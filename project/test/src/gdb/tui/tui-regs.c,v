head	1.52;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.48.2.1
	gdb_7_6-2013-04-26-release:1.48
	gdb_7_6-branch:1.48.0.2
	gdb_7_6-2013-03-12-branchpoint:1.48
	gdb_7_5_1-2012-11-29-release:1.47
	gdb_7_5-2012-08-17-release:1.47
	gdb_7_5-branch:1.47.0.2
	gdb_7_5-2012-07-18-branchpoint:1.47
	gdb_7_4_1-2012-04-26-release:1.45.2.1
	gdb_7_4-2012-01-24-release:1.45.2.1
	gdb_7_4-branch:1.45.0.2
	gdb_7_4-2011-12-13-branchpoint:1.45
	gdb_7_3_1-2011-09-04-release:1.44.2.1
	gdb_7_3-2011-07-26-release:1.44
	gdb_7_3-branch:1.44.0.2
	gdb_7_3-2011-04-01-branchpoint:1.44
	gdb_7_2-2010-09-02-release:1.40
	gdb_7_2-branch:1.40.0.2
	gdb_7_2-2010-07-07-branchpoint:1.40
	gdb_7_1-2010-03-18-release:1.36
	gdb_7_1-branch:1.36.0.2
	gdb_7_1-2010-02-18-branchpoint:1.36
	gdb_7_0_1-2009-12-22-release:1.35
	gdb_7_0-2009-10-06-release:1.35
	gdb_7_0-branch:1.35.0.4
	gdb_7_0-2009-09-16-branchpoint:1.35
	arc-sim-20090309:1.30
	msnyder-checkpoint-072509-branch:1.35.0.2
	msnyder-checkpoint-072509-branchpoint:1.35
	arc-insight_6_8-branch:1.30.0.12
	arc-insight_6_8-branchpoint:1.30
	insight_6_8-branch:1.30.0.10
	insight_6_8-branchpoint:1.30
	reverse-20081226-branch:1.31.0.4
	reverse-20081226-branchpoint:1.31
	multiprocess-20081120-branch:1.31.0.2
	multiprocess-20081120-branchpoint:1.31
	reverse-20080930-branch:1.30.0.8
	reverse-20080930-branchpoint:1.30
	reverse-20080717-branch:1.30.0.6
	reverse-20080717-branchpoint:1.30
	msnyder-reverse-20080609-branch:1.30.0.4
	msnyder-reverse-20080609-branchpoint:1.30
	drow-reverse-20070409-branch:1.21.0.2
	drow-reverse-20070409-branchpoint:1.21
	gdb_6_8-2008-03-27-release:1.30
	gdb_6_8-branch:1.30.0.2
	gdb_6_8-2008-02-26-branchpoint:1.30
	gdb_6_7_1-2007-10-29-release:1.29
	gdb_6_7-2007-10-10-release:1.29
	gdb_6_7-branch:1.29.0.2
	gdb_6_7-2007-09-07-branchpoint:1.29
	insight_6_6-20070208-release:1.19
	gdb_6_6-2006-12-18-release:1.19
	gdb_6_6-branch:1.19.0.18
	gdb_6_6-2006-11-15-branchpoint:1.19
	insight_6_5-20061003-release:1.19
	gdb-csl-symbian-6_4_50_20060226-12:1.19
	gdb-csl-sourcerygxx-3_4_4-25:1.18
	nickrob-async-20060828-mergepoint:1.19
	gdb-csl-symbian-6_4_50_20060226-11:1.19
	gdb-csl-sourcerygxx-4_1-17:1.19
	gdb-csl-20060226-branch-local-2:1.19
	gdb-csl-sourcerygxx-4_1-14:1.19
	gdb-csl-sourcerygxx-4_1-13:1.19
	gdb-csl-sourcerygxx-4_1-12:1.19
	gdb-csl-sourcerygxx-3_4_4-21:1.19
	gdb_6_5-20060621-release:1.19
	gdb-csl-sourcerygxx-4_1-9:1.19
	gdb-csl-sourcerygxx-4_1-8:1.19
	gdb-csl-sourcerygxx-4_1-7:1.19
	gdb-csl-arm-2006q1-6:1.19
	gdb-csl-sourcerygxx-4_1-6:1.19
	gdb-csl-symbian-6_4_50_20060226-10:1.19
	gdb-csl-symbian-6_4_50_20060226-9:1.19
	gdb-csl-symbian-6_4_50_20060226-8:1.19
	gdb-csl-coldfire-4_1-11:1.19
	gdb-csl-sourcerygxx-3_4_4-19:1.19
	gdb-csl-coldfire-4_1-10:1.19
	gdb_6_5-branch:1.19.0.16
	gdb_6_5-2006-05-14-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-5:1.19
	nickrob-async-20060513-branch:1.19.0.14
	nickrob-async-20060513-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-4:1.19
	msnyder-reverse-20060502-branch:1.19.0.12
	msnyder-reverse-20060502-branchpoint:1.19
	gdb-csl-morpho-4_1-4:1.19
	gdb-csl-sourcerygxx-3_4_4-17:1.19
	readline_5_1-import-branch:1.19.0.10
	readline_5_1-import-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.19
	gdb-csl-symbian-20060226-branch:1.19.0.8
	gdb-csl-symbian-20060226-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.19
	msnyder-reverse-20060331-branch:1.19.0.6
	msnyder-reverse-20060331-branchpoint:1.19
	gdb-csl-available-20060303-branch:1.19.0.4
	gdb-csl-available-20060303-branchpoint:1.19
	gdb-csl-20060226-branch:1.19.0.2
	gdb-csl-20060226-branchpoint:1.19
	gdb_6_4-20051202-release:1.18
	msnyder-fork-checkpoint-branch:1.18.0.10
	msnyder-fork-checkpoint-branchpoint:1.18
	gdb-csl-gxxpro-6_3-branch:1.18.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.18
	gdb_6_4-branch:1.18.0.6
	gdb_6_4-2005-11-01-branchpoint:1.18
	gdb-csl-arm-20051020-branch:1.18.0.4
	gdb-csl-arm-20051020-branchpoint:1.18
	msnyder-tracepoint-checkpoint-branch:1.18.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.18
	gdb-csl-arm-20050325-2005-q1b:1.17
	gdb-csl-arm-20050325-2005-q1a:1.17
	csl-arm-20050325-branch:1.17.0.2
	csl-arm-20050325-branchpoint:1.17
	gdb-post-i18n-errorwarning-20050211:1.14
	gdb-pre-i18n-errorwarning-20050211:1.14
	gdb_6_3-20041109-release:1.14
	gdb_6_3-branch:1.14.0.4
	gdb_6_3-20041019-branchpoint:1.14
	drow_intercu-merge-20040921:1.14
	drow_intercu-merge-20040915:1.14
	jimb-gdb_6_2-e500-branch:1.14.0.6
	jimb-gdb_6_2-e500-branchpoint:1.14
	gdb_6_2-20040730-release:1.14
	gdb_6_2-branch:1.14.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.14
	gdb_6_1_1-20040616-release:1.12.2.2
	gdb_6_1-2004-04-05-release:1.12.2.2
	drow_intercu-merge-20040402:1.14
	drow_intercu-merge-20040327:1.13
	ezannoni_pie-20040323-branch:1.13.0.4
	ezannoni_pie-20040323-branchpoint:1.13
	ezannoni_pie-20030916-branch:1.13.0.2
	cagney_tramp-20040321-mergepoint:1.13
	cagney_tramp-20040309-branch:1.12.0.4
	cagney_tramp-20040309-branchpoint:1.12
	gdb_6_1-branch:1.12.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.12
	drow_intercu-20040221-branch:1.11.0.4
	drow_intercu-20040221-branchpoint:1.11
	cagney_bfdfile-20040213-branch:1.11.0.2
	cagney_bfdfile-20040213-branchpoint:1.11
	drow-cplus-branch:1.10.0.2
	drow-cplus-merge-20040208:1.8
	carlton_dictionary-branch:1.2.0.4
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.2
	cagney_bigcore-20040122-branchpoint:1.2;
locks; strict;
comment	@ * @;


1.52
date	2013.09.05.11.50.48;	author palves;	state Exp;
branches;
next	1.51;

1.51
date	2013.09.05.11.20.16;	author palves;	state Exp;
branches;
next	1.50;

1.50
date	2013.07.01.10.09.27;	author palves;	state Exp;
branches;
next	1.49;

1.49
date	2013.06.28.12.36.48;	author palves;	state Exp;
branches;
next	1.48;

1.48
date	2013.01.01.06.41.30;	author brobecke;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2012.03.01.21.08.07;	author palves;	state Exp;
branches;
next	1.46;

1.46
date	2012.01.04.08.27.59;	author brobecke;	state Exp;
branches;
next	1.45;

1.45
date	2011.08.12.17.04.32;	author palves;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2011.03.01.00.11.07;	author msnyder;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2011.01.25.18.18.15;	author palves;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.06.00.57.05;	author msnyder;	state Exp;
branches;
next	1.41;

1.41
date	2011.01.01.15.33.53;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2010.05.17.22.21.43;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2010.05.05.22.53.54;	author msnyder;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.16.04.34.31;	author brobecke;	state Exp;
branches;
next	1.37;

1.37
date	2010.04.13.12.11.09;	author muller;	state Exp;
branches;
next	1.36;

1.36
date	2010.01.01.07.32.07;	author brobecke;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.02.17.02.35;	author uweigand;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.17.18.36.44;	author uweigand;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.21.16.14.50;	author palves;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.03.05.58.08;	author brobecke;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.28.17.19.58;	author tromey;	state Exp;
branches;
next	1.30;

1.30
date	2008.01.01.22.53.22;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2007.08.23.18.08.50;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.15.00.19.44;	author msnyder;	state Exp;
branches;
next	1.27;

1.27
date	2007.08.14.23.50.39;	author msnyder;	state Exp;
branches;
next	1.26;

1.26
date	2007.08.14.21.39.22;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.14.21.20.09;	author msnyder;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.14.20.23.29;	author msnyder;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.31.17.32.22;	author uweigand;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.06.19.37.31;	author uweigand;	state Exp;
branches;
next	1.21;

1.21
date	2007.01.21.17.37.51;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.09.17.59.15;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.23.19.10.03;	author eliz;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.22.14.53.35;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.15.15.49.27;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.14.18.10.11;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.12.00.39.24;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.28.10.18.07;	author ciceron;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.13.14.14.01;	author ciceron;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2004.02.25.01.10.01;	author brobecke;	state Exp;
branches
	1.12.2.1
	1.12.4.1;
next	1.11;

1.11
date	2004.02.10.19.08.16;	author cagney;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2004.02.08.01.32.26;	author cagney;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2004.02.08.00.05.16;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.07.20.57.02;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.07.17.46.14;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.07.16.31.22;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.07.04.40.36;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.07.00.23.56;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.06.23.55.34;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.19.16.06.04;	author cagney;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2004.01.19.04.31.51;	author cagney;	state Exp;
branches;
next	;

1.48.2.1
date	2013.06.28.12.39.00;	author palves;	state Exp;
branches;
next	;

1.45.2.1
date	2012.01.06.04.54.35;	author brobecke;	state Exp;
branches;
next	;

1.44.2.1
date	2011.08.12.17.06.26;	author palves;	state Exp;
branches;
next	;

1.13.2.1
date	2004.03.23.20.09.16;	author ezannoni;	state Exp;
branches;
next	;

1.12.2.1
date	2004.03.13.14.21.00;	author ciceron;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2004.03.28.10.19.46;	author ciceron;	state Exp;
branches;
next	;

1.12.4.1
date	2004.03.21.23.57.42;	author cagney;	state Exp;
branches;
next	;

1.11.4.1
date	2004.03.27.17.38.05;	author drow;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2004.04.02.16.47.51;	author drow;	state Exp;
branches;
next	;

1.10.2.1
date	2004.02.09.19.43.56;	author drow;	state Exp;
branches;
next	;

1.2.4.1
date	2004.01.26.19.11.45;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.52
log
@[TUI] Rewrite register-changed decision bits.

I stumbled on the TUI's register-changed decision code before (used to
decided whether the register should be highlighted in the register
window), for it is trying to compare all the different possible states
and contents or previous/current register contents, and as such may
need updating whenever the value machinery changes to have more state.
It's just much simpler and more future proof to compare the
previous/current printable representation instead.

The bit in tui_register_format that returns early if the register has
no name gets a bit in the way of the new prototype (what to return in
that case? NULL, empty string, etc.?).  Fortunately, that check isn't
really necessary.  All the callers will have already skipped unnamed
registers.

gdb/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* tui/tui-regs.c (tui_register_format): Don't look at the
	register's name here.  Return string representing register
	value instead of storing it in the data element.
	(tui_get_register): Compare register string representations
	instead of register value states and contents.
@
text
@/* TUI display registers in window.

   Copyright (C) 1998-2013 Free Software Foundation, Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "tui/tui.h"
#include "tui/tui-data.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "frame.h"
#include "regcache.h"
#include "inferior.h"
#include "target.h"
#include "gdb_string.h"
#include "tui/tui-layout.h"
#include "tui/tui-win.h"
#include "tui/tui-windata.h"
#include "tui/tui-wingeneral.h"
#include "tui/tui-file.h"
#include "tui/tui-regs.h"
#include "reggroups.h"
#include "valprint.h"

#include "gdb_curses.h"


/*****************************************
** STATIC LOCAL FUNCTIONS FORWARD DECLS    **
******************************************/
static void
tui_display_register (struct tui_data_element *data,
                      struct tui_gen_win_info *win_info);

static enum tui_status tui_show_register_group (struct reggroup *group,
						struct frame_info *frame,
						int refresh_values_only);

static enum tui_status tui_get_register (struct frame_info *frame,
					 struct tui_data_element *data,
					 int regnum, int *changedp);

static void tui_scroll_regs_forward_command (char *, int);
static void tui_scroll_regs_backward_command (char *, int);



/*****************************************
** PUBLIC FUNCTIONS                     **
******************************************/

/* Answer the number of the last line in the regs display.  If there
   are no registers (-1) is returned.  */
int
tui_last_regs_line_no (void)
{
  int num_lines = (-1);

  if (TUI_DATA_WIN->detail.data_display_info.regs_content_count > 0)
    {
      num_lines = (TUI_DATA_WIN->detail.data_display_info.regs_content_count /
		  TUI_DATA_WIN->detail.data_display_info.regs_column_count);
      if (TUI_DATA_WIN->detail.data_display_info.regs_content_count %
	  TUI_DATA_WIN->detail.data_display_info.regs_column_count)
	num_lines++;
    }
  return num_lines;
}


/* Answer the line number that the register element at element_no is
   on.  If element_no is greater than the number of register elements
   there are, -1 is returned.  */
int
tui_line_from_reg_element_no (int element_no)
{
  if (element_no < TUI_DATA_WIN->detail.data_display_info.regs_content_count)
    {
      int i, line = (-1);

      i = 1;
      while (line == (-1))
	{
	  if (element_no <
	      (TUI_DATA_WIN->detail.data_display_info.regs_column_count * i))
	    line = i - 1;
	  else
	    i++;
	}

      return line;
    }
  else
    return (-1);
}


/* Answer the index of the first element in line_no.  If line_no is
   past the register area (-1) is returned.  */
int
tui_first_reg_element_no_inline (int line_no)
{
  if ((line_no * TUI_DATA_WIN->detail.data_display_info.regs_column_count)
      <= TUI_DATA_WIN->detail.data_display_info.regs_content_count)
    return ((line_no + 1) *
	    TUI_DATA_WIN->detail.data_display_info.regs_column_count) -
      TUI_DATA_WIN->detail.data_display_info.regs_column_count;
  else
    return (-1);
}


/* Show the registers of the given group in the data window
   and refresh the window.  */
void
tui_show_registers (struct reggroup *group)
{
  enum tui_status ret = TUI_FAILURE;
  struct tui_data_info *display_info;

  /* Make sure the curses mode is enabled.  */
  tui_enable ();

  /* Make sure the register window is visible.  If not, select an
     appropriate layout.  */
  if (TUI_DATA_WIN == NULL || !TUI_DATA_WIN->generic.is_visible)
    tui_set_layout_for_display_command (DATA_NAME);

  display_info = &TUI_DATA_WIN->detail.data_display_info;
  if (group == 0)
    group = general_reggroup;

  /* Say that registers should be displayed, even if there is a
     problem.  */
  display_info->display_regs = TRUE;

  if (target_has_registers && target_has_stack && target_has_memory)
    {
      ret = tui_show_register_group (group, get_selected_frame (NULL),
                                     group == display_info->current_group);
    }
  if (ret == TUI_FAILURE)
    {
      display_info->current_group = 0;
      tui_erase_data_content (NO_REGS_STRING);
    }
  else
    {
      int i;

      /* Clear all notation of changed values.  */
      for (i = 0; i < display_info->regs_content_count; i++)
	{
	  struct tui_gen_win_info *data_item_win;
          struct tui_win_element *win;

	  data_item_win = &display_info->regs_content[i]
            ->which_element.data_window;
          win = (struct tui_win_element *) data_item_win->content[0];
          win->which_element.data.highlight = FALSE;
	}
      display_info->current_group = group;
      tui_display_all_data ();
    }
}


/* Set the data window to display the registers of the register group
   using the given frame.  Values are refreshed only when
   refresh_values_only is TRUE.  */

static enum tui_status
tui_show_register_group (struct reggroup *group,
                         struct frame_info *frame, 
			 int refresh_values_only)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum tui_status ret = TUI_FAILURE;
  int nr_regs;
  int allocated_here = FALSE;
  int regnum, pos;
  char title[80];
  struct tui_data_info *display_info = &TUI_DATA_WIN->detail.data_display_info;

  /* Make a new title showing which group we display.  */
  snprintf (title, sizeof (title) - 1, "Register group: %s",
            reggroup_name (group));
  xfree (TUI_DATA_WIN->generic.title);
  TUI_DATA_WIN->generic.title = xstrdup (title);

  /* See how many registers must be displayed.  */
  nr_regs = 0;
  for (regnum = 0;
       regnum < gdbarch_num_regs (gdbarch)
		+ gdbarch_num_pseudo_regs (gdbarch);
       regnum++)
    {
      const char *name;

      /* Must be in the group.  */
      if (!gdbarch_register_reggroup_p (gdbarch, regnum, group))
	continue;

      /* If the register name is empty, it is undefined for this
	 processor, so don't display anything.  */
      name = gdbarch_register_name (gdbarch, regnum);
      if (name == 0 || *name == '\0')
	continue;

      nr_regs++;
    }

  if (display_info->regs_content_count > 0 && !refresh_values_only)
    {
      tui_free_data_content (display_info->regs_content,
                             display_info->regs_content_count);
      display_info->regs_content_count = 0;
    }

  if (display_info->regs_content_count <= 0)
    {
      display_info->regs_content = tui_alloc_content (nr_regs, DATA_WIN);
      allocated_here = TRUE;
      refresh_values_only = FALSE;
    }

  if (display_info->regs_content != (tui_win_content) NULL)
    {
      if (!refresh_values_only || allocated_here)
	{
	  TUI_DATA_WIN->generic.content = (void*) NULL;
	  TUI_DATA_WIN->generic.content_size = 0;
	  tui_add_content_elements (&TUI_DATA_WIN->generic, nr_regs);
	  display_info->regs_content
            = (tui_win_content) TUI_DATA_WIN->generic.content;
	  display_info->regs_content_count = nr_regs;
	}

      /* Now set the register names and values.  */
      pos = 0;
      for (regnum = 0;
	   regnum < gdbarch_num_regs (gdbarch)
		    + gdbarch_num_pseudo_regs (gdbarch);
	   regnum++)
        {
	  struct tui_gen_win_info *data_item_win;
          struct tui_data_element *data;
          const char *name;

          /* Must be in the group.  */
          if (!gdbarch_register_reggroup_p (gdbarch, regnum, group))
            continue;

	  /* If the register name is empty, it is undefined for this
	     processor, so don't display anything.  */
	  name = gdbarch_register_name (gdbarch, regnum);
	  if (name == 0 || *name == '\0')
	    continue;

	  data_item_win =
            &display_info->regs_content[pos]->which_element.data_window;
          data = &((struct tui_win_element *)
		   data_item_win->content[0])->which_element.data;
          if (data)
            {
              if (!refresh_values_only)
                {
                  data->item_no = regnum;
                  data->name = name;
                  data->highlight = FALSE;
                }
              tui_get_register (frame, data, regnum, 0);
            }
          pos++;
	}

      TUI_DATA_WIN->generic.content_size =
	display_info->regs_content_count + display_info->data_content_count;
      ret = TUI_SUCCESS;
    }

  return ret;
}

/* Function to display the registers in the content from
   'start_element_no' until the end of the register content or the end
   of the display height.  No checking for displaying past the end of
   the registers is done here.  */
void
tui_display_registers_from (int start_element_no)
{
  struct tui_data_info *display_info = &TUI_DATA_WIN->detail.data_display_info;

  if (display_info->regs_content != (tui_win_content) NULL 
      && display_info->regs_content_count > 0)
    {
      int i = start_element_no;
      int j, item_win_width, cur_y;

      int max_len = 0;
      for (i = 0; i < display_info->regs_content_count; i++)
        {
          struct tui_data_element *data;
          struct tui_gen_win_info *data_item_win;
          char *p;
          int len;

          data_item_win
	    = &display_info->regs_content[i]->which_element.data_window;
          data = &((struct tui_win_element *)
                   data_item_win->content[0])->which_element.data;
          len = 0;
          p = data->content;
          if (p != 0)
            while (*p)
              {
                if (*p++ == '\t')
                  len = 8 * ((len / 8) + 1);
                else
                  len++;
              }

          if (len > max_len)
            max_len = len;
        }
      item_win_width = max_len + 1;
      i = start_element_no;

      display_info->regs_column_count =
        (TUI_DATA_WIN->generic.width - 2) / item_win_width;
      if (display_info->regs_column_count == 0)
        display_info->regs_column_count = 1;
      item_win_width =
        (TUI_DATA_WIN->generic.width - 2) / display_info->regs_column_count;

      /* Now create each data "sub" window, and write the display into
	 it.  */
      cur_y = 1;
      while (i < display_info->regs_content_count 
	     && cur_y <= TUI_DATA_WIN->generic.viewport_height)
	{
	  for (j = 0;
	       j < display_info->regs_column_count
		 && i < display_info->regs_content_count;
	       j++)
	    {
	      struct tui_gen_win_info *data_item_win;
	      struct tui_data_element *data_element_ptr;

	      /* Create the window if necessary.  */
	      data_item_win = &display_info->regs_content[i]
                ->which_element.data_window;
	      data_element_ptr = &((struct tui_win_element *)
				   data_item_win->content[0])->which_element.data;
              if (data_item_win->handle != (WINDOW*) NULL
                  && (data_item_win->height != 1
                      || data_item_win->width != item_win_width
                      || data_item_win->origin.x != (item_win_width * j) + 1
                      || data_item_win->origin.y != cur_y))
                {
                  tui_delete_win (data_item_win->handle);
                  data_item_win->handle = 0;
                }
                  
	      if (data_item_win->handle == (WINDOW *) NULL)
		{
		  data_item_win->height = 1;
		  data_item_win->width = item_win_width;
		  data_item_win->origin.x = (item_win_width * j) + 1;
		  data_item_win->origin.y = cur_y;
		  tui_make_window (data_item_win, DONT_BOX_WINDOW);
                  scrollok (data_item_win->handle, FALSE);
		}
              touchwin (data_item_win->handle);

	      /* Get the printable representation of the register
                 and display it.  */
              tui_display_register (data_element_ptr, data_item_win);
	      i++;		/* Next register.  */
	    }
	  cur_y++;		/* Next row.  */
	}
    }
}


/* Function to display the registers in the content from
   'start_element_no' on 'start_line_no' until the end of the register
   content or the end of the display height.  This function checks
   that we won't display off the end of the register display.  */
static void
tui_display_reg_element_at_line (int start_element_no,
				 int start_line_no)
{
  if (TUI_DATA_WIN->detail.data_display_info.regs_content
      != (tui_win_content) NULL
      && TUI_DATA_WIN->detail.data_display_info.regs_content_count > 0)
    {
      int element_no = start_element_no;

      if (start_element_no != 0 && start_line_no != 0)
	{
	  int last_line_no, first_line_on_last_page;

	  last_line_no = tui_last_regs_line_no ();
	  first_line_on_last_page
	    = last_line_no - (TUI_DATA_WIN->generic.height - 2);
	  if (first_line_on_last_page < 0)
	    first_line_on_last_page = 0;

	  /* If there is no other data displayed except registers, and
	     the element_no causes us to scroll past the end of the
	     registers, adjust what element to really start the
	     display at.  */
	  if (TUI_DATA_WIN->detail.data_display_info.data_content_count <= 0
	      && start_line_no > first_line_on_last_page)
	    element_no
	      = tui_first_reg_element_no_inline (first_line_on_last_page);
	}
      tui_display_registers_from (element_no);
    }
}



/* Function to display the registers starting at line line_no in the
   data window.  Answers the line number that the display actually
   started from.  If nothing is displayed (-1) is returned.  */
int
tui_display_registers_from_line (int line_no, 
				 int force_display)
{
  if (TUI_DATA_WIN->detail.data_display_info.regs_content_count > 0)
    {
      int line, element_no;

      if (line_no < 0)
	line = 0;
      else if (force_display)
	{ /* If we must display regs (force_display is true), then
	     make sure that we don't display off the end of the
	     registers.  */
	  if (line_no >= tui_last_regs_line_no ())
	    {
	      if ((line = tui_line_from_reg_element_no (
		 TUI_DATA_WIN->detail.data_display_info.regs_content_count - 1)) < 0)
		line = 0;
	    }
	  else
	    line = line_no;
	}
      else
	line = line_no;

      element_no = tui_first_reg_element_no_inline (line);
      if (element_no
	  < TUI_DATA_WIN->detail.data_display_info.regs_content_count)
	tui_display_reg_element_at_line (element_no, line);
      else
	line = (-1);

      return line;
    }

  return (-1);			/* Nothing was displayed.  */
}


/* This function check all displayed registers for changes in values,
   given a particular frame.  If the values have changed, they are
   updated with the new value and highlighted.  */
void
tui_check_register_values (struct frame_info *frame)
{
  if (TUI_DATA_WIN != NULL
      && TUI_DATA_WIN->generic.is_visible)
    {
      struct tui_data_info *display_info
        = &TUI_DATA_WIN->detail.data_display_info;

      if (display_info->regs_content_count <= 0 
	  && display_info->display_regs)
	tui_show_registers (display_info->current_group);
      else
	{
	  int i;

	  for (i = 0; (i < display_info->regs_content_count); i++)
	    {
	      struct tui_data_element *data;
	      struct tui_gen_win_info *data_item_win_ptr;
	      int was_hilighted;

	      data_item_win_ptr = &display_info->regs_content[i]->
                which_element.data_window;
	      data = &((struct tui_win_element *)
                       data_item_win_ptr->content[0])->which_element.data;
	      was_hilighted = data->highlight;

              tui_get_register (frame, data,
                                data->item_no, &data->highlight);

	      if (data->highlight || was_hilighted)
		{
                  tui_display_register (data, data_item_win_ptr);
		}
	    }
	}
    }
}

/* Display a register in a window.  If hilite is TRUE, then the value
   will be displayed in reverse video.  */
static void
tui_display_register (struct tui_data_element *data,
                      struct tui_gen_win_info *win_info)
{
  if (win_info->handle != (WINDOW *) NULL)
    {
      int i;

      if (data->highlight)
	/* We ignore the return value, casting it to void in order to avoid
	   a compiler warning.  The warning itself was introduced by a patch
	   to ncurses 5.7 dated 2009-08-29, changing this macro to expand
	   to code that causes the compiler to generate an unused-value
	   warning.  */
	(void) wstandout (win_info->handle);
      
      wmove (win_info->handle, 0, 0);
      for (i = 1; i < win_info->width; i++)
        waddch (win_info->handle, ' ');
      wmove (win_info->handle, 0, 0);
      if (data->content)
        waddstr (win_info->handle, data->content);

      if (data->highlight)
	/* We ignore the return value, casting it to void in order to avoid
	   a compiler warning.  The warning itself was introduced by a patch
	   to ncurses 5.7 dated 2009-08-29, changing this macro to expand
	   to code that causes the compiler to generate an unused-value
	   warning.  */
	(void) wstandend (win_info->handle);
      tui_refresh_win (win_info);
    }
}

static void
tui_reg_next_command (char *arg, int from_tty)
{
  struct gdbarch *gdbarch = get_current_arch ();

  if (TUI_DATA_WIN != 0)
    {
      struct reggroup *group
        = TUI_DATA_WIN->detail.data_display_info.current_group;

      group = reggroup_next (gdbarch, group);
      if (group == 0)
        group = reggroup_next (gdbarch, 0);

      if (group)
        tui_show_registers (group);
    }
}

static void
tui_reg_float_command (char *arg, int from_tty)
{
  tui_show_registers (float_reggroup);
}

static void
tui_reg_general_command (char *arg, int from_tty)
{
  tui_show_registers (general_reggroup);
}

static void
tui_reg_system_command (char *arg, int from_tty)
{
  tui_show_registers (system_reggroup);
}

static struct cmd_list_element *tuireglist;

static void
tui_reg_command (char *args, int from_tty)
{
  printf_unfiltered (_("\"tui reg\" must be followed by the name of a "
                     "tui reg command.\n"));
  help_list (tuireglist, "tui reg ", -1, gdb_stdout);
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_tui_regs;

void
_initialize_tui_regs (void)
{
  struct cmd_list_element **tuicmd;

  tuicmd = tui_get_cmd_list ();

  add_prefix_cmd ("reg", class_tui, tui_reg_command,
                  _("TUI commands to control the register window."),
                  &tuireglist, "tui reg ", 0,
                  tuicmd);

  add_cmd ("float", class_tui, tui_reg_float_command,
           _("Display only floating point registers."),
           &tuireglist);
  add_cmd ("general", class_tui, tui_reg_general_command,
           _("Display only general registers."),
           &tuireglist);
  add_cmd ("system", class_tui, tui_reg_system_command,
           _("Display only system registers."),
           &tuireglist);
  add_cmd ("next", class_tui, tui_reg_next_command,
           _("Display next register group."),
           &tuireglist);

  if (xdb_commands)
    {
      add_com ("fr", class_tui, tui_reg_float_command,
	       _("Display only floating point registers\n"));
      add_com ("gr", class_tui, tui_reg_general_command,
	       _("Display only general registers\n"));
      add_com ("sr", class_tui, tui_reg_system_command,
	       _("Display only special registers\n"));
      add_com ("+r", class_tui, tui_scroll_regs_forward_command,
	       _("Scroll the registers window forward\n"));
      add_com ("-r", class_tui, tui_scroll_regs_backward_command,
	       _("Scroll the register window backward\n"));
    }
}


/*****************************************
** STATIC LOCAL FUNCTIONS                 **
******************************************/

static void
tui_restore_gdbout (void *ui)
{
  ui_file_delete (gdb_stdout);
  gdb_stdout = (struct ui_file*) ui;
  pagination_enabled = 1;
}

/* Get the register from the frame and return a printable
   representation of it.  */

static char *
tui_register_format (struct frame_info *frame, int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct ui_file *stream;
  struct ui_file *old_stdout;
  struct cleanup *cleanups;
  char *p, *s;
  char *ret;

  pagination_enabled = 0;
  old_stdout = gdb_stdout;
  stream = tui_sfileopen (256);
  gdb_stdout = stream;
  cleanups = make_cleanup (tui_restore_gdbout, (void*) old_stdout);
  gdbarch_print_registers_info (gdbarch, stream, frame, regnum, 1);

  /* Save formatted output in the buffer.  */
  p = tui_file_get_strbuf (stream);

  /* Remove the possible \n.  */
  s = strrchr (p, '\n');
  if (s && s[1] == 0)
    *s = 0;

  ret = xstrdup (p);
  do_cleanups (cleanups);

  return ret;
}

/* Get the register value from the given frame and format it for the
   display.  When changep is set, check if the new register value has
   changed with respect to the previous call.  */
static enum tui_status
tui_get_register (struct frame_info *frame,
                  struct tui_data_element *data, 
		  int regnum, int *changedp)
{
  enum tui_status ret = TUI_FAILURE;

  if (changedp)
    *changedp = FALSE;
  if (target_has_registers)
    {
      char *prev_content = data->content;

      data->content = tui_register_format (frame, regnum);

      if (changedp != NULL
	  && strcmp (prev_content, data->content) != 0)
	*changedp = 1;

      xfree (prev_content);

      ret = TUI_SUCCESS;
    }
  return ret;
}

static void
tui_scroll_regs_forward_command (char *arg, int from_tty)
{
  tui_scroll (FORWARD_SCROLL, TUI_DATA_WIN, 1);
}


static void
tui_scroll_regs_backward_command (char *arg, int from_tty)
{
  tui_scroll (BACKWARD_SCROLL, TUI_DATA_WIN, 1);
}
@


1.51
log
@[PR tui/15933] TUI shows registers of the wrong frame the first time

I've stumbled on this by inspection.

When the TUI's register window is first displayed, it always shows the
registers of the current frame, instead of of the selected frame,
which is obviously bogus.

E.g.,

 (gdb) step             # into "function"
 (gdb) up
 (gdb) tui reg general  # or C-x 2, C-x 2

shows the registers of "function", rather than the caller's.

A subsequent:

 (gdb) frame

or

 (gdb) down
 (gdb) up

can be used as workaround to "fix" it.

gdb/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	PR tui/15933
	* tui/tui-regs.c (tui_show_registers): Show registers of the
	selected frame, not the current frame.
@
text
@a60 3
static void tui_register_format (struct frame_info *,
				 struct tui_data_element*, int);

d669 5
a673 6
/* Get the register from the frame and make a printable representation
   of it in the data element.  */
static void
tui_register_format (struct frame_info *frame,
                     struct tui_data_element *data_element, 
		     int regnum)
a677 1
  const char *name;
d680 1
a680 4

  name = gdbarch_register_name (gdbarch, regnum);
  if (name == 0 || *name == '\0')
    return;
d697 1
a697 2
  xfree (data_element->content);
  data_element->content = xstrdup (p);
d699 2
d717 1
a717 8
      struct value *old_val = data->value;

      data->value = get_frame_register_value (frame, regnum);
      release_value (data->value);
      if (changedp)
	{
	  struct gdbarch *gdbarch = get_frame_arch (frame);
	  int size = register_size (gdbarch, regnum);
d719 1
a719 12
	  /* We only know whether a value chunk is available if we've
	     tried to read it.  */
	  if (value_lazy (data->value))
	    value_fetch_lazy (data->value);
	  if (value_lazy (old_val))
	    value_fetch_lazy (old_val);

	  if (value_optimized_out (data->value) != value_optimized_out (old_val)
	      || !value_available_contents_eq (data->value, 0,
					       old_val, 0, size))
	    *changedp = TRUE;
	}
d721 3
a723 1
      value_free (old_val);
d725 1
a725 3
      /* Reformat the data content if the value changed.  */
      if (changedp == 0 || *changedp == TRUE)
	tui_register_format (frame, data, regnum);
@


1.50
log
@Delete pagination_enabled extern declaration in tui/tui-regs.c.

It's declared in utils.h.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* tui/tui-regs.c (pagination_enabled): Delete declaration.
@
text
@d160 1
a160 1
      ret = tui_show_register_group (group, get_current_frame (),
@


1.49
log
@[PR tui/14880] Fetch values before comparing their contents.

PR tui/14880 shows a reproducer that triggers this assertion:

  int
  value_available_contents_eq (const struct value *val1, int offset1,
  			     const struct value *val2, int offset2,
  			     int length)
  {
    int idx1 = 0, idx2 = 0;

    /* This routine is used by printing routines, where we should
       already have read the value.  Note that we only know whether a
       value chunk is available if we've tried to read it.  */
    gdb_assert (!val1->lazy && !val2->lazy);

(top-gdb) bt
#0  internal_error (file=0x88a26c "../../src/gdb/value.c", line=549, string=0x88a220 "%s: Assertion `%s' failed.") at ../../src/gdb/utils.c:844
#1  0x000000000057b9cd in value_available_contents_eq (val1=0x10fa900, offset1=0, val2=0x10f9e10, offset2=0, length=8) at ../../src/gdb/value.c:549
#2  0x00000000004fd756 in tui_get_register (frame=0xd5c430, data=0x109a548, regnum=0, changedp=0x109a560) at ../../src/gdb/tui/tui-regs.c:736
#3  0x00000000004fd111 in tui_check_register_values (frame=0xd5c430) at ../../src/gdb/tui/tui-regs.c:521
#4  0x0000000000501884 in tui_check_data_values (frame=0xd5c430) at ../../src/gdb/tui/tui-windata.c:234
#5  0x00000000004f976f in tui_selected_frame_level_changed_hook (level=1) at ../../src/gdb/tui/tui-hooks.c:222
#6  0x00000000006f0681 in select_frame (fi=0xd5c430) at ../../src/gdb/frame.c:1490
#7  0x00000000005dd94b in up_silently_base (count_exp=0x0) at ../../src/gdb/stack.c:2268
#8  0x00000000005dd985 in up_command (count_exp=0x0, from_tty=1) at ../../src/gdb/stack.c:2280
#9  0x00000000004dc5cf in do_cfunc (c=0xd3f720, args=0x0, from_tty=1) at ../../src/gdb/cli/cli-decode.c:113
#10 0x00000000004df664 in cmd_func (cmd=0xd3f720, args=0x0, from_tty=1) at ../../src/gdb/cli/cli-decode.c:1888
#11 0x00000000006e43e1 in execute_command (p=0xc7e6c2 "", from_tty=1) at ../../src/gdb/top.c:489

The fix is to fetch the value before comparing the contents.  The
comment additions to value.h explain why it can't be
value_available_contents_eq itself that fetches the contents.

Tested on x86_64 Fedora 17.

gdb/
2013-06-28  Pedro Alves  <palves@@redhat.com>

	PR tui/14880
	* tui/tui-regs.c (tui_get_register): Fetch register value contents
	before checking whether they're available.
	* value.c (value_available_contents_eq): Change comment.
	* value.h (value_available_contents_eq): Expand comment.
@
text
@a663 2
extern int pagination_enabled;

@


1.48
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d735 7
@


1.48.2.1
log
@[PR tui/14880] Fetch values before comparing their contents.

PR tui/14880 shows a reproducer that triggers this assertion:

  int
  value_available_contents_eq (const struct value *val1, int offset1,
  			     const struct value *val2, int offset2,
  			     int length)
  {
    int idx1 = 0, idx2 = 0;

    /* This routine is used by printing routines, where we should
       already have read the value.  Note that we only know whether a
       value chunk is available if we've tried to read it.  */
    gdb_assert (!val1->lazy && !val2->lazy);

(top-gdb) bt
#0  internal_error (file=0x88a26c "../../src/gdb/value.c", line=549, string=0x88a220 "%s: Assertion `%s' failed.") at ../../src/gdb/utils.c:844
#1  0x000000000057b9cd in value_available_contents_eq (val1=0x10fa900, offset1=0, val2=0x10f9e10, offset2=0, length=8) at ../../src/gdb/value.c:549
#2  0x00000000004fd756 in tui_get_register (frame=0xd5c430, data=0x109a548, regnum=0, changedp=0x109a560) at ../../src/gdb/tui/tui-regs.c:736
#3  0x00000000004fd111 in tui_check_register_values (frame=0xd5c430) at ../../src/gdb/tui/tui-regs.c:521
#4  0x0000000000501884 in tui_check_data_values (frame=0xd5c430) at ../../src/gdb/tui/tui-windata.c:234
#5  0x00000000004f976f in tui_selected_frame_level_changed_hook (level=1) at ../../src/gdb/tui/tui-hooks.c:222
#6  0x00000000006f0681 in select_frame (fi=0xd5c430) at ../../src/gdb/frame.c:1490
#7  0x00000000005dd94b in up_silently_base (count_exp=0x0) at ../../src/gdb/stack.c:2268
#8  0x00000000005dd985 in up_command (count_exp=0x0, from_tty=1) at ../../src/gdb/stack.c:2280
#9  0x00000000004dc5cf in do_cfunc (c=0xd3f720, args=0x0, from_tty=1) at ../../src/gdb/cli/cli-decode.c:113
#10 0x00000000004df664 in cmd_func (cmd=0xd3f720, args=0x0, from_tty=1) at ../../src/gdb/cli/cli-decode.c:1888
#11 0x00000000006e43e1 in execute_command (p=0xc7e6c2 "", from_tty=1) at ../../src/gdb/top.c:489

The fix is to fetch the value before comparing the contents.  The
comment additions to value.h explain why it can't be
value_available_contents_eq itself that fetches the contents.

Tested on x86_64 Fedora 17.

gdb/
2013-06-28  Pedro Alves  <palves@@redhat.com>

	PR tui/14880
	* tui/tui-regs.c (tui_get_register): Fetch register value contents
	before checking whether they're available.
	* value.c (value_available_contents_eq): Change comment.
	* value.h (value_available_contents_eq): Expand comment.
@
text
@a734 7
	  /* We only know whether a value chunk is available if we've
	     tried to read it.  */
	  if (value_lazy (data->value))
	    value_fetch_lazy (data->value);
	  if (value_lazy (old_val))
	    value_fetch_lazy (old_val);

@


1.47
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* tui/tui-data.c (set_gen_win_origin): Delete.
	* tui/tui-data.h (tui_set_gen_win_origin): Delete declaration.
	* tui/tui-regs.c (tui_last_reg_element_no_in_line): Delete.
@
text
@d3 1
a3 1
   Copyright (C) 1998-2004, 2007-2012 Free Software Foundation, Inc.
@


1.46
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a133 13
/* Answer the index of the last element in line_no.  If line_no is
   past the register area (-1) is returned.  */
int
tui_last_reg_element_no_in_line (int line_no)
{
  if ((line_no * TUI_DATA_WIN->detail.data_display_info.regs_column_count) <=
      TUI_DATA_WIN->detail.data_display_info.regs_content_count)
    return ((line_no + 1) *
	    TUI_DATA_WIN->detail.data_display_info.regs_column_count) - 1;
  else
    return (-1);
}

@


1.45
log
@2011-08-12  Pedro Alves  <pedro@@codesourcery.com>

	PR tui/13073

	gdb/
	* tui/tui-regs.c (tui_show_register_group): Skip registers with an
	empty name.
	(tui_show_register_group): Don't store a byte buffer in the data
	element's value.
	(tui_register_format): Skip registers with an empty name.
	(tui_get_register): Store a struct value in the data element's
	value field instead of a byte buffer holding the raw register
	contents.  Account for optimized-out and unavailable registers
	when comparing register contents.
@
text
@d3 1
a3 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.45.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1998-2004, 2007-2012 Free Software Foundation, Inc.
@


1.44
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* tui/tui-regs.c (tui_register_format): Delete unused variable.
@
text
@d233 13
a245 4
      /* Must be in the group and have a name.  */
      if (gdbarch_register_reggroup_p (gdbarch, regnum, group)
          && gdbarch_register_name (gdbarch, regnum) != 0)
        nr_regs++;
d285 1
d289 5
a293 3
          name = gdbarch_register_name (gdbarch, regnum);
          if (name == 0)
            continue;
a306 3
              if (data->value == (void*) NULL)
                data->value = (void*) xmalloc (MAX_REGISTER_SIZE);

d703 3
a705 5
  if (name == 0)
    {
      return;
    }
  
d740 1
a740 1
      gdb_byte buf[MAX_REGISTER_SIZE];
d742 2
a743 1
      get_frame_register (frame, regnum, buf);
a747 2
	  char *old = (char*) data->value;
	  int i;
d749 4
a752 6
	  for (i = 0; i < size; i++)
	    if (buf[i] != old[i])
	      {
		*changedp = TRUE;
		old[i] = buf[i];
	      }
d755 2
@


1.44.2.1
log
@2011-08-12  Pedro Alves  <pedro@@codesourcery.com>

	PR tui/13073

	* tui/tui-regs.c (tui_show_register_group): Skip registers with an
	empty name.
	(tui_show_register_group): Don't store a byte buffer in the data
	element's value.
	(tui_register_format): Skip registers with an empty name.
	(tui_get_register): Store a struct value in the data element's
	value field instead of a byte buffer holding the raw register
	contents.  Account for optimized-out and unavailable registers
	when comparing register contents.
@
text
@d233 4
a236 13
      const char *name;

      /* Must be in the group.  */
      if (!gdbarch_register_reggroup_p (gdbarch, regnum, group))
	continue;

      /* If the register name is empty, it is undefined for this
	 processor, so don't display anything.  */
      name = gdbarch_register_name (gdbarch, regnum);
      if (name == 0 || *name == '\0')
	continue;

      nr_regs++;
a275 1
          /* Must be in the group.  */
d279 3
a281 5
	  /* If the register name is empty, it is undefined for this
	     processor, so don't display anything.  */
	  name = gdbarch_register_name (gdbarch, regnum);
	  if (name == 0 || *name == '\0')
	    continue;
d295 3
d694 5
a698 3
  if (name == 0 || *name == '\0')
    return;

d733 1
a733 1
      struct value *old_val = data->value;
d735 1
a735 2
      data->value = get_frame_register_value (frame, regnum);
      release_value (data->value);
d740 2
d743 6
a748 4
	  if (value_optimized_out (data->value) != value_optimized_out (old_val)
	      || !value_available_contents_eq (data->value, 0,
					       old_val, 0, size))
	    *changedp = TRUE;
a750 2
      value_free (old_val);

@


1.43
log
@	* tui/tui-regs.c (tui_register_format): Remove dead code.
@
text
@a691 1
  struct type *type = register_type (gdbarch, regnum);
@


1.42
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-cmds.c: Shorten lines of >= 80 columns.
	* cli/cli-decode.c: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-setshow.c: Ditto.
	* common/signals.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-disas.c: Ditto.
	* mi/mi-cmd-stack.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-cmds.c: Ditto.
	* mi/mi-common.h: Ditto.
	* mi/mi-console.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
	* osf-share/cma_attr.c: Ditto.
	* osf-share/cma_deb_core.h: Ditto.
	* osf-share/cma_debug_client.h: Ditto.
	* osf-share/cma_handle.h: Ditto.
	* osf-share/cma_mutex.h: Ditto.
	* osf-share/cma_stack_int.h: Ditto.
	* osf-share/cma_tcb_defs.h: Ditto.
	* python/py-auto-load.c: Ditto.
	* python/py-breakpoint.c: Ditto.
	* python/py-cmd.c: Ditto.
	* python/py-frame.c: Ditto.
	* python/py-objfile.c: Ditto.
	* python/py-param.c: Ditto.
	* python/py-progspace.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-value.c: Ditto.
	* python/python-internal.h: Ditto.
	* python/python.c: Ditto.
	* tui/tui-data.c: Ditto.
	* tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c: Ditto.
	* tui/tui-io.c: Ditto.
	* tui/tui-layout.c: Ditto.
	* tui/tui-regs.c: Ditto.
	* tui/tui-source.c: Ditto.
	* tui/tui-stack.c: Ditto.
	* tui/tui-win.c: Ditto.
	* tui/tui-windata.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d705 1
a705 17
  if (TYPE_VECTOR (type) != 0 && 0)
    {
      gdb_byte buf[MAX_REGISTER_SIZE];
      int len;
      struct value_print_options opts;

      len = register_size (gdbarch, regnum);
      fprintf_filtered (stream, "%-14s ", name);
      get_frame_register (frame, regnum, buf);
      get_formatted_print_options (&opts, 'f');
      print_scalar_formatted (buf, type, &opts, len, stream);
    }
  else
    {
      gdbarch_print_registers_info (gdbarch, stream,
                                    frame, regnum, 1);
    }
@


1.41
log
@run copyright.sh for 2011.
@
text
@d285 2
a286 2
          data =
            &((struct tui_win_element *) data_item_win->content[0])->which_element.data;
d334 2
a335 1
          data_item_win = &display_info->regs_content[i]->which_element.data_window;
d380 1
a380 1
				 data_item_win->content[0])->which_element.data;
d421 2
a422 1
  if (TUI_DATA_WIN->detail.data_display_info.regs_content != (tui_win_content) NULL
d432 2
a433 1
	  first_line_on_last_page = last_line_no - (TUI_DATA_WIN->generic.height - 2);
d443 2
a444 1
	    element_no = tui_first_reg_element_no_inline (first_line_on_last_page);
d482 2
a483 1
      if (element_no < TUI_DATA_WIN->detail.data_display_info.regs_content_count)
@


1.40
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* tui/tui.c: White space.
	* tui/tui-data.c: White space.
	* tui/tui-disasm.c: White space.
	* tui/tui-file.c: White space.
	* tui/tui-interp.c: White space.
	* tui/tui-main.c: White space.
	* tui/tui-out.c: White space.
	* tui/tui-regs.c: White space.
	* tui/tui-source.c: White space.
	* tui/tui-stack.c: White space.
	* tui/tui-win.c: White space.
	* tui/tui-winsource.c: White space.
@
text
@d4 1
a4 1
   2010 Free Software Foundation, Inc.
@


1.39
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* tui/tui-interp.c (_initialize_tui_interp):
	Delete unused variable.
	* tui/tui-regs.c tui_display_registers_from):
	Delete unused variable.
	(tui_check_register_values): Delete unused variable.
	(tui_register_format): Delete unused variable.
	* tui/tui-win.c (_initialize_tui_win): Delete unused variable.
	* tui/tui-windata.c (tui_display_data_from_line):
	Delete unused variables.
	(tui_vertical_data_scroll): Delete unused variables.
@
text
@d746 1
a747 1

@


1.38
log
@        * tui/tui-regs.c (tui_display_register): Add comment about
        a couple of casts.
        * tui/tui-stack.c (tui_show_locator_content): Ditto.
@
text
@d324 1
a324 1
      int j, value_chars_wide, item_win_width, cur_y;
d507 1
a507 1
	  int i, j;
a686 1
  int pos;
@


1.37
log
@	Suppress unused value warning during compilation.
	* tui/tui-regs.c (tui_display_register): Cast wstandout and wstandend
	calls to void.
	* tui/tui-stack.c (tui_show_locator_content): Likewise.
@
text
@d544 5
d559 5
@


1.36
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d544 1
a544 1
	wstandout (win_info->handle);
d554 1
a554 1
	wstandend (win_info->handle);
@


1.35
log
@	* arch-utils.c (selected_byte_order): Return target_byte_order_user.
	(show_endian): Use target_byte_order_user if specified; otherwise
	use get_current_arch () instead of current_gdbarch.
	(show_architecture): Use set_architecture_string if specified;
	otherwise use get_current_arch () instead of current_gdbarch.
	(get_current_arch): New function.
	* arch-utils.h (get_current_arch): Add prototype.

	* osabi.c (show_osabi): Use get_current_arch () instead of
	current_gdbarch.

	* findcmd.c: Include "arch-utils.h".
	(parse_find_args): Add BIG_P argument.  Use it instead of byte order
	of current_gdbarch.
	(find_command): Use get_current_arch () instead of current_gdbarch.
	Pass byte order to parse_find_args.

	* maint.c: Include "arch-utils.h".
	(maintenance_print_architecture): Use get_current_arch () instead
	of current_gdbarch.

	* reggroups.c: Include "arch-utils.h".
	(maintenance_print_reggroups): Use get_current_arch () instead
	of current_gdbarch.

	* symfile.c: Include "arch-utils.h".
	(overlay_load_command): Use get_current_arch () instead of
	current_gdbarch.

	* value.c: Include "arch-utils.h".
	(show_convenience): Use get_current_arch () instead of
	current_gdbarch.

	* tui/tui-regs.c: Include "arch-utils.h".
	(tui_reg_next_command): Use get_current_arch () instead of
	current_gdbarch.

	* mi/mi-main.c: Include "arch-utils.h".
	(mi_cmd_data_read_memory): Use get_current_arch () instead of
	current_gdbarch.

	* parse.c: Include "arch-utils.h".
	(parse_exp_in_context): Use get_current_arch () instead of
	current_gdbarch.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.34
log
@	* tui/tui-regs.c (tui_show_register_group): Remove GDBARCH parameter;
	use frame architecture instead.  Replace current_gdbarch uses.
	(tui_show_registers): Update call.
	(tui_get_register): Remove GDBARCH parameter; use frame architecture
	instead.
	(tui_show_register_group): Update call.
	(tui_check_register_values): Likewise.
	(tui_register_format): Remove GDBARCH parameter; use frame
	architecture instead.  Replace current_gdbarch uses.
	(tui_get_register): Update call.
@
text
@d24 1
d562 2
d569 1
a569 1
      group = reggroup_next (current_gdbarch, group);
d571 1
a571 1
        group = reggroup_next (current_gdbarch, 0);
@


1.33
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d53 10
a62 5
static enum tui_status
tui_show_register_group (struct gdbarch *gdbarch, 
			 struct reggroup *group,
                         struct frame_info *frame, 
			 int refresh_values_only);
a63 9
static enum tui_status
tui_get_register (struct gdbarch *gdbarch, 
		  struct frame_info *frame,
                  struct tui_data_element *data, 
		  int regnum, int *changedp);
static void tui_register_format (struct gdbarch *, 
				 struct frame_info *, 
				 struct tui_data_element*, 
				 int);
d173 1
a173 2
      ret = tui_show_register_group (current_gdbarch, group,
                                     get_current_frame (),
d207 1
a207 2
tui_show_register_group (struct gdbarch *gdbarch, 
			 struct reggroup *group,
d211 1
d228 2
a229 2
       regnum < gdbarch_num_regs (current_gdbarch)
		+ gdbarch_num_pseudo_regs (current_gdbarch);
d267 2
a268 2
	   regnum < gdbarch_num_regs (current_gdbarch)
		    + gdbarch_num_pseudo_regs (current_gdbarch);
d297 1
a297 1
              tui_get_register (gdbarch, frame, data, regnum, 0);
d520 1
a520 1
              tui_get_register (current_gdbarch, frame, data,
d664 1
a664 2
tui_register_format (struct gdbarch *gdbarch, 
		     struct frame_info *frame,
d668 1
d694 1
a694 1
      len = register_size (current_gdbarch, regnum);
d702 1
a702 1
      gdbarch_print_registers_info (current_gdbarch, stream,
d723 1
a723 2
tui_get_register (struct gdbarch *gdbarch, 
		  struct frame_info *frame,
d738 1
d753 1
a753 1
	tui_register_format (gdbarch, frame, data, regnum);
@


1.32
log
@        Updated copyright notices for most files.
@
text
@d39 1
d420 1
a420 1
void
d608 3
@


1.31
log
@gdb
	* varobj.c (value_get_print_value): Include valprint.h.
	(value_get_print_value): Use get_formatted_print_options.
	* value.h (struct value_print_options): Declare.
	(value_print, val_print, common_val_print, val_print_string):
	Update.
	* value.c: Include valprint.h.
	(show_values): Use get_user_print_options.
	(show_convenience): Likewise.
	* valprint.h (prettyprint_arrays, prettyprint_structs): Don't
	declare.
	(struct value_print_options): New type.
	(vtblprint, unionprint, addressprint, objectprint, print_max,
	inspect_it, repeat_count_threshold, output_format,
	stop_print_at_null): Don't declare.
	(user_print_options, get_user_print_options,
	get_raw_print_options, get_formatted_print_options): Declare.
	(print_array_indexes_p): Don't declare.
	(maybe_print_array_index, val_print_array_elements): Update.
	* valprint.c (print_max): Remove.
	(user_print_options): New global.
	(get_user_print_options, get_raw_print_options,
	get_formatted_print_options): New functions.
	(print_array_indexes, repeat_count_threshold, stop_print_at_null,
	prettyprint_structs, prettyprint_arrays, unionprint,
	addressprint): Remove.
	(val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(common_val_print): Likewise.
	(print_array_indexes_p): Remove.
	(maybe_print_array_index): Remove format, pretty arguments; add
	options.  Update.
	(val_print_array_elements): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(val_print_string): Add options argument.  Update.
	(_initialize_valprint): Use user_print_options.
	(output_format): Remove.
	(set_output_radix_1): Use user_print_options.
	* typeprint.c: Include valprint.h.
	(objectprint): Don't declare.
	(whatis_exp): Use get_user_print_options.
	* tui/tui-regs.c: Include valprint.h.
	(tui_register_format): Use get_formatted_print_options.
	* tracepoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(trace_mention): Use get_user_print_options.
	(tracepoints_info): Likewise.
	* stack.c (print_frame_args): Use get_raw_print_options.
	(print_frame_info): Use get_user_print_options.
	(print_frame): Likewise.
	* sh64-tdep.c: Include valprint.h
	(sh64_do_register): Use get_formatted_print_options.
	* scm-valprint.c (scm_inferior_print): Remove format, deref_ref,
	pretty arguments; add options.
	(scm_scmlist_print): Likewise.  Update.
	(scm_scmval_print): Likewise.
	(scm_val_print): Likewise.
	(scm_value_print): Remove format, pretty arguments; add options.
	Update.
	* scm-lang.h (scm_value_print, scm_val_print, scm_scmval_print):
	Update.
	* scm-lang.c (scm_printstr): Add options argument.
	* python/python-value.c: Include valprint.h.
	(valpy_str): Use get_user_print_options.
	* printcmd.c: Include valprint.h.
	(addressprint): Don't declare.
	(inspect_it): Remove.
	(print_formatted): Remove format option; add options.  Update.
	(print_scalar_formatted): Likewise.
	(print_address_demangle): Use get_user_print_options.
	(do_examine): Use get_formatted_print_options.
	(print_command_1): Likewise.
	(output_command): Use get_formatted_print_options.
	(do_one_display): Likewise.
	(print_variable_value): Use get_user_print_options.
	* p-valprint.c (pascal_val_print): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(pascal_value_print): Remove format, pretty arguments; add
	options.  Update.
	(vtblprint, objectprint): Don't declare.
	(pascal_static_field_print): Remove.
	(pascal_object_print_value_fields): Remove format, pretty
	arguments; add options.  Update.
	(pascal_object_print_static_field): Likewise.
	(_initialize_pascal_valprint): Use user_print_options.  Update.
	* p-lang.h (pascal_val_print, pascal_value_print,
	pascal_printstr, pascal_object_print_value_fields): Update.
	(vtblprint, static_field_print): Don't declare.
	* p-lang.c (pascal_printstr): Add options argument.  Update.
	* objc-lang.c (objc_printstr): Add options argument.  Update.
	* mt-tdep.c: Include valprint.h.
	(mt_registers_info): Use get_raw_print_options.
	* mips-tdep.c: Include valprint.h.
	(mips_print_fp_register): Use get_formatted_print_options.
	(mips_print_register): Likewise.
	* mi/mi-main.c: Include valprint.h.
	(get_register): Use get_user_print_options.
	(mi_cmd_data_evaluate_expression): Likewise.
	(mi_cmd_data_read_memory): Use get_formatted_print_options.
	* mi/mi-cmd-stack.c: Include valprint.h.
	(list_args_or_locals): Use get_raw_print_options.
	* m2-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(m2_print_long_set): Remove format, pretty arguments.
	(m2_print_unbounded_array): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(print_unpacked_pointer): Remove format argument; add options.
	Now static.  Update.
	(print_variable_at_address): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(m2_print_array_contents): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* m2-lang.c (m2_printstr): Add options argument. Update.
	* language.h (struct value_print_options): Declare.
	(struct language_defn) <la_printstr>: Add options argument.
	<la_val_print>: Remove format, deref_ref, pretty argument; add
	options.
	<la_value_print>: Remove format, pretty arguments; add options.
	<la_print_array_index>: Likewise.
	(LA_VAL_PRINT, LA_VALUE_PRINT, LA_PRINT_STRING,
	LA_PRINT_ARRAY_INDEX): Update.
	(default_print_array_index): Update.
	* language.c (default_print_array_index): Remove format, pretty
	arguments; add options.  Update.
	(unk_lang_printstr): Add options argument.
	(unk_lang_val_print): Remove format, deref_ref, pretty arguments;
	add options.
	(unk_lang_value_print): Remove format, pretty arguments; add
	options.
	* jv-valprint.c (java_value_print): Remove format, pretty
	arguments; add options.  Update.
	(java_print_value_fields): Likewise.
	(java_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	* jv-lang.h (java_val_print, java_value_print): Declare.
	* infcmd.c: Include valprint.h.
	(print_return_value): Use get_raw_print_options.
	(default_print_registers_info): Use get_user_print_options,
	get_formatted_print_options.
	(registers_info): Use get_formatted_print_options.
	* gdbtypes.h (struct value_print_options): Declare.
	(print_scalar_formatted): Update.
	* f-valprint.c (f77_print_array_1): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Update.
	* f-lang.c (f_printstr): Add options argument.  Update.
	(c_value_print): Update declaration.
	* expprint.c: Include valprint.h.
	(print_subexp_standard): Use get_raw_print_options,
	get_user_print_options.
	* eval.c: Include valprint.h.
	(objectprint): Don't declare.
	(evaluate_subexp_standard): Use get_user_print_options.
	* cp-valprint.c (vtblprint, objectprint, static_field_print):
	Remove.
	(cp_print_value_fields): Remove format, pretty arguments; add
	options.  Update.
	(cp_print_value): Likewise.
	(cp_print_static_field): Likewise.
	(_initialize_cp_valprint): Use user_print_options.  Update.
	* c-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(c_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(c_value_print): Add options argument.  Update.
	* c-lang.h (c_val_print, c_value_print, c_printstr): Update.
	(vtblprint, static_field_print): Don't declare.
	(cp_print_value_fields): Update.
	* c-lang.c (c_printstr): Add options argument.  Update.
	* breakpoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(watchpoint_value_print): Use get_user_print_options.
	(print_one_breakpoint_location): Likewise.
	(breakpoint_1, print_it_catch_fork, print_it_catch_vfork, mention,
	print_exception_catchpoint): Likewise.
	* auxv.c (fprint_target_auxv): Don't declare addressprint.  Use
	get_user_print_options.
	* ada-valprint.c (struct ada_val_print_args): Remove format,
	deref_ref, and pretty; add options.
	(print_optional_low_bound): Add options argument.
	(val_print_packed_array_elements): Remove format and pretty
	arguments; add options.  Update.
	(printstr): Add options argument.  Update.
	(ada_printstr): Likewise.
	(ada_val_print): Remove format, deref_ref, pretty arguments; add
	options argument.  Update.
	(ada_val_print_stub): Update.
	(ada_val_print_array): Remove format, deref_ref, pretty arguments;
	add options.  Update.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Remove format, pretty arguments; add options.
	Update.
	(print_record): Likewise.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print, ada_value_print, ada_printstr):
	Update.
	* ada-lang.c (ada_print_array_index): Add options argument; remove
	format and pretty arguments.
	(print_one_exception): Use get_user_print_options.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add enum formatting tests.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
@


1.30
log
@	Updated copyright notices for most files.
@
text
@d40 1
d693 1
d698 2
a699 1
      print_scalar_formatted (buf, type, 'f', len, stream);
@


1.29
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007
@


1.28
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-disasm.c, tui-file.c, tui-io.c,
	tui-layout.c, tui-regs.c, tui-source.c, tui-win.c, tui-windata.c,
	tui-wingeneral.c, tui-winsource.c: Coding standard, && and ||
	go at beginning of new line.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.27
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-data.c, tui-data.h, tui-disasm.c, tui-disasm.h, tui-hooks.c,
	tui-io.c, tui-layout.c, tui-layout.h, tui-out.c, tui-regs.c,
	tui-source.c, tui-source.h, tui-stack.c, tui-win.c, tui-win.h,
	tui-windata.c, tui-windata.h, tui-wingeneral.c, tui-winsource.c,
	tui-winsource.h, tui.c, tui.h: Function declarations and
	definitions, wrap long lines.
@
text
@d324 2
a325 2
  if (display_info->regs_content != (tui_win_content) NULL &&
      display_info->regs_content_count > 0)
d368 2
a369 2
      while (i < display_info->regs_content_count &&
	     cur_y <= TUI_DATA_WIN->generic.viewport_height)
d372 3
a374 2
	       (j < display_info->regs_column_count &&
		i < display_info->regs_content_count); j++)
d424 2
a425 2
  if (TUI_DATA_WIN->detail.data_display_info.regs_content != (tui_win_content) NULL &&
      TUI_DATA_WIN->detail.data_display_info.regs_content_count > 0)
d442 2
a443 2
	  if (TUI_DATA_WIN->detail.data_display_info.data_content_count <= 0 &&
	      start_line_no > first_line_on_last_page)
d500 2
a501 1
  if (TUI_DATA_WIN != NULL && TUI_DATA_WIN->generic.is_visible)
d506 2
a507 1
      if (display_info->regs_content_count <= 0 && display_info->display_regs)
@


1.26
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-disasm.c, tui-layout.c,
	tui-regs.c, tui-win.c, tui-windata.c, tui-winsource.c, tui.c:
	Reformat block comments to GNU standard.
@
text
@d54 4
a57 2
tui_show_register_group (struct gdbarch *gdbarch, struct reggroup *group,
                         struct frame_info *frame, int refresh_values_only);
d60 8
a67 4
tui_get_register (struct gdbarch *gdbarch, struct frame_info *frame,
                  struct tui_data_element *data, int regnum, int *changedp);
static void tui_register_format
  (struct gdbarch *, struct frame_info *, struct tui_data_element*, int);
d212 4
a215 2
tui_show_register_group (struct gdbarch *gdbarch, struct reggroup *group,
                         struct frame_info *frame, int refresh_values_only)
d420 2
a421 1
tui_display_reg_element_at_line (int start_element_no, int start_line_no)
d455 2
a456 1
tui_display_registers_from_line (int line_no, int force_display)
d663 4
a666 2
tui_register_format (struct gdbarch *gdbarch, struct frame_info *frame,
                     struct tui_data_element *data_element, int regnum)
d720 4
a723 2
tui_get_register (struct gdbarch *gdbarch, struct frame_info *frame,
                  struct tui_data_element *data, int regnum, int *changedp)
@


1.25
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-data.h, tui-disasm.c, tui-file.c,
	tui-hooks.c, tui-interp.c, tui-io.c, tui-layout.c, tui-out.c,
	tui-regs.c, tui-regs.h, tui-source.c, tui-stack.c, tui-win.c,
	tui-windata.c, tui-wingeneral.c, tui-winsource.c, tui-winsource.h,
	tui.c, tui.h: Comment reformatting to coding standard (capitals,
	spaces after periods, etc).
@
text
@d357 2
a358 4
      /*
         ** Now create each data "sub" window, and write the display
	 ** into it.
       */
d427 5
a431 6
	  /*
	     ** If there is no other data displayed except registers,
	     ** and the element_no causes us to scroll past the end of
	     ** the registers, adjust what element to really start the
	     ** display at.
	   */
d455 3
a457 4
	{ /*
	   ** If we must display regs (force_display is true), then make
	   ** sure that we don't display off the end of the registers.
	  */
@


1.24
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-data.c, tui-data.h, tui-disasm.c, tui-hooks.c, tui-layout.c,
	tui-regs.c, tui-source.c, tui-stack.c, tui-win.c, tui-windata.c,
	tui-wingeneral.c, tui-wingeneral.h, tui-winsource.c, tui.c,
	tui-winsource.h: Whitespace changes, fix pointer declarations
	to be consistant.
@
text
@d117 2
a118 2
/* Answer the index of the first element in line_no.  If line_no is past
   the register area (-1) is returned.  */
d165 2
a166 1
  /* Say that registers should be displayed, even if there is a problem.  */
d184 1
a184 1
      /* Clear all notation of changed values */
d202 2
a203 2
   using the given frame.  Values are refreshed only when refresh_values_only
   is TRUE.  */
d261 1
a261 1
      /* Now set the register names and values */
d358 2
a359 1
         ** Now create each data "sub" window, and write the display into it.
d372 1
a372 1
	      /* create the window if necessary */
d401 1
a401 1
	      i++;		/* next register */
d403 1
a403 1
	  cur_y++;		/* next row; */
d431 3
a433 2
	     ** and the element_no causes us to scroll past the end of the
	     ** registers, adjust what element to really start the display at.
d458 4
a461 4
	{			/*
				   ** If we must display regs (force_display is true), then make
				   ** sure that we don't display off the end of the registers.
				 */
d483 1
a483 1
  return (-1);			/* nothing was displayed */
d528 2
a529 2
/* Display a register in a window.  If hilite is TRUE,
   then the value will be displayed in reverse video  */
d708 3
a710 3
/* Get the register value from the given frame and format it for
   the display.  When changep is set, check if the new register value
   has changed with respect to the previous call.  */
@


1.23
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d367 2
a368 2
	      struct tui_gen_win_info * data_item_win;
	      struct tui_data_element * data_element_ptr;
@


1.22
log
@	* regcache.c (regcache_invalidate): New function.
	(register_cached): Remove.
	(set_register_cached): Remove.
	(deprecated_registers_fetched): Remove.
	(registers_changed): Use regcache_invalidate instead
	of set_register_cached.
	(regcache_raw_read): Update comment.

	* regcache.h (regcache_invalidate): Add prototype.
	(register_cached): Remove.
	(set_register_cached): Remove.
	(deprecated_registers_fetched): Remove.

	* findvar.c (value_of_register): Do not call register_cached.
	* frame.c (frame_register): Likewise.
	* tui/tui-regs.c (tui_get_register): Likewise.

	* remote.c (fetch_register_using_p): Do not call set_register_cached.
	(process_g_packet): Likewise.
	(remote_fetch_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* mt-tdep.c (mt_select_coprocessor): Replace set_register_cached call
	by regcache_invalidate.
	(mt_pseudo_register_write): Likewise.
	* sh-tdep.c (sh_pseudo_register_write): Likewise.

	* corelow.c (get_core_registers): Replace deprecated_registers_fetched
	call by loop over regcache_raw_supply (..., NULL).
@
text
@d223 4
a226 1
  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
d262 4
a265 1
      for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
@


1.21
log
@	* gdbarch.sh (register_type): Update comment.
	* gdbarch.h: Regenerated.
	* arch-utils.c (generic_register_size): Call register_type.
	* ia64-tdep.c (ia64_extract_return_value): Likewise.
	* m32c-tdep.c (check_for_saved): Likewise.
	* mips-tdep.c (mips_print_register, print_gp_register_row)
	(mips_print_registers_info): Likewise.
	* sh-tdep.c (sh_pseudo_register_read, sh_pseudo_register_write):
	Likewise.
	* sh64-tdep.c (sh64_pseudo_register_read, sh64_pseudo_register_write)
	(sh64_do_register, sh64_print_register)
	(sh64_media_print_registers_info): Likewise.
	* tui/tui-regs.c (tui_register_format): Likewise.
@
text
@d713 19
d733 1
a733 25
      get_frame_register (frame, regnum, buf);
      /* NOTE: cagney/2003-03-13: This is bogus.  It is refering to
         the register cache and not the frame which could have pulled
         the register value off the stack.  */
      if (register_cached (regnum) >= 0)
        {
          if (changedp)
            {
              int size = register_size (gdbarch, regnum);
              char *old = (char*) data->value;
              int i;

              for (i = 0; i < size; i++)
                if (buf[i] != old[i])
                  {
                    *changedp = TRUE;
                    old[i] = buf[i];
                  }
            }

          /* Reformat the data content if the value changed.  */
          if (changedp == 0 || *changedp == TRUE)
            tui_register_format (gdbarch, frame, data, regnum);
          ret = TUI_SUCCESS;
        }
@


1.20
log
@Copyright updates for 2007.
@
text
@d657 1
a657 1
  struct type *type = gdbarch_register_type (gdbarch, regnum);
@


1.19
log
@	* tui/tui-file.c:
	* tui/tui-disasm.c:
	* tui/tui-data.h:
	* tui/tui-data.c:
	* tui/tui-command.h:
	* tui/tui-command.c:
	* tui/tui-win.h:
	* tui/tui-win.h:
	* tui/tui-win.c:
	* tui/tui-stack.h:
	* tui/tui-stack.c:
	* tui/tui-source.h:
	* tui/tui-source.c:
	* tui/tui-regs.h:
	* tui/tui-regs.c:
	* tui/tui-out.c:
	* tui/tui-main.c:
	* tui/tui-layout.h:
	* tui/tui-layout.c:
	* tui/tui-io.h:
	* tui/tui-io.c:
	* tui/tui-interp.c:
	* tui/tui-hooks.h:
	* tui/tui-hooks.c:
	* tui/tui-file.h:
	* tui/tui.h:
	* tui/tui.c:
	* tui/tui-winsource.h:
	* tui/tui-winsource.c:
	* tui/tui-wingeneral.h:
	* tui/tui-wingeneral.c:
	* tui/tui-windata.h:
	* tui/tui-windata.c: Add (C) after Copyright.  Update the FSF
	address.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
@


1.18
log
@2005-05-22  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (frame_register_unwind, frame_unwind_register)
	(get_frame_register, frame_register, put_frame_register)
	(get_frame_memory, safe_frame_unwind_memory)
	(frame_register_read): Use gdb_byte for byte buffer parameters.
	* trad-frame.h (trad_frame_get_register)
	(frame_get_prev_register): Ditto.
	* frame-unwind.h (frame_prev_register_ftype): Ditto.
	* frame.c (frame_pop, frame_register, frame_unwind_register)
	(get_frame_register, frame_unwind_register_signed)
	(frame_unwind_register_unsigned, frame_unwind_unsigned_register)
	(frame_register_read, get_frame_memory): Update.
	* trad-frame.c (trad_frame_get_prev_register): Update.
	(trad_frame_get_register): Update.
	* gdbcore.h (deprecated_read_memory_nobpt, read_memory): Ditto.
	* breakpoint.c (deprecated_read_memory_nobpt): Update.
	* corefile.c (read_memory): Update.
	* tramp-frame.c (tramp_frame_prev_register): Update.
	* valops.c (value_assign): Update.
	* sentinel-frame.c (sentinel_frame_prev_register): Update.
	* std-regs.c (value_of_builtin_frame_fp_reg)
	(value_of_builtin_frame_pc_reg): Update.
	* infcmd.c (default_print_registers_info): Update
	* dummy-frame.c (dummy_frame_prev_register): Update.
	* findvar.c (value_of_register, value_from_register): Update.
	* tui/tui-regs.c (tui_register_format, tui_get_register): Update.
	* mi/mi-main.c (register_changed_p, get_register): Update.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.17
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d672 1
a672 1
      char buf[MAX_REGISTER_SIZE];
d712 1
a712 1
      char buf[MAX_REGISTER_SIZE];
@


1.16
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d598 1
a598 1
                  "TUI commands to control the register window.",
d618 1
a618 1
	       "Display only floating point registers\n");
d620 1
a620 1
	       "Display only general registers\n");
d622 1
a622 1
	       "Display only special registers\n");
d624 1
a624 1
	       "Scroll the registers window forward\n");
d626 1
a626 1
	       "Scroll the register window backward\n");
@


1.15
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d603 1
a603 1
           "Display only floating point registers\n",
d606 1
a606 1
           "Display only general registers\n",
d609 1
a609 1
           "Display only system registers\n",
d612 1
a612 1
           "Display next register group\n",
@


1.14
log
@	* tui/tui-regs.c (tui_show_registers): Make sure the TUI is active
	and switch the layout to force a display of register window.
@
text
@d585 2
a586 2
  printf_unfiltered ("\"tui reg\" must be followed by the name of a "
                     "tui reg command.\n");
@


1.13
log
@	* tui/tui-win.h (tui_get_cmd_list): Declare.
	* tui/tui-win.c (tui_command): New function.
	(tui_get_cmd_list): New function.
	(_initialize_tui_win): Moved initialization of tui command in
	tui_get_cmd_list.

	* tui/tui-data.c (init_content_element): Setup new data members.
	(init_win_info): Likewise.
	(free_content_elements): Free it.
	* tui/tui-data.h (struct tui_data_element): Store the register
	content to print.
	(struct tui_data_info): Keep the current register group.

	* tui/tui-layout.c (tui_set_layout): Update call to tui_show_registers.

	* tui/tui-regs.h (tui_show_registers): Update prototype.
	(tui_toggle_float_regs, tui_calculate_regs_column_count): Remove.
	(tui_resize_all): No need to calculate anything for register window.
	* tui/tui-regs.c (tui_calculate_regs_column_count): Remove.
	(tui_set_register_element, tui_set_general_regs_content): Remove.
	(tui_set_special_regs_content): Remove.
	(tui_set_general_and_special_regs_content): Remove.
	(tui_set_float_regs_content): Remove.
	(tui_reg_value_has_changed, tui_get_register_raw_value): Remove.
	(tui_set_regs_content): Remove.
	(tui_toggle_float_regs, _tui_toggle_float_regs_command): Remove.
	(tui_v_show_registers_command_support): Remove.
	(tui_show_registers): Use a reggroup to specify the registers to show.
	(tui_show_register_group): New function.
	(tui_display_registers_from): Compute the layout of register window
	and refresh with new API; be sure to delete old register windows.
	(tui_check_register_values): Update to use tui_get_register and
	tui_display_data.
	(tui_display_register): Just refresh the register window part.
	(tui_register_format): Format registers and save in tui_data_element.
	(tui_get_register): New to combine tui_reg_value_has_changed and
	tui_get_register_raw_value; fix to use the new gdb API.
	(tui_show_float_command): Renamed tui_reg_float_command.
	(tui_show_general_command): Renamed tui_reg_general_command.
	(tui_show_special_command): Renamed tui_reg_system_command.
	(_initialize_tui_regs): Remove unused commands.
@
text
@d151 1
a151 1
  struct tui_data_info *display_info = &TUI_DATA_WIN->detail.data_display_info;
d153 9
@


1.13.2.1
log
@merge mainline changes to branch
@
text
@@


1.12
log
@        * tui/tui-disasm.c: %s/lines/asm_lines/g to avoid a collision
        with the lines macro defined in term.h on AiX.
        * tui/tui-regs.c: %s/label_width/tui_label_width/g, to avoid
        a collision with the label_width macro defined in term.h on AiX.
@
text
@d41 1
a44 21
/*****************************************
** LOCAL DEFINITIONS                    **
******************************************/
#define DOUBLE_FLOAT_LABEL_WIDTH    6
#define DOUBLE_FLOAT_LABEL_FMT      "%6.6s: "
#define DOUBLE_FLOAT_VALUE_WIDTH    30	/*min of 16 but may be in sci notation */

#define SINGLE_FLOAT_LABEL_WIDTH    6
#define SINGLE_FLOAT_LABEL_FMT      "%6.6s: "
#define SINGLE_FLOAT_VALUE_WIDTH    25	/* min of 8 but may be in sci notation */

#define SINGLE_LABEL_WIDTH    16
#define SINGLE_LABEL_FMT      "%10.10s: "
#define SINGLE_VALUE_WIDTH    20 /* minimum of 8 but may be in sci notation */

/* In the code HP gave Cygnus, this was actually a function call to a
   PA-specific function, which was supposed to determine whether the
   target was a 64-bit or 32-bit processor.  However, the 64-bit
   support wasn't complete, so we didn't merge that in, so we leave
   this here as a stub.  */
#define IS_64BIT 0
d47 1
a47 1
** STATIC DATA                          **
d49 3
d53 3
d57 3
a59 10
/*****************************************
** STATIC LOCAL FUNCTIONS FORWARD DECLS    **
******************************************/
static enum tui_status tui_set_regs_content
  (int, int, struct frame_info *, enum tui_register_display_type, int);
static const char *tui_register_name (int);
static enum tui_status tui_get_register_raw_value (int, char *, struct frame_info *);
static void tui_set_register_element
  (int, struct frame_info *, struct tui_data_element *, int);
static void tui_display_register (int, struct tui_gen_win_info *, enum precision_type);
d61 1
a61 12
  (char *, int, int, struct tui_data_element *, enum precision_type);
static enum tui_status tui_set_general_regs_content (int);
static enum tui_status tui_set_special_regs_content (int);
static enum tui_status tui_set_general_and_special_regs_content (int);
static enum tui_status tui_set_float_regs_content (enum tui_register_display_type, int);
static int tui_reg_value_has_changed
  (struct tui_data_element *, struct frame_info *, char *);
static void tui_show_float_command (char *, int);
static void tui_show_general_command (char *, int);
static void tui_show_special_command (char *, int);
static void tui_v_show_registers_command_support (enum tui_register_display_type);
static void _tui_toggle_float_regs_command (char *, int);
d145 10
d156 2
a157 6
/* Calculate the number of columns that should be used to display the
   registers.  */
int
tui_calculate_regs_column_count (enum tui_register_display_type dpy_type)
{
  int col_count, col_width;
d159 11
a169 2
  if (IS_64BIT || dpy_type == TUI_DFLOAT_REGS)
    col_width = DOUBLE_FLOAT_VALUE_WIDTH + DOUBLE_FLOAT_LABEL_WIDTH;
d172 15
a186 4
      if (dpy_type == TUI_SFLOAT_REGS)
	col_width = SINGLE_FLOAT_VALUE_WIDTH + SINGLE_FLOAT_LABEL_WIDTH;
      else
	col_width = SINGLE_VALUE_WIDTH + SINGLE_LABEL_WIDTH;
d188 1
a188 1
  col_count = (TUI_DATA_WIN->generic.width - 2) / col_width;
a189 2
  return col_count;
}
d191 3
d195 3
a197 5
/* Show the registers int the data window as indicated by dpy_type.  If
   there is any other registers being displayed, then they are
   cleared.  What registers are displayed is dependent upon dpy_type.  */
void
tui_show_registers (enum tui_register_display_type dpy_type)
d200 5
a204 1
  int refresh_values_only = FALSE;
d206 5
a210 2
  /* Say that registers should be displayed, even if there is a problem */
  TUI_DATA_WIN->detail.data_display_info.display_regs = TRUE;
d212 3
a214 1
  if (target_has_registers)
d216 5
a220 20
      refresh_values_only =
	(dpy_type == TUI_DATA_WIN->detail.data_display_info.regs_display_type);
      switch (dpy_type)
	{
	case TUI_GENERAL_REGS:
	  ret = tui_set_general_regs_content (refresh_values_only);
	  break;
	case TUI_SFLOAT_REGS:
	case TUI_DFLOAT_REGS:
	  ret = tui_set_float_regs_content (dpy_type, refresh_values_only);
	  break;

/* could ifdef out */

	case TUI_SPECIAL_REGS:
	  ret = tui_set_special_regs_content (refresh_values_only);
	  break;
	case TUI_GENERAL_AND_SPECIAL_REGS:
	  ret = tui_set_general_and_special_regs_content (refresh_values_only);
	  break;
d222 6
a227 1
/* end of potential if def */
d229 1
a229 5
	default:
	  break;
	}
    }
  if (ret == TUI_FAILURE)
d231 3
a233 2
      TUI_DATA_WIN->detail.data_display_info.regs_display_type = TUI_UNDEFINED_REGS;
      tui_erase_data_content (NO_REGS_STRING);
d235 2
a236 1
  else
d238 1
a238 4
      int i;

      /* Clear all notation of changed values */
      for (i = 0; (i < TUI_DATA_WIN->detail.data_display_info.regs_content_count); i++)
d240 42
a281 1
	  struct tui_gen_win_info * data_item_win;
d283 3
a285 7
	  data_item_win = &TUI_DATA_WIN->detail.data_display_info.
	    regs_content[i]->which_element.data_window;
	  (&((struct tui_win_element *)
	     data_item_win->content[0])->which_element.data)->highlight = FALSE;
	}
      TUI_DATA_WIN->detail.data_display_info.regs_display_type = dpy_type;
      tui_display_all_data ();
a286 1
  (tui_layout_def ())->regs_display_type = dpy_type;
d288 1
a288 1
  return;
a290 1

d298 4
a301 2
  if (TUI_DATA_WIN->detail.data_display_info.regs_content != (tui_win_content) NULL &&
      TUI_DATA_WIN->detail.data_display_info.regs_content_count > 0)
a304 1
      enum precision_type precision;
d306 35
a340 30
      /* Do not rename the following variable into "label_width".
         Unfortunately, term.h on AiX systems defines a macro with
         the same name, which causes a build failure if we use the
         same name for this variable.  */
      int tui_label_width;

      precision = (TUI_DATA_WIN->detail.data_display_info.regs_display_type
		   == TUI_DFLOAT_REGS) ?
	double_precision : unspecified_precision;
      if (IS_64BIT ||
	  TUI_DATA_WIN->detail.data_display_info.regs_display_type == TUI_DFLOAT_REGS)
	{
	  value_chars_wide = DOUBLE_FLOAT_VALUE_WIDTH;
	  tui_label_width = DOUBLE_FLOAT_LABEL_WIDTH;
	}
      else
	{
	  if (TUI_DATA_WIN->detail.data_display_info.regs_display_type ==
	      TUI_SFLOAT_REGS)
	    {
	      value_chars_wide = SINGLE_FLOAT_VALUE_WIDTH;
	      tui_label_width = SINGLE_FLOAT_LABEL_WIDTH;
	    }
	  else
	    {
	      value_chars_wide = SINGLE_VALUE_WIDTH;
	      tui_label_width = SINGLE_LABEL_WIDTH;
	    }
	}
      item_win_width = value_chars_wide + tui_label_width;
d345 1
a345 1
      while (i < TUI_DATA_WIN->detail.data_display_info.regs_content_count &&
d349 2
a350 2
	       (j < TUI_DATA_WIN->detail.data_display_info.regs_column_count &&
		i < TUI_DATA_WIN->detail.data_display_info.regs_content_count); j++)
d356 2
a357 2
	      data_item_win = &TUI_DATA_WIN->detail.data_display_info.
		regs_content[i]->which_element.data_window;
d360 10
d373 1
a373 2
		  data_item_win->width = (precision == double_precision) ?
		    item_win_width + 2 : item_win_width + 1;
d381 3
a383 6
	      /*
	         ** Get the printable representation of the register
	         ** and display it
	       */
	      tui_display_register (
			    data_element_ptr->item_no, data_item_win, precision);
a388 2

  return;
d477 5
a481 3
      if (TUI_DATA_WIN->detail.data_display_info.regs_content_count <= 0 &&
	  TUI_DATA_WIN->detail.data_display_info.display_regs)
	tui_show_registers ((tui_layout_def ())->regs_display_type);
a484 1
	  char raw_buf[MAX_REGISTER_SIZE];
d486 1
a486 2
	  for (i = 0;
	       (i < TUI_DATA_WIN->detail.data_display_info.regs_content_count); i++)
d488 2
a489 2
	      struct tui_data_element * data_element_ptr;
	      struct tui_gen_win_info * data_item_win_ptr;
d492 8
a499 10
	      data_item_win_ptr = &TUI_DATA_WIN->detail.data_display_info.
		regs_content[i]->which_element.data_window;
	      data_element_ptr = &((struct tui_win_element *)
			     data_item_win_ptr->content[0])->which_element.data;
	      was_hilighted = data_element_ptr->highlight;
	      data_element_ptr->highlight =
		tui_reg_value_has_changed (data_element_ptr, frame, &raw_buf[0]);
	      if (data_element_ptr->highlight)
		{
                  int size;
d501 1
a501 11
                  size = DEPRECATED_REGISTER_RAW_SIZE (data_element_ptr->item_no);
		  for (j = 0; j < size; j++)
		    ((char *) data_element_ptr->value)[j] = raw_buf[j];
		  tui_display_register (
					data_element_ptr->item_no,
					data_item_win_ptr,
			((TUI_DATA_WIN->detail.data_display_info.regs_display_type ==
			  TUI_DFLOAT_REGS) ?
			 double_precision : unspecified_precision));
		}
	      else if (was_hilighted)
d503 1
a503 7
		  data_element_ptr->highlight = FALSE;
		  tui_display_register (
					data_element_ptr->item_no,
					data_item_win_ptr,
			((TUI_DATA_WIN->detail.data_display_info.regs_display_type ==
			  TUI_DFLOAT_REGS) ?
			 double_precision : unspecified_precision));
a507 1
  return;
d510 37
d548 7
a554 5
/*
   ** tui_toggle_float_regs().
 */
void
tui_toggle_float_regs (void)
d556 2
a557 1
  struct tui_layout_def * layout_def = tui_layout_def ();
d559 5
a563 4
  if (layout_def->float_regs_display_type == TUI_SFLOAT_REGS)
    layout_def->float_regs_display_type = TUI_DFLOAT_REGS;
  else
    layout_def->float_regs_display_type = TUI_SFLOAT_REGS;
d565 5
a569 4
  if (TUI_DATA_WIN != NULL && TUI_DATA_WIN->generic.is_visible &&
      (TUI_DATA_WIN->detail.data_display_info.regs_display_type == TUI_SFLOAT_REGS ||
       TUI_DATA_WIN->detail.data_display_info.regs_display_type == TUI_DFLOAT_REGS))
    tui_show_registers (layout_def->float_regs_display_type);
d571 1
a571 2
  return;
}				/* tui_toggle_float_regs */
d573 7
d584 22
d608 1
a608 1
      add_com ("fr", class_tui, tui_show_float_command,
d610 1
a610 1
      add_com ("gr", class_tui, tui_show_general_command,
d612 1
a612 1
      add_com ("sr", class_tui, tui_show_special_command,
a617 8
      add_com ("tf", class_tui, _tui_toggle_float_regs_command,
	       "Toggle between single and double precision floating point registers.\n");
      add_cmd (TUI_FLOAT_REGS_NAME_LOWER,
	       class_tui,
	       _tui_toggle_float_regs_command,
	       "Toggle between single and double precision floating point \
registers.\n",
	       &togglelist);
a625 10

/*
   ** tui_register_name().
   **        Return the register name.
 */
static const char *
tui_register_name (int reg_num)
{
  return REGISTER_NAME (reg_num);
}
d636 2
a637 5
/*
   ** tui_register_format
   **        Function to format the register name and value into a buffer,
   **        suitable for printing or display
 */
d639 2
a640 3
tui_register_format (char *buf, int buf_len, int reg_num,
                    struct tui_data_element * data_element,
                    enum precision_type precision)
d646 1
a646 1
  char *p;
d648 1
d650 1
a650 1
  name = REGISTER_NAME (reg_num);
a652 1
      strcpy (buf, "");
d658 1
a658 1
  stream = tui_sfileopen (buf_len);
d661 15
a675 2
  gdbarch_print_registers_info (current_gdbarch, stream, deprecated_selected_frame,
                                reg_num, 1);
a678 16
  pos = 0;
  while (*p && *p == *name++ && buf_len)
    {
      *buf++ = *p++;
      buf_len--;
      pos++;
    }
  while (*p == ' ')
    p++;
  while (pos < 8 && buf_len)
    {
      *buf++ = ' ';
      buf_len--;
      pos++;
    }
  strncpy (buf, p, buf_len);
d681 3
a683 3
  p = strchr (buf, '\n');
  if (p)
    *p = 0;
d685 2
d690 3
a692 24

#define NUM_GENERAL_REGS    32
/* Set the content of the data window to consist of the general
   registers.  */
static enum tui_status
tui_set_general_regs_content (int refresh_values_only)
{
  return (tui_set_regs_content (0,
			      NUM_GENERAL_REGS - 1,
			      deprecated_selected_frame,
			      TUI_GENERAL_REGS,
			      refresh_values_only));

}


#ifndef PCOQ_HEAD_REGNUM
#define START_SPECIAL_REGS  0
#else
#define START_SPECIAL_REGS    PCOQ_HEAD_REGNUM
#endif

/* Set the content of the data window to consist of the special
   registers.  */
d694 2
a695 1
tui_set_special_regs_content (int refresh_values_only)
a697 1
  int end_reg_num;
d699 3
a701 56
  end_reg_num = FP0_REGNUM - 1;
  ret = tui_set_regs_content (START_SPECIAL_REGS,
			    end_reg_num,
			    deprecated_selected_frame,
			    TUI_SPECIAL_REGS,
			    refresh_values_only);

  return ret;
}


/* Set the content of the data window to consist of the special
   registers.  */
static enum tui_status
tui_set_general_and_special_regs_content (int refresh_values_only)
{
  enum tui_status ret = TUI_FAILURE;
  int end_reg_num = (-1);

  end_reg_num = FP0_REGNUM - 1;
  ret = tui_set_regs_content (
	 0, end_reg_num, deprecated_selected_frame, TUI_SPECIAL_REGS, refresh_values_only);

  return ret;
}

/* Set the content of the data window to consist of the float
   registers.  */
static enum tui_status
tui_set_float_regs_content (enum tui_register_display_type dpy_type,
			    int refresh_values_only)
{
  enum tui_status ret = TUI_FAILURE;
  int start_reg_num;

  start_reg_num = FP0_REGNUM;
  ret = tui_set_regs_content (start_reg_num,
			    NUM_REGS - 1,
			    deprecated_selected_frame,
			    dpy_type,
			    refresh_values_only);

  return ret;
}


/* Answer TRUE if the register's value has changed, FALSE otherwise.
   If TRUE, new_value is filled in with the new value.  */
static int
tui_reg_value_has_changed (struct tui_data_element * data_element,
			   struct frame_info *frame, char *new_value)
{
  int has_changed = FALSE;

  if (data_element->item_no != UNDEFINED_ITEM &&
      tui_register_name (data_element->item_no) != (char *) NULL)
d703 1
a703 2
      char raw_buf[MAX_REGISTER_SIZE];
      int i;
d705 1
a705 27
      if (tui_get_register_raw_value (data_element->item_no, raw_buf, frame) == TUI_SUCCESS)
	{
          int size = DEPRECATED_REGISTER_RAW_SIZE (data_element->item_no);
          
	  for (i = 0; (i < size && !has_changed); i++)
	    has_changed = (((char *) data_element->value)[i] != raw_buf[i]);
	  if (has_changed && new_value != (char *) NULL)
	    {
	      for (i = 0; i < size; i++)
		new_value[i] = raw_buf[i];
	    }
	}
    }
  return has_changed;
}



/* Get the register raw value.  The raw value is returned in reg_value.  */
static enum tui_status
tui_get_register_raw_value (int reg_num, char *reg_value, struct frame_info *frame)
{
  enum tui_status ret = TUI_FAILURE;

  if (target_has_registers)
    {
      get_frame_register (frame, reg_num, reg_value);
d709 21
a729 2
      if (register_cached (reg_num) >= 0)
	ret = TUI_SUCCESS;
a732 223



/* Function to initialize a data element with the input and the
   register value.  */
static void
tui_set_register_element (int reg_num, struct frame_info *frame,
			  struct tui_data_element * data_element,
			  int refresh_value_only)
{
  if (data_element != (struct tui_data_element *) NULL)
    {
      if (!refresh_value_only)
	{
	  data_element->item_no = reg_num;
	  data_element->name = tui_register_name (reg_num);
	  data_element->highlight = FALSE;
	}
      if (data_element->value == NULL)
	data_element->value = xmalloc (MAX_REGISTER_SIZE);
      if (data_element->value != NULL)
	tui_get_register_raw_value (reg_num, data_element->value, frame);
    }
}


/* Set the content of the data window to consist of the registers
   numbered from start_reg_num to end_reg_num.  Note that if
   refresh_values_only is TRUE, start_reg_num and end_reg_num are
   ignored.  */
static enum tui_status
tui_set_regs_content (int start_reg_num, int end_reg_num,
                    struct frame_info *frame,
                    enum tui_register_display_type dpy_type,
                    int refresh_values_only)
{
  enum tui_status ret = TUI_FAILURE;
  int num_regs = end_reg_num - start_reg_num + 1;
  int allocated_here = FALSE;

  if (TUI_DATA_WIN->detail.data_display_info.regs_content_count > 0 &&
      !refresh_values_only)
    {
      tui_free_data_content (TUI_DATA_WIN->detail.data_display_info.regs_content,
			     TUI_DATA_WIN->detail.data_display_info.regs_content_count);
      TUI_DATA_WIN->detail.data_display_info.regs_content_count = 0;
    }
  if (TUI_DATA_WIN->detail.data_display_info.regs_content_count <= 0)
    {
      TUI_DATA_WIN->detail.data_display_info.regs_content =
	tui_alloc_content (num_regs, DATA_WIN);
      allocated_here = TRUE;
    }

  if (TUI_DATA_WIN->detail.data_display_info.regs_content != (tui_win_content) NULL)
    {
      int i;

      if (!refresh_values_only || allocated_here)
	{
	  TUI_DATA_WIN->generic.content = NULL;
	  TUI_DATA_WIN->generic.content_size = 0;
	  tui_add_content_elements (&TUI_DATA_WIN->generic, num_regs);
	  TUI_DATA_WIN->detail.data_display_info.regs_content =
	    (tui_win_content) TUI_DATA_WIN->generic.content;
	  TUI_DATA_WIN->detail.data_display_info.regs_content_count = num_regs;
	}
      /*
         ** Now set the register names and values
       */
      for (i = start_reg_num; (i <= end_reg_num); i++)
	{
	  struct tui_gen_win_info * data_item_win;

	  data_item_win = &TUI_DATA_WIN->detail.data_display_info.
	    regs_content[i - start_reg_num]->which_element.data_window;
	  tui_set_register_element (
				   i,
				   frame,
	   &((struct tui_win_element *) data_item_win->content[0])->which_element.data,
				   !allocated_here && refresh_values_only);
	}
      TUI_DATA_WIN->detail.data_display_info.regs_column_count =
	tui_calculate_regs_column_count (dpy_type);
#ifdef LATER
      if (TUI_DATA_WIN->detail.data_display_info.data_content_count > 0)
	{
	  /* delete all the windows? */
	  /* realloc content equal to data_content_count + regs_content_count */
	  /* append TUI_DATA_WIN->detail.data_display_info.data_content to content */
	}
#endif
      TUI_DATA_WIN->generic.content_size =
	TUI_DATA_WIN->detail.data_display_info.regs_content_count +
	TUI_DATA_WIN->detail.data_display_info.data_content_count;
      ret = TUI_SUCCESS;
    }

  return ret;
}


/* Function to display a register in a window.  If hilite is TRUE,
   than the value will be displayed in reverse video.  */
static void
tui_display_register (int reg_num,
                     struct tui_gen_win_info * win_info,		/* the data item window */
                     enum precision_type precision)
{
  if (win_info->handle != (WINDOW *) NULL)
    {
      int i;
      char buf[40];
      int value_chars_wide;
      struct tui_data_element * data_element_ptr = &((tui_win_content)
				    win_info->content)[0]->which_element.data;

      /* Do not rename the following variable into "label_width".
         Unfortunately, term.h on AiX systems defines a macro with
         the same name, which causes a build failure if we use the
         same name for this variable.  */
      int tui_label_width;

      if (IS_64BIT ||
	  TUI_DATA_WIN->detail.data_display_info.regs_display_type == TUI_DFLOAT_REGS)
	{
	  value_chars_wide = DOUBLE_FLOAT_VALUE_WIDTH;
	  tui_label_width = DOUBLE_FLOAT_LABEL_WIDTH;
	}
      else
	{
	  if (TUI_DATA_WIN->detail.data_display_info.regs_display_type ==
	      TUI_SFLOAT_REGS)
	    {
	      value_chars_wide = SINGLE_FLOAT_VALUE_WIDTH;
	      tui_label_width = SINGLE_FLOAT_LABEL_WIDTH;
	    }
	  else
	    {
	      value_chars_wide = SINGLE_VALUE_WIDTH;
	      tui_label_width = SINGLE_LABEL_WIDTH;
	    }
	}

      buf[0] = (char) 0;
      tui_register_format (buf,
			  value_chars_wide + tui_label_width,
			  reg_num,
			  data_element_ptr,
			  precision);

      if (data_element_ptr->highlight)
	wstandout (win_info->handle);

      wmove (win_info->handle, 0, 0);
      for (i = 1; i < win_info->width; i++)
        waddch (win_info->handle, ' ');
      wmove (win_info->handle, 0, 0);
      waddstr (win_info->handle, buf);

      if (data_element_ptr->highlight)
	wstandend (win_info->handle);
      tui_refresh_win (win_info);
    }
}


static void
tui_v_show_registers_command_support (enum tui_register_display_type dpy_type)
{

  if (TUI_DATA_WIN != NULL && TUI_DATA_WIN->generic.is_visible)
    {				/* Data window already displayed, show the registers */
      if (TUI_DATA_WIN->detail.data_display_info.regs_display_type != dpy_type)
	tui_show_registers (dpy_type);
    }
  else
    (tui_layout_def ())->regs_display_type = dpy_type;

  return;
}


static void
tui_show_float_command (char *arg, int from_tty)
{
  if (TUI_DATA_WIN == NULL || !TUI_DATA_WIN->generic.is_visible ||
      (TUI_DATA_WIN->detail.data_display_info.regs_display_type != TUI_SFLOAT_REGS &&
       TUI_DATA_WIN->detail.data_display_info.regs_display_type != TUI_DFLOAT_REGS))
    tui_v_show_registers_command_support ((tui_layout_def ())->float_regs_display_type);
}


static void
tui_show_general_command (char *arg, int from_tty)
{
  tui_v_show_registers_command_support (TUI_GENERAL_REGS);
}


static void
tui_show_special_command (char *arg, int from_tty)
{
  tui_v_show_registers_command_support (TUI_SPECIAL_REGS);
}


static void
_tui_toggle_float_regs_command (char *arg, int from_tty)
{
  if (TUI_DATA_WIN != NULL && TUI_DATA_WIN->generic.is_visible)
    tui_toggle_float_regs ();
  else
    {
      struct tui_layout_def * layout_def = tui_layout_def ();

      if (layout_def->float_regs_display_type == TUI_SFLOAT_REGS)
	layout_def->float_regs_display_type = TUI_DFLOAT_REGS;
      else
	layout_def->float_regs_display_type = TUI_SFLOAT_REGS;
    }
}

@


1.12.4.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@a40 1
#include "reggroups.h"
d44 21
d67 1
a67 1
** STATIC LOCAL FUNCTIONS FORWARD DECLS    **
a68 3
static void
tui_display_register (struct tui_data_element *data,
                      struct tui_gen_win_info *win_info);
a69 3
static enum tui_status
tui_show_register_group (struct gdbarch *gdbarch, struct reggroup *group,
                         struct frame_info *frame, int refresh_values_only);
d71 10
a80 3
static enum tui_status
tui_get_register (struct gdbarch *gdbarch, struct frame_info *frame,
                  struct tui_data_element *data, int regnum, int *changedp);
d82 12
a93 1
  (struct gdbarch *, struct frame_info *, struct tui_data_element*, int);
d177 26
a202 2
/* Show the registers of the given group in the data window
   and refresh the window.  */
d204 1
a204 1
tui_show_registers (struct reggroup *group)
d207 1
a207 1
  struct tui_data_info *display_info = &TUI_DATA_WIN->detail.data_display_info;
d209 2
a210 2
  if (group == 0)
    group = general_reggroup;
d212 22
a233 2
  /* Say that registers should be displayed, even if there is a problem.  */
  display_info->display_regs = TRUE;
d235 5
a239 5
  if (target_has_registers && target_has_stack && target_has_memory)
    {
      ret = tui_show_register_group (current_gdbarch, group,
                                     get_current_frame (),
                                     group == display_info->current_group);
d243 1
a243 1
      display_info->current_group = 0;
d251 1
a251 1
      for (i = 0; i < display_info->regs_content_count; i++)
d253 1
a253 2
	  struct tui_gen_win_info *data_item_win;
          struct tui_win_element *win;
d255 4
a258 4
	  data_item_win = &display_info->regs_content[i]
            ->which_element.data_window;
          win = (struct tui_win_element *) data_item_win->content[0];
          win->which_element.data.highlight = FALSE;
d260 1
a260 1
      display_info->current_group = group;
d263 3
a268 100
/* Set the data window to display the registers of the register group
   using the given frame.  Values are refreshed only when refresh_values_only
   is TRUE.  */

static enum tui_status
tui_show_register_group (struct gdbarch *gdbarch, struct reggroup *group,
                         struct frame_info *frame, int refresh_values_only)
{
  enum tui_status ret = TUI_FAILURE;
  int nr_regs;
  int allocated_here = FALSE;
  int regnum, pos;
  char title[80];
  struct tui_data_info *display_info = &TUI_DATA_WIN->detail.data_display_info;

  /* Make a new title showing which group we display.  */
  snprintf (title, sizeof (title) - 1, "Register group: %s",
            reggroup_name (group));
  xfree (TUI_DATA_WIN->generic.title);
  TUI_DATA_WIN->generic.title = xstrdup (title);

  /* See how many registers must be displayed.  */
  nr_regs = 0;
  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
    {
      /* Must be in the group and have a name.  */
      if (gdbarch_register_reggroup_p (gdbarch, regnum, group)
          && gdbarch_register_name (gdbarch, regnum) != 0)
        nr_regs++;
    }

  if (display_info->regs_content_count > 0 && !refresh_values_only)
    {
      tui_free_data_content (display_info->regs_content,
                             display_info->regs_content_count);
      display_info->regs_content_count = 0;
    }

  if (display_info->regs_content_count <= 0)
    {
      display_info->regs_content = tui_alloc_content (nr_regs, DATA_WIN);
      allocated_here = TRUE;
      refresh_values_only = FALSE;
    }

  if (display_info->regs_content != (tui_win_content) NULL)
    {
      if (!refresh_values_only || allocated_here)
	{
	  TUI_DATA_WIN->generic.content = (void*) NULL;
	  TUI_DATA_WIN->generic.content_size = 0;
	  tui_add_content_elements (&TUI_DATA_WIN->generic, nr_regs);
	  display_info->regs_content
            = (tui_win_content) TUI_DATA_WIN->generic.content;
	  display_info->regs_content_count = nr_regs;
	}

      /* Now set the register names and values */
      pos = 0;
      for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
        {
	  struct tui_gen_win_info *data_item_win;
          struct tui_data_element *data;
          const char *name;

          if (!gdbarch_register_reggroup_p (gdbarch, regnum, group))
            continue;

          name = gdbarch_register_name (gdbarch, regnum);
          if (name == 0)
            continue;

	  data_item_win =
            &display_info->regs_content[pos]->which_element.data_window;
          data =
            &((struct tui_win_element *) data_item_win->content[0])->which_element.data;
          if (data)
            {
              if (!refresh_values_only)
                {
                  data->item_no = regnum;
                  data->name = name;
                  data->highlight = FALSE;
                }
              if (data->value == (void*) NULL)
                data->value = (void*) xmalloc (MAX_REGISTER_SIZE);

              tui_get_register (gdbarch, frame, data, regnum, 0);
            }
          pos++;
	}

      TUI_DATA_WIN->generic.content_size =
	display_info->regs_content_count + display_info->data_content_count;
      ret = TUI_SUCCESS;
    }

  return ret;
}

d276 2
a277 4
  struct tui_data_info *display_info = &TUI_DATA_WIN->detail.data_display_info;

  if (display_info->regs_content != (tui_win_content) NULL &&
      display_info->regs_content_count > 0)
d281 1
d283 30
a312 35
      int max_len = 0;
      for (i = 0; i < display_info->regs_content_count; i++)
        {
          struct tui_data_element *data;
          struct tui_gen_win_info *data_item_win;
          char *p;
          int len;

          data_item_win = &display_info->regs_content[i]->which_element.data_window;
          data = &((struct tui_win_element *)
                   data_item_win->content[0])->which_element.data;
          len = 0;
          p = data->content;
          if (p != 0)
            while (*p)
              {
                if (*p++ == '\t')
                  len = 8 * ((len / 8) + 1);
                else
                  len++;
              }

          if (len > max_len)
            max_len = len;
        }
      item_win_width = max_len + 1;
      i = start_element_no;

      display_info->regs_column_count =
        (TUI_DATA_WIN->generic.width - 2) / item_win_width;
      if (display_info->regs_column_count == 0)
        display_info->regs_column_count = 1;
      item_win_width =
        (TUI_DATA_WIN->generic.width - 2) / display_info->regs_column_count;

d317 1
a317 1
      while (i < display_info->regs_content_count &&
d321 2
a322 2
	       (j < display_info->regs_column_count &&
		i < display_info->regs_content_count); j++)
d328 2
a329 2
	      data_item_win = &display_info->regs_content[i]
                ->which_element.data_window;
a331 10
              if (data_item_win->handle != (WINDOW*) NULL
                  && (data_item_win->height != 1
                      || data_item_win->width != item_win_width
                      || data_item_win->origin.x != (item_win_width * j) + 1
                      || data_item_win->origin.y != cur_y))
                {
                  tui_delete_win (data_item_win->handle);
                  data_item_win->handle = 0;
                }
                  
d335 2
a336 1
		  data_item_win->width = item_win_width;
d344 6
a349 3
	      /* Get the printable representation of the register
                 and display it.  */
              tui_display_register (data_element_ptr, data_item_win);
d355 2
d445 3
a447 5
      struct tui_data_info *display_info
        = &TUI_DATA_WIN->detail.data_display_info;

      if (display_info->regs_content_count <= 0 && display_info->display_regs)
	tui_show_registers (display_info->current_group);
d451 1
d453 2
a454 1
	  for (i = 0; (i < display_info->regs_content_count); i++)
d456 2
a457 2
	      struct tui_data_element *data;
	      struct tui_gen_win_info *data_item_win_ptr;
d460 10
a469 5
	      data_item_win_ptr = &display_info->regs_content[i]->
                which_element.data_window;
	      data = &((struct tui_win_element *)
                       data_item_win_ptr->content[0])->which_element.data;
	      was_hilighted = data->highlight;
d471 11
a481 4
              tui_get_register (current_gdbarch, frame, data,
                                data->item_no, &data->highlight);

	      if (data->highlight || was_hilighted)
d483 7
a489 1
                  tui_display_register (data, data_item_win_ptr);
d494 1
a496 19
/* Display a register in a window.  If hilite is TRUE,
   then the value will be displayed in reverse video  */
static void
tui_display_register (struct tui_data_element *data,
                      struct tui_gen_win_info *win_info)
{
  if (win_info->handle != (WINDOW *) NULL)
    {
      int i;

      if (data->highlight)
	wstandout (win_info->handle);
      
      wmove (win_info->handle, 0, 0);
      for (i = 1; i < win_info->width; i++)
        waddch (win_info->handle, ' ');
      wmove (win_info->handle, 0, 0);
      if (data->content)
        waddstr (win_info->handle, data->content);
d498 5
a502 8
      if (data->highlight)
	wstandend (win_info->handle);
      tui_refresh_win (win_info);
    }
}

static void
tui_reg_next_command (char *arg, int from_tty)
d504 1
a504 4
  if (TUI_DATA_WIN != 0)
    {
      struct reggroup *group
        = TUI_DATA_WIN->detail.data_display_info.current_group;
d506 4
a509 20
      group = reggroup_next (current_gdbarch, group);
      if (group == 0)
        group = reggroup_next (current_gdbarch, 0);

      if (group)
        tui_show_registers (group);
    }
}

static void
tui_reg_float_command (char *arg, int from_tty)
{
  tui_show_registers (float_reggroup);
}

static void
tui_reg_general_command (char *arg, int from_tty)
{
  tui_show_registers (general_reggroup);
}
d511 4
a514 5
static void
tui_reg_system_command (char *arg, int from_tty)
{
  tui_show_registers (system_reggroup);
}
d516 2
a517 1
static struct cmd_list_element *tuireglist;
a518 7
static void
tui_reg_command (char *args, int from_tty)
{
  printf_unfiltered ("\"tui reg\" must be followed by the name of a "
                     "tui reg command.\n");
  help_list (tuireglist, "tui reg ", -1, gdb_stdout);
}
a522 22
  struct cmd_list_element **tuicmd;

  tuicmd = tui_get_cmd_list ();

  add_prefix_cmd ("reg", class_tui, tui_reg_command,
                  "TUI commands to control the register window.",
                  &tuireglist, "tui reg ", 0,
                  tuicmd);

  add_cmd ("float", class_tui, tui_reg_float_command,
           "Display only floating point registers\n",
           &tuireglist);
  add_cmd ("general", class_tui, tui_reg_general_command,
           "Display only general registers\n",
           &tuireglist);
  add_cmd ("system", class_tui, tui_reg_system_command,
           "Display only system registers\n",
           &tuireglist);
  add_cmd ("next", class_tui, tui_reg_next_command,
           "Display next register group\n",
           &tuireglist);

d525 1
a525 1
      add_com ("fr", class_tui, tui_reg_float_command,
d527 1
a527 1
      add_com ("gr", class_tui, tui_reg_general_command,
d529 1
a529 1
      add_com ("sr", class_tui, tui_reg_system_command,
d535 8
d551 10
d571 5
a575 2
/* Get the register from the frame and make a printable representation
   of it in the data element.  */
d577 3
a579 2
tui_register_format (struct gdbarch *gdbarch, struct frame_info *frame,
                     struct tui_data_element *data_element, int regnum)
d585 1
a585 1
  char *p, *s;
a586 1
  struct type *type = gdbarch_register_type (gdbarch, regnum);
d588 1
a588 1
  name = gdbarch_register_name (gdbarch, regnum);
d591 1
d597 1
a597 1
  stream = tui_sfileopen (256);
d600 2
a601 4
  if (TYPE_VECTOR (type) != 0 && 0)
    {
      char buf[MAX_REGISTER_SIZE];
      int len;
d603 4
a606 6
      len = register_size (current_gdbarch, regnum);
      fprintf_filtered (stream, "%-14s ", name);
      get_frame_register (frame, regnum, buf);
      print_scalar_formatted (buf, type, 'f', len, stream);
    }
  else
d608 11
a618 2
      gdbarch_print_registers_info (current_gdbarch, stream,
                                    frame, regnum, 1);
d620 1
a620 3

  /* Save formatted output in the buffer.  */
  p = tui_file_get_strbuf (stream);
d623 3
a625 3
  s = strrchr (p, '\n');
  if (s && s[1] == 0)
    *s = 0;
a626 2
  xfree (data_element->content);
  data_element->content = xstrdup (p);
d630 58
a687 3
/* Get the register value from the given frame and format it for
   the display.  When changep is set, check if the new register value
   has changed with respect to the previous call.  */
d689 52
a740 2
tui_get_register (struct gdbarch *gdbarch, struct frame_info *frame,
                  struct tui_data_element *data, int regnum, int *changedp)
a743 2
  if (changedp)
    *changedp = FALSE;
d746 1
a746 3
      char buf[MAX_REGISTER_SIZE];

      get_frame_register (frame, regnum, buf);
d750 2
a751 21
      if (register_cached (regnum) >= 0)
        {
          if (changedp)
            {
              int size = register_size (gdbarch, regnum);
              char *old = (char*) data->value;
              int i;

              for (i = 0; i < size; i++)
                if (buf[i] != old[i])
                  {
                    *changedp = TRUE;
                    old[i] = buf[i];
                  }
            }

          /* Reformat the data content if the value changed.  */
          if (changedp == 0 || *changedp == TRUE)
            tui_register_format (gdbarch, frame, data, regnum);
          ret = TUI_SUCCESS;
        }
d755 223
@


1.12.2.1
log
@	* tui/tui-win.h (tui_get_cmd_list): Declare.
	* tui/tui-win.c (tui_command): New function.
	(tui_get_cmd_list): New function.
	(_initialize_tui_win): Moved initialization of tui command in
	tui_get_cmd_list.

	* tui/tui-data.c (init_content_element): Setup new data members.
	(init_win_info): Likewise.
	(free_content_elements): Free it.
	* tui/tui-data.h (struct tui_data_element): Store the register
	content to print.
	(struct tui_data_info): Keep the current register group.

	* tui/tui-layout.c (tui_set_layout): Update call to tui_show_registers.

	* tui/tui-regs.h (tui_show_registers): Update prototype.
	(tui_toggle_float_regs, tui_calculate_regs_column_count): Remove.
	(tui_resize_all): No need to calculate anything for register window.
	* tui/tui-regs.c (tui_calculate_regs_column_count): Remove.
	(tui_set_register_element, tui_set_general_regs_content): Remove.
	(tui_set_special_regs_content): Remove.
	(tui_set_general_and_special_regs_content): Remove.
	(tui_set_float_regs_content): Remove.
	(tui_reg_value_has_changed, tui_get_register_raw_value): Remove.
	(tui_set_regs_content): Remove.
	(tui_toggle_float_regs, _tui_toggle_float_regs_command): Remove.
	(tui_v_show_registers_command_support): Remove.
	(tui_show_registers): Use a reggroup to specify the registers to show.
	(tui_show_register_group): New function.
	(tui_display_registers_from): Compute the layout of register window
	and refresh with new API; be sure to delete old register windows.
	(tui_check_register_values): Update to use tui_get_register and
	tui_display_data.
	(tui_display_register): Just refresh the register window part.
	(tui_register_format): Format registers and save in tui_data_element.
	(tui_get_register): New to combine tui_reg_value_has_changed and
	tui_get_register_raw_value; fix to use the new gdb API.
	(tui_show_float_command): Renamed tui_reg_float_command.
	(tui_show_general_command): Renamed tui_reg_general_command.
	(tui_show_special_command): Renamed tui_reg_system_command.
	(_initialize_tui_regs): Remove unused commands.
@
text
@a40 1
#include "reggroups.h"
d44 21
d67 1
a67 1
** STATIC LOCAL FUNCTIONS FORWARD DECLS    **
a68 3
static void
tui_display_register (struct tui_data_element *data,
                      struct tui_gen_win_info *win_info);
a69 3
static enum tui_status
tui_show_register_group (struct gdbarch *gdbarch, struct reggroup *group,
                         struct frame_info *frame, int refresh_values_only);
d71 10
a80 3
static enum tui_status
tui_get_register (struct gdbarch *gdbarch, struct frame_info *frame,
                  struct tui_data_element *data, int regnum, int *changedp);
d82 12
a93 1
  (struct gdbarch *, struct frame_info *, struct tui_data_element*, int);
d177 26
a202 2
/* Show the registers of the given group in the data window
   and refresh the window.  */
d204 1
a204 1
tui_show_registers (struct reggroup *group)
d207 1
a207 1
  struct tui_data_info *display_info = &TUI_DATA_WIN->detail.data_display_info;
d209 2
a210 2
  if (group == 0)
    group = general_reggroup;
d212 22
a233 2
  /* Say that registers should be displayed, even if there is a problem.  */
  display_info->display_regs = TRUE;
d235 5
a239 5
  if (target_has_registers && target_has_stack && target_has_memory)
    {
      ret = tui_show_register_group (current_gdbarch, group,
                                     get_current_frame (),
                                     group == display_info->current_group);
d243 1
a243 1
      display_info->current_group = 0;
d251 1
a251 1
      for (i = 0; i < display_info->regs_content_count; i++)
d253 1
a253 2
	  struct tui_gen_win_info *data_item_win;
          struct tui_win_element *win;
d255 4
a258 4
	  data_item_win = &display_info->regs_content[i]
            ->which_element.data_window;
          win = (struct tui_win_element *) data_item_win->content[0];
          win->which_element.data.highlight = FALSE;
d260 1
a260 1
      display_info->current_group = group;
d263 3
a268 100
/* Set the data window to display the registers of the register group
   using the given frame.  Values are refreshed only when refresh_values_only
   is TRUE.  */

static enum tui_status
tui_show_register_group (struct gdbarch *gdbarch, struct reggroup *group,
                         struct frame_info *frame, int refresh_values_only)
{
  enum tui_status ret = TUI_FAILURE;
  int nr_regs;
  int allocated_here = FALSE;
  int regnum, pos;
  char title[80];
  struct tui_data_info *display_info = &TUI_DATA_WIN->detail.data_display_info;

  /* Make a new title showing which group we display.  */
  snprintf (title, sizeof (title) - 1, "Register group: %s",
            reggroup_name (group));
  xfree (TUI_DATA_WIN->generic.title);
  TUI_DATA_WIN->generic.title = xstrdup (title);

  /* See how many registers must be displayed.  */
  nr_regs = 0;
  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
    {
      /* Must be in the group and have a name.  */
      if (gdbarch_register_reggroup_p (gdbarch, regnum, group)
          && gdbarch_register_name (gdbarch, regnum) != 0)
        nr_regs++;
    }

  if (display_info->regs_content_count > 0 && !refresh_values_only)
    {
      tui_free_data_content (display_info->regs_content,
                             display_info->regs_content_count);
      display_info->regs_content_count = 0;
    }

  if (display_info->regs_content_count <= 0)
    {
      display_info->regs_content = tui_alloc_content (nr_regs, DATA_WIN);
      allocated_here = TRUE;
      refresh_values_only = FALSE;
    }

  if (display_info->regs_content != (tui_win_content) NULL)
    {
      if (!refresh_values_only || allocated_here)
	{
	  TUI_DATA_WIN->generic.content = (void*) NULL;
	  TUI_DATA_WIN->generic.content_size = 0;
	  tui_add_content_elements (&TUI_DATA_WIN->generic, nr_regs);
	  display_info->regs_content
            = (tui_win_content) TUI_DATA_WIN->generic.content;
	  display_info->regs_content_count = nr_regs;
	}

      /* Now set the register names and values */
      pos = 0;
      for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
        {
	  struct tui_gen_win_info *data_item_win;
          struct tui_data_element *data;
          const char *name;

          if (!gdbarch_register_reggroup_p (gdbarch, regnum, group))
            continue;

          name = gdbarch_register_name (gdbarch, regnum);
          if (name == 0)
            continue;

	  data_item_win =
            &display_info->regs_content[pos]->which_element.data_window;
          data =
            &((struct tui_win_element *) data_item_win->content[0])->which_element.data;
          if (data)
            {
              if (!refresh_values_only)
                {
                  data->item_no = regnum;
                  data->name = name;
                  data->highlight = FALSE;
                }
              if (data->value == (void*) NULL)
                data->value = (void*) xmalloc (MAX_REGISTER_SIZE);

              tui_get_register (gdbarch, frame, data, regnum, 0);
            }
          pos++;
	}

      TUI_DATA_WIN->generic.content_size =
	display_info->regs_content_count + display_info->data_content_count;
      ret = TUI_SUCCESS;
    }

  return ret;
}

d276 2
a277 4
  struct tui_data_info *display_info = &TUI_DATA_WIN->detail.data_display_info;

  if (display_info->regs_content != (tui_win_content) NULL &&
      display_info->regs_content_count > 0)
d281 1
d283 30
a312 35
      int max_len = 0;
      for (i = 0; i < display_info->regs_content_count; i++)
        {
          struct tui_data_element *data;
          struct tui_gen_win_info *data_item_win;
          char *p;
          int len;

          data_item_win = &display_info->regs_content[i]->which_element.data_window;
          data = &((struct tui_win_element *)
                   data_item_win->content[0])->which_element.data;
          len = 0;
          p = data->content;
          if (p != 0)
            while (*p)
              {
                if (*p++ == '\t')
                  len = 8 * ((len / 8) + 1);
                else
                  len++;
              }

          if (len > max_len)
            max_len = len;
        }
      item_win_width = max_len + 1;
      i = start_element_no;

      display_info->regs_column_count =
        (TUI_DATA_WIN->generic.width - 2) / item_win_width;
      if (display_info->regs_column_count == 0)
        display_info->regs_column_count = 1;
      item_win_width =
        (TUI_DATA_WIN->generic.width - 2) / display_info->regs_column_count;

d317 1
a317 1
      while (i < display_info->regs_content_count &&
d321 2
a322 2
	       (j < display_info->regs_column_count &&
		i < display_info->regs_content_count); j++)
d328 2
a329 2
	      data_item_win = &display_info->regs_content[i]
                ->which_element.data_window;
a331 10
              if (data_item_win->handle != (WINDOW*) NULL
                  && (data_item_win->height != 1
                      || data_item_win->width != item_win_width
                      || data_item_win->origin.x != (item_win_width * j) + 1
                      || data_item_win->origin.y != cur_y))
                {
                  tui_delete_win (data_item_win->handle);
                  data_item_win->handle = 0;
                }
                  
d335 2
a336 1
		  data_item_win->width = item_win_width;
d344 6
a349 3
	      /* Get the printable representation of the register
                 and display it.  */
              tui_display_register (data_element_ptr, data_item_win);
d355 2
d445 3
a447 5
      struct tui_data_info *display_info
        = &TUI_DATA_WIN->detail.data_display_info;

      if (display_info->regs_content_count <= 0 && display_info->display_regs)
	tui_show_registers (display_info->current_group);
d451 1
d453 2
a454 1
	  for (i = 0; (i < display_info->regs_content_count); i++)
d456 2
a457 2
	      struct tui_data_element *data;
	      struct tui_gen_win_info *data_item_win_ptr;
d460 10
a469 5
	      data_item_win_ptr = &display_info->regs_content[i]->
                which_element.data_window;
	      data = &((struct tui_win_element *)
                       data_item_win_ptr->content[0])->which_element.data;
	      was_hilighted = data->highlight;
d471 11
a481 4
              tui_get_register (current_gdbarch, frame, data,
                                data->item_no, &data->highlight);

	      if (data->highlight || was_hilighted)
d483 7
a489 1
                  tui_display_register (data, data_item_win_ptr);
d494 1
a496 19
/* Display a register in a window.  If hilite is TRUE,
   then the value will be displayed in reverse video  */
static void
tui_display_register (struct tui_data_element *data,
                      struct tui_gen_win_info *win_info)
{
  if (win_info->handle != (WINDOW *) NULL)
    {
      int i;

      if (data->highlight)
	wstandout (win_info->handle);
      
      wmove (win_info->handle, 0, 0);
      for (i = 1; i < win_info->width; i++)
        waddch (win_info->handle, ' ');
      wmove (win_info->handle, 0, 0);
      if (data->content)
        waddstr (win_info->handle, data->content);
d498 5
a502 8
      if (data->highlight)
	wstandend (win_info->handle);
      tui_refresh_win (win_info);
    }
}

static void
tui_reg_next_command (char *arg, int from_tty)
d504 1
a504 4
  if (TUI_DATA_WIN != 0)
    {
      struct reggroup *group
        = TUI_DATA_WIN->detail.data_display_info.current_group;
d506 4
a509 20
      group = reggroup_next (current_gdbarch, group);
      if (group == 0)
        group = reggroup_next (current_gdbarch, 0);

      if (group)
        tui_show_registers (group);
    }
}

static void
tui_reg_float_command (char *arg, int from_tty)
{
  tui_show_registers (float_reggroup);
}

static void
tui_reg_general_command (char *arg, int from_tty)
{
  tui_show_registers (general_reggroup);
}
d511 4
a514 5
static void
tui_reg_system_command (char *arg, int from_tty)
{
  tui_show_registers (system_reggroup);
}
d516 2
a517 1
static struct cmd_list_element *tuireglist;
a518 7
static void
tui_reg_command (char *args, int from_tty)
{
  printf_unfiltered ("\"tui reg\" must be followed by the name of a "
                     "tui reg command.\n");
  help_list (tuireglist, "tui reg ", -1, gdb_stdout);
}
a522 22
  struct cmd_list_element **tuicmd;

  tuicmd = tui_get_cmd_list ();

  add_prefix_cmd ("reg", class_tui, tui_reg_command,
                  "TUI commands to control the register window.",
                  &tuireglist, "tui reg ", 0,
                  tuicmd);

  add_cmd ("float", class_tui, tui_reg_float_command,
           "Display only floating point registers\n",
           &tuireglist);
  add_cmd ("general", class_tui, tui_reg_general_command,
           "Display only general registers\n",
           &tuireglist);
  add_cmd ("system", class_tui, tui_reg_system_command,
           "Display only system registers\n",
           &tuireglist);
  add_cmd ("next", class_tui, tui_reg_next_command,
           "Display next register group\n",
           &tuireglist);

d525 1
a525 1
      add_com ("fr", class_tui, tui_reg_float_command,
d527 1
a527 1
      add_com ("gr", class_tui, tui_reg_general_command,
d529 1
a529 1
      add_com ("sr", class_tui, tui_reg_system_command,
d535 8
d551 10
d571 5
a575 2
/* Get the register from the frame and make a printable representation
   of it in the data element.  */
d577 3
a579 2
tui_register_format (struct gdbarch *gdbarch, struct frame_info *frame,
                     struct tui_data_element *data_element, int regnum)
d585 1
a585 1
  char *p, *s;
a586 1
  struct type *type = gdbarch_register_type (gdbarch, regnum);
d588 1
a588 1
  name = gdbarch_register_name (gdbarch, regnum);
d591 1
d597 1
a597 1
  stream = tui_sfileopen (256);
d600 2
a601 4
  if (TYPE_VECTOR (type) != 0 && 0)
    {
      char buf[MAX_REGISTER_SIZE];
      int len;
d603 4
a606 6
      len = register_size (current_gdbarch, regnum);
      fprintf_filtered (stream, "%-14s ", name);
      get_frame_register (frame, regnum, buf);
      print_scalar_formatted (buf, type, 'f', len, stream);
    }
  else
d608 11
a618 2
      gdbarch_print_registers_info (current_gdbarch, stream,
                                    frame, regnum, 1);
d620 1
a620 3

  /* Save formatted output in the buffer.  */
  p = tui_file_get_strbuf (stream);
d623 3
a625 3
  s = strrchr (p, '\n');
  if (s && s[1] == 0)
    *s = 0;
a626 2
  xfree (data_element->content);
  data_element->content = xstrdup (p);
d630 58
a687 3
/* Get the register value from the given frame and format it for
   the display.  When changep is set, check if the new register value
   has changed with respect to the previous call.  */
d689 52
a740 2
tui_get_register (struct gdbarch *gdbarch, struct frame_info *frame,
                  struct tui_data_element *data, int regnum, int *changedp)
a743 2
  if (changedp)
    *changedp = FALSE;
d746 1
a746 3
      char buf[MAX_REGISTER_SIZE];

      get_frame_register (frame, regnum, buf);
d750 2
a751 21
      if (register_cached (regnum) >= 0)
        {
          if (changedp)
            {
              int size = register_size (gdbarch, regnum);
              char *old = (char*) data->value;
              int i;

              for (i = 0; i < size; i++)
                if (buf[i] != old[i])
                  {
                    *changedp = TRUE;
                    old[i] = buf[i];
                  }
            }

          /* Reformat the data content if the value changed.  */
          if (changedp == 0 || *changedp == TRUE)
            tui_register_format (gdbarch, frame, data, regnum);
          ret = TUI_SUCCESS;
        }
d755 223
@


1.12.2.2
log
@	* tui/tui-regs.c (tui_show_registers): Make sure the TUI is active
	and switch the layout to force a display of register window.
@
text
@d151 1
a151 1
  struct tui_data_info *display_info;
a152 9
  /* Make sure the curses mode is enabled.  */
  tui_enable ();

  /* Make sure the register window is visible.  If not, select an
     appropriate layout.  */
  if (TUI_DATA_WIN == NULL || !TUI_DATA_WIN->generic.is_visible)
    tui_set_layout_for_display_command (DATA_NAME);

  display_info = &TUI_DATA_WIN->detail.data_display_info;
@


1.11
log
@2004-02-10  Andrew Cagney  <cagney@@redhat.com>

	* defs.h: Do not include "tui.h".
	* gdb_curses.h: New file.
	* tui/tui-hooks.h: New file.
	* tui/tui.h (tui_update_all_exec_infos): Delete declaration.
	(tui_install_hooks, tui_remove_hooks): Delete declarations.
	(tui_initialize_io): Delete declaration.
	(tui_initialize_readline: Delete redundant declaration.
	(struct tui_point): Delete definition.
	* tui/tui-data.h (struct tui_point): Define.
	* cli/cli-decode.c [TUI]: Include "tui/tui.h".
	* utils.c: Include "tui/tui.h".
	* tui/tui-data.h: Include "tui/tui.h" and "gdb_curses.h".
	* printcmd.c [TUI]: Include "tui/tui.h".
	* cli/cli-cmds.c [TUI]: Include "tui/tui.h".
	* tui/tui-command.c: Include "gdb_curses.h".
	* tui/tui.c, tui/tui-winsource.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-windata.c, tui/tui-win.c, tui/tui-stack.c: Ditto.
	* tui/tui-source.c, tui/tui-regs.c, tui/tui-layout.c: Ditto.
	* tui/tui-io.c, tui/tui-disasm.c, tui/tui-data.c: : Ditto.
	* tui/tui-hooks.c: Include "tui-hooks.h" and "gdb_curses.h".
	* Makefile.in: Update all dependencies.
	(tui_hooks_h, gdb_curses_h): Define.
	(SUBDIR_TUI_CFLAGS): Remove -I${srcdir}/tui.
@
text
@d280 1
a280 1
      int j, value_chars_wide, item_win_width, cur_y, label_width;
d283 6
d296 1
a296 1
	  label_width = DOUBLE_FLOAT_LABEL_WIDTH;
d304 1
a304 1
	      label_width = SINGLE_FLOAT_LABEL_WIDTH;
d309 1
a309 1
	      label_width = SINGLE_LABEL_WIDTH;
d312 1
a312 1
      item_win_width = value_chars_wide + label_width;
d868 1
a868 1
      int value_chars_wide, label_width;
d872 6
d882 1
a882 1
	  label_width = DOUBLE_FLOAT_LABEL_WIDTH;
d890 1
a890 1
	      label_width = SINGLE_FLOAT_LABEL_WIDTH;
d895 1
a895 1
	      label_width = SINGLE_LABEL_WIDTH;
d901 1
a901 1
			  value_chars_wide + label_width,
@


1.11.4.1
log
@Merge mainline to intercu branch.
@
text
@a40 1
#include "reggroups.h"
d44 21
d67 1
a67 1
** STATIC LOCAL FUNCTIONS FORWARD DECLS    **
a68 3
static void
tui_display_register (struct tui_data_element *data,
                      struct tui_gen_win_info *win_info);
a69 3
static enum tui_status
tui_show_register_group (struct gdbarch *gdbarch, struct reggroup *group,
                         struct frame_info *frame, int refresh_values_only);
d71 10
a80 3
static enum tui_status
tui_get_register (struct gdbarch *gdbarch, struct frame_info *frame,
                  struct tui_data_element *data, int regnum, int *changedp);
d82 12
a93 1
  (struct gdbarch *, struct frame_info *, struct tui_data_element*, int);
d177 26
a202 2
/* Show the registers of the given group in the data window
   and refresh the window.  */
d204 1
a204 1
tui_show_registers (struct reggroup *group)
d207 1
a207 1
  struct tui_data_info *display_info = &TUI_DATA_WIN->detail.data_display_info;
d209 2
a210 2
  if (group == 0)
    group = general_reggroup;
d212 22
a233 2
  /* Say that registers should be displayed, even if there is a problem.  */
  display_info->display_regs = TRUE;
d235 5
a239 5
  if (target_has_registers && target_has_stack && target_has_memory)
    {
      ret = tui_show_register_group (current_gdbarch, group,
                                     get_current_frame (),
                                     group == display_info->current_group);
d243 1
a243 1
      display_info->current_group = 0;
d251 1
a251 1
      for (i = 0; i < display_info->regs_content_count; i++)
d253 1
a253 2
	  struct tui_gen_win_info *data_item_win;
          struct tui_win_element *win;
d255 4
a258 4
	  data_item_win = &display_info->regs_content[i]
            ->which_element.data_window;
          win = (struct tui_win_element *) data_item_win->content[0];
          win->which_element.data.highlight = FALSE;
d260 1
a260 1
      display_info->current_group = group;
d263 3
a268 100
/* Set the data window to display the registers of the register group
   using the given frame.  Values are refreshed only when refresh_values_only
   is TRUE.  */

static enum tui_status
tui_show_register_group (struct gdbarch *gdbarch, struct reggroup *group,
                         struct frame_info *frame, int refresh_values_only)
{
  enum tui_status ret = TUI_FAILURE;
  int nr_regs;
  int allocated_here = FALSE;
  int regnum, pos;
  char title[80];
  struct tui_data_info *display_info = &TUI_DATA_WIN->detail.data_display_info;

  /* Make a new title showing which group we display.  */
  snprintf (title, sizeof (title) - 1, "Register group: %s",
            reggroup_name (group));
  xfree (TUI_DATA_WIN->generic.title);
  TUI_DATA_WIN->generic.title = xstrdup (title);

  /* See how many registers must be displayed.  */
  nr_regs = 0;
  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
    {
      /* Must be in the group and have a name.  */
      if (gdbarch_register_reggroup_p (gdbarch, regnum, group)
          && gdbarch_register_name (gdbarch, regnum) != 0)
        nr_regs++;
    }

  if (display_info->regs_content_count > 0 && !refresh_values_only)
    {
      tui_free_data_content (display_info->regs_content,
                             display_info->regs_content_count);
      display_info->regs_content_count = 0;
    }

  if (display_info->regs_content_count <= 0)
    {
      display_info->regs_content = tui_alloc_content (nr_regs, DATA_WIN);
      allocated_here = TRUE;
      refresh_values_only = FALSE;
    }

  if (display_info->regs_content != (tui_win_content) NULL)
    {
      if (!refresh_values_only || allocated_here)
	{
	  TUI_DATA_WIN->generic.content = (void*) NULL;
	  TUI_DATA_WIN->generic.content_size = 0;
	  tui_add_content_elements (&TUI_DATA_WIN->generic, nr_regs);
	  display_info->regs_content
            = (tui_win_content) TUI_DATA_WIN->generic.content;
	  display_info->regs_content_count = nr_regs;
	}

      /* Now set the register names and values */
      pos = 0;
      for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
        {
	  struct tui_gen_win_info *data_item_win;
          struct tui_data_element *data;
          const char *name;

          if (!gdbarch_register_reggroup_p (gdbarch, regnum, group))
            continue;

          name = gdbarch_register_name (gdbarch, regnum);
          if (name == 0)
            continue;

	  data_item_win =
            &display_info->regs_content[pos]->which_element.data_window;
          data =
            &((struct tui_win_element *) data_item_win->content[0])->which_element.data;
          if (data)
            {
              if (!refresh_values_only)
                {
                  data->item_no = regnum;
                  data->name = name;
                  data->highlight = FALSE;
                }
              if (data->value == (void*) NULL)
                data->value = (void*) xmalloc (MAX_REGISTER_SIZE);

              tui_get_register (gdbarch, frame, data, regnum, 0);
            }
          pos++;
	}

      TUI_DATA_WIN->generic.content_size =
	display_info->regs_content_count + display_info->data_content_count;
      ret = TUI_SUCCESS;
    }

  return ret;
}

d276 2
a277 4
  struct tui_data_info *display_info = &TUI_DATA_WIN->detail.data_display_info;

  if (display_info->regs_content != (tui_win_content) NULL &&
      display_info->regs_content_count > 0)
d280 2
a281 36
      int j, value_chars_wide, item_win_width, cur_y;

      int max_len = 0;
      for (i = 0; i < display_info->regs_content_count; i++)
        {
          struct tui_data_element *data;
          struct tui_gen_win_info *data_item_win;
          char *p;
          int len;

          data_item_win = &display_info->regs_content[i]->which_element.data_window;
          data = &((struct tui_win_element *)
                   data_item_win->content[0])->which_element.data;
          len = 0;
          p = data->content;
          if (p != 0)
            while (*p)
              {
                if (*p++ == '\t')
                  len = 8 * ((len / 8) + 1);
                else
                  len++;
              }

          if (len > max_len)
            max_len = len;
        }
      item_win_width = max_len + 1;
      i = start_element_no;

      display_info->regs_column_count =
        (TUI_DATA_WIN->generic.width - 2) / item_win_width;
      if (display_info->regs_column_count == 0)
        display_info->regs_column_count = 1;
      item_win_width =
        (TUI_DATA_WIN->generic.width - 2) / display_info->regs_column_count;
d283 24
d311 1
a311 1
      while (i < display_info->regs_content_count &&
d315 2
a316 2
	       (j < display_info->regs_column_count &&
		i < display_info->regs_content_count); j++)
d322 2
a323 2
	      data_item_win = &display_info->regs_content[i]
                ->which_element.data_window;
a325 10
              if (data_item_win->handle != (WINDOW*) NULL
                  && (data_item_win->height != 1
                      || data_item_win->width != item_win_width
                      || data_item_win->origin.x != (item_win_width * j) + 1
                      || data_item_win->origin.y != cur_y))
                {
                  tui_delete_win (data_item_win->handle);
                  data_item_win->handle = 0;
                }
                  
d329 2
a330 1
		  data_item_win->width = item_win_width;
d338 6
a343 3
	      /* Get the printable representation of the register
                 and display it.  */
              tui_display_register (data_element_ptr, data_item_win);
d349 2
d439 3
a441 5
      struct tui_data_info *display_info
        = &TUI_DATA_WIN->detail.data_display_info;

      if (display_info->regs_content_count <= 0 && display_info->display_regs)
	tui_show_registers (display_info->current_group);
d445 1
d447 2
a448 1
	  for (i = 0; (i < display_info->regs_content_count); i++)
d450 2
a451 2
	      struct tui_data_element *data;
	      struct tui_gen_win_info *data_item_win_ptr;
d454 10
a463 5
	      data_item_win_ptr = &display_info->regs_content[i]->
                which_element.data_window;
	      data = &((struct tui_win_element *)
                       data_item_win_ptr->content[0])->which_element.data;
	      was_hilighted = data->highlight;
d465 11
a475 4
              tui_get_register (current_gdbarch, frame, data,
                                data->item_no, &data->highlight);

	      if (data->highlight || was_hilighted)
d477 7
a483 1
                  tui_display_register (data, data_item_win_ptr);
d488 1
a490 19
/* Display a register in a window.  If hilite is TRUE,
   then the value will be displayed in reverse video  */
static void
tui_display_register (struct tui_data_element *data,
                      struct tui_gen_win_info *win_info)
{
  if (win_info->handle != (WINDOW *) NULL)
    {
      int i;

      if (data->highlight)
	wstandout (win_info->handle);
      
      wmove (win_info->handle, 0, 0);
      for (i = 1; i < win_info->width; i++)
        waddch (win_info->handle, ' ');
      wmove (win_info->handle, 0, 0);
      if (data->content)
        waddstr (win_info->handle, data->content);
d492 5
a496 8
      if (data->highlight)
	wstandend (win_info->handle);
      tui_refresh_win (win_info);
    }
}

static void
tui_reg_next_command (char *arg, int from_tty)
d498 1
a498 4
  if (TUI_DATA_WIN != 0)
    {
      struct reggroup *group
        = TUI_DATA_WIN->detail.data_display_info.current_group;
d500 4
a503 20
      group = reggroup_next (current_gdbarch, group);
      if (group == 0)
        group = reggroup_next (current_gdbarch, 0);

      if (group)
        tui_show_registers (group);
    }
}

static void
tui_reg_float_command (char *arg, int from_tty)
{
  tui_show_registers (float_reggroup);
}

static void
tui_reg_general_command (char *arg, int from_tty)
{
  tui_show_registers (general_reggroup);
}
d505 4
a508 5
static void
tui_reg_system_command (char *arg, int from_tty)
{
  tui_show_registers (system_reggroup);
}
d510 2
a511 1
static struct cmd_list_element *tuireglist;
a512 7
static void
tui_reg_command (char *args, int from_tty)
{
  printf_unfiltered ("\"tui reg\" must be followed by the name of a "
                     "tui reg command.\n");
  help_list (tuireglist, "tui reg ", -1, gdb_stdout);
}
a516 22
  struct cmd_list_element **tuicmd;

  tuicmd = tui_get_cmd_list ();

  add_prefix_cmd ("reg", class_tui, tui_reg_command,
                  "TUI commands to control the register window.",
                  &tuireglist, "tui reg ", 0,
                  tuicmd);

  add_cmd ("float", class_tui, tui_reg_float_command,
           "Display only floating point registers\n",
           &tuireglist);
  add_cmd ("general", class_tui, tui_reg_general_command,
           "Display only general registers\n",
           &tuireglist);
  add_cmd ("system", class_tui, tui_reg_system_command,
           "Display only system registers\n",
           &tuireglist);
  add_cmd ("next", class_tui, tui_reg_next_command,
           "Display next register group\n",
           &tuireglist);

d519 1
a519 1
      add_com ("fr", class_tui, tui_reg_float_command,
d521 1
a521 1
      add_com ("gr", class_tui, tui_reg_general_command,
d523 1
a523 1
      add_com ("sr", class_tui, tui_reg_system_command,
d529 8
d545 10
d565 5
a569 2
/* Get the register from the frame and make a printable representation
   of it in the data element.  */
d571 3
a573 2
tui_register_format (struct gdbarch *gdbarch, struct frame_info *frame,
                     struct tui_data_element *data_element, int regnum)
d579 1
a579 1
  char *p, *s;
a580 1
  struct type *type = gdbarch_register_type (gdbarch, regnum);
d582 1
a582 1
  name = gdbarch_register_name (gdbarch, regnum);
d585 1
d591 1
a591 1
  stream = tui_sfileopen (256);
d594 2
a595 4
  if (TYPE_VECTOR (type) != 0 && 0)
    {
      char buf[MAX_REGISTER_SIZE];
      int len;
d597 4
a600 6
      len = register_size (current_gdbarch, regnum);
      fprintf_filtered (stream, "%-14s ", name);
      get_frame_register (frame, regnum, buf);
      print_scalar_formatted (buf, type, 'f', len, stream);
    }
  else
d602 11
a612 2
      gdbarch_print_registers_info (current_gdbarch, stream,
                                    frame, regnum, 1);
d614 1
a614 3

  /* Save formatted output in the buffer.  */
  p = tui_file_get_strbuf (stream);
d617 3
a619 3
  s = strrchr (p, '\n');
  if (s && s[1] == 0)
    *s = 0;
a620 2
  xfree (data_element->content);
  data_element->content = xstrdup (p);
d624 58
a681 3
/* Get the register value from the given frame and format it for
   the display.  When changep is set, check if the new register value
   has changed with respect to the previous call.  */
d683 52
a734 2
tui_get_register (struct gdbarch *gdbarch, struct frame_info *frame,
                  struct tui_data_element *data, int regnum, int *changedp)
a737 2
  if (changedp)
    *changedp = FALSE;
d740 1
a740 3
      char buf[MAX_REGISTER_SIZE];

      get_frame_register (frame, regnum, buf);
d744 2
a745 21
      if (register_cached (regnum) >= 0)
        {
          if (changedp)
            {
              int size = register_size (gdbarch, regnum);
              char *old = (char*) data->value;
              int i;

              for (i = 0; i < size; i++)
                if (buf[i] != old[i])
                  {
                    *changedp = TRUE;
                    old[i] = buf[i];
                  }
            }

          /* Reformat the data content if the value changed.  */
          if (changedp == 0 || *changedp == TRUE)
            tui_register_format (gdbarch, frame, data, regnum);
          ret = TUI_SUCCESS;
        }
d749 217
@


1.11.4.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d151 1
a151 1
  struct tui_data_info *display_info;
a152 9
  /* Make sure the curses mode is enabled.  */
  tui_enable ();

  /* Make sure the register window is visible.  If not, select an
     appropriate layout.  */
  if (TUI_DATA_WIN == NULL || !TUI_DATA_WIN->generic.is_visible)
    tui_set_layout_for_display_command (DATA_NAME);

  display_info = &TUI_DATA_WIN->detail.data_display_info;
@


1.10
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Include "gdb_string.h", delete register
	attribute, use ISO-C function signatures.
	* tui/tui-disasm.c, tui/tui-file.c, tui/tui-io.c: Ditto.
	* tui/tui-layout.c, tui/tui-regs.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-win.c, tui/tui-winsource.c: Ditto.
	* tui/tui.c: Ditto.
@
text
@d42 1
a42 7
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
@


1.10.2.1
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d80 1
a80 1
static enum tui_status _tuiSetRegsContent
d82 3
a84 3
static const char *_tuiRegisterName (int);
static enum tui_status _tuiGetRegisterRawValue (int, char *, struct frame_info *);
static void _tuiSetRegisterElement
d86 2
a87 2
static void _tuiDisplayRegister (int, struct tui_gen_win_info *, enum precision_type);
static void _tuiRegisterFormat
d89 5
a93 5
static enum tui_status _tuiSetGeneralRegsContent (int);
static enum tui_status _tuiSetSpecialRegsContent (int);
static enum tui_status _tuiSetGeneralAndSpecialRegsContent (int);
static enum tui_status _tuiSetFloatRegsContent (enum tui_register_display_type, int);
static int _tuiRegValueHasChanged
d95 7
a101 7
static void _tuiShowFloat_command (char *, int);
static void _tuiShowGeneral_command (char *, int);
static void _tuiShowSpecial_command (char *, int);
static void _tui_vShowRegisters_commandSupport (enum tui_register_display_type);
static void _tuiToggleFloatRegs_command (char *, int);
static void _tuiScrollRegsForward_command (char *, int);
static void _tuiScrollRegsBackward_command (char *, int);
d114 1
a114 1
  register int numLines = (-1);
d118 1
a118 1
      numLines = (TUI_DATA_WIN->detail.data_display_info.regs_content_count /
d122 1
a122 1
	numLines++;
d124 1
a124 1
  return numLines;
d128 2
a129 2
/* Answer the line number that the register element at elementNo is
   on.  If elementNo is greater than the number of register elements
d132 1
a132 1
tui_line_from_reg_element_no (int elementNo)
d134 1
a134 1
  if (elementNo < TUI_DATA_WIN->detail.data_display_info.regs_content_count)
d141 1
a141 1
	  if (elementNo <
d155 1
a155 1
/* Answer the index of the first element in lineNo.  If lineNo is past
d158 1
a158 1
tui_first_reg_element_no_inline (int lineNo)
d160 1
a160 1
  if ((lineNo * TUI_DATA_WIN->detail.data_display_info.regs_column_count)
d162 1
a162 1
    return ((lineNo + 1) *
d170 2
a171 5
/*
   ** tuiLastRegElementNoInLine()
   **        Answer the index of the last element in lineNo.  If lineNo is past
   **        the register area (-1) is returned.
 */
d173 1
a173 1
tuiLastRegElementNoInLine (int lineNo)
d175 1
a175 1
  if ((lineNo * TUI_DATA_WIN->detail.data_display_info.regs_column_count) <=
d177 1
a177 1
    return ((lineNo + 1) *
d181 1
a181 1
}				/* tuiLastRegElementNoInLine */
d187 1
a187 1
tui_calculate_regs_column_count (enum tui_register_display_type dpyType)
d189 1
a189 1
  int colCount, colWidth;
d191 2
a192 2
  if (IS_64BIT || dpyType == TUI_DFLOAT_REGS)
    colWidth = DOUBLE_FLOAT_VALUE_WIDTH + DOUBLE_FLOAT_LABEL_WIDTH;
d195 2
a196 2
      if (dpyType == TUI_SFLOAT_REGS)
	colWidth = SINGLE_FLOAT_VALUE_WIDTH + SINGLE_FLOAT_LABEL_WIDTH;
d198 1
a198 1
	colWidth = SINGLE_VALUE_WIDTH + SINGLE_LABEL_WIDTH;
d200 1
a200 1
  colCount = (TUI_DATA_WIN->generic.width - 2) / colWidth;
d202 2
a203 2
  return colCount;
}				/* tuiCalulateRegs_column_count */
d206 1
a206 1
/* Show the registers int the data window as indicated by dpyType.  If
d208 1
a208 1
   cleared.  What registers are displayed is dependent upon dpyType.  */
d210 1
a210 1
tui_show_registers (enum tui_register_display_type dpyType)
d213 1
a213 1
  int refreshValuesOnly = FALSE;
d220 3
a222 3
      refreshValuesOnly =
	(dpyType == TUI_DATA_WIN->detail.data_display_info.regs_display_type);
      switch (dpyType)
d225 1
a225 1
	  ret = _tuiSetGeneralRegsContent (refreshValuesOnly);
d229 1
a229 1
	  ret = _tuiSetFloatRegsContent (dpyType, refreshValuesOnly);
d235 1
a235 1
	  ret = _tuiSetSpecialRegsContent (refreshValuesOnly);
d238 1
a238 1
	  ret = _tuiSetGeneralAndSpecialRegsContent (refreshValuesOnly);
d259 1
a259 1
	  struct tui_gen_win_info * dataItemWin;
d261 1
a261 1
	  dataItemWin = &TUI_DATA_WIN->detail.data_display_info.
d264 1
a264 1
	     dataItemWin->content[0])->which_element.data)->highlight = FALSE;
d266 1
a266 1
      TUI_DATA_WIN->detail.data_display_info.regs_display_type = dpyType;
d269 1
a269 1
  (tui_layout_def ())->regs_display_type = dpyType;
d276 1
a276 1
   'startElementNo' until the end of the register content or the end
d280 1
a280 1
tui_display_registers_from (int startElementNo)
d285 2
a286 2
      register int i = startElementNo;
      int j, valueCharsWide, itemWinWidth, curY, labelWidth;
d295 2
a296 2
	  valueCharsWide = DOUBLE_FLOAT_VALUE_WIDTH;
	  labelWidth = DOUBLE_FLOAT_LABEL_WIDTH;
d303 2
a304 2
	      valueCharsWide = SINGLE_FLOAT_VALUE_WIDTH;
	      labelWidth = SINGLE_FLOAT_LABEL_WIDTH;
d308 2
a309 2
	      valueCharsWide = SINGLE_VALUE_WIDTH;
	      labelWidth = SINGLE_LABEL_WIDTH;
d312 1
a312 1
      itemWinWidth = valueCharsWide + labelWidth;
d316 1
a316 1
      curY = 1;
d318 1
a318 1
	     curY <= TUI_DATA_WIN->generic.viewport_height)
d324 2
a325 2
	      struct tui_gen_win_info * dataItemWin;
	      struct tui_data_element * dataElementPtr;
d328 1
a328 1
	      dataItemWin = &TUI_DATA_WIN->detail.data_display_info.
d330 3
a332 3
	      dataElementPtr = &((struct tui_win_element *)
				 dataItemWin->content[0])->which_element.data;
	      if (dataItemWin->handle == (WINDOW *) NULL)
d334 7
a340 7
		  dataItemWin->height = 1;
		  dataItemWin->width = (precision == double_precision) ?
		    itemWinWidth + 2 : itemWinWidth + 1;
		  dataItemWin->origin.x = (itemWinWidth * j) + 1;
		  dataItemWin->origin.y = curY;
		  tui_make_window (dataItemWin, DONT_BOX_WINDOW);
                  scrollok (dataItemWin->handle, FALSE);
d342 1
a342 1
              touchwin (dataItemWin->handle);
d348 2
a349 2
	      _tuiDisplayRegister (
			    dataElementPtr->item_no, dataItemWin, precision);
d352 1
a352 1
	  curY++;		/* next row; */
d360 4
a363 8
/*
   ** tuiDisplayRegElementAtLine().
   **        Function to display the registers in the content from
   **        'startElementNo' on 'startLineNo' until the end of the
   **        register content or the end of the display height.
   **        This function checks that we won't display off the end
   **        of the register display.
 */
d365 1
a365 1
tuiDisplayRegElementAtLine (int startElementNo, int startLineNo)
d370 1
a370 1
      register int elementNo = startElementNo;
d372 1
a372 1
      if (startElementNo != 0 && startLineNo != 0)
d374 1
a374 1
	  register int lastLineNo, firstLineOnLastPage;
d376 4
a379 4
	  lastLineNo = tui_last_regs_line_no ();
	  firstLineOnLastPage = lastLineNo - (TUI_DATA_WIN->generic.height - 2);
	  if (firstLineOnLastPage < 0)
	    firstLineOnLastPage = 0;
d382 1
a382 1
	     ** and the elementNo causes us to scroll past the end of the
d386 2
a387 2
	      startLineNo > firstLineOnLastPage)
	    elementNo = tui_first_reg_element_no_inline (firstLineOnLastPage);
d389 1
a389 1
      tui_display_registers_from (elementNo);
d391 1
a391 3

  return;
}				/* tuiDisplayRegElementAtLine */
d395 1
a395 1
/* Function to display the registers starting at line lineNo in the
d399 1
a399 1
tui_display_registers_from_line (int lineNo, int forceDisplay)
d403 1
a403 1
      int line, elementNo;
d405 1
a405 1
      if (lineNo < 0)
d407 1
a407 1
      else if (forceDisplay)
d409 1
a409 1
				   ** If we must display regs (forceDisplay is true), then make
d412 1
a412 1
	  if (lineNo >= tui_last_regs_line_no ())
d419 1
a419 1
	    line = lineNo;
d422 1
a422 1
	line = lineNo;
d424 3
a426 3
      elementNo = tui_first_reg_element_no_inline (line);
      if (elementNo < TUI_DATA_WIN->detail.data_display_info.regs_content_count)
	tuiDisplayRegElementAtLine (elementNo, line);
d451 1
a451 1
	  char rawBuf[MAX_REGISTER_SIZE];
d456 3
a458 3
	      struct tui_data_element * dataElementPtr;
	      struct tui_gen_win_info * dataItemWinPtr;
	      int wasHilighted;
d460 1
a460 1
	      dataItemWinPtr = &TUI_DATA_WIN->detail.data_display_info.
d462 6
a467 6
	      dataElementPtr = &((struct tui_win_element *)
			     dataItemWinPtr->content[0])->which_element.data;
	      wasHilighted = dataElementPtr->highlight;
	      dataElementPtr->highlight =
		_tuiRegValueHasChanged (dataElementPtr, frame, &rawBuf[0]);
	      if (dataElementPtr->highlight)
d471 1
a471 1
                  size = DEPRECATED_REGISTER_RAW_SIZE (dataElementPtr->item_no);
d473 4
a476 4
		    ((char *) dataElementPtr->value)[j] = rawBuf[j];
		  _tuiDisplayRegister (
					dataElementPtr->item_no,
					dataItemWinPtr,
d481 1
a481 1
	      else if (wasHilighted)
d483 4
a486 4
		  dataElementPtr->highlight = FALSE;
		  _tuiDisplayRegister (
					dataElementPtr->item_no,
					dataItemWinPtr,
d499 1
a499 1
   ** tuiToggleFloatRegs().
d502 1
a502 1
tuiToggleFloatRegs (void)
d504 1
a504 1
  struct tui_layout_def * layoutDef = tui_layout_def ();
d506 2
a507 2
  if (layoutDef->float_regs_display_type == TUI_SFLOAT_REGS)
    layoutDef->float_regs_display_type = TUI_DFLOAT_REGS;
d509 1
a509 1
    layoutDef->float_regs_display_type = TUI_SFLOAT_REGS;
d514 1
a514 1
    tui_show_registers (layoutDef->float_regs_display_type);
d517 1
a517 1
}				/* tuiToggleFloatRegs */
d521 1
a521 1
_initialize_tuiRegs (void)
d525 1
a525 1
      add_com ("fr", class_tui, _tuiShowFloat_command,
d527 1
a527 1
      add_com ("gr", class_tui, _tuiShowGeneral_command,
d529 1
a529 1
      add_com ("sr", class_tui, _tuiShowSpecial_command,
d531 1
a531 1
      add_com ("+r", class_tui, _tuiScrollRegsForward_command,
d533 1
a533 1
      add_com ("-r", class_tui, _tuiScrollRegsBackward_command,
d535 1
a535 1
      add_com ("tf", class_tui, _tuiToggleFloatRegs_command,
d539 1
a539 1
	       _tuiToggleFloatRegs_command,
d553 1
a553 1
   ** _tuiRegisterName().
d557 1
a557 1
_tuiRegisterName (int regNum)
d559 1
a559 1
  return REGISTER_NAME (regNum);
d572 1
a572 1
   ** _tuiRegisterFormat
d577 2
a578 2
_tuiRegisterFormat (char *buf, int bufLen, int regNum,
                    struct tui_data_element * dataElement,
d588 1
a588 1
  name = REGISTER_NAME (regNum);
d597 1
a597 1
  stream = tui_sfileopen (bufLen);
d601 1
a601 1
                                regNum, 1);
d606 1
a606 1
  while (*p && *p == *name++ && bufLen)
d609 1
a609 1
      bufLen--;
d614 1
a614 1
  while (pos < 8 && bufLen)
d617 1
a617 1
      bufLen--;
d620 1
a620 1
  strncpy (buf, p, bufLen);
d632 2
a633 4
/*
   ** _tuiSetGeneralRegsContent().
   **      Set the content of the data window to consist of the general registers.
 */
d635 1
a635 1
_tuiSetGeneralRegsContent (int refreshValuesOnly)
d637 1
a637 1
  return (_tuiSetRegsContent (0,
d641 1
a641 1
			      refreshValuesOnly));
d643 1
a643 1
}				/* _tuiSetGeneralRegsContent */
d652 2
a653 4
/*
   ** _tuiSetSpecialRegsContent().
   **      Set the content of the data window to consist of the special registers.
 */
d655 1
a655 1
_tuiSetSpecialRegsContent (int refreshValuesOnly)
d658 1
a658 1
  int endRegNum;
d660 3
a662 3
  endRegNum = FP0_REGNUM - 1;
  ret = _tuiSetRegsContent (START_SPECIAL_REGS,
			    endRegNum,
d665 1
a665 1
			    refreshValuesOnly);
d668 1
a668 1
}				/* _tuiSetSpecialRegsContent */
d671 2
a672 4
/*
   ** _tuiSetGeneralAndSpecialRegsContent().
   **      Set the content of the data window to consist of the special registers.
 */
d674 1
a674 1
_tuiSetGeneralAndSpecialRegsContent (int refreshValuesOnly)
d677 1
a677 1
  int endRegNum = (-1);
d679 3
a681 3
  endRegNum = FP0_REGNUM - 1;
  ret = _tuiSetRegsContent (
	 0, endRegNum, deprecated_selected_frame, TUI_SPECIAL_REGS, refreshValuesOnly);
d684 1
a684 1
}				/* _tuiSetGeneralAndSpecialRegsContent */
d686 2
a687 4
/*
   ** _tuiSetFloatRegsContent().
   **        Set the content of the data window to consist of the float registers.
 */
d689 2
a690 1
_tuiSetFloatRegsContent (enum tui_register_display_type dpyType, int refreshValuesOnly)
d693 1
a693 1
  int startRegNum;
d695 2
a696 2
  startRegNum = FP0_REGNUM;
  ret = _tuiSetRegsContent (startRegNum,
d699 2
a700 2
			    dpyType,
			    refreshValuesOnly);
d703 1
a703 1
}				/* _tuiSetFloatRegsContent */
d706 2
a707 5
/*
   ** _tuiRegValueHasChanged().
   **        Answer TRUE if the register's value has changed, FALSE otherwise.
   **        If TRUE, newValue is filled in with the new value.
 */
d709 2
a710 3
_tuiRegValueHasChanged (struct tui_data_element * dataElement,
                        struct frame_info *frame,
                        char *newValue)
d712 1
a712 1
  int hasChanged = FALSE;
d714 2
a715 2
  if (dataElement->item_no != UNDEFINED_ITEM &&
      _tuiRegisterName (dataElement->item_no) != (char *) NULL)
d717 1
a717 1
      char rawBuf[MAX_REGISTER_SIZE];
d720 1
a720 2
      if (_tuiGetRegisterRawValue (
			 dataElement->item_no, rawBuf, frame) == TUI_SUCCESS)
d722 1
a722 1
          int size = DEPRECATED_REGISTER_RAW_SIZE (dataElement->item_no);
d724 3
a726 3
	  for (i = 0; (i < size && !hasChanged); i++)
	    hasChanged = (((char *) dataElement->value)[i] != rawBuf[i]);
	  if (hasChanged && newValue != (char *) NULL)
d729 1
a729 1
		newValue[i] = rawBuf[i];
d733 2
a734 2
  return hasChanged;
}				/* _tuiRegValueHasChanged */
d738 1
a738 4
/*
   ** _tuiGetRegisterRawValue().
   **        Get the register raw value.  The raw value is returned in regValue.
 */
d740 1
a740 1
_tuiGetRegisterRawValue (int regNum, char *regValue, struct frame_info *frame)
d746 1
a746 1
      get_frame_register (frame, regNum, regValue);
d750 1
a750 1
      if (register_cached (regNum) >= 0)
d754 1
a754 1
}				/* _tuiGetRegisterRawValue */
d758 2
a759 5
/*
   ** _tuiSetRegisterElement().
   **       Function to initialize a data element with the input and
   **       the register value.
 */
d761 16
a776 16
_tuiSetRegisterElement (int regNum, struct frame_info *frame,
                        struct tui_data_element * dataElement,
                        int refreshValueOnly)
{
  if (dataElement != (struct tui_data_element *) NULL)
    {
      if (!refreshValueOnly)
	{
	  dataElement->item_no = regNum;
	  dataElement->name = _tuiRegisterName (regNum);
	  dataElement->highlight = FALSE;
	}
      if (dataElement->value == NULL)
	dataElement->value = xmalloc (MAX_REGISTER_SIZE);
      if (dataElement->value != NULL)
	_tuiGetRegisterRawValue (regNum, dataElement->value, frame);
d778 1
a779 2
  return;
}				/* _tuiSetRegisterElement */
d781 4
a784 7

/*
   ** _tuiSetRegsContent().
   **        Set the content of the data window to consist of the registers
   **        numbered from startRegNum to endRegNum.  Note that if
   **        refreshValuesOnly is TRUE, startRegNum and endRegNum are ignored.
 */
d786 1
a786 1
_tuiSetRegsContent (int startRegNum, int endRegNum,
d788 2
a789 2
                    enum tui_register_display_type dpyType,
                    int refreshValuesOnly)
d792 2
a793 2
  int numRegs = endRegNum - startRegNum + 1;
  int allocatedHere = FALSE;
d796 1
a796 1
      !refreshValuesOnly)
d805 2
a806 2
	tui_alloc_content (numRegs, DATA_WIN);
      allocatedHere = TRUE;
d813 1
a813 1
      if (!refreshValuesOnly || allocatedHere)
d817 1
a817 1
	  tui_add_content_elements (&TUI_DATA_WIN->generic, numRegs);
d820 1
a820 1
	  TUI_DATA_WIN->detail.data_display_info.regs_content_count = numRegs;
d825 1
a825 1
      for (i = startRegNum; (i <= endRegNum); i++)
d827 1
a827 1
	  struct tui_gen_win_info * dataItemWin;
d829 3
a831 3
	  dataItemWin = &TUI_DATA_WIN->detail.data_display_info.
	    regs_content[i - startRegNum]->which_element.data_window;
	  _tuiSetRegisterElement (
d834 2
a835 2
	   &((struct tui_win_element *) dataItemWin->content[0])->which_element.data,
				   !allocatedHere && refreshValuesOnly);
d838 1
a838 1
	tui_calculate_regs_column_count (dpyType);
d844 1
a844 1
	  /* append TUI_DATA_WIN->detail.data_display_info.dataContent to content */
d854 1
a854 1
}				/* _tuiSetRegsContent */
d857 2
a858 5
/*
   ** _tuiDisplayRegister().
   **        Function to display a register in a window.  If hilite is TRUE,
   **        than the value will be displayed in reverse video
 */
d860 2
a861 2
_tuiDisplayRegister (int regNum,
                     struct tui_gen_win_info * winInfo,		/* the data item window */
d864 1
a864 1
  if (winInfo->handle != (WINDOW *) NULL)
d868 3
a870 3
      int valueCharsWide, labelWidth;
      struct tui_data_element * dataElementPtr = &((tui_win_content)
				    winInfo->content)[0]->which_element.data;
d875 2
a876 2
	  valueCharsWide = DOUBLE_FLOAT_VALUE_WIDTH;
	  labelWidth = DOUBLE_FLOAT_LABEL_WIDTH;
d883 2
a884 2
	      valueCharsWide = SINGLE_FLOAT_VALUE_WIDTH;
	      labelWidth = SINGLE_FLOAT_LABEL_WIDTH;
d888 2
a889 2
	      valueCharsWide = SINGLE_VALUE_WIDTH;
	      labelWidth = SINGLE_LABEL_WIDTH;
d894 4
a897 4
      _tuiRegisterFormat (buf,
			  valueCharsWide + labelWidth,
			  regNum,
			  dataElementPtr,
d900 8
a907 2
      if (dataElementPtr->highlight)
	wstandout (winInfo->handle);
d909 3
a911 9
      wmove (winInfo->handle, 0, 0);
      for (i = 1; i < winInfo->width; i++)
        waddch (winInfo->handle, ' ');
      wmove (winInfo->handle, 0, 0);
      waddstr (winInfo->handle, buf);

      if (dataElementPtr->highlight)
	wstandend (winInfo->handle);
      tui_refresh_win (winInfo);
d913 1
a913 2
  return;
}				/* _tuiDisplayRegister */
d917 1
a917 1
_tui_vShowRegisters_commandSupport (enum tui_register_display_type dpyType)
d922 2
a923 2
      if (TUI_DATA_WIN->detail.data_display_info.regs_display_type != dpyType)
	tui_show_registers (dpyType);
d926 1
a926 1
    (tui_layout_def ())->regs_display_type = dpyType;
d929 1
a929 1
}				/* _tui_vShowRegisters_commandSupport */
d933 1
a933 1
_tuiShowFloat_command (char *arg, int fromTTY)
d938 2
a939 4
    _tui_vShowRegisters_commandSupport ((tui_layout_def ())->float_regs_display_type);

  return;
}				/* _tuiShowFloat_command */
d943 1
a943 1
_tuiShowGeneral_command (char *arg, int fromTTY)
d945 1
a945 1
  _tui_vShowRegisters_commandSupport (TUI_GENERAL_REGS);
d950 1
a950 1
_tuiShowSpecial_command (char *arg, int fromTTY)
d952 1
a952 1
  _tui_vShowRegisters_commandSupport (TUI_SPECIAL_REGS);
d957 1
a957 1
_tuiToggleFloatRegs_command (char *arg, int fromTTY)
d960 1
a960 1
    tuiToggleFloatRegs ();
d963 1
a963 1
      struct tui_layout_def * layoutDef = tui_layout_def ();
d965 2
a966 2
      if (layoutDef->float_regs_display_type == TUI_SFLOAT_REGS)
	layoutDef->float_regs_display_type = TUI_DFLOAT_REGS;
d968 1
a968 1
	layoutDef->float_regs_display_type = TUI_SFLOAT_REGS;
d970 1
a970 4


  return;
}				/* _tuiToggleFloatRegs_command */
d974 1
a974 1
_tuiScrollRegsForward_command (char *arg, int fromTTY)
d981 1
a981 1
_tuiScrollRegsBackward_command (char *arg, int fromTTY)
@


1.9
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Change variable and function names to lower
	case.
	* tui/tui-data.c, tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c, tui/tui-io.c, tui/tui-layout.c: Ditto.
	* tui/tui-regs.c, tui/tui-source.c, tui/tui-stack.c: Ditto.
	* tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d114 1
a114 1
  register int num_lines = (-1);
d285 1
a285 1
      register int i = start_element_no;
d370 1
a370 1
      register int element_no = start_element_no;
d374 1
a374 1
	  register int last_line_no, first_line_on_last_page;
@


1.8
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui.h: Do not include <stdarg.h>, <string.h>, and
	"ansidecl.h".  Do not undef "reg" and "chtype".  Fix case of
	fields and variables.
	* tui/tui-wingeneral.h (m_beVisible): Delete macro.
	(m_beInvisible): Delete macro.
	* tui/tui-data.h: Fix case case fields and variables.
	(m_genWinPtrIsNull): Delete macro.
	(tui_win_list): Rename winList.
	(TUI_SRC_WIN): Rename srcWin.
	(TUI_DISASM_WIN): Rename disassemWin.
	(TUI_DATA_WIN): Rename dataWin.
	(TUI_CMD_WIN): Rename cmdWin.
	(m_genWinPtrNotNull): Delete macro.
	(m_winPtrIsNull): Delete macro.
	(m_winPtrNotNull): Delete macro.
	(tui_win_is_source_type): Replace m_winIsSourceType
	(tui_win_is_auxillary): Replace m_winIsAuzillary.
	(tui_win_has_locator): Replace m_hasLocator.
	(tui_set_win_highlight): Replace m_setWinHighlightOn and
	m_setWinHighlightOff.
	* tui/tui-data.c: Update references.
	(tui_win_is_source_type, tui_set_win_highlight): New functions.
	(tui_win_has_locator, tui_win_is_auxillary): New functions.
	* tui/tui-command.c, tui/tui-disasm.c: Update references.
	* tui/tui-io.c, tui/tui-layout.c, tui/tui-regs.c: Ditto.
	* tui/tui-regs.h, tui/tui-source.c, tui/tui-stack.c: Ditto.
	* tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d80 1
a80 1
static enum tui_status _tuiSetRegsContent
d82 3
a84 3
static const char *_tuiRegisterName (int);
static enum tui_status _tuiGetRegisterRawValue (int, char *, struct frame_info *);
static void _tuiSetRegisterElement
d86 2
a87 2
static void _tuiDisplayRegister (int, struct tui_gen_win_info *, enum precision_type);
static void _tuiRegisterFormat
d89 5
a93 5
static enum tui_status _tuiSetGeneralRegsContent (int);
static enum tui_status _tuiSetSpecialRegsContent (int);
static enum tui_status _tuiSetGeneralAndSpecialRegsContent (int);
static enum tui_status _tuiSetFloatRegsContent (enum tui_register_display_type, int);
static int _tuiRegValueHasChanged
d95 7
a101 7
static void _tuiShowFloat_command (char *, int);
static void _tuiShowGeneral_command (char *, int);
static void _tuiShowSpecial_command (char *, int);
static void _tui_vShowRegisters_commandSupport (enum tui_register_display_type);
static void _tuiToggleFloatRegs_command (char *, int);
static void _tuiScrollRegsForward_command (char *, int);
static void _tuiScrollRegsBackward_command (char *, int);
d114 1
a114 1
  register int numLines = (-1);
d118 1
a118 1
      numLines = (TUI_DATA_WIN->detail.data_display_info.regs_content_count /
d122 1
a122 1
	numLines++;
d124 1
a124 1
  return numLines;
d128 2
a129 2
/* Answer the line number that the register element at elementNo is
   on.  If elementNo is greater than the number of register elements
d132 1
a132 1
tui_line_from_reg_element_no (int elementNo)
d134 1
a134 1
  if (elementNo < TUI_DATA_WIN->detail.data_display_info.regs_content_count)
d141 1
a141 1
	  if (elementNo <
d155 1
a155 1
/* Answer the index of the first element in lineNo.  If lineNo is past
d158 1
a158 1
tui_first_reg_element_no_inline (int lineNo)
d160 1
a160 1
  if ((lineNo * TUI_DATA_WIN->detail.data_display_info.regs_column_count)
d162 1
a162 1
    return ((lineNo + 1) *
d170 2
a171 5
/*
   ** tuiLastRegElementNoInLine()
   **        Answer the index of the last element in lineNo.  If lineNo is past
   **        the register area (-1) is returned.
 */
d173 1
a173 1
tuiLastRegElementNoInLine (int lineNo)
d175 1
a175 1
  if ((lineNo * TUI_DATA_WIN->detail.data_display_info.regs_column_count) <=
d177 1
a177 1
    return ((lineNo + 1) *
d181 1
a181 1
}				/* tuiLastRegElementNoInLine */
d187 1
a187 1
tui_calculate_regs_column_count (enum tui_register_display_type dpyType)
d189 1
a189 1
  int colCount, colWidth;
d191 2
a192 2
  if (IS_64BIT || dpyType == TUI_DFLOAT_REGS)
    colWidth = DOUBLE_FLOAT_VALUE_WIDTH + DOUBLE_FLOAT_LABEL_WIDTH;
d195 2
a196 2
      if (dpyType == TUI_SFLOAT_REGS)
	colWidth = SINGLE_FLOAT_VALUE_WIDTH + SINGLE_FLOAT_LABEL_WIDTH;
d198 1
a198 1
	colWidth = SINGLE_VALUE_WIDTH + SINGLE_LABEL_WIDTH;
d200 1
a200 1
  colCount = (TUI_DATA_WIN->generic.width - 2) / colWidth;
d202 2
a203 2
  return colCount;
}				/* tuiCalulateRegs_column_count */
d206 1
a206 1
/* Show the registers int the data window as indicated by dpyType.  If
d208 1
a208 1
   cleared.  What registers are displayed is dependent upon dpyType.  */
d210 1
a210 1
tui_show_registers (enum tui_register_display_type dpyType)
d213 1
a213 1
  int refreshValuesOnly = FALSE;
d220 3
a222 3
      refreshValuesOnly =
	(dpyType == TUI_DATA_WIN->detail.data_display_info.regs_display_type);
      switch (dpyType)
d225 1
a225 1
	  ret = _tuiSetGeneralRegsContent (refreshValuesOnly);
d229 1
a229 1
	  ret = _tuiSetFloatRegsContent (dpyType, refreshValuesOnly);
d235 1
a235 1
	  ret = _tuiSetSpecialRegsContent (refreshValuesOnly);
d238 1
a238 1
	  ret = _tuiSetGeneralAndSpecialRegsContent (refreshValuesOnly);
d259 1
a259 1
	  struct tui_gen_win_info * dataItemWin;
d261 1
a261 1
	  dataItemWin = &TUI_DATA_WIN->detail.data_display_info.
d264 1
a264 1
	     dataItemWin->content[0])->which_element.data)->highlight = FALSE;
d266 1
a266 1
      TUI_DATA_WIN->detail.data_display_info.regs_display_type = dpyType;
d269 1
a269 1
  (tui_layout_def ())->regs_display_type = dpyType;
d276 1
a276 1
   'startElementNo' until the end of the register content or the end
d280 1
a280 1
tui_display_registers_from (int startElementNo)
d285 2
a286 2
      register int i = startElementNo;
      int j, valueCharsWide, itemWinWidth, curY, labelWidth;
d295 2
a296 2
	  valueCharsWide = DOUBLE_FLOAT_VALUE_WIDTH;
	  labelWidth = DOUBLE_FLOAT_LABEL_WIDTH;
d303 2
a304 2
	      valueCharsWide = SINGLE_FLOAT_VALUE_WIDTH;
	      labelWidth = SINGLE_FLOAT_LABEL_WIDTH;
d308 2
a309 2
	      valueCharsWide = SINGLE_VALUE_WIDTH;
	      labelWidth = SINGLE_LABEL_WIDTH;
d312 1
a312 1
      itemWinWidth = valueCharsWide + labelWidth;
d316 1
a316 1
      curY = 1;
d318 1
a318 1
	     curY <= TUI_DATA_WIN->generic.viewport_height)
d324 2
a325 2
	      struct tui_gen_win_info * dataItemWin;
	      struct tui_data_element * dataElementPtr;
d328 1
a328 1
	      dataItemWin = &TUI_DATA_WIN->detail.data_display_info.
d330 3
a332 3
	      dataElementPtr = &((struct tui_win_element *)
				 dataItemWin->content[0])->which_element.data;
	      if (dataItemWin->handle == (WINDOW *) NULL)
d334 7
a340 7
		  dataItemWin->height = 1;
		  dataItemWin->width = (precision == double_precision) ?
		    itemWinWidth + 2 : itemWinWidth + 1;
		  dataItemWin->origin.x = (itemWinWidth * j) + 1;
		  dataItemWin->origin.y = curY;
		  tui_make_window (dataItemWin, DONT_BOX_WINDOW);
                  scrollok (dataItemWin->handle, FALSE);
d342 1
a342 1
              touchwin (dataItemWin->handle);
d348 2
a349 2
	      _tuiDisplayRegister (
			    dataElementPtr->item_no, dataItemWin, precision);
d352 1
a352 1
	  curY++;		/* next row; */
d360 4
a363 8
/*
   ** tuiDisplayRegElementAtLine().
   **        Function to display the registers in the content from
   **        'startElementNo' on 'startLineNo' until the end of the
   **        register content or the end of the display height.
   **        This function checks that we won't display off the end
   **        of the register display.
 */
d365 1
a365 1
tuiDisplayRegElementAtLine (int startElementNo, int startLineNo)
d370 1
a370 1
      register int elementNo = startElementNo;
d372 1
a372 1
      if (startElementNo != 0 && startLineNo != 0)
d374 1
a374 1
	  register int lastLineNo, firstLineOnLastPage;
d376 4
a379 4
	  lastLineNo = tui_last_regs_line_no ();
	  firstLineOnLastPage = lastLineNo - (TUI_DATA_WIN->generic.height - 2);
	  if (firstLineOnLastPage < 0)
	    firstLineOnLastPage = 0;
d382 1
a382 1
	     ** and the elementNo causes us to scroll past the end of the
d386 2
a387 2
	      startLineNo > firstLineOnLastPage)
	    elementNo = tui_first_reg_element_no_inline (firstLineOnLastPage);
d389 1
a389 1
      tui_display_registers_from (elementNo);
d391 1
a391 3

  return;
}				/* tuiDisplayRegElementAtLine */
d395 1
a395 1
/* Function to display the registers starting at line lineNo in the
d399 1
a399 1
tui_display_registers_from_line (int lineNo, int forceDisplay)
d403 1
a403 1
      int line, elementNo;
d405 1
a405 1
      if (lineNo < 0)
d407 1
a407 1
      else if (forceDisplay)
d409 1
a409 1
				   ** If we must display regs (forceDisplay is true), then make
d412 1
a412 1
	  if (lineNo >= tui_last_regs_line_no ())
d419 1
a419 1
	    line = lineNo;
d422 1
a422 1
	line = lineNo;
d424 3
a426 3
      elementNo = tui_first_reg_element_no_inline (line);
      if (elementNo < TUI_DATA_WIN->detail.data_display_info.regs_content_count)
	tuiDisplayRegElementAtLine (elementNo, line);
d451 1
a451 1
	  char rawBuf[MAX_REGISTER_SIZE];
d456 3
a458 3
	      struct tui_data_element * dataElementPtr;
	      struct tui_gen_win_info * dataItemWinPtr;
	      int wasHilighted;
d460 1
a460 1
	      dataItemWinPtr = &TUI_DATA_WIN->detail.data_display_info.
d462 6
a467 6
	      dataElementPtr = &((struct tui_win_element *)
			     dataItemWinPtr->content[0])->which_element.data;
	      wasHilighted = dataElementPtr->highlight;
	      dataElementPtr->highlight =
		_tuiRegValueHasChanged (dataElementPtr, frame, &rawBuf[0]);
	      if (dataElementPtr->highlight)
d471 1
a471 1
                  size = DEPRECATED_REGISTER_RAW_SIZE (dataElementPtr->item_no);
d473 4
a476 4
		    ((char *) dataElementPtr->value)[j] = rawBuf[j];
		  _tuiDisplayRegister (
					dataElementPtr->item_no,
					dataItemWinPtr,
d481 1
a481 1
	      else if (wasHilighted)
d483 4
a486 4
		  dataElementPtr->highlight = FALSE;
		  _tuiDisplayRegister (
					dataElementPtr->item_no,
					dataItemWinPtr,
d499 1
a499 1
   ** tuiToggleFloatRegs().
d502 1
a502 1
tuiToggleFloatRegs (void)
d504 1
a504 1
  struct tui_layout_def * layoutDef = tui_layout_def ();
d506 2
a507 2
  if (layoutDef->float_regs_display_type == TUI_SFLOAT_REGS)
    layoutDef->float_regs_display_type = TUI_DFLOAT_REGS;
d509 1
a509 1
    layoutDef->float_regs_display_type = TUI_SFLOAT_REGS;
d514 1
a514 1
    tui_show_registers (layoutDef->float_regs_display_type);
d517 1
a517 1
}				/* tuiToggleFloatRegs */
d521 1
a521 1
_initialize_tuiRegs (void)
d525 1
a525 1
      add_com ("fr", class_tui, _tuiShowFloat_command,
d527 1
a527 1
      add_com ("gr", class_tui, _tuiShowGeneral_command,
d529 1
a529 1
      add_com ("sr", class_tui, _tuiShowSpecial_command,
d531 1
a531 1
      add_com ("+r", class_tui, _tuiScrollRegsForward_command,
d533 1
a533 1
      add_com ("-r", class_tui, _tuiScrollRegsBackward_command,
d535 1
a535 1
      add_com ("tf", class_tui, _tuiToggleFloatRegs_command,
d539 1
a539 1
	       _tuiToggleFloatRegs_command,
d553 1
a553 1
   ** _tuiRegisterName().
d557 1
a557 1
_tuiRegisterName (int regNum)
d559 1
a559 1
  return REGISTER_NAME (regNum);
d572 1
a572 1
   ** _tuiRegisterFormat
d577 2
a578 2
_tuiRegisterFormat (char *buf, int bufLen, int regNum,
                    struct tui_data_element * dataElement,
d588 1
a588 1
  name = REGISTER_NAME (regNum);
d597 1
a597 1
  stream = tui_sfileopen (bufLen);
d601 1
a601 1
                                regNum, 1);
d606 1
a606 1
  while (*p && *p == *name++ && bufLen)
d609 1
a609 1
      bufLen--;
d614 1
a614 1
  while (pos < 8 && bufLen)
d617 1
a617 1
      bufLen--;
d620 1
a620 1
  strncpy (buf, p, bufLen);
d632 2
a633 4
/*
   ** _tuiSetGeneralRegsContent().
   **      Set the content of the data window to consist of the general registers.
 */
d635 1
a635 1
_tuiSetGeneralRegsContent (int refreshValuesOnly)
d637 1
a637 1
  return (_tuiSetRegsContent (0,
d641 1
a641 1
			      refreshValuesOnly));
d643 1
a643 1
}				/* _tuiSetGeneralRegsContent */
d652 2
a653 4
/*
   ** _tuiSetSpecialRegsContent().
   **      Set the content of the data window to consist of the special registers.
 */
d655 1
a655 1
_tuiSetSpecialRegsContent (int refreshValuesOnly)
d658 1
a658 1
  int endRegNum;
d660 3
a662 3
  endRegNum = FP0_REGNUM - 1;
  ret = _tuiSetRegsContent (START_SPECIAL_REGS,
			    endRegNum,
d665 1
a665 1
			    refreshValuesOnly);
d668 1
a668 1
}				/* _tuiSetSpecialRegsContent */
d671 2
a672 4
/*
   ** _tuiSetGeneralAndSpecialRegsContent().
   **      Set the content of the data window to consist of the special registers.
 */
d674 1
a674 1
_tuiSetGeneralAndSpecialRegsContent (int refreshValuesOnly)
d677 1
a677 1
  int endRegNum = (-1);
d679 3
a681 3
  endRegNum = FP0_REGNUM - 1;
  ret = _tuiSetRegsContent (
	 0, endRegNum, deprecated_selected_frame, TUI_SPECIAL_REGS, refreshValuesOnly);
d684 1
a684 1
}				/* _tuiSetGeneralAndSpecialRegsContent */
d686 2
a687 4
/*
   ** _tuiSetFloatRegsContent().
   **        Set the content of the data window to consist of the float registers.
 */
d689 2
a690 1
_tuiSetFloatRegsContent (enum tui_register_display_type dpyType, int refreshValuesOnly)
d693 1
a693 1
  int startRegNum;
d695 2
a696 2
  startRegNum = FP0_REGNUM;
  ret = _tuiSetRegsContent (startRegNum,
d699 2
a700 2
			    dpyType,
			    refreshValuesOnly);
d703 1
a703 1
}				/* _tuiSetFloatRegsContent */
d706 2
a707 5
/*
   ** _tuiRegValueHasChanged().
   **        Answer TRUE if the register's value has changed, FALSE otherwise.
   **        If TRUE, newValue is filled in with the new value.
 */
d709 2
a710 3
_tuiRegValueHasChanged (struct tui_data_element * dataElement,
                        struct frame_info *frame,
                        char *newValue)
d712 1
a712 1
  int hasChanged = FALSE;
d714 2
a715 2
  if (dataElement->item_no != UNDEFINED_ITEM &&
      _tuiRegisterName (dataElement->item_no) != (char *) NULL)
d717 1
a717 1
      char rawBuf[MAX_REGISTER_SIZE];
d720 1
a720 2
      if (_tuiGetRegisterRawValue (
			 dataElement->item_no, rawBuf, frame) == TUI_SUCCESS)
d722 1
a722 1
          int size = DEPRECATED_REGISTER_RAW_SIZE (dataElement->item_no);
d724 3
a726 3
	  for (i = 0; (i < size && !hasChanged); i++)
	    hasChanged = (((char *) dataElement->value)[i] != rawBuf[i]);
	  if (hasChanged && newValue != (char *) NULL)
d729 1
a729 1
		newValue[i] = rawBuf[i];
d733 2
a734 2
  return hasChanged;
}				/* _tuiRegValueHasChanged */
d738 1
a738 4
/*
   ** _tuiGetRegisterRawValue().
   **        Get the register raw value.  The raw value is returned in regValue.
 */
d740 1
a740 1
_tuiGetRegisterRawValue (int regNum, char *regValue, struct frame_info *frame)
d746 1
a746 1
      get_frame_register (frame, regNum, regValue);
d750 1
a750 1
      if (register_cached (regNum) >= 0)
d754 1
a754 1
}				/* _tuiGetRegisterRawValue */
d758 2
a759 5
/*
   ** _tuiSetRegisterElement().
   **       Function to initialize a data element with the input and
   **       the register value.
 */
d761 16
a776 16
_tuiSetRegisterElement (int regNum, struct frame_info *frame,
                        struct tui_data_element * dataElement,
                        int refreshValueOnly)
{
  if (dataElement != (struct tui_data_element *) NULL)
    {
      if (!refreshValueOnly)
	{
	  dataElement->item_no = regNum;
	  dataElement->name = _tuiRegisterName (regNum);
	  dataElement->highlight = FALSE;
	}
      if (dataElement->value == NULL)
	dataElement->value = xmalloc (MAX_REGISTER_SIZE);
      if (dataElement->value != NULL)
	_tuiGetRegisterRawValue (regNum, dataElement->value, frame);
d778 1
a779 2
  return;
}				/* _tuiSetRegisterElement */
d781 4
a784 7

/*
   ** _tuiSetRegsContent().
   **        Set the content of the data window to consist of the registers
   **        numbered from startRegNum to endRegNum.  Note that if
   **        refreshValuesOnly is TRUE, startRegNum and endRegNum are ignored.
 */
d786 1
a786 1
_tuiSetRegsContent (int startRegNum, int endRegNum,
d788 2
a789 2
                    enum tui_register_display_type dpyType,
                    int refreshValuesOnly)
d792 2
a793 2
  int numRegs = endRegNum - startRegNum + 1;
  int allocatedHere = FALSE;
d796 1
a796 1
      !refreshValuesOnly)
d805 2
a806 2
	tui_alloc_content (numRegs, DATA_WIN);
      allocatedHere = TRUE;
d813 1
a813 1
      if (!refreshValuesOnly || allocatedHere)
d817 1
a817 1
	  tui_add_content_elements (&TUI_DATA_WIN->generic, numRegs);
d820 1
a820 1
	  TUI_DATA_WIN->detail.data_display_info.regs_content_count = numRegs;
d825 1
a825 1
      for (i = startRegNum; (i <= endRegNum); i++)
d827 1
a827 1
	  struct tui_gen_win_info * dataItemWin;
d829 3
a831 3
	  dataItemWin = &TUI_DATA_WIN->detail.data_display_info.
	    regs_content[i - startRegNum]->which_element.data_window;
	  _tuiSetRegisterElement (
d834 2
a835 2
	   &((struct tui_win_element *) dataItemWin->content[0])->which_element.data,
				   !allocatedHere && refreshValuesOnly);
d838 1
a838 1
	tui_calculate_regs_column_count (dpyType);
d844 1
a844 1
	  /* append TUI_DATA_WIN->detail.data_display_info.dataContent to content */
d854 1
a854 1
}				/* _tuiSetRegsContent */
d857 2
a858 5
/*
   ** _tuiDisplayRegister().
   **        Function to display a register in a window.  If hilite is TRUE,
   **        than the value will be displayed in reverse video
 */
d860 2
a861 2
_tuiDisplayRegister (int regNum,
                     struct tui_gen_win_info * winInfo,		/* the data item window */
d864 1
a864 1
  if (winInfo->handle != (WINDOW *) NULL)
d868 3
a870 3
      int valueCharsWide, labelWidth;
      struct tui_data_element * dataElementPtr = &((tui_win_content)
				    winInfo->content)[0]->which_element.data;
d875 2
a876 2
	  valueCharsWide = DOUBLE_FLOAT_VALUE_WIDTH;
	  labelWidth = DOUBLE_FLOAT_LABEL_WIDTH;
d883 2
a884 2
	      valueCharsWide = SINGLE_FLOAT_VALUE_WIDTH;
	      labelWidth = SINGLE_FLOAT_LABEL_WIDTH;
d888 2
a889 2
	      valueCharsWide = SINGLE_VALUE_WIDTH;
	      labelWidth = SINGLE_LABEL_WIDTH;
d894 4
a897 4
      _tuiRegisterFormat (buf,
			  valueCharsWide + labelWidth,
			  regNum,
			  dataElementPtr,
d900 8
a907 2
      if (dataElementPtr->highlight)
	wstandout (winInfo->handle);
d909 3
a911 9
      wmove (winInfo->handle, 0, 0);
      for (i = 1; i < winInfo->width; i++)
        waddch (winInfo->handle, ' ');
      wmove (winInfo->handle, 0, 0);
      waddstr (winInfo->handle, buf);

      if (dataElementPtr->highlight)
	wstandend (winInfo->handle);
      tui_refresh_win (winInfo);
d913 1
a913 2
  return;
}				/* _tuiDisplayRegister */
d917 1
a917 1
_tui_vShowRegisters_commandSupport (enum tui_register_display_type dpyType)
d922 2
a923 2
      if (TUI_DATA_WIN->detail.data_display_info.regs_display_type != dpyType)
	tui_show_registers (dpyType);
d926 1
a926 1
    (tui_layout_def ())->regs_display_type = dpyType;
d929 1
a929 1
}				/* _tui_vShowRegisters_commandSupport */
d933 1
a933 1
_tuiShowFloat_command (char *arg, int fromTTY)
d938 2
a939 4
    _tui_vShowRegisters_commandSupport ((tui_layout_def ())->float_regs_display_type);

  return;
}				/* _tuiShowFloat_command */
d943 1
a943 1
_tuiShowGeneral_command (char *arg, int fromTTY)
d945 1
a945 1
  _tui_vShowRegisters_commandSupport (TUI_GENERAL_REGS);
d950 1
a950 1
_tuiShowSpecial_command (char *arg, int fromTTY)
d952 1
a952 1
  _tui_vShowRegisters_commandSupport (TUI_SPECIAL_REGS);
d957 1
a957 1
_tuiToggleFloatRegs_command (char *arg, int fromTTY)
d960 1
a960 1
    tuiToggleFloatRegs ();
d963 1
a963 1
      struct tui_layout_def * layoutDef = tui_layout_def ();
d965 2
a966 2
      if (layoutDef->float_regs_display_type == TUI_SFLOAT_REGS)
	layoutDef->float_regs_display_type = TUI_DFLOAT_REGS;
d968 1
a968 1
	layoutDef->float_regs_display_type = TUI_SFLOAT_REGS;
d970 1
a970 4


  return;
}				/* _tuiToggleFloatRegs_command */
d974 1
a974 1
_tuiScrollRegsForward_command (char *arg, int fromTTY)
d981 1
a981 1
_tuiScrollRegsBackward_command (char *arg, int fromTTY)
@


1.7
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui.h (Opaque, OpaquePtr OpaqueList): Delete definition.
	(TuiPoint, TuiPointPtr): Ditto.
	(TuiStatus, TuiStatusPtr): Ditto.
	(TuiWinType, TuiWinTypePtr): Ditto.
	(struct tui_point): Rename _TuiPoint.
	(tui_get_low_disassembly_address): Rename
	tuiGetLowDisassemblyAddress.
	(tui_update_all_exec_infos): Rename tuiUpdateAllExecInfos.
	(tuiFree): Delete declaration.
	(OpaqueFuncPtr, TuiOpaqueFuncPtr): Delete definitions.
	(TuiVoidFuncPtr, TuiIntFuncPtr): Delete definitions.
	* tui/tui.c (tuiFree): Delete function.
	* cli/cli-cmds.c (disassemble_command): Update references.
	* tui/tui-data.c, tui/tui-data.h, tui/tui-disasm.c: Ditto.
	* tui/tui-layout.c, tui/tui-regs.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-win.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d35 1
d116 1
a116 1
  if (dataWin->detail.dataDisplayInfo.regsContentCount > 0)
d118 4
a121 4
      numLines = (dataWin->detail.dataDisplayInfo.regsContentCount /
		  dataWin->detail.dataDisplayInfo.regsColumnCount);
      if (dataWin->detail.dataDisplayInfo.regsContentCount %
	  dataWin->detail.dataDisplayInfo.regsColumnCount)
d134 1
a134 1
  if (elementNo < dataWin->detail.dataDisplayInfo.regsContentCount)
d142 1
a142 1
	      (dataWin->detail.dataDisplayInfo.regsColumnCount * i))
d160 2
a161 2
  if ((lineNo * dataWin->detail.dataDisplayInfo.regsColumnCount)
      <= dataWin->detail.dataDisplayInfo.regsContentCount)
d163 2
a164 2
	    dataWin->detail.dataDisplayInfo.regsColumnCount) -
      dataWin->detail.dataDisplayInfo.regsColumnCount;
d178 2
a179 2
  if ((lineNo * dataWin->detail.dataDisplayInfo.regsColumnCount) <=
      dataWin->detail.dataDisplayInfo.regsContentCount)
d181 1
a181 1
	    dataWin->detail.dataDisplayInfo.regsColumnCount) - 1;
d203 1
a203 1
  colCount = (dataWin->generic.width - 2) / colWidth;
d206 1
a206 1
}				/* tuiCalulateRegsColumnCount */
d219 1
a219 1
  dataWin->detail.dataDisplayInfo.displayRegs = TRUE;
d224 1
a224 1
	(dpyType == dataWin->detail.dataDisplayInfo.regsDisplayType);
d252 1
a252 1
      dataWin->detail.dataDisplayInfo.regsDisplayType = TUI_UNDEFINED_REGS;
d260 1
a260 1
      for (i = 0; (i < dataWin->detail.dataDisplayInfo.regsContentCount); i++)
d264 2
a265 2
	  dataItemWin = &dataWin->detail.dataDisplayInfo.
	    regsContent[i]->whichElement.dataWindow;
d267 1
a267 1
	     dataItemWin->content[0])->whichElement.data)->highlight = FALSE;
d269 1
a269 1
      dataWin->detail.dataDisplayInfo.regsDisplayType = dpyType;
d272 1
a272 1
  (tui_layout_def ())->regsDisplayType = dpyType;
d285 2
a286 2
  if (dataWin->detail.dataDisplayInfo.regsContent != (tui_win_content) NULL &&
      dataWin->detail.dataDisplayInfo.regsContentCount > 0)
d292 1
a292 1
      precision = (dataWin->detail.dataDisplayInfo.regsDisplayType
d296 1
a296 1
	  dataWin->detail.dataDisplayInfo.regsDisplayType == TUI_DFLOAT_REGS)
d303 1
a303 1
	  if (dataWin->detail.dataDisplayInfo.regsDisplayType ==
d320 2
a321 2
      while (i < dataWin->detail.dataDisplayInfo.regsContentCount &&
	     curY <= dataWin->generic.viewportHeight)
d324 2
a325 2
	       (j < dataWin->detail.dataDisplayInfo.regsColumnCount &&
		i < dataWin->detail.dataDisplayInfo.regsContentCount); j++)
d331 2
a332 2
	      dataItemWin = &dataWin->detail.dataDisplayInfo.
		regsContent[i]->whichElement.dataWindow;
d334 1
a334 1
				 dataItemWin->content[0])->whichElement.data;
d352 1
a352 1
			    dataElementPtr->itemNo, dataItemWin, precision);
d374 2
a375 2
  if (dataWin->detail.dataDisplayInfo.regsContent != (tui_win_content) NULL &&
      dataWin->detail.dataDisplayInfo.regsContentCount > 0)
d384 1
a384 1
	  firstLineOnLastPage = lastLineNo - (dataWin->generic.height - 2);
d392 1
a392 1
	  if (dataWin->detail.dataDisplayInfo.dataContentCount <= 0 &&
d410 1
a410 1
  if (dataWin->detail.dataDisplayInfo.regsContentCount > 0)
d424 1
a424 1
		 dataWin->detail.dataDisplayInfo.regsContentCount - 1)) < 0)
d434 1
a434 1
      if (elementNo < dataWin->detail.dataDisplayInfo.regsContentCount)
d452 1
a452 1
  if (m_winPtrNotNull (dataWin) && dataWin->generic.isVisible)
d454 3
a456 3
      if (dataWin->detail.dataDisplayInfo.regsContentCount <= 0 &&
	  dataWin->detail.dataDisplayInfo.displayRegs)
	tui_show_registers ((tui_layout_def ())->regsDisplayType);
d463 1
a463 1
	       (i < dataWin->detail.dataDisplayInfo.regsContentCount); i++)
d469 2
a470 2
	      dataItemWinPtr = &dataWin->detail.dataDisplayInfo.
		regsContent[i]->whichElement.dataWindow;
d472 1
a472 1
			     dataItemWinPtr->content[0])->whichElement.data;
d480 1
a480 1
                  size = DEPRECATED_REGISTER_RAW_SIZE (dataElementPtr->itemNo);
d484 1
a484 1
					dataElementPtr->itemNo,
d486 1
a486 1
			((dataWin->detail.dataDisplayInfo.regsDisplayType ==
d494 1
a494 1
					dataElementPtr->itemNo,
d496 1
a496 1
			((dataWin->detail.dataDisplayInfo.regsDisplayType ==
d515 2
a516 2
  if (layoutDef->floatRegsDisplayType == TUI_SFLOAT_REGS)
    layoutDef->floatRegsDisplayType = TUI_DFLOAT_REGS;
d518 1
a518 1
    layoutDef->floatRegsDisplayType = TUI_SFLOAT_REGS;
d520 4
a523 4
  if (m_winPtrNotNull (dataWin) && dataWin->generic.isVisible &&
      (dataWin->detail.dataDisplayInfo.regsDisplayType == TUI_SFLOAT_REGS ||
       dataWin->detail.dataDisplayInfo.regsDisplayType == TUI_DFLOAT_REGS))
    tui_show_registers (layoutDef->floatRegsDisplayType);
d734 2
a735 2
  if (dataElement->itemNo != UNDEFINED_ITEM &&
      _tuiRegisterName (dataElement->itemNo) != (char *) NULL)
d741 1
a741 1
			 dataElement->itemNo, rawBuf, frame) == TUI_SUCCESS)
d743 1
a743 1
          int size = DEPRECATED_REGISTER_RAW_SIZE (dataElement->itemNo);
d796 1
a796 1
	  dataElement->itemNo = regNum;
d826 1
a826 1
  if (dataWin->detail.dataDisplayInfo.regsContentCount > 0 &&
d829 3
a831 3
      tui_free_data_content (dataWin->detail.dataDisplayInfo.regsContent,
			     dataWin->detail.dataDisplayInfo.regsContentCount);
      dataWin->detail.dataDisplayInfo.regsContentCount = 0;
d833 1
a833 1
  if (dataWin->detail.dataDisplayInfo.regsContentCount <= 0)
d835 1
a835 1
      dataWin->detail.dataDisplayInfo.regsContent =
d840 1
a840 1
  if (dataWin->detail.dataDisplayInfo.regsContent != (tui_win_content) NULL)
d846 6
a851 6
	  dataWin->generic.content = NULL;
	  dataWin->generic.contentSize = 0;
	  tui_add_content_elements (&dataWin->generic, numRegs);
	  dataWin->detail.dataDisplayInfo.regsContent =
	    (tui_win_content) dataWin->generic.content;
	  dataWin->detail.dataDisplayInfo.regsContentCount = numRegs;
d860 2
a861 2
	  dataItemWin = &dataWin->detail.dataDisplayInfo.
	    regsContent[i - startRegNum]->whichElement.dataWindow;
d865 1
a865 1
	   &((struct tui_win_element *) dataItemWin->content[0])->whichElement.data,
d868 1
a868 1
      dataWin->detail.dataDisplayInfo.regsColumnCount =
d871 1
a871 1
      if (dataWin->detail.dataDisplayInfo.dataContentCount > 0)
d874 2
a875 2
	  /* realloc content equal to dataContentCount + regsContentCount */
	  /* append dataWin->detail.dataDisplayInfo.dataContent to content */
d878 3
a880 3
      dataWin->generic.contentSize =
	dataWin->detail.dataDisplayInfo.regsContentCount +
	dataWin->detail.dataDisplayInfo.dataContentCount;
d904 1
a904 1
				    winInfo->content)[0]->whichElement.data;
d907 1
a907 1
	  dataWin->detail.dataDisplayInfo.regsDisplayType == TUI_DFLOAT_REGS)
d914 1
a914 1
	  if (dataWin->detail.dataDisplayInfo.regsDisplayType ==
d955 1
a955 1
  if (m_winPtrNotNull (dataWin) && dataWin->generic.isVisible)
d957 1
a957 1
      if (dataWin->detail.dataDisplayInfo.regsDisplayType != dpyType)
d961 1
a961 1
    (tui_layout_def ())->regsDisplayType = dpyType;
d970 4
a973 4
  if (m_winPtrIsNull (dataWin) || !dataWin->generic.isVisible ||
      (dataWin->detail.dataDisplayInfo.regsDisplayType != TUI_SFLOAT_REGS &&
       dataWin->detail.dataDisplayInfo.regsDisplayType != TUI_DFLOAT_REGS))
    _tui_vShowRegisters_commandSupport ((tui_layout_def ())->floatRegsDisplayType);
d996 1
a996 1
  if (m_winPtrNotNull (dataWin) && dataWin->generic.isVisible)
d1002 2
a1003 2
      if (layoutDef->floatRegsDisplayType == TUI_SFLOAT_REGS)
	layoutDef->floatRegsDisplayType = TUI_DFLOAT_REGS;
d1005 1
a1005 1
	layoutDef->floatRegsDisplayType = TUI_SFLOAT_REGS;
d1016 1
a1016 1
  tui_scroll (FORWARD_SCROLL, dataWin, 1);
d1023 1
a1023 1
  tui_scroll (BACKWARD_SCROLL, dataWin, 1);
@


1.6
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

        * tui/tui-data.h (tui_win_element): Rename TuiWinElement.
        (tui_exec_info_content): Rename TuiExecInfoContent.
        (TuiGenWinInfo, TuiGenWinInfoPtr): Delete definitions.
        (TuiWinInfo, TuiWinInfoPtr): Ditto.
        (TuiScrollDirection, TuiScrollDirectionPtr): Ditto.
        (TuiList, TuiListPtr): Ditto.
        (TuiLayoutType, TuiLayoutTypePtr): Ditto.
        (TuiDataType, TuiDataTypePtr): Ditto.
        (TuiRegisterDisplayType, TuiRegisterDisplayTypePtr): Ditto.
        (TuiLineOrAddress, TuiLineOrAddressPtr): Ditto.
        (TuiLayoutDef, TuiLayoutDefPtr): Ditto.
        (TuiSourceElement, TuiSourceElementPtr): Ditto.
        (TuiDataElement, TuiDataElementPtr): Ditto.
        (TuiWinElement, TuiWinElementPtr): Ditto.
        (TuiDataInfo, TuiDataInfoPtr): Ditto.
        (TuiCommandElement, TuiCommandElementPtr): Ditto.
        (TuiLocatorElement, TuiLocatorElementPtr): Ditto.
        (TuiWhichElement, TuiWhichElementPtr): Ditto.
        (TuiSourceInfo, TuiSourceInfoPtr): Ditto.
        (TuiCommandInfo, TuiCommandInfoPtr): Ditto.
        * tui/tui-command.c, tui/tui-data.c: Update references.
        * tui/tui-data.h, tui/tui-disasm.c, tui/tui-layout.c: Ditto.
        * tui/tui-regs.c, tui/tui-source.c, tui/tui-stack.c: Ditto.
        * tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
        * tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d79 1
a79 1
static TuiStatus _tuiSetRegsContent
d82 1
a82 1
static TuiStatus _tuiGetRegisterRawValue (int, char *, struct frame_info *);
d88 4
a91 4
static TuiStatus _tuiSetGeneralRegsContent (int);
static TuiStatus _tuiSetSpecialRegsContent (int);
static TuiStatus _tuiSetGeneralAndSpecialRegsContent (int);
static TuiStatus _tuiSetFloatRegsContent (enum tui_register_display_type, int);
d214 1
a214 1
  TuiStatus ret = TUI_FAILURE;
d644 1
a644 1
static TuiStatus
d666 1
a666 1
static TuiStatus
d669 1
a669 1
  TuiStatus ret = TUI_FAILURE;
d687 1
a687 1
static TuiStatus
d690 1
a690 1
  TuiStatus ret = TUI_FAILURE;
d704 1
a704 1
static TuiStatus
d707 1
a707 1
  TuiStatus ret = TUI_FAILURE;
d762 1
a762 1
static TuiStatus
d765 1
a765 1
  TuiStatus ret = TUI_FAILURE;
d799 3
a801 3
      if (dataElement->value == (Opaque) NULL)
	dataElement->value = (Opaque) xmalloc (MAX_REGISTER_SIZE);
      if (dataElement->value != (Opaque) NULL)
d815 1
a815 1
static TuiStatus
d821 1
a821 1
  TuiStatus ret = TUI_FAILURE;
d845 1
a845 1
	  dataWin->generic.content = (OpaquePtr) NULL;
@


1.5
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-data.h (struct tui_list): Rename _TuiList.
	(enum tui_data_type): Rename _TuiDataType.
	(struct tui_layout_def): Rename _TuiLayoutDef.
	(struct tui_source_element): Rename _TuiSourceElement.
	(struct tui_data_element): Rename _TuiDataElement.
	(struct tui_command_element): Rename _TuiCommandElement.
	(struct tui_locator_element): Rename _TuiLocatorElement.
	(union tui_which_element): Define.
	(struct tui_win_element): Rename _TuiWinElement.
	(struct tui_data_info): Rename _TuiDataInfo.
	(struct tui_source_info): Rename _TuiSourceInfo.
	(struct tui_command_info): Rename _TuiCommandInfo.
	(tui_initialize_static_data): Rename initializeStaticData.
	(tui_alloc_generic_win_info): Rename allocGenericWinInfo.
	(tui_alloc_win_info): Rename allocWinInfo.
	(tui_init_generic_part): Rename initGenericPart.
	(tui_init_win_info): Rename initWinInfo.
	(tui_alloc_content): Rename allocContent.
	(tui_add_content_elements): Rename addContentElements.
	(tui_init_content_element): Rename initContentElement.
	(tui_free_window): Rename freeWindow.
	(tui_free_win_content): Rename freeWinContent.
	(tui_free_data_content): Rename freeDataContent.
	(tui_free_all_source_wins_content): Rename
	freeAllSourceWinsContent.
	(tui_del_window): Rename tuiDelWindow.
	(tui_del_data_windows): Rename tuiDelDataWindows.
	(tui_partial_win_by_name): Rename partialWinByName.
	(tui_win_name): Rename winName.
	(tui_current_layout): Rename currentLayout.
	(tui_set_current_layout_to): Rename setCurrentLayoutTo.
	(tui_term_height): Rename termHeight.
	(tui_set_term_height_to): Rename setTermHeightTo.
	(tui_term_width): Rename termWidth.
	(tui_set_term_width_to): Rename setTermWidthTo.
	(tui_set_gen_win_origin): Rename setGenWinOrigin.
	(tui_locator_win_info_ptr): Rename locatorWinInfoPtr.
	(tui_source_exec_info_win_ptr): Rename tui_gen_win_info.
	(tui_disassem_exec_info_win_ptr): Rename disassemExecInfoWinPtr.
	(tui_source_windows): Rename sourceWindows.
	(tui_clear_source_windows): Rename clearSourceWindows.
	(tui_clear_source_windows_detail): Rename
	clearSourceWindowsDetail.
	(tui_clear_win_detail): Rename clearWinDetail.
	(tui_add_to_source_windows): Rename tuiAddToSourceWindows.
	(tui_default_tab_len): Rename tuiDefaultTabLen.
	(tui_set_default_tab_len): Rename tuiSetDefaultTabLen.
	(tui_win_with_focus): Rename tuiWinWithFocus.
	(tui_set_win_with_focus): Rename tuiSetWinWithFocus.
	(tui_layout_def): Rename tuiLayoutDef.
	(tui_win_resized): Rename tuiWinResized.
	(tui_set_win_resized_to): Rename tuiSetWinResizedTo.
	(tui_next_win): Rename tuiNextWin.
	(tui_prev_win): Rename tuiPrevWin.
	(tui_add_to_source_windows): Rename addToSourceWindows.
	* tui/tui-winsource.c, tui/tui-win.c: Update references.
	* tui/tui-layout.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-io.c: Ditto.
	* tui/tui.c, tui/tui-data.c: Ditto.
	* tui/tui-interp.c, tui/tui-data.c: Ditto.
	* tui/tui-disasm.c, tui/tui-command.c: Ditto.
@
text
@d80 1
a80 1
  (int, int, struct frame_info *, TuiRegisterDisplayType, int);
d84 2
a85 2
  (int, struct frame_info *, TuiDataElementPtr, int);
static void _tuiDisplayRegister (int, TuiGenWinInfoPtr, enum precision_type);
d87 1
a87 1
  (char *, int, int, TuiDataElementPtr, enum precision_type);
d91 1
a91 1
static TuiStatus _tuiSetFloatRegsContent (TuiRegisterDisplayType, int);
d93 1
a93 1
  (TuiDataElementPtr, struct frame_info *, char *);
d97 1
a97 1
static void _tui_vShowRegisters_commandSupport (TuiRegisterDisplayType);
d189 1
a189 1
tui_calculate_regs_column_count (TuiRegisterDisplayType dpyType)
d212 1
a212 1
tui_show_registers (TuiRegisterDisplayType dpyType)
d261 1
a261 1
	  TuiGenWinInfoPtr dataItemWin;
d265 1
a265 1
	  (&((TuiWinElementPtr)
d284 1
a284 1
  if (dataWin->detail.dataDisplayInfo.regsContent != (TuiWinContent) NULL &&
d326 2
a327 2
	      TuiGenWinInfoPtr dataItemWin;
	      TuiDataElementPtr dataElementPtr;
d332 1
a332 1
	      dataElementPtr = &((TuiWinElementPtr)
d373 1
a373 1
  if (dataWin->detail.dataDisplayInfo.regsContent != (TuiWinContent) NULL &&
d464 2
a465 2
	      TuiDataElementPtr dataElementPtr;
	      TuiGenWinInfoPtr dataItemWinPtr;
d470 1
a470 1
	      dataElementPtr = &((TuiWinElementPtr)
d512 1
a512 1
  TuiLayoutDefPtr layoutDef = tui_layout_def ();
d586 1
a586 1
                    TuiDataElementPtr dataElement,
d705 1
a705 1
_tuiSetFloatRegsContent (TuiRegisterDisplayType dpyType, int refreshValuesOnly)
d727 1
a727 1
_tuiRegValueHasChanged (TuiDataElementPtr dataElement,
d788 1
a788 1
                        TuiDataElementPtr dataElement,
d791 1
a791 1
  if (dataElement != (TuiDataElementPtr) NULL)
d818 1
a818 1
                    TuiRegisterDisplayType dpyType,
d839 1
a839 1
  if (dataWin->detail.dataDisplayInfo.regsContent != (TuiWinContent) NULL)
d849 1
a849 1
	    (TuiWinContent) dataWin->generic.content;
d857 1
a857 1
	  TuiGenWinInfoPtr dataItemWin;
d864 1
a864 1
	   &((TuiWinElementPtr) dataItemWin->content[0])->whichElement.data,
d894 1
a894 1
                     TuiGenWinInfoPtr winInfo,		/* the data item window */
d902 1
a902 1
      TuiDataElementPtr dataElementPtr = &((TuiWinContent)
d951 1
a951 1
_tui_vShowRegisters_commandSupport (TuiRegisterDisplayType dpyType)
d999 1
a999 1
      TuiLayoutDefPtr layoutDef = tui_layout_def ();
@


1.4
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-windata.h: Update copyright.  Include "tui-data.h".
	(tui_erase_data_content): Rename tuiEraseDataContent.
	(tui_display_all_data): Rename tuiDisplayAllData.
	(tui_check_data_values): Rename tuiCheckDataValues.
	(tui_display_data_from_line): Rename tuiDisplayDataFromLine.
	(tui_first_data_item_displayed): Rename tuiFirstDataItemDisplayed.
	(tui_first_data_element_no_in_line): Rename
	tuiFirstDataElementNoInLine.
	(tui_delete_data_content_windows): Rename
	tuiDeleteDataContentWindows.
	(tui_refresh_data_win): Rename tuiRefreshDataWin.
	(tui_display_data_from): Rename tuiDisplayDataFrom.
	(tui_vertical_data_scroll): Rename tuiVerticalDataScroll.
	* tui/tui-windata.c, tui/tui-hooks.c: Update references.
	* tui/tui-win.c, tui/tui-regs.c: Update references.
	* tui/tui-layout.c, tui/tui.c: Update references.
@
text
@d271 1
a271 1
  (tuiLayoutDef ())->regsDisplayType = dpyType;
d455 1
a455 1
	tui_show_registers ((tuiLayoutDef ())->regsDisplayType);
d512 1
a512 1
  TuiLayoutDefPtr layoutDef = tuiLayoutDef ();
d828 2
a829 2
      freeDataContent (dataWin->detail.dataDisplayInfo.regsContent,
		       dataWin->detail.dataDisplayInfo.regsContentCount);
d835 1
a835 1
	allocContent (numRegs, DATA_WIN);
d847 1
a847 1
	  addContentElements (&dataWin->generic, numRegs);
d960 1
a960 1
    (tuiLayoutDef ())->regsDisplayType = dpyType;
d972 1
a972 1
    _tui_vShowRegisters_commandSupport ((tuiLayoutDef ())->floatRegsDisplayType);
d999 1
a999 1
      TuiLayoutDefPtr layoutDef = tuiLayoutDef ();
@


1.3
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-wingeneral.h: Update copyright.
	(m_allBeVisible): Delete macro.
	(m_allBeInvisible): Delete macro.
	(struct tui_gen_win_info): Declare.
	(struct tui_win_info): Declare.
	(tui_unhighlight_win): Rename unhighlightWin.
	(tui_make_visible, tui_make_invisible): Replace makeVisible.
	(tui_make_all_visible, tui_make_all_invisible): Replace makeAllVisible.
	(tui_make_window): Rename makeWindow.
	(tui_copy_win): Rename copyWin.
	(tui_box_win): Rename boxWin.
	(tui_highlight_win): Rename highlightWin.
	(tui_check_and_display_highlight_if_needed): Rename
	checkAndDisplayHighlightIfNeeded.
	(tui_refresh_all): Rename refreshAll.
	(tui_delete_win): Rename tuiDelwin.
	(tui_refresh_win): Rename tuiRefreshWin.
	* tui/tui-wingeneral.c (make_visible): Rename makeVisible.
	(tui_make_visible, tui_make_invisible): New functions.
	(tui_make_all_visible, tui_make_all_invisible): New functions.
	(make_all_visible): Rename makeAllVisible.
	* tui/tui-winsource.c, tui/tui-windata.c: Update references.
	* tui/tui-data.c, tui/tui-winsource.c: Update references.
	* tui/tui-windata.c, tui/tui-win.c: Update references.
	* tui/tui-regs.c, tui/tui-layout.c: Update references.
	* tui/tui-data.h (struct tui_gen_win_info): Rename _TuiGenWinInfo.
@
text
@d252 1
a252 1
      tuiEraseDataContent (NO_REGS_STRING);
d269 1
a269 1
      tuiDisplayAllData ();
@


1.2
log
@2004-01-19  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-regs.h: Include "tui-data.h".
	(tuiFirstRegElementNoInLine): Delete declaration.
	(tui_display_registers_from): Rename tuiDisplayRegistersFrom.
	(tui_last_regs_line_no): Rename tuiLastRegsLineNo.
	(tui_line_from_reg_element_no): Rename tuiLineFromRegElementNo.
	(tui_calculate_regs_column_count): Rename
	tuiCalculateRegsColumnCount.
	(tui_check_register_values): Rename tuiCheckRegisterValues.
	(tui_show_registers): Rename tuiShowRegisters.
	(tui_display_registers_from_line): Rename
	tuiDisplayRegistersFromLine.
	(tui_first_reg_element_inline): Rename tuiFirstRegElementInLine.
	(tui_toggle_float_regs): Rename tuiToggleFloatRegs.
	(tui_first_reg_element_no_inline): Rename
	tuiFirstRegElementNoInLine.
	* tui/tui-data.h: Update copyright.
	(enum tui_register_display_type): Rename _TuiRegisterDisplayType.
	* tui/tui-windata.c: Update copyright, update references.
	* tui/tui-regs.c: Update copyright, update references.
	* tui/tui-win.c: Update copyright, update references.
	* tui/tui-layout.c: Update copyright, update references.
@
text
@d341 1
a341 1
		  makeWindow (dataItemWin, DONT_BOX_WINDOW);
d944 1
a944 1
      tuiRefreshWin (winInfo);
@


1.2.4.1
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.1
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.
d108 2
a109 5
/*
   ** tuiLastRegsLineNo()
   **        Answer the number of the last line in the regs display.
   **        If there are no registers (-1) is returned.
 */
d111 1
a111 1
tuiLastRegsLineNo (void)
d124 1
a124 1
}				/* tuiLastRegsLineNo */
d127 3
a129 6
/*
   ** tuiLineFromRegElementNo()
   **        Answer the line number that the register element at elementNo is
   **        on.  If elementNo is greater than the number of register elements
   **        there are, -1 is returned.
 */
d131 1
a131 1
tuiLineFromRegElementNo (int elementNo)
d151 1
a151 1
}				/* tuiLineFromRegElementNo */
d154 2
a155 5
/*
   ** tuiFirstRegElementNoInLine()
   **        Answer the index of the first element in lineNo.  If lineNo is
   **        past the register area (-1) is returned.
 */
d157 1
a157 1
tuiFirstRegElementNoInLine (int lineNo)
d166 1
a166 1
}				/* tuiFirstRegElementNoInLine */
d186 2
a187 5
/*
   ** tuiCalculateRegsColumnCount
   **        Calculate the number of columns that should be used to display
   **        the registers.
 */
d189 1
a189 1
tuiCalculateRegsColumnCount (TuiRegisterDisplayType dpyType)
d208 3
a210 6
/*
   ** tuiShowRegisters().
   **        Show the registers int the data window as indicated by dpyType.
   **        If there is any other registers being displayed, then they are
   **        cleared.  What registers are displayed is dependent upon dpyType.
 */
d212 1
a212 1
tuiShowRegisters (TuiRegisterDisplayType dpyType)
d274 1
a274 1
}				/* tuiShowRegisters */
d277 4
a280 7
/*
   ** tuiDisplayRegistersFrom().
   **        Function to display the registers in the content from
   **        'startElementNo' until the end of the register content or the
   **        end of the display height.  No checking for displaying past
   **        the end of the registers is done here.
 */
d282 1
a282 1
tuiDisplayRegistersFrom (int startElementNo)
d359 1
a359 1
}				/* tuiDisplayRegistersFrom */
d382 1
a382 1
	  lastLineNo = tuiLastRegsLineNo ();
d393 1
a393 1
	    elementNo = tuiFirstRegElementNoInLine (firstLineOnLastPage);
d395 1
a395 1
      tuiDisplayRegistersFrom (elementNo);
d403 3
a405 6
/*
   ** tuiDisplayRegistersFromLine().
   **        Function to display the registers starting at line lineNo in
   **        the data window.  Answers the line number that the display
   **        actually started from.  If nothing is displayed (-1) is returned.
 */
d407 1
a407 1
tuiDisplayRegistersFromLine (int lineNo, int forceDisplay)
d420 1
a420 1
	  if (lineNo >= tuiLastRegsLineNo ())
d422 1
a422 1
	      if ((line = tuiLineFromRegElementNo (
d432 1
a432 1
      elementNo = tuiFirstRegElementNoInLine (line);
d442 1
a442 1
}				/* tuiDisplayRegistersFromLine */
d445 3
a447 6
/*
   ** tuiCheckRegisterValues()
   **        This function check all displayed registers for changes in
   **        values, given a particular frame.  If the values have changed,
   **        they are updated with the new value and highlighted.
 */
d449 1
a449 1
tuiCheckRegisterValues (struct frame_info *frame)
d455 1
a455 1
	tuiShowRegisters ((tuiLayoutDef ())->regsDisplayType);
d503 1
a503 1
}				/* tuiCheckRegisterValues */
d522 1
a522 1
    tuiShowRegisters (layoutDef->floatRegsDisplayType);
d868 1
a868 1
	tuiCalculateRegsColumnCount (dpyType);
d957 1
a957 1
	tuiShowRegisters (dpyType);
@

