head	1.60;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.60
	gdb_7_6-2013-04-26-release:1.60
	gdb_7_6-branch:1.60.0.2
	gdb_7_6-2013-03-12-branchpoint:1.60
	gdb_7_5_1-2012-11-29-release:1.58
	gdb_7_5-2012-08-17-release:1.58
	gdb_7_5-branch:1.58.0.2
	gdb_7_5-2012-07-18-branchpoint:1.58
	gdb_7_4_1-2012-04-26-release:1.54.4.1
	gdb_7_4-2012-01-24-release:1.54.4.1
	gdb_7_4-branch:1.54.0.4
	gdb_7_4-2011-12-13-branchpoint:1.54
	gdb_7_3_1-2011-09-04-release:1.54
	gdb_7_3-2011-07-26-release:1.54
	gdb_7_3-branch:1.54.0.2
	gdb_7_3-2011-04-01-branchpoint:1.54
	gdb_7_2-2010-09-02-release:1.47
	gdb_7_2-branch:1.47.0.2
	gdb_7_2-2010-07-07-branchpoint:1.47
	gdb_7_1-2010-03-18-release:1.45
	gdb_7_1-branch:1.45.0.2
	gdb_7_1-2010-02-18-branchpoint:1.45
	gdb_7_0_1-2009-12-22-release:1.44
	gdb_7_0-2009-10-06-release:1.44
	gdb_7_0-branch:1.44.0.4
	gdb_7_0-2009-09-16-branchpoint:1.44
	arc-sim-20090309:1.41
	msnyder-checkpoint-072509-branch:1.44.0.2
	msnyder-checkpoint-072509-branchpoint:1.44
	arc-insight_6_8-branch:1.41.0.16
	arc-insight_6_8-branchpoint:1.41
	insight_6_8-branch:1.41.0.14
	insight_6_8-branchpoint:1.41
	reverse-20081226-branch:1.41.0.12
	reverse-20081226-branchpoint:1.41
	multiprocess-20081120-branch:1.41.0.10
	multiprocess-20081120-branchpoint:1.41
	reverse-20080930-branch:1.41.0.8
	reverse-20080930-branchpoint:1.41
	reverse-20080717-branch:1.41.0.6
	reverse-20080717-branchpoint:1.41
	msnyder-reverse-20080609-branch:1.41.0.4
	msnyder-reverse-20080609-branchpoint:1.41
	drow-reverse-20070409-branch:1.33.0.2
	drow-reverse-20070409-branchpoint:1.33
	gdb_6_8-2008-03-27-release:1.41
	gdb_6_8-branch:1.41.0.2
	gdb_6_8-2008-02-26-branchpoint:1.41
	gdb_6_7_1-2007-10-29-release:1.39
	gdb_6_7-2007-10-10-release:1.39
	gdb_6_7-branch:1.39.0.2
	gdb_6_7-2007-09-07-branchpoint:1.39
	insight_6_6-20070208-release:1.31
	gdb_6_6-2006-12-18-release:1.31
	gdb_6_6-branch:1.31.0.18
	gdb_6_6-2006-11-15-branchpoint:1.31
	insight_6_5-20061003-release:1.31
	gdb-csl-symbian-6_4_50_20060226-12:1.31
	gdb-csl-sourcerygxx-3_4_4-25:1.28
	nickrob-async-20060828-mergepoint:1.31
	gdb-csl-symbian-6_4_50_20060226-11:1.31
	gdb-csl-sourcerygxx-4_1-17:1.31
	gdb-csl-20060226-branch-local-2:1.31
	gdb-csl-sourcerygxx-4_1-14:1.31
	gdb-csl-sourcerygxx-4_1-13:1.31
	gdb-csl-sourcerygxx-4_1-12:1.31
	gdb-csl-sourcerygxx-3_4_4-21:1.31
	gdb_6_5-20060621-release:1.31
	gdb-csl-sourcerygxx-4_1-9:1.31
	gdb-csl-sourcerygxx-4_1-8:1.31
	gdb-csl-sourcerygxx-4_1-7:1.31
	gdb-csl-arm-2006q1-6:1.31
	gdb-csl-sourcerygxx-4_1-6:1.31
	gdb-csl-symbian-6_4_50_20060226-10:1.31
	gdb-csl-symbian-6_4_50_20060226-9:1.31
	gdb-csl-symbian-6_4_50_20060226-8:1.31
	gdb-csl-coldfire-4_1-11:1.31
	gdb-csl-sourcerygxx-3_4_4-19:1.31
	gdb-csl-coldfire-4_1-10:1.31
	gdb_6_5-branch:1.31.0.16
	gdb_6_5-2006-05-14-branchpoint:1.31
	gdb-csl-sourcerygxx-4_1-5:1.31
	nickrob-async-20060513-branch:1.31.0.14
	nickrob-async-20060513-branchpoint:1.31
	gdb-csl-sourcerygxx-4_1-4:1.31
	msnyder-reverse-20060502-branch:1.31.0.12
	msnyder-reverse-20060502-branchpoint:1.31
	gdb-csl-morpho-4_1-4:1.31
	gdb-csl-sourcerygxx-3_4_4-17:1.31
	readline_5_1-import-branch:1.31.0.10
	readline_5_1-import-branchpoint:1.31
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.31
	gdb-csl-symbian-20060226-branch:1.31.0.8
	gdb-csl-symbian-20060226-branchpoint:1.31
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.31
	msnyder-reverse-20060331-branch:1.31.0.6
	msnyder-reverse-20060331-branchpoint:1.31
	gdb-csl-available-20060303-branch:1.31.0.4
	gdb-csl-available-20060303-branchpoint:1.31
	gdb-csl-20060226-branch:1.31.0.2
	gdb-csl-20060226-branchpoint:1.31
	gdb_6_4-20051202-release:1.27.2.1
	msnyder-fork-checkpoint-branch:1.28.0.4
	msnyder-fork-checkpoint-branchpoint:1.28
	gdb-csl-gxxpro-6_3-branch:1.28.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.28
	gdb_6_4-branch:1.27.0.2
	gdb_6_4-2005-11-01-branchpoint:1.27
	gdb-csl-arm-20051020-branch:1.26.0.2
	gdb-csl-arm-20051020-branchpoint:1.26
	msnyder-tracepoint-checkpoint-branch:1.25.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.25
	gdb-csl-arm-20050325-2005-q1b:1.25
	gdb-csl-arm-20050325-2005-q1a:1.25
	csl-arm-20050325-branch:1.25.0.2
	csl-arm-20050325-branchpoint:1.25
	gdb-post-i18n-errorwarning-20050211:1.21
	gdb-pre-i18n-errorwarning-20050211:1.20
	gdb_6_3-20041109-release:1.20
	gdb_6_3-branch:1.20.0.2
	gdb_6_3-20041019-branchpoint:1.20
	drow_intercu-merge-20040921:1.20
	drow_intercu-merge-20040915:1.20
	jimb-gdb_6_2-e500-branch:1.18.6.1.0.4
	jimb-gdb_6_2-e500-branchpoint:1.18.6.1
	gdb_6_2-20040730-release:1.18.6.1
	gdb_6_2-branch:1.18.0.6
	gdb_6_2-2004-07-10-gmt-branchpoint:1.18
	gdb_6_1_1-20040616-release:1.17.2.1
	gdb_6_1-2004-04-05-release:1.17.2.1
	drow_intercu-merge-20040402:1.18
	drow_intercu-merge-20040327:1.18
	ezannoni_pie-20040323-branch:1.18.0.4
	ezannoni_pie-20040323-branchpoint:1.18
	ezannoni_pie-20030916-branch:1.18.0.2
	cagney_tramp-20040321-mergepoint:1.18
	cagney_tramp-20040309-branch:1.17.0.4
	cagney_tramp-20040309-branchpoint:1.17
	gdb_6_1-branch:1.17.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.17
	drow_intercu-20040221-branch:1.16.0.4
	drow_intercu-20040221-branchpoint:1.16
	cagney_bfdfile-20040213-branch:1.16.0.2
	cagney_bfdfile-20040213-branchpoint:1.16
	drow-cplus-branch:1.15.0.2
	drow-cplus-merge-20040208:1.13
	carlton_dictionary-branch:1.3.0.4
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.2
	cagney_bigcore-20040122-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.60
date	2013.01.01.06.41.30;	author brobecke;	state Exp;
branches;
next	1.59;

1.59
date	2012.11.20.22.51.05;	author muller;	state Exp;
branches;
next	1.58;

1.58
date	2012.03.16.18.22.24;	author tromey;	state Exp;
branches;
next	1.57;

1.57
date	2012.02.02.16.22.21;	author tromey;	state Exp;
branches;
next	1.56;

1.56
date	2012.01.28.18.08.22;	author jkratoch;	state Exp;
branches;
next	1.55;

1.55
date	2012.01.04.08.27.59;	author brobecke;	state Exp;
branches;
next	1.54;

1.54
date	2011.02.26.02.07.10;	author msnyder;	state Exp;
branches
	1.54.4.1;
next	1.53;

1.53
date	2011.01.06.00.57.05;	author msnyder;	state Exp;
branches;
next	1.52;

1.52
date	2011.01.01.15.33.53;	author brobecke;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.28.23.24.57;	author palves;	state Exp;
branches;
next	1.50;

1.50
date	2010.07.28.12.08.19;	author palves;	state Exp;
branches;
next	1.49;

1.49
date	2010.07.28.12.01.22;	author palves;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.28.11.56.30;	author palves;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.17.22.21.43;	author msnyder;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.05.22.53.54;	author msnyder;	state Exp;
branches;
next	1.45;

1.45
date	2010.01.01.07.32.07;	author brobecke;	state Exp;
branches;
next	1.44;

1.44
date	2009.07.02.17.17.42;	author uweigand;	state Exp;
branches;
next	1.43;

1.43
date	2009.02.21.16.14.50;	author palves;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.03.05.58.08;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2008.01.01.22.53.22;	author drow;	state Exp;
branches
	1.41.10.1;
next	1.40;

1.40
date	2007.10.02.16.50.08;	author uweigand;	state Exp;
branches;
next	1.39;

1.39
date	2007.08.23.18.08.50;	author brobecke;	state Exp;
branches;
next	1.38;

1.38
date	2007.08.15.00.19.44;	author msnyder;	state Exp;
branches;
next	1.37;

1.37
date	2007.08.14.23.50.39;	author msnyder;	state Exp;
branches;
next	1.36;

1.36
date	2007.08.14.21.39.22;	author msnyder;	state Exp;
branches;
next	1.35;

1.35
date	2007.08.14.21.20.09;	author msnyder;	state Exp;
branches;
next	1.34;

1.34
date	2007.08.14.20.23.29;	author msnyder;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.27.19.46.04;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.09.17.59.15;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.14.19.05.40;	author aoliva;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.14.18.45.14;	author aoliva;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.23.19.10.03;	author eliz;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.11.18.07.09;	author ciceron;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.01.17.40.25;	author ams;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2005.07.06.07.25.36;	author woodzltc;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.24.13.51.36;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.21.04.31.59;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.15.15.49.28;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.12.00.39.24;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.11.04.06.14;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.26.14.53.06;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.17.14.24.07;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.13.14.14.01;	author ciceron;	state Exp;
branches
	1.18.2.1
	1.18.6.1;
next	1.17;

1.17
date	2004.02.28.18.04.37;	author cagney;	state Exp;
branches
	1.17.2.1
	1.17.4.1;
next	1.16;

1.16
date	2004.02.10.19.08.16;	author cagney;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	2004.02.08.01.32.26;	author cagney;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2004.02.08.00.05.16;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.07.20.57.02;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.07.17.46.14;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.07.16.31.22;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.07.04.40.36;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.07.01.40.25;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.07.01.02.54;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.07.00.23.56;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.06.23.55.34;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.06.22.42.18;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.28.23.16.50;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.20.21.56.22;	author cagney;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2004.01.19.16.06.04;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.19.04.31.51;	author cagney;	state Exp;
branches;
next	;

1.54.4.1
date	2012.01.06.04.54.36;	author brobecke;	state Exp;
branches;
next	;

1.41.10.1
date	2008.11.21.02.31.59;	author shebs;	state Exp;
branches;
next	;

1.27.2.1
date	2005.11.11.18.07.52;	author ciceron;	state Exp;
branches;
next	;

1.18.2.1
date	2004.03.23.20.09.16;	author ezannoni;	state Exp;
branches;
next	;

1.18.6.1
date	2004.07.17.14.24.17;	author cagney;	state Exp;
branches;
next	;

1.17.2.1
date	2004.03.13.14.21.00;	author ciceron;	state Exp;
branches;
next	;

1.17.4.1
date	2004.03.21.23.57.42;	author cagney;	state Exp;
branches;
next	;

1.16.4.1
date	2004.03.27.17.38.05;	author drow;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2004.09.16.17.01.47;	author drow;	state Exp;
branches;
next	;

1.15.2.1
date	2004.02.09.19.43.57;	author drow;	state Exp;
branches;
next	;

1.3.4.1
date	2004.01.26.19.11.45;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.60
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* TUI window generic functions.

   Copyright (C) 1998-2013 Free Software Foundation, Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This module contains procedures for handling tui window functions
   like resize, scrolling, scrolling, changing focus, etc.

   Author: Susan B. Macchia  */

#include "defs.h"
#include "command.h"
#include "symtab.h"
#include "breakpoint.h"
#include "frame.h"
#include "cli/cli-cmds.h"
#include "top.h"
#include "source.h"

#include "tui/tui.h"
#include "tui/tui-data.h"
#include "tui/tui-wingeneral.h"
#include "tui/tui-stack.h"
#include "tui/tui-regs.h"
#include "tui/tui-disasm.h"
#include "tui/tui-source.h"
#include "tui/tui-winsource.h"
#include "tui/tui-windata.h"
#include "tui/tui-win.h"

#include "gdb_curses.h"

#include "gdb_string.h"
#include <ctype.h>
#include "readline/readline.h"

#include <signal.h>

/*******************************
** Static Local Decls
********************************/
static void make_visible_with_new_height (struct tui_win_info *);
static void make_invisible_and_set_new_height (struct tui_win_info *, 
					       int);
static enum tui_status tui_adjust_win_heights (struct tui_win_info *, 
					       int);
static int new_height_ok (struct tui_win_info *, int);
static void tui_set_tab_width_command (char *, int);
static void tui_refresh_all_command (char *, int);
static void tui_set_win_height_command (char *, int);
static void tui_xdb_set_win_height_command (char *, int);
static void tui_all_windows_info (char *, int);
static void tui_set_focus_command (char *, int);
static void tui_scroll_forward_command (char *, int);
static void tui_scroll_backward_command (char *, int);
static void tui_scroll_left_command (char *, int);
static void tui_scroll_right_command (char *, int);
static void parse_scrolling_args (char *, 
				  struct tui_win_info **, 
				  int *);


/***************************************
** DEFINITIONS
***************************************/
#define WIN_HEIGHT_USAGE    "Usage: winheight <win_name> [+ | -] <#lines>\n"
#define XDBWIN_HEIGHT_USAGE "Usage: w <#lines>\n"
#define FOCUS_USAGE         "Usage: focus {<win> | next | prev}\n"

/***************************************
** PUBLIC FUNCTIONS
***************************************/

#ifndef ACS_LRCORNER
#  define ACS_LRCORNER '+'
#endif
#ifndef ACS_LLCORNER
#  define ACS_LLCORNER '+'
#endif
#ifndef ACS_ULCORNER
#  define ACS_ULCORNER '+'
#endif
#ifndef ACS_URCORNER
#  define ACS_URCORNER '+'
#endif
#ifndef ACS_HLINE
#  define ACS_HLINE '-'
#endif
#ifndef ACS_VLINE
#  define ACS_VLINE '|'
#endif

/* Possible values for tui-border-kind variable.  */
static const char *const tui_border_kind_enums[] = {
  "space",
  "ascii",
  "acs",
  NULL
};

/* Possible values for tui-border-mode and tui-active-border-mode.  */
static const char *const tui_border_mode_enums[] = {
  "normal",
  "standout",
  "reverse",
  "half",
  "half-standout",
  "bold",
  "bold-standout",
  NULL
};

struct tui_translate
{
  const char *name;
  int value;
};

/* Translation table for border-mode variables.
   The list of values must be terminated by a NULL.
   After the NULL value, an entry defines the default.  */
struct tui_translate tui_border_mode_translate[] = {
  { "normal",		A_NORMAL },
  { "standout",		A_STANDOUT },
  { "reverse",		A_REVERSE },
  { "half",		A_DIM },
  { "half-standout",	A_DIM | A_STANDOUT },
  { "bold",		A_BOLD },
  { "bold-standout",	A_BOLD | A_STANDOUT },
  { 0, 0 },
  { "normal",		A_NORMAL }
};

/* Translation tables for border-kind, one for each border
   character (see wborder, border curses operations).
   -1 is used to indicate the ACS because ACS characters
   are determined at run time by curses (depends on terminal).  */
struct tui_translate tui_border_kind_translate_vline[] = {
  { "space",    ' ' },
  { "ascii",    '|' },
  { "acs",      -1 },
  { 0, 0 },
  { "ascii",    '|' }
};

struct tui_translate tui_border_kind_translate_hline[] = {
  { "space",    ' ' },
  { "ascii",    '-' },
  { "acs",      -1 },
  { 0, 0 },
  { "ascii",    '-' }
};

struct tui_translate tui_border_kind_translate_ulcorner[] = {
  { "space",    ' ' },
  { "ascii",    '+' },
  { "acs",      -1 },
  { 0, 0 },
  { "ascii",    '+' }
};

struct tui_translate tui_border_kind_translate_urcorner[] = {
  { "space",    ' ' },
  { "ascii",    '+' },
  { "acs",      -1 },
  { 0, 0 },
  { "ascii",    '+' }
};

struct tui_translate tui_border_kind_translate_llcorner[] = {
  { "space",    ' ' },
  { "ascii",    '+' },
  { "acs",      -1 },
  { 0, 0 },
  { "ascii",    '+' }
};

struct tui_translate tui_border_kind_translate_lrcorner[] = {
  { "space",    ' ' },
  { "ascii",    '+' },
  { "acs",      -1 },
  { 0, 0 },
  { "ascii",    '+' }
};


/* Tui configuration variables controlled with set/show command.  */
const char *tui_active_border_mode = "bold-standout";
static void
show_tui_active_border_mode (struct ui_file *file,
			     int from_tty,
			     struct cmd_list_element *c, 
			     const char *value)
{
  fprintf_filtered (file, _("\
The attribute mode to use for the active TUI window border is \"%s\".\n"),
		    value);
}

const char *tui_border_mode = "normal";
static void
show_tui_border_mode (struct ui_file *file, 
		      int from_tty,
		      struct cmd_list_element *c, 
		      const char *value)
{
  fprintf_filtered (file, _("\
The attribute mode to use for the TUI window borders is \"%s\".\n"),
		    value);
}

const char *tui_border_kind = "acs";
static void
show_tui_border_kind (struct ui_file *file, 
		      int from_tty,
		      struct cmd_list_element *c, 
		      const char *value)
{
  fprintf_filtered (file, _("The kind of border for TUI windows is \"%s\".\n"),
		    value);
}


/* Tui internal configuration variables.  These variables are updated
   by tui_update_variables to reflect the tui configuration
   variables.  */
chtype tui_border_vline;
chtype tui_border_hline;
chtype tui_border_ulcorner;
chtype tui_border_urcorner;
chtype tui_border_llcorner;
chtype tui_border_lrcorner;

int tui_border_attrs;
int tui_active_border_attrs;

/* Identify the item in the translation table.
   When the item is not recognized, use the default entry.  */
static struct tui_translate *
translate (const char *name, struct tui_translate *table)
{
  while (table->name)
    {
      if (name && strcmp (table->name, name) == 0)
        return table;
      table++;
    }

  /* Not found, return default entry.  */
  table++;
  return table;
}

/* Update the tui internal configuration according to gdb settings.
   Returns 1 if the configuration has changed and the screen should
   be redrawn.  */
int
tui_update_variables (void)
{
  int need_redraw = 0;
  struct tui_translate *entry;

  entry = translate (tui_border_mode, tui_border_mode_translate);
  if (tui_border_attrs != entry->value)
    {
      tui_border_attrs = entry->value;
      need_redraw = 1;
    }
  entry = translate (tui_active_border_mode, tui_border_mode_translate);
  if (tui_active_border_attrs != entry->value)
    {
      tui_active_border_attrs = entry->value;
      need_redraw = 1;
    }

  /* If one corner changes, all characters are changed.
     Only check the first one.  The ACS characters are determined at
     run time by curses terminal management.  */
  entry = translate (tui_border_kind, tui_border_kind_translate_lrcorner);
  if (tui_border_lrcorner != (chtype) entry->value)
    {
      tui_border_lrcorner = (entry->value < 0) ? ACS_LRCORNER : entry->value;
      need_redraw = 1;
    }
  entry = translate (tui_border_kind, tui_border_kind_translate_llcorner);
  tui_border_llcorner = (entry->value < 0) ? ACS_LLCORNER : entry->value;

  entry = translate (tui_border_kind, tui_border_kind_translate_ulcorner);
  tui_border_ulcorner = (entry->value < 0) ? ACS_ULCORNER : entry->value;

  entry = translate (tui_border_kind, tui_border_kind_translate_urcorner);
  tui_border_urcorner = (entry->value < 0) ? ACS_URCORNER : entry->value;

  entry = translate (tui_border_kind, tui_border_kind_translate_hline);
  tui_border_hline = (entry->value < 0) ? ACS_HLINE : entry->value;

  entry = translate (tui_border_kind, tui_border_kind_translate_vline);
  tui_border_vline = (entry->value < 0) ? ACS_VLINE : entry->value;

  return need_redraw;
}

static void
set_tui_cmd (char *args, int from_tty)
{
}

static void
show_tui_cmd (char *args, int from_tty)
{
}

static struct cmd_list_element *tuilist;

static void
tui_command (char *args, int from_tty)
{
  printf_unfiltered (_("\"tui\" must be followed by the name of a "
                     "tui command.\n"));
  help_list (tuilist, "tui ", -1, gdb_stdout);
}

struct cmd_list_element **
tui_get_cmd_list (void)
{
  if (tuilist == 0)
    add_prefix_cmd ("tui", class_tui, tui_command,
                    _("Text User Interface commands."),
                    &tuilist, "tui ", 0, &cmdlist);
  return &tuilist;
}

/* Function to initialize gdb commands, for tui window
   manipulation.  */

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_tui_win;

void
_initialize_tui_win (void)
{
  static struct cmd_list_element *tui_setlist;
  static struct cmd_list_element *tui_showlist;

  /* Define the classes of commands.
     They will appear in the help list in the reverse of this order.  */
  add_prefix_cmd ("tui", class_tui, set_tui_cmd,
                  _("TUI configuration variables"),
		  &tui_setlist, "set tui ",
		  0 /* allow-unknown */, &setlist);
  add_prefix_cmd ("tui", class_tui, show_tui_cmd,
                  _("TUI configuration variables"),
		  &tui_showlist, "show tui ",
		  0 /* allow-unknown */, &showlist);

  add_com ("refresh", class_tui, tui_refresh_all_command,
           _("Refresh the terminal display.\n"));
  if (xdb_commands)
    add_com_alias ("U", "refresh", class_tui, 0);
  add_com ("tabset", class_tui, tui_set_tab_width_command, _("\
Set the width (in characters) of tab stops.\n\
Usage: tabset <n>\n"));
  add_com ("winheight", class_tui, tui_set_win_height_command, _("\
Set the height of a specified window.\n\
Usage: winheight <win_name> [+ | -] <#lines>\n\
Window names are:\n\
src  : the source window\n\
cmd  : the command window\n\
asm  : the disassembly window\n\
regs : the register display\n"));
  add_com_alias ("wh", "winheight", class_tui, 0);
  add_info ("win", tui_all_windows_info,
	    _("List of all displayed windows.\n"));
  add_com ("focus", class_tui, tui_set_focus_command, _("\
Set focus to named window or next/prev window.\n\
Usage: focus {<win> | next | prev}\n\
Valid Window names are:\n\
src  : the source window\n\
asm  : the disassembly window\n\
regs : the register display\n\
cmd  : the command window\n"));
  add_com_alias ("fs", "focus", class_tui, 0);
  add_com ("+", class_tui, tui_scroll_forward_command, _("\
Scroll window forward.\n\
Usage: + [win] [n]\n"));
  add_com ("-", class_tui, tui_scroll_backward_command, _("\
Scroll window backward.\n\
Usage: - [win] [n]\n"));
  add_com ("<", class_tui, tui_scroll_left_command, _("\
Scroll window forward.\n\
Usage: < [win] [n]\n"));
  add_com (">", class_tui, tui_scroll_right_command, _("\
Scroll window backward.\n\
Usage: > [win] [n]\n"));
  if (xdb_commands)
    add_com ("w", class_xdb, tui_xdb_set_win_height_command, _("\
XDB compatibility command for setting the height of a command window.\n\
Usage: w <#lines>\n"));

  /* Define the tui control variables.  */
  add_setshow_enum_cmd ("border-kind", no_class, tui_border_kind_enums,
			&tui_border_kind, _("\
Set the kind of border for TUI windows."), _("\
Show the kind of border for TUI windows."), _("\
This variable controls the border of TUI windows:\n\
space           use a white space\n\
ascii           use ascii characters + - | for the border\n\
acs             use the Alternate Character Set"),
			NULL,
			show_tui_border_kind,
			&tui_setlist, &tui_showlist);

  add_setshow_enum_cmd ("border-mode", no_class, tui_border_mode_enums,
			&tui_border_mode, _("\
Set the attribute mode to use for the TUI window borders."), _("\
Show the attribute mode to use for the TUI window borders."), _("\
This variable controls the attributes to use for the window borders:\n\
normal          normal display\n\
standout        use highlight mode of terminal\n\
reverse         use reverse video mode\n\
half            use half bright\n\
half-standout   use half bright and standout mode\n\
bold            use extra bright or bold\n\
bold-standout   use extra bright or bold with standout mode"),
			NULL,
			show_tui_border_mode,
			&tui_setlist, &tui_showlist);

  add_setshow_enum_cmd ("active-border-mode", no_class, tui_border_mode_enums,
			&tui_active_border_mode, _("\
Set the attribute mode to use for the active TUI window border."), _("\
Show the attribute mode to use for the active TUI window border."), _("\
This variable controls the attributes to use for the active window border:\n\
normal          normal display\n\
standout        use highlight mode of terminal\n\
reverse         use reverse video mode\n\
half            use half bright\n\
half-standout   use half bright and standout mode\n\
bold            use extra bright or bold\n\
bold-standout   use extra bright or bold with standout mode"),
			NULL,
			show_tui_active_border_mode,
			&tui_setlist, &tui_showlist);
}

/* Update gdb's knowledge of the terminal size.  */
void
tui_update_gdb_sizes (void)
{
  char cmd[50];

  /* Set to TUI command window dimension or use readline values.  */
  xsnprintf (cmd, sizeof (cmd), "set width %d",
           tui_active ? TUI_CMD_WIN->generic.width : tui_term_width());
  execute_command (cmd, 0);
  xsnprintf (cmd, sizeof (cmd), "set height %d",
           tui_active ? TUI_CMD_WIN->generic.height : tui_term_height());
  execute_command (cmd, 0);
}


/* Set the logical focus to win_info.  */
void
tui_set_win_focus_to (struct tui_win_info *win_info)
{
  if (win_info != NULL)
    {
      struct tui_win_info *win_with_focus = tui_win_with_focus ();

      if (win_with_focus != NULL
	  && win_with_focus->generic.type != CMD_WIN)
	tui_unhighlight_win (win_with_focus);
      tui_set_win_with_focus (win_info);
      if (win_info->generic.type != CMD_WIN)
	tui_highlight_win (win_info);
    }
}


void
tui_scroll_forward (struct tui_win_info *win_to_scroll, 
		    int num_to_scroll)
{
  if (win_to_scroll != TUI_CMD_WIN)
    {
      int _num_to_scroll = num_to_scroll;

      if (num_to_scroll == 0)
	_num_to_scroll = win_to_scroll->generic.height - 3;

      /* If we are scrolling the source or disassembly window, do a
         "psuedo" scroll since not all of the source is in memory,
         only what is in the viewport.  If win_to_scroll is the
         command window do nothing since the term should handle
         it.  */
      if (win_to_scroll == TUI_SRC_WIN)
	tui_vertical_source_scroll (FORWARD_SCROLL, _num_to_scroll);
      else if (win_to_scroll == TUI_DISASM_WIN)
	tui_vertical_disassem_scroll (FORWARD_SCROLL, _num_to_scroll);
      else if (win_to_scroll == TUI_DATA_WIN)
	tui_vertical_data_scroll (FORWARD_SCROLL, _num_to_scroll);
    }
}

void
tui_scroll_backward (struct tui_win_info *win_to_scroll, 
		     int num_to_scroll)
{
  if (win_to_scroll != TUI_CMD_WIN)
    {
      int _num_to_scroll = num_to_scroll;

      if (num_to_scroll == 0)
	_num_to_scroll = win_to_scroll->generic.height - 3;

      /* If we are scrolling the source or disassembly window, do a
         "psuedo" scroll since not all of the source is in memory,
         only what is in the viewport.  If win_to_scroll is the
         command window do nothing since the term should handle
         it.  */
      if (win_to_scroll == TUI_SRC_WIN)
	tui_vertical_source_scroll (BACKWARD_SCROLL, _num_to_scroll);
      else if (win_to_scroll == TUI_DISASM_WIN)
	tui_vertical_disassem_scroll (BACKWARD_SCROLL, _num_to_scroll);
      else if (win_to_scroll == TUI_DATA_WIN)
	tui_vertical_data_scroll (BACKWARD_SCROLL, _num_to_scroll);
    }
}


void
tui_scroll_left (struct tui_win_info *win_to_scroll,
		 int num_to_scroll)
{
  if (win_to_scroll != TUI_CMD_WIN)
    {
      int _num_to_scroll = num_to_scroll;

      if (_num_to_scroll == 0)
	_num_to_scroll = 1;

      /* If we are scrolling the source or disassembly window, do a
         "psuedo" scroll since not all of the source is in memory,
         only what is in the viewport. If win_to_scroll is the command
         window do nothing since the term should handle it.  */
      if (win_to_scroll == TUI_SRC_WIN
	  || win_to_scroll == TUI_DISASM_WIN)
	tui_horizontal_source_scroll (win_to_scroll, LEFT_SCROLL,
				      _num_to_scroll);
    }
}


void
tui_scroll_right (struct tui_win_info *win_to_scroll, 
		  int num_to_scroll)
{
  if (win_to_scroll != TUI_CMD_WIN)
    {
      int _num_to_scroll = num_to_scroll;

      if (_num_to_scroll == 0)
	_num_to_scroll = 1;

      /* If we are scrolling the source or disassembly window, do a
         "psuedo" scroll since not all of the source is in memory,
         only what is in the viewport. If win_to_scroll is the command
         window do nothing since the term should handle it.  */
      if (win_to_scroll == TUI_SRC_WIN
	  || win_to_scroll == TUI_DISASM_WIN)
	tui_horizontal_source_scroll (win_to_scroll, RIGHT_SCROLL,
				      _num_to_scroll);
    }
}


/* Scroll a window.  Arguments are passed through a va_list.  */
void
tui_scroll (enum tui_scroll_direction direction,
	    struct tui_win_info *win_to_scroll,
	    int num_to_scroll)
{
  switch (direction)
    {
    case FORWARD_SCROLL:
      tui_scroll_forward (win_to_scroll, num_to_scroll);
      break;
    case BACKWARD_SCROLL:
      tui_scroll_backward (win_to_scroll, num_to_scroll);
      break;
    case LEFT_SCROLL:
      tui_scroll_left (win_to_scroll, num_to_scroll);
      break;
    case RIGHT_SCROLL:
      tui_scroll_right (win_to_scroll, num_to_scroll);
      break;
    default:
      break;
    }
}


void
tui_refresh_all_win (void)
{
  enum tui_win_type type;

  clearok (curscr, TRUE);
  tui_refresh_all (tui_win_list);
  for (type = SRC_WIN; type < MAX_MAJOR_WINDOWS; type++)
    {
      if (tui_win_list[type] 
	  && tui_win_list[type]->generic.is_visible)
	{
	  switch (type)
	    {
	    case SRC_WIN:
	    case DISASSEM_WIN:
	      tui_show_source_content (tui_win_list[type]);
	      tui_check_and_display_highlight_if_needed (tui_win_list[type]);
	      tui_erase_exec_info_content (tui_win_list[type]);
	      tui_update_exec_info (tui_win_list[type]);
	      break;
	    case DATA_WIN:
	      tui_refresh_data_win ();
	      break;
	    default:
	      break;
	    }
	}
    }
  tui_show_locator_content ();
}


/* Resize all the windows based on the terminal size.  This function
   gets called from within the readline sinwinch handler.  */
void
tui_resize_all (void)
{
  int height_diff, width_diff;
  int screenheight, screenwidth;

  rl_get_screen_size (&screenheight, &screenwidth);
  width_diff = screenwidth - tui_term_width ();
  height_diff = screenheight - tui_term_height ();
  if (height_diff || width_diff)
    {
      enum tui_layout_type cur_layout = tui_current_layout ();
      struct tui_win_info *win_with_focus = tui_win_with_focus ();
      struct tui_win_info *first_win;
      struct tui_win_info *second_win;
      struct tui_gen_win_info *locator = tui_locator_win_info_ptr ();
      enum tui_win_type win_type;
      int new_height, split_diff, cmd_split_diff, num_wins_displayed = 2;

#ifdef HAVE_RESIZE_TERM
      resize_term (screenheight, screenwidth);
#endif      
      /* Turn keypad off while we resize.  */
      if (win_with_focus != TUI_CMD_WIN)
	keypad (TUI_CMD_WIN->generic.handle, FALSE);
      tui_update_gdb_sizes ();
      tui_set_term_height_to (screenheight);
      tui_set_term_width_to (screenwidth);
      if (cur_layout == SRC_DISASSEM_COMMAND 
	  || cur_layout == SRC_DATA_COMMAND
	  || cur_layout == DISASSEM_DATA_COMMAND)
	num_wins_displayed++;
      split_diff = height_diff / num_wins_displayed;
      cmd_split_diff = split_diff;
      if (height_diff % num_wins_displayed)
	{
	  if (height_diff < 0)
	    cmd_split_diff--;
	  else
           cmd_split_diff++;
       }
      /* Now adjust each window.  */
      /* erase + clearok are used instead of a straightforward clear as
         AIX 5.3 does not define clear.  */
      erase ();
      clearok (curscr, TRUE);
      refresh ();
      switch (cur_layout)
       {
	case SRC_COMMAND:
	case DISASSEM_COMMAND:
	  first_win = (struct tui_win_info *) (tui_source_windows ())->list[0];
	  first_win->generic.width += width_diff;
	  locator->width += width_diff;
	  /* Check for invalid heights.  */
	  if (height_diff == 0)
	    new_height = first_win->generic.height;
	  else if ((first_win->generic.height + split_diff) >=
		   (screenheight - MIN_CMD_WIN_HEIGHT - 1))
	    new_height = screenheight - MIN_CMD_WIN_HEIGHT - 1;
	  else if ((first_win->generic.height + split_diff) <= 0)
	    new_height = MIN_WIN_HEIGHT;
	  else
	    new_height = first_win->generic.height + split_diff;

	  locator->origin.y = new_height + 1;
	  make_invisible_and_set_new_height (first_win, new_height);
	  TUI_CMD_WIN->generic.origin.y = locator->origin.y + 1;
	  TUI_CMD_WIN->generic.width += width_diff;
	  new_height = screenheight - TUI_CMD_WIN->generic.origin.y;
	  make_invisible_and_set_new_height (TUI_CMD_WIN, new_height);
	  make_visible_with_new_height (first_win);
	  make_visible_with_new_height (TUI_CMD_WIN);
	  if (first_win->generic.content_size <= 0)
	    tui_erase_source_content (first_win, EMPTY_SOURCE_PROMPT);
	  break;
	default:
	  if (cur_layout == SRC_DISASSEM_COMMAND)
	    {
	      first_win = TUI_SRC_WIN;
	      first_win->generic.width += width_diff;
	      second_win = TUI_DISASM_WIN;
	      second_win->generic.width += width_diff;
	    }
	  else
	    {
	      first_win = TUI_DATA_WIN;
	      first_win->generic.width += width_diff;
	      second_win = (struct tui_win_info *)
		(tui_source_windows ())->list[0];
	      second_win->generic.width += width_diff;
	    }
	  /* Change the first window's height/width.  */
	  /* Check for invalid heights.  */
	  if (height_diff == 0)
	    new_height = first_win->generic.height;
	  else if ((first_win->generic.height +
		    second_win->generic.height + (split_diff * 2)) >=
		   (screenheight - MIN_CMD_WIN_HEIGHT - 1))
	    new_height = (screenheight - MIN_CMD_WIN_HEIGHT - 1) / 2;
	  else if ((first_win->generic.height + split_diff) <= 0)
	    new_height = MIN_WIN_HEIGHT;
	  else
	    new_height = first_win->generic.height + split_diff;
	  make_invisible_and_set_new_height (first_win, new_height);

	  locator->width += width_diff;

	  /* Change the second window's height/width.  */
	  /* Check for invalid heights.  */
	  if (height_diff == 0)
	    new_height = second_win->generic.height;
	  else if ((first_win->generic.height +
		    second_win->generic.height + (split_diff * 2)) >=
		   (screenheight - MIN_CMD_WIN_HEIGHT - 1))
	    {
	      new_height = screenheight - MIN_CMD_WIN_HEIGHT - 1;
	      if (new_height % 2)
		new_height = (new_height / 2) + 1;
	      else
		new_height /= 2;
	    }
	  else if ((second_win->generic.height + split_diff) <= 0)
	    new_height = MIN_WIN_HEIGHT;
	  else
	    new_height = second_win->generic.height + split_diff;
	  second_win->generic.origin.y = first_win->generic.height - 1;
	  make_invisible_and_set_new_height (second_win, new_height);

	  /* Change the command window's height/width.  */
	  TUI_CMD_WIN->generic.origin.y = locator->origin.y + 1;
	  make_invisible_and_set_new_height (TUI_CMD_WIN,
					     TUI_CMD_WIN->generic.height
					     + cmd_split_diff);
	  make_visible_with_new_height (first_win);
	  make_visible_with_new_height (second_win);
	  make_visible_with_new_height (TUI_CMD_WIN);
	  if (first_win->generic.content_size <= 0)
	    tui_erase_source_content (first_win, EMPTY_SOURCE_PROMPT);
	  if (second_win->generic.content_size <= 0)
	    tui_erase_source_content (second_win, EMPTY_SOURCE_PROMPT);
	  break;
	}
      /* Now remove all invisible windows, and their content so that
         they get created again when called for with the new size.  */
      for (win_type = SRC_WIN; (win_type < MAX_MAJOR_WINDOWS); win_type++)
	{
	  if (win_type != CMD_WIN 
	      && (tui_win_list[win_type] != NULL)
	      && !tui_win_list[win_type]->generic.is_visible)
	    {
	      tui_free_window (tui_win_list[win_type]);
	      tui_win_list[win_type] = (struct tui_win_info *) NULL;
	    }
	}
      /* Turn keypad back on, unless focus is in the command
	 window.  */
      if (win_with_focus != TUI_CMD_WIN)
	keypad (TUI_CMD_WIN->generic.handle, TRUE);
    }
}

#ifdef SIGWINCH
/* SIGWINCH signal handler for the tui.  This signal handler is always
   called, even when the readline package clears signals because it is
   set as the old_sigwinch() (TUI only).  */
static void
tui_sigwinch_handler (int signal)
{
  /* Say that a resize was done so that the readline can do it later
     when appropriate.  */
  tui_set_win_resized_to (TRUE);
}
#endif

/* Initializes SIGWINCH signal handler for the tui.  */
void
tui_initialize_win (void)
{
#ifdef SIGWINCH
#ifdef HAVE_SIGACTION
  struct sigaction old_winch;

  memset (&old_winch, 0, sizeof (old_winch));
  old_winch.sa_handler = &tui_sigwinch_handler;
  sigaction (SIGWINCH, &old_winch, NULL);
#else
  signal (SIGWINCH, &tui_sigwinch_handler);
#endif
#endif
}


/*************************
** STATIC LOCAL FUNCTIONS
**************************/


static void
tui_scroll_forward_command (char *arg, int from_tty)
{
  int num_to_scroll = 1;
  struct tui_win_info *win_to_scroll;

  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  if (arg == (char *) NULL)
    parse_scrolling_args (arg, &win_to_scroll, (int *) NULL);
  else
    parse_scrolling_args (arg, &win_to_scroll, &num_to_scroll);
  tui_scroll (FORWARD_SCROLL, win_to_scroll, num_to_scroll);
}


static void
tui_scroll_backward_command (char *arg, int from_tty)
{
  int num_to_scroll = 1;
  struct tui_win_info *win_to_scroll;

  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  if (arg == (char *) NULL)
    parse_scrolling_args (arg, &win_to_scroll, (int *) NULL);
  else
    parse_scrolling_args (arg, &win_to_scroll, &num_to_scroll);
  tui_scroll (BACKWARD_SCROLL, win_to_scroll, num_to_scroll);
}


static void
tui_scroll_left_command (char *arg, int from_tty)
{
  int num_to_scroll;
  struct tui_win_info *win_to_scroll;

  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  parse_scrolling_args (arg, &win_to_scroll, &num_to_scroll);
  tui_scroll (LEFT_SCROLL, win_to_scroll, num_to_scroll);
}


static void
tui_scroll_right_command (char *arg, int from_tty)
{
  int num_to_scroll;
  struct tui_win_info *win_to_scroll;

  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  parse_scrolling_args (arg, &win_to_scroll, &num_to_scroll);
  tui_scroll (RIGHT_SCROLL, win_to_scroll, num_to_scroll);
}


/* Set focus to the window named by 'arg'.  */
static void
tui_set_focus (char *arg, int from_tty)
{
  if (arg != (char *) NULL)
    {
      char *buf_ptr = (char *) xstrdup (arg);
      int i;
      struct tui_win_info *win_info = (struct tui_win_info *) NULL;

      for (i = 0; (i < strlen (buf_ptr)); i++)
	buf_ptr[i] = toupper (arg[i]);

      if (subset_compare (buf_ptr, "NEXT"))
	win_info = tui_next_win (tui_win_with_focus ());
      else if (subset_compare (buf_ptr, "PREV"))
	win_info = tui_prev_win (tui_win_with_focus ());
      else
	win_info = tui_partial_win_by_name (buf_ptr);

      if (win_info == (struct tui_win_info *) NULL
	  || !win_info->generic.is_visible)
	warning (_("Invalid window specified. \n\
The window name specified must be valid and visible.\n"));
      else
	{
	  tui_set_win_focus_to (win_info);
	  keypad (TUI_CMD_WIN->generic.handle, (win_info != TUI_CMD_WIN));
	}

      if (TUI_DATA_WIN && TUI_DATA_WIN->generic.is_visible)
	tui_refresh_data_win ();
      xfree (buf_ptr);
      printf_filtered (_("Focus set to %s window.\n"),
		       tui_win_name ((struct tui_gen_win_info *)
				     tui_win_with_focus ()));
    }
  else
    warning (_("Incorrect Number of Arguments.\n%s"), FOCUS_USAGE);
}

static void
tui_set_focus_command (char *arg, int from_tty)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  tui_set_focus (arg, from_tty);
}


static void
tui_all_windows_info (char *arg, int from_tty)
{
  enum tui_win_type type;
  struct tui_win_info *win_with_focus = tui_win_with_focus ();

  for (type = SRC_WIN; (type < MAX_MAJOR_WINDOWS); type++)
    if (tui_win_list[type] 
	&& tui_win_list[type]->generic.is_visible)
      {
	if (win_with_focus == tui_win_list[type])
	  printf_filtered ("        %s\t(%d lines)  <has focus>\n",
			   tui_win_name (&tui_win_list[type]->generic),
			   tui_win_list[type]->generic.height);
	else
	  printf_filtered ("        %s\t(%d lines)\n",
			   tui_win_name (&tui_win_list[type]->generic),
			   tui_win_list[type]->generic.height);
      }
}


static void
tui_refresh_all_command (char *arg, int from_tty)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();

  tui_refresh_all_win ();
}


/* Set the height of the specified window.  */
static void
tui_set_tab_width_command (char *arg, int from_tty)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  if (arg != (char *) NULL)
    {
      int ts;

      ts = atoi (arg);
      if (ts > 0)
	tui_set_default_tab_len (ts);
      else
	warning (_("Tab widths greater than 0 must be specified."));
    }
}


/* Set the height of the specified window.  */
static void
tui_set_win_height (char *arg, int from_tty)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  if (arg != (char *) NULL)
    {
      char *buf = xstrdup (arg);
      char *buf_ptr = buf;
      char *wname = (char *) NULL;
      int new_height, i;
      struct tui_win_info *win_info;

      wname = buf_ptr;
      buf_ptr = strchr (buf_ptr, ' ');
      if (buf_ptr != (char *) NULL)
	{
	  *buf_ptr = (char) 0;

	  /* Validate the window name.  */
	  for (i = 0; i < strlen (wname); i++)
	    wname[i] = toupper (wname[i]);
	  win_info = tui_partial_win_by_name (wname);

	  if (win_info == (struct tui_win_info *) NULL
	      || !win_info->generic.is_visible)
	    warning (_("Invalid window specified. \n\
The window name specified must be valid and visible.\n"));
	  else
	    {
	      /* Process the size.  */
	      while (*(++buf_ptr) == ' ')
		;

	      if (*buf_ptr != (char) 0)
		{
		  int negate = FALSE;
		  int fixed_size = TRUE;
		  int input_no;;

		  if (*buf_ptr == '+' || *buf_ptr == '-')
		    {
		      if (*buf_ptr == '-')
			negate = TRUE;
		      fixed_size = FALSE;
		      buf_ptr++;
		    }
		  input_no = atoi (buf_ptr);
		  if (input_no > 0)
		    {
		      if (negate)
			input_no *= (-1);
		      if (fixed_size)
			new_height = input_no;
		      else
			new_height = win_info->generic.height + input_no;

		      /* Now change the window's height, and adjust
		         all other windows around it.  */
		      if (tui_adjust_win_heights (win_info,
						new_height) == TUI_FAILURE)
			warning (_("Invalid window height specified.\n%s"),
				 WIN_HEIGHT_USAGE);
		      else
                        tui_update_gdb_sizes ();
		    }
		  else
		    warning (_("Invalid window height specified.\n%s"),
			     WIN_HEIGHT_USAGE);
		}
	    }
	}
      else
	printf_filtered (WIN_HEIGHT_USAGE);

      if (buf != (char *) NULL)
	xfree (buf);
    }
  else
    printf_filtered (WIN_HEIGHT_USAGE);
}

/* Set the height of the specified window, with va_list.  */
static void
tui_set_win_height_command (char *arg, int from_tty)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  tui_set_win_height (arg, from_tty);
}


/* XDB Compatibility command for setting the window height.  This will
   increase or decrease the command window by the specified
   amount.  */
static void
tui_xdb_set_win_height (char *arg, int from_tty)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  if (arg != (char *) NULL)
    {
      int input_no = atoi (arg);

      if (input_no > 0)
	{			/* Add 1 for the locator.  */
	  int new_height = tui_term_height () - (input_no + 1);

	  if (!new_height_ok (tui_win_list[CMD_WIN], new_height)
	      || tui_adjust_win_heights (tui_win_list[CMD_WIN],
					 new_height) == TUI_FAILURE)
	    warning (_("Invalid window height specified.\n%s"),
		     XDBWIN_HEIGHT_USAGE);
	}
      else
	warning (_("Invalid window height specified.\n%s"),
		 XDBWIN_HEIGHT_USAGE);
    }
  else
    warning (_("Invalid window height specified.\n%s"), XDBWIN_HEIGHT_USAGE);
}

/* Set the height of the specified window, with va_list.  */
static void
tui_xdb_set_win_height_command (char *arg, int from_tty)
{
  tui_xdb_set_win_height (arg, from_tty);
}


/* Function to adjust all window heights around the primary.   */
static enum tui_status
tui_adjust_win_heights (struct tui_win_info *primary_win_info,
			int new_height)
{
  enum tui_status status = TUI_FAILURE;

  if (new_height_ok (primary_win_info, new_height))
    {
      status = TUI_SUCCESS;
      if (new_height != primary_win_info->generic.height)
	{
	  int diff;
	  struct tui_win_info *win_info;
	  struct tui_gen_win_info *locator = tui_locator_win_info_ptr ();
	  enum tui_layout_type cur_layout = tui_current_layout ();

	  diff = (new_height - primary_win_info->generic.height) * (-1);
	  if (cur_layout == SRC_COMMAND 
	      || cur_layout == DISASSEM_COMMAND)
	    {
	      struct tui_win_info *src_win_info;

	      make_invisible_and_set_new_height (primary_win_info, new_height);
	      if (primary_win_info->generic.type == CMD_WIN)
		{
		  win_info = (tui_source_windows ())->list[0];
		  src_win_info = win_info;
		}
	      else
		{
		  win_info = tui_win_list[CMD_WIN];
		  src_win_info = primary_win_info;
		}
	      make_invisible_and_set_new_height (win_info,
					     win_info->generic.height + diff);
	      TUI_CMD_WIN->generic.origin.y = locator->origin.y + 1;
	      make_visible_with_new_height (win_info);
	      make_visible_with_new_height (primary_win_info);
	      if (src_win_info->generic.content_size <= 0)
		tui_erase_source_content (src_win_info, EMPTY_SOURCE_PROMPT);
	    }
	  else
	    {
	      struct tui_win_info *first_win;
	      struct tui_win_info *second_win;

	      if (cur_layout == SRC_DISASSEM_COMMAND)
		{
		  first_win = TUI_SRC_WIN;
		  second_win = TUI_DISASM_WIN;
		}
	      else
		{
		  first_win = TUI_DATA_WIN;
		  second_win = (tui_source_windows ())->list[0];
		}
	      if (primary_win_info == TUI_CMD_WIN)
		{ /* Split the change in height accross the 1st & 2nd
		     windows, adjusting them as well.  */
		  /* Subtract the locator.  */
		  int first_split_diff = diff / 2;
		  int second_split_diff = first_split_diff;

		  if (diff % 2)
		    {
		      if (first_win->generic.height >
			  second_win->generic.height)
			if (diff < 0)
			  first_split_diff--;
			else
			  first_split_diff++;
		      else
			{
			  if (diff < 0)
			    second_split_diff--;
			  else
			    second_split_diff++;
			}
		    }
		  /* Make sure that the minimum hieghts are
		     honored.  */
		  while ((first_win->generic.height + first_split_diff) < 3)
		    {
		      first_split_diff++;
		      second_split_diff--;
		    }
		  while ((second_win->generic.height + second_split_diff) < 3)
		    {
		      second_split_diff++;
		      first_split_diff--;
		    }
		  make_invisible_and_set_new_height (
						  first_win,
				 first_win->generic.height + first_split_diff);
		  second_win->generic.origin.y = first_win->generic.height - 1;
		  make_invisible_and_set_new_height (second_win,
						     second_win->generic.height
						     + second_split_diff);
		  TUI_CMD_WIN->generic.origin.y = locator->origin.y + 1;
		  make_invisible_and_set_new_height (TUI_CMD_WIN, new_height);
		}
	      else
		{
		  if ((TUI_CMD_WIN->generic.height + diff) < 1)
		    { /* If there is no way to increase the command
			 window take real estate from the 1st or 2nd
			 window.  */
		      if ((TUI_CMD_WIN->generic.height + diff) < 1)
			{
			  int i;

			  for (i = TUI_CMD_WIN->generic.height + diff;
			       (i < 1); i++)
			    if (primary_win_info == first_win)
			      second_win->generic.height--;
			    else
			      first_win->generic.height--;
			}
		    }
		  if (primary_win_info == first_win)
		    make_invisible_and_set_new_height (first_win, new_height);
		  else
		    make_invisible_and_set_new_height (
						    first_win,
						  first_win->generic.height);
		  second_win->generic.origin.y = first_win->generic.height - 1;
		  if (primary_win_info == second_win)
		    make_invisible_and_set_new_height (second_win, new_height);
		  else
		    make_invisible_and_set_new_height (
				      second_win, second_win->generic.height);
		  TUI_CMD_WIN->generic.origin.y = locator->origin.y + 1;
		  if ((TUI_CMD_WIN->generic.height + diff) < 1)
		    make_invisible_and_set_new_height (TUI_CMD_WIN, 1);
		  else
		    make_invisible_and_set_new_height (TUI_CMD_WIN,
						       TUI_CMD_WIN->generic.height + diff);
		}
	      make_visible_with_new_height (TUI_CMD_WIN);
	      make_visible_with_new_height (second_win);
	      make_visible_with_new_height (first_win);
	      if (first_win->generic.content_size <= 0)
		tui_erase_source_content (first_win, EMPTY_SOURCE_PROMPT);
	      if (second_win->generic.content_size <= 0)
		tui_erase_source_content (second_win, EMPTY_SOURCE_PROMPT);
	    }
	}
    }

  return status;
}


/* Function make the target window (and auxillary windows associated
   with the targer) invisible, and set the new height and
   location.  */
static void
make_invisible_and_set_new_height (struct tui_win_info *win_info, 
				   int height)
{
  int i;
  struct tui_gen_win_info *gen_win_info;

  tui_make_invisible (&win_info->generic);
  win_info->generic.height = height;
  if (height > 1)
    win_info->generic.viewport_height = height - 1;
  else
    win_info->generic.viewport_height = height;
  if (win_info != TUI_CMD_WIN)
    win_info->generic.viewport_height--;

  /* Now deal with the auxillary windows associated with win_info.  */
  switch (win_info->generic.type)
    {
    case SRC_WIN:
    case DISASSEM_WIN:
      gen_win_info = win_info->detail.source_info.execution_info;
      tui_make_invisible (gen_win_info);
      gen_win_info->height = height;
      gen_win_info->origin.y = win_info->generic.origin.y;
      if (height > 1)
	gen_win_info->viewport_height = height - 1;
      else
	gen_win_info->viewport_height = height;
      if (win_info != TUI_CMD_WIN)
	gen_win_info->viewport_height--;

      if (tui_win_has_locator (win_info))
	{
	  gen_win_info = tui_locator_win_info_ptr ();
	  tui_make_invisible (gen_win_info);
	  gen_win_info->origin.y = win_info->generic.origin.y + height;
	}
      break;
    case DATA_WIN:
      /* Delete all data item windows.  */
      for (i = 0; i < win_info->generic.content_size; i++)
	{
	  gen_win_info = (struct tui_gen_win_info *)
	    &((struct tui_win_element *)
	      win_info->generic.content[i])->which_element.data_window;
	  tui_delete_win (gen_win_info->handle);
	  gen_win_info->handle = (WINDOW *) NULL;
	}
      break;
    default:
      break;
    }
}


/* Function to make the windows with new heights visible.  This means
   re-creating the windows' content since the window had to be
   destroyed to be made invisible.  */
static void
make_visible_with_new_height (struct tui_win_info *win_info)
{
  struct symtab *s;

  tui_make_visible (&win_info->generic);
  tui_check_and_display_highlight_if_needed (win_info);
  switch (win_info->generic.type)
    {
    case SRC_WIN:
    case DISASSEM_WIN:
      tui_free_win_content (win_info->detail.source_info.execution_info);
      tui_make_visible (win_info->detail.source_info.execution_info);
      if (win_info->generic.content != NULL)
	{
	  struct gdbarch *gdbarch = win_info->detail.source_info.gdbarch;
	  struct tui_line_or_address line_or_addr;
	  struct symtab_and_line cursal
	    = get_current_source_symtab_and_line ();

	  line_or_addr = win_info->detail.source_info.start_line_or_addr;
	  tui_free_win_content (&win_info->generic);
	  tui_update_source_window (win_info, gdbarch,
				    cursal.symtab, line_or_addr, TRUE);
	}
      else if (deprecated_safe_get_selected_frame () != NULL)
	{
	  struct tui_line_or_address line;
	  struct symtab_and_line cursal
	    = get_current_source_symtab_and_line ();
	  struct frame_info *frame = deprecated_safe_get_selected_frame ();
	  struct gdbarch *gdbarch = get_frame_arch (frame);

	  s = find_pc_symtab (get_frame_pc (frame));
	  if (win_info->generic.type == SRC_WIN)
	    {
	      line.loa = LOA_LINE;
	      line.u.line_no = cursal.line;
	    }
	  else
	    {
	      line.loa = LOA_ADDRESS;
	      find_line_pc (s, cursal.line, &line.u.addr);
	    }
	  tui_update_source_window (win_info, gdbarch, s, line, TRUE);
	}
      if (tui_win_has_locator (win_info))
	{
	  tui_make_visible (tui_locator_win_info_ptr ());
	  tui_show_locator_content ();
	}
      break;
    case DATA_WIN:
      tui_display_all_data ();
      break;
    case CMD_WIN:
      win_info->detail.command_info.cur_line = 0;
      win_info->detail.command_info.curch = 0;
#ifdef HAVE_WRESIZE
      wresize (TUI_CMD_WIN->generic.handle,
	       TUI_CMD_WIN->generic.height,
	       TUI_CMD_WIN->generic.width);
#endif
      mvwin (TUI_CMD_WIN->generic.handle,
	     TUI_CMD_WIN->generic.origin.y,
	     TUI_CMD_WIN->generic.origin.x);
      wmove (win_info->generic.handle,
	     win_info->detail.command_info.cur_line,
	     win_info->detail.command_info.curch);
      break;
    default:
      break;
    }
}


static int
new_height_ok (struct tui_win_info *primary_win_info, 
	       int new_height)
{
  int ok = (new_height < tui_term_height ());

  if (ok)
    {
      int diff;
      enum tui_layout_type cur_layout = tui_current_layout ();

      diff = (new_height - primary_win_info->generic.height) * (-1);
      if (cur_layout == SRC_COMMAND || cur_layout == DISASSEM_COMMAND)
	{
	  ok = ((primary_win_info->generic.type == CMD_WIN 
		 && new_height <= (tui_term_height () - 4) 
		 && new_height >= MIN_CMD_WIN_HEIGHT) 
		|| (primary_win_info->generic.type != CMD_WIN 
		    && new_height <= (tui_term_height () - 2) 
		    && new_height >= MIN_WIN_HEIGHT));
	  if (ok)
	    {			/* Check the total height.  */
	      struct tui_win_info *win_info;

	      if (primary_win_info == TUI_CMD_WIN)
		win_info = (tui_source_windows ())->list[0];
	      else
		win_info = TUI_CMD_WIN;
	      ok = ((new_height +
		     (win_info->generic.height + diff)) <= tui_term_height ());
	    }
	}
      else
	{
	  int cur_total_height, total_height, min_height = 0;
	  struct tui_win_info *first_win;
	  struct tui_win_info *second_win;

	  if (cur_layout == SRC_DISASSEM_COMMAND)
	    {
	      first_win = TUI_SRC_WIN;
	      second_win = TUI_DISASM_WIN;
	    }
	  else
	    {
	      first_win = TUI_DATA_WIN;
	      second_win = (tui_source_windows ())->list[0];
	    }
	  /* We could simply add all the heights to obtain the same
	     result but below is more explicit since we subtract 1 for
	     the line that the first and second windows share, and add
	     one for the locator.  */
	  total_height = cur_total_height =
	    (first_win->generic.height + second_win->generic.height - 1)
	    + TUI_CMD_WIN->generic.height + 1;	/* Locator. */
	  if (primary_win_info == TUI_CMD_WIN)
	    {
	      /* Locator included since first & second win share a line.  */
	      ok = ((first_win->generic.height +
		     second_win->generic.height + diff) >=
		    (MIN_WIN_HEIGHT * 2) 
		    && new_height >= MIN_CMD_WIN_HEIGHT);
	      if (ok)
		{
		  total_height = new_height + 
		    (first_win->generic.height +
		     second_win->generic.height + diff);
		  min_height = MIN_CMD_WIN_HEIGHT;
		}
	    }
	  else
	    {
	      min_height = MIN_WIN_HEIGHT;

	      /* First see if we can increase/decrease the command
	         window.  And make sure that the command window is at
	         least 1 line.  */
	      ok = ((TUI_CMD_WIN->generic.height + diff) > 0);
	      if (!ok)
		{ /* Looks like we have to increase/decrease one of
		     the other windows.  */
		  if (primary_win_info == first_win)
		    ok = (second_win->generic.height + diff) >= min_height;
		  else
		    ok = (first_win->generic.height + diff) >= min_height;
		}
	      if (ok)
		{
		  if (primary_win_info == first_win)
		    total_height = new_height +
		      second_win->generic.height +
		      TUI_CMD_WIN->generic.height + diff;
		  else
		    total_height = new_height +
		      first_win->generic.height +
		      TUI_CMD_WIN->generic.height + diff;
		}
	    }
	  /* Now make sure that the proposed total height doesn't
	     exceed the old total height.  */
	  if (ok)
	    ok = (new_height >= min_height 
		  && total_height <= cur_total_height);
	}
    }

  return ok;
}


static void
parse_scrolling_args (char *arg, 
		      struct tui_win_info **win_to_scroll,
		      int *num_to_scroll)
{
  if (num_to_scroll)
    *num_to_scroll = 0;
  *win_to_scroll = tui_win_with_focus ();

  /* First set up the default window to scroll, in case there is no
     window name arg.  */
  if (arg != (char *) NULL)
    {
      char *buf, *buf_ptr;

      /* Process the number of lines to scroll.  */
      buf = buf_ptr = xstrdup (arg);
      if (isdigit (*buf_ptr))
	{
	  char *num_str;

	  num_str = buf_ptr;
	  buf_ptr = strchr (buf_ptr, ' ');
	  if (buf_ptr != (char *) NULL)
	    {
	      *buf_ptr = (char) 0;
	      if (num_to_scroll)
		*num_to_scroll = atoi (num_str);
	      buf_ptr++;
	    }
	  else if (num_to_scroll)
	    *num_to_scroll = atoi (num_str);
	}

      /* Process the window name if one is specified.  */
      if (buf_ptr != (char *) NULL)
	{
	  char *wname;
	  int i;

	  if (*buf_ptr == ' ')
	    while (*(++buf_ptr) == ' ')
	      ;

	  if (*buf_ptr != (char) 0)
	    {
	      wname = buf_ptr;

	      /* Validate the window name.  */
	      for (i = 0; i < strlen (wname); i++)
		wname[i] = toupper (wname[i]);
	    }
	  else
	    wname = "?";
	  
	  *win_to_scroll = tui_partial_win_by_name (wname);

	  if (*win_to_scroll == (struct tui_win_info *) NULL
	      || !(*win_to_scroll)->generic.is_visible)
	    error (_("Invalid window specified. \n\
The window name specified must be valid and visible.\n"));
	  else if (*win_to_scroll == TUI_CMD_WIN)
	    *win_to_scroll = (tui_source_windows ())->list[0];
	}
      xfree (buf);
    }
}
@


1.59
log
@	ARI fixes: sprintf rule.
	Replace sprintf function calls for char arrays by
	calls to xsnprintf calls.
	* arm-tdep.c (arm_push_dummy_call): Replace sprintf by xsnprintf.
	(arm_dwarf_reg_to_regnum, arm_return_value): Ditto.
	(arm_neon_quad_read, arm_pseudo_read): Ditto.
	(arm_neon_quad_write, arm_pseudo_write): Ditto.
	* breakpoint.c (condition_completer): Ditto.
	(create_tracepoint_from_upload): Ditto.
	* dwarf2read.c (file_full_name): Ditto.
	* gcore.c (gcore_command): Ditto.
	* gnu-nat.c (proc_string, gnu_pid_to_str): Ditto.
	* go32-nat.c (go32_sysinfo): Ditto.
	* interps.c (interp_set): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	* ppc-linux-nat.c (fetch_register, store_register): Ditto.
	* remote-m32r-sdi.c (m32r_open): Ditto.
	* sol-thread.c (td_err_string): Ditto.
	(td_state_string, solaris_pid_to_str): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	* cli/cli-script.c (execute_control_command): Ditto.
	(define_command, document_command): Ditto.
	* tui/tui-io.c (tui_rl_display_match_list): Ditto.
	* tui/tui-stack.c (tui_make_status_line): Ditto.
	* tui/tui-win.c (tui_update_gdb_sizes): Ditto.
@
text
@d3 1
a3 1
   Copyright (C) 1998-2004, 2006-2012 Free Software Foundation, Inc.
@


1.58
log
@2012-03-16  Chris January  <chris.january@@allinea.com>

	* tui-tui.win.c (tui_resize_all): Use erase and clearok instead
	of clear.
@
text
@d469 1
a469 1
  sprintf (cmd, "set width %d",
d472 1
a472 1
  sprintf (cmd, "set height %d",
@


1.57
log
@	PR gdb/13405:
	* tui/tui-win.c (parse_scrolling_args): Don't write to possibly
	read-only memory.
@
text
@d693 2
a694 2
	    cmd_split_diff++;
	}
d696 4
a699 1
      clear ();
d702 1
a702 1
	{
@


1.56
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@d1586 7
a1592 1
	    wname = buf_ptr;
a1595 3
	  /* Validate the window name.  */
	  for (i = 0; i < strlen (wname); i++)
	    wname[i] = toupper (wname[i]);
@


1.55
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d110 1
a110 1
static const char *tui_border_kind_enums[] = {
d118 1
a118 1
static const char *tui_border_mode_enums[] = {
@


1.54
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d3 1
a3 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007, 2008,
   2009, 2010, 2011 Free Software Foundation, Inc.
@


1.54.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1998-2004, 2006-2012 Free Software Foundation, Inc.
@


1.53
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-cmds.c: Shorten lines of >= 80 columns.
	* cli/cli-decode.c: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-setshow.c: Ditto.
	* common/signals.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-disas.c: Ditto.
	* mi/mi-cmd-stack.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-cmds.c: Ditto.
	* mi/mi-common.h: Ditto.
	* mi/mi-console.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
	* osf-share/cma_attr.c: Ditto.
	* osf-share/cma_deb_core.h: Ditto.
	* osf-share/cma_debug_client.h: Ditto.
	* osf-share/cma_handle.h: Ditto.
	* osf-share/cma_mutex.h: Ditto.
	* osf-share/cma_stack_int.h: Ditto.
	* osf-share/cma_tcb_defs.h: Ditto.
	* python/py-auto-load.c: Ditto.
	* python/py-breakpoint.c: Ditto.
	* python/py-cmd.c: Ditto.
	* python/py-frame.c: Ditto.
	* python/py-objfile.c: Ditto.
	* python/py-param.c: Ditto.
	* python/py-progspace.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-value.c: Ditto.
	* python/python-internal.h: Ditto.
	* python/python.c: Ditto.
	* tui/tui-data.c: Ditto.
	* tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c: Ditto.
	* tui/tui-io.c: Ditto.
	* tui/tui-layout.c: Ditto.
	* tui/tui-regs.c: Ditto.
	* tui/tui-source.c: Ditto.
	* tui/tui-stack.c: Ditto.
	* tui/tui-win.c: Ditto.
	* tui/tui-windata.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d653 2
a654 2
/* Resize all the windows based on the the terminal size.  This
   function gets called from within the readline sinwinch handler.  */
@


1.52
log
@run copyright.sh for 2011.
@
text
@d565 2
a566 1
	tui_horizontal_source_scroll (win_to_scroll, LEFT_SCROLL, _num_to_scroll);
d588 2
a589 1
	tui_horizontal_source_scroll (win_to_scroll, RIGHT_SCROLL, _num_to_scroll);
d740 2
a741 1
	      second_win = (struct tui_win_info *) (tui_source_windows ())->list[0];
d783 3
a785 2
	  make_invisible_and_set_new_height (
			     TUI_CMD_WIN, TUI_CMD_WIN->generic.height + cmd_split_diff);
d942 2
a943 1
		       tui_win_name ((struct tui_gen_win_info *) tui_win_with_focus ()));
d1236 3
a1238 2
		  make_invisible_and_set_new_height (
		    second_win, second_win->generic.height + second_split_diff);
d1276 2
a1277 2
		    make_invisible_and_set_new_height (
				     TUI_CMD_WIN, TUI_CMD_WIN->generic.height + diff);
d1340 3
a1342 2
	  gen_win_info = (struct tui_gen_win_info *) & ((struct tui_win_element *)
		      win_info->generic.content[i])->which_element.data_window;
d1384 2
a1385 1
	  struct symtab_and_line cursal = get_current_source_symtab_and_line ();
@


1.51
log
@2010-07-28  Pedro Alves  <pedro@@codesourcery.com>

	PR build/11848
	* configure.ac: Check for wresize.
	* configure, config.in: Regenerate.
	* tui/tui-win.c (make_visible_with_new_height): Wrap wresize call
	with HAVE_WRESIZE.
@
text
@d4 1
a4 1
   2009, 2010 Free Software Foundation, Inc.
@


1.50
log
@2010-07-28  Balazs Kezes  <rlblaster@@gmail.com>

	* tui/tui-win.c (make_visible_with_new_height): Resize and move
	the command window to the new size and position.
@
text
@d1406 1
d1410 1
@


1.49
log
@        * tui/tui-win.c (tui_resize_all): Update the locator's origin's
	coordinates.
@
text
@d1406 6
@


1.48
log
@2010-07-28  Balazs Kezes  <rlblaster@@gmail.com>

        * tui/tui-io.c (tui_handle_resize_during_io): Call tui_resize_all
	after a detecting a resize.
        * tui/tui-win.c (tui_resize_all): Remove tui_set_win_resized_to
	call.
@
text
@d715 1
@


1.47
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* tui/tui.c: White space.
	* tui/tui-data.c: White space.
	* tui/tui-disasm.c: White space.
	* tui/tui-file.c: White space.
	* tui/tui-interp.c: White space.
	* tui/tui-main.c: White space.
	* tui/tui-out.c: White space.
	* tui/tui-regs.c: White space.
	* tui/tui-source.c: White space.
	* tui/tui-stack.c: White space.
	* tui/tui-win.c: White space.
	* tui/tui-winsource.c: White space.
@
text
@a801 1
      tui_set_win_resized_to (TRUE);
@


1.46
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* tui/tui-interp.c (_initialize_tui_interp):
	Delete unused variable.
	* tui/tui-regs.c tui_display_registers_from):
	Delete unused variable.
	(tui_check_register_values): Delete unused variable.
	(tui_register_format): Delete unused variable.
	* tui/tui-win.c (_initialize_tui_win): Delete unused variable.
	* tui/tui-windata.c (tui_display_data_from_line):
	Delete unused variables.
	(tui_vertical_data_scroll): Delete unused variables.
@
text
@d830 1
d1245 1
@


1.45
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a358 1
  struct cmd_list_element *c;
@


1.44
log
@	* disasm.h (gdb_disassembly): Add GDBARCH parameter.
	(gdb_print_insn): Likewise.
	* disasm.c (dump_insns): Add GDBARCH parameter.  Use it instead
	of current_gdbarch.
	(do_mixed_source_and_assembly): Add GDBARCH parameter.  Pass to
	dump_insns.
	(do_assembly_only): Likewise.
	(gdb_disassembly): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.  Pass to subroutines.
	(gdb_print_insn): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.

	* stack.c (struct gdb_disassembly_stub_args): Add GDBARCH member.
	(gdb_disassembly_stub): Pass architecture to gdb_disassembly.
	(do_gdb_disassembly): Add GDBARCH argument.  Store into args.
	(print_frame_info): Pass architecture to do_gdb_disassembly.

	* printcmd.c (print_formatted): Pass architecture to gdb_print_insn.

	* mi/mi-cmd-disas.c: Include "arch-utils.h"
	(mi_cmd_disassemble): Pass architecture to gdb_disassembly.

	* cli/cli-cmds.c: Include "arch-utils.h".
	(print_disassembly): Add GDBARCH parameter.  Pass to gdb_disassembly
	and tui_show_assembly.
	(disassemble_current_function): Pass architecture to
	tui_get_low_disassembly_address and print_disassembly.
	(disassemble_command): Pass architecture to
	tui_get_low_disassembly_address and print_disassembly.

	* tui/tui.c (tui_show_assembly): Add GDBARCH parameter.  Pass to
	tui_update_source_windows_with_addr.

	* tui/tui-data.h (struct tui_locator_element): Add GDBARCH member.
	(struct tui_source_info): Likewise.
	* tui/tui-data.c (tui_clear_win_detail): Clear source_info.gdbarch.

	* tui/tui-disasm.c (tui_disassemble): Add GDBARCH parameter.
	Pass to gdb_print_insn.
	(tui_find_disassembly_address): Add GDBARCH parameter.  Pass to
	tui_disassemble.
	(tui_set_disassem_content): Add GDBARCH parameter.  Install into
	source_info.gdbarch.  Pass to tui_disassemble.
	(tui_show_disassem): Add GDBARCH parameter.  Pass to
	tui_update_source_window.
	(tui_show_disassem_and_update_source): Add GDBARCH parameter.  Pass to
	tui_show_disassem and tui_update_source_window.

	(tui_get_begin_asm_address): Return locator architecture in addition
	to locator PC value.

	(tui_get_low_disassembly_address): Add GDBARCH parameter.   Pass to
	tui_get_low_disassembly_address.

	(tui_vertical_disassem_scroll): Pass architecture to subroutines.

	* tui/tui-disasm.h (tui_set_disassem_content): Add GDBARCH parameter.
	(tui_show_disassem): Likewise.
	(tui_show_disassem_and_update_source): Likewise.
	(tui_get_begin_asm_address): Return architecture and PC value.

	* tui/tui.h (tui_get_low_disassembly_address): Add GDBARCH parameter.
	(tui_show_assembly): Add GDBARCH parameter.

	* tui/tui-layout.c (extract_display_start_addr): Return current window
	architecture in addition to current PC value.

	(tui_set_layout): Update calls to tui_get_low_disassembly_address and
	extract_display_start_addr.  Pass architecture to
	tui_update_source_windows_with_addr.

	* tui/tui-source.c: Include "objfiles.h".
	(tui_set_source_content): Initialize window architecture.
	(tui_show_symtab_source): Add GDBARCH parameter.  Pass to
	tui_update_source_window_as_is

	* tui/tui-source.h (tui_show_symtab_source): Add GDBARCH parameter.

	* tui/tui-stack.c (tui_set_locator_info): Add GDBARCH parameter.
	Install locator architecture.
	(tui_set_locator_filename): Update call.
	(tui_show_frame_info): Pass architecture to tui_set_locator_info
	and subroutines.

	* tui/tui-win.c (make_visible_with_new_height): Pass architecture
	to tui_update_source_window.

	* tui/tui-winsource.c: Include "objfiles.h".
	(tui_display_main): Update call to tui_get_begin_asm_address.
	Pass architecture to tui_update_source_windows_with_addr.
	(tui_update_source_window): Add GDBARCH parameter.  Pass to
	tui_update_source_window_as_is.
	(tui_update_source_window_as_is): Add GDBARCH parameter.
	Pass to tui_set_disassem_content.
	(tui_update_source_windows_with_addr): Add GDBARCH parameter.
	Pass to subroutines.
	(tui_update_source_windows_with_line): Pass objfile architecture
	to subroutines.
	(tui_horizontal_source_scroll): Pass architecture to
	tui_update_source_window_as_is.

	* tui/tui-winsource.h (tui_update_source_window): Add GDBARCH
	parameter.
	(tui_update_source_window_as_is): Likewise.
	(tui_update_source_windows_with_addr): Likewise.
@
text
@d4 1
a4 1
   2009 Free Software Foundation, Inc.
@


1.43
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d1363 1
d1370 2
a1371 1
	  tui_update_source_window (win_info, cursal.symtab, line_or_addr, TRUE);
d1378 1
d1391 1
a1391 1
	  tui_update_source_window (win_info, s, line, TRUE);
@


1.42
log
@        Updated copyright notices for most files.
@
text
@d46 1
d352 4
d811 1
a811 1

d815 1
a815 1
void
d822 1
@


1.41
log
@	Updated copyright notices for most files.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007, 2008
   Free Software Foundation, Inc.
@


1.41.10.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@d387 1
a387 1
  add_com ("ffocus", class_tui, tui_set_focus_command, _("\
@


1.40
log
@2007-10-02  Carlos Eduardo Seo  <cseo@@linux.vnet.ibm.com>

	* tui/tui-interp.c (tui_init): Initialize tui's SIGWINCH
	signal handler.
	* tui/tui-win.c (tui_initialize_win): New function for
	initializing tui's SIGWINCH signal handler.
	* tui/tui-win.h (tui_initialize_win): Declare.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007
@


1.39
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d53 2
d818 15
@


1.38
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-disasm.c, tui-file.c, tui-io.c,
	tui-layout.c, tui-regs.c, tui-source.c, tui-win.c, tui-windata.c,
	tui-wingeneral.c, tui-winsource.c: Coding standard, && and ||
	go at beginning of new line.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.37
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-data.c, tui-data.h, tui-disasm.c, tui-disasm.h, tui-hooks.c,
	tui-io.c, tui-layout.c, tui-layout.h, tui-out.c, tui-regs.c,
	tui-source.c, tui-source.h, tui-stack.c, tui-win.c, tui-win.h,
	tui-windata.c, tui-windata.h, tui-wingeneral.c, tui-winsource.c,
	tui-winsource.h, tui.c, tui.h: Function declarations and
	definitions, wrap long lines.
@
text
@d559 2
a560 1
      if (win_to_scroll == TUI_SRC_WIN || win_to_scroll == TUI_DISASM_WIN)
d581 2
a582 1
      if (win_to_scroll == TUI_SRC_WIN || win_to_scroll == TUI_DISASM_WIN)
d623 2
a624 1
      if (tui_win_list[type] && tui_win_list[type]->generic.is_visible)
d677 3
a679 2
      if (cur_layout == SRC_DISASSEM_COMMAND ||
	cur_layout == SRC_DATA_COMMAND || cur_layout == DISASSEM_DATA_COMMAND)
d790 2
a791 1
	  if (win_type != CMD_WIN && (tui_win_list[win_type] != NULL)
d903 2
a904 1
      if (win_info == (struct tui_win_info *) NULL || !win_info->generic.is_visible)
d939 2
a940 1
    if (tui_win_list[type] && tui_win_list[type]->generic.is_visible)
d1008 2
a1009 1
	  if (win_info == (struct tui_win_info *) NULL || !win_info->generic.is_visible)
d1092 3
a1094 3
	  if (!new_height_ok (tui_win_list[CMD_WIN], new_height) ||
	      tui_adjust_win_heights (tui_win_list[CMD_WIN],
				    new_height) == TUI_FAILURE)
d1132 2
a1133 1
	  if (cur_layout == SRC_COMMAND || cur_layout == DISASSEM_COMMAND)
d1405 6
a1410 6
	  ok = ((primary_win_info->generic.type == CMD_WIN &&
		 new_height <= (tui_term_height () - 4) &&
		 new_height >= MIN_CMD_WIN_HEIGHT) ||
		(primary_win_info->generic.type != CMD_WIN &&
		 new_height <= (tui_term_height () - 2) &&
		 new_height >= MIN_WIN_HEIGHT));
d1451 2
a1452 2
		    (MIN_WIN_HEIGHT * 2) &&
		    new_height >= MIN_CMD_WIN_HEIGHT);
d1455 3
a1457 2
		  total_height = new_height + (first_win->generic.height +
					  second_win->generic.height + diff);
d1492 2
a1493 1
	    ok = (new_height >= min_height && total_height <= cur_total_height);
d1555 2
a1556 2
	  if (*win_to_scroll == (struct tui_win_info *) NULL ||
	      !(*win_to_scroll)->generic.is_visible)
@


1.36
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-disasm.c, tui-layout.c,
	tui-regs.c, tui-win.c, tui-windata.c, tui-winsource.c, tui.c:
	Reformat block comments to GNU standard.
@
text
@d59 4
a62 2
static void make_invisible_and_set_new_height (struct tui_win_info *, int);
static enum tui_status tui_adjust_win_heights (struct tui_win_info *, int);
d74 3
a76 1
static void parse_scrolling_args (char *, struct tui_win_info **, int *);
d82 3
a84 3
#define WIN_HEIGHT_USAGE      "Usage: winheight <win_name> [+ | -] <#lines>\n"
#define XDBWIN_HEIGHT_USAGE   "Usage: w <#lines>\n"
#define FOCUS_USAGE           "Usage: focus {<win> | next | prev}\n"
d206 4
a209 2
show_tui_active_border_mode (struct ui_file *file, int from_tty,
			     struct cmd_list_element *c, const char *value)
d218 4
a221 2
show_tui_border_mode (struct ui_file *file, int from_tty,
		      struct cmd_list_element *c, const char *value)
d230 4
a233 2
show_tui_border_kind (struct ui_file *file, int from_tty,
		      struct cmd_list_element *c, const char *value)
d349 2
a350 1
/* Function to initialize gdb commands, for tui window manipulation.  */
d494 2
a495 1
tui_scroll_forward (struct tui_win_info *win_to_scroll, int num_to_scroll)
d519 2
a520 1
tui_scroll_backward (struct tui_win_info *win_to_scroll, int num_to_scroll)
d545 2
a546 1
tui_scroll_left (struct tui_win_info *win_to_scroll, int num_to_scroll)
d566 2
a567 1
tui_scroll_right (struct tui_win_info *win_to_scroll, int num_to_scroll)
d1108 2
a1109 1
tui_adjust_win_heights (struct tui_win_info *primary_win_info, int new_height)
d1261 2
a1262 1
make_invisible_and_set_new_height (struct tui_win_info *win_info, int height)
d1383 2
a1384 1
new_height_ok (struct tui_win_info *primary_win_info, int new_height)
d1491 2
a1492 1
parse_scrolling_args (char *arg, struct tui_win_info **win_to_scroll,
@


1.35
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-data.h, tui-disasm.c, tui-file.c,
	tui-hooks.c, tui-interp.c, tui-io.c, tui-layout.c, tui-out.c,
	tui-regs.c, tui-regs.h, tui-source.c, tui-stack.c, tui-win.c,
	tui-windata.c, tui-wingeneral.c, tui-winsource.c, tui-winsource.h,
	tui.c, tui.h: Comment reformatting to coding standard (capitals,
	spaces after periods, etc).
@
text
@d491 6
a496 6
      /*
         ** If we are scrolling the source or disassembly window, do a
         ** "psuedo" scroll since not all of the source is in memory,
         ** only what is in the viewport.  If win_to_scroll is the
         ** command window do nothing since the term should handle it.
       */
d515 6
a520 6
      /*
         ** If we are scrolling the source or disassembly window, do a
         ** "psuedo" scroll since not all of the source is in memory,
         ** only what is in the viewport.  If win_to_scroll is the
         ** command window do nothing since the term should handle it.
       */
d540 5
a544 6
      /*
         ** If we are scrolling the source or disassembly window, do a
         ** "psuedo" scroll since not all of the source is in memory,
         ** only what is in the viewport. If win_to_scroll is the
         ** command window do nothing since the term should handle it.
       */
d560 5
a564 6
      /*
         ** If we are scrolling the source or disassembly window, do a
         ** "psuedo" scroll since not all of the source is in memory,
         ** only what is in the viewport. If win_to_scroll is the
         ** command window do nothing since the term should handle it.
       */
d767 2
a768 4
      /*
         ** Now remove all invisible windows, and their content so that
         ** they get created again when called for with the new size.
       */
d793 2
a794 4
  /*
     ** Say that a resize was done so that the readline can do it
     ** later when appropriate.
   */
d981 1
a981 3
	  /*
	     ** Validate the window name.
	   */
d1017 3
a1019 4
		      /*
		         ** Now change the window's height, and adjust all
		         ** other windows around it.
		       */
d1147 4
a1150 5
		{ /*
		   ** Split the change in height accross the 1st & 2nd
		   ** windows, adjusting them as well.
		   */
		  int first_split_diff = diff / 2;	/* Subtract the locator.  */
d1193 3
a1195 4
		    { /*
			** If there is no way to increase the command window
			** take real estate from the 1st or 2nd window.
		       */
d1412 4
a1415 6
	  /*
	     ** We could simply add all the heights to obtain the same result
	     ** but below is more explicit since we subtract 1 for the
	     ** line that the first and second windows share, and add one
	     ** for the locator.
	   */
d1436 4
a1439 5
	      /*
	         ** First see if we can increase/decrease the command
	         ** window.  And make sure that the command window is
	         ** at least 1 line.
	       */
d1442 2
a1443 4
		{	/*
			   ** Looks like we have to increase/decrease one of
			   ** the other windows.
			 */
d1461 2
a1462 4
	  /*
	     ** Now make sure that the proposed total height doesn't exceed
	     ** the old total height.
	   */
d1480 2
a1481 4
  /*
     ** First set up the default window to scroll, in case there is no
     ** window name arg.
   */
@


1.34
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-data.c, tui-data.h, tui-disasm.c, tui-hooks.c, tui-layout.c,
	tui-regs.c, tui-source.c, tui-stack.c, tui-win.c, tui-windata.c,
	tui-wingeneral.c, tui-wingeneral.h, tui-winsource.c, tui.c,
	tui-winsource.h: Whitespace changes, fix pointer declarations
	to be consistant.
@
text
@d230 2
a231 2
/* Tui internal configuration variables.  These variables are
   updated by tui_update_variables to reflect the tui configuration
d352 1
a352 1
		  0/*allow-unknown*/, &setlist);
d356 1
a356 1
		  0/*allow-unknown*/, &showlist);
d464 1
a464 1
/* Set the logical focus to win_info.    */
d573 1
a573 1
/* Scroll a window.  Arguments are passed through a va_list.    */
d655 1
a655 1
      /* turn keypad off while we resize */
d673 1
a673 1
      /* now adjust each window */
d683 1
a683 1
	  /* check for invalid heights */
d719 2
a720 2
	  /* Change the first window's height/width */
	  /* check for invalid heights */
d735 2
a736 2
	  /* Change the second window's height/width */
	  /* check for invalid heights */
d756 1
a756 1
	  /* Change the command window's height/width */
d770 2
a771 2
         ** Now remove all invisible windows, and their content so that they get
         ** created again when called for with the new size
d783 2
a784 1
      /* turn keypad back on, unless focus is in the command window */
d948 1
a948 1
/* Set the height of the specified window.   */
d967 1
a967 1
/* Set the height of the specified window.   */
d988 1
a988 1
	     ** Validate the window name
d999 1
a999 1
	      /* Process the size */
d1027 1
a1027 1
		         ** other windows around it
d1052 1
a1052 1
/* Set the height of the specified window, with va_list.    */
d1063 2
a1064 1
   increase or decrease the command window by the specified amount.  */
d1075 1
a1075 1
	{			/* Add 1 for the locator */
d1156 5
a1160 5
		{		/*
				   ** Split the change in height accross the 1st & 2nd windows
				   ** adjusting them as well.
				 */
		  int first_split_diff = diff / 2;	/* subtract the locator */
d1179 2
a1180 1
		  /* make sure that the minimum hieghts are honored */
d1203 4
a1206 4
		    {		/*
				   ** If there is no way to increase the command window
				   ** take real estate from the 1st or 2nd window.
				 */
d1253 2
a1254 1
   with the targer) invisible, and set the new height and location.  */
d1270 1
a1270 1
  /* Now deal with the auxillary windows associated with win_info */
d1294 1
a1294 1
      /* delete all data item windows */
d1396 1
a1396 1
	    {			/* check the total height */
d1431 1
a1431 1
	    + TUI_CMD_WIN->generic.height + 1 /*locator */ ;
d1434 1
a1434 1
	      /* locator included since first & second win share a line */
d1452 1
a1452 1
	         ** at least 1 line
d1456 4
a1459 4
		{		/*
				   ** Looks like we have to increase/decrease one of
				   ** the other windows
				 */
d1500 1
a1500 1
     ** window name arg
d1506 1
a1506 1
      /* process the number of lines to scroll */
d1525 1
a1525 1
      /* process the window name if one is specified */
d1540 1
a1540 1
	  /* Validate the window name */
@


1.33
log
@	* frame.c (deprecated_selected_frame): Rename to...
	(selected_frame): ...this.  Make static.
	(get_selected_frame, select_frame): Update.
	* frame.h (deprected_select_frame): Delete.
	(deprecated_safe_get_selected_frame): Update comments.

	* breakpoint.c, cli/cli-cmds.c, f-valprint.c, infcmd.c, inflow.c,
	infrun.c, stack.c, tui/tui-disasm.c, tui/tui-source.c,
	tui/tui-winsource.c, valops.c, varobj.c, findvar.c, macroscope.c,
	parse.c, regcache.h, sh64-tdep.c, tui/tui-hooks.c, tui/tui-win.c,
	tui/tui.c: Replace references to deprecated_selected_frame.
@
text
@d72 1
a72 1
static void parse_scrolling_args (char *, struct tui_win_info * *, int *);
d466 1
a466 1
tui_set_win_focus_to (struct tui_win_info * win_info)
d470 1
a470 1
      struct tui_win_info * win_with_focus = tui_win_with_focus ();
d483 1
a483 1
tui_scroll_forward (struct tui_win_info * win_to_scroll, int num_to_scroll)
d507 1
a507 1
tui_scroll_backward (struct tui_win_info * win_to_scroll, int num_to_scroll)
d532 1
a532 1
tui_scroll_left (struct tui_win_info * win_to_scroll, int num_to_scroll)
d553 1
a553 1
tui_scroll_right (struct tui_win_info * win_to_scroll, int num_to_scroll)
d576 1
a576 1
	    struct tui_win_info * win_to_scroll,
d645 1
a645 1
      struct tui_win_info * win_with_focus = tui_win_with_focus ();
d648 1
a648 1
      struct tui_gen_win_info * locator = tui_locator_win_info_ptr ();
d814 1
a814 1
  struct tui_win_info * win_to_scroll;
d830 1
a830 1
  struct tui_win_info * win_to_scroll;
d846 1
a846 1
  struct tui_win_info * win_to_scroll;
d859 1
a859 1
  struct tui_win_info * win_to_scroll;
d876 1
a876 1
      struct tui_win_info * win_info = (struct tui_win_info *) NULL;
d920 1
a920 1
  struct tui_win_info * win_with_focus = tui_win_with_focus ();
d978 1
a978 1
      struct tui_win_info * win_info;
d1100 1
a1100 1
tui_adjust_win_heights (struct tui_win_info * primary_win_info, int new_height)
d1110 2
a1111 2
	  struct tui_win_info * win_info;
	  struct tui_gen_win_info * locator = tui_locator_win_info_ptr ();
d1117 1
a1117 1
	      struct tui_win_info * src_win_info;
d1252 1
a1252 1
make_invisible_and_set_new_height (struct tui_win_info * win_info, int height)
d1255 1
a1255 1
  struct tui_gen_win_info * gen_win_info;
d1309 1
a1309 1
make_visible_with_new_height (struct tui_win_info * win_info)
d1373 1
a1373 1
new_height_ok (struct tui_win_info * primary_win_info, int new_height)
d1393 1
a1393 1
	      struct tui_win_info * win_info;
d1487 1
a1487 1
parse_scrolling_args (char *arg, struct tui_win_info * * win_to_scroll,
@


1.32
log
@Copyright updates for 2007.
@
text
@d1331 1
a1331 1
      else if (deprecated_selected_frame != (struct frame_info *) NULL)
d1335 1
d1337 1
a1337 2

	  s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
@


1.31
log
@Update copyright notice
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006
@


1.30
log
@* doublest.h (DOUBLEST): Use long double only if we can scan
it in.  Undefine HAVE_LONG_DOUBLE otherwise.
(DOUBLEST_FORMAT): New.
* c-exp.y (parse_number): Use it.
* jv-exp.y (parse_number): Likewise.
* objc-exp.y (parse_number): Likewise.
* p-exp.y (parse_number): Likewise.
* varobj.c (free_variable): Silence type-punning warnings.
* tui/tui-data.h (struct tui_list): Change type of list member.
* tui/tui-data.c: Remove no-longer-needed type casts.
(source_windows): Silence type-punning warnings.
* tui/tui-stack.c, tui/tui-win.c, tui/tui-winsource.c: Likewise.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
@


1.29
log
@	* tui/tui-file.c:
	* tui/tui-disasm.c:
	* tui/tui-data.h:
	* tui/tui-data.c:
	* tui/tui-command.h:
	* tui/tui-command.c:
	* tui/tui-win.h:
	* tui/tui-win.h:
	* tui/tui-win.c:
	* tui/tui-stack.h:
	* tui/tui-stack.c:
	* tui/tui-source.h:
	* tui/tui-source.c:
	* tui/tui-regs.h:
	* tui/tui-regs.c:
	* tui/tui-out.c:
	* tui/tui-main.c:
	* tui/tui-layout.h:
	* tui/tui-layout.c:
	* tui/tui-io.h:
	* tui/tui-io.c:
	* tui/tui-interp.c:
	* tui/tui-hooks.h:
	* tui/tui-hooks.c:
	* tui/tui-file.h:
	* tui/tui.h:
	* tui/tui.c:
	* tui/tui-winsource.h:
	* tui/tui-winsource.c:
	* tui/tui-wingeneral.h:
	* tui/tui-wingeneral.c:
	* tui/tui-windata.h:
	* tui/tui-windata.c: Add (C) after Copyright.  Update the FSF
	address.
@
text
@d1122 1
a1122 1
		  win_info = (struct tui_win_info *) (tui_source_windows ())->list[0];
d1151 1
a1151 1
		  second_win = (struct tui_win_info *) (tui_source_windows ())->list[0];
d1396 1
a1396 1
		win_info = (struct tui_win_info *) (tui_source_windows ())->list[0];
d1417 1
a1417 1
	      second_win = (struct tui_win_info *) (tui_source_windows ())->list[0];
d1546 1
a1546 1
	    *win_to_scroll = (struct tui_win_info *) (tui_source_windows ())->list[0];
@


1.28
log
@	* tui/tui-win.c (tui_update_gdb_sizes): Use tui_term_width() and
	tui_term_height() to restore the terminal size when leaving the
	TUI mode.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.27
log
@2005-11-01  Andrew Stubbs  <andrew.stubbs@@st.com>

	* tui/tui-data.h (tui_line_or_address): Encapsulate the union in a
	struct with a tag.
	(tui_source_element, tui_source_info): Update.
	* tui/tui-disasm.c, tui/tui-source.c: Update to use the tagged union.
	* tui/tui-source.h, tui/tui-stack.c, tui/tui-win.c: Likewise.
	* tui/tui-winsource.c, tui/tui-data.c, tui/tui-layout.c: Likewise.
	* tui/tui-winsource.h: Likewise.
@
text
@a452 1
  int screenheight, screenwidth;
a453 1
  rl_get_screen_size (&screenheight, &screenwidth);
d456 1
a456 1
           tui_active ? TUI_CMD_WIN->generic.width : screenwidth);
d459 1
a459 1
           tui_active ? TUI_CMD_WIN->generic.height : screenheight);
@


1.27.2.1
log
@	* tui/tui-win.c (tui_update_gdb_sizes): Use tui_term_width() and
	tui_term_height() to restore the terminal size when leaving the
	TUI mode.
@
text
@d453 1
d455 1
d458 1
a458 1
           tui_active ? TUI_CMD_WIN->generic.width : tui_term_width());
d461 1
a461 1
           tui_active ? TUI_CMD_WIN->generic.height : tui_term_height());
@


1.26
log
@	* tui/tui-win.c (parse_scrolling_args): Fix SEGV error with invalid
	scroll commands.
@
text
@d1325 1
a1325 1
	  union tui_line_or_address line_or_addr;
d1329 1
a1329 6
	  if (win_info->generic.type == SRC_WIN)
	    line_or_addr.line_no =
	      win_info->detail.source_info.start_line_or_addr.line_no;
	  else
	    line_or_addr.addr =
	      win_info->detail.source_info.start_line_or_addr.addr;
d1335 1
a1335 1
	  union tui_line_or_address line;
d1341 4
a1344 1
	    line.line_no = cursal.line;
d1347 2
a1348 1
	      find_line_pc (s, cursal.line, &line.addr);
@


1.25
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d1546 1
a1546 1
	    warning (_("Invalid window specified. \n\
@


1.24
log
@2005-02-20  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_enum_cmd through out.
	* arch-utils.c, charset.c, demangle.c, i386-tdep.c: Update.
	* infrun.c, mips-tdep.c, osabi.c, serial.c, tui/tui-win.c: Update.
@
text
@d201 9
d211 9
d221 8
d412 1
a412 1
			NULL, /* FIXME: i18n: */
d428 1
a428 1
			NULL, /* FIXME: i18n: */
d444 1
a444 1
			NULL, /* FIXME: i18n: */
@


1.23
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d377 43
a419 40
  c = add_set_enum_cmd
    ("border-kind", no_class,
     tui_border_kind_enums, &tui_border_kind,
     "Set the kind of border for TUI windows.\n"
     "This variable controls the border of TUI windows:\n"
     "space           use a white space\n"
     "ascii           use ascii characters + - | for the border\n"
     "acs             use the Alternate Character Set\n",
     &tui_setlist);
  deprecated_add_show_from_set (c, &tui_showlist);

  c = add_set_enum_cmd
    ("border-mode", no_class,
     tui_border_mode_enums, &tui_border_mode,
     "Set the attribute mode to use for the TUI window borders.\n"
     "This variable controls the attributes to use for the window borders:\n"
     "normal          normal display\n"
     "standout        use highlight mode of terminal\n"
     "reverse         use reverse video mode\n"
     "half            use half bright\n"
     "half-standout   use half bright and standout mode\n"
     "bold            use extra bright or bold\n"
     "bold-standout   use extra bright or bold with standout mode\n",
     &tui_setlist);
  deprecated_add_show_from_set (c, &tui_showlist);

  c = add_set_enum_cmd
    ("active-border-mode", no_class,
     tui_border_mode_enums, &tui_active_border_mode,
     "Set the attribute mode to use for the active TUI window border.\n"
     "This variable controls the attributes to use for the active window border:\n"
     "normal          normal display\n"
     "standout        use highlight mode of terminal\n"
     "reverse         use reverse video mode\n"
     "half            use half bright\n"
     "half-standout   use half bright and standout mode\n"
     "bold            use extra bright or bold\n"
     "bold-standout   use extra bright or bold with standout mode\n",
     &tui_setlist);
  deprecated_add_show_from_set (c, &tui_showlist);
@


1.22
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d308 1
a308 1
                    "Text User Interface commands.",
d324 1
a324 1
                  "TUI configuration variables",
d328 1
a328 1
                  "TUI configuration variables",
d333 1
a333 1
           "Refresh the terminal display.\n");
d336 5
a340 5
  add_com ("tabset", class_tui, tui_set_tab_width_command,
           "Set the width (in characters) of tab stops.\n\
Usage: tabset <n>\n");
  add_com ("winheight", class_tui, tui_set_win_height_command,
           "Set the height of a specified window.\n\
d346 1
a346 1
regs : the register display\n");
d349 3
a351 3
            "List of all displayed windows.\n");
  add_com ("focus", class_tui, tui_set_focus_command,
           "Set focus to named window or next/prev window.\n\
d357 1
a357 1
cmd  : the command window\n");
d359 12
a370 8
  add_com ("+", class_tui, tui_scroll_forward_command,
           "Scroll window forward.\nUsage: + [win] [n]\n");
  add_com ("-", class_tui, tui_scroll_backward_command,
           "Scroll window backward.\nUsage: - [win] [n]\n");
  add_com ("<", class_tui, tui_scroll_left_command,
           "Scroll window forward.\nUsage: < [win] [n]\n");
  add_com (">", class_tui, tui_scroll_right_command,
           "Scroll window backward.\nUsage: > [win] [n]\n");
d372 3
a374 3
    add_com ("w", class_xdb, tui_xdb_set_win_height_command,
             "XDB compatibility command for setting the height of a command window.\n\
Usage: w <#lines>\n");
@


1.21
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d298 2
a299 2
  printf_unfiltered ("\"tui\" must be followed by the name of a "
                     "tui command.\n");
d869 1
a869 1
      printf_filtered ("Focus set to %s window.\n",
@


1.20
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d858 2
a859 2
	warning ("Invalid window specified. \n\
The window name specified must be valid and visible.\n");
d873 1
a873 1
    warning ("Incorrect Number of Arguments.\n%s", FOCUS_USAGE);
d930 1
a930 1
	warning ("Tab widths greater than 0 must be specified.\n");
d963 2
a964 2
	    warning ("Invalid window specified. \n\
The window name specified must be valid and visible.\n");
d999 1
a999 1
			warning ("Invalid window height specified.\n%s",
d1005 1
a1005 1
		    warning ("Invalid window height specified.\n%s",
d1048 1
a1048 1
	    warning ("Invalid window height specified.\n%s",
d1052 1
a1052 1
	warning ("Invalid window height specified.\n%s",
d1056 1
a1056 1
    warning ("Invalid window height specified.\n%s", XDBWIN_HEIGHT_USAGE);
d1513 2
a1514 2
	    warning ("Invalid window specified. \n\
The window name specified must be valid and visible.\n");
@


1.19
log
@2004-07-17  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-nat.c (store_spe_registers): Eliminate K&R C.
	* tui/tui-win.c (tui_get_cmd_list): Ditto.
	* symfile-mem.c (_initialize_symfile_mem): Ditto.
@
text
@d382 1
a382 1
  add_show_from_set (c, &tui_showlist);
d397 1
a397 1
  add_show_from_set (c, &tui_showlist);
d412 1
a412 1
  add_show_from_set (c, &tui_showlist);
@


1.18
log
@	* tui/tui-win.h (tui_get_cmd_list): Declare.
	* tui/tui-win.c (tui_command): New function.
	(tui_get_cmd_list): New function.
	(_initialize_tui_win): Moved initialization of tui command in
	tui_get_cmd_list.

	* tui/tui-data.c (init_content_element): Setup new data members.
	(init_win_info): Likewise.
	(free_content_elements): Free it.
	* tui/tui-data.h (struct tui_data_element): Store the register
	content to print.
	(struct tui_data_info): Keep the current register group.

	* tui/tui-layout.c (tui_set_layout): Update call to tui_show_registers.

	* tui/tui-regs.h (tui_show_registers): Update prototype.
	(tui_toggle_float_regs, tui_calculate_regs_column_count): Remove.
	(tui_resize_all): No need to calculate anything for register window.
	* tui/tui-regs.c (tui_calculate_regs_column_count): Remove.
	(tui_set_register_element, tui_set_general_regs_content): Remove.
	(tui_set_special_regs_content): Remove.
	(tui_set_general_and_special_regs_content): Remove.
	(tui_set_float_regs_content): Remove.
	(tui_reg_value_has_changed, tui_get_register_raw_value): Remove.
	(tui_set_regs_content): Remove.
	(tui_toggle_float_regs, _tui_toggle_float_regs_command): Remove.
	(tui_v_show_registers_command_support): Remove.
	(tui_show_registers): Use a reggroup to specify the registers to show.
	(tui_show_register_group): New function.
	(tui_display_registers_from): Compute the layout of register window
	and refresh with new API; be sure to delete old register windows.
	(tui_check_register_values): Update to use tui_get_register and
	tui_display_data.
	(tui_display_register): Just refresh the register window part.
	(tui_register_format): Format registers and save in tui_data_element.
	(tui_get_register): New to combine tui_reg_value_has_changed and
	tui_get_register_raw_value; fix to use the new gdb API.
	(tui_show_float_command): Renamed tui_reg_float_command.
	(tui_show_general_command): Renamed tui_reg_general_command.
	(tui_show_special_command): Renamed tui_reg_system_command.
	(_initialize_tui_regs): Remove unused commands.
@
text
@d304 1
a304 1
tui_get_cmd_list ()
@


1.18.6.1
log
@2004-07-17  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-nat.c (store_spe_registers): Eliminate K&R C.
	* tui/tui-win.c (tui_get_cmd_list): Ditto.
	* symfile-mem.c (_initialize_symfile_mem): Ditto.
@
text
@d304 1
a304 1
tui_get_cmd_list (void)
@


1.18.2.1
log
@merge mainline changes to branch
@
text
@@


1.17
log
@2004-02-28  Andrew Cagney  <cagney@@redhat.com>

	* utils.c: Use "", instead of <>, to include readline.
	tui/tui-win.c, tui/tui.c, tui/tui-hooks.c: Ditto.
	* tracepoint.c, top.c, symmisc.c, symfile.c: Ditto.
	* source.c, solib.c, exec.c, event-top.c: Ditto.
	* corelow.c, completer.c, cli/cli-setshow.c: Ditto.
	* cli/cli-dump.c, cli/cli-cmds.c: Ditto.
	* Makefile.in: Update all dependencies.
	(readline_tilde_h, readline_history_h): Define.
	(readline_headers): Delete.
@
text
@d293 20
a322 4
  add_cmd ("tui", class_tui, NULL,
	   "Text User Interface commands.",
	   &cmdlist);

d621 3
a701 4
	  if (first_win == TUI_DATA_WIN && width_diff != 0)
	    first_win->detail.data_display_info.regs_column_count =
	      tui_calculate_regs_column_count (
			  first_win->detail.data_display_info.regs_display_type);
@


1.17.4.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@a292 20
static struct cmd_list_element *tuilist;

static void
tui_command (char *args, int from_tty)
{
  printf_unfiltered ("\"tui\" must be followed by the name of a "
                     "tui command.\n");
  help_list (tuilist, "tui ", -1, gdb_stdout);
}

struct cmd_list_element **
tui_get_cmd_list ()
{
  if (tuilist == 0)
    add_prefix_cmd ("tui", class_tui, tui_command,
                    "Text User Interface commands.",
                    &tuilist, "tui ", 0, &cmdlist);
  return &tuilist;
}

d303 4
a604 3
#ifdef HAVE_RESIZE_TERM
      resize_term (screenheight, screenwidth);
#endif      
d683 4
@


1.17.2.1
log
@	* tui/tui-win.h (tui_get_cmd_list): Declare.
	* tui/tui-win.c (tui_command): New function.
	(tui_get_cmd_list): New function.
	(_initialize_tui_win): Moved initialization of tui command in
	tui_get_cmd_list.

	* tui/tui-data.c (init_content_element): Setup new data members.
	(init_win_info): Likewise.
	(free_content_elements): Free it.
	* tui/tui-data.h (struct tui_data_element): Store the register
	content to print.
	(struct tui_data_info): Keep the current register group.

	* tui/tui-layout.c (tui_set_layout): Update call to tui_show_registers.

	* tui/tui-regs.h (tui_show_registers): Update prototype.
	(tui_toggle_float_regs, tui_calculate_regs_column_count): Remove.
	(tui_resize_all): No need to calculate anything for register window.
	* tui/tui-regs.c (tui_calculate_regs_column_count): Remove.
	(tui_set_register_element, tui_set_general_regs_content): Remove.
	(tui_set_special_regs_content): Remove.
	(tui_set_general_and_special_regs_content): Remove.
	(tui_set_float_regs_content): Remove.
	(tui_reg_value_has_changed, tui_get_register_raw_value): Remove.
	(tui_set_regs_content): Remove.
	(tui_toggle_float_regs, _tui_toggle_float_regs_command): Remove.
	(tui_v_show_registers_command_support): Remove.
	(tui_show_registers): Use a reggroup to specify the registers to show.
	(tui_show_register_group): New function.
	(tui_display_registers_from): Compute the layout of register window
	and refresh with new API; be sure to delete old register windows.
	(tui_check_register_values): Update to use tui_get_register and
	tui_display_data.
	(tui_display_register): Just refresh the register window part.
	(tui_register_format): Format registers and save in tui_data_element.
	(tui_get_register): New to combine tui_reg_value_has_changed and
	tui_get_register_raw_value; fix to use the new gdb API.
	(tui_show_float_command): Renamed tui_reg_float_command.
	(tui_show_general_command): Renamed tui_reg_general_command.
	(tui_show_special_command): Renamed tui_reg_system_command.
	(_initialize_tui_regs): Remove unused commands.
@
text
@a292 20
static struct cmd_list_element *tuilist;

static void
tui_command (char *args, int from_tty)
{
  printf_unfiltered ("\"tui\" must be followed by the name of a "
                     "tui command.\n");
  help_list (tuilist, "tui ", -1, gdb_stdout);
}

struct cmd_list_element **
tui_get_cmd_list ()
{
  if (tuilist == 0)
    add_prefix_cmd ("tui", class_tui, tui_command,
                    "Text User Interface commands.",
                    &tuilist, "tui ", 0, &cmdlist);
  return &tuilist;
}

d303 4
a604 3
#ifdef HAVE_RESIZE_TERM
      resize_term (screenheight, screenwidth);
#endif      
d683 4
@


1.16
log
@2004-02-10  Andrew Cagney  <cagney@@redhat.com>

	* defs.h: Do not include "tui.h".
	* gdb_curses.h: New file.
	* tui/tui-hooks.h: New file.
	* tui/tui.h (tui_update_all_exec_infos): Delete declaration.
	(tui_install_hooks, tui_remove_hooks): Delete declarations.
	(tui_initialize_io): Delete declaration.
	(tui_initialize_readline: Delete redundant declaration.
	(struct tui_point): Delete definition.
	* tui/tui-data.h (struct tui_point): Define.
	* cli/cli-decode.c [TUI]: Include "tui/tui.h".
	* utils.c: Include "tui/tui.h".
	* tui/tui-data.h: Include "tui/tui.h" and "gdb_curses.h".
	* printcmd.c [TUI]: Include "tui/tui.h".
	* cli/cli-cmds.c [TUI]: Include "tui/tui.h".
	* tui/tui-command.c: Include "gdb_curses.h".
	* tui/tui.c, tui/tui-winsource.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-windata.c, tui/tui-win.c, tui/tui-stack.c: Ditto.
	* tui/tui-source.c, tui/tui-regs.c, tui/tui-layout.c: Ditto.
	* tui/tui-io.c, tui/tui-disasm.c, tui/tui-data.c: : Ditto.
	* tui/tui-hooks.c: Include "tui-hooks.h" and "gdb_curses.h".
	* Makefile.in: Update all dependencies.
	(tui_hooks_h, gdb_curses_h): Define.
	(SUBDIR_TUI_CFLAGS): Remove -I${srcdir}/tui.
@
text
@d53 1
a53 1
#include <readline/readline.h>
@


1.16.4.1
log
@Merge mainline to intercu branch.
@
text
@d53 1
a53 1
#include "readline/readline.h"
a292 20
static struct cmd_list_element *tuilist;

static void
tui_command (char *args, int from_tty)
{
  printf_unfiltered ("\"tui\" must be followed by the name of a "
                     "tui command.\n");
  help_list (tuilist, "tui ", -1, gdb_stdout);
}

struct cmd_list_element **
tui_get_cmd_list ()
{
  if (tuilist == 0)
    add_prefix_cmd ("tui", class_tui, tui_command,
                    "Text User Interface commands.",
                    &tuilist, "tui ", 0, &cmdlist);
  return &tuilist;
}

d303 4
a604 3
#ifdef HAVE_RESIZE_TERM
      resize_term (screenheight, screenwidth);
#endif      
d683 4
@


1.16.4.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d304 1
a304 1
tui_get_cmd_list (void)
d382 1
a382 1
  deprecated_add_show_from_set (c, &tui_showlist);
d397 1
a397 1
  deprecated_add_show_from_set (c, &tui_showlist);
d412 1
a412 1
  deprecated_add_show_from_set (c, &tui_showlist);
@


1.15
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Include "gdb_string.h", delete register
	attribute, use ISO-C function signatures.
	* tui/tui-disasm.c, tui/tui-file.c, tui/tui-io.c: Ditto.
	* tui/tui-layout.c, tui/tui-regs.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-win.c, tui/tui-winsource.c: Ditto.
	* tui/tui.c: Ditto.
@
text
@d49 1
a49 7
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
@


1.15.2.1
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d57 1
a57 1
#include <string.h>
d64 15
a78 15
static void _makeVisibleWithNewHeight (struct tui_win_info *);
static void _makeInvisibleAndSetNewHeight (struct tui_win_info *, int);
static enum tui_status _tuiAdjustWinHeights (struct tui_win_info *, int);
static int _newHeightOk (struct tui_win_info *, int);
static void _tuiSetTabWidth_command (char *, int);
static void _tuiRefreshAll_command (char *, int);
static void _tuiSetWinHeight_command (char *, int);
static void _tuiXDBsetWinHeight_command (char *, int);
static void _tuiAllWindowsInfo (char *, int);
static void _tuiSetFocus_command (char *, int);
static void _tuiScrollForward_command (char *, int);
static void _tuiScrollBackward_command (char *, int);
static void _tuiScrollLeft_command (char *, int);
static void _tuiScrollRight_command (char *, int);
static void _parseScrollingArgs (char *, struct tui_win_info * *, int *);
d244 1
a244 1
tui_update_variables ()
d299 1
a299 4
/*
   ** _initialize_tuiWin().
   **        Function to initialize gdb commands, for tui window manipulation.
 */
d301 1
a301 1
_initialize_tuiWin (void)
d322 1
a322 1
  add_com ("refresh", class_tui, _tuiRefreshAll_command,
d326 1
a326 1
  add_com ("tabset", class_tui, _tuiSetTabWidth_command,
d329 1
a329 1
  add_com ("winheight", class_tui, _tuiSetWinHeight_command,
d338 1
a338 1
  add_info ("win", _tuiAllWindowsInfo,
d340 1
a340 1
  add_com ("focus", class_tui, _tuiSetFocus_command,
d349 1
a349 1
  add_com ("+", class_tui, _tuiScrollForward_command,
d351 1
a351 1
  add_com ("-", class_tui, _tuiScrollBackward_command,
d353 1
a353 1
  add_com ("<", class_tui, _tuiScrollLeft_command,
d355 1
a355 1
  add_com (">", class_tui, _tuiScrollRight_command,
d358 1
a358 1
    add_com ("w", class_xdb, _tuiXDBsetWinHeight_command,
d407 1
a407 1
tui_update_gdb_sizes ()
d429 1
a429 1
      struct tui_win_info * winWithFocus = tui_win_with_focus ();
d431 3
a433 3
      if (winWithFocus != NULL
	  && winWithFocus->generic.type != CMD_WIN)
	tui_unhighlight_win (winWithFocus);
d438 1
a438 3

  return;
}				/* tuiSetWinFocusTo */
d442 1
a442 1
tui_scroll_forward (struct tui_win_info * winToScroll, int numToScroll)
d444 1
a444 1
  if (winToScroll != TUI_CMD_WIN)
d446 1
a446 1
      int _numToScroll = numToScroll;
d448 2
a449 2
      if (numToScroll == 0)
	_numToScroll = winToScroll->generic.height - 3;
d453 1
a453 1
         ** only what is in the viewport.  If winToScroll is the
d456 6
a461 6
      if (winToScroll == TUI_SRC_WIN)
	tui_vertical_source_scroll (FORWARD_SCROLL, _numToScroll);
      else if (winToScroll == TUI_DISASM_WIN)
	tui_vertical_disassem_scroll (FORWARD_SCROLL, _numToScroll);
      else if (winToScroll == TUI_DATA_WIN)
	tui_vertical_data_scroll (FORWARD_SCROLL, _numToScroll);
d466 1
a466 1
tui_scroll_backward (struct tui_win_info * winToScroll, int numToScroll)
d468 1
a468 1
  if (winToScroll != TUI_CMD_WIN)
d470 1
a470 1
      int _numToScroll = numToScroll;
d472 2
a473 2
      if (numToScroll == 0)
	_numToScroll = winToScroll->generic.height - 3;
d477 1
a477 1
         ** only what is in the viewport.  If winToScroll is the
d480 6
a485 6
      if (winToScroll == TUI_SRC_WIN)
	tui_vertical_source_scroll (BACKWARD_SCROLL, _numToScroll);
      else if (winToScroll == TUI_DISASM_WIN)
	tui_vertical_disassem_scroll (BACKWARD_SCROLL, _numToScroll);
      else if (winToScroll == TUI_DATA_WIN)
	tui_vertical_data_scroll (BACKWARD_SCROLL, _numToScroll);
d491 1
a491 1
tui_scroll_left (struct tui_win_info * winToScroll, int numToScroll)
d493 1
a493 1
  if (winToScroll != TUI_CMD_WIN)
d495 1
a495 1
      int _numToScroll = numToScroll;
d497 2
a498 2
      if (_numToScroll == 0)
	_numToScroll = 1;
d502 1
a502 1
         ** only what is in the viewport. If winToScroll is the
d505 2
a506 2
      if (winToScroll == TUI_SRC_WIN || winToScroll == TUI_DISASM_WIN)
	tui_horizontal_source_scroll (winToScroll, LEFT_SCROLL, _numToScroll);
d512 1
a512 1
tui_scroll_right (struct tui_win_info * winToScroll, int numToScroll)
d514 1
a514 1
  if (winToScroll != TUI_CMD_WIN)
d516 1
a516 1
      int _numToScroll = numToScroll;
d518 2
a519 2
      if (_numToScroll == 0)
	_numToScroll = 1;
d523 1
a523 1
         ** only what is in the viewport. If winToScroll is the
d526 2
a527 2
      if (winToScroll == TUI_SRC_WIN || winToScroll == TUI_DISASM_WIN)
	tui_horizontal_source_scroll (winToScroll, RIGHT_SCROLL, _numToScroll);
d535 2
a536 2
	    struct tui_win_info * winToScroll,
	    int numToScroll)
d541 1
a541 1
      tui_scroll_forward (winToScroll, numToScroll);
d544 1
a544 1
      tui_scroll_backward (winToScroll, numToScroll);
d547 1
a547 1
      tui_scroll_left (winToScroll, numToScroll);
d550 1
a550 1
      tui_scroll_right (winToScroll, numToScroll);
d590 2
a591 5
/*
   ** tuiResizeAll().
   **      Resize all the windows based on the the terminal size.  This
   **      function gets called from within the readline sinwinch handler.
 */
d593 1
a593 1
tuiResizeAll (void)
d595 1
a595 1
  int heightDiff, widthDiff;
d599 8
a606 8
  widthDiff = screenwidth - tui_term_width ();
  heightDiff = screenheight - tui_term_height ();
  if (heightDiff || widthDiff)
    {
      enum tui_layout_type curLayout = tui_current_layout ();
      struct tui_win_info * winWithFocus = tui_win_with_focus ();
      struct tui_win_info *firstWin;
      struct tui_win_info *secondWin;
d608 2
a609 2
      enum tui_win_type winType;
      int newHeight, splitDiff, cmdSplitDiff, numWinsDisplayed = 2;
d612 1
a612 1
      if (winWithFocus != TUI_CMD_WIN)
d617 6
a622 6
      if (curLayout == SRC_DISASSEM_COMMAND ||
	curLayout == SRC_DATA_COMMAND || curLayout == DISASSEM_DATA_COMMAND)
	numWinsDisplayed++;
      splitDiff = heightDiff / numWinsDisplayed;
      cmdSplitDiff = splitDiff;
      if (heightDiff % numWinsDisplayed)
d624 2
a625 2
	  if (heightDiff < 0)
	    cmdSplitDiff--;
d627 1
a627 1
	    cmdSplitDiff++;
d632 1
a632 1
      switch (curLayout)
d636 3
a638 3
	  firstWin = (struct tui_win_info *) (tui_source_windows ())->list[0];
	  firstWin->generic.width += widthDiff;
	  locator->width += widthDiff;
d640 3
a642 3
	  if (heightDiff == 0)
	    newHeight = firstWin->generic.height;
	  else if ((firstWin->generic.height + splitDiff) >=
d644 3
a646 3
	    newHeight = screenheight - MIN_CMD_WIN_HEIGHT - 1;
	  else if ((firstWin->generic.height + splitDiff) <= 0)
	    newHeight = MIN_WIN_HEIGHT;
d648 1
a648 1
	    newHeight = firstWin->generic.height + splitDiff;
d650 1
a650 1
	  _makeInvisibleAndSetNewHeight (firstWin, newHeight);
d652 7
a658 7
	  TUI_CMD_WIN->generic.width += widthDiff;
	  newHeight = screenheight - TUI_CMD_WIN->generic.origin.y;
	  _makeInvisibleAndSetNewHeight (TUI_CMD_WIN, newHeight);
	  _makeVisibleWithNewHeight (firstWin);
	  _makeVisibleWithNewHeight (TUI_CMD_WIN);
	  if (firstWin->generic.content_size <= 0)
	    tui_erase_source_content (firstWin, EMPTY_SOURCE_PROMPT);
d661 1
a661 1
	  if (curLayout == SRC_DISASSEM_COMMAND)
d663 4
a666 4
	      firstWin = TUI_SRC_WIN;
	      firstWin->generic.width += widthDiff;
	      secondWin = TUI_DISASM_WIN;
	      secondWin->generic.width += widthDiff;
d670 4
a673 4
	      firstWin = TUI_DATA_WIN;
	      firstWin->generic.width += widthDiff;
	      secondWin = (struct tui_win_info *) (tui_source_windows ())->list[0];
	      secondWin->generic.width += widthDiff;
d677 4
a680 4
	  if (heightDiff == 0)
	    newHeight = firstWin->generic.height;
	  else if ((firstWin->generic.height +
		    secondWin->generic.height + (splitDiff * 2)) >=
d682 3
a684 3
	    newHeight = (screenheight - MIN_CMD_WIN_HEIGHT - 1) / 2;
	  else if ((firstWin->generic.height + splitDiff) <= 0)
	    newHeight = MIN_WIN_HEIGHT;
d686 2
a687 2
	    newHeight = firstWin->generic.height + splitDiff;
	  _makeInvisibleAndSetNewHeight (firstWin, newHeight);
d689 2
a690 2
	  if (firstWin == TUI_DATA_WIN && widthDiff != 0)
	    firstWin->detail.data_display_info.regs_column_count =
d692 2
a693 2
			  firstWin->detail.data_display_info.regs_display_type);
	  locator->width += widthDiff;
d697 4
a700 4
	  if (heightDiff == 0)
	    newHeight = secondWin->generic.height;
	  else if ((firstWin->generic.height +
		    secondWin->generic.height + (splitDiff * 2)) >=
d703 3
a705 3
	      newHeight = screenheight - MIN_CMD_WIN_HEIGHT - 1;
	      if (newHeight % 2)
		newHeight = (newHeight / 2) + 1;
d707 1
a707 1
		newHeight /= 2;
d709 2
a710 2
	  else if ((secondWin->generic.height + splitDiff) <= 0)
	    newHeight = MIN_WIN_HEIGHT;
d712 3
a714 3
	    newHeight = secondWin->generic.height + splitDiff;
	  secondWin->generic.origin.y = firstWin->generic.height - 1;
	  _makeInvisibleAndSetNewHeight (secondWin, newHeight);
d718 9
a726 9
	  _makeInvisibleAndSetNewHeight (
			     TUI_CMD_WIN, TUI_CMD_WIN->generic.height + cmdSplitDiff);
	  _makeVisibleWithNewHeight (firstWin);
	  _makeVisibleWithNewHeight (secondWin);
	  _makeVisibleWithNewHeight (TUI_CMD_WIN);
	  if (firstWin->generic.content_size <= 0)
	    tui_erase_source_content (firstWin, EMPTY_SOURCE_PROMPT);
	  if (secondWin->generic.content_size <= 0)
	    tui_erase_source_content (secondWin, EMPTY_SOURCE_PROMPT);
d733 1
a733 1
      for (winType = SRC_WIN; (winType < MAX_MAJOR_WINDOWS); winType++)
d735 2
a736 2
	  if (winType != CMD_WIN && (tui_win_list[winType] != NULL)
	      && !tui_win_list[winType]->generic.is_visible)
d738 2
a739 2
	      tui_free_window (tui_win_list[winType]);
	      tui_win_list[winType] = (struct tui_win_info *) NULL;
d744 1
a744 1
      if (winWithFocus != TUI_CMD_WIN)
d747 1
a747 2
  return;
}				/* tuiResizeAll */
d750 3
a752 6
/*
   ** tuiSigwinchHandler()
   **    SIGWINCH signal handler for the tui.  This signal handler is
   **    always called, even when the readline package clears signals
   **    because it is set as the old_sigwinch() (TUI only)
 */
d754 1
a754 1
tuiSigwinchHandler (int signal)
d761 1
a761 3

  return;
}				/* tuiSigwinchHandler */
a769 3
/*
   ** _tuiScrollForward_command().
 */
d771 1
a771 1
_tuiScrollForward_command (char *arg, int fromTTY)
d773 2
a774 2
  int numToScroll = 1;
  struct tui_win_info * winToScroll;
d779 1
a779 1
    _parseScrollingArgs (arg, &winToScroll, (int *) NULL);
d781 2
a782 2
    _parseScrollingArgs (arg, &winToScroll, &numToScroll);
  tui_scroll (FORWARD_SCROLL, winToScroll, numToScroll);
a785 3
/*
   ** _tuiScrollBackward_command().
 */
d787 1
a787 1
_tuiScrollBackward_command (char *arg, int fromTTY)
d789 2
a790 2
  int numToScroll = 1;
  struct tui_win_info * winToScroll;
d795 1
a795 1
    _parseScrollingArgs (arg, &winToScroll, (int *) NULL);
d797 2
a798 2
    _parseScrollingArgs (arg, &winToScroll, &numToScroll);
  tui_scroll (BACKWARD_SCROLL, winToScroll, numToScroll);
a801 3
/*
   ** _tuiScrollLeft_command().
 */
d803 1
a803 1
_tuiScrollLeft_command (char *arg, int fromTTY)
d805 2
a806 2
  int numToScroll;
  struct tui_win_info * winToScroll;
d810 2
a811 2
  _parseScrollingArgs (arg, &winToScroll, &numToScroll);
  tui_scroll (LEFT_SCROLL, winToScroll, numToScroll);
a814 3
/*
   ** _tuiScrollRight_command().
 */
d816 1
a816 1
_tuiScrollRight_command (char *arg, int fromTTY)
d818 2
a819 2
  int numToScroll;
  struct tui_win_info * winToScroll;
d823 2
a824 2
  _parseScrollingArgs (arg, &winToScroll, &numToScroll);
  tui_scroll (RIGHT_SCROLL, winToScroll, numToScroll);
d828 1
a828 4
/*
   ** _tuiSetFocus().
   **     Set focus to the window named by 'arg'
 */
d830 1
a830 1
_tuiSetFocus (char *arg, int fromTTY)
d834 1
a834 1
      char *bufPtr = (char *) xstrdup (arg);
d838 2
a839 2
      for (i = 0; (i < strlen (bufPtr)); i++)
	bufPtr[i] = toupper (arg[i]);
d841 1
a841 1
      if (subset_compare (bufPtr, "NEXT"))
d843 1
a843 1
      else if (subset_compare (bufPtr, "PREV"))
d846 1
a846 1
	win_info = tui_partial_win_by_name (bufPtr);
d859 1
a859 1
      xfree (bufPtr);
d865 1
a866 6
  return;
}				/* _tuiSetFocus */

/*
   ** _tuiSetFocus_command()
 */
d868 1
a868 1
_tuiSetFocus_command (char *arg, int fromTTY)
d872 1
a872 1
  _tuiSetFocus (arg, fromTTY);
a875 3
/*
   ** _tuiAllWindowsInfo().
 */
d877 1
a877 1
_tuiAllWindowsInfo (char *arg, int fromTTY)
d880 1
a880 1
  struct tui_win_info * winWithFocus = tui_win_with_focus ();
d885 1
a885 1
	if (winWithFocus == tui_win_list[type])
d894 1
a894 3

  return;
}				/* _tuiAllWindowsInfo */
a896 3
/*
   ** _tuiRefreshAll_command().
 */
d898 1
a898 1
_tuiRefreshAll_command (char *arg, int fromTTY)
d907 1
a907 4
/*
   ** _tuiSetWinTabWidth_command().
   **        Set the height of the specified window.
 */
d909 1
a909 1
_tuiSetTabWidth_command (char *arg, int fromTTY)
d923 1
a923 3

  return;
}				/* _tuiSetTabWidth_command */
d926 1
a926 4
/*
   ** _tuiSetWinHeight().
   **        Set the height of the specified window.
 */
d928 1
a928 1
_tuiSetWinHeight (char *arg, int fromTTY)
d935 1
a935 1
      char *bufPtr = buf;
d937 1
a937 1
      int newHeight, i;
d940 3
a942 3
      wname = bufPtr;
      bufPtr = strchr (bufPtr, ' ');
      if (bufPtr != (char *) NULL)
d944 1
a944 1
	  *bufPtr = (char) 0;
d959 1
a959 1
	      while (*(++bufPtr) == ' ')
d962 1
a962 1
	      if (*bufPtr != (char) 0)
d965 2
a966 2
		  int fixedSize = TRUE;
		  int inputNo;;
d968 1
a968 1
		  if (*bufPtr == '+' || *bufPtr == '-')
d970 1
a970 1
		      if (*bufPtr == '-')
d972 2
a973 2
		      fixedSize = FALSE;
		      bufPtr++;
d975 2
a976 2
		  inputNo = atoi (bufPtr);
		  if (inputNo > 0)
d979 3
a981 3
			inputNo *= (-1);
		      if (fixedSize)
			newHeight = inputNo;
d983 1
a983 1
			newHeight = win_info->generic.height + inputNo;
d988 2
a989 2
		      if (_tuiAdjustWinHeights (win_info,
						newHeight) == TUI_FAILURE)
d1009 1
d1011 1
a1011 7
  return;
}				/* _tuiSetWinHeight */

/*
   ** _tuiSetWinHeight_command().
   **        Set the height of the specified window, with va_list.
 */
d1013 1
a1013 1
_tuiSetWinHeight_command (char *arg, int fromTTY)
d1017 1
a1017 1
  _tuiSetWinHeight (arg, fromTTY);
d1021 2
a1022 5
/*
   ** _tuiXDBsetWinHeight().
   **        XDB Compatibility command for setting the window height.  This will
   **        increase or decrease the command window by the specified amount.
 */
d1024 1
a1024 1
_tuiXDBsetWinHeight (char *arg, int fromTTY)
d1030 1
a1030 1
      int inputNo = atoi (arg);
d1032 1
a1032 1
      if (inputNo > 0)
d1034 1
a1034 1
	  int newHeight = tui_term_height () - (inputNo + 1);
d1036 3
a1038 3
	  if (!_newHeightOk (tui_win_list[CMD_WIN], newHeight) ||
	      _tuiAdjustWinHeights (tui_win_list[CMD_WIN],
				    newHeight) == TUI_FAILURE)
d1048 1
d1050 1
a1050 7
  return;
}				/* _tuiXDBsetWinHeight */

/*
   ** _tuiSetWinHeight_command().
   **        Set the height of the specified window, with va_list.
 */
d1052 1
a1052 1
_tuiXDBsetWinHeight_command (char *arg, int fromTTY)
d1054 1
a1054 1
  _tuiXDBsetWinHeight (arg, fromTTY);
d1058 1
a1058 4
/*
   ** _tuiAdjustWinHeights().
   **        Function to adjust all window heights around the primary
 */
d1060 1
a1060 1
_tuiAdjustWinHeights (struct tui_win_info * primaryWinInfo, int newHeight)
d1064 1
a1064 1
  if (_newHeightOk (primaryWinInfo, newHeight))
d1067 1
a1067 1
      if (newHeight != primaryWinInfo->generic.height)
d1072 1
a1072 1
	  enum tui_layout_type curLayout = tui_current_layout ();
d1074 2
a1075 2
	  diff = (newHeight - primaryWinInfo->generic.height) * (-1);
	  if (curLayout == SRC_COMMAND || curLayout == DISASSEM_COMMAND)
d1077 1
a1077 1
	      struct tui_win_info * srcWinInfo;
d1079 2
a1080 2
	      _makeInvisibleAndSetNewHeight (primaryWinInfo, newHeight);
	      if (primaryWinInfo->generic.type == CMD_WIN)
d1083 1
a1083 1
		  srcWinInfo = win_info;
d1088 1
a1088 1
		  srcWinInfo = primaryWinInfo;
d1090 1
a1090 1
	      _makeInvisibleAndSetNewHeight (win_info,
d1093 4
a1096 4
	      _makeVisibleWithNewHeight (win_info);
	      _makeVisibleWithNewHeight (primaryWinInfo);
	      if (srcWinInfo->generic.content_size <= 0)
		tui_erase_source_content (srcWinInfo, EMPTY_SOURCE_PROMPT);
d1100 2
a1101 2
	      struct tui_win_info *firstWin;
	      struct tui_win_info *secondWin;
d1103 1
a1103 1
	      if (curLayout == SRC_DISASSEM_COMMAND)
d1105 2
a1106 2
		  firstWin = TUI_SRC_WIN;
		  secondWin = TUI_DISASM_WIN;
d1110 2
a1111 2
		  firstWin = TUI_DATA_WIN;
		  secondWin = (struct tui_win_info *) (tui_source_windows ())->list[0];
d1113 1
a1113 1
	      if (primaryWinInfo == TUI_CMD_WIN)
d1118 2
a1119 2
		  int firstSplitDiff = diff / 2;	/* subtract the locator */
		  int secondSplitDiff = firstSplitDiff;
d1123 2
a1124 2
		      if (firstWin->generic.height >
			  secondWin->generic.height)
d1126 1
a1126 1
			  firstSplitDiff--;
d1128 1
a1128 1
			  firstSplitDiff++;
d1132 1
a1132 1
			    secondSplitDiff--;
d1134 1
a1134 1
			    secondSplitDiff++;
d1138 1
a1138 1
		  while ((firstWin->generic.height + firstSplitDiff) < 3)
d1140 2
a1141 2
		      firstSplitDiff++;
		      secondSplitDiff--;
d1143 1
a1143 1
		  while ((secondWin->generic.height + secondSplitDiff) < 3)
d1145 2
a1146 2
		      secondSplitDiff++;
		      firstSplitDiff--;
d1148 6
a1153 6
		  _makeInvisibleAndSetNewHeight (
						  firstWin,
				 firstWin->generic.height + firstSplitDiff);
		  secondWin->generic.origin.y = firstWin->generic.height - 1;
		  _makeInvisibleAndSetNewHeight (
		    secondWin, secondWin->generic.height + secondSplitDiff);
d1155 1
a1155 1
		  _makeInvisibleAndSetNewHeight (TUI_CMD_WIN, newHeight);
d1169 2
a1170 2
			    if (primaryWinInfo == firstWin)
			      secondWin->generic.height--;
d1172 1
a1172 1
			      firstWin->generic.height--;
d1175 2
a1176 2
		  if (primaryWinInfo == firstWin)
		    _makeInvisibleAndSetNewHeight (firstWin, newHeight);
d1178 6
a1183 6
		    _makeInvisibleAndSetNewHeight (
						    firstWin,
						  firstWin->generic.height);
		  secondWin->generic.origin.y = firstWin->generic.height - 1;
		  if (primaryWinInfo == secondWin)
		    _makeInvisibleAndSetNewHeight (secondWin, newHeight);
d1185 2
a1186 2
		    _makeInvisibleAndSetNewHeight (
				      secondWin, secondWin->generic.height);
d1189 1
a1189 1
		    _makeInvisibleAndSetNewHeight (TUI_CMD_WIN, 1);
d1191 1
a1191 1
		    _makeInvisibleAndSetNewHeight (
d1194 7
a1200 7
	      _makeVisibleWithNewHeight (TUI_CMD_WIN);
	      _makeVisibleWithNewHeight (secondWin);
	      _makeVisibleWithNewHeight (firstWin);
	      if (firstWin->generic.content_size <= 0)
		tui_erase_source_content (firstWin, EMPTY_SOURCE_PROMPT);
	      if (secondWin->generic.content_size <= 0)
		tui_erase_source_content (secondWin, EMPTY_SOURCE_PROMPT);
d1206 1
a1206 1
}				/* _tuiAdjustWinHeights */
d1209 2
a1210 5
/*
   ** _makeInvisibleAndSetNewHeight().
   **        Function make the target window (and auxillary windows associated
   **        with the targer) invisible, and set the new height and location.
 */
d1212 1
a1212 1
_makeInvisibleAndSetNewHeight (struct tui_win_info * win_info, int height)
d1215 1
a1215 1
  struct tui_gen_win_info * genWinInfo;
d1231 4
a1234 4
      genWinInfo = win_info->detail.source_info.execution_info;
      tui_make_invisible (genWinInfo);
      genWinInfo->height = height;
      genWinInfo->origin.y = win_info->generic.origin.y;
d1236 1
a1236 1
	genWinInfo->viewport_height = height - 1;
d1238 1
a1238 1
	genWinInfo->viewport_height = height;
d1240 1
a1240 1
	genWinInfo->viewport_height--;
d1244 3
a1246 3
	  genWinInfo = tui_locator_win_info_ptr ();
	  tui_make_invisible (genWinInfo);
	  genWinInfo->origin.y = win_info->generic.origin.y + height;
d1253 1
a1253 1
	  genWinInfo = (struct tui_gen_win_info *) & ((struct tui_win_element *)
d1255 2
a1256 2
	  tui_delete_win (genWinInfo->handle);
	  genWinInfo->handle = (WINDOW *) NULL;
d1265 3
a1267 6
/*
   ** _makeVisibleWithNewHeight().
   **        Function to make the windows with new heights visible.
   **        This means re-creating the windows' content since the window
   **        had to be destroyed to be made invisible.
 */
d1269 1
a1269 1
_makeVisibleWithNewHeight (struct tui_win_info * win_info)
d1283 1
a1283 1
	  union tui_line_or_address lineOrAddr;
d1288 1
a1288 1
	    lineOrAddr.line_no =
d1291 1
a1291 1
	    lineOrAddr.addr =
d1294 1
a1294 1
	  tui_update_source_window (win_info, cursal.symtab, lineOrAddr, TRUE);
d1330 1
a1330 3

  return;
}				/* _makeVisibleWithNewHeight */
d1334 1
a1334 1
_newHeightOk (struct tui_win_info * primaryWinInfo, int newHeight)
d1336 1
a1336 1
  int ok = (newHeight < tui_term_height ());
d1343 1
a1343 1
      diff = (newHeight - primaryWinInfo->generic.height) * (-1);
d1346 6
a1351 6
	  ok = ((primaryWinInfo->generic.type == CMD_WIN &&
		 newHeight <= (tui_term_height () - 4) &&
		 newHeight >= MIN_CMD_WIN_HEIGHT) ||
		(primaryWinInfo->generic.type != CMD_WIN &&
		 newHeight <= (tui_term_height () - 2) &&
		 newHeight >= MIN_WIN_HEIGHT));
d1356 1
a1356 1
	      if (primaryWinInfo == TUI_CMD_WIN)
d1360 1
a1360 1
	      ok = ((newHeight +
d1366 3
a1368 3
	  int curTotalHeight, totalHeight, minHeight = 0;
	  struct tui_win_info *firstWin;
	  struct tui_win_info *secondWin;
d1372 2
a1373 2
	      firstWin = TUI_SRC_WIN;
	      secondWin = TUI_DISASM_WIN;
d1377 2
a1378 2
	      firstWin = TUI_DATA_WIN;
	      secondWin = (struct tui_win_info *) (tui_source_windows ())->list[0];
d1386 2
a1387 2
	  totalHeight = curTotalHeight =
	    (firstWin->generic.height + secondWin->generic.height - 1)
d1389 1
a1389 1
	  if (primaryWinInfo == TUI_CMD_WIN)
d1392 2
a1393 2
	      ok = ((firstWin->generic.height +
		     secondWin->generic.height + diff) >=
d1395 1
a1395 1
		    newHeight >= MIN_CMD_WIN_HEIGHT);
d1398 3
a1400 3
		  totalHeight = newHeight + (firstWin->generic.height +
					  secondWin->generic.height + diff);
		  minHeight = MIN_CMD_WIN_HEIGHT;
d1405 1
a1405 1
	      minHeight = MIN_WIN_HEIGHT;
d1417 2
a1418 2
		  if (primaryWinInfo == firstWin)
		    ok = (secondWin->generic.height + diff) >= minHeight;
d1420 1
a1420 1
		    ok = (firstWin->generic.height + diff) >= minHeight;
d1424 3
a1426 3
		  if (primaryWinInfo == firstWin)
		    totalHeight = newHeight +
		      secondWin->generic.height +
d1429 2
a1430 2
		    totalHeight = newHeight +
		      firstWin->generic.height +
d1439 1
a1439 1
	    ok = (newHeight >= minHeight && totalHeight <= curTotalHeight);
d1444 1
a1444 1
}				/* _newHeightOk */
a1446 3
/*
   ** _parseScrollingArgs().
 */
d1448 2
a1449 1
_parseScrollingArgs (char *arg, struct tui_win_info * * winToScroll, int *numToScroll)
d1451 3
a1453 3
  if (numToScroll)
    *numToScroll = 0;
  *winToScroll = tui_win_with_focus ();
d1461 1
a1461 1
      char *buf, *bufPtr;
d1464 2
a1465 2
      buf = bufPtr = xstrdup (arg);
      if (isdigit (*bufPtr))
d1467 1
a1467 1
	  char *numStr;
d1469 3
a1471 3
	  numStr = bufPtr;
	  bufPtr = strchr (bufPtr, ' ');
	  if (bufPtr != (char *) NULL)
d1473 4
a1476 4
	      *bufPtr = (char) 0;
	      if (numToScroll)
		*numToScroll = atoi (numStr);
	      bufPtr++;
d1478 2
a1479 2
	  else if (numToScroll)
	    *numToScroll = atoi (numStr);
d1483 1
a1483 1
      if (bufPtr != (char *) NULL)
d1488 2
a1489 2
	  if (*bufPtr == ' ')
	    while (*(++bufPtr) == ' ')
d1492 2
a1493 2
	  if (*bufPtr != (char) 0)
	    wname = bufPtr;
d1500 1
a1500 1
	  *winToScroll = tui_partial_win_by_name (wname);
d1502 2
a1503 2
	  if (*winToScroll == (struct tui_win_info *) NULL ||
	      !(*winToScroll)->generic.is_visible)
d1506 2
a1507 2
	  else if (*winToScroll == TUI_CMD_WIN)
	    *winToScroll = (struct tui_win_info *) (tui_source_windows ())->list[0];
d1511 1
a1511 3

  return;
}				/* _parseScrollingArgs */
@


1.14
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Change variable and function names to lower
	case.
	* tui/tui-data.c, tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c, tui/tui-io.c, tui/tui-layout.c: Ditto.
	* tui/tui-regs.c, tui/tui-source.c, tui/tui-stack.c: Ditto.
	* tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d57 1
a57 1
#include <string.h>
d244 1
a244 1
tui_update_variables ()
d407 1
a407 1
tui_update_gdb_sizes ()
@


1.13
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui.h: Do not include <stdarg.h>, <string.h>, and
	"ansidecl.h".  Do not undef "reg" and "chtype".  Fix case of
	fields and variables.
	* tui/tui-wingeneral.h (m_beVisible): Delete macro.
	(m_beInvisible): Delete macro.
	* tui/tui-data.h: Fix case case fields and variables.
	(m_genWinPtrIsNull): Delete macro.
	(tui_win_list): Rename winList.
	(TUI_SRC_WIN): Rename srcWin.
	(TUI_DISASM_WIN): Rename disassemWin.
	(TUI_DATA_WIN): Rename dataWin.
	(TUI_CMD_WIN): Rename cmdWin.
	(m_genWinPtrNotNull): Delete macro.
	(m_winPtrIsNull): Delete macro.
	(m_winPtrNotNull): Delete macro.
	(tui_win_is_source_type): Replace m_winIsSourceType
	(tui_win_is_auxillary): Replace m_winIsAuzillary.
	(tui_win_has_locator): Replace m_hasLocator.
	(tui_set_win_highlight): Replace m_setWinHighlightOn and
	m_setWinHighlightOff.
	* tui/tui-data.c: Update references.
	(tui_win_is_source_type, tui_set_win_highlight): New functions.
	(tui_win_has_locator, tui_win_is_auxillary): New functions.
	* tui/tui-command.c, tui/tui-disasm.c: Update references.
	* tui/tui-io.c, tui/tui-layout.c, tui/tui-regs.c: Ditto.
	* tui/tui-regs.h, tui/tui-source.c, tui/tui-stack.c: Ditto.
	* tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d64 15
a78 15
static void _makeVisibleWithNewHeight (struct tui_win_info *);
static void _makeInvisibleAndSetNewHeight (struct tui_win_info *, int);
static enum tui_status _tuiAdjustWinHeights (struct tui_win_info *, int);
static int _newHeightOk (struct tui_win_info *, int);
static void _tuiSetTabWidth_command (char *, int);
static void _tuiRefreshAll_command (char *, int);
static void _tuiSetWinHeight_command (char *, int);
static void _tuiXDBsetWinHeight_command (char *, int);
static void _tuiAllWindowsInfo (char *, int);
static void _tuiSetFocus_command (char *, int);
static void _tuiScrollForward_command (char *, int);
static void _tuiScrollBackward_command (char *, int);
static void _tuiScrollLeft_command (char *, int);
static void _tuiScrollRight_command (char *, int);
static void _parseScrollingArgs (char *, struct tui_win_info * *, int *);
d299 1
a299 4
/*
   ** _initialize_tuiWin().
   **        Function to initialize gdb commands, for tui window manipulation.
 */
d301 1
a301 1
_initialize_tuiWin (void)
d322 1
a322 1
  add_com ("refresh", class_tui, _tuiRefreshAll_command,
d326 1
a326 1
  add_com ("tabset", class_tui, _tuiSetTabWidth_command,
d329 1
a329 1
  add_com ("winheight", class_tui, _tuiSetWinHeight_command,
d338 1
a338 1
  add_info ("win", _tuiAllWindowsInfo,
d340 1
a340 1
  add_com ("focus", class_tui, _tuiSetFocus_command,
d349 1
a349 1
  add_com ("+", class_tui, _tuiScrollForward_command,
d351 1
a351 1
  add_com ("-", class_tui, _tuiScrollBackward_command,
d353 1
a353 1
  add_com ("<", class_tui, _tuiScrollLeft_command,
d355 1
a355 1
  add_com (">", class_tui, _tuiScrollRight_command,
d358 1
a358 1
    add_com ("w", class_xdb, _tuiXDBsetWinHeight_command,
d429 1
a429 1
      struct tui_win_info * winWithFocus = tui_win_with_focus ();
d431 3
a433 3
      if (winWithFocus != NULL
	  && winWithFocus->generic.type != CMD_WIN)
	tui_unhighlight_win (winWithFocus);
d438 1
a438 3

  return;
}				/* tuiSetWinFocusTo */
d442 1
a442 1
tui_scroll_forward (struct tui_win_info * winToScroll, int numToScroll)
d444 1
a444 1
  if (winToScroll != TUI_CMD_WIN)
d446 1
a446 1
      int _numToScroll = numToScroll;
d448 2
a449 2
      if (numToScroll == 0)
	_numToScroll = winToScroll->generic.height - 3;
d453 1
a453 1
         ** only what is in the viewport.  If winToScroll is the
d456 6
a461 6
      if (winToScroll == TUI_SRC_WIN)
	tui_vertical_source_scroll (FORWARD_SCROLL, _numToScroll);
      else if (winToScroll == TUI_DISASM_WIN)
	tui_vertical_disassem_scroll (FORWARD_SCROLL, _numToScroll);
      else if (winToScroll == TUI_DATA_WIN)
	tui_vertical_data_scroll (FORWARD_SCROLL, _numToScroll);
d466 1
a466 1
tui_scroll_backward (struct tui_win_info * winToScroll, int numToScroll)
d468 1
a468 1
  if (winToScroll != TUI_CMD_WIN)
d470 1
a470 1
      int _numToScroll = numToScroll;
d472 2
a473 2
      if (numToScroll == 0)
	_numToScroll = winToScroll->generic.height - 3;
d477 1
a477 1
         ** only what is in the viewport.  If winToScroll is the
d480 6
a485 6
      if (winToScroll == TUI_SRC_WIN)
	tui_vertical_source_scroll (BACKWARD_SCROLL, _numToScroll);
      else if (winToScroll == TUI_DISASM_WIN)
	tui_vertical_disassem_scroll (BACKWARD_SCROLL, _numToScroll);
      else if (winToScroll == TUI_DATA_WIN)
	tui_vertical_data_scroll (BACKWARD_SCROLL, _numToScroll);
d491 1
a491 1
tui_scroll_left (struct tui_win_info * winToScroll, int numToScroll)
d493 1
a493 1
  if (winToScroll != TUI_CMD_WIN)
d495 1
a495 1
      int _numToScroll = numToScroll;
d497 2
a498 2
      if (_numToScroll == 0)
	_numToScroll = 1;
d502 1
a502 1
         ** only what is in the viewport. If winToScroll is the
d505 2
a506 2
      if (winToScroll == TUI_SRC_WIN || winToScroll == TUI_DISASM_WIN)
	tui_horizontal_source_scroll (winToScroll, LEFT_SCROLL, _numToScroll);
d512 1
a512 1
tui_scroll_right (struct tui_win_info * winToScroll, int numToScroll)
d514 1
a514 1
  if (winToScroll != TUI_CMD_WIN)
d516 1
a516 1
      int _numToScroll = numToScroll;
d518 2
a519 2
      if (_numToScroll == 0)
	_numToScroll = 1;
d523 1
a523 1
         ** only what is in the viewport. If winToScroll is the
d526 2
a527 2
      if (winToScroll == TUI_SRC_WIN || winToScroll == TUI_DISASM_WIN)
	tui_horizontal_source_scroll (winToScroll, RIGHT_SCROLL, _numToScroll);
d535 2
a536 2
	    struct tui_win_info * winToScroll,
	    int numToScroll)
d541 1
a541 1
      tui_scroll_forward (winToScroll, numToScroll);
d544 1
a544 1
      tui_scroll_backward (winToScroll, numToScroll);
d547 1
a547 1
      tui_scroll_left (winToScroll, numToScroll);
d550 1
a550 1
      tui_scroll_right (winToScroll, numToScroll);
d590 2
a591 5
/*
   ** tuiResizeAll().
   **      Resize all the windows based on the the terminal size.  This
   **      function gets called from within the readline sinwinch handler.
 */
d593 1
a593 1
tuiResizeAll (void)
d595 1
a595 1
  int heightDiff, widthDiff;
d599 8
a606 8
  widthDiff = screenwidth - tui_term_width ();
  heightDiff = screenheight - tui_term_height ();
  if (heightDiff || widthDiff)
    {
      enum tui_layout_type curLayout = tui_current_layout ();
      struct tui_win_info * winWithFocus = tui_win_with_focus ();
      struct tui_win_info *firstWin;
      struct tui_win_info *secondWin;
d608 2
a609 2
      enum tui_win_type winType;
      int newHeight, splitDiff, cmdSplitDiff, numWinsDisplayed = 2;
d612 1
a612 1
      if (winWithFocus != TUI_CMD_WIN)
d617 6
a622 6
      if (curLayout == SRC_DISASSEM_COMMAND ||
	curLayout == SRC_DATA_COMMAND || curLayout == DISASSEM_DATA_COMMAND)
	numWinsDisplayed++;
      splitDiff = heightDiff / numWinsDisplayed;
      cmdSplitDiff = splitDiff;
      if (heightDiff % numWinsDisplayed)
d624 2
a625 2
	  if (heightDiff < 0)
	    cmdSplitDiff--;
d627 1
a627 1
	    cmdSplitDiff++;
d632 1
a632 1
      switch (curLayout)
d636 3
a638 3
	  firstWin = (struct tui_win_info *) (tui_source_windows ())->list[0];
	  firstWin->generic.width += widthDiff;
	  locator->width += widthDiff;
d640 3
a642 3
	  if (heightDiff == 0)
	    newHeight = firstWin->generic.height;
	  else if ((firstWin->generic.height + splitDiff) >=
d644 3
a646 3
	    newHeight = screenheight - MIN_CMD_WIN_HEIGHT - 1;
	  else if ((firstWin->generic.height + splitDiff) <= 0)
	    newHeight = MIN_WIN_HEIGHT;
d648 1
a648 1
	    newHeight = firstWin->generic.height + splitDiff;
d650 1
a650 1
	  _makeInvisibleAndSetNewHeight (firstWin, newHeight);
d652 7
a658 7
	  TUI_CMD_WIN->generic.width += widthDiff;
	  newHeight = screenheight - TUI_CMD_WIN->generic.origin.y;
	  _makeInvisibleAndSetNewHeight (TUI_CMD_WIN, newHeight);
	  _makeVisibleWithNewHeight (firstWin);
	  _makeVisibleWithNewHeight (TUI_CMD_WIN);
	  if (firstWin->generic.content_size <= 0)
	    tui_erase_source_content (firstWin, EMPTY_SOURCE_PROMPT);
d661 1
a661 1
	  if (curLayout == SRC_DISASSEM_COMMAND)
d663 4
a666 4
	      firstWin = TUI_SRC_WIN;
	      firstWin->generic.width += widthDiff;
	      secondWin = TUI_DISASM_WIN;
	      secondWin->generic.width += widthDiff;
d670 4
a673 4
	      firstWin = TUI_DATA_WIN;
	      firstWin->generic.width += widthDiff;
	      secondWin = (struct tui_win_info *) (tui_source_windows ())->list[0];
	      secondWin->generic.width += widthDiff;
d677 4
a680 4
	  if (heightDiff == 0)
	    newHeight = firstWin->generic.height;
	  else if ((firstWin->generic.height +
		    secondWin->generic.height + (splitDiff * 2)) >=
d682 3
a684 3
	    newHeight = (screenheight - MIN_CMD_WIN_HEIGHT - 1) / 2;
	  else if ((firstWin->generic.height + splitDiff) <= 0)
	    newHeight = MIN_WIN_HEIGHT;
d686 2
a687 2
	    newHeight = firstWin->generic.height + splitDiff;
	  _makeInvisibleAndSetNewHeight (firstWin, newHeight);
d689 2
a690 2
	  if (firstWin == TUI_DATA_WIN && widthDiff != 0)
	    firstWin->detail.data_display_info.regs_column_count =
d692 2
a693 2
			  firstWin->detail.data_display_info.regs_display_type);
	  locator->width += widthDiff;
d697 4
a700 4
	  if (heightDiff == 0)
	    newHeight = secondWin->generic.height;
	  else if ((firstWin->generic.height +
		    secondWin->generic.height + (splitDiff * 2)) >=
d703 3
a705 3
	      newHeight = screenheight - MIN_CMD_WIN_HEIGHT - 1;
	      if (newHeight % 2)
		newHeight = (newHeight / 2) + 1;
d707 1
a707 1
		newHeight /= 2;
d709 2
a710 2
	  else if ((secondWin->generic.height + splitDiff) <= 0)
	    newHeight = MIN_WIN_HEIGHT;
d712 3
a714 3
	    newHeight = secondWin->generic.height + splitDiff;
	  secondWin->generic.origin.y = firstWin->generic.height - 1;
	  _makeInvisibleAndSetNewHeight (secondWin, newHeight);
d718 9
a726 9
	  _makeInvisibleAndSetNewHeight (
			     TUI_CMD_WIN, TUI_CMD_WIN->generic.height + cmdSplitDiff);
	  _makeVisibleWithNewHeight (firstWin);
	  _makeVisibleWithNewHeight (secondWin);
	  _makeVisibleWithNewHeight (TUI_CMD_WIN);
	  if (firstWin->generic.content_size <= 0)
	    tui_erase_source_content (firstWin, EMPTY_SOURCE_PROMPT);
	  if (secondWin->generic.content_size <= 0)
	    tui_erase_source_content (secondWin, EMPTY_SOURCE_PROMPT);
d733 1
a733 1
      for (winType = SRC_WIN; (winType < MAX_MAJOR_WINDOWS); winType++)
d735 2
a736 2
	  if (winType != CMD_WIN && (tui_win_list[winType] != NULL)
	      && !tui_win_list[winType]->generic.is_visible)
d738 2
a739 2
	      tui_free_window (tui_win_list[winType]);
	      tui_win_list[winType] = (struct tui_win_info *) NULL;
d744 1
a744 1
      if (winWithFocus != TUI_CMD_WIN)
d747 1
a747 2
  return;
}				/* tuiResizeAll */
d750 3
a752 6
/*
   ** tuiSigwinchHandler()
   **    SIGWINCH signal handler for the tui.  This signal handler is
   **    always called, even when the readline package clears signals
   **    because it is set as the old_sigwinch() (TUI only)
 */
d754 1
a754 1
tuiSigwinchHandler (int signal)
d761 1
a761 3

  return;
}				/* tuiSigwinchHandler */
a769 3
/*
   ** _tuiScrollForward_command().
 */
d771 1
a771 1
_tuiScrollForward_command (char *arg, int fromTTY)
d773 2
a774 2
  int numToScroll = 1;
  struct tui_win_info * winToScroll;
d779 1
a779 1
    _parseScrollingArgs (arg, &winToScroll, (int *) NULL);
d781 2
a782 2
    _parseScrollingArgs (arg, &winToScroll, &numToScroll);
  tui_scroll (FORWARD_SCROLL, winToScroll, numToScroll);
a785 3
/*
   ** _tuiScrollBackward_command().
 */
d787 1
a787 1
_tuiScrollBackward_command (char *arg, int fromTTY)
d789 2
a790 2
  int numToScroll = 1;
  struct tui_win_info * winToScroll;
d795 1
a795 1
    _parseScrollingArgs (arg, &winToScroll, (int *) NULL);
d797 2
a798 2
    _parseScrollingArgs (arg, &winToScroll, &numToScroll);
  tui_scroll (BACKWARD_SCROLL, winToScroll, numToScroll);
a801 3
/*
   ** _tuiScrollLeft_command().
 */
d803 1
a803 1
_tuiScrollLeft_command (char *arg, int fromTTY)
d805 2
a806 2
  int numToScroll;
  struct tui_win_info * winToScroll;
d810 2
a811 2
  _parseScrollingArgs (arg, &winToScroll, &numToScroll);
  tui_scroll (LEFT_SCROLL, winToScroll, numToScroll);
a814 3
/*
   ** _tuiScrollRight_command().
 */
d816 1
a816 1
_tuiScrollRight_command (char *arg, int fromTTY)
d818 2
a819 2
  int numToScroll;
  struct tui_win_info * winToScroll;
d823 2
a824 2
  _parseScrollingArgs (arg, &winToScroll, &numToScroll);
  tui_scroll (RIGHT_SCROLL, winToScroll, numToScroll);
d828 1
a828 4
/*
   ** _tuiSetFocus().
   **     Set focus to the window named by 'arg'
 */
d830 1
a830 1
_tuiSetFocus (char *arg, int fromTTY)
d834 1
a834 1
      char *bufPtr = (char *) xstrdup (arg);
d838 2
a839 2
      for (i = 0; (i < strlen (bufPtr)); i++)
	bufPtr[i] = toupper (arg[i]);
d841 1
a841 1
      if (subset_compare (bufPtr, "NEXT"))
d843 1
a843 1
      else if (subset_compare (bufPtr, "PREV"))
d846 1
a846 1
	win_info = tui_partial_win_by_name (bufPtr);
d859 1
a859 1
      xfree (bufPtr);
d865 1
a866 6
  return;
}				/* _tuiSetFocus */

/*
   ** _tuiSetFocus_command()
 */
d868 1
a868 1
_tuiSetFocus_command (char *arg, int fromTTY)
d872 1
a872 1
  _tuiSetFocus (arg, fromTTY);
a875 3
/*
   ** _tuiAllWindowsInfo().
 */
d877 1
a877 1
_tuiAllWindowsInfo (char *arg, int fromTTY)
d880 1
a880 1
  struct tui_win_info * winWithFocus = tui_win_with_focus ();
d885 1
a885 1
	if (winWithFocus == tui_win_list[type])
d894 1
a894 3

  return;
}				/* _tuiAllWindowsInfo */
a896 3
/*
   ** _tuiRefreshAll_command().
 */
d898 1
a898 1
_tuiRefreshAll_command (char *arg, int fromTTY)
d907 1
a907 4
/*
   ** _tuiSetWinTabWidth_command().
   **        Set the height of the specified window.
 */
d909 1
a909 1
_tuiSetTabWidth_command (char *arg, int fromTTY)
d923 1
a923 3

  return;
}				/* _tuiSetTabWidth_command */
d926 1
a926 4
/*
   ** _tuiSetWinHeight().
   **        Set the height of the specified window.
 */
d928 1
a928 1
_tuiSetWinHeight (char *arg, int fromTTY)
d935 1
a935 1
      char *bufPtr = buf;
d937 1
a937 1
      int newHeight, i;
d940 3
a942 3
      wname = bufPtr;
      bufPtr = strchr (bufPtr, ' ');
      if (bufPtr != (char *) NULL)
d944 1
a944 1
	  *bufPtr = (char) 0;
d959 1
a959 1
	      while (*(++bufPtr) == ' ')
d962 1
a962 1
	      if (*bufPtr != (char) 0)
d965 2
a966 2
		  int fixedSize = TRUE;
		  int inputNo;;
d968 1
a968 1
		  if (*bufPtr == '+' || *bufPtr == '-')
d970 1
a970 1
		      if (*bufPtr == '-')
d972 2
a973 2
		      fixedSize = FALSE;
		      bufPtr++;
d975 2
a976 2
		  inputNo = atoi (bufPtr);
		  if (inputNo > 0)
d979 3
a981 3
			inputNo *= (-1);
		      if (fixedSize)
			newHeight = inputNo;
d983 1
a983 1
			newHeight = win_info->generic.height + inputNo;
d988 2
a989 2
		      if (_tuiAdjustWinHeights (win_info,
						newHeight) == TUI_FAILURE)
d1009 1
d1011 1
a1011 7
  return;
}				/* _tuiSetWinHeight */

/*
   ** _tuiSetWinHeight_command().
   **        Set the height of the specified window, with va_list.
 */
d1013 1
a1013 1
_tuiSetWinHeight_command (char *arg, int fromTTY)
d1017 1
a1017 1
  _tuiSetWinHeight (arg, fromTTY);
d1021 2
a1022 5
/*
   ** _tuiXDBsetWinHeight().
   **        XDB Compatibility command for setting the window height.  This will
   **        increase or decrease the command window by the specified amount.
 */
d1024 1
a1024 1
_tuiXDBsetWinHeight (char *arg, int fromTTY)
d1030 1
a1030 1
      int inputNo = atoi (arg);
d1032 1
a1032 1
      if (inputNo > 0)
d1034 1
a1034 1
	  int newHeight = tui_term_height () - (inputNo + 1);
d1036 3
a1038 3
	  if (!_newHeightOk (tui_win_list[CMD_WIN], newHeight) ||
	      _tuiAdjustWinHeights (tui_win_list[CMD_WIN],
				    newHeight) == TUI_FAILURE)
d1048 1
d1050 1
a1050 7
  return;
}				/* _tuiXDBsetWinHeight */

/*
   ** _tuiSetWinHeight_command().
   **        Set the height of the specified window, with va_list.
 */
d1052 1
a1052 1
_tuiXDBsetWinHeight_command (char *arg, int fromTTY)
d1054 1
a1054 1
  _tuiXDBsetWinHeight (arg, fromTTY);
d1058 1
a1058 4
/*
   ** _tuiAdjustWinHeights().
   **        Function to adjust all window heights around the primary
 */
d1060 1
a1060 1
_tuiAdjustWinHeights (struct tui_win_info * primaryWinInfo, int newHeight)
d1064 1
a1064 1
  if (_newHeightOk (primaryWinInfo, newHeight))
d1067 1
a1067 1
      if (newHeight != primaryWinInfo->generic.height)
d1072 1
a1072 1
	  enum tui_layout_type curLayout = tui_current_layout ();
d1074 2
a1075 2
	  diff = (newHeight - primaryWinInfo->generic.height) * (-1);
	  if (curLayout == SRC_COMMAND || curLayout == DISASSEM_COMMAND)
d1077 1
a1077 1
	      struct tui_win_info * srcWinInfo;
d1079 2
a1080 2
	      _makeInvisibleAndSetNewHeight (primaryWinInfo, newHeight);
	      if (primaryWinInfo->generic.type == CMD_WIN)
d1083 1
a1083 1
		  srcWinInfo = win_info;
d1088 1
a1088 1
		  srcWinInfo = primaryWinInfo;
d1090 1
a1090 1
	      _makeInvisibleAndSetNewHeight (win_info,
d1093 4
a1096 4
	      _makeVisibleWithNewHeight (win_info);
	      _makeVisibleWithNewHeight (primaryWinInfo);
	      if (srcWinInfo->generic.content_size <= 0)
		tui_erase_source_content (srcWinInfo, EMPTY_SOURCE_PROMPT);
d1100 2
a1101 2
	      struct tui_win_info *firstWin;
	      struct tui_win_info *secondWin;
d1103 1
a1103 1
	      if (curLayout == SRC_DISASSEM_COMMAND)
d1105 2
a1106 2
		  firstWin = TUI_SRC_WIN;
		  secondWin = TUI_DISASM_WIN;
d1110 2
a1111 2
		  firstWin = TUI_DATA_WIN;
		  secondWin = (struct tui_win_info *) (tui_source_windows ())->list[0];
d1113 1
a1113 1
	      if (primaryWinInfo == TUI_CMD_WIN)
d1118 2
a1119 2
		  int firstSplitDiff = diff / 2;	/* subtract the locator */
		  int secondSplitDiff = firstSplitDiff;
d1123 2
a1124 2
		      if (firstWin->generic.height >
			  secondWin->generic.height)
d1126 1
a1126 1
			  firstSplitDiff--;
d1128 1
a1128 1
			  firstSplitDiff++;
d1132 1
a1132 1
			    secondSplitDiff--;
d1134 1
a1134 1
			    secondSplitDiff++;
d1138 1
a1138 1
		  while ((firstWin->generic.height + firstSplitDiff) < 3)
d1140 2
a1141 2
		      firstSplitDiff++;
		      secondSplitDiff--;
d1143 1
a1143 1
		  while ((secondWin->generic.height + secondSplitDiff) < 3)
d1145 2
a1146 2
		      secondSplitDiff++;
		      firstSplitDiff--;
d1148 6
a1153 6
		  _makeInvisibleAndSetNewHeight (
						  firstWin,
				 firstWin->generic.height + firstSplitDiff);
		  secondWin->generic.origin.y = firstWin->generic.height - 1;
		  _makeInvisibleAndSetNewHeight (
		    secondWin, secondWin->generic.height + secondSplitDiff);
d1155 1
a1155 1
		  _makeInvisibleAndSetNewHeight (TUI_CMD_WIN, newHeight);
d1169 2
a1170 2
			    if (primaryWinInfo == firstWin)
			      secondWin->generic.height--;
d1172 1
a1172 1
			      firstWin->generic.height--;
d1175 2
a1176 2
		  if (primaryWinInfo == firstWin)
		    _makeInvisibleAndSetNewHeight (firstWin, newHeight);
d1178 6
a1183 6
		    _makeInvisibleAndSetNewHeight (
						    firstWin,
						  firstWin->generic.height);
		  secondWin->generic.origin.y = firstWin->generic.height - 1;
		  if (primaryWinInfo == secondWin)
		    _makeInvisibleAndSetNewHeight (secondWin, newHeight);
d1185 2
a1186 2
		    _makeInvisibleAndSetNewHeight (
				      secondWin, secondWin->generic.height);
d1189 1
a1189 1
		    _makeInvisibleAndSetNewHeight (TUI_CMD_WIN, 1);
d1191 1
a1191 1
		    _makeInvisibleAndSetNewHeight (
d1194 7
a1200 7
	      _makeVisibleWithNewHeight (TUI_CMD_WIN);
	      _makeVisibleWithNewHeight (secondWin);
	      _makeVisibleWithNewHeight (firstWin);
	      if (firstWin->generic.content_size <= 0)
		tui_erase_source_content (firstWin, EMPTY_SOURCE_PROMPT);
	      if (secondWin->generic.content_size <= 0)
		tui_erase_source_content (secondWin, EMPTY_SOURCE_PROMPT);
d1206 1
a1206 1
}				/* _tuiAdjustWinHeights */
d1209 2
a1210 5
/*
   ** _makeInvisibleAndSetNewHeight().
   **        Function make the target window (and auxillary windows associated
   **        with the targer) invisible, and set the new height and location.
 */
d1212 1
a1212 1
_makeInvisibleAndSetNewHeight (struct tui_win_info * win_info, int height)
d1215 1
a1215 1
  struct tui_gen_win_info * genWinInfo;
d1231 4
a1234 4
      genWinInfo = win_info->detail.source_info.execution_info;
      tui_make_invisible (genWinInfo);
      genWinInfo->height = height;
      genWinInfo->origin.y = win_info->generic.origin.y;
d1236 1
a1236 1
	genWinInfo->viewport_height = height - 1;
d1238 1
a1238 1
	genWinInfo->viewport_height = height;
d1240 1
a1240 1
	genWinInfo->viewport_height--;
d1244 3
a1246 3
	  genWinInfo = tui_locator_win_info_ptr ();
	  tui_make_invisible (genWinInfo);
	  genWinInfo->origin.y = win_info->generic.origin.y + height;
d1253 1
a1253 1
	  genWinInfo = (struct tui_gen_win_info *) & ((struct tui_win_element *)
d1255 2
a1256 2
	  tui_delete_win (genWinInfo->handle);
	  genWinInfo->handle = (WINDOW *) NULL;
d1265 3
a1267 6
/*
   ** _makeVisibleWithNewHeight().
   **        Function to make the windows with new heights visible.
   **        This means re-creating the windows' content since the window
   **        had to be destroyed to be made invisible.
 */
d1269 1
a1269 1
_makeVisibleWithNewHeight (struct tui_win_info * win_info)
d1283 1
a1283 1
	  union tui_line_or_address lineOrAddr;
d1288 1
a1288 1
	    lineOrAddr.line_no =
d1291 1
a1291 1
	    lineOrAddr.addr =
d1294 1
a1294 1
	  tui_update_source_window (win_info, cursal.symtab, lineOrAddr, TRUE);
d1330 1
a1330 3

  return;
}				/* _makeVisibleWithNewHeight */
d1334 1
a1334 1
_newHeightOk (struct tui_win_info * primaryWinInfo, int newHeight)
d1336 1
a1336 1
  int ok = (newHeight < tui_term_height ());
d1343 1
a1343 1
      diff = (newHeight - primaryWinInfo->generic.height) * (-1);
d1346 6
a1351 6
	  ok = ((primaryWinInfo->generic.type == CMD_WIN &&
		 newHeight <= (tui_term_height () - 4) &&
		 newHeight >= MIN_CMD_WIN_HEIGHT) ||
		(primaryWinInfo->generic.type != CMD_WIN &&
		 newHeight <= (tui_term_height () - 2) &&
		 newHeight >= MIN_WIN_HEIGHT));
d1356 1
a1356 1
	      if (primaryWinInfo == TUI_CMD_WIN)
d1360 1
a1360 1
	      ok = ((newHeight +
d1366 3
a1368 3
	  int curTotalHeight, totalHeight, minHeight = 0;
	  struct tui_win_info *firstWin;
	  struct tui_win_info *secondWin;
d1372 2
a1373 2
	      firstWin = TUI_SRC_WIN;
	      secondWin = TUI_DISASM_WIN;
d1377 2
a1378 2
	      firstWin = TUI_DATA_WIN;
	      secondWin = (struct tui_win_info *) (tui_source_windows ())->list[0];
d1386 2
a1387 2
	  totalHeight = curTotalHeight =
	    (firstWin->generic.height + secondWin->generic.height - 1)
d1389 1
a1389 1
	  if (primaryWinInfo == TUI_CMD_WIN)
d1392 2
a1393 2
	      ok = ((firstWin->generic.height +
		     secondWin->generic.height + diff) >=
d1395 1
a1395 1
		    newHeight >= MIN_CMD_WIN_HEIGHT);
d1398 3
a1400 3
		  totalHeight = newHeight + (firstWin->generic.height +
					  secondWin->generic.height + diff);
		  minHeight = MIN_CMD_WIN_HEIGHT;
d1405 1
a1405 1
	      minHeight = MIN_WIN_HEIGHT;
d1417 2
a1418 2
		  if (primaryWinInfo == firstWin)
		    ok = (secondWin->generic.height + diff) >= minHeight;
d1420 1
a1420 1
		    ok = (firstWin->generic.height + diff) >= minHeight;
d1424 3
a1426 3
		  if (primaryWinInfo == firstWin)
		    totalHeight = newHeight +
		      secondWin->generic.height +
d1429 2
a1430 2
		    totalHeight = newHeight +
		      firstWin->generic.height +
d1439 1
a1439 1
	    ok = (newHeight >= minHeight && totalHeight <= curTotalHeight);
d1444 1
a1444 1
}				/* _newHeightOk */
a1446 3
/*
   ** _parseScrollingArgs().
 */
d1448 2
a1449 1
_parseScrollingArgs (char *arg, struct tui_win_info * * winToScroll, int *numToScroll)
d1451 3
a1453 3
  if (numToScroll)
    *numToScroll = 0;
  *winToScroll = tui_win_with_focus ();
d1461 1
a1461 1
      char *buf, *bufPtr;
d1464 2
a1465 2
      buf = bufPtr = xstrdup (arg);
      if (isdigit (*bufPtr))
d1467 1
a1467 1
	  char *numStr;
d1469 3
a1471 3
	  numStr = bufPtr;
	  bufPtr = strchr (bufPtr, ' ');
	  if (bufPtr != (char *) NULL)
d1473 4
a1476 4
	      *bufPtr = (char) 0;
	      if (numToScroll)
		*numToScroll = atoi (numStr);
	      bufPtr++;
d1478 2
a1479 2
	  else if (numToScroll)
	    *numToScroll = atoi (numStr);
d1483 1
a1483 1
      if (bufPtr != (char *) NULL)
d1488 2
a1489 2
	  if (*bufPtr == ' ')
	    while (*(++bufPtr) == ' ')
d1492 2
a1493 2
	  if (*bufPtr != (char) 0)
	    wname = bufPtr;
d1500 1
a1500 1
	  *winToScroll = tui_partial_win_by_name (wname);
d1502 2
a1503 2
	  if (*winToScroll == (struct tui_win_info *) NULL ||
	      !(*winToScroll)->generic.is_visible)
d1506 2
a1507 2
	  else if (*winToScroll == TUI_CMD_WIN)
	    *winToScroll = (struct tui_win_info *) (tui_source_windows ())->list[0];
d1511 1
a1511 3

  return;
}				/* _parseScrollingArgs */
@


1.12
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui.h (Opaque, OpaquePtr OpaqueList): Delete definition.
	(TuiPoint, TuiPointPtr): Ditto.
	(TuiStatus, TuiStatusPtr): Ditto.
	(TuiWinType, TuiWinTypePtr): Ditto.
	(struct tui_point): Rename _TuiPoint.
	(tui_get_low_disassembly_address): Rename
	tuiGetLowDisassemblyAddress.
	(tui_update_all_exec_infos): Rename tuiUpdateAllExecInfos.
	(tuiFree): Delete declaration.
	(OpaqueFuncPtr, TuiOpaqueFuncPtr): Delete definitions.
	(TuiVoidFuncPtr, TuiIntFuncPtr): Delete definitions.
	* tui/tui.c (tuiFree): Delete function.
	* cli/cli-cmds.c (disassemble_command): Update references.
	* tui/tui-data.c, tui/tui-data.h, tui/tui-disasm.c: Ditto.
	* tui/tui-layout.c, tui/tui-regs.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-win.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d418 1
a418 1
           tui_active ? cmdWin->generic.width : screenwidth);
d421 1
a421 1
           tui_active ? cmdWin->generic.height : screenheight);
d426 1
a426 1
/* Set the logical focus to winInfo.    */
d428 1
a428 1
tui_set_win_focus_to (struct tui_win_info * winInfo)
d430 1
a430 1
  if (m_winPtrNotNull (winInfo))
d434 2
a435 2
      if (m_winPtrNotNull (winWithFocus) &&
	  winWithFocus->generic.type != CMD_WIN)
d437 3
a439 3
      tui_set_win_with_focus (winInfo);
      if (winInfo->generic.type != CMD_WIN)
	tui_highlight_win (winInfo);
d449 1
a449 1
  if (winToScroll != cmdWin)
d461 1
a461 1
      if (winToScroll == srcWin)
d463 1
a463 1
      else if (winToScroll == disassemWin)
d465 1
a465 1
      else if (winToScroll == dataWin)
d473 1
a473 1
  if (winToScroll != cmdWin)
d485 1
a485 1
      if (winToScroll == srcWin)
d487 1
a487 1
      else if (winToScroll == disassemWin)
d489 1
a489 1
      else if (winToScroll == dataWin)
d498 1
a498 1
  if (winToScroll != cmdWin)
d510 1
a510 1
      if (winToScroll == srcWin || winToScroll == disassemWin)
d519 1
a519 1
  if (winToScroll != cmdWin)
d531 1
a531 1
      if (winToScroll == srcWin || winToScroll == disassemWin)
d569 1
a569 1
  tui_refresh_all (winList);
d572 1
a572 1
      if (winList[type] && winList[type]->generic.isVisible)
d578 4
a581 4
	      tui_show_source_content (winList[type]);
	      tui_check_and_display_highlight_if_needed (winList[type]);
	      tui_erase_exec_info_content (winList[type]);
	      tui_update_exec_info (winList[type]);
d620 2
a621 2
      if (winWithFocus != cmdWin)
	keypad (cmdWin->generic.handle, FALSE);
d659 4
a662 4
	  cmdWin->generic.origin.y = locator->origin.y + 1;
	  cmdWin->generic.width += widthDiff;
	  newHeight = screenheight - cmdWin->generic.origin.y;
	  _makeInvisibleAndSetNewHeight (cmdWin, newHeight);
d664 2
a665 2
	  _makeVisibleWithNewHeight (cmdWin);
	  if (firstWin->generic.contentSize <= 0)
d671 1
a671 1
	      firstWin = srcWin;
d673 1
a673 1
	      secondWin = disassemWin;
d678 1
a678 1
	      firstWin = dataWin;
d697 2
a698 2
	  if (firstWin == dataWin && widthDiff != 0)
	    firstWin->detail.dataDisplayInfo.regsColumnCount =
d700 1
a700 1
			  firstWin->detail.dataDisplayInfo.regsDisplayType);
d725 1
a725 1
	  cmdWin->generic.origin.y = locator->origin.y + 1;
d727 1
a727 1
			     cmdWin, cmdWin->generic.height + cmdSplitDiff);
d730 2
a731 2
	  _makeVisibleWithNewHeight (cmdWin);
	  if (firstWin->generic.contentSize <= 0)
d733 1
a733 1
	  if (secondWin->generic.contentSize <= 0)
d743 2
a744 2
	  if (winType != CMD_WIN && m_winPtrNotNull (winList[winType]) &&
	      !winList[winType]->generic.isVisible)
d746 2
a747 2
	      tui_free_window (winList[winType]);
	      winList[winType] = (struct tui_win_info *) NULL;
d752 2
a753 2
      if (winWithFocus != cmdWin)
	keypad (cmdWin->generic.handle, TRUE);
d865 1
a865 1
      struct tui_win_info * winInfo = (struct tui_win_info *) NULL;
d871 1
a871 1
	winInfo = tui_next_win (tui_win_with_focus ());
d873 1
a873 1
	winInfo = tui_prev_win (tui_win_with_focus ());
d875 1
a875 1
	winInfo = tui_partial_win_by_name (bufPtr);
d877 1
a877 1
      if (winInfo == (struct tui_win_info *) NULL || !winInfo->generic.isVisible)
d882 2
a883 2
	  tui_set_win_focus_to (winInfo);
	  keypad (cmdWin->generic.handle, (winInfo != cmdWin));
d886 1
a886 1
      if (dataWin && dataWin->generic.isVisible)
d920 1
a920 1
    if (winList[type] && winList[type]->generic.isVisible)
d922 1
a922 1
	if (winWithFocus == winList[type])
d924 2
a925 2
			   tui_win_name (&winList[type]->generic),
			   winList[type]->generic.height);
d928 2
a929 2
			   tui_win_name (&winList[type]->generic),
			   winList[type]->generic.height);
d988 1
a988 1
      struct tui_win_info * winInfo;
d1001 1
a1001 1
	  winInfo = tui_partial_win_by_name (wname);
d1003 1
a1003 1
	  if (winInfo == (struct tui_win_info *) NULL || !winInfo->generic.isVisible)
d1033 1
a1033 1
			newHeight = winInfo->generic.height + inputNo;
d1038 1
a1038 1
		      if (_tuiAdjustWinHeights (winInfo,
d1094 2
a1095 2
	  if (!_newHeightOk (winList[CMD_WIN], newHeight) ||
	      _tuiAdjustWinHeights (winList[CMD_WIN],
d1136 1
a1136 1
	  struct tui_win_info * winInfo;
d1148 2
a1149 2
		  winInfo = (struct tui_win_info *) (tui_source_windows ())->list[0];
		  srcWinInfo = winInfo;
d1153 1
a1153 1
		  winInfo = winList[CMD_WIN];
d1156 4
a1159 4
	      _makeInvisibleAndSetNewHeight (winInfo,
					     winInfo->generic.height + diff);
	      cmdWin->generic.origin.y = locator->origin.y + 1;
	      _makeVisibleWithNewHeight (winInfo);
d1161 1
a1161 1
	      if (srcWinInfo->generic.contentSize <= 0)
d1171 2
a1172 2
		  firstWin = srcWin;
		  secondWin = disassemWin;
d1176 1
a1176 1
		  firstWin = dataWin;
d1179 1
a1179 1
	      if (primaryWinInfo == cmdWin)
d1220 2
a1221 2
		  cmdWin->generic.origin.y = locator->origin.y + 1;
		  _makeInvisibleAndSetNewHeight (cmdWin, newHeight);
d1225 1
a1225 1
		  if ((cmdWin->generic.height + diff) < 1)
d1230 1
a1230 1
		      if ((cmdWin->generic.height + diff) < 1)
d1233 1
a1233 1
			  for (i = cmdWin->generic.height + diff;
d1253 3
a1255 3
		  cmdWin->generic.origin.y = locator->origin.y + 1;
		  if ((cmdWin->generic.height + diff) < 1)
		    _makeInvisibleAndSetNewHeight (cmdWin, 1);
d1258 1
a1258 1
				     cmdWin, cmdWin->generic.height + diff);
d1260 1
a1260 1
	      _makeVisibleWithNewHeight (cmdWin);
d1263 1
a1263 1
	      if (firstWin->generic.contentSize <= 0)
d1265 1
a1265 1
	      if (secondWin->generic.contentSize <= 0)
d1281 1
a1281 1
_makeInvisibleAndSetNewHeight (struct tui_win_info * winInfo, int height)
d1286 2
a1287 2
  tui_make_invisible (&winInfo->generic);
  winInfo->generic.height = height;
d1289 1
a1289 1
    winInfo->generic.viewportHeight = height - 1;
d1291 3
a1293 3
    winInfo->generic.viewportHeight = height;
  if (winInfo != cmdWin)
    winInfo->generic.viewportHeight--;
d1295 2
a1296 2
  /* Now deal with the auxillary windows associated with winInfo */
  switch (winInfo->generic.type)
d1300 1
a1300 1
      genWinInfo = winInfo->detail.sourceInfo.executionInfo;
d1303 1
a1303 1
      genWinInfo->origin.y = winInfo->generic.origin.y;
d1305 1
a1305 1
	genWinInfo->viewportHeight = height - 1;
d1307 3
a1309 3
	genWinInfo->viewportHeight = height;
      if (winInfo != cmdWin)
	genWinInfo->viewportHeight--;
d1311 1
a1311 1
      if (m_hasLocator (winInfo))
d1315 1
a1315 1
	  genWinInfo->origin.y = winInfo->generic.origin.y + height;
d1320 1
a1320 1
      for (i = 0; i < winInfo->generic.contentSize; i++)
d1323 1
a1323 1
		      winInfo->generic.content[i])->whichElement.dataWindow;
d1341 1
a1341 1
_makeVisibleWithNewHeight (struct tui_win_info * winInfo)
d1345 3
a1347 3
  tui_make_visible (&winInfo->generic);
  tui_check_and_display_highlight_if_needed (winInfo);
  switch (winInfo->generic.type)
d1351 3
a1353 3
      tui_free_win_content (winInfo->detail.sourceInfo.executionInfo);
      tui_make_visible (winInfo->detail.sourceInfo.executionInfo);
      if (winInfo->generic.content != NULL)
d1359 3
a1361 3
	  if (winInfo->generic.type == SRC_WIN)
	    lineOrAddr.lineNo =
	      winInfo->detail.sourceInfo.startLineOrAddr.lineNo;
d1364 3
a1366 3
	      winInfo->detail.sourceInfo.startLineOrAddr.addr;
	  tui_free_win_content (&winInfo->generic);
	  tui_update_source_window (winInfo, cursal.symtab, lineOrAddr, TRUE);
d1375 2
a1376 2
	  if (winInfo->generic.type == SRC_WIN)
	    line.lineNo = cursal.line;
d1381 1
a1381 1
	  tui_update_source_window (winInfo, s, line, TRUE);
d1383 1
a1383 1
      if (m_hasLocator (winInfo))
d1393 5
a1397 5
      winInfo->detail.commandInfo.curLine = 0;
      winInfo->detail.commandInfo.curch = 0;
      wmove (winInfo->generic.handle,
	     winInfo->detail.commandInfo.curLine,
	     winInfo->detail.commandInfo.curch);
d1415 1
a1415 1
      enum tui_layout_type curLayout = tui_current_layout ();
d1418 1
a1418 1
      if (curLayout == SRC_COMMAND || curLayout == DISASSEM_COMMAND)
d1428 1
a1428 1
	      struct tui_win_info * winInfo;
d1430 2
a1431 2
	      if (primaryWinInfo == cmdWin)
		winInfo = (struct tui_win_info *) (tui_source_windows ())->list[0];
d1433 1
a1433 1
		winInfo = cmdWin;
d1435 1
a1435 1
		     (winInfo->generic.height + diff)) <= tui_term_height ());
d1444 1
a1444 1
	  if (curLayout == SRC_DISASSEM_COMMAND)
d1446 2
a1447 2
	      firstWin = srcWin;
	      secondWin = disassemWin;
d1451 1
a1451 1
	      firstWin = dataWin;
d1462 2
a1463 2
	    + cmdWin->generic.height + 1 /*locator */ ;
	  if (primaryWinInfo == cmdWin)
d1485 1
a1485 1
	      ok = ((cmdWin->generic.height + diff) > 0);
d1501 1
a1501 1
		      cmdWin->generic.height + diff;
d1505 1
a1505 1
		      cmdWin->generic.height + diff;
d1579 1
a1579 1
	      !(*winToScroll)->generic.isVisible)
d1582 1
a1582 1
	  else if (*winToScroll == cmdWin)
@


1.11
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

        * tui/tui-data.h (tui_win_element): Rename TuiWinElement.
        (tui_exec_info_content): Rename TuiExecInfoContent.
        (TuiGenWinInfo, TuiGenWinInfoPtr): Delete definitions.
        (TuiWinInfo, TuiWinInfoPtr): Ditto.
        (TuiScrollDirection, TuiScrollDirectionPtr): Ditto.
        (TuiList, TuiListPtr): Ditto.
        (TuiLayoutType, TuiLayoutTypePtr): Ditto.
        (TuiDataType, TuiDataTypePtr): Ditto.
        (TuiRegisterDisplayType, TuiRegisterDisplayTypePtr): Ditto.
        (TuiLineOrAddress, TuiLineOrAddressPtr): Ditto.
        (TuiLayoutDef, TuiLayoutDefPtr): Ditto.
        (TuiSourceElement, TuiSourceElementPtr): Ditto.
        (TuiDataElement, TuiDataElementPtr): Ditto.
        (TuiWinElement, TuiWinElementPtr): Ditto.
        (TuiDataInfo, TuiDataInfoPtr): Ditto.
        (TuiCommandElement, TuiCommandElementPtr): Ditto.
        (TuiLocatorElement, TuiLocatorElementPtr): Ditto.
        (TuiWhichElement, TuiWhichElementPtr): Ditto.
        (TuiSourceInfo, TuiSourceInfoPtr): Ditto.
        (TuiCommandInfo, TuiCommandInfoPtr): Ditto.
        * tui/tui-command.c, tui/tui-data.c: Update references.
        * tui/tui-data.h, tui/tui-disasm.c, tui/tui-layout.c: Ditto.
        * tui/tui-regs.c, tui/tui-source.c, tui/tui-stack.c: Ditto.
        * tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
        * tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d66 1
a66 1
static TuiStatus _tuiAdjustWinHeights (struct tui_win_info *, int);
d566 1
a566 1
  TuiWinType type;
d616 1
a616 1
      TuiWinType winType;
d888 1
a888 1
      tuiFree (bufPtr);
d916 1
a916 1
  TuiWinType type;
d1055 1
a1055 1
	tuiFree (buf);
d1125 1
a1125 1
static TuiStatus
d1128 1
a1128 1
  TuiStatus status = TUI_FAILURE;
d1353 1
a1353 1
      if (winInfo->generic.content != (OpaquePtr) NULL)
d1585 1
a1585 1
      tuiFree (buf);
@


1.10
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-data.h (struct tui_list): Rename _TuiList.
	(enum tui_data_type): Rename _TuiDataType.
	(struct tui_layout_def): Rename _TuiLayoutDef.
	(struct tui_source_element): Rename _TuiSourceElement.
	(struct tui_data_element): Rename _TuiDataElement.
	(struct tui_command_element): Rename _TuiCommandElement.
	(struct tui_locator_element): Rename _TuiLocatorElement.
	(union tui_which_element): Define.
	(struct tui_win_element): Rename _TuiWinElement.
	(struct tui_data_info): Rename _TuiDataInfo.
	(struct tui_source_info): Rename _TuiSourceInfo.
	(struct tui_command_info): Rename _TuiCommandInfo.
	(tui_initialize_static_data): Rename initializeStaticData.
	(tui_alloc_generic_win_info): Rename allocGenericWinInfo.
	(tui_alloc_win_info): Rename allocWinInfo.
	(tui_init_generic_part): Rename initGenericPart.
	(tui_init_win_info): Rename initWinInfo.
	(tui_alloc_content): Rename allocContent.
	(tui_add_content_elements): Rename addContentElements.
	(tui_init_content_element): Rename initContentElement.
	(tui_free_window): Rename freeWindow.
	(tui_free_win_content): Rename freeWinContent.
	(tui_free_data_content): Rename freeDataContent.
	(tui_free_all_source_wins_content): Rename
	freeAllSourceWinsContent.
	(tui_del_window): Rename tuiDelWindow.
	(tui_del_data_windows): Rename tuiDelDataWindows.
	(tui_partial_win_by_name): Rename partialWinByName.
	(tui_win_name): Rename winName.
	(tui_current_layout): Rename currentLayout.
	(tui_set_current_layout_to): Rename setCurrentLayoutTo.
	(tui_term_height): Rename termHeight.
	(tui_set_term_height_to): Rename setTermHeightTo.
	(tui_term_width): Rename termWidth.
	(tui_set_term_width_to): Rename setTermWidthTo.
	(tui_set_gen_win_origin): Rename setGenWinOrigin.
	(tui_locator_win_info_ptr): Rename locatorWinInfoPtr.
	(tui_source_exec_info_win_ptr): Rename tui_gen_win_info.
	(tui_disassem_exec_info_win_ptr): Rename disassemExecInfoWinPtr.
	(tui_source_windows): Rename sourceWindows.
	(tui_clear_source_windows): Rename clearSourceWindows.
	(tui_clear_source_windows_detail): Rename
	clearSourceWindowsDetail.
	(tui_clear_win_detail): Rename clearWinDetail.
	(tui_add_to_source_windows): Rename tuiAddToSourceWindows.
	(tui_default_tab_len): Rename tuiDefaultTabLen.
	(tui_set_default_tab_len): Rename tuiSetDefaultTabLen.
	(tui_win_with_focus): Rename tuiWinWithFocus.
	(tui_set_win_with_focus): Rename tuiSetWinWithFocus.
	(tui_layout_def): Rename tuiLayoutDef.
	(tui_win_resized): Rename tuiWinResized.
	(tui_set_win_resized_to): Rename tuiSetWinResizedTo.
	(tui_next_win): Rename tuiNextWin.
	(tui_prev_win): Rename tuiPrevWin.
	(tui_add_to_source_windows): Rename addToSourceWindows.
	* tui/tui-winsource.c, tui/tui-win.c: Update references.
	* tui/tui-layout.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-io.c: Ditto.
	* tui/tui.c, tui/tui-data.c: Ditto.
	* tui/tui-interp.c, tui/tui-data.c: Ditto.
	* tui/tui-disasm.c, tui/tui-command.c: Ditto.
@
text
@d64 4
a67 4
static void _makeVisibleWithNewHeight (TuiWinInfoPtr);
static void _makeInvisibleAndSetNewHeight (TuiWinInfoPtr, int);
static TuiStatus _tuiAdjustWinHeights (TuiWinInfoPtr, int);
static int _newHeightOk (TuiWinInfoPtr, int);
d78 1
a78 1
static void _parseScrollingArgs (char *, TuiWinInfoPtr *, int *);
d428 1
a428 1
tui_set_win_focus_to (TuiWinInfoPtr winInfo)
d432 1
a432 1
      TuiWinInfoPtr winWithFocus = tui_win_with_focus ();
d447 1
a447 1
tui_scroll_forward (TuiWinInfoPtr winToScroll, int numToScroll)
d471 1
a471 1
tui_scroll_backward (TuiWinInfoPtr winToScroll, int numToScroll)
d496 1
a496 1
tui_scroll_left (TuiWinInfoPtr winToScroll, int numToScroll)
d517 1
a517 1
tui_scroll_right (TuiWinInfoPtr winToScroll, int numToScroll)
d539 2
a540 2
tui_scroll (TuiScrollDirection direction,
	    TuiWinInfoPtr winToScroll,
d611 5
a615 4
      TuiLayoutType curLayout = tui_current_layout ();
      TuiWinInfoPtr winWithFocus = tui_win_with_focus ();
      TuiWinInfoPtr firstWin, secondWin;
      TuiGenWinInfoPtr locator = tui_locator_win_info_ptr ();
d644 1
a644 1
	  firstWin = (TuiWinInfoPtr) (tui_source_windows ())->list[0];
d680 1
a680 1
	      secondWin = (TuiWinInfoPtr) (tui_source_windows ())->list[0];
d747 1
a747 1
	      winList[winType] = (TuiWinInfoPtr) NULL;
d791 1
a791 1
  TuiWinInfoPtr winToScroll;
d810 1
a810 1
  TuiWinInfoPtr winToScroll;
d829 1
a829 1
  TuiWinInfoPtr winToScroll;
d845 1
a845 1
  TuiWinInfoPtr winToScroll;
d865 1
a865 1
      TuiWinInfoPtr winInfo = (TuiWinInfoPtr) NULL;
d877 1
a877 1
      if (winInfo == (TuiWinInfoPtr) NULL || !winInfo->generic.isVisible)
d890 1
a890 1
		       tui_win_name ((TuiGenWinInfoPtr) tui_win_with_focus ()));
d917 1
a917 1
  TuiWinInfoPtr winWithFocus = tui_win_with_focus ();
d988 1
a988 1
      TuiWinInfoPtr winInfo;
d1003 1
a1003 1
	  if (winInfo == (TuiWinInfoPtr) NULL || !winInfo->generic.isVisible)
d1126 1
a1126 1
_tuiAdjustWinHeights (TuiWinInfoPtr primaryWinInfo, int newHeight)
d1136 3
a1138 3
	  TuiWinInfoPtr winInfo;
	  TuiGenWinInfoPtr locator = tui_locator_win_info_ptr ();
	  TuiLayoutType curLayout = tui_current_layout ();
d1143 1
a1143 1
	      TuiWinInfoPtr srcWinInfo;
d1148 1
a1148 1
		  winInfo = (TuiWinInfoPtr) (tui_source_windows ())->list[0];
d1166 2
a1167 1
	      TuiWinInfoPtr firstWin, secondWin;
d1177 1
a1177 1
		  secondWin = (TuiWinInfoPtr) (tui_source_windows ())->list[0];
d1281 1
a1281 1
_makeInvisibleAndSetNewHeight (TuiWinInfoPtr winInfo, int height)
d1284 1
a1284 1
  TuiGenWinInfoPtr genWinInfo;
d1322 1
a1322 1
	  genWinInfo = (TuiGenWinInfoPtr) & ((TuiWinElementPtr)
d1341 1
a1341 1
_makeVisibleWithNewHeight (TuiWinInfoPtr winInfo)
d1355 1
a1355 1
	  TuiLineOrAddress lineOrAddr;
d1370 1
a1370 1
	  TuiLineOrAddress line;
d1408 1
a1408 1
_newHeightOk (TuiWinInfoPtr primaryWinInfo, int newHeight)
d1415 1
a1415 1
      TuiLayoutType curLayout = tui_current_layout ();
d1428 1
a1428 1
	      TuiWinInfoPtr winInfo;
d1431 1
a1431 1
		winInfo = (TuiWinInfoPtr) (tui_source_windows ())->list[0];
d1441 2
a1442 1
	  TuiWinInfoPtr firstWin, secondWin;
d1452 1
a1452 1
	      secondWin = (TuiWinInfoPtr) (tui_source_windows ())->list[0];
d1525 1
a1525 1
_parseScrollingArgs (char *arg, TuiWinInfoPtr * winToScroll, int *numToScroll)
d1578 1
a1578 1
	  if (*winToScroll == (TuiWinInfoPtr) NULL ||
d1583 1
a1583 1
	    *winToScroll = (TuiWinInfoPtr) (tui_source_windows ())->list[0];
@


1.9
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-source.h: Update copyright.  Include "tui-data.h".
	(struct symtab): Declare.
	(tui_set_source_content): Rename tuiSetSourceContent.
	(tui_show_symtab_source): Rename tuiShowSource.
	(tui_source_is_displayed): Rename tuiSourceIsDisplayed.
	(tui_vertical_source_scroll): Rename tuiVerticalSourceScroll.
	* tui/tui-source.c: Update copyright.  Update references.
	* tui/tui-win.c, tui/tui-winsource.c: Update references.
	* tui/tui-stack.c: Update references.
@
text
@d432 1
a432 1
      TuiWinInfoPtr winWithFocus = tuiWinWithFocus ();
d437 1
a437 1
      tuiSetWinWithFocus (winInfo);
d607 2
a608 2
  widthDiff = screenwidth - termWidth ();
  heightDiff = screenheight - termHeight ();
d611 2
a612 2
      TuiLayoutType curLayout = currentLayout ();
      TuiWinInfoPtr winWithFocus = tuiWinWithFocus ();
d614 1
a614 1
      TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
d622 2
a623 2
      setTermHeightTo (screenheight);
      setTermWidthTo (screenwidth);
d643 1
a643 1
	  firstWin = (TuiWinInfoPtr) (sourceWindows ())->list[0];
d679 1
a679 1
	      secondWin = (TuiWinInfoPtr) (sourceWindows ())->list[0];
d745 1
a745 1
	      freeWindow (winList[winType]);
d749 1
a749 1
      tuiSetWinResizedTo (TRUE);
d771 1
a771 1
  tuiSetWinResizedTo (TRUE);
d870 1
a870 1
	winInfo = tuiNextWin (tuiWinWithFocus ());
d872 1
a872 1
	winInfo = tuiPrevWin (tuiWinWithFocus ());
d874 1
a874 1
	winInfo = partialWinByName (bufPtr);
d889 1
a889 1
		       winName ((TuiGenWinInfoPtr) tuiWinWithFocus ()));
d916 1
a916 1
  TuiWinInfoPtr winWithFocus = tuiWinWithFocus ();
d923 1
a923 1
			   winName (&winList[type]->generic),
d927 1
a927 1
			   winName (&winList[type]->generic),
d963 1
a963 1
	tuiSetDefaultTabLen (ts);
d1000 1
a1000 1
	  winInfo = partialWinByName (wname);
d1091 1
a1091 1
	  int newHeight = termHeight () - (inputNo + 1);
d1136 2
a1137 2
	  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
	  TuiLayoutType curLayout = currentLayout ();
d1147 1
a1147 1
		  winInfo = (TuiWinInfoPtr) (sourceWindows ())->list[0];
d1175 1
a1175 1
		  secondWin = (TuiWinInfoPtr) (sourceWindows ())->list[0];
d1311 1
a1311 1
	  genWinInfo = locatorWinInfoPtr ();
d1349 1
a1349 1
      freeWinContent (winInfo->detail.sourceInfo.executionInfo);
d1363 1
a1363 1
	  freeWinContent (&winInfo->generic);
d1383 1
a1383 1
	  tui_make_visible (locatorWinInfoPtr ());
d1408 1
a1408 1
  int ok = (newHeight < termHeight ());
d1413 1
a1413 1
      TuiLayoutType curLayout = currentLayout ();
d1419 1
a1419 1
		 newHeight <= (termHeight () - 4) &&
d1422 1
a1422 1
		 newHeight <= (termHeight () - 2) &&
d1429 1
a1429 1
		winInfo = (TuiWinInfoPtr) (sourceWindows ())->list[0];
d1433 1
a1433 1
		     (winInfo->generic.height + diff)) <= termHeight ());
d1449 1
a1449 1
	      secondWin = (TuiWinInfoPtr) (sourceWindows ())->list[0];
d1526 1
a1526 1
  *winToScroll = tuiWinWithFocus ();
d1573 1
a1573 1
	  *winToScroll = partialWinByName (wname);
d1580 1
a1580 1
	    *winToScroll = (TuiWinInfoPtr) (sourceWindows ())->list[0];
@


1.8
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-win.h: Update copyright.  Include "tui-data.h".
	(struct tui_win_info): Declare.
	(tui_scroll_forward): Rename tuiScrollForward.
	(tui_scroll_backward): Rename tuiScrollBackward.
	(tui_scroll_left): Rename tuiScrollLeft.
	(tui_scroll_right): Rename tuiScrollRight.
	(tui_set_win_focus_to): Rename tuiSetWinFocusTo.
	(tui_resize_all): Rename tuiResizeAll.
	(tui_refresh_all_win): Rename tuiRefreshAll.
	(tui_sigwinch_handler): Rename tuiSigwinchHandler.
	* tui/tui-layout.c, * tui/tui-io.c: Update references.
	* tui/tui-wingeneral.h, * tui/tui.c: Update references.
	* tui/tui-disasm.c, * tui/tui-command.c: Update references.
@
text
@d462 1
a462 1
	tuiVerticalSourceScroll (FORWARD_SCROLL, _numToScroll);
d486 1
a486 1
	tuiVerticalSourceScroll (BACKWARD_SCROLL, _numToScroll);
@


1.7
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-windata.h: Update copyright.  Include "tui-data.h".
	(tui_erase_data_content): Rename tuiEraseDataContent.
	(tui_display_all_data): Rename tuiDisplayAllData.
	(tui_check_data_values): Rename tuiCheckDataValues.
	(tui_display_data_from_line): Rename tuiDisplayDataFromLine.
	(tui_first_data_item_displayed): Rename tuiFirstDataItemDisplayed.
	(tui_first_data_element_no_in_line): Rename
	tuiFirstDataElementNoInLine.
	(tui_delete_data_content_windows): Rename
	tuiDeleteDataContentWindows.
	(tui_refresh_data_win): Rename tuiRefreshDataWin.
	(tui_display_data_from): Rename tuiDisplayDataFrom.
	(tui_vertical_data_scroll): Rename tuiVerticalDataScroll.
	* tui/tui-windata.c, tui/tui-hooks.c: Update references.
	* tui/tui-win.c, tui/tui-regs.c: Update references.
	* tui/tui-layout.c, tui/tui.c: Update references.
@
text
@d426 1
a426 4
/*
   ** tuiSetWinFocusTo
   **        Set the logical focus to winInfo
 */
d428 1
a428 1
tuiSetWinFocusTo (TuiWinInfoPtr winInfo)
a445 3
/*
   ** tuiScrollForward().
 */
d447 1
a447 1
tuiScrollForward (TuiWinInfoPtr winToScroll, int numToScroll)
d468 1
a469 7
  return;
}				/* tuiScrollForward */


/*
   ** tuiScrollBackward().
 */
d471 1
a471 1
tuiScrollBackward (TuiWinInfoPtr winToScroll, int numToScroll)
d492 1
a492 2
  return;
}				/* tuiScrollBackward */
a494 3
/*
   ** tuiScrollLeft().
 */
d496 1
a496 1
tuiScrollLeft (TuiWinInfoPtr winToScroll, int numToScroll)
d513 1
a513 2
  return;
}				/* tuiScrollLeft */
a515 3
/*
   ** tuiScrollRight().
 */
d517 1
a517 1
tuiScrollRight (TuiWinInfoPtr winToScroll, int numToScroll)
d534 1
a534 2
  return;
}				/* tuiScrollRight */
d537 1
a537 4
/*
   ** tui_scroll().
   **    Scroll a window.  Arguments are passed through a va_list.
 */
d546 1
a546 1
      tuiScrollForward (winToScroll, numToScroll);
d549 1
a549 1
      tuiScrollBackward (winToScroll, numToScroll);
d552 1
a552 1
      tuiScrollLeft (winToScroll, numToScroll);
d555 1
a555 1
      tuiScrollRight (winToScroll, numToScroll);
a562 3
/*
   ** tuiRefreshAll().
 */
d564 1
a564 1
tuiRefreshAll (void)
d881 1
a881 1
	  tuiSetWinFocusTo (winInfo);
d944 1
a944 1
  tuiRefreshAll ();
@


1.6
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-wingeneral.h: Update copyright.
	(m_allBeVisible): Delete macro.
	(m_allBeInvisible): Delete macro.
	(struct tui_gen_win_info): Declare.
	(struct tui_win_info): Declare.
	(tui_unhighlight_win): Rename unhighlightWin.
	(tui_make_visible, tui_make_invisible): Replace makeVisible.
	(tui_make_all_visible, tui_make_all_invisible): Replace makeAllVisible.
	(tui_make_window): Rename makeWindow.
	(tui_copy_win): Rename copyWin.
	(tui_box_win): Rename boxWin.
	(tui_highlight_win): Rename highlightWin.
	(tui_check_and_display_highlight_if_needed): Rename
	checkAndDisplayHighlightIfNeeded.
	(tui_refresh_all): Rename refreshAll.
	(tui_delete_win): Rename tuiDelwin.
	(tui_refresh_win): Rename tuiRefreshWin.
	* tui/tui-wingeneral.c (make_visible): Rename makeVisible.
	(tui_make_visible, tui_make_invisible): New functions.
	(tui_make_all_visible, tui_make_all_invisible): New functions.
	(make_all_visible): Rename makeAllVisible.
	* tui/tui-winsource.c, tui/tui-windata.c: Update references.
	* tui/tui-data.c, tui/tui-winsource.c: Update references.
	* tui/tui-windata.c, tui/tui-win.c: Update references.
	* tui/tui-regs.c, tui/tui-layout.c: Update references.
	* tui/tui-data.h (struct tui_gen_win_info): Rename _TuiGenWinInfo.
@
text
@d472 1
a472 1
	tuiVerticalDataScroll (FORWARD_SCROLL, _numToScroll);
d502 1
a502 1
	tuiVerticalDataScroll (BACKWARD_SCROLL, _numToScroll);
d611 1
a611 1
	      tuiRefreshDataWin ();
d913 1
a913 1
	tuiRefreshDataWin ();
d1415 1
a1415 1
      tuiDisplayAllData ();
@


1.5
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-source.h: Do not include "defs.h".
	(struct tui_win_info): Declare.
	(tui_set_source_content_nil): Declare.
	* tui/tui-data.h (struct tui_win_info): Rename _TuiWinInfo.
	(union tui_line_or_address): Rename _TuiLineOrAddress.
	* tui/tui-winsource.h: Update copyright.  Include "tui-data.h".
	(tui_update_source_window): Rename tuiUpdateSourceWindow.
	(tui_update_source_window_as_is): Rename
	tuiUpdateSourceWindowAsIs.
	(tui_update_source_windows_with_addr): Rename
	tuiUpdateSourceWindowsWithAddr.
	(tui_update_source_windows_with_line): Rename
	tuiUpdateSourceWindowsWithLine.
	(tui_clear_source_content): Rename tuiClearSourceContent.
	(tui_erase_source_content): Rename tuiEraseSourceContent.
	(tui_set_source_content_nil): Rename tuiSetSourceContentNil.
	(tui_show_source_content): Rename tuiShowSourceContent.
	(tui_horizontal_source_scroll): Rename tuiHorizontalSourceScroll.
	(tui_set_exec_info_content): Rename tuiSetExecInfoContent.
	(tui_show_exec_info_content): Rename tuiShowExecInfoContent.
	(tui_erase_exec_info_content): Rename tuiEraseExecInfoContent.
	(tui_clear_exec_info_content): Rename tuiClearExecInfoContent.
	(tui_update_exec_info): Rename tuiUpdateExecInfo.
	(tui_set_is_exec_point_at): Rename tuiSetIsExecPointAt.
	(tui_alloc_source_buffer): Rename tuiAllocSourceBuffer.
	(tui_line_is_displayed): Rename tuiLineIsDisplayed.
	(tui_addr_is_displayed): Rename tuiAddrIsDisplayed.
	(struct tui_win_info): Declare.
	* tui/tui-stack.c: Update references.
	* tui/tui-layout.c, tui/tui-winsource.c: Ditto.
	* tui/tui-win.c, tui/tui-source.c: Ditto.
	* tui/tui.c, tui/tui-disasm.c: Ditto.
@
text
@d439 1
a439 1
	unhighlightWin (winWithFocus);
d442 1
a442 1
	highlightWin (winInfo);
d596 1
a596 1
  refreshAll (winList);
d606 1
a606 1
	      checkAndDisplayHighlightIfNeeded (winList[type]);
d1311 1
a1311 2

  m_beInvisible (&winInfo->generic);
d1326 1
a1326 1
      m_beInvisible (genWinInfo);
d1339 1
a1339 1
	  m_beInvisible (genWinInfo);
d1349 1
a1349 1
	  tuiDelwin (genWinInfo->handle);
d1370 2
a1371 2
  m_beVisible (&winInfo->generic);
  checkAndDisplayHighlightIfNeeded (winInfo);
d1377 1
a1377 1
      m_beVisible (winInfo->detail.sourceInfo.executionInfo);
d1410 1
a1410 1
	  m_beVisible (locatorWinInfoPtr ());
@


1.4
log
@2004-01-28  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-stack.h: Update copyright.
	(struct frame_info): Add opaque declaration.
	(tui_update_locator_filename): Rename tuiUpdateLocatorFilename.
	(tui_show_locator_content): Rename tuiShowLocatorContent.
	(tui_show_frame_info): Rename tuiShowFrameInfo.
	* tui/tui-stack.c: Update copyright.  Update references.
	* tui/tui-winsource.c: Update references.
	* tui/tui-win.c: Update references.
	* tui/tui-layout.c: Update references.
	* tui/tui-hooks.c: Update copyright, update references.
	* tui/tui.c: Update copyright, update references.
	* tui/tui-disasm.c: Update references.
@
text
@d527 1
a527 1
	tuiHorizontalSourceScroll (winToScroll, LEFT_SCROLL, _numToScroll);
d552 1
a552 1
	tuiHorizontalSourceScroll (winToScroll, RIGHT_SCROLL, _numToScroll);
d605 1
a605 1
	      tuiShowSourceContent (winList[type]);
d607 2
a608 2
	      tuiEraseExecInfoContent (winList[type]);
	      tuiUpdateExecInfo (winList[type]);
d692 1
a692 1
	    tuiEraseSourceContent (firstWin, EMPTY_SOURCE_PROMPT);
d758 1
a758 1
	    tuiEraseSourceContent (firstWin, EMPTY_SOURCE_PROMPT);
d760 1
a760 1
	    tuiEraseSourceContent (secondWin, EMPTY_SOURCE_PROMPT);
d1188 1
a1188 1
		tuiEraseSourceContent (srcWinInfo, EMPTY_SOURCE_PROMPT);
d1289 1
a1289 1
		tuiEraseSourceContent (firstWin, EMPTY_SOURCE_PROMPT);
d1291 1
a1291 1
		tuiEraseSourceContent (secondWin, EMPTY_SOURCE_PROMPT);
d1392 1
a1392 2
	  tuiUpdateSourceWindow (winInfo,
				 cursal.symtab, lineOrAddr, TRUE);
d1407 1
a1407 1
	  tuiUpdateSourceWindow (winInfo, s, line, TRUE);
@


1.3
log
@2004-01-20  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-disasm.h: Update copyright.  Include "tui.h" and
	"tui-data.h".
	(tui_set_disassem_content): Rename tuiSetDisassemContent.
	(tui_show_disassem): Rename tuiShowDisassem.
	(tui_show_disassem_and_update_source): Rename
	tuiVerticalDisassemScroll.
	(tui_vertical_disassem_scroll): Rename tuiVerticalDisassemScroll.
	(tui_get_begin_asm_address): Rename tuiGetBeginAsmAddress.
	* tui/tui.h: Update copyright.
	(enum tui_status): Define.
	* tui/tui-data.h (enum tui_scroll_direction): Define.
	* tui/tui-disasm.c: Update copyright.  Update references.
	* tui/tui-winsource.c: 	Update copyright.  Update references.
	* tui/tui-win.c: Update references.
	* tui/tui-layout.c: Update references.
@
text
@d618 1
a618 1
  tuiShowLocatorContent ();
d1413 1
a1413 1
	  tuiShowLocatorContent ();
@


1.3.4.1
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.2
log
@2004-01-19  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-regs.h: Include "tui-data.h".
	(tuiFirstRegElementNoInLine): Delete declaration.
	(tui_display_registers_from): Rename tuiDisplayRegistersFrom.
	(tui_last_regs_line_no): Rename tuiLastRegsLineNo.
	(tui_line_from_reg_element_no): Rename tuiLineFromRegElementNo.
	(tui_calculate_regs_column_count): Rename
	tuiCalculateRegsColumnCount.
	(tui_check_register_values): Rename tuiCheckRegisterValues.
	(tui_show_registers): Rename tuiShowRegisters.
	(tui_display_registers_from_line): Rename
	tuiDisplayRegistersFromLine.
	(tui_first_reg_element_inline): Rename tuiFirstRegElementInLine.
	(tui_toggle_float_regs): Rename tuiToggleFloatRegs.
	(tui_first_reg_element_no_inline): Rename
	tuiFirstRegElementNoInLine.
	* tui/tui-data.h: Update copyright.
	(enum tui_register_display_type): Rename _TuiRegisterDisplayType.
	* tui/tui-windata.c: Update copyright, update references.
	* tui/tui-regs.c: Update copyright, update references.
	* tui/tui-win.c: Update copyright, update references.
	* tui/tui-layout.c: Update copyright, update references.
@
text
@d470 1
a470 1
	tuiVerticalDisassemScroll (FORWARD_SCROLL, _numToScroll);
d500 1
a500 1
	tuiVerticalDisassemScroll (BACKWARD_SCROLL, _numToScroll);
@


1.1
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.
d725 1
a725 1
	      tuiCalculateRegsColumnCount (
@

