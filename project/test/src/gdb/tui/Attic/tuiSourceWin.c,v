head	1.27;
access;
symbols
	drow-cplus-merge-20040113:1.25
	drow-cplus-merge-20031224:1.25
	drow-cplus-merge-20031220:1.25
	carlton_dictionary-20031215-merge:1.25
	drow-cplus-merge-20031214:1.25
	carlton-dictionary-20031111-merge:1.25
	gdb_6_0-2003-10-04-release:1.25
	kettenis_sparc-20030918-branch:1.25.0.8
	kettenis_sparc-20030918-branchpoint:1.25
	carlton_dictionary-20030917-merge:1.25
	ezannoni_pie-20030916-branchpoint:1.25
	ezannoni_pie-20030916-branch:1.25.0.6
	cagney_x86i386-20030821-branch:1.25.0.4
	cagney_x86i386-20030821-branchpoint:1.25
	carlton_dictionary-20030805-merge:1.25
	carlton_dictionary-20030627-merge:1.25
	gdb_6_0-branch:1.25.0.2
	gdb_6_0-2003-06-23-branchpoint:1.25
	jimb-ppc64-linux-20030613-branch:1.24.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.24
	cagney_convert-20030606-branch:1.23.0.30
	cagney_convert-20030606-branchpoint:1.23
	cagney_writestrings-20030508-branch:1.23.0.28
	cagney_writestrings-20030508-branchpoint:1.23
	jimb-ppc64-linux-20030528-branch:1.23.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.23
	carlton_dictionary-20030523-merge:1.23
	cagney_fileio-20030521-branch:1.23.0.24
	cagney_fileio-20030521-branchpoint:1.23
	kettenis_i386newframe-20030517-mergepoint:1.23
	jimb-ppc64-linux-20030509-branch:1.23.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.23
	kettenis_i386newframe-20030504-mergepoint:1.23
	carlton_dictionary-20030430-merge:1.23
	kettenis_i386newframe-20030419-branch:1.23.0.20
	kettenis_i386newframe-20030419-branchpoint:1.23
	carlton_dictionary-20030416-merge:1.23
	cagney_frameaddr-20030409-mergepoint:1.23
	kettenis_i386newframe-20030406-branch:1.23.0.18
	kettenis_i386newframe-20030406-branchpoint:1.23
	cagney_frameaddr-20030403-branchpoint:1.23
	cagney_frameaddr-20030403-branch:1.23.0.16
	cagney_framebase-20030330-mergepoint:1.23
	cagney_framebase-20030326-branch:1.23.0.14
	cagney_framebase-20030326-branchpoint:1.23
	cagney_lazyid-20030317-branch:1.23.0.12
	cagney_lazyid-20030317-branchpoint:1.23
	kettenis-i386newframe-20030316-mergepoint:1.23
	offbyone-20030313-branch:1.23.0.10
	offbyone-20030313-branchpoint:1.23
	kettenis-i386newframe-20030308-branch:1.23.0.8
	kettenis-i386newframe-20030308-branchpoint:1.23
	carlton_dictionary-20030305-merge:1.23
	cagney_offbyone-20030303-branch:1.23.0.6
	cagney_offbyone-20030303-branchpoint:1.23
	carlton_dictionary-20030207-merge:1.23
	interps-20030203-mergepoint:1.23
	interps-20030202-branch:1.23.0.4
	interps-20030202-branchpoint:1.23
	cagney-unwind-20030108-branch:1.23.0.2
	cagney-unwind-20030108-branchpoint:1.23
	carlton_dictionary-20021223-merge:1.23
	gdb_5_3-2002-12-12-release:1.21
	carlton_dictionary-20021115-merge:1.22
	kseitz_interps-20021105-merge:1.22
	kseitz_interps-20021103-merge:1.22
	drow-cplus-merge-20021020:1.22
	drow-cplus-merge-20021025:1.22
	carlton_dictionary-20021025-merge:1.22
	carlton_dictionary-20021011-merge:1.22
	drow-cplus-branch:1.22.0.2
	drow-cplus-branchpoint:1.22
	kseitz_interps-20020930-merge:1.22
	carlton_dictionary-20020927-merge:1.21
	carlton_dictionary-branch:1.21.0.4
	carlton_dictionary-20020920-branchpoint:1.21
	gdb_5_3-branch:1.21.0.2
	gdb_5_3-2002-09-04-branchpoint:1.21
	kseitz_interps-20020829-merge:1.18
	cagney_sysregs-20020825-branch:1.17.0.2
	cagney_sysregs-20020825-branchpoint:1.17
	readline_4_3-import-branch:1.11.0.10
	readline_4_3-import-branchpoint:1.11
	gdb_5_2_1-2002-07-23-release:1.11
	kseitz_interps-20020528-branch:1.11.0.8
	kseitz_interps-20020528-branchpoint:1.11
	cagney_regbuf-20020515-branch:1.11.0.6
	cagney_regbuf-20020515-branchpoint:1.11
	jimb-macro-020506-branch:1.11.0.4
	jimb-macro-020506-branchpoint:1.11
	gdb_5_2-2002-04-29-release:1.11
	gdb_5_2-branch:1.11.0.2
	gdb_5_2-2002-03-03-branchpoint:1.11
	gdb_5_1_1-2002-01-24-release:1.7.2.1
	gdb_5_1_0_1-2002-01-03-release:1.7.2.1
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.7.2.1.0.4
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7.2.1
	gdb_5_1-2001-11-21-release:1.7.2.1
	gdb_s390-2001-09-26-branch:1.7.2.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.7.2.1
	gdb_5_1-2001-07-29-branch:1.7.0.2
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.1.1.2.0.6
	dberlin-typesystem-branchpoint:1.1.1.2
	gdb-post-ptid_t-2001-05-03:1.1.1.2
	gdb-pre-ptid_t-2001-05-03:1.1.1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb-post-protoization-2000-07-29:1.1.1.2
	gdb-pre-protoization-2000-07-29:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb-post-params-removal-2000-06-04:1.1.1.2
	gdb-pre-params-removal-2000-06-04:1.1.1.2
	gdb-post-params-removal-2000-05-28:1.1.1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.27
date	2004.01.19.04.31.52;	author cagney;	state dead;
branches;
next	1.26;

1.26
date	2004.01.19.02.58.48;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.22.15.21.39;	author drow;	state Exp;
branches
	1.25.6.1;
next	1.24;

1.24
date	2003.06.12.15.44.24;	author schwab;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.29.19.15.16;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.30.00.52.27;	author ezannoni;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2002.08.31.12.25.29;	author ciceron;	state Exp;
branches
	1.21.4.1;
next	1.20;

1.20
date	2002.08.30.21.49.49;	author ciceron;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.30.20.07.05;	author ciceron;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.27.21.59.49;	author ciceron;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.25.19.19.50;	author ciceron;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.25.13.13.20;	author ciceron;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.25.11.00.46;	author ciceron;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.25.08.44.44;	author ciceron;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.24.12.28.32;	author ciceron;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.24.10.15.54;	author ciceron;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.01.06.19.28;	author cagney;	state Exp;
branches
	1.11.8.1;
next	1.10;

1.10
date	2002.02.08.15.54.32;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.21.17.19.38;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.02.11.58.29;	author eliz;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.20.23.06.48;	author ciceron;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.07.20.22.26.54;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.18.20.59.00;	author ciceron;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.17.22.22.40;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.14.19.31.09;	author ciceron;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.14.19.01.25;	author ciceron;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.19.30;	author jsm;	state Exp;
branches;
next	;

1.7.2.1
date	2001.08.02.12.05.59;	author eliz;	state Exp;
branches;
next	;

1.11.8.1
date	2002.08.30.22.52.52;	author kseitz;	state Exp;
branches;
next	1.11.8.2;

1.11.8.2
date	2002.10.01.00.46.35;	author kseitz;	state Exp;
branches;
next	;

1.21.4.1
date	2002.10.11.22.23.03;	author carlton;	state Exp;
branches;
next	1.21.4.2;

1.21.4.2
date	2002.12.23.19.39.21;	author carlton;	state Exp;
branches;
next	1.21.4.3;

1.21.4.3
date	2003.06.27.21.50.21;	author carlton;	state Exp;
branches;
next	1.21.4.4;

1.21.4.4
date	2004.01.26.19.11.45;	author carlton;	state dead;
branches;
next	;

1.22.2.1
date	2003.12.14.20.27.59;	author drow;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2004.02.09.19.43.58;	author drow;	state dead;
branches;
next	;

1.25.6.1
date	2004.03.23.20.09.17;	author ezannoni;	state dead;
branches;
next	;


desc
@@


1.27
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@/* TUI display source/assembly window.

   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include <ctype.h>
#include "symtab.h"
#include "frame.h"
#include "breakpoint.h"
#include "value.h"
#include "source.h"

#include "tui.h"
#include "tuiData.h"
#include "tuiStack.h"
#include "tuiWin.h"
#include "tuiGeneralWin.h"
#include "tuiSourceWin.h"
#include "tuiSource.h"
#include "tuiDisassem.h"

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

/* Function to display the "main" routine.  */
void
tui_display_main (void)
{
  if ((sourceWindows ())->count > 0)
    {
      CORE_ADDR addr;

      addr = tuiGetBeginAsmAddress ();
      if (addr != (CORE_ADDR) 0)
	{
	  struct symtab_and_line sal;

	  tuiUpdateSourceWindowsWithAddr (addr);
	  sal = find_pc_line (addr, 0);
          if (sal.symtab)
             tuiUpdateLocatorFilename (sal.symtab->filename);
          else
             tuiUpdateLocatorFilename ("??");
	}
    }
}



/*
   ** tuiUpdateSourceWindow().
   **    Function to display source in the source window.  This function
   **    initializes the horizontal scroll to 0.
 */
void
tuiUpdateSourceWindow (TuiWinInfoPtr winInfo, struct symtab *s,
                       TuiLineOrAddress lineOrAddr, int noerror)
{
  winInfo->detail.sourceInfo.horizontalOffset = 0;
  tuiUpdateSourceWindowAsIs (winInfo, s, lineOrAddr, noerror);

  return;
}				/* tuiUpdateSourceWindow */


/*
   ** tuiUpdateSourceWindowAsIs().
   **        Function to display source in the source/asm window.  This
   **        function shows the source as specified by the horizontal offset.
 */
void
tuiUpdateSourceWindowAsIs (TuiWinInfoPtr winInfo, struct symtab *s,
                           TuiLineOrAddress lineOrAddr, int noerror)
{
  TuiStatus ret;

  if (winInfo->generic.type == SRC_WIN)
    ret = tuiSetSourceContent (s, lineOrAddr.lineNo, noerror);
  else
    ret = tuiSetDisassemContent (lineOrAddr.addr);

  if (ret == TUI_FAILURE)
    {
      tuiClearSourceContent (winInfo, EMPTY_SOURCE_PROMPT);
      tuiClearExecInfoContent (winInfo);
    }
  else
    {
      tui_update_breakpoint_info (winInfo, 0);
      tuiShowSourceContent (winInfo);
      tuiUpdateExecInfo (winInfo);
      if (winInfo->generic.type == SRC_WIN)
	{
	  struct symtab_and_line sal;
	  
	  sal.line = lineOrAddr.lineNo +
	    (winInfo->generic.contentSize - 2);
	  sal.symtab = s;
	  set_current_source_symtab_and_line (&sal);
	  /*
	     ** If the focus was in the asm win, put it in the src
	     ** win if we don't have a split layout
	   */
	  if (tuiWinWithFocus () == disassemWin &&
	      currentLayout () != SRC_DISASSEM_COMMAND)
	    tuiSetWinFocusTo (srcWin);
	}
    }


  return;
}				/* tuiUpdateSourceWindowAsIs */


/*
   ** tuiUpdateSourceWindowsWithAddr().
   **        Function to ensure that the source and/or disassemly windows
   **        reflect the input address.
 */
void
tuiUpdateSourceWindowsWithAddr (CORE_ADDR addr)
{
  if (addr != 0)
    {
      struct symtab_and_line sal;
      TuiLineOrAddress l;
      
      switch (currentLayout ())
	{
	case DISASSEM_COMMAND:
	case DISASSEM_DATA_COMMAND:
	  tuiShowDisassem (addr);
	  break;
	case SRC_DISASSEM_COMMAND:
	  tuiShowDisassemAndUpdateSource (addr);
	  break;
	default:
	  sal = find_pc_line (addr, 0);
	  l.lineNo = sal.line;
	  tuiShowSource (sal.symtab, l, FALSE);
	  break;
	}
    }
  else
    {
      int i;

      for (i = 0; i < (sourceWindows ())->count; i++)
	{
	  TuiWinInfoPtr winInfo = (TuiWinInfoPtr) (sourceWindows ())->list[i];

	  tuiClearSourceContent (winInfo, EMPTY_SOURCE_PROMPT);
	  tuiClearExecInfoContent (winInfo);
	}
    }

  return;
}				/* tuiUpdateSourceWindowsWithAddr */

/*
   ** tuiUpdateSourceWindowsWithLine().
   **        Function to ensure that the source and/or disassemly windows
   **        reflect the input address.
 */
void
tuiUpdateSourceWindowsWithLine (struct symtab *s, int line)
{
  CORE_ADDR pc;
  TuiLineOrAddress l;
  
  switch (currentLayout ())
    {
    case DISASSEM_COMMAND:
    case DISASSEM_DATA_COMMAND:
      find_line_pc (s, line, &pc);
      tuiUpdateSourceWindowsWithAddr (pc);
      break;
    default:
      l.lineNo = line;
      tuiShowSource (s, l, FALSE);
      if (currentLayout () == SRC_DISASSEM_COMMAND)
	{
	  find_line_pc (s, line, &pc);
	  tuiShowDisassem (pc);
	}
      break;
    }

  return;
}				/* tuiUpdateSourceWindowsWithLine */

/*
   ** tuiClearSourceContent().
 */
void
tuiClearSourceContent (TuiWinInfoPtr winInfo, int displayPrompt)
{
  if (m_winPtrNotNull (winInfo))
    {
      register int i;

      winInfo->generic.contentInUse = FALSE;
      tuiEraseSourceContent (winInfo, displayPrompt);
      for (i = 0; i < winInfo->generic.contentSize; i++)
	{
	  TuiWinElementPtr element =
	  (TuiWinElementPtr) winInfo->generic.content[i];
	  element->whichElement.source.hasBreak = FALSE;
	  element->whichElement.source.isExecPoint = FALSE;
	}
    }

  return;
}				/* tuiClearSourceContent */


/*
   ** tuiEraseSourceContent().
 */
void
tuiEraseSourceContent (TuiWinInfoPtr winInfo, int displayPrompt)
{
  int xPos;
  int halfWidth = (winInfo->generic.width - 2) / 2;

  if (winInfo->generic.handle != (WINDOW *) NULL)
    {
      werase (winInfo->generic.handle);
      checkAndDisplayHighlightIfNeeded (winInfo);
      if (displayPrompt == EMPTY_SOURCE_PROMPT)
	{
	  char *noSrcStr;

	  if (winInfo->generic.type == SRC_WIN)
	    noSrcStr = NO_SRC_STRING;
	  else
	    noSrcStr = NO_DISASSEM_STRING;
	  if (strlen (noSrcStr) >= halfWidth)
	    xPos = 1;
	  else
	    xPos = halfWidth - strlen (noSrcStr);
	  mvwaddstr (winInfo->generic.handle,
		     (winInfo->generic.height / 2),
		     xPos,
		     noSrcStr);

	  /* elz: added this function call to set the real contents of
	     the window to what is on the  screen, so that later calls
	     to refresh, do display
	     the correct stuff, and not the old image */

	  tuiSetSourceContentNil (winInfo, noSrcStr);
	}
      tuiRefreshWin (&winInfo->generic);
    }
  return;
}				/* tuiEraseSourceContent */


/* Redraw the complete line of a source or disassembly window.  */
static void
tui_show_source_line (TuiWinInfoPtr winInfo, int lineno)
{
  TuiWinElementPtr line;
  int x, y;

  line = (TuiWinElementPtr) winInfo->generic.content[lineno - 1];
  if (line->whichElement.source.isExecPoint)
    wattron (winInfo->generic.handle, A_STANDOUT);

  mvwaddstr (winInfo->generic.handle, lineno, 1,
             line->whichElement.source.line);
  if (line->whichElement.source.isExecPoint)
    wattroff (winInfo->generic.handle, A_STANDOUT);

  /* Clear to end of line but stop before the border.  */
  getyx (winInfo->generic.handle, y, x);
  while (x + 1 < winInfo->generic.width)
    {
      waddch (winInfo->generic.handle, ' ');
      getyx (winInfo->generic.handle, y, x);
    }
}

/*
   ** tuiShowSourceContent().
 */
void
tuiShowSourceContent (TuiWinInfoPtr winInfo)
{
  if (winInfo->generic.contentSize > 0)
    {
      int lineno;

      for (lineno = 1; lineno <= winInfo->generic.contentSize; lineno++)
        tui_show_source_line (winInfo, lineno);
    }
  else
    tuiEraseSourceContent (winInfo, TRUE);

  checkAndDisplayHighlightIfNeeded (winInfo);
  tuiRefreshWin (&winInfo->generic);
  winInfo->generic.contentInUse = TRUE;
}


/*
   ** tuiHorizontalSourceScroll().
   **      Scroll the source forward or backward horizontally
 */
void
tuiHorizontalSourceScroll (TuiWinInfoPtr winInfo,
                           TuiScrollDirection direction,
                           int numToScroll)
{
  if (winInfo->generic.content != (OpaquePtr) NULL)
    {
      int offset;
      struct symtab *s;
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();

      if (cursal.symtab == (struct symtab *) NULL)
	s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
      else
	s = cursal.symtab;

      if (direction == LEFT_SCROLL)
	offset = winInfo->detail.sourceInfo.horizontalOffset + numToScroll;
      else
	{
	  if ((offset =
	     winInfo->detail.sourceInfo.horizontalOffset - numToScroll) < 0)
	    offset = 0;
	}
      winInfo->detail.sourceInfo.horizontalOffset = offset;
      tuiUpdateSourceWindowAsIs (
				  winInfo,
				  s,
				  ((TuiWinElementPtr)
				   winInfo->generic.content[0])->whichElement.source.lineOrAddr,
				  FALSE);
    }

  return;
}				/* tuiHorizontalSourceScroll */


/* Set or clear the hasBreak flag in the line whose line is lineNo.  */
void
tuiSetIsExecPointAt (TuiLineOrAddress l, TuiWinInfoPtr winInfo)
{
  int changed = 0;
  int i;
  TuiWinContent content = (TuiWinContent) winInfo->generic.content;

  i = 0;
  while (i < winInfo->generic.contentSize)
    {
      int newState;

      if (content[i]->whichElement.source.lineOrAddr.addr == l.addr)
        newState = TRUE;
      else
	newState = FALSE;
      if (newState != content[i]->whichElement.source.isExecPoint)
        {
          changed++;
          content[i]->whichElement.source.isExecPoint = newState;
          tui_show_source_line (winInfo, i + 1);
        }
      i++;
    }
  if (changed)
    tuiRefreshWin (&winInfo->generic);
}

/* Update the execution windows to show the active breakpoints.
   This is called whenever a breakpoint is inserted, removed or
   has its state changed.  */
void
tui_update_all_breakpoint_info ()
{
  TuiList* list = sourceWindows ();
  int i;

  for (i = 0; i < list->count; i++)
    {
      TuiWinInfoPtr win = (TuiWinInfoPtr) list->list[i];

      if (tui_update_breakpoint_info (win, FALSE))
        {
          tuiUpdateExecInfo (win);
        }
    }
}


/* Scan the source window and the breakpoints to update the
   hasBreak information for each line.
   Returns 1 if something changed and the execution window
   must be refreshed.  */
int
tui_update_breakpoint_info (TuiWinInfoPtr win, int current_only)
{
  int i;
  int need_refresh = 0;
  TuiSourceInfoPtr src = &win->detail.sourceInfo;

  for (i = 0; i < win->generic.contentSize; i++)
    {
      struct breakpoint *bp;
      extern struct breakpoint *breakpoint_chain;
      int mode;
      TuiSourceElement* line;

      line = &((TuiWinElementPtr) win->generic.content[i])->whichElement.source;
      if (current_only && !line->isExecPoint)
         continue;

      /* Scan each breakpoint to see if the current line has something to
         do with it.  Identify enable/disabled breakpoints as well as
         those that we already hit.  */
      mode = 0;
      for (bp = breakpoint_chain;
           bp != (struct breakpoint *) NULL;
           bp = bp->next)
        {
          if ((win == srcWin
               && bp->source_file
               && (strcmp (src->filename, bp->source_file) == 0)
               && bp->line_number == line->lineOrAddr.lineNo)
              || (win == disassemWin
                  && bp->loc->address == line->lineOrAddr.addr))
            {
              if (bp->enable_state == bp_disabled)
                mode |= TUI_BP_DISABLED;
              else
                mode |= TUI_BP_ENABLED;
              if (bp->hit_count)
                mode |= TUI_BP_HIT;
              if (bp->cond)
                mode |= TUI_BP_CONDITIONAL;
              if (bp->type == bp_hardware_breakpoint)
                mode |= TUI_BP_HARDWARE;
            }
        }
      if (line->hasBreak != mode)
        {
          line->hasBreak = mode;
          need_refresh = 1;
        }
    }
  return need_refresh;
}


/*
   ** tuiSetExecInfoContent().
   **      Function to initialize the content of the execution info window,
   **      based upon the input window which is either the source or
   **      disassembly window.
 */
TuiStatus
tuiSetExecInfoContent (TuiWinInfoPtr winInfo)
{
  TuiStatus ret = TUI_SUCCESS;

  if (winInfo->detail.sourceInfo.executionInfo != (TuiGenWinInfoPtr) NULL)
    {
      TuiGenWinInfoPtr execInfoPtr = winInfo->detail.sourceInfo.executionInfo;

      if (execInfoPtr->content == (OpaquePtr) NULL)
	execInfoPtr->content =
	  (OpaquePtr) allocContent (winInfo->generic.height,
				    execInfoPtr->type);
      if (execInfoPtr->content != (OpaquePtr) NULL)
	{
	  int i;

          tui_update_breakpoint_info (winInfo, 1);
	  for (i = 0; i < winInfo->generic.contentSize; i++)
	    {
	      TuiWinElementPtr element;
	      TuiWinElementPtr srcElement;
              int mode;

	      element = (TuiWinElementPtr) execInfoPtr->content[i];
	      srcElement = (TuiWinElementPtr) winInfo->generic.content[i];

              memset(element->whichElement.simpleString, ' ',
                     sizeof(element->whichElement.simpleString));
              element->whichElement.simpleString[TUI_EXECINFO_SIZE - 1] = 0;

	      /* Now update the exec info content based upon the state
                 of each line as indicated by the source content.  */
              mode = srcElement->whichElement.source.hasBreak;
              if (mode & TUI_BP_HIT)
                element->whichElement.simpleString[TUI_BP_HIT_POS] =
                  (mode & TUI_BP_HARDWARE) ? 'H' : 'B';
              else if (mode & (TUI_BP_ENABLED | TUI_BP_DISABLED))
                element->whichElement.simpleString[TUI_BP_HIT_POS] =
                  (mode & TUI_BP_HARDWARE) ? 'h' : 'b';

              if (mode & TUI_BP_ENABLED)
                element->whichElement.simpleString[TUI_BP_BREAK_POS] = '+';
              else if (mode & TUI_BP_DISABLED)
                element->whichElement.simpleString[TUI_BP_BREAK_POS] = '-';

              if (srcElement->whichElement.source.isExecPoint)
                element->whichElement.simpleString[TUI_EXEC_POS] = '>';
	    }
	  execInfoPtr->contentSize = winInfo->generic.contentSize;
	}
      else
	ret = TUI_FAILURE;
    }

  return ret;
}


/*
   ** tuiShowExecInfoContent().
 */
void
tuiShowExecInfoContent (TuiWinInfoPtr winInfo)
{
  TuiGenWinInfoPtr execInfo = winInfo->detail.sourceInfo.executionInfo;
  int curLine;

  werase (execInfo->handle);
  tuiRefreshWin (execInfo);
  for (curLine = 1; (curLine <= execInfo->contentSize); curLine++)
    mvwaddstr (execInfo->handle,
	       curLine,
	       0,
	       ((TuiWinElementPtr)
		execInfo->content[curLine - 1])->whichElement.simpleString);
  tuiRefreshWin (execInfo);
  execInfo->contentInUse = TRUE;

  return;
}				/* tuiShowExecInfoContent */


/*
   ** tuiEraseExecInfoContent().
 */
void
tuiEraseExecInfoContent (TuiWinInfoPtr winInfo)
{
  TuiGenWinInfoPtr execInfo = winInfo->detail.sourceInfo.executionInfo;

  werase (execInfo->handle);
  tuiRefreshWin (execInfo);

  return;
}				/* tuiEraseExecInfoContent */

/*
   ** tuiClearExecInfoContent().
 */
void
tuiClearExecInfoContent (TuiWinInfoPtr winInfo)
{
  winInfo->detail.sourceInfo.executionInfo->contentInUse = FALSE;
  tuiEraseExecInfoContent (winInfo);

  return;
}				/* tuiClearExecInfoContent */

/*
   ** tuiUpdateExecInfo().
   **        Function to update the execution info window
 */
void
tuiUpdateExecInfo (TuiWinInfoPtr winInfo)
{
  tuiSetExecInfoContent (winInfo);
  tuiShowExecInfoContent (winInfo);
}				/* tuiUpdateExecInfo */

TuiStatus
tuiAllocSourceBuffer (TuiWinInfoPtr winInfo)
{
  register char *srcLineBuf;
  register int i, lineWidth, maxLines;
  TuiStatus ret = TUI_FAILURE;

  maxLines = winInfo->generic.height;	/* less the highlight box */
  lineWidth = winInfo->generic.width - 1;
  /*
     ** Allocate the buffer for the source lines.  Do this only once since they
     ** will be re-used for all source displays.  The only other time this will
     ** be done is when a window's size changes.
   */
  if (winInfo->generic.content == (OpaquePtr) NULL)
    {
      srcLineBuf = (char *) xmalloc ((maxLines * lineWidth) * sizeof (char));
      if (srcLineBuf == (char *) NULL)
	fputs_unfiltered (
	   "Unable to Allocate Memory for Source or Disassembly Display.\n",
			   gdb_stderr);
      else
	{
	  /* allocate the content list */
	  if ((winInfo->generic.content =
	  (OpaquePtr) allocContent (maxLines, SRC_WIN)) == (OpaquePtr) NULL)
	    {
	      tuiFree (srcLineBuf);
	      srcLineBuf = (char *) NULL;
	      fputs_unfiltered (
				 "Unable to Allocate Memory for Source or Disassembly Display.\n",
				 gdb_stderr);
	    }
	}
      for (i = 0; i < maxLines; i++)
	((TuiWinElementPtr)
	 winInfo->generic.content[i])->whichElement.source.line =
	  srcLineBuf + (lineWidth * i);
      ret = TUI_SUCCESS;
    }
  else
    ret = TUI_SUCCESS;

  return ret;
}				/* tuiAllocSourceBuffer */


/*
   ** tuiLineIsDisplayed().
   **      Answer whether the a particular line number or address is displayed
   **      in the current source window.
 */
int
tuiLineIsDisplayed (int line, TuiWinInfoPtr winInfo,
                    int checkThreshold)
{
  int isDisplayed = FALSE;
  int i, threshold;

  if (checkThreshold)
    threshold = SCROLL_THRESHOLD;
  else
    threshold = 0;
  i = 0;
  while (i < winInfo->generic.contentSize - threshold && !isDisplayed)
    {
      isDisplayed = (((TuiWinElementPtr)
		      winInfo->generic.content[i])->whichElement.source.lineOrAddr.lineNo
		     == (int) line);
      i++;
    }

  return isDisplayed;
}				/* tuiLineIsDisplayed */


/*
   ** tuiLineIsDisplayed().
   **      Answer whether the a particular line number or address is displayed
   **      in the current source window.
 */
int
tuiAddrIsDisplayed (CORE_ADDR addr, TuiWinInfoPtr winInfo,
		    int checkThreshold)
{
  int isDisplayed = FALSE;
  int i, threshold;

  if (checkThreshold)
    threshold = SCROLL_THRESHOLD;
  else
    threshold = 0;
  i = 0;
  while (i < winInfo->generic.contentSize - threshold && !isDisplayed)
    {
      isDisplayed = (((TuiWinElementPtr)
		      winInfo->generic.content[i])->whichElement.source.lineOrAddr.addr
		     == addr);
      i++;
    }

  return isDisplayed;
}


/*****************************************
** STATIC LOCAL FUNCTIONS               **
******************************************/
@


1.26
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tuiSourceWin.c (tui_update_breakpoint_info): Fix compile
	problem.
@
text
@@


1.25
log
@	* tui-hooks.c: Update include order.
	* tui.c: Likewise.
	* tuiCommand.c: Likewise.
	* tuiData.c: Likewise.
	* tuiDataWin.c: Likewise.
	* tuiDisassem.c: Likewise.
	* tuiGeneralWin.c: Likewise.
	* tuiIO.c: Likewise.
	* tuiLayout.c: Likewise.
	* tuiRegs.c: Likewise.
	* tuiSource.c: Likewise.
	* tuiSourceWin.c: Likewise.
	* tuiStack.c: Likewise.
	* tuiWin.c: Likewise.
@
text
@d458 1
a458 1
                  && bp->address == line->lineOrAddr.addr))
@


1.25.6.1
log
@merge mainline changes to branch
@
text
@@


1.24
log
@	* Makefile.in (tuiDisassem.o): Update dependencies.

tui:
	* tuiSource.c (tuiVerticalSourceScroll): Use get_frame_pc.
	* tuiSourceWin.c (tuiHorizontalSourceScroll): Likewise.
	* tuiStack.c (tui_get_function_from_frame): Likewise.
	(tuiShowFrameInfo): Likewise.
	* tuiWin.c (_makeVisibleWithNewHeight): Likewise.
	* tui-hooks.c (tui_selected_frame_level_changed_hook): Likewise.
	* tuiDisassem.c (tuiVerticalDisassemScroll): Likewise.
	Include "disasm.h".
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation,
a24 17
/* FIXME: cagney/2002-02-28: The GDB coding standard indicates that
   "defs.h" should be included first.  Unfortunatly some systems
   (currently Debian GNU/Linux) include the <stdbool.h> via <curses.h>
   and they clash with "bfd.h"'s definiton of true/false.  The correct
   fix is to remove true/false from "bfd.h", however, until that
   happens, hack around it by including "config.h" and <curses.h>
   first.  */

#include "config.h"
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

d42 7
@


1.23
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d358 1
a358 1
	s = find_pc_symtab (deprecated_selected_frame->pc);
@


1.22
log
@2002-09-29  Elena Zannoni  <ezannoni@@redhat.com>

	* tui.c (tui_show_source): Don't access current_source_symtab, use
	accessor function instead.  Include source.h and symtab.h
	* tuiDisassem.c (tuiShowDisassemAndUpdateSource,
	tuiVerticalDisassemScroll): Use accessor functions for current
	source line and symtab.  Include source.h.
	* tuiLayout.c (_extractDisplayStartAddr): Use accessor functions
	for current source line and symtab.  Include source.h.
	* tuiWin.c (_makeVisibleWithNewHeight): Ditto.
	* tuiSourceWin.c (tuiUpdateSourceWindowAsIs,
	tuiHorizontalSourceScroll): Ditto.
	* tuiSource.c (tuiVerticalSourceScroll): Ditto.
@
text
@d358 1
a358 1
	s = find_pc_symtab (selected_frame->pc);
@


1.22.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a58 7
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
d358 1
a358 1
	s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
@


1.22.2.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@@


1.21
log
@	* tuiSourceWin.h (tuiUpdateAllExecInfos): Don't declare.
	(tuiClearAllExecInfosContent): Likewise.
	(tuiEraseAllExecInfosContent): Ditto.
	(tuiUpdateSourceWindowsFromLocator): Ditto.
	* tuiSourceWin.c (tuiUpdateAllExecInfos): Remove.
	* tui.h (tui_vCheckDataValues): Don't declare.
	(tui_vStartNewLines, tui_vAllSetHasBreakAt): Likewise.
	(tui_vUpdateLocatorFilename, tui_vUpdateSourceWindowsWithAddr): Ditto.
	(tui_vShowFrameInfo): Ditto.
@
text
@d48 1
d129 3
a131 1
	  current_source_line = lineOrAddr.lineNo +
d133 2
a134 1
	  current_source_symtab = s;
d355 1
d357 1
a357 1
      if (current_source_symtab == (struct symtab *) NULL)
d360 1
a360 1
	s = current_source_symtab;
@


1.21.4.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a47 1
#include "source.h"
d128 1
a128 3
	  struct symtab_and_line sal;
	  
	  sal.line = lineOrAddr.lineNo +
d130 1
a130 2
	  sal.symtab = s;
	  set_current_source_symtab_and_line (&sal);
a350 1
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();
d352 1
a352 1
      if (cursal.symtab == (struct symtab *) NULL)
d355 1
a355 1
	s = cursal.symtab;
@


1.21.4.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d358 1
a358 1
	s = find_pc_symtab (deprecated_selected_frame->pc);
@


1.21.4.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a58 7
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
d358 1
a358 1
	s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
@


1.21.4.4
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.20
log
@	* tuiSourceWin.c (tuiSetIsExecPointAt): Redraw the previous and
	current line.
@
text
@a612 15

				   /*
				   ** tuiUpdateAllExecInfos()
				 */
void
tuiUpdateAllExecInfos (void)
{
  int i;

  for (i = 0; i < (sourceWindows ())->count; i++)
    tuiUpdateExecInfo ((TuiWinInfoPtr) (sourceWindows ())->list[i]);

  return;
}				/* tuiUpdateAllExecInfos */

@


1.19
log
@	* tuiSourceWin.h (tui_update_all_breakpoint_info): Declare.
	(tui_update_breakpoint_info): Declare.
	(tuiSetHasBreakAt, tuiAllSetHasBreakAt): Remove.

	* tuiSourceWin.c (tuiUpdateSourceWindowAsIs): Update breakpoint
	information using tui_update_breakpoint_info.
	(tui_update_all_breakpoint_info): New function to refresh all
	execution windows.
	(tui_update_breakpoint_info): New function to recompute the status
	of exec info window from breakpoints.
	(tuiSetHasBreakAt, tuiAllSetHasBreakAt): Remove.
	(tuiSetExecInfoContent): Use the exec info flags computed by
	tui_update_breakpoint_info to display a short status about breakpoints.

	* tuiData.h (TuiExecInfoContent): New for exec info string.
	(TuiWhichElement): Use it.
	(TUI_BP_ENABLED, TUI_BP_DISABLED, TUI_BP_HIT): New defines.
	(TUI_BP_CONDITIONAL, TUI_BP_HARDWARE): New defines.
	(TUI_BP_HIT_POS, TUI_BP_BREAK_POS, TUI_EXEC_POS): Likewise.
	(TUI_EXECINFO_SIZE): Likewise.
	* tuiData.c (initContentElement): Clear exec info string.

	* tui-hooks.c (get_breakpoint): Remove.
	(tui_event_create_breakpoint): Call tui_update_all_breakpoint_info.
	(tui_event_delete_breakpoint): Likewise.
	(tui_event_modify_breakpoint): Likewise.
@
text
@d378 1
a378 4
/*
   ** tuiSetHasExecPointAt().
   **        Set or clear the hasBreak flag in the line whose line is lineNo.
 */
d382 1
d389 2
d392 1
a392 1
	content[i]->whichElement.source.isExecPoint = TRUE;
d394 7
a400 1
	content[i]->whichElement.source.isExecPoint = FALSE;
d403 3
a405 3

  return;
}				/* tuiSetIsExecPointAt */
@


1.18
log
@	* tuiDisassem.c (tui_disassemble): New function to disassemble
	several lines in a buffer.
	(tui_find_disassembly_address): New function to search backward
	or forward a disassembly line.
	(tuiSetDisassemContent): Use tui_disassemble to obtain the real
	content and format it in the window.
	(tuiShowDisassemAndUpdateSource): Remove unused locals.
	(tuiVerticalDisassemScroll): Use tui_find_disassembly_address to
	obtain the address to disassemble for the scrolling.
	* tuiDisassem.h (tuiGetBeginAsmAddress): Update.
	* tuiSourceWin.c (tuiUpdateSourceWindowAsIs): Don't pass symtab.
@
text
@d123 1
a123 1
      tuiEraseSourceContent (winInfo, NO_EMPTY_SOURCE_PROMPT);
d401 3
a403 4
/*
   ** tuiSetHasBreakAt().
   **        Set or clear the hasBreak flag in the line whose line is lineNo.
 */
d405 1
a405 1
tuiSetHasBreakAt (struct breakpoint *bp, TuiWinInfoPtr winInfo, int hasBreak)
d407 1
a408 1
  TuiWinContent content = (TuiWinContent) winInfo->generic.content;
d410 1
a410 2
  i = 0;
  while (i < winInfo->generic.contentSize)
d412 1
a412 6
      int gotIt;
      TuiGenWinInfoPtr locator = locatorWinInfoPtr ();

      if (winInfo == srcWin)
	{
          TuiSourceInfoPtr src = &winInfo->detail.sourceInfo;
d414 4
a417 15
	  gotIt = (src->filename != (char *) NULL &&
                   bp->source_file != NULL &&
		   (strcmp (bp->source_file, src->filename) == 0) &&
		   content[i]->whichElement.source.lineOrAddr.lineNo ==
		   bp->line_number);
	}
      else
	gotIt = (content[i]->whichElement.source.lineOrAddr.addr
		 == bp->address);
      if (gotIt)
	{
	  content[i]->whichElement.source.hasBreak = hasBreak;
	  break;
	}
      i++;
d419 1
a419 3

  return;
}				/* tuiSetHasBreakAt */
d422 6
a427 6
/*
   ** tuiAllSetHasBreakAt().
   **        Set or clear the hasBreak flag in all displayed source windows.
 */
void
tuiAllSetHasBreakAt (struct breakpoint *bp, int hasBreak)
d430 2
d433 46
a478 7
  for (i = 0; i < (sourceWindows ())->count; i++)
    tuiSetHasBreakAt (bp,
		      (TuiWinInfoPtr) (sourceWindows ())->list[i], hasBreak);

  return;
}				/* tuiAllSetHasBreakAt */

a479 3
/*********************************
** EXECUTION INFO FUNCTIONS        **
*********************************/
d504 1
d509 1
d513 22
a534 43
	      /*
	         ** First check to see if we have a breakpoint that is
	         ** temporary.  If so, and this is our current execution point,
	         ** then clear the break indicator.
	       */
	      if (srcElement->whichElement.source.hasBreak &&
		  srcElement->whichElement.source.isExecPoint)
		{
		  struct breakpoint *bp;
		  int found = FALSE;
		  extern struct breakpoint *breakpoint_chain;

		  for (bp = breakpoint_chain;
		       (bp != (struct breakpoint *) NULL && !found);
		       bp = bp->next)
		    {
		      found =
			(winInfo == srcWin &&
			 bp->line_number ==
		       srcElement->whichElement.source.lineOrAddr.lineNo) ||
			(winInfo == disassemWin &&
			 bp->address == (CORE_ADDR)
			 srcElement->whichElement.source.lineOrAddr.addr);
		      if (found)
			srcElement->whichElement.source.hasBreak =
			  (bp->disposition != disp_del || bp->hit_count <= 0);
		    }
		  if (!found)
		    srcElement->whichElement.source.hasBreak = FALSE;
		}
	      /*
	         ** Now update the exec info content based upon the state
	         ** of each line as indicated by the source content.
	       */
	      if (srcElement->whichElement.source.hasBreak &&
		  srcElement->whichElement.source.isExecPoint)
		element->whichElement.simpleString = breakLocationStr ();
	      else if (srcElement->whichElement.source.hasBreak)
		element->whichElement.simpleString = breakStr ();
	      else if (srcElement->whichElement.source.isExecPoint)
		element->whichElement.simpleString = locationStr ();
	      else
		element->whichElement.simpleString = blankStr ();
d543 1
a543 1
}				/* tuiSetExecInfoContent */
@


1.17
log
@	* tuiSourceWin.c (tui_display_main): Rename from tuiDisplayMainFunction
	and use tuiGetBeginAsmAddress.
	* tuiSourceWin.h (tui_display_main): Declare.
	* tui.h (tuiDisplayMainFunction): Remove.
	* tui-hooks.c (tui_new_objfile_hook): Update.
@
text
@d114 1
a114 1
    ret = tuiSetDisassemContent (s, lineOrAddr.addr);
@


1.16
log
@	* tuiSourceWin.c (tuiDisplayMainFunction): Update to use
	tuiUpdateLocatorFilename.
	* tuiStack.c (tuiSetLocatorInfo): Make it static.
	(tuiSetLocatorContent): Likewise.
	(tuiUpdateLocatorInfoFromFrame): Likewise.
	(tuiSwitchFilename): Remove.
	(tui_set_locator_filename): New function
	(tui_set_locator_info): Rename from tuiSetLocatorInfo to GNU-ify;
	use tui_set_locator_filename to record the filename.
	(tuiUpdateLocatorFilename): Likewise.
	(tuiUpdateLocatorInfoFromFrame): Update.
	(tuiSetLocatorContent): Likewise.
	* tuiStack.h (tuiClearLocatorContent): Don't declare.
	(tuiSetLocatorInfo, tuiSetLocatorContent): Likewise.
	(tuiUpdateLocatorInfoFromFrame, tuiSwitchFilename): Likewise.
@
text
@d59 1
a59 14
/*****************************************
** EXTERNAL FUNCTION DECLS                **
******************************************/

/*****************************************
** EXTERNAL DATA DECLS                    **
******************************************/
extern int current_source_line;
extern struct symtab *current_source_symtab;

/*
   ** tuiDisplayMainFunction().
   **        Function to display the "main" routine"
 */
d61 1
a61 1
tuiDisplayMainFunction (void)
d67 1
a67 3
      addr = parse_and_eval_address ("main");
      if (addr == (CORE_ADDR) 0)
	addr = parse_and_eval_address ("MAIN");
@


1.15
log
@	* tuiSourceWin.c (tuiSetHasBreakAt): Use filename for breakpoint
	comparison; cleanup.
	* tuiSource.c (tuiSetSourceContent): Set window title and filename.
	* tuiGeneralWin.c (boxWin): Print optional title on top of window.
	* tuiData.h (TuiSourceInfo): Add filename member.
	(TuiGenWinInfo): Add title member.
	* tuiData.c (initGenericPart): Clear title.
	(freeWindow): Free title and filename; remove unused locals.
	(initWinInfo): Clear filename.
	(tuiDelWindow): Free it; remove unused locals.
@
text
@d89 4
a92 1
	  tuiSwitchFilename (sal.symtab->filename);
d95 1
a95 3

  return;
}				/* tuiDisplayMainFunction */
@


1.14
log
@	* tuiSourceWin.h (tuiEraseAllSourceContent): Don't declare.
	(tuiShowAllExecInfosContent): Likewise.
	* tuiSourceWin.c (tuiEraseAllSourceContent): Remove.
	(tuiShowAllExecInfosContent): Remove.
	(tuiAllocSourceBuffer): Remove unused locals.
@
text
@d433 1
a433 1
	  char *fileNameDisplayed = (char *) NULL;
d435 1
a435 9
	  if (((TuiWinElementPtr)
	       locator->content[0])->whichElement.locator.fileName !=
	      (char *) NULL)
	    fileNameDisplayed = ((TuiWinElementPtr)
			locator->content[0])->whichElement.locator.fileName;
	  else if (current_source_symtab != (struct symtab *) NULL)
	    fileNameDisplayed = current_source_symtab->filename;

	  gotIt = (fileNameDisplayed != (char *) NULL &&
d437 1
a437 1
		   (strcmp (bp->source_file, fileNameDisplayed) == 0) &&
@


1.13
log
@	* tuiSourceWin.c (tui_show_source_line): New function.
	(tuiShowSourceContent): Call it and avoid clearing the window before
	redrawing it.
	(tuiClearAllSourceWinsContent): Remove.
	* tuiSourceWin.h (tuiClearAllSourceWinsContent): Don't declare.
	* tuiWin.h (tuiClearWinFocus, tuiClearWinFocusFrom): Don't declare.
	* tuiWin.c (tuiClearWinFocus, tuiClearWinFocusFrom): Remove.
	(tuiRefreshAll): Don't clear the window.
	(_makeVisibleWithNewHeight): Don't clear locator line.
	(tuiResizeAll): Remove unused locals.
	(_tuiAdjustWinHeights): Likewise.
	(_makeInvisibleAndSetNewHeight): Likewise.
	(_newHeightOk): Likewise.
	* tuiLayout.c (showLayout): Don't clear source windows.
	(tuiSetLayout): Don't clear the window.
	(_initAndMakeWin): Likewise for status line.
	* tuiGeneralWin.c (makeVisible): Don't clear or refresh the window.
	(makeWindow): Likewise.
	(tuiClearWin): Remove.
	* tuiGeneralWin.h (tuiClearWin): Don't declare.
@
text
@a304 16
/*
   ** tuiEraseAllSourceContent().
 */
void
tuiEraseAllSourceWinsContent (int displayPrompt)
{
  int i;

  for (i = 0; i < (sourceWindows ())->count; i++)
    tuiEraseSourceContent ((TuiWinInfoPtr) (sourceWindows ())->list[i],
			   displayPrompt);

  return;
}				/* tuiEraseAllSourceWinsContent */


a593 15
   ** tuiShowAllExecInfosContent()
 */
void
tuiShowAllExecInfosContent (void)
{
  int i;

  for (i = 0; i < (sourceWindows ())->count; i++)
    tuiShowExecInfoContent ((TuiWinInfoPtr) (sourceWindows ())->list[i]);

  return;
}				/* tuiShowAllExecInfosContent */


/*
d648 2
a649 2
  register char *srcLine, *srcLineBuf;
  register int i, lineWidth, c, maxLines;
@


1.12
log
@	* tuiSourceWin.c (tuiSrcWinIsDisplayed): Remove.
	(tuiAsmWinIsDisplayed): Remove.
	(tuiShowAllSourceWinsContent): Remove.
	(tuiUpdateOnEnd): Remove.
	* tuiGeneralWin.c (scrollWinForward): Remove.
	(scrollWinBackward): Remove.
	(_winResize): Don't declare.
	* tui.h (tuiUpdateOnEnd): Don't declare.
	(vcatch_errors, va_catch_errors): Likewise.
	* tuiSourceWin.h (tuiUpdateOnEnd): Likewise.
	(tuiShowAllSourceWinsContent): Likewise.
	* tuiGeneralWin.h (scrollWinForward): Likewise.
	(scrollWinBackward): Likewise.
@
text
@a262 16
   ** tuiClearAllSourceWinsContent().
 */
void
tuiClearAllSourceWinsContent (int displayPrompt)
{
  int i;

  for (i = 0; i < (sourceWindows ())->count; i++)
    tuiClearSourceContent ((TuiWinInfoPtr) (sourceWindows ())->list[i],
			   displayPrompt);

  return;
}				/* tuiClearAllSourceWinsContent */


/*
d321 25
a351 3
  int curLine, i, curX;

  tuiEraseSourceContent (winInfo, (winInfo->generic.contentSize <= 0));
d354 1
a354 1
      char *line;
d356 2
a357 7
      for (curLine = 1; (curLine <= winInfo->generic.contentSize); curLine++)
	mvwaddstr (
		    winInfo->generic.handle,
		    curLine,
		    1,
		    ((TuiWinElementPtr)
	  winInfo->generic.content[curLine - 1])->whichElement.source.line);
d359 3
d365 1
a365 3

  return;
}				/* tuiShowSourceContent */
@


1.11
log
@Add FIXME explaining include problem.
@
text
@a68 38

/*****************************************
** STATIC LOCAL FUNCTIONS FORWARD DECLS    **
******************************************/

/*****************************************
** STATIC LOCAL DATA                    **
******************************************/


/*****************************************
** PUBLIC FUNCTIONS                        **
******************************************/

/*********************************
** SOURCE/DISASSEM  FUNCTIONS    **
*********************************/

/*
   ** tuiSrcWinIsDisplayed().
 */
int
tuiSrcWinIsDisplayed (void)
{
  return (m_winPtrNotNull (srcWin) && srcWin->generic.isVisible);
}				/* tuiSrcWinIsDisplayed */


/*
   ** tuiAsmWinIsDisplayed().
 */
int
tuiAsmWinIsDisplayed (void)
{
  return (m_winPtrNotNull (disassemWin) && disassemWin->generic.isVisible);
}				/* tuiAsmWinIsDisplayed */


a366 15
   ** tuiShowAllSourceWinsContent()
 */
void
tuiShowAllSourceWinsContent (void)
{
  int i;

  for (i = 0; i < (sourceWindows ())->count; i++)
    tuiShowSourceContent ((TuiWinInfoPtr) (sourceWindows ())->list[i]);

  return;
}				/* tuiShowAllSourceWinsContent */


/*
a635 16

/*
   ** tuiEraseAllExecInfosContent()
 */
void
tuiEraseAllExecInfosContent (void)
{
  int i;

  for (i = 0; i < (sourceWindows ())->count; i++)
    tuiEraseExecInfoContent ((TuiWinInfoPtr) (sourceWindows ())->list[i]);

  return;
}				/* tuiEraseAllExecInfosContent */


a647 16

/*
   ** tuiClearAllExecInfosContent()
 */
void
tuiClearAllExecInfosContent (void)
{
  int i;

  for (i = 0; i < (sourceWindows ())->count; i++)
    tuiClearExecInfoContent ((TuiWinInfoPtr) (sourceWindows ())->list[i]);

  return;
}				/* tuiClearAllExecInfosContent */


a672 49



/* tuiUpdateOnEnd()
   **       elz: This function clears the execution info from the source windows
   **       and resets the locator to display no line info, procedure info, pc
   **       info.  It is called by stack_publish_stopped_with_no_frame, which
   **       is called then the target terminates execution
 */
void
tuiUpdateOnEnd (void)
{
  int i;
  TuiGenWinInfoPtr locator;
  char *filename;
  TuiWinInfoPtr winInfo;

  locator = locatorWinInfoPtr ();

  /* for all the windows (src, asm) */
  for (i = 0; i < (sourceWindows ())->count; i++)
    {
      TuiLineOrAddress l;
      
      winInfo = (TuiWinInfoPtr) (sourceWindows ())->list[i];

      l.addr = -1;
      l.lineNo = -1;
      tuiSetIsExecPointAt (l, winInfo);	/* the target is'n running */
      /* -1 should not match any line number or pc */
      tuiSetExecInfoContent (winInfo);	/*set winInfo so that > is'n displayed */
      tuiShowExecInfoContent (winInfo);		/* display the new contents */
    }

  /*now update the locator */
  tuiClearLocatorDisplay ();
  tuiGetLocatorFilename (locator, &filename);
  tuiSetLocatorInfo (
		      filename,
		      (char *) NULL,
		      0,
		      (CORE_ADDR) 0,
	   &((TuiWinElementPtr) locator->content[0])->whichElement.locator);
  tuiShowLocatorContent ();

  return;
}				/* tuiUpdateOnEnd */


@


1.11.8.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d59 52
a110 1
/* Function to display the "main" routine.  */
d112 1
a112 1
tui_display_main (void)
d118 3
a120 1
      addr = tuiGetBeginAsmAddress ();
d127 1
a127 4
          if (sal.symtab)
             tuiUpdateLocatorFilename (sal.symtab->filename);
          else
             tuiUpdateLocatorFilename ("??");
d130 3
a132 1
}
d166 1
a166 1
    ret = tuiSetDisassemContent (lineOrAddr.addr);
d301 16
d359 15
a373 24
/* Redraw the complete line of a source or disassembly window.  */
static void
tui_show_source_line (TuiWinInfoPtr winInfo, int lineno)
{
  TuiWinElementPtr line;
  int x, y;

  line = (TuiWinElementPtr) winInfo->generic.content[lineno - 1];
  if (line->whichElement.source.isExecPoint)
    wattron (winInfo->generic.handle, A_STANDOUT);

  mvwaddstr (winInfo->generic.handle, lineno, 1,
             line->whichElement.source.line);
  if (line->whichElement.source.isExecPoint)
    wattroff (winInfo->generic.handle, A_STANDOUT);

  /* Clear to end of line but stop before the border.  */
  getyx (winInfo->generic.handle, y, x);
  while (x + 1 < winInfo->generic.width)
    {
      waddch (winInfo->generic.handle, ' ');
      getyx (winInfo->generic.handle, y, x);
    }
}
d381 3
d386 1
a386 1
      int lineno;
d388 7
a394 2
      for (lineno = 1; lineno <= winInfo->generic.contentSize; lineno++)
        tui_show_source_line (winInfo, lineno);
a395 3
  else
    tuiEraseSourceContent (winInfo, TRUE);

d399 18
a416 1
}
d500 1
a500 1
          TuiSourceInfoPtr src = &winInfo->detail.sourceInfo;
d502 9
a510 1
	  gotIt = (src->filename != (char *) NULL &&
d512 1
a512 1
		   (strcmp (bp->source_file, src->filename) == 0) &&
d661 15
d689 16
d717 16
d759 49
d811 2
a812 2
  register char *srcLineBuf;
  register int i, lineWidth, maxLines;
@


1.11.8.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a47 1
#include "source.h"
d123 1
a123 1
      tui_update_breakpoint_info (winInfo, 0);
d128 1
a128 3
	  struct symtab_and_line sal;
	  
	  sal.line = lineOrAddr.lineNo +
d130 1
a130 2
	  sal.symtab = s;
	  set_current_source_symtab_and_line (&sal);
a350 1
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();
d352 1
a352 1
      if (cursal.symtab == (struct symtab *) NULL)
d355 1
a355 1
	s = cursal.symtab;
d378 4
a381 1
/* Set or clear the hasBreak flag in the line whose line is lineNo.  */
a384 1
  int changed = 0;
a390 2
      int newState;

d392 1
a392 1
        newState = TRUE;
d394 1
a394 7
	newState = FALSE;
      if (newState != content[i]->whichElement.source.isExecPoint)
        {
          changed++;
          content[i]->whichElement.source.isExecPoint = newState;
          tui_show_source_line (winInfo, i + 1);
        }
a396 3
  if (changed)
    tuiRefreshWin (&winInfo->generic);
}
d398 7
a404 3
/* Update the execution windows to show the active breakpoints.
   This is called whenever a breakpoint is inserted, removed or
   has its state changed.  */
d406 1
a406 1
tui_update_all_breakpoint_info ()
a407 1
  TuiList* list = sourceWindows ();
d409 1
d411 2
a412 1
  for (i = 0; i < list->count; i++)
d414 6
a419 1
      TuiWinInfoPtr win = (TuiWinInfoPtr) list->list[i];
d421 15
a435 4
      if (tui_update_breakpoint_info (win, FALSE))
        {
          tuiUpdateExecInfo (win);
        }
d437 3
a439 1
}
d442 6
a447 6
/* Scan the source window and the breakpoints to update the
   hasBreak information for each line.
   Returns 1 if something changed and the execution window
   must be refreshed.  */
int
tui_update_breakpoint_info (TuiWinInfoPtr win, int current_only)
a449 2
  int need_refresh = 0;
  TuiSourceInfoPtr src = &win->detail.sourceInfo;
d451 7
a457 46
  for (i = 0; i < win->generic.contentSize; i++)
    {
      struct breakpoint *bp;
      extern struct breakpoint *breakpoint_chain;
      int mode;
      TuiSourceElement* line;

      line = &((TuiWinElementPtr) win->generic.content[i])->whichElement.source;
      if (current_only && !line->isExecPoint)
         continue;

      /* Scan each breakpoint to see if the current line has something to
         do with it.  Identify enable/disabled breakpoints as well as
         those that we already hit.  */
      mode = 0;
      for (bp = breakpoint_chain;
           bp != (struct breakpoint *) NULL;
           bp = bp->next)
        {
          if ((win == srcWin
               && bp->source_file
               && (strcmp (src->filename, bp->source_file) == 0)
               && bp->line_number == line->lineOrAddr.lineNo)
              || (win == disassemWin
                  && bp->address == line->lineOrAddr.addr))
            {
              if (bp->enable_state == bp_disabled)
                mode |= TUI_BP_DISABLED;
              else
                mode |= TUI_BP_ENABLED;
              if (bp->hit_count)
                mode |= TUI_BP_HIT;
              if (bp->cond)
                mode |= TUI_BP_CONDITIONAL;
              if (bp->type == bp_hardware_breakpoint)
                mode |= TUI_BP_HARDWARE;
            }
        }
      if (line->hasBreak != mode)
        {
          line->hasBreak = mode;
          need_refresh = 1;
        }
    }
  return need_refresh;
}
d459 3
a485 1
          tui_update_breakpoint_info (winInfo, 1);
a489 1
              int mode;
d493 43
a535 22

              memset(element->whichElement.simpleString, ' ',
                     sizeof(element->whichElement.simpleString));
              element->whichElement.simpleString[TUI_EXECINFO_SIZE - 1] = 0;

	      /* Now update the exec info content based upon the state
                 of each line as indicated by the source content.  */
              mode = srcElement->whichElement.source.hasBreak;
              if (mode & TUI_BP_HIT)
                element->whichElement.simpleString[TUI_BP_HIT_POS] =
                  (mode & TUI_BP_HARDWARE) ? 'H' : 'B';
              else if (mode & (TUI_BP_ENABLED | TUI_BP_DISABLED))
                element->whichElement.simpleString[TUI_BP_HIT_POS] =
                  (mode & TUI_BP_HARDWARE) ? 'h' : 'b';

              if (mode & TUI_BP_ENABLED)
                element->whichElement.simpleString[TUI_BP_BREAK_POS] = '+';
              else if (mode & TUI_BP_DISABLED)
                element->whichElement.simpleString[TUI_BP_BREAK_POS] = '-';

              if (srcElement->whichElement.source.isExecPoint)
                element->whichElement.simpleString[TUI_EXEC_POS] = '>';
d544 1
a544 1
}
d607 15
@


1.10
log
@2002-02-08  Daniel Jacobowitz  <drow@@mvista.com>

        * utils.c: Include <curses.h> before "bfd.h".
        * tui/tui-hooks.c: Likewise.
        * tui/tui.c: Likewise.
        * tui/tuiCommand.c: Likewise.
        * tui/tuiData.c: Likewise.
        * tui/tuiDataWin.c: Likewise.
        * tui/tuiDisassem.c: Likewise.
        * tui/tuiGeneralWin.c: Likewise.
        * tui/tuiIO.c: Likewise.
        * tui/tuiLayout.c: Likewise.
        * tui/tuiRegs.c: Likewise.
        * tui/tuiSource.c: Likewise.
        * tui/tuiSourceWin.c: Likewise.
        * tui/tuiStack.c: Likewise.
        * tui/tuiWin.c: Likewise.
@
text
@d2 4
a5 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d25 8
a32 1
/* If we need <curses.h>, we must include it before we get "bfd.h".  */
@


1.9
log
@Add explicit #include of "value.h".
@
text
@d22 10
@


1.8
log
@	The following changes avoid polluting global namespace with the
	`enable' and `disable' identifiers, because some platforms define
	in their system headers symbols with global scope that go by those
	names.

	* breakpoint.h (enum enable_state): Rename from `enum enable'.
	Also rename all the enum members to have the "bp_" prefix.
	(struct breakpoint): Rename the `enable' member to `enable_state'.
	(enum bpdisp): Rename all members to have the "disp_" prefix.

	* breakpoint.c: All users of `enum enable' and `enum bpdisp'
	changed.
	(args_for_catchpoint_enable): Rename the `enable' member to
	`enable_p'.  All users changed.

	* tracepoint.h (enum enable): Remove.
	(struct tracepoint): The member `enabled' is now `int enabled_p'.

	* tracepoint.c: All users of the `enabled' member changed.

	* printcmd.c (struct display): The `status' member is now an int.

	* memattr.h (struct mem_region): Rename the `status' member to
	`enabled_p'.
	(enum enable): Remove.

	* memattr.c: Change all users of the `status' member of struct
	mem_region to use `enabled_p' instead.

	* infcmd.c (run_stack_dummy): Use disp_del instead of del.

	* go32-nat.c: Remove the kludgey work-around for conflicts between
	<dos.h> and "breakpoint.h".
	* tui/tuiSourceWin.c: Use disp_del instead of del.

	* tui/tuiSource.c: Use disp_del instead of del.

	* tui/tuiDisassem.c: Use disp_del instead of del.
@
text
@d27 1
@


1.7
log
@	* tuiWin.c (_parseScrollingArgs): Fix uninitialized variable.
	(_makeVisibleWithNewHeight): Use TuiLineOrAddress type.

	* tuiStack.c (tuiShowFrameInfo): Use TuiLineOrAddress type.
	(tui_vUpdateLocatorFilename): Remove.
	* tuiStack.h: Update prototypes.

	* tuiSourceWin.c (tuiAddrIsDisplayed): New function.
	(tuiLineIsDisplayed): Split for address and line.
	(tuiUpdateSourceWindow): Use TuiLineOrAddress type.
	(tuiUpdateSourceWindowAsIs): Likewise.
	(tuiUpdateSourceWindowsWithAddr): Likewise.
	(tuiUpdateSourceWindowsWithLine): Likewise.
	(tuiHorizontalSourceScroll): Likewise.
	(tuiSetIsExecPointAt): Likewise.
	(tuiUpdateOnEnd): Likewise.
	* tuiSourceWin.h: Update prototypes.

	* tuiSource.c (tuiVerticalSourceScroll): Use TuiLineOrAddress type.
	(tuiShowSource): Likewise.
	(tuiVerticalSourceScroll): Likewise.
	* tuiSource.h (tuiShowSource): Update prototype.

	* tuiDisassem.c (tuiSetDisassemContent): Use CORE_ADDR for address.
	(tuiShowDisassem): Use TuiLineOrAddress type.
	(tuiShowDisassemAndUpdateSource): Likewise.
	(tuiVerticalDisassemScroll): Likewise.
	(tuiShowDisassemAsIs): Remove.
	* tuiDisassem.h (tuiSetDisassemContent): Update prototype.

	* tuiData.c (initWinInfo): Use CORE_ADDR for address.
	(clearWinDetail): Likewise.
	(displayableWinContentOf): Fix address conversion.
	(tuiNextWin): Fix crash when the window is not yet created.
	(partialWinByName): Likewise.
@
text
@d586 1
a586 1
			  (bp->disposition != del || bp->hit_count <= 0);
@


1.7.2.1
log
@	The following changes avoid polluting global namespace with the
	`enable' and `disable' identifiers, because some platforms define
	in their system headers symbols with global scope that go by those
	names.

	* breakpoint.h (enum enable_state): Rename from `enum enable'.
	Also rename all the enum members to have the "bp_" prefix.
	(struct breakpoint): Rename the `enable' member to `enable_state'.
	(enum bpdisp): Rename all members to have the "disp_" prefix.

	* breakpoint.c: All users of `enum enable' and `enum bpdisp'
	changed.
	(args_for_catchpoint_enable): Rename the `enable' member to
	`enable_p'.  All users changed.

	* tracepoint.h (enum enable): Remove.
	(struct tracepoint): The member `enabled' is now `int enabled_p'.

	* tracepoint.c: All users of the `enabled' member changed.

	* printcmd.c (struct display): The `status' member is now an int.

	* memattr.h (struct mem_region): Rename the `status' member to
	`enabled_p'.
	(enum enable): Remove.

	* memattr.c: Change all users of the `status' member of struct
	mem_region to use `enabled_p' instead.

	* infcmd.c (run_stack_dummy): Use disp_del instead of del.

	* go32-nat.c: Remove the kludgey work-around for conflicts between
	<dos.h> and "breakpoint.h".

	* tui/tuiSourceWin.c: Use disp_del instead of del.

	* tui/tuiSource.c: Use disp_del instead of del.

	* tui/tuiDisassem.c: Use disp_del instead of del.
@
text
@d586 1
a586 1
			  (bp->disposition != disp_del || bp->hit_count <= 0);
@


1.6
log
@	* tuiSourceWin.h: Remove unused declarations.
	* tuiSourceWin.c (tui_vUpdateSourceWindowsWithAddr): Remove.
	(tui_vUpdateSourceWindowsWithLine): Remove.
	(tui_vAllSetHasBreakAt): Remove.

	* tuiLayout.h (tui_set_layout): Declare.
	(tui_vSetLayoutTo): Remove.
	(tui_vAddWinToLayout): Remove.
	* tuiLayout.c (_tuiLayout_command): Call tui_enable() to force TUI.
	(_tuiToggleLayout_command): Remove.
	(_tuiToggleSplitLayout_command): Remove.
	(_tuiLayout_command): Remove.
	(tui_vSetLayoutTo): Remove.
	(tui_vAddWinToLayout): Remove.

	* tuiDataWin.h (tui_vCheckDataValues): Remove.
	* tuiDataWin.c (tui_vCheckDataValues): Remove.
@
text
@d122 1
a122 1
                       Opaque lineOrAddr, int noerror)
d138 1
a138 1
                           Opaque lineOrAddr, int noerror)
d143 1
a143 1
    ret = tuiSetSourceContent (s, (int) lineOrAddr, noerror);
d145 1
a145 1
    ret = tuiSetDisassemContent (s, (Opaque) lineOrAddr);
d159 1
a159 1
	  current_source_line = (int) lineOrAddr +
d188 2
a189 1

d201 2
a202 1
	  tuiShowSource (sal.symtab, sal.line, FALSE);
d231 2
a232 1

d241 2
a242 1
      tuiShowSource (s, line, FALSE);
d429 3
a431 6
				  ((winInfo == srcWin) ?
				   (Opaque) ((TuiWinElementPtr)
       winInfo->generic.content[0])->whichElement.source.lineOrAddr.lineNo :
				   (Opaque) ((TuiWinElementPtr)
	 winInfo->generic.content[0])->whichElement.source.lineOrAddr.addr),
				  (int) FALSE);
d443 1
a443 1
tuiSetIsExecPointAt (Opaque lineOrAddr, TuiWinInfoPtr winInfo)
d451 1
a451 1
      if (content[i]->whichElement.source.lineOrAddr.addr == lineOrAddr)
a460 1

d759 2
d763 3
a765 1
      tuiSetIsExecPointAt ((Opaque) - 1, winInfo);	/* the target is'n running */
d778 1
a778 1
		      (Opaque) NULL,
d840 1
a840 1
tuiLineIsDisplayed (Opaque lineNoOrAddr, TuiWinInfoPtr winInfo,
d853 3
a855 8
      if (winInfo == srcWin)
	isDisplayed = (((TuiWinElementPtr)
	 winInfo->generic.content[i])->whichElement.source.lineOrAddr.lineNo
		       == (int) lineNoOrAddr);
      else
	isDisplayed = (((TuiWinElementPtr)
	   winInfo->generic.content[i])->whichElement.source.lineOrAddr.addr
		       == lineNoOrAddr);
d861 29
@


1.5
log
@	* tuiData.h (TuiLocatorElement): Use CORE_ADDR for address member.
	(TuiLineOrAddress): Likewise.
	* tuiDisassem.c (tuiGetBeginAsmAddress): Use CORE_ADDR to specify
	an address.
	(tuiSetDisassemContent): Likewise.
	(tuiShowDisassem, tuiShowDisassemAndUpdateSource): Likewise.
	* tuiLayout.c (_extractDisplayStartAddr): Likewise.
	(tuiSetLayout): Likewise.
	* tuiSourceWin.c (tuiDisplayMainFunction): Likewise.
	(tuiUpdateSourceWindowsWithAddr): Likewise.
	(tuiUpdateSourceWindowsWithLine): Likewise.
	(tuiSetHasBreakAt): Likewise.
	* tuiStack.c (tuiSetLocatorInfo): Likewise.
	(tuiSwitchFilename): Likewise.
	(tuiUpdateLocatorInfoFromFrame): Likewise.
	(tuiSetLocatorContent): Likewise.
	(tuiShowFrameInfo): Likewise.
	* tuiDisassem.h: Update prototypes to use CORE_ADDR.
	* tuiSourceWin.h: Likewise.
	* tuiStack.h: Likewise.
@
text
@a219 16

/*
   ** tui_vUpdateSourceWindowsWithAddr()
   **        Update the source window with the address in a va_list
 */
void
tui_vUpdateSourceWindowsWithAddr (va_list args)
{
  Opaque addr = va_arg (args, Opaque);

  tuiUpdateSourceWindowsWithAddr (addr);

  return;
}				/* tui_vUpdateSourceWindowsWithAddr */


a249 17

/*
   ** tui_vUpdateSourceWindowsWithLine()
   **        Update the source window with the line number in a va_list
 */
void
tui_vUpdateSourceWindowsWithLine (va_list args)
{
  struct symtab *s = va_arg (args, struct symtab *);
  int line = va_arg (args, int);

  tuiUpdateSourceWindowsWithLine (s, line);

  return;
}				/* tui_vUpdateSourceWindowsWithLine */


a526 18
/*
   ** tui_vAllSetHasBreakAt()
   **        Set or clear the hasBreak flag in all displayed source windows,
   **        with params in a va_list
 */
void
tui_vAllSetHasBreakAt (va_list args)
{
  struct breakpoint *bp = va_arg (args, struct breakpoint *);
  int hasBreak = va_arg (args, int);

  tuiAllSetHasBreakAt (bp, hasBreak);

  return;
}				/* tui_vAllSetHasBreakAt */



d721 1
a721 1
}				/* tuiUpdateExecInfo
@


1.4
log
@	* tuiWin.c: Add missing includes.
	(_makeVisibleWithNewHeight): Fix call to find_line_pc.
	* tuiLayout.c: Add missing includes.
	(_initAndMakeWin): Don't put curses in echo mode.
	(_extractDisplayStartAddr): Fix calls to find_line_pc.
	(_tuiLayout_command): Missing ',' in warning call.
	* tuiSourceWin.c (tuiUpdateSourceWindowsWithLine): Fix calls to
	find_line_pc.
	(tuiSetHasBreakAt): Check for null source file.
@
text
@d31 2
d98 1
a98 1
      if (addr <= (CORE_ADDR) 0)
d100 1
a100 1
      if (addr > (CORE_ADDR) 0)
d104 1
a104 1
	  tuiUpdateSourceWindowsWithAddr ((Opaque) addr);
d183 1
a183 1
tuiUpdateSourceWindowsWithAddr (Opaque addr)
d185 1
a185 1
  if (addr > (Opaque) NULL)
d199 2
a200 4
	  sal = find_pc_line ((CORE_ADDR) addr, 0);
	  tuiShowSource (sal.symtab,
			 (Opaque) sal.line,
			 FALSE);
d251 1
a251 1
      tuiUpdateSourceWindowsWithAddr ((Opaque) pc);
d254 1
a254 1
      tuiShowSource (s, (Opaque) line, FALSE);
d258 1
a258 1
	  tuiShowDisassem ((Opaque) pc);
d530 1
a530 1
		 == (Opaque) bp->address);
@


1.3
log
@	* tuiWin.c, tui.c, tuiCommand.c: Use ansi prototype.
	tuiIO.c, tuiData.c: Likewise.
	tuiDataWin.c, tuiDisassem.c: Likewise.
	tuiGeneralWin.c, tuiLayout.c: Likewise.
	tuiRegs.c, tuiSource.c: Likewise.
	tuiSouceWin.c, tuiStack.c: Likewise.
@
text
@d244 2
d250 2
a251 1
      tuiUpdateSourceWindowsWithAddr ((Opaque) find_line_pc (s, line));
d256 4
a259 1
	tuiShowDisassem ((Opaque) find_line_pc (s, line));
d523 1
@


1.2
log
@	* tuiWin.c, tuiWin.h, tui.c, tui.h, tuiCommand.c: Add FSF copyright.
	tuiCommand.h, tuiIO.c, tuiIO.h, tuiData.h, tuiData.c: Likewise.
	tuiDataWin.c, tuiDataWin.h, tuiDisassem.c, tuiDisassem.h: Likewise.
	tuiGeneralWin.c, tuiGeneralWin.h, tuiLayout.c, tuiLayout.h: Likewise.
	tuiRegs.c, tuiRegs.h, tuiSource.c, tuiSource.h: Likewise.
	tuiSouceWin.c, tuiSourceWin.h, tuiStack.c, tuiStack.h: Likewise.
@
text
@a67 1
#ifdef __STDC__
a68 3
#else
tuiSrcWinIsDisplayed ()
#endif
a77 1
#ifdef __STDC__
a78 3
#else
tuiAsmWinIsDisplayed ()
#endif
a88 1
#ifdef __STDC__
a89 3
#else
tuiDisplayMainFunction ()
#endif
d119 2
a120 13
#ifdef __STDC__
tuiUpdateSourceWindow (
			TuiWinInfoPtr winInfo,
			struct symtab *s,
			Opaque lineOrAddr,
			int noerror)
#else
tuiUpdateSourceWindow (winInfo, s, lineOrAddr, noerror)
     TuiWinInfoPtr winInfo;
     struct symtab *s;
     Opaque lineOrAddr;
     int noerror;
#endif
d135 2
a136 13
#ifdef __STDC__
tuiUpdateSourceWindowAsIs (
			    TuiWinInfoPtr winInfo,
			    struct symtab *s,
			    Opaque lineOrAddr,
			    int noerror)
#else
tuiUpdateSourceWindowAsIs (winInfo, s, lineOrAddr, noerror)
     TuiWinInfoPtr winInfo;
     struct symtab *s;
     Opaque lineOrAddr;
     int noerror;
#endif
d181 1
a181 7
#ifdef __STDC__
tuiUpdateSourceWindowsWithAddr (
				 Opaque addr)
#else
tuiUpdateSourceWindowsWithAddr (addr)
     Opaque addr;
#endif
d226 1
a226 7
#ifdef __STDC__
tui_vUpdateSourceWindowsWithAddr (
				   va_list args)
#else
tui_vUpdateSourceWindowsWithAddr (args)
     va_list args;
#endif
d242 1
a242 9
#ifdef __STDC__
tuiUpdateSourceWindowsWithLine (
				 struct symtab *s,
				 int line)
#else
tuiUpdateSourceWindowsWithLine (s, line)
     struct symtab *s;
     int line;
#endif
d266 1
a266 7
#ifdef __STDC__
tui_vUpdateSourceWindowsWithLine (
				   va_list args)
#else
tui_vUpdateSourceWindowsWithLine (args)
     va_list args;
#endif
d281 1
a281 9
#ifdef __STDC__
tuiClearSourceContent (
			TuiWinInfoPtr winInfo,
			int displayPrompt)
#else
tuiClearSourceContent (winInfo, displayPrompt)
     TuiWinInfoPtr winInfo;
     int displayPrompt;
#endif
d306 1
a306 7
#ifdef __STDC__
tuiClearAllSourceWinsContent (
			       int displayPrompt)
#else
tuiClearAllSourceWinsContent (displayPrompt)
     int displayPrompt;
#endif
d322 1
a322 9
#ifdef __STDC__
tuiEraseSourceContent (
			TuiWinInfoPtr winInfo,
			int displayPrompt)
#else
tuiEraseSourceContent (winInfo, displayPrompt)
     TuiWinInfoPtr winInfo;
     int displayPrompt;
#endif
d365 1
a365 7
#ifdef __STDC__
tuiEraseAllSourceWinsContent (
			       int displayPrompt)
#else
tuiEraseAllSourceWinsContent (displayPrompt)
     int displayPrompt;
#endif
d381 1
a381 7
#ifdef __STDC__
tuiShowSourceContent (
		       TuiWinInfoPtr winInfo)
#else
tuiShowSourceContent (winInfo)
     TuiWinInfoPtr winInfo;
#endif
a409 1
#ifdef __STDC__
a410 3
#else
tuiShowAllSourceWinsContent ()
#endif
d426 3
a428 11
#ifdef __STDC__
tuiHorizontalSourceScroll (
			    TuiWinInfoPtr winInfo,
			    TuiScrollDirection direction,
			    int numToScroll)
#else
tuiHorizontalSourceScroll (winInfo, direction, numToScroll)
     TuiWinInfoPtr winInfo;
     TuiScrollDirection direction;
     int numToScroll;
#endif
d469 1
a469 9
#ifdef __STDC__
tuiSetIsExecPointAt (
		      Opaque lineOrAddr,
		      TuiWinInfoPtr winInfo)
#else
tuiSetIsExecPointAt (lineOrAddr, winInfo)
     Opaque lineOrAddr;
     TuiWinInfoPtr winInfo;
#endif
d493 1
a493 11
#ifdef __STDC__
tuiSetHasBreakAt (
		   struct breakpoint *bp,
		   TuiWinInfoPtr winInfo,
		   int hasBreak)
#else
tuiSetHasBreakAt (bp, winInfo, hasBreak)
     struct breakpoint *bp;
     TuiWinInfoPtr winInfo;
     int hasBreak;
#endif
d541 1
a541 9
#ifdef __STDC__
tuiAllSetHasBreakAt (
		      struct breakpoint *bp,
		      int hasBreak)
#else
tuiAllSetHasBreakAt (bp, hasBreak)
     struct breakpoint *bp;
     int hasBreak;
#endif
d559 1
a559 7
#ifdef __STDC__
tui_vAllSetHasBreakAt (
			va_list args)
#else
tui_vAllSetHasBreakAt (args)
     va_list args;
#endif
d582 1
a582 7
#ifdef __STDC__
tuiSetExecInfoContent (
			TuiWinInfoPtr winInfo)
#else
tuiSetExecInfoContent (winInfo)
     TuiWinInfoPtr winInfo;
#endif
d663 1
a663 7
#ifdef __STDC__
tuiShowExecInfoContent (
			 TuiWinInfoPtr winInfo)
#else
tuiShowExecInfoContent (winInfo)
     TuiWinInfoPtr winInfo;
#endif
a686 1
#ifdef __STDC__
a687 3
#else
tuiShowAllExecInfosContent ()
#endif
d702 1
a702 7
#ifdef __STDC__
tuiEraseExecInfoContent (
			  TuiWinInfoPtr winInfo)
#else
tuiEraseExecInfoContent (winInfo)
     TuiWinInfoPtr winInfo;
#endif
a716 1
#ifdef __STDC__
a717 3
#else
tuiEraseAllExecInfosContent ()
#endif
d732 1
a732 7
#ifdef __STDC__
tuiClearExecInfoContent (
			  TuiWinInfoPtr winInfo)
#else
tuiClearExecInfoContent (winInfo)
     TuiWinInfoPtr winInfo;
#endif
a744 1
#ifdef __STDC__
a745 3
#else
tuiClearAllExecInfosContent ()
#endif
d761 1
a761 7
#ifdef __STDC__
tuiUpdateExecInfo (
		    TuiWinInfoPtr winInfo)
#else
tuiUpdateExecInfo (winInfo)
     TuiWinInfoPtr winInfo;
#endif
a771 1
#ifdef __STDC__
a772 3
#else
tuiUpdateAllExecInfos ()
#endif
a790 1
#ifdef __STDC__
a791 3
#else
tuiUpdateOnEnd ()
#endif
d828 1
a828 7
#ifdef __STDC__
tuiAllocSourceBuffer (
		       TuiWinInfoPtr winInfo)
#else
tuiAllocSourceBuffer (winInfo)
     TuiWinInfoPtr winInfo;
#endif
d880 2
a881 11
#ifdef __STDC__
tuiLineIsDisplayed (
		     Opaque lineNoOrAddr,
		     TuiWinInfoPtr winInfo,
		     int checkThreshold)
#else
tuiLineIsDisplayed (lineNoOrAddr, winInfo, checkThreshold)
     Opaque lineNoOrAddr;
     TuiWinInfoPtr winInfo;
     int checkThreshold;
#endif
@


1.1
log
@Initial revision
@
text
@d1 20
a20 5
/*
** tuiSourceWin.c
**         This module contains functions for displaying source or assembly in the "source" window.
*        The "source" window may be the assembly or the source windows.
*/
d65 2
a66 2
** tuiSrcWinIsDisplayed().
*/
d79 2
a80 2
** tuiAsmWinIsDisplayed().
*/
d93 3
a95 3
** tuiDisplayMainFunction().
**        Function to display the "main" routine"
*/
d126 4
a129 4
** tuiUpdateSourceWindow().
**    Function to display source in the source window.  This function
**    initializes the horizontal scroll to 0.
*/
d153 4
a156 4
** tuiUpdateSourceWindowAsIs().
**        Function to display source in the source/asm window.  This
**        function shows the source as specified by the horizontal offset.
*/
d195 3
a197 3
            ** If the focus was in the asm win, put it in the src
            ** win if we don't have a split layout
            */
d210 4
a213 4
** tuiUpdateSourceWindowsWithAddr().
**        Function to ensure that the source and/or disassemly windows
**        reflect the input address.
*/
d262 3
a264 3
** tui_vUpdateSourceWindowsWithAddr()
**        Update the source window with the address in a va_list
*/
d283 4
a286 4
** tuiUpdateSourceWindowsWithLine().
**        Function to ensure that the source and/or disassemly windows
**        reflect the input address.
*/
d316 3
a318 3
** tui_vUpdateSourceWindowsWithLine()
**        Update the source window with the line number in a va_list
*/
d338 2
a339 2
** tuiClearSourceContent().
*/
d371 2
a372 2
** tuiClearAllSourceWinsContent().
*/
d393 2
a394 2
** tuiEraseSourceContent().
*/
d431 3
a433 3
                   the window to what is on the  screen, so that later calls
                   to refresh, do display
                   the correct stuff, and not the old image */
d444 2
a445 2
** tuiEraseAllSourceContent().
*/
d466 2
a467 2
** tuiShowSourceContent().
*/
d501 2
a502 2
** tuiShowAllSourceWinsContent()
*/
d520 3
a522 3
** tuiHorizontalSourceScroll().
**      Scroll the source forward or backward horizontally
*/
d571 3
a573 3
** tuiSetHasExecPointAt().
**        Set or clear the hasBreak flag in the line whose line is lineNo.
*/
d603 3
a605 3
** tuiSetHasBreakAt().
**        Set or clear the hasBreak flag in the line whose line is lineNo.
*/
d661 3
a663 3
** tuiAllSetHasBreakAt().
**        Set or clear the hasBreak flag in all displayed source windows.
*/
d686 4
a689 4
** tui_vAllSetHasBreakAt()
**        Set or clear the hasBreak flag in all displayed source windows,
**        with params in a va_list
*/
d714 5
a718 5
** tuiSetExecInfoContent().
**      Function to initialize the content of the execution info window,
**      based upon the input window which is either the source or
**      disassembly window.
*/
d750 4
a753 4
                ** First check to see if we have a breakpoint that is
                ** temporary.  If so, and this is our current execution point,
                ** then clear the break indicator.
                */
d780 3
a782 3
                ** Now update the exec info content based upon the state
                ** of each line as indicated by the source content.
                */
d804 2
a805 2
** tuiShowExecInfoContent().
*/
d834 2
a835 2
** tuiShowAllExecInfosContent()
*/
d853 2
a854 2
** tuiEraseExecInfoContent().
*/
d874 2
a875 2
** tuiEraseAllExecInfosContent()
*/
d893 2
a894 2
** tuiClearExecInfoContent().
*/
d912 2
a913 2
** tuiClearAllExecInfosContent()
*/
d931 3
a933 3
** tuiUpdateExecInfo().
**        Function to update the execution info window
*/
d948 3
a950 3
/*
** tuiUpdateAllExecInfos()
*/
d964 1
a964 1
}				/* tuiUpdateAllExecInfos*/
d969 5
a973 5
**       elz: This function clears the execution info from the source windows
**       and resets the locator to display no line info, procedure info, pc
**       info.  It is called by stack_publish_stopped_with_no_frame, which
**       is called then the target terminates execution
*/
d995 2
a996 2
      tuiSetExecInfoContent (winInfo);	/*set winInfo so that > is'n displayed*/
      tuiShowExecInfoContent (winInfo);	/* display the new contents */
d999 1
a999 1
  /*now update the locator*/
d1031 4
a1034 4
    ** Allocate the buffer for the source lines.  Do this only once since they
    ** will be re-used for all source displays.  The only other time this will
    ** be done is when a window's size changes.
    */
d1069 4
a1072 4
** tuiLineIsDisplayed().
**      Answer whether the a particular line number or address is displayed
**      in the current source window.
*/
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d2 4
a5 4
   ** tuiSourceWin.c
   **         This module contains functions for displaying source or assembly in the "source" window.
   *        The "source" window may be the assembly or the source windows.
 */
d50 2
a51 2
   ** tuiSrcWinIsDisplayed().
 */
d64 2
a65 2
   ** tuiAsmWinIsDisplayed().
 */
d78 3
a80 3
   ** tuiDisplayMainFunction().
   **        Function to display the "main" routine"
 */
d111 4
a114 4
   ** tuiUpdateSourceWindow().
   **    Function to display source in the source window.  This function
   **    initializes the horizontal scroll to 0.
 */
d138 4
a141 4
   ** tuiUpdateSourceWindowAsIs().
   **        Function to display source in the source/asm window.  This
   **        function shows the source as specified by the horizontal offset.
 */
d180 3
a182 3
	     ** If the focus was in the asm win, put it in the src
	     ** win if we don't have a split layout
	   */
d195 4
a198 4
   ** tuiUpdateSourceWindowsWithAddr().
   **        Function to ensure that the source and/or disassemly windows
   **        reflect the input address.
 */
d247 3
a249 3
   ** tui_vUpdateSourceWindowsWithAddr()
   **        Update the source window with the address in a va_list
 */
d268 4
a271 4
   ** tuiUpdateSourceWindowsWithLine().
   **        Function to ensure that the source and/or disassemly windows
   **        reflect the input address.
 */
d301 3
a303 3
   ** tui_vUpdateSourceWindowsWithLine()
   **        Update the source window with the line number in a va_list
 */
d323 2
a324 2
   ** tuiClearSourceContent().
 */
d356 2
a357 2
   ** tuiClearAllSourceWinsContent().
 */
d378 2
a379 2
   ** tuiEraseSourceContent().
 */
d416 3
a418 3
	     the window to what is on the  screen, so that later calls
	     to refresh, do display
	     the correct stuff, and not the old image */
d429 2
a430 2
   ** tuiEraseAllSourceContent().
 */
d451 2
a452 2
   ** tuiShowSourceContent().
 */
d486 2
a487 2
   ** tuiShowAllSourceWinsContent()
 */
d505 3
a507 3
   ** tuiHorizontalSourceScroll().
   **      Scroll the source forward or backward horizontally
 */
d556 3
a558 3
   ** tuiSetHasExecPointAt().
   **        Set or clear the hasBreak flag in the line whose line is lineNo.
 */
d588 3
a590 3
   ** tuiSetHasBreakAt().
   **        Set or clear the hasBreak flag in the line whose line is lineNo.
 */
d646 3
a648 3
   ** tuiAllSetHasBreakAt().
   **        Set or clear the hasBreak flag in all displayed source windows.
 */
d671 4
a674 4
   ** tui_vAllSetHasBreakAt()
   **        Set or clear the hasBreak flag in all displayed source windows,
   **        with params in a va_list
 */
d699 5
a703 5
   ** tuiSetExecInfoContent().
   **      Function to initialize the content of the execution info window,
   **      based upon the input window which is either the source or
   **      disassembly window.
 */
d735 4
a738 4
	         ** First check to see if we have a breakpoint that is
	         ** temporary.  If so, and this is our current execution point,
	         ** then clear the break indicator.
	       */
d765 3
a767 3
	         ** Now update the exec info content based upon the state
	         ** of each line as indicated by the source content.
	       */
d789 2
a790 2
   ** tuiShowExecInfoContent().
 */
d819 2
a820 2
   ** tuiShowAllExecInfosContent()
 */
d838 2
a839 2
   ** tuiEraseExecInfoContent().
 */
d859 2
a860 2
   ** tuiEraseAllExecInfosContent()
 */
d878 2
a879 2
   ** tuiClearExecInfoContent().
 */
d897 2
a898 2
   ** tuiClearAllExecInfosContent()
 */
d916 3
a918 3
   ** tuiUpdateExecInfo().
   **        Function to update the execution info window
 */
d933 3
a935 3
				   /*
				   ** tuiUpdateAllExecInfos()
				 */
d949 1
a949 1
}				/* tuiUpdateAllExecInfos */
d954 5
a958 5
   **       elz: This function clears the execution info from the source windows
   **       and resets the locator to display no line info, procedure info, pc
   **       info.  It is called by stack_publish_stopped_with_no_frame, which
   **       is called then the target terminates execution
 */
d980 2
a981 2
      tuiSetExecInfoContent (winInfo);	/*set winInfo so that > is'n displayed */
      tuiShowExecInfoContent (winInfo);		/* display the new contents */
d984 1
a984 1
  /*now update the locator */
d1016 4
a1019 4
     ** Allocate the buffer for the source lines.  Do this only once since they
     ** will be re-used for all source displays.  The only other time this will
     ** be done is when a window's size changes.
   */
d1054 4
a1057 4
   ** tuiLineIsDisplayed().
   **      Answer whether the a particular line number or address is displayed
   **      in the current source window.
 */
@

