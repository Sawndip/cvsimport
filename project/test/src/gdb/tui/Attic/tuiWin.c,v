head	1.30;
access;
symbols
	drow-cplus-merge-20040113:1.29
	drow-cplus-merge-20031224:1.29
	drow-cplus-merge-20031220:1.29
	carlton_dictionary-20031215-merge:1.29
	drow-cplus-merge-20031214:1.29
	carlton-dictionary-20031111-merge:1.29
	gdb_6_0-2003-10-04-release:1.29
	kettenis_sparc-20030918-branch:1.29.0.8
	kettenis_sparc-20030918-branchpoint:1.29
	carlton_dictionary-20030917-merge:1.29
	ezannoni_pie-20030916-branchpoint:1.29
	ezannoni_pie-20030916-branch:1.29.0.6
	cagney_x86i386-20030821-branch:1.29.0.4
	cagney_x86i386-20030821-branchpoint:1.29
	carlton_dictionary-20030805-merge:1.29
	carlton_dictionary-20030627-merge:1.29
	gdb_6_0-branch:1.29.0.2
	gdb_6_0-2003-06-23-branchpoint:1.29
	jimb-ppc64-linux-20030613-branch:1.28.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.28
	cagney_convert-20030606-branch:1.27.0.30
	cagney_convert-20030606-branchpoint:1.27
	cagney_writestrings-20030508-branch:1.27.0.28
	cagney_writestrings-20030508-branchpoint:1.27
	jimb-ppc64-linux-20030528-branch:1.27.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.27
	carlton_dictionary-20030523-merge:1.27
	cagney_fileio-20030521-branch:1.27.0.24
	cagney_fileio-20030521-branchpoint:1.27
	kettenis_i386newframe-20030517-mergepoint:1.27
	jimb-ppc64-linux-20030509-branch:1.27.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.27
	kettenis_i386newframe-20030504-mergepoint:1.27
	carlton_dictionary-20030430-merge:1.27
	kettenis_i386newframe-20030419-branch:1.27.0.20
	kettenis_i386newframe-20030419-branchpoint:1.27
	carlton_dictionary-20030416-merge:1.27
	cagney_frameaddr-20030409-mergepoint:1.27
	kettenis_i386newframe-20030406-branch:1.27.0.18
	kettenis_i386newframe-20030406-branchpoint:1.27
	cagney_frameaddr-20030403-branchpoint:1.27
	cagney_frameaddr-20030403-branch:1.27.0.16
	cagney_framebase-20030330-mergepoint:1.27
	cagney_framebase-20030326-branch:1.27.0.14
	cagney_framebase-20030326-branchpoint:1.27
	cagney_lazyid-20030317-branch:1.27.0.12
	cagney_lazyid-20030317-branchpoint:1.27
	kettenis-i386newframe-20030316-mergepoint:1.27
	offbyone-20030313-branch:1.27.0.10
	offbyone-20030313-branchpoint:1.27
	kettenis-i386newframe-20030308-branch:1.27.0.8
	kettenis-i386newframe-20030308-branchpoint:1.27
	carlton_dictionary-20030305-merge:1.27
	cagney_offbyone-20030303-branch:1.27.0.6
	cagney_offbyone-20030303-branchpoint:1.27
	carlton_dictionary-20030207-merge:1.27
	interps-20030203-mergepoint:1.27
	interps-20030202-branch:1.27.0.4
	interps-20030202-branchpoint:1.27
	cagney-unwind-20030108-branch:1.27.0.2
	cagney-unwind-20030108-branchpoint:1.27
	carlton_dictionary-20021223-merge:1.27
	gdb_5_3-2002-12-12-release:1.23.2.1
	carlton_dictionary-20021115-merge:1.25
	kseitz_interps-20021105-merge:1.25
	kseitz_interps-20021103-merge:1.25
	drow-cplus-merge-20021020:1.24
	drow-cplus-merge-20021025:1.24
	carlton_dictionary-20021025-merge:1.24
	carlton_dictionary-20021011-merge:1.24
	drow-cplus-branch:1.24.0.2
	drow-cplus-branchpoint:1.24
	kseitz_interps-20020930-merge:1.24
	carlton_dictionary-20020927-merge:1.23
	carlton_dictionary-branch:1.23.0.4
	carlton_dictionary-20020920-branchpoint:1.23
	gdb_5_3-branch:1.23.0.2
	gdb_5_3-2002-09-04-branchpoint:1.23
	kseitz_interps-20020829-merge:1.21
	cagney_sysregs-20020825-branch:1.21.0.2
	cagney_sysregs-20020825-branchpoint:1.21
	readline_4_3-import-branch:1.19.0.10
	readline_4_3-import-branchpoint:1.19
	gdb_5_2_1-2002-07-23-release:1.19
	kseitz_interps-20020528-branch:1.19.0.8
	kseitz_interps-20020528-branchpoint:1.19
	cagney_regbuf-20020515-branch:1.19.0.6
	cagney_regbuf-20020515-branchpoint:1.19
	jimb-macro-020506-branch:1.19.0.4
	jimb-macro-020506-branchpoint:1.19
	gdb_5_2-2002-04-29-release:1.19
	gdb_5_2-branch:1.19.0.2
	gdb_5_2-2002-03-03-branchpoint:1.19
	gdb_5_1_1-2002-01-24-release:1.16
	gdb_5_1_0_1-2002-01-03-release:1.16
	cygnus_cvs_20020108_pre:1.16
	gdb_5_1_0_1-2002-01-03-branch:1.16.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.16
	gdb_5_1-2001-11-21-release:1.16
	gdb_s390-2001-09-26-branch:1.16.0.4
	gdb_s390-2001-09-26-branchpoint:1.16
	gdb_5_1-2001-07-29-branch:1.16.0.2
	gdb_5_1-2001-07-29-branchpoint:1.16
	dberlin-typesystem-branch:1.3.0.2
	dberlin-typesystem-branchpoint:1.3
	gdb-post-ptid_t-2001-05-03:1.3
	gdb-pre-ptid_t-2001-05-03:1.3
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.30
date	2004.01.19.04.31.53;	author cagney;	state dead;
branches;
next	1.29;

1.29
date	2003.06.22.15.21.39;	author drow;	state Exp;
branches
	1.29.6.1;
next	1.28;

1.28
date	2003.06.12.15.44.24;	author schwab;	state Exp;
branches;
next	1.27;

1.27
date	2002.12.08.22.31.37;	author ezannoni;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.29.19.15.16;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2002.10.25.19.46.04;	author ciceron;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.30.00.52.27;	author ezannoni;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2002.09.02.19.34.18;	author ciceron;	state Exp;
branches
	1.23.2.1
	1.23.4.1;
next	1.22;

1.22
date	2002.09.01.17.23.59;	author ciceron;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.24.16.43.08;	author ciceron;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.24.12.28.32;	author ciceron;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.01.06.19.28;	author cagney;	state Exp;
branches
	1.19.8.1
	1.19.10.1;
next	1.18;

1.18
date	2002.02.08.15.54.32;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.02.00.56.37;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.28.19.30.54;	author ciceron;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.23.21.13.57;	author ciceron;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.21.20.57.17;	author ciceron;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.21.19.44.38;	author ciceron;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.20.23.06.48;	author ciceron;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.20.22.22.08;	author ciceron;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.19.22.47.46;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.18.22.03.22;	author ciceron;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.17.22.22.40;	author ciceron;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.17.21.37.18;	author ciceron;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.16.22.13.38;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.14.19.31.09;	author ciceron;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.14.19.01.25;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.42;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.19.35;	author jsm;	state Exp;
branches;
next	;

1.19.8.1
date	2002.08.30.22.52.52;	author kseitz;	state Exp;
branches;
next	1.19.8.2;

1.19.8.2
date	2002.10.01.00.46.35;	author kseitz;	state Exp;
branches;
next	1.19.8.3;

1.19.8.3
date	2002.11.03.22.07.42;	author ezannoni;	state Exp;
branches;
next	;

1.19.10.1
date	2002.08.27.16.23.29;	author ezannoni;	state Exp;
branches;
next	;

1.23.2.1
date	2002.10.25.19.46.41;	author ciceron;	state Exp;
branches;
next	;

1.23.4.1
date	2002.10.11.22.23.03;	author carlton;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2002.11.15.19.19.20;	author carlton;	state Exp;
branches;
next	1.23.4.3;

1.23.4.3
date	2002.12.23.19.39.21;	author carlton;	state Exp;
branches;
next	1.23.4.4;

1.23.4.4
date	2003.06.27.21.50.21;	author carlton;	state Exp;
branches;
next	1.23.4.5;

1.23.4.5
date	2004.01.26.19.11.45;	author carlton;	state dead;
branches;
next	;

1.24.2.1
date	2003.12.14.20.27.59;	author drow;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2004.02.09.19.43.58;	author drow;	state dead;
branches;
next	;

1.29.6.1
date	2004.03.23.20.09.17;	author ezannoni;	state dead;
branches;
next	;


desc
@@


1.30
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@/* TUI window generic functions.

   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This module contains procedures for handling tui window functions
   like resize, scrolling, scrolling, changing focus, etc.

   Author: Susan B. Macchia  */

#include "defs.h"
#include "command.h"
#include "symtab.h"
#include "breakpoint.h"
#include "frame.h"
#include "cli/cli-cmds.h"
#include "top.h"
#include "source.h"

#include "tui.h"
#include "tuiData.h"
#include "tuiGeneralWin.h"
#include "tuiStack.h"
#include "tuiRegs.h"
#include "tuiDisassem.h"
#include "tuiSource.h"
#include "tuiSourceWin.h"
#include "tuiDataWin.h"

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

#include <string.h>
#include <ctype.h>
#include <readline/readline.h>

/*******************************
** Static Local Decls
********************************/
static void _makeVisibleWithNewHeight (TuiWinInfoPtr);
static void _makeInvisibleAndSetNewHeight (TuiWinInfoPtr, int);
static TuiStatus _tuiAdjustWinHeights (TuiWinInfoPtr, int);
static int _newHeightOk (TuiWinInfoPtr, int);
static void _tuiSetTabWidth_command (char *, int);
static void _tuiRefreshAll_command (char *, int);
static void _tuiSetWinHeight_command (char *, int);
static void _tuiXDBsetWinHeight_command (char *, int);
static void _tuiAllWindowsInfo (char *, int);
static void _tuiSetFocus_command (char *, int);
static void _tuiScrollForward_command (char *, int);
static void _tuiScrollBackward_command (char *, int);
static void _tuiScrollLeft_command (char *, int);
static void _tuiScrollRight_command (char *, int);
static void _parseScrollingArgs (char *, TuiWinInfoPtr *, int *);


/***************************************
** DEFINITIONS
***************************************/
#define WIN_HEIGHT_USAGE      "Usage: winheight <win_name> [+ | -] <#lines>\n"
#define XDBWIN_HEIGHT_USAGE   "Usage: w <#lines>\n"
#define FOCUS_USAGE           "Usage: focus {<win> | next | prev}\n"

/***************************************
** PUBLIC FUNCTIONS
***************************************/

#ifndef ACS_LRCORNER
#  define ACS_LRCORNER '+'
#endif
#ifndef ACS_LLCORNER
#  define ACS_LLCORNER '+'
#endif
#ifndef ACS_ULCORNER
#  define ACS_ULCORNER '+'
#endif
#ifndef ACS_URCORNER
#  define ACS_URCORNER '+'
#endif
#ifndef ACS_HLINE
#  define ACS_HLINE '-'
#endif
#ifndef ACS_VLINE
#  define ACS_VLINE '|'
#endif

/* Possible values for tui-border-kind variable.  */
static const char *tui_border_kind_enums[] = {
  "space",
  "ascii",
  "acs",
  NULL
};

/* Possible values for tui-border-mode and tui-active-border-mode.  */
static const char *tui_border_mode_enums[] = {
  "normal",
  "standout",
  "reverse",
  "half",
  "half-standout",
  "bold",
  "bold-standout",
  NULL
};

struct tui_translate
{
  const char *name;
  int value;
};

/* Translation table for border-mode variables.
   The list of values must be terminated by a NULL.
   After the NULL value, an entry defines the default.  */
struct tui_translate tui_border_mode_translate[] = {
  { "normal",		A_NORMAL },
  { "standout",		A_STANDOUT },
  { "reverse",		A_REVERSE },
  { "half",		A_DIM },
  { "half-standout",	A_DIM | A_STANDOUT },
  { "bold",		A_BOLD },
  { "bold-standout",	A_BOLD | A_STANDOUT },
  { 0, 0 },
  { "normal",		A_NORMAL }
};

/* Translation tables for border-kind, one for each border
   character (see wborder, border curses operations).
   -1 is used to indicate the ACS because ACS characters
   are determined at run time by curses (depends on terminal).  */
struct tui_translate tui_border_kind_translate_vline[] = {
  { "space",    ' ' },
  { "ascii",    '|' },
  { "acs",      -1 },
  { 0, 0 },
  { "ascii",    '|' }
};

struct tui_translate tui_border_kind_translate_hline[] = {
  { "space",    ' ' },
  { "ascii",    '-' },
  { "acs",      -1 },
  { 0, 0 },
  { "ascii",    '-' }
};

struct tui_translate tui_border_kind_translate_ulcorner[] = {
  { "space",    ' ' },
  { "ascii",    '+' },
  { "acs",      -1 },
  { 0, 0 },
  { "ascii",    '+' }
};

struct tui_translate tui_border_kind_translate_urcorner[] = {
  { "space",    ' ' },
  { "ascii",    '+' },
  { "acs",      -1 },
  { 0, 0 },
  { "ascii",    '+' }
};

struct tui_translate tui_border_kind_translate_llcorner[] = {
  { "space",    ' ' },
  { "ascii",    '+' },
  { "acs",      -1 },
  { 0, 0 },
  { "ascii",    '+' }
};

struct tui_translate tui_border_kind_translate_lrcorner[] = {
  { "space",    ' ' },
  { "ascii",    '+' },
  { "acs",      -1 },
  { 0, 0 },
  { "ascii",    '+' }
};


/* Tui configuration variables controlled with set/show command.  */
const char *tui_active_border_mode = "bold-standout";
const char *tui_border_mode = "normal";
const char *tui_border_kind = "acs";

/* Tui internal configuration variables.  These variables are
   updated by tui_update_variables to reflect the tui configuration
   variables.  */
chtype tui_border_vline;
chtype tui_border_hline;
chtype tui_border_ulcorner;
chtype tui_border_urcorner;
chtype tui_border_llcorner;
chtype tui_border_lrcorner;

int tui_border_attrs;
int tui_active_border_attrs;

/* Identify the item in the translation table.
   When the item is not recognized, use the default entry.  */
static struct tui_translate *
translate (const char *name, struct tui_translate *table)
{
  while (table->name)
    {
      if (name && strcmp (table->name, name) == 0)
        return table;
      table++;
    }

  /* Not found, return default entry.  */
  table++;
  return table;
}

/* Update the tui internal configuration according to gdb settings.
   Returns 1 if the configuration has changed and the screen should
   be redrawn.  */
int
tui_update_variables ()
{
  int need_redraw = 0;
  struct tui_translate *entry;

  entry = translate (tui_border_mode, tui_border_mode_translate);
  if (tui_border_attrs != entry->value)
    {
      tui_border_attrs = entry->value;
      need_redraw = 1;
    }
  entry = translate (tui_active_border_mode, tui_border_mode_translate);
  if (tui_active_border_attrs != entry->value)
    {
      tui_active_border_attrs = entry->value;
      need_redraw = 1;
    }

  /* If one corner changes, all characters are changed.
     Only check the first one.  The ACS characters are determined at
     run time by curses terminal management.  */
  entry = translate (tui_border_kind, tui_border_kind_translate_lrcorner);
  if (tui_border_lrcorner != (chtype) entry->value)
    {
      tui_border_lrcorner = (entry->value < 0) ? ACS_LRCORNER : entry->value;
      need_redraw = 1;
    }
  entry = translate (tui_border_kind, tui_border_kind_translate_llcorner);
  tui_border_llcorner = (entry->value < 0) ? ACS_LLCORNER : entry->value;

  entry = translate (tui_border_kind, tui_border_kind_translate_ulcorner);
  tui_border_ulcorner = (entry->value < 0) ? ACS_ULCORNER : entry->value;

  entry = translate (tui_border_kind, tui_border_kind_translate_urcorner);
  tui_border_urcorner = (entry->value < 0) ? ACS_URCORNER : entry->value;

  entry = translate (tui_border_kind, tui_border_kind_translate_hline);
  tui_border_hline = (entry->value < 0) ? ACS_HLINE : entry->value;

  entry = translate (tui_border_kind, tui_border_kind_translate_vline);
  tui_border_vline = (entry->value < 0) ? ACS_VLINE : entry->value;

  return need_redraw;
}

static void
set_tui_cmd (char *args, int from_tty)
{
}

static void
show_tui_cmd (char *args, int from_tty)
{
}

/*
   ** _initialize_tuiWin().
   **        Function to initialize gdb commands, for tui window manipulation.
 */
void
_initialize_tuiWin (void)
{
  struct cmd_list_element *c;
  static struct cmd_list_element *tui_setlist;
  static struct cmd_list_element *tui_showlist;

  /* Define the classes of commands.
     They will appear in the help list in the reverse of this order.  */
  add_cmd ("tui", class_tui, NULL,
	   "Text User Interface commands.",
	   &cmdlist);

  add_prefix_cmd ("tui", class_tui, set_tui_cmd,
                  "TUI configuration variables",
		  &tui_setlist, "set tui ",
		  0/*allow-unknown*/, &setlist);
  add_prefix_cmd ("tui", class_tui, show_tui_cmd,
                  "TUI configuration variables",
		  &tui_showlist, "show tui ",
		  0/*allow-unknown*/, &showlist);

  add_com ("refresh", class_tui, _tuiRefreshAll_command,
           "Refresh the terminal display.\n");
  if (xdb_commands)
    add_com_alias ("U", "refresh", class_tui, 0);
  add_com ("tabset", class_tui, _tuiSetTabWidth_command,
           "Set the width (in characters) of tab stops.\n\
Usage: tabset <n>\n");
  add_com ("winheight", class_tui, _tuiSetWinHeight_command,
           "Set the height of a specified window.\n\
Usage: winheight <win_name> [+ | -] <#lines>\n\
Window names are:\n\
src  : the source window\n\
cmd  : the command window\n\
asm  : the disassembly window\n\
regs : the register display\n");
  add_com_alias ("wh", "winheight", class_tui, 0);
  add_info ("win", _tuiAllWindowsInfo,
            "List of all displayed windows.\n");
  add_com ("focus", class_tui, _tuiSetFocus_command,
           "Set focus to named window or next/prev window.\n\
Usage: focus {<win> | next | prev}\n\
Valid Window names are:\n\
src  : the source window\n\
asm  : the disassembly window\n\
regs : the register display\n\
cmd  : the command window\n");
  add_com_alias ("fs", "focus", class_tui, 0);
  add_com ("+", class_tui, _tuiScrollForward_command,
           "Scroll window forward.\nUsage: + [win] [n]\n");
  add_com ("-", class_tui, _tuiScrollBackward_command,
           "Scroll window backward.\nUsage: - [win] [n]\n");
  add_com ("<", class_tui, _tuiScrollLeft_command,
           "Scroll window forward.\nUsage: < [win] [n]\n");
  add_com (">", class_tui, _tuiScrollRight_command,
           "Scroll window backward.\nUsage: > [win] [n]\n");
  if (xdb_commands)
    add_com ("w", class_xdb, _tuiXDBsetWinHeight_command,
             "XDB compatibility command for setting the height of a command window.\n\
Usage: w <#lines>\n");

  /* Define the tui control variables.  */
  c = add_set_enum_cmd
    ("border-kind", no_class,
     tui_border_kind_enums, &tui_border_kind,
     "Set the kind of border for TUI windows.\n"
     "This variable controls the border of TUI windows:\n"
     "space           use a white space\n"
     "ascii           use ascii characters + - | for the border\n"
     "acs             use the Alternate Character Set\n",
     &tui_setlist);
  add_show_from_set (c, &tui_showlist);

  c = add_set_enum_cmd
    ("border-mode", no_class,
     tui_border_mode_enums, &tui_border_mode,
     "Set the attribute mode to use for the TUI window borders.\n"
     "This variable controls the attributes to use for the window borders:\n"
     "normal          normal display\n"
     "standout        use highlight mode of terminal\n"
     "reverse         use reverse video mode\n"
     "half            use half bright\n"
     "half-standout   use half bright and standout mode\n"
     "bold            use extra bright or bold\n"
     "bold-standout   use extra bright or bold with standout mode\n",
     &tui_setlist);
  add_show_from_set (c, &tui_showlist);

  c = add_set_enum_cmd
    ("active-border-mode", no_class,
     tui_border_mode_enums, &tui_active_border_mode,
     "Set the attribute mode to use for the active TUI window border.\n"
     "This variable controls the attributes to use for the active window border:\n"
     "normal          normal display\n"
     "standout        use highlight mode of terminal\n"
     "reverse         use reverse video mode\n"
     "half            use half bright\n"
     "half-standout   use half bright and standout mode\n"
     "bold            use extra bright or bold\n"
     "bold-standout   use extra bright or bold with standout mode\n",
     &tui_setlist);
  add_show_from_set (c, &tui_showlist);
}

/* Update gdb's knowledge of the terminal size.  */
void
tui_update_gdb_sizes ()
{
  char cmd[50];
  int screenheight, screenwidth;

  rl_get_screen_size (&screenheight, &screenwidth);
  /* Set to TUI command window dimension or use readline values.  */
  sprintf (cmd, "set width %d",
           tui_active ? cmdWin->generic.width : screenwidth);
  execute_command (cmd, 0);
  sprintf (cmd, "set height %d",
           tui_active ? cmdWin->generic.height : screenheight);
  execute_command (cmd, 0);
}


/*
   ** tuiSetWinFocusTo
   **        Set the logical focus to winInfo
 */
void
tuiSetWinFocusTo (TuiWinInfoPtr winInfo)
{
  if (m_winPtrNotNull (winInfo))
    {
      TuiWinInfoPtr winWithFocus = tuiWinWithFocus ();

      if (m_winPtrNotNull (winWithFocus) &&
	  winWithFocus->generic.type != CMD_WIN)
	unhighlightWin (winWithFocus);
      tuiSetWinWithFocus (winInfo);
      if (winInfo->generic.type != CMD_WIN)
	highlightWin (winInfo);
    }

  return;
}				/* tuiSetWinFocusTo */


/*
   ** tuiScrollForward().
 */
void
tuiScrollForward (TuiWinInfoPtr winToScroll, int numToScroll)
{
  if (winToScroll != cmdWin)
    {
      int _numToScroll = numToScroll;

      if (numToScroll == 0)
	_numToScroll = winToScroll->generic.height - 3;
      /*
         ** If we are scrolling the source or disassembly window, do a
         ** "psuedo" scroll since not all of the source is in memory,
         ** only what is in the viewport.  If winToScroll is the
         ** command window do nothing since the term should handle it.
       */
      if (winToScroll == srcWin)
	tuiVerticalSourceScroll (FORWARD_SCROLL, _numToScroll);
      else if (winToScroll == disassemWin)
	tuiVerticalDisassemScroll (FORWARD_SCROLL, _numToScroll);
      else if (winToScroll == dataWin)
	tuiVerticalDataScroll (FORWARD_SCROLL, _numToScroll);
    }

  return;
}				/* tuiScrollForward */


/*
   ** tuiScrollBackward().
 */
void
tuiScrollBackward (TuiWinInfoPtr winToScroll, int numToScroll)
{
  if (winToScroll != cmdWin)
    {
      int _numToScroll = numToScroll;

      if (numToScroll == 0)
	_numToScroll = winToScroll->generic.height - 3;
      /*
         ** If we are scrolling the source or disassembly window, do a
         ** "psuedo" scroll since not all of the source is in memory,
         ** only what is in the viewport.  If winToScroll is the
         ** command window do nothing since the term should handle it.
       */
      if (winToScroll == srcWin)
	tuiVerticalSourceScroll (BACKWARD_SCROLL, _numToScroll);
      else if (winToScroll == disassemWin)
	tuiVerticalDisassemScroll (BACKWARD_SCROLL, _numToScroll);
      else if (winToScroll == dataWin)
	tuiVerticalDataScroll (BACKWARD_SCROLL, _numToScroll);
    }
  return;
}				/* tuiScrollBackward */


/*
   ** tuiScrollLeft().
 */
void
tuiScrollLeft (TuiWinInfoPtr winToScroll, int numToScroll)
{
  if (winToScroll != cmdWin)
    {
      int _numToScroll = numToScroll;

      if (_numToScroll == 0)
	_numToScroll = 1;
      /*
         ** If we are scrolling the source or disassembly window, do a
         ** "psuedo" scroll since not all of the source is in memory,
         ** only what is in the viewport. If winToScroll is the
         ** command window do nothing since the term should handle it.
       */
      if (winToScroll == srcWin || winToScroll == disassemWin)
	tuiHorizontalSourceScroll (winToScroll, LEFT_SCROLL, _numToScroll);
    }
  return;
}				/* tuiScrollLeft */


/*
   ** tuiScrollRight().
 */
void
tuiScrollRight (TuiWinInfoPtr winToScroll, int numToScroll)
{
  if (winToScroll != cmdWin)
    {
      int _numToScroll = numToScroll;

      if (_numToScroll == 0)
	_numToScroll = 1;
      /*
         ** If we are scrolling the source or disassembly window, do a
         ** "psuedo" scroll since not all of the source is in memory,
         ** only what is in the viewport. If winToScroll is the
         ** command window do nothing since the term should handle it.
       */
      if (winToScroll == srcWin || winToScroll == disassemWin)
	tuiHorizontalSourceScroll (winToScroll, RIGHT_SCROLL, _numToScroll);
    }
  return;
}				/* tuiScrollRight */


/*
   ** tui_scroll().
   **    Scroll a window.  Arguments are passed through a va_list.
 */
void
tui_scroll (TuiScrollDirection direction,
	    TuiWinInfoPtr winToScroll,
	    int numToScroll)
{
  switch (direction)
    {
    case FORWARD_SCROLL:
      tuiScrollForward (winToScroll, numToScroll);
      break;
    case BACKWARD_SCROLL:
      tuiScrollBackward (winToScroll, numToScroll);
      break;
    case LEFT_SCROLL:
      tuiScrollLeft (winToScroll, numToScroll);
      break;
    case RIGHT_SCROLL:
      tuiScrollRight (winToScroll, numToScroll);
      break;
    default:
      break;
    }
}


/*
   ** tuiRefreshAll().
 */
void
tuiRefreshAll (void)
{
  TuiWinType type;

  clearok (curscr, TRUE);
  refreshAll (winList);
  for (type = SRC_WIN; type < MAX_MAJOR_WINDOWS; type++)
    {
      if (winList[type] && winList[type]->generic.isVisible)
	{
	  switch (type)
	    {
	    case SRC_WIN:
	    case DISASSEM_WIN:
	      tuiShowSourceContent (winList[type]);
	      checkAndDisplayHighlightIfNeeded (winList[type]);
	      tuiEraseExecInfoContent (winList[type]);
	      tuiUpdateExecInfo (winList[type]);
	      break;
	    case DATA_WIN:
	      tuiRefreshDataWin ();
	      break;
	    default:
	      break;
	    }
	}
    }
  tuiShowLocatorContent ();
}


/*
   ** tuiResizeAll().
   **      Resize all the windows based on the the terminal size.  This
   **      function gets called from within the readline sinwinch handler.
 */
void
tuiResizeAll (void)
{
  int heightDiff, widthDiff;
  int screenheight, screenwidth;

  rl_get_screen_size (&screenheight, &screenwidth);
  widthDiff = screenwidth - termWidth ();
  heightDiff = screenheight - termHeight ();
  if (heightDiff || widthDiff)
    {
      TuiLayoutType curLayout = currentLayout ();
      TuiWinInfoPtr winWithFocus = tuiWinWithFocus ();
      TuiWinInfoPtr firstWin, secondWin;
      TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
      TuiWinType winType;
      int newHeight, splitDiff, cmdSplitDiff, numWinsDisplayed = 2;

      /* turn keypad off while we resize */
      if (winWithFocus != cmdWin)
	keypad (cmdWin->generic.handle, FALSE);
      tui_update_gdb_sizes ();
      setTermHeightTo (screenheight);
      setTermWidthTo (screenwidth);
      if (curLayout == SRC_DISASSEM_COMMAND ||
	curLayout == SRC_DATA_COMMAND || curLayout == DISASSEM_DATA_COMMAND)
	numWinsDisplayed++;
      splitDiff = heightDiff / numWinsDisplayed;
      cmdSplitDiff = splitDiff;
      if (heightDiff % numWinsDisplayed)
	{
	  if (heightDiff < 0)
	    cmdSplitDiff--;
	  else
	    cmdSplitDiff++;
	}
      /* now adjust each window */
      clear ();
      refresh ();
      switch (curLayout)
	{
	case SRC_COMMAND:
	case DISASSEM_COMMAND:
	  firstWin = (TuiWinInfoPtr) (sourceWindows ())->list[0];
	  firstWin->generic.width += widthDiff;
	  locator->width += widthDiff;
	  /* check for invalid heights */
	  if (heightDiff == 0)
	    newHeight = firstWin->generic.height;
	  else if ((firstWin->generic.height + splitDiff) >=
		   (screenheight - MIN_CMD_WIN_HEIGHT - 1))
	    newHeight = screenheight - MIN_CMD_WIN_HEIGHT - 1;
	  else if ((firstWin->generic.height + splitDiff) <= 0)
	    newHeight = MIN_WIN_HEIGHT;
	  else
	    newHeight = firstWin->generic.height + splitDiff;

	  _makeInvisibleAndSetNewHeight (firstWin, newHeight);
	  cmdWin->generic.origin.y = locator->origin.y + 1;
	  cmdWin->generic.width += widthDiff;
	  newHeight = screenheight - cmdWin->generic.origin.y;
	  _makeInvisibleAndSetNewHeight (cmdWin, newHeight);
	  _makeVisibleWithNewHeight (firstWin);
	  _makeVisibleWithNewHeight (cmdWin);
	  if (firstWin->generic.contentSize <= 0)
	    tuiEraseSourceContent (firstWin, EMPTY_SOURCE_PROMPT);
	  break;
	default:
	  if (curLayout == SRC_DISASSEM_COMMAND)
	    {
	      firstWin = srcWin;
	      firstWin->generic.width += widthDiff;
	      secondWin = disassemWin;
	      secondWin->generic.width += widthDiff;
	    }
	  else
	    {
	      firstWin = dataWin;
	      firstWin->generic.width += widthDiff;
	      secondWin = (TuiWinInfoPtr) (sourceWindows ())->list[0];
	      secondWin->generic.width += widthDiff;
	    }
	  /* Change the first window's height/width */
	  /* check for invalid heights */
	  if (heightDiff == 0)
	    newHeight = firstWin->generic.height;
	  else if ((firstWin->generic.height +
		    secondWin->generic.height + (splitDiff * 2)) >=
		   (screenheight - MIN_CMD_WIN_HEIGHT - 1))
	    newHeight = (screenheight - MIN_CMD_WIN_HEIGHT - 1) / 2;
	  else if ((firstWin->generic.height + splitDiff) <= 0)
	    newHeight = MIN_WIN_HEIGHT;
	  else
	    newHeight = firstWin->generic.height + splitDiff;
	  _makeInvisibleAndSetNewHeight (firstWin, newHeight);

	  if (firstWin == dataWin && widthDiff != 0)
	    firstWin->detail.dataDisplayInfo.regsColumnCount =
	      tuiCalculateRegsColumnCount (
			  firstWin->detail.dataDisplayInfo.regsDisplayType);
	  locator->width += widthDiff;

	  /* Change the second window's height/width */
	  /* check for invalid heights */
	  if (heightDiff == 0)
	    newHeight = secondWin->generic.height;
	  else if ((firstWin->generic.height +
		    secondWin->generic.height + (splitDiff * 2)) >=
		   (screenheight - MIN_CMD_WIN_HEIGHT - 1))
	    {
	      newHeight = screenheight - MIN_CMD_WIN_HEIGHT - 1;
	      if (newHeight % 2)
		newHeight = (newHeight / 2) + 1;
	      else
		newHeight /= 2;
	    }
	  else if ((secondWin->generic.height + splitDiff) <= 0)
	    newHeight = MIN_WIN_HEIGHT;
	  else
	    newHeight = secondWin->generic.height + splitDiff;
	  secondWin->generic.origin.y = firstWin->generic.height - 1;
	  _makeInvisibleAndSetNewHeight (secondWin, newHeight);

	  /* Change the command window's height/width */
	  cmdWin->generic.origin.y = locator->origin.y + 1;
	  _makeInvisibleAndSetNewHeight (
			     cmdWin, cmdWin->generic.height + cmdSplitDiff);
	  _makeVisibleWithNewHeight (firstWin);
	  _makeVisibleWithNewHeight (secondWin);
	  _makeVisibleWithNewHeight (cmdWin);
	  if (firstWin->generic.contentSize <= 0)
	    tuiEraseSourceContent (firstWin, EMPTY_SOURCE_PROMPT);
	  if (secondWin->generic.contentSize <= 0)
	    tuiEraseSourceContent (secondWin, EMPTY_SOURCE_PROMPT);
	  break;
	}
      /*
         ** Now remove all invisible windows, and their content so that they get
         ** created again when called for with the new size
       */
      for (winType = SRC_WIN; (winType < MAX_MAJOR_WINDOWS); winType++)
	{
	  if (winType != CMD_WIN && m_winPtrNotNull (winList[winType]) &&
	      !winList[winType]->generic.isVisible)
	    {
	      freeWindow (winList[winType]);
	      winList[winType] = (TuiWinInfoPtr) NULL;
	    }
	}
      tuiSetWinResizedTo (TRUE);
      /* turn keypad back on, unless focus is in the command window */
      if (winWithFocus != cmdWin)
	keypad (cmdWin->generic.handle, TRUE);
    }
  return;
}				/* tuiResizeAll */


/*
   ** tuiSigwinchHandler()
   **    SIGWINCH signal handler for the tui.  This signal handler is
   **    always called, even when the readline package clears signals
   **    because it is set as the old_sigwinch() (TUI only)
 */
void
tuiSigwinchHandler (int signal)
{
  /*
     ** Say that a resize was done so that the readline can do it
     ** later when appropriate.
   */
  tuiSetWinResizedTo (TRUE);

  return;
}				/* tuiSigwinchHandler */



/*************************
** STATIC LOCAL FUNCTIONS
**************************/


/*
   ** _tuiScrollForward_command().
 */
static void
_tuiScrollForward_command (char *arg, int fromTTY)
{
  int numToScroll = 1;
  TuiWinInfoPtr winToScroll;

  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  if (arg == (char *) NULL)
    _parseScrollingArgs (arg, &winToScroll, (int *) NULL);
  else
    _parseScrollingArgs (arg, &winToScroll, &numToScroll);
  tui_scroll (FORWARD_SCROLL, winToScroll, numToScroll);
}


/*
   ** _tuiScrollBackward_command().
 */
static void
_tuiScrollBackward_command (char *arg, int fromTTY)
{
  int numToScroll = 1;
  TuiWinInfoPtr winToScroll;

  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  if (arg == (char *) NULL)
    _parseScrollingArgs (arg, &winToScroll, (int *) NULL);
  else
    _parseScrollingArgs (arg, &winToScroll, &numToScroll);
  tui_scroll (BACKWARD_SCROLL, winToScroll, numToScroll);
}


/*
   ** _tuiScrollLeft_command().
 */
static void
_tuiScrollLeft_command (char *arg, int fromTTY)
{
  int numToScroll;
  TuiWinInfoPtr winToScroll;

  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  _parseScrollingArgs (arg, &winToScroll, &numToScroll);
  tui_scroll (LEFT_SCROLL, winToScroll, numToScroll);
}


/*
   ** _tuiScrollRight_command().
 */
static void
_tuiScrollRight_command (char *arg, int fromTTY)
{
  int numToScroll;
  TuiWinInfoPtr winToScroll;

  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  _parseScrollingArgs (arg, &winToScroll, &numToScroll);
  tui_scroll (RIGHT_SCROLL, winToScroll, numToScroll);
}


/*
   ** _tuiSetFocus().
   **     Set focus to the window named by 'arg'
 */
static void
_tuiSetFocus (char *arg, int fromTTY)
{
  if (arg != (char *) NULL)
    {
      char *bufPtr = (char *) xstrdup (arg);
      int i;
      TuiWinInfoPtr winInfo = (TuiWinInfoPtr) NULL;

      for (i = 0; (i < strlen (bufPtr)); i++)
	bufPtr[i] = toupper (arg[i]);

      if (subset_compare (bufPtr, "NEXT"))
	winInfo = tuiNextWin (tuiWinWithFocus ());
      else if (subset_compare (bufPtr, "PREV"))
	winInfo = tuiPrevWin (tuiWinWithFocus ());
      else
	winInfo = partialWinByName (bufPtr);

      if (winInfo == (TuiWinInfoPtr) NULL || !winInfo->generic.isVisible)
	warning ("Invalid window specified. \n\
The window name specified must be valid and visible.\n");
      else
	{
	  tuiSetWinFocusTo (winInfo);
	  keypad (cmdWin->generic.handle, (winInfo != cmdWin));
	}

      if (dataWin && dataWin->generic.isVisible)
	tuiRefreshDataWin ();
      tuiFree (bufPtr);
      printf_filtered ("Focus set to %s window.\n",
		       winName ((TuiGenWinInfoPtr) tuiWinWithFocus ()));
    }
  else
    warning ("Incorrect Number of Arguments.\n%s", FOCUS_USAGE);

  return;
}				/* _tuiSetFocus */

/*
   ** _tuiSetFocus_command()
 */
static void
_tuiSetFocus_command (char *arg, int fromTTY)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  _tuiSetFocus (arg, fromTTY);
}


/*
   ** _tuiAllWindowsInfo().
 */
static void
_tuiAllWindowsInfo (char *arg, int fromTTY)
{
  TuiWinType type;
  TuiWinInfoPtr winWithFocus = tuiWinWithFocus ();

  for (type = SRC_WIN; (type < MAX_MAJOR_WINDOWS); type++)
    if (winList[type] && winList[type]->generic.isVisible)
      {
	if (winWithFocus == winList[type])
	  printf_filtered ("        %s\t(%d lines)  <has focus>\n",
			   winName (&winList[type]->generic),
			   winList[type]->generic.height);
	else
	  printf_filtered ("        %s\t(%d lines)\n",
			   winName (&winList[type]->generic),
			   winList[type]->generic.height);
      }

  return;
}				/* _tuiAllWindowsInfo */


/*
   ** _tuiRefreshAll_command().
 */
static void
_tuiRefreshAll_command (char *arg, int fromTTY)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();

  tuiRefreshAll ();
}


/*
   ** _tuiSetWinTabWidth_command().
   **        Set the height of the specified window.
 */
static void
_tuiSetTabWidth_command (char *arg, int fromTTY)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  if (arg != (char *) NULL)
    {
      int ts;

      ts = atoi (arg);
      if (ts > 0)
	tuiSetDefaultTabLen (ts);
      else
	warning ("Tab widths greater than 0 must be specified.\n");
    }

  return;
}				/* _tuiSetTabWidth_command */


/*
   ** _tuiSetWinHeight().
   **        Set the height of the specified window.
 */
static void
_tuiSetWinHeight (char *arg, int fromTTY)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  if (arg != (char *) NULL)
    {
      char *buf = xstrdup (arg);
      char *bufPtr = buf;
      char *wname = (char *) NULL;
      int newHeight, i;
      TuiWinInfoPtr winInfo;

      wname = bufPtr;
      bufPtr = strchr (bufPtr, ' ');
      if (bufPtr != (char *) NULL)
	{
	  *bufPtr = (char) 0;

	  /*
	     ** Validate the window name
	   */
	  for (i = 0; i < strlen (wname); i++)
	    wname[i] = toupper (wname[i]);
	  winInfo = partialWinByName (wname);

	  if (winInfo == (TuiWinInfoPtr) NULL || !winInfo->generic.isVisible)
	    warning ("Invalid window specified. \n\
The window name specified must be valid and visible.\n");
	  else
	    {
	      /* Process the size */
	      while (*(++bufPtr) == ' ')
		;

	      if (*bufPtr != (char) 0)
		{
		  int negate = FALSE;
		  int fixedSize = TRUE;
		  int inputNo;;

		  if (*bufPtr == '+' || *bufPtr == '-')
		    {
		      if (*bufPtr == '-')
			negate = TRUE;
		      fixedSize = FALSE;
		      bufPtr++;
		    }
		  inputNo = atoi (bufPtr);
		  if (inputNo > 0)
		    {
		      if (negate)
			inputNo *= (-1);
		      if (fixedSize)
			newHeight = inputNo;
		      else
			newHeight = winInfo->generic.height + inputNo;
		      /*
		         ** Now change the window's height, and adjust all
		         ** other windows around it
		       */
		      if (_tuiAdjustWinHeights (winInfo,
						newHeight) == TUI_FAILURE)
			warning ("Invalid window height specified.\n%s",
				 WIN_HEIGHT_USAGE);
		      else
                        tui_update_gdb_sizes ();
		    }
		  else
		    warning ("Invalid window height specified.\n%s",
			     WIN_HEIGHT_USAGE);
		}
	    }
	}
      else
	printf_filtered (WIN_HEIGHT_USAGE);

      if (buf != (char *) NULL)
	tuiFree (buf);
    }
  else
    printf_filtered (WIN_HEIGHT_USAGE);

  return;
}				/* _tuiSetWinHeight */

/*
   ** _tuiSetWinHeight_command().
   **        Set the height of the specified window, with va_list.
 */
static void
_tuiSetWinHeight_command (char *arg, int fromTTY)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  _tuiSetWinHeight (arg, fromTTY);
}


/*
   ** _tuiXDBsetWinHeight().
   **        XDB Compatibility command for setting the window height.  This will
   **        increase or decrease the command window by the specified amount.
 */
static void
_tuiXDBsetWinHeight (char *arg, int fromTTY)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  if (arg != (char *) NULL)
    {
      int inputNo = atoi (arg);

      if (inputNo > 0)
	{			/* Add 1 for the locator */
	  int newHeight = termHeight () - (inputNo + 1);

	  if (!_newHeightOk (winList[CMD_WIN], newHeight) ||
	      _tuiAdjustWinHeights (winList[CMD_WIN],
				    newHeight) == TUI_FAILURE)
	    warning ("Invalid window height specified.\n%s",
		     XDBWIN_HEIGHT_USAGE);
	}
      else
	warning ("Invalid window height specified.\n%s",
		 XDBWIN_HEIGHT_USAGE);
    }
  else
    warning ("Invalid window height specified.\n%s", XDBWIN_HEIGHT_USAGE);

  return;
}				/* _tuiXDBsetWinHeight */

/*
   ** _tuiSetWinHeight_command().
   **        Set the height of the specified window, with va_list.
 */
static void
_tuiXDBsetWinHeight_command (char *arg, int fromTTY)
{
  _tuiXDBsetWinHeight (arg, fromTTY);
}


/*
   ** _tuiAdjustWinHeights().
   **        Function to adjust all window heights around the primary
 */
static TuiStatus
_tuiAdjustWinHeights (TuiWinInfoPtr primaryWinInfo, int newHeight)
{
  TuiStatus status = TUI_FAILURE;

  if (_newHeightOk (primaryWinInfo, newHeight))
    {
      status = TUI_SUCCESS;
      if (newHeight != primaryWinInfo->generic.height)
	{
	  int diff;
	  TuiWinInfoPtr winInfo;
	  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
	  TuiLayoutType curLayout = currentLayout ();

	  diff = (newHeight - primaryWinInfo->generic.height) * (-1);
	  if (curLayout == SRC_COMMAND || curLayout == DISASSEM_COMMAND)
	    {
	      TuiWinInfoPtr srcWinInfo;

	      _makeInvisibleAndSetNewHeight (primaryWinInfo, newHeight);
	      if (primaryWinInfo->generic.type == CMD_WIN)
		{
		  winInfo = (TuiWinInfoPtr) (sourceWindows ())->list[0];
		  srcWinInfo = winInfo;
		}
	      else
		{
		  winInfo = winList[CMD_WIN];
		  srcWinInfo = primaryWinInfo;
		}
	      _makeInvisibleAndSetNewHeight (winInfo,
					     winInfo->generic.height + diff);
	      cmdWin->generic.origin.y = locator->origin.y + 1;
	      _makeVisibleWithNewHeight (winInfo);
	      _makeVisibleWithNewHeight (primaryWinInfo);
	      if (srcWinInfo->generic.contentSize <= 0)
		tuiEraseSourceContent (srcWinInfo, EMPTY_SOURCE_PROMPT);
	    }
	  else
	    {
	      TuiWinInfoPtr firstWin, secondWin;

	      if (curLayout == SRC_DISASSEM_COMMAND)
		{
		  firstWin = srcWin;
		  secondWin = disassemWin;
		}
	      else
		{
		  firstWin = dataWin;
		  secondWin = (TuiWinInfoPtr) (sourceWindows ())->list[0];
		}
	      if (primaryWinInfo == cmdWin)
		{		/*
				   ** Split the change in height accross the 1st & 2nd windows
				   ** adjusting them as well.
				 */
		  int firstSplitDiff = diff / 2;	/* subtract the locator */
		  int secondSplitDiff = firstSplitDiff;

		  if (diff % 2)
		    {
		      if (firstWin->generic.height >
			  secondWin->generic.height)
			if (diff < 0)
			  firstSplitDiff--;
			else
			  firstSplitDiff++;
		      else
			{
			  if (diff < 0)
			    secondSplitDiff--;
			  else
			    secondSplitDiff++;
			}
		    }
		  /* make sure that the minimum hieghts are honored */
		  while ((firstWin->generic.height + firstSplitDiff) < 3)
		    {
		      firstSplitDiff++;
		      secondSplitDiff--;
		    }
		  while ((secondWin->generic.height + secondSplitDiff) < 3)
		    {
		      secondSplitDiff++;
		      firstSplitDiff--;
		    }
		  _makeInvisibleAndSetNewHeight (
						  firstWin,
				 firstWin->generic.height + firstSplitDiff);
		  secondWin->generic.origin.y = firstWin->generic.height - 1;
		  _makeInvisibleAndSetNewHeight (
		    secondWin, secondWin->generic.height + secondSplitDiff);
		  cmdWin->generic.origin.y = locator->origin.y + 1;
		  _makeInvisibleAndSetNewHeight (cmdWin, newHeight);
		}
	      else
		{
		  if ((cmdWin->generic.height + diff) < 1)
		    {		/*
				   ** If there is no way to increase the command window
				   ** take real estate from the 1st or 2nd window.
				 */
		      if ((cmdWin->generic.height + diff) < 1)
			{
			  int i;
			  for (i = cmdWin->generic.height + diff;
			       (i < 1); i++)
			    if (primaryWinInfo == firstWin)
			      secondWin->generic.height--;
			    else
			      firstWin->generic.height--;
			}
		    }
		  if (primaryWinInfo == firstWin)
		    _makeInvisibleAndSetNewHeight (firstWin, newHeight);
		  else
		    _makeInvisibleAndSetNewHeight (
						    firstWin,
						  firstWin->generic.height);
		  secondWin->generic.origin.y = firstWin->generic.height - 1;
		  if (primaryWinInfo == secondWin)
		    _makeInvisibleAndSetNewHeight (secondWin, newHeight);
		  else
		    _makeInvisibleAndSetNewHeight (
				      secondWin, secondWin->generic.height);
		  cmdWin->generic.origin.y = locator->origin.y + 1;
		  if ((cmdWin->generic.height + diff) < 1)
		    _makeInvisibleAndSetNewHeight (cmdWin, 1);
		  else
		    _makeInvisibleAndSetNewHeight (
				     cmdWin, cmdWin->generic.height + diff);
		}
	      _makeVisibleWithNewHeight (cmdWin);
	      _makeVisibleWithNewHeight (secondWin);
	      _makeVisibleWithNewHeight (firstWin);
	      if (firstWin->generic.contentSize <= 0)
		tuiEraseSourceContent (firstWin, EMPTY_SOURCE_PROMPT);
	      if (secondWin->generic.contentSize <= 0)
		tuiEraseSourceContent (secondWin, EMPTY_SOURCE_PROMPT);
	    }
	}
    }

  return status;
}				/* _tuiAdjustWinHeights */


/*
   ** _makeInvisibleAndSetNewHeight().
   **        Function make the target window (and auxillary windows associated
   **        with the targer) invisible, and set the new height and location.
 */
static void
_makeInvisibleAndSetNewHeight (TuiWinInfoPtr winInfo, int height)
{
  int i;
  TuiGenWinInfoPtr genWinInfo;


  m_beInvisible (&winInfo->generic);
  winInfo->generic.height = height;
  if (height > 1)
    winInfo->generic.viewportHeight = height - 1;
  else
    winInfo->generic.viewportHeight = height;
  if (winInfo != cmdWin)
    winInfo->generic.viewportHeight--;

  /* Now deal with the auxillary windows associated with winInfo */
  switch (winInfo->generic.type)
    {
    case SRC_WIN:
    case DISASSEM_WIN:
      genWinInfo = winInfo->detail.sourceInfo.executionInfo;
      m_beInvisible (genWinInfo);
      genWinInfo->height = height;
      genWinInfo->origin.y = winInfo->generic.origin.y;
      if (height > 1)
	genWinInfo->viewportHeight = height - 1;
      else
	genWinInfo->viewportHeight = height;
      if (winInfo != cmdWin)
	genWinInfo->viewportHeight--;

      if (m_hasLocator (winInfo))
	{
	  genWinInfo = locatorWinInfoPtr ();
	  m_beInvisible (genWinInfo);
	  genWinInfo->origin.y = winInfo->generic.origin.y + height;
	}
      break;
    case DATA_WIN:
      /* delete all data item windows */
      for (i = 0; i < winInfo->generic.contentSize; i++)
	{
	  genWinInfo = (TuiGenWinInfoPtr) & ((TuiWinElementPtr)
		      winInfo->generic.content[i])->whichElement.dataWindow;
	  tuiDelwin (genWinInfo->handle);
	  genWinInfo->handle = (WINDOW *) NULL;
	}
      break;
    default:
      break;
    }
}


/*
   ** _makeVisibleWithNewHeight().
   **        Function to make the windows with new heights visible.
   **        This means re-creating the windows' content since the window
   **        had to be destroyed to be made invisible.
 */
static void
_makeVisibleWithNewHeight (TuiWinInfoPtr winInfo)
{
  struct symtab *s;

  m_beVisible (&winInfo->generic);
  checkAndDisplayHighlightIfNeeded (winInfo);
  switch (winInfo->generic.type)
    {
    case SRC_WIN:
    case DISASSEM_WIN:
      freeWinContent (winInfo->detail.sourceInfo.executionInfo);
      m_beVisible (winInfo->detail.sourceInfo.executionInfo);
      if (winInfo->generic.content != (OpaquePtr) NULL)
	{
	  TuiLineOrAddress lineOrAddr;
	  struct symtab_and_line cursal
	    = get_current_source_symtab_and_line ();

	  if (winInfo->generic.type == SRC_WIN)
	    lineOrAddr.lineNo =
	      winInfo->detail.sourceInfo.startLineOrAddr.lineNo;
	  else
	    lineOrAddr.addr =
	      winInfo->detail.sourceInfo.startLineOrAddr.addr;
	  freeWinContent (&winInfo->generic);
	  tuiUpdateSourceWindow (winInfo,
				 cursal.symtab, lineOrAddr, TRUE);
	}
      else if (deprecated_selected_frame != (struct frame_info *) NULL)
	{
	  TuiLineOrAddress line;
	  struct symtab_and_line cursal = get_current_source_symtab_and_line ();


	  s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
	  if (winInfo->generic.type == SRC_WIN)
	    line.lineNo = cursal.line;
	  else
	    {
	      find_line_pc (s, cursal.line, &line.addr);
	    }
	  tuiUpdateSourceWindow (winInfo, s, line, TRUE);
	}
      if (m_hasLocator (winInfo))
	{
	  m_beVisible (locatorWinInfoPtr ());
	  tuiShowLocatorContent ();
	}
      break;
    case DATA_WIN:
      tuiDisplayAllData ();
      break;
    case CMD_WIN:
      winInfo->detail.commandInfo.curLine = 0;
      winInfo->detail.commandInfo.curch = 0;
      wmove (winInfo->generic.handle,
	     winInfo->detail.commandInfo.curLine,
	     winInfo->detail.commandInfo.curch);
      break;
    default:
      break;
    }

  return;
}				/* _makeVisibleWithNewHeight */


static int
_newHeightOk (TuiWinInfoPtr primaryWinInfo, int newHeight)
{
  int ok = (newHeight < termHeight ());

  if (ok)
    {
      int diff;
      TuiLayoutType curLayout = currentLayout ();

      diff = (newHeight - primaryWinInfo->generic.height) * (-1);
      if (curLayout == SRC_COMMAND || curLayout == DISASSEM_COMMAND)
	{
	  ok = ((primaryWinInfo->generic.type == CMD_WIN &&
		 newHeight <= (termHeight () - 4) &&
		 newHeight >= MIN_CMD_WIN_HEIGHT) ||
		(primaryWinInfo->generic.type != CMD_WIN &&
		 newHeight <= (termHeight () - 2) &&
		 newHeight >= MIN_WIN_HEIGHT));
	  if (ok)
	    {			/* check the total height */
	      TuiWinInfoPtr winInfo;

	      if (primaryWinInfo == cmdWin)
		winInfo = (TuiWinInfoPtr) (sourceWindows ())->list[0];
	      else
		winInfo = cmdWin;
	      ok = ((newHeight +
		     (winInfo->generic.height + diff)) <= termHeight ());
	    }
	}
      else
	{
	  int curTotalHeight, totalHeight, minHeight = 0;
	  TuiWinInfoPtr firstWin, secondWin;

	  if (curLayout == SRC_DISASSEM_COMMAND)
	    {
	      firstWin = srcWin;
	      secondWin = disassemWin;
	    }
	  else
	    {
	      firstWin = dataWin;
	      secondWin = (TuiWinInfoPtr) (sourceWindows ())->list[0];
	    }
	  /*
	     ** We could simply add all the heights to obtain the same result
	     ** but below is more explicit since we subtract 1 for the
	     ** line that the first and second windows share, and add one
	     ** for the locator.
	   */
	  totalHeight = curTotalHeight =
	    (firstWin->generic.height + secondWin->generic.height - 1)
	    + cmdWin->generic.height + 1 /*locator */ ;
	  if (primaryWinInfo == cmdWin)
	    {
	      /* locator included since first & second win share a line */
	      ok = ((firstWin->generic.height +
		     secondWin->generic.height + diff) >=
		    (MIN_WIN_HEIGHT * 2) &&
		    newHeight >= MIN_CMD_WIN_HEIGHT);
	      if (ok)
		{
		  totalHeight = newHeight + (firstWin->generic.height +
					  secondWin->generic.height + diff);
		  minHeight = MIN_CMD_WIN_HEIGHT;
		}
	    }
	  else
	    {
	      minHeight = MIN_WIN_HEIGHT;
	      /*
	         ** First see if we can increase/decrease the command
	         ** window.  And make sure that the command window is
	         ** at least 1 line
	       */
	      ok = ((cmdWin->generic.height + diff) > 0);
	      if (!ok)
		{		/*
				   ** Looks like we have to increase/decrease one of
				   ** the other windows
				 */
		  if (primaryWinInfo == firstWin)
		    ok = (secondWin->generic.height + diff) >= minHeight;
		  else
		    ok = (firstWin->generic.height + diff) >= minHeight;
		}
	      if (ok)
		{
		  if (primaryWinInfo == firstWin)
		    totalHeight = newHeight +
		      secondWin->generic.height +
		      cmdWin->generic.height + diff;
		  else
		    totalHeight = newHeight +
		      firstWin->generic.height +
		      cmdWin->generic.height + diff;
		}
	    }
	  /*
	     ** Now make sure that the proposed total height doesn't exceed
	     ** the old total height.
	   */
	  if (ok)
	    ok = (newHeight >= minHeight && totalHeight <= curTotalHeight);
	}
    }

  return ok;
}				/* _newHeightOk */


/*
   ** _parseScrollingArgs().
 */
static void
_parseScrollingArgs (char *arg, TuiWinInfoPtr * winToScroll, int *numToScroll)
{
  if (numToScroll)
    *numToScroll = 0;
  *winToScroll = tuiWinWithFocus ();

  /*
     ** First set up the default window to scroll, in case there is no
     ** window name arg
   */
  if (arg != (char *) NULL)
    {
      char *buf, *bufPtr;

      /* process the number of lines to scroll */
      buf = bufPtr = xstrdup (arg);
      if (isdigit (*bufPtr))
	{
	  char *numStr;

	  numStr = bufPtr;
	  bufPtr = strchr (bufPtr, ' ');
	  if (bufPtr != (char *) NULL)
	    {
	      *bufPtr = (char) 0;
	      if (numToScroll)
		*numToScroll = atoi (numStr);
	      bufPtr++;
	    }
	  else if (numToScroll)
	    *numToScroll = atoi (numStr);
	}

      /* process the window name if one is specified */
      if (bufPtr != (char *) NULL)
	{
	  char *wname;
	  int i;

	  if (*bufPtr == ' ')
	    while (*(++bufPtr) == ' ')
	      ;

	  if (*bufPtr != (char) 0)
	    wname = bufPtr;
	  else
	    wname = "?";
	  
	  /* Validate the window name */
	  for (i = 0; i < strlen (wname); i++)
	    wname[i] = toupper (wname[i]);
	  *winToScroll = partialWinByName (wname);

	  if (*winToScroll == (TuiWinInfoPtr) NULL ||
	      !(*winToScroll)->generic.isVisible)
	    warning ("Invalid window specified. \n\
The window name specified must be valid and visible.\n");
	  else if (*winToScroll == cmdWin)
	    *winToScroll = (TuiWinInfoPtr) (sourceWindows ())->list[0];
	}
      tuiFree (buf);
    }

  return;
}				/* _parseScrollingArgs */
@


1.29
log
@	* tui-hooks.c: Update include order.
	* tui.c: Likewise.
	* tuiCommand.c: Likewise.
	* tuiData.c: Likewise.
	* tuiDataWin.c: Likewise.
	* tuiDisassem.c: Likewise.
	* tuiGeneralWin.c: Likewise.
	* tuiIO.c: Likewise.
	* tuiLayout.c: Likewise.
	* tuiRegs.c: Likewise.
	* tuiSource.c: Likewise.
	* tuiSourceWin.c: Likewise.
	* tuiStack.c: Likewise.
	* tuiWin.c: Likewise.
@
text
@@


1.29.6.1
log
@merge mainline changes to branch
@
text
@@


1.28
log
@	* Makefile.in (tuiDisassem.o): Update dependencies.

tui:
	* tuiSource.c (tuiVerticalSourceScroll): Use get_frame_pc.
	* tuiSourceWin.c (tuiHorizontalSourceScroll): Likewise.
	* tuiStack.c (tui_get_function_from_frame): Likewise.
	(tuiShowFrameInfo): Likewise.
	* tuiWin.c (_makeVisibleWithNewHeight): Likewise.
	* tui-hooks.c (tui_selected_frame_level_changed_hook): Likewise.
	* tuiDisassem.c (tuiVerticalDisassemScroll): Likewise.
	Include "disasm.h".
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation,
a29 20
/* FIXME: cagney/2002-02-28: The GDB coding standard indicates that
   "defs.h" should be included first.  Unfortunatly some systems
   (currently Debian GNU/Linux) include the <stdbool.h> via <curses.h>
   and they clash with "bfd.h"'s definiton of true/false.  The correct
   fix is to remove true/false from "bfd.h", however, until that
   happens, hack around it by including "config.h" and <curses.h>
   first.  */

#include "config.h"
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

#include <string.h>
#include <ctype.h>
#include <readline/readline.h>
d48 12
@


1.27
log
@Import of readline 4.3.
Non-readline modified files:

src/gdb/ChangeLog src/gdb/defs.h src/gdb/cli/cli-cmds.c
src/gdb/cli/cli-setshow.c src/gdb/tui/ChangeLog
src/gdb/tui/tuiWin.c

In readline directory:

        * compat.c, mbutil.c, misc.c, rlmbutil.h, rltypedefs.h,
        text.c, doc/history.0, doc/history.3, support/wcwidth.c,
        examples/readlinebuf.h, examples/rlcat.c: New files.

        * CHANGELOG, CHANGES, INSTALL,  MANIFEST, Makefile.in, README,
        aclocal.m4, ansi_stdlib.h, bind.c, callback.c, chardefs.h,
        complete.c, config.h.in, configure, configure.in, display.c,
        emacs_keymap.c, funmap.c, histexpand.c, histfile.c, histlib.h,
        history.c, history.h, histsearch.c, input.c, isearch.c,
        keymaps.c, keymaps.h, kill.c, macro.c, nls.c, parens.c,
        posixdir.h, readline.c, readline.h, rlconf.h, rldefs.h,
        rlprivate.h, rlshell.h, rlstdc.h, rltty.c, savestring.c,
        search.c, shell.c, signals.c, terminal.c, tilde.c, tilde.h,
        undo.c, util.c, vi_keymap.c, vi_mode.c, xmalloc.c, xmalloc.h,
        doc/Makefile.in, doc/hist.texinfo, doc/hstech.texinfo,
        doc/hsuser.texinfo, doc/manvers.texinfo, doc/readline.3,
        doc/rlman.texinfo, doc/rltech.texinfo, doc/rluser.texinfo
        doc/rluserman.texinfo, doc/texi2dvi, doc/texi2html,
        shlib/Makefile.in, support/install.sh, support/mkdirs,
        support/mkdist, support/shlib-install, support/shobj-conf,
        examples/Inputrc, examples/Makefile.in, examples/fileman.c,
        examples/histexamp.c, examples/manexamp.c, examples/rl.c,
        examples/rlfe.c, examples/rltest.c, examples/rlversion.c:
        Modified files.
@
text
@d1409 1
a1409 1
	  s = find_pc_symtab (deprecated_selected_frame->pc);
@


1.26
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d49 1
d421 1
a421 1
  extern int screenheight, screenwidth;		/* in readline */
d423 1
d639 1
a639 1
  extern int screenheight, screenwidth;		/* in readline */
d641 1
@


1.25
log
@	Fix PR gdb/787
	* tuiWin.c (ACS_LRCORNER, ACS_LLCORNER, ACS_ULCORNER, ACS_URCORNER,
	ACS_HLINE, ACS_VLINE): Define if they don't exist.
@
text
@d1400 1
a1400 1
      else if (selected_frame != (struct frame_info *) NULL)
d1406 1
a1406 1
	  s = find_pc_symtab (selected_frame->pc);
@


1.24
log
@2002-09-29  Elena Zannoni  <ezannoni@@redhat.com>

	* tui.c (tui_show_source): Don't access current_source_symtab, use
	accessor function instead.  Include source.h and symtab.h
	* tuiDisassem.c (tuiShowDisassemAndUpdateSource,
	tuiVerticalDisassemScroll): Use accessor functions for current
	source line and symtab.  Include source.h.
	* tuiLayout.c (_extractDisplayStartAddr): Use accessor functions
	for current source line and symtab.  Include source.h.
	* tuiWin.c (_makeVisibleWithNewHeight): Ditto.
	* tuiSourceWin.c (tuiUpdateSourceWindowAsIs,
	tuiHorizontalSourceScroll): Ditto.
	* tuiSource.c (tuiVerticalSourceScroll): Ditto.
@
text
@d99 19
@


1.24.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d30 19
a67 12
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

#include <string.h>
#include <ctype.h>
#include <readline/readline.h>

a98 19
#ifndef ACS_LRCORNER
#  define ACS_LRCORNER '+'
#endif
#ifndef ACS_LLCORNER
#  define ACS_LLCORNER '+'
#endif
#ifndef ACS_ULCORNER
#  define ACS_ULCORNER '+'
#endif
#ifndef ACS_URCORNER
#  define ACS_URCORNER '+'
#endif
#ifndef ACS_HLINE
#  define ACS_HLINE '-'
#endif
#ifndef ACS_VLINE
#  define ACS_VLINE '|'
#endif

d401 1
a401 1
  int screenheight, screenwidth;
a402 1
  rl_get_screen_size (&screenheight, &screenwidth);
d618 1
a618 1
  int screenheight, screenwidth;
a619 1
  rl_get_screen_size (&screenheight, &screenwidth);
d1381 1
a1381 1
      else if (deprecated_selected_frame != (struct frame_info *) NULL)
d1387 1
a1387 1
	  s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
@


1.24.2.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@@


1.23
log
@	* tuiWin.c (_newHeightOk): Fix compilation warnings.
@
text
@d56 1
d1368 2
d1379 1
a1379 1
				 current_source_symtab, lineOrAddr, TRUE);
d1384 2
a1385 1
	  extern int current_source_line;
d1389 1
a1389 1
	    line.lineNo = current_source_line;
d1392 1
a1392 1
	      find_line_pc (s, current_source_line, &line.addr);
@


1.23.2.1
log
@	Fix PR gdb/787
	* tuiWin.c (ACS_LRCORNER, ACS_LLCORNER, ACS_ULCORNER, ACS_URCORNER,
	ACS_HLINE, ACS_VLINE): Define if they don't exist.
@
text
@a97 19
#ifndef ACS_LRCORNER
#  define ACS_LRCORNER '+'
#endif
#ifndef ACS_LLCORNER
#  define ACS_LLCORNER '+'
#endif
#ifndef ACS_ULCORNER
#  define ACS_ULCORNER '+'
#endif
#ifndef ACS_URCORNER
#  define ACS_URCORNER '+'
#endif
#ifndef ACS_HLINE
#  define ACS_HLINE '-'
#endif
#ifndef ACS_VLINE
#  define ACS_VLINE '|'
#endif

@


1.23.4.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a55 1
#include "source.h"
a1366 2
	  struct symtab_and_line cursal
	    = get_current_source_symtab_and_line ();
d1376 1
a1376 1
				 cursal.symtab, lineOrAddr, TRUE);
d1381 1
a1381 2
	  struct symtab_and_line cursal = get_current_source_symtab_and_line ();

d1385 1
a1385 1
	    line.lineNo = cursal.line;
d1388 1
a1388 1
	      find_line_pc (s, cursal.line, &line.addr);
@


1.23.4.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a98 19
#ifndef ACS_LRCORNER
#  define ACS_LRCORNER '+'
#endif
#ifndef ACS_LLCORNER
#  define ACS_LLCORNER '+'
#endif
#ifndef ACS_ULCORNER
#  define ACS_ULCORNER '+'
#endif
#ifndef ACS_URCORNER
#  define ACS_URCORNER '+'
#endif
#ifndef ACS_HLINE
#  define ACS_HLINE '-'
#endif
#ifndef ACS_VLINE
#  define ACS_VLINE '|'
#endif

@


1.23.4.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a48 1
#include <readline/readline.h>
d420 1
a420 1
  int screenheight, screenwidth;
a421 1
  rl_get_screen_size (&screenheight, &screenwidth);
d637 1
a637 1
  int screenheight, screenwidth;
a638 1
  rl_get_screen_size (&screenheight, &screenwidth);
d1400 1
a1400 1
      else if (deprecated_selected_frame != (struct frame_info *) NULL)
d1406 1
a1406 1
	  s = find_pc_symtab (deprecated_selected_frame->pc);
@


1.23.4.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d30 20
a68 12
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

#include <string.h>
#include <ctype.h>
#include <readline/readline.h>

d1409 1
a1409 1
	  s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
@


1.23.4.5
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.22
log
@	* tuiWin.c (_tuiAllWindowsInfo): Don't crash if the window
	is not displayed.
@
text
@d1449 1
a1449 1
	  int curTotalHeight, totalHeight, minHeight;
d1468 1
a1468 1
	  curTotalHeight =
@


1.21
log
@	* tuiWin.c (tui_update_gdb_sizes): New function to tell gdb what
	is the size of command window.
	(tuiResizeAll): Call it instead of init_page_info.
	* tui.c (tui_enable): Call it to resize to TUI command window.
	(tui_disable): Likewise for plain screen.
@
text
@d931 1
a931 1
    if (winList[type]->generic.isVisible)
@


1.20
log
@	* tuiSourceWin.c (tui_show_source_line): New function.
	(tuiShowSourceContent): Call it and avoid clearing the window before
	redrawing it.
	(tuiClearAllSourceWinsContent): Remove.
	* tuiSourceWin.h (tuiClearAllSourceWinsContent): Don't declare.
	* tuiWin.h (tuiClearWinFocus, tuiClearWinFocusFrom): Don't declare.
	* tuiWin.c (tuiClearWinFocus, tuiClearWinFocusFrom): Remove.
	(tuiRefreshAll): Don't clear the window.
	(_makeVisibleWithNewHeight): Don't clear locator line.
	(tuiResizeAll): Remove unused locals.
	(_tuiAdjustWinHeights): Likewise.
	(_makeInvisibleAndSetNewHeight): Likewise.
	(_newHeightOk): Likewise.
	* tuiLayout.c (showLayout): Don't clear source windows.
	(tuiSetLayout): Don't clear the window.
	(_initAndMakeWin): Likewise for status line.
	* tuiGeneralWin.c (makeVisible): Don't clear or refresh the window.
	(makeWindow): Likewise.
	(tuiClearWin): Remove.
	* tuiGeneralWin.h (tuiClearWin): Don't declare.
@
text
@d55 1
a67 5
** External Declarations
********************************/
extern void init_page_info ();

/*******************************
d395 16
d633 1
a633 1
      init_page_info ();
d1054 1
a1054 1
			init_page_info ();
@


1.19
log
@Add FIXME explaining include problem.
@
text
@a400 31
   ** tuiClearWinFocusFrom
   **        Clear the logical focus from winInfo
 */
void
tuiClearWinFocusFrom (TuiWinInfoPtr winInfo)
{
  if (m_winPtrNotNull (winInfo))
    {
      if (winInfo->generic.type != CMD_WIN)
	unhighlightWin (winInfo);
      tuiSetWinWithFocus ((TuiWinInfoPtr) NULL);
    }

  return;
}				/* tuiClearWinFocusFrom */


/*
   ** tuiClearWinFocus().
   **        Clear the window that has focus.
 */
void
tuiClearWinFocus (void)
{
  tuiClearWinFocusFrom (tuiWinWithFocus ());

  return;
}				/* tuiClearWinFocus */


/*
a578 3
	      tuiClearWin (&winList[type]->generic);
	      if (winList[type]->detail.sourceInfo.hasLocator)
		tuiClearLocatorDisplay ();
a591 1
  tuiClearLocatorDisplay ();
d593 1
a593 3

  return;
}				/* tuiRefreshAll */
d616 1
a616 1
      int i, newHeight, splitDiff, cmdSplitDiff, numWinsDisplayed = 2;
d1134 1
a1134 1
	  int i, diff;
a1281 1
  struct symtab *s;
d1330 1
a1330 3

  return;
}				/* _makeInvisibleAndSetNewHeight */
a1341 1
  int i;
a1382 1
	  tuiClearLocatorDisplay ();
d1411 1
a1411 1
      int diff, curHeight;
@


1.19.8.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a54 1
#include "top.h"
d67 5
d399 5
a403 1
/* Update gdb's knowledge of the terminal size.  */
d405 1
a405 1
tui_update_gdb_sizes ()
d407 19
a425 2
  char cmd[50];
  extern int screenheight, screenwidth;		/* in readline */
d427 2
a428 8
  /* Set to TUI command window dimension or use readline values.  */
  sprintf (cmd, "set width %d",
           tui_active ? cmdWin->generic.width : screenwidth);
  execute_command (cmd, 0);
  sprintf (cmd, "set height %d",
           tui_active ? cmdWin->generic.height : screenheight);
  execute_command (cmd, 0);
}
d610 3
d626 1
d628 3
a630 1
}
d653 1
a653 1
      int newHeight, splitDiff, cmdSplitDiff, numWinsDisplayed = 2;
d658 1
a658 1
      tui_update_gdb_sizes ();
d1079 1
a1079 1
                        tui_update_gdb_sizes ();
d1171 1
a1171 1
	  int diff;
d1319 1
d1368 3
a1370 1
}
d1382 1
d1424 1
d1453 1
a1453 1
      int diff;
@


1.19.8.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a55 1
#include "source.h"
d931 1
a931 1
    if (winList[type] && winList[type]->generic.isVisible)
a1366 2
	  struct symtab_and_line cursal
	    = get_current_source_symtab_and_line ();
d1376 1
a1376 1
				 cursal.symtab, lineOrAddr, TRUE);
d1381 1
a1381 2
	  struct symtab_and_line cursal = get_current_source_symtab_and_line ();

d1385 1
a1385 1
	    line.lineNo = cursal.line;
d1388 1
a1388 1
	      find_line_pc (s, cursal.line, &line.addr);
d1449 1
a1449 1
	  int curTotalHeight, totalHeight, minHeight = 0;
d1468 1
a1468 1
	  totalHeight = curTotalHeight =
@


1.19.8.3
log
@merge from mainline
@
text
@a98 19
#ifndef ACS_LRCORNER
#  define ACS_LRCORNER '+'
#endif
#ifndef ACS_LLCORNER
#  define ACS_LLCORNER '+'
#endif
#ifndef ACS_ULCORNER
#  define ACS_ULCORNER '+'
#endif
#ifndef ACS_URCORNER
#  define ACS_URCORNER '+'
#endif
#ifndef ACS_HLINE
#  define ACS_HLINE '-'
#endif
#ifndef ACS_VLINE
#  define ACS_VLINE '|'
#endif

@


1.19.10.1
log
@2002-08-27  Elena Zannoni  <ezannoni@@redhat.com>

       Fix PR gdb/675
       * tuiWin.c: Include readline/readline.h. Use accessor function
       rl_get_screen_size.

       * tuiRegs.c (_tuiRegisterFormat): Use DO_REGISTERS_INFO instead of
       do_registers_info.
@
text
@a48 1
#include <readline/readline.h>
d642 1
a642 1
  int screenheight, screenwidth;
a643 1
  rl_get_screen_size (&screenheight, &screenwidth);
@


1.18
log
@2002-02-08  Daniel Jacobowitz  <drow@@mvista.com>

        * utils.c: Include <curses.h> before "bfd.h".
        * tui/tui-hooks.c: Likewise.
        * tui/tui.c: Likewise.
        * tui/tuiCommand.c: Likewise.
        * tui/tuiData.c: Likewise.
        * tui/tuiDataWin.c: Likewise.
        * tui/tuiDisassem.c: Likewise.
        * tui/tuiGeneralWin.c: Likewise.
        * tui/tuiIO.c: Likewise.
        * tui/tuiLayout.c: Likewise.
        * tui/tuiRegs.c: Likewise.
        * tui/tuiSource.c: Likewise.
        * tui/tuiSourceWin.c: Likewise.
        * tui/tuiStack.c: Likewise.
        * tui/tuiWin.c: Likewise.
@
text
@d2 4
a5 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d30 8
a37 1
/* If we need <curses.h>, we must include it before we get "bfd.h".  */
@


1.17
log
@s/NO_FUNCTION/NULL/
@
text
@d27 10
@


1.16
log
@	* tuiWin.c (_initialize_tuiWin): Use specific tui prefix for
	set/show configuration variables.
	(show_tui_cmd): New function.
	(set_tui_cmd): New function.
@
text
@d283 1
a283 1
  add_cmd ("tui", class_tui, NO_FUNCTION,
@


1.15
log
@	* tuiStack.c (tuiUpdateLocatorFilename): Use const char*.
	* tuiStack.h (tuiUpdateLocatorFilename): Update prototype.
	* tuiWin.c (_initialize_tuiWin): Don't cast table of enum in calls
	to add_set_enum_cmd.
	* tui.c (tui_show_source): New function.
	(tuiGetLowDisassemblyAddress): Use CORE_ADDR for newLow.
	(tui_switch_mode): Prep or deprep readline terminal;
	make sure the \n we return does not redo the last command.
	* tui.h (tui_show_source): Declare.
	(tui_out_new, tui_install_hooks, tui_remove_hooks): Likewise.
	(tui_active, tui_initialize_io, tui_initialize_readline): Likewise.
@
text
@d260 9
d278 2
a282 1

d287 9
d338 1
a338 1
    ("tui-border-kind", class_tui,
d345 2
a346 2
     &setlist);
  add_show_from_set (c, &showlist);
d349 1
a349 1
    ("tui-border-mode", class_tui,
d360 2
a361 2
     &setlist);
  add_show_from_set (c, &showlist);
d364 1
a364 1
    ("tui-active-border-mode", class_tui,
d375 2
a376 2
     &setlist);
  add_show_from_set (c, &showlist);
@


1.14
log
@	* tuiWin.c (tuiRefreshAll): Use clearok to force a refresh.
@
text
@d320 1
a320 1
     tui_border_kind_enums, (char*) &tui_border_kind,
d331 1
a331 1
     tui_border_mode_enums, (char*) &tui_border_mode,
d346 1
a346 1
     tui_border_mode_enums, (char*) &tui_active_border_mode,
@


1.13
log
@	* tuiGeneralWin.c (boxWin): Use the tui configuration variables.
	* tuiWin.h: Declare the new variables.
	* tuiWin.c (_initialize_tuiWin): Create TUI configuration variables.
	(tui_update_variables): New function.
	(translate): New function.
	(tui_border_kind_enums, tui_border_mode_enums): New tables.
	(tui_border_mode_translate): New table.
	(tui_border_kind_translate_*): New tables.
	(tui_active_border_mode): New variables.
	(tui_border_*): New variables.
@
text
@d561 1
@


1.12
log
@	* tuiWin.c (_parseScrollingArgs): Fix uninitialized variable.
	(_makeVisibleWithNewHeight): Use TuiLineOrAddress type.

	* tuiStack.c (tuiShowFrameInfo): Use TuiLineOrAddress type.
	(tui_vUpdateLocatorFilename): Remove.
	* tuiStack.h: Update prototypes.

	* tuiSourceWin.c (tuiAddrIsDisplayed): New function.
	(tuiLineIsDisplayed): Split for address and line.
	(tuiUpdateSourceWindow): Use TuiLineOrAddress type.
	(tuiUpdateSourceWindowAsIs): Likewise.
	(tuiUpdateSourceWindowsWithAddr): Likewise.
	(tuiUpdateSourceWindowsWithLine): Likewise.
	(tuiHorizontalSourceScroll): Likewise.
	(tuiSetIsExecPointAt): Likewise.
	(tuiUpdateOnEnd): Likewise.
	* tuiSourceWin.h: Update prototypes.

	* tuiSource.c (tuiVerticalSourceScroll): Use TuiLineOrAddress type.
	(tuiShowSource): Likewise.
	(tuiVerticalSourceScroll): Likewise.
	* tuiSource.h (tuiShowSource): Update prototype.

	* tuiDisassem.c (tuiSetDisassemContent): Use CORE_ADDR for address.
	(tuiShowDisassem): Use TuiLineOrAddress type.
	(tuiShowDisassemAndUpdateSource): Likewise.
	(tuiVerticalDisassemScroll): Likewise.
	(tuiShowDisassemAsIs): Remove.
	* tuiDisassem.h (tuiSetDisassemContent): Update prototype.

	* tuiData.c (initWinInfo): Use CORE_ADDR for address.
	(clearWinDetail): Likewise.
	(displayableWinContentOf): Fix address conversion.
	(tuiNextWin): Fix crash when the window is not yet created.
	(partialWinByName): Likewise.
@
text
@d82 179
d268 2
d316 42
@


1.11
log
@	* tuiWin.c (tuiStrDup): Remove, replaced by xstrdup.
	(_parseScrollingArgs): Use xstrdup.
	(_tuiScrollForward_command): Call tui_enable() to force TUI mode.
	(_tuiScrollBackward_command): Likewise.
	(_tuiScrollLeft_command): Likewise.
	(_tuiScrollRight_command): Likewise.
	(_tuiSetFocus): Likewise.
	(_tuiSetFocus_command): Likewise.
	(_tuiRefreshAll_command): Likewise.
	(_tuiSetTabWidth_command): Likewise.
	(_tuiSetWinHeight): Likewise.
	(_tuiSetWinHeight_command): Likewise.
	(_tuiXDBsetWinHeight): Likewise.
	(_tui_vSetFocus): Remove.
	(_tui_vSetWinHeight): Remove.
	(_tui_vXDBsetWinHeight): Remove.
@
text
@d1142 1
a1142 5
				 current_source_symtab,
				 ((winInfo->generic.type == SRC_WIN) ?
				  (Opaque) lineOrAddr.lineNo :
				  lineOrAddr.addr),
				 TRUE);
d1146 1
a1146 1
	  Opaque line = 0;
d1151 1
a1151 1
	    line = (Opaque) current_source_line;
d1154 1
a1154 4
	      CORE_ADDR pc;

	      find_line_pc (s, current_source_line, &pc);
	      line = (Opaque) pc;
d1345 3
a1347 1

@


1.10
log
@	* tuiWin.c (_initialize_tuiWin): Always define the tui commands;
	create the tui class help.
	* tuiLayout.c (_initialize_tuiLayout): Always define the tui commands.
	* tuiRegs.c (_initialize_tuiRegs): Likewise.
	* tuiStack.c (_initialize_tuiStack): Likewise.
@
text
@a191 15
char *
tuiStrDup (char *str)
{
  char *newStr = (char *) NULL;

  if (str != (char *) NULL)
    {
      newStr = (char *) xmalloc (strlen (str) + 1);
      strcpy (newStr, str);
    }

  return newStr;
}				/* tuiStrDup */


d566 2
d585 2
d604 2
d620 2
d636 1
a636 1
      char *bufPtr = (char *) tuiStrDup (arg);
a670 16

/*
   ** _tui_vSetFocus()
 */
static void
_tui_vSetFocus (va_list args)
{
  char *arg = va_arg (args, char *);
  int fromTTY = va_arg (args, int);

  _tuiSetFocus (arg, fromTTY);

  return;
}				/* tui_vSetFocus */


d677 2
d715 3
d729 2
d753 2
d757 1
a757 1
      char *buf = tuiStrDup (arg);
a835 17

/*
   ** _tui_vSetWinHeight().
   **        Set the height of the specified window, with va_list.
 */
static void
_tui_vSetWinHeight (va_list args)
{
  char *arg = va_arg (args, char *);
  int fromTTY = va_arg (args, int);

  _tuiSetWinHeight (arg, fromTTY);

  return;
}				/* _tui_vSetWinHeight */


d843 2
d857 2
a882 17

/*
   ** _tui_vXDBsetWinHeight().
   **        Set the height of the specified window, with va_list.
 */
static void
_tui_vXDBsetWinHeight (va_list args)
{
  char *arg = va_arg (args, char *);
  int fromTTY = va_arg (args, int);

  _tuiXDBsetWinHeight (arg, fromTTY);

  return;
}				/* _tui_vXDBsetWinHeight */


d1322 1
a1322 1
      buf = bufPtr = tuiStrDup (arg);
@


1.9
log
@	* tuiIO.c (_tuiHandleResizeDuringIO): Call tuiRefreshAll.
	(tuiRead, tui_vread): Remove.

	* tui.c (va_catch_errors, tuiDo, tuiDoAndReturnToTop): Remove.
	(vcatch_errors, _tui_vDo): Remove.
	* tui.h (tuiDo, tuiDoAndReturnToTop): Remove.

	* tuiLayout.c (tuiSetLayout): Remove vcatch_errors.
	(tui_set_layout): Rename of _tuiSetLayoutTo, public.
	(_tuiToggleLayout_command): Merge with _tui_vToggleLayout_command.
	(_tuiToggleSplitLayout_command): Merge with _tui_vToggleSplitLayout_command.
	(_tuiLayout_command): Call tui_set_layout.

	* tuiRegs.c (_tuiScrollRegsBackward_command): Call tui_scroll.
	(_tuiScrollRegsForward_command): Likewise.
	(_tuiShowFloat_command): Call _tui_vShowRegisters_commandSupport.
	(_tuiShowGeneral_command): Likewise.
	(_tuiShowSpecial_command): Likewise.
	(_tuiToggleFloatRegs_command): Call tuiToggleFloatRegs.
	* tuiWin.c (tui_scroll): Rename of tui_vScroll, update parameters.
	(_tuiScrollForward_command): Call tui_scroll.
	(_tuiScrollBackward_command): Likewise.
	(_tuiScrollLeft_command): Likewise.
	(_tuiScrollRight_command): Likewise.
	(_tuiSetFocus_command): Call _tuiSetFocus.
	(_tuiRefreshAll_command): Call tuiRefreshAll.
	(_tuiSetWinHeight_command): Call _tuiSetWinHeight.
	(_tuiXDBsetWinHeight_command): Call _tuiXDBsetWinHeight.
	* tuiWin.h (tui_scroll): Rename of tui_vScroll, update parameters.
@
text
@d34 1
d89 13
a101 8
  if (tui_version)
    {
      add_com ("refresh", class_tui, _tuiRefreshAll_command,
	       "Refresh the terminal display.\n");
      if (xdb_commands)
	add_com_alias ("U", "refresh", class_tui, 0);
      add_com ("tabset", class_tui, _tuiSetTabWidth_command,
	       "Set the width (in characters) of tab stops.\n\
d103 2
a104 2
      add_com ("winheight", class_tui, _tuiSetWinHeight_command,
	       "Set the height of a specified window.\n\
d111 5
a115 5
      add_com_alias ("wh", "winheight", class_tui, 0);
      add_info ("win", _tuiAllWindowsInfo,
		"List of all displayed windows.\n");
      add_com ("focus", class_tui, _tuiSetFocus_command,
	       "Set focus to named window or next/prev window.\n\
d122 12
a133 12
      add_com_alias ("fs", "focus", class_tui, 0);
      add_com ("+", class_tui, _tuiScrollForward_command,
	       "Scroll window forward.\nUsage: + [win] [n]\n");
      add_com ("-", class_tui, _tuiScrollBackward_command,
	       "Scroll window backward.\nUsage: - [win] [n]\n");
      add_com ("<", class_tui, _tuiScrollLeft_command,
	       "Scroll window forward.\nUsage: < [win] [n]\n");
      add_com (">", class_tui, _tuiScrollRight_command,
	       "Scroll window backward.\nUsage: > [win] [n]\n");
      if (xdb_commands)
	add_com ("w", class_xdb, _tuiXDBsetWinHeight_command,
		 "XDB compatibility command for setting the height of a command window.\n\
d135 1
a135 4
    }

  return;
}				/* _intialize_tuiWin */
@


1.8
log
@	* tuiWin.c: Add missing includes.
	(_makeVisibleWithNewHeight): Fix call to find_line_pc.
	* tuiLayout.c: Add missing includes.
	(_initAndMakeWin): Don't put curses in echo mode.
	(_extractDisplayStartAddr): Fix calls to find_line_pc.
	(_tuiLayout_command): Missing ',' in warning call.
	* tuiSourceWin.c (tuiUpdateSourceWindowsWithLine): Fix calls to
	find_line_pc.
	(tuiSetHasBreakAt): Check for null source file.
@
text
@d314 1
a314 1
   ** tui_vScroll().
d318 3
a320 1
tui_vScroll (va_list args)
a321 4
  TuiScrollDirection direction = va_arg (args, TuiScrollDirection);
  TuiWinInfoPtr winToScroll = va_arg (args, TuiWinInfoPtr);
  int numToScroll = va_arg (args, int);

d339 1
a339 3

  return;
}				/* tui_vScroll */
d582 2
a583 7
  tuiDo ((TuiOpaqueFuncPtr) tui_vScroll,
	 FORWARD_SCROLL,
	 winToScroll,
	 numToScroll);

  return;
}				/* _tuiScrollForward_command */
d599 2
a600 7
  tuiDo ((TuiOpaqueFuncPtr) tui_vScroll,
	 BACKWARD_SCROLL,
	 winToScroll,
	 numToScroll);

  return;
}				/* _tuiScrollBackward_command */
d613 2
a614 7
  tuiDo ((TuiOpaqueFuncPtr) tui_vScroll,
	 LEFT_SCROLL,
	 winToScroll,
	 numToScroll);

  return;
}				/* _tuiScrollLeft_command */
d627 2
a628 7
  tuiDo ((TuiOpaqueFuncPtr) tui_vScroll,
	 RIGHT_SCROLL,
	 winToScroll,
	 numToScroll);

  return;
}				/* _tuiScrollRight_command */
d697 2
a698 4
  tuiDo ((TuiOpaqueFuncPtr) _tui_vSetFocus, arg, fromTTY);

  return;
}				/* tui_SetFocus */
d733 1
a733 1
  tuiDo ((TuiOpaqueFuncPtr) tuiRefreshAll);
d871 2
a872 4
  tuiDo ((TuiOpaqueFuncPtr) _tui_vSetWinHeight, arg, fromTTY);

  return;
}				/* _tuiSetWinHeight_command */
d931 2
a932 4
  tuiDo ((TuiOpaqueFuncPtr) _tui_vXDBsetWinHeight, arg, fromTTY);

  return;
}				/* _tuiXDBsetWinHeight_command */
@


1.7
log
@	* tuiWin.c (_tuiSetFocus): Replace subsetCompare with subset_compare.
	* tuiLayout.c (_tuiSetLayoutTo): Likewise.
	* tui.c (_tui_vToggle_command): Likewise.
@
text
@d28 1
d39 3
d1228 6
a1233 1
	    line = (Opaque) find_line_pc (s, current_source_line);
@


1.6
log
@	* tuiStack.c: Add missing includes.
	(tuiShowFrameInfo): Don't crash when there is no symbol table
	associated with the pc.
	* tuiSource.c (_hasBreak): Check for null source file.
	* tuiWin.c (tuiRefreshAll): Check for null winList[type].
	(_tuiSetFocus): Check for null dataWin.
	* tuiGeneralWin.c (refreshAll): Check for null list[type].
@
text
@d667 1
a667 1
      if (subsetCompare (bufPtr, "NEXT"))
d669 1
a669 1
      else if (subsetCompare (bufPtr, "PREV"))
@


1.5
log
@	* tuiWin.c, tui.c, tuiCommand.c: Use ansi prototype.
	tuiIO.c, tuiData.c: Likewise.
	tuiDataWin.c, tuiDisassem.c: Likewise.
	tuiGeneralWin.c, tuiLayout.c: Likewise.
	tuiRegs.c, tuiSource.c: Likewise.
	tuiSouceWin.c, tuiStack.c: Likewise.
@
text
@d353 1
a353 1
      if (winList[type]->generic.isVisible)
d683 1
a683 1
      if (dataWin->generic.isVisible)
@


1.4
log
@	* tuiWin.c, tuiWin.h, tui.c, tui.h, tuiCommand.c: Add FSF copyright.
	tuiCommand.h, tuiIO.c, tuiIO.h, tuiData.h, tuiData.c: Likewise.
	tuiDataWin.c, tuiDataWin.h, tuiDisassem.c, tuiDisassem.h: Likewise.
	tuiGeneralWin.c, tuiGeneralWin.h, tuiLayout.c, tuiLayout.h: Likewise.
	tuiRegs.c, tuiRegs.h, tuiSource.c, tuiSource.h: Likewise.
	tuiSouceWin.c, tuiSourceWin.h, tuiStack.c, tuiStack.h: Likewise.
@
text
@d136 1
a136 7
#ifdef __STDC__
tuiClearWinFocusFrom (
		       TuiWinInfoPtr winInfo)
#else
tuiClearWinFocusFrom (winInfo)
     TuiWinInfoPtr winInfo;
#endif
a153 1
#ifdef __STDC__
a154 3
#else
tuiClearWinFocus ()
#endif
d167 1
a167 7
#ifdef __STDC__
tuiSetWinFocusTo (
		   TuiWinInfoPtr winInfo)
#else
tuiSetWinFocusTo (winInfo)
     TuiWinInfoPtr winInfo;
#endif
d186 1
a186 7
#ifdef __STDC__
tuiStrDup (
	    char *str)
#else
tuiStrDup (str)
     char *str;
#endif
d204 1
a204 9
#ifdef __STDC__
tuiScrollForward (
		   TuiWinInfoPtr winToScroll,
		   int numToScroll)
#else
tuiScrollForward (winToScroll, numToScroll)
     TuiWinInfoPtr winToScroll;
     int numToScroll;
#endif
d234 1
a234 9
#ifdef __STDC__
tuiScrollBackward (
		    TuiWinInfoPtr winToScroll,
		    int numToScroll)
#else
tuiScrollBackward (winToScroll, numToScroll)
     TuiWinInfoPtr winToScroll;
     int numToScroll;
#endif
d263 1
a263 9
#ifdef __STDC__
tuiScrollLeft (
		TuiWinInfoPtr winToScroll,
		int numToScroll)
#else
tuiScrollLeft (winToScroll, numToScroll)
     TuiWinInfoPtr winToScroll;
     int numToScroll;
#endif
d288 1
a288 9
#ifdef __STDC__
tuiScrollRight (
		 TuiWinInfoPtr winToScroll,
		 int numToScroll)
#else
tuiScrollRight (winToScroll, numToScroll)
     TuiWinInfoPtr winToScroll;
     int numToScroll;
#endif
d314 1
a314 7
#ifdef __STDC__
tui_vScroll (
	      va_list args)
#else
tui_vScroll (args)
     va_list args;
#endif
a345 1
#ifdef __STDC__
a346 3
#else
tuiRefreshAll ()
#endif
a387 1
#ifdef __STDC__
a388 3
#else
tuiResizeAll ()
#endif
d551 1
a551 7
#ifdef __STDC__
tuiSigwinchHandler (
		     int signal)
#else
tuiSigwinchHandler (signal)
     int signal;
#endif
d573 1
a573 9
#ifdef __STDC__
_tuiScrollForward_command (
			    char *arg,
			    int fromTTY)
#else
_tuiScrollForward_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d595 1
a595 9
#ifdef __STDC__
_tuiScrollBackward_command (
			     char *arg,
			     int fromTTY)
#else
_tuiScrollBackward_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d617 1
a617 9
#ifdef __STDC__
_tuiScrollLeft_command (
			 char *arg,
			 int fromTTY)
#else
_tuiScrollLeft_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d636 1
a636 9
#ifdef __STDC__
_tuiScrollRight_command (
			  char *arg,
			  int fromTTY)
#else
_tuiScrollRight_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d656 1
a656 9
#ifdef __STDC__
_tuiSetFocus (
	       char *arg,
	       int fromTTY)
#else
_tuiSetFocus (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d700 1
a700 7
#ifdef __STDC__
_tui_vSetFocus (
		 va_list args)
#else
_tui_vSetFocus (args)
     va_list args;
#endif
d715 1
a715 9
#ifdef __STDC__
_tuiSetFocus_command (
		       char *arg,
		       int fromTTY)
#else
_tuiSetFocus_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d727 1
a727 9
#ifdef __STDC__
_tuiAllWindowsInfo (
		     char *arg,
		     int fromTTY)
#else
_tuiAllWindowsInfo (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d753 1
a753 9
#ifdef __STDC__
_tuiRefreshAll_command (
			 char *arg,
			 int fromTTY)
#else
_tuiRefreshAll_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d764 1
a764 9
#ifdef __STDC__
_tuiSetTabWidth_command (
			  char *arg,
			  int fromTTY)
#else
_tuiSetTabWidth_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d786 1
a786 9
#ifdef __STDC__
_tuiSetWinHeight (
		   char *arg,
		   int fromTTY)
#else
_tuiSetWinHeight (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d875 1
a875 7
#ifdef __STDC__
_tui_vSetWinHeight (
		     va_list args)
#else
_tui_vSetWinHeight (args)
     va_list args;
#endif
d891 1
a891 9
#ifdef __STDC__
_tuiSetWinHeight_command (
			   char *arg,
			   int fromTTY)
#else
_tuiSetWinHeight_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d905 1
a905 9
#ifdef __STDC__
_tuiXDBsetWinHeight (
		      char *arg,
		      int fromTTY)
#else
_tuiXDBsetWinHeight (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d937 1
a937 7
#ifdef __STDC__
_tui_vXDBsetWinHeight (
			va_list args)
#else
_tui_vXDBsetWinHeight (args)
     va_list args;
#endif
d953 1
a953 9
#ifdef __STDC__
_tuiXDBsetWinHeight_command (
			      char *arg,
			      int fromTTY)
#else
_tuiXDBsetWinHeight_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d966 1
a966 9
#ifdef __STDC__
_tuiAdjustWinHeights (
		       TuiWinInfoPtr primaryWinInfo,
		       int newHeight)
#else
_tuiAdjustWinHeights (primaryWinInfo, newHeight)
     TuiWinInfoPtr primaryWinInfo;
     int newHeight;
#endif
d1120 1
a1120 9
#ifdef __STDC__
_makeInvisibleAndSetNewHeight (
				TuiWinInfoPtr winInfo,
				int height)
#else
_makeInvisibleAndSetNewHeight (winInfo, height)
     TuiWinInfoPtr winInfo;
     int height;
#endif
d1184 1
a1184 7
#ifdef __STDC__
_makeVisibleWithNewHeight (
			    TuiWinInfoPtr winInfo)
#else
_makeVisibleWithNewHeight (winInfo)
     TuiWinInfoPtr winInfo;
#endif
d1253 1
a1253 9
#ifdef __STDC__
_newHeightOk (
	       TuiWinInfoPtr primaryWinInfo,
	       int newHeight)
#else
_newHeightOk (primaryWinInfo, newHeight)
     TuiWinInfoPtr primaryWinInfo;
     int newHeight;
#endif
d1369 1
a1369 11
#ifdef __STDC__
_parseScrollingArgs (
		      char *arg,
		      TuiWinInfoPtr * winToScroll,
		      int *numToScroll)
#else
_parseScrollingArgs (arg, winToScroll, numToScroll)
     char *arg;
     TuiWinInfoPtr *winToScroll;
     int *numToScroll;
#endif
@


1.3
log
@Protoization.
@
text
@d1 3
a3 7
/*
   ** tuiWin.c
   **    This module contains procedures for handling tui window functions
   **    like resize, scrolling, scrolling, changing focus, etc.
   **
   ** Author: Susan B. Macchia
 */
d5 21
@


1.2
log
@PARAMS removal.
@
text
@d65 1
a65 1
_initialize_tuiWin ()
@


1.1
log
@Initial revision
@
text
@d2 6
a7 6
** tuiWin.c
**    This module contains procedures for handling tui window functions
**    like resize, scrolling, scrolling, changing focus, etc.
**
** Author: Susan B. Macchia
*/
d32 15
a46 15
static void _makeVisibleWithNewHeight PARAMS ((TuiWinInfoPtr));
static void _makeInvisibleAndSetNewHeight PARAMS ((TuiWinInfoPtr, int));
static TuiStatus _tuiAdjustWinHeights PARAMS ((TuiWinInfoPtr, int));
static int _newHeightOk PARAMS ((TuiWinInfoPtr, int));
static void _tuiSetTabWidth_command PARAMS ((char *, int));
static void _tuiRefreshAll_command PARAMS ((char *, int));
static void _tuiSetWinHeight_command PARAMS ((char *, int));
static void _tuiXDBsetWinHeight_command PARAMS ((char *, int));
static void _tuiAllWindowsInfo PARAMS ((char *, int));
static void _tuiSetFocus_command PARAMS ((char *, int));
static void _tuiScrollForward_command PARAMS ((char *, int));
static void _tuiScrollBackward_command PARAMS ((char *, int));
static void _tuiScrollLeft_command PARAMS ((char *, int));
static void _tuiScrollRight_command PARAMS ((char *, int));
static void _parseScrollingArgs PARAMS ((char *, TuiWinInfoPtr *, int *));
d61 3
a63 3
** _initialize_tuiWin().
**        Function to initialize gdb commands, for tui window manipulation.
*/
d115 3
a117 3
** tuiClearWinFocusFrom
**        Clear the logical focus from winInfo
*/
d139 3
a141 3
** tuiClearWinFocus().
**        Clear the window that has focus.
*/
d156 3
a158 3
** tuiSetWinFocusTo
**        Set the logical focus to winInfo
*/
d206 2
a207 2
** tuiScrollForward().
*/
d226 5
a230 5
        ** If we are scrolling the source or disassembly window, do a
        ** "psuedo" scroll since not all of the source is in memory,
        ** only what is in the viewport.  If winToScroll is the
        ** command window do nothing since the term should handle it.
        */
d244 2
a245 2
** tuiScrollBackward().
*/
d264 5
a268 5
        ** If we are scrolling the source or disassembly window, do a
        ** "psuedo" scroll since not all of the source is in memory,
        ** only what is in the viewport.  If winToScroll is the
        ** command window do nothing since the term should handle it.
        */
d281 2
a282 2
** tuiScrollLeft().
*/
d301 5
a305 5
        ** If we are scrolling the source or disassembly window, do a
        ** "psuedo" scroll since not all of the source is in memory,
        ** only what is in the viewport. If winToScroll is the
        ** command window do nothing since the term should handle it.
        */
d314 2
a315 2
** tuiScrollRight().
*/
d334 5
a338 5
        ** If we are scrolling the source or disassembly window, do a
        ** "psuedo" scroll since not all of the source is in memory,
        ** only what is in the viewport. If winToScroll is the
        ** command window do nothing since the term should handle it.
        */
d347 3
a349 3
** tui_vScroll().
**    Scroll a window.  Arguments are passed through a va_list.
*/
d386 2
a387 2
** tuiRefreshAll().
*/
d430 4
a433 4
** tuiResizeAll().
**      Resize all the windows based on the the terminal size.  This
**      function gets called from within the readline sinwinch handler.
*/
d442 1
a442 1
  extern int screenheight, screenwidth;	/* in readline */
d574 3
a576 3
        ** Now remove all invisible windows, and their content so that they get
        ** created again when called for with the new size
        */
d596 5
a600 5
** tuiSigwinchHandler()
**    SIGWINCH signal handler for the tui.  This signal handler is
**    always called, even when the readline package clears signals
**    because it is set as the old_sigwinch() (TUI only)
*/
d611 3
a613 3
    ** Say that a resize was done so that the readline can do it
    ** later when appropriate.
    */
d627 2
a628 2
** _tuiScrollForward_command().
*/
d657 2
a658 2
** _tuiScrollBackward_command().
*/
d687 2
a688 2
** _tuiScrollLeft_command().
*/
d714 2
a715 2
** _tuiScrollRight_command().
*/
d741 3
a743 3
** _tuiSetFocus().
**     Set focus to the window named by 'arg'
*/
d794 2
a795 2
** _tui_vSetFocus()
*/
d815 2
a816 2
** _tuiSetFocus_command()
*/
d835 2
a836 2
** _tuiAllWindowsInfo().
*/
d869 2
a870 2
** _tuiRefreshAll_command().
*/
d887 3
a889 3
** _tuiSetWinTabWidth_command().
**        Set the height of the specified window.
*/
d917 3
a919 3
** _tuiSetWinHeight().
**        Set the height of the specified window.
*/
d946 2
a947 2
            ** Validate the window name
            */
d984 3
a986 3
                        ** Now change the window's height, and adjust all
                        ** other windows around it
                        */
d1014 3
a1016 3
** _tui_vSetWinHeight().
**        Set the height of the specified window, with va_list.
*/
d1036 3
a1038 3
** _tuiSetWinHeight_command().
**        Set the height of the specified window, with va_list.
*/
d1057 4
a1060 4
** _tuiXDBsetWinHeight().
**        XDB Compatibility command for setting the window height.  This will
**        increase or decrease the command window by the specified amount.
*/
d1098 3
a1100 3
** _tui_vXDBsetWinHeight().
**        Set the height of the specified window, with va_list.
*/
d1120 3
a1122 3
** _tuiSetWinHeight_command().
**        Set the height of the specified window, with va_list.
*/
d1141 3
a1143 3
** _tuiAdjustWinHeights().
**        Function to adjust all window heights around the primary
*/
d1207 3
a1209 3
                    ** Split the change in height accross the 1st & 2nd windows
                    ** adjusting them as well.
                    */
d1253 3
a1255 3
                        ** If there is no way to increase the command window
                        ** take real estate from the 1st or 2nd window.
                        */
d1302 4
a1305 4
** _makeInvisibleAndSetNewHeight().
**        Function make the target window (and auxillary windows associated
**        with the targer) invisible, and set the new height and location.
*/
d1373 5
a1377 5
** _makeVisibleWithNewHeight().
**        Function to make the windows with new heights visible.
**        This means re-creating the windows' content since the window
**        had to be destroyed to be made invisible.
*/
d1508 5
a1512 5
            ** We could simply add all the heights to obtain the same result
            ** but below is more explicit since we subtract 1 for the
            ** line that the first and second windows share, and add one
            ** for the locator.
            */
d1515 1
a1515 1
	    + cmdWin->generic.height + 1 /*locator*/ ;
d1534 4
a1537 4
                ** First see if we can increase/decrease the command
                ** window.  And make sure that the command window is
                ** at least 1 line
                */
d1541 3
a1543 3
                     ** Looks like we have to increase/decrease one of
                     ** the other windows
                     */
d1562 3
a1564 3
            ** Now make sure that the proposed total height doesn't exceed
            ** the old total height.
            */
d1575 2
a1576 2
** _parseScrollingArgs().
*/
d1595 3
a1597 3
    ** First set up the default window to scroll, in case there is no
    ** window name arg
    */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d2 6
a7 6
   ** tuiWin.c
   **    This module contains procedures for handling tui window functions
   **    like resize, scrolling, scrolling, changing focus, etc.
   **
   ** Author: Susan B. Macchia
 */
d61 3
a63 3
   ** _initialize_tuiWin().
   **        Function to initialize gdb commands, for tui window manipulation.
 */
d115 3
a117 3
   ** tuiClearWinFocusFrom
   **        Clear the logical focus from winInfo
 */
d139 3
a141 3
   ** tuiClearWinFocus().
   **        Clear the window that has focus.
 */
d156 3
a158 3
   ** tuiSetWinFocusTo
   **        Set the logical focus to winInfo
 */
d206 2
a207 2
   ** tuiScrollForward().
 */
d226 5
a230 5
         ** If we are scrolling the source or disassembly window, do a
         ** "psuedo" scroll since not all of the source is in memory,
         ** only what is in the viewport.  If winToScroll is the
         ** command window do nothing since the term should handle it.
       */
d244 2
a245 2
   ** tuiScrollBackward().
 */
d264 5
a268 5
         ** If we are scrolling the source or disassembly window, do a
         ** "psuedo" scroll since not all of the source is in memory,
         ** only what is in the viewport.  If winToScroll is the
         ** command window do nothing since the term should handle it.
       */
d281 2
a282 2
   ** tuiScrollLeft().
 */
d301 5
a305 5
         ** If we are scrolling the source or disassembly window, do a
         ** "psuedo" scroll since not all of the source is in memory,
         ** only what is in the viewport. If winToScroll is the
         ** command window do nothing since the term should handle it.
       */
d314 2
a315 2
   ** tuiScrollRight().
 */
d334 5
a338 5
         ** If we are scrolling the source or disassembly window, do a
         ** "psuedo" scroll since not all of the source is in memory,
         ** only what is in the viewport. If winToScroll is the
         ** command window do nothing since the term should handle it.
       */
d347 3
a349 3
   ** tui_vScroll().
   **    Scroll a window.  Arguments are passed through a va_list.
 */
d386 2
a387 2
   ** tuiRefreshAll().
 */
d430 4
a433 4
   ** tuiResizeAll().
   **      Resize all the windows based on the the terminal size.  This
   **      function gets called from within the readline sinwinch handler.
 */
d442 1
a442 1
  extern int screenheight, screenwidth;		/* in readline */
d574 3
a576 3
         ** Now remove all invisible windows, and their content so that they get
         ** created again when called for with the new size
       */
d596 5
a600 5
   ** tuiSigwinchHandler()
   **    SIGWINCH signal handler for the tui.  This signal handler is
   **    always called, even when the readline package clears signals
   **    because it is set as the old_sigwinch() (TUI only)
 */
d611 3
a613 3
     ** Say that a resize was done so that the readline can do it
     ** later when appropriate.
   */
d627 2
a628 2
   ** _tuiScrollForward_command().
 */
d657 2
a658 2
   ** _tuiScrollBackward_command().
 */
d687 2
a688 2
   ** _tuiScrollLeft_command().
 */
d714 2
a715 2
   ** _tuiScrollRight_command().
 */
d741 3
a743 3
   ** _tuiSetFocus().
   **     Set focus to the window named by 'arg'
 */
d794 2
a795 2
   ** _tui_vSetFocus()
 */
d815 2
a816 2
   ** _tuiSetFocus_command()
 */
d835 2
a836 2
   ** _tuiAllWindowsInfo().
 */
d869 2
a870 2
   ** _tuiRefreshAll_command().
 */
d887 3
a889 3
   ** _tuiSetWinTabWidth_command().
   **        Set the height of the specified window.
 */
d917 3
a919 3
   ** _tuiSetWinHeight().
   **        Set the height of the specified window.
 */
d946 2
a947 2
	     ** Validate the window name
	   */
d984 3
a986 3
		         ** Now change the window's height, and adjust all
		         ** other windows around it
		       */
d1014 3
a1016 3
   ** _tui_vSetWinHeight().
   **        Set the height of the specified window, with va_list.
 */
d1036 3
a1038 3
   ** _tuiSetWinHeight_command().
   **        Set the height of the specified window, with va_list.
 */
d1057 4
a1060 4
   ** _tuiXDBsetWinHeight().
   **        XDB Compatibility command for setting the window height.  This will
   **        increase or decrease the command window by the specified amount.
 */
d1098 3
a1100 3
   ** _tui_vXDBsetWinHeight().
   **        Set the height of the specified window, with va_list.
 */
d1120 3
a1122 3
   ** _tuiSetWinHeight_command().
   **        Set the height of the specified window, with va_list.
 */
d1141 3
a1143 3
   ** _tuiAdjustWinHeights().
   **        Function to adjust all window heights around the primary
 */
d1207 3
a1209 3
				   ** Split the change in height accross the 1st & 2nd windows
				   ** adjusting them as well.
				 */
d1253 3
a1255 3
				   ** If there is no way to increase the command window
				   ** take real estate from the 1st or 2nd window.
				 */
d1302 4
a1305 4
   ** _makeInvisibleAndSetNewHeight().
   **        Function make the target window (and auxillary windows associated
   **        with the targer) invisible, and set the new height and location.
 */
d1373 5
a1377 5
   ** _makeVisibleWithNewHeight().
   **        Function to make the windows with new heights visible.
   **        This means re-creating the windows' content since the window
   **        had to be destroyed to be made invisible.
 */
d1508 5
a1512 5
	     ** We could simply add all the heights to obtain the same result
	     ** but below is more explicit since we subtract 1 for the
	     ** line that the first and second windows share, and add one
	     ** for the locator.
	   */
d1515 1
a1515 1
	    + cmdWin->generic.height + 1 /*locator */ ;
d1534 4
a1537 4
	         ** First see if we can increase/decrease the command
	         ** window.  And make sure that the command window is
	         ** at least 1 line
	       */
d1541 3
a1543 3
				   ** Looks like we have to increase/decrease one of
				   ** the other windows
				 */
d1562 3
a1564 3
	     ** Now make sure that the proposed total height doesn't exceed
	     ** the old total height.
	   */
d1575 2
a1576 2
   ** _parseScrollingArgs().
 */
d1595 3
a1597 3
     ** First set up the default window to scroll, in case there is no
     ** window name arg
   */
@

