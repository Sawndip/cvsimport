head	1.23;
access;
symbols
	drow-cplus-merge-20040113:1.22
	drow-cplus-merge-20031224:1.22
	drow-cplus-merge-20031220:1.22
	carlton_dictionary-20031215-merge:1.22
	drow-cplus-merge-20031214:1.22
	carlton-dictionary-20031111-merge:1.22
	gdb_6_0-2003-10-04-release:1.22
	kettenis_sparc-20030918-branch:1.22.0.8
	kettenis_sparc-20030918-branchpoint:1.22
	carlton_dictionary-20030917-merge:1.22
	ezannoni_pie-20030916-branchpoint:1.22
	ezannoni_pie-20030916-branch:1.22.0.6
	cagney_x86i386-20030821-branch:1.22.0.4
	cagney_x86i386-20030821-branchpoint:1.22
	carlton_dictionary-20030805-merge:1.22
	carlton_dictionary-20030627-merge:1.22
	gdb_6_0-branch:1.22.0.2
	gdb_6_0-2003-06-23-branchpoint:1.22
	jimb-ppc64-linux-20030613-branch:1.21.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.21
	cagney_convert-20030606-branch:1.21.0.26
	cagney_convert-20030606-branchpoint:1.21
	cagney_writestrings-20030508-branch:1.21.0.24
	cagney_writestrings-20030508-branchpoint:1.21
	jimb-ppc64-linux-20030528-branch:1.21.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.21
	carlton_dictionary-20030523-merge:1.21
	cagney_fileio-20030521-branch:1.21.0.20
	cagney_fileio-20030521-branchpoint:1.21
	kettenis_i386newframe-20030517-mergepoint:1.21
	jimb-ppc64-linux-20030509-branch:1.21.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.21
	kettenis_i386newframe-20030504-mergepoint:1.21
	carlton_dictionary-20030430-merge:1.21
	kettenis_i386newframe-20030419-branch:1.21.0.16
	kettenis_i386newframe-20030419-branchpoint:1.21
	carlton_dictionary-20030416-merge:1.21
	cagney_frameaddr-20030409-mergepoint:1.21
	kettenis_i386newframe-20030406-branch:1.21.0.14
	kettenis_i386newframe-20030406-branchpoint:1.21
	cagney_frameaddr-20030403-branchpoint:1.21
	cagney_frameaddr-20030403-branch:1.21.0.12
	cagney_framebase-20030330-mergepoint:1.21
	cagney_framebase-20030326-branch:1.21.0.10
	cagney_framebase-20030326-branchpoint:1.21
	cagney_lazyid-20030317-branch:1.21.0.8
	cagney_lazyid-20030317-branchpoint:1.21
	kettenis-i386newframe-20030316-mergepoint:1.21
	offbyone-20030313-branch:1.21.0.6
	offbyone-20030313-branchpoint:1.21
	kettenis-i386newframe-20030308-branch:1.21.0.4
	kettenis-i386newframe-20030308-branchpoint:1.21
	carlton_dictionary-20030305-merge:1.21
	cagney_offbyone-20030303-branch:1.21.0.2
	cagney_offbyone-20030303-branchpoint:1.21
	carlton_dictionary-20030207-merge:1.20
	interps-20030203-mergepoint:1.20
	interps-20030202-branch:1.20.0.4
	interps-20030202-branchpoint:1.20
	cagney-unwind-20030108-branch:1.20.0.2
	cagney-unwind-20030108-branchpoint:1.20
	carlton_dictionary-20021223-merge:1.20
	gdb_5_3-2002-12-12-release:1.15.2.5
	carlton_dictionary-20021115-merge:1.20
	kseitz_interps-20021105-merge:1.20
	kseitz_interps-20021103-merge:1.20
	drow-cplus-merge-20021020:1.18
	drow-cplus-merge-20021025:1.18
	carlton_dictionary-20021025-merge:1.18
	carlton_dictionary-20021011-merge:1.18
	drow-cplus-branch:1.18.0.4
	drow-cplus-branchpoint:1.18
	kseitz_interps-20020930-merge:1.18
	carlton_dictionary-20020927-merge:1.18
	carlton_dictionary-branch:1.18.0.2
	carlton_dictionary-20020920-branchpoint:1.18
	gdb_5_3-branch:1.15.0.2
	gdb_5_3-2002-09-04-branchpoint:1.15
	kseitz_interps-20020829-merge:1.13
	cagney_sysregs-20020825-branch:1.12.0.12
	cagney_sysregs-20020825-branchpoint:1.12
	readline_4_3-import-branch:1.12.0.10
	readline_4_3-import-branchpoint:1.12
	gdb_5_2_1-2002-07-23-release:1.12
	kseitz_interps-20020528-branch:1.12.0.8
	kseitz_interps-20020528-branchpoint:1.12
	cagney_regbuf-20020515-branch:1.12.0.6
	cagney_regbuf-20020515-branchpoint:1.12
	jimb-macro-020506-branch:1.12.0.4
	jimb-macro-020506-branchpoint:1.12
	gdb_5_2-2002-04-29-release:1.12
	gdb_5_2-branch:1.12.0.2
	gdb_5_2-2002-03-03-branchpoint:1.12
	gdb_5_1_1-2002-01-24-release:1.10
	gdb_5_1_0_1-2002-01-03-release:1.10
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.10.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.10
	gdb_5_1-2001-11-21-release:1.10
	gdb_s390-2001-09-26-branch:1.10.0.4
	gdb_s390-2001-09-26-branchpoint:1.10
	gdb_5_1-2001-07-29-branch:1.10.0.2
	gdb_5_1-2001-07-29-branchpoint:1.10
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	gdb-post-ptid_t-2001-05-03:1.4
	gdb-pre-ptid_t-2001-05-03:1.4
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.23
date	2004.01.19.04.31.52;	author cagney;	state dead;
branches;
next	1.22;

1.22
date	2003.06.22.15.21.38;	author drow;	state Exp;
branches
	1.22.6.1;
next	1.21;

1.21
date	2003.02.12.15.14.36;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.26.10.38.57;	author ciceron;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.25.19.24.01;	author ciceron;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.13.20.06.56;	author ciceron;	state Exp;
branches
	1.18.2.1
	1.18.4.1;
next	1.17;

1.17
date	2002.09.13.19.47.21;	author ciceron;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.10.19.59.31;	author ciceron;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.03.20.47.48;	author ciceron;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.08.31.12.02.14;	author ciceron;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.27.20.58.27;	author ciceron;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.01.06.19.28;	author cagney;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	2002.02.08.15.54.32;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.23.21.16.20;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.21.22.35.40;	author ciceron;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.21.19.56.54;	author ciceron;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.18.22.03.22;	author ciceron;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.14.19.31.09;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.14.19.01.25;	author ciceron;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.18.00.23.24;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.04.00.41.10;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.42;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.19.21;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.02.00.21.19;	author jsm;	state Exp;
branches;
next	;

1.12.8.1
date	2002.08.30.22.52.52;	author kseitz;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2002.10.01.00.46.35;	author kseitz;	state Exp;
branches;
next	1.12.8.3;

1.12.8.3
date	2002.11.03.22.07.42;	author ezannoni;	state Exp;
branches;
next	;

1.15.2.1
date	2002.09.10.20.00.55;	author ciceron;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.09.13.19.48.13;	author ciceron;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.09.13.20.08.29;	author ciceron;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2002.10.25.19.24.29;	author ciceron;	state Exp;
branches;
next	1.15.2.5;

1.15.2.5
date	2002.10.26.10.40.03;	author ciceron;	state Exp;
branches;
next	;

1.18.2.1
date	2002.11.15.19.19.20;	author carlton;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2003.03.06.00.56.37;	author carlton;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2003.06.27.21.50.21;	author carlton;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2004.01.26.19.11.45;	author carlton;	state dead;
branches;
next	;

1.18.4.1
date	2003.12.14.20.27.59;	author drow;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2004.02.09.19.43.58;	author drow;	state dead;
branches;
next	;

1.22.6.1
date	2004.03.23.20.09.16;	author ezannoni;	state dead;
branches;
next	;


desc
@@


1.23
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@/* TUI support I/O functions.

   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "terminal.h"
#include "target.h"
#include "event-loop.h"
#include "event-top.h"
#include "command.h"
#include "top.h"
#include "readline/readline.h"
#include "tui.h"
#include "tuiData.h"
#include "tuiIO.h"
#include "tuiCommand.h"
#include "tuiWin.h"
#include "tuiGeneralWin.h"
#include "tui-file.h"
#include "ui-out.h"
#include "cli-out.h"
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

/* Use definition from readline 4.3.  */
#undef CTRL_CHAR
#define CTRL_CHAR(c) ((c) < control_character_threshold && (((c) & 0x80) == 0))

/* This file controls the IO interactions between gdb and curses.
   When the TUI is enabled, gdb has two modes a curses and a standard
   mode.

   In curses mode, the gdb outputs are made in a curses command window.
   For this, the gdb_stdout and gdb_stderr are redirected to the specific
   ui_file implemented by TUI.  The output is handled by tui_puts().
   The input is also controlled by curses with tui_getc().  The readline
   library uses this function to get its input.  Several readline hooks
   are installed to redirect readline output to the TUI (see also the
   note below).

   In normal mode, the gdb outputs are restored to their origin, that
   is as if TUI is not used.  Readline also uses its original getc()
   function with stdin.

   Note SCz/2001-07-21: the current readline is not clean in its management of
   the output.  Even if we install a redisplay handler, it sometimes writes on
   a stdout file.  It is important to redirect every output produced by
   readline, otherwise the curses window will be garbled.  This is implemented
   with a pipe that TUI reads and readline writes to.  A gdb input handler
   is created so that reading the pipe is handled automatically.
   This will probably not work on non-Unix platforms.  The best fix is
   to make readline clean enougth so that is never write on stdout.

   Note SCz/2002-09-01: we now use more readline hooks and it seems that
   with them we don't need the pipe anymore (verified by creating the pipe
   and closing its end so that write causes a SIGPIPE).  The old pipe code
   is still there and can be conditionally removed by
   #undef TUI_USE_PIPE_FOR_READLINE.  */

/* For gdb 5.3, prefer to continue the pipe hack as a backup wheel.  */
#define TUI_USE_PIPE_FOR_READLINE
/*#undef TUI_USE_PIPE_FOR_READLINE*/

/* TUI output files.  */
static struct ui_file *tui_stdout;
static struct ui_file *tui_stderr;
struct ui_out *tui_out;

/* GDB output files in non-curses mode.  */
static struct ui_file *tui_old_stdout;
static struct ui_file *tui_old_stderr;
struct ui_out *tui_old_uiout;

/* Readline previous hooks.  */
static Function *tui_old_rl_getc_function;
static VFunction *tui_old_rl_redisplay_function;
static VFunction *tui_old_rl_prep_terminal;
static VFunction *tui_old_rl_deprep_terminal;
static int tui_old_readline_echoing_p;

/* Readline output stream.
   Should be removed when readline is clean.  */
static FILE *tui_rl_outstream;
static FILE *tui_old_rl_outstream;
#ifdef TUI_USE_PIPE_FOR_READLINE
static int tui_readline_pipe[2];
#endif

/* The last gdb prompt that was registered in readline.
   This may be the main gdb prompt or a secondary prompt.  */
static char *tui_rl_saved_prompt;

static unsigned int _tuiHandleResizeDuringIO (unsigned int);

static void
tui_putc (char c)
{
  char buf[2];

  buf[0] = c;
  buf[1] = 0;
  tui_puts (buf);
}

/* Print the string in the curses command window.  */
void
tui_puts (const char *string)
{
  static int tui_skip_line = -1;
  char c;
  WINDOW *w;

  w = cmdWin->generic.handle;
  while ((c = *string++) != 0)
    {
      /* Catch annotation and discard them.  We need two \032 and
         discard until a \n is seen.  */
      if (c == '\032')
        {
          tui_skip_line++;
        }
      else if (tui_skip_line != 1)
        {
          tui_skip_line = -1;
          waddch (w, c);
        }
      else if (c == '\n')
        tui_skip_line = -1;
    }
  getyx (w, cmdWin->detail.commandInfo.curLine,
         cmdWin->detail.commandInfo.curch);
  cmdWin->detail.commandInfo.start_line = cmdWin->detail.commandInfo.curLine;

  /* We could defer the following.  */
  wrefresh (w);
  fflush (stdout);
}

/* Readline callback.
   Redisplay the command line with its prompt after readline has
   changed the edited text.  */
void
tui_redisplay_readline (void)
{
  int prev_col;
  int height;
  int col, line;
  int c_pos;
  int c_line;
  int in;
  WINDOW *w;
  char *prompt;
  int start_line;

  /* Detect when we temporarily left SingleKey and now the readline
     edit buffer is empty, automatically restore the SingleKey mode.  */
  if (tui_current_key_mode == tui_one_command_mode && rl_end == 0)
    tui_set_key_mode (tui_single_key_mode);

  if (tui_current_key_mode == tui_single_key_mode)
    prompt = "";
  else
    prompt = tui_rl_saved_prompt;
  
  c_pos = -1;
  c_line = -1;
  w = cmdWin->generic.handle;
  start_line = cmdWin->detail.commandInfo.start_line;
  wmove (w, start_line, 0);
  prev_col = 0;
  height = 1;
  for (in = 0; prompt && prompt[in]; in++)
    {
      waddch (w, prompt[in]);
      getyx (w, line, col);
      if (col < prev_col)
        height++;
      prev_col = col;
    }
  for (in = 0; in < rl_end; in++)
    {
      unsigned char c;
      
      c = (unsigned char) rl_line_buffer[in];
      if (in == rl_point)
	{
          getyx (w, c_line, c_pos);
	}

      if (CTRL_CHAR (c) || c == RUBOUT)
	{
          waddch (w, '^');
          waddch (w, CTRL_CHAR (c) ? UNCTRL (c) : '?');
	}
      else
	{
          waddch (w, c);
	}
      if (c == '\n')
        {
          getyx (w, cmdWin->detail.commandInfo.start_line,
                 cmdWin->detail.commandInfo.curch);
        }
      getyx (w, line, col);
      if (col < prev_col)
        height++;
      prev_col = col;
    }
  wclrtobot (w);
  getyx (w, cmdWin->detail.commandInfo.start_line,
         cmdWin->detail.commandInfo.curch);
  if (c_line >= 0)
    {
      wmove (w, c_line, c_pos);
      cmdWin->detail.commandInfo.curLine = c_line;
      cmdWin->detail.commandInfo.curch = c_pos;
    }
  cmdWin->detail.commandInfo.start_line -= height - 1;

  wrefresh (w);
  fflush(stdout);
}

/* Readline callback to prepare the terminal.  It is called once
   each time we enter readline.  Terminal is already setup in curses mode.  */
static void
tui_prep_terminal (int notused1)
{
  /* Save the prompt registered in readline to correctly display it.
     (we can't use gdb_prompt() due to secondary prompts and can't use
     rl_prompt because it points to an alloca buffer).  */
  xfree (tui_rl_saved_prompt);
  tui_rl_saved_prompt = xstrdup (rl_prompt);
}

/* Readline callback to restore the terminal.  It is called once
   each time we leave readline.  There is nothing to do in curses mode.  */
static void
tui_deprep_terminal (void)
{
}

#ifdef TUI_USE_PIPE_FOR_READLINE
/* Read readline output pipe and feed the command window with it.
   Should be removed when readline is clean.  */
static void
tui_readline_output (int code, gdb_client_data data)
{
  int size;
  char buf[256];

  size = read (tui_readline_pipe[0], buf, sizeof (buf) - 1);
  if (size > 0 && tui_active)
    {
      buf[size] = 0;
      tui_puts (buf);
    }
}
#endif

/* Return the portion of PATHNAME that should be output when listing
   possible completions.  If we are hacking filename completion, we
   are only interested in the basename, the portion following the
   final slash.  Otherwise, we return what we were passed.

   Comes from readline/complete.c  */
static char *
printable_part (pathname)
     char *pathname;
{
  char *temp;

  temp = rl_filename_completion_desired ? strrchr (pathname, '/') : (char *)NULL;
#if defined (__MSDOS__)
  if (rl_filename_completion_desired && temp == 0 && isalpha (pathname[0]) && pathname[1] == ':')
    temp = pathname + 1;
#endif
  return (temp ? ++temp : pathname);
}

/* Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we
   are using it, check for and output a single character for `special'
   filenames.  Return the number of characters we output. */

#define PUTX(c) \
    do { \
      if (CTRL_CHAR (c)) \
        { \
          tui_puts ("^"); \
          tui_putc (UNCTRL (c)); \
          printed_len += 2; \
        } \
      else if (c == RUBOUT) \
	{ \
	  tui_puts ("^?"); \
	  printed_len += 2; \
	} \
      else \
	{ \
	  tui_putc (c); \
	  printed_len++; \
	} \
    } while (0)

static int
print_filename (to_print, full_pathname)
     char *to_print, *full_pathname;
{
  int printed_len = 0;
  char *s;

  for (s = to_print; *s; s++)
    {
      PUTX (*s);
    }
  return printed_len;
}

/* The user must press "y" or "n".  Non-zero return means "y" pressed.
   Comes from readline/complete.c  */
static int
get_y_or_n ()
{
  extern int _rl_abort_internal ();
  int c;

  for (;;)
    {
      c = rl_read_key ();
      if (c == 'y' || c == 'Y' || c == ' ')
	return (1);
      if (c == 'n' || c == 'N' || c == RUBOUT)
	return (0);
      if (c == ABORT_CHAR)
	_rl_abort_internal ();
      beep ();
    }
}

/* A convenience function for displaying a list of strings in
   columnar format on readline's output stream.  MATCHES is the list
   of strings, in argv format, LEN is the number of strings in MATCHES,
   and MAX is the length of the longest string in MATCHES.

   Comes from readline/complete.c and modified to write in
   the TUI command window using tui_putc/tui_puts.  */
static void
tui_rl_display_match_list (matches, len, max)
     char **matches;
     int len, max;
{
  typedef int QSFUNC (const void *, const void *);
  extern int _rl_qsort_string_compare (const void*, const void*);
  extern int _rl_print_completions_horizontally;
  
  int count, limit, printed_len;
  int i, j, k, l;
  char *temp;

  /* Screen dimension correspond to the TUI command window.  */
  int screenwidth = cmdWin->generic.width;

  /* If there are many items, then ask the user if she really wants to
     see them all. */
  if (len >= rl_completion_query_items)
    {
      char msg[256];

      sprintf (msg, "\nDisplay all %d possibilities? (y or n)", len);
      tui_puts (msg);
      if (get_y_or_n () == 0)
	{
	  tui_puts ("\n");
	  return;
	}
    }

  /* How many items of MAX length can we fit in the screen window? */
  max += 2;
  limit = screenwidth / max;
  if (limit != 1 && (limit * max == screenwidth))
    limit--;

  /* Avoid a possible floating exception.  If max > screenwidth,
     limit will be 0 and a divide-by-zero fault will result. */
  if (limit == 0)
    limit = 1;

  /* How many iterations of the printing loop? */
  count = (len + (limit - 1)) / limit;

  /* Watch out for special case.  If LEN is less than LIMIT, then
     just do the inner printing loop.
	   0 < len <= limit  implies  count = 1. */

  /* Sort the items if they are not already sorted. */
  if (rl_ignore_completion_duplicates == 0)
    qsort (matches + 1, len, sizeof (char *),
           (QSFUNC *)_rl_qsort_string_compare);

  tui_putc ('\n');

  if (_rl_print_completions_horizontally == 0)
    {
      /* Print the sorted items, up-and-down alphabetically, like ls. */
      for (i = 1; i <= count; i++)
	{
	  for (j = 0, l = i; j < limit; j++)
	    {
	      if (l > len || matches[l] == 0)
		break;
	      else
		{
		  temp = printable_part (matches[l]);
		  printed_len = print_filename (temp, matches[l]);

		  if (j + 1 < limit)
		    for (k = 0; k < max - printed_len; k++)
		      tui_putc (' ');
		}
	      l += count;
	    }
	  tui_putc ('\n');
	}
    }
  else
    {
      /* Print the sorted items, across alphabetically, like ls -x. */
      for (i = 1; matches[i]; i++)
	{
	  temp = printable_part (matches[i]);
	  printed_len = print_filename (temp, matches[i]);
	  /* Have we reached the end of this line? */
	  if (matches[i+1])
	    {
	      if (i && (limit > 1) && (i % limit) == 0)
		tui_putc ('\n');
	      else
		for (k = 0; k < max - printed_len; k++)
		  tui_putc (' ');
	    }
	}
      tui_putc ('\n');
    }
}

/* Setup the IO for curses or non-curses mode.
   - In non-curses mode, readline and gdb use the standard input and
   standard output/error directly.
   - In curses mode, the standard output/error is controlled by TUI
   with the tui_stdout and tui_stderr.  The output is redirected in
   the curses command window.  Several readline callbacks are installed
   so that readline asks for its input to the curses command window
   with wgetch().  */
void
tui_setup_io (int mode)
{
  extern int readline_echoing_p;
 
  if (mode)
    {
      /* Redirect readline to TUI.  */
      tui_old_rl_redisplay_function = rl_redisplay_function;
      tui_old_rl_deprep_terminal = rl_deprep_term_function;
      tui_old_rl_prep_terminal = rl_prep_term_function;
      tui_old_rl_getc_function = rl_getc_function;
      tui_old_rl_outstream = rl_outstream;
      tui_old_readline_echoing_p = readline_echoing_p;
      rl_redisplay_function = tui_redisplay_readline;
      rl_deprep_term_function = tui_deprep_terminal;
      rl_prep_term_function = tui_prep_terminal;
      rl_getc_function = tui_getc;
      readline_echoing_p = 0;
      rl_outstream = tui_rl_outstream;
      rl_prompt = 0;
      rl_completion_display_matches_hook = tui_rl_display_match_list;
      rl_already_prompted = 0;

      /* Keep track of previous gdb output.  */
      tui_old_stdout = gdb_stdout;
      tui_old_stderr = gdb_stderr;
      tui_old_uiout = uiout;

      /* Reconfigure gdb output.  */
      gdb_stdout = tui_stdout;
      gdb_stderr = tui_stderr;
      gdb_stdlog = gdb_stdout;	/* for moment */
      gdb_stdtarg = gdb_stderr;	/* for moment */
      uiout = tui_out;

      /* Save tty for SIGCONT.  */
      savetty ();
    }
  else
    {
      /* Restore gdb output.  */
      gdb_stdout = tui_old_stdout;
      gdb_stderr = tui_old_stderr;
      gdb_stdlog = gdb_stdout;	/* for moment */
      gdb_stdtarg = gdb_stderr;	/* for moment */
      uiout = tui_old_uiout;

      /* Restore readline.  */
      rl_redisplay_function = tui_old_rl_redisplay_function;
      rl_deprep_term_function = tui_old_rl_deprep_terminal;
      rl_prep_term_function = tui_old_rl_prep_terminal;
      rl_getc_function = tui_old_rl_getc_function;
      rl_outstream = tui_old_rl_outstream;
      rl_completion_display_matches_hook = 0;
      readline_echoing_p = tui_old_readline_echoing_p;
      rl_already_prompted = 0;

      /* Save tty for SIGCONT.  */
      savetty ();
    }
}

#ifdef SIGCONT
/* Catch SIGCONT to restore the terminal and refresh the screen.  */
static void
tui_cont_sig (int sig)
{
  if (tui_active)
    {
      /* Restore the terminal setting because another process (shell)
         might have changed it.  */
      resetty ();

      /* Force a refresh of the screen.  */
      tuiRefreshAll ();

      /* Update cursor position on the screen.  */
      wmove (cmdWin->generic.handle,
             cmdWin->detail.commandInfo.start_line,
             cmdWin->detail.commandInfo.curch);
      wrefresh (cmdWin->generic.handle);
    }
  signal (sig, tui_cont_sig);
}
#endif

/* Initialize the IO for gdb in curses mode.  */
void
tui_initialize_io ()
{
#ifdef SIGCONT
  signal (SIGCONT, tui_cont_sig);
#endif

  /* Create tui output streams.  */
  tui_stdout = tui_fileopen (stdout);
  tui_stderr = tui_fileopen (stderr);
  tui_out = tui_out_new (tui_stdout);

  /* Create the default UI.  It is not created because we installed
     a init_ui_hook.  */
  tui_old_uiout = uiout = cli_out_new (gdb_stdout);

#ifdef TUI_USE_PIPE_FOR_READLINE
  /* Temporary solution for readline writing to stdout:
     redirect readline output in a pipe, read that pipe and
     output the content in the curses command window.  */
  if (pipe (tui_readline_pipe) != 0)
    {
      fprintf_unfiltered (gdb_stderr, "Cannot create pipe for readline");
      exit (1);
    }
  tui_rl_outstream = fdopen (tui_readline_pipe[1], "w");
  if (tui_rl_outstream == 0)
    {
      fprintf_unfiltered (gdb_stderr, "Cannot redirect readline output");
      exit (1);
    }
  setvbuf (tui_rl_outstream, (char*) NULL, _IOLBF, 0);

#ifdef O_NONBLOCK
  (void) fcntl (tui_readline_pipe[0], F_SETFL, O_NONBLOCK);
#else
#ifdef O_NDELAY
  (void) fcntl (tui_readline_pipe[0], F_SETFL, O_NDELAY);
#endif
#endif
  add_file_handler (tui_readline_pipe[0], tui_readline_output, 0);
#else
  tui_rl_outstream = stdout;
#endif
}

/* Get a character from the command window.  This is called from the readline
   package.  */
int
tui_getc (FILE *fp)
{
  int ch;
  WINDOW *w;

  w = cmdWin->generic.handle;

#ifdef TUI_USE_PIPE_FOR_READLINE
  /* Flush readline output.  */
  tui_readline_output (GDB_READABLE, 0);
#endif

  ch = wgetch (w);
  ch = _tuiHandleResizeDuringIO (ch);

  /* The \n must be echoed because it will not be printed by readline.  */
  if (ch == '\n')
    {
      /* When hitting return with an empty input, gdb executes the last
         command.  If we emit a newline, this fills up the command window
         with empty lines with gdb prompt at beginning.  Instead of that,
         stay on the same line but provide a visual effect to show the
         user we recognized the command.  */
      if (rl_end == 0)
        {
          wmove (w, cmdWin->detail.commandInfo.curLine, 0);

          /* Clear the line.  This will blink the gdb prompt since
             it will be redrawn at the same line.  */
          wclrtoeol (w);
          wrefresh (w);
          napms (20);
        }
      else
        {
          wmove (w, cmdWin->detail.commandInfo.curLine,
                 cmdWin->detail.commandInfo.curch);
          waddch (w, ch);
        }
    }
  
  if (m_isCommandChar (ch))
    {				/* Handle prev/next/up/down here */
      ch = tuiDispatchCtrlChar (ch);
    }
  
  if (ch == '\n' || ch == '\r' || ch == '\f')
    cmdWin->detail.commandInfo.curch = 0;
#if 0
  else
    tuiIncrCommandCharCountBy (1);
#endif
  if (ch == KEY_BACKSPACE)
    return '\b';
  
  return ch;
}


/* Cleanup when a resize has occured.
   Returns the character that must be processed.  */
static unsigned int
_tuiHandleResizeDuringIO (unsigned int originalCh)
{
  if (tuiWinResized ())
    {
      tuiRefreshAll ();
      dont_repeat ();
      tuiSetWinResizedTo (FALSE);
      return '\n';
    }
  else
    return originalCh;
}
@


1.22
log
@	* tui-hooks.c: Update include order.
	* tui.c: Likewise.
	* tuiCommand.c: Likewise.
	* tuiData.c: Likewise.
	* tuiDataWin.c: Likewise.
	* tuiDisassem.c: Likewise.
	* tuiGeneralWin.c: Likewise.
	* tuiIO.c: Likewise.
	* tuiLayout.c: Likewise.
	* tuiRegs.c: Likewise.
	* tuiSource.c: Likewise.
	* tuiSourceWin.c: Likewise.
	* tuiStack.c: Likewise.
	* tuiWin.c: Likewise.
@
text
@@


1.22.6.1
log
@merge mainline changes to branch
@
text
@@


1.21
log
@2003-02-12  Andrew Cagney  <ac131313@@redhat.com>

	* tuiIO.c (tui_prep_terminal): Add one notused parameter.
	* tui.c (tui_rl_switch_mode): Add two notused parameters.
	(tui_rl_change_windows, tui_rl_next_keymap): Ditto.
	(tui_rl_delete_other_windows): Ditto.
	(tui_rl_change_windows, tui_rl_delete_other_windows): Update
	calls.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation,
a24 18
/* FIXME: cagney/2002-02-28: The GDB coding standard indicates that
   "defs.h" should be included first.  Unfortunatly some systems
   (currently Debian GNU/Linux) include the <stdbool.h> via <curses.h>
   and they clash with "bfd.h"'s definiton of true/false.  The correct
   fix is to remove true/false from "bfd.h", however, until that
   happens, hack around it by including "config.h" and <curses.h>
   first.  */

#include "config.h"
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

#include <stdio.h>
d44 9
@


1.20
log
@	* tuiIO.c (tui_prep_terminal): Save the prompt registered in readline.
	(tui_redisplay_readline): Use the last saved prompt.
	(tui_rl_saved_prompt): New.
@
text
@d265 1
a265 1
tui_prep_terminal (void)
@


1.19
log
@	Fix PR gdb/478
	* tuiIO.c (tui_initialize_io): Use setvbuf since this is portable.
@
text
@d127 4
d201 1
a201 1
    prompt = get_prompt ();
d263 1
a263 1
   each time we enter readline.  There is nothing to do in curses mode.  */
d267 5
@


1.18
log
@	* tui.c (tui_rl_switch_mode): Remove unecessary TUI switch printfs.
	(tui_initialize_readline): Allow to use space to leave SingleKey
	to enter one gdb command.
	(tui_enable): Restore the TUI keymap when we are back to TUI.
	(tui_disable): Restore normal keymap when leaving TUI.
	* tuiIO.c (tui_redisplay_readline): Restore the SingleKey mode
	when the buffer becomes empty and we are in tui_one_command_mode.
@
text
@d603 1
a603 1
  setlinebuf (tui_rl_outstream);
@


1.18.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 18
a61 9
#include <stdio.h>

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
a126 4
/* The last gdb prompt that was registered in readline.
   This may be the main gdb prompt or a secondary prompt.  */
static char *tui_rl_saved_prompt;

d197 1
a197 1
    prompt = tui_rl_saved_prompt;
d259 1
a259 1
   each time we enter readline.  Terminal is already setup in curses mode.  */
d261 1
a261 1
tui_prep_terminal (int notused1)
a262 5
  /* Save the prompt registered in readline to correctly display it.
     (we can't use gdb_prompt() due to secondary prompts and can't use
     rl_prompt because it points to an alloca buffer).  */
  xfree (tui_rl_saved_prompt);
  tui_rl_saved_prompt = xstrdup (rl_prompt);
d603 1
a603 1
  setvbuf (tui_rl_outstream, (char*) NULL, _IOLBF, 0);
@


1.18.4.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@@


1.18.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a126 4
/* The last gdb prompt that was registered in readline.
   This may be the main gdb prompt or a secondary prompt.  */
static char *tui_rl_saved_prompt;

d197 1
a197 1
    prompt = tui_rl_saved_prompt;
d259 1
a259 1
   each time we enter readline.  Terminal is already setup in curses mode.  */
a262 5
  /* Save the prompt registered in readline to correctly display it.
     (we can't use gdb_prompt() due to secondary prompts and can't use
     rl_prompt because it points to an alloca buffer).  */
  xfree (tui_rl_saved_prompt);
  tui_rl_saved_prompt = xstrdup (rl_prompt);
d603 1
a603 1
  setvbuf (tui_rl_outstream, (char*) NULL, _IOLBF, 0);
@


1.18.2.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d265 1
a265 1
tui_prep_terminal (int notused1)
@


1.18.2.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 18
a61 9
#include <stdio.h>

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
@


1.18.2.4
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.17
log
@	* tuiIO.c (tui_setup_io): rl_already_prompted must be cleared
	when leaving TUI mode so that gdb prompt is displayed.
@
text
@d188 6
a193 1
  
@


1.16
log
@	* tui-hooks.c (tui_event_loop): New function.
	(tui_command_loop): New function to override gdb loop and make sure
	uiout is set according to TUI mode.
	(tui_command_loop): Install the specific TUI command hook.
	* tuiIO.c (tui_initialize_io): Initialize tui_old_uiout.
	(tui_uiout, tui_old_uiout): Make public.
	* tuiIO.h (tui_uiout, tui_old_uiout): Declare.
@
text
@d535 1
a535 1
      rl_already_prompted = 1;
@


1.15
log
@	* tuiIO.c (tui_putc): New function to print one character.
	(printable_part): New function from readline/complete.c.
	(PUTX): New macro, likewise.
	(print_filename): New function, likewise.
	(get_y_or_n): New function, likewise and adapted for TUI.
	(tui_rl_display_match_list): New function from readline/complete.c
	and writes on TUI command window.
	(tui_setup_io): Install or remove the readline hook
	rl_completion_display_matches_hook so that completion is written
	directly in TUI command window instead of in the TUI pipe.
	(tui_initialize_io): Use #ifdef TUI_USE_PIPE_FOR_READLINE for the
	TUI redirection pipe.
	(tui_getc): Likewise for call to tui_readline_output.
	(tui_readline_output): Likewise for function.
	* tui.c (tui_rl_startup_hook): Always take care of gdb prompt.
@
text
@d105 1
a105 1
static struct ui_out *tui_out;
d110 1
a110 1
static struct ui_out *tui_old_uiout;
d581 1
a581 1
  uiout = cli_out_new (gdb_stdout);
@


1.15.2.1
log
@	* tui-hooks.c (tui_event_loop): New function.
	(tui_command_loop): New function to override gdb loop and make sure
	uiout is set according to TUI mode.
	(tui_command_loop): Install the specific TUI command hook.
	* tuiIO.c (tui_initialize_io): Initialize tui_old_uiout.
	(tui_uiout, tui_old_uiout): Make public.
	* tuiIO.h (tui_uiout, tui_old_uiout): Declare.
@
text
@d105 1
a105 1
struct ui_out *tui_out;
d110 1
a110 1
struct ui_out *tui_old_uiout;
d581 1
a581 1
  tui_old_uiout = uiout = cli_out_new (gdb_stdout);
@


1.15.2.2
log
@	* tuiIO.c (tui_setup_io): rl_already_prompted must be cleared
	when leaving TUI mode so that gdb prompt is displayed.
@
text
@d535 1
a535 1
      rl_already_prompted = 0;
@


1.15.2.3
log
@	* tui.c (tui_rl_switch_mode): Remove unecessary TUI switch printfs.
	(tui_initialize_readline): Allow to use space to leave SingleKey
	to enter one gdb command.
	(tui_enable): Restore the TUI keymap when we are back to TUI.
	(tui_disable): Restore normal keymap when leaving TUI.
	* tuiIO.c (tui_redisplay_readline): Restore the SingleKey mode
	when the buffer becomes empty and we are in tui_one_command_mode.
@
text
@d188 1
a188 6

  /* Detect when we temporarily left SingleKey and now the readline
     edit buffer is empty, automatically restore the SingleKey mode.  */
  if (tui_current_key_mode == tui_one_command_mode && rl_end == 0)
    tui_set_key_mode (tui_single_key_mode);

@


1.15.2.4
log
@	Fix PR gdb/478
	* tuiIO.c (tui_initialize_io): Use setvbuf since this is portable.
@
text
@d603 1
a603 1
  setvbuf (tui_rl_outstream, (char*) NULL, _IOLBF, 0);
@


1.15.2.5
log
@	* tuiIO.c (tui_prep_terminal): Save the prompt registered in readline.
	(tui_redisplay_readline): Use the last saved prompt.
	(tui_rl_saved_prompt): New.
@
text
@a126 4
/* The last gdb prompt that was registered in readline.
   This may be the main gdb prompt or a secondary prompt.  */
static char *tui_rl_saved_prompt;

d197 1
a197 1
    prompt = tui_rl_saved_prompt;
d259 1
a259 1
   each time we enter readline.  Terminal is already setup in curses mode.  */
a262 5
  /* Save the prompt registered in readline to correctly display it.
     (we can't use gdb_prompt() due to secondary prompts and can't use
     rl_prompt because it points to an alloca buffer).  */
  xfree (tui_rl_saved_prompt);
  tui_rl_saved_prompt = xstrdup (rl_prompt);
@


1.14
log
@2002-08-31  Stephane Carrez  <stcarrez@@nerim.fr>

	* tui.c (tui_commands): Table of single key commands.
	(tui_rl_command_key): New function to execute gdb command.
	(tui_rl_command_mode): New function to temporarily leave SingleKey.
	(tui_rl_next_keymap): New function to enter/leave the SingleKey mode.
	(tui_rl_startup_hook): New function to avoid prompt display by
	readline functions.
	(tui_set_key_mode): New function to set the key mode and install
	the readline keymap.
	(tui_initialize_readline): Create TUI SingleKey readline map.
	(tui_enable): Install rl_startup_hook.
	(tui_disable): Remove it.
	* tui.h (enum tui_key_mode): Declare.
	(tui_set_key_mode, tui_current_key_mode): Declare.
	* tuiIO.c (tui_redisplay_readline): Don't display the prompt in
	SingleKey mode.
	* tuiIO.h (tui_redisplay_readline): Declare.
@
text
@d83 5
a87 5
   Note: the current readline is not clean in its management of the output.
   Even if we install a redisplay handler, it sometimes writes on a stdout
   file.  It is important to redirect every output produced by readline,
   otherwise the curses window will be garbled.  This is implemented with
   a pipe that TUI reads and readline writes to.  A gdb input handler
d90 11
a100 1
   to make readline clean enougth so that is never write on stdout.  */
d123 1
d125 1
d129 9
d267 1
d283 187
d500 2
d533 1
d535 1
d583 1
a606 1

d608 3
d623 1
d626 2
a627 1
  
@


1.13
log
@	* tuiIO.c (CTRL_CHAR): Redefine and use readline 4.3 definition.
@
text
@d47 1
d155 1
a155 1
static void
d168 4
a171 1
  prompt = get_prompt ();
@


1.12
log
@Add FIXME explaining include problem.
@
text
@d62 4
@


1.12.8.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a61 4
/* Use definition from readline 4.3.  */
#undef CTRL_CHAR
#define CTRL_CHAR(c) ((c) < control_character_threshold && (((c) & 0x80) == 0))

@


1.12.8.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a46 1
#include "event-top.h"
d82 5
a86 5
   Note SCz/2001-07-21: the current readline is not clean in its management of
   the output.  Even if we install a redisplay handler, it sometimes writes on
   a stdout file.  It is important to redirect every output produced by
   readline, otherwise the curses window will be garbled.  This is implemented
   with a pipe that TUI reads and readline writes to.  A gdb input handler
d89 1
a89 11
   to make readline clean enougth so that is never write on stdout.

   Note SCz/2002-09-01: we now use more readline hooks and it seems that
   with them we don't need the pipe anymore (verified by creating the pipe
   and closing its end so that write causes a SIGPIPE).  The old pipe code
   is still there and can be conditionally removed by
   #undef TUI_USE_PIPE_FOR_READLINE.  */

/* For gdb 5.3, prefer to continue the pipe hack as a backup wheel.  */
#define TUI_USE_PIPE_FOR_READLINE
/*#undef TUI_USE_PIPE_FOR_READLINE*/
d94 1
a94 1
struct ui_out *tui_out;
d99 1
a99 1
struct ui_out *tui_old_uiout;
a111 1
#ifdef TUI_USE_PIPE_FOR_READLINE
a112 1
#endif
a115 9
static void
tui_putc (char c)
{
  char buf[2];

  buf[0] = c;
  buf[1] = 0;
  tui_puts (buf);
}
d154 1
a154 1
void
d166 2
a167 10

  /* Detect when we temporarily left SingleKey and now the readline
     edit buffer is empty, automatically restore the SingleKey mode.  */
  if (tui_current_key_mode == tui_one_command_mode && rl_end == 0)
    tui_set_key_mode (tui_single_key_mode);

  if (tui_current_key_mode == tui_single_key_mode)
    prompt = "";
  else
    prompt = get_prompt ();
a241 1
#ifdef TUI_USE_PIPE_FOR_READLINE
a256 187
#endif

/* Return the portion of PATHNAME that should be output when listing
   possible completions.  If we are hacking filename completion, we
   are only interested in the basename, the portion following the
   final slash.  Otherwise, we return what we were passed.

   Comes from readline/complete.c  */
static char *
printable_part (pathname)
     char *pathname;
{
  char *temp;

  temp = rl_filename_completion_desired ? strrchr (pathname, '/') : (char *)NULL;
#if defined (__MSDOS__)
  if (rl_filename_completion_desired && temp == 0 && isalpha (pathname[0]) && pathname[1] == ':')
    temp = pathname + 1;
#endif
  return (temp ? ++temp : pathname);
}

/* Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we
   are using it, check for and output a single character for `special'
   filenames.  Return the number of characters we output. */

#define PUTX(c) \
    do { \
      if (CTRL_CHAR (c)) \
        { \
          tui_puts ("^"); \
          tui_putc (UNCTRL (c)); \
          printed_len += 2; \
        } \
      else if (c == RUBOUT) \
	{ \
	  tui_puts ("^?"); \
	  printed_len += 2; \
	} \
      else \
	{ \
	  tui_putc (c); \
	  printed_len++; \
	} \
    } while (0)

static int
print_filename (to_print, full_pathname)
     char *to_print, *full_pathname;
{
  int printed_len = 0;
  char *s;

  for (s = to_print; *s; s++)
    {
      PUTX (*s);
    }
  return printed_len;
}

/* The user must press "y" or "n".  Non-zero return means "y" pressed.
   Comes from readline/complete.c  */
static int
get_y_or_n ()
{
  extern int _rl_abort_internal ();
  int c;

  for (;;)
    {
      c = rl_read_key ();
      if (c == 'y' || c == 'Y' || c == ' ')
	return (1);
      if (c == 'n' || c == 'N' || c == RUBOUT)
	return (0);
      if (c == ABORT_CHAR)
	_rl_abort_internal ();
      beep ();
    }
}

/* A convenience function for displaying a list of strings in
   columnar format on readline's output stream.  MATCHES is the list
   of strings, in argv format, LEN is the number of strings in MATCHES,
   and MAX is the length of the longest string in MATCHES.

   Comes from readline/complete.c and modified to write in
   the TUI command window using tui_putc/tui_puts.  */
static void
tui_rl_display_match_list (matches, len, max)
     char **matches;
     int len, max;
{
  typedef int QSFUNC (const void *, const void *);
  extern int _rl_qsort_string_compare (const void*, const void*);
  extern int _rl_print_completions_horizontally;
  
  int count, limit, printed_len;
  int i, j, k, l;
  char *temp;

  /* Screen dimension correspond to the TUI command window.  */
  int screenwidth = cmdWin->generic.width;

  /* If there are many items, then ask the user if she really wants to
     see them all. */
  if (len >= rl_completion_query_items)
    {
      char msg[256];

      sprintf (msg, "\nDisplay all %d possibilities? (y or n)", len);
      tui_puts (msg);
      if (get_y_or_n () == 0)
	{
	  tui_puts ("\n");
	  return;
	}
    }

  /* How many items of MAX length can we fit in the screen window? */
  max += 2;
  limit = screenwidth / max;
  if (limit != 1 && (limit * max == screenwidth))
    limit--;

  /* Avoid a possible floating exception.  If max > screenwidth,
     limit will be 0 and a divide-by-zero fault will result. */
  if (limit == 0)
    limit = 1;

  /* How many iterations of the printing loop? */
  count = (len + (limit - 1)) / limit;

  /* Watch out for special case.  If LEN is less than LIMIT, then
     just do the inner printing loop.
	   0 < len <= limit  implies  count = 1. */

  /* Sort the items if they are not already sorted. */
  if (rl_ignore_completion_duplicates == 0)
    qsort (matches + 1, len, sizeof (char *),
           (QSFUNC *)_rl_qsort_string_compare);

  tui_putc ('\n');

  if (_rl_print_completions_horizontally == 0)
    {
      /* Print the sorted items, up-and-down alphabetically, like ls. */
      for (i = 1; i <= count; i++)
	{
	  for (j = 0, l = i; j < limit; j++)
	    {
	      if (l > len || matches[l] == 0)
		break;
	      else
		{
		  temp = printable_part (matches[l]);
		  printed_len = print_filename (temp, matches[l]);

		  if (j + 1 < limit)
		    for (k = 0; k < max - printed_len; k++)
		      tui_putc (' ');
		}
	      l += count;
	    }
	  tui_putc ('\n');
	}
    }
  else
    {
      /* Print the sorted items, across alphabetically, like ls -x. */
      for (i = 1; matches[i]; i++)
	{
	  temp = printable_part (matches[i]);
	  printed_len = print_filename (temp, matches[i]);
	  /* Have we reached the end of this line? */
	  if (matches[i+1])
	    {
	      if (i && (limit > 1) && (i % limit) == 0)
		tui_putc ('\n');
	      else
		for (k = 0; k < max - printed_len; k++)
		  tui_putc (' ');
	    }
	}
      tui_putc ('\n');
    }
}
a286 2
      rl_completion_display_matches_hook = tui_rl_display_match_list;
      rl_already_prompted = 0;
a317 1
      rl_completion_display_matches_hook = 0;
a318 1
      rl_already_prompted = 0;
d364 1
a364 1
  tui_old_uiout = uiout = cli_out_new (gdb_stdout);
a365 1
#ifdef TUI_USE_PIPE_FOR_READLINE
d389 1
a390 3
#else
  tui_rl_outstream = stdout;
#endif
a402 1
#ifdef TUI_USE_PIPE_FOR_READLINE
d405 1
a405 2
#endif

@


1.12.8.3
log
@merge from mainline
@
text
@a126 4
/* The last gdb prompt that was registered in readline.
   This may be the main gdb prompt or a secondary prompt.  */
static char *tui_rl_saved_prompt;

d197 1
a197 1
    prompt = tui_rl_saved_prompt;
d259 1
a259 1
   each time we enter readline.  Terminal is already setup in curses mode.  */
a262 5
  /* Save the prompt registered in readline to correctly display it.
     (we can't use gdb_prompt() due to secondary prompts and can't use
     rl_prompt because it points to an alloca buffer).  */
  xfree (tui_rl_saved_prompt);
  tui_rl_saved_prompt = xstrdup (rl_prompt);
d603 1
a603 1
  setvbuf (tui_rl_outstream, (char*) NULL, _IOLBF, 0);
@


1.11
log
@2002-02-08  Daniel Jacobowitz  <drow@@mvista.com>

        * utils.c: Include <curses.h> before "bfd.h".
        * tui/tui-hooks.c: Likewise.
        * tui/tui.c: Likewise.
        * tui/tuiCommand.c: Likewise.
        * tui/tuiData.c: Likewise.
        * tui/tuiDataWin.c: Likewise.
        * tui/tuiDisassem.c: Likewise.
        * tui/tuiGeneralWin.c: Likewise.
        * tui/tuiIO.c: Likewise.
        * tui/tuiLayout.c: Likewise.
        * tui/tuiRegs.c: Likewise.
        * tui/tuiSource.c: Likewise.
        * tui/tuiSourceWin.c: Likewise.
        * tui/tuiStack.c: Likewise.
        * tui/tuiWin.c: Likewise.
@
text
@d2 4
a5 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d25 8
a32 1
/* If we need <curses.h>, we must include it before we get "bfd.h".  */
@


1.10
log
@	* tuiIO.c (tui_cont_sig): Update cursor position on the screen to
	leave it in the command window.
	(tui_redisplay_readline): Save cursor position to restore the
	cursor after we go back from background.
	* tuiData.h (TuiCommandInfo): Add start_line member.
@
text
@d22 10
@


1.9
log
@	* tuiIO.c (tui_initialize_io): Install tui_cont_sig signal handler
	if SIGCONT is defined.
	(tui_cont_sig): New function when SIGCONT is defined.
	(tui_setup_io): Save tty setting to restore by SIGCONT.
@
text
@d120 1
d148 1
a148 1
  start_line = cmdWin->detail.commandInfo.curLine;
d181 1
a181 1
          getyx (w, cmdWin->detail.commandInfo.curLine,
d190 1
a190 1
  getyx (w, cmdWin->detail.commandInfo.curLine,
d193 6
a198 1
    wmove (w, c_line, c_pos);
a199 2
  cmdWin->detail.commandInfo.curLine -= height - 1;
  
d314 6
@


1.8
log
@        * tuiIO.h: Remove old declarations and add the new ones.
        * tuiIO.c: New management for curses and gdb terminal interactions.
        (tui_tputs): Remove.
        (tuiTermSetup, tuiTermUnsetup): Remove, must use normal curses ops.
        (tuiBufferGetc, tui_vStartNewLines, _updateCommandInfo): Remove.
        (tui_owns_terminal): Remove.
        (tui_redisplay_readline): New function.
        (tui_puts): New function.
        (tui_prep_terminal): New function.
        (tui_deprep_terminal): New function.
        (tui_getc): Rename of tuiGetc, simplify and fix.
        (tui_setup_io): New function.
        (tui_initialize_io): New function.
@
text
@d40 1
d271 3
d291 19
d311 1
d313 1
d319 4
@


1.7
log
@	* tuiIO.c (_tuiHandleResizeDuringIO): Call tuiRefreshAll.
	(tuiRead, tui_vread): Remove.

	* tui.c (va_catch_errors, tuiDo, tuiDoAndReturnToTop): Remove.
	(vcatch_errors, _tui_vDo): Remove.
	* tui.h (tuiDo, tuiDoAndReturnToTop): Remove.

	* tuiLayout.c (tuiSetLayout): Remove vcatch_errors.
	(tui_set_layout): Rename of _tuiSetLayoutTo, public.
	(_tuiToggleLayout_command): Merge with _tui_vToggleLayout_command.
	(_tuiToggleSplitLayout_command): Merge with _tui_vToggleSplitLayout_command.
	(_tuiLayout_command): Call tui_set_layout.

	* tuiRegs.c (_tuiScrollRegsBackward_command): Call tui_scroll.
	(_tuiScrollRegsForward_command): Likewise.
	(_tuiShowFloat_command): Call _tui_vShowRegisters_commandSupport.
	(_tuiShowGeneral_command): Likewise.
	(_tuiShowSpecial_command): Likewise.
	(_tuiToggleFloatRegs_command): Call tuiToggleFloatRegs.
	* tuiWin.c (tui_scroll): Rename of tui_vScroll, update parameters.
	(_tuiScrollForward_command): Call tui_scroll.
	(_tuiScrollBackward_command): Likewise.
	(_tuiScrollLeft_command): Likewise.
	(_tuiScrollRight_command): Likewise.
	(_tuiSetFocus_command): Call _tuiSetFocus.
	(_tuiRefreshAll_command): Call tuiRefreshAll.
	(_tuiSetWinHeight_command): Call _tuiSetWinHeight.
	(_tuiXDBsetWinHeight_command): Call _tuiXDBsetWinHeight.
	* tuiWin.h (tui_scroll): Rename of tui_vScroll, update parameters.
@
text
@d25 5
d35 53
a88 13
#include <stdarg.h>

/* The Solaris header files seem to provide no declaration for this at
   all when __STDC__ is defined.  This shouldn't conflict with
   anything.  */
extern char *tgoto ();

int insert_mode = 0;

/********************************************
**       LOCAL STATIC FORWARD DECLS        **
********************************************/
static void _updateCommandInfo (int);
d92 1
a92 13
/*********************************************************************************
**                              PUBLIC FUNCTIONS                                **
*********************************************************************************/

/*
   ** tuiPuts_unfiltered().
   **        Function to put a string to the command window
   **              When running in TUI mode, this is the "hook"
   **              for fputs_unfiltered(). That is, all debugger
   **              output eventually makes it's way to the bottom-level
   **              routine fputs_unfiltered (main.c), which (in TUI
   **              mode), calls tuiPuts_unfiltered().
 */
d94 36
a129 1
tuiPuts_unfiltered (const char *string, struct ui_file * stream)
d131 36
a166 2
  int len = strlen (string);
  int i, linech;
d168 5
a172 4
  for (i = 0; i < len; i++)
    {
      if (string[i] == '\n' || string[i] == '\r')
	m_tuiStartNewLine;
d175 1
a175 18
	  if ((cmdWin->detail.commandInfo.curch + 1) > cmdWin->generic.width)
	    m_tuiStartNewLine;

	  if (insert_mode)
	    {
	      mvwinsch (cmdWin->generic.handle,
			cmdWin->detail.commandInfo.curLine,
			cmdWin->detail.commandInfo.curch++,
			string[i]);
	      wmove (cmdWin->generic.handle,
		     cmdWin->detail.commandInfo.curLine,
		     cmdWin->detail.commandInfo.curch);
	    }
	  else
	    mvwaddch (cmdWin->generic.handle,
		      cmdWin->detail.commandInfo.curLine,
		      cmdWin->detail.commandInfo.curch++,
		      string[i]);
d177 21
a197 2
    }
  tuiRefreshWin (&cmdWin->generic);
d199 6
a204 2
  return;
}				/* tuiPuts_unfiltered */
d206 4
a209 22
/* A cover routine for tputs().
 * tputs() is called from the readline package to put
 * out strings representing cursor positioning.
 * In TUI mode (non-XDB-style), tui_tputs() is called instead.
 *
 * The reason we need to hook tputs() is:
 * Since the output is going to curses and not to
 * a raw terminal, we need to intercept these special
 * sequences, and handle them them here.
 *
 * This function seems to be correctly handling all sequences
 * aimed at hpterm's, but there is additional work to do
 * for xterm's and dtterm's. I abandoned further work on this
 * in favor of "XDB style". In "XDB style", the command region
 * looks like terminal, not a curses window, and this routine
 * is not called. - RT
 */
void
tui_tputs (str, affcnt, putfunc)
     char *str;
     int affcnt;
     int (*putfunc) (int);
d211 1
a211 1
  extern char *rl_prompt;	/* the prompt string */
d213 7
a219 35
  /* This set of globals are defined and initialized
   * by the readline package.
   *
   * Note we're assuming tui_tputs() is being called
   * by the readline package. That's because we're recognizing
   * that a given string is being passed by
   * matching the string address against readline's
   * term_<whatever> global. To make this more general,
   * we'd have to actually recognize the termcap sequence
   * inside the string (more work than I want to do). - RT
   *
   * We don't see or need to handle every one of these here;
   * this is just the full list defined in readline/readline.c
   */
  extern char *term_backspace;
  extern char *term_clreol;
  extern char *term_clrpag;
  extern char *term_cr;
  extern char *term_dc;
  extern char *term_ei;
  extern char *term_goto;
  extern char *term_ic;
  extern char *term_im;
  extern char *term_mm;
  extern char *term_mo;
  extern char *term_up;
  extern char *term_scroll_region;
  extern char *term_memory_lock;
  extern char *term_memory_unlock;
  extern char *term_cursor_move;
  extern char *visible_bell;

  /* Sanity check - if not TUI, just call tputs() */
  if (!tui_version)
    tputs (str, affcnt, putfunc);
d221 2
a222 3
  /* The strings we special-case are handled first */

  if (str == term_backspace)
d224 46
a269 15
      /* Backspace. */

      /* We see this on an emacs control-B.
         * I.e., it's like the left-arrow key (not like the backspace key).
         * The effect that readline wants when it transmits this
         * character to us is simply to back up one character
         * (but not to write a space over the old character).
       */

      _updateCommandInfo (-1);
      wmove (cmdWin->generic.handle,
	     cmdWin->detail.commandInfo.curLine,
	     cmdWin->detail.commandInfo.curch);
      wrefresh (cmdWin->generic.handle);

d271 1
a271 1
  else if (str == term_clreol)
d273 14
a286 5

      /* Clear to end of line. */
      wclrtoeol (cmdWin->generic.handle);
      wrefresh (cmdWin->generic.handle);

d288 1
a288 2
  else if (str == term_cr)
    {
d290 8
a297 25
      /* Carriage return */
      _updateCommandInfo (-cmdWin->detail.commandInfo.curch);
      wmove (cmdWin->generic.handle,
	     cmdWin->detail.commandInfo.curLine,
	     0 /* readline will rewrite the prompt from 0 */ );
      wrefresh (cmdWin->generic.handle);

    }
  else if (str == term_goto)
    {

      /* This is actually a tgoto() specifying a character position,
         * followed by either a term_IC/term_DC which [I think] means
         * insert/delete one character at that position.
         * There are complications with this one - need to either
         * extract the position from the string, or have a backdoor
         * means of communicating it from ../readline/display.c.
         * So this one is not yet implemented.
         * Not doing it seems to have no ill effects on command-line-editing
         * that I've noticed so far. - RT
       */

    }
  else if (str == term_dc)
    {
d299 3
a301 3
      /* Delete character at current cursor position */
      wdelch (cmdWin->generic.handle);
      wrefresh (cmdWin->generic.handle);
d303 4
a306 2
    }
  else if (str == term_im)
d308 2
a309 4

      /* Turn on insert mode. */
      insert_mode = 1;

d311 2
a312 1
  else if (str == term_ei)
d314 2
a315 30

      /* Turn off insert mode. */
      insert_mode = 0;

      /* Strings we know about but don't handle
         * specially here are just passed along to tputs().
         *
         * These are not handled because (as far as I can tell)
         * they are not actually emitted by the readline package
         * in the course of doing command-line editing. Some of them
         * theoretically could be used in the future, in which case we'd
         * need to handle them.
       */
    }
  else if (str == term_ic ||	/* insert character */
	   str == term_cursor_move ||	/* cursor move */
	   str == term_clrpag ||	/* clear page */
	   str == term_mm ||	/* turn on meta key */
	   str == term_mo ||	/* turn off meta key */
	   str == term_up ||	/* up one line (not expected) */
	   str == term_scroll_region ||		/* set scroll region */
	   str == term_memory_lock ||	/* lock screen above cursor */
	   str == term_memory_unlock ||		/* unlock screen above cursor */
	   str == visible_bell)
    {				/* flash screen */
      tputs (str, affcnt, putfunc);
    }
  else
    {				/* something else */
      tputs (str, affcnt, putfunc);
d317 1
a317 1
}				/* tui_tputs */
d319 7
d327 2
a328 15
/*
   ** tui_vwgetch()
   **        Wrapper around wgetch with the window in a va_list
 */
unsigned int
tui_vwgetch (va_list args)
{
  unsigned int ch;
  WINDOW *window;

  window = va_arg (args, WINDOW *);

  return ((unsigned int) wgetch (window));
}				/* tui_vwgetch */

d330 14
a343 24
/*
   ** tuiGetc().
   **        Get a character from the command window.
   **           This is called from the readline package,
   **              that is, we have:
   **                tuiGetc() [here], called from
   **                readline code [in ../readline/], called from
   **                command_line_input() in top.c
 */
unsigned int
tuiGetc (void)
{
  unsigned int ch;
  extern char *rl_prompt;
  extern char *rl_line_buffer;
  extern int rl_point;

  /* Call the curses routine that reads one character */
#ifndef COMMENT
  ch = (unsigned int) vcatch_errors ((OpaqueFuncPtr) tui_vwgetch,
				     cmdWin->generic.handle);
#else
  ch = wgetch (cmdWin->generic.handle);
#endif
d346 26
a373 1
      tuiTermSetup (0);
a374 2
      cmdWin->detail.commandInfo.curch = strlen (rl_prompt) + rl_point;
      tuiTermUnsetup (0, cmdWin->detail.commandInfo.curch);
d376 1
d379 1
d382 4
a385 1

d387 1
a387 102
}				/* tuiGetc */


/*
   ** tuiBufferGetc().
 */
/*elz: this function reads a line of input from the user and
   puts it in a static buffer. Subsequent calls to this same function
   obtain one char at the time, providing the caller with a behavior
   similar to fgetc. When the input is buffered, the backspaces have
   the needed effect, i.e. ignore the last char active in the buffer */
/* so far this function is called only from the query function in
   utils.c */

unsigned int
tuiBufferGetc (void)
{
  unsigned int ch;
  static unsigned char _ibuffer[512];
  static int index_read = -1;
  static int length_of_answer = -1;
  int pos = 0;

  if (length_of_answer == -1)
    {
      /* this is the first time through, need to read the answer */
      do
	{
	  /* Call the curses routine that reads one character */
	  ch = (unsigned int) wgetch (cmdWin->generic.handle);
	  if (ch != '\b')
	    {
	      _ibuffer[pos] = ch;
	      pos++;
	    }
	  else
	    pos--;
	}
      while (ch != '\r' && ch != '\n');

      length_of_answer = pos;
      index_read = 0;
    }

  ch = _ibuffer[index_read];
  index_read++;

  if (index_read == length_of_answer)
    {
      /*this is the last time through, reset for next query */
      index_read = -1;
      length_of_answer = -1;
    }

  wrefresh (cmdWin->generic.handle);

  return (ch);
}				/* tuiBufferGetc */


/*
   ** tuiStartNewLines().
 */
void
tuiStartNewLines (int numLines)
{
  if (numLines > 0)
    {
      if (cmdWin->generic.viewportHeight > 1 &&
	cmdWin->detail.commandInfo.curLine < cmdWin->generic.viewportHeight)
	cmdWin->detail.commandInfo.curLine += numLines;
      else
	scroll (cmdWin->generic.handle);
      cmdWin->detail.commandInfo.curch = 0;
      wmove (cmdWin->generic.handle,
	     cmdWin->detail.commandInfo.curLine,
	     cmdWin->detail.commandInfo.curch);
      tuiRefreshWin (&cmdWin->generic);
    }

  return;
}				/* tuiStartNewLines */


/*
   ** tui_vStartNewLines().
   **        With numLines in a va_list
 */
void
tui_vStartNewLines (va_list args)
{
  int numLines = va_arg (args, int);

  tuiStartNewLines (numLines);

  return;
}				/* tui_vStartNewLines */


/****************************************************************************
**                   LOCAL STATIC FUNCTIONS                                **
*****************************************************************************/
d390 2
a391 6
/*
   ** _tuiHandleResizeDuringIO
   **    This function manages the cleanup when a resize has occured
   **    From within a call to getch() or read.  Returns the character
   **    to return from getc or read.
 */
a393 1
	/* the char just read */
a399 1
      rl_reset ();
d404 1
a404 198
}				/* _tuiHandleResizeDuringIO */


/*
   ** _updateCommandInfo().
   **        Function to update the command window information.
 */
static void
_updateCommandInfo (int sizeOfString)
{

  if ((sizeOfString +
       cmdWin->detail.commandInfo.curch) > cmdWin->generic.width)
    {
      int newCurch = sizeOfString + cmdWin->detail.commandInfo.curch;

      tuiStartNewLines (1);
      cmdWin->detail.commandInfo.curch = newCurch - cmdWin->generic.width;
    }
  else
    cmdWin->detail.commandInfo.curch += sizeOfString;

  return;
}				/* _updateCommandInfo */


/* Looked at in main.c, fputs_unfiltered(), to decide
 * if it's safe to do standard output to the command window.
 */
int tui_owns_terminal = 0;

/* Called to set up the terminal for TUI (curses) I/O.
 * We do this either on our way "in" to GDB after target
 * program execution, or else within tuiDo just before
 * going off to TUI routines.
 */

void
tuiTermSetup (int turn_off_echo)
{
  char *buffer;
  int start;
  int end;
  int endcol;
  extern char *term_scroll_region;
  extern char *term_cursor_move;
  extern char *term_memory_lock;
  extern char *term_memory_unlock;

  /* Turn off echoing, since the TUI does not
     * expect echoing. Below I only put in the TERMIOS
     * case, since that is what applies on HP-UX. turn_off_echo
     * is 1 except for the case where we're being called
     * on a "quit", in which case we want to leave echo on.
   */
  if (turn_off_echo)
    {
#ifdef HAVE_TERMIOS
      struct termios tio;
      tcgetattr (0, &tio);
      tio.c_lflag &= ~(ECHO);
      tcsetattr (0, TCSANOW, &tio);
#endif
    }

  /* Compute the start and end lines of the command
     * region. (Actually we only use end here)
   */
  start = winList[CMD_WIN]->generic.origin.y;
  end = start + winList[CMD_WIN]->generic.height - 1;
  endcol = winList[CMD_WIN]->generic.width - 1;

  if (term_memory_unlock)
    {

      /* Un-do the effect of the memory lock in terminal_inferior() */
      tputs (term_memory_unlock, 1, (int (*) (int)) putchar);
      fflush (stdout);

    }
  else if (term_scroll_region)
    {

      /* Un-do the effect of setting scroll region in terminal_inferior() */
      /* I'm actually not sure how to do this (we don't know for
       * sure what the scroll region was *before* we changed it),
       * but I'll guess that setting it to the whole screen is
       * the right thing. So, ...
       */

      /* Set scroll region to be 0..end */
      buffer = (char *) tgoto (term_scroll_region, end, 0);
      tputs (buffer, 1, (int (*) (int)) putchar);

    }				/* else we're out of luck */

  /* This is an attempt to keep the logical & physical
     * cursor in synch, going into curses. Without this,
     * curses seems to be confused by the fact that
     * GDB has physically moved the curser on it. One
     * visible effect of removing this code is that the
     * locator window fails to get updated and the line
     * of text that *should* go into the locator window
     * often goes to the wrong place.
   */
  /* What's done here is to  tell curses to write a ' '
     * at the bottom right corner of the screen.
     * The idea is to wind up with the cursor in a known
     * place.
     * Note I'm relying on refresh()
     * only writing what changed (the space),
     * not the whole screen.
   */
  standend ();
  move (end, endcol - 1);
  addch (' ');
  refresh ();

  tui_owns_terminal = 1;
}				/* tuiTermSetup */


/* Called to set up the terminal for target program I/O, meaning I/O
 * is confined to the command-window area.  We also call this on our
 * way out of tuiDo, thus setting up the terminal this way for
 * debugger command I/O.  */
void
tuiTermUnsetup (int turn_on_echo, int to_column)
{
  int start;
  int end;
  int curline;
  char *buffer;
  /* The next bunch of things are from readline */
  extern char *term_scroll_region;
  extern char *term_cursor_move;
  extern char *term_memory_lock;
  extern char *term_memory_unlock;
  extern char *term_se;

  /* We need to turn on echoing, since the TUI turns it off */
  /* Below I only put in the TERMIOS case, since that
     * is what applies on HP-UX.
   */
  if (turn_on_echo)
    {
#ifdef HAVE_TERMIOS
      struct termios tio;
      tcgetattr (0, &tio);
      tio.c_lflag |= (ECHO);
      tcsetattr (0, TCSANOW, &tio);
#endif
    }

  /* Compute the start and end lines of the command
     * region, as well as the last "real" line of
     * the region (normally same as end, except when
     * we're first populating the region)
   */
  start = winList[CMD_WIN]->generic.origin.y;
  end = start + winList[CMD_WIN]->generic.height - 1;
  curline = start + winList[CMD_WIN]->detail.commandInfo.curLine;

  /* We want to confine target I/O to the command region.
     * In order to do so, we must either have "memory lock"
     * (hpterm's) or "scroll regions" (xterm's).
   */
  if (term_cursor_move && term_memory_lock)
    {

      /* Memory lock means lock region above cursor.
       * So first position the cursor, then call memory lock.
       */
      buffer = tgoto (term_cursor_move, 0, start);
      tputs (buffer, 1, (int (*) (int)) putchar);
      tputs (term_memory_lock, 1, (int (*) (int)) putchar);

    }
  else if (term_scroll_region)
    {

      /* Set the scroll region to the command window */
      buffer = tgoto (term_scroll_region, end, start);
      tputs (buffer, 1, (int (*) (int)) putchar);

    }				/* else we can't do anything about target I/O */

  /* Also turn off standout mode, in case it is on */
  if (term_se != NULL)
    tputs (term_se, 1, (int (*) (int)) putchar);

  /* Now go to the appropriate spot on the end line */
  buffer = tgoto (term_cursor_move, to_column, end);
  tputs (buffer, 1, (int (*) (int)) putchar);
  fflush (stdout);

  tui_owns_terminal = 0;
}				/* tuiTermUnsetup */
@


1.6
log
@	* tuiWin.c, tui.c, tuiCommand.c: Use ansi prototype.
	tuiIO.c, tuiData.c: Likewise.
	tuiDataWin.c, tuiDisassem.c: Likewise.
	tuiGeneralWin.c, tuiLayout.c: Likewise.
	tuiRegs.c, tuiSource.c: Likewise.
	tuiSouceWin.c, tuiStack.c: Likewise.
@
text
@a279 33
   ** tui_vread()
   **   Wrapper around read() with paramets in a va_list
 */
unsigned int
tui_vread (va_list args)
{
  int result = 0;
  int filedes = va_arg (args, int);
  char *buf = va_arg (args, char *);
  int nbytes = va_arg (args, int);

  result = read (filedes, buf, nbytes);

  return result;
}				/* tui_vread() */

/*
   ** tuiRead()
   **    Function to perform a read() catching resize events
 */
int
tuiRead (int filedes, char *buf, int nbytes)
{
  int result = 0;

  result = (int) vcatch_errors ((OpaqueFuncPtr) tui_vread, filedes, buf, nbytes);
  *buf = _tuiHandleResizeDuringIO (*buf);

  return result;
}				/* tuiRead */


/*
d434 1
a434 1
      tuiDo ((TuiOpaqueFuncPtr) tuiRefreshAll);
@


1.5
log
@	* tuiWin.c, tuiWin.h, tui.c, tui.h, tuiCommand.c: Add FSF copyright.
	tuiCommand.h, tuiIO.c, tuiIO.h, tuiData.h, tuiData.c: Likewise.
	tuiDataWin.c, tuiDataWin.h, tuiDisassem.c, tuiDisassem.h: Likewise.
	tuiGeneralWin.c, tuiGeneralWin.h, tuiLayout.c, tuiLayout.h: Likewise.
	tuiRegs.c, tuiRegs.h, tuiSource.c, tuiSource.h: Likewise.
	tuiSouceWin.c, tuiSourceWin.h, tuiStack.c, tuiStack.h: Likewise.
@
text
@a30 1
#ifdef ANSI_PROTOTYPES
a31 3
#else
#include <varargs.h>
#endif
d61 1
a61 9
#ifdef __STDC__
tuiPuts_unfiltered (
		     const char *string,
		     struct ui_file * stream)
#else
tuiPuts_unfiltered (string, stream)
     char *string;
     struct ui_file *stream;
#endif
a267 1
#ifdef __STDC__
a268 4
#else
tui_vwgetch (args)
     va_list args;
#endif
a283 1
#ifdef __STDC__
a284 4
#else
tui_vread (args)
     va_list args;
#endif
d301 1
a301 11
#ifdef __STDC__
tuiRead (
	  int filedes,
	  char *buf,
	  int nbytes)
#else
tuiRead (filedes, buf, nbytes)
     int filedes;
     char *buf;
     int nbytes;
#endif
a321 1
#ifdef __STDC__
a322 3
#else
tuiGetc ()
#endif
a365 1
#ifdef __STDC__
a366 3
#else
tuiBufferGetc ()
#endif
d415 1
a415 7
#ifdef __STDC__
tuiStartNewLines (
		   int numLines)
#else
tuiStartNewLines (numLines)
     int numLines;
#endif
d440 1
a440 7
#ifdef __STDC__
tui_vStartNewLines (
		     va_list args)
#else
tui_vStartNewLines (args)
     va_list args;
#endif
d462 2
a463 7
#ifdef __STDC__
_tuiHandleResizeDuringIO (
			   unsigned int originalCh)	/* the char just read */
#else
_tuiHandleResizeDuringIO (originalCh)
     unsigned int originalCh;
#endif
d483 1
a483 7
#ifdef __STDC__
_updateCommandInfo (
		     int sizeOfString)
#else
_updateCommandInfo (sizeOfString)
     int sizeOfString;
#endif
d513 1
a513 7
#ifdef __STDC__
tuiTermSetup (
	       int turn_off_echo)
#else
tuiTermSetup (turn_off_echo)
     int turn_off_echo;
#endif
d602 1
a602 9
#ifdef __STDC__
tuiTermUnsetup (
		 int turn_on_echo,
		 int to_column)
#else
tuiTermUnsetup (turn_on_echo, to_column)
     int turn_on_echo;
     int to_column;
#endif
@


1.4
log
@PARAMS elimination.
@
text
@d1 3
d5 1
a5 3
/*
   ** This module contains functions to support i/o in the TUI
 */
d7 14
@


1.3
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d605 1
a605 1
      tputs (term_memory_unlock, 1, (int (*)PARAMS ((int))) putchar);
d621 1
a621 1
      tputs (buffer, 1, (int (*)PARAMS ((int))) putchar);
d711 2
a712 2
      tputs (buffer, 1, (int (*)PARAMS ((int))) putchar);
      tputs (term_memory_lock, 1, (int (*)PARAMS ((int))) putchar);
d720 1
a720 1
      tputs (buffer, 1, (int (*)PARAMS ((int))) putchar);
d726 1
a726 1
    tputs (term_se, 1, (int (*)PARAMS ((int))) putchar);
d730 1
a730 1
  tputs (buffer, 1, (int (*)PARAMS ((int))) putchar);
@


1.2
log
@PARAMS removal.
@
text
@d115 1
a115 1
     int (*putfunc) PARAMS ((int));
@


1.1
log
@Initial revision
@
text
@d3 2
a4 2
** This module contains functions to support i/o in the TUI
*/
d32 2
a33 2
static void _updateCommandInfo PARAMS ((int));
static unsigned int _tuiHandleResizeDuringIO PARAMS ((unsigned int));
d41 8
a48 8
** tuiPuts_unfiltered().
**        Function to put a string to the command window
**              When running in TUI mode, this is the "hook"
**              for fputs_unfiltered(). That is, all debugger
**              output eventually makes it's way to the bottom-level
**              routine fputs_unfiltered (main.c), which (in TUI
**              mode), calls tuiPuts_unfiltered().
*/
d53 1
a53 1
		     GDB_FILE * stream)
d57 1
a57 1
     GDB_FILE *stream;
d162 5
a166 5
     * I.e., it's like the left-arrow key (not like the backspace key).
     * The effect that readline wants when it transmits this
     * character to us is simply to back up one character
     * (but not to write a space over the old character).
     */
d198 9
a206 9
     * followed by either a term_IC/term_DC which [I think] means
     * insert/delete one character at that position.
     * There are complications with this one - need to either
     * extract the position from the string, or have a backdoor
     * means of communicating it from ../readline/display.c.
     * So this one is not yet implemented.
     * Not doing it seems to have no ill effects on command-line-editing
     * that I've noticed so far. - RT
     */
d231 8
a238 8
   * specially here are just passed along to tputs().
   *
   * These are not handled because (as far as I can tell)
   * they are not actually emitted by the readline package
   * in the course of doing command-line editing. Some of them
   * theoretically could be used in the future, in which case we'd
   * need to handle them.
   */
d242 1
a242 1
	   str == term_clrpag ||/* clear page */
d246 1
a246 1
	   str == term_scroll_region ||	/* set scroll region */
d248 1
a248 1
	   str == term_memory_unlock ||	/* unlock screen above cursor */
d261 3
a263 3
** tui_vwgetch()
**        Wrapper around wgetch with the window in a va_list
*/
d282 3
a284 3
** tui_vread()
**   Wrapper around read() with paramets in a va_list
*/
d304 3
a306 3
** tuiRead()
**    Function to perform a read() catching resize events
*/
d330 8
a337 8
** tuiGetc().
**        Get a character from the command window.
**		This is called from the readline package,
**              that is, we have:
**                tuiGetc() [here], called from
**                readline code [in ../readline/], called from
**                command_line_input() in top.c
*/
d376 2
a377 2
** tuiBufferGetc().
*/
d379 4
a382 4
puts it in a static buffer. Subsequent calls to this same function
obtain one char at the time, providing the caller with a behavior
similar to fgetc. When the input is buffered, the backspaces have
the needed effect, i.e. ignore the last char active in the buffer*/
d384 1
a384 1
utils.c*/
d401 1
a401 1
      /* this is the first time through, need to read the answer*/
d425 1
a425 1
      /*this is the last time through, reset for next query*/
d437 2
a438 2
** tuiStartNewLines().
*/
d467 3
a469 3
** tui_vStartNewLines().
**        With numLines in a va_list
*/
d493 5
a497 5
** _tuiHandleResizeDuringIO
**    This function manages the cleanup when a resize has occured
**    From within a call to getch() or read.  Returns the character
**    to return from getc or read.
*/
d521 3
a523 3
** _updateCommandInfo().
**        Function to update the command window information.
*/
d583 1
a583 1
     */
d596 1
a596 1
     */
d626 8
a633 8
       * cursor in synch, going into curses. Without this,
       * curses seems to be confused by the fact that
       * GDB has physically moved the curser on it. One
       * visible effect of removing this code is that the
       * locator window fails to get updated and the line
       * of text that *should* go into the locator window
       * often goes to the wrong place.
       */
d635 7
a641 7
       * at the bottom right corner of the screen.
       * The idea is to wind up with the cursor in a known
       * place.
       * Note I'm relying on refresh()
       * only writing what changed (the space),
       * not the whole screen.
       */
d680 1
a680 1
     */
d695 1
a695 1
     */
d703 1
a703 1
     */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d3 2
a4 2
   ** This module contains functions to support i/o in the TUI
 */
d41 8
a48 8
   ** tuiPuts_unfiltered().
   **        Function to put a string to the command window
   **              When running in TUI mode, this is the "hook"
   **              for fputs_unfiltered(). That is, all debugger
   **              output eventually makes it's way to the bottom-level
   **              routine fputs_unfiltered (main.c), which (in TUI
   **              mode), calls tuiPuts_unfiltered().
 */
d162 5
a166 5
         * I.e., it's like the left-arrow key (not like the backspace key).
         * The effect that readline wants when it transmits this
         * character to us is simply to back up one character
         * (but not to write a space over the old character).
       */
d198 9
a206 9
         * followed by either a term_IC/term_DC which [I think] means
         * insert/delete one character at that position.
         * There are complications with this one - need to either
         * extract the position from the string, or have a backdoor
         * means of communicating it from ../readline/display.c.
         * So this one is not yet implemented.
         * Not doing it seems to have no ill effects on command-line-editing
         * that I've noticed so far. - RT
       */
d231 8
a238 8
         * specially here are just passed along to tputs().
         *
         * These are not handled because (as far as I can tell)
         * they are not actually emitted by the readline package
         * in the course of doing command-line editing. Some of them
         * theoretically could be used in the future, in which case we'd
         * need to handle them.
       */
d242 1
a242 1
	   str == term_clrpag ||	/* clear page */
d246 1
a246 1
	   str == term_scroll_region ||		/* set scroll region */
d248 1
a248 1
	   str == term_memory_unlock ||		/* unlock screen above cursor */
d261 3
a263 3
   ** tui_vwgetch()
   **        Wrapper around wgetch with the window in a va_list
 */
d282 3
a284 3
   ** tui_vread()
   **   Wrapper around read() with paramets in a va_list
 */
d304 3
a306 3
   ** tuiRead()
   **    Function to perform a read() catching resize events
 */
d330 8
a337 8
   ** tuiGetc().
   **        Get a character from the command window.
   **           This is called from the readline package,
   **              that is, we have:
   **                tuiGetc() [here], called from
   **                readline code [in ../readline/], called from
   **                command_line_input() in top.c
 */
d376 2
a377 2
   ** tuiBufferGetc().
 */
d379 4
a382 4
   puts it in a static buffer. Subsequent calls to this same function
   obtain one char at the time, providing the caller with a behavior
   similar to fgetc. When the input is buffered, the backspaces have
   the needed effect, i.e. ignore the last char active in the buffer */
d384 1
a384 1
   utils.c */
d401 1
a401 1
      /* this is the first time through, need to read the answer */
d425 1
a425 1
      /*this is the last time through, reset for next query */
d437 2
a438 2
   ** tuiStartNewLines().
 */
d467 3
a469 3
   ** tui_vStartNewLines().
   **        With numLines in a va_list
 */
d493 5
a497 5
   ** _tuiHandleResizeDuringIO
   **    This function manages the cleanup when a resize has occured
   **    From within a call to getch() or read.  Returns the character
   **    to return from getc or read.
 */
d521 3
a523 3
   ** _updateCommandInfo().
   **        Function to update the command window information.
 */
d583 1
a583 1
   */
d596 1
a596 1
   */
d626 8
a633 8
     * cursor in synch, going into curses. Without this,
     * curses seems to be confused by the fact that
     * GDB has physically moved the curser on it. One
     * visible effect of removing this code is that the
     * locator window fails to get updated and the line
     * of text that *should* go into the locator window
     * often goes to the wrong place.
   */
d635 7
a641 7
     * at the bottom right corner of the screen.
     * The idea is to wind up with the cursor in a known
     * place.
     * Note I'm relying on refresh()
     * only writing what changed (the space),
     * not the whole screen.
   */
d680 1
a680 1
   */
d695 1
a695 1
   */
d703 1
a703 1
   */
@


1.1.1.3
log
@import gdb-2000-02-01 snapshot
@
text
@d53 1
a53 1
		     struct ui_file * stream)
d57 1
a57 1
     struct ui_file *stream;
@


