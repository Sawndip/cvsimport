head	1.29;
access;
symbols
	drow-cplus-merge-20040113:1.28
	drow-cplus-merge-20031224:1.28
	drow-cplus-merge-20031220:1.28
	carlton_dictionary-20031215-merge:1.28
	drow-cplus-merge-20031214:1.28
	carlton-dictionary-20031111-merge:1.28
	gdb_6_0-2003-10-04-release:1.28
	kettenis_sparc-20030918-branch:1.28.0.8
	kettenis_sparc-20030918-branchpoint:1.28
	carlton_dictionary-20030917-merge:1.28
	ezannoni_pie-20030916-branchpoint:1.28
	ezannoni_pie-20030916-branch:1.28.0.6
	cagney_x86i386-20030821-branch:1.28.0.4
	cagney_x86i386-20030821-branchpoint:1.28
	carlton_dictionary-20030805-merge:1.28
	carlton_dictionary-20030627-merge:1.28
	gdb_6_0-branch:1.28.0.2
	gdb_6_0-2003-06-23-branchpoint:1.28
	jimb-ppc64-linux-20030613-branch:1.27.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.27
	cagney_convert-20030606-branch:1.26.0.30
	cagney_convert-20030606-branchpoint:1.26
	cagney_writestrings-20030508-branch:1.26.0.28
	cagney_writestrings-20030508-branchpoint:1.26
	jimb-ppc64-linux-20030528-branch:1.26.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.26
	carlton_dictionary-20030523-merge:1.26
	cagney_fileio-20030521-branch:1.26.0.24
	cagney_fileio-20030521-branchpoint:1.26
	kettenis_i386newframe-20030517-mergepoint:1.26
	jimb-ppc64-linux-20030509-branch:1.26.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.26
	kettenis_i386newframe-20030504-mergepoint:1.26
	carlton_dictionary-20030430-merge:1.26
	kettenis_i386newframe-20030419-branch:1.26.0.20
	kettenis_i386newframe-20030419-branchpoint:1.26
	carlton_dictionary-20030416-merge:1.26
	cagney_frameaddr-20030409-mergepoint:1.26
	kettenis_i386newframe-20030406-branch:1.26.0.18
	kettenis_i386newframe-20030406-branchpoint:1.26
	cagney_frameaddr-20030403-branchpoint:1.26
	cagney_frameaddr-20030403-branch:1.26.0.16
	cagney_framebase-20030330-mergepoint:1.26
	cagney_framebase-20030326-branch:1.26.0.14
	cagney_framebase-20030326-branchpoint:1.26
	cagney_lazyid-20030317-branch:1.26.0.12
	cagney_lazyid-20030317-branchpoint:1.26
	kettenis-i386newframe-20030316-mergepoint:1.26
	offbyone-20030313-branch:1.26.0.10
	offbyone-20030313-branchpoint:1.26
	kettenis-i386newframe-20030308-branch:1.26.0.8
	kettenis-i386newframe-20030308-branchpoint:1.26
	carlton_dictionary-20030305-merge:1.26
	cagney_offbyone-20030303-branch:1.26.0.6
	cagney_offbyone-20030303-branchpoint:1.26
	carlton_dictionary-20030207-merge:1.26
	interps-20030203-mergepoint:1.26
	interps-20030202-branch:1.26.0.4
	interps-20030202-branchpoint:1.26
	cagney-unwind-20030108-branch:1.26.0.2
	cagney-unwind-20030108-branchpoint:1.26
	carlton_dictionary-20021223-merge:1.26
	gdb_5_3-2002-12-12-release:1.20.2.1
	carlton_dictionary-20021115-merge:1.22
	kseitz_interps-20021105-merge:1.21
	kseitz_interps-20021103-merge:1.21
	drow-cplus-merge-20021020:1.21
	drow-cplus-merge-20021025:1.21
	carlton_dictionary-20021025-merge:1.21
	carlton_dictionary-20021011-merge:1.21
	drow-cplus-branch:1.21.0.4
	drow-cplus-branchpoint:1.21
	kseitz_interps-20020930-merge:1.21
	carlton_dictionary-20020927-merge:1.21
	carlton_dictionary-branch:1.21.0.2
	carlton_dictionary-20020920-branchpoint:1.21
	gdb_5_3-branch:1.20.0.2
	gdb_5_3-2002-09-04-branchpoint:1.20
	kseitz_interps-20020829-merge:1.19
	cagney_sysregs-20020825-branch:1.19.0.2
	cagney_sysregs-20020825-branchpoint:1.19
	readline_4_3-import-branch:1.13.0.10
	readline_4_3-import-branchpoint:1.13
	gdb_5_2_1-2002-07-23-release:1.13
	kseitz_interps-20020528-branch:1.13.0.8
	kseitz_interps-20020528-branchpoint:1.13
	cagney_regbuf-20020515-branch:1.13.0.6
	cagney_regbuf-20020515-branchpoint:1.13
	jimb-macro-020506-branch:1.13.0.4
	jimb-macro-020506-branchpoint:1.13
	gdb_5_2-2002-04-29-release:1.13
	gdb_5_2-branch:1.13.0.2
	gdb_5_2-2002-03-03-branchpoint:1.13
	gdb_5_1_1-2002-01-24-release:1.11
	gdb_5_1_0_1-2002-01-03-release:1.11
	cygnus_cvs_20020108_pre:1.11
	gdb_5_1_0_1-2002-01-03-branch:1.11.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11
	gdb_5_1-2001-11-21-release:1.11
	gdb_s390-2001-09-26-branch:1.11.0.4
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.2
	gdb_5_1-2001-07-29-branchpoint:1.11
	dberlin-typesystem-branch:1.3.0.2
	dberlin-typesystem-branchpoint:1.3
	gdb-post-ptid_t-2001-05-03:1.3
	gdb-pre-ptid_t-2001-05-03:1.3
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.29
date	2004.01.19.04.31.53;	author cagney;	state dead;
branches;
next	1.28;

1.28
date	2003.06.22.15.21.39;	author drow;	state Exp;
branches
	1.28.6.1;
next	1.27;

1.27
date	2003.06.12.15.44.24;	author schwab;	state Exp;
branches;
next	1.26;

1.26
date	2002.12.07.03.36.46;	author ezannoni;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.29.01.52.02;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.24.03.20.09;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.18.22.19.33;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.10.15.36.26;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.13.19.37.47;	author ciceron;	state Exp;
branches
	1.21.2.1
	1.21.4.1;
next	1.20;

1.20
date	2002.09.01.10.20.48;	author ciceron;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2002.08.25.17.13.29;	author ciceron;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.25.13.13.20;	author ciceron;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.25.10.04.08;	author ciceron;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.25.09.53.27;	author ciceron;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.25.09.40.32;	author ciceron;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.25.08.22.58;	author ciceron;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.01.06.19.28;	author cagney;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	2002.02.08.15.54.32;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.23.21.13.57;	author ciceron;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.21.20.52.56;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.20.23.06.48;	author ciceron;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.19.22.47.46;	author ciceron;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.18.20.59.00;	author ciceron;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.16.22.13.38;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.14.19.31.09;	author ciceron;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.14.19.01.25;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.42;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.19.33;	author jsm;	state Exp;
branches;
next	;

1.13.8.1
date	2002.08.30.22.52.52;	author kseitz;	state Exp;
branches;
next	1.13.8.2;

1.13.8.2
date	2002.10.01.00.46.35;	author kseitz;	state Exp;
branches;
next	;

1.20.2.1
date	2002.09.13.19.38.27;	author ciceron;	state Exp;
branches;
next	;

1.21.2.1
date	2002.11.15.19.19.20;	author carlton;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.12.23.19.39.21;	author carlton;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2003.06.27.21.50.21;	author carlton;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2004.01.26.19.11.45;	author carlton;	state dead;
branches;
next	;

1.21.4.1
date	2003.12.14.20.27.59;	author drow;	state Exp;
branches;
next	1.21.4.2;

1.21.4.2
date	2004.02.09.19.43.58;	author drow;	state dead;
branches;
next	;

1.28.6.1
date	2004.03.23.20.09.17;	author ezannoni;	state dead;
branches;
next	;


desc
@@


1.29
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@/* TUI display locator.

   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "symtab.h"
#include "breakpoint.h"
#include "frame.h"
#include "command.h"
#include "inferior.h"
#include "target.h"
#include "top.h"

#include "tui.h"
#include "tuiData.h"
#include "tuiStack.h"
#include "tuiGeneralWin.h"
#include "tuiSource.h"
#include "tuiSourceWin.h"
#include "tui-file.h"

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

/* Get a printable name for the function at the address.
   The symbol name is demangled if demangling is turned on.
   Returns a pointer to a static area holding the result.  */
static char* tui_get_function_from_frame (struct frame_info *fi);

/* Set the filename portion of the locator.  */
static void tui_set_locator_filename (const char *filename);

/* Update the locator, with the provided arguments.  */
static void tui_set_locator_info (const char *filename, const char *procname,
                                  int lineno, CORE_ADDR addr);

static void tui_update_command (char *, int);


/* Create the status line to display as much information as we
   can on this single line: target name, process number, current
   function, current line, current PC, SingleKey mode.  */
static char*
tui_make_status_line (TuiLocatorElement* loc)
{
  char* string;
  char line_buf[50], *pname;
  char* buf;
  int status_size;
  int i, proc_width;
  const char* pid_name;
  const char* pc_buf;
  int target_width;
  int pid_width;
  int line_width;
  int pc_width;
  struct ui_file *pc_out;

  if (ptid_equal (inferior_ptid, null_ptid))
    pid_name = "No process";
  else
    pid_name = target_pid_to_str (inferior_ptid);

  target_width = strlen (target_shortname);
  if (target_width > MAX_TARGET_WIDTH)
    target_width = MAX_TARGET_WIDTH;

  pid_width = strlen (pid_name);
  if (pid_width > MAX_PID_WIDTH)
    pid_width = MAX_PID_WIDTH;

  status_size = termWidth ();  
  string = (char *) xmalloc (status_size + 1);
  buf = (char*) alloca (status_size + 1);

  /* Translate line number and obtain its size.  */
  if (loc->lineNo > 0)
    sprintf (line_buf, "%d", loc->lineNo);
  else
    strcpy (line_buf, "??");
  line_width = strlen (line_buf);
  if (line_width < MIN_LINE_WIDTH)
    line_width = MIN_LINE_WIDTH;

  /* Translate PC address.  */
  pc_out = tui_sfileopen (128);
  print_address_numeric (loc->addr, 1, pc_out);
  pc_buf = tui_file_get_strbuf (pc_out);
  pc_width = strlen (pc_buf);
  
  /* First determine the amount of proc name width we have available.
     The +1 are for a space separator between fields.
     The -1 are to take into account the \0 counted by sizeof.  */
  proc_width = (status_size
                - (target_width + 1)
                - (pid_width + 1)
                - (sizeof (PROC_PREFIX) - 1 + 1)
                - (sizeof (LINE_PREFIX) - 1 + line_width + 1)
                - (sizeof (PC_PREFIX) - 1 + pc_width + 1)
                - (tui_current_key_mode == tui_single_key_mode
                   ? (sizeof (SINGLE_KEY) - 1 + 1)
                   : 0));

  /* If there is no room to print the function name, try by removing
     some fields.  */
  if (proc_width < MIN_PROC_WIDTH)
    {
      proc_width += target_width + 1;
      target_width = 0;
      if (proc_width < MIN_PROC_WIDTH)
        {
          proc_width += pid_width + 1;
          pid_width = 0;
          if (proc_width <= MIN_PROC_WIDTH)
            {
              proc_width += pc_width + sizeof (PC_PREFIX) - 1 + 1;
              pc_width = 0;
              if (proc_width < 0)
                {
                  proc_width += line_width + sizeof (LINE_PREFIX) - 1 + 1;
                  line_width = 0;
                  if (proc_width < 0)
                    proc_width = 0;
                }
            }
        }
    }

  /* Now convert elements to string form */
  pname = loc->procName;

  /* Now create the locator line from the string version
     of the elements.  We could use sprintf() here but
     that wouldn't ensure that we don't overrun the size
     of the allocated buffer.  strcat_to_buf() will.  */
  *string = (char) 0;

  if (target_width > 0)
    {
      sprintf (buf, "%*.*s ",
               -target_width, target_width, target_shortname);
      strcat_to_buf (string, status_size, buf);
    }
  if (pid_width > 0)
    {
      sprintf (buf, "%*.*s ",
               -pid_width, pid_width, pid_name);
      strcat_to_buf (string, status_size, buf);
    }
  
  /* Show whether we are in SingleKey mode.  */
  if (tui_current_key_mode == tui_single_key_mode)
    {
      strcat_to_buf (string, status_size, SINGLE_KEY);
      strcat_to_buf (string, status_size, " ");
    }

  /* procedure/class name */
  if (proc_width > 0)
    {
      if (strlen (pname) > proc_width)
        sprintf (buf, "%s%*.*s* ", PROC_PREFIX,
                 1 - proc_width, proc_width - 1, pname);
      else
        sprintf (buf, "%s%*.*s ", PROC_PREFIX,
                 -proc_width, proc_width, pname);
      strcat_to_buf (string, status_size, buf);
    }

  if (line_width > 0)
    {
      sprintf (buf, "%s%*.*s ", LINE_PREFIX,
               -line_width, line_width, line_buf);
      strcat_to_buf (string, status_size, buf);
    }
  if (pc_width > 0)
    {
      strcat_to_buf (string, status_size, PC_PREFIX);
      strcat_to_buf (string, status_size, pc_buf);
    }
  
  
  for (i = strlen (string); i < status_size; i++)
    string[i] = ' ';
  string[status_size] = (char) 0;

  ui_file_delete (pc_out);
  return string;
}

/* Get a printable name for the function at the address.
   The symbol name is demangled if demangling is turned on.
   Returns a pointer to a static area holding the result.  */
static char*
tui_get_function_from_frame (struct frame_info *fi)
{
  static char name[256];
  struct ui_file *stream = tui_sfileopen (256);
  char *p;

  print_address_symbolic (get_frame_pc (fi), stream, demangle, "");
  p = tui_file_get_strbuf (stream);

  /* Use simple heuristics to isolate the function name.  The symbol can
     be demangled and we can have function parameters.  Remove them because
     the status line is too short to display them.  */
  if (*p == '<')
    p++;
  strncpy (name, p, sizeof (name));
  p = strchr (name, '(');
  if (!p)
    p = strchr (name, '>');
  if (p)
    *p = 0;
  p = strchr (name, '+');
  if (p)
    *p = 0;
  ui_file_delete (stream);
  return name;
}

/*
   ** tuiShowLocatorContent()
 */
void
tuiShowLocatorContent (void)
{
  char *string;
  TuiGenWinInfoPtr locator;

  locator = locatorWinInfoPtr ();

  if (m_genWinPtrNotNull (locator) && locator->handle != (WINDOW *) NULL)
    {
      TuiWinElementPtr element;

      element = (TuiWinElementPtr) locator->content[0];

      string = tui_make_status_line (&element->whichElement.locator);
      wmove (locator->handle, 0, 0);
      wstandout (locator->handle);
      waddstr (locator->handle, string);
      wclrtoeol (locator->handle);
      wstandend (locator->handle);
      tuiRefreshWin (locator);
      wmove (locator->handle, 0, 0);
      xfree (string);
      locator->contentInUse = TRUE;
    }
}


/* Set the filename portion of the locator.  */
static void
tui_set_locator_filename (const char *filename)
{
  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
  TuiLocatorElementPtr element;

  if (locator->content[0] == (Opaque) NULL)
    {
      tui_set_locator_info (filename, NULL, 0, 0);
      return;
    }

  element = &((TuiWinElementPtr) locator->content[0])->whichElement.locator;
  element->fileName[0] = 0;
  strcat_to_buf (element->fileName, MAX_LOCATOR_ELEMENT_LEN, filename);
}

/* Update the locator, with the provided arguments.  */
static void
tui_set_locator_info (const char *filename, const char *procname, int lineno,
                      CORE_ADDR addr)
{
  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
  TuiLocatorElementPtr element;

  /* Allocate the locator content if necessary.  */
  if (locator->contentSize <= 0)
    {
      locator->content = (OpaquePtr) allocContent (1, locator->type);
      locator->contentSize = 1;
    }

  element = &((TuiWinElementPtr) locator->content[0])->whichElement.locator;
  element->procName[0] = (char) 0;
  strcat_to_buf (element->procName, MAX_LOCATOR_ELEMENT_LEN, procname);
  element->lineNo = lineno;
  element->addr = addr;
  tui_set_locator_filename (filename);
}

/* Update only the filename portion of the locator.  */
void
tuiUpdateLocatorFilename (const char *filename)
{
  tui_set_locator_filename (filename);
  tuiShowLocatorContent ();
}

/* Function to print the frame information for the TUI.  */
void
tuiShowFrameInfo (struct frame_info *fi)
{
  TuiWinInfoPtr winInfo;
  register int i;

  if (fi)
    {
      register int startLine, i;
      CORE_ADDR low;
      TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
      int sourceAlreadyDisplayed;
      struct symtab_and_line sal;

      find_frame_sal (fi, &sal);

      sourceAlreadyDisplayed = sal.symtab != 0
        && tuiSourceIsDisplayed (sal.symtab->filename);
      tui_set_locator_info (sal.symtab == 0 ? "??" : sal.symtab->filename,
                            tui_get_function_from_frame (fi),
                            sal.line,
                            get_frame_pc (fi));
      tuiShowLocatorContent ();
      startLine = 0;
      for (i = 0; i < (sourceWindows ())->count; i++)
	{
	  TuiWhichElement *item;
	  winInfo = (TuiWinInfoPtr) (sourceWindows ())->list[i];

	  item = &((TuiWinElementPtr) locator->content[0])->whichElement;
	  if (winInfo == srcWin)
	    {
	      startLine = (item->locator.lineNo -
			   (winInfo->generic.viewportHeight / 2)) + 1;
	      if (startLine <= 0)
		startLine = 1;
	    }
	  else
	    {
	      if (find_pc_partial_function (get_frame_pc (fi), (char **) NULL,
					    &low, (CORE_ADDR) NULL) == 0)
		error ("No function contains program counter for selected frame.\n");
	      else
		low = tuiGetLowDisassemblyAddress (low, get_frame_pc (fi));
	    }

	  if (winInfo == srcWin)
	    {
	      TuiLineOrAddress l;
	      l.lineNo = startLine;
	      if (!(sourceAlreadyDisplayed
		    && tuiLineIsDisplayed (item->locator.lineNo, winInfo, TRUE)))
		tuiUpdateSourceWindow (winInfo, sal.symtab, l, TRUE);
	      else
		{
		  l.lineNo = item->locator.lineNo;
		  tuiSetIsExecPointAt (l, winInfo);
		}
	    }
	  else
	    {
	      if (winInfo == disassemWin)
		{
		  TuiLineOrAddress a;
		  a.addr = low;
		  if (!tuiAddrIsDisplayed (item->locator.addr, winInfo, TRUE))
		    tuiUpdateSourceWindow (winInfo, sal.symtab, a, TRUE);
		  else
		    {
		      a.addr = item->locator.addr;
		      tuiSetIsExecPointAt (a, winInfo);
		    }
		}
	    }
	  tuiUpdateExecInfo (winInfo);
	}
    }
  else
    {
      tui_set_locator_info (NULL, NULL, 0, (CORE_ADDR) 0);
      tuiShowLocatorContent ();
      for (i = 0; i < (sourceWindows ())->count; i++)
	{
	  winInfo = (TuiWinInfoPtr) (sourceWindows ())->list[i];
	  tuiClearSourceContent (winInfo, EMPTY_SOURCE_PROMPT);
	  tuiUpdateExecInfo (winInfo);
	}
    }
}

/* Function to initialize gdb commands, for tui window stack manipulation.  */
void
_initialize_tuiStack (void)
{
  add_com ("update", class_tui, tui_update_command,
           "Update the source window and locator to display the current "
           "execution point.\n");
}

/* Command to update the display with the current execution point.  */
static void
tui_update_command (char *arg, int from_tty)
{
  char cmd[sizeof("frame 0")];

  strcpy (cmd, "frame 0");
  execute_command (cmd, from_tty);
}
@


1.28
log
@	* tui-hooks.c: Update include order.
	* tui.c: Likewise.
	* tuiCommand.c: Likewise.
	* tuiData.c: Likewise.
	* tuiDataWin.c: Likewise.
	* tuiDisassem.c: Likewise.
	* tuiGeneralWin.c: Likewise.
	* tuiIO.c: Likewise.
	* tuiLayout.c: Likewise.
	* tuiRegs.c: Likewise.
	* tuiSource.c: Likewise.
	* tuiSourceWin.c: Likewise.
	* tuiStack.c: Likewise.
	* tuiWin.c: Likewise.
@
text
@@


1.28.6.1
log
@merge mainline changes to branch
@
text
@@


1.27
log
@	* Makefile.in (tuiDisassem.o): Update dependencies.

tui:
	* tuiSource.c (tuiVerticalSourceScroll): Use get_frame_pc.
	* tuiSourceWin.c (tuiHorizontalSourceScroll): Likewise.
	* tuiStack.c (tui_get_function_from_frame): Likewise.
	(tuiShowFrameInfo): Likewise.
	* tuiWin.c (_makeVisibleWithNewHeight): Likewise.
	* tui-hooks.c (tui_selected_frame_level_changed_hook): Likewise.
	* tuiDisassem.c (tuiVerticalDisassemScroll): Likewise.
	Include "disasm.h".
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation,
a24 17
/* FIXME: cagney/2002-02-28: The GDB coding standard indicates that
   "defs.h" should be included first.  Unfortunatly some systems
   (currently Debian GNU/Linux) include the <stdbool.h> via <curses.h>
   and they clash with "bfd.h"'s definiton of true/false.  The correct
   fix is to remove true/false from "bfd.h", however, until that
   happens, hack around it by including "config.h" and <curses.h>
   first.  */

#include "config.h"
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

d42 7
@


1.26
log
@2002-12-06  Elena Zannoni  <ezannoni@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Fix typo.
@
text
@d236 1
a236 1
  print_address_symbolic (fi->pc, stream, demangle, "");
d359 1
a359 1
                            fi->pc);
d377 2
a378 1
	      if (find_pc_partial_function (fi->pc, (char **) NULL, &low, (CORE_ADDR) NULL) == 0)
d381 1
a381 1
		low = tuiGetLowDisassemblyAddress (low, fi->pc);
@


1.25
log
@2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (pc_notcurrent): New function.
	(find_frame_sal): New function.
	* frame.h (find_frame_sal): Declare.
	(struct symtab_and_line): Add opaque declaration.
	* stack.c (print_frame_info_base): Use find_pc_line instead of
	find_frame_sal.
	(frame_info): Ditto.
	* ada-lang.c (find_printable_frame): Ditto.

Index: tui/ChangeLog
2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use find_frame_sal instead of
	find_pc_line.
@
text
@d352 1
a352 1
      find_frame_sap (fi, &sal);
@


1.24
log
@2002-11-23  Andrew Cagney  <ac131313@@redhat.com>

	* breakpoint.c: Include "gdb_assert.h".
	(deprecated_frame_in_dummy): Assert that generic dummy frames are
	not being used.
	* Makefile.in (breakpoint.o): Update dependencies.
	* ada-lang.c (find_printable_frame): Use get_frame_type instead of
	deprecated_frame_in_dummy.
	* stack.c (print_frame_info_base): Ditto.
	(frame_info): Ditto.
	(print_frame_info_base): Ditto.  Delete dead code.

Index: tui/ChangeLog
2002-11-23  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	deprecated_frame_in_dummy.  Fix coding style.
@
text
@d352 1
a352 4
      sal = find_pc_line (fi->pc,
                          (fi->next != (struct frame_info *) NULL
			   && !(get_frame_type (fi->next) == SIGTRAMP_FRAME)
			   && !(get_frame_type (fi->next) == DUMMY_FRAME)));
@


1.23
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@d353 3
a355 3
                          (fi->next != (struct frame_info *) NULL &&
                           !(get_frame_type (fi->next) == SIGTRAMP_FRAME) &&
                           !deprecated_frame_in_dummy (fi->next)));
@


1.22
log
@2002-11-10  Andrew Cagney  <ac131313@@redhat.com>

	* breakpoint.h (deprecated_frame_in_dummy): Rename frame_in_dummy.
	* stack.c (print_frame_info_base): Update.
	(print_frame_info_base, frame_info): Update.
	* sparc-tdep.c (sparc_init_extra_frame_info): Update.
	(sparc_frame_saved_pc): Update.
	* ada-lang.c (find_printable_frame): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
@
text
@d354 1
a354 1
                           !fi->next->signal_handler_caller &&
@


1.21
log
@	* tuiStack.c (tui_make_status_line): Make sure the local buffer
	is large enough to hold the complete line.
@
text
@d355 1
a355 1
                           !frame_in_dummy (fi->next)));
@


1.21.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a58 7
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
d236 1
a236 1
  print_address_symbolic (get_frame_pc (fi), stream, demangle, "");
d352 4
a355 1
      find_frame_sal (fi, &sal);
d362 1
a362 1
                            get_frame_pc (fi));
d380 1
a380 2
	      if (find_pc_partial_function (get_frame_pc (fi), (char **) NULL,
					    &low, (CORE_ADDR) NULL) == 0)
d383 1
a383 1
		low = tuiGetLowDisassemblyAddress (low, get_frame_pc (fi));
@


1.21.4.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@@


1.21.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d355 1
a355 1
                           !deprecated_frame_in_dummy (fi->next)));
@


1.21.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d352 4
a355 1
      find_frame_sal (fi, &sal);
@


1.21.2.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a58 7
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
d236 1
a236 1
  print_address_symbolic (get_frame_pc (fi), stream, demangle, "");
d359 1
a359 1
                            get_frame_pc (fi));
d377 1
a377 2
	      if (find_pc_partial_function (get_frame_pc (fi), (char **) NULL,
					    &low, (CORE_ADDR) NULL) == 0)
d380 1
a380 1
		low = tuiGetLowDisassemblyAddress (low, get_frame_pc (fi));
@


1.21.2.4
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.20
log
@	* tuiStack.c (tui_make_status_line): New function to create the
	status line.
	(tuiShowLocatorContent): Use it instead of displayableWinContentAt.
	* tuiData.h (PROC_PREFIX): Use "In:" to reduce length of prefix.
	(PC_PREFIX): Use upper case.
	(SINGLE_KEY, MIN_LINE_WIDTH, MIN_PROC_WIDTH): Define.
	(MAX_TARGET_WIDTH, MAX_PID_WIDTH): Define.
@
text
@d82 3
a84 2
  char line_buf[50], buf[50], *pname;
  int status_size = termWidth ();
d106 2
a107 1
  
d109 1
@


1.20.2.1
log
@	* tuiStack.c (tui_make_status_line): Make sure the local buffer
	is large enough to hold the complete line.
@
text
@d82 2
a83 3
  char line_buf[50], *pname;
  char* buf;
  int status_size;
d105 1
a105 2

  status_size = termWidth ();  
a106 1
  buf = (char*) alloca (status_size + 1);
@


1.19
log
@	* tuiStack.c (tuiSetLocatorContent): Remove.
	(tuiUpdateLocatorInfoFromFrame): Remove.
	(tui_set_locator_info): Allocate the content buffer if necessary.
	(tui_set_locator_filename): Call tui_set_locator_info directly.
	(tuiShowFrameInfo): Likewise and use find_pc_line instead of
	find_pc_symtab.
@
text
@d47 2
d75 148
d267 14
a280 14
      string = displayableWinContentAt (locator, 0);
      if (string != (char *) NULL)
	{
	  wmove (locator->handle, 0, 0);
	  wstandout (locator->handle);
	  waddstr (locator->handle, string);
          wclrtoeol (locator->handle);
	  wstandend (locator->handle);
	  tuiRefreshWin (locator);
	  wmove (locator->handle, 0, 0);
	  if (string != nullStr ())
	    tuiFree (string);
	  locator->contentInUse = TRUE;
	}
d282 1
a283 2
  return;
}				/* tuiShowLocatorContent */
@


1.18
log
@	* tuiSourceWin.c (tuiDisplayMainFunction): Update to use
	tuiUpdateLocatorFilename.
	* tuiStack.c (tuiSetLocatorInfo): Make it static.
	(tuiSetLocatorContent): Likewise.
	(tuiUpdateLocatorInfoFromFrame): Likewise.
	(tuiSwitchFilename): Remove.
	(tui_set_locator_filename): New function
	(tui_set_locator_info): Rename from tuiSetLocatorInfo to GNU-ify;
	use tui_set_locator_filename to record the filename.
	(tuiUpdateLocatorFilename): Likewise.
	(tuiUpdateLocatorInfoFromFrame): Update.
	(tuiSetLocatorContent): Likewise.
	* tuiStack.h (tuiClearLocatorContent): Don't declare.
	(tuiSetLocatorInfo, tuiSetLocatorContent): Likewise.
	(tuiUpdateLocatorInfoFromFrame, tuiSwitchFilename): Likewise.
@
text
@d68 1
a68 2
                                  int lineno, CORE_ADDR addr,
                                  TuiLocatorElementPtr element);
d71 1
a71 3

/* Function to set the content of the locator.  */
static void tuiSetLocatorContent (struct frame_info *frameInfo);
d144 4
a147 1
    tuiSetLocatorContent ((struct frame_info *) NULL);
d157 1
a157 1
                      CORE_ADDR addr, TuiLocatorElementPtr element)
d159 11
a176 1

d185 1
a185 66
/*
   ** tuiUpdateLocatorInfoFromFrame().
   **        Function to update the locator, with the information extracted from frameInfo
 */
static void
tuiUpdateLocatorInfoFromFrame (struct frame_info *frameInfo,
                               TuiLocatorElementPtr element)
{
  struct symtab_and_line symtabAndLine;

  /* now get the new info */
  symtabAndLine = find_pc_line (frameInfo->pc,
			   (frameInfo->next != (struct frame_info *) NULL &&
			    !frameInfo->next->signal_handler_caller &&
			    !frame_in_dummy (frameInfo->next)));
  if (symtabAndLine.symtab && symtabAndLine.symtab->filename)
    tui_set_locator_info (symtabAndLine.symtab->filename,
                          tui_get_function_from_frame (frameInfo),
                          symtabAndLine.line,
                          frameInfo->pc,
                          element);
  else
    tui_set_locator_info ((char *) NULL,
                          tui_get_function_from_frame (frameInfo),
                          0,
                          frameInfo->pc,
                          element);

  return;
}				/* tuiUpdateLocatorInfoFromFrame */


/* Function to set the content of the locator.  */
static void
tuiSetLocatorContent (struct frame_info *frameInfo)
{
  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
  TuiWinElementPtr element;
  struct symtab_and_line symtabAndLine;

  /* Allocate the element if necessary */
  if (locator->contentSize <= 0)
    {
      TuiWinContent contentPtr;

      if ((locator->content = (OpaquePtr) allocContent (1, locator->type)) == (OpaquePtr) NULL)
	error ("Unable to Allocate Memory to Display Location.");
      locator->contentSize = 1;
    }

  if (frameInfo != (struct frame_info *) NULL)
    tuiUpdateLocatorInfoFromFrame (frameInfo,
	   &((TuiWinElementPtr) locator->content[0])->whichElement.locator);
  else
    tui_set_locator_info ((char *) NULL,
                          (char *) NULL,
                          0,
                          (CORE_ADDR) 0,
	   &((TuiWinElementPtr) locator->content[0])->whichElement.locator);
  return;
}				/* tuiSetLocatorContent */

/*
   ** tuiShowFrameInfo().
   **        Function to print the frame inforrmation for the TUI.
 */
a194 1
      register struct symtab *s;
d198 1
d200 12
a211 5

      s = find_pc_symtab (fi->pc);
      if (s == 0)
        return;

a212 3
      sourceAlreadyDisplayed = tuiSourceIsDisplayed (s->filename);
      tuiSetLocatorContent (fi);
      tuiShowLocatorContent ();
d240 1
a240 1
		tuiUpdateSourceWindow (winInfo, s, l, TRUE);
d254 1
a254 1
		    tuiUpdateSourceWindow (winInfo, s, a, TRUE);
d267 1
a267 1
      tuiSetLocatorContent (fi);
d276 1
a276 3

  return;
}				/* tuiShowFrameInfo */
@


1.17
log
@	* tuiStack.h (tuiGetLocatorFilename): Don't declare.
	(tuiUpdateLocatorDisplay): Likewise.
	* tuiStack.c (tuiGetLocatorFilename): Remove.
	(tuiShowFrameInfo): Use tuiSetLocatorContent and tuiShowLocatorContent
	instead of tuiUpdateLocatorDisplay.
	(tuiUpdateLocatorDisplay): Remove.
@
text
@d63 8
d73 2
d139 14
d155 3
a157 3
void
tuiSetLocatorInfo (char *fname, char *procname, int lineNo,
                   CORE_ADDR addr, TuiLocatorElementPtr element)
a158 1
  element->fileName[0] = (char) 0;
a159 1
  strcat_to_buf (element->fileName, MAX_LOCATOR_ELEMENT_LEN, fname);
d161 1
a161 1
  element->lineNo = lineNo;
d163 1
d167 1
a167 4
/*
   ** tuiUpdateLocatorFilename().
   **        Update only the filename portion of the locator.
 */
d169 1
a169 1
tuiUpdateLocatorFilename (const char *fileName)
d171 1
a171 9
  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();

  if (locator->content[0] == (Opaque) NULL)
    tuiSetLocatorContent ((struct frame_info *) NULL);
  ((TuiWinElementPtr) locator->content[0])->whichElement.locator.fileName[0] = (char) 0;
  strcat_to_buf (((TuiWinElementPtr) locator->content[0])->whichElement.locator.fileName,
		 MAX_LOCATOR_ELEMENT_LEN,
		 fileName);

d173 1
a173 28

  return;
}				/* tuiUpdateLocatorFilename */

/*
   ** tuiSwitchFilename().
   **   Update the filename portion of the locator. Clear the other info in locator.
   ** (elz)
 */
void
tuiSwitchFilename (char *fileName)
{
  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();

  if (locator->content[0] == (Opaque) NULL)
    tuiSetLocatorContent ((struct frame_info *) NULL);
  ((TuiWinElementPtr) locator->content[0])->whichElement.locator.fileName[0] = (char) 0;

  tuiSetLocatorInfo (fileName,
		     (char *) NULL,
		     0,
		     (CORE_ADDR) 0,
	   &((TuiWinElementPtr) locator->content[0])->whichElement.locator);

  tuiShowLocatorContent ();

  return;
}				/* tuiSwitchFilename */
d179 1
a179 1
void
d191 5
a195 5
    tuiSetLocatorInfo (symtabAndLine.symtab->filename,
		       tui_get_function_from_frame (frameInfo),
		       symtabAndLine.line,
		       frameInfo->pc,
		       element);
d197 5
a201 5
    tuiSetLocatorInfo ((char *) NULL,
		       tui_get_function_from_frame (frameInfo),
		       0,
		       frameInfo->pc,
		       element);
d207 2
a208 5
/*
   ** tuiSetLocatorContent().
   **        Function to set the content of the locator
 */
void
d229 4
a232 4
    tuiSetLocatorInfo ((char *) NULL,
		       (char *) NULL,
		       0,
		       (CORE_ADDR) 0,
@


1.16
log
@	* tuiStack.h (tuiClearLocatorDisplay): Don't declare.
	* tuiStack.c (tuiClearLocatorDisplay): Remove.
	(tuiShowLocatorContent): Use wclrtoeol to clear end of status line.
	(tuiUpdateLocatorDisplay): Don't call tuiClearLocatorDisplay.
@
text
@a189 26

/*
   ** tuiGetLocatorFilename().
   **   Get the filename portion of the locator.
   ** (elz)
 */
void
tuiGetLocatorFilename (TuiGenWinInfoPtr locator, char **filename)
{

  /* the current filename could be non known, in which case the xmalloc would
     allocate no memory, because the length would be 0 */
  if (((TuiWinElementPtr) locator->content[0])->whichElement.locator.fileName)
    {
      int name_length =
      strlen (((TuiWinElementPtr) locator->content[0])->whichElement.locator.fileName);

      (*filename) = (char *) xmalloc (name_length + 1);
      strcpy ((*filename),
	      ((TuiWinElementPtr) locator->content[0])->whichElement.locator.fileName);
    }

  return;
}				/* tuiGetLocatorFilename */


a254 15

/*
   ** tuiUpdateLocatorDisplay().
   **        Function to update the locator display
 */
void
tuiUpdateLocatorDisplay (struct frame_info *frameInfo)
{
  tuiSetLocatorContent (frameInfo);
  tuiShowLocatorContent ();

  return;
}				/* tuiUpdateLocatorDisplay */


d280 2
a281 1
      tuiUpdateLocatorDisplay (fi);
d336 2
a337 1
      tuiUpdateLocatorDisplay (fi);
@


1.15
log
@	* tuiStack.c (tui_get_function_from_frame): Rename from
	_getFuncNameFromFrame; use print_address_symbolic to get symbolic
	name of address.
	(tuiUpdateLocatorInfoFromFrame): Update.
@
text
@a97 29
   ** tuiClearLocatorDisplay()
 */
void
tuiClearLocatorDisplay (void)
{
  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
  int i;

  if (locator->handle != (WINDOW *) NULL)
    {
      /* No need to werase, since writing a line of
         * blanks which we do below, is equivalent.
       */
      /* werase(locator->handle); */
      wmove (locator->handle, 0, 0);
      wstandout (locator->handle);
      for (i = 0; i < locator->width; i++)
	waddch (locator->handle, ' ');
      wstandend (locator->handle);
      tuiRefreshWin (locator);
      wmove (locator->handle, 0, 0);
      locator->contentInUse = FALSE;
    }

  return;
}				/* tuiClearLocatorDisplay */


/*
d116 1
a288 1
  tuiClearLocatorDisplay ();
@


1.14
log
@	* tuiStack.c (tui_update_command): Rename _tuiUpdateLocation_command
	to follow other gdb's command names; use execute_command; cleanup.
	(_initialize_tuiStack): Update.
@
text
@d55 1
d58 4
a61 3
/*****************************************
** STATIC LOCAL FUNCTIONS FORWARD DECLS    **
******************************************/
a62 1
static char *_getFuncNameFromFrame (struct frame_info *);
d66 30
a95 3
/*****************************************
** PUBLIC FUNCTION                        **
******************************************/
d261 1
a261 1
		       _getFuncNameFromFrame (frameInfo),
d267 1
a267 1
		       _getFuncNameFromFrame (frameInfo),
a424 21


/*****************************************
** STATIC LOCAL FUNCTIONS                 **
******************************************/

/*
   **    _getFuncNameFromFrame().
 */
static char *
_getFuncNameFromFrame (struct frame_info *frameInfo)
{
  char *funcName = (char *) NULL;

  find_pc_partial_function (frameInfo->pc,
			    &funcName,
			    (CORE_ADDR *) NULL,
			    (CORE_ADDR *) NULL);
  return funcName;
}				/* _getFuncNameFromFrame */

@


1.13
log
@Add FIXME explaining include problem.
@
text
@d47 1
d62 1
a62 2
static void _tuiUpdateLocation_command (char *, int);

d389 1
a389 4
/*
   ** _initialize_tuiStack().
   **      Function to initialize gdb commands, for tui window stack manipulation.
 */
d393 3
a395 2
  add_com ("update", class_tui, _tuiUpdateLocation_command,
           "Update the source window and locator to display the current execution point.\n");
d419 1
a419 4
/*
   ** _tuiUpdateLocation_command().
   **        Command to update the display with the current execution point
 */
d421 1
a421 1
_tuiUpdateLocation_command (char *arg, int fromTTY)
d423 1
a423 5
#ifndef TRY
extern void frame_command (char *, int);
  frame_command ("0", FALSE);
#else
  struct frame_info *curFrame;
d425 3
a427 18
  /* Obtain the current execution point */
  if ((curFrame = get_current_frame ()) != (struct frame_info *) NULL)
    {
      struct frame_info *frame;
      int curLevel = 0;

      for (frame = get_prev_frame (curLevel);
	   (frame != (struct frame_info *) NULL && (frame != curFrame));
	   frame = get_prev_frame (frame))
	curLevel++;

      if (curFrame != (struct frame_info *) NULL)
	print_frame_info (frame, curLevel, 0, 1);
    }
#endif

  return;
}				/* _tuiUpdateLocation_command */
@


1.13.8.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a46 1
#include "top.h"
a53 1
#include "tui-file.h"
d56 3
a58 4
/* Get a printable name for the function at the address.
   The symbol name is demangled if demangling is turned on.
   Returns a pointer to a static area holding the result.  */
static char* tui_get_function_from_frame (struct frame_info *fi);
d60 2
a61 2
/* Set the filename portion of the locator.  */
static void tui_set_locator_filename (const char *filename);
a62 3
/* Update the locator, with the provided arguments.  */
static void tui_set_locator_info (const char *filename, const char *procname,
                                  int lineno, CORE_ADDR addr);
a63 2
static void tui_update_command (char *, int);

d65 32
a96 30
/* Get a printable name for the function at the address.
   The symbol name is demangled if demangling is turned on.
   Returns a pointer to a static area holding the result.  */
static char*
tui_get_function_from_frame (struct frame_info *fi)
{
  static char name[256];
  struct ui_file *stream = tui_sfileopen (256);
  char *p;

  print_address_symbolic (fi->pc, stream, demangle, "");
  p = tui_file_get_strbuf (stream);

  /* Use simple heuristics to isolate the function name.  The symbol can
     be demangled and we can have function parameters.  Remove them because
     the status line is too short to display them.  */
  if (*p == '<')
    p++;
  strncpy (name, p, sizeof (name));
  p = strchr (name, '(');
  if (!p)
    p = strchr (name, '>');
  if (p)
    *p = 0;
  p = strchr (name, '+');
  if (p)
    *p = 0;
  ui_file_delete (stream);
  return name;
}
a116 1
          wclrtoeol (locator->handle);
d129 43
a171 3
/* Set the filename portion of the locator.  */
static void
tui_set_locator_filename (const char *filename)
a173 1
  TuiLocatorElementPtr element;
d176 27
d204 6
a209 2
      tui_set_locator_info (filename, NULL, 0, 0);
      return;
d212 35
a246 4
  element = &((TuiWinElementPtr) locator->content[0])->whichElement.locator;
  element->fileName[0] = 0;
  strcat_to_buf (element->fileName, MAX_LOCATOR_ELEMENT_LEN, filename);
}
d248 6
a253 4
/* Update the locator, with the provided arguments.  */
static void
tui_set_locator_info (const char *filename, const char *procname, int lineno,
                      CORE_ADDR addr)
d256 2
a257 1
  TuiLocatorElementPtr element;
d259 1
a259 1
  /* Allocate the locator content if necessary.  */
d262 4
a265 1
      locator->content = (OpaquePtr) allocContent (1, locator->type);
d269 12
a280 7
  element = &((TuiWinElementPtr) locator->content[0])->whichElement.locator;
  element->procName[0] = (char) 0;
  strcat_to_buf (element->procName, MAX_LOCATOR_ELEMENT_LEN, procname);
  element->lineNo = lineno;
  element->addr = addr;
  tui_set_locator_filename (filename);
}
d282 4
a285 1
/* Update only the filename portion of the locator.  */
d287 1
a287 1
tuiUpdateLocatorFilename (const char *filename)
d289 2
a290 1
  tui_set_locator_filename (filename);
a291 1
}
d293 8
a300 1
/* Function to print the frame information for the TUI.  */
d310 1
a313 1
      struct symtab_and_line sal;
d315 5
a319 12
      sal = find_pc_line (fi->pc,
                          (fi->next != (struct frame_info *) NULL &&
                           !fi->next->signal_handler_caller &&
                           !frame_in_dummy (fi->next)));

      sourceAlreadyDisplayed = sal.symtab != 0
        && tuiSourceIsDisplayed (sal.symtab->filename);
      tui_set_locator_info (sal.symtab == 0 ? "??" : sal.symtab->filename,
                            tui_get_function_from_frame (fi),
                            sal.line,
                            fi->pc);
      tuiShowLocatorContent ();
d321 2
d350 1
a350 1
		tuiUpdateSourceWindow (winInfo, sal.symtab, l, TRUE);
d364 1
a364 1
		    tuiUpdateSourceWindow (winInfo, sal.symtab, a, TRUE);
d377 1
a377 2
      tui_set_locator_info (NULL, NULL, 0, (CORE_ADDR) 0);
      tuiShowLocatorContent ();
a384 1
}
d386 7
a392 1
/* Function to initialize gdb commands, for tui window stack manipulation.  */
d396 2
a397 3
  add_com ("update", class_tui, tui_update_command,
           "Update the source window and locator to display the current "
           "execution point.\n");
d400 25
a424 1
/* Command to update the display with the current execution point.  */
d426 1
a426 1
tui_update_command (char *arg, int from_tty)
d428 5
a432 1
  char cmd[sizeof("frame 0")];
d434 18
a451 3
  strcpy (cmd, "frame 0");
  execute_command (cmd, from_tty);
}
@


1.13.8.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a46 2
#include "inferior.h"
#include "target.h"
a72 151
/* Create the status line to display as much information as we
   can on this single line: target name, process number, current
   function, current line, current PC, SingleKey mode.  */
static char*
tui_make_status_line (TuiLocatorElement* loc)
{
  char* string;
  char line_buf[50], *pname;
  char* buf;
  int status_size;
  int i, proc_width;
  const char* pid_name;
  const char* pc_buf;
  int target_width;
  int pid_width;
  int line_width;
  int pc_width;
  struct ui_file *pc_out;

  if (ptid_equal (inferior_ptid, null_ptid))
    pid_name = "No process";
  else
    pid_name = target_pid_to_str (inferior_ptid);

  target_width = strlen (target_shortname);
  if (target_width > MAX_TARGET_WIDTH)
    target_width = MAX_TARGET_WIDTH;

  pid_width = strlen (pid_name);
  if (pid_width > MAX_PID_WIDTH)
    pid_width = MAX_PID_WIDTH;

  status_size = termWidth ();  
  string = (char *) xmalloc (status_size + 1);
  buf = (char*) alloca (status_size + 1);

  /* Translate line number and obtain its size.  */
  if (loc->lineNo > 0)
    sprintf (line_buf, "%d", loc->lineNo);
  else
    strcpy (line_buf, "??");
  line_width = strlen (line_buf);
  if (line_width < MIN_LINE_WIDTH)
    line_width = MIN_LINE_WIDTH;

  /* Translate PC address.  */
  pc_out = tui_sfileopen (128);
  print_address_numeric (loc->addr, 1, pc_out);
  pc_buf = tui_file_get_strbuf (pc_out);
  pc_width = strlen (pc_buf);
  
  /* First determine the amount of proc name width we have available.
     The +1 are for a space separator between fields.
     The -1 are to take into account the \0 counted by sizeof.  */
  proc_width = (status_size
                - (target_width + 1)
                - (pid_width + 1)
                - (sizeof (PROC_PREFIX) - 1 + 1)
                - (sizeof (LINE_PREFIX) - 1 + line_width + 1)
                - (sizeof (PC_PREFIX) - 1 + pc_width + 1)
                - (tui_current_key_mode == tui_single_key_mode
                   ? (sizeof (SINGLE_KEY) - 1 + 1)
                   : 0));

  /* If there is no room to print the function name, try by removing
     some fields.  */
  if (proc_width < MIN_PROC_WIDTH)
    {
      proc_width += target_width + 1;
      target_width = 0;
      if (proc_width < MIN_PROC_WIDTH)
        {
          proc_width += pid_width + 1;
          pid_width = 0;
          if (proc_width <= MIN_PROC_WIDTH)
            {
              proc_width += pc_width + sizeof (PC_PREFIX) - 1 + 1;
              pc_width = 0;
              if (proc_width < 0)
                {
                  proc_width += line_width + sizeof (LINE_PREFIX) - 1 + 1;
                  line_width = 0;
                  if (proc_width < 0)
                    proc_width = 0;
                }
            }
        }
    }

  /* Now convert elements to string form */
  pname = loc->procName;

  /* Now create the locator line from the string version
     of the elements.  We could use sprintf() here but
     that wouldn't ensure that we don't overrun the size
     of the allocated buffer.  strcat_to_buf() will.  */
  *string = (char) 0;

  if (target_width > 0)
    {
      sprintf (buf, "%*.*s ",
               -target_width, target_width, target_shortname);
      strcat_to_buf (string, status_size, buf);
    }
  if (pid_width > 0)
    {
      sprintf (buf, "%*.*s ",
               -pid_width, pid_width, pid_name);
      strcat_to_buf (string, status_size, buf);
    }
  
  /* Show whether we are in SingleKey mode.  */
  if (tui_current_key_mode == tui_single_key_mode)
    {
      strcat_to_buf (string, status_size, SINGLE_KEY);
      strcat_to_buf (string, status_size, " ");
    }

  /* procedure/class name */
  if (proc_width > 0)
    {
      if (strlen (pname) > proc_width)
        sprintf (buf, "%s%*.*s* ", PROC_PREFIX,
                 1 - proc_width, proc_width - 1, pname);
      else
        sprintf (buf, "%s%*.*s ", PROC_PREFIX,
                 -proc_width, proc_width, pname);
      strcat_to_buf (string, status_size, buf);
    }

  if (line_width > 0)
    {
      sprintf (buf, "%s%*.*s ", LINE_PREFIX,
               -line_width, line_width, line_buf);
      strcat_to_buf (string, status_size, buf);
    }
  if (pc_width > 0)
    {
      strcat_to_buf (string, status_size, PC_PREFIX);
      strcat_to_buf (string, status_size, pc_buf);
    }
  
  
  for (i = strlen (string); i < status_size; i++)
    string[i] = ' ';
  string[status_size] = (char) 0;

  ui_file_delete (pc_out);
  return string;
}

d117 14
a130 14
      TuiWinElementPtr element;

      element = (TuiWinElementPtr) locator->content[0];

      string = tui_make_status_line (&element->whichElement.locator);
      wmove (locator->handle, 0, 0);
      wstandout (locator->handle);
      waddstr (locator->handle, string);
      wclrtoeol (locator->handle);
      wstandend (locator->handle);
      tuiRefreshWin (locator);
      wmove (locator->handle, 0, 0);
      xfree (string);
      locator->contentInUse = TRUE;
a131 1
}
d133 2
@


1.12
log
@2002-02-08  Daniel Jacobowitz  <drow@@mvista.com>

        * utils.c: Include <curses.h> before "bfd.h".
        * tui/tui-hooks.c: Likewise.
        * tui/tui.c: Likewise.
        * tui/tuiCommand.c: Likewise.
        * tui/tuiData.c: Likewise.
        * tui/tuiDataWin.c: Likewise.
        * tui/tuiDisassem.c: Likewise.
        * tui/tuiGeneralWin.c: Likewise.
        * tui/tuiIO.c: Likewise.
        * tui/tuiLayout.c: Likewise.
        * tui/tuiRegs.c: Likewise.
        * tui/tuiSource.c: Likewise.
        * tui/tuiSourceWin.c: Likewise.
        * tui/tuiStack.c: Likewise.
        * tui/tuiWin.c: Likewise.
@
text
@d2 4
a5 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d25 8
a32 1
/* If we need <curses.h>, we must include it before we get "bfd.h".  */
@


1.11
log
@	* tuiStack.c (tuiUpdateLocatorFilename): Use const char*.
	* tuiStack.h (tuiUpdateLocatorFilename): Update prototype.
	* tuiWin.c (_initialize_tuiWin): Don't cast table of enum in calls
	to add_set_enum_cmd.
	* tui.c (tui_show_source): New function.
	(tuiGetLowDisassemblyAddress): Use CORE_ADDR for newLow.
	(tui_switch_mode): Prep or deprep readline terminal;
	make sure the \n we return does not redo the last command.
	* tui.h (tui_show_source): Declare.
	(tui_out_new, tui_install_hooks, tui_remove_hooks): Likewise.
	(tui_active, tui_initialize_io, tui_initialize_readline): Likewise.
@
text
@d22 10
@


1.10
log
@	* tuiStack.c (tuiSetLocatorInfo): Cleanup.
	* tuiStack.h (tuiGetLocatorFilename): Declare.
	* tuiRegs.h (tuiFirstRegElementNoInLine): Declare.
	* tuiData.h (addToSourceWindows): Declare.
@
text
@d129 1
a129 1
tuiUpdateLocatorFilename (char *fileName)
@


1.9
log
@	* tuiWin.c (_parseScrollingArgs): Fix uninitialized variable.
	(_makeVisibleWithNewHeight): Use TuiLineOrAddress type.

	* tuiStack.c (tuiShowFrameInfo): Use TuiLineOrAddress type.
	(tui_vUpdateLocatorFilename): Remove.
	* tuiStack.h: Update prototypes.

	* tuiSourceWin.c (tuiAddrIsDisplayed): New function.
	(tuiLineIsDisplayed): Split for address and line.
	(tuiUpdateSourceWindow): Use TuiLineOrAddress type.
	(tuiUpdateSourceWindowAsIs): Likewise.
	(tuiUpdateSourceWindowsWithAddr): Likewise.
	(tuiUpdateSourceWindowsWithLine): Likewise.
	(tuiHorizontalSourceScroll): Likewise.
	(tuiSetIsExecPointAt): Likewise.
	(tuiUpdateOnEnd): Likewise.
	* tuiSourceWin.h: Update prototypes.

	* tuiSource.c (tuiVerticalSourceScroll): Use TuiLineOrAddress type.
	(tuiShowSource): Likewise.
	(tuiVerticalSourceScroll): Likewise.
	* tuiSource.h (tuiShowSource): Update prototype.

	* tuiDisassem.c (tuiSetDisassemContent): Use CORE_ADDR for address.
	(tuiShowDisassem): Use TuiLineOrAddress type.
	(tuiShowDisassemAndUpdateSource): Likewise.
	(tuiVerticalDisassemScroll): Likewise.
	(tuiShowDisassemAsIs): Remove.
	* tuiDisassem.h (tuiSetDisassemContent): Update prototype.

	* tuiData.c (initWinInfo): Use CORE_ADDR for address.
	(clearWinDetail): Likewise.
	(displayableWinContentOf): Fix address conversion.
	(tuiNextWin): Fix crash when the window is not yet created.
	(partialWinByName): Likewise.
@
text
@d110 1
a110 4
/*
   ** tuiSetLocatorInfo().
   **        Function to update the locator, with the provided arguments.
 */
a114 16
#ifdef COMMENT
  /* first free the old info */
  if (element->fileName)
    tuiFree (element->fileName);
  if (element->procName)
    tuiFree (element->procName);

  if (fname == (char *) NULL)
    element->fileName = fname;
  else
    element->fileName = tuiStrDup (fname);
  if (procname == (char *) NULL)
    element->procName = procname;
  else
    element->procName = tuiStrDup (procname);
#else
a118 1
#endif
d121 1
a121 3

  return;
}				/* tuiSetLocatorInfo */
@


1.8
log
@	* tuiWin.c (_initialize_tuiWin): Always define the tui commands;
	create the tui class help.
	* tuiLayout.c (_initialize_tuiLayout): Always define the tui commands.
	* tuiRegs.c (_initialize_tuiRegs): Likewise.
	* tuiStack.c (_initialize_tuiStack): Likewise.
@
text
@a166 17

/*
   ** tui_vUpdateLocatorFilename().
   **        Update only the filename portion of the locator with args in a va_list.
 */
void
tui_vUpdateLocatorFilename (va_list args)
{
  char *fileName;

  fileName = va_arg (args, char *);
  tuiUpdateLocatorFilename (fileName);

  return;
}				/* tui_vUpdateLocatorFilename */


d322 1
d327 1
d329 2
d333 2
a334 3
	      startLine =
		(((TuiWinElementPtr) locator->content[0])->whichElement.locator.lineNo -
		 (winInfo->generic.viewportHeight / 2)) + 1;
d348 5
a352 4
	      if (!(sourceAlreadyDisplayed && m_tuiLineDisplayedWithinThreshold (
								    winInfo,
										  ((TuiWinElementPtr) locator->content[0])->whichElement.locator.lineNo)))
		tuiUpdateSourceWindow (winInfo, s, (Opaque) startLine, TRUE);
d354 4
a357 3
		tuiSetIsExecPointAt ((Opaque)
				     ((TuiWinElementPtr) locator->content[0])->whichElement.locator.lineNo,
				     winInfo);
d363 4
a366 3
		  if (!m_tuiLineDisplayedWithinThreshold (winInfo,
							  ((TuiWinElementPtr) locator->content[0])->whichElement.locator.addr))
		    tuiUpdateSourceWindow (winInfo, s, (Opaque) low, TRUE);
d368 4
a371 3
		    tuiSetIsExecPointAt ((Opaque)
					 ((TuiWinElementPtr) locator->content[0])->whichElement.locator.addr,
					 winInfo);
a389 17


/*
   ** tui_vShowFrameInfo().
   **        Function to print the frame inforrmation for the TUI with args in a va_list.
 */
void
tui_vShowFrameInfo (va_list args)
{
  struct frame_info *fi;

  fi = va_arg (args, struct frame_info *);
  tuiShowFrameInfo (fi);

  return;
}				/* tui_vShowFrameInfo */

@


1.7
log
@	* tuiData.h (TuiLocatorElement): Use CORE_ADDR for address member.
	(TuiLineOrAddress): Likewise.
	* tuiDisassem.c (tuiGetBeginAsmAddress): Use CORE_ADDR to specify
	an address.
	(tuiSetDisassemContent): Likewise.
	(tuiShowDisassem, tuiShowDisassemAndUpdateSource): Likewise.
	* tuiLayout.c (_extractDisplayStartAddr): Likewise.
	(tuiSetLayout): Likewise.
	* tuiSourceWin.c (tuiDisplayMainFunction): Likewise.
	(tuiUpdateSourceWindowsWithAddr): Likewise.
	(tuiUpdateSourceWindowsWithLine): Likewise.
	(tuiSetHasBreakAt): Likewise.
	* tuiStack.c (tuiSetLocatorInfo): Likewise.
	(tuiSwitchFilename): Likewise.
	(tuiUpdateLocatorInfoFromFrame): Likewise.
	(tuiSetLocatorContent): Likewise.
	(tuiShowFrameInfo): Likewise.
	* tuiDisassem.h: Update prototypes to use CORE_ADDR.
	* tuiSourceWin.h: Likewise.
	* tuiStack.h: Likewise.
@
text
@d425 3
a427 8
  if (tui_version)
    {
      add_com ("update", class_tui, _tuiUpdateLocation_command,
	       "Update the source window and locator to display the current execution point.\n");
    }

  return;
}				/* _initialize_tuiStack */
@


1.6
log
@	* tuiStack.c: Add missing includes.
	(tuiShowFrameInfo): Don't crash when there is no symbol table
	associated with the pc.
	* tuiSource.c (_hasBreak): Check for null source file.
	* tuiWin.c (tuiRefreshAll): Check for null winList[type].
	(_tuiSetFocus): Check for null dataWin.
	* tuiGeneralWin.c (refreshAll): Check for null list[type].
@
text
@d116 1
a116 1
                   Opaque addr, TuiLocatorElementPtr element)
d140 1
a140 1
  element->addr = (Opaque) addr;
d201 1
a201 1
		     (Opaque) NULL,
d254 1
a254 1
		       (Opaque) frameInfo->pc,
d260 1
a260 1
		       (Opaque) frameInfo->pc,
d295 1
a295 1
		       (Opaque) NULL,
d357 1
a357 1
		low = (CORE_ADDR) tuiGetLowDisassemblyAddress ((Opaque) low, (Opaque) fi->pc);
@


1.5
log
@	* tuiWin.c, tui.c, tuiCommand.c: Use ansi prototype.
	tuiIO.c, tuiData.c: Likewise.
	tuiDataWin.c, tuiDisassem.c: Likewise.
	tuiGeneralWin.c, tuiLayout.c: Likewise.
	tuiRegs.c, tuiSource.c: Likewise.
	tuiSouceWin.c, tuiStack.c: Likewise.
@
text
@d26 1
d31 2
d336 3
@


1.4
log
@	* tuiWin.c, tuiWin.h, tui.c, tui.h, tuiCommand.c: Add FSF copyright.
	tuiCommand.h, tuiIO.c, tuiIO.h, tuiData.h, tuiData.c: Likewise.
	tuiDataWin.c, tuiDataWin.h, tuiDisassem.c, tuiDisassem.h: Likewise.
	tuiGeneralWin.c, tuiGeneralWin.h, tuiLayout.c, tuiLayout.h: Likewise.
	tuiRegs.c, tuiRegs.h, tuiSource.c, tuiSource.h: Likewise.
	tuiSouceWin.c, tuiSourceWin.h, tuiStack.c, tuiStack.h: Likewise.
@
text
@a49 1
#ifdef __STDC__
a50 3
#else
tuiClearLocatorDisplay ()
#endif
a78 1
#ifdef __STDC__
a79 3
#else
tuiShowLocatorContent ()
#endif
d112 2
a113 15
#ifdef __STDC__
tuiSetLocatorInfo (
		    char *fname,
		    char *procname,
		    int lineNo,
		    Opaque addr,
		    TuiLocatorElementPtr element)
#else
tuiSetLocatorInfo (fname, procname, lineNo, addr, element)
     char *fname;
     char *procname;
     int lineNo;
     Opaque addr;
     TuiLocatorElementPtr element;
#endif
d148 1
a148 7
#ifdef __STDC__
tuiUpdateLocatorFilename (
			   char *fileName)
#else
tuiUpdateLocatorFilename (fileName)
     char *fileName;
#endif
d170 1
a170 7
#ifdef __STDC__
tui_vUpdateLocatorFilename (
			     va_list args)
#else
tui_vUpdateLocatorFilename (args)
     va_list args;
#endif
d187 1
a187 7
#ifdef __STDC__
tuiSwitchFilename (
		    char *fileName)
#else
tuiSwitchFilename (fileName)
     char *fileName;
#endif
d213 1
a213 9
#ifdef __STDC__
tuiGetLocatorFilename (
			TuiGenWinInfoPtr locator,
			char **filename)
#else
tuiGetLocatorFilename (locator, filename)
     TuiGenWinInfoPtr locator;
     char **filename;
#endif
d237 2
a238 9
#ifdef __STDC__
tuiUpdateLocatorInfoFromFrame (
				struct frame_info *frameInfo,
				TuiLocatorElementPtr element)
#else
tuiUpdateLocatorInfoFromFrame (frameInfo, element)
     struct frame_info *frameInfo;
     TuiLocatorElementPtr element;
#endif
d269 1
a269 7
#ifdef __STDC__
tuiSetLocatorContent (
		       struct frame_info *frameInfo)
#else
tuiSetLocatorContent (frameInfo)
     struct frame_info *frameInfo;
#endif
d303 1
a303 7
#ifdef __STDC__
tuiUpdateLocatorDisplay (
			  struct frame_info *frameInfo)
#else
tuiUpdateLocatorDisplay (frameInfo)
     struct frame_info *frameInfo;
#endif
d318 1
a318 7
#ifdef __STDC__
tuiShowFrameInfo (
		   struct frame_info *fi)
#else
tuiShowFrameInfo (fi)
     struct frame_info *fi;
#endif
d401 1
a401 7
#ifdef __STDC__
tui_vShowFrameInfo (
		     va_list args)
#else
tui_vShowFrameInfo (args)
     va_list args;
#endif
d437 1
a437 7
#ifdef __STDC__
_getFuncNameFromFrame (
			struct frame_info *frameInfo)
#else
_getFuncNameFromFrame (frameInfo)
     struct frame_info *frameInfo;
#endif
d454 1
a454 9
#ifdef __STDC__
_tuiUpdateLocation_command (
			     char *arg,
			     int fromTTY)
#else
_tuiUpdateLocation_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
@


1.3
log
@Protoization.
@
text
@d1 20
a20 3
/*
   ** This module contains functions for displaying the locator information in the locator window.
 */
@


1.2
log
@PARAMS removal.
@
text
@d478 1
a478 1
_initialize_tuiStack ()
@


1.1
log
@Initial revision
@
text
@d2 2
a3 2
** This module contains functions for displaying the locator information in the locator window.
*/
d20 2
a21 2
static char *_getFuncNameFromFrame PARAMS ((struct frame_info *));
static void _tuiUpdateLocation_command PARAMS ((char *, int));
d30 2
a31 2
** tuiClearLocatorDisplay()
*/
d46 1
a46 1
         */
d63 2
a64 2
** tuiShowLocatorContent()
*/
d99 3
a101 3
** tuiSetLocatorInfo().
**        Function to update the locator, with the provided arguments.
*/
d148 3
a150 3
** tuiUpdateLocatorFilename().
**        Update only the filename portion of the locator.
*/
d176 3
a178 3
** tui_vUpdateLocatorFilename().
**        Update only the filename portion of the locator with args in a va_list.
*/
d198 4
a201 4
** tuiSwitchFilename().
**   Update the filename portion of the locator. Clear the other info in locator.
** (elz)
*/
d230 4
a233 4
** tuiGetLocatorFilename().
**   Get the filename portion of the locator.
** (elz)
*/
d263 3
a265 3
** tuiUpdateLocatorInfoFromFrame().
**        Function to update the locator, with the information extracted from frameInfo
*/
d302 3
a304 3
** tuiSetLocatorContent().
**        Function to set the content of the locator
*/
d342 3
a344 3
** tuiUpdateLocatorDisplay().
**        Function to update the locator display
*/
d363 3
a365 3
** tuiShowFrameInfo().
**        Function to print the frame inforrmation for the TUI.
*/
d452 3
a454 3
** tui_vShowFrameInfo().
**        Function to print the frame inforrmation for the TUI with args in a va_list.
*/
d474 3
a476 3
** _initialize_tuiStack().
**      Function to initialize gdb commands, for tui window stack manipulation.
*/
d495 2
a496 2
**    _getFuncNameFromFrame().
*/
d517 3
a519 3
** _tuiUpdateLocation_command().
**        Command to update the display with the current execution point
*/
d532 1
a532 1
  extern void frame_command PARAMS ((char *, int));
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d2 2
a3 2
   ** This module contains functions for displaying the locator information in the locator window.
 */
d30 2
a31 2
   ** tuiClearLocatorDisplay()
 */
d46 1
a46 1
       */
d63 2
a64 2
   ** tuiShowLocatorContent()
 */
d99 3
a101 3
   ** tuiSetLocatorInfo().
   **        Function to update the locator, with the provided arguments.
 */
d148 3
a150 3
   ** tuiUpdateLocatorFilename().
   **        Update only the filename portion of the locator.
 */
d176 3
a178 3
   ** tui_vUpdateLocatorFilename().
   **        Update only the filename portion of the locator with args in a va_list.
 */
d198 4
a201 4
   ** tuiSwitchFilename().
   **   Update the filename portion of the locator. Clear the other info in locator.
   ** (elz)
 */
d230 4
a233 4
   ** tuiGetLocatorFilename().
   **   Get the filename portion of the locator.
   ** (elz)
 */
d263 3
a265 3
   ** tuiUpdateLocatorInfoFromFrame().
   **        Function to update the locator, with the information extracted from frameInfo
 */
d302 3
a304 3
   ** tuiSetLocatorContent().
   **        Function to set the content of the locator
 */
d342 3
a344 3
   ** tuiUpdateLocatorDisplay().
   **        Function to update the locator display
 */
d363 3
a365 3
   ** tuiShowFrameInfo().
   **        Function to print the frame inforrmation for the TUI.
 */
d452 3
a454 3
   ** tui_vShowFrameInfo().
   **        Function to print the frame inforrmation for the TUI with args in a va_list.
 */
d474 3
a476 3
   ** _initialize_tuiStack().
   **      Function to initialize gdb commands, for tui window stack manipulation.
 */
d495 2
a496 2
   **    _getFuncNameFromFrame().
 */
d517 3
a519 3
   ** _tuiUpdateLocation_command().
   **        Command to update the display with the current execution point
 */
@

