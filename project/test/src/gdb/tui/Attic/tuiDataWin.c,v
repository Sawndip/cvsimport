head	1.8;
access;
symbols
	drow-cplus-merge-20040113:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.7
	kettenis_sparc-20030918-branch:1.7.0.8
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.6
	cagney_x86i386-20030821-branch:1.7.0.4
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.2
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.6.0.50
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.48
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.46
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.44
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.42
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.40
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.38
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.36
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.34
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.32
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.30
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.28
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.26
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.24
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030203-mergepoint:1.6
	interps-20030202-branch:1.6.0.22
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.20
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.6
	carlton_dictionary-20021115-merge:1.6
	kseitz_interps-20021105-merge:1.6
	kseitz_interps-20021103-merge:1.6
	drow-cplus-merge-20021020:1.6
	drow-cplus-merge-20021025:1.6
	carlton_dictionary-20021025-merge:1.6
	carlton_dictionary-20021011-merge:1.6
	drow-cplus-branch:1.6.0.18
	drow-cplus-branchpoint:1.6
	kseitz_interps-20020930-merge:1.6
	carlton_dictionary-20020927-merge:1.6
	carlton_dictionary-branch:1.6.0.16
	carlton_dictionary-20020920-branchpoint:1.6
	gdb_5_3-branch:1.6.0.14
	gdb_5_3-2002-09-04-branchpoint:1.6
	kseitz_interps-20020829-merge:1.6
	cagney_sysregs-20020825-branch:1.6.0.12
	cagney_sysregs-20020825-branchpoint:1.6
	readline_4_3-import-branch:1.6.0.10
	readline_4_3-import-branchpoint:1.6
	gdb_5_2_1-2002-07-23-release:1.6
	kseitz_interps-20020528-branch:1.6.0.8
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.6
	cagney_regbuf-20020515-branchpoint:1.6
	jimb-macro-020506-branch:1.6.0.4
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	gdb_5_2-branch:1.6.0.2
	gdb_5_2-2002-03-03-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	dberlin-typesystem-branch:1.1.1.2.0.6
	dberlin-typesystem-branchpoint:1.1.1.2
	gdb-post-ptid_t-2001-05-03:1.1.1.2
	gdb-pre-ptid_t-2001-05-03:1.1.1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb-post-protoization-2000-07-29:1.1.1.2
	gdb-pre-protoization-2000-07-29:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb-post-params-removal-2000-06-04:1.1.1.2
	gdb-pre-params-removal-2000-06-04:1.1.1.2
	gdb-post-params-removal-2000-05-28:1.1.1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2004.01.19.04.31.51;	author cagney;	state dead;
branches;
next	1.7;

1.7
date	2003.06.22.15.21.38;	author drow;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2002.03.01.06.19.28;	author cagney;	state Exp;
branches
	1.6.16.1
	1.6.18.1;
next	1.5;

1.5
date	2002.02.08.15.54.32;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.20.22.26.54;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.14.19.31.09;	author ciceron;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.14.19.01.25;	author ciceron;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.12;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.12;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.19.14;	author jsm;	state Exp;
branches;
next	;

1.6.16.1
date	2003.06.27.21.50.21;	author carlton;	state Exp;
branches;
next	1.6.16.2;

1.6.16.2
date	2004.01.26.19.11.45;	author carlton;	state dead;
branches;
next	;

1.6.18.1
date	2003.12.14.20.27.59;	author drow;	state Exp;
branches;
next	1.6.18.2;

1.6.18.2
date	2004.02.09.19.43.58;	author drow;	state dead;
branches;
next	;

1.7.6.1
date	2004.03.23.20.09.16;	author ezannoni;	state dead;
branches;
next	;


desc
@@


1.8
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@/* Data/register window display.

   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "tui.h"
#include "tuiData.h"
#include "tuiGeneralWin.h"
#include "tuiRegs.h"

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif


/*****************************************
** STATIC LOCAL FUNCTIONS FORWARD DECLS    **
******************************************/



/*****************************************
** PUBLIC FUNCTIONS                        **
******************************************/


/*
   ** tuiFirstDataItemDisplayed()
   **    Answer the index first element displayed.
   **    If none are displayed, then return (-1).
 */
int
tuiFirstDataItemDisplayed (void)
{
  int elementNo = (-1);
  int i;

  for (i = 0; (i < dataWin->generic.contentSize && elementNo < 0); i++)
    {
      TuiGenWinInfoPtr dataItemWin;

      dataItemWin = &((TuiWinContent)
		      dataWin->generic.content)[i]->whichElement.dataWindow;
      if (dataItemWin->handle != (WINDOW *) NULL && dataItemWin->isVisible)
	elementNo = i;
    }

  return elementNo;
}				/* tuiFirstDataItemDisplayed */


/*
   ** tuiFirstDataElementNoInLine()
   **        Answer the index of the first element in lineNo.  If lineNo is
   **        past the data area (-1) is returned.
 */
int
tuiFirstDataElementNoInLine (int lineNo)
{
  int firstElementNo = (-1);

  /*
     ** First see if there is a register on lineNo, and if so, set the
     ** first element number
   */
  if ((firstElementNo = tuiFirstRegElementNoInLine (lineNo)) == -1)
    {				/*
				   ** Looking at the general data, the 1st element on lineNo
				 */
    }

  return firstElementNo;
}				/* tuiFirstDataElementNoInLine */


/*
   ** tuiDeleteDataContentWindows()
   **        Function to delete all the item windows in the data window.
   **        This is usually done when the data window is scrolled.
 */
void
tuiDeleteDataContentWindows (void)
{
  int i;
  TuiGenWinInfoPtr dataItemWinPtr;

  for (i = 0; (i < dataWin->generic.contentSize); i++)
    {
      dataItemWinPtr = &((TuiWinContent)
		      dataWin->generic.content)[i]->whichElement.dataWindow;
      tuiDelwin (dataItemWinPtr->handle);
      dataItemWinPtr->handle = (WINDOW *) NULL;
      dataItemWinPtr->isVisible = FALSE;
    }

  return;
}				/* tuiDeleteDataContentWindows */


void
tuiEraseDataContent (char *prompt)
{
  werase (dataWin->generic.handle);
  checkAndDisplayHighlightIfNeeded (dataWin);
  if (prompt != (char *) NULL)
    {
      int halfWidth = (dataWin->generic.width - 2) / 2;
      int xPos;

      if (strlen (prompt) >= halfWidth)
	xPos = 1;
      else
	xPos = halfWidth - strlen (prompt);
      mvwaddstr (dataWin->generic.handle,
		 (dataWin->generic.height / 2),
		 xPos,
		 prompt);
    }
  wrefresh (dataWin->generic.handle);

  return;
}				/* tuiEraseDataContent */


/*
   ** tuiDisplayAllData().
   **        This function displays the data that is in the data window's
   **        content.  It does not set the content.
 */
void
tuiDisplayAllData (void)
{
  if (dataWin->generic.contentSize <= 0)
    tuiEraseDataContent (NO_DATA_STRING);
  else
    {
      tuiEraseDataContent ((char *) NULL);
      tuiDeleteDataContentWindows ();
      checkAndDisplayHighlightIfNeeded (dataWin);
      tuiDisplayRegistersFrom (0);
      /*
         ** Then display the other data
       */
      if (dataWin->detail.dataDisplayInfo.dataContent !=
	  (TuiWinContent) NULL &&
	  dataWin->detail.dataDisplayInfo.dataContentCount > 0)
	{
	}
    }
  return;
}				/* tuiDisplayAllData */


/*
   ** tuiDisplayDataFromLine()
   **        Function to display the data starting at line, lineNo, in the
   **        data window.
 */
void
tuiDisplayDataFromLine (int lineNo)
{
  int _lineNo = lineNo;

  if (lineNo < 0)
    _lineNo = 0;

  checkAndDisplayHighlightIfNeeded (dataWin);

  /* there is no general data, force regs to display (if there are any) */
  if (dataWin->detail.dataDisplayInfo.dataContentCount <= 0)
    tuiDisplayRegistersFromLine (_lineNo, TRUE);
  else
    {
      int elementNo, startLineNo;
      int regsLastLine = tuiLastRegsLineNo ();


      /* display regs if we can */
      if (tuiDisplayRegistersFromLine (_lineNo, FALSE) < 0)
	{			/*
				   ** _lineNo is past the regs display, so calc where the
				   ** start data element is
				 */
	  if (regsLastLine < _lineNo)
	    {			/* figure out how many lines each element is to obtain
				   the start elementNo */
	    }
	}
      else
	{			/*
				   ** calculate the starting element of the data display, given
				   ** regsLastLine and how many lines each element is, up to
				   ** _lineNo
				 */
	}
      /* Now display the data , starting at elementNo */
    }

  return;
}				/* tuiDisplayDataFromLine */


/*
   ** tuiDisplayDataFrom()
   **        Display data starting at element elementNo
 */
void
tuiDisplayDataFrom (int elementNo, int reuseWindows)
{
  int firstLine = (-1);

  if (elementNo < dataWin->detail.dataDisplayInfo.regsContentCount)
    firstLine = tuiLineFromRegElementNo (elementNo);
  else
    {				/* calculate the firstLine from the element number */
    }

  if (firstLine >= 0)
    {
      tuiEraseDataContent ((char *) NULL);
      if (!reuseWindows)
	tuiDeleteDataContentWindows ();
      tuiDisplayDataFromLine (firstLine);
    }

  return;
}				/* tuiDisplayDataFrom */


/*
   ** tuiRefreshDataWin()
   **        Function to redisplay the contents of the data window.
 */
void
tuiRefreshDataWin (void)
{
  tuiEraseDataContent ((char *) NULL);
  if (dataWin->generic.contentSize > 0)
    {
      int firstElement = tuiFirstDataItemDisplayed ();

      if (firstElement >= 0)	/* re-use existing windows */
	tuiDisplayDataFrom (firstElement, TRUE);
    }

  return;
}				/* tuiRefreshDataWin */


/*
   ** tuiCheckDataValues().
   **        Function to check the data values and hilite any that have changed
 */
void
tuiCheckDataValues (struct frame_info *frame)
{
  tuiCheckRegisterValues (frame);

  /* Now check any other data values that there are */
  if (m_winPtrNotNull (dataWin) && dataWin->generic.isVisible)
    {
      int i;

      for (i = 0; dataWin->detail.dataDisplayInfo.dataContentCount; i++)
	{
#ifdef LATER
	  TuiDataElementPtr dataElementPtr;
	  TuiGenWinInfoPtr dataItemWinPtr;
	  Opaque newValue;

	  dataItemPtr = &dataWin->detail.dataDisplayInfo.
	    dataContent[i]->whichElement.dataWindow;
	  dataElementPtr = &((TuiWinContent)
			     dataItemWinPtr->content)[0]->whichElement.data;
	  if value
	    has changed (dataElementPtr, frame, &newValue)
	    {
	      dataElementPtr->value = newValue;
	      update the display with the new value, hiliting it.
	    }
#endif
	}
    }
}				/* tuiCheckDataValues */


/*
   ** tuiVerticalDataScroll()
   **        Scroll the data window vertically forward or backward.
 */
void
tuiVerticalDataScroll (TuiScrollDirection scrollDirection, int numToScroll)
{
  int firstElementNo;
  int firstLine = (-1);

  firstElementNo = tuiFirstDataItemDisplayed ();
  if (firstElementNo < dataWin->detail.dataDisplayInfo.regsContentCount)
    firstLine = tuiLineFromRegElementNo (firstElementNo);
  else
    {				/* calculate the first line from the element number which is in
				   ** the general data content
				 */
    }

  if (firstLine >= 0)
    {
      int lastElementNo, lastLine;

      if (scrollDirection == FORWARD_SCROLL)
	firstLine += numToScroll;
      else
	firstLine -= numToScroll;
      tuiEraseDataContent ((char *) NULL);
      tuiDeleteDataContentWindows ();
      tuiDisplayDataFromLine (firstLine);
    }

  return;
}				/* tuiVerticalDataScroll */


/*****************************************
** STATIC LOCAL FUNCTIONS               **
******************************************/
@


1.7
log
@	* tui-hooks.c: Update include order.
	* tui.c: Likewise.
	* tuiCommand.c: Likewise.
	* tuiData.c: Likewise.
	* tuiDataWin.c: Likewise.
	* tuiDisassem.c: Likewise.
	* tuiGeneralWin.c: Likewise.
	* tuiIO.c: Likewise.
	* tuiLayout.c: Likewise.
	* tuiRegs.c: Likewise.
	* tuiSource.c: Likewise.
	* tuiSourceWin.c: Likewise.
	* tuiStack.c: Likewise.
	* tuiWin.c: Likewise.
@
text
@@


1.7.6.1
log
@merge mainline changes to branch
@
text
@@


1.6
log
@Add FIXME explaining include problem.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation,
d25 5
a29 7
/* FIXME: cagney/2002-02-28: The GDB coding standard indicates that
   "defs.h" should be included first.  Unfortunatly some systems
   (currently Debian GNU/Linux) include the <stdbool.h> via <curses.h>
   and they clash with "bfd.h"'s definiton of true/false.  The correct
   fix is to remove true/false from "bfd.h", however, until that
   happens, hack around it by including "config.h" and <curses.h>
   first.  */
a30 1
#include "config.h"
a37 6

#include "defs.h"
#include "tui.h"
#include "tuiData.h"
#include "tuiGeneralWin.h"
#include "tuiRegs.h"
@


1.6.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 7
a31 5
#include "defs.h"
#include "tui.h"
#include "tuiData.h"
#include "tuiGeneralWin.h"
#include "tuiRegs.h"
d33 1
d41 6
@


1.6.18.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@@


1.6.16.1
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 7
a31 5
#include "defs.h"
#include "tui.h"
#include "tuiData.h"
#include "tuiGeneralWin.h"
#include "tuiRegs.h"
d33 1
d41 6
@


1.6.16.2
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.5
log
@2002-02-08  Daniel Jacobowitz  <drow@@mvista.com>

        * utils.c: Include <curses.h> before "bfd.h".
        * tui/tui-hooks.c: Likewise.
        * tui/tui.c: Likewise.
        * tui/tuiCommand.c: Likewise.
        * tui/tuiData.c: Likewise.
        * tui/tuiDataWin.c: Likewise.
        * tui/tuiDisassem.c: Likewise.
        * tui/tuiGeneralWin.c: Likewise.
        * tui/tuiIO.c: Likewise.
        * tui/tuiLayout.c: Likewise.
        * tui/tuiRegs.c: Likewise.
        * tui/tuiSource.c: Likewise.
        * tui/tuiSourceWin.c: Likewise.
        * tui/tuiStack.c: Likewise.
        * tui/tuiWin.c: Likewise.
@
text
@d2 4
a5 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d25 8
a32 1
/* If we need <curses.h>, we must include it before we get "bfd.h".  */
@


1.4
log
@	* tuiSourceWin.h: Remove unused declarations.
	* tuiSourceWin.c (tui_vUpdateSourceWindowsWithAddr): Remove.
	(tui_vUpdateSourceWindowsWithLine): Remove.
	(tui_vAllSetHasBreakAt): Remove.

	* tuiLayout.h (tui_set_layout): Declare.
	(tui_vSetLayoutTo): Remove.
	(tui_vAddWinToLayout): Remove.
	* tuiLayout.c (_tuiLayout_command): Call tui_enable() to force TUI.
	(_tuiToggleLayout_command): Remove.
	(_tuiToggleSplitLayout_command): Remove.
	(_tuiLayout_command): Remove.
	(tui_vSetLayoutTo): Remove.
	(tui_vAddWinToLayout): Remove.

	* tuiDataWin.h (tui_vCheckDataValues): Remove.
	* tuiDataWin.c (tui_vCheckDataValues): Remove.
@
text
@d22 10
@


1.3
log
@	* tuiWin.c, tui.c, tuiCommand.c: Use ansi prototype.
	tuiIO.c, tuiData.c: Likewise.
	tuiDataWin.c, tuiDisassem.c: Likewise.
	tuiGeneralWin.c, tuiLayout.c: Likewise.
	tuiRegs.c, tuiSource.c: Likewise.
	tuiSouceWin.c, tuiStack.c: Likewise.
@
text
@d25 1
a297 16


/*
   ** tui_vCheckDataValues().
   **        Function to check the data values and hilite any that have
   **        changed with args in a va_list
 */
void
tui_vCheckDataValues (va_list args)
{
  struct frame_info *frame = va_arg (args, struct frame_info *);

  tuiCheckDataValues (frame);

  return;
}				/* tui_vCheckDataValues */
@


1.2
log
@	* tuiWin.c, tuiWin.h, tui.c, tui.h, tuiCommand.c: Add FSF copyright.
	tuiCommand.h, tuiIO.c, tuiIO.h, tuiData.h, tuiData.c: Likewise.
	tuiDataWin.c, tuiDataWin.h, tuiDisassem.c, tuiDisassem.h: Likewise.
	tuiGeneralWin.c, tuiGeneralWin.h, tuiLayout.c, tuiLayout.h: Likewise.
	tuiRegs.c, tuiRegs.h, tuiSource.c, tuiSource.h: Likewise.
	tuiSouceWin.c, tuiSourceWin.h, tuiStack.c, tuiStack.h: Likewise.
@
text
@a44 1
#ifdef __STDC__
a45 3
#else
tuiFirstDataItemDisplayed ()
#endif
d70 1
a70 7
#ifdef __STDC__
tuiFirstDataElementNoInLine (
			      int lineNo)
#else
tuiFirstDataElementNoInLine (lineNo)
     int lineNo;
#endif
a93 1
#ifdef __STDC__
a94 3
#else
tuiDeleteDataContentWindows ()
#endif
d113 1
a113 7
#ifdef __STDC__
tuiEraseDataContent (
		      char *prompt)
#else
tuiEraseDataContent (prompt)
     char *prompt;
#endif
a142 1
#ifdef __STDC__
a143 3
#else
tuiDisplayAllData ()
#endif
d172 1
a172 7
#ifdef __STDC__
tuiDisplayDataFromLine (
			 int lineNo)
#else
tuiDisplayDataFromLine (lineNo)
     int lineNo;
#endif
d220 1
a220 9
#ifdef __STDC__
tuiDisplayDataFrom (
		     int elementNo,
		     int reuseWindows)
#else
tuiDisplayDataFrom (elementNo, reuseWindows)
     int elementNo;
     int reuseWindows;
#endif
a246 1
#ifdef __STDC__
a247 3
#else
tuiRefreshDataWin ()
#endif
d267 1
a267 7
#ifdef __STDC__
tuiCheckDataValues (
		     struct frame_info *frame)
#else
tuiCheckDataValues (frame)
     struct frame_info *frame;
#endif
d305 1
a305 7
#ifdef __STDC__
tui_vCheckDataValues (
		       va_list args)
#else
tui_vCheckDataValues (args)
     va_list args;
#endif
d320 1
a320 9
#ifdef __STDC__
tuiVerticalDataScroll (
			TuiScrollDirection scrollDirection,
			int numToScroll)
#else
tuiVerticalDataScroll (scrollDirection, numToScroll)
     TuiScrollDirection scrollDirection;
     int numToScroll;
#endif
@


1.1
log
@Initial revision
@
text
@d1 20
a20 5
/*
** tuiDataWin.c
**   This module contains functions to support the data/register window display.
*/

d40 4
a43 4
** tuiFirstDataItemDisplayed()
**    Answer the index first element displayed.
**    If none are displayed, then return (-1).
*/
d69 4
a72 4
** tuiFirstDataElementNoInLine()
**        Answer the index of the first element in lineNo.  If lineNo is
**        past the data area (-1) is returned.
*/
d85 3
a87 3
    ** First see if there is a register on lineNo, and if so, set the
    ** first element number
    */
d90 2
a91 2
      ** Looking at the general data, the 1st element on lineNo
      */
d99 4
a102 4
** tuiDeleteDataContentWindows()
**        Function to delete all the item windows in the data window.
**        This is usually done when the data window is scrolled.
*/
d158 4
a161 4
** tuiDisplayAllData().
**        This function displays the data that is in the data window's
**        content.  It does not set the content.
*/
d178 2
a179 2
        ** Then display the other data
        */
d191 4
a194 4
** tuiDisplayDataFromLine()
**        Function to display the data starting at line, lineNo, in the
**        data window.
*/
d223 3
a225 3
            ** _lineNo is past the regs display, so calc where the
            ** start data element is
            */
d228 1
a228 1
                    the start elementNo */
d233 4
a236 4
           ** calculate the starting element of the data display, given
           ** regsLastLine and how many lines each element is, up to
           ** _lineNo
           */
d246 3
a248 3
** tuiDisplayDataFrom()
**        Display data starting at element elementNo
*/
d281 3
a283 3
** tuiRefreshDataWin()
**        Function to redisplay the contents of the data window.
*/
d305 3
a307 3
** tuiCheckDataValues().
**        Function to check the data values and hilite any that have changed
*/
d348 4
a351 4
** tui_vCheckDataValues().
**        Function to check the data values and hilite any that have
**        changed with args in a va_list
*/
d370 3
a372 3
** tuiVerticalDataScroll()
**        Scroll the data window vertically forward or backward.
*/
d392 2
a393 2
        ** the general data content
        */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d2 3
a4 3
   ** tuiDataWin.c
   **   This module contains functions to support the data/register window display.
 */
d25 4
a28 4
   ** tuiFirstDataItemDisplayed()
   **    Answer the index first element displayed.
   **    If none are displayed, then return (-1).
 */
d54 4
a57 4
   ** tuiFirstDataElementNoInLine()
   **        Answer the index of the first element in lineNo.  If lineNo is
   **        past the data area (-1) is returned.
 */
d70 3
a72 3
     ** First see if there is a register on lineNo, and if so, set the
     ** first element number
   */
d75 2
a76 2
				   ** Looking at the general data, the 1st element on lineNo
				 */
d84 4
a87 4
   ** tuiDeleteDataContentWindows()
   **        Function to delete all the item windows in the data window.
   **        This is usually done when the data window is scrolled.
 */
d143 4
a146 4
   ** tuiDisplayAllData().
   **        This function displays the data that is in the data window's
   **        content.  It does not set the content.
 */
d163 2
a164 2
         ** Then display the other data
       */
d176 4
a179 4
   ** tuiDisplayDataFromLine()
   **        Function to display the data starting at line, lineNo, in the
   **        data window.
 */
d208 3
a210 3
				   ** _lineNo is past the regs display, so calc where the
				   ** start data element is
				 */
d213 1
a213 1
				   the start elementNo */
d218 4
a221 4
				   ** calculate the starting element of the data display, given
				   ** regsLastLine and how many lines each element is, up to
				   ** _lineNo
				 */
d231 3
a233 3
   ** tuiDisplayDataFrom()
   **        Display data starting at element elementNo
 */
d266 3
a268 3
   ** tuiRefreshDataWin()
   **        Function to redisplay the contents of the data window.
 */
d290 3
a292 3
   ** tuiCheckDataValues().
   **        Function to check the data values and hilite any that have changed
 */
d333 4
a336 4
   ** tui_vCheckDataValues().
   **        Function to check the data values and hilite any that have
   **        changed with args in a va_list
 */
d355 3
a357 3
   ** tuiVerticalDataScroll()
   **        Scroll the data window vertically forward or backward.
 */
d377 2
a378 2
				   ** the general data content
				 */
@

