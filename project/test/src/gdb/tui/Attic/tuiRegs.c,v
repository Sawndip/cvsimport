head	1.21;
access;
symbols
	drow-cplus-merge-20040113:1.20
	drow-cplus-merge-20031224:1.20
	drow-cplus-merge-20031220:1.20
	carlton_dictionary-20031215-merge:1.20
	drow-cplus-merge-20031214:1.20
	carlton-dictionary-20031111-merge:1.20
	gdb_6_0-2003-10-04-release:1.18
	kettenis_sparc-20030918-branch:1.18.0.8
	kettenis_sparc-20030918-branchpoint:1.18
	carlton_dictionary-20030917-merge:1.18
	ezannoni_pie-20030916-branchpoint:1.18
	ezannoni_pie-20030916-branch:1.18.0.6
	cagney_x86i386-20030821-branch:1.18.0.4
	cagney_x86i386-20030821-branchpoint:1.18
	carlton_dictionary-20030805-merge:1.18
	carlton_dictionary-20030627-merge:1.18
	gdb_6_0-branch:1.18.0.2
	gdb_6_0-2003-06-23-branchpoint:1.18
	jimb-ppc64-linux-20030613-branch:1.17.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.17
	cagney_convert-20030606-branch:1.17.0.10
	cagney_convert-20030606-branchpoint:1.17
	cagney_writestrings-20030508-branch:1.17.0.8
	cagney_writestrings-20030508-branchpoint:1.17
	jimb-ppc64-linux-20030528-branch:1.17.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.17
	carlton_dictionary-20030523-merge:1.17
	cagney_fileio-20030521-branch:1.17.0.4
	cagney_fileio-20030521-branchpoint:1.17
	kettenis_i386newframe-20030517-mergepoint:1.17
	jimb-ppc64-linux-20030509-branch:1.17.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.17
	kettenis_i386newframe-20030504-mergepoint:1.16
	carlton_dictionary-20030430-merge:1.16
	kettenis_i386newframe-20030419-branch:1.16.0.10
	kettenis_i386newframe-20030419-branchpoint:1.16
	carlton_dictionary-20030416-merge:1.16
	cagney_frameaddr-20030409-mergepoint:1.16
	kettenis_i386newframe-20030406-branch:1.16.0.8
	kettenis_i386newframe-20030406-branchpoint:1.16
	cagney_frameaddr-20030403-branchpoint:1.16
	cagney_frameaddr-20030403-branch:1.16.0.6
	cagney_framebase-20030330-mergepoint:1.16
	cagney_framebase-20030326-branch:1.16.0.4
	cagney_framebase-20030326-branchpoint:1.16
	cagney_lazyid-20030317-branch:1.16.0.2
	cagney_lazyid-20030317-branchpoint:1.16
	kettenis-i386newframe-20030316-mergepoint:1.16
	offbyone-20030313-branch:1.15.0.10
	offbyone-20030313-branchpoint:1.15
	kettenis-i386newframe-20030308-branch:1.15.0.8
	kettenis-i386newframe-20030308-branchpoint:1.15
	carlton_dictionary-20030305-merge:1.15
	cagney_offbyone-20030303-branch:1.15.0.6
	cagney_offbyone-20030303-branchpoint:1.15
	carlton_dictionary-20030207-merge:1.15
	interps-20030203-mergepoint:1.15
	interps-20030202-branch:1.15.0.4
	interps-20030202-branchpoint:1.15
	cagney-unwind-20030108-branch:1.15.0.2
	cagney-unwind-20030108-branchpoint:1.15
	carlton_dictionary-20021223-merge:1.15
	gdb_5_3-2002-12-12-release:1.14
	carlton_dictionary-20021115-merge:1.14
	kseitz_interps-20021105-merge:1.14
	kseitz_interps-20021103-merge:1.14
	drow-cplus-merge-20021020:1.14
	drow-cplus-merge-20021025:1.14
	carlton_dictionary-20021025-merge:1.14
	carlton_dictionary-20021011-merge:1.14
	drow-cplus-branch:1.14.0.8
	drow-cplus-branchpoint:1.14
	kseitz_interps-20020930-merge:1.14
	carlton_dictionary-20020927-merge:1.14
	carlton_dictionary-branch:1.14.0.6
	carlton_dictionary-20020920-branchpoint:1.14
	gdb_5_3-branch:1.14.0.4
	gdb_5_3-2002-09-04-branchpoint:1.14
	kseitz_interps-20020829-merge:1.14
	cagney_sysregs-20020825-branch:1.14.0.2
	cagney_sysregs-20020825-branchpoint:1.14
	readline_4_3-import-branch:1.12.0.10
	readline_4_3-import-branchpoint:1.12
	gdb_5_2_1-2002-07-23-release:1.12
	kseitz_interps-20020528-branch:1.12.0.8
	kseitz_interps-20020528-branchpoint:1.12
	cagney_regbuf-20020515-branch:1.12.0.6
	cagney_regbuf-20020515-branchpoint:1.12
	jimb-macro-020506-branch:1.12.0.4
	jimb-macro-020506-branchpoint:1.12
	gdb_5_2-2002-04-29-release:1.12
	gdb_5_2-branch:1.12.0.2
	gdb_5_2-2002-03-03-branchpoint:1.12
	gdb_5_1_1-2002-01-24-release:1.10
	gdb_5_1_0_1-2002-01-03-release:1.10
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.10.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.10
	gdb_5_1-2001-11-21-release:1.10
	gdb_s390-2001-09-26-branch:1.10.0.4
	gdb_s390-2001-09-26-branchpoint:1.10
	gdb_5_1-2001-07-29-branch:1.10.0.2
	gdb_5_1-2001-07-29-branchpoint:1.10
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	gdb-post-ptid_t-2001-05-03:1.4
	gdb-pre-ptid_t-2001-05-03:1.4
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.21
date	2004.01.19.04.31.52;	author cagney;	state dead;
branches;
next	1.20;

1.20
date	2003.10.02.20.28.31;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.28.22.32.20;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.22.15.21.38;	author drow;	state Exp;
branches
	1.18.6.1;
next	1.17;

1.17
date	2003.05.08.20.52.49;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.14.17.07.01;	author cagney;	state Exp;
branches
	1.16.10.1;
next	1.15;

1.15
date	2002.11.29.19.15.16;	author cagney;	state Exp;
branches
	1.15.8.1;
next	1.14;

1.14
date	2002.08.25.09.12.36;	author ciceron;	state Exp;
branches
	1.14.6.1
	1.14.8.1;
next	1.13;

1.13
date	2002.08.24.09.43.30;	author ciceron;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.01.06.19.28;	author cagney;	state Exp;
branches
	1.12.8.1
	1.12.10.1;
next	1.11;

1.11
date	2002.02.08.15.54.32;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.21.19.46.59;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.19.22.47.46;	author ciceron;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.18.22.03.22;	author ciceron;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.17.06.44.57;	author ciceron;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.14.19.31.09;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.14.19.01.25;	author ciceron;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.23.31.14;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.42;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.19.26;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.11.09.01.23.10;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.02.02.00.21.19;	author jsm;	state Exp;
branches;
next	;

1.12.8.1
date	2002.08.30.22.52.52;	author kseitz;	state Exp;
branches;
next	;

1.12.10.1
date	2002.08.27.16.23.29;	author ezannoni;	state Exp;
branches;
next	;

1.14.6.1
date	2002.12.23.19.39.21;	author carlton;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2003.04.16.19.57.03;	author carlton;	state Exp;
branches;
next	1.14.6.3;

1.14.6.3
date	2003.05.23.18.40.53;	author carlton;	state Exp;
branches;
next	1.14.6.4;

1.14.6.4
date	2003.06.27.21.50.21;	author carlton;	state Exp;
branches;
next	1.14.6.5;

1.14.6.5
date	2003.11.11.23.51.12;	author carlton;	state Exp;
branches;
next	1.14.6.6;

1.14.6.6
date	2004.01.26.19.11.45;	author carlton;	state dead;
branches;
next	;

1.14.8.1
date	2003.12.14.20.27.59;	author drow;	state Exp;
branches;
next	1.14.8.2;

1.14.8.2
date	2004.02.09.19.43.58;	author drow;	state dead;
branches;
next	;

1.15.8.1
date	2003.03.16.14.01.55;	author kettenis;	state Exp;
branches;
next	;

1.16.10.1
date	2003.05.18.09.44.36;	author kettenis;	state Exp;
branches;
next	;

1.18.6.1
date	2004.03.23.20.09.16;	author ezannoni;	state dead;
branches;
next	;


desc
@@


1.21
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@/* TUI display registers in window.

   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "tui.h"
#include "tuiData.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "frame.h"
#include "regcache.h"
#include "inferior.h"
#include "target.h"
#include "tuiLayout.h"
#include "tuiWin.h"
#include "tuiDataWin.h"
#include "tuiGeneralWin.h"
#include "tui-file.h"

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

/*****************************************
** LOCAL DEFINITIONS                    **
******************************************/
#define DOUBLE_FLOAT_LABEL_WIDTH    6
#define DOUBLE_FLOAT_LABEL_FMT      "%6.6s: "
#define DOUBLE_FLOAT_VALUE_WIDTH    30	/*min of 16 but may be in sci notation */

#define SINGLE_FLOAT_LABEL_WIDTH    6
#define SINGLE_FLOAT_LABEL_FMT      "%6.6s: "
#define SINGLE_FLOAT_VALUE_WIDTH    25	/* min of 8 but may be in sci notation */

#define SINGLE_LABEL_WIDTH    16
#define SINGLE_LABEL_FMT      "%10.10s: "
#define SINGLE_VALUE_WIDTH    20 /* minimum of 8 but may be in sci notation */

/* In the code HP gave Cygnus, this was actually a function call to a
   PA-specific function, which was supposed to determine whether the
   target was a 64-bit or 32-bit processor.  However, the 64-bit
   support wasn't complete, so we didn't merge that in, so we leave
   this here as a stub.  */
#define IS_64BIT 0

/*****************************************
** STATIC DATA                          **
******************************************/


/*****************************************
** STATIC LOCAL FUNCTIONS FORWARD DECLS    **
******************************************/
static TuiStatus _tuiSetRegsContent
  (int, int, struct frame_info *, TuiRegisterDisplayType, int);
static const char *_tuiRegisterName (int);
static TuiStatus _tuiGetRegisterRawValue (int, char *, struct frame_info *);
static void _tuiSetRegisterElement
  (int, struct frame_info *, TuiDataElementPtr, int);
static void _tuiDisplayRegister (int, TuiGenWinInfoPtr, enum precision_type);
static void _tuiRegisterFormat
  (char *, int, int, TuiDataElementPtr, enum precision_type);
static TuiStatus _tuiSetGeneralRegsContent (int);
static TuiStatus _tuiSetSpecialRegsContent (int);
static TuiStatus _tuiSetGeneralAndSpecialRegsContent (int);
static TuiStatus _tuiSetFloatRegsContent (TuiRegisterDisplayType, int);
static int _tuiRegValueHasChanged
  (TuiDataElementPtr, struct frame_info *, char *);
static void _tuiShowFloat_command (char *, int);
static void _tuiShowGeneral_command (char *, int);
static void _tuiShowSpecial_command (char *, int);
static void _tui_vShowRegisters_commandSupport (TuiRegisterDisplayType);
static void _tuiToggleFloatRegs_command (char *, int);
static void _tuiScrollRegsForward_command (char *, int);
static void _tuiScrollRegsBackward_command (char *, int);



/*****************************************
** PUBLIC FUNCTIONS                     **
******************************************/

/*
   ** tuiLastRegsLineNo()
   **        Answer the number of the last line in the regs display.
   **        If there are no registers (-1) is returned.
 */
int
tuiLastRegsLineNo (void)
{
  register int numLines = (-1);

  if (dataWin->detail.dataDisplayInfo.regsContentCount > 0)
    {
      numLines = (dataWin->detail.dataDisplayInfo.regsContentCount /
		  dataWin->detail.dataDisplayInfo.regsColumnCount);
      if (dataWin->detail.dataDisplayInfo.regsContentCount %
	  dataWin->detail.dataDisplayInfo.regsColumnCount)
	numLines++;
    }
  return numLines;
}				/* tuiLastRegsLineNo */


/*
   ** tuiLineFromRegElementNo()
   **        Answer the line number that the register element at elementNo is
   **        on.  If elementNo is greater than the number of register elements
   **        there are, -1 is returned.
 */
int
tuiLineFromRegElementNo (int elementNo)
{
  if (elementNo < dataWin->detail.dataDisplayInfo.regsContentCount)
    {
      int i, line = (-1);

      i = 1;
      while (line == (-1))
	{
	  if (elementNo <
	      (dataWin->detail.dataDisplayInfo.regsColumnCount * i))
	    line = i - 1;
	  else
	    i++;
	}

      return line;
    }
  else
    return (-1);
}				/* tuiLineFromRegElementNo */


/*
   ** tuiFirstRegElementNoInLine()
   **        Answer the index of the first element in lineNo.  If lineNo is
   **        past the register area (-1) is returned.
 */
int
tuiFirstRegElementNoInLine (int lineNo)
{
  if ((lineNo * dataWin->detail.dataDisplayInfo.regsColumnCount)
      <= dataWin->detail.dataDisplayInfo.regsContentCount)
    return ((lineNo + 1) *
	    dataWin->detail.dataDisplayInfo.regsColumnCount) -
      dataWin->detail.dataDisplayInfo.regsColumnCount;
  else
    return (-1);
}				/* tuiFirstRegElementNoInLine */


/*
   ** tuiLastRegElementNoInLine()
   **        Answer the index of the last element in lineNo.  If lineNo is past
   **        the register area (-1) is returned.
 */
int
tuiLastRegElementNoInLine (int lineNo)
{
  if ((lineNo * dataWin->detail.dataDisplayInfo.regsColumnCount) <=
      dataWin->detail.dataDisplayInfo.regsContentCount)
    return ((lineNo + 1) *
	    dataWin->detail.dataDisplayInfo.regsColumnCount) - 1;
  else
    return (-1);
}				/* tuiLastRegElementNoInLine */


/*
   ** tuiCalculateRegsColumnCount
   **        Calculate the number of columns that should be used to display
   **        the registers.
 */
int
tuiCalculateRegsColumnCount (TuiRegisterDisplayType dpyType)
{
  int colCount, colWidth;

  if (IS_64BIT || dpyType == TUI_DFLOAT_REGS)
    colWidth = DOUBLE_FLOAT_VALUE_WIDTH + DOUBLE_FLOAT_LABEL_WIDTH;
  else
    {
      if (dpyType == TUI_SFLOAT_REGS)
	colWidth = SINGLE_FLOAT_VALUE_WIDTH + SINGLE_FLOAT_LABEL_WIDTH;
      else
	colWidth = SINGLE_VALUE_WIDTH + SINGLE_LABEL_WIDTH;
    }
  colCount = (dataWin->generic.width - 2) / colWidth;

  return colCount;
}				/* tuiCalulateRegsColumnCount */


/*
   ** tuiShowRegisters().
   **        Show the registers int the data window as indicated by dpyType.
   **        If there is any other registers being displayed, then they are
   **        cleared.  What registers are displayed is dependent upon dpyType.
 */
void
tuiShowRegisters (TuiRegisterDisplayType dpyType)
{
  TuiStatus ret = TUI_FAILURE;
  int refreshValuesOnly = FALSE;

  /* Say that registers should be displayed, even if there is a problem */
  dataWin->detail.dataDisplayInfo.displayRegs = TRUE;

  if (target_has_registers)
    {
      refreshValuesOnly =
	(dpyType == dataWin->detail.dataDisplayInfo.regsDisplayType);
      switch (dpyType)
	{
	case TUI_GENERAL_REGS:
	  ret = _tuiSetGeneralRegsContent (refreshValuesOnly);
	  break;
	case TUI_SFLOAT_REGS:
	case TUI_DFLOAT_REGS:
	  ret = _tuiSetFloatRegsContent (dpyType, refreshValuesOnly);
	  break;

/* could ifdef out */

	case TUI_SPECIAL_REGS:
	  ret = _tuiSetSpecialRegsContent (refreshValuesOnly);
	  break;
	case TUI_GENERAL_AND_SPECIAL_REGS:
	  ret = _tuiSetGeneralAndSpecialRegsContent (refreshValuesOnly);
	  break;

/* end of potential if def */

	default:
	  break;
	}
    }
  if (ret == TUI_FAILURE)
    {
      dataWin->detail.dataDisplayInfo.regsDisplayType = TUI_UNDEFINED_REGS;
      tuiEraseDataContent (NO_REGS_STRING);
    }
  else
    {
      int i;

      /* Clear all notation of changed values */
      for (i = 0; (i < dataWin->detail.dataDisplayInfo.regsContentCount); i++)
	{
	  TuiGenWinInfoPtr dataItemWin;

	  dataItemWin = &dataWin->detail.dataDisplayInfo.
	    regsContent[i]->whichElement.dataWindow;
	  (&((TuiWinElementPtr)
	     dataItemWin->content[0])->whichElement.data)->highlight = FALSE;
	}
      dataWin->detail.dataDisplayInfo.regsDisplayType = dpyType;
      tuiDisplayAllData ();
    }
  (tuiLayoutDef ())->regsDisplayType = dpyType;

  return;
}				/* tuiShowRegisters */


/*
   ** tuiDisplayRegistersFrom().
   **        Function to display the registers in the content from
   **        'startElementNo' until the end of the register content or the
   **        end of the display height.  No checking for displaying past
   **        the end of the registers is done here.
 */
void
tuiDisplayRegistersFrom (int startElementNo)
{
  if (dataWin->detail.dataDisplayInfo.regsContent != (TuiWinContent) NULL &&
      dataWin->detail.dataDisplayInfo.regsContentCount > 0)
    {
      register int i = startElementNo;
      int j, valueCharsWide, itemWinWidth, curY, labelWidth;
      enum precision_type precision;

      precision = (dataWin->detail.dataDisplayInfo.regsDisplayType
		   == TUI_DFLOAT_REGS) ?
	double_precision : unspecified_precision;
      if (IS_64BIT ||
	  dataWin->detail.dataDisplayInfo.regsDisplayType == TUI_DFLOAT_REGS)
	{
	  valueCharsWide = DOUBLE_FLOAT_VALUE_WIDTH;
	  labelWidth = DOUBLE_FLOAT_LABEL_WIDTH;
	}
      else
	{
	  if (dataWin->detail.dataDisplayInfo.regsDisplayType ==
	      TUI_SFLOAT_REGS)
	    {
	      valueCharsWide = SINGLE_FLOAT_VALUE_WIDTH;
	      labelWidth = SINGLE_FLOAT_LABEL_WIDTH;
	    }
	  else
	    {
	      valueCharsWide = SINGLE_VALUE_WIDTH;
	      labelWidth = SINGLE_LABEL_WIDTH;
	    }
	}
      itemWinWidth = valueCharsWide + labelWidth;
      /*
         ** Now create each data "sub" window, and write the display into it.
       */
      curY = 1;
      while (i < dataWin->detail.dataDisplayInfo.regsContentCount &&
	     curY <= dataWin->generic.viewportHeight)
	{
	  for (j = 0;
	       (j < dataWin->detail.dataDisplayInfo.regsColumnCount &&
		i < dataWin->detail.dataDisplayInfo.regsContentCount); j++)
	    {
	      TuiGenWinInfoPtr dataItemWin;
	      TuiDataElementPtr dataElementPtr;

	      /* create the window if necessary */
	      dataItemWin = &dataWin->detail.dataDisplayInfo.
		regsContent[i]->whichElement.dataWindow;
	      dataElementPtr = &((TuiWinElementPtr)
				 dataItemWin->content[0])->whichElement.data;
	      if (dataItemWin->handle == (WINDOW *) NULL)
		{
		  dataItemWin->height = 1;
		  dataItemWin->width = (precision == double_precision) ?
		    itemWinWidth + 2 : itemWinWidth + 1;
		  dataItemWin->origin.x = (itemWinWidth * j) + 1;
		  dataItemWin->origin.y = curY;
		  makeWindow (dataItemWin, DONT_BOX_WINDOW);
                  scrollok (dataItemWin->handle, FALSE);
		}
              touchwin (dataItemWin->handle);

	      /*
	         ** Get the printable representation of the register
	         ** and display it
	       */
	      _tuiDisplayRegister (
			    dataElementPtr->itemNo, dataItemWin, precision);
	      i++;		/* next register */
	    }
	  curY++;		/* next row; */
	}
    }

  return;
}				/* tuiDisplayRegistersFrom */


/*
   ** tuiDisplayRegElementAtLine().
   **        Function to display the registers in the content from
   **        'startElementNo' on 'startLineNo' until the end of the
   **        register content or the end of the display height.
   **        This function checks that we won't display off the end
   **        of the register display.
 */
void
tuiDisplayRegElementAtLine (int startElementNo, int startLineNo)
{
  if (dataWin->detail.dataDisplayInfo.regsContent != (TuiWinContent) NULL &&
      dataWin->detail.dataDisplayInfo.regsContentCount > 0)
    {
      register int elementNo = startElementNo;

      if (startElementNo != 0 && startLineNo != 0)
	{
	  register int lastLineNo, firstLineOnLastPage;

	  lastLineNo = tuiLastRegsLineNo ();
	  firstLineOnLastPage = lastLineNo - (dataWin->generic.height - 2);
	  if (firstLineOnLastPage < 0)
	    firstLineOnLastPage = 0;
	  /*
	     ** If there is no other data displayed except registers,
	     ** and the elementNo causes us to scroll past the end of the
	     ** registers, adjust what element to really start the display at.
	   */
	  if (dataWin->detail.dataDisplayInfo.dataContentCount <= 0 &&
	      startLineNo > firstLineOnLastPage)
	    elementNo = tuiFirstRegElementNoInLine (firstLineOnLastPage);
	}
      tuiDisplayRegistersFrom (elementNo);
    }

  return;
}				/* tuiDisplayRegElementAtLine */



/*
   ** tuiDisplayRegistersFromLine().
   **        Function to display the registers starting at line lineNo in
   **        the data window.  Answers the line number that the display
   **        actually started from.  If nothing is displayed (-1) is returned.
 */
int
tuiDisplayRegistersFromLine (int lineNo, int forceDisplay)
{
  if (dataWin->detail.dataDisplayInfo.regsContentCount > 0)
    {
      int line, elementNo;

      if (lineNo < 0)
	line = 0;
      else if (forceDisplay)
	{			/*
				   ** If we must display regs (forceDisplay is true), then make
				   ** sure that we don't display off the end of the registers.
				 */
	  if (lineNo >= tuiLastRegsLineNo ())
	    {
	      if ((line = tuiLineFromRegElementNo (
		 dataWin->detail.dataDisplayInfo.regsContentCount - 1)) < 0)
		line = 0;
	    }
	  else
	    line = lineNo;
	}
      else
	line = lineNo;

      elementNo = tuiFirstRegElementNoInLine (line);
      if (elementNo < dataWin->detail.dataDisplayInfo.regsContentCount)
	tuiDisplayRegElementAtLine (elementNo, line);
      else
	line = (-1);

      return line;
    }

  return (-1);			/* nothing was displayed */
}				/* tuiDisplayRegistersFromLine */


/*
   ** tuiCheckRegisterValues()
   **        This function check all displayed registers for changes in
   **        values, given a particular frame.  If the values have changed,
   **        they are updated with the new value and highlighted.
 */
void
tuiCheckRegisterValues (struct frame_info *frame)
{
  if (m_winPtrNotNull (dataWin) && dataWin->generic.isVisible)
    {
      if (dataWin->detail.dataDisplayInfo.regsContentCount <= 0 &&
	  dataWin->detail.dataDisplayInfo.displayRegs)
	tuiShowRegisters ((tuiLayoutDef ())->regsDisplayType);
      else
	{
	  int i, j;
	  char rawBuf[MAX_REGISTER_SIZE];

	  for (i = 0;
	       (i < dataWin->detail.dataDisplayInfo.regsContentCount); i++)
	    {
	      TuiDataElementPtr dataElementPtr;
	      TuiGenWinInfoPtr dataItemWinPtr;
	      int wasHilighted;

	      dataItemWinPtr = &dataWin->detail.dataDisplayInfo.
		regsContent[i]->whichElement.dataWindow;
	      dataElementPtr = &((TuiWinElementPtr)
			     dataItemWinPtr->content[0])->whichElement.data;
	      wasHilighted = dataElementPtr->highlight;
	      dataElementPtr->highlight =
		_tuiRegValueHasChanged (dataElementPtr, frame, &rawBuf[0]);
	      if (dataElementPtr->highlight)
		{
                  int size;

                  size = DEPRECATED_REGISTER_RAW_SIZE (dataElementPtr->itemNo);
		  for (j = 0; j < size; j++)
		    ((char *) dataElementPtr->value)[j] = rawBuf[j];
		  _tuiDisplayRegister (
					dataElementPtr->itemNo,
					dataItemWinPtr,
			((dataWin->detail.dataDisplayInfo.regsDisplayType ==
			  TUI_DFLOAT_REGS) ?
			 double_precision : unspecified_precision));
		}
	      else if (wasHilighted)
		{
		  dataElementPtr->highlight = FALSE;
		  _tuiDisplayRegister (
					dataElementPtr->itemNo,
					dataItemWinPtr,
			((dataWin->detail.dataDisplayInfo.regsDisplayType ==
			  TUI_DFLOAT_REGS) ?
			 double_precision : unspecified_precision));
		}
	    }
	}
    }
  return;
}				/* tuiCheckRegisterValues */


/*
   ** tuiToggleFloatRegs().
 */
void
tuiToggleFloatRegs (void)
{
  TuiLayoutDefPtr layoutDef = tuiLayoutDef ();

  if (layoutDef->floatRegsDisplayType == TUI_SFLOAT_REGS)
    layoutDef->floatRegsDisplayType = TUI_DFLOAT_REGS;
  else
    layoutDef->floatRegsDisplayType = TUI_SFLOAT_REGS;

  if (m_winPtrNotNull (dataWin) && dataWin->generic.isVisible &&
      (dataWin->detail.dataDisplayInfo.regsDisplayType == TUI_SFLOAT_REGS ||
       dataWin->detail.dataDisplayInfo.regsDisplayType == TUI_DFLOAT_REGS))
    tuiShowRegisters (layoutDef->floatRegsDisplayType);

  return;
}				/* tuiToggleFloatRegs */


void
_initialize_tuiRegs (void)
{
  if (xdb_commands)
    {
      add_com ("fr", class_tui, _tuiShowFloat_command,
	       "Display only floating point registers\n");
      add_com ("gr", class_tui, _tuiShowGeneral_command,
	       "Display only general registers\n");
      add_com ("sr", class_tui, _tuiShowSpecial_command,
	       "Display only special registers\n");
      add_com ("+r", class_tui, _tuiScrollRegsForward_command,
	       "Scroll the registers window forward\n");
      add_com ("-r", class_tui, _tuiScrollRegsBackward_command,
	       "Scroll the register window backward\n");
      add_com ("tf", class_tui, _tuiToggleFloatRegs_command,
	       "Toggle between single and double precision floating point registers.\n");
      add_cmd (TUI_FLOAT_REGS_NAME_LOWER,
	       class_tui,
	       _tuiToggleFloatRegs_command,
	       "Toggle between single and double precision floating point \
registers.\n",
	       &togglelist);
    }
}


/*****************************************
** STATIC LOCAL FUNCTIONS                 **
******************************************/


/*
   ** _tuiRegisterName().
   **        Return the register name.
 */
static const char *
_tuiRegisterName (int regNum)
{
  return REGISTER_NAME (regNum);
}
extern int pagination_enabled;

static void
tui_restore_gdbout (void *ui)
{
  ui_file_delete (gdb_stdout);
  gdb_stdout = (struct ui_file*) ui;
  pagination_enabled = 1;
}

/*
   ** _tuiRegisterFormat
   **        Function to format the register name and value into a buffer,
   **        suitable for printing or display
 */
static void
_tuiRegisterFormat (char *buf, int bufLen, int regNum,
                    TuiDataElementPtr dataElement,
                    enum precision_type precision)
{
  struct ui_file *stream;
  struct ui_file *old_stdout;
  const char *name;
  struct cleanup *cleanups;
  char *p;
  int pos;

  name = REGISTER_NAME (regNum);
  if (name == 0)
    {
      strcpy (buf, "");
      return;
    }
  
  pagination_enabled = 0;
  old_stdout = gdb_stdout;
  stream = tui_sfileopen (bufLen);
  gdb_stdout = stream;
  cleanups = make_cleanup (tui_restore_gdbout, (void*) old_stdout);
  gdbarch_print_registers_info (current_gdbarch, stream, deprecated_selected_frame,
                                regNum, 1);

  /* Save formatted output in the buffer.  */
  p = tui_file_get_strbuf (stream);
  pos = 0;
  while (*p && *p == *name++ && bufLen)
    {
      *buf++ = *p++;
      bufLen--;
      pos++;
    }
  while (*p == ' ')
    p++;
  while (pos < 8 && bufLen)
    {
      *buf++ = ' ';
      bufLen--;
      pos++;
    }
  strncpy (buf, p, bufLen);

  /* Remove the possible \n.  */
  p = strchr (buf, '\n');
  if (p)
    *p = 0;

  do_cleanups (cleanups);
}


#define NUM_GENERAL_REGS    32
/*
   ** _tuiSetGeneralRegsContent().
   **      Set the content of the data window to consist of the general registers.
 */
static TuiStatus
_tuiSetGeneralRegsContent (int refreshValuesOnly)
{
  return (_tuiSetRegsContent (0,
			      NUM_GENERAL_REGS - 1,
			      deprecated_selected_frame,
			      TUI_GENERAL_REGS,
			      refreshValuesOnly));

}				/* _tuiSetGeneralRegsContent */


#ifndef PCOQ_HEAD_REGNUM
#define START_SPECIAL_REGS  0
#else
#define START_SPECIAL_REGS    PCOQ_HEAD_REGNUM
#endif

/*
   ** _tuiSetSpecialRegsContent().
   **      Set the content of the data window to consist of the special registers.
 */
static TuiStatus
_tuiSetSpecialRegsContent (int refreshValuesOnly)
{
  TuiStatus ret = TUI_FAILURE;
  int endRegNum;

  endRegNum = FP0_REGNUM - 1;
  ret = _tuiSetRegsContent (START_SPECIAL_REGS,
			    endRegNum,
			    deprecated_selected_frame,
			    TUI_SPECIAL_REGS,
			    refreshValuesOnly);

  return ret;
}				/* _tuiSetSpecialRegsContent */


/*
   ** _tuiSetGeneralAndSpecialRegsContent().
   **      Set the content of the data window to consist of the special registers.
 */
static TuiStatus
_tuiSetGeneralAndSpecialRegsContent (int refreshValuesOnly)
{
  TuiStatus ret = TUI_FAILURE;
  int endRegNum = (-1);

  endRegNum = FP0_REGNUM - 1;
  ret = _tuiSetRegsContent (
	 0, endRegNum, deprecated_selected_frame, TUI_SPECIAL_REGS, refreshValuesOnly);

  return ret;
}				/* _tuiSetGeneralAndSpecialRegsContent */

/*
   ** _tuiSetFloatRegsContent().
   **        Set the content of the data window to consist of the float registers.
 */
static TuiStatus
_tuiSetFloatRegsContent (TuiRegisterDisplayType dpyType, int refreshValuesOnly)
{
  TuiStatus ret = TUI_FAILURE;
  int startRegNum;

  startRegNum = FP0_REGNUM;
  ret = _tuiSetRegsContent (startRegNum,
			    NUM_REGS - 1,
			    deprecated_selected_frame,
			    dpyType,
			    refreshValuesOnly);

  return ret;
}				/* _tuiSetFloatRegsContent */


/*
   ** _tuiRegValueHasChanged().
   **        Answer TRUE if the register's value has changed, FALSE otherwise.
   **        If TRUE, newValue is filled in with the new value.
 */
static int
_tuiRegValueHasChanged (TuiDataElementPtr dataElement,
                        struct frame_info *frame,
                        char *newValue)
{
  int hasChanged = FALSE;

  if (dataElement->itemNo != UNDEFINED_ITEM &&
      _tuiRegisterName (dataElement->itemNo) != (char *) NULL)
    {
      char rawBuf[MAX_REGISTER_SIZE];
      int i;

      if (_tuiGetRegisterRawValue (
			 dataElement->itemNo, rawBuf, frame) == TUI_SUCCESS)
	{
          int size = DEPRECATED_REGISTER_RAW_SIZE (dataElement->itemNo);
          
	  for (i = 0; (i < size && !hasChanged); i++)
	    hasChanged = (((char *) dataElement->value)[i] != rawBuf[i]);
	  if (hasChanged && newValue != (char *) NULL)
	    {
	      for (i = 0; i < size; i++)
		newValue[i] = rawBuf[i];
	    }
	}
    }
  return hasChanged;
}				/* _tuiRegValueHasChanged */



/*
   ** _tuiGetRegisterRawValue().
   **        Get the register raw value.  The raw value is returned in regValue.
 */
static TuiStatus
_tuiGetRegisterRawValue (int regNum, char *regValue, struct frame_info *frame)
{
  TuiStatus ret = TUI_FAILURE;

  if (target_has_registers)
    {
      get_frame_register (frame, regNum, regValue);
      /* NOTE: cagney/2003-03-13: This is bogus.  It is refering to
         the register cache and not the frame which could have pulled
         the register value off the stack.  */
      if (register_cached (regNum) >= 0)
	ret = TUI_SUCCESS;
    }
  return ret;
}				/* _tuiGetRegisterRawValue */



/*
   ** _tuiSetRegisterElement().
   **       Function to initialize a data element with the input and
   **       the register value.
 */
static void
_tuiSetRegisterElement (int regNum, struct frame_info *frame,
                        TuiDataElementPtr dataElement,
                        int refreshValueOnly)
{
  if (dataElement != (TuiDataElementPtr) NULL)
    {
      if (!refreshValueOnly)
	{
	  dataElement->itemNo = regNum;
	  dataElement->name = _tuiRegisterName (regNum);
	  dataElement->highlight = FALSE;
	}
      if (dataElement->value == (Opaque) NULL)
	dataElement->value = (Opaque) xmalloc (MAX_REGISTER_SIZE);
      if (dataElement->value != (Opaque) NULL)
	_tuiGetRegisterRawValue (regNum, dataElement->value, frame);
    }

  return;
}				/* _tuiSetRegisterElement */


/*
   ** _tuiSetRegsContent().
   **        Set the content of the data window to consist of the registers
   **        numbered from startRegNum to endRegNum.  Note that if
   **        refreshValuesOnly is TRUE, startRegNum and endRegNum are ignored.
 */
static TuiStatus
_tuiSetRegsContent (int startRegNum, int endRegNum,
                    struct frame_info *frame,
                    TuiRegisterDisplayType dpyType,
                    int refreshValuesOnly)
{
  TuiStatus ret = TUI_FAILURE;
  int numRegs = endRegNum - startRegNum + 1;
  int allocatedHere = FALSE;

  if (dataWin->detail.dataDisplayInfo.regsContentCount > 0 &&
      !refreshValuesOnly)
    {
      freeDataContent (dataWin->detail.dataDisplayInfo.regsContent,
		       dataWin->detail.dataDisplayInfo.regsContentCount);
      dataWin->detail.dataDisplayInfo.regsContentCount = 0;
    }
  if (dataWin->detail.dataDisplayInfo.regsContentCount <= 0)
    {
      dataWin->detail.dataDisplayInfo.regsContent =
	allocContent (numRegs, DATA_WIN);
      allocatedHere = TRUE;
    }

  if (dataWin->detail.dataDisplayInfo.regsContent != (TuiWinContent) NULL)
    {
      int i;

      if (!refreshValuesOnly || allocatedHere)
	{
	  dataWin->generic.content = (OpaquePtr) NULL;
	  dataWin->generic.contentSize = 0;
	  addContentElements (&dataWin->generic, numRegs);
	  dataWin->detail.dataDisplayInfo.regsContent =
	    (TuiWinContent) dataWin->generic.content;
	  dataWin->detail.dataDisplayInfo.regsContentCount = numRegs;
	}
      /*
         ** Now set the register names and values
       */
      for (i = startRegNum; (i <= endRegNum); i++)
	{
	  TuiGenWinInfoPtr dataItemWin;

	  dataItemWin = &dataWin->detail.dataDisplayInfo.
	    regsContent[i - startRegNum]->whichElement.dataWindow;
	  _tuiSetRegisterElement (
				   i,
				   frame,
	   &((TuiWinElementPtr) dataItemWin->content[0])->whichElement.data,
				   !allocatedHere && refreshValuesOnly);
	}
      dataWin->detail.dataDisplayInfo.regsColumnCount =
	tuiCalculateRegsColumnCount (dpyType);
#ifdef LATER
      if (dataWin->detail.dataDisplayInfo.dataContentCount > 0)
	{
	  /* delete all the windows? */
	  /* realloc content equal to dataContentCount + regsContentCount */
	  /* append dataWin->detail.dataDisplayInfo.dataContent to content */
	}
#endif
      dataWin->generic.contentSize =
	dataWin->detail.dataDisplayInfo.regsContentCount +
	dataWin->detail.dataDisplayInfo.dataContentCount;
      ret = TUI_SUCCESS;
    }

  return ret;
}				/* _tuiSetRegsContent */


/*
   ** _tuiDisplayRegister().
   **        Function to display a register in a window.  If hilite is TRUE,
   **        than the value will be displayed in reverse video
 */
static void
_tuiDisplayRegister (int regNum,
                     TuiGenWinInfoPtr winInfo,		/* the data item window */
                     enum precision_type precision)
{
  if (winInfo->handle != (WINDOW *) NULL)
    {
      int i;
      char buf[40];
      int valueCharsWide, labelWidth;
      TuiDataElementPtr dataElementPtr = &((TuiWinContent)
				    winInfo->content)[0]->whichElement.data;

      if (IS_64BIT ||
	  dataWin->detail.dataDisplayInfo.regsDisplayType == TUI_DFLOAT_REGS)
	{
	  valueCharsWide = DOUBLE_FLOAT_VALUE_WIDTH;
	  labelWidth = DOUBLE_FLOAT_LABEL_WIDTH;
	}
      else
	{
	  if (dataWin->detail.dataDisplayInfo.regsDisplayType ==
	      TUI_SFLOAT_REGS)
	    {
	      valueCharsWide = SINGLE_FLOAT_VALUE_WIDTH;
	      labelWidth = SINGLE_FLOAT_LABEL_WIDTH;
	    }
	  else
	    {
	      valueCharsWide = SINGLE_VALUE_WIDTH;
	      labelWidth = SINGLE_LABEL_WIDTH;
	    }
	}

      buf[0] = (char) 0;
      _tuiRegisterFormat (buf,
			  valueCharsWide + labelWidth,
			  regNum,
			  dataElementPtr,
			  precision);

      if (dataElementPtr->highlight)
	wstandout (winInfo->handle);

      wmove (winInfo->handle, 0, 0);
      for (i = 1; i < winInfo->width; i++)
        waddch (winInfo->handle, ' ');
      wmove (winInfo->handle, 0, 0);
      waddstr (winInfo->handle, buf);

      if (dataElementPtr->highlight)
	wstandend (winInfo->handle);
      tuiRefreshWin (winInfo);
    }
  return;
}				/* _tuiDisplayRegister */


static void
_tui_vShowRegisters_commandSupport (TuiRegisterDisplayType dpyType)
{

  if (m_winPtrNotNull (dataWin) && dataWin->generic.isVisible)
    {				/* Data window already displayed, show the registers */
      if (dataWin->detail.dataDisplayInfo.regsDisplayType != dpyType)
	tuiShowRegisters (dpyType);
    }
  else
    (tuiLayoutDef ())->regsDisplayType = dpyType;

  return;
}				/* _tui_vShowRegisters_commandSupport */


static void
_tuiShowFloat_command (char *arg, int fromTTY)
{
  if (m_winPtrIsNull (dataWin) || !dataWin->generic.isVisible ||
      (dataWin->detail.dataDisplayInfo.regsDisplayType != TUI_SFLOAT_REGS &&
       dataWin->detail.dataDisplayInfo.regsDisplayType != TUI_DFLOAT_REGS))
    _tui_vShowRegisters_commandSupport ((tuiLayoutDef ())->floatRegsDisplayType);

  return;
}				/* _tuiShowFloat_command */


static void
_tuiShowGeneral_command (char *arg, int fromTTY)
{
  _tui_vShowRegisters_commandSupport (TUI_GENERAL_REGS);
}


static void
_tuiShowSpecial_command (char *arg, int fromTTY)
{
  _tui_vShowRegisters_commandSupport (TUI_SPECIAL_REGS);
}


static void
_tuiToggleFloatRegs_command (char *arg, int fromTTY)
{
  if (m_winPtrNotNull (dataWin) && dataWin->generic.isVisible)
    tuiToggleFloatRegs ();
  else
    {
      TuiLayoutDefPtr layoutDef = tuiLayoutDef ();

      if (layoutDef->floatRegsDisplayType == TUI_SFLOAT_REGS)
	layoutDef->floatRegsDisplayType = TUI_DFLOAT_REGS;
      else
	layoutDef->floatRegsDisplayType = TUI_SFLOAT_REGS;
    }


  return;
}				/* _tuiToggleFloatRegs_command */


static void
_tuiScrollRegsForward_command (char *arg, int fromTTY)
{
  tui_scroll (FORWARD_SCROLL, dataWin, 1);
}


static void
_tuiScrollRegsBackward_command (char *arg, int fromTTY)
{
  tui_scroll (BACKWARD_SCROLL, dataWin, 1);
}
@


1.20
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@@


1.19
log
@2003-09-28  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_read_unsigned_register): Delete function.
	* frame.h (frame_read_unsigned_register): Delete declaration.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	get_frame_register_unsigned.
	(sparc_frame_saved_pc, sparc_pop_frame): Ditto.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.h (frame_read_register): Delete declaration.
	* frame.c (frame_read_register): Delete function.
	* arch-utils.c (legacy_register_to_value): Use get_frame_register.
	* sparc-tdep.c (sparc_fetch_pointer_argument): Ditto.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* hppa-tdep.c (hppa_fetch_pointer_argument): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.c (frame_read_signed_register): Delete function.
	(frame_read_unsigned_register): Update comments.
	* frame.h (frame_read_signed_register): Delete declaration.
	* h8300-tdep.c (h8300_print_register): Use
	get_frame_register_signed.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
@
text
@d503 1
a503 1
                  size = REGISTER_RAW_SIZE (dataElementPtr->itemNo);
d766 1
a766 1
          int size = REGISTER_RAW_SIZE (dataElement->itemNo);
@


1.18
log
@	* tui-hooks.c: Update include order.
	* tui.c: Likewise.
	* tuiCommand.c: Likewise.
	* tuiData.c: Likewise.
	* tuiDataWin.c: Likewise.
	* tuiDisassem.c: Likewise.
	* tuiGeneralWin.c: Likewise.
	* tuiIO.c: Likewise.
	* tuiLayout.c: Likewise.
	* tuiRegs.c: Likewise.
	* tuiSource.c: Likewise.
	* tuiSourceWin.c: Likewise.
	* tuiStack.c: Likewise.
	* tuiWin.c: Likewise.
@
text
@d793 1
a793 1
      frame_read_register (frame, regNum, regValue);
@


1.18.6.1
log
@merge mainline changes to branch
@
text
@@


1.17
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation,
a24 17
/* FIXME: cagney/2002-02-28: The GDB coding standard indicates that
   "defs.h" should be included first.  Unfortunatly some systems
   (currently Debian GNU/Linux) include the <stdbool.h> via <curses.h>
   and they clash with "bfd.h"'s definiton of true/false.  The correct
   fix is to remove true/false from "bfd.h", however, until that
   happens, hack around it by including "config.h" and <curses.h>
   first.  */

#include "config.h"
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

d40 8
@


1.16
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_saved_register): Delete function.
	* xstormy16-tdep.c: Update comment.
	* regcache.h: Update comments.
	* sparc-tdep.c (sparc_init_extra_frame_info): Instead of
	get_saved_register and extract_address, use
	frame_read_unsigned_register.
	(sparc_frame_saved_pc): Ditto.
	(sparc_get_saved_register): Instead of get_saved_register, use
	frame_register.
	(sparc_pop_frame): Ditto.
	* frame.h (get_saved_register): Delete declaration.
	* findvar.c: Update comments.
	(value_of_register): Call frame_register instead of
	get_saved_register.
	(value_from_register): Ditto.
	* config/sparc/tm-sparc.h: Update comment.
	* breakpoint.c: Update comment.

Index: doc/ChangeLog
2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to get_saved_register.
@
text
@d492 1
a492 1
	  char rawBuf[MAX_REGISTER_RAW_SIZE];
d769 1
a769 1
      char rawBuf[MAX_REGISTER_RAW_SIZE];
d833 1
a833 1
	dataElement->value = (Opaque) xmalloc (MAX_REGISTER_RAW_SIZE);
@


1.16.10.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d492 1
a492 1
	  char rawBuf[MAX_REGISTER_SIZE];
d769 1
a769 1
      char rawBuf[MAX_REGISTER_SIZE];
d833 1
a833 1
	dataElement->value = (Opaque) xmalloc (MAX_REGISTER_SIZE);
@


1.15
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d802 4
a805 4
      int opt;
      
      get_saved_register (regValue, &opt, (CORE_ADDR*) NULL, frame,
			  regNum, (enum lval_type*) NULL);
@


1.15.8.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d802 4
a805 4
      frame_read_register (frame, regNum, regValue);
      /* NOTE: cagney/2003-03-13: This is bogus.  It is refering to
         the register cache and not the frame which could have pulled
         the register value off the stack.  */
@


1.14
log
@	* tuiRegs.c (tuiDisplayRegistersFrom): Remove unused locals.
	(_tuiRegisterFormat, _tuiSetSpecialRegsContent): Likewise.
	(_tuiSetGeneralAndSpecialRegsContent): Likewise.
	(_tuiSetFloatRegsContent): Likewise.
	(_tuiRegisterName): Return a const char*.
	* tuiData.h (_TuiDataElement): Use const char* for name.
@
text
@d641 1
a641 1
  gdbarch_print_registers_info (current_gdbarch, stream, selected_frame,
d682 1
a682 1
			      selected_frame,
d708 1
a708 1
			    selected_frame,
d728 1
a728 1
	 0, endRegNum, selected_frame, TUI_SPECIAL_REGS, refreshValuesOnly);
d746 1
a746 1
			    selected_frame,
@


1.14.8.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a57 8
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

d492 1
a492 1
	  char rawBuf[MAX_REGISTER_SIZE];
d512 1
a512 1
                  size = DEPRECATED_REGISTER_RAW_SIZE (dataElementPtr->itemNo);
d641 1
a641 1
  gdbarch_print_registers_info (current_gdbarch, stream, deprecated_selected_frame,
d682 1
a682 1
			      deprecated_selected_frame,
d708 1
a708 1
			    deprecated_selected_frame,
d728 1
a728 1
	 0, endRegNum, deprecated_selected_frame, TUI_SPECIAL_REGS, refreshValuesOnly);
d746 1
a746 1
			    deprecated_selected_frame,
d769 1
a769 1
      char rawBuf[MAX_REGISTER_SIZE];
d775 1
a775 1
          int size = DEPRECATED_REGISTER_RAW_SIZE (dataElement->itemNo);
d802 4
a805 4
      get_frame_register (frame, regNum, regValue);
      /* NOTE: cagney/2003-03-13: This is bogus.  It is refering to
         the register cache and not the frame which could have pulled
         the register value off the stack.  */
d833 1
a833 1
	dataElement->value = (Opaque) xmalloc (MAX_REGISTER_SIZE);
@


1.14.8.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@@


1.14.6.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d641 1
a641 1
  gdbarch_print_registers_info (current_gdbarch, stream, deprecated_selected_frame,
d682 1
a682 1
			      deprecated_selected_frame,
d708 1
a708 1
			    deprecated_selected_frame,
d728 1
a728 1
	 0, endRegNum, deprecated_selected_frame, TUI_SPECIAL_REGS, refreshValuesOnly);
d746 1
a746 1
			    deprecated_selected_frame,
@


1.14.6.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d802 4
a805 4
      frame_read_register (frame, regNum, regValue);
      /* NOTE: cagney/2003-03-13: This is bogus.  It is refering to
         the register cache and not the frame which could have pulled
         the register value off the stack.  */
@


1.14.6.3
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d492 1
a492 1
	  char rawBuf[MAX_REGISTER_SIZE];
d769 1
a769 1
      char rawBuf[MAX_REGISTER_SIZE];
d833 1
a833 1
	dataElement->value = (Opaque) xmalloc (MAX_REGISTER_SIZE);
@


1.14.6.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a56 8

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
@


1.14.6.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d503 1
a503 1
                  size = DEPRECATED_REGISTER_RAW_SIZE (dataElementPtr->itemNo);
d766 1
a766 1
          int size = DEPRECATED_REGISTER_RAW_SIZE (dataElement->itemNo);
d793 1
a793 1
      get_frame_register (frame, regNum, regValue);
@


1.14.6.6
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.13
log
@	* tuiRegs.c (_tuiRegisterFormat): Use gdbarch_print_registers_info.
@
text
@d49 1
d90 1
a90 1
static char *_tuiRegisterName (int);
d315 1
a315 1
      int j, valueCharsWide, charsWide, itemWinWidth, curY, labelWidth;
a438 2
  int elementNo;

d597 1
a597 1
static char *
d624 1
a624 1
  char *name;
d703 1
a703 1
  int i, endRegNum;
a705 6
#if 0
  endRegNum = (-1);
  for (i = START_SPECIAL_REGS; (i < NUM_REGS && endRegNum < 0); i++)
    if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
      endRegNum = i - 1;
#endif
d724 1
a724 1
  int i, endRegNum = (-1);
a726 6
#if 0
  endRegNum = (-1);
  for (i = 0; (i < NUM_REGS && endRegNum < 0); i++)
    if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
      endRegNum = i - 1;
#endif
d741 1
a741 1
  int i, startRegNum;
a743 6
#if 0
  startRegNum = (-1);
  for (i = NUM_REGS - 1; (i >= 0 && startRegNum < 0); i--)
    if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) != TYPE_CODE_FLT)
      startRegNum = i + 1;
#endif
@


1.12
log
@Add FIXME explaining include problem.
@
text
@d642 2
a643 1
  do_registers_info (regNum, 0);
@


1.12.8.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a48 1
#include "regcache.h"
d89 1
a89 1
static const char *_tuiRegisterName (int);
d314 1
a314 1
      int j, valueCharsWide, itemWinWidth, curY, labelWidth;
d438 2
d598 1
a598 1
static const char *
d625 1
a625 1
  const char *name;
d642 1
a642 2
  gdbarch_print_registers_info (current_gdbarch, stream, selected_frame,
                                regNum, 1);
d703 1
a703 1
  int endRegNum;
d706 6
d730 1
a730 1
  int endRegNum = (-1);
d733 6
d753 1
a753 1
  int startRegNum;
d756 6
@


1.12.10.1
log
@2002-08-27  Elena Zannoni  <ezannoni@@redhat.com>

       Fix PR gdb/675
       * tuiWin.c: Include readline/readline.h. Use accessor function
       rl_get_screen_size.

       * tuiRegs.c (_tuiRegisterFormat): Use DO_REGISTERS_INFO instead of
       do_registers_info.
@
text
@d642 1
a642 1
  DO_REGISTERS_INFO (regNum, 0);
@


1.11
log
@2002-02-08  Daniel Jacobowitz  <drow@@mvista.com>

        * utils.c: Include <curses.h> before "bfd.h".
        * tui/tui-hooks.c: Likewise.
        * tui/tui.c: Likewise.
        * tui/tuiCommand.c: Likewise.
        * tui/tuiData.c: Likewise.
        * tui/tuiDataWin.c: Likewise.
        * tui/tuiDisassem.c: Likewise.
        * tui/tuiGeneralWin.c: Likewise.
        * tui/tuiIO.c: Likewise.
        * tui/tuiLayout.c: Likewise.
        * tui/tuiRegs.c: Likewise.
        * tui/tuiSource.c: Likewise.
        * tui/tuiSourceWin.c: Likewise.
        * tui/tuiStack.c: Likewise.
        * tui/tuiWin.c: Likewise.
@
text
@d2 4
a5 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d25 8
a32 1
/* If we need <curses.h>, we must include it before we get "bfd.h".  */
@


1.10
log
@	* tuiRegs.c (tuiDisplayRegistersFrom): Call touchwin.
	(_tuiRegisterFormat): Reduce size of format result.
@
text
@d22 10
@


1.9
log
@	* tuiWin.c (_initialize_tuiWin): Always define the tui commands;
	create the tui class help.
	* tuiLayout.c (_initialize_tuiLayout): Always define the tui commands.
	* tuiRegs.c (_initialize_tuiRegs): Likewise.
	* tuiStack.c (_initialize_tuiStack): Likewise.
@
text
@d350 2
d608 1
d625 17
a641 1
  strncpy (buf, tui_file_get_strbuf (stream), bufLen);
@


1.8
log
@	* tuiIO.c (_tuiHandleResizeDuringIO): Call tuiRefreshAll.
	(tuiRead, tui_vread): Remove.

	* tui.c (va_catch_errors, tuiDo, tuiDoAndReturnToTop): Remove.
	(vcatch_errors, _tui_vDo): Remove.
	* tui.h (tuiDo, tuiDoAndReturnToTop): Remove.

	* tuiLayout.c (tuiSetLayout): Remove vcatch_errors.
	(tui_set_layout): Rename of _tuiSetLayoutTo, public.
	(_tuiToggleLayout_command): Merge with _tui_vToggleLayout_command.
	(_tuiToggleSplitLayout_command): Merge with _tui_vToggleSplitLayout_command.
	(_tuiLayout_command): Call tui_set_layout.

	* tuiRegs.c (_tuiScrollRegsBackward_command): Call tui_scroll.
	(_tuiScrollRegsForward_command): Likewise.
	(_tuiShowFloat_command): Call _tui_vShowRegisters_commandSupport.
	(_tuiShowGeneral_command): Likewise.
	(_tuiShowSpecial_command): Likewise.
	(_tuiToggleFloatRegs_command): Call tuiToggleFloatRegs.
	* tuiWin.c (tui_scroll): Rename of tui_vScroll, update parameters.
	(_tuiScrollForward_command): Call tui_scroll.
	(_tuiScrollBackward_command): Likewise.
	(_tuiScrollLeft_command): Likewise.
	(_tuiScrollRight_command): Likewise.
	(_tuiSetFocus_command): Call _tuiSetFocus.
	(_tuiRefreshAll_command): Call tuiRefreshAll.
	(_tuiSetWinHeight_command): Call _tuiSetWinHeight.
	(_tuiXDBsetWinHeight_command): Call _tuiXDBsetWinHeight.
	* tuiWin.h (tui_scroll): Rename of tui_vScroll, update parameters.
@
text
@d543 1
a543 1
  if (tui_version && xdb_commands)
d564 1
a564 3

  return;
}				/* _initialize_tuiRegs */
@


1.7
log
@	* tuiRegs.c (tuiDisplayRegistersFrom): Set scrollok to FALSE in
	each register window.
	(tuiCheckRegisterValues): Use REGISTER_RAW_SIZE to obtain the size
	of the register to check.
	(_tuiRegValueHasChanged): Likewise.
	(_tuiRegisterName): Use REGISTER_NAME.
	(tui_restore_gdbout): New function.
	(_tuiRegisterFormat): Use do_registers_info with gdb_stdout redirected
	to a string.
	(START_SPECIAL_REGS): Define.
	(_tuiGetRegisterRawValue): Use get_saved_register.
	(_tuiDisplayRegister): Fix clearing of register window.
@
text
@d33 2
d85 1
a85 1
static void _tui_vShowRegisters_commandSupport (va_list);
a88 1
static void _tui_vShowRegisters_commandSupport (va_list);
d965 1
a965 1
_tui_vShowRegisters_commandSupport (va_list args)
a966 1
  TuiRegisterDisplayType dpyType = va_arg (args, TuiRegisterDisplayType);
d986 1
a986 2
    tuiDo ((TuiOpaqueFuncPtr) _tui_vShowRegisters_commandSupport,
	   (tuiLayoutDef ())->floatRegsDisplayType);
d995 2
a996 5
  tuiDo ((TuiOpaqueFuncPtr) _tui_vShowRegisters_commandSupport,
	 TUI_GENERAL_REGS);

  return;
}				/* _tuiShowGeneral_command */
d1002 2
a1003 5
  tuiDo ((TuiOpaqueFuncPtr) _tui_vShowRegisters_commandSupport,
	 TUI_SPECIAL_REGS);

  return;
}				/* _tuiShowSpecial_command */
d1010 1
a1010 1
    tuiDo ((TuiOpaqueFuncPtr) tuiToggleFloatRegs);
d1029 2
a1030 4
  tuiDo ((TuiOpaqueFuncPtr) tui_vScroll, FORWARD_SCROLL, dataWin, 1);

  return;
}				/* _tuiScrollRegsForward_command */
d1036 2
a1037 4
  tuiDo ((TuiOpaqueFuncPtr) tui_vScroll, BACKWARD_SCROLL, dataWin, 1);

  return;
}				/* _tuiScrollRegsBackward_command */
@


1.6
log
@	* tuiWin.c, tui.c, tuiCommand.c: Use ansi prototype.
	tuiIO.c, tuiData.c: Likewise.
	tuiDataWin.c, tuiDisassem.c: Likewise.
	tuiGeneralWin.c, tuiLayout.c: Likewise.
	tuiRegs.c, tuiSource.c: Likewise.
	tuiSouceWin.c, tuiStack.c: Likewise.
@
text
@d33 1
a33 1

d46 1
a46 1
#define SINGLE_LABEL_WIDTH    10
d48 1
a48 1
#define SINGLE_VALUE_WIDTH    14	/* minimum of 8 but may be in sci notation */
d347 1
d488 4
a491 1
		  for (j = 0; j < MAX_REGISTER_RAW_SIZE; j++)
d580 3
a582 5
  if (reg_names[regNum] != (char *) NULL && *(reg_names[regNum]) != (char) 0)
    return reg_names[regNum];
  else
    return ((char *) NULL);
}				/* tuiGetRegisterName */
d584 7
a601 2
  char tmpBuf[15];
  char *fmt;
d603 14
a616 1

d618 11
a628 3
  pa_do_strcat_registers_info (regNum, 0, stream, precision);
  strcpy (buf, tui_file_get_strbuf (stream));
  ui_file_delete (stream);
d630 2
a631 2
  return;
}				/* _tuiRegisterFormat */
d651 3
d655 2
d712 1
a712 2
_tuiSetFloatRegsContent (TuiRegisterDisplayType dpyType,
                         int refreshValuesOnly)
d755 3
a757 1
	  for (i = 0; (i < MAX_REGISTER_RAW_SIZE && !hasChanged); i++)
d761 1
a761 1
	      for (i = 0; (i < MAX_REGISTER_RAW_SIZE); i++)
d776 1
a776 2
_tuiGetRegisterRawValue (int regNum, char *regValue,
                         struct frame_info *frame)
d782 6
a787 2
      read_relative_register_raw_bytes_for_frame (regNum, regValue, frame);
      ret = TUI_SUCCESS;
a788 1

d912 2
a913 1
      char buf[100];
d945 1
d949 3
a951 1
      werase (winInfo->handle);
@


1.5
log
@	* tuiWin.c, tuiWin.h, tui.c, tui.h, tuiCommand.c: Add FSF copyright.
	tuiCommand.h, tuiIO.c, tuiIO.h, tuiData.h, tuiData.c: Likewise.
	tuiDataWin.c, tuiDataWin.h, tuiDisassem.c, tuiDisassem.h: Likewise.
	tuiGeneralWin.c, tuiGeneralWin.h, tuiLayout.c, tuiLayout.h: Likewise.
	tuiRegs.c, tuiRegs.h, tuiSource.c, tuiSource.h: Likewise.
	tuiSouceWin.c, tuiSourceWin.h, tuiStack.c, tuiStack.h: Likewise.
@
text
@a100 1
#ifdef __STDC__
a101 3
#else
tuiLastRegsLineNo ()
#endif
d124 1
a124 7
#ifdef __STDC__
tuiLineFromRegElementNo (
			  int elementNo)
#else
tuiLineFromRegElementNo (elementNo)
     int elementNo;
#endif
d153 1
a153 7
#ifdef __STDC__
tuiFirstRegElementNoInLine (
			     int lineNo)
#else
tuiFirstRegElementNoInLine (lineNo)
     int lineNo;
#endif
d171 1
a171 7
#ifdef __STDC__
tuiLastRegElementNoInLine (
			    int lineNo)
#else
tuiLastRegElementNoInLine (lineNo)
     int lineNo;
#endif
d188 1
a188 7
#ifdef __STDC__
tuiCalculateRegsColumnCount (
			      TuiRegisterDisplayType dpyType)
#else
tuiCalculateRegsColumnCount (dpyType)
     TuiRegisterDisplayType dpyType;
#endif
d214 1
a214 7
#ifdef __STDC__
tuiShowRegisters (
		   TuiRegisterDisplayType dpyType)
#else
tuiShowRegisters (dpyType)
     TuiRegisterDisplayType dpyType;
#endif
d287 1
a287 7
#ifdef __STDC__
tuiDisplayRegistersFrom (
			  int startElementNo)
#else
tuiDisplayRegistersFrom (startElementNo)
     int startElementNo;
#endif
d373 1
a373 9
#ifdef __STDC__
tuiDisplayRegElementAtLine (
			     int startElementNo,
			     int startLineNo)
#else
tuiDisplayRegElementAtLine (startElementNo, startLineNo)
     int startElementNo;
     int startLineNo;
#endif
d412 1
a412 9
#ifdef __STDC__
tuiDisplayRegistersFromLine (
			      int lineNo,
			      int forceDisplay)
#else
tuiDisplayRegistersFromLine (lineNo, forceDisplay)
     int lineNo;
     int forceDisplay;
#endif
d459 1
a459 7
#ifdef __STDC__
tuiCheckRegisterValues (
			 struct frame_info *frame)
#else
tuiCheckRegisterValues (frame)
     struct frame_info *frame;
#endif
a516 1
#ifdef __STDC__
a517 3
#else
tuiToggleFloatRegs ()
#endif
d574 1
a574 7
#ifdef __STDC__
_tuiRegisterName (
		   int regNum)
#else
_tuiRegisterName (regNum)
     int regNum;
#endif
d589 3
a591 15
#ifdef __STDC__
_tuiRegisterFormat (
		     char *buf,
		     int bufLen,
		     int regNum,
		     TuiDataElementPtr dataElement,
		     enum precision_type precision)
#else
_tuiRegisterFormat (buf, bufLen, regNum, dataElement, precision)
     char *buf;
     int bufLen;
     int regNum;
     TuiDataElementPtr dataElement;
     enum precision_type precision;
#endif
d612 1
a612 7
#ifdef __STDC__
_tuiSetGeneralRegsContent (
			    int refreshValuesOnly)
#else
_tuiSetGeneralRegsContent (refreshValuesOnly)
     int refreshValuesOnly;
#endif
d629 1
a629 7
#ifdef __STDC__
_tuiSetSpecialRegsContent (
			    int refreshValuesOnly)
#else
_tuiSetSpecialRegsContent (refreshValuesOnly)
     int refreshValuesOnly;
#endif
d656 1
a656 7
#ifdef __STDC__
_tuiSetGeneralAndSpecialRegsContent (
				      int refreshValuesOnly)
#else
_tuiSetGeneralAndSpecialRegsContent (refreshValuesOnly)
     int refreshValuesOnly;
#endif
d679 2
a680 9
#ifdef __STDC__
_tuiSetFloatRegsContent (
			  TuiRegisterDisplayType dpyType,
			  int refreshValuesOnly)
#else
_tuiSetFloatRegsContent (dpyType, refreshValuesOnly)
     TuiRegisterDisplayType dpyType;
     int refreshValuesOnly;
#endif
d708 3
a710 11
#ifdef __STDC__
_tuiRegValueHasChanged (
			 TuiDataElementPtr dataElement,
			 struct frame_info *frame,
			 char *newValue)
#else
_tuiRegValueHasChanged (dataElement, frame, newValue)
     TuiDataElementPtr dataElement;
     struct frame_info *frame;
     char *newValue;
#endif
d742 2
a743 11
#ifdef __STDC__
_tuiGetRegisterRawValue (
			  int regNum,
			  char *regValue,
			  struct frame_info *frame)
#else
_tuiGetRegisterRawValue (regNum, regValue, frame)
     int regNum;
     char *regValue;
     struct frame_info *frame;
#endif
d764 3
a766 13
#ifdef __STDC__
_tuiSetRegisterElement (
			 int regNum,
			 struct frame_info *frame,
			 TuiDataElementPtr dataElement,
			 int refreshValueOnly)
#else
_tuiSetRegisterElement (regNum, frame, dataElement, refreshValueOnly)
     int regNum;
     struct frame_info *frame;
     TuiDataElementPtr dataElement;
     int refreshValueOnly;
#endif
d793 4
a796 15
#ifdef __STDC__
_tuiSetRegsContent (
		     int startRegNum,
		     int endRegNum,
		     struct frame_info *frame,
		     TuiRegisterDisplayType dpyType,
		     int refreshValuesOnly)
#else
_tuiSetRegsContent (startRegNum, endRegNum, frame, dpyType, refreshValuesOnly)
     int startRegNum;
     int endRegNum;
     struct frame_info *frame;
     TuiRegisterDisplayType dpyType;
     int refreshValuesOnly;
#endif
d870 3
a872 11
#ifdef __STDC__
_tuiDisplayRegister (
		      int regNum,
		      TuiGenWinInfoPtr winInfo,		/* the data item window */
		      enum precision_type precision)
#else
_tuiDisplayRegister (regNum, winInfo, precision)
     int regNum;
     TuiGenWinInfoPtr winInfo;	/* the data item window */
     enum precision_type precision;
#endif
d924 1
a924 7
#ifdef __STDC__
_tui_vShowRegisters_commandSupport (
				     va_list args)
#else
_tui_vShowRegisters_commandSupport (args)
     va_list args;
#endif
d941 1
a941 9
#ifdef __STDC__
_tuiShowFloat_command (
			char *arg,
			int fromTTY)
#else
_tuiShowFloat_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d954 1
a954 9
#ifdef __STDC__
_tuiShowGeneral_command (
			  char *arg,
			  int fromTTY)
#else
_tuiShowGeneral_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d964 1
a964 9
#ifdef __STDC__
_tuiShowSpecial_command (
			  char *arg,
			  int fromTTY)
#else
_tuiShowSpecial_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d974 1
a974 9
#ifdef __STDC__
_tuiToggleFloatRegs_command (
			      char *arg,
			      int fromTTY)
#else
_tuiToggleFloatRegs_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d994 1
a994 9
#ifdef __STDC__
_tuiScrollRegsForward_command (
				char *arg,
				int fromTTY)
#else
_tuiScrollRegsForward_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d1003 1
a1003 9
#ifdef __STDC__
_tuiScrollRegsBackward_command (
				 char *arg,
				 int fromTTY)
#else
_tuiScrollRegsBackward_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
@


1.4
log
@Eliminate ARCH_NUM_REGS.
@
text
@d1 3
d5 1
a5 5
/*
   ** tuiRegs.c
   **         This module contains functions to support display of registers
   **         in the data window.
 */
d7 14
@


1.3
log
@Protoization.
@
text
@d720 1
a720 1
  for (i = START_SPECIAL_REGS; (i < ARCH_NUM_REGS && endRegNum < 0); i++)
d753 1
a753 1
  for (i = 0; (i < ARCH_NUM_REGS && endRegNum < 0); i++)
d784 1
a784 1
  for (i = ARCH_NUM_REGS - 1; (i >= 0 && startRegNum < 0); i--)
d789 1
a789 1
			    ARCH_NUM_REGS - 1,
@


1.2
log
@PARAMS removal.
@
text
@d589 1
a589 1
_initialize_tuiRegs ()
@


1.1
log
@Initial revision
@
text
@d3 4
a6 4
** tuiRegs.c
**         This module contains functions to support display of registers
**         in the data window.
*/
d35 1
a35 1
#define SINGLE_VALUE_WIDTH    14/* minimum of 8 but may be in sci notation */
d53 3
a55 5
  PARAMS ((int, int, struct frame_info *,
	   TuiRegisterDisplayType, int));
static char *_tuiRegisterName PARAMS ((int));
static TuiStatus _tuiGetRegisterRawValue
  PARAMS ((int, char *, struct frame_info *));
d57 2
a58 4
  PARAMS ((int, struct frame_info *,
	   TuiDataElementPtr, int));
static void _tuiDisplayRegister
  PARAMS ((int, TuiGenWinInfoPtr, enum precision_type));
d60 5
a64 6
  PARAMS ((char *, int, int, TuiDataElementPtr,
	   enum precision_type));
static TuiStatus _tuiSetGeneralRegsContent PARAMS ((int));
static TuiStatus _tuiSetSpecialRegsContent PARAMS ((int));
static TuiStatus _tuiSetGeneralAndSpecialRegsContent PARAMS ((int));
static TuiStatus _tuiSetFloatRegsContent PARAMS ((TuiRegisterDisplayType, int));
d66 9
a74 10
  PARAMS ((TuiDataElementPtr, struct frame_info *,
	   char *));
static void _tuiShowFloat_command PARAMS ((char *, int));
static void _tuiShowGeneral_command PARAMS ((char *, int));
static void _tuiShowSpecial_command PARAMS ((char *, int));
static void _tui_vShowRegisters_commandSupport PARAMS ((va_list));
static void _tuiToggleFloatRegs_command PARAMS ((char *, int));
static void _tuiScrollRegsForward_command PARAMS ((char *, int));
static void _tuiScrollRegsBackward_command PARAMS ((char *, int));
static void _tui_vShowRegisters_commandSupport PARAMS ((va_list));
d83 4
a86 4
** tuiLastRegsLineNo()
**        Answer the number of the last line in the regs display.
**        If there are no registers (-1) is returned.
*/
d109 5
a113 5
** tuiLineFromRegElementNo()
**        Answer the line number that the register element at elementNo is
**        on.  If elementNo is greater than the number of register elements
**        there are, -1 is returned.
*/
d145 4
a148 4
** tuiFirstRegElementNoInLine()
**        Answer the index of the first element in lineNo.  If lineNo is
**        past the register area (-1) is returned.
*/
d169 4
a172 4
** tuiLastRegElementNoInLine()
**        Answer the index of the last element in lineNo.  If lineNo is past
**        the register area (-1) is returned.
*/
d192 4
a195 4
** tuiCalculateRegsColumnCount
**        Calculate the number of columns that should be used to display
**        the registers.
*/
d223 5
a227 5
** tuiShowRegisters().
**        Show the registers int the data window as indicated by dpyType.
**        If there is any other registers being displayed, then they are
**        cleared.  What registers are displayed is dependent upon dpyType.
*/
d301 6
a306 6
** tuiDisplayRegistersFrom().
**        Function to display the registers in the content from
**        'startElementNo' until the end of the register content or the
**        end of the display height.  No checking for displaying past
**        the end of the registers is done here.
*/
d348 2
a349 2
        ** Now create each data "sub" window, and write the display into it.
        */
d361 1
a361 1
	      /* create the window if necessary*/
d376 3
a378 3
                ** Get the printable representation of the register
                ** and display it
                */
d392 7
a398 7
** tuiDisplayRegElementAtLine().
**        Function to display the registers in the content from
**        'startElementNo' on 'startLineNo' until the end of the
**        register content or the end of the display height.
**        This function checks that we won't display off the end
**        of the register display.
*/
d424 4
a427 4
            ** If there is no other data displayed except registers,
            ** and the elementNo causes us to scroll past the end of the
            ** registers, adjust what element to really start the display at.
            */
d441 5
a445 5
** tuiDisplayRegistersFromLine().
**        Function to display the registers starting at line lineNo in
**        the data window.  Answers the line number that the display
**        actually started from.  If nothing is displayed (-1) is returned.
*/
d467 3
a469 3
            ** If we must display regs (forceDisplay is true), then make
            ** sure that we don't display off the end of the registers.
            */
d496 5
a500 5
** tuiCheckRegisterValues()
**        This function check all displayed registers for changes in
**        values, given a particular frame.  If the values have changed,
**        they are updated with the new value and highlighted.
*/
d563 2
a564 2
** tuiToggleFloatRegs().
*/
d623 3
a625 3
** _tuiRegisterName().
**        Return the register name.
*/
d643 4
a646 4
** _tuiRegisterFormat
**        Function to format the register name and value into a buffer,
**        suitable for printing or display
*/
d666 1
a666 1
  GDB_FILE *stream;
d668 1
a668 1
  stream = gdb_file_init_astring(bufLen);
d670 2
a671 2
  strcpy (buf, gdb_file_get_strbuf(stream));
  gdb_file_deallocate(&stream);
d679 3
a681 3
** _tuiSetGeneralRegsContent().
**      Set the content of the data window to consist of the general registers.
*/
d702 3
a704 3
** _tuiSetSpecialRegsContent().
**      Set the content of the data window to consist of the special registers.
*/
d735 3
a737 3
** _tuiSetGeneralAndSpecialRegsContent().
**      Set the content of the data window to consist of the special registers.
*/
d764 3
a766 3
** _tuiSetFloatRegsContent().
**        Set the content of the data window to consist of the float registers.
*/
d799 4
a802 4
** _tuiRegValueHasChanged().
**        Answer TRUE if the register's value has changed, FALSE otherwise.
**        If TRUE, newValue is filled in with the new value.
*/
d842 3
a844 3
** _tuiGetRegisterRawValue().
**        Get the register raw value.  The raw value is returned in regValue.
*/
d872 4
a875 4
** _tuiSetRegisterElement().
**       Function to initialize a data element with the input and
**       the register value.
*/
d910 5
a914 5
** _tuiSetRegsContent().
**        Set the content of the data window to consist of the registers
**        numbered from startRegNum to endRegNum.  Note that if
**        refreshValuesOnly is TRUE, startRegNum and endRegNum are ignored.
*/
d964 2
a965 2
        ** Now set the register names and values
        */
d999 4
a1002 4
** _tuiDisplayRegister().
**        Function to display a register in a window.  If hilite is TRUE,
**        than the value will be displayed in reverse video
*/
d1007 1
a1007 1
		      TuiGenWinInfoPtr winInfo,	/* the data item window */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d3 4
a6 4
   ** tuiRegs.c
   **         This module contains functions to support display of registers
   **         in the data window.
 */
d35 1
a35 1
#define SINGLE_VALUE_WIDTH    14	/* minimum of 8 but may be in sci notation */
d89 4
a92 4
   ** tuiLastRegsLineNo()
   **        Answer the number of the last line in the regs display.
   **        If there are no registers (-1) is returned.
 */
d115 5
a119 5
   ** tuiLineFromRegElementNo()
   **        Answer the line number that the register element at elementNo is
   **        on.  If elementNo is greater than the number of register elements
   **        there are, -1 is returned.
 */
d151 4
a154 4
   ** tuiFirstRegElementNoInLine()
   **        Answer the index of the first element in lineNo.  If lineNo is
   **        past the register area (-1) is returned.
 */
d175 4
a178 4
   ** tuiLastRegElementNoInLine()
   **        Answer the index of the last element in lineNo.  If lineNo is past
   **        the register area (-1) is returned.
 */
d198 4
a201 4
   ** tuiCalculateRegsColumnCount
   **        Calculate the number of columns that should be used to display
   **        the registers.
 */
d229 5
a233 5
   ** tuiShowRegisters().
   **        Show the registers int the data window as indicated by dpyType.
   **        If there is any other registers being displayed, then they are
   **        cleared.  What registers are displayed is dependent upon dpyType.
 */
d307 6
a312 6
   ** tuiDisplayRegistersFrom().
   **        Function to display the registers in the content from
   **        'startElementNo' until the end of the register content or the
   **        end of the display height.  No checking for displaying past
   **        the end of the registers is done here.
 */
d354 2
a355 2
         ** Now create each data "sub" window, and write the display into it.
       */
d367 1
a367 1
	      /* create the window if necessary */
d382 3
a384 3
	         ** Get the printable representation of the register
	         ** and display it
	       */
d398 7
a404 7
   ** tuiDisplayRegElementAtLine().
   **        Function to display the registers in the content from
   **        'startElementNo' on 'startLineNo' until the end of the
   **        register content or the end of the display height.
   **        This function checks that we won't display off the end
   **        of the register display.
 */
d430 4
a433 4
	     ** If there is no other data displayed except registers,
	     ** and the elementNo causes us to scroll past the end of the
	     ** registers, adjust what element to really start the display at.
	   */
d447 5
a451 5
   ** tuiDisplayRegistersFromLine().
   **        Function to display the registers starting at line lineNo in
   **        the data window.  Answers the line number that the display
   **        actually started from.  If nothing is displayed (-1) is returned.
 */
d473 3
a475 3
				   ** If we must display regs (forceDisplay is true), then make
				   ** sure that we don't display off the end of the registers.
				 */
d502 5
a506 5
   ** tuiCheckRegisterValues()
   **        This function check all displayed registers for changes in
   **        values, given a particular frame.  If the values have changed,
   **        they are updated with the new value and highlighted.
 */
d569 2
a570 2
   ** tuiToggleFloatRegs().
 */
d629 3
a631 3
   ** _tuiRegisterName().
   **        Return the register name.
 */
d649 4
a652 4
   ** _tuiRegisterFormat
   **        Function to format the register name and value into a buffer,
   **        suitable for printing or display
 */
d674 1
a674 1
  stream = gdb_file_init_astring (bufLen);
d676 2
a677 2
  strcpy (buf, gdb_file_get_strbuf (stream));
  gdb_file_deallocate (&stream);
d685 3
a687 3
   ** _tuiSetGeneralRegsContent().
   **      Set the content of the data window to consist of the general registers.
 */
d708 3
a710 3
   ** _tuiSetSpecialRegsContent().
   **      Set the content of the data window to consist of the special registers.
 */
d741 3
a743 3
   ** _tuiSetGeneralAndSpecialRegsContent().
   **      Set the content of the data window to consist of the special registers.
 */
d770 3
a772 3
   ** _tuiSetFloatRegsContent().
   **        Set the content of the data window to consist of the float registers.
 */
d805 4
a808 4
   ** _tuiRegValueHasChanged().
   **        Answer TRUE if the register's value has changed, FALSE otherwise.
   **        If TRUE, newValue is filled in with the new value.
 */
d848 3
a850 3
   ** _tuiGetRegisterRawValue().
   **        Get the register raw value.  The raw value is returned in regValue.
 */
d878 4
a881 4
   ** _tuiSetRegisterElement().
   **       Function to initialize a data element with the input and
   **       the register value.
 */
d916 5
a920 5
   ** _tuiSetRegsContent().
   **        Set the content of the data window to consist of the registers
   **        numbered from startRegNum to endRegNum.  Note that if
   **        refreshValuesOnly is TRUE, startRegNum and endRegNum are ignored.
 */
d970 2
a971 2
         ** Now set the register names and values
       */
d1005 4
a1008 4
   ** _tuiDisplayRegister().
   **        Function to display a register in a window.  If hilite is TRUE,
   **        than the value will be displayed in reverse video
 */
d1013 1
a1013 1
		      TuiGenWinInfoPtr winInfo,		/* the data item window */
@


1.1.1.3
log
@import gdb-1999-11-08 snapshot
@
text
@d674 1
a674 1
  stream = tui_sfileopen (bufLen);
d676 2
a677 2
  strcpy (buf, tui_file_get_strbuf (stream));
  gdb_file_delete (stream);
@


1.1.1.4
log
@import gdb-2000-02-01 snapshot
@
text
@d672 1
a672 1
  struct ui_file *stream;
d677 1
a677 1
  ui_file_delete (stream);
@


