head	1.13;
access;
symbols
	drow-cplus-merge-20040113:1.12
	drow-cplus-merge-20031224:1.12
	drow-cplus-merge-20031220:1.12
	carlton_dictionary-20031215-merge:1.12
	drow-cplus-merge-20031214:1.12
	carlton-dictionary-20031111-merge:1.12
	gdb_6_0-2003-10-04-release:1.12
	kettenis_sparc-20030918-branch:1.12.0.8
	kettenis_sparc-20030918-branchpoint:1.12
	carlton_dictionary-20030917-merge:1.12
	ezannoni_pie-20030916-branchpoint:1.12
	ezannoni_pie-20030916-branch:1.12.0.6
	cagney_x86i386-20030821-branch:1.12.0.4
	cagney_x86i386-20030821-branchpoint:1.12
	carlton_dictionary-20030805-merge:1.12
	carlton_dictionary-20030627-merge:1.12
	gdb_6_0-branch:1.12.0.2
	gdb_6_0-2003-06-23-branchpoint:1.12
	jimb-ppc64-linux-20030613-branch:1.11.0.38
	jimb-ppc64-linux-20030613-branchpoint:1.11
	cagney_convert-20030606-branch:1.11.0.36
	cagney_convert-20030606-branchpoint:1.11
	cagney_writestrings-20030508-branch:1.11.0.34
	cagney_writestrings-20030508-branchpoint:1.11
	jimb-ppc64-linux-20030528-branch:1.11.0.32
	jimb-ppc64-linux-20030528-branchpoint:1.11
	carlton_dictionary-20030523-merge:1.11
	cagney_fileio-20030521-branch:1.11.0.30
	cagney_fileio-20030521-branchpoint:1.11
	kettenis_i386newframe-20030517-mergepoint:1.11
	jimb-ppc64-linux-20030509-branch:1.11.0.28
	jimb-ppc64-linux-20030509-branchpoint:1.11
	kettenis_i386newframe-20030504-mergepoint:1.11
	carlton_dictionary-20030430-merge:1.11
	kettenis_i386newframe-20030419-branch:1.11.0.26
	kettenis_i386newframe-20030419-branchpoint:1.11
	carlton_dictionary-20030416-merge:1.11
	cagney_frameaddr-20030409-mergepoint:1.11
	kettenis_i386newframe-20030406-branch:1.11.0.24
	kettenis_i386newframe-20030406-branchpoint:1.11
	cagney_frameaddr-20030403-branchpoint:1.11
	cagney_frameaddr-20030403-branch:1.11.0.22
	cagney_framebase-20030330-mergepoint:1.11
	cagney_framebase-20030326-branch:1.11.0.20
	cagney_framebase-20030326-branchpoint:1.11
	cagney_lazyid-20030317-branch:1.11.0.18
	cagney_lazyid-20030317-branchpoint:1.11
	kettenis-i386newframe-20030316-mergepoint:1.11
	offbyone-20030313-branch:1.11.0.16
	offbyone-20030313-branchpoint:1.11
	kettenis-i386newframe-20030308-branch:1.11.0.14
	kettenis-i386newframe-20030308-branchpoint:1.11
	carlton_dictionary-20030305-merge:1.11
	cagney_offbyone-20030303-branch:1.11.0.12
	cagney_offbyone-20030303-branchpoint:1.11
	carlton_dictionary-20030207-merge:1.11
	interps-20030203-mergepoint:1.11
	interps-20030202-branch:1.11.0.10
	interps-20030202-branchpoint:1.11
	cagney-unwind-20030108-branch:1.11.0.8
	cagney-unwind-20030108-branchpoint:1.11
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.11
	carlton_dictionary-20021115-merge:1.11
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.11
	drow-cplus-merge-20021025:1.11
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.11
	drow-cplus-branch:1.11.0.6
	drow-cplus-branchpoint:1.11
	kseitz_interps-20020930-merge:1.11
	carlton_dictionary-20020927-merge:1.11
	carlton_dictionary-branch:1.11.0.4
	carlton_dictionary-20020920-branchpoint:1.11
	gdb_5_3-branch:1.11.0.2
	gdb_5_3-2002-09-04-branchpoint:1.11
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.2
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.8.0.10
	readline_4_3-import-branchpoint:1.8
	gdb_5_2_1-2002-07-23-release:1.8
	kseitz_interps-20020528-branch:1.8.0.8
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.8.0.6
	cagney_regbuf-20020515-branchpoint:1.8
	jimb-macro-020506-branch:1.8.0.4
	jimb-macro-020506-branchpoint:1.8
	gdb_5_2-2002-04-29-release:1.8
	gdb_5_2-branch:1.8.0.2
	gdb_5_2-2002-03-03-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	cygnus_cvs_20020108_pre:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.4
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.2
	gdb_5_1-2001-07-29-branchpoint:1.6
	dberlin-typesystem-branch:1.3.0.2
	dberlin-typesystem-branchpoint:1.3
	gdb-post-ptid_t-2001-05-03:1.3
	gdb-pre-ptid_t-2001-05-03:1.3
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2004.01.19.04.31.51;	author cagney;	state dead;
branches;
next	1.12;

1.12
date	2003.06.22.15.21.38;	author drow;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	2002.09.01.10.49.00;	author ciceron;	state Exp;
branches
	1.11.4.1
	1.11.6.1;
next	1.10;

1.10
date	2002.08.30.20.07.05;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.25.11.00.46;	author ciceron;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.01.06.19.28;	author cagney;	state Exp;
branches
	1.8.8.1;
next	1.7;

1.7
date	2002.02.08.15.54.32;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.20.23.06.48;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.14.19.31.09;	author ciceron;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.14.19.01.25;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.01.01.51;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.42;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.12;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.12;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.19.12;	author jsm;	state Exp;
branches;
next	;

1.8.8.1
date	2002.08.30.22.52.52;	author kseitz;	state Exp;
branches;
next	1.8.8.2;

1.8.8.2
date	2002.10.01.00.46.34;	author kseitz;	state Exp;
branches;
next	;

1.11.4.1
date	2003.06.27.21.50.21;	author carlton;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2004.01.26.19.11.45;	author carlton;	state dead;
branches;
next	;

1.11.6.1
date	2003.12.14.20.27.59;	author drow;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2004.02.09.19.43.58;	author drow;	state dead;
branches;
next	;

1.12.6.1
date	2004.03.23.20.09.16;	author ezannoni;	state dead;
branches;
next	;


desc
@@


1.13
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@/* TUI data manipulation routines.

   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "symtab.h"
#include "tui.h"
#include "tuiData.h"
#include "tuiGeneralWin.h"

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

/****************************
** GLOBAL DECLARATIONS
****************************/
TuiWinInfoPtr winList[MAX_MAJOR_WINDOWS];

/***************************
** Private data
****************************/
static TuiLayoutType _currentLayout = UNDEFINED_LAYOUT;
static int _termHeight, _termWidth;
static TuiGenWinInfo _locator;
static TuiGenWinInfo _execInfo[2];
static TuiWinInfoPtr _srcWinList[2];
static TuiList _sourceWindows =
{(OpaqueList) _srcWinList, 0};
static int _defaultTabLen = DEFAULT_TAB_LEN;
static TuiWinInfoPtr _winWithFocus = (TuiWinInfoPtr) NULL;
static TuiLayoutDef _layoutDef =
{SRC_WIN,			/* displayMode */
 FALSE,				/* split */
 TUI_UNDEFINED_REGS,		/* regsDisplayType */
 TUI_SFLOAT_REGS};		/* floatRegsDisplayType */
static int _winResized = FALSE;


/*********************************
** Static function forward decls
**********************************/
static void freeContent (TuiWinContent, int, TuiWinType);
static void freeContentElements (TuiWinContent, int, TuiWinType);



/*********************************
** PUBLIC FUNCTIONS
**********************************/

/******************************************
** ACCESSORS & MUTATORS FOR PRIVATE DATA
******************************************/

/*
   ** tuiWinResized().
   **        Answer a whether the terminal window has been resized or not
 */
int
tuiWinResized (void)
{
  return _winResized;
}				/* tuiWinResized */


/*
   ** tuiSetWinResized().
   **        Set a whether the terminal window has been resized or not
 */
void
tuiSetWinResizedTo (int resized)
{
  _winResized = resized;

  return;
}				/* tuiSetWinResizedTo */


/*
   ** tuiLayoutDef().
   **        Answer a pointer to the current layout definition
 */
TuiLayoutDefPtr
tuiLayoutDef (void)
{
  return &_layoutDef;
}				/* tuiLayoutDef */


/*
   ** tuiWinWithFocus().
   **        Answer the window with the logical focus
 */
TuiWinInfoPtr
tuiWinWithFocus (void)
{
  return _winWithFocus;
}				/* tuiWinWithFocus */


/*
   ** tuiSetWinWithFocus().
   **        Set the window that has the logical focus
 */
void
tuiSetWinWithFocus (TuiWinInfoPtr winInfo)
{
  _winWithFocus = winInfo;

  return;
}				/* tuiSetWinWithFocus */


/*
   ** tuiDefaultTabLen().
   **        Answer the length in chars, of tabs
 */
int
tuiDefaultTabLen (void)
{
  return _defaultTabLen;
}				/* tuiDefaultTabLen */


/*
   ** tuiSetDefaultTabLen().
   **        Set the length in chars, of tabs
 */
void
tuiSetDefaultTabLen (int len)
{
  _defaultTabLen = len;

  return;
}				/* tuiSetDefaultTabLen */


/*
   ** currentSourceWin()
   **        Accessor for the current source window.  Usually there is only
   **        one source window (either source or disassembly), but both can
   **        be displayed at the same time.
 */
TuiListPtr
sourceWindows (void)
{
  return &_sourceWindows;
}				/* currentSourceWindows */


/*
   ** clearSourceWindows()
   **        Clear the list of source windows.  Usually there is only one
   **        source window (either source or disassembly), but both can be
   **        displayed at the same time.
 */
void
clearSourceWindows (void)
{
  _sourceWindows.list[0] = (Opaque) NULL;
  _sourceWindows.list[1] = (Opaque) NULL;
  _sourceWindows.count = 0;

  return;
}				/* currentSourceWindows */


/*
   ** clearSourceWindowsDetail()
   **        Clear the pertinant detail in the source windows.
 */
void
clearSourceWindowsDetail (void)
{
  int i;

  for (i = 0; i < (sourceWindows ())->count; i++)
    clearWinDetail ((TuiWinInfoPtr) (sourceWindows ())->list[i]);

  return;
}				/* currentSourceWindows */


/*
   ** addSourceWindowToList().
   **       Add a window to the list of source windows.  Usually there is
   **       only one source window (either source or disassembly), but
   **       both can be displayed at the same time.
 */
void
addToSourceWindows (TuiWinInfoPtr winInfo)
{
  if (_sourceWindows.count < 2)
    _sourceWindows.list[_sourceWindows.count++] = (Opaque) winInfo;

  return;
}				/* addToSourceWindows */


/*
   ** clearWinDetail()
   **        Clear the pertinant detail in the windows.
 */
void
clearWinDetail (TuiWinInfoPtr winInfo)
{
  if (m_winPtrNotNull (winInfo))
    {
      switch (winInfo->generic.type)
	{
	case SRC_WIN:
	case DISASSEM_WIN:
	  winInfo->detail.sourceInfo.startLineOrAddr.addr = 0;
	  winInfo->detail.sourceInfo.horizontalOffset = 0;
	  break;
	case CMD_WIN:
	  winInfo->detail.commandInfo.curLine =
	    winInfo->detail.commandInfo.curch = 0;
	  break;
	case DATA_WIN:
	  winInfo->detail.dataDisplayInfo.dataContent =
	    (TuiWinContent) NULL;
	  winInfo->detail.dataDisplayInfo.dataContentCount = 0;
	  winInfo->detail.dataDisplayInfo.regsContent =
	    (TuiWinContent) NULL;
	  winInfo->detail.dataDisplayInfo.regsContentCount = 0;
	  winInfo->detail.dataDisplayInfo.regsDisplayType =
	    TUI_UNDEFINED_REGS;
	  winInfo->detail.dataDisplayInfo.regsColumnCount = 1;
	  winInfo->detail.dataDisplayInfo.displayRegs = FALSE;
	  break;
	default:
	  break;
	}
    }

  return;
}				/* clearWinDetail */


/*
   ** sourceExecInfoPtr().
   **        Accessor for the source execution info ptr.
 */
TuiGenWinInfoPtr
sourceExecInfoWinPtr (void)
{
  return &_execInfo[0];
}				/* sourceExecInfoWinPtr */


/*
   ** disassemExecInfoPtr().
   **        Accessor for the disassem execution info ptr.
 */
TuiGenWinInfoPtr
disassemExecInfoWinPtr (void)
{
  return &_execInfo[1];
}				/* disassemExecInfoWinPtr */


/*
   ** locatorWinInfoPtr().
   **        Accessor for the locator win info.  Answers a pointer to the
   **        static locator win info struct.
 */
TuiGenWinInfoPtr
locatorWinInfoPtr (void)
{
  return &_locator;
}				/* locatorWinInfoPtr */


/*
   ** termHeight().
   **        Accessor for the termHeight
 */
int
termHeight (void)
{
  return _termHeight;
}				/* termHeight */


/*
   ** setTermHeightTo().
   **        Mutator for the term height
 */
void
setTermHeightTo (int h)
{
  _termHeight = h;

  return;
}				/* setTermHeightTo */


/*
   ** termWidth().
   **        Accessor for the termWidth
 */
int
termWidth (void)
{
  return _termWidth;
}				/* termWidth */


/*
   ** setTermWidth().
   **        Mutator for the termWidth
 */
void
setTermWidthTo (int w)
{
  _termWidth = w;

  return;
}				/* setTermWidthTo */


/*
   ** currentLayout().
   **        Accessor for the current layout
 */
TuiLayoutType
currentLayout (void)
{
  return _currentLayout;
}				/* currentLayout */


/*
   ** setCurrentLayoutTo().
   **        Mutator for the current layout
 */
void
setCurrentLayoutTo (TuiLayoutType newLayout)
{
  _currentLayout = newLayout;

  return;
}				/* setCurrentLayoutTo */


/*
   ** setGenWinOrigin().
   **        Set the origin of the window
 */
void
setGenWinOrigin (TuiGenWinInfoPtr winInfo, int x, int y)
{
  winInfo->origin.x = x;
  winInfo->origin.y = y;

  return;
}				/* setGenWinOrigin */


/*****************************
** OTHER PUBLIC FUNCTIONS
*****************************/


/*
   ** tuiNextWin().
   **        Answer the next window in the list, cycling back to the top
   **        if necessary
 */
TuiWinInfoPtr
tuiNextWin (TuiWinInfoPtr curWin)
{
  TuiWinType type = curWin->generic.type;
  TuiWinInfoPtr nextWin = (TuiWinInfoPtr) NULL;

  if (curWin->generic.type == CMD_WIN)
    type = SRC_WIN;
  else
    type = curWin->generic.type + 1;
  while (type != curWin->generic.type && m_winPtrIsNull (nextWin))
    {
      if (winList[type] && winList[type]->generic.isVisible)
	nextWin = winList[type];
      else
	{
	  if (type == CMD_WIN)
	    type = SRC_WIN;
	  else
	    type++;
	}
    }

  return nextWin;
}				/* tuiNextWin */


/*
   ** tuiPrevWin().
   **        Answer the prev window in the list, cycling back to the bottom
   **        if necessary
 */
TuiWinInfoPtr
tuiPrevWin (TuiWinInfoPtr curWin)
{
  TuiWinType type = curWin->generic.type;
  TuiWinInfoPtr prev = (TuiWinInfoPtr) NULL;

  if (curWin->generic.type == SRC_WIN)
    type = CMD_WIN;
  else
    type = curWin->generic.type - 1;
  while (type != curWin->generic.type && m_winPtrIsNull (prev))
    {
      if (winList[type]->generic.isVisible)
	prev = winList[type];
      else
	{
	  if (type == SRC_WIN)
	    type = CMD_WIN;
	  else
	    type--;
	}
    }

  return prev;
}


/*
   **  partialWinByName().
   **      Answer the window represented by name
 */
TuiWinInfoPtr
partialWinByName (char *name)
{
  TuiWinInfoPtr winInfo = (TuiWinInfoPtr) NULL;

  if (name != (char *) NULL)
    {
      int i = 0;

      while (i < MAX_MAJOR_WINDOWS && m_winPtrIsNull (winInfo))
	{
          if (winList[i] != 0)
            {
              char *curName = winName (&winList[i]->generic);
              if (strlen (name) <= strlen (curName) &&
                  strncmp (name, curName, strlen (name)) == 0)
                winInfo = winList[i];
            }
	  i++;
	}
    }

  return winInfo;
}				/* partialWinByName */


/*
   ** winName().
   **      Answer the name of the window
 */
char *
winName (TuiGenWinInfoPtr winInfo)
{
  char *name = (char *) NULL;

  switch (winInfo->type)
    {
    case SRC_WIN:
      name = SRC_NAME;
      break;
    case CMD_WIN:
      name = CMD_NAME;
      break;
    case DISASSEM_WIN:
      name = DISASSEM_NAME;
      break;
    case DATA_WIN:
      name = DATA_NAME;
      break;
    default:
      name = "";
      break;
    }

  return name;
}				/* winName */


/*
   ** initializeStaticData
 */
void
initializeStaticData (void)
{
  initGenericPart (sourceExecInfoWinPtr ());
  initGenericPart (disassemExecInfoWinPtr ());
  initGenericPart (locatorWinInfoPtr ());

  return;
}				/* initializeStaticData */


/*
   ** allocGenericWinInfo().
 */
TuiGenWinInfoPtr
allocGenericWinInfo (void)
{
  TuiGenWinInfoPtr win;

  if ((win = (TuiGenWinInfoPtr) xmalloc (
		     sizeof (TuiGenWinInfoPtr))) != (TuiGenWinInfoPtr) NULL)
    initGenericPart (win);

  return win;
}				/* allocGenericWinInfo */


/*
   ** initGenericPart().
 */
void
initGenericPart (TuiGenWinInfoPtr win)
{
  win->width =
    win->height =
    win->origin.x =
    win->origin.y =
    win->viewportHeight =
    win->contentSize =
    win->lastVisibleLine = 0;
  win->handle = (WINDOW *) NULL;
  win->content = (OpaquePtr) NULL;
  win->contentInUse =
    win->isVisible = FALSE;
  win->title = 0;
}


/*
   ** initContentElement().
 */
void
initContentElement (TuiWinElementPtr element, TuiWinType type)
{
  element->highlight = FALSE;
  switch (type)
    {
    case SRC_WIN:
    case DISASSEM_WIN:
      element->whichElement.source.line = (char *) NULL;
      element->whichElement.source.lineOrAddr.lineNo = 0;
      element->whichElement.source.isExecPoint = FALSE;
      element->whichElement.source.hasBreak = FALSE;
      break;
    case DATA_WIN:
      initGenericPart (&element->whichElement.dataWindow);
      element->whichElement.dataWindow.type = DATA_ITEM_WIN;
      ((TuiGenWinInfoPtr) & element->whichElement.dataWindow)->content =
	(OpaquePtr) allocContent (1, DATA_ITEM_WIN);
      ((TuiGenWinInfoPtr)
       & element->whichElement.dataWindow)->contentSize = 1;
      break;
    case CMD_WIN:
      element->whichElement.command.line = (char *) NULL;
      break;
    case DATA_ITEM_WIN:
      element->whichElement.data.name = (char *) NULL;
      element->whichElement.data.type = TUI_REGISTER;
      element->whichElement.data.itemNo = UNDEFINED_ITEM;
      element->whichElement.data.value = (Opaque) NULL;
      element->whichElement.data.highlight = FALSE;
      break;
    case LOCATOR_WIN:
      element->whichElement.locator.fileName[0] =
	element->whichElement.locator.procName[0] = (char) 0;
      element->whichElement.locator.lineNo = 0;
      element->whichElement.locator.addr = 0;
      break;
    case EXEC_INFO_WIN:
      memset(element->whichElement.simpleString, ' ',
             sizeof(element->whichElement.simpleString));
      break;
    default:
      break;
    }
  return;
}				/* initContentElement */

/*
   ** initWinInfo().
 */
void
initWinInfo (TuiWinInfoPtr winInfo)
{
  initGenericPart (&winInfo->generic);
  winInfo->canHighlight =
    winInfo->isHighlighted = FALSE;
  switch (winInfo->generic.type)
    {
    case SRC_WIN:
    case DISASSEM_WIN:
      winInfo->detail.sourceInfo.executionInfo = (TuiGenWinInfoPtr) NULL;
      winInfo->detail.sourceInfo.hasLocator = FALSE;
      winInfo->detail.sourceInfo.horizontalOffset = 0;
      winInfo->detail.sourceInfo.startLineOrAddr.addr = 0;
      winInfo->detail.sourceInfo.filename = 0;
      break;
    case DATA_WIN:
      winInfo->detail.dataDisplayInfo.dataContent = (TuiWinContent) NULL;
      winInfo->detail.dataDisplayInfo.dataContentCount = 0;
      winInfo->detail.dataDisplayInfo.regsContent = (TuiWinContent) NULL;
      winInfo->detail.dataDisplayInfo.regsContentCount = 0;
      winInfo->detail.dataDisplayInfo.regsDisplayType =
	TUI_UNDEFINED_REGS;
      winInfo->detail.dataDisplayInfo.regsColumnCount = 1;
      winInfo->detail.dataDisplayInfo.displayRegs = FALSE;
      break;
    case CMD_WIN:
      winInfo->detail.commandInfo.curLine = 0;
      winInfo->detail.commandInfo.curch = 0;
      break;
    default:
      winInfo->detail.opaque = (Opaque) NULL;
      break;
    }

  return;
}				/* initWinInfo */


/*
   ** allocWinInfo().
 */
TuiWinInfoPtr
allocWinInfo (TuiWinType type)
{
  TuiWinInfoPtr winInfo = (TuiWinInfoPtr) NULL;

  winInfo = (TuiWinInfoPtr) xmalloc (sizeof (TuiWinInfo));
  if (m_winPtrNotNull (winInfo))
    {
      winInfo->generic.type = type;
      initWinInfo (winInfo);
    }

  return winInfo;
}				/* allocWinInfo */


/*
   ** allocContent().
   **        Allocates the content and elements in a block.
 */
TuiWinContent
allocContent (int numElements, TuiWinType type)
{
  TuiWinContent content = (TuiWinContent) NULL;
  char *elementBlockPtr = (char *) NULL;
  int i;

  if ((content = (TuiWinContent)
  xmalloc (sizeof (TuiWinElementPtr) * numElements)) != (TuiWinContent) NULL)
    {				/*
				   ** All windows, except the data window, can allocate the elements
				   ** in a chunk.  The data window cannot because items can be
				   ** added/removed from the data display by the user at any time.
				 */
      if (type != DATA_WIN)
	{
	  if ((elementBlockPtr = (char *)
	   xmalloc (sizeof (TuiWinElement) * numElements)) != (char *) NULL)
	    {
	      for (i = 0; i < numElements; i++)
		{
		  content[i] = (TuiWinElementPtr) elementBlockPtr;
		  initContentElement (content[i], type);
		  elementBlockPtr += sizeof (TuiWinElement);
		}
	    }
	  else
	    {
	      tuiFree ((char *) content);
	      content = (TuiWinContent) NULL;
	    }
	}
    }

  return content;
}				/* allocContent */


/*
   ** addContentElements().
   **        Adds the input number of elements to the windows's content.  If
   **        no content has been allocated yet, allocContent() is called to
   **        do this.  The index of the first element added is returned,
   **        unless there is a memory allocation error, in which case, (-1)
   **        is returned.
 */
int
addContentElements (TuiGenWinInfoPtr winInfo, int numElements)
{
  TuiWinElementPtr elementPtr;
  int i, indexStart;

  if (winInfo->content == (OpaquePtr) NULL)
    {
      winInfo->content = (OpaquePtr) allocContent (numElements, winInfo->type);
      indexStart = 0;
    }
  else
    indexStart = winInfo->contentSize;
  if (winInfo->content != (OpaquePtr) NULL)
    {
      for (i = indexStart; (i < numElements + indexStart); i++)
	{
	  if ((elementPtr = (TuiWinElementPtr)
	       xmalloc (sizeof (TuiWinElement))) != (TuiWinElementPtr) NULL)
	    {
	      winInfo->content[i] = (Opaque) elementPtr;
	      initContentElement (elementPtr, winInfo->type);
	      winInfo->contentSize++;
	    }
	  else			/* things must be really hosed now! We ran out of memory!? */
	    return (-1);
	}
    }

  return indexStart;
}				/* addContentElements */


/* Delete all curses windows associated with winInfo, leaving everything
   else intact.  */
void
tuiDelWindow (TuiWinInfoPtr winInfo)
{
  TuiGenWinInfoPtr genericWin;

  switch (winInfo->generic.type)
    {
    case SRC_WIN:
    case DISASSEM_WIN:
      genericWin = locatorWinInfoPtr ();
      if (genericWin != (TuiGenWinInfoPtr) NULL)
	{
	  tuiDelwin (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  genericWin->isVisible = FALSE;
	}
      if (winInfo->detail.sourceInfo.filename)
        {
          xfree (winInfo->detail.sourceInfo.filename);
          winInfo->detail.sourceInfo.filename = 0;
        }
      genericWin = winInfo->detail.sourceInfo.executionInfo;
      if (genericWin != (TuiGenWinInfoPtr) NULL)
	{
	  tuiDelwin (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  genericWin->isVisible = FALSE;
	}
      break;
    case DATA_WIN:
      if (winInfo->generic.content != (OpaquePtr) NULL)
	{
	  tuiDelDataWindows (winInfo->detail.dataDisplayInfo.regsContent,
                             winInfo->detail.dataDisplayInfo.regsContentCount);
	  tuiDelDataWindows (winInfo->detail.dataDisplayInfo.dataContent,
                             winInfo->detail.dataDisplayInfo.dataContentCount);
	}
      break;
    default:
      break;
    }
  if (winInfo->generic.handle != (WINDOW *) NULL)
    {
      tuiDelwin (winInfo->generic.handle);
      winInfo->generic.handle = (WINDOW *) NULL;
      winInfo->generic.isVisible = FALSE;
    }
}


/*
   **  freeWindow().
 */
void
freeWindow (TuiWinInfoPtr winInfo)
{
  TuiGenWinInfoPtr genericWin;

  switch (winInfo->generic.type)
    {
    case SRC_WIN:
    case DISASSEM_WIN:
      genericWin = locatorWinInfoPtr ();
      if (genericWin != (TuiGenWinInfoPtr) NULL)
	{
	  tuiDelwin (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	}
      freeWinContent (genericWin);
      if (winInfo->detail.sourceInfo.filename)
        {
          xfree (winInfo->detail.sourceInfo.filename);
          winInfo->detail.sourceInfo.filename = 0;
        }
      genericWin = winInfo->detail.sourceInfo.executionInfo;
      if (genericWin != (TuiGenWinInfoPtr) NULL)
	{
	  tuiDelwin (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  freeWinContent (genericWin);
	}
      break;
    case DATA_WIN:
      if (winInfo->generic.content != (OpaquePtr) NULL)
	{
	  freeDataContent (
			    winInfo->detail.dataDisplayInfo.regsContent,
			  winInfo->detail.dataDisplayInfo.regsContentCount);
	  winInfo->detail.dataDisplayInfo.regsContent =
	    (TuiWinContent) NULL;
	  winInfo->detail.dataDisplayInfo.regsContentCount = 0;
	  freeDataContent (
			    winInfo->detail.dataDisplayInfo.dataContent,
			  winInfo->detail.dataDisplayInfo.dataContentCount);
	  winInfo->detail.dataDisplayInfo.dataContent =
	    (TuiWinContent) NULL;
	  winInfo->detail.dataDisplayInfo.dataContentCount = 0;
	  winInfo->detail.dataDisplayInfo.regsDisplayType =
	    TUI_UNDEFINED_REGS;
	  winInfo->detail.dataDisplayInfo.regsColumnCount = 1;
	  winInfo->detail.dataDisplayInfo.displayRegs = FALSE;
	  winInfo->generic.content = (OpaquePtr) NULL;
	  winInfo->generic.contentSize = 0;
	}
      break;
    default:
      break;
    }
  if (winInfo->generic.handle != (WINDOW *) NULL)
    {
      tuiDelwin (winInfo->generic.handle);
      winInfo->generic.handle = (WINDOW *) NULL;
      freeWinContent (&winInfo->generic);
    }
  if (winInfo->generic.title)
    xfree (winInfo->generic.title);
  xfree (winInfo);
}


/*
   ** freeAllSourceWinsContent().
 */
void
freeAllSourceWinsContent (void)
{
  int i;

  for (i = 0; i < (sourceWindows ())->count; i++)
    {
      TuiWinInfoPtr winInfo = (TuiWinInfoPtr) (sourceWindows ())->list[i];

      if (m_winPtrNotNull (winInfo))
	{
	  freeWinContent (&(winInfo->generic));
	  freeWinContent (winInfo->detail.sourceInfo.executionInfo);
	}
    }

  return;
}				/* freeAllSourceWinsContent */


/*
   ** freeWinContent().
 */
void
freeWinContent (TuiGenWinInfoPtr winInfo)
{
  if (winInfo->content != (OpaquePtr) NULL)
    {
      freeContent ((TuiWinContent) winInfo->content,
		   winInfo->contentSize,
		   winInfo->type);
      winInfo->content = (OpaquePtr) NULL;
    }
  winInfo->contentSize = 0;

  return;
}				/* freeWinContent */


void
tuiDelDataWindows (TuiWinContent content, int contentSize)
{
  int i;

  /*
     ** Remember that data window content elements are of type TuiGenWinInfoPtr,
     ** each of which whose single element is a data element.
   */
  for (i = 0; i < contentSize; i++)
    {
      TuiGenWinInfoPtr genericWin = &content[i]->whichElement.dataWindow;

      if (genericWin != (TuiGenWinInfoPtr) NULL)
	{
	  tuiDelwin (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  genericWin->isVisible = FALSE;
	}
    }

  return;
}				/* tuiDelDataWindows */


void
freeDataContent (TuiWinContent content, int contentSize)
{
  int i;

  /*
     ** Remember that data window content elements are of type TuiGenWinInfoPtr,
     ** each of which whose single element is a data element.
   */
  for (i = 0; i < contentSize; i++)
    {
      TuiGenWinInfoPtr genericWin = &content[i]->whichElement.dataWindow;

      if (genericWin != (TuiGenWinInfoPtr) NULL)
	{
	  tuiDelwin (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  freeWinContent (genericWin);
	}
    }
  freeContent (content,
	       contentSize,
	       DATA_WIN);

  return;
}				/* freeDataContent */


/**********************************
** LOCAL STATIC FUNCTIONS        **
**********************************/


/*
   ** freeContent().
 */
static void
freeContent (TuiWinContent content, int contentSize, TuiWinType winType)
{
  if (content != (TuiWinContent) NULL)
    {
      freeContentElements (content, contentSize, winType);
      tuiFree ((char *) content);
    }

  return;
}				/* freeContent */


/*
   ** freeContentElements().
 */
static void
freeContentElements (TuiWinContent content, int contentSize, TuiWinType type)
{
  if (content != (TuiWinContent) NULL)
    {
      int i;

      if (type == SRC_WIN || type == DISASSEM_WIN)
	{
	  /* free whole source block */
	  if (content[0]->whichElement.source.line != (char *) NULL)
	    tuiFree (content[0]->whichElement.source.line);
	}
      else
	{
	  for (i = 0; i < contentSize; i++)
	    {
	      TuiWinElementPtr element;

	      element = content[i];
	      if (element != (TuiWinElementPtr) NULL)
		{
		  switch (type)
		    {
		    case DATA_WIN:
		      tuiFree ((char *) element);
		      break;
		    case DATA_ITEM_WIN:
		      /*
		         ** Note that data elements are not allocated
		         ** in a single block, but individually, as needed.
		       */
		      if (element->whichElement.data.type != TUI_REGISTER)
			tuiFree ((char *)
				 element->whichElement.data.name);
		      tuiFree ((char *) element->whichElement.data.value);
		      tuiFree ((char *) element);
		      break;
		    case CMD_WIN:
		      tuiFree ((char *) element->whichElement.command.line);
		      break;
		    default:
		      break;
		    }
		}
	    }
	}
      if (type != DATA_WIN && type != DATA_ITEM_WIN)
	tuiFree ((char *) content[0]);	/* free the element block */
    }

  return;
}				/* freeContentElements */
@


1.12
log
@	* tui-hooks.c: Update include order.
	* tui.c: Likewise.
	* tuiCommand.c: Likewise.
	* tuiData.c: Likewise.
	* tuiDataWin.c: Likewise.
	* tuiDisassem.c: Likewise.
	* tuiGeneralWin.c: Likewise.
	* tuiIO.c: Likewise.
	* tuiLayout.c: Likewise.
	* tuiRegs.c: Likewise.
	* tuiSource.c: Likewise.
	* tuiSourceWin.c: Likewise.
	* tuiStack.c: Likewise.
	* tuiWin.c: Likewise.
@
text
@@


1.12.6.1
log
@merge mainline changes to branch
@
text
@@


1.11
log
@	* tuiData.h (FILE_PREFIX): Don't define.
	(blankStr, locationStr, breakStr): Don't declare.
	(breakLocationStr, nullStr, historyLimit, setHistoryLimitTo): Likewise.
	(displayableWinContentOf, displayableWinContentAt): Likewise.
	(winElementHeight, winByName, freeAllWindows): Likewise.

	* tuiData.c (blankStr, locationStr, breakStr): Remove.
	(breakLocationStr, nullStr, historyLimit, setHistoryLimitTo): Remove.
	(displayableWinContentOf, displayableWinContentAt): Remove.
	(winElementHeight, winByName, freeAllWindows): Remove.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation,
d25 5
a29 7
/* FIXME: cagney/2002-02-28: The GDB coding standard indicates that
   "defs.h" should be included first.  Unfortunatly some systems
   (currently Debian GNU/Linux) include the <stdbool.h> via <curses.h>
   and they clash with "bfd.h"'s definiton of true/false.  The correct
   fix is to remove true/false from "bfd.h", however, until that
   happens, hack around it by including "config.h" and <curses.h>
   first.  */
a30 1
#include "config.h"
a37 6

#include "defs.h"
#include "symtab.h"
#include "tui.h"
#include "tuiData.h"
#include "tuiGeneralWin.h"
@


1.11.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 7
a31 5
#include "defs.h"
#include "symtab.h"
#include "tui.h"
#include "tuiData.h"
#include "tuiGeneralWin.h"
d33 1
d41 6
@


1.11.6.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@@


1.11.4.1
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 7
a31 5
#include "defs.h"
#include "symtab.h"
#include "tui.h"
#include "tuiData.h"
#include "tuiGeneralWin.h"
d33 1
d41 6
@


1.11.4.2
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.10
log
@	* tuiSourceWin.h (tui_update_all_breakpoint_info): Declare.
	(tui_update_breakpoint_info): Declare.
	(tuiSetHasBreakAt, tuiAllSetHasBreakAt): Remove.

	* tuiSourceWin.c (tuiUpdateSourceWindowAsIs): Update breakpoint
	information using tui_update_breakpoint_info.
	(tui_update_all_breakpoint_info): New function to refresh all
	execution windows.
	(tui_update_breakpoint_info): New function to recompute the status
	of exec info window from breakpoints.
	(tuiSetHasBreakAt, tuiAllSetHasBreakAt): Remove.
	(tuiSetExecInfoContent): Use the exec info flags computed by
	tui_update_breakpoint_info to display a short status about breakpoints.

	* tuiData.h (TuiExecInfoContent): New for exec info string.
	(TuiWhichElement): Use it.
	(TUI_BP_ENABLED, TUI_BP_DISABLED, TUI_BP_HIT): New defines.
	(TUI_BP_CONDITIONAL, TUI_BP_HARDWARE): New defines.
	(TUI_BP_HIT_POS, TUI_BP_BREAK_POS, TUI_EXEC_POS): Likewise.
	(TUI_EXECINFO_SIZE): Likewise.
	* tuiData.c (initContentElement): Clear exec info string.

	* tui-hooks.c (get_breakpoint): Remove.
	(tui_event_create_breakpoint): Call tui_update_all_breakpoint_info.
	(tui_event_delete_breakpoint): Likewise.
	(tui_event_modify_breakpoint): Likewise.
@
text
@d43 1
a53 8
** Private Definitions
****************************/
#define FILE_WIDTH   30
#define PROC_WIDTH   40
#define LINE_WIDTH   4
#define PC_WIDTH     8

/***************************
a55 5
static char *_tuiNullStr = TUI_NULL_STR;
static char *_tuiBlankStr = "   ";
static char *_tuiLocationStr = "  >";
static char *_tuiBreakStr = " * ";
static char *_tuiBreakLocationStr = " *>";
a57 1
static int _historyLimit = DEFAULT_HISTORY_COUNT;
a275 55
   ** blankStr()
   **        Accessor for the blank string.
 */
char *
blankStr (void)
{
  return _tuiBlankStr;
}				/* blankStr */


/*
   ** locationStr()
   **        Accessor for the location string.
 */
char *
locationStr (void)
{
  return _tuiLocationStr;
}				/* locationStr */


/*
   ** breakStr()
   **        Accessor for the break string.
 */
char *
breakStr (void)
{
  return _tuiBreakStr;
}				/* breakStr */


/*
   ** breakLocationStr()
   **        Accessor for the breakLocation string.
 */
char *
breakLocationStr (void)
{
  return _tuiBreakLocationStr;
}				/* breakLocationStr */


/*
   ** nullStr()
   **        Accessor for the null string.
 */
char *
nullStr (void)
{
  return _tuiNullStr;
}				/* nullStr */


/*
a309 23
   ** historyLimit().
   **        Accessor for the history limit
 */
int
historyLimit (void)
{
  return _historyLimit;
}				/* historyLimit */


/*
   ** setHistoryLimitTo().
   **        Mutator for the history limit
 */
void
setHistoryLimitTo (int h)
{
  _historyLimit = h;

  return;
}				/* setHistoryLimitTo */

/*
d461 1
a461 183
}				/* tuiPrevWin */


/*
   ** displayableWinContentOf().
   **        Answer a the content at the location indicated by index.  Note
   **        that if this is a locator window, the string returned should be
   **        freed after use.
 */
char *
displayableWinContentOf (TuiGenWinInfoPtr winInfo, TuiWinElementPtr elementPtr)
{

  char *string = nullStr ();

  if (elementPtr != (TuiWinElementPtr) NULL || winInfo->type == LOCATOR_WIN)
    {
      /*
         ** Now convert the line to a displayable string
       */
      switch (winInfo->type)
	{
	case SRC_WIN:
	case DISASSEM_WIN:
	  string = elementPtr->whichElement.source.line;
	  break;
	case CMD_WIN:
	  string = elementPtr->whichElement.command.line;
	  break;
	case LOCATOR_WIN:
	  if ((string = (char *) xmalloc (
		      (termWidth () + 1) * sizeof (char))) == (char *) NULL)
	      string = nullStr ();
	  else
	    {
	      char lineNo[50], pc[50], buf[50], *fname, *pname;
	      register int strSize = termWidth (), i, procWidth, fileWidth;

	      /*
	         ** First determine the amount of file/proc name width
	         ** we have available
	       */
	      i = strSize - (PC_WIDTH + LINE_WIDTH
			     + 25	/* pc and line labels */
			     + strlen (FILE_PREFIX) + 1		/* file label */
			     + 15 /* procedure label */ );
	      if (i >= FILE_WIDTH + PROC_WIDTH)
		{
		  fileWidth = FILE_WIDTH;
		  procWidth = PROC_WIDTH;
		}
	      else
		{
		  fileWidth = i / 2;
		  procWidth = i - fileWidth;
		}

	      /* Now convert elements to string form */
	      if (elementPtr != (TuiWinElementPtr) NULL &&
		  *elementPtr->whichElement.locator.fileName != (char) 0 &&
		  srcWin->generic.isVisible)
		fname = elementPtr->whichElement.locator.fileName;
	      else
		fname = "??";
	      if (elementPtr != (TuiWinElementPtr) NULL &&
		  *elementPtr->whichElement.locator.procName != (char) 0)
		pname = elementPtr->whichElement.locator.procName;
	      else
		pname = "??";
	      if (elementPtr != (TuiWinElementPtr) NULL &&
		  elementPtr->whichElement.locator.lineNo > 0)
		sprintf (lineNo, "%d",
			 elementPtr->whichElement.locator.lineNo);
	      else
		strcpy (lineNo, "??");
	      if (elementPtr != (TuiWinElementPtr) NULL &&
		  elementPtr->whichElement.locator.addr != 0)
		sprintf (pc, "0x%lx",
			 (long) elementPtr->whichElement.locator.addr);
	      else
		strcpy (pc, "??");
	      /*
	         ** Now create the locator line from the string version
	         ** of the elements.  We could use sprintf() here but
	         ** that wouldn't ensure that we don't overrun the size
	         ** of the allocated buffer.  strcat_to_buf() will.
	       */
	      *string = (char) 0;
	      /* Filename */
	      strcat_to_buf (string, strSize, " ");
	      strcat_to_buf (string, strSize, FILE_PREFIX);
	      if (strlen (fname) > fileWidth)
		{
		  strncpy (buf, fname, fileWidth - 1);
		  buf[fileWidth - 1] = '*';
		  buf[fileWidth] = (char) 0;
		}
	      else
		strcpy (buf, fname);
	      strcat_to_buf (string, strSize, buf);
	      /* procedure/class name */
	      sprintf (buf, "%15s", PROC_PREFIX);
	      strcat_to_buf (string, strSize, buf);
	      if (strlen (pname) > procWidth)
		{
		  strncpy (buf, pname, procWidth - 1);
		  buf[procWidth - 1] = '*';
		  buf[procWidth] = (char) 0;
		}
	      else
		strcpy (buf, pname);
	      strcat_to_buf (string, strSize, buf);
	      sprintf (buf, "%10s", LINE_PREFIX);
	      strcat_to_buf (string, strSize, buf);
	      strcat_to_buf (string, strSize, lineNo);
	      sprintf (buf, "%10s", PC_PREFIX);
	      strcat_to_buf (string, strSize, buf);
	      strcat_to_buf (string, strSize, pc);
	      for (i = strlen (string); i < strSize; i++)
		string[i] = ' ';
	      string[strSize] = (char) 0;
	    }
	  break;
	case EXEC_INFO_WIN:
	  string = elementPtr->whichElement.simpleString;
	  break;
	default:
	  break;
	}
    }
  return string;
}				/* displayableWinContentOf */


/*
   **    winContentAt().
   **        Answer a the content at the location indicated by index
 */
char *
displayableWinContentAt (TuiGenWinInfoPtr winInfo, int index)
{
  return (displayableWinContentOf (winInfo, (TuiWinElementPtr) winInfo->content[index]));
}				/* winContentAt */


/*
   ** winElementHeight().
   **        Answer the height of the element in lines
 */
int
winElementHeight (TuiGenWinInfoPtr winInfo, TuiWinElementPtr element)
{
  int h;

  if (winInfo->type == DATA_WIN)
/* FOR NOW SAY IT IS ONLY ONE LINE HIGH */
    h = 1;
  else
    h = 1;

  return h;
}				/* winElementHeight */


/*
   **  winByName().
   **      Answer the window represented by name
 */
TuiWinInfoPtr
winByName (char *name)
{
  TuiWinInfoPtr winInfo = (TuiWinInfoPtr) NULL;
  int i = 0;

  while (i < MAX_MAJOR_WINDOWS && m_winPtrIsNull (winInfo))
    {
      if (strcmp (name, winName (&(winList[i]->generic))) == 0)
	winInfo = winList[i];
      i++;
    }

  return winInfo;
}				/* winByName */
a932 16


/*
   ** freeAllWindows().
 */
void
freeAllWindows (void)
{
  TuiWinType type = SRC_WIN;

  for (; type < MAX_MAJOR_WINDOWS; type++)
    if (m_winPtrNotNull (winList[type]) &&
	winList[type]->generic.type != UNDEFINED_WIN)
      freeWindow (winList[type]);
  return;
}				/* freeAllWindows */
@


1.9
log
@	* tuiSourceWin.c (tuiSetHasBreakAt): Use filename for breakpoint
	comparison; cleanup.
	* tuiSource.c (tuiSetSourceContent): Set window title and filename.
	* tuiGeneralWin.c (boxWin): Print optional title on top of window.
	* tuiData.h (TuiSourceInfo): Add filename member.
	(TuiGenWinInfo): Add title member.
	* tuiData.c (initGenericPart): Clear title.
	(freeWindow): Free title and filename; remove unused locals.
	(initWinInfo): Clear filename.
	(tuiDelWindow): Free it; remove unused locals.
@
text
@d891 2
a892 1
      element->whichElement.simpleString = blankStr ();
@


1.8
log
@Add FIXME explaining include problem.
@
text
@d846 2
a847 3

  return;
}				/* initGenericPart */
d916 1
d1043 2
a1044 5
/*
   **  tuiDelWindow().
   **     Delete all curses windows associated with winInfo, leaving everything
   **     else in tact.
 */
a1047 2
  Opaque detail;
  int i;
a1049 1

d1061 5
d1077 4
a1080 8
	  int i;

	  tuiDelDataWindows (
			      winInfo->detail.dataDisplayInfo.regsContent,
			  winInfo->detail.dataDisplayInfo.regsContentCount);
	  tuiDelDataWindows (
			      winInfo->detail.dataDisplayInfo.dataContent,
			  winInfo->detail.dataDisplayInfo.dataContentCount);
d1092 1
a1092 3

  return;
}				/* tuiDelWindow */
a1100 2
  Opaque detail;
  int i;
a1102 1

d1114 5
d1159 2
d1162 1
a1162 3

  return;
}				/* freeWindow */
@


1.8.8.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d846 3
a848 2
  win->title = 0;
}
a916 1
      winInfo->detail.sourceInfo.filename = 0;
d1043 5
a1047 2
/* Delete all curses windows associated with winInfo, leaving everything
   else intact.  */
d1051 2
d1055 1
a1066 5
      if (winInfo->detail.sourceInfo.filename)
        {
          xfree (winInfo->detail.sourceInfo.filename);
          winInfo->detail.sourceInfo.filename = 0;
        }
d1078 8
a1085 4
	  tuiDelDataWindows (winInfo->detail.dataDisplayInfo.regsContent,
                             winInfo->detail.dataDisplayInfo.regsContentCount);
	  tuiDelDataWindows (winInfo->detail.dataDisplayInfo.dataContent,
                             winInfo->detail.dataDisplayInfo.dataContentCount);
d1097 3
a1099 1
}
d1108 2
d1112 1
a1123 5
      if (winInfo->detail.sourceInfo.filename)
        {
          xfree (winInfo->detail.sourceInfo.filename);
          winInfo->detail.sourceInfo.filename = 0;
        }
a1163 2
  if (winInfo->generic.title)
    xfree (winInfo->generic.title);
d1165 3
a1167 1
}
@


1.8.8.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a42 1
#include "symtab.h"
d53 8
d63 5
d70 1
d289 55
d378 23
d552 183
a734 1
}
d891 1
a891 2
      memset(element->whichElement.simpleString, ' ',
             sizeof(element->whichElement.simpleString));
d1205 16
@


1.7
log
@2002-02-08  Daniel Jacobowitz  <drow@@mvista.com>

        * utils.c: Include <curses.h> before "bfd.h".
        * tui/tui-hooks.c: Likewise.
        * tui/tui.c: Likewise.
        * tui/tuiCommand.c: Likewise.
        * tui/tuiData.c: Likewise.
        * tui/tuiDataWin.c: Likewise.
        * tui/tuiDisassem.c: Likewise.
        * tui/tuiGeneralWin.c: Likewise.
        * tui/tuiIO.c: Likewise.
        * tui/tuiLayout.c: Likewise.
        * tui/tuiRegs.c: Likewise.
        * tui/tuiSource.c: Likewise.
        * tui/tuiSourceWin.c: Likewise.
        * tui/tuiStack.c: Likewise.
        * tui/tuiWin.c: Likewise.
@
text
@d2 4
a5 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d25 8
a32 1
/* If we need <curses.h>, we must include it before we get "bfd.h".  */
@


1.6
log
@	* tuiWin.c (_parseScrollingArgs): Fix uninitialized variable.
	(_makeVisibleWithNewHeight): Use TuiLineOrAddress type.

	* tuiStack.c (tuiShowFrameInfo): Use TuiLineOrAddress type.
	(tui_vUpdateLocatorFilename): Remove.
	* tuiStack.h: Update prototypes.

	* tuiSourceWin.c (tuiAddrIsDisplayed): New function.
	(tuiLineIsDisplayed): Split for address and line.
	(tuiUpdateSourceWindow): Use TuiLineOrAddress type.
	(tuiUpdateSourceWindowAsIs): Likewise.
	(tuiUpdateSourceWindowsWithAddr): Likewise.
	(tuiUpdateSourceWindowsWithLine): Likewise.
	(tuiHorizontalSourceScroll): Likewise.
	(tuiSetIsExecPointAt): Likewise.
	(tuiUpdateOnEnd): Likewise.
	* tuiSourceWin.h: Update prototypes.

	* tuiSource.c (tuiVerticalSourceScroll): Use TuiLineOrAddress type.
	(tuiShowSource): Likewise.
	(tuiVerticalSourceScroll): Likewise.
	* tuiSource.h (tuiShowSource): Update prototype.

	* tuiDisassem.c (tuiSetDisassemContent): Use CORE_ADDR for address.
	(tuiShowDisassem): Use TuiLineOrAddress type.
	(tuiShowDisassemAndUpdateSource): Likewise.
	(tuiVerticalDisassemScroll): Likewise.
	(tuiShowDisassemAsIs): Remove.
	* tuiDisassem.h (tuiSetDisassemContent): Update prototype.

	* tuiData.c (initWinInfo): Use CORE_ADDR for address.
	(clearWinDetail): Likewise.
	(displayableWinContentOf): Fix address conversion.
	(tuiNextWin): Fix crash when the window is not yet created.
	(partialWinByName): Likewise.
@
text
@d22 10
@


1.5
log
@	* tuiWin.c, tui.c, tuiCommand.c: Use ansi prototype.
	tuiIO.c, tuiData.c: Likewise.
	tuiDataWin.c, tuiDisassem.c: Likewise.
	tuiGeneralWin.c, tuiLayout.c: Likewise.
	tuiRegs.c, tuiSource.c: Likewise.
	tuiSouceWin.c, tuiStack.c: Likewise.
@
text
@d25 1
d240 1
a240 1
	  winInfo->detail.sourceInfo.startLineOrAddr.addr = (Opaque) NULL;
d488 1
a488 1
      if (winList[type]->generic.isVisible)
d608 3
a610 3
		  elementPtr->whichElement.locator.addr > (Opaque) 0)
		sprintf (pc, "0x%x",
			 elementPtr->whichElement.locator.addr);
d732 7
a738 4
	  char *curName = winName (&winList[i]->generic);
	  if (strlen (name) <= strlen (curName) &&
	      strncmp (name, curName, strlen (name)) == 0)
	    winInfo = winList[i];
d896 1
a896 1
      winInfo->detail.sourceInfo.startLineOrAddr.addr = (Opaque) NULL;
@


1.4
log
@	* tuiWin.c, tuiWin.h, tui.c, tui.h, tuiCommand.c: Add FSF copyright.
	tuiCommand.h, tuiIO.c, tuiIO.h, tuiData.h, tuiData.c: Likewise.
	tuiDataWin.c, tuiDataWin.h, tuiDisassem.c, tuiDisassem.h: Likewise.
	tuiGeneralWin.c, tuiGeneralWin.h, tuiLayout.c, tuiLayout.h: Likewise.
	tuiRegs.c, tuiRegs.h, tuiSource.c, tuiSource.h: Likewise.
	tuiSouceWin.c, tuiSourceWin.h, tuiStack.c, tuiStack.h: Likewise.
@
text
@a85 1
#ifdef __STDC__
a86 3
#else
tuiWinResized ()
#endif
d97 1
a97 7
#ifdef __STDC__
tuiSetWinResizedTo (
		     int resized)
#else
tuiSetWinResizedTo (resized)
     int resized;
#endif
a109 1
#ifdef __STDC__
a110 3
#else
tuiLayoutDef ()
#endif
a120 1
#ifdef __STDC__
a121 3
#else
tuiWinWithFocus ()
#endif
d132 1
a132 7
#ifdef __STDC__
tuiSetWinWithFocus (
		     TuiWinInfoPtr winInfo)
#else
tuiSetWinWithFocus (winInfo)
     TuiWinInfoPtr winInfo;
#endif
a144 1
#ifdef __STDC__
a145 3
#else
tuiDefaultTabLen ()
#endif
d156 1
a156 7
#ifdef __STDC__
tuiSetDefaultTabLen (
		      int len)
#else
tuiSetDefaultTabLen (len)
     int len;
#endif
a170 1
#ifdef __STDC__
a171 3
#else
sourceWindows ()
#endif
a183 1
#ifdef __STDC__
a184 3
#else
clearSourceWindows ()
#endif
a198 1
#ifdef __STDC__
a199 3
#else
clearSourceWindowsDetail ()
#endif
d217 1
a217 7
#ifdef __STDC__
addToSourceWindows (
		     TuiWinInfoPtr winInfo)
#else
addToSourceWindows (winInfo)
     TuiWinInfoPtr winInfo;
#endif
d231 1
a231 7
#ifdef __STDC__
clearWinDetail (
		 TuiWinInfoPtr winInfo)
#else
clearWinDetail (winInfo)
     TuiWinInfoPtr winInfo;
#endif
a271 1
#ifdef __STDC__
a272 3
#else
blankStr ()
#endif
a282 1
#ifdef __STDC__
a283 3
#else
locationStr ()
#endif
a293 1
#ifdef __STDC__
a294 3
#else
breakStr ()
#endif
a304 1
#ifdef __STDC__
a305 3
#else
breakLocationStr ()
#endif
a315 1
#ifdef __STDC__
a316 3
#else
nullStr ()
#endif
a326 1
#ifdef __STDC__
a327 3
#else
sourceExecInfoWinPtr ()
#endif
a337 1
#ifdef __STDC__
a338 3
#else
disassemExecInfoWinPtr ()
#endif
a349 1
#ifdef __STDC__
a350 3
#else
locatorWinInfoPtr ()
#endif
a360 1
#ifdef __STDC__
a361 3
#else
historyLimit ()
#endif
d372 1
a372 7
#ifdef __STDC__
setHistoryLimitTo (
		    int h)
#else
setHistoryLimitTo (h)
     int h;
#endif
a383 1
#ifdef __STDC__
a384 3
#else
termHeight ()
#endif
d395 1
a395 7
#ifdef __STDC__
setTermHeightTo (
		  int h)
#else
setTermHeightTo (h)
     int h;
#endif
a407 1
#ifdef __STDC__
a408 3
#else
termWidth ()
#endif
d419 1
a419 7
#ifdef __STDC__
setTermWidthTo (
		 int w)
#else
setTermWidthTo (w)
     int w;
#endif
a431 1
#ifdef __STDC__
a432 3
#else
currentLayout ()
#endif
d443 1
a443 7
#ifdef __STDC__
setCurrentLayoutTo (
		     TuiLayoutType newLayout)
#else
setCurrentLayoutTo (newLayout)
     TuiLayoutType newLayout;
#endif
d456 1
a456 11
#ifdef __STDC__
setGenWinOrigin (
		  TuiGenWinInfoPtr winInfo,
		  int x,
		  int y)
#else
setGenWinOrigin (winInfo, x, y)
     TuiGenWinInfoPtr winInfo;
     int x;
     int y;
#endif
d476 1
a476 7
#ifdef __STDC__
tuiNextWin (
	     TuiWinInfoPtr curWin)
#else
tuiNextWin (curWin)
     TuiWinInfoPtr curWin;
#endif
d508 1
a508 7
#ifdef __STDC__
tuiPrevWin (
	     TuiWinInfoPtr curWin)
#else
tuiPrevWin (curWin)
     TuiWinInfoPtr curWin;
#endif
d541 1
a541 9
#ifdef __STDC__
displayableWinContentOf (
			  TuiGenWinInfoPtr winInfo,
			  TuiWinElementPtr elementPtr)
#else
displayableWinContentOf (winInfo, elementPtr)
     TuiGenWinInfoPtr winInfo;
     TuiWinElementPtr elementPtr;
#endif
d670 1
a670 9
#ifdef __STDC__
displayableWinContentAt (
			  TuiGenWinInfoPtr winInfo,
			  int index)
#else
displayableWinContentAt (winInfo, index)
     TuiGenWinInfoPtr winInfo;
     int index;
#endif
d681 1
a681 9
#ifdef __STDC__
winElementHeight (
		   TuiGenWinInfoPtr winInfo,
		   TuiWinElementPtr element)
#else
winElementHeight (winInfo, element)
     TuiGenWinInfoPtr winInfo;
     TuiWinElementPtr element;
#endif
d700 1
a700 7
#ifdef __STDC__
winByName (
	    char *name)
#else
winByName (name)
     char *name;
#endif
d721 1
a721 7
#ifdef __STDC__
partialWinByName (
		   char *name)
#else
partialWinByName (name)
     char *name;
#endif
d748 1
a748 7
#ifdef __STDC__
winName (
	  TuiGenWinInfoPtr winInfo)
#else
winName (winInfo)
     TuiGenWinInfoPtr winInfo;
#endif
a778 1
#ifdef __STDC__
a779 3
#else
initializeStaticData ()
#endif
a792 1
#ifdef __STDC__
a793 3
#else
allocGenericWinInfo ()
#endif
d809 1
a809 7
#ifdef __STDC__
initGenericPart (
		  TuiGenWinInfoPtr win)
#else
initGenericPart (win)
     TuiGenWinInfoPtr win;
#endif
d831 1
a831 9
#ifdef __STDC__
initContentElement (
		     TuiWinElementPtr element,
		     TuiWinType type)
#else
initContentElement (element, type)
     TuiWinElementPtr element;
     TuiWinType type;
#endif
d880 1
a880 7
#ifdef __STDC__
initWinInfo (
	      TuiWinInfoPtr winInfo)
#else
initWinInfo (winInfo)
     TuiWinInfoPtr winInfo;
#endif
d921 1
a921 7
#ifdef __STDC__
allocWinInfo (
	       TuiWinType type)
#else
allocWinInfo (type)
     TuiWinType type;
#endif
d941 1
a941 9
#ifdef __STDC__
allocContent (
	       int numElements,
	       TuiWinType type)
#else
allocContent (numElements, type)
     int numElements;
     TuiWinType type;
#endif
d987 1
a987 9
#ifdef __STDC__
addContentElements (
		     TuiGenWinInfoPtr winInfo,
		     int numElements)
#else
addContentElements (winInfo, numElements)
     TuiGenWinInfoPtr winInfo;
     int numElements;
#endif
d1025 1
a1025 7
#ifdef __STDC__
tuiDelWindow (
	       TuiWinInfoPtr winInfo)
#else
tuiDelWindow (winInfo)
     TuiWinInfoPtr winInfo;
#endif
d1082 1
a1082 7
#ifdef __STDC__
freeWindow (
	     TuiWinInfoPtr winInfo)
#else
freeWindow (winInfo)
     TuiWinInfoPtr winInfo;
#endif
a1149 1
#ifdef __STDC__
a1150 3
#else
freeAllSourceWinsContent ()
#endif
d1173 1
a1173 7
#ifdef __STDC__
freeWinContent (
		 TuiGenWinInfoPtr winInfo)
#else
freeWinContent (winInfo)
     TuiGenWinInfoPtr winInfo;
#endif
a1191 1
#ifdef __STDC__
a1192 3
#else
freeAllWindows ()
#endif
d1205 1
a1205 9
#ifdef __STDC__
tuiDelDataWindows (
		    TuiWinContent content,
		    int contentSize)
#else
tuiDelDataWindows (content, contentSize)
     TuiWinContent content;
     int contentSize;
#endif
d1230 1
a1230 9
#ifdef __STDC__
freeDataContent (
		  TuiWinContent content,
		  int contentSize)
#else
freeDataContent (content, contentSize)
     TuiWinContent content;
     int contentSize;
#endif
d1266 1
a1266 11
#ifdef __STDC__
freeContent (
	      TuiWinContent content,
	      int contentSize,
	      TuiWinType winType)
#else
freeContent (content, contentSize, winType)
     TuiWinContent content;
     int contentSize;
     TuiWinType winType;
#endif
d1282 1
a1282 11
#ifdef __STDC__
freeContentElements (
		      TuiWinContent content,
		      int contentSize,
		      TuiWinType type)
#else
freeContentElements (content, contentSize, type)
     TuiWinContent content;
     int contentSize;
     TuiWinType type;
#endif
@


1.3
log
@Replace free() with xfree().
@
text
@d1 20
a20 5
/*
   ** tuiData.c
   **    This module contains functions for manipulating the data
   **    structures used by the TUI
 */
@


1.2
log
@PARAMS removal.
@
text
@d1381 1
a1381 1
  free (winInfo);
@


1.1
log
@Initial revision
@
text
@d2 4
a5 4
** tuiData.c
**    This module contains functions for manipulating the data
**    structures used by the TUI
*/
d53 2
a54 2
static void freeContent PARAMS ((TuiWinContent, int, TuiWinType));
static void freeContentElements PARAMS ((TuiWinContent, int, TuiWinType));
d67 3
a69 3
** tuiWinResized().
**        Answer a whether the terminal window has been resized or not
*/
d82 3
a84 3
** tuiSetWinResized().
**        Set a whether the terminal window has been resized or not
*/
d101 3
a103 3
** tuiLayoutDef().
**        Answer a pointer to the current layout definition
*/
d116 3
a118 3
** tuiWinWithFocus().
**        Answer the window with the logical focus
*/
d131 3
a133 3
** tuiSetWinWithFocus().
**        Set the window that has the logical focus
*/
d150 3
a152 3
** tuiDefaultTabLen().
**        Answer the length in chars, of tabs
*/
d165 3
a167 3
** tuiSetDefaultTabLen().
**        Set the length in chars, of tabs
*/
d184 5
a188 5
** currentSourceWin()
**        Accessor for the current source window.  Usually there is only
**        one source window (either source or disassembly), but both can
**        be displayed at the same time.
*/
d201 5
a205 5
** clearSourceWindows()
**        Clear the list of source windows.  Usually there is only one
**        source window (either source or disassembly), but both can be
**        displayed at the same time.
*/
d222 3
a224 3
** clearSourceWindowsDetail()
**        Clear the pertinant detail in the source windows.
*/
d242 5
a246 5
** addSourceWindowToList().
**       Add a window to the list of source windows.  Usually there is
**       only one source window (either source or disassembly), but
**       both can be displayed at the same time.
*/
d264 3
a266 3
** clearWinDetail()
**        Clear the pertinant detail in the windows.
*/
d311 3
a313 3
** blankStr()
**        Accessor for the blank string.
*/
d326 3
a328 3
** locationStr()
**        Accessor for the location string.
*/
d341 3
a343 3
** breakStr()
**        Accessor for the break string.
*/
d356 3
a358 3
** breakLocationStr()
**        Accessor for the breakLocation string.
*/
d371 3
a373 3
** nullStr()
**        Accessor for the null string.
*/
d386 3
a388 3
** sourceExecInfoPtr().
**        Accessor for the source execution info ptr.
*/
d401 3
a403 3
** disassemExecInfoPtr().
**        Accessor for the disassem execution info ptr.
*/
d416 4
a419 4
** locatorWinInfoPtr().
**        Accessor for the locator win info.  Answers a pointer to the
**        static locator win info struct.
*/
d432 3
a434 3
** historyLimit().
**        Accessor for the history limit
*/
d447 3
a449 3
** setHistoryLimitTo().
**        Mutator for the history limit
*/
d465 3
a467 3
** termHeight().
**        Accessor for the termHeight
*/
d480 3
a482 3
** setTermHeightTo().
**        Mutator for the term height
*/
d499 3
a501 3
** termWidth().
**        Accessor for the termWidth
*/
d514 3
a516 3
** setTermWidth().
**        Mutator for the termWidth
*/
d533 3
a535 3
** currentLayout().
**        Accessor for the current layout
*/
d548 3
a550 3
** setCurrentLayoutTo().
**        Mutator for the current layout
*/
d567 3
a569 3
** setGenWinOrigin().
**        Set the origin of the window
*/
d596 4
a599 4
** tuiNextWin().
**        Answer the next window in the list, cycling back to the top
**        if necessary
*/
d634 4
a637 4
** tuiPrevWin().
**        Answer the prev window in the list, cycling back to the bottom
**        if necessary
*/
d672 5
a676 5
** displayableWinContentOf().
**        Answer a the content at the location indicated by index.  Note
**        that if this is a locator window, the string returned should be
**        freed after use.
*/
d694 2
a695 2
        ** Now convert the line to a displayable string
        */
d715 3
a717 3
                    ** First determine the amount of file/proc name width
                    ** we have available
                    */
d720 1
a720 1
			     + strlen (FILE_PREFIX) + 1	/* file label */
d758 5
a762 5
                    ** Now create the locator line from the string version
                    ** of the elements.  We could use sprintf() here but
                    ** that wouldn't ensure that we don't overrun the size
                    ** of the allocated buffer.  strcat_to_buf() will.
                    */
d811 3
a813 3
**    winContentAt().
**        Answer a the content at the location indicated by index
*/
d830 3
a832 3
** winElementHeight().
**        Answer the height of the element in lines
*/
d857 3
a859 3
**  winByName().
**      Answer the window represented by name
*/
d884 3
a886 3
**  partialWinByName().
**      Answer the window represented by name
*/
d917 3
a919 3
** winName().
**      Answer the name of the window
*/
d955 2
a956 2
** initializeStaticData
*/
d973 2
a974 2
** allocGenericWinInfo().
*/
d993 2
a994 2
** initGenericPart().
*/
d1021 2
a1022 2
** initContentElement().
*/
d1078 2
a1079 2
** initWinInfo().
*/
d1125 2
a1126 2
** allocWinInfo().
*/
d1150 3
a1152 3
** allocContent().
**        Allocates the content and elements in a block.
*/
d1171 4
a1174 4
        ** All windows, except the data window, can allocate the elements
        ** in a chunk.  The data window cannot because items can be
        ** added/removed from the data display by the user at any time.
        */
d1200 7
a1206 7
** addContentElements().
**        Adds the input number of elements to the windows's content.  If
**        no content has been allocated yet, allocContent() is called to
**        do this.  The index of the first element added is returned,
**        unless there is a memory allocation error, in which case, (-1)
**        is returned.
*/
d1239 1
a1239 1
	  else			/* things must be really hosed now! We ran out of memory!?*/
d1249 4
a1252 4
**  tuiDelWindow().
**     Delete all curses windows associated with winInfo, leaving everything
**     else in tact.
*/
d1314 2
a1315 2
**  freeWindow().
*/
d1388 2
a1389 2
** freeAllSourceWinsContent().
*/
d1415 2
a1416 2
** freeWinContent().
*/
d1440 2
a1441 2
** freeAllWindows().
*/
d1473 3
a1475 3
    ** Remember that data window content elements are of type TuiGenWinInfoPtr,
    ** each of which whose single element is a data element.
    */
d1506 3
a1508 3
    ** Remember that data window content elements are of type TuiGenWinInfoPtr,
    ** each of which whose single element is a data element.
    */
d1534 2
a1535 2
** freeContent().
*/
d1560 2
a1561 2
** freeContentElements().
*/
d1601 3
a1603 3
                            ** Note that data elements are not allocated
                            ** in a single block, but individually, as needed.
                            */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d2 4
a5 4
   ** tuiData.c
   **    This module contains functions for manipulating the data
   **    structures used by the TUI
 */
d67 3
a69 3
   ** tuiWinResized().
   **        Answer a whether the terminal window has been resized or not
 */
d82 3
a84 3
   ** tuiSetWinResized().
   **        Set a whether the terminal window has been resized or not
 */
d101 3
a103 3
   ** tuiLayoutDef().
   **        Answer a pointer to the current layout definition
 */
d116 3
a118 3
   ** tuiWinWithFocus().
   **        Answer the window with the logical focus
 */
d131 3
a133 3
   ** tuiSetWinWithFocus().
   **        Set the window that has the logical focus
 */
d150 3
a152 3
   ** tuiDefaultTabLen().
   **        Answer the length in chars, of tabs
 */
d165 3
a167 3
   ** tuiSetDefaultTabLen().
   **        Set the length in chars, of tabs
 */
d184 5
a188 5
   ** currentSourceWin()
   **        Accessor for the current source window.  Usually there is only
   **        one source window (either source or disassembly), but both can
   **        be displayed at the same time.
 */
d201 5
a205 5
   ** clearSourceWindows()
   **        Clear the list of source windows.  Usually there is only one
   **        source window (either source or disassembly), but both can be
   **        displayed at the same time.
 */
d222 3
a224 3
   ** clearSourceWindowsDetail()
   **        Clear the pertinant detail in the source windows.
 */
d242 5
a246 5
   ** addSourceWindowToList().
   **       Add a window to the list of source windows.  Usually there is
   **       only one source window (either source or disassembly), but
   **       both can be displayed at the same time.
 */
d264 3
a266 3
   ** clearWinDetail()
   **        Clear the pertinant detail in the windows.
 */
d311 3
a313 3
   ** blankStr()
   **        Accessor for the blank string.
 */
d326 3
a328 3
   ** locationStr()
   **        Accessor for the location string.
 */
d341 3
a343 3
   ** breakStr()
   **        Accessor for the break string.
 */
d356 3
a358 3
   ** breakLocationStr()
   **        Accessor for the breakLocation string.
 */
d371 3
a373 3
   ** nullStr()
   **        Accessor for the null string.
 */
d386 3
a388 3
   ** sourceExecInfoPtr().
   **        Accessor for the source execution info ptr.
 */
d401 3
a403 3
   ** disassemExecInfoPtr().
   **        Accessor for the disassem execution info ptr.
 */
d416 4
a419 4
   ** locatorWinInfoPtr().
   **        Accessor for the locator win info.  Answers a pointer to the
   **        static locator win info struct.
 */
d432 3
a434 3
   ** historyLimit().
   **        Accessor for the history limit
 */
d447 3
a449 3
   ** setHistoryLimitTo().
   **        Mutator for the history limit
 */
d465 3
a467 3
   ** termHeight().
   **        Accessor for the termHeight
 */
d480 3
a482 3
   ** setTermHeightTo().
   **        Mutator for the term height
 */
d499 3
a501 3
   ** termWidth().
   **        Accessor for the termWidth
 */
d514 3
a516 3
   ** setTermWidth().
   **        Mutator for the termWidth
 */
d533 3
a535 3
   ** currentLayout().
   **        Accessor for the current layout
 */
d548 3
a550 3
   ** setCurrentLayoutTo().
   **        Mutator for the current layout
 */
d567 3
a569 3
   ** setGenWinOrigin().
   **        Set the origin of the window
 */
d596 4
a599 4
   ** tuiNextWin().
   **        Answer the next window in the list, cycling back to the top
   **        if necessary
 */
d634 4
a637 4
   ** tuiPrevWin().
   **        Answer the prev window in the list, cycling back to the bottom
   **        if necessary
 */
d672 5
a676 5
   ** displayableWinContentOf().
   **        Answer a the content at the location indicated by index.  Note
   **        that if this is a locator window, the string returned should be
   **        freed after use.
 */
d694 2
a695 2
         ** Now convert the line to a displayable string
       */
d715 3
a717 3
	         ** First determine the amount of file/proc name width
	         ** we have available
	       */
d720 1
a720 1
			     + strlen (FILE_PREFIX) + 1		/* file label */
d758 5
a762 5
	         ** Now create the locator line from the string version
	         ** of the elements.  We could use sprintf() here but
	         ** that wouldn't ensure that we don't overrun the size
	         ** of the allocated buffer.  strcat_to_buf() will.
	       */
d811 3
a813 3
   **    winContentAt().
   **        Answer a the content at the location indicated by index
 */
d830 3
a832 3
   ** winElementHeight().
   **        Answer the height of the element in lines
 */
d857 3
a859 3
   **  winByName().
   **      Answer the window represented by name
 */
d884 3
a886 3
   **  partialWinByName().
   **      Answer the window represented by name
 */
d917 3
a919 3
   ** winName().
   **      Answer the name of the window
 */
d955 2
a956 2
   ** initializeStaticData
 */
d973 2
a974 2
   ** allocGenericWinInfo().
 */
d993 2
a994 2
   ** initGenericPart().
 */
d1021 2
a1022 2
   ** initContentElement().
 */
d1078 2
a1079 2
   ** initWinInfo().
 */
d1125 2
a1126 2
   ** allocWinInfo().
 */
d1150 3
a1152 3
   ** allocContent().
   **        Allocates the content and elements in a block.
 */
d1171 4
a1174 4
				   ** All windows, except the data window, can allocate the elements
				   ** in a chunk.  The data window cannot because items can be
				   ** added/removed from the data display by the user at any time.
				 */
d1200 7
a1206 7
   ** addContentElements().
   **        Adds the input number of elements to the windows's content.  If
   **        no content has been allocated yet, allocContent() is called to
   **        do this.  The index of the first element added is returned,
   **        unless there is a memory allocation error, in which case, (-1)
   **        is returned.
 */
d1239 1
a1239 1
	  else			/* things must be really hosed now! We ran out of memory!? */
d1249 4
a1252 4
   **  tuiDelWindow().
   **     Delete all curses windows associated with winInfo, leaving everything
   **     else in tact.
 */
d1314 2
a1315 2
   **  freeWindow().
 */
d1388 2
a1389 2
   ** freeAllSourceWinsContent().
 */
d1415 2
a1416 2
   ** freeWinContent().
 */
d1440 2
a1441 2
   ** freeAllWindows().
 */
d1473 3
a1475 3
     ** Remember that data window content elements are of type TuiGenWinInfoPtr,
     ** each of which whose single element is a data element.
   */
d1506 3
a1508 3
     ** Remember that data window content elements are of type TuiGenWinInfoPtr,
     ** each of which whose single element is a data element.
   */
d1534 2
a1535 2
   ** freeContent().
 */
d1560 2
a1561 2
   ** freeContentElements().
 */
d1601 3
a1603 3
		         ** Note that data elements are not allocated
		         ** in a single block, but individually, as needed.
		       */
@

