head	1.23;
access;
symbols
	drow-cplus-merge-20040113:1.22
	drow-cplus-merge-20031224:1.22
	drow-cplus-merge-20031220:1.22
	carlton_dictionary-20031215-merge:1.22
	drow-cplus-merge-20031214:1.22
	carlton-dictionary-20031111-merge:1.22
	gdb_6_0-2003-10-04-release:1.22
	kettenis_sparc-20030918-branch:1.22.0.8
	kettenis_sparc-20030918-branchpoint:1.22
	carlton_dictionary-20030917-merge:1.22
	ezannoni_pie-20030916-branchpoint:1.22
	ezannoni_pie-20030916-branch:1.22.0.6
	cagney_x86i386-20030821-branch:1.22.0.4
	cagney_x86i386-20030821-branchpoint:1.22
	carlton_dictionary-20030805-merge:1.22
	carlton_dictionary-20030627-merge:1.22
	gdb_6_0-branch:1.22.0.2
	gdb_6_0-2003-06-23-branchpoint:1.22
	jimb-ppc64-linux-20030613-branch:1.21.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.21
	cagney_convert-20030606-branch:1.20.0.10
	cagney_convert-20030606-branchpoint:1.20
	cagney_writestrings-20030508-branch:1.20.0.8
	cagney_writestrings-20030508-branchpoint:1.20
	jimb-ppc64-linux-20030528-branch:1.20.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.20
	carlton_dictionary-20030523-merge:1.20
	cagney_fileio-20030521-branch:1.20.0.4
	cagney_fileio-20030521-branchpoint:1.20
	kettenis_i386newframe-20030517-mergepoint:1.20
	jimb-ppc64-linux-20030509-branch:1.20.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.20
	kettenis_i386newframe-20030504-mergepoint:1.20
	carlton_dictionary-20030430-merge:1.19
	kettenis_i386newframe-20030419-branch:1.18.0.20
	kettenis_i386newframe-20030419-branchpoint:1.18
	carlton_dictionary-20030416-merge:1.18
	cagney_frameaddr-20030409-mergepoint:1.18
	kettenis_i386newframe-20030406-branch:1.18.0.18
	kettenis_i386newframe-20030406-branchpoint:1.18
	cagney_frameaddr-20030403-branchpoint:1.18
	cagney_frameaddr-20030403-branch:1.18.0.16
	cagney_framebase-20030330-mergepoint:1.18
	cagney_framebase-20030326-branch:1.18.0.14
	cagney_framebase-20030326-branchpoint:1.18
	cagney_lazyid-20030317-branch:1.18.0.12
	cagney_lazyid-20030317-branchpoint:1.18
	kettenis-i386newframe-20030316-mergepoint:1.18
	offbyone-20030313-branch:1.18.0.10
	offbyone-20030313-branchpoint:1.18
	kettenis-i386newframe-20030308-branch:1.18.0.8
	kettenis-i386newframe-20030308-branchpoint:1.18
	carlton_dictionary-20030305-merge:1.18
	cagney_offbyone-20030303-branch:1.18.0.6
	cagney_offbyone-20030303-branchpoint:1.18
	carlton_dictionary-20030207-merge:1.18
	interps-20030203-mergepoint:1.18
	interps-20030202-branch:1.18.0.4
	interps-20030202-branchpoint:1.18
	cagney-unwind-20030108-branch:1.18.0.2
	cagney-unwind-20030108-branchpoint:1.18
	carlton_dictionary-20021223-merge:1.18
	gdb_5_3-2002-12-12-release:1.16
	carlton_dictionary-20021115-merge:1.17
	kseitz_interps-20021105-merge:1.17
	kseitz_interps-20021103-merge:1.17
	drow-cplus-merge-20021020:1.17
	drow-cplus-merge-20021025:1.17
	carlton_dictionary-20021025-merge:1.17
	carlton_dictionary-20021011-merge:1.17
	drow-cplus-branch:1.17.0.2
	drow-cplus-branchpoint:1.17
	kseitz_interps-20020930-merge:1.17
	carlton_dictionary-20020927-merge:1.16
	carlton_dictionary-branch:1.16.0.4
	carlton_dictionary-20020920-branchpoint:1.16
	gdb_5_3-branch:1.16.0.2
	gdb_5_3-2002-09-04-branchpoint:1.16
	kseitz_interps-20020829-merge:1.16
	cagney_sysregs-20020825-branch:1.13.0.2
	cagney_sysregs-20020825-branchpoint:1.13
	readline_4_3-import-branch:1.12.0.10
	readline_4_3-import-branchpoint:1.12
	gdb_5_2_1-2002-07-23-release:1.12
	kseitz_interps-20020528-branch:1.12.0.8
	kseitz_interps-20020528-branchpoint:1.12
	cagney_regbuf-20020515-branch:1.12.0.6
	cagney_regbuf-20020515-branchpoint:1.12
	jimb-macro-020506-branch:1.12.0.4
	jimb-macro-020506-branchpoint:1.12
	gdb_5_2-2002-04-29-release:1.12
	gdb_5_2-branch:1.12.0.2
	gdb_5_2-2002-03-03-branchpoint:1.12
	gdb_5_1_1-2002-01-24-release:1.8.2.1
	gdb_5_1_0_1-2002-01-03-release:1.8.2.1
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.8.2.1.0.4
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8.2.1
	gdb_5_1-2001-11-21-release:1.8.2.1
	gdb_s390-2001-09-26-branch:1.8.2.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.8.2.1
	gdb_5_1-2001-07-29-branch:1.8.0.2
	gdb_5_1-2001-07-29-branchpoint:1.8
	dberlin-typesystem-branch:1.2.0.4
	dberlin-typesystem-branchpoint:1.2
	gdb-post-ptid_t-2001-05-03:1.2
	gdb-pre-ptid_t-2001-05-03:1.2
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.23
date	2004.01.19.04.31.51;	author cagney;	state dead;
branches;
next	1.22;

1.22
date	2003.06.22.15.21.38;	author drow;	state Exp;
branches
	1.22.6.1;
next	1.21;

1.21
date	2003.06.12.15.44.24;	author schwab;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.03.19.13.04;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.30.22.01.38;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.29.19.15.16;	author cagney;	state Exp;
branches
	1.18.20.1;
next	1.17;

1.17
date	2002.09.30.00.52.27;	author ezannoni;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2002.08.28.20.33.27;	author ciceron;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	2002.08.27.21.59.49;	author ciceron;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.25.19.54.56;	author ciceron;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.25.19.39.45;	author ciceron;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.01.06.19.28;	author cagney;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	2002.02.08.15.54.32;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.21.17.19.38;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.02.11.58.29;	author eliz;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.20.23.06.48;	author ciceron;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.07.19.21.56.39;	author ciceron;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.18.20.59.00;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.16.22.10.07;	author ciceron;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.14.19.31.09;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.14.19.01.25;	author ciceron;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.42;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.12;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.12;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.19.16;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.11.09.01.23.10;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.02.02.00.21.19;	author jsm;	state Exp;
branches;
next	;

1.8.2.1
date	2001.08.02.12.05.59;	author eliz;	state Exp;
branches;
next	;

1.12.8.1
date	2002.08.30.22.52.52;	author kseitz;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2002.10.01.00.46.35;	author kseitz;	state Exp;
branches;
next	;

1.16.4.1
date	2002.10.11.22.23.03;	author carlton;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2002.12.23.19.39.21;	author carlton;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2003.05.01.00.46.56;	author carlton;	state Exp;
branches;
next	1.16.4.4;

1.16.4.4
date	2003.05.23.18.40.53;	author carlton;	state Exp;
branches;
next	1.16.4.5;

1.16.4.5
date	2003.06.27.21.50.21;	author carlton;	state Exp;
branches;
next	1.16.4.6;

1.16.4.6
date	2004.01.26.19.11.45;	author carlton;	state dead;
branches;
next	;

1.17.2.1
date	2003.12.14.20.27.59;	author drow;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2004.02.09.19.43.58;	author drow;	state dead;
branches;
next	;

1.18.20.1
date	2003.05.04.11.37.48;	author kettenis;	state Exp;
branches;
next	;

1.22.6.1
date	2004.03.23.20.09.16;	author ezannoni;	state dead;
branches;
next	;


desc
@@


1.23
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@/* Disassembly display.

   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "symtab.h"
#include "breakpoint.h"
#include "frame.h"
#include "value.h"
#include "source.h"
#include "disasm.h"

#include "tui.h"
#include "tuiData.h"
#include "tuiWin.h"
#include "tuiLayout.h"
#include "tuiSourceWin.h"
#include "tuiStack.h"
#include "tui-file.h"

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

struct tui_asm_line 
{
  CORE_ADDR addr;
  char* addr_string;
  char* insn;
};

/* Function to set the disassembly window's content.
   Disassemble count lines starting at pc.
   Return address of the count'th instruction after pc.  */
static CORE_ADDR
tui_disassemble (struct tui_asm_line* lines, CORE_ADDR pc, int count)
{
  struct ui_file *gdb_dis_out;

  /* now init the ui_file structure */
  gdb_dis_out = tui_sfileopen (256);

  /* Now construct each line */
  for (; count > 0; count--, lines++)
    {
      if (lines->addr_string)
        xfree (lines->addr_string);
      if (lines->insn)
        xfree (lines->insn);
      
      print_address (pc, gdb_dis_out);
      lines->addr = pc;
      lines->addr_string = xstrdup (tui_file_get_strbuf (gdb_dis_out));

      ui_file_rewind (gdb_dis_out);

      pc = pc + gdb_print_insn (pc, gdb_dis_out);

      lines->insn = xstrdup (tui_file_get_strbuf (gdb_dis_out));

      /* reset the buffer to empty */
      ui_file_rewind (gdb_dis_out);
    }
  ui_file_delete (gdb_dis_out);
  return pc;
}

/* Find the disassembly address that corresponds to FROM lines
   above or below the PC.  Variable sized instructions are taken
   into account by the algorithm.  */
static CORE_ADDR
tui_find_disassembly_address (CORE_ADDR pc, int from)
{
  register CORE_ADDR newLow;
  int maxLines;
  int i;
  struct tui_asm_line* lines;

  maxLines = (from > 0) ? from : - from;
  if (maxLines <= 1)
     return pc;

  lines = (struct tui_asm_line*) alloca (sizeof (struct tui_asm_line)
                                         * maxLines);
  memset (lines, 0, sizeof (struct tui_asm_line) * maxLines);

  newLow = pc;
  if (from > 0)
    {
      tui_disassemble (lines, pc, maxLines);
      newLow = lines[maxLines - 1].addr;
    }
  else
    {
      CORE_ADDR last_addr;
      int pos;
      struct minimal_symbol* msymbol;
              
      /* Find backward an address which is a symbol
         and for which disassembling from that address will fill
         completely the window.  */
      pos = maxLines - 1;
      do {
         newLow -= 1 * maxLines;
         msymbol = lookup_minimal_symbol_by_pc_section (newLow, 0);

         if (msymbol)
            newLow = SYMBOL_VALUE_ADDRESS (msymbol);
         else
            newLow += 1 * maxLines;

         tui_disassemble (lines, newLow, maxLines);
         last_addr = lines[pos].addr;
      } while (last_addr > pc && msymbol);

      /* Scan forward disassembling one instruction at a time
         until the last visible instruction of the window
         matches the pc.  We keep the disassembled instructions
         in the 'lines' window and shift it downward (increasing
         its addresses).  */
      if (last_addr < pc)
        do
          {
            CORE_ADDR next_addr;
                 
            pos++;
            if (pos >= maxLines)
              pos = 0;

            next_addr = tui_disassemble (&lines[pos], last_addr, 1);

            /* If there are some problems while disassembling exit.  */
            if (next_addr <= last_addr)
              break;
            last_addr = next_addr;
          } while (last_addr <= pc);
      pos++;
      if (pos >= maxLines)
         pos = 0;
      newLow = lines[pos].addr;
    }
  for (i = 0; i < maxLines; i++)
    {
      xfree (lines[i].addr_string);
      xfree (lines[i].insn);
    }
  return newLow;
}

/* Function to set the disassembly window's content.  */
TuiStatus
tuiSetDisassemContent (CORE_ADDR pc)
{
  TuiStatus ret = TUI_FAILURE;
  register int i;
  register int offset = disassemWin->detail.sourceInfo.horizontalOffset;
  register int lineWidth, maxLines;
  CORE_ADDR cur_pc;
  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
  int tab_len = tuiDefaultTabLen ();
  struct tui_asm_line* lines;
  int insn_pos;
  int addr_size, max_size;
  char* line;
  
  if (pc == 0)
    return TUI_FAILURE;

  ret = tuiAllocSourceBuffer (disassemWin);
  if (ret != TUI_SUCCESS)
    return ret;

  disassemWin->detail.sourceInfo.startLineOrAddr.addr = pc;
  cur_pc = (CORE_ADDR)
    (((TuiWinElementPtr) locator->content[0])->whichElement.locator.addr);

  maxLines = disassemWin->generic.height - 2;	/* account for hilite */

  /* Get temporary table that will hold all strings (addr & insn).  */
  lines = (struct tui_asm_line*) alloca (sizeof (struct tui_asm_line)
                                         * maxLines);
  memset (lines, 0, sizeof (struct tui_asm_line) * maxLines);

  lineWidth = disassemWin->generic.width - 1;

  tui_disassemble (lines, pc, maxLines);

  /* See what is the maximum length of an address and of a line.  */
  addr_size = 0;
  max_size = 0;
  for (i = 0; i < maxLines; i++)
    {
      size_t len = strlen (lines[i].addr_string);
      if (len > addr_size)
        addr_size = len;

      len = strlen (lines[i].insn) + tab_len;
      if (len > max_size)
        max_size = len;
    }
  max_size += addr_size + tab_len;

  /* Allocate memory to create each line.  */
  line = (char*) alloca (max_size);
  insn_pos = (1 + (addr_size / tab_len)) * tab_len;

  /* Now construct each line */
  for (i = 0; i < maxLines; i++)
    {
      TuiWinElementPtr element;
      TuiSourceElement* src;
      int curLen;

      element = (TuiWinElementPtr) disassemWin->generic.content[i];
      src = &element->whichElement.source;
      strcpy (line, lines[i].addr_string);
      curLen = strlen (line);

      /* Add spaces to make the instructions start on the same column */
      while (curLen < insn_pos)
        {
          strcat (line, " ");
          curLen++;
        }

      strcat (line, lines[i].insn);

      /* Now copy the line taking the offset into account */
      if (strlen (line) > offset)
        strcpy (src->line, &line[offset]);
      else
        src->line[0] = '\0';

      src->lineOrAddr.addr = lines[i].addr;
      src->isExecPoint = lines[i].addr == cur_pc;

      /* See whether there is a breakpoint installed.  */
      src->hasBreak = (!src->isExecPoint
                       && breakpoint_here_p (pc) != no_breakpoint_here);

      xfree (lines[i].addr_string);
      xfree (lines[i].insn);
    }
  disassemWin->generic.contentSize = i;
  return TUI_SUCCESS;
}


/*
   ** tuiShowDisassem().
   **        Function to display the disassembly window with disassembled code.
 */
void
tuiShowDisassem (CORE_ADDR startAddr)
{
  struct symtab *s = find_pc_symtab (startAddr);
  TuiWinInfoPtr winWithFocus = tuiWinWithFocus ();
  TuiLineOrAddress val;

  val.addr = startAddr;
  tuiAddWinToLayout (DISASSEM_WIN);
  tuiUpdateSourceWindow (disassemWin, s, val, FALSE);
  /*
     ** if the focus was in the src win, put it in the asm win, if the
     ** source view isn't split
   */
  if (currentLayout () != SRC_DISASSEM_COMMAND && winWithFocus == srcWin)
    tuiSetWinFocusTo (disassemWin);

  return;
}				/* tuiShowDisassem */


/*
   ** tuiShowDisassemAndUpdateSource().
   **        Function to display the disassembly window.
 */
void
tuiShowDisassemAndUpdateSource (CORE_ADDR startAddr)
{
  struct symtab_and_line sal;

  tuiShowDisassem (startAddr);
  if (currentLayout () == SRC_DISASSEM_COMMAND)
    {
      TuiLineOrAddress val;

      /*
         ** Update what is in the source window if it is displayed too,
         ** note that it follows what is in the disassembly window and visa-versa
       */
      sal = find_pc_line (startAddr, 0);
      val.lineNo = sal.line;
      tuiUpdateSourceWindow (srcWin, sal.symtab, val, TRUE);
      if (sal.symtab)
	{
	  set_current_source_symtab_and_line (&sal);
	  tuiUpdateLocatorFilename (sal.symtab->filename);
	}
      else
	tuiUpdateLocatorFilename ("?");
    }

  return;
}				/* tuiShowDisassemAndUpdateSource */

/*
   ** tuiGetBeginAsmAddress().
 */
CORE_ADDR
tuiGetBeginAsmAddress (void)
{
  TuiGenWinInfoPtr locator;
  TuiLocatorElementPtr element;
  CORE_ADDR addr;

  locator = locatorWinInfoPtr ();
  element = &((TuiWinElementPtr) locator->content[0])->whichElement.locator;

  if (element->addr == 0)
    {
      struct minimal_symbol *main_symbol;

      /* Find address of the start of program.
         Note: this should be language specific.  */
      main_symbol = lookup_minimal_symbol ("main", NULL, NULL);
      if (main_symbol == 0)
        main_symbol = lookup_minimal_symbol ("MAIN", NULL, NULL);
      if (main_symbol == 0)
        main_symbol = lookup_minimal_symbol ("_start", NULL, NULL);
      if (main_symbol)
        addr = SYMBOL_VALUE_ADDRESS (main_symbol);
      else
        addr = 0;
    }
  else				/* the target is executing */
    addr = element->addr;

  return addr;
}				/* tuiGetBeginAsmAddress */

/* Determine what the low address will be to display in the TUI's
   disassembly window.  This may or may not be the same as the
   low address input.  */
CORE_ADDR
tuiGetLowDisassemblyAddress (CORE_ADDR low, CORE_ADDR pc)
{
  int pos;

  /* Determine where to start the disassembly so that the pc is about in the
     middle of the viewport.  */
  pos = tuiDefaultWinViewportHeight (DISASSEM_WIN, DISASSEM_COMMAND) / 2;
  pc = tui_find_disassembly_address (pc, -pos);

  if (pc < low)
    pc = low;
  return pc;
}

/*
   ** tuiVerticalDisassemScroll().
   **      Scroll the disassembly forward or backward vertically
 */
void
tuiVerticalDisassemScroll (TuiScrollDirection scrollDirection,
                           int numToScroll)
{
  if (disassemWin->generic.content != (OpaquePtr) NULL)
    {
      CORE_ADDR pc;
      TuiWinContent content;
      struct symtab *s;
      TuiLineOrAddress val;
      int maxLines, dir;
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();

      content = (TuiWinContent) disassemWin->generic.content;
      if (cursal.symtab == (struct symtab *) NULL)
	s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
      else
	s = cursal.symtab;

      /* account for hilite */
      maxLines = disassemWin->generic.height - 2;
      pc = content[0]->whichElement.source.lineOrAddr.addr;
      dir = (scrollDirection == FORWARD_SCROLL) ? maxLines : - maxLines;

      val.addr = tui_find_disassembly_address (pc, dir);
      tuiUpdateSourceWindowAsIs (disassemWin, s, val, FALSE);
    }
}
@


1.22
log
@	* tui-hooks.c: Update include order.
	* tui.c: Likewise.
	* tuiCommand.c: Likewise.
	* tuiData.c: Likewise.
	* tuiDataWin.c: Likewise.
	* tuiDisassem.c: Likewise.
	* tuiGeneralWin.c: Likewise.
	* tuiIO.c: Likewise.
	* tuiLayout.c: Likewise.
	* tuiRegs.c: Likewise.
	* tuiSource.c: Likewise.
	* tuiSourceWin.c: Likewise.
	* tuiStack.c: Likewise.
	* tuiWin.c: Likewise.
@
text
@@


1.22.6.1
log
@merge mainline changes to branch
@
text
@@


1.21
log
@	* Makefile.in (tuiDisassem.o): Update dependencies.

tui:
	* tuiSource.c (tuiVerticalSourceScroll): Use get_frame_pc.
	* tuiSourceWin.c (tuiHorizontalSourceScroll): Likewise.
	* tuiStack.c (tui_get_function_from_frame): Likewise.
	(tuiShowFrameInfo): Likewise.
	* tuiWin.c (_makeVisibleWithNewHeight): Likewise.
	* tui-hooks.c (tui_selected_frame_level_changed_hook): Likewise.
	* tuiDisassem.c (tuiVerticalDisassemScroll): Likewise.
	Include "disasm.h".
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation,
a24 17
/* FIXME: cagney/2002-02-28: The GDB coding standard indicates that
   "defs.h" should be included first.  Unfortunatly some systems
   (currently Debian GNU/Linux) include the <stdbool.h> via <curses.h>
   and they clash with "bfd.h"'s definiton of true/false.  The correct
   fix is to remove true/false from "bfd.h", however, until that
   happens, hack around it by including "config.h" and <curses.h>
   first.  */

#include "config.h"
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

d40 8
@


1.20
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* disasm.h (print_insn): Declare.
	* disasm.c (init_gdb_disassemble_info): New function.
	(gdb_disassembly): Call init_gdb_disassemble_info.
	(gdb_print_insn): New function.
	* v850-tdep.c (v850_scan_prologue): Call gdb_print_insn, instead
	of TARGET_PRINT_INSN.  Send debug info to "gdb_stdlog".
	* mcore-tdep.c: Include "disasm.h"
	(mcore_dump_insn): Call gdb_print_insn, instead of TARGET_PRINT_INSN.
	* d10v-tdep.c: Include "disasm.h".
	(display_trace): Call gdb_print_insn, instead of print_insn.
	(print_insn): Delete function.
	* printcmd.c: Include "disasm.h".
	(print_insn): Delete function.
	(print_formatted): Call gdb_print_insn, instead of print_insn.
	* Makefile.in (printcmd.o): Update dependencies.
	(mcore-tdep.o, d10v-tdep.o): Ditto.

2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* tuiDisassem.c (tui_disassemble): Call gdb_print_insn, instead of
	TARGET_PRINT_INSN.  Do not initialize a disassemble_info object.
@
text
@d48 1
d412 1
a412 1
	s = find_pc_symtab (deprecated_selected_frame->pc);
@


1.19
log
@2003-04-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn_info): Rename
	"tm_print_insn_info".
	(TARGET_PRINT_INSN_INFO): Delete macro.
	(dis_asm_read_memory): Delete function declaration.
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	(tm_print_insn_info): Delete variable definition.
	(_initialize_gdbarch): Do not initialize "tm_print_insn_info".
	* gdbarch.h, gdbarch.c: Re-generate.
	* d10v-tdep.c (display_trace): Replace "tm_print_insn_info" with
	"deprecated_tm_print_insn_info".
	* mcore-tdep.c (mcore_dump_insn): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* sparc-tdep.c (_initialize_sparc_tdep): Ditto.
	* v850-tdep.c (v850_scan_prologue, v850_gdbarch_init): Ditto.
	* ia64-tdep.c (_initialize_ia64_tdep): Ditto.
	* printcmd.c (print_insn): Use "deprecated_tm_print_insn_info"
	instead of TARGET_PRINT_INSN_INFO, add comment.
	* s390-tdep.c (s390_get_frame_info): Instead of
	"dis_asm_read_memory", use "deprecated_tm_print_insn_info".
	(s390_check_function_end, s390_is_sigreturn): Ditto.
	* corefile.c (dis_asm_read_memory): Move to "disasm.c".
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	* disasm.c: Include "gdbcore.h".
	(_initialize_disasm): New function, initialize
	"deprecated_tm_print_insn_info".
	(deprecated_tm_print_insn_info): New variable.
	(dis_asm_read_memory): Moved from "corefile.c", made static.
	(dis_asm_print_address, dis_asm_memory_error): Ditto.
	* Makefile.in (disasm.o): Update dependencies.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@a70 1
  disassemble_info asm_info;
a74 15
  /* FIXME: cagney/2003-04-28: Should instead be using the generic
     disassembler but first need to clean that up and stop it trying
     to access the exec file.  */

  memcpy (&asm_info, &deprecated_tm_print_insn_info, sizeof (asm_info));
  asm_info.stream = gdb_dis_out;

  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    asm_info.endian = BFD_ENDIAN_BIG;
  else
    asm_info.endian = BFD_ENDIAN_LITTLE;

  if (TARGET_ARCHITECTURE != NULL)
    asm_info.mach = TARGET_ARCHITECTURE->mach;

d89 1
a89 1
      pc = pc + TARGET_PRINT_INSN (pc, &asm_info);
@


1.18
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d76 5
a80 1
  memcpy (&asm_info, TARGET_PRINT_INSN_INFO, sizeof (asm_info));
@


1.18.20.1
log
@Merge from mainline.
@
text
@d71 1
d76 11
d101 1
a101 1
      pc = pc + gdb_print_insn (pc, gdb_dis_out);
@


1.17
log
@2002-09-29  Elena Zannoni  <ezannoni@@redhat.com>

	* tui.c (tui_show_source): Don't access current_source_symtab, use
	accessor function instead.  Include source.h and symtab.h
	* tuiDisassem.c (tuiShowDisassemAndUpdateSource,
	tuiVerticalDisassemScroll): Use accessor functions for current
	source line and symtab.  Include source.h.
	* tuiLayout.c (_extractDisplayStartAddr): Use accessor functions
	for current source line and symtab.  Include source.h.
	* tuiWin.c (_makeVisibleWithNewHeight): Ditto.
	* tuiSourceWin.c (tuiUpdateSourceWindowAsIs,
	tuiHorizontalSourceScroll): Ditto.
	* tuiSource.c (tuiVerticalSourceScroll): Ditto.
@
text
@d423 1
a423 1
	s = find_pc_symtab (selected_frame->pc);
@


1.17.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a47 1
#include "disasm.h"
a56 8
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

d71 1
d76 11
d101 1
a101 1
      pc = pc + gdb_print_insn (pc, gdb_dis_out);
d423 1
a423 1
	s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
@


1.17.2.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@@


1.16
log
@	* tui.c (tuiGetLowDisassemblyAddress): Moved from here.
	* tuiDisassem.c (tuiGetLowDisassemblyAddress): To here, and use
	tui_find_disassembly_address to find the starting address of
	disassemble window.
@
text
@d47 1
d341 1
a341 1
	  current_source_symtab = sal.symtab;
d419 1
d422 1
a422 1
      if (current_source_symtab == (struct symtab *) NULL)
d425 1
a425 1
	s = current_source_symtab;
@


1.16.4.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a46 1
#include "source.h"
d340 1
a340 1
	  set_current_source_symtab_and_line (&sal);
a417 1
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();
d420 1
a420 1
      if (cursal.symtab == (struct symtab *) NULL)
d423 1
a423 1
	s = cursal.symtab;
@


1.16.4.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d423 1
a423 1
	s = find_pc_symtab (deprecated_selected_frame->pc);
@


1.16.4.3
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d76 1
a76 5
  /* FIXME: cagney/2003-04-28: Should instead be using the generic
     disassembler but first need to clean that up and stop it trying
     to access the exec file.  */

  memcpy (&asm_info, &deprecated_tm_print_insn_info, sizeof (asm_info));
@


1.16.4.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d71 1
d76 15
d105 1
a105 1
      pc = pc + gdb_print_insn (pc, gdb_dis_out);
@


1.16.4.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a47 1
#include "disasm.h"
a56 8
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

d411 1
a411 1
	s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
@


1.16.4.6
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.15
log
@	* tuiDisassem.c (tui_disassemble): New function to disassemble
	several lines in a buffer.
	(tui_find_disassembly_address): New function to search backward
	or forward a disassembly line.
	(tuiSetDisassemContent): Use tui_disassemble to obtain the real
	content and format it in the window.
	(tuiShowDisassemAndUpdateSource): Remove unused locals.
	(tuiVerticalDisassemScroll): Use tui_find_disassembly_address to
	obtain the address to disassemble for the scrolling.
	* tuiDisassem.h (tuiGetBeginAsmAddress): Update.
	* tuiSourceWin.c (tuiUpdateSourceWindowAsIs): Don't pass symtab.
@
text
@d385 18
@


1.14
log
@	* tuiDisassem.c (tuiSetDisassemContent): Use breakpoint_here_p.
	(_hasBreak): Remove.
@
text
@d56 136
d193 1
a193 4
/*
   ** tuiSetDisassemContent().
   **        Function to set the disassembly window's content.
 */
d195 1
a195 1
tuiSetDisassemContent (struct symtab *s, CORE_ADDR startAddr)
d198 51
a248 1
  struct ui_file *gdb_dis_out;
d250 2
a251 1
  if (startAddr != 0)
d253 30
a282 1
      register int i, desc;
d284 2
a285 70
      if ((ret = tuiAllocSourceBuffer (disassemWin)) == TUI_SUCCESS)
	{
	  register int offset = disassemWin->detail.sourceInfo.horizontalOffset;
	  register int threshold, curLine = 0, lineWidth, maxLines;
	  CORE_ADDR newpc, pc;
	  disassemble_info asmInfo;
	  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
extern void strcat_address (CORE_ADDR, char *, int);
extern void strcat_address_numeric (CORE_ADDR, int, char *, int);
	  int curLen = 0;
	  int tab_len = tuiDefaultTabLen ();

	  maxLines = disassemWin->generic.height - 2;	/* account for hilite */
	  lineWidth = disassemWin->generic.width - 1;
	  threshold = (lineWidth - 1) + offset;

	  /* now init the ui_file structure */
	  gdb_dis_out = tui_sfileopen (threshold);

          asmInfo = tm_print_insn_info;
          asmInfo.stream = gdb_dis_out;

	  disassemWin->detail.sourceInfo.startLineOrAddr.addr = startAddr;

	  /* Now construct each line */
	  for (curLine = 0, pc = startAddr; (curLine < maxLines);)
	    {
	      TuiWinElementPtr element = (TuiWinElementPtr) disassemWin->generic.content[curLine];

	      print_address (pc, gdb_dis_out);

	      curLen = strlen (tui_file_get_strbuf (gdb_dis_out));
	      i = curLen - ((curLen / tab_len) * tab_len);

	      /* adjust buffer length if necessary */
	      tui_file_adjust_strbuf ((tab_len - i > 0) ? (tab_len - i) : 0, gdb_dis_out);

	      /* Add spaces to make the instructions start onthe same column */
	      while (i < tab_len)
		{
		  tui_file_get_strbuf (gdb_dis_out)[curLen] = ' ';
		  i++;
		  curLen++;
		}
	      tui_file_get_strbuf (gdb_dis_out)[curLen] = '\0';

	      newpc = pc + ((*tm_print_insn) (pc, &asmInfo));

	      /* Now copy the line taking the offset into account */
	      if (strlen (tui_file_get_strbuf (gdb_dis_out)) > offset)
		strcpy (element->whichElement.source.line,
			&(tui_file_get_strbuf (gdb_dis_out)[offset]));
	      else
		element->whichElement.source.line[0] = '\0';
	      element->whichElement.source.lineOrAddr.addr = pc;
	      element->whichElement.source.isExecPoint =
		(pc == (CORE_ADDR) ((TuiWinElementPtr) locator->content[0])->whichElement.locator.addr);
	      element->whichElement.source.hasBreak =
		(breakpoint_here_p (pc) != no_breakpoint_here
		 && !element->whichElement.source.isExecPoint);
	      curLine++;
	      pc = newpc;
	      /* reset the buffer to empty */
	      tui_file_get_strbuf (gdb_dis_out)[0] = '\0';
	    }
	  ui_file_delete (gdb_dis_out);
	  gdb_dis_out = NULL;
	  disassemWin->generic.contentSize = curLine;
	  ret = TUI_SUCCESS;
	}
d287 3
a289 3

  return ret;
}				/* tuiSetDisassemContent */
d330 1
a330 1
      TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
d383 1
a383 2
}

d395 1
a395 1
      CORE_ADDR pc, lowAddr;
d398 2
d407 2
d410 4
a413 24
      if (find_pc_partial_function (pc, (char **) NULL, &lowAddr,
				    (CORE_ADDR) 0) == 0)
	error ("No function contains program counter for selected frame.\n");
      else
	{
	  register int line = 0;
	  register CORE_ADDR newLow;
	  bfd_byte buffer[4];
	  TuiLineOrAddress val;

	  newLow = pc;
	  if (scrollDirection == FORWARD_SCROLL)
	    {
	      for (; line < numToScroll; line++)
		newLow += sizeof (bfd_getb32 (buffer));
	    }
	  else
	    {
	      for (; newLow != 0 && line < numToScroll; line++)
		newLow -= sizeof (bfd_getb32 (buffer));
	    }
	  val.addr = newLow;
	  tuiUpdateSourceWindowAsIs (disassemWin, s, val, FALSE);
	}
d415 1
a415 3

  return;
}				/* tuiVerticalDisassemScroll */
@


1.13
log
@	* tuiDisassem.c (tuiGetBeginAsmAddress): Use lookup_minimal_symbol
	to find symbol address.
@
text
@a56 11
/*****************************************
** STATIC LOCAL FUNCTIONS FORWARD DECLS    **
******************************************/

static struct breakpoint *_hasBreak (CORE_ADDR);


/*****************************************
** PUBLIC FUNCTIONS                        **
******************************************/

a98 1
	      struct breakpoint *bp;
a127 1
	      bp = _hasBreak (pc);
d129 2
a130 3
		(bp != (struct breakpoint *) NULL &&
		 (!element->whichElement.source.isExecPoint ||
		  (bp->disposition != disp_del || bp->hit_count <= 0)));
a289 28



/*****************************************
** STATIC LOCAL FUNCTIONS                 **
******************************************/
/*
   ** _hasBreak().
   **      Answer whether there is a break point at the input line in the
   **      source file indicated
 */
static struct breakpoint *
_hasBreak (CORE_ADDR addr)
{
  struct breakpoint *bpWithBreak = (struct breakpoint *) NULL;
  struct breakpoint *bp;
  extern struct breakpoint *breakpoint_chain;


  for (bp = breakpoint_chain;
       (bp != (struct breakpoint *) NULL &&
	bpWithBreak == (struct breakpoint *) NULL);
       bp = bp->next)
    if (addr == bp->address)
      bpWithBreak = bp;

  return bpWithBreak;
}				/* _hasBreak */
@


1.12
log
@Add FIXME explaining include problem.
@
text
@d234 1
a234 6
      /*the target is not executing, because the pc is 0 */

      addr = parse_and_eval_address ("main");

      if (addr == 0)
	addr = parse_and_eval_address ("MAIN");
d236 11
d252 1
a252 1
}				/* tuiGetBeginAsmAddress */
@


1.12.8.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a55 15
struct tui_asm_line 
{
  CORE_ADDR addr;
  char* addr_string;
  char* insn;
};

/* Function to set the disassembly window's content.
   Disassemble count lines starting at pc.
   Return address of the count'th instruction after pc.  */
static CORE_ADDR
tui_disassemble (struct tui_asm_line* lines, CORE_ADDR pc, int count)
{
  struct ui_file *gdb_dis_out;
  disassemble_info asm_info;
d57 3
a59 2
  /* now init the ui_file structure */
  gdb_dis_out = tui_sfileopen (256);
d61 1
a61 2
  memcpy (&asm_info, TARGET_PRINT_INSN_INFO, sizeof (asm_info));
  asm_info.stream = gdb_dis_out;
a62 4
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    asm_info.endian = BFD_ENDIAN_BIG;
  else
    asm_info.endian = BFD_ENDIAN_LITTLE;
d64 3
a66 2
  if (TARGET_ARCHITECTURE != NULL)
    asm_info.mach = TARGET_ARCHITECTURE->mach;
d68 4
a71 108
  /* Now construct each line */
  for (; count > 0; count--, lines++)
    {
      if (lines->addr_string)
        xfree (lines->addr_string);
      if (lines->insn)
        xfree (lines->insn);
      
      print_address (pc, gdb_dis_out);
      lines->addr = pc;
      lines->addr_string = xstrdup (tui_file_get_strbuf (gdb_dis_out));

      ui_file_rewind (gdb_dis_out);

      pc = pc + TARGET_PRINT_INSN (pc, &asm_info);

      lines->insn = xstrdup (tui_file_get_strbuf (gdb_dis_out));

      /* reset the buffer to empty */
      ui_file_rewind (gdb_dis_out);
    }
  ui_file_delete (gdb_dis_out);
  return pc;
}

/* Find the disassembly address that corresponds to FROM lines
   above or below the PC.  Variable sized instructions are taken
   into account by the algorithm.  */
static CORE_ADDR
tui_find_disassembly_address (CORE_ADDR pc, int from)
{
  register CORE_ADDR newLow;
  int maxLines;
  int i;
  struct tui_asm_line* lines;

  maxLines = (from > 0) ? from : - from;
  if (maxLines <= 1)
     return pc;

  lines = (struct tui_asm_line*) alloca (sizeof (struct tui_asm_line)
                                         * maxLines);
  memset (lines, 0, sizeof (struct tui_asm_line) * maxLines);

  newLow = pc;
  if (from > 0)
    {
      tui_disassemble (lines, pc, maxLines);
      newLow = lines[maxLines - 1].addr;
    }
  else
    {
      CORE_ADDR last_addr;
      int pos;
      struct minimal_symbol* msymbol;
              
      /* Find backward an address which is a symbol
         and for which disassembling from that address will fill
         completely the window.  */
      pos = maxLines - 1;
      do {
         newLow -= 1 * maxLines;
         msymbol = lookup_minimal_symbol_by_pc_section (newLow, 0);

         if (msymbol)
            newLow = SYMBOL_VALUE_ADDRESS (msymbol);
         else
            newLow += 1 * maxLines;

         tui_disassemble (lines, newLow, maxLines);
         last_addr = lines[pos].addr;
      } while (last_addr > pc && msymbol);

      /* Scan forward disassembling one instruction at a time
         until the last visible instruction of the window
         matches the pc.  We keep the disassembled instructions
         in the 'lines' window and shift it downward (increasing
         its addresses).  */
      if (last_addr < pc)
        do
          {
            CORE_ADDR next_addr;
                 
            pos++;
            if (pos >= maxLines)
              pos = 0;

            next_addr = tui_disassemble (&lines[pos], last_addr, 1);

            /* If there are some problems while disassembling exit.  */
            if (next_addr <= last_addr)
              break;
            last_addr = next_addr;
          } while (last_addr <= pc);
      pos++;
      if (pos >= maxLines)
         pos = 0;
      newLow = lines[pos].addr;
    }
  for (i = 0; i < maxLines; i++)
    {
      xfree (lines[i].addr_string);
      xfree (lines[i].insn);
    }
  return newLow;
}

/* Function to set the disassembly window's content.  */
d73 1
a73 1
tuiSetDisassemContent (CORE_ADDR pc)
d76 1
a76 47
  register int i;
  register int offset = disassemWin->detail.sourceInfo.horizontalOffset;
  register int lineWidth, maxLines;
  CORE_ADDR cur_pc;
  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
  int tab_len = tuiDefaultTabLen ();
  struct tui_asm_line* lines;
  int insn_pos;
  int addr_size, max_size;
  char* line;
  
  if (pc == 0)
    return TUI_FAILURE;

  ret = tuiAllocSourceBuffer (disassemWin);
  if (ret != TUI_SUCCESS)
    return ret;

  disassemWin->detail.sourceInfo.startLineOrAddr.addr = pc;
  cur_pc = (CORE_ADDR)
    (((TuiWinElementPtr) locator->content[0])->whichElement.locator.addr);

  maxLines = disassemWin->generic.height - 2;	/* account for hilite */

  /* Get temporary table that will hold all strings (addr & insn).  */
  lines = (struct tui_asm_line*) alloca (sizeof (struct tui_asm_line)
                                         * maxLines);
  memset (lines, 0, sizeof (struct tui_asm_line) * maxLines);

  lineWidth = disassemWin->generic.width - 1;

  tui_disassemble (lines, pc, maxLines);

  /* See what is the maximum length of an address and of a line.  */
  addr_size = 0;
  max_size = 0;
  for (i = 0; i < maxLines; i++)
    {
      size_t len = strlen (lines[i].addr_string);
      if (len > addr_size)
        addr_size = len;

      len = strlen (lines[i].insn) + tab_len;
      if (len > max_size)
        max_size = len;
    }
  max_size += addr_size + tab_len;
d78 1
a78 6
  /* Allocate memory to create each line.  */
  line = (char*) alloca (max_size);
  insn_pos = (1 + (addr_size / tab_len)) * tab_len;

  /* Now construct each line */
  for (i = 0; i < maxLines; i++)
d80 1
a80 23
      TuiWinElementPtr element;
      TuiSourceElement* src;
      int curLen;

      element = (TuiWinElementPtr) disassemWin->generic.content[i];
      src = &element->whichElement.source;
      strcpy (line, lines[i].addr_string);
      curLen = strlen (line);

      /* Add spaces to make the instructions start on the same column */
      while (curLen < insn_pos)
        {
          strcat (line, " ");
          curLen++;
        }

      strcat (line, lines[i].insn);

      /* Now copy the line taking the offset into account */
      if (strlen (line) > offset)
        strcpy (src->line, &line[offset]);
      else
        src->line[0] = '\0';
d82 74
a155 2
      src->lineOrAddr.addr = lines[i].addr;
      src->isExecPoint = lines[i].addr == cur_pc;
d157 2
a158 10
      /* See whether there is a breakpoint installed.  */
      src->hasBreak = (!src->isExecPoint
                       && breakpoint_here_p (pc) != no_breakpoint_here);

      xfree (lines[i].addr_string);
      xfree (lines[i].insn);
    }
  disassemWin->generic.contentSize = i;
  return TUI_SUCCESS;
}
d199 1
a199 1

d234 6
a239 1
      struct minimal_symbol *main_symbol;
a240 11
      /* Find address of the start of program.
         Note: this should be language specific.  */
      main_symbol = lookup_minimal_symbol ("main", NULL, NULL);
      if (main_symbol == 0)
        main_symbol = lookup_minimal_symbol ("MAIN", NULL, NULL);
      if (main_symbol == 0)
        main_symbol = lookup_minimal_symbol ("_start", NULL, NULL);
      if (main_symbol)
        addr = SYMBOL_VALUE_ADDRESS (main_symbol);
      else
        addr = 0;
a247 17
/* Determine what the low address will be to display in the TUI's
   disassembly window.  This may or may not be the same as the
   low address input.  */
CORE_ADDR
tuiGetLowDisassemblyAddress (CORE_ADDR low, CORE_ADDR pc)
{
  int pos;

  /* Determine where to start the disassembly so that the pc is about in the
     middle of the viewport.  */
  pos = tuiDefaultWinViewportHeight (DISASSEM_WIN, DISASSEM_COMMAND) / 2;
  pc = tui_find_disassembly_address (pc, -pos);

  if (pc < low)
    pc = low;
  return pc;
}
d259 1
a259 1
      CORE_ADDR pc;
a261 2
      TuiLineOrAddress val;
      int maxLines, dir;
a268 2
      /* account for hilite */
      maxLines = disassemWin->generic.height - 2;
d270 28
a297 1
      dir = (scrollDirection == FORWARD_SCROLL) ? maxLines : - maxLines;
d299 27
a325 4
      val.addr = tui_find_disassembly_address (pc, dir);
      tuiUpdateSourceWindowAsIs (disassemWin, s, val, FALSE);
    }
}
@


1.12.8.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a46 1
#include "source.h"
d340 1
a340 1
	  set_current_source_symtab_and_line (&sal);
a417 1
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();
d420 1
a420 1
      if (cursal.symtab == (struct symtab *) NULL)
d423 1
a423 1
	s = cursal.symtab;
@


1.11
log
@2002-02-08  Daniel Jacobowitz  <drow@@mvista.com>

        * utils.c: Include <curses.h> before "bfd.h".
        * tui/tui-hooks.c: Likewise.
        * tui/tui.c: Likewise.
        * tui/tuiCommand.c: Likewise.
        * tui/tuiData.c: Likewise.
        * tui/tuiDataWin.c: Likewise.
        * tui/tuiDisassem.c: Likewise.
        * tui/tuiGeneralWin.c: Likewise.
        * tui/tuiIO.c: Likewise.
        * tui/tuiLayout.c: Likewise.
        * tui/tuiRegs.c: Likewise.
        * tui/tuiSource.c: Likewise.
        * tui/tuiSourceWin.c: Likewise.
        * tui/tuiStack.c: Likewise.
        * tui/tuiWin.c: Likewise.
@
text
@d2 4
a5 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d25 8
a32 1
/* If we need <curses.h>, we must include it before we get "bfd.h".  */
@


1.10
log
@Add explicit #include of "value.h".
@
text
@d22 10
@


1.9
log
@	The following changes avoid polluting global namespace with the
	`enable' and `disable' identifiers, because some platforms define
	in their system headers symbols with global scope that go by those
	names.

	* breakpoint.h (enum enable_state): Rename from `enum enable'.
	Also rename all the enum members to have the "bp_" prefix.
	(struct breakpoint): Rename the `enable' member to `enable_state'.
	(enum bpdisp): Rename all members to have the "disp_" prefix.

	* breakpoint.c: All users of `enum enable' and `enum bpdisp'
	changed.
	(args_for_catchpoint_enable): Rename the `enable' member to
	`enable_p'.  All users changed.

	* tracepoint.h (enum enable): Remove.
	(struct tracepoint): The member `enabled' is now `int enabled_p'.

	* tracepoint.c: All users of the `enabled' member changed.

	* printcmd.c (struct display): The `status' member is now an int.

	* memattr.h (struct mem_region): Rename the `status' member to
	`enabled_p'.
	(enum enable): Remove.

	* memattr.c: Change all users of the `status' member of struct
	mem_region to use `enabled_p' instead.

	* infcmd.c (run_stack_dummy): Use disp_del instead of del.

	* go32-nat.c: Remove the kludgey work-around for conflicts between
	<dos.h> and "breakpoint.h".
	* tui/tuiSourceWin.c: Use disp_del instead of del.

	* tui/tuiSource.c: Use disp_del instead of del.

	* tui/tuiDisassem.c: Use disp_del instead of del.
@
text
@d26 1
@


1.8
log
@	* tuiWin.c (_parseScrollingArgs): Fix uninitialized variable.
	(_makeVisibleWithNewHeight): Use TuiLineOrAddress type.

	* tuiStack.c (tuiShowFrameInfo): Use TuiLineOrAddress type.
	(tui_vUpdateLocatorFilename): Remove.
	* tuiStack.h: Update prototypes.

	* tuiSourceWin.c (tuiAddrIsDisplayed): New function.
	(tuiLineIsDisplayed): Split for address and line.
	(tuiUpdateSourceWindow): Use TuiLineOrAddress type.
	(tuiUpdateSourceWindowAsIs): Likewise.
	(tuiUpdateSourceWindowsWithAddr): Likewise.
	(tuiUpdateSourceWindowsWithLine): Likewise.
	(tuiHorizontalSourceScroll): Likewise.
	(tuiSetIsExecPointAt): Likewise.
	(tuiUpdateOnEnd): Likewise.
	* tuiSourceWin.h: Update prototypes.

	* tuiSource.c (tuiVerticalSourceScroll): Use TuiLineOrAddress type.
	(tuiShowSource): Likewise.
	(tuiVerticalSourceScroll): Likewise.
	* tuiSource.h (tuiShowSource): Update prototype.

	* tuiDisassem.c (tuiSetDisassemContent): Use CORE_ADDR for address.
	(tuiShowDisassem): Use TuiLineOrAddress type.
	(tuiShowDisassemAndUpdateSource): Likewise.
	(tuiVerticalDisassemScroll): Likewise.
	(tuiShowDisassemAsIs): Remove.
	* tuiDisassem.h (tuiSetDisassemContent): Update prototype.

	* tuiData.c (initWinInfo): Use CORE_ADDR for address.
	(clearWinDetail): Likewise.
	(displayableWinContentOf): Fix address conversion.
	(tuiNextWin): Fix crash when the window is not yet created.
	(partialWinByName): Likewise.
@
text
@d123 1
a123 1
		  (bp->disposition != del || bp->hit_count <= 0)));
@


1.8.2.1
log
@	The following changes avoid polluting global namespace with the
	`enable' and `disable' identifiers, because some platforms define
	in their system headers symbols with global scope that go by those
	names.

	* breakpoint.h (enum enable_state): Rename from `enum enable'.
	Also rename all the enum members to have the "bp_" prefix.
	(struct breakpoint): Rename the `enable' member to `enable_state'.
	(enum bpdisp): Rename all members to have the "disp_" prefix.

	* breakpoint.c: All users of `enum enable' and `enum bpdisp'
	changed.
	(args_for_catchpoint_enable): Rename the `enable' member to
	`enable_p'.  All users changed.

	* tracepoint.h (enum enable): Remove.
	(struct tracepoint): The member `enabled' is now `int enabled_p'.

	* tracepoint.c: All users of the `enabled' member changed.

	* printcmd.c (struct display): The `status' member is now an int.

	* memattr.h (struct mem_region): Rename the `status' member to
	`enabled_p'.
	(enum enable): Remove.

	* memattr.c: Change all users of the `status' member of struct
	mem_region to use `enabled_p' instead.

	* infcmd.c (run_stack_dummy): Use disp_del instead of del.

	* go32-nat.c: Remove the kludgey work-around for conflicts between
	<dos.h> and "breakpoint.h".

	* tui/tuiSourceWin.c: Use disp_del instead of del.

	* tui/tuiSource.c: Use disp_del instead of del.

	* tui/tuiDisassem.c: Use disp_del instead of del.
@
text
@d123 1
a123 1
		  (bp->disposition != disp_del || bp->hit_count <= 0)));
@


1.7
log
@	* tuiDisassem.c (tuiVerticalDisassemScroll): Use CORE_ADDR.
	(tuiVerticalDisassemScroll): Likewise.
	(tuiShowDisassemAndUpdateSource): Check for null symtab to
	prevent a crash.
@
text
@d116 1
a116 1
	      element->whichElement.source.lineOrAddr.addr = (Opaque) pc;
d149 1
d151 1
d153 1
a153 1
  tuiUpdateSourceWindow (disassemWin, s, startAddr, FALSE);
d177 1
d184 2
a185 1
      tuiUpdateSourceWindow (srcWin, sal.symtab, sal.line, TRUE);
a197 22

/*
   ** tuiShowDisassemAsIs().
   **        Function to display the disassembly window.  This function shows
   **        the disassembly as specified by the horizontal offset.
 */
void
tuiShowDisassemAsIs (Opaque addr)
{
  tuiAddWinToLayout (DISASSEM_WIN);
  tuiUpdateSourceWindowAsIs (disassemWin, (struct symtab *) NULL, addr, FALSE);
  /*
     ** Update what is in the source window if it is displayed too, not that it
     ** follows what is in the disassembly window and visa-versa
   */
  if (currentLayout () == SRC_DISASSEM_COMMAND)
    tuiShowSourceContent (srcWin);	/*????  Need to do more? */

  return;
}				/* tuiShowDisassem */


d257 1
d267 1
a267 1
	      for (; newLow >= (Opaque) 0 && line < numToScroll; line++)
d270 2
a271 1
	  tuiUpdateSourceWindowAsIs (disassemWin, s, newLow, FALSE);
@


1.6
log
@	* tuiData.h (TuiLocatorElement): Use CORE_ADDR for address member.
	(TuiLineOrAddress): Likewise.
	* tuiDisassem.c (tuiGetBeginAsmAddress): Use CORE_ADDR to specify
	an address.
	(tuiSetDisassemContent): Likewise.
	(tuiShowDisassem, tuiShowDisassemAndUpdateSource): Likewise.
	* tuiLayout.c (_extractDisplayStartAddr): Likewise.
	(tuiSetLayout): Likewise.
	* tuiSourceWin.c (tuiDisplayMainFunction): Likewise.
	(tuiUpdateSourceWindowsWithAddr): Likewise.
	(tuiUpdateSourceWindowsWithLine): Likewise.
	(tuiSetHasBreakAt): Likewise.
	* tuiStack.c (tuiSetLocatorInfo): Likewise.
	(tuiSwitchFilename): Likewise.
	(tuiUpdateLocatorInfoFromFrame): Likewise.
	(tuiSetLocatorContent): Likewise.
	(tuiShowFrameInfo): Likewise.
	* tuiDisassem.h: Update prototypes to use CORE_ADDR.
	* tuiSourceWin.h: Likewise.
	* tuiStack.h: Likewise.
@
text
@d181 8
a188 3
      current_source_symtab = sal.symtab;
      tuiUpdateSourceWindow (srcWin, sal.symtab, (Opaque) sal.line, TRUE);
      tuiUpdateLocatorFilename (sal.symtab->filename);
d256 1
a256 1
      Opaque pc, lowAddr;
d267 3
a269 5
      if (find_pc_partial_function ((CORE_ADDR) pc,
				    (char **) NULL,
				    (CORE_ADDR *) & lowAddr,
				    (CORE_ADDR) NULL) == 0)
	error ("No function contains prgram counter for selected frame.\n");
d273 1
a273 1
	  register Opaque newLow;
@


1.5
log
@	* tuiDisassem.c (tuiSetDisassemContent): Use tm_print_insn_info
	to disassemble in the curses window.
@
text
@d52 1
a52 1
tuiSetDisassemContent (struct symtab *s, Opaque startAddr)
d57 1
a57 1
  if (startAddr != (Opaque) NULL)
d86 1
a86 1
	  for (curLine = 0, pc = (CORE_ADDR) startAddr; (curLine < maxLines);)
d145 1
a145 1
tuiShowDisassem (Opaque startAddr)
d147 1
a147 1
  struct symtab *s = find_pc_symtab ((CORE_ADDR) startAddr);
d168 1
a168 1
tuiShowDisassemAndUpdateSource (Opaque startAddr)
d180 1
a180 1
      sal = find_pc_line ((CORE_ADDR) startAddr, 0);
d214 1
a214 1
Opaque
d219 1
a219 1
  Opaque addr;
d224 1
a224 1
  if (element->addr == (Opaque) 0)
d228 1
a228 1
      addr = (Opaque) parse_and_eval_address ("main");
d230 2
a231 2
      if (addr == (Opaque) 0)
	addr = (Opaque) parse_and_eval_address ("MAIN");
@


1.4
log
@	* tuiWin.c, tui.c, tuiCommand.c: Use ansi prototype.
	tuiIO.c, tuiData.c: Likewise.
	tuiDataWin.c, tuiDisassem.c: Likewise.
	tuiGeneralWin.c, tuiLayout.c: Likewise.
	tuiRegs.c, tuiSource.c: Likewise.
	tuiSouceWin.c, tuiStack.c: Likewise.
@
text
@d29 1
d33 1
d80 2
a81 3
	  INIT_DISASSEMBLE_INFO_NO_ARCH (asmInfo, gdb_dis_out, (fprintf_ftype) fprintf_filtered);
	  asmInfo.read_memory_func = dis_asm_read_memory;
	  asmInfo.memory_error_func = dis_asm_memory_error;
@


1.3
log
@	* tuiWin.c, tuiWin.h, tui.c, tui.h, tuiCommand.c: Add FSF copyright.
	tuiCommand.h, tuiIO.c, tuiIO.h, tuiData.h, tuiData.c: Likewise.
	tuiDataWin.c, tuiDataWin.h, tuiDisassem.c, tuiDisassem.h: Likewise.
	tuiGeneralWin.c, tuiGeneralWin.h, tuiLayout.c, tuiLayout.h: Likewise.
	tuiRegs.c, tuiRegs.h, tuiSource.c, tuiSource.h: Likewise.
	tuiSouceWin.c, tuiSourceWin.h, tuiStack.c, tuiStack.h: Likewise.
@
text
@d50 1
a50 9
#ifdef __STDC__
tuiSetDisassemContent (
			struct symtab *s,
			Opaque startAddr)
#else
tuiSetDisassemContent (s, startAddr)
     struct symtab *s;
     Opaque startAddr;
#endif
d144 1
a144 7
#ifdef __STDC__
tuiShowDisassem (
		  Opaque startAddr)
#else
tuiShowDisassem (startAddr)
     Opaque startAddr;
#endif
d167 1
a167 7
#ifdef __STDC__
tuiShowDisassemAndUpdateSource (
				 Opaque startAddr)
#else
tuiShowDisassemAndUpdateSource (startAddr)
     Opaque startAddr;
#endif
d195 1
a195 7
#ifdef __STDC__
tuiShowDisassemAsIs (
		      Opaque addr)
#else
tuiShowDisassemAsIs (addr)
     Opaque addr;
#endif
a213 1
#ifdef __STDC__
a214 3
#else
tuiGetBeginAsmAddress ()
#endif
d245 2
a246 9
#ifdef __STDC__
tuiVerticalDisassemScroll (
			    TuiScrollDirection scrollDirection,
			    int numToScroll)
#else
tuiVerticalDisassemScroll (scrollDirection, numToScroll)
     TuiScrollDirection scrollDirection;
     int numToScroll;
#endif
d301 1
a301 7
#ifdef __STDC__
_hasBreak (
	    CORE_ADDR addr)
#else
_hasBreak (addr)
     CORE_ADDR addr;
#endif
@


1.2
log
@PARAMS removal.
@
text
@d1 3
a3 4
/*
   ** tuiDisassem.c
   **         This module contains functions for handling disassembly display.
 */
d5 16
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
** tuiDisassem.c
**         This module contains functions for handling disassembly display.
*/
d23 1
a23 1
static struct breakpoint *_hasBreak PARAMS ((CORE_ADDR));
d31 3
a33 3
** tuiSetDisassemContent().
**        Function to set the disassembly window's content.
*/
d37 2
a38 2
		       struct symtab *s,
		       Opaque startAddr)
d40 1
a40 1
     tuiSetDisassemContent (s, startAddr)
d46 1
a46 1
  GDB_FILE *gdb_dis_out;
d59 2
a60 2
	  extern void strcat_address PARAMS ((CORE_ADDR, char *, int));
	  extern void strcat_address_numeric PARAMS ((CORE_ADDR, int, char *, int));
d68 2
a69 2
	  /* now init the gdb_file structure */
          gdb_dis_out = gdb_file_init_astring (threshold);
d80 1
a80 1
	      TuiWinElementPtr element = (TuiWinElementPtr)disassemWin->generic.content[curLine];
d85 1
a85 1
	      curLen = strlen (gdb_file_get_strbuf (gdb_dis_out));
d88 3
a90 3
              /* adjust buffer length if necessary */
	      gdb_file_adjust_strbuf ((tab_len - i > 0) ? (tab_len - i ) : 0, gdb_dis_out);
		
d94 1
a94 1
		  gdb_file_get_strbuf (gdb_dis_out)[curLen] = ' ';
d98 1
a98 1
	      gdb_file_get_strbuf (gdb_dis_out)[curLen] = '\0';
d103 1
a103 1
	      if (strlen (gdb_file_get_strbuf (gdb_dis_out)) > offset)
d105 1
a105 1
			&(gdb_file_get_strbuf (gdb_dis_out)[offset]));
d110 1
a110 1
		(pc == (CORE_ADDR) ((TuiWinElementPtr)locator->content[0])->whichElement.locator.addr);
d118 2
a119 2
              /* reset the buffer to empty */
	      gdb_file_get_strbuf (gdb_dis_out)[0] = '\0';
d121 2
a122 1
	  gdb_file_deallocate (&gdb_dis_out);
d133 3
a135 3
** tuiShowDisassem().
**        Function to display the disassembly window with disassembled code.
*/
d151 3
a153 3
    ** if the focus was in the src win, put it in the asm win, if the
    ** source view isn't split
    */
d162 3
a164 3
** tuiShowDisassemAndUpdateSource().
**        Function to display the disassembly window.
*/
d181 3
a183 3
        ** Update what is in the source window if it is displayed too,
        ** note that it follows what is in the disassembly window and visa-versa
        */
d195 4
a198 4
** tuiShowDisassemAsIs().
**        Function to display the disassembly window.  This function shows
**        the disassembly as specified by the horizontal offset.
*/
d211 3
a213 3
    ** Update what is in the source window if it is displayed too, not that it
    ** follows what is in the disassembly window and visa-versa
    */
d222 2
a223 2
** tuiGetBeginAsmAddress().
*/
d240 1
a240 1
      /*the target is not executing, because the pc is 0*/
d256 3
a258 3
** tuiVerticalDisassemScroll().
**      Scroll the disassembly forward or backward vertically
*/
d318 4
a321 4
** _hasBreak().
**      Answer whether there is a break point at the input line in the
**      source file indicated
*/
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d2 3
a4 3
   ** tuiDisassem.c
   **         This module contains functions for handling disassembly display.
 */
d31 3
a33 3
   ** tuiSetDisassemContent().
   **        Function to set the disassembly window's content.
 */
d37 2
a38 2
			struct symtab *s,
			Opaque startAddr)
d40 1
a40 1
tuiSetDisassemContent (s, startAddr)
d69 1
a69 1
	  gdb_dis_out = gdb_file_init_astring (threshold);
d80 1
a80 1
	      TuiWinElementPtr element = (TuiWinElementPtr) disassemWin->generic.content[curLine];
d88 3
a90 3
	      /* adjust buffer length if necessary */
	      gdb_file_adjust_strbuf ((tab_len - i > 0) ? (tab_len - i) : 0, gdb_dis_out);

d110 1
a110 1
		(pc == (CORE_ADDR) ((TuiWinElementPtr) locator->content[0])->whichElement.locator.addr);
d118 1
a118 1
	      /* reset the buffer to empty */
d132 3
a134 3
   ** tuiShowDisassem().
   **        Function to display the disassembly window with disassembled code.
 */
d150 3
a152 3
     ** if the focus was in the src win, put it in the asm win, if the
     ** source view isn't split
   */
d161 3
a163 3
   ** tuiShowDisassemAndUpdateSource().
   **        Function to display the disassembly window.
 */
d180 3
a182 3
         ** Update what is in the source window if it is displayed too,
         ** note that it follows what is in the disassembly window and visa-versa
       */
d194 4
a197 4
   ** tuiShowDisassemAsIs().
   **        Function to display the disassembly window.  This function shows
   **        the disassembly as specified by the horizontal offset.
 */
d210 3
a212 3
     ** Update what is in the source window if it is displayed too, not that it
     ** follows what is in the disassembly window and visa-versa
   */
d221 2
a222 2
   ** tuiGetBeginAsmAddress().
 */
d239 1
a239 1
      /*the target is not executing, because the pc is 0 */
d255 3
a257 3
   ** tuiVerticalDisassemScroll().
   **      Scroll the disassembly forward or backward vertically
 */
d317 4
a320 4
   ** _hasBreak().
   **      Answer whether there is a break point at the input line in the
   **      source file indicated
 */
@


1.1.1.3
log
@import gdb-1999-11-08 snapshot
@
text
@d69 1
a69 1
	  gdb_dis_out = tui_sfileopen (threshold);
d85 1
a85 1
	      curLen = strlen (tui_file_get_strbuf (gdb_dis_out));
d89 1
a89 1
	      tui_file_adjust_strbuf ((tab_len - i > 0) ? (tab_len - i) : 0, gdb_dis_out);
d94 1
a94 1
		  tui_file_get_strbuf (gdb_dis_out)[curLen] = ' ';
d98 1
a98 1
	      tui_file_get_strbuf (gdb_dis_out)[curLen] = '\0';
d103 1
a103 1
	      if (strlen (tui_file_get_strbuf (gdb_dis_out)) > offset)
d105 1
a105 1
			&(tui_file_get_strbuf (gdb_dis_out)[offset]));
d119 1
a119 1
	      tui_file_get_strbuf (gdb_dis_out)[0] = '\0';
d121 1
a121 2
	  gdb_file_delete (gdb_dis_out);
	  gdb_dis_out = NULL;
@


1.1.1.4
log
@import gdb-2000-02-01 snapshot
@
text
@d46 1
a46 1
  struct ui_file *gdb_dis_out;
d68 1
a68 1
	  /* now init the ui_file structure */
d121 1
a121 1
	  ui_file_delete (gdb_dis_out);
@


