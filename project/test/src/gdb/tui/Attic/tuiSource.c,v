head	1.17;
access;
symbols
	drow-cplus-merge-20040113:1.16
	drow-cplus-merge-20031224:1.16
	drow-cplus-merge-20031220:1.16
	carlton_dictionary-20031215-merge:1.16
	drow-cplus-merge-20031214:1.16
	carlton-dictionary-20031111-merge:1.16
	gdb_6_0-2003-10-04-release:1.16
	kettenis_sparc-20030918-branch:1.16.0.8
	kettenis_sparc-20030918-branchpoint:1.16
	carlton_dictionary-20030917-merge:1.16
	ezannoni_pie-20030916-branchpoint:1.16
	ezannoni_pie-20030916-branch:1.16.0.6
	cagney_x86i386-20030821-branch:1.16.0.4
	cagney_x86i386-20030821-branchpoint:1.16
	carlton_dictionary-20030805-merge:1.16
	carlton_dictionary-20030627-merge:1.16
	gdb_6_0-branch:1.16.0.2
	gdb_6_0-2003-06-23-branchpoint:1.16
	jimb-ppc64-linux-20030613-branch:1.15.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.15
	cagney_convert-20030606-branch:1.14.0.30
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.14.0.28
	cagney_writestrings-20030508-branchpoint:1.14
	jimb-ppc64-linux-20030528-branch:1.14.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.14
	carlton_dictionary-20030523-merge:1.14
	cagney_fileio-20030521-branch:1.14.0.24
	cagney_fileio-20030521-branchpoint:1.14
	kettenis_i386newframe-20030517-mergepoint:1.14
	jimb-ppc64-linux-20030509-branch:1.14.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.14
	kettenis_i386newframe-20030504-mergepoint:1.14
	carlton_dictionary-20030430-merge:1.14
	kettenis_i386newframe-20030419-branch:1.14.0.20
	kettenis_i386newframe-20030419-branchpoint:1.14
	carlton_dictionary-20030416-merge:1.14
	cagney_frameaddr-20030409-mergepoint:1.14
	kettenis_i386newframe-20030406-branch:1.14.0.18
	kettenis_i386newframe-20030406-branchpoint:1.14
	cagney_frameaddr-20030403-branchpoint:1.14
	cagney_frameaddr-20030403-branch:1.14.0.16
	cagney_framebase-20030330-mergepoint:1.14
	cagney_framebase-20030326-branch:1.14.0.14
	cagney_framebase-20030326-branchpoint:1.14
	cagney_lazyid-20030317-branch:1.14.0.12
	cagney_lazyid-20030317-branchpoint:1.14
	kettenis-i386newframe-20030316-mergepoint:1.14
	offbyone-20030313-branch:1.14.0.10
	offbyone-20030313-branchpoint:1.14
	kettenis-i386newframe-20030308-branch:1.14.0.8
	kettenis-i386newframe-20030308-branchpoint:1.14
	carlton_dictionary-20030305-merge:1.14
	cagney_offbyone-20030303-branch:1.14.0.6
	cagney_offbyone-20030303-branchpoint:1.14
	carlton_dictionary-20030207-merge:1.14
	interps-20030203-mergepoint:1.14
	interps-20030202-branch:1.14.0.4
	interps-20030202-branchpoint:1.14
	cagney-unwind-20030108-branch:1.14.0.2
	cagney-unwind-20030108-branchpoint:1.14
	carlton_dictionary-20021223-merge:1.14
	gdb_5_3-2002-12-12-release:1.12
	carlton_dictionary-20021115-merge:1.13
	kseitz_interps-20021105-merge:1.13
	kseitz_interps-20021103-merge:1.13
	drow-cplus-merge-20021020:1.13
	drow-cplus-merge-20021025:1.13
	carlton_dictionary-20021025-merge:1.13
	carlton_dictionary-20021011-merge:1.13
	drow-cplus-branch:1.13.0.2
	drow-cplus-branchpoint:1.13
	kseitz_interps-20020930-merge:1.13
	carlton_dictionary-20020927-merge:1.12
	carlton_dictionary-branch:1.12.0.4
	carlton_dictionary-20020920-branchpoint:1.12
	gdb_5_3-branch:1.12.0.2
	gdb_5_3-2002-09-04-branchpoint:1.12
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.2
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.9.0.10
	readline_4_3-import-branchpoint:1.9
	gdb_5_2_1-2002-07-23-release:1.9
	kseitz_interps-20020528-branch:1.9.0.8
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.6
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.4
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	gdb_5_2-branch:1.9.0.2
	gdb_5_2-2002-03-03-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.6.2.1
	gdb_5_1_0_1-2002-01-03-release:1.6.2.1
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.6.2.1.0.4
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6.2.1
	gdb_5_1-2001-11-21-release:1.6.2.1
	gdb_s390-2001-09-26-branch:1.6.2.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.6.2.1
	gdb_5_1-2001-07-29-branch:1.6.0.2
	gdb_5_1-2001-07-29-branchpoint:1.6
	dberlin-typesystem-branch:1.2.0.4
	dberlin-typesystem-branchpoint:1.2
	gdb-post-ptid_t-2001-05-03:1.2
	gdb-pre-ptid_t-2001-05-03:1.2
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.17
date	2004.01.19.04.31.52;	author cagney;	state dead;
branches;
next	1.16;

1.16
date	2003.06.22.15.21.39;	author drow;	state Exp;
branches
	1.16.6.1;
next	1.15;

1.15
date	2003.06.12.15.44.24;	author schwab;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.29.19.15.16;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.30.00.52.27;	author ezannoni;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2002.09.01.16.12.52;	author ciceron;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2002.08.30.20.23.34;	author ciceron;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.25.11.00.46;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.01.06.19.28;	author cagney;	state Exp;
branches
	1.9.8.1;
next	1.8;

1.8
date	2002.02.08.15.54.32;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.02.11.58.29;	author eliz;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.20.23.06.48;	author ciceron;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.07.16.22.13.38;	author ciceron;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.14.19.31.09;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.14.19.01.25;	author ciceron;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.42;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.19.28;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.22.03.25.22;	author jsm;	state Exp;
branches;
next	;

1.6.2.1
date	2001.08.02.12.05.59;	author eliz;	state Exp;
branches;
next	;

1.9.8.1
date	2002.08.30.22.52.52;	author kseitz;	state Exp;
branches;
next	1.9.8.2;

1.9.8.2
date	2002.10.01.00.46.35;	author kseitz;	state Exp;
branches;
next	;

1.12.4.1
date	2002.10.11.22.23.03;	author carlton;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.12.23.19.39.21;	author carlton;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2003.06.27.21.50.21;	author carlton;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2004.01.26.19.11.45;	author carlton;	state dead;
branches;
next	;

1.13.2.1
date	2003.12.14.20.27.59;	author drow;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2004.02.09.19.43.58;	author drow;	state dead;
branches;
next	;

1.16.6.1
date	2004.03.23.20.09.17;	author ezannoni;	state dead;
branches;
next	;


desc
@@


1.17
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@/* TUI display source window.

   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include <ctype.h>
#include "symtab.h"
#include "frame.h"
#include "breakpoint.h"
#include "source.h"
#include "symtab.h"

#include "tui.h"
#include "tuiData.h"
#include "tuiStack.h"
#include "tuiSourceWin.h"
#include "tuiSource.h"

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

/* Function to display source in the source window.  */
TuiStatus
tuiSetSourceContent (struct symtab *s, int lineNo, int noerror)
{
  TuiStatus ret = TUI_FAILURE;

  if (s != (struct symtab *) NULL && s->filename != (char *) NULL)
    {
      register FILE *stream;
      register int i, desc, c, lineWidth, nlines;
      register char *srcLine = 0;

      if ((ret = tuiAllocSourceBuffer (srcWin)) == TUI_SUCCESS)
	{
	  lineWidth = srcWin->generic.width - 1;
	  /* Take hilite (window border) into account, when calculating
	     the number of lines  */
	  nlines = (lineNo + (srcWin->generic.height - 2)) - lineNo;
	  desc = open_source_file (s);
	  if (desc < 0)
	    {
	      if (!noerror)
		{
		  char *name = alloca (strlen (s->filename) + 100);
		  sprintf (name, "%s:%d", s->filename, lineNo);
		  print_sys_errmsg (name, errno);
		}
	      ret = TUI_FAILURE;
	    }
	  else
	    {
	      if (s->line_charpos == 0)
		find_source_lines (s, desc);

	      if (lineNo < 1 || lineNo > s->nlines)
		{
		  close (desc);
		  printf_unfiltered (
			  "Line number %d out of range; %s has %d lines.\n",
				      lineNo, s->filename, s->nlines);
		}
	      else if (lseek (desc, s->line_charpos[lineNo - 1], 0) < 0)
		{
		  close (desc);
		  perror_with_name (s->filename);
		}
	      else
		{
		  register int offset, curLineNo, curLine, curLen, threshold;
		  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();
                  TuiSourceInfoPtr src = &srcWin->detail.sourceInfo;

                  if (srcWin->generic.title)
                    xfree (srcWin->generic.title);
                  srcWin->generic.title = xstrdup (s->filename);

                  if (src->filename)
                    xfree (src->filename);
                  src->filename = xstrdup (s->filename);

		  /* Determine the threshold for the length of the line
                     and the offset to start the display.  */
		  offset = src->horizontalOffset;
		  threshold = (lineWidth - 1) + offset;
		  stream = fdopen (desc, FOPEN_RT);
		  clearerr (stream);
		  curLine = 0;
		  curLineNo = src->startLineOrAddr.lineNo = lineNo;
		  if (offset > 0)
		    srcLine = (char *) xmalloc (
					   (threshold + 1) * sizeof (char));
		  while (curLine < nlines)
		    {
		      TuiWinElementPtr element = (TuiWinElementPtr)
		      srcWin->generic.content[curLine];

		      /* get the first character in the line */
		      c = fgetc (stream);

		      if (offset == 0)
			srcLine = ((TuiWinElementPtr)
				   srcWin->generic.content[
					curLine])->whichElement.source.line;
		      /* Init the line with the line number */
		      sprintf (srcLine, "%-6d", curLineNo);
		      curLen = strlen (srcLine);
		      i = curLen -
			((curLen / tuiDefaultTabLen ()) * tuiDefaultTabLen ());
		      while (i < tuiDefaultTabLen ())
			{
			  srcLine[curLen] = ' ';
			  i++;
			  curLen++;
			}
		      srcLine[curLen] = (char) 0;

		      /* Set whether element is the execution point and
		         whether there is a break point on it.  */
		      element->whichElement.source.lineOrAddr.lineNo =
			curLineNo;
		      element->whichElement.source.isExecPoint =
			(strcmp (((TuiWinElementPtr)
			locator->content[0])->whichElement.locator.fileName,
				 s->filename) == 0
			 && curLineNo == ((TuiWinElementPtr)
			 locator->content[0])->whichElement.locator.lineNo);
		      if (c != EOF)
			{
			  i = strlen (srcLine) - 1;
			  do
			    {
			      if ((c != '\n') &&
				  (c != '\r') && (++i < threshold))
				{
				  if (c < 040 && c != '\t')
				    {
				      srcLine[i++] = '^';
				      srcLine[i] = c + 0100;
				    }
				  else if (c == 0177)
				    {
				      srcLine[i++] = '^';
				      srcLine[i] = '?';
				    }
				  else
				    {	/* Store the charcter in the line
					   buffer.  If it is a tab, then
					   translate to the correct number of
					   chars so we don't overwrite our
					   buffer.  */
				      if (c == '\t')
					{
					  int j, maxTabLen = tuiDefaultTabLen ();

					  for (j = i - (
					       (i / maxTabLen) * maxTabLen);
					       ((j < maxTabLen) &&
						i < threshold);
					       i++, j++)
					    srcLine[i] = ' ';
					  i--;
					}
				      else
					srcLine[i] = c;
				    }
				  srcLine[i + 1] = 0;
				}
			      else
				{	/* If we have not reached EOL, then eat
                                           chars until we do  */
				  while (c != EOF && c != '\n' && c != '\r')
				    c = fgetc (stream);
				}
			    }
			  while (c != EOF && c != '\n' && c != '\r' &&
				 i < threshold && (c = fgetc (stream)));
			}
		      /* Now copy the line taking the offset into account */
		      if (strlen (srcLine) > offset)
			strcpy (((TuiWinElementPtr) srcWin->generic.content[
					curLine])->whichElement.source.line,
				&srcLine[offset]);
		      else
			((TuiWinElementPtr)
			 srcWin->generic.content[
			  curLine])->whichElement.source.line[0] = (char) 0;
		      curLine++;
		      curLineNo++;
		    }
		  if (offset > 0)
		    tuiFree (srcLine);
		  fclose (stream);
		  srcWin->generic.contentSize = nlines;
		  ret = TUI_SUCCESS;
		}
	    }
	}
    }
  return ret;
}


/* elz: this function sets the contents of the source window to empty
   except for a line in the middle with a warning message about the
   source not being available. This function is called by
   tuiEraseSourceContents, which in turn is invoked when the source files
   cannot be accessed */

void
tuiSetSourceContentNil (TuiWinInfoPtr winInfo, char *warning_string)
{
  int lineWidth;
  int nLines;
  int curr_line = 0;

  lineWidth = winInfo->generic.width - 1;
  nLines = winInfo->generic.height - 2;

  /* set to empty each line in the window, except for the one
     which contains the message */
  while (curr_line < winInfo->generic.contentSize)
    {
      /* set the information related to each displayed line
         to null: i.e. the line number is 0, there is no bp,
         it is not where the program is stopped */

      TuiWinElementPtr element =
      (TuiWinElementPtr) winInfo->generic.content[curr_line];
      element->whichElement.source.lineOrAddr.lineNo = 0;
      element->whichElement.source.isExecPoint = FALSE;
      element->whichElement.source.hasBreak = FALSE;

      /* set the contents of the line to blank */
      element->whichElement.source.line[0] = (char) 0;

      /* if the current line is in the middle of the screen, then we want to
         display the 'no source available' message in it.
         Note: the 'weird' arithmetic with the line width and height comes from
         the function tuiEraseSourceContent. We need to keep the screen and the
         window's actual contents in synch */

      if (curr_line == (nLines / 2 + 1))
	{
	  int i;
	  int xpos;
	  int warning_length = strlen (warning_string);
	  char *srcLine;

	  srcLine = element->whichElement.source.line;

	  if (warning_length >= ((lineWidth - 1) / 2))
	    xpos = 1;
	  else
	    xpos = (lineWidth - 1) / 2 - warning_length;

	  for (i = 0; i < xpos; i++)
	    srcLine[i] = ' ';

	  sprintf (srcLine + i, "%s", warning_string);

	  for (i = xpos + warning_length; i < lineWidth; i++)
	    srcLine[i] = ' ';

	  srcLine[i] = '\n';

	}			/* end if */

      curr_line++;

    }				/* end while */
}


/* Function to display source in the source window.  This function
   initializes the horizontal scroll to 0.  */
void
tuiShowSource (struct symtab *s, TuiLineOrAddress line, int noerror)
{
  srcWin->detail.sourceInfo.horizontalOffset = 0;
  tuiUpdateSourceWindowAsIs(srcWin, s, line, noerror);
}


/* Answer whether the source is currently displayed in the source window.  */
int
tuiSourceIsDisplayed (char *fname)
{
  return (srcWin->generic.contentInUse &&
	  (strcmp (((TuiWinElementPtr) (locatorWinInfoPtr ())->
		  content[0])->whichElement.locator.fileName, fname) == 0));
}


/* Scroll the source forward or backward vertically.  */
void
tuiVerticalSourceScroll (TuiScrollDirection scrollDirection,
                         int numToScroll)
{
  if (srcWin->generic.content != (OpaquePtr) NULL)
    {
      TuiLineOrAddress l;
      struct symtab *s;
      TuiWinContent content = (TuiWinContent) srcWin->generic.content;
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();

      if (cursal.symtab == (struct symtab *) NULL)
	s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
      else
	s = cursal.symtab;

      if (scrollDirection == FORWARD_SCROLL)
	{
	  l.lineNo = content[0]->whichElement.source.lineOrAddr.lineNo +
	    numToScroll;
	  if (l.lineNo > s->nlines)
	    /*line = s->nlines - winInfo->generic.contentSize + 1; */
	    /*elz: fix for dts 23398 */
	    l.lineNo = content[0]->whichElement.source.lineOrAddr.lineNo;
	}
      else
	{
	  l.lineNo = content[0]->whichElement.source.lineOrAddr.lineNo -
	    numToScroll;
	  if (l.lineNo <= 0)
	    l.lineNo = 1;
	}

      print_source_lines (s, l.lineNo, l.lineNo + 1, 0);
    }
}
@


1.16
log
@	* tui-hooks.c: Update include order.
	* tui.c: Likewise.
	* tuiCommand.c: Likewise.
	* tuiData.c: Likewise.
	* tuiDataWin.c: Likewise.
	* tuiDisassem.c: Likewise.
	* tuiGeneralWin.c: Likewise.
	* tuiIO.c: Likewise.
	* tuiLayout.c: Likewise.
	* tuiRegs.c: Likewise.
	* tuiSource.c: Likewise.
	* tuiSourceWin.c: Likewise.
	* tuiStack.c: Likewise.
	* tuiWin.c: Likewise.
@
text
@@


1.16.6.1
log
@merge mainline changes to branch
@
text
@@


1.15
log
@	* Makefile.in (tuiDisassem.o): Update dependencies.

tui:
	* tuiSource.c (tuiVerticalSourceScroll): Use get_frame_pc.
	* tuiSourceWin.c (tuiHorizontalSourceScroll): Likewise.
	* tuiStack.c (tui_get_function_from_frame): Likewise.
	(tuiShowFrameInfo): Likewise.
	* tuiWin.c (_makeVisibleWithNewHeight): Likewise.
	* tui-hooks.c (tui_selected_frame_level_changed_hook): Likewise.
	* tuiDisassem.c (tuiVerticalDisassemScroll): Likewise.
	Include "disasm.h".
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation,
a24 17
/* FIXME: cagney/2002-02-28: The GDB coding standard indicates that
   "defs.h" should be included first.  Unfortunatly some systems
   (currently Debian GNU/Linux) include the <stdbool.h> via <curses.h>
   and they clash with "bfd.h"'s definiton of true/false.  The correct
   fix is to remove true/false from "bfd.h", however, until that
   happens, hack around it by including "config.h" and <curses.h>
   first.  */

#include "config.h"
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

d39 7
@


1.14
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d343 1
a343 1
	s = find_pc_symtab (deprecated_selected_frame->pc);
@


1.13
log
@2002-09-29  Elena Zannoni  <ezannoni@@redhat.com>

	* tui.c (tui_show_source): Don't access current_source_symtab, use
	accessor function instead.  Include source.h and symtab.h
	* tuiDisassem.c (tuiShowDisassemAndUpdateSource,
	tuiVerticalDisassemScroll): Use accessor functions for current
	source line and symtab.  Include source.h.
	* tuiLayout.c (_extractDisplayStartAddr): Use accessor functions
	for current source line and symtab.  Include source.h.
	* tuiWin.c (_makeVisibleWithNewHeight): Ditto.
	* tuiSourceWin.c (tuiUpdateSourceWindowAsIs,
	tuiHorizontalSourceScroll): Ditto.
	* tuiSource.c (tuiVerticalSourceScroll): Ditto.
@
text
@d343 1
a343 1
	s = find_pc_symtab (selected_frame->pc);
@


1.13.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a55 7
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
d343 1
a343 1
	s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
@


1.13.2.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@@


1.12
log
@	* tui-out.c (tui_out_new): Clear start_of_line.
	* tuiSource.c (tuiVerticalSourceScroll): Use print_source_lines
	to update the current source line.
@
text
@d340 1
d342 1
a342 1
      if (current_source_symtab == (struct symtab *) NULL)
d345 1
a345 1
	s = current_source_symtab;
@


1.12.4.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a339 1
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();
d341 1
a341 1
      if (cursal.symtab == (struct symtab *) NULL)
d344 1
a344 1
	s = cursal.symtab;
@


1.12.4.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d343 1
a343 1
	s = find_pc_symtab (deprecated_selected_frame->pc);
@


1.12.4.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a55 7
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
d343 1
a343 1
	s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
@


1.12.4.4
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.11
log
@	* tuiSource.c (tuiSetSourceContent): Remove old breakpoint code.
	(_hasBreak): Remove.
	(tuiShowSource): Fix comment indentation.
	(tuiSourceIsDisplayed): Likewise.
	(tuiVerticalSourceScroll): Likewise.
@
text
@d362 2
a363 2
      if (identify_source_line (s, l.lineNo, 0, -1) == 1)
        tuiUpdateSourceWindowAsIs (srcWin, s, l, FALSE);
@


1.10
log
@	* tuiSourceWin.c (tuiSetHasBreakAt): Use filename for breakpoint
	comparison; cleanup.
	* tuiSource.c (tuiSetSourceContent): Set window title and filename.
	* tuiGeneralWin.c (boxWin): Print optional title on top of window.
	* tuiData.h (TuiSourceInfo): Add filename member.
	(TuiGenWinInfo): Add title member.
	* tuiData.c (initGenericPart): Clear title.
	(freeWindow): Free title and filename; remove unused locals.
	(initWinInfo): Clear filename.
	(tuiDelWindow): Free it; remove unused locals.
@
text
@d57 1
a57 11
/*****************************************
** STATIC LOCAL FUNCTIONS FORWARD DECLS    **
******************************************/

static struct breakpoint *_hasBreak (char *, int);


/*
   ** tuiSetSourceContent().
   **    Function to display source in the source window.
 */
d72 2
a73 4
	  /*
	     ** Take hilite (window border) into account, when calculating
	     ** the number of lines
	   */
a131 1
		      struct breakpoint *bp;
d153 2
a154 4
		      /*
		         ** Set whether element is the execution point and
		         ** whether there is a break point on it.
		       */
a162 5
		      bp = _hasBreak (s->filename, curLineNo);
		      element->whichElement.source.hasBreak =
			(bp != (struct breakpoint *) NULL &&
			 (!element->whichElement.source.isExecPoint ||
			  (bp->disposition != disp_del || bp->hit_count <= 0)));
d182 5
a186 7
				    {	/*
					   ** Store the charcter in the line
					   ** buffer.  If it is a tab, then
					   ** translate to the correct number of
					   ** chars so we don't overwrite our
					   ** buffer.
					 */
d205 2
a206 4
				{	/*
					   ** if we have not reached EOL, then eat
					   ** chars until we do
					 */
d236 1
a236 1
}				/* tuiSetSourceContent */
d307 1
a307 4

}				/*tuiSetSourceContentNil */


d310 2
a311 5
/*
   ** tuiShowSource().
   **        Function to display source in the source window.  This function
   **        initializes the horizontal scroll to 0.
 */
d317 1
a318 2
  return;
}				/* tuiShowSource */
d320 1
a320 5

/*
   ** tuiSourceIsDisplayed().
   **        Answer whether the source is currently displayed in the source window.
 */
d327 1
a327 1
}				/* tuiSourceIsDisplayed */
d330 1
a330 4
/*
   ** tuiVerticalSourceScroll().
   **      Scroll the source forward or backward vertically
 */
d365 1
a365 33

  return;
}				/* tuiVerticalSourceScroll */


/*****************************************
** STATIC LOCAL FUNCTIONS                 **
******************************************/

/*
   ** _hasBreak().
   **        Answer whether there is a break point at the input line in
   **        the source file indicated
 */
static struct breakpoint *
_hasBreak (char *sourceFileName, int lineNo)
{
  struct breakpoint *bpWithBreak = (struct breakpoint *) NULL;
  struct breakpoint *bp;
  extern struct breakpoint *breakpoint_chain;


  for (bp = breakpoint_chain;
       (bp != (struct breakpoint *) NULL &&
	bpWithBreak == (struct breakpoint *) NULL);
       bp = bp->next)
    if (bp->source_file
	&& (strcmp (sourceFileName, bp->source_file) == 0)
	&& (lineNo == bp->line_number))
      bpWithBreak = bp;

  return bpWithBreak;
}				/* _hasBreak */
@


1.9
log
@Add FIXME explaining include problem.
@
text
@a57 7
** EXTERNAL DATA DECLS                    **
******************************************/
extern int current_source_line;
extern struct symtab *current_source_symtab;


/*****************************************
a63 13
/*****************************************
** STATIC LOCAL DATA                    **
******************************************/


/*****************************************
** PUBLIC FUNCTIONS                     **
******************************************/

/*********************************
** SOURCE/DISASSEM  FUNCTIONS    **
*********************************/

d77 1
a77 1
      register char *srcLine;
d119 13
a131 5
		  /*
		     ** Determine the threshold for the length of the line
		     ** and the offset to start the display
		   */
		  offset = srcWin->detail.sourceInfo.horizontalOffset;
d136 1
a136 2
		  curLineNo =
		    srcWin->detail.sourceInfo.startLineOrAddr.lineNo = lineNo;
@


1.9.8.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d58 7
d71 13
d97 1
a97 1
      register char *srcLine = 0;
d139 5
a143 13
                  TuiSourceInfoPtr src = &srcWin->detail.sourceInfo;

                  if (srcWin->generic.title)
                    xfree (srcWin->generic.title);
                  srcWin->generic.title = xstrdup (s->filename);

                  if (src->filename)
                    xfree (src->filename);
                  src->filename = xstrdup (s->filename);

		  /* Determine the threshold for the length of the line
                     and the offset to start the display.  */
		  offset = src->horizontalOffset;
d148 2
a149 1
		  curLineNo = src->startLineOrAddr.lineNo = lineNo;
@


1.9.8.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d57 11
a67 1
/* Function to display source in the source window.  */
d82 4
a85 2
	  /* Take hilite (window border) into account, when calculating
	     the number of lines  */
d144 1
d166 4
a169 2
		      /* Set whether element is the execution point and
		         whether there is a break point on it.  */
d178 5
d202 7
a208 5
				    {	/* Store the charcter in the line
					   buffer.  If it is a tab, then
					   translate to the correct number of
					   chars so we don't overwrite our
					   buffer.  */
d227 4
a230 2
				{	/* If we have not reached EOL, then eat
                                           chars until we do  */
d260 1
a260 1
}
d331 2
a332 1
}
d335 7
a341 2
/* Function to display source in the source window.  This function
   initializes the horizontal scroll to 0.  */
d347 3
a349 1
}
d352 4
a355 1
/* Answer whether the source is currently displayed in the source window.  */
d362 1
a362 1
}
d365 4
a368 1
/* Scroll the source forward or backward vertically.  */
a377 1
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();
d379 1
a379 1
      if (cursal.symtab == (struct symtab *) NULL)
d382 1
a382 1
	s = cursal.symtab;
d400 7
d408 28
a435 3
      print_source_lines (s, l.lineNo, l.lineNo + 1, 0);
    }
}
@


1.8
log
@2002-02-08  Daniel Jacobowitz  <drow@@mvista.com>

        * utils.c: Include <curses.h> before "bfd.h".
        * tui/tui-hooks.c: Likewise.
        * tui/tui.c: Likewise.
        * tui/tuiCommand.c: Likewise.
        * tui/tuiData.c: Likewise.
        * tui/tuiDataWin.c: Likewise.
        * tui/tuiDisassem.c: Likewise.
        * tui/tuiGeneralWin.c: Likewise.
        * tui/tuiIO.c: Likewise.
        * tui/tuiLayout.c: Likewise.
        * tui/tuiRegs.c: Likewise.
        * tui/tuiSource.c: Likewise.
        * tui/tuiSourceWin.c: Likewise.
        * tui/tuiStack.c: Likewise.
        * tui/tuiWin.c: Likewise.
@
text
@d2 4
a5 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d25 8
a32 1
/* If we need <curses.h>, we must include it before we get "bfd.h".  */
@


1.7
log
@	The following changes avoid polluting global namespace with the
	`enable' and `disable' identifiers, because some platforms define
	in their system headers symbols with global scope that go by those
	names.

	* breakpoint.h (enum enable_state): Rename from `enum enable'.
	Also rename all the enum members to have the "bp_" prefix.
	(struct breakpoint): Rename the `enable' member to `enable_state'.
	(enum bpdisp): Rename all members to have the "disp_" prefix.

	* breakpoint.c: All users of `enum enable' and `enum bpdisp'
	changed.
	(args_for_catchpoint_enable): Rename the `enable' member to
	`enable_p'.  All users changed.

	* tracepoint.h (enum enable): Remove.
	(struct tracepoint): The member `enabled' is now `int enabled_p'.

	* tracepoint.c: All users of the `enabled' member changed.

	* printcmd.c (struct display): The `status' member is now an int.

	* memattr.h (struct mem_region): Rename the `status' member to
	`enabled_p'.
	(enum enable): Remove.

	* memattr.c: Change all users of the `status' member of struct
	mem_region to use `enabled_p' instead.

	* infcmd.c (run_stack_dummy): Use disp_del instead of del.

	* go32-nat.c: Remove the kludgey work-around for conflicts between
	<dos.h> and "breakpoint.h".
	* tui/tuiSourceWin.c: Use disp_del instead of del.

	* tui/tuiSource.c: Use disp_del instead of del.

	* tui/tuiDisassem.c: Use disp_del instead of del.
@
text
@d22 10
@


1.6
log
@	* tuiWin.c (_parseScrollingArgs): Fix uninitialized variable.
	(_makeVisibleWithNewHeight): Use TuiLineOrAddress type.

	* tuiStack.c (tuiShowFrameInfo): Use TuiLineOrAddress type.
	(tui_vUpdateLocatorFilename): Remove.
	* tuiStack.h: Update prototypes.

	* tuiSourceWin.c (tuiAddrIsDisplayed): New function.
	(tuiLineIsDisplayed): Split for address and line.
	(tuiUpdateSourceWindow): Use TuiLineOrAddress type.
	(tuiUpdateSourceWindowAsIs): Likewise.
	(tuiUpdateSourceWindowsWithAddr): Likewise.
	(tuiUpdateSourceWindowsWithLine): Likewise.
	(tuiHorizontalSourceScroll): Likewise.
	(tuiSetIsExecPointAt): Likewise.
	(tuiUpdateOnEnd): Likewise.
	* tuiSourceWin.h: Update prototypes.

	* tuiSource.c (tuiVerticalSourceScroll): Use TuiLineOrAddress type.
	(tuiShowSource): Likewise.
	(tuiVerticalSourceScroll): Likewise.
	* tuiSource.h (tuiShowSource): Update prototype.

	* tuiDisassem.c (tuiSetDisassemContent): Use CORE_ADDR for address.
	(tuiShowDisassem): Use TuiLineOrAddress type.
	(tuiShowDisassemAndUpdateSource): Likewise.
	(tuiVerticalDisassemScroll): Likewise.
	(tuiShowDisassemAsIs): Remove.
	* tuiDisassem.h (tuiSetDisassemContent): Update prototype.

	* tuiData.c (initWinInfo): Use CORE_ADDR for address.
	(clearWinDetail): Likewise.
	(displayableWinContentOf): Fix address conversion.
	(tuiNextWin): Fix crash when the window is not yet created.
	(partialWinByName): Likewise.
@
text
@d175 1
a175 1
			  (bp->disposition != del || bp->hit_count <= 0)));
@


1.6.2.1
log
@	The following changes avoid polluting global namespace with the
	`enable' and `disable' identifiers, because some platforms define
	in their system headers symbols with global scope that go by those
	names.

	* breakpoint.h (enum enable_state): Rename from `enum enable'.
	Also rename all the enum members to have the "bp_" prefix.
	(struct breakpoint): Rename the `enable' member to `enable_state'.
	(enum bpdisp): Rename all members to have the "disp_" prefix.

	* breakpoint.c: All users of `enum enable' and `enum bpdisp'
	changed.
	(args_for_catchpoint_enable): Rename the `enable' member to
	`enable_p'.  All users changed.

	* tracepoint.h (enum enable): Remove.
	(struct tracepoint): The member `enabled' is now `int enabled_p'.

	* tracepoint.c: All users of the `enabled' member changed.

	* printcmd.c (struct display): The `status' member is now an int.

	* memattr.h (struct mem_region): Rename the `status' member to
	`enabled_p'.
	(enum enable): Remove.

	* memattr.c: Change all users of the `status' member of struct
	mem_region to use `enabled_p' instead.

	* infcmd.c (run_stack_dummy): Use disp_del instead of del.

	* go32-nat.c: Remove the kludgey work-around for conflicts between
	<dos.h> and "breakpoint.h".

	* tui/tuiSourceWin.c: Use disp_del instead of del.

	* tui/tuiSource.c: Use disp_del instead of del.

	* tui/tuiDisassem.c: Use disp_del instead of del.
@
text
@d175 1
a175 1
			  (bp->disposition != disp_del || bp->hit_count <= 0)));
@


1.5
log
@	* tuiStack.c: Add missing includes.
	(tuiShowFrameInfo): Don't crash when there is no symbol table
	associated with the pc.
	* tuiSource.c (_hasBreak): Check for null source file.
	* tuiWin.c (tuiRefreshAll): Check for null winList[type].
	(_tuiSetFocus): Check for null dataWin.
	* tuiGeneralWin.c (refreshAll): Check for null list[type].
@
text
@d28 1
d336 1
a336 1
tuiShowSource (struct symtab *s, Opaque line, int noerror)
d339 1
a339 1
  m_tuiShowSourceAsIs (s, line, noerror);
d363 2
a364 1
tuiVerticalSourceScroll (TuiScrollDirection scrollDirection, int numToScroll)
d368 1
a368 2
      int line;
      Opaque addr;
d379 1
a379 1
	  line = content[0]->whichElement.source.lineOrAddr.lineNo +
d381 1
a381 1
	  if (line > s->nlines)
d384 1
a384 1
	    line = content[0]->whichElement.source.lineOrAddr.lineNo;
d388 1
a388 1
	  line = content[0]->whichElement.source.lineOrAddr.lineNo -
d390 2
a391 2
	  if (line <= 0)
	    line = 1;
d393 2
a394 1
      tuiUpdateSourceWindowAsIs (srcWin, s, (Opaque) line, FALSE);
@


1.4
log
@	* tuiWin.c, tui.c, tuiCommand.c: Use ansi prototype.
	tuiIO.c, tuiData.c: Likewise.
	tuiDataWin.c, tuiDisassem.c: Likewise.
	tuiGeneralWin.c, tuiLayout.c: Likewise.
	tuiRegs.c, tuiSource.c: Likewise.
	tuiSouceWin.c, tuiStack.c: Likewise.
@
text
@d420 3
a422 2
    if ((strcmp (sourceFileName, bp->source_file) == 0) &&
	(lineNo == bp->line_number))
@


1.3
log
@	* tuiWin.c, tuiWin.h, tui.c, tui.h, tuiCommand.c: Add FSF copyright.
	tuiCommand.h, tuiIO.c, tuiIO.h, tuiData.h, tuiData.c: Likewise.
	tuiDataWin.c, tuiDataWin.h, tuiDisassem.c, tuiDisassem.h: Likewise.
	tuiGeneralWin.c, tuiGeneralWin.h, tuiLayout.c, tuiLayout.h: Likewise.
	tuiRegs.c, tuiRegs.h, tuiSource.c, tuiSource.h: Likewise.
	tuiSouceWin.c, tuiSourceWin.h, tuiStack.c, tuiStack.h: Likewise.
@
text
@d68 1
a68 11
#ifdef __STDC__
tuiSetSourceContent (
		      struct symtab *s,
		      int lineNo,
		      int noerror)
#else
tuiSetSourceContent (s, lineNo, noerror)
     struct symtab *s;
     int lineNo;
     int noerror;
#endif
d262 1
a262 9
#ifdef __STDC__
tuiSetSourceContentNil (
			 TuiWinInfoPtr winInfo,
			 char *warning_string)
#else
tuiSetSourceContentNil (winInfo, warning_string)
     TuiWinInfoPtr winInfo;
     char *warning_string;
#endif
d335 1
a335 11
#ifdef __STDC__
tuiShowSource (
		struct symtab *s,
		Opaque line,
		int noerror)
#else
tuiShowSource (s, line, noerror)
     struct symtab *s;
     Opaque line;
     int noerror;
#endif
d349 1
a349 7
#ifdef __STDC__
tuiSourceIsDisplayed (
		       char *fname)
#else
tuiSourceIsDisplayed (fname)
     char *fname;
#endif
d362 1
a362 9
#ifdef __STDC__
tuiVerticalSourceScroll (
			  TuiScrollDirection scrollDirection,
			  int numToScroll)
#else
tuiVerticalSourceScroll (scrollDirection, numToScroll)
     TuiScrollDirection scrollDirection;
     int numToScroll;
#endif
d409 1
a409 9
#ifdef __STDC__
_hasBreak (
	    char *sourceFileName,
	    int lineNo)
#else
_hasBreak (sourceFileName, lineNo)
     char *sourceFileName;
     int lineNo;
#endif
@


1.2
log
@PARAMS removal.
@
text
@d1 20
a20 4
/*
   ** tuiSource.c
   **         This module contains functions for displaying source in the source window
 */
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
** tuiSource.c
**         This module contains functions for displaying source in the source window
*/
d11 1
a20 7
** EXTERNAL FUNCTION DECLS                **
******************************************/

extern int open_source_file PARAMS ((struct symtab *));
extern void find_source_lines PARAMS ((struct symtab *, int));

/*****************************************
d31 1
a31 1
static struct breakpoint *_hasBreak PARAMS ((char *, int));
d48 3
a50 3
** tuiSetSourceContent().
**    Function to display source in the source window.
*/
d76 3
a78 3
            ** Take hilite (window border) into account, when calculating
            ** the number of lines
            */
d113 3
a115 3
                    ** Determine the threshold for the length of the line
                    ** and the offset to start the display
                    */
d153 3
a155 3
                        ** Set whether element is the execution point and
                        ** whether there is a break point on it.
                        */
d189 6
a194 6
                                        ** Store the charcter in the line
                                        ** buffer.  If it is a tab, then
                                        ** translate to the correct number of
                                        ** chars so we don't overwrite our
                                        ** buffer.
                                        */
d214 3
a216 3
                                    ** if we have not reached EOL, then eat
                                    ** chars until we do
                                    */
d253 1
a253 1
   cannot be accessed*/
d274 1
a274 1
    which contains the message*/
d278 2
a279 2
     to null: i.e. the line number is 0, there is no bp,
     it is not where the program is stopped */
d287 1
a287 1
      /* set the contents of the line to blank*/
d291 4
a294 4
     display the 'no source available' message in it.
     Note: the 'weird' arithmetic with the line width and height comes from
     the function tuiEraseSourceContent. We need to keep the screen and the
     window's actual contents in synch */
d324 1
a324 1
    }				/* end while*/
d326 1
a326 1
}				/*tuiSetSourceContentNil*/
d332 4
a335 4
** tuiShowSource().
**        Function to display source in the source window.  This function
**        initializes the horizontal scroll to 0.
*/
d357 3
a359 3
** tuiSourceIsDisplayed().
**        Answer whether the source is currently displayed in the source window.
*/
d376 3
a378 3
** tuiVerticalSourceScroll().
**      Scroll the source forward or backward vertically
*/
d407 2
a408 2
	    /*line = s->nlines - winInfo->generic.contentSize + 1;*/
	    /*elz: fix for dts 23398*/
d430 4
a433 4
** _hasBreak().
**        Answer whether there is a break point at the input line in
**        the source file indicated
*/
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d2 3
a4 3
   ** tuiSource.c
   **         This module contains functions for displaying source in the source window
 */
d54 3
a56 3
   ** tuiSetSourceContent().
   **    Function to display source in the source window.
 */
d82 3
a84 3
	     ** Take hilite (window border) into account, when calculating
	     ** the number of lines
	   */
d119 3
a121 3
		     ** Determine the threshold for the length of the line
		     ** and the offset to start the display
		   */
d159 3
a161 3
		         ** Set whether element is the execution point and
		         ** whether there is a break point on it.
		       */
d195 6
a200 6
					   ** Store the charcter in the line
					   ** buffer.  If it is a tab, then
					   ** translate to the correct number of
					   ** chars so we don't overwrite our
					   ** buffer.
					 */
d220 3
a222 3
					   ** if we have not reached EOL, then eat
					   ** chars until we do
					 */
d259 1
a259 1
   cannot be accessed */
d280 1
a280 1
     which contains the message */
d284 2
a285 2
         to null: i.e. the line number is 0, there is no bp,
         it is not where the program is stopped */
d293 1
a293 1
      /* set the contents of the line to blank */
d297 4
a300 4
         display the 'no source available' message in it.
         Note: the 'weird' arithmetic with the line width and height comes from
         the function tuiEraseSourceContent. We need to keep the screen and the
         window's actual contents in synch */
d330 1
a330 1
    }				/* end while */
d332 1
a332 1
}				/*tuiSetSourceContentNil */
d338 4
a341 4
   ** tuiShowSource().
   **        Function to display source in the source window.  This function
   **        initializes the horizontal scroll to 0.
 */
d363 3
a365 3
   ** tuiSourceIsDisplayed().
   **        Answer whether the source is currently displayed in the source window.
 */
d382 3
a384 3
   ** tuiVerticalSourceScroll().
   **      Scroll the source forward or backward vertically
 */
d413 2
a414 2
	    /*line = s->nlines - winInfo->generic.contentSize + 1; */
	    /*elz: fix for dts 23398 */
d436 4
a439 4
   ** _hasBreak().
   **        Answer whether there is a break point at the input line in
   **        the source file indicated
 */
@


1.1.1.3
log
@import gdb-1999-09-21
@
text
@a10 1
#include "source.h"
d18 7
@


