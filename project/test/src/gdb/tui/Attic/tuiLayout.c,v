head	1.20;
access;
symbols
	drow-cplus-merge-20040113:1.19
	drow-cplus-merge-20031224:1.19
	drow-cplus-merge-20031220:1.19
	carlton_dictionary-20031215-merge:1.19
	drow-cplus-merge-20031214:1.19
	carlton-dictionary-20031111-merge:1.19
	gdb_6_0-2003-10-04-release:1.19
	kettenis_sparc-20030918-branch:1.19.0.8
	kettenis_sparc-20030918-branchpoint:1.19
	carlton_dictionary-20030917-merge:1.19
	ezannoni_pie-20030916-branchpoint:1.19
	ezannoni_pie-20030916-branch:1.19.0.6
	cagney_x86i386-20030821-branch:1.19.0.4
	cagney_x86i386-20030821-branchpoint:1.19
	carlton_dictionary-20030805-merge:1.19
	carlton_dictionary-20030627-merge:1.19
	gdb_6_0-branch:1.19.0.2
	gdb_6_0-2003-06-23-branchpoint:1.19
	jimb-ppc64-linux-20030613-branch:1.18.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.18
	cagney_convert-20030606-branch:1.18.0.32
	cagney_convert-20030606-branchpoint:1.18
	cagney_writestrings-20030508-branch:1.18.0.30
	cagney_writestrings-20030508-branchpoint:1.18
	jimb-ppc64-linux-20030528-branch:1.18.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.18
	carlton_dictionary-20030523-merge:1.18
	cagney_fileio-20030521-branch:1.18.0.26
	cagney_fileio-20030521-branchpoint:1.18
	kettenis_i386newframe-20030517-mergepoint:1.18
	jimb-ppc64-linux-20030509-branch:1.18.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.18
	kettenis_i386newframe-20030504-mergepoint:1.18
	carlton_dictionary-20030430-merge:1.18
	kettenis_i386newframe-20030419-branch:1.18.0.22
	kettenis_i386newframe-20030419-branchpoint:1.18
	carlton_dictionary-20030416-merge:1.18
	cagney_frameaddr-20030409-mergepoint:1.18
	kettenis_i386newframe-20030406-branch:1.18.0.20
	kettenis_i386newframe-20030406-branchpoint:1.18
	cagney_frameaddr-20030403-branchpoint:1.18
	cagney_frameaddr-20030403-branch:1.18.0.18
	cagney_framebase-20030330-mergepoint:1.18
	cagney_framebase-20030326-branch:1.18.0.16
	cagney_framebase-20030326-branchpoint:1.18
	cagney_lazyid-20030317-branch:1.18.0.14
	cagney_lazyid-20030317-branchpoint:1.18
	kettenis-i386newframe-20030316-mergepoint:1.18
	offbyone-20030313-branch:1.18.0.12
	offbyone-20030313-branchpoint:1.18
	kettenis-i386newframe-20030308-branch:1.18.0.10
	kettenis-i386newframe-20030308-branchpoint:1.18
	carlton_dictionary-20030305-merge:1.18
	cagney_offbyone-20030303-branch:1.18.0.8
	cagney_offbyone-20030303-branchpoint:1.18
	carlton_dictionary-20030207-merge:1.18
	interps-20030203-mergepoint:1.18
	interps-20030202-branch:1.18.0.6
	interps-20030202-branchpoint:1.18
	cagney-unwind-20030108-branch:1.18.0.4
	cagney-unwind-20030108-branchpoint:1.18
	carlton_dictionary-20021223-merge:1.18
	gdb_5_3-2002-12-12-release:1.17
	carlton_dictionary-20021115-merge:1.18
	kseitz_interps-20021105-merge:1.18
	kseitz_interps-20021103-merge:1.18
	drow-cplus-merge-20021020:1.18
	drow-cplus-merge-20021025:1.18
	carlton_dictionary-20021025-merge:1.18
	carlton_dictionary-20021011-merge:1.18
	drow-cplus-branch:1.18.0.2
	drow-cplus-branchpoint:1.18
	kseitz_interps-20020930-merge:1.18
	carlton_dictionary-20020927-merge:1.17
	carlton_dictionary-branch:1.17.0.6
	carlton_dictionary-20020920-branchpoint:1.17
	gdb_5_3-branch:1.17.0.4
	gdb_5_3-2002-09-04-branchpoint:1.17
	kseitz_interps-20020829-merge:1.17
	cagney_sysregs-20020825-branch:1.17.0.2
	cagney_sysregs-20020825-branchpoint:1.17
	readline_4_3-import-branch:1.15.0.10
	readline_4_3-import-branchpoint:1.15
	gdb_5_2_1-2002-07-23-release:1.15
	kseitz_interps-20020528-branch:1.15.0.8
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.15.0.6
	cagney_regbuf-20020515-branchpoint:1.15
	jimb-macro-020506-branch:1.15.0.4
	jimb-macro-020506-branchpoint:1.15
	gdb_5_2-2002-04-29-release:1.15
	gdb_5_2-branch:1.15.0.2
	gdb_5_2-2002-03-03-branchpoint:1.15
	gdb_5_1_1-2002-01-24-release:1.13
	gdb_5_1_0_1-2002-01-03-release:1.13
	cygnus_cvs_20020108_pre:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.13.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.13
	gdb_5_1-2001-11-21-release:1.13
	gdb_s390-2001-09-26-branch:1.13.0.4
	gdb_s390-2001-09-26-branchpoint:1.13
	gdb_5_1-2001-07-29-branch:1.13.0.2
	gdb_5_1-2001-07-29-branchpoint:1.13
	dberlin-typesystem-branch:1.5.0.2
	dberlin-typesystem-branchpoint:1.5
	gdb-post-ptid_t-2001-05-03:1.5
	gdb-pre-ptid_t-2001-05-03:1.5
	insight-precleanup-2001-01-01:1.5
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.20
date	2004.01.19.04.31.52;	author cagney;	state dead;
branches;
next	1.19;

1.19
date	2003.06.22.15.21.38;	author drow;	state Exp;
branches
	1.19.6.1;
next	1.18;

1.18
date	2002.09.30.00.52.27;	author ezannoni;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2002.08.24.15.25.25;	author ciceron;	state Exp;
branches
	1.17.6.1;
next	1.16;

1.16
date	2002.08.24.12.28.32;	author ciceron;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.01.06.19.28;	author cagney;	state Exp;
branches
	1.15.8.1;
next	1.14;

1.14
date	2002.02.08.15.54.32;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.20.22.26.54;	author ciceron;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.19.22.47.46;	author ciceron;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.18.22.03.22;	author ciceron;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.18.20.59.00;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.17.22.22.40;	author ciceron;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.17.21.37.18;	author ciceron;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.14.19.31.09;	author ciceron;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.14.19.01.25;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.01.01.51;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.20.07.13.39;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.42;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.13;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.19.23;	author jsm;	state Exp;
branches;
next	;

1.15.8.1
date	2002.08.30.22.52.52;	author kseitz;	state Exp;
branches;
next	1.15.8.2;

1.15.8.2
date	2002.10.01.00.46.35;	author kseitz;	state Exp;
branches;
next	;

1.17.6.1
date	2002.10.11.22.23.03;	author carlton;	state Exp;
branches;
next	1.17.6.2;

1.17.6.2
date	2003.06.27.21.50.21;	author carlton;	state Exp;
branches;
next	1.17.6.3;

1.17.6.3
date	2004.01.26.19.11.45;	author carlton;	state dead;
branches;
next	;

1.18.2.1
date	2003.12.14.20.27.59;	author drow;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2004.02.09.19.43.58;	author drow;	state dead;
branches;
next	;

1.19.6.1
date	2004.03.23.20.09.16;	author ezannoni;	state dead;
branches;
next	;


desc
@@


1.20
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@/* TUI layout window management.

   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "command.h"
#include "symtab.h"
#include "frame.h"
#include "source.h"
#include <ctype.h>

#include "tui.h"
#include "tuiData.h"
#include "tuiDataWin.h"
#include "tuiGeneralWin.h"
#include "tuiStack.h"
#include "tuiRegs.h"
#include "tuiWin.h"
#include "tuiSourceWin.h"
#include "tuiDisassem.h"

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

/*******************************
** Static Local Decls
********************************/
static void showLayout (TuiLayoutType);
static void _initGenWinInfo (TuiGenWinInfoPtr, TuiWinType, int, int, int, int);
static void _initAndMakeWin (Opaque *, TuiWinType, int, int, int, int, int);
static void _showSourceOrDisassemAndCommand (TuiLayoutType);
static void _makeSourceOrDisassemWindow (TuiWinInfoPtr *, TuiWinType, int, int);
static void _makeCommandWindow (TuiWinInfoPtr *, int, int);
static void _makeSourceWindow (TuiWinInfoPtr *, int, int);
static void _makeDisassemWindow (TuiWinInfoPtr *, int, int);
static void _makeDataWindow (TuiWinInfoPtr *, int, int);
static void _showSourceCommand (void);
static void _showDisassemCommand (void);
static void _showSourceDisassemCommand (void);
static void _showData (TuiLayoutType);
static TuiLayoutType _nextLayout (void);
static TuiLayoutType _prevLayout (void);
static void _tuiLayout_command (char *, int);
static void _tuiToggleLayout_command (char *, int);
static void _tuiToggleSplitLayout_command (char *, int);
static CORE_ADDR _extractDisplayStartAddr (void);
static void _tuiHandleXDBLayout (TuiLayoutDefPtr);


/***************************************
** DEFINITIONS
***************************************/

#define LAYOUT_USAGE     "Usage: layout prev | next | <layout_name> \n"

/* Show the screen layout defined.  */
static void
showLayout (TuiLayoutType layout)
{
  TuiLayoutType curLayout = currentLayout ();

  if (layout != curLayout)
    {
      /*
         ** Since the new layout may cause changes in window size, we
         ** should free the content and reallocate on next display of
         ** source/asm
       */
      freeAllSourceWinsContent ();
      clearSourceWindows ();
      if (layout == SRC_DATA_COMMAND || layout == DISASSEM_DATA_COMMAND)
	{
	  _showData (layout);
	  refreshAll (winList);
	}
      else
	{
	  /* First make the current layout be invisible */
	  m_allBeInvisible ();
	  m_beInvisible (locatorWinInfoPtr ());

	  switch (layout)
	    {
	      /* Now show the new layout */
	    case SRC_COMMAND:
	      _showSourceCommand ();
	      addToSourceWindows (srcWin);
	      break;
	    case DISASSEM_COMMAND:
	      _showDisassemCommand ();
	      addToSourceWindows (disassemWin);
	      break;
	    case SRC_DISASSEM_COMMAND:
	      _showSourceDisassemCommand ();
	      addToSourceWindows (srcWin);
	      addToSourceWindows (disassemWin);
	      break;
	    default:
	      break;
	    }
	}
    }
}


/*
   ** tuiSetLayout()
   **    Function to set the layout to SRC_COMMAND, DISASSEM_COMMAND,
   **    SRC_DISASSEM_COMMAND, SRC_DATA_COMMAND, or DISASSEM_DATA_COMMAND.
   **    If the layout is SRC_DATA_COMMAND, DISASSEM_DATA_COMMAND, or
   **    UNDEFINED_LAYOUT, then the data window is populated according
   **    to regsDisplayType.
 */
TuiStatus
tuiSetLayout (TuiLayoutType layoutType,
              TuiRegisterDisplayType regsDisplayType)
{
  TuiStatus status = TUI_SUCCESS;

  if (layoutType != UNDEFINED_LAYOUT || regsDisplayType != TUI_UNDEFINED_REGS)
    {
      TuiLayoutType curLayout = currentLayout (), newLayout = UNDEFINED_LAYOUT;
      int regsPopulate = FALSE;
      CORE_ADDR addr = _extractDisplayStartAddr ();
      TuiWinInfoPtr newWinWithFocus = (TuiWinInfoPtr) NULL, winWithFocus = tuiWinWithFocus ();
      TuiLayoutDefPtr layoutDef = tuiLayoutDef ();


      if (layoutType == UNDEFINED_LAYOUT &&
	  regsDisplayType != TUI_UNDEFINED_REGS)
	{
	  if (curLayout == SRC_DISASSEM_COMMAND)
	    newLayout = DISASSEM_DATA_COMMAND;
	  else if (curLayout == SRC_COMMAND || curLayout == SRC_DATA_COMMAND)
	    newLayout = SRC_DATA_COMMAND;
	  else if (curLayout == DISASSEM_COMMAND ||
		   curLayout == DISASSEM_DATA_COMMAND)
	    newLayout = DISASSEM_DATA_COMMAND;
	}
      else
	newLayout = layoutType;

      regsPopulate = (newLayout == SRC_DATA_COMMAND ||
		      newLayout == DISASSEM_DATA_COMMAND ||
		      regsDisplayType != TUI_UNDEFINED_REGS);
      if (newLayout != curLayout || regsDisplayType != TUI_UNDEFINED_REGS)
	{
	  if (newLayout != curLayout)
	    {
	      showLayout (newLayout);
	      /*
	         ** Now determine where focus should be
	       */
	      if (winWithFocus != cmdWin)
		{
		  switch (newLayout)
		    {
		    case SRC_COMMAND:
		      tuiSetWinFocusTo (srcWin);
		      layoutDef->displayMode = SRC_WIN;
		      layoutDef->split = FALSE;
		      break;
		    case DISASSEM_COMMAND:
		      /* the previous layout was not showing
		         ** code. this can happen if there is no
		         ** source available:
		         ** 1. if the source file is in another dir OR
		         ** 2. if target was compiled without -g
		         ** We still want to show the assembly though!
		       */
		      addr = tuiGetBeginAsmAddress ();
		      tuiSetWinFocusTo (disassemWin);
		      layoutDef->displayMode = DISASSEM_WIN;
		      layoutDef->split = FALSE;
		      break;
		    case SRC_DISASSEM_COMMAND:
		      /* the previous layout was not showing
		         ** code. this can happen if there is no
		         ** source available:
		         ** 1. if the source file is in another dir OR
		         ** 2. if target was compiled without -g
		         ** We still want to show the assembly though!
		       */
		      addr = tuiGetBeginAsmAddress ();
		      if (winWithFocus == srcWin)
			tuiSetWinFocusTo (srcWin);
		      else
			tuiSetWinFocusTo (disassemWin);
		      layoutDef->split = TRUE;
		      break;
		    case SRC_DATA_COMMAND:
		      if (winWithFocus != dataWin)
			tuiSetWinFocusTo (srcWin);
		      else
			tuiSetWinFocusTo (dataWin);
		      layoutDef->displayMode = SRC_WIN;
		      layoutDef->split = FALSE;
		      break;
		    case DISASSEM_DATA_COMMAND:
		      /* the previous layout was not showing
		         ** code. this can happen if there is no
		         ** source available:
		         ** 1. if the source file is in another dir OR
		         ** 2. if target was compiled without -g
		         ** We still want to show the assembly though!
		       */
		      addr = tuiGetBeginAsmAddress ();
		      if (winWithFocus != dataWin)
			tuiSetWinFocusTo (disassemWin);
		      else
			tuiSetWinFocusTo (dataWin);
		      layoutDef->displayMode = DISASSEM_WIN;
		      layoutDef->split = FALSE;
		      break;
		    default:
		      break;
		    }
		}
	      if (newWinWithFocus != (TuiWinInfoPtr) NULL)
		tuiSetWinFocusTo (newWinWithFocus);
	      /*
	         ** Now update the window content
	       */
	      if (!regsPopulate &&
		  (newLayout == SRC_DATA_COMMAND ||
		   newLayout == DISASSEM_DATA_COMMAND))
		tuiDisplayAllData ();

	      tuiUpdateSourceWindowsWithAddr (addr);
	    }
	  if (regsPopulate)
	    {
	      layoutDef->regsDisplayType =
		(regsDisplayType == TUI_UNDEFINED_REGS ?
		 TUI_GENERAL_REGS : regsDisplayType);
	      tuiShowRegisters (layoutDef->regsDisplayType);
	    }
	}
    }
  else
    status = TUI_FAILURE;

  return status;
}

/*
   ** tuiAddWinToLayout().
   **        Add the specified window to the layout in a logical way.
   **        This means setting up the most logical layout given the
   **        window to be added.
 */
void
tuiAddWinToLayout (TuiWinType type)
{
  TuiLayoutType curLayout = currentLayout ();

  switch (type)
    {
    case SRC_WIN:
      if (curLayout != SRC_COMMAND &&
	  curLayout != SRC_DISASSEM_COMMAND &&
	  curLayout != SRC_DATA_COMMAND)
	{
	  clearSourceWindowsDetail ();
	  if (curLayout == DISASSEM_DATA_COMMAND)
	    showLayout (SRC_DATA_COMMAND);
	  else
	    showLayout (SRC_COMMAND);
	}
      break;
    case DISASSEM_WIN:
      if (curLayout != DISASSEM_COMMAND &&
	  curLayout != SRC_DISASSEM_COMMAND &&
	  curLayout != DISASSEM_DATA_COMMAND)
	{
	  clearSourceWindowsDetail ();
	  if (curLayout == SRC_DATA_COMMAND)
	    showLayout (DISASSEM_DATA_COMMAND);
	  else
	    showLayout (DISASSEM_COMMAND);
	}
      break;
    case DATA_WIN:
      if (curLayout != SRC_DATA_COMMAND &&
	  curLayout != DISASSEM_DATA_COMMAND)
	{
	  if (curLayout == DISASSEM_COMMAND)
	    showLayout (DISASSEM_DATA_COMMAND);
	  else
	    showLayout (SRC_DATA_COMMAND);
	}
      break;
    default:
      break;
    }

  return;
}				/* tuiAddWinToLayout */


/*
   ** tuiDefaultWinHeight().
   **        Answer the height of a window.  If it hasn't been created yet,
   **        answer what the height of a window would be based upon its
   **        type and the layout.
 */
int
tuiDefaultWinHeight (TuiWinType type, TuiLayoutType layout)
{
  int h;

  if (winList[type] != (TuiWinInfoPtr) NULL)
    h = winList[type]->generic.height;
  else
    {
      switch (layout)
	{
	case SRC_COMMAND:
	case DISASSEM_COMMAND:
	  if (m_winPtrIsNull (cmdWin))
	    h = termHeight () / 2;
	  else
	    h = termHeight () - cmdWin->generic.height;
	  break;
	case SRC_DISASSEM_COMMAND:
	case SRC_DATA_COMMAND:
	case DISASSEM_DATA_COMMAND:
	  if (m_winPtrIsNull (cmdWin))
	    h = termHeight () / 3;
	  else
	    h = (termHeight () - cmdWin->generic.height) / 2;
	  break;
	default:
	  h = 0;
	  break;
	}
    }

  return h;
}				/* tuiDefaultWinHeight */


/*
   ** tuiDefaultWinViewportHeight().
   **        Answer the height of a window.  If it hasn't been created yet,
   **        answer what the height of a window would be based upon its
   **        type and the layout.
 */
int
tuiDefaultWinViewportHeight (TuiWinType type, TuiLayoutType layout)
{
  int h;

  h = tuiDefaultWinHeight (type, layout);

  if (winList[type] == cmdWin)
    h -= 1;
  else
    h -= 2;

  return h;
}				/* tuiDefaultWinViewportHeight */


/*
   ** _initialize_tuiLayout().
   **        Function to initialize gdb commands, for tui window layout
   **        manipulation.
 */
void
_initialize_tuiLayout (void)
{
  add_com ("layout", class_tui, _tuiLayout_command,
           "Change the layout of windows.\n\
Usage: layout prev | next | <layout_name> \n\
Layout names are:\n\
   src   : Displays source and command windows.\n\
   asm   : Displays disassembly and command windows.\n\
   split : Displays source, disassembly and command windows.\n\
   regs  : Displays register window. If existing layout\n\
           is source/command or assembly/command, the \n\
           register window is displayed. If the\n\
           source/assembly/command (split) is displayed, \n\
           the register window is displayed with \n\
           the window that has current logical focus.\n");
  if (xdb_commands)
    {
      add_com ("td", class_tui, _tuiToggleLayout_command,
               "Toggle between Source/Command and Disassembly/Command layouts.\n");
      add_com ("ts", class_tui, _tuiToggleSplitLayout_command,
               "Toggle between Source/Command or Disassembly/Command and \n\
Source/Disassembly/Command layouts.\n");
    }
}


/*************************
** STATIC LOCAL FUNCTIONS
**************************/


/*
   ** _tuiSetLayoutTo()
   **    Function to set the layout to SRC, ASM, SPLIT, NEXT, PREV, DATA, REGS,
   **        $REGS, $GREGS, $FREGS, $SREGS.
 */
TuiStatus
tui_set_layout (const char *layoutName)
{
  TuiStatus status = TUI_SUCCESS;

  if (layoutName != (char *) NULL)
    {
      register int i;
      register char *bufPtr;
      TuiLayoutType newLayout = UNDEFINED_LAYOUT;
      TuiRegisterDisplayType dpyType = TUI_UNDEFINED_REGS;
      TuiLayoutType curLayout = currentLayout ();

      bufPtr = (char *) xstrdup (layoutName);
      for (i = 0; (i < strlen (layoutName)); i++)
	bufPtr[i] = toupper (bufPtr[i]);

      /* First check for ambiguous input */
      if (strlen (bufPtr) <= 1 && (*bufPtr == 'S' || *bufPtr == '$'))
	{
	  warning ("Ambiguous command input.\n");
	  status = TUI_FAILURE;
	}
      else
	{
	  if (subset_compare (bufPtr, "SRC"))
	    newLayout = SRC_COMMAND;
	  else if (subset_compare (bufPtr, "ASM"))
	    newLayout = DISASSEM_COMMAND;
	  else if (subset_compare (bufPtr, "SPLIT"))
	    newLayout = SRC_DISASSEM_COMMAND;
	  else if (subset_compare (bufPtr, "REGS") ||
		   subset_compare (bufPtr, TUI_GENERAL_SPECIAL_REGS_NAME) ||
		   subset_compare (bufPtr, TUI_GENERAL_REGS_NAME) ||
		   subset_compare (bufPtr, TUI_FLOAT_REGS_NAME) ||
		   subset_compare (bufPtr, TUI_SPECIAL_REGS_NAME))
	    {
	      if (curLayout == SRC_COMMAND || curLayout == SRC_DATA_COMMAND)
		newLayout = SRC_DATA_COMMAND;
	      else
		newLayout = DISASSEM_DATA_COMMAND;

/* could ifdef out the following code. when compile with -z, there are null 
   pointer references that cause a core dump if 'layout regs' is the first 
   layout command issued by the user. HP has asked us to hook up this code 
   - edie epstein
 */
	      if (subset_compare (bufPtr, TUI_FLOAT_REGS_NAME))
		{
		  if (dataWin->detail.dataDisplayInfo.regsDisplayType !=
		      TUI_SFLOAT_REGS &&
		      dataWin->detail.dataDisplayInfo.regsDisplayType !=
		      TUI_DFLOAT_REGS)
		    dpyType = TUI_SFLOAT_REGS;
		  else
		    dpyType =
		      dataWin->detail.dataDisplayInfo.regsDisplayType;
		}
	      else if (subset_compare (bufPtr,
				      TUI_GENERAL_SPECIAL_REGS_NAME))
		dpyType = TUI_GENERAL_AND_SPECIAL_REGS;
	      else if (subset_compare (bufPtr, TUI_GENERAL_REGS_NAME))
		dpyType = TUI_GENERAL_REGS;
	      else if (subset_compare (bufPtr, TUI_SPECIAL_REGS_NAME))
		dpyType = TUI_SPECIAL_REGS;
	      else if (dataWin)
		{
		  if (dataWin->detail.dataDisplayInfo.regsDisplayType !=
		      TUI_UNDEFINED_REGS)
		    dpyType =
		      dataWin->detail.dataDisplayInfo.regsDisplayType;
		  else
		    dpyType = TUI_GENERAL_REGS;
		}

/* end of potential ifdef 
 */

/* if ifdefed out code above, then assume that the user wishes to display the 
   general purpose registers 
 */

/*              dpyType = TUI_GENERAL_REGS; 
 */
	    }
	  else if (subset_compare (bufPtr, "NEXT"))
	    newLayout = _nextLayout ();
	  else if (subset_compare (bufPtr, "PREV"))
	    newLayout = _prevLayout ();
	  else
	    status = TUI_FAILURE;
	  xfree (bufPtr);

	  tuiSetLayout (newLayout, dpyType);
	}
    }
  else
    status = TUI_FAILURE;

  return status;
}


static CORE_ADDR
_extractDisplayStartAddr (void)
{
  TuiLayoutType curLayout = currentLayout ();
  CORE_ADDR addr;
  CORE_ADDR pc;
  struct symtab_and_line cursal = get_current_source_symtab_and_line ();

  switch (curLayout)
    {
    case SRC_COMMAND:
    case SRC_DATA_COMMAND:
      find_line_pc (cursal.symtab,
		    srcWin->detail.sourceInfo.startLineOrAddr.lineNo,
		    &pc);
      addr = pc;
      break;
    case DISASSEM_COMMAND:
    case SRC_DISASSEM_COMMAND:
    case DISASSEM_DATA_COMMAND:
      addr = disassemWin->detail.sourceInfo.startLineOrAddr.addr;
      break;
    default:
      addr = 0;
      break;
    }

  return addr;
}				/* _extractDisplayStartAddr */


static void
_tuiHandleXDBLayout (TuiLayoutDefPtr layoutDef)
{
  if (layoutDef->split)
    {
      tuiSetLayout (SRC_DISASSEM_COMMAND, TUI_UNDEFINED_REGS);
      tuiSetWinFocusTo (winList[layoutDef->displayMode]);
    }
  else
    {
      if (layoutDef->displayMode == SRC_WIN)
	tuiSetLayout (SRC_COMMAND, TUI_UNDEFINED_REGS);
      else
	tuiSetLayout (DISASSEM_DATA_COMMAND, layoutDef->regsDisplayType);
    }


  return;
}				/* _tuiHandleXDBLayout */


static void
_tuiToggleLayout_command (char *arg, int fromTTY)
{
  TuiLayoutDefPtr layoutDef = tuiLayoutDef ();

  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  if (layoutDef->displayMode == SRC_WIN)
    layoutDef->displayMode = DISASSEM_WIN;
  else
    layoutDef->displayMode = SRC_WIN;

  if (!layoutDef->split)
    _tuiHandleXDBLayout (layoutDef);

}


static void
_tuiToggleSplitLayout_command (char *arg, int fromTTY)
{
  TuiLayoutDefPtr layoutDef = tuiLayoutDef ();

  /* Make sure the curses mode is enabled.  */
  tui_enable ();
  layoutDef->split = (!layoutDef->split);
  _tuiHandleXDBLayout (layoutDef);

}


static void
_tuiLayout_command (char *arg, int fromTTY)
{
  /* Make sure the curses mode is enabled.  */
  tui_enable ();

  /* Switch to the selected layout.  */
  if (tui_set_layout (arg) != TUI_SUCCESS)
    warning ("Invalid layout specified.\n%s", LAYOUT_USAGE);

}

/*
   ** _nextLayout().
   **        Answer the previous layout to cycle to.
 */
static TuiLayoutType
_nextLayout (void)
{
  TuiLayoutType newLayout;

  newLayout = currentLayout ();
  if (newLayout == UNDEFINED_LAYOUT)
    newLayout = SRC_COMMAND;
  else
    {
      newLayout++;
      if (newLayout == UNDEFINED_LAYOUT)
	newLayout = SRC_COMMAND;
    }

  return newLayout;
}				/* _nextLayout */


/*
   ** _prevLayout().
   **        Answer the next layout to cycle to.
 */
static TuiLayoutType
_prevLayout (void)
{
  TuiLayoutType newLayout;

  newLayout = currentLayout ();
  if (newLayout == SRC_COMMAND)
    newLayout = DISASSEM_DATA_COMMAND;
  else
    {
      newLayout--;
      if (newLayout == UNDEFINED_LAYOUT)
	newLayout = DISASSEM_DATA_COMMAND;
    }

  return newLayout;
}				/* _prevLayout */



/*
   ** _makeCommandWindow().
 */
static void
_makeCommandWindow (TuiWinInfoPtr * winInfoPtr, int height, int originY)
{
  _initAndMakeWin ((Opaque *) winInfoPtr,
		   CMD_WIN,
		   height,
		   termWidth (),
		   0,
		   originY,
		   DONT_BOX_WINDOW);

  (*winInfoPtr)->canHighlight = FALSE;

  return;
}				/* _makeCommandWindow */


/*
   ** _makeSourceWindow().
 */
static void
_makeSourceWindow (TuiWinInfoPtr * winInfoPtr, int height, int originY)
{
  _makeSourceOrDisassemWindow (winInfoPtr, SRC_WIN, height, originY);

  return;
}				/* _makeSourceWindow */


/*
   ** _makeDisassemWindow().
 */
static void
_makeDisassemWindow (TuiWinInfoPtr * winInfoPtr, int height, int originY)
{
  _makeSourceOrDisassemWindow (winInfoPtr, DISASSEM_WIN, height, originY);

  return;
}				/* _makeDisassemWindow */


/*
   ** _makeDataWindow().
 */
static void
_makeDataWindow (TuiWinInfoPtr * winInfoPtr, int height, int originY)
{
  _initAndMakeWin ((Opaque *) winInfoPtr,
		   DATA_WIN,
		   height,
		   termWidth (),
		   0,
		   originY,
		   BOX_WINDOW);

  return;
}				/* _makeDataWindow */



/*
   **    _showSourceCommand().
   **        Show the Source/Command layout
 */
static void
_showSourceCommand (void)
{
  _showSourceOrDisassemAndCommand (SRC_COMMAND);

  return;
}				/* _showSourceCommand */


/*
   **    _showDisassemCommand().
   **        Show the Dissassem/Command layout
 */
static void
_showDisassemCommand (void)
{
  _showSourceOrDisassemAndCommand (DISASSEM_COMMAND);

  return;
}				/* _showDisassemCommand */


/*
   **    _showSourceDisassemCommand().
   **        Show the Source/Disassem/Command layout
 */
static void
_showSourceDisassemCommand (void)
{
  if (currentLayout () != SRC_DISASSEM_COMMAND)
    {
      int cmdHeight, srcHeight, asmHeight;

      if (m_winPtrNotNull (cmdWin))
	cmdHeight = cmdWin->generic.height;
      else
	cmdHeight = termHeight () / 3;

      srcHeight = (termHeight () - cmdHeight) / 2;
      asmHeight = termHeight () - (srcHeight + cmdHeight);

      if (m_winPtrIsNull (srcWin))
	_makeSourceWindow (&srcWin, srcHeight, 0);
      else
	{
	  _initGenWinInfo (&srcWin->generic,
			   srcWin->generic.type,
			   srcHeight,
			   srcWin->generic.width,
			   srcWin->detail.sourceInfo.executionInfo->width,
			   0);
	  srcWin->canHighlight = TRUE;
	  _initGenWinInfo (srcWin->detail.sourceInfo.executionInfo,
			   EXEC_INFO_WIN,
			   srcHeight,
			   3,
			   0,
			   0);
	  m_beVisible (srcWin);
	  m_beVisible (srcWin->detail.sourceInfo.executionInfo);
	  srcWin->detail.sourceInfo.hasLocator = FALSE;;
	}
      if (m_winPtrNotNull (srcWin))
	{
	  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();

	  tuiShowSourceContent (srcWin);
	  if (m_winPtrIsNull (disassemWin))
	    {
	      _makeDisassemWindow (&disassemWin, asmHeight, srcHeight - 1);
	      _initAndMakeWin ((Opaque *) & locator,
			       LOCATOR_WIN,
			       2 /* 1 */ ,
			       termWidth (),
			       0,
			       (srcHeight + asmHeight) - 1,
			       DONT_BOX_WINDOW);
	    }
	  else
	    {
	      _initGenWinInfo (locator,
			       LOCATOR_WIN,
			       2 /* 1 */ ,
			       termWidth (),
			       0,
			       (srcHeight + asmHeight) - 1);
	      disassemWin->detail.sourceInfo.hasLocator = TRUE;
	      _initGenWinInfo (
				&disassemWin->generic,
				disassemWin->generic.type,
				asmHeight,
				disassemWin->generic.width,
			disassemWin->detail.sourceInfo.executionInfo->width,
				srcHeight - 1);
	      _initGenWinInfo (disassemWin->detail.sourceInfo.executionInfo,
			       EXEC_INFO_WIN,
			       asmHeight,
			       3,
			       0,
			       srcHeight - 1);
	      disassemWin->canHighlight = TRUE;
	      m_beVisible (disassemWin);
	      m_beVisible (disassemWin->detail.sourceInfo.executionInfo);
	    }
	  if (m_winPtrNotNull (disassemWin))
	    {
	      srcWin->detail.sourceInfo.hasLocator = FALSE;
	      disassemWin->detail.sourceInfo.hasLocator = TRUE;
	      m_beVisible (locator);
	      tuiShowLocatorContent ();
	      tuiShowSourceContent (disassemWin);

	      if (m_winPtrIsNull (cmdWin))
		_makeCommandWindow (&cmdWin,
				    cmdHeight,
				    termHeight () - cmdHeight);
	      else
		{
		  _initGenWinInfo (&cmdWin->generic,
				   cmdWin->generic.type,
				   cmdWin->generic.height,
				   cmdWin->generic.width,
				   0,
				   cmdWin->generic.origin.y);
		  cmdWin->canHighlight = FALSE;
		  m_beVisible (cmdWin);
		}
	      if (m_winPtrNotNull (cmdWin))
		tuiRefreshWin (&cmdWin->generic);
	    }
	}
      setCurrentLayoutTo (SRC_DISASSEM_COMMAND);
    }

  return;
}				/* _showSourceDisassemCommand */


/*
   **    _showData().
   **        Show the Source/Data/Command or the Dissassembly/Data/Command layout
 */
static void
_showData (TuiLayoutType newLayout)
{
  int totalHeight = (termHeight () - cmdWin->generic.height);
  int srcHeight, dataHeight;
  TuiWinType winType;
  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();


  dataHeight = totalHeight / 2;
  srcHeight = totalHeight - dataHeight;
  m_allBeInvisible ();
  m_beInvisible (locator);
  _makeDataWindow (&dataWin, dataHeight, 0);
  dataWin->canHighlight = TRUE;
  if (newLayout == SRC_DATA_COMMAND)
    winType = SRC_WIN;
  else
    winType = DISASSEM_WIN;
  if (m_winPtrIsNull (winList[winType]))
    {
      if (winType == SRC_WIN)
	_makeSourceWindow (&winList[winType], srcHeight, dataHeight - 1);
      else
	_makeDisassemWindow (&winList[winType], srcHeight, dataHeight - 1);
      _initAndMakeWin ((Opaque *) & locator,
		       LOCATOR_WIN,
		       2 /* 1 */ ,
		       termWidth (),
		       0,
		       totalHeight - 1,
		       DONT_BOX_WINDOW);
    }
  else
    {
      _initGenWinInfo (&winList[winType]->generic,
		       winList[winType]->generic.type,
		       srcHeight,
		       winList[winType]->generic.width,
		   winList[winType]->detail.sourceInfo.executionInfo->width,
		       dataHeight - 1);
      _initGenWinInfo (winList[winType]->detail.sourceInfo.executionInfo,
		       EXEC_INFO_WIN,
		       srcHeight,
		       3,
		       0,
		       dataHeight - 1);
      m_beVisible (winList[winType]);
      m_beVisible (winList[winType]->detail.sourceInfo.executionInfo);
      _initGenWinInfo (locator,
		       LOCATOR_WIN,
		       2 /* 1 */ ,
		       termWidth (),
		       0,
		       totalHeight - 1);
    }
  winList[winType]->detail.sourceInfo.hasLocator = TRUE;
  m_beVisible (locator);
  tuiShowLocatorContent ();
  addToSourceWindows (winList[winType]);
  setCurrentLayoutTo (newLayout);

  return;
}				/* _showData */

/*
   ** _initGenWinInfo().
 */
static void
_initGenWinInfo (TuiGenWinInfoPtr winInfo, TuiWinType type,
                 int height, int width, int originX, int originY)
{
  int h = height;

  winInfo->type = type;
  winInfo->width = width;
  winInfo->height = h;
  if (h > 1)
    {
      winInfo->viewportHeight = h - 1;
      if (winInfo->type != CMD_WIN)
	winInfo->viewportHeight--;
    }
  else
    winInfo->viewportHeight = 1;
  winInfo->origin.x = originX;
  winInfo->origin.y = originY;

  return;
}				/* _initGenWinInfo */

/*
   ** _initAndMakeWin().
 */
static void
_initAndMakeWin (Opaque * winInfoPtr, TuiWinType winType,
                 int height, int width, int originX, int originY, int boxIt)
{
  Opaque opaqueWinInfo = *winInfoPtr;
  TuiGenWinInfoPtr generic;

  if (opaqueWinInfo == (Opaque) NULL)
    {
      if (m_winIsAuxillary (winType))
	opaqueWinInfo = (Opaque) allocGenericWinInfo ();
      else
	opaqueWinInfo = (Opaque) allocWinInfo (winType);
    }
  if (m_winIsAuxillary (winType))
    generic = (TuiGenWinInfoPtr) opaqueWinInfo;
  else
    generic = &((TuiWinInfoPtr) opaqueWinInfo)->generic;

  if (opaqueWinInfo != (Opaque) NULL)
    {
      _initGenWinInfo (generic, winType, height, width, originX, originY);
      if (!m_winIsAuxillary (winType))
	{
	  if (generic->type == CMD_WIN)
	    ((TuiWinInfoPtr) opaqueWinInfo)->canHighlight = FALSE;
	  else
	    ((TuiWinInfoPtr) opaqueWinInfo)->canHighlight = TRUE;
	}
      makeWindow (generic, boxIt);
    }
  *winInfoPtr = opaqueWinInfo;
}


/*
   ** _makeSourceOrDisassemWindow().
 */
static void
_makeSourceOrDisassemWindow (TuiWinInfoPtr * winInfoPtr, TuiWinType type,
                             int height, int originY)
{
  TuiGenWinInfoPtr executionInfo = (TuiGenWinInfoPtr) NULL;

  /*
     ** Create the exeuction info window.
   */
  if (type == SRC_WIN)
    executionInfo = sourceExecInfoWinPtr ();
  else
    executionInfo = disassemExecInfoWinPtr ();
  _initAndMakeWin ((Opaque *) & executionInfo,
		   EXEC_INFO_WIN,
		   height,
		   3,
		   0,
		   originY,
		   DONT_BOX_WINDOW);
  /*
     ** Now create the source window.
   */
  _initAndMakeWin ((Opaque *) winInfoPtr,
		   type,
		   height,
		   termWidth () - executionInfo->width,
		   executionInfo->width,
		   originY,
		   BOX_WINDOW);

  (*winInfoPtr)->detail.sourceInfo.executionInfo = executionInfo;

  return;
}				/* _makeSourceOrDisassemWindow */


/*
   **    _showSourceOrDisassemAndCommand().
   **        Show the Source/Command or the Disassem layout
 */
static void
_showSourceOrDisassemAndCommand (TuiLayoutType layoutType)
{
  if (currentLayout () != layoutType)
    {
      TuiWinInfoPtr *winInfoPtr;
      int srcHeight, cmdHeight;
      TuiGenWinInfoPtr locator = locatorWinInfoPtr ();

      if (m_winPtrNotNull (cmdWin))
	cmdHeight = cmdWin->generic.height;
      else
	cmdHeight = termHeight () / 3;
      srcHeight = termHeight () - cmdHeight;


      if (layoutType == SRC_COMMAND)
	winInfoPtr = &srcWin;
      else
	winInfoPtr = &disassemWin;

      if (m_winPtrIsNull (*winInfoPtr))
	{
	  if (layoutType == SRC_COMMAND)
	    _makeSourceWindow (winInfoPtr, srcHeight - 1, 0);
	  else
	    _makeDisassemWindow (winInfoPtr, srcHeight - 1, 0);
	  _initAndMakeWin ((Opaque *) & locator,
			   LOCATOR_WIN,
			   2 /* 1 */ ,
			   termWidth (),
			   0,
			   srcHeight - 1,
			   DONT_BOX_WINDOW);
	}
      else
	{
	  _initGenWinInfo (locator,
			   LOCATOR_WIN,
			   2 /* 1 */ ,
			   termWidth (),
			   0,
			   srcHeight - 1);
	  (*winInfoPtr)->detail.sourceInfo.hasLocator = TRUE;
	  _initGenWinInfo (
			    &(*winInfoPtr)->generic,
			    (*winInfoPtr)->generic.type,
			    srcHeight - 1,
			    (*winInfoPtr)->generic.width,
		      (*winInfoPtr)->detail.sourceInfo.executionInfo->width,
			    0);
	  _initGenWinInfo ((*winInfoPtr)->detail.sourceInfo.executionInfo,
			   EXEC_INFO_WIN,
			   srcHeight - 1,
			   3,
			   0,
			   0);
	  (*winInfoPtr)->canHighlight = TRUE;
	  m_beVisible (*winInfoPtr);
	  m_beVisible ((*winInfoPtr)->detail.sourceInfo.executionInfo);
	}
      if (m_winPtrNotNull (*winInfoPtr))
	{
	  (*winInfoPtr)->detail.sourceInfo.hasLocator = TRUE;
	  m_beVisible (locator);
	  tuiShowLocatorContent ();
	  tuiShowSourceContent (*winInfoPtr);

	  if (m_winPtrIsNull (cmdWin))
	    {
	      _makeCommandWindow (&cmdWin, cmdHeight, srcHeight);
	      tuiRefreshWin (&cmdWin->generic);
	    }
	  else
	    {
	      _initGenWinInfo (&cmdWin->generic,
			       cmdWin->generic.type,
			       cmdWin->generic.height,
			       cmdWin->generic.width,
			       cmdWin->generic.origin.x,
			       cmdWin->generic.origin.y);
	      cmdWin->canHighlight = FALSE;
	      m_beVisible (cmdWin);
	    }
	}
      setCurrentLayoutTo (layoutType);
    }

  return;
}				/* _showSourceOrDisassemAndCommand */
@


1.19
log
@	* tui-hooks.c: Update include order.
	* tui.c: Likewise.
	* tuiCommand.c: Likewise.
	* tuiData.c: Likewise.
	* tuiDataWin.c: Likewise.
	* tuiDisassem.c: Likewise.
	* tuiGeneralWin.c: Likewise.
	* tuiIO.c: Likewise.
	* tuiLayout.c: Likewise.
	* tuiRegs.c: Likewise.
	* tuiSource.c: Likewise.
	* tuiSourceWin.c: Likewise.
	* tuiStack.c: Likewise.
	* tuiWin.c: Likewise.
@
text
@@


1.19.6.1
log
@merge mainline changes to branch
@
text
@@


1.18
log
@2002-09-29  Elena Zannoni  <ezannoni@@redhat.com>

	* tui.c (tui_show_source): Don't access current_source_symtab, use
	accessor function instead.  Include source.h and symtab.h
	* tuiDisassem.c (tuiShowDisassemAndUpdateSource,
	tuiVerticalDisassemScroll): Use accessor functions for current
	source line and symtab.  Include source.h.
	* tuiLayout.c (_extractDisplayStartAddr): Use accessor functions
	for current source line and symtab.  Include source.h.
	* tuiWin.c (_makeVisibleWithNewHeight): Ditto.
	* tuiSourceWin.c (tuiUpdateSourceWindowAsIs,
	tuiHorizontalSourceScroll): Ditto.
	* tuiSource.c (tuiVerticalSourceScroll): Ditto.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation,
a24 17
/* FIXME: cagney/2002-02-28: The GDB coding standard indicates that
   "defs.h" should be included first.  Unfortunatly some systems
   (currently Debian GNU/Linux) include the <stdbool.h> via <curses.h>
   and they clash with "bfd.h"'s definiton of true/false.  The correct
   fix is to remove true/false from "bfd.h", however, until that
   happens, hack around it by including "config.h" and <curses.h>
   first.  */

#include "config.h"
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

d41 8
@


1.18.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a57 8

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
@


1.18.2.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@@


1.17
log
@	* tui.c (tui_enable): Use tuiSetLayout instead of showLayout and
	use tuiShowFrameInfo instead of tuiSetLocatorContent.
	* tuiLayout.h (showLayout): Remove.
	* tuiLayout.c (_showSourceOrDisassemAndCommand): Remove unused locals.
	(_showSourceDisassemCommand): Likewise.
	(showLayout): Make it static.
	(lastLayout): Remove.
@
text
@d46 1
d550 1
d556 1
a556 1
      find_line_pc (current_source_symtab,
@


1.17.6.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a45 1
#include "source.h"
a548 1
  struct symtab_and_line cursal = get_current_source_symtab_and_line ();
d554 1
a554 1
      find_line_pc (cursal.symtab,
@


1.17.6.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a57 8

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
@


1.17.6.3
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.16
log
@	* tuiSourceWin.c (tui_show_source_line): New function.
	(tuiShowSourceContent): Call it and avoid clearing the window before
	redrawing it.
	(tuiClearAllSourceWinsContent): Remove.
	* tuiSourceWin.h (tuiClearAllSourceWinsContent): Don't declare.
	* tuiWin.h (tuiClearWinFocus, tuiClearWinFocusFrom): Don't declare.
	* tuiWin.c (tuiClearWinFocus, tuiClearWinFocusFrom): Remove.
	(tuiRefreshAll): Don't clear the window.
	(_makeVisibleWithNewHeight): Don't clear locator line.
	(tuiResizeAll): Remove unused locals.
	(_tuiAdjustWinHeights): Likewise.
	(_makeInvisibleAndSetNewHeight): Likewise.
	(_newHeightOk): Likewise.
	* tuiLayout.c (showLayout): Don't clear source windows.
	(tuiSetLayout): Don't clear the window.
	(_initAndMakeWin): Likewise for status line.
	* tuiGeneralWin.c (makeVisible): Don't clear or refresh the window.
	(makeWindow): Likewise.
	(tuiClearWin): Remove.
	* tuiGeneralWin.h (tuiClearWin): Don't declare.
@
text
@d61 1
a61 1

d89 2
a90 14
/***************************************
** Static Local Data
***************************************/
static TuiLayoutType lastLayout = UNDEFINED_LAYOUT;

/***************************************
** PUBLIC FUNCTIONS
***************************************/

/*
   ** showLayout().
   **        Show the screen layout defined
 */
void
a779 2
  TuiGenWinInfoPtr locator = locatorWinInfoPtr ();

a1071 1
      int areaLeft;
@


1.15
log
@Add FIXME explaining include problem.
@
text
@a113 1
      tuiClearAllSourceWinsContent (NO_EMPTY_SOURCE_PROMPT);
d148 1
a148 3

  return;
}				/* showLayout */
a194 2
	      if (winWithFocus != cmdWin)
		tuiClearWinFocus ();
d289 1
a289 1
}				/* tuiSetLayout */
a1030 2
      if (winType == LOCATOR_WIN)
	tuiClearLocatorDisplay ();
d1033 1
a1033 3

  return;
}				/* _initAndMakeWin */
@


1.15.8.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d61 1
a61 1
static void showLayout (TuiLayoutType);
d89 14
a102 2
/* Show the screen layout defined.  */
static void
d114 1
d149 3
a151 1
}
d198 2
d294 1
a294 1
}
d797 2
d1036 2
d1040 3
a1042 1
}
d1095 1
@


1.15.8.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a45 1
#include "source.h"
a548 1
  struct symtab_and_line cursal = get_current_source_symtab_and_line ();
d554 1
a554 1
      find_line_pc (cursal.symtab,
@


1.14
log
@2002-02-08  Daniel Jacobowitz  <drow@@mvista.com>

        * utils.c: Include <curses.h> before "bfd.h".
        * tui/tui-hooks.c: Likewise.
        * tui/tui.c: Likewise.
        * tui/tuiCommand.c: Likewise.
        * tui/tuiData.c: Likewise.
        * tui/tuiDataWin.c: Likewise.
        * tui/tuiDisassem.c: Likewise.
        * tui/tuiGeneralWin.c: Likewise.
        * tui/tuiIO.c: Likewise.
        * tui/tuiLayout.c: Likewise.
        * tui/tuiRegs.c: Likewise.
        * tui/tuiSource.c: Likewise.
        * tui/tuiSourceWin.c: Likewise.
        * tui/tuiStack.c: Likewise.
        * tui/tuiWin.c: Likewise.
@
text
@d2 4
a5 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d25 8
a32 1
/* If we need <curses.h>, we must include it before we get "bfd.h".  */
@


1.13
log
@	* tuiSourceWin.h: Remove unused declarations.
	* tuiSourceWin.c (tui_vUpdateSourceWindowsWithAddr): Remove.
	(tui_vUpdateSourceWindowsWithLine): Remove.
	(tui_vAllSetHasBreakAt): Remove.

	* tuiLayout.h (tui_set_layout): Declare.
	(tui_vSetLayoutTo): Remove.
	(tui_vAddWinToLayout): Remove.
	* tuiLayout.c (_tuiLayout_command): Call tui_enable() to force TUI.
	(_tuiToggleLayout_command): Remove.
	(_tuiToggleSplitLayout_command): Remove.
	(_tuiLayout_command): Remove.
	(tui_vSetLayoutTo): Remove.
	(tui_vAddWinToLayout): Remove.

	* tuiDataWin.h (tui_vCheckDataValues): Remove.
	* tuiDataWin.c (tui_vCheckDataValues): Remove.
@
text
@d22 10
@


1.12
log
@	* tuiWin.c (_initialize_tuiWin): Always define the tui commands;
	create the tui class help.
	* tuiLayout.c (_initialize_tuiLayout): Always define the tui commands.
	* tuiRegs.c (_initialize_tuiRegs): Likewise.
	* tuiStack.c (_initialize_tuiStack): Likewise.
@
text
@a57 1
static void _tui_vToggleLayout_command (va_list);
a58 1
static void _tui_vToggleSplitLayout_command (va_list);
a275 17

/*
   ** tui_vSetLayoutTo()
   **        Function to set the layout to SRC, ASM, SPLIT, NEXT, PREV, DATA,
   **        REGS, $REGS, $GREGS, $FREGS, $SREGS with arguments in a va_list
 */
TuiStatus
tui_vSetLayoutTo (va_list args)
{
  char *layoutName;

  layoutName = va_arg (args, char *);

  return (_tuiSetLayoutTo (layoutName));
}				/* tui_vSetLayoutTo */


a331 16
   ** tui_vAddWinToLayout().
   **        Add the specified window to the layout in a logical way,
   **        with arguments in a va_list.
 */
void
tui_vAddWinToLayout (va_list args)
{
  TuiWinType type = va_arg (args, TuiWinType);

  tuiAddWinToLayout (type);

  return;
}				/* tui_vAddWinToLayout */


/*
d450 1
a450 1
      bufPtr = (char *) tuiStrDup (layoutName);
d596 2
d614 2
d625 4
@


1.11
log
@	* tuiIO.c (_tuiHandleResizeDuringIO): Call tuiRefreshAll.
	(tuiRead, tui_vread): Remove.

	* tui.c (va_catch_errors, tuiDo, tuiDoAndReturnToTop): Remove.
	(vcatch_errors, _tui_vDo): Remove.
	* tui.h (tuiDo, tuiDoAndReturnToTop): Remove.

	* tuiLayout.c (tuiSetLayout): Remove vcatch_errors.
	(tui_set_layout): Rename of _tuiSetLayoutTo, public.
	(_tuiToggleLayout_command): Merge with _tui_vToggleLayout_command.
	(_tuiToggleSplitLayout_command): Merge with _tui_vToggleSplitLayout_command.
	(_tuiLayout_command): Call tui_set_layout.

	* tuiRegs.c (_tuiScrollRegsBackward_command): Call tui_scroll.
	(_tuiScrollRegsForward_command): Likewise.
	(_tuiShowFloat_command): Call _tui_vShowRegisters_commandSupport.
	(_tuiShowGeneral_command): Likewise.
	(_tuiShowSpecial_command): Likewise.
	(_tuiToggleFloatRegs_command): Call tuiToggleFloatRegs.
	* tuiWin.c (tui_scroll): Rename of tui_vScroll, update parameters.
	(_tuiScrollForward_command): Call tui_scroll.
	(_tuiScrollBackward_command): Likewise.
	(_tuiScrollLeft_command): Likewise.
	(_tuiScrollRight_command): Likewise.
	(_tuiSetFocus_command): Call _tuiSetFocus.
	(_tuiRefreshAll_command): Call tuiRefreshAll.
	(_tuiSetWinHeight_command): Call _tuiSetWinHeight.
	(_tuiXDBsetWinHeight_command): Call _tuiXDBsetWinHeight.
	* tuiWin.h (tui_scroll): Rename of tui_vScroll, update parameters.
@
text
@d438 2
a439 4
  if (tui_version)
    {
      add_com ("layout", class_tui, _tuiLayout_command,
	       "Change the layout of windows.\n\
d451 6
a456 6
      if (xdb_commands)
	{
	  add_com ("td", class_tui, _tuiToggleLayout_command,
		   "Toggle between Source/Command and Disassembly/Command layouts.\n");
	  add_com ("ts", class_tui, _tuiToggleSplitLayout_command,
		   "Toggle between Source/Command or Disassembly/Command and \n\
a457 1
	}
d459 1
a459 3

  return;
}				/* _intialize_tuiLayout */
@


1.10
log
@	* tuiData.h (TuiLocatorElement): Use CORE_ADDR for address member.
	(TuiLineOrAddress): Likewise.
	* tuiDisassem.c (tuiGetBeginAsmAddress): Use CORE_ADDR to specify
	an address.
	(tuiSetDisassemContent): Likewise.
	(tuiShowDisassem, tuiShowDisassemAndUpdateSource): Likewise.
	* tuiLayout.c (_extractDisplayStartAddr): Likewise.
	(tuiSetLayout): Likewise.
	* tuiSourceWin.c (tuiDisplayMainFunction): Likewise.
	(tuiUpdateSourceWindowsWithAddr): Likewise.
	(tuiUpdateSourceWindowsWithLine): Likewise.
	(tuiSetHasBreakAt): Likewise.
	* tuiStack.c (tuiSetLocatorInfo): Likewise.
	(tuiSwitchFilename): Likewise.
	(tuiUpdateLocatorInfoFromFrame): Likewise.
	(tuiSetLocatorContent): Likewise.
	(tuiShowFrameInfo): Likewise.
	* tuiDisassem.h: Update prototypes to use CORE_ADDR.
	* tuiSourceWin.h: Likewise.
	* tuiStack.h: Likewise.
@
text
@a62 1
static TuiStatus _tuiSetLayoutTo (char *);
d203 1
a203 2
		      addr = vcatch_errors ((OpaqueFuncPtr)
					    tuiGetBeginAsmAddress);
d216 1
a216 2
		      addr = vcatch_errors ((OpaqueFuncPtr)
					    tuiGetBeginAsmAddress);
d239 1
a239 2
		      addr = vcatch_errors ((OpaqueFuncPtr)
					    tuiGetBeginAsmAddress);
d477 2
a478 2
static TuiStatus
_tuiSetLayoutTo (char *layoutName)
d577 1
a577 1
}				/* _tuiSetLayoutTo */
a633 6
  tuiDo ((TuiOpaqueFuncPtr) _tui_vToggleLayout_command, arg, fromTTY);
}

static void
_tui_vToggleLayout_command (va_list args)
{
d644 1
a644 2
  return;
}				/* _tuiToggleLayout_command */
a649 6
  tuiDo ((TuiOpaqueFuncPtr) _tui_vToggleSplitLayout_command, arg, fromTTY);
}

static void
_tui_vToggleSplitLayout_command (va_list args)
{
d655 1
a655 2
  return;
}				/* _tui_vToggleSplitLayout_command */
d661 1
a661 2
  if ((TuiStatus) tuiDo (
		   (TuiOpaqueFuncPtr) tui_vSetLayoutTo, arg) != TUI_SUCCESS)
d664 1
a664 2
  return;
}				/* _tuiLayout_command */
@


1.9
log
@	* tuiWin.c: Add missing includes.
	(_makeVisibleWithNewHeight): Fix call to find_line_pc.
	* tuiLayout.c: Add missing includes.
	(_initAndMakeWin): Don't put curses in echo mode.
	(_extractDisplayStartAddr): Fix calls to find_line_pc.
	(_tuiLayout_command): Missing ',' in warning call.
	* tuiSourceWin.c (tuiUpdateSourceWindowsWithLine): Fix calls to
	find_line_pc.
	(tuiSetHasBreakAt): Check for null source file.
@
text
@d61 1
a61 1
static Opaque _extractDisplayStartAddr (void);
d155 1
a155 1
      Opaque addr = _extractDisplayStartAddr ();
d584 1
a584 1
static Opaque
d588 1
a588 1
  Opaque addr;
d598 1
a598 1
      addr =(Opaque) pc;
d606 1
a606 1
      addr = (Opaque) NULL;
@


1.8
log
@	* tuiWin.c (_tuiSetFocus): Replace subsetCompare with subset_compare.
	* tuiLayout.c (_tuiSetLayoutTo): Likewise.
	* tui.c (_tui_vToggle_command): Likewise.
@
text
@d26 1
d30 1
d34 2
d546 1
a546 1
	      else
d589 1
d595 4
a598 3
      addr = (Opaque) find_line_pc (
				     current_source_symtab,
			  srcWin->detail.sourceInfo.startLineOrAddr.lineNo);
d681 1
a681 1
    warning ("Invalid layout specified.\n%s" LAYOUT_USAGE);
a1069 1
      echo ();
@


1.7
log
@	* tuiWin.c, tui.c, tuiCommand.c: Use ansi prototype.
	tuiIO.c, tuiData.c: Likewise.
	tuiDataWin.c, tuiDisassem.c: Likewise.
	tuiGeneralWin.c, tuiLayout.c: Likewise.
	tuiRegs.c, tuiSource.c: Likewise.
	tuiSouceWin.c, tuiStack.c: Likewise.
@
text
@d502 1
a502 1
	  if (subsetCompare (bufPtr, "SRC"))
d504 1
a504 1
	  else if (subsetCompare (bufPtr, "ASM"))
d506 1
a506 1
	  else if (subsetCompare (bufPtr, "SPLIT"))
d508 5
a512 5
	  else if (subsetCompare (bufPtr, "REGS") ||
		   subsetCompare (bufPtr, TUI_GENERAL_SPECIAL_REGS_NAME) ||
		   subsetCompare (bufPtr, TUI_GENERAL_REGS_NAME) ||
		   subsetCompare (bufPtr, TUI_FLOAT_REGS_NAME) ||
		   subsetCompare (bufPtr, TUI_SPECIAL_REGS_NAME))
d524 1
a524 1
	      if (subsetCompare (bufPtr, TUI_FLOAT_REGS_NAME))
d535 1
a535 1
	      else if (subsetCompare (bufPtr,
d538 1
a538 1
	      else if (subsetCompare (bufPtr, TUI_GENERAL_REGS_NAME))
d540 1
a540 1
	      else if (subsetCompare (bufPtr, TUI_SPECIAL_REGS_NAME))
d562 1
a562 1
	  else if (subsetCompare (bufPtr, "NEXT"))
d564 1
a564 1
	  else if (subsetCompare (bufPtr, "PREV"))
@


1.6
log
@	* tuiWin.c, tuiWin.h, tui.c, tui.h, tuiCommand.c: Add FSF copyright.
	tuiCommand.h, tuiIO.c, tuiIO.h, tuiData.h, tuiData.c: Likewise.
	tuiDataWin.c, tuiDataWin.h, tuiDisassem.c, tuiDisassem.h: Likewise.
	tuiGeneralWin.c, tuiGeneralWin.h, tuiLayout.c, tuiLayout.h: Likewise.
	tuiRegs.c, tuiRegs.h, tuiSource.c, tuiSource.h: Likewise.
	tuiSouceWin.c, tuiSourceWin.h, tuiStack.c, tuiStack.h: Likewise.
@
text
@d82 1
a82 7
#ifdef __STDC__
showLayout (
	     TuiLayoutType layout)
#else
showLayout (layout)
     TuiLayoutType layout;
#endif
d142 2
a143 9
#ifdef __STDC__
tuiSetLayout (
	       TuiLayoutType layoutType,
	       TuiRegisterDisplayType regsDisplayType)
#else
tuiSetLayout (layoutType, regsDisplayType)
     TuiLayoutType layoutType;
     TuiRegisterDisplayType regsDisplayType;
#endif
d285 1
a285 7
#ifdef __STDC__
tui_vSetLayoutTo (
		   va_list args)
#else
tui_vSetLayoutTo (args)
     va_list args;
#endif
d302 1
a302 7
#ifdef __STDC__
tuiAddWinToLayout (
		    TuiWinType type)
#else
tuiAddWinToLayout (type)
     TuiWinType type;
#endif
d356 1
a356 7
#ifdef __STDC__
tui_vAddWinToLayout (
		      va_list args)
#else
tui_vAddWinToLayout (args)
     va_list args;
#endif
d373 1
a373 9
#ifdef __STDC__
tuiDefaultWinHeight (
		      TuiWinType type,
		      TuiLayoutType layout)
#else
tuiDefaultWinHeight (type, layout)
     TuiWinType type;
     TuiLayoutType layout;
#endif
d415 1
a415 9
#ifdef __STDC__
tuiDefaultWinViewportHeight (
			      TuiWinType type,
			      TuiLayoutType layout)
#else
tuiDefaultWinViewportHeight (type, layout)
     TuiWinType type;
     TuiLayoutType layout;
#endif
d478 1
a478 7
#ifdef __STDC__
_tuiSetLayoutTo (
		  char *layoutName)
#else
_tuiSetLayoutTo (layoutName)
     char *layoutName;
#endif
a580 1
#ifdef __STDC__
a581 3
#else
_extractDisplayStartAddr ()
#endif
d609 1
a609 7
#ifdef __STDC__
_tuiHandleXDBLayout (
		      TuiLayoutDefPtr layoutDef)
#else
_tuiHandleXDBLayout (layoutDef)
     TuiLayoutDefPtr layoutDef;
#endif
d630 1
a630 9
#ifdef __STDC__
_tuiToggleLayout_command (
			   char *arg,
			   int fromTTY)
#else
_tuiToggleLayout_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d636 1
a636 7
#ifdef __STDC__
_tui_vToggleLayout_command (
			     va_list args)
#else
_tui_vToggleLayout_command (args)
     va_list args;
#endif
d653 1
a653 9
#ifdef __STDC__
_tuiToggleSplitLayout_command (
				char *arg,
				int fromTTY)
#else
_tuiToggleSplitLayout_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d659 1
a659 7
#ifdef __STDC__
_tui_vToggleSplitLayout_command (
				  va_list args)
#else
_tui_vToggleSplitLayout_command (args)
     va_list args;
#endif
d671 1
a671 9
#ifdef __STDC__
_tuiLayout_command (
		     char *arg,
		     int fromTTY)
#else
_tuiLayout_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
a684 1
#ifdef __STDC__
a685 3
#else
_nextLayout ()
#endif
a707 1
#ifdef __STDC__
a708 3
#else
_prevLayout ()
#endif
d731 1
a731 11
#ifdef __STDC__
_makeCommandWindow (
		     TuiWinInfoPtr * winInfoPtr,
		     int height,
		     int originY)
#else
_makeCommandWindow (winInfoPtr, height, originY)
     TuiWinInfoPtr *winInfoPtr;
     int height;
     int originY;
#endif
d751 1
a751 11
#ifdef __STDC__
_makeSourceWindow (
		    TuiWinInfoPtr * winInfoPtr,
		    int height,
		    int originY)
#else
_makeSourceWindow (winInfoPtr, height, originY)
     TuiWinInfoPtr *winInfoPtr;
     int height;
     int originY;
#endif
d763 1
a763 11
#ifdef __STDC__
_makeDisassemWindow (
		      TuiWinInfoPtr * winInfoPtr,
		      int height,
		      int originY)
#else
_makeDisassemWindow (winInfoPtr, height, originY)
     TuiWinInfoPtr *winInfoPtr;
     int height;
     int originY;
#endif
d775 1
a775 11
#ifdef __STDC__
_makeDataWindow (
		  TuiWinInfoPtr * winInfoPtr,
		  int height,
		  int originY)
#else
_makeDataWindow (winInfoPtr, height, originY)
     TuiWinInfoPtr *winInfoPtr;
     int height;
     int originY;
#endif
a794 1
#ifdef __STDC__
a795 3
#else
_showSourceCommand ()
#endif
a807 1
#ifdef __STDC__
a808 3
#else
_showDisassemCommand ()
#endif
a820 1
#ifdef __STDC__
a821 3
#else
_showSourceDisassemCommand ()
#endif
d939 1
a939 7
#ifdef __STDC__
_showData (
	    TuiLayoutType newLayout)
#else
_showData (newLayout)
     TuiLayoutType newLayout;
#endif
d1007 2
a1008 17
#ifdef __STDC__
_initGenWinInfo (
		  TuiGenWinInfoPtr winInfo,
		  TuiWinType type,
		  int height,
		  int width,
		  int originX,
		  int originY)
#else
_initGenWinInfo (winInfo, type, height, width, originX, originY)
     TuiGenWinInfoPtr winInfo;
     TuiWinType type;
     int height;
     int width;
     int originX;
     int originY;
#endif
d1033 2
a1034 19
#ifdef __STDC__
_initAndMakeWin (
		  Opaque * winInfoPtr,
		  TuiWinType winType,
		  int height,
		  int width,
		  int originX,
		  int originY,
		  int boxIt)
#else
_initAndMakeWin (winInfoPtr, winType, height, width, originX, originY, boxIt)
     Opaque *winInfoPtr;
     TuiWinType winType;
     int height;
     int width;
     int originX;
     int originY;
     int boxIt;
#endif
d1076 2
a1077 13
#ifdef __STDC__
_makeSourceOrDisassemWindow (
			      TuiWinInfoPtr * winInfoPtr,
			      TuiWinType type,
			      int height,
			      int originY)
#else
_makeSourceOrDisassemWindow (winInfoPtr, type, height, originY)
     TuiWinInfoPtr *winInfoPtr;
     TuiWinType type;
     int height;
     int originY;
#endif
d1117 1
a1117 7
#ifdef __STDC__
_showSourceOrDisassemAndCommand (
				  TuiLayoutType layoutType)
#else
_showSourceOrDisassemAndCommand (layoutType)
     TuiLayoutType layoutType;
#endif
@


1.5
log
@Replace free() with xfree().
@
text
@d1 3
a3 4
/*
   ** tuiLayout.c
   ** This module contains procedures for handling the layout of the windows.
 */
d5 16
@


1.4
log
@Protoization.
@
text
@d606 1
a606 1
	  free (bufPtr);
@


1.3
log
@PARAMS elimination.
@
text
@d468 1
a468 1
_initialize_tuiLayout ()
@


1.2
log
@PARAMS removal.
@
text
@d23 4
a26 8
static void _initGenWinInfo PARAMS
  ((TuiGenWinInfoPtr, TuiWinType, int, int, int, int));
static void _initAndMakeWin PARAMS
  ((Opaque *, TuiWinType, int, int, int, int, int));
static void _showSourceOrDisassemAndCommand PARAMS
  ((TuiLayoutType));
static void _makeSourceOrDisassemWindow PARAMS
  ((TuiWinInfoPtr *, TuiWinType, int, int));
d29 1
a29 2
static void _makeDisassemWindow PARAMS
  ((TuiWinInfoPtr *, int, int));
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
** tuiLayout.c
** This module contains procedures for handling the layout of the windows.
*/
d31 2
a32 2
static void _makeCommandWindow PARAMS ((TuiWinInfoPtr *, int, int));
static void _makeSourceWindow PARAMS ((TuiWinInfoPtr *, int, int));
d35 15
a49 15
static void _makeDataWindow PARAMS ((TuiWinInfoPtr *, int, int));
static void _showSourceCommand PARAMS ((void));
static void _showDisassemCommand PARAMS ((void));
static void _showSourceDisassemCommand PARAMS ((void));
static void _showData PARAMS ((TuiLayoutType));
static TuiLayoutType _nextLayout PARAMS ((void));
static TuiLayoutType _prevLayout PARAMS ((void));
static void _tuiLayout_command PARAMS ((char *, int));
static void _tuiToggleLayout_command PARAMS ((char *, int));
static void _tui_vToggleLayout_command PARAMS ((va_list));
static void _tuiToggleSplitLayout_command PARAMS ((char *, int));
static void _tui_vToggleSplitLayout_command PARAMS ((va_list));
static Opaque _extractDisplayStartAddr PARAMS ((void));
static void _tuiHandleXDBLayout PARAMS ((TuiLayoutDefPtr));
static TuiStatus _tuiSetLayoutTo PARAMS ((char *));
d68 3
a70 3
** showLayout().
**        Show the screen layout defined
*/
d85 4
a88 4
        ** Since the new layout may cause changes in window size, we
        ** should free the content and reallocate on next display of
        ** source/asm
        */
d130 7
a136 7
** tuiSetLayout()
**    Function to set the layout to SRC_COMMAND, DISASSEM_COMMAND,
**    SRC_DISASSEM_COMMAND, SRC_DATA_COMMAND, or DISASSEM_DATA_COMMAND.
**    If the layout is SRC_DATA_COMMAND, DISASSEM_DATA_COMMAND, or
**    UNDEFINED_LAYOUT, then the data window is populated according
**    to regsDisplayType.
*/
d184 2
a185 2
                ** Now determine where focus should be
                */
d197 6
a202 6
                            ** code. this can happen if there is no
                            ** source available:
                            ** 1. if the source file is in another dir OR
                            ** 2. if target was compiled without -g
                            ** We still want to show the assembly though!
                            */
d211 6
a216 6
                            ** code. this can happen if there is no
                            ** source available:
                            ** 1. if the source file is in another dir OR
                            ** 2. if target was compiled without -g
                            ** We still want to show the assembly though!
                            */
d235 6
a240 6
                            ** code. this can happen if there is no
                            ** source available:
                            ** 1. if the source file is in another dir OR
                            ** 2. if target was compiled without -g
                            ** We still want to show the assembly though!
                            */
d257 2
a258 2
                ** Now update the window content
                */
d283 4
a286 4
** tui_vSetLayoutTo()
**        Function to set the layout to SRC, ASM, SPLIT, NEXT, PREV, DATA,
**        REGS, $REGS, $GREGS, $FREGS, $SREGS with arguments in a va_list
*/
d305 5
a309 5
** tuiAddWinToLayout().
**        Add the specified window to the layout in a logical way.
**        This means setting up the most logical layout given the
**        window to be added.
*/
d366 4
a369 4
** tui_vAddWinToLayout().
**        Add the specified window to the layout in a logical way,
**        with arguments in a va_list.
*/
d388 5
a392 5
** tuiDefaultWinHeight().
**        Answer the height of a window.  If it hasn't been created yet,
**        answer what the height of a window would be based upon its
**        type and the layout.
*/
d438 5
a442 5
** tuiDefaultWinViewportHeight().
**        Answer the height of a window.  If it hasn't been created yet,
**        answer what the height of a window would be based upon its
**        type and the layout.
*/
d468 4
a471 4
** _initialize_tuiLayout().
**        Function to initialize gdb commands, for tui window layout
**        manipulation.
*/
d510 4
a513 4
** _tuiSetLayoutTo()
**    Function to set the layout to SRC, ASM, SPLIT, NEXT, PREV, DATA, REGS,
**        $REGS, $GREGS, $FREGS, $SREGS.
*/
d770 3
a772 3
** _nextLayout().
**        Answer the previous layout to cycle to.
*/
d797 3
a799 3
** _prevLayout().
**        Answer the next layout to cycle to.
*/
d825 2
a826 2
** _makeCommandWindow().
*/
d855 2
a856 2
** _makeSourceWindow().
*/
d877 2
a878 2
** _makeDisassemWindow().
*/
d899 2
a900 2
** _makeDataWindow().
*/
d928 3
a930 3
**    _showSourceCommand().
**        Show the Source/Command layout
*/
d945 3
a947 3
**    _showDisassemCommand().
**        Show the Dissassem/Command layout
*/
d962 3
a964 3
**    _showSourceDisassemCommand().
**        Show the Source/Disassem/Command layout
*/
d1084 3
a1086 3
**    _showData().
**        Show the Source/Data/Command or the Dissassembly/Data/Command layout
*/
d1159 2
a1160 2
** _initGenWinInfo().
*/
d1200 2
a1201 2
** _initAndMakeWin().
*/
d1260 2
a1261 2
** _makeSourceOrDisassemWindow().
*/
d1280 2
a1281 2
    ** Create the exeuction info window.
    */
d1294 2
a1295 2
    ** Now create the source window.
    */
d1311 3
a1313 3
**    _showSourceOrDisassemAndCommand().
**        Show the Source/Command or the Disassem layout
*/
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d2 3
a4 3
   ** tuiLayout.c
   ** This module contains procedures for handling the layout of the windows.
 */
d68 3
a70 3
   ** showLayout().
   **        Show the screen layout defined
 */
d85 4
a88 4
         ** Since the new layout may cause changes in window size, we
         ** should free the content and reallocate on next display of
         ** source/asm
       */
d130 7
a136 7
   ** tuiSetLayout()
   **    Function to set the layout to SRC_COMMAND, DISASSEM_COMMAND,
   **    SRC_DISASSEM_COMMAND, SRC_DATA_COMMAND, or DISASSEM_DATA_COMMAND.
   **    If the layout is SRC_DATA_COMMAND, DISASSEM_DATA_COMMAND, or
   **    UNDEFINED_LAYOUT, then the data window is populated according
   **    to regsDisplayType.
 */
d184 2
a185 2
	         ** Now determine where focus should be
	       */
d197 6
a202 6
		         ** code. this can happen if there is no
		         ** source available:
		         ** 1. if the source file is in another dir OR
		         ** 2. if target was compiled without -g
		         ** We still want to show the assembly though!
		       */
d211 6
a216 6
		         ** code. this can happen if there is no
		         ** source available:
		         ** 1. if the source file is in another dir OR
		         ** 2. if target was compiled without -g
		         ** We still want to show the assembly though!
		       */
d235 6
a240 6
		         ** code. this can happen if there is no
		         ** source available:
		         ** 1. if the source file is in another dir OR
		         ** 2. if target was compiled without -g
		         ** We still want to show the assembly though!
		       */
d257 2
a258 2
	         ** Now update the window content
	       */
d283 4
a286 4
   ** tui_vSetLayoutTo()
   **        Function to set the layout to SRC, ASM, SPLIT, NEXT, PREV, DATA,
   **        REGS, $REGS, $GREGS, $FREGS, $SREGS with arguments in a va_list
 */
d305 5
a309 5
   ** tuiAddWinToLayout().
   **        Add the specified window to the layout in a logical way.
   **        This means setting up the most logical layout given the
   **        window to be added.
 */
d366 4
a369 4
   ** tui_vAddWinToLayout().
   **        Add the specified window to the layout in a logical way,
   **        with arguments in a va_list.
 */
d388 5
a392 5
   ** tuiDefaultWinHeight().
   **        Answer the height of a window.  If it hasn't been created yet,
   **        answer what the height of a window would be based upon its
   **        type and the layout.
 */
d438 5
a442 5
   ** tuiDefaultWinViewportHeight().
   **        Answer the height of a window.  If it hasn't been created yet,
   **        answer what the height of a window would be based upon its
   **        type and the layout.
 */
d468 4
a471 4
   ** _initialize_tuiLayout().
   **        Function to initialize gdb commands, for tui window layout
   **        manipulation.
 */
d510 4
a513 4
   ** _tuiSetLayoutTo()
   **    Function to set the layout to SRC, ASM, SPLIT, NEXT, PREV, DATA, REGS,
   **        $REGS, $GREGS, $FREGS, $SREGS.
 */
d770 3
a772 3
   ** _nextLayout().
   **        Answer the previous layout to cycle to.
 */
d797 3
a799 3
   ** _prevLayout().
   **        Answer the next layout to cycle to.
 */
d825 2
a826 2
   ** _makeCommandWindow().
 */
d855 2
a856 2
   ** _makeSourceWindow().
 */
d877 2
a878 2
   ** _makeDisassemWindow().
 */
d899 2
a900 2
   ** _makeDataWindow().
 */
d928 3
a930 3
   **    _showSourceCommand().
   **        Show the Source/Command layout
 */
d945 3
a947 3
   **    _showDisassemCommand().
   **        Show the Dissassem/Command layout
 */
d962 3
a964 3
   **    _showSourceDisassemCommand().
   **        Show the Source/Disassem/Command layout
 */
d1084 3
a1086 3
   **    _showData().
   **        Show the Source/Data/Command or the Dissassembly/Data/Command layout
 */
d1159 2
a1160 2
   ** _initGenWinInfo().
 */
d1200 2
a1201 2
   ** _initAndMakeWin().
 */
d1260 2
a1261 2
   ** _makeSourceOrDisassemWindow().
 */
d1280 2
a1281 2
     ** Create the exeuction info window.
   */
d1294 2
a1295 2
     ** Now create the source window.
   */
d1311 3
a1313 3
   **    _showSourceOrDisassemAndCommand().
   **        Show the Source/Command or the Disassem layout
 */
@

