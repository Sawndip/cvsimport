head	1.48;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.48
	gdb_7_6-2013-04-26-release:1.48
	gdb_7_6-branch:1.48.0.2
	gdb_7_6-2013-03-12-branchpoint:1.48
	gdb_7_5_1-2012-11-29-release:1.44
	gdb_7_5-2012-08-17-release:1.44
	gdb_7_5-branch:1.44.0.2
	gdb_7_5-2012-07-18-branchpoint:1.44
	gdb_7_4_1-2012-04-26-release:1.43.2.1
	gdb_7_4-2012-01-24-release:1.43.2.1
	gdb_7_4-branch:1.43.0.2
	gdb_7_4-2011-12-13-branchpoint:1.43
	gdb_7_3_1-2011-09-04-release:1.42
	gdb_7_3-2011-07-26-release:1.42
	gdb_7_3-branch:1.42.0.2
	gdb_7_3-2011-04-01-branchpoint:1.42
	gdb_7_2-2010-09-02-release:1.36
	gdb_7_2-branch:1.36.0.2
	gdb_7_2-2010-07-07-branchpoint:1.36
	gdb_7_1-2010-03-18-release:1.35
	gdb_7_1-branch:1.35.0.2
	gdb_7_1-2010-02-18-branchpoint:1.35
	gdb_7_0_1-2009-12-22-release:1.34
	gdb_7_0-2009-10-06-release:1.34
	gdb_7_0-branch:1.34.0.4
	gdb_7_0-2009-09-16-branchpoint:1.34
	arc-sim-20090309:1.30
	msnyder-checkpoint-072509-branch:1.34.0.2
	msnyder-checkpoint-072509-branchpoint:1.34
	arc-insight_6_8-branch:1.30.0.16
	arc-insight_6_8-branchpoint:1.30
	insight_6_8-branch:1.30.0.14
	insight_6_8-branchpoint:1.30
	reverse-20081226-branch:1.30.0.12
	reverse-20081226-branchpoint:1.30
	multiprocess-20081120-branch:1.30.0.10
	multiprocess-20081120-branchpoint:1.30
	reverse-20080930-branch:1.30.0.8
	reverse-20080930-branchpoint:1.30
	reverse-20080717-branch:1.30.0.6
	reverse-20080717-branchpoint:1.30
	msnyder-reverse-20080609-branch:1.30.0.4
	msnyder-reverse-20080609-branchpoint:1.30
	drow-reverse-20070409-branch:1.21.0.2
	drow-reverse-20070409-branchpoint:1.21
	gdb_6_8-2008-03-27-release:1.30
	gdb_6_8-branch:1.30.0.2
	gdb_6_8-2008-02-26-branchpoint:1.30
	gdb_6_7_1-2007-10-29-release:1.28
	gdb_6_7-2007-10-10-release:1.28
	gdb_6_7-branch:1.28.0.2
	gdb_6_7-2007-09-07-branchpoint:1.28
	insight_6_6-20070208-release:1.19
	gdb_6_6-2006-12-18-release:1.19
	gdb_6_6-branch:1.19.0.16
	gdb_6_6-2006-11-15-branchpoint:1.19
	insight_6_5-20061003-release:1.19
	gdb-csl-symbian-6_4_50_20060226-12:1.19.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.16
	nickrob-async-20060828-mergepoint:1.19
	gdb-csl-symbian-6_4_50_20060226-11:1.19.2.1
	gdb-csl-sourcerygxx-4_1-17:1.19.2.1
	gdb-csl-20060226-branch-local-2:1.19.2.1
	gdb-csl-sourcerygxx-4_1-14:1.19.2.1
	gdb-csl-sourcerygxx-4_1-13:1.19.2.1
	gdb-csl-sourcerygxx-4_1-12:1.19.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.19.2.1
	gdb_6_5-20060621-release:1.19
	gdb-csl-sourcerygxx-4_1-9:1.19.2.1
	gdb-csl-sourcerygxx-4_1-8:1.19.2.1
	gdb-csl-sourcerygxx-4_1-7:1.19.2.1
	gdb-csl-arm-2006q1-6:1.19.2.1
	gdb-csl-sourcerygxx-4_1-6:1.19.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.19.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.19.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.19.2.1
	gdb-csl-coldfire-4_1-11:1.19.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.19.2.1
	gdb-csl-coldfire-4_1-10:1.19.2.1
	gdb_6_5-branch:1.19.0.14
	gdb_6_5-2006-05-14-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-5:1.19.2.1
	nickrob-async-20060513-branch:1.19.0.12
	nickrob-async-20060513-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-4:1.19.2.1
	msnyder-reverse-20060502-branch:1.19.0.10
	msnyder-reverse-20060502-branchpoint:1.19
	gdb-csl-morpho-4_1-4:1.19.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.19.2.1
	readline_5_1-import-branch:1.19.0.8
	readline_5_1-import-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.19.2.1
	gdb-csl-symbian-20060226-branch:1.19.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.19.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.19.2.1
	msnyder-reverse-20060331-branch:1.19.0.6
	msnyder-reverse-20060331-branchpoint:1.19
	gdb-csl-available-20060303-branch:1.19.0.4
	gdb-csl-available-20060303-branchpoint:1.19
	gdb-csl-20060226-branch:1.19.0.2
	gdb-csl-20060226-branchpoint:1.19
	gdb_6_4-20051202-release:1.16
	msnyder-fork-checkpoint-branch:1.16.0.6
	msnyder-fork-checkpoint-branchpoint:1.16
	gdb-csl-gxxpro-6_3-branch:1.16.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.16
	gdb_6_4-branch:1.16.0.2
	gdb_6_4-2005-11-01-branchpoint:1.16
	gdb-csl-arm-20051020-branch:1.15.0.22
	gdb-csl-arm-20051020-branchpoint:1.15
	msnyder-tracepoint-checkpoint-branch:1.15.0.20
	msnyder-tracepoint-checkpoint-branchpoint:1.15
	gdb-csl-arm-20050325-2005-q1b:1.15
	gdb-csl-arm-20050325-2005-q1a:1.15
	csl-arm-20050325-branch:1.15.0.18
	csl-arm-20050325-branchpoint:1.15
	gdb-post-i18n-errorwarning-20050211:1.15
	gdb-pre-i18n-errorwarning-20050211:1.15
	gdb_6_3-20041109-release:1.15
	gdb_6_3-branch:1.15.0.14
	gdb_6_3-20041019-branchpoint:1.15
	drow_intercu-merge-20040921:1.15
	drow_intercu-merge-20040915:1.15
	jimb-gdb_6_2-e500-branch:1.15.0.16
	jimb-gdb_6_2-e500-branchpoint:1.15
	gdb_6_2-20040730-release:1.15
	gdb_6_2-branch:1.15.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.15
	gdb_6_1_1-20040616-release:1.15
	gdb_6_1-2004-04-05-release:1.15
	drow_intercu-merge-20040402:1.15
	drow_intercu-merge-20040327:1.15
	ezannoni_pie-20040323-branch:1.15.0.10
	ezannoni_pie-20040323-branchpoint:1.15
	ezannoni_pie-20030916-branch:1.15.0.8
	cagney_tramp-20040321-mergepoint:1.15
	cagney_tramp-20040309-branch:1.15.0.6
	cagney_tramp-20040309-branchpoint:1.15
	gdb_6_1-branch:1.15.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.15
	drow_intercu-20040221-branch:1.15.0.2
	drow_intercu-20040221-branchpoint:1.15
	cagney_bfdfile-20040213-branch:1.14.0.2
	cagney_bfdfile-20040213-branchpoint:1.14
	drow-cplus-branch:1.13.0.2
	drow-cplus-merge-20040208:1.11
	carlton_dictionary-branch:1.2.0.4
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.2
	cagney_bigcore-20040122-branchpoint:1.2;
locks; strict;
comment	@ * @;


1.48
date	2013.02.03.16.16.42;	author jkratoch;	state Exp;
branches;
next	1.47;

1.47
date	2013.02.03.16.05.09;	author jkratoch;	state Exp;
branches;
next	1.46;

1.46
date	2013.02.03.15.57.07;	author jkratoch;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.01.06.41.30;	author brobecke;	state Exp;
branches;
next	1.44;

1.44
date	2012.01.04.08.27.59;	author brobecke;	state Exp;
branches;
next	1.43;

1.43
date	2011.12.06.18.54.43;	author tromey;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2011.03.25.09.57.37;	author ktietz;	state Exp;
branches;
next	1.41;

1.41
date	2011.03.03.17.28.45;	author msnyder;	state Exp;
branches;
next	1.40;

1.40
date	2011.02.27.16.25.38;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2011.01.07.20.24.18;	author msnyder;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.06.00.57.05;	author msnyder;	state Exp;
branches;
next	1.37;

1.37
date	2011.01.01.15.33.53;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.17.22.21.43;	author msnyder;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.01.07.32.07;	author brobecke;	state Exp;
branches;
next	1.34;

1.34
date	2009.07.02.17.17.42;	author uweigand;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.18.21.28.39;	author palves;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.18.17.05.49;	author palves;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.03.05.58.08;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2008.01.01.22.53.22;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.22.19.06.59;	author vprus;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.23.18.08.50;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2007.08.15.00.19.44;	author msnyder;	state Exp;
branches;
next	1.26;

1.26
date	2007.08.14.23.50.39;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.14.21.39.22;	author msnyder;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.14.21.20.09;	author msnyder;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.14.20.23.29;	author msnyder;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.13.23.06.34;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.27.19.46.04;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.09.17.59.15;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.14.19.05.40;	author aoliva;	state Exp;
branches
	1.19.2.1
	1.19.4.1;
next	1.18;

1.18
date	2006.02.14.18.45.14;	author aoliva;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.23.19.10.03;	author eliz;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.01.17.40.25;	author ams;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.16.21.05.09;	author cagney;	state Exp;
branches
	1.15.8.1;
next	1.14;

1.14
date	2004.02.10.19.08.19;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.08.01.32.26;	author cagney;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2004.02.08.00.05.16;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.07.20.57.02;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.07.17.46.14;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.07.16.31.22;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.07.04.40.36;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.07.01.40.25;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.07.01.02.54;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.06.23.55.34;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.06.22.42.18;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.28.23.16.50;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.20.21.56.22;	author cagney;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2004.01.19.04.31.51;	author cagney;	state Exp;
branches;
next	;

1.43.2.1
date	2012.01.06.04.54.36;	author brobecke;	state Exp;
branches;
next	;

1.19.2.1
date	2006.04.03.00.47.41;	author drow;	state Exp;
branches;
next	;

1.19.4.1
date	2006.04.02.21.52.40;	author drow;	state Exp;
branches;
next	;

1.15.8.1
date	2004.03.23.20.09.16;	author ezannoni;	state Exp;
branches;
next	;

1.13.2.1
date	2004.02.09.19.43.58;	author drow;	state Exp;
branches;
next	;

1.2.4.1
date	2004.01.26.19.11.45;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.48
log
@gdb/
	* source.c (print_source_lines_base): Print for TUI also "fullname".
	* tui/tui-data.c (init_content_element): Change tui_locator_element
	field to full_name.
	* tui/tui-data.h (struct tui_locator_element): Likewise.
	* tui/tui-disasm.c (tui_show_disassem_and_update_source): Rename
	tui_update_locator_filename calls to tui_update_locator_fullname.
	Replace symtab->filename refererence by symtab_to_fullname call.
	* tui/tui-out.c (tui_field_string): Check for "fullname" now.
	* tui/tui-source.c (tui_set_source_content): Change tui_locator_element
	field to full_name.  Replace symtab->filename refererence by
	symtab_to_fullname call.
	(tui_show_symtab_source): Rename parameter to fullname.  Change
	tui_locator_element field to full_name.
	* tui/tui-stack.c: Include source.h.
	(tui_set_locator_filename): Rename the declaration to ...
	(tui_set_locator_fullname): ... here.  Rename its parameter to
	fullname, updates its comment.
	(tui_set_locator_info): Rename its parameter to fullname.
	(tui_set_locator_filename): Rename the definition to ...
	(tui_set_locator_fullname): ... here.  Rename its parameter to
	fullname, updates its comment.  Change tui_locator_element field to
	full_name.
	(tui_set_locator_info): Rename its parameter to fullname.
	(tui_set_locator_info): Rename callee to tui_set_locator_fullname.
	(tui_update_locator_filename): Rename to ...
	(tui_update_locator_fullname): ... here. Rename callee to
	tui_set_locator_fullname.
	(tui_show_frame_info): Replace symtab->filename refererence by
	symtab_to_fullname call.
	* tui/tui-stack.h (tui_update_locator_filename): Rename to ...
	(tui_update_locator_fullname): ... here.
	* tui/tui-winsource.c (tui_display_main): Rename the callee to
	tui_update_locator_fullname.  Replace symtab->filename refererence by
	symtab_to_fullname call.
	* tui/tui.c (tui_show_source): Rename its parameter to fullname.
	Rename the callee to tui_update_locator_fullname.
	* tui/tui.h (tui_show_source): Rename its parameter to fullname.
@
text
@/* TUI display source/assembly window.

   Copyright (C) 1998-2013 Free Software Foundation, Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include <ctype.h>
#include "symtab.h"
#include "frame.h"
#include "breakpoint.h"
#include "value.h"
#include "source.h"
#include "objfiles.h"
#include "filenames.h"

#include "tui/tui.h"
#include "tui/tui-data.h"
#include "tui/tui-stack.h"
#include "tui/tui-win.h"
#include "tui/tui-wingeneral.h"
#include "tui/tui-winsource.h"
#include "tui/tui-source.h"
#include "tui/tui-disasm.h"

#include "gdb_string.h"
#include "gdb_curses.h"
#include "gdb_assert.h"

/* Function to display the "main" routine.  */
void
tui_display_main (void)
{
  if ((tui_source_windows ())->count > 0)
    {
      struct gdbarch *gdbarch;
      CORE_ADDR addr;

      tui_get_begin_asm_address (&gdbarch, &addr);
      if (addr != (CORE_ADDR) 0)
	{
	  struct symtab_and_line sal;

	  tui_update_source_windows_with_addr (gdbarch, addr);
	  sal = find_pc_line (addr, 0);
          if (sal.symtab)
             tui_update_locator_fullname (symtab_to_fullname (sal.symtab));
          else
             tui_update_locator_fullname ("??");
	}
    }
}



/* Function to display source in the source window.  This function
   initializes the horizontal scroll to 0.  */
void
tui_update_source_window (struct tui_win_info *win_info,
			  struct gdbarch *gdbarch,
			  struct symtab *s,
			  struct tui_line_or_address line_or_addr,
			  int noerror)
{
  win_info->detail.source_info.horizontal_offset = 0;
  tui_update_source_window_as_is (win_info, gdbarch, s, line_or_addr, noerror);

  return;
}


/* Function to display source in the source/asm window.  This function
   shows the source as specified by the horizontal offset.  */
void
tui_update_source_window_as_is (struct tui_win_info *win_info, 
				struct gdbarch *gdbarch,
				struct symtab *s,
				struct tui_line_or_address line_or_addr, 
				int noerror)
{
  enum tui_status ret;

  if (win_info->generic.type == SRC_WIN)
    ret = tui_set_source_content (s, line_or_addr.u.line_no, noerror);
  else
    ret = tui_set_disassem_content (gdbarch, line_or_addr.u.addr);

  if (ret == TUI_FAILURE)
    {
      tui_clear_source_content (win_info, EMPTY_SOURCE_PROMPT);
      tui_clear_exec_info_content (win_info);
    }
  else
    {
      tui_update_breakpoint_info (win_info, 0);
      tui_show_source_content (win_info);
      tui_update_exec_info (win_info);
      if (win_info->generic.type == SRC_WIN)
	{
	  struct symtab_and_line sal;
	  
	  init_sal (&sal);
	  sal.line = line_or_addr.u.line_no +
	    (win_info->generic.content_size - 2);
	  sal.symtab = s;
	  sal.pspace = s->objfile->pspace;
	  set_current_source_symtab_and_line (&sal);
	  /* If the focus was in the asm win, put it in the src win if
	     we don't have a split layout.  */
	  if (tui_win_with_focus () == TUI_DISASM_WIN
	      && tui_current_layout () != SRC_DISASSEM_COMMAND)
	    tui_set_win_focus_to (TUI_SRC_WIN);
	}
    }


  return;
}


/* Function to ensure that the source and/or disassemly windows
   reflect the input address.  */
void
tui_update_source_windows_with_addr (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  if (addr != 0)
    {
      struct symtab_and_line sal;
      struct tui_line_or_address l;
      
      switch (tui_current_layout ())
	{
	case DISASSEM_COMMAND:
	case DISASSEM_DATA_COMMAND:
	  tui_show_disassem (gdbarch, addr);
	  break;
	case SRC_DISASSEM_COMMAND:
	  tui_show_disassem_and_update_source (gdbarch, addr);
	  break;
	default:
	  sal = find_pc_line (addr, 0);
	  l.loa = LOA_LINE;
	  l.u.line_no = sal.line;
	  tui_show_symtab_source (gdbarch, sal.symtab, l, FALSE);
	  break;
	}
    }
  else
    {
      int i;

      for (i = 0; i < (tui_source_windows ())->count; i++)
	{
	  struct tui_win_info *win_info = (tui_source_windows ())->list[i];

	  tui_clear_source_content (win_info, EMPTY_SOURCE_PROMPT);
	  tui_clear_exec_info_content (win_info);
	}
    }
}

/* Function to ensure that the source and/or disassemly windows
   reflect the input address.  */
void
tui_update_source_windows_with_line (struct symtab *s, int line)
{
  struct gdbarch *gdbarch;
  CORE_ADDR pc;
  struct tui_line_or_address l;

  if (!s)
    return;

  gdbarch = get_objfile_arch (s->objfile);

  switch (tui_current_layout ())
    {
    case DISASSEM_COMMAND:
    case DISASSEM_DATA_COMMAND:
      find_line_pc (s, line, &pc);
      tui_update_source_windows_with_addr (gdbarch, pc);
      break;
    default:
      l.loa = LOA_LINE;
      l.u.line_no = line;
      tui_show_symtab_source (gdbarch, s, l, FALSE);
      if (tui_current_layout () == SRC_DISASSEM_COMMAND)
	{
	  find_line_pc (s, line, &pc);
	  tui_show_disassem (gdbarch, pc);
	}
      break;
    }

  return;
}

void
tui_clear_source_content (struct tui_win_info *win_info, 
			  int display_prompt)
{
  if (win_info != NULL)
    {
      int i;

      win_info->generic.content_in_use = FALSE;
      tui_erase_source_content (win_info, display_prompt);
      for (i = 0; i < win_info->generic.content_size; i++)
	{
	  struct tui_win_element *element =
	    (struct tui_win_element *) win_info->generic.content[i];

	  element->which_element.source.has_break = FALSE;
	  element->which_element.source.is_exec_point = FALSE;
	}
    }
}


void
tui_erase_source_content (struct tui_win_info *win_info, 
			  int display_prompt)
{
  int x_pos;
  int half_width = (win_info->generic.width - 2) / 2;

  if (win_info->generic.handle != (WINDOW *) NULL)
    {
      werase (win_info->generic.handle);
      tui_check_and_display_highlight_if_needed (win_info);
      if (display_prompt == EMPTY_SOURCE_PROMPT)
	{
	  char *no_src_str;

	  if (win_info->generic.type == SRC_WIN)
	    no_src_str = NO_SRC_STRING;
	  else
	    no_src_str = NO_DISASSEM_STRING;
	  if (strlen (no_src_str) >= half_width)
	    x_pos = 1;
	  else
	    x_pos = half_width - strlen (no_src_str);
	  mvwaddstr (win_info->generic.handle,
		     (win_info->generic.height / 2),
		     x_pos,
		     no_src_str);

	  /* elz: Added this function call to set the real contents of
	     the window to what is on the screen, so that later calls
	     to refresh, do display the correct stuff, and not the old
	     image.  */

	  tui_set_source_content_nil (win_info, no_src_str);
	}
      tui_refresh_win (&win_info->generic);
    }
}


/* Redraw the complete line of a source or disassembly window.  */
static void
tui_show_source_line (struct tui_win_info *win_info, int lineno)
{
  struct tui_win_element *line;
  int x, y;

  line = (struct tui_win_element *) win_info->generic.content[lineno - 1];
  if (line->which_element.source.is_exec_point)
    wattron (win_info->generic.handle, A_STANDOUT);

  mvwaddstr (win_info->generic.handle, lineno, 1,
             line->which_element.source.line);
  if (line->which_element.source.is_exec_point)
    wattroff (win_info->generic.handle, A_STANDOUT);

  /* Clear to end of line but stop before the border.  */
  getyx (win_info->generic.handle, y, x);
  while (x + 1 < win_info->generic.width)
    {
      waddch (win_info->generic.handle, ' ');
      getyx (win_info->generic.handle, y, x);
    }
}

void
tui_show_source_content (struct tui_win_info *win_info)
{
  if (win_info->generic.content_size > 0)
    {
      int lineno;

      for (lineno = 1; lineno <= win_info->generic.content_size; lineno++)
        tui_show_source_line (win_info, lineno);
    }
  else
    tui_erase_source_content (win_info, TRUE);

  tui_check_and_display_highlight_if_needed (win_info);
  tui_refresh_win (&win_info->generic);
  win_info->generic.content_in_use = TRUE;
}


/* Scroll the source forward or backward horizontally.  */
void
tui_horizontal_source_scroll (struct tui_win_info *win_info,
			      enum tui_scroll_direction direction,
			      int num_to_scroll)
{
  if (win_info->generic.content != NULL)
    {
      struct gdbarch *gdbarch = win_info->detail.source_info.gdbarch;
      int offset;
      struct symtab *s = NULL;

      if (win_info->generic.type == SRC_WIN)
	{
	  struct symtab_and_line cursal
	    = get_current_source_symtab_and_line ();

	  if (cursal.symtab == NULL)
	    s = find_pc_symtab (get_frame_pc (get_selected_frame (NULL)));
	  else
	    s = cursal.symtab;
	}

      if (direction == LEFT_SCROLL)
	offset = win_info->detail.source_info.horizontal_offset
	  + num_to_scroll;
      else
	{
	  offset = win_info->detail.source_info.horizontal_offset
	    - num_to_scroll;
	  if (offset < 0)
	    offset = 0;
	}
      win_info->detail.source_info.horizontal_offset = offset;
      tui_update_source_window_as_is (win_info, gdbarch, s,
				      ((struct tui_win_element *)
				       win_info->generic.content[0])->which_element.source.line_or_addr,
				      FALSE);
    }

  return;
}


/* Set or clear the has_break flag in the line whose line is
   line_no.  */

void
tui_set_is_exec_point_at (struct tui_line_or_address l, 
			  struct tui_win_info *win_info)
{
  int changed = 0;
  int i;
  tui_win_content content = (tui_win_content) win_info->generic.content;

  i = 0;
  while (i < win_info->generic.content_size)
    {
      int new_state;
      struct tui_line_or_address content_loa =
	content[i]->which_element.source.line_or_addr;

      gdb_assert (l.loa == LOA_ADDRESS || l.loa == LOA_LINE);
      gdb_assert (content_loa.loa == LOA_LINE
		  || content_loa.loa == LOA_ADDRESS);
      if (content_loa.loa == l.loa
	  && ((l.loa == LOA_LINE && content_loa.u.line_no == l.u.line_no)
              || (content_loa.u.addr == l.u.addr)))
        new_state = TRUE;
      else
	new_state = FALSE;
      if (new_state != content[i]->which_element.source.is_exec_point)
        {
          changed++;
          content[i]->which_element.source.is_exec_point = new_state;
          tui_show_source_line (win_info, i + 1);
        }
      i++;
    }
  if (changed)
    tui_refresh_win (&win_info->generic);
}

/* Update the execution windows to show the active breakpoints.
   This is called whenever a breakpoint is inserted, removed or
   has its state changed.  */
void
tui_update_all_breakpoint_info (void)
{
  struct tui_list *list = tui_source_windows ();
  int i;

  for (i = 0; i < list->count; i++)
    {
      struct tui_win_info *win = list->list[i];

      if (tui_update_breakpoint_info (win, FALSE))
        {
          tui_update_exec_info (win);
        }
    }
}


/* Scan the source window and the breakpoints to update the has_break
   information for each line.

   Returns 1 if something changed and the execution window must be
   refreshed.  */

int
tui_update_breakpoint_info (struct tui_win_info *win, 
			    int current_only)
{
  int i;
  int need_refresh = 0;
  struct tui_source_info *src = &win->detail.source_info;

  for (i = 0; i < win->generic.content_size; i++)
    {
      struct breakpoint *bp;
      extern struct breakpoint *breakpoint_chain;
      int mode;
      struct tui_source_element *line;

      line = &((struct tui_win_element *)
	       win->generic.content[i])->which_element.source;
      if (current_only && !line->is_exec_point)
         continue;

      /* Scan each breakpoint to see if the current line has something to
         do with it.  Identify enable/disabled breakpoints as well as
         those that we already hit.  */
      mode = 0;
      for (bp = breakpoint_chain;
           bp != (struct breakpoint *) NULL;
           bp = bp->next)
        {
	  struct bp_location *loc;

	  gdb_assert (line->line_or_addr.loa == LOA_LINE
		      || line->line_or_addr.loa == LOA_ADDRESS);

	  for (loc = bp->loc; loc != NULL; loc = loc->next)
	    {
	      if ((win == TUI_SRC_WIN
		   && loc->symtab != NULL
		   && filename_cmp (src->fullname,
				    symtab_to_fullname (loc->symtab)) == 0
		   && line->line_or_addr.loa == LOA_LINE
		   && loc->line_number == line->line_or_addr.u.line_no)
		  || (win == TUI_DISASM_WIN
		      && line->line_or_addr.loa == LOA_ADDRESS
		      && loc->address == line->line_or_addr.u.addr))
		{
		  if (bp->enable_state == bp_disabled)
		    mode |= TUI_BP_DISABLED;
		  else
		    mode |= TUI_BP_ENABLED;
		  if (bp->hit_count)
		    mode |= TUI_BP_HIT;
		  if (bp->loc->cond)
		    mode |= TUI_BP_CONDITIONAL;
		  if (bp->type == bp_hardware_breakpoint)
		    mode |= TUI_BP_HARDWARE;
		}
	    }
        }
      if (line->has_break != mode)
        {
          line->has_break = mode;
          need_refresh = 1;
        }
    }
  return need_refresh;
}


/* Function to initialize the content of the execution info window,
   based upon the input window which is either the source or
   disassembly window.  */
enum tui_status
tui_set_exec_info_content (struct tui_win_info *win_info)
{
  enum tui_status ret = TUI_SUCCESS;

  if (win_info->detail.source_info.execution_info
      != (struct tui_gen_win_info *) NULL)
    {
      struct tui_gen_win_info *exec_info_ptr
	= win_info->detail.source_info.execution_info;

      if (exec_info_ptr->content == NULL)
	exec_info_ptr->content =
	  (void **) tui_alloc_content (win_info->generic.height,
					 exec_info_ptr->type);
      if (exec_info_ptr->content != NULL)
	{
	  int i;

          tui_update_breakpoint_info (win_info, 1);
	  for (i = 0; i < win_info->generic.content_size; i++)
	    {
	      struct tui_win_element *element;
	      struct tui_win_element *src_element;
              int mode;

	      element = (struct tui_win_element *) exec_info_ptr->content[i];
	      src_element = (struct tui_win_element *)
		win_info->generic.content[i];

              memset(element->which_element.simple_string, ' ',
                     sizeof(element->which_element.simple_string));
              element->which_element.simple_string[TUI_EXECINFO_SIZE - 1] = 0;

	      /* Now update the exec info content based upon the state
                 of each line as indicated by the source content.  */
              mode = src_element->which_element.source.has_break;
              if (mode & TUI_BP_HIT)
                element->which_element.simple_string[TUI_BP_HIT_POS] =
                  (mode & TUI_BP_HARDWARE) ? 'H' : 'B';
              else if (mode & (TUI_BP_ENABLED | TUI_BP_DISABLED))
                element->which_element.simple_string[TUI_BP_HIT_POS] =
                  (mode & TUI_BP_HARDWARE) ? 'h' : 'b';

              if (mode & TUI_BP_ENABLED)
                element->which_element.simple_string[TUI_BP_BREAK_POS] = '+';
              else if (mode & TUI_BP_DISABLED)
                element->which_element.simple_string[TUI_BP_BREAK_POS] = '-';

              if (src_element->which_element.source.is_exec_point)
                element->which_element.simple_string[TUI_EXEC_POS] = '>';
	    }
	  exec_info_ptr->content_size = win_info->generic.content_size;
	}
      else
	ret = TUI_FAILURE;
    }

  return ret;
}


void
tui_show_exec_info_content (struct tui_win_info *win_info)
{
  struct tui_gen_win_info *exec_info
    = win_info->detail.source_info.execution_info;
  int cur_line;

  werase (exec_info->handle);
  tui_refresh_win (exec_info);
  for (cur_line = 1; (cur_line <= exec_info->content_size); cur_line++)
    mvwaddstr (exec_info->handle,
	       cur_line,
	       0,
	       ((struct tui_win_element *)
		exec_info->content[cur_line - 1])->which_element.simple_string);
  tui_refresh_win (exec_info);
  exec_info->content_in_use = TRUE;
}


void
tui_erase_exec_info_content (struct tui_win_info *win_info)
{
  struct tui_gen_win_info *exec_info
    = win_info->detail.source_info.execution_info;

  werase (exec_info->handle);
  tui_refresh_win (exec_info);
}

void
tui_clear_exec_info_content (struct tui_win_info *win_info)
{
  win_info->detail.source_info.execution_info->content_in_use = FALSE;
  tui_erase_exec_info_content (win_info);

  return;
}

/* Function to update the execution info window.  */
void
tui_update_exec_info (struct tui_win_info *win_info)
{
  tui_set_exec_info_content (win_info);
  tui_show_exec_info_content (win_info);
}

enum tui_status
tui_alloc_source_buffer (struct tui_win_info *win_info)
{
  char *src_line_buf;
  int i, line_width, max_lines;

  max_lines = win_info->generic.height;	/* Less the highlight box.  */
  line_width = win_info->generic.width - 1;
  /*
   * Allocate the buffer for the source lines.  Do this only once
   * since they will be re-used for all source displays.  The only
   * other time this will be done is when a window's size changes.
   */
  if (win_info->generic.content == NULL)
    {
      src_line_buf = (char *) 
	xmalloc ((max_lines * line_width) * sizeof (char));
      if (src_line_buf == (char *) NULL)
	{
	  fputs_unfiltered ("Unable to Allocate Memory for "
			    "Source or Disassembly Display.\n",
			    gdb_stderr);
	  return TUI_FAILURE;
	}
      /* Allocate the content list.  */
      if ((win_info->generic.content =
	   (void **) tui_alloc_content (max_lines, SRC_WIN)) == NULL)
	{
	  xfree (src_line_buf);
	  fputs_unfiltered ("Unable to Allocate Memory for "
			    "Source or Disassembly Display.\n",
			    gdb_stderr);
	  return TUI_FAILURE;
	}
      for (i = 0; i < max_lines; i++)
	((struct tui_win_element *)
	 win_info->generic.content[i])->which_element.source.line =
	  src_line_buf + (line_width * i);
    }

  return TUI_SUCCESS;
}


/* Answer whether a particular line number or address is displayed
   in the current source window.  */
int
tui_line_is_displayed (int line, 
		       struct tui_win_info *win_info,
		       int check_threshold)
{
  int is_displayed = FALSE;
  int i, threshold;

  if (check_threshold)
    threshold = SCROLL_THRESHOLD;
  else
    threshold = 0;
  i = 0;
  while (i < win_info->generic.content_size - threshold
	 && !is_displayed)
    {
      is_displayed = (((struct tui_win_element *)
		       win_info->generic.content[i])->which_element.source.line_or_addr.loa
		      == LOA_LINE)
	&& (((struct tui_win_element *)
	     win_info->generic.content[i])->which_element.source.line_or_addr.u.line_no
	    == (int) line);
      i++;
    }

  return is_displayed;
}


/* Answer whether a particular line number or address is displayed
   in the current source window.  */
int
tui_addr_is_displayed (CORE_ADDR addr, 
		       struct tui_win_info *win_info,
		       int check_threshold)
{
  int is_displayed = FALSE;
  int i, threshold;

  if (check_threshold)
    threshold = SCROLL_THRESHOLD;
  else
    threshold = 0;
  i = 0;
  while (i < win_info->generic.content_size - threshold
	 && !is_displayed)
    {
      is_displayed = (((struct tui_win_element *)
		       win_info->generic.content[i])->which_element.source.line_or_addr.loa
		      == LOA_ADDRESS)
	&& (((struct tui_win_element *)
	     win_info->generic.content[i])->which_element.source.line_or_addr.u.addr
	    == addr);
      i++;
    }

  return is_displayed;
}


/*****************************************
** STATIC LOCAL FUNCTIONS               **
******************************************/
@


1.47
log
@gdb/
	* tui/tui-data.c (init_win_info, tui_del_window, tui_free_window):
	Rename field reference filename to fullname.
	* tui/tui-data.h (struct tui_source_info): Rename field filename to
	fullname.  New comment for it.
	* tui/tui-source.c (tui_set_source_content): Rename field reference
	filename to fullname.  Initialize field by symtab_to_fullname now.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Rename field
	reference filename to fullname.  Use symtab_to_fullname during
	comparison.
@
text
@d62 1
a62 1
             tui_update_locator_filename (sal.symtab->filename);
d64 1
a64 1
             tui_update_locator_filename ("??");
@


1.46
log
@gdb/
	Code cleanup.
	* breakpoint.c (print_breakpoint_location): Replace bp_location field
	source_file references by symtab field references.  Remove variables
	sal and fullname.
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	(clear_command, say_where): Replace bp_location field source_file
	references by symtab field references.
	(bp_location_dtor): Remove the source_file reference.
	(update_static_tracepoint): Replace bp_location field source_file
	references by symtab field references.
	(breakpoint_free_objfile): New function.
	* breakpoint.h (struct bp_location): Extend the comment for line_number.
	Replace the field source_file by field symtab, extend its comment.
	(breakpoint_free_objfile): New declaration.
	* objfiles.c (free_objfile): Call breakpoint_free_objfile.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Replace bp_location
	field source_file references by symtab field references.
@
text
@d466 2
a467 1
		   && (filename_cmp (src->filename, loc->symtab->filename) == 0)
@


1.45
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d465 2
a466 2
		   && loc->source_file
		   && (filename_cmp (src->filename, loc->source_file) == 0)
@


1.44
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 1998-2004, 2006-2012 Free Software Foundation, Inc.
@


1.43
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d3 1
a3 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007, 2008,
   2009, 2010, 2011 Free Software Foundation, Inc.
@


1.43.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1998-2004, 2006-2012 Free Software Foundation, Inc.
@


1.42
log
@2011-03-25  Kai Tietz  <ktietz@@redhat.com>

        * tui/tui-source.c (tui_set_source_content): Use filename_cmp
        instead of strcmp for comparison.
        (tui_source_is_displayed): Likewise.
        * tui/tui-winsource.c (tui_update_breakpoint_info): Likewise.
@
text
@d458 2
d462 24
a485 21
          if ((win == TUI_SRC_WIN
               && bp->source_file
               && (filename_cmp (src->filename, bp->source_file) == 0)
	       && line->line_or_addr.loa == LOA_LINE
               && bp->line_number == line->line_or_addr.u.line_no)
              || (win == TUI_DISASM_WIN
		  && line->line_or_addr.loa == LOA_ADDRESS
		  && bp->loc != NULL
                  && bp->loc->address == line->line_or_addr.u.addr))
            {
              if (bp->enable_state == bp_disabled)
                mode |= TUI_BP_DISABLED;
              else
                mode |= TUI_BP_ENABLED;
              if (bp->hit_count)
                mode |= TUI_BP_HIT;
              if (bp->loc->cond)
                mode |= TUI_BP_CONDITIONAL;
              if (bp->type == bp_hardware_breakpoint)
                mode |= TUI_BP_HARDWARE;
            }
@


1.41
log
@2011-03-03  Michael Snyder  <msnyder@@vmware.com>

	* tui/tui-winsource.c (tui_update_source_window_as_is): Initialize
	sal.pspace before calling set_current_source_symtab_and_line.
@
text
@d31 1
d462 1
a462 1
               && (strcmp (src->filename, bp->source_file) == 0)
@


1.40
log
@2011-02-27  Michael Snyder  <msnyder@@vmware.com>

	* darwin-nat-info.c: Fix comment typo.
	* dwarf2expr.h: Ditto.
	* fbsd-nat.c: Ditto.
	* fbsd-nat.h: Ditto.
	* frame-unwind.h: Ditto.
	* frame.h: Ditto.
	* hppa-hpux-tdep.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* linux-nat.c: Ditto.
	* nbsd-nat.c: Ditto.
	* nbsd-nat.h: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* serial.c: Ditto.
	* ui-file.h: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d117 1
d121 1
@


1.39
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Mark up error message
	for i18n.
	* tui/tui-layout.c (tui_set_layout_for_display_command):
	Split line so that operator goes to beginning of line.
	* tui/tui-winsource.c (tui_horizontal_source_scroll): Move
	assignment out of if statement.
@
text
@d645 1
a645 1
/* Answer whether the a particular line number or address is displayed
d676 1
a676 1
/* Answer whether the a particular line number or address is displayed
@


1.38
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-cmds.c: Shorten lines of >= 80 columns.
	* cli/cli-decode.c: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-setshow.c: Ditto.
	* common/signals.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-disas.c: Ditto.
	* mi/mi-cmd-stack.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-cmds.c: Ditto.
	* mi/mi-common.h: Ditto.
	* mi/mi-console.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
	* osf-share/cma_attr.c: Ditto.
	* osf-share/cma_deb_core.h: Ditto.
	* osf-share/cma_debug_client.h: Ditto.
	* osf-share/cma_handle.h: Ditto.
	* osf-share/cma_mutex.h: Ditto.
	* osf-share/cma_stack_int.h: Ditto.
	* osf-share/cma_tcb_defs.h: Ditto.
	* python/py-auto-load.c: Ditto.
	* python/py-breakpoint.c: Ditto.
	* python/py-cmd.c: Ditto.
	* python/py-frame.c: Ditto.
	* python/py-objfile.c: Ditto.
	* python/py-param.c: Ditto.
	* python/py-progspace.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-value.c: Ditto.
	* python/python-internal.h: Ditto.
	* python/python.c: Ditto.
	* tui/tui-data.c: Ditto.
	* tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c: Ditto.
	* tui/tui-io.c: Ditto.
	* tui/tui-layout.c: Ditto.
	* tui/tui-regs.c: Ditto.
	* tui/tui-source.c: Ditto.
	* tui/tui-stack.c: Ditto.
	* tui/tui-win.c: Ditto.
	* tui/tui-windata.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d345 3
a347 2
	  if ((offset = win_info->detail.source_info.horizontal_offset
	       - num_to_scroll) < 0)
@


1.37
log
@run copyright.sh for 2011.
@
text
@d331 2
a332 1
	  struct symtab_and_line cursal = get_current_source_symtab_and_line ();
d341 2
a342 1
	offset = win_info->detail.source_info.horizontal_offset + num_to_scroll;
d345 2
a346 2
	  if ((offset =
	     win_info->detail.source_info.horizontal_offset - num_to_scroll) < 0)
d441 2
a442 1
      line = &((struct tui_win_element *) win->generic.content[i])->which_element.source;
d496 2
a497 1
  if (win_info->detail.source_info.execution_info != (struct tui_gen_win_info *) NULL)
d499 2
a500 1
      struct tui_gen_win_info *exec_info_ptr = win_info->detail.source_info.execution_info;
d518 2
a519 1
	      src_element = (struct tui_win_element *) win_info->generic.content[i];
d556 2
a557 1
  struct tui_gen_win_info *exec_info = win_info->detail.source_info.execution_info;
d576 2
a577 1
  struct tui_gen_win_info *exec_info = win_info->detail.source_info.execution_info;
d619 2
a620 1
	  fputs_unfiltered ("Unable to Allocate Memory for Source or Disassembly Display.\n",
d629 2
a630 1
	  fputs_unfiltered ("Unable to Allocate Memory for Source or Disassembly Display.\n",
@


1.36
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* tui/tui.c: White space.
	* tui/tui-data.c: White space.
	* tui/tui-disasm.c: White space.
	* tui/tui-file.c: White space.
	* tui/tui-interp.c: White space.
	* tui/tui-main.c: White space.
	* tui/tui-out.c: White space.
	* tui/tui-regs.c: White space.
	* tui/tui-source.c: White space.
	* tui/tui-stack.c: White space.
	* tui/tui-win.c: White space.
	* tui/tui-winsource.c: White space.
@
text
@d4 1
a4 1
   2009, 2010 Free Software Foundation, Inc.
@


1.35
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d224 2
a225 1
	  (struct tui_win_element *) win_info->generic.content[i];
d332 1
@


1.34
log
@	* disasm.h (gdb_disassembly): Add GDBARCH parameter.
	(gdb_print_insn): Likewise.
	* disasm.c (dump_insns): Add GDBARCH parameter.  Use it instead
	of current_gdbarch.
	(do_mixed_source_and_assembly): Add GDBARCH parameter.  Pass to
	dump_insns.
	(do_assembly_only): Likewise.
	(gdb_disassembly): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.  Pass to subroutines.
	(gdb_print_insn): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.

	* stack.c (struct gdb_disassembly_stub_args): Add GDBARCH member.
	(gdb_disassembly_stub): Pass architecture to gdb_disassembly.
	(do_gdb_disassembly): Add GDBARCH argument.  Store into args.
	(print_frame_info): Pass architecture to do_gdb_disassembly.

	* printcmd.c (print_formatted): Pass architecture to gdb_print_insn.

	* mi/mi-cmd-disas.c: Include "arch-utils.h"
	(mi_cmd_disassemble): Pass architecture to gdb_disassembly.

	* cli/cli-cmds.c: Include "arch-utils.h".
	(print_disassembly): Add GDBARCH parameter.  Pass to gdb_disassembly
	and tui_show_assembly.
	(disassemble_current_function): Pass architecture to
	tui_get_low_disassembly_address and print_disassembly.
	(disassemble_command): Pass architecture to
	tui_get_low_disassembly_address and print_disassembly.

	* tui/tui.c (tui_show_assembly): Add GDBARCH parameter.  Pass to
	tui_update_source_windows_with_addr.

	* tui/tui-data.h (struct tui_locator_element): Add GDBARCH member.
	(struct tui_source_info): Likewise.
	* tui/tui-data.c (tui_clear_win_detail): Clear source_info.gdbarch.

	* tui/tui-disasm.c (tui_disassemble): Add GDBARCH parameter.
	Pass to gdb_print_insn.
	(tui_find_disassembly_address): Add GDBARCH parameter.  Pass to
	tui_disassemble.
	(tui_set_disassem_content): Add GDBARCH parameter.  Install into
	source_info.gdbarch.  Pass to tui_disassemble.
	(tui_show_disassem): Add GDBARCH parameter.  Pass to
	tui_update_source_window.
	(tui_show_disassem_and_update_source): Add GDBARCH parameter.  Pass to
	tui_show_disassem and tui_update_source_window.

	(tui_get_begin_asm_address): Return locator architecture in addition
	to locator PC value.

	(tui_get_low_disassembly_address): Add GDBARCH parameter.   Pass to
	tui_get_low_disassembly_address.

	(tui_vertical_disassem_scroll): Pass architecture to subroutines.

	* tui/tui-disasm.h (tui_set_disassem_content): Add GDBARCH parameter.
	(tui_show_disassem): Likewise.
	(tui_show_disassem_and_update_source): Likewise.
	(tui_get_begin_asm_address): Return architecture and PC value.

	* tui/tui.h (tui_get_low_disassembly_address): Add GDBARCH parameter.
	(tui_show_assembly): Add GDBARCH parameter.

	* tui/tui-layout.c (extract_display_start_addr): Return current window
	architecture in addition to current PC value.

	(tui_set_layout): Update calls to tui_get_low_disassembly_address and
	extract_display_start_addr.  Pass architecture to
	tui_update_source_windows_with_addr.

	* tui/tui-source.c: Include "objfiles.h".
	(tui_set_source_content): Initialize window architecture.
	(tui_show_symtab_source): Add GDBARCH parameter.  Pass to
	tui_update_source_window_as_is

	* tui/tui-source.h (tui_show_symtab_source): Add GDBARCH parameter.

	* tui/tui-stack.c (tui_set_locator_info): Add GDBARCH parameter.
	Install locator architecture.
	(tui_set_locator_filename): Update call.
	(tui_show_frame_info): Pass architecture to tui_set_locator_info
	and subroutines.

	* tui/tui-win.c (make_visible_with_new_height): Pass architecture
	to tui_update_source_window.

	* tui/tui-winsource.c: Include "objfiles.h".
	(tui_display_main): Update call to tui_get_begin_asm_address.
	Pass architecture to tui_update_source_windows_with_addr.
	(tui_update_source_window): Add GDBARCH parameter.  Pass to
	tui_update_source_window_as_is.
	(tui_update_source_window_as_is): Add GDBARCH parameter.
	Pass to tui_set_disassem_content.
	(tui_update_source_windows_with_addr): Add GDBARCH parameter.
	Pass to subroutines.
	(tui_update_source_windows_with_line): Pass objfile architecture
	to subroutines.
	(tui_horizontal_source_scroll): Pass architecture to
	tui_update_source_window_as_is.

	* tui/tui-winsource.h (tui_update_source_window): Add GDBARCH
	parameter.
	(tui_update_source_window_as_is): Likewise.
	(tui_update_source_windows_with_addr): Likewise.
@
text
@d4 1
a4 1
   2009 Free Software Foundation, Inc.
@


1.33
log
@	* tui/tui-disasm.c (tui_vertical_disassem_scroll): Scroll one line
	at a time, times NUM_TO_SCROLL.
	* tui/tui-winsource.c (tui_horizontal_source_scroll): Don't try to
	fetch the selected frame if there is no stack.
@
text
@d30 1
d51 1
d54 1
a54 1
      addr = tui_get_begin_asm_address ();
d59 1
a59 1
	  tui_update_source_windows_with_addr (addr);
d75 1
d81 1
a81 1
  tui_update_source_window_as_is (win_info, s, line_or_addr, noerror);
d91 1
d101 1
a101 1
    ret = tui_set_disassem_content (line_or_addr.u.addr);
d137 1
a137 1
tui_update_source_windows_with_addr (CORE_ADDR addr)
d148 1
a148 1
	  tui_show_disassem (addr);
d151 1
a151 1
	  tui_show_disassem_and_update_source (addr);
d157 1
a157 1
	  tui_show_symtab_source (sal.symtab, l, FALSE);
d180 1
d183 6
a188 1
  
d194 1
a194 1
      tui_update_source_windows_with_addr (pc);
d199 1
a199 1
      tui_show_symtab_source (s, l, FALSE);
d203 1
a203 1
	  tui_show_disassem (pc);
d324 1
d346 1
a346 1
      tui_update_source_window_as_is (win_info, s,
@


1.32
log
@	* tui/tui-winsource.c (tui_update_breakpoint_info): In asm layout,
	skip breakpoints without a location (pending breakpoints).
@
text
@d315 1
a315 2
      struct symtab *s;
      struct symtab_and_line cursal = get_current_source_symtab_and_line ();
d317 8
a324 4
      if (cursal.symtab == (struct symtab *) NULL)
	s = find_pc_symtab (get_frame_pc (get_selected_frame (NULL)));
      else
	s = cursal.symtab;
@


1.31
log
@        Updated copyright notices for most files.
@
text
@d444 1
@


1.30
log
@	Updated copyright notices for most files.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007, 2008
   Free Software Foundation, Inc.
@


1.29
log
@	gdb/
	* breakpoint.h (struct breakpoint): Move the cond
	field to...
	(struct bp_location): Here.
	* breakpoint.c (condition_command, bpstat_stop_status)
	(print_one_breakpoint, allocate_bp_location)
	(solib_load_unload_1, create_fork_vfork_event_catchpoint)
	(create_exec_event_catchpoint, create_breakpoints)
	(break_command_1, watch_command_1, handle_gnu_v3_exceptions)
	(create_ada_exception_breakpoint, set_breakpoint_sal)
	(delete_breakpoint, breakpoint_re_set_one): Adjust.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Adjust.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007
@


1.28
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d452 1
a452 1
              if (bp->cond)
@


1.27
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-disasm.c, tui-file.c, tui-io.c,
	tui-layout.c, tui-regs.c, tui-source.c, tui-win.c, tui-windata.c,
	tui-wingeneral.c, tui-winsource.c: Coding standard, && and ||
	go at beginning of new line.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.26
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-data.c, tui-data.h, tui-disasm.c, tui-disasm.h, tui-hooks.c,
	tui-io.c, tui-layout.c, tui-layout.h, tui-out.c, tui-regs.c,
	tui-source.c, tui-source.h, tui-stack.c, tui-win.c, tui-win.h,
	tui-windata.c, tui-windata.h, tui-wingeneral.c, tui-winsource.c,
	tui-winsource.h, tui.c, tui.h: Function declarations and
	definitions, wrap long lines.
@
text
@d121 2
a122 2
	  if (tui_win_with_focus () == TUI_DISASM_WIN &&
	      tui_current_layout () != SRC_DISASSEM_COMMAND)
d634 2
a635 1
  while (i < win_info->generic.content_size - threshold && !is_displayed)
d638 1
a638 1
		      win_info->generic.content[i])->which_element.source.line_or_addr.loa
d640 3
a642 3
		     && (((struct tui_win_element *)
		      win_info->generic.content[i])->which_element.source.line_or_addr.u.line_no
		      == (int) line);
d665 2
a666 1
  while (i < win_info->generic.content_size - threshold && !is_displayed)
d669 1
a669 1
		      win_info->generic.content[i])->which_element.source.line_or_addr.loa
d671 3
a673 3
		     && (((struct tui_win_element *)
		      win_info->generic.content[i])->which_element.source.line_or_addr.u.addr
		      == addr);
@


1.25
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-disasm.c, tui-layout.c,
	tui-regs.c, tui-win.c, tui-windata.c, tui-winsource.c, tui.c:
	Reformat block comments to GNU standard.
@
text
@d74 4
a77 2
tui_update_source_window (struct tui_win_info *win_info, struct symtab *s,
			  struct tui_line_or_address line_or_addr, int noerror)
d89 4
a92 2
tui_update_source_window_as_is (struct tui_win_info *win_info, struct symtab *s,
				struct tui_line_or_address line_or_addr, int noerror)
d204 2
a205 1
tui_clear_source_content (struct tui_win_info *win_info, int display_prompt)
d225 2
a226 1
tui_erase_source_content (struct tui_win_info *win_info, int display_prompt)
d348 2
a349 1
tui_set_is_exec_point_at (struct tui_line_or_address l, struct tui_win_info *win_info)
d411 2
a412 1
tui_update_breakpoint_info (struct tui_win_info *win, int current_only)
d622 2
a623 1
tui_line_is_displayed (int line, struct tui_win_info *win_info,
d652 3
a654 2
tui_addr_is_displayed (CORE_ADDR addr, struct tui_win_info *win_info,
		    int check_threshold)
@


1.24
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-data.h, tui-disasm.c, tui-file.c,
	tui-hooks.c, tui-interp.c, tui-io.c, tui-layout.c, tui-out.c,
	tui-regs.c, tui-regs.h, tui-source.c, tui-stack.c, tui-win.c,
	tui-windata.c, tui-wingeneral.c, tui-winsource.c, tui-winsource.h,
	tui.c, tui.h: Comment reformatting to coding standard (capitals,
	spaces after periods, etc).
@
text
@d115 2
a116 4
	  /*
	     ** If the focus was in the asm win, put it in the src
	     ** win if we don't have a split layout.
	   */
@


1.23
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-data.c, tui-data.h, tui-disasm.c, tui-hooks.c, tui-layout.c,
	tui-regs.c, tui-source.c, tui-stack.c, tui-win.c, tui-windata.c,
	tui-wingeneral.c, tui-wingeneral.h, tui-winsource.c, tui.c,
	tui-winsource.h: Whitespace changes, fix pointer declarations
	to be consistant.
@
text
@d117 1
a117 1
	     ** win if we don't have a split layout
d248 4
a251 4
	  /* elz: added this function call to set the real contents of
	     the window to what is on the  screen, so that later calls
	     to refresh, do display
	     the correct stuff, and not the old image */
d340 3
a342 1
/* Set or clear the has_break flag in the line whose line is line_no.  */
d399 6
a404 4
/* Scan the source window and the breakpoints to update the
   has_break information for each line.
   Returns 1 if something changed and the execution window
   must be refreshed.  */
d577 1
a577 1
  max_lines = win_info->generic.height;	/* less the highlight box */
d594 1
a594 1
      /* allocate the content list */
@


1.22
log
@2007-08-13  Michael Snyder  <msnyder@@access-company.com>

	* tui/tui-winsource.c (tui_alloc_source_buffer): Clean up allocation.
@
text
@d74 1
a74 1
tui_update_source_window (struct tui_win_info * win_info, struct symtab *s,
d87 1
a87 1
tui_update_source_window_as_is (struct tui_win_info * win_info, struct symtab *s,
d163 1
a163 1
	  struct tui_win_info * win_info = (tui_source_windows ())->list[i];
d202 1
a202 1
tui_clear_source_content (struct tui_win_info * win_info, int display_prompt)
d212 1
a212 1
	  struct tui_win_element * element =
d222 1
a222 1
tui_erase_source_content (struct tui_win_info * win_info, int display_prompt)
d262 1
a262 1
tui_show_source_line (struct tui_win_info * win_info, int lineno)
d264 1
a264 1
  struct tui_win_element * line;
d286 1
a286 1
tui_show_source_content (struct tui_win_info * win_info)
d306 1
a306 1
tui_horizontal_source_scroll (struct tui_win_info * win_info,
d342 1
a342 1
tui_set_is_exec_point_at (struct tui_line_or_address l, struct tui_win_info * win_info)
d387 1
a387 1
      struct tui_win_info * win = list->list[i];
d402 1
a402 1
tui_update_breakpoint_info (struct tui_win_info * win, int current_only)
d406 1
a406 1
  struct tui_source_info * src = &win->detail.source_info;
d413 1
a413 1
      struct tui_source_element* line;
d464 1
a464 1
tui_set_exec_info_content (struct tui_win_info * win_info)
d470 1
a470 1
      struct tui_gen_win_info * exec_info_ptr = win_info->detail.source_info.execution_info;
d483 2
a484 2
	      struct tui_win_element * element;
	      struct tui_win_element * src_element;
d523 1
a523 1
tui_show_exec_info_content (struct tui_win_info * win_info)
d525 1
a525 1
  struct tui_gen_win_info * exec_info = win_info->detail.source_info.execution_info;
d542 1
a542 1
tui_erase_exec_info_content (struct tui_win_info * win_info)
d544 1
a544 1
  struct tui_gen_win_info * exec_info = win_info->detail.source_info.execution_info;
d551 1
a551 1
tui_clear_exec_info_content (struct tui_win_info * win_info)
d561 1
a561 1
tui_update_exec_info (struct tui_win_info * win_info)
d612 1
a612 1
tui_line_is_displayed (int line, struct tui_win_info * win_info,
d641 1
a641 1
tui_addr_is_displayed (CORE_ADDR addr, struct tui_win_info * win_info,
@


1.21
log
@	* frame.c (deprecated_selected_frame): Rename to...
	(selected_frame): ...this.  Make static.
	(get_selected_frame, select_frame): Update.
	* frame.h (deprected_select_frame): Delete.
	(deprecated_safe_get_selected_frame): Update comments.

	* breakpoint.c, cli/cli-cmds.c, f-valprint.c, infcmd.c, inflow.c,
	infrun.c, stack.c, tui/tui-disasm.c, tui/tui-source.c,
	tui/tui-winsource.c, valops.c, varobj.c, findvar.c, macroscope.c,
	parse.c, regcache.h, sh64-tdep.c, tui/tui-hooks.c, tui/tui-win.c,
	tui/tui.c: Replace references to deprecated_selected_frame.
@
text
@a571 1
  enum tui_status ret = TUI_FAILURE;
d576 3
a578 3
     ** Allocate the buffer for the source lines.  Do this only once since they
     ** will be re-used for all source displays.  The only other time this will
     ** be done is when a window's size changes.
d582 2
a583 1
      src_line_buf = (char *) xmalloc ((max_lines * line_width) * sizeof (char));
a584 4
	fputs_unfiltered (
	   "Unable to Allocate Memory for Source or Disassembly Display.\n",
			   gdb_stderr);
      else
d586 12
a597 10
	  /* allocate the content list */
	  if ((win_info->generic.content =
	  (void **) tui_alloc_content (max_lines, SRC_WIN)) == NULL)
	    {
	      xfree (src_line_buf);
	      src_line_buf = (char *) NULL;
	      fputs_unfiltered (
				 "Unable to Allocate Memory for Source or Disassembly Display.\n",
				 gdb_stderr);
	    }
a602 1
      ret = TUI_SUCCESS;
a603 2
  else
    ret = TUI_SUCCESS;
d605 1
a605 1
  return ret;
@


1.20
log
@Copyright updates for 2007.
@
text
@d317 1
a317 1
	s = find_pc_symtab (get_frame_pc (deprecated_selected_frame));
@


1.19
log
@Update copyright notice
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006
@


1.19.2.1
log
@Merge XML and VFP support to this branch.
@
text
@d317 1
a317 1
	s = find_pc_symtab (get_frame_pc (get_selected_frame (NULL)));
@


1.19.4.1
log
@Add a Debian patch that prevents some bogus "No selected frame" errors.
This needs to go to mainline separately.
@
text
@d317 1
a317 1
	s = find_pc_symtab (get_frame_pc (get_selected_frame (NULL)));
@


1.18
log
@* doublest.h (DOUBLEST): Use long double only if we can scan
it in.  Undefine HAVE_LONG_DOUBLE otherwise.
(DOUBLEST_FORMAT): New.
* c-exp.y (parse_number): Use it.
* jv-exp.y (parse_number): Likewise.
* objc-exp.y (parse_number): Likewise.
* p-exp.y (parse_number): Likewise.
* varobj.c (free_variable): Silence type-punning warnings.
* tui/tui-data.h (struct tui_list): Change type of list member.
* tui/tui-data.c: Remove no-longer-needed type casts.
(source_windows): Silence type-punning warnings.
* tui/tui-stack.c, tui/tui-win.c, tui/tui-winsource.c: Likewise.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
@


1.17
log
@	* tui/tui-file.c:
	* tui/tui-disasm.c:
	* tui/tui-data.h:
	* tui/tui-data.c:
	* tui/tui-command.h:
	* tui/tui-command.c:
	* tui/tui-win.h:
	* tui/tui-win.h:
	* tui/tui-win.c:
	* tui/tui-stack.h:
	* tui/tui-stack.c:
	* tui/tui-source.h:
	* tui/tui-source.c:
	* tui/tui-regs.h:
	* tui/tui-regs.c:
	* tui/tui-out.c:
	* tui/tui-main.c:
	* tui/tui-layout.h:
	* tui/tui-layout.c:
	* tui/tui-io.h:
	* tui/tui-io.c:
	* tui/tui-interp.c:
	* tui/tui-hooks.h:
	* tui/tui-hooks.c:
	* tui/tui-file.h:
	* tui/tui.h:
	* tui/tui.c:
	* tui/tui-winsource.h:
	* tui/tui-winsource.c:
	* tui/tui-wingeneral.h:
	* tui/tui-wingeneral.c:
	* tui/tui-windata.h:
	* tui/tui-windata.c: Add (C) after Copyright.  Update the FSF
	address.
@
text
@d163 1
a163 1
	  struct tui_win_info * win_info = (struct tui_win_info *) (tui_source_windows ())->list[i];
d387 1
a387 1
      struct tui_win_info * win = (struct tui_win_info *) list->list[i];
@


1.16
log
@2005-11-01  Andrew Stubbs  <andrew.stubbs@@st.com>

	* tui/tui-data.h (tui_line_or_address): Encapsulate the union in a
	struct with a tag.
	(tui_source_element, tui_source_info): Update.
	* tui/tui-disasm.c, tui/tui-source.c: Update to use the tagged union.
	* tui/tui-source.h, tui/tui-stack.c, tui/tui-win.c: Likewise.
	* tui/tui-winsource.c, tui/tui-data.c, tui/tui-layout.c: Likewise.
	* tui/tui-winsource.h: Likewise.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.15
log
@2004-02-16  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-windata.c: Include "gdb_string.h".
	* tui/tui-source.c, tui/tui-winsource.c: Ditto.
	* tui/tui-layout.c, tui/tui-command.c: Ditto.
	* Makefile.in: Update dependencies.
@
text
@d44 1
d75 1
a75 1
			  union tui_line_or_address line_or_addr, int noerror)
d88 1
a88 1
				union tui_line_or_address line_or_addr, int noerror)
d93 1
a93 1
    ret = tui_set_source_content (s, line_or_addr.line_no, noerror);
d95 1
a95 1
    ret = tui_set_disassem_content (line_or_addr.addr);
d111 1
a111 1
	  sal.line = line_or_addr.line_no +
d138 1
a138 1
      union tui_line_or_address l;
d151 2
a152 1
	  l.line_no = sal.line;
d177 1
a177 1
  union tui_line_or_address l;
d187 2
a188 1
      l.line_no = line;
d342 1
a342 1
tui_set_is_exec_point_at (union tui_line_or_address l, struct tui_win_info * win_info)
d352 2
d355 6
a360 1
      if (content[i]->which_element.source.line_or_addr.addr == l.addr)
d427 2
d432 2
a433 1
               && bp->line_number == line->line_or_addr.line_no)
d435 2
a436 1
                  && bp->loc->address == line->line_or_addr.addr))
d631 5
a635 2
		      win_info->generic.content[i])->which_element.source.line_or_addr.line_no
		     == (int) line);
d660 5
a664 2
		      win_info->generic.content[i])->which_element.source.line_or_addr.addr
		     == addr);
@


1.15.8.1
log
@merge mainline changes to branch
@
text
@@


1.14
log
@2004-02-10  Andrew Cagney  <cagney@@redhat.com>

	* defs.h: Do not include "tui.h".
	* gdb_curses.h: New file.
	* tui/tui-hooks.h: New file.
	* tui/tui.h (tui_update_all_exec_infos): Delete declaration.
	(tui_install_hooks, tui_remove_hooks): Delete declarations.
	(tui_initialize_io): Delete declaration.
	(tui_initialize_readline: Delete redundant declaration.
	(struct tui_point): Delete definition.
	* tui/tui-data.h (struct tui_point): Define.
	* cli/cli-decode.c [TUI]: Include "tui/tui.h".
	* utils.c: Include "tui/tui.h".
	* tui/tui-data.h: Include "tui/tui.h" and "gdb_curses.h".
	* printcmd.c [TUI]: Include "tui/tui.h".
	* cli/cli-cmds.c [TUI]: Include "tui/tui.h".
	* tui/tui-command.c: Include "gdb_curses.h".
	* tui/tui.c, tui/tui-winsource.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-windata.c, tui/tui-win.c, tui/tui-stack.c: Ditto.
	* tui/tui-source.c, tui/tui-regs.c, tui/tui-layout.c: Ditto.
	* tui/tui-io.c, tui/tui-disasm.c, tui/tui-data.c: : Ditto.
	* tui/tui-hooks.c: Include "tui-hooks.h" and "gdb_curses.h".
	* Makefile.in: Update all dependencies.
	(tui_hooks_h, gdb_curses_h): Define.
	(SUBDIR_TUI_CFLAGS): Remove -I${srcdir}/tui.
@
text
@d42 1
@


1.13
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Include "gdb_string.h", delete register
	attribute, use ISO-C function signatures.
	* tui/tui-disasm.c, tui/tui-file.c, tui/tui-io.c: Ditto.
	* tui/tui-layout.c, tui/tui-regs.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-win.c, tui/tui-winsource.c: Ditto.
	* tui/tui.c: Ditto.
@
text
@d42 1
a42 7
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
@


1.13.2.1
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d79 1
a79 1
			  union tui_line_or_address lineOrAddr, int noerror)
d82 1
a82 1
  tui_update_source_window_as_is (win_info, s, lineOrAddr, noerror);
d92 1
a92 1
				union tui_line_or_address lineOrAddr, int noerror)
d97 1
a97 1
    ret = tui_set_source_content (s, lineOrAddr.line_no, noerror);
d99 1
a99 1
    ret = tui_set_disassem_content (lineOrAddr.addr);
d115 1
a115 1
	  sal.line = lineOrAddr.line_no +
d172 1
a172 3

  return;
}				/* tuiUpdateSourceWindowsWithAddr */
d204 1
a204 1
tui_clear_source_content (struct tui_win_info * win_info, int displayPrompt)
d208 1
a208 1
      register int i;
d211 1
a211 1
      tui_erase_source_content (win_info, displayPrompt);
d220 1
a220 3

  return;
}				/* tuiClearSourceContent */
d224 1
a224 1
tui_erase_source_content (struct tui_win_info * win_info, int displayPrompt)
d226 2
a227 2
  int xPos;
  int halfWidth = (win_info->generic.width - 2) / 2;
d233 1
a233 1
      if (displayPrompt == EMPTY_SOURCE_PROMPT)
d235 1
a235 1
	  char *noSrcStr;
d238 1
a238 1
	    noSrcStr = NO_SRC_STRING;
d240 3
a242 3
	    noSrcStr = NO_DISASSEM_STRING;
	  if (strlen (noSrcStr) >= halfWidth)
	    xPos = 1;
d244 1
a244 1
	    xPos = halfWidth - strlen (noSrcStr);
d247 2
a248 2
		     xPos,
		     noSrcStr);
d255 1
a255 1
	  tui_set_source_content_nil (win_info, noSrcStr);
d259 1
a259 2
  return;
}				/* tuiEraseSourceContent */
d310 1
a310 1
			      int numToScroll)
d324 1
a324 1
	offset = win_info->detail.source_info.horizontal_offset + numToScroll;
d328 1
a328 1
	     win_info->detail.source_info.horizontal_offset - numToScroll) < 0)
d339 1
a339 1
}				/* tuiHorizontalSourceScroll */
d353 1
a353 1
      int newState;
d356 1
a356 1
        newState = TRUE;
d358 2
a359 2
	newState = FALSE;
      if (newState != content[i]->which_element.source.is_exec_point)
d362 1
a362 1
          content[i]->which_element.source.is_exec_point = newState;
d375 1
a375 1
tui_update_all_breakpoint_info ()
d451 3
a453 6
/*
   ** tuiSetExecInfoContent().
   **      Function to initialize the content of the execution info window,
   **      based upon the input window which is either the source or
   **      disassembly window.
 */
d455 1
a455 1
tuiSetExecInfoContent (struct tui_win_info * win_info)
d461 1
a461 1
      struct tui_gen_win_info * execInfoPtr = win_info->detail.source_info.execution_info;
d463 2
a464 2
      if (execInfoPtr->content == NULL)
	execInfoPtr->content =
d466 2
a467 2
					 execInfoPtr->type);
      if (execInfoPtr->content != NULL)
d475 1
a475 1
	      struct tui_win_element * srcElement;
d478 2
a479 2
	      element = (struct tui_win_element *) execInfoPtr->content[i];
	      srcElement = (struct tui_win_element *) win_info->generic.content[i];
d487 1
a487 1
              mode = srcElement->which_element.source.has_break;
d500 1
a500 1
              if (srcElement->which_element.source.is_exec_point)
d503 1
a503 1
	  execInfoPtr->content_size = win_info->generic.content_size;
d513 11
a523 14
/*
   ** tuiShowExecInfoContent().
 */
void
tuiShowExecInfoContent (struct tui_win_info * win_info)
{
  struct tui_gen_win_info * execInfo = win_info->detail.source_info.execution_info;
  int curLine;

  werase (execInfo->handle);
  tui_refresh_win (execInfo);
  for (curLine = 1; (curLine <= execInfo->content_size); curLine++)
    mvwaddstr (execInfo->handle,
	       curLine,
d526 3
a528 5
		execInfo->content[curLine - 1])->which_element.simple_string);
  tui_refresh_win (execInfo);
  execInfo->content_in_use = TRUE;

  return;
d535 1
a535 1
  struct tui_gen_win_info * execInfo = win_info->detail.source_info.execution_info;
d537 2
a538 4
  werase (execInfo->handle);
  tui_refresh_win (execInfo);

  return;
d554 3
a556 3
  tuiSetExecInfoContent (win_info);
  tuiShowExecInfoContent (win_info);
}				/* tuiUpdateExecInfo */
d561 2
a562 2
  register char *srcLineBuf;
  register int i, lineWidth, maxLines;
d565 2
a566 2
  maxLines = win_info->generic.height;	/* less the highlight box */
  lineWidth = win_info->generic.width - 1;
d574 2
a575 2
      srcLineBuf = (char *) xmalloc ((maxLines * lineWidth) * sizeof (char));
      if (srcLineBuf == (char *) NULL)
d583 1
a583 1
	  (void **) tui_alloc_content (maxLines, SRC_WIN)) == NULL)
d585 2
a586 2
	      xfree (srcLineBuf);
	      srcLineBuf = (char *) NULL;
d592 1
a592 1
      for (i = 0; i < maxLines; i++)
d595 1
a595 1
	  srcLineBuf + (lineWidth * i);
d602 1
a602 1
}				/* tuiAllocSourceBuffer */
d609 1
a609 1
		       int checkThreshold)
d611 1
a611 1
  int isDisplayed = FALSE;
d614 1
a614 1
  if (checkThreshold)
d619 1
a619 1
  while (i < win_info->generic.content_size - threshold && !isDisplayed)
d621 1
a621 1
      isDisplayed = (((struct tui_win_element *)
d627 1
a627 1
  return isDisplayed;
d635 1
a635 1
		    int checkThreshold)
d637 1
a637 1
  int isDisplayed = FALSE;
d640 1
a640 1
  if (checkThreshold)
d645 1
a645 1
  while (i < win_info->generic.content_size - threshold && !isDisplayed)
d647 1
a647 1
      isDisplayed = (((struct tui_win_element *)
d653 1
a653 1
  return isDisplayed;
@


1.12
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Change variable and function names to lower
	case.
	* tui/tui-data.c, tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c, tui/tui-io.c, tui/tui-layout.c: Ditto.
	* tui/tui-regs.c, tui/tui-source.c, tui/tui-stack.c: Ditto.
	* tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d208 1
a208 1
      register int i;
d375 1
a375 1
tui_update_all_breakpoint_info ()
d561 2
a562 2
  register char *src_line_buf;
  register int i, line_width, max_lines;
@


1.11
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui.h: Do not include <stdarg.h>, <string.h>, and
	"ansidecl.h".  Do not undef "reg" and "chtype".  Fix case of
	fields and variables.
	* tui/tui-wingeneral.h (m_beVisible): Delete macro.
	(m_beInvisible): Delete macro.
	* tui/tui-data.h: Fix case case fields and variables.
	(m_genWinPtrIsNull): Delete macro.
	(tui_win_list): Rename winList.
	(TUI_SRC_WIN): Rename srcWin.
	(TUI_DISASM_WIN): Rename disassemWin.
	(TUI_DATA_WIN): Rename dataWin.
	(TUI_CMD_WIN): Rename cmdWin.
	(m_genWinPtrNotNull): Delete macro.
	(m_winPtrIsNull): Delete macro.
	(m_winPtrNotNull): Delete macro.
	(tui_win_is_source_type): Replace m_winIsSourceType
	(tui_win_is_auxillary): Replace m_winIsAuzillary.
	(tui_win_has_locator): Replace m_hasLocator.
	(tui_set_win_highlight): Replace m_setWinHighlightOn and
	m_setWinHighlightOff.
	* tui/tui-data.c: Update references.
	(tui_win_is_source_type, tui_set_win_highlight): New functions.
	(tui_win_has_locator, tui_win_is_auxillary): New functions.
	* tui/tui-command.c, tui/tui-disasm.c: Update references.
	* tui/tui-io.c, tui/tui-layout.c, tui/tui-regs.c: Ditto.
	* tui/tui-regs.h, tui/tui-source.c, tui/tui-stack.c: Ditto.
	* tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d79 1
a79 1
			  union tui_line_or_address lineOrAddr, int noerror)
d82 1
a82 1
  tui_update_source_window_as_is (win_info, s, lineOrAddr, noerror);
d92 1
a92 1
				union tui_line_or_address lineOrAddr, int noerror)
d97 1
a97 1
    ret = tui_set_source_content (s, lineOrAddr.line_no, noerror);
d99 1
a99 1
    ret = tui_set_disassem_content (lineOrAddr.addr);
d115 1
a115 1
	  sal.line = lineOrAddr.line_no +
d172 1
a172 3

  return;
}				/* tuiUpdateSourceWindowsWithAddr */
d204 1
a204 1
tui_clear_source_content (struct tui_win_info * win_info, int displayPrompt)
d211 1
a211 1
      tui_erase_source_content (win_info, displayPrompt);
d220 1
a220 3

  return;
}				/* tuiClearSourceContent */
d224 1
a224 1
tui_erase_source_content (struct tui_win_info * win_info, int displayPrompt)
d226 2
a227 2
  int xPos;
  int halfWidth = (win_info->generic.width - 2) / 2;
d233 1
a233 1
      if (displayPrompt == EMPTY_SOURCE_PROMPT)
d235 1
a235 1
	  char *noSrcStr;
d238 1
a238 1
	    noSrcStr = NO_SRC_STRING;
d240 3
a242 3
	    noSrcStr = NO_DISASSEM_STRING;
	  if (strlen (noSrcStr) >= halfWidth)
	    xPos = 1;
d244 1
a244 1
	    xPos = halfWidth - strlen (noSrcStr);
d247 2
a248 2
		     xPos,
		     noSrcStr);
d255 1
a255 1
	  tui_set_source_content_nil (win_info, noSrcStr);
d259 1
a259 2
  return;
}				/* tuiEraseSourceContent */
d310 1
a310 1
			      int numToScroll)
d324 1
a324 1
	offset = win_info->detail.source_info.horizontal_offset + numToScroll;
d328 1
a328 1
	     win_info->detail.source_info.horizontal_offset - numToScroll) < 0)
d339 1
a339 1
}				/* tuiHorizontalSourceScroll */
d353 1
a353 1
      int newState;
d356 1
a356 1
        newState = TRUE;
d358 2
a359 2
	newState = FALSE;
      if (newState != content[i]->which_element.source.is_exec_point)
d362 1
a362 1
          content[i]->which_element.source.is_exec_point = newState;
d451 3
a453 6
/*
   ** tuiSetExecInfoContent().
   **      Function to initialize the content of the execution info window,
   **      based upon the input window which is either the source or
   **      disassembly window.
 */
d455 1
a455 1
tuiSetExecInfoContent (struct tui_win_info * win_info)
d461 1
a461 1
      struct tui_gen_win_info * execInfoPtr = win_info->detail.source_info.execution_info;
d463 2
a464 2
      if (execInfoPtr->content == NULL)
	execInfoPtr->content =
d466 2
a467 2
					 execInfoPtr->type);
      if (execInfoPtr->content != NULL)
d475 1
a475 1
	      struct tui_win_element * srcElement;
d478 2
a479 2
	      element = (struct tui_win_element *) execInfoPtr->content[i];
	      srcElement = (struct tui_win_element *) win_info->generic.content[i];
d487 1
a487 1
              mode = srcElement->which_element.source.has_break;
d500 1
a500 1
              if (srcElement->which_element.source.is_exec_point)
d503 1
a503 1
	  execInfoPtr->content_size = win_info->generic.content_size;
d513 11
a523 14
/*
   ** tuiShowExecInfoContent().
 */
void
tuiShowExecInfoContent (struct tui_win_info * win_info)
{
  struct tui_gen_win_info * execInfo = win_info->detail.source_info.execution_info;
  int curLine;

  werase (execInfo->handle);
  tui_refresh_win (execInfo);
  for (curLine = 1; (curLine <= execInfo->content_size); curLine++)
    mvwaddstr (execInfo->handle,
	       curLine,
d526 3
a528 5
		execInfo->content[curLine - 1])->which_element.simple_string);
  tui_refresh_win (execInfo);
  execInfo->content_in_use = TRUE;

  return;
d535 1
a535 1
  struct tui_gen_win_info * execInfo = win_info->detail.source_info.execution_info;
d537 2
a538 4
  werase (execInfo->handle);
  tui_refresh_win (execInfo);

  return;
d554 3
a556 3
  tuiSetExecInfoContent (win_info);
  tuiShowExecInfoContent (win_info);
}				/* tuiUpdateExecInfo */
d561 2
a562 2
  register char *srcLineBuf;
  register int i, lineWidth, maxLines;
d565 2
a566 2
  maxLines = win_info->generic.height;	/* less the highlight box */
  lineWidth = win_info->generic.width - 1;
d574 2
a575 2
      srcLineBuf = (char *) xmalloc ((maxLines * lineWidth) * sizeof (char));
      if (srcLineBuf == (char *) NULL)
d583 1
a583 1
	  (void **) tui_alloc_content (maxLines, SRC_WIN)) == NULL)
d585 2
a586 2
	      xfree (srcLineBuf);
	      srcLineBuf = (char *) NULL;
d592 1
a592 1
      for (i = 0; i < maxLines; i++)
d595 1
a595 1
	  srcLineBuf + (lineWidth * i);
d602 1
a602 1
}				/* tuiAllocSourceBuffer */
d609 1
a609 1
		       int checkThreshold)
d611 1
a611 1
  int isDisplayed = FALSE;
d614 1
a614 1
  if (checkThreshold)
d619 1
a619 1
  while (i < win_info->generic.content_size - threshold && !isDisplayed)
d621 1
a621 1
      isDisplayed = (((struct tui_win_element *)
d627 1
a627 1
  return isDisplayed;
d635 1
a635 1
		    int checkThreshold)
d637 1
a637 1
  int isDisplayed = FALSE;
d640 1
a640 1
  if (checkThreshold)
d645 1
a645 1
  while (i < win_info->generic.content_size - threshold && !isDisplayed)
d647 1
a647 1
      isDisplayed = (((struct tui_win_element *)
d653 1
a653 1
  return isDisplayed;
@


1.10
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui.h (Opaque, OpaquePtr OpaqueList): Delete definition.
	(TuiPoint, TuiPointPtr): Ditto.
	(TuiStatus, TuiStatusPtr): Ditto.
	(TuiWinType, TuiWinTypePtr): Ditto.
	(struct tui_point): Rename _TuiPoint.
	(tui_get_low_disassembly_address): Rename
	tuiGetLowDisassemblyAddress.
	(tui_update_all_exec_infos): Rename tuiUpdateAllExecInfos.
	(tuiFree): Delete declaration.
	(OpaqueFuncPtr, TuiOpaqueFuncPtr): Delete definitions.
	(TuiVoidFuncPtr, TuiIntFuncPtr): Delete definitions.
	* tui/tui.c (tuiFree): Delete function.
	* cli/cli-cmds.c (disassemble_command): Update references.
	* tui/tui-data.c, tui/tui-data.h, tui/tui-disasm.c: Ditto.
	* tui/tui-layout.c, tui/tui-regs.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-win.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d78 1
a78 1
tui_update_source_window (struct tui_win_info * winInfo, struct symtab *s,
d81 2
a82 2
  winInfo->detail.sourceInfo.horizontalOffset = 0;
  tui_update_source_window_as_is (winInfo, s, lineOrAddr, noerror);
d91 1
a91 1
tui_update_source_window_as_is (struct tui_win_info * winInfo, struct symtab *s,
d96 2
a97 2
  if (winInfo->generic.type == SRC_WIN)
    ret = tui_set_source_content (s, lineOrAddr.lineNo, noerror);
d103 2
a104 2
      tui_clear_source_content (winInfo, EMPTY_SOURCE_PROMPT);
      tui_clear_exec_info_content (winInfo);
d108 4
a111 4
      tui_update_breakpoint_info (winInfo, 0);
      tui_show_source_content (winInfo);
      tui_update_exec_info (winInfo);
      if (winInfo->generic.type == SRC_WIN)
d115 2
a116 2
	  sal.line = lineOrAddr.lineNo +
	    (winInfo->generic.contentSize - 2);
d123 1
a123 1
	  if (tui_win_with_focus () == disassemWin &&
d125 1
a125 1
	    tui_set_win_focus_to (srcWin);
d155 1
a155 1
	  l.lineNo = sal.line;
d166 1
a166 1
	  struct tui_win_info * winInfo = (struct tui_win_info *) (tui_source_windows ())->list[i];
d168 2
a169 2
	  tui_clear_source_content (winInfo, EMPTY_SOURCE_PROMPT);
	  tui_clear_exec_info_content (winInfo);
d192 1
a192 1
      l.lineNo = line;
d206 1
a206 1
tui_clear_source_content (struct tui_win_info * winInfo, int displayPrompt)
d208 1
a208 1
  if (m_winPtrNotNull (winInfo))
d212 3
a214 3
      winInfo->generic.contentInUse = FALSE;
      tui_erase_source_content (winInfo, displayPrompt);
      for (i = 0; i < winInfo->generic.contentSize; i++)
d217 3
a219 3
	  (struct tui_win_element *) winInfo->generic.content[i];
	  element->whichElement.source.hasBreak = FALSE;
	  element->whichElement.source.isExecPoint = FALSE;
d228 1
a228 1
tui_erase_source_content (struct tui_win_info * winInfo, int displayPrompt)
d231 1
a231 1
  int halfWidth = (winInfo->generic.width - 2) / 2;
d233 1
a233 1
  if (winInfo->generic.handle != (WINDOW *) NULL)
d235 2
a236 2
      werase (winInfo->generic.handle);
      tui_check_and_display_highlight_if_needed (winInfo);
d241 1
a241 1
	  if (winInfo->generic.type == SRC_WIN)
d249 2
a250 2
	  mvwaddstr (winInfo->generic.handle,
		     (winInfo->generic.height / 2),
d259 1
a259 1
	  tui_set_source_content_nil (winInfo, noSrcStr);
d261 1
a261 1
      tui_refresh_win (&winInfo->generic);
d269 1
a269 1
tui_show_source_line (struct tui_win_info * winInfo, int lineno)
d274 8
a281 8
  line = (struct tui_win_element *) winInfo->generic.content[lineno - 1];
  if (line->whichElement.source.isExecPoint)
    wattron (winInfo->generic.handle, A_STANDOUT);

  mvwaddstr (winInfo->generic.handle, lineno, 1,
             line->whichElement.source.line);
  if (line->whichElement.source.isExecPoint)
    wattroff (winInfo->generic.handle, A_STANDOUT);
d284 2
a285 2
  getyx (winInfo->generic.handle, y, x);
  while (x + 1 < winInfo->generic.width)
d287 2
a288 2
      waddch (winInfo->generic.handle, ' ');
      getyx (winInfo->generic.handle, y, x);
d293 1
a293 1
tui_show_source_content (struct tui_win_info * winInfo)
d295 1
a295 1
  if (winInfo->generic.contentSize > 0)
d299 2
a300 2
      for (lineno = 1; lineno <= winInfo->generic.contentSize; lineno++)
        tui_show_source_line (winInfo, lineno);
d303 1
a303 1
    tui_erase_source_content (winInfo, TRUE);
d305 3
a307 3
  tui_check_and_display_highlight_if_needed (winInfo);
  tui_refresh_win (&winInfo->generic);
  winInfo->generic.contentInUse = TRUE;
d313 1
a313 1
tui_horizontal_source_scroll (struct tui_win_info * winInfo,
d317 1
a317 1
  if (winInfo->generic.content != NULL)
d329 1
a329 1
	offset = winInfo->detail.sourceInfo.horizontalOffset + numToScroll;
d333 1
a333 1
	     winInfo->detail.sourceInfo.horizontalOffset - numToScroll) < 0)
d336 2
a337 2
      winInfo->detail.sourceInfo.horizontalOffset = offset;
      tui_update_source_window_as_is (winInfo, s,
d339 1
a339 1
				       winInfo->generic.content[0])->whichElement.source.lineOrAddr,
d347 1
a347 1
/* Set or clear the hasBreak flag in the line whose line is lineNo.  */
d349 1
a349 1
tui_set_is_exec_point_at (union tui_line_or_address l, struct tui_win_info * winInfo)
d353 1
a353 1
  tui_win_content content = (tui_win_content) winInfo->generic.content;
d356 1
a356 1
  while (i < winInfo->generic.contentSize)
d360 1
a360 1
      if (content[i]->whichElement.source.lineOrAddr.addr == l.addr)
d364 1
a364 1
      if (newState != content[i]->whichElement.source.isExecPoint)
d367 2
a368 2
          content[i]->whichElement.source.isExecPoint = newState;
          tui_show_source_line (winInfo, i + 1);
d373 1
a373 1
    tui_refresh_win (&winInfo->generic);
d398 1
a398 1
   hasBreak information for each line.
d406 1
a406 1
  struct tui_source_info * src = &win->detail.sourceInfo;
d408 1
a408 1
  for (i = 0; i < win->generic.contentSize; i++)
d415 2
a416 2
      line = &((struct tui_win_element *) win->generic.content[i])->whichElement.source;
      if (current_only && !line->isExecPoint)
d427 1
a427 1
          if ((win == srcWin
d430 3
a432 3
               && bp->line_number == line->lineOrAddr.lineNo)
              || (win == disassemWin
                  && bp->loc->address == line->lineOrAddr.addr))
d446 1
a446 1
      if (line->hasBreak != mode)
d448 1
a448 1
          line->hasBreak = mode;
d463 1
a463 1
tuiSetExecInfoContent (struct tui_win_info * winInfo)
d467 1
a467 1
  if (winInfo->detail.sourceInfo.executionInfo != (struct tui_gen_win_info *) NULL)
d469 1
a469 1
      struct tui_gen_win_info * execInfoPtr = winInfo->detail.sourceInfo.executionInfo;
d473 1
a473 1
	  (void **) tui_alloc_content (winInfo->generic.height,
d479 2
a480 2
          tui_update_breakpoint_info (winInfo, 1);
	  for (i = 0; i < winInfo->generic.contentSize; i++)
d487 1
a487 1
	      srcElement = (struct tui_win_element *) winInfo->generic.content[i];
d489 3
a491 3
              memset(element->whichElement.simpleString, ' ',
                     sizeof(element->whichElement.simpleString));
              element->whichElement.simpleString[TUI_EXECINFO_SIZE - 1] = 0;
d495 1
a495 1
              mode = srcElement->whichElement.source.hasBreak;
d497 1
a497 1
                element->whichElement.simpleString[TUI_BP_HIT_POS] =
d500 1
a500 1
                element->whichElement.simpleString[TUI_BP_HIT_POS] =
d504 1
a504 1
                element->whichElement.simpleString[TUI_BP_BREAK_POS] = '+';
d506 1
a506 1
                element->whichElement.simpleString[TUI_BP_BREAK_POS] = '-';
d508 2
a509 2
              if (srcElement->whichElement.source.isExecPoint)
                element->whichElement.simpleString[TUI_EXEC_POS] = '>';
d511 1
a511 1
	  execInfoPtr->contentSize = winInfo->generic.contentSize;
d525 1
a525 1
tuiShowExecInfoContent (struct tui_win_info * winInfo)
d527 1
a527 1
  struct tui_gen_win_info * execInfo = winInfo->detail.sourceInfo.executionInfo;
d532 1
a532 1
  for (curLine = 1; (curLine <= execInfo->contentSize); curLine++)
d537 1
a537 1
		execInfo->content[curLine - 1])->whichElement.simpleString);
d539 1
a539 1
  execInfo->contentInUse = TRUE;
d546 1
a546 1
tui_erase_exec_info_content (struct tui_win_info * winInfo)
d548 1
a548 1
  struct tui_gen_win_info * execInfo = winInfo->detail.sourceInfo.executionInfo;
d557 1
a557 1
tui_clear_exec_info_content (struct tui_win_info * winInfo)
d559 2
a560 2
  winInfo->detail.sourceInfo.executionInfo->contentInUse = FALSE;
  tui_erase_exec_info_content (winInfo);
d567 1
a567 1
tui_update_exec_info (struct tui_win_info * winInfo)
d569 2
a570 2
  tuiSetExecInfoContent (winInfo);
  tuiShowExecInfoContent (winInfo);
d574 1
a574 1
tui_alloc_source_buffer (struct tui_win_info *winInfo)
d580 2
a581 2
  maxLines = winInfo->generic.height;	/* less the highlight box */
  lineWidth = winInfo->generic.width - 1;
d587 1
a587 1
  if (winInfo->generic.content == NULL)
d597 1
a597 1
	  if ((winInfo->generic.content =
d609 1
a609 1
	 winInfo->generic.content[i])->whichElement.source.line =
d623 1
a623 1
tui_line_is_displayed (int line, struct tui_win_info * winInfo,
d634 1
a634 1
  while (i < winInfo->generic.contentSize - threshold && !isDisplayed)
d637 1
a637 1
		      winInfo->generic.content[i])->whichElement.source.lineOrAddr.lineNo
d649 1
a649 1
tui_addr_is_displayed (CORE_ADDR addr, struct tui_win_info * winInfo,
d660 1
a660 1
  while (i < winInfo->generic.contentSize - threshold && !isDisplayed)
d663 1
a663 1
		      winInfo->generic.content[i])->whichElement.source.lineOrAddr.addr
@


1.9
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

        * tui/tui-data.h (tui_win_element): Rename TuiWinElement.
        (tui_exec_info_content): Rename TuiExecInfoContent.
        (TuiGenWinInfo, TuiGenWinInfoPtr): Delete definitions.
        (TuiWinInfo, TuiWinInfoPtr): Ditto.
        (TuiScrollDirection, TuiScrollDirectionPtr): Ditto.
        (TuiList, TuiListPtr): Ditto.
        (TuiLayoutType, TuiLayoutTypePtr): Ditto.
        (TuiDataType, TuiDataTypePtr): Ditto.
        (TuiRegisterDisplayType, TuiRegisterDisplayTypePtr): Ditto.
        (TuiLineOrAddress, TuiLineOrAddressPtr): Ditto.
        (TuiLayoutDef, TuiLayoutDefPtr): Ditto.
        (TuiSourceElement, TuiSourceElementPtr): Ditto.
        (TuiDataElement, TuiDataElementPtr): Ditto.
        (TuiWinElement, TuiWinElementPtr): Ditto.
        (TuiDataInfo, TuiDataInfoPtr): Ditto.
        (TuiCommandElement, TuiCommandElementPtr): Ditto.
        (TuiLocatorElement, TuiLocatorElementPtr): Ditto.
        (TuiWhichElement, TuiWhichElementPtr): Ditto.
        (TuiSourceInfo, TuiSourceInfoPtr): Ditto.
        (TuiCommandInfo, TuiCommandInfoPtr): Ditto.
        * tui/tui-command.c, tui/tui-data.c: Update references.
        * tui/tui-data.h, tui/tui-disasm.c, tui/tui-layout.c: Ditto.
        * tui/tui-regs.c, tui/tui-source.c, tui/tui-stack.c: Ditto.
        * tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
        * tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d94 1
a94 1
  TuiStatus ret;
d317 1
a317 1
  if (winInfo->generic.content != (OpaquePtr) NULL)
d462 1
a462 1
TuiStatus
d465 1
a465 1
  TuiStatus ret = TUI_SUCCESS;
d471 1
a471 1
      if (execInfoPtr->content == (OpaquePtr) NULL)
d473 1
a473 1
	  (OpaquePtr) tui_alloc_content (winInfo->generic.height,
d475 1
a475 1
      if (execInfoPtr->content != (OpaquePtr) NULL)
d578 1
a578 1
  TuiStatus ret = TUI_FAILURE;
d587 1
a587 1
  if (winInfo->generic.content == (OpaquePtr) NULL)
d598 1
a598 1
	  (OpaquePtr) tui_alloc_content (maxLines, SRC_WIN)) == (OpaquePtr) NULL)
d600 1
a600 1
	      tuiFree (srcLineBuf);
@


1.8
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-data.h (struct tui_list): Rename _TuiList.
	(enum tui_data_type): Rename _TuiDataType.
	(struct tui_layout_def): Rename _TuiLayoutDef.
	(struct tui_source_element): Rename _TuiSourceElement.
	(struct tui_data_element): Rename _TuiDataElement.
	(struct tui_command_element): Rename _TuiCommandElement.
	(struct tui_locator_element): Rename _TuiLocatorElement.
	(union tui_which_element): Define.
	(struct tui_win_element): Rename _TuiWinElement.
	(struct tui_data_info): Rename _TuiDataInfo.
	(struct tui_source_info): Rename _TuiSourceInfo.
	(struct tui_command_info): Rename _TuiCommandInfo.
	(tui_initialize_static_data): Rename initializeStaticData.
	(tui_alloc_generic_win_info): Rename allocGenericWinInfo.
	(tui_alloc_win_info): Rename allocWinInfo.
	(tui_init_generic_part): Rename initGenericPart.
	(tui_init_win_info): Rename initWinInfo.
	(tui_alloc_content): Rename allocContent.
	(tui_add_content_elements): Rename addContentElements.
	(tui_init_content_element): Rename initContentElement.
	(tui_free_window): Rename freeWindow.
	(tui_free_win_content): Rename freeWinContent.
	(tui_free_data_content): Rename freeDataContent.
	(tui_free_all_source_wins_content): Rename
	freeAllSourceWinsContent.
	(tui_del_window): Rename tuiDelWindow.
	(tui_del_data_windows): Rename tuiDelDataWindows.
	(tui_partial_win_by_name): Rename partialWinByName.
	(tui_win_name): Rename winName.
	(tui_current_layout): Rename currentLayout.
	(tui_set_current_layout_to): Rename setCurrentLayoutTo.
	(tui_term_height): Rename termHeight.
	(tui_set_term_height_to): Rename setTermHeightTo.
	(tui_term_width): Rename termWidth.
	(tui_set_term_width_to): Rename setTermWidthTo.
	(tui_set_gen_win_origin): Rename setGenWinOrigin.
	(tui_locator_win_info_ptr): Rename locatorWinInfoPtr.
	(tui_source_exec_info_win_ptr): Rename tui_gen_win_info.
	(tui_disassem_exec_info_win_ptr): Rename disassemExecInfoWinPtr.
	(tui_source_windows): Rename sourceWindows.
	(tui_clear_source_windows): Rename clearSourceWindows.
	(tui_clear_source_windows_detail): Rename
	clearSourceWindowsDetail.
	(tui_clear_win_detail): Rename clearWinDetail.
	(tui_add_to_source_windows): Rename tuiAddToSourceWindows.
	(tui_default_tab_len): Rename tuiDefaultTabLen.
	(tui_set_default_tab_len): Rename tuiSetDefaultTabLen.
	(tui_win_with_focus): Rename tuiWinWithFocus.
	(tui_set_win_with_focus): Rename tuiSetWinWithFocus.
	(tui_layout_def): Rename tuiLayoutDef.
	(tui_win_resized): Rename tuiWinResized.
	(tui_set_win_resized_to): Rename tuiSetWinResizedTo.
	(tui_next_win): Rename tuiNextWin.
	(tui_prev_win): Rename tuiPrevWin.
	(tui_add_to_source_windows): Rename addToSourceWindows.
	* tui/tui-winsource.c, tui/tui-win.c: Update references.
	* tui/tui-layout.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-io.c: Ditto.
	* tui/tui.c, tui/tui-data.c: Ditto.
	* tui/tui-interp.c, tui/tui-data.c: Ditto.
	* tui/tui-disasm.c, tui/tui-command.c: Ditto.
@
text
@d78 2
a79 2
tui_update_source_window (TuiWinInfoPtr winInfo, struct symtab *s,
			  TuiLineOrAddress lineOrAddr, int noerror)
d91 2
a92 2
tui_update_source_window_as_is (TuiWinInfoPtr winInfo, struct symtab *s,
				TuiLineOrAddress lineOrAddr, int noerror)
d142 1
a142 1
      TuiLineOrAddress l;
d166 1
a166 1
	  TuiWinInfoPtr winInfo = (TuiWinInfoPtr) (tui_source_windows ())->list[i];
d182 1
a182 1
  TuiLineOrAddress l;
d206 1
a206 1
tui_clear_source_content (TuiWinInfoPtr winInfo, int displayPrompt)
d216 2
a217 2
	  TuiWinElementPtr element =
	  (TuiWinElementPtr) winInfo->generic.content[i];
d228 1
a228 1
tui_erase_source_content (TuiWinInfoPtr winInfo, int displayPrompt)
d269 1
a269 1
tui_show_source_line (TuiWinInfoPtr winInfo, int lineno)
d271 1
a271 1
  TuiWinElementPtr line;
d274 1
a274 1
  line = (TuiWinElementPtr) winInfo->generic.content[lineno - 1];
d293 1
a293 1
tui_show_source_content (TuiWinInfoPtr winInfo)
d313 2
a314 2
tui_horizontal_source_scroll (TuiWinInfoPtr winInfo,
			      TuiScrollDirection direction,
d338 1
a338 1
				      ((TuiWinElementPtr)
d349 1
a349 1
tui_set_is_exec_point_at (TuiLineOrAddress l, TuiWinInfoPtr winInfo)
d353 1
a353 1
  TuiWinContent content = (TuiWinContent) winInfo->generic.content;
d382 1
a382 1
  TuiList* list = tui_source_windows ();
d387 1
a387 1
      TuiWinInfoPtr win = (TuiWinInfoPtr) list->list[i];
d402 1
a402 1
tui_update_breakpoint_info (TuiWinInfoPtr win, int current_only)
d406 1
a406 1
  TuiSourceInfoPtr src = &win->detail.sourceInfo;
d413 1
a413 1
      TuiSourceElement* line;
d415 1
a415 1
      line = &((TuiWinElementPtr) win->generic.content[i])->whichElement.source;
d463 1
a463 1
tuiSetExecInfoContent (TuiWinInfoPtr winInfo)
d467 1
a467 1
  if (winInfo->detail.sourceInfo.executionInfo != (TuiGenWinInfoPtr) NULL)
d469 1
a469 1
      TuiGenWinInfoPtr execInfoPtr = winInfo->detail.sourceInfo.executionInfo;
d482 2
a483 2
	      TuiWinElementPtr element;
	      TuiWinElementPtr srcElement;
d486 2
a487 2
	      element = (TuiWinElementPtr) execInfoPtr->content[i];
	      srcElement = (TuiWinElementPtr) winInfo->generic.content[i];
d525 1
a525 1
tuiShowExecInfoContent (TuiWinInfoPtr winInfo)
d527 1
a527 1
  TuiGenWinInfoPtr execInfo = winInfo->detail.sourceInfo.executionInfo;
d536 1
a536 1
	       ((TuiWinElementPtr)
d546 1
a546 1
tui_erase_exec_info_content (TuiWinInfoPtr winInfo)
d548 1
a548 1
  TuiGenWinInfoPtr execInfo = winInfo->detail.sourceInfo.executionInfo;
d557 1
a557 1
tui_clear_exec_info_content (TuiWinInfoPtr winInfo)
d567 1
a567 1
tui_update_exec_info (TuiWinInfoPtr winInfo)
d608 1
a608 1
	((TuiWinElementPtr)
d623 1
a623 1
tui_line_is_displayed (int line, TuiWinInfoPtr winInfo,
d636 1
a636 1
      isDisplayed = (((TuiWinElementPtr)
d649 1
a649 1
tui_addr_is_displayed (CORE_ADDR addr, TuiWinInfoPtr winInfo,
d662 1
a662 1
      isDisplayed = (((TuiWinElementPtr)
@


1.7
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-source.h: Update copyright.  Include "tui-data.h".
	(struct symtab): Declare.
	(tui_set_source_content): Rename tuiSetSourceContent.
	(tui_show_symtab_source): Rename tuiShowSource.
	(tui_source_is_displayed): Rename tuiSourceIsDisplayed.
	(tui_vertical_source_scroll): Rename tuiVerticalSourceScroll.
	* tui/tui-source.c: Update copyright.  Update references.
	* tui/tui-win.c, tui/tui-winsource.c: Update references.
	* tui/tui-stack.c: Update references.
@
text
@d54 1
a54 1
  if ((sourceWindows ())->count > 0)
d123 2
a124 2
	  if (tuiWinWithFocus () == disassemWin &&
	      currentLayout () != SRC_DISASSEM_COMMAND)
d144 1
a144 1
      switch (currentLayout ())
d164 1
a164 1
      for (i = 0; i < (sourceWindows ())->count; i++)
d166 1
a166 1
	  TuiWinInfoPtr winInfo = (TuiWinInfoPtr) (sourceWindows ())->list[i];
d184 1
a184 1
  switch (currentLayout ())
d194 1
a194 1
      if (currentLayout () == SRC_DISASSEM_COMMAND)
d382 1
a382 1
  TuiList* list = sourceWindows ();
d473 2
a474 2
	  (OpaquePtr) allocContent (winInfo->generic.height,
				    execInfoPtr->type);
d598 1
a598 1
	  (OpaquePtr) allocContent (maxLines, SRC_WIN)) == (OpaquePtr) NULL)
@


1.6
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-win.h: Update copyright.  Include "tui-data.h".
	(struct tui_win_info): Declare.
	(tui_scroll_forward): Rename tuiScrollForward.
	(tui_scroll_backward): Rename tuiScrollBackward.
	(tui_scroll_left): Rename tuiScrollLeft.
	(tui_scroll_right): Rename tuiScrollRight.
	(tui_set_win_focus_to): Rename tuiSetWinFocusTo.
	(tui_resize_all): Rename tuiResizeAll.
	(tui_refresh_all_win): Rename tuiRefreshAll.
	(tui_sigwinch_handler): Rename tuiSigwinchHandler.
	* tui/tui-layout.c, * tui/tui-io.c: Update references.
	* tui/tui-wingeneral.h, * tui/tui.c: Update references.
	* tui/tui-disasm.c, * tui/tui-command.c: Update references.
@
text
@d97 1
a97 1
    ret = tuiSetSourceContent (s, lineOrAddr.lineNo, noerror);
d156 1
a156 1
	  tuiShowSource (sal.symtab, l, FALSE);
d193 1
a193 1
      tuiShowSource (s, l, FALSE);
@


1.5
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-wingeneral.h: Update copyright.
	(m_allBeVisible): Delete macro.
	(m_allBeInvisible): Delete macro.
	(struct tui_gen_win_info): Declare.
	(struct tui_win_info): Declare.
	(tui_unhighlight_win): Rename unhighlightWin.
	(tui_make_visible, tui_make_invisible): Replace makeVisible.
	(tui_make_all_visible, tui_make_all_invisible): Replace makeAllVisible.
	(tui_make_window): Rename makeWindow.
	(tui_copy_win): Rename copyWin.
	(tui_box_win): Rename boxWin.
	(tui_highlight_win): Rename highlightWin.
	(tui_check_and_display_highlight_if_needed): Rename
	checkAndDisplayHighlightIfNeeded.
	(tui_refresh_all): Rename refreshAll.
	(tui_delete_win): Rename tuiDelwin.
	(tui_refresh_win): Rename tuiRefreshWin.
	* tui/tui-wingeneral.c (make_visible): Rename makeVisible.
	(tui_make_visible, tui_make_invisible): New functions.
	(tui_make_all_visible, tui_make_all_invisible): New functions.
	(make_all_visible): Rename makeAllVisible.
	* tui/tui-winsource.c, tui/tui-windata.c: Update references.
	* tui/tui-data.c, tui/tui-winsource.c: Update references.
	* tui/tui-windata.c, tui/tui-win.c: Update references.
	* tui/tui-regs.c, tui/tui-layout.c: Update references.
	* tui/tui-data.h (struct tui_gen_win_info): Rename _TuiGenWinInfo.
@
text
@d125 1
a125 1
	    tuiSetWinFocusTo (srcWin);
@


1.4
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-source.h: Do not include "defs.h".
	(struct tui_win_info): Declare.
	(tui_set_source_content_nil): Declare.
	* tui/tui-data.h (struct tui_win_info): Rename _TuiWinInfo.
	(union tui_line_or_address): Rename _TuiLineOrAddress.
	* tui/tui-winsource.h: Update copyright.  Include "tui-data.h".
	(tui_update_source_window): Rename tuiUpdateSourceWindow.
	(tui_update_source_window_as_is): Rename
	tuiUpdateSourceWindowAsIs.
	(tui_update_source_windows_with_addr): Rename
	tuiUpdateSourceWindowsWithAddr.
	(tui_update_source_windows_with_line): Rename
	tuiUpdateSourceWindowsWithLine.
	(tui_clear_source_content): Rename tuiClearSourceContent.
	(tui_erase_source_content): Rename tuiEraseSourceContent.
	(tui_set_source_content_nil): Rename tuiSetSourceContentNil.
	(tui_show_source_content): Rename tuiShowSourceContent.
	(tui_horizontal_source_scroll): Rename tuiHorizontalSourceScroll.
	(tui_set_exec_info_content): Rename tuiSetExecInfoContent.
	(tui_show_exec_info_content): Rename tuiShowExecInfoContent.
	(tui_erase_exec_info_content): Rename tuiEraseExecInfoContent.
	(tui_clear_exec_info_content): Rename tuiClearExecInfoContent.
	(tui_update_exec_info): Rename tuiUpdateExecInfo.
	(tui_set_is_exec_point_at): Rename tuiSetIsExecPointAt.
	(tui_alloc_source_buffer): Rename tuiAllocSourceBuffer.
	(tui_line_is_displayed): Rename tuiLineIsDisplayed.
	(tui_addr_is_displayed): Rename tuiAddrIsDisplayed.
	(struct tui_win_info): Declare.
	* tui/tui-stack.c: Update references.
	* tui/tui-layout.c, tui/tui-winsource.c: Ditto.
	* tui/tui-win.c, tui/tui-source.c: Ditto.
	* tui/tui.c, tui/tui-disasm.c: Ditto.
@
text
@d236 1
a236 1
      checkAndDisplayHighlightIfNeeded (winInfo);
d261 1
a261 1
      tuiRefreshWin (&winInfo->generic);
d305 2
a306 2
  checkAndDisplayHighlightIfNeeded (winInfo);
  tuiRefreshWin (&winInfo->generic);
d373 1
a373 1
    tuiRefreshWin (&winInfo->generic);
d531 1
a531 1
  tuiRefreshWin (execInfo);
d538 1
a538 1
  tuiRefreshWin (execInfo);
d551 1
a551 1
  tuiRefreshWin (execInfo);
@


1.3
log
@2004-01-28  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-stack.h: Update copyright.
	(struct frame_info): Add opaque declaration.
	(tui_update_locator_filename): Rename tuiUpdateLocatorFilename.
	(tui_show_locator_content): Rename tuiShowLocatorContent.
	(tui_show_frame_info): Rename tuiShowFrameInfo.
	* tui/tui-stack.c: Update copyright.  Update references.
	* tui/tui-winsource.c: Update references.
	* tui/tui-win.c: Update references.
	* tui/tui-layout.c: Update references.
	* tui/tui-hooks.c: Update copyright, update references.
	* tui/tui.c: Update copyright, update references.
	* tui/tui-disasm.c: Update references.
@
text
@d63 1
a63 1
	  tuiUpdateSourceWindowsWithAddr (addr);
d75 2
a76 5
/*
   ** tuiUpdateSourceWindow().
   **    Function to display source in the source window.  This function
   **    initializes the horizontal scroll to 0.
 */
d78 2
a79 2
tuiUpdateSourceWindow (TuiWinInfoPtr winInfo, struct symtab *s,
                       TuiLineOrAddress lineOrAddr, int noerror)
d82 1
a82 1
  tuiUpdateSourceWindowAsIs (winInfo, s, lineOrAddr, noerror);
d85 1
a85 1
}				/* tuiUpdateSourceWindow */
d88 2
a89 5
/*
   ** tuiUpdateSourceWindowAsIs().
   **        Function to display source in the source/asm window.  This
   **        function shows the source as specified by the horizontal offset.
 */
d91 2
a92 2
tuiUpdateSourceWindowAsIs (TuiWinInfoPtr winInfo, struct symtab *s,
                           TuiLineOrAddress lineOrAddr, int noerror)
d103 2
a104 2
      tuiClearSourceContent (winInfo, EMPTY_SOURCE_PROMPT);
      tuiClearExecInfoContent (winInfo);
d109 2
a110 2
      tuiShowSourceContent (winInfo);
      tuiUpdateExecInfo (winInfo);
d131 1
a131 1
}				/* tuiUpdateSourceWindowAsIs */
d134 2
a135 5
/*
   ** tuiUpdateSourceWindowsWithAddr().
   **        Function to ensure that the source and/or disassemly windows
   **        reflect the input address.
 */
d137 1
a137 1
tuiUpdateSourceWindowsWithAddr (CORE_ADDR addr)
d168 2
a169 2
	  tuiClearSourceContent (winInfo, EMPTY_SOURCE_PROMPT);
	  tuiClearExecInfoContent (winInfo);
d176 2
a177 5
/*
   ** tuiUpdateSourceWindowsWithLine().
   **        Function to ensure that the source and/or disassemly windows
   **        reflect the input address.
 */
d179 1
a179 1
tuiUpdateSourceWindowsWithLine (struct symtab *s, int line)
d189 1
a189 1
      tuiUpdateSourceWindowsWithAddr (pc);
d203 1
a203 1
}				/* tuiUpdateSourceWindowsWithLine */
a204 3
/*
   ** tuiClearSourceContent().
 */
d206 1
a206 1
tuiClearSourceContent (TuiWinInfoPtr winInfo, int displayPrompt)
d213 1
a213 1
      tuiEraseSourceContent (winInfo, displayPrompt);
a226 3
/*
   ** tuiEraseSourceContent().
 */
d228 1
a228 1
tuiEraseSourceContent (TuiWinInfoPtr winInfo, int displayPrompt)
d259 1
a259 1
	  tuiSetSourceContentNil (winInfo, noSrcStr);
a291 3
/*
   ** tuiShowSourceContent().
 */
d293 1
a293 1
tuiShowSourceContent (TuiWinInfoPtr winInfo)
d303 1
a303 1
    tuiEraseSourceContent (winInfo, TRUE);
d311 1
a311 4
/*
   ** tuiHorizontalSourceScroll().
   **      Scroll the source forward or backward horizontally
 */
d313 3
a315 3
tuiHorizontalSourceScroll (TuiWinInfoPtr winInfo,
                           TuiScrollDirection direction,
                           int numToScroll)
d337 4
a340 6
      tuiUpdateSourceWindowAsIs (
				  winInfo,
				  s,
				  ((TuiWinElementPtr)
				   winInfo->generic.content[0])->whichElement.source.lineOrAddr,
				  FALSE);
d349 1
a349 1
tuiSetIsExecPointAt (TuiLineOrAddress l, TuiWinInfoPtr winInfo)
d391 1
a391 1
          tuiUpdateExecInfo (win);
d542 1
a542 1
}				/* tuiShowExecInfoContent */
a544 3
/*
   ** tuiEraseExecInfoContent().
 */
d546 1
a546 1
tuiEraseExecInfoContent (TuiWinInfoPtr winInfo)
d554 1
a554 1
}				/* tuiEraseExecInfoContent */
a555 3
/*
   ** tuiClearExecInfoContent().
 */
d557 1
a557 1
tuiClearExecInfoContent (TuiWinInfoPtr winInfo)
d560 1
a560 1
  tuiEraseExecInfoContent (winInfo);
d563 1
a563 1
}				/* tuiClearExecInfoContent */
d565 1
a565 4
/*
   ** tuiUpdateExecInfo().
   **        Function to update the execution info window
 */
d567 1
a567 1
tuiUpdateExecInfo (TuiWinInfoPtr winInfo)
d573 2
a574 2
TuiStatus
tuiAllocSourceBuffer (TuiWinInfoPtr winInfo)
d620 2
a621 5
/*
   ** tuiLineIsDisplayed().
   **      Answer whether the a particular line number or address is displayed
   **      in the current source window.
 */
d623 2
a624 2
tuiLineIsDisplayed (int line, TuiWinInfoPtr winInfo,
                    int checkThreshold)
d643 1
a643 1
}				/* tuiLineIsDisplayed */
d646 2
a647 5
/*
   ** tuiLineIsDisplayed().
   **      Answer whether the a particular line number or address is displayed
   **      in the current source window.
 */
d649 1
a649 1
tuiAddrIsDisplayed (CORE_ADDR addr, TuiWinInfoPtr winInfo,
@


1.2
log
@2004-01-20  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-disasm.h: Update copyright.  Include "tui.h" and
	"tui-data.h".
	(tui_set_disassem_content): Rename tuiSetDisassemContent.
	(tui_show_disassem): Rename tuiShowDisassem.
	(tui_show_disassem_and_update_source): Rename
	tuiVerticalDisassemScroll.
	(tui_vertical_disassem_scroll): Rename tuiVerticalDisassemScroll.
	(tui_get_begin_asm_address): Rename tuiGetBeginAsmAddress.
	* tui/tui.h: Update copyright.
	(enum tui_status): Define.
	* tui/tui-data.h (enum tui_scroll_direction): Define.
	* tui/tui-disasm.c: Update copyright.  Update references.
	* tui/tui-winsource.c: 	Update copyright.  Update references.
	* tui/tui-win.c: Update references.
	* tui/tui-layout.c: Update references.
@
text
@d66 1
a66 1
             tuiUpdateLocatorFilename (sal.symtab->filename);
d68 1
a68 1
             tuiUpdateLocatorFilename ("??");
@


1.2.4.1
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@


1.1
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.
d58 1
a58 1
      addr = tuiGetBeginAsmAddress ();
d105 1
a105 1
    ret = tuiSetDisassemContent (lineOrAddr.addr);
d157 1
a157 1
	  tuiShowDisassem (addr);
d160 1
a160 1
	  tuiShowDisassemAndUpdateSource (addr);
d209 1
a209 1
	  tuiShowDisassem (pc);
@

