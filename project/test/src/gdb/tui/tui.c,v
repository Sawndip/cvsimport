head	1.74;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.74
	gdb_7_6-2013-04-26-release:1.74
	gdb_7_6-branch:1.74.0.2
	gdb_7_6-2013-03-12-branchpoint:1.74
	gdb_7_5_1-2012-11-29-release:1.70
	gdb_7_5-2012-08-17-release:1.70
	gdb_7_5-branch:1.70.0.2
	gdb_7_5-2012-07-18-branchpoint:1.70
	gdb_7_4_1-2012-04-26-release:1.69.4.1
	gdb_7_4-2012-01-24-release:1.69.4.1
	gdb_7_4-branch:1.69.0.4
	gdb_7_4-2011-12-13-branchpoint:1.69
	gdb_7_3_1-2011-09-04-release:1.69
	gdb_7_3-2011-07-26-release:1.69
	gdb_7_3-branch:1.69.0.2
	gdb_7_3-2011-04-01-branchpoint:1.69
	gdb_7_2-2010-09-02-release:1.68
	gdb_7_2-branch:1.68.0.2
	gdb_7_2-2010-07-07-branchpoint:1.68
	gdb_7_1-2010-03-18-release:1.66
	gdb_7_1-branch:1.66.0.2
	gdb_7_1-2010-02-18-branchpoint:1.66
	gdb_7_0_1-2009-12-22-release:1.65
	gdb_7_0-2009-10-06-release:1.65
	gdb_7_0-branch:1.65.0.4
	gdb_7_0-2009-09-16-branchpoint:1.65
	arc-sim-20090309:1.63
	msnyder-checkpoint-072509-branch:1.65.0.2
	msnyder-checkpoint-072509-branchpoint:1.65
	arc-insight_6_8-branch:1.63.0.16
	arc-insight_6_8-branchpoint:1.63
	insight_6_8-branch:1.63.0.14
	insight_6_8-branchpoint:1.63
	reverse-20081226-branch:1.63.0.12
	reverse-20081226-branchpoint:1.63
	multiprocess-20081120-branch:1.63.0.10
	multiprocess-20081120-branchpoint:1.63
	reverse-20080930-branch:1.63.0.8
	reverse-20080930-branchpoint:1.63
	reverse-20080717-branch:1.63.0.6
	reverse-20080717-branchpoint:1.63
	msnyder-reverse-20080609-branch:1.63.0.4
	msnyder-reverse-20080609-branchpoint:1.63
	drow-reverse-20070409-branch:1.57.0.2
	drow-reverse-20070409-branchpoint:1.57
	gdb_6_8-2008-03-27-release:1.63
	gdb_6_8-branch:1.63.0.2
	gdb_6_8-2008-02-26-branchpoint:1.63
	gdb_6_7_1-2007-10-29-release:1.62
	gdb_6_7-2007-10-10-release:1.62
	gdb_6_7-branch:1.62.0.2
	gdb_6_7-2007-09-07-branchpoint:1.62
	insight_6_6-20070208-release:1.55
	gdb_6_6-2006-12-18-release:1.55
	gdb_6_6-branch:1.55.0.18
	gdb_6_6-2006-11-15-branchpoint:1.55
	insight_6_5-20061003-release:1.55
	gdb-csl-symbian-6_4_50_20060226-12:1.55
	gdb-csl-sourcerygxx-3_4_4-25:1.54
	nickrob-async-20060828-mergepoint:1.55
	gdb-csl-symbian-6_4_50_20060226-11:1.55
	gdb-csl-sourcerygxx-4_1-17:1.55
	gdb-csl-20060226-branch-local-2:1.55
	gdb-csl-sourcerygxx-4_1-14:1.55
	gdb-csl-sourcerygxx-4_1-13:1.55
	gdb-csl-sourcerygxx-4_1-12:1.55
	gdb-csl-sourcerygxx-3_4_4-21:1.55
	gdb_6_5-20060621-release:1.55
	gdb-csl-sourcerygxx-4_1-9:1.55
	gdb-csl-sourcerygxx-4_1-8:1.55
	gdb-csl-sourcerygxx-4_1-7:1.55
	gdb-csl-arm-2006q1-6:1.55
	gdb-csl-sourcerygxx-4_1-6:1.55
	gdb-csl-symbian-6_4_50_20060226-10:1.55
	gdb-csl-symbian-6_4_50_20060226-9:1.55
	gdb-csl-symbian-6_4_50_20060226-8:1.55
	gdb-csl-coldfire-4_1-11:1.55
	gdb-csl-sourcerygxx-3_4_4-19:1.55
	gdb-csl-coldfire-4_1-10:1.55
	gdb_6_5-branch:1.55.0.16
	gdb_6_5-2006-05-14-branchpoint:1.55
	gdb-csl-sourcerygxx-4_1-5:1.55
	nickrob-async-20060513-branch:1.55.0.14
	nickrob-async-20060513-branchpoint:1.55
	gdb-csl-sourcerygxx-4_1-4:1.55
	msnyder-reverse-20060502-branch:1.55.0.12
	msnyder-reverse-20060502-branchpoint:1.55
	gdb-csl-morpho-4_1-4:1.55
	gdb-csl-sourcerygxx-3_4_4-17:1.55
	readline_5_1-import-branch:1.55.0.10
	readline_5_1-import-branchpoint:1.55
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.55
	gdb-csl-symbian-20060226-branch:1.55.0.8
	gdb-csl-symbian-20060226-branchpoint:1.55
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.55
	msnyder-reverse-20060331-branch:1.55.0.6
	msnyder-reverse-20060331-branchpoint:1.55
	gdb-csl-available-20060303-branch:1.55.0.4
	gdb-csl-available-20060303-branchpoint:1.55
	gdb-csl-20060226-branch:1.55.0.2
	gdb-csl-20060226-branchpoint:1.55
	gdb_6_4-20051202-release:1.54
	msnyder-fork-checkpoint-branch:1.54.0.10
	msnyder-fork-checkpoint-branchpoint:1.54
	gdb-csl-gxxpro-6_3-branch:1.54.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.54
	gdb_6_4-branch:1.54.0.6
	gdb_6_4-2005-11-01-branchpoint:1.54
	gdb-csl-arm-20051020-branch:1.54.0.4
	gdb-csl-arm-20051020-branchpoint:1.54
	msnyder-tracepoint-checkpoint-branch:1.54.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.54
	gdb-csl-arm-20050325-2005-q1b:1.53
	gdb-csl-arm-20050325-2005-q1a:1.53
	csl-arm-20050325-branch:1.53.0.2
	csl-arm-20050325-branchpoint:1.53
	gdb-post-i18n-errorwarning-20050211:1.53
	gdb-pre-i18n-errorwarning-20050211:1.53
	gdb_6_3-20041109-release:1.52
	gdb_6_3-branch:1.52.0.2
	gdb_6_3-20041019-branchpoint:1.52
	drow_intercu-merge-20040921:1.52
	drow_intercu-merge-20040915:1.52
	jimb-gdb_6_2-e500-branch:1.51.0.6
	jimb-gdb_6_2-e500-branchpoint:1.51
	gdb_6_2-20040730-release:1.51
	gdb_6_2-branch:1.51.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.51
	gdb_6_1_1-20040616-release:1.50
	gdb_6_1-2004-04-05-release:1.50
	drow_intercu-merge-20040402:1.50
	drow_intercu-merge-20040327:1.50
	ezannoni_pie-20040323-branch:1.50.0.6
	ezannoni_pie-20040323-branchpoint:1.50
	cagney_tramp-20040321-mergepoint:1.50
	cagney_tramp-20040309-branch:1.50.0.4
	cagney_tramp-20040309-branchpoint:1.50
	gdb_6_1-branch:1.50.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.50
	drow_intercu-20040221-branch:1.47.0.2
	drow_intercu-20040221-branchpoint:1.47
	cagney_bfdfile-20040213-branch:1.46.0.2
	cagney_bfdfile-20040213-branchpoint:1.46
	drow-cplus-merge-20040208:1.43
	carlton_dictionary-20040126-merge:1.35
	cagney_bigcore-20040122-branch:1.34.0.2
	cagney_bigcore-20040122-branchpoint:1.34
	drow-cplus-merge-20040113:1.33
	drow-cplus-merge-20031224:1.33
	drow-cplus-merge-20031220:1.33
	carlton_dictionary-20031215-merge:1.33
	drow-cplus-merge-20031214:1.33
	carlton-dictionary-20031111-merge:1.33
	gdb_6_0-2003-10-04-release:1.31.2.2
	kettenis_sparc-20030918-branch:1.33.0.6
	kettenis_sparc-20030918-branchpoint:1.33
	carlton_dictionary-20030917-merge:1.33
	ezannoni_pie-20030916-branchpoint:1.33
	ezannoni_pie-20030916-branch:1.33.0.4
	cagney_x86i386-20030821-branch:1.33.0.2
	cagney_x86i386-20030821-branchpoint:1.33
	carlton_dictionary-20030805-merge:1.33
	carlton_dictionary-20030627-merge:1.31
	gdb_6_0-branch:1.31.0.2
	gdb_6_0-2003-06-23-branchpoint:1.31
	jimb-ppc64-linux-20030613-branch:1.30.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.30
	cagney_convert-20030606-branch:1.30.0.26
	cagney_convert-20030606-branchpoint:1.30
	cagney_writestrings-20030508-branch:1.30.0.24
	cagney_writestrings-20030508-branchpoint:1.30
	jimb-ppc64-linux-20030528-branch:1.30.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.30
	carlton_dictionary-20030523-merge:1.30
	cagney_fileio-20030521-branch:1.30.0.20
	cagney_fileio-20030521-branchpoint:1.30
	kettenis_i386newframe-20030517-mergepoint:1.30
	jimb-ppc64-linux-20030509-branch:1.30.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.30
	kettenis_i386newframe-20030504-mergepoint:1.30
	carlton_dictionary-20030430-merge:1.30
	kettenis_i386newframe-20030419-branch:1.30.0.16
	kettenis_i386newframe-20030419-branchpoint:1.30
	carlton_dictionary-20030416-merge:1.30
	cagney_frameaddr-20030409-mergepoint:1.30
	kettenis_i386newframe-20030406-branch:1.30.0.14
	kettenis_i386newframe-20030406-branchpoint:1.30
	cagney_frameaddr-20030403-branchpoint:1.30
	cagney_frameaddr-20030403-branch:1.30.0.12
	cagney_framebase-20030330-mergepoint:1.30
	cagney_framebase-20030326-branch:1.30.0.10
	cagney_framebase-20030326-branchpoint:1.30
	cagney_lazyid-20030317-branch:1.30.0.8
	cagney_lazyid-20030317-branchpoint:1.30
	kettenis-i386newframe-20030316-mergepoint:1.30
	offbyone-20030313-branch:1.30.0.6
	offbyone-20030313-branchpoint:1.30
	kettenis-i386newframe-20030308-branch:1.30.0.4
	kettenis-i386newframe-20030308-branchpoint:1.30
	carlton_dictionary-20030305-merge:1.30
	cagney_offbyone-20030303-branch:1.30.0.2
	cagney_offbyone-20030303-branchpoint:1.30
	carlton_dictionary-20030207-merge:1.28
	interps-20030203-mergepoint:1.28
	interps-20030202-branch:1.28.0.4
	interps-20030202-branchpoint:1.28
	cagney-unwind-20030108-branch:1.28.0.2
	cagney-unwind-20030108-branchpoint:1.28
	carlton_dictionary-20021223-merge:1.28
	gdb_5_3-2002-12-12-release:1.25.2.1
	carlton_dictionary-20021115-merge:1.27
	kseitz_interps-20021105-merge:1.27
	kseitz_interps-20021103-merge:1.27
	drow-cplus-merge-20021020:1.27
	drow-cplus-merge-20021025:1.27
	carlton_dictionary-20021025-merge:1.27
	carlton_dictionary-20021011-merge:1.27
	drow-cplus-branch:1.27.0.2
	drow-cplus-branchpoint:1.27
	kseitz_interps-20020930-merge:1.27
	carlton_dictionary-20020927-merge:1.26
	carlton_dictionary-branch:1.26.0.2
	carlton_dictionary-20020920-branchpoint:1.26
	gdb_5_3-branch:1.25.0.2
	gdb_5_3-2002-09-04-branchpoint:1.25
	kseitz_interps-20020829-merge:1.23
	cagney_sysregs-20020825-branch:1.20.0.2
	cagney_sysregs-20020825-branchpoint:1.20
	readline_4_3-import-branch:1.17.0.2
	readline_4_3-import-branchpoint:1.17
	gdb_5_2_1-2002-07-23-release:1.16
	kseitz_interps-20020528-branch:1.16.0.8
	kseitz_interps-20020528-branchpoint:1.16
	cagney_regbuf-20020515-branch:1.16.0.6
	cagney_regbuf-20020515-branchpoint:1.16
	jimb-macro-020506-branch:1.16.0.4
	jimb-macro-020506-branchpoint:1.16
	gdb_5_2-2002-04-29-release:1.16
	gdb_5_2-branch:1.16.0.2
	gdb_5_2-2002-03-03-branchpoint:1.16
	gdb_5_1_1-2002-01-24-release:1.13.2.1
	gdb_5_1_0_1-2002-01-03-release:1.13.2.1
	cygnus_cvs_20020108_pre:1.14
	gdb_5_1_0_1-2002-01-03-branch:1.13.2.1.0.4
	gdb_5_1_0_1-2002-01-03-branchpoint:1.13.2.1
	gdb_5_1-2001-11-21-release:1.13.2.1
	gdb_s390-2001-09-26-branch:1.13.2.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.13.2.1
	gdb_5_1-2001-07-29-branch:1.13.0.2
	gdb_5_1-2001-07-29-branchpoint:1.13
	dberlin-typesystem-branch:1.5.0.2
	dberlin-typesystem-branchpoint:1.5
	gdb-post-ptid_t-2001-05-03:1.5
	gdb-pre-ptid_t-2001-05-03:1.5
	insight-precleanup-2001-01-01:1.5
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.74
date	2013.02.03.16.16.42;	author jkratoch;	state Exp;
branches;
next	1.73;

1.73
date	2013.01.01.06.41.30;	author brobecke;	state Exp;
branches;
next	1.72;

1.72
date	2012.11.10.13.12.18;	author ciceron;	state Exp;
branches;
next	1.71;

1.71
date	2012.11.10.12.25.07;	author ciceron;	state Exp;
branches;
next	1.70;

1.70
date	2012.01.04.08.27.59;	author brobecke;	state Exp;
branches;
next	1.69;

1.69
date	2011.01.01.15.33.53;	author brobecke;	state Exp;
branches
	1.69.4.1;
next	1.68;

1.68
date	2010.05.17.22.21.43;	author msnyder;	state Exp;
branches;
next	1.67;

1.67
date	2010.03.30.22.21.34;	author palves;	state Exp;
branches;
next	1.66;

1.66
date	2010.01.01.07.32.07;	author brobecke;	state Exp;
branches;
next	1.65;

1.65
date	2009.07.02.17.17.42;	author uweigand;	state Exp;
branches;
next	1.64;

1.64
date	2009.01.03.05.58.08;	author brobecke;	state Exp;
branches;
next	1.63;

1.63
date	2008.01.01.22.53.22;	author drow;	state Exp;
branches;
next	1.62;

1.62
date	2007.08.23.18.08.50;	author brobecke;	state Exp;
branches;
next	1.61;

1.61
date	2007.08.14.23.50.39;	author msnyder;	state Exp;
branches;
next	1.60;

1.60
date	2007.08.14.21.39.22;	author msnyder;	state Exp;
branches;
next	1.59;

1.59
date	2007.08.14.21.20.09;	author msnyder;	state Exp;
branches;
next	1.58;

1.58
date	2007.08.14.20.23.29;	author msnyder;	state Exp;
branches;
next	1.57;

1.57
date	2007.02.27.19.46.04;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2007.01.09.17.59.15;	author drow;	state Exp;
branches;
next	1.55;

1.55
date	2005.12.23.19.10.03;	author eliz;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.27.04.39.33;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2004.11.09.00.59.03;	author danglin;	state Exp;
branches;
next	1.52;

1.52
date	2004.09.07.21.55.12;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2004.04.09.13.44.02;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2004.02.28.18.04.37;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2004.02.28.15.02.35;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2004.02.26.02.08.04;	author brobecke;	state Exp;
branches;
next	1.47;

1.47
date	2004.02.18.17.24.36;	author kettenis;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2004.02.10.19.08.19;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2004.02.08.01.32.26;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2004.02.08.00.05.16;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2004.02.07.20.57.02;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.07.17.46.14;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.07.16.31.22;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.07.04.40.36;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.07.01.02.54;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2004.02.07.00.23.56;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.06.22.42.18;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.28.23.16.50;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.23.23.25.17;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.19.04.31.51;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.24.20.23.17;	author ciceron;	state Exp;
branches
	1.33.4.1;
next	1.32;

1.32
date	2003.07.23.21.40.59;	author ciceron;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.22.15.21.38;	author drow;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2003.02.14.13.58.06;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.12.15.14.36;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.29.19.15.16;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.30.00.52.27;	author ezannoni;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2002.09.13.20.06.56;	author ciceron;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2002.09.03.20.47.48;	author ciceron;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2002.08.31.12.02.14;	author ciceron;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.28.20.33.27;	author ciceron;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.26.19.35.37;	author ciceron;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.25.21.44.41;	author ciceron;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.24.17.04.33;	author ciceron;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.24.16.43.08;	author ciceron;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.24.15.25.25;	author ciceron;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.18.23.20.47;	author drow;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.01.06.19.27;	author cagney;	state Exp;
branches
	1.16.2.1
	1.16.8.1;
next	1.15;

1.15
date	2002.02.08.15.54.32;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.31.19.00.50;	author ciceron;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.23.21.13.57;	author ciceron;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.07.21.22.24.44;	author ciceron;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.21.20.49.56;	author ciceron;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.21.19.59.14;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.18.22.03.22;	author ciceron;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.17.21.37.18;	author ciceron;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.14.19.31.09;	author ciceron;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.14.19.01.25;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.01.01.51;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.01.12.42;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.26.04.11.34;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.12;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.69.4.1
date	2012.01.06.04.54.36;	author brobecke;	state Exp;
branches;
next	;

1.47.2.1
date	2004.03.27.17.38.05;	author drow;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2004.09.16.17.01.48;	author drow;	state Exp;
branches;
next	;

1.33.4.1
date	2004.03.23.20.09.16;	author ezannoni;	state Exp;
branches;
next	;

1.31.2.1
date	2003.07.23.21.41.22;	author ciceron;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2003.07.24.20.27.00;	author ciceron;	state Exp;
branches;
next	;

1.27.2.1
date	2003.12.14.20.27.59;	author drow;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2004.02.09.19.43.58;	author drow;	state Exp;
branches;
next	;

1.26.2.1
date	2002.10.11.22.23.03;	author carlton;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2002.12.23.19.39.21;	author carlton;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2003.03.06.00.56.37;	author carlton;	state Exp;
branches;
next	1.26.2.4;

1.26.2.4
date	2003.06.27.21.50.21;	author carlton;	state Exp;
branches;
next	1.26.2.5;

1.26.2.5
date	2003.08.05.17.13.26;	author carlton;	state Exp;
branches;
next	1.26.2.6;

1.26.2.6
date	2004.01.26.19.11.45;	author carlton;	state Exp;
branches;
next	;

1.25.2.1
date	2002.09.13.20.08.29;	author ciceron;	state Exp;
branches;
next	;

1.16.2.1
date	2002.08.18.23.42.03;	author drow;	state Exp;
branches;
next	;

1.16.8.1
date	2002.08.30.22.52.52;	author kseitz;	state Exp;
branches;
next	1.16.8.2;

1.16.8.2
date	2002.10.01.00.46.34;	author kseitz;	state Exp;
branches;
next	;

1.13.2.1
date	2001.07.31.19.21.31;	author ciceron;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.12;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.19.07;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.10.19.02.46.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.74
log
@gdb/
	* source.c (print_source_lines_base): Print for TUI also "fullname".
	* tui/tui-data.c (init_content_element): Change tui_locator_element
	field to full_name.
	* tui/tui-data.h (struct tui_locator_element): Likewise.
	* tui/tui-disasm.c (tui_show_disassem_and_update_source): Rename
	tui_update_locator_filename calls to tui_update_locator_fullname.
	Replace symtab->filename refererence by symtab_to_fullname call.
	* tui/tui-out.c (tui_field_string): Check for "fullname" now.
	* tui/tui-source.c (tui_set_source_content): Change tui_locator_element
	field to full_name.  Replace symtab->filename refererence by
	symtab_to_fullname call.
	(tui_show_symtab_source): Rename parameter to fullname.  Change
	tui_locator_element field to full_name.
	* tui/tui-stack.c: Include source.h.
	(tui_set_locator_filename): Rename the declaration to ...
	(tui_set_locator_fullname): ... here.  Rename its parameter to
	fullname, updates its comment.
	(tui_set_locator_info): Rename its parameter to fullname.
	(tui_set_locator_filename): Rename the definition to ...
	(tui_set_locator_fullname): ... here.  Rename its parameter to
	fullname, updates its comment.  Change tui_locator_element field to
	full_name.
	(tui_set_locator_info): Rename its parameter to fullname.
	(tui_set_locator_info): Rename callee to tui_set_locator_fullname.
	(tui_update_locator_filename): Rename to ...
	(tui_update_locator_fullname): ... here. Rename callee to
	tui_set_locator_fullname.
	(tui_show_frame_info): Replace symtab->filename refererence by
	symtab_to_fullname call.
	* tui/tui-stack.h (tui_update_locator_filename): Rename to ...
	(tui_update_locator_fullname): ... here.
	* tui/tui-winsource.c (tui_display_main): Rename the callee to
	tui_update_locator_fullname.  Replace symtab->filename refererence by
	symtab_to_fullname call.
	* tui/tui.c (tui_show_source): Rename its parameter to fullname.
	Rename the callee to tui_update_locator_fullname.
	* tui/tui.h (tui_show_source): Rename its parameter to fullname.
@
text
@/* General functions for the WDB TUI.

   Copyright (C) 1998-2013 Free Software Foundation, Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdbcmd.h"
#include "tui/tui.h"
#include "tui/tui-hooks.h"
#include "tui/tui-data.h"
#include "tui/tui-layout.h"
#include "tui/tui-io.h"
#include "tui/tui-regs.h"
#include "tui/tui-stack.h"
#include "tui/tui-win.h"
#include "tui/tui-winsource.h"
#include "tui/tui-windata.h"
#include "target.h"
#include "frame.h"
#include "breakpoint.h"
#include "inferior.h"
#include "symtab.h"
#include "source.h"

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <signal.h>
#include <fcntl.h>
#if 0
#include <termio.h>
#endif
#include <setjmp.h>

#include "gdb_curses.h"

/* This redefines CTRL if it is not already defined, so it must come
   after terminal state releated include files like <term.h> and
   "gdb_curses.h".  */
#include "readline/readline.h"

/* Tells whether the TUI is active or not.  */
int tui_active = 0;
static int tui_finish_init = 1;

enum tui_key_mode tui_current_key_mode = TUI_COMMAND_MODE;

struct tui_char_command
{
  unsigned char key;
  const char *cmd;
};

/* Key mapping to gdb commands when the TUI is using the single key
   mode.  */
static const struct tui_char_command tui_commands[] = {
  { 'c', "continue" },
  { 'd', "down" },
  { 'f', "finish" },
  { 'n', "next" },
  { 'r', "run" },
  { 's', "step" },
  { 'u', "up" },
  { 'v', "info locals" },
  { 'w', "where" },
  { 0, 0 },
};

static Keymap tui_keymap;
static Keymap tui_readline_standard_keymap;

/* TUI readline command.
   Switch the output mode between TUI/standard gdb.  */
static int
tui_rl_switch_mode (int notused1, int notused2)
{
  if (tui_active)
    {
      tui_disable ();
      rl_prep_terminal (0);
    }
  else
    {
      rl_deprep_terminal ();
      tui_enable ();
    }

  /* Clear the readline in case switching occurred in middle of
     something.  */
  if (rl_end)
    rl_kill_text (0, rl_end);

  /* Since we left the curses mode, the terminal mode is restored to
     some previous state.  That state may not be suitable for readline
     to work correctly (it may be restored in line mode).  We force an
     exit of the current readline so that readline is re-entered and
     it will be able to setup the terminal for its needs.  By
     re-entering in readline, we also redisplay its prompt in the
     non-curses mode.  */
  rl_newline (1, '\n');

  /* Make sure the \n we are returning does not repeat the last
     command.  */
  dont_repeat ();
  return 0;
}

/* TUI readline command.
   Change the TUI layout to show a next layout.
   This function is bound to CTRL-X 2.  It is intended to provide
   a functionality close to the Emacs split-window command.  We
   always show two windows (src+asm), (src+regs) or (asm+regs).  */
static int
tui_rl_change_windows (int notused1, int notused2)
{
  if (!tui_active)
    tui_rl_switch_mode (0 /* notused */, 0 /* notused */);

  if (tui_active)
    {
      enum tui_layout_type new_layout;
      enum tui_register_display_type regs_type = TUI_UNDEFINED_REGS;

      new_layout = tui_current_layout ();

      /* Select a new layout to have a rolling layout behavior with
	 always two windows (except when undefined).  */
      switch (new_layout)
	{
	case SRC_COMMAND:
	  new_layout = SRC_DISASSEM_COMMAND;
	  break;

	case DISASSEM_COMMAND:
	  new_layout = SRC_DISASSEM_COMMAND;
	  break;

	case SRC_DATA_COMMAND:
	  new_layout = SRC_DISASSEM_COMMAND;
	  break;

	case SRC_DISASSEM_COMMAND:
	  new_layout = DISASSEM_DATA_COMMAND;
	  break;
	  
	case DISASSEM_DATA_COMMAND:
	  new_layout = SRC_DATA_COMMAND;
	  break;

	default:
	  new_layout = SRC_COMMAND;
	  break;
	}
      tui_set_layout (new_layout, regs_type);
    }
  return 0;
}

/* TUI readline command.
   Delete the second TUI window to only show one.  */
static int
tui_rl_delete_other_windows (int notused1, int notused2)
{
  if (!tui_active)
    tui_rl_switch_mode (0 /* notused */, 0 /* notused */);

  if (tui_active)
    {
      enum tui_layout_type new_layout;
      enum tui_register_display_type regs_type = TUI_UNDEFINED_REGS;

      new_layout = tui_current_layout ();

      /* Kill one window.  */
      switch (new_layout)
	{
	case SRC_COMMAND:
	case SRC_DATA_COMMAND:
	case SRC_DISASSEM_COMMAND:
	default:
	  new_layout = SRC_COMMAND;
	  break;

	case DISASSEM_COMMAND:
	case DISASSEM_DATA_COMMAND:
	  new_layout = DISASSEM_COMMAND;
	  break;
	}
      tui_set_layout (new_layout, regs_type);
    }
  return 0;
}

/* TUI readline command.
   Switch the active window to give the focus to a next window.  */
static int
tui_rl_other_window (int count, int key)
{
  struct tui_win_info *win_info;

  if (!tui_active)
    tui_rl_switch_mode (0 /* notused */, 0 /* notused */);

  win_info = tui_next_win (tui_win_with_focus ());
  if (win_info)
    {
      tui_set_win_focus_to (win_info);
      if (TUI_DATA_WIN && TUI_DATA_WIN->generic.is_visible)
        tui_refresh_data_win ();
      keypad (TUI_CMD_WIN->generic.handle, (win_info != TUI_CMD_WIN));
    }
  return 0;
}

/* TUI readline command.
   Execute the gdb command bound to the specified key.  */
static int
tui_rl_command_key (int count, int key)
{
  int i;

  reinitialize_more_filter ();
  for (i = 0; tui_commands[i].cmd; i++)
    {
      if (tui_commands[i].key == key)
        {
          /* Insert the command in the readline buffer.
             Avoid calling the gdb command here since it creates
             a possible recursion on readline if prompt_for_continue
             is called (See PR 9584).  The command will also appear
             in the readline history which turns out to be better.  */
          rl_insert_text (tui_commands[i].cmd);
          rl_newline (1, '\n');

          /* Switch to gdb command mode while executing the command.
             This way the gdb's continue prompty will be displayed.  */
          tui_set_key_mode (TUI_ONE_COMMAND_MODE);
          return 0;
        }
    }
  return 0;
}

/* TUI readline command.
   Temporarily leave the TUI SingleKey mode to allow editing
   a gdb command with the normal readline.  Once the command
   is executed, the TUI SingleKey mode is installed back.  */
static int
tui_rl_command_mode (int count, int key)
{
  tui_set_key_mode (TUI_ONE_COMMAND_MODE);
  return rl_insert (count, key);
}

/* TUI readline command.
   Switch between TUI SingleKey mode and gdb readline editing.  */
static int
tui_rl_next_keymap (int notused1, int notused2)
{
  if (!tui_active)
    tui_rl_switch_mode (0 /* notused */, 0 /* notused */);

  tui_set_key_mode (tui_current_key_mode == TUI_COMMAND_MODE
                    ? TUI_SINGLE_KEY_MODE : TUI_COMMAND_MODE);
  return 0;
}

/* Readline hook to redisplay ourself the gdb prompt.
   In the SingleKey mode, the prompt is not printed so that
   the command window is cleaner.  It will be displayed if
   we temporarily leave the SingleKey mode.  */
static int
tui_rl_startup_hook (void)
{
  rl_already_prompted = 1;
  if (tui_current_key_mode != TUI_COMMAND_MODE && immediate_quit == 0)
    tui_set_key_mode (TUI_SINGLE_KEY_MODE);
  tui_redisplay_readline ();
  return 0;
}

/* Change the TUI key mode by installing the appropriate readline
   keymap.  */
void
tui_set_key_mode (enum tui_key_mode mode)
{
  tui_current_key_mode = mode;
  rl_set_keymap (mode == TUI_SINGLE_KEY_MODE
                 ? tui_keymap : tui_readline_standard_keymap);
  tui_show_locator_content ();
}

/* Initialize readline and configure the keymap for the switching
   key shortcut.  */
void
tui_initialize_readline (void)
{
  int i;
  Keymap tui_ctlx_keymap;

  rl_initialize ();

  rl_add_defun ("tui-switch-mode", tui_rl_switch_mode, -1);
  rl_add_defun ("gdb-command", tui_rl_command_key, -1);
  rl_add_defun ("next-keymap", tui_rl_next_keymap, -1);

  tui_keymap = rl_make_bare_keymap ();
  tui_ctlx_keymap = rl_make_bare_keymap ();
  tui_readline_standard_keymap = rl_get_keymap ();

  for (i = 0; tui_commands[i].cmd; i++)
    rl_bind_key_in_map (tui_commands[i].key, tui_rl_command_key, tui_keymap);

  rl_generic_bind (ISKMAP, "\\C-x", (char*) tui_ctlx_keymap, tui_keymap);

  /* Bind all other keys to tui_rl_command_mode so that we switch
     temporarily from SingleKey mode and can enter a gdb command.  */
  for (i = ' '; i < 0x7f; i++)
    {
      int j;

      for (j = 0; tui_commands[j].cmd; j++)
        if (tui_commands[j].key == i)
          break;

      if (tui_commands[j].cmd)
        continue;

      rl_bind_key_in_map (i, tui_rl_command_mode, tui_keymap);
    }

  rl_bind_key_in_map ('a', tui_rl_switch_mode, emacs_ctlx_keymap);
  rl_bind_key_in_map ('a', tui_rl_switch_mode, tui_ctlx_keymap);
  rl_bind_key_in_map ('A', tui_rl_switch_mode, emacs_ctlx_keymap);
  rl_bind_key_in_map ('A', tui_rl_switch_mode, tui_ctlx_keymap);
  rl_bind_key_in_map (CTRL ('A'), tui_rl_switch_mode, emacs_ctlx_keymap);
  rl_bind_key_in_map (CTRL ('A'), tui_rl_switch_mode, tui_ctlx_keymap);
  rl_bind_key_in_map ('1', tui_rl_delete_other_windows, emacs_ctlx_keymap);
  rl_bind_key_in_map ('1', tui_rl_delete_other_windows, tui_ctlx_keymap);
  rl_bind_key_in_map ('2', tui_rl_change_windows, emacs_ctlx_keymap);
  rl_bind_key_in_map ('2', tui_rl_change_windows, tui_ctlx_keymap);
  rl_bind_key_in_map ('o', tui_rl_other_window, emacs_ctlx_keymap);
  rl_bind_key_in_map ('o', tui_rl_other_window, tui_ctlx_keymap);
  rl_bind_key_in_map ('q', tui_rl_next_keymap, tui_keymap);
  rl_bind_key_in_map ('s', tui_rl_next_keymap, emacs_ctlx_keymap);
  rl_bind_key_in_map ('s', tui_rl_next_keymap, tui_ctlx_keymap);
}

/* Enter in the tui mode (curses).
   When in normal mode, it installs the tui hooks in gdb, redirects
   the gdb output, configures the readline to work in tui mode.
   When in curses mode, it does nothing.  */
void
tui_enable (void)
{
  if (!tui_allowed_p ())
    error (_("TUI mode not allowed"));

  if (tui_active)
    return;

  /* To avoid to initialize curses when gdb starts, there is a defered
     curses initialization.  This initialization is made only once
     and the first time the curses mode is entered.  */
  if (tui_finish_init)
    {
      WINDOW *w;

      w = initscr ();
  
      cbreak ();
      noecho ();
      /* timeout (1); */
      nodelay(w, FALSE);
      nl();
      keypad (w, TRUE);
      rl_initialize ();
      tui_set_term_height_to (LINES);
      tui_set_term_width_to (COLS);
      def_prog_mode ();

      tui_show_frame_info (0);
      tui_set_layout (SRC_COMMAND, TUI_UNDEFINED_REGS);
      tui_set_win_focus_to (TUI_SRC_WIN);
      keypad (TUI_CMD_WIN->generic.handle, TRUE);
      wrefresh (TUI_CMD_WIN->generic.handle);
      tui_finish_init = 0;
    }
  else
    {
     /* Save the current gdb setting of the terminal.
        Curses will restore this state when endwin() is called.  */
     def_shell_mode ();
     clearok (stdscr, TRUE);
   }

  /* Install the TUI specific hooks.  */
  tui_install_hooks ();
  rl_startup_hook = tui_rl_startup_hook;

  tui_update_variables ();
  
  tui_setup_io (1);

  tui_active = 1;
  if (deprecated_safe_get_selected_frame ())
     tui_show_frame_info (deprecated_safe_get_selected_frame ());

  /* Restore TUI keymap.  */
  tui_set_key_mode (tui_current_key_mode);
  tui_refresh_all_win ();

  /* Update gdb's knowledge of its terminal.  */
  target_terminal_save_ours ();
  tui_update_gdb_sizes ();
}

/* Leave the tui mode.
   Remove the tui hooks and configure the gdb output and readline
   back to their original state.  The curses mode is left so that
   the terminal setting is restored to the point when we entered.  */
void
tui_disable (void)
{
  if (!tui_active)
    return;

  /* Restore initial readline keymap.  */
  rl_set_keymap (tui_readline_standard_keymap);

  /* Remove TUI hooks.  */
  tui_remove_hooks ();
  rl_startup_hook = 0;
  rl_already_prompted = 0;

  /* Leave curses and restore previous gdb terminal setting.  */
  endwin ();

  /* gdb terminal has changed, update gdb internal copy of it
     so that terminal management with the inferior works.  */
  tui_setup_io (0);

  /* Update gdb's knowledge of its terminal.  */
  target_terminal_save_ours ();

  tui_active = 0;
  tui_update_gdb_sizes ();
}

void
strcat_to_buf (char *buf, int buflen, 
	       const char *item_to_add)
{
  if (item_to_add != (char *) NULL && buf != (char *) NULL)
    {
      if ((strlen (buf) + strlen (item_to_add)) <= buflen)
	strcat (buf, item_to_add);
      else
	strncat (buf, item_to_add, (buflen - strlen (buf)));
    }
}

#if 0
/* Solaris <sys/termios.h> defines CTRL.  */
#ifndef CTRL
#define CTRL(x)         (x & ~0140)
#endif

#define FILEDES         2
#define CHK(val, dft)   (val<=0 ? dft : val)

static void
tui_reset (void)
{
  struct termio mode;

  /* Reset the teletype mode bits to a sensible state.
     Copied tset.c.  */
#if defined (TIOCGETC)
  struct tchars tbuf;
#endif /* TIOCGETC */
#ifdef UCB_NTTY
  struct ltchars ltc;

  if (ldisc == NTTYDISC)
    {
      ioctl (FILEDES, TIOCGLTC, &ltc);
      ltc.t_suspc = CHK (ltc.t_suspc, CTRL ('Z'));
      ltc.t_dsuspc = CHK (ltc.t_dsuspc, CTRL ('Y'));
      ltc.t_rprntc = CHK (ltc.t_rprntc, CTRL ('R'));
      ltc.t_flushc = CHK (ltc.t_flushc, CTRL ('O'));
      ltc.t_werasc = CHK (ltc.t_werasc, CTRL ('W'));
      ltc.t_lnextc = CHK (ltc.t_lnextc, CTRL ('V'));
      ioctl (FILEDES, TIOCSLTC, &ltc);
    }
#endif /* UCB_NTTY */
#ifdef TIOCGETC
  ioctl (FILEDES, TIOCGETC, &tbuf);
  tbuf.t_intrc = CHK (tbuf.t_intrc, CTRL ('?'));
  tbuf.t_quitc = CHK (tbuf.t_quitc, CTRL ('\\'));
  tbuf.t_startc = CHK (tbuf.t_startc, CTRL ('Q'));
  tbuf.t_stopc = CHK (tbuf.t_stopc, CTRL ('S'));
  tbuf.t_eofc = CHK (tbuf.t_eofc, CTRL ('D'));
  /* brkc is left alone.  */
  ioctl (FILEDES, TIOCSETC, &tbuf);
#endif /* TIOCGETC */
  mode.sg_flags &= ~(RAW
#ifdef CBREAK
		     | CBREAK
#endif /* CBREAK */
		     | VTDELAY | ALLDELAY);
  mode.sg_flags |= XTABS | ECHO | CRMOD | ANYP;

  return;
}
#endif

void
tui_show_source (const char *fullname, int line)
{
  struct symtab_and_line cursal = get_current_source_symtab_and_line ();

  /* Make sure that the source window is displayed.  */
  tui_add_win_to_layout (SRC_WIN);

  tui_update_source_windows_with_line (cursal.symtab, line);
  tui_update_locator_fullname (fullname);
}

void
tui_show_assembly (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  tui_add_win_to_layout (DISASSEM_WIN);
  tui_update_source_windows_with_addr (gdbarch, addr);
}

int
tui_is_window_visible (enum tui_win_type type)
{
  if (tui_active == 0)
    return 0;

  if (tui_win_list[type] == 0)
    return 0;
  
  return tui_win_list[type]->generic.is_visible;
}

int
tui_get_command_dimension (unsigned int *width, 
			   unsigned int *height)
{
  if (!tui_active || (TUI_CMD_WIN == NULL))
    {
      return 0;
    }
  
  *width = TUI_CMD_WIN->generic.width;
  *height = TUI_CMD_WIN->generic.height;
  return 1;
}
@


1.73
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d535 1
a535 1
tui_show_source (const char *file, int line)
d543 1
a543 1
  tui_update_locator_filename (file);
@


1.72
log
@* tui/tui.c (tui_rl_command_key): Switch to TUI_ONE_COMMAND_MODE
while executing the gdb command.
(tui_rl_startup_hook): Do not switch back to TUI_SINGLE_KEY_MODE if we
are called from prompt_for_continue.
* tui/tui-io.c (tui_redisplay_readline): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 1998-2004, 2007-2012 Free Software Foundation, Inc.
@


1.71
log
@PR tui/9584

* tui/tui.c (tui_rl_command_key): Do not call execute_command
  but insert the command to execute in readline's buffer.
@
text
@d250 4
d292 1
a292 1
  if (tui_current_key_mode != TUI_COMMAND_MODE)
@


1.70
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d243 7
a249 6
          /* Must save the command because it can be modified by
             execute_command.  */
          char *cmd = alloca (strlen (tui_commands[i].cmd) + 1);

          strcpy (cmd, tui_commands[i].cmd);
          execute_command (cmd, TRUE);
@


1.69
log
@run copyright.sh for 2011.
@
text
@d3 1
a3 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.69.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1998-2004, 2007-2012 Free Software Foundation, Inc.
@


1.68
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* tui/tui.c: White space.
	* tui/tui-data.c: White space.
	* tui/tui-disasm.c: White space.
	* tui/tui-file.c: White space.
	* tui/tui-interp.c: White space.
	* tui/tui-main.c: White space.
	* tui/tui-out.c: White space.
	* tui/tui-regs.c: White space.
	* tui/tui-source.c: White space.
	* tui/tui-stack.c: White space.
	* tui/tui-win.c: White space.
	* tui/tui-winsource.c: White space.
@
text
@d4 1
a4 1
   2010 Free Software Foundation, Inc.
@


1.67
log
@	* tui/tui-interp.c (tui_is_toplevel): New.
	(tui_init): Set it.
	(tui_allowed_p): New.
	* tui/tui.c (tui_enable): Check if the TUI is allowed before
	enabling it.
	* tui/tui.h (tui_allowed_p): Declare.
@
text
@d247 1
d534 1
@


1.66
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d367 3
@


1.65
log
@	* disasm.h (gdb_disassembly): Add GDBARCH parameter.
	(gdb_print_insn): Likewise.
	* disasm.c (dump_insns): Add GDBARCH parameter.  Use it instead
	of current_gdbarch.
	(do_mixed_source_and_assembly): Add GDBARCH parameter.  Pass to
	dump_insns.
	(do_assembly_only): Likewise.
	(gdb_disassembly): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.  Pass to subroutines.
	(gdb_print_insn): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.

	* stack.c (struct gdb_disassembly_stub_args): Add GDBARCH member.
	(gdb_disassembly_stub): Pass architecture to gdb_disassembly.
	(do_gdb_disassembly): Add GDBARCH argument.  Store into args.
	(print_frame_info): Pass architecture to do_gdb_disassembly.

	* printcmd.c (print_formatted): Pass architecture to gdb_print_insn.

	* mi/mi-cmd-disas.c: Include "arch-utils.h"
	(mi_cmd_disassemble): Pass architecture to gdb_disassembly.

	* cli/cli-cmds.c: Include "arch-utils.h".
	(print_disassembly): Add GDBARCH parameter.  Pass to gdb_disassembly
	and tui_show_assembly.
	(disassemble_current_function): Pass architecture to
	tui_get_low_disassembly_address and print_disassembly.
	(disassemble_command): Pass architecture to
	tui_get_low_disassembly_address and print_disassembly.

	* tui/tui.c (tui_show_assembly): Add GDBARCH parameter.  Pass to
	tui_update_source_windows_with_addr.

	* tui/tui-data.h (struct tui_locator_element): Add GDBARCH member.
	(struct tui_source_info): Likewise.
	* tui/tui-data.c (tui_clear_win_detail): Clear source_info.gdbarch.

	* tui/tui-disasm.c (tui_disassemble): Add GDBARCH parameter.
	Pass to gdb_print_insn.
	(tui_find_disassembly_address): Add GDBARCH parameter.  Pass to
	tui_disassemble.
	(tui_set_disassem_content): Add GDBARCH parameter.  Install into
	source_info.gdbarch.  Pass to tui_disassemble.
	(tui_show_disassem): Add GDBARCH parameter.  Pass to
	tui_update_source_window.
	(tui_show_disassem_and_update_source): Add GDBARCH parameter.  Pass to
	tui_show_disassem and tui_update_source_window.

	(tui_get_begin_asm_address): Return locator architecture in addition
	to locator PC value.

	(tui_get_low_disassembly_address): Add GDBARCH parameter.   Pass to
	tui_get_low_disassembly_address.

	(tui_vertical_disassem_scroll): Pass architecture to subroutines.

	* tui/tui-disasm.h (tui_set_disassem_content): Add GDBARCH parameter.
	(tui_show_disassem): Likewise.
	(tui_show_disassem_and_update_source): Likewise.
	(tui_get_begin_asm_address): Return architecture and PC value.

	* tui/tui.h (tui_get_low_disassembly_address): Add GDBARCH parameter.
	(tui_show_assembly): Add GDBARCH parameter.

	* tui/tui-layout.c (extract_display_start_addr): Return current window
	architecture in addition to current PC value.

	(tui_set_layout): Update calls to tui_get_low_disassembly_address and
	extract_display_start_addr.  Pass architecture to
	tui_update_source_windows_with_addr.

	* tui/tui-source.c: Include "objfiles.h".
	(tui_set_source_content): Initialize window architecture.
	(tui_show_symtab_source): Add GDBARCH parameter.  Pass to
	tui_update_source_window_as_is

	* tui/tui-source.h (tui_show_symtab_source): Add GDBARCH parameter.

	* tui/tui-stack.c (tui_set_locator_info): Add GDBARCH parameter.
	Install locator architecture.
	(tui_set_locator_filename): Update call.
	(tui_show_frame_info): Pass architecture to tui_set_locator_info
	and subroutines.

	* tui/tui-win.c (make_visible_with_new_height): Pass architecture
	to tui_update_source_window.

	* tui/tui-winsource.c: Include "objfiles.h".
	(tui_display_main): Update call to tui_get_begin_asm_address.
	Pass architecture to tui_update_source_windows_with_addr.
	(tui_update_source_window): Add GDBARCH parameter.  Pass to
	tui_update_source_window_as_is.
	(tui_update_source_window_as_is): Add GDBARCH parameter.
	Pass to tui_set_disassem_content.
	(tui_update_source_windows_with_addr): Add GDBARCH parameter.
	Pass to subroutines.
	(tui_update_source_windows_with_line): Pass objfile architecture
	to subroutines.
	(tui_horizontal_source_scroll): Pass architecture to
	tui_update_source_window_as_is.

	* tui/tui-winsource.h (tui_update_source_window): Add GDBARCH
	parameter.
	(tui_update_source_window_as_is): Likewise.
	(tui_update_source_windows_with_addr): Likewise.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.64
log
@        Updated copyright notices for most files.
@
text
@d538 1
a538 1
tui_show_assembly (CORE_ADDR addr)
d541 1
a541 1
  tui_update_source_windows_with_addr (addr);
@


1.63
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
@


1.62
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007
@


1.61
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-data.c, tui-data.h, tui-disasm.c, tui-disasm.h, tui-hooks.c,
	tui-io.c, tui-layout.c, tui-layout.h, tui-out.c, tui-regs.c,
	tui-source.c, tui-source.h, tui-stack.c, tui-win.c, tui-win.h,
	tui-windata.c, tui-windata.h, tui-wingeneral.c, tui-winsource.c,
	tui-winsource.h, tui.c, tui.h: Function declarations and
	definitions, wrap long lines.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.60
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-disasm.c, tui-layout.c,
	tui-regs.c, tui-win.c, tui-windata.c, tui-winsource.c, tui.c:
	Reformat block comments to GNU standard.
@
text
@d461 2
a462 1
strcat_to_buf (char *buf, int buflen, const char *item_to_add)
d559 2
a560 1
tui_get_command_dimension (unsigned int *width, unsigned int *height)
@


1.59
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-data.h, tui-disasm.c, tui-file.c,
	tui-hooks.c, tui-interp.c, tui-io.c, tui-layout.c, tui-out.c,
	tui-regs.c, tui-regs.h, tui-source.c, tui-stack.c, tui-win.c,
	tui-windata.c, tui-wingeneral.c, tui-winsource.c, tui-winsource.h,
	tui.c, tui.h: Comment reformatting to coding standard (capitals,
	spaces after periods, etc).
@
text
@d486 2
a487 4
  /*
     ** Reset the teletype mode bits to a sensible state.
     ** Copied tset.c
   */
@


1.58
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-data.c, tui-data.h, tui-disasm.c, tui-hooks.c, tui-layout.c,
	tui-regs.c, tui-source.c, tui-stack.c, tui-win.c, tui-windata.c,
	tui-wingeneral.c, tui-wingeneral.h, tui-winsource.c, tui.c,
	tui-winsource.h: Whitespace changes, fix pointer declarations
	to be consistant.
@
text
@d73 2
a74 1
/* Key mapping to gdb commands when the TUI is using the single key mode.  */
d107 2
a108 1
  /* Clear the readline in case switching occurred in middle of something.  */
d115 4
a118 3
     exit of the current readline so that readline is re-entered and it
     will be able to setup the terminal for its needs.  By re-entering
     in readline, we also redisplay its prompt in the non-curses mode.  */
d121 2
a122 1
  /* Make sure the \n we are returning does not repeat the last command.  */
d130 2
a131 2
   a functionality close to the Emacs split-window command.  We always
   show two windows (src+asm), (src+regs) or (asm+regs).  */
d136 1
a136 1
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);
d145 2
a146 2
      /* Select a new layout to have a rolling layout behavior
	 with always two windows (except when undefined).  */
d184 1
a184 1
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);
d221 1
a221 1
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);
d246 2
a247 2
          /* Must save the command because it can be modified
             by execute_command.  */
d274 1
a274 1
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);
d295 2
a296 1
/* Change the TUI key mode by installing the appropriate readline keymap.  */
d383 1
a383 1
      /*timeout (1);*/
d473 1
a473 1
/* Solaris <sys/termios.h> defines CTRL. */
d487 1
a487 1
     ** reset the teletype mode bits to a sensible state.
d515 1
a515 1
  /* brkc is left alone */
d533 1
a533 1
  /* make sure that the source window is displayed */
@


1.57
log
@	* frame.c (deprecated_selected_frame): Rename to...
	(selected_frame): ...this.  Make static.
	(get_selected_frame, select_frame): Update.
	* frame.h (deprected_select_frame): Delete.
	(deprecated_safe_get_selected_frame): Update comments.

	* breakpoint.c, cli/cli-cmds.c, f-valprint.c, infcmd.c, inflow.c,
	infrun.c, stack.c, tui/tui-disasm.c, tui/tui-source.c,
	tui/tui-winsource.c, valops.c, varobj.c, findvar.c, macroscope.c,
	parse.c, regcache.h, sh64-tdep.c, tui/tui-hooks.c, tui/tui-win.c,
	tui/tui.c: Replace references to deprecated_selected_frame.
@
text
@d70 1
a70 1
  const char* cmd;
d214 1
a214 1
  struct tui_win_info * win_info;
d244 1
a244 1
          char* cmd = alloca (strlen (tui_commands[i].cmd) + 1);
@


1.56
log
@Copyright updates for 2007.
@
text
@d411 2
a412 2
  if (deprecated_selected_frame)
     tui_show_frame_info (deprecated_selected_frame);
@


1.55
log
@	* tui/tui-file.c:
	* tui/tui-disasm.c:
	* tui/tui-data.h:
	* tui/tui-data.c:
	* tui/tui-command.h:
	* tui/tui-command.c:
	* tui/tui-win.h:
	* tui/tui-win.h:
	* tui/tui-win.c:
	* tui/tui-stack.h:
	* tui/tui-stack.c:
	* tui/tui-source.h:
	* tui/tui-source.c:
	* tui/tui-regs.h:
	* tui/tui-regs.c:
	* tui/tui-out.c:
	* tui/tui-main.c:
	* tui/tui-layout.h:
	* tui/tui-layout.c:
	* tui/tui-io.h:
	* tui/tui-io.c:
	* tui/tui-interp.c:
	* tui/tui-hooks.h:
	* tui/tui-hooks.c:
	* tui/tui-file.h:
	* tui/tui.h:
	* tui/tui.c:
	* tui/tui-winsource.h:
	* tui/tui-winsource.c:
	* tui/tui-wingeneral.h:
	* tui/tui-wingeneral.c:
	* tui/tui-windata.h:
	* tui/tui-windata.c: Add (C) after Copyright.  Update the FSF
	address.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
@


1.54
log
@2005-05-27  Andrew Cagney  <cagney@@gnu.org>

	* jv-lang.c (get_java_utf8_name): Add cast.
	(evaluate_subexp_java): Use gdb_byte for buffers.
	* jv-valprint.c (java_value_print, java_value_print): Use gdb_byte
	for buffers.
	* scm-lang.c (scm_get_field, scm_unpack)
	(scm_evaluate_string): Use gdb_byte for buffers.
	(scm_lookup_name): Add cast.
	* scm-valprint.c (scm_scmval_print, scm_scmval_print): Use
	gdb_byte for buffers.
	* tui/tui.h (tui_get_command_dimension): Make parameters unsigned.
	* tui/tui.c (tui_get_command_dimension): Make parameters unsigned.
	* value.h (check_field): Change "name" to a string.
	* valops.c (check_field): Change "name" to a string.
	* scm-lang.h (scm_parse): Use gdb_byte for buffers.
	* source.c (get_current_source_symtab_and_line)
	(set_current_source_symtab_and_line): Initialize all fields of sal
	structures.
	* cli/cli-cmds.c (list_command): Use gdb_byte for buffers.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.53
log
@	* configure.in: Check for ncurses/term.h.
	* gdb_curses.h: Include term.h here, prefering ncurses/term.h.
	* utils.c: Include gdb_curses.h instead of curses.h and term.h.
	* tui/tui.c: Don't include term.h.
	* configure, config.in: Rebuilt.
@
text
@d555 1
a555 1
tui_get_command_dimension (int *width, int *height)
@


1.52
log
@2004-09-07  Andrew Cagney  <cagney@@gnu.org>

	* vx-share/wait.h: Delete #ifdef USG.
	* utils.c (request_quit): Ditto.
	* tui/tui.c (tui_reset): Ditto.
	* remote.c: Ditto.
	* remote-sds.c: Ditto.
	* remote-rdi.c: Ditto.
	* mdebugread.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* infttrace.c: Ditto.
	* infptrace.c: Ditto.
	* i386v-nat.c: Ditto.
	* exec.c: Ditto.
	* dbxread.c: Ditto.
	* core-aout.c: Ditto.
@
text
@a46 3
#ifdef HAVE_TERM_H
#include <term.h>
#endif
@


1.51
log
@* tui/tui.c: Fix typo in comment.
@
text
@d488 1
a488 1
#if ! defined (USG) && defined (TIOCGETC)
d490 1
a490 1
#endif /* !USG && TIOCGETC */
a505 1
#ifndef USG
a521 21
#else /*USG */
  ioctl (FILEDES, TCGETA, &mode);
  mode.c_cc[VINTR] = CHK (mode.c_cc[VINTR], CTRL ('?'));
  mode.c_cc[VQUIT] = CHK (mode.c_cc[VQUIT], CTRL ('\\'));
  mode.c_cc[VEOF] = CHK (mode.c_cc[VEOF], CTRL ('D'));

  mode.c_iflag &= ~(IGNBRK | PARMRK | INPCK | INLCR | IGNCR | IUCLC | IXOFF);
  mode.c_iflag |= (BRKINT | ISTRIP | ICRNL | IXON);
  mode.c_oflag &= ~(OLCUC | OCRNL | ONOCR | ONLRET | OFILL | OFDEL |
		    NLDLY | CRDLY | TABDLY | BSDLY | VTDLY | FFDLY);
  mode.c_oflag |= (OPOST | ONLCR);
  mode.c_cflag &= ~(CSIZE | PARODD | CLOCAL);
#ifndef hp9000s800
  mode.c_cflag |= (CS8 | CREAD);
#else /*hp9000s800 */
  mode.c_cflag |= (CS8 | CSTOPB | CREAD);
#endif /* hp9000s800 */
  mode.c_lflag &= ~(XCASE | ECHONL | NOFLSH);
  mode.c_lflag |= (ISIG | ICANON | ECHO | ECHOK);
  ioctl (FILEDES, TCSETAW, &mode);
#endif /* USG */
@


1.50
log
@2004-02-28  Andrew Cagney  <cagney@@redhat.com>

	* utils.c: Use "", instead of <>, to include readline.
	tui/tui-win.c, tui/tui.c, tui/tui-hooks.c: Ditto.
	* tracepoint.c, top.c, symmisc.c, symfile.c: Ditto.
	* source.c, solib.c, exec.c, event-top.c: Ditto.
	* corelow.c, completer.c, cli/cli-setshow.c: Ditto.
	* cli/cli-dump.c, cli/cli-cmds.c: Ditto.
	* Makefile.in: Update all dependencies.
	(readline_tilde_h, readline_history_h): Define.
	(readline_headers): Delete.
@
text
@d61 1
a61 1
   "gdb_ncurses.h".  */
@


1.49
log
@* tui/tui.c: Include <readline/readline.h> instead of
"readline/readline.h".  Include it after <term.h> and
"gdb_curses.h".
@
text
@d62 1
a62 1
#include <readline/readline.h>
@


1.48
log
@        * tui/tui.c: Move system header includes after local includes.
        Fixes a build failure on solaris systems.
@
text
@a36 1
#include "readline/readline.h"
d58 5
@


1.47
log
@* tui/tui.c: Don't include <malloc.h>.
@
text
@a24 12
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#ifdef HAVE_TERM_H
#include <term.h>
#endif
#include <signal.h>
#include <fcntl.h>
#if 0
#include <termio.h>
#endif
#include <setjmp.h>
d44 13
@


1.47.2.1
log
@Merge mainline to intercu branch.
@
text
@d25 12
d49 1
a56 13
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#ifdef HAVE_TERM_H
#include <term.h>
#endif
#include <signal.h>
#include <fcntl.h>
#if 0
#include <termio.h>
#endif
#include <setjmp.h>

a57 5

/* This redefines CTRL if it is not already defined, so it must come
   after terminal state releated include files like <term.h> and
   "gdb_ncurses.h".  */
#include "readline/readline.h"
@


1.47.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d61 1
a61 1
   "gdb_curses.h".  */
d488 1
a488 1
#if defined (TIOCGETC)
d490 1
a490 1
#endif /* TIOCGETC */
d506 1
d523 21
@


1.46
log
@2004-02-10  Andrew Cagney  <cagney@@redhat.com>

	* defs.h: Do not include "tui.h".
	* gdb_curses.h: New file.
	* tui/tui-hooks.h: New file.
	* tui/tui.h (tui_update_all_exec_infos): Delete declaration.
	(tui_install_hooks, tui_remove_hooks): Delete declarations.
	(tui_initialize_io): Delete declaration.
	(tui_initialize_readline: Delete redundant declaration.
	(struct tui_point): Delete definition.
	* tui/tui-data.h (struct tui_point): Define.
	* cli/cli-decode.c [TUI]: Include "tui/tui.h".
	* utils.c: Include "tui/tui.h".
	* tui/tui-data.h: Include "tui/tui.h" and "gdb_curses.h".
	* printcmd.c [TUI]: Include "tui/tui.h".
	* cli/cli-cmds.c [TUI]: Include "tui/tui.h".
	* tui/tui-command.c: Include "gdb_curses.h".
	* tui/tui.c, tui/tui-winsource.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-windata.c, tui/tui-win.c, tui/tui-stack.c: Ditto.
	* tui/tui-source.c, tui/tui-regs.c, tui/tui-layout.c: Ditto.
	* tui/tui-io.c, tui/tui-disasm.c, tui/tui-data.c: : Ditto.
	* tui/tui-hooks.c: Include "tui-hooks.h" and "gdb_curses.h".
	* Makefile.in: Update all dependencies.
	(tui_hooks_h, gdb_curses_h): Define.
	(SUBDIR_TUI_CFLAGS): Remove -I${srcdir}/tui.
@
text
@a27 1
#include <malloc.h>
@


1.45
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Include "gdb_string.h", delete register
	attribute, use ISO-C function signatures.
	* tui/tui-disasm.c, tui/tui-file.c, tui/tui-io.c: Ditto.
	* tui/tui-layout.c, tui/tui-regs.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-win.c, tui/tui-winsource.c: Ditto.
	* tui/tui.c: Ditto.
@
text
@d41 1
d58 1
a58 7
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
@


1.44
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Change variable and function names to lower
	case.
	* tui/tui-data.c, tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c, tui/tui-io.c, tui/tui-layout.c: Ditto.
	* tui/tui-regs.c, tui/tui-source.c, tui/tui-stack.c: Ditto.
	* tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d286 1
a286 1
tui_rl_startup_hook ()
d308 1
a308 1
tui_initialize_readline ()
@


1.43
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui.h: Do not include <stdarg.h>, <string.h>, and
	"ansidecl.h".  Do not undef "reg" and "chtype".  Fix case of
	fields and variables.
	* tui/tui-wingeneral.h (m_beVisible): Delete macro.
	(m_beInvisible): Delete macro.
	* tui/tui-data.h: Fix case case fields and variables.
	(m_genWinPtrIsNull): Delete macro.
	(tui_win_list): Rename winList.
	(TUI_SRC_WIN): Rename srcWin.
	(TUI_DISASM_WIN): Rename disassemWin.
	(TUI_DATA_WIN): Rename dataWin.
	(TUI_CMD_WIN): Rename cmdWin.
	(m_genWinPtrNotNull): Delete macro.
	(m_winPtrIsNull): Delete macro.
	(m_winPtrNotNull): Delete macro.
	(tui_win_is_source_type): Replace m_winIsSourceType
	(tui_win_is_auxillary): Replace m_winIsAuzillary.
	(tui_win_has_locator): Replace m_hasLocator.
	(tui_set_win_highlight): Replace m_setWinHighlightOn and
	m_setWinHighlightOff.
	* tui/tui-data.c: Update references.
	(tui_win_is_source_type, tui_set_win_highlight): New functions.
	(tui_win_has_locator, tui_win_is_auxillary): New functions.
	* tui/tui-command.c, tui/tui-disasm.c: Update references.
	* tui/tui-io.c, tui/tui-layout.c, tui/tui-regs.c: Ditto.
	* tui/tui-regs.h, tui/tui-source.c, tui/tui-stack.c: Ditto.
	* tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d218 1
a218 1
  struct tui_win_info * winInfo;
d223 2
a224 2
  winInfo = tui_next_win (tui_win_with_focus ());
  if (winInfo)
d226 1
a226 1
      tui_set_win_focus_to (winInfo);
d229 1
a229 1
      keypad (TUI_CMD_WIN->generic.handle, (winInfo != TUI_CMD_WIN));
d460 1
a460 1
strcat_to_buf (char *buf, int buflen, const char *itemToAdd)
d462 1
a462 1
  if (itemToAdd != (char *) NULL && buf != (char *) NULL)
d464 2
a465 2
      if ((strlen (buf) + strlen (itemToAdd)) <= buflen)
	strcat (buf, itemToAdd);
d467 1
a467 1
	strncat (buf, itemToAdd, (buflen - strlen (buf)));
d481 1
a481 1
_tuiReset (void)
d547 1
a547 1
}				/* _tuiReset */
@


1.42
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui.h (Opaque, OpaquePtr OpaqueList): Delete definition.
	(TuiPoint, TuiPointPtr): Ditto.
	(TuiStatus, TuiStatusPtr): Ditto.
	(TuiWinType, TuiWinTypePtr): Ditto.
	(struct tui_point): Rename _TuiPoint.
	(tui_get_low_disassembly_address): Rename
	tuiGetLowDisassemblyAddress.
	(tui_update_all_exec_infos): Rename tuiUpdateAllExecInfos.
	(tuiFree): Delete declaration.
	(OpaqueFuncPtr, TuiOpaqueFuncPtr): Delete definitions.
	(TuiVoidFuncPtr, TuiIntFuncPtr): Delete definitions.
	* tui/tui.c (tuiFree): Delete function.
	* cli/cli-cmds.c (disassemble_command): Update references.
	* tui/tui-data.c, tui/tui-data.h, tui/tui-disasm.c: Ditto.
	* tui/tui-layout.c, tui/tui-regs.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-win.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d69 1
a69 1
enum tui_key_mode tui_current_key_mode = tui_command_mode;
d227 1
a227 1
      if (dataWin && dataWin->generic.isVisible)
d229 1
a229 1
      keypad (cmdWin->generic.handle, (winInfo != cmdWin));
d264 1
a264 1
  tui_set_key_mode (tui_one_command_mode);
d276 2
a277 2
  tui_set_key_mode (tui_current_key_mode == tui_command_mode
                    ? tui_single_key_mode : tui_command_mode);
d289 2
a290 2
  if (tui_current_key_mode != tui_command_mode)
    tui_set_key_mode (tui_single_key_mode);
d300 1
a300 1
  rl_set_keymap (mode == tui_single_key_mode
d393 3
a395 3
      tui_set_win_focus_to (srcWin);
      keypad (cmdWin->generic.handle, TRUE);
      wrefresh (cmdWin->generic.handle);
d574 1
a574 1
  if (winList[type] == 0)
d577 1
a577 1
  return winList[type]->generic.isVisible;
d583 1
a583 1
  if (!tui_active || !m_winPtrNotNull (cmdWin))
d588 2
a589 2
  *width = cmdWin->generic.width;
  *height = cmdWin->generic.height;
@


1.41
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

        * tui/tui-data.h (tui_win_element): Rename TuiWinElement.
        (tui_exec_info_content): Rename TuiExecInfoContent.
        (TuiGenWinInfo, TuiGenWinInfoPtr): Delete definitions.
        (TuiWinInfo, TuiWinInfoPtr): Ditto.
        (TuiScrollDirection, TuiScrollDirectionPtr): Ditto.
        (TuiList, TuiListPtr): Ditto.
        (TuiLayoutType, TuiLayoutTypePtr): Ditto.
        (TuiDataType, TuiDataTypePtr): Ditto.
        (TuiRegisterDisplayType, TuiRegisterDisplayTypePtr): Ditto.
        (TuiLineOrAddress, TuiLineOrAddressPtr): Ditto.
        (TuiLayoutDef, TuiLayoutDefPtr): Ditto.
        (TuiSourceElement, TuiSourceElementPtr): Ditto.
        (TuiDataElement, TuiDataElementPtr): Ditto.
        (TuiWinElement, TuiWinElementPtr): Ditto.
        (TuiDataInfo, TuiDataInfoPtr): Ditto.
        (TuiCommandElement, TuiCommandElementPtr): Ditto.
        (TuiLocatorElement, TuiLocatorElementPtr): Ditto.
        (TuiWhichElement, TuiWhichElementPtr): Ditto.
        (TuiSourceInfo, TuiSourceInfoPtr): Ditto.
        (TuiCommandInfo, TuiCommandInfoPtr): Ditto.
        * tui/tui-command.c, tui/tui-data.c: Update references.
        * tui/tui-data.h, tui/tui-disasm.c, tui/tui-layout.c: Ditto.
        * tui/tui-regs.c, tui/tui-source.c, tui/tui-stack.c: Ditto.
        * tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
        * tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@a458 11
/* Wrapper on top of free() to ensure that input address
   is greater than 0x0.  */
void
tuiFree (char *ptr)
{
  if (ptr != (char *) NULL)
    {
      xfree (ptr);
    }
}

d569 1
a569 1
tui_is_window_visible (TuiWinType type)
@


1.40
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-data.h (struct tui_list): Rename _TuiList.
	(enum tui_data_type): Rename _TuiDataType.
	(struct tui_layout_def): Rename _TuiLayoutDef.
	(struct tui_source_element): Rename _TuiSourceElement.
	(struct tui_data_element): Rename _TuiDataElement.
	(struct tui_command_element): Rename _TuiCommandElement.
	(struct tui_locator_element): Rename _TuiLocatorElement.
	(union tui_which_element): Define.
	(struct tui_win_element): Rename _TuiWinElement.
	(struct tui_data_info): Rename _TuiDataInfo.
	(struct tui_source_info): Rename _TuiSourceInfo.
	(struct tui_command_info): Rename _TuiCommandInfo.
	(tui_initialize_static_data): Rename initializeStaticData.
	(tui_alloc_generic_win_info): Rename allocGenericWinInfo.
	(tui_alloc_win_info): Rename allocWinInfo.
	(tui_init_generic_part): Rename initGenericPart.
	(tui_init_win_info): Rename initWinInfo.
	(tui_alloc_content): Rename allocContent.
	(tui_add_content_elements): Rename addContentElements.
	(tui_init_content_element): Rename initContentElement.
	(tui_free_window): Rename freeWindow.
	(tui_free_win_content): Rename freeWinContent.
	(tui_free_data_content): Rename freeDataContent.
	(tui_free_all_source_wins_content): Rename
	freeAllSourceWinsContent.
	(tui_del_window): Rename tuiDelWindow.
	(tui_del_data_windows): Rename tuiDelDataWindows.
	(tui_partial_win_by_name): Rename partialWinByName.
	(tui_win_name): Rename winName.
	(tui_current_layout): Rename currentLayout.
	(tui_set_current_layout_to): Rename setCurrentLayoutTo.
	(tui_term_height): Rename termHeight.
	(tui_set_term_height_to): Rename setTermHeightTo.
	(tui_term_width): Rename termWidth.
	(tui_set_term_width_to): Rename setTermWidthTo.
	(tui_set_gen_win_origin): Rename setGenWinOrigin.
	(tui_locator_win_info_ptr): Rename locatorWinInfoPtr.
	(tui_source_exec_info_win_ptr): Rename tui_gen_win_info.
	(tui_disassem_exec_info_win_ptr): Rename disassemExecInfoWinPtr.
	(tui_source_windows): Rename sourceWindows.
	(tui_clear_source_windows): Rename clearSourceWindows.
	(tui_clear_source_windows_detail): Rename
	clearSourceWindowsDetail.
	(tui_clear_win_detail): Rename clearWinDetail.
	(tui_add_to_source_windows): Rename tuiAddToSourceWindows.
	(tui_default_tab_len): Rename tuiDefaultTabLen.
	(tui_set_default_tab_len): Rename tuiSetDefaultTabLen.
	(tui_win_with_focus): Rename tuiWinWithFocus.
	(tui_set_win_with_focus): Rename tuiSetWinWithFocus.
	(tui_layout_def): Rename tuiLayoutDef.
	(tui_win_resized): Rename tuiWinResized.
	(tui_set_win_resized_to): Rename tuiSetWinResizedTo.
	(tui_next_win): Rename tuiNextWin.
	(tui_prev_win): Rename tuiPrevWin.
	(tui_add_to_source_windows): Rename addToSourceWindows.
	* tui/tui-winsource.c, tui/tui-win.c: Update references.
	* tui/tui-layout.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-io.c: Ditto.
	* tui/tui.c, tui/tui-data.c: Ditto.
	* tui/tui-interp.c, tui/tui-data.c: Ditto.
	* tui/tui-disasm.c, tui/tui-command.c: Ditto.
@
text
@d140 2
a141 2
      TuiLayoutType new_layout;
      TuiRegisterDisplayType regs_type = TUI_UNDEFINED_REGS;
d188 2
a189 2
      TuiLayoutType new_layout;
      TuiRegisterDisplayType regs_type = TUI_UNDEFINED_REGS;
d218 1
a218 1
  TuiWinInfoPtr winInfo;
@


1.39
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-win.h: Update copyright.  Include "tui-data.h".
	(struct tui_win_info): Declare.
	(tui_scroll_forward): Rename tuiScrollForward.
	(tui_scroll_backward): Rename tuiScrollBackward.
	(tui_scroll_left): Rename tuiScrollLeft.
	(tui_scroll_right): Rename tuiScrollRight.
	(tui_set_win_focus_to): Rename tuiSetWinFocusTo.
	(tui_resize_all): Rename tuiResizeAll.
	(tui_refresh_all_win): Rename tuiRefreshAll.
	(tui_sigwinch_handler): Rename tuiSigwinchHandler.
	* tui/tui-layout.c, * tui/tui-io.c: Update references.
	* tui/tui-wingeneral.h, * tui/tui.c: Update references.
	* tui/tui-disasm.c, * tui/tui-command.c: Update references.
@
text
@d143 1
a143 1
      new_layout = currentLayout ();
d191 1
a191 1
      new_layout = currentLayout ();
d223 1
a223 1
  winInfo = tuiNextWin (tuiWinWithFocus ());
d387 2
a388 2
      setTermHeightTo (LINES);
      setTermWidthTo (COLS);
@


1.38
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-windata.h: Update copyright.  Include "tui-data.h".
	(tui_erase_data_content): Rename tuiEraseDataContent.
	(tui_display_all_data): Rename tuiDisplayAllData.
	(tui_check_data_values): Rename tuiCheckDataValues.
	(tui_display_data_from_line): Rename tuiDisplayDataFromLine.
	(tui_first_data_item_displayed): Rename tuiFirstDataItemDisplayed.
	(tui_first_data_element_no_in_line): Rename
	tuiFirstDataElementNoInLine.
	(tui_delete_data_content_windows): Rename
	tuiDeleteDataContentWindows.
	(tui_refresh_data_win): Rename tuiRefreshDataWin.
	(tui_display_data_from): Rename tuiDisplayDataFrom.
	(tui_vertical_data_scroll): Rename tuiVerticalDataScroll.
	* tui/tui-windata.c, tui/tui-hooks.c: Update references.
	* tui/tui-win.c, tui/tui-regs.c: Update references.
	* tui/tui-layout.c, tui/tui.c: Update references.
@
text
@d226 1
a226 1
      tuiSetWinFocusTo (winInfo);
d393 1
a393 1
      tuiSetWinFocusTo (srcWin);
d420 1
a420 1
  tuiRefreshAll ();
@


1.37
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-source.h: Do not include "defs.h".
	(struct tui_win_info): Declare.
	(tui_set_source_content_nil): Declare.
	* tui/tui-data.h (struct tui_win_info): Rename _TuiWinInfo.
	(union tui_line_or_address): Rename _TuiLineOrAddress.
	* tui/tui-winsource.h: Update copyright.  Include "tui-data.h".
	(tui_update_source_window): Rename tuiUpdateSourceWindow.
	(tui_update_source_window_as_is): Rename
	tuiUpdateSourceWindowAsIs.
	(tui_update_source_windows_with_addr): Rename
	tuiUpdateSourceWindowsWithAddr.
	(tui_update_source_windows_with_line): Rename
	tuiUpdateSourceWindowsWithLine.
	(tui_clear_source_content): Rename tuiClearSourceContent.
	(tui_erase_source_content): Rename tuiEraseSourceContent.
	(tui_set_source_content_nil): Rename tuiSetSourceContentNil.
	(tui_show_source_content): Rename tuiShowSourceContent.
	(tui_horizontal_source_scroll): Rename tuiHorizontalSourceScroll.
	(tui_set_exec_info_content): Rename tuiSetExecInfoContent.
	(tui_show_exec_info_content): Rename tuiShowExecInfoContent.
	(tui_erase_exec_info_content): Rename tuiEraseExecInfoContent.
	(tui_clear_exec_info_content): Rename tuiClearExecInfoContent.
	(tui_update_exec_info): Rename tuiUpdateExecInfo.
	(tui_set_is_exec_point_at): Rename tuiSetIsExecPointAt.
	(tui_alloc_source_buffer): Rename tuiAllocSourceBuffer.
	(tui_line_is_displayed): Rename tuiLineIsDisplayed.
	(tui_addr_is_displayed): Rename tuiAddrIsDisplayed.
	(struct tui_win_info): Declare.
	* tui/tui-stack.c: Update references.
	* tui/tui-layout.c, tui/tui-winsource.c: Ditto.
	* tui/tui-win.c, tui/tui-source.c: Ditto.
	* tui/tui.c, tui/tui-disasm.c: Ditto.
@
text
@d228 1
a228 1
        tuiRefreshDataWin ();
@


1.36
log
@2004-01-28  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-stack.h: Update copyright.
	(struct frame_info): Add opaque declaration.
	(tui_update_locator_filename): Rename tuiUpdateLocatorFilename.
	(tui_show_locator_content): Rename tuiShowLocatorContent.
	(tui_show_frame_info): Rename tuiShowFrameInfo.
	* tui/tui-stack.c: Update copyright.  Update references.
	* tui/tui-winsource.c: Update references.
	* tui/tui-win.c: Update references.
	* tui/tui-layout.c: Update references.
	* tui/tui-hooks.c: Update copyright, update references.
	* tui/tui.c: Update copyright, update references.
	* tui/tui-disasm.c: Update references.
@
text
@d568 1
a568 1
  tuiUpdateSourceWindowsWithLine (cursal.symtab, line);
d576 1
a576 1
  tuiUpdateSourceWindowsWithAddr (addr);
@


1.35
log
@2004-01-23  Andrew Cagney  <cagney@@redhat.com>

	* printcmd.c (display_command): Replace tui_set_display call with
	tui_set_layout_for_display_command.
	* tui/tui.h (enum tui_win_type): Define.
	(tui_set_layout): Delete declaration.
	(tui_set_layout_for_display_command): Rename set_tui_layout.
	* tui/tui-data.h (enum tui_layout_type): Define.
	* tui/tui-layout.h: Update copyright.  Include "tui-data.h" and
	"tui.h".
	(tui_add_win_to_layout): Rename tuiAddWinToLayout.
	(tui_default_win_height): Rename tuiDefaultWinHeight.
	(tui_default_win_viewport_height): Rename
	tuiDefaultWinViewportHeight.
	(tui_set_layout): RenametuiSetLayout.
	* tui/tui-layout.c: Update references.
	* tui/tui.c: Update references.
	* tui/tui-disasm.c: Update references.
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.
d302 1
a302 1
  tuiShowLocatorContent ();
d391 1
a391 1
      tuiShowFrameInfo (0);
d416 1
a416 1
     tuiShowFrameInfo (deprecated_selected_frame);
d569 1
a569 1
  tuiUpdateLocatorFilename (file);
@


1.34
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@d173 1
a173 1
      tuiSetLayout (new_layout, regs_type);
d208 1
a208 1
      tuiSetLayout (new_layout, regs_type);
d392 1
a392 1
      tuiSetLayout (SRC_COMMAND, TUI_UNDEFINED_REGS);
d566 1
a566 1
  tuiAddWinToLayout (SRC_WIN);
d575 1
a575 1
  tuiAddWinToLayout (DISASSEM_WIN);
@


1.33
log
@	* tui.c (tui_rl_other_window): New function to switch the TUI active
	window and give focus to a next window.
	(tui_initialize_readline): Bind it to c-x o.
	(tui_rl_next_keymap): Activate TUI mode when entering SingleKey mode.
@
text
@d40 9
a48 9
#include "tui.h"
#include "tuiData.h"
#include "tuiLayout.h"
#include "tuiIO.h"
#include "tuiRegs.h"
#include "tuiStack.h"
#include "tuiWin.h"
#include "tuiSourceWin.h"
#include "tuiDataWin.h"
@


1.33.4.1
log
@merge mainline changes to branch
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
a24 19
#include "defs.h"
#include "gdbcmd.h"
#include "tui/tui.h"
#include "tui/tui-hooks.h"
#include "tui/tui-data.h"
#include "tui/tui-layout.h"
#include "tui/tui-io.h"
#include "tui/tui-regs.h"
#include "tui/tui-stack.h"
#include "tui/tui-win.h"
#include "tui/tui-winsource.h"
#include "tui/tui-windata.h"
#include "target.h"
#include "frame.h"
#include "breakpoint.h"
#include "inferior.h"
#include "symtab.h"
#include "source.h"

d28 1
d38 18
d57 7
a63 6
#include "gdb_curses.h"

/* This redefines CTRL if it is not already defined, so it must come
   after terminal state releated include files like <term.h> and
   "gdb_ncurses.h".  */
#include "readline/readline.h"
d69 1
a69 1
enum tui_key_mode tui_current_key_mode = TUI_COMMAND_MODE;
d140 2
a141 2
      enum tui_layout_type new_layout;
      enum tui_register_display_type regs_type = TUI_UNDEFINED_REGS;
d143 1
a143 1
      new_layout = tui_current_layout ();
d173 1
a173 1
      tui_set_layout (new_layout, regs_type);
d188 2
a189 2
      enum tui_layout_type new_layout;
      enum tui_register_display_type regs_type = TUI_UNDEFINED_REGS;
d191 1
a191 1
      new_layout = tui_current_layout ();
d208 1
a208 1
      tui_set_layout (new_layout, regs_type);
d218 1
a218 1
  struct tui_win_info * win_info;
d223 2
a224 2
  win_info = tui_next_win (tui_win_with_focus ());
  if (win_info)
d226 4
a229 4
      tui_set_win_focus_to (win_info);
      if (TUI_DATA_WIN && TUI_DATA_WIN->generic.is_visible)
        tui_refresh_data_win ();
      keypad (TUI_CMD_WIN->generic.handle, (win_info != TUI_CMD_WIN));
d264 1
a264 1
  tui_set_key_mode (TUI_ONE_COMMAND_MODE);
d276 2
a277 2
  tui_set_key_mode (tui_current_key_mode == TUI_COMMAND_MODE
                    ? TUI_SINGLE_KEY_MODE : TUI_COMMAND_MODE);
d286 1
a286 1
tui_rl_startup_hook (void)
d289 2
a290 2
  if (tui_current_key_mode != TUI_COMMAND_MODE)
    tui_set_key_mode (TUI_SINGLE_KEY_MODE);
d300 1
a300 1
  rl_set_keymap (mode == TUI_SINGLE_KEY_MODE
d302 1
a302 1
  tui_show_locator_content ();
d308 1
a308 1
tui_initialize_readline (void)
d387 2
a388 2
      tui_set_term_height_to (LINES);
      tui_set_term_width_to (COLS);
d391 5
a395 5
      tui_show_frame_info (0);
      tui_set_layout (SRC_COMMAND, TUI_UNDEFINED_REGS);
      tui_set_win_focus_to (TUI_SRC_WIN);
      keypad (TUI_CMD_WIN->generic.handle, TRUE);
      wrefresh (TUI_CMD_WIN->generic.handle);
d416 1
a416 1
     tui_show_frame_info (deprecated_selected_frame);
d420 1
a420 1
  tui_refresh_all_win ();
d459 2
d462 1
a462 1
strcat_to_buf (char *buf, int buflen, const char *item_to_add)
d464 1
a464 1
  if (item_to_add != (char *) NULL && buf != (char *) NULL)
d466 11
a476 2
      if ((strlen (buf) + strlen (item_to_add)) <= buflen)
	strcat (buf, item_to_add);
d478 1
a478 1
	strncat (buf, item_to_add, (buflen - strlen (buf)));
d492 1
a492 1
tui_reset (void)
d558 1
a558 1
}
d566 1
a566 1
  tui_add_win_to_layout (SRC_WIN);
d568 2
a569 2
  tui_update_source_windows_with_line (cursal.symtab, line);
  tui_update_locator_filename (file);
d575 2
a576 2
  tui_add_win_to_layout (DISASSEM_WIN);
  tui_update_source_windows_with_addr (addr);
d580 1
a580 1
tui_is_window_visible (enum tui_win_type type)
d585 1
a585 1
  if (tui_win_list[type] == 0)
d588 1
a588 1
  return tui_win_list[type]->generic.is_visible;
d594 1
a594 1
  if (!tui_active || (TUI_CMD_WIN == NULL))
d599 2
a600 2
  *width = TUI_CMD_WIN->generic.width;
  *height = TUI_CMD_WIN->generic.height;
@


1.32
log
@	* tui.c (tui_enable): Call tuiRefreshAll to make sure the window
	is accurate.
@
text
@d48 1
d214 21
d273 3
d354 2
@


1.31
log
@	* tui-hooks.c: Update include order.
	* tui.c: Likewise.
	* tuiCommand.c: Likewise.
	* tuiData.c: Likewise.
	* tuiDataWin.c: Likewise.
	* tuiDisassem.c: Likewise.
	* tuiGeneralWin.c: Likewise.
	* tuiIO.c: Likewise.
	* tuiLayout.c: Likewise.
	* tuiRegs.c: Likewise.
	* tuiSource.c: Likewise.
	* tuiSourceWin.c: Likewise.
	* tuiStack.c: Likewise.
	* tuiWin.c: Likewise.
@
text
@d393 1
a393 1
  refresh ();
@


1.31.2.1
log
@	* tui.c (tui_enable): Call tuiRefreshAll to make sure the window
	is accurate.
@
text
@d393 1
a393 1
  tuiRefreshAll ();
@


1.31.2.2
log
@	* tui.c (tui_rl_other_window): New function to switch the TUI active
	window and give focus to a next window.
	(tui_initialize_readline): Bind it to c-x o.
	(tui_rl_next_keymap): Activate TUI mode when entering SingleKey mode.
@
text
@a47 1
#include "tuiDataWin.h"
a212 21
   Switch the active window to give the focus to a next window.  */
static int
tui_rl_other_window (int count, int key)
{
  TuiWinInfoPtr winInfo;

  if (!tui_active)
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);

  winInfo = tuiNextWin (tuiWinWithFocus ());
  if (winInfo)
    {
      tuiSetWinFocusTo (winInfo);
      if (dataWin && dataWin->generic.isVisible)
        tuiRefreshDataWin ();
      keypad (cmdWin->generic.handle, (winInfo != cmdWin));
    }
  return 0;
}

/* TUI readline command.
a250 3
  if (!tui_active)
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);

a328 2
  rl_bind_key_in_map ('o', tui_rl_other_window, emacs_ctlx_keymap);
  rl_bind_key_in_map ('o', tui_rl_other_window, tui_ctlx_keymap);
@


1.30
log
@2003-02-14  Andrew Cagney  <ac131313@@redhat.com>

	* main.c (tui_version): Delete variable.
	(captured_main): When --tui, set interpreter_p to "tui" instead of
	enabling tui_version.
	* printcmd.c (display_command) [TUI]: Test tui_active instead of
	tui_version.
	* cli/cli-decode.c (lookup_cmd_composition): Ditto.
	* cli/cli-cmds.c (disassemble_command): Ditto.
	* defs.h (tui_version): Delete declaration.
	* Makefile.in (SUBDIR_TUI_SRCS): Add "tui/tui-interp.c".
	(tui-interp.o): Add rules.
	(SUBDIR_TUI_OBS): Add "tui-interp.o".

Index: tui/ChangeLog
2003-02-14  Andrew Cagney  <ac131313@@redhat.com>

	* tui.c (tui_enable, tui_disable): Don't modify tui_version.
	(tui_is_window_visible, tui_get_command_dimension): Test
	tui_active instead of tui_version.
	* tuiData.h (tui_version): Delete declaration.
	* tui-hooks.c (tui_init_hook, tui_event_loop): Delete function,
	moved to "tui-interp.c".
	(tui_exit, tui_command_loop): Ditto.
	(_initialize_tui): Don't initialize init_ui_hook.  Initialize
	target_new_objfile_hook.
	* tui-interp.c: New file.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation,
a24 17
/* FIXME: cagney/2002-02-28: The GDB coding standard indicates that
   "defs.h" should be included first.  Unfortunatly some systems
   (currently Debian GNU/Linux) include the <stdbool.h> via <curses.h>
   and they clash with "bfd.h"'s definiton of true/false.  The correct
   fix is to remove true/false from "bfd.h", however, until that
   happens, hack around it by including "config.h" and <curses.h>
   first.  */

#include "config.h"
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

d55 8
@


1.29
log
@2003-02-12  Andrew Cagney  <ac131313@@redhat.com>

	* tuiIO.c (tui_prep_terminal): Add one notused parameter.
	* tui.c (tui_rl_switch_mode): Add two notused parameters.
	(tui_rl_change_windows, tui_rl_next_keymap): Ditto.
	(tui_rl_delete_other_windows): Ditto.
	(tui_rl_change_windows, tui_rl_delete_other_windows): Update
	calls.
@
text
@a395 1
  tui_version = 1;
a436 1
  tui_version = 0;
d564 1
a564 1
  if (tui_version == 0)
d576 1
a576 1
  if (!tui_version || !m_winPtrNotNull (cmdWin))
@


1.28
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d105 1
a105 1
tui_rl_switch_mode (void)
d141 1
a141 1
tui_rl_change_windows (void)
d144 1
a144 1
    tui_rl_switch_mode ();
d189 1
a189 1
tui_rl_delete_other_windows (void)
d192 1
a192 1
    tui_rl_switch_mode ();
d258 1
a258 1
tui_rl_next_keymap (void)
@


1.27
log
@2002-09-29  Elena Zannoni  <ezannoni@@redhat.com>

	* tui.c (tui_show_source): Don't access current_source_symtab, use
	accessor function instead.  Include source.h and symtab.h
	* tuiDisassem.c (tuiShowDisassemAndUpdateSource,
	tuiVerticalDisassemScroll): Use accessor functions for current
	source line and symtab.  Include source.h.
	* tuiLayout.c (_extractDisplayStartAddr): Use accessor functions
	for current source line and symtab.  Include source.h.
	* tuiWin.c (_makeVisibleWithNewHeight): Ditto.
	* tuiSourceWin.c (tuiUpdateSourceWindowAsIs,
	tuiHorizontalSourceScroll): Ditto.
	* tuiSource.c (tuiVerticalSourceScroll): Ditto.
@
text
@d398 2
a399 2
  if (selected_frame)
     tuiShowFrameInfo (selected_frame);
@


1.27.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a64 1
#include "tuiDataWin.h"
a72 8
#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif

d105 1
a105 1
tui_rl_switch_mode (int notused1, int notused2)
d141 1
a141 1
tui_rl_change_windows (int notused1, int notused2)
d144 1
a144 1
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);
d189 1
a189 1
tui_rl_delete_other_windows (int notused1, int notused2)
d192 1
a192 1
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);
a221 21
   Switch the active window to give the focus to a next window.  */
static int
tui_rl_other_window (int count, int key)
{
  TuiWinInfoPtr winInfo;

  if (!tui_active)
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);

  winInfo = tuiNextWin (tuiWinWithFocus ());
  if (winInfo)
    {
      tuiSetWinFocusTo (winInfo);
      if (dataWin && dataWin->generic.isVisible)
        tuiRefreshDataWin ();
      keypad (cmdWin->generic.handle, (winInfo != cmdWin));
    }
  return 0;
}

/* TUI readline command.
d258 1
a258 1
tui_rl_next_keymap (int notused1, int notused2)
a259 3
  if (!tui_active)
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);

a337 2
  rl_bind_key_in_map ('o', tui_rl_other_window, emacs_ctlx_keymap);
  rl_bind_key_in_map ('o', tui_rl_other_window, tui_ctlx_keymap);
d396 1
d398 2
a399 2
  if (deprecated_selected_frame)
     tuiShowFrameInfo (deprecated_selected_frame);
d403 1
a403 1
  tuiRefreshAll ();
d438 1
d566 1
a566 1
  if (tui_active == 0)
d578 1
a578 1
  if (!tui_active || !m_winPtrNotNull (cmdWin))
@


1.27.2.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d40 9
a48 9
#include "tui/tui.h"
#include "tui/tui-data.h"
#include "tui/tui-layout.h"
#include "tui/tui-io.h"
#include "tui/tui-regs.h"
#include "tui/tui-stack.h"
#include "tui/tui-win.h"
#include "tui/tui-winsource.h"
#include "tui/tui-windata.h"
d69 1
a69 1
enum tui_key_mode tui_current_key_mode = TUI_COMMAND_MODE;
d140 2
a141 2
      enum tui_layout_type new_layout;
      enum tui_register_display_type regs_type = TUI_UNDEFINED_REGS;
d143 1
a143 1
      new_layout = tui_current_layout ();
d173 1
a173 1
      tui_set_layout (new_layout, regs_type);
d188 2
a189 2
      enum tui_layout_type new_layout;
      enum tui_register_display_type regs_type = TUI_UNDEFINED_REGS;
d191 1
a191 1
      new_layout = tui_current_layout ();
d208 1
a208 1
      tui_set_layout (new_layout, regs_type);
d218 1
a218 1
  struct tui_win_info * winInfo;
d223 1
a223 1
  winInfo = tui_next_win (tui_win_with_focus ());
d226 4
a229 4
      tui_set_win_focus_to (winInfo);
      if (TUI_DATA_WIN && TUI_DATA_WIN->generic.is_visible)
        tui_refresh_data_win ();
      keypad (TUI_CMD_WIN->generic.handle, (winInfo != TUI_CMD_WIN));
d264 1
a264 1
  tui_set_key_mode (TUI_ONE_COMMAND_MODE);
d276 2
a277 2
  tui_set_key_mode (tui_current_key_mode == TUI_COMMAND_MODE
                    ? TUI_SINGLE_KEY_MODE : TUI_COMMAND_MODE);
d289 2
a290 2
  if (tui_current_key_mode != TUI_COMMAND_MODE)
    tui_set_key_mode (TUI_SINGLE_KEY_MODE);
d300 1
a300 1
  rl_set_keymap (mode == TUI_SINGLE_KEY_MODE
d302 1
a302 1
  tui_show_locator_content ();
d387 2
a388 2
      tui_set_term_height_to (LINES);
      tui_set_term_width_to (COLS);
d391 5
a395 5
      tui_show_frame_info (0);
      tui_set_layout (SRC_COMMAND, TUI_UNDEFINED_REGS);
      tui_set_win_focus_to (TUI_SRC_WIN);
      keypad (TUI_CMD_WIN->generic.handle, TRUE);
      wrefresh (TUI_CMD_WIN->generic.handle);
d416 1
a416 1
     tui_show_frame_info (deprecated_selected_frame);
d420 1
a420 1
  tui_refresh_all_win ();
d459 11
d566 1
a566 1
  tui_add_win_to_layout (SRC_WIN);
d568 2
a569 2
  tui_update_source_windows_with_line (cursal.symtab, line);
  tui_update_locator_filename (file);
d575 2
a576 2
  tui_add_win_to_layout (DISASSEM_WIN);
  tui_update_source_windows_with_addr (addr);
d580 1
a580 1
tui_is_window_visible (enum tui_win_type type)
d585 1
a585 1
  if (tui_win_list[type] == 0)
d588 1
a588 1
  return tui_win_list[type]->generic.is_visible;
d594 1
a594 1
  if (!tui_active || (TUI_CMD_WIN == NULL))
d599 2
a600 2
  *width = TUI_CMD_WIN->generic.width;
  *height = TUI_CMD_WIN->generic.height;
@


1.26
log
@	* tui.c (tui_rl_switch_mode): Remove unecessary TUI switch printfs.
	(tui_initialize_readline): Allow to use space to leave SingleKey
	to enter one gdb command.
	(tui_enable): Restore the TUI keymap when we are back to TUI.
	(tui_disable): Restore normal keymap when leaving TUI.
	* tuiIO.c (tui_redisplay_readline): Restore the SingleKey mode
	when the buffer becomes empty and we are in tui_one_command_mode.
@
text
@d70 2
d548 1
d552 1
a552 1
  tuiUpdateSourceWindowsWithLine (current_source_symtab, line);
@


1.26.2.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a69 2
#include "symtab.h"
#include "source.h"
a545 1
  struct symtab_and_line cursal = get_current_source_symtab_and_line ();
d549 1
a549 1
  tuiUpdateSourceWindowsWithLine (cursal.symtab, line);
@


1.26.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d398 2
a399 2
  if (deprecated_selected_frame)
     tuiShowFrameInfo (deprecated_selected_frame);
@


1.26.2.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d105 1
a105 1
tui_rl_switch_mode (int notused1, int notused2)
d141 1
a141 1
tui_rl_change_windows (int notused1, int notused2)
d144 1
a144 1
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);
d189 1
a189 1
tui_rl_delete_other_windows (int notused1, int notused2)
d192 1
a192 1
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);
d258 1
a258 1
tui_rl_next_keymap (int notused1, int notused2)
d396 1
d438 1
d566 1
a566 1
  if (tui_active == 0)
d578 1
a578 1
  if (!tui_active || !m_winPtrNotNull (cmdWin))
@


1.26.2.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
d25 17
a71 8

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
@


1.26.2.5
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a47 1
#include "tuiDataWin.h"
a212 21
   Switch the active window to give the focus to a next window.  */
static int
tui_rl_other_window (int count, int key)
{
  TuiWinInfoPtr winInfo;

  if (!tui_active)
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);

  winInfo = tuiNextWin (tuiWinWithFocus ());
  if (winInfo)
    {
      tuiSetWinFocusTo (winInfo);
      if (dataWin && dataWin->generic.isVisible)
        tuiRefreshDataWin ();
      keypad (cmdWin->generic.handle, (winInfo != cmdWin));
    }
  return 0;
}

/* TUI readline command.
a250 3
  if (!tui_active)
    tui_rl_switch_mode (0/*notused*/, 0/*notused*/);

a328 2
  rl_bind_key_in_map ('o', tui_rl_other_window, emacs_ctlx_keymap);
  rl_bind_key_in_map ('o', tui_rl_other_window, tui_ctlx_keymap);
d393 1
a393 1
  tuiRefreshAll ();
@


1.26.2.6
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d40 9
a48 9
#include "tui/tui.h"
#include "tui/tui-data.h"
#include "tui/tui-layout.h"
#include "tui/tui-io.h"
#include "tui/tui-regs.h"
#include "tui/tui-stack.h"
#include "tui/tui-win.h"
#include "tui/tui-winsource.h"
#include "tui/tui-windata.h"
d173 1
a173 1
      tui_set_layout (new_layout, regs_type);
d208 1
a208 1
      tui_set_layout (new_layout, regs_type);
d392 1
a392 1
      tui_set_layout (SRC_COMMAND, TUI_UNDEFINED_REGS);
d566 1
a566 1
  tui_add_win_to_layout (SRC_WIN);
d575 1
a575 1
  tui_add_win_to_layout (DISASSEM_WIN);
@


1.25
log
@	* tuiIO.c (tui_putc): New function to print one character.
	(printable_part): New function from readline/complete.c.
	(PUTX): New macro, likewise.
	(print_filename): New function, likewise.
	(get_y_or_n): New function, likewise and adapted for TUI.
	(tui_rl_display_match_list): New function from readline/complete.c
	and writes on TUI command window.
	(tui_setup_io): Install or remove the readline hook
	rl_completion_display_matches_hook so that completion is written
	directly in TUI command window instead of in the TUI pipe.
	(tui_initialize_io): Use #ifdef TUI_USE_PIPE_FOR_READLINE for the
	TUI redirection pipe.
	(tui_getc): Likewise for call to tui_readline_output.
	(tui_readline_output): Likewise for function.
	* tui.c (tui_rl_startup_hook): Always take care of gdb prompt.
@
text
@a108 2

      printf_filtered ("Left the TUI mode\n");
a113 1
      printf_filtered ("Entered the TUI mode\n");
d312 1
a312 1
  for (i = ' ' + 1; i < 0x7f; i++)
d399 2
d417 3
@


1.25.2.1
log
@	* tui.c (tui_rl_switch_mode): Remove unecessary TUI switch printfs.
	(tui_initialize_readline): Allow to use space to leave SingleKey
	to enter one gdb command.
	(tui_enable): Restore the TUI keymap when we are back to TUI.
	(tui_disable): Restore normal keymap when leaving TUI.
	* tuiIO.c (tui_redisplay_readline): Restore the SingleKey mode
	when the buffer becomes empty and we are in tui_one_command_mode.
@
text
@d109 2
d116 1
d315 1
a315 1
  for (i = ' '; i < 0x7f; i++)
a401 2
  /* Restore TUI keymap.  */
  tui_set_key_mode (tui_current_key_mode);
a417 3

  /* Restore initial readline keymap.  */
  rl_set_keymap (tui_readline_standard_keymap);
@


1.24
log
@2002-08-31  Stephane Carrez  <stcarrez@@nerim.fr>

	* tui.c (tui_commands): Table of single key commands.
	(tui_rl_command_key): New function to execute gdb command.
	(tui_rl_command_mode): New function to temporarily leave SingleKey.
	(tui_rl_next_keymap): New function to enter/leave the SingleKey mode.
	(tui_rl_startup_hook): New function to avoid prompt display by
	readline functions.
	(tui_set_key_mode): New function to set the key mode and install
	the readline keymap.
	(tui_initialize_readline): Create TUI SingleKey readline map.
	(tui_enable): Install rl_startup_hook.
	(tui_disable): Remove it.
	* tui.h (enum tui_key_mode): Declare.
	(tui_set_key_mode, tui_current_key_mode): Declare.
	* tuiIO.c (tui_redisplay_readline): Don't display the prompt in
	SingleKey mode.
	* tuiIO.h (tui_redisplay_readline): Declare.
@
text
@d273 4
a276 6
  rl_already_prompted = (tui_current_key_mode != tui_command_mode);
  if (rl_already_prompted)
    {
      tui_set_key_mode (tui_single_key_mode);
      tui_redisplay_readline ();
    }
@


1.23
log
@	* tui.c (tuiGetLowDisassemblyAddress): Moved from here.
	* tuiDisassem.c (tuiGetLowDisassemblyAddress): To here, and use
	tui_find_disassembly_address to find the starting address of
	disassemble window.
@
text
@d75 27
a101 1
/* Switch the output mode between TUI/standard gdb.  */
d222 70
d297 3
d303 28
d332 1
d334 1
d336 1
d338 1
d340 4
d393 1
d423 2
@


1.22
log
@	Fix PR gdb/393:
	* tui.c (tui_disable): Update gdb's knowledge of its terminal
	using target_terminal_save_ours.
	(tui_enable): Likewise.
@
text
@a313 25
/* Determine what the low address will be to display in the TUI's
   disassembly window.  This may or may not be the same as the
   low address input.  */
CORE_ADDR
tuiGetLowDisassemblyAddress (CORE_ADDR low, CORE_ADDR pc)
{
  int line;
  CORE_ADDR newLow;

  /* Determine where to start the disassembly so that the pc is about in the
     middle of the viewport.  */
  for (line = 0, newLow = pc;
       (newLow > low &&
	line < (tuiDefaultWinViewportHeight (DISASSEM_WIN,
					     DISASSEM_COMMAND) / 2));)
    {
      bfd_byte buffer[4];

      newLow -= sizeof (bfd_getb32 (buffer));
      line++;
    }

  return newLow;
}

@


1.21
log
@	* tui.c (tui_rl_switch_mode): Renames tui_switch_mode.
	(tui_rl_change_windows): Renames tui_change_windows.
	(tui_rl_delete_other_windows): Renames tui_delete_other_windows.
	(tui_initialize_readline): Update.
@
text
@d269 3
d294 3
@


1.20
log
@	* tui.c (strcat_to_buf): Use const char* for source item.
	(tui_enable): Update the windows if there is a selected frame.
	* tui.h (strcat_to_buf): Update prototype.
	(strcat_to_buf_with_fmt): Remove.
@
text
@d77 1
a77 1
tui_switch_mode (void)
d110 2
a111 1
/* Change the TUI layout to show a next layout.
d116 1
a116 1
tui_change_windows (void)
d119 1
a119 1
    tui_switch_mode ();
d161 2
a162 2

/* Delete the second TUI window to only show one.  */
d164 1
a164 1
tui_delete_other_windows (void)
d167 1
a167 1
    tui_switch_mode ();
d203 6
a208 6
  rl_add_defun ("tui-switch-mode", tui_switch_mode, -1);
  rl_bind_key_in_map ('a', tui_switch_mode, emacs_ctlx_keymap);
  rl_bind_key_in_map ('A', tui_switch_mode, emacs_ctlx_keymap);
  rl_bind_key_in_map (CTRL ('A'), tui_switch_mode, emacs_ctlx_keymap);
  rl_bind_key_in_map ('1', tui_delete_other_windows, emacs_ctlx_keymap);
  rl_bind_key_in_map ('2', tui_change_windows, emacs_ctlx_keymap);
@


1.19
log
@	* tuiWin.c (tui_update_gdb_sizes): New function to tell gdb what
	is the size of command window.
	(tuiResizeAll): Call it instead of init_page_info.
	* tui.c (tui_enable): Call it to resize to TUI command window.
	(tui_disable): Likewise for plain screen.
@
text
@d264 3
d333 1
a333 1
strcat_to_buf (char *buf, int buflen, char *itemToAdd)
@


1.18
log
@	* tui.c (tui_enable): Use tuiSetLayout instead of showLayout and
	use tuiShowFrameInfo instead of tuiSetLocatorContent.
	* tuiLayout.h (showLayout): Remove.
	* tuiLayout.c (_showSourceOrDisassemAndCommand): Remove unused locals.
	(_showSourceDisassemCommand): Likewise.
	(showLayout): Make it static.
	(lastLayout): Remove.
@
text
@d265 1
d290 1
@


1.17
log
@        Fix PR gdb/655
        * tui.c: Disable <termio.h> include.
@
text
@d240 2
a241 2
      tuiSetLocatorContent (0);
      showLayout (SRC_COMMAND);
@


1.16
log
@Add FIXME explaining include problem.
@
text
@d51 1
d53 1
@


1.16.8.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a50 1
#if 0
a51 1
#endif
d75 1
a75 1
tui_rl_switch_mode (void)
d108 1
a108 2
/* TUI readline command.
   Change the TUI layout to show a next layout.
d113 1
a113 1
tui_rl_change_windows (void)
d116 1
a116 1
    tui_rl_switch_mode ();
d158 2
a159 2
/* TUI readline command.
   Delete the second TUI window to only show one.  */
d161 1
a161 1
tui_rl_delete_other_windows (void)
d164 1
a164 1
    tui_rl_switch_mode ();
d200 6
a205 6
  rl_add_defun ("tui-switch-mode", tui_rl_switch_mode, -1);
  rl_bind_key_in_map ('a', tui_rl_switch_mode, emacs_ctlx_keymap);
  rl_bind_key_in_map ('A', tui_rl_switch_mode, emacs_ctlx_keymap);
  rl_bind_key_in_map (CTRL ('A'), tui_rl_switch_mode, emacs_ctlx_keymap);
  rl_bind_key_in_map ('1', tui_rl_delete_other_windows, emacs_ctlx_keymap);
  rl_bind_key_in_map ('2', tui_rl_change_windows, emacs_ctlx_keymap);
d238 2
a239 2
      tuiShowFrameInfo (0);
      tuiSetLayout (SRC_COMMAND, TUI_UNDEFINED_REGS);
a261 3
  if (selected_frame)
     tuiShowFrameInfo (selected_frame);

a262 4

  /* Update gdb's knowledge of its terminal.  */
  target_terminal_save_ours ();
  tui_update_gdb_sizes ();
a284 3
  /* Update gdb's knowledge of its terminal.  */
  target_terminal_save_ours ();

a286 1
  tui_update_gdb_sizes ();
d300 25
d326 1
a326 1
strcat_to_buf (char *buf, int buflen, const char *itemToAdd)
@


1.16.8.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a69 2
#include "symtab.h"
#include "source.h"
d75 1
a75 27
enum tui_key_mode tui_current_key_mode = tui_command_mode;

struct tui_char_command
{
  unsigned char key;
  const char* cmd;
};

/* Key mapping to gdb commands when the TUI is using the single key mode.  */
static const struct tui_char_command tui_commands[] = {
  { 'c', "continue" },
  { 'd', "down" },
  { 'f', "finish" },
  { 'n', "next" },
  { 'r', "run" },
  { 's', "step" },
  { 'u', "up" },
  { 'v', "info locals" },
  { 'w', "where" },
  { 0, 0 },
};

static Keymap tui_keymap;
static Keymap tui_readline_standard_keymap;

/* TUI readline command.
   Switch the output mode between TUI/standard gdb.  */
d83 2
d90 1
a195 68
/* TUI readline command.
   Execute the gdb command bound to the specified key.  */
static int
tui_rl_command_key (int count, int key)
{
  int i;

  reinitialize_more_filter ();
  for (i = 0; tui_commands[i].cmd; i++)
    {
      if (tui_commands[i].key == key)
        {
          /* Must save the command because it can be modified
             by execute_command.  */
          char* cmd = alloca (strlen (tui_commands[i].cmd) + 1);
          strcpy (cmd, tui_commands[i].cmd);
          execute_command (cmd, TRUE);
          return 0;
        }
    }
  return 0;
}

/* TUI readline command.
   Temporarily leave the TUI SingleKey mode to allow editing
   a gdb command with the normal readline.  Once the command
   is executed, the TUI SingleKey mode is installed back.  */
static int
tui_rl_command_mode (int count, int key)
{
  tui_set_key_mode (tui_one_command_mode);
  return rl_insert (count, key);
}

/* TUI readline command.
   Switch between TUI SingleKey mode and gdb readline editing.  */
static int
tui_rl_next_keymap (void)
{
  tui_set_key_mode (tui_current_key_mode == tui_command_mode
                    ? tui_single_key_mode : tui_command_mode);
  return 0;
}

/* Readline hook to redisplay ourself the gdb prompt.
   In the SingleKey mode, the prompt is not printed so that
   the command window is cleaner.  It will be displayed if
   we temporarily leave the SingleKey mode.  */
static int
tui_rl_startup_hook ()
{
  rl_already_prompted = 1;
  if (tui_current_key_mode != tui_command_mode)
    tui_set_key_mode (tui_single_key_mode);
  tui_redisplay_readline ();
  return 0;
}

/* Change the TUI key mode by installing the appropriate readline keymap.  */
void
tui_set_key_mode (enum tui_key_mode mode)
{
  tui_current_key_mode = mode;
  rl_set_keymap (mode == tui_single_key_mode
                 ? tui_keymap : tui_readline_standard_keymap);
  tuiShowLocatorContent ();
}

a200 3
  int i;
  Keymap tui_ctlx_keymap;

a203 28
  rl_add_defun ("gdb-command", tui_rl_command_key, -1);
  rl_add_defun ("next-keymap", tui_rl_next_keymap, -1);

  tui_keymap = rl_make_bare_keymap ();
  tui_ctlx_keymap = rl_make_bare_keymap ();
  tui_readline_standard_keymap = rl_get_keymap ();

  for (i = 0; tui_commands[i].cmd; i++)
    rl_bind_key_in_map (tui_commands[i].key, tui_rl_command_key, tui_keymap);

  rl_generic_bind (ISKMAP, "\\C-x", (char*) tui_ctlx_keymap, tui_keymap);

  /* Bind all other keys to tui_rl_command_mode so that we switch
     temporarily from SingleKey mode and can enter a gdb command.  */
  for (i = ' '; i < 0x7f; i++)
    {
      int j;

      for (j = 0; tui_commands[j].cmd; j++)
        if (tui_commands[j].key == i)
          break;

      if (tui_commands[j].cmd)
        continue;

      rl_bind_key_in_map (i, tui_rl_command_mode, tui_keymap);
    }

a204 1
  rl_bind_key_in_map ('a', tui_rl_switch_mode, tui_ctlx_keymap);
a205 1
  rl_bind_key_in_map ('A', tui_rl_switch_mode, tui_ctlx_keymap);
a206 1
  rl_bind_key_in_map (CTRL ('A'), tui_rl_switch_mode, tui_ctlx_keymap);
a207 1
  rl_bind_key_in_map ('1', tui_rl_delete_other_windows, tui_ctlx_keymap);
a208 4
  rl_bind_key_in_map ('2', tui_rl_change_windows, tui_ctlx_keymap);
  rl_bind_key_in_map ('q', tui_rl_next_keymap, tui_keymap);
  rl_bind_key_in_map ('s', tui_rl_next_keymap, emacs_ctlx_keymap);
  rl_bind_key_in_map ('s', tui_rl_next_keymap, tui_ctlx_keymap);
a257 1
  rl_startup_hook = tui_rl_startup_hook;
a267 2
  /* Restore TUI keymap.  */
  tui_set_key_mode (tui_current_key_mode);
a284 3
  /* Restore initial readline keymap.  */
  rl_set_keymap (tui_readline_standard_keymap);

a286 2
  rl_startup_hook = 0;
  rl_already_prompted = 0;
a407 1
  struct symtab_and_line cursal = get_current_source_symtab_and_line ();
d411 1
a411 1
  tuiUpdateSourceWindowsWithLine (cursal.symtab, line);
@


1.16.2.1
log
@2002-08-18  Daniel Jacobowitz  <drow@@mvista.com>

        Fix PR gdb/655
        * tui.c: Disable <termio.h> include.
@
text
@a50 1
#if 0
a51 1
#endif
@


1.15
log
@2002-02-08  Daniel Jacobowitz  <drow@@mvista.com>

        * utils.c: Include <curses.h> before "bfd.h".
        * tui/tui-hooks.c: Likewise.
        * tui/tui.c: Likewise.
        * tui/tuiCommand.c: Likewise.
        * tui/tuiData.c: Likewise.
        * tui/tuiDataWin.c: Likewise.
        * tui/tuiDisassem.c: Likewise.
        * tui/tuiGeneralWin.c: Likewise.
        * tui/tuiIO.c: Likewise.
        * tui/tuiLayout.c: Likewise.
        * tui/tuiRegs.c: Likewise.
        * tui/tuiSource.c: Likewise.
        * tui/tuiSourceWin.c: Likewise.
        * tui/tuiStack.c: Likewise.
        * tui/tuiWin.c: Likewise.
@
text
@d2 4
a5 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d25 8
a32 1
/* If we need <curses.h>, we must include it before we get "bfd.h".  */
@


1.14
log
@	* tui.c (tui_enable): Remove call to terminal_save_ours().
	(tui_disable): Likewise.
@
text
@d22 10
@


1.13
log
@	* tuiStack.c (tuiUpdateLocatorFilename): Use const char*.
	* tuiStack.h (tuiUpdateLocatorFilename): Update prototype.
	* tuiWin.c (_initialize_tuiWin): Don't cast table of enum in calls
	to add_set_enum_cmd.
	* tui.c (tui_show_source): New function.
	(tuiGetLowDisassemblyAddress): Use CORE_ADDR for newLow.
	(tui_switch_mode): Prep or deprep readline terminal;
	make sure the \n we return does not redo the last command.
	* tui.h (tui_show_source): Declare.
	(tui_out_new, tui_install_hooks, tui_remove_hooks): Likewise.
	(tui_active, tui_initialize_io, tui_initialize_readline): Likewise.
@
text
@a242 3

  /* Update gdb's knowledge of its terminal.  */
  terminal_save_ours ();
a264 2
  /* Update gdb's knowledge of its terminal.  */
  terminal_save_ours ();
@


1.13.2.1
log
@	* tui.c (tui_enable): Remove call to terminal_save_ours().
	(tui_disable): Likewise.
@
text
@d243 3
d268 2
@


1.12
log
@	* tui.h (tui_show_assembly): Declare.
	(tui_is_window_visible): Declare.
	* tui.c (tui_show_assembly): New function.
	(tui_is_window_visible): New function.
	(tui_get_command_dimension): New function.
@
text
@d42 1
d47 1
d60 2
d66 1
d82 3
d243 3
d268 2
d292 1
a292 1
  Opaque newLow;
d401 9
@


1.11
log
@	* tui.c (tui_change_windows): New function.
	(tui_delete_other_windows): New function.
	(tui_initialize_readline): Bind them to C-X 1 and C-X 2.
	(tui_enable): Enable the keypad; call tui_update_variables.
	(strcat_to_buf_with_fmt): Remove.
@
text
@d388 32
@


1.10
log
@        * tui.h: Remove old declarations, add the new ones.
        * tui.c (tui_switch_mode): New function.
        (tui_initialize_readline): New function.
        (tui_enable): New function.
        (tui_disable): New function.
        (tuiGetLowDisassemblyAddress): Use CORE_ADDR, cleanup.
        (tui_vSelectSourceSymtab): Remove.
        (tuiInitWindows): Remove.
        (_initialize_tui): Remove.
        (_tuiReset): Keep but put arround #if 0.
@
text
@d40 1
d80 85
d176 2
d199 2
a200 2
      cbreak();
      noecho();
d213 1
d228 2
a306 17

  return;
}				/* strcat_to_buf */

/* VARARGS */
void
strcat_to_buf_with_fmt (char *buf, int bufLen, char *format, ...)
{
  char *linebuffer;
  struct cleanup *old_cleanups;
  va_list args;
  va_start (args, format);
  vasprintf (&linebuffer, format, args);
  old_cleanups = make_cleanup (xfree, linebuffer);
  strcat_to_buf (buf, bufLen, linebuffer);
  do_cleanups (old_cleanups);
  va_end (args);
@


1.9
log
@	* tuiIO.c (_tuiHandleResizeDuringIO): Call tuiRefreshAll.
	(tuiRead, tui_vread): Remove.

	* tui.c (va_catch_errors, tuiDo, tuiDoAndReturnToTop): Remove.
	(vcatch_errors, _tui_vDo): Remove.
	* tui.h (tuiDo, tuiDoAndReturnToTop): Remove.

	* tuiLayout.c (tuiSetLayout): Remove vcatch_errors.
	(tui_set_layout): Rename of _tuiSetLayoutTo, public.
	(_tuiToggleLayout_command): Merge with _tui_vToggleLayout_command.
	(_tuiToggleSplitLayout_command): Merge with _tui_vToggleSplitLayout_command.
	(_tuiLayout_command): Call tui_set_layout.

	* tuiRegs.c (_tuiScrollRegsBackward_command): Call tui_scroll.
	(_tuiScrollRegsForward_command): Likewise.
	(_tuiShowFloat_command): Call _tui_vShowRegisters_commandSupport.
	(_tuiShowGeneral_command): Likewise.
	(_tuiShowSpecial_command): Likewise.
	(_tuiToggleFloatRegs_command): Call tuiToggleFloatRegs.
	* tuiWin.c (tui_scroll): Rename of tui_vScroll, update parameters.
	(_tuiScrollForward_command): Call tui_scroll.
	(_tuiScrollBackward_command): Likewise.
	(_tuiScrollLeft_command): Likewise.
	(_tuiScrollRight_command): Likewise.
	(_tuiSetFocus_command): Call _tuiSetFocus.
	(_tuiRefreshAll_command): Call tuiRefreshAll.
	(_tuiSetWinHeight_command): Call _tuiSetWinHeight.
	(_tuiXDBsetWinHeight_command): Call _tuiXDBsetWinHeight.
	* tuiWin.h (tui_scroll): Rename of tui_vScroll, update parameters.
@
text
@d41 12
a52 37

/* The Solaris header files seem to provide no declaration for this at
   all when __STDC__ is defined.  This shouldn't conflict with
   anything.  */
extern char *tgoto ();

/***********************
** Local Definitions
************************/
#define FILEDES         2
/* Solaris <sys/termios.h> defines CTRL. */
#ifndef CTRL
#define CTRL(x)         (x & ~0140)
#endif
#define CHK(val, dft)   (val<=0 ? dft : val)

#define TOGGLE_USAGE "Usage:toggle breakpoints"
#define TUI_TOGGLE_USAGE "Usage:\ttoggle $fregs\n\ttoggle breakpoints"

/*****************************
** Local static forward decls
******************************/
static void _tuiReset (void);
static void _toggle_command (char *, int);
static void _tui_vToggle_command (va_list);



/***********************
** Public Functions
************************/

/*
   ** tuiInit().
 */
void
tuiInit (char *argv0)
d54 6
a59 58
  extern void init_page_info ();
extern void initialize_tui_files (void);

  initialize_tui_files ();
  initializeStaticData ();
  initscr ();
  refresh ();
  setTermHeightTo (LINES);
  setTermWidthTo (COLS);
  tuiInitWindows ();
  wrefresh (cmdWin->generic.handle);
  init_page_info ();
  /* Don't hook debugger output if doing command-window
     * the XDB way. However, one thing we do want to do in
     * XDB style is set up the scrolling region to be
     * the bottom of the screen (tuiTermUnsetup()).
   */
  fputs_unfiltered_hook = NULL;
  rl_initialize ();		/* need readline initialization to
				   * create termcap sequences
				 */
  tuiTermUnsetup (1, cmdWin->detail.commandInfo.curch);

  return;
}				/* tuiInit */


/*
   ** tuiInitWindows().
 */
void
tuiInitWindows (void)
{
  TuiWinType type;

  tuiSetLocatorContent (0);
  showLayout (SRC_COMMAND);
  keypad (cmdWin->generic.handle, TRUE);
  echo ();
  crmode ();
  nl ();
  tuiSetWinFocusTo (srcWin);

  return;
}				/* tuiInitWindows */


/*
   ** tuiCleanUp().
   **        Kill signal handler and cleanup termination method
 */
void
tuiResetScreen (void)
{
  TuiWinType type = SRC_WIN;

  keypad (cmdWin->generic.handle, FALSE);
  for (; type < MAX_MAJOR_WINDOWS; type++)
d61 2
a62 4
      if (m_winPtrNotNull (winList[type]) &&
	  winList[type]->generic.type != UNDEFINED_WIN &&
	  !winList[type]->generic.isVisible)
	tuiDelWindow (winList[type]);
a63 6
  endwin ();
  initscr ();
  refresh ();
  echo ();
  crmode ();
  nl ();
d65 13
a77 2
  return;
}				/* tuiResetScreen */
d79 2
a80 5

/*
   ** tuiCleanUp().
   **        Kill signal handler and cleanup termination method
 */
d82 1
a82 1
tuiCleanUp (void)
d84 1
a84 2
  char *buffer;
  extern char *term_cursor_move;
d86 5
a90 8
  signal (SIGINT, SIG_IGN);
  tuiTermSetup (0);		/* Restore scrolling region to whole screen */
  keypad (cmdWin->generic.handle, FALSE);
  freeAllWindows ();
  endwin ();
  buffer = tgoto (term_cursor_move, 0, termHeight ());
  tputs (buffer, 1, putchar);
  _tuiReset ();
d92 16
a107 2
  return;
}				/* tuiCleanUp */
d109 26
d136 2
a137 12
/*
   ** tuiError().
 */
void
tuiError (char *string, int exitGdb)
{
  puts_unfiltered (string);
  if (exitGdb)
    {
      tuiCleanUp ();
      exit (-1);
    }
d139 1
a139 2
  return;
}				/* tuiError */
d141 4
d146 4
a149 4
/*
   ** tui_vError()
   **        tuiError with args in a va_list.
 */
d151 1
a151 1
tui_vError (va_list args)
d153 2
a154 2
  char *string;
  int exitGdb;
d156 2
a157 2
  string = va_arg (args, char *);
  exitGdb = va_arg (args, int);
d159 2
a160 1
  tuiError (string, exitGdb);
d162 3
a164 2
  return;
}				/* tui_vError */
d166 3
d170 2
a171 4
/*
   ** tuiFree()
   **    Wrapper on top of free() to ensure that input address is greater than 0x0
 */
d179 1
d181 5
a185 11
  return;
}				/* tuiFree */


/* tuiGetLowDisassemblyAddress().
   **        Determine what the low address will be to display in the TUI's
   **        disassembly window.  This may or may not be the same as the
   **        low address input.
 */
Opaque
tuiGetLowDisassemblyAddress (Opaque low, Opaque pc)
d190 2
a191 4
  /*
     ** Determine where to start the disassembly so that the pc is about in the
     ** middle of the viewport.
   */
d204 1
a204 66
}				/* tuiGetLowDisassemblyAddress */


/* tui_vGetLowDisassemblyAddress().
   **        Determine what the low address will be to display in the TUI's
   **        disassembly window with args in a va_list.
 */
Opaque
tui_vGetLowDisassemblyAddress (va_list args)
{
  int line;
  Opaque newLow;
  Opaque low;
  Opaque pc;

  low = va_arg (args, Opaque);
  pc = va_arg (args, Opaque);

  return (tuiGetLowDisassemblyAddress (low, pc));

}				/* tui_vGetLowDisassemblyAddress */


void
tui_vSelectSourceSymtab (va_list args)
{
  struct symtab *s = va_arg (args, struct symtab *);

  select_source_symtab (s);
  return;
}				/* tui_vSelectSourceSymtab */


/*
   ** _initialize_tui().
   **      Function to initialize gdb commands, for tui window manipulation.
 */
void
_initialize_tui (void)
{
#if 0
  if (tui_version)
    {
      add_com ("toggle", class_tui, _toggle_command,
	       "Toggle Terminal UI Features\n\
Usage: Toggle $fregs\n\
\tToggles between single and double precision floating point registers.\n");
    }
#endif
  char *helpStr;

  if (tui_version)
    helpStr = "Toggle Specified Features\n\
Usage:\ttoggle $fregs\n\ttoggle breakpoints";
  else
    helpStr = "Toggle Specified Features\nUsage:toggle breakpoints";
  add_abbrev_prefix_cmd ("toggle",
			 class_tui,
			 _toggle_command,
			 helpStr,
			 &togglelist,
			 "toggle ",
			 1,
			 &cmdlist);
}				/* _initialize_tui */

d235 5
d241 2
a242 53



/***********************
** Static Functions
************************/



static void
_toggle_command (char *arg, int fromTTY)
{
  printf_filtered ("Specify feature to toggle.\n%s\n",
		   (tui_version) ? TUI_TOGGLE_USAGE : TOGGLE_USAGE);
/*
   tuiDo((TuiOpaqueFuncPtr)_Toggle_command, arg, fromTTY);
 */
}

/*
   ** _tui_vToggle_command().
 */
static void
_tui_vToggle_command (va_list args)
{
  char *arg;
  int fromTTY;

  arg = va_arg (args, char *);

  if (arg == (char *) NULL)
    printf_filtered (TOGGLE_USAGE);
  else
    {
      char *ptr = (char *) tuiStrDup (arg);
      int i;

      for (i = 0; (ptr[i]); i++)
	ptr[i] = toupper (arg[i]);

      if (subset_compare (ptr, TUI_FLOAT_REGS_NAME))
	tuiToggleFloatRegs ();
/*        else if (subset_compare(ptr, "ANOTHER TOGGLE OPTION"))
   ...
 */
      else
	printf_filtered (TOGGLE_USAGE);
      tuiFree (ptr);
    }

  return;
}				/* _tuiToggle_command */

d312 2
@


1.8
log
@	* tuiWin.c (_tuiSetFocus): Replace subsetCompare with subset_compare.
	* tuiLayout.c (_tuiSetLayoutTo): Likewise.
	* tui.c (_tui_vToggle_command): Likewise.
@
text
@a65 1
static Opaque _tui_vDo (TuiOpaqueFuncPtr, va_list);
a278 86
/*
   ** tuiDo().
   **        General purpose function to execute a tui function.  Transitions
   **        between curses and the are handled here.  This function is called
   **        by non-tui gdb functions.
   **
   **        Errors are caught here.
   **        If there is no error, the value returned by 'func' is returned.
   **        If there is an error, then zero is returned.
   **
   **       Must not be called with immediate_quit in effect (bad things might
   **       happen, say we got a signal in the middle of a memcpy to quit_return).
   **       This is an OK restriction; with very few exceptions immediate_quit can
   **       be replaced by judicious use of QUIT.
 */
Opaque
tuiDo (TuiOpaqueFuncPtr func, ...)
{
  extern int terminal_is_ours;

  Opaque ret = (Opaque) NULL;

  /* It is an error to be tuiDo'ing if we
     * don't own the terminal.
   */
  if (!terminal_is_ours)
    return ret;

  if (tui_version)
    {
      va_list args;

      va_start (args, func);
      ret = _tui_vDo (func, args);
      va_end (args);
    }

  return ret;
}				/* tuiDo */


/*
   ** tuiDoAndReturnToTop().
   **        General purpose function to execute a tui function.  Transitions
   **        between curses and the are handled here.  This function is called
   **        by non-tui gdb functions who wish to reset gdb to the top level.
   **        After the tuiDo is performed, a return to the top level occurs.
   **
   **        Errors are caught here.
   **        If there is no error, the value returned by 'func' is returned.
   **        If there is an error, then zero is returned.
   **
   **       Must not be called with immediate_quit in effect (bad things might
   **       happen, say we got a signal in the middle of a memcpy to quit_return).
   **       This is an OK restriction; with very few exceptions immediate_quit can
   **       be replaced by judicious use of QUIT.
   **
 */
Opaque
tuiDoAndReturnToTop (TuiOpaqueFuncPtr func, ...)
{
  extern int terminal_is_ours;

  Opaque ret = (Opaque) NULL;

  /* It is an error to be tuiDo'ing if we
     * don't own the terminal.
   */
  if (!terminal_is_ours)
    return ret;

  if (tui_version)
    {
      va_list args;

      va_start (args, func);
      ret = _tui_vDo (func, args);

      /* force a return to the top level */
      return_to_top_level (RETURN_ERROR);
    }

  return ret;
}				/* tuiDoAndReturnToTop */


a322 78
/*
   ** va_catch_errors().
   **       General purpose function to execute a function, catching errors.
   **       If there is no error, the value returned by 'func' is returned.
   **       If there is error, then zero is returned.
   **       Note that 'func' must take a variable argument list as well.
   **
   **       Must not be called with immediate_quit in effect (bad things might
   **       happen, say we got a signal in the middle of a memcpy to quit_return).
   **       This is an OK restriction; with very few exceptions immediate_quit can
   **       be replaced by judicious use of QUIT.
 */
Opaque
va_catch_errors (TuiOpaqueFuncPtr func, va_list args)
{
  Opaque ret = (Opaque) NULL;

  /*
     ** We could have used catch_errors(), but it doesn't handle variable args.
     ** Also, for the tui, we always want to catch all errors, so we don't
     ** need to pass a mask, or an error string.
   */
  jmp_buf saved_error;
  jmp_buf saved_quit;
  jmp_buf tmp_jmp;
  struct cleanup *saved_cleanup_chain;
  char *saved_error_pre_print;
  char *saved_quit_pre_print;
  extern jmp_buf error_return;
  extern jmp_buf quit_return;

  saved_cleanup_chain = save_cleanups ();
  saved_error_pre_print = error_pre_print;
  saved_quit_pre_print = quit_pre_print;

  memcpy ((char *) saved_error, (char *) error_return, sizeof (jmp_buf));
  error_pre_print = "";
  memcpy (saved_quit, quit_return, sizeof (jmp_buf));
  quit_pre_print = "";

  if (setjmp (tmp_jmp) == 0)
    {
      va_list argList = args;
      memcpy (error_return, tmp_jmp, sizeof (jmp_buf));
      memcpy (quit_return, tmp_jmp, sizeof (jmp_buf));
      ret = func (argList);
    }
  restore_cleanups (saved_cleanup_chain);
  memcpy (error_return, saved_error, sizeof (jmp_buf));
  error_pre_print = saved_error_pre_print;
  memcpy (quit_return, saved_quit, sizeof (jmp_buf));
  quit_pre_print = saved_quit_pre_print;

  return ret;
}

/*
   ** vcatch_errors().
   **        Catch errors occurring in tui or non tui function, handling
   **        variable param lists. Note that 'func' must take a variable
   **        argument list as well.
 */
Opaque
vcatch_errors (OpaqueFuncPtr func, ...)
{
  Opaque ret = (Opaque) NULL;
  va_list args;
  va_start (args, func);
/*
   va_arg(args, OpaqueFuncPtr);
 */
  ret = va_catch_errors (func, args);
  va_end (args);

  return ret;
}


a359 45

/*
   ** _tui_vDo().
   **        General purpose function to execute a tui function.  Transitions
   **        between curses and the are handled here.  This function is called
   **        by non-tui gdb functions.
   **
   **        Errors are caught here.
   **        If there is no error, the value returned by 'func' is returned.
   **        If there is an error, then zero is returned.
   **
   **       Must not be called with immediate_quit in effect (bad things might
   **       happen, say we got a signal in the middle of a memcpy to quit_return).
   **       This is an OK restriction; with very few exceptions immediate_quit can
   **       be replaced by judicious use of QUIT.
 */
static Opaque
_tui_vDo (TuiOpaqueFuncPtr func, va_list args)
{
  extern int terminal_is_ours;

  Opaque ret = (Opaque) NULL;

  /* It is an error to be tuiDo'ing if we
     * don't own the terminal.
   */
  if (!terminal_is_ours)
    return ret;

  if (tui_version)
    {
      /* If doing command window the "XDB way" (command window
         * is unmanaged by curses...
       */
      /* Set up terminal for TUI */
      tuiTermSetup (1);

      ret = va_catch_errors (func, args);

      /* Set up terminal for command window */
      tuiTermUnsetup (1, cmdWin->detail.commandInfo.curch);
    }

  return ret;
}				/* _tui_vDo */
@


1.7
log
@	* tuiWin.c, tui.c, tuiCommand.c: Use ansi prototype.
	tuiIO.c, tuiData.c: Likewise.
	tuiDataWin.c, tuiDisassem.c: Likewise.
	tuiGeneralWin.c, tuiLayout.c: Likewise.
	tuiRegs.c, tuiSource.c: Likewise.
	tuiSouceWin.c, tuiStack.c: Likewise.
@
text
@d603 1
a603 1
      if (subsetCompare (ptr, TUI_FLOAT_REGS_NAME))
d605 1
a605 1
/*        else if (subsetCompare(ptr, "ANOTHER TOGGLE OPTION"))
@


1.6
log
@	* tuiWin.c, tuiWin.h, tui.c, tui.h, tuiCommand.c: Add FSF copyright.
	tuiCommand.h, tuiIO.c, tuiIO.h, tuiData.h, tuiData.c: Likewise.
	tuiDataWin.c, tuiDataWin.h, tuiDisassem.c, tuiDisassem.h: Likewise.
	tuiGeneralWin.c, tuiGeneralWin.h, tuiLayout.c, tuiLayout.h: Likewise.
	tuiRegs.c, tuiRegs.h, tuiSource.c, tuiSource.h: Likewise.
	tuiSouceWin.c, tuiSourceWin.h, tuiStack.c, tuiStack.h: Likewise.
@
text
@a77 1
#ifdef __STDC__
a78 4
#else
tuiInit (argv0)
     char *argv0;
#endif
a110 1
#ifdef __STDC__
a111 3
#else
tuiInitWindows ()
#endif
a131 1
#ifdef __STDC__
a132 3
#else
tuiResetScreen ()
#endif
a159 1
#ifdef __STDC__
a160 3
#else
tuiCleanUp ()
#endif
d182 1
a182 9
#ifdef __STDC__
tuiError (
	   char *string,
	   int exitGdb)
#else
tuiError (string, exitGdb)
     char *string;
     int exitGdb;
#endif
d200 1
a200 7
#ifdef __STDC__
tui_vError (
	     va_list args)
#else
tui_vError (args)
     va_list args;
#endif
d219 1
a219 7
#ifdef __STDC__
tuiFree (
	  char *ptr)
#else
tuiFree (ptr)
     char *ptr;
#endif
d236 1
a236 9
#ifdef __STDC__
tuiGetLowDisassemblyAddress (
			      Opaque low,
			      Opaque pc)
#else
tuiGetLowDisassemblyAddress (low, pc)
     Opaque low;
     Opaque pc;
#endif
d265 1
a265 7
#ifdef __STDC__
tui_vGetLowDisassemblyAddress (
				va_list args)
#else
tui_vGetLowDisassemblyAddress (args)
     va_list args;
#endif
d296 1
a296 8
#ifdef __STDC__
tuiDo (
	TuiOpaqueFuncPtr func,...)
#else
tuiDo (func, va_alist)
     TuiOpaqueFuncPtr func;
     va_dcl
#endif
a311 1
#ifdef __STDC__
a312 3
#else
      va_start (args);
#endif
d339 1
a339 8
#ifdef __STDC__
tuiDoAndReturnToTop (
		      TuiOpaqueFuncPtr func,...)
#else
tuiDoAndReturnToTop (func, va_alist)
     TuiOpaqueFuncPtr func;
     va_dcl
#endif
a354 1
#ifdef __STDC__
a355 3
#else
      va_start (args);
#endif
d367 1
a367 7
#ifdef __STDC__
tui_vSelectSourceSymtab (
			  va_list args)
#else
tui_vSelectSourceSymtab (args)
     va_list args;
#endif
d423 1
a423 9
#ifdef __STDC__
va_catch_errors (
		  TuiOpaqueFuncPtr func,
		  va_list args)
#else
va_catch_errors (func, args)
     TuiOpaqueFuncPtr func;
     va_list args;
#endif
d473 1
a473 12
#ifdef __STDC__
vcatch_errors (
		OpaqueFuncPtr func,...)
#else
vcatch_errors (va_alist)
     va_dcl
/*
   vcatch_errors(func, va_alist)
   OpaqueFuncPtr    func;
   va_dcl
 */
#endif
a476 1
#ifdef __STDC__
a480 6
#else
  OpaqueFuncPtr func;

  va_start (args);
  func = va_arg (args, OpaqueFuncPtr);
#endif
d489 1
a489 11
#ifdef __STDC__
strcat_to_buf (
		char *buf,
		int buflen,
		char *itemToAdd)
#else
strcat_to_buf (buf, buflen, itemToAdd)
     char *buf;
     int buflen;
     char *itemToAdd;
#endif
d504 1
a504 9
#ifdef ANSI_PROTOTYPES
strcat_to_buf_with_fmt (
			 char *buf,
			 int bufLen,
			 char *format,...)
#else
strcat_to_buf_with_fmt (va_alist)
     va_dcl
#endif
a508 1
#ifdef ANSI_PROTOTYPES
a509 10
#else
  char *buf;
  int bufLen;
  char *format;

  va_start (args);
  buf = va_arg (args, char *);
  bufLen = va_arg (args, int);
  format = va_arg (args, char *);
#endif
d542 1
a542 9
#ifdef __STDC__
_tui_vDo (
	   TuiOpaqueFuncPtr func,
	   va_list args)
#else
_tui_vDo (func, args)
     TuiOpaqueFuncPtr func;
     va_list args;
#endif
d573 1
a573 9
#ifdef __STDC__
_toggle_command (
		  char *arg,
		  int fromTTY)
#else
_toggle_command (arg, fromTTY)
     char *arg;
     int fromTTY;
#endif
d586 1
a586 7
#ifdef __STDC__
_tui_vToggle_command (
		       va_list args)
#else
_tui_vToggle_command (args)
     va_list args;
#endif
a617 1
#ifdef __STDC__
a618 3
#else
_tuiReset ()
#endif
@


1.5
log
@Replace free() with xfree().
@
text
@d1 20
a20 4
/*
   ** tui.c
   **         General functions for the WDB TUI
 */
@


1.4
log
@Protoization.
@
text
@d244 1
a244 1
      free (ptr);
d629 1
a629 1
  old_cleanups = make_cleanup (free, linebuffer);
@


1.3
log
@PARAMS removal.
@
text
@d444 1
a444 1
_initialize_tui ()
@


1.2
log
@Configure TUI to use <ncurses.h> when available.
@
text
@d47 4
a50 4
static void _tuiReset PARAMS ((void));
static void _toggle_command PARAMS ((char *, int));
static void _tui_vToggle_command PARAMS ((va_list));
static Opaque _tui_vDo PARAMS ((TuiOpaqueFuncPtr, va_list));
d70 1
a70 1
  extern void initialize_tui_files PARAMS ((void));
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
** tui.c
**         General functions for the WDB TUI
*/
a9 1
#include <curses.h>
d59 2
a60 2
** tuiInit().
*/
d85 1
a85 1
     */
a86 1
  flush_hook = NULL;
d88 2
a89 2
		      * create termcap sequences
		      */
d97 2
a98 2
** tuiInitWindows().
*/
d121 3
a123 3
** tuiCleanUp().
**        Kill signal handler and cleanup termination method
*/
d153 3
a155 3
** tuiCleanUp().
**        Kill signal handler and cleanup termination method
*/
d180 2
a181 2
** tuiError().
*/
d205 3
a207 3
** tui_vError()
**        tuiError with args in a va_list.
*/
d230 3
a232 3
** tuiFree()
**    Wrapper on top of free() to ensure that input address is greater than 0x0
*/
d252 4
a255 4
**        Determine what the low address will be to display in the TUI's
**        disassembly window.  This may or may not be the same as the
**        low address input.
*/
d271 3
a273 3
    ** Determine where to start the disassembly so that the pc is about in the
    ** middle of the viewport.
    */
d290 3
a292 3
**        Determine what the low address will be to display in the TUI's
**        disassembly window with args in a va_list.
*/
d316 14
a329 14
** tuiDo().
**        General purpose function to execute a tui function.  Transitions
**        between curses and the are handled here.  This function is called
**        by non-tui gdb functions.
**
**        Errors are caught here.
**        If there is no error, the value returned by 'func' is returned.
**        If there is an error, then zero is returned.
**
**       Must not be called with immediate_quit in effect (bad things might
**       happen, say we got a signal in the middle of a memcpy to quit_return).
**       This is an OK restriction; with very few exceptions immediate_quit can
**       be replaced by judicious use of QUIT.
*/
d346 1
a346 1
     */
d368 16
a383 16
** tuiDoAndReturnToTop().
**        General purpose function to execute a tui function.  Transitions
**        between curses and the are handled here.  This function is called
**        by non-tui gdb functions who wish to reset gdb to the top level.
**        After the tuiDo is performed, a return to the top level occurs.
**
**        Errors are caught here.
**        If there is no error, the value returned by 'func' is returned.
**        If there is an error, then zero is returned.
**
**       Must not be called with immediate_quit in effect (bad things might
**       happen, say we got a signal in the middle of a memcpy to quit_return).
**       This is an OK restriction; with very few exceptions immediate_quit can
**       be replaced by judicious use of QUIT.
**
*/
d400 1
a400 1
     */
d440 3
a442 3
** _initialize_tui().
**      Function to initialize gdb commands, for tui window manipulation.
*/
d470 1
a470 1
}				/* _initialize_tui*/
d474 11
a484 11
** va_catch_errors().
**       General purpose function to execute a function, catching errors.
**       If there is no error, the value returned by 'func' is returned.
**       If there is error, then zero is returned.
**       Note that 'func' must take a variable argument list as well.
**
**       Must not be called with immediate_quit in effect (bad things might
**       happen, say we got a signal in the middle of a memcpy to quit_return).
**       This is an OK restriction; with very few exceptions immediate_quit can
**       be replaced by judicious use of QUIT.
*/
d499 4
a502 4
  ** We could have used catch_errors(), but it doesn't handle variable args.
  ** Also, for the tui, we always want to catch all errors, so we don't
  ** need to pass a mask, or an error string.
  */
d538 5
a542 5
** vcatch_errors().
**        Catch errors occurring in tui or non tui function, handling
**        variable param lists. Note that 'func' must take a variable
**        argument list as well.
*/
d551 4
a554 4
vcatch_errors(func, va_alist)
    OpaqueFuncPtr    func;
    va_dcl
*/
d562 2
a563 2
    va_arg(args, OpaqueFuncPtr);
*/
d645 14
a658 14
** _tui_vDo().
**        General purpose function to execute a tui function.  Transitions
**        between curses and the are handled here.  This function is called
**        by non-tui gdb functions.
**
**        Errors are caught here.
**        If there is no error, the value returned by 'func' is returned.
**        If there is an error, then zero is returned.
**
**       Must not be called with immediate_quit in effect (bad things might
**       happen, say we got a signal in the middle of a memcpy to quit_return).
**       This is an OK restriction; with very few exceptions immediate_quit can
**       be replaced by judicious use of QUIT.
*/
d676 1
a676 1
     */
d684 1
a684 1
         */
d712 2
a713 2
  tuiDo((TuiOpaqueFuncPtr)_Toggle_command, arg, fromTTY);
*/
d717 2
a718 2
** _tui_vToggle_command().
*/
d746 2
a747 2
            ...
*/
d767 3
a769 3
    ** reset the teletype mode bits to a sensible state.
    ** Copied tset.c
    */
d805 1
a805 1
#else /*USG*/
d819 1
a819 1
#else /*hp9000s800*/
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d2 3
a4 3
   ** tui.c
   **         General functions for the WDB TUI
 */
d60 2
a61 2
   ** tuiInit().
 */
d86 1
a86 1
   */
d90 2
a91 2
				   * create termcap sequences
				 */
d99 2
a100 2
   ** tuiInitWindows().
 */
d123 3
a125 3
   ** tuiCleanUp().
   **        Kill signal handler and cleanup termination method
 */
d155 3
a157 3
   ** tuiCleanUp().
   **        Kill signal handler and cleanup termination method
 */
d182 2
a183 2
   ** tuiError().
 */
d207 3
a209 3
   ** tui_vError()
   **        tuiError with args in a va_list.
 */
d232 3
a234 3
   ** tuiFree()
   **    Wrapper on top of free() to ensure that input address is greater than 0x0
 */
d254 4
a257 4
   **        Determine what the low address will be to display in the TUI's
   **        disassembly window.  This may or may not be the same as the
   **        low address input.
 */
d273 3
a275 3
     ** Determine where to start the disassembly so that the pc is about in the
     ** middle of the viewport.
   */
d292 3
a294 3
   **        Determine what the low address will be to display in the TUI's
   **        disassembly window with args in a va_list.
 */
d318 14
a331 14
   ** tuiDo().
   **        General purpose function to execute a tui function.  Transitions
   **        between curses and the are handled here.  This function is called
   **        by non-tui gdb functions.
   **
   **        Errors are caught here.
   **        If there is no error, the value returned by 'func' is returned.
   **        If there is an error, then zero is returned.
   **
   **       Must not be called with immediate_quit in effect (bad things might
   **       happen, say we got a signal in the middle of a memcpy to quit_return).
   **       This is an OK restriction; with very few exceptions immediate_quit can
   **       be replaced by judicious use of QUIT.
 */
d348 1
a348 1
   */
d370 16
a385 16
   ** tuiDoAndReturnToTop().
   **        General purpose function to execute a tui function.  Transitions
   **        between curses and the are handled here.  This function is called
   **        by non-tui gdb functions who wish to reset gdb to the top level.
   **        After the tuiDo is performed, a return to the top level occurs.
   **
   **        Errors are caught here.
   **        If there is no error, the value returned by 'func' is returned.
   **        If there is an error, then zero is returned.
   **
   **       Must not be called with immediate_quit in effect (bad things might
   **       happen, say we got a signal in the middle of a memcpy to quit_return).
   **       This is an OK restriction; with very few exceptions immediate_quit can
   **       be replaced by judicious use of QUIT.
   **
 */
d402 1
a402 1
   */
d442 3
a444 3
   ** _initialize_tui().
   **      Function to initialize gdb commands, for tui window manipulation.
 */
d472 1
a472 1
}				/* _initialize_tui */
d476 11
a486 11
   ** va_catch_errors().
   **       General purpose function to execute a function, catching errors.
   **       If there is no error, the value returned by 'func' is returned.
   **       If there is error, then zero is returned.
   **       Note that 'func' must take a variable argument list as well.
   **
   **       Must not be called with immediate_quit in effect (bad things might
   **       happen, say we got a signal in the middle of a memcpy to quit_return).
   **       This is an OK restriction; with very few exceptions immediate_quit can
   **       be replaced by judicious use of QUIT.
 */
d501 4
a504 4
     ** We could have used catch_errors(), but it doesn't handle variable args.
     ** Also, for the tui, we always want to catch all errors, so we don't
     ** need to pass a mask, or an error string.
   */
d540 5
a544 5
   ** vcatch_errors().
   **        Catch errors occurring in tui or non tui function, handling
   **        variable param lists. Note that 'func' must take a variable
   **        argument list as well.
 */
d553 4
a556 4
   vcatch_errors(func, va_alist)
   OpaqueFuncPtr    func;
   va_dcl
 */
d564 2
a565 2
   va_arg(args, OpaqueFuncPtr);
 */
d647 14
a660 14
   ** _tui_vDo().
   **        General purpose function to execute a tui function.  Transitions
   **        between curses and the are handled here.  This function is called
   **        by non-tui gdb functions.
   **
   **        Errors are caught here.
   **        If there is no error, the value returned by 'func' is returned.
   **        If there is an error, then zero is returned.
   **
   **       Must not be called with immediate_quit in effect (bad things might
   **       happen, say we got a signal in the middle of a memcpy to quit_return).
   **       This is an OK restriction; with very few exceptions immediate_quit can
   **       be replaced by judicious use of QUIT.
 */
d678 1
a678 1
   */
d686 1
a686 1
       */
d714 2
a715 2
   tuiDo((TuiOpaqueFuncPtr)_Toggle_command, arg, fromTTY);
 */
d719 2
a720 2
   ** _tui_vToggle_command().
 */
d748 2
a749 2
   ...
 */
d769 3
a771 3
     ** reset the teletype mode bits to a sensible state.
     ** Copied tset.c
   */
d807 1
a807 1
#else /*USG */
d821 1
a821 1
#else /*hp9000s800 */
@


1.1.1.3
log
@import gdb-1999-10-18 snapshot
@
text
@d88 1
@


