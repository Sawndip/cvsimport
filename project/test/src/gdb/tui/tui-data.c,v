head	1.36;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.36
	gdb_7_6-2013-04-26-release:1.36
	gdb_7_6-branch:1.36.0.2
	gdb_7_6-2013-03-12-branchpoint:1.36
	gdb_7_5_1-2012-11-29-release:1.33
	gdb_7_5-2012-08-17-release:1.33
	gdb_7_5-branch:1.33.0.2
	gdb_7_5-2012-07-18-branchpoint:1.33
	gdb_7_4_1-2012-04-26-release:1.31.4.1
	gdb_7_4-2012-01-24-release:1.31.4.1
	gdb_7_4-branch:1.31.0.4
	gdb_7_4-2011-12-13-branchpoint:1.31
	gdb_7_3_1-2011-09-04-release:1.31
	gdb_7_3-2011-07-26-release:1.31
	gdb_7_3-branch:1.31.0.2
	gdb_7_3-2011-04-01-branchpoint:1.31
	gdb_7_2-2010-09-02-release:1.29
	gdb_7_2-branch:1.29.0.2
	gdb_7_2-2010-07-07-branchpoint:1.29
	gdb_7_1-2010-03-18-release:1.28
	gdb_7_1-branch:1.28.0.2
	gdb_7_1-2010-02-18-branchpoint:1.28
	gdb_7_0_1-2009-12-22-release:1.27
	gdb_7_0-2009-10-06-release:1.27
	gdb_7_0-branch:1.27.0.4
	gdb_7_0-2009-09-16-branchpoint:1.27
	arc-sim-20090309:1.24
	msnyder-checkpoint-072509-branch:1.27.0.2
	msnyder-checkpoint-072509-branchpoint:1.27
	arc-insight_6_8-branch:1.24.0.16
	arc-insight_6_8-branchpoint:1.24
	insight_6_8-branch:1.24.0.14
	insight_6_8-branchpoint:1.24
	reverse-20081226-branch:1.24.0.12
	reverse-20081226-branchpoint:1.24
	multiprocess-20081120-branch:1.24.0.10
	multiprocess-20081120-branchpoint:1.24
	reverse-20080930-branch:1.24.0.8
	reverse-20080930-branchpoint:1.24
	reverse-20080717-branch:1.24.0.6
	reverse-20080717-branchpoint:1.24
	msnyder-reverse-20080609-branch:1.24.0.4
	msnyder-reverse-20080609-branchpoint:1.24
	drow-reverse-20070409-branch:1.14.0.2
	drow-reverse-20070409-branchpoint:1.14
	gdb_6_8-2008-03-27-release:1.24
	gdb_6_8-branch:1.24.0.2
	gdb_6_8-2008-02-26-branchpoint:1.24
	gdb_6_7_1-2007-10-29-release:1.22
	gdb_6_7-2007-10-10-release:1.22
	gdb_6_7-branch:1.22.0.2
	gdb_6_7-2007-09-07-branchpoint:1.22
	insight_6_6-20070208-release:1.13
	gdb_6_6-2006-12-18-release:1.13
	gdb_6_6-branch:1.13.0.18
	gdb_6_6-2006-11-15-branchpoint:1.13
	insight_6_5-20061003-release:1.13
	gdb-csl-symbian-6_4_50_20060226-12:1.13
	gdb-csl-sourcerygxx-3_4_4-25:1.10
	nickrob-async-20060828-mergepoint:1.13
	gdb-csl-symbian-6_4_50_20060226-11:1.13
	gdb-csl-sourcerygxx-4_1-17:1.13
	gdb-csl-20060226-branch-local-2:1.13
	gdb-csl-sourcerygxx-4_1-14:1.13
	gdb-csl-sourcerygxx-4_1-13:1.13
	gdb-csl-sourcerygxx-4_1-12:1.13
	gdb-csl-sourcerygxx-3_4_4-21:1.13
	gdb_6_5-20060621-release:1.13
	gdb-csl-sourcerygxx-4_1-9:1.13
	gdb-csl-sourcerygxx-4_1-8:1.13
	gdb-csl-sourcerygxx-4_1-7:1.13
	gdb-csl-arm-2006q1-6:1.13
	gdb-csl-sourcerygxx-4_1-6:1.13
	gdb-csl-symbian-6_4_50_20060226-10:1.13
	gdb-csl-symbian-6_4_50_20060226-9:1.13
	gdb-csl-symbian-6_4_50_20060226-8:1.13
	gdb-csl-coldfire-4_1-11:1.13
	gdb-csl-sourcerygxx-3_4_4-19:1.13
	gdb-csl-coldfire-4_1-10:1.13
	gdb_6_5-branch:1.13.0.16
	gdb_6_5-2006-05-14-branchpoint:1.13
	gdb-csl-sourcerygxx-4_1-5:1.13
	nickrob-async-20060513-branch:1.13.0.14
	nickrob-async-20060513-branchpoint:1.13
	gdb-csl-sourcerygxx-4_1-4:1.13
	msnyder-reverse-20060502-branch:1.13.0.12
	msnyder-reverse-20060502-branchpoint:1.13
	gdb-csl-morpho-4_1-4:1.13
	gdb-csl-sourcerygxx-3_4_4-17:1.13
	readline_5_1-import-branch:1.13.0.10
	readline_5_1-import-branchpoint:1.13
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.13
	gdb-csl-symbian-20060226-branch:1.13.0.8
	gdb-csl-symbian-20060226-branchpoint:1.13
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.13
	msnyder-reverse-20060331-branch:1.13.0.6
	msnyder-reverse-20060331-branchpoint:1.13
	gdb-csl-available-20060303-branch:1.13.0.4
	gdb-csl-available-20060303-branchpoint:1.13
	gdb-csl-20060226-branch:1.13.0.2
	gdb-csl-20060226-branchpoint:1.13
	gdb_6_4-20051202-release:1.10
	msnyder-fork-checkpoint-branch:1.10.0.6
	msnyder-fork-checkpoint-branchpoint:1.10
	gdb-csl-gxxpro-6_3-branch:1.10.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.10
	gdb_6_4-branch:1.10.0.2
	gdb_6_4-2005-11-01-branchpoint:1.10
	gdb-csl-arm-20051020-branch:1.9.0.16
	gdb-csl-arm-20051020-branchpoint:1.9
	msnyder-tracepoint-checkpoint-branch:1.9.0.14
	msnyder-tracepoint-checkpoint-branchpoint:1.9
	gdb-csl-arm-20050325-2005-q1b:1.9
	gdb-csl-arm-20050325-2005-q1a:1.9
	csl-arm-20050325-branch:1.9.0.12
	csl-arm-20050325-branchpoint:1.9
	gdb-post-i18n-errorwarning-20050211:1.9
	gdb-pre-i18n-errorwarning-20050211:1.9
	gdb_6_3-20041109-release:1.9
	gdb_6_3-branch:1.9.0.8
	gdb_6_3-20041019-branchpoint:1.9
	drow_intercu-merge-20040921:1.9
	drow_intercu-merge-20040915:1.9
	jimb-gdb_6_2-e500-branch:1.9.0.10
	jimb-gdb_6_2-e500-branchpoint:1.9
	gdb_6_2-20040730-release:1.9
	gdb_6_2-branch:1.9.0.6
	gdb_6_2-2004-07-10-gmt-branchpoint:1.9
	gdb_6_1_1-20040616-release:1.8.6.1
	gdb_6_1-2004-04-05-release:1.8.6.1
	drow_intercu-merge-20040402:1.9
	drow_intercu-merge-20040327:1.9
	ezannoni_pie-20040323-branch:1.9.0.4
	ezannoni_pie-20040323-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.2
	cagney_tramp-20040321-mergepoint:1.9
	cagney_tramp-20040309-branch:1.8.0.8
	cagney_tramp-20040309-branchpoint:1.8
	gdb_6_1-branch:1.8.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.8
	drow_intercu-20040221-branch:1.8.0.4
	drow_intercu-20040221-branchpoint:1.8
	cagney_bfdfile-20040213-branch:1.8.0.2
	cagney_bfdfile-20040213-branchpoint:1.8
	drow-cplus-branch:1.7.0.2
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-branch:1.1.0.4
	carlton_dictionary-20040126-merge:1.1
	cagney_bigcore-20040122-branch:1.1.0.2
	cagney_bigcore-20040122-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.36
date	2013.02.03.16.16.41;	author jkratoch;	state Exp;
branches;
next	1.35;

1.35
date	2013.02.03.16.05.08;	author jkratoch;	state Exp;
branches;
next	1.34;

1.34
date	2013.01.01.06.41.30;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2012.03.01.21.08.07;	author palves;	state Exp;
branches;
next	1.32;

1.32
date	2012.01.04.08.27.58;	author brobecke;	state Exp;
branches;
next	1.31;

1.31
date	2011.01.06.00.57.05;	author msnyder;	state Exp;
branches
	1.31.4.1;
next	1.30;

1.30
date	2011.01.01.15.33.52;	author brobecke;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.17.22.21.43;	author msnyder;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.01.07.32.07;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.02.17.17.42;	author uweigand;	state Exp;
branches;
next	1.26;

1.26
date	2009.02.21.16.14.50;	author palves;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.03.05.58.08;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.01.22.53.22;	author drow;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.13.17.00.11;	author bauermann;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.23.18.08.50;	author brobecke;	state Exp;
branches;
next	1.21;

1.21
date	2007.08.15.00.19.44;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2007.08.14.23.50.39;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.14.21.39.22;	author msnyder;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.14.21.20.09;	author msnyder;	state Exp;
branches;
next	1.17;

1.17
date	2007.08.14.20.23.29;	author msnyder;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.01.20.15.36;	author msnyder;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.28.01.16.39;	author msnyder;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.09.17.59.14;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.14.19.05.40;	author aoliva;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.14.18.45.14;	author aoliva;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.23.19.10.02;	author eliz;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.01.17.40.25;	author ams;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.13.14.14.01;	author ciceron;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2004.02.10.19.08.15;	author cagney;	state Exp;
branches
	1.8.4.1
	1.8.6.1
	1.8.8.1;
next	1.7;

1.7
date	2004.02.08.00.05.16;	author cagney;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2004.02.07.20.57.02;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.07.17.46.14;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.07.16.31.21;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.07.04.40.36;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.06.23.55.34;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.19.04.31.50;	author cagney;	state Exp;
branches
	1.1.4.1;
next	;

1.31.4.1
date	2012.01.06.04.54.35;	author brobecke;	state Exp;
branches;
next	;

1.9.2.1
date	2004.03.23.20.09.16;	author ezannoni;	state Exp;
branches;
next	;

1.8.4.1
date	2004.03.27.17.38.05;	author drow;	state Exp;
branches;
next	;

1.8.6.1
date	2004.03.13.14.21.00;	author ciceron;	state Exp;
branches;
next	;

1.8.8.1
date	2004.03.21.23.57.42;	author cagney;	state Exp;
branches;
next	;

1.7.2.1
date	2004.02.09.19.43.56;	author drow;	state Exp;
branches;
next	;

1.1.4.1
date	2004.01.26.19.11.45;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.36
log
@gdb/
	* source.c (print_source_lines_base): Print for TUI also "fullname".
	* tui/tui-data.c (init_content_element): Change tui_locator_element
	field to full_name.
	* tui/tui-data.h (struct tui_locator_element): Likewise.
	* tui/tui-disasm.c (tui_show_disassem_and_update_source): Rename
	tui_update_locator_filename calls to tui_update_locator_fullname.
	Replace symtab->filename refererence by symtab_to_fullname call.
	* tui/tui-out.c (tui_field_string): Check for "fullname" now.
	* tui/tui-source.c (tui_set_source_content): Change tui_locator_element
	field to full_name.  Replace symtab->filename refererence by
	symtab_to_fullname call.
	(tui_show_symtab_source): Rename parameter to fullname.  Change
	tui_locator_element field to full_name.
	* tui/tui-stack.c: Include source.h.
	(tui_set_locator_filename): Rename the declaration to ...
	(tui_set_locator_fullname): ... here.  Rename its parameter to
	fullname, updates its comment.
	(tui_set_locator_info): Rename its parameter to fullname.
	(tui_set_locator_filename): Rename the definition to ...
	(tui_set_locator_fullname): ... here.  Rename its parameter to
	fullname, updates its comment.  Change tui_locator_element field to
	full_name.
	(tui_set_locator_info): Rename its parameter to fullname.
	(tui_set_locator_info): Rename callee to tui_set_locator_fullname.
	(tui_update_locator_filename): Rename to ...
	(tui_update_locator_fullname): ... here. Rename callee to
	tui_set_locator_fullname.
	(tui_show_frame_info): Replace symtab->filename refererence by
	symtab_to_fullname call.
	* tui/tui-stack.h (tui_update_locator_filename): Rename to ...
	(tui_update_locator_fullname): ... here.
	* tui/tui-winsource.c (tui_display_main): Rename the callee to
	tui_update_locator_fullname.  Replace symtab->filename refererence by
	symtab_to_fullname call.
	* tui/tui.c (tui_show_source): Rename its parameter to fullname.
	Rename the callee to tui_update_locator_fullname.
	* tui/tui.h (tui_show_source): Rename its parameter to fullname.
@
text
@/* TUI data manipulation routines.

   Copyright (C) 1998-2013 Free Software Foundation, Inc.

   Contributed by Hewlett-Packard Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "symtab.h"
#include "tui/tui.h"
#include "tui/tui-data.h"
#include "tui/tui-wingeneral.h"

#include "gdb_string.h"
#include "gdb_curses.h"

/****************************
** GLOBAL DECLARATIONS
****************************/
struct tui_win_info *(tui_win_list[MAX_MAJOR_WINDOWS]);

/***************************
** Private data
****************************/
static enum tui_layout_type current_layout = UNDEFINED_LAYOUT;
static int term_height, term_width;
static struct tui_gen_win_info _locator;
static struct tui_gen_win_info exec_info[2];
static struct tui_win_info *src_win_list[2];
static struct tui_list source_windows = {src_win_list, 0};
static int default_tab_len = DEFAULT_TAB_LEN;
static struct tui_win_info *win_with_focus = (struct tui_win_info *) NULL;
static struct tui_layout_def layout_def = {
  SRC_WIN,			/* DISPLAY_MODE */
  FALSE,			/* SPLIT */
  TUI_UNDEFINED_REGS,		/* REGS_DISPLAY_TYPE */
  TUI_SFLOAT_REGS};		/* FLOAT_REGS_DISPLAY_TYPE */

static int win_resized = FALSE;


/*********************************
** Static function forward decls
**********************************/
static void free_content (tui_win_content, 
			  int, 
			  enum tui_win_type);
static void free_content_elements (tui_win_content, 
				   int, 
				   enum tui_win_type);



/*********************************
** PUBLIC FUNCTIONS
**********************************/

int
tui_win_is_source_type (enum tui_win_type win_type)
{
  return (win_type == SRC_WIN || win_type == DISASSEM_WIN);
}

int
tui_win_is_auxillary (enum tui_win_type win_type)
{
  return (win_type > MAX_MAJOR_WINDOWS);
}

int
tui_win_has_locator (struct tui_win_info *win_info)
{
  return (win_info != NULL 
	  && win_info->detail.source_info.has_locator);
}

void
tui_set_win_highlight (struct tui_win_info *win_info, 
		       int highlight)
{
  if (win_info != NULL)
    win_info->is_highlighted = highlight;
}

/******************************************
** ACCESSORS & MUTATORS FOR PRIVATE DATA
******************************************/

/* Answer a whether the terminal window has been resized or not.  */
int
tui_win_resized (void)
{
  return win_resized;
}


/* Set a whether the terminal window has been resized or not.  */
void
tui_set_win_resized_to (int resized)
{
  win_resized = resized;
}


/* Answer a pointer to the current layout definition.  */
struct tui_layout_def *
tui_layout_def (void)
{
  return &layout_def;
}


/* Answer the window with the logical focus.  */
struct tui_win_info *
tui_win_with_focus (void)
{
  return win_with_focus;
}


/* Set the window that has the logical focus.  */
void
tui_set_win_with_focus (struct tui_win_info *win_info)
{
  win_with_focus = win_info;
}


/* Answer the length in chars, of tabs.  */
int
tui_default_tab_len (void)
{
  return default_tab_len;
}


/* Set the length in chars, of tabs.  */
void
tui_set_default_tab_len (int len)
{
  default_tab_len = len;
}


/* Accessor for the current source window.  Usually there is only one
   source window (either source or disassembly), but both can be
   displayed at the same time.  */
struct tui_list *
tui_source_windows (void)
{
  return &source_windows;
}


/* Clear the list of source windows.  Usually there is only one source
   window (either source or disassembly), but both can be displayed at
   the same time.  */
void
tui_clear_source_windows (void)
{
  source_windows.list[0] = NULL;
  source_windows.list[1] = NULL;
  source_windows.count = 0;
}


/* Clear the pertinant detail in the source windows.  */
void
tui_clear_source_windows_detail (void)
{
  int i;

  for (i = 0; i < (tui_source_windows ())->count; i++)
    tui_clear_win_detail ((tui_source_windows ())->list[i]);
}


/* Add a window to the list of source windows.  Usually there is only
   one source window (either source or disassembly), but both can be
   displayed at the same time.  */
void
tui_add_to_source_windows (struct tui_win_info *win_info)
{
  if (source_windows.count < 2)
    source_windows.list[source_windows.count++] = (void *) win_info;
}


/* Clear the pertinant detail in the windows.  */
void
tui_clear_win_detail (struct tui_win_info *win_info)
{
  if (win_info != NULL)
    {
      switch (win_info->generic.type)
	{
	case SRC_WIN:
	case DISASSEM_WIN:
	  win_info->detail.source_info.gdbarch = NULL;
	  win_info->detail.source_info.start_line_or_addr.loa = LOA_ADDRESS;
	  win_info->detail.source_info.start_line_or_addr.u.addr = 0;
	  win_info->detail.source_info.horizontal_offset = 0;
	  break;
	case CMD_WIN:
	  win_info->detail.command_info.cur_line =
	    win_info->detail.command_info.curch = 0;
	  break;
	case DATA_WIN:
	  win_info->detail.data_display_info.data_content =
	    (tui_win_content) NULL;
	  win_info->detail.data_display_info.data_content_count = 0;
	  win_info->detail.data_display_info.regs_content =
	    (tui_win_content) NULL;
	  win_info->detail.data_display_info.regs_content_count = 0;
	  win_info->detail.data_display_info.regs_display_type =
	    TUI_UNDEFINED_REGS;
	  win_info->detail.data_display_info.regs_column_count = 1;
	  win_info->detail.data_display_info.display_regs = FALSE;
	  break;
	default:
	  break;
	}
    }
}


/* Accessor for the source execution info ptr.  */
struct tui_gen_win_info *
tui_source_exec_info_win_ptr (void)
{
  return &exec_info[0];
}


/* Accessor for the disassem execution info ptr.  */
struct tui_gen_win_info *
tui_disassem_exec_info_win_ptr (void)
{
  return &exec_info[1];
}


/* Accessor for the locator win info.  Answers a pointer to the static
   locator win info struct.  */
struct tui_gen_win_info *
tui_locator_win_info_ptr (void)
{
  return &_locator;
}


/* Accessor for the term_height.  */
int
tui_term_height (void)
{
  return term_height;
}


/* Mutator for the term height.  */
void
tui_set_term_height_to (int h)
{
  term_height = h;
}


/* Accessor for the term_width.  */
int
tui_term_width (void)
{
  return term_width;
}


/* Mutator for the term_width.  */
void
tui_set_term_width_to (int w)
{
  term_width = w;
}


/* Accessor for the current layout.  */
enum tui_layout_type
tui_current_layout (void)
{
  return current_layout;
}


/* Mutator for the current layout.  */
void
tui_set_current_layout_to (enum tui_layout_type new_layout)
{
  current_layout = new_layout;
}


/*****************************
** OTHER PUBLIC FUNCTIONS
*****************************/


/* Answer the next window in the list, cycling back to the top if
   necessary.  */
struct tui_win_info *
tui_next_win (struct tui_win_info *cur_win)
{
  enum tui_win_type type = cur_win->generic.type;
  struct tui_win_info *next_win = (struct tui_win_info *) NULL;

  if (cur_win->generic.type == CMD_WIN)
    type = SRC_WIN;
  else
    type = cur_win->generic.type + 1;
  while (type != cur_win->generic.type && (next_win == NULL))
    {
      if (tui_win_list[type]
	  && tui_win_list[type]->generic.is_visible)
	next_win = tui_win_list[type];
      else
	{
	  if (type == CMD_WIN)
	    type = SRC_WIN;
	  else
	    type++;
	}
    }

  return next_win;
}


/* Answer the prev window in the list, cycling back to the bottom if
   necessary.  */
struct tui_win_info *
tui_prev_win (struct tui_win_info *cur_win)
{
  enum tui_win_type type = cur_win->generic.type;
  struct tui_win_info *prev = (struct tui_win_info *) NULL;

  if (cur_win->generic.type == SRC_WIN)
    type = CMD_WIN;
  else
    type = cur_win->generic.type - 1;
  while (type != cur_win->generic.type && (prev == NULL))
    {
      if (tui_win_list[type]
	  && tui_win_list[type]->generic.is_visible)
	prev = tui_win_list[type];
      else
	{
	  if (type == SRC_WIN)
	    type = CMD_WIN;
	  else
	    type--;
	}
    }

  return prev;
}


/* Answer the window represented by name.  */
struct tui_win_info *
tui_partial_win_by_name (char *name)
{
  struct tui_win_info *win_info = (struct tui_win_info *) NULL;

  if (name != (char *) NULL)
    {
      int i = 0;

      while (i < MAX_MAJOR_WINDOWS && win_info == NULL)
	{
          if (tui_win_list[i] != 0)
            {
              char *cur_name = tui_win_name (&tui_win_list[i]->generic);

              if (strlen (name) <= strlen (cur_name)
		  && strncmp (name, cur_name, strlen (name)) == 0)
                win_info = tui_win_list[i];
            }
	  i++;
	}
    }

  return win_info;
}


/* Answer the name of the window.  */
char *
tui_win_name (struct tui_gen_win_info *win_info)
{
  char *name = (char *) NULL;

  switch (win_info->type)
    {
    case SRC_WIN:
      name = SRC_NAME;
      break;
    case CMD_WIN:
      name = CMD_NAME;
      break;
    case DISASSEM_WIN:
      name = DISASSEM_NAME;
      break;
    case DATA_WIN:
      name = DATA_NAME;
      break;
    default:
      name = "";
      break;
    }

  return name;
}


void
tui_initialize_static_data (void)
{
  tui_init_generic_part (tui_source_exec_info_win_ptr ());
  tui_init_generic_part (tui_disassem_exec_info_win_ptr ());
  tui_init_generic_part (tui_locator_win_info_ptr ());
}


struct tui_gen_win_info *
tui_alloc_generic_win_info (void)
{
  struct tui_gen_win_info *win;

  if ((win = XMALLOC (struct tui_gen_win_info)) != NULL)
    tui_init_generic_part (win);

  return win;
}


void
tui_init_generic_part (struct tui_gen_win_info *win)
{
  win->width =
    win->height =
    win->origin.x =
    win->origin.y =
    win->viewport_height =
    win->content_size =
    win->last_visible_line = 0;
  win->handle = (WINDOW *) NULL;
  win->content = NULL;
  win->content_in_use =
    win->is_visible = FALSE;
  win->title = 0;
}


/* init_content_element().
 */
static void
init_content_element (struct tui_win_element *element, 
		      enum tui_win_type type)
{
  element->highlight = FALSE;
  switch (type)
    {
    case SRC_WIN:
    case DISASSEM_WIN:
      element->which_element.source.line = (char *) NULL;
      element->which_element.source.line_or_addr.loa = LOA_LINE;
      element->which_element.source.line_or_addr.u.line_no = 0;
      element->which_element.source.is_exec_point = FALSE;
      element->which_element.source.has_break = FALSE;
      break;
    case DATA_WIN:
      tui_init_generic_part (&element->which_element.data_window);
      element->which_element.data_window.type = DATA_ITEM_WIN;
      ((struct tui_gen_win_info *)
       &element->which_element.data_window)->content =
	(void **) tui_alloc_content (1, DATA_ITEM_WIN);
      ((struct tui_gen_win_info *)
       & element->which_element.data_window)->content_size = 1;
      break;
    case CMD_WIN:
      element->which_element.command.line = (char *) NULL;
      break;
    case DATA_ITEM_WIN:
      element->which_element.data.name = (char *) NULL;
      element->which_element.data.type = TUI_REGISTER;
      element->which_element.data.item_no = UNDEFINED_ITEM;
      element->which_element.data.value = NULL;
      element->which_element.data.highlight = FALSE;
      element->which_element.data.content = (char*) NULL;
      break;
    case LOCATOR_WIN:
      element->which_element.locator.full_name[0] =
	element->which_element.locator.proc_name[0] = (char) 0;
      element->which_element.locator.line_no = 0;
      element->which_element.locator.addr = 0;
      break;
    case EXEC_INFO_WIN:
      memset(element->which_element.simple_string, ' ',
             sizeof(element->which_element.simple_string));
      break;
    default:
      break;
    }
}

static void
init_win_info (struct tui_win_info *win_info)
{
  tui_init_generic_part (&win_info->generic);
  win_info->can_highlight =
    win_info->is_highlighted = FALSE;
  switch (win_info->generic.type)
    {
    case SRC_WIN:
    case DISASSEM_WIN:
      win_info->detail.source_info.execution_info
	= (struct tui_gen_win_info *) NULL;
      win_info->detail.source_info.has_locator = FALSE;
      win_info->detail.source_info.horizontal_offset = 0;
      win_info->detail.source_info.gdbarch = NULL;
      win_info->detail.source_info.start_line_or_addr.loa = LOA_ADDRESS;
      win_info->detail.source_info.start_line_or_addr.u.addr = 0;
      win_info->detail.source_info.fullname = NULL;
      break;
    case DATA_WIN:
      win_info->detail.data_display_info.data_content = (tui_win_content) NULL;
      win_info->detail.data_display_info.data_content_count = 0;
      win_info->detail.data_display_info.regs_content = (tui_win_content) NULL;
      win_info->detail.data_display_info.regs_content_count = 0;
      win_info->detail.data_display_info.regs_display_type =
	TUI_UNDEFINED_REGS;
      win_info->detail.data_display_info.regs_column_count = 1;
      win_info->detail.data_display_info.display_regs = FALSE;
      win_info->detail.data_display_info.current_group = 0;
      break;
    case CMD_WIN:
      win_info->detail.command_info.cur_line = 0;
      win_info->detail.command_info.curch = 0;
      break;
    default:
      win_info->detail.opaque = NULL;
      break;
    }
}


struct tui_win_info *
tui_alloc_win_info (enum tui_win_type type)
{
  struct tui_win_info *win_info;

  win_info = XMALLOC (struct tui_win_info);
  if (win_info != NULL)
    {
      win_info->generic.type = type;
      init_win_info (win_info);
    }

  return win_info;
}


/* Allocates the content and elements in a block.  */
tui_win_content
tui_alloc_content (int num_elements, enum tui_win_type type)
{
  tui_win_content content;
  char *element_block_ptr;
  int i;

  content = xmalloc (sizeof (struct tui_win_element *) *num_elements);
  if (content != NULL)
    {
      /*
       * All windows, except the data window, can allocate the
       * elements in a chunk.  The data window cannot because items
       * can be added/removed from the data display by the user at any
       * time.
       */
      if (type != DATA_WIN)
	{
	  element_block_ptr =
	    xmalloc (sizeof (struct tui_win_element) * num_elements);
	  if (element_block_ptr != NULL)
	    {
	      for (i = 0; i < num_elements; i++)
		{
		  content[i] = (struct tui_win_element *) element_block_ptr;
		  init_content_element (content[i], type);
		  element_block_ptr += sizeof (struct tui_win_element);
		}
	    }
	  else
	    {
	      xfree (content);
	      content = (tui_win_content) NULL;
	    }
	}
    }

  return content;
}


/* Adds the input number of elements to the windows's content.  If no
   content has been allocated yet, alloc_content() is called to do
   this.  The index of the first element added is returned, unless
   there is a memory allocation error, in which case, (-1) is
   returned.  */
int
tui_add_content_elements (struct tui_gen_win_info *win_info, 
			  int num_elements)
{
  struct tui_win_element *element_ptr;
  int i, index_start;

  if (win_info->content == NULL)
    {
      win_info->content = (void **) tui_alloc_content (num_elements,
						       win_info->type);
      index_start = 0;
    }
  else
    index_start = win_info->content_size;
  if (win_info->content != NULL)
    {
      for (i = index_start; (i < num_elements + index_start); i++)
	{
	  if ((element_ptr = XMALLOC (struct tui_win_element)) != NULL)
	    {
	      win_info->content[i] = (void *) element_ptr;
	      init_content_element (element_ptr, win_info->type);
	      win_info->content_size++;
	    }
	  else	/* Things must be really hosed now!  We ran out of
		   memory!?  */
	    return (-1);
	}
    }

  return index_start;
}


/* Delete all curses windows associated with win_info, leaving
   everything else intact.  */
void
tui_del_window (struct tui_win_info *win_info)
{
  struct tui_gen_win_info *generic_win;

  switch (win_info->generic.type)
    {
    case SRC_WIN:
    case DISASSEM_WIN:
      generic_win = tui_locator_win_info_ptr ();
      if (generic_win != (struct tui_gen_win_info *) NULL)
	{
	  tui_delete_win (generic_win->handle);
	  generic_win->handle = (WINDOW *) NULL;
	  generic_win->is_visible = FALSE;
	}
      if (win_info->detail.source_info.fullname)
        {
          xfree (win_info->detail.source_info.fullname);
          win_info->detail.source_info.fullname = NULL;
        }
      generic_win = win_info->detail.source_info.execution_info;
      if (generic_win != (struct tui_gen_win_info *) NULL)
	{
	  tui_delete_win (generic_win->handle);
	  generic_win->handle = (WINDOW *) NULL;
	  generic_win->is_visible = FALSE;
	}
      break;
    case DATA_WIN:
      if (win_info->generic.content != NULL)
	{
	  tui_del_data_windows (win_info->detail.data_display_info.regs_content,
				win_info->detail.data_display_info.regs_content_count);
	  tui_del_data_windows (win_info->detail.data_display_info.data_content,
				win_info->detail.data_display_info.data_content_count);
	}
      break;
    default:
      break;
    }
  if (win_info->generic.handle != (WINDOW *) NULL)
    {
      tui_delete_win (win_info->generic.handle);
      win_info->generic.handle = (WINDOW *) NULL;
      win_info->generic.is_visible = FALSE;
    }
}


void
tui_free_window (struct tui_win_info *win_info)
{
  struct tui_gen_win_info *generic_win;

  switch (win_info->generic.type)
    {
    case SRC_WIN:
    case DISASSEM_WIN:
      generic_win = tui_locator_win_info_ptr ();
      if (generic_win != (struct tui_gen_win_info *) NULL)
	{
	  tui_delete_win (generic_win->handle);
	  generic_win->handle = (WINDOW *) NULL;
	}
      tui_free_win_content (generic_win);
      if (win_info->detail.source_info.fullname)
        {
          xfree (win_info->detail.source_info.fullname);
          win_info->detail.source_info.fullname = NULL;
        }
      generic_win = win_info->detail.source_info.execution_info;
      if (generic_win != (struct tui_gen_win_info *) NULL)
	{
	  tui_delete_win (generic_win->handle);
	  generic_win->handle = (WINDOW *) NULL;
	  tui_free_win_content (generic_win);
	}
      break;
    case DATA_WIN:
      if (win_info->generic.content != NULL)
	{
	  tui_free_data_content (win_info->detail.data_display_info.regs_content,
				 win_info->detail.data_display_info.regs_content_count);
	  win_info->detail.data_display_info.regs_content =
	    (tui_win_content) NULL;
	  win_info->detail.data_display_info.regs_content_count = 0;
	  tui_free_data_content (win_info->detail.data_display_info.data_content,
				 win_info->detail.data_display_info.data_content_count);
	  win_info->detail.data_display_info.data_content =
	    (tui_win_content) NULL;
	  win_info->detail.data_display_info.data_content_count = 0;
	  win_info->detail.data_display_info.regs_display_type =
	    TUI_UNDEFINED_REGS;
	  win_info->detail.data_display_info.regs_column_count = 1;
	  win_info->detail.data_display_info.display_regs = FALSE;
	  win_info->generic.content = NULL;
	  win_info->generic.content_size = 0;
	}
      break;
    default:
      break;
    }
  if (win_info->generic.handle != (WINDOW *) NULL)
    {
      tui_delete_win (win_info->generic.handle);
      win_info->generic.handle = (WINDOW *) NULL;
      tui_free_win_content (&win_info->generic);
    }
  if (win_info->generic.title)
    xfree (win_info->generic.title);
  xfree (win_info);
}


void
tui_free_all_source_wins_content (void)
{
  int i;

  for (i = 0; i < (tui_source_windows ())->count; i++)
    {
      struct tui_win_info *win_info = (tui_source_windows ())->list[i];

      if (win_info != NULL)
	{
	  tui_free_win_content (&(win_info->generic));
	  tui_free_win_content (win_info->detail.source_info.execution_info);
	}
    }
}


void
tui_free_win_content (struct tui_gen_win_info *win_info)
{
  if (win_info->content != NULL)
    {
      free_content ((tui_win_content) win_info->content,
		   win_info->content_size,
		   win_info->type);
      win_info->content = NULL;
    }
  win_info->content_size = 0;
}


void
tui_del_data_windows (tui_win_content content, 
		      int content_size)
{
  int i;

  /* Remember that data window content elements are of type struct
     tui_gen_win_info *, each of which whose single element is a data
     element.  */
  for (i = 0; i < content_size; i++)
    {
      struct tui_gen_win_info *generic_win
	= &content[i]->which_element.data_window;

      if (generic_win != (struct tui_gen_win_info *) NULL)
	{
	  tui_delete_win (generic_win->handle);
	  generic_win->handle = (WINDOW *) NULL;
	  generic_win->is_visible = FALSE;
	}
    }
}


void
tui_free_data_content (tui_win_content content, 
		       int content_size)
{
  int i;

  /* Remember that data window content elements are of type struct
     tui_gen_win_info *, each of which whose single element is a data
     element.  */
  for (i = 0; i < content_size; i++)
    {
      struct tui_gen_win_info *generic_win
	= &content[i]->which_element.data_window;

      if (generic_win != (struct tui_gen_win_info *) NULL)
	{
	  tui_delete_win (generic_win->handle);
	  generic_win->handle = (WINDOW *) NULL;
	  tui_free_win_content (generic_win);
	}
    }
  free_content (content,
		content_size,
		DATA_WIN);
}


/**********************************
** LOCAL STATIC FUNCTIONS        **
**********************************/


static void
free_content (tui_win_content content, 
	      int content_size, 
	      enum tui_win_type win_type)
{
  if (content != (tui_win_content) NULL)
    {
      free_content_elements (content, content_size, win_type);
      xfree (content);
    }
}


/* free_content_elements().
 */
static void
free_content_elements (tui_win_content content, 
		       int content_size, 
		       enum tui_win_type type)
{
  if (content != (tui_win_content) NULL)
    {
      int i;

      if (type == SRC_WIN || type == DISASSEM_WIN)
	{
	  /* Free whole source block.  */
	  xfree (content[0]->which_element.source.line);
	}
      else
	{
	  for (i = 0; i < content_size; i++)
	    {
	      struct tui_win_element *element;

	      element = content[i];
	      if (element != (struct tui_win_element *) NULL)
		{
		  switch (type)
		    {
		    case DATA_WIN:
		      xfree (element);
		      break;
		    case DATA_ITEM_WIN:
		      /* Note that data elements are not allocated in
		         a single block, but individually, as
		         needed.  */
		      if (element->which_element.data.type != TUI_REGISTER)
			xfree ((void *)element->which_element.data.name);
		      xfree (element->which_element.data.value);
                      xfree (element->which_element.data.content);
		      xfree (element);
		      break;
		    case CMD_WIN:
		      xfree (element->which_element.command.line);
		      break;
		    default:
		      break;
		    }
		}
	    }
	}
      if (type != DATA_WIN && type != DATA_ITEM_WIN)
	xfree (content[0]);	/* Free the element block.  */
    }
}
@


1.35
log
@gdb/
	* tui/tui-data.c (init_win_info, tui_del_window, tui_free_window):
	Rename field reference filename to fullname.
	* tui/tui-data.h (struct tui_source_info): Rename field filename to
	fullname.  New comment for it.
	* tui/tui-source.c (tui_set_source_content): Rename field reference
	filename to fullname.  Initialize field by symtab_to_fullname now.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Rename field
	reference filename to fullname.  Use symtab_to_fullname during
	comparison.
@
text
@d513 1
a513 1
      element->which_element.locator.file_name[0] =
@


1.34
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d544 1
a544 1
      win_info->detail.source_info.filename = 0;
d684 1
a684 1
      if (win_info->detail.source_info.filename)
d686 2
a687 2
          xfree (win_info->detail.source_info.filename);
          win_info->detail.source_info.filename = 0;
d734 1
a734 1
      if (win_info->detail.source_info.filename)
d736 2
a737 2
          xfree (win_info->detail.source_info.filename);
          win_info->detail.source_info.filename = 0;
@


1.33
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* tui/tui-data.c (set_gen_win_origin): Delete.
	* tui/tui-data.h (tui_set_gen_win_origin): Delete declaration.
	* tui/tui-regs.c (tui_last_reg_element_no_in_line): Delete.
@
text
@d3 1
a3 1
   Copyright (C) 1998-2004, 2006-2012 Free Software Foundation, Inc.
@


1.32
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a313 10
/* Set the origin of the window.  */
void
set_gen_win_origin (struct tui_gen_win_info *win_info, 
		    int x, int y)
{
  win_info->origin.x = x;
  win_info->origin.y = y;
}


@


1.31
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-cmds.c: Shorten lines of >= 80 columns.
	* cli/cli-decode.c: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-setshow.c: Ditto.
	* common/signals.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-disas.c: Ditto.
	* mi/mi-cmd-stack.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-cmds.c: Ditto.
	* mi/mi-common.h: Ditto.
	* mi/mi-console.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
	* osf-share/cma_attr.c: Ditto.
	* osf-share/cma_deb_core.h: Ditto.
	* osf-share/cma_debug_client.h: Ditto.
	* osf-share/cma_handle.h: Ditto.
	* osf-share/cma_mutex.h: Ditto.
	* osf-share/cma_stack_int.h: Ditto.
	* osf-share/cma_tcb_defs.h: Ditto.
	* python/py-auto-load.c: Ditto.
	* python/py-breakpoint.c: Ditto.
	* python/py-cmd.c: Ditto.
	* python/py-frame.c: Ditto.
	* python/py-objfile.c: Ditto.
	* python/py-param.c: Ditto.
	* python/py-progspace.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-value.c: Ditto.
	* python/python-internal.h: Ditto.
	* python/python.c: Ditto.
	* tui/tui-data.c: Ditto.
	* tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c: Ditto.
	* tui/tui-io.c: Ditto.
	* tui/tui-layout.c: Ditto.
	* tui/tui-regs.c: Ditto.
	* tui/tui-source.c: Ditto.
	* tui/tui-stack.c: Ditto.
	* tui/tui-win.c: Ditto.
	* tui/tui-windata.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d3 1
a3 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007, 2008,
   2009, 2010, 2011 Free Software Foundation, Inc.
@


1.31.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1998-2004, 2006-2012 Free Software Foundation, Inc.
@


1.30
log
@run copyright.sh for 2011.
@
text
@d506 2
a507 1
      ((struct tui_gen_win_info *) & element->which_element.data_window)->content =
d548 2
a549 1
      win_info->detail.source_info.execution_info = (struct tui_gen_win_info *) NULL;
d651 2
a652 1
      win_info->content = (void **) tui_alloc_content (num_elements, win_info->type);
d837 2
a838 1
      struct tui_gen_win_info *generic_win = &content[i]->which_element.data_window;
d861 2
a862 1
      struct tui_gen_win_info *generic_win = &content[i]->which_element.data_window;
@


1.29
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* tui/tui.c: White space.
	* tui/tui-data.c: White space.
	* tui/tui-disasm.c: White space.
	* tui/tui-file.c: White space.
	* tui/tui-interp.c: White space.
	* tui/tui-main.c: White space.
	* tui/tui-out.c: White space.
	* tui/tui-regs.c: White space.
	* tui/tui-source.c: White space.
	* tui/tui-stack.c: White space.
	* tui/tui-win.c: White space.
	* tui/tui-winsource.c: White space.
@
text
@d4 1
a4 1
   2009, 2010 Free Software Foundation, Inc.
@


1.28
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d405 1
@


1.27
log
@	* disasm.h (gdb_disassembly): Add GDBARCH parameter.
	(gdb_print_insn): Likewise.
	* disasm.c (dump_insns): Add GDBARCH parameter.  Use it instead
	of current_gdbarch.
	(do_mixed_source_and_assembly): Add GDBARCH parameter.  Pass to
	dump_insns.
	(do_assembly_only): Likewise.
	(gdb_disassembly): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.  Pass to subroutines.
	(gdb_print_insn): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.

	* stack.c (struct gdb_disassembly_stub_args): Add GDBARCH member.
	(gdb_disassembly_stub): Pass architecture to gdb_disassembly.
	(do_gdb_disassembly): Add GDBARCH argument.  Store into args.
	(print_frame_info): Pass architecture to do_gdb_disassembly.

	* printcmd.c (print_formatted): Pass architecture to gdb_print_insn.

	* mi/mi-cmd-disas.c: Include "arch-utils.h"
	(mi_cmd_disassemble): Pass architecture to gdb_disassembly.

	* cli/cli-cmds.c: Include "arch-utils.h".
	(print_disassembly): Add GDBARCH parameter.  Pass to gdb_disassembly
	and tui_show_assembly.
	(disassemble_current_function): Pass architecture to
	tui_get_low_disassembly_address and print_disassembly.
	(disassemble_command): Pass architecture to
	tui_get_low_disassembly_address and print_disassembly.

	* tui/tui.c (tui_show_assembly): Add GDBARCH parameter.  Pass to
	tui_update_source_windows_with_addr.

	* tui/tui-data.h (struct tui_locator_element): Add GDBARCH member.
	(struct tui_source_info): Likewise.
	* tui/tui-data.c (tui_clear_win_detail): Clear source_info.gdbarch.

	* tui/tui-disasm.c (tui_disassemble): Add GDBARCH parameter.
	Pass to gdb_print_insn.
	(tui_find_disassembly_address): Add GDBARCH parameter.  Pass to
	tui_disassemble.
	(tui_set_disassem_content): Add GDBARCH parameter.  Install into
	source_info.gdbarch.  Pass to tui_disassemble.
	(tui_show_disassem): Add GDBARCH parameter.  Pass to
	tui_update_source_window.
	(tui_show_disassem_and_update_source): Add GDBARCH parameter.  Pass to
	tui_show_disassem and tui_update_source_window.

	(tui_get_begin_asm_address): Return locator architecture in addition
	to locator PC value.

	(tui_get_low_disassembly_address): Add GDBARCH parameter.   Pass to
	tui_get_low_disassembly_address.

	(tui_vertical_disassem_scroll): Pass architecture to subroutines.

	* tui/tui-disasm.h (tui_set_disassem_content): Add GDBARCH parameter.
	(tui_show_disassem): Likewise.
	(tui_show_disassem_and_update_source): Likewise.
	(tui_get_begin_asm_address): Return architecture and PC value.

	* tui/tui.h (tui_get_low_disassembly_address): Add GDBARCH parameter.
	(tui_show_assembly): Add GDBARCH parameter.

	* tui/tui-layout.c (extract_display_start_addr): Return current window
	architecture in addition to current PC value.

	(tui_set_layout): Update calls to tui_get_low_disassembly_address and
	extract_display_start_addr.  Pass architecture to
	tui_update_source_windows_with_addr.

	* tui/tui-source.c: Include "objfiles.h".
	(tui_set_source_content): Initialize window architecture.
	(tui_show_symtab_source): Add GDBARCH parameter.  Pass to
	tui_update_source_window_as_is

	* tui/tui-source.h (tui_show_symtab_source): Add GDBARCH parameter.

	* tui/tui-stack.c (tui_set_locator_info): Add GDBARCH parameter.
	Install locator architecture.
	(tui_set_locator_filename): Update call.
	(tui_show_frame_info): Pass architecture to tui_set_locator_info
	and subroutines.

	* tui/tui-win.c (make_visible_with_new_height): Pass architecture
	to tui_update_source_window.

	* tui/tui-winsource.c: Include "objfiles.h".
	(tui_display_main): Update call to tui_get_begin_asm_address.
	Pass architecture to tui_update_source_windows_with_addr.
	(tui_update_source_window): Add GDBARCH parameter.  Pass to
	tui_update_source_window_as_is.
	(tui_update_source_window_as_is): Add GDBARCH parameter.
	Pass to tui_set_disassem_content.
	(tui_update_source_windows_with_addr): Add GDBARCH parameter.
	Pass to subroutines.
	(tui_update_source_windows_with_line): Pass objfile architecture
	to subroutines.
	(tui_horizontal_source_scroll): Pass architecture to
	tui_update_source_window_as_is.

	* tui/tui-winsource.h (tui_update_source_window): Add GDBARCH
	parameter.
	(tui_update_source_window_as_is): Likewise.
	(tui_update_source_windows_with_addr): Likewise.
@
text
@d4 1
a4 1
   2009 Free Software Foundation, Inc.
@


1.26
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d214 1
d549 1
@


1.25
log
@        Updated copyright notices for most files.
@
text
@d486 1
a486 1
void
d535 1
a535 1
void
@


1.24
log
@	Updated copyright notices for most files.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007, 2008
   Free Software Foundation, Inc.
@


1.23
log
@	* tui/tui-data.c (tui_prev_win): Guard against NULL.
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007
@


1.22
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d373 2
a374 1
      if (tui_win_list[type]->generic.is_visible)
@


1.21
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-disasm.c, tui-file.c, tui-io.c,
	tui-layout.c, tui-regs.c, tui-source.c, tui-win.c, tui-windata.c,
	tui-wingeneral.c, tui-winsource.c: Coding standard, && and ||
	go at beginning of new line.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.20
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-data.c, tui-data.h, tui-disasm.c, tui-disasm.h, tui-hooks.c,
	tui-io.c, tui-layout.c, tui-layout.h, tui-out.c, tui-regs.c,
	tui-source.c, tui-source.h, tui-stack.c, tui-win.c, tui-win.h,
	tui-windata.c, tui-windata.h, tui-wingeneral.c, tui-winsource.c,
	tui-winsource.h, tui.c, tui.h: Function declarations and
	definitions, wrap long lines.
@
text
@d345 2
a346 1
      if (tui_win_list[type] && tui_win_list[type]->generic.is_visible)
d405 2
a406 2
              if (strlen (name) <= strlen (cur_name) &&
                  strncmp (name, cur_name, strlen (name)) == 0)
@


1.19
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-disasm.c, tui-layout.c,
	tui-regs.c, tui-win.c, tui-windata.c, tui-winsource.c, tui.c:
	Reformat block comments to GNU standard.
@
text
@d50 6
a55 5
static struct tui_layout_def layout_def =
{SRC_WIN,			/* DISPLAY_MODE */
 FALSE,				/* SPLIT */
 TUI_UNDEFINED_REGS,		/* REGS_DISPLAY_TYPE */
 TUI_SFLOAT_REGS};		/* FLOAT_REGS_DISPLAY_TYPE */
d62 6
a67 2
static void free_content (tui_win_content, int, enum tui_win_type);
static void free_content_elements (tui_win_content, int, enum tui_win_type);
d90 1
a90 1
  return (win_info != NULL \
d95 2
a96 1
tui_set_win_highlight (struct tui_win_info *win_info, int highlight)
d318 2
a319 1
set_gen_win_origin (struct tui_gen_win_info *win_info, int x, int y)
d487 2
a488 1
init_content_element (struct tui_win_element *element, enum tui_win_type type)
d638 2
a639 1
tui_add_content_elements (struct tui_gen_win_info *win_info, int num_elements)
d821 2
a822 1
tui_del_data_windows (tui_win_content content, int content_size)
d844 2
a845 1
tui_free_data_content (tui_win_content content, int content_size)
d864 2
a865 2
	       content_size,
	       DATA_WIN);
d875 3
a877 1
free_content (tui_win_content content, int content_size, enum tui_win_type win_type)
d890 3
a892 1
free_content_elements (tui_win_content content, int content_size, enum tui_win_type type)
@


1.18
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-command.c, tui-data.c, tui-data.h, tui-disasm.c, tui-file.c,
	tui-hooks.c, tui-interp.c, tui-io.c, tui-layout.c, tui-out.c,
	tui-regs.c, tui-regs.h, tui-source.c, tui-stack.c, tui-win.c,
	tui-windata.c, tui-wingeneral.c, tui-winsource.c, tui-winsource.h,
	tui.c, tui.h: Comment reformatting to coding standard (capitals,
	spaces after periods, etc).
@
text
@d477 1
a477 2
/*
   ** init_content_element().
d816 3
a818 5
  /*
     ** Remember that data window content elements are of type 
     ** struct tui_gen_win_info *, each of which whose single 
     ** element is a data element.
   */
d838 3
a840 5
  /*
     ** Remember that data window content elements are of type 
     ** struct tui_gen_win_info *, each of which whose single 
     ** element is a data element.
   */
d874 1
a874 2
/*
   ** free_content_elements().
d903 3
a905 5
		      /*
		         ** Note that data elements are not allocated
		         ** in a single block, but individually, as
			 ** needed.
		       */
@


1.17
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* tui-data.c, tui-data.h, tui-disasm.c, tui-hooks.c, tui-layout.c,
	tui-regs.c, tui-source.c, tui-stack.c, tui-win.c, tui-windata.c,
	tui-wingeneral.c, tui-wingeneral.h, tui-winsource.c, tui.c,
	tui-winsource.h: Whitespace changes, fix pointer declarations
	to be consistant.
@
text
@d100 1
a100 1
/* Answer a whether the terminal window has been resized or not.   */
d108 1
a108 1
/* Set a whether the terminal window has been resized or not.   */
d116 1
a116 1
/* Answer a pointer to the current layout definition.   */
d124 1
a124 1
/* Answer the window with the logical focus.    */
d132 1
a132 1
/* Set the window that has the logical focus.   */
d140 1
a140 1
/* Answer the length in chars, of tabs.    */
d148 1
a148 1
/* Set the length in chars, of tabs.   */
d178 1
a178 1
/* Clear the pertinant detail in the source windows.   */
d200 1
a200 1
/* Clear the pertinant detail in the windows.   */
d270 1
a270 1
/* Mutator for the term height.   */
d278 1
a278 1
/* Accessor for the term_width.   */
d294 1
a294 1
/* Accessor for the current layout.   */
d382 1
a382 1
/* Answer the window represented by name.    */
d653 2
a654 1
	  else	/* Things must be really hosed now!  We ran out of memory!? */
d663 2
a664 2
/* Delete all curses windows associated with win_info, leaving everything
   else intact.  */
d818 3
a820 2
     ** Remember that data window content elements are of type struct tui_gen_win_info *,
     ** each of which whose single element is a data element.
d842 3
a844 2
     ** Remember that data window content elements are of type struct tui_gen_win_info *,
     ** each of which whose single element is a data element.
d891 1
a891 1
	  /* free whole source block */
d911 2
a912 1
		         ** in a single block, but individually, as needed.
d930 1
a930 1
	xfree (content[0]);	/* free the element block */
@


1.16
log
@2007-08-01  Michael Snyder  <msnyder@@access-company.com>

	* tui/tui-data.c (tui_alloc_content): Move assign out of if,
	clean up long lines.
	(tui_alloc_generic_win_info): Tidy by using XMALLOC macro.
	(tui_alloc_win_info): Ditto.
	(tui_add_content_elements): Ditto.
	* tui/tui-file.c (tui_file_magic): Ditto.
@
text
@d46 1
a46 1
static struct tui_win_info * src_win_list[2];
d49 1
a49 1
static struct tui_win_info * win_with_focus = (struct tui_win_info *) NULL;
d134 1
a134 1
tui_set_win_with_focus (struct tui_win_info * win_info)
d193 1
a193 1
tui_add_to_source_windows (struct tui_win_info * win_info)
d202 1
a202 1
tui_clear_win_detail (struct tui_win_info * win_info)
d312 1
a312 1
set_gen_win_origin (struct tui_gen_win_info * win_info, int x, int y)
d327 1
a327 1
tui_next_win (struct tui_win_info * cur_win)
d330 1
a330 1
  struct tui_win_info * next_win = (struct tui_win_info *) NULL;
d356 1
a356 1
tui_prev_win (struct tui_win_info * cur_win)
d359 1
a359 1
  struct tui_win_info * prev = (struct tui_win_info *) NULL;
d386 1
a386 1
  struct tui_win_info * win_info = (struct tui_win_info *) NULL;
d411 1
a411 1
tui_win_name (struct tui_gen_win_info * win_info)
d450 1
a450 1
  struct tui_gen_win_info * win;
d460 1
a460 1
tui_init_generic_part (struct tui_gen_win_info * win)
d481 1
a481 1
init_content_element (struct tui_win_element * element, enum tui_win_type type)
d529 1
a529 1
init_win_info (struct tui_win_info * win_info)
d570 1
a570 1
  struct tui_win_info * win_info;
d591 1
a591 1
  content = xmalloc (sizeof (struct tui_win_element *) * num_elements);
d631 1
a631 1
tui_add_content_elements (struct tui_gen_win_info * win_info, int num_elements)
d633 1
a633 1
  struct tui_win_element * element_ptr;
d665 1
a665 1
tui_del_window (struct tui_win_info * win_info)
d667 1
a667 1
  struct tui_gen_win_info * generic_win;
d715 1
a715 1
tui_free_window (struct tui_win_info * win_info)
d717 1
a717 1
  struct tui_gen_win_info * generic_win;
d786 1
a786 1
      struct tui_win_info * win_info = (tui_source_windows ())->list[i];
d798 1
a798 1
tui_free_win_content (struct tui_gen_win_info * win_info)
d822 1
a822 1
      struct tui_gen_win_info * generic_win = &content[i]->which_element.data_window;
d845 1
a845 1
      struct tui_gen_win_info * generic_win = &content[i]->which_element.data_window;
d895 1
a895 1
	      struct tui_win_element * element;
@


1.15
log
@2007-07-27  Michael Snyder  <msnyder@@access-company.com>

	* tui/tui-data.c (tui_alloc_generic_win_info): Wrong arg for sizeof.
@
text
@d452 1
a452 2
  if ((win = (struct tui_gen_win_info *) xmalloc (
		     sizeof (struct tui_gen_win_info))) != (struct tui_gen_win_info *) NULL)
d570 1
a570 1
  struct tui_win_info * win_info = (struct tui_win_info *) NULL;
d572 2
a573 2
  win_info = (struct tui_win_info *) xmalloc (sizeof (struct tui_win_info));
  if ((win_info != NULL))
d587 2
a588 2
  tui_win_content content = (tui_win_content) NULL;
  char *element_block_ptr = (char *) NULL;
d591 9
a599 7
  if ((content = (tui_win_content)
  xmalloc (sizeof (struct tui_win_element *) * num_elements)) != (tui_win_content) NULL)
    {				/*
				   ** All windows, except the data window, can allocate the elements
				   ** in a chunk.  The data window cannot because items can be
				   ** added/removed from the data display by the user at any time.
				 */
d602 3
a604 2
	  if ((element_block_ptr = (char *)
	   xmalloc (sizeof (struct tui_win_element) * num_elements)) != (char *) NULL)
d647 1
a647 2
	  if ((element_ptr = (struct tui_win_element *)
	       xmalloc (sizeof (struct tui_win_element))) != (struct tui_win_element *) NULL)
d653 1
a653 1
	  else			/* things must be really hosed now! We ran out of memory!? */
@


1.14
log
@Copyright updates for 2007.
@
text
@d453 1
a453 1
		     sizeof (struct tui_gen_win_info *))) != (struct tui_gen_win_info *) NULL)
@


1.13
log
@Update copyright notice
@
text
@d3 1
a3 1
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006
@


1.12
log
@* doublest.h (DOUBLEST): Use long double only if we can scan
it in.  Undefine HAVE_LONG_DOUBLE otherwise.
(DOUBLEST_FORMAT): New.
* c-exp.y (parse_number): Use it.
* jv-exp.y (parse_number): Likewise.
* objc-exp.y (parse_number): Likewise.
* p-exp.y (parse_number): Likewise.
* varobj.c (free_variable): Silence type-punning warnings.
* tui/tui-data.h (struct tui_list): Change type of list member.
* tui/tui-data.c: Remove no-longer-needed type casts.
(source_windows): Silence type-punning warnings.
* tui/tui-stack.c, tui/tui-win.c, tui/tui-winsource.c: Likewise.
@
text
@d3 2
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
@


1.11
log
@	* tui/tui-file.c:
	* tui/tui-disasm.c:
	* tui/tui-data.h:
	* tui/tui-data.c:
	* tui/tui-command.h:
	* tui/tui-command.c:
	* tui/tui-win.h:
	* tui/tui-win.h:
	* tui/tui-win.c:
	* tui/tui-stack.h:
	* tui/tui-stack.c:
	* tui/tui-source.h:
	* tui/tui-source.c:
	* tui/tui-regs.h:
	* tui/tui-regs.c:
	* tui/tui-out.c:
	* tui/tui-main.c:
	* tui/tui-layout.h:
	* tui/tui-layout.c:
	* tui/tui-io.h:
	* tui/tui-io.c:
	* tui/tui-interp.c:
	* tui/tui-hooks.h:
	* tui/tui-hooks.c:
	* tui/tui-file.h:
	* tui/tui.h:
	* tui/tui.c:
	* tui/tui-winsource.h:
	* tui/tui-winsource.c:
	* tui/tui-wingeneral.h:
	* tui/tui-wingeneral.c:
	* tui/tui-windata.h:
	* tui/tui-windata.c: Add (C) after Copyright.  Update the FSF
	address.
@
text
@d47 1
a47 1
static struct tui_list source_windows = {(void **) src_win_list, 0};
d185 1
a185 1
    tui_clear_win_detail ((struct tui_win_info *) (tui_source_windows ())->list[i]);
d785 1
a785 1
      struct tui_win_info * win_info = (struct tui_win_info *) (tui_source_windows ())->list[i];
@


1.10
log
@2005-11-01  Andrew Stubbs  <andrew.stubbs@@st.com>

	* tui/tui-data.h (tui_line_or_address): Encapsulate the union in a
	struct with a tag.
	(tui_source_element, tui_source_info): Update.
	* tui/tui-disasm.c, tui/tui-source.c: Update to use the tagged union.
	* tui/tui-source.h, tui/tui-stack.c, tui/tui-win.c: Likewise.
	* tui/tui-winsource.c, tui/tui-data.c, tui/tui-layout.c: Likewise.
	* tui/tui-winsource.h: Likewise.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.9
log
@	* tui/tui-win.h (tui_get_cmd_list): Declare.
	* tui/tui-win.c (tui_command): New function.
	(tui_get_cmd_list): New function.
	(_initialize_tui_win): Moved initialization of tui command in
	tui_get_cmd_list.

	* tui/tui-data.c (init_content_element): Setup new data members.
	(init_win_info): Likewise.
	(free_content_elements): Free it.
	* tui/tui-data.h (struct tui_data_element): Store the register
	content to print.
	(struct tui_data_info): Keep the current register group.

	* tui/tui-layout.c (tui_set_layout): Update call to tui_show_registers.

	* tui/tui-regs.h (tui_show_registers): Update prototype.
	(tui_toggle_float_regs, tui_calculate_regs_column_count): Remove.
	(tui_resize_all): No need to calculate anything for register window.
	* tui/tui-regs.c (tui_calculate_regs_column_count): Remove.
	(tui_set_register_element, tui_set_general_regs_content): Remove.
	(tui_set_special_regs_content): Remove.
	(tui_set_general_and_special_regs_content): Remove.
	(tui_set_float_regs_content): Remove.
	(tui_reg_value_has_changed, tui_get_register_raw_value): Remove.
	(tui_set_regs_content): Remove.
	(tui_toggle_float_regs, _tui_toggle_float_regs_command): Remove.
	(tui_v_show_registers_command_support): Remove.
	(tui_show_registers): Use a reggroup to specify the registers to show.
	(tui_show_register_group): New function.
	(tui_display_registers_from): Compute the layout of register window
	and refresh with new API; be sure to delete old register windows.
	(tui_check_register_values): Update to use tui_get_register and
	tui_display_data.
	(tui_display_register): Just refresh the register window part.
	(tui_register_format): Format registers and save in tui_data_element.
	(tui_get_register): New to combine tui_reg_value_has_changed and
	tui_get_register_raw_value; fix to use the new gdb API.
	(tui_show_float_command): Renamed tui_reg_float_command.
	(tui_show_general_command): Renamed tui_reg_general_command.
	(tui_show_special_command): Renamed tui_reg_system_command.
	(_initialize_tui_regs): Remove unused commands.
@
text
@d210 2
a211 1
	  win_info->detail.source_info.start_line_or_addr.addr = 0;
d490 2
a491 1
      element->which_element.source.line_or_addr.line_no = 0;
d542 2
a543 1
      win_info->detail.source_info.start_line_or_addr.addr = 0;
@


1.9.2.1
log
@merge mainline changes to branch
@
text
@@


1.8
log
@2004-02-10  Andrew Cagney  <cagney@@redhat.com>

	* defs.h: Do not include "tui.h".
	* gdb_curses.h: New file.
	* tui/tui-hooks.h: New file.
	* tui/tui.h (tui_update_all_exec_infos): Delete declaration.
	(tui_install_hooks, tui_remove_hooks): Delete declarations.
	(tui_initialize_io): Delete declaration.
	(tui_initialize_readline: Delete redundant declaration.
	(struct tui_point): Delete definition.
	* tui/tui-data.h (struct tui_point): Define.
	* cli/cli-decode.c [TUI]: Include "tui/tui.h".
	* utils.c: Include "tui/tui.h".
	* tui/tui-data.h: Include "tui/tui.h" and "gdb_curses.h".
	* printcmd.c [TUI]: Include "tui/tui.h".
	* cli/cli-cmds.c [TUI]: Include "tui/tui.h".
	* tui/tui-command.c: Include "gdb_curses.h".
	* tui/tui.c, tui/tui-winsource.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-windata.c, tui/tui-win.c, tui/tui-stack.c: Ditto.
	* tui/tui-source.c, tui/tui-regs.c, tui/tui-layout.c: Ditto.
	* tui/tui-io.c, tui/tui-disasm.c, tui/tui-data.c: : Ditto.
	* tui/tui-hooks.c: Include "tui-hooks.h" and "gdb_curses.h".
	* Makefile.in: Update all dependencies.
	(tui_hooks_h, gdb_curses_h): Define.
	(SUBDIR_TUI_CFLAGS): Remove -I${srcdir}/tui.
@
text
@d510 1
d552 1
d909 1
@


1.8.4.1
log
@Merge mainline to intercu branch.
@
text
@a509 1
      element->which_element.data.content = (char*) NULL;
a550 1
      win_info->detail.data_display_info.current_group = 0;
a906 1
                      xfree (element->which_element.data.content);
@


1.8.8.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@a509 1
      element->which_element.data.content = (char*) NULL;
a550 1
      win_info->detail.data_display_info.current_group = 0;
a906 1
                      xfree (element->which_element.data.content);
@


1.8.6.1
log
@	* tui/tui-win.h (tui_get_cmd_list): Declare.
	* tui/tui-win.c (tui_command): New function.
	(tui_get_cmd_list): New function.
	(_initialize_tui_win): Moved initialization of tui command in
	tui_get_cmd_list.

	* tui/tui-data.c (init_content_element): Setup new data members.
	(init_win_info): Likewise.
	(free_content_elements): Free it.
	* tui/tui-data.h (struct tui_data_element): Store the register
	content to print.
	(struct tui_data_info): Keep the current register group.

	* tui/tui-layout.c (tui_set_layout): Update call to tui_show_registers.

	* tui/tui-regs.h (tui_show_registers): Update prototype.
	(tui_toggle_float_regs, tui_calculate_regs_column_count): Remove.
	(tui_resize_all): No need to calculate anything for register window.
	* tui/tui-regs.c (tui_calculate_regs_column_count): Remove.
	(tui_set_register_element, tui_set_general_regs_content): Remove.
	(tui_set_special_regs_content): Remove.
	(tui_set_general_and_special_regs_content): Remove.
	(tui_set_float_regs_content): Remove.
	(tui_reg_value_has_changed, tui_get_register_raw_value): Remove.
	(tui_set_regs_content): Remove.
	(tui_toggle_float_regs, _tui_toggle_float_regs_command): Remove.
	(tui_v_show_registers_command_support): Remove.
	(tui_show_registers): Use a reggroup to specify the registers to show.
	(tui_show_register_group): New function.
	(tui_display_registers_from): Compute the layout of register window
	and refresh with new API; be sure to delete old register windows.
	(tui_check_register_values): Update to use tui_get_register and
	tui_display_data.
	(tui_display_register): Just refresh the register window part.
	(tui_register_format): Format registers and save in tui_data_element.
	(tui_get_register): New to combine tui_reg_value_has_changed and
	tui_get_register_raw_value; fix to use the new gdb API.
	(tui_show_float_command): Renamed tui_reg_float_command.
	(tui_show_general_command): Renamed tui_reg_general_command.
	(tui_show_special_command): Renamed tui_reg_system_command.
	(_initialize_tui_regs): Remove unused commands.
@
text
@a509 1
      element->which_element.data.content = (char*) NULL;
a550 1
      win_info->detail.data_display_info.current_group = 0;
a906 1
                      xfree (element->which_element.data.content);
@


1.7
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Change variable and function names to lower
	case.
	* tui/tui-data.c, tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c, tui/tui-io.c, tui/tui-layout.c: Ditto.
	* tui/tui-regs.c, tui/tui-source.c, tui/tui-stack.c: Ditto.
	* tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d32 1
a32 8

#ifdef HAVE_NCURSES_H       
#include <ncurses.h>
#else
#ifdef HAVE_CURSES_H
#include <curses.h>
#endif
#endif
@


1.7.2.1
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d49 2
a50 2
static enum tui_layout_type _currentLayout = UNDEFINED_LAYOUT;
static int _termHeight, _termWidth;
d52 11
a62 11
static struct tui_gen_win_info _execInfo[2];
static struct tui_win_info * _srcWinList[2];
static struct tui_list _sourceWindows = {(void **) _srcWinList, 0};
static int _defaultTabLen = DEFAULT_TAB_LEN;
static struct tui_win_info * _winWithFocus = (struct tui_win_info *) NULL;
static struct tui_layout_def _layoutDef =
{SRC_WIN,			/* displayMode */
 FALSE,				/* split */
 TUI_UNDEFINED_REGS,		/* regsDisplayType */
 TUI_SFLOAT_REGS};		/* floatRegsDisplayType */
static int _winResized = FALSE;
d68 2
a69 2
static void freeContent (tui_win_content, int, enum tui_win_type);
static void freeContentElements (tui_win_content, int, enum tui_win_type);
d111 1
a111 1
  return _winResized;
d119 1
a119 1
  _winResized = resized;
d127 1
a127 1
  return &_layoutDef;
d135 1
a135 1
  return _winWithFocus;
d143 1
a143 1
  _winWithFocus = win_info;
d151 1
a151 1
  return _defaultTabLen;
d159 1
a159 1
  _defaultTabLen = len;
d163 3
a165 6
/*
   ** currentSourceWin()
   **        Accessor for the current source window.  Usually there is only
   **        one source window (either source or disassembly), but both can
   **        be displayed at the same time.
 */
d169 1
a169 1
  return &_sourceWindows;
d179 3
a181 3
  _sourceWindows.list[0] = NULL;
  _sourceWindows.list[1] = NULL;
  _sourceWindows.count = 0;
d202 2
a203 2
  if (_sourceWindows.count < 2)
    _sourceWindows.list[_sourceWindows.count++] = (void *) win_info;
d240 1
a240 3

  return;
}				/* clearWinDetail */
d243 1
a243 4
/*
   ** sourceExecInfoPtr().
   **        Accessor for the source execution info ptr.
 */
d247 2
a248 2
  return &_execInfo[0];
}				/* sourceExecInfoWinPtr */
d251 1
a251 4
/*
   ** disassemExecInfoPtr().
   **        Accessor for the disassem execution info ptr.
 */
d255 2
a256 2
  return &_execInfo[1];
}				/* disassemExecInfoWinPtr */
d268 1
a268 1
/* Accessor for the termHeight.  */
d272 1
a272 1
  return _termHeight;
d280 1
a280 1
  _termHeight = h;
d284 1
a284 1
/* Accessor for the termWidth.   */
d288 1
a288 1
  return _termWidth;
d292 1
a292 1
/* Mutator for the termWidth.  */
d296 1
a296 1
  _termWidth = w;
d304 1
a304 1
  return _currentLayout;
d310 1
a310 1
tui_set_current_layout_to (enum tui_layout_type newLayout)
d312 1
a312 1
  _currentLayout = newLayout;
d316 1
a316 4
/*
   ** setGenWinOrigin().
   **        Set the origin of the window
 */
d318 1
a318 1
setGenWinOrigin (struct tui_gen_win_info * win_info, int x, int y)
d322 1
a322 3

  return;
}				/* setGenWinOrigin */
d333 1
a333 1
tui_next_win (struct tui_win_info * curWin)
d335 2
a336 2
  enum tui_win_type type = curWin->generic.type;
  struct tui_win_info * nextWin = (struct tui_win_info *) NULL;
d338 1
a338 1
  if (curWin->generic.type == CMD_WIN)
d341 2
a342 2
    type = curWin->generic.type + 1;
  while (type != curWin->generic.type && (nextWin == NULL))
d345 1
a345 1
	nextWin = tui_win_list[type];
d355 2
a356 2
  return nextWin;
}				/* tuiNextWin */
d362 1
a362 1
tui_prev_win (struct tui_win_info * curWin)
d364 1
a364 1
  enum tui_win_type type = curWin->generic.type;
d367 1
a367 1
  if (curWin->generic.type == SRC_WIN)
d370 2
a371 2
    type = curWin->generic.type - 1;
  while (type != curWin->generic.type && (prev == NULL))
d402 3
a404 3
              char *curName = tui_win_name (&tui_win_list[i]->generic);
              if (strlen (name) <= strlen (curName) &&
                  strncmp (name, curName, strlen (name)) == 0)
d412 1
a412 1
}				/* partialWinByName */
d415 1
a415 4
/*
   ** winName().
   **      Answer the name of the window
 */
d441 1
a441 1
}				/* winName */
d463 1
a463 1
}				/* allocGenericWinInfo */
a465 3
/*
   ** initGenericPart().
 */
d485 1
a485 1
   ** initContentElement().
d488 1
a488 1
initContentElement (struct tui_win_element * element, enum tui_win_type type)
d531 1
a531 2
  return;
}				/* initContentElement */
a532 3
/*
   ** initWinInfo().
 */
d534 1
a534 1
initWinInfo (struct tui_win_info * win_info)
d567 1
a567 3

  return;
}				/* initWinInfo */
d579 1
a579 1
      initWinInfo (win_info);
d583 1
a583 1
}				/* allocWinInfo */
d586 1
a586 4
/*
   ** allocContent().
   **        Allocates the content and elements in a block.
 */
d588 1
a588 1
tui_alloc_content (int numElements, enum tui_win_type type)
d591 1
a591 1
  char *elementBlockPtr = (char *) NULL;
d595 1
a595 1
  xmalloc (sizeof (struct tui_win_element *) * numElements)) != (tui_win_content) NULL)
d603 2
a604 2
	  if ((elementBlockPtr = (char *)
	   xmalloc (sizeof (struct tui_win_element) * numElements)) != (char *) NULL)
d606 1
a606 1
	      for (i = 0; i < numElements; i++)
d608 3
a610 3
		  content[i] = (struct tui_win_element *) elementBlockPtr;
		  initContentElement (content[i], type);
		  elementBlockPtr += sizeof (struct tui_win_element);
d622 1
a622 1
}				/* allocContent */
d626 1
a626 1
   content has been allocated yet, allocContent() is called to do
d631 1
a631 1
tui_add_content_elements (struct tui_gen_win_info * win_info, int numElements)
d633 2
a634 2
  struct tui_win_element * elementPtr;
  int i, indexStart;
d638 2
a639 2
      win_info->content = (void **) tui_alloc_content (numElements, win_info->type);
      indexStart = 0;
d642 1
a642 1
    indexStart = win_info->content_size;
d645 1
a645 1
      for (i = indexStart; (i < numElements + indexStart); i++)
d647 1
a647 1
	  if ((elementPtr = (struct tui_win_element *)
d650 2
a651 2
	      win_info->content[i] = (void *) elementPtr;
	      initContentElement (elementPtr, win_info->type);
d659 2
a660 2
  return indexStart;
}				/* addContentElements */
d666 1
a666 1
tuiDelWindow (struct tui_win_info * win_info)
d668 1
a668 1
  struct tui_gen_win_info * genericWin;
d674 2
a675 2
      genericWin = tui_locator_win_info_ptr ();
      if (genericWin != (struct tui_gen_win_info *) NULL)
d677 3
a679 3
	  tui_delete_win (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  genericWin->is_visible = FALSE;
d686 2
a687 2
      genericWin = win_info->detail.source_info.execution_info;
      if (genericWin != (struct tui_gen_win_info *) NULL)
d689 3
a691 3
	  tui_delete_win (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  genericWin->is_visible = FALSE;
d718 1
a718 1
  struct tui_gen_win_info * genericWin;
d724 2
a725 2
      genericWin = tui_locator_win_info_ptr ();
      if (genericWin != (struct tui_gen_win_info *) NULL)
d727 2
a728 2
	  tui_delete_win (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
d730 1
a730 1
      tui_free_win_content (genericWin);
d736 2
a737 2
      genericWin = win_info->detail.source_info.execution_info;
      if (genericWin != (struct tui_gen_win_info *) NULL)
d739 3
a741 3
	  tui_delete_win (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  tui_free_win_content (genericWin);
d803 1
a803 1
      freeContent ((tui_win_content) win_info->content,
d809 1
a809 3

  return;
}				/* freeWinContent */
d813 1
a813 1
tui_del_data_windows (tui_win_content content, int contentSize)
d821 1
a821 1
  for (i = 0; i < contentSize; i++)
d823 1
a823 1
      struct tui_gen_win_info * genericWin = &content[i]->which_element.data_window;
d825 1
a825 1
      if (genericWin != (struct tui_gen_win_info *) NULL)
d827 3
a829 3
	  tui_delete_win (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  genericWin->is_visible = FALSE;
d836 1
a836 1
tui_free_data_content (tui_win_content content, int contentSize)
d844 1
a844 1
  for (i = 0; i < contentSize; i++)
d846 1
a846 1
      struct tui_gen_win_info * genericWin = &content[i]->which_element.data_window;
d848 1
a848 1
      if (genericWin != (struct tui_gen_win_info *) NULL)
d850 3
a852 3
	  tui_delete_win (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  tui_free_win_content (genericWin);
d855 2
a856 2
  freeContent (content,
	       contentSize,
d858 1
a858 3

  return;
}				/* freeDataContent */
a865 3
/*
   ** freeContent().
 */
d867 1
a867 1
freeContent (tui_win_content content, int contentSize, enum tui_win_type winType)
d871 1
a871 1
      freeContentElements (content, contentSize, winType);
d874 1
a874 3

  return;
}				/* freeContent */
d878 1
a878 1
   ** freeContentElements().
d881 1
a881 1
freeContentElements (tui_win_content content, int contentSize, enum tui_win_type type)
d894 1
a894 1
	  for (i = 0; i < contentSize; i++)
d928 1
a928 3

  return;
}				/* freeContentElements */
@


1.6
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui.h: Do not include <stdarg.h>, <string.h>, and
	"ansidecl.h".  Do not undef "reg" and "chtype".  Fix case of
	fields and variables.
	* tui/tui-wingeneral.h (m_beVisible): Delete macro.
	(m_beInvisible): Delete macro.
	* tui/tui-data.h: Fix case case fields and variables.
	(m_genWinPtrIsNull): Delete macro.
	(tui_win_list): Rename winList.
	(TUI_SRC_WIN): Rename srcWin.
	(TUI_DISASM_WIN): Rename disassemWin.
	(TUI_DATA_WIN): Rename dataWin.
	(TUI_CMD_WIN): Rename cmdWin.
	(m_genWinPtrNotNull): Delete macro.
	(m_winPtrIsNull): Delete macro.
	(m_winPtrNotNull): Delete macro.
	(tui_win_is_source_type): Replace m_winIsSourceType
	(tui_win_is_auxillary): Replace m_winIsAuzillary.
	(tui_win_has_locator): Replace m_hasLocator.
	(tui_set_win_highlight): Replace m_setWinHighlightOn and
	m_setWinHighlightOff.
	* tui/tui-data.c: Update references.
	(tui_win_is_source_type, tui_set_win_highlight): New functions.
	(tui_win_has_locator, tui_win_is_auxillary): New functions.
	* tui/tui-command.c, tui/tui-disasm.c: Update references.
	* tui/tui-io.c, tui/tui-layout.c, tui/tui-regs.c: Ditto.
	* tui/tui-regs.h, tui/tui-source.c, tui/tui-stack.c: Ditto.
	* tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d49 2
a50 2
static enum tui_layout_type _currentLayout = UNDEFINED_LAYOUT;
static int _termHeight, _termWidth;
d52 11
a62 11
static struct tui_gen_win_info _execInfo[2];
static struct tui_win_info * _srcWinList[2];
static struct tui_list _sourceWindows = {(void **) _srcWinList, 0};
static int _defaultTabLen = DEFAULT_TAB_LEN;
static struct tui_win_info * _winWithFocus = (struct tui_win_info *) NULL;
static struct tui_layout_def _layoutDef =
{SRC_WIN,			/* displayMode */
 FALSE,				/* split */
 TUI_UNDEFINED_REGS,		/* regsDisplayType */
 TUI_SFLOAT_REGS};		/* floatRegsDisplayType */
static int _winResized = FALSE;
d68 2
a69 2
static void freeContent (tui_win_content, int, enum tui_win_type);
static void freeContentElements (tui_win_content, int, enum tui_win_type);
d111 1
a111 1
  return _winResized;
d119 1
a119 1
  _winResized = resized;
d127 1
a127 1
  return &_layoutDef;
d135 1
a135 1
  return _winWithFocus;
d143 1
a143 1
  _winWithFocus = win_info;
d151 1
a151 1
  return _defaultTabLen;
d159 1
a159 1
  _defaultTabLen = len;
d163 3
a165 6
/*
   ** currentSourceWin()
   **        Accessor for the current source window.  Usually there is only
   **        one source window (either source or disassembly), but both can
   **        be displayed at the same time.
 */
d169 1
a169 1
  return &_sourceWindows;
d179 3
a181 3
  _sourceWindows.list[0] = NULL;
  _sourceWindows.list[1] = NULL;
  _sourceWindows.count = 0;
d202 2
a203 2
  if (_sourceWindows.count < 2)
    _sourceWindows.list[_sourceWindows.count++] = (void *) win_info;
d240 1
a240 3

  return;
}				/* clearWinDetail */
d243 1
a243 4
/*
   ** sourceExecInfoPtr().
   **        Accessor for the source execution info ptr.
 */
d247 2
a248 2
  return &_execInfo[0];
}				/* sourceExecInfoWinPtr */
d251 1
a251 4
/*
   ** disassemExecInfoPtr().
   **        Accessor for the disassem execution info ptr.
 */
d255 2
a256 2
  return &_execInfo[1];
}				/* disassemExecInfoWinPtr */
d268 1
a268 1
/* Accessor for the termHeight.  */
d272 1
a272 1
  return _termHeight;
d280 1
a280 1
  _termHeight = h;
d284 1
a284 1
/* Accessor for the termWidth.   */
d288 1
a288 1
  return _termWidth;
d292 1
a292 1
/* Mutator for the termWidth.  */
d296 1
a296 1
  _termWidth = w;
d304 1
a304 1
  return _currentLayout;
d310 1
a310 1
tui_set_current_layout_to (enum tui_layout_type newLayout)
d312 1
a312 1
  _currentLayout = newLayout;
d316 1
a316 4
/*
   ** setGenWinOrigin().
   **        Set the origin of the window
 */
d318 1
a318 1
setGenWinOrigin (struct tui_gen_win_info * win_info, int x, int y)
d322 1
a322 3

  return;
}				/* setGenWinOrigin */
d333 1
a333 1
tui_next_win (struct tui_win_info * curWin)
d335 2
a336 2
  enum tui_win_type type = curWin->generic.type;
  struct tui_win_info * nextWin = (struct tui_win_info *) NULL;
d338 1
a338 1
  if (curWin->generic.type == CMD_WIN)
d341 2
a342 2
    type = curWin->generic.type + 1;
  while (type != curWin->generic.type && (nextWin == NULL))
d345 1
a345 1
	nextWin = tui_win_list[type];
d355 2
a356 2
  return nextWin;
}				/* tuiNextWin */
d362 1
a362 1
tui_prev_win (struct tui_win_info * curWin)
d364 1
a364 1
  enum tui_win_type type = curWin->generic.type;
d367 1
a367 1
  if (curWin->generic.type == SRC_WIN)
d370 2
a371 2
    type = curWin->generic.type - 1;
  while (type != curWin->generic.type && (prev == NULL))
d402 3
a404 3
              char *curName = tui_win_name (&tui_win_list[i]->generic);
              if (strlen (name) <= strlen (curName) &&
                  strncmp (name, curName, strlen (name)) == 0)
d412 1
a412 1
}				/* partialWinByName */
d415 1
a415 4
/*
   ** winName().
   **      Answer the name of the window
 */
d441 1
a441 1
}				/* winName */
d463 1
a463 1
}				/* allocGenericWinInfo */
a465 3
/*
   ** initGenericPart().
 */
d485 1
a485 1
   ** initContentElement().
d488 1
a488 1
initContentElement (struct tui_win_element * element, enum tui_win_type type)
d531 1
a531 2
  return;
}				/* initContentElement */
a532 3
/*
   ** initWinInfo().
 */
d534 1
a534 1
initWinInfo (struct tui_win_info * win_info)
d567 1
a567 3

  return;
}				/* initWinInfo */
d579 1
a579 1
      initWinInfo (win_info);
d583 1
a583 1
}				/* allocWinInfo */
d586 1
a586 4
/*
   ** allocContent().
   **        Allocates the content and elements in a block.
 */
d588 1
a588 1
tui_alloc_content (int numElements, enum tui_win_type type)
d591 1
a591 1
  char *elementBlockPtr = (char *) NULL;
d595 1
a595 1
  xmalloc (sizeof (struct tui_win_element *) * numElements)) != (tui_win_content) NULL)
d603 2
a604 2
	  if ((elementBlockPtr = (char *)
	   xmalloc (sizeof (struct tui_win_element) * numElements)) != (char *) NULL)
d606 1
a606 1
	      for (i = 0; i < numElements; i++)
d608 3
a610 3
		  content[i] = (struct tui_win_element *) elementBlockPtr;
		  initContentElement (content[i], type);
		  elementBlockPtr += sizeof (struct tui_win_element);
d622 1
a622 1
}				/* allocContent */
d626 1
a626 1
   content has been allocated yet, allocContent() is called to do
d631 1
a631 1
tui_add_content_elements (struct tui_gen_win_info * win_info, int numElements)
d633 2
a634 2
  struct tui_win_element * elementPtr;
  int i, indexStart;
d638 2
a639 2
      win_info->content = (void **) tui_alloc_content (numElements, win_info->type);
      indexStart = 0;
d642 1
a642 1
    indexStart = win_info->content_size;
d645 1
a645 1
      for (i = indexStart; (i < numElements + indexStart); i++)
d647 1
a647 1
	  if ((elementPtr = (struct tui_win_element *)
d650 2
a651 2
	      win_info->content[i] = (void *) elementPtr;
	      initContentElement (elementPtr, win_info->type);
d659 2
a660 2
  return indexStart;
}				/* addContentElements */
d666 1
a666 1
tuiDelWindow (struct tui_win_info * win_info)
d668 1
a668 1
  struct tui_gen_win_info * genericWin;
d674 2
a675 2
      genericWin = tui_locator_win_info_ptr ();
      if (genericWin != (struct tui_gen_win_info *) NULL)
d677 3
a679 3
	  tui_delete_win (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  genericWin->is_visible = FALSE;
d686 2
a687 2
      genericWin = win_info->detail.source_info.execution_info;
      if (genericWin != (struct tui_gen_win_info *) NULL)
d689 3
a691 3
	  tui_delete_win (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  genericWin->is_visible = FALSE;
d718 1
a718 1
  struct tui_gen_win_info * genericWin;
d724 2
a725 2
      genericWin = tui_locator_win_info_ptr ();
      if (genericWin != (struct tui_gen_win_info *) NULL)
d727 2
a728 2
	  tui_delete_win (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
d730 1
a730 1
      tui_free_win_content (genericWin);
d736 2
a737 2
      genericWin = win_info->detail.source_info.execution_info;
      if (genericWin != (struct tui_gen_win_info *) NULL)
d739 3
a741 3
	  tui_delete_win (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  tui_free_win_content (genericWin);
d803 1
a803 1
      freeContent ((tui_win_content) win_info->content,
d809 1
a809 3

  return;
}				/* freeWinContent */
d813 1
a813 1
tui_del_data_windows (tui_win_content content, int contentSize)
d821 1
a821 1
  for (i = 0; i < contentSize; i++)
d823 1
a823 1
      struct tui_gen_win_info * genericWin = &content[i]->which_element.data_window;
d825 1
a825 1
      if (genericWin != (struct tui_gen_win_info *) NULL)
d827 3
a829 3
	  tui_delete_win (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  genericWin->is_visible = FALSE;
d836 1
a836 1
tui_free_data_content (tui_win_content content, int contentSize)
d844 1
a844 1
  for (i = 0; i < contentSize; i++)
d846 1
a846 1
      struct tui_gen_win_info * genericWin = &content[i]->which_element.data_window;
d848 1
a848 1
      if (genericWin != (struct tui_gen_win_info *) NULL)
d850 3
a852 3
	  tui_delete_win (genericWin->handle);
	  genericWin->handle = (WINDOW *) NULL;
	  tui_free_win_content (genericWin);
d855 2
a856 2
  freeContent (content,
	       contentSize,
d858 1
a858 3

  return;
}				/* freeDataContent */
a865 3
/*
   ** freeContent().
 */
d867 1
a867 1
freeContent (tui_win_content content, int contentSize, enum tui_win_type winType)
d871 1
a871 1
      freeContentElements (content, contentSize, winType);
d874 1
a874 3

  return;
}				/* freeContent */
d878 1
a878 1
   ** freeContentElements().
d881 1
a881 1
freeContentElements (tui_win_content content, int contentSize, enum tui_win_type type)
d894 1
a894 1
	  for (i = 0; i < contentSize; i++)
d928 1
a928 3

  return;
}				/* freeContentElements */
@


1.5
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui.h (Opaque, OpaquePtr OpaqueList): Delete definition.
	(TuiPoint, TuiPointPtr): Ditto.
	(TuiStatus, TuiStatusPtr): Ditto.
	(TuiWinType, TuiWinTypePtr): Ditto.
	(struct tui_point): Rename _TuiPoint.
	(tui_get_low_disassembly_address): Rename
	tuiGetLowDisassemblyAddress.
	(tui_update_all_exec_infos): Rename tuiUpdateAllExecInfos.
	(tuiFree): Delete declaration.
	(OpaqueFuncPtr, TuiOpaqueFuncPtr): Delete definitions.
	(TuiVoidFuncPtr, TuiIntFuncPtr): Delete definitions.
	* tui/tui.c (tuiFree): Delete function.
	* cli/cli-cmds.c (disassemble_command): Update references.
	* tui/tui-data.c, tui/tui-data.h, tui/tui-disasm.c: Ditto.
	* tui/tui-layout.c, tui/tui-regs.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-win.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
   Inc.
d31 2
d44 1
a44 1
struct tui_win_info *(winList[MAX_MAJOR_WINDOWS]);
d77 26
d141 1
a141 1
tui_set_win_with_focus (struct tui_win_info * winInfo)
d143 1
a143 1
  _winWithFocus = winInfo;
d203 1
a203 1
tui_add_to_source_windows (struct tui_win_info * winInfo)
d206 1
a206 1
    _sourceWindows.list[_sourceWindows.count++] = (void *) winInfo;
d212 1
a212 1
tui_clear_win_detail (struct tui_win_info * winInfo)
d214 1
a214 1
  if (m_winPtrNotNull (winInfo))
d216 1
a216 1
      switch (winInfo->generic.type)
d220 2
a221 2
	  winInfo->detail.sourceInfo.startLineOrAddr.addr = 0;
	  winInfo->detail.sourceInfo.horizontalOffset = 0;
d224 2
a225 2
	  winInfo->detail.commandInfo.curLine =
	    winInfo->detail.commandInfo.curch = 0;
d228 1
a228 1
	  winInfo->detail.dataDisplayInfo.dataContent =
d230 2
a231 2
	  winInfo->detail.dataDisplayInfo.dataContentCount = 0;
	  winInfo->detail.dataDisplayInfo.regsContent =
d233 2
a234 2
	  winInfo->detail.dataDisplayInfo.regsContentCount = 0;
	  winInfo->detail.dataDisplayInfo.regsDisplayType =
d236 2
a237 2
	  winInfo->detail.dataDisplayInfo.regsColumnCount = 1;
	  winInfo->detail.dataDisplayInfo.displayRegs = FALSE;
d332 1
a332 1
setGenWinOrigin (struct tui_gen_win_info * winInfo, int x, int y)
d334 2
a335 2
  winInfo->origin.x = x;
  winInfo->origin.y = y;
d358 1
a358 1
  while (type != curWin->generic.type && m_winPtrIsNull (nextWin))
d360 2
a361 2
      if (winList[type] && winList[type]->generic.isVisible)
	nextWin = winList[type];
d387 1
a387 1
  while (type != curWin->generic.type && m_winPtrIsNull (prev))
d389 2
a390 2
      if (winList[type]->generic.isVisible)
	prev = winList[type];
d408 1
a408 1
  struct tui_win_info * winInfo = (struct tui_win_info *) NULL;
d414 1
a414 1
      while (i < MAX_MAJOR_WINDOWS && m_winPtrIsNull (winInfo))
d416 1
a416 1
          if (winList[i] != 0)
d418 1
a418 1
              char *curName = tui_win_name (&winList[i]->generic);
d421 1
a421 1
                winInfo = winList[i];
d427 1
a427 1
  return winInfo;
d436 1
a436 1
tui_win_name (struct tui_gen_win_info * winInfo)
d440 1
a440 1
  switch (winInfo->type)
d495 3
a497 3
    win->viewportHeight =
    win->contentSize =
    win->lastVisibleLine = 0;
d500 2
a501 2
  win->contentInUse =
    win->isVisible = FALSE;
d517 4
a520 4
      element->whichElement.source.line = (char *) NULL;
      element->whichElement.source.lineOrAddr.lineNo = 0;
      element->whichElement.source.isExecPoint = FALSE;
      element->whichElement.source.hasBreak = FALSE;
d523 3
a525 3
      tui_init_generic_part (&element->whichElement.dataWindow);
      element->whichElement.dataWindow.type = DATA_ITEM_WIN;
      ((struct tui_gen_win_info *) & element->whichElement.dataWindow)->content =
d528 1
a528 1
       & element->whichElement.dataWindow)->contentSize = 1;
d531 1
a531 1
      element->whichElement.command.line = (char *) NULL;
d534 5
a538 5
      element->whichElement.data.name = (char *) NULL;
      element->whichElement.data.type = TUI_REGISTER;
      element->whichElement.data.itemNo = UNDEFINED_ITEM;
      element->whichElement.data.value = NULL;
      element->whichElement.data.highlight = FALSE;
d541 4
a544 4
      element->whichElement.locator.fileName[0] =
	element->whichElement.locator.procName[0] = (char) 0;
      element->whichElement.locator.lineNo = 0;
      element->whichElement.locator.addr = 0;
d547 2
a548 2
      memset(element->whichElement.simpleString, ' ',
             sizeof(element->whichElement.simpleString));
d560 1
a560 1
initWinInfo (struct tui_win_info * winInfo)
d562 4
a565 4
  tui_init_generic_part (&winInfo->generic);
  winInfo->canHighlight =
    winInfo->isHighlighted = FALSE;
  switch (winInfo->generic.type)
d569 5
a573 5
      winInfo->detail.sourceInfo.executionInfo = (struct tui_gen_win_info *) NULL;
      winInfo->detail.sourceInfo.hasLocator = FALSE;
      winInfo->detail.sourceInfo.horizontalOffset = 0;
      winInfo->detail.sourceInfo.startLineOrAddr.addr = 0;
      winInfo->detail.sourceInfo.filename = 0;
d576 5
a580 5
      winInfo->detail.dataDisplayInfo.dataContent = (tui_win_content) NULL;
      winInfo->detail.dataDisplayInfo.dataContentCount = 0;
      winInfo->detail.dataDisplayInfo.regsContent = (tui_win_content) NULL;
      winInfo->detail.dataDisplayInfo.regsContentCount = 0;
      winInfo->detail.dataDisplayInfo.regsDisplayType =
d582 2
a583 2
      winInfo->detail.dataDisplayInfo.regsColumnCount = 1;
      winInfo->detail.dataDisplayInfo.displayRegs = FALSE;
d586 2
a587 2
      winInfo->detail.commandInfo.curLine = 0;
      winInfo->detail.commandInfo.curch = 0;
d590 1
a590 1
      winInfo->detail.opaque = NULL;
d601 1
a601 1
  struct tui_win_info * winInfo = (struct tui_win_info *) NULL;
d603 2
a604 2
  winInfo = (struct tui_win_info *) xmalloc (sizeof (struct tui_win_info));
  if (m_winPtrNotNull (winInfo))
d606 2
a607 2
      winInfo->generic.type = type;
      initWinInfo (winInfo);
d610 1
a610 1
  return winInfo;
d662 1
a662 1
tui_add_content_elements (struct tui_gen_win_info * winInfo, int numElements)
d667 1
a667 1
  if (winInfo->content == NULL)
d669 1
a669 1
      winInfo->content = (void **) tui_alloc_content (numElements, winInfo->type);
d673 2
a674 2
    indexStart = winInfo->contentSize;
  if (winInfo->content != NULL)
d681 3
a683 3
	      winInfo->content[i] = (void *) elementPtr;
	      initContentElement (elementPtr, winInfo->type);
	      winInfo->contentSize++;
d694 1
a694 1
/* Delete all curses windows associated with winInfo, leaving everything
d697 1
a697 1
tuiDelWindow (struct tui_win_info * winInfo)
d701 1
a701 1
  switch (winInfo->generic.type)
d710 1
a710 1
	  genericWin->isVisible = FALSE;
d712 1
a712 1
      if (winInfo->detail.sourceInfo.filename)
d714 2
a715 2
          xfree (winInfo->detail.sourceInfo.filename);
          winInfo->detail.sourceInfo.filename = 0;
d717 1
a717 1
      genericWin = winInfo->detail.sourceInfo.executionInfo;
d722 1
a722 1
	  genericWin->isVisible = FALSE;
d726 1
a726 1
      if (winInfo->generic.content != NULL)
d728 4
a731 4
	  tui_del_data_windows (winInfo->detail.dataDisplayInfo.regsContent,
				winInfo->detail.dataDisplayInfo.regsContentCount);
	  tui_del_data_windows (winInfo->detail.dataDisplayInfo.dataContent,
				winInfo->detail.dataDisplayInfo.dataContentCount);
d737 1
a737 1
  if (winInfo->generic.handle != (WINDOW *) NULL)
d739 3
a741 3
      tui_delete_win (winInfo->generic.handle);
      winInfo->generic.handle = (WINDOW *) NULL;
      winInfo->generic.isVisible = FALSE;
d747 1
a747 1
tui_free_window (struct tui_win_info * winInfo)
d751 1
a751 1
  switch (winInfo->generic.type)
d762 1
a762 1
      if (winInfo->detail.sourceInfo.filename)
d764 2
a765 2
          xfree (winInfo->detail.sourceInfo.filename);
          winInfo->detail.sourceInfo.filename = 0;
d767 1
a767 1
      genericWin = winInfo->detail.sourceInfo.executionInfo;
d776 1
a776 1
      if (winInfo->generic.content != NULL)
d778 3
a780 3
	  tui_free_data_content (winInfo->detail.dataDisplayInfo.regsContent,
				 winInfo->detail.dataDisplayInfo.regsContentCount);
	  winInfo->detail.dataDisplayInfo.regsContent =
d782 4
a785 4
	  winInfo->detail.dataDisplayInfo.regsContentCount = 0;
	  tui_free_data_content (winInfo->detail.dataDisplayInfo.dataContent,
				 winInfo->detail.dataDisplayInfo.dataContentCount);
	  winInfo->detail.dataDisplayInfo.dataContent =
d787 2
a788 2
	  winInfo->detail.dataDisplayInfo.dataContentCount = 0;
	  winInfo->detail.dataDisplayInfo.regsDisplayType =
d790 4
a793 4
	  winInfo->detail.dataDisplayInfo.regsColumnCount = 1;
	  winInfo->detail.dataDisplayInfo.displayRegs = FALSE;
	  winInfo->generic.content = NULL;
	  winInfo->generic.contentSize = 0;
d799 1
a799 1
  if (winInfo->generic.handle != (WINDOW *) NULL)
d801 7
a807 7
      tui_delete_win (winInfo->generic.handle);
      winInfo->generic.handle = (WINDOW *) NULL;
      tui_free_win_content (&winInfo->generic);
    }
  if (winInfo->generic.title)
    xfree (winInfo->generic.title);
  xfree (winInfo);
d818 1
a818 1
      struct tui_win_info * winInfo = (struct tui_win_info *) (tui_source_windows ())->list[i];
d820 1
a820 1
      if (m_winPtrNotNull (winInfo))
d822 2
a823 2
	  tui_free_win_content (&(winInfo->generic));
	  tui_free_win_content (winInfo->detail.sourceInfo.executionInfo);
d830 1
a830 1
tui_free_win_content (struct tui_gen_win_info * winInfo)
d832 1
a832 1
  if (winInfo->content != NULL)
d834 4
a837 4
      freeContent ((tui_win_content) winInfo->content,
		   winInfo->contentSize,
		   winInfo->type);
      winInfo->content = NULL;
d839 1
a839 1
  winInfo->contentSize = 0;
d856 1
a856 1
      struct tui_gen_win_info * genericWin = &content[i]->whichElement.dataWindow;
d862 1
a862 1
	  genericWin->isVisible = FALSE;
d879 1
a879 1
      struct tui_gen_win_info * genericWin = &content[i]->whichElement.dataWindow;
d930 1
a930 1
	  xfree (content[0]->whichElement.source.line);
d951 3
a953 3
		      if (element->whichElement.data.type != TUI_REGISTER)
			xfree ((void *)element->whichElement.data.name);
		      xfree (element->whichElement.data.value);
d957 1
a957 1
		      xfree (element->whichElement.command.line);
@


1.4
log
@2004-02-07  Andrew Cagney  <cagney@@redhat.com>

        * tui/tui-data.h (tui_win_element): Rename TuiWinElement.
        (tui_exec_info_content): Rename TuiExecInfoContent.
        (TuiGenWinInfo, TuiGenWinInfoPtr): Delete definitions.
        (TuiWinInfo, TuiWinInfoPtr): Ditto.
        (TuiScrollDirection, TuiScrollDirectionPtr): Ditto.
        (TuiList, TuiListPtr): Ditto.
        (TuiLayoutType, TuiLayoutTypePtr): Ditto.
        (TuiDataType, TuiDataTypePtr): Ditto.
        (TuiRegisterDisplayType, TuiRegisterDisplayTypePtr): Ditto.
        (TuiLineOrAddress, TuiLineOrAddressPtr): Ditto.
        (TuiLayoutDef, TuiLayoutDefPtr): Ditto.
        (TuiSourceElement, TuiSourceElementPtr): Ditto.
        (TuiDataElement, TuiDataElementPtr): Ditto.
        (TuiWinElement, TuiWinElementPtr): Ditto.
        (TuiDataInfo, TuiDataInfoPtr): Ditto.
        (TuiCommandElement, TuiCommandElementPtr): Ditto.
        (TuiLocatorElement, TuiLocatorElementPtr): Ditto.
        (TuiWhichElement, TuiWhichElementPtr): Ditto.
        (TuiSourceInfo, TuiSourceInfoPtr): Ditto.
        (TuiCommandInfo, TuiCommandInfoPtr): Ditto.
        * tui/tui-command.c, tui/tui-data.c: Update references.
        * tui/tui-data.h, tui/tui-disasm.c, tui/tui-layout.c: Ditto.
        * tui/tui-regs.c, tui/tui-source.c, tui/tui-stack.c: Ditto.
        * tui/tui-win.c, tui/tui-windata.c, tui/tui-wingeneral.c: Ditto.
        * tui/tui-winsource.c, tui/tui.c: Ditto.
@
text
@d52 1
a52 2
static struct tui_list _sourceWindows =
{(OpaqueList) _srcWinList, 0};
d66 2
a67 2
static void freeContent (tui_win_content, int, TuiWinType);
static void freeContentElements (tui_win_content, int, TuiWinType);
d154 2
a155 2
  _sourceWindows.list[0] = (Opaque) NULL;
  _sourceWindows.list[1] = (Opaque) NULL;
d178 1
a178 1
    _sourceWindows.list[_sourceWindows.count++] = (Opaque) winInfo;
d323 1
a323 1
  TuiWinType type = curWin->generic.type;
d352 1
a352 1
  TuiWinType type = curWin->generic.type;
d471 1
a471 1
  win->content = (OpaquePtr) NULL;
d482 1
a482 1
initContentElement (struct tui_win_element * element, TuiWinType type)
d498 1
a498 1
	(OpaquePtr) tui_alloc_content (1, DATA_ITEM_WIN);
d509 1
a509 1
      element->whichElement.data.value = (Opaque) NULL;
d562 1
a562 1
      winInfo->detail.opaque = (Opaque) NULL;
d571 1
a571 1
tui_alloc_win_info (TuiWinType type)
d591 1
a591 1
tui_alloc_content (int numElements, TuiWinType type)
d618 1
a618 1
	      tuiFree ((char *) content);
d639 1
a639 1
  if (winInfo->content == (OpaquePtr) NULL)
d641 1
a641 1
      winInfo->content = (OpaquePtr) tui_alloc_content (numElements, winInfo->type);
d646 1
a646 1
  if (winInfo->content != (OpaquePtr) NULL)
d653 1
a653 1
	      winInfo->content[i] = (Opaque) elementPtr;
d698 1
a698 1
      if (winInfo->generic.content != (OpaquePtr) NULL)
d748 1
a748 1
      if (winInfo->generic.content != (OpaquePtr) NULL)
d764 1
a764 1
	  winInfo->generic.content = (OpaquePtr) NULL;
d804 1
a804 1
  if (winInfo->content != (OpaquePtr) NULL)
d809 1
a809 1
      winInfo->content = (OpaquePtr) NULL;
d877 1
a877 1
freeContent (tui_win_content content, int contentSize, TuiWinType winType)
d882 1
a882 1
      tuiFree ((char *) content);
d893 1
a893 1
freeContentElements (tui_win_content content, int contentSize, TuiWinType type)
d902 1
a902 2
	  if (content[0]->whichElement.source.line != (char *) NULL)
	    tuiFree (content[0]->whichElement.source.line);
d916 1
a916 1
		      tuiFree ((char *) element);
d924 3
a926 4
			tuiFree ((char *)
				 element->whichElement.data.name);
		      tuiFree ((char *) element->whichElement.data.value);
		      tuiFree ((char *) element);
d929 1
a929 1
		      tuiFree ((char *) element->whichElement.command.line);
d938 1
a938 1
	tuiFree ((char *) content[0]);	/* free the element block */
@


1.3
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-data.h (struct tui_list): Rename _TuiList.
	(enum tui_data_type): Rename _TuiDataType.
	(struct tui_layout_def): Rename _TuiLayoutDef.
	(struct tui_source_element): Rename _TuiSourceElement.
	(struct tui_data_element): Rename _TuiDataElement.
	(struct tui_command_element): Rename _TuiCommandElement.
	(struct tui_locator_element): Rename _TuiLocatorElement.
	(union tui_which_element): Define.
	(struct tui_win_element): Rename _TuiWinElement.
	(struct tui_data_info): Rename _TuiDataInfo.
	(struct tui_source_info): Rename _TuiSourceInfo.
	(struct tui_command_info): Rename _TuiCommandInfo.
	(tui_initialize_static_data): Rename initializeStaticData.
	(tui_alloc_generic_win_info): Rename allocGenericWinInfo.
	(tui_alloc_win_info): Rename allocWinInfo.
	(tui_init_generic_part): Rename initGenericPart.
	(tui_init_win_info): Rename initWinInfo.
	(tui_alloc_content): Rename allocContent.
	(tui_add_content_elements): Rename addContentElements.
	(tui_init_content_element): Rename initContentElement.
	(tui_free_window): Rename freeWindow.
	(tui_free_win_content): Rename freeWinContent.
	(tui_free_data_content): Rename freeDataContent.
	(tui_free_all_source_wins_content): Rename
	freeAllSourceWinsContent.
	(tui_del_window): Rename tuiDelWindow.
	(tui_del_data_windows): Rename tuiDelDataWindows.
	(tui_partial_win_by_name): Rename partialWinByName.
	(tui_win_name): Rename winName.
	(tui_current_layout): Rename currentLayout.
	(tui_set_current_layout_to): Rename setCurrentLayoutTo.
	(tui_term_height): Rename termHeight.
	(tui_set_term_height_to): Rename setTermHeightTo.
	(tui_term_width): Rename termWidth.
	(tui_set_term_width_to): Rename setTermWidthTo.
	(tui_set_gen_win_origin): Rename setGenWinOrigin.
	(tui_locator_win_info_ptr): Rename locatorWinInfoPtr.
	(tui_source_exec_info_win_ptr): Rename tui_gen_win_info.
	(tui_disassem_exec_info_win_ptr): Rename disassemExecInfoWinPtr.
	(tui_source_windows): Rename sourceWindows.
	(tui_clear_source_windows): Rename clearSourceWindows.
	(tui_clear_source_windows_detail): Rename
	clearSourceWindowsDetail.
	(tui_clear_win_detail): Rename clearWinDetail.
	(tui_add_to_source_windows): Rename tuiAddToSourceWindows.
	(tui_default_tab_len): Rename tuiDefaultTabLen.
	(tui_set_default_tab_len): Rename tuiSetDefaultTabLen.
	(tui_win_with_focus): Rename tuiWinWithFocus.
	(tui_set_win_with_focus): Rename tuiSetWinWithFocus.
	(tui_layout_def): Rename tuiLayoutDef.
	(tui_win_resized): Rename tuiWinResized.
	(tui_set_win_resized_to): Rename tuiSetWinResizedTo.
	(tui_next_win): Rename tuiNextWin.
	(tui_prev_win): Rename tuiPrevWin.
	(tui_add_to_source_windows): Rename addToSourceWindows.
	* tui/tui-winsource.c, tui/tui-win.c: Update references.
	* tui/tui-layout.c, tui/tui-source.c: Ditto.
	* tui/tui-stack.c, tui/tui-io.c: Ditto.
	* tui/tui.c, tui/tui-data.c: Ditto.
	* tui/tui-interp.c, tui/tui-data.c: Ditto.
	* tui/tui-disasm.c, tui/tui-command.c: Ditto.
@
text
@d42 1
a42 1
TuiWinInfoPtr winList[MAX_MAJOR_WINDOWS];
d47 1
a47 1
static TuiLayoutType _currentLayout = UNDEFINED_LAYOUT;
d49 4
a52 4
static TuiGenWinInfo _locator;
static TuiGenWinInfo _execInfo[2];
static TuiWinInfoPtr _srcWinList[2];
static TuiList _sourceWindows =
d55 2
a56 2
static TuiWinInfoPtr _winWithFocus = (TuiWinInfoPtr) NULL;
static TuiLayoutDef _layoutDef =
d67 2
a68 2
static void freeContent (TuiWinContent, int, TuiWinType);
static void freeContentElements (TuiWinContent, int, TuiWinType);
d97 1
a97 1
TuiLayoutDefPtr
d105 1
a105 1
TuiWinInfoPtr
d114 1
a114 1
tui_set_win_with_focus (TuiWinInfoPtr winInfo)
d142 1
a142 1
TuiListPtr
d168 1
a168 1
    tui_clear_win_detail ((TuiWinInfoPtr) (tui_source_windows ())->list[i]);
d176 1
a176 1
tui_add_to_source_windows (TuiWinInfoPtr winInfo)
d185 1
a185 1
tui_clear_win_detail (TuiWinInfoPtr winInfo)
d202 1
a202 1
	    (TuiWinContent) NULL;
d205 1
a205 1
	    (TuiWinContent) NULL;
d225 1
a225 1
TuiGenWinInfoPtr
d236 1
a236 1
TuiGenWinInfoPtr
d245 1
a245 1
TuiGenWinInfoPtr
d249 1
a249 1
}				/* locatorWinInfoPtr */
d285 1
a285 1
TuiLayoutType
d294 1
a294 1
tui_set_current_layout_to (TuiLayoutType newLayout)
d305 1
a305 1
setGenWinOrigin (TuiGenWinInfoPtr winInfo, int x, int y)
d321 2
a322 2
TuiWinInfoPtr
tui_next_win (TuiWinInfoPtr curWin)
d325 1
a325 1
  TuiWinInfoPtr nextWin = (TuiWinInfoPtr) NULL;
d350 2
a351 2
TuiWinInfoPtr
tui_prev_win (TuiWinInfoPtr curWin)
d354 1
a354 1
  TuiWinInfoPtr prev = (TuiWinInfoPtr) NULL;
d378 1
a378 1
TuiWinInfoPtr
d381 1
a381 1
  TuiWinInfoPtr winInfo = (TuiWinInfoPtr) NULL;
d409 1
a409 1
tui_win_name (TuiGenWinInfoPtr winInfo)
d445 1
a445 1
TuiGenWinInfoPtr
d448 1
a448 1
  TuiGenWinInfoPtr win;
d450 2
a451 2
  if ((win = (TuiGenWinInfoPtr) xmalloc (
		     sizeof (TuiGenWinInfoPtr))) != (TuiGenWinInfoPtr) NULL)
d462 1
a462 1
tui_init_generic_part (TuiGenWinInfoPtr win)
d483 1
a483 1
initContentElement (TuiWinElementPtr element, TuiWinType type)
d498 1
a498 1
      ((TuiGenWinInfoPtr) & element->whichElement.dataWindow)->content =
d500 1
a500 1
      ((TuiGenWinInfoPtr)
d533 1
a533 1
initWinInfo (TuiWinInfoPtr winInfo)
d542 1
a542 1
      winInfo->detail.sourceInfo.executionInfo = (TuiGenWinInfoPtr) NULL;
d549 1
a549 1
      winInfo->detail.dataDisplayInfo.dataContent = (TuiWinContent) NULL;
d551 1
a551 1
      winInfo->detail.dataDisplayInfo.regsContent = (TuiWinContent) NULL;
d571 1
a571 1
TuiWinInfoPtr
d574 1
a574 1
  TuiWinInfoPtr winInfo = (TuiWinInfoPtr) NULL;
d576 1
a576 1
  winInfo = (TuiWinInfoPtr) xmalloc (sizeof (TuiWinInfo));
d591 1
a591 1
TuiWinContent
d594 1
a594 1
  TuiWinContent content = (TuiWinContent) NULL;
d598 2
a599 2
  if ((content = (TuiWinContent)
  xmalloc (sizeof (TuiWinElementPtr) * numElements)) != (TuiWinContent) NULL)
d608 1
a608 1
	   xmalloc (sizeof (TuiWinElement) * numElements)) != (char *) NULL)
d612 1
a612 1
		  content[i] = (TuiWinElementPtr) elementBlockPtr;
d614 1
a614 1
		  elementBlockPtr += sizeof (TuiWinElement);
d620 1
a620 1
	      content = (TuiWinContent) NULL;
d635 1
a635 1
tui_add_content_elements (TuiGenWinInfoPtr winInfo, int numElements)
d637 1
a637 1
  TuiWinElementPtr elementPtr;
d651 2
a652 2
	  if ((elementPtr = (TuiWinElementPtr)
	       xmalloc (sizeof (TuiWinElement))) != (TuiWinElementPtr) NULL)
d670 1
a670 1
tuiDelWindow (TuiWinInfoPtr winInfo)
d672 1
a672 1
  TuiGenWinInfoPtr genericWin;
d679 1
a679 1
      if (genericWin != (TuiGenWinInfoPtr) NULL)
d691 1
a691 1
      if (genericWin != (TuiGenWinInfoPtr) NULL)
d720 1
a720 1
tui_free_window (TuiWinInfoPtr winInfo)
d722 1
a722 1
  TuiGenWinInfoPtr genericWin;
d729 1
a729 1
      if (genericWin != (TuiGenWinInfoPtr) NULL)
d741 1
a741 1
      if (genericWin != (TuiGenWinInfoPtr) NULL)
d754 1
a754 1
	    (TuiWinContent) NULL;
d759 1
a759 1
	    (TuiWinContent) NULL;
d791 1
a791 1
      TuiWinInfoPtr winInfo = (TuiWinInfoPtr) (tui_source_windows ())->list[i];
d803 1
a803 1
tui_free_win_content (TuiGenWinInfoPtr winInfo)
d807 1
a807 1
      freeContent ((TuiWinContent) winInfo->content,
d819 1
a819 1
tui_del_data_windows (TuiWinContent content, int contentSize)
d824 1
a824 1
     ** Remember that data window content elements are of type TuiGenWinInfoPtr,
d829 1
a829 1
      TuiGenWinInfoPtr genericWin = &content[i]->whichElement.dataWindow;
d831 1
a831 1
      if (genericWin != (TuiGenWinInfoPtr) NULL)
d842 1
a842 1
tui_free_data_content (TuiWinContent content, int contentSize)
d847 1
a847 1
     ** Remember that data window content elements are of type TuiGenWinInfoPtr,
d852 1
a852 1
      TuiGenWinInfoPtr genericWin = &content[i]->whichElement.dataWindow;
d854 1
a854 1
      if (genericWin != (TuiGenWinInfoPtr) NULL)
d878 1
a878 1
freeContent (TuiWinContent content, int contentSize, TuiWinType winType)
d880 1
a880 1
  if (content != (TuiWinContent) NULL)
d894 1
a894 1
freeContentElements (TuiWinContent content, int contentSize, TuiWinType type)
d896 1
a896 1
  if (content != (TuiWinContent) NULL)
d910 1
a910 1
	      TuiWinElementPtr element;
d913 1
a913 1
	      if (element != (TuiWinElementPtr) NULL)
@


1.2
log
@2004-02-06  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-wingeneral.h: Update copyright.
	(m_allBeVisible): Delete macro.
	(m_allBeInvisible): Delete macro.
	(struct tui_gen_win_info): Declare.
	(struct tui_win_info): Declare.
	(tui_unhighlight_win): Rename unhighlightWin.
	(tui_make_visible, tui_make_invisible): Replace makeVisible.
	(tui_make_all_visible, tui_make_all_invisible): Replace makeAllVisible.
	(tui_make_window): Rename makeWindow.
	(tui_copy_win): Rename copyWin.
	(tui_box_win): Rename boxWin.
	(tui_highlight_win): Rename highlightWin.
	(tui_check_and_display_highlight_if_needed): Rename
	checkAndDisplayHighlightIfNeeded.
	(tui_refresh_all): Rename refreshAll.
	(tui_delete_win): Rename tuiDelwin.
	(tui_refresh_win): Rename tuiRefreshWin.
	* tui/tui-wingeneral.c (make_visible): Rename makeVisible.
	(tui_make_visible, tui_make_invisible): New functions.
	(tui_make_all_visible, tui_make_all_invisible): New functions.
	(make_all_visible): Rename makeAllVisible.
	* tui/tui-winsource.c, tui/tui-windata.c: Update references.
	* tui/tui-data.c, tui/tui-winsource.c: Update references.
	* tui/tui-windata.c, tui/tui-win.c: Update references.
	* tui/tui-regs.c, tui/tui-layout.c: Update references.
	* tui/tui-data.h (struct tui_gen_win_info): Rename _TuiGenWinInfo.
@
text
@d80 1
a80 4
/*
   ** tuiWinResized().
   **        Answer a whether the terminal window has been resized or not
 */
d82 1
a82 1
tuiWinResized (void)
d85 1
a85 1
}				/* tuiWinResized */
d88 1
a88 4
/*
   ** tuiSetWinResized().
   **        Set a whether the terminal window has been resized or not
 */
d90 1
a90 1
tuiSetWinResizedTo (int resized)
d93 1
a94 2
  return;
}				/* tuiSetWinResizedTo */
d96 1
a96 5

/*
   ** tuiLayoutDef().
   **        Answer a pointer to the current layout definition
 */
d98 1
a98 1
tuiLayoutDef (void)
d101 1
a101 1
}				/* tuiLayoutDef */
d104 1
a104 4
/*
   ** tuiWinWithFocus().
   **        Answer the window with the logical focus
 */
d106 1
a106 1
tuiWinWithFocus (void)
d109 1
a109 1
}				/* tuiWinWithFocus */
d112 1
a112 4
/*
   ** tuiSetWinWithFocus().
   **        Set the window that has the logical focus
 */
d114 1
a114 1
tuiSetWinWithFocus (TuiWinInfoPtr winInfo)
d117 1
a117 3

  return;
}				/* tuiSetWinWithFocus */
d120 1
a120 4
/*
   ** tuiDefaultTabLen().
   **        Answer the length in chars, of tabs
 */
d122 1
a122 1
tuiDefaultTabLen (void)
d125 1
a125 1
}				/* tuiDefaultTabLen */
d128 1
a128 4
/*
   ** tuiSetDefaultTabLen().
   **        Set the length in chars, of tabs
 */
d130 1
a130 1
tuiSetDefaultTabLen (int len)
d133 1
a133 3

  return;
}				/* tuiSetDefaultTabLen */
d143 1
a143 1
sourceWindows (void)
d146 1
a146 1
}				/* currentSourceWindows */
d149 3
a151 6
/*
   ** clearSourceWindows()
   **        Clear the list of source windows.  Usually there is only one
   **        source window (either source or disassembly), but both can be
   **        displayed at the same time.
 */
d153 1
a153 1
clearSourceWindows (void)
d158 1
a159 2
  return;
}				/* currentSourceWindows */
d161 1
a161 5

/*
   ** clearSourceWindowsDetail()
   **        Clear the pertinant detail in the source windows.
 */
d163 1
a163 1
clearSourceWindowsDetail (void)
d167 3
a169 5
  for (i = 0; i < (sourceWindows ())->count; i++)
    clearWinDetail ((TuiWinInfoPtr) (sourceWindows ())->list[i]);

  return;
}				/* currentSourceWindows */
d172 3
a174 6
/*
   ** addSourceWindowToList().
   **       Add a window to the list of source windows.  Usually there is
   **       only one source window (either source or disassembly), but
   **       both can be displayed at the same time.
 */
d176 1
a176 1
addToSourceWindows (TuiWinInfoPtr winInfo)
d180 1
a180 3

  return;
}				/* addToSourceWindows */
d183 1
a183 4
/*
   ** clearWinDetail()
   **        Clear the pertinant detail in the windows.
 */
d185 1
a185 1
clearWinDetail (TuiWinInfoPtr winInfo)
d226 1
a226 1
sourceExecInfoWinPtr (void)
d237 1
a237 1
disassemExecInfoWinPtr (void)
d243 2
a244 5
/*
   ** locatorWinInfoPtr().
   **        Accessor for the locator win info.  Answers a pointer to the
   **        static locator win info struct.
 */
d246 1
a246 1
locatorWinInfoPtr (void)
d252 1
a252 4
/*
   ** termHeight().
   **        Accessor for the termHeight
 */
d254 1
a254 1
termHeight (void)
d257 1
a257 1
}				/* termHeight */
d260 1
a260 4
/*
   ** setTermHeightTo().
   **        Mutator for the term height
 */
d262 1
a262 1
setTermHeightTo (int h)
d265 1
a266 2
  return;
}				/* setTermHeightTo */
d268 1
a268 5

/*
   ** termWidth().
   **        Accessor for the termWidth
 */
d270 1
a270 1
termWidth (void)
d273 1
a273 1
}				/* termWidth */
d276 1
a276 4
/*
   ** setTermWidth().
   **        Mutator for the termWidth
 */
d278 1
a278 1
setTermWidthTo (int w)
d281 1
a281 3

  return;
}				/* setTermWidthTo */
d284 1
a284 4
/*
   ** currentLayout().
   **        Accessor for the current layout
 */
d286 1
a286 1
currentLayout (void)
d289 1
a289 1
}				/* currentLayout */
d292 1
a292 4
/*
   ** setCurrentLayoutTo().
   **        Mutator for the current layout
 */
d294 1
a294 1
setCurrentLayoutTo (TuiLayoutType newLayout)
d297 1
a297 3

  return;
}				/* setCurrentLayoutTo */
d319 2
a320 5
/*
   ** tuiNextWin().
   **        Answer the next window in the list, cycling back to the top
   **        if necessary
 */
d322 1
a322 1
tuiNextWin (TuiWinInfoPtr curWin)
d348 2
a349 5
/*
   ** tuiPrevWin().
   **        Answer the prev window in the list, cycling back to the bottom
   **        if necessary
 */
d351 1
a351 1
tuiPrevWin (TuiWinInfoPtr curWin)
d377 1
a377 4
/*
   **  partialWinByName().
   **      Answer the window represented by name
 */
d379 1
a379 1
partialWinByName (char *name)
d391 1
a391 1
              char *curName = winName (&winList[i]->generic);
d409 1
a409 1
winName (TuiGenWinInfoPtr winInfo)
a435 3
/*
   ** initializeStaticData
 */
d437 1
a437 1
initializeStaticData (void)
d439 4
a442 6
  initGenericPart (sourceExecInfoWinPtr ());
  initGenericPart (disassemExecInfoWinPtr ());
  initGenericPart (locatorWinInfoPtr ());

  return;
}				/* initializeStaticData */
a444 3
/*
   ** allocGenericWinInfo().
 */
d446 1
a446 1
allocGenericWinInfo (void)
d452 1
a452 1
    initGenericPart (win);
d462 1
a462 1
initGenericPart (TuiGenWinInfoPtr win)
d496 1
a496 1
      initGenericPart (&element->whichElement.dataWindow);
d499 1
a499 1
	(OpaquePtr) allocContent (1, DATA_ITEM_WIN);
d535 1
a535 1
  initGenericPart (&winInfo->generic);
a570 3
/*
   ** allocWinInfo().
 */
d572 1
a572 1
allocWinInfo (TuiWinType type)
d592 1
a592 1
allocContent (int numElements, TuiWinType type)
d629 5
a633 8
/*
   ** addContentElements().
   **        Adds the input number of elements to the windows's content.  If
   **        no content has been allocated yet, allocContent() is called to
   **        do this.  The index of the first element added is returned,
   **        unless there is a memory allocation error, in which case, (-1)
   **        is returned.
 */
d635 1
a635 1
addContentElements (TuiGenWinInfoPtr winInfo, int numElements)
d642 1
a642 1
      winInfo->content = (OpaquePtr) allocContent (numElements, winInfo->type);
d678 1
a678 1
      genericWin = locatorWinInfoPtr ();
d701 4
a704 4
	  tuiDelDataWindows (winInfo->detail.dataDisplayInfo.regsContent,
                             winInfo->detail.dataDisplayInfo.regsContentCount);
	  tuiDelDataWindows (winInfo->detail.dataDisplayInfo.dataContent,
                             winInfo->detail.dataDisplayInfo.dataContentCount);
a718 3
/*
   **  freeWindow().
 */
d720 1
a720 1
freeWindow (TuiWinInfoPtr winInfo)
d728 1
a728 1
      genericWin = locatorWinInfoPtr ();
d734 1
a734 1
      freeWinContent (genericWin);
d745 1
a745 1
	  freeWinContent (genericWin);
d751 2
a752 3
	  freeDataContent (
			    winInfo->detail.dataDisplayInfo.regsContent,
			  winInfo->detail.dataDisplayInfo.regsContentCount);
d756 2
a757 3
	  freeDataContent (
			    winInfo->detail.dataDisplayInfo.dataContent,
			  winInfo->detail.dataDisplayInfo.dataContentCount);
d776 1
a776 1
      freeWinContent (&winInfo->generic);
a783 3
/*
   ** freeAllSourceWinsContent().
 */
d785 1
a785 1
freeAllSourceWinsContent (void)
d789 1
a789 1
  for (i = 0; i < (sourceWindows ())->count; i++)
d791 1
a791 1
      TuiWinInfoPtr winInfo = (TuiWinInfoPtr) (sourceWindows ())->list[i];
d795 2
a796 2
	  freeWinContent (&(winInfo->generic));
	  freeWinContent (winInfo->detail.sourceInfo.executionInfo);
d799 1
a799 3

  return;
}				/* freeAllSourceWinsContent */
a801 3
/*
   ** freeWinContent().
 */
d803 1
a803 1
freeWinContent (TuiGenWinInfoPtr winInfo)
d819 1
a819 1
tuiDelDataWindows (TuiWinContent content, int contentSize)
d838 1
a838 3

  return;
}				/* tuiDelDataWindows */
d842 1
a842 1
freeDataContent (TuiWinContent content, int contentSize)
d858 1
a858 1
	  freeWinContent (genericWin);
@


1.1
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* tui/tui-command.c: Rename tui/tuiCommand.c.
	* tui/tui-command.h: Rename tui/tuiCommand.h.
	* tui/tui-data.c: Rename tui/tuiData.c.
	* tui/tui-data.h: Rename tui/tuiData.h.
	* tui/tui-disasm.c: Rename tui/tuiDisassem.c.
	* tui/tui-disasm.h: Rename tui/tuiDisassem.h.
	* tui/tui-io.c: Rename tui/tuiIO.c.
	* tui/tui-io.h: Rename tui/tuiIO.h.
	* tui/tui-layout.c: Rename tui/tuiLayout.c.
	* tui/tui-layout.h: Rename tui/tuiLayout.h.
	* tui/tui-regs.c: Rename tui/tuiRegs.c.
	* tui/tui-regs.h: Rename tui/tuiRegs.h.
	* tui/tui-source.c: Rename tui/tuiSource.c.
	* tui/tui-source.h: Rename tui/tuiSource.h.
	* tui/tui-stack.c: Rename tui/tuiStack.c.
	* tui/tui-stack.h: Rename tui/tuiStack.h.
	* tui/tui-win.c: Rename tui/tuiWin.c.
	* tui/tui-win.h: Rename tui/tuiWin.h.
	* tui/tui-windata.c: Rename tui/tuiDataWin.c.
	* tui/tui-windata.h: Rename tui/tuiDataWin.h.
	* tui/tui-wingeneral.c: Rename tui/tuiGeneralWin.c.
	* tui/tui-wingeneral.h: Rename tui/tuiGeneralWin.h.
	* tui/tui-winsource.c: Rename tui/tuiSourceWin.c.
	* tui/tui-winsource.h: Rename tui/tuiSourceWin.h.
	* tui/tui-file.c: Update includes.
	* tui/tui-hooks.c: Update includes.
	* tui/tui-interp.c: Update includes.
	* tui/tui.c: Update includes.
	* Makefile.in: Update all tui/ dependencies.
	(SUBDIR_TUI_OBS, SUBDIR_TUI_SRCS): Update file names.
@
text
@d776 1
a776 1
	  tuiDelwin (genericWin->handle);
d788 1
a788 1
	  tuiDelwin (genericWin->handle);
d807 1
a807 1
      tuiDelwin (winInfo->generic.handle);
d829 1
a829 1
	  tuiDelwin (genericWin->handle);
d841 1
a841 1
	  tuiDelwin (genericWin->handle);
d874 1
a874 1
      tuiDelwin (winInfo->generic.handle);
d941 1
a941 1
	  tuiDelwin (genericWin->handle);
d966 1
a966 1
	  tuiDelwin (genericWin->handle);
@


1.1.4.1
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@@

