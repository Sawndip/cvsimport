head	1.121;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.117
	gdb_7_6-2013-04-26-release:1.117
	gdb_7_6-branch:1.117.0.2
	gdb_7_6-2013-03-12-branchpoint:1.117
	gdb_7_5_1-2012-11-29-release:1.109.2.1
	gdb_7_5-2012-08-17-release:1.109
	gdb_7_5-branch:1.109.0.2
	gdb_7_5-2012-07-18-branchpoint:1.109
	gdb_7_4_1-2012-04-26-release:1.98.2.1
	gdb_7_4-2012-01-24-release:1.98.2.1
	gdb_7_4-branch:1.98.0.2
	gdb_7_4-2011-12-13-branchpoint:1.98
	gdb_7_3_1-2011-09-04-release:1.87
	gdb_7_3-2011-07-26-release:1.87
	gdb_7_3-branch:1.87.0.2
	gdb_7_3-2011-04-01-branchpoint:1.87
	gdb_7_2-2010-09-02-release:1.81
	gdb_7_2-branch:1.81.0.2
	gdb_7_2-2010-07-07-branchpoint:1.81
	gdb_7_1-2010-03-18-release:1.72
	gdb_7_1-branch:1.72.0.2
	gdb_7_1-2010-02-18-branchpoint:1.72
	gdb_7_0_1-2009-12-22-release:1.65.2.1
	gdb_7_0-2009-10-06-release:1.65
	gdb_7_0-branch:1.65.0.2
	gdb_7_0-2009-09-16-branchpoint:1.65
	arc-sim-20090309:1.46.2.1
	msnyder-checkpoint-072509-branch:1.63.0.2
	msnyder-checkpoint-072509-branchpoint:1.63
	arc-insight_6_8-branch:1.46.2.1.0.4
	arc-insight_6_8-branchpoint:1.46.2.1
	insight_6_8-branch:1.46.2.1.0.2
	insight_6_8-branchpoint:1.46.2.1
	reverse-20081226-branch:1.55.0.4
	reverse-20081226-branchpoint:1.55
	multiprocess-20081120-branch:1.55.0.2
	multiprocess-20081120-branchpoint:1.55
	reverse-20080930-branch:1.54.0.2
	reverse-20080930-branchpoint:1.54
	reverse-20080717-branch:1.52.0.4
	reverse-20080717-branchpoint:1.52
	msnyder-reverse-20080609-branch:1.52.0.2
	msnyder-reverse-20080609-branchpoint:1.52
	drow-reverse-20070409-branch:1.35.0.2
	drow-reverse-20070409-branchpoint:1.35
	gdb_6_8-2008-03-27-release:1.46.2.1
	gdb_6_8-branch:1.46.0.2
	gdb_6_8-2008-02-26-branchpoint:1.46
	gdb_6_7_1-2007-10-29-release:1.39
	gdb_6_7-2007-10-10-release:1.39
	gdb_6_7-branch:1.39.0.2
	gdb_6_7-2007-09-07-branchpoint:1.39
	insight_6_6-20070208-release:1.32
	gdb_6_6-2006-12-18-release:1.32
	gdb_6_6-branch:1.32.0.2
	gdb_6_6-2006-11-15-branchpoint:1.32
	insight_6_5-20061003-release:1.31
	gdb-csl-symbian-6_4_50_20060226-12:1.31
	gdb-csl-sourcerygxx-3_4_4-25:1.27
	nickrob-async-20060828-mergepoint:1.32
	gdb-csl-symbian-6_4_50_20060226-11:1.31
	gdb-csl-sourcerygxx-4_1-17:1.31
	gdb-csl-20060226-branch-local-2:1.31
	gdb-csl-sourcerygxx-4_1-14:1.31
	gdb-csl-sourcerygxx-4_1-13:1.31
	gdb-csl-sourcerygxx-4_1-12:1.31
	gdb-csl-sourcerygxx-3_4_4-21:1.31
	gdb_6_5-20060621-release:1.31
	gdb-csl-sourcerygxx-4_1-9:1.31
	gdb-csl-sourcerygxx-4_1-8:1.31
	gdb-csl-sourcerygxx-4_1-7:1.31
	gdb-csl-arm-2006q1-6:1.31
	gdb-csl-sourcerygxx-4_1-6:1.31
	gdb-csl-symbian-6_4_50_20060226-10:1.31
	gdb-csl-symbian-6_4_50_20060226-9:1.31
	gdb-csl-symbian-6_4_50_20060226-8:1.31
	gdb-csl-coldfire-4_1-11:1.31
	gdb-csl-sourcerygxx-3_4_4-19:1.31
	gdb-csl-coldfire-4_1-10:1.31
	gdb_6_5-branch:1.31.0.16
	gdb_6_5-2006-05-14-branchpoint:1.31
	gdb-csl-sourcerygxx-4_1-5:1.31
	nickrob-async-20060513-branch:1.31.0.14
	nickrob-async-20060513-branchpoint:1.31
	gdb-csl-sourcerygxx-4_1-4:1.31
	msnyder-reverse-20060502-branch:1.31.0.12
	msnyder-reverse-20060502-branchpoint:1.31
	gdb-csl-morpho-4_1-4:1.31
	gdb-csl-sourcerygxx-3_4_4-17:1.31
	readline_5_1-import-branch:1.31.0.10
	readline_5_1-import-branchpoint:1.31
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.31
	gdb-csl-symbian-20060226-branch:1.31.0.8
	gdb-csl-symbian-20060226-branchpoint:1.31
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.31
	msnyder-reverse-20060331-branch:1.31.0.6
	msnyder-reverse-20060331-branchpoint:1.31
	gdb-csl-available-20060303-branch:1.31.0.4
	gdb-csl-available-20060303-branchpoint:1.31
	gdb-csl-20060226-branch:1.31.0.2
	gdb-csl-20060226-branchpoint:1.31
	gdb_6_4-20051202-release:1.27
	msnyder-fork-checkpoint-branch:1.27.0.8
	msnyder-fork-checkpoint-branchpoint:1.27
	gdb-csl-gxxpro-6_3-branch:1.27.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.27
	gdb_6_4-branch:1.27.0.4
	gdb_6_4-2005-11-01-branchpoint:1.27
	gdb-csl-arm-20051020-branch:1.27.0.2
	gdb-csl-arm-20051020-branchpoint:1.27
	msnyder-tracepoint-checkpoint-branch:1.24.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.24
	gdb-csl-arm-20050325-2005-q1b:1.22
	gdb-csl-arm-20050325-2005-q1a:1.22
	csl-arm-20050325-branch:1.22.0.2
	csl-arm-20050325-branchpoint:1.22
	gdb-post-i18n-errorwarning-20050211:1.21
	gdb-pre-i18n-errorwarning-20050211:1.20
	gdb_6_3-20041109-release:1.15
	gdb_6_3-branch:1.15.0.4
	gdb_6_3-20041019-branchpoint:1.15
	drow_intercu-merge-20040921:1.15
	drow_intercu-merge-20040915:1.15
	jimb-gdb_6_2-e500-branch:1.15.0.6
	jimb-gdb_6_2-e500-branchpoint:1.15
	gdb_6_2-20040730-release:1.15
	gdb_6_2-branch:1.15.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.15
	gdb_6_1_1-20040616-release:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.6
	drow_intercu-20040221-branch:1.6.0.2
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.5.0.2
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.3.0.4
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.121
date	2013.09.26.07.00.00;	author muller;	state Exp;
branches;
next	1.120;

1.120
date	2013.09.24.16.14.15;	author brobecke;	state Exp;
branches;
next	1.119;

1.119
date	2013.09.24.16.13.58;	author brobecke;	state Exp;
branches;
next	1.118;

1.118
date	2013.09.24.16.13.48;	author brobecke;	state Exp;
branches;
next	1.117;

1.117
date	2013.01.01.06.32.37;	author brobecke;	state Exp;
branches;
next	1.116;

1.116
date	2012.12.04.07.43.19;	author kvbhat;	state Exp;
branches;
next	1.115;

1.115
date	2012.10.26.19.34.09;	author palves;	state Exp;
branches;
next	1.114;

1.114
date	2012.10.23.18.16.55;	author kettenis;	state Exp;
branches;
next	1.113;

1.113
date	2012.10.15.20.37.38;	author hjl;	state Exp;
branches;
next	1.112;

1.112
date	2012.09.27.10.40.00;	author siddhesh;	state Exp;
branches;
next	1.111;

1.111
date	2012.09.26.07.52.47;	author siddhesh;	state Exp;
branches;
next	1.110;

1.110
date	2012.09.25.12.48.52;	author siddhesh;	state Exp;
branches;
next	1.109;

1.109
date	2012.07.04.20.46.20;	author hjl;	state Exp;
branches
	1.109.2.1;
next	1.108;

1.108
date	2012.06.16.15.20.22;	author hjl;	state Exp;
branches;
next	1.107;

1.107
date	2012.06.16.13.28.06;	author hjl;	state Exp;
branches;
next	1.106;

1.106
date	2012.06.13.20.29.15;	author kettenis;	state Exp;
branches;
next	1.105;

1.105
date	2012.05.16.14.35.02;	author macro;	state Exp;
branches;
next	1.104;

1.104
date	2012.05.14.18.56.40;	author hjl;	state Exp;
branches;
next	1.103;

1.103
date	2012.05.07.21.02.43;	author kettenis;	state Exp;
branches;
next	1.102;

1.102
date	2012.04.27.20.47.51;	author sergiodj;	state Exp;
branches;
next	1.101;

1.101
date	2012.04.06.21.52.22;	author devans;	state Exp;
branches;
next	1.100;

1.100
date	2012.03.20.07.08.55;	author qiyao;	state Exp;
branches;
next	1.99;

1.99
date	2012.01.04.08.16.56;	author brobecke;	state Exp;
branches;
next	1.98;

1.98
date	2011.12.11.02.41.31;	author ndreys;	state Exp;
branches
	1.98.2.1;
next	1.97;

1.97
date	2011.12.05.03.48.29;	author ndreys;	state Exp;
branches;
next	1.96;

1.96
date	2011.11.09.02.21.54;	author qiyao;	state Exp;
branches;
next	1.95;

1.95
date	2011.09.27.13.09.34;	author shebs;	state Exp;
branches;
next	1.94;

1.94
date	2011.09.13.08.26.11;	author jkratoch;	state Exp;
branches;
next	1.93;

1.93
date	2011.09.09.19.41.13;	author jkratoch;	state Exp;
branches;
next	1.92;

1.92
date	2011.09.08.15.38.14;	author jkratoch;	state Exp;
branches;
next	1.91;

1.91
date	2011.07.22.15.31.50;	author tromey;	state Exp;
branches;
next	1.90;

1.90
date	2011.07.05.04.34.55;	author bauermann;	state Exp;
branches;
next	1.89;

1.89
date	2011.06.29.22.19.24;	author jkratoch;	state Exp;
branches;
next	1.88;

1.88
date	2011.04.19.18.04.06;	author tromey;	state Exp;
branches;
next	1.87;

1.87
date	2011.03.18.18.52.29;	author palves;	state Exp;
branches;
next	1.86;

1.86
date	2011.03.18.18.38.41;	author palves;	state Exp;
branches;
next	1.85;

1.85
date	2011.03.18.00.27.48;	author kcy;	state Exp;
branches;
next	1.84;

1.84
date	2011.01.07.19.36.15;	author msnyder;	state Exp;
branches;
next	1.83;

1.83
date	2011.01.01.15.32.56;	author brobecke;	state Exp;
branches;
next	1.82;

1.82
date	2010.09.11.19.09.34;	author hjl;	state Exp;
branches;
next	1.81;

1.81
date	2010.05.26.18.19.26;	author palves;	state Exp;
branches
	1.81.2.1;
next	1.80;

1.80
date	2010.05.06.00.21.53;	author palves;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.02.21.14.59;	author jkratoch;	state Exp;
branches;
next	1.78;

1.78
date	2010.04.11.20.20.31;	author hjl;	state Exp;
branches;
next	1.77;

1.77
date	2010.04.07.18.46.50;	author hjl;	state Exp;
branches;
next	1.76;

1.76
date	2010.04.01.20.02.09;	author hjl;	state Exp;
branches;
next	1.75;

1.75
date	2010.03.12.15.12.35;	author hjl;	state Exp;
branches;
next	1.74;

1.74
date	2010.03.02.13.14.33;	author hjl;	state Exp;
branches;
next	1.73;

1.73
date	2010.03.01.15.33.30;	author hjl;	state Exp;
branches;
next	1.72;

1.72
date	2010.01.29.14.39.02;	author brobecke;	state Exp;
branches;
next	1.71;

1.71
date	2010.01.29.05.27.35;	author brobecke;	state Exp;
branches;
next	1.70;

1.70
date	2010.01.29.05.21.55;	author brobecke;	state Exp;
branches;
next	1.69;

1.69
date	2010.01.29.05.19.22;	author brobecke;	state Exp;
branches;
next	1.68;

1.68
date	2010.01.01.07.31.29;	author brobecke;	state Exp;
branches;
next	1.67;

1.67
date	2009.12.20.19.09.37;	author msnyder;	state Exp;
branches;
next	1.66;

1.66
date	2009.11.05.21.17.00;	author devans;	state Exp;
branches;
next	1.65;

1.65
date	2009.08.17.18.23.45;	author msnyder;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2009.08.10.03.02.39;	author teawater;	state Exp;
branches;
next	1.63;

1.63
date	2009.07.02.17.25.52;	author uweigand;	state Exp;
branches;
next	1.62;

1.62
date	2009.07.02.17.21.05;	author uweigand;	state Exp;
branches;
next	1.61;

1.61
date	2009.07.02.12.52.52;	author uweigand;	state Exp;
branches;
next	1.60;

1.60
date	2009.07.02.12.48.53;	author uweigand;	state Exp;
branches;
next	1.59;

1.59
date	2009.07.02.12.46.18;	author uweigand;	state Exp;
branches;
next	1.58;

1.58
date	2009.02.17.06.14.16;	author devans;	state Exp;
branches;
next	1.57;

1.57
date	2009.01.29.00.29.56;	author devans;	state Exp;
branches;
next	1.56;

1.56
date	2009.01.03.05.57.50;	author brobecke;	state Exp;
branches;
next	1.55;

1.55
date	2008.10.08.12.49.12;	author jkratoch;	state Exp;
branches;
next	1.54;

1.54
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.53;

1.53
date	2008.08.09.16.27.39;	author hjl;	state Exp;
branches;
next	1.52;

1.52
date	2008.05.16.00.27.22;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2008.04.30.21.19.44;	author drow;	state Exp;
branches;
next	1.50;

1.50
date	2008.04.25.14.57.30;	author palves;	state Exp;
branches;
next	1.49;

1.49
date	2008.04.22.11.03.41;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2008.03.11.05.21.38;	author deuling;	state Exp;
branches;
next	1.47;

1.47
date	2008.02.26.22.23.45;	author bauermann;	state Exp;
branches;
next	1.46;

1.46
date	2008.01.29.21.27.19;	author brobecke;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2008.01.11.13.19.59;	author deuling;	state Exp;
branches;
next	1.44;

1.44
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.43;

1.43
date	2007.12.06.16.32.58;	author deuling;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.02.14.27.13;	author uweigand;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.24.20.29.14;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.08.12.48.05;	author uweigand;	state Exp;
branches;
next	1.39;

1.39
date	2007.08.23.18.08.26;	author brobecke;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.16.17.25.59;	author uweigand;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.16.17.24.18;	author uweigand;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.27.15.31.35;	author drow;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.27.20.17.18;	author drow;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.09.17.58.49;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2006.08.19.15.15.18;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.29.21.19.31;	author kettenis;	state Exp;
branches
	1.31.14.1;
next	1.30;

1.30
date	2006.01.21.20.59.50;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.18.21.26.47;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.26.06.59.38;	author jbeulich;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.03.17.30.22;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.12.09.19.07;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.14.11.27.02;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.08.18.00.07;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.17.17.44.14;	author pbrook;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.11.04.05.43;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.07.00.09.52;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.05.15.43.42;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.13.02.15.31;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.31.19.52.46;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.29.14.00.55;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.07.02.02.45;	author tausq;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.30.16.56.08;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.22.15.16.22;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.21.22.15.09;	author jimb;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.20.00.53.06;	author jimb;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.18.21.20.25;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.09.19.48.25;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.09.23.24.05;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.09.16.28.50;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.26.23.15.40;	author brobecke;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2004.03.23.14.47.55;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.14.21.38.55;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.28.20.48.57;	author kettenis;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2004.02.28.18.07.58;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.25.20.45.30;	author kettenis;	state Exp;
branches;
next	;

1.109.2.1
date	2012.11.10.00.50.46;	author hjl;	state Exp;
branches;
next	;

1.98.2.1
date	2012.01.06.04.43.04;	author brobecke;	state Exp;
branches;
next	;

1.81.2.1
date	2011.03.18.00.32.12;	author kcy;	state Exp;
branches;
next	;

1.65.2.1
date	2009.12.21.04.44.23;	author brobecke;	state Exp;
branches;
next	;

1.46.2.1
date	2008.03.04.19.49.39;	author brobecke;	state Exp;
branches;
next	;

1.31.14.1
date	2006.08.28.07.48.50;	author nickrob;	state Exp;
branches;
next	;

1.6.2.1
date	2004.03.27.17.37.43;	author drow;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2004.09.16.17.00.53;	author drow;	state Exp;
branches;
next	;

1.3.4.1
date	2004.03.21.23.57.33;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.121
log
@	Replace constant values 8 to 15 by AMD64_R8_REGNUM to
	AMD64_R15_REGNUM when a register index is expected.
	* amd64-windows-tdep.c (amd64_windows_dummy_call_integer_regs):
	Substitute in array.
	* amd64-tdep.c (amd64_dwarf_regmap): Ditto.
	(amd64_push_arguments): Substitute in integer_regnum array.
@
text
@/* Target-dependent code for AMD64.

   Copyright (C) 2001-2013 Free Software Foundation, Inc.

   Contributed by Jiri Smid, SuSE Labs.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "opcode/i386.h"
#include "dis-asm.h"
#include "arch-utils.h"
#include "block.h"
#include "dummy-frame.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "inferior.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "objfiles.h"
#include "regcache.h"
#include "regset.h"
#include "symfile.h"
#include "disasm.h"
#include "gdb_assert.h"
#include "exceptions.h"
#include "amd64-tdep.h"
#include "i387-tdep.h"

#include "features/i386/amd64.c"
#include "features/i386/amd64-avx.c"
#include "features/i386/x32.c"
#include "features/i386/x32-avx.c"

#include "ax.h"
#include "ax-gdb.h"

/* Note that the AMD64 architecture was previously known as x86-64.
   The latter is (forever) engraved into the canonical system name as
   returned by config.guess, and used as the name for the AMD64 port
   of GNU/Linux.  The BSD's have renamed their ports to amd64; they
   don't like to shout.  For GDB we prefer the amd64_-prefix over the
   x86_64_-prefix since it's so much easier to type.  */

/* Register information.  */

static const char *amd64_register_names[] = 
{
  "rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "rsp",

  /* %r8 is indeed register number 8.  */
  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
  "rip", "eflags", "cs", "ss", "ds", "es", "fs", "gs",

  /* %st0 is register number 24.  */
  "st0", "st1", "st2", "st3", "st4", "st5", "st6", "st7",
  "fctrl", "fstat", "ftag", "fiseg", "fioff", "foseg", "fooff", "fop",

  /* %xmm0 is register number 40.  */
  "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7",
  "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15",
  "mxcsr",
};

static const char *amd64_ymm_names[] = 
{
  "ymm0", "ymm1", "ymm2", "ymm3",
  "ymm4", "ymm5", "ymm6", "ymm7",
  "ymm8", "ymm9", "ymm10", "ymm11",
  "ymm12", "ymm13", "ymm14", "ymm15"
};

static const char *amd64_ymmh_names[] = 
{
  "ymm0h", "ymm1h", "ymm2h", "ymm3h",
  "ymm4h", "ymm5h", "ymm6h", "ymm7h",
  "ymm8h", "ymm9h", "ymm10h", "ymm11h",
  "ymm12h", "ymm13h", "ymm14h", "ymm15h"
};

/* DWARF Register Number Mapping as defined in the System V psABI,
   section 3.6.  */

static int amd64_dwarf_regmap[] =
{
  /* General Purpose Registers RAX, RDX, RCX, RBX, RSI, RDI.  */
  AMD64_RAX_REGNUM, AMD64_RDX_REGNUM,
  AMD64_RCX_REGNUM, AMD64_RBX_REGNUM,
  AMD64_RSI_REGNUM, AMD64_RDI_REGNUM,

  /* Frame Pointer Register RBP.  */
  AMD64_RBP_REGNUM,

  /* Stack Pointer Register RSP.  */
  AMD64_RSP_REGNUM,

  /* Extended Integer Registers 8 - 15.  */
  AMD64_R8_REGNUM,		/* %r8 */
  AMD64_R9_REGNUM,		/* %r9 */
  AMD64_R10_REGNUM,		/* %r10 */
  AMD64_R11_REGNUM,		/* %r11 */
  AMD64_R12_REGNUM,		/* %r12 */
  AMD64_R13_REGNUM,		/* %r13 */
  AMD64_R14_REGNUM,		/* %r14 */
  AMD64_R15_REGNUM,		/* %r15 */

  /* Return Address RA.  Mapped to RIP.  */
  AMD64_RIP_REGNUM,

  /* SSE Registers 0 - 7.  */
  AMD64_XMM0_REGNUM + 0, AMD64_XMM1_REGNUM,
  AMD64_XMM0_REGNUM + 2, AMD64_XMM0_REGNUM + 3,
  AMD64_XMM0_REGNUM + 4, AMD64_XMM0_REGNUM + 5,
  AMD64_XMM0_REGNUM + 6, AMD64_XMM0_REGNUM + 7,

  /* Extended SSE Registers 8 - 15.  */
  AMD64_XMM0_REGNUM + 8, AMD64_XMM0_REGNUM + 9,
  AMD64_XMM0_REGNUM + 10, AMD64_XMM0_REGNUM + 11,
  AMD64_XMM0_REGNUM + 12, AMD64_XMM0_REGNUM + 13,
  AMD64_XMM0_REGNUM + 14, AMD64_XMM0_REGNUM + 15,

  /* Floating Point Registers 0-7.  */
  AMD64_ST0_REGNUM + 0, AMD64_ST0_REGNUM + 1,
  AMD64_ST0_REGNUM + 2, AMD64_ST0_REGNUM + 3,
  AMD64_ST0_REGNUM + 4, AMD64_ST0_REGNUM + 5,
  AMD64_ST0_REGNUM + 6, AMD64_ST0_REGNUM + 7,
  
  /* Control and Status Flags Register.  */
  AMD64_EFLAGS_REGNUM,

  /* Selector Registers.  */
  AMD64_ES_REGNUM,
  AMD64_CS_REGNUM,
  AMD64_SS_REGNUM,
  AMD64_DS_REGNUM,
  AMD64_FS_REGNUM,
  AMD64_GS_REGNUM,
  -1,
  -1,

  /* Segment Base Address Registers.  */
  -1,
  -1,
  -1,
  -1,

  /* Special Selector Registers.  */
  -1,
  -1,

  /* Floating Point Control Registers.  */
  AMD64_MXCSR_REGNUM,
  AMD64_FCTRL_REGNUM,
  AMD64_FSTAT_REGNUM
};

static const int amd64_dwarf_regmap_len =
  (sizeof (amd64_dwarf_regmap) / sizeof (amd64_dwarf_regmap[0]));

/* Convert DWARF register number REG to the appropriate register
   number used by GDB.  */

static int
amd64_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int ymm0_regnum = tdep->ymm0_regnum;
  int regnum = -1;

  if (reg >= 0 && reg < amd64_dwarf_regmap_len)
    regnum = amd64_dwarf_regmap[reg];

  if (regnum == -1)
    warning (_("Unmapped DWARF Register #%d encountered."), reg);
  else if (ymm0_regnum >= 0
	   && i386_xmm_regnum_p (gdbarch, regnum))
    regnum += ymm0_regnum - I387_XMM0_REGNUM (tdep);

  return regnum;
}

/* Map architectural register numbers to gdb register numbers.  */

static const int amd64_arch_regmap[16] =
{
  AMD64_RAX_REGNUM,	/* %rax */
  AMD64_RCX_REGNUM,	/* %rcx */
  AMD64_RDX_REGNUM,	/* %rdx */
  AMD64_RBX_REGNUM,	/* %rbx */
  AMD64_RSP_REGNUM,	/* %rsp */
  AMD64_RBP_REGNUM,	/* %rbp */
  AMD64_RSI_REGNUM,	/* %rsi */
  AMD64_RDI_REGNUM,	/* %rdi */
  AMD64_R8_REGNUM,	/* %r8 */
  AMD64_R9_REGNUM,	/* %r9 */
  AMD64_R10_REGNUM,	/* %r10 */
  AMD64_R11_REGNUM,	/* %r11 */
  AMD64_R12_REGNUM,	/* %r12 */
  AMD64_R13_REGNUM,	/* %r13 */
  AMD64_R14_REGNUM,	/* %r14 */
  AMD64_R15_REGNUM	/* %r15 */
};

static const int amd64_arch_regmap_len =
  (sizeof (amd64_arch_regmap) / sizeof (amd64_arch_regmap[0]));

/* Convert architectural register number REG to the appropriate register
   number used by GDB.  */

static int
amd64_arch_reg_to_regnum (int reg)
{
  gdb_assert (reg >= 0 && reg < amd64_arch_regmap_len);

  return amd64_arch_regmap[reg];
}

/* Register names for byte pseudo-registers.  */

static const char *amd64_byte_names[] =
{
  "al", "bl", "cl", "dl", "sil", "dil", "bpl", "spl",
  "r8l", "r9l", "r10l", "r11l", "r12l", "r13l", "r14l", "r15l",
  "ah", "bh", "ch", "dh"
};

/* Number of lower byte registers.  */
#define AMD64_NUM_LOWER_BYTE_REGS 16

/* Register names for word pseudo-registers.  */

static const char *amd64_word_names[] =
{
  "ax", "bx", "cx", "dx", "si", "di", "bp", "", 
  "r8w", "r9w", "r10w", "r11w", "r12w", "r13w", "r14w", "r15w"
};

/* Register names for dword pseudo-registers.  */

static const char *amd64_dword_names[] =
{
  "eax", "ebx", "ecx", "edx", "esi", "edi", "ebp", "esp", 
  "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d", "r15d",
  "eip"
};

/* Return the name of register REGNUM.  */

static const char *
amd64_pseudo_register_name (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  if (i386_byte_regnum_p (gdbarch, regnum))
    return amd64_byte_names[regnum - tdep->al_regnum];
  else if (i386_ymm_regnum_p (gdbarch, regnum))
    return amd64_ymm_names[regnum - tdep->ymm0_regnum];
  else if (i386_word_regnum_p (gdbarch, regnum))
    return amd64_word_names[regnum - tdep->ax_regnum];
  else if (i386_dword_regnum_p (gdbarch, regnum))
    return amd64_dword_names[regnum - tdep->eax_regnum];
  else
    return i386_pseudo_register_name (gdbarch, regnum);
}

static struct value *
amd64_pseudo_register_read_value (struct gdbarch *gdbarch,
				  struct regcache *regcache,
				  int regnum)
{
  gdb_byte raw_buf[MAX_REGISTER_SIZE];
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum register_status status;
  struct value *result_value;
  gdb_byte *buf;

  result_value = allocate_value (register_type (gdbarch, regnum));
  VALUE_LVAL (result_value) = lval_register;
  VALUE_REGNUM (result_value) = regnum;
  buf = value_contents_raw (result_value);

  if (i386_byte_regnum_p (gdbarch, regnum))
    {
      int gpnum = regnum - tdep->al_regnum;

      /* Extract (always little endian).  */
      if (gpnum >= AMD64_NUM_LOWER_BYTE_REGS)
	{
	  /* Special handling for AH, BH, CH, DH.  */
	  status = regcache_raw_read (regcache,
				      gpnum - AMD64_NUM_LOWER_BYTE_REGS,
				      raw_buf);
	  if (status == REG_VALID)
	    memcpy (buf, raw_buf + 1, 1);
	  else
	    mark_value_bytes_unavailable (result_value, 0,
					  TYPE_LENGTH (value_type (result_value)));
	}
      else
	{
	  status = regcache_raw_read (regcache, gpnum, raw_buf);
	  if (status == REG_VALID)
	    memcpy (buf, raw_buf, 1);
	  else
	    mark_value_bytes_unavailable (result_value, 0,
					  TYPE_LENGTH (value_type (result_value)));
	}
    }
  else if (i386_dword_regnum_p (gdbarch, regnum))
    {
      int gpnum = regnum - tdep->eax_regnum;
      /* Extract (always little endian).  */
      status = regcache_raw_read (regcache, gpnum, raw_buf);
      if (status == REG_VALID)
	memcpy (buf, raw_buf, 4);
      else
	mark_value_bytes_unavailable (result_value, 0,
				      TYPE_LENGTH (value_type (result_value)));
    }
  else
    i386_pseudo_register_read_into_value (gdbarch, regcache, regnum,
					  result_value);

  return result_value;
}

static void
amd64_pseudo_register_write (struct gdbarch *gdbarch,
			     struct regcache *regcache,
			     int regnum, const gdb_byte *buf)
{
  gdb_byte raw_buf[MAX_REGISTER_SIZE];
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (i386_byte_regnum_p (gdbarch, regnum))
    {
      int gpnum = regnum - tdep->al_regnum;

      if (gpnum >= AMD64_NUM_LOWER_BYTE_REGS)
	{
	  /* Read ... AH, BH, CH, DH.  */
	  regcache_raw_read (regcache,
			     gpnum - AMD64_NUM_LOWER_BYTE_REGS, raw_buf);
	  /* ... Modify ... (always little endian).  */
	  memcpy (raw_buf + 1, buf, 1);
	  /* ... Write.  */
	  regcache_raw_write (regcache,
			      gpnum - AMD64_NUM_LOWER_BYTE_REGS, raw_buf);
	}
      else
	{
	  /* Read ...  */
	  regcache_raw_read (regcache, gpnum, raw_buf);
	  /* ... Modify ... (always little endian).  */
	  memcpy (raw_buf, buf, 1);
	  /* ... Write.  */
	  regcache_raw_write (regcache, gpnum, raw_buf);
	}
    }
  else if (i386_dword_regnum_p (gdbarch, regnum))
    {
      int gpnum = regnum - tdep->eax_regnum;

      /* Read ...  */
      regcache_raw_read (regcache, gpnum, raw_buf);
      /* ... Modify ... (always little endian).  */
      memcpy (raw_buf, buf, 4);
      /* ... Write.  */
      regcache_raw_write (regcache, gpnum, raw_buf);
    }
  else
    i386_pseudo_register_write (gdbarch, regcache, regnum, buf);
}



/* Register classes as defined in the psABI.  */

enum amd64_reg_class
{
  AMD64_INTEGER,
  AMD64_SSE,
  AMD64_SSEUP,
  AMD64_X87,
  AMD64_X87UP,
  AMD64_COMPLEX_X87,
  AMD64_NO_CLASS,
  AMD64_MEMORY
};

/* Return the union class of CLASS1 and CLASS2.  See the psABI for
   details.  */

static enum amd64_reg_class
amd64_merge_classes (enum amd64_reg_class class1, enum amd64_reg_class class2)
{
  /* Rule (a): If both classes are equal, this is the resulting class.  */
  if (class1 == class2)
    return class1;

  /* Rule (b): If one of the classes is NO_CLASS, the resulting class
     is the other class.  */
  if (class1 == AMD64_NO_CLASS)
    return class2;
  if (class2 == AMD64_NO_CLASS)
    return class1;

  /* Rule (c): If one of the classes is MEMORY, the result is MEMORY.  */
  if (class1 == AMD64_MEMORY || class2 == AMD64_MEMORY)
    return AMD64_MEMORY;

  /* Rule (d): If one of the classes is INTEGER, the result is INTEGER.  */
  if (class1 == AMD64_INTEGER || class2 == AMD64_INTEGER)
    return AMD64_INTEGER;

  /* Rule (e): If one of the classes is X87, X87UP, COMPLEX_X87 class,
     MEMORY is used as class.  */
  if (class1 == AMD64_X87 || class1 == AMD64_X87UP
      || class1 == AMD64_COMPLEX_X87 || class2 == AMD64_X87
      || class2 == AMD64_X87UP || class2 == AMD64_COMPLEX_X87)
    return AMD64_MEMORY;

  /* Rule (f): Otherwise class SSE is used.  */
  return AMD64_SSE;
}

static void amd64_classify (struct type *type, enum amd64_reg_class class[2]);

/* Return non-zero if TYPE is a non-POD structure or union type.  */

static int
amd64_non_pod_p (struct type *type)
{
  /* ??? A class with a base class certainly isn't POD, but does this
     catch all non-POD structure types?  */
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT && TYPE_N_BASECLASSES (type) > 0)
    return 1;

  return 0;
}

/* Classify TYPE according to the rules for aggregate (structures and
   arrays) and union types, and store the result in CLASS.  */

static void
amd64_classify_aggregate (struct type *type, enum amd64_reg_class class[2])
{
  /* 1. If the size of an object is larger than two eightbytes, or in
        C++, is a non-POD structure or union type, or contains
        unaligned fields, it has class memory.  */
  if (TYPE_LENGTH (type) > 16 || amd64_non_pod_p (type))
    {
      class[0] = class[1] = AMD64_MEMORY;
      return;
    }

  /* 2. Both eightbytes get initialized to class NO_CLASS.  */
  class[0] = class[1] = AMD64_NO_CLASS;

  /* 3. Each field of an object is classified recursively so that
        always two fields are considered. The resulting class is
        calculated according to the classes of the fields in the
        eightbyte: */

  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      struct type *subtype = check_typedef (TYPE_TARGET_TYPE (type));

      /* All fields in an array have the same type.  */
      amd64_classify (subtype, class);
      if (TYPE_LENGTH (type) > 8 && class[1] == AMD64_NO_CLASS)
	class[1] = class[0];
    }
  else
    {
      int i;

      /* Structure or union.  */
      gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT
		  || TYPE_CODE (type) == TYPE_CODE_UNION);

      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));
	  int pos = TYPE_FIELD_BITPOS (type, i) / 64;
	  enum amd64_reg_class subclass[2];
	  int bitsize = TYPE_FIELD_BITSIZE (type, i);
	  int endpos;

	  if (bitsize == 0)
	    bitsize = TYPE_LENGTH (subtype) * 8;
	  endpos = (TYPE_FIELD_BITPOS (type, i) + bitsize - 1) / 64;

	  /* Ignore static fields.  */
	  if (field_is_static (&TYPE_FIELD (type, i)))
	    continue;

	  gdb_assert (pos == 0 || pos == 1);

	  amd64_classify (subtype, subclass);
	  class[pos] = amd64_merge_classes (class[pos], subclass[0]);
	  if (bitsize <= 64 && pos == 0 && endpos == 1)
	    /* This is a bit of an odd case:  We have a field that would
	       normally fit in one of the two eightbytes, except that
	       it is placed in a way that this field straddles them.
	       This has been seen with a structure containing an array.

	       The ABI is a bit unclear in this case, but we assume that
	       this field's class (stored in subclass[0]) must also be merged
	       into class[1].  In other words, our field has a piece stored
	       in the second eight-byte, and thus its class applies to
	       the second eight-byte as well.

	       In the case where the field length exceeds 8 bytes,
	       it should not be necessary to merge the field class
	       into class[1].  As LEN > 8, subclass[1] is necessarily
	       different from AMD64_NO_CLASS.  If subclass[1] is equal
	       to subclass[0], then the normal class[1]/subclass[1]
	       merging will take care of everything.  For subclass[1]
	       to be different from subclass[0], I can only see the case
	       where we have a SSE/SSEUP or X87/X87UP pair, which both
	       use up all 16 bytes of the aggregate, and are already
	       handled just fine (because each portion sits on its own
	       8-byte).  */
	    class[1] = amd64_merge_classes (class[1], subclass[0]);
	  if (pos == 0)
	    class[1] = amd64_merge_classes (class[1], subclass[1]);
	}
    }

  /* 4. Then a post merger cleanup is done:  */

  /* Rule (a): If one of the classes is MEMORY, the whole argument is
     passed in memory.  */
  if (class[0] == AMD64_MEMORY || class[1] == AMD64_MEMORY)
    class[0] = class[1] = AMD64_MEMORY;

  /* Rule (b): If SSEUP is not preceded by SSE, it is converted to
     SSE.  */
  if (class[0] == AMD64_SSEUP)
    class[0] = AMD64_SSE;
  if (class[1] == AMD64_SSEUP && class[0] != AMD64_SSE)
    class[1] = AMD64_SSE;
}

/* Classify TYPE, and store the result in CLASS.  */

static void
amd64_classify (struct type *type, enum amd64_reg_class class[2])
{
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);

  class[0] = class[1] = AMD64_NO_CLASS;

  /* Arguments of types (signed and unsigned) _Bool, char, short, int,
     long, long long, and pointers are in the INTEGER class.  Similarly,
     range types, used by languages such as Ada, are also in the INTEGER
     class.  */
  if ((code == TYPE_CODE_INT || code == TYPE_CODE_ENUM
       || code == TYPE_CODE_BOOL || code == TYPE_CODE_RANGE
       || code == TYPE_CODE_CHAR
       || code == TYPE_CODE_PTR || code == TYPE_CODE_REF)
      && (len == 1 || len == 2 || len == 4 || len == 8))
    class[0] = AMD64_INTEGER;

  /* Arguments of types float, double, _Decimal32, _Decimal64 and __m64
     are in class SSE.  */
  else if ((code == TYPE_CODE_FLT || code == TYPE_CODE_DECFLOAT)
	   && (len == 4 || len == 8))
    /* FIXME: __m64 .  */
    class[0] = AMD64_SSE;

  /* Arguments of types __float128, _Decimal128 and __m128 are split into
     two halves.  The least significant ones belong to class SSE, the most
     significant one to class SSEUP.  */
  else if (code == TYPE_CODE_DECFLOAT && len == 16)
    /* FIXME: __float128, __m128.  */
    class[0] = AMD64_SSE, class[1] = AMD64_SSEUP;

  /* The 64-bit mantissa of arguments of type long double belongs to
     class X87, the 16-bit exponent plus 6 bytes of padding belongs to
     class X87UP.  */
  else if (code == TYPE_CODE_FLT && len == 16)
    /* Class X87 and X87UP.  */
    class[0] = AMD64_X87, class[1] = AMD64_X87UP;

  /* Arguments of complex T where T is one of the types float or
     double get treated as if they are implemented as:

     struct complexT {
       T real;
       T imag;
     };  */
  else if (code == TYPE_CODE_COMPLEX && len == 8)
    class[0] = AMD64_SSE;
  else if (code == TYPE_CODE_COMPLEX && len == 16)
    class[0] = class[1] = AMD64_SSE;

  /* A variable of type complex long double is classified as type
     COMPLEX_X87.  */
  else if (code == TYPE_CODE_COMPLEX && len == 32)
    class[0] = AMD64_COMPLEX_X87;

  /* Aggregates.  */
  else if (code == TYPE_CODE_ARRAY || code == TYPE_CODE_STRUCT
	   || code == TYPE_CODE_UNION)
    amd64_classify_aggregate (type, class);
}

static enum return_value_convention
amd64_return_value (struct gdbarch *gdbarch, struct value *function,
		    struct type *type, struct regcache *regcache,
		    gdb_byte *readbuf, const gdb_byte *writebuf)
{
  enum amd64_reg_class class[2];
  int len = TYPE_LENGTH (type);
  static int integer_regnum[] = { AMD64_RAX_REGNUM, AMD64_RDX_REGNUM };
  static int sse_regnum[] = { AMD64_XMM0_REGNUM, AMD64_XMM1_REGNUM };
  int integer_reg = 0;
  int sse_reg = 0;
  int i;

  gdb_assert (!(readbuf && writebuf));

  /* 1. Classify the return type with the classification algorithm.  */
  amd64_classify (type, class);

  /* 2. If the type has class MEMORY, then the caller provides space
     for the return value and passes the address of this storage in
     %rdi as if it were the first argument to the function.  In effect,
     this address becomes a hidden first argument.

     On return %rax will contain the address that has been passed in
     by the caller in %rdi.  */
  if (class[0] == AMD64_MEMORY)
    {
      /* As indicated by the comment above, the ABI guarantees that we
         can always find the return value just after the function has
         returned.  */

      if (readbuf)
	{
	  ULONGEST addr;

	  regcache_raw_read_unsigned (regcache, AMD64_RAX_REGNUM, &addr);
	  read_memory (addr, readbuf, TYPE_LENGTH (type));
	}

      return RETURN_VALUE_ABI_RETURNS_ADDRESS;
    }

  /* 8. If the class is COMPLEX_X87, the real part of the value is
        returned in %st0 and the imaginary part in %st1.  */
  if (class[0] == AMD64_COMPLEX_X87)
    {
      if (readbuf)
	{
	  regcache_raw_read (regcache, AMD64_ST0_REGNUM, readbuf);
	  regcache_raw_read (regcache, AMD64_ST1_REGNUM, readbuf + 16);
	}

      if (writebuf)
	{
	  i387_return_value (gdbarch, regcache);
	  regcache_raw_write (regcache, AMD64_ST0_REGNUM, writebuf);
	  regcache_raw_write (regcache, AMD64_ST1_REGNUM, writebuf + 16);

	  /* Fix up the tag word such that both %st(0) and %st(1) are
	     marked as valid.  */
	  regcache_raw_write_unsigned (regcache, AMD64_FTAG_REGNUM, 0xfff);
	}

      return RETURN_VALUE_REGISTER_CONVENTION;
    }

  gdb_assert (class[1] != AMD64_MEMORY);
  gdb_assert (len <= 16);

  for (i = 0; len > 0; i++, len -= 8)
    {
      int regnum = -1;
      int offset = 0;

      switch (class[i])
	{
	case AMD64_INTEGER:
	  /* 3. If the class is INTEGER, the next available register
	     of the sequence %rax, %rdx is used.  */
	  regnum = integer_regnum[integer_reg++];
	  break;

	case AMD64_SSE:
	  /* 4. If the class is SSE, the next available SSE register
             of the sequence %xmm0, %xmm1 is used.  */
	  regnum = sse_regnum[sse_reg++];
	  break;

	case AMD64_SSEUP:
	  /* 5. If the class is SSEUP, the eightbyte is passed in the
	     upper half of the last used SSE register.  */
	  gdb_assert (sse_reg > 0);
	  regnum = sse_regnum[sse_reg - 1];
	  offset = 8;
	  break;

	case AMD64_X87:
	  /* 6. If the class is X87, the value is returned on the X87
             stack in %st0 as 80-bit x87 number.  */
	  regnum = AMD64_ST0_REGNUM;
	  if (writebuf)
	    i387_return_value (gdbarch, regcache);
	  break;

	case AMD64_X87UP:
	  /* 7. If the class is X87UP, the value is returned together
             with the previous X87 value in %st0.  */
	  gdb_assert (i > 0 && class[0] == AMD64_X87);
	  regnum = AMD64_ST0_REGNUM;
	  offset = 8;
	  len = 2;
	  break;

	case AMD64_NO_CLASS:
	  continue;

	default:
	  gdb_assert (!"Unexpected register class.");
	}

      gdb_assert (regnum != -1);

      if (readbuf)
	regcache_raw_read_part (regcache, regnum, offset, min (len, 8),
				readbuf + i * 8);
      if (writebuf)
	regcache_raw_write_part (regcache, regnum, offset, min (len, 8),
				 writebuf + i * 8);
    }

  return RETURN_VALUE_REGISTER_CONVENTION;
}


static CORE_ADDR
amd64_push_arguments (struct regcache *regcache, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return)
{
  static int integer_regnum[] =
  {
    AMD64_RDI_REGNUM,		/* %rdi */
    AMD64_RSI_REGNUM,		/* %rsi */
    AMD64_RDX_REGNUM,		/* %rdx */
    AMD64_RCX_REGNUM,		/* %rcx */
    AMD64_R8_REGNUM,		/* %r8 */
    AMD64_R9_REGNUM		/* %r9 */
  };
  static int sse_regnum[] =
  {
    /* %xmm0 ... %xmm7 */
    AMD64_XMM0_REGNUM + 0, AMD64_XMM1_REGNUM,
    AMD64_XMM0_REGNUM + 2, AMD64_XMM0_REGNUM + 3,
    AMD64_XMM0_REGNUM + 4, AMD64_XMM0_REGNUM + 5,
    AMD64_XMM0_REGNUM + 6, AMD64_XMM0_REGNUM + 7,
  };
  struct value **stack_args = alloca (nargs * sizeof (struct value *));
  int num_stack_args = 0;
  int num_elements = 0;
  int element = 0;
  int integer_reg = 0;
  int sse_reg = 0;
  int i;

  /* Reserve a register for the "hidden" argument.  */
  if (struct_return)
    integer_reg++;

  for (i = 0; i < nargs; i++)
    {
      struct type *type = value_type (args[i]);
      int len = TYPE_LENGTH (type);
      enum amd64_reg_class class[2];
      int needed_integer_regs = 0;
      int needed_sse_regs = 0;
      int j;

      /* Classify argument.  */
      amd64_classify (type, class);

      /* Calculate the number of integer and SSE registers needed for
         this argument.  */
      for (j = 0; j < 2; j++)
	{
	  if (class[j] == AMD64_INTEGER)
	    needed_integer_regs++;
	  else if (class[j] == AMD64_SSE)
	    needed_sse_regs++;
	}

      /* Check whether enough registers are available, and if the
         argument should be passed in registers at all.  */
      if (integer_reg + needed_integer_regs > ARRAY_SIZE (integer_regnum)
	  || sse_reg + needed_sse_regs > ARRAY_SIZE (sse_regnum)
	  || (needed_integer_regs == 0 && needed_sse_regs == 0))
	{
	  /* The argument will be passed on the stack.  */
	  num_elements += ((len + 7) / 8);
	  stack_args[num_stack_args++] = args[i];
	}
      else
	{
	  /* The argument will be passed in registers.  */
	  const gdb_byte *valbuf = value_contents (args[i]);
	  gdb_byte buf[8];

	  gdb_assert (len <= 16);

	  for (j = 0; len > 0; j++, len -= 8)
	    {
	      int regnum = -1;
	      int offset = 0;

	      switch (class[j])
		{
		case AMD64_INTEGER:
		  regnum = integer_regnum[integer_reg++];
		  break;

		case AMD64_SSE:
		  regnum = sse_regnum[sse_reg++];
		  break;

		case AMD64_SSEUP:
		  gdb_assert (sse_reg > 0);
		  regnum = sse_regnum[sse_reg - 1];
		  offset = 8;
		  break;

		default:
		  gdb_assert (!"Unexpected register class.");
		}

	      gdb_assert (regnum != -1);
	      memset (buf, 0, sizeof buf);
	      memcpy (buf, valbuf + j * 8, min (len, 8));
	      regcache_raw_write_part (regcache, regnum, offset, 8, buf);
	    }
	}
    }

  /* Allocate space for the arguments on the stack.  */
  sp -= num_elements * 8;

  /* The psABI says that "The end of the input argument area shall be
     aligned on a 16 byte boundary."  */
  sp &= ~0xf;

  /* Write out the arguments to the stack.  */
  for (i = 0; i < num_stack_args; i++)
    {
      struct type *type = value_type (stack_args[i]);
      const gdb_byte *valbuf = value_contents (stack_args[i]);
      int len = TYPE_LENGTH (type);

      write_memory (sp + element * 8, valbuf, len);
      element += ((len + 7) / 8);
    }

  /* The psABI says that "For calls that may call functions that use
     varargs or stdargs (prototype-less calls or calls to functions
     containing ellipsis (...) in the declaration) %al is used as
     hidden argument to specify the number of SSE registers used.  */
  regcache_raw_write_unsigned (regcache, AMD64_RAX_REGNUM, sse_reg);
  return sp; 
}

static CORE_ADDR
amd64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
		       struct regcache *regcache, CORE_ADDR bp_addr,
		       int nargs, struct value **args,	CORE_ADDR sp,
		       int struct_return, CORE_ADDR struct_addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[8];

  /* Pass arguments.  */
  sp = amd64_push_arguments (regcache, nargs, args, sp, struct_return);

  /* Pass "hidden" argument".  */
  if (struct_return)
    {
      store_unsigned_integer (buf, 8, byte_order, struct_addr);
      regcache_cooked_write (regcache, AMD64_RDI_REGNUM, buf);
    }

  /* Store return address.  */
  sp -= 8;
  store_unsigned_integer (buf, 8, byte_order, bp_addr);
  write_memory (sp, buf, 8);

  /* Finally, update the stack pointer...  */
  store_unsigned_integer (buf, 8, byte_order, sp);
  regcache_cooked_write (regcache, AMD64_RSP_REGNUM, buf);

  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, AMD64_RBP_REGNUM, buf);

  return sp + 16;
}

/* Displaced instruction handling.  */

/* A partially decoded instruction.
   This contains enough details for displaced stepping purposes.  */

struct amd64_insn
{
  /* The number of opcode bytes.  */
  int opcode_len;
  /* The offset of the rex prefix or -1 if not present.  */
  int rex_offset;
  /* The offset to the first opcode byte.  */
  int opcode_offset;
  /* The offset to the modrm byte or -1 if not present.  */
  int modrm_offset;

  /* The raw instruction.  */
  gdb_byte *raw_insn;
};

struct displaced_step_closure
{
  /* For rip-relative insns, saved copy of the reg we use instead of %rip.  */
  int tmp_used;
  int tmp_regno;
  ULONGEST tmp_save;

  /* Details of the instruction.  */
  struct amd64_insn insn_details;

  /* Amount of space allocated to insn_buf.  */
  int max_len;

  /* The possibly modified insn.
     This is a variable-length field.  */
  gdb_byte insn_buf[1];
};

/* WARNING: Keep onebyte_has_modrm, twobyte_has_modrm in sync with
   ../opcodes/i386-dis.c (until libopcodes exports them, or an alternative,
   at which point delete these in favor of libopcodes' versions).  */

static const unsigned char onebyte_has_modrm[256] = {
  /*	   0 1 2 3 4 5 6 7 8 9 a b c d e f	  */
  /*	   -------------------------------	  */
  /* 00 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 00 */
  /* 10 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 10 */
  /* 20 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 20 */
  /* 30 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 30 */
  /* 40 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 40 */
  /* 50 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 50 */
  /* 60 */ 0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0, /* 60 */
  /* 70 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 70 */
  /* 80 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 80 */
  /* 90 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 90 */
  /* a0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* a0 */
  /* b0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* b0 */
  /* c0 */ 1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0, /* c0 */
  /* d0 */ 1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1, /* d0 */
  /* e0 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* e0 */
  /* f0 */ 0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1  /* f0 */
  /*	   -------------------------------	  */
  /*	   0 1 2 3 4 5 6 7 8 9 a b c d e f	  */
};

static const unsigned char twobyte_has_modrm[256] = {
  /*	   0 1 2 3 4 5 6 7 8 9 a b c d e f	  */
  /*	   -------------------------------	  */
  /* 00 */ 1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,1, /* 0f */
  /* 10 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 1f */
  /* 20 */ 1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1, /* 2f */
  /* 30 */ 0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0, /* 3f */
  /* 40 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 4f */
  /* 50 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 5f */
  /* 60 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 6f */
  /* 70 */ 1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1, /* 7f */
  /* 80 */ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 8f */
  /* 90 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* 9f */
  /* a0 */ 0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1, /* af */
  /* b0 */ 1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1, /* bf */
  /* c0 */ 1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0, /* cf */
  /* d0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* df */
  /* e0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ef */
  /* f0 */ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0  /* ff */
  /*	   -------------------------------	  */
  /*	   0 1 2 3 4 5 6 7 8 9 a b c d e f	  */
};

static int amd64_syscall_p (const struct amd64_insn *insn, int *lengthp);

static int
rex_prefix_p (gdb_byte pfx)
{
  return REX_PREFIX_P (pfx);
}

/* Skip the legacy instruction prefixes in INSN.
   We assume INSN is properly sentineled so we don't have to worry
   about falling off the end of the buffer.  */

static gdb_byte *
amd64_skip_prefixes (gdb_byte *insn)
{
  while (1)
    {
      switch (*insn)
	{
	case DATA_PREFIX_OPCODE:
	case ADDR_PREFIX_OPCODE:
	case CS_PREFIX_OPCODE:
	case DS_PREFIX_OPCODE:
	case ES_PREFIX_OPCODE:
	case FS_PREFIX_OPCODE:
	case GS_PREFIX_OPCODE:
	case SS_PREFIX_OPCODE:
	case LOCK_PREFIX_OPCODE:
	case REPE_PREFIX_OPCODE:
	case REPNE_PREFIX_OPCODE:
	  ++insn;
	  continue;
	default:
	  break;
	}
      break;
    }

  return insn;
}

/* Return an integer register (other than RSP) that is unused as an input
   operand in INSN.
   In order to not require adding a rex prefix if the insn doesn't already
   have one, the result is restricted to RAX ... RDI, sans RSP.
   The register numbering of the result follows architecture ordering,
   e.g. RDI = 7.  */

static int
amd64_get_unused_input_int_reg (const struct amd64_insn *details)
{
  /* 1 bit for each reg */
  int used_regs_mask = 0;

  /* There can be at most 3 int regs used as inputs in an insn, and we have
     7 to choose from (RAX ... RDI, sans RSP).
     This allows us to take a conservative approach and keep things simple.
     E.g. By avoiding RAX, we don't have to specifically watch for opcodes
     that implicitly specify RAX.  */

  /* Avoid RAX.  */
  used_regs_mask |= 1 << EAX_REG_NUM;
  /* Similarily avoid RDX, implicit operand in divides.  */
  used_regs_mask |= 1 << EDX_REG_NUM;
  /* Avoid RSP.  */
  used_regs_mask |= 1 << ESP_REG_NUM;

  /* If the opcode is one byte long and there's no ModRM byte,
     assume the opcode specifies a register.  */
  if (details->opcode_len == 1 && details->modrm_offset == -1)
    used_regs_mask |= 1 << (details->raw_insn[details->opcode_offset] & 7);

  /* Mark used regs in the modrm/sib bytes.  */
  if (details->modrm_offset != -1)
    {
      int modrm = details->raw_insn[details->modrm_offset];
      int mod = MODRM_MOD_FIELD (modrm);
      int reg = MODRM_REG_FIELD (modrm);
      int rm = MODRM_RM_FIELD (modrm);
      int have_sib = mod != 3 && rm == 4;

      /* Assume the reg field of the modrm byte specifies a register.  */
      used_regs_mask |= 1 << reg;

      if (have_sib)
	{
	  int base = SIB_BASE_FIELD (details->raw_insn[details->modrm_offset + 1]);
	  int idx = SIB_INDEX_FIELD (details->raw_insn[details->modrm_offset + 1]);
	  used_regs_mask |= 1 << base;
	  used_regs_mask |= 1 << idx;
	}
      else
	{
	  used_regs_mask |= 1 << rm;
	}
    }

  gdb_assert (used_regs_mask < 256);
  gdb_assert (used_regs_mask != 255);

  /* Finally, find a free reg.  */
  {
    int i;

    for (i = 0; i < 8; ++i)
      {
	if (! (used_regs_mask & (1 << i)))
	  return i;
      }

    /* We shouldn't get here.  */
    internal_error (__FILE__, __LINE__, _("unable to find free reg"));
  }
}

/* Extract the details of INSN that we need.  */

static void
amd64_get_insn_details (gdb_byte *insn, struct amd64_insn *details)
{
  gdb_byte *start = insn;
  int need_modrm;

  details->raw_insn = insn;

  details->opcode_len = -1;
  details->rex_offset = -1;
  details->opcode_offset = -1;
  details->modrm_offset = -1;

  /* Skip legacy instruction prefixes.  */
  insn = amd64_skip_prefixes (insn);

  /* Skip REX instruction prefix.  */
  if (rex_prefix_p (*insn))
    {
      details->rex_offset = insn - start;
      ++insn;
    }

  details->opcode_offset = insn - start;

  if (*insn == TWO_BYTE_OPCODE_ESCAPE)
    {
      /* Two or three-byte opcode.  */
      ++insn;
      need_modrm = twobyte_has_modrm[*insn];

      /* Check for three-byte opcode.  */
      switch (*insn)
	{
	case 0x24:
	case 0x25:
	case 0x38:
	case 0x3a:
	case 0x7a:
	case 0x7b:
	  ++insn;
	  details->opcode_len = 3;
	  break;
	default:
	  details->opcode_len = 2;
	  break;
	}
    }
  else
    {
      /* One-byte opcode.  */
      need_modrm = onebyte_has_modrm[*insn];
      details->opcode_len = 1;
    }

  if (need_modrm)
    {
      ++insn;
      details->modrm_offset = insn - start;
    }
}

/* Update %rip-relative addressing in INSN.

   %rip-relative addressing only uses a 32-bit displacement.
   32 bits is not enough to be guaranteed to cover the distance between where
   the real instruction is and where its copy is.
   Convert the insn to use base+disp addressing.
   We set base = pc + insn_length so we can leave disp unchanged.  */

static void
fixup_riprel (struct gdbarch *gdbarch, struct displaced_step_closure *dsc,
	      CORE_ADDR from, CORE_ADDR to, struct regcache *regs)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  const struct amd64_insn *insn_details = &dsc->insn_details;
  int modrm_offset = insn_details->modrm_offset;
  gdb_byte *insn = insn_details->raw_insn + modrm_offset;
  CORE_ADDR rip_base;
  int32_t disp;
  int insn_length;
  int arch_tmp_regno, tmp_regno;
  ULONGEST orig_value;

  /* %rip+disp32 addressing mode, displacement follows ModRM byte.  */
  ++insn;

  /* Compute the rip-relative address.	*/
  disp = extract_signed_integer (insn, sizeof (int32_t), byte_order);
  insn_length = gdb_buffered_insn_length (gdbarch, dsc->insn_buf,
					  dsc->max_len, from);
  rip_base = from + insn_length;

  /* We need a register to hold the address.
     Pick one not used in the insn.
     NOTE: arch_tmp_regno uses architecture ordering, e.g. RDI = 7.  */
  arch_tmp_regno = amd64_get_unused_input_int_reg (insn_details);
  tmp_regno = amd64_arch_reg_to_regnum (arch_tmp_regno);

  /* REX.B should be unset as we were using rip-relative addressing,
     but ensure it's unset anyway, tmp_regno is not r8-r15.  */
  if (insn_details->rex_offset != -1)
    dsc->insn_buf[insn_details->rex_offset] &= ~REX_B;

  regcache_cooked_read_unsigned (regs, tmp_regno, &orig_value);
  dsc->tmp_regno = tmp_regno;
  dsc->tmp_save = orig_value;
  dsc->tmp_used = 1;

  /* Convert the ModRM field to be base+disp.  */
  dsc->insn_buf[modrm_offset] &= ~0xc7;
  dsc->insn_buf[modrm_offset] |= 0x80 + arch_tmp_regno;

  regcache_cooked_write_unsigned (regs, tmp_regno, rip_base);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog, "displaced: %%rip-relative addressing used.\n"
			"displaced: using temp reg %d, old value %s, new value %s\n",
			dsc->tmp_regno, paddress (gdbarch, dsc->tmp_save),
			paddress (gdbarch, rip_base));
}

static void
fixup_displaced_copy (struct gdbarch *gdbarch,
		      struct displaced_step_closure *dsc,
		      CORE_ADDR from, CORE_ADDR to, struct regcache *regs)
{
  const struct amd64_insn *details = &dsc->insn_details;

  if (details->modrm_offset != -1)
    {
      gdb_byte modrm = details->raw_insn[details->modrm_offset];

      if ((modrm & 0xc7) == 0x05)
	{
	  /* The insn uses rip-relative addressing.
	     Deal with it.  */
	  fixup_riprel (gdbarch, dsc, from, to, regs);
	}
    }
}

struct displaced_step_closure *
amd64_displaced_step_copy_insn (struct gdbarch *gdbarch,
				CORE_ADDR from, CORE_ADDR to,
				struct regcache *regs)
{
  int len = gdbarch_max_insn_length (gdbarch);
  /* Extra space for sentinels so fixup_{riprel,displaced_copy} don't have to
     continually watch for running off the end of the buffer.  */
  int fixup_sentinel_space = len;
  struct displaced_step_closure *dsc =
    xmalloc (sizeof (*dsc) + len + fixup_sentinel_space);
  gdb_byte *buf = &dsc->insn_buf[0];
  struct amd64_insn *details = &dsc->insn_details;

  dsc->tmp_used = 0;
  dsc->max_len = len + fixup_sentinel_space;

  read_memory (from, buf, len);

  /* Set up the sentinel space so we don't have to worry about running
     off the end of the buffer.  An excessive number of leading prefixes
     could otherwise cause this.  */
  memset (buf + len, 0, fixup_sentinel_space);

  amd64_get_insn_details (buf, details);

  /* GDB may get control back after the insn after the syscall.
     Presumably this is a kernel bug.
     If this is a syscall, make sure there's a nop afterwards.  */
  {
    int syscall_length;

    if (amd64_syscall_p (details, &syscall_length))
      buf[details->opcode_offset + syscall_length] = NOP_OPCODE;
  }

  /* Modify the insn to cope with the address where it will be executed from.
     In particular, handle any rip-relative addressing.	 */
  fixup_displaced_copy (gdbarch, dsc, from, to, regs);

  write_memory (to, buf, len);

  if (debug_displaced)
    {
      fprintf_unfiltered (gdb_stdlog, "displaced: copy %s->%s: ",
			  paddress (gdbarch, from), paddress (gdbarch, to));
      displaced_step_dump_bytes (gdb_stdlog, buf, len);
    }

  return dsc;
}

static int
amd64_absolute_jmp_p (const struct amd64_insn *details)
{
  const gdb_byte *insn = &details->raw_insn[details->opcode_offset];

  if (insn[0] == 0xff)
    {
      /* jump near, absolute indirect (/4) */
      if ((insn[1] & 0x38) == 0x20)
	return 1;

      /* jump far, absolute indirect (/5) */
      if ((insn[1] & 0x38) == 0x28)
	return 1;
    }

  return 0;
}

static int
amd64_absolute_call_p (const struct amd64_insn *details)
{
  const gdb_byte *insn = &details->raw_insn[details->opcode_offset];

  if (insn[0] == 0xff)
    {
      /* Call near, absolute indirect (/2) */
      if ((insn[1] & 0x38) == 0x10)
	return 1;

      /* Call far, absolute indirect (/3) */
      if ((insn[1] & 0x38) == 0x18)
	return 1;
    }

  return 0;
}

static int
amd64_ret_p (const struct amd64_insn *details)
{
  /* NOTE: gcc can emit "repz ; ret".  */
  const gdb_byte *insn = &details->raw_insn[details->opcode_offset];

  switch (insn[0])
    {
    case 0xc2: /* ret near, pop N bytes */
    case 0xc3: /* ret near */
    case 0xca: /* ret far, pop N bytes */
    case 0xcb: /* ret far */
    case 0xcf: /* iret */
      return 1;

    default:
      return 0;
    }
}

static int
amd64_call_p (const struct amd64_insn *details)
{
  const gdb_byte *insn = &details->raw_insn[details->opcode_offset];

  if (amd64_absolute_call_p (details))
    return 1;

  /* call near, relative */
  if (insn[0] == 0xe8)
    return 1;

  return 0;
}

/* Return non-zero if INSN is a system call, and set *LENGTHP to its
   length in bytes.  Otherwise, return zero.  */

static int
amd64_syscall_p (const struct amd64_insn *details, int *lengthp)
{
  const gdb_byte *insn = &details->raw_insn[details->opcode_offset];

  if (insn[0] == 0x0f && insn[1] == 0x05)
    {
      *lengthp = 2;
      return 1;
    }

  return 0;
}

/* Fix up the state of registers and memory after having single-stepped
   a displaced instruction.  */

void
amd64_displaced_step_fixup (struct gdbarch *gdbarch,
			    struct displaced_step_closure *dsc,
			    CORE_ADDR from, CORE_ADDR to,
			    struct regcache *regs)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  /* The offset we applied to the instruction's address.  */
  ULONGEST insn_offset = to - from;
  gdb_byte *insn = dsc->insn_buf;
  const struct amd64_insn *insn_details = &dsc->insn_details;

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: fixup (%s, %s), "
			"insn = 0x%02x 0x%02x ...\n",
			paddress (gdbarch, from), paddress (gdbarch, to),
			insn[0], insn[1]);

  /* If we used a tmp reg, restore it.	*/

  if (dsc->tmp_used)
    {
      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog, "displaced: restoring reg %d to %s\n",
			    dsc->tmp_regno, paddress (gdbarch, dsc->tmp_save));
      regcache_cooked_write_unsigned (regs, dsc->tmp_regno, dsc->tmp_save);
    }

  /* The list of issues to contend with here is taken from
     resume_execution in arch/x86/kernel/kprobes.c, Linux 2.6.28.
     Yay for Free Software!  */

  /* Relocate the %rip back to the program's instruction stream,
     if necessary.  */

  /* Except in the case of absolute or indirect jump or call
     instructions, or a return instruction, the new rip is relative to
     the displaced instruction; make it relative to the original insn.
     Well, signal handler returns don't need relocation either, but we use the
     value of %rip to recognize those; see below.  */
  if (! amd64_absolute_jmp_p (insn_details)
      && ! amd64_absolute_call_p (insn_details)
      && ! amd64_ret_p (insn_details))
    {
      ULONGEST orig_rip;
      int insn_len;

      regcache_cooked_read_unsigned (regs, AMD64_RIP_REGNUM, &orig_rip);

      /* A signal trampoline system call changes the %rip, resuming
	 execution of the main program after the signal handler has
	 returned.  That makes them like 'return' instructions; we
	 shouldn't relocate %rip.

	 But most system calls don't, and we do need to relocate %rip.

	 Our heuristic for distinguishing these cases: if stepping
	 over the system call instruction left control directly after
	 the instruction, the we relocate --- control almost certainly
	 doesn't belong in the displaced copy.	Otherwise, we assume
	 the instruction has put control where it belongs, and leave
	 it unrelocated.  Goodness help us if there are PC-relative
	 system calls.	*/
      if (amd64_syscall_p (insn_details, &insn_len)
	  && orig_rip != to + insn_len
	  /* GDB can get control back after the insn after the syscall.
	     Presumably this is a kernel bug.
	     Fixup ensures its a nop, we add one to the length for it.  */
	  && orig_rip != to + insn_len + 1)
	{
	  if (debug_displaced)
	    fprintf_unfiltered (gdb_stdlog,
				"displaced: syscall changed %%rip; "
				"not relocating\n");
	}
      else
	{
	  ULONGEST rip = orig_rip - insn_offset;

	  /* If we just stepped over a breakpoint insn, we don't backup
	     the pc on purpose; this is to match behaviour without
	     stepping.  */

	  regcache_cooked_write_unsigned (regs, AMD64_RIP_REGNUM, rip);

	  if (debug_displaced)
	    fprintf_unfiltered (gdb_stdlog,
				"displaced: "
				"relocated %%rip from %s to %s\n",
				paddress (gdbarch, orig_rip),
				paddress (gdbarch, rip));
	}
    }

  /* If the instruction was PUSHFL, then the TF bit will be set in the
     pushed value, and should be cleared.  We'll leave this for later,
     since GDB already messes up the TF flag when stepping over a
     pushfl.  */

  /* If the instruction was a call, the return address now atop the
     stack is the address following the copied instruction.  We need
     to make it the address following the original instruction.	 */
  if (amd64_call_p (insn_details))
    {
      ULONGEST rsp;
      ULONGEST retaddr;
      const ULONGEST retaddr_len = 8;

      regcache_cooked_read_unsigned (regs, AMD64_RSP_REGNUM, &rsp);
      retaddr = read_memory_unsigned_integer (rsp, retaddr_len, byte_order);
      retaddr = (retaddr - insn_offset) & 0xffffffffUL;
      write_memory_unsigned_integer (rsp, retaddr_len, byte_order, retaddr);

      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog,
			    "displaced: relocated return addr at %s "
			    "to %s\n",
			    paddress (gdbarch, rsp),
			    paddress (gdbarch, retaddr));
    }
}

/* If the instruction INSN uses RIP-relative addressing, return the
   offset into the raw INSN where the displacement to be adjusted is
   found.  Returns 0 if the instruction doesn't use RIP-relative
   addressing.  */

static int
rip_relative_offset (struct amd64_insn *insn)
{
  if (insn->modrm_offset != -1)
    {
      gdb_byte modrm = insn->raw_insn[insn->modrm_offset];

      if ((modrm & 0xc7) == 0x05)
	{
	  /* The displacement is found right after the ModRM byte.  */
	  return insn->modrm_offset + 1;
	}
    }

  return 0;
}

static void
append_insns (CORE_ADDR *to, ULONGEST len, const gdb_byte *buf)
{
  target_write_memory (*to, buf, len);
  *to += len;
}

static void
amd64_relocate_instruction (struct gdbarch *gdbarch,
			    CORE_ADDR *to, CORE_ADDR oldloc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int len = gdbarch_max_insn_length (gdbarch);
  /* Extra space for sentinels.  */
  int fixup_sentinel_space = len;
  gdb_byte *buf = xmalloc (len + fixup_sentinel_space);
  struct amd64_insn insn_details;
  int offset = 0;
  LONGEST rel32, newrel;
  gdb_byte *insn;
  int insn_length;

  read_memory (oldloc, buf, len);

  /* Set up the sentinel space so we don't have to worry about running
     off the end of the buffer.  An excessive number of leading prefixes
     could otherwise cause this.  */
  memset (buf + len, 0, fixup_sentinel_space);

  insn = buf;
  amd64_get_insn_details (insn, &insn_details);

  insn_length = gdb_buffered_insn_length (gdbarch, insn, len, oldloc);

  /* Skip legacy instruction prefixes.  */
  insn = amd64_skip_prefixes (insn);

  /* Adjust calls with 32-bit relative addresses as push/jump, with
     the address pushed being the location where the original call in
     the user program would return to.  */
  if (insn[0] == 0xe8)
    {
      gdb_byte push_buf[16];
      unsigned int ret_addr;

      /* Where "ret" in the original code will return to.  */
      ret_addr = oldloc + insn_length;
      push_buf[0] = 0x68; /* pushq $...  */
      store_unsigned_integer (&push_buf[1], 4, byte_order, ret_addr);
      /* Push the push.  */
      append_insns (to, 5, push_buf);

      /* Convert the relative call to a relative jump.  */
      insn[0] = 0xe9;

      /* Adjust the destination offset.  */
      rel32 = extract_signed_integer (insn + 1, 4, byte_order);
      newrel = (oldloc - *to) + rel32;
      store_signed_integer (insn + 1, 4, byte_order, newrel);

      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog,
			    "Adjusted insn rel32=%s at %s to"
			    " rel32=%s at %s\n",
			    hex_string (rel32), paddress (gdbarch, oldloc),
			    hex_string (newrel), paddress (gdbarch, *to));

      /* Write the adjusted jump into its displaced location.  */
      append_insns (to, 5, insn);
      return;
    }

  offset = rip_relative_offset (&insn_details);
  if (!offset)
    {
      /* Adjust jumps with 32-bit relative addresses.  Calls are
	 already handled above.  */
      if (insn[0] == 0xe9)
	offset = 1;
      /* Adjust conditional jumps.  */
      else if (insn[0] == 0x0f && (insn[1] & 0xf0) == 0x80)
	offset = 2;
    }

  if (offset)
    {
      rel32 = extract_signed_integer (insn + offset, 4, byte_order);
      newrel = (oldloc - *to) + rel32;
      store_signed_integer (insn + offset, 4, byte_order, newrel);
      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog,
			    "Adjusted insn rel32=%s at %s to"
			    " rel32=%s at %s\n",
			    hex_string (rel32), paddress (gdbarch, oldloc),
			    hex_string (newrel), paddress (gdbarch, *to));
    }

  /* Write the adjusted instruction into its displaced location.  */
  append_insns (to, insn_length, buf);
}


/* The maximum number of saved registers.  This should include %rip.  */
#define AMD64_NUM_SAVED_REGS	AMD64_NUM_GREGS

struct amd64_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  int base_p;
  CORE_ADDR sp_offset;
  CORE_ADDR pc;

  /* Saved registers.  */
  CORE_ADDR saved_regs[AMD64_NUM_SAVED_REGS];
  CORE_ADDR saved_sp;
  int saved_sp_reg;

  /* Do we have a frame?  */
  int frameless_p;
};

/* Initialize a frame cache.  */

static void
amd64_init_frame_cache (struct amd64_frame_cache *cache)
{
  int i;

  /* Base address.  */
  cache->base = 0;
  cache->base_p = 0;
  cache->sp_offset = -8;
  cache->pc = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %rbp is supposed to be stored).
     The values start out as being offsets, and are later converted to
     addresses (at which point -1 is interpreted as an address, still meaning
     "invalid").  */
  for (i = 0; i < AMD64_NUM_SAVED_REGS; i++)
    cache->saved_regs[i] = -1;
  cache->saved_sp = 0;
  cache->saved_sp_reg = -1;

  /* Frameless until proven otherwise.  */
  cache->frameless_p = 1;
}

/* Allocate and initialize a frame cache.  */

static struct amd64_frame_cache *
amd64_alloc_frame_cache (void)
{
  struct amd64_frame_cache *cache;

  cache = FRAME_OBSTACK_ZALLOC (struct amd64_frame_cache);
  amd64_init_frame_cache (cache);
  return cache;
}

/* GCC 4.4 and later, can put code in the prologue to realign the
   stack pointer.  Check whether PC points to such code, and update
   CACHE accordingly.  Return the first instruction after the code
   sequence or CURRENT_PC, whichever is smaller.  If we don't
   recognize the code, return PC.  */

static CORE_ADDR
amd64_analyze_stack_align (CORE_ADDR pc, CORE_ADDR current_pc,
			   struct amd64_frame_cache *cache)
{
  /* There are 2 code sequences to re-align stack before the frame
     gets set up:

	1. Use a caller-saved saved register:

		leaq  8(%rsp), %reg
		andq  $-XXX, %rsp
		pushq -8(%reg)

	2. Use a callee-saved saved register:

		pushq %reg
		leaq  16(%rsp), %reg
		andq  $-XXX, %rsp
		pushq -8(%reg)

     "andq $-XXX, %rsp" can be either 4 bytes or 7 bytes:
     
     	0x48 0x83 0xe4 0xf0			andq $-16, %rsp
     	0x48 0x81 0xe4 0x00 0xff 0xff 0xff	andq $-256, %rsp
   */

  gdb_byte buf[18];
  int reg, r;
  int offset, offset_and;

  if (target_read_memory (pc, buf, sizeof buf))
    return pc;

  /* Check caller-saved saved register.  The first instruction has
     to be "leaq 8(%rsp), %reg".  */
  if ((buf[0] & 0xfb) == 0x48
      && buf[1] == 0x8d
      && buf[3] == 0x24
      && buf[4] == 0x8)
    {
      /* MOD must be binary 10 and R/M must be binary 100.  */
      if ((buf[2] & 0xc7) != 0x44)
	return pc;

      /* REG has register number.  */
      reg = (buf[2] >> 3) & 7;

      /* Check the REX.R bit.  */
      if (buf[0] == 0x4c)
	reg += 8;

      offset = 5;
    }
  else
    {
      /* Check callee-saved saved register.  The first instruction
	 has to be "pushq %reg".  */
      reg = 0;
      if ((buf[0] & 0xf8) == 0x50)
	offset = 0;
      else if ((buf[0] & 0xf6) == 0x40
	       && (buf[1] & 0xf8) == 0x50)
	{
	  /* Check the REX.B bit.  */
	  if ((buf[0] & 1) != 0)
	    reg = 8;

	  offset = 1;
	}
      else
	return pc;

      /* Get register.  */
      reg += buf[offset] & 0x7;

      offset++;

      /* The next instruction has to be "leaq 16(%rsp), %reg".  */
      if ((buf[offset] & 0xfb) != 0x48
	  || buf[offset + 1] != 0x8d
	  || buf[offset + 3] != 0x24
	  || buf[offset + 4] != 0x10)
	return pc;

      /* MOD must be binary 10 and R/M must be binary 100.  */
      if ((buf[offset + 2] & 0xc7) != 0x44)
	return pc;
      
      /* REG has register number.  */
      r = (buf[offset + 2] >> 3) & 7;

      /* Check the REX.R bit.  */
      if (buf[offset] == 0x4c)
	r += 8;

      /* Registers in pushq and leaq have to be the same.  */
      if (reg != r)
	return pc;

      offset += 5;
    }

  /* Rigister can't be %rsp nor %rbp.  */
  if (reg == 4 || reg == 5)
    return pc;

  /* The next instruction has to be "andq $-XXX, %rsp".  */
  if (buf[offset] != 0x48
      || buf[offset + 2] != 0xe4
      || (buf[offset + 1] != 0x81 && buf[offset + 1] != 0x83))
    return pc;

  offset_and = offset;
  offset += buf[offset + 1] == 0x81 ? 7 : 4;

  /* The next instruction has to be "pushq -8(%reg)".  */
  r = 0;
  if (buf[offset] == 0xff)
    offset++;
  else if ((buf[offset] & 0xf6) == 0x40
	   && buf[offset + 1] == 0xff)
    {
      /* Check the REX.B bit.  */
      if ((buf[offset] & 0x1) != 0)
	r = 8;
      offset += 2;
    }
  else
    return pc;

  /* 8bit -8 is 0xf8.  REG must be binary 110 and MOD must be binary
     01.  */
  if (buf[offset + 1] != 0xf8
      || (buf[offset] & 0xf8) != 0x70)
    return pc;

  /* R/M has register.  */
  r += buf[offset] & 7;

  /* Registers in leaq and pushq have to be the same.  */
  if (reg != r)
    return pc;

  if (current_pc > pc + offset_and)
    cache->saved_sp_reg = amd64_arch_reg_to_regnum (reg);

  return min (pc + offset + 2, current_pc);
}

/* Similar to amd64_analyze_stack_align for x32.  */

static CORE_ADDR
amd64_x32_analyze_stack_align (CORE_ADDR pc, CORE_ADDR current_pc,
			       struct amd64_frame_cache *cache) 
{
  /* There are 2 code sequences to re-align stack before the frame
     gets set up:

	1. Use a caller-saved saved register:

		leaq  8(%rsp), %reg
		andq  $-XXX, %rsp
		pushq -8(%reg)

	   or

		[addr32] leal  8(%rsp), %reg
		andl  $-XXX, %esp
		[addr32] pushq -8(%reg)

	2. Use a callee-saved saved register:

		pushq %reg
		leaq  16(%rsp), %reg
		andq  $-XXX, %rsp
		pushq -8(%reg)

	   or

		pushq %reg
		[addr32] leal  16(%rsp), %reg
		andl  $-XXX, %esp
		[addr32] pushq -8(%reg)

     "andq $-XXX, %rsp" can be either 4 bytes or 7 bytes:
     
     	0x48 0x83 0xe4 0xf0			andq $-16, %rsp
     	0x48 0x81 0xe4 0x00 0xff 0xff 0xff	andq $-256, %rsp

     "andl $-XXX, %esp" can be either 3 bytes or 6 bytes:
     
     	0x83 0xe4 0xf0			andl $-16, %esp
     	0x81 0xe4 0x00 0xff 0xff 0xff	andl $-256, %esp
   */

  gdb_byte buf[19];
  int reg, r;
  int offset, offset_and;

  if (target_read_memory (pc, buf, sizeof buf))
    return pc;

  /* Skip optional addr32 prefix.  */
  offset = buf[0] == 0x67 ? 1 : 0;

  /* Check caller-saved saved register.  The first instruction has
     to be "leaq 8(%rsp), %reg" or "leal 8(%rsp), %reg".  */
  if (((buf[offset] & 0xfb) == 0x48 || (buf[offset] & 0xfb) == 0x40)
      && buf[offset + 1] == 0x8d
      && buf[offset + 3] == 0x24
      && buf[offset + 4] == 0x8)
    {
      /* MOD must be binary 10 and R/M must be binary 100.  */
      if ((buf[offset + 2] & 0xc7) != 0x44)
	return pc;

      /* REG has register number.  */
      reg = (buf[offset + 2] >> 3) & 7;

      /* Check the REX.R bit.  */
      if ((buf[offset] & 0x4) != 0)
	reg += 8;

      offset += 5;
    }
  else
    {
      /* Check callee-saved saved register.  The first instruction
	 has to be "pushq %reg".  */
      reg = 0;
      if ((buf[offset] & 0xf6) == 0x40
	  && (buf[offset + 1] & 0xf8) == 0x50)
	{
	  /* Check the REX.B bit.  */
	  if ((buf[offset] & 1) != 0)
	    reg = 8;

	  offset += 1;
	}
      else if ((buf[offset] & 0xf8) != 0x50)
	return pc;

      /* Get register.  */
      reg += buf[offset] & 0x7;

      offset++;

      /* Skip optional addr32 prefix.  */
      if (buf[offset] == 0x67)
	offset++;

      /* The next instruction has to be "leaq 16(%rsp), %reg" or
	 "leal 16(%rsp), %reg".  */
      if (((buf[offset] & 0xfb) != 0x48 && (buf[offset] & 0xfb) != 0x40)
	  || buf[offset + 1] != 0x8d
	  || buf[offset + 3] != 0x24
	  || buf[offset + 4] != 0x10)
	return pc;

      /* MOD must be binary 10 and R/M must be binary 100.  */
      if ((buf[offset + 2] & 0xc7) != 0x44)
	return pc;
      
      /* REG has register number.  */
      r = (buf[offset + 2] >> 3) & 7;

      /* Check the REX.R bit.  */
      if ((buf[offset] & 0x4) != 0)
	r += 8;

      /* Registers in pushq and leaq have to be the same.  */
      if (reg != r)
	return pc;

      offset += 5;
    }

  /* Rigister can't be %rsp nor %rbp.  */
  if (reg == 4 || reg == 5)
    return pc;

  /* The next instruction may be "andq $-XXX, %rsp" or
     "andl $-XXX, %esp".  */
  if (buf[offset] != 0x48)
    offset--;

  if (buf[offset + 2] != 0xe4
      || (buf[offset + 1] != 0x81 && buf[offset + 1] != 0x83))
    return pc;

  offset_and = offset;
  offset += buf[offset + 1] == 0x81 ? 7 : 4;

  /* Skip optional addr32 prefix.  */
  if (buf[offset] == 0x67)
    offset++;

  /* The next instruction has to be "pushq -8(%reg)".  */
  r = 0;
  if (buf[offset] == 0xff)
    offset++;
  else if ((buf[offset] & 0xf6) == 0x40
	   && buf[offset + 1] == 0xff)
    {
      /* Check the REX.B bit.  */
      if ((buf[offset] & 0x1) != 0)
	r = 8;
      offset += 2;
    }
  else
    return pc;

  /* 8bit -8 is 0xf8.  REG must be binary 110 and MOD must be binary
     01.  */
  if (buf[offset + 1] != 0xf8
      || (buf[offset] & 0xf8) != 0x70)
    return pc;

  /* R/M has register.  */
  r += buf[offset] & 7;

  /* Registers in leaq and pushq have to be the same.  */
  if (reg != r)
    return pc;

  if (current_pc > pc + offset_and)
    cache->saved_sp_reg = amd64_arch_reg_to_regnum (reg);

  return min (pc + offset + 2, current_pc);
}

/* Do a limited analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.

   We will handle only functions beginning with:

      pushq %rbp        0x55
      movq %rsp, %rbp   0x48 0x89 0xe5 (or 0x48 0x8b 0xec)

   or (for the X32 ABI):

      pushq %rbp        0x55
      movl %esp, %ebp   0x89 0xe5 (or 0x8b 0xec)

   Any function that doesn't start with one of these sequences will be
   assumed to have no prologue and thus no valid frame pointer in
   %rbp.  */

static CORE_ADDR
amd64_analyze_prologue (struct gdbarch *gdbarch,
			CORE_ADDR pc, CORE_ADDR current_pc,
			struct amd64_frame_cache *cache)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  /* There are two variations of movq %rsp, %rbp.  */
  static const gdb_byte mov_rsp_rbp_1[3] = { 0x48, 0x89, 0xe5 };
  static const gdb_byte mov_rsp_rbp_2[3] = { 0x48, 0x8b, 0xec };
  /* Ditto for movl %esp, %ebp.  */
  static const gdb_byte mov_esp_ebp_1[2] = { 0x89, 0xe5 };
  static const gdb_byte mov_esp_ebp_2[2] = { 0x8b, 0xec };

  gdb_byte buf[3];
  gdb_byte op;

  if (current_pc <= pc)
    return current_pc;

  if (gdbarch_ptr_bit (gdbarch) == 32)
    pc = amd64_x32_analyze_stack_align (pc, current_pc, cache);
  else
    pc = amd64_analyze_stack_align (pc, current_pc, cache);

  op = read_memory_unsigned_integer (pc, 1, byte_order);

  if (op == 0x55)		/* pushq %rbp */
    {
      /* Take into account that we've executed the `pushq %rbp' that
         starts this instruction sequence.  */
      cache->saved_regs[AMD64_RBP_REGNUM] = 0;
      cache->sp_offset += 8;

      /* If that's all, return now.  */
      if (current_pc <= pc + 1)
        return current_pc;

      read_memory (pc + 1, buf, 3);

      /* Check for `movq %rsp, %rbp'.  */
      if (memcmp (buf, mov_rsp_rbp_1, 3) == 0
	  || memcmp (buf, mov_rsp_rbp_2, 3) == 0)
	{
	  /* OK, we actually have a frame.  */
	  cache->frameless_p = 0;
	  return pc + 4;
	}

      /* For X32, also check for `movq %esp, %ebp'.  */
      if (gdbarch_ptr_bit (gdbarch) == 32)
	{
	  if (memcmp (buf, mov_esp_ebp_1, 2) == 0
	      || memcmp (buf, mov_esp_ebp_2, 2) == 0)
	    {
	      /* OK, we actually have a frame.  */
	      cache->frameless_p = 0;
	      return pc + 3;
	    }
	}

      return pc + 1;
    }

  return pc;
}

/* Work around false termination of prologue - GCC PR debug/48827.

   START_PC is the first instruction of a function, PC is its minimal already
   determined advanced address.  Function returns PC if it has nothing to do.

   84 c0                test   %al,%al
   74 23                je     after
   <-- here is 0 lines advance - the false prologue end marker.
   0f 29 85 70 ff ff ff movaps %xmm0,-0x90(%rbp)
   0f 29 4d 80          movaps %xmm1,-0x80(%rbp)
   0f 29 55 90          movaps %xmm2,-0x70(%rbp)
   0f 29 5d a0          movaps %xmm3,-0x60(%rbp)
   0f 29 65 b0          movaps %xmm4,-0x50(%rbp)
   0f 29 6d c0          movaps %xmm5,-0x40(%rbp)
   0f 29 75 d0          movaps %xmm6,-0x30(%rbp)
   0f 29 7d e0          movaps %xmm7,-0x20(%rbp)
   after:  */

static CORE_ADDR
amd64_skip_xmm_prologue (CORE_ADDR pc, CORE_ADDR start_pc)
{
  struct symtab_and_line start_pc_sal, next_sal;
  gdb_byte buf[4 + 8 * 7];
  int offset, xmmreg;

  if (pc == start_pc)
    return pc;

  start_pc_sal = find_pc_sect_line (start_pc, NULL, 0);
  if (start_pc_sal.symtab == NULL
      || producer_is_gcc_ge_4 (start_pc_sal.symtab->producer) < 6
      || start_pc_sal.pc != start_pc || pc >= start_pc_sal.end)
    return pc;

  next_sal = find_pc_sect_line (start_pc_sal.end, NULL, 0);
  if (next_sal.line != start_pc_sal.line)
    return pc;

  /* START_PC can be from overlayed memory, ignored here.  */
  if (target_read_memory (next_sal.pc - 4, buf, sizeof (buf)) != 0)
    return pc;

  /* test %al,%al */
  if (buf[0] != 0x84 || buf[1] != 0xc0)
    return pc;
  /* je AFTER */
  if (buf[2] != 0x74)
    return pc;

  offset = 4;
  for (xmmreg = 0; xmmreg < 8; xmmreg++)
    {
      /* 0x0f 0x29 0b??000101 movaps %xmmreg?,-0x??(%rbp) */
      if (buf[offset] != 0x0f || buf[offset + 1] != 0x29
          || (buf[offset + 2] & 0x3f) != (xmmreg << 3 | 0x5))
	return pc;

      /* 0b01?????? */
      if ((buf[offset + 2] & 0xc0) == 0x40)
	{
	  /* 8-bit displacement.  */
	  offset += 4;
	}
      /* 0b10?????? */
      else if ((buf[offset + 2] & 0xc0) == 0x80)
	{
	  /* 32-bit displacement.  */
	  offset += 7;
	}
      else
	return pc;
    }

  /* je AFTER */
  if (offset - 4 != buf[3])
    return pc;

  return next_sal.end;
}

/* Return PC of first real instruction.  */

static CORE_ADDR
amd64_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
{
  struct amd64_frame_cache cache;
  CORE_ADDR pc;
  CORE_ADDR func_addr;

  if (find_pc_partial_function (start_pc, NULL, &func_addr, NULL))
    {
      CORE_ADDR post_prologue_pc
	= skip_prologue_using_sal (gdbarch, func_addr);
      struct symtab *s = find_pc_symtab (func_addr);

      /* Clang always emits a line note before the prologue and another
	 one after.  We trust clang to emit usable line notes.  */
      if (post_prologue_pc
	  && (s != NULL
	      && s->producer != NULL
	      && strncmp (s->producer, "clang ", sizeof ("clang ") - 1) == 0))
        return max (start_pc, post_prologue_pc);
    }

  amd64_init_frame_cache (&cache);
  pc = amd64_analyze_prologue (gdbarch, start_pc, 0xffffffffffffffffLL,
			       &cache);
  if (cache.frameless_p)
    return start_pc;

  return amd64_skip_xmm_prologue (pc, start_pc);
}


/* Normal frames.  */

static void
amd64_frame_cache_1 (struct frame_info *this_frame,
		     struct amd64_frame_cache *cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[8];
  int i;

  cache->pc = get_frame_func (this_frame);
  if (cache->pc != 0)
    amd64_analyze_prologue (gdbarch, cache->pc, get_frame_pc (this_frame),
			    cache);

  if (cache->frameless_p)
    {
      /* We didn't find a valid frame.  If we're at the start of a
	 function, or somewhere half-way its prologue, the function's
	 frame probably hasn't been fully setup yet.  Try to
	 reconstruct the base address for the stack frame by looking
	 at the stack pointer.  For truly "frameless" functions this
	 might work too.  */

      if (cache->saved_sp_reg != -1)
	{
	  /* Stack pointer has been saved.  */
	  get_frame_register (this_frame, cache->saved_sp_reg, buf);
	  cache->saved_sp = extract_unsigned_integer (buf, 8, byte_order);

	  /* We're halfway aligning the stack.  */
	  cache->base = ((cache->saved_sp - 8) & 0xfffffffffffffff0LL) - 8;
	  cache->saved_regs[AMD64_RIP_REGNUM] = cache->saved_sp - 8;

	  /* This will be added back below.  */
	  cache->saved_regs[AMD64_RIP_REGNUM] -= cache->base;
	}
      else
	{
	  get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);
	  cache->base = extract_unsigned_integer (buf, 8, byte_order)
			+ cache->sp_offset;
	}
    }
  else
    {
      get_frame_register (this_frame, AMD64_RBP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 8, byte_order);
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of %rsp in the calling frame.  */
  cache->saved_sp = cache->base + 16;

  /* For normal frames, %rip is stored at 8(%rbp).  If we don't have a
     frame we find it at the same offset from the reconstructed base
     address.  If we're halfway aligning the stack, %rip is handled
     differently (see above).  */
  if (!cache->frameless_p || cache->saved_sp_reg == -1)
    cache->saved_regs[AMD64_RIP_REGNUM] = 8;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < AMD64_NUM_SAVED_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;

  cache->base_p = 1;
}

static struct amd64_frame_cache *
amd64_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  volatile struct gdb_exception ex;
  struct amd64_frame_cache *cache;

  if (*this_cache)
    return *this_cache;

  cache = amd64_alloc_frame_cache ();
  *this_cache = cache;

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      amd64_frame_cache_1 (this_frame, cache);
    }
  if (ex.reason < 0 && ex.error != NOT_AVAILABLE_ERROR)
    throw_exception (ex);

  return cache;
}

static enum unwind_stop_reason
amd64_frame_unwind_stop_reason (struct frame_info *this_frame,
				void **this_cache)
{
  struct amd64_frame_cache *cache =
    amd64_frame_cache (this_frame, this_cache);

  if (!cache->base_p)
    return UNWIND_UNAVAILABLE;

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return UNWIND_OUTERMOST;

  return UNWIND_NO_REASON;
}

static void
amd64_frame_this_id (struct frame_info *this_frame, void **this_cache,
		     struct frame_id *this_id)
{
  struct amd64_frame_cache *cache =
    amd64_frame_cache (this_frame, this_cache);

  if (!cache->base_p)
    return;

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  (*this_id) = frame_id_build (cache->base + 16, cache->pc);
}

static struct value *
amd64_frame_prev_register (struct frame_info *this_frame, void **this_cache,
			   int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct amd64_frame_cache *cache =
    amd64_frame_cache (this_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (regnum == gdbarch_sp_regnum (gdbarch) && cache->saved_sp)
    return frame_unwind_got_constant (this_frame, regnum, cache->saved_sp);

  if (regnum < AMD64_NUM_SAVED_REGS && cache->saved_regs[regnum] != -1)
    return frame_unwind_got_memory (this_frame, regnum,
				    cache->saved_regs[regnum]);

  return frame_unwind_got_register (this_frame, regnum, regnum);
}

static const struct frame_unwind amd64_frame_unwind =
{
  NORMAL_FRAME,
  amd64_frame_unwind_stop_reason,
  amd64_frame_this_id,
  amd64_frame_prev_register,
  NULL,
  default_frame_sniffer
};

/* Generate a bytecode expression to get the value of the saved PC.  */

static void
amd64_gen_return_address (struct gdbarch *gdbarch,
			  struct agent_expr *ax, struct axs_value *value,
			  CORE_ADDR scope)
{
  /* The following sequence assumes the traditional use of the base
     register.  */
  ax_reg (ax, AMD64_RBP_REGNUM);
  ax_const_l (ax, 8);
  ax_simple (ax, aop_add);
  value->type = register_type (gdbarch, AMD64_RIP_REGNUM);
  value->kind = axs_lvalue_memory;
}


/* Signal trampolines.  */

/* FIXME: kettenis/20030419: Perhaps, we can unify the 32-bit and
   64-bit variants.  This would require using identical frame caches
   on both platforms.  */

static struct amd64_frame_cache *
amd64_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  volatile struct gdb_exception ex;
  struct amd64_frame_cache *cache;
  CORE_ADDR addr;
  gdb_byte buf[8];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = amd64_alloc_frame_cache ();

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 8, byte_order) - 8;

      addr = tdep->sigcontext_addr (this_frame);
      gdb_assert (tdep->sc_reg_offset);
      gdb_assert (tdep->sc_num_regs <= AMD64_NUM_SAVED_REGS);
      for (i = 0; i < tdep->sc_num_regs; i++)
	if (tdep->sc_reg_offset[i] != -1)
	  cache->saved_regs[i] = addr + tdep->sc_reg_offset[i];

      cache->base_p = 1;
    }
  if (ex.reason < 0 && ex.error != NOT_AVAILABLE_ERROR)
    throw_exception (ex);

  *this_cache = cache;
  return cache;
}

static enum unwind_stop_reason
amd64_sigtramp_frame_unwind_stop_reason (struct frame_info *this_frame,
					 void **this_cache)
{
  struct amd64_frame_cache *cache =
    amd64_sigtramp_frame_cache (this_frame, this_cache);

  if (!cache->base_p)
    return UNWIND_UNAVAILABLE;

  return UNWIND_NO_REASON;
}

static void
amd64_sigtramp_frame_this_id (struct frame_info *this_frame,
			      void **this_cache, struct frame_id *this_id)
{
  struct amd64_frame_cache *cache =
    amd64_sigtramp_frame_cache (this_frame, this_cache);

  if (!cache->base_p)
    return;

  (*this_id) = frame_id_build (cache->base + 16, get_frame_pc (this_frame));
}

static struct value *
amd64_sigtramp_frame_prev_register (struct frame_info *this_frame,
				    void **this_cache, int regnum)
{
  /* Make sure we've initialized the cache.  */
  amd64_sigtramp_frame_cache (this_frame, this_cache);

  return amd64_frame_prev_register (this_frame, this_cache, regnum);
}

static int
amd64_sigtramp_frame_sniffer (const struct frame_unwind *self,
			      struct frame_info *this_frame,
			      void **this_cache)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));

  /* We shouldn't even bother if we don't have a sigcontext_addr
     handler.  */
  if (tdep->sigcontext_addr == NULL)
    return 0;

  if (tdep->sigtramp_p != NULL)
    {
      if (tdep->sigtramp_p (this_frame))
	return 1;
    }

  if (tdep->sigtramp_start != 0)
    {
      CORE_ADDR pc = get_frame_pc (this_frame);

      gdb_assert (tdep->sigtramp_end != 0);
      if (pc >= tdep->sigtramp_start && pc < tdep->sigtramp_end)
	return 1;
    }

  return 0;
}

static const struct frame_unwind amd64_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  amd64_sigtramp_frame_unwind_stop_reason,
  amd64_sigtramp_frame_this_id,
  amd64_sigtramp_frame_prev_register,
  NULL,
  amd64_sigtramp_frame_sniffer
};


static CORE_ADDR
amd64_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct amd64_frame_cache *cache =
    amd64_frame_cache (this_frame, this_cache);

  return cache->base;
}

static const struct frame_base amd64_frame_base =
{
  &amd64_frame_unwind,
  amd64_frame_base_address,
  amd64_frame_base_address,
  amd64_frame_base_address
};

/* Normal frames, but in a function epilogue.  */

/* The epilogue is defined here as the 'ret' instruction, which will
   follow any instruction such as 'leave' or 'pop %ebp' that destroys
   the function's stack frame.  */

static int
amd64_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  gdb_byte insn;
  struct symtab *symtab;

  symtab = find_pc_symtab (pc);
  if (symtab && symtab->epilogue_unwind_valid)
    return 0;

  if (target_read_memory (pc, &insn, 1))
    return 0;   /* Can't read memory at pc.  */

  if (insn != 0xc3)     /* 'ret' instruction.  */
    return 0;

  return 1;
}

static int
amd64_epilogue_frame_sniffer (const struct frame_unwind *self,
			      struct frame_info *this_frame,
			      void **this_prologue_cache)
{
  if (frame_relative_level (this_frame) == 0)
    return amd64_in_function_epilogue_p (get_frame_arch (this_frame),
					 get_frame_pc (this_frame));
  else
    return 0;
}

static struct amd64_frame_cache *
amd64_epilogue_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  volatile struct gdb_exception ex;
  struct amd64_frame_cache *cache;
  gdb_byte buf[8];

  if (*this_cache)
    return *this_cache;

  cache = amd64_alloc_frame_cache ();
  *this_cache = cache;

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      /* Cache base will be %esp plus cache->sp_offset (-8).  */
      get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 8,
					      byte_order) + cache->sp_offset;

      /* Cache pc will be the frame func.  */
      cache->pc = get_frame_pc (this_frame);

      /* The saved %esp will be at cache->base plus 16.  */
      cache->saved_sp = cache->base + 16;

      /* The saved %eip will be at cache->base plus 8.  */
      cache->saved_regs[AMD64_RIP_REGNUM] = cache->base + 8;

      cache->base_p = 1;
    }
  if (ex.reason < 0 && ex.error != NOT_AVAILABLE_ERROR)
    throw_exception (ex);

  return cache;
}

static enum unwind_stop_reason
amd64_epilogue_frame_unwind_stop_reason (struct frame_info *this_frame,
					 void **this_cache)
{
  struct amd64_frame_cache *cache
    = amd64_epilogue_frame_cache (this_frame, this_cache);

  if (!cache->base_p)
    return UNWIND_UNAVAILABLE;

  return UNWIND_NO_REASON;
}

static void
amd64_epilogue_frame_this_id (struct frame_info *this_frame,
			      void **this_cache,
			      struct frame_id *this_id)
{
  struct amd64_frame_cache *cache = amd64_epilogue_frame_cache (this_frame,
							       this_cache);

  if (!cache->base_p)
    return;

  (*this_id) = frame_id_build (cache->base + 8, cache->pc);
}

static const struct frame_unwind amd64_epilogue_frame_unwind =
{
  NORMAL_FRAME,
  amd64_epilogue_frame_unwind_stop_reason,
  amd64_epilogue_frame_this_id,
  amd64_frame_prev_register,
  NULL, 
  amd64_epilogue_frame_sniffer
};

static struct frame_id
amd64_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  CORE_ADDR fp;

  fp = get_frame_register_unsigned (this_frame, AMD64_RBP_REGNUM);

  return frame_id_build (fp + 16, get_frame_pc (this_frame));
}

/* 16 byte align the SP per frame requirements.  */

static CORE_ADDR
amd64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  return sp & -(CORE_ADDR)16;
}


/* Supply register REGNUM from the buffer specified by FPREGS and LEN
   in the floating-point register set REGSET to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */

static void
amd64_supply_fpregset (const struct regset *regset, struct regcache *regcache,
		       int regnum, const void *fpregs, size_t len)
{
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);

  gdb_assert (len == tdep->sizeof_fpregset);
  amd64_supply_fxsave (regcache, regnum, fpregs);
}

/* Collect register REGNUM from the register cache REGCACHE and store
   it in the buffer specified by FPREGS and LEN as described by the
   floating-point register set REGSET.  If REGNUM is -1, do this for
   all registers in REGSET.  */

static void
amd64_collect_fpregset (const struct regset *regset,
			const struct regcache *regcache,
			int regnum, void *fpregs, size_t len)
{
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);

  gdb_assert (len == tdep->sizeof_fpregset);
  amd64_collect_fxsave (regcache, regnum, fpregs);
}

/* Similar to amd64_supply_fpregset, but use XSAVE extended state.  */

static void
amd64_supply_xstateregset (const struct regset *regset,
			   struct regcache *regcache, int regnum,
			   const void *xstateregs, size_t len)
{
  amd64_supply_xsave (regcache, regnum, xstateregs);
}

/* Similar to amd64_collect_fpregset, but use XSAVE extended state.  */

static void
amd64_collect_xstateregset (const struct regset *regset,
			    const struct regcache *regcache,
			    int regnum, void *xstateregs, size_t len)
{
  amd64_collect_xsave (regcache, regnum, xstateregs, 1);
}

/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */

static const struct regset *
amd64_regset_from_core_section (struct gdbarch *gdbarch,
				const char *sect_name, size_t sect_size)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (strcmp (sect_name, ".reg2") == 0 && sect_size == tdep->sizeof_fpregset)
    {
      if (tdep->fpregset == NULL)
	tdep->fpregset = regset_alloc (gdbarch, amd64_supply_fpregset,
				       amd64_collect_fpregset);

      return tdep->fpregset;
    }

  if (strcmp (sect_name, ".reg-xstate") == 0)
    {
      if (tdep->xstateregset == NULL)
	tdep->xstateregset = regset_alloc (gdbarch,
					   amd64_supply_xstateregset,
					   amd64_collect_xstateregset);

      return tdep->xstateregset;
    }

  return i386_regset_from_core_section (gdbarch, sect_name, sect_size);
}


/* Figure out where the longjmp will land.  Slurp the jmp_buf out of
   %rdi.  We expect its value to be a pointer to the jmp_buf structure
   from which we extract the address that we will land at.  This
   address is copied into PC.  This routine returns non-zero on
   success.  */

static int
amd64_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)
{
  gdb_byte buf[8];
  CORE_ADDR jb_addr;
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int jb_pc_offset = gdbarch_tdep (gdbarch)->jb_pc_offset;
  int len = TYPE_LENGTH (builtin_type (gdbarch)->builtin_func_ptr);

  /* If JB_PC_OFFSET is -1, we have no way to find out where the
     longjmp will land.	 */
  if (jb_pc_offset == -1)
    return 0;

  get_frame_register (frame, AMD64_RDI_REGNUM, buf);
  jb_addr= extract_typed_address
	    (buf, builtin_type (gdbarch)->builtin_data_ptr);
  if (target_read_memory (jb_addr + jb_pc_offset, buf, len))
    return 0;

  *pc = extract_typed_address (buf, builtin_type (gdbarch)->builtin_func_ptr);

  return 1;
}

static const int amd64_record_regmap[] =
{
  AMD64_RAX_REGNUM, AMD64_RCX_REGNUM, AMD64_RDX_REGNUM, AMD64_RBX_REGNUM,
  AMD64_RSP_REGNUM, AMD64_RBP_REGNUM, AMD64_RSI_REGNUM, AMD64_RDI_REGNUM,
  AMD64_R8_REGNUM, AMD64_R9_REGNUM, AMD64_R10_REGNUM, AMD64_R11_REGNUM,
  AMD64_R12_REGNUM, AMD64_R13_REGNUM, AMD64_R14_REGNUM, AMD64_R15_REGNUM,
  AMD64_RIP_REGNUM, AMD64_EFLAGS_REGNUM, AMD64_CS_REGNUM, AMD64_SS_REGNUM,
  AMD64_DS_REGNUM, AMD64_ES_REGNUM, AMD64_FS_REGNUM, AMD64_GS_REGNUM
};

void
amd64_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  const struct target_desc *tdesc = info.target_desc;

  /* AMD64 generally uses `fxsave' instead of `fsave' for saving its
     floating-point registers.  */
  tdep->sizeof_fpregset = I387_SIZEOF_FXSAVE;

  if (! tdesc_has_registers (tdesc))
    tdesc = tdesc_amd64;
  tdep->tdesc = tdesc;

  tdep->num_core_regs = AMD64_NUM_GREGS + I387_NUM_REGS;
  tdep->register_names = amd64_register_names;

  if (tdesc_find_feature (tdesc, "org.gnu.gdb.i386.avx") != NULL)
    {
      tdep->ymmh_register_names = amd64_ymmh_names;
      tdep->num_ymm_regs = 16;
      tdep->ymm0h_regnum = AMD64_YMM0H_REGNUM;
    }

  tdep->num_byte_regs = 20;
  tdep->num_word_regs = 16;
  tdep->num_dword_regs = 16;
  /* Avoid wiring in the MMX registers for now.  */
  tdep->num_mmx_regs = 0;

  set_gdbarch_pseudo_register_read_value (gdbarch,
					  amd64_pseudo_register_read_value);
  set_gdbarch_pseudo_register_write (gdbarch,
				     amd64_pseudo_register_write);

  set_tdesc_pseudo_register_name (gdbarch, amd64_pseudo_register_name);

  /* AMD64 has an FPU and 16 SSE registers.  */
  tdep->st0_regnum = AMD64_ST0_REGNUM;
  tdep->num_xmm_regs = 16;

  /* This is what all the fuss is about.  */
  set_gdbarch_long_bit (gdbarch, 64);
  set_gdbarch_long_long_bit (gdbarch, 64);
  set_gdbarch_ptr_bit (gdbarch, 64);

  /* In contrast to the i386, on AMD64 a `long double' actually takes
     up 128 bits, even though it's still based on the i387 extended
     floating-point format which has only 80 significant bits.  */
  set_gdbarch_long_double_bit (gdbarch, 128);

  set_gdbarch_num_regs (gdbarch, AMD64_NUM_REGS);

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, AMD64_RSP_REGNUM); /* %rsp */
  set_gdbarch_pc_regnum (gdbarch, AMD64_RIP_REGNUM); /* %rip */
  set_gdbarch_ps_regnum (gdbarch, AMD64_EFLAGS_REGNUM); /* %eflags */
  set_gdbarch_fp0_regnum (gdbarch, AMD64_ST0_REGNUM); /* %st(0) */

  /* The "default" register numbering scheme for AMD64 is referred to
     as the "DWARF Register Number Mapping" in the System V psABI.
     The preferred debugging format for all known AMD64 targets is
     actually DWARF2, and GCC doesn't seem to support DWARF (that is
     DWARF-1), but we provide the same mapping just in case.  This
     mapping is also used for stabs, which GCC does support.  */
  set_gdbarch_stab_reg_to_regnum (gdbarch, amd64_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, amd64_dwarf_reg_to_regnum);

  /* We don't override SDB_REG_RO_REGNUM, since COFF doesn't seem to
     be in use on any of the supported AMD64 targets.  */

  /* Call dummy code.  */
  set_gdbarch_push_dummy_call (gdbarch, amd64_push_dummy_call);
  set_gdbarch_frame_align (gdbarch, amd64_frame_align);
  set_gdbarch_frame_red_zone_size (gdbarch, 128);

  set_gdbarch_convert_register_p (gdbarch, i387_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, i387_register_to_value);
  set_gdbarch_value_to_register (gdbarch, i387_value_to_register);

  set_gdbarch_return_value (gdbarch, amd64_return_value);

  set_gdbarch_skip_prologue (gdbarch, amd64_skip_prologue);

  tdep->record_regmap = amd64_record_regmap;

  set_gdbarch_dummy_id (gdbarch, amd64_dummy_id);

  /* Hook the function epilogue frame unwinder.  This unwinder is
     appended to the list first, so that it supercedes the other
     unwinders in function epilogues.  */
  frame_unwind_prepend_unwinder (gdbarch, &amd64_epilogue_frame_unwind);

  /* Hook the prologue-based frame unwinders.  */
  frame_unwind_append_unwinder (gdbarch, &amd64_sigtramp_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &amd64_frame_unwind);
  frame_base_set_default (gdbarch, &amd64_frame_base);

  /* If we have a register mapping, enable the generic core file support.  */
  if (tdep->gregset_reg_offset)
    set_gdbarch_regset_from_core_section (gdbarch,
					  amd64_regset_from_core_section);

  set_gdbarch_get_longjmp_target (gdbarch, amd64_get_longjmp_target);

  set_gdbarch_relocate_instruction (gdbarch, amd64_relocate_instruction);

  set_gdbarch_gen_return_address (gdbarch, amd64_gen_return_address);

  /* SystemTap variables and functions.  */
  set_gdbarch_stap_integer_prefix (gdbarch, "$");
  set_gdbarch_stap_register_prefix (gdbarch, "%");
  set_gdbarch_stap_register_indirection_prefix (gdbarch, "(");
  set_gdbarch_stap_register_indirection_suffix (gdbarch, ")");
  set_gdbarch_stap_is_single_operand (gdbarch,
				      i386_stap_is_single_operand);
  set_gdbarch_stap_parse_special_token (gdbarch,
					i386_stap_parse_special_token);
}


static struct type *
amd64_x32_pseudo_register_type (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  switch (regnum - tdep->eax_regnum)
    {
    case AMD64_RBP_REGNUM:	/* %ebp */
    case AMD64_RSP_REGNUM:	/* %esp */
      return builtin_type (gdbarch)->builtin_data_ptr;
    case AMD64_RIP_REGNUM:	/* %eip */
      return builtin_type (gdbarch)->builtin_func_ptr;
    }

  return i386_pseudo_register_type (gdbarch, regnum);
}

void
amd64_x32_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  const struct target_desc *tdesc = info.target_desc;

  amd64_init_abi (info, gdbarch);

  if (! tdesc_has_registers (tdesc))
    tdesc = tdesc_x32;
  tdep->tdesc = tdesc;

  tdep->num_dword_regs = 17;
  set_tdesc_pseudo_register_type (gdbarch, amd64_x32_pseudo_register_type);

  set_gdbarch_long_bit (gdbarch, 32);
  set_gdbarch_ptr_bit (gdbarch, 32);
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_amd64_tdep (void);

void
_initialize_amd64_tdep (void)
{
  initialize_tdesc_amd64 ();
  initialize_tdesc_amd64_avx ();
  initialize_tdesc_x32 ();
  initialize_tdesc_x32_avx ();
}


/* The 64-bit FXSAVE format differs from the 32-bit format in the
   sense that the instruction pointer and data pointer are simply
   64-bit offsets into the code segment and the data segment instead
   of a selector offset pair.  The functions below store the upper 32
   bits of these pointers (instead of just the 16-bits of the segment
   selector).  */

/* Fill register REGNUM in REGCACHE with the appropriate
   floating-point or SSE register value from *FXSAVE.  If REGNUM is
   -1, do this for all registers.  This function masks off any of the
   reserved bits in *FXSAVE.  */

void
amd64_supply_fxsave (struct regcache *regcache, int regnum,
		     const void *fxsave)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  i387_supply_fxsave (regcache, regnum, fxsave);

  if (fxsave
      && gdbarch_bfd_arch_info (gdbarch)->bits_per_word == 64)
    {
      const gdb_byte *regs = fxsave;

      if (regnum == -1 || regnum == I387_FISEG_REGNUM (tdep))
	regcache_raw_supply (regcache, I387_FISEG_REGNUM (tdep), regs + 12);
      if (regnum == -1 || regnum == I387_FOSEG_REGNUM (tdep))
	regcache_raw_supply (regcache, I387_FOSEG_REGNUM (tdep), regs + 20);
    }
}

/* Similar to amd64_supply_fxsave, but use XSAVE extended state.  */

void
amd64_supply_xsave (struct regcache *regcache, int regnum,
		    const void *xsave)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  i387_supply_xsave (regcache, regnum, xsave);

  if (xsave
      && gdbarch_bfd_arch_info (gdbarch)->bits_per_word == 64)
    {
      const gdb_byte *regs = xsave;

      if (regnum == -1 || regnum == I387_FISEG_REGNUM (tdep))
	regcache_raw_supply (regcache, I387_FISEG_REGNUM (tdep),
			     regs + 12);
      if (regnum == -1 || regnum == I387_FOSEG_REGNUM (tdep))
	regcache_raw_supply (regcache, I387_FOSEG_REGNUM (tdep),
			     regs + 20);
    }
}

/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FXSAVE with the value from REGCACHE.  If REGNUM is -1, do this for
   all registers.  This function doesn't touch any of the reserved
   bits in *FXSAVE.  */

void
amd64_collect_fxsave (const struct regcache *regcache, int regnum,
		      void *fxsave)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  gdb_byte *regs = fxsave;

  i387_collect_fxsave (regcache, regnum, fxsave);

  if (gdbarch_bfd_arch_info (gdbarch)->bits_per_word == 64)
    {
      if (regnum == -1 || regnum == I387_FISEG_REGNUM (tdep))
	regcache_raw_collect (regcache, I387_FISEG_REGNUM (tdep), regs + 12);
      if (regnum == -1 || regnum == I387_FOSEG_REGNUM (tdep))
	regcache_raw_collect (regcache, I387_FOSEG_REGNUM (tdep), regs + 20);
    }
}

/* Similar to amd64_collect_fxsave, but use XSAVE extended state.  */

void
amd64_collect_xsave (const struct regcache *regcache, int regnum,
		     void *xsave, int gcore)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  gdb_byte *regs = xsave;

  i387_collect_xsave (regcache, regnum, xsave, gcore);

  if (gdbarch_bfd_arch_info (gdbarch)->bits_per_word == 64)
    {
      if (regnum == -1 || regnum == I387_FISEG_REGNUM (tdep))
	regcache_raw_collect (regcache, I387_FISEG_REGNUM (tdep),
			      regs + 12);
      if (regnum == -1 || regnum == I387_FOSEG_REGNUM (tdep))
	regcache_raw_collect (regcache, I387_FOSEG_REGNUM (tdep),
			      regs + 20);
    }
}
@


1.120
log
@Revert use of classify callback in i386 gdbarch_tdep.

This is no longer useful, as it was introduced to reuse the funcall
handling code in amd64-tdep.c in the context of x64-windows. But
we have since then changed the implementations to be completely
independent of each other.

This reverts the non-windows-specific part of the change called:
    amd64: Integer parameters in function calls on Windows
(the x64-windows portion has already been reverted)

gdb/ChangeLog:

	Revert:
	* i386-tdep.h (enum amd64_reg_class): New, moved here from
	amd64-tdep.c.
	(struct gdbarch_tdep): Add fields call_dummy_num_integer_regs,
	call_dummy_integer_regs, and classify.
	* amd64-tdep.h (amd64_classify): Add declaration.
	* amd64-tdep.c (amd64_dummy_call_integer_regs): New static constant.
	(amd64_reg_class): Delete, moved to i386-tdep.h.
	(amd64_classify): Make non-static.  Move declaration to amd64-tdep.h.
	Replace call to amd64_classify by call to tdep->classify.
	(amd64_push_arguments): Get the list of registers to use for
	passing integer parameters from the gdbarch tdep structure,
	rather than using a hardcoded one.  Replace calls to amd64_classify
	by calls to tdep->classify.
	(amd64_push_dummy_call): Get the register number used for
	the "hidden" argument from tdep->call_dummy_integer_regs.
	(amd64_init_abi): Initialize tdep->call_dummy_num_integer_regs
	and tdep->call_dummy_integer_regs.  Set tdep->classify.
@
text
@d112 8
a119 1
  8, 9, 10, 11, 12, 13, 14, 15,
d768 2
a769 2
    8,				/* %r8 */
    9				/* %r9 */
@


1.119
log
@Revert use of memory_args_by_pointer in i386 gdbarch_tdep.

This is no longer useful, as it was introduced to reuse the funcall
handling code in amd64-tdep.c in the context of x64-windows. But
we have since then changed the implementations to be completely
independent of each other.

This reverts the non-windows-specific part of the change called:
    amd64-windows: memory args passed by pointer during function calls.
(the x64-windows portion has already been reverted)

gdb/ChangeLog:

        Revert:
        * i386-tdep.h (gdbarch_tdep): Add field memory_args_by_pointer.
        * amd64-tdep.c (amd64_push_arguments): Add handling of architectures
        where tdep->memory_args_by_pointer is non-zero.
@
text
@a94 11
/* The registers used to pass integer arguments during a function call.  */
static int amd64_dummy_call_integer_regs[] =
{
  AMD64_RDI_REGNUM,		/* %rdi */
  AMD64_RSI_REGNUM,		/* %rsi */
  AMD64_RDX_REGNUM,		/* %rdx */
  AMD64_RCX_REGNUM,		/* %rcx */
  8,				/* %r8 */
  9				/* %r9 */
};

d383 14
d433 2
d554 1
a554 1
void
a621 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
a630 1
  gdb_assert (tdep->classify);
d633 1
a633 1
  tdep->classify (type, class);
d755 9
a763 4
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  int *integer_regs = tdep->call_dummy_integer_regs;
  int num_integer_regs = tdep->call_dummy_num_integer_regs;

a779 2
  gdb_assert (tdep->classify);

d794 1
a794 1
      tdep->classify (type, class);
d808 1
a808 1
      if (integer_reg + needed_integer_regs > num_integer_regs
d832 1
a832 1
		  regnum = integer_regs[integer_reg++];
a889 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
a897 4
      /* The "hidden" argument is passed throught the first argument
         register.  */
      const int arg_regnum = tdep->call_dummy_integer_regs[0];

d899 1
a899 1
      regcache_cooked_write (regcache, arg_regnum, buf);
a2891 4
  tdep->call_dummy_num_integer_regs =
    ARRAY_SIZE (amd64_dummy_call_integer_regs);
  tdep->call_dummy_integer_regs = amd64_dummy_call_integer_regs;
  tdep->classify = amd64_classify;
@


1.118
log
@Revert use of integer_param_regs_saved_in_caller_frame in i386 gdbarch_tdep.

This is no longer useful, as it was introduced to reuse the funcall
handling code in amd64-tdep.c in the context of x64-windows. But
we have since then changed the implementations to be completely
independent of each other.

This reverts the non-windows-specific part of the change called:
    amd64-windows: 32 bytes allocated on stack by caller for integer
    parameter regs
(the x64-windows portion has already been reverted)

gdb/ChangeLog:

        Revert:
        * i386-tdep.h (struct gdbarch_tdep): Add new field
        integer_param_regs_saved_in_caller_frame.
        * amd64-tdep.c (amd64_push_dummy_call): Allocate some memory on
        stack if tdep->integer_param_regs_saved_in_caller_frame is set.
@
text
@d752 1
a752 2
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
a764 5
  /* An array that mirrors the stack_args array.  For all arguments
     that are passed by MEMORY, if that argument's address also needs
     to be stored in a register, the ARG_ADDR_REGNO array will contain
     that register number (or a negative value otherwise).  */
  int *arg_addr_regno = alloca (nargs * sizeof (int));
d808 1
a808 13
	  stack_args[num_stack_args] = args[i];
          /* If this is an AMD64_MEMORY argument whose address must also
             be passed in one of the integer registers, reserve that
             register and associate this value to that register so that
             we can store the argument address as soon as we know it.  */
          if (class[0] == AMD64_MEMORY
              && tdep->memory_args_by_pointer
              && integer_reg < tdep->call_dummy_num_integer_regs)
            arg_addr_regno[num_stack_args] =
              tdep->call_dummy_integer_regs[integer_reg++];
          else
            arg_addr_regno[num_stack_args] = -1;
          num_stack_args++;
d863 1
a863 1
      CORE_ADDR arg_addr = sp + element * 8;
d865 2
a866 12
      write_memory (arg_addr, valbuf, TYPE_LENGTH (type));
      if (arg_addr_regno[i] >= 0)
        {
          /* We also need to store the address of that argument in
             the given register.  */
          gdb_byte buf[8];
          enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

          store_unsigned_integer (buf, 8, byte_order, arg_addr);
          regcache_cooked_write (regcache, arg_addr_regno[i], buf);
        }
      element += ((TYPE_LENGTH (type) + 7) / 8);
@


1.117
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a928 5
  /* Reserve some memory on the stack for the integer-parameter registers,
     if required by the ABI.  */
  if (tdep->integer_param_regs_saved_in_caller_frame)
    sp -= tdep->call_dummy_num_integer_regs * 8;

@


1.116
log
@Fix for incorrect breakpoint set in case of clang compiled binary
@
text
@d3 1
a3 1
   Copyright (C) 2001-2012 Free Software Foundation, Inc.
@


1.115
log
@2012-10-26  Pedro Alves  <palves@@redhat.com>

	* amd64-tdep.c (amd64_relocate_instruction): Use
	store_unsigned_integer instead of memcpy.
	* i386-tdep.c (i386_relocate_instruction): Ditto.
@
text
@d2255 16
@


1.114
log
@PR gdb/12796
PR gdb/12798
PR gdb/12800
* amd64-tdep.h (enum amd64_regnum): Add AMD64_ST1_REGNUM and
AMD64_FTAG_REGNUM.
* amd64-tdep.c (amd64_classify): Classify complex types.
(amd64_return_value): Handle the COMPLEX_X87 class.
@
text
@d1634 1
a1634 1
      memcpy (&push_buf[1], &ret_addr, 4);
@


1.113
log
@Remove sp_regnum_from_eax and pc_regnum_from_eax

	PR backtrace/14646
	PR gdb/14647
	* i386-tdep.h (gdbarch_tdep): Remove sp_regnum_from_eax and
	pc_regnum_from_eax.
	* i386-tdep.c (i386_gdbarch_init): Don't use sp_regnum_from_eax
	nor pc_regnum_from_eax.
	* amd64-tdep.c (amd64_x32_init_abi): Don't set sp_regnum_from_eax
	nor pc_regnum_from_eax.
@
text
@d589 17
d656 24
@


1.112
log
@        * amd64-tdep.c (amd64_return_value): Revert previous change
        that used TYPE_LENGTH directly.
        * bfin-tdep.c (bfin_extract_return_value): Likewise.
        (bfin_store_return_value): Likewise.
        * cris-tdep.c (cris_store_return_value): Likewise.
        (cris_extract_return_value): Likewise.
        * h8300-tdep.c (h8300_extract_return_value): Likewise.
        * hppa-tdep.c (hppa64_return_value): Likewise.
        * lm32-tdep.c (lm32_store_return_value): Likewise.
        * microblaze-tdep.c (microblaze_store_return_value): Likewise.
        * spu-tdep.c (spu_value_from_register): Likewise.
        * vax-tdep.c (vax_return_value): Likewise.
@
text
@a2945 3
  tdep->sp_regnum_from_eax = AMD64_RSP_REGNUM;
  tdep->pc_regnum_from_eax = AMD64_RIP_REGNUM;

@


1.111
log
@        * amd64-tdep.c (amd64_return_value): Use TYPE_LENGTH directly.
        * bfin-tdep.c (bfin_extract_return_value): Likewise.
        (bfin_store_return_value): Likewise.
        * cris-tdep.c (cris_store_return_value): Likewise.
        (cris_extract_return_value): Likewise.
        * h8300-tdep.c (h8300_extract_return_value): Likewise.
        * hppa-tdep.c (hppa64_return_value): Likewise.
        * lm32-tdep.c (lm32_store_return_value): Likewise.
        * microblaze-tdep.c (microblaze_store_return_value): Likewise.
        * spu-tdep.c (spu_value_from_register): Likewise.
        * vax-tdep.c (vax_return_value): Likewise.
@
text
@d640 1
a640 1
  gdb_assert (TYPE_LENGTH (type) <= 16);
@


1.110
log
@	* ada-valprint.c (ada_val_print_1): Eliminate single-use
	variable LEN.
	* alpha-tdep.c (alpha_extract_return_value): Use TYPE_LENGTH
	directly.
	(alpha_store_return_value): Likewise.
	* amd64-tdep.c (amd64_classify_aggregate): Likewise.
	(amd64_push_arguments): Likewise.
	* ax-gdb.c (gen_trace_static_fields): Likewise.
	(gen_traced_pop): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* breakpoint.c (update_watchpoint): Likewise.
	* findcmd.c (parse_find_args): Use local variable for type
	instead of length.
	* findvar.c (default_read_var_value): Use TYPE_LENGTH directly.
	* h8300-tdep.c (h8300h_extract_return_value): Likewise.
	(h8300_store_return_value): Likewise.
	* i386-darwin-tdep.c (i386_darwin_push_dummy_call): Likewise.
	Use i386_darwin_arg_type_alignment directly.
	* infcall.c (call_function_by_hand): Use TYPE_LENGTH directly.
	* lm32-tdep.c (lm32_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	(m68hc11_extract_return_value): Likewise.
	* mep-tdep.c (mep_push_dummy_call): Likewise.
	* printcmd.c (float_type_from_length): Likewise.
	* s390-tdep.c (s390_value_from_register): Likewise.
	* stack.c (read_frame_arg): Likewise.
	* tracepoint.c (encode_actions_1): Likewise.
	* valops.c (value_fetch_lazy): Use local variable for type
	instead of length.  Use TYPE_LENGTH directly.
	* value.c (value_contents_equal): Use TYPE_LENGTH directly.
@
text
@d640 1
a640 1
  gdb_assert (len <= 16);
@


1.109
log
@Add sp_regnum_from_eax/pc_regnum_from_eax to i386 gdbarch_tdep

	* amd64-tdep.c (amd64_x32_init_abi): Set sp_regnum_from_eax to
	AMD64_RSP_REGNUM and pc_regnum_from_eax to AMD64_RIP_REGNUM.

	* i386-tdep.c (i386_gdbarch_init): Initialize sp_regnum_from_eax
	and pc_regnum_from_eax to -1.  Update SP regnum from
	sp_regnum_from_eax and PC regnum from pc_regnum_from_eax if
	needed.

	* i386-tdep.h (gdbarch_tdep): Add sp_regnum_from_eax and
	pc_regnum_from_eax.
@
text
@a448 2
  int len = TYPE_LENGTH (type);

d452 1
a452 1
  if (len > 16 || amd64_non_pod_p (type))
d472 1
a472 1
      if (len > 8 && class[1] == AMD64_NO_CLASS)
a839 1
      int len = TYPE_LENGTH (type);
d842 1
a842 1
      write_memory (arg_addr, valbuf, len);
d853 1
a853 1
      element += ((len + 7) / 8);
@


1.109.2.1
log
@Remove sp_regnum_from_eax and pc_regnum_from_eax

	PR backtrace/14646
	PR gdb/14647
	* i386-tdep.h (gdbarch_tdep): Remove sp_regnum_from_eax and
	pc_regnum_from_eax.
	* i386-tdep.c (i386_gdbarch_init): Don't use sp_regnum_from_eax
	nor pc_regnum_from_eax.
	* amd64-tdep.c (amd64_x32_init_abi): Don't set sp_regnum_from_eax
	nor pc_regnum_from_eax.
@
text
@d2949 3
@


1.108
log
@Add and use amd64_x32_analyze_stack_align

	* amd64-tdep.c (amd64_x32_analyze_stack_align): New function.
	(amd64_analyze_prologue): Call amd64_x32_analyze_stack_align
	for x32.
@
text
@d2949 3
@


1.107
log
@Check bits_per_word instead of gdbarch_ptr_bit

	* amd64-linux-nat.c (ps_get_thread_area): Check bits_per_word
	instead of gdbarch_ptr_bit.
	* amd64-nat.c (amd64_native_gregset_reg_offset): Likewise.
	(amd64_supply_native_gregset): Likewise.
	(amd64_collect_native_gregset): Likewise.
	* amd64-tdep.c (amd64_supply_fxsave): Likewise.
	(amd64_supply_xsave): Likewise.
	(amd64_collect_fxsave): Likewise.
	(amd64_collect_xsave): Likewise.
@
text
@d1864 182
d2083 4
a2086 1
  pc = amd64_analyze_stack_align (pc, current_pc, cache);
@


1.106
log
@    H.J. Lu  <hongjiu.lu@@intel.com>

* i386-tdep.h (i386_pseudo_register_name): New prototype.
* i386-tdep.c (i386_pseudo_register_name): Make public.
* amd64-tdep.h (amd64_x32_init_abi): New prototype.
* amd64-tdep.c (amd64_dword_names): Add "eip".
(amd64_x32_pseudo_register_type): New function
(amd64_x32_init_abi): New function.
@
text
@d2805 2
a2806 1
  if (fxsave && gdbarch_ptr_bit (gdbarch) == 64)
d2828 2
a2829 1
  if (xsave && gdbarch_ptr_bit (gdbarch) == 64)
d2857 1
a2857 1
  if (gdbarch_ptr_bit (gdbarch) == 64)
d2878 1
a2878 1
  if (gdbarch_ptr_bit (gdbarch) == 64)
@


1.105
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@d261 2
a262 1
  "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d", "r15d"
d2733 37
@


1.104
log
@Call initialize_tdesc_x32/initialize_tdesc_x32_avx

	* amd64-tdep.c: Include features/i386/x32.c and
	features/i386/x32-avx.c.
	(_initialize_amd64_tdep): Call initialize_tdesc_x32 and
	initialize_tdesc_x32_avx.
@
text
@d597 1
a597 1
amd64_return_value (struct gdbarch *gdbarch, struct type *func_type,
@


1.103
log
@    H.J. Lu  <hongjiu.lu@@intel.com>

* amd64-tdep.c (amd64_analyze_prologue): Additionally check for
`movl %esp, %ebp' for the X32 ABI.
@
text
@d46 2
d2741 2
@


1.102
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d1870 8
a1877 2
   Any function that doesn't start with this sequence will be assumed
   to have no prologue and thus no valid frame pointer in %rbp.  */
d1888 4
d1913 2
d1916 21
a1936 8
      read_memory (pc + 1, buf, 3);
      if (memcmp (buf, mov_rsp_rbp_1, 3) != 0
	  && memcmp (buf, mov_rsp_rbp_2, 3) != 0)
	return pc + 1;

      /* OK, we actually have a frame.  */
      cache->frameless_p = 0;
      return pc + 4;
@


1.101
log
@	* amd64-tdep.c (amd64_analyze_prologue): Recognize both variations of
	"mov %rsp,%rbp".
@
text
@d2694 10
@


1.100
log
@gdb/
	* amd64-tdep.c (amd64_displaced_step_copy_insn): Complete missing "}" in
	comment.
@
text
@d1868 1
a1868 1
      movq %rsp, %rbp   0x48 0x89 0xe5
d1879 3
a1881 1
  static gdb_byte proto[3] = { 0x48, 0x89, 0xe5 }; /* movq %rsp, %rbp */
d1905 2
a1906 1
      if (memcmp (buf, proto, 3) != 0)
@


1.99
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1261 1
a1261 1
  /* Extra space for sentinels so fixup_{riprel,displaced_copy don't have to
@


1.98
log
@* amd64-tdep.c (amd64_get_unused_input_int_reg): Rename `index' to
`idx'(-Wshadow).
@
text
@d3 1
a3 2
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
@


1.98.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2001-2012 Free Software Foundation, Inc.
@


1.97
log
@* amd64-tdep.c (amd64_push_dummy_call): Remove nested definition
  of `tdep'(-Wshadow).
@
text
@d1084 1
a1084 1
	  int index = SIB_INDEX_FIELD (details->raw_insn[details->modrm_offset + 1]);
d1086 1
a1086 1
	  used_regs_mask |= 1 << index;
@


1.96
log
@gdb/

	* amd64-tdep.c (amd64_relocate_instruction): Make it static.
@
text
@a880 1
      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
@


1.95
log
@	Add return address collection for tracepoints.
	* tracepoint.c (encode_actions_1): Add case for $_ret.
	(validate_actionline): Check for $_ret.
	(trace_dump_actions): Ditto.
	* ax-gdb.h (gen_trace_for_return_address): Declare.
	* ax-gdb.c: Include arch-utils.h.
	(gen_trace_for_return_address): New function.
	(agent_command): Add return address special case.
	* amd64-tdep.c: Include ax.h and ax-gdb.h.
	(amd64_gen_return_address): New function.
	(amd64_init_abi): Call it.
	* i386-tdep.c: Include ax.h and ax-gdb.h.
	(i386_gen_return_address): New function.
	(i386_init_abi): Call it.
	* arch-utils.h (default_gen_return_address): Declare.
	* arch-utils.c (default_gen_return_address): New function.
	* gdbarch.sh (gen_return_address): New method.
	* gdbarch.h, gdbarch.c: Regenerate.

	* gdb.texinfo (Tracepoint Action Lists): Document $_ret.

	* gdb.trace/collection.exp: Test collection of $_ret.
@
text
@d1554 1
a1554 1
void
@


1.94
log
@gdb/
	Fix compatibility with gcc < 4.3 and non-gcc compilers.
	* amd64-tdep.c (amd64_skip_xmm_prologue): Convert 0b constants.
@
text
@d48 3
d2171 16
d2691 2
@


1.93
log
@gdb/
	Code cleanup.
	* amd64-tdep.c (amd64_skip_prologue): Move the XMM code to ...
	(amd64_skip_xmm_prologue): ... this new function.  Describe its
	parameters.  No longer use amd64_prologue_line_bug.
	* defs.h (producer_is_gcc_ge_4): New declaration.
	* dwarf2read.c (producer_is_gcc_ge_4): Move to utils.c.
	(process_full_comp_unit): Update its caller.  Remove
	amd64_prologue_line_bug initialization.
	* symtab.h (struct symtab): Remove field amd64_prologue_line_bug.
	* utils.c (producer_is_gcc_ge_4): Moved here from dwarf2read.c.
@
text
@d1965 1
a1965 1
      /* movaps %xmmreg?,-0x??(%rbp) */
d1967 1
a1967 1
          || (buf[offset + 2] & 0b00111111) != (xmmreg << 3 | 0b101))
d1970 2
a1971 1
      if ((buf[offset + 2] & 0b11000000) == 0b01000000)
d1976 2
a1977 1
      else if ((buf[offset + 2] & 0b11000000) == 0b10000000)
@


1.92
log
@gdb/
	PR breakpoints/12435
	* amd64-tdep.c (amd64_skip_prologue): New variables start_pc_sal,
	next_sal, buf, offset and xmmreg.  Advance PC if it sees the PR.
	* dwarf2read.c (process_full_comp_unit): Initialize
	amd64_prologue_line_bug.
	* symtab.h (struct symtab): New field amd64_prologue_line_bug.

gdb/testsuite/
	PR breakpoints/12435
	* gdb.arch/amd64-prologue-xmm.c: New file.
	* gdb.arch/amd64-prologue-xmm.exp: New file.
	* gdb.arch/amd64-prologue-xmm.s: New file.
@
text
@d1913 17
a1929 1
/* Return PC of first real instruction.  */
d1932 1
a1932 1
amd64_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
a1933 2
  struct amd64_frame_cache cache;
  CORE_ADDR pc;
a1937 20
  amd64_init_frame_cache (&cache);
  pc = amd64_analyze_prologue (gdbarch, start_pc, 0xffffffffffffffffLL,
			       &cache);
  if (cache.frameless_p)
    return start_pc;

  /* GCC PR debug/48827 produced false prologue end:
     84 c0                test   %al,%al
     74 23                je     after
     <-- here is 0 lines advance - the false prologue end marker.
     0f 29 85 70 ff ff ff movaps %xmm0,-0x90(%rbp)
     0f 29 4d 80          movaps %xmm1,-0x80(%rbp)
     0f 29 55 90          movaps %xmm2,-0x70(%rbp)
     0f 29 5d a0          movaps %xmm3,-0x60(%rbp)
     0f 29 65 b0          movaps %xmm4,-0x50(%rbp)
     0f 29 6d c0          movaps %xmm5,-0x40(%rbp)
     0f 29 75 d0          movaps %xmm6,-0x30(%rbp)
     0f 29 7d e0          movaps %xmm7,-0x20(%rbp)
     after:  */

d1943 1
a1943 1
      || !start_pc_sal.symtab->amd64_prologue_line_bug
d1990 17
@


1.91
log
@gdb
	* amd64-tdep.c (amd64_pseudo_register_read_value): Rename
	from amd64_pseudo_register_read.  Change arguments.  Call
	mark_value_bytes_unavailable when needed.
	(amd64_init_abi): Use set_gdbarch_pseudo_register_read_value, not
	set_gdbarch_pseudo_register_read.
	* sentinel-frame.c (sentinel_frame_prev_register): Use
	regcache_cooked_read_value.
	* regcache.h (regcache_cooked_read_value): Declare.
	* regcache.c (regcache_cooked_read_value): New function.
	(regcache_cooked_read): Call
	gdbarch_pseudo_register_read_value if available.
	* i386-tdep.h (i386_pseudo_register_read_value): Declare.
	(i386_pseudo_register_read): Remove.
	* i386-tdep.c (i386_pseudo_register_read_into_value): Rename from
	i386_pseudo_register_read.  Change arguments.  Call
	mark_value_bytes_unavailable when needed.
	(i386_pseudo_register_read_value): New function.
	(i386_gdbarch_init): Call set_gdbarch_pseudo_register_read_value,
	not set_gdbarch_pseudo_register_read.
	* gdbarch.sh (pseudo_register_read_value): New method.
	* gdbarch.c, gdbarch.h: Rebuild.
	* findvar.c (value_from_register): Call get_frame_register_value.
gdb/testsuite
	* gdb.dwarf2/typeddwarf.c: XFAIL 'z' on x86-64.
	* gdb.dwarf2/typeddwarf.exp (xfail-gdb-test): Add arch_pattern
	argument.
	* gdb.dwarf2/typeddwarf-amd64.S: New file.
@
text
@d1920 3
d1930 65
a1994 1
  return pc;
@


1.90
log
@gdb/
	* ada-lang.c: Fix typos.
	* amd64-tdep.c: Likewise.
	* breakpoint.c: Likewise.
	* cli/cli-decode.c: Likewise.
	* findcmd.c: Likewise.
	* inline-frame.c: Likewise.
	* mi/mi-main.c: Likewise.
	* minsyms.c: Likewise.
	* monitor.c: Likewise.
	* monitor.h: Likewise.
	* prologue-value.c: Likewise.
	* reverse.c: Likewise.
	* s390-tdep.c: Likewise.

gdb/testsuite/
	* gdb.base/call-sc.c: Likewise.
	* gdb.base/ifelse.exp: Likewise.
	* gdb.base/structs.c: Likewise.

gdb/doc/
	* gdb.texinfo: Likewise.
@
text
@d278 4
a281 4
static enum register_status
amd64_pseudo_register_read (struct gdbarch *gdbarch,
			    struct regcache *regcache,
			    int regnum, gdb_byte *buf)
d286 7
d307 3
d316 3
a319 2

      return status;
d328 3
a330 2

      return status;
d333 4
a336 1
    return i386_pseudo_register_read (gdbarch, regcache, regnum, buf);
d2512 2
a2513 2
  set_gdbarch_pseudo_register_read (gdbarch,
				    amd64_pseudo_register_read);
@


1.89
log
@gdb/
	Disable epilogue unwinders on recent GCCs.
	* amd64-tdep.c (amd64_in_function_epilogue_p): New variable symtab,
	initialize it, return 0 on EPILOGUE_UNWIND_VALID.
	* dwarf2read.c (process_full_comp_unit): Initialize
	EPILOGUE_UNWIND_VALID.
	* i386-tdep.c (i386_in_function_epilogue_p): New variable symtab,
	initialize it, return 0 on EPILOGUE_UNWIND_VALID.
	* symtab.h (struct symtab): New field epilogue_unwind_valid.
@
text
@d521 1
a521 1
  /* Rule (b): If SSEUP is not preceeded by SSE, it is converted to
@


1.88
log
@gdb
	* windows-tdep.c (windows_xfer_shared_library):
	* windows-nat.c (get_module_name, windows_make_so):
	* v850-tdep.c (v850_handle_pushm):
	* utils.c (null_cleanup, gdb_realpath):
	* ui-out.c (get_next_header):
	* tracepoint.c (clear_traceframe_info):
	* symtab.c (lookup_symtab):
	* serial.h (struct serial_ops):
	* mipsread.c (read_alphacoff_dynamic_symtab):
	* infcmd.c (print_return_value):
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address):
	* f-exp.y (parse_number):
	* exceptions.c (catch_exceptions):
	* dummy-frame.c (dummy_frame_this_id):
	* defs.h (struct cleanup):
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib):
	* arm-tdep.c (arm_push_dummy_call):
	* amd64-tdep.h (amd64_collect_xsave):
	* amd64-tdep.c (amd64_collect_xsave):
	* alpha-tdep.c (alpha_heuristic_frame_unwind_cache):
	* README (typing): Remove duplicate words.
	* cli/cli-decode.c (lookup_cmd_composition): Add comma.
	* infrun.c (siginfo_value_read): Fix typo.
	* solib-frv.c (frv_fdpic_find_global_pointer): Likewise.
	* top.c (source_line_number): Add comma.
gdb/doc
	* gdbint.texinfo (Register Information Functions): Remove
	duplicate "the".
	* gdb.texinfo (Emacs): Remove duplicate "to".
	(GDB/MI Variable Objects): Remove duplicate "the".
	(General Query Packets): Likewise.
gdb/testsuite
	* gdb.mi/mi-nsmoribund.exp:
	* gdb.hp/gdb.objdbg/objdbg01.exp:
	* gdb.base/structs.exp (test_struct_returns):
	* gdb.base/call-sc.exp (test_scalar_returns):
	* gdb.base/bigcore.exp: Remove duplicate words.
gdb/gdbserver
	* win32-low.c (handle_load_dll): Remove duplicate "the".
@
text
@d2222 5
@


1.87
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d2665 1
a2665 1
/* Similar to amd64_collect_fxsave, but but use XSAVE extended state.  */
@


1.86
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d41 1
a41 1

d1638 1
d1660 1
d1918 3
a1920 2
static struct amd64_frame_cache *
amd64_frame_cache (struct frame_info *this_frame, void **this_cache)
a1923 1
  struct amd64_frame_cache *cache;
a1926 6
  if (*this_cache)
    return *this_cache;

  cache = amd64_alloc_frame_cache ();
  *this_cache = cache;

a1931 7
  if (cache->saved_sp_reg != -1)
    {
      /* Stack pointer has been saved.  */
      get_frame_register (this_frame, cache->saved_sp_reg, buf);
      cache->saved_sp = extract_unsigned_integer(buf, 8, byte_order);
    }

d1943 4
d1984 22
d2009 17
d2033 3
d2066 1
d2086 1
d2097 11
a2107 2
  get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 8, byte_order) - 8;
d2109 4
a2112 6
  addr = tdep->sigcontext_addr (this_frame);
  gdb_assert (tdep->sc_reg_offset);
  gdb_assert (tdep->sc_num_regs <= AMD64_NUM_SAVED_REGS);
  for (i = 0; i < tdep->sc_num_regs; i++)
    if (tdep->sc_reg_offset[i] != -1)
      cache->saved_regs[i] = addr + tdep->sc_reg_offset[i];
d2118 13
d2138 3
d2187 1
d2249 1
d2259 9
a2267 4
  /* Cache base will be %esp plus cache->sp_offset (-8).  */
  get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 8, 
					  byte_order) + cache->sp_offset;
d2269 2
a2270 2
  /* Cache pc will be the frame func.  */
  cache->pc = get_frame_pc (this_frame);
d2272 2
a2273 2
  /* The saved %esp will be at cache->base plus 16.  */
  cache->saved_sp = cache->base + 16;
d2275 4
a2278 2
  /* The saved %eip will be at cache->base plus 8.  */
  cache->saved_regs[AMD64_RIP_REGNUM] = cache->base + 8;
d2283 13
d2304 3
d2313 1
@


1.85
log
@Fix relocation of jump and call instructions (used when inserting fast
tracepoints).

2011-03-18  Kwok Cheung Yeung  <kcy@@codesourcery.com>

        * amd64-tdep.c (amd64_relocate_instruction): Fix ordering of arguments
        to store_signed_integer.  Add debug message when relocating CALL
        instructions.  Fix formatting of debug message.
        * i386-tdep.c (i386_relocate_instruction): Ditto.
@
text
@d278 1
a278 1
static void
d285 1
d295 5
a299 3
	  regcache_raw_read (regcache,
			     gpnum - AMD64_NUM_LOWER_BYTE_REGS, raw_buf);
	  memcpy (buf, raw_buf + 1, 1);
d303 3
a305 2
	  regcache_raw_read (regcache, gpnum, raw_buf);
	  memcpy (buf, raw_buf, 1);
d307 2
d314 5
a318 2
      regcache_raw_read (regcache, gpnum, raw_buf);
      memcpy (buf, raw_buf, 4);
d321 1
a321 1
    i386_pseudo_register_read (gdbarch, regcache, regnum, buf);
@


1.84
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d1578 8
a1585 1
      store_signed_integer (insn + 1, 4, newrel, byte_order);
d1608 1
a1608 1
      store_signed_integer (insn + offset, 4, newrel, byte_order);
d1611 2
a1612 2
			    "Adjusted insn rel32=0x%s at 0x%s to"
			    " rel32=0x%s at 0x%s\n",
@


1.83
log
@run copyright.sh for 2011.
@
text
@d590 1
a590 1
     %rdi as if it were the first argument to the function. In effect,
d1567 1
a1567 1
      push_buf[0] = 0x68; /* pushq $... */
@


1.82
log
@Remove amd64_register_name.

2010-09-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-tdep.c (amd64_register_name): Removed.
	(amd64_init_abi): Don't call set_gdbarch_register_name.

	* i386-tdep.c (i386_ymmh_regnum_p): Make it static.

	* i386-tdep.h (i386_ymmh_regnum_p): Removed.
@
text
@d3 2
a4 2
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@


1.81
log
@gdb/
2010-05-26  Pedro Alves  <pedro@@codesourcery.com>

	* NEWS: Mention the `qRelocInsn' feature.
	* gdbarch.sh (relocate_instruction): New.
	* amd64-tdep.c (rip_relative_offset): New.
	(append_insns): New.
	(amd64_relocate_instruction): New.
	(amd64_init_abi): Install it.
	* i386-tdep.c (append_insns): New.
	(i386_relocate_instruction): New.
	(i386_gdbarch_init): Install it.
	* remote.c (remote_get_noisy_reply): Handle qRelocInsn requests.
	* gdbarch.h, gdbarch.c: Regenerate.

gdb/doc/
2010-05-26  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (General Query Packets) <qSupported>: Describe the
	`qRelocInsn' feature.
	(Relocate instruction reply packet): New subsection
	of `Tracepoint Packets'.
	(Tracepoint Packets): Mention that packets QTDP and QTStart
	support the qRelocInsn request, and add cross reference to new
	subsection.
@
text
@a259 13
/* Return the name of register REGNUM, or the empty string if it is
   an anonymous register. */

static const char *
amd64_register_name (struct gdbarch *gdbarch, int regnum)
{
  /* Hide the upper YMM registers.  */
  if (i386_ymmh_regnum_p (gdbarch, regnum))
    return "";

  return tdesc_register_name (gdbarch, regnum);
}

a2396 2
  set_gdbarch_register_name (gdbarch, amd64_register_name);

@


1.81.2.1
log
@Fix relocation of jump and call instructions (used when inserting fast
tracepoints).

2011-03-18  Kwok Cheung Yeung  <kcy@@codesourcery.com>

	* amd64-tdep.c (amd64_relocate_instruction): Fix ordering of arguments
        to store_signed_integer.  Add debug message when relocating CALL
        instructions.  Fix formatting of debug message.
        * i386-tdep.c (i386_relocate_instruction): Ditto.
@
text
@d1591 1
a1591 8
      store_signed_integer (insn + 1, 4, byte_order, newrel);

      if (debug_displaced)
	fprintf_unfiltered (gdb_stdlog,
			    "Adjusted insn rel32=%s at %s to"
			    " rel32=%s at %s\n",
			    hex_string (rel32), paddress (gdbarch, oldloc),
			    hex_string (newrel), paddress (gdbarch, *to));
d1614 1
a1614 1
      store_signed_integer (insn + offset, 4, byte_order, newrel);
d1617 2
a1618 2
			    "Adjusted insn rel32=%s at %s to"
			    " rel32=%s at %s\n",
@


1.80
log
@	* amd64-tdep.c: Include disasm.h.
	(amd64_insn_length_fprintf, amd64_insn_length_init_dis)
	(amd64_insn_length): Moved to disasm.c and renamed.
	(fixup_riprel): Adjust.
	* disasm.c (do_ui_file_delete): New.
	(gdb_insn_length): New.
	(gdb_buffered_insn_length_fprintf)
	(gdb_buffered_insn_length_init_dis)
	(gdb_buffered_insn_length): New, moved from amd64-tdep.c, and
	renamed.
	* disasm.h (gdb_insn_length): Declare.
	(gdb_buffered_insn_length): Declare.
@
text
@d1510 117
d2483 2
@


1.79
log
@gdb/
	* ada-lang.c (lim_warning): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* amd64-tdep.c (amd64_insn_length_fprintf): Likewise.
	* cli-out.c (cli_field_fmt): New ATTRIBUTE_PRINTF.
	(cli_message, out_field_fmt): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* complaints.c (find_complaint): New ATTRIBUTE_PRINTF.
	(vcomplaint): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* complaints.h (complaint, internal_complaint): Likewise.
	* defs.h: Change ATTR_FORMAT to ATTRIBUTE_PRINTF in the top comment.
	(ATTR_FORMAT): Remove.
	(query, nquery, yquery, vprintf_filtered, vfprintf_filtered)
	(fprintf_filtered, fprintfi_filtered, printf_filtered, printfi_filtered)
	(vprintf_unfiltered, vfprintf_unfiltered, fprintf_unfiltered)
	(printf_unfiltered, xasprintf, xvasprintf, xstrprintf, xstrvprintf)
	(xsnprintf, verror, error, vfatal, fatal, internal_verror)
	(internal_error, internal_vwarning, internal_warning, warning)
	(vwarning): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* disasm.c (fprintf_disasm): Likewise.
	* exceptions.c (throw_it): Likewise.
	* exceptions.h (exception_fprintf, throw_verror, throw_vfatal)
	(throw_error): Likewise.
	* language.h (type_error, range_error): Likewise.
	* linespec.c (cplusplus_error): Likewise.
	* mi/mi-interp.c (mi_interp_query_hook): Likewise.
	* mi/mi-out.c (mi_field_fmt, mi_message): Likewise.
	* monitor.c (monitor_debug): Likewise.
	* parser-defs.h (parser_fprintf): Likewise.
	* serial.h (serial_printf): Likewise.
	* tui/tui-hooks.c (tui_query_hook): Likewise.
	* ui-out.c (default_field_fmt, default_message, uo_field_fmt)
	(uo_message): Likewise.
	* ui-out.h (ui_out_field_fmt, ui_out_message): Likewise.
	* utils.c (vfprintf_maybe_filtered, internal_vproblem, defaulted_query):
	Likewise.
	* xml-support.h (gdb_xml_debug, gdb_xml_error): Likewise.
@
text
@d39 1
a39 1

a1024 51
/* fprintf-function for amd64_insn_length.
   This function is a nop, we don't want to print anything, we just want to
   compute the length of the insn.  */

static int ATTRIBUTE_PRINTF (2, 3)
amd64_insn_length_fprintf (void *stream, const char *format, ...)
{
  return 0;
}

/* Initialize a struct disassemble_info for amd64_insn_length.	*/

static void
amd64_insn_length_init_dis (struct gdbarch *gdbarch,
			    struct disassemble_info *di,
			    const gdb_byte *insn, int max_len,
			    CORE_ADDR addr)
{
  init_disassemble_info (di, NULL, amd64_insn_length_fprintf);

  /* init_disassemble_info installs buffer_read_memory, etc.
     so we don't need to do that here.
     The cast is necessary until disassemble_info is const-ified.  */
  di->buffer = (gdb_byte *) insn;
  di->buffer_length = max_len;
  di->buffer_vma = addr;

  di->arch = gdbarch_bfd_arch_info (gdbarch)->arch;
  di->mach = gdbarch_bfd_arch_info (gdbarch)->mach;
  di->endian = gdbarch_byte_order (gdbarch);
  di->endian_code = gdbarch_byte_order_for_code (gdbarch);

  disassemble_init_for_target (di);
}

/* Return the length in bytes of INSN.
   MAX_LEN is the size of the buffer containing INSN.
   libopcodes currently doesn't export a utility to compute the
   instruction length, so use the disassembler until then.  */

static int
amd64_insn_length (struct gdbarch *gdbarch,
		   const gdb_byte *insn, int max_len, CORE_ADDR addr)
{
  struct disassemble_info di;

  amd64_insn_length_init_dis (gdbarch, &di, insn, max_len, addr);

  return gdbarch_print_insn (gdbarch, addr, &di);
}

d1190 2
a1191 1
  insn_length = amd64_insn_length (gdbarch, dsc->insn_buf, dsc->max_len, from);
@


1.78
log
@Remove the unused variable in amd64-tdep.c.

2010-04-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-tdep.c (amd64_supply_xstateregset): Remove the unused
	tdep.
	(amd64_collect_xstateregset): Likewise.
@
text
@d1029 1
a1029 1
static int ATTR_FORMAT (printf, 2, 3)
@


1.77
log
@Support amd64 AVX.

gdb/

2010-04-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-linux-nat.c: Include "regset.h", "elf/common.h",
	<sys/uio.h> and "i386-xstate.h".
	(PTRACE_GETREGSET): New.
	(PTRACE_SETREGSET): Likewise.
	(have_ptrace_getregset): Likewise.
	(amd64_linux_gregset64_reg_offset): Include 16 upper YMM
	registers.
	(amd64_linux_gregset32_reg_offset): Include 8 upper YMM
	registers.
	(amd64_linux_fetch_inferior_registers): Support PTRACE_GETFPREGS.
	(amd64_linux_store_inferior_registers): Likewise.
	(amd64_linux_read_description): Check and enable AVX target
	descriptions.

	* amd64-linux-tdep.c: Include "regset.h", "i386-linux-tdep.h"
	and "features/i386/amd64-avx-linux.c".
	(amd64_linux_regset_sections): New.
	(amd64_linux_core_read_description): Check and enable AVX
	target description.
	(amd64_linux_init_abi): Set xsave_xcr0_offset.  Call
	set_gdbarch_core_regset_sections.
	(_initialize_amd64_linux_tdep): Call
	initialize_tdesc_amd64_avx_linux.

	* amd64-linux-tdep.h (AMD64_LINUX_ORIG_RAX_REGNUM): Replace
	AMD64_MXCSR_REGNUM with AMD64_YMM15H_REGNUM.
	(tdesc_amd64_avx_linux): New.
	(amd64_linux_update_xstateregset): Likewise.

	* amd64-tdep.c: Include "features/i386/amd64-avx.c".
	(amd64_ymm_names): New.
	(amd64_ymmh_names): Likewise.
	(amd64_register_name): Likewise.
	(amd64_supply_xstateregset): Likewise.
	(amd64_collect_xstateregset): Likewise.
	(amd64_supply_xsave): Likewise.
	(amd64_collect_xsave): Likewise.
	(AMD64_NUM_REGS): Removed.
	(amd64_dwarf_reg_to_regnum): Return %ymmN register number for
	%xmmN if AVX is available.
	(amd64_pseudo_register_name): Support pseudo YMM registers.
	(amd64_regset_from_core_section): Support .reg-xstate section.
	(amd64_init_abi): Set ymmh_register_names, num_ymm_regs
	and ymm0h_regnum.  Call set_gdbarch_register_name.
	(amd64_init_abi): Call initialize_tdesc_amd64_avx.

	* amd64-tdep.h (amd64_regnum): Add AMD64_YMM0H_REGNUM and
	AMD64_YMM15H_REGNUM.
	(AMD64_NUM_REGS): New.
	(amd64_supply_xsave): Likewise.
	(amd64_collect_xsave): Likewise.
	(amd64_register_name): Removed.
	(amd64_register_type): Likewise.

gdb/testsuite/

2010-04-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.arch/i386-avx.c: New.
	* gdb.arch/i386-avx.exp: Likewise.

	* gdb.arch/i386-cpuid.h: Updated from gcc 4.4.
@
text
@a2219 1
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
a2229 1
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
@


1.76
log
@Support "ah", "bh", "ch", "dh" on amd64.

gdb/

2010-04-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-tdep.c (amd64_byte_names): Add "ah", "bh", "ch", "dh".
	(AMD64_NUM_LOWER_BYTE_REGS): New.
	(amd64_pseudo_register_read): Handle "ah", "bh", "ch", "dh".
	(amd64_pseudo_register_write): Likewise.
	(amd64_init_abi): Set num_byte_regs to 20.

gdb/testsuite/

2010-04-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.arch/amd64-byte.exp: Check "ah", "bh", "ch", "dh".
@
text
@d46 1
d75 15
a89 2
/* Total number of registers.  */
#define AMD64_NUM_REGS	ARRAY_SIZE (amd64_register_names)
d180 2
d189 3
d260 13
d281 2
d2213 22
d2253 10
d2325 7
d2345 2
d2427 1
d2463 24
d2510 23
@


1.75
log
@Restore sp for x86.

2010-03-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-tdep.c (amd64_word_names): Replace "sp" with "".
	* i386-tdep.c (i386_word_names): Likewise.
@
text
@d218 2
a219 1
  "r8l", "r9l", "r10l", "r11l", "r12l", "r13l", "r14l", "r15l"
d222 3
d270 12
a281 2
      regcache_raw_read (regcache, gpnum, raw_buf);
      memcpy (buf, raw_buf, 1);
d306 20
a325 6
      /* Read ...  */
      regcache_raw_read (regcache, gpnum, raw_buf);
      /* ... Modify ... (always little endian).  */
      memcpy (raw_buf, buf, 1);
      /* ... Write.  */
      regcache_raw_write (regcache, gpnum, raw_buf);
d2259 1
a2259 1
  tdep->num_byte_regs = 16;
@


1.74
log
@Support x86 pseudo byte, word and dword registers.

gdb/

2010-03-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-tdep.c (amd64_byte_names): New.
	(amd64_word_names): Likewise.
	(amd64_dword_names): Likewise.
	(amd64_pseudo_register_name): Likewise.
	(amd64_pseudo_register_read): Likewise.
	(amd64_pseudo_register_write): Likewise.
	(amd64_init_abi): Set num_byte_regs, num_word_regs, num_dword_regs
	and num_mmx_regs.  Call set_gdbarch_pseudo_register_read,
	set_gdbarch_pseudo_register_write and
	set_tdesc_pseudo_register_name.  Don't call
	set_gdbarch_num_pseudo_regs.  Don't set mm0_regnum.

	* i386-tdep.c (i386_num_mmx_regs): Removed.
	(i386_num_pseudo_regs): Likewise.
	(i386_byte_names): New.
	(i386_word_names): Likewise.
	(i386_byte_regnum_p): Likewise.
	(i386_word_regnum_p): Likewise.
	(i386_mmx_regnum_p): Updated.
	(i386_pseudo_register_name): Make it global.  Handle byte and
	word pseudo-registers.
	(i386_pseudo_register_read): Likewise.
	(i386_pseudo_register_write): Likewise.
	(i386_pseudo_register_type): Handle byte, word and dword
	pseudo-registers
	(i386_register_reggroup_p): Don't include pseudo
	registers, except for MXX, in any register groups.  Don't
	include pseudo byte, word, dword registers in general_reggroup.
	(i386_gdbarch_init): Set num_byte_regs, num_word_regs,
	num_dword_regs, al_regnum, ax_regnum and eax_regnum.  Put MMX
	pseudo-registers after word pseudo-registers.  Call
	set_gdbarch_num_pseudo_regs after calling gdbarch_init_osabi.

	* i386-tdep.h (gdbarch_tdep): Add num_mmx_regs, num_byte_regs,
	al_regnum, num_word_regs, ax_regnum, num_dword_regs and
	eax_regnum.
	(i386_byte_regnum_p): New.
	(i386_word_regnum_p): Likewise.
	(i386_dword_regnum_p): Likewise.
	(i386_pseudo_register_name): Likewise.
	(i386_pseudo_register_read): Likewise.
	(i386_pseudo_register_write): Likewise.

gdb/testsuite/

2010-03-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.arch/amd64-byte.exp: New.
	* gdb.arch/amd64-dword.exp: Likewise.
	* gdb.arch/amd64-pseudo.c: Likewise.
	* gdb.arch/amd64-word.exp: Likewise.
	* gdb.arch/i386-byte.exp: Likewise.
	* gdb.arch/i386-pseudo.c: Likewise.
	* gdb.arch/i386-word.exp: Likewise.
@
text
@d225 1
a225 1
  "ax", "bx", "cx", "dx", "si", "di", "bp", "sp", 
@


1.73
log
@Enable XML target descriptions for x86.

gdb/

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-linux-nat.c (AMD64_LINUX_USER64_CS): New.
	(amd64_linux_read_description): Likewise.
	(_initialize_amd64_linux_nat): Set to_read_description to
	amd64_linux_read_description.

	* amd64-linux-tdep.c: Include "features/i386/amd64-linux.c".
	(amd64_linux_register_name): Removed.
	(amd64_linux_register_type): Likewise.
	(amd64_linux_core_read_description): New.
	(amd64_linux_init_abi): Set target description to
	tdesc_amd64_linux if needed.  Support orig_rax in target
	description.  Don't call set_gdbarch_register_name nor
	set_gdbarch_register_type.  Call
	set_gdbarch_core_read_description.
	(_initialize_amd64_linux_tdep): Call
	initialize_tdesc_amd64_linux.

	* amd64-linux-tdep.h (tdesc_amd64_linux): New.

	* amd64-tdep.c:  Include "features/i386/amd64.c".
	(amd64_register_names): Removed.
	(amd64_register_name): Likewise.
	(amd64_register_type): Likewise.
	(amd64_init_abi):  Set num_core_regs and register_names.  Set
	target description to tdesc_amd64 if needed.  Don't call
	set_gdbarch_register_name nor set_gdbarch_register_type.
	(_initialize_amd64_tdep): New.

	* i386-linux-nat.c (i386_linux_read_description): New.
	(_initialize_i386_linux_nat): Set to_read_description to
	i386_linux_read_description.

	* i386-linux-tdep.c: Include "features/i386/i386-linux.c".
	(i386_linux_register_name): Removed.
	(i386_linux_core_read_description): New.
	(i386_linux_read_description): Likewise.
	(i386_linux_init_abi): Don't call set_gdbarch_register_name.
	Set target description to tdesc_i386_linux if needed.  Support
	orig_eax.  Set register_reggroup_p.  Call
	set_gdbarch_core_read_description.
	(_initialize_i386_linux_tdep): Call initialize_tdesc_i386_linux.

	* i386-linux-tdep.h (tdesc_i386_linux): New.

	* i386-nto-tdep.c (i386nto_regset_id): Replace I386_NUM_FREGS
	with I387_NUM_REGS.

	* i386-tdep.c: Include "features/i386/i386.c".
	(i386_register_names): Make it const.
	(i386_mmx_names): Likewise.
	(i386_num_register_names): Removed.
	(i386_register_name): Likewise.
	(i386_eflags_type): Likewise.
	(i386_mxcsr_type): Likewise.
	(i386_sse_type): Likewise.
	(i386_register_type): Likewise.
	(i387_ext_type): Call tdesc_find_type instead of arch_float_type.
	(i386_pseudo_register_name): New.
	(i386_pseudo_register_type): Likewise.
	(i386_mmx_type): Make it static.
	(i386_gdbarch_init): Check arch.  Replace I386_NUM_FREGS with
	I387_NUM_REGS.  Set num_core_regs and register_names.  Don't
	call set_gdbarch_register_name nor set_gdbarch_register_type.
	Set register_reggroup_p.  Set target description to tdesc_i386
	if needed.  Call set_tdesc_pseudo_register_type,
	set_tdesc_pseudo_register_name and tdesc_use_registers.
	(_initialize_i386_tdep): Call initialize_tdesc_i386.
	initialize_tdesc_x86_64.

	* i386-tdep.h (gdbarch_tdep): Remove i386_eflags_type,
	i386_mxcsr_type and i386_sse_type.  Add num_core_regs,
	register_names, tdesc and register_reggroup_p.
	(I386_NUM_FREGS): Removed.
	(i386_eflags_type): Likewise.
	(i386_mxcsr_type): Likewise.
	(i386_mmx_type): Likewise.
	(i386_sse_type): Likewise.
	(i386_register_name): Likewise.
	(i386_regnum): Add I386_MXCSR_REGNUM.
	(I386_SSE_NUM_REGS): Defined with I386_MXCSR_REGNUM.

	* i387-tdep.h (I387_NUM_REGS): New.

	* regformats/i386/i386-linux.dat: Generated.
	* regformats/i386/i386.dat: Likewise.
	* regformats/i386/amd64-linux.dat: Likewise.
	* regformats/i386/amd64.dat: Likewise.

	* regformats/reg-i386-linux.dat: Removed.
	* regformats/reg-i386.dat: Likewise.
	* regformats/reg-x86-64-linux.dat: Likewise.
	* regformats/reg-x86-64.dat: Likewise.

gdb/gdbserver/

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.in (clean): Replace reg-i386.c, reg-x86-64.c,
	reg-i386-linux.c and reg-x86-64-linux.c with i386.c, amd64.c,
	i386-linux.c and amd64-linux.c.
	(reg-i386.o): Removed.
	(reg-i386.c): Likewise.
	(reg-i386-linux.o): Likewise.
	(reg-i386-linux.c): Likewise.
	(reg-x86-64.o): Likewise.
	(reg-x86-64.c): Likewise.
	(reg-x86-64-linux.o): Likewise.
	(reg-x86-64-linux.c): Likewise.
	(i386.o): New.
	(i386.c): Likewise.
	(i386-linux.o): Likewise.
	(i386-linux.c): Likewise.
	(amd64.o): Likewise.
	(amd64.c): Likewise.
	(amd64-linux.o): Likewise.
	(amd64-linux.c): Likewise.

	* configure.srv (srv_i386_regobj): New.
	(srv_i386_linux_regobj): Likewise.
	(srv_amd64_regobj): Likewise.
	(srv_amd64_linux_regobj): Likewise.
	(srv_i386_32bit_xmlfiles): Likewise.
	(srv_i386_64bit_xmlfiles): Likewise.
	(srv_i386_xmlfiles): Likewise.
	(srv_amd64_xmlfiles): Likewise.
	(srv_i386_linux_xmlfiles): Likewise.
	(srv_amd64_linux_xmlfiles): Likewise.
	(i[34567]86-*-cygwin*): Set srv_regobj to $srv_i386_regobj.  Set
	srv_xmlfiles to $srv_i386_xmlfiles.
	(i[34567]86-*-mingw32ce*): Likewise.
	(i[34567]86-*-mingw*): Likewise.
	(i[34567]86-*-nto*): Likewise.
	(i[34567]86-*-linux*): Set srv_regobj to $srv_i386_linux_regobj
	and $srv_amd64_linux_regobj.  Set srv_xmlfiles to
	$srv_i386_linux_xmlfiles and $srv_amd64_linux_xmlfiles.
	(x86_64-*-linux*): Likewise.

	* linux-x86-low.c (init_registers_x86_64_linux): Removed.
	(init_registers_amd64_linux): New.
	(x86_arch_setup): Replace init_registers_x86_64_linux with
	init_registers_amd64_linux.

gdb/testsuite/

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.xml/tdesc-regs.exp (architecture): New.  Set it for x86.
	(load_description): Set architecture if defined.
@
text
@d213 101
d2231 13
a2294 4
  /* Avoid wiring in the MMX registers for now.  */
  set_gdbarch_num_pseudo_regs (gdbarch, 0);
  tdep->mm0_regnum = -1;

@


1.72
log
@amd64 - function returning record with field straddling 2 registers

gdb/ChangeLog:

        From Paul Hilfinger  <hilfinger@@adacore.com>
        * amd64-tdep.c (amd_classify_aggregate): Handle the case of
        a record of length <= 16 in which a field straddles the two
        eightbytes.

gdb/testsuite/ChangeLog:

        * gdb.ada/rec_return: New testcase.
@
text
@d45 2
a87 41
/* Return the name of register REGNUM.  */

const char *
amd64_register_name (struct gdbarch *gdbarch, int regnum)
{
  if (regnum >= 0 && regnum < AMD64_NUM_REGS)
    return amd64_register_names[regnum];

  return NULL;
}

/* Return the GDB type object for the "standard" data type of data in
   register REGNUM. */

struct type *
amd64_register_type (struct gdbarch *gdbarch, int regnum)
{
  if (regnum >= AMD64_RAX_REGNUM && regnum <= AMD64_RDI_REGNUM)
    return builtin_type (gdbarch)->builtin_int64;
  if (regnum == AMD64_RBP_REGNUM || regnum == AMD64_RSP_REGNUM)
    return builtin_type (gdbarch)->builtin_data_ptr;
  if (regnum >= AMD64_R8_REGNUM && regnum <= AMD64_R15_REGNUM)
    return builtin_type (gdbarch)->builtin_int64;
  if (regnum == AMD64_RIP_REGNUM)
    return builtin_type (gdbarch)->builtin_func_ptr;
  if (regnum == AMD64_EFLAGS_REGNUM)
    return i386_eflags_type (gdbarch);
  if (regnum >= AMD64_CS_REGNUM && regnum <= AMD64_GS_REGNUM)
    return builtin_type (gdbarch)->builtin_int32;
  if (regnum >= AMD64_ST0_REGNUM && regnum <= AMD64_ST0_REGNUM + 7)
    return i387_ext_type (gdbarch);
  if (regnum >= AMD64_FCTRL_REGNUM && regnum <= AMD64_FCTRL_REGNUM + 7)
    return builtin_type (gdbarch)->builtin_int32;
  if (regnum >= AMD64_XMM0_REGNUM && regnum <= AMD64_XMM0_REGNUM + 15)
    return i386_sse_type (gdbarch);
  if (regnum == AMD64_MXCSR_REGNUM)
    return i386_mxcsr_type (gdbarch);

  internal_error (__FILE__, __LINE__, _("invalid regnum"));
}

d2117 1
d2123 7
a2144 2
  set_gdbarch_register_name (gdbarch, amd64_register_name);
  set_gdbarch_register_type (gdbarch, amd64_register_type);
d2206 9
@


1.71
log
@amd64-windows: 32 bytes allocated on stack by caller for integer parameter registers

        * i386-tdep.h (struct gdbarch_tdep): Add new field
        integer_param_regs_saved_in_caller_frame.
        * amd64-windows-tdep.c (amd64_windows_init_abi): Set
        tdep->integer_param_regs_saved_in_caller_frame to 1.
        * amd64-tdep.c (amd64_push_dummy_call): Allocate some memory on
        stack if tdep->integer_param_regs_saved_in_caller_frame is set.
@
text
@d350 6
d365 24
@


1.70
log
@amd64-windows: memory args passed by pointer during function calls.

        * i386-tdep.h (gdbarch_tdep): Add field memory_args_by_pointer.
        * amd64-tdep.c (amd64_push_arguments): Add handling of architectures
        where tdep->memory_args_by_pointer is non-zero.
        * amd64-windows-tdep.c (amd64_windows_init_abi): Set
        tdep->memory_args_by_pointer to 1.
@
text
@d704 1
d722 5
@


1.69
log
@amd64: Integer parameters in function calls on Windows.

gdb/ChangeLog:

        * i386-tdep.h (enum amd64_reg_class): New, moved here from
        amd64-tdep.c.
        (struct gdbarch_tdep): Add fields call_dummy_num_integer_regs,
        call_dummy_integer_regs, and classify.
        * amd64-tdep.h (amd64_classify): Add declaration.
        * amd64-tdep.c (amd64_dummy_call_integer_regs): New static constant.
        (amd64_reg_class): Delete, moved to i386-tdep.h.
        (amd64_classify): Make non-static.  Move declaration to amd64-tdep.h.
        Replace call to amd64_classify by call to tdep->classify.
        (amd64_push_arguments): Get the list of registers to use for
        passing integer parameters from the gdbarch tdep structure,
        rather than using a hardcoded one.  Replace calls to amd64_classify
        by calls to tdep->classify.
        (amd64_push_dummy_call): Get the register number used for
        the "hidden" argument from tdep->call_dummy_integer_regs.
        (amd64_init_abi): Initialize tdep->call_dummy_num_integer_regs
        and tdep->call_dummy_integer_regs.  Set tdep->classify.
        * amd64-windows-tdep.c: Add include of gdbtypes.h.
        (amd64_windows_dummy_call_integer_regs): New static global.
        (amd64_windows_classify): New function.
        (amd64_windows_init_abi): Initialize tdep->call_dummy_num_integer_regs
        tdep->call_dummy_integer_regs and tdep->classify.

gdb/testsuite/ChangeLog:

        * gdb.ada/call_pn: New testcase.
@
text
@d543 2
a544 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
d557 5
d605 13
a617 1
	  stack_args[num_stack_args++] = args[i];
d673 1
d675 11
a685 1
      write_memory (sp + element * 8, valbuf, len);
@


1.68
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d75 11
a253 14
/* Register classes as defined in the psABI.  */

enum amd64_reg_class
{
  AMD64_INTEGER,
  AMD64_SSE,
  AMD64_SSEUP,
  AMD64_X87,
  AMD64_X87UP,
  AMD64_COMPLEX_X87,
  AMD64_NO_CLASS,
  AMD64_MEMORY
};

a289 2
static void amd64_classify (struct type *type, enum amd64_reg_class class[2]);

d381 1
a381 1
static void
d432 1
d442 1
d445 1
a445 1
  amd64_classify (type, class);
d543 4
a546 9
  static int integer_regnum[] =
  {
    AMD64_RDI_REGNUM,		/* %rdi */
    AMD64_RSI_REGNUM,		/* %rsi */
    AMD64_RDX_REGNUM,		/* %rdx */
    AMD64_RCX_REGNUM,		/* %rcx */
    8,				/* %r8 */
    9				/* %r9 */
  };
d563 2
d579 1
a579 1
      amd64_classify (type, class);
d593 1
a593 1
      if (integer_reg + needed_integer_regs > ARRAY_SIZE (integer_regnum)
d617 1
a617 1
		  regnum = integer_regnum[integer_reg++];
d683 5
d689 1
a689 1
      regcache_cooked_write (regcache, AMD64_RDI_REGNUM, buf);
d2136 4
@


1.67
log
@2009-12-20  Michael Snyder  <msnyder@@vmware.com>

	* amd64-tdep.c (amd64_epilogue_frame_cache): Fix buf size.
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.66
log
@	* amd64-tdep.c (amd64_init_frame_cache): Enhance comment describing
	saved_regs.
@
text
@d1931 1
a1931 1
  gdb_byte buf[4];
@


1.65
log
@2009-08-17  Michael Snyder  <msnyder@@vmware.com>

	* amd64-tdep.c: Add a frame unwinder for function epilogues.
	(amd64_in_function_epilogue_p): New function.
	(amd64_epilogue_frame_sniffer): New function.
	(amd64_epilogue_frame_cache): New function.
	(amd64_epilogue_frame_this_id): New function.
	(amd64_epilogue_frame_unwind): New struct frame_unwind.
	(amd64_init_abi): Hook the new unwinder.

	* amd64-linux-tdep.c (amd64_linux_init_abi): Set gdbarch to use
	SVR4 method for skip_trampoline_code.
@
text
@d1405 4
a1408 1
     offset (that's where %rbp is supposed to be stored).  */
@


1.65.2.1
log
@        * amd64-tdep.c (amd64_epilogue_frame_cache): Fix buf size.
@
text
@d1928 1
a1928 1
  gdb_byte buf[8];
@


1.64
log
@2009-08-10  Hui Zhu  <teawater@@gmail.com>

	Add AMD64 process record instruction set support.

	* i386-tdep.h (gdbarch_tdep): Add record_regmap for registers
	because the AMD64's registers order in GDB is not same with
	I386 instructions.
	Add i386_syscall_record to be the syscall function handle
	interface.
	(record_i386_regnum): Number for record_regmap.
	* i386-tdep.c (OT_QUAD): For 64 bits.
	(i386_record_s): Add rex_x, rex_b, rip_offset and
	popl_esp_hack for AMD64 instruction set. And regmap for
	record_regmap.
	(i386_record_lea_modrm_addr): Support AMD64 instruction set
	64 bits lea.
	(i386_record_lea_modrm): Ditto.
	(i386_record_push): New function.  Record the execution log
	of push.
	(I386_RECORD_ARCH_LIST_ADD_REG): New macro to record the
	register.
	(i386_process_record): Support AMD64 instruction set.
	* amd64-tdep.c (amd64_record_regmap): For record_regmap.
	(amd64_init_abi): Set amd64_record_regmap to record_regmap.
@
text
@d1890 83
d2151 6
@


1.63
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d1992 10
d2064 2
@


1.62
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d680 1
d689 1
a689 1
      store_unsigned_integer (buf, 8, struct_addr);
d695 1
a695 1
  store_unsigned_integer (buf, 8, bp_addr);
d699 1
a699 1
  store_unsigned_integer (buf, 8, sp);
d1038 1
d1052 1
a1052 1
  disp = extract_signed_integer (insn, sizeof (int32_t));
d1256 1
d1360 1
a1360 1
      retaddr = read_memory_unsigned_integer (rsp, retaddr_len);
d1362 1
a1362 1
      write_memory_unsigned_integer (rsp, retaddr_len, retaddr);
d1595 2
a1596 1
amd64_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
d1599 1
d1609 1
a1609 1
  op = read_memory_unsigned_integer (pc, 1);
d1644 2
a1645 1
  pc = amd64_analyze_prologue (start_pc, 0xffffffffffffffffLL, &cache);
d1658 2
d1672 2
a1673 1
    amd64_analyze_prologue (cache->pc, get_frame_pc (this_frame), cache);
d1679 1
a1679 1
      cache->saved_sp = extract_unsigned_integer(buf, 8);
d1703 2
a1704 1
	  cache->base = extract_unsigned_integer (buf, 8) + cache->sp_offset;
d1710 1
a1710 1
      cache->base = extract_unsigned_integer (buf, 8);
d1786 3
a1789 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));
d1800 1
a1800 1
  cache->base = extract_unsigned_integer (buf, 8) - 8;
@


1.61
log
@	* i386-tdep.h (struct gdbarch_tdep): Add i386_eflags_type and
	i386_mxcsr_type members.
	(i386_eflags_type): Make into function.
	(i386_mxcsr_type): Likewise.
	* i386-tdep.c (i386_eflags_type): Make into function.
	(i386_mxcsr_type): Likewise.
	(i386_register_type): Update uses.
	(i386_init_types): Remove.
	(_initialize_i386_tdep): Do not call it.
	* amd64-tdep.c (amd64_register_type): Update uses.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68k_ps_type member.
	* m68k-tdep.c (m68k_ps_type): Make into function.
	(m68k_register_type): Update use.
	(m68k_init_types): Remove.
	(_initialize_m68k_tdep): Do not call it.

	* sparc-tdep.h (struct gdbarch_tdep): Add sparc_psr_type,
	sparc_fsr_type, sparc64_pstate_type, sparc64_fsr_type, and
	sparc64_fprs_type members.
	* sparc-tdep.c (sparc_psr_type): Make into function.
	(sparc_fsr_type): Likewise.
	(sparc32_register_type): Update uses.
	(sparc_init_types): Remove.
	(_initialize_sparc_tdep): Do not call it.
	* sparc64-tdep.c (sparc64_pstate_type): Make into function.
	(sparc64_fsr_type): Likewise.
	(sparc64_fprs_type): Likewise.
	(sparc64_register_type): Update uses.
	(sparc64_init_types): Remove.
	(_initialize_sparc64_tdep): Likewise.
@
text
@d1078 3
a1080 3
			"displaced: using temp reg %d, old value 0x%s, new value 0x%s\n",
			dsc->tmp_regno, paddr_nz (dsc->tmp_save),
			paddr_nz (rip_base));
d1147 2
a1148 2
      fprintf_unfiltered (gdb_stdlog, "displaced: copy 0x%s->0x%s: ",
			  paddr_nz (from), paddr_nz (to));
d1261 1
a1261 1
			"displaced: fixup (0x%s, 0x%s), "
d1263 2
a1264 1
			paddr_nz (from), paddr_nz (to), insn[0], insn[1]);
d1271 2
a1272 2
	fprintf_unfiltered (gdb_stdlog, "displaced: restoring reg %d to 0x%s\n",
			    dsc->tmp_regno, paddr_nz (dsc->tmp_save));
d1336 3
a1338 2
				"relocated %%rip from 0x%s to 0x%s\n",
				paddr_nz (orig_rip), paddr_nz (rip));
d1363 4
a1366 4
			    "displaced: relocated return addr at 0x%s "
			    "to 0x%s\n",
			    paddr_nz (rsp),
			    paddr_nz (retaddr));
@


1.60
log
@	* gdbtypes.h (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(init_float_type, init_complex_type): Add prototypes.
	* gdbtypes.c (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(build_flt): Rename to ...
	(init_float_type): ... this.  Make global.
	(build_complex): Rename to ...
	(init_complex_type): ... this.  Make global.  Remove BIT argument.
	(gdbtypes_post_init): Update calls.

	* ada-lang.c (ada_language_arch_info): Use init_float_type.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* f-lang.c (build_fortran_types): Use init_float_type and
	init_complex_type.

	* target-descriptions.c (tdesc_gdb_type): Call init_float_type instead
	of using builtin_type_ieee_single, builtin_type_ieee_double, or
	builtin_type_arm_ext.

	* ia64-tdep.h (struct gdbarch_tdep): Add ia64_ext_type member.
	* ia64-tdep.c (builtin_type_ia64_ext): Remove.
	(_initialize_ia64_tdep): Do not initialize it.
	(floatformat_valid, floatformat_ia64_ext, floatformats_ia64_ext):
	Move up.
	(ia64_ext_type): New function.
	(ia64_register_reggroup_p, ia64_convert_register_p,
	ia64_register_to_value, ia64_value_to_register,
	ia64_extract_return_value, ia64_store_return_value): Use ia64_ext_type
	instead of builtin_type_ia64_ext.

	* i386-tdep.h (struct gdbarch_tdep): Add i387_ext_type member.
	(i387_ext_type): Add prototype.
	* i386-tdep.c (i387_ext_type): New function.
	(i386_extract_return_value, i386_store_return_value,
	i386_register_type): Use it instead of builtin_type_i387_ext.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* i387-tdep.c (print_i387_value, i387_register_to_value,
	i387_value_to_register): Likewise.
	(print_i387_value, print_i387_ext): Add GDBARCH argument.
	(print_i387_ext, i387_print_float_info): Pass to subroutines.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68881_ext_type member.
	* m68k-tdep.c (m68881_ext_type): New function.
	(m68k_register_type, m68k_convert_register_p): Use it instead
	of builtin_type_m68881_ext.

	* arm-tdep.h (struct gdbarch_tdep): Add arm_ext_type member.
	* arm-tdep.c (arm_ext_type): New function.
	(arm_register_type): Use it instead of builtin_type_arm_ext.

	* alpha-tdep.c (alpha_register_type): Use builtin types
	instead of builtin_type_ieee_double.

	* mips-tdep.c (mips_float_register_type, mips_double_register_type):
	Remove.
	(mips_register_type): Use builtin types instead of
	builtin_type_ieee_single and builtin_type_ieee_double.
	(mips_print_fp_register): Use builtin types instead of
	mips_float_register_type and mips_double_register_type.

	* hppa-tdep.c (hppa32_register_type, hppa64_register_type):
	Use builtin types instead of builtin_type_ieee_single and
	builtin_type_ieee_double.
@
text
@d101 1
a101 1
    return i386_eflags_type;
d111 1
a111 1
    return i386_mxcsr_type;
@


1.59
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d105 1
a105 1
    return builtin_type_i387_ext;
@


1.58
log
@	* amd64-tdep.c (amd64_skip_prefixes): Renamed from skip_prefixes.
	All callers updated.
	(amd64_get_insn_details): Handle more 3-byte opcode insns.
	(amd64_breakpoint_p): Delete.
	(amd64_displaced_step_fixup): When fixing up after stepping an int3,
	don't back up pc to the start of the int3.
	* i386-tdep.c: #include opcode/i386.h.
	(i386_skip_prefixes): New function.
	(i386_absolute_jmp_p): Constify argument.
	(i386_absolute_call_p,i386_ret_p,i386_call_p,i386_syscall_p): Ditto.
	(i386_breakpoint_p): Delete.
	(i386_displaced_step_fixup): Handle unnecessary or redundant prefixes.
	When fixing up after stepping an int3, don't back up pc to the start
	of the int3.

	* gdb.arch/amd64-disp-step.S (test_int3): New test.
	* gdb.arch/amd64-disp-step.exp (test_int3): New test.
	* gdb.arch/i386-disp-step.S (test_prefixed_abs_jump): New test.
	(test_prefixed_syscall,test_int3): New tests.
	* gdb.arch/i386-disp-step.exp (test_prefixed_abs_jump): New test.
	(test_prefixed_syscall,test_int3): New tests.
@
text
@d93 1
a93 1
    return builtin_type_int64;
d97 1
a97 1
    return builtin_type_int64;
d103 1
a103 1
    return builtin_type_int32;
d107 1
a107 1
    return builtin_type_int32;
@


1.57
log
@	* opcode/i386.h: Add multiple inclusion protection.
	(EAX_REG_NUM,ECX_REG_NUM,EDX_REGNUM,EBX_REG_NUM,ESI_REG_NUM)
	(EDI_REG_NUM): New macros.
	(MODRM_MOD_FIELD,MODRM_REG_FIELD,MODRM_RM_FIELD): New macros.
	(SIB_SCALE_FIELD,SIB_INDEX_FIELD,SIB_BASE_FIELD): New macros.
	(REG_PREFIX_P): New macro.

	* amd64-tdep.h (amd64_displaced_step_copy_insn): Declare.
	(amd64_displaced_step_fixup): Declare.
	* amd64-tdep.c: #include opcode/i386.h, dis-asm.h.
	(amd64_arch_regmap): Move out of amd64_analyze_stack_align
	and make static global.
	(amd64_arch_regmap_len): New static global.
	(amd64_arch_reg_to_regnum): New function.
	(struct amd64_insn): New struct.
	(struct displaced_step_closure): New struct.
	(onebyte_has_modrm,twobyte_has_modrm): New static globals.
	(rex_prefix_p,skip_prefixes)
	(amd64_insn_length_fprintf,amd64_insn_length_init_dis)
	(amd64_insn_length,amd64_get_unused_input_int_reg)
	(amd64_get_insn_details,fixup_riprel,fixup_displaced_copy)
	(amd64_displaced_step_copy_insn)
	(amd64_absolute_jmp_p,amd64_absolute_call_p,amd64_ret_p)
	(amd64_call_p,amd64_breakpoint_p,amd64_syscall_p)
	(amd64_displaced_step_fixup): New functions.
	* amd64-linux-tdep.c: #include arch-utils.h.
	(amd64_linux_init_abi): Install displaced stepping support.

	* gdb.arch/amd64-disp-step.S: New file.
	* gdb.arch/amd64-disp-step.exp: New file.
	* gdb.arch/i386-disp-step.S: New file.
	* gdb.arch/i386-disp-step.exp: New file.
@
text
@d808 1
a808 1
skip_prefixes (gdb_byte *insn)
d977 1
a977 1
  insn = skip_prefixes (insn);
d995 1
a995 1
      if (*insn == 0x38 || *insn == 0x3a)
d997 6
d1005 4
a1009 2
      else
	details->opcode_len = 2;
a1227 8
static int
amd64_breakpoint_p (const struct amd64_insn *details)
{
  const gdb_byte *insn = &details->raw_insn[details->opcode_offset];

  return insn[0] == 0xcc; /* int 3 */
}

d1326 3
a1328 14
	  /* If we have stepped over a breakpoint, set %rip to
	     point at the breakpoint instruction itself.

	     (gdbarch_decr_pc_after_break was never something the core
	     of GDB should have been concerned with; arch-specific
	     code should be making PC values consistent before
	     presenting them to GDB.)  */
	  if (amd64_breakpoint_p (insn_details))
	    {
	      if (debug_displaced)
		fprintf_unfiltered (gdb_stdlog,
				    "displaced: stepped breakpoint\n");
	      rip--;
	    }
@


1.56
log
@        Updated copyright notices for most files.
@
text
@d24 2
d205 36
d707 502
d1210 169
a1467 18
  static int regnums[16] = {
    AMD64_RAX_REGNUM,		/* %rax */
    AMD64_RCX_REGNUM,		/* %rcx */
    AMD64_RDX_REGNUM,		/* %rdx */
    AMD64_RBX_REGNUM,		/* %rbx */
    AMD64_RSP_REGNUM,		/* %rsp */
    AMD64_RBP_REGNUM,		/* %rbp */
    AMD64_RSI_REGNUM,		/* %rsi */
    AMD64_RDI_REGNUM,		/* %rdi */
    AMD64_R8_REGNUM,		/* %r8 */
    AMD64_R9_REGNUM,		/* %r9 */
    AMD64_R10_REGNUM,		/* %r10 */
    AMD64_R11_REGNUM,		/* %r11 */
    AMD64_R12_REGNUM,		/* %r12 */
    AMD64_R13_REGNUM,		/* %r13 */
    AMD64_R14_REGNUM,		/* %r14 */
    AMD64_R15_REGNUM,		/* %r15 */
  };
d1583 1
a1583 1
    cache->saved_sp_reg = regnums[reg];
@


1.55
log
@	Convert static_kind into loc_kind enum.
	* gdbtypes.h (enum field_loc_kind): New.
	(union field_location): New field dwarf_block.
	(struct field): Rename static_kind as loc_kind.
	(FIELD_STATIC_KIND): Rename to ...
	(FIELD_LOC_KIND): ... here.
	(TYPE_FIELD_STATIC_KIND): Rename to ...
	(TYPE_FIELD_LOC_KIND): ... here and use there now new FIELD_LOC_KIND.
	(TYPE_FIELD_STATIC_HAS_ADDR): Remove.
	(TYPE_FIELD_STATIC): Remove.
	(TYPE_FIELD_BITPOS): Reformat.
	(SET_FIELD_BITPOS): New.
	(FIELD_PHYSADDR): Rename to ...
	(FIELD_STATIC_PHYSADDR): ... here.
	(TYPE_FIELD_STATIC_PHYSADDR): Follow the FIELD_PHYSADDR rename.
	(SET_FIELD_PHYSADDR): Use new FIELD_LOC_KIND.
	(FIELD_PHYSNAME): Rename to ...
	(FIELD_STATIC_PHYSNAME): ... here.
	(TYPE_FIELD_STATIC_PHYSNAME): Follow the FIELD_PHYSNAME rename.
	(SET_FIELD_PHYSNAME): Use new FIELD_LOC_KIND.
	(FIELD_DWARF_BLOCK, TYPE_FIELD_DWARF_BLOCK, SET_FIELD_DWARF_BLOCK): New.
	(field_is_static): New declaration.
	* gdbtypes.c (field_is_static): New function.
	(copy_type_recursive): Update throughout.
	* amd64-tdep.c, c-typeprint.c, coffread.c, cp-valprint.c, dwarf2read.c,
	eval.c, jv-typeprint.c, jv-valprint.c, mdebugread.c, p-typeprint.c,
	p-valprint.c, valops.c, value.c, varobj.c: Update throughout.
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.54
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d319 1
a319 1
	  if (TYPE_FIELD_STATIC (type, i))
@


1.53
log
@2008-08-09  Xuepeng Guo  <xuepeng.guo@@intel.com>
	    H.J. Lu  <hongjiu.lu@@intel.com>
	    Mark Kettenis <kettenis@@gnu.org>

	* amd64-tdep.c (amd64_frame_cache): Add saved_sp_reg.
	(amd64_init_frame_cache): Initialize saved_sp_reg.
	(amd64_analyze_stack_align): New.
	(amd64_analyze_prologue): Call it.
	(amd64_frame_cache): Use saved_sp_reg if it is invalid.  Don't set
	%rip to 8 when halfway aligning the stack.

	* amd64-tdep.h (amd64_regnum): Add AMD64_R9_REGNUM to
	AMD64_R14_REGNUM.

	* i386-tdep.c (i386_frame_cache): Remove stack_align.  Add
	saved_sp_reg.
	(i386_alloc_frame_cache): Remove stack_align.  Initialize
	saved_sp_reg to -1.
	(i386_analyze_stack_align): Rewrite.
	(i386_frame_cache): Use saved_sp_reg if it is valid.
@
text
@d93 1
a93 1
    return builtin_type_void_data_ptr;
d97 1
a97 1
    return builtin_type_void_func_ptr;
d1280 1
a1280 1
  int len = TYPE_LENGTH (builtin_type_void_func_ptr);
d1288 2
a1289 1
  jb_addr = extract_typed_address (buf, builtin_type_void_data_ptr);
d1293 1
a1293 1
  *pc = extract_typed_address (buf, builtin_type_void_func_ptr);
@


1.52
log
@	* gdbarch.sh: Delete dwarf_reg_to_regnum.
	* gdbarch.c, gdbarch.h: Regenerated.
	* amd64-tdep.c, arm-tdep.c, h8300-tdep.c, hppa-linux-tdep.c,
	hppa-tdep.c, i386-tdep.c, m32c-tdep.c, m68k-tdep.c, mips-tdep.c,
	s390-tdep.c, xtensa-tdep.c: Do not set dwarf_reg_to_regnum.

	* gdbint.texinfo (Target Conditionals): Delete entry for
	gdbarch_dwarf_reg_to_regnum.
@
text
@d683 1
d706 1
d724 173
d920 2
d984 7
d1000 14
a1013 2
      get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 8) + cache->sp_offset;
d1027 4
a1030 2
     address.  */
  cache->saved_regs[AMD64_RIP_REGNUM] = 8;
@


1.51
log
@	Update i386 and amd64 ports for unwinder changes.

	* amd64-tdep.c (amd64_frame_cache): Expect this_frame.
	(amd64_frame_this_id, amd64_frame_prev_register): Update signature.
	(amd64_frame_unwind): Use default_frame_sniffer.
	(amd64_frame_sniffer): Delete.
	(amd64_sigtramp_frame_cache): Expect this_frame.
	(amd64_sigtramp_frame_this_id, amd64_sigtramp_frame_prev_register)
	(amd64_sigtramp_frame_sniffer): Update signature.
	(amd64_sigtramp_frame_unwind): Add amd64_sigtramp_frame_sniffer.
	(amd64_frame_base_address): Expect this_frame.
	(amd64_dummy_id): Renamed from amd64_unwind_dummy_id.  Expect
	this_frame.
	(amd64_init_abi): Use set_gdbarch_dummy_id and
	frame_unwind_append_unwinder.
	* i386-tdep.c (i386_frame_cache): Expect this_frame.
	(i386_frame_this_id, i386_frame_prev_register): Update signature.
	(i386_frame_unwind): Use default_frame_sniffer.
	(i386_frame_sniffer): Delete.
	(i386_sigtramp_frame_cache): Expect this_frame.
	(i386_sigtramp_frame_this_id, i386_sigtramp_frame_prev_register)
	(i386_sigtramp_frame_sniffer): Update signature.
	(i386_sigtramp_frame_unwind): Use i386_sigtramp_frame_sniffer.
	(i386_frame_base_address): Update signature.
	(i386_dummy_id): Rename from i386_unwind_dummy_id.  Expect this_frame.
	(i386_push_dummy_call): Update comment.
	(i386_sigtramp_p, i386_svr4_sigtramp_p, i386_svr4_sigcontext_addr):
	Expect this_frame.
	(i386_gdbarch_init): Use set_gdbarch_dummy_id, dwarf2_append_unwinders,
	and frame_unwind_append_unwinder.
	* amd64-linux-tdep.c, amd64-sol2-tdep.c, amd64fbsd-tdep.c,
	amd64nbsd-tdep.c, amd64obsd-tdep.c, i386-linux-tdep.c,
	i386-nto-tdep.c, i386bsd-tdep.c, i386-sol2-tdep.c, i386obsd-tdep.c,
	i386nbsd-tdep.c: Update for unwinder changes.
@
text
@a1138 1
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, amd64_dwarf_reg_to_regnum);
@


1.50
log
@	* amd64-tdep.c (amd64_get_longjmp_target): New.
	(amd64_init_abi): Register amd64_get_longjmp_target as
	gdbarch_get_longjmp_target callback.
	* i386-tdep.c (i386_get_longjmp_target): Remove 64-bit handling.
@
text
@d791 1
a791 1
amd64_frame_cache (struct frame_info *next_frame, void **this_cache)
d803 1
a803 1
  cache->pc = frame_func_unwind (next_frame, NORMAL_FRAME);
d805 1
a805 1
    amd64_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);
d816 1
a816 1
      frame_unwind_register (next_frame, AMD64_RSP_REGNUM, buf);
d821 1
a821 1
      frame_unwind_register (next_frame, AMD64_RBP_REGNUM, buf);
d844 1
a844 1
amd64_frame_this_id (struct frame_info *next_frame, void **this_cache,
d848 1
a848 1
    amd64_frame_cache (next_frame, this_cache);
d857 3
a859 5
static void
amd64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			   int regnum, int *optimizedp,
			   enum lval_type *lvalp, CORE_ADDR *addrp,
			   int *realnump, gdb_byte *valuep)
d861 1
a861 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d863 1
a863 1
    amd64_frame_cache (next_frame, this_cache);
d868 1
a868 12
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 8, cache->saved_sp);
	}
      return;
    }
d871 2
a872 13
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (gdbarch, regnum));
	}
      return;
    }
d874 1
a874 6
  *optimizedp = 0;
  *lvalp = lval_register;
  *addrp = 0;
  *realnump = regnum;
  if (valuep)
    frame_unwind_register (next_frame, (*realnump), valuep);
d881 3
a883 1
  amd64_frame_prev_register
a884 6

static const struct frame_unwind *
amd64_frame_sniffer (struct frame_info *next_frame)
{
  return &amd64_frame_unwind;
}
d894 1
a894 1
amd64_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
d897 1
a897 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (next_frame));
d907 1
a907 1
  frame_unwind_register (next_frame, AMD64_RSP_REGNUM, buf);
d910 1
a910 1
  addr = tdep->sigcontext_addr (next_frame);
d922 1
a922 1
amd64_sigtramp_frame_this_id (struct frame_info *next_frame,
d926 1
a926 1
    amd64_sigtramp_frame_cache (next_frame, this_cache);
d928 1
a928 1
  (*this_id) = frame_id_build (cache->base + 16, frame_pc_unwind (next_frame));
d931 3
a933 6
static void
amd64_sigtramp_frame_prev_register (struct frame_info *next_frame,
				    void **this_cache,
				    int regnum, int *optimizedp,
				    enum lval_type *lvalp, CORE_ADDR *addrp,
				    int *realnump, gdb_byte *valuep)
d936 1
a936 1
  amd64_sigtramp_frame_cache (next_frame, this_cache);
d938 1
a938 2
  amd64_frame_prev_register (next_frame, this_cache, regnum,
			     optimizedp, lvalp, addrp, realnump, valuep);
d941 4
a944 9
static const struct frame_unwind amd64_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  amd64_sigtramp_frame_this_id,
  amd64_sigtramp_frame_prev_register
};

static const struct frame_unwind *
amd64_sigtramp_frame_sniffer (struct frame_info *next_frame)
d946 1
a946 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (next_frame));
d951 1
a951 1
    return NULL;
d955 2
a956 2
      if (tdep->sigtramp_p (next_frame))
	return &amd64_sigtramp_frame_unwind;
d961 1
a961 1
      CORE_ADDR pc = frame_pc_unwind (next_frame);
d965 1
a965 1
	return &amd64_sigtramp_frame_unwind;
d968 1
a968 1
  return NULL;
d970 9
d982 1
a982 1
amd64_frame_base_address (struct frame_info *next_frame, void **this_cache)
d985 1
a985 1
    amd64_frame_cache (next_frame, this_cache);
d999 1
a999 1
amd64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
a1000 1
  gdb_byte buf[8];
d1003 1
a1003 2
  frame_unwind_register (next_frame, AMD64_RBP_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 8);
d1005 1
a1005 1
  return frame_id_build (fp + 16, frame_pc_unwind (next_frame));
d1162 1
a1162 1
  set_gdbarch_unwind_dummy_id (gdbarch, amd64_unwind_dummy_id);
d1164 2
a1165 2
  frame_unwind_append_sniffer (gdbarch, amd64_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, amd64_frame_sniffer);
@


1.49
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d1104 30
d1207 2
@


1.48
log
@
	* win32-nat.c (do_win32_fetch_inferior_registers): Use get_regcache_arch
	to get at the current architecture and at the target specific vector.
	Add target specific vector to I387_FISEG_REGNUM and I387_FOP_REGNUM and
	remove define of I387_ST0_REGNUM.

	* amd64-tdep.c (I387_ST0_REGNUM): Remove define.

	(amd64_supply_fxsave, amd64_collect_fxsave): Use get_regcache_arch to
	get at the current architecture
	(I387_FISEG_REGNUM, I387_FOSEG_REGNUM): Add target specific vector as
	parameter.

	* i386-tdep.c: Remove various define's and undef's of I387_ST0_REGNUM,
	I387_NUM_XMM_REGS and I387_MM0_REGNUM.

	(I387_NUM_XMM_REGS, I387_XMM0_REGNUM, I387_MXCSR_REGNUM,
	I387_ST0_REGNUM, I387_FCTRL_REGNUM, I387_MM0_REGNUM,
	(I387_FSTAT_REGNUM): Add target specific vector as parameter.

	(i386_register_name, i386_dbx_reg_to_regnum): Use gdbarch_tdep to get
	at the target specific vector.

	(i386_get_longjmp_target): Use get_frame_arch to get at the current
	architecture. Use gdbarch_tdep to get at the target specific vector.

	(i386_fp_regnum_p, i386_fpc_regnum_p): Add gdbarch as parameter and
	update caller. Use gdbarch_tdep to get at the target specific vector.

	(i386_register_to_value: Use get_frame_arch to get at the current
	architecture.

	* i386-tdep.h (i386_fp_regnum_p, i386_fpc_regnum_p): Add gdbarch as
	parameter.

	* i387-tdep.c (I387_FCTRL_REGNUM, I387_FSTAT_REGNUM, I387_FTAG_REGNUM,
	I387_FISEG_REGNUM, I387_FIOFF_REGNUM, I387_FOSEG_REGNUM
	I387_FOOFF_REGNUM, I387_FOP_REGNUM, I387_ST0_REGNUM, FSAVE_ADDR,
	FXSAVE_ADDR, I387_XMM0_REGNUM): Add target specific vector as parameter.

	(I387_ST0_REGNUM, I387_NUM_XMM_REGS): Remove various define's and
	undef's.

	(i387_convert_register_p, i387_register_to_value,
	i387_value_to_register): Update call for i386_fp_regnum_p.

	* i387-tdep.h: Remove comment.
	(I387_ST0_REGNUM, I387_NUM_XMM_REGS, I387_MM0_REGNUM): Add define.
	(I387_FCTRL_REGNUM, I387_FSTAT_REGNUM, I387_FTAG_REGNUM,
	I387_FISEG_REGNUM, I387_FIOFF_REGNUM, I387_FOSEG_REGNUM,
	I387_FOOFF_REGNUM, I387_FOP_REGNUM, I387_XMM0_REGNUM,
	I387_MXCSR_REGNUM): Add target specific vector as parameter.
@
text
@d395 2
a396 2
amd64_return_value (struct gdbarch *gdbarch, struct type *type,
		    struct regcache *regcache,
@


1.47
log
@	* amd64-tdep.c (amd64_classify): Add support for decimal float
	types.
	* i386-tdep.c (i386_return_value): Make 128-bit decimal float
	use the struct return convention.
@
text
@a1179 2
#define I387_ST0_REGNUM AMD64_ST0_REGNUM

d1194 1
a1194 1
		      const void *fxsave)
d1196 3
d1201 1
a1201 1
  if (fxsave && gdbarch_ptr_bit (get_regcache_arch (regcache)) == 64)
d1205 4
a1208 4
      if (regnum == -1 || regnum == I387_FISEG_REGNUM)
	regcache_raw_supply (regcache, I387_FISEG_REGNUM, regs + 12);
      if (regnum == -1 || regnum == I387_FOSEG_REGNUM)
	regcache_raw_supply (regcache, I387_FOSEG_REGNUM, regs + 20);
d1221 2
d1227 1
a1227 1
  if (gdbarch_ptr_bit (get_regcache_arch (regcache)) == 64)
d1229 4
a1232 4
      if (regnum == -1 || regnum == I387_FISEG_REGNUM)
	regcache_raw_collect (regcache, I387_FISEG_REGNUM, regs + 12);
      if (regnum == -1 || regnum == I387_FOSEG_REGNUM)
	regcache_raw_collect (regcache, I387_FOSEG_REGNUM, regs + 20);
@


1.46
log
@        * amd64-tdep.c (amd64_classify): Add handling of TYPE_CODE_CHAR.
@
text
@d367 4
a370 2
  /* Arguments of types float, double and __m64 are in class SSE.  */
  else if (code == TYPE_CODE_FLT && (len == 4 || len == 8))
d374 2
a375 2
  /* Arguments of types __float128 and __m128 are split into two
     halves.  The least significant ones belong to class SSE, the most
d377 3
a379 1
  /* FIXME: __float128, __m128.  */
@


1.46.2.1
log
@        * amd64-tdep.c (amd64_classify): Add support for decimal float
        types.
        * i386-tdep.c (i386_return_value): Make 128-bit decimal float
        use the struct return convention.
@
text
@d367 2
a368 4
  /* Arguments of types float, double, _Decimal32, _Decimal64 and __m64
     are in class SSE.  */
  else if ((code == TYPE_CODE_FLT || code == TYPE_CODE_DECFLOAT)
	   && (len == 4 || len == 8))
d372 2
a373 2
  /* Arguments of types __float128, _Decimal128 and __m128 are split into
     two halves.  The least significant ones belong to class SSE, the most
d375 1
a375 3
  else if (code == TYPE_CODE_DECFLOAT && len == 16)
    /* FIXME: __float128, __m128.  */
    class[0] = AMD64_SSE, class[1] = AMD64_SSEUP;
@


1.45
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d362 1
@


1.44
log
@	Updated copyright notices for most files.
@
text
@d769 1
a769 1
amd64_skip_prologue (CORE_ADDR start_pc)
@


1.43
log
@	* gdbarch.sh (stab_reg_to_regnum, dwarf_reg_to_regnum)
	( dwarf2_reg_to_regnum, sdb_reg_to_regnum, ecoff_reg_to_regnum): Add
	gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* xtensa-tdep.c (xtensa_reg_to_regnum): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* s390-tdep.c (s390_dwarf_reg_to_regnum): Likewise.
	* rs6000-tdep.c (rs6000_stab_reg_to_regnum)
	(rs6000_dwarf2_reg_to_regnum): Likewise.
	* mips-tdep.c (mips_stab_reg_to_regnum)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	* mep-tdep.c (mep_debug_reg_to_regnum): Likewise.
	* m32c-tdep.c (m32c_debug_info_reg_to_regnum): Likewise.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise
	* h8300-tdep.c (h8300s_dbg_reg_to_regnum)
	(h8300_dbg_reg_to_regnum): Likewise.
	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Likewise.
	* arch-utils.c (no_op_reg_to_regnum): Likewise.
	* arch-utils.h (no_op_reg_to_regnum): Likewise.
	* arm-tdep.c (arm_dwarf_reg_to_regnum): Likewise.
	* cris-tdep.c (cris_dwarf2_reg_to_regnum): Likewise.
	* hppa-tdep.c (hppa64_dwarf_reg_to_regnum): Likewise.
	* ia64-tdep.c (ia64_dwarf_reg_to_regnum): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.42
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d190 1
a190 1
amd64_dwarf_reg_to_regnum (int reg)
@


1.41
log
@	* amd64-tdep.c (amd64_convert_register_p): Delete.
	(amd64_init_abi): Use i387_convert_register_p.
	* alpha-tdep.c (alpha_convert_register_p): Return zero for
	eight byte types.
	(alpha_register_to_value, alpha_value_to_register): Do not handle
	eight byte types.
	* i386-tdep.c (i386_convert_register_p): Use i387_convert_register_p.
	* i387-tdep.c (i387_convert_register_p): New.
	(i387_register_to_value, i387_value_to_register): Update comments.
	* i387-tdep.h (i387_convert_register_p): Declare.
	* ia64-tdep.c (ia64_convert_register_p): Return zero for
	builtin_type_ia64_ext.
	(ia64_gdbarch_init): Do not initialize builtin_type_ia64_ext here.
	(_initialize_ia64_tdep): Initialize builtin_type_ia64_ext here.
	* m68k-tdep.c (m68k_convert_register_p): Return zero for
	builtin_type_m68881_ext.
	(m68k_register_to_value, m68k_value_to_register): Update comments.

	* gdbint.texinfo (Register and Memory Data, Target Conditionals):
	Document that gdbarch_convert_register_p should return zero for no-op
	conversions.
@
text
@d76 1
a76 1
amd64_register_name (int regnum)
@


1.40
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* amd64-tdep.c (amd64_frame_prev_register, amd64_sigtramp_frame_cache):
	Use get_regcache_arch or get_frame_arch to get at the current
	architecture by regcache or by frame, respectively.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* amd64-nat.c (amd64_supply_native_gregset)
	(amd64_collect_native_gregset): Replace current_gdbarch by gdbarch.
@
text
@a202 8
/* Return nonzero if a value of type TYPE stored in register REGNUM
   needs any special handling.  */

static int
amd64_convert_register_p (int regnum, struct type *type)
{
  return i386_fp_regnum_p (regnum);
}
d1150 1
a1150 1
  set_gdbarch_convert_register_p (gdbarch, amd64_convert_register_p);
@


1.39
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d866 1
d872 1
a872 1
  if (regnum == gdbarch_sp_regnum (current_gdbarch) && cache->saved_sp)
d896 1
a896 1
		       register_size (current_gdbarch, regnum));
d933 1
a933 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.38
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.37
log
@	* gdbtypes.c (builtin_type_v2_double, builtin_type_v4_float,
	builtin_type_v2_int64, builtin_type_v4_int32, builtin_type_v8_int16,
	builtin_type_v16_int8, builtin_type_v2_float, builtin_type_v2_int32,
	builtin_type_v4_int16, builtin_type_v8_int8, builtin_type_v4sf,
	builtin_type_v4si, builtin_type_v16qi, builtin_type_v8qi,
	builtin_type_v8hi, builtin_type_v4hi, builtin_type_v2si,
	builtin_type_vec64, builtin_type_vec128): Remove.
	(init_simd_type): Remove.
	(init_vector_type): Make global.
	(build_builtin_type_vec64, build_builtin_type_vec128): Remove.
	(build_gdbtypes): Do not build vector types.
	(_initialize_gdbtypes): Do not swap vector types.
	* gdbtypes.h (builtin_type_v2_double, builtin_type_v4_float,
	builtin_type_v2_int64, builtin_type_v4_int32, builtin_type_v8_int16,
	builtin_type_v16_int8, builtin_type_v2_float, builtin_type_v2_int32,
	builtin_type_v4_int16, builtin_type_v8_int8, builtin_type_v4sf,
	builtin_type_v4si, builtin_type_v16qi, builtin_type_v8qi,
	builtin_type_v8hi, builtin_type_v4hi, builtin_type_v2si,
	builtin_type_vec64, builtin_type_vec128): Remove declarations.
	(init_vector_type): Add prototype.

	* i386-tdep.h (struct gdbarch_tdep): Add i386_mmx_type and
	i386_sse_type members.
	(i386_mmx_type, i386_sse_type): Change from variables to functions.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Remove variables.
	(i386_init_types): Do not build vector types.
	(i386_mmx_type, i386_sse_type): New functions.
	(i386_register_type): Call them instead of using global variables.
	(i386_gdbarch_init): Use XCALLOC to allocate tdep structure.
	* amd64-tdep.c (amd64_register_type): Call i386_sse_type instead
	of using global variable.

	* rs6000-tdep.h (struct gdbarch_tdep): Add ppc_builtin_type_vec64
	and ppc_builtin_type_vec128 members.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): New function.
	(rs6000_builtin_type_vec128): Likewise.
	(rs6000_register_type): Call them instead of using builtin_type_vec64
	and builtin_type_vec128.
	(rs6000_gdbarch_init): Use XCALLOC to allocate tdep structure.

	* spu-tdep.c (struct gdbarch_tdep): New data type.
	(spu_builtin_type_vec128): Remove variable.
	(spu_builtin_type_vec128): New function.
	(spu_register_type): Call it instead of using global variable.
	(spu_gdbarch_init): Allocate tdep structure.
	(spu_init_vector_type): Remove function.
	(_initialize_spu_tdep): Do not call it.
@
text
@d873 1
a873 1
  if (regnum == SP_REGNUM && cache->saved_sp)
@


1.36
log
@	* amd64-tdep.c (struct amd64_register_info): Remove.
	(amd64_register_info): Remove.
	(amd64_register_names): New static variable.
	(AMD64_NUM_REGS): Use amd64_register_names instead of
	amd64_register_info.
	(amd64_register_name): Likewise.
	(amd64_register_type): Do not refer to amd64_register_info.

	* s390-tdep.c (struct s390_register_info): Remove.
	(s390_register_info): Remove.
	(s390_register_name): Do not refer to s390_register_info.
	(s390_register_type): Likewise.

	* sparc64-tdep.c (struct sparc64_register_info): Remove.
	(sparc64_register_info, sparc64_pseudo_register_info): Remove.
	(sparc64_register_names, sparc64_pseudo_register_names): New.
	(SPARC64_NUM_REGS, SPARC64_NUM_PSEUDO_REGS): Use
	sparc64_register_names and sparc64_pseudo_register_names instead of
	sparc64_register_info and sparc64_pseudo_register_info.
	(sparc64_register_name): Likewise.
	(sparc64_register_type): Do not refer to sparc64_register_info
	and sparc64_pseudo_register_info.
@
text
@d109 1
a109 1
    return i386_sse_type;
@


1.35
log
@	* amd64-tdep.c (amd64_init_frame_cache): New function.
	(amd64_alloc_frame_cache, amd64_skip_prologue): Use it.
@
text
@d54 1
a54 1
struct amd64_register_info
d56 1
a56 14
  char *name;
  struct type **type;
};

static struct amd64_register_info const amd64_register_info[] =
{
  { "rax", &builtin_type_int64 },
  { "rbx", &builtin_type_int64 },
  { "rcx", &builtin_type_int64 },
  { "rdx", &builtin_type_int64 },
  { "rsi", &builtin_type_int64 },
  { "rdi", &builtin_type_int64 },
  { "rbp", &builtin_type_void_data_ptr },
  { "rsp", &builtin_type_void_data_ptr },
d59 2
a60 16
  { "r8", &builtin_type_int64 },
  { "r9", &builtin_type_int64 },
  { "r10", &builtin_type_int64 },
  { "r11", &builtin_type_int64 },
  { "r12", &builtin_type_int64 },
  { "r13", &builtin_type_int64 },
  { "r14", &builtin_type_int64 },
  { "r15", &builtin_type_int64 },
  { "rip", &builtin_type_void_func_ptr },
  { "eflags", &i386_eflags_type },
  { "cs", &builtin_type_int32 },
  { "ss", &builtin_type_int32 },
  { "ds", &builtin_type_int32 },
  { "es", &builtin_type_int32 },
  { "fs", &builtin_type_int32 },
  { "gs", &builtin_type_int32 },
d63 2
a64 16
  { "st0", &builtin_type_i387_ext },
  { "st1", &builtin_type_i387_ext },
  { "st2", &builtin_type_i387_ext },
  { "st3", &builtin_type_i387_ext },
  { "st4", &builtin_type_i387_ext },
  { "st5", &builtin_type_i387_ext },
  { "st6", &builtin_type_i387_ext },
  { "st7", &builtin_type_i387_ext },
  { "fctrl", &builtin_type_int32 },
  { "fstat", &builtin_type_int32 },
  { "ftag", &builtin_type_int32 },
  { "fiseg", &builtin_type_int32 },
  { "fioff", &builtin_type_int32 },
  { "foseg", &builtin_type_int32 },
  { "fooff", &builtin_type_int32 },
  { "fop", &builtin_type_int32 },
d67 3
a69 17
  { "xmm0", &i386_sse_type },
  { "xmm1", &i386_sse_type },
  { "xmm2", &i386_sse_type },
  { "xmm3", &i386_sse_type },
  { "xmm4", &i386_sse_type },
  { "xmm5", &i386_sse_type },
  { "xmm6", &i386_sse_type },
  { "xmm7", &i386_sse_type },
  { "xmm8", &i386_sse_type },
  { "xmm9", &i386_sse_type },
  { "xmm10", &i386_sse_type },
  { "xmm11", &i386_sse_type },
  { "xmm12", &i386_sse_type },
  { "xmm13", &i386_sse_type },
  { "xmm14", &i386_sse_type },
  { "xmm15", &i386_sse_type },
  { "mxcsr", &i386_mxcsr_type }
d73 1
a73 1
#define AMD64_NUM_REGS	ARRAY_SIZE (amd64_register_info)
d81 1
a81 1
    return amd64_register_info[regnum].name;
d92 20
a111 1
  gdb_assert (regnum >= 0 && regnum < AMD64_NUM_REGS);
d113 1
a113 1
  return *amd64_register_info[regnum].type;
@


1.34
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d729 1
a729 1
/* Allocate and initialize a frame cache.  */
d731 2
a732 2
static struct amd64_frame_cache *
amd64_alloc_frame_cache (void)
a733 1
  struct amd64_frame_cache *cache;
a735 2
  cache = FRAME_OBSTACK_ZALLOC (struct amd64_frame_cache);

d749 1
d751 9
d820 1
@


1.33
log
@Copyright updates for 2007.
@
text
@d836 1
a836 1
  cache->pc = frame_func_unwind (next_frame);
@


1.32
log
@gdb/
	* Makefile.in (amd64_linux_tdep_h): New.
	(amd64-linux-nat.o, amd64-linux-tdep.o): Update.
	* amd64-linux-nat.c (amd64_linux_gregset64_reg_offset): Add
	ORIG_RAX.
	(_initialize_amd64_linux_nat): Set amd64_native_gregset64_num_regs.
	* amd64-linux-tdep.c (amd64_linux_register_name)
	(amd64_linux_register_type, amd64_linux_register_reggroup_p)
	(amd64_linux_write_pc): New.
	(amd64_linux_init_abi): Use them, and update num_regs.
	* amd64-linux-tdep.h: New file.
	* amd64-tdep.c (amd64_register_name, amd64_register_type): Make
	public.
	* amd64-tdep.h (amd64_register_name, amd64_register_type): New
	prototypes.

	* regformats/reg-x86-64-linux.dat: New file.
gdb/testsuite/
	* Makefile.in (clean): Clean reg-x86-64-linux.c.
	(reg-x86-64-linux.o, reg-x86-64-linux.c): New.
	* configure.srv (x86_64-*-linux*): Use reg-x86-64-linux.o.
	* linux-x86-64-low.c (x86_64_regmap): Include ORIG_RAX.
	(x86_64_fill_gregset, x86_64_store_gregset): Skip floating
	point registers.
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
@


1.31
log
@* amd64-tdep.c (amd64_classify): Handle TYPE_CODE_BOOL.
Fixes PR tdep/2075.
@
text
@d132 1
a132 1
static const char *
d144 1
a144 1
static struct type *
@


1.31.14.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d132 1
a132 1
const char *
d144 1
a144 1
struct type *
@


1.30
log
@* i386-tdep.c (i386_mxcsr_type): New variable.
(i386_init_types): Initialize i386_mxcsr_type.
(i386_register_type): Return i386_mxcsr_type for %mxcsr.
* i386-tdep.c (i386_mxcsr_type): New extern.
* amd64-tdep.c (amd64_register_info): Return i386_mxcsr_type for
%mxcsr.
@
text
@d407 1
a407 1
       || code == TYPE_CODE_RANGE
@


1.29
log
@* amd64-tdep.c (amd64_sse_type): Remove.
(amd64_register_info): Use i386_eflags_type and i386_sse_type
where appropriate.
(AMD64_NUM_REGS): Use ARRAY_SIZE.
(amd64_register_type): Remove code to build amd_sse_type.
* i386-tdep.c (i386_eflag_type): New variable.
(i386_mmx_type, i386_sse_type): Make global.
(i386_init_types): New function.
(i386_build_mmx_type, i386_build_sse_type): Remove functions.
(i386_register_type): Return i386_eflag_type, i386_sse_type and
i386_mmx_type when appropriate.
(_initialize_i386_tdep): Call i386_init_types.
* i386-tdep.h (i386_eflags_type, i386_mmx_type, i386_sse_type):
Declare extern.
Based on a previous patch form Michal Ludvig:
@
text
@d124 1
a124 1
  { "mxcsr", &builtin_type_int32 }
@


1.28
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 4
a6 2
   Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation,
   Inc.  Contributed by Jiri Smid, SuSE Labs.
a59 2
static struct type *amd64_sse_type;

d81 1
a81 1
  { "eflags", &builtin_type_int32 },
d108 16
a123 16
  { "xmm0", &amd64_sse_type },
  { "xmm1", &amd64_sse_type },
  { "xmm2", &amd64_sse_type },
  { "xmm3", &amd64_sse_type },
  { "xmm4", &amd64_sse_type },
  { "xmm5", &amd64_sse_type },
  { "xmm6", &amd64_sse_type },
  { "xmm7", &amd64_sse_type },
  { "xmm8", &amd64_sse_type },
  { "xmm9", &amd64_sse_type },
  { "xmm10", &amd64_sse_type },
  { "xmm11", &amd64_sse_type },
  { "xmm12", &amd64_sse_type },
  { "xmm13", &amd64_sse_type },
  { "xmm14", &amd64_sse_type },
  { "xmm15", &amd64_sse_type },
d128 1
a128 2
#define AMD64_NUM_REGS \
  (sizeof (amd64_register_info) / sizeof (amd64_register_info[0]))
a146 2
  struct type *t;

d149 1
a149 23
  /* ??? Unfortunately, amd64_init_abi is called too early, and so we
     cannot create the amd64_sse_type early enough to avoid any check
     at this point.  */
  t = *amd64_register_info[regnum].type;
  if (t != NULL)
    return t;

  gdb_assert (amd64_sse_type == NULL);

  t = init_composite_type ("__gdb_builtin_type_vec128i", TYPE_CODE_UNION);
  append_composite_type_field (t, "v4_float", builtin_type_v4_float);
  append_composite_type_field (t, "v2_double", builtin_type_v2_double);
  append_composite_type_field (t, "v16_int8", builtin_type_v16_int8);
  append_composite_type_field (t, "v8_int16", builtin_type_v8_int16);
  append_composite_type_field (t, "v4_int32", builtin_type_v4_int32);
  append_composite_type_field (t, "v2_int64", builtin_type_v2_int64);
  append_composite_type_field (t, "uint128", builtin_type_int128);

  TYPE_FLAGS (t) |= TYPE_FLAG_VECTOR;
  TYPE_NAME (t) = "builtin_type_vec128i";
      
  amd64_sse_type = t;
  return t;
@


1.27
log
@gdb/
2005-09-26  Jan Beulich  <jbeulich@@novell.com>

	* amd64-tdep.h (AMD64_FCTRL_REGNUM, AMD64_FSTAT_REGNUM,
	AMD64_MXCSR_REGNUM): New.
	* amd64-tdep.c (amd64_dwarf_regmap): Add eflags, selector regs,
	mxcsr, fp control and status words.
	* i386-tdep.c (): Add selector regs, mxcsr, fp control and status
	words.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.26
log
@	From Richard Henderson.
	* amd64-tdep.c (amd64_sse_type): New.
	(amd64_register_info): Use it for xmm registers.  Constify.
	(amd64_register_type): Initialize amd64_sse_type as needed.
@
text
@d215 29
a243 1
  AMD64_ST0_REGNUM + 6, AMD64_ST0_REGNUM + 7
@


1.25
log
@* amd64-tdep.c (amd64_frame_prev_register)
(amd64_sigtramp_frame_prev_register): Change type of last argument
to `gdb_byte *'.
@
text
@d58 3
a60 1
static struct amd64_register_info amd64_register_info[] =
d108 16
a123 16
  { "xmm0", &builtin_type_v4sf },
  { "xmm1", &builtin_type_v4sf },
  { "xmm2", &builtin_type_v4sf },
  { "xmm3", &builtin_type_v4sf },
  { "xmm4", &builtin_type_v4sf },
  { "xmm5", &builtin_type_v4sf },
  { "xmm6", &builtin_type_v4sf },
  { "xmm7", &builtin_type_v4sf },
  { "xmm8", &builtin_type_v4sf },
  { "xmm9", &builtin_type_v4sf },
  { "xmm10", &builtin_type_v4sf },
  { "xmm11", &builtin_type_v4sf },
  { "xmm12", &builtin_type_v4sf },
  { "xmm13", &builtin_type_v4sf },
  { "xmm14", &builtin_type_v4sf },
  { "xmm15", &builtin_type_v4sf },
d148 2
d152 23
a174 1
  return *amd64_register_info[regnum].type;
@


1.24
log
@* amd64-tdep.c (amd64_return_value): Change type of readbuf and
writebuf arguments to `gdb_byte *'.  Remove now redundant casts.
* i386-tdep.c (i386_return_value): Change type of readbuf and
writebuf arguments to `gdb_byte *'.
(i386_pseudo_register_read, i386_pseudo_register_write): Change
type of last argument to `gdb_byte *'.
(i386_register_to_value, i386_value_to_register): Change type of
last argument to `gdb_byte *'.  Simplify function a bit.
* i387-tdep.h (i387_value_to_register, i387_register_to_value):
Change type of last argument to `gdb_byte *'.
* i387-tdep.c: Likewise.
@
text
@d865 1
a865 1
			   int *realnump, void *valuep)
d972 1
a972 1
				    int *realnump, void *valuep)
@


1.23
log
@* amd64-tdep.c (amd64_return_value): Use `gdb_byte *' in casts.
(amd64_push_arguments): Use gdb_byte instead of bfd_byte.  Use
gdb_byte for buf.
(amd64_push_dummy_call): Use gdb_byte for buf.
(amd64_analyze_prologue): Use gdb_byte for proto, buf and op.
(amd64_frame_cache, amd64_sigtramp_frame_cache)
(amd64_unwind_dummy_id): Use gdb_byte for buf.
(amd64_supply_fxsave, amd64_collect_fxsave): Use `gdb_byte *' for
regs.
* amd64obsd-tdep.c (amd64obsd_supply_regset): Use `gdb_byte *' in
casts.
(amd64obsd_sigtramp_p): Use gdb_byte for sigreturn and `gdb_byte
*' for buf,
@
text
@d409 1
a409 1
		    void *readbuf, const void *writebuf)
d506 1
a506 1
				((gdb_byte *)readbuf) + i * 8);
d509 1
a509 1
				 ((const gdb_byte *)writebuf) + i * 8);
@


1.22
log
@2005-03-17  Paul Brook  <paul@@codesourcery.com>

	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Fix broken logic.
	* s390-tdep.c (s390_dwarf_reg_to_regnum): Ditto.
@
text
@d506 1
a506 1
				(char *) readbuf + i * 8);
d509 1
a509 1
				 (const char *) writebuf + i * 8);
d584 2
a585 2
	  const bfd_byte *valbuf = value_contents (args[i]);
	  char buf[8];
d633 1
a633 1
      const bfd_byte *valbuf = value_contents (stack_args[i]);
d654 1
a654 1
  char buf[8];
d743 3
a745 3
  static unsigned char proto[3] = { 0x48, 0x89, 0xe5 };
  unsigned char buf[3];
  unsigned char op;
d798 1
a798 1
  char buf[8];
d935 1
a935 1
  char buf[8];
d1037 1
a1037 1
  char buf[8];
d1205 1
a1205 1
      const char *regs = fxsave;
d1223 1
a1223 1
  char *regs = fxsave;
@


1.21
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d203 1
a203 1
  if (reg >= 0 || reg < amd64_dwarf_regmap_len)
@


1.20
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d207 1
a207 1
    warning (_("Unmapped DWARF Register #%d encountered\n"), reg);
@


1.19
log
@2005-01-05  Baurjan Ismagulov  <ibr@@ata.cs.hun.edu.tr>

	Committed by Andrew Cagney.
	* ada-valprint.c, aix-thread.c, alpha-nat.c: I18n markup.
	* alphabsd-nat.c, alphanbsd-tdep.c, amd64-linux-nat.c: I18n markup.
	* amd64-tdep.c,	amd64bsd-nat.c, amd64fbsd-nat.c: I18n markup.
	* arch-utils.c, arm-linux-nat.c, arm-tdep.c: I18n markup.
	* armnbsd-nat.c, armnbsd-tdep.c, auxv.c, avr-tdep.c: I18n markup.
	* aix-thread.c (_initialize_aix_thread): Get rid of the
	deprecated_add_show_from_set call.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* command.h (add_setshow_enum_cmd): Add arguments for returning
	new list elements.
	* cli/cli-decode.c (add_setshow_enum_cmd): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Modify calls to
	add_setshow_enum_cmd.
@
text
@d3 2
a4 2
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
   Contributed by Jiri Smid, SuSE Labs.
d584 1
a584 1
	  char *valbuf = VALUE_CONTENTS (args[i]);
d633 1
a633 1
      char *valbuf = VALUE_CONTENTS (stack_args[i]);
@


1.18
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* sparc-tdep.c: Replace VALUE_TYPE with value_type.
	* v850-tdep.c, sparc64-tdep.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, s390-tdep.c, mcore-tdep.c: Ditto.
	* h8300-tdep.c, arm-linux-tdep.c, amd64-tdep.c: Ditto.
	* hppa-tdep.c, mips-tdep.c, m88k-tdep.c: Ditto.
	* m68hc11-tdep.c, m32r-tdep.c, ia64-tdep.c: Ditto.
	* frv-tdep.c, cris-tdep.c, avr-tdep.c, alpha-tdep.c: Ditto.
@
text
@d207 1
a207 1
    warning ("Unmapped DWARF Register #%d encountered\n", reg);
@


1.17
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Do not set
	in_solib_call_trampoline to in_plt_entry, IN_SOLIB_CALL_TRAMPOLINE
	isn't used by this architecture.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* m68klinux-tdep.c (m68k_linux_init_abi): Ditto.
	* i386-tdep.c (i386_svr4_init_abi): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Ditto.
	* arm-linux-tdep.c (arm_linux_init_abi): Ditto.
	* amd64-tdep.c (amd64_init_abi): Ditto.
@
text
@d551 1
a551 1
      struct type *type = VALUE_TYPE (args[i]);
d632 1
a632 1
      struct type *type = VALUE_TYPE (stack_args[i]);
@


1.16
log
@2004-10-27  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Use
	frame_unwind_register instead of frame_register_unwind, do not
	recurse the register's location.
	* xstormy16-tdep.c (xstormy16_frame_prev_register):
	* sparc-tdep.c (sparc32_frame_prev_register): Ditto.
	* sparc64-tdep.c (sparc64_frame_prev_register): Ditto.
	* sh-tdep.c (sh_frame_prev_register): Ditto.
	* m68k-tdep.c (m68k_frame_prev_register): Ditto.
	* i386-tdep.c (i386_frame_prev_register): Ditto.
	* dwarf2-frame.c (dwarf2_frame_prev_register): Ditto.
	* amd64-tdep.c (amd64_frame_prev_register): Ditto.
@
text
@a1171 5
  /* FIXME: kettenis/20021026: This is ELF-specific.  Fine for now,
     since all supported AMD64 targets are ELF, but that might change
     in the future.  */
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);

@


1.15
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d901 6
a906 2
  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
@


1.14
log
@* amd64-tdep.c (amd64_supply_fpregset): Adjust comment.
(amd64_collect_fpregset): New function.
(amd64_regset_from_core_section): Use amd64_collect_fpregset.
@
text
@d649 1
a649 1
amd64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
@


1.13
log
@* regset.c: Tweak comment.
(regset_alloc): Remove descr argument.  Use GDBARCH_OBSTACK_ZALLOC
macro.
* regset.h: Update copyright year.
(struct regset): Remove `descr' member, add `gdbarch' member.
(regset_alloc): Adjust prototype and comment.
* i386-tdep.c (i386_supply_gregset): Get TDEP from REGSET->arch.
(i386_supply_fpregset): Likewise.
(i386_regset_from_core_section): Update call to regset_alloc.
* i386obsd-tdep.c (i386obsd_aout_supply_regset): Get TDEP from
REGSET->arch.
(i386obsd_aout_regset_from_core_section): Update call to
regset_alloc.
* i386nbsd-tdep.c (i386nbsd_aout_supply_regset): Get TDEP from
REGSET->arch.
(i386nbsd_aout_regset_from_core_section): Update call to
regset_alloc.
* amd64-tdep.c (amd64_supply_fpregset): Get TDEP from
REGSET->arch.
(amd64_regset_from_core_section): Update call to regset_alloc.
* amd64obsd-tdep.c (amd64obsd_supply_regset): Get TDEP from
REGSET->arch.
(amd64obsd_regset_from_core_section): Update call to regset_alloc.
* sparcnbsd-tdep.c (sparc32nbsd_supply_gregset): Directly pass
&sparc32nbsd_gregset in sparc32_supply_gregset call.
(sparc32nbsd_init_abi): Update call to regset_alloc.
* sparc64obsd-tdep.c (sparc64obsd_supply_gregset): Directly pass
&sparc64obsd_core_gregset in sparc64_supply_gregset call.
(sparc64obsd_init_abi): Update call to regset_alloc.
* sparc64nbsd-tdep.c (sparc64nbsd_supply_gregset): Directly pass
&sparc64nbsd_gregset in sparc64_supply_gregset call.
(sparc64nbsd_init_abi): Update call to regset_alloc.
* sparc64fbsd-tdep.c (sparc64fbsd_supply_gregset): Directly pass
&sparc64fbsd_gregset in sparc64_supply_gregset call.
(sparc64fbsd_init_abi): Update call to regset_alloc.
@
text
@d1051 3
a1053 3
/* Supply register REGNUM from the floating-point register set REGSET
   to register cache REGCACHE.  If REGNUM is -1, do this for all
   registers in REGSET.  */
d1065 16
d1093 2
a1094 1
        tdep->fpregset = regset_alloc (gdbarch, amd64_supply_fpregset, NULL);
@


1.12
log
@Allocate regset structures in the gdbarch's obstack, not using
xmalloc.
* regset.c (regset_alloc): Renamed from regset_xmalloc.
Add 'arch' argument.  Allocate the regset on arch's obstack, not
using xmalloc.
* regset.h (regset_alloc): Update declaration.
* am64-tdep.c (amd64_regset_from_core_section): Update call; pass
gdbarch argument.
* amd64obsd-tdep.c (amd64obsd_regset_from_core_section): Same.
* i386-tdep.c (i386_regset_from_core_section): Same.
* i386nbsd-tdep.c (i386nbsd_aout_regset_from_core_section): Same.
* i386obsd-tdep.c (i386obsd_aout_regset_from_core_section): Same.
* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Same.
* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Same.
* sparc64obsd-tdep.c (sparc64obsd_init_abi): Same.
* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Same.
@
text
@d1059 1
a1059 1
  const struct gdbarch_tdep *tdep = regset->descr;
d1077 1
a1077 2
        tdep->fpregset = regset_alloc (gdbarch, tdep,
                                       amd64_supply_fpregset, NULL);
@


1.11
log
@Use a constructor function to create regset structures.
* regset.h (supply_regset_ftype, collect_regset_ftype): New typedefs.
(struct regset): Use supply_regset_ftype.  Add new
'collect_regset' member.
(regset_xmalloc): New declaration.
* regset.c: New file.
* am64-tdep.c (amd64_regset_from_core_section): Use
regset_xmalloc to construct regset structures.
* amd64obsd-tdep.c (amd64obsd_regset_from_core_section): Same.
* i386-tdep.c (i386_regset_from_core_section): Same.
* i386nbsd-tdep.c (i386nbsd_aout_regset_from_core_section): Same.
* i386obsd-tdep.c (i386obsd_aout_regset_from_core_section): Same.
* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Same.
* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Same.
* sparc64obsd-tdep.c (sparc64obsd_init_abi): Same.
* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Same.
* Makefile.in (COMMON_OBS): Add regset.o.
(regset.o): New rule.
@
text
@d1077 2
a1078 1
        tdep->fpregset = regset_xmalloc (tdep, amd64_supply_fpregset, NULL);
@


1.10
log
@	* alpha-tdep.c (alpha_gdbarch_init): Use LL suffix for large
	constants.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* ia64-tdep.c (examine_prologue): Likewise.
	* ns32k-tdep.c (ns32k_fix_call_dummy): Remove unused function.
	* v850-tdep.c (v850_fix_call_dummy): Likewise.
@
text
@d1077 1
a1077 5
	{
	  tdep->fpregset = XMALLOC (struct regset);
	  tdep->fpregset->descr = tdep;
	  tdep->fpregset->supply_regset = amd64_supply_fpregset;
	}
@


1.9
log
@* amd64-tdep.c (amd64_return_value): Implement
RETURN_VALUE_ABI_RETURNS_ADDRESS.
@
text
@d784 1
a784 1
  pc = amd64_analyze_prologue (start_pc, 0xffffffffffffffff, &cache);
@


1.8
log
@* amd64-tdep.c (amd64_supply_fxsave): Only fiddle with
I387_FISEG_REGNUM and I387_FOSEG_REGNUM in 64-bit mode.
(amd64_collect_fxsave): Likewise.
@
text
@d425 6
a430 3
        for the return value and passes the address of this storage in
        %rdi as if it were the first argument to the function. In
        effect, this address becomes a hidden first argument.  */
d432 15
a446 1
    return RETURN_VALUE_STRUCT_CONVENTION;
@


1.7
log
@* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Rewrite to use new
sigtramp_p member of `struct gdbarch_tdep'.  Also check whether
the program counter is in the range specified by `struct
gdbarch_tdep'.
* amd64-linux-tdep.c: Include "symtab.h".
(amd64_linux_pc_in_sigtramp): Remove function.
(amd64_linux_sigtramp_p): New function.
(amd64_linux_init_abi): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* amd64nbsd-tdep.c: Include "symtab.h".
(amd64nbsd_sigtramp_p): New function.
(amd64nbsd_init_abi): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* amd64obsd-tdep.c: Include "symtab.h" and "objfiles.h".  Add a
few comments.
(amd64obsd_pc_in_sigtramp): Remove function.
(amd64obsd_sigtramp_p): New function.
(amd64obsd_init_abi): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* i386-tdep.h (struct gdbarch_tdep): Add sigtramp_p member.
(i386bsd_pc_ins_sigtramp): Remove prototype.
(i386bsd_sigtramp_start, i386bsd_sigtramp_end): Remove prototypes.
* i386-tdep.c (i386_sigtramp_frame_sniffer): Rewrite to use new
sigtramp_p member of `struct gdbarch_tdep'.  Also check whether
the program counter is in the range specified by `struct
gdbarch_tdep'.
(i386_pc_in_sigtramp, i386_svr4_pc_in_sigtramp): Remove functions.
(i386_sigtramp_p, i386_svr4_sigtramp_p): New functions.
(i386_go32_pc_in_sigtramp): Remove function.
(i386_svr4_init_abi): Don't set deprecated_pc_in_sigtramp.
Initialize TDEP->sigtramp_p.
(i386_go32_init_abi): Initialize TDEP->sigtramp_p to NULL.
(i386_gdbarch_init): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* i386-linux-tdep.c: Adjust comments.
(i386_linux_pc_in_sigtramp): Remove function.
(i386_linux_sigtramp_p): New function.
(i386_linux_init_abi): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* i386-nto-tdep.c: Update copyright year.
(i386nto_pc_in_sigtramp): Remove function.
(i386nto_sigtramp_p): New function.
(i386nto_sigcontext_addr): Use I386_ESP_REGNUM instead of
SP_REGNUM.
(i386nto_init_abi): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* i386-sol2-tdep.c: Update copyright year.
(i386_sol2_pc_in_sigtramp): Remove function.
(i386_sol2_sigtramp_p): New function.
(i386_sol2_init_abi): Initialize TDEP->sigtramp_p.  Don't set
deprecated_pc_in_sigtramp.
* i386bsd-tdep.c (i386bsd_pc_in_sigtramp): Remove function.
(i386bsd_sigtramp_start, i386bsd_sigtramp_end): Remove functions.
(i386bsd_init_abi): Don't set deprecated_pc_in_sigtramp,
deprecated_sigtramp_start and deprecated_sigtramp_end.
* i386nbsd-tdep.c: Include "frame.h" and "symtab.h".
(i386nbsd_pc_in_sigtramp): Remove function.
(i386nbsd_sigtramp_p): New function.
(i386nbsd_init_abi): Don't set deprecated_pc_in_sigtramp,
deprecated_sigtramp_start, deprecated_sigtramp_end.  Initialize
TDEP->sigtramp_start, TDEP->sigtramp_end and TDEP->sigtramp_p.
* i386obsd-tdep.c: Include "frame.h", "symtab.h" and "objfiles.h".
(i386obsd_pc_in_sigtramp): Remove function.
(i386obsd_sigtramp_p): New function.
(i386obsd_sigtramp_start, i386obsd_sigtramp_end): Remove
functions.
(i386bsd_init_abi): Don't set deprecated_pc_in_sigtramp,
deprecated_sigtramp_start, deprecated_sigtramp_end.  Initialize
TDEP->sigtramp_p.
* Makefile.in (amd64-linux-tdep.o, amd64nbsd-tdep.o,
amd64obsd-tdep.o, i386nbsd-tdep.o, i386obsd-tdep.o): Update
dependencies.
@
text
@d1174 1
a1174 1
  if (fxsave)
d1198 7
a1204 4
  if (regnum == -1 || regnum == I387_FISEG_REGNUM)
    regcache_raw_collect (regcache, I387_FISEG_REGNUM, regs + 12);
  if (regnum == -1 || regnum == I387_FOSEG_REGNUM)
    regcache_raw_collect (regcache, I387_FOSEG_REGNUM, regs + 20);
@


1.6
log
@        * amd64-tdep.c (amd64_classify): make RANGE_TYPE objects be part
        of the INTEGER class.
@
text
@d970 1
a970 2
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  char *name;
d972 12
a983 2
  find_pc_partial_function (pc, &name, NULL, NULL);
  if (DEPRECATED_PC_IN_SIGTRAMP (pc, name))
d985 1
a985 1
      gdb_assert (gdbarch_tdep (current_gdbarch)->sigcontext_addr);
d987 3
a989 1
      return &amd64_sigtramp_frame_unwind;
@


1.6.2.1
log
@Merge mainline to intercu branch.
@
text
@@


1.6.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d425 3
a427 6
     for the return value and passes the address of this storage in
     %rdi as if it were the first argument to the function. In effect,
     this address becomes a hidden first argument.

     On return %rax will contain the address that has been passed in
     by the caller in %rdi.  */
d429 1
a429 15
    {
      /* As indicated by the comment above, the ABI guarantees that we
         can always find the return value just after the function has
         returned.  */

      if (readbuf)
	{
	  ULONGEST addr;

	  regcache_raw_read_unsigned (regcache, AMD64_RAX_REGNUM, &addr);
	  read_memory (addr, readbuf, TYPE_LENGTH (type));
	}

      return RETURN_VALUE_ABI_RETURNS_ADDRESS;
    }
d632 1
a632 1
amd64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
d767 1
a767 1
  pc = amd64_analyze_prologue (start_pc, 0xffffffffffffffffLL, &cache);
d970 2
a971 12
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (next_frame));

  /* We shouldn't even bother if we don't have a sigcontext_addr
     handler.  */
  if (tdep->sigcontext_addr == NULL)
    return NULL;

  if (tdep->sigtramp_p != NULL)
    {
      if (tdep->sigtramp_p (next_frame))
	return &amd64_sigtramp_frame_unwind;
    }
d973 2
a974 1
  if (tdep->sigtramp_start != 0)
d976 1
a976 1
      CORE_ADDR pc = frame_pc_unwind (next_frame);
d978 1
a978 3
      gdb_assert (tdep->sigtramp_end != 0);
      if (pc >= tdep->sigtramp_start && pc < tdep->sigtramp_end)
	return &amd64_sigtramp_frame_unwind;
d1023 3
a1025 3
/* Supply register REGNUM from the buffer specified by FPREGS and LEN
   in the floating-point register set REGSET to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
d1031 1
a1031 1
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
a1036 16
/* Collect register REGNUM from the register cache REGCACHE and store
   it in the buffer specified by FPREGS and LEN as described by the
   floating-point register set REGSET.  If REGNUM is -1, do this for
   all registers in REGSET.  */

static void
amd64_collect_fpregset (const struct regset *regset,
			const struct regcache *regcache,
			int regnum, void *fpregs, size_t len)
{
  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);

  gdb_assert (len == tdep->sizeof_fpregset);
  amd64_collect_fxsave (regcache, regnum, fpregs);
}

d1049 5
a1053 2
	tdep->fpregset = regset_alloc (gdbarch, amd64_supply_fpregset,
				       amd64_collect_fpregset);
d1163 1
a1163 1
  if (fxsave && gdbarch_ptr_bit (get_regcache_arch (regcache)) == 64)
d1187 4
a1190 7
  if (gdbarch_ptr_bit (get_regcache_arch (regcache)) == 64)
    {
      if (regnum == -1 || regnum == I387_FISEG_REGNUM)
	regcache_raw_collect (regcache, I387_FISEG_REGNUM, regs + 12);
      if (regnum == -1 || regnum == I387_FOSEG_REGNUM)
	regcache_raw_collect (regcache, I387_FOSEG_REGNUM, regs + 20);
    }
@


1.5
log
@2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PC_IN_SIGTRAMP): Change to a function with
	predicate, deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-linux-tdep.c (alpha_linux_init_abi): Update.
	* alpha-osf1-tdep.c (alpha_osf1_init_abi): Update.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Update.
	* alphafbsd-tdep.c (alphafbsd_init_abi): Update.
	* alphanbsd-tdep.c (alphanbsd_init_abi): Update.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Update.
	* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Update.
	* amd64nbsd-tdep.c (amd64nbsd_init_abi): Update.
	* amd64obsd-tdep.c (amd64obsd_init_abi): Update.
	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Update.
	* blockframe.c (find_pc_partial_function): Update.
	* breakpoint.c (bpstat_what): Update.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update.
	* frv-linux-tdep.c (frv_linux_init_abi): Update.
	* frv-tdep.c (frv_sigtramp_frame_sniffer): Update.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* i386-nto-tdep.c (i386nto_init_abi): Update.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Update.
	* i386-tdep.c (i386_sigtramp_frame_sniffer)
	(i386_svr4_init_abi, i386_go32_init_abi, i386_gdbarch_init): Update.
	* i386bsd-tdep.c (i386bsd_init_abi): Update.
	* i386nbsd-tdep.c (i386nbsd_init_abi): Update.
	* i386obsd-tdep.c (i386obsd_init_abi): Update.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Update.
	* infrun.c (pc_in_sigtramp): Update.
	* m68k-tdep.c (m68k_sigtramp_frame_sniffer): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mipsnbsd-tdep.c (mipsnbsd_init_abi): Update.
	* ppc-linux-tdep.c: Update comment.
	* ppcnbsd-tdep.c (ppcnbsd_init_abi): Update.
	* shnbsd-tdep.c (shnbsd_init_abi): Update.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Update.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Update.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Update.
	* sparcobsd-tdep.c (sparc32obsd_init_abi): Update.

Index: doc/ChangeLog
2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	references to PC_IN_SIGTRAMP.
@
text
@d374 3
a376 1
     long, long long, and pointers are in the INTEGER class.  */
d378 1
@


1.4
log
@* amd64-tdep.h (amd64_fill_fxsave): Remove prototype.
* amd64-tdep.c (amd64_fill_fxsave): Remove function.
@
text
@d971 1
a971 1
  if (PC_IN_SIGTRAMP (pc, name))
@


1.3
log
@* amd64-tdep.h: (amd64_collect_fxsave): New prototype.
* amd64-tdep.c (amd64_collect_fxsave): New function.
(amd64_fill_fxsave): Simply call amd64_collect_fxsave.
@
text
@a1188 11

/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FXSAVE with the value in GDB's register cache.  If REGNUM is -1, do
   this for all registers.  This function doesn't touch any of the
   reserved bits in *FXSAVE.  */

void
amd64_fill_fxsave (char *fxsave, int regnum)
{
  amd64_collect_fxsave (current_regcache, regnum, fxsave);
}
@


1.3.4.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d1189 11
@


1.2
log
@* amd64-tdep.c (amd64_frame_cache): Fix comment.
@
text
@d1172 19
d1198 1
a1198 6
  i387_fill_fxsave (fxsave, regnum);

  if (regnum == -1 || regnum == I387_FISEG_REGNUM)
    regcache_collect (I387_FISEG_REGNUM, fxsave + 12);
  if (regnum == -1 || regnum == I387_FOSEG_REGNUM)
    regcache_collect (I387_FOSEG_REGNUM, fxsave + 20);
@


1.1
log
@* amd64-tdep.h: Renamed from x86-64-tdep.h.
* amd64-tdep.c: Renamed from x86-64-tdep.c.  Include
"amd64-tdep.h" instead of "x86-64-tdep.h".
* amd64-nat.c: Include "amd64-tdep.h" instead of "x86-64-tdep.h".
* amd64-linux-tdep.h: Renamed from x86-64-linux.h.
* amd64-linux-tdep.c: Renamed from x86-64-linux-tdep.c.  Include
"amd64-tdep.h" and "amd64-linux-tdep.h" instead of "x86-64-tdep.h"
and "x86-64-tdep.c".
* amd64-linux-nat.c: Renamed from x86-64-linux-nat.c.  Include
"amd64-tdep.h" and "amd64-linux-tdep.h" instead of "x86-64-tdep.h"
and "x86-64-tdep.c".
* amd64bsd-nat.c: Update copyright year.
Include "amd64-tdep.h" instead of "x86-64-tdep.h".
* amd64fbsd-tdep.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64fbsd-nat.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64nbsd-tdep.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64nbsd-nat.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64obsd-tdep.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64obsd-nat.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* configure.host: (x86_64-*-linux*): Set gdb_target to linux64.
* configure.tgt (x86_64-*-linux*): Set gdb_target to linux64.
* Makefile.in (amd64_linux_tdep_h): Renamed from
x86_64_linux_tdep_h.
(amd64_tdep_h): Renamed from x86_64_tdep_h.
(amd64bsd-nat.o, amd64fbsd-nat.o, amd64fbsd-tdep.o, amd64-nat.o)
(amd64nbsd-nat.o, amd64nbsd-tdep.o, amd64obsd-nat.o)
(amd64obsd-tdep.o): Update dependencies.
(amd64-tdep.o, amd64-linux-nat.o, amd64-linux-tdep.o): New
dependencies.
(x86-64-linux-nat.o, x86-64-linux-tdep.o, x86-64-tdep.o): Remove
dependencies.
(ALLDEPFILES): Add amd64-tdep.c, amd64obsd-nat.c, amd64obsd-nat.c,
amd64-linux-nat.c amd64-linux-tdep.c.
* config/i386/tm-linux64.h: Renamed from tm-x86-64linux.h
* config/i386/nm-linux64.h: Renamed from nm-x86-64linux.h.
* config/i386/linux64.mt: Renamed from x86-64linux.mt.
(TDEPFILES): Replace x86-64-tdep.o and x86-64-linux-tdep.o with
amd64-tdep.o and amd64-linux-tdep.o.
(TM_FILE): Set to tm-linux64.h.
* config/i386/linux64.mh: Renamed from x86-64linux.mh.
(NAT_FILE): Set to nm-linux64.h.
(NATDEPFILES): Replace x86-64-linux-nat.o with amd64-linux-nat.o.
* config/i386/fbsd64.mt (TDEPFILES): Replace x86-64-tdep.o with
amd64-tdep.o.
* config/i386/nbsd64.mt (TDEPFILES): Replace x86-64-tdep.o with
amd64-tdep.o.
* config/i386/obsd64.mt (TDEPFILES): Replace x86-64-tdep.o with
amd64-tdep.o.
@
text
@d793 6
a798 7
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */
@

