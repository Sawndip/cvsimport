head	1.351;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.329
	gdb_7_6-2013-04-26-release:1.329
	gdb_7_6-branch:1.329.0.2
	gdb_7_6-2013-03-12-branchpoint:1.329
	gdb_7_5_1-2012-11-29-release:1.311
	gdb_7_5-2012-08-17-release:1.311
	gdb_7_5-branch:1.311.0.2
	gdb_7_5-2012-07-18-branchpoint:1.311
	gdb_7_4_1-2012-04-26-release:1.293.2.1
	gdb_7_4-2012-01-24-release:1.293.2.1
	gdb_7_4-branch:1.293.0.2
	gdb_7_4-2011-12-13-branchpoint:1.293
	gdb_7_3_1-2011-09-04-release:1.280
	gdb_7_3-2011-07-26-release:1.280
	gdb_7_3-branch:1.280.0.2
	gdb_7_3-2011-04-01-branchpoint:1.280
	gdb_7_2-2010-09-02-release:1.259.2.1
	gdb_7_2-branch:1.259.0.2
	gdb_7_2-2010-07-07-branchpoint:1.259
	gdb_7_1-2010-03-18-release:1.239.2.1
	gdb_7_1-branch:1.239.0.2
	gdb_7_1-2010-02-18-branchpoint:1.239
	gdb_7_0_1-2009-12-22-release:1.226
	gdb_7_0-2009-10-06-release:1.226
	gdb_7_0-branch:1.226.0.2
	gdb_7_0-2009-09-16-branchpoint:1.226
	arc-sim-20090309:1.154
	msnyder-checkpoint-072509-branch:1.218.0.2
	msnyder-checkpoint-072509-branchpoint:1.218
	arc-insight_6_8-branch:1.154.0.6
	arc-insight_6_8-branchpoint:1.154
	insight_6_8-branch:1.154.0.4
	insight_6_8-branchpoint:1.154
	reverse-20081226-branch:1.193.0.2
	reverse-20081226-branchpoint:1.193
	multiprocess-20081120-branch:1.191.0.2
	multiprocess-20081120-branchpoint:1.191
	reverse-20080930-branch:1.184.0.2
	reverse-20080930-branchpoint:1.184
	reverse-20080717-branch:1.169.0.2
	reverse-20080717-branchpoint:1.169
	msnyder-reverse-20080609-branch:1.163.0.2
	msnyder-reverse-20080609-branchpoint:1.163
	drow-reverse-20070409-branch:1.137.0.2
	drow-reverse-20070409-branchpoint:1.137
	gdb_6_8-2008-03-27-release:1.154
	gdb_6_8-branch:1.154.0.2
	gdb_6_8-2008-02-26-branchpoint:1.154
	gdb_6_7_1-2007-10-29-release:1.147
	gdb_6_7-2007-10-10-release:1.147
	gdb_6_7-branch:1.147.0.2
	gdb_6_7-2007-09-07-branchpoint:1.147
	insight_6_6-20070208-release:1.128
	gdb_6_6-2006-12-18-release:1.128
	gdb_6_6-branch:1.128.0.2
	gdb_6_6-2006-11-15-branchpoint:1.128
	insight_6_5-20061003-release:1.119
	gdb-csl-symbian-6_4_50_20060226-12:1.116.2.1.2.4
	gdb-csl-sourcerygxx-3_4_4-25:1.111
	nickrob-async-20060828-mergepoint:1.124
	gdb-csl-symbian-6_4_50_20060226-11:1.116.2.1.2.4
	gdb-csl-sourcerygxx-4_1-17:1.116.2.1
	gdb-csl-20060226-branch-local-2:1.116.2.1
	gdb-csl-sourcerygxx-4_1-14:1.116.2.1
	gdb-csl-sourcerygxx-4_1-13:1.116.2.1
	gdb-csl-sourcerygxx-4_1-12:1.116.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.116.2.1
	gdb_6_5-20060621-release:1.119
	gdb-csl-sourcerygxx-4_1-9:1.116.2.1
	gdb-csl-sourcerygxx-4_1-8:1.116.2.1
	gdb-csl-sourcerygxx-4_1-7:1.116.2.1
	gdb-csl-arm-2006q1-6:1.116.2.1
	gdb-csl-sourcerygxx-4_1-6:1.116.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.116.2.1.2.4
	gdb-csl-symbian-6_4_50_20060226-9:1.116.2.1.2.4
	gdb-csl-symbian-6_4_50_20060226-8:1.116.2.1.2.4
	gdb-csl-coldfire-4_1-11:1.116.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.116.2.1
	gdb-csl-coldfire-4_1-10:1.116.2.1
	gdb_6_5-branch:1.119.0.4
	gdb_6_5-2006-05-14-branchpoint:1.119
	gdb-csl-sourcerygxx-4_1-5:1.116.2.1
	nickrob-async-20060513-branch:1.119.0.2
	nickrob-async-20060513-branchpoint:1.119
	gdb-csl-sourcerygxx-4_1-4:1.116.2.1
	msnyder-reverse-20060502-branch:1.118.0.4
	msnyder-reverse-20060502-branchpoint:1.118
	gdb-csl-morpho-4_1-4:1.116.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.116.2.1
	readline_5_1-import-branch:1.118.0.2
	readline_5_1-import-branchpoint:1.118
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.116.2.1
	gdb-csl-symbian-20060226-branch:1.116.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.116.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.116.2.1
	msnyder-reverse-20060331-branch:1.117.0.2
	msnyder-reverse-20060331-branchpoint:1.117
	gdb-csl-available-20060303-branch:1.116.0.4
	gdb-csl-available-20060303-branchpoint:1.116
	gdb-csl-20060226-branch:1.116.0.2
	gdb-csl-20060226-branchpoint:1.116
	gdb_6_4-20051202-release:1.111
	msnyder-fork-checkpoint-branch:1.111.0.8
	msnyder-fork-checkpoint-branchpoint:1.111
	gdb-csl-gxxpro-6_3-branch:1.111.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.111
	gdb_6_4-branch:1.111.0.4
	gdb_6_4-2005-11-01-branchpoint:1.111
	gdb-csl-arm-20051020-branch:1.111.0.2
	gdb-csl-arm-20051020-branchpoint:1.111
	msnyder-tracepoint-checkpoint-branch:1.109.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.109
	gdb-csl-arm-20050325-2005-q1b:1.103
	gdb-csl-arm-20050325-2005-q1a:1.103
	csl-arm-20050325-branch:1.103.0.2
	csl-arm-20050325-branchpoint:1.103
	gdb-post-i18n-errorwarning-20050211:1.94
	gdb-pre-i18n-errorwarning-20050211:1.93
	gdb_6_3-20041109-release:1.90
	gdb_6_3-branch:1.90.0.2
	gdb_6_3-20041019-branchpoint:1.90
	drow_intercu-merge-20040921:1.80
	drow_intercu-merge-20040915:1.80
	jimb-gdb_6_2-e500-branch:1.75.0.6
	jimb-gdb_6_2-e500-branchpoint:1.75
	gdb_6_2-20040730-release:1.75
	gdb_6_2-branch:1.75.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.75
	gdb_6_1_1-20040616-release:1.70
	gdb_6_1-2004-04-05-release:1.70
	drow_intercu-merge-20040402:1.71
	drow_intercu-merge-20040327:1.71
	ezannoni_pie-20040323-branch:1.71.0.4
	ezannoni_pie-20040323-branchpoint:1.71
	cagney_tramp-20040321-mergepoint:1.71
	cagney_tramp-20040309-branch:1.71.0.2
	cagney_tramp-20040309-branchpoint:1.71
	gdb_6_1-branch:1.70.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.70
	drow_intercu-20040221-branch:1.70.0.6
	drow_intercu-20040221-branchpoint:1.70
	cagney_bfdfile-20040213-branch:1.70.0.4
	cagney_bfdfile-20040213-branchpoint:1.70
	drow-cplus-merge-20040208:1.70
	carlton_dictionary-20040126-merge:1.70
	cagney_bigcore-20040122-branch:1.70.0.2
	cagney_bigcore-20040122-branchpoint:1.70
	drow-cplus-merge-20040113:1.68
	drow-cplus-merge-20031224:1.67
	drow-cplus-merge-20031220:1.67
	carlton_dictionary-20031215-merge:1.67
	drow-cplus-merge-20031214:1.67
	carlton-dictionary-20031111-merge:1.66
	gdb_6_0-2003-10-04-release:1.53
	kettenis_sparc-20030918-branch:1.53.0.8
	kettenis_sparc-20030918-branchpoint:1.53
	carlton_dictionary-20030917-merge:1.53
	ezannoni_pie-20030916-branchpoint:1.53
	ezannoni_pie-20030916-branch:1.53.0.6
	cagney_x86i386-20030821-branch:1.53.0.4
	cagney_x86i386-20030821-branchpoint:1.53
	carlton_dictionary-20030805-merge:1.53
	carlton_dictionary-20030627-merge:1.53
	gdb_6_0-branch:1.53.0.2
	gdb_6_0-2003-06-23-branchpoint:1.53
	jimb-ppc64-linux-20030613-branch:1.52.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.52
	cagney_convert-20030606-branch:1.52.0.10
	cagney_convert-20030606-branchpoint:1.52
	cagney_writestrings-20030508-branch:1.52.0.8
	cagney_writestrings-20030508-branchpoint:1.52
	jimb-ppc64-linux-20030528-branch:1.52.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.52
	carlton_dictionary-20030523-merge:1.52
	cagney_fileio-20030521-branch:1.52.0.4
	cagney_fileio-20030521-branchpoint:1.52
	kettenis_i386newframe-20030517-mergepoint:1.52
	jimb-ppc64-linux-20030509-branch:1.52.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.52
	kettenis_i386newframe-20030504-mergepoint:1.50
	carlton_dictionary-20030430-merge:1.50
	kettenis_i386newframe-20030419-branch:1.50.0.16
	kettenis_i386newframe-20030419-branchpoint:1.50
	carlton_dictionary-20030416-merge:1.50
	cagney_frameaddr-20030409-mergepoint:1.50
	kettenis_i386newframe-20030406-branch:1.50.0.14
	kettenis_i386newframe-20030406-branchpoint:1.50
	cagney_frameaddr-20030403-branchpoint:1.50
	cagney_frameaddr-20030403-branch:1.50.0.12
	cagney_framebase-20030330-mergepoint:1.50
	cagney_framebase-20030326-branch:1.50.0.10
	cagney_framebase-20030326-branchpoint:1.50
	cagney_lazyid-20030317-branch:1.50.0.8
	cagney_lazyid-20030317-branchpoint:1.50
	kettenis-i386newframe-20030316-mergepoint:1.50
	offbyone-20030313-branch:1.50.0.6
	offbyone-20030313-branchpoint:1.50
	kettenis-i386newframe-20030308-branch:1.50.0.4
	kettenis-i386newframe-20030308-branchpoint:1.50
	carlton_dictionary-20030305-merge:1.50
	cagney_offbyone-20030303-branch:1.50.0.2
	cagney_offbyone-20030303-branchpoint:1.50
	carlton_dictionary-20030207-merge:1.49
	interps-20030203-mergepoint:1.49
	interps-20030202-branch:1.49.0.2
	interps-20030202-branchpoint:1.49
	cagney-unwind-20030108-branch:1.48.0.2
	cagney-unwind-20030108-branchpoint:1.48
	carlton_dictionary-20021223-merge:1.48
	gdb_5_3-2002-12-12-release:1.40
	carlton_dictionary-20021115-merge:1.42
	kseitz_interps-20021105-merge:1.41
	kseitz_interps-20021103-merge:1.41
	drow-cplus-merge-20021020:1.40
	drow-cplus-merge-20021025:1.40
	carlton_dictionary-20021025-merge:1.40
	carlton_dictionary-20021011-merge:1.40
	drow-cplus-branch:1.40.0.6
	drow-cplus-branchpoint:1.40
	kseitz_interps-20020930-merge:1.40
	carlton_dictionary-20020927-merge:1.40
	carlton_dictionary-branch:1.40.0.4
	carlton_dictionary-20020920-branchpoint:1.40
	gdb_5_3-branch:1.40.0.2
	gdb_5_3-2002-09-04-branchpoint:1.40
	kseitz_interps-20020829-merge:1.40
	cagney_sysregs-20020825-branch:1.39.0.4
	cagney_sysregs-20020825-branchpoint:1.39
	readline_4_3-import-branch:1.39.0.2
	readline_4_3-import-branchpoint:1.39
	gdb_5_2_1-2002-07-23-release:1.33
	kseitz_interps-20020528-branch:1.35.0.6
	kseitz_interps-20020528-branchpoint:1.35
	cagney_regbuf-20020515-branch:1.35.0.4
	cagney_regbuf-20020515-branchpoint:1.35
	jimb-macro-020506-branch:1.35.0.2
	jimb-macro-020506-branchpoint:1.35
	gdb_5_2-2002-04-29-release:1.33
	gdb_5_2-branch:1.33.0.2
	gdb_5_2-2002-03-03-branchpoint:1.33
	gdb_5_1_1-2002-01-24-release:1.28
	gdb_5_1_0_1-2002-01-03-release:1.28
	cygnus_cvs_20020108_pre:1.29
	gdb_5_1_0_1-2002-01-03-branchpoint:1.28
	gdb_5_1_0_1-2002-01-03-branch:1.28.0.6
	gdb_5_1-2001-11-21-release:1.28
	gdb_s390-2001-09-26-branch:1.28.0.4
	gdb_s390-2001-09-26-branchpoint:1.28
	gdb_5_1-2001-07-29-branch:1.28.0.2
	gdb_5_1-2001-07-29-branchpoint:1.28
	dberlin-typesystem-branch:1.27.0.2
	dberlin-typesystem-branchpoint:1.27
	gdb-post-ptid_t-2001-05-03:1.26
	gdb-pre-ptid_t-2001-05-03:1.25
	insight-precleanup-2001-01-01:1.17
	gdb-post-protoization-2000-07-29:1.10
	gdb-pre-protoization-2000-07-29:1.9
	gdb-premipsmulti-2000-06-06-branch:1.9.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.9
	gdb-post-params-removal-2000-06-04:1.9
	gdb-pre-params-removal-2000-06-04:1.8
	gdb-post-params-removal-2000-05-28:1.8
	gdb-pre-params-removal-2000-05-28:1.7
	gdb_5_0-2000-05-19-release:1.5.2.1
	gdb_4_18_2-2000-05-18-release:1.5.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.5.2.1
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	repo-unification-2000-02-06:1.1.1.20
	insight-2000-02-04:1.1.1.20
	gdb-2000-02-04:1.1.1.20
	gdb-2000-02-02:1.1.1.20
	gdb-2000-02-01:1.1.1.20
	gdb-2000-01-31:1.1.1.19
	gdb-2000-01-26:1.1.1.19
	gdb-2000-01-24:1.1.1.19
	gdb-2000-01-17:1.1.1.19
	gdb-2000-01-10:1.1.1.19
	gdb-2000-01-05:1.1.1.18
	gdb-1999-12-21:1.1.1.18
	gdb-1999-12-13:1.1.1.17
	gdb-1999-12-07:1.1.1.17
	gdb-1999-12-06:1.1.1.17
	gdb-1999-11-16:1.1.1.16
	gdb-1999-11-08:1.1.1.16
	gdb-1999-11-01:1.1.1.15
	gdb-1999-10-25:1.1.1.15
	gdb-1999-10-18:1.1.1.15
	gdb-1999-10-11:1.1.1.14
	gdb-1999-10-04:1.1.1.14
	gdb-1999-09-28:1.1.1.13
	gdb-1999-09-21:1.1.1.12
	gdb-1999-09-13:1.1.1.12
	gdb-1999-09-08:1.1.1.12
	gdb-1999-08-30:1.1.1.11
	gdb-1999-08-23:1.1.1.10
	gdb-1999-08-16:1.1.1.10
	gdb-1999-08-09:1.1.1.10
	gdb-1999-08-02:1.1.1.9
	gdb-1999-07-26:1.1.1.9
	gdb-1999-07-19:1.1.1.9
	gdb-1999-07-12:1.1.1.8
	gdb-post-reformat-19990707:1.1.1.8
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.8
	gdb-pre-reformat-19990707:1.1.1.7
	gdb-1999-07-07:1.1.1.7
	gdb-1999-07-05:1.1.1.6
	gdb-1999-06-28:1.1.1.5
	gdb-1999-06-21:1.1.1.5
	gdb-1999-06-14:1.1.1.5
	gdb-1999-06-07:1.1.1.5
	gdb-1999-06-01:1.1.1.5
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.5
	gdb-1999-05-19:1.1.1.4
	gdb-1999-05-10:1.1.1.4
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.351
date	2013.10.16.02.41.42;	author sergiodj;	state Exp;
branches;
next	1.350;

1.350
date	2013.10.09.17.00.00;	author palves;	state Exp;
branches;
next	1.349;

1.349
date	2013.09.30.11.50.12;	author luisgpm;	state Exp;
branches;
next	1.348;

1.348
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.347;

1.347
date	2013.09.03.17.22.45;	author luisgpm;	state Exp;
branches;
next	1.346;

1.346
date	2013.08.23.14.03.25;	author palves;	state Exp;
branches;
next	1.345;

1.345
date	2013.08.22.10.00.05;	author palves;	state Exp;
branches;
next	1.344;

1.344
date	2013.07.29.21.27.46;	author devans;	state Exp;
branches;
next	1.343;

1.343
date	2013.07.25.14.34.50;	author tromey;	state Exp;
branches;
next	1.342;

1.342
date	2013.07.25.14.28.15;	author tromey;	state Exp;
branches;
next	1.341;

1.341
date	2013.07.24.16.20.12;	author luisgpm;	state Exp;
branches;
next	1.340;

1.340
date	2013.07.18.23.09.49;	author qiyao;	state Exp;
branches;
next	1.339;

1.339
date	2013.07.16.20.41.55;	author devans;	state Exp;
branches;
next	1.338;

1.338
date	2013.06.27.19.52.41;	author tromey;	state Exp;
branches;
next	1.337;

1.337
date	2013.06.27.19.38.24;	author tromey;	state Exp;
branches;
next	1.336;

1.336
date	2013.06.04.13.10.53;	author gary;	state Exp;
branches;
next	1.335;

1.335
date	2013.05.14.20.33.36;	author tromey;	state Exp;
branches;
next	1.334;

1.334
date	2013.05.14.20.32.15;	author tromey;	state Exp;
branches;
next	1.333;

1.333
date	2013.05.14.20.30.48;	author tromey;	state Exp;
branches;
next	1.332;

1.332
date	2013.04.07.10.23.34;	author qiyao;	state Exp;
branches;
next	1.331;

1.331
date	2013.03.29.15.21.23;	author qiyao;	state Exp;
branches;
next	1.330;

1.330
date	2013.03.20.15.46.24;	author jkratoch;	state Exp;
branches;
next	1.329;

1.329
date	2013.03.11.12.22.20;	author palves;	state Exp;
branches;
next	1.328;

1.328
date	2013.03.11.08.50.05;	author mmetzger;	state Exp;
branches;
next	1.327;

1.327
date	2013.03.11.08.48.38;	author mmetzger;	state Exp;
branches;
next	1.326;

1.326
date	2013.03.11.08.47.10;	author mmetzger;	state Exp;
branches;
next	1.325;

1.325
date	2013.03.11.08.42.55;	author mmetzger;	state Exp;
branches;
next	1.324;

1.324
date	2013.03.11.08.39.38;	author mmetzger;	state Exp;
branches;
next	1.323;

1.323
date	2013.03.11.08.17.07;	author mmetzger;	state Exp;
branches;
next	1.322;

1.322
date	2013.03.08.15.06.34;	author abidh;	state Exp;
branches;
next	1.321;

1.321
date	2013.03.07.23.53.12;	author palves;	state Exp;
branches;
next	1.320;

1.320
date	2013.03.01.15.38.26;	author palves;	state Exp;
branches;
next	1.319;

1.319
date	2013.01.31.16.32.44;	author aristovski;	state Exp;
branches;
next	1.318;

1.318
date	2013.01.01.06.32.52;	author brobecke;	state Exp;
branches;
next	1.317;

1.317
date	2012.12.14.15.30.36;	author tromey;	state Exp;
branches;
next	1.316;

1.316
date	2012.11.09.19.58.01;	author tromey;	state Exp;
branches;
next	1.315;

1.315
date	2012.10.26.16.52.38;	author palves;	state Exp;
branches;
next	1.314;

1.314
date	2012.10.01.12.02.12;	author aburgess;	state Exp;
branches;
next	1.313;

1.313
date	2012.08.02.09.36.39;	author qiyao;	state Exp;
branches;
next	1.312;

1.312
date	2012.07.20.16.57.32;	author palves;	state Exp;
branches;
next	1.311;

1.311
date	2012.07.02.15.29.35;	author shebs;	state Exp;
branches;
next	1.310;

1.310
date	2012.06.05.21.22.31;	author jkratoch;	state Exp;
branches;
next	1.309;

1.309
date	2012.06.05.21.18.05;	author jkratoch;	state Exp;
branches;
next	1.308;

1.308
date	2012.06.01.16.37.59;	author jkratoch;	state Exp;
branches;
next	1.307;

1.307
date	2012.05.24.16.39.11;	author palves;	state Exp;
branches;
next	1.306;

1.306
date	2012.05.22.15.04.57;	author palves;	state Exp;
branches;
next	1.305;

1.305
date	2012.05.09.11.47.14;	author palves;	state Exp;
branches;
next	1.304;

1.304
date	2012.03.07.19.25.37;	author palves;	state Exp;
branches;
next	1.303;

1.303
date	2012.03.03.04.04.34;	author qiyao;	state Exp;
branches;
next	1.302;

1.302
date	2012.03.03.03.32.44;	author qiyao;	state Exp;
branches;
next	1.301;

1.301
date	2012.03.02.19.26.10;	author palves;	state Exp;
branches;
next	1.300;

1.300
date	2012.02.24.15.10.59;	author luisgpm;	state Exp;
branches;
next	1.299;

1.299
date	2012.01.23.13.35.22;	author uweigand;	state Exp;
branches;
next	1.298;

1.298
date	2012.01.20.09.49.01;	author uweigand;	state Exp;
branches;
next	1.297;

1.297
date	2012.01.20.09.47.32;	author uweigand;	state Exp;
branches;
next	1.296;

1.296
date	2012.01.20.09.45.50;	author uweigand;	state Exp;
branches;
next	1.295;

1.295
date	2012.01.19.16.32.59;	author palves;	state Exp;
branches;
next	1.294;

1.294
date	2012.01.04.08.17.13;	author brobecke;	state Exp;
branches;
next	1.293;

1.293
date	2011.12.06.20.03.12;	author palves;	state Exp;
branches
	1.293.2.1;
next	1.292;

1.292
date	2011.11.20.23.59.47;	author shebs;	state Exp;
branches;
next	1.291;

1.291
date	2011.11.14.20.07.20;	author shebs;	state Exp;
branches;
next	1.290;

1.290
date	2011.11.14.15.18.54;	author qiyao;	state Exp;
branches;
next	1.289;

1.289
date	2011.11.14.14.11.35;	author qiyao;	state Exp;
branches;
next	1.288;

1.288
date	2011.11.10.20.07.51;	author palves;	state Exp;
branches;
next	1.287;

1.287
date	2011.11.02.23.44.19;	author shebs;	state Exp;
branches;
next	1.286;

1.286
date	2011.10.07.12.06.46;	author uweigand;	state Exp;
branches;
next	1.285;

1.285
date	2011.06.06.12.47.07;	author palves;	state Exp;
branches;
next	1.284;

1.284
date	2011.05.26.18.11.33;	author palves;	state Exp;
branches;
next	1.283;

1.283
date	2011.05.12.12.09.16;	author kcy;	state Exp;
branches;
next	1.282;

1.282
date	2011.05.06.18.46.31;	author bauermann;	state Exp;
branches;
next	1.281;

1.281
date	2011.04.27.13.29.15;	author uweigand;	state Exp;
branches;
next	1.280;

1.280
date	2011.03.31.14.32.48;	author bauermann;	state Exp;
branches;
next	1.279;

1.279
date	2011.03.17.13.19.24;	author brobecke;	state Exp;
branches;
next	1.278;

1.278
date	2011.03.08.18.58.54;	author msnyder;	state Exp;
branches;
next	1.277;

1.277
date	2011.03.08.04.53.36;	author brobecke;	state Exp;
branches;
next	1.276;

1.276
date	2011.03.07.15.58.13;	author tromey;	state Exp;
branches;
next	1.275;

1.275
date	2011.02.15.17.22.21;	author palves;	state Exp;
branches;
next	1.274;

1.274
date	2011.02.14.11.22.29;	author palves;	state Exp;
branches;
next	1.273;

1.273
date	2011.02.14.11.13.11;	author palves;	state Exp;
branches;
next	1.272;

1.272
date	2011.01.28.16.00.16;	author palves;	state Exp;
branches;
next	1.271;

1.271
date	2011.01.19.17.21.36;	author tromey;	state Exp;
branches;
next	1.270;

1.270
date	2011.01.14.13.47.15;	author palves;	state Exp;
branches;
next	1.269;

1.269
date	2011.01.11.21.53.25;	author msnyder;	state Exp;
branches;
next	1.268;

1.268
date	2011.01.11.19.16.20;	author bauermann;	state Exp;
branches;
next	1.267;

1.267
date	2011.01.11.15.10.02;	author msnyder;	state Exp;
branches;
next	1.266;

1.266
date	2011.01.05.22.22.53;	author msnyder;	state Exp;
branches;
next	1.265;

1.265
date	2011.01.01.15.33.17;	author brobecke;	state Exp;
branches;
next	1.264;

1.264
date	2010.12.28.11.40.27;	author brobecke;	state Exp;
branches;
next	1.263;

1.263
date	2010.08.31.18.08.43;	author jkratoch;	state Exp;
branches;
next	1.262;

1.262
date	2010.08.13.13.22.42;	author vprus;	state Exp;
branches;
next	1.261;

1.261
date	2010.07.19.17.51.23;	author jkratoch;	state Exp;
branches;
next	1.260;

1.260
date	2010.07.16.20.04.41;	author sezero;	state Exp;
branches;
next	1.259;

1.259
date	2010.07.07.16.15.17;	author bauermann;	state Exp;
branches
	1.259.2.1;
next	1.258;

1.258
date	2010.07.01.10.36.09;	author palves;	state Exp;
branches;
next	1.257;

1.257
date	2010.06.12.00.05.21;	author shebs;	state Exp;
branches;
next	1.256;

1.256
date	2010.06.09.18.25.34;	author msnyder;	state Exp;
branches;
next	1.255;

1.255
date	2010.05.23.14.23.31;	author jkratoch;	state Exp;
branches;
next	1.254;

1.254
date	2010.05.17.10.40.06;	author palves;	state Exp;
branches;
next	1.253;

1.253
date	2010.05.17.05.30.59;	author brobecke;	state Exp;
branches;
next	1.252;

1.252
date	2010.05.17.03.20.57;	author teawater;	state Exp;
branches;
next	1.251;

1.251
date	2010.05.17.01.15.20;	author msnyder;	state Exp;
branches;
next	1.250;

1.250
date	2010.05.06.22.29.49;	author msnyder;	state Exp;
branches;
next	1.249;

1.249
date	2010.05.02.23.52.14;	author jkratoch;	state Exp;
branches;
next	1.248;

1.248
date	2010.04.29.16.33.15;	author palves;	state Exp;
branches;
next	1.247;

1.247
date	2010.04.19.22.06.17;	author shebs;	state Exp;
branches;
next	1.246;

1.246
date	2010.04.16.07.49.35;	author muller;	state Exp;
branches;
next	1.245;

1.245
date	2010.03.24.01.12.13;	author palves;	state Exp;
branches;
next	1.244;

1.244
date	2010.03.23.22.05.45;	author vprus;	state Exp;
branches;
next	1.243;

1.243
date	2010.03.18.21.23.33;	author shebs;	state Exp;
branches;
next	1.242;

1.242
date	2010.03.12.03.54.45;	author palves;	state Exp;
branches;
next	1.241;

1.241
date	2010.03.08.13.34.38;	author teawater;	state Exp;
branches;
next	1.240;

1.240
date	2010.02.24.20.49.50;	author palves;	state Exp;
branches;
next	1.239;

1.239
date	2010.01.19.09.39.11;	author brobecke;	state Exp;
branches
	1.239.2.1;
next	1.238;

1.238
date	2010.01.15.22.37.17;	author shebs;	state Exp;
branches;
next	1.237;

1.237
date	2010.01.12.21.40.24;	author vprus;	state Exp;
branches;
next	1.236;

1.236
date	2010.01.07.19.17.46;	author shebs;	state Exp;
branches;
next	1.235;

1.235
date	2010.01.01.07.31.42;	author brobecke;	state Exp;
branches;
next	1.234;

1.234
date	2009.11.28.17.00.55;	author vprus;	state Exp;
branches;
next	1.233;

1.233
date	2009.11.20.17.23.38;	author msnyder;	state Exp;
branches;
next	1.232;

1.232
date	2009.11.13.23.26.19;	author devans;	state Exp;
branches;
next	1.231;

1.231
date	2009.10.29.20.12.26;	author sandra;	state Exp;
branches;
next	1.230;

1.230
date	2009.10.26.18.28.13;	author teawater;	state Exp;
branches;
next	1.229;

1.229
date	2009.10.20.11.09.01;	author palves;	state Exp;
branches;
next	1.228;

1.228
date	2009.10.19.09.51.42;	author palves;	state Exp;
branches;
next	1.227;

1.227
date	2009.10.06.15.32.17;	author muller;	state Exp;
branches;
next	1.226;

1.226
date	2009.09.15.16.16.40;	author devans;	state Exp;
branches;
next	1.225;

1.225
date	2009.09.15.03.30.06;	author sergiodj;	state Exp;
branches;
next	1.224;

1.224
date	2009.09.14.20.49.11;	author devans;	state Exp;
branches;
next	1.223;

1.223
date	2009.09.08.23.52.45;	author devans;	state Exp;
branches;
next	1.222;

1.222
date	2009.08.31.20.18.45;	author devans;	state Exp;
branches;
next	1.221;

1.221
date	2009.08.20.22.30.12;	author devans;	state Exp;
branches;
next	1.220;

1.220
date	2009.08.14.14.28.14;	author palves;	state Exp;
branches;
next	1.219;

1.219
date	2009.07.31.15.28.27;	author uweigand;	state Exp;
branches;
next	1.218;

1.218
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches
	1.218.2.1;
next	1.217;

1.217
date	2009.07.02.17.21.07;	author uweigand;	state Exp;
branches;
next	1.216;

1.216
date	2009.07.02.17.12.27;	author uweigand;	state Exp;
branches;
next	1.215;

1.215
date	2009.07.02.17.06.44;	author uweigand;	state Exp;
branches;
next	1.214;

1.214
date	2009.06.28.00.20.22;	author drow;	state Exp;
branches;
next	1.213;

1.213
date	2009.06.07.16.46.48;	author palves;	state Exp;
branches;
next	1.212;

1.212
date	2009.06.03.18.50.36;	author palves;	state Exp;
branches;
next	1.211;

1.211
date	2009.05.22.23.49.14;	author palves;	state Exp;
branches;
next	1.210;

1.210
date	2009.05.21.16.00.14;	author palves;	state Exp;
branches;
next	1.209;

1.209
date	2009.05.21.15.48.41;	author palves;	state Exp;
branches;
next	1.208;

1.208
date	2009.05.19.00.23.49;	author palves;	state Exp;
branches;
next	1.207;

1.207
date	2009.05.11.11.13.09;	author muller;	state Exp;
branches;
next	1.206;

1.206
date	2009.04.14.16.48.07;	author brobecke;	state Exp;
branches;
next	1.205;

1.205
date	2009.03.17.19.28.09;	author brobecke;	state Exp;
branches;
next	1.204;

1.204
date	2009.02.25.02.14.22;	author teawater;	state Exp;
branches;
next	1.203;

1.203
date	2009.02.23.00.03.50;	author palves;	state Exp;
branches;
next	1.202;

1.202
date	2009.02.21.16.14.49;	author palves;	state Exp;
branches;
next	1.201;

1.201
date	2009.02.06.22.21.26;	author palves;	state Exp;
branches;
next	1.200;

1.200
date	2009.02.06.02.08.48;	author palves;	state Exp;
branches;
next	1.199;

1.199
date	2009.02.06.01.23.00;	author palves;	state Exp;
branches;
next	1.198;

1.198
date	2009.02.06.00.27.58;	author palves;	state Exp;
branches;
next	1.197;

1.197
date	2009.02.05.23.30.33;	author palves;	state Exp;
branches;
next	1.196;

1.196
date	2009.02.01.23.31.03;	author devans;	state Exp;
branches;
next	1.195;

1.195
date	2009.01.11.13.23.42;	author brobecke;	state Exp;
branches;
next	1.194;

1.194
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.193;

1.193
date	2008.12.16.11.15.58;	author gingold;	state Exp;
branches
	1.193.2.1;
next	1.192;

1.192
date	2008.12.02.07.57.36;	author vprus;	state Exp;
branches;
next	1.191;

1.191
date	2008.11.09.11.27.18;	author vprus;	state Exp;
branches
	1.191.2.1;
next	1.190;

1.190
date	2008.11.03.14.01.27;	author palves;	state Exp;
branches;
next	1.189;

1.189
date	2008.10.27.12.43.24;	author palves;	state Exp;
branches;
next	1.188;

1.188
date	2008.10.22.19.45.05;	author brobecke;	state Exp;
branches;
next	1.187;

1.187
date	2008.10.17.19.43.47;	author msnyder;	state Exp;
branches;
next	1.186;

1.186
date	2008.10.14.20.49.02;	author palves;	state Exp;
branches;
next	1.185;

1.185
date	2008.10.09.03.24.51;	author palves;	state Exp;
branches;
next	1.184;

1.184
date	2008.09.22.15.21.30;	author palves;	state Exp;
branches
	1.184.2.1;
next	1.183;

1.183
date	2008.09.22.15.16.51;	author palves;	state Exp;
branches;
next	1.182;

1.182
date	2008.09.11.14.29.21;	author uweigand;	state Exp;
branches;
next	1.181;

1.181
date	2008.09.05.12.57.16;	author uweigand;	state Exp;
branches;
next	1.180;

1.180
date	2008.09.05.11.50.57;	author uweigand;	state Exp;
branches;
next	1.179;

1.179
date	2008.09.05.11.37.17;	author uweigand;	state Exp;
branches;
next	1.178;

1.178
date	2008.09.04.22.49.30;	author devans;	state Exp;
branches;
next	1.177;

1.177
date	2008.08.26.17.21.29;	author uweigand;	state Exp;
branches;
next	1.176;

1.176
date	2008.08.26.12.42.00;	author uweigand;	state Exp;
branches;
next	1.175;

1.175
date	2008.08.19.13.22.14;	author vprus;	state Exp;
branches;
next	1.174;

1.174
date	2008.08.19.13.05.02;	author vprus;	state Exp;
branches;
next	1.173;

1.173
date	2008.08.19.12.49.19;	author vprus;	state Exp;
branches;
next	1.172;

1.172
date	2008.08.18.23.12.40;	author palves;	state Exp;
branches;
next	1.171;

1.171
date	2008.08.16.22.12.18;	author palves;	state Exp;
branches;
next	1.170;

1.170
date	2008.08.09.12.15.10;	author uweigand;	state Exp;
branches;
next	1.169;

1.169
date	2008.07.09.22.42.42;	author palves;	state Exp;
branches
	1.169.2.1;
next	1.168;

1.168
date	2008.07.09.22.16.14;	author palves;	state Exp;
branches;
next	1.167;

1.167
date	2008.07.03.17.38.08;	author palves;	state Exp;
branches;
next	1.166;

1.166
date	2008.06.26.15.51.28;	author drow;	state Exp;
branches;
next	1.165;

1.165
date	2008.06.26.15.10.48;	author vprus;	state Exp;
branches;
next	1.164;

1.164
date	2008.06.10.10.23.53;	author vprus;	state Exp;
branches;
next	1.163;

1.163
date	2008.05.09.17.37.36;	author devans;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2008.05.09.17.02.01;	author devans;	state Exp;
branches;
next	1.161;

1.161
date	2008.05.02.11.07.25;	author schwab;	state Exp;
branches;
next	1.160;

1.160
date	2008.04.24.10.21.44;	author vprus;	state Exp;
branches;
next	1.159;

1.159
date	2008.03.28.16.37.08;	author palves;	state Exp;
branches;
next	1.158;

1.158
date	2008.03.21.17.09.35;	author palves;	state Exp;
branches;
next	1.157;

1.157
date	2008.03.15.14.55.21;	author vprus;	state Exp;
branches;
next	1.156;

1.156
date	2008.03.13.12.22.13;	author drow;	state Exp;
branches;
next	1.155;

1.155
date	2008.02.28.16.26.17;	author drow;	state Exp;
branches;
next	1.154;

1.154
date	2008.01.25.00.09.49;	author msnyder;	state Exp;
branches
	1.154.6.1;
next	1.153;

1.153
date	2008.01.11.00.12.43;	author devans;	state Exp;
branches;
next	1.152;

1.152
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.151;

1.151
date	2007.12.13.02.00.07;	author jimb;	state Exp;
branches;
next	1.150;

1.150
date	2007.12.07.15.02.12;	author macro;	state Exp;
branches;
next	1.149;

1.149
date	2007.10.22.14.03.37;	author uweigand;	state Exp;
branches;
next	1.148;

1.148
date	2007.10.10.13.28.43;	author drow;	state Exp;
branches;
next	1.147;

1.147
date	2007.08.23.18.08.45;	author brobecke;	state Exp;
branches;
next	1.146;

1.146
date	2007.08.08.22.02.43;	author msnyder;	state Exp;
branches;
next	1.145;

1.145
date	2007.07.24.12.49.24;	author uweigand;	state Exp;
branches;
next	1.144;

1.144
date	2007.07.01.22.35.55;	author drow;	state Exp;
branches;
next	1.143;

1.143
date	2007.06.09.13.42.16;	author uweigand;	state Exp;
branches;
next	1.142;

1.142
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.141;

1.141
date	2007.05.06.18.55.41;	author uweigand;	state Exp;
branches;
next	1.140;

1.140
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.139;

1.139
date	2007.04.29.01.51.51;	author uweigand;	state Exp;
branches;
next	1.138;

1.138
date	2007.04.27.13.26.05;	author uweigand;	state Exp;
branches;
next	1.137;

1.137
date	2007.03.30.12.57.43;	author drow;	state Exp;
branches
	1.137.2.1;
next	1.136;

1.136
date	2007.03.28.18.56.07;	author uweigand;	state Exp;
branches;
next	1.135;

1.135
date	2007.02.08.16.31.57;	author drow;	state Exp;
branches;
next	1.134;

1.134
date	2007.01.29.16.36.01;	author brobecke;	state Exp;
branches;
next	1.133;

1.133
date	2007.01.23.13.03.20;	author drow;	state Exp;
branches;
next	1.132;

1.132
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.131;

1.131
date	2006.12.05.20.38.13;	author drow;	state Exp;
branches;
next	1.130;

1.130
date	2006.11.28.22.10.26;	author drow;	state Exp;
branches;
next	1.129;

1.129
date	2006.11.21.16.50.16;	author vprus;	state Exp;
branches;
next	1.128;

1.128
date	2006.10.17.21.55.23;	author drow;	state Exp;
branches;
next	1.127;

1.127
date	2006.10.10.03.17.53;	author drow;	state Exp;
branches;
next	1.126;

1.126
date	2006.09.21.14.00.53;	author drow;	state Exp;
branches;
next	1.125;

1.125
date	2006.09.21.13.54.03;	author drow;	state Exp;
branches;
next	1.124;

1.124
date	2006.08.16.18.31.03;	author drow;	state Exp;
branches;
next	1.123;

1.123
date	2006.08.15.18.46.25;	author drow;	state Exp;
branches;
next	1.122;

1.122
date	2006.07.27.21.23.42;	author drow;	state Exp;
branches;
next	1.121;

1.121
date	2006.07.18.12.44.48;	author vprus;	state Exp;
branches;
next	1.120;

1.120
date	2006.07.12.18.13.45;	author drow;	state Exp;
branches;
next	1.119;

1.119
date	2006.05.05.20.08.45;	author drow;	state Exp;
branches
	1.119.2.1;
next	1.118;

1.118
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches
	1.118.4.1;
next	1.117;

1.117
date	2006.03.17.00.30.34;	author msnyder;	state Exp;
branches
	1.117.2.1;
next	1.116;

1.116
date	2006.02.08.06.43.00;	author woodzltc;	state Exp;
branches
	1.116.2.1
	1.116.4.1;
next	1.115;

1.115
date	2006.02.08.05.41.06;	author woodzltc;	state Exp;
branches;
next	1.114;

1.114
date	2006.01.10.22.38.51;	author kettenis;	state Exp;
branches;
next	1.113;

1.113
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches;
next	1.112;

1.112
date	2005.12.07.19.35.43;	author jimb;	state Exp;
branches;
next	1.111;

1.111
date	2005.09.04.16.18.20;	author drow;	state Exp;
branches;
next	1.110;

1.110
date	2005.07.18.21.00.49;	author kettenis;	state Exp;
branches;
next	1.109;

1.109
date	2005.05.28.16.44.29;	author drow;	state Exp;
branches
	1.109.2.1;
next	1.108;

1.108
date	2005.05.16.16.36.24;	author kettenis;	state Exp;
branches;
next	1.107;

1.107
date	2005.05.16.04.45.43;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2005.05.09.21.20.35;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2005.05.08.14.46.52;	author kettenis;	state Exp;
branches;
next	1.104;

1.104
date	2005.05.01.19.58.55;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2005.03.13.22.06.10;	author kettenis;	state Exp;
branches;
next	1.102;

1.102
date	2005.03.04.17.47.59;	author drow;	state Exp;
branches;
next	1.101;

1.101
date	2005.02.24.13.51.35;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2005.02.18.18.58.56;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2005.02.17.13.49.55;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2005.02.15.15.49.22;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2005.02.14.16.18.43;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2005.02.12.00.39.21;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2005.02.11.18.13.54;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2005.02.11.04.06.06;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2005.02.10.17.32.50;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2005.01.27.20.09.10;	author cagney;	state Exp;
branches;
next	1.91;

1.91
date	2005.01.18.17.04.28;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2004.10.08.20.29.55;	author cagney;	state Exp;
branches;
next	1.89;

1.89
date	2004.10.08.19.51.16;	author cagney;	state Exp;
branches;
next	1.88;

1.88
date	2004.10.08.17.30.47;	author jjohnstn;	state Exp;
branches;
next	1.87;

1.87
date	2004.10.05.21.53.33;	author cagney;	state Exp;
branches;
next	1.86;

1.86
date	2004.10.01.16.12.26;	author cagney;	state Exp;
branches;
next	1.85;

1.85
date	2004.09.30.20.36.27;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2004.09.30.16.18.57;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2004.09.30.14.16.20;	author cagney;	state Exp;
branches;
next	1.82;

1.82
date	2004.09.29.15.33.02;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2004.09.29.13.54.32;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2004.09.12.15.20.47;	author cagney;	state Exp;
branches;
next	1.79;

1.79
date	2004.08.27.18.03.32;	author nathanw;	state Exp;
branches;
next	1.78;

1.78
date	2004.08.03.00.57.26;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2004.07.28.17.26.27;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2004.07.26.14.53.05;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2004.06.09.20.09.42;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2004.05.25.14.58.31;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2004.05.08.22.26.09;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2004.04.21.23.52.21;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2004.03.09.16.16.52;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.19.16.49.35;	author kevinb;	state Exp;
branches
	1.70.6.1;
next	1.69;

1.69
date	2004.01.19.01.20.11;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.05.22.32.23;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.11.23.20.41.17;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2003.11.10.21.20.44;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2003.11.06.19.56.26;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2003.10.31.15.25.34;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2003.10.24.20.24.06;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2003.10.23.00.13.53;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2003.10.22.21.39.09;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2003.10.21.21.29.55;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2003.10.17.20.17.51;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2003.10.17.18.24.49;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2003.10.17.16.09.20;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2003.10.17.13.59.27;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2003.09.21.01.26.45;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.17.20.28.13;	author drow;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.08.20.52.48;	author cagney;	state Exp;
branches
	1.52.8.1;
next	1.51;

1.51
date	2003.05.05.17.56.56;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2003.02.24.21.56.50;	author kewarken;	state Exp;
branches
	1.50.16.1;
next	1.49;

1.49
date	2003.01.19.04.06.46;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2002.12.15.19.00.33;	author drow;	state Exp;
branches;
next	1.47;

1.47
date	2002.12.12.01.39.34;	author drow;	state Exp;
branches;
next	1.46;

1.46
date	2002.12.11.02.04.44;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2002.11.16.19.23.52;	author drow;	state Exp;
branches;
next	1.44;

1.44
date	2002.11.16.19.22.58;	author drow;	state Exp;
branches;
next	1.43;

1.43
date	2002.11.16.19.21.44;	author drow;	state Exp;
branches;
next	1.42;

1.42
date	2002.11.12.02.39.40;	author ezannoni;	state Exp;
branches;
next	1.41;

1.41
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2002.08.26.19.18.33;	author ciceron;	state Exp;
branches
	1.40.4.1
	1.40.6.1;
next	1.39;

1.39
date	2002.08.01.21.20.14;	author graces;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.11.13.50.49;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.25.05.39.17;	author tromey;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.15.21.07.58;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.04.14.19.21;	author cagney;	state Exp;
branches
	1.35.4.1
	1.35.6.1;
next	1.34;

1.34
date	2002.04.26.22.11.52;	author bje;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.01.01.01.21;	author msnyder;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.01.00.49.53;	author msnyder;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.31.02.31.06;	author msnyder;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.09.00.36.58;	author msnyder;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.05.22.32.57;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.19.18.09.11;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.28.04.31.36;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.04.04.15.27;	author kevinb;	state Exp;
branches;
next	1.25;

1.25
date	2001.04.26.22.10.42;	author msnyder;	state Exp;
branches;
next	1.24;

1.24
date	2001.04.14.19.23.02;	author jtc;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.07.02.57.08;	author jtc;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.26.02.30.15;	author jtc;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.23.22.48.56;	author jtc;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.15.01.01.50;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.21.10.26.07;	author schauer;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.10.18.34.21;	author jtc;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.03.22.00.56;	author jtc;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.27.15.02.42;	author davea;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.25.14.16.25;	author fnasser;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.28.07.48.14;	author schauer;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.28.01.12.30;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.20.10.29.51;	author jtc;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.28.03.10.43;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.28.02.25.14;	author dberlin;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.03.15.16.55.07;	author jimb;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.16.22.24.50;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.47;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.293.2.1
date	2012.01.06.04.43.31;	author brobecke;	state Exp;
branches;
next	;

1.259.2.1
date	2010.07.21.20.01.09;	author sezero;	state Exp;
branches;
next	;

1.239.2.1
date	2010.03.12.03.56.30;	author palves;	state Exp;
branches;
next	;

1.218.2.1
date	2009.07.26.01.29.41;	author msnyder;	state Exp;
branches;
next	;

1.193.2.1
date	2008.12.26.21.09.13;	author msnyder;	state Exp;
branches;
next	;

1.191.2.1
date	2008.11.21.02.31.58;	author shebs;	state Exp;
branches;
next	;

1.184.2.1
date	2008.09.30.23.36.43;	author msnyder;	state Exp;
branches;
next	1.184.2.2;

1.184.2.2
date	2008.10.01.03.16.05;	author msnyder;	state Exp;
branches;
next	1.184.2.3;

1.184.2.3
date	2008.10.04.18.56.36;	author msnyder;	state Exp;
branches;
next	1.184.2.4;

1.184.2.4
date	2008.10.06.18.00.47;	author msnyder;	state Exp;
branches;
next	1.184.2.5;

1.184.2.5
date	2008.10.08.00.26.28;	author msnyder;	state Exp;
branches;
next	1.184.2.6;

1.184.2.6
date	2008.10.18.13.45.18;	author teawater;	state Exp;
branches;
next	;

1.169.2.1
date	2008.07.18.04.23.49;	author msnyder;	state Exp;
branches;
next	1.169.2.2;

1.169.2.2
date	2008.07.24.08.58.37;	author teawater;	state Exp;
branches;
next	1.169.2.3;

1.169.2.3
date	2008.08.15.06.47.49;	author teawater;	state Exp;
branches;
next	1.169.2.4;

1.169.2.4
date	2008.10.06.01.13.38;	author msnyder;	state Exp;
branches;
next	1.169.2.5;

1.169.2.5
date	2008.10.06.17.52.18;	author msnyder;	state Exp;
branches;
next	1.169.2.6;

1.169.2.6
date	2008.10.08.00.26.50;	author msnyder;	state Exp;
branches;
next	;

1.163.2.1
date	2008.06.10.02.11.17;	author msnyder;	state Exp;
branches;
next	;

1.154.6.1
date	2009.09.11.04.45.46;	author amylaar;	state Exp;
branches;
next	;

1.137.2.1
date	2008.06.10.00.13.15;	author msnyder;	state Exp;
branches;
next	;

1.119.2.1
date	2006.05.12.07.40.20;	author nickrob;	state Exp;
branches;
next	1.119.2.2;

1.119.2.2
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.118.4.1
date	2006.05.03.00.27.27;	author msnyder;	state Exp;
branches;
next	;

1.117.2.1
date	2006.03.31.20.35.47;	author msnyder;	state Exp;
branches;
next	;

1.116.2.1
date	2006.04.03.00.47.40;	author drow;	state Exp;
branches
	1.116.2.1.2.1;
next	;

1.116.2.1.2.1
date	2006.04.11.21.58.24;	author drow;	state Exp;
branches;
next	1.116.2.1.2.2;

1.116.2.1.2.2
date	2006.04.12.14.48.21;	author drow;	state Exp;
branches;
next	1.116.2.1.2.3;

1.116.2.1.2.3
date	2006.04.12.14.52.04;	author drow;	state Exp;
branches;
next	1.116.2.1.2.4;

1.116.2.1.2.4
date	2006.04.12.18.11.40;	author drow;	state Exp;
branches;
next	;

1.116.4.1
date	2006.03.03.20.46.37;	author drow;	state Exp;
branches;
next	1.116.4.2;

1.116.4.2
date	2006.03.31.18.17.29;	author drow;	state Exp;
branches;
next	;

1.109.2.1
date	2005.06.03.14.42.06;	author msnyder;	state Exp;
branches;
next	1.109.2.2;

1.109.2.2
date	2005.06.04.02.18.29;	author msnyder;	state Exp;
branches;
next	;

1.70.6.1
date	2004.03.27.17.37.54;	author drow;	state Exp;
branches;
next	1.70.6.2;

1.70.6.2
date	2004.09.16.17.01.24;	author drow;	state Exp;
branches;
next	;

1.52.8.1
date	2003.06.03.20.54.40;	author cagney;	state Exp;
branches;
next	;

1.50.16.1
date	2003.05.18.09.44.25;	author kettenis;	state Exp;
branches;
next	;

1.40.4.1
date	2002.11.15.19.18.59;	author carlton;	state Exp;
branches;
next	1.40.4.2;

1.40.4.2
date	2002.12.23.19.38.46;	author carlton;	state Exp;
branches;
next	1.40.4.3;

1.40.4.3
date	2003.02.07.19.17.53;	author carlton;	state Exp;
branches;
next	1.40.4.4;

1.40.4.4
date	2003.03.06.00.56.32;	author carlton;	state Exp;
branches;
next	1.40.4.5;

1.40.4.5
date	2003.05.23.18.40.46;	author carlton;	state Exp;
branches;
next	1.40.4.6;

1.40.4.6
date	2003.06.27.21.50.12;	author carlton;	state Exp;
branches;
next	1.40.4.7;

1.40.4.7
date	2003.11.11.23.50.58;	author carlton;	state Exp;
branches;
next	1.40.4.8;

1.40.4.8
date	2003.12.16.00.00.51;	author carlton;	state Exp;
branches;
next	1.40.4.9;

1.40.4.9
date	2004.01.26.19.11.33;	author carlton;	state Exp;
branches;
next	;

1.40.6.1
date	2003.12.14.20.27.33;	author drow;	state Exp;
branches;
next	1.40.6.2;

1.40.6.2
date	2004.01.13.16.12.01;	author drow;	state Exp;
branches;
next	1.40.6.3;

1.40.6.3
date	2004.02.09.19.43.48;	author drow;	state Exp;
branches;
next	;

1.35.4.1
date	2002.06.21.16.19.32;	author cagney;	state Exp;
branches;
next	1.35.4.2;

1.35.4.2
date	2002.06.25.20.02.42;	author cagney;	state Exp;
branches;
next	;

1.35.6.1
date	2002.06.20.01.33.13;	author kseitz;	state Exp;
branches;
next	1.35.6.2;

1.35.6.2
date	2002.07.22.21.47.03;	author kseitz;	state Exp;
branches;
next	1.35.6.3;

1.35.6.3
date	2002.08.09.18.34.27;	author kseitz;	state Exp;
branches;
next	1.35.6.4;

1.35.6.4
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	1.35.6.5;

1.35.6.5
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.5.2.1
date	2000.04.28.03.10.12;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.35;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.43.02;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.05.11.13.29.31;	author shebs;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.05.25.18.03.34;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.07.05.17.54.07;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.07.07.17.23.26;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.07.07.20.10.37;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.07.19.23.28.13;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.08.09.21.33.58;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.08.31.01.06.10;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.09.08.23.59.36;	author shebs;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.09.28.21.52.35;	author jsm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.10.05.23.08.57;	author jsm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.10.19.02.46.40;	author jsm;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	99.11.09.01.23.08;	author jsm;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	99.12.07.03.56.06;	author jsm;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	99.12.22.21.45.10;	author jsm;	state Exp;
branches;
next	1.1.1.19;

1.1.1.19
date	2000.01.11.03.07.25;	author jsm;	state Exp;
branches;
next	1.1.1.20;

1.1.1.20
date	2000.02.02.00.21.11;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.351
log
@This is a simple bug.  target_disable_btrace and target_teardown_btrace,
both from gdb/target.c, do a "return" calling another function.  But both
are marked as void.  Despite the fact that the functions being called are
void as well, this is wrong.  This patch fixes this by calling the functions
and then returning in the next line.

2013-10-16  Sergio Durigan Junior  <sergiodj@@redhat.com>

	PR gdb/16042
	* target.c (target_disable_btrace): Fix invalid return value for
	void function.
	(target_teardown_btrace): Likewise.
@
text
@/* Select target systems and architectures at runtime for GDB.

   Copyright (C) 1990-2013 Free Software Foundation, Inc.

   Contributed by Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include <errno.h>
#include "gdb_string.h"
#include "target.h"
#include "gdbcmd.h"
#include "symtab.h"
#include "inferior.h"
#include "bfd.h"
#include "symfile.h"
#include "objfiles.h"
#include "dcache.h"
#include <signal.h>
#include "regcache.h"
#include "gdb_assert.h"
#include "gdbcore.h"
#include "exceptions.h"
#include "target-descriptions.h"
#include "gdbthread.h"
#include "solib.h"
#include "exec.h"
#include "inline-frame.h"
#include "tracepoint.h"
#include "gdb/fileio.h"
#include "agent.h"

static void target_info (char *, int);

static void default_terminal_info (const char *, int);

static int default_watchpoint_addr_within_range (struct target_ops *,
						 CORE_ADDR, CORE_ADDR, int);

static int default_region_ok_for_hw_watchpoint (CORE_ADDR, int);

static void tcomplain (void) ATTRIBUTE_NORETURN;

static int nomemory (CORE_ADDR, char *, int, int, struct target_ops *);

static int return_zero (void);

static int return_one (void);

static int return_minus_one (void);

void target_ignore (void);

static void target_command (char *, int);

static struct target_ops *find_default_run_target (char *);

static LONGEST default_xfer_partial (struct target_ops *ops,
				     enum target_object object,
				     const char *annex, gdb_byte *readbuf,
				     const gdb_byte *writebuf,
				     ULONGEST offset, LONGEST len);

static LONGEST current_xfer_partial (struct target_ops *ops,
				     enum target_object object,
				     const char *annex, gdb_byte *readbuf,
				     const gdb_byte *writebuf,
				     ULONGEST offset, LONGEST len);

static struct gdbarch *default_thread_architecture (struct target_ops *ops,
						    ptid_t ptid);

static void init_dummy_target (void);

static struct target_ops debug_target;

static void debug_to_open (char *, int);

static void debug_to_prepare_to_store (struct regcache *);

static void debug_to_files_info (struct target_ops *);

static int debug_to_insert_breakpoint (struct gdbarch *,
				       struct bp_target_info *);

static int debug_to_remove_breakpoint (struct gdbarch *,
				       struct bp_target_info *);

static int debug_to_can_use_hw_breakpoint (int, int, int);

static int debug_to_insert_hw_breakpoint (struct gdbarch *,
					  struct bp_target_info *);

static int debug_to_remove_hw_breakpoint (struct gdbarch *,
					  struct bp_target_info *);

static int debug_to_insert_watchpoint (CORE_ADDR, int, int,
				       struct expression *);

static int debug_to_remove_watchpoint (CORE_ADDR, int, int,
				       struct expression *);

static int debug_to_stopped_by_watchpoint (void);

static int debug_to_stopped_data_address (struct target_ops *, CORE_ADDR *);

static int debug_to_watchpoint_addr_within_range (struct target_ops *,
						  CORE_ADDR, CORE_ADDR, int);

static int debug_to_region_ok_for_hw_watchpoint (CORE_ADDR, int);

static int debug_to_can_accel_watchpoint_condition (CORE_ADDR, int, int,
						    struct expression *);

static void debug_to_terminal_init (void);

static void debug_to_terminal_inferior (void);

static void debug_to_terminal_ours_for_output (void);

static void debug_to_terminal_save_ours (void);

static void debug_to_terminal_ours (void);

static void debug_to_load (char *, int);

static int debug_to_can_run (void);

static void debug_to_stop (ptid_t);

/* Pointer to array of target architecture structures; the size of the
   array; the current index into the array; the allocated size of the
   array.  */
struct target_ops **target_structs;
unsigned target_struct_size;
unsigned target_struct_allocsize;
#define	DEFAULT_ALLOCSIZE	10

/* The initial current target, so that there is always a semi-valid
   current target.  */

static struct target_ops dummy_target;

/* Top of target stack.  */

static struct target_ops *target_stack;

/* The target structure we are currently using to talk to a process
   or file or whatever "inferior" we have.  */

struct target_ops current_target;

/* Command list for target.  */

static struct cmd_list_element *targetlist = NULL;

/* Nonzero if we should trust readonly sections from the
   executable when reading memory.  */

static int trust_readonly = 0;

/* Nonzero if we should show true memory content including
   memory breakpoint inserted by gdb.  */

static int show_memory_breakpoints = 0;

/* These globals control whether GDB attempts to perform these
   operations; they are useful for targets that need to prevent
   inadvertant disruption, such as in non-stop mode.  */

int may_write_registers = 1;

int may_write_memory = 1;

int may_insert_breakpoints = 1;

int may_insert_tracepoints = 1;

int may_insert_fast_tracepoints = 1;

int may_stop = 1;

/* Non-zero if we want to see trace of target level stuff.  */

static unsigned int targetdebug = 0;
static void
show_targetdebug (struct ui_file *file, int from_tty,
		  struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Target debugging is %s.\n"), value);
}

static void setup_target_debug (void);

/* The option sets this.  */
static int stack_cache_enabled_p_1 = 1;
/* And set_stack_cache_enabled_p updates this.
   The reason for the separation is so that we don't flush the cache for
   on->on transitions.  */
static int stack_cache_enabled_p = 1;

/* This is called *after* the stack-cache has been set.
   Flush the cache for off->on and on->off transitions.
   There's no real need to flush the cache for on->off transitions,
   except cleanliness.  */

static void
set_stack_cache_enabled_p (char *args, int from_tty,
			   struct cmd_list_element *c)
{
  if (stack_cache_enabled_p != stack_cache_enabled_p_1)
    target_dcache_invalidate ();

  stack_cache_enabled_p = stack_cache_enabled_p_1;
}

static void
show_stack_cache_enabled_p (struct ui_file *file, int from_tty,
			    struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Cache use for stack accesses is %s.\n"), value);
}

/* Cache of memory operations, to speed up remote access.  */
static DCACHE *target_dcache;

/* Invalidate the target dcache.  */

void
target_dcache_invalidate (void)
{
  dcache_invalidate (target_dcache);
}

/* The user just typed 'target' without the name of a target.  */

static void
target_command (char *arg, int from_tty)
{
  fputs_filtered ("Argument required (target name).  Try `help target'\n",
		  gdb_stdout);
}

/* Default target_has_* methods for process_stratum targets.  */

int
default_child_has_all_memory (struct target_ops *ops)
{
  /* If no inferior selected, then we can't read memory here.  */
  if (ptid_equal (inferior_ptid, null_ptid))
    return 0;

  return 1;
}

int
default_child_has_memory (struct target_ops *ops)
{
  /* If no inferior selected, then we can't read memory here.  */
  if (ptid_equal (inferior_ptid, null_ptid))
    return 0;

  return 1;
}

int
default_child_has_stack (struct target_ops *ops)
{
  /* If no inferior selected, there's no stack.  */
  if (ptid_equal (inferior_ptid, null_ptid))
    return 0;

  return 1;
}

int
default_child_has_registers (struct target_ops *ops)
{
  /* Can't read registers from no inferior.  */
  if (ptid_equal (inferior_ptid, null_ptid))
    return 0;

  return 1;
}

int
default_child_has_execution (struct target_ops *ops, ptid_t the_ptid)
{
  /* If there's no thread selected, then we can't make it run through
     hoops.  */
  if (ptid_equal (the_ptid, null_ptid))
    return 0;

  return 1;
}


int
target_has_all_memory_1 (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_has_all_memory (t))
      return 1;

  return 0;
}

int
target_has_memory_1 (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_has_memory (t))
      return 1;

  return 0;
}

int
target_has_stack_1 (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_has_stack (t))
      return 1;

  return 0;
}

int
target_has_registers_1 (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_has_registers (t))
      return 1;

  return 0;
}

int
target_has_execution_1 (ptid_t the_ptid)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_has_execution (t, the_ptid))
      return 1;

  return 0;
}

int
target_has_execution_current (void)
{
  return target_has_execution_1 (inferior_ptid);
}

/* Complete initialization of T.  This ensures that various fields in
   T are set, if needed by the target implementation.  */

void
complete_target_initialization (struct target_ops *t)
{
  /* Provide default values for all "must have" methods.  */
  if (t->to_xfer_partial == NULL)
    t->to_xfer_partial = default_xfer_partial;

  if (t->to_has_all_memory == NULL)
    t->to_has_all_memory = (int (*) (struct target_ops *)) return_zero;

  if (t->to_has_memory == NULL)
    t->to_has_memory = (int (*) (struct target_ops *)) return_zero;

  if (t->to_has_stack == NULL)
    t->to_has_stack = (int (*) (struct target_ops *)) return_zero;

  if (t->to_has_registers == NULL)
    t->to_has_registers = (int (*) (struct target_ops *)) return_zero;

  if (t->to_has_execution == NULL)
    t->to_has_execution = (int (*) (struct target_ops *, ptid_t)) return_zero;
}

/* Add possible target architecture T to the list and add a new
   command 'target T->to_shortname'.  Set COMPLETER as the command's
   completer if not NULL.  */

void
add_target_with_completer (struct target_ops *t,
			   completer_ftype *completer)
{
  struct cmd_list_element *c;

  complete_target_initialization (t);

  if (!target_structs)
    {
      target_struct_allocsize = DEFAULT_ALLOCSIZE;
      target_structs = (struct target_ops **) xmalloc
	(target_struct_allocsize * sizeof (*target_structs));
    }
  if (target_struct_size >= target_struct_allocsize)
    {
      target_struct_allocsize *= 2;
      target_structs = (struct target_ops **)
	xrealloc ((char *) target_structs,
		  target_struct_allocsize * sizeof (*target_structs));
    }
  target_structs[target_struct_size++] = t;

  if (targetlist == NULL)
    add_prefix_cmd ("target", class_run, target_command, _("\
Connect to a target machine or process.\n\
The first argument is the type or protocol of the target machine.\n\
Remaining arguments are interpreted by the target protocol.  For more\n\
information on the arguments for a particular protocol, type\n\
`help target ' followed by the protocol name."),
		    &targetlist, "target ", 0, &cmdlist);
  c = add_cmd (t->to_shortname, no_class, t->to_open, t->to_doc,
	       &targetlist);
  if (completer != NULL)
    set_cmd_completer (c, completer);
}

/* Add a possible target architecture to the list.  */

void
add_target (struct target_ops *t)
{
  add_target_with_completer (t, NULL);
}

/* See target.h.  */

void
add_deprecated_target_alias (struct target_ops *t, char *alias)
{
  struct cmd_list_element *c;
  char *alt;

  /* If we use add_alias_cmd, here, we do not get the deprecated warning,
     see PR cli/15104.  */
  c = add_cmd (alias, no_class, t->to_open, t->to_doc, &targetlist);
  alt = xstrprintf ("target %s", t->to_shortname);
  deprecate_cmd (c, alt);
}

/* Stub functions */

void
target_ignore (void)
{
}

void
target_kill (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_kill != NULL)
      {
	if (targetdebug)
	  fprintf_unfiltered (gdb_stdlog, "target_kill ()\n");

        t->to_kill (t);
	return;
      }

  noprocess ();
}

void
target_load (char *arg, int from_tty)
{
  target_dcache_invalidate ();
  (*current_target.to_load) (arg, from_tty);
}

void
target_create_inferior (char *exec_file, char *args,
			char **env, int from_tty)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_create_inferior != NULL)	
	{
	  t->to_create_inferior (t, exec_file, args, env, from_tty);
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog,
				"target_create_inferior (%s, %s, xxx, %d)\n",
				exec_file, args, from_tty);
	  return;
	}
    }

  internal_error (__FILE__, __LINE__,
		  _("could not find a target to create inferior"));
}

void
target_terminal_inferior (void)
{
  /* A background resume (``run&'') should leave GDB in control of the
     terminal.  Use target_can_async_p, not target_is_async_p, since at
     this point the target is not async yet.  However, if sync_execution
     is not set, we know it will become async prior to resume.  */
  if (target_can_async_p () && !sync_execution)
    return;

  /* If GDB is resuming the inferior in the foreground, install
     inferior's terminal modes.  */
  (*current_target.to_terminal_inferior) ();
}

static int
nomemory (CORE_ADDR memaddr, char *myaddr, int len, int write,
	  struct target_ops *t)
{
  errno = EIO;			/* Can't read/write this location.  */
  return 0;			/* No bytes handled.  */
}

static void
tcomplain (void)
{
  error (_("You can't do that when your target is `%s'"),
	 current_target.to_shortname);
}

void
noprocess (void)
{
  error (_("You can't do that without a process to debug."));
}

static void
default_terminal_info (const char *args, int from_tty)
{
  printf_unfiltered (_("No saved terminal information.\n"));
}

/* A default implementation for the to_get_ada_task_ptid target method.

   This function builds the PTID by using both LWP and TID as part of
   the PTID lwp and tid elements.  The pid used is the pid of the
   inferior_ptid.  */

static ptid_t
default_get_ada_task_ptid (long lwp, long tid)
{
  return ptid_build (ptid_get_pid (inferior_ptid), lwp, tid);
}

static enum exec_direction_kind
default_execution_direction (void)
{
  if (!target_can_execute_reverse)
    return EXEC_FORWARD;
  else if (!target_can_async_p ())
    return EXEC_FORWARD;
  else
    gdb_assert_not_reached ("\
to_execution_direction must be implemented for reverse async");
}

/* Go through the target stack from top to bottom, copying over zero
   entries in current_target, then filling in still empty entries.  In
   effect, we are doing class inheritance through the pushed target
   vectors.

   NOTE: cagney/2003-10-17: The problem with this inheritance, as it
   is currently implemented, is that it discards any knowledge of
   which target an inherited method originally belonged to.
   Consequently, new new target methods should instead explicitly and
   locally search the target stack for the target that can handle the
   request.  */

static void
update_current_target (void)
{
  struct target_ops *t;

  /* First, reset current's contents.  */
  memset (&current_target, 0, sizeof (current_target));

#define INHERIT(FIELD, TARGET) \
      if (!current_target.FIELD) \
	current_target.FIELD = (TARGET)->FIELD

  for (t = target_stack; t; t = t->beneath)
    {
      INHERIT (to_shortname, t);
      INHERIT (to_longname, t);
      INHERIT (to_doc, t);
      /* Do not inherit to_open.  */
      /* Do not inherit to_close.  */
      /* Do not inherit to_attach.  */
      INHERIT (to_post_attach, t);
      INHERIT (to_attach_no_wait, t);
      /* Do not inherit to_detach.  */
      /* Do not inherit to_disconnect.  */
      /* Do not inherit to_resume.  */
      /* Do not inherit to_wait.  */
      /* Do not inherit to_fetch_registers.  */
      /* Do not inherit to_store_registers.  */
      INHERIT (to_prepare_to_store, t);
      INHERIT (deprecated_xfer_memory, t);
      INHERIT (to_files_info, t);
      INHERIT (to_insert_breakpoint, t);
      INHERIT (to_remove_breakpoint, t);
      INHERIT (to_can_use_hw_breakpoint, t);
      INHERIT (to_insert_hw_breakpoint, t);
      INHERIT (to_remove_hw_breakpoint, t);
      /* Do not inherit to_ranged_break_num_registers.  */
      INHERIT (to_insert_watchpoint, t);
      INHERIT (to_remove_watchpoint, t);
      /* Do not inherit to_insert_mask_watchpoint.  */
      /* Do not inherit to_remove_mask_watchpoint.  */
      INHERIT (to_stopped_data_address, t);
      INHERIT (to_have_steppable_watchpoint, t);
      INHERIT (to_have_continuable_watchpoint, t);
      INHERIT (to_stopped_by_watchpoint, t);
      INHERIT (to_watchpoint_addr_within_range, t);
      INHERIT (to_region_ok_for_hw_watchpoint, t);
      INHERIT (to_can_accel_watchpoint_condition, t);
      /* Do not inherit to_masked_watch_num_registers.  */
      INHERIT (to_terminal_init, t);
      INHERIT (to_terminal_inferior, t);
      INHERIT (to_terminal_ours_for_output, t);
      INHERIT (to_terminal_ours, t);
      INHERIT (to_terminal_save_ours, t);
      INHERIT (to_terminal_info, t);
      /* Do not inherit to_kill.  */
      INHERIT (to_load, t);
      /* Do no inherit to_create_inferior.  */
      INHERIT (to_post_startup_inferior, t);
      INHERIT (to_insert_fork_catchpoint, t);
      INHERIT (to_remove_fork_catchpoint, t);
      INHERIT (to_insert_vfork_catchpoint, t);
      INHERIT (to_remove_vfork_catchpoint, t);
      /* Do not inherit to_follow_fork.  */
      INHERIT (to_insert_exec_catchpoint, t);
      INHERIT (to_remove_exec_catchpoint, t);
      INHERIT (to_set_syscall_catchpoint, t);
      INHERIT (to_has_exited, t);
      /* Do not inherit to_mourn_inferior.  */
      INHERIT (to_can_run, t);
      /* Do not inherit to_pass_signals.  */
      /* Do not inherit to_program_signals.  */
      /* Do not inherit to_thread_alive.  */
      /* Do not inherit to_find_new_threads.  */
      /* Do not inherit to_pid_to_str.  */
      INHERIT (to_extra_thread_info, t);
      INHERIT (to_thread_name, t);
      INHERIT (to_stop, t);
      /* Do not inherit to_xfer_partial.  */
      INHERIT (to_rcmd, t);
      INHERIT (to_pid_to_exec_file, t);
      INHERIT (to_log_command, t);
      INHERIT (to_stratum, t);
      /* Do not inherit to_has_all_memory.  */
      /* Do not inherit to_has_memory.  */
      /* Do not inherit to_has_stack.  */
      /* Do not inherit to_has_registers.  */
      /* Do not inherit to_has_execution.  */
      INHERIT (to_has_thread_control, t);
      INHERIT (to_can_async_p, t);
      INHERIT (to_is_async_p, t);
      INHERIT (to_async, t);
      INHERIT (to_find_memory_regions, t);
      INHERIT (to_make_corefile_notes, t);
      INHERIT (to_get_bookmark, t);
      INHERIT (to_goto_bookmark, t);
      /* Do not inherit to_get_thread_local_address.  */
      INHERIT (to_can_execute_reverse, t);
      INHERIT (to_execution_direction, t);
      INHERIT (to_thread_architecture, t);
      /* Do not inherit to_read_description.  */
      INHERIT (to_get_ada_task_ptid, t);
      /* Do not inherit to_search_memory.  */
      INHERIT (to_supports_multi_process, t);
      INHERIT (to_supports_enable_disable_tracepoint, t);
      INHERIT (to_supports_string_tracing, t);
      INHERIT (to_trace_init, t);
      INHERIT (to_download_tracepoint, t);
      INHERIT (to_can_download_tracepoint, t);
      INHERIT (to_download_trace_state_variable, t);
      INHERIT (to_enable_tracepoint, t);
      INHERIT (to_disable_tracepoint, t);
      INHERIT (to_trace_set_readonly_regions, t);
      INHERIT (to_trace_start, t);
      INHERIT (to_get_trace_status, t);
      INHERIT (to_get_tracepoint_status, t);
      INHERIT (to_trace_stop, t);
      INHERIT (to_trace_find, t);
      INHERIT (to_get_trace_state_variable_value, t);
      INHERIT (to_save_trace_data, t);
      INHERIT (to_upload_tracepoints, t);
      INHERIT (to_upload_trace_state_variables, t);
      INHERIT (to_get_raw_trace_data, t);
      INHERIT (to_get_min_fast_tracepoint_insn_len, t);
      INHERIT (to_set_disconnected_tracing, t);
      INHERIT (to_set_circular_trace_buffer, t);
      INHERIT (to_set_trace_buffer_size, t);
      INHERIT (to_set_trace_notes, t);
      INHERIT (to_get_tib_address, t);
      INHERIT (to_set_permissions, t);
      INHERIT (to_static_tracepoint_marker_at, t);
      INHERIT (to_static_tracepoint_markers_by_strid, t);
      INHERIT (to_traceframe_info, t);
      INHERIT (to_use_agent, t);
      INHERIT (to_can_use_agent, t);
      INHERIT (to_augmented_libraries_svr4_read, t);
      INHERIT (to_magic, t);
      INHERIT (to_supports_evaluation_of_breakpoint_conditions, t);
      INHERIT (to_can_run_breakpoint_commands, t);
      /* Do not inherit to_memory_map.  */
      /* Do not inherit to_flash_erase.  */
      /* Do not inherit to_flash_done.  */
    }
#undef INHERIT

  /* Clean up a target struct so it no longer has any zero pointers in
     it.  Some entries are defaulted to a method that print an error,
     others are hard-wired to a standard recursive default.  */

#define de_fault(field, value) \
  if (!current_target.field)               \
    current_target.field = value

  de_fault (to_open,
	    (void (*) (char *, int))
	    tcomplain);
  de_fault (to_close,
	    (void (*) (void))
	    target_ignore);
  de_fault (to_post_attach,
	    (void (*) (int))
	    target_ignore);
  de_fault (to_prepare_to_store,
	    (void (*) (struct regcache *))
	    noprocess);
  de_fault (deprecated_xfer_memory,
	    (int (*) (CORE_ADDR, gdb_byte *, int, int,
		      struct mem_attrib *, struct target_ops *))
	    nomemory);
  de_fault (to_files_info,
	    (void (*) (struct target_ops *))
	    target_ignore);
  de_fault (to_insert_breakpoint,
	    memory_insert_breakpoint);
  de_fault (to_remove_breakpoint,
	    memory_remove_breakpoint);
  de_fault (to_can_use_hw_breakpoint,
	    (int (*) (int, int, int))
	    return_zero);
  de_fault (to_insert_hw_breakpoint,
	    (int (*) (struct gdbarch *, struct bp_target_info *))
	    return_minus_one);
  de_fault (to_remove_hw_breakpoint,
	    (int (*) (struct gdbarch *, struct bp_target_info *))
	    return_minus_one);
  de_fault (to_insert_watchpoint,
	    (int (*) (CORE_ADDR, int, int, struct expression *))
	    return_minus_one);
  de_fault (to_remove_watchpoint,
	    (int (*) (CORE_ADDR, int, int, struct expression *))
	    return_minus_one);
  de_fault (to_stopped_by_watchpoint,
	    (int (*) (void))
	    return_zero);
  de_fault (to_stopped_data_address,
	    (int (*) (struct target_ops *, CORE_ADDR *))
	    return_zero);
  de_fault (to_watchpoint_addr_within_range,
	    default_watchpoint_addr_within_range);
  de_fault (to_region_ok_for_hw_watchpoint,
	    default_region_ok_for_hw_watchpoint);
  de_fault (to_can_accel_watchpoint_condition,
            (int (*) (CORE_ADDR, int, int, struct expression *))
            return_zero);
  de_fault (to_terminal_init,
	    (void (*) (void))
	    target_ignore);
  de_fault (to_terminal_inferior,
	    (void (*) (void))
	    target_ignore);
  de_fault (to_terminal_ours_for_output,
	    (void (*) (void))
	    target_ignore);
  de_fault (to_terminal_ours,
	    (void (*) (void))
	    target_ignore);
  de_fault (to_terminal_save_ours,
	    (void (*) (void))
	    target_ignore);
  de_fault (to_terminal_info,
	    default_terminal_info);
  de_fault (to_load,
	    (void (*) (char *, int))
	    tcomplain);
  de_fault (to_post_startup_inferior,
	    (void (*) (ptid_t))
	    target_ignore);
  de_fault (to_insert_fork_catchpoint,
	    (int (*) (int))
	    return_one);
  de_fault (to_remove_fork_catchpoint,
	    (int (*) (int))
	    return_one);
  de_fault (to_insert_vfork_catchpoint,
	    (int (*) (int))
	    return_one);
  de_fault (to_remove_vfork_catchpoint,
	    (int (*) (int))
	    return_one);
  de_fault (to_insert_exec_catchpoint,
	    (int (*) (int))
	    return_one);
  de_fault (to_remove_exec_catchpoint,
	    (int (*) (int))
	    return_one);
  de_fault (to_set_syscall_catchpoint,
	    (int (*) (int, int, int, int, int *))
	    return_one);
  de_fault (to_has_exited,
	    (int (*) (int, int, int *))
	    return_zero);
  de_fault (to_can_run,
	    return_zero);
  de_fault (to_extra_thread_info,
	    (char *(*) (struct thread_info *))
	    return_zero);
  de_fault (to_thread_name,
	    (char *(*) (struct thread_info *))
	    return_zero);
  de_fault (to_stop,
	    (void (*) (ptid_t))
	    target_ignore);
  current_target.to_xfer_partial = current_xfer_partial;
  de_fault (to_rcmd,
	    (void (*) (char *, struct ui_file *))
	    tcomplain);
  de_fault (to_pid_to_exec_file,
	    (char *(*) (int))
	    return_zero);
  de_fault (to_async,
	    (void (*) (void (*) (enum inferior_event_type, void*), void*))
	    tcomplain);
  de_fault (to_thread_architecture,
	    default_thread_architecture);
  current_target.to_read_description = NULL;
  de_fault (to_get_ada_task_ptid,
            (ptid_t (*) (long, long))
            default_get_ada_task_ptid);
  de_fault (to_supports_multi_process,
	    (int (*) (void))
	    return_zero);
  de_fault (to_supports_enable_disable_tracepoint,
	    (int (*) (void))
	    return_zero);
  de_fault (to_supports_string_tracing,
	    (int (*) (void))
	    return_zero);
  de_fault (to_trace_init,
	    (void (*) (void))
	    tcomplain);
  de_fault (to_download_tracepoint,
	    (void (*) (struct bp_location *))
	    tcomplain);
  de_fault (to_can_download_tracepoint,
	    (int (*) (void))
	    return_zero);
  de_fault (to_download_trace_state_variable,
	    (void (*) (struct trace_state_variable *))
	    tcomplain);
  de_fault (to_enable_tracepoint,
	    (void (*) (struct bp_location *))
	    tcomplain);
  de_fault (to_disable_tracepoint,
	    (void (*) (struct bp_location *))
	    tcomplain);
  de_fault (to_trace_set_readonly_regions,
	    (void (*) (void))
	    tcomplain);
  de_fault (to_trace_start,
	    (void (*) (void))
	    tcomplain);
  de_fault (to_get_trace_status,
	    (int (*) (struct trace_status *))
	    return_minus_one);
  de_fault (to_get_tracepoint_status,
	    (void (*) (struct breakpoint *, struct uploaded_tp *))
	    tcomplain);
  de_fault (to_trace_stop,
	    (void (*) (void))
	    tcomplain);
  de_fault (to_trace_find,
	    (int (*) (enum trace_find_type, int, CORE_ADDR, CORE_ADDR, int *))
	    return_minus_one);
  de_fault (to_get_trace_state_variable_value,
	    (int (*) (int, LONGEST *))
	    return_zero);
  de_fault (to_save_trace_data,
	    (int (*) (const char *))
	    tcomplain);
  de_fault (to_upload_tracepoints,
	    (int (*) (struct uploaded_tp **))
	    return_zero);
  de_fault (to_upload_trace_state_variables,
	    (int (*) (struct uploaded_tsv **))
	    return_zero);
  de_fault (to_get_raw_trace_data,
	    (LONGEST (*) (gdb_byte *, ULONGEST, LONGEST))
	    tcomplain);
  de_fault (to_get_min_fast_tracepoint_insn_len,
	    (int (*) (void))
	    return_minus_one);
  de_fault (to_set_disconnected_tracing,
	    (void (*) (int))
	    target_ignore);
  de_fault (to_set_circular_trace_buffer,
	    (void (*) (int))
	    target_ignore);
  de_fault (to_set_trace_buffer_size,
	    (void (*) (LONGEST))
	    target_ignore);
  de_fault (to_set_trace_notes,
	    (int (*) (const char *, const char *, const char *))
	    return_zero);
  de_fault (to_get_tib_address,
	    (int (*) (ptid_t, CORE_ADDR *))
	    tcomplain);
  de_fault (to_set_permissions,
	    (void (*) (void))
	    target_ignore);
  de_fault (to_static_tracepoint_marker_at,
	    (int (*) (CORE_ADDR, struct static_tracepoint_marker *))
	    return_zero);
  de_fault (to_static_tracepoint_markers_by_strid,
	    (VEC(static_tracepoint_marker_p) * (*) (const char *))
	    tcomplain);
  de_fault (to_traceframe_info,
	    (struct traceframe_info * (*) (void))
	    return_zero);
  de_fault (to_supports_evaluation_of_breakpoint_conditions,
	    (int (*) (void))
	    return_zero);
  de_fault (to_can_run_breakpoint_commands,
	    (int (*) (void))
	    return_zero);
  de_fault (to_use_agent,
	    (int (*) (int))
	    tcomplain);
  de_fault (to_can_use_agent,
	    (int (*) (void))
	    return_zero);
  de_fault (to_augmented_libraries_svr4_read,
	    (int (*) (void))
	    return_zero);
  de_fault (to_execution_direction, default_execution_direction);

#undef de_fault

  /* Finally, position the target-stack beneath the squashed
     "current_target".  That way code looking for a non-inherited
     target method can quickly and simply find it.  */
  current_target.beneath = target_stack;

  if (targetdebug)
    setup_target_debug ();
}

/* Push a new target type into the stack of the existing target accessors,
   possibly superseding some of the existing accessors.

   Rather than allow an empty stack, we always have the dummy target at
   the bottom stratum, so we can call the function vectors without
   checking them.  */

void
push_target (struct target_ops *t)
{
  struct target_ops **cur;

  /* Check magic number.  If wrong, it probably means someone changed
     the struct definition, but not all the places that initialize one.  */
  if (t->to_magic != OPS_MAGIC)
    {
      fprintf_unfiltered (gdb_stderr,
			  "Magic number of %s target struct wrong\n",
			  t->to_shortname);
      internal_error (__FILE__, __LINE__,
		      _("failed internal consistency check"));
    }

  /* Find the proper stratum to install this target in.  */
  for (cur = &target_stack; (*cur) != NULL; cur = &(*cur)->beneath)
    {
      if ((int) (t->to_stratum) >= (int) (*cur)->to_stratum)
	break;
    }

  /* If there's already targets at this stratum, remove them.  */
  /* FIXME: cagney/2003-10-15: I think this should be popping all
     targets to CUR, and not just those at this stratum level.  */
  while ((*cur) != NULL && t->to_stratum == (*cur)->to_stratum)
    {
      /* There's already something at this stratum level.  Close it,
         and un-hook it from the stack.  */
      struct target_ops *tmp = (*cur);

      (*cur) = (*cur)->beneath;
      tmp->beneath = NULL;
      target_close (tmp);
    }

  /* We have removed all targets in our stratum, now add the new one.  */
  t->beneath = (*cur);
  (*cur) = t;

  update_current_target ();
}

/* Remove a target_ops vector from the stack, wherever it may be.
   Return how many times it was removed (0 or 1).  */

int
unpush_target (struct target_ops *t)
{
  struct target_ops **cur;
  struct target_ops *tmp;

  if (t->to_stratum == dummy_stratum)
    internal_error (__FILE__, __LINE__,
		    _("Attempt to unpush the dummy target"));

  /* Look for the specified target.  Note that we assume that a target
     can only occur once in the target stack.  */

  for (cur = &target_stack; (*cur) != NULL; cur = &(*cur)->beneath)
    {
      if ((*cur) == t)
	break;
    }

  /* If we don't find target_ops, quit.  Only open targets should be
     closed.  */
  if ((*cur) == NULL)
    return 0;			

  /* Unchain the target.  */
  tmp = (*cur);
  (*cur) = (*cur)->beneath;
  tmp->beneath = NULL;

  update_current_target ();

  /* Finally close the target.  Note we do this after unchaining, so
     any target method calls from within the target_close
     implementation don't end up in T anymore.  */
  target_close (t);

  return 1;
}

void
pop_all_targets_above (enum strata above_stratum)
{
  while ((int) (current_target.to_stratum) > (int) above_stratum)
    {
      if (!unpush_target (target_stack))
	{
	  fprintf_unfiltered (gdb_stderr,
			      "pop_all_targets couldn't find target %s\n",
			      target_stack->to_shortname);
	  internal_error (__FILE__, __LINE__,
			  _("failed internal consistency check"));
	  break;
	}
    }
}

void
pop_all_targets (void)
{
  pop_all_targets_above (dummy_stratum);
}

/* Return 1 if T is now pushed in the target stack.  Return 0 otherwise.  */

int
target_is_pushed (struct target_ops *t)
{
  struct target_ops **cur;

  /* Check magic number.  If wrong, it probably means someone changed
     the struct definition, but not all the places that initialize one.  */
  if (t->to_magic != OPS_MAGIC)
    {
      fprintf_unfiltered (gdb_stderr,
			  "Magic number of %s target struct wrong\n",
			  t->to_shortname);
      internal_error (__FILE__, __LINE__,
		      _("failed internal consistency check"));
    }

  for (cur = &target_stack; (*cur) != NULL; cur = &(*cur)->beneath)
    if (*cur == t)
      return 1;

  return 0;
}

/* Using the objfile specified in OBJFILE, find the address for the
   current thread's thread-local storage with offset OFFSET.  */
CORE_ADDR
target_translate_tls_address (struct objfile *objfile, CORE_ADDR offset)
{
  volatile CORE_ADDR addr = 0;
  struct target_ops *target;

  for (target = current_target.beneath;
       target != NULL;
       target = target->beneath)
    {
      if (target->to_get_thread_local_address != NULL)
	break;
    }

  if (target != NULL
      && gdbarch_fetch_tls_load_module_address_p (target_gdbarch ()))
    {
      ptid_t ptid = inferior_ptid;
      volatile struct gdb_exception ex;

      TRY_CATCH (ex, RETURN_MASK_ALL)
	{
	  CORE_ADDR lm_addr;
	  
	  /* Fetch the load module address for this objfile.  */
	  lm_addr = gdbarch_fetch_tls_load_module_address (target_gdbarch (),
	                                                   objfile);
	  /* If it's 0, throw the appropriate exception.  */
	  if (lm_addr == 0)
	    throw_error (TLS_LOAD_MODULE_NOT_FOUND_ERROR,
			 _("TLS load module not found"));

	  addr = target->to_get_thread_local_address (target, ptid,
						      lm_addr, offset);
	}
      /* If an error occurred, print TLS related messages here.  Otherwise,
         throw the error to some higher catcher.  */
      if (ex.reason < 0)
	{
	  int objfile_is_library = (objfile->flags & OBJF_SHARED);

	  switch (ex.error)
	    {
	    case TLS_NO_LIBRARY_SUPPORT_ERROR:
	      error (_("Cannot find thread-local variables "
		       "in this thread library."));
	      break;
	    case TLS_LOAD_MODULE_NOT_FOUND_ERROR:
	      if (objfile_is_library)
		error (_("Cannot find shared library `%s' in dynamic"
		         " linker's load module list"), objfile_name (objfile));
	      else
		error (_("Cannot find executable file `%s' in dynamic"
		         " linker's load module list"), objfile_name (objfile));
	      break;
	    case TLS_NOT_ALLOCATED_YET_ERROR:
	      if (objfile_is_library)
		error (_("The inferior has not yet allocated storage for"
		         " thread-local variables in\n"
		         "the shared library `%s'\n"
		         "for %s"),
		       objfile_name (objfile), target_pid_to_str (ptid));
	      else
		error (_("The inferior has not yet allocated storage for"
		         " thread-local variables in\n"
		         "the executable `%s'\n"
		         "for %s"),
		       objfile_name (objfile), target_pid_to_str (ptid));
	      break;
	    case TLS_GENERIC_ERROR:
	      if (objfile_is_library)
		error (_("Cannot find thread-local storage for %s, "
		         "shared library %s:\n%s"),
		       target_pid_to_str (ptid),
		       objfile_name (objfile), ex.message);
	      else
		error (_("Cannot find thread-local storage for %s, "
		         "executable file %s:\n%s"),
		       target_pid_to_str (ptid),
		       objfile_name (objfile), ex.message);
	      break;
	    default:
	      throw_exception (ex);
	      break;
	    }
	}
    }
  /* It wouldn't be wrong here to try a gdbarch method, too; finding
     TLS is an ABI-specific thing.  But we don't do that yet.  */
  else
    error (_("Cannot find thread-local variables on this target"));

  return addr;
}

const char *
target_xfer_error_to_string (enum target_xfer_error err)
{
#define CASE(X) case X: return #X
  switch (err)
    {
      CASE(TARGET_XFER_E_IO);
      CASE(TARGET_XFER_E_UNAVAILABLE);
    default:
      return "<unknown>";
    }
#undef CASE
};


#undef	MIN
#define MIN(A, B) (((A) <= (B)) ? (A) : (B))

/* target_read_string -- read a null terminated string, up to LEN bytes,
   from MEMADDR in target.  Set *ERRNOP to the errno code, or 0 if successful.
   Set *STRING to a pointer to malloc'd memory containing the data; the caller
   is responsible for freeing it.  Return the number of bytes successfully
   read.  */

int
target_read_string (CORE_ADDR memaddr, char **string, int len, int *errnop)
{
  int tlen, offset, i;
  gdb_byte buf[4];
  int errcode = 0;
  char *buffer;
  int buffer_allocated;
  char *bufptr;
  unsigned int nbytes_read = 0;

  gdb_assert (string);

  /* Small for testing.  */
  buffer_allocated = 4;
  buffer = xmalloc (buffer_allocated);
  bufptr = buffer;

  while (len > 0)
    {
      tlen = MIN (len, 4 - (memaddr & 3));
      offset = memaddr & 3;

      errcode = target_read_memory (memaddr & ~3, buf, sizeof buf);
      if (errcode != 0)
	{
	  /* The transfer request might have crossed the boundary to an
	     unallocated region of memory.  Retry the transfer, requesting
	     a single byte.  */
	  tlen = 1;
	  offset = 0;
	  errcode = target_read_memory (memaddr, buf, 1);
	  if (errcode != 0)
	    goto done;
	}

      if (bufptr - buffer + tlen > buffer_allocated)
	{
	  unsigned int bytes;

	  bytes = bufptr - buffer;
	  buffer_allocated *= 2;
	  buffer = xrealloc (buffer, buffer_allocated);
	  bufptr = buffer + bytes;
	}

      for (i = 0; i < tlen; i++)
	{
	  *bufptr++ = buf[i + offset];
	  if (buf[i + offset] == '\000')
	    {
	      nbytes_read += i + 1;
	      goto done;
	    }
	}

      memaddr += tlen;
      len -= tlen;
      nbytes_read += tlen;
    }
done:
  *string = buffer;
  if (errnop != NULL)
    *errnop = errcode;
  return nbytes_read;
}

struct target_section_table *
target_get_section_table (struct target_ops *target)
{
  struct target_ops *t;

  if (targetdebug)
    fprintf_unfiltered (gdb_stdlog, "target_get_section_table ()\n");

  for (t = target; t != NULL; t = t->beneath)
    if (t->to_get_section_table != NULL)
      return (*t->to_get_section_table) (t);

  return NULL;
}

/* Find a section containing ADDR.  */

struct target_section *
target_section_by_addr (struct target_ops *target, CORE_ADDR addr)
{
  struct target_section_table *table = target_get_section_table (target);
  struct target_section *secp;

  if (table == NULL)
    return NULL;

  for (secp = table->sections; secp < table->sections_end; secp++)
    {
      if (addr >= secp->addr && addr < secp->endaddr)
	return secp;
    }
  return NULL;
}

/* Read memory from the live target, even if currently inspecting a
   traceframe.  The return is the same as that of target_read.  */

static LONGEST
target_read_live_memory (enum target_object object,
			 ULONGEST memaddr, gdb_byte *myaddr, LONGEST len)
{
  LONGEST ret;
  struct cleanup *cleanup;

  /* Switch momentarily out of tfind mode so to access live memory.
     Note that this must not clear global state, such as the frame
     cache, which must still remain valid for the previous traceframe.
     We may be _building_ the frame cache at this point.  */
  cleanup = make_cleanup_restore_traceframe_number ();
  set_traceframe_number (-1);

  ret = target_read (current_target.beneath, object, NULL,
		     myaddr, memaddr, len);

  do_cleanups (cleanup);
  return ret;
}

/* Using the set of read-only target sections of OPS, read live
   read-only memory.  Note that the actual reads start from the
   top-most target again.

   For interface/parameters/return description see target.h,
   to_xfer_partial.  */

static LONGEST
memory_xfer_live_readonly_partial (struct target_ops *ops,
				   enum target_object object,
				   gdb_byte *readbuf, ULONGEST memaddr,
				   LONGEST len)
{
  struct target_section *secp;
  struct target_section_table *table;

  secp = target_section_by_addr (ops, memaddr);
  if (secp != NULL
      && (bfd_get_section_flags (secp->the_bfd_section->owner,
				 secp->the_bfd_section)
	  & SEC_READONLY))
    {
      struct target_section *p;
      ULONGEST memend = memaddr + len;

      table = target_get_section_table (ops);

      for (p = table->sections; p < table->sections_end; p++)
	{
	  if (memaddr >= p->addr)
	    {
	      if (memend <= p->endaddr)
		{
		  /* Entire transfer is within this section.  */
		  return target_read_live_memory (object, memaddr,
						  readbuf, len);
		}
	      else if (memaddr >= p->endaddr)
		{
		  /* This section ends before the transfer starts.  */
		  continue;
		}
	      else
		{
		  /* This section overlaps the transfer.  Just do half.  */
		  len = p->endaddr - memaddr;
		  return target_read_live_memory (object, memaddr,
						  readbuf, len);
		}
	    }
	}
    }

  return 0;
}

/* Perform a partial memory transfer.
   For docs see target.h, to_xfer_partial.  */

static LONGEST
memory_xfer_partial_1 (struct target_ops *ops, enum target_object object,
		       void *readbuf, const void *writebuf, ULONGEST memaddr,
		       LONGEST len)
{
  LONGEST res;
  int reg_len;
  struct mem_region *region;
  struct inferior *inf;

  /* For accesses to unmapped overlay sections, read directly from
     files.  Must do this first, as MEMADDR may need adjustment.  */
  if (readbuf != NULL && overlay_debugging)
    {
      struct obj_section *section = find_pc_overlay (memaddr);

      if (pc_in_unmapped_range (memaddr, section))
	{
	  struct target_section_table *table
	    = target_get_section_table (ops);
	  const char *section_name = section->the_bfd_section->name;

	  memaddr = overlay_mapped_address (memaddr, section);
	  return section_table_xfer_memory_partial (readbuf, writebuf,
						    memaddr, len,
						    table->sections,
						    table->sections_end,
						    section_name);
	}
    }

  /* Try the executable files, if "trust-readonly-sections" is set.  */
  if (readbuf != NULL && trust_readonly)
    {
      struct target_section *secp;
      struct target_section_table *table;

      secp = target_section_by_addr (ops, memaddr);
      if (secp != NULL
	  && (bfd_get_section_flags (secp->the_bfd_section->owner,
				     secp->the_bfd_section)
	      & SEC_READONLY))
	{
	  table = target_get_section_table (ops);
	  return section_table_xfer_memory_partial (readbuf, writebuf,
						    memaddr, len,
						    table->sections,
						    table->sections_end,
						    NULL);
	}
    }

  /* If reading unavailable memory in the context of traceframes, and
     this address falls within a read-only section, fallback to
     reading from live memory.  */
  if (readbuf != NULL && get_traceframe_number () != -1)
    {
      VEC(mem_range_s) *available;

      /* If we fail to get the set of available memory, then the
	 target does not support querying traceframe info, and so we
	 attempt reading from the traceframe anyway (assuming the
	 target implements the old QTro packet then).  */
      if (traceframe_available_memory (&available, memaddr, len))
	{
	  struct cleanup *old_chain;

	  old_chain = make_cleanup (VEC_cleanup(mem_range_s), &available);

	  if (VEC_empty (mem_range_s, available)
	      || VEC_index (mem_range_s, available, 0)->start != memaddr)
	    {
	      /* Don't read into the traceframe's available
		 memory.  */
	      if (!VEC_empty (mem_range_s, available))
		{
		  LONGEST oldlen = len;

		  len = VEC_index (mem_range_s, available, 0)->start - memaddr;
		  gdb_assert (len <= oldlen);
		}

	      do_cleanups (old_chain);

	      /* This goes through the topmost target again.  */
	      res = memory_xfer_live_readonly_partial (ops, object,
						       readbuf, memaddr, len);
	      if (res > 0)
		return res;

	      /* No use trying further, we know some memory starting
		 at MEMADDR isn't available.  */
	      return TARGET_XFER_E_UNAVAILABLE;
	    }

	  /* Don't try to read more than how much is available, in
	     case the target implements the deprecated QTro packet to
	     cater for older GDBs (the target's knowledge of read-only
	     sections may be outdated by now).  */
	  len = VEC_index (mem_range_s, available, 0)->length;

	  do_cleanups (old_chain);
	}
    }

  /* Try GDB's internal data cache.  */
  region = lookup_mem_region (memaddr);
  /* region->hi == 0 means there's no upper bound.  */
  if (memaddr + len < region->hi || region->hi == 0)
    reg_len = len;
  else
    reg_len = region->hi - memaddr;

  switch (region->attrib.mode)
    {
    case MEM_RO:
      if (writebuf != NULL)
	return -1;
      break;

    case MEM_WO:
      if (readbuf != NULL)
	return -1;
      break;

    case MEM_FLASH:
      /* We only support writing to flash during "load" for now.  */
      if (writebuf != NULL)
	error (_("Writing to flash memory forbidden in this context"));
      break;

    case MEM_NONE:
      return -1;
    }

  if (!ptid_equal (inferior_ptid, null_ptid))
    inf = find_inferior_pid (ptid_get_pid (inferior_ptid));
  else
    inf = NULL;

  if (inf != NULL
      /* The dcache reads whole cache lines; that doesn't play well
	 with reading from a trace buffer, because reading outside of
	 the collected memory range fails.  */
      && get_traceframe_number () == -1
      && (region->attrib.cache
	  || (stack_cache_enabled_p && object == TARGET_OBJECT_STACK_MEMORY)))
    {
      if (readbuf != NULL)
	res = dcache_xfer_memory (ops, target_dcache, memaddr, readbuf,
				  reg_len, 0);
      else
	/* FIXME drow/2006-08-09: If we're going to preserve const
	   correctness dcache_xfer_memory should take readbuf and
	   writebuf.  */
	res = dcache_xfer_memory (ops, target_dcache, memaddr,
				  (void *) writebuf,
				  reg_len, 1);
      if (res <= 0)
	return -1;
      else
	return res;
    }

  /* If none of those methods found the memory we wanted, fall back
     to a target partial transfer.  Normally a single call to
     to_xfer_partial is enough; if it doesn't recognize an object
     it will call the to_xfer_partial of the next target down.
     But for memory this won't do.  Memory is the only target
     object which can be read from more than one valid target.
     A core file, for instance, could have some of memory but
     delegate other bits to the target below it.  So, we must
     manually try all targets.  */

  do
    {
      res = ops->to_xfer_partial (ops, TARGET_OBJECT_MEMORY, NULL,
				  readbuf, writebuf, memaddr, reg_len);
      if (res > 0)
	break;

      /* We want to continue past core files to executables, but not
	 past a running target's memory.  */
      if (ops->to_has_all_memory (ops))
	break;

      ops = ops->beneath;
    }
  while (ops != NULL);

  /* Make sure the cache gets updated no matter what - if we are writing
     to the stack.  Even if this write is not tagged as such, we still need
     to update the cache.  */

  if (res > 0
      && inf != NULL
      && writebuf != NULL
      && !region->attrib.cache
      && stack_cache_enabled_p
      && object != TARGET_OBJECT_STACK_MEMORY)
    {
      dcache_update (target_dcache, memaddr, (void *) writebuf, res);
    }

  /* If we still haven't got anything, return the last error.  We
     give up.  */
  return res;
}

/* Perform a partial memory transfer.  For docs see target.h,
   to_xfer_partial.  */

static LONGEST
memory_xfer_partial (struct target_ops *ops, enum target_object object,
		     void *readbuf, const void *writebuf, ULONGEST memaddr,
		     LONGEST len)
{
  int res;

  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    return 0;

  /* Fill in READBUF with breakpoint shadows, or WRITEBUF with
     breakpoint insns, thus hiding out from higher layers whether
     there are software breakpoints inserted in the code stream.  */
  if (readbuf != NULL)
    {
      res = memory_xfer_partial_1 (ops, object, readbuf, NULL, memaddr, len);

      if (res > 0 && !show_memory_breakpoints)
	breakpoint_xfer_memory (readbuf, NULL, NULL, memaddr, res);
    }
  else
    {
      void *buf;
      struct cleanup *old_chain;

      buf = xmalloc (len);
      old_chain = make_cleanup (xfree, buf);
      memcpy (buf, writebuf, len);

      breakpoint_xfer_memory (NULL, buf, writebuf, memaddr, len);
      res = memory_xfer_partial_1 (ops, object, NULL, buf, memaddr, len);

      do_cleanups (old_chain);
    }

  return res;
}

static void
restore_show_memory_breakpoints (void *arg)
{
  show_memory_breakpoints = (uintptr_t) arg;
}

struct cleanup *
make_show_memory_breakpoints_cleanup (int show)
{
  int current = show_memory_breakpoints;

  show_memory_breakpoints = show;
  return make_cleanup (restore_show_memory_breakpoints,
		       (void *) (uintptr_t) current);
}

/* For docs see target.h, to_xfer_partial.  */

LONGEST
target_xfer_partial (struct target_ops *ops,
		     enum target_object object, const char *annex,
		     void *readbuf, const void *writebuf,
		     ULONGEST offset, LONGEST len)
{
  LONGEST retval;

  gdb_assert (ops->to_xfer_partial != NULL);

  if (writebuf && !may_write_memory)
    error (_("Writing to memory is not allowed (addr %s, len %s)"),
	   core_addr_to_string_nz (offset), plongest (len));

  /* If this is a memory transfer, let the memory-specific code
     have a look at it instead.  Memory transfers are more
     complicated.  */
  if (object == TARGET_OBJECT_MEMORY || object == TARGET_OBJECT_STACK_MEMORY)
    retval = memory_xfer_partial (ops, object, readbuf,
				  writebuf, offset, len);
  else
    {
      enum target_object raw_object = object;

      /* If this is a raw memory transfer, request the normal
	 memory object from other layers.  */
      if (raw_object == TARGET_OBJECT_RAW_MEMORY)
	raw_object = TARGET_OBJECT_MEMORY;

      retval = ops->to_xfer_partial (ops, raw_object, annex, readbuf,
				     writebuf, offset, len);
    }

  if (targetdebug)
    {
      const unsigned char *myaddr = NULL;

      fprintf_unfiltered (gdb_stdlog,
			  "%s:target_xfer_partial "
			  "(%d, %s, %s, %s, %s, %s) = %s",
			  ops->to_shortname,
			  (int) object,
			  (annex ? annex : "(null)"),
			  host_address_to_string (readbuf),
			  host_address_to_string (writebuf),
			  core_addr_to_string_nz (offset),
			  plongest (len), plongest (retval));

      if (readbuf)
	myaddr = readbuf;
      if (writebuf)
	myaddr = writebuf;
      if (retval > 0 && myaddr != NULL)
	{
	  int i;

	  fputs_unfiltered (", bytes =", gdb_stdlog);
	  for (i = 0; i < retval; i++)
	    {
	      if ((((intptr_t) &(myaddr[i])) & 0xf) == 0)
		{
		  if (targetdebug < 2 && i > 0)
		    {
		      fprintf_unfiltered (gdb_stdlog, " ...");
		      break;
		    }
		  fprintf_unfiltered (gdb_stdlog, "\n");
		}

	      fprintf_unfiltered (gdb_stdlog, " %02x", myaddr[i] & 0xff);
	    }
	}

      fputc_unfiltered ('\n', gdb_stdlog);
    }
  return retval;
}

/* Read LEN bytes of target memory at address MEMADDR, placing the
   results in GDB's memory at MYADDR.  Returns either 0 for success or
   a target_xfer_error value if any error occurs.

   If an error occurs, no guarantee is made about the contents of the data at
   MYADDR.  In particular, the caller should not depend upon partial reads
   filling the buffer with good data.  There is no way for the caller to know
   how much good data might have been transfered anyway.  Callers that can
   deal with partial reads should call target_read (which will retry until
   it makes no progress, and then return how much was transferred).  */

int
target_read_memory (CORE_ADDR memaddr, gdb_byte *myaddr, ssize_t len)
{
  /* Dispatch to the topmost target, not the flattened current_target.
     Memory accesses check target->to_has_(all_)memory, and the
     flattened target doesn't inherit those.  */
  if (target_read (current_target.beneath, TARGET_OBJECT_MEMORY, NULL,
		   myaddr, memaddr, len) == len)
    return 0;
  else
    return TARGET_XFER_E_IO;
}

/* Like target_read_memory, but specify explicitly that this is a read from
   the target's stack.  This may trigger different cache behavior.  */

int
target_read_stack (CORE_ADDR memaddr, gdb_byte *myaddr, ssize_t len)
{
  /* Dispatch to the topmost target, not the flattened current_target.
     Memory accesses check target->to_has_(all_)memory, and the
     flattened target doesn't inherit those.  */

  if (target_read (current_target.beneath, TARGET_OBJECT_STACK_MEMORY, NULL,
		   myaddr, memaddr, len) == len)
    return 0;
  else
    return TARGET_XFER_E_IO;
}

/* Write LEN bytes from MYADDR to target memory at address MEMADDR.
   Returns either 0 for success or a target_xfer_error value if any
   error occurs.  If an error occurs, no guarantee is made about how
   much data got written.  Callers that can deal with partial writes
   should call target_write.  */

int
target_write_memory (CORE_ADDR memaddr, const gdb_byte *myaddr, ssize_t len)
{
  /* Dispatch to the topmost target, not the flattened current_target.
     Memory accesses check target->to_has_(all_)memory, and the
     flattened target doesn't inherit those.  */
  if (target_write (current_target.beneath, TARGET_OBJECT_MEMORY, NULL,
		    myaddr, memaddr, len) == len)
    return 0;
  else
    return TARGET_XFER_E_IO;
}

/* Write LEN bytes from MYADDR to target raw memory at address
   MEMADDR.  Returns either 0 for success or a target_xfer_error value
   if any error occurs.  If an error occurs, no guarantee is made
   about how much data got written.  Callers that can deal with
   partial writes should call target_write.  */

int
target_write_raw_memory (CORE_ADDR memaddr, const gdb_byte *myaddr, ssize_t len)
{
  /* Dispatch to the topmost target, not the flattened current_target.
     Memory accesses check target->to_has_(all_)memory, and the
     flattened target doesn't inherit those.  */
  if (target_write (current_target.beneath, TARGET_OBJECT_RAW_MEMORY, NULL,
		    myaddr, memaddr, len) == len)
    return 0;
  else
    return TARGET_XFER_E_IO;
}

/* Fetch the target's memory map.  */

VEC(mem_region_s) *
target_memory_map (void)
{
  VEC(mem_region_s) *result;
  struct mem_region *last_one, *this_one;
  int ix;
  struct target_ops *t;

  if (targetdebug)
    fprintf_unfiltered (gdb_stdlog, "target_memory_map ()\n");

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_memory_map != NULL)
      break;

  if (t == NULL)
    return NULL;

  result = t->to_memory_map (t);
  if (result == NULL)
    return NULL;

  qsort (VEC_address (mem_region_s, result),
	 VEC_length (mem_region_s, result),
	 sizeof (struct mem_region), mem_region_cmp);

  /* Check that regions do not overlap.  Simultaneously assign
     a numbering for the "mem" commands to use to refer to
     each region.  */
  last_one = NULL;
  for (ix = 0; VEC_iterate (mem_region_s, result, ix, this_one); ix++)
    {
      this_one->number = ix;

      if (last_one && last_one->hi > this_one->lo)
	{
	  warning (_("Overlapping regions in memory map: ignoring"));
	  VEC_free (mem_region_s, result);
	  return NULL;
	}
      last_one = this_one;
    }

  return result;
}

void
target_flash_erase (ULONGEST address, LONGEST length)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_flash_erase != NULL)
      {
	if (targetdebug)
	  fprintf_unfiltered (gdb_stdlog, "target_flash_erase (%s, %s)\n",
			      hex_string (address), phex (length, 0));
	t->to_flash_erase (t, address, length);
	return;
      }

  tcomplain ();
}

void
target_flash_done (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_flash_done != NULL)
      {
	if (targetdebug)
	  fprintf_unfiltered (gdb_stdlog, "target_flash_done\n");
	t->to_flash_done (t);
	return;
      }

  tcomplain ();
}

static void
show_trust_readonly (struct ui_file *file, int from_tty,
		     struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("Mode for reading from readonly sections is %s.\n"),
		    value);
}

/* More generic transfers.  */

static LONGEST
default_xfer_partial (struct target_ops *ops, enum target_object object,
		      const char *annex, gdb_byte *readbuf,
		      const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  if (object == TARGET_OBJECT_MEMORY
      && ops->deprecated_xfer_memory != NULL)
    /* If available, fall back to the target's
       "deprecated_xfer_memory" method.  */
    {
      int xfered = -1;

      errno = 0;
      if (writebuf != NULL)
	{
	  void *buffer = xmalloc (len);
	  struct cleanup *cleanup = make_cleanup (xfree, buffer);

	  memcpy (buffer, writebuf, len);
	  xfered = ops->deprecated_xfer_memory (offset, buffer, len,
						1/*write*/, NULL, ops);
	  do_cleanups (cleanup);
	}
      if (readbuf != NULL)
	xfered = ops->deprecated_xfer_memory (offset, readbuf, len, 
					      0/*read*/, NULL, ops);
      if (xfered > 0)
	return xfered;
      else if (xfered == 0 && errno == 0)
	/* "deprecated_xfer_memory" uses 0, cross checked against
           ERRNO as one indication of an error.  */
	return 0;
      else
	return -1;
    }
  else if (ops->beneath != NULL)
    return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					  readbuf, writebuf, offset, len);
  else
    return -1;
}

/* The xfer_partial handler for the topmost target.  Unlike the default,
   it does not need to handle memory specially; it just passes all
   requests down the stack.  */

static LONGEST
current_xfer_partial (struct target_ops *ops, enum target_object object,
		      const char *annex, gdb_byte *readbuf,
		      const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  if (ops->beneath != NULL)
    return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					  readbuf, writebuf, offset, len);
  else
    return -1;
}

/* Target vector read/write partial wrapper functions.  */

static LONGEST
target_read_partial (struct target_ops *ops,
		     enum target_object object,
		     const char *annex, gdb_byte *buf,
		     ULONGEST offset, LONGEST len)
{
  return target_xfer_partial (ops, object, annex, buf, NULL, offset, len);
}

static LONGEST
target_write_partial (struct target_ops *ops,
		      enum target_object object,
		      const char *annex, const gdb_byte *buf,
		      ULONGEST offset, LONGEST len)
{
  return target_xfer_partial (ops, object, annex, NULL, buf, offset, len);
}

/* Wrappers to perform the full transfer.  */

/* For docs on target_read see target.h.  */

LONGEST
target_read (struct target_ops *ops,
	     enum target_object object,
	     const char *annex, gdb_byte *buf,
	     ULONGEST offset, LONGEST len)
{
  LONGEST xfered = 0;

  while (xfered < len)
    {
      LONGEST xfer = target_read_partial (ops, object, annex,
					  (gdb_byte *) buf + xfered,
					  offset + xfered, len - xfered);

      /* Call an observer, notifying them of the xfer progress?  */
      if (xfer == 0)
	return xfered;
      if (xfer < 0)
	return -1;
      xfered += xfer;
      QUIT;
    }
  return len;
}

/* Assuming that the entire [begin, end) range of memory cannot be
   read, try to read whatever subrange is possible to read.

   The function returns, in RESULT, either zero or one memory block.
   If there's a readable subrange at the beginning, it is completely
   read and returned.  Any further readable subrange will not be read.
   Otherwise, if there's a readable subrange at the end, it will be
   completely read and returned.  Any readable subranges before it
   (obviously, not starting at the beginning), will be ignored.  In
   other cases -- either no readable subrange, or readable subrange(s)
   that is neither at the beginning, or end, nothing is returned.

   The purpose of this function is to handle a read across a boundary
   of accessible memory in a case when memory map is not available.
   The above restrictions are fine for this case, but will give
   incorrect results if the memory is 'patchy'.  However, supporting
   'patchy' memory would require trying to read every single byte,
   and it seems unacceptable solution.  Explicit memory map is
   recommended for this case -- and target_read_memory_robust will
   take care of reading multiple ranges then.  */

static void
read_whatever_is_readable (struct target_ops *ops,
			   ULONGEST begin, ULONGEST end,
			   VEC(memory_read_result_s) **result)
{
  gdb_byte *buf = xmalloc (end - begin);
  ULONGEST current_begin = begin;
  ULONGEST current_end = end;
  int forward;
  memory_read_result_s r;

  /* If we previously failed to read 1 byte, nothing can be done here.  */
  if (end - begin <= 1)
    {
      xfree (buf);
      return;
    }

  /* Check that either first or the last byte is readable, and give up
     if not.  This heuristic is meant to permit reading accessible memory
     at the boundary of accessible region.  */
  if (target_read_partial (ops, TARGET_OBJECT_MEMORY, NULL,
			   buf, begin, 1) == 1)
    {
      forward = 1;
      ++current_begin;
    }
  else if (target_read_partial (ops, TARGET_OBJECT_MEMORY, NULL,
				buf + (end-begin) - 1, end - 1, 1) == 1)
    {
      forward = 0;
      --current_end;
    }
  else
    {
      xfree (buf);
      return;
    }

  /* Loop invariant is that the [current_begin, current_end) was previously
     found to be not readable as a whole.

     Note loop condition -- if the range has 1 byte, we can't divide the range
     so there's no point trying further.  */
  while (current_end - current_begin > 1)
    {
      ULONGEST first_half_begin, first_half_end;
      ULONGEST second_half_begin, second_half_end;
      LONGEST xfer;
      ULONGEST middle = current_begin + (current_end - current_begin)/2;

      if (forward)
	{
	  first_half_begin = current_begin;
	  first_half_end = middle;
	  second_half_begin = middle;
	  second_half_end = current_end;
	}
      else
	{
	  first_half_begin = middle;
	  first_half_end = current_end;
	  second_half_begin = current_begin;
	  second_half_end = middle;
	}

      xfer = target_read (ops, TARGET_OBJECT_MEMORY, NULL,
			  buf + (first_half_begin - begin),
			  first_half_begin,
			  first_half_end - first_half_begin);

      if (xfer == first_half_end - first_half_begin)
	{
	  /* This half reads up fine.  So, the error must be in the
	     other half.  */
	  current_begin = second_half_begin;
	  current_end = second_half_end;
	}
      else
	{
	  /* This half is not readable.  Because we've tried one byte, we
	     know some part of this half if actually redable.  Go to the next
	     iteration to divide again and try to read.

	     We don't handle the other half, because this function only tries
	     to read a single readable subrange.  */
	  current_begin = first_half_begin;
	  current_end = first_half_end;
	}
    }

  if (forward)
    {
      /* The [begin, current_begin) range has been read.  */
      r.begin = begin;
      r.end = current_begin;
      r.data = buf;
    }
  else
    {
      /* The [current_end, end) range has been read.  */
      LONGEST rlen = end - current_end;

      r.data = xmalloc (rlen);
      memcpy (r.data, buf + current_end - begin, rlen);
      r.begin = current_end;
      r.end = end;
      xfree (buf);
    }
  VEC_safe_push(memory_read_result_s, (*result), &r);
}

void
free_memory_read_result_vector (void *x)
{
  VEC(memory_read_result_s) *v = x;
  memory_read_result_s *current;
  int ix;

  for (ix = 0; VEC_iterate (memory_read_result_s, v, ix, current); ++ix)
    {
      xfree (current->data);
    }
  VEC_free (memory_read_result_s, v);
}

VEC(memory_read_result_s) *
read_memory_robust (struct target_ops *ops, ULONGEST offset, LONGEST len)
{
  VEC(memory_read_result_s) *result = 0;

  LONGEST xfered = 0;
  while (xfered < len)
    {
      struct mem_region *region = lookup_mem_region (offset + xfered);
      LONGEST rlen;

      /* If there is no explicit region, a fake one should be created.  */
      gdb_assert (region);

      if (region->hi == 0)
	rlen = len - xfered;
      else
	rlen = region->hi - offset;

      if (region->attrib.mode == MEM_NONE || region->attrib.mode == MEM_WO)
	{
	  /* Cannot read this region.  Note that we can end up here only
	     if the region is explicitly marked inaccessible, or
	     'inaccessible-by-default' is in effect.  */
	  xfered += rlen;
	}
      else
	{
	  LONGEST to_read = min (len - xfered, rlen);
	  gdb_byte *buffer = (gdb_byte *)xmalloc (to_read);

	  LONGEST xfer = target_read (ops, TARGET_OBJECT_MEMORY, NULL,
				      (gdb_byte *) buffer,
				      offset + xfered, to_read);
	  /* Call an observer, notifying them of the xfer progress?  */
	  if (xfer <= 0)
	    {
	      /* Got an error reading full chunk.  See if maybe we can read
		 some subrange.  */
	      xfree (buffer);
	      read_whatever_is_readable (ops, offset + xfered,
					 offset + xfered + to_read, &result);
	      xfered += to_read;
	    }
	  else
	    {
	      struct memory_read_result r;
	      r.data = buffer;
	      r.begin = offset + xfered;
	      r.end = r.begin + xfer;
	      VEC_safe_push (memory_read_result_s, result, &r);
	      xfered += xfer;
	    }
	  QUIT;
	}
    }
  return result;
}


/* An alternative to target_write with progress callbacks.  */

LONGEST
target_write_with_progress (struct target_ops *ops,
			    enum target_object object,
			    const char *annex, const gdb_byte *buf,
			    ULONGEST offset, LONGEST len,
			    void (*progress) (ULONGEST, void *), void *baton)
{
  LONGEST xfered = 0;

  /* Give the progress callback a chance to set up.  */
  if (progress)
    (*progress) (0, baton);

  while (xfered < len)
    {
      LONGEST xfer = target_write_partial (ops, object, annex,
					   (gdb_byte *) buf + xfered,
					   offset + xfered, len - xfered);

      if (xfer == 0)
	return xfered;
      if (xfer < 0)
	return -1;

      if (progress)
	(*progress) (xfer, baton);

      xfered += xfer;
      QUIT;
    }
  return len;
}

/* For docs on target_write see target.h.  */

LONGEST
target_write (struct target_ops *ops,
	      enum target_object object,
	      const char *annex, const gdb_byte *buf,
	      ULONGEST offset, LONGEST len)
{
  return target_write_with_progress (ops, object, annex, buf, offset, len,
				     NULL, NULL);
}

/* Read OBJECT/ANNEX using OPS.  Store the result in *BUF_P and return
   the size of the transferred data.  PADDING additional bytes are
   available in *BUF_P.  This is a helper function for
   target_read_alloc; see the declaration of that function for more
   information.  */

static LONGEST
target_read_alloc_1 (struct target_ops *ops, enum target_object object,
		     const char *annex, gdb_byte **buf_p, int padding)
{
  size_t buf_alloc, buf_pos;
  gdb_byte *buf;
  LONGEST n;

  /* This function does not have a length parameter; it reads the
     entire OBJECT).  Also, it doesn't support objects fetched partly
     from one target and partly from another (in a different stratum,
     e.g. a core file and an executable).  Both reasons make it
     unsuitable for reading memory.  */
  gdb_assert (object != TARGET_OBJECT_MEMORY);

  /* Start by reading up to 4K at a time.  The target will throttle
     this number down if necessary.  */
  buf_alloc = 4096;
  buf = xmalloc (buf_alloc);
  buf_pos = 0;
  while (1)
    {
      n = target_read_partial (ops, object, annex, &buf[buf_pos],
			       buf_pos, buf_alloc - buf_pos - padding);
      if (n < 0)
	{
	  /* An error occurred.  */
	  xfree (buf);
	  return -1;
	}
      else if (n == 0)
	{
	  /* Read all there was.  */
	  if (buf_pos == 0)
	    xfree (buf);
	  else
	    *buf_p = buf;
	  return buf_pos;
	}

      buf_pos += n;

      /* If the buffer is filling up, expand it.  */
      if (buf_alloc < buf_pos * 2)
	{
	  buf_alloc *= 2;
	  buf = xrealloc (buf, buf_alloc);
	}

      QUIT;
    }
}

/* Read OBJECT/ANNEX using OPS.  Store the result in *BUF_P and return
   the size of the transferred data.  See the declaration in "target.h"
   function for more information about the return value.  */

LONGEST
target_read_alloc (struct target_ops *ops, enum target_object object,
		   const char *annex, gdb_byte **buf_p)
{
  return target_read_alloc_1 (ops, object, annex, buf_p, 0);
}

/* Read OBJECT/ANNEX using OPS.  The result is NUL-terminated and
   returned as a string, allocated using xmalloc.  If an error occurs
   or the transfer is unsupported, NULL is returned.  Empty objects
   are returned as allocated but empty strings.  A warning is issued
   if the result contains any embedded NUL bytes.  */

char *
target_read_stralloc (struct target_ops *ops, enum target_object object,
		      const char *annex)
{
  gdb_byte *buffer;
  char *bufstr;
  LONGEST i, transferred;

  transferred = target_read_alloc_1 (ops, object, annex, &buffer, 1);
  bufstr = (char *) buffer;

  if (transferred < 0)
    return NULL;

  if (transferred == 0)
    return xstrdup ("");

  bufstr[transferred] = 0;

  /* Check for embedded NUL bytes; but allow trailing NULs.  */
  for (i = strlen (bufstr); i < transferred; i++)
    if (bufstr[i] != 0)
      {
	warning (_("target object %d, annex %s, "
		   "contained unexpected null characters"),
		 (int) object, annex ? annex : "(none)");
	break;
      }

  return bufstr;
}

/* Memory transfer methods.  */

void
get_target_memory (struct target_ops *ops, CORE_ADDR addr, gdb_byte *buf,
		   LONGEST len)
{
  /* This method is used to read from an alternate, non-current
     target.  This read must bypass the overlay support (as symbols
     don't match this target), and GDB's internal cache (wrong cache
     for this target).  */
  if (target_read (ops, TARGET_OBJECT_RAW_MEMORY, NULL, buf, addr, len)
      != len)
    memory_error (TARGET_XFER_E_IO, addr);
}

ULONGEST
get_target_memory_unsigned (struct target_ops *ops, CORE_ADDR addr,
			    int len, enum bfd_endian byte_order)
{
  gdb_byte buf[sizeof (ULONGEST)];

  gdb_assert (len <= sizeof (buf));
  get_target_memory (ops, addr, buf, len);
  return extract_unsigned_integer (buf, len, byte_order);
}

int
target_insert_breakpoint (struct gdbarch *gdbarch,
			  struct bp_target_info *bp_tgt)
{
  if (!may_insert_breakpoints)
    {
      warning (_("May not insert breakpoints"));
      return 1;
    }

  return (*current_target.to_insert_breakpoint) (gdbarch, bp_tgt);
}

int
target_remove_breakpoint (struct gdbarch *gdbarch,
			  struct bp_target_info *bp_tgt)
{
  /* This is kind of a weird case to handle, but the permission might
     have been changed after breakpoints were inserted - in which case
     we should just take the user literally and assume that any
     breakpoints should be left in place.  */
  if (!may_insert_breakpoints)
    {
      warning (_("May not remove breakpoints"));
      return 1;
    }

  return (*current_target.to_remove_breakpoint) (gdbarch, bp_tgt);
}

static void
target_info (char *args, int from_tty)
{
  struct target_ops *t;
  int has_all_mem = 0;

  if (symfile_objfile != NULL)
    printf_unfiltered (_("Symbols from \"%s\".\n"),
		       objfile_name (symfile_objfile));

  for (t = target_stack; t != NULL; t = t->beneath)
    {
      if (!(*t->to_has_memory) (t))
	continue;

      if ((int) (t->to_stratum) <= (int) dummy_stratum)
	continue;
      if (has_all_mem)
	printf_unfiltered (_("\tWhile running this, "
			     "GDB does not access memory from...\n"));
      printf_unfiltered ("%s:\n", t->to_longname);
      (t->to_files_info) (t);
      has_all_mem = (*t->to_has_all_memory) (t);
    }
}

/* This function is called before any new inferior is created, e.g.
   by running a program, attaching, or connecting to a target.
   It cleans up any state from previous invocations which might
   change between runs.  This is a subset of what target_preopen
   resets (things which might change between targets).  */

void
target_pre_inferior (int from_tty)
{
  /* Clear out solib state.  Otherwise the solib state of the previous
     inferior might have survived and is entirely wrong for the new
     target.  This has been observed on GNU/Linux using glibc 2.3.  How
     to reproduce:

     bash$ ./foo&
     [1] 4711
     bash$ ./foo&
     [1] 4712
     bash$ gdb ./foo
     [...]
     (gdb) attach 4711
     (gdb) detach
     (gdb) attach 4712
     Cannot access memory at address 0xdeadbeef
  */

  /* In some OSs, the shared library list is the same/global/shared
     across inferiors.  If code is shared between processes, so are
     memory regions and features.  */
  if (!gdbarch_has_global_solist (target_gdbarch ()))
    {
      no_shared_libraries (NULL, from_tty);

      invalidate_target_mem_regions ();

      target_clear_description ();
    }

  agent_capability_invalidate ();
}

/* Callback for iterate_over_inferiors.  Gets rid of the given
   inferior.  */

static int
dispose_inferior (struct inferior *inf, void *args)
{
  struct thread_info *thread;

  thread = any_thread_of_process (inf->pid);
  if (thread)
    {
      switch_to_thread (thread->ptid);

      /* Core inferiors actually should be detached, not killed.  */
      if (target_has_execution)
	target_kill ();
      else
	target_detach (NULL, 0);
    }

  return 0;
}

/* This is to be called by the open routine before it does
   anything.  */

void
target_preopen (int from_tty)
{
  dont_repeat ();

  if (have_inferiors ())
    {
      if (!from_tty
	  || !have_live_inferiors ()
	  || query (_("A program is being debugged already.  Kill it? ")))
	iterate_over_inferiors (dispose_inferior, NULL);
      else
	error (_("Program not killed."));
    }

  /* Calling target_kill may remove the target from the stack.  But if
     it doesn't (which seems like a win for UDI), remove it now.  */
  /* Leave the exec target, though.  The user may be switching from a
     live process to a core of the same program.  */
  pop_all_targets_above (file_stratum);

  target_pre_inferior (from_tty);
}

/* Detach a target after doing deferred register stores.  */

void
target_detach (char *args, int from_tty)
{
  struct target_ops* t;
  
  if (gdbarch_has_global_breakpoints (target_gdbarch ()))
    /* Don't remove global breakpoints here.  They're removed on
       disconnection from the target.  */
    ;
  else
    /* If we're in breakpoints-always-inserted mode, have to remove
       them before detaching.  */
    remove_breakpoints_pid (ptid_get_pid (inferior_ptid));

  prepare_for_detach ();

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_detach != NULL)
	{
	  t->to_detach (t, args, from_tty);
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "target_detach (%s, %d)\n",
				args, from_tty);
	  return;
	}
    }

  internal_error (__FILE__, __LINE__, _("could not find a target to detach"));
}

void
target_disconnect (char *args, int from_tty)
{
  struct target_ops *t;

  /* If we're in breakpoints-always-inserted mode or if breakpoints
     are global across processes, we have to remove them before
     disconnecting.  */
  remove_breakpoints ();

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_disconnect != NULL)
	{
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "target_disconnect (%s, %d)\n",
				args, from_tty);
	  t->to_disconnect (t, args, from_tty);
	  return;
	}

  tcomplain ();
}

ptid_t
target_wait (ptid_t ptid, struct target_waitstatus *status, int options)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_wait != NULL)
	{
	  ptid_t retval = (*t->to_wait) (t, ptid, status, options);

	  if (targetdebug)
	    {
	      char *status_string;
	      char *options_string;

	      status_string = target_waitstatus_to_string (status);
	      options_string = target_options_to_string (options);
	      fprintf_unfiltered (gdb_stdlog,
				  "target_wait (%d, status, options={%s})"
				  " = %d,   %s\n",
				  ptid_get_pid (ptid), options_string,
				  ptid_get_pid (retval), status_string);
	      xfree (status_string);
	      xfree (options_string);
	    }

	  return retval;
	}
    }

  noprocess ();
}

char *
target_pid_to_str (ptid_t ptid)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_pid_to_str != NULL)
	return (*t->to_pid_to_str) (t, ptid);
    }

  return normal_pid_to_str (ptid);
}

char *
target_thread_name (struct thread_info *info)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_thread_name != NULL)
	return (*t->to_thread_name) (info);
    }

  return NULL;
}

void
target_resume (ptid_t ptid, int step, enum gdb_signal signal)
{
  struct target_ops *t;

  target_dcache_invalidate ();

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_resume != NULL)
	{
	  t->to_resume (t, ptid, step, signal);
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "target_resume (%d, %s, %s)\n",
				ptid_get_pid (ptid),
				step ? "step" : "continue",
				gdb_signal_to_name (signal));

	  registers_changed_ptid (ptid);
	  set_executing (ptid, 1);
	  set_running (ptid, 1);
	  clear_inline_frame_state (ptid);
	  return;
	}
    }

  noprocess ();
}

void
target_pass_signals (int numsigs, unsigned char *pass_signals)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_pass_signals != NULL)
	{
	  if (targetdebug)
	    {
	      int i;

	      fprintf_unfiltered (gdb_stdlog, "target_pass_signals (%d, {",
				  numsigs);

	      for (i = 0; i < numsigs; i++)
		if (pass_signals[i])
		  fprintf_unfiltered (gdb_stdlog, " %s",
				      gdb_signal_to_name (i));

	      fprintf_unfiltered (gdb_stdlog, " })\n");
	    }

	  (*t->to_pass_signals) (numsigs, pass_signals);
	  return;
	}
    }
}

void
target_program_signals (int numsigs, unsigned char *program_signals)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_program_signals != NULL)
	{
	  if (targetdebug)
	    {
	      int i;

	      fprintf_unfiltered (gdb_stdlog, "target_program_signals (%d, {",
				  numsigs);

	      for (i = 0; i < numsigs; i++)
		if (program_signals[i])
		  fprintf_unfiltered (gdb_stdlog, " %s",
				      gdb_signal_to_name (i));

	      fprintf_unfiltered (gdb_stdlog, " })\n");
	    }

	  (*t->to_program_signals) (numsigs, program_signals);
	  return;
	}
    }
}

/* Look through the list of possible targets for a target that can
   follow forks.  */

int
target_follow_fork (int follow_child, int detach_fork)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_follow_fork != NULL)
	{
	  int retval = t->to_follow_fork (t, follow_child, detach_fork);

	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog,
				"target_follow_fork (%d, %d) = %d\n",
				follow_child, detach_fork, retval);
	  return retval;
	}
    }

  /* Some target returned a fork event, but did not know how to follow it.  */
  internal_error (__FILE__, __LINE__,
		  _("could not find a target to follow fork"));
}

void
target_mourn_inferior (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_mourn_inferior != NULL)	
	{
	  t->to_mourn_inferior (t);
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "target_mourn_inferior ()\n");

          /* We no longer need to keep handles on any of the object files.
             Make sure to release them to avoid unnecessarily locking any
             of them while we're not actually debugging.  */
          bfd_cache_close_all ();

	  return;
	}
    }

  internal_error (__FILE__, __LINE__,
		  _("could not find a target to follow mourn inferior"));
}

/* Look for a target which can describe architectural features, starting
   from TARGET.  If we find one, return its description.  */

const struct target_desc *
target_read_description (struct target_ops *target)
{
  struct target_ops *t;

  for (t = target; t != NULL; t = t->beneath)
    if (t->to_read_description != NULL)
      {
	const struct target_desc *tdesc;

	tdesc = t->to_read_description (t);
	if (tdesc)
	  return tdesc;
      }

  return NULL;
}

/* The default implementation of to_search_memory.
   This implements a basic search of memory, reading target memory and
   performing the search here (as opposed to performing the search in on the
   target side with, for example, gdbserver).  */

int
simple_search_memory (struct target_ops *ops,
		      CORE_ADDR start_addr, ULONGEST search_space_len,
		      const gdb_byte *pattern, ULONGEST pattern_len,
		      CORE_ADDR *found_addrp)
{
  /* NOTE: also defined in find.c testcase.  */
#define SEARCH_CHUNK_SIZE 16000
  const unsigned chunk_size = SEARCH_CHUNK_SIZE;
  /* Buffer to hold memory contents for searching.  */
  gdb_byte *search_buf;
  unsigned search_buf_size;
  struct cleanup *old_cleanups;

  search_buf_size = chunk_size + pattern_len - 1;

  /* No point in trying to allocate a buffer larger than the search space.  */
  if (search_space_len < search_buf_size)
    search_buf_size = search_space_len;

  search_buf = malloc (search_buf_size);
  if (search_buf == NULL)
    error (_("Unable to allocate memory to perform the search."));
  old_cleanups = make_cleanup (free_current_contents, &search_buf);

  /* Prime the search buffer.  */

  if (target_read (ops, TARGET_OBJECT_MEMORY, NULL,
		   search_buf, start_addr, search_buf_size) != search_buf_size)
    {
      warning (_("Unable to access %s bytes of target "
		 "memory at %s, halting search."),
	       pulongest (search_buf_size), hex_string (start_addr));
      do_cleanups (old_cleanups);
      return -1;
    }

  /* Perform the search.

     The loop is kept simple by allocating [N + pattern-length - 1] bytes.
     When we've scanned N bytes we copy the trailing bytes to the start and
     read in another N bytes.  */

  while (search_space_len >= pattern_len)
    {
      gdb_byte *found_ptr;
      unsigned nr_search_bytes = min (search_space_len, search_buf_size);

      found_ptr = memmem (search_buf, nr_search_bytes,
			  pattern, pattern_len);

      if (found_ptr != NULL)
	{
	  CORE_ADDR found_addr = start_addr + (found_ptr - search_buf);

	  *found_addrp = found_addr;
	  do_cleanups (old_cleanups);
	  return 1;
	}

      /* Not found in this chunk, skip to next chunk.  */

      /* Don't let search_space_len wrap here, it's unsigned.  */
      if (search_space_len >= chunk_size)
	search_space_len -= chunk_size;
      else
	search_space_len = 0;

      if (search_space_len >= pattern_len)
	{
	  unsigned keep_len = search_buf_size - chunk_size;
	  CORE_ADDR read_addr = start_addr + chunk_size + keep_len;
	  int nr_to_read;

	  /* Copy the trailing part of the previous iteration to the front
	     of the buffer for the next iteration.  */
	  gdb_assert (keep_len == pattern_len - 1);
	  memcpy (search_buf, search_buf + chunk_size, keep_len);

	  nr_to_read = min (search_space_len - keep_len, chunk_size);

	  if (target_read (ops, TARGET_OBJECT_MEMORY, NULL,
			   search_buf + keep_len, read_addr,
			   nr_to_read) != nr_to_read)
	    {
	      warning (_("Unable to access %s bytes of target "
			 "memory at %s, halting search."),
		       plongest (nr_to_read),
		       hex_string (read_addr));
	      do_cleanups (old_cleanups);
	      return -1;
	    }

	  start_addr += chunk_size;
	}
    }

  /* Not found.  */

  do_cleanups (old_cleanups);
  return 0;
}

/* Search SEARCH_SPACE_LEN bytes beginning at START_ADDR for the
   sequence of bytes in PATTERN with length PATTERN_LEN.

   The result is 1 if found, 0 if not found, and -1 if there was an error
   requiring halting of the search (e.g. memory read error).
   If the pattern is found the address is recorded in FOUND_ADDRP.  */

int
target_search_memory (CORE_ADDR start_addr, ULONGEST search_space_len,
		      const gdb_byte *pattern, ULONGEST pattern_len,
		      CORE_ADDR *found_addrp)
{
  struct target_ops *t;
  int found;

  /* We don't use INHERIT to set current_target.to_search_memory,
     so we have to scan the target stack and handle targetdebug
     ourselves.  */

  if (targetdebug)
    fprintf_unfiltered (gdb_stdlog, "target_search_memory (%s, ...)\n",
			hex_string (start_addr));

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_search_memory != NULL)
      break;

  if (t != NULL)
    {
      found = t->to_search_memory (t, start_addr, search_space_len,
				   pattern, pattern_len, found_addrp);
    }
  else
    {
      /* If a special version of to_search_memory isn't available, use the
	 simple version.  */
      found = simple_search_memory (current_target.beneath,
				    start_addr, search_space_len,
				    pattern, pattern_len, found_addrp);
    }

  if (targetdebug)
    fprintf_unfiltered (gdb_stdlog, "  = %d\n", found);

  return found;
}

/* Look through the currently pushed targets.  If none of them will
   be able to restart the currently running process, issue an error
   message.  */

void
target_require_runnable (void)
{
  struct target_ops *t;

  for (t = target_stack; t != NULL; t = t->beneath)
    {
      /* If this target knows how to create a new program, then
	 assume we will still be able to after killing the current
	 one.  Either killing and mourning will not pop T, or else
	 find_default_run_target will find it again.  */
      if (t->to_create_inferior != NULL)
	return;

      /* Do not worry about thread_stratum targets that can not
	 create inferiors.  Assume they will be pushed again if
	 necessary, and continue to the process_stratum.  */
      if (t->to_stratum == thread_stratum
	  || t->to_stratum == arch_stratum)
	continue;

      error (_("The \"%s\" target does not support \"run\".  "
	       "Try \"help target\" or \"continue\"."),
	     t->to_shortname);
    }

  /* This function is only called if the target is running.  In that
     case there should have been a process_stratum target and it
     should either know how to create inferiors, or not...  */
  internal_error (__FILE__, __LINE__, _("No targets found"));
}

/* Look through the list of possible targets for a target that can
   execute a run or attach command without any other data.  This is
   used to locate the default process stratum.

   If DO_MESG is not NULL, the result is always valid (error() is
   called for errors); else, return NULL on error.  */

static struct target_ops *
find_default_run_target (char *do_mesg)
{
  struct target_ops **t;
  struct target_ops *runable = NULL;
  int count;

  count = 0;

  for (t = target_structs; t < target_structs + target_struct_size;
       ++t)
    {
      if ((*t)->to_can_run && target_can_run (*t))
	{
	  runable = *t;
	  ++count;
	}
    }

  if (count != 1)
    {
      if (do_mesg)
	error (_("Don't know how to %s.  Try \"help target\"."), do_mesg);
      else
	return NULL;
    }

  return runable;
}

void
find_default_attach (struct target_ops *ops, char *args, int from_tty)
{
  struct target_ops *t;

  t = find_default_run_target ("attach");
  (t->to_attach) (t, args, from_tty);
  return;
}

void
find_default_create_inferior (struct target_ops *ops,
			      char *exec_file, char *allargs, char **env,
			      int from_tty)
{
  struct target_ops *t;

  t = find_default_run_target ("run");
  (t->to_create_inferior) (t, exec_file, allargs, env, from_tty);
  return;
}

static int
find_default_can_async_p (void)
{
  struct target_ops *t;

  /* This may be called before the target is pushed on the stack;
     look for the default process stratum.  If there's none, gdb isn't
     configured with a native debugger, and target remote isn't
     connected yet.  */
  t = find_default_run_target (NULL);
  if (t && t->to_can_async_p)
    return (t->to_can_async_p) ();
  return 0;
}

static int
find_default_is_async_p (void)
{
  struct target_ops *t;

  /* This may be called before the target is pushed on the stack;
     look for the default process stratum.  If there's none, gdb isn't
     configured with a native debugger, and target remote isn't
     connected yet.  */
  t = find_default_run_target (NULL);
  if (t && t->to_is_async_p)
    return (t->to_is_async_p) ();
  return 0;
}

static int
find_default_supports_non_stop (void)
{
  struct target_ops *t;

  t = find_default_run_target (NULL);
  if (t && t->to_supports_non_stop)
    return (t->to_supports_non_stop) ();
  return 0;
}

int
target_supports_non_stop (void)
{
  struct target_ops *t;

  for (t = &current_target; t != NULL; t = t->beneath)
    if (t->to_supports_non_stop)
      return t->to_supports_non_stop ();

  return 0;
}

/* Implement the "info proc" command.  */

int
target_info_proc (char *args, enum info_proc_what what)
{
  struct target_ops *t;

  /* If we're already connected to something that can get us OS
     related data, use it.  Otherwise, try using the native
     target.  */
  if (current_target.to_stratum >= process_stratum)
    t = current_target.beneath;
  else
    t = find_default_run_target (NULL);

  for (; t != NULL; t = t->beneath)
    {
      if (t->to_info_proc != NULL)
	{
	  t->to_info_proc (t, args, what);

	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog,
				"target_info_proc (\"%s\", %d)\n", args, what);

	  return 1;
	}
    }

  return 0;
}

static int
find_default_supports_disable_randomization (void)
{
  struct target_ops *t;

  t = find_default_run_target (NULL);
  if (t && t->to_supports_disable_randomization)
    return (t->to_supports_disable_randomization) ();
  return 0;
}

int
target_supports_disable_randomization (void)
{
  struct target_ops *t;

  for (t = &current_target; t != NULL; t = t->beneath)
    if (t->to_supports_disable_randomization)
      return t->to_supports_disable_randomization ();

  return 0;
}

char *
target_get_osdata (const char *type)
{
  struct target_ops *t;

  /* If we're already connected to something that can get us OS
     related data, use it.  Otherwise, try using the native
     target.  */
  if (current_target.to_stratum >= process_stratum)
    t = current_target.beneath;
  else
    t = find_default_run_target ("get OS data");

  if (!t)
    return NULL;

  return target_read_stralloc (t, TARGET_OBJECT_OSDATA, type);
}

/* Determine the current address space of thread PTID.  */

struct address_space *
target_thread_address_space (ptid_t ptid)
{
  struct address_space *aspace;
  struct inferior *inf;
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_thread_address_space != NULL)
	{
	  aspace = t->to_thread_address_space (t, ptid);
	  gdb_assert (aspace);

	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog,
				"target_thread_address_space (%s) = %d\n",
				target_pid_to_str (ptid),
				address_space_num (aspace));
	  return aspace;
	}
    }

  /* Fall-back to the "main" address space of the inferior.  */
  inf = find_inferior_pid (ptid_get_pid (ptid));

  if (inf == NULL || inf->aspace == NULL)
    internal_error (__FILE__, __LINE__,
		    _("Can't determine the current "
		      "address space of thread %s\n"),
		    target_pid_to_str (ptid));

  return inf->aspace;
}


/* Target file operations.  */

static struct target_ops *
default_fileio_target (void)
{
  /* If we're already connected to something that can perform
     file I/O, use it. Otherwise, try using the native target.  */
  if (current_target.to_stratum >= process_stratum)
    return current_target.beneath;
  else
    return find_default_run_target ("file I/O");
}

/* Open FILENAME on the target, using FLAGS and MODE.  Return a
   target file descriptor, or -1 if an error occurs (and set
   *TARGET_ERRNO).  */
int
target_fileio_open (const char *filename, int flags, int mode,
		    int *target_errno)
{
  struct target_ops *t;

  for (t = default_fileio_target (); t != NULL; t = t->beneath)
    {
      if (t->to_fileio_open != NULL)
	{
	  int fd = t->to_fileio_open (filename, flags, mode, target_errno);

	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog,
				"target_fileio_open (%s,0x%x,0%o) = %d (%d)\n",
				filename, flags, mode,
				fd, fd != -1 ? 0 : *target_errno);
	  return fd;
	}
    }

  *target_errno = FILEIO_ENOSYS;
  return -1;
}

/* Write up to LEN bytes from WRITE_BUF to FD on the target.
   Return the number of bytes written, or -1 if an error occurs
   (and set *TARGET_ERRNO).  */
int
target_fileio_pwrite (int fd, const gdb_byte *write_buf, int len,
		      ULONGEST offset, int *target_errno)
{
  struct target_ops *t;

  for (t = default_fileio_target (); t != NULL; t = t->beneath)
    {
      if (t->to_fileio_pwrite != NULL)
	{
	  int ret = t->to_fileio_pwrite (fd, write_buf, len, offset,
					 target_errno);

	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog,
				"target_fileio_pwrite (%d,...,%d,%s) "
				"= %d (%d)\n",
				fd, len, pulongest (offset),
				ret, ret != -1 ? 0 : *target_errno);
	  return ret;
	}
    }

  *target_errno = FILEIO_ENOSYS;
  return -1;
}

/* Read up to LEN bytes FD on the target into READ_BUF.
   Return the number of bytes read, or -1 if an error occurs
   (and set *TARGET_ERRNO).  */
int
target_fileio_pread (int fd, gdb_byte *read_buf, int len,
		     ULONGEST offset, int *target_errno)
{
  struct target_ops *t;

  for (t = default_fileio_target (); t != NULL; t = t->beneath)
    {
      if (t->to_fileio_pread != NULL)
	{
	  int ret = t->to_fileio_pread (fd, read_buf, len, offset,
					target_errno);

	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog,
				"target_fileio_pread (%d,...,%d,%s) "
				"= %d (%d)\n",
				fd, len, pulongest (offset),
				ret, ret != -1 ? 0 : *target_errno);
	  return ret;
	}
    }

  *target_errno = FILEIO_ENOSYS;
  return -1;
}

/* Close FD on the target.  Return 0, or -1 if an error occurs
   (and set *TARGET_ERRNO).  */
int
target_fileio_close (int fd, int *target_errno)
{
  struct target_ops *t;

  for (t = default_fileio_target (); t != NULL; t = t->beneath)
    {
      if (t->to_fileio_close != NULL)
	{
	  int ret = t->to_fileio_close (fd, target_errno);

	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog,
				"target_fileio_close (%d) = %d (%d)\n",
				fd, ret, ret != -1 ? 0 : *target_errno);
	  return ret;
	}
    }

  *target_errno = FILEIO_ENOSYS;
  return -1;
}

/* Unlink FILENAME on the target.  Return 0, or -1 if an error
   occurs (and set *TARGET_ERRNO).  */
int
target_fileio_unlink (const char *filename, int *target_errno)
{
  struct target_ops *t;

  for (t = default_fileio_target (); t != NULL; t = t->beneath)
    {
      if (t->to_fileio_unlink != NULL)
	{
	  int ret = t->to_fileio_unlink (filename, target_errno);

	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog,
				"target_fileio_unlink (%s) = %d (%d)\n",
				filename, ret, ret != -1 ? 0 : *target_errno);
	  return ret;
	}
    }

  *target_errno = FILEIO_ENOSYS;
  return -1;
}

/* Read value of symbolic link FILENAME on the target.  Return a
   null-terminated string allocated via xmalloc, or NULL if an error
   occurs (and set *TARGET_ERRNO).  */
char *
target_fileio_readlink (const char *filename, int *target_errno)
{
  struct target_ops *t;

  for (t = default_fileio_target (); t != NULL; t = t->beneath)
    {
      if (t->to_fileio_readlink != NULL)
	{
	  char *ret = t->to_fileio_readlink (filename, target_errno);

	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog,
				"target_fileio_readlink (%s) = %s (%d)\n",
				filename, ret? ret : "(nil)",
				ret? 0 : *target_errno);
	  return ret;
	}
    }

  *target_errno = FILEIO_ENOSYS;
  return NULL;
}

static void
target_fileio_close_cleanup (void *opaque)
{
  int fd = *(int *) opaque;
  int target_errno;

  target_fileio_close (fd, &target_errno);
}

/* Read target file FILENAME.  Store the result in *BUF_P and
   return the size of the transferred data.  PADDING additional bytes are
   available in *BUF_P.  This is a helper function for
   target_fileio_read_alloc; see the declaration of that function for more
   information.  */

static LONGEST
target_fileio_read_alloc_1 (const char *filename,
			    gdb_byte **buf_p, int padding)
{
  struct cleanup *close_cleanup;
  size_t buf_alloc, buf_pos;
  gdb_byte *buf;
  LONGEST n;
  int fd;
  int target_errno;

  fd = target_fileio_open (filename, FILEIO_O_RDONLY, 0700, &target_errno);
  if (fd == -1)
    return -1;

  close_cleanup = make_cleanup (target_fileio_close_cleanup, &fd);

  /* Start by reading up to 4K at a time.  The target will throttle
     this number down if necessary.  */
  buf_alloc = 4096;
  buf = xmalloc (buf_alloc);
  buf_pos = 0;
  while (1)
    {
      n = target_fileio_pread (fd, &buf[buf_pos],
			       buf_alloc - buf_pos - padding, buf_pos,
			       &target_errno);
      if (n < 0)
	{
	  /* An error occurred.  */
	  do_cleanups (close_cleanup);
	  xfree (buf);
	  return -1;
	}
      else if (n == 0)
	{
	  /* Read all there was.  */
	  do_cleanups (close_cleanup);
	  if (buf_pos == 0)
	    xfree (buf);
	  else
	    *buf_p = buf;
	  return buf_pos;
	}

      buf_pos += n;

      /* If the buffer is filling up, expand it.  */
      if (buf_alloc < buf_pos * 2)
	{
	  buf_alloc *= 2;
	  buf = xrealloc (buf, buf_alloc);
	}

      QUIT;
    }
}

/* Read target file FILENAME.  Store the result in *BUF_P and return
   the size of the transferred data.  See the declaration in "target.h"
   function for more information about the return value.  */

LONGEST
target_fileio_read_alloc (const char *filename, gdb_byte **buf_p)
{
  return target_fileio_read_alloc_1 (filename, buf_p, 0);
}

/* Read target file FILENAME.  The result is NUL-terminated and
   returned as a string, allocated using xmalloc.  If an error occurs
   or the transfer is unsupported, NULL is returned.  Empty objects
   are returned as allocated but empty strings.  A warning is issued
   if the result contains any embedded NUL bytes.  */

char *
target_fileio_read_stralloc (const char *filename)
{
  gdb_byte *buffer;
  char *bufstr;
  LONGEST i, transferred;

  transferred = target_fileio_read_alloc_1 (filename, &buffer, 1);
  bufstr = (char *) buffer;

  if (transferred < 0)
    return NULL;

  if (transferred == 0)
    return xstrdup ("");

  bufstr[transferred] = 0;

  /* Check for embedded NUL bytes; but allow trailing NULs.  */
  for (i = strlen (bufstr); i < transferred; i++)
    if (bufstr[i] != 0)
      {
	warning (_("target file %s "
		   "contained unexpected null characters"),
		 filename);
	break;
      }

  return bufstr;
}


static int
default_region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)
{
  return (len <= gdbarch_ptr_bit (target_gdbarch ()) / TARGET_CHAR_BIT);
}

static int
default_watchpoint_addr_within_range (struct target_ops *target,
				      CORE_ADDR addr,
				      CORE_ADDR start, int length)
{
  return addr >= start && addr < start + length;
}

static struct gdbarch *
default_thread_architecture (struct target_ops *ops, ptid_t ptid)
{
  return target_gdbarch ();
}

static int
return_zero (void)
{
  return 0;
}

static int
return_one (void)
{
  return 1;
}

static int
return_minus_one (void)
{
  return -1;
}

/*
 * Find the next target down the stack from the specified target.
 */

struct target_ops *
find_target_beneath (struct target_ops *t)
{
  return t->beneath;
}


/* The inferior process has died.  Long live the inferior!  */

void
generic_mourn_inferior (void)
{
  ptid_t ptid;

  ptid = inferior_ptid;
  inferior_ptid = null_ptid;

  /* Mark breakpoints uninserted in case something tries to delete a
     breakpoint while we delete the inferior's threads (which would
     fail, since the inferior is long gone).  */
  mark_breakpoints_out ();

  if (!ptid_equal (ptid, null_ptid))
    {
      int pid = ptid_get_pid (ptid);
      exit_inferior (pid);
    }

  /* Note this wipes step-resume breakpoints, so needs to be done
     after exit_inferior, which ends up referencing the step-resume
     breakpoints through clear_thread_inferior_resources.  */
  breakpoint_init_inferior (inf_exited);

  registers_changed ();

  reopen_exec_file ();
  reinit_frame_cache ();

  if (deprecated_detach_hook)
    deprecated_detach_hook ();
}

/* Convert a normal process ID to a string.  Returns the string in a
   static buffer.  */

char *
normal_pid_to_str (ptid_t ptid)
{
  static char buf[32];

  xsnprintf (buf, sizeof buf, "process %d", ptid_get_pid (ptid));
  return buf;
}

static char *
dummy_pid_to_str (struct target_ops *ops, ptid_t ptid)
{
  return normal_pid_to_str (ptid);
}

/* Error-catcher for target_find_memory_regions.  */
static int
dummy_find_memory_regions (find_memory_region_ftype ignore1, void *ignore2)
{
  error (_("Command not implemented for this target."));
  return 0;
}

/* Error-catcher for target_make_corefile_notes.  */
static char *
dummy_make_corefile_notes (bfd *ignore1, int *ignore2)
{
  error (_("Command not implemented for this target."));
  return NULL;
}

/* Error-catcher for target_get_bookmark.  */
static gdb_byte *
dummy_get_bookmark (char *ignore1, int ignore2)
{
  tcomplain ();
  return NULL;
}

/* Error-catcher for target_goto_bookmark.  */
static void
dummy_goto_bookmark (gdb_byte *ignore, int from_tty)
{
  tcomplain ();
}

/* Set up the handful of non-empty slots needed by the dummy target
   vector.  */

static void
init_dummy_target (void)
{
  dummy_target.to_shortname = "None";
  dummy_target.to_longname = "None";
  dummy_target.to_doc = "";
  dummy_target.to_attach = find_default_attach;
  dummy_target.to_detach = 
    (void (*)(struct target_ops *, char *, int))target_ignore;
  dummy_target.to_create_inferior = find_default_create_inferior;
  dummy_target.to_can_async_p = find_default_can_async_p;
  dummy_target.to_is_async_p = find_default_is_async_p;
  dummy_target.to_supports_non_stop = find_default_supports_non_stop;
  dummy_target.to_supports_disable_randomization
    = find_default_supports_disable_randomization;
  dummy_target.to_pid_to_str = dummy_pid_to_str;
  dummy_target.to_stratum = dummy_stratum;
  dummy_target.to_find_memory_regions = dummy_find_memory_regions;
  dummy_target.to_make_corefile_notes = dummy_make_corefile_notes;
  dummy_target.to_get_bookmark = dummy_get_bookmark;
  dummy_target.to_goto_bookmark = dummy_goto_bookmark;
  dummy_target.to_xfer_partial = default_xfer_partial;
  dummy_target.to_has_all_memory = (int (*) (struct target_ops *)) return_zero;
  dummy_target.to_has_memory = (int (*) (struct target_ops *)) return_zero;
  dummy_target.to_has_stack = (int (*) (struct target_ops *)) return_zero;
  dummy_target.to_has_registers = (int (*) (struct target_ops *)) return_zero;
  dummy_target.to_has_execution
    = (int (*) (struct target_ops *, ptid_t)) return_zero;
  dummy_target.to_stopped_by_watchpoint = return_zero;
  dummy_target.to_stopped_data_address =
    (int (*) (struct target_ops *, CORE_ADDR *)) return_zero;
  dummy_target.to_magic = OPS_MAGIC;
}

static void
debug_to_open (char *args, int from_tty)
{
  debug_target.to_open (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_open (%s, %d)\n", args, from_tty);
}

void
target_close (struct target_ops *targ)
{
  gdb_assert (!target_is_pushed (targ));

  if (targ->to_xclose != NULL)
    targ->to_xclose (targ);
  else if (targ->to_close != NULL)
    targ->to_close ();

  if (targetdebug)
    fprintf_unfiltered (gdb_stdlog, "target_close ()\n");
}

void
target_attach (char *args, int from_tty)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_attach != NULL)	
	{
	  t->to_attach (t, args, from_tty);
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "target_attach (%s, %d)\n",
				args, from_tty);
	  return;
	}
    }

  internal_error (__FILE__, __LINE__,
		  _("could not find a target to attach"));
}

int
target_thread_alive (ptid_t ptid)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_thread_alive != NULL)
	{
	  int retval;

	  retval = t->to_thread_alive (t, ptid);
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "target_thread_alive (%d) = %d\n",
				ptid_get_pid (ptid), retval);

	  return retval;
	}
    }

  return 0;
}

void
target_find_new_threads (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_find_new_threads != NULL)
	{
	  t->to_find_new_threads (t);
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "target_find_new_threads ()\n");

	  return;
	}
    }
}

void
target_stop (ptid_t ptid)
{
  if (!may_stop)
    {
      warning (_("May not interrupt or stop the target, ignoring attempt"));
      return;
    }

  (*current_target.to_stop) (ptid);
}

static void
debug_to_post_attach (int pid)
{
  debug_target.to_post_attach (pid);

  fprintf_unfiltered (gdb_stdlog, "target_post_attach (%d)\n", pid);
}

/* Concatenate ELEM to LIST, a comma separate list, and return the
   result.  The LIST incoming argument is released.  */

static char *
str_comma_list_concat_elem (char *list, const char *elem)
{
  if (list == NULL)
    return xstrdup (elem);
  else
    return reconcat (list, list, ", ", elem, (char *) NULL);
}

/* Helper for target_options_to_string.  If OPT is present in
   TARGET_OPTIONS, append the OPT_STR (string version of OPT) in RET.
   Returns the new resulting string.  OPT is removed from
   TARGET_OPTIONS.  */

static char *
do_option (int *target_options, char *ret,
	   int opt, char *opt_str)
{
  if ((*target_options & opt) != 0)
    {
      ret = str_comma_list_concat_elem (ret, opt_str);
      *target_options &= ~opt;
    }

  return ret;
}

char *
target_options_to_string (int target_options)
{
  char *ret = NULL;

#define DO_TARG_OPTION(OPT) \
  ret = do_option (&target_options, ret, OPT, #OPT)

  DO_TARG_OPTION (TARGET_WNOHANG);

  if (target_options != 0)
    ret = str_comma_list_concat_elem (ret, "unknown???");

  if (ret == NULL)
    ret = xstrdup ("");
  return ret;
}

static void
debug_print_register (const char * func,
		      struct regcache *regcache, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);

  fprintf_unfiltered (gdb_stdlog, "%s ", func);
  if (regno >= 0 && regno < gdbarch_num_regs (gdbarch)
      && gdbarch_register_name (gdbarch, regno) != NULL
      && gdbarch_register_name (gdbarch, regno)[0] != '\0')
    fprintf_unfiltered (gdb_stdlog, "(%s)",
			gdbarch_register_name (gdbarch, regno));
  else
    fprintf_unfiltered (gdb_stdlog, "(%d)", regno);
  if (regno >= 0 && regno < gdbarch_num_regs (gdbarch))
    {
      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
      int i, size = register_size (gdbarch, regno);
      gdb_byte buf[MAX_REGISTER_SIZE];

      regcache_raw_collect (regcache, regno, buf);
      fprintf_unfiltered (gdb_stdlog, " = ");
      for (i = 0; i < size; i++)
	{
	  fprintf_unfiltered (gdb_stdlog, "%02x", buf[i]);
	}
      if (size <= sizeof (LONGEST))
	{
	  ULONGEST val = extract_unsigned_integer (buf, size, byte_order);

	  fprintf_unfiltered (gdb_stdlog, " %s %s",
			      core_addr_to_string_nz (val), plongest (val));
	}
    }
  fprintf_unfiltered (gdb_stdlog, "\n");
}

void
target_fetch_registers (struct regcache *regcache, int regno)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_fetch_registers != NULL)
	{
	  t->to_fetch_registers (t, regcache, regno);
	  if (targetdebug)
	    debug_print_register ("target_fetch_registers", regcache, regno);
	  return;
	}
    }
}

void
target_store_registers (struct regcache *regcache, int regno)
{
  struct target_ops *t;

  if (!may_write_registers)
    error (_("Writing to registers is not allowed (regno %d)"), regno);

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_store_registers != NULL)
	{
	  t->to_store_registers (t, regcache, regno);
	  if (targetdebug)
	    {
	      debug_print_register ("target_store_registers", regcache, regno);
	    }
	  return;
	}
    }

  noprocess ();
}

int
target_core_of_thread (ptid_t ptid)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_core_of_thread != NULL)
	{
	  int retval = t->to_core_of_thread (t, ptid);

	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog,
				"target_core_of_thread (%d) = %d\n",
				ptid_get_pid (ptid), retval);
	  return retval;
	}
    }

  return -1;
}

int
target_verify_memory (const gdb_byte *data, CORE_ADDR memaddr, ULONGEST size)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_verify_memory != NULL)
	{
	  int retval = t->to_verify_memory (t, data, memaddr, size);

	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog,
				"target_verify_memory (%s, %s) = %d\n",
				paddress (target_gdbarch (), memaddr),
				pulongest (size),
				retval);
	  return retval;
	}
    }

  tcomplain ();
}

/* The documentation for this function is in its prototype declaration in
   target.h.  */

int
target_insert_mask_watchpoint (CORE_ADDR addr, CORE_ADDR mask, int rw)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_insert_mask_watchpoint != NULL)
      {
	int ret;

	ret = t->to_insert_mask_watchpoint (t, addr, mask, rw);

	if (targetdebug)
	  fprintf_unfiltered (gdb_stdlog, "\
target_insert_mask_watchpoint (%s, %s, %d) = %d\n",
			      core_addr_to_string (addr),
			      core_addr_to_string (mask), rw, ret);

	return ret;
      }

  return 1;
}

/* The documentation for this function is in its prototype declaration in
   target.h.  */

int
target_remove_mask_watchpoint (CORE_ADDR addr, CORE_ADDR mask, int rw)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_remove_mask_watchpoint != NULL)
      {
	int ret;

	ret = t->to_remove_mask_watchpoint (t, addr, mask, rw);

	if (targetdebug)
	  fprintf_unfiltered (gdb_stdlog, "\
target_remove_mask_watchpoint (%s, %s, %d) = %d\n",
			      core_addr_to_string (addr),
			      core_addr_to_string (mask), rw, ret);

	return ret;
      }

  return 1;
}

/* The documentation for this function is in its prototype declaration
   in target.h.  */

int
target_masked_watch_num_registers (CORE_ADDR addr, CORE_ADDR mask)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_masked_watch_num_registers != NULL)
      return t->to_masked_watch_num_registers (t, addr, mask);

  return -1;
}

/* The documentation for this function is in its prototype declaration
   in target.h.  */

int
target_ranged_break_num_registers (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_ranged_break_num_registers != NULL)
      return t->to_ranged_break_num_registers (t);

  return -1;
}

/* See target.h.  */

int
target_supports_btrace (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_supports_btrace != NULL)
      return t->to_supports_btrace ();

  return 0;
}

/* See target.h.  */

struct btrace_target_info *
target_enable_btrace (ptid_t ptid)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_enable_btrace != NULL)
      return t->to_enable_btrace (ptid);

  tcomplain ();
  return NULL;
}

/* See target.h.  */

void
target_disable_btrace (struct btrace_target_info *btinfo)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_disable_btrace != NULL)
      {
	t->to_disable_btrace (btinfo);
	return;
      }

  tcomplain ();
}

/* See target.h.  */

void
target_teardown_btrace (struct btrace_target_info *btinfo)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_teardown_btrace != NULL)
      {
	t->to_teardown_btrace (btinfo);
	return;
      }

  tcomplain ();
}

/* See target.h.  */

VEC (btrace_block_s) *
target_read_btrace (struct btrace_target_info *btinfo,
		    enum btrace_read_type type)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_read_btrace != NULL)
      return t->to_read_btrace (btinfo, type);

  tcomplain ();
  return NULL;
}

/* See target.h.  */

void
target_stop_recording (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_stop_recording != NULL)
      {
	t->to_stop_recording ();
	return;
      }

  /* This is optional.  */
}

/* See target.h.  */

void
target_info_record (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_info_record != NULL)
      {
	t->to_info_record ();
	return;
      }

  tcomplain ();
}

/* See target.h.  */

void
target_save_record (const char *filename)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_save_record != NULL)
      {
	t->to_save_record (filename);
	return;
      }

  tcomplain ();
}

/* See target.h.  */

int
target_supports_delete_record (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_delete_record != NULL)
      return 1;

  return 0;
}

/* See target.h.  */

void
target_delete_record (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_delete_record != NULL)
      {
	t->to_delete_record ();
	return;
      }

  tcomplain ();
}

/* See target.h.  */

int
target_record_is_replaying (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_record_is_replaying != NULL)
	return t->to_record_is_replaying ();

  return 0;
}

/* See target.h.  */

void
target_goto_record_begin (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_goto_record_begin != NULL)
      {
	t->to_goto_record_begin ();
	return;
      }

  tcomplain ();
}

/* See target.h.  */

void
target_goto_record_end (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_goto_record_end != NULL)
      {
	t->to_goto_record_end ();
	return;
      }

  tcomplain ();
}

/* See target.h.  */

void
target_goto_record (ULONGEST insn)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_goto_record != NULL)
      {
	t->to_goto_record (insn);
	return;
      }

  tcomplain ();
}

/* See target.h.  */

void
target_insn_history (int size, int flags)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_insn_history != NULL)
      {
	t->to_insn_history (size, flags);
	return;
      }

  tcomplain ();
}

/* See target.h.  */

void
target_insn_history_from (ULONGEST from, int size, int flags)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_insn_history_from != NULL)
      {
	t->to_insn_history_from (from, size, flags);
	return;
      }

  tcomplain ();
}

/* See target.h.  */

void
target_insn_history_range (ULONGEST begin, ULONGEST end, int flags)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_insn_history_range != NULL)
      {
	t->to_insn_history_range (begin, end, flags);
	return;
      }

  tcomplain ();
}

/* See target.h.  */

void
target_call_history (int size, int flags)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_call_history != NULL)
      {
	t->to_call_history (size, flags);
	return;
      }

  tcomplain ();
}

/* See target.h.  */

void
target_call_history_from (ULONGEST begin, int size, int flags)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_call_history_from != NULL)
      {
	t->to_call_history_from (begin, size, flags);
	return;
      }

  tcomplain ();
}

/* See target.h.  */

void
target_call_history_range (ULONGEST begin, ULONGEST end, int flags)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_call_history_range != NULL)
      {
	t->to_call_history_range (begin, end, flags);
	return;
      }

  tcomplain ();
}

static void
debug_to_prepare_to_store (struct regcache *regcache)
{
  debug_target.to_prepare_to_store (regcache);

  fprintf_unfiltered (gdb_stdlog, "target_prepare_to_store ()\n");
}

static int
deprecated_debug_xfer_memory (CORE_ADDR memaddr, bfd_byte *myaddr, int len,
			      int write, struct mem_attrib *attrib,
			      struct target_ops *target)
{
  int retval;

  retval = debug_target.deprecated_xfer_memory (memaddr, myaddr, len, write,
						attrib, target);

  fprintf_unfiltered (gdb_stdlog,
		      "target_xfer_memory (%s, xxx, %d, %s, xxx) = %d",
		      paddress (target_gdbarch (), memaddr), len,
		      write ? "write" : "read", retval);

  if (retval > 0)
    {
      int i;

      fputs_unfiltered (", bytes =", gdb_stdlog);
      for (i = 0; i < retval; i++)
	{
	  if ((((intptr_t) &(myaddr[i])) & 0xf) == 0)
	    {
	      if (targetdebug < 2 && i > 0)
		{
		  fprintf_unfiltered (gdb_stdlog, " ...");
		  break;
		}
	      fprintf_unfiltered (gdb_stdlog, "\n");
	    }

	  fprintf_unfiltered (gdb_stdlog, " %02x", myaddr[i] & 0xff);
	}
    }

  fputc_unfiltered ('\n', gdb_stdlog);

  return retval;
}

static void
debug_to_files_info (struct target_ops *target)
{
  debug_target.to_files_info (target);

  fprintf_unfiltered (gdb_stdlog, "target_files_info (xxx)\n");
}

static int
debug_to_insert_breakpoint (struct gdbarch *gdbarch,
			    struct bp_target_info *bp_tgt)
{
  int retval;

  retval = debug_target.to_insert_breakpoint (gdbarch, bp_tgt);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_breakpoint (%s, xxx) = %ld\n",
		      core_addr_to_string (bp_tgt->placed_address),
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_remove_breakpoint (struct gdbarch *gdbarch,
			    struct bp_target_info *bp_tgt)
{
  int retval;

  retval = debug_target.to_remove_breakpoint (gdbarch, bp_tgt);

  fprintf_unfiltered (gdb_stdlog,
		      "target_remove_breakpoint (%s, xxx) = %ld\n",
		      core_addr_to_string (bp_tgt->placed_address),
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_can_use_hw_breakpoint (int type, int cnt, int from_tty)
{
  int retval;

  retval = debug_target.to_can_use_hw_breakpoint (type, cnt, from_tty);

  fprintf_unfiltered (gdb_stdlog,
		      "target_can_use_hw_breakpoint (%ld, %ld, %ld) = %ld\n",
		      (unsigned long) type,
		      (unsigned long) cnt,
		      (unsigned long) from_tty,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)
{
  CORE_ADDR retval;

  retval = debug_target.to_region_ok_for_hw_watchpoint (addr, len);

  fprintf_unfiltered (gdb_stdlog,
		      "target_region_ok_for_hw_watchpoint (%s, %ld) = %s\n",
		      core_addr_to_string (addr), (unsigned long) len,
		      core_addr_to_string (retval));
  return retval;
}

static int
debug_to_can_accel_watchpoint_condition (CORE_ADDR addr, int len, int rw,
					 struct expression *cond)
{
  int retval;

  retval = debug_target.to_can_accel_watchpoint_condition (addr, len,
							   rw, cond);

  fprintf_unfiltered (gdb_stdlog,
		      "target_can_accel_watchpoint_condition "
		      "(%s, %d, %d, %s) = %ld\n",
		      core_addr_to_string (addr), len, rw,
		      host_address_to_string (cond), (unsigned long) retval);
  return retval;
}

static int
debug_to_stopped_by_watchpoint (void)
{
  int retval;

  retval = debug_target.to_stopped_by_watchpoint ();

  fprintf_unfiltered (gdb_stdlog,
		      "target_stopped_by_watchpoint () = %ld\n",
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_stopped_data_address (struct target_ops *target, CORE_ADDR *addr)
{
  int retval;

  retval = debug_target.to_stopped_data_address (target, addr);

  fprintf_unfiltered (gdb_stdlog,
		      "target_stopped_data_address ([%s]) = %ld\n",
		      core_addr_to_string (*addr),
		      (unsigned long)retval);
  return retval;
}

static int
debug_to_watchpoint_addr_within_range (struct target_ops *target,
				       CORE_ADDR addr,
				       CORE_ADDR start, int length)
{
  int retval;

  retval = debug_target.to_watchpoint_addr_within_range (target, addr,
							 start, length);

  fprintf_filtered (gdb_stdlog,
		    "target_watchpoint_addr_within_range (%s, %s, %d) = %d\n",
		    core_addr_to_string (addr), core_addr_to_string (start),
		    length, retval);
  return retval;
}

static int
debug_to_insert_hw_breakpoint (struct gdbarch *gdbarch,
			       struct bp_target_info *bp_tgt)
{
  int retval;

  retval = debug_target.to_insert_hw_breakpoint (gdbarch, bp_tgt);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_hw_breakpoint (%s, xxx) = %ld\n",
		      core_addr_to_string (bp_tgt->placed_address),
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_remove_hw_breakpoint (struct gdbarch *gdbarch,
			       struct bp_target_info *bp_tgt)
{
  int retval;

  retval = debug_target.to_remove_hw_breakpoint (gdbarch, bp_tgt);

  fprintf_unfiltered (gdb_stdlog,
		      "target_remove_hw_breakpoint (%s, xxx) = %ld\n",
		      core_addr_to_string (bp_tgt->placed_address),
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_insert_watchpoint (CORE_ADDR addr, int len, int type,
			    struct expression *cond)
{
  int retval;

  retval = debug_target.to_insert_watchpoint (addr, len, type, cond);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_watchpoint (%s, %d, %d, %s) = %ld\n",
		      core_addr_to_string (addr), len, type,
		      host_address_to_string (cond), (unsigned long) retval);
  return retval;
}

static int
debug_to_remove_watchpoint (CORE_ADDR addr, int len, int type,
			    struct expression *cond)
{
  int retval;

  retval = debug_target.to_remove_watchpoint (addr, len, type, cond);

  fprintf_unfiltered (gdb_stdlog,
		      "target_remove_watchpoint (%s, %d, %d, %s) = %ld\n",
		      core_addr_to_string (addr), len, type,
		      host_address_to_string (cond), (unsigned long) retval);
  return retval;
}

static void
debug_to_terminal_init (void)
{
  debug_target.to_terminal_init ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_init ()\n");
}

static void
debug_to_terminal_inferior (void)
{
  debug_target.to_terminal_inferior ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_inferior ()\n");
}

static void
debug_to_terminal_ours_for_output (void)
{
  debug_target.to_terminal_ours_for_output ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_ours_for_output ()\n");
}

static void
debug_to_terminal_ours (void)
{
  debug_target.to_terminal_ours ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_ours ()\n");
}

static void
debug_to_terminal_save_ours (void)
{
  debug_target.to_terminal_save_ours ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_save_ours ()\n");
}

static void
debug_to_terminal_info (const char *arg, int from_tty)
{
  debug_target.to_terminal_info (arg, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_terminal_info (%s, %d)\n", arg,
		      from_tty);
}

static void
debug_to_load (char *args, int from_tty)
{
  debug_target.to_load (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_load (%s, %d)\n", args, from_tty);
}

static void
debug_to_post_startup_inferior (ptid_t ptid)
{
  debug_target.to_post_startup_inferior (ptid);

  fprintf_unfiltered (gdb_stdlog, "target_post_startup_inferior (%d)\n",
		      ptid_get_pid (ptid));
}

static int
debug_to_insert_fork_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_insert_fork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_insert_fork_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_remove_fork_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_remove_fork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_remove_fork_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_insert_vfork_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_insert_vfork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_insert_vfork_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_remove_vfork_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_remove_vfork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_remove_vfork_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_insert_exec_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_insert_exec_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_insert_exec_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_remove_exec_catchpoint (int pid)
{
  int retval;

  retval = debug_target.to_remove_exec_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_remove_exec_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
}

static int
debug_to_has_exited (int pid, int wait_status, int *exit_status)
{
  int has_exited;

  has_exited = debug_target.to_has_exited (pid, wait_status, exit_status);

  fprintf_unfiltered (gdb_stdlog, "target_has_exited (%d, %d, %d) = %d\n",
		      pid, wait_status, *exit_status, has_exited);

  return has_exited;
}

static int
debug_to_can_run (void)
{
  int retval;

  retval = debug_target.to_can_run ();

  fprintf_unfiltered (gdb_stdlog, "target_can_run () = %d\n", retval);

  return retval;
}

static struct gdbarch *
debug_to_thread_architecture (struct target_ops *ops, ptid_t ptid)
{
  struct gdbarch *retval;

  retval = debug_target.to_thread_architecture (ops, ptid);

  fprintf_unfiltered (gdb_stdlog, 
		      "target_thread_architecture (%s) = %s [%s]\n",
		      target_pid_to_str (ptid),
		      host_address_to_string (retval),
		      gdbarch_bfd_arch_info (retval)->printable_name);
  return retval;
}

static void
debug_to_stop (ptid_t ptid)
{
  debug_target.to_stop (ptid);

  fprintf_unfiltered (gdb_stdlog, "target_stop (%s)\n",
		      target_pid_to_str (ptid));
}

static void
debug_to_rcmd (char *command,
	       struct ui_file *outbuf)
{
  debug_target.to_rcmd (command, outbuf);
  fprintf_unfiltered (gdb_stdlog, "target_rcmd (%s, ...)\n", command);
}

static char *
debug_to_pid_to_exec_file (int pid)
{
  char *exec_file;

  exec_file = debug_target.to_pid_to_exec_file (pid);

  fprintf_unfiltered (gdb_stdlog, "target_pid_to_exec_file (%d) = %s\n",
		      pid, exec_file);

  return exec_file;
}

static void
setup_target_debug (void)
{
  memcpy (&debug_target, &current_target, sizeof debug_target);

  current_target.to_open = debug_to_open;
  current_target.to_post_attach = debug_to_post_attach;
  current_target.to_prepare_to_store = debug_to_prepare_to_store;
  current_target.deprecated_xfer_memory = deprecated_debug_xfer_memory;
  current_target.to_files_info = debug_to_files_info;
  current_target.to_insert_breakpoint = debug_to_insert_breakpoint;
  current_target.to_remove_breakpoint = debug_to_remove_breakpoint;
  current_target.to_can_use_hw_breakpoint = debug_to_can_use_hw_breakpoint;
  current_target.to_insert_hw_breakpoint = debug_to_insert_hw_breakpoint;
  current_target.to_remove_hw_breakpoint = debug_to_remove_hw_breakpoint;
  current_target.to_insert_watchpoint = debug_to_insert_watchpoint;
  current_target.to_remove_watchpoint = debug_to_remove_watchpoint;
  current_target.to_stopped_by_watchpoint = debug_to_stopped_by_watchpoint;
  current_target.to_stopped_data_address = debug_to_stopped_data_address;
  current_target.to_watchpoint_addr_within_range
    = debug_to_watchpoint_addr_within_range;
  current_target.to_region_ok_for_hw_watchpoint
    = debug_to_region_ok_for_hw_watchpoint;
  current_target.to_can_accel_watchpoint_condition
    = debug_to_can_accel_watchpoint_condition;
  current_target.to_terminal_init = debug_to_terminal_init;
  current_target.to_terminal_inferior = debug_to_terminal_inferior;
  current_target.to_terminal_ours_for_output
    = debug_to_terminal_ours_for_output;
  current_target.to_terminal_ours = debug_to_terminal_ours;
  current_target.to_terminal_save_ours = debug_to_terminal_save_ours;
  current_target.to_terminal_info = debug_to_terminal_info;
  current_target.to_load = debug_to_load;
  current_target.to_post_startup_inferior = debug_to_post_startup_inferior;
  current_target.to_insert_fork_catchpoint = debug_to_insert_fork_catchpoint;
  current_target.to_remove_fork_catchpoint = debug_to_remove_fork_catchpoint;
  current_target.to_insert_vfork_catchpoint = debug_to_insert_vfork_catchpoint;
  current_target.to_remove_vfork_catchpoint = debug_to_remove_vfork_catchpoint;
  current_target.to_insert_exec_catchpoint = debug_to_insert_exec_catchpoint;
  current_target.to_remove_exec_catchpoint = debug_to_remove_exec_catchpoint;
  current_target.to_has_exited = debug_to_has_exited;
  current_target.to_can_run = debug_to_can_run;
  current_target.to_stop = debug_to_stop;
  current_target.to_rcmd = debug_to_rcmd;
  current_target.to_pid_to_exec_file = debug_to_pid_to_exec_file;
  current_target.to_thread_architecture = debug_to_thread_architecture;
}


static char targ_desc[] =
"Names of targets and files being debugged.\nShows the entire \
stack of targets currently in use (including the exec-file,\n\
core-file, and process, if any), as well as the symbol file name.";

static void
do_monitor_command (char *cmd,
		 int from_tty)
{
  if ((current_target.to_rcmd
       == (void (*) (char *, struct ui_file *)) tcomplain)
      || (current_target.to_rcmd == debug_to_rcmd
	  && (debug_target.to_rcmd
	      == (void (*) (char *, struct ui_file *)) tcomplain)))
    error (_("\"monitor\" command not supported by this target."));
  target_rcmd (cmd, gdb_stdtarg);
}

/* Print the name of each layers of our target stack.  */

static void
maintenance_print_target_stack (char *cmd, int from_tty)
{
  struct target_ops *t;

  printf_filtered (_("The current target stack is:\n"));

  for (t = target_stack; t != NULL; t = t->beneath)
    {
      printf_filtered ("  - %s (%s)\n", t->to_shortname, t->to_longname);
    }
}

/* Controls if async mode is permitted.  */
int target_async_permitted = 0;

/* The set command writes to this variable.  If the inferior is
   executing, target_async_permitted is *not* updated.  */
static int target_async_permitted_1 = 0;

static void
set_target_async_command (char *args, int from_tty,
			  struct cmd_list_element *c)
{
  if (have_live_inferiors ())
    {
      target_async_permitted_1 = target_async_permitted;
      error (_("Cannot change this setting while the inferior is running."));
    }

  target_async_permitted = target_async_permitted_1;
}

static void
show_target_async_command (struct ui_file *file, int from_tty,
			   struct cmd_list_element *c,
			   const char *value)
{
  fprintf_filtered (file,
		    _("Controlling the inferior in "
		      "asynchronous mode is %s.\n"), value);
}

/* Temporary copies of permission settings.  */

static int may_write_registers_1 = 1;
static int may_write_memory_1 = 1;
static int may_insert_breakpoints_1 = 1;
static int may_insert_tracepoints_1 = 1;
static int may_insert_fast_tracepoints_1 = 1;
static int may_stop_1 = 1;

/* Make the user-set values match the real values again.  */

void
update_target_permissions (void)
{
  may_write_registers_1 = may_write_registers;
  may_write_memory_1 = may_write_memory;
  may_insert_breakpoints_1 = may_insert_breakpoints;
  may_insert_tracepoints_1 = may_insert_tracepoints;
  may_insert_fast_tracepoints_1 = may_insert_fast_tracepoints;
  may_stop_1 = may_stop;
}

/* The one function handles (most of) the permission flags in the same
   way.  */

static void
set_target_permissions (char *args, int from_tty,
			struct cmd_list_element *c)
{
  if (target_has_execution)
    {
      update_target_permissions ();
      error (_("Cannot change this setting while the inferior is running."));
    }

  /* Make the real values match the user-changed values.  */
  may_write_registers = may_write_registers_1;
  may_insert_breakpoints = may_insert_breakpoints_1;
  may_insert_tracepoints = may_insert_tracepoints_1;
  may_insert_fast_tracepoints = may_insert_fast_tracepoints_1;
  may_stop = may_stop_1;
  update_observer_mode ();
}

/* Set memory write permission independently of observer mode.  */

static void
set_write_memory_permission (char *args, int from_tty,
			struct cmd_list_element *c)
{
  /* Make the real values match the user-changed values.  */
  may_write_memory = may_write_memory_1;
  update_observer_mode ();
}


void
initialize_targets (void)
{
  init_dummy_target ();
  push_target (&dummy_target);

  add_info ("target", target_info, targ_desc);
  add_info ("files", target_info, targ_desc);

  add_setshow_zuinteger_cmd ("target", class_maintenance, &targetdebug, _("\
Set target debugging."), _("\
Show target debugging."), _("\
When non-zero, target debugging is enabled.  Higher numbers are more\n\
verbose.  Changes do not take effect until the next \"run\" or \"target\"\n\
command."),
			     NULL,
			     show_targetdebug,
			     &setdebuglist, &showdebuglist);

  add_setshow_boolean_cmd ("trust-readonly-sections", class_support,
			   &trust_readonly, _("\
Set mode for reading from readonly sections."), _("\
Show mode for reading from readonly sections."), _("\
When this mode is on, memory reads from readonly sections (such as .text)\n\
will be read from the object file instead of from the target.  This will\n\
result in significant performance improvement for remote targets."),
			   NULL,
			   show_trust_readonly,
			   &setlist, &showlist);

  add_com ("monitor", class_obscure, do_monitor_command,
	   _("Send a command to the remote monitor (remote targets only)."));

  add_cmd ("target-stack", class_maintenance, maintenance_print_target_stack,
           _("Print the name of each layer of the internal target stack."),
           &maintenanceprintlist);

  add_setshow_boolean_cmd ("target-async", no_class,
			   &target_async_permitted_1, _("\
Set whether gdb controls the inferior in asynchronous mode."), _("\
Show whether gdb controls the inferior in asynchronous mode."), _("\
Tells gdb whether to control the inferior in asynchronous mode."),
			   set_target_async_command,
			   show_target_async_command,
			   &setlist,
			   &showlist);

  add_setshow_boolean_cmd ("stack-cache", class_support,
			   &stack_cache_enabled_p_1, _("\
Set cache use for stack access."), _("\
Show cache use for stack access."), _("\
When on, use the data cache for all stack access, regardless of any\n\
configured memory regions.  This improves remote performance significantly.\n\
By default, caching for stack access is on."),
			   set_stack_cache_enabled_p,
			   show_stack_cache_enabled_p,
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("may-write-registers", class_support,
			   &may_write_registers_1, _("\
Set permission to write into registers."), _("\
Show permission to write into registers."), _("\
When this permission is on, GDB may write into the target's registers.\n\
Otherwise, any sort of write attempt will result in an error."),
			   set_target_permissions, NULL,
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("may-write-memory", class_support,
			   &may_write_memory_1, _("\
Set permission to write into target memory."), _("\
Show permission to write into target memory."), _("\
When this permission is on, GDB may write into the target's memory.\n\
Otherwise, any sort of write attempt will result in an error."),
			   set_write_memory_permission, NULL,
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("may-insert-breakpoints", class_support,
			   &may_insert_breakpoints_1, _("\
Set permission to insert breakpoints in the target."), _("\
Show permission to insert breakpoints in the target."), _("\
When this permission is on, GDB may insert breakpoints in the program.\n\
Otherwise, any sort of insertion attempt will result in an error."),
			   set_target_permissions, NULL,
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("may-insert-tracepoints", class_support,
			   &may_insert_tracepoints_1, _("\
Set permission to insert tracepoints in the target."), _("\
Show permission to insert tracepoints in the target."), _("\
When this permission is on, GDB may insert tracepoints in the program.\n\
Otherwise, any sort of insertion attempt will result in an error."),
			   set_target_permissions, NULL,
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("may-insert-fast-tracepoints", class_support,
			   &may_insert_fast_tracepoints_1, _("\
Set permission to insert fast tracepoints in the target."), _("\
Show permission to insert fast tracepoints in the target."), _("\
When this permission is on, GDB may insert fast tracepoints.\n\
Otherwise, any sort of insertion attempt will result in an error."),
			   set_target_permissions, NULL,
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("may-interrupt", class_support,
			   &may_stop_1, _("\
Set permission to interrupt or signal the target."), _("\
Show permission to interrupt or signal the target."), _("\
When this permission is on, GDB may interrupt/stop the target's execution.\n\
Otherwise, any attempt to interrupt or stop will be ignored."),
			   set_target_permissions, NULL,
			   &setlist, &showlist);


  target_dcache = dcache_init ();
}
@


1.350
log
@Stop using errno values around target_xfer interfaces and memory errors.

target_read_memory & friends build on top of target_read (thus on top
of the target_xfer machinery), but turn all errors to EIO, an errno
value.  I think we'd better convert all these to return a
target_xfer_error too, like target_xfer_partial in a previous patch.
The patch starts by doing that.

(The patch does not add a enum target_xfer_error value for '0'/no
error, and likewise does not change the return type of several of
these functions to enum target_xfer_error, because different functions
return '0' with different semantics.)

I audited the tree for memory_error calls, EIO checks, places where
GDB hardcodes 'errno = EIO', and also for strerror calls.  What I
found is that nowadays there's really no need to handle random errno
values, other than the EIOs gdb itself hardcodes.  No doubt errno
values would appear in common code back in the day when
target_xfer_memory was the main interface to access memory, but
nowadays, any errno value that deprecated interface could return is
just absorved by default_xfer_partial:

      else if (xfered == 0 && errno == 0)
	/* "deprecated_xfer_memory" uses 0, cross checked against
           ERRNO as one indication of an error.  */
	return 0;
      else
	return -1;

There are two places in the code that check for EIO and print "out of
bounds", and defer to strerror for other errors.  That's
c-lang.c:c_get_string, and valprint.c.:val_print_string.  AFAICT, the
strerror branch can never be reached nowadays, as the only error
possible to get at those points is EIO, given that it's GDB itself
that set that errno value (in target_read_memory, etc.).

breakpoint.c:insert_bp_location always prints the error val as if an
errno, returned by target_insert_breakpoint, with strerr.  Now the
error here is either always EIO for mem-break.c targets (again
hardcoded by the target_read_memory/target_write_memory functions), so
this always prints "Input/output error" or similar (depending on
host), or, for remote targets (and probably others), this gem:

  Error accessing memory address 0x80200400: Unknown error -1.

This patch makes these 3 places print the exact same error
memory_error prints.  This changes output, but I think this is better,
for making memory error output consistent with other commands, and, it
means we have a central place to tweak for memory errors.

E.g., this changes:

 Cannot insert breakpoint 1.
 Error accessing memory address 0x5fc660: Input/output error.

to:

 Cannot insert breakpoint 1.
 Cannot access memory at address 0x5fc660

Which I find pretty much acceptable.

Surprisingly, only py-prettyprint.exp had a regression, for needing an
adjustment.  I also grepped the testsuite for the old errors, and
found no other hits.

Now that errno values aren't used anywhere in any of these memory
access related routines, I made memory_error itself take a
target_xfer_error instead of an errno.  The new
target_xfer_memory_error function added recently is no longer
necessary, and is thus removed.

Tested on x86_64 Fedora 17, native and gdbserver.

gdb/
2013-10-09  Pedro Alves  <palves@@redhat.com>

	* breakpoint.c (insert_bp_location): Use memory_error_message to
	build the memory error string.
	* c-lang.c: Include "gdbcore.h".
	(c_get_string): Use memory_error to throw error.
	(target_xfer_memory_error): Delete.
	(memory_error_message): New, factored out from
	target_xfer_memory_error.
	(memory_error): Change parameter type to target_xfer_error.
	Rewrite.
	(read_memory): Use memory_error instead of
	target_xfer_memory_error.
	* gdbcore.h: Include "target.h".
	(memory_error): Change parameter type to target_xfer_error.
	(memory_error_message): Declare function.
	* target.c (target_read_memory, target_read_stack)
	(target_write_memory, target_write_raw_memory): Return
	TARGET_XFER_E_IO on error.  Adjust comments.
	(get_target_memory): Pass TARGET_XFER_E_IO to memory_error,
	instead of EIO.
	* target.h (target_read, target_insert_breakpoint)
	(target_remove_breakpoint): Adjust comments.
	* valprint.c (partial_memory_read): Rename parameter, and adjust
	comment.
	(val_print_string): Use memory_error_message to build the memory
	error string.

gdb/testsuite/
2013-10-09  Pedro Alves  <palves@@redhat.com>

	* gdb.python/py-prettyprint.exp (run_lang_tests): Adjust expected
	output.
@
text
@d4168 4
a4171 1
      return t->to_disable_btrace (btinfo);
d4185 4
a4188 1
      return t->to_teardown_btrace (btinfo);
@


1.349
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@d1790 3
a1792 3
/* Read LEN bytes of target memory at address MEMADDR, placing the results in
   GDB's memory at MYADDR.  Returns either 0 for success or an errno value
   if any error occurs.
d1811 1
a1811 1
    return EIO;
d1828 1
a1828 1
    return EIO;
d1832 4
a1835 3
   Returns either 0 for success or an errno value if any error occurs.
   If an error occurs, no guarantee is made about how much data got written.
   Callers that can deal with partial writes should call target_write.  */
d1847 1
a1847 1
    return EIO;
d1851 4
a1854 4
   MEMADDR.  Returns either 0 for success or an errno value if any
   error occurs.  If an error occurs, no guarantee is made about how
   much data got written.  Callers that can deal with partial writes
   should call target_write.  */
d1866 1
a1866 1
    return EIO;
d2444 1
a2444 1
    memory_error (EIO, addr);
@


1.348
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@d2618 1
a2618 1
    remove_breakpoints_pid (PIDGET (inferior_ptid));
d2681 2
a2682 2
				  PIDGET (ptid), options_string,
				  PIDGET (retval), status_string);
d2736 1
a2736 1
				PIDGET (ptid),
d3826 1
a3826 1
				PIDGET (ptid), retval);
d4013 1
a4013 1
				PIDGET (ptid), retval);
d4752 1
a4752 1
		      PIDGET (ptid));
@


1.347
log
@	* inf-child.c (inf_child_follow_fork) New parameter
	detach_fork.
	* inf-ptrace.c (inf_ptrace_follow_fork): Likewise.
	* inf-ttrace.c (inf_ttrace_follow_fork): Likewise.
	* inferior.h (detach_fork): Remove.
	* infrun.c (detach_fork): Adjust comment and make it
	static.
	(follow_fork): Pass detach_fork parameter to
	target_follow_fork.
	* linux-nat.c (linux_child_follow_fork): New parameter
	detach_fork.
	* target.c (target_follow_fork): New parameter detach_fork.
	Pass detach_fork as parameter and print its value.
	* target.h (struct target_ops) <to_follow_fork>: New int
	parameter.
	(target_follow_fork): New parameter detach_fork.
@
text
@d1190 1
a1190 1
		         " linker's load module list"), objfile->name);
d1193 1
a1193 1
		         " linker's load module list"), objfile->name);
d1201 1
a1201 1
		       objfile->name, target_pid_to_str (ptid));
d1207 1
a1207 1
		       objfile->name, target_pid_to_str (ptid));
d1214 1
a1214 1
		       objfile->name, ex.message);
d1219 1
a1219 1
		       objfile->name, ex.message);
d2494 2
a2495 1
    printf_unfiltered (_("Symbols from \"%s\".\n"), symfile_objfile->name);
@


1.346
log
@target.c:target_read_live_memory: Fix type of local.

'ret' is used to hold the return of target_read, and pass it on.  Both
target_read and target_read_live_memory return LONGEST.

gdb/
2013-08-23  Pedro Alves  <palves@@redhat.com>

	* target.c (target_read_live_memory): Change type of 'ret' local
	to LONGEST.
@
text
@d2814 1
a2814 1
target_follow_fork (int follow_child)
d2822 1
a2822 1
	  int retval = t->to_follow_fork (t, follow_child);
d2825 3
a2827 2
	    fprintf_unfiltered (gdb_stdlog, "target_follow_fork (%d) = %d\n",
				follow_child, retval);
@


1.345
log
@PR gdb/15871: Unavailable entry value is not shown correctly

In entry-values.exp, we have a test where the entry value of 'j' is
unavailable, so it is expected that printing j@@entry yields
"<unavailable>".  However, the actual output is:

 (gdb) frame
 #0  0x0000000000400540 in foo (i=0, i@@entry=2, j=2, j@@entry=<error reading variable: Cannot access memory at address 0x6009e8>)

The error is thrown here:

#0  throw_it (reason=RETURN_ERROR, error=MEMORY_ERROR, fmt=0x8cd550 "Cannot access memory at address %s", ap=0x7fffffffc8e8) at ../../src/gdb/exceptions.c:373
#1  0x00000000005e2f9c in throw_error (error=MEMORY_ERROR, fmt=0x8cd550 "Cannot access memory at address %s") at ../../src/gdb/exceptions.c:422
#2  0x0000000000673a5f in memory_error (status=5, memaddr=6293992) at ../../src/gdb/corefile.c:204
#3  0x0000000000673aea in read_memory (memaddr=6293992, myaddr=0x7fffffffca60 "\200\316\377\377\377\177", len=4) at ../../src/gdb/corefile.c:223
#4  0x00000000006784d1 in dwarf_expr_read_mem (baton=0x7fffffffcd50, buf=0x7fffffffca60 "\200\316\377\377\377\177", addr=6293992, len=4) at ../../src/gdb/dwarf2loc.c:334
#5  0x000000000067645e in execute_stack_op (ctx=0x1409480, op_ptr=0x7fffffffce87 "\237<\005@@", op_end=0x7fffffffce88 "<\005@@") at ../../src/gdb/dwarf2expr.c:1045
#6  0x0000000000674e29 in dwarf_expr_eval (ctx=0x1409480, addr=0x7fffffffce80 "\003\350\t`", len=8) at ../../src/gdb/dwarf2expr.c:364
#7  0x000000000067c5b2 in dwarf2_evaluate_loc_desc_full (type=0x10876d0, frame=0xd8ecc0, data=0x7fffffffce80 "\003\350\t`", size=8, per_cu=0xf24c40, byte_offset=0)
    at ../../src/gdb/dwarf2loc.c:2236
#8  0x000000000067cc65 in dwarf2_evaluate_loc_desc (type=0x10876d0, frame=0xd8ecc0, data=0x7fffffffce80 "\003\350\t`", size=8, per_cu=0xf24c40)
    at ../../src/gdb/dwarf2loc.c:2407
#9  0x000000000067a5d4 in dwarf_entry_parameter_to_value (parameter=0x13a7960, deref_size=18446744073709551615, type=0x10876d0, caller_frame=0xd8ecc0, per_cu=0xf24c40)
    at ../../src/gdb/dwarf2loc.c:1160
#10 0x000000000067a962 in value_of_dwarf_reg_entry (type=0x10876d0, frame=0xd8de70, kind=CALL_SITE_PARAMETER_DWARF_REG, kind_u=...) at ../../src/gdb/dwarf2loc.c:1310
#11 0x000000000067aaca in value_of_dwarf_block_entry (type=0x10876d0, frame=0xd8de70, block=0xf1c2d4 "Q", block_len=1) at ../../src/gdb/dwarf2loc.c:1363
#12 0x000000000067e7c9 in locexpr_read_variable_at_entry (symbol=0x13a7540, frame=0xd8de70) at ../../src/gdb/dwarf2loc.c:3326
#13 0x00000000005daab6 in read_frame_arg (sym=0x13a7540, frame=0xd8de70, argp=0x7fffffffd0e0, entryargp=0x7fffffffd100) at ../../src/gdb/stack.c:362
#14 0x00000000005db384 in print_frame_args (func=0x13a7470, frame=0xd8de70, num=-1, stream=0xea3890) at ../../src/gdb/stack.c:669
#15 0x00000000005dc338 in print_frame (frame=0xd8de70, print_level=1, print_what=SRC_AND_LOC, print_args=1, sal=...) at ../../src/gdb/stack.c:1199
#16 0x00000000005db8ee in print_frame_info (frame=0xd8de70, print_level=1, print_what=SRC_AND_LOC, print_args=1) at ../../src/gdb/stack.c:851
#17 0x00000000005da2bb in print_stack_frame (frame=0xd8de70, print_level=1, print_what=SRC_AND_LOC) at ../../src/gdb/stack.c:169
#18 0x00000000005de236 in frame_command (level_exp=0x0, from_tty=1) at ../../src/gdb/stack.c:2265

dwarf2_evaluate_loc_desc_full (frame #7) knows to handle
NOT_AVAILABLE_ERROR errors, but read_memory always throws
a generic error.

Presently, only the value machinery knows to handle unavailable
memory.  We need to push the awareness down to the target_xfer layer,
making it return a finer grained error indication.  We can only return
a generic -1 nowadays, which leaves the upper layers with no clue on
why the xfer failed.  Use target_xfer_partial directly, rather than
propagating the error through target_read_memory so as to get a better
address to display in the error message.

(target_read_memory & friends build on top of target_read (thus the
target_xfer machinery), but turn all errors to EIO, an errno value.  I
think this is a mistake, and we'd better convert all these to return a
target_xfer_error too, but that can be done separately.  I looked
around a bit over memory_error calls, and the need to handle random
errno values, other than the EIOs gdb itself hardcodes, probably comes
(only) from deprecated_xfer_memory, which uses errno for error
indication, but I didn't look exhaustively.  We should really get rid
of deprecated_xfer_memory and of passing down errno values as error
indication in target_read & friends methods).

Tested on x86_64 Fedora 17, native and gdbserver.  Fixes the test in
the PR, which will be added to the testsuite later.

gdb/
2013-08-22  Pedro Alves  <palves@@redhat.com>

	PR gdb/15871
	* corefile.c (target_xfer_memory_error): New function.
	(memory_error): Defer EIO to target_memory_error.
	(read_memory): Use target_xfer_partial, and handle finer-grained
	target xfer errors.
	* target.c (target_xfer_error_to_string): New function.
	(memory_xfer_partial_1): If memory is known to be
	unavailable, return TARGET_XFER_E_UNAVAILABLE instead of -1.
	(target_xfer_partial): Make extern.
	* target.h (enum target_xfer_error): New enum.
	(target_xfer_error_to_string): Declare function.
	(target_xfer_partial): Declare function.
	(struct target_ops) <xfer_partial>: Adjust describing comment.
@
text
@d1367 1
a1367 1
  int ret;
@


1.344
log
@	* target.c (target_async_permitted_1): Fix comment.
@
text
@a83 6
static LONGEST target_xfer_partial (struct target_ops *ops,
				    enum target_object object,
				    const char *annex,
				    void *readbuf, const void *writebuf,
				    ULONGEST offset, LONGEST len);

d1235 15
d1535 1
a1535 1
	      return -1;
d1712 1
a1712 1
static LONGEST
@


1.343
log
@remove pop_target

This patch fixes the target double-close problem (PR remote/15266),
and in the process removes pop_target entire (PR remote/15256).

The first issue is that pop_target calls target_close.  However, it
then calls unpush_target, which also calls target_close.  This means
targets must be able to be closed twice.  Not only is this strange,
but it also directly contradicts the contract of to_xclose targets.
(We currently have just a single such target, and it is never pushed;
but I plan to add more, and so this latent bug is triggered.)

The second issue is that it seems to me that calling pop_target is
often unsafe.  This is what cropped up in 15256, where the remote
target assumed that it could pop_target -- but there was another
target higher on the stack, leading to confusion.

But, it is always just as easy to call unpush_target as it is to call
pop_target; and it is also safer.  So, removing pop_target seemed like
an improvement.

Finally, this adds an assertion to target_close to ensure that no
currently-pushed target can be closed.

Built and regtested on x86-64 Fedora 18; both natively and using the
native-gdbserver board file.

	PR remote/15256, PR remote/15266:
	* bfd-target.c (target_bfd_reopen): Initialize to_magic.
	* monitor.c (monitor_detach): Use unpush_target.
	* remote-m32r-sdi.c (m32r_detach): Use unpush_target.
	* remote-mips.c (mips_detach): Use unpush_target.  Don't
	call mips_close.
	* remote-sim.c (gdbsim_detach): Use unpush_target.
	* target.c (pop_target): Remove.
	(pop_all_targets_above): Don't call target_close.
	(target_close): Assert that the target is unpushed.
	* target.h (pop_target): Don't declare.
	* tracepoint.c (tfile_open): Use unpush_target.
@
text
@d4978 1
a4978 1
   executing, linux_nat_async_permitted is *not* updated.  */
@


1.342
log
@don't call add_target for thread_db_ops

Right now, "help target" will include this line:

    target multi-thread -- Threads and pthreads support

However, it doesn't make sense to invoke "target multi-thread".

This patch fixes the problem by not registering the multi-thread
target.  add_target does some needed initialization of the target_ops,
so I broke this out into a new function.

It isn't clear to me whether this patch requires a test case or not.
I'm not sure whether there are other unregistered targets; but if
there are, it seems unlikely that we test for their absence from the
help.

Built and regtested on x86-64 Fedora 18.

	* linux-thread-db.c (init_thread_db_ops): Call
	complete_target_initialization.
	(_initialize_thread_db): Don't call add_target.
	* target.c (complete_target_initialization): New function.
	(add_target_with_completer): Call it.
	* target.h (complete_target_initialization): Declare.
@
text
@a1096 14
pop_target (void)
{
  target_close (target_stack);		/* Let it clean up.  */
  if (unpush_target (target_stack) == 1)
    return;

  fprintf_unfiltered (gdb_stderr,
		      "pop_target couldn't find target %s\n",
		      current_target.to_shortname);
  internal_error (__FILE__, __LINE__,
		  _("failed internal consistency check"));
}

void
a1100 1
      target_close (target_stack);
d3769 2
@


1.341
log
@	gdb/
	* Makefile.in (SFILES): Add common/target-common.c.
	Add common/target-common.h to headers.
	(COMMON_OBS): Add target-common.o.
	(target-common.o): New target.
	* linux-nat.h (resume_kind): Move to common/target-common.h.
	* target.c (target_waitstatus_to_string): Move to
	common/target-common.c.
	* target.h: Include target-common.h.
	(target_waitkind): Move to common/target-common.h.
	(target_waitstatus): Likewise.
	(TARGET_WNOHANG): Likewise.
	* common/target-common.c: New file.
	* common/target-common.h: New file.

	gdb/gdbserver/
	* Makefile.in (SFILES): /common/target-common.c.
	(OBS): Add target-common.o.
	(server_h): Add $(srcdir)/../common/target-common.h.
	(target-common.o): New target.
	* server.c (queue_stop_reply_callback): Free
	status string after use.
	* target.c (target_waitstatus_to_string): Remove.
	* target.h: Include target-common.h.
	(resume_kind): Likewise.
	(target_waitkind): Likewise.
	(target_waitstatus): Likewise.
	(TARGET_WNOHANG): Likewise.
@
text
@d384 2
a385 3
/* Add possible target architecture T to the list and add a new
   command 'target T->to_shortname'.  Set COMPLETER as the command's
   completer if not NULL.  */
d388 1
a388 2
add_target_with_completer (struct target_ops *t,
			   completer_ftype *completer)
a389 2
  struct cmd_list_element *c;

d408 13
@


1.340
log
@gdb/

	* target.c (update_current_target): Change the default action
	of 'to_traceframe_info' from tcomplain to return_zero.
	* target.h (struct target_ops) <to_traceframe_info>: Add more
	comments.
	* valops.c (read_value_memory): Call
	traceframe_available_memory unconditionally.

gdb/testsuite/

	* gdb.trace/read-memory.exp (test_from_remote): Update test.
	(teset_from_exec): Likewise.
@
text
@a3865 46
/* Return a pretty printed form of target_waitstatus.
   Space for the result is malloc'd, caller must free.  */

char *
target_waitstatus_to_string (const struct target_waitstatus *ws)
{
  const char *kind_str = "status->kind = ";

  switch (ws->kind)
    {
    case TARGET_WAITKIND_EXITED:
      return xstrprintf ("%sexited, status = %d",
			 kind_str, ws->value.integer);
    case TARGET_WAITKIND_STOPPED:
      return xstrprintf ("%sstopped, signal = %s",
			 kind_str, gdb_signal_to_name (ws->value.sig));
    case TARGET_WAITKIND_SIGNALLED:
      return xstrprintf ("%ssignalled, signal = %s",
			 kind_str, gdb_signal_to_name (ws->value.sig));
    case TARGET_WAITKIND_LOADED:
      return xstrprintf ("%sloaded", kind_str);
    case TARGET_WAITKIND_FORKED:
      return xstrprintf ("%sforked", kind_str);
    case TARGET_WAITKIND_VFORKED:
      return xstrprintf ("%svforked", kind_str);
    case TARGET_WAITKIND_EXECD:
      return xstrprintf ("%sexecd", kind_str);
    case TARGET_WAITKIND_VFORK_DONE:
      return xstrprintf ("%svfork-done", kind_str);
    case TARGET_WAITKIND_SYSCALL_ENTRY:
      return xstrprintf ("%sentered syscall", kind_str);
    case TARGET_WAITKIND_SYSCALL_RETURN:
      return xstrprintf ("%sexited syscall", kind_str);
    case TARGET_WAITKIND_SPURIOUS:
      return xstrprintf ("%sspurious", kind_str);
    case TARGET_WAITKIND_IGNORE:
      return xstrprintf ("%signore", kind_str);
    case TARGET_WAITKIND_NO_HISTORY:
      return xstrprintf ("%sno-history", kind_str);
    case TARGET_WAITKIND_NO_RESUMED:
      return xstrprintf ("%sno-resumed", kind_str);
    default:
      return xstrprintf ("%sunknown???", kind_str);
    }
}

@


1.339
log
@	* target.h (struct target_section): Delete member bfd.
	All users updated to use the_bfd_section->owner instead.
	* exec.c (add_to_section_table): Assert bfd is expected value.
	Remove initialization of target_section.bfd.
	(remove_target_sections): Update.
	(section_table_available_memory): Update.
	(section_table_xfer_memory_partial): Update.
	(print_section_info): Update.
	(exec_set_section_address): Update.
	* record-full.c (record_full_core_xfer_partial): Update.
	* solib-svr4.c (svr4_relocate_section_addresses): Update.
	* solib-target.c (solib_target_relocate_section_addresses): Update.
	* symfile.c (build_section_addr_info_from_section_table): Update.
	* target.c (memory_xfer_live_readonly_partial): Update.
	(memory_xfer_partial_1): Update.
@
text
@d965 1
a965 1
	    tcomplain);
@


1.338
log
@	* target.c (find_run_target): Remove.
	* target.h (find_run_target): Remove.
@
text
@d1399 2
a1400 1
      && (bfd_get_section_flags (secp->bfd, secp->the_bfd_section)
d1479 2
a1480 1
	  && (bfd_get_section_flags (secp->bfd, secp->the_bfd_section)
@


1.337
log
@	* target.c (target_struct_index): Remove.
@
text
@a3629 24
/* Find a single runnable target in the stack and return it.  If for
   some reason there is more than one, return NULL.  */

struct target_ops *
find_run_target (void)
{
  struct target_ops **t;
  struct target_ops *runable = NULL;
  int count;

  count = 0;

  for (t = target_structs; t < target_structs + target_struct_size; ++t)
    {
      if ((*t)->to_can_run && target_can_run (*t))
	{
	  runable = *t;
	  ++count;
	}
    }

  return (count == 1 ? runable : NULL);
}

@


1.336
log
@2013-06-04  Gary Benson  <gbenson@@redhat.com>

	* target.h (target_ops): New field
	"to_augmented_libraries_svr4_read".
	(target_augmented_libraries_svr4_read): New macro.
	* target.c (update_current_target): Handle
	to_augmented_libraries_svr4_read.
	* remote.c (remote_state): New field
	"augmented_libraries_svr4_read".
	(remote_augmented_libraries_svr4_read_feature): New function.
	(remote_protocol_features): Add entry for
	"augmented-libraries-svr4-read".
	(remote_augmented_libraries_svr4_read): New function.
	(init_remote_ops): Initialize
	remote_ops.to_augmented_libraries_svr4_read.
@
text
@a155 1
unsigned target_struct_index;
@


1.335
log
@	* remote.c (remote_set_trace_notes): Make arguments const.
	* target.c (update_current_target): Update cast.
	* target.h (to_set_trace_notes): Make arguments const.
@
text
@d734 1
d979 3
@


1.334
log
@	* go32-nat.c (go32_terminal_info): Make 'args' const.
	* inferior.h (child_terminal_info): Update.
	* inflow.c (child_terminal_info): Make 'args' const.
	* target.c (default_terminal_info): Make 'args' const.
	(debug_to_terminal_save_ours): Likewise.
	* target.h (struct target_ops) <to_terminal_info>: Make argument
	const.
@
text
@d949 1
a949 1
	    (int (*) (char *, char *, char *))
@


1.333
log
@	* gcore.c (create_gcore_bfd): Make 'filename' const.
	* gcore.h (create_gcore_bfd): Make 'filename' const.
	* record-full.c (record_full_save): Make 'recfilename' const.
	* target.c (target_save_record): Make 'filename' const.
	* target.h (struct target_ops) <to_save_record>: Make 'filename'
	const.
	(target_save_record): Likewise.
@
text
@d49 1
a49 1
static void default_terminal_info (char *, int);
a144 2
static void debug_to_terminal_info (char *, int);

d558 1
a558 1
default_terminal_info (char *args, int from_tty)
d4788 1
a4788 1
debug_to_terminal_info (char *arg, int from_tty)
@


1.332
log
@gdb/
	* remote.c (remote_trace_find): Change type of parameters 'addr1'
	and 'addr2' to CORE_ADDR.
	* target.c (update_current_target): Update.
	* target.h (struct target_ops) <to_trace_find>: Change parameter
	type to CORE_ADDR.
	* tracepoint.c (tfind_1): Change type of parameters 'addr1' and
	'addr2' to CORE_ADDR.
	(tfile_trace_find): Likewise.
	(tfile_get_traceframe_address): Change return type to CORE_ADDR.
	Change local variable 'addr' to type CORE_ADDR.
	* tracepoint.h (tfind_1): Update declaration.
@
text
@d4299 1
a4299 1
target_save_record (char *filename)
@


1.331
log
@gdb/

2013-03-29  Yao Qi  <yao@@codesourcery.com>

	* corelow.c: Include "completer.h".
	(_initialize_corelow): Call add_target_with_completer with
	argument 'filename_completer'.
	* tracepoint.c: Likewise.
	* exec.c (_initialize_exec): Likewise.
	* target.c (add_target): Rename to ...
	(add_target_with_completer): ... this.  Call set_cmd_completer
	if parameter completer is not NULL.
	(add_target): New.
	* target.h: Include "command.h".
	(add_target_with_completer): Declare it.

gdb/testsuite:

2013-03-29  Yao Qi  <yao@@codesourcery.com>

	* gdb.base/completion.exp: Test completion of commands
	"target core", "target tfile" and "target exec".
	* gdb.trace/tfile.exp: Test completion of command
	"target tfile".
@
text
@d921 1
a921 1
	    (int (*) (enum trace_find_type, int, ULONGEST, ULONGEST, int *))
@


1.330
log
@gdb/
	Code cleanup.
	* bfd-target.c (target_bfd_xclose): Remove parameter quitting.
	* bsd-kvm.c (bsd_kvm_close): Likewise.
	* bsd-uthread.c (bsd_uthread_close): Likewise.
	* corelow.c (core_close): Likewise.
	(core_close_cleanup): Remove parameter quitting from a caller.
	* event-top.c (async_disconnect): Likewise.
	* exec.c (exec_close_1): Remove parameter quitting.
	* go32-nat.c (go32_close): Likewise.
	* linux-nat.c (linux_nat_close): Remove parameter quitting.  Remove
	parameter quitting from a caller.
	* mips-linux-nat.c (super_close): Remove parameter quitting from the
	variable.
	(mips_linux_close): Remove parameter quitting.  Remove parameter
	quitting from a caller.
	* monitor.c (monitor_close): Remove parameter quitting.
	* monitor.h (monitor_close): Likewise.
	* record-btrace.c (record_btrace_close): Likewise.
	* record-full.c (record_full_close): Likewise.
	* remote-m32r-sdi.c (m32r_close): Remove parameter quitting and remove
	it also from fprintf_unfiltered.
	* remote-mips.c (mips_close): Remove parameter quitting.
	(mips_detach): Remove parameter quitting from a caller.
	* remote-sim.c (gdbsim_close): Remove parameter quitting.
	(gdbsim_close): Remove duplicate function comment.  Remove parameter
	quitting and remove it also from printf_filtered.
	* remote.c (remote_close): Remove parameter quitting.
	* solib-svr4.c (enable_break): Remove parameter quitting from a caller.
	* target.c (update_current_target): Remove parameter int from to_close
	de_fault.
	(push_target, unpush_target, pop_target): Remove parameter quitting from
	a caller.
	(pop_all_targets_above, pop_all_targets): Remove parameter quitting.
	Remove parameter quitting from a caller.
	(target_preopen): Remove parameter quitting from a caller.
	(target_close): Remove parameter quitting.  Remove parameter quitting
	from a caller two times.  Remove parameter quitting also from
	fprintf_unfiltered.
	* target.h (struct target_ops): Remove parameter quitting and as int
	from fields to_xclose and to_close.
	(extern struct target_ops current_target):
	(target_close, pop_all_targets): Remove parameter quitting.  Update the
	comment.
	(pop_all_targets_above): Remove parameter quitting.
	* top.c (quit_target): Remove parameter quitting from a caller.
	* tracepoint.c (tfile_close): Remove parameter quitting.
	* windows-nat.c (windows_close): Remove parameter quitting.
@
text
@d387 3
a389 1
/* Add a possible target architecture to the list.  */
d392 2
a393 1
add_target (struct target_ops *t)
d395 2
d439 12
a450 1
  add_cmd (t->to_shortname, no_class, t->to_open, t->to_doc, &targetlist);
@


1.329
log
@Avoid invalid pointer to pointer conversions.

Casts between 'char **' <-> 'unsigned char **' and 'char **' <-> const
char **' are actually invalid:

  http://gcc.gnu.org/ml/gcc-help/2013-03/msg00118.html

In a nutshell, char (and variants) can alias anything, but pointers to
chars get no special treatment (cf. C99/N1256, 6.5/7).

Turns out older gcc's actually warn/complain on these constructs,
though newer one's don't:

  http://sourceware.org/ml/gdb-patches/2013-03/msg00429.html
  http://sourceware.org/ml/gdb-patches/2013-03/msg00430.html

This patch fixes the cases I added last week.  It also fixes one other
preexisting case in charset.c, though it seems even older gccs don't
complain of char * <-> const char * aliasing.

Tested on x86_64 Fedora 17.

gdb/
2013-03-11  Pedro Alves  <palves@@redhat.com>

	* charset.c (convert_between_encodings): Don't cast between
	different pointer to pointer types.  Instead, make the 'inp' local
	be of the type iconv expects.
	(wchar_iterate): Don't cast between different pointer to pointer
	types.  Instead, use new pointer local of the type iconv expects.
	* target.c (target_read_stralloc, target_fileio_read_stralloc):
	Add new local of type char pointer, and use it to get a
	char/string view of the byte buffer, instead of casting between
	pointer to pointer types.
@
text
@d741 1
a741 1
	    (void (*) (int))
d1018 1
a1018 1
      target_close (tmp, 0);
d1065 1
a1065 1
  target_close (t, 0);
d1073 1
a1073 1
  target_close (target_stack, 0);	/* Let it clean up.  */
d1085 1
a1085 1
pop_all_targets_above (enum strata above_stratum, int quitting)
d1089 1
a1089 1
      target_close (target_stack, quitting);
d1103 1
a1103 1
pop_all_targets (int quitting)
d1105 1
a1105 1
  pop_all_targets_above (dummy_stratum, quitting);
d2576 1
a2576 1
  pop_all_targets_above (file_stratum, 0);
d3778 1
a3778 1
target_close (struct target_ops *targ, int quitting)
d3781 1
a3781 1
    targ->to_xclose (targ, quitting);
d3783 1
a3783 1
    targ->to_close (quitting);
d3786 1
a3786 1
    fprintf_unfiltered (gdb_stdlog, "target_close (%d)\n", quitting);
@


1.328
log
@Add command to print the function names from recorded instructions.

This command provides a quick high-level overview over the recorded execution
log at function granularity without having to reverse-step.

gdb/
	* target.c (target_call_history, target_call_history_from,
	target_call_history_range): New.
	* target.h (target_ops) <to_call_history, to_call_history_from,
	to_call_history_range>: New fields.
	(target_call_history, target_call_history_from,
	target_call_history_range): New declaration.
	* record.c (get_call_history_modifiers, cmd_record_call_history,
	record_call_history_size): New.
	(_initialize_record): Add the "record function-call-history" command.
	Add "set/show record function-call-history-size" commands.
	* record.h (record_print_flag): New.
@
text
@d2381 2
a2382 1
  char *buffer;
d2385 2
a2386 2
  transferred = target_read_alloc_1 (ops, object, annex,
				     (gdb_byte **) &buffer, 1);
d2394 1
a2394 1
  buffer[transferred] = 0;
d2397 2
a2398 2
  for (i = strlen (buffer); i < transferred; i++)
    if (buffer[i] != 0)
d2406 1
a2406 1
  return buffer;
d3546 2
a3547 1
  char *buffer;
d3550 2
a3551 2
  transferred = target_fileio_read_alloc_1 (filename,
					    (gdb_byte **) &buffer, 1);
d3559 1
a3559 1
  buffer[transferred] = 0;
d3562 2
a3563 2
  for (i = strlen (buffer); i < transferred; i++)
    if (buffer[i] != 0)
d3571 1
a3571 1
  return buffer;
@


1.327
log
@Add a command to provide a disassembly of the execution trace log.

gdb/
	* target.h (target_ops) <to_insn_history, to_insn_history_from,
	to_insn_history_range>: New fields.
	(target_insn_history): New.
	(target_insn_history_from): New.
	(target_insn_history_range): New.
	* target.c (target_insn_history): New.
	(target_insn_history_from): New.
	(target_insn_history_range): New.
	* record.c: Include cli/cli-utils.h, disasm.h, ctype.h.
	(record_insn_history_size): New.
	(get_insn_number): New.
	(get_context_size): New.
	(no_chunk): New.
	(get_insn_history_modifiers): New.
	(cmd_record_insn_history): New.
	(_initialize_record): Add "set/show record instruction-history-size"
	command. Add "record instruction-history" command.
@
text
@d4442 51
@


1.326
log
@Provide default target methods for record targets that are likely to be shared
between different record targets.

gdb/
	* record.h (record_disconnect): New.
	(record_detach): New.
	(record_mourn_inferior): New.
	(record_kill): New.
	* record-full.c (record_disconnect, record_detach,
	record_mourn_inferior, record_kill): Move to...
	* record.c: ...here.
	(DEBUG): New.
	(record_stop): New.
	(record_unpush): New.
	(cmd_record_stop): Call record_stop. Replace unpush_target
	call with record_unpush call.
	(record_disconnect, record_detach): Assert that the target
	is of record stratum. Call record_unpush, record_stop, and
	DEBUG.
	(record_mourn_inferior, record_kill): Assert that the target
	is of record stratum. Call record_unpush and DEBUG.
@
text
@d4391 51
@


1.325
log
@Split record.h into record.h and record-full.h.
Split record.c into record.c and record-full.c.

The split leaves the command part in record.c and moves the target part into
record-full.c.

gdb/
	* record.h: Split into this and ...
	* record-full.h: ... this.
	* record.c: Split into this and ...
	* record-full.c: ... this.
	* target.h (target_ops): Add new fields to_info_record,
	to_save_record, to_delete_record, to_record_is_replaying,
	to_goto_record_begin, to_goto_record_end, to_goto_record.
	(target_info_record): New.
	(target_save_record): New.
	(target_supports_delete_record): New.
	(target_delete_record): New.
	(target_record_is_replaying): New.
	(target_goto_record_begin): New.
	(target_goto_record_end): New.
	(target_goto_record): New.
	* target.c (target_info_record): New.
	(target_save_record): New.
	(target_supports_delete_record): New.
	(target_delete_record): New.
	(target_record_is_replaying): New.
	(target_goto_record_begin): New.
	(target_goto_record_end): New.
	(target_goto_record): New.
	* record.h: Declare struct cmd_list_element.
	(record_cmdlist): New declaration.
	(set_record_cmdlist): New declaration.
	(show_record_cmdlist): New declaration.
	(info_record_cmdlist): New declaration.
	(cmd_record_goto): New declaration.
	* record.c: Remove unnecessary includes.
	Include inferior.h.
	(cmd_record_goto): Remove declaration.
	(record_cmdlist): Now extern. Initialize.
	(set_record_cmdlist): Now extern. Initialize.
	(show_record_cmdlist): Now extern. Initialize.
	(info_record_cmdlist): Now extern. Initialize.
	(find_record_target): New.
	(require_record_target): New.
	(cmd_record_start): Update.
	(cmd_record_delete): Remove target-specific code.
	Call target_delete_record.
	(cmd_record_stop): Unpush any record target.
	(set_record_insn_max_num): Move to record-full.c
	(set_record_command): Add comment.
	(show_record_command): Add comment.
	(info_record_command): Update comment.
	Remove target-specific code.
	Call the record target's to_info_record.
	(cmd_record_start): New.
	(cmd_record_goto): Now extern.
	Remove target-specific code.
	Call target_goto_begin,  target_goto_end, or target_goto.
	(_initialize_record): Move record target ops initialization to
	record-full.c.
	Change "record" command help text.
	Move "record restore", "record set", and "record show" commands to
	record-full.c.
	* Makefile.in (SFILES): Add record-full.c.
	(HFILES_NO_SRCDIR): Add record-full.h.
	(COMMON_OBS): Add record-full.o.
	* amd64-linux-tdep.c: Include record-full.h instead of record.h.
	* arm-tdep.c: Include record-full.h.
	* i386-linux-tdep.c: Include record-full.h instead of record.h.
	* i386-tdep.c: Include record-full.h.
	* infrun.c: Include record-full.h.
	* linux-record.c: Include record-full.h.
	* moxie-tdep.c: Include record-full.h.
	* record-full.c: Include record-full.h.
	Change module comment.
	(set_record_full_cmdlist): New.
	(show_record_full_cmdlist): New.
	(record_full_cmdlist): New.
	(record_goto_insn): New declaration.
	(record_save): New declaration.
	(record_check_insn_num): Change query string.
	(record_info): New.
	(record_delete): New.
	(record_is_replaying): New.
	(record_goto_entry): New.
	(record_goto_begin): New.
	(record_goto_end): New.
	(record_goto): New.
	(init_record_ops): Update.
	(init_record_core_ops): Update.
	(cmd_record_save): Rename to record_save. Remove target and arg checks.
	(cmd_record_start): New.
	(set_record_insn_max_num): Moved from record.c
	(set_record_full_command): New.
	(show_record_full_command): New.
	(_initialize_record_full): New.
@
text
@d4247 17
@


1.324
log
@Add a new function to target.h to add an alias command for a target and mark it
deprecated.  This is useful when renaming targets.

gdb/
	* target.h (add_deprecated_target_alias): New.
	* target.c (add_deprecated_target_alias): New.
@
text
@d4244 130
@


1.323
log
@Add branch trace information to struct thread_info.

Add functions to enable, disable, clear, and fetch a thread's branch trace.

gdb/
	* target.h: Include btrace.h.
	(struct target_ops) <to_supports_btrace, to_enable_btrace,
	to_disable_btrace, to_teardown_btrace, to_read_btrace>: New.
	* target.c (target_supports_btrace): New function.
	(target_enable_btrace): New function.
	(target_disable_btrace): New function.
	(target_teardown_btrace): New function.
	(target_read_btrace): New function.
	* btrace.h: New file.
	* btrace.c: New file.
	* Makefile.in: Add btrace.c.
	* gdbthread.h: Include btrace.h.
	(struct thread_info): Add btrace field.
	* thread.c: Include btrace.h.
	(clear_thread_inferior_resources): Call target_teardown_btrace.
	* common/btrace-common.h: New file.
@
text
@d437 15
@


1.322
log
@2012-03-08  Stan Shebs  <stan@@codesourcery.com>
	    Hafiz Abid Qadeer  <abidh@@codesourcery.com>

	gdb/
	* NEWS: Mention set and show trace-buffer-size commands.
	Mention new packet.
	* target.h (struct target_ops): New method
	to_set_trace_buffer_size.
	(target_set_trace_buffer_size): New macro.
	* target.c (update_current_target): Set up new method.
	* tracepoint.c (trace_buffer_size): New global.
	(start_tracing): Send it to the target.
	(set_trace_buffer_size): New function.
	(_initialize_tracepoint): Add new setshow for trace-buffer-size.
	* remote.c (remote_set_trace_buffer_size): New function.
	(_initialize_remote): Use it.
	(QTBuffer:size) New remote command.
	(PACKET_QTBuffer_size): New enum.
	(remote_protocol_features): Add an entry for
	PACKET_QTBuffer_size.

	gdb/gdbserver/
	* tracepoint.c (trace_buffer_size): New global.
	(DEFAULT_TRACE_BUFFER_SIZE): New define.
	(init_trace_buffer): Change to one-argument function. Allocate
	trace buffer memory.
	(handle_tracepoint_general_set): Call cmd_bigqtbuffer_size to
	handle QTBuffer:size packet.
	(cmd_bigqtbuffer_size): New function.
	(initialize_tracepoint): Call init_trace_buffer with
	DEFAULT_TRACE_BUFFER_SIZE.
	* server.c (handle_query): Add QTBuffer:size in the
	supported packets.

	gdb/doc/
	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	trace-buffer-size set and show commands.
	(Tracepoint Packets): Document QTBuffer:size.
	(General Query Packets): Document QTBuffer:size.

	gdb/testsuite/
	* gdb.trace/trace-buffer-size.exp: New file.
	* gdb.trace/trace-buffer-size.c: New file.
@
text
@d4156 73
@


1.321
log
@target.c: fix -Wpointer-sign

$ make WERROR_CFLAGS="-Wpointer-sign -Werror" target.o -k 2>&1 1>/dev/null
../../src/gdb/target.c: In function target_read_stralloc:
../../src/gdb/target.c:2376:3: error: pointer targets in passing argument 1 of strlen differ in signedness [-Werror=pointer-sign]
In file included from build-gnulib/import/string.h:27:0,
                 from ../../src/gdb/common/gdb_string.h:24,
                 from ../../src/gdb/target.c:24:
/usr/include/string.h:399:15: note: expected const char * but argument is of type gdb_byte *
...

This is about the same as the previous patch.

Functions that take or return ascii-ish string arguments usually use
char* for parameters/return.  That means that at points we call into
target methods that work with binary blobs, we need casts to/from
gdb_byte*/char*.  To choose which type for the variables, I usually go
based on which requires the fewer casts, and what the contents of the
variable are supposed to hold, which often gives the same answer.

gdb/
2013-03-07  Pedro Alves  <palves@@redhat.com>

	* target.c (target_read_stralloc, target_fileio_read_alloc):
	*Cast pointer to 'gdb_byte *' in target call.
@
text
@d696 1
d916 3
@


1.320
log
@Use gdb_byte for bytes from the program being debugged.

gdb_byte should be used for bytes from the program being debugged.  We
have many places using char or unsigned char instead all over the
existing ports, and more ends up added over time due to copy/paste as
new code is based on old code.

I've greped the tree for "char buf[", and fixed all I found.

Tested by building with --enable-targets=all.

2013-03-01  Pedro Alves  <palves@@redhat.com>

	Use gdb_byte for bytes from the program being debugged.

	* arm-tdep.c (arm_store_return_value, arm_get_longjmp_target):
	Change type of local 'buf' to gdb_byte.
	* avr-tdep.c (avr_frame_prev_register, avr_push_dummy_call): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* cris-tdep.c (cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache): Likewise.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp)
	(frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Likewise.
	* frv-tdep.c (frv_pseudo_register_write, frv_analyze_prologue): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_find_global_pointer)
	(hppa32_hpux_search_dummy_call_sequence)
	(hppa_hpux_supply_save_state): Likewise.
	* hppa-linux-tdep.c (insns_match_pattern)
	(hppa_linux_find_global_pointer): Likewise.
	* hppa-tdep.c (hppa_in_function_epilogue_p)
	(skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Likewise.
	* i386fbsd-tdep.c (i386fbsd_supply_uthread)
	(i386fbsd_collect_uthread): Likewise.
	* ia64-hpux-tdep.c (ia64_hpux_push_dummy_code): Likewise.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Likewise.
	* ia64-tdep.c (examine_prologue, ia64_frame_cache)
	(ia64_frame_prev_register, ia64_sigtramp_frame_cache)
	(ia64_sigtramp_frame_prev_register, ia64_access_reg)
	(ia64_access_rse_reg, ia64_libunwind_frame_this_id)
	(ia64_libunwind_frame_prev_register)
	(ia64_libunwind_sigtramp_frame_this_id)
	(ia64_find_global_pointer_from_dynamic_section)
	(find_extant_func_descr, find_func_descr, ia64_dummy_id)
	(ia64_unwind_pc): Likewise.
	* iq2000-tdep.c (iq2000_store_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call)
	(m68hc11_extract_return_value): Likewise.
	* m68klinux-nat.c (fetch_register, store_register): Likewise.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_cr32_write)
	(mep_get_insn, mep_push_dummy_call): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips_linux_in_dynsym_stub): Likewise.
	* mn10300-tdep.c (mep_pseudo_cr32_write): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* regcache.c (dump_endian_bytes): Change type of parameter 'buf'
	to gdb_byte.
	* remote-mips.c (mips_set_register): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* score-tdep.c (score7_fetch_inst): Change type of parameter
	'memblock' and local 'buf' to gdb_byte.
	(score7_malloc_and_get_memblock): Change return type to gdb_byte.
	Change type of local 'buf' to gdb_byte.  Adjust.
	(score7_adjust_memblock_ptr): Change type of parameter 'memblock'
	to gdb_byte**.
	(score7_analyze_prologue): Change type of 'memblock' and
	'memblock_ptr' locals to gdb_byte*.
	* sh64-tdep.c (sh64_extract_return_value)
	(sh64_store_return_value): Change type of local 'buf' to gdb_byte.
	* solib-darwin.c (darwin_current_sos, darwin_read_exec_load_addr):
	* solib-pa64.c (pa64_solib_create_inferior_hook)
	(pa64_open_symbol_file_object): Remove local 'buf'.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start)
	(som_open_symbol_file_object): Likewise.
	* solib-spu.c (spu_current_sos): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	* spu-multiarch.c (parse_spufs_run, spu_fetch_registers)
	(spu_store_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	* tic6x-tdep.c (tic6x_get_longjmp_target): Likewise.
	* xstormy16-tdep.c (xstormy16_store_return_value)
	(xstormy16_push_dummy_call, xstormy16_resolve_jmp_table_entry)
	(xstormy16_find_jmp_table_entry): Likewise.
@
text
@d2362 1
a2362 1
  gdb_byte *buffer;
d2365 2
a2366 1
  transferred = target_read_alloc_1 (ops, object, annex, &buffer, 1);
d2386 1
a2386 1
  return (char *) buffer;
d3526 1
a3526 1
  gdb_byte *buffer;
d3529 2
a3530 1
  transferred = target_fileio_read_alloc_1 (filename, &buffer, 1);
d3550 1
a3550 1
  return (char *) buffer;
@


1.319
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

        * target.c (target_read_string): Remove unused origlen.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00754.html
@
text
@d3960 1
a3960 1
      unsigned char buf[MAX_REGISTER_SIZE];
@


1.318
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1223 1
a1223 1
  int tlen, origlen, offset, i;
a1237 2
  origlen = len;

@


1.317
log
@gdb
        * NEWS: Mention "info proc" and core files.
        * corelow.c (core_info_proc): New function.
        (init_core_ops): Set to_info_proc.
        * gdbarch.c, gdbarch.h: Rebuild.
        * gdbarch.sh (core_info_proc): New method.
        * infcmd.c (info_proc_cmd_1): Invoke target_info_proc first.
        * linux-tdep.c (linux_core_info_proc_mappings)
        (linux_core_info_proc): New functions.
        (linux_find_memory_region_ftype): New typedef.
        (linux_find_memory_regions_full): New function, from
        linux_find_memory_regions.
        (struct linux_find_memory_regions_data): New.
        (linux_find_memory_regions_thunk): New function.
        (linux_find_memory_regions): Rewrite.
        (struct linux_make_mappings_data): New.
        (linux_make_mappings_callback)
        (linux_make_mappings_corefile_notes): New functions.
        (linux_make_corefile_notes): Call linux_make_mappings_corefile_notes.
        (linux_init_abi): Call set_gdbarch_core_info_proc.
        * target.c (target_info_proc): Return 'int'.
        * target.h (target_info_proc): Update.
gdb/doc
        * gdb.texinfo (SVR4 Process Information): Mention core files.
gdb/testsuite
        * gdb.base/info-proc.exp: Add core file tests.
bfd
        * elf.c (elfcore_grok_note) <NT_FILE>: New case.
@
text
@d3 1
a3 1
   Copyright (C) 1990-2012 Free Software Foundation, Inc.
@


1.316
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d3147 1
a3147 1
void
d3170 1
a3170 1
	  return;
d3174 1
a3174 1
  error (_("Not supported on this target."));
@


1.315
log
@2012-10-26  Pedro Alves  <palves@@redhat.com>

	* target.c (target_waitstatus_to_string): Handle
	TARGET_WAITKIND_VFORK_DONE.
@
text
@d1131 1
a1131 1
      && gdbarch_fetch_tls_load_module_address_p (target_gdbarch))
d1141 1
a1141 1
	  lm_addr = gdbarch_fetch_tls_load_module_address (target_gdbarch,
d2500 1
a2500 1
  if (!gdbarch_has_global_solist (target_gdbarch))
d2569 1
a2569 1
  if (gdbarch_has_global_breakpoints (target_gdbarch))
d3557 1
a3557 1
  return (len <= gdbarch_ptr_bit (target_gdbarch) / TARGET_CHAR_BIT);
d3571 1
a3571 1
  return target_gdbarch;
d4058 1
a4058 1
				paddress (target_gdbarch, memaddr),
d4172 1
a4172 1
		      paddress (target_gdbarch, memaddr), len,
@


1.314
log
@http://sourceware.org/ml/gdb-patches/2012-09/msg00568.html

gdb/ChangeLog

        * target.c (simple_search_memory): Include access length in
        warning message.

gdb/gdbserver/ChangeLog

        * server.c (handle_search_memory_1): Include access length in
        warning message.

gdb/testsuite/ChangeLog

        Test find command on unmapped memory.
        * gdb.base/find-unmapped.c: New file.
        * gdb.base/find-unmapped.exp: New file.
@
text
@d3877 2
@


1.313
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@d2877 3
a2879 2
      warning (_("Unable to access target memory at %s, halting search."),
	       hex_string (start_addr));
d2932 1
a2932 1
	      warning (_("Unable to access target "
d2934 1
@


1.312
log
@2012-07-20  Pedro Alves  <palves@@redhat.com>

	* linux-nat.c (linux_nat_wait): Dump the passed in target options.
	* target.c (target_wait): Likewise.
	(str_comma_list_concat_elem, do_option, target_options_to_string):
	New functions.
	* target.h (target_options_to_string): Declare.
@
text
@d208 1
a208 1
static int targetdebug = 0;
d4777 1
a4777 1
  add_setshow_zinteger_cmd ("target", class_maintenance, &targetdebug, _("\
d4783 3
a4785 3
			    NULL,
			    show_targetdebug,
			    &setdebuglist, &showdebuglist);
@


1.311
log
@	Add target-side support for dynamic printf.
	* NEWS: Mention the additional style.
	* breakpoint.h (struct bp_target_info): New fields tcommands, persist.
	(struct bp_location): New field cmd_bytecode.
	* breakpoint.c: Include format.h.
	(disconnected_dprintf): New global.
	(parse_cmd_to_aexpr): New function.
	(build_target_command_list): New function.
	(insert_bp_location): Call it.
	(remove_breakpoints_pid): Skip dprintf breakpoints.
	(print_one_breakpoint_location): Ditto.
	(dprintf_style_agent): New global.
	(dprintf_style_enums): Add dprintf_style_agent.
	(update_dprintf_command_list): Add agent case.
	(agent_printf_command): New function.
	(_initialize_breakpoint): Add new commands.
	* common/ax.def (printf): New bytecode.
	* ax.h (ax_string): Declare.
	* ax-gdb.h (gen_printf): Declare.
	* ax-gdb.c: Include cli-utils.h, format.h.
	(gen_printf): New function.
	(maint_agent_print_command): New function.
	(_initialize_ax_gdb): Add maint agent-printf command.
	* ax-general.c (ax_string): New function.
	(ax_print): Add printf disassembly.
	* Makefile.in (SFILES): Add format.c
	(COMMON_OBS): Add format.o.
	* common/format.h: New file.
	* common/format.c: New file.
	* printcmd.c: Include format.h.
	(ui_printf): Call parse_format_string.
	* remote.c (remote_state): New field breakpoint_commands.
	(PACKET_BreakpointCommands): New enum.
	(remote_breakpoint_commands_feature): New function.
	(remote_protocol_features): Add new BreakpointCommands entry.
	(remote_can_run_breakpoint_commands): New function.
	(remote_add_target_side_commands): New function.
	(remote_insert_breakpoint): Call it.
	(remote_insert_hw_breakpoint): Ditto.
	(_initialize_remote): Add new packet configuration for
	target-side breakpoint commands.
	* target.h (struct target_ops): New field
	to_can_run_breakpoint_commands.
	(target_can_run_breakpoint_commands): New macro.
	* target.c (update_current_target): Handle
	to_can_run_breakpoint_commands.

	[gdbserver]
	* Makefile.in (WARN_CFLAGS_NO_FORMAT): Define.
	(ax.o): Add it to build rule.
	(ax-ipa.o): Ditto.
	(OBS): Add format.o.
	(IPA_OBS): Add format.o.
	* server.c (handle_query): Claim support for breakpoint commands.
	(process_point_options): Add command case.
	(process_serial_event): Leave running if there are printfs in
	effect.
	* mem-break.h (any_persistent_commands): Declare.
	(add_breakpoint_commands): Declare.
	(gdb_no_commands_at_breakpoint): Declare.
	(run_breakpoint_commands): Declare.
	* mem-break.c (struct point_command_list): New struct.
	(struct breakpoint): New field command_list.
	(any_persistent_commands): New function.
	(add_commands_to_breakpoint): New function.
	(add_breakpoint_commands): New function.
	(gdb_no_commands_at_breakpoint): New function.
	(run_breakpoint_commands): New function.
	* linux-low.c (linux_wait_1): Test for and run breakpoint commands
	locally.
	* ax.c: Include format.h.
	(ax_printf): New function.
	(gdb_eval_agent_expr): Add printf opcode.

	[doc]
	* gdb.texinfo (Dynamic Printf): Mention agent style and
	disconnected dprintf.
	(Maintenance Commands): Describe maint agent-printf.
	(General Query Packets): Mention BreakpointCommands feature.
	(Packets): Document commands extension to Z0 packet.
	* agentexpr.texi (Bytecode Descriptions): Document printf
	bytecode.

	[testsuite]
	* gdb.base/dprintf.exp: Add agent style tests.
@
text
@d2632 1
d2635 1
d2637 4
a2640 3
				  "target_wait (%d, status) = %d,   %s\n",
				  PIDGET (ptid), PIDGET (retval),
				  status_string);
d2642 1
d3892 48
@


1.310
log
@gdb/
	* corefile.c (read_memory, read_stack, write_memory): Accept LEN
	argument as ssize_t.
	* gdbcore.h (read_memory, read_stack, write_memory): Likewise.
	* remote.c (remote_write_bytes_aux, remote_write_bytes): Likewise.
	* target.c (target_read_stack, target_write_memory)
	(target_write_raw_memory): Likewise.
	* target.h (target_read_stack, target_write_memory)
	(target_write_raw_memory): Likewise.
@
text
@d706 1
d936 3
@


1.309
log
@gdb/
	* symfile-mem.c: Change gdb_static_assert to ssize_t.
	(target_read_memory_bfd): Cast gdb_assert LEN to ssize_t.
	* target.c (target_read_memory): Change LEN to ssize_t.
	* target.h (target_read_memory): Change LEN to ssize_t.
@
text
@d1775 1
a1775 1
target_read_stack (CORE_ADDR memaddr, gdb_byte *myaddr, int len)
d1794 1
a1794 1
target_write_memory (CORE_ADDR memaddr, const gdb_byte *myaddr, int len)
d1813 1
a1813 1
target_write_raw_memory (CORE_ADDR memaddr, const gdb_byte *myaddr, int len)
@


1.308
log
@bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Make LEN argument
	of target_read_memory as size_t.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (elf_backend_bfd_from_remote_memory): Make LEN
	argument of target_read_memory as size_t.
	(_bfd_elf32_bfd_from_remote_memory): Likewise.
	(_bfd_elf64_bfd_from_remote_memory): Likewise.
	* elf.c (bfd_elf_bfd_from_remote_memory): Likewise.
	* elfcode.h (NAME(_bfd_elf,bfd_from_remote_memory)): Likewise.

gdb/
	* target.c (target_read_memory): Make LEN argument as size_t.
	* target.h (target_read_memory): Likewise.
@
text
@d1759 1
a1759 1
target_read_memory (CORE_ADDR memaddr, gdb_byte *myaddr, size_t len)
@


1.307
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d1759 1
a1759 1
target_read_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len)
@


1.306
log
@2012-05-22  Pedro Alves  <palves@@redhat.com>

	* target.h (store_waitstatus): Move declaration ...
	* inf-child.h (store_waitstatus): ... here.
	* target.c: Move inclusion of gdb_wait.h, and ...
	(store_waitstatus): ... this ...
	* inf-child.c: ... here.
	* linux-nat.c: Include inf-child.h.
	* rs6000-nat.c: Include inf-child.h.
	* spu-linux-nat.c: Include inf-child.h.
@
text
@d2673 1
a2673 1
target_resume (ptid_t ptid, int step, enum target_signal signal)
d2688 1
a2688 1
				target_signal_to_name (signal));
d2720 1
a2720 1
				      target_signal_to_name (i));
d2750 1
a2750 1
				      target_signal_to_name (i));
d3855 1
a3855 1
			 kind_str, target_signal_to_name (ws->value.sig));
d3858 1
a3858 1
			 kind_str, target_signal_to_name (ws->value.sig));
@


1.305
log
@2012-05-09  Pedro Alves  <palves@@redhat.com>

	* target.c (set_maintenance_target_async_permitted): Rename to ...
	(set_target_async_command): ... this.
	(show_maintenance_target_async_permitted): Rename to ...
	(show_target_async_command): ... this.
	(initialize_targets): Adjust.
@
text
@a31 1
#include "gdb_wait.h"
a3651 23
/* Helper function for child_wait and the derivatives of child_wait.
   HOSTSTATUS is the waitstatus from wait() or the equivalent; store our
   translation of that in OURSTATUS.  */
void
store_waitstatus (struct target_waitstatus *ourstatus, int hoststatus)
{
  if (WIFEXITED (hoststatus))
    {
      ourstatus->kind = TARGET_WAITKIND_EXITED;
      ourstatus->value.integer = WEXITSTATUS (hoststatus);
    }
  else if (!WIFSTOPPED (hoststatus))
    {
      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
      ourstatus->value.sig = target_signal_from_host (WTERMSIG (hoststatus));
    }
  else
    {
      ourstatus->kind = TARGET_WAITKIND_STOPPED;
      ourstatus->value.sig = target_signal_from_host (WSTOPSIG (hoststatus));
    }
}

@


1.304
log
@2012-03-07  Pedro Alves  <palves@@redhat.com>

	gdb/doc/
	* gdb.texinfo (General Query Packets): Document new
	QProgramSignals packet.
	* gdb.texinfo (Remote configuration): Mention
	"program-signals-packet".

	gdb/gdbserver/
	* linux-low.c (get_detach_signal): New.
	(linux_detach_one_lwp): Get rid of a pending SIGSTOP with SIGCONT.
	Pass on pending signals to PTRACE_DETACH.  Check the result of the
	ptrace call.
	* server.c (program_signals, program_signals_p): New.
	(handle_general_set): Handle QProgramSignals.
	* server.h (program_signals, program_signals_p): Declare.

	gdb/
	* NEWS: Mention QProgramSignals.
	* inferior.h (update_signals_program_target): Declare.
	* infrun.c: (update_signals_program_target): New.
	(handle_command): Update the target of the new program signals
	array changes.
	* remote.c (PACKET_QProgramSignals): New enum.
	(last_program_signals_packet): New global.
	(remote_program_signals): New.
	(remote_start_remote): Update the target with the program signals
	list.
	(remote_protocol_features): Add entry for QPassSignals.
	(remote_open_1): Free anc clear last_program_signals_packet.
	(init_remote_ops): Install remote_program_signals.
	* target.c (update_current_target): Adjust.
	(target_program_signals): New.
	* target.h (struct target_ops) <to_program_signals>: New field.
	(target_program_signals): Declare.
@
text
@d4658 2
a4659 2
set_maintenance_target_async_permitted (char *args, int from_tty,
					struct cmd_list_element *c)
d4671 3
a4673 3
show_maintenance_target_async_permitted (struct ui_file *file, int from_tty,
					 struct cmd_list_element *c,
					 const char *value)
d4778 2
a4779 2
			   set_maintenance_target_async_permitted,
			   show_maintenance_target_async_permitted,
@


1.303
log
@gdb:
	* common/agent.c (struct ipa_sym_addresses) <addr_capability>: New.
	(agent_capability_check, agent_capability_invalidate): New.
	(symbol_list): New array element.
	* common/agent.h (enum agent_capa): New.
	* target.c (target_pre_inferior): Call agent_capability_invalidate.

gdb/gdbserver:
	* tracepoint.c (gdb_agent_capability): New global.
	(in_process_agent_loaded_ust): Renamed to
	`in_process_agent_supports_ust'.
	Update callers.
	(in_process_agent_supports_ust): Call agent_capability_check.
	(clear_installed_tracepoints): Assert that agent supports
	agent.
@
text
@d642 1
d2732 30
@


1.302
log
@gdb:
	* target.h (struct target_ops) <to_use_agent>: New field.
	(struct target_ops) <to_can_use_agent>: New field.
	(target_use_agent, target_can_use_agent): New macro.
	* target.c (update_current_target): Update.
	* remote.c: New enum `PACKET_QAgent'.
	(remote_protocol_features): Add a new element.
	(remote_use_agent, remote_can_use_agent): New.
	(init_remote_ops): Initialize field `can_use_agent' with
	remote_can_use_agent.  Intiailize field `use_agent' with
	remote_use_agent.
	* common/agent.c (use_agent): New global.
	* common/agent.h: Declare it.
	* tracepoint.c (info_static_tracepoint_markers_command): Add
	comment.
	* Makefile.in (SFILES): Add common/agent.c and agent.c.
	(COMMON_OBS): Add common/agent.o and agent.o
	(common-agent.o): New rule.
	* agent.c: New.

gdb/doc:
	* gdb.texinfo (In-Process Agent): New node.
	Document new commands.
	(General Query Packets): Add packet `QAgent'.

gdb/gdbserver:
	* linux-low.c (linux_supports_agent): New.
	(linux_target_ops): Initialize field `supports_agent' with
	linux_supports_agent.
	* target.h (struct target_ops) <supports_agent>: New.
	(target_supports_agent): New macro.
	* server.c (handle_general_set): Handle packet 'QAgent'.
	(handle_query): Send `QAgent+'.
	* Makefile.in (server.o): Depends on agent.h.
@
text
@d46 1
d2504 2
@


1.301
log
@2012-03-02  Tom Tromey  <tromey@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	PR breakpoints/13776:
	* breakpoint.c (breakpoint_init_inferior): Delete step-resume
	breakpoints.
	(delete_longjmp_breakpoint_at_next_stop): New.
	* breakpoint.h (delete_longjmp_breakpoint_at_next_stop): Declare.
	* target.c (generic_mourn_inferior): Call mark_breakpoints_out
	before deleting the inferior.  Add comments.
	* thread.c (clear_thread_inferior_resources): Don't delete lonjmp
	breakpoints immediately, but only on next stop.  Move that code
	next to where we mark other breakpoints for deletion.
@
text
@d701 2
d934 6
@


1.300
log
@2012-02-24  Luis Machado  <lgustavo@@codesourcery.com>

	* remote.c (remote_supports_cond_breakpoints): New forward
	declaration.
	(remote_add_target_side_condition): New function.
	(remote_insert_breakpoint): Add target-side breakpoint
	conditional if supported.
	(remote_insert_hw_breakpoint): Likewise.
	(init_remote_ops): Set to_supports_evaluation_of_breakpoint_conditions
	hook.

	* target.c (update_current_target): Inherit
	to_supports_evaluation_of_breakpoint_conditions.
	Default to_supports_evaluation_of_breakpoint_conditions to return_zero.

	* target.h (struct target_ops)
	<to_supports_evaluation_of_breakpoint_conditions>: New field.
	(target_supports_evaluation_of_breakpoint_conditions): New #define.

	* breakpoint.c (get_first_locp_gte_addr): New forward declaration.
	(condition_evaluation_both, condition_evaluation_auto,
	condition_evaluation_host, condition_evaluation_target,
	condition_evaluation_enums, condition_evaluation_mode_1,
	condition_evaluation_mode): New	static globals.
	(translate_condition_evaluation_mode): New function.
	(breakpoint_condition_evaluation_mode): New function.
	(gdb_evaluates_breakpoint_condition_p): New function.
	(ALL_BP_LOCATIONS_AT_ADDR): New helper macro.
	(mark_breakpoint_modified): New function.
	(mark_breakpoint_location_modified): New function.
	(set_condition_evaluation_mode): New function.
	(show_condition_evaluation_mode): New function.
	(bp_location_compare_addrs): New function.
	(get_first_location_gte_addr): New helper function.
	(set_breakpoint_condition): Free condition bytecode if locations
	has become unconditional.  Call mark_breakpoint_modified (...).
	(condition_command): Call update_global_location_list (1) for
	breakpoints.
	(breakpoint_xfer_memory): Use is_breakpoint (...).
	(is_breakpoint): New function.
	(parse_cond_to_aexpr): New function.
	(build_target_condition_list): New function.
	(insert_bp_location): Handle target-side conditional
	breakpoints and call build_target_condition_list (...).
	(update_inserted_breakpoint_locations): New function.
	(insert_breakpoint_locations): Handle target-side conditional
	breakpoints.
	(bpstat_check_breakpoint_conditions): Add comment.
	(bp_condition_evaluator): New function.
	(bp_location_condition_evaluator): New function.
	(print_breakpoint_location): Print information on where the condition
	will be evaluated.
	(print_one_breakpoint_location): Likewise.
	(init_bp_location): Call mark_breakpoint_location_modified (...) for
	breakpoint location.
	(force_breakpoint_reinsertion): New functions.
	(update_global_location_list): Handle target-side breakpoint
	conditions.
	Reinsert locations that are already inserted if conditions have
	changed.
	(bp_location_dtor): Free agent expression bytecode.
	(disable_breakpoint): Call mark_breakpoint_modified (...).
	Call update_global_location_list (...) with parameter 1 for breakpoints.
	(disable_command): Call mark_breakpoint_location_modified (...).
	Call update_global_location_list (...) with parameter 1 for breakpoints.
	(enable_breakpoint_disp): Call mark_breakpoint_modified (...).
	(enable_command): mark_breakpoint_location_modified (...).
	(_initialize_breakpoint): Update documentation and add
	condition-evaluation breakpoint subcommand.

	* breakpoint.h: Include ax.h.
	(condition_list): New data structure.
	(condition_status): New enum.
	(bp_target_info) <cond_list>: New field.
	(bp_location) <condition_changed, cond_bytecode>: New fields.
	(is_breakpoint): New prototype.
@
text
@d3586 5
d3597 3
d3601 1
@


1.299
log
@	* inf-child.c: Include "gdb_stat.h" instead of <sys/stat.h>.
	* linux-tdep.c (linux_info_proc): Avoid ARI coding style warning.
	* target.c (target_fileio_pwrite): Remove buffer address from
	debug output.
	(target_fileio_pread): Likewise.
@
text
@d702 1
d929 3
@


1.298
log
@ChangeLog:

	* defs.h (enum info_proc_what): Moved here from linux-nat.c
	* infcmd.c: (info_proc_cmd_1): New function.
	(info_proc_cmd): New function, moved here from equivalent routine
	orignally in linux-nat.c.
	(info_proc_cmd_mappings): Likewise.
	(info_proc_cmd_stat): Likewise.
	(info_proc_cmd_status): Likewise.
	(info_proc_cmd_cwd): Likewise.
	(info_proc_cmd_cmdline): Likewise.
	(info_proc_cmd_exe): Likewise.
	(info_proc_cmd_all): Likewise.
	(_initialize_infcmd): Install "info proc" command and subcommands.

	* target.h (struct target_ops): Add to_info_proc.
	(target_info_proc): Add prototype.
	* target.c (target_info_proc): New function.

	* procfs.c (procfs_info_proc): Add prototype.
	(info_proc_cmd): Rename into ...
	(procfs_info_proc): ... this.  Update argument types as appropriate
	for a to_info_proc implementation.  Handle "what" argument.
	(procfs_target): Install procfs_info_proc.
	(_initialize_procfs): No longer install "info proc" command.

	* linux-nat.c: (enum info_proc_what): Remove.
	(linux_nat_info_proc_cmd_1): Rename into ...
	(linux_nat_info_proc): ... this.  Update argument types as appropriate
	for a to_info_proc implementation.
	(linux_nat_info_proc_cmd): Remove.
	(linux_nat_info_proc_cmd_mappings): Likewise.
	(linux_nat_info_proc_cmd_stat): Likewise.
	(linux_nat_info_proc_cmd_status): Likewise.
	(linux_nat_info_proc_cmd_cwd): Likewise.
	(linux_nat_info_proc_cmd_cmdline): Likewise.
	(linux_nat_info_proc_cmd_exe): Likewise.
	(linux_nat_info_proc_cmd_all): Likewise.
	(linux_target_install_ops): Install linux_nat_info_proc.
	(_initialize_linux_nat): No longer install "info proc" command
	and subcommands.

testsuite/ChangeLog:

	* gdb.base/info-proc.exp: Also run on remote targets.  Main
	"info proc" command is now always present; whether target supports
	actual info proc operation is detected when attempting to issue
	the command.
@
text
@d3261 1
a3261 1
				"target_fileio_pwrite (%d,%p,%d,%s) "
d3263 1
a3263 1
				fd, write_buf, len, pulongest (offset),
d3291 1
a3291 1
				"target_fileio_pread (%d,%p,%d,%s) "
d3293 1
a3293 1
				fd, read_buf, len, pulongest (offset),
@


1.297
log
@ChangeLog:

	* configure.ac [AC_CHECK_FUNCS]: Check for readlink.
	* config.in, configure: Regenerate.

	* target.h (struct target_ops): Add to_fileio_readlink.
	(target_fileio_readlink): Add prototype.
	* target.c (target_fileio_readlink): New function.

	* inf-child.c: Conditionally include <sys/param.h>.
	(inf_child_fileio_readlink): New function.
	(inf_child_target): Install it.

	* remote.c (PACKET_vFile_readlink): New enum value.
	(remote_hostio_readlink): New function.
	(init_remote_ops): Install it.
	(_initialize_remote): Handle vFile:readlink packet type.

doc/ChangeLog:

	* gdb.texinfo (Remote Configuration): Document
	"set remote hostio-readlink-packet" command.
	(General Query Packets): Document vFile:readlink packet.

gdbserver/ChangeLog:

	* hostio.c (handle_readlink): New function.
	(handle_vFile): Call it to handle "vFile:readlink" packets.
@
text
@d3090 32
@


1.296
log
@2012-01-20  Pedro Alves  <palves@@redhat.com>
	    Ulrich Weigand  <ulrich.weigand@@linaro.org>

	* configure.ac [AC_CHECK_FUNCS]: Check for pread and pwrite.
	* config.in, configure: Regenerate.

	* target.h (struct target_ops): Add to_fileio_open, to_fileio_pwrite,
	to_fileio_pread, to_fileio_close, to_fileio_unlink.
	(target_fileio_open): Add prototype.
	(target_fileio_pwrite): Likewise.
	(target_fileio_pread): Likewise.
	(target_fileio_close): Likewise.
	(target_fileio_unlink): Likewise.
	(target_fileio_read_alloc): Likewise.
	(target_fileio_read_stralloc): Likewise.

	* target.c: Include "gdb/fileio.h".
	(target_read_stralloc): Accept trailing, but not embedded NUL bytes.
	(default_fileio_target): New function.
	(target_fileio_open): Likewise.
	(target_fileio_pwrite): Likewise.
	(target_fileio_pread): Likewise.
	(target_fileio_close): Likewise.
	(target_fileio_unlink): Likewise.
	(target_fileio_close_cleanup): Likewise.
	(target_fileio_read_alloc_1): Likewise.
	(target_fileio_read_alloc): Likewise.
	(target_fileio_read_stralloc): Likewise.

	* inf-child.c: Include "gdb/fileio.h", <sys/types.h>, <sys/stat.h>,
	<fcntl.h>, and <unistd.h>.
	(inf_child_fileio_open_flags_to_host): New function.
	(inf_child_errno_to_fileio_error): Likewise.
	(inf_child_fileio_open): Likewise.
	(inf_child_fileio_pwrite): Likewise.
	(inf_child_fileio_pread): Likewise.
	(inf_child_fileio_close): Likewise.
	(inf_child_fileio_unlink): Likewise.
	(inf_child_target): Install to_fileio routines.

	* remote.c (init_remote_ops): Install to_fileio routines.
@
text
@d3321 27
@


1.295
log
@2012-01-19  Pedro Alves  <palves@@redhat.com>

	* linux-nat.c (linux_nat_close): Call linux_nat_is_async_p and
	linux_nat_async directly instead of going through the target
	vector.
	* target.c (unpush_target): Close target after unpushing it, not
	before.
@
text
@d45 1
d2348 1
a2348 1
  LONGEST transferred;
d2359 10
a2368 4
  if (strlen (buffer) < transferred)
    warning (_("target object %d, annex %s, "
	       "contained unexpected null characters"),
	     (int) object, annex ? annex : "(none)");
d3169 271
@


1.294
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1013 2
d1016 1
a1016 9
    return 0;			/* Didn't find target_ops, quit now.  */

  /* NOTE: cagney/2003-12-06: In '94 the close call was made
     unconditional by moving it to before the above check that the
     target was in the target stack (something about "Change the way
     pushing and popping of targets work to support target overlays
     and inheritance").  This doesn't make much sense - only open
     targets should be closed.  */
  target_close (t, 0);
d1025 5
@


1.293
log
@2011-12-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.c (breakpoint_restore_shadows): Rename to ...
	(breakpoint_xfer_memory): ... this.  Change prototype.  Handle
	memory writes too.
	* breakpoint.h (breakpoint_restore_shadows): Delete.
	(breakpoint_xfer_memory): Declare.
	* mem-break.c (default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Use target_write_raw_memory.
	(memory_xfer_partial): Rename to ...
	(memory_xfer_partial_1): ... this.  Don't mask out breakpoints
	here.
	(memory_xfer_partial): New.
	(target_write_raw_memory): New.
	* target.h (target_write_raw_memory): New.

	gdb/testsuite/
	* gdb.base/break-always.exp: Test changing memory at addresses
	with breakpoints inserted.
@
text
@d3 1
a3 3
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.293.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1990-2012 Free Software Foundation, Inc.
@


1.292
log
@	* NEWS: Mention tracepoint additions.
	* breakpoint.h (struct tracepoint): New field traceframe_usage.
	* breakpoint.c (print_one_breakpoint_location): Identify
	tracepoints as such when reporting hit counts, report
	trace buffer usage.
	(create_tracepoint_from_upload): Copy status info.
	* tracepoint.h (struct trace_status): Rename error_desc to stop_desc,
	add fields user_name, notes, start_time, stop_time.
	(struct uploaded_tp): Add fields hit_count, traceframe_usage.
	* tracepoint.c (trace_user): New global.
	(trace_notes): New global.
	(trace_stop_notes): New global.
	(start_tracing): Add argument and trace note handling.
	(stop_tracing): Ditto.
	(trace_start_command): Add notes argument.
	(trace_stop_command): Ditto.
	(trace_status_command): Report additional status info.
	(trace_status_mi): Similarly.
	(trace_save): Update, record tracepoint status.
	(set_disconnected_tracing): Call target method directly.
	(send_disconnected_tracing_value): Remove.
	(set_trace_user): New function.
	(set_trace_notes): New function.
	(set_trace_stop_notes): New function.
	(parse_trace_status): Handle additional status.
	(parse_tracepoint_status): New function.
	(parse_tracepoint_definition): Call it.
	(tfile_get_tracepoint_status): New function.
	(init_tfile_ops): Use it.
	(_initialize_tracepoint): Add new setshows.
	* target.h (struct target_ops): New methods to_get_tracepoint_status
	and to_set_trace_notes.
	(target_get_tracepoint_status): New macro.
	(target_set_trace_notes): New macro.
	* target.c (update_current_target): Add new methods.
	* remote.c (remote_get_tracepoint_status): New function.
	(remote_set_trace_notes): New function.
	(init_remote_ops): Add them.
	* mi/mi-main.c (mi_cmd_trace_start): Add argument to call.
	(mi_cmd_trace_stop): Ditto.

	* tracepoint.c (struct tracepoint): New field traceframe_usage.
	(tracing_start_time): New global.
	(tracing_stop_time): New global.
	(tracing_user_name): New global.
	(tracing_notes): New global.
	(tracing_stop_note): New global.
	(cmd_qtstart): Set traceframe_usage, start_time.
	(stop_tracing): Set stop_time.
	(cmd_qtstatus): Report additional status.
	(cmd_qtp): New function.
	(handle_tracepoint_query): Call it.
	(cmd_qtnotes): New function.
	(handle_tracepoint_general_set): Call it.
	(get_timestamp): Rename from tsv_get_timestamp.

	* gdb.texinfo (Starting and Stopping Trace Experiments): Document
	note-related options and variables.
	(Tracepoint Packets): Document packet changes.

	* gdb.trace/tstatus.exp: New.
	* gdb.trace/actions.c: Include string.h.
@
text
@d1391 3
a1393 3
memory_xfer_partial (struct target_ops *ops, enum target_object object,
		     void *readbuf, const void *writebuf, ULONGEST memaddr,
		     LONGEST len)
a1399 4
  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    return 0;

d1550 1
a1550 5
	{
	  if (readbuf && !show_memory_breakpoints)
	    breakpoint_restore_shadows (readbuf, memaddr, reg_len);
	  return res;
	}
a1578 3
  if (res > 0 && readbuf != NULL && !show_memory_breakpoints)
    breakpoint_restore_shadows (readbuf, memaddr, reg_len);

d1598 42
d1795 19
@


1.291
log
@2011-11-14  Stan Shebs  <stan@@codesourcery.com>
	    Kwok Cheung Yeung  <kcy@@codesourcery.com>

	* NEWS: Document shorter fast tracepoints and qTMinFTPILen packet.
	* i386-tdep.c (i386_fast_tracepoint_valid_at): Query target for
	the minimum instruction size for fast tracepoints.
	* target.h (struct target_ops): Add new method
	to_get_min_fast_tracepoint_insn_len.
	(target_get_min_fast_tracepoint_insn_len): New.
	* target.c (update_current_target): Set up new target operation.
	* remote.c (remote_write_bytes_aux): Fix typo.
	(remote_get_min_fast_tracepoint_insn_len): New.
	(init_remote_ops): Initialize new field.

	* gdb.texinfo (Create and Delete Tracepoints): Describe what is
	needed to get shorter fast tracepoints.
	(Tracepoint Packets): Document new qTMinFTPILen packet.

	* linux-x86-low.c (small_jump_insn): New.
	(i386_install_fast_tracepoint_jump_pad): Add arguments for
	trampoline and error message, build a trampoline and issue a small
	jump instruction to it.
	(x86_install_fast_tracepoint_jump_pad): Add arguments for
	trampoline and error message.
	(x86_get_min_fast_tracepoint_insn_len): New.
	(the_low_target): Add call to x86_get_min_fast_tracepoint_insn_len.
	* linux-low.h (struct linux_target_ops): Add arguments to
	install_fast_tracepoint_jump_pad operation, add new operation.
	* linux-low.c (linux_install_fast_tracepoint_jump_pad): Add
	arguments.
	(linux_get_min_fast_tracepoint_insn_len): New function.
	(linux_target_op): Add new operation.
	* tracepoint.c (gdb_trampoline_buffer): New IPA variable.
	(gdb_trampoline_buffer_end): Ditto.
	(gdb_trampoline_buffer_error): Ditto.
	(struct ipa_sym_addresses): Add fields for new IPA variables.
	(symbol_list): Add entries for new IPA variables.
	(struct tracepoint): Add fields to hold the address range of the
	trampoline used by the tracepoint.
	(trampoline_buffer_head): New static variable.
	(trampoline_buffer_tail): Ditto.
	(claim_trampoline_space): New function.
	(have_fast_tracepoint_trampoline_buffer): New function.
	(clone_fast_tracepoint): Fill in trampoline fields of tracepoint
	structure.
	(install_fast_tracepoint): Ditto, also add error buffer argument.
	(cmd_qtminftpilen): New function.
	(handle_tracepoint_query): Add response to qTMinFTPILen packet.
	(fast_tracepoint_from_trampoline_address): New function.
	(fast_tracepoint_collecting): Handle trampoline as part of jump
	pad space.
	(set_trampoline_buffer_space): New function.
	(initialize_tracepoint): Initialize new IPA variables.
	* target.h (struct target_ops): Add arguments to
	install_fast_tracepoint_jump_pad operation, add new
	get_min_fast_tracepoint_insn_len operation.
	(target_get_min_fast_tracepoint_insn_len): New.
	(install_fast_tracepoint_jump_pad): Add arguments.
	* server.h (IPA_BUFSIZ): Define.
	* linux-i386-ipa.c: Include extra header files.
	(initialize_fast_tracepoint_trampoline_buffer): New function.
	(initialize_low_tracepoint): Call it.
	* server.h (set_trampoline_buffer_space): Declare.
	(claim_trampoline_space): Ditto.
	(have_fast_tracepoint_trampoline_buffer): Ditto.

	* gdb.trace/ftrace.c: New.
	* gdb.trace/ftrace.exp: New.
@
text
@d685 1
d696 1
d878 3
d911 3
@


1.290
log
@gdb/
	* remote.c (struct remote_state): <install_in_trace> new field.
	(PACKET_InstallInTrace): New enum value.
	(remote_install_in_trace_feature): Support InstallInTrace.
	(remote_supports_install_in_trace): Likewise.
	(remote_protocol_features): Likewise.
	(_initialize_remote): Likewise.
	(remote_can_download_tracepoint): New.
	* target.h (struct target): New field
	`to_can_download_tracepoint'.
	(target_can_download_tracepoint): New macro.
	* target.c (update_current_target): Update.
	* breakpoint.h (struct bp_location): Add comment on field
	`duplicate'.
	(should_be_inserted): Don't differentiate breakpoint and tracepoint.
	(remove_breakpoints): Don't remove tracepoints.
	(tracepoint_locations_match ): New.
	(breakpoint_locations_match): Call it.
	(disable_breakpoints_in_unloaded_shlib): Handle tracepoint.
	(download_tracepoint_locations): New.
	(update_global_location_list): Call it.
	* tracepoint.c (find_matching_tracepoint): Delete.
	(find_matching_tracepoint_location): Renamed from
	find_matching_tracepoint.  Return bp_location rather than
	tracepoint.
	(merge_uploaded_tracepoints): Set `inserted' field to 1 if
	tracepoint is found.

gdb/doc/
	* gdb.texinfo (Create and Delete Tracepoints): Describe changed
	behavior of tracepoint.
	(General Query Packets): New feature InstallInTrace.
	(Remote Configuration): Document "set remote
	install-in-trace-packet".

gdb/gdbserver/
	* server.c (handle_query): Handle InstallInTrace for qSupported.
	* tracepoint.c (add_tracepoint): Sort list.
	(install_tracepoint, download_tracepoint): New.
	(cmd_qtdp): Call them to install and download tracepoints.
	(sort_tracepoints): Removed.
	(cmd_qtstart): Update.

gdb/testsuite/
	* gdb.trace/change-loc-1.c: New.
	* gdb.trace/change-loc-2.c: New.
	* gdb.trace/change-loc.c: New.
	* gdb.trace/change-loc.exp:  New.
	* gdb.trace/change-loc.h:  New.
	* gdb.trace/trace-break.c (marker): Define new symbol.
	* gdb.trace/trace-break.exp (break_trace_same_addr_5):
        New.
	(break_trace_same_addr_6): New.
@
text
@d692 1
d897 3
@


1.289
log
@	* target.h (struct target): <to_download_tracepoint> Change type
	of parameter from tracepoint to bp_location.
	* target.c (update_current_target): Update.
	* tracepoint.c (start_tracing): Update.
	* remote.c (remote_download_tracepoint): Remove loop for each location
	of a tracepoint.
@
text
@d678 1
d854 3
@


1.288
log
@2011-11-10  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* target.c (target_waitstatus_to_string): Handle
	TARGET_WAITKIND_NO_RESUMED.
@
text
@d851 1
a851 1
	    (void (*) (struct breakpoint *))
@


1.287
log
@2011-11-02  Stan Shebs  <stan@@codesourcery.com>

	String collection for tracepoints.
	* NEWS: Mention string collection.
	* common/ax.def (tracenz): New bytecode.
	* ax-gdb.h (trace_string_kludge): Declare.
	* ax-gdb.c: Include valprint.h and c-lang.h.
	(trace_string_kludge): New global.
	(gen_traced_pop): Add string case.
	(agent_command): Add string case.
	* tracepoint.h (decode_agent_options): Declare.
	* tracepoint.c: Include cli-utils.h.
	(decode_agent_options): New function.
	(validate_actionline): Call it.
	(encode_actions_1): Ditto.
	* target.h (struct target_ops): New method to_supports_string_tracing.
	(target_supports_string_tracing): New macro.
	* target.c (update_current_target): Add to_supports_string_tracing.
	* remote.c (struct remote_state): New field string_tracing.
	(remote_string_tracing_feature): New function.
	(remote_protocol_features): New feature tracenz.
	(remote_supports_string_tracing): New function.
	(init_remote_ops): Set to_supports_string_tracing.

	* tracepoint.c (agent_mem_read_string): New function.
	(eval_agent_expr): Call it for tracenz.
	* server.c (handle_query): Report support for tracenz.

	* gdb.texinfo (Tracepoint Action Lists): Document collect/s.
	(General Query Packets): Describe tracenz feature.
	* agentexpr.texi (Bytecode Descriptions): Describe tracenz.

	* gdb.trace/collection.c: Add code using strings.
	* gdb.trace/collection.exp: Add tests of string collection.
@
text
@d3446 2
@


1.286
log
@	* inferior.h (disable_randomization): Declare.
	* infrun.c (disable_randomization): New global variable.
	(show_disable_randomization): New function.
	(set_disable_randomization): Likewise.
	(_initialize_infrun): Install set/show disable-randomization
	commands.
	* linux-nat.c (disable_randomization): Remove.
	(show_disable_randomization): Likewise.
	(set_disable_randomization): Likewise.
	(_initialize_linux_nat): No longer install set/show
	disable-randomization commands here.
	(linux_nat_supports_disable_randomization): New function.
	(linux_nat_add_target): Install it.
	* remote.c (PACKET_QDisableRandomization): New enum value.
	(remote_protocol_packets): Support QDisableRandomization.
	(_initialize_remote): Likewise.
	(remote_supports_disable_randomization): New function.
	(init_remote_ops): Install it.
	(extended_remote_supports_disable_randomization): New function.
	(init_extended_remote_ops): Install it.
	(extended_remote_disable_randomization): New function.
	(extended_remote_create_inferior_1): Call it.
	* target.h (struct target_ops): Add to_supports_disable_randomization.
	(target_supports_disable_randomization): Add prototype.
	* target.c (target_supports_disable_randomization): New function.
	(find_default_supports_disable_randomization): Likewise.
	(init_dummy_target): Install it.

doc/
	* gdb.texinfo (Starting your Program): "set disable-randomization"
	is no longer Linux-specific.
	(Remote Configuration): Document "set remote
	disable-randomization-packet".
	(General Query Packets): Document "QDisableRandomization" packet
	and add it to "qSupported" list.

gdbserver/
	* configure.ac: Check support for personality routine.
	* configure: Regenerate.
	* config.in: Likewise.
	* linux-low.c: Include <sys/personality.h>.
	Define ADDR_NO_RANDOMIZE if necessary.
	(linux_create_inferior): Disable address space randomization when
	forking inferior, if requested.
	(linux_supports_disable_randomization): New function.
	(linux_target_ops): Install it.
	* server.h (disable_randomization): Declare.
	* server.c (disable_randomization): New global variable.
	(handle_general_set): Handle QDisableRandomization.
	(handle_query): Likewise for qSupported.
	(main): Support --disable-randomization and --no-disable-randomization
	command line arguments.
	* target.h (struct target_ops): Add supports_disable_randomization.
	(target_supports_disable_randomization): New macro.
@
text
@d675 1
d844 3
@


1.285
log
@2011-06-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* infcall.c (run_inferior_call): Don't mask async.  Instead force
	a synchronous wait, if the target can async.

	* target.h (struct target_ops): Delete to_async_mask.
	(target_async_mask): Delete.
	* target.c (update_current_target): Delete references to to_async_mask.
	* linux-nat.c (linux_nat_async_mask_value): Delete.
	(linux_nat_is_async_p, linux_nat_can_async_p): Remove references
	to linux_nat_async_mask_value.
	(linux_nat_async_mask): Delete.
	(linux_nat_async, linux_nat_close): Remove references to
	linux_nat_async_mask_value.
	* record.c (record_async_mask_value): Delete.
	(record_async): Remove references to record_async_mask_value.
	(record_async_mask): Delete.
	(record_can_async_p, record_is_async_p): Remove references to
	record_async_mask_value.
	(init_record_ops, init_record_core_ops): Remove references to
	record_async_mask.
	* remote.c (remote_async_mask_value): Delete.
	(init_remote_ops): Remove reference to remote_async_mask.
	(remote_can_async_p, remote_is_async_p): Remove references to
	remote_async_mask_value.
	(remote_async): Remove references to remote_async_mask_value.
	(remote_async_mask): Delete.

	* infrun.c (fetch_inferior_event): Don't claim registers changed
	if the current thread is already not executing.
@
text
@d3016 22
d3282 2
@


1.284
log
@2011-05-26  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* record.c: Include event-loop.h, inf-loop.h.
	(record_beneath_to_async): New global.
	(tmp_to_async): New global.
	(record_async_inferior_event_token): New global.
	(record_open_1): Don't error out if async is enabled.
	(record_open): Handle to_async.  Create an async event source in
	the event loop.
	(record_close): Delete the async event source.
	(record_resumed): New global.
	(record_execution_dir): New global.
	(record_resume, record_core_resume): Set them.  Register the
	target on the event loop.
	(record_wait): Rename to ...
	(record_wait_1): ... this.  Add more debug output.  Handle
	TARGET_WNOHANG, and the target beneath returning
	TARGET_WAITKIND_IGNORE.
	(record_wait): Reimplement on top of record_wait_1.
	(record_async_mask_value): New global.
	(record_async, record_async_mask, record_can_async_p)
	(record_is_async_p, record_execution_direction): New functions.
	(init_record_ops, init_record_core_ops): Install new methods.
	* infrun.c (fetch_inferior_event): Temporarily switch the global
	execution direction to the direction the target was going.
	(execution_direction): Change type to int.
	* target.c (default_execution_direction): New function.
	(update_current_target): Inherit and de_fault
	to_execution_direction.
	* target.h (struct target_ops) <to_execution_direction>: New
	field.
	(target_execution_direction): New macro.
	* inferior.h (execution_direction): Change type to int.
@
text
@a661 1
      INHERIT (to_async_mask, t);
a830 3
  de_fault (to_async_mask,
	    (int (*) (int))
	    return_one);
@


1.283
log
@Add support for enabling and disabling tracepoints while a trace
experiment is still running.

gdb/
	* breakpoint.c (disable_breakpoint): Disable all locations
	associated with a tracepoint on target if a trace experiment is
	running.
	(disable_command): Disable a specific tracepoint location on target if
	a trace	experiment is running.
	(do_enable_breakpoint): Enable all locations associated with a
	tracepoint on target if a trace experiment is running.
	(enable_command) Enable a specific tracepoint location on target if a
	trace experiment is running.
	* target.c (update_current_target): Add INHERIT and de_fault clauses for
	to_supports_enable_disable_tracepoint, to_enable_tracepoint and
	to_disable_tracepoint.
	* target.h: Add declaration of struct bp_location.
	(struct target_ops): Add new functions
	to_supports_enable_disable_tracepoint, to_enable_tracepoint and
	to_disable_tracepoint to target operations.
	(target_supports_enable_disable_tracepoint): New macro.
	(target_enable_tracepoint): New macro.
	(target_disable_tracepoint): New macro.
	* remote.c (struct remote_state): Add new field.
	(remote_enable_disable_tracepoint_feature): New.
	(remote_protocol_features): Add new entry.
	(remote_supports_enable_disable_tracepoint): New.
	(remote_enable_tracepoint): New.
	(remote_disable_tracepoint): New.
	(init_remote_ops): Add remote_enable_tracepoint,
	remote_disable_tracepoint and remote_supports_enable_disable_tracepoint
	to remote operations.
	* tracepoint.c (start_tracing): Allow tracing to start without any
	tracepoints enabled with just a warning if they can be re-enabled
	later.
	* NEWS: Add news item for the new behaviour of the enable and disable
	GDB commands when applied to tracepoints.
	Add news items for the new remote packets QTEnable and QTDisable.

gdb/doc/
	* gdb.texinfo: Document change in the behaviour of the enable and
	disable GDB commands when applied to tracepoints.
	Document the EnableDisableTracepoints remote stub feature.
	Document QTEnable and QTDisable in the list of tracepoint packets.

gdb/gdbserver/
	* server.c (handle_query): Add EnableDisableTracepoints to the list
	of supported features.
	* tracepoint.c (clear_installed_tracepoints): Uninstall	disabled
	tracepoints.
	(cmd_qtenable_disable): New.
	(cmd_qtstart): Install tracepoints even if disabled.
	(handle_tracepoint_general_set): Add call to cmd_qtenable_disable on
	receiving a QTEnable or QTDisable packet.
	(gdb_collect): Skip data collection if fast tracepoint is disabled.
	(ust_marker_to_static_tracepoint): Do not ignore disabled static
	tracepoints.
	(gdb_probe): Skip data collection if static tracepoint is disabled.
@
text
@d547 12
d669 1
d913 2
@


1.282
log
@2011-05-06  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Implement support for PowerPC BookE masked watchpoints.

gdb/
	* NEWS: Mention masked watchpoint support.  Create "Changed commands"
	section.
	* breakpoint.h (struct breakpoint_ops) <works_in_software_mode>: New
	method.  Initialize to NULL in all existing breakpoint_ops instances.
	(struct breakpoint) <hw_wp_mask>: New field.
	* breakpoint.c (is_masked_watchpoint): Add prototype.
	(update_watchpoint): Don't set b->val for masked watchpoints.  Call
	breakpoint's breakpoint_ops.works_in_software_mode if available.
	(watchpoints_triggered): Handle the case of a hardware masked
	watchpoint trigger.
	(watchpoint_check): Likewise.
	(works_in_software_mode_watchpoint): New function.
	(insert_masked_watchpoint, remove_masked_watchpoint)
	(resources_needed_masked_watchpoint)
	(works_in_software_mode_masked_watchpoint, print_it_masked_watchpoint)
	(print_one_detail_masked_watchpoint, print_mention_masked_watchpoint)
	(print_recreate_masked_watchpoint, is_masked_watchpoint): New
	functions.
	(masked_watchpoint_breakpoint_ops): New structure.
	(watch_command_1): Check for the existence of the `mask' parameter.
	Set b->ops according to the type of hardware watchpoint being created.
	* ppc-linux-nat.c (ppc_linux_insert_mask_watchpoint)
	(ppc_linux_remove_mask_watchpoint)
	(ppc_linux_masked_watch_num_registers): New functions.
	(_initialize_ppc_linux_nat): Initialize to_insert_mask_watchpoint,
	to_remove_mask_watchpoint and to_masked_watch_num_registers.
	* target.c (update_current_target): Mention to_insert_mask_watchpoint,
	to_remove_mask_watchpoint, and to_masked_watch_num_registers.
	(target_insert_mask_watchpoint, target_remove_mask_watchpoint)
	(target_masked_watch_num_registers): New functions.
	* target.h (struct target_ops) <to_insert_mask_watchpoint>,
	<to_remove_mask_watchpoint>, <to_masked_watch_num_registers>: New
	methods.
	(target_insert_mask_watchpoint, target_remove_mask_watchpoint)
	(target_masked_watch_num_registers): Add prototypes.

gdb/doc/
	* gdb.texinfo (Set Watchpoints): Document mask parameter.
	(PowerPC Embedded): Mention support of masked watchpoints.
@
text
@d662 1
d666 2
d831 3
d843 6
@


1.281
log
@	* target.h (struct target_ops): Remove to_notice_signals;
	add to_pass_signals.
	(target_notice_signals): Remove.
	(target_pass_signals): Add prototype.
	* target.c (update_current_target): Remove to_notice_signals;
	mention to_pass_signals.
	(target_pass_signals): New function.
	(debug_to_notice_signals): Remove.
	(setup_target_debug): Do not install debug_to_notice_signals.

	* infrun.c (signal_pass): New global.
	(resume): Call target_pass_signals.
	(handle_inferior_event): Report all signals while stepping over
	non-steppable watchpoint.  Reset trap_expected to ensure breakpoints
	are re-inserted when stepping over a signal handler.
	(signal_cache_update): New function.
	(signal_stop_update): Call it.
	(signal_print_update): Likewise.
	(signal_pass_update): Likewise.
	(handle_command): Call signal_cache_update and target_pass_signals
	instead of target_notice_signals.
	(_initialize_infrun): Initialize signal_pass.

	* linux-nat.c (pass_mask): New global.
	(linux_nat_pass_signals): New function.
	(linux_nat_create_inferior): Report all signals initially.
	(linux_nat_attach): Likewise.
	(linux_nat_resume): Use pass_mask to decide whether to directly
	handle an inferior signal.
	(linux_nat_wait_1): Likewise.
	(linux_nat_add_target): Install to_pass_signals callback.

	* nto-procfs.c (notice_signals): Remove.
	(procfs_resume): Do not call notice_signals.
	(procfs_notice_signals): Remove.
	(procfs_pass_signals): New function.
	(init_procfs_ops): Install to_pass_signals callback instead of
	to_notice_signals callback.
	(_initialize_procfs): Report all signals initially.

	* procfs.c (procfs_notice_signals): Remove.
	(procfs_pass_signals): New function.
	(procfs_target): Install to_pass_signals callback instead of
	to_notice_signals callback.
	(register_gdb_signals): Remove.
	(procfs_debug_inferior): Report all signals initially.
	(procfs_init_inferior): Remove redundant register_gdb_signals call.

	* remote.c (remote_pass_signals): Add numsigs and pass_signals
	parameters; use them instead of calling signal_..._state routines.
	(remote_notice_signals): Remove.
	(remote_start_remote): Report all signals initially.
	(remote_resume): Do not call remote_pass_signals.
	(_initialize_remote): Install to_pass_signals callback instead of
	to_notice_signals callback.
@
text
@d598 2
d607 1
d3524 69
@


1.280
log
@2011-03-31  Thiago Jung Bauermann  <bauerman@@br.ibm.com>
	    Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>

	Implement support for PowerPC BookE ranged breakpoints.

gdb/
	* NEWS: Mention support for ranged breakpoints on embedded PowerPC.
	* breakpoint.h (struct bp_target_info) <length>: New member
	variable.
	(struct breakpoint_ops) <breakpoint_hit>: Take struct bp_location
	instead of struct breakpoint as argument, and also add ASPACE
	and BP_ADDR arguments.  Update all callers.
	(struct breakpoint_ops) <print_one_detail>: New method.
	(struct breakpoint) <addr_string_range_end>: New member variable.
	* breakpoint.c (breakpoint_location_address_match): Add function
	prototype.
	(insert_bp_location): Set bl->target_info.length.
	(breakpoint_here_p): Call breakpoint_location_address_match.
	(moribund_breakpoint_here_p): Likewise.
	(regular_breakpoint_inserted_here_p): Likewise.
	(breakpoint_thread_match): Likewise.
	(bpstat_stop_status): Likewise.
	(bpstat_check_location): Move call to
	breakpoint_ops.breakpoint_hit to the top.
	(print_one_breakpoint_location): Call
	breakpoint_ops.print_one_detail if available.
	(breakpoint_address_match_range): New function.
	(breakpoint_location_address_match): Likewise.
	(breakpoint_locations_match): Compare the length field of the
	locations too.
	(hw_breakpoint_used_count): Count resources used by all locations
	in a breakpoint, and use breakpoint_ops.resources_needed if
	available.
	(breakpoint_hit_ranged_breakpoint): New function.
	(resources_needed_ranged_breakpoint): Likewise.
	(print_it_ranged_breakpoint): Likewise.
	(print_one_ranged_breakpoint): Likewise.
	(print_one_detail_ranged_breakpoint): Likewise.
	(print_mention_ranged_breakpoint): Likewise.
	(print_recreate_ranged_breakpoint): Likewise.
	(ranged_breakpoint_ops): New structure.
	(find_breakpoint_range_end): New function.
	(break_range_command): Likewise.
	(delete_breakpoint): Free addr_string_range_end.
	(update_breakpoint_locations): Add SALS_END argument.  Update
	all callers.  Calculate breakpoint length if a non-zero SALS_END
	is given.  Call breakpoint_locations_match instead of
	breakpoint_address_match.
	(reset_breakpoint): Find SaL of the end of the range if B is a
	ranged breakpoint.
	(_initialize_breakpoint): Register break-range command.
	* defs.h (print_core_address): Add function prototype.
	* ppc-linux-nat.c (ppc_linux_ranged_break_num_registers): New
	function.
	(ppc_linux_insert_hw_breakpoint): Support ranged breakpoints.
	(ppc_linux_remove_hw_breakpoint): Likewise.
	(_initialize_ppc_linux_nat): Initialize
	to_ranged_break_num_registers.
	* target.c (update_current_target): Add comment about
	to_ranged_break_num_registers.
	(target_ranged_break_num_registers): New function.
	* target.h (struct target_ops) <to_ranged_break_num_registers>:
	New method.
	(target_ranged_break_num_registers): Add function prototype.
	* ui-out.c (ui_out_field_core_addr): Move address-printing logic to ...
	* utils.c (print_core_address): ... here.

gdb/doc/
	* gdb.texinfo (PowerPC Embedded): Document ranged breakpoints.
@
text
@a151 2
static void debug_to_notice_signals (ptid_t);

d626 1
a626 1
      INHERIT (to_notice_signals, t);
a793 3
  de_fault (to_notice_signals,
	    (void (*) (ptid_t))
	    target_ignore);
d2585 31
a3942 9
static void
debug_to_notice_signals (ptid_t ptid)
{
  debug_target.to_notice_signals (ptid);

  fprintf_unfiltered (gdb_stdlog, "target_notice_signals (%d)\n",
                      PIDGET (ptid));
}

a4029 1
  current_target.to_notice_signals = debug_to_notice_signals;
@


1.279
log
@delete target_ops.to_lookup_symbol

gdb/ChangeLog:

        * target.h (struct target_ops): Remove to_lookup_symbol field.
        (target_lookup_symbol): Delete macro.
        * target.c (nosymbol, debug_to_lookup_symbol): Delete.
        (update_current_target, setup_target_debug): Remove handling
        of to_lookup_symbol target_ops field.
        * ada-tasks.c (get_known_tasks_addr): Remove use of
        target_lookup_symbol.
        * coffread.c (coff_symtab_read): Likewise.
        * dbxread.c (read_dbx_symtab): Ditto.
@
text
@d597 1
d3495 15
@


1.278
log
@2011-02-27  Michael Snyder  <msnyder@@vmware.com>

	* target.c (read_whatever_is_readable): Fix memory leak.
@
text
@a56 2
static int nosymbol (char *, CORE_ADDR *);

a149 2
static int debug_to_lookup_symbol (char *, CORE_ADDR *);

a530 6
static int
nosymbol (char *name, CORE_ADDR *addrp)
{
  return 1;			/* Symbol does not exist in target env.  */
}

a613 1
      INHERIT (to_lookup_symbol, t);
a765 3
  de_fault (to_lookup_symbol,
	    (int (*) (char *, CORE_ADDR *))
	    nosymbol);
a3788 12
static int
debug_to_lookup_symbol (char *name, CORE_ADDR *addrp)
{
  int retval;

  retval = debug_target.to_lookup_symbol (name, addrp);

  fprintf_unfiltered (gdb_stdlog, "target_lookup_symbol (%s, xxx)\n", name);

  return retval;
}

a3987 1
  current_target.to_lookup_symbol = debug_to_lookup_symbol;
@


1.277
log
@minor reformatting for target.c:read_whatever_is_readable

gdb/ChangeLog:

        * target.c (read_whatever_is_readable): Reformat comment,
        with a minor typo fix. Minor reformatting of the code.
@
text
@d1971 4
a1974 1
    return;
d1993 1
@


1.276
log
@	* target.h (struct target_ops) <to_has_execution>: Add ptid_t
	parameter.
	(target_has_execution_1): Update.
	(target_has_execution_current): Declare.
	(target_has_execution): Call target_has_execution_current.
	(default_child_has_execution): Update.
	* target.c (default_child_has_execution): Add 'the_ptid'
	parameter.
	(target_has_execution_1): Likewise.
	(target_has_execution_current): New function.
	(add_target): Update.
	(init_dummy_target): Update.
	* remote-m32r-sdi.c (m32r_has_execution): New function.
	(init_m32r_ops): Use it.
	* record.c (record_core_has_execution): Now static.  Add
	'the_ptid' parameter.
	* inferior.c (have_live_inferiors): Don't save current thread.
	Use target_has_execution_1.
@
text
@d1937 2
a1938 2
/** Assuming that the entire [begin, end) range of memory cannot be read,
    try to read whatever subrange is possible to read.
d1940 17
a1956 17
    The function results, in RESULT, either zero or one memory block.
    If there's a readable subrange at the beginning, it is completely
    read and returned.  Any further readable subrange will not be read.
    Otherwise, if there's a readable subrange at the end, it will be
    completely read and returned.  Any readable subranges before it (obviously,
    not starting at the beginning), will be ignored.  In other cases --
    either no readable subrange, or readable subrange (s) that is neither
    at the beginning, or end, nothing is returned.

    The purpose of this function is to handle a read across a boundary of
    accessible memory in a case when memory map is not available.  The above
    restrictions are fine for this case, but will give incorrect results if
    the memory is 'patchy'.  However, supporting 'patchy' memory would require
    trying to read every single byte, and it seems unacceptable solution.
    Explicit memory map is recommended for this case -- and
    target_read_memory_robust will take care of reading multiple ranges
    then.  */
d1963 1
a1963 1
  gdb_byte *buf = xmalloc (end-begin);
d2003 1
a2004 1
      ULONGEST middle = current_begin + (current_end - current_begin)/2;
d2056 1
@


1.275
log
@	gdb/
	* target.c (memory_xfer_live_readonly_partial): Document where to
	look for interface description.
@
text
@d317 1
a317 1
default_child_has_execution (struct target_ops *ops)
d321 1
a321 1
  if (ptid_equal (inferior_ptid, null_ptid))
d377 1
a377 1
target_has_execution_1 (void)
d382 1
a382 1
    if (t->to_has_execution (t))
d388 6
d416 1
a416 1
    t->to_has_execution = (int (*) (struct target_ops *)) return_zero;
d3227 2
a3228 1
  dummy_target.to_has_execution = (int (*) (struct target_ops *)) return_zero;
@


1.274
log
@	gdb/
	* target.c (target_read_live_memory): New function.
	(memory_xfer_live_readonly_partial): New.
	(memory_xfer_partial): If reading from a traceframe, fallback to
	reading unavailable read-only memory from read-only regions of
	live target memory.
	* tracepoint.c (disconnect_tracing): Adjust.
	(set_current_traceframe): New, factored out from
	set_traceframe_number.
	(set_traceframe_number): Reimplement to only change the traceframe
	number on the GDB side.
	(do_restore_current_traceframe_cleanup): Adjust.
	(make_cleanup_restore_traceframe_number): New.
	(cur_traceframe_number): New global.
	(tfile_open): Set cur_traceframe_number to no traceframe.
	(set_tfile_traceframe): New function.
	(tfile_trace_find): If looking up a traceframe using any method
	other than by number, make sure the current tfile traceframe
	matches gdb's current traceframe.  Update the current tfile
	traceframe if the lookup succeeded.
	(tfile_fetch_registers, tfile_xfer_partial)
	(tfile_get_trace_state_variable_value): Make sure the remote
	traceframe matches gdb's current traceframe.
	* remote.c (remote_traceframe_number): New global.
	(remote_open_1): Set it to -1.
	(set_remote_traceframe): New function.
	(remote_fetch_registers, remote_store_registers)
	(remote_xfer_memory, remote_xfer_partial)
	(remote_get_trace_state_variable_value): Make sure the remote
	traceframe matches gdb's current traceframe.
	(remote_trace_find): If looking up a traceframe using any method
	other than by number, make sure the current remote traceframe
	matches gdb's current traceframe.  Update the current remote
	traceframe if the lookup succeeded.
	* infrun.c (fetch_inferior_event): Adjust.
	* tracepoint.h (set_current_traceframe): Declare.
	(get_traceframe_number, set_traceframe_number): Add describing
	comments.
@
text
@d1300 4
a1303 1
   top-most target again.  */
@


1.273
log
@	gdb/
	* target.h (struct traceframe_info): Forward declare.
	(enum target_object): Add TARGET_OBJECT_TRACEFRAME_INFO.
	(struct target_ops) <to_traceframe_info>: New field.
	(target_traceframe_info): New.
	* target.c (update_current_target): Inherit and default
	to_traceframe_info.
	* remote.c (PACKET_qXfer_traceframe_info): New.
	(remote_protocol_features): Register qXfer:traceframe-info:read.
	(remote_xfer_partial): Handle TARGET_OBJECT_TRACEFRAME_INFO.
	(remote_traceframe_info): New.
	(init_remote_ops): Install it.
	(_initialize_remote): Install "set/show remote traceframe-info"
	commands.
	* tracepoint.h (parse_traceframe_info): Declare.
	* tracepoint.c (struct mem_range): New.
	(mem_range_s): New typedef.
	(struct traceframe_info): New.
	(traceframe_info): New global.
	(free_traceframe_info): New function.
	(clear_traceframe_info): New function.
	(start_tracing, tfind_1, set_traceframe_number): Clear traceframe
	info.
	(build_traceframe_info): New function.
	(tfile_traceframe_info): New function.
	(init_tfile_ops): Install tfile_traceframe_info.
	(traceframe_info_start_memory, free_result): New functions.
	(memory_attributes, traceframe_info_elements): New globals.
	(parse_traceframe_info, get_traceframe_info): New functions.
	* features/traceframe-info.dtd: New file.
	* Makefile.in (XMLFILES): Add traceframe-info.dtd.

	gdb/gdbserver/
	* server.c (handle_qxfer_traceframe_info): New.
	(qxfer_packets): Register "traceframe-info".
	(handle_query): Report support for qXfer:traceframe-info:read+.
	* tracepoint.c (match_blocktype): New.
	(traceframe_find_block_type): Rename to ...
	(traceframe_walk_blocks): ... this.  Add callback filter argument,
	and use it.
	(traceframe_find_block_type): New, reimplemented on top of
	traceframe_walk_blocks.
	(build_traceframe_info_xml): New.
	(traceframe_read_info): New.
	* server.h (traceframe_read_info): Declare.

	gdb/doc/
	* gdb.texinfo (Remote Configuration): Mention set/show remote
	traceframe-info.
	(Tools/Packages Optional for Building GDB): Mention that expat is
	used for traceframe info.
	(Remote Protocol) <Menu>: Add "Traceframe Info Format".
	(General Query Packets) <qSupported>: Describe the
	qXfer:traceframe-info:read feature.
	(qXfer::read): Describe qXfer:traceframe-info:read.
	(Traceframe Info Format): New section.
@
text
@d1274 76
d1408 53
@


1.272
log
@	gdb/
	* target.c (memory_xfer_partial): No need to restore shadows if we
	haven't read anything.
@
text
@d684 1
d894 3
@


1.271
log
@gdb
	PR mi/8618:
	* thread.c (free_thread): Free 'name'.
	(print_thread_info): Emit thread name.  Change CLI output.
	(thread_name_command): New function.
	(do_captured_thread_select): Emit newline.
	(_initialize_thread): Register 'thread name' command.
	* target.h (struct target_ops) <to_thread_name>: New field.
	(target_thread_name): New macro.
	* target.c (update_current_target): Handle to_thread_name.
	* python/py-infthread.c (thpy_get_name): New function.
	(thpy_set_name): Likewise.
	(thread_object_getset): Add "name".
	* linux-nat.c (linux_nat_thread_name): New function.
	(linux_nat_add_target): Set to_thread_name.
	* gdbthread.h (struct thread_info) <name>: New field.
gdb/doc
	* gdb.texinfo (Threads): Document thread name output and `thread
	name' command.
	(Threads In Python): Document Thread.name attribute.
	(GDB/MI Thread Commands): Document thread attributes.
gdb/testsuite
	* gdb.python/py-infthread.exp: Add thread tests.
@
text
@d1417 1
a1417 1
  if (readbuf && !show_memory_breakpoints)
@


1.270
log
@	* target.h (deprecated_child_ops): Delete declaration.
	* target.c (deprecated_child_ops): Delete definition.
@
text
@d637 1
d808 3
d2414 14
@


1.269
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@a159 6
/* NOTE: cagney/2004-09-29: Many targets reference this variable in
   wierd and mysterious ways.  Putting the variable here lets those
   wierd and mysterious ways keep building while they are being
   converted to the inferior inheritance structure.  */
struct target_ops deprecated_child_ops;

@


1.268
log
@2010-01-11  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Convert hardware watchpoints to use breakpoint_ops.

gdb/
	* breakpoint.h (breakpoint_ops) <insert>: Rename to...
	<insert_location>: ... this.  Return int instead of void.
	Accept pointer to struct bp_location instead of pointer to
	struct breakpoint.  Adapt all implementations.
	(breakpoint_ops) <remove>: Rename to...
	<remove_location>: ... this.  Accept pointer to struct bp_location
	instead of pointer to struct breakpoint.  Adapt all implementations.
	* breakpoint.c (insert_catchpoint): Delete function.
	(insert_bp_location): Call the watchpoint or catchpoint's
	breakpoint_ops.insert method.
	(remove_breakpoint_1): Call the watchpoint or catchpoint's
	breakpoint_ops.remove method.
	(insert_watchpoint, remove_watchpoint): New functions.
	(watchpoint_breakpoint_ops): New structure.
	(watch_command_1): Initialize the OPS field.
	* inf-child.c (inf_child_insert_fork_catchpoint)
	(inf_child_remove_fork_catchpoint, inf_child_insert_vfork_catchpoint)
	(inf_child_remove_vfork_catchpoint, inf_child_insert_exec_catchpoint)
	(inf_child_remove_exec_catchpoint, inf_child_set_syscall_catchpoint):
	Delete functions.
	(inf_child_target): Remove initialization of to_insert_fork_catchpoint,
	to_remove_fork_catchpoint, to_insert_vfork_catchpoint,
	to_remove_vfork_catchpoint, to_insert_exec_catchpoint,
	to_remove_exec_catchpoint and to_set_syscall_catchpoint.
	* target.c (update_current_target): Change default implementation of
	to_insert_fork_catchpoint, to_remove_fork_catchpoint,
	to_insert_vfork_catchpoint, to_remove_vfork_catchpoint,
	to_insert_exec_catchpoint, to_remove_exec_catchpoint and
	to_set_syscall_catchpoint to return_one.
	(debug_to_insert_fork_catchpoint, debug_to_insert_vfork_catchpoint)
	(debug_to_insert_exec_catchpoint): Report return value.
	* target.h (to_insert_fork_catchpoint, to_insert_vfork_catchpoint)
	(to_insert_exec_catchpoint): Change declaration to return int instead
	of void.

gdb/testsuite/
	* gdb.base/foll-exec.exp: Adapt to new error string when the catchpoint
	type is not supported.
	* gdb.base/foll-fork.exp: Likewise.
	* gdb.base/foll-vfork.exp: Likewise.
@
text
@d503 1
a503 1
     terminal. Use target_can_async_p, not target_is_async_p, since at
d518 2
a519 2
  errno = EIO;			/* Can't read/write this location */
  return 0;			/* No bytes handled */
d538 1
a538 1
  return 1;			/* Symbol does not exist in target env */
d649 5
a653 5
      /* Do not inherit to_has_all_memory */
      /* Do not inherit to_has_memory */
      /* Do not inherit to_has_stack */
      /* Do not inherit to_has_registers */
      /* Do not inherit to_has_execution */
d971 1
a971 1
     can only occur once in the target stack. */
d980 1
a980 1
    return 0;			/* Didn't find target_ops, quit now */
d990 1
a990 1
  /* Unchain the target */
d1003 1
a1003 1
  target_close (target_stack, 0);	/* Let it clean up */
d1198 1
a1198 1
	     unallocated region of memory. Retry the transfer, requesting
d1546 1
a1546 1
   it makes no progress, and then return how much was transferred). */
d1802 1
a1802 1
    read and returned. Any further readable subrange will not be read.
d1805 1
a1805 1
    not starting at the beginning), will be ignored. In other cases --
d1810 1
a1810 1
    accessible memory in a case when memory map is not available. The above
d1812 1
a1812 1
    the memory is 'patchy'. However, supporting 'patchy' memory would require
d1834 1
a1834 1
     if not. This heuristic is meant to permit reading accessible memory
d1887 1
a1887 1
	  /* This half reads up fine. So, the error must be in the
d1894 2
a1895 2
	  /* This half is not readable. Because we've tried one byte, we
	     know some part of this half if actually redable. Go to the next
d1960 1
a1960 1
	  /* Cannot read this region. Note that we can end up here only
d1976 1
a1976 1
	      /* Got an error reading full chunk. See if maybe we can read
d2236 1
a2236 1
  /* Clear out solib state. Otherwise the solib state of the previous
d2238 1
a2238 1
     target.  This has been observed on GNU/Linux using glibc 2.3. How
d2702 1
a2702 1
     should either know how to create inferiors, or not... */
@


1.267
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Internationalization.
	* c-lang.c: Ditto.
	* charset.c: Ditto.
	* fork-child.c: Ditto.
	* nto-procfs.c: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* procfs.c: Ditto.
	* remote-mips.c: Ditto.
	* remote.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* target.c: Ditto.
	* valops.c: Ditto.
	* value.c: Ditto.
	* xml-support.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
@
text
@d782 2
a783 2
	    (void (*) (int))
	    tcomplain);
d786 1
a786 1
	    tcomplain);
d788 2
a789 2
	    (void (*) (int))
	    tcomplain);
d792 1
a792 1
	    tcomplain);
d794 2
a795 2
	    (void (*) (int))
	    tcomplain);
d798 1
a798 1
	    tcomplain);
d801 1
a801 1
	    tcomplain);
d3664 1
a3664 1
static void
d3667 6
a3672 1
  debug_target.to_insert_fork_catchpoint (pid);
d3674 1
a3674 2
  fprintf_unfiltered (gdb_stdlog, "target_insert_fork_catchpoint (%d)\n",
		      pid);
d3690 1
a3690 1
static void
d3693 3
a3695 1
  debug_target.to_insert_vfork_catchpoint (pid);
d3697 4
a3700 2
  fprintf_unfiltered (gdb_stdlog, "target_insert_vfork_catchpoint (%d)\n",
		      pid);
d3716 1
a3716 1
static void
d3719 3
a3721 1
  debug_target.to_insert_exec_catchpoint (pid);
d3723 4
a3726 2
  fprintf_unfiltered (gdb_stdlog, "target_insert_exec_catchpoint (%d)\n",
		      pid);
@


1.266
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d496 1
a496 1
		  "could not find a target to create inferior");
d968 1
a968 1
		    "Attempt to unpush the dummy target");
d2346 1
a2346 1
  internal_error (__FILE__, __LINE__, "could not find a target to detach");
d2467 1
a2467 1
		  "could not find a target to follow fork");
d2493 1
a2493 1
		  "could not find a target to follow mourn inferior");
d2606 2
a2607 1
	      warning (_("Unable to access target memory at %s, halting search."),
d2703 1
a2703 1
  internal_error (__FILE__, __LINE__, "No targets found");
d2868 2
a2869 1
		    "Can't determine the current address space of thread %s\n",
d3118 1
a3118 1
		  "could not find a target to attach");
@


1.265
log
@run copyright.sh for 2011.
@
text
@d717 2
a718 1
	    (int (*) (CORE_ADDR, gdb_byte *, int, int, struct mem_attrib *, struct target_ops *))
d925 2
a926 1
      internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
d1052 2
a1053 1
      internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
d1097 2
a1098 1
	  addr = target->to_get_thread_local_address (target, ptid, lm_addr, offset);
d1109 2
a1110 1
	      error (_("Cannot find thread-local variables in this thread library."));
d1497 2
a1498 1
			  "%s:target_xfer_partial (%d, %s, %s, %s, %s, %s) = %s",
d1683 2
a1684 2
  fprintf_filtered (file, _("\
Mode for reading from readonly sections is %s.\n"),
d1815 2
a1816 1
    target_read_memory_robust will take care of reading multiple ranges then.  */
d1819 2
a1820 1
read_whatever_is_readable (struct target_ops *ops, ULONGEST begin, ULONGEST end,
d1887 2
a1888 1
	  /* This half reads up fine. So, the error must be in the other half.  */
d1979 2
a1980 1
	      read_whatever_is_readable (ops, offset + xfered, offset + xfered + to_read, &result);
d2219 2
a2220 1
	printf_unfiltered (_("\tWhile running this, GDB does not access memory from...\n"));
d2694 2
a2695 2
      error (_("\
The \"%s\" target does not support \"run\".  Try \"help target\" or \"continue\"."),
d2866 2
a2867 2
    internal_error (__FILE__, __LINE__, "\
Can't determine the current address space of thread %s\n",
d3312 2
a3313 1
	    fprintf_unfiltered (gdb_stdlog, "target_core_of_thread (%d) = %d\n",
d3334 2
a3335 1
	    fprintf_unfiltered (gdb_stdlog, "target_verify_memory (%s, %s) = %d\n",
d3469 2
a3470 1
  retval = debug_target.to_can_accel_watchpoint_condition (addr, len, rw, cond);
d3473 2
a3474 1
		      "target_can_accel_watchpoint_condition (%s, %d, %d, %s) = %ld\n",
d3769 4
a3772 2
  fprintf_unfiltered (gdb_stdlog, "target_thread_architecture (%s) = %s [%s]\n",
		      target_pid_to_str (ptid), host_address_to_string (retval),
d3826 6
a3831 3
  current_target.to_watchpoint_addr_within_range = debug_to_watchpoint_addr_within_range;
  current_target.to_region_ok_for_hw_watchpoint = debug_to_region_ok_for_hw_watchpoint;
  current_target.to_can_accel_watchpoint_condition = debug_to_can_accel_watchpoint_condition;
d3834 2
a3835 1
  current_target.to_terminal_ours_for_output = debug_to_terminal_ours_for_output;
d3859 2
a3860 2
"Names of targets and files being debugged.\n\
Shows the entire stack of targets currently in use (including the exec-file,\n\
d3916 3
a3918 2
  fprintf_filtered (file, _("\
Controlling the inferior in asynchronous mode is %s.\n"), value);
@


1.264
log
@remove target_acknowledge_created_inferior

This target_ops routine appears to be unused in practice, so this patch
removes it.

gdb/ChangeLog:

        * inf-child.c (inf_child_acknowledge_created_inferior): Delete.
        (inf_child_target): Do not set t->to_acknowledge_created_inferior.
        * inf-ptrace.c (inf_ptrace_create_inferior): Remove call to
        target_acknowledge_created_inferior.
        * inf-ttrace.c (inf_ttrace_him): Likewise.
        * target.h (struct target_ops): Delete to_acknowledge_created_inferior
        field.
        (target_acknowledge_created_inferior): Delete.
        * target.c (update_current_target): Remove setting of
        to_acknowledge_created_inferior field. Do default value for that
        field either.
        (debug_to_acknowledge_created_inferior): Delete.
        (setup_target_debug): Remove setting of
        current_target.to_acknowledge_created_inferior.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.263
log
@gdb/
	Code cleanup.
	* defs.h (find_memory_region_ftype): New typedef.
	(exec_set_find_memory_regions): Use it.
	* exec.c (exec_set_find_memory_regions): Use find_memory_region_ftype.
	* fbsd-nat.c (fbsd_find_memory_regions): Likewise.
	* gcore.c (objfile_find_memory_regions): Likewise.
	* gnu-nat.c (gnu_find_memory_regions): Likewise.
	* linux-nat.c (linux_nat_find_memory_regions): Likewise.
	* procfs.c (iterate_over_mappings_cb_ftype): Remove.
	(iterate_over_mappings): Rename iterate_over_mappings_cb_ftype to
	find_memory_region_ftype.
	(insert_dbx_link_bpt_in_region): Likewise.
	(iterate_over_mappings): Likewise.  Drop the comment part about the
	function prototype.
	(find_memory_regions_callback): Use find_memory_region_ftype.
	(proc_find_memory_regions): Likewise.
	(info_mappings_callback): Rename iterate_over_mappings_cb_ftype to
	find_memory_region_ftype.
	* target.c (dummy_find_memory_regions): Use find_memory_region_ftype.
	* target.h (struct target_ops) <to_find_memory_regions>: Likewise.
@
text
@a626 1
      INHERIT (to_acknowledge_created_inferior, t);
a779 3
  de_fault (to_acknowledge_created_inferior,
	    (void (*) (int))
	    target_ignore);
a3647 9
debug_to_acknowledge_created_inferior (int pid)
{
  debug_target.to_acknowledge_created_inferior (pid);

  fprintf_unfiltered (gdb_stdlog, "target_acknowledge_created_inferior (%d)\n",
		      pid);
}

static void
a3820 1
  current_target.to_acknowledge_created_inferior = debug_to_acknowledge_created_inferior;
@


1.262
log
@	Easier and more stubborn MI memory read commands.

	* mi/mi-cmds.c (mi_cmds): Register data-read-memory-bytes
	and data-write-memory-bytes.
	* mi/mi-cmds.h (mi_cmd_data_read_memory_bytes)
	(mi_cmd_data_write_memory_bytes): New.
	* mi/mi-main.c (mi_cmd_data_read_memory): Use regular target_read.
	(mi_cmd_data_read_memory_bytes, mi_cmd_data_write_memory_bytes):
	New.
	(mi_cmd_list_features): Add "data-read-memory-bytes" feature.
	* target.c (target_read_until_error): Remove.
	(read_whatever_is_readable, free_memory_read_result_vector)
	(read_memory_robust): New.
	* target.h (target_read_until_error): Remove.
	(struct memory_read_result, free_memory_read_result_vector)
	(read_memory_robust): New.
@
text
@d3008 1
a3008 1
dummy_find_memory_regions (int (*ignore1) (), void *ignore2)
@


1.261
log
@gdb/
	Make core files the process_stratum.
	* corefile.c (core_target): New variable.
	(core_file_command): Remove variable t, use core_target.
	* corelow.c (core_ops): Make it static.
	(init_core_ops): Change to process_stratum.  Initialize CORE_TARGET.
	* defs.h (make_cleanup_unpush_target): New prototype.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (core_pid_to_str): Remove core_stratum from its comment.
	* gdbcore.h (core_target): New declaration.
	* inf-ptrace.c (inf_ptrace_create_inferior, inf_ptrace_attach): New
	variables ops_already_pushed and back_to.  Use push_target,
	make_cleanup_unpush_target and discard_cleanups calls.
	* record.c (record_open): Replace core_stratum by a core_bfd check.
	* target.c (target_is_pushed): New function.
	(find_core_target): Remove.
	* target.h (enum strata) <core_stratum>: Remove.
	(target_is_pushed): New declaration.
	(find_core_target): Remove declaration.
	* tracepoint.c (init_tfile_ops) <to_stratum>: Remove comment.
	* utils.c (do_unpush_target, make_cleanup_unpush_target): New functions.

gdb/doc/
	Make core files the process_stratum.
	* gdb.texinfo (Active Targets): Remove core_stratum.  Include
	record_stratum example.

gdb/testsuite/
	Make core files the process_stratum.
	* gdb.base/corefile.exp (run: load core again)
	(run: sanity check we see the core file, run: with core)
	(run: core file is cleared, attach: load core again)
	(attach: sanity check we see the core file, attach: with core)
	(attach: core file is cleared): New tests.
	* gdb.base/coremaker.c (main): New parameters.  Implement "sleep" argv.
@
text
@d1795 141
a1935 5
LONGEST
target_read_until_error (struct target_ops *ops,
			 enum target_object object,
			 const char *annex, gdb_byte *buf,
			 ULONGEST offset, LONGEST len)
d1937 2
a1939 1

d1942 2
a1943 3
      LONGEST xfer = target_read_partial (ops, object, annex,
					  (gdb_byte *) buf + xfered,
					  offset + xfered, len - xfered);
d1945 16
a1960 4
      /* Call an observer, notifying them of the xfer progress?  */
      if (xfer == 0)
	return xfered;
      if (xfer < 0)
d1962 7
a1968 11
	  /* We've got an error.  Try to read in smaller blocks.  */
	  ULONGEST start = offset + xfered;
	  ULONGEST remaining = len - xfered;
	  ULONGEST half;

	  /* If an attempt was made to read a random memory address,
	     it's likely that the very first byte is not accessible.
	     Try reading the first byte, to avoid doing log N tries
	     below.  */
	  xfer = target_read_partial (ops, object, annex, 
				      (gdb_byte *) buf + xfered, start, 1);
a1969 6
	    return xfered;
	  start += 1;
	  remaining -= 1;
	  half = remaining/2;
	  
	  while (half > 0)
d1971 14
a1984 19
	      xfer = target_read_partial (ops, object, annex,
					  (gdb_byte *) buf + xfered,
					  start, half);
	      if (xfer == 0)
		return xfered;
	      if (xfer < 0)
		{
		  remaining = half;		  
		}
	      else
		{
		  /* We have successfully read the first half.  So, the
		     error must be in the second half.  Adjust start and
		     remaining to point at the second half.  */
		  xfered += xfer;
		  start += xfer;
		  remaining -= xfer;
		}
	      half = remaining/2;
d1986 1
a1986 2

	  return xfered;
a1987 2
      xfered += xfer;
      QUIT;
d1989 1
a1989 1
  return len;
d1992 1
@


1.260
log
@* target.c (debug_to_insert_breakpoint): Instead of casting to unsigned
long and %ld, use core_addr_to_string() and %s to print CORE_ADDR vars
and host_address_to_string() and %s for pointers.
(debug_to_remove_breakpoint): Likewise.
(debug_to_region_ok_for_hw_watchpoint): Likewise.
(debug_to_can_accel_watchpoint_condition): Likewise.
(debug_to_stopped_data_address): Likewise.
(debug_to_watchpoint_addr_within_range): Likewise.
(debug_to_insert_hw_breakpoint): Likewise.
(debug_to_remove_hw_breakpoint): Likewise.
(debug_to_insert_watchpoint): Likewise.
(debug_to_remove_watchpoint): Likewise.
@
text
@d1040 24
a2796 25
/* Find a single core_stratum target in the list of targets and return it.
   If for some reason there is more than one, return NULL.  */

struct target_ops *
find_core_target (void)
{
  struct target_ops **t;
  struct target_ops *runable = NULL;
  int count;

  count = 0;

  for (t = target_structs; t < target_structs + target_struct_size;
       ++t)
    {
      if ((*t)->to_stratum == core_stratum)
	{
	  runable = *t;
	  ++count;
	}
    }

  return (count == 1 ? runable : NULL);
}

@


1.259
log
@2010-07-07  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Support for hw accelerated condition watchpoints in booke powerpc.

	* breakpoint.c (fetch_watchpoint_value): Rename to fetch_subexp_value
	and move to eval.c.  Change callers.
	(insert_bp_location): Pass watchpoint condition in
	target_insert_watchpoint.
	(remove_breakpoint_1) Pass watchpoint condition in
	target_remove_watchpoint.
	(watchpoint_locations_match): Call
	target_can_accel_watchpoint_condition.
	* eval.c: Include wrapper.h.
	(fetch_subexp_value): Moved from breakpoint.c.
	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint):
	Formatting fix.
	(can_use_watchpoint_cond_accel): New function.
	(calculate_dvc): Likewise.
	(num_memory_accesses): Likewise.
	(check_condition): Likewise.
	(ppc_linux_can_accel_watchpoint_condition): Likewise
	(ppc_linux_insert_watchpoint): Call can_use_watchpoint_cond_accel,
	check_condition and calculate_dvc.
	(ppc_linux_remove_watchpoint): Likewise.
	(_initialize_ppc_linux_nat): Set to_can_accel_watchpoint_condition to
	ppc_linux_can_accel_watchpoint_condition
	* target.c (debug_to_insert_watchpoint): Add argument for watchpoint
	condition.
	(debug_to_remove_watchpoint): Likewise.
	(debug_to_can_accel_watchpoint_condition): New function.
	(update_current_target): Set to_can_accel_watchpoint_condition.
	(setup_target_debug): Set to_can_accel_watchpoint_condition.
	* target.h: Add opaque declaration for struct expression.
	(struct target_ops) <to_insert_watchpoint>,
	<to_remove_watchpoint>: Add new arguments to pass the watchpoint
	<to_can_accel_watchpoint_condition>: New member.
	condition.  Update all callers and implementations.
	(target_can_accel_watchpoint_condition): New macro.
	* value.c (free_value_chain): New function.
	* value.h (fetch_subexp_value): New prototype.
	(free_value_chain): Likewise.
@
text
@d3273 2
a3274 2
		      "target_insert_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) bp_tgt->placed_address,
d3288 2
a3289 2
		      "target_remove_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) bp_tgt->placed_address,
d3318 3
a3320 4
		      "target_region_ok_for_hw_watchpoint (%ld, %ld) = 0x%lx\n",
		      (unsigned long) addr,
		      (unsigned long) len,
		      (unsigned long) retval);
d3333 3
a3335 3
		      "target_can_accel_watchpoint_condition (0x%lx, %d, %d, 0x%lx) = %ld\n",
		      (unsigned long) addr, len, rw, (unsigned long) cond,
		      (unsigned long) retval);
d3360 2
a3361 2
		      "target_stopped_data_address ([0x%lx]) = %ld\n",
		      (unsigned long)*addr,
d3377 3
a3379 3
		    "target_watchpoint_addr_within_range (0x%lx, 0x%lx, %d) = %d\n",
		    (unsigned long) addr, (unsigned long) start, length,
		    retval);
d3392 2
a3393 2
		      "target_insert_hw_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) bp_tgt->placed_address,
d3407 2
a3408 2
		      "target_remove_hw_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) bp_tgt->placed_address,
d3422 3
a3424 3
		      "target_insert_watchpoint (0x%lx, %d, %d, 0x%ld) = %ld\n",
		      (unsigned long) addr, len, type, (unsigned long) cond,
		      (unsigned long) retval);
d3437 3
a3439 3
		      "target_remove_watchpoint (0x%lx, %d, %d, 0x%ld) = %ld\n",
		      (unsigned long) addr, len, type, (unsigned long) cond,
		      (unsigned long) retval);
@


1.259.2.1
log
@Merge recent win64 breakage fixes from HEAD to 7.2 branch:

gdb/

	* target.c (debug_to_insert_breakpoint): Instead of casting to unsigned
	long and %ld, use core_addr_to_string() and %s to print CORE_ADDR vars
	and host_address_to_string() and %s for pointers.
	(debug_to_remove_breakpoint): Likewise.
	(debug_to_region_ok_for_hw_watchpoint): Likewise.
	(debug_to_can_accel_watchpoint_condition): Likewise.
	(debug_to_stopped_data_address): Likewise.
	(debug_to_watchpoint_addr_within_range): Likewise.
	(debug_to_insert_hw_breakpoint): Likewise.
	(debug_to_remove_hw_breakpoint): Likewise.
	(debug_to_insert_watchpoint): Likewise.
	(debug_to_remove_watchpoint): Likewise.

gdb/gdbserver/

	* server.c (handle_query): strcpy() the returned string from paddress()
	instead of sprintf().
	* utils.c (paddress): Return phex_nz().
@
text
@d3273 2
a3274 2
		      "target_insert_breakpoint (%s, xxx) = %ld\n",
		      core_addr_to_string (bp_tgt->placed_address),
d3288 2
a3289 2
		      "target_remove_breakpoint (%s, xxx) = %ld\n",
		      core_addr_to_string (bp_tgt->placed_address),
d3318 4
a3321 3
		      "target_region_ok_for_hw_watchpoint (%s, %ld) = %s\n",
		      core_addr_to_string (addr), (unsigned long) len,
		      core_addr_to_string (retval));
d3334 3
a3336 3
		      "target_can_accel_watchpoint_condition (%s, %d, %d, %s) = %ld\n",
		      core_addr_to_string (addr), len, rw,
		      host_address_to_string (cond), (unsigned long) retval);
d3361 2
a3362 2
		      "target_stopped_data_address ([%s]) = %ld\n",
		      core_addr_to_string (*addr),
d3378 3
a3380 3
		    "target_watchpoint_addr_within_range (%s, %s, %d) = %d\n",
		    core_addr_to_string (addr), core_addr_to_string (start),
		    length, retval);
d3393 2
a3394 2
		      "target_insert_hw_breakpoint (%s, xxx) = %ld\n",
		      core_addr_to_string (bp_tgt->placed_address),
d3408 2
a3409 2
		      "target_remove_hw_breakpoint (%s, xxx) = %ld\n",
		      core_addr_to_string (bp_tgt->placed_address),
d3423 3
a3425 3
		      "target_insert_watchpoint (%s, %d, %d, %s) = %ld\n",
		      core_addr_to_string (addr), len, type,
		      host_address_to_string (cond), (unsigned long) retval);
d3438 3
a3440 3
		      "target_remove_watchpoint (%s, %d, %d, %s) = %ld\n",
		      core_addr_to_string (addr), len, type,
		      host_address_to_string (cond), (unsigned long) retval);
@


1.258
log
@	Static tracepoints support, and UST integration.

	gdb/gdbserver/
	* configure.ac: Handle --with-ust.  substitute ustlibs and ustinc.
	* mem-break.c (uninsert_all_breakpoints)
	(reinsert_all_breakpoints): New.
	* mem-break.h (reinsert_all_breakpoints, uninsert_all_breakpoints):
	* tracepoint.c (ust_loaded, helper_thread_id, cmd_buf): New.
	(gdb_agent_ust_loaded, helper_thread_id)
	(gdb_agent_helper_thread_id): New macros.
	(struct ipa_sym_addresses): Add addr_ust_loaded,
	addr_helper_thread_id, addr_cmd_buf.
	(symbol_list): Add ust_loaded, helper_thread_id, cmd_buf.
	(in_process_agent_loaded_ust): New.
	(write_e_ust_not_loaded): New.
	(maybe_write_ipa_ust_not_loaded): New.
	(struct collect_static_trace_data_action): New.
	(enum tracepoint_type) <static_tracepoint>: New.
	(struct tracepoint) <handle>: Mention static tracepoints.
	(struct static_tracepoint_ctx): New.
	(CMD_BUF_SIZE): New.
	(add_tracepoint_action): Handle static tracepoint actions.
	(unprobe_marker_at): New.
	(clear_installed_tracepoints): Handle static tracepoints.
	(cmd_qtdp): Handle static tracepoints.
	(probe_marker_at): New.
	(cmd_qtstart): Handle static tracepoints.
	(response_tracepoint): Handle static tracepoints.
	(cmd_qtfstm, cmd_qtsstm, cmd_qtstmat): New.
	(handle_tracepoint_query): Handle qTfSTM, qTsSTM and qTSTMat.
	(get_context_regcache): Handle static tracepoints.
	(do_action_at_tracepoint): Handle static tracepoint actions.
	(traceframe_find_block_type): Handle static trace data blocks.
	(traceframe_read_sdata): New.
	(download_tracepoints): Download static tracepoint actions.
	[HAVE_UST] Include ust/ust.h, dlfcn.h, sys/socket.h, and sys/un.h.
	(GDB_PROBE_NAME): New.
	(ust_ops): New.
	(GET_UST_SYM): New.
	(USTF): New.
	(dlsym_ust): New.
	(ust_marker_to_static_tracepoint): New.
	(gdb_probe): New.
	(collect_ust_data_at_tracepoint): New.
	(gdb_ust_probe): New.
	(UNIX_PATH_MAX, SOCK_DIR): New.
	(gdb_ust_connect_sync_socket): New.
	(resume_thread, stop_thread): New.
	(run_inferior_command): New.
	(init_named_socket): New.
	(gdb_ust_socket_init): New.
	(cstr_to_hexstr): New.
	(next_st): New.
	(first_marker, next_marker): New.
	(response_ust_marker): New.
	(cmd_qtfstm, cmd_qtsstm): New.
	(unprobe_marker_at, probe_marker_at): New.
	(cmd_qtstmat, gdb_ust_thread): New.
	(gdb_ust_init): New.
	(initialize_tracepoint_ftlib): Call gdb_ust_init.
	* linux-amd64-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(x86_64_st_collect_regmap): New.
	(X86_64_NUM_ST_COLLECT_GREGS): New.
	(AMD64_RIP_REGNUM): New.
	(supply_static_tracepoint_registers): New.
	* linux-i386-ipa.c [HAVE_UST]: Include ust/processor.h
	(ST_REGENTRY): New.
	(i386_st_collect_regmap): New.
	(i386_NUM_ST_COLLECT_GREGS): New.
	(supply_static_tracepoint_registers): New.
	* server.c (handle_query): Handle qXfer:statictrace:read.
	<qSupported>: Report support for StaticTracepoints, and
	qXfer:statictrace:read features.
	* server.h (traceframe_read_sdata)
	(supply_static_tracepoint_registers): Declare.
	* remote-utils.c (convert_int_to_ascii, hexchars, ishex, tohex)
	(unpack_varlen_hex): Include in IPA build.
	* Makefile.in (ustlibs, ustinc): New.
	(IPA_OBJS): Add remote-utils-ipa.o.
	($(IPA_LIB)): Link -ldl and -lpthread.
	(UST_CFLAGS): New.
	(IPAGENT_CFLAGS): Add UST_CFLAGS.
	* config.in, configure: Regenerate.

	gdb/
	* NEWS: Mention new support for static tracepoints.
	(New packets): Mention qTfSTM, qTsSTM, qTSTMat and
	qXfer:statictrace:read.
	(New features in the GDB remote stub, GDBserver): Mention static
	tracepoints support using an UST based backend.
	(New commands): Mention "info static-tracepoint-markers" and
	"strace".
	* breakpoint.c (is_marker_spec): New.
	(is_tracepoint): Handle static tracepoints.
	(validate_commands_for_breakpoint): Static tracepoints can't do
	while-stepping.
	(static_tracepoints_here): New.
	(bpstat_what): Handle static tracepoints.
	(print_one_breakpoint_location, allocate_bp_location, mention):
	Ditto.
	(create_breakpoint_sal): Ditto.
	(decode_static_tracepoint_spec): New.
	(create_breakpoint): Replace `hardwareflag', and `traceflag' with
	`type_wanted'.  Adjust.  Handle static tracepoint marker
	locations.
	(break_command_1): Adjust.
	(update_static_tracepoint): New.
	(update_breakpoint_locations): Handle static tracepoints.
	(breakpoint_re_set_one): Handle static tracepoint marker
	locations.
	(disable_command, enable_command): Handle static tracepoints.
	(trace_command, ftrace_command): Adjust.
	(strace_command): New.
	(create_tracepoint_from_upload): Adjust.
	(save_breakpoints): Handle static tracepoints.
	(_initialize_breakpoint): Install the "strace" command.
	* breakpoint.h (enum bptype): New bp_static_tracepoint type.
	(struct breakpoint): New fields static_trace_marker_id and
	static_trace_marker_id_idx.
	(breakpoints_here_p): Declare.
	(create_breakpoint): Adjust.
	(static_tracepoints_here): Declare.
	* remote.c (struct remote_state) <static_tracepoints>: New field.
	(PACKET_qXfer_statictrace_read, PACKET_StaticTracepoints): New.
	(remote_static_tracepoint_marker_at): New.
	(remote_static_tracepoint_markers_by_strid): New.
	(remote_static_tracepoint_feature): New.
	(remote_disconnected_tracing_feature): Handle "StaticTracepoints".
	(remote_xfer_partial): Handle TARGET_OBJECT_STATIC_TRACE_DATA.
	(remote_supports_static_tracepoints): New.
	(remote_download_tracepoint): Download static tracepoints.
	(init_remote_ops): Install remote_static_tracepoint_marker_at and
	remote_static_tracepoint_markers_by_strid.
	(_initialize_remote): Install set|show remote static-tracepoints,
	and set|show remote read-sdata-object commands.
	* target.c (update_current_target): Inherit and default
	to_static_tracepoint_marker_at, and
	to_static_tracepoint_markers_by_strid.
	* target.h (static_tracepoint_marker): Forward declare.
	(enum target_object): New object TARGET_OBJECT_STATIC_TRACE_DATA.
	(static_tracepoint_marker_p): New typedef.
	(DEF_VEC_P(static_tracepoint_marker_p)): New VEC type.
	(struct target_ops): New fields to_static_tracepoint_marker_at and
	to_static_tracepoint_markers_by_strid.
	(target_static_tracepoint_marker_at)
	(target_static_tracepoint_markers_by_strid): New.
	* tracepoint.c: Include source.h.
	(validate_actionline): Handle $_sdata.
	(struct collection_list): New field strace_data.
	(add_static_trace_data): New.
	(clear_collection_list): Clear strace_data.
	(stringify_collection_list): Account for a possible static trace
	data collection.
	(encode_actions_1): Encode an $_sdata collection.
	(parse_tracepoint_definition): Handle static tracepoints.
	(parse_static_tracepoint_marker_definition): New.
	(release_static_tracepoint_marker): New.
	(print_one_static_tracepoint_marker): New.
	(info_static_tracepoint_markers_command): New.
	(sdata_make_value): New.
	(_initialize_tracepoint): Create the $_sdata convenience variable.
	Add the "info static-tracepoint-markers" command.
	Mention $_sdata in the "collect" command's help output.
	* tracepoint.h (struct static_tracepoint_marker): New.
	(parse_static_tracepoint_marker_definition)
	(release_static_tracepoint_marker): Declare.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust.
	* python/py-breakpoint.c (bppy_new): Adjust.

	doc/
	* gdb.texinfo (Convenience Variables): Document $_sdata.
	(Commands to Set Tracepoints): Describe static tracepoints.  Add
	`Listing Static Tracepoint Markers' menu entry.  Document
	"strace".
	(Tracepoint Action Lists): Document collecting $_sdata.
	(Listing Static Tracepoint Markers): New subsection.
	(Tracepoints support in gdbserver): Mention static tracepoints.
	(remote packets, enabling and disabling): Mention
	read-sdata-object.
	(General Query Packets) <qSupported>: Document qXfer:sdata:read
	and StaticTracepoint.
	Mention qTfSTM, qTsSTM and qTSTMat as tracepoint packets.
	Document qXfer:sdata:read.
	(Tracepoint packets): Document qTfSTM, qTsSTM and qTSTMat.
@
text
@d120 2
a121 1
static int debug_to_insert_watchpoint (CORE_ADDR, int, int);
d123 2
a124 1
static int debug_to_remove_watchpoint (CORE_ADDR, int, int);
d135 3
d615 1
d737 1
a737 1
	    (int (*) (CORE_ADDR, int, int))
d740 1
a740 1
	    (int (*) (CORE_ADDR, int, int))
d752 3
d3326 15
d3415 2
a3416 1
debug_to_insert_watchpoint (CORE_ADDR addr, int len, int type)
d3420 1
a3420 1
  retval = debug_target.to_insert_watchpoint (addr, len, type);
d3423 3
a3425 2
		      "target_insert_watchpoint (0x%lx, %d, %d) = %ld\n",
		      (unsigned long) addr, len, type, (unsigned long) retval);
d3430 2
a3431 1
debug_to_remove_watchpoint (CORE_ADDR addr, int len, int type)
d3435 1
a3435 1
  retval = debug_target.to_remove_watchpoint (addr, len, type);
d3438 3
a3440 2
		      "target_remove_watchpoint (0x%lx, %d, %d) = %ld\n",
		      (unsigned long) addr, len, type, (unsigned long) retval);
d3695 1
@


1.257
log
@2010-06-11  Stan Shebs  <stan@@codesourcery.com>

	Add per-operation permission flags.

	* target.h (struct target_ops): New method to_set_permissions.
	(target_set_permissions): New macro.
	(target_insert_breakpoint): Change macro to function.
	(target_remove_breakpoint): Ditto.
	(target_stop): Ditto.
	(may_write_registers): Declare.
	(may_write_memory): Declare.
	(may_insert_breakpoints): Declare.
	(may_insert_tracepoints): Declare.
	(may_insert_fast_tracepoints): Declare.
	(may_stop): Declare.
	* target.c (may_write_registers, may_write_registers_1): New globals.
	(may_write_memory, may_write_memory_1): New globals.
	(may_insert_breakpoints, may_insert_breakpoints_1): New globals.
	(may_insert_tracepoints, may_insert_tracepoints_1): New globals.
	(may_insert_fast_tracepoints, may_insert_fast_tracepoints_1): New
	globals.
	(may_stop, may_stop_1): New global.
	(target_xfer_partial): Test for write permission.
	(target_store_registers): Ditto.
	(target_insert_breakpoint): New function.
	(target_remove_breakpoint): New function.
	(target_stop): New function.
	(_initialize_targets): Add new set/show variables.
	(set_write_memory_permission): New function.
	(update_target_permissions): New function.
	(set_target_permissions): New function.
	(update_current_target): Default to_set_permissions.
	(_initialize_targets): Use new globals and setter function.
	* tracepoint.c (start_tracing): Test for permission.
	* inferior.h (update_observer_mode): Declare.
	* infrun.c (non_stop_1): Define earlier.
	(observer_mode, observer_mode_1): New globals.
	(set_observer_mode, show_observer_mode): New functions.
	(update_observer_mode): New function.
	(_initialize_infrun): Define "set observer" command.
	* remote.c (PACKET_QAllow): New optional packet.
	(remote_protocol_features): Add QAllow.
	(remote_set_permissions): New function.
	(remote_start_remote): Call it.
	(init_remote_ops): Add it to target vector.
	(_initialize_remote): Add config command for QAllow.

	* gdb.texinfo (Observer Mode): New section.
	(General Query Packets): Document QAllow.

	* gdb.base/permissions.exp: New file.
@
text
@d682 2
d883 6
@


1.256
log
@2010-06-09  Michael Snyder  <msnyder@@vmware.com>

	* target.c (update_current_target): Fix spelling error in comment.
	(target_mourn_inferior): Fix spelling error in error message.
@
text
@d198 16
d681 1
d878 3
d1427 4
d1994 30
d3006 12
d3127 3
d3747 56
d3861 55
@


1.255
log
@gdb/
	Code cleanup.
	* target.c (push_target): Return only void.  Remove the return value
	comment.
	* target.h (push_target): Return only void.
@
text
@d615 1
a615 1
      /* Do not inherit to_mourn_inferiour.  */
d2260 1
a2260 1
		  "could not find a target to follow mourn inferiour");
@


1.254
log
@Revert previous change that inadvertently added reset_schedlock, and
revert changes done on top on that.
@
text
@a874 3
   Result is zero if the pushed target ended up on top of the stack,
   nonzero if at least one target is on top of it.

d879 1
a879 1
int
a919 3

  /* Not on top?  */
  return (t != target_stack);
@


1.253
log
@Add reset_schedlock declaration in target.h.

This patches improves a couple of previous patches:
  - one that introduces reset_schedlock, but failed to add a declarationl;
  - one that was checked in to avoid a compilation failure due to that
    missing declaration.
It also improves the declaration itself to better conform to our coding
practices.  Same for the comments.

2010-05-17  Joel Brobecker  <brobecker@@adacore.com>

        * target.h (reset_schedlock): Add declaration.
        * infrun.c (reset_schedlock): Add missing void in function profile.
        * target.c (target_mourn_inferior): Delete local declaration of
        reset_schedlock.  Style-fix in comment.
@
text
@a2247 3
  /* Clear schedlock in infrun.c.  */
  reset_schedlock ();

@


1.252
log
@2010-05-17  Hui Zhu  <teawater@@gmail.com>

	* target.c (target_mourn_inferior): Extern reset_schedlock.
@
text
@a2246 1
  extern void reset_schedlock ();
d2248 1
a2248 1
  /* Clear schedlock in infrun.c */
@


1.251
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* target.c: White space.
	* target-descriptions.c: White space.
	* target-memory.c: White space.
	* thread.c: White space.
	* top.c: White space.
	* tracepoint.c: White space.
	* trad-frame.c: White space.
	* tramp-frame.c: White space.
	* ui-file.c: White space.
	* ui-out.c: White space.
	* user-regs.c: White space.
	* utils.c: White space.
@
text
@d2247 1
@


1.250
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* osabi.c (_initialize_gdb_osabi): Delete unused variable.
	* memattr.c (mem_delete): Delete unused variable.
	(invalidate_target_mem_regions): Delete unused variable.
	* mem-break.c (default_memory_insert_breakpoint):
	Delete unused variable.
	* target.c (target_get_osdata): Delete unused variable.
	* parse.c (length_of_subexp): Delete unused variable.
	(prefixify_subexp): Delete unused variable.
	(exp_iterate): Delete unused variable.
	* reverse.c (delete_bookmark_command): Delete unused variable.
@
text
@d460 1
d912 1
d981 2
a982 1
  internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
d1154 1
d1238 1
d1244 1
d1395 1
a1396 1

d1590 7
a1596 7
	{
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "target_flash_erase (%s, %s)\n",
                                hex_string (address), phex (length, 0));
	  t->to_flash_erase (t, address, length);
	  return;
	}
d1608 6
a1613 6
	{
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "target_flash_done\n");
	  t->to_flash_done (t);
	  return;
	}
d1640 1
d1646 1
d1718 1
d1724 1
d1743 1
d1749 1
d1966 2
a1967 2
get_target_memory_unsigned (struct target_ops *ops,
			    CORE_ADDR addr, int len, enum bfd_endian byte_order)
d2230 1
d2247 4
d2351 1
d2585 1
d2903 1
d2924 1
d2947 1
d3016 1
d3030 1
d3040 1
d3052 1
d3068 1
a3069 1
  struct target_ops *t;
d3096 1
d3117 1
@


1.249
log
@gdb/
	* cli/cli-cmds.h (error_no_arg): Remove.  Move the comment ...
	* command.h (error_no_arg): ... here.  Remove NORETURN, change
	ATTR_NORETURN to ATTRIBUTE_NORETURN.
	* defs.h (NORETURN, ATTR_NORETURN): Remove.
	(perror_with_name, verror, error, error_stream, vfatal, fatal)
	(internal_verror, internal_error, nomem): Remove NORETURN, change
	ATTR_NORETURN to ATTRIBUTE_NORETURN.
	* exceptions.c (throw_exception, deprecated_throw_reason, throw_verror)
	(throw_vfatal, throw_error): Remove NORETURN.
	(throw_it): Remove NORETURN, change ATTR_NORETURN to ATTRIBUTE_NORETURN.
	* exceptions.h (throw_exception, throw_verror, throw_vfatal)
	(throw_error, deprecated_throw_reason): Remove NORETURN, change
	ATTR_NORETURN to ATTRIBUTE_NORETURN.
	* linespec.c (cplusplus_error): Remove NORETURN, change ATTR_NORETURN
	to ATTRIBUTE_NORETURN for prototype, for the definition only remove
	NORETURN.
	* remote-mips.c (mips_error): Change NORETURN to ATTRIBUTE_NORETURN.
	* remote-sim.c (gdb_os_error): Change ATTR_NORETURN to
	ATTRIBUTE_NORETURN.
	* target.c (tcomplain): Likewise.
	* target.h (noprocess): Remove NORETURN, change ATTR_NORETURN to
	ATTRIBUTE_NORETURN.
	* utils.c (verror, error, vfatal, fatal, error_stream, internal_verror)
	(internal_error, perror_with_name, nomem): Remove NORETURN.
	* xml-support.h (gdb_xml_error): Change ATTR_NORETURN to
	ATTRIBUTE_NORETURN.

gdb/doc/
	* gdbint.texinfo (Host Definition): Remove items NORETURN and
	ATTR_NORETURN.
@
text
@a2577 1
  char *document;
@


1.248
log
@	PR gdb/11557

	gdb/
	* regcache.c (registers_changed): Rename to ...
	(registers_changed_ptid): ... this, and only delete register cache
	entries matching the ptid filter argument.
	(registers_changed): Reimplement on top of registers_changed_ptid.
	* regcache.h (registers_changed_ptid): Declare.
	* target.c (target_resume): Flush register caches.

	gdb/testsuite/
	* gdb.mi/mi-ns-stale-regcache.exp, gdb.mi/ns-stale-regcache.c: New
	files.
@
text
@d59 1
a59 1
static void tcomplain (void) ATTR_NORETURN;
@


1.247
log
@2010-04-19  Stan Shebs  <stan@@codesourcery.com>
	    Vladimir Prus  <vladimir@@codesourcery.com>

	* tracepoint.c (tfind_1): Add missing newline, report exit from
	tfind mode as such.
	* target.c (update_current_target): Make default
	to_trace_find return -1.
@
text
@d2195 1
@


1.246
log
@
	Support for Windows OS Thread Information Block.
	* NEWS: Document new feature.
	* remote.c (PACKET_qGetTIBAddr): New enum element.
	(remote_get_tib_address): New function.
	(init_remote_ops): Set to_get_tib_address field
	to remote_get_tib_address.
	(_initialize_remote): Add add_packet_config_cmd
	for PACKET_qGetTIBAddr.
	* target.c (update_current_target): Set default value for
	new to_get_tib_address field.
	* target.h (target_ops): New field to_get_tib_address.
	(target_get_tib_address): New macro.
	* windows-nat.c (thread_info): Add thread_local_base field.
	(windows_add_thread): Add tlb argument of type 'void *'.
	(fake_create_process): Adapt windows_add_thread call.
	(get_windows_debug_event): Idem.
	(windows_get_tib_address): New function.
	(init_windows_ops): Set to_get_tib_address field
	to remote_get_tib_address.
	(_initialize_windows_nat): Replace info_w32_cmdlist
	initialization by a call to init_w32_command_list.
	(info_w32_command, info_w32_cmdlist): Removed from here...
	to windows-tdep.c file.
	* windows-tdep.h (info_w32_cmdlist): Declare.
	(init_w32_command_list): New external function
	declaration.
	* windows-tdep.c: Add several headers.
	(info_w32_cmdlist): to here, made global.
	(thread_information_32): New struct.
	(thread_information_64): New struct.
	(TIB_NAME): New char array.
	(MAX_TIB32, MAX_TIB64, FULL_TIB_SIZE): New constants.
	(maint_display_all_tib): New static variable.
	(windows_get_tlb_type): New function.
	(tlb_value_read, tlb_value_write): New functions.
	(tlb_value_funcs): New static struct.
	(tlb_make_value): New function.
	(display_one_tib): New function.
	(display_tib): New function.
	(show_maint_show_all_tib):New function.
	(info_w32_command): Moved from windows-nat.c.
	(init_w32_command_list): New function.
	(_initialize_windows_tdep): New function.
	New "maint set/show show-all-tib" command
	New "$_tlb" internal variable.

gdbserver/ChangeLog entry:

	* server.c (handle_query): Handle 'qGetTIBAddr' query.
	* target.h (target_ops): New get_tib_address field.
	* win32-low.h (win32_thread_info): Add thread_local_base field.
	* win32-low.c (child_add_thread): Add tlb argument.
	Set thread_local_base field to TLB.
	(get_child_debug_event): Adapt to child_add_thread change.
	(win32_get_tib_address): New function.
	(win32_target_ops): Set get_tib_address field to
	win32_get_tib_address.
	* linux-low.c (linux_target_ops): Set get_tib_address field to NULL.

doc/ChangeLog entry:

	gdb.texinfo ($_tlb): Document new automatic convinience variable.
	(info w32 thread-information-block): Document new command.
	(qGetTIBAddress): Document new gdbserver query.
	(maint set/show show-all-tib): Document new command.
@
text
@d835 1
a835 1
	    return_zero);
@


1.245
log
@	gdb/
	* remote.c (crc32): Constify `buf' parameter.
	(remote_verify_memory): New, abstracted out from...
	(compare_sections_command): ... this.  Remove hardcoded target
	checks.
	(init_remote_ops): Install remote_verify_memory.
	* target.c (target_verify_memory): New.
	* target.h (struct target_ops) <to_verify_memory>: New field.
	(target_verify_memory): Declare.
@
text
@d663 1
d857 3
@


1.244
log
@	Implement -trace-save.

	* mi-cmds.h (mi_cmds_trace_save): Declare.
	* mi-cmds.c (mi_cmds): Register -trace-save.
	* mi/mi-main.c (mi_cmd_trace_save): New.
	* remote.c (remote_save_trace_data): Take const parameter.
	* target.h (struct target_ops::to_save_trace_data): Take
	const parameter.
	* target.c (update_current_target): Adjust to the above.
	* tracepoint.c (trave_save): New, extracted from
	(trace_save_command): ...this.
	(tfile_trace_find): Remove message that is unnecessary now
	that 'tfind' reports found frame.
	* tracepoint.h (trace_save): Declare.
@
text
@d3076 22
@


1.243
log
@2010-03-18  Stan Shebs  <stan@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* target.h (struct target_ops): New method
	to_set_circular_trace_buffer.
	(target_set_circular_trace_buffer): New macro.
	* target.c (update_current_target): Add
	to_set_circular_trace_buffer, fix to_set_disconnected_tracing
	default behavior.
	* remote.c (remote_set_circular_trace_buffer): New function.
	(init_remote_ops): Add it to vector.
	* tracepoint.h (struct trace_status): New field traceframes_created,
	change buffer_size and buffer_free to int.
	* tracepoint.c (circular_trace_buffer): New global.
	(start_tracing): Send values of disconnected tracing and circular
	trace buffer settings.
	(set_circular_trace_buffer): New function.
	(parse_trace_state): Handle total space and frames created.
	(trace_status_command): Display total space and total frames
	created.
	(trace_save): Write out new status values.
	(parse_trace_status): Set traceframe_count, traceframes_created,
	buffer_free and buffer_size to -1 by default.
	(_initialize_tracepoint): New setshow for circular-trace-buffer.
	* NEWS: Mention the circular trace buffer option.

	* gdb.texinfo (Starting and Stopping Trace Experiments): Describe
	circular-trace-buffer.
	(Tracepoint Packets): Describe QTBuffer, and details of the
	qTStatus reply.

	* gdb.trace/circ.exp: Test circular-trace-buffer.
	* gdb.trace/tfile.exp: Update tstatus test.
@
text
@d839 1
a839 1
	    (int (*) (char *))
@


1.242
log
@	* target.c (memory_xfer_partial): Don't use the stack cache if
	inspecting trace frames.
	* tracepoint.c (finish_tfind_command): Invalidate the target
	dcache.
@
text
@d662 1
d852 4
a855 1
	    tcomplain);
@


1.241
log
@2010-03-08  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Hui Zhu  <teawater@@gmail.com>

	* record.c (record_open_1): Check tmp_to_stopped_by_watchpoint and
	tmp_to_stopped_data_address.
	(record_open): Reset tmp_to_stopped_by_watchpoint and
	tmp_to_stopped_data_address.
	* target.c (init_dummy_target): Add to_stopped_by_watchpoint and
	to_stopped_data_address.
@
text
@d46 1
d1296 4
@


1.240
log
@	PR gdb/11321

	* inferior.h (prepare_for_detach): Declare.
	(struct inferior) <detaching>: New field.
	* infrun.c (prepare_for_detach): New.
	(handle_inferior_event) <random signal>: Don't stop if detaching.
	* target.c (target_detach): Call prepare_for_detach.
@
text
@d2841 3
@


1.239
log
@Delete unused or undefined functions.

        * breakpoint.c (ep_parse_optional_filename): Delete.
        * dcache.c (dcache_write_line): Remove declaration.
        * infrun.c (build_infrun): Remove declaration.
        * tracepoint.c (tracepoint_save_command): Remove declaration.
        * linux-nat.c (init_lwp_list): Delete. No longer used.
        * event-loop.c (check_async_signal_handlers): Delete declaration.
        * infrun.c (init_execution_control_state): Delete.
        (proceed): Update comment to avoid mentioning
        init_execution_control_state.
        * target.c (kill_or_be_killed, nosupport_runtime): Delete.
        * ada-lang.c (ada_to_static_fixed_value): Delete.
        * scm-lang.c (evaluate_subexp_scm): Delete declaration.
        * cp-namespace.c (cp_copy_usings): Delete.
        * xml-syscall.c (xml_number_of_syscalls): Delete.
        * progspace.c (find_program_space_by_num): Delete.
        * inflow.c (handle_sigio): Delete declaration.
        * hppa-tdep.c (hppa_alignof): Delete.
        * mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset)
        (mipsnbsd_core_osabi_sniffer): Delete.
@
text
@d2080 2
@


1.239.2.1
log
@	* target.c (memory_xfer_partial): Don't use the stack cache if
	inspecting trace frames.
	* tracepoint.c (finish_tfind_command): Invalidate the target
	dcache.
@
text
@a45 1
#include "tracepoint.h"
a1294 4
      /* The dcache reads whole cache lines; that doesn't play well
	 with reading from a trace buffer, because reading outside of
	 the collected memory range fails.  */
      && get_traceframe_number () == -1
@


1.238
log
@	Add trace file support.
	* tracepoint.h (enum trace_stop_reason): New enum.
	(struct trace_status): New struct.
	(parse_trace_status): Declare.
	(struct uploaded_tp): Move here from remote.c,
	add fields for actions.
	(struct uploaded_tsv): New struct.
	* tracepoint.c (tfile_ops): New target vector.
	(trace_fd): New global.
	(tfile_open): New function.
	(tfile_close): New function.
	(tfile_files_info): New function.
	(tfile_get_trace_status): New function.
	(tfile_get_traceframe_address): New function.
	(tfile_trace_find): New function.
	(tfile_fetch_registers): New function.
	(tfile_xfer_partial): New function.
	(tfile_get_trace_state_variable_value): New function.
	(init_tfile_ops): New function.
	(_initialize_tracepoint): Call it, add tfile target.
	(trace_status): New global.
	(current_trace_status): New function.
	(trace_running_p): Remove, change all users to get from
	current_trace_status()->running.
	(get_trace_status): Remove.
	(trace_status_command): Call target_get_trace_status directly,
	report more detail including tracing stop reasons.
	(trace_find_command): Always allow tfind on a file.
	(trace_find_pc_command): Ditto.
	(trace_find_tracepoint_command): Ditto.
	(trace_find_line_command): Ditto.
	(trace_find_range_command): Ditto.
	(trace_find_outside_command): Ditto.
	(trace_frames_offset, cur_offset): Declare as off_t.
	(trace_regblock_size): Rename from reg_size, update users.
	(parse_trace_status): New function.
	(tfile_interp_line): New function.
	(disconnect_or_stop_tracing): Ensure current trace
	status before asking what to do.
	(stop_reason_names): New global.
	(trace_save_command): New command.
	(get_uploaded_tp): Move here from remote.c.
	(find_matching_tracepoint): Ditto.
	(merge_uploaded_tracepoints): New function.
	(parse_trace_status): Use stop_reason_names.
	(_initialize_tracepoint): Define tsave command.
	* target.h (target_ops): New fields to_save_trace_data,
	to_upload_tracepoints, to_upload_trace_state_variables,
	to_get_raw_trace_data, change to_get_trace_status
	to take a pointer to a status struct.
	(target_save_trace_data): New macro.
	(target_upload_tracepoints): New macro.
	(target_upload_trace_state_variables): New macro.
	(target_get_raw_trace_data): New macro.
	* target.c (update_current_target): Add new methods, change
	signature of to_get_trace_status.
	* remote.c (hex2bin): Make globally visible.
	(bin2hex): Ditto.
	(remote_download_trace_state_variable): Download name also.
	(remote_get_trace_status): Update parameter, use
	parse_trace_status.
	(remote_save_trace_data): New function.
	(remote_upload_tracepoints): New function.
	(remote_upload_trace_state_variables): New function.
	(remote_get_raw_trace_data): New function.
	(remote_start_remote): Use them.
	(_initialize_remote_ops): Add operations.
	* ax-gdb.c: Include breakpoint.h.
	* breakpoint.c (create_tracepoint_from_upload): Use
	break_command_really, return tracepoint, warn about unimplemented
	parts.
	* NEWS: Mention trace file addition.

	* gdb.texinfo (Trace Files): New section.
	(Tracepoint Packets): Document QTSave and qTBuffer.
	(Trace File Format): New appendix.

	* generic/gdbtk-bp.c (gdb_trace_status): Use current_trace_status.

	* gdb.trace/tfile.c: New file.
	* gdb.trace/tfile.exp: New file.
@
text
@a48 2
static void kill_or_be_killed (int);

a73 2
static void nosupport_runtime (void);

a518 10
nosupport_runtime (void)
{
  if (ptid_equal (inferior_ptid, null_ptid))
    noprocess ();
  else
    error (_("No run-time support for this"));
}


static void
a523 27
/* This is the default target_create_inferior and target_attach function.
   If the current target is executing, it asks whether to kill it off.
   If this function returns without calling error(), it has killed off
   the target, and the operation should be attempted.  */

static void
kill_or_be_killed (int from_tty)
{
  if (target_has_execution)
    {
      printf_unfiltered (_("You are already running a program:\n"));
      target_files_info ();
      if (query (_("Kill it? ")))
	{
	  target_kill ();
	  if (target_has_execution)
	    error (_("Killing the program did not help."));
	  return;
	}
      else
	{
	  error (_("Program not killed."));
	}
    }
  tcomplain ();
}

@


1.237
log
@	Implement core awareness.

	* bcache.c (compare_ints): Remove
	(print_percentage): Use compare_positive_ints.
	* defs.h (compare_positive_ints): Declare.
	* linux-nat.h (struct lin_lwp): New field core.
	(linux_nat_core_of_thread_1): Declare.
	* linux-nat.c (add_lwp): Init the 'core' field.
	(linux_nat_wait_1): Record the core.
	(linux_nat_core_of_thread_1, linux_nat_core_of_thread): New.
	(linux_nat_add_target): Register the above.
	* linux-thread-db.c (update_thread_core): New.
	(thread_db_find_new_threads): Update core information for
	every thread.
	* remote.c (struct private_thread_info): New.
	(free_private_thread_info, demand_private_info): New.
	(PACKET_qXfer_threads, use_osdata_threads): New.
	(struct thread_item, threads_parsing_context
	(start_thread, end_thread, thread_attributes)
	(thread_children, threads_children, threads_elements): New.
	(remote_threads_info): Try qXfer:threads before anything
	else.
	(remote_protocol_packets): Register qXfer:threads.
	(remote_open_1): Init use_osdata_threads.
	(struct stop_reply): New field 'core'.
	(remote_parse_stop_reply): Parse core number.
	(process_stop_reply): Record core number.
	(remote_xfer_partial): Handle qXfer:threads.
	(remote_core_of_thread): New.
	(init_remote_ops): Register remote_core_of_thread.
	(_initialize_remote): Register qXfer:read.
	* target.c (target_core_of_thread): New
	* target.h (enum target_object): New value TARGET_OBJECT_THREADS.
	(struct target_ops): New field to_core_of_threads.
	(target_core_of_thread): Declare.
	* gdbthread.h (struct thread_info): New field private_dtor.
	* thread.c (print_thread_info): Report the core.
	* ui-out.c (MAX_UI_OUT_LEVELS): Increase.
	* utils.c (compare_positive_ints): New.
	* features/threads.dtd: New.
	* mi/mi-interp.c (mi_on_normal_stop): Report the core.
	* mi/mi-main.c (struct collect_cores_data, collect_cores)
	(do_nothing, free_vector_of_osdata_items)
	(splay_tree_int_comparator, free_splay_tree): New.
	(print_one_inferior_data): Implemented printing of selected
	inferiors.  Collect and print cores.
	(output_cores): New.
	(mi_cmd_list_thread_groups): Support --recurse.  Permit specifying
	thread groups together with --available.
@
text
@d697 4
d866 1
a866 1
	    (int (*) (int *))
d877 12
@


1.236
log
@	Make tracepoint operations go through target vector.
	* target.h (enum trace_find_type): New enum.
	(struct target_ops): New fields to_trace_init,
	to_download_tracepoint, to_download_trace_state_variable,
	to_trace_set_readonly_regions, to_trace_start, to_get_trace_status,
	to_trace_stop, to_trace_find, to_get_trace_state_variable_value,
	to_set_disconnected_tracing.
	(target_trace_init): New macro.
	(target_download_tracepoint): New macro.
	(target_download_trace_state_variable): New macro.
	(target_trace_start): New macro.
	(target_trace_set_readonly_regions): New macro.
	(target_get_trace_status): New macro.
	(target_trace_stop): New macro.
	(target_trace_find): New macro.
	(target_get_trace_state_variable_value): New macro.
	(target_set_disconnected_tracing): New macro.
	* target.c (update_current_target): Inherit and set defaults for
	tracepoint operations.
	* tracepoint.c (default_collect): Make globally visible.
	(target_is_remote): Remove, along with all calls.
	(tvariables_info): Call target_get_trace_state_variable_value.
	(remote_set_transparent_ranges): Remove.
	(trace_start_command): Call target_trace_init,
	target_download_tracepoint, etc.
	(download_tracepoint): Remove.
	(trace_stop_command): Simplify.
	(stop_tracing): Call target_trace_stop.
	(get_trace_status): Call target_get_trace_status.
	(trace_status_command): Add case for targets that cannot trace.
	(finish_tfind_command): Change to take numerical arguments, call
	target_trace_find.
	(trace_find_command): Update call to finish_tfind_command.
	(trace_find_pc_command): Ditto.
	(trace_find_tracepoint_command): Ditto.
	(trace_find_line_command): Ditto.
	(trace_find_range_command): Ditto.
	(trace_find_outside_command): Ditto.
	(set_disconnected_tracing_value): Call
	target_set_disconnected_tracing.
	* remote.c: Add protocol encoding bits from tracepoint.c.
	(trace_error): Move from tracepoint.c.
	(remote_get_noisy_reply): Ditto.
	(free_actions_list_cleanup_wrapper): Ditto.
	(free_actions_list): Ditto.
	(remote_trace_init): New function.
	(remote_download_tracepoint): New function.
	(remote_download_trace_state_variable): New function.
	(remote_trace_set_readonly_regions): New function.
	(remote_trace_start): New function.
	(remote_get_trace_status): New function.
	(remote_trace_stop): New function.
	(remote_trace_find): New function.
	(remote_download_trace_state_variable): New function.
	(remote_set_disconnected_tracing): New function.
	(init_remote_ops): Add tracepoint operations.
@
text
@d3067 20
@


1.235
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d688 10
d846 30
@


1.234
log
@	* target.c (target_terminal_inferior): Use target_can_async_p, not
	target_is_async_p.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.233
log
@2009-10-25  Michael Snyder  <msnyder@@vmware.com>

        * target.h (struct target_ops): New methods to_get_bookmark
        and to_goto_bookmark.
        (target_get_bookmark): New macro.
        (target_goto_bookmark): New macro.
        * target.c (dummy_get_bookmark): New function, default implementation.
        (dummy_goto_bookmark): New function, default implementation.
        (update_current_target): Inherit new methods.
        * record.c (record_get_bookmark): New function.
        (record_goto_bookmark): New function.
        (init_record_ops): Set to_get_bookmark and to_goto_bookmark methods.
        * reverse.c (struct bookmark): New type.
        (save_bookmark_command): New function (command).
        (delete_bookmark_command): New function (command).
        (goto_bookmark_command): New function (command).
        (bookmarks_info): New function (command).
        (_initialize_reverse): Add new bookmark commands.
	* command.h (enum command_class): Add class_bookmark.
	* NEWS: Mention bookmark commands.
@
text
@d484 4
a487 2
     terminal.  */
  if (target_is_async_p () && !sync_execution)
@


1.232
log
@	* dcache.c (dcache_hit, dcache_read_line): Tweak comments.
	(dcache_peek_byte, dcache_init, dcache_xfer_memory): Ditto.
	* target.c (memory_xfer_partial): Tweak comments.
	(target_xfer_partial, target_write_memory): Add comment.
	(target_read_partial): Remove note from 2003-10-21.
	(target_read, target_write): Add comments.
@
text
@d677 2
d2779 15
d2814 2
@


1.231
log
@2009-10-29  Sandra Loosemore  <sandra@@codesourcery.com>

	PR gdb/10783

	gdb/
	* target.c (simple_search_memory): Correct read_addr initialization
	in loop for searching subsequent chunks.

	gdb/gdbserver/
	* server.c (handle_search_memory_1): Correct read_addr initialization
	in loop for searching subsequent chunks.
@
text
@d1184 2
a1185 2
/* Perform a partial memory transfer.  The arguments and return
   value are just as for target_xfer_partial.  */
d1363 2
d1479 5
d1647 1
a1647 5
/* Target vector read/write partial wrapper functions.

   NOTE: cagney/2003-10-21: I wonder if having "to_xfer_partial
   (inbuf, outbuf)", instead of separate read/write methods, make life
   easier.  */
d1668 3
a1758 1

d1794 2
@


1.230
log
@2009-10-26  Michael Snyder  <msnyder@@vmware.com>
	    Hui Zhu  <teawater@@gmail.com>

	* Makefile.in (SFILES): Add gcore.c.
	(COMMON_OBS): Add gcore.o.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Delete gcore.o.
	* config/alpha/fbsd.mh (NATDEPFILES): Ditto.
	* config/arm/linux.mh (NATDEPFILES): Ditto.
	* config/i386/fbsd.mh (NATDEPFILES): Ditto.
	* config/i386/fbsd64.mh (NATDEPFILES): Ditto.
	* config/i386/i386sol2.mh (NATDEPFILES): Ditto.
	* config/i386/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux64.mh (NATDEPFILES): Ditto.
	* config/i386/sol2-64.mh (NATDEPFILES): Ditto.
	* config/ia64/linux.mh (NATDEPFILES): Ditto.
	* config/m32r/linux.mh (NATDEPFILES): Ditto.
	* config/m68k/linux.mh (NATDEPFILES): Ditto.
	* config/mips/linux.mh (NATDEPFILES): Ditto.
	* config/pa/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Ditto.
	* config/s390/s390.mh (NATDEPFILES): Ditto.
	* config/sparc/fbsd.mh (NATDEPFILES): Ditto.
	* config/sparc/linux.mh (NATDEPFILES): Ditto.
	* config/sparc/linux64.mh (NATDEPFILES): Ditto.
	* config/sparc/sol2.mh (NATDEPFILES): Ditto.
	* config/xtensa/linux.mh (NATDEPFILES): Ditto.
	* target.c (dummy_find_memory_regions): Change output.
	(dummy_make_corefile_notes): Ditto.
@
text
@d2308 1
a2308 1
	  CORE_ADDR read_addr = start_addr + keep_len;
@


1.229
log
@	* linux-nat.c (linux_nat_thread_address_space): New.
	(linux_nat_add_target): Install it.
	* progspace.c (address_space_num): New.
	* progspace.h (address_space_num): Declare.
	* target.c (target_thread_address_space): Really query the target.
	* target.h (struct target_ops) <to_thread_address_space>: New
	field.
@
text
@d2754 3
a2756 2
/* Error-catcher for target_find_memory_regions */
static int dummy_find_memory_regions (int (*ignore1) (), void *ignore2)
d2758 1
a2758 1
  error (_("No target."));
d2762 3
a2764 2
/* Error-catcher for target_make_corefile_notes */
static char * dummy_make_corefile_notes (bfd *ignore1, int *ignore2)
d2766 1
a2766 1
  error (_("No target."));
@


1.228
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d2558 1
d2560 8
d2569 8
a2576 2
  /* For now, assume frame chains and inferiors only see one address
     space.  */
@


1.227
log
@	* ARI fix: "%p" rule.
	target.c (debug_to_thread_architecture): Replace %p by %s using
	host_address_to_string function.
@
text
@d1270 4
a1273 1
  inf = find_inferior_pid (ptid_get_pid (inferior_ptid));
d2052 1
a2052 1
    remove_breakpoints ();
d2553 21
d2685 1
a2685 1
      delete_inferior (pid);
@


1.226
log
@	* target.c (memory_xfer_partial): Pass correct length to dcache_update.
@
text
@d3370 2
a3371 2
  fprintf_unfiltered (gdb_stdlog, "target_thread_architecture (%s) = %p [%s]\n",
		      target_pid_to_str (ptid), retval,
@


1.225
log
@Implementing catch syscall.

* amd64-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(amd64_linux_get_syscall_number): New function.
(amd64_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* breakpoint.c: New include: xml-syscall.h.
(set_raw_breakpoint_without_location): Setting the parameters
for the catch syscall feature.
(insert_catch_syscall): New.
(remove_catch_syscall): New.
(breakpoint_hit_catch_syscall): New.
(print_it_catch_syscall): New.
(print_one_catch_syscall): New.
(print_mention_catch_syscall): New.
(catch_syscall_breakpoint_ops): New.
(syscall_catchpoint_p): New.
(create_catchpoint_without_mention): New.
(create_catchpoint): Modified in order to use
create_catchpoint_without_mention.
(create_syscall_event_catchpoint): New.
(clean_up_filters): New.
(catch_syscall_split_args): New.
(catch_syscall_command_1): New.
(delete_breakpoint): Add cleanup for catch syscall.
(is_syscall_catchpoint_enabled): New.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
(catch_syscall_completer): New completer function.
(add_catch_command): Add the completer function for catchpoints.
* breakpoint.h (syscalls_to_be_caught): New vector.
(catch_syscall_enabled): New.
(catching_syscall_number): New.
* gdbarch.c: Regenerated.
* gdbarch.h: Regenerated.
* gdbarch.sh: Add syscall catchpoint functions and structures.
(get_syscall_number): New.
(UNKNOWN_SYSCALL): New definition.
* i386-linux-nat.c (i386_linux_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* i386-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall name for the architecture.
(i386_linux_get_syscall_number): New.
(i386_linux_init_abi): Register the correct functions for syscall
catchpoint; set the correct syscall file name.
* inf-child.c (inf_child_set_syscall_catchpoint): New.
(inf_child_target): Assign default values to target_ops.
* inf-ptrace.c (inf_ptrace_resume): Select the proper request
to be made for ptrace() considering if we are catching syscalls
or not.
* inferior.h (struct inferior): Included new variables
any_syscall_count, syscalls_counts and total_syscalls_count,
used to keep track of requested syscall catchpoints.
* infrun.c (resume): Add syscall catchpoint.
(deal_with_syscall_event): New.
(handle_inferior_event): Add syscall entry/return events.
(inferior_has_called_syscall): New.
* linux-nat.c: Define some helpful variables to track wether we have
support for the needed ptrace option.
(linux_test_for_tracesysgood): New.
(linux_supports_tracesysgood): New.
(linux_enable_tracesysgood): New.
(linux_enable_event_reporting): Save the current used ptrace
options.
(linux_child_post_attach): Calling linux_enable_tracesysgood.
(linux_child_post_startup_inferior): Likewise.
(linux_child_set_syscall_catchpoint): New function.
(linux_handle_extended_wait): Handle the case which the inferior stops
because it has called or returned from a syscall.
(linux_target_install_ops): Install the necessary functions to handle
syscall catchpoints.
* linux-nat.h (struct lwp_info): Include syscall_state into the
structure, which indicates if we are in a syscall entry or return.
* ppc-linux-tdep.c: Include xml-syscall.h header, define the XML
syscall filename for the arch.
(ppc_linux_get_syscall_number): New.
(ppc_linux_init_abi): Register the correct functions for syscall
catchpoint; setting the correct name for the XML syscall file.
* target.c (update_current_target): Update/copy functions related to
syscall catchpoint.
(target_waitstatus_to_string): Add syscall catchpoint entry/return
events.
* target.h (struct target_waitstatus): Add syscall number.
(struct syscall): New struct to hold information about syscalls
in the system.
(struct target_ops): Add ops for syscall catchpoint.
(inferior_has_called_syscall): New.
(target_set_syscall_catchpoint): New.
* xml-support.c (xml_fetch_content_from_file): New function,
transferred from xml-tdesc.c.
* xml-support.h (xml_fetch_content_from_file): New.
* xml-tdesc.c (fetch_xml_from_file): Function removed;
transferred to xml-support.c.
(file_read_description_xml): Updated to use the new
xml_fetch_content_from_file function.
* syscalls/gdb-syscalls.dtd: New definition file for syscall's XML
support.
* syscalls/amd64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use amd64 architecture.
* syscalls/i386-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use i386 architecture.
* syscalls/ppc-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC architecture.
* syscalls/ppc64-linux.xml: New file containing information about
syscalls for GNU/Linux systems that use PPC64 architecture.
* xml-syscall.c: New file containing functions for manipulating
syscall's XML files.
* xml-syscall.h: New file, exporting the functions above mentioned.
* Makefile.in: Support for relocatable GDB datadir and XML
syscall.
* NEWS: Added information about the catch syscall feature.
* doc/gdb.texinfo (Set Catchpoints): Documentation about the new
feature.
* testsuite/Makefile.in: Inclusion of catch-syscall object.
* testsuite/gdb.base/catch-syscall.c: New file.
* testsuite/gdb.base/catch-syscall.exp: New file.
@
text
@d1336 1
a1336 1
      dcache_update (target_dcache, memaddr, (void *) writebuf, reg_len);
@


1.224
log
@	* target.c (memory_xfer_partial): Only update dcache after we know
	the write succeeded.
@
text
@d650 1
d793 3
d2873 1
a2873 1
      return xstrprintf ("%ssyscall-entry", kind_str);
d2875 1
a2875 1
      return xstrprintf ("%ssyscall-return", kind_str);
@


1.223
log
@	* target.c (initialize_targets): Fix thinko in stack_cache_enabled_p.
@
text
@a1291 13
  /* Make sure the cache gets updated no matter what - if we are writing
     to the stack, even if this write is not tagged as such, we still need
     to update the cache. */

  if (inf != NULL
      && readbuf == NULL
      && !region->attrib.cache
      && stack_cache_enabled_p
      && object != TARGET_OBJECT_STACK_MEMORY)
    {
      dcache_update (target_dcache, memaddr, (void *) writebuf, reg_len);
    }

d1321 14
@


1.222
log
@	Implement TARGET_OBJECT_STACK_MEMORY.
	* NEWS: Add note on new "set stack-cache" option.
	* corefile.c (read_stack): New function.
	* dcache.c (dcache_struct): New member ptid.
	(dcache_enable_p): Mark as obsolete.
	(show_dcache_enabled_p): Flag option as deprecated.
	(dcache_invalidate): Update ptid.
	(dcache_invalidate_line): New function.
	(dcache_read_line): No longer check cacheable attribute, stack
	accesses get cached despite attribute.
	(dcache_init): Set ptid.
	(dcache_xfer_memory): Flush cache if from different ptid than before.
	Update cache after write.
	(dcache_update): New function.
	(dcache_info): Report ptid.
	(_initialize_dcache): Update text for `remotecache' to indicate it
	is obsolete.
	* dcache.h (dcache_update): Declare.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Mark values on stack with
	set_value_stack.
	* frame-unwind.c (frame_unwind_got_memory): Ditto.
	* gdbcore.h (read_stack): Declare.
	* memattr.c (mem_enable_command): Call target_dcache_invalidate
	instead of dcache_invalidate.
	(mem_disable_command, mem_delete_command): Ditto.
	* target.c (stack_cache_enabled_p_1): New static global.
	(stack_cache_enabled_p): New static global.
	(set_stack_cache_enabled_p): New function.
	(show_stack_cache_enabled_p): New function.
	(target_dcache): Make static.
	(target_dcache_invalidate): New function.
	(target_load, target_resume): Call target_dcache_invalidate
	instead of dcache_invalidate.
	(memory_xfer_partial): New arg object, all callers updated.
	Check for existing inferior before calling dcache routines.
	When writing non-TARGET_OBJECT_STACK_MEMORY, notify dcache.
	(target_xfer_partial): Call memory_xfer_partial for
	TARGET_OBJECT_STACK_MEMORY.
	(target_read_stack): New function.
	(initialize_targets): Install new option `stack-cache'.
	* target.h: Remove #include of dcache.h.
	(enum target_object): New value TARGET_OBJECT_STACK_MEMORY.
	(target_dcache): Delete.
	(target_dcache_invalidate): Declare.
	(target_read_stack): Declare.
	* top.c (prepare_execute_command): New function.
	(execute_command): Call prepare_execute_command
	instead of free_all_values.
	* top.h (prepare_execute_command): Declare.
	* valops.c (get_value_at): New function.
	(value_at): Guts moved to get_value_at.
	(value_at_lazy): Similarly.
	(value_fetch_lazy): Call read_stack for stack values.
	* value.c (struct value): New member `stack'.
	(value_stack, set_value_stack): New functions.
	* value.h (value_stack, set_value_stack): Declare.
	* mi/mi-main.c (mi_cmd_execute): Call prepare_execute_command
	instead of free_all_values.

	doc/
	* gdb.texinfo (Caching Data of Remote Targets): Update text.
	Mark `set/show remotecache' options as obsolete.
	Document new `set/show stack-cache' option.
	Update text for `info dcache'.
@
text
@d3558 1
a3558 1
			   &stack_cache_enabled_p, _("\
@


1.221
log
@	Replace dcache with splay tree.
	Remove partially implemented writeback support.
	* dcache.c: Include splay-tree.h.
	(LINE_SIZE_POWER): Change from 5 to 6.
	(DCACHE_SIZE): Change from 64 to 4096.
	(ENTRY_INVALID, ENTRY_VALID, ENTRY_DIRTY): Delete.
	(state_chars): Delete.
	(struct dcache_block): Clean up; remove state and anydirty fields.
	(struct dcache_struct): Redefine as a splay tree and linked list.
	(last_cache): Make static.
	(dcache_invalidate, dcache_hit): Rewrite for new cache structure.
	(dcache_read_line, dcache_alloc): Rewrite for new cache structure.
	(dcache_write_line): Delete.
	(dcache_writeback): Delete.
	(dcache_peek_byte): Clean up; remove "invalid" state check.
	(dcache_poke_byte): Rewrite for new cache structure; clarify comment.
	(dcache_splay_tree_compare): New function.
	(dcache_init, dcache_free): Rewrite for new cache structure.
	(dcache_xfer_memory): Rewrite for new write-through cache structure.
	(dcache_print_line): New function.
	(dcache_info): Rewrite for new cache structure.
	(_initialize_dcache): Update "info dcache" help text.
	* dcache.h (dcache_xfer_memory): Update declaration.
	* target.c (memory_xfer_partial): Update calls to dcache_xfer_memory.
@
text
@d213 39
a251 1
DCACHE *target_dcache;
d454 1
a454 1
  dcache_invalidate (target_dcache);
d1184 3
a1186 2
memory_xfer_partial (struct target_ops *ops, void *readbuf, const void *writebuf,
		     ULONGEST memaddr, LONGEST len)
d1191 1
d1266 5
a1270 1
  if (region->attrib.cache)
d1292 13
d1368 3
a1370 2
  if (object == TARGET_OBJECT_MEMORY)
    retval = memory_xfer_partial (ops, readbuf, writebuf, offset, len);
d1452 17
d2133 1
a2133 1
  dcache_invalidate (target_dcache);
d3557 11
@


1.220
log
@2009-08-14  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* top.c (any_thread_of): Delete.
	(kill_or_detach): Use any_thread_of_process.
	* top.c (print_inferior_quit_action): New.
	(quit_confirm): Rewrite to print info about all inferiors.
	* target.c (dispose_inferior): New.
	(target_preopen): Use it.

2009-08-14  Pedro Alves  <pedro@@codesourcery.com>

	gdb/testsuite/
	* gdb.threads/killed.exp, gdb.threads/manythreads.exp,
	gdb.threads/staticthreads.exp: Adjust to "quit" output changes.
@
text
@a1227 2
      /* FIXME drow/2006-08-09: This call discards OPS, so the raw
	 memory request will start back at current_target.  */
d1229 1
a1229 1
	res = dcache_xfer_memory (target_dcache, memaddr, readbuf,
d1235 1
a1235 1
	res = dcache_xfer_memory (target_dcache, memaddr,
@


1.219
log
@ChangeLog:

	* target.h (enum strata): New value arch_stratum.
	* target.c (target_require_runnable): Skip arch_stratum targets.

	* configure.tgt (powerpc-*-linux* | powerpc64-*-linux*): Add
	solib-spu.o and spu-multiarch.o to gdb_target_obs.
	* Makefile.in (ALL_TARGET_OBS): Add solib-spu.o and spu-multiarch.o.
	(ALLDEPFILES): Add solib-spu.c and spu-multiarch.c.

	* solib-spu.c: New file.
	* solib-spu.h: New file.
	* spu-multiarch.c: New file.

	* spu-tdep.h (SPUADDR, SPUADDR_SPU, SPUADDR_ADDR): New macros.

	* spu-tdep.c (struct gdbarch_tdep): New member id.
	(spu_gdbarch_id): New function.
	(spu_lslr): New function.

	(spu_address_to_pointer): New function.
	(spu_pointer_to_address): Support SPU ID address encoding.  Use
	spu_gdbarch_id and spu_lslr.
	(spu_integer_to_address): Likewise.
	(spu_frame_unwind_cache): Update for encoded addresses.
	(spu_unwind_pc, spu_unwind_sp): Likewise.
	(spu_read_pc, spu_write_pc): Likewise.
	(spu_push_dummy_call): Likewise.
	(spu_software_single_step): Likewise.
	(spu_get_longjmp_target): Likewise.
	(spu_overlay_update_osect): Likewise.

	(spu_dis_asm_print_address): New function.
	(gdb_print_insn_spu): Likewise.

	(spu_gdbarch_init): Store SPU ID in tdep structure.
	Install spu_address_to_pointer and gdb_print_insn_spu.

	* ppc-linux-tdep.c: Include "observer.h", "auxv.h", "elf/common.h"
	and "solib-spu.h".
	(ppc_linux_entry_point_addr): New static variable.
	(ppc_linux_inferior_created): New function.
	(ppc_linux_displaced_step_location): Likewise.
	(ppc_linux_init_abi): Enable Cell/B.E. support if supported
	by the target.
	(_initialize_ppc_linux_tdep): Attach to inferior_created observer.

	* NEWS: Mention multi-architecture and Cell/B.E. debugging
	capabilities.

testsuite/ChangeLog:

	* gdb.xml/tdesc-regs.exp: Skip for SPU targets.
@
text
@d1907 23
d1938 1
a1938 1
  if (target_has_execution)
d1941 3
a1943 2
          || query (_("A program is being debugged already.  Kill it? ")))
	target_kill ();
@


1.218
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d2301 2
a2302 1
      if (t->to_stratum == thread_stratum)
@


1.218.2.1
log
@2009-07-25  Michael Snyder  <msnyder@@vmware.com>

	* target.h (struct target_ops): New methods to_set_checkpoint,
	to_unset_checkpoint, to_restore_checkpoint, to_info_checkpoints.
	* target.c (update_current_target): Inherit the above methods.
@
text
@a639 4
      INHERIT (to_set_checkpoint, t);
      INHERIT (to_unset_checkpoint, t);
      INHERIT (to_restore_checkpoint, t);
      INHERIT (to_info_checkpoints, t);
@


1.217
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d1835 1
a1835 1
			    CORE_ADDR addr, int len)
d1841 1
a1841 1
  return extract_unsigned_integer (buf, len);
d2799 1
d2810 1
a2810 1
	  ULONGEST val = extract_unsigned_integer (buf, size);
@


1.216
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d1467 1
a1467 1
                                paddr (address), phex (length, 0));
d2874 2
a2875 2
		      paddress (memaddr), len, write ? "write" : "read",
                      retval);
@


1.215
log
@	* target.h (struct target_ops): New member to_thread_architecture.
	(target_thread_architecture): New macro.
	* target.c (update_current_target): Inherit to_thread_architecture.
	(default_thread_architecture): New function.
	(debug_to_thread_architecture): New function.
	(setup_target_debug): Handle to_thread_architecture.

	* regcache.h (get_thread_arch_regcache): New.
	* regcache.c (struct regcache_list): New data type.
	(current_regcache): Hold regcache list instead of single regcache.
	(current_thread_ptid, current_thread_arch): New static variables.
	(get_thread_arch_regcache): New function.
	(get_thread_regcache): Use it.  Call target_thread_architecture.
	(regcache_thread_ptid_changed): Update to current_regcache changes.
	(registers_changed): Likewise.  Reset current_thread_arch and
	current_thread_ptid.

	* remote.c (remote_wait): Access target registers in target_gdbarch.
	* linux-nat.c (linux_nat_do_thread_registers): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* solib-svr4.c (enable_break): Likewise.
	(svr4_relocate_main_executable): Likewise.
@
text
@d109 2
a110 1
static int debug_to_insert_breakpoint (struct bp_target_info *);
d112 2
a113 1
static int debug_to_remove_breakpoint (struct bp_target_info *);
d117 2
a118 1
static int debug_to_insert_hw_breakpoint (struct bp_target_info *);
d120 2
a121 1
static int debug_to_remove_hw_breakpoint (struct bp_target_info *);
d686 1
a686 1
	    (int (*) (struct bp_target_info *))
d689 1
a689 1
	    (int (*) (struct bp_target_info *))
d2912 2
a2913 1
debug_to_insert_breakpoint (struct bp_target_info *bp_tgt)
d2917 1
a2917 1
  retval = debug_target.to_insert_breakpoint (bp_tgt);
d2927 2
a2928 1
debug_to_remove_breakpoint (struct bp_target_info *bp_tgt)
d2932 1
a2932 1
  retval = debug_target.to_remove_breakpoint (bp_tgt);
d3017 2
a3018 1
debug_to_insert_hw_breakpoint (struct bp_target_info *bp_tgt)
d3022 1
a3022 1
  retval = debug_target.to_insert_hw_breakpoint (bp_tgt);
d3032 2
a3033 1
debug_to_remove_hw_breakpoint (struct bp_target_info *bp_tgt)
d3037 1
a3037 1
  retval = debug_target.to_remove_hw_breakpoint (bp_tgt);
@


1.214
log
@	gdb/
	* NEWS: Document inlined function support.
	* Makefile.in (SFILES): Add inline-frame.c.
	(COMMON_OBS): Add inline-frame.o.
	* block.c (contained_in): Rewrite to use lexical nesting.
	(block_linkage_function): Skip inlined function blocks.
	(block_inlined_p): New.
	* block.h (struct block): Update comment.
	(block_inlined_p): New prototype.
	* blockframe.c (get_frame_block): Handle inlined functions.
	(get_frame_function): Do not use block_linkage_function.
	(block_innermost_frame): Use get_frame_block and contained_in.
	* breakpoint.c (watchpoint_check): Remove extra reinit_frame_cache.
	Skip over inlined functions.  Simplify epilogue check.
	(bpstat_check_breakpoint_conditions): Use get_stack_frame_id.
	Update comments.
	(set_momentary_breakpoint): Only accept non-inlined frames.
	(watch_command_1): Use frame_unwind_caller_pc and
	frame_unwind_caller_id instead of get_prev_frame.
	(until_break_command): Likewise.  Use get_stack_frame_id.
	* buildsym.c (end_symtab): Set SYMBOL_SYMTAB for block functions.
	* dwarf2loc.c (dwarf_expr_frame_base): Use block_linkage_function.
	* dwarf2read.c (process_die): Handle DW_TAG_inlined_subroutine.
	(read_func_scope, new_symbol): Likewise.  Handle arguments specially
	for inlined functions without call site information.
	(inherit_abstract_dies): Allow tag mismatch for inlined subroutines.
	(die_specification): Treat DW_AT_abstract_origin as a specification.
	(read_type_die): Handle DW_TAG_inlined_subroutine.
	* frame-unwind.c (frame_unwind_init): Add inline_frame_unwind.
	* frame.c (fprint_frame_id): Print inline depth.
	(fprint_frame_type): Handle INLINE_FRAME and SENTINEL_FRAME.
	(skip_inlined_frames, get_stack_frame_id): New.
	(frame_unwind_caller_id): Use skip_inlined_frames.
	(frame_id_inlined_p): New.
	(frame_id_eq): Make the logic match the comments.  Add inline_depth
	check.
	(frame_id_inner): Handle inlined functions.
	(frame_unwind_pc): New function, copied from frame_unwind_caller_pc.
	(frame_unwind_caller_pc): Use skip_inlined_frames and frame_unwind_pc.
	(get_prev_frame_1): Check for inline frames.  Split out frame
	allocation to get_prev_frame_raw.
	(get_prev_frame_raw): New function.
	(get_prev_frame): Handle inline frames.
	(get_frame_pc): Use frame_unwind_pc.
	(get_frame_address_in_block): Skip inlined frames on both sides.
	(pc_notcurrent): Delete.
	(find_frame_sal): Rewrite to handle inline call sites.  Use
	get_frame_address_in_block.
	(deprecated_update_frame_pc_hack): Make static.
	* frame.h: Update comments.
	(struct frame_id): Add inline_depth.
	(enum frame_type): Add INLINE_FRAME.
	(frame_id_inlined_p, get_stack_frame_id): New prototypes.
	* gdbthread.h (struct thread_info): Add step_stack_frame_id field.
	* infcmd.c (set_step_frame): New function.
	(step_once): Use set_step_frame.  Handle inlined functions.
	(until_next_command): Use set_step_frame.
	(finish_backward), finish_forward): Use get_stack_frame_id.
	(finish_command): Support inlined functions.
	* inferior.h (set_step_info): New prototype.
	* infrun.c (RESUME_ALL): Use minus_one_ptid.
	(clear_proceed_status): Clear step_stack_frame_id.
	(init_wait_for_inferior): Call clear_inline_frame_state.
	(init_execution_control_state): Make static.
	(set_step_info): New function.
	(init_thread_stepping_state): Do not set the symtab or line here.
	(stepped_in_from): New function.
	(handle_inferior_event): Handle inlined functions.  Use set_step_info.
	(insert_step_resume_breakpoint_at_frame): Use get_stack_frame_id.
	(struct inferior_status): Add step_stack_frame_id.
	(save_inferior_status, restore_inferior_status): Save and restore
	step_stack_frame_id.
	* inline-frame.c, inline-frame.h: New files.
	* minsyms.c (prim_record_minimal_symbol_and_info): Use XCALLOC.
	* regcache.c (regcache_write_pc): Call reinit_frame_cache.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Handle INLINE_FRAME.
	* stack.c (frame_show_address): New.
	(print_frame_info, print_frame): Use it.
	(find_frame_funname): Use get_frame_function.  Handle inlined blocks.
	(frame_info): Mark inlined functions.
	(backtrace_command_1): Use get_current_user_frame.
	(print_frame_local_vars, print_frame_label_vars): Update comments.
	(return_command): Refuse inlined functions.
	* symtab.c (lookup_symbol_aux_local): Stop at inlined function
	boundaries.
	(find_function_start_sal): Avoid inlined functions.
	(completion_list_add_fields): New function.
	(default_make_symbol_completion_list): Use it.  Use block_static_block
	and block_global_block.  Check for inlined functions.
	(skip_prologue_using_sal): Avoid line number comparison across
	inlining.
	* symtab.h (struct symbol): Add is_inlined.
	(SYMBOL_INLINED): New.
	* target.c (target_resume): Call clear_inline_frame_state.
	* valops.c (value_of_variable): Check block_inlined_p.

	gdb/doc/
	* gdb.texinfo (Debugging Optimized Code): New chapter.
	(Compiling for Debugging): Reference it.  Move some
	text to the new section.

	gdb/testsuite/
	* gdb.base/break.exp: Add an XFAIL for gcc/36748.
	* gdb.cp/annota2.exp: Accept frames-invalid in more places.
	* gdb.opt/Makefile.in (EXECUTABLES): Update.
	* gdb.opt/clobbered-registers-O2.exp: Update to GPL v3.
	* gdb.opt/inline-bt.c, gdb.opt/inline-bt.exp,
	gdb.opt/inline-cmds.c, gdb.opt/inline-cmds.exp,
	gdb.opt/inline-locals.c, gdb.opt/inline-locals.exp,
	gdb.opt/inline-markers.c: New files.
	* lib/gdb.exp (skip_inline_frame_tests): New function.
	(skip_inline_var_tests): New function.
@
text
@d96 3
d636 1
d777 2
d2457 6
d3251 13
d3337 1
@


1.213
log
@	* target.h (struct target_ops): Make to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	methods instead of variables.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1)
	(target_has_registers_1, target_has_execution_1): Declare
	functions.
	(target_has_all_memory): Rewrite to call target_has_all_memory_1.
	(target_has_memory): Rewrite to call target_has_memory_1.
	(target_has_stack): Rewrite to call target_has_all_stack_1.
	(target_has_registers): Rewrite to call target_has_registers_1.
	(target_has_execution): Rewrite to call target_has_execution_1.
	(default_child_has_all_memory, default_child_has_memory)
	(default_child_has_stack, default_child_has_registers)
	(default_child_has_execution): Declare.
	(target_mark_running, target_mark_exited): Delete declarations.
	* target.c (default_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution): New.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1,
	target_has_registers_1, target_has_execution_1): New.
	(add_target): Default the to_has_all_memory, to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	callbacks to return 0.
	(update_current_target): Do not inherit to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers or to_has_execution.
	(target_mark_running, target_mark_exited): Delete.
	(memory_xfer_partial): Adjust.
	(target_read_memory, target_write_memory, target_search_memory):
	Dispatch to the the top-most target, not the flattened
	current_target.
	(target_info): Adjust.
	(init_dummy_target): Install return_zero as callback for
	to_has_all_memory, to_has_memory, to_has_stack, to_has_registers,
	to_has_execution.
	(set_maintenance_target_async_permitted): Use have_live_inferiors
	instead of target_has_execution.
	* target-memory.c (target_write_memory_blocks): Dispatch memory
	writes to the the top-most target, not the flattened
	current_target.

	* breakpoint.c (insert_breakpoints): Don't check for
	target_has_execution here.
	(update_global_location_list): Check if there are live inferiors
	to debug instead of target_has_execution.
	* infcmd.c (kill_command, detach_command): Check if there are
	inferiors instead of target_has_execution.
	* inferior.h (have_live_inferiors): Declare.
	* inferior.c (have_live_inferiors): New.
	* infrun.c (normal_stop): Don't check for target_has_execution to
	finish the thread states.
	* thread.c (is_thread_state, is_stopped, is_exited, is_running)
	(any_running, is_executing): Remove checks for
	target_has_execution.
	* top.c (kill_or_detach): Don't try to kill core inferiors.
	(quit_target): Don't check for target_has_execution.

	* corelow.c (core_has_memory, core_has_stack, core_has_registers):
	New.
	(init_core_ops): Install core_has_memory, core_has_stack and
	core_has_registers.
	* exec.c (exec_has_memory): New.
	(init_exec_ops): Install exec_has_memory.
	* remote.c (remote_add_inferior): Don't call target_mark_running.
	(remote_start_remote): Don't call target_mark_exited or call
	target_mark_running.
	(remote_open_1): Use have_inferiors instead of
	target_has_execution.  Don't use target_mark_exited.
	(init_remote_ops): Install deafult_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution.
	* bsd-kvm.c (bsd_kvm_return_one): New.
	(bsd_kvm_add_target): Register bsd_kvm_return_one as
	to_has_memory, to_has_stack and to_has_registers callbacks.
	* remote-m32r-sdi.c (m32r_return_one): New.
	(init_m32r_ops): Register it.
	* inf-child.c (inf_child_target): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.
	* gnu-nat.c (init_gnu_ops): Likewise.
	* go32-nat.c (init_go32_ops): Likewise.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* monitor.c (init_base_monitor_ops): Likewise.
	* nto-procfs.c (init_procfs_ops): Likewise.
	* remote-mips.c (_initialize_remote_mips): Likewise.
	* windows-nat.c (init_windows_ops): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Don't use
	target_mark_running or target_mark_exited.
	(gdbsim_mourn_inferior): Don't call target_mark_exited.
	(init_gdbsim_ops): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.

	* linux-nat.c (linux_nat_xfer_partial): If reading memory, and
	there's no inferior selected, defer to a lower stratum.
@
text
@d45 1
d2041 1
@


1.212
log
@	* target.c: Include "exec.h".
	(update_current_target): Don't inherit to_sections or
	to_sections_end.
	(target_get_section_table): New.
	(target_section_by_addr): Fetch the section table from the passed
	in target.
	(memory_xfer_partial): Handle unmapped overlay sections before
	anything else.  Get the overlay mapped address here.  Adjust to
	use section_table_xfer_memory_partial.
	(get_target_memory): Request a TARGET_OBJECT_RAW_MEMORY object
	instead of TARGET_OBJECT_MEMORY.
	(target_resize_to_sections): Delete.
	(remove_target_sections): Adjust to remove target sections from
	`current_target_sections', and use resize_section_table.
	* target.h (struct target_ops) <to_sections, to_sections_end>:
	Remove fields.
	<to_get_section_table>: New method.
	(xfer_memory, print_section_info): Delete declarations.
	(struct target_section_table): New type.
	(target_get_section_table): Declare.
	(target_resize_to_sections): Delete declaration.
	(remove_target_sections): Delete declaration.
	* bfd-target.c (target_bfd_xfer_partial): Get the section table
	from to_data.
	(target_bfd_get_section_table): New.
	(target_bfd_xclose): Adjust.
	(target_bfd_reopen): Store the section table in the to_data field.
	* corelow.c (core_data): New.
	(core_close): Adjust to release core_data and its sections.
	(core_open): Allocate core_data, and build its target sections
	table.
	(deprecated_core_resize_section_table): New.
	(core_files_info): Pass core_data to print_section_info.
	(core_xfer_partial): Adjust to use
	section_table_xfer_memory_partial for TARGET_OBJECT_MEMORY xfers.
	(init_core_ops): Do not install a deprecated_xfer_memory callback
	anymore.
	* solib.c (update_solib_list): Add the shared library sections
	to the current target sections table.
	* exec.c (current_target_sections_1): New global.
	(current_target_sections): New global.
	(exec_close_1): New function, refactored from exec_close.  Remove
	the exec_bfd's sections from the current target sections table.
	Adjust to not use to_sections.
	(exec_close): Remove all target sections.  Call exec_close_1.
	(exec_file_clear): Use exec_close_1 instead of unpushing the
	target.
	(exec_file_attach): Likewise.  Adjust to not use to_sections.  Add
	exec_bfd's sections to the current target sections table.  Don't
	push the exec_ops target here.
	(resize_section_table): New.
	(add_target_sections): New.
	(remove_target_sections): Moved here.
	(section_table_xfer_memory): Adjust to implement the xfer_partial
	interface, and rename to...
	(section_table_xfer_memory_partial): ... this, replacing the
	current function of that same name.
	(exec_get_section_table): New.
	(exec_xfer_partial): New.
	(xfer_memory): Delete.
	(print_section_info): Replace the target_ops parameter by a
	target_section_table parameter.
	(exec_files_info, set_section_command, exec_set_section_address):
	Adjust to use the current sections table.
	(init_exec_ops): Do not register a deprecated_xfer_memory
	callback.  Register to_xfer_partial and to_get_section_table
	callbacks.
	* infrun.c (handle_inferior_event): Update comments around
	solib_add.
	* rs6000-nat.c (xcoff_relocate_core): Adjust to use
	deprecated_core_resize_section_table.
	* exec.h (resize_section_table): Declare.
	(section_table_xfer_memory_partial): Add const char * argument.
	(remove_target_sections): Declare here.
	(add_target_sections): Declare.
	(print_section_info): Declare here.
	* gdbcore.h (deprecated_core_resize_section_table): Declare.
@
text
@d216 114
d339 15
d618 5
a622 5
      INHERIT (to_has_all_memory, t);
      INHERIT (to_has_memory, t);
      INHERIT (to_has_stack, t);
      INHERIT (to_has_registers, t);
      INHERIT (to_has_execution, t);
a789 50
/* Mark OPS as a running target.  This reverses the effect
   of target_mark_exited.  */

void
target_mark_running (struct target_ops *ops)
{
  struct target_ops *t;

  for (t = target_stack; t != NULL; t = t->beneath)
    if (t == ops)
      break;
  if (t == NULL)
    internal_error (__FILE__, __LINE__,
		    "Attempted to mark unpushed target \"%s\" as running",
		    ops->to_shortname);

  ops->to_has_execution = 1;
  ops->to_has_all_memory = 1;
  ops->to_has_memory = 1;
  ops->to_has_stack = 1;
  ops->to_has_registers = 1;

  update_current_target ();
}

/* Mark OPS as a non-running target.  This reverses the effect
   of target_mark_running.  */

void
target_mark_exited (struct target_ops *ops)
{
  struct target_ops *t;

  for (t = target_stack; t != NULL; t = t->beneath)
    if (t == ops)
      break;
  if (t == NULL)
    internal_error (__FILE__, __LINE__,
		    "Attempted to mark unpushed target \"%s\" as running",
		    ops->to_shortname);

  ops->to_has_execution = 0;
  ops->to_has_all_memory = 0;
  ops->to_has_memory = 0;
  ops->to_has_stack = 0;
  ops->to_has_registers = 0;

  update_current_target ();
}

d1258 1
a1258 1
      if (ops->to_has_all_memory)
d1375 4
a1378 1
  if (target_read (&current_target, TARGET_OBJECT_MEMORY, NULL,
d1388 4
a1391 1
  if (target_write (&current_target, TARGET_OBJECT_MEMORY, NULL,
d1844 1
a1844 1
      if (!t->to_has_memory)
d1853 1
a1853 1
      has_all_mem = t->to_has_all_memory;
d2257 1
a2257 1
      found = simple_search_memory (&current_target,
d2629 5
d3357 1
a3357 1
  if (target_has_execution)
@


1.211
log
@	* target.h (struct section_table): Rename to ...
	(struct target_section): ... this.
	* exec.c: Adjust all references.
	* exec.h: Adjust all references.
	* nto-tdep.c: Adjust all references.
	* nto-tdep.h: Adjust all references.
	* ppc-linux-tdep.c: Adjust all references.
	* rs6000-nat.c: Adjust all references.
	* s390-tdep.c: Adjust all references.
	* solib-darwin.c: Adjust all references.
	* solib-frv.c: Adjust all references.
	* solib-irix.c: Adjust all references.
	* solib-null.c: Adjust all references.
	* solib-osf.c: Adjust all references.
	* solib-pa64.c: Adjust all references.
	* solib-som.c: Adjust all references.
	* solib-sunos.c: Adjust all references.
	* solib-svr4.c: Adjust all references.
	* solib-target.c: Adjust all references.
	* solib.c: Adjust all references.
	* solist.h: Adjust all references.
	* symfile.c: Adjust all references.
	* symfile.h: Adjust all references.
	* target.c: Adjust all references.
@
text
@d44 1
a494 2
      INHERIT (to_sections, t);
      INHERIT (to_sections_end, t);
d1018 15
d1034 1
d1038 1
d1040 5
a1044 3
  for (secp = target->to_sections;
       secp < target->to_sections_end;
       secp++)
d1067 20
a1086 1
  /* Try the executable file, if "trust-readonly-sections" is set.  */
d1090 1
d1096 8
a1103 9
	return xfer_memory (memaddr, readbuf, len, 0, NULL, ops);
    }

  /* Likewise for accesses to unmapped overlay sections.  */
  if (readbuf != NULL && overlay_debugging)
    {
      struct obj_section *section = find_pc_overlay (memaddr);
      if (pc_in_unmapped_range (memaddr, section))
	return xfer_memory (memaddr, readbuf, len, 0, NULL, ops);
d1728 5
a1732 1
  if (target_read (ops, TARGET_OBJECT_MEMORY, NULL, buf, addr, len)
a2381 90
/*
 * Resize the to_sections pointer.  Also make sure that anyone that
 * was holding on to an old value of it gets updated.
 * Returns the old size.
 */

int
target_resize_to_sections (struct target_ops *target, int num_added)
{
  struct target_ops **t;
  struct target_section *old_value;
  int old_count;

  old_value = target->to_sections;

  if (target->to_sections)
    {
      old_count = target->to_sections_end - target->to_sections;
      target->to_sections = (struct target_section *)
	xrealloc ((char *) target->to_sections,
		  (sizeof (struct target_section)) * (num_added + old_count));
    }
  else
    {
      old_count = 0;
      target->to_sections = (struct target_section *)
	xmalloc ((sizeof (struct target_section)) * num_added);
    }
  target->to_sections_end = target->to_sections + (num_added + old_count);

  /* Check to see if anyone else was pointing to this structure.
     If old_value was null, then no one was. */

  if (old_value)
    {
      for (t = target_structs; t < target_structs + target_struct_size;
	   ++t)
	{
	  if ((*t)->to_sections == old_value)
	    {
	      (*t)->to_sections = target->to_sections;
	      (*t)->to_sections_end = target->to_sections_end;
	    }
	}
      /* There is a flattened view of the target stack in current_target,
	 so its to_sections pointer might also need updating. */
      if (current_target.to_sections == old_value)
	{
	  current_target.to_sections = target->to_sections;
	  current_target.to_sections_end = target->to_sections_end;
	}
    }

  return old_count;

}

/* Remove all target sections taken from ABFD.

   Scan the current target stack for targets whose section tables
   refer to sections from BFD, and remove those sections.  We use this
   when we notice that the inferior has unloaded a shared object, for
   example.  */
void
remove_target_sections (bfd *abfd)
{
  struct target_ops **t;

  for (t = target_structs; t < target_structs + target_struct_size; t++)
    {
      struct target_section *src, *dest;

      dest = (*t)->to_sections;
      for (src = (*t)->to_sections; src < (*t)->to_sections_end; src++)
	if (src->bfd != abfd)
	  {
	    /* Keep this section.  */
	    if (dest < src) *dest = *src;
	    dest++;
	  }

      /* If we've dropped any sections, resize the section table.  */
      if (dest < src)
	target_resize_to_sections (*t, dest - src);
    }
}




@


1.210
log
@	* linux-nat.c (linux_nat_terminal_inferior)
	(linux_nat_terminal_ours): Don't check sync_execution.
	* remote.c (remote_terminal_inferior, remote_terminal_ours):
	Don't check sync_execution.  Update comments.
	* target.c (target_terminal_inferior): New.
	* target.h (target_terminal_inferior): Delete macro, and declare
	as function.
	* event-top.c (async_disable_stdin): Make idempotent.  Don't give
	the target the terminal here.
	* inflow.c (terminal_ours_1): Don't return early without setting
	`terminal_is_ours'.
@
text
@d1020 1
a1020 1
struct section_table *
d1023 1
a1023 1
  struct section_table *secp;
d1052 1
a1052 1
      struct section_table *secp;
d2351 1
a2351 1
  struct section_table *old_value;
d2359 1
a2359 1
      target->to_sections = (struct section_table *)
d2361 1
a2361 1
		  (sizeof (struct section_table)) * (num_added + old_count));
d2366 2
a2367 2
      target->to_sections = (struct section_table *)
	xmalloc ((sizeof (struct section_table)) * num_added);
d2411 1
a2411 1
      struct section_table *src, *dest;
@


1.209
log
@	* target.h (TARGET_WNOHANG): New.
	* target.c (target_wait): Add `options' argument.  Adjust.
	(struct target_ops) <to_wait>: Add `options' argument.
	(target_wait): Add `options' argument.
	* infrun.c (wait_for_inferior): Pass 0 as options to
	target_wait (blocking wait).
	(fetch_inferior_event): Pass TARGET_WNOHANG as options to
	target_wait.
	* fork-child.c (startup_inferior): Pass 0 as options to
	target_wait (blocking wait).
	* linux-nat.c (linux_nat_create_inferior): Remove async masking.
	(linux_nat_wait_1): Add `target_options' argument.  Use it instead
	of checking on target_can_async_p.
	(linux_nat_wait): Add `target_options' argument.  Adjust.
	* remote.c (remote_wait_ns): Add `options' argument.  Adjust to
	check on TARGET_WNOWAIT instead of checking on remote_is_async_p.
	(remote_wait_as): Add `options' argument.  Adjust to check on
	TARGET_WNOWAIT instead of checking on remote_is_async_p.  If doing
	a blocking wait, keep waiting until an interesting event comes
	out.
	(remote_wait): Add `options' argument.  Don't loop here if the
	target is in async mode, and a blocking wait has been requested.

	* top.c (deprecated_target_wait_hook): Add `options' argument.
	* linux-thread-db.c (thread_db_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ptrace.c (inf_ptrace_wait): Add `options' argument.
	* record.c (record_beneath_to_wait): Add `options' argument.
	(record_wait): Add `options' argument, and pass it down to the
	layer beneath.
	* bsd-uthread.c (bsd_uthread_wait): Add `options' argument.
	* darwin-nat.c (darwin_wait): Likewise.
	* defs.h (deprecated_target_wait_hook): Likewise.
	* gnu-nat.c (gnu_wait): Add `options' argument.
	* go32-nat.c (go32_wait): Likewise.
	* hpux-thread.c (hpux_thread_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ttrace.c (inf_ttrace_wait): Add `options' argument.
	* monitor.c (monitor_wait): Likewise.
	* nto-procfs.c (procfs_wait): Likewise.
	* remote-mips.c (mips_wait): Add `options' argument.
	* remote-sim.c (gdbsim_wait): Likewise.
	* rs6000-nat.c (rs6000_wait): Add `options' argument.
	* sol-thread.c (sol_thread_wait): Add `options' argument, and pass
	it down to the layer beneath.
	* spu-linux-nat.c (spu_child_wait): Add `options' argument.
	* windows-nat.c (windows_wait): Likewise.
	* tui/tui-hooks.c (tui_target_wait_hook): Likewise.  Adjust.
@
text
@d304 12
@


1.208
log
@	* breakpoint.c (insert_breakpoints, breakpoint_init_inferior)
	(update_global_location_list): Use gdbarch_has_global_breakpoints
	instead of gdbarch_has_global_solist and
	target_supports_multi_process.
	* dicos-tdep.c (dicos_init_abi): Set
	gdbarch_has_global_breakpoints.
	* gdbarch.sh (has_global_solist): Update comment.
	(has_global_breakpoints): New.
	* remote.c (remote_start_remote): Use
	gdbarch_has_global_breakpoints instead of
	gdbarch_has_global_solist.
	* target.c (target_detach): Use gdbarch_has_global_breakpoints
	instead of gdbarch_has_global_solist.
	* infcmd.c (attach_command): Use gdbarch_has_global_solist instead
	of target_supports_multi_process.
@
text
@d1839 1
a1839 1
target_wait (ptid_t ptid, struct target_waitstatus *status)
d1847 1
a1847 1
	  ptid_t retval = (*t->to_wait) (t, ptid, status);
@


1.207
log
@	Unify target macros.

	* target.h (STOPPED_BY_WATCHPOINT): Delete, replaced by ...
	(target_stoppped_by_watchpoint): New macro.
	(HAVE_STEPPABLE_WATCHPOINT): Delete, replaced by ...
	(target_have_steppable_watchpoint): New macro.
	(HAVE_CONTINUABLE_WATCHPOINT): Delete, replace by ...
	(target_have_continuable_watchpoint): New macro.
	(TARGET_CAN_USE_HARDWARE_WATCHPOINT):Delete, replaced by ...
	(target_can_use_hardware_watchpoint): New macro.
	(TARGET_REGION_OK_FOR_HW_WATCHPOINT):Delete, replaced by ...
	(target_region_ok_for_hw_watchpoint): New macro.

	* breakpoint.c (update_watchpoint): Use new macros.
	(bpstat_alloc): Likewise.
	(create_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(can_use_hardware_watchpoint): Likewise.
	(do_enable_breakpoint): Likewise.
	* infrun.c (handle_inferior_event): Adapt to new macros.
	* mips-tdep.c (mips_gdbarch_init): Update comments.
	* procfs.c (procfs_set_watchpoint): Update comment.
	(procfs_insert_watchpoint): Adapt to new macros.
	* remote-m32r-sdi.c (m32r_stop):
	* remote-mips.c (mips_remove_breakpoint):
	* target.c (debug_to_region_ok_for_hw_watchpoint): Update to new macros.
	(debug_to_stopped_by_watchpoint): Likewise.
@
text
@d1791 1
a1791 1
  if (gdbarch_has_global_solist (target_gdbarch))
@


1.206
log
@        * target.c (target_mourn_inferior): Call bfd_cache_close_all
        after having executed the target mourn_inferior routine.
@
text
@d2892 1
a2892 1
		      "TARGET_REGION_OK_FOR_HW_WATCHPOINT (%ld, %ld) = 0x%lx\n",
d2907 1
a2907 1
		      "STOPPED_BY_WATCHPOINT () = %ld\n",
@


1.205
log
@        Add a target_ops parameter to the to_kill method in struct target_ops.

        * target.h (struct target_ops): Add a "target_ops *" parameter to
        method to_kill.
        (target_kill): Remove macro. Add declaration.
        * target.c (debug_to_kill): Delete, no longer necessary.
        (target_kill): New function.
        (update_current_target):  Stop inheriting the to_kill method.
        Do not de_fault it to no_process either.
        (setup_target_debug): Do not set current_target.to_kill.
        * gnu-nat.c, go32-nat.c, hpux-thread.c, inf-ptrace.c, inf-ttrace.c,
        linux-nat.c, monitor.c, nto-procfs.c, procfs.c, remote-m32r-sdi.c,
        remote-mips.c, remote-sim.c, remote.c, windows-nat.c: Update
        accordingly.
@
text
@d1944 6
@


1.204
log
@2009-02-25  Hui Zhu  <teawater@@gmail.com>

	* cli/cli-script.c (define_command): Add _() to query.
	* gnu-nat.c (inf_validate_task_sc): Ditto.
	* infcmd.c (kill_if_already_running): Ditto.
	(jump_command): Ditto.
	(attach_command): Ditto.
	* inflow.c (kill_command): Ditto.
	* infrun.c (handle_command): Ditto.
	* maint.c (maintenance_dump_me): Ditto.
	* memattr.c (mem_delete_command): Ditto.
	* monitor.c (monitor_interrupt_query): Ditto.
	* nto-procfs.c (interrupt_query): Ditto.
	* printcmd.c (undisplay_command): Ditto.
	* remote-mips.c (mips_kill): Ditto.
	* remote.c (interrupt_query): Ditto.
	* solib-irix.c (irix_open_symbol_file_object): Ditto.
	* solib-osf.c (osf_open_symbol_file_object): Ditto.
	* solib-pa64.c (pa64_open_symbol_file_object): Ditto.
	* solib-som.c (som_open_symbol_file_object): Ditto.
	* solib-svr4.c (open_symbol_file_object): Ditto.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Ditto.
	* target.c (kill_or_be_killed): Ditto.
	* tracepoint.c (delete_trace_command): Ditto.
	* top.c (quit_confirm): Add _() to s that will be used
	in query.
@
text
@a138 2
static void debug_to_kill (void);

d258 18
d449 1
a449 1
      INHERIT (to_kill, t);
a574 3
  de_fault (to_kill,
	    (void (*) (void))
	    noprocess);
a3040 8
debug_to_kill (void)
{
  debug_target.to_kill ();

  fprintf_unfiltered (gdb_stdlog, "target_kill ()\n");
}

static void
a3234 1
  current_target.to_kill = debug_to_kill;
@


1.203
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d344 1
a344 1
      if (query ("Kill it? "))
@


1.202
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@a99 6
static void debug_to_resume (ptid_t, int, enum target_signal);

static void debug_to_fetch_registers (struct regcache *, int);

static void debug_to_store_registers (struct regcache *, int);

a148 2
static int debug_to_thread_alive (ptid_t);

d407 1
a407 1
      INHERIT (to_resume, t);
d409 2
a410 2
      INHERIT (to_fetch_registers, t);
      INHERIT (to_store_registers, t);
d450 2
a451 2
      INHERIT (to_thread_alive, t);
      INHERIT (to_find_new_threads, t);
a503 9
  de_fault (to_resume,
	    (void (*) (ptid_t, int, enum target_signal))
	    noprocess);
  de_fault (to_fetch_registers,
	    (void (*) (struct regcache *, int))
	    target_ignore);
  de_fault (to_store_registers,
	    (void (*) (struct regcache *, int))
	    noprocess);
a599 6
  de_fault (to_thread_alive,
	    (int (*) (ptid_t))
	    return_zero);
  de_fault (to_find_new_threads,
	    (void (*) (void))
	    target_ignore);
d1872 2
d1875 19
a1893 3
  (*current_target.to_resume) (ptid, step, signal);
  set_executing (ptid, 1);
  set_running (ptid, 1);
d2605 24
a2628 2
static void
debug_to_post_attach (int pid)
d2630 8
a2637 1
  debug_target.to_post_attach (pid);
d2639 3
a2641 1
  fprintf_unfiltered (gdb_stdlog, "target_post_attach (%d)\n", pid);
d2645 1
a2645 1
debug_to_resume (ptid_t ptid, int step, enum target_signal siggnal)
d2647 1
a2647 1
  debug_target.to_resume (ptid, step, siggnal);
d2649 1
a2649 3
  fprintf_unfiltered (gdb_stdlog, "target_resume (%d, %s, %s)\n", PIDGET (ptid),
		      step ? "step" : "continue",
		      target_signal_to_name (siggnal));
d2727 2
a2728 2
static void
debug_to_fetch_registers (struct regcache *regcache, int regno)
d2730 11
a2740 2
  debug_target.to_fetch_registers (regcache, regno);
  debug_print_register ("target_fetch_registers", regcache, regno);
d2743 2
a2744 2
static void
debug_to_store_registers (struct regcache *regcache, int regno)
d2746 16
a2761 3
  debug_target.to_store_registers (regcache, regno);
  debug_print_register ("target_store_registers", regcache, regno);
  fprintf_unfiltered (gdb_stdlog, "\n");
a3172 21
static int
debug_to_thread_alive (ptid_t ptid)
{
  int retval;

  retval = debug_target.to_thread_alive (ptid);

  fprintf_unfiltered (gdb_stdlog, "target_thread_alive (%d) = %d\n",
		      PIDGET (ptid), retval);

  return retval;
}

static void
debug_to_find_new_threads (void)
{
  debug_target.to_find_new_threads ();

  fputs_unfiltered ("target_find_new_threads ()\n", gdb_stdlog);
}

a3209 3
  current_target.to_resume = debug_to_resume;
  current_target.to_fetch_registers = debug_to_fetch_registers;
  current_target.to_store_registers = debug_to_store_registers;
a3243 2
  current_target.to_thread_alive = debug_to_thread_alive;
  current_target.to_find_new_threads = debug_to_find_new_threads;
@


1.201
log
@	* linux-nat.c (linux_nat_wait): Adjust.
	(linux_nat_pid_to_str): Adjust.  Remove call to thread_db_init.
	* linux-nat.h (thread_db_init): Delete declaration.
	* linux-thread-db.c (target_beneath): Delete.
	(thread_db_init): Delete.
	(thread_db_detach): Use find_target_beneath.
	(thread_db_wait): Adjust interface.  Use find_target_beneath.
	(thread_db_mourn_inferior): Use find_target_beneath.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): Delete.
	(thread_db_pid_to_str): Adjust interface.  Use
	find_target_beneath.
	(thread_db_get_thread_local_address): Adjust interface.  Use
	find_target_beneath.
	(init_thread_db_ops): Delete references to delete functions.
	* target.c (update_current_target): Don't inherit or default
	to_wait.  Don't inherit to_pid_to_str and
	to_get_thread_local_address.
	(target_translate_tls_address): Look for a pushed target that
	implements to_get_thread_local_address, and use it instead of
	checking for target_get_thread_local_address_p.
	(target_wait, target_pid_to_str): Reimplement as functions.
	(dummy_pid_to_str): New.
	(init_dummy_target): Register it.
	(debug_to_wait): Delete.
	* target.h (struct target_ops): Make to_wait, to_pid_to_str and
	to_get_thread_local_address accept a pointer to struct target_ops.
	(target_wait): Delete macro, and declare as function.
	(target_pid_to_str): Likewise.
	(target_get_thread_local_address)
	(target_get_thread_local_address_p): Delete.
	(noprocess): Add NORETURN and ATTR_NORETURN tags.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	(inf_ptrace_pid_to_str): New.
	(inf_ptrace_target): Use inf_ptrace_pid_to_str.
	* aix-thread.c (aix_thread_wait, aix_thread_pid_to_str): Adjust.
	* bsd-kvm.c (bsd_kvm_pid_to_str): Adjust.
	* bsd-uthread.c (bsd_uthread_wait, bsd_uthread_pid_to_str):
	Adjust.
	* corelow.c (core_pid_to_str): Adjust.
	* darwin-nat.c (darwin_wait, darwin_pid_to_str): Adjust.
	* dec-thread.c (dec_thread_wait, dec_thread_pid_to_str): Adjust.
	* gnu-nat.c (gnu_wait, gnu_pid_to_str): Adjust.
	* go32-nat.c (go32_wait, go32_pid_to_str): Adjust.
	* hpux-thread.c (hpux_thread_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait, inf_ttrace_pid_to_str): Adjust.
	* monitor.c (monitor_wait, monitor_pid_to_str): Adjust.
	* nto-procfs.c (procfs_wait, procfs_pid_to_str): Adjust.
	* procfs.c (procfs_pid_to_str): Adjust.
	* remote-m32r-sdi.c (m32r_wait, m32r_pid_to_str): Adjust.
	* remote-mips.c (mips_wait): Adjust.
	* remote-sim.c (gdbsim_wait, gdbsim_pid_to_str): Adjust.
	* remote.c (remote_wait, remote_pid_to_str)
	(remote_get_thread_local_address): Adjust.
	* rs6000-nat.c (rs6000_wait): Adjust.
	* sol-thread.c (procfs_pid_to_str): Adjust declaration.
	(sol_thread_wait, solaris_pid_to_str): Adjust.
	* spu-linux-nat.c (spu_child_wait): Adjust.
	* windows-nat.c (windows_wait, windows_pid_to_str): Adjust.
@
text
@d373 1
a373 1
ptid_t
d2210 1
a2210 1
int
d2225 1
a2225 1
int
d2240 1
a2240 1
int
d2252 1
a2252 1
target_supports_non_stop ()
d2526 1
a2526 1
char *
@


1.200
log
@	* target.c (target_get_osdata): Check for equal or higher than
	process_stratum, not dummy_stratum.
@
text
@a101 2
static ptid_t debug_to_wait (ptid_t, struct target_waitstatus *);

d416 1
a416 1
      INHERIT (to_wait, t);
d455 1
a455 1
      /* Do no inherit to_mourn_inferiour.  */
d460 1
a460 1
      INHERIT (to_pid_to_str, t);
d482 1
a482 1
      INHERIT (to_get_thread_local_address, t);
a514 3
  de_fault (to_wait,
	    (ptid_t (*) (ptid_t, struct target_waitstatus *))
	    noprocess);
d851 9
d861 1
a861 1
  if (target_get_thread_local_address_p ()
d879 1
a879 1
	  addr = target_get_thread_local_address (ptid, lm_addr, offset);
d1848 44
d2526 6
d2562 1
a2562 1
  dummy_target.to_pid_to_str = normal_pid_to_str;
a2669 19
static ptid_t
debug_to_wait (ptid_t ptid, struct target_waitstatus *status)
{
  ptid_t retval;
  char *status_string;

  retval = debug_target.to_wait (ptid, status);

  fprintf_unfiltered (gdb_stdlog,
		      "target_wait (%d, status) = %d,   ", PIDGET (ptid),
		      PIDGET (retval));

  status_string = target_waitstatus_to_string (status);
  fprintf_unfiltered (gdb_stdlog, "%s\n", status_string);
  xfree (status_string);

  return retval;
}

a3185 1
  current_target.to_wait = debug_to_wait;
@


1.199
log
@	* remote.c (extended_remote_can_run): Delete.
	(init_remote_ops): Don't register it.
	* target.c (target_get_osdata): Don't check for target_can_run.
	Instead any target that has already been pushed, otherwise
	fallback to the default run target..
@
text
@d2221 6
a2226 1
  if (current_target.to_stratum == dummy_stratum)
a2227 2
  else
    t = current_target.beneath;
@


1.198
log
@	* target.c (target_create_inferior, target_detach)
	(target_mourn_inferior, target_attach, target_close): Do target
	debug output.
	(debug_to_attach, debug_to_detach, debug_to_create_inferior)
	(debug_to_mourn_inferior, debug_to_close): Delete.
	(setup_target_debug): Adjust.
@
text
@d2221 2
a2222 2
  if (target_can_run (&current_target))
    t = &current_target;
d2224 1
a2224 1
    t = find_default_run_target ("get OS data");
d2229 1
a2229 4
  document = target_read_stralloc (t,
                                  TARGET_OBJECT_OSDATA,
                                  type);
  return document;
@


1.197
log
@	* target.h (target_stopped_data_address_p): Delete declaration,
	and don't define as macro.
	* target.c (target_stopped_data_address_p): Delete.
@
text
@a99 6
static void debug_to_close (int);

static void debug_to_attach (struct target_ops *ops, char *, int);

static void debug_to_detach (struct target_ops *ops, char *, int);

a152 2
static void debug_to_mourn_inferior (struct target_ops *);

d276 3
a278 2
void target_create_inferior (char *exec_file, char *args,
			     char **env, int from_tty)
d286 4
d1811 3
d1886 2
a2523 7
static void
debug_to_close (int quitting)
{
  target_close (&debug_target, quitting);
  fprintf_unfiltered (gdb_stdlog, "target_close (%d)\n", quitting);
}

d2531 3
d2545 3
a2555 10

static void
debug_to_attach (struct target_ops *ops, char *args, int from_tty)
{
  debug_target.to_attach (&debug_target, args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_attach (%s, %d)\n", args, from_tty);
}


a2564 8
debug_to_detach (struct target_ops *ops, char *args, int from_tty)
{
  debug_target.to_detach (&debug_target, args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_detach (%s, %d)\n", args, from_tty);
}

static void
a2974 11
debug_to_create_inferior (struct target_ops *ops,
			  char *exec_file, char *args, char **env,
			  int from_tty)
{
  debug_target.to_create_inferior (ops, exec_file, args, env, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_create_inferior (%s, %s, xxx, %d)\n",
		      exec_file, args, from_tty);
}

static void
a3070 8
static void
debug_to_mourn_inferior (struct target_ops *ops)
{
  debug_target.to_mourn_inferior (&debug_target);

  fprintf_unfiltered (gdb_stdlog, "target_mourn_inferior ()\n");
}

a3148 2
  current_target.to_close = debug_to_close;
  current_target.to_attach = debug_to_attach;
a3149 1
  current_target.to_detach = debug_to_detach;
a3176 1
  current_target.to_create_inferior = debug_to_create_inferior;
a3185 1
  current_target.to_mourn_inferior = debug_to_mourn_inferior;
@


1.196
log
@	* target.h (target_waitstatus_to_string): Declare.
	* target.c (target_waitstatus_to_string): New function.  Copied from
	debug_to_wait.  Add missing entries for TARGET_WAITKIND_SYSCALL_ENTRY,
	TARGET_WAITKIND_SYSCALL_RETURN, TARGET_WAITKIND_IGNORE,
	TARGET_WAITKIND_NO_HISTORY.
	(debug_to_wait): Call it.
	* infrun.c (wait_for_inferior): If debug_infrun, print result of
	target_wait.
	(fetch_inferior_event): Ditto.
@
text
@a1355 15
#ifndef target_stopped_data_address_p
int
target_stopped_data_address_p (struct target_ops *target)
{
  if (target->to_stopped_data_address
      == (int (*) (struct target_ops *, CORE_ADDR *)) return_zero)
    return 0;
  if (target->to_stopped_data_address == debug_to_stopped_data_address
      && (debug_target.to_stopped_data_address
	  == (int (*) (struct target_ops *, CORE_ADDR *)) return_zero))
    return 0;
  return 1;
}
#endif

@


1.195
log
@        * target.c (target_xfer_partial): Use host_address_to_string to
        print the address of readbuf and writebuf. Cast the address of
        elements inside the myaddr buffer into intptr_t.
        (deprecated_debug_xfer_memory): Use paddress to print memaddr.
        Cast the address of elements inside the myaddr buffer into
        intptr_t.
@
text
@d2606 5
a2610 2
static ptid_t
debug_to_wait (ptid_t ptid, struct target_waitstatus *status)
d2612 1
a2612 3
  ptid_t retval;

  retval = debug_target.to_wait (ptid, status);
d2614 1
a2614 5
  fprintf_unfiltered (gdb_stdlog,
		      "target_wait (%d, status) = %d,   ", PIDGET (ptid),
		      PIDGET (retval));
  fprintf_unfiltered (gdb_stdlog, "status->kind = ");
  switch (status->kind)
d2617 2
a2618 3
      fprintf_unfiltered (gdb_stdlog, "exited, status = %d\n",
			  status->value.integer);
      break;
d2620 2
a2621 3
      fprintf_unfiltered (gdb_stdlog, "stopped, signal = %s\n",
			  target_signal_to_name (status->value.sig));
      break;
d2623 2
a2624 3
      fprintf_unfiltered (gdb_stdlog, "signalled, signal = %s\n",
			  target_signal_to_name (status->value.sig));
      break;
d2626 1
a2626 2
      fprintf_unfiltered (gdb_stdlog, "loaded\n");
      break;
d2628 1
a2628 2
      fprintf_unfiltered (gdb_stdlog, "forked\n");
      break;
d2630 1
a2630 2
      fprintf_unfiltered (gdb_stdlog, "vforked\n");
      break;
d2632 5
a2636 2
      fprintf_unfiltered (gdb_stdlog, "execd\n");
      break;
d2638 5
a2642 2
      fprintf_unfiltered (gdb_stdlog, "spurious\n");
      break;
d2644 1
a2644 2
      fprintf_unfiltered (gdb_stdlog, "unknown???\n");
      break;
d2646 17
@


1.194
log
@        Updated copyright notices for most files.
@
text
@d1203 1
a1203 1
			  "%s:target_xfer_partial (%d, %s, 0x%lx,  0x%lx,  %s, %s) = %s",
d1207 2
a1208 1
			  (long) readbuf, (long) writebuf,
d1223 1
a1223 1
	      if ((((long) &(myaddr[i])) & 0xf) == 0)
d2721 3
a2723 3
		      "target_xfer_memory (0x%x, xxx, %d, %s, xxx) = %d",
		      (unsigned int) memaddr,	/* possable truncate long long */
		      len, write ? "write" : "read", retval);
d2732 1
a2732 1
	  if ((((long) &(myaddr[i])) & 0xf) == 0)
@


1.193
log
@2008-12-16  Tristan Gingold  <gingold@@adacore.com>

	* inflow.c: Remove old_sigio, handle_sigio, old_fcntl_flags,
	set_sigio_trap, clear_sigio_trap definitions.
	* inferior.h: Remove set_sigio_trap and clear_sigio_trap declarations.
	* inf-ptrace.c (inf_ptrace_wait): Remove call to set_sigio_trap
	and clear_sigio_trap.
	* inf-ttrace.c (inf_ttrace_wait): Ditto.
	* linux-nat.c (linux_nat_wait): Ditto.
	* spu-linux-nat.c (spu_child_wait): Ditto.
	* rs6000-nat.c (rs6000_wait): Ditto.
	* target.c: Remove target_activity_function and target_activity_fd.
	* target.h: Remove target_activity_function and target_activity_fd
	declarations.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.193.2.1
log
@2008-12-26  Michael Snyder  <msnyder@@vmware.com>

	* Marker: adding teawater patches to branch.
@
text
@a43 1
#include "record.h"
a407 6
  record_beneath_to_resume = NULL;
  record_beneath_to_store_registers = NULL;
  record_beneath_to_xfer_partial = NULL;
  record_beneath_to_insert_breakpoint = NULL;
  record_beneath_to_remove_breakpoint = NULL;

a496 29

      /* Set pointers to functions in the target beneath us.  */
      if (t != &record_ops)
        {
           if (!record_beneath_to_resume)
             {
               record_beneath_to_resume = t->to_resume;
             }
           if (!record_beneath_to_wait)
             {
               record_beneath_to_wait = t->to_wait;
             }
           if (!record_beneath_to_store_registers)
             {
               record_beneath_to_store_registers = t->to_store_registers;
             }
           if (!record_beneath_to_xfer_partial)
             {
               record_beneath_to_xfer_partial = t->to_xfer_partial;
             }
           if (!record_beneath_to_insert_breakpoint)
             {
               record_beneath_to_insert_breakpoint = t->to_insert_breakpoint;
             }
           if (!record_beneath_to_remove_breakpoint)
             {
               record_beneath_to_remove_breakpoint = t->to_remove_breakpoint;
             }
        }
@


1.192
log
@	Implement -list-thread-groups --available

        * Makefile.in (XMLFILES): Add osdata.dtd.
        (SFILES): Add osdata.c.
        (COMMON_OBS): Add osdata.o.
        * linux-nat.c: Include pwd.h, sys/types.h, gdb_dirent.h and xml-support.h.
        (linux_nat_xfer_osdata): New function.
        (linux_xfer_partial): Handle TARGET_OBJECT_OSDATA.
        * osdata.c: New file.
        * osdata.h: New file.
        * remote.c (PACKET_qXfer_osdata): New packet enum.
        (remote_protocol_features): Add "qXfer:osdata:read".
        (remote_read_qxfer): Handle TARGET_OBJECT_OSDATA.
        (extended_remote_can_run): New.
        (init_extended_remote_ops): Set to_can_run to
        extended_remote_can_run.
        (_initialize_remote): Add packet config command for
        "qXfer:osdata:read".
        * xml-support.c (obstack_xml_printf): New function.
        * xml-support.h (obstack_xml_printf): Declare.
        * target.c (target_get_osdata): New function.
        * target.h (enum target_object): Add TARGET_OBJECT_OSDATA.
        (target_os_data): Declare.
        * features/osdata.dtd: New file.
        * mi/mi-main.c (mi_list_thread_groups): Handle the --available
        option.
@
text
@a2477 4
/* Returns zero to leave the inferior alone, one to interrupt it.  */
int (*target_activity_function) (void);
int target_activity_fd;

@


1.191
log
@	Kill pthread_ops_hack

	* target.h (struct target_ops): Make to_attach, to_detach,
	to_create_inferior and to_mourn_inferior accept a pointer
    	to struct target_ops.
	(target_attach, target_create_inferior, target_create_inferior):
	Convert from macros to function.  Find the right target to
	invoke a method of.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.
	* corefile.c (core_file_command): Pass target to to_detach.
	* corelow.c (core_detach): Add 'ops' parameter.
	* fork-child.c (fork_inferior): Return the pid.  Allow
	init_trace_fun to be NULL.
	* inf-ptrace (ptrace_ops_hack): Remove.
	(inf_ptrace_him): Remove, moving all logic into....
	(inf_ptrace_create_inferior): ... here.  Push the target
	passed as parameter.
	(inf_ptrace_mourn_inferior, inf_ptrace_attach, inf_ptrace_detach):
	Push/pop target passed as parameter, no ptrace_ops_hack.
	(inf_ptrace_target): Don't remember result.
	* inferior.h (fork_inferior): Adjust prototype.
	* linux-nat.c (linux_nat_create_inferior, linux_nat_attach)
	(linux_nat_detach, linux_nat_mourn_inferior): New parameter ops.
	Pass it to linux_ops target.
	* linux-thread-db.c (thread_db_detach, thread_db_mourn_inferior):
	New parameter ops. Pass it to the target beneath.
	* remote.c (remote_mourn, extended_remote_mourn, remote_detach)
	(extended_remote_create_inferior): New parameter ops. Pass it
	further.
	* target.c (debug_to_attach, debug_to_detach)
	(debug_to_mourn_inferior): New parameter ops.
	(target_create_inferior): New.
	(update_current_target): Do not inherit to_attach, to_detach,
	to_create_inferiour, to_mourn_inferior.  Do not default
	to_detach and to_mourn_inferior.
	(target_detach): Find the right target to use.
	(target_mourn_inferior): New.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.  Pass the found target when calling its method.
	(init_dummy_target): Provide fallback definition of to_detach.
	(target_attach): New.
	(debug_to_attach, debug_to_detach, debug_to_create_inferior)
	(debug_to_mourn_inferiour): New parameter ops.
        * aix-thread.c: Adjust.
        * bsd-uthread.c: Adjust.
        * gnu-nat.c: Adjust.
        * go32-nat.c: Adjust.
        * hpux-thread.c: Adjust.
        * inf-ttrace.c: Ajust.
        * monitor.c: Adjust.
        * nto-procfs.c: Adjust.
        * procfs.c: Adjust.
        * remote-m32r-sdi.c: Adjust.
        * remote-mips.c: Adjust.
        * remote-sim.c: Adjust.
        * rs6000-nat.c: Adjust.
        * sol-thread.c: Adjust.
        * win32-nat.c: Adjust.
	* dec-thread.c: Adjust.
@
text
@d2227 20
@


1.191.2.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a32 1
#include "exec.h"
a2270 2
  struct exec *exec;
  int ix;
a2309 9
      
      for (ix = 0; VEC_iterate (exec_p, execs, ix, exec); ++ix)
	{
	  if (exec->sections == old_value)
	    {
	      exec->sections = target->to_sections;
	      exec->sections_end = target->to_sections_end;
	    }
	}
@


1.190
log
@	* remote.c (remote_start_remote): If the solib list is global,
	fetch libraries and insert breakpoints after connecting.
	* infcmd.c (post_create_inferior): If the solist is shared between
	inferiors, no need to refetch it on every new inferior.
	(detach_command): If the shared library list is shared between
	inferiors, then don't clear it on every inferior detach.
	* gdbarch.sh (has_global_solist): New.
	* i386-dicos-tdep.c (i386_dicos_init_abi): Set
	gdbarch_has_global_solist.
	* target.c (target_pre_inferior): If the shared library list is
	shared between inferiors, then don't clear it here, neither
	invalidate the memory regions or clear the target description.
	(target_detach): If the shared library list is shared between
	inferiors, then don't remove breakpoints from the target here.
	(target_disconnect): Comment.
	* solib.c (update_solib_list): Check for null_ptid.
	* breakpoint.c (insert_breakpoints, update_global_location_list):
	If the shared library list is shared between inferiors, insert
	breakpoints even if there's no execution.
	(breakpoint_init_inferior): If the shared library list is shared
	between inferiors, don't delete breakpoints or mark them
	uninserted here.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d102 1
a102 1
static void debug_to_attach (char *, int);
d104 1
a104 1
static void debug_to_detach (char *, int);
d159 1
a159 1
static void debug_to_mourn_inferior (void);
d284 18
d415 1
a415 1
      INHERIT (to_attach, t);
d418 1
a418 1
      INHERIT (to_detach, t);
d449 1
a449 1
      INHERIT (to_create_inferior, t);
d460 1
a460 1
      INHERIT (to_mourn_inferior, t);
a516 3
  de_fault (to_detach,
	    (void (*) (char *, int))
	    target_ignore);
a619 3
  de_fault (to_mourn_inferior,
	    (void (*) (void))
	    noprocess);
d1812 2
d1823 10
a1832 1
  (current_target.to_detach) (args, from_tty);
d1891 17
d2153 1
a2153 1
find_default_attach (char *args, int from_tty)
d2158 1
a2158 1
  (t->to_attach) (args, from_tty);
d2163 2
a2164 1
find_default_create_inferior (char *exec_file, char *allargs, char **env,
d2170 1
a2170 1
  (t->to_create_inferior) (exec_file, allargs, env, from_tty);
d2498 2
d2536 18
d2555 1
a2555 1
debug_to_attach (char *args, int from_tty)
d2557 1
a2557 1
  debug_target.to_attach (args, from_tty);
d2572 1
a2572 1
debug_to_detach (char *args, int from_tty)
d2574 1
a2574 1
  debug_target.to_detach (args, from_tty);
d2977 2
a2978 1
debug_to_create_inferior (char *exec_file, char *args, char **env,
d2981 1
a2981 1
  debug_target.to_create_inferior (exec_file, args, env, from_tty);
d3085 1
a3085 1
debug_to_mourn_inferior (void)
d3087 1
a3087 1
  debug_target.to_mourn_inferior ();
@


1.189
log
@	* target.h (struct target_ops) <to_supports_multi_process>: New
	field.
	(target_supports_multi_process): New define.
	* target.c (update_current_target): Inherit and de_fault
	to_supports_multi_process.
	* infcmd.c (attach_command): Allow attaching to multiple processes
	if the target supports it.
	(detach_command): If the target claims there is still execution,
	don't clear the thread list.
	* remote.c (remote_supports_multi_process): New.
	(init_remote_ops): Register remote_supports_multi_process.
@
text
@a1754 1
  no_shared_libraries (NULL, from_tty);
d1756 8
a1763 1
  invalidate_target_mem_regions ();
d1765 2
a1766 1
  target_clear_description ();
d1800 8
a1807 3
  /* If we're in breakpoints-always-inserted mode, have to
     remove them before detaching.  */
  remove_breakpoints ();
d1817 3
a1819 2
  /* If we're in breakpoints-always-inserted mode, have to
     remove them before disconnecting.  */  
@


1.188
log
@        * target.h (struct target_ops): Add new field to_get_ada_task_ptid.
        (target_get_ada_task_ptid): New macro.
        * target.c (default_get_ada_task_ptid): New function.
        (update_current_target): Inherit field default_get_ada_task_ptid.
        (update_current_target): Make default_get_ada_task_ptid the default
        value for field to_get_ada_task_ptid.
        * ada-lang.h (struct task_control_block): Delete. Never used.
        (struct task_ptid, task_ptid_t, struct task_entry, task_list):
        Likewise.
        (struct ada_task_info): New.
        (ada_task_is_alive, ada_find_printable_frame)
        (ada_task_list_iterator_ftype, iterate_over_live_ada_tasks): Add
        declarations.
        (ada_build_task_list): Update prototype.
        (init_task_list, ada_is_exception_breakpoint): Remove prototypes.
        * ada-lang.c (ada_find_printable_frame): Make non-static.
        * ada-tasks.c: New file.
        * Makefile.in (SFILES): Add ada-tasks.c.
        (COMMON_OBS): Add ada-tasks.o.
        * linux-thread-db.c (thread_db_find_thread_from_tid)
        (thread_db_get_ada_task_ptid): New functions.
        (init_thread_db_ops): Set thread_db_ops.to_get_ada_task_ptid.
@
text
@d474 1
d642 3
@


1.187
log
@2008-10-17  Michael Snyder  <msnyder@@vmware.com>
	Target interface for reverse debugging.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(struct target_ops): New method to_can_execute_reverse.
	(target_can_execute_reverse): New macro.
	* target.c (update_current_target): Inherit to_can_execute_reverse.

	Remote interface for reverse debugging.
	* remote.c (remote_can_execute_reverse): New target method.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait_as): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(remote_vcont_resume): Jump out if attempting reverse execution.

	Event handling interface for reverse debugging.
	* infrun.c (execution_direction): New state variable.
	(enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.
	(step_into_function): Rename to handle_step_into_function.
	(handle_step_into_function_backward): New function.
	(set_exec_direction_func, show_exec_direction_func): New funcs.
	(proceed): No need to singlestep over a breakpoint
	when resuming in reverse.

	* inferior.h (enum exec_direction_kind): New enum.
	(execution_direction): Export new execution state variable.

	* breakpoint.c (make_breakpoint_silent): New function.
	* breakpoint.h (make_breakpoint_silent): Export.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.

	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.
@
text
@d354 12
d472 1
d638 3
@


1.186
log
@	Remove dead code.

	* breakpoint.c (show_breakpoint_hit_counts): Delete.
	(print_one_breakpoint_location): Adjust.
	(breakpoint_clear_ignore_counts): Delete.
	* breakpoint.h (breakpoint_clear_ignore_counts): Remove
	declaration.
	* target.c (generic_mourn_inferior): Don't clear ignore
	counts (never reached).
@
text
@d458 1
@


1.185
log
@	* remote.c (remote_open_1): Move acknowledging any pending ack,
	querying supported features, activating noack mode, finding the
	target description, enabling extended remote, and checking remote
	symbols from here ...
	(remote_start_remote): ... to here.
	(remote_open_1): Don't pop the target if it is already gone.
	* target.c (unpush_target): Check for the dummy target.
@
text
@a2338 1
  extern int show_breakpoint_hit_counts;
a2355 7
  /* It is confusing to the user for ignore counts to stick around
     from previous runs of the inferior.  So clear them.  */
  /* However, it is more confusing for the ignore counts to disappear when
     using hit counts.  So don't clear them if we're counting hits.  */
  if (!show_breakpoint_hit_counts)
    breakpoint_clear_ignore_counts ();

@


1.184
log
@	Remove the attach_flag global, and make it per-inferior.

	* inferior.h (attach_flag): Delete.
	(inferior_process): Declare.
	* solib.c (update_solib_list): Adjust.
	* gnu-nat.c (gnu_create_inferior, gnu_attach): Adjust.
	* inf-ptrace.c (inf_ptrace_detach): Adjust.
	(inf_ptrace_files_info): Get it from the current inferior.
	* inf-ttrace.c (inf_ttrace_attach): Adjust.
	(inf_ttrace_files_info): Get it from the current
	inferior.
	* inflow.c (terminal_inferior, terminal_ours_1, set_sigint_trap)
	(clear_sigint_trap): Get it from the current process.
	* remote.c (extended_remote_attach_1)
	(extended_remote_create_inferior_1): Adjust.
	* top.c (quit_confirm, quit_target): Get it from the current inferior.
	* procfs.c (do_detach): Adjust.
	(procfs_wait): Get it from the event inferior.
	(procfs_files_info): Get it from the current inferior.
	* nto-procfs.c (procfs_files_info): Likewise.
	(procfs_attach): Adjust.  Set the attach_flag here.
	(do_attach): Don't set it here.
	(procfs_detach): Don't clear it.
	(procfs_mourn_inferior): Don't clear it.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* target.c (attach_flag): Delete.
	(generic_mourn_inferior): Don't clear it.
	* win32-nat.c (get_win32_debug_event): Get it from the event
	process.
	(do_initial_win32_stuff): Add attaching argument.  Set attach_flag
	in the inferior accordingly.
	(win32_attach): Don't set the attach_flag here.  Pass 1 to
	do_intial_win32_stuff.
	(win32_files_info): Get it from the current inferior.
	(win32_create_inferior): Dont clear attach_flag here.  Pass 0 to
	do_intial_win32_stuff.
@
text
@d749 4
@


1.184.2.1
log
@2008-09-30  Michael Snyder  <msnyder@@vmware.com>
	Target interface for reverse debugging.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	* target.c (target_get_execdir): New generic method.
	(target_set_execdir): Ditto.
@
text
@a457 2
      INHERIT (to_get_execdir, t);
      INHERIT (to_set_execdir, t);
@


1.184.2.2
log
@2008-09-30  Hui Zhu  <teawater@@gmail.com>
	Add process record and replay to GDB.
	* record.c, record.h: New files. Record and reverse target.
	* gdbarch.sh: New methods process_record and process_record_dasm.
	* gdbarch.c, gdbarch.h: Re-generate.
	* target.h (enum strata): Add record_stratum.
	* target.h (target_ops): Add a element "to_support_record_wait".
	Default value is 0. meaning that this target doesn't support record
	wait.
	* target.c: Add include of "record.h".
	(update_current_target): Set the real beneath function.
	(add_target): Set the default value of "to_support_record_wait".
	pointers.
 	* Makefile.in: Add files record.c, record.o.
@
text
@a43 1
#include "record.h"
a243 3
  /* Set the default value of to_support_record_wait. */
  t->to_support_record_wait = 0;

a377 6
  record_beneath_to_resume = NULL;
  record_beneath_to_prepare_to_store = NULL;
  record_beneath_to_xfer_partial = NULL;
  record_beneath_to_insert_breakpoint = NULL;
  record_beneath_to_remove_breakpoint = NULL;

a465 29

      /* Set the real beneath function pointers. */
      if (t != &record_ops)
        {
           if (!record_beneath_to_resume)
             {
               record_beneath_to_resume = t->to_resume;
             }
           if (!record_beneath_to_wait)
             {
               record_beneath_to_wait = t->to_wait;
             }
           if (!record_beneath_to_prepare_to_store)
             {
               record_beneath_to_prepare_to_store = t->to_prepare_to_store;
             }
           if (!record_beneath_to_xfer_partial)
             {
               record_beneath_to_xfer_partial = t->to_xfer_partial;
             }
           if (!record_beneath_to_insert_breakpoint)
             {
               record_beneath_to_insert_breakpoint = t->to_insert_breakpoint;
             }
           if (!record_beneath_to_remove_breakpoint)
             {
               record_beneath_to_remove_breakpoint = t->to_remove_breakpoint;
             }
        }
@


1.184.2.3
log
@2008-10-04  Michael Snyder  <msnyder@@vmware.com>

	* target.c, target.h: Rename execdir to exec_direction.
	* record.c, record.h: Ditto.
	* reverse.c: Ditto.
	* remote.c: Ditto.

	* reverse.c (show_exec_direction_func): Don't error, just inform.
@
text
@d468 2
a469 2
      INHERIT (to_get_exec_direction, t);
      INHERIT (to_set_exec_direction, t);
@


1.184.2.4
log
@2008-10-04  Hui Zhu  <teawater@@gmail.com>

	Change from "to_prepare_to_store" to "to_store_registers".
	* record.c (record_beneath_to_prepare_to_store): Removed.
	(record_beneath_to_store_registers): New function pointer.
	Instead "record_beneath_to_prepare_to_store". Will point
	to the low strata target "to_store_registers" function.
	(record_prepare_to_store): Removed.
	(record_store_registers): New function.
	Instead "record_prepare_to_store". Record the change of
	registers from GDB.
	(init_record_ops): Change record_prepare_to_store to
	record_store_registers.
	* record.h (record_beneath_to_prepare_to_store): Removed.
	(record_beneath_to_store_registers): New extern.
	(record_regcache_raw_write_regnum): Remove.
	* target.c (update_current_target): Change
	record_beneath_to_prepare_to_store to
	record_beneath_to_store_registers.
@
text
@d383 1
a383 1
  record_beneath_to_store_registers = NULL;
d488 1
a488 1
           if (!record_beneath_to_store_registers)
d490 1
a490 1
               record_beneath_to_store_registers = t->to_store_registers;
@


1.184.2.5
log
@2008-10-07  Michael Snyder  <msnyder@@vmware.com>

	* target.h (to_set_exec_direction, to_get_exec_direction): Remove.
	(to_can_execute_reverse): New method.
	(enum exec_direction_kind): Move to inferior.h.
	* target.c (update_current_target): Inherit to_can_execute_reverse.
	Remove to_set_exec_direction, to_get_exec_direction.
	* inferior.h (enum exec_direction_kind): Move from target.h.

	* infrun.c (set_exec_direction_func): Move here from reverse.c.
	(show_exec_direction_func): Ditto.
	(proceed): Consult global execution_direction instead of
	target method.
	(handle_inferior_event): Ditto.

	* reverse.c (set_exec_direction_func): Move to infrun.c
	(show_exec_direction_func): Ditto.
	(exec_direction_default): Set infrun global variable.
	(exec_reverse_once): Consult infrun global direction variable.

	* infcmd.c (step_1): Consult infrun global direction variable.
	(step_once): Ditto.
	(until_next_command): Ditto.
	(finish_command): Ditto.

	* record.h (record_exec_direction): Delete.
	(RECORD_IS_REPLAY): Consult infrun global direction variable.

	* record.c: (record_wait_cleanups): Use infrun state variable.
	(record_wait): Ditto.
	(record_get_exec_direction, record_set_exec_direction): Remove.
	(record_can_execute_reverse): New target method.

	* remote.c (remote_resume): Use infrun state variable.
	(remote_get_exec_direction, remote_set_exec_direction): Remove.
	(remote_can_execute_reverse): New target method.
@
text
@d468 2
a469 1
      INHERIT (to_can_execute_reverse, t);
@


1.184.2.6
log
@2008-10-18  Hui Zhu  <teawater@@gmail.com>

	Remove "to_support_record_wait".

	* target.c (add_target): Remove "to_support_record_wait".
	* target.h (target_ops): Ditto.
	* linux-nat.c (linux_nat_add_target): Ditto.
	* record.h (RECORD_TARGET_SUPPORT_RECORD_WAIT): This macro is removed.
@
text
@d245 3
@


1.183
log
@	* gnu-nat.c (gnu_attach): Add process to inferiors table.
	(gnu_detach): Remove it.
	* go32-nat.c (go32_create_inferior): Add process to gdb's inferior
	table.
	* inf-ptrace.c (inf_ptrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ptrace_attach): Add new process to inferior table.
	(inf_ptrace_detach): Remove it.
	* inf-ttrace.c (inf_ttrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ttrace_attach): Add process to inferior table.
	(inf_ttrace_detach): Remove it.
	* linux-fork.c (init_fork_list): Delete any left over inferior.
	(linux_fork_mourn_inferior, detach_fork_command): Also delete
	processes from inferior list.
	* monitor.c (monitor_open): Add process to inferior list.
	(monitor_close): Remove it.
	* nto-procfs.c (procfs_attach): Add process to inferior list.
	Find threads after pushing the target.
	(procfs_detach): Remove process from inferior list.
	(procfs_create_inferior): Add process to inferior list.
	* procfs.c (procfs_detach): Remove process from inferior list.
	(do_attach): Add process to inferior list.
	* remote-sim.c (sim_create_inferior): Add process to inferior list.
	(gdbsim_close): Remove it.
	* target.c (generic_mourn_inferior): If inferior_ptid is not
	null_ptid, remove the corresponding inferior from inferior list.
	* win32-nat.c (do_initial_win32_stuff): Add process to inferior list.
	(win32_detach): Remove it.
	* linux-nat.c (linux_child_follow_fork): Delete and add inferiors
	to inferior list accordingly.
	* fork-child.c (fork_inferior): Add process to inferior list.
	* corelow.c (CORELOW_PID): Define.
	(core_close): Remove core from inferior list.
	(core_open): Add it.
@
text
@a201 5
/* Nonzero if we are debugging an attached outside process
   rather than an inferior.  */

int attach_flag;

a2346 1
  attach_flag = 0;
@


1.182
log
@	* auxv.c (default_auxv_parse): Use gdbarch_ptr_bit (target_gdbarch)
	instead of builtin_type_void_data_ptr.
	* target.c (default_region_ok_for_hw_watchpoint): Likewise.
@
text
@d2341 1
d2343 1
d2345 7
@


1.181
log
@	* gdbarch.sh (gdbarch_dump): Use core_addr_to_string_nz
	instead of paddr_nz.
	* gdbarch.c: Regenerate.

	* target.c (target_xfer_partial, debug_print_register): Use
	core_addr_to_string_nz instead of paddr_nz.
@
text
@d2156 1
a2156 1
  return (len <= TYPE_LENGTH (builtin_type_void_data_ptr));
@


1.180
log
@	* target.c (update_current_target): Do not inherit to_open
	or to_close.
	(pop_target): Call target_close on target_stack instead
	of current_target.
	(pop_all_targets_above): Likewise.
@
text
@d1171 1
a1171 1
			  "%s:target_xfer_partial (%d, %s, 0x%lx,  0x%lx,  0x%s, %s) = %s",
d1176 2
a1177 1
			  paddr_nz (offset), plongest (len), plongest (retval));
d2569 2
a2570 2
	  fprintf_unfiltered (gdb_stdlog, " 0x%s %s",
			      paddr_nz (val), plongest (val));
@


1.179
log
@	* breakpoint.h (struct bp_location): Change type of section
	member to "struct obj_section *".
	* tracepoint.h (struct tracepoint): Likewise.
	* symtab.h (struct general_symbol_info): Replace bfd_section
	member with obj_section.
	(struct symtab_and_line): Change type of section member to
	"struct obj_section *".
	(SYMBOL_BFD_SECTION): Remove macro, replace by ...
	(SYMBOL_OBJ_SECTION): ... this.

	* minsym.c (prim_record_minimal_symbol_and_info): Record symbol
	section as obj_section instead of bfd_section.

	* ada-lang.c (ada_decode_symbol): Use gsymbol->obj_section
	directly instead of looking of obj_section from bfd_section.

	* objfiles.h (find_pc_sect_section): Remove.
	* objfiles.c (find_pc_sect_section): Remove.
	(find_pc_section): Inline find_pc_sect_section code.

	* symfile.h (find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(section_is_overlay, section_is_mapped): Change type of section
	argument to struct obj_section *.
	(pc_in_mapped_range, pc_in_unmapped_range): Likewise.
	(overlay_mapped_address, overlay_unmapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	* symtab.h (symbol_overlayed_address): Likewise.
	* symfile.c (overlay_is_mapped): Remove.
	(section_is_mapped): Inline overlay_is_mapped code.  Update.
	(overlay_invalidate_all): Update.
	(section_is_overlay): Change section argument to type
	"struct obj_section *".  Use bfd_ methods.
	(pc_in_unmapped_range): Likewise.  Handle relocated sections.
	(pc_in_mapped_range): Likewise.  Handle relocated sections.
	(sections_overlap): Likewise.
	(overlay_unmapped_address): Likewise.
	(overlay_mapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	(find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(list_overlays_command): Update.
	(map_overlay_command, unmap_overlay_command): Update.
	(simple_overlay_update): Update.

	* block.h (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* block.c (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* symtab.h (find_pc_sect_function, find_pc_sect_psymtab,
	find_pc_sect_symtab, find_pc_sect_psymbol, find_pc_sect_line,
	lookup_minimal_symbol_by_pc_section, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.
	* blockframe.c (find_pc_sect_function): Likewise.
	* breakpoint.c (describe_other_breakpoints): Likewise.
	(breakpoint_has_pc, check_duplicates_for): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_minimal_symbol_by_pc_section): Likewise.
	* symtab.c (find_pc_sect_psymtab_closer): Likewise.
	(find_pc_sect_psymtab, find_pc_sect_psymbol, find_pc_sect_symtab,
	find_pc_sect_line, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.

	* blockframe.c (find_pc_partial_function): Update to section
	type changes.  No longer call find_pc_sect_section.
	(cache_pc_function_section): Change to type "struct obj_section *".
	* breakpoint.c (resolve_sal_pc): Update to section type changes.
	* exec.c (xfer_memory): Likewise.
	* findvar.c (read_var_value): Likewise.
	* infcmd.c (jump_command): Likewise.
	* linespec.c (minsym_found): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_solib_trampoline_symbol_by_pc): Likewise.
	* parse.c (write_exp_msymbol): Likewise.
	* printcmd.c (build_address_symbolic): Likewise.
	(address_info, sym_info): Likewise.
	* symmisc.c (dump_msymbols, print_symbol): Likewise.
	* symtab.c (fixup_section): Likewise.
	(fixup_symbol_section, fixup_psymbol_section): Likewise.
	(find_pc_line, find_function_start_sal): Likewise.
	* target.c (memory_xfer_partial): Likewise.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline): Likewise.
	* spu-tdep.c (spu_overlay_update): Likewise.
@
text
@d388 2
a389 2
      INHERIT (to_open, t);
      INHERIT (to_close, t);
d787 1
a787 1
  target_close (&current_target, 0);	/* Let it clean up */
d802 1
a802 1
      target_close (&current_target, quitting);
d807 1
a807 1
			      current_target.to_shortname);
@


1.178
log
@	* defs.h (plongest,pulongest): Renamed from paddr_u,paddr_d.
	Change argument of pulongest from CORE_ADDR to ULONGEST.
	All callers updated.
	* utils.c (plongest): Renamed from paddr_d.
	(pulongest): Renamed from paddr_u, change arg type to ULONGEST.
	* remote-mips.c (send_srec): Use paddr_nz instead of paddr_u in
	`CORE_ADDR addr' arg of error message.
@
text
@d1029 1
a1029 1
      asection *section = find_pc_overlay (memaddr);
@


1.177
log
@	* gdbarch.sh (target_gdbarch): New global variable.
	(deprecated_current_gdbarch_select_hack): Set it.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (gdbarch_update_p): Use target_gdbarch instead
	of current_gdbarch.
	* target-descriptions.c (target_find_description): Likewise.
	* arm-tdep.c (arm_update_current_architecture): Likewise.
	(show_fp_model, arm_show_abi, arm_show_fallback_mode,
	arm_show_force_mode): Likewise.
	* mips-tdep.c (show_mask_address, show_mipsfpu_command,
	show_mips_abi): Likewise.
	* mep-tdep.c (me_module_register_set, current_me_module): Likewise.

	* target.c (target_translate_tls_address): Use target_gdbarch
	instead of current_gdbarch.
	* remote.c (struct packet_reg): Likewise.
	(get_remote_arch_state, packet_reg_from_regnum,
	packet_reg_from_pnum, remote_check_symbols, remote_wait,
	remote_address_masked, remote_insert_breakpoint,
	remote_insert_hw_breakpoint, remote_read_description): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* remote-mips.c (mips_open, mips_common_breakpoint): Likewise.
	* cris-tdep.c (cris_can_use_hardware_watchpoint): Likewise.

	* solib.c (solib_open, solib_map_sections, solib_read_symbols,
	solib_add, info_sharedlibrary_command, solib_address,
	solib_create_inferior_hook, in_solib_dynsym_resolve_code,
	solib_global_lookup): Likewise.
	* solib-frv.c (enable_break2, frv_relocate_main_executable): Likewise.
	* solib-irix.c (irix_current_sos, irix_open_symbol_file_object):
	Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (exec_entry_point, enable_break, svr4_free_so,
	set_solib_svr4_fetch_link_map_offsets, svr4_fetch_link_map_offsets):
	Likewise.
	* nto-tdep.c (nto_find_and_open_solib, nto_init_solib_absolute_prefix,
	nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_in_dynsym_stub): Likewise.
@
text
@d1176 1
a1176 1
			  paddr_nz (offset), paddr_d (len), paddr_d (retval));
d2569 1
a2569 1
			      paddr_nz (val), paddr_d (val));
@


1.176
log
@	* target.c (debug_print_register): Use regcache_raw_collect
	instead of regcache_cooked_read.  Only handle raw registers.
@
text
@d829 1
a829 1
      && gdbarch_fetch_tls_load_module_address_p (current_gdbarch))
d839 1
a839 1
	  lm_addr = gdbarch_fetch_tls_load_module_address (current_gdbarch,
@


1.175
log
@	Make sure target supports non-stop.
        * infcmd.c (run_command_1, attach_command): If non-stop mode
        is requested, verify the target supports it.
        * linux-nat.c (linux_nat_supports_non_stop): New.
        (linux_nat_add_target): Register the above.
        * target.c (find_default_supports_non_stop)
        (target_supports_non_stop): New.
        (init_dummy_target): Register find_default_supports_non_stop.
        * target.h (struct target_ops): New field to_supports_non_stop.
        (target_supports_non_stop): New.
@
text
@a2548 1
			    + gdbarch_num_pseudo_regs (gdbarch)
d2555 1
a2555 1
  if (regno >= 0)
d2559 1
a2559 1
      regcache_cooked_read (regcache, regno, buf);
@


1.174
log
@	* target.c (target_async_permitted, target_async_permitted_1)
        (set_maintenance_target_async_permitted)
        (show_maintenance_target_async_permitted): New.
        (initialize_targets): Register 'set target-async'.
        * target.h (target_async_permitted): Declare.
        * linux-nat.c (linux_nat_async_enabled)
        (linux_nat_async_permitted, set_maintenance_linux_async_permitted)
        (show_maintenance_linux_async_permitted): Remove.
        (sigchld_handler, linux_nat_is_async_p, linux_nat_can_async_p)
        (get_pending_events, linux_nat_async): Use target_async_permitted.
        (linux_nat_set_async_mode): Remove, moving the only used bits
        into...
        (linux_nat_setup_async): This.
        (_initialize_linux_nat): Do not register 'maint set linux-async'.
        Use linux_nat_setup_async.
        * remote.c (remote_async_permitted, remote_async_permitted_set)
        (set_maintenance_remote_async_permitted)
        (show_maintenance_remote_async_permitted): Remove.
        (remote_open_1, remote_terminal_inferior, remote_can_async_p)
        (remote_is_async_p): Use target_async_permitted.
        (_initialize_remote): Don't register 'main set remote-async'.
        * mi/mi-cmds.c (mi_cmds): Register -list-target-features.
        * mi/mi-cmds.h (mi_cmd_list_target_features): New.
        * mi/mi-main.c (mi_cmd_list_target_features): New.
@
text
@d2129 23
d2426 1
@


1.173
log
@	* target.c (maybe_kill_then_attach)
        (maybe_kill_then_create_inferior): Remove.
        (update_current_target): Do not default to_attach,
        to_create_inferiour, to_is_async_p.
@
text
@d3136 29
d3202 10
@


1.172
log
@	* corelow.c (core_open): Assume there was no upper layer left
	behind from a previous inferior.
	* target.c (pop_all_targets): Rename to ...
	(pop_all_targets_above): ... this.  Add a target stratum
	parameter.  Use it instead of hardcoding the dummy_stratum.
	(pop_all_targets): New, defer to pop_all_targets_above.
	(target_preopen): Use pop_all_targets_above.
	* target.h (pop_all_targets_above): Declare.
@
text
@a46 2
static void maybe_kill_then_attach (char *, int);

a358 15
static void
maybe_kill_then_attach (char *args, int from_tty)
{
  kill_or_be_killed (from_tty);
  target_attach (args, from_tty);
}

static void
maybe_kill_then_create_inferior (char *exec, char *args, char **env,
				 int from_tty)
{
  kill_or_be_killed (0);
  target_create_inferior (exec, args, env, from_tty);
}

a485 2
  de_fault (to_attach,
	    maybe_kill_then_attach);
a567 2
  de_fault (to_create_inferior,
	    maybe_kill_then_create_inferior);
a621 6
  de_fault (to_can_async_p,
	    (int (*) (void))
	    return_zero);
  de_fault (to_is_async_p,
	    (int (*) (void))
	    return_zero);
@


1.171
log
@	* target.h (pop_all_targets): Declare.
	* target.c (pop_all_targets): New.
	* top.c (quit_target): Pop all targets instead of just closing the
	current.
@
text
@d825 1
a825 1
pop_all_targets (int quitting)
d827 1
a827 1
  while ((int) (current_target.to_stratum) > (int) dummy_stratum)
d842 6
d1787 3
a1789 3

  if (target_has_execution)
    pop_target ();
@


1.170
log
@	* target.c: Include "solib.h".
	(target_pre_inferior): Call no_shared_libraries.
	* infcmd.c (run_command_1): Do not call objfile_purge_solibs
	or clear_solib.
	(attach_command): Do not call clear_solib.
@
text
@d824 18
@


1.169
log
@	Non-stop inferior control.

	* infrun.c (resume): In non-stop mode, always resume just one
	thread.
	(proceed): Don't call prepare_to_proceed in non-stop mode.
	(fetch_inferior_event): In non-stop mode, switch context before
	handling the event.
	(error_is_running, ensure_not_running): New.
	(handle_inferior_event): In non-stop mode: Mark only the event
	thread as stopped.  Require that the target module manages adding
	threads to the thread list.  Assert that there isn't a
	deferred_step_ptid set.  Don't switch to infwait_thread_hop_state.
	(normal_stop): Only mark not-running if inferior hasn't exited.
	In non-stop mode, only mark the event thread.

	* thread.c:Include "cli/cli-decode.h".
	(print_thread_info): Don't read from a running thread.
	Output "(running)" if thread is running.
	(switch_to_thread): Don't read stop_pc if thread is executing.
	(do_restore_current_thread_cleanup): Don't write to a running
	thread.
	(thread_apply_all_command): Don't read from a running thread.  In
	non-stop mode, do a full context-switch instead of just switching
	threads.
	(thread_apply_command): In non-stop mode, do a full context-switch
	instead of just switching threads.
	(do_captured_thread_select): Likewise.  Inform user if selected
	thread is running.
	(_initialize_thread): Mark "info threads" and "thread" and
	async_ok.

	* inf-loop.c (inferior_event_handler): In non-stop mode, don't
	unregister the target from the event loop.

	* infcmd.c (continue_command, step_1, jump_command)
	(signal_command): Ensure the selected thread isn't running.
	(interrupt_target_command): In non-stop mode, interrupt only the
	selected thread.

	* inferior.h (error_is_running, ensure_not_running): Declare.

	* target.h (struct target_ops): Add ptid argument to the to_stop
	member.
	(target_stop): Add ptid_t argument.

	* target.c (update_current_target): Add ptid argument to to_stop's
	type.
	(debug_to_stop): Add ptid_t argument.
	(debug_to_rcmd): Set to_stop_ptid.

	* remote.c (remote_stop): Add ptid_t argument.
	(async_remote_interrupt): Add inferior_ptid to target_stop.
	* inf-ptrace.c (inf_ptrace_stop): Add ptid argument.

	* Makefile.in (thread.o): Depend on $(cli_decode_h).
@
text
@d43 1
d1721 18
@


1.169.2.1
log
@2008-07-17  Michael Snyder  <msnyder@@specifix.com>
	2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* Target interface for reverse execution.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	* target.c (target_get_execdir): New generic method.
	(target_set_execdir): Ditto.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(remote_vcont_resume): Jump out if attempting reverse execution.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(_initialize_remote): Add new methods to remote target vector.

	* breakpoint.h (breakpoint_silence): Export.
	* breakpoint.c (breakpoint_silence): New function.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.

	2006-03-31  Michael Snyder  <msnyder@@redhat.com>
	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.

	2007-04-18  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c (finish_backwards): Correct check for whether to back
	up after finishing.

	* arm-tdep.c (arm_scan_epilogue): New.
	(arm_make_prologue_cache): Use it.
	(arm_epilogue_unwind_sniffer): New.
	(arm_gdbarch_init): Register it.
@
text
@a478 2
      INHERIT (to_get_execdir, t);
      INHERIT (to_set_execdir, t);
@


1.169.2.2
log
@Add a element "to_support_record_wait" to target_ops.
Optimize infrun.c.
@
text
@a249 3
  /* Set the default value of to_support_record_wait. */
  t->to_support_record_wait = 0;

@


1.169.2.3
log
@2008-08-10  Hui Zhu  <teawater@@gmail.com>

	Add the real beneath function pointers for record target.

	* Makefile.in: Add record.h to depend of target.c.
	* record.c (record_beneath_to_resume, record_beneath_to_wait,
	record_beneath_to_prepare_to_store, record_beneath_to_xfer_partial,
	record_beneath_to_insert_breakpoint,
	record_beneath_to_remove_breakpoint): New function pointers. The real
	beneath function pointers.
	(record_resume): Change "record_ops.beneath->to_resume" to
	"record_beneath_to_resume".
	(record_wait): Change "record_ops.beneath->to_wait" to
	"record_beneath_to_wait".
	(record_prepare_to_store): Change
	"record_ops.beneath->to_prepare_to_store" to
	"record_beneath_to_prepare_to_store".
	(record_xfer_partial): Change "record_ops.beneath->to_xfer_partial" to
	"record_beneath_to_xfer_partial".
	(record_insert_breakpoint): Change
	"record_ops.beneath->to_insert_breakpoint" to
	"record_beneath_to_insert_breakpoint".
	(record_remove_breakpoint): Change
	"record_ops.beneath->to_remove_breakpoint" to
	"record_beneath_to_remove_breakpoint".
	* record.h (record_beneath_to_resume, record_beneath_to_wait,
	record_beneath_to_prepare_to_store, record_beneath_to_xfer_partial,
	record_beneath_to_insert_breakpoint,
	record_beneath_to_remove_breakpoint): Extern.
	* target.c: Add include of "record.h".
	(update_current_target): Set the real beneath function pointers.
@
text
@a42 1
#include "record.h"
a401 6
  record_beneath_to_resume = NULL;
  record_beneath_to_prepare_to_store = NULL;
  record_beneath_to_xfer_partial = NULL;
  record_beneath_to_insert_breakpoint = NULL;
  record_beneath_to_remove_breakpoint = NULL;

a489 29

      /* Set the real beneath function pointers. */
      if (t != &record_ops)
        {
           if (!record_beneath_to_resume)
             {
               record_beneath_to_resume = t->to_resume;
             }
           if (!record_beneath_to_wait)
             {
               record_beneath_to_wait = t->to_wait;
             }
           if (!record_beneath_to_prepare_to_store)
             {
               record_beneath_to_prepare_to_store = t->to_prepare_to_store;
             }
           if (!record_beneath_to_xfer_partial)
             {
               record_beneath_to_xfer_partial = t->to_xfer_partial;
             }
           if (!record_beneath_to_insert_breakpoint)
             {
               record_beneath_to_insert_breakpoint = t->to_insert_breakpoint;
             }
           if (!record_beneath_to_remove_breakpoint)
             {
               record_beneath_to_remove_breakpoint = t->to_remove_breakpoint;
             }
        }
@


1.169.2.4
log
@2008-10-05  Michael Snyder  <msnyder@@vmware.com>

	* target.c, target.h: Rename execdir to exec_direction.
	* record.c, record.h: Ditto.
	* reverse.c: Ditto.
	* remote.c: Ditto.
@
text
@d489 2
a490 2
      INHERIT (to_get_exec_direction, t);
      INHERIT (to_set_exec_direction, t);
@


1.169.2.5
log
@2008-10-04  Hui Zhu  <teawater@@gmail.com>

	Change from "to_prepare_to_store" to "to_store_registers".
	* record.c (record_beneath_to_prepare_to_store): Removed.
	(record_beneath_to_store_registers): New function pointer.
	Instead "record_beneath_to_prepare_to_store". Will point
	to the low strata target "to_store_registers" function.
	(record_prepare_to_store): Removed.
	(record_store_registers): New function.
	Instead "record_prepare_to_store". Record the change of
	registers from GDB.
	(init_record_ops): Change record_prepare_to_store to
	record_store_registers.
	* record.h (record_beneath_to_prepare_to_store): Removed.
	(record_beneath_to_store_registers): New extern.
	(record_regcache_raw_write_regnum): Remove.
	* target.c (update_current_target): Change
	record_beneath_to_prepare_to_store to
	record_beneath_to_store_registers.

2008-10-06  Michael Snyder  <msnyder@@promb-2s-dhcp59.eng.vmware.com>

	* regcache.c (regcache_raw_write): Remove global variable.
	No need to include "record.h" now.
	* record.c (record_regcache_raw_write_regnum): Remove.
@
text
@d404 1
a404 1
  record_beneath_to_store_registers = NULL;
d509 1
a509 1
           if (!record_beneath_to_store_registers)
d511 1
a511 1
               record_beneath_to_store_registers = t->to_store_registers;
@


1.169.2.6
log
@2008-10-07  Michael Snyder  <msnyder@@vmware.com>

	* target.h (to_set_exec_direction, to_get_exec_direction): Remove.
	(to_can_execute_reverse): New method.
	(enum exec_direction_kind): Move to inferior.h.
	* target.c (update_current_target): Inherit to_can_execute_reverse.
	Remove to_set_exec_direction, to_get_exec_direction.
	* inferior.h (enum exec_direction_kind): Move from target.h.

	* infrun.c (set_exec_direction_func): Move here from reverse.c.
	(show_exec_direction_func): Ditto.
	(proceed): Consult global execution_direction instead of
	target method.
	(handle_inferior_event): Ditto.

	* reverse.c (set_exec_direction_func): Move to infrun.c
	(show_exec_direction_func): Ditto.
	(exec_direction_default): Set infrun global variable.
	(exec_reverse_once): Consult infrun global direction variable.

	* infcmd.c (step_1): Consult infrun global direction variable.
	(step_once): Ditto.
	(until_next_command): Ditto.
	(finish_command): Ditto.

	* record.h (record_exec_direction): Delete.
	(RECORD_IS_REPLAY): Consult infrun global direction variable.

	* record.c: (record_wait_cleanups): Use infrun state variable.
	(record_wait): Ditto.
	(record_get_exec_direction, record_set_exec_direction): Remove.
	(record_can_execute_reverse): New target method.

	* remote.c (remote_resume): Use infrun state variable.
	(remote_get_exec_direction, remote_set_exec_direction): Remove.
	(remote_can_execute_reverse): New target method.
@
text
@d489 2
a490 1
      INHERIT (to_can_execute_reverse, t);
@


1.168
log
@	Add "executing" property to threads.

	* inferior.h (target_executing): Delete.
	* gdbthread.h (struct thread_info): Add executing_ field.
	(set_executing, is_executing): New.
	* thread.c (main_thread_executing): New.
	(init_thread_list): Clear it and also main_thread_running.
	(is_running): Return false if target has no execution.
	(any_running, is_executing, set_executing): New.

	* top.c: Include "gdbthread.h".
	(target_executing): Delete.
	(execute_command): Replace target_executing check by any_running.
	* event-top.c: Include "gdbthread.h".
	(display_gdb_prompt, command_handler): Replace target_executing by
	is_running.
	* inf-loop.c: Include "gdbthread.h".  Don't mark as not executing
	here.  Replace target_executing by is_running.
	* infrun.c (handle_inferior_event): Mark all threads as
	not-executing.
	* linux-nat.c (linux_nat_resume): Don't mark thread as executing
	here.
	* stack.c (get_selected_block): Return null if inferior is
	executing.
	* target.c (target_resume): Mark resumed ptid as executing.
	* breakpoint.c (until_break_command): Replace target_executing
	check by is_executing.
	* remote.c (remote_async_resume): Don't mark inferior as executing
	here.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Replace target_executing
	by any_running.

	* mi/mi-main.c (mi_cmd_exec_interrupt, mi_cmd_execute)
	(mi_execute_async_cli_command): Replace target_executing by
	is_running.

	* frame.c (get_current_frame): Error out if the current thread is
	executing.
	(has_stack_frames): New.
	(get_selected_frame, deprecated_safe_get_selected_frame): Check
	has_stack_frames.

	* Makefile.in (event-top.o, frame.o, inf-loop.o, top.o): Depend on
	$(gdbthread_h).
@
text
@d168 1
a168 1
static void debug_to_stop (void);
d633 1
a633 1
	    (void (*) (void))
d3000 1
a3000 1
debug_to_stop (void)
d3002 1
a3002 1
  debug_target.to_stop ();
d3004 2
a3005 1
  fprintf_unfiltered (gdb_stdlog, "target_stop ()\n");
@


1.167
log
@	* config/i386/nm-cygwin.h (ATTACH_NO_WAIT): Delete.
	* config/i386/nm-i386gnu.h (ATTACH_NO_WAIT): Delete.

	* target.h (struct target_ops): Add to_attach_no_wait member.
	(target_attach_no_wait): New.
	* target.c (update_current_target): Inherit to_attach_no_wait.

	* infcmd.c: Replace ATTACH_NO_WAIT compile time check by
	target_attach_no_wait runtime check.

	* gnu-nat.c (init_gnu_ops): Set to_attach_no_wait in gnu_ops.
	* win32-nat.c (init_win32_ops): Set to_attach_no_wait in
	win32_ops.
@
text
@d1790 1
a1791 1

@


1.166
log
@	* Makefile.in (GNULIB_H): Use GNULIB_STDINT_H.
	(gdb_stdint_h, gdb_stdint.h, stamp-int): Delete.  Remove
	all dependencies on $(gdb_stdint_h).
	(distclean): Do not delete gdb_stdint.h.
	* acinclude.m4: Do not use stdint.m4.
	* configure.ac: Set GNULIB_STDINT_H.  Remove tests for stdint.h,
	uintptr_t, and gdb_stdint.h.
	* defs.h: Include <stdint.h>.
	* gdb_thread_db.h: Assume stdint.h is already included.
	* breakpoint.c, findcmd.c, hppa-tdep.c, inf-ptrace.c, proc-service.c,
	rs6000-nat.c, spu-linux-nat.c, target.c, win32-nat.c: Do not
	include gdb_stdint.h.
	* configure, config.in: Regenerate.
@
text
@d408 1
@


1.165
log
@	* target.c (target_read_until_error): New.
        * target.h (target_read_until_error): Declare.
        * mi/mi-main.c (mi_cmd_data_read_memory): Use
        target_read_until_error.
@
text
@a41 1
#include "gdb_stdint.h"
@


1.164
log
@	Implement *running.
        * Makefile.in: Update dependencies.
        * gdbthread.h (struct thread_info): New field
        running_.
        (set_running, is_running): New.
        * thread.c (set_running, is_running): New.
        * inferior.h (suppress_normal_stop_observer): Rename to...
        (suppress_run_stop_observers): ..this.
        * infcmd.c (suppress_normal_stop_observer): Rename to...
        (suppress_run_stop_observers): ..this.
        (finish_command_continuation, finish_command): Adjust.
        * infcall.c (call_function_by_hand): Adjust.
        * infrun.c (normal_stop): Call set_running.
        * target.c (target_resume): New.  Call set_running.
        * target.h (target_resume): Convert from macro to
        a function.

        * mi/mi-interp.c (mi_on_resume): New.
        (mi_interpreter_init): Register mi_on_resume.
@
text
@d1454 66
@


1.163
log
@	* error.c (parse_find_args): Fix capitalization in previous patch.
	(find_command): Ditto.
	* target.c (simple_search_memory): Ditto.
	* gdbserver/server.c (handle_search_memory_1): Ditto.
	(handle_search_memory): Ditto.
@
text
@d43 1
d1719 8
@


1.163.2.1
log
@Reverse execution branch

2008-06-09  Michael Snyder  <msnyder@@specifix.com>
	2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* Target interface for reverse execution.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	* target.c (target_get_execdir): New generic method.
	(target_set_execdir): Ditto.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(remote_vcont_resume): Jump out if attempting reverse execution.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(_initialize_remote): Add new methods to remote target vector.

	* breakpoint.h (breakpoint_silence): Export.
	* breakpoint.c (breakpoint_silence): New function.
	* infcmd.c (finish_command): Check for reverse exec direction.
	(finish_backward): New function, handle finish cmd in reverse.
	* infrun.c (enum inferior_stop_reason): Add NO_HISTORY reason.
	(handle_inferior_event): Handle TARGET_WAITKIND_NO_HISTORY.
	Handle stepping over a function call in reverse.
	Handle stepping thru a line range in reverse.
	Handle setting a step-resume breakpoint in reverse.
	Handle stepping into a function in reverse.
	Handle stepping between line ranges in reverse.
	(print_stop_reason): Print reason for NO_HISTORY.

	2006-03-31  Michael Snyder  <msnyder@@redhat.com>
	User interface for reverse execution.
	* Makefile.in (reverse.c): New file.
	* reverse.c: New file.  User interface for reverse execution.
@
text
@a477 2
      INHERIT (to_get_execdir, t);
      INHERIT (to_set_execdir, t);
@


1.162
log
@	New "find" command.
	* NEWS: Document find command and qSearch:memory packet.
	* Makefile.in (SFILES): Add findcmd.c.
	(COMMON_OBJS): Add findcmd.o.
	(findcmd.o): New rule.
	* findcmd.c: New file.
	* target.h (target_ops): New member to_search_memory.
	(simple_search_memory): Declare.
	(target_search_memory): Declare.
	* target.c (simple_search_memory): New fn.
	(target_search_memory): New fn.
	* remote.c (PACKET_qSearch_memory): New packet kind.
	(remote_search_memory): New fn.
	(init_remote_ops): Init to_search_memory.
	(init_extended_remote_ops): Ditto.
	(_initialize_remote): Add qSearch:memory packet config command.

	* gdbserver/server.h (decode_search_memory_packet): Declare.
	* gdbserver/remote-utils.c (decode_search_memory_packet): New fn.
	* gdbserver/server.c (handle_search_memory_1): New fn.
	(handle_search_memory): New fn.
	(handle_query): Process qSearch:memory packets.

	* doc/gdb.texinfo: Document "find" command, qSearch:memory packet.

	* testsuite/gdb.base/find.exp: New file.
	* testsuite/gdb.base/find.c: New file.
@
text
@d1791 1
a1791 1
    error (_("unable to allocate memory to perform the search"));
d1799 1
a1799 1
      warning (_("unable to access target memory at %s, halting search"),
d1852 1
a1852 1
	      warning (_("unable to access target memory at %s, halting search"),
@


1.161
log
@* target.h (struct target_ops): Add
to_watchpoint_addr_within_range.
(target_watchpoint_addr_within_range): New function.
* target.c (update_current_target): Inherit
to_watchpoint_addr_within_range, defaulting to
default_watchpoint_addr_within_range.
(default_watchpoint_addr_within_range): New function.
(debug_to_watchpoint_addr_within_range): New function.
(setup_target_debug): Set to_watchpoint_addr_within_range.
* ppc-linux-nat.c (ppc_linux_watchpoint_addr_within_range):
New function.
(_initialize_ppc_linux_nat): Set to_watchpoint_addr_within_range.
* breakpoint.c (watchpoints_triggered): Use
target_watchpoint_addr_within_range.

* gdbint.texinfo (Algorithms): Describe
target_watchpoint_addr_within_range.
@
text
@d479 1
d1764 151
@


1.160
log
@	* breakpoint.h (bp_location_p): New typedef.
	Register a vector of bp_location_p.
	* breakpoint.c (always_inserted_mode)
	(show_always_inserted_mode): New.
	(unlink_locations_from_global_list): Remove.
	(update_global_location_list)
	(update_global_location_list_nothrow): New.
	(update_watchpoint): Don't free locations.
	(should_insert_location): New.
	(insert_bp_location): Use should_insert_location.
	(insert_breakpoint_locations): Copied from
	insert_breakpoints.
	(insert_breakpoint): Use insert_breakpoint_locations.
	(bpstat_stop_status): Call update_global_location_list
	when disabling breakpoint.
	(allocate_bp_location): Don't add to bp_location_chain.
	(set_raw_breakpoint)
	(create_longjmp_breakpoint, enable_longjmp_breakpoint)
	(disable_longjmp_breakpoint, create_overlay_event_breakpoint)
	(enable_overlay_breakpoints, disable_overlay_breakpoints)
	(set_longjmp_resume_breakpoint)
	(enable_watchpoints_after_interactive_call_stop)
	(disable_watchpoints_before_interactive_call_start)
	(create_internal_breakpoint)
	(create_fork_vfork_event_catchpoint)
	(create_exec_event_catchpoint, set_momentary_breakpoint)
	(create_breakpoints, break_command_1, watch_command_1)
	(create_exception_catchpoint)
	(handle_gnu_v3_exceptions)
	(disable_breakpoint, breakpoint_re_set_one)
	(create_thread_event_breakpoint, create_solib_event_breakpoint)
	(create_ada_exception_breakpoint): : Don't call check_duplicates.
	Call update_global_location_list.
	(delete_breakpoint): Don't remove locations and don't
	try to reinsert them. Call update_global_location_list.
	(update_breakpoint_locations): Likewise.
	(restore_always_inserted_mode): New.
	(update_breakpoints_after_exec): Temporary disable
	always inserted mode.
	* Makefile.in: Update dependencies.

	* infrun.c (proceed): Remove breakpoints while stepping
	over breakpoint.
	(handle_inferior_event): Don't remove or insert
	breakpoints.
	* linux-fork.c (checkpoint_command): Remove breakpoints
	before fork and insert after.
	(linux_fork_context): Remove breakpoints before switch
	and insert after.
	* target.c (target_disconnect, target_detach): Remove
	breakpoints from target.
@
text
@d52 3
d137 3
a424 1
      INHERIT (to_stopped_by_watchpoint, t);
d427 2
d554 2
d1893 8
d2468 17
d2827 1
@


1.159
log
@	* target.c (find_default_run_target): Allow a NULL `do_mesg'
	parameter.  If it is NULL, don't call error.
	(find_default_can_async_p, find_default_is_async_p): Pass NULL as
	`do_mesg' parameter to find_default_run_target.  If no target was
	found, return 0.
@
text
@d1679 4
d1691 4
@


1.158
log
@gdb/
	* target.h (struct target_ops): Delete to_async_mask_value and add
	to_async_mask.
	(target_is_async_p, target_async): Formatting.
	(target_async_mask_value): Delete.
	(target_async_mask): Delete function declaration, and add new
	target macro with the same name.

	* target.c (update_current_target): Replace to_async_mask_value by
	to_async_mask.  Default to_async_mask to return_one.
	(target_async_mask): Delete.
	(find_default_can_async_p, find_default_is_async_p): New.
	(init_dummy_target): register find_default_can_async_p and
	find_default_is_async_p on the dummy target.

	* linux-nat.c: Include inf-loop.h, event-loop.h and event-top.h.
	(debug_linux_nat_async): New global.
	(show_debug_linux_nat_async): New function.
	(linux_nat_async_enabled, linux_nat_async_mask_value)
	(linux_nat_event_pipe, linux_nat_num_queued_events)
	(linux_nat_async_events_enabled): New globals.
	(struct waitpid_result): New struct.
	(waitpid_queue): New global.
	(queued_waitpid, push_waitpid, drain_queued_events): New.
	(my_waitpid): Call queued_waitpid.
	(linux_child_follow_fork): Disable async events during the call.
	(blocked_mask): Delete.
	(sync_sigchld_action, async_sigchld_action): New globals.
	(lin_lwp_attach_lwp): In sync mode, don't reblock SIGCHLD.  In
	async mode, block events during the call.
	(linux_nat_create_inferior): New.
	(linux_nat_attach): In sync mode, restore the mask states.  In
	async mode, wake the event loop immediatelly.
	(detach_callback): Drain all queued events of the lwp we're
	detaching from.
	(linux_nat_detach): Block async mode, and drain events of the main
	process.
	(linux_nat_resume): If in async mode, mask async events during the
	call.  If short circuiting, force event loop to wake up.  If
	resuming, set target_executing, and register target events in the
	event loop.
	(pipe_to_local_event_queue, local_event_queue_to_pipe): New.
	(linux_nat_wait): In async mode, block events during the call.
	Only enable/disable passing SIGINT to the inferior in sync mode.
	Get events from local waitpid queue.  If no interesting events was
	found, return to events loop.  Reregister target events in the
	event loop on exit.  In sync mode, no need to reblock SIGCHLD.
	(linux_nat_kill): Disable events on entry.
	(linux_nat_mourn_inferior): In sync mode, don't restore the masks
	here.  Detach async mode from the event loop if there are no more
	forks available, otherwise leave it on.
	(sigchld_handler): Assure this is called only in sync mode.
	(linux_async_permitted, linux_async_permitted_1): New globals.
	(set_maintenance_linux_async_permitted)
	(show_maintenance_linux_async_permitted): New functions.
	(linux_nat_is_async_p, linux_nat_can_async_p)
	(linux_nat_async_mask): New.
	(linux_nat_event_pipe_pop, linux_nat_event_pipe_push): New.
	(get_pending_events, async_sigchld_handler): New.
	(linux_nat_async_events): New.
	(async_terminal_is_ours): New global.
	(linux_nat_terminal_inferior, linux_nat_terminal_ours): New.
	(async_client_callback, async_client_context): New.
	(linux_nat_async_file_handler, linux_nat_async)
	(linux_nat_disable_async, linux_nat_enable_async): New.
	(linux_nat_add_target): Register linux_nat_create_inferior,
	linux_nat_can_async_p, linux_nat_is_async_p, linux_nat_async,
	linux_nat_async_mask, linux_nat_terminal_inferior and
	linux_nat_terminal_ours.
	(_initialize_linux_nat): Remove local action variable, and update
	code that used it to use sync_sigchld_action.  Add new
	"lin-lwp-async" debug set/show command.  Put the "lin-lwp" debug
	set/show command in the maintenance class.  Add new "linux-async"
	maintenance set/show command.  Block SIGCHLD by default.  Setup
	async_sichld_action, and sync_sigchld_action.  Install the default
	async mode.
	(lin_thread_get_thread_signals): Use a local sigset_t for blocking
	the cancel signals.

	* linux-thread-db.c (re_check_for_thread_db): New.
	(clear_lwpid_callback): Handle TARGET_WAITKIND_IGNORE.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): New.
	(init_thread_db_ops): Register thread_db_can_async_p,
	thread_db_is_async_p, thread_db_async and thread_db_async_mask.

	* remote.c (remote_async_mask_value): New.
	(remote_return_zero): New.
	(init_remote_ops): Register remote_return_zero as callbacks of
	to_can_async_p and to_is_async_p.
	(remote_can_async_p, remote_is_async_p, remote_async): Update to
	use remote_async_mask_value.
	(remote_async_mask): New.
	(init_remote_async_ops): Remove to_async_mask_value setting and
	register remote_async_mask as to_async_mask callback in
	remote_async_ops.

	* Makefile.in (linux-nat.o): Update.

gdb/doc/
	* gdb.texinfo (Debugging Output): Document
	"set/show debug lin-lwp-async".
	(Maintenance Commands): Document "maint set/show linux-async".
@
text
@d1785 2
a1786 1
   Result is always valid (error() is called for errors).  */
d1808 6
a1813 1
    error (_("Don't know how to %s.  Try \"help target\"."), do_mesg);
d1844 6
a1849 2
  t = find_default_run_target ("async");
  if (t->to_can_async_p)
d1859 6
a1864 2
  t = find_default_run_target ("async");
  if (t->to_is_async_p)
@


1.157
log
@	Remove ignoring leading exec events code.
        * fork-child.c (startup_inferior): Do not set
        inferior_ignoring_leading_exec_events.
        * inf-child.c (inf_child_reported_exec_events_per_exec_call): Remove.
        (inf_child_target): Do not set to_reported_exec_events_per_exec_call.
        * infrun.c (inferior_ignoring_leading_exec_events): Remove.
        (handle_inferior_event): Remove code for ignoring leading exec
        events.
        * target.c (update_current_target): Do not inherit, or default,
        to_reported_exec_events_per_exec_call.
        (debug_to_reported_exec_events_per_exec_call): Remove.
        (setup_target_debug): Do not set to_reported_exec_events_per_exec_call.
        * target.h (target_reported_exec_events_per_exec_call): Remove.
        (struct target): Remove the to_reported_exec_events_per_exec_call
        field.
@
text
@d467 1
a467 1
      INHERIT (to_async_mask_value, t);
d640 3
a1699 8
int
target_async_mask (int mask)
{
  int saved_async_masked_status = target_async_mask_value;
  target_async_mask_value = mask;
  return saved_async_masked_status;
}

d1833 22
d2119 2
@


1.156
log
@	* breakpoint.h (breakpoint_restore_shadows): New
	declaration.
	* breakpoint.c (breakpoint_restore_shadows): New.
	(read_memory_nobpt): Delete.
	* gdbcore.h (read_memory_nobpt): Delete declaration.
	* target.c (memory_xfer_partial): Call
	breakpoint_restore_shadows.
	(restore_show_memory_breakpoints)
	(make_show_memory_beakpoints_cleanup): New.
	(show_memory_breakpoints): New.
	* target.h (make_show_memory_beakpoints_cleanup): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint):
	Make sure we see memory breakpoints when checking if
	breakpoint is still there.
	* alpha-tdep.c, alphanbsd-tdep.c, frame.c, frv-tdep.c,
	hppa-linux-tdep.c, hppa-tdep.c, i386-linux-nat.c, i386-tdep.c,
	m68klinux-tdep.c, mips-tdep.c, mn10300-tdep.c, s390-tdep.c,
	sparc-tdep.c: Use target_read_memory instead of read_memory_nobpt.
@
text
@a441 1
      INHERIT (to_reported_exec_events_per_exec_call, t);
a600 3
  de_fault (to_reported_exec_events_per_exec_call,
	    (int (*) (void))
	    return_one);
a2634 14
debug_to_reported_exec_events_per_exec_call (void)
{
  int reported_exec_events;

  reported_exec_events = debug_target.to_reported_exec_events_per_exec_call ();

  fprintf_unfiltered (gdb_stdlog,
		      "target_reported_exec_events_per_exec_call () = %d\n",
		      reported_exec_events);

  return reported_exec_events;
}

static int
a2770 1
  current_target.to_reported_exec_events_per_exec_call = debug_to_reported_exec_events_per_exec_call;
@


1.155
log
@	* infcmd.c (kill_if_already_running): Make static.  Use
	target_require_runnable.
	* target.c (target_require_runnable): New.
	* target.h (target_require_runnable): Declare.

	* gdb.texinfo (Starting): Mention always-running targets.
	(Target Commands): Add an anchor for load.
	(Connecting): Explain continue instead of run.
@
text
@d42 1
d207 5
d1073 5
a1077 1
	return res;
d1095 1
a1095 1
	return res;
d1100 1
a1100 1
	return res;
d1106 3
d1114 16
@


1.154
log
@2008-01-24  Michael Snyder  <msnyder@@specifix.com>

	* procfs.c (procfs_xfer_partial): Comment, cut/paste error.
	* win32-nat.c (win32_xfer_partial): Ditto.
	* target.c (default_xfer_partial): Minor whitespace adjustment.
@
text
@d1726 35
@


1.154.6.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@a41 4
// begin ARC
#include "observer.h"
#include "cli/cli-decode.h"
// end ARC
a230 15
// begin ARC
static void
pre_open_notify (char *name, int from_tty)
{
    observer_notify_target_pre_connect(&current_target);
}

static void
post_open_notify (char *name, int from_tty)
{
    observer_notify_target_post_connect(&current_target);
}
// end ARC


a233 4
// begin ARC
  struct cmd_list_element *cmd;
// end ARC

a260 4

// begin ARC
  cmd = 
// end ARC
a261 5

// begin ARC
  (void) add_cmd ("", no_class, pre_open_notify,  "", &cmd->hook_pre);
  (void) add_cmd ("", no_class, post_open_notify, "", &cmd->hook_post);
// end ARC
a391 1
      INHERIT (to_data, t);     // ARC 16/02/2009   gdb bug: 9886
a647 4

// begin ARC
  observer_notify_target_updated(&current_target);
// end ARC
d688 1
a688 1
		    "Attempted to mark unpushed target \"%s\" as non-running",   // ARC 17/11/08 correct message   gdb bug: 9887
a1651 3
// begin ARC
  observer_notify_target_post_disconnect(&current_target);
// end ARC
a1762 3
// begin ARC
  observer_notify_target_pre_connect(t);
// end ARC
a1763 3
// begin ARC
  observer_notify_target_post_connect(t);
// end ARC
a2062 3
// begin ARC
  observer_notify_target_post_disconnect(&debug_target);
// end ARC
a2071 3
// begin ARC
  observer_notify_target_post_disconnect(targ);
// end ARC
a2094 3
// begin ARC
  observer_notify_target_post_disconnect(&debug_target);
// end ARC
@


1.153
log
@	* defs.h (struct continuation_arg): Fix typo in comment.
	* target.c (target_translate_tls_address): Fix comment spelling error.
@
text
@d1333 2
a1334 2
	xfered = ops->deprecated_xfer_memory (offset, readbuf, len, 0/*read*/,
					      NULL, ops);
@


1.152
log
@	Updated copyright notices for most files.
@
text
@d807 1
a807 1
/* Using the objfile specified in BATON, find the address for the
@


1.151
log
@Remove unused support for target-based exception catching.
* target.h (struct target_ops): Delete
to_enable_exception_callback and to_get_current_exception_event
members.
(target_enable_exception_callback)
(target_get_current_exception_event): Delete macros.
* target.c (update_current_target): Remove code to inherit and
default those members.
(debug_to_enable_exception_callback)
(debug_to_get_current_exception_event): Delete functions.
(setup_target_debug): Don't install those methods.
* inf-child.c (inf_child_enable_exception_callback)
(inf_child_get_current_exception_event): Delete dummy functions.
(inf_child_target): Don't install them in the target vector.
* breakpoint.h (enum bptype): Delete bp_catch_catch,
bp_catch_throw.
* breakpoint.c (cover_target_enable_exception_callback)
(ep_is_exception_catchpoint, create_exception_catchpoint): Delete
functions.
(insert_bp_location, update_breakpoints_after_exec)
(remove_breakpoint, ep_is_catchpoint, print_it_typical)
(bpstat_stop_status, bpstat_what)
(bpstat_get_triggered_catchpoints, print_one_breakpoint_location)
(user_settable_breakpoint, allocate_bp_location)
(disable_watchpoints_before_interactive_call_start)
(enable_watchpoints_after_interactive_call_stop, mention)
(delete_breakpoint, breakpoint_re_set_one, disable_command)
(enable_command): Remove exception catchpoint cases.
(catch_exception_command_1): Don't try target-based exception
handling.
* stack.c (catch_info): Call print_frame_label_vars
unconditionally.
@
text
@d4 1
a4 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.150
log
@* target.c (update_current_target): Inherit to_log_command.
* target.h (struct target_ops). Add to_log_command.
(target_log_command): New macro.
* top.c (execute_command): Call target_log_command() rather than
serial_log_command().
* monitor.c (init_base_monitor_ops): Initialize to_log_command.
* remote-m32r-sdi.c (init_m32r_ops): Likewise.
* remote-mips.c (_initialize_remote_mips): Likewise.
* remote.c (init_remote_ops): Likewise.
@
text
@a447 2
      INHERIT (to_enable_exception_callback, t);
      INHERIT (to_get_current_exception_event, t);
a625 6
  de_fault (to_enable_exception_callback,
	    (struct symtab_and_line * (*) (enum exception_event_kind, int))
	    nosupport_runtime);
  de_fault (to_get_current_exception_event,
	    (struct exception_event_record * (*) (void))
	    nosupport_runtime);
a2666 20
static struct symtab_and_line *
debug_to_enable_exception_callback (enum exception_event_kind kind, int enable)
{
  struct symtab_and_line *result;
  result = debug_target.to_enable_exception_callback (kind, enable);
  fprintf_unfiltered (gdb_stdlog,
		      "target get_exception_callback_sal (%d, %d)\n",
		      kind, enable);
  return result;
}

static struct exception_event_record *
debug_to_get_current_exception_event (void)
{
  struct exception_event_record *result;
  result = debug_target.to_get_current_exception_event ();
  fprintf_unfiltered (gdb_stdlog, "target get_current_exception_event ()\n");
  return result;
}

a2733 2
  current_target.to_enable_exception_callback = debug_to_enable_exception_callback;
  current_target.to_get_current_exception_event = debug_to_get_current_exception_event;
@


1.149
log
@2007-10-22  Markus Deuling  <deuling@@de.ibm.com>

	* target.c (debug_print_register): Use get_regcache_arch to get at the
	current architecture by regcache.
@
text
@d451 1
@


1.148
log
@	* target.c (update_current_target): Call setup_target_debug.
	(push_target): Do not call it here.
@
text
@d2168 1
d2170 6
a2175 6
  if (regno >= 0 && regno < gdbarch_num_regs (current_gdbarch)
			    + gdbarch_num_pseudo_regs (current_gdbarch)
      && gdbarch_register_name (current_gdbarch, regno) != NULL
      && gdbarch_register_name (current_gdbarch, regno)[0] != '\0')
    fprintf_unfiltered (gdb_stdlog, "(%s)", gdbarch_register_name
					      (current_gdbarch, regno));
d2180 1
a2180 1
      int i, size = register_size (current_gdbarch, regno);
@


1.147
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d652 3
a757 3
  if (targetdebug)
    setup_target_debug ();

@


1.146
log
@2007-08-08  Michael Snyder  <msnyder@@access-company.com>

	* target.c (target_read_string): Guard against null.
@
text
@d13 1
a13 1
   the Free Software Foundation; either version 2 of the License, or
d22 1
a22 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.145
log
@	* target.c (memory_xfer_partial): Accesses to unmapped overlay
	sections should always go to the executable file.
@
text
@d922 2
d973 1
a975 2
  if (string != NULL)
    *string = buffer;
@


1.144
log
@	PR symtab/2161
	* target.c (memory_xfer_partial): Do not continue past targets with
	all memory.
@
text
@d1020 8
@


1.143
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1087 5
@


1.142
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d2159 4
a2162 2
      && REGISTER_NAME (regno) != NULL && REGISTER_NAME (regno)[0] != '\0')
    fprintf_unfiltered (gdb_stdlog, "(%s)", REGISTER_NAME (regno));
@


1.141
log
@	* target.h (struct target_ops): Add REGCACHE parameter to
	to_prepare_to_store.
	(target_prepare_to_store): Likewise.
	* target.c (debug_to_prepare_to_store): Add REGCACHE parameter.
	(update_current_target): Adapt prepare_to_store de_fault rule.

	* regcache.c (regcache_raw_write): Pass regcache to
	target_prepare_to_store.

	* inftarg.c (child_prepare_to_store): Add REGCACHE parameter.
	Do not call CHILD_PREPARE_TO_STORE.
	* gnu-nat.c (gnu_prepare_to_store): Likewise.
	* procfs.c (procfs_prepare_to_store): Likewise.

	* inf-child.c (inf_child_prepare_to_store): Add REGCACHE parameter.
	* go32-nat.c (go32_prepare_to_store): Likewise.
	* monitor.c (monitor_prepare_to_store): Likewise.
	* nto-procfs.c (procfs_prepare_to_store): Likewise.
	* remote-m32r-sdi.c (m32r_prepare_to_store): Likewise.
	* remote-mips.c (mips_prepare_to_store): Likewise.
	* remote-sim.c (gdbsim_prepare_to_store): Likewise.
	* win32-nat.c (win32_prepare_to_store): Likewise.

	* remote.c (remote_prepare_to_store): Add REGCACHE parameter.
	Use it instead of current_regcache.

	* hpux-thread.c (hpux_thread_prepare_to_store): Add REGCACHE
	parameter.  Pass it on to next target.
	* sol-thread.c (sol_thread_prepare_to_store): Likewise.
@
text
@d2157 2
a2158 1
  if (regno >= 0 && regno < NUM_REGS + NUM_PSEUDO_REGS
@


1.140
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d113 1
a113 1
static void debug_to_prepare_to_store (void);
d512 1
a512 1
	    (void (*) (void))
d2198 1
a2198 1
debug_to_prepare_to_store (void)
d2200 1
a2200 1
  debug_target.to_prepare_to_store ();
@


1.139
log
@	* regcache.c (deprecated_read_register_gen): Remove, inline ...
	(read_register): ... here.
	(deprecated_write_register_gen): Remove, inline ...
	(write_register): ... here.
	* regcache.h (deprecated_read_register_gen): Remove prototype.
	(deprecated_write_register_gen): Likewise.

	* remote-sim.c (gdbsim_store_register): Replace call to
	deprecated_read_register_gen with regcache_cooked_read.
	* target.c (debug_print_register): Replace calls to
	deprecated_read_register_gen and read_register with
	regcache_cooked_read.
@
text
@d109 1
a109 1
static void debug_to_fetch_registers (int);
d111 1
a111 1
static void debug_to_store_registers (int);
d506 1
a506 1
	    (void (*) (int))
d509 1
a509 1
	    (void (*) (int))
d2153 2
a2154 1
debug_print_register (const char * func, int regno)
d2166 1
a2166 1
      regcache_cooked_read (current_regcache, regno, buf);
d2183 1
a2183 1
debug_to_fetch_registers (int regno)
d2185 2
a2186 2
  debug_target.to_fetch_registers (regno);
  debug_print_register ("target_fetch_registers", regno);
d2190 1
a2190 1
debug_to_store_registers (int regno)
d2192 2
a2193 2
  debug_target.to_store_registers (regno);
  debug_print_register ("target_store_registers", regno);
@


1.138
log
@	* config/rs6000/nm-rs6000.h (CHILD_SPECIAL_WAITSTATUS): Remove.
	* rs6000-nat.c (rs6000_wait): New function.
	(_initialize_core_rs6000): Install it as to_wait target method.
	* target.c (store_waitstatus): Don't check CHILD_SPECIAL_WAITSTATUS.
@
text
@d2163 1
a2163 1
      int i;
d2165 1
a2165 1
      deprecated_read_register_gen (regno, buf);
d2167 1
a2167 1
      for (i = 0; i < register_size (current_gdbarch, regno); i++)
d2171 1
a2171 1
      if (register_size (current_gdbarch, regno) <= sizeof (LONGEST))
d2173 1
d2175 1
a2175 2
			      paddr_nz (read_register (regno)),
			      paddr_d (read_register (regno)));
@


1.137
log
@	* Makefile.in (SFILES): Remove nlmread.c.
	(COMMON_OBS): Remove nlmread.o.
	(nlmread.o): Delete rule.
	* README: Delete reference to remote-st.c.
	* acinclude.m4 (CY_AC_TCL_LYNX_POSIX): Delete.
	* defs.h (enum gdb_osabi): Delete GDB_OSABI_NETWARE and
	GDB_OSABI_LYNXOS.
	* i386-tdep.c (i386_nw_init_abi, i386_nlm_osabi_sniffer): Delete.
	(_initialize_i386_tdep): Do not reference them.
	* nlmread.c: Delete file.
	* osabi.c (gdb_osabi_names): Remove NetWare and LynxOS.
	* target.c: Doc update.
	* thread.c: Delete commented include.
	* config/alpha/tm-alpha.h: Doc update.

	* gdb.texinfo (Startup): Delete references to some alternate
	names for .gdbinit.
	(Thread): Remove LynxOS reference.
	(Tandem ST2000): Delete target-specific documentation.
	* gdbint.texinfo (Symbol Handling): Remove mention of NLM.
	(Target Architecture Definition): Remove mention of GDB_OSABI_NETWARE
	and GDB_OSABI_LYNXOS.

	* config/netware.exp: Delete file.
@
text
@a1978 7
#ifdef CHILD_SPECIAL_WAITSTATUS
  /* CHILD_SPECIAL_WAITSTATUS should return nonzero and set *OURSTATUS
     if it wants to deal with hoststatus.  */
  if (CHILD_SPECIAL_WAITSTATUS (ourstatus, hoststatus))
    return;
#endif

@


1.137.2.1
log
@Daniel Jacobowitz' update to Michael Snyder's reverse debugging patches
@
text
@a468 3
      INHERIT (to_get_execdir, t);
      INHERIT (to_set_execdir, t);
      INHERIT (to_doing_call, t);
a646 3
  de_fault (to_doing_call,
	    (void (*) (int))
	    target_ignore);
@


1.136
log
@	* arch-utils.c (legacy_pc_in_sigtramp): Remove.
	* arch-utils.h (legacy_pc_in_sigtramp): Remove.

	* config/ia64/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/ia64/tm-linux.h: Remove file.
	* ia64-tdep.h (struct gdbarch_tdep): Add pc_in_sigtramp callback.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Use it instead of
	legacy_pc_in_sigtramp.
	(ia64_gdbarch_init): Initialize tdep->pc_in_sigtramp.
	* ia64-linux-tdep.c (ia64_linux_pc_in_sigtramp): Make static.
	Remove func_name argument.
	(ia64_linux_init_abi): Install it as tdep->pc_in_sigtramp.

	* infrun.c (HAVE_STEPPABLE_WATCHPOINT): Do not redefine.
	* target.c (update_current_target): Add to_have_steppable_watchpoint.
	* target.h (struct target_ops):  Add to_have_steppable_watchpoint.
	(HAVE_STEPPABLE_WATCHPOINT): Define.

	* config/ia64/linux.mh (NATDEPFILES): Remove core-aout.o.
	* config/ia64/nm-linux.h (KERNEL_U_ADDR, U_REGS_OFFSET,
	CANNOT_FETCH_REGISTER, CANNOT_STORE_REGISTER,
	TARGET_CAN_USE_HARDWARE_WATCHPOINT, HAVE_STEPPABLE_WATCHPOINT,
	STOPPED_BY_WATCHPOINT, target_stopped_data_address,
	target_insert_watchpoint, target_remove_watchpoint): Remove.
	(FETCH_INFERIOR_REGISTERS): Define.
	* ia64-linux-nat.c (ia64_register_addr): Make static.
	(ia64_cannot_fetch_register, ia64_cannot_store_register): Likewise.
	(ia64_linux_insert_watchpoint): Make static.  Remove ptid_p argument.
	(ia64_linux_remove_watchpoint): Likewise.  Add type argument.
	(ia64_linux_stopped_data_address): Make static.  Add target_ops.
	(ia64_linux_stopped_by_watchpoint): Make static.
	(ia64_linux_can_use_hw_breakpoint): New function.
	(ia64_linux_fetch_register, ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register, ia64_linux_store_registers): Likewise.
	(_initialize_ia64_linux_nat): Install register and watchpoint ops.
@
text
@d1973 1
a1973 1
/* Helper function for child_wait and the Lynx derivatives of child_wait.
@


1.135
log
@	Reported by timeless@@gmail.com:
	* gdb/target.c (target_flash_erase): Do not return void value.
	(target_flash_done): Likewise.
	* gdb/cli/cli-cmds.c (source_command): Likewise.

	Reported by timeless@@gmail.com:
	* wrapper.c (sim_target_parse_arg_array): Do not return void value.
@
text
@d416 1
@


1.134
log
@        * target.c (maintenance_print_target_stack): New function.
        (initialize_targets): Add new "maintenance print target-stack"
        command.
@
text
@d1255 2
a1256 1
	  return t->to_flash_erase (t, address, length);
d1272 2
a1273 1
	  return t->to_flash_done (t);
@


1.133
log
@From Nick Hudson:
	* target.c (update_current_target): Correct typo.

	* gdb.base/sigrepeat.exp: Correct error message.
@
text
@d2772 15
d2820 4
@


1.132
log
@Copyright updates for 2007.
@
text
@d382 1
a382 1
  /* First, reset curren'ts contents.  */
@


1.131
log
@2006-12-05  Adam Nemet  <anemet@@caviumnetworks.com>

	* target.c (debug_to_remove_watchpoint): Call
	to_remove_watchpoint.  Print target_remove_watchpoint.
@
text
@d3 2
a4 2
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
@


1.130
log
@	* Makefile.in (SFILES): Add new and missed files.
	(target_descriptions_h): New.
	(COMMON_OBS): Add target-descriptions.o.
	(arch-utils.o, infcmd.o, remote.o, target.o): Update.
	(target-descriptions.o): New.
	* arch-utils.c (gdbarch_info_fill): Check for a target
	description.
	* target-descriptions.c, target-descriptions.h: New files.
	* gdbarch.sh: Add target_desc to info.  Declare it in gdbarch.h.
	Correct typos.
	(gdbarch_list_lookup_by_info): Check target_desc.
	* gdbarch.c, gdbarch.h: Regenerated.
	* target.c (update_current_target): Mention to_read_description.
	(target_pre_inferior): Call target_clear_description.
	(target_read_description): New.
	* target.h (struct target_ops): Add to_read_description.
	(target_read_description): New prototype.
	* infcmd.c (post_create_inferior): Call target_find_description.
	* remote.c (remote_open_1): Likewise.
	(extended_remote_create_inferior): Add a comment.
	(extended_remote_async_create_inferior): Likewise.
@
text
@d2389 1
a2389 1
  retval = debug_target.to_insert_watchpoint (addr, len, type);
d2392 1
a2392 1
		      "target_insert_watchpoint (0x%lx, %d, %d) = %ld\n",
@


1.129
log
@        gdb/
        * memattr.h (enum mem_access_mode): New value
        MEM_NONE.
        * memattr.c (unknown_mem_attrib): New.
        (inaccessible_by_default): New.
        (show_inaccessible_by_default): New.
        (lookup_mem_region): Check inaccessible_by_default.
        (dummy_cmd): New.
        (mem_set_cmdlist, mem_show_cmdlist): New.
        (_initialize_mem): Register new "set" and "show"
        commands.
        * target.c (memory_xfer_partial): If memory type
        is MEM_NONE, return an error.
        Clip to region size when calling to_xfer_partial.
        If upper limit of memory range is 0, don't clip
        anything.

        gdb/doc/
        * gdb.texinfo (Memory Access Checking): New.
@
text
@d43 1
d468 1
d646 1
d1608 2
d1697 21
@


1.128
log
@gdb/
	* gdbint.texinfo (Target Vector Definition): Move most
	content into Existing Targets.  Add a menu.
	(Existing Targets): New section, moved from Target Vector
	Definition.  Use @@subsection.
	(Managing Execution State): New section.
gdb/doc/
	* remote-sim.c (gdbsim_kill): Call target_mourn_inferior.
	(gdbsim_load): Don't bother to adjust inferior_ptid here.
	(gdbsim_create_inferior): Mark the simulator as running.
	(gdbsim_open): Don't bother fetching registers.  Mark
	the target as not running.
	(gdbsim_xfer): When the program is not running, pass memory
	requests down.
	(gdbsim_mourn_inferior): Mark the target as not running.
	* target.c (target_mark_running, target_mark_exited): New.
	* target.h (target_has_execution): Update the comment.
	(target_mark_running, target_mark_exited): New prototypes.
@
text
@d1018 2
a1019 1
  if (memaddr + len < region->hi)
d1041 3
d1079 1
a1079 1
				  readbuf, writebuf, memaddr, len);
@


1.127
log
@2006-10-09  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* Makefile.in (expprint.o, parse.o, target.o): Update.
	* dwarf2loc.c (dwarf_expr_tls_address): Move body to
	target_translate_tls_address.  Call it.
	* eval.c (evaluate_subexp_standard): Handle UNOP_MEMVAL_TLS.
	* expprint.c (print_subexp_standard): Likewise.
	(op_name_standard, dump_subexp_body_standard): Likewise.
	* expression.h (enum exp_opcode): Add UNOP_MEMVAL_TLS.
	(union exp_element): Add objfile.
	* parse.c (write_exp_elt_objfile): New function.
	(msym_tls_symbol_type): New.
	(write_exp_msymbol): Handle TLS.
	(operator_length_standard): Handle UNOP_MEMVAL_TLS.
	(build_parse): Initialize msym_tls_symbol_type.
	* parser-defs.h (write_exp_elt_objfile): New prototype.
	* target.c (target_translate_tls_address): New.
	* target.h (target_translate_tls_address): Add prototype.

2006-10-09  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* gdb.threads/tls-nodebug.c, gdb.threads/tls-nodebug.exp: New test.
@
text
@d652 50
@


1.126
log
@	* Makefile.in (SFILES): Add target-memory.c.
	(COMMON_OBS): Add target-memory.o.
	* memattr.c (lookup_mem_region): Adjust handling for
	the top of memory.  Improve comments.
	* remote.c (packet_check_result): New function, split out
	from packet_ok.  Recognize "E." as an error prefix.
	(packet_ok): Use it.
	(remote_write_bytes_aux): New function, renamed from
	remote_write_bytes.  Take packet header, packet format,
	and length flag as arguments.
	(remote_write_bytes): Rewrite to use remote_write_bytes_aux.
	(remote_send_printf, restore_remote_timeout)
	(remote_flash_timeout, remote_flash_erase, remote_flash_write)
	(remote_flash_done): New.
	(remote_xfer_partial): Handle flash writes.
	(init_remote_ops, init_remote_async_ops): Set to_flash_erase
	and to_flash_done.
	* symfile.c (struct load_section_data): Include a pointer to
	the cumulative stats and a request queue.  Move most members
	to other types.
	(struct load_progress_data, struct load_progress_section_data): New
	types.
	(load_progress): Handle a NULL baton and zero bytes.  Update for
	type changes.
	(load_section_callback): Create memory write requests instead of
	writing to memory.  Don't print the progress message here.
	(clear_memory_write_data): New function.
	(generic_load): Use target_write_memory_blocks.
	* target-memory.c: New file.
	* target.c (update_current_target): Mention new uninherited methods.
	(memory_xfer_partial): Issue an error for flash writes.
	(target_flash_erase, target_flash_done): New functions.
	(target_write_with_progress): Call the progress callback at the
	start also.
	* target.h (enum target_object): Add TARGET_OBJECT_FLASH.
	(target_write_with_progress): Update comment.
	(struct target_ops): Add to_flash_erase and to_flash_done.
	(target_flash_erase, target_flash_done, struct memory_write_request)
	(memory_write_request_s, enum flash_preserve_mode)
	(target_write_memory_blocks): New, including a vector type
	for memory_write_request_s.
@
text
@d42 1
d762 86
@


1.125
log
@gdb/
2006-09-21  Vladimir Prus  <vladimir@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Nathan Sidwell  <nathan@@codesourcery.com>

	* Makefile.in (SFILES): Add memory-map.c and xml-support.c.
	(memory_map_h, xml_support_h): New.
	(target_h): Add vec_h dependency.
	(COMMON_OBS): Add memory-map.o and xml-support.o.
	(memory-map.o, xml-support.o): New rules.
	(remote.o): Update.
	* exceptions.h (enum errors): Add XML_PARSE_ERROR.
	* infcmd.c (run_command_1, attach_command): Call target_pre_inferior.
	* memattr.c (default_mem_attrib): Initialize blocksize.
	(target_mem_region_list, mem_use_target)
	(target_mem_regions_valid, mem_region_cmp, mem_region_init)
	(require_user_regions, require_target_regions)
	(invalidate_target_mem_regions): New.
	(create_mem_region): Use mem_region_init.
	(mem_clear): Move higher.
	(lookup_mem_region): Use require_target_regions.
	(mem_command): Implement "mem auto".
	(mem_info_command): Handle target-supplied regions and flash
	attributes.
	(mem_enable_command, mem_disable_command, mem_delete_command): Use
	require_user_regions.
	(_initialize_mem): Mention "mem auto" in help.
	* memattr.h (enum mem_access_mode): Add MEM_FLASH.
	(struct mem_attrib): Add blocksize.
	(invalidate_target_mem_regions, mem_region_init, mem_region_cmp): New
	prototypes.
	* remote.c: Include "memory-map.h".
	(PACKET_qXfer_memory_map): New enum value.
	(remote_protocol_features): Add qXfer:memory-map:read.
	(remote_xfer_partial): Handle memory maps.
	(remote_memory_map): New.
	(init_remote_ops, init_remote_async_ops): Set to_memory_map.
	(_initialize_remote): Register qXfer:memory-map:read.
	* target.c (update_current_target): Mention to_memory_map.
	(target_memory_map, target_pre_inferior): New.
	(target_preopen): Call target_pre_inferior.
	* target.h: Include "vec.h".
	(enum target_object): Add TARGET_OBJECT_MEMORY_MAP.
	(struct target_ops): Add to_memory_map.
	(target_memory_map, target_pre_inferior): New prototypes.
	* memory-map.c, memory-map.h, xml-support.c, xml-support.h: New files.
gdb/doc/
2006-09-21  Vladimir Prus  <vladimir@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb.texinfo (Memory Region Attributes): Mention target-supplied
	memory regions and "mem auto".
@
text
@d468 2
d897 6
d1100 33
d1273 5
@


1.124
log
@	* remote.c, target.c: Strip trailing whitespace.
@
text
@d467 1
d1044 48
d1408 12
d1442 2
@


1.123
log
@	PR remote/1966
	* dcache.c (dcache_write_line): Use target_write.
	(dcache_read_line): Use target_read.
	* mi/mi-main.c (mi_cmd_data_read_memory): Use target_read.
	* symfile.c (struct load_section_data): Add new per-section
	members.
	(load_progress): New function.
	(load_section_callback): Pass load_progress to the new
	target_write_with_progress.
	* target.c (current_xfer_partial, memory_xfer_partial): New.
	(target_xfer_partial): New prototype.
	(target_xfer_memory, target_xfer_partial_p, xfer_using_stratum)
	(do_xfer_memory, target_xfer_memory_partial)
	(target_read_memory_partial, target_write_memory_partial): Delete.
	(trust_readonly): Move higher in the file.
	(update_current_target): Use current_xer_partial.
	(target_xfer_partial): Use memory_xfer_partial.  Handle
	TARGET_OBJECT_RAW_MEMORY specially.
	(target_read_memory): Use target_read.
	(target_write_memory): Use target_write.
	(default_xfer_partial): Call to_xfer_partial directly.
	(target_write_with_progress): New function, based on target_write.
	(target_write): Call it.
	* target.h (enum target_object): Add TARGET_OBJECT_RAW_MEMORY.
	(target_write_with_progress): New prototype.
	(do_xfer_memory, target_read_memory_partial)
	(target_write_memory_partial): Delete prototypes.
@
text
@d170 1
a170 1
   array; the current index into the array; the allocated size of the 
d478 2
a479 2
  de_fault (to_open, 
	    (void (*) (char *, int)) 
d481 2
a482 2
  de_fault (to_close, 
	    (void (*) (int)) 
d484 1
a484 1
  de_fault (to_attach, 
d486 2
a487 2
  de_fault (to_post_attach, 
	    (void (*) (int)) 
d489 2
a490 2
  de_fault (to_detach, 
	    (void (*) (char *, int)) 
d492 2
a493 2
  de_fault (to_resume, 
	    (void (*) (ptid_t, int, enum target_signal)) 
d495 2
a496 2
  de_fault (to_wait, 
	    (ptid_t (*) (ptid_t, struct target_waitstatus *)) 
d498 2
a499 2
  de_fault (to_fetch_registers, 
	    (void (*) (int)) 
d501 2
a502 2
  de_fault (to_store_registers, 
	    (void (*) (int)) 
d504 2
a505 2
  de_fault (to_prepare_to_store, 
	    (void (*) (void)) 
d507 2
a508 2
  de_fault (deprecated_xfer_memory, 
	    (int (*) (CORE_ADDR, gdb_byte *, int, int, struct mem_attrib *, struct target_ops *)) 
d510 2
a511 2
  de_fault (to_files_info, 
	    (void (*) (struct target_ops *)) 
d513 1
a513 1
  de_fault (to_insert_breakpoint, 
d515 1
a515 1
  de_fault (to_remove_breakpoint, 
d540 2
a541 2
  de_fault (to_terminal_init, 
	    (void (*) (void)) 
d543 2
a544 2
  de_fault (to_terminal_inferior, 
	    (void (*) (void)) 
d546 2
a547 2
  de_fault (to_terminal_ours_for_output, 
	    (void (*) (void)) 
d549 2
a550 2
  de_fault (to_terminal_ours, 
	    (void (*) (void)) 
d552 2
a553 2
  de_fault (to_terminal_save_ours, 
	    (void (*) (void)) 
d555 1
a555 1
  de_fault (to_terminal_info, 
d557 2
a558 2
  de_fault (to_kill, 
	    (void (*) (void)) 
d560 2
a561 2
  de_fault (to_load, 
	    (void (*) (char *, int)) 
d563 2
a564 2
  de_fault (to_lookup_symbol, 
	    (int (*) (char *, CORE_ADDR *)) 
d566 1
a566 1
  de_fault (to_create_inferior, 
d568 2
a569 2
  de_fault (to_post_startup_inferior, 
	    (void (*) (ptid_t)) 
d571 2
a572 2
  de_fault (to_acknowledge_created_inferior, 
	    (void (*) (int)) 
d574 2
a575 2
  de_fault (to_insert_fork_catchpoint, 
	    (void (*) (int)) 
d577 2
a578 2
  de_fault (to_remove_fork_catchpoint, 
	    (int (*) (int)) 
d580 2
a581 2
  de_fault (to_insert_vfork_catchpoint, 
	    (void (*) (int)) 
d583 2
a584 2
  de_fault (to_remove_vfork_catchpoint, 
	    (int (*) (int)) 
d586 2
a587 2
  de_fault (to_insert_exec_catchpoint, 
	    (void (*) (int)) 
d589 2
a590 2
  de_fault (to_remove_exec_catchpoint, 
	    (int (*) (int)) 
d592 2
a593 2
  de_fault (to_reported_exec_events_per_exec_call, 
	    (int (*) (void)) 
d595 2
a596 2
  de_fault (to_has_exited, 
	    (int (*) (int, int, int *)) 
d598 2
a599 2
  de_fault (to_mourn_inferior, 
	    (void (*) (void)) 
d601 1
a601 1
  de_fault (to_can_run, 
d603 2
a604 2
  de_fault (to_notice_signals, 
	    (void (*) (ptid_t)) 
d606 2
a607 2
  de_fault (to_thread_alive, 
	    (int (*) (ptid_t)) 
d609 2
a610 2
  de_fault (to_find_new_threads, 
	    (void (*) (void)) 
d612 2
a613 2
  de_fault (to_extra_thread_info, 
	    (char *(*) (struct thread_info *)) 
d615 2
a616 2
  de_fault (to_stop, 
	    (void (*) (void)) 
d619 2
a620 2
  de_fault (to_rcmd, 
	    (void (*) (char *, struct ui_file *)) 
d622 2
a623 2
  de_fault (to_enable_exception_callback, 
	    (struct symtab_and_line * (*) (enum exception_event_kind, int)) 
d625 2
a626 2
  de_fault (to_get_current_exception_event, 
	    (struct exception_event_record * (*) (void)) 
d628 2
a629 2
  de_fault (to_pid_to_exec_file, 
	    (char *(*) (int)) 
d631 2
a632 2
  de_fault (to_can_async_p, 
	    (int (*) (void)) 
d634 2
a635 2
  de_fault (to_is_async_p, 
	    (int (*) (void)) 
d637 2
a638 2
  de_fault (to_async, 
	    (void (*) (void (*) (enum inferior_event_type, void*), void*)) 
d706 1
a706 1
/* Remove a target_ops vector from the stack, wherever it may be. 
d989 1
a989 1
	  
d1002 1
a1002 1
	      
d1006 1
a1006 1
      
d1071 1
a1071 1
		      const char *annex, gdb_byte *readbuf, 
d1550 1
a1550 1
     
d1570 1
a1570 1
  
d1963 1
a1963 1
	  
d2515 1
a2515 1
  add_setshow_boolean_cmd ("trust-readonly-sections", class_support, 
@


1.122
log
@	* target.h (target_read_stralloc): New prototype.
	* target.c (target_read_alloc_1): Renamed from target_read_alloc.
	Take new PADDING argument.
	(target_read_alloc): Use it.
	(target_read_stralloc): New function.
@
text
@d79 11
a89 8
/* Transfer LEN bytes between target address MEMADDR and GDB address
   MYADDR.  Returns 0 for success, errno code for failure (which
   includes partial transfers -- if you want a more useful response to
   partial transfers, try either target_read_memory_partial or
   target_write_memory_partial).  */

static int target_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len,
			       int write);
d201 5
d618 1
a618 1
  current_target.to_xfer_partial = default_xfer_partial;
d849 6
a854 4
/* Return non-zero when the target vector has supplied an xfer_partial
   method and it, rather than xfer_memory, should be used.  */
static int
target_xfer_partial_p (void)
d856 84
a939 2
  return (target_stack != NULL
	  && target_stack->to_xfer_partial != default_xfer_partial);
d951 19
a969 2
  retval = ops->to_xfer_partial (ops, object, annex, readbuf, writebuf,
				 offset, len);
a1011 79
/* Attempt a transfer all LEN bytes starting at OFFSET between the
   inferior's KIND:ANNEX space and GDB's READBUF/WRITEBUF buffer.  If
   the transfer succeeds, return zero, otherwize the host ERRNO is
   returned.

   The inferior is formed from several layers.  In the case of
   corefiles, inf-corefile is layered above inf-exec and a request for
   text (corefiles do not include text pages) will be first sent to
   the core-stratum, fail, and then sent to the object-file where it
   will succeed.

   NOTE: cagney/2004-09-30:

   The old code tried to use four separate mechanisms for mapping an
   object:offset:len tuple onto an inferior and its address space: the
   target stack; the inferior's TO_SECTIONS; solib's SO_LIST;
   overlays.

   This is stupid.

   The code below is instead using a single mechanism (currently
   strata).  If that mechanism proves insufficient then re-factor it
   implementing another singluar mechanism (for instance, a generic
   object:annex onto inferior:object:annex say).  */

static LONGEST
xfer_using_stratum (enum target_object object, const char *annex,
		    ULONGEST offset, LONGEST len, void *readbuf,
		    const void *writebuf)
{
  LONGEST xfered;
  struct target_ops *target;

  /* Always successful.  */
  if (len == 0)
    return 0;
  /* Never successful.  */
  if (target_stack == NULL)
    return EIO;

  target = target_stack;
  while (1)
    {
      xfered = target_xfer_partial (target, object, annex,
				    readbuf, writebuf, offset, len);
      if (xfered > 0)
	{
	  /* The partial xfer succeeded, update the counts, check that
	     the xfer hasn't finished and if it hasn't set things up
	     for the next round.  */
	  len -= xfered;
	  if (len <= 0)
	    return 0;
	  offset += xfered;
	  if (readbuf != NULL)
	    readbuf = (gdb_byte *) readbuf + xfered;
	  if (writebuf != NULL)
	    writebuf = (gdb_byte *) writebuf + xfered;
	  target = target_stack;
	}
      else if (xfered < 0)
	{
	  /* Something totally screwed up, abandon the attempt to
	     xfer.  */
	  if (errno)
	    return errno;
	  else
	    return EIO;
	}
      else
	{
	  /* This "stratum" didn't work, try the next one down.  */
	  target = target->beneath;
	  if (target == NULL)
	    return EIO;
	}
    }
}

d1020 2
a1021 1
   deal with partial reads should call target_read_memory_partial. */
d1026 3
a1028 3
  if (target_xfer_partial_p ())
    return xfer_using_stratum (TARGET_OBJECT_MEMORY, NULL,
			       memaddr, len, myaddr, NULL);
d1030 1
a1030 1
    return target_xfer_memory (memaddr, myaddr, len, 0);
d1036 3
a1038 5
  gdb_byte *bytes = alloca (len);
  memcpy (bytes, myaddr, len);
  if (target_xfer_partial_p ())
    return xfer_using_stratum (TARGET_OBJECT_MEMORY, NULL,
			       memaddr, len, NULL, bytes);
d1040 1
a1040 1
    return target_xfer_memory (memaddr, bytes, len, 1);
a1057 1
static int trust_readonly = 0;
a1066 257
/* Move memory to or from the targets.  The top target gets priority;
   if it cannot handle it, it is offered to the next one down, etc.

   Result is -1 on error, or the number of bytes transfered.  */

int
do_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len, int write,
		struct mem_attrib *attrib)
{
  int res;
  int done = 0;
  struct target_ops *t;

  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    return 0;

  /* deprecated_xfer_memory is not guaranteed to set errno, even when
     it returns 0.  */
  errno = 0;

  if (!write && trust_readonly)
    {
      struct section_table *secp;
      /* User-settable option, "trust-readonly-sections".  If true,
         then memory from any SEC_READONLY bfd section may be read
         directly from the bfd file.  */
      secp = target_section_by_addr (&current_target, memaddr);
      if (secp != NULL
	  && (bfd_get_section_flags (secp->bfd, secp->the_bfd_section)
	      & SEC_READONLY))
	return xfer_memory (memaddr, myaddr, len, 0, attrib, &current_target);
    }

  /* The quick case is that the top target can handle the transfer.  */
  res = current_target.deprecated_xfer_memory
    (memaddr, myaddr, len, write, attrib, &current_target);

  /* If res <= 0 then we call it again in the loop.  Ah well. */
  if (res <= 0)
    {
      for (t = target_stack; t != NULL; t = t->beneath)
	{
	  if (!t->to_has_memory)
	    continue;

	  res = t->deprecated_xfer_memory (memaddr, myaddr, len, write, attrib, t);
	  if (res > 0)
	    break;		/* Handled all or part of xfer */
	  if (t->to_has_all_memory)
	    break;
	}

      if (res <= 0)
	return -1;
    }

  return res;
}


/* Perform a memory transfer.  Iterate until the entire region has
   been transfered.

   Result is 0 or errno value.  */

static int
target_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len, int write)
{
  int res;
  int reg_len;
  struct mem_region *region;

  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    {
      return 0;
    }

  while (len > 0)
    {
      region = lookup_mem_region(memaddr);
      if (memaddr + len < region->hi)
	reg_len = len;
      else
	reg_len = region->hi - memaddr;

      switch (region->attrib.mode)
	{
	case MEM_RO:
	  if (write)
	    return EIO;
	  break;
	  
	case MEM_WO:
	  if (!write)
	    return EIO;
	  break;
	}

      while (reg_len > 0)
	{
	  if (region->attrib.cache)
	    res = dcache_xfer_memory (target_dcache, memaddr, myaddr,
				      reg_len, write);
	  else
	    res = do_xfer_memory (memaddr, myaddr, reg_len, write,
				 &region->attrib);
	      
	  if (res <= 0)
	    {
	      /* If this address is for nonexistent memory, read zeros
		 if reading, or do nothing if writing.  Return
		 error. */
	      if (!write)
		memset (myaddr, 0, len);
	      if (errno == 0)
		return EIO;
	      else
		return errno;
	    }

	  memaddr += res;
	  myaddr  += res;
	  len     -= res;
	  reg_len -= res;
	}
    }
  
  return 0;			/* We managed to cover it all somehow. */
}


/* Perform a partial memory transfer.

   If we succeed, set *ERR to zero and return the number of bytes transferred.
   If we fail, set *ERR to a non-zero errno value, and return -1.  */

static int
target_xfer_memory_partial (CORE_ADDR memaddr, gdb_byte *myaddr, int len,
			    int write_p, int *err)
{
  int res;
  int reg_len;
  struct mem_region *region;

  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    {
      *err = 0;
      return 0;
    }

  region = lookup_mem_region(memaddr);
  if (memaddr + len < region->hi)
    reg_len = len;
  else
    reg_len = region->hi - memaddr;

  switch (region->attrib.mode)
    {
    case MEM_RO:
      if (write_p)
	{
	  *err = EIO;
	  return -1;
	}
      break;

    case MEM_WO:
      if (write_p)
	{
	  *err = EIO;
	  return -1;
	}
      break;
    }

  if (region->attrib.cache)
    res = dcache_xfer_memory (target_dcache, memaddr, myaddr,
			      reg_len, write_p);
  else
    res = do_xfer_memory (memaddr, myaddr, reg_len, write_p,
			  &region->attrib);
      
  if (res <= 0)
    {
      if (errno != 0)
	*err = errno;
      else
	*err = EIO;

        return -1;
    }

  *err = 0;
  return res;
}

int
target_read_memory_partial (CORE_ADDR memaddr, gdb_byte *buf,
			    int len, int *err)
{
  if (target_xfer_partial_p ())
    {
      int retval;

      retval = target_xfer_partial (target_stack, TARGET_OBJECT_MEMORY,
				    NULL, buf, NULL, memaddr, len);

      if (retval <= 0)
	{
	  if (errno)
	    *err = errno;
	  else
	    *err = EIO;
	  return -1;
	}
      else
	{
	  *err = 0;
	  return retval;
	}
    }
  else
    return target_xfer_memory_partial (memaddr, buf, len, 0, err);
}

int
target_write_memory_partial (CORE_ADDR memaddr, gdb_byte *buf,
			     int len, int *err)
{
  if (target_xfer_partial_p ())
    {
      int retval;

      retval = target_xfer_partial (target_stack, TARGET_OBJECT_MEMORY,
				    NULL, NULL, buf, memaddr, len);

      if (retval <= 0)
	{
	  if (errno)
	    *err = errno;
	  else
	    *err = EIO;
	  return -1;
	}
      else
	{
	  *err = 0;
	  return retval;
	}
    }
  else
    return target_xfer_memory_partial (memaddr, buf, len, 1, err);
}

d1103 18
a1120 2
    return target_xfer_partial (ops->beneath, object, annex,
				readbuf, writebuf, offset, len);
d1173 2
d1176 5
a1180 4
target_write (struct target_ops *ops,
	      enum target_object object,
	      const char *annex, const gdb_byte *buf,
	      ULONGEST offset, LONGEST len)
d1188 1
a1188 1
      /* Call an observer, notifying them of the xfer progress?  */
d1193 4
d1203 10
@


1.121
log
@2006-07-18  Vladimir Prus  <vladimir@@codesourcery.com>

        * target.c (tcomplain): Mark with ATTR_NORETURN.
@
text
@d1409 9
a1417 16
/* Wrapper to perform a full read of unknown size.  OBJECT/ANNEX will
   be read using OPS.  The return value will be -1 if the transfer
   fails or is not supported; 0 if the object is empty; or the length
   of the object otherwise.  If a positive value is returned, a
   sufficiently large buffer will be allocated using xmalloc and
   returned in *BUF_P containing the contents of the object.

   This method should be used for objects sufficiently small to store
   in a single xmalloc'd buffer, when no fixed bound on the object's
   size is known in advance.  Don't try to read TARGET_OBJECT_MEMORY
   through this function.  */

LONGEST
target_read_alloc (struct target_ops *ops,
		   enum target_object object,
		   const char *annex, gdb_byte **buf_p)
d1438 1
a1438 1
			       buf_pos, buf_alloc - buf_pos);
d1468 41
@


1.120
log
@	* target.c (target_read): Stop if target_read_partial returns 0
	when some bytes have already been read.
	(target_write): Likewise for target_write_partial.
	(target_read_partial, target_write_partial): Make static.
	(target_read_alloc): New.
	* target.h: Doc fixes.
	(target_read_partial, target_write_partial): Delete prototypes.
	(target_read_alloc): New prototype.

	* auxv.c (target_auxv_read): Delete.
	(target_auxv_search, fprint_target_auxv): Use target_read_alloc.
	* auxv.h (target_auxv_read): Delete prototype.
	* avr-tdep.c (avr_io_reg_read_command): Use target_read_alloc.
	* ia64-tdep.c (getunwind_table, get_kernel_table): Likewise.
	* linux-nat.c (linux_nat_make_corefile_notes): Likewise.
	* procfs.c (procfs_make_note_section): Likewise.
	* remote.c (remote_xfer_partial): Don't loop here.
	* sparc-tdep.c (sparc_fetch_wcookie): Use target_read.
@
text
@d55 1
a55 1
static void tcomplain (void);
@


1.119
log
@	* remote.c (remote_disconnect): Add TARGET argument.
	* target.c (debug_to_disconnect): Delete.
	(update_current_target): Do not inherit to_disconnect.
	(target_disconnect): Search for a target to implement to_disconnect.
	(setup_target_debug): Do not reference to_disconnect.
	* target.h (struct target_ops): Add target argument to
	to_disconnect.
@
text
@d1344 1
a1344 1
LONGEST
d1353 1
a1353 1
LONGEST
d1376 3
a1378 2
      if (xfer <= 0)
	/* Call memory_error?  */
d1399 3
a1401 2
      if (xfer <= 0)
	/* Call memory_error?  */
d1409 66
@


1.119.2.1
log
@2006-05-13    Changes based on Apple GDB (CVS repository 5th Sept 2005)

	* async-nat-inferior.c, async-nat-inferior.h,
	* async-nat-sigthread.c, async-nat-sigthread.h: New files

	* linux-nat.c: Include async-nat-inferior.h.
	(linux_nat_wait): Add extra argument.  If target_can_async_p
	do something completely different.

	* interps.h (interp_set, interp_set_quiet): New externs.

	* interps.c (interp_set): Make asynchronous.
	(interp_set_quiet): Don't make static.
	(current_interp_command_loop): Call functions with new arguments.

	* target.h (target_wait): Add extra argument.
	(gdb_override_async, gdb_set_async_override) New externs.
	(target_can_async_p): Make conditional on gdb_override_async.

	* target.c (gdb_override_async): New variable.
	(gdb_set_async_override, do_restore_target_async_mask):
	New functions.
	(debug_to_wait): Add extra argument.

	* linux-thread-db.c (thread_db_wait): Add extra argument.

	* wrapper.h (safe_execute_command): Declare structure.

	* top.c (*deprecated_target_wait_hook): Add extra argument.
	(read_command_file): Make asynchronous.

	* remote.c (remote_wait, remote_async_wait): Add extra argument.

	* infrun.c: Include event-top.h
	(wait_for_inferior, fetch_inferior_event): Add extra argument to
	target_wait.
	(proceed): Set target_executing = 0.
	(handle_inferior_event): Call async_disable_stdin if async.

	* inf-ptrace.c: Include inf-loop.h, async-nat-inferior.h.
	(inf_ptrace_him): Create a signal thread.
	(inf_ptrace_wait): Add extra argument to target_wait.

	* inf-loop.c (inferior_event_handler, complete_execution):
	Changes for asynchronous operation (copied verbatim).

	* inf-child.c: Include async-nat-inferior.h.
	(inf_child_target): Use methods async_terminal_inferior
	and async_terminal_ours.

	* i386-linux-nat.c: Include inf-loop.h, async-nat-inferior.h.
	(i386_linux_resume): Call gdb_process_events and then
	async methods.

	* exec.c: Include event-loop.h, async-nat-inferior.h.
	(async_file_handler, standard_async, standard_is_async_p)
	(standard_can_async_p): New functions.
	(init_exec_ops): Initialise above methods.

	* event-top.h (cli_command_loop): Make argument void*.

	* event-top.c (display_gdb_prompt, async_enable_stdin)
	(async_disable_stdin, handle_sigint, async_request_quit)
	(gdb_setup_readline, _initialize_event_loop):
	Changes for asynchronous operation (copied verbatim).
	(cli_command_loop): Make argument void*.

	* event-loop.h (gdb_client_data): Move typedef to defs.h.
	(gdb_create_event): Declare.
	(event_handler_func): Move typedef from event-loop.c.

	* event-loop.c (use_poll): Set to 0.
	(gdb_queue_event, gdb_create_event): New functions.
	(async_queue_event): Don't make static.
	(create_file_event): Use gdb_create_event.
	(gdb_event): Change component from int to void*.
	(process_event, handle_file_event, handle_timer_event):
	Change according to gdb_event.
	(event_handler_func): Move typedef to event-loop.c.

	* defs.h: (gdb_mi_run_status, event_loop_p): New externs.
	(gdb_client_data): Move typedef from event-loop.h.
	(*deprecated_command_loop_hook): Make argument void*.
	(*deprecated_target_wait_hook): Add argument.

	* cli-out.h (cli_quoted_out_new): Declare.

	* cli-out.c (cli_quoted_out_new): New function.
	Include mi/mi-console.h.

	* cli/cli-interp.c: Include inferior.h, mi/mi-console.h.
	(safe_execute_command): Make static.
	(cli_interpreter_resume, cli_interpreter_exec):
	Make asynchronous.
	(cli_quoted_interpreter_resume): New function.
	(_initialize_cli_interp): Add li_command_loop to procs.
	Initialize the console-quoted interpreter.

	* tui/tui-hooks.c (tui_target_wait_hook): Add extra argument.

	* mi/mi-main.h (mi_dont_register_continuation)
	(current_command_token,  mi_interp, mi_interpreter_exec_continuation)
	(mi_continuation_arg): New externs.
	(mi_setup_continuation_arg): Declare.

	* mi/mi-main.c: Include wrapper.h.
	(struct mi_continuation_arg): New structure.
	(mi_interpreter_exec_continuation): Move to mi-interp.c.
	(mi_execute_async_cli_command)
	(mi_exec_async_cli_cmd_continuation): Make asynchronous.
	(mi_setup_continuation_arg): New function.

	* mi/mi-interp.c (mi_interpreter_exec_continuation):
	Move from mi-main.c
	(mi_cmd_interpreter_exec): Switch interpreters.  Make
	asynchronous.
	(mi1_command_loop, mi2_command_loop, mi3_command_loop):
	Make argument void*.

	* Makefile.in (async_nat_inferior_h, async_nat_sigthread_h):
	New variables.
	(gdb$(EXEEXT), $(TUI)$(EXEEXT)): Link with libpthread.
	(async-nat-inferior.o, async-nat-sigthread.o): New rules.
	(COMMON_OBS): Add above object files.
	(exec.o, i386-linux-nat.o, inf-ptrace.o, linux-nat.o):
	Update dependencies.

2006-05-13  Nick Roberts  <nickrob@@snap.net.nz>

	* main.c: (event_loop_p): Re-instate variable.
	(captured_main): Re-instate async/noasync option.
	(print_gdb_help): Describe option again.

	* exec.c(init_exec_ops): Only initialise async methods with async
	option.

	* inf-ptrace.c (inf_ptrace_him): Only reate a signal thread with
	async option.

	* README.async, TODO.async, PROBLEMS.async: New files.
@
text
@d102 1
a102 2
static ptid_t debug_to_wait (ptid_t, struct target_waitstatus *,
			     gdb_client_data client_data);
a209 4
/* Non-zero if we are overriding the target's async behavior as far as
   user commands go... */
int gdb_override_async = 0;

d487 2
a488 2
  de_fault (to_wait,  
	    (ptid_t (*) (ptid_t, struct target_waitstatus *, gdb_client_data client_data)) 
a1510 15
void
gdb_set_async_override (void* on)
{
  if (on) gdb_override_async = 1;
}

/* do_restore_target_async_mask is a convenience function to use
   in make_cleanup to restore the state of the async mask. */
 
void
do_restore_target_async_mask (int mask)
{
  target_async_mask (mask);
}

d1927 1
a1927 2
debug_to_wait (ptid_t ptid, struct target_waitstatus *status,
	       gdb_client_data client_data)
d1931 1
a1931 1
  retval = debug_target.to_wait (ptid, status, client_data);
@


1.119.2.2
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d55 1
a55 1
static void tcomplain (void) ATTR_NORETURN;
d79 5
a83 5
static LONGEST current_xfer_partial (struct target_ops *ops,
				     enum target_object object,
				     const char *annex, gdb_byte *readbuf,
				     const gdb_byte *writebuf,
				     ULONGEST offset, LONGEST len);
d85 2
a86 5
static LONGEST target_xfer_partial (struct target_ops *ops,
				    enum target_object object,
				    const char *annex,
				    void *readbuf, const void *writebuf,
				    ULONGEST offset, LONGEST len);
d168 1
a168 1
   array; the current index into the array; the allocated size of the
a198 5
/* Nonzero if we should trust readonly sections from the
   executable when reading memory.  */

static int trust_readonly = 0;

d475 2
a476 2
  de_fault (to_open,
	    (void (*) (char *, int))
d478 2
a479 2
  de_fault (to_close,
	    (void (*) (int))
d481 1
a481 1
  de_fault (to_attach,
d483 2
a484 2
  de_fault (to_post_attach,
	    (void (*) (int))
d486 2
a487 2
  de_fault (to_detach,
	    (void (*) (char *, int))
d489 2
a490 2
  de_fault (to_resume,
	    (void (*) (ptid_t, int, enum target_signal))
d495 2
a496 2
  de_fault (to_fetch_registers,
	    (void (*) (int))
d498 2
a499 2
  de_fault (to_store_registers,
	    (void (*) (int))
d501 2
a502 2
  de_fault (to_prepare_to_store,
	    (void (*) (void))
d504 2
a505 2
  de_fault (deprecated_xfer_memory,
	    (int (*) (CORE_ADDR, gdb_byte *, int, int, struct mem_attrib *, struct target_ops *))
d507 2
a508 2
  de_fault (to_files_info,
	    (void (*) (struct target_ops *))
d510 1
a510 1
  de_fault (to_insert_breakpoint,
d512 1
a512 1
  de_fault (to_remove_breakpoint,
d537 2
a538 2
  de_fault (to_terminal_init,
	    (void (*) (void))
d540 2
a541 2
  de_fault (to_terminal_inferior,
	    (void (*) (void))
d543 2
a544 2
  de_fault (to_terminal_ours_for_output,
	    (void (*) (void))
d546 2
a547 2
  de_fault (to_terminal_ours,
	    (void (*) (void))
d549 2
a550 2
  de_fault (to_terminal_save_ours,
	    (void (*) (void))
d552 1
a552 1
  de_fault (to_terminal_info,
d554 2
a555 2
  de_fault (to_kill,
	    (void (*) (void))
d557 2
a558 2
  de_fault (to_load,
	    (void (*) (char *, int))
d560 2
a561 2
  de_fault (to_lookup_symbol,
	    (int (*) (char *, CORE_ADDR *))
d563 1
a563 1
  de_fault (to_create_inferior,
d565 2
a566 2
  de_fault (to_post_startup_inferior,
	    (void (*) (ptid_t))
d568 2
a569 2
  de_fault (to_acknowledge_created_inferior,
	    (void (*) (int))
d571 2
a572 2
  de_fault (to_insert_fork_catchpoint,
	    (void (*) (int))
d574 2
a575 2
  de_fault (to_remove_fork_catchpoint,
	    (int (*) (int))
d577 2
a578 2
  de_fault (to_insert_vfork_catchpoint,
	    (void (*) (int))
d580 2
a581 2
  de_fault (to_remove_vfork_catchpoint,
	    (int (*) (int))
d583 2
a584 2
  de_fault (to_insert_exec_catchpoint,
	    (void (*) (int))
d586 2
a587 2
  de_fault (to_remove_exec_catchpoint,
	    (int (*) (int))
d589 2
a590 2
  de_fault (to_reported_exec_events_per_exec_call,
	    (int (*) (void))
d592 2
a593 2
  de_fault (to_has_exited,
	    (int (*) (int, int, int *))
d595 2
a596 2
  de_fault (to_mourn_inferior,
	    (void (*) (void))
d598 1
a598 1
  de_fault (to_can_run,
d600 2
a601 2
  de_fault (to_notice_signals,
	    (void (*) (ptid_t))
d603 2
a604 2
  de_fault (to_thread_alive,
	    (int (*) (ptid_t))
d606 2
a607 2
  de_fault (to_find_new_threads,
	    (void (*) (void))
d609 2
a610 2
  de_fault (to_extra_thread_info,
	    (char *(*) (struct thread_info *))
d612 2
a613 2
  de_fault (to_stop,
	    (void (*) (void))
d615 3
a617 3
  current_target.to_xfer_partial = current_xfer_partial;
  de_fault (to_rcmd,
	    (void (*) (char *, struct ui_file *))
d619 2
a620 2
  de_fault (to_enable_exception_callback,
	    (struct symtab_and_line * (*) (enum exception_event_kind, int))
d622 2
a623 2
  de_fault (to_get_current_exception_event,
	    (struct exception_event_record * (*) (void))
d625 2
a626 2
  de_fault (to_pid_to_exec_file,
	    (char *(*) (int))
d628 2
a629 2
  de_fault (to_can_async_p,
	    (int (*) (void))
d631 2
a632 2
  de_fault (to_is_async_p,
	    (int (*) (void))
d634 2
a635 2
  de_fault (to_async,
	    (void (*) (void (*) (enum inferior_event_type, void*), void*))
d703 1
a703 1
/* Remove a target_ops vector from the stack, wherever it may be.
d846 4
a849 6
/* Perform a partial memory transfer.  The arguments and return
   value are just as for target_xfer_partial.  */

static LONGEST
memory_xfer_partial (struct target_ops *ops, void *readbuf, const void *writebuf,
		     ULONGEST memaddr, LONGEST len)
d851 2
a852 84
  LONGEST res;
  int reg_len;
  struct mem_region *region;

  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    return 0;

  /* Try the executable file, if "trust-readonly-sections" is set.  */
  if (readbuf != NULL && trust_readonly)
    {
      struct section_table *secp;

      secp = target_section_by_addr (ops, memaddr);
      if (secp != NULL
	  && (bfd_get_section_flags (secp->bfd, secp->the_bfd_section)
	      & SEC_READONLY))
	return xfer_memory (memaddr, readbuf, len, 0, NULL, ops);
    }

  /* Try GDB's internal data cache.  */
  region = lookup_mem_region (memaddr);
  if (memaddr + len < region->hi)
    reg_len = len;
  else
    reg_len = region->hi - memaddr;

  switch (region->attrib.mode)
    {
    case MEM_RO:
      if (writebuf != NULL)
	return -1;
      break;

    case MEM_WO:
      if (readbuf != NULL)
	return -1;
      break;
    }

  if (region->attrib.cache)
    {
      /* FIXME drow/2006-08-09: This call discards OPS, so the raw
	 memory request will start back at current_target.  */
      if (readbuf != NULL)
	res = dcache_xfer_memory (target_dcache, memaddr, readbuf,
				  reg_len, 0);
      else
	/* FIXME drow/2006-08-09: If we're going to preserve const
	   correctness dcache_xfer_memory should take readbuf and
	   writebuf.  */
	res = dcache_xfer_memory (target_dcache, memaddr,
				  (void *) writebuf,
				  reg_len, 1);
      if (res <= 0)
	return -1;
      else
	return res;
    }

  /* If none of those methods found the memory we wanted, fall back
     to a target partial transfer.  Normally a single call to
     to_xfer_partial is enough; if it doesn't recognize an object
     it will call the to_xfer_partial of the next target down.
     But for memory this won't do.  Memory is the only target
     object which can be read from more than one valid target.
     A core file, for instance, could have some of memory but
     delegate other bits to the target below it.  So, we must
     manually try all targets.  */

  do
    {
      res = ops->to_xfer_partial (ops, TARGET_OBJECT_MEMORY, NULL,
				  readbuf, writebuf, memaddr, len);
      if (res > 0)
	return res;

      ops = ops->beneath;
    }
  while (ops != NULL);

  /* If we still haven't got anything, return the last error.  We
     give up.  */
  return res;
d864 2
a865 19

  /* If this is a memory transfer, let the memory-specific code
     have a look at it instead.  Memory transfers are more
     complicated.  */
  if (object == TARGET_OBJECT_MEMORY)
    retval = memory_xfer_partial (ops, readbuf, writebuf, offset, len);
  else
    {
      enum target_object raw_object = object;

      /* If this is a raw memory transfer, request the normal
	 memory object from other layers.  */
      if (raw_object == TARGET_OBJECT_RAW_MEMORY)
	raw_object = TARGET_OBJECT_MEMORY;

      retval = ops->to_xfer_partial (ops, raw_object, annex, readbuf,
				     writebuf, offset, len);
    }

d885 1
a885 1

d898 1
a898 1

d902 1
a902 1

d908 79
d995 1
a995 2
   deal with partial reads should call target_read (which will retry until
   it makes no progress, and then return how much was transferred). */
d1000 3
a1002 3
  if (target_read (&current_target, TARGET_OBJECT_MEMORY, NULL,
		   myaddr, memaddr, len) == len)
    return 0;
d1004 1
a1004 1
    return EIO;
d1010 5
a1014 3
  if (target_write (&current_target, TARGET_OBJECT_MEMORY, NULL,
		    myaddr, memaddr, len) == len)
    return 0;
d1016 1
a1016 1
    return EIO;
d1034 1
d1044 257
d1305 1
a1305 1
		      const char *annex, gdb_byte *readbuf,
d1337 2
a1338 18
    return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					  readbuf, writebuf, offset, len);
  else
    return -1;
}

/* The xfer_partial handler for the topmost target.  Unlike the default,
   it does not need to handle memory specially; it just passes all
   requests down the stack.  */

static LONGEST
current_xfer_partial (struct target_ops *ops, enum target_object object,
		      const char *annex, gdb_byte *readbuf,
		      const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  if (ops->beneath != NULL)
    return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					  readbuf, writebuf, offset, len);
d1349 1
a1349 1
static LONGEST
d1358 1
a1358 1
static LONGEST
d1381 2
a1382 3
      if (xfer == 0)
	return xfered;
      if (xfer < 0)
a1389 2
/* An alternative to target_write with progress callbacks.  */

d1391 4
a1394 5
target_write_with_progress (struct target_ops *ops,
			    enum target_object object,
			    const char *annex, const gdb_byte *buf,
			    ULONGEST offset, LONGEST len,
			    void (*progress) (ULONGEST, void *), void *baton)
d1402 3
a1404 4

      if (xfer == 0)
	return xfered;
      if (xfer < 0)
a1405 4

      if (progress)
	(*progress) (xfer, baton);

a1411 110
LONGEST
target_write (struct target_ops *ops,
	      enum target_object object,
	      const char *annex, const gdb_byte *buf,
	      ULONGEST offset, LONGEST len)
{
  return target_write_with_progress (ops, object, annex, buf, offset, len,
				     NULL, NULL);
}

/* Read OBJECT/ANNEX using OPS.  Store the result in *BUF_P and return
   the size of the transferred data.  PADDING additional bytes are
   available in *BUF_P.  This is a helper function for
   target_read_alloc; see the declaration of that function for more
   information.  */

static LONGEST
target_read_alloc_1 (struct target_ops *ops, enum target_object object,
		     const char *annex, gdb_byte **buf_p, int padding)
{
  size_t buf_alloc, buf_pos;
  gdb_byte *buf;
  LONGEST n;

  /* This function does not have a length parameter; it reads the
     entire OBJECT).  Also, it doesn't support objects fetched partly
     from one target and partly from another (in a different stratum,
     e.g. a core file and an executable).  Both reasons make it
     unsuitable for reading memory.  */
  gdb_assert (object != TARGET_OBJECT_MEMORY);

  /* Start by reading up to 4K at a time.  The target will throttle
     this number down if necessary.  */
  buf_alloc = 4096;
  buf = xmalloc (buf_alloc);
  buf_pos = 0;
  while (1)
    {
      n = target_read_partial (ops, object, annex, &buf[buf_pos],
			       buf_pos, buf_alloc - buf_pos - padding);
      if (n < 0)
	{
	  /* An error occurred.  */
	  xfree (buf);
	  return -1;
	}
      else if (n == 0)
	{
	  /* Read all there was.  */
	  if (buf_pos == 0)
	    xfree (buf);
	  else
	    *buf_p = buf;
	  return buf_pos;
	}

      buf_pos += n;

      /* If the buffer is filling up, expand it.  */
      if (buf_alloc < buf_pos * 2)
	{
	  buf_alloc *= 2;
	  buf = xrealloc (buf, buf_alloc);
	}

      QUIT;
    }
}

/* Read OBJECT/ANNEX using OPS.  Store the result in *BUF_P and return
   the size of the transferred data.  See the declaration in "target.h"
   function for more information about the return value.  */

LONGEST
target_read_alloc (struct target_ops *ops, enum target_object object,
		   const char *annex, gdb_byte **buf_p)
{
  return target_read_alloc_1 (ops, object, annex, buf_p, 0);
}

/* Read OBJECT/ANNEX using OPS.  The result is NUL-terminated and
   returned as a string, allocated using xmalloc.  If an error occurs
   or the transfer is unsupported, NULL is returned.  Empty objects
   are returned as allocated but empty strings.  A warning is issued
   if the result contains any embedded NUL bytes.  */

char *
target_read_stralloc (struct target_ops *ops, enum target_object object,
		      const char *annex)
{
  gdb_byte *buffer;
  LONGEST transferred;

  transferred = target_read_alloc_1 (ops, object, annex, &buffer, 1);

  if (transferred < 0)
    return NULL;

  if (transferred == 0)
    return xstrdup ("");

  buffer[transferred] = 0;
  if (strlen (buffer) < transferred)
    warning (_("target object %d, annex %s, "
	       "contained unexpected null characters"),
	     (int) object, annex ? annex : "(none)");

  return (char *) buffer;
}

d1664 1
a1664 1

d1684 1
a1684 1

d2078 1
a2078 1

d2630 1
a2630 1
  add_setshow_boolean_cmd ("trust-readonly-sections", class_support,
@


1.118
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@a99 2
static void debug_to_disconnect (char *, int);

d389 1
a389 1
      INHERIT (to_disconnect, t);
a483 3
  de_fault (to_disconnect, 
	    (void (*) (char *, int)) 
	    tcomplain);
d1488 13
a1500 1
  (current_target.to_disconnect) (args, from_tty);
a1916 9
debug_to_disconnect (char *args, int from_tty)
{
  debug_target.to_disconnect (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_disconnect (%s, %d)\n",
		      args, from_tty);
}

static void
a2521 1
  current_target.to_disconnect = debug_to_disconnect;
a2568 1

@


1.118.4.1
log
@2006-05-02  Michael Snyder  <msnyder@@redhat.com>

	* Target interface for reverse execution.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	* target.c (target_get_execdir): New generic method.
	(target_set_execdir): Ditto.
	* remote.c (remote_get_execdir, remote_set_execdir): New methods.
	(remote_vcont_resume): Jump out if attempting reverse execution.
	(remote_resume): Check for reverse exec direction, and send
	appropriate command to target.
	(remote_wait): Check target response for NO_HISTORY status.
	Also check for empty reply (target doesn't understand "bs" or "bc).
	(_initialize_remote): Add new methods to remote target vector.
@
text
@a459 2
      /* Do not inherit to_get_execdir.  */
      /* Do not inherit to_set_execdir.  */
a1504 55
   support reverse execution.  */

enum exec_direction_kind
target_get_execdir (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_get_execdir != NULL)
	{
	  enum exec_direction_kind retval = t->to_get_execdir ();
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "%s->to_get_execdir () = %s\n",
				t->to_shortname, 
				retval == EXEC_FORWARD ? "Forward" :
				retval == EXEC_REVERSE ? "Reverse" :
				retval == EXEC_ERROR   ? "Error"   :
				"*unknown*");
	  return retval;
	}
    }

  if (targetdebug)
    fprintf_unfiltered (gdb_stdlog, "target_get_execdir: unsupported\n");
  return EXEC_ERROR;
}

enum exec_direction_kind
target_set_execdir (enum exec_direction_kind setdir)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_set_execdir != NULL)
	{
	  enum exec_direction_kind retval = t->to_set_execdir (setdir);
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "%s->to_set_execdir () = %s\n",
				t->to_shortname, 
				retval == EXEC_FORWARD ? "Forward" :
				retval == EXEC_REVERSE ? "Reverse" :
				retval == EXEC_ERROR   ? "Error"   :
				"*unknown*");
	  return retval;
	}
    }

  if (targetdebug)
    fprintf_unfiltered (gdb_stdlog, "target_set_execdir: unsupported\n");
  return EXEC_ERROR;
}

/* Look through the list of possible targets for a target that can
@


1.117
log
@2006-03-16  Michael Snyder  <msnyder@@redhat.com>

	* target.c (push_target): Fix typo in comment.
@
text
@d114 1
a114 1
static int debug_to_insert_breakpoint (CORE_ADDR, gdb_byte *);
d116 1
a116 1
static int debug_to_remove_breakpoint (CORE_ADDR, gdb_byte *);
d120 1
a120 1
static int debug_to_insert_hw_breakpoint (CORE_ADDR, gdb_byte *);
d122 1
a122 1
static int debug_to_remove_hw_breakpoint (CORE_ADDR, gdb_byte *);
d518 1
a518 1
	    (int (*) (CORE_ADDR, gdb_byte *))
d521 1
a521 1
	    (int (*) (CORE_ADDR, gdb_byte *))
d2078 1
a2078 1
debug_to_insert_breakpoint (CORE_ADDR addr, gdb_byte *save)
d2082 1
a2082 1
  retval = debug_target.to_insert_breakpoint (addr, save);
d2086 1
a2086 1
		      (unsigned long) addr,
d2092 1
a2092 1
debug_to_remove_breakpoint (CORE_ADDR addr, gdb_byte *save)
d2096 1
a2096 1
  retval = debug_target.to_remove_breakpoint (addr, save);
d2100 1
a2100 1
		      (unsigned long) addr,
d2164 1
a2164 1
debug_to_insert_hw_breakpoint (CORE_ADDR addr, gdb_byte *save)
d2168 1
a2168 1
  retval = debug_target.to_insert_hw_breakpoint (addr, save);
d2172 1
a2172 1
		      (unsigned long) addr,
d2178 1
a2178 1
debug_to_remove_hw_breakpoint (CORE_ADDR addr, gdb_byte *save)
d2182 1
a2182 1
  retval = debug_target.to_remove_hw_breakpoint (addr, save);
d2186 1
a2186 1
		      (unsigned long) addr,
@


1.117.2.1
log
@2006-03-31  Michael Snyder  <msnyder@@redhat.com>

	Target interface for reverse execution.
	* target.h (enum target_waitkind):
	Add new wait event, TARGET_WAITKIND_NO_HISTORY.
	(enum exec_direction_kind): New enum.
	(struct target_ops): New methods to_set_execdir, to_get_execdir.
	(target_set_execution_direction): New macro.
	(target_get_execution_direction): New macro.
	* target.c (update_current_target): Inherit new execdir methods.
@
text
@a459 2
      INHERIT (to_get_execdir, t);
      INHERIT (to_set_execdir, t);
@


1.116
log
@	* breakpoint.c (TARGET_REGION_OK_FOR_HW_WATCHPOINT): Delete.
	* config/i386/nm-i386sol2.h (TARGET_REGION_OK_FOR_HW_WATCHPOINT): New.
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
	* config/mips/nm-irix5.h (TARGET_REGION_OK_FOR_HW_WATCHPOINT): New.
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
	* config/sparc/nm-sol2.h (TARGET_REGION_OK_FOR_HW_WATCHPOINT): New.
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
	* inf-ttrace.c (inf_ttrace_region_ok_for_hw_watchpoint): New.
	(inf_ttrace_region_size_ok_for_hw_watchpoint): Delete.
	(inf_ttrace_target): Delete to_region_size_ok_for_hw_watchpoint and
	add to_region_ok_for_hw_watchpoint.
	* s390-nat.c (s390_region_size_ok_for_hw_watchpoint): Delete.
	(s390_region_ok_for_hw_watchpoint): New.
	(_initialize_s390_nat): Delete to_region_size_ok_for_hw_watchpoint
	and add to_region_ok_for_hw_watchpoint.
	* target.c (default_region_size_ok_for_hw_watchpoint,
	debug_to_region_size_ok_for_hw_watchpoint): Delete prototype.
	(update_current_target): Delete to_region_size_ok_for_hw_watchpoint
	inheritance and default_region_size_ok_for_hw_watchpoint.
	(default_region_ok_for_hw_watchpoint): If len is less than or equal
	the length of void pointer, return ok.
	(default_region_size_ok_for_hw_watchpoint): Delete.
	(debug_to_region_size_ok_for_hw_watchpoint): Delete.
	(setup_target_debug): Delete to_region_size_ok_for_hw_watchpoint.
	* target.h (struct target_ops): Delete
	to_region_size_ok_for_hw_watchpoint.
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
@
text
@d678 1
a678 1
  /* FIXME: cagney/2003-10-15: I think this should be poping all
@


1.116.2.1
log
@Merge XML and VFP support to this branch.
@
text
@a459 1
      /* Do not inherit to_available_features.  */
a636 1
  current_target.to_available_features = NULL;
d1381 2
a1382 3
      if (xfer == 0)
	return xfered;
      if (xfer < 0)
d1403 2
a1404 3
      if (xfer == 0)
	return xfered;
      if (xfer < 0)
a1411 41
/* Perform a full target read of unknown size.  */

LONGEST
target_read_whole (struct target_ops *ops,
		   enum target_object object,
		   const char *annex, gdb_byte **buf_p)
{
  /* FIXME: Should we use the memory write size parameters for this
     too?  Or something at another level entirely?  */
  size_t buf_alloc = 32768, buf_pos = 0;
  gdb_byte *buf = xmalloc (buf_alloc);
  LONGEST n, total;

  total = 0;
  while (1)
    {
      n = target_read (ops, object, annex, &buf[buf_pos],
		       buf_pos, buf_alloc - buf_pos);
      if (n < 0)
	{
	  /* An error occurred.  */
	  xfree (buf);
	  return -1;
	}

      buf_pos += n;
      if (buf_pos < buf_alloc)
	{
	  /* Read all there was.  */
	  if (buf_pos == 0)
	    xfree (buf);
	  else
	    *buf_p = buf;
	  return buf_pos;
	}

      buf_alloc *= 2;
      buf = xrealloc (buf, buf_alloc);
    }
}

a1528 22
/* Look for a target which can report architectural features, starting
   from TARGET.  If we find one, return its features, using OBSTACK
   for any temporary allocation.  */

struct gdb_feature_set *
target_available_features (struct target_ops *target, struct obstack *obstack)
{
  struct target_ops *t;

  for (t = target; t != NULL; t = t->beneath)
    if (t->to_available_features != NULL)
      {
	struct gdb_feature_set *features;

	features = t->to_available_features (t, obstack);
	if (features)
	  return features;
      }

  return NULL;
}

@


1.116.2.1.2.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d114 1
a114 1
static int debug_to_insert_breakpoint (CORE_ADDR, struct bp_location *);
d116 1
a116 1
static int debug_to_remove_breakpoint (CORE_ADDR, struct bp_location *);
d120 1
a120 1
static int debug_to_insert_hw_breakpoint (CORE_ADDR, struct bp_location *);
d122 1
a122 1
static int debug_to_remove_hw_breakpoint (CORE_ADDR, struct bp_location *);
d519 1
a519 1
	    (int (*) (CORE_ADDR, struct bp_location *))
d522 1
a522 1
	    (int (*) (CORE_ADDR, struct bp_location *))
d2145 1
a2145 1
debug_to_insert_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d2149 1
a2149 1
  retval = debug_target.to_insert_breakpoint (addr, bpt);
d2159 1
a2159 1
debug_to_remove_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d2163 1
a2163 1
  retval = debug_target.to_remove_breakpoint (addr, bpt);
d2231 1
a2231 1
debug_to_insert_hw_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d2235 1
a2235 1
  retval = debug_target.to_insert_hw_breakpoint (addr, bpt);
d2245 1
a2245 1
debug_to_remove_hw_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d2249 1
a2249 1
  retval = debug_target.to_remove_hw_breakpoint (addr, bpt);
@


1.116.2.1.2.2
log
@Actually include patch, not just changelog.
@
text
@d100 2
d369 1
a369 1
void
d391 1
a391 1
      /* Do not inherit to_disconnect.  */
d487 3
d1538 1
a1538 13
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_disconnect != NULL)
	{
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "target_disconnect (%s, %d)\n",
				args, from_tty);
	  t->to_disconnect (t, args, from_tty);
	  return;
	}

  tcomplain ();
d1977 9
d2591 1
d2639 1
@


1.116.2.1.2.3
log
@No, really, check in the RIGHT patch!
[Revert half of changes from previous commit.]
@
text
@a99 2
static void debug_to_disconnect (char *, int);

d367 1
a367 1
static void
d389 1
a389 1
      INHERIT (to_disconnect, t);
a484 3
  de_fault (to_disconnect, 
	    (void (*) (char *, int)) 
	    tcomplain);
d1533 13
a1545 1
  (current_target.to_disconnect) (args, from_tty);
a1983 9
debug_to_disconnect (char *args, int from_tty)
{
  debug_target.to_disconnect (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_disconnect (%s, %d)\n",
		      args, from_tty);
}

static void
a2588 1
  current_target.to_disconnect = debug_to_disconnect;
a2635 1

@


1.116.2.1.2.4
log
@Add experimental support for SymbianOS-related protocol features.
@
text
@d100 2
d369 1
a369 1
void
d391 1
a391 1
      /* Do not inherit to_disconnect.  */
a460 1
      /* Do not inherit to_get_shared_libraries.  */
d487 3
d1538 1
a1538 13
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_disconnect != NULL)
	{
	  if (targetdebug)
	    fprintf_unfiltered (gdb_stdlog, "target_disconnect (%s, %d)\n",
				args, from_tty);
	  t->to_disconnect (t, args, from_tty);
	  return;
	}

  tcomplain ();
a1596 21
   fetch shared libraries.  */

void
target_get_shared_libraries (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (t->to_get_shared_libraries != NULL)
	{
	  t->to_get_shared_libraries (t);
	  break;
	}
    }

  if (targetdebug)
    fprintf_unfiltered (gdb_stdlog, "target_get_shared_libraries ()\n");
}

/* Look through the list of possible targets for a target that can
d1977 9
d2591 1
d2639 1
@


1.116.4.1
log
@Initial version of available features support.
@
text
@a459 1
      /* Do not inherit to_available_features.  */
a636 1
  current_target.to_available_features = NULL;
d1381 2
a1382 3
      if (xfer == 0)
	return xfered;
      if (xfer < 0)
d1403 2
a1404 3
      if (xfer == 0)
	return xfered;
      if (xfer < 0)
a1411 39
/* Perform a full target read of unknown size.  */

LONGEST
target_read_whole (struct target_ops *ops,
		   enum target_object object,
		   const char *annex, gdb_byte **buf_p)
{
  size_t buf_alloc = 512, buf_pos = 0;
  gdb_byte *buf = xmalloc (buf_alloc);
  LONGEST n, total;

  total = 0;
  while (1)
    {
      n = target_read (ops, object, annex, &buf[buf_pos],
		       buf_pos, buf_alloc - buf_pos);
      if (n < 0)
	{
	  /* An error occurred.  */
	  xfree (buf);
	  return -1;
	}

      buf_pos += n;
      if (buf_pos < buf_alloc)
	{
	  /* Read all there was.  */
	  if (buf_pos == 0)
	    xfree (buf);
	  else
	    *buf_p = buf;
	  return buf_pos;
	}

      buf_alloc *= 2;
      buf = xrealloc (buf, buf_alloc);
    }
}

a1528 22
/* Look for a target which can report architectural features, starting
   from TARGET.  If we find one, return its features, using OBSTACK
   for any temporary allocation.  */

struct gdb_feature_set *
target_available_features (struct target_ops *target, struct obstack *obstack)
{
  struct target_ops *t;

  for (t = target; t != NULL; t = t->beneath)
    if (t->to_available_features != NULL)
      {
	struct gdb_feature_set *features;

	features = t->to_available_features (t, obstack);
	if (features)
	  return features;
      }

  return NULL;
}

@


1.116.4.2
log
@Local changes to take full advantage of qPacketInfo
@
text
@d1423 1
a1423 3
  /* FIXME: Should we use the memory write size parameters for this
     too?  Or something at another level entirely?  */
  size_t buf_alloc = 32768, buf_pos = 0;
@


1.115
log
@	* ppc-linux-nat.c (PTRACE_GET_DEBUGREG, PTRACE_SET_DEBUGREG,
	PTRACE_GETSIGINFO): Define.
	(last_stopped_data_address): New.
	(ppc_linux_check_watch_resources): New function.
	(ppc_linux_region_ok_for_hw_watchpoint): New function.
	(ppc_linux_insert_watchpoint): New function.
	(ppc_linux_remove_watchpoint): New function.
	(ppc_linux_stopped_data_address): New function.
	(ppc_linux_stopped_by_watchpoint): New function.
	(_initialize_ppc_linux_nat): Set the above hardware watchpoint
	related target vectors.
	* rs6000-tdep.c (rs6000_gdbarch_init): Set PPC architectures
	to have nonsteppable watchpoint.
	* target.c (default_region_ok_for_hw_watchpoint,
	debug_to_region_ok_for_hw_watchpoint): New prototypes.
	(update_current_target): Inherit to_region_ok_for_hw_watchpoint
	and set default to_region_ok_for_hw_watchpoint.
	(default_region_ok_for_hw_watchpoint): New function.
	(debug_to_region_ok_for_hw_watchpoint): New function.
	(setup_target_debug): Set to_region_ok_for_hw_watchpoint of
	debug_target.
	* target.h (struct target_ops): Add a new target vector
	to_region_ok_for_hw_watchpoint.
	(TARGET_REGION_OK_FOR_HW_WATCHPOINT): Define this if it is not
	defined anyplace else.
@
text
@a52 2
static int default_region_size_ok_for_hw_watchpoint (int);

a133 2
static int debug_to_region_size_ok_for_hw_watchpoint (int);

a409 1
      INHERIT (to_region_size_ok_for_hw_watchpoint, t);
a536 2
  de_fault (to_region_size_ok_for_hw_watchpoint,
	    default_region_size_ok_for_hw_watchpoint);
d1584 1
a1584 7
  return TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT (len);
}

static int
default_region_size_ok_for_hw_watchpoint (int byte_count)
{
  return (byte_count <= TYPE_LENGTH (builtin_type_void_data_ptr));
a2136 14
debug_to_region_size_ok_for_hw_watchpoint (int byte_count)
{
  CORE_ADDR retval;

  retval = debug_target.to_region_size_ok_for_hw_watchpoint (byte_count);

  fprintf_unfiltered (gdb_stdlog,
		      "TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT (%ld) = 0x%lx\n",
		      (unsigned long) byte_count,
		      (unsigned long) retval);
  return retval;
}

static int
a2541 1
  current_target.to_region_size_ok_for_hw_watchpoint = debug_to_region_size_ok_for_hw_watchpoint;
@


1.114
log
@* target.h (target_read_memory_partial,	target_write_memory_partial):
Change second argument to 'gdb_byte *'.
* target.c (target_xfer_memory_partial): Change third argument to
'gdb_byte *'.
(target_read_memory_partial, target_write_memory_partial): Change
second argument to 'gdb_byte *'.
@
text
@d51 2
d134 2
d413 1
d540 2
d1589 6
d2135 15
d2568 1
@


1.113
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 2
a5 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d1183 1
a1183 1
target_xfer_memory_partial (CORE_ADDR memaddr, char *myaddr, int len,
d1244 2
a1245 1
target_read_memory_partial (CORE_ADDR memaddr, char *buf, int len, int *err)
d1273 2
a1274 1
target_write_memory_partial (CORE_ADDR memaddr, char *buf, int len, int *err)
d1427 1
a1427 1
  char buf[sizeof (ULONGEST)];
@


1.112
log
@gdb/ChangeLog:
2005-12-07  Jim Blandy  <jimb@@redhat.com>

	* target.c (target_xfer_memory_partial): Doc fix.
@
text
@d3 1
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.111
log
@	* inf-child.c (inf_child_follow_fork): Add OPS argument.
	* inf-ptrace.c (inf_ptrace_follow_fork): Likewise.
	* inf-ttrace.c (inf_ttrace_follow_fork): Likewise.
	* inftarg.c (child_follow_fork): Likewise.
	* linux-nat.c (child_follow_fork): Likewise.  Use ops instead of
	&deprecated_child_ops.
	* target.c (update_current_target): Do not inherit to_follow_fork.
	(target_follow_fork): New function.
	(debug_to_follow_fork): Remove.
	(setup_target_debug): Don't set to_follow_fork.
	* target.h (struct target_ops): Add struct target_ops * to
	to_follow_fork.
	(child_follow_fork): Add struct target_ops * argument.
	(target_follow_fork): Replace macro with prototype.
@
text
@d1178 2
a1179 1
   Result is -1 on error, or the number of bytes transfered.  */
@


1.110
log
@* target.c (normal_pid_to_str): Use xsnprintf instead of snprintf.
* bsd-uthread.c (bsd_uthread_pid_to_str): Likewise.
* inf-ttrace.c (inf_ttrace_pid_to_str): Likewise.
@
text
@d425 1
a425 1
      INHERIT (to_follow_fork, t);
a581 3
  de_fault (to_follow_fork,
	    (int (*) (int)) 
	    target_ignore);
d1501 25
a2360 11
static int
debug_to_follow_fork (int follow_child)
{
  int retval =  debug_target.to_follow_fork (follow_child);

  fprintf_unfiltered (gdb_stdlog, "target_follow_fork (%d) = %d\n",
		      follow_child, retval);

  return retval;
}

a2552 1
  current_target.to_follow_fork = debug_to_follow_fork;
@


1.109
log
@	* dwarf2-frame.c (dwarf2_frame_prev_register): Use gdb_byte.
	* i386-linux-nat.c (fetch_register, store_register, supply_gregset)
	(fill_gregset): Likewise.
	* i386-tdep.c (i386_frame_prev_register)
	(i386_sigtramp_frame_prev_register): Likewise.
	* linux-nat.c (linux_nat_xfer_memory, linux_nat_make_corefile_notes):
	Likewise.
	* linux-thread-db.c (thread_db_xfer_memory): Likewise.
	* remote.c (remote_insert_hw_breakpoint, remote_remove_hw_breakpoint):
	Likewise.
	* target.c (debug_to_insert_hw_breakpoint)
	(debug_to_remove_hw_breakpoint, update_current_target): Likewise.
@
text
@a1795 1
  int size;
d1797 1
a1797 2
  size = snprintf (buf, sizeof buf, "process %d", ptid_get_pid (ptid));
  gdb_assert (size < sizeof buf);
@


1.109.2.1
log
@2005-05-12  Michael Snyder  <msnyder@@redhat.com>

	* target.c (target_read_memory_trusted): New function.
	Implements 'trust-readonly-section'.
	(target_read_partial): Honor trust-readonly-section.
	(target_read_memory_partial): Ditto.
	(target_read_memory): Ditto.
	(do_xfer_memory): Ditto.
@
text
@a847 34
static int trust_readonly = 0;
static void
show_trust_readonly (struct ui_file *file, int from_tty,
		     struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, 
		    _("Mode for reading from readonly sections is %s.\n"),
		    value);
}

/* If trust-readonly-sections, and if MEMADDR is within a
   read-only section, read LEN bytes from the bfd at MEMADDR,
   placing the results in GDB's memory at MYADDR.  Returns
   the number of bytes read.  */

static int
target_read_memory_trusted (CORE_ADDR memaddr, char *myaddr, int len)
{
  struct section_table *secp;
  /* User-settable option, 'trust-readonly-sections'.  If true,
     then memory from any SEC_READONLY bfd section may be read
     directly from the bfd file.  */
  if (trust_readonly)
    {
      secp = target_section_by_addr (&current_target, memaddr);
      if (secp != NULL
	  && (bfd_get_section_flags (secp->bfd, secp->the_bfd_section)
	      & SEC_READONLY))
	return xfer_memory (memaddr, myaddr, len, 0, NULL, &current_target);
    }

  return 0;
}

a1001 6
  int ret;

  /* Honor 'trust-readonly-sections' if set.  */
  if ((ret = target_read_memory_trusted (memaddr, myaddr, len)) > 0)
    return (ret != len);

d1036 10
a1062 5
  /* Honor 'trust-readonly-sections' if set.  */
  if (!write && 
      (res = target_read_memory_trusted (memaddr, myaddr, len)) > 0)
	return res;

d1067 13
a1246 6
  int retval;

  /* Honor 'trust-readonly-sections' if set.  */
  if ((retval = target_read_memory_trusted (memaddr, buf, len)) > 0)
    return retval;

d1249 2
a1353 7
  int ret;

  /* Honor 'trust-readonly-sections' if set.  */
  if (object == TARGET_OBJECT_MEMORY)
    if ((ret = target_read_memory_trusted (offset, buf, len)) > 0)
      return ret;

@


1.109.2.2
log
@2005-06-03  Michael Snyder  <msnyder@@redhat.com>

	* tracepoint.c, remote.c, target.c, target.h, etc.:
	Begin moving tracepoint methods into the target vector,
	and migrating some of the remote protocol stuff from
	tracepoint.c into remote.c.
@
text
@a40 1
#include "tracepoint.h"
a458 4
      INHERIT (to_start_tracepoints, t);
      INHERIT (to_stop_tracepoints, t);
      INHERIT (to_tracepoint_status, t);
     
a638 10
  de_fault (to_start_tracepoints, 
	    (int (*) (char *, int))
	    return_zero);
  de_fault (to_stop_tracepoints, 
	    (int (*) (char *, int))
	    return_zero);
  de_fault (to_tracepoint_status, 
	    (int (*) (char *, int))
	    return_zero);

a1849 30
/* Generic fallback method for tracepoints: start tracepoint experiment.  */
static int
default_start_tracepoints (char *args, int from_tty)
{
  if (info_verbose)
    fprintf_unfiltered (gdb_stdout, "default to_start_tracepoints\n");

  return trace_default_start (args, from_tty);
}

/* Generic fallback method for tracepoints: stop tracepoint experiment.  */
static int
default_stop_tracepoints (char *args, int from_tty)
{
  if (info_verbose)
    fprintf_unfiltered (gdb_stdout, "default to_stop_tracepoints\n");

  return trace_default_stop (args, from_tty);
}

/* Generic fallback method for tracepoints: tracepoint experiment status.  */
static int
default_tracepoint_status (char *args, int from_tty)
{
  if (info_verbose)
    fprintf_unfiltered (gdb_stdout, "default to_tracepoint_status\n");

  return trace_default_status (args, from_tty);
}

a1865 3
  dummy_target.to_start_tracepoints = default_start_tracepoints;
  dummy_target.to_stop_tracepoints = default_stop_tracepoints;
  dummy_target.to_tracepoint_status = default_tracepoint_status;
a2532 30
static int
debug_to_start_tracepoints (char *args, int from_tty)
{
  int ret = debug_target.to_start_tracepoints (args, from_tty);

  fprintf_unfiltered (gdb_stdout, 
		      "target to_start_tracepoints returns %d\n", ret);
  return ret;
}

static int
debug_to_stop_tracepoints (char *args, int from_tty)
{
  int ret = debug_target.to_stop_tracepoints (args, from_tty);

  fprintf_unfiltered (gdb_stdout, 
		      "target to_stop_tracepoints returns %d\n", ret);
  return ret;
}

static int
debug_to_tracepoint_status (char *args, int from_tty)
{
  int ret = debug_target.to_tracepoint_status (args, from_tty);

  fprintf_unfiltered (gdb_stdout, 
		      "target to_tracepoint_status returns %d\n", ret);
  return ret;
}

a2592 4
  current_target.to_start_tracepoints = debug_to_start_tracepoints;
  current_target.to_stop_tracepoints  = debug_to_stop_tracepoints;
  current_target.to_tracepoint_status = debug_to_tracepoint_status;

@


1.108
log
@* corelow.c (core_xfer_partial): Change type of readbuf and
writebuf to `gdb_byte *'.
* sparc-nat.c (sparc_xfer_wcookie, sparc_xfer_partial): Change
type of readbuf and writebuf to `gdb_byte *'.
* bsd-uthread.c (bsd_uthread_xfer_partial): Change type of readbuf
and writebuf to `gdb_byte *'.
* inf-ptrace.c (inf_ptrace_xfer_partial): Change type of readbuf
and writebuf to `gdb_byte *'.
* bsd-kvm.c (bsd_kvm_xfer_memory): Replace.
(bsd_kvm_xfer_partial): New function.
(bsd_kvm_add_target): Set to_xfer_partial instead of
to_xfer_memory.
* bfd-target.c (target_bfd_xfer_partial): Change type of readbuf
and writebuf to `gdb_byte *'.
* target.c (deprecated_debug_xfer_memory): Remove prototype.
(deprecated_debug_xfer_memory): Change type of second argument to
`gdb_byte *'.
* remote.c (remote_xfer_memory): Remove prototype.
(remote_xfer_memory): Change type of second argument to `gdb_byte
*'.
(remote_xfer_partial): Change type of readbuf and writebuf to
`gdb_byte *'.
@
text
@d119 1
a119 1
static int debug_to_insert_hw_breakpoint (CORE_ADDR, char *);
d121 1
a121 1
static int debug_to_remove_hw_breakpoint (CORE_ADDR, char *);
d517 1
a517 1
	    (int (*) (CORE_ADDR, char *))
d520 1
a520 1
	    (int (*) (CORE_ADDR, char *))
d2139 1
a2139 1
debug_to_insert_hw_breakpoint (CORE_ADDR addr, char *save)
d2153 1
a2153 1
debug_to_remove_hw_breakpoint (CORE_ADDR addr, char *save)
@


1.107
log
@2005-05-16  Andrew Cagney  <cagney@@gnu.org>

	* target.h (target_read_partial, target_write_partial)
	(do_xfer_memory, xfer_memory, target_read, target_write)
	(get_target_memory): For buffers, change "void*" to gdb_byte.
	(struct target_ops): Ditto for to_xfer_partial and
	deprecated_xfer_memory.
	* dcache.h (dcache_xfer_memory): Ditto.
	* target.c (default_xfer_partial, target_read_partial)
	(target_write_partial, target_read, target_write)
	(do_xfer_memory, update_current_target, get_target_memory): Update.
	(target_read_string): Change buf to a gdb_byte.
	* dcache.c (dcache_xfer_memory): Update.
	* exec.c (xfer_memory): Make buffer type to gdb_byte.
	* mem-break.c (default_memory_insert_breakpoint): Remove cast.
	* disasm.c (dis_asm_read_memory): Remove cast, use gdb_byte.
@
text
@a110 4
static int deprecated_debug_xfer_memory (CORE_ADDR, char *, int, int,
					 struct mem_attrib *,
					 struct target_ops *);

d2005 1
a2005 1
deprecated_debug_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
@


1.106
log
@2005-05-09  Andrew Cagney  <cagney@@gnu.org>

	Use gdb_byte in preference to bfd_byte.
	* gdbarch.sh: Update.
	* gdbarch.h, gdbarch.c: Re-generate.
	* ada-lang.c, ada-lang.h, ada-valprint.c, arch-utils.c: Update.
	* c-lang.c, c-lang.h, c-valprint.c, cp-valprint.c: Update.
	* f-lang.c, f-lang.h, f-valprint.c, gdbcore.h, jv-lang.h: Update.
	* jv-valprint.c, language.c, language.h, m2-lang.c: Update.
	* m2-lang.h, m2-valprint.c, objc-lang.c, p-lang.c: Update.
	* p-lang.h, p-valprint.c, regcache.c, scm-lang.c: Update.
	* scm-lang.h, scm-valprint.c, target.c, target.h: Update.
	* tramp-frame.c, valarith.c, valops.c, valprint.c: Update.
	* valprint.h, value.c, value.h: Update.
@
text
@d74 2
a75 2
				     const char *annex, void *readbuf,
				     const void *writebuf,
d84 1
a84 1
static int target_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
d508 1
a508 1
	    (int (*) (CORE_ADDR, char *, int, int, struct mem_attrib *, struct target_ops *)) 
d774 1
a774 1
  char buf[4];
d793 1
a793 1
      errcode = target_read_memory (memaddr & ~3, buf, 4);
d1056 1
a1056 1
do_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
d1117 1
a1117 1
target_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write)
d1154 1
a1154 1
				     reg_len, write);
d1308 2
a1309 2
		      const char *annex, void *readbuf, 
		      const void *writebuf, ULONGEST offset, LONGEST len)
d1355 1
a1355 1
		     const char *annex, void *buf,
d1364 1
a1364 1
		      const char *annex, const void *buf,
d1374 1
a1374 1
	     const char *annex, void *buf,
d1396 1
a1396 1
	      const char *annex, const void *buf,
d1418 1
a1418 1
get_target_memory (struct target_ops *ops, CORE_ADDR addr, void *buf,
@


1.105
log
@* target.h (target_link): Remove prototype.
* target.c (target_link): Remove function.
* symfile.c: Remove comment about rombug.
@
text
@d117 1
a117 1
static int debug_to_insert_breakpoint (CORE_ADDR, bfd_byte *);
d119 1
a119 1
static int debug_to_remove_breakpoint (CORE_ADDR, bfd_byte *);
d969 1
a969 1
	    readbuf = (bfd_byte *) readbuf + xfered;
d971 1
a971 1
	    writebuf = (bfd_byte *) writebuf + xfered;
d1004 1
a1004 1
target_read_memory (CORE_ADDR memaddr, bfd_byte *myaddr, int len)
d1014 1
a1014 1
target_write_memory (CORE_ADDR memaddr, const bfd_byte *myaddr, int len)
d1016 1
a1016 1
  bfd_byte *bytes = alloca (len);
d1381 1
a1381 1
					  (bfd_byte *) buf + xfered,
d1403 1
a1403 1
					   (bfd_byte *) buf + xfered,
d2058 1
a2058 1
debug_to_insert_breakpoint (CORE_ADDR addr, bfd_byte *save)
d2072 1
a2072 1
debug_to_remove_breakpoint (CORE_ADDR addr, bfd_byte *save)
@


1.104
log
@2005-05-01  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_extract_return_value)
	(breakpoint_from_pc, deprecated_store_return_value)
	(memory_insert_breakpoint, memory_remove_breakpoint): Change type
	of buffer to a bfd_byte pointer.
	* gdbarch.h, gdbarch.c: Re-generate.
	* mem-break.c (memory_insert_breakpoint)
	(memory_remove_breakpoint, default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Update.
	* target.h (memory_insert_breakpoint)
	(memory_remove_breakpoint, default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Update declarations.
	(struct target_ops): Update to_insert_breakpoint and
	to_remove_breakpoint.
	* target.c (debug_to_remove_breakpoint)
	(debug_to_insert_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_remove_breakpoint)
	(m32r_insert_breakpoint): Update.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Update.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Update.
	* remote-rdi.c (arm_rdi_insert_breakpoint)
	(arm_rdi_remove_breakpoint): Update.
	* remote-sim.c (gdbsim_insert_breakpoint)
	(gdbsim_remove_breakpoint): Update.
	* exec.c (ignore): Update.
	* rs6000-tdep.c (rs6000_extract_return_value): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Update.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Update.
@
text
@a1498 13
void
target_link (char *modname, CORE_ADDR *t_reloc)
{
  if (DEPRECATED_STREQ (current_target.to_shortname, "rombug"))
    {
      (current_target.to_lookup_symbol) (modname, t_reloc);
      if (*t_reloc == 0)
	error (_("Unable to link to %s and get relocation in rombug"), modname);
    }
  else
    *t_reloc = (CORE_ADDR) -1;
}

@


1.103
log
@* inf-ttrace.c (inf_ttrace_pid_to_str): Use snprintf instead of
sprintf.
* target.c (normal_pid_to_str): Likewise.
* remote.c (remote_pid_to_str): Use snprint instead of sprintf.
Change capitalization of "thread".  Use ptid_get_pid instead of
GETPID.
@
text
@d117 1
a117 1
static int debug_to_insert_breakpoint (CORE_ADDR, char *);
d119 1
a119 1
static int debug_to_remove_breakpoint (CORE_ADDR, char *);
d2071 1
a2071 1
debug_to_insert_breakpoint (CORE_ADDR addr, char *save)
d2085 1
a2085 1
debug_to_remove_breakpoint (CORE_ADDR addr, char *save)
@


1.102
log
@	* target.c (target_read_memory_partial): Always initialize
	ERR.
	(target_write_memory_partial): Likewise.
@
text
@d1806 2
a1807 2
/* Convert a normal process ID to a string.  Returns the string in a static
   buffer.  */
d1812 2
a1813 1
  static char buf[30];
d1815 2
a1816 1
  sprintf (buf, "process %d", PIDGET (ptid));
@


1.101
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1252 20
a1271 2
    return target_xfer_partial (target_stack, TARGET_OBJECT_MEMORY, NULL,
				buf, NULL, memaddr, len);
d1280 20
a1299 2
    return target_xfer_partial (target_stack, TARGET_OBJECT_MEMORY, NULL,
				NULL, buf, memaddr, len);
@


1.100
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_zinteger_cmd through out.  Re-sync gdbarch.sh
	and gdbarch.c.
	* breakpoint.c, frame.c, gdb-events.sh, gdbarch.sh: Update.
	* gdbtypes.c, infrun.c, linux-nat.c, maint.c, monitor.c: Update.
	* pa64solib.c, parse.c, remote-mips.c, ser-go32.c: Update.
	* serial.c, solib-frv.c, somsolib.c, target.c, top.c: Update.
	* varobj.c, cli/cli-cmds.c: Update.
	* gdbarch.c, gdb-events.c: Regenerate.
@
text
@d206 6
d1041 8
d2576 1
a2576 1
			    NULL, /* FIXME: i18n: */
d2587 1
a2587 1
			   NULL, /* FIXME: i18n: Mode for reading from readonly sections is %s.  */
@


1.99
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d2555 3
a2557 4
  deprecated_add_show_from_set 
    (add_set_cmd ("target", class_maintenance, var_zinteger,
		  (char *) &targetdebug,
		  "Set target debugging.\n\
d2560 4
a2563 2
command.", &setdebuglist),
     &showdebuglist);
@


1.98
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d2571 1
a2572 1
			   NULL, NULL,
@


1.97
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_setshow functions, replace "PRINT:" comment prefix
	with "FIXME: i18n:".
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* cris-tdep.c, dwarf2read.c, frame.c, hppa-tdep.c: Update.
	* infcall.c, m32r-rom.c, maint.c, mips-tdep.c: Update.
	* nto-tdep.c, observer.c, remote-rdi.c, remote.c: Update.
	* target.c, cli/cli-logging.c: Update.
@
text
@d245 2
a246 2
    add_prefix_cmd ("target", class_run, target_command,
		    "Connect to a target machine or process.\n\
d250 1
a250 1
`help target ' followed by the protocol name.",
d2576 1
a2576 1
	   "Send a command to the remote monitor (remote targets only).");
@


1.96
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d2565 3
a2567 3
			   &trust_readonly, "\
Set mode for reading from readonly sections.", "\
Show mode for reading from readonly sections.", "\
d2570 2
a2571 2
result in significant performance improvement for remote targets.",
			   NULL, /* PRINT: Mode for reading from readonly sections is %s.  */
@


1.95
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d309 1
a309 1
  printf_unfiltered ("No saved terminal information.\n");
d322 1
a322 1
      printf_unfiltered ("You are already running a program:\n");
d1394 1
a1394 1
    printf_unfiltered ("Symbols from \"%s\".\n", symfile_objfile->name);
d1404 1
a1404 1
	printf_unfiltered ("\tWhile running this, GDB does not access memory from...\n");
@


1.94
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d667 1
a667 1
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
d752 1
a752 1
  internal_error (__FILE__, __LINE__, "failed internal consistency check");
d1422 1
a1422 1
          || query ("A program is being debugged already.  Kill it? "))
@


1.93
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd, add_setshow_cmd_full)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Replace
	print string parameter with fprint_setshow function.
	* command.h (fprint_setshow_ftype): Define.  Update declarations.
	* cli/cli-setshow.c (do_setshow_command): When fprint_setshow is
	available, use that.
	* cli/cli-decode.h (struct cmd_list_element): Add field
	fprint_setshow.
	* complaints.c (fprint_setshow_complaints): New function.
	(_initialize_complaints): Pass to add_setshow_zinteger_cmd.
	* hppa-tdep.c (_initialize_hppa_tdep): Replace "print" parameter
	with NULL.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* cris-tdep.c (_initialize_cris_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* target.c (initialize_targets): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* breakpoint.c (_initialize_breakpoint): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
@
text
@d280 1
a280 1
  error ("You can't do that when your target is `%s'",
d287 1
a287 1
  error ("You can't do that without a process to debug.");
d302 1
a302 1
    error ("No run-time support for this");
d328 1
a328 1
	    error ("Killing the program did not help.");
d333 1
a333 1
	  error ("Program not killed.");
d1425 1
a1425 1
	error ("Program not killed.");
d1456 1
a1456 1
	error ("Unable to link to %s and get relocation in rombug", modname);
d1496 1
a1496 1
    error ("Don't know how to %s.  Try \"help target\".", do_mesg);
d1771 1
a1771 1
  error ("No target.");
d1778 1
a1778 1
  error ("No target.");
d2542 1
a2542 3
    {
      error ("\"monitor\" command not supported by this target.\n");
    }
@


1.92
log
@2005-01-27  Andrew Cagney  <cagney@@gnu.org>

	* symfile-mem.c (do_target_read_memory): New function.
	(symbol_file_add_from_memory): Pass do_target_read_memory to
	bfd_elf_bfd_from_remote_memory.
	* corefile.c (write_memory): Update, make a copy of the read-only
	buffer.
	* target.c (target_read_memory): Update.
	(target_write_memory): Update, make a copy of the read-only
	buffer.
	* gdbcore.h (write_memory): Change buffer type to bfd_byte, make
	const.
	* target.h (target_read_memory, target_write_memory): Change
	buffer type to bfd_byte; for write_memory, make it const.
@
text
@d2572 2
a2573 2
result in significant performance improvement for remote targets.", "\
Mode for reading from readonly sections is %s.",
@


1.91
log
@2005-01-18  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Change return type of
	to_insert_fork_catchpoint, to_insert_vfork_catchpoint and
	to_insert_exec_catchpoint to void.
	(child_insert_fork_catchpoint, child_insert_vfork_catchpoint)
	(child_insert_exec_catchpoint): Change return type to void.
	* target.c (update_current_target): Update.
	(debug_to_insert_fork_catchpoint)
	(debug_to_insert_vfork_catchpoint)
	(debug_to_insert_exec_catchpoint): Update.
	* inf-child.c (inf_child_insert_fork_catchpoint)
	(inf_child_insert_vfork_catchpoint)
	(inf_child_insert_exec_catchpoint): Update.
	* breakpoint.c (insert_catchpoint): Update, do not throw an error.
	* linux-nat.c (child_insert_fork_catchpoint)
	(child_insert_vfork_catchpoint)
	(child_insert_exec_catchpoint): Update.
	* inftarg.c (child_insert_fork_catchpoint)
	(child_insert_vfork_catchpoint,)
	(child_insert_exec_catchpoint): Update.
@
text
@d998 1
a998 1
target_read_memory (CORE_ADDR memaddr, char *myaddr, int len)
d1008 1
a1008 1
target_write_memory (CORE_ADDR memaddr, char *myaddr, int len)
d1010 2
d1014 1
a1014 1
			       memaddr, len, NULL, myaddr);
d1016 1
a1016 1
    return target_xfer_memory (memaddr, myaddr, len, 1);
@


1.90
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d569 1
a569 1
	    (int (*) (int)) 
d575 1
a575 1
	    (int (*) (int)) 
d584 1
a584 1
	    (int (*) (int)) 
d2260 1
a2260 1
static int
d2263 1
a2263 1
  int retval;
d2265 2
a2266 6
  retval = debug_target.to_insert_fork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_insert_fork_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
d2282 1
a2282 1
static int
d2285 1
a2285 1
  int retval;
d2287 2
a2288 6
  retval = debug_target.to_insert_vfork_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_insert_vfork_catchpoint (%d)= %d\n",
		      pid, retval);

  return retval;
d2315 1
a2315 1
static int
d2318 1
a2318 1
  int retval;
d2320 2
a2321 6
  retval = debug_target.to_insert_exec_catchpoint (pid);

  fprintf_unfiltered (gdb_stdlog, "target_insert_exec_catchpoint (%d) = %d\n",
		      pid, retval);

  return retval;
@


1.89
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.c (debug_target): Move to near start of file.
	(target_stopped_data_address_p): Re-org logic, add casts.
@
text
@d111 3
a113 2
static int debug_to_xfer_memory (CORE_ADDR, char *, int, int,
				 struct mem_attrib *, struct target_ops *);
d394 1
a394 1
      INHERIT (to_xfer_memory, t);
d501 1
a501 1
  de_fault (to_xfer_memory, 
d1051 2
a1052 2
  /* to_xfer_memory is not guaranteed to set errno, even when it returns
     0.  */
d1069 1
a1069 1
  res = current_target.to_xfer_memory
d1080 1
a1080 1
	  res = t->to_xfer_memory (memaddr, myaddr, len, write, attrib, t);
d1260 3
a1262 3
      && ops->to_xfer_memory != NULL)
    /* If available, fall back to the target's "to_xfer_memory"
       method.  */
d1271 2
a1272 2
	  xfered = ops->to_xfer_memory (offset, buffer, len, 1/*write*/, NULL,
					ops);
d1276 2
a1277 2
	xfered = ops->to_xfer_memory (offset, readbuf, len, 0/*read*/, NULL,
				      ops);
d1281 2
a1282 2
	/* "to_xfer_memory" uses 0, cross checked against ERRNO as one
           indication of an error.  */
d1968 3
a1970 3
debug_to_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		      struct mem_attrib *attrib,
		      struct target_ops *target)
d1974 2
a1975 2
  retval = debug_target.to_xfer_memory (memaddr, myaddr, len, write,
					attrib, target);
d2491 1
a2491 1
  current_target.to_xfer_memory = debug_to_xfer_memory;
@


1.88
log
@
2004-10-08  Jeff Johnston  <jjohnstn@@redhat.com>

        * target.h (to_stopped_data_address): Change prototype to
        take a CORE_ADDR pointer and return an int.
        * target.c (update_current_target): Change to_stopped_data_address
        to match new prototype.
        (debug_to_stopped_data_address): Change appropriately.
        * breakpoint.c (bpstat_stop_status): Change call to
        target_stopped_data_address to use new prototype.
        * frv-tdep.c (frv_have_stopped_data_address): New function.
        (frv_stopped_data_address): Change to new prototype and
        functionality.
        * ia64-linux-nat.c (ia64_stopped_data_address): Change to new
        prototype and functionality.
        (ia64_stopped_by_watchpoint): New function.
        * i386-nat.c (i386_stopped_data_address): Change to new
        prototype and functionality.
        (i386_stopped_by_watchpoint): New function.
        * remote.c (remote_stopped_data_address): Change to new prototype
        and functionality.
        * remote-m32r-sdi.c (m32r_stopped_data_address): Ditto.
        * config/frv/tm-frv.h (frv_stopped_data_address): Change prototype.
        (STOPPED_BY_WATCHPOINT): Change to use frv_have_stopped_data_address.
        * config/i386/nm-i386.h (STOPPED_BY_WATCHPOINT): Change to use
        new i386_stopped_by_watchpoint function.
        (i386_stopped_by_watchpoint): New prototype.
        (i386_stoppped_data_address): Change to new prototype.
        * config/ia64/nm-linux.h (STOPPED_BY_WATCHPOINT): Change to use
        new ia64_stopped_by_watchpoint function.
        (ia64_stopped_by_watchpoint): New prototype.
        (ia64_stopped_data_address): Ditto.
@
text
@d89 2
d1020 2
a1021 3
  if (target->to_stopped_data_address == return_zero
      || (target->to_stopped_data_address == debug_to_stopped_data_address
	  && debug_target.to_stopped_data_address == return_zero))
d1023 5
a1027 2
  else
    return 1;
a1797 3

static struct target_ops debug_target;

@


1.87
log
@2004-10-05  Andrew Cagney  <cagney@@gnu.org>

	* target.h (deprecated_child_ops): Rename child_ops.
	* wince.c: Update copyright.  Rename child_ops.
	* win32-nat.c: Rename child_ops.
	* target.c: Rename child_ops.
	* rs6000-nat.c: Rename child_ops.
	* linux-nat.c: Rename child_ops.
	* infttrace.c: Rename child_ops.
	* inftarg.c: Rename child_ops.
	* infptrace.c: Rename child_ops.
	* hppah-nat.c: Update copyright.  Rename child_ops.
	* hpux-thread.c: Update copyright.  Rename child_ops.
@
text
@d130 1
a130 1
static CORE_ADDR debug_to_stopped_data_address (void);
d527 1
a527 1
	    (CORE_ADDR (*) (void))
d1014 13
d2085 2
a2086 2
static CORE_ADDR
debug_to_stopped_data_address (void)
d2088 1
a2088 1
  CORE_ADDR retval;
d2090 1
a2090 1
  retval = debug_target.to_stopped_data_address ();
d2093 3
a2095 2
		      "target_stopped_data_address () = 0x%lx\n",
		      (unsigned long) retval);
@


1.86
log
@2004-10-01  Andrew Cagney  <cagney@@gnu.org>

	* target.c (xfer_using_stratum): Change return type to LONGEST.
	On each iteration offset, readbuf and writebuf.
	* inf-ptrace.c (inf_ptrace_xfer_partial): Simplify computation of
	partial_length, and read/modify/write predicate, update comments.
	Pass buffer.word to ptrace write.
@
text
@d166 1
a166 1
struct target_ops child_ops;
@


1.85
log
@2004-09-30  Andrew Cagney  <cagney@@gnu.org>

	* target.c (target_xfer_partial): New function.
	(target_read_memory_partial, target_write_memory_partial)
	(default_xfer_partial, target_read_partial, target_write_partial)
	(xfer_using_stratum): Use.
	(debug_to_xfer_partial): Delete function.
	(setup_target_debug): Do not override to_xfer_partial.
@
text
@d930 1
a930 1
static int
d932 1
a932 1
		    CORE_ADDR memaddr, int len, void *readbuf,
d949 1
a949 1
				    readbuf, writebuf, memaddr, len);
d958 5
@


1.84
log
@2004-09-30  Andrew Cagney  <cagney@@gnu.org>

	* inf-ptrace.c (inf_ptrace_target): Do not set to_xfer_memory.
	(inf_ptrace_xfer_memory): Delete.
	* target.c (target_xfer_partial_p, xfer_using_stratum): New.
	(target_read_memory, target_write_memory): Use xfer_using_stratum
	when target_xfer_partial_p.
	(debug_target): Move to start of file.
	(target_read_memory_partial, target_write_memory_partial): Use
	to_xfer_partial when target_xfer_partial_p.
@
text
@d852 53
d948 2
a949 2
      xfered = target->to_xfer_partial (target, object, annex,
					readbuf, writebuf, memaddr, len);
d1213 2
a1214 3
    return target_stack->to_xfer_partial (target_stack,
					  TARGET_OBJECT_MEMORY, NULL,
					  buf, NULL, memaddr, len);
d1223 2
a1224 3
    return target_stack->to_xfer_partial (target_stack,
					  TARGET_OBJECT_MEMORY, NULL,
					  NULL, buf, memaddr, len);
d1265 2
a1266 2
    return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					  readbuf, writebuf, offset, len);
d1283 1
a1283 2
  gdb_assert (ops->to_xfer_partial != NULL);
  return ops->to_xfer_partial (ops, object, annex, buf, NULL, offset, len);
d1292 1
a1292 2
  gdb_assert (ops->to_xfer_partial != NULL);
  return ops->to_xfer_partial (ops, object, annex, NULL, buf, offset, len);
a2412 19
static LONGEST
debug_to_xfer_partial (struct target_ops *ops, enum target_object object,
		       const char *annex, void *readbuf, const void *writebuf,
		       ULONGEST offset, LONGEST len)
{
  LONGEST retval;

  retval = debug_target.to_xfer_partial (&debug_target, object, annex,
					 readbuf, writebuf, offset, len);

  fprintf_unfiltered (gdb_stdlog,
		      "target_xfer_partial (%d, %s, 0x%lx,  0x%lx,  0x%s, %s) = %s\n",
		      (int) object, (annex ? annex : "(null)"),
		      (long) readbuf, (long) writebuf, paddr_nz (offset),
		      paddr_d (len), paddr_d (retval));

  return retval;
}

a2508 1
  current_target.to_xfer_partial = debug_to_xfer_partial;
@


1.83
log
@2004-09-30  Andrew Cagney  <cagney@@gnu.org>

	* target.c (target_read_string): Use target_read_memory instead of
	target_xfer_memory.
@
text
@d843 83
d939 5
a943 1
  return target_xfer_memory (memaddr, myaddr, len, 0);
d949 5
a953 1
  return target_xfer_memory (memaddr, myaddr, len, 1);
d1159 6
a1164 1
  return target_xfer_memory_partial (memaddr, buf, len, 0, err);
d1170 6
a1175 1
  return target_xfer_memory_partial (memaddr, buf, len, 1, err);
@


1.82
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Delete field to_post_wait.
	(target_post_wait): Delete macro.
	(child_post_wait): Delete declaration.
	* target.c (update_current_target, update_current_target)
	(debug_to_post_wait, setup_target_debug): Delete functions and
	references.
	* infttrace.c (ptrace_wait): Delete call to target_post_wait.
	* inftarg.c (child_post_wait): Delete.
	(init_child_ops): Do not set to_post_wait.
	* infptrace.c (ptrace_wait): Delete call to target_post_wait.
	* inf-ptrace.c (inf_ptrace_wait): Delete call to target_post_wait.
	* inf-child.c (inf_child_post_wait): Delete.
	(inf_child_target): Do not set to_post_wait.
	* inf-ptrace.c (inf_ptrace_post_wait): Delete.
	(inf_ptrace_target): Do not set to_post_wait.
@
text
@d784 1
a784 1
      errcode = target_xfer_memory (memaddr & ~3, buf, 4, 0);
d792 1
a792 1
	  errcode = target_xfer_memory (memaddr, buf, 1, 0);
@


1.81
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* target.h (child_ops): Declare.
	* inftarg.c (child_ops): Move from here ...
	* target.c (child_ops): ... to here.
	* wince.c (child_ops): Delete extern declaration.
	* win32-nat.c (child_ops): Delete extern declaration.
	* linux-nat.c (child_ops): Delete extern declaration.
	* hpux-thread.c (child_ops): Delete extern declaration.
@
text
@a387 1
      INHERIT (to_post_wait, t);
a488 3
  de_fault (to_post_wait, 
	    (void (*) (ptid_t, int)) 
	    target_ignore);
a1745 9
debug_to_post_wait (ptid_t ptid, int status)
{
  debug_target.to_post_wait (ptid, status);

  fprintf_unfiltered (gdb_stdlog, "target_post_wait (%d, %d)\n",
		      PIDGET (ptid), status);
}

static void
a2335 1
  current_target.to_post_wait = debug_to_post_wait;
@


1.80
log
@2004-09-12  Andrew Cagney  <cagney@@gnu.org>

	* target.c (target_info): Delete #ifdef call to FILES_INFO_HOOK.

Index: doc/ChangeLog
2004-09-12  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Native Debugging): Delete description of
	FILES_INFO_HOOK.
@
text
@d162 6
@


1.79
log
@        * target.c (target_resize_to_sections): Check
        current_target.to_sections for an old value when updating.
@
text
@a1218 5
#ifdef FILES_INFO_HOOK
  if (FILES_INFO_HOOK ())
    return;
#endif

@


1.78
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d1418 7
@


1.77
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_zinteger_cmd)
	(add_setshow_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_cmd_full): Add help_doc and
	print parameters.  Make string parameters constant.
	* command.h: Update.  Update copyright.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* complaints.c (_initialize_complaints): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* target.c (initialize_targets): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* d10v-tdep.c (_initialize_d10v_tdep): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
@
text
@d1765 1
a1765 1
      for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i++)
d1769 1
a1769 1
      if (DEPRECATED_REGISTER_RAW_SIZE (regno) <= sizeof (LONGEST))
@


1.76
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d2433 2
a2434 1
Set mode for reading from readonly sections.\n\
d2438 1
a2438 1
Show mode for reading from readonly sections.\n",
@


1.75
log
@2004-06-09  Andrew Cagney  <cagney@@gnu.org>

	* infptrace.c (child_xfer_memory) [CLEAR_INSN_CACHE]: Delete
	#ifdef CLEAR_INSN_CACHE code.
	* target.c (generic_mourn_inferior) [CLEAR_DEFERRED_STORES]:
	Delete #ifdef CLEAR_DEFERRED_STORES code.
@
text
@d2422 1
a2422 1
  add_show_from_set 
@


1.74
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@a1528 5
#ifdef CLEAR_DEFERRED_STORES
  /* Delete any pending stores to the inferior... */
  CLEAR_DEFERRED_STORES;
#endif

@


1.73
log
@2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* infrun.c (resume): Delete call to DO_DEFERRED_STORES.
	* target.c (target_detach, target_disconnect): Ditto.

2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	description of DO_DEFERRED_STORES.
@
text
@a43 2
static void maybe_kill_then_create_inferior (char *, char *, char **);

a151 2
static void debug_to_create_inferior (char *, char *, char **);

d338 2
a339 1
maybe_kill_then_create_inferior (char *exec, char *args, char **env)
d342 1
a342 1
  target_create_inferior (exec, args, env);
d1340 2
a1341 1
find_default_create_inferior (char *exec_file, char *allargs, char **env)
d1346 1
a1346 1
  (t->to_create_inferior) (exec_file, allargs, env);
d2072 2
a2073 1
debug_to_create_inferior (char *exec_file, char *args, char **env)
d2075 1
a2075 1
  debug_target.to_create_inferior (exec_file, args, env);
d2077 2
a2078 2
  fprintf_unfiltered (gdb_stdlog, "target_create_inferior (%s, %s, xxx)\n",
		      exec_file, args);
@


1.72
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@a1270 4
  /* Handle any optimized stores to the inferior.  */
#ifdef DO_DEFERRED_STORES
  DO_DEFERRED_STORES;
#endif
a1276 4
  /* Handle any optimized stores to the inferior.  */
#ifdef DO_DEFERRED_STORES
  DO_DEFERRED_STORES;
#endif
@


1.71
log
@	* target.c (debug_to_xfer_memory): If targetdebug is 1, don't
	print the whole transfer.
	(initialize_targets): Update description of "set debug target".
@
text
@d1554 2
a1555 2
  if (detach_hook)
    detach_hook ();
@


1.70
log
@	* target.c (default_region_size_ok_for_hw_watchpoint): Compare
	the region size against the size of a pointer, not the size of
	a register as given by DEPRECATED_REGISTER_SIZE.
@
text
@a1831 2


d1840 9
a1848 1
	    fprintf_unfiltered (gdb_stdlog, "\n");
d2440 3
a2442 1
When non-zero, target debugging is enabled.", &setdebuglist),
@


1.70.6.1
log
@Merge mainline to intercu branch.
@
text
@d1832 2
d1842 1
a1842 9
	    {
	      if (targetdebug < 2 && i > 0)
		{
		  fprintf_unfiltered (gdb_stdlog, " ...");
		  break;
		}
	      fprintf_unfiltered (gdb_stdlog, "\n");
	    }
	  
d2434 1
a2434 3
When non-zero, target debugging is enabled.  Higher numbers are more\n\
verbose.  Changes do not take effect until the next \"run\" or \"target\"\n\
command.", &setdebuglist),
@


1.70.6.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d44 2
d154 2
d342 1
a342 2
maybe_kill_then_create_inferior (char *exec, char *args, char **env,
				 int from_tty)
d345 1
a345 1
  target_create_inferior (exec, args, env, from_tty);
d1222 5
d1271 4
d1281 4
d1351 1
a1351 2
find_default_create_inferior (char *exec_file, char *allargs, char **env,
			      int from_tty)
d1356 1
a1356 1
  (t->to_create_inferior) (exec_file, allargs, env, from_tty);
a1427 7
      /* There is a flattened view of the target stack in current_target,
	 so its to_sections pointer might also need updating. */
      if (current_target.to_sections == old_value)
	{
	  current_target.to_sections = target->to_sections;
	  current_target.to_sections_end = target->to_sections_end;
	}
d1539 5
d1554 2
a1555 2
  if (deprecated_detach_hook)
    deprecated_detach_hook ();
d1780 1
a1780 1
      for (i = 0; i < register_size (current_gdbarch, regno); i++)
d1784 1
a1784 1
      if (register_size (current_gdbarch, regno) <= sizeof (LONGEST))
d2082 1
a2082 2
debug_to_create_inferior (char *exec_file, char *args, char **env,
			  int from_tty)
d2084 1
a2084 1
  debug_target.to_create_inferior (exec_file, args, env, from_tty);
d2086 2
a2087 2
  fprintf_unfiltered (gdb_stdlog, "target_create_inferior (%s, %s, xxx, %d)\n",
		      exec_file, args, from_tty);
d2436 1
a2436 1
  deprecated_add_show_from_set 
d2447 1
a2447 2
Set mode for reading from readonly sections.", "\
Show mode for reading from readonly sections.", "\
d2451 1
a2451 1
Mode for reading from readonly sections is %s.",
@


1.69
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* remote-sds.c (tohex): Delete unused function.  Update copyright.
	* xstormy16-tdep.c (xstormy16_register_virtual_size): Ditto.
	* v850-tdep.c (v850_register_virtual_size): Ditto.
	* target.c (normal_target_post_startup_inferior): Ditto.
	* source.c (ambiguous_line_spec): Ditto.
	* remote.c (adapt_remote_get_threadinfo): Ditto.
	* mi/mi-out.c (out_field_fmt): Ditto.
	* mi/mi-interp.c (mi_interp_read_one_line_hook): Ditto.
	(output_control_change_notification): Ditto.
	* m68k-tdep.c (m68k_register_byte): Ditto.
	(m68k_remote_breakpoint_from_pc): Ditto.
	* ui-out.c (init_ui_out_state): Delete unused declaration.
	* stabsread.c (search_value): Ditto.
	* mi/mi-cmd-env.c (env_cli_command): Ditto.
	* maint.c (print_section_table): Ditto.
	* infrun.c (set_follow_fork_mode_command): Ditto.
@
text
@d1363 1
a1363 1
  return (byte_count <= DEPRECATED_REGISTER_SIZE);
@


1.68
log
@2004-01-05  Andrew Cagney  <cagney@@redhat.com>

	* target.c (unpush_target): Only close a target that is in the
	target stack.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a73 2
static void normal_target_post_startup_inferior (ptid_t ptid);

a1601 18
}

/* Some targets (such as ttrace-based HPUX) don't allow us to request
   notification of inferior events such as fork and vork immediately
   after the inferior is created.  (This because of how gdb gets an
   inferior created via invoking a shell to do it.  In such a scenario,
   if the shell init file has commands in it, the shell will fork and
   exec for each of those commands, and we will see each such fork
   event.  Very bad.)

   This function is used by all targets that allow us to request
   notification of forks, etc at inferior creation time; e.g., in
   target_acknowledge_forked_child.
 */
static void
normal_target_post_startup_inferior (ptid_t ptid)
{
  /* This space intentionally left blank. */
@


1.67
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@a711 2
  target_close (t, 0);

d723 8
@


1.66
log
@2003-11-10  Andrew Cagney  <cagney@@redhat.com>

	* target.h (struct target_ops): Order xfer buffer parameters "read
	write" not "write read".
	* bfd-target.c (target_bfd_xfer_partial): Update.
	* remote.c (remote_xfer_partial): Update.
	* inftarg.c (child_xfer_partial): Update.
	* target.c (default_xfer_partial): Update.
	(target_read_partial, target_write_partial): Update.
	(debug_to_xfer_partial): Update.
@
text
@d1287 1
a1287 1
  if (STREQ (current_target.to_shortname, "rombug"))
@


1.65
log
@2003-11-06  Andrew Cagney  <cagney@@redhat.com>
	    Jeff Johnston  <jjohnstn@@redhat.com>

	* target.c (add_target): Only set "to_xfer_partial" when NULL.
	(init_dummy_target): Set "to_xfer_partial".
@
text
@d78 3
a80 3
				     const char *annex, const void *writebuf,
				     void *readbuf, ULONGEST offset,
				     LONGEST len);
d1077 3
a1079 4
default_xfer_partial (struct target_ops *ops,
		      enum target_object object,
		      const char *annex, const void *writebuf,
		      void *readbuf, ULONGEST offset, LONGEST len)
d1111 1
a1111 1
					  writebuf, readbuf, offset, len);
d1129 1
a1129 1
  return ops->to_xfer_partial (ops, object, annex, NULL, buf, offset, len);
d1139 1
a1139 1
  return ops->to_xfer_partial (ops, object, annex, buf, NULL, offset, len);
d2291 3
a2293 4
debug_to_xfer_partial (struct target_ops *ops,
		       enum target_object object,
		       const char *annex, const void *writebuf,
		       void *readbuf, ULONGEST offset, LONGEST len)
d2298 1
a2298 1
					 writebuf, readbuf, offset, len);
d2303 1
a2303 1
		      (long) writebuf, (long) readbuf, paddr_nz (offset),
@


1.64
log
@2003-10-31  Andrew Cagney  <cagney@@redhat.com>

	* target.h (struct target_ops): Replace "to_read_partial" and
	"to_write_partial" with "to_xfer_partial".  Update comments.
	* target.c (debug_to_write_partial): Delete function.
	(debug_to_xfer_partial): Replace debug_to_read_partial.
	(add_target, update_current_target, setup_target_debug): Set
	"to_xfer_partial" instead of "to_read_partial" and
	"to_write_partial".
	(default_xfer_partial): Replace "default_write_partial".
	(default_read_partial): Delete.
	(target_read_partial, target_write_partial): Call
	"to_xfer_partial".
	* remote.c (init_remote_ops): Set "to_xfer_partial".
	(init_remote_async_ops): Ditto.
	(remote_xfer_partial): Replace "remote_read_partial".
@
text
@d223 2
a224 1
  t->to_xfer_partial = default_xfer_partial;
d1648 1
@


1.63
log
@2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* target.c: Include "gdbcore.h".
	(get_target_memory, get_target_memory_unsigned): New functions.
	* target.h (get_target_memory, get_target_memory_unsigned): Declare.
	* ppc-linux-tdep.c (ppc64_linux_convert_from_func_ptr_addr):
	Use get_target_memory_unsigned.
	* Makefile.in (target.o): Update dependencies.
@
text
@d76 1
a76 1
static LONGEST default_read_partial (struct target_ops *ops,
d78 3
a80 6
				     const char *annex, void *buf,
				     ULONGEST offset, LONGEST len);
static LONGEST default_write_partial (struct target_ops *ops,
				      enum target_object object,
				      const char *annex, const void *buf,
				      ULONGEST offset, LONGEST len);
d223 1
a223 2
  t->to_read_partial = default_read_partial;
  t->to_write_partial = default_write_partial;
d432 1
a432 2
      /* Do not inherit to_read_partial.  */
      /* Do not inherit to_write_partial.  */
d614 1
a614 2
  current_target.to_read_partial = default_read_partial;
  current_target.to_write_partial = default_write_partial;
d1076 1
a1076 1
default_read_partial (struct target_ops *ops,
d1078 2
a1079 2
		      const char *annex, void *buf,
		      ULONGEST offset, LONGEST len)
d1086 1
a1086 1
      int xfered;
d1088 11
a1098 34
      xfered = ops->to_xfer_memory (offset, buf, len, 0/*read*/, NULL, ops);
      if (xfered > 0)
	return xfered;
      else if (xfered == 0 && errno == 0)
	/* "to_xfer_memory" uses 0, cross checked against ERRNO as one
           indication of an error.  */
	return 0;
      else
	return -1;
    }
  else if (ops->beneath != NULL)
    return target_read_partial (ops->beneath, object, annex, buf, offset, len);
  else
    return -1;
}

static LONGEST
default_write_partial (struct target_ops *ops,
		       enum target_object object,
		       const char *annex, const void *buf,
		       ULONGEST offset, LONGEST len)
{
  if (object == TARGET_OBJECT_MEMORY
      && ops->to_xfer_memory != NULL)
    /* If available, fall back to the target's "to_xfer_memory"
       method.  */
    {
      int xfered;
      errno = 0;
      {
	void *buffer = xmalloc (len);
	struct cleanup *cleanup = make_cleanup (xfree, buffer);
	memcpy (buffer, buf, len);
	xfered = ops->to_xfer_memory (offset, buffer, len, 1/*write*/, NULL,
a1099 2
	do_cleanups (cleanup);
      }
d1110 2
a1111 2
    return target_write_partial (ops->beneath, object, annex, buf, offset,
				 len);
d1128 2
a1129 2
  gdb_assert (ops->to_read_partial != NULL);
  return ops->to_read_partial (ops, object, annex, buf, offset, len);
d1138 2
a1139 2
  gdb_assert (ops->to_write_partial != NULL);
  return ops->to_write_partial (ops, object, annex, buf, offset, len);
d2290 1
a2290 1
debug_to_read_partial (struct target_ops *ops,
d2292 2
a2293 22
		       const char *annex, void *buf,
		       ULONGEST offset, LONGEST len)
{
  LONGEST retval;

  retval = target_read_partial (&debug_target, object, annex, buf, offset,
				len);

  fprintf_unfiltered (gdb_stdlog,
		      "target_read_partial (%d, %s, 0x%lx,  0x%s, %s) = %s\n",
		      (int) object, (annex ? annex : "(null)"),
		      (long) buf, paddr_nz (offset),
		      paddr_d (len), paddr_d (retval));

  return retval;
}

static LONGEST
debug_to_write_partial (struct target_ops *ops,
			enum target_object object,
			const char *annex, const void *buf,
			ULONGEST offset, LONGEST len)
d2297 2
a2298 2
  retval = target_write_partial (&debug_target, object, annex, buf, offset,
				len);
d2301 1
a2301 1
		      "target_write_partial (%d, %s, 0x%lx,  0x%s, %s) = %s\n",
d2303 1
a2303 1
		      (long) buf, paddr_nz (offset),
d2406 1
a2406 2
  current_target.to_read_partial = debug_to_read_partial;
  current_target.to_write_partial = debug_to_write_partial;
@


1.62
log
@2003-10-22  Andrew Cagney  <cagney@@redhat.com>

	* target.c: Include "gdb_assert.h" (target_read): Call
	"target_read_partial", not "target_write_partial".
	(default_read_partial, default_write_partial): New function.
	(target_read_partial, target_write_partial): Simplify, assume that
	there is always a read/write method.
	(update_current_target, add_target): Always set "to_read_partial"
	and "to_write_partial".
	(target_write, target_read): Fail on a zero byte transfer.
	* Makefile.in (target.o): Update dependencies.
	* target.h: Update copyright date.
	(target_object): Fix typo.
@
text
@d40 1
d1216 22
@


1.61
log
@2003-10-22  Andrew Cagney  <cagney@@redhat.com>

	* target.c (target_close): New function.
	(debug_to_close): Use "target_close".
	(push_target): Use "target_close".
	(unpush_target): Use "target_close".
	(pop_target): Use "target_close".
	* target.h (struct target_ops): Add "to_xclose".
	(target_open): Delete macro.  Move comment to "to_open".
	(target_close): Replace macro with function that takes a target.
	* top.c (quit_target): Pass "current_target" to "target_close".
@
text
@d39 1
d75 9
d224 4
d462 2
a463 2
     it.  We default entries, at least to stubs that print error
     messages.  */
d618 2
d1080 72
d1158 2
a1159 12
  struct target_ops *op;

  /* Find the first target stratum that can handle the request.  */
  for (op = ops;
       op != NULL && op->to_read_partial == NULL;
       op = op->beneath)
    ;
  if (op == NULL)
    return -1;
  
  /* Now apply the operation at that level.  */
  return op->to_read_partial (op, object, annex, buf, offset, len);
d1168 2
a1169 11
  struct target_ops *op;

  /* Find the first target stratum that can handle the request.  */
  for (op = ops;
       op != NULL && op->to_write_partial == NULL;
       op = op->beneath)
    ;
  if (op == NULL)
    return -1;
  
  return op->to_write_partial (op, object, annex, buf, offset, len);
d1182 3
a1184 3
      LONGEST xfer = target_write_partial (ops, object, annex,
					   (bfd_byte *) buf + xfered,
					   offset + xfered, len - xfered);
d1186 3
a1188 2
      if (xfer < 0)
	return xfer;
d1208 3
a1210 2
      if (xfer < 0)
	return xfer;
@


1.60
log
@2003-10-21  Andrew Cagney  <cagney@@redhat.com>

	* target.c (errno): Delete extern declaration.
@
text
@d675 1
a675 2
      if (tmp->to_close)
	(tmp->to_close) (0);
d700 1
a700 2
  if (t->to_close)
    t->to_close (0);		/* Let it clean up */
d727 1
a727 1
  (current_target.to_close) (0);	/* Let it clean up */
d1601 3
a1603 1
  debug_target.to_close (quitting);
d1605 7
a1611 1
  fprintf_unfiltered (gdb_stdlog, "target_close (%d)\n", quitting);
@


1.59
log
@2003-10-17  Andrew Cagney  <cagney@@redhat.com>

	* target.c (target_section_by_addr): New function.
	(do_xfer_memory): Use "target_section_by_addr".
	* target.h (target_section_by_addr): Declare.
@
text
@a39 2
extern int errno;

@


1.58
log
@2003-10-17  Andrew Cagney  <cagney@@redhat.com>

	* target.h (struct target_ops): Add "to_read_partial" and
	"to_write_partial", delete "to_query".
	(target_read_partial, target_write_partial): Declare.
	(target_read, target_write): Declare.
	(target_query): Delete macro.
	* target.c (target_read_partial): New function.
	(target_write_partial, target_read, target_write): New function.
	(update_current_target): Delete inheritance of "to_query".  Add
	comments about "to_read_partial" and "to_write_partial".
	(debug_to_partial_read, debug_to_partial_write): New functions.
	(debug_to_query): Delete function.
	(setup_target_debug): Set "to_read_partial" and "to_write_partial"
	instead of "to_query".
	* remote.c (remote_read_partial): Replace "remote_query".
	(init_remote_ops): Set "to_read_partial" instead of "to_query".
	(init_remote_async_ops): Ditto.
	* kod.c (gdb_kod_query): Make "bufsize" a LONGEST.  Use
	"target_read_partial" instead of "target_query".
	* avr-tdep.c (avr_io_reg_read_command): Make "bufsize" a LONGEST.
	Use "target_read_partial" instead of "target_query".
@
text
@d817 15
d879 1
d882 6
a887 14
         directly from the bfd file. */

      struct section_table *secp;

      for (secp = current_target.to_sections;
	   secp < current_target.to_sections_end;
	   secp++)
	{
	  if (bfd_get_section_flags (secp->bfd, secp->the_bfd_section) 
	      & SEC_READONLY)
	    if (memaddr >= secp->addr && memaddr < secp->endaddr)
	      return xfer_memory (memaddr, myaddr, len, 0, 
				  attrib, &current_target);
	}
@


1.57
log
@2003-10-17  Andrew Cagney  <cagney@@redhat.com>

	* target.c: Update copyright.
	(update_current_target): Perform the target cleanup.
	Put the target stack beneath the squashed "current_target".
	(add_target): Delete disabled call to "cleanup_target".
	(cleanup_target): Delete function.
	(push_target, unpush_target): Do not call "cleanup_target".
@
text
@a161 2
static int debug_to_query (int /*char */ , char *, char *, int *);

d423 2
a424 1
      INHERIT (to_query, t);
d1058 84
d2214 25
a2238 2
static int
debug_to_query (int type, char *req, char *resp, int *siz)
d2240 1
a2240 1
  int retval;
d2242 2
a2243 1
  retval = debug_target.to_query (type, req, resp, siz);
d2245 5
a2249 1
  fprintf_unfiltered (gdb_stdlog, "target_query (%c, %s, %s,  %d) = %d\n", type, req, resp, *siz, retval);
d2351 2
a2352 1
  current_target.to_query = debug_to_query;
@


1.56
log
@2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* target.c (target_stack): Change to a static target_ops.
	(update_current_target): Walk the "struct target_ops" stack.
	(pop_target, do_xfer_memory, target_info): Ditto.
	(find_target_beneath): Ditto.
	(push_target): Rewrite to use the "struct target_ops" stack.
	(unpush_target): Ditto.
	* target.h (struct target_stack_item): Delete definition.
	(target_stack): Delete declaration.
	(struct target_ops): Add field "beneath".
@
text
@d2 4
a5 3
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002
   Free Software Foundation, Inc.
a43 2
static void cleanup_target (struct target_ops *);

a71 2
static void update_current_target (void);

a231 1
/*  cleanup_target (t); */
d342 11
a352 2
/* Clean up a target struct so it no longer has any zero pointers in it.
   We default entries, at least to stubs that print error messages.  */
d355 1
a355 1
cleanup_target (struct target_ops *t)
d357 96
d455 2
a456 2
  if (!t->field)               \
    t->field = value
a628 1
}
d630 4
a633 101
/* Go through the target stack from top to bottom, copying over zero entries in
   current_target.  In effect, we are doing class inheritance through the
   pushed target vectors.  */

static void
update_current_target (void)
{
  struct target_ops *t;

  /* First, reset current_target */
  memset (&current_target, 0, sizeof current_target);

  for (t = target_stack; t; t = t->beneath)
    {

#define INHERIT(FIELD, TARGET) \
      if (!current_target.FIELD) \
	current_target.FIELD = TARGET->FIELD

      INHERIT (to_shortname, t);
      INHERIT (to_longname, t);
      INHERIT (to_doc, t);
      INHERIT (to_open, t);
      INHERIT (to_close, t);
      INHERIT (to_attach, t);
      INHERIT (to_post_attach, t);
      INHERIT (to_detach, t);
      INHERIT (to_disconnect, t);
      INHERIT (to_resume, t);
      INHERIT (to_wait, t);
      INHERIT (to_post_wait, t);
      INHERIT (to_fetch_registers, t);
      INHERIT (to_store_registers, t);
      INHERIT (to_prepare_to_store, t);
      INHERIT (to_xfer_memory, t);
      INHERIT (to_files_info, t);
      INHERIT (to_insert_breakpoint, t);
      INHERIT (to_remove_breakpoint, t);
      INHERIT (to_can_use_hw_breakpoint, t);
      INHERIT (to_insert_hw_breakpoint, t);
      INHERIT (to_remove_hw_breakpoint, t);
      INHERIT (to_insert_watchpoint, t);
      INHERIT (to_remove_watchpoint, t);
      INHERIT (to_stopped_data_address, t);
      INHERIT (to_stopped_by_watchpoint, t);
      INHERIT (to_have_continuable_watchpoint, t);
      INHERIT (to_region_size_ok_for_hw_watchpoint, t);
      INHERIT (to_terminal_init, t);
      INHERIT (to_terminal_inferior, t);
      INHERIT (to_terminal_ours_for_output, t);
      INHERIT (to_terminal_ours, t);
      INHERIT (to_terminal_save_ours, t);
      INHERIT (to_terminal_info, t);
      INHERIT (to_kill, t);
      INHERIT (to_load, t);
      INHERIT (to_lookup_symbol, t);
      INHERIT (to_create_inferior, t);
      INHERIT (to_post_startup_inferior, t);
      INHERIT (to_acknowledge_created_inferior, t);
      INHERIT (to_insert_fork_catchpoint, t);
      INHERIT (to_remove_fork_catchpoint, t);
      INHERIT (to_insert_vfork_catchpoint, t);
      INHERIT (to_remove_vfork_catchpoint, t);
      INHERIT (to_follow_fork, t);
      INHERIT (to_insert_exec_catchpoint, t);
      INHERIT (to_remove_exec_catchpoint, t);
      INHERIT (to_reported_exec_events_per_exec_call, t);
      INHERIT (to_has_exited, t);
      INHERIT (to_mourn_inferior, t);
      INHERIT (to_can_run, t);
      INHERIT (to_notice_signals, t);
      INHERIT (to_thread_alive, t);
      INHERIT (to_find_new_threads, t);
      INHERIT (to_pid_to_str, t);
      INHERIT (to_extra_thread_info, t);
      INHERIT (to_stop, t);
      INHERIT (to_query, t);
      INHERIT (to_rcmd, t);
      INHERIT (to_enable_exception_callback, t);
      INHERIT (to_get_current_exception_event, t);
      INHERIT (to_pid_to_exec_file, t);
      INHERIT (to_stratum, t);
      INHERIT (to_has_all_memory, t);
      INHERIT (to_has_memory, t);
      INHERIT (to_has_stack, t);
      INHERIT (to_has_registers, t);
      INHERIT (to_has_execution, t);
      INHERIT (to_has_thread_control, t);
      INHERIT (to_sections, t);
      INHERIT (to_sections_end, t);
      INHERIT (to_can_async_p, t);
      INHERIT (to_is_async_p, t);
      INHERIT (to_async, t);
      INHERIT (to_async_mask_value, t);
      INHERIT (to_find_memory_regions, t);
      INHERIT (to_make_corefile_notes, t);
      INHERIT (to_get_thread_local_address, t);
      INHERIT (to_magic, t);

#undef INHERIT
    }
a687 2
  cleanup_target (&current_target);	/* Fill in the gaps */

a724 1
  cleanup_target (&current_target);
@


1.55
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d183 1
a183 1
struct target_stack_item *target_stack;
a536 1
  struct target_stack_item *item;
d542 1
a542 1
  for (item = target_stack; item; item = item->next)
a543 1
      t = item->target_ops;
d646 1
a646 1
  struct target_stack_item *cur, *prev, *tmp;
d658 2
a659 3
  /* Find the proper stratum to install this target in. */

  for (prev = NULL, cur = target_stack; cur; prev = cur, cur = cur->next)
d661 1
a661 1
      if ((int) (t->to_stratum) >= (int) (cur->target_ops->to_stratum))
d665 13
a677 16
  /* If there's already targets at this stratum, remove them. */

  if (cur)
    while (t->to_stratum == cur->target_ops->to_stratum)
      {
	/* There's already something on this stratum.  Close it off.  */
	if (cur->target_ops->to_close)
	  (cur->target_ops->to_close) (0);
	if (prev)
	  prev->next = cur->next;	/* Unchain old target_ops */
	else
	  target_stack = cur->next;	/* Unchain first on list */
	tmp = cur->next;
	xfree (cur);
	cur = tmp;
      }
d680 2
a681 10

  tmp = (struct target_stack_item *)
    xmalloc (sizeof (struct target_stack_item));
  tmp->next = cur;
  tmp->target_ops = t;

  if (prev)
    prev->next = tmp;
  else
    target_stack = tmp;
d690 2
a691 1
  return prev != 0;
d700 2
a701 1
  struct target_stack_item *cur, *prev;
d709 5
a713 3
  for (cur = target_stack, prev = NULL; cur; prev = cur, cur = cur->next)
    if (cur->target_ops == t)
      break;
d715 1
a715 1
  if (!cur)
d719 3
a721 7

  if (!prev)
    target_stack = cur->next;
  else
    prev->next = cur->next;

  xfree (cur);			/* Release the target_stack_item */
d733 1
a733 1
  if (unpush_target (target_stack->target_ops) == 1)
a853 1
  struct target_stack_item *item;
d890 1
a890 1
      for (item = target_stack; item; item = item->next)
a891 1
	  t = item->target_ops;
a1062 1
  struct target_stack_item *item;
d1073 1
a1073 1
  for (item = target_stack; item; item = item->next)
a1074 2
      t = item->target_ops;

d1369 1
a1369 10
  struct target_stack_item *cur;

  for (cur = target_stack; cur; cur = cur->next)
    if (cur->target_ops == t)
      break;

  if (cur == NULL || cur->next == NULL)
    return NULL;
  else
    return cur->next->target_ops;
@


1.54
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d1663 1
a1663 1
      for (i = 0; i < REGISTER_RAW_SIZE (regno); i++)
d1667 1
a1667 1
      if (REGISTER_RAW_SIZE (regno) <= sizeof (LONGEST))
@


1.53
log
@gdb/
        * NEWS: Mention gdbserver detach change and "disconnect" command.
        * infcmd.c (disconnect_command): New function.
        (_initialize_infcmd): Add ``disconnect'' command.
        * remote.c (remote_async_detach): Delete.
        (remote_detach): Merge remote_async_detach.
        (remote_disconnect): New.
        (init_remote_ops): Set to_disconnect.
        (init_remote_cisco_ops): Likewise.
        (init_remote_async_ops): Likewise.  Use remote_detach.
        * target.c (cleanup_target): Default to_disconnect.
        (update_current_target): Inherit to_disconnect.
        (target_disconnect, debug_to_disconnect): New functions.
        (setup_target_debug): Set to_disconnect.
        * target.h (struct target_ops): Add to_disconnect.
        (target_disconnect): Add prototype.
gdbserver/
	* linux-low.c: Move comment to linux_thread_alive where it belonged.
	(linux_detach_one_process, linux_detach): New functions.
	(linux_target_ops): Add linux_detach.
	* server.c (main): Handle 'D' packet.
	* target.h (struct target_ops): Add "detach" member.
	(detach_inferior): Define.
mi/
        * mi-cmds.c (mi_cmds): Add "-target-disconnect".
@
text
@a208 1
/* ARGSUSED */
a261 1
/* ARGSUSED */
a282 1
/* ARGSUSED */
a288 1
/* ARGSUSED */
a298 1
/* ARGSUSED */
a1074 1
/* ARGSUSED */
a1496 1
/* ARGSUSED */
a1503 1
/* ARGSUSED */
@


1.52
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d98 2
d376 3
d564 1
d1150 10
d1581 9
d2230 1
@


1.52.8.1
log
@Snap const char * mess.
@
text
@d41 2
d47 2
d51 1
a51 1
static void default_terminal_info (const char *, int);
d69 1
a69 1
static void target_command (const char *, int);
d90 1
a90 1
static void debug_to_open (const char *, int);
d94 1
a94 1
static void debug_to_attach (const char *, int);
d96 1
a96 1
static void debug_to_detach (const char *, int);
d143 1
a143 1
static void debug_to_terminal_info (const char *, int);
d147 2
d209 1
a209 1
target_command (const char *arg, int from_tty)
d255 1
a255 1
target_load (const char *arg, int from_tty)
d303 1
a303 1
default_terminal_info (const char *args, int from_tty)
d336 1
a336 1
maybe_kill_then_attach (const char *args, int from_tty)
d361 1
a361 1
	    (void (*) (const char *, int)) 
d372 1
a372 1
	    (void (*) (const char *, int)) 
d446 1
a446 1
	    (void (*) (const char *, int)) 
d507 1
a507 1
	    (void (*) (const char *, struct ui_file *)) 
d1076 1
a1076 1
target_info (const char *args, int from_tty)
d1134 1
a1134 1
target_detach (const char *args, int from_tty)
d1196 1
a1196 1
find_default_attach (const char *args, int from_tty)
d1524 1
a1524 1
debug_to_open (const char *args, int from_tty)
d1540 1
a1540 1
debug_to_attach (const char *args, int from_tty)
d1557 1
a1557 1
debug_to_detach (const char *args, int from_tty)
d1905 1
a1905 1
debug_to_terminal_info (const char *arg, int from_tty)
d1922 1
a1922 1
debug_to_load (const char *args, int from_tty)
d2155 1
a2155 1
debug_to_rcmd (const char *command,
d2265 2
a2266 1
do_monitor_command (const char *cmd, int from_tty)
d2269 1
a2269 1
       == (void (*) (const char *, struct ui_file *)) tcomplain)
d2272 1
a2272 1
	      == (void (*) (const char *, struct ui_file *)) tcomplain)))
@


1.51
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d1643 1
a1643 1
      unsigned char *buf = alloca (MAX_REGISTER_RAW_SIZE);
@


1.50
log
@add HAVE_CONTINUABLE_WATCHPOINT to target_ops
@
text
@d1218 1
a1218 1
  return (byte_count <= REGISTER_SIZE);
@


1.50.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1218 1
a1218 1
  return (byte_count <= DEPRECATED_REGISTER_SIZE);
d1643 1
a1643 1
      unsigned char buf[MAX_REGISTER_SIZE];
@


1.49
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* cris-tdep.c: Fix function declaration indentation.
	* dwarfread.c, gdbcore.h, gdbtypes.h, i386v-nat.c: Ditto.
	* mips-tdep.c, monitor.h, parse.c, proc-utils.h: Ditto.
	* rs6000-nat.c, ser-go32.c, somread.c, stabsread.c: Ditto.
	* symfile.h, symtab.h, target.c, target.h, value.h: Ditto.
	* xcoffread.c, config/pa/tm-hppa.h: Ditto.
	* config/sparc/tm-sp64.h, config/sparc/tm-sparc.h: Ditto.
@
text
@d576 1
@


1.48
log
@	* target.c (update_current_target): Don't inherit DONT_USE.
	* target.h (struct target_ops): Remove DONT_USE.
	(target_next): Remove macro.
@
text
@d85 2
a86 2
static int
target_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write);
@


1.47
log
@	* corelow.c (init_core_ops): Delete references to to_require_attach
	and to_require_detach.
	* exec.c (init_exec_ops): Likewise.
	* hppah-nat.c (child_follow_fork): Call hppa_require_attach and
	hppa_require_detach directly.
	* inferior.h (REQUIRE_ATTACH, REQUIRE_DETACH): Delete.
	* inftarg.c (child_detach): Remove.
	(child_detach_from_process): Rename to child_detach, remove
	after_fork argument.
	(child_attach): Remove.
	(child_attach_to_process): Rename to child_attach, remove after_fork
	argument.
	(init_child_ops): Delete references to to_require_attach
	and to_require_detach.
	* infttrace.c (hppa_require_attach): Update comment.
	* target.c (cleanup_target, update_current_target)
	(init_dummy_target, setup_target_debug): Delete references to
	to_require_attach and to_require_detach.
	(find_default_require_detach, find_default_require_attach)
	(debug_to_require_attach, debug_to_require_detach): Remove
	functions.
	* target.h (struct target_ops): Remove to_require_attach
	and to_require_detach.
	(target_require_attach, target_require_detach): Delete macros.
	(find_default_require_detach, find_default_require_attach): Delete
	prototypes.
	* config/pa/nm-hppah.h (REQUIRE_ATTACH, REQUIRE_DETACH): Delete.
@
text
@a611 1
      INHERIT (DONT_USE, t);
@


1.46
log
@	* config/pa/nm-hppah.h (CHILD_POST_FOLLOW_VFORK): Change to
	CHILD_FOLLOW_FORK.
	* hppah-nat.c (saved_vfork_pid): Add.
	(child_post_follow_vfork): Remove.
	(child_follow_fork): New function.
	(child_wait): Call detach_breakpoints after receiving the child vfork.
	Call child_resume directly instead of going through resume ().
	Make sure we have the exec before reporting the vfork.
	* inferior.h (follow_inferior_reset_breakpoints): Add prototype.
	* infrun.c (follow_fork, follow_vfork, follow_inferior_fork): Remove.
	(follow_fork): New function.  Call target_follow_fork.
	(follow_inferior_reset_breakpoints): New function broken out from
	old follow_inferior_fork.
	(resume): Remove hack to follow exec after vfork.
	* inftarg.c (child_post_follow_vfork): Remove.
	(child_follow_fork): New function.
	(init_child_ops): Replace to_post_follow_vfork with to_follow_fork.
	* target.c (cleanup_target): Replace to_post_follow_vfork with
	to_follow_fork.
	(update_current_target): Likewise.
	(setup_target_debug): Likewise.
	(debug_to_post_follow_vfork): Remove.
	(debug_to_follow_fork): New function.
	* target.h (struct target_ops): Replace to_post_folow_vfork with
	to_follow_fork.
	(child_post_follow_vfork): Remove prototype.
	(child_follow_fork): Add prototype.
	(target_post_follow_vfork): Remove macro.
	(target_follow_fork): Add macro.

testsuite/
	* gdb.base/foll-vfork.exp: Re-enable test on HP/UX.
@
text
@a370 2
  de_fault (to_require_attach, 
	    maybe_kill_then_attach);
a373 3
  de_fault (to_require_detach, 
	    (void (*) (int, char *, int)) 
	    target_ignore);
d471 1
a471 1
  de_fault (to_follow_fork, 
a557 1
      INHERIT (to_require_attach, t);
a558 1
      INHERIT (to_require_detach, t);
a1205 20
find_default_require_attach (char *args, int from_tty)
{
  struct target_ops *t;

  t = find_default_run_target ("require_attach");
  (t->to_require_attach) (args, from_tty);
  return;
}

void
find_default_require_detach (int pid, char *args, int from_tty)
{
  struct target_ops *t;

  t = find_default_run_target ("require_detach");
  (t->to_require_detach) (pid, args, from_tty);
  return;
}

void
a1511 2
  dummy_target.to_require_attach = find_default_require_attach;
  dummy_target.to_require_detach = find_default_require_detach;
a1556 9
debug_to_require_attach (char *args, int from_tty)
{
  debug_target.to_require_attach (args, from_tty);

  fprintf_unfiltered (gdb_stdlog,
		      "target_require_attach (%s, %d)\n", args, from_tty);
}

static void
a1564 9
debug_to_require_detach (int pid, char *args, int from_tty)
{
  debug_target.to_require_detach (pid, args, from_tty);

  fprintf_unfiltered (gdb_stdlog,
	       "target_require_detach (%d, %s, %d)\n", pid, args, from_tty);
}

static void
a2203 1
  current_target.to_require_attach = debug_to_require_attach;
a2204 1
  current_target.to_require_detach = debug_to_require_detach;
@


1.45
log
@	* config/pa/nm-hppah.h (CHILD_POST_FOLLOW_INFERIOR_BY_CLONE): Don't
	define.
	(struct target_waitstatus): Add opaque definition.
	* corelow.c (init_core_ops): Don't set to_clone_and_follow_inferior.
	* exec.c (init_exec_ops): Likewise.
	* fork-child.c (clone_and_follow_inferior): Remove.
	* hppah-nat.c (child_post_follow_inferior_by_clone): Remove.
	* inferior.h (clone_and_follow_inferior): Remove prototype.
	* infrun.c (follow_fork_mode_both): Remove.
	(follow_fork_mode_kind_names): Remove commented out "both".
	(follow_inferior_fork): Remove follow_fork_mode_both support.
	* inftarg.c (child_clone_and_follow_inferior): Remove.
	(child_post_follow_inferior_by_clone): Remove.
	(init_child_ops): Don't set to_clone_and_follow_inferior
	or to_post_follow_inferior_by_clone.
	* target.c (default_clone_and_follow_inferior): Remove.
	(cleanup_target): Don't set to_clone_and_follow_inferior
	or to_post_follow_inferior_by_clone.
	(find_default_clone_and_follow_inferior): Remove.
	(init_dummy_target): Don't set to_clone_and_follow_inferior.
	(debug_to_clone_and_follow_inferior): Remove.
	(debug_to_post_follow_inferior_by_clone): Remove.
	(setup_target_debug): Don't set to_clone_and_follow_inferior
	or to_post_follow_inferior_by_clone.
	* target.h (struct target_ops): Remove to_clone_and_follow_inferior
	and to_post_follow_inferior_by_clone.
	(child_clone_and_follow_inferior): Remove prototype.
	(child_post_follow_inferior_by_clone): Remove prototype.
	(target_clone_and_follow_inferior): Remove macro.
	(target_post_follow_inferior_by_clone): Remove macro.
	(find_default_clone_and_follow_inferior): Remove prototype.
@
text
@d476 2
a477 2
  de_fault (to_post_follow_vfork, 
	    (void (*) (int, int, int, int)) 
d600 1
a600 1
      INHERIT (to_post_follow_vfork, t);
d2067 2
a2068 3
static void
debug_to_post_follow_vfork (int parent_pid, int followed_parent, int child_pid,
			    int followed_child)
d2070 1
a2070 1
  debug_target.to_post_follow_vfork (parent_pid, followed_parent, child_pid, followed_child);
d2072 4
a2075 3
  fprintf_unfiltered (gdb_stdlog,
		      "target_post_follow_vfork (%d, %d, %d, %d)\n",
		    parent_pid, followed_parent, child_pid, followed_child);
d2288 1
a2288 1
  current_target.to_post_follow_vfork = debug_to_post_follow_vfork;
@


1.44
log
@	* breakpoint.c (bpstat_stop_status): Call inferior_has_forked,
	inferior_has_vforked, and inferior_has_execd instead of
	target_has_forked, target_has_vforked, and target_has_execd.
	* config/pa/nm-hppah.h (CHILD_HAS_FORKED, CHILD_HAS_VFORKED)
	(CHILD_HAS_EXECD, CHILD_HAS_SYSCALL_EVENT): Don't define.
	(CHILD_WAIT): Define.
	(child_wait): Add prototype.
	* hppah-nat.c (hpux_has_forked): Rename from child_has_forked.
	Add prototype.
	(hpux_has_vforked): Likewise, from child_has_vforked.
	(hpux_has_execd): Likewise, from child_has_execd.
	(hpux_has_syscall_event): Likewise, from child_has_syscall_event.
	(not_same_real_pid, child_wait): New, copied from inftarg.c.
	Call hpux_has_forked, hpux_has_vforked, hpux_has_execd,
	and hpux_has_syscall_event instead of the target hooks.
	* infrun.c (inferior_has_forked, inferior_has_vforked)
	(inferior_has_execd): New functions.
	* inftarg.c (not_same_real_pid): Remove.
	(child_wait): Remove references to not_same_real_pid,
	target_has_forked, target_has_vforked, target_has_execd,
	and target_has_syscall_event.
	(child_has_forked, child_has_vforked, child_has_execd)
	(child_has_syscall_event): Remove.
	(init_child_ops): Remove references to child_has_forked,
	child_has_vforked, child_has_execd, and child_has_syscall_event.
	* infttrace.c (hpux_has_forked): Rename from child_has_forked.
	(hpux_has_vforked): Likewise, from child_has_vforked.
	(hpux_has_execd): Likewise, from child_has_execd.
	(hpux_has_syscall_event): Likewise, from child_has_syscall_event.
	* target.c (cleanup_target): Remove references to
	to_has_forked, to_has_vforked, to_has_execd, and
	to_has_syscall_event.
	(update_current_target): Likewise.
	(setup_target_debug): Likewise.
	(debug_to_has_forked): Remove.
	(debug_to_has_vforked): Remove.
	(debug_to_has_execd): Remove.
	(debug_to_has_syscall_event): Remove.
	* target.h (struct target_ops): Remove to_has_forked.
	to_has_vforked, to_has_execd, and to_has_syscall_event.
	(child_has_forked, child_has_vforked, child_has_execd)
	(child_has_syscall_event): Remove prototypes.
	(inferior_has_forked, inferior_has_vforked, inferior_has_execd): Add
	prototypes.
	(target_has_forked, target_has_vforked, target_has_execd)
	(target_has_syscall_event): Remove macros.
@
text
@a46 2
static void default_clone_and_follow_inferior (int, int *);

a348 6
static void
default_clone_and_follow_inferior (int child_pid, int *followed_child)
{
  target_clone_and_follow_inferior (child_pid, followed_child);
}

a463 5
  de_fault (to_clone_and_follow_inferior, 
	    default_clone_and_follow_inferior);
  de_fault (to_post_follow_inferior_by_clone, 
	    (void (*) (void)) 
	    target_ignore);
a595 2
      INHERIT (to_clone_and_follow_inferior, t);
      INHERIT (to_post_follow_inferior_by_clone, t);
a1241 10
void
find_default_clone_and_follow_inferior (int child_pid, int *followed_child)
{
  struct target_ops *t;

  t = find_default_run_target ("run");
  (t->to_clone_and_follow_inferior) (child_pid, followed_child);
  return;
}

a1541 1
  dummy_target.to_clone_and_follow_inferior = find_default_clone_and_follow_inferior;
a2014 18
static void
debug_to_clone_and_follow_inferior (int child_pid, int *followed_child)
{
  debug_target.to_clone_and_follow_inferior (child_pid, followed_child);

  fprintf_unfiltered (gdb_stdlog,
		      "target_clone_and_follow_inferior (%d, %d)\n",
		      child_pid, *followed_child);
}

static void
debug_to_post_follow_inferior_by_clone (void)
{
  debug_target.to_post_follow_inferior_by_clone ();

  fprintf_unfiltered (gdb_stdlog, "target_post_follow_inferior_by_clone ()\n");
}

a2283 2
  current_target.to_clone_and_follow_inferior = debug_to_clone_and_follow_inferior;
  current_target.to_post_follow_inferior_by_clone = debug_to_post_follow_inferior_by_clone;
@


1.43
log
@	* hppah-nat.c (child_can_follow_vfork_prior_to_exec): Remove.
	* inftarg.c (child_can_follow_vfork_prior_to_exec): Remove.
	(init_child_ops): Don't initialize to_can_follow_vfork_prior_to_exec.
	* infttrace.c (child_can_follow_vfork_prior_to_exec): Remove.
	* target.c (cleanup_target): Remove reference to
	to_can_follow_vfork_prior_to_exec.
	(update_current_target): Likewise.
	(debug_to_can_follow_vfork_prior_to_exec): Remove.
	(setup_target_debug): Remove reference to
	to_can_follow_vfork_prior_to_exec.
	* target.h (struct target_ops): Remove
	to_can_follow_vfork_prior_to_exec.
	(child_can_follow_vfork_prior_to_exec): Remove prototype.
	(target_can_follow_vfork_prior_to_exec): Remove definition.
	* config/pa/nm-hppah.h (CHILD_CAN_FOLLOW_VFORK_PRIOR_TO_EXEC): Don't
	define.
	* infrun.c (follow_vfork_when_exec): Remove.
	(follow_inferior_fork): Remove references to follow_vfork_when_exec.
	(follow_exec): Likewise.
	(handle_inferior_event): Likewise.
	(keep_going): Likewise.
@
text
@a488 6
  de_fault (to_has_forked, 
	    (int (*) (int, int *)) 
	    return_zero);
  de_fault (to_has_vforked, 
	    (int (*) (int, int *)) 
	    return_zero);
a497 3
  de_fault (to_has_execd, 
	    (int (*) (int, char **)) 
	    return_zero);
a500 3
  de_fault (to_has_syscall_event, 
	    (int (*) (int, enum target_waitkind *, int *)) 
	    return_zero);
a614 2
      INHERIT (to_has_forked, t);
      INHERIT (to_has_vforked, t);
a617 1
      INHERIT (to_has_execd, t);
a618 1
      INHERIT (to_has_syscall_event, t);
a2110 26
static int
debug_to_has_forked (int pid, int *child_pid)
{
  int has_forked;

  has_forked = debug_target.to_has_forked (pid, child_pid);

  fprintf_unfiltered (gdb_stdlog, "target_has_forked (%d, %d) = %d\n",
		      pid, *child_pid, has_forked);

  return has_forked;
}

static int
debug_to_has_vforked (int pid, int *child_pid)
{
  int has_vforked;

  has_vforked = debug_target.to_has_vforked (pid, child_pid);

  fprintf_unfiltered (gdb_stdlog, "target_has_vforked (%d, %d) = %d\n",
		      pid, *child_pid, has_vforked);

  return has_vforked;
}

a2148 14
debug_to_has_execd (int pid, char **execd_pathname)
{
  int has_execd;

  has_execd = debug_target.to_has_execd (pid, execd_pathname);

  fprintf_unfiltered (gdb_stdlog, "target_has_execd (%d, %s) = %d\n",
		      pid, (*execd_pathname ? *execd_pathname : "<NULL>"),
		      has_execd);

  return has_execd;
}

static int
a2162 30
debug_to_has_syscall_event (int pid, enum target_waitkind *kind,
			    int *syscall_id)
{
  int has_syscall_event;
  char *kind_spelling = "??";

  has_syscall_event = debug_target.to_has_syscall_event (pid, kind, syscall_id);
  if (has_syscall_event)
    {
      switch (*kind)
	{
	case TARGET_WAITKIND_SYSCALL_ENTRY:
	  kind_spelling = "SYSCALL_ENTRY";
	  break;
	case TARGET_WAITKIND_SYSCALL_RETURN:
	  kind_spelling = "SYSCALL_RETURN";
	  break;
	default:
	  break;
	}
    }

  fprintf_unfiltered (gdb_stdlog,
		      "target_has_syscall_event (%d, %s, %d) = %d\n",
		      pid, kind_spelling, *syscall_id, has_syscall_event);

  return has_syscall_event;
}

static int
a2333 2
  current_target.to_has_forked = debug_to_has_forked;
  current_target.to_has_vforked = debug_to_has_vforked;
a2336 1
  current_target.to_has_execd = debug_to_has_execd;
a2337 1
  current_target.to_has_syscall_event = debug_to_has_syscall_event;
@


1.42
log
@2002-11-11  Elena Zannoni  <ezannoni@@redhat.com>

        * findvar.c (read_var_value): Reenable TLS code.

2002-11-11  Elena Zannoni  <ezannoni@@redhat.com>
            Jim Blandy  <jimb@@redhat.com>

	* gdb_thread_db.h (enum): Add TD_NOTALLOC.
	* target.c (update_current_target): Add
	to_get_thread_local_address.
	* target.h (to_get_thread_local_address): Export.
	(target_get_thread_local_address): Define.
	(target_get_thread_local_address_p): Define.
	* thread-db.c: Include solib-svr4.h.
	(td_thr_tls_get_addr_p): Define.
	(thread_db_load): Get a pointer to td_thr_tls_get_addr.
	(thread_db_get_thread_local_address): New function.
	(init_thread_db_ops): Initialize to_get_thread_local_address.
	* configure.in: Add test for TD_NOTALLOC in thread_db.h.
	* configure: Regenerate.
	* config.in: Regenerate.
@
text
@a494 3
  de_fault (to_can_follow_vfork_prior_to_exec, 
	    (int (*) (void)) 
	    return_zero);
a628 1
      INHERIT (to_can_follow_vfork_prior_to_exec, t);
a2152 13
static int
debug_to_can_follow_vfork_prior_to_exec (void)
{
  int can_immediately_follow_vfork;

  can_immediately_follow_vfork = debug_target.to_can_follow_vfork_prior_to_exec ();

  fprintf_unfiltered (gdb_stdlog, "target_can_follow_vfork_prior_to_exec () = %d\n",
		      can_immediately_follow_vfork);

  return can_immediately_follow_vfork;
}

a2421 1
  current_target.to_can_follow_vfork_prior_to_exec = debug_to_can_follow_vfork_prior_to_exec;
@


1.41
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d669 1
@


1.40
log
@	Fix PR gdb/393:
	* inflow.c (terminal_save_ours): New function to save terminal
	settings.
	* inferior.h (terminal_save_ours): Declare.
	* target.c (debug_to_terminal_save_ours): New function.
	(cleanup_target): Defaults to_terminal_save_ours.
	(update_current_target): Inherit to_terminal_save_ours.
	(setup_target_debug): Set to_terminal_save_ours.
	* target.h (target_terminal_save_ours): New to save terminal settings.
	(target_ops): New member to_terminal_save_ours.
	* gnu-nat.c (init_gnu_ops): Set to_terminal_save_ours.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* inftarg.c (init_child_ops): Likewise.
	* m3-nat.c (init_m3_ops): Likewise.
	* procfs.c (init_procfs_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* sol-thread.c (init_sol_thread_ops): Likewise.
@
text
@d1736 1
a1736 1
      read_register_gen (regno, buf);
@


1.40.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 3
a4 4

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.

d38 2
a39 2
#include "gdb_assert.h"
#include "gdbcore.h"
d43 2
d47 2
d75 2
a80 6
static LONGEST default_xfer_partial (struct target_ops *ops,
				     enum target_object object,
				     const char *annex, void *readbuf,
				     const void *writebuf,
				     ULONGEST offset, LONGEST len);

d87 2
a88 2
static int target_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
			       int write);
a99 2
static void debug_to_disconnect (char *, int);

d165 2
d183 1
a183 1
static struct target_ops *target_stack;
d209 1
a221 4
  /* Provide default values for all "must have" methods.  */
  if (t->to_xfer_partial == NULL)
    t->to_xfer_partial = default_xfer_partial;

d236 1
d263 1
d285 1
d292 1
d303 1
a350 12
/* Go through the target stack from top to bottom, copying over zero
   entries in current_target, then filling in still empty entries.  In
   effect, we are doing class inheritance through the pushed target
   vectors.

   NOTE: cagney/2003-10-17: The problem with this inheritance, as it
   is currently implemented, is that it discards any knowledge of
   which target an inherited method originally belonged to.
   Consequently, new new target methods should instead explicitly and
   locally search the target stack for the target that can handle the
   request.  */

d352 1
a352 1
update_current_target (void)
d354 2
a355 1
  struct target_ops *t;
d357 2
a358 2
  /* First, reset curren'ts contents.  */
  memset (&current_target, 0, sizeof (current_target));
d360 3
a362 91
#define INHERIT(FIELD, TARGET) \
      if (!current_target.FIELD) \
	current_target.FIELD = (TARGET)->FIELD

  for (t = target_stack; t; t = t->beneath)
    {
      INHERIT (to_shortname, t);
      INHERIT (to_longname, t);
      INHERIT (to_doc, t);
      INHERIT (to_open, t);
      INHERIT (to_close, t);
      INHERIT (to_attach, t);
      INHERIT (to_post_attach, t);
      INHERIT (to_detach, t);
      INHERIT (to_disconnect, t);
      INHERIT (to_resume, t);
      INHERIT (to_wait, t);
      INHERIT (to_post_wait, t);
      INHERIT (to_fetch_registers, t);
      INHERIT (to_store_registers, t);
      INHERIT (to_prepare_to_store, t);
      INHERIT (to_xfer_memory, t);
      INHERIT (to_files_info, t);
      INHERIT (to_insert_breakpoint, t);
      INHERIT (to_remove_breakpoint, t);
      INHERIT (to_can_use_hw_breakpoint, t);
      INHERIT (to_insert_hw_breakpoint, t);
      INHERIT (to_remove_hw_breakpoint, t);
      INHERIT (to_insert_watchpoint, t);
      INHERIT (to_remove_watchpoint, t);
      INHERIT (to_stopped_data_address, t);
      INHERIT (to_stopped_by_watchpoint, t);
      INHERIT (to_have_continuable_watchpoint, t);
      INHERIT (to_region_size_ok_for_hw_watchpoint, t);
      INHERIT (to_terminal_init, t);
      INHERIT (to_terminal_inferior, t);
      INHERIT (to_terminal_ours_for_output, t);
      INHERIT (to_terminal_ours, t);
      INHERIT (to_terminal_save_ours, t);
      INHERIT (to_terminal_info, t);
      INHERIT (to_kill, t);
      INHERIT (to_load, t);
      INHERIT (to_lookup_symbol, t);
      INHERIT (to_create_inferior, t);
      INHERIT (to_post_startup_inferior, t);
      INHERIT (to_acknowledge_created_inferior, t);
      INHERIT (to_insert_fork_catchpoint, t);
      INHERIT (to_remove_fork_catchpoint, t);
      INHERIT (to_insert_vfork_catchpoint, t);
      INHERIT (to_remove_vfork_catchpoint, t);
      INHERIT (to_follow_fork, t);
      INHERIT (to_insert_exec_catchpoint, t);
      INHERIT (to_remove_exec_catchpoint, t);
      INHERIT (to_reported_exec_events_per_exec_call, t);
      INHERIT (to_has_exited, t);
      INHERIT (to_mourn_inferior, t);
      INHERIT (to_can_run, t);
      INHERIT (to_notice_signals, t);
      INHERIT (to_thread_alive, t);
      INHERIT (to_find_new_threads, t);
      INHERIT (to_pid_to_str, t);
      INHERIT (to_extra_thread_info, t);
      INHERIT (to_stop, t);
      /* Do not inherit to_xfer_partial.  */
      INHERIT (to_rcmd, t);
      INHERIT (to_enable_exception_callback, t);
      INHERIT (to_get_current_exception_event, t);
      INHERIT (to_pid_to_exec_file, t);
      INHERIT (to_stratum, t);
      INHERIT (to_has_all_memory, t);
      INHERIT (to_has_memory, t);
      INHERIT (to_has_stack, t);
      INHERIT (to_has_registers, t);
      INHERIT (to_has_execution, t);
      INHERIT (to_has_thread_control, t);
      INHERIT (to_sections, t);
      INHERIT (to_sections_end, t);
      INHERIT (to_can_async_p, t);
      INHERIT (to_is_async_p, t);
      INHERIT (to_async, t);
      INHERIT (to_async_mask_value, t);
      INHERIT (to_find_memory_regions, t);
      INHERIT (to_make_corefile_notes, t);
      INHERIT (to_get_thread_local_address, t);
      INHERIT (to_magic, t);
    }
#undef INHERIT

  /* Clean up a target struct so it no longer has any zero pointers in
     it.  Some entries are defaulted to a method that print an error,
     others are hard-wired to a standard recursive default.  */
d365 2
a366 2
  if (!current_target.field)               \
    current_target.field = value
d379 2
d384 3
a386 3
  de_fault (to_disconnect, 
	    (void (*) (char *, int)) 
	    tcomplain);
d472 5
d489 11
a499 2
  de_fault (to_follow_fork,
	    (int (*) (int)) 
d507 3
d513 3
a538 1
  current_target.to_xfer_partial = default_xfer_partial;
d561 18
d580 93
a672 4
  /* Finally, position the target-stack beneath the squashed
     "current_target".  That way code looking for a non-inherited
     target method can quickly and simply find it.  */
  current_target.beneath = target_stack;
d688 1
a688 1
  struct target_ops **cur;
d700 3
a702 2
  /* Find the proper stratum to install this target in.  */
  for (cur = &target_stack; (*cur) != NULL; cur = &(*cur)->beneath)
d704 1
a704 1
      if ((int) (t->to_stratum) >= (int) (*cur)->to_stratum)
d708 16
a723 12
  /* If there's already targets at this stratum, remove them.  */
  /* FIXME: cagney/2003-10-15: I think this should be poping all
     targets to CUR, and not just those at this stratum level.  */
  while ((*cur) != NULL && t->to_stratum == (*cur)->to_stratum)
    {
      /* There's already something at this stratum level.  Close it,
         and un-hook it from the stack.  */
      struct target_ops *tmp = (*cur);
      (*cur) = (*cur)->beneath;
      tmp->beneath = NULL;
      target_close (tmp, 0);
    }
d726 10
a735 2
  t->beneath = (*cur);
  (*cur) = t;
d739 2
d744 1
a744 2
  /* Not on top?  */
  return (t != target_stack);
d753 1
a753 2
  struct target_ops **cur;
  struct target_ops *tmp;
d755 2
a756 1
  target_close (t, 0);
d761 3
a763 5
  for (cur = &target_stack; (*cur) != NULL; cur = &(*cur)->beneath)
    {
      if ((*cur) == t)
	break;
    }
d765 1
a765 1
  if ((*cur) == NULL)
d769 7
a775 3
  tmp = (*cur);
  (*cur) = (*cur)->beneath;
  tmp->beneath = NULL;
d778 1
d786 2
a787 2
  target_close (&current_target, 0);	/* Let it clean up */
  if (unpush_target (target_stack) == 1)
a871 15
/* Find a section containing ADDR.  */
struct section_table *
target_section_by_addr (struct target_ops *target, CORE_ADDR addr)
{
  struct section_table *secp;
  for (secp = target->to_sections;
       secp < target->to_sections_end;
       secp++)
    {
      if (addr >= secp->addr && addr < secp->endaddr)
	return secp;
    }
  return NULL;
}

d908 1
a919 1
      struct section_table *secp;
d922 14
a935 6
         directly from the bfd file.  */
      secp = target_section_by_addr (&current_target, memaddr);
      if (secp != NULL
	  && (bfd_get_section_flags (secp->bfd, secp->the_bfd_section)
	      & SEC_READONLY))
	return xfer_memory (memaddr, myaddr, len, 0, attrib, &current_target);
d945 1
a945 1
      for (t = target_stack; t != NULL; t = t->beneath)
d947 1
d1115 1
a1115 135
/* More generic transfers.  */

static LONGEST
default_xfer_partial (struct target_ops *ops, enum target_object object,
		      const char *annex, void *readbuf, 
		      const void *writebuf, ULONGEST offset, LONGEST len)
{
  if (object == TARGET_OBJECT_MEMORY
      && ops->to_xfer_memory != NULL)
    /* If available, fall back to the target's "to_xfer_memory"
       method.  */
    {
      int xfered = -1;
      errno = 0;
      if (writebuf != NULL)
	{
	  void *buffer = xmalloc (len);
	  struct cleanup *cleanup = make_cleanup (xfree, buffer);
	  memcpy (buffer, writebuf, len);
	  xfered = ops->to_xfer_memory (offset, buffer, len, 1/*write*/, NULL,
					ops);
	  do_cleanups (cleanup);
	}
      if (readbuf != NULL)
	xfered = ops->to_xfer_memory (offset, readbuf, len, 0/*read*/, NULL,
				      ops);
      if (xfered > 0)
	return xfered;
      else if (xfered == 0 && errno == 0)
	/* "to_xfer_memory" uses 0, cross checked against ERRNO as one
           indication of an error.  */
	return 0;
      else
	return -1;
    }
  else if (ops->beneath != NULL)
    return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					  readbuf, writebuf, offset, len);
  else
    return -1;
}

/* Target vector read/write partial wrapper functions.

   NOTE: cagney/2003-10-21: I wonder if having "to_xfer_partial
   (inbuf, outbuf)", instead of separate read/write methods, make life
   easier.  */

LONGEST
target_read_partial (struct target_ops *ops,
		     enum target_object object,
		     const char *annex, void *buf,
		     ULONGEST offset, LONGEST len)
{
  gdb_assert (ops->to_xfer_partial != NULL);
  return ops->to_xfer_partial (ops, object, annex, buf, NULL, offset, len);
}

LONGEST
target_write_partial (struct target_ops *ops,
		      enum target_object object,
		      const char *annex, const void *buf,
		      ULONGEST offset, LONGEST len)
{
  gdb_assert (ops->to_xfer_partial != NULL);
  return ops->to_xfer_partial (ops, object, annex, NULL, buf, offset, len);
}

/* Wrappers to perform the full transfer.  */
LONGEST
target_read (struct target_ops *ops,
	     enum target_object object,
	     const char *annex, void *buf,
	     ULONGEST offset, LONGEST len)
{
  LONGEST xfered = 0;
  while (xfered < len)
    {
      LONGEST xfer = target_read_partial (ops, object, annex,
					  (bfd_byte *) buf + xfered,
					  offset + xfered, len - xfered);
      /* Call an observer, notifying them of the xfer progress?  */
      if (xfer <= 0)
	/* Call memory_error?  */
	return -1;
      xfered += xfer;
      QUIT;
    }
  return len;
}

LONGEST
target_write (struct target_ops *ops,
	      enum target_object object,
	      const char *annex, const void *buf,
	      ULONGEST offset, LONGEST len)
{
  LONGEST xfered = 0;
  while (xfered < len)
    {
      LONGEST xfer = target_write_partial (ops, object, annex,
					   (bfd_byte *) buf + xfered,
					   offset + xfered, len - xfered);
      /* Call an observer, notifying them of the xfer progress?  */
      if (xfer <= 0)
	/* Call memory_error?  */
	return -1;
      xfered += xfer;
      QUIT;
    }
  return len;
}

/* Memory transfer methods.  */

void
get_target_memory (struct target_ops *ops, CORE_ADDR addr, void *buf,
		   LONGEST len)
{
  if (target_read (ops, TARGET_OBJECT_MEMORY, NULL, buf, addr, len)
      != len)
    memory_error (EIO, addr);
}

ULONGEST
get_target_memory_unsigned (struct target_ops *ops,
			    CORE_ADDR addr, int len)
{
  char buf[sizeof (ULONGEST)];

  gdb_assert (len <= sizeof (buf));
  get_target_memory (ops, addr, buf, len);
  return extract_unsigned_integer (buf, len);
}

d1120 1
d1131 1
a1131 1
  for (t = target_stack; t != NULL; t = t->beneath)
d1133 2
a1184 10
target_disconnect (char *args, int from_tty)
{
  /* Handle any optimized stores to the inferior.  */
#ifdef DO_DEFERRED_STORES
  DO_DEFERRED_STORES;
#endif
  (current_target.to_disconnect) (args, from_tty);
}

void
d1187 1
a1187 1
  if (DEPRECATED_STREQ (current_target.to_shortname, "rombug"))
d1247 20
d1276 10
d1289 1
a1289 1
  return (byte_count <= DEPRECATED_REGISTER_SIZE);
d1449 10
a1458 1
  return t->beneath;
d1558 1
d1566 1
d1583 2
d1586 1
a1590 1
  dummy_target.to_xfer_partial = default_xfer_partial;
d1608 2
a1609 1
  target_close (&debug_target, quitting);
a1612 9
void
target_close (struct target_ops *targ, int quitting)
{
  if (targ->to_xclose != NULL)
    targ->to_xclose (targ, quitting);
  else if (targ->to_close != NULL)
    targ->to_close (quitting);
}

d1631 9
d1648 1
a1648 1
debug_to_disconnect (char *args, int from_tty)
d1650 1
a1650 1
  debug_target.to_disconnect (args, from_tty);
d1652 2
a1653 2
  fprintf_unfiltered (gdb_stdlog, "target_disconnect (%s, %d)\n",
		      args, from_tty);
d1735 2
a1736 2
      unsigned char buf[MAX_REGISTER_SIZE];
      deprecated_read_register_gen (regno, buf);
d1738 1
a1738 1
      for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i++)
d1742 1
a1742 1
      if (DEPRECATED_REGISTER_RAW_SIZE (regno) <= sizeof (LONGEST))
d2060 18
d2131 1
a2131 1
debug_to_follow_fork (int follow_child)
d2133 1
a2133 1
  int retval =  debug_target.to_follow_fork (follow_child);
d2135 1
a2135 2
  fprintf_unfiltered (gdb_stdlog, "target_follow_fork (%d) = %d\n",
		      follow_child, retval);
d2137 41
a2177 1
  return retval;
d2207 14
d2235 30
d2335 2
a2336 4
static LONGEST
debug_to_xfer_partial (struct target_ops *ops, enum target_object object,
		       const char *annex, void *readbuf, const void *writebuf,
		       ULONGEST offset, LONGEST len)
d2338 1
a2338 1
  LONGEST retval;
d2340 1
a2340 2
  retval = debug_target.to_xfer_partial (&debug_target, object, annex,
					 readbuf, writebuf, offset, len);
d2342 1
a2342 5
  fprintf_unfiltered (gdb_stdlog,
		      "target_xfer_partial (%d, %s, 0x%lx,  0x%lx,  0x%s, %s) = %s\n",
		      (int) object, (annex ? annex : "(null)"),
		      (long) readbuf, (long) writebuf, paddr_nz (offset),
		      paddr_d (len), paddr_d (retval));
d2397 1
d2399 1
a2399 1
  current_target.to_disconnect = debug_to_disconnect;
d2430 2
d2436 4
a2439 1
  current_target.to_follow_fork = debug_to_follow_fork;
d2442 1
d2444 1
d2452 1
a2452 1
  current_target.to_xfer_partial = debug_to_xfer_partial;
@


1.40.6.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d712 2
a724 8

  /* NOTE: cagney/2003-12-06: In '94 the close call was made
     unconditional by moving it to before the above check that the
     target was in the target stack (something about "Change the way
     pushing and popping of targets work to support target overlays
     and inheritance").  This doesn't make much sense - only open
     targets should be closed.  */
  target_close (t, 0);
@


1.40.6.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d74 2
d1365 1
a1365 1
  return (byte_count <= TYPE_LENGTH (builtin_type_void_data_ptr));
d1604 18
@


1.40.4.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a668 1
      INHERIT (to_get_thread_local_address, t);
d1736 1
a1736 1
      deprecated_read_register_gen (regno, buf);
@


1.40.4.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d47 2
d351 6
d379 2
d384 3
d472 5
d489 11
a499 2
  de_fault (to_follow_fork,
	    (int (*) (int)) 
d507 3
d513 3
d591 1
d593 1
d624 2
d630 4
a633 1
      INHERIT (to_follow_fork, t);
d636 1
d638 1
d654 1
d1248 20
d1277 10
d1584 2
d1587 1
d1632 9
d1649 9
d2061 18
d2132 14
a2145 1
debug_to_follow_fork (int follow_child)
d2147 22
a2168 1
  int retval =  debug_target.to_follow_fork (follow_child);
d2170 5
a2174 2
  fprintf_unfiltered (gdb_stdlog, "target_follow_fork (%d) = %d\n",
		      follow_child, retval);
d2176 3
a2178 1
  return retval;
d2208 14
d2236 30
d2398 1
d2400 1
d2431 2
d2437 4
a2440 1
  current_target.to_follow_fork = debug_to_follow_fork;
d2443 1
d2445 1
@


1.40.4.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d85 2
a86 2
static int target_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
			       int write);
@


1.40.4.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@a575 1
      INHERIT (to_have_continuable_watchpoint, t);
@


1.40.4.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1218 1
a1218 1
  return (byte_count <= DEPRECATED_REGISTER_SIZE);
d1643 1
a1643 1
      unsigned char buf[MAX_REGISTER_SIZE];
@


1.40.4.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a97 2
static void debug_to_disconnect (char *, int);

a373 3
  de_fault (to_disconnect, 
	    (void (*) (char *, int)) 
	    tcomplain);
a558 1
      INHERIT (to_disconnect, t);
a1143 10
target_disconnect (char *args, int from_tty)
{
  /* Handle any optimized stores to the inferior.  */
#ifdef DO_DEFERRED_STORES
  DO_DEFERRED_STORES;
#endif
  (current_target.to_disconnect) (args, from_tty);
}

void
a1564 9
debug_to_disconnect (char *args, int from_tty)
{
  debug_target.to_disconnect (args, from_tty);

  fprintf_unfiltered (gdb_stdlog, "target_disconnect (%s, %d)\n",
		      args, from_tty);
}

static void
a2204 1
  current_target.to_disconnect = debug_to_disconnect;
@


1.40.4.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d2 3
a4 4

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.

d38 2
a39 2
#include "gdb_assert.h"
#include "gdbcore.h"
d43 2
d73 2
a78 6
static LONGEST default_xfer_partial (struct target_ops *ops,
				     enum target_object object,
				     const char *annex, void *readbuf,
				     const void *writebuf,
				     ULONGEST offset, LONGEST len);

d165 2
d183 1
a183 1
static struct target_ops *target_stack;
d209 1
a221 4
  /* Provide default values for all "must have" methods.  */
  if (t->to_xfer_partial == NULL)
    t->to_xfer_partial = default_xfer_partial;

d236 1
d263 1
d285 1
d292 1
d303 1
d351 2
a352 11
/* Go through the target stack from top to bottom, copying over zero
   entries in current_target, then filling in still empty entries.  In
   effect, we are doing class inheritance through the pushed target
   vectors.

   NOTE: cagney/2003-10-17: The problem with this inheritance, as it
   is currently implemented, is that it discards any knowledge of
   which target an inherited method originally belonged to.
   Consequently, new new target methods should instead explicitly and
   locally search the target stack for the target that can handle the
   request.  */
d355 1
a355 1
update_current_target (void)
a356 96
  struct target_ops *t;

  /* First, reset curren'ts contents.  */
  memset (&current_target, 0, sizeof (current_target));

#define INHERIT(FIELD, TARGET) \
      if (!current_target.FIELD) \
	current_target.FIELD = (TARGET)->FIELD

  for (t = target_stack; t; t = t->beneath)
    {
      INHERIT (to_shortname, t);
      INHERIT (to_longname, t);
      INHERIT (to_doc, t);
      INHERIT (to_open, t);
      INHERIT (to_close, t);
      INHERIT (to_attach, t);
      INHERIT (to_post_attach, t);
      INHERIT (to_detach, t);
      INHERIT (to_disconnect, t);
      INHERIT (to_resume, t);
      INHERIT (to_wait, t);
      INHERIT (to_post_wait, t);
      INHERIT (to_fetch_registers, t);
      INHERIT (to_store_registers, t);
      INHERIT (to_prepare_to_store, t);
      INHERIT (to_xfer_memory, t);
      INHERIT (to_files_info, t);
      INHERIT (to_insert_breakpoint, t);
      INHERIT (to_remove_breakpoint, t);
      INHERIT (to_can_use_hw_breakpoint, t);
      INHERIT (to_insert_hw_breakpoint, t);
      INHERIT (to_remove_hw_breakpoint, t);
      INHERIT (to_insert_watchpoint, t);
      INHERIT (to_remove_watchpoint, t);
      INHERIT (to_stopped_data_address, t);
      INHERIT (to_stopped_by_watchpoint, t);
      INHERIT (to_have_continuable_watchpoint, t);
      INHERIT (to_region_size_ok_for_hw_watchpoint, t);
      INHERIT (to_terminal_init, t);
      INHERIT (to_terminal_inferior, t);
      INHERIT (to_terminal_ours_for_output, t);
      INHERIT (to_terminal_ours, t);
      INHERIT (to_terminal_save_ours, t);
      INHERIT (to_terminal_info, t);
      INHERIT (to_kill, t);
      INHERIT (to_load, t);
      INHERIT (to_lookup_symbol, t);
      INHERIT (to_create_inferior, t);
      INHERIT (to_post_startup_inferior, t);
      INHERIT (to_acknowledge_created_inferior, t);
      INHERIT (to_insert_fork_catchpoint, t);
      INHERIT (to_remove_fork_catchpoint, t);
      INHERIT (to_insert_vfork_catchpoint, t);
      INHERIT (to_remove_vfork_catchpoint, t);
      INHERIT (to_follow_fork, t);
      INHERIT (to_insert_exec_catchpoint, t);
      INHERIT (to_remove_exec_catchpoint, t);
      INHERIT (to_reported_exec_events_per_exec_call, t);
      INHERIT (to_has_exited, t);
      INHERIT (to_mourn_inferior, t);
      INHERIT (to_can_run, t);
      INHERIT (to_notice_signals, t);
      INHERIT (to_thread_alive, t);
      INHERIT (to_find_new_threads, t);
      INHERIT (to_pid_to_str, t);
      INHERIT (to_extra_thread_info, t);
      INHERIT (to_stop, t);
      /* Do not inherit to_xfer_partial.  */
      INHERIT (to_rcmd, t);
      INHERIT (to_enable_exception_callback, t);
      INHERIT (to_get_current_exception_event, t);
      INHERIT (to_pid_to_exec_file, t);
      INHERIT (to_stratum, t);
      INHERIT (to_has_all_memory, t);
      INHERIT (to_has_memory, t);
      INHERIT (to_has_stack, t);
      INHERIT (to_has_registers, t);
      INHERIT (to_has_execution, t);
      INHERIT (to_has_thread_control, t);
      INHERIT (to_sections, t);
      INHERIT (to_sections_end, t);
      INHERIT (to_can_async_p, t);
      INHERIT (to_is_async_p, t);
      INHERIT (to_async, t);
      INHERIT (to_async_mask_value, t);
      INHERIT (to_find_memory_regions, t);
      INHERIT (to_make_corefile_notes, t);
      INHERIT (to_get_thread_local_address, t);
      INHERIT (to_magic, t);
    }
#undef INHERIT

  /* Clean up a target struct so it no longer has any zero pointers in
     it.  Some entries are defaulted to a method that print an error,
     others are hard-wired to a standard recursive default.  */
d359 2
a360 2
  if (!current_target.field)               \
    current_target.field = value
a510 1
  current_target.to_xfer_partial = default_xfer_partial;
d533 14
d548 90
a637 4
  /* Finally, position the target-stack beneath the squashed
     "current_target".  That way code looking for a non-inherited
     target method can quickly and simply find it.  */
  current_target.beneath = target_stack;
d653 1
a653 1
  struct target_ops **cur;
d665 3
a667 2
  /* Find the proper stratum to install this target in.  */
  for (cur = &target_stack; (*cur) != NULL; cur = &(*cur)->beneath)
d669 1
a669 1
      if ((int) (t->to_stratum) >= (int) (*cur)->to_stratum)
d673 16
a688 12
  /* If there's already targets at this stratum, remove them.  */
  /* FIXME: cagney/2003-10-15: I think this should be poping all
     targets to CUR, and not just those at this stratum level.  */
  while ((*cur) != NULL && t->to_stratum == (*cur)->to_stratum)
    {
      /* There's already something at this stratum level.  Close it,
         and un-hook it from the stack.  */
      struct target_ops *tmp = (*cur);
      (*cur) = (*cur)->beneath;
      tmp->beneath = NULL;
      target_close (tmp, 0);
    }
d691 10
a700 2
  t->beneath = (*cur);
  (*cur) = t;
d704 2
d709 1
a709 2
  /* Not on top?  */
  return (t != target_stack);
d718 1
a718 2
  struct target_ops **cur;
  struct target_ops *tmp;
d720 2
a721 1
  target_close (t, 0);
d726 3
a728 5
  for (cur = &target_stack; (*cur) != NULL; cur = &(*cur)->beneath)
    {
      if ((*cur) == t)
	break;
    }
d730 1
a730 1
  if ((*cur) == NULL)
d734 7
a740 3
  tmp = (*cur);
  (*cur) = (*cur)->beneath;
  tmp->beneath = NULL;
d743 1
d751 2
a752 2
  target_close (&current_target, 0);	/* Let it clean up */
  if (unpush_target (target_stack) == 1)
a836 15
/* Find a section containing ADDR.  */
struct section_table *
target_section_by_addr (struct target_ops *target, CORE_ADDR addr)
{
  struct section_table *secp;
  for (secp = target->to_sections;
       secp < target->to_sections_end;
       secp++)
    {
      if (addr >= secp->addr && addr < secp->endaddr)
	return secp;
    }
  return NULL;
}

d873 1
a884 1
      struct section_table *secp;
d887 14
a900 6
         directly from the bfd file.  */
      secp = target_section_by_addr (&current_target, memaddr);
      if (secp != NULL
	  && (bfd_get_section_flags (secp->bfd, secp->the_bfd_section)
	      & SEC_READONLY))
	return xfer_memory (memaddr, myaddr, len, 0, attrib, &current_target);
d910 1
a910 1
      for (t = target_stack; t != NULL; t = t->beneath)
d912 1
d1080 1
a1080 135
/* More generic transfers.  */

static LONGEST
default_xfer_partial (struct target_ops *ops, enum target_object object,
		      const char *annex, void *readbuf, 
		      const void *writebuf, ULONGEST offset, LONGEST len)
{
  if (object == TARGET_OBJECT_MEMORY
      && ops->to_xfer_memory != NULL)
    /* If available, fall back to the target's "to_xfer_memory"
       method.  */
    {
      int xfered = -1;
      errno = 0;
      if (writebuf != NULL)
	{
	  void *buffer = xmalloc (len);
	  struct cleanup *cleanup = make_cleanup (xfree, buffer);
	  memcpy (buffer, writebuf, len);
	  xfered = ops->to_xfer_memory (offset, buffer, len, 1/*write*/, NULL,
					ops);
	  do_cleanups (cleanup);
	}
      if (readbuf != NULL)
	xfered = ops->to_xfer_memory (offset, readbuf, len, 0/*read*/, NULL,
				      ops);
      if (xfered > 0)
	return xfered;
      else if (xfered == 0 && errno == 0)
	/* "to_xfer_memory" uses 0, cross checked against ERRNO as one
           indication of an error.  */
	return 0;
      else
	return -1;
    }
  else if (ops->beneath != NULL)
    return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					  readbuf, writebuf, offset, len);
  else
    return -1;
}

/* Target vector read/write partial wrapper functions.

   NOTE: cagney/2003-10-21: I wonder if having "to_xfer_partial
   (inbuf, outbuf)", instead of separate read/write methods, make life
   easier.  */

LONGEST
target_read_partial (struct target_ops *ops,
		     enum target_object object,
		     const char *annex, void *buf,
		     ULONGEST offset, LONGEST len)
{
  gdb_assert (ops->to_xfer_partial != NULL);
  return ops->to_xfer_partial (ops, object, annex, buf, NULL, offset, len);
}

LONGEST
target_write_partial (struct target_ops *ops,
		      enum target_object object,
		      const char *annex, const void *buf,
		      ULONGEST offset, LONGEST len)
{
  gdb_assert (ops->to_xfer_partial != NULL);
  return ops->to_xfer_partial (ops, object, annex, NULL, buf, offset, len);
}

/* Wrappers to perform the full transfer.  */
LONGEST
target_read (struct target_ops *ops,
	     enum target_object object,
	     const char *annex, void *buf,
	     ULONGEST offset, LONGEST len)
{
  LONGEST xfered = 0;
  while (xfered < len)
    {
      LONGEST xfer = target_read_partial (ops, object, annex,
					  (bfd_byte *) buf + xfered,
					  offset + xfered, len - xfered);
      /* Call an observer, notifying them of the xfer progress?  */
      if (xfer <= 0)
	/* Call memory_error?  */
	return -1;
      xfered += xfer;
      QUIT;
    }
  return len;
}

LONGEST
target_write (struct target_ops *ops,
	      enum target_object object,
	      const char *annex, const void *buf,
	      ULONGEST offset, LONGEST len)
{
  LONGEST xfered = 0;
  while (xfered < len)
    {
      LONGEST xfer = target_write_partial (ops, object, annex,
					   (bfd_byte *) buf + xfered,
					   offset + xfered, len - xfered);
      /* Call an observer, notifying them of the xfer progress?  */
      if (xfer <= 0)
	/* Call memory_error?  */
	return -1;
      xfered += xfer;
      QUIT;
    }
  return len;
}

/* Memory transfer methods.  */

void
get_target_memory (struct target_ops *ops, CORE_ADDR addr, void *buf,
		   LONGEST len)
{
  if (target_read (ops, TARGET_OBJECT_MEMORY, NULL, buf, addr, len)
      != len)
    memory_error (EIO, addr);
}

ULONGEST
get_target_memory_unsigned (struct target_ops *ops,
			    CORE_ADDR addr, int len)
{
  char buf[sizeof (ULONGEST)];

  gdb_assert (len <= sizeof (buf));
  get_target_memory (ops, addr, buf, len);
  return extract_unsigned_integer (buf, len);
}

d1085 1
d1096 1
a1096 1
  for (t = target_stack; t != NULL; t = t->beneath)
d1098 2
d1394 10
a1403 1
  return t->beneath;
d1503 1
d1511 1
a1532 1
  dummy_target.to_xfer_partial = default_xfer_partial;
d1550 2
a1551 1
  target_close (&debug_target, quitting);
a1554 9
void
target_close (struct target_ops *targ, int quitting)
{
  if (targ->to_xclose != NULL)
    targ->to_xclose (targ, quitting);
  else if (targ->to_close != NULL)
    targ->to_close (quitting);
}

d1671 1
a1671 1
      for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i++)
d1675 1
a1675 1
      if (DEPRECATED_REGISTER_RAW_SIZE (regno) <= sizeof (LONGEST))
d2167 2
a2168 4
static LONGEST
debug_to_xfer_partial (struct target_ops *ops, enum target_object object,
		       const char *annex, void *readbuf, const void *writebuf,
		       ULONGEST offset, LONGEST len)
d2170 1
a2170 1
  LONGEST retval;
d2172 1
a2172 2
  retval = debug_target.to_xfer_partial (&debug_target, object, annex,
					 readbuf, writebuf, offset, len);
d2174 1
a2174 5
  fprintf_unfiltered (gdb_stdlog,
		      "target_xfer_partial (%d, %s, 0x%lx,  0x%lx,  0x%s, %s) = %s\n",
		      (int) object, (annex ? annex : "(null)"),
		      (long) readbuf, (long) writebuf, paddr_nz (offset),
		      paddr_d (len), paddr_d (retval));
d2276 1
a2276 1
  current_target.to_xfer_partial = debug_to_xfer_partial;
@


1.40.4.8
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1287 1
a1287 1
  if (DEPRECATED_STREQ (current_target.to_shortname, "rombug"))
@


1.40.4.9
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d74 2
d712 2
a725 8
  /* NOTE: cagney/2003-12-06: In '94 the close call was made
     unconditional by moving it to before the above check that the
     target was in the target stack (something about "Change the way
     pushing and popping of targets work to support target overlays
     and inheritance").  This doesn't make much sense - only open
     targets should be closed.  */
  target_close (t, 0);

d1359 1
a1359 1
  return (byte_count <= TYPE_LENGTH (builtin_type_void_data_ptr));
d1598 18
@


1.39
log
@	* target.h: Add to_insert_hw_breakpoint, to_remove_hw_breakpoint,
	to_insert_watchpoint, to_remove_watchpoint,
	to_stopped_by_watchpoint, to_stopped_data_address,
	to_region_size_ok_for_hw_watchpoint, to_can_use_hw_breakpoint to
	target vecctor. Define their corresponding macros so they call
	them.

	* target.c: Add default and debug versions of for
	to_insert_hw_breakpoint, to_remove_hw_breakpoint,
	to_insert_watchpoint, to_remove_watchpoint,
	to_stopped_by_watchpoint, to_stopped_data_address,
	to_region_size_ok_for_hw_watchpoint, to_can_use_hw_breakpoint.
@
text
@d141 2
d450 3
d616 1
d1989 8
d2422 1
@


1.38
log
@Fix some K&R isms.
@
text
@d55 2
d67 2
d119 16
d413 23
d599 8
d1281 6
d1298 6
d1840 110
d2396 8
@


1.37
log
@	* cli/cli-decode.c (add_show_from_set): Fixed typo in comment.
	* target.c (initialize_targets): Fixed typo in
	trust-readonly-sections `show' documentation.
@
text
@d106 2
a107 3
static int
debug_to_xfer_memory (CORE_ADDR, char *, int, int, struct mem_attrib *, 
		      struct target_ops *);
@


1.36
log
@* cli/cli-decode.c (add_setshow_boolean_cmd): Replace
add_set_boolean_cmd.
(add_setshow_cmd): New function.
* command.h (add_setshow_boolean_cmd): Replace
add_set_boolean_cmd.
* remote-rdi.c (_initialize_remote_rdi): Update ``set rdiheartbeat''
and ``set rdiromatzero''.
* maint.c (_initialize_maint_cmds): Update commented out code.
* cli/cli-decode.h (add_set_boolean_cmd): Delete declaration.
* target.c (initialize_targets): Update `set
trust-readonly-sections'.
* remote.c (_initialize_remote): Update `set remotebreak'.
@
text
@d2308 1
a2308 1
Set mode for reading from readonly sections.\n",
@


1.35
log
@* target.c (debug_print_register): New function.  Handle oversize
registers.
(debug_to_fetch_registers): Call.
(debug_to_store_registers): Call.
@
text
@d2302 3
a2304 5
  add_show_from_set 
    (add_set_boolean_cmd 
     ("trust-readonly-sections", class_support, 
      &trust_readonly, 
      "Set mode for reading from readonly sections.\n\
d2307 4
a2310 3
result in significant performance improvement for remote targets.",
      &setlist),
     &showlist);
@


1.35.4.1
log
@Merge with trunk.
@
text
@d2302 5
a2306 3
  add_setshow_boolean_cmd ("trust-readonly-sections", class_support, 
			   &trust_readonly, "\
Set mode for reading from readonly sections.\n\
d2309 3
a2311 4
result in significant performance improvement for remote targets.", "\
Set mode for reading from readonly sections.\n",
			   NULL, NULL,
			   &setlist, &showlist);
@


1.35.4.2
log
@merge with trunk
@
text
@d2308 1
a2308 1
Show mode for reading from readonly sections.\n",
@


1.35.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2302 5
a2306 3
  add_setshow_boolean_cmd ("trust-readonly-sections", class_support, 
			   &trust_readonly, "\
Set mode for reading from readonly sections.\n\
d2309 3
a2311 4
result in significant performance improvement for remote targets.", "\
Set mode for reading from readonly sections.\n",
			   NULL, NULL,
			   &setlist, &showlist);
@


1.35.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d106 3
a108 2
static int debug_to_xfer_memory (CORE_ADDR, char *, int, int,
				 struct mem_attrib *, struct target_ops *);
d2308 1
a2308 1
Show mode for reading from readonly sections.\n",
@


1.35.6.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a54 2
static int default_region_size_ok_for_hw_watchpoint (int);

a64 2
static int return_minus_one (void);

a114 16
static int debug_to_can_use_hw_breakpoint (int, int, int);

static int debug_to_insert_hw_breakpoint (CORE_ADDR, char *);

static int debug_to_remove_hw_breakpoint (CORE_ADDR, char *);

static int debug_to_insert_watchpoint (CORE_ADDR, int, int);

static int debug_to_remove_watchpoint (CORE_ADDR, int, int);

static int debug_to_stopped_by_watchpoint (void);

static CORE_ADDR debug_to_stopped_data_address (void);

static int debug_to_region_size_ok_for_hw_watchpoint (int);

a392 23
  de_fault (to_can_use_hw_breakpoint,
	    (int (*) (int, int, int))
	    return_zero);
  de_fault (to_insert_hw_breakpoint,
	    (int (*) (CORE_ADDR, char *))
	    return_minus_one);
  de_fault (to_remove_hw_breakpoint,
	    (int (*) (CORE_ADDR, char *))
	    return_minus_one);
  de_fault (to_insert_watchpoint,
	    (int (*) (CORE_ADDR, int, int))
	    return_minus_one);
  de_fault (to_remove_watchpoint,
	    (int (*) (CORE_ADDR, int, int))
	    return_minus_one);
  de_fault (to_stopped_by_watchpoint,
	    (int (*) (void))
	    return_zero);
  de_fault (to_stopped_data_address,
	    (CORE_ADDR (*) (void))
	    return_zero);
  de_fault (to_region_size_ok_for_hw_watchpoint,
	    default_region_size_ok_for_hw_watchpoint);
a555 8
      INHERIT (to_can_use_hw_breakpoint, t);
      INHERIT (to_insert_hw_breakpoint, t);
      INHERIT (to_remove_hw_breakpoint, t);
      INHERIT (to_insert_watchpoint, t);
      INHERIT (to_remove_watchpoint, t);
      INHERIT (to_stopped_data_address, t);
      INHERIT (to_stopped_by_watchpoint, t);
      INHERIT (to_region_size_ok_for_hw_watchpoint, t);
a1229 6
default_region_size_ok_for_hw_watchpoint (int byte_count)
{
  return (byte_count <= REGISTER_SIZE);
}

static int
a1240 6
static int
return_minus_one (void)
{
  return -1;
}

a1776 110
static int
debug_to_can_use_hw_breakpoint (int type, int cnt, int from_tty)
{
  int retval;

  retval = debug_target.to_can_use_hw_breakpoint (type, cnt, from_tty);

  fprintf_unfiltered (gdb_stdlog,
		      "target_can_use_hw_breakpoint (%ld, %ld, %ld) = %ld\n",
		      (unsigned long) type,
		      (unsigned long) cnt,
		      (unsigned long) from_tty,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_region_size_ok_for_hw_watchpoint (int byte_count)
{
  CORE_ADDR retval;

  retval = debug_target.to_region_size_ok_for_hw_watchpoint (byte_count);

  fprintf_unfiltered (gdb_stdlog,
		      "TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT (%ld) = 0x%lx\n",
		      (unsigned long) byte_count,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_stopped_by_watchpoint (void)
{
  int retval;

  retval = debug_target.to_stopped_by_watchpoint ();

  fprintf_unfiltered (gdb_stdlog,
		      "STOPPED_BY_WATCHPOINT () = %ld\n",
		      (unsigned long) retval);
  return retval;
}

static CORE_ADDR
debug_to_stopped_data_address (void)
{
  CORE_ADDR retval;

  retval = debug_target.to_stopped_data_address ();

  fprintf_unfiltered (gdb_stdlog,
		      "target_stopped_data_address () = 0x%lx\n",
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_insert_hw_breakpoint (CORE_ADDR addr, char *save)
{
  int retval;

  retval = debug_target.to_insert_hw_breakpoint (addr, save);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_hw_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) addr,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_remove_hw_breakpoint (CORE_ADDR addr, char *save)
{
  int retval;

  retval = debug_target.to_remove_hw_breakpoint (addr, save);

  fprintf_unfiltered (gdb_stdlog,
		      "target_remove_hw_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) addr,
		      (unsigned long) retval);
  return retval;
}

static int
debug_to_insert_watchpoint (CORE_ADDR addr, int len, int type)
{
  int retval;

  retval = debug_target.to_insert_watchpoint (addr, len, type);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_watchpoint (0x%lx, %d, %d) = %ld\n",
		      (unsigned long) addr, len, type, (unsigned long) retval);
  return retval;
}

static int
debug_to_remove_watchpoint (CORE_ADDR addr, int len, int type)
{
  int retval;

  retval = debug_target.to_insert_watchpoint (addr, len, type);

  fprintf_unfiltered (gdb_stdlog,
		      "target_insert_watchpoint (0x%lx, %d, %d) = %ld\n",
		      (unsigned long) addr, len, type, (unsigned long) retval);
  return retval;
}

a2222 8
  current_target.to_can_use_hw_breakpoint = debug_to_can_use_hw_breakpoint;
  current_target.to_insert_hw_breakpoint = debug_to_insert_hw_breakpoint;
  current_target.to_remove_hw_breakpoint = debug_to_remove_hw_breakpoint;
  current_target.to_insert_watchpoint = debug_to_insert_watchpoint;
  current_target.to_remove_watchpoint = debug_to_remove_watchpoint;
  current_target.to_stopped_by_watchpoint = debug_to_stopped_by_watchpoint;
  current_target.to_stopped_data_address = debug_to_stopped_data_address;
  current_target.to_region_size_ok_for_hw_watchpoint = debug_to_region_size_ok_for_hw_watchpoint;
@


1.35.6.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a140 2
static void debug_to_terminal_save_ours (void);

a447 3
  de_fault (to_terminal_save_ours, 
	    (void (*) (void)) 
	    target_ignore);
a610 1
      INHERIT (to_terminal_save_ours, t);
a1982 8
debug_to_terminal_save_ours (void)
{
  debug_target.to_terminal_save_ours ();

  fprintf_unfiltered (gdb_stdlog, "target_terminal_save_ours ()\n");
}

static void
a2407 1
  current_target.to_terminal_save_ours = debug_to_terminal_save_ours;
@


1.35.6.5
log
@merge from mainline
@
text
@d1736 1
a1736 1
      deprecated_read_register_gen (regno, buf);
@


1.34
log
@2002-04-26  Ben Elliston  <bje@@redhat.com>

	* target.c (do_xfer_memory): Correct reference to the new option
	"trust-readonly-sections".
@
text
@d1656 29
d1688 1
a1688 8

  fprintf_unfiltered (gdb_stdlog, "target_fetch_registers (%s)",
		      regno != -1 ? REGISTER_NAME (regno) : "-1");
  if (regno != -1)
    fprintf_unfiltered (gdb_stdlog, " = 0x%lx %ld",
			(unsigned long) read_register (regno),
			(unsigned long) read_register (regno));
  fprintf_unfiltered (gdb_stdlog, "\n");
d1695 2
a1696 8

  if (regno >= 0 && regno < NUM_REGS)
    fprintf_unfiltered (gdb_stdlog, "target_store_registers (%s) = 0x%lx %ld\n",
			REGISTER_NAME (regno),
			(unsigned long) read_register (regno),
			(unsigned long) read_register (regno));
  else
    fprintf_unfiltered (gdb_stdlog, "target_store_registers (%d)\n", regno);
@


1.33
log
@2002-01-31  Michael Snyder  <msnyder@@redhat.com>

	* target.c (target_xfer_memory): Add spaces, coding standard.
@
text
@d864 3
a866 3
      /* User-settable option, "trust-readonly".  If true, then
	 memory from any SEC_READONLY bfd section may be read
	 directly from the bfd file. */
@


1.32
log
@2002-01-31  Michael Snyder  <msnyder@@redhat.com>

	* target.c (do_xfer_memory): Add missing line to trust-readonly
	code: check bfd SEC_READONLY flag for section.
@
text
@d952 1
a952 1
	    res = dcache_xfer_memory(target_dcache, memaddr, myaddr,
d955 1
a955 1
	    res = do_xfer_memory(memaddr, myaddr, reg_len, write,
d2300 1
a2300 1
  target_dcache = dcache_init();
@


1.31
log
@2002-01-15  Michael Snyder  <msnyder@@redhat.com>

	* target.c: New command, "set trust-readonly-sections on".
	(do_xfer_memory): Honor the suggestion to trust readonly sections
	by reading them from the object file instead of from the target.
	(initialize_targets): Register command "set trust-readonly-sections".
@
text
@d874 5
a878 3
	  if (memaddr >= secp->addr && memaddr < secp->endaddr)
	    return xfer_memory (memaddr, myaddr, len, 0, 
				attrib, &current_target);
@


1.30
log
@2002-01-03  Michael Snyder  <msnyder@@redhat.com>

	Implement a "generate-core-file" command in gdb, save target state.
	* gcore.c: New file.  Implement new command 'generate-core-file'.
	Save a corefile image of the current state of the inferior.
	* linux-proc.c: Add linux-specific code for saving corefiles.
	* target.h (struct target_ops): Add new target vectors for saving
	corefiles; to_find_memory_regions and to_make_corefile_notes.
	(target_find_memory_regions): New macro.
	(target_make_corefile_notes): New macro.
	* target.c (update_current_target): Inherit new target methods.
	(dummy_find_memory_regions): New place-holder method.
	(dummy_make_corefile_notes): New place-holder method.
	(init_dummy_target): Initialize new dummy target vectors.
	* exec.c (exec_set_find_memory_regions): New function.
	Allow the exec_ops vector for memory regions to be taken over.
	(exec_make_note_section): New function, target vector method.
	* defs.h (exec_set_find_memory_regions): Export prototype.
	* procfs.c (proc_find_memory_regions): New function, corefile method.
	(procfs_make_note_section): New function, corefile method.
	(init_procfs_ops): Set new target vector pointers.
	(find_memory_regions_callback): New function.
	(procfs_do_thread_registers): New function.
	(procfs_corefile_thread_callback): New function.
	* sol-thread.c (sol_find_memory_regions): New function.
	(sol_make_note_section): New function.
	(init_sol_thread_ops): Initialize new target vectors.
	* inftarg.c (inftarg_set_find_memory_regions): New function.
	Allow to_find_memory_regions vector to be taken over.
	(inftarg_set_make_corefile_notes): New function.
	Allow to_make_corefile_notes vector to be taken over.
	* thread-db.c (thread_db_new_objfile): Don't activate thread-db
	interface layer if not target_has_execution (may be a corefile).
	* config/i386/linux.mh: Add gcore.o to NATDEPFILES.
	* config/sparc/sun4sol2.mh: Ditto.
	* config/alpha/alpha-linux.mh: Ditto.
	* config/arm/linux.mh: Ditto.
	* config/i386/x86-64linux.mh: Ditto.
	* config/ia64/linux.mh: Ditto.
	* config/m68k/linux.mh: Ditto.
	* config/mips/linux.mh: Ditto.
	* config/powerpc/linux.mh: Ditto.
	* config/sparc/linux.mh: Ditto.
@
text
@d838 2
d862 18
d2277 4
a2280 4
  add_show_from_set (
		add_set_cmd ("target", class_maintenance, var_zinteger,
			     (char *) &targetdebug,
			     "Set target debugging.\n\
d2282 1
a2282 1
		      &showdebuglist);
d2284 10
@


1.29
log
@* target.c (cleanup_target): Do not initialize to_query to
return_zero.
@
text
@d3 2
a4 1
   2000, 2001 Free Software Foundation, Inc.
d611 2
d1467 16
d1499 2
@


1.28
log
@        * signals.c: New file.
        * Makefile.in: Add signals.o.
        * target.c (struct signals, target_signal_to_name)
        (target_signal_from_name, target_signal_from_host)
        (do_target_signal_to_host, target_signal_to_host_p)
        (target_signal_to_host, target_signal_from_command): Move to
        signals.c.
        (initialize_targets): Move check of struct signals to...
        * signals.c (_initialize_signals): Here.
@
text
@a490 3
  de_fault (to_query, 
	    (int (*) (int, char *, char *, int *)) 
	    return_zero);
@


1.27
log
@From 2001-06-08 Daniel Jacobowitz <djacobowitz@@mvista.com>:
* defs.h (enum target_signal): Add TARGET_SIGNAL_REALTIME_65
to TARGET_SIGNAL_REALTIME_127.
* target.c (struct signals): Add SIG63 to SIG127.
(target_signal_from_host): Handle up to 127 signals.
(do_target_signal_to_host): Likewise.
@
text
@a1402 786
/* This table must match in order and size the signals in enum target_signal
   in target.h.  */
/* *INDENT-OFF* */
static struct {
  char *name;
  char *string;
  } signals [] =
{
  {"0", "Signal 0"},
  {"SIGHUP", "Hangup"},
  {"SIGINT", "Interrupt"},
  {"SIGQUIT", "Quit"},
  {"SIGILL", "Illegal instruction"},
  {"SIGTRAP", "Trace/breakpoint trap"},
  {"SIGABRT", "Aborted"},
  {"SIGEMT", "Emulation trap"},
  {"SIGFPE", "Arithmetic exception"},
  {"SIGKILL", "Killed"},
  {"SIGBUS", "Bus error"},
  {"SIGSEGV", "Segmentation fault"},
  {"SIGSYS", "Bad system call"},
  {"SIGPIPE", "Broken pipe"},
  {"SIGALRM", "Alarm clock"},
  {"SIGTERM", "Terminated"},
  {"SIGURG", "Urgent I/O condition"},
  {"SIGSTOP", "Stopped (signal)"},
  {"SIGTSTP", "Stopped (user)"},
  {"SIGCONT", "Continued"},
  {"SIGCHLD", "Child status changed"},
  {"SIGTTIN", "Stopped (tty input)"},
  {"SIGTTOU", "Stopped (tty output)"},
  {"SIGIO", "I/O possible"},
  {"SIGXCPU", "CPU time limit exceeded"},
  {"SIGXFSZ", "File size limit exceeded"},
  {"SIGVTALRM", "Virtual timer expired"},
  {"SIGPROF", "Profiling timer expired"},
  {"SIGWINCH", "Window size changed"},
  {"SIGLOST", "Resource lost"},
  {"SIGUSR1", "User defined signal 1"},
  {"SIGUSR2", "User defined signal 2"},
  {"SIGPWR", "Power fail/restart"},
  {"SIGPOLL", "Pollable event occurred"},
  {"SIGWIND", "SIGWIND"},
  {"SIGPHONE", "SIGPHONE"},
  {"SIGWAITING", "Process's LWPs are blocked"},
  {"SIGLWP", "Signal LWP"},
  {"SIGDANGER", "Swap space dangerously low"},
  {"SIGGRANT", "Monitor mode granted"},
  {"SIGRETRACT", "Need to relinquish monitor mode"},
  {"SIGMSG", "Monitor mode data available"},
  {"SIGSOUND", "Sound completed"},
  {"SIGSAK", "Secure attention"},
  {"SIGPRIO", "SIGPRIO"},
  {"SIG33", "Real-time event 33"},
  {"SIG34", "Real-time event 34"},
  {"SIG35", "Real-time event 35"},
  {"SIG36", "Real-time event 36"},
  {"SIG37", "Real-time event 37"},
  {"SIG38", "Real-time event 38"},
  {"SIG39", "Real-time event 39"},
  {"SIG40", "Real-time event 40"},
  {"SIG41", "Real-time event 41"},
  {"SIG42", "Real-time event 42"},
  {"SIG43", "Real-time event 43"},
  {"SIG44", "Real-time event 44"},
  {"SIG45", "Real-time event 45"},
  {"SIG46", "Real-time event 46"},
  {"SIG47", "Real-time event 47"},
  {"SIG48", "Real-time event 48"},
  {"SIG49", "Real-time event 49"},
  {"SIG50", "Real-time event 50"},
  {"SIG51", "Real-time event 51"},
  {"SIG52", "Real-time event 52"},
  {"SIG53", "Real-time event 53"},
  {"SIG54", "Real-time event 54"},
  {"SIG55", "Real-time event 55"},
  {"SIG56", "Real-time event 56"},
  {"SIG57", "Real-time event 57"},
  {"SIG58", "Real-time event 58"},
  {"SIG59", "Real-time event 59"},
  {"SIG60", "Real-time event 60"},
  {"SIG61", "Real-time event 61"},
  {"SIG62", "Real-time event 62"},
  {"SIG63", "Real-time event 63"},
  {"SIGCANCEL", "LWP internal signal"},
  {"SIG32", "Real-time event 32"},
  {"SIG64", "Real-time event 64"},
  {"SIG65", "Real-time event 65"},
  {"SIG66", "Real-time event 66"},
  {"SIG67", "Real-time event 67"},
  {"SIG68", "Real-time event 68"},
  {"SIG69", "Real-time event 69"},
  {"SIG70", "Real-time event 70"},
  {"SIG71", "Real-time event 71"},
  {"SIG72", "Real-time event 72"},
  {"SIG73", "Real-time event 73"},
  {"SIG74", "Real-time event 74"},
  {"SIG75", "Real-time event 75"},
  {"SIG76", "Real-time event 76"},
  {"SIG77", "Real-time event 77"},
  {"SIG78", "Real-time event 78"},
  {"SIG79", "Real-time event 79"},
  {"SIG80", "Real-time event 80"},
  {"SIG81", "Real-time event 81"},
  {"SIG82", "Real-time event 82"},
  {"SIG83", "Real-time event 83"},
  {"SIG84", "Real-time event 84"},
  {"SIG85", "Real-time event 85"},
  {"SIG86", "Real-time event 86"},
  {"SIG87", "Real-time event 87"},
  {"SIG88", "Real-time event 88"},
  {"SIG89", "Real-time event 89"},
  {"SIG90", "Real-time event 90"},
  {"SIG91", "Real-time event 91"},
  {"SIG92", "Real-time event 92"},
  {"SIG93", "Real-time event 93"},
  {"SIG94", "Real-time event 94"},
  {"SIG95", "Real-time event 95"},
  {"SIG96", "Real-time event 96"},
  {"SIG97", "Real-time event 97"},
  {"SIG98", "Real-time event 98"},
  {"SIG99", "Real-time event 99"},
  {"SIG100", "Real-time event 100"},
  {"SIG101", "Real-time event 101"},
  {"SIG102", "Real-time event 102"},
  {"SIG103", "Real-time event 103"},
  {"SIG104", "Real-time event 104"},
  {"SIG105", "Real-time event 105"},
  {"SIG106", "Real-time event 106"},
  {"SIG107", "Real-time event 107"},
  {"SIG108", "Real-time event 108"},
  {"SIG109", "Real-time event 109"},
  {"SIG110", "Real-time event 110"},
  {"SIG111", "Real-time event 111"},
  {"SIG112", "Real-time event 112"},
  {"SIG113", "Real-time event 113"},
  {"SIG114", "Real-time event 114"},
  {"SIG115", "Real-time event 115"},
  {"SIG116", "Real-time event 116"},
  {"SIG117", "Real-time event 117"},
  {"SIG118", "Real-time event 118"},
  {"SIG119", "Real-time event 119"},
  {"SIG120", "Real-time event 120"},
  {"SIG121", "Real-time event 121"},
  {"SIG122", "Real-time event 122"},
  {"SIG123", "Real-time event 123"},
  {"SIG124", "Real-time event 124"},
  {"SIG125", "Real-time event 125"},
  {"SIG126", "Real-time event 126"},
  {"SIG127", "Real-time event 127"},

#if defined(MACH) || defined(__MACH__)
  /* Mach exceptions */
  {"EXC_BAD_ACCESS", "Could not access memory"},
  {"EXC_BAD_INSTRUCTION", "Illegal instruction/operand"},
  {"EXC_ARITHMETIC", "Arithmetic exception"},
  {"EXC_EMULATION", "Emulation instruction"},
  {"EXC_SOFTWARE", "Software generated exception"},
  {"EXC_BREAKPOINT", "Breakpoint"},
#endif
  {"SIGINFO", "Information request"},

  {NULL, "Unknown signal"},
  {NULL, "Internal error: printing TARGET_SIGNAL_DEFAULT"},

  /* Last entry, used to check whether the table is the right size.  */
  {NULL, "TARGET_SIGNAL_MAGIC"}
};
/* *INDENT-ON* */



/* Return the string for a signal.  */
char *
target_signal_to_string (enum target_signal sig)
{
  if ((sig >= TARGET_SIGNAL_FIRST) && (sig <= TARGET_SIGNAL_LAST))
    return signals[sig].string;
  else
    return signals[TARGET_SIGNAL_UNKNOWN].string;
}

/* Return the name for a signal.  */
char *
target_signal_to_name (enum target_signal sig)
{
  if (sig == TARGET_SIGNAL_UNKNOWN)
    /* I think the code which prints this will always print it along with
       the string, so no need to be verbose.  */
    return "?";
  return signals[sig].name;
}

/* Given a name, return its signal.  */
enum target_signal
target_signal_from_name (char *name)
{
  enum target_signal sig;

  /* It's possible we also should allow "SIGCLD" as well as "SIGCHLD"
     for TARGET_SIGNAL_SIGCHLD.  SIGIOT, on the other hand, is more
     questionable; seems like by now people should call it SIGABRT
     instead.  */

  /* This ugly cast brought to you by the native VAX compiler.  */
  for (sig = TARGET_SIGNAL_HUP;
       signals[sig].name != NULL;
       sig = (enum target_signal) ((int) sig + 1))
    if (STREQ (name, signals[sig].name))
      return sig;
  return TARGET_SIGNAL_UNKNOWN;
}

/* The following functions are to help certain targets deal
   with the signal/waitstatus stuff.  They could just as well be in
   a file called native-utils.c or unixwaitstatus-utils.c or whatever.  */

/* Convert host signal to our signals.  */
enum target_signal
target_signal_from_host (int hostsig)
{
  /* A switch statement would make sense but would require special kludges
     to deal with the cases where more than one signal has the same number.  */

  if (hostsig == 0)
    return TARGET_SIGNAL_0;

#if defined (SIGHUP)
  if (hostsig == SIGHUP)
    return TARGET_SIGNAL_HUP;
#endif
#if defined (SIGINT)
  if (hostsig == SIGINT)
    return TARGET_SIGNAL_INT;
#endif
#if defined (SIGQUIT)
  if (hostsig == SIGQUIT)
    return TARGET_SIGNAL_QUIT;
#endif
#if defined (SIGILL)
  if (hostsig == SIGILL)
    return TARGET_SIGNAL_ILL;
#endif
#if defined (SIGTRAP)
  if (hostsig == SIGTRAP)
    return TARGET_SIGNAL_TRAP;
#endif
#if defined (SIGABRT)
  if (hostsig == SIGABRT)
    return TARGET_SIGNAL_ABRT;
#endif
#if defined (SIGEMT)
  if (hostsig == SIGEMT)
    return TARGET_SIGNAL_EMT;
#endif
#if defined (SIGFPE)
  if (hostsig == SIGFPE)
    return TARGET_SIGNAL_FPE;
#endif
#if defined (SIGKILL)
  if (hostsig == SIGKILL)
    return TARGET_SIGNAL_KILL;
#endif
#if defined (SIGBUS)
  if (hostsig == SIGBUS)
    return TARGET_SIGNAL_BUS;
#endif
#if defined (SIGSEGV)
  if (hostsig == SIGSEGV)
    return TARGET_SIGNAL_SEGV;
#endif
#if defined (SIGSYS)
  if (hostsig == SIGSYS)
    return TARGET_SIGNAL_SYS;
#endif
#if defined (SIGPIPE)
  if (hostsig == SIGPIPE)
    return TARGET_SIGNAL_PIPE;
#endif
#if defined (SIGALRM)
  if (hostsig == SIGALRM)
    return TARGET_SIGNAL_ALRM;
#endif
#if defined (SIGTERM)
  if (hostsig == SIGTERM)
    return TARGET_SIGNAL_TERM;
#endif
#if defined (SIGUSR1)
  if (hostsig == SIGUSR1)
    return TARGET_SIGNAL_USR1;
#endif
#if defined (SIGUSR2)
  if (hostsig == SIGUSR2)
    return TARGET_SIGNAL_USR2;
#endif
#if defined (SIGCLD)
  if (hostsig == SIGCLD)
    return TARGET_SIGNAL_CHLD;
#endif
#if defined (SIGCHLD)
  if (hostsig == SIGCHLD)
    return TARGET_SIGNAL_CHLD;
#endif
#if defined (SIGPWR)
  if (hostsig == SIGPWR)
    return TARGET_SIGNAL_PWR;
#endif
#if defined (SIGWINCH)
  if (hostsig == SIGWINCH)
    return TARGET_SIGNAL_WINCH;
#endif
#if defined (SIGURG)
  if (hostsig == SIGURG)
    return TARGET_SIGNAL_URG;
#endif
#if defined (SIGIO)
  if (hostsig == SIGIO)
    return TARGET_SIGNAL_IO;
#endif
#if defined (SIGPOLL)
  if (hostsig == SIGPOLL)
    return TARGET_SIGNAL_POLL;
#endif
#if defined (SIGSTOP)
  if (hostsig == SIGSTOP)
    return TARGET_SIGNAL_STOP;
#endif
#if defined (SIGTSTP)
  if (hostsig == SIGTSTP)
    return TARGET_SIGNAL_TSTP;
#endif
#if defined (SIGCONT)
  if (hostsig == SIGCONT)
    return TARGET_SIGNAL_CONT;
#endif
#if defined (SIGTTIN)
  if (hostsig == SIGTTIN)
    return TARGET_SIGNAL_TTIN;
#endif
#if defined (SIGTTOU)
  if (hostsig == SIGTTOU)
    return TARGET_SIGNAL_TTOU;
#endif
#if defined (SIGVTALRM)
  if (hostsig == SIGVTALRM)
    return TARGET_SIGNAL_VTALRM;
#endif
#if defined (SIGPROF)
  if (hostsig == SIGPROF)
    return TARGET_SIGNAL_PROF;
#endif
#if defined (SIGXCPU)
  if (hostsig == SIGXCPU)
    return TARGET_SIGNAL_XCPU;
#endif
#if defined (SIGXFSZ)
  if (hostsig == SIGXFSZ)
    return TARGET_SIGNAL_XFSZ;
#endif
#if defined (SIGWIND)
  if (hostsig == SIGWIND)
    return TARGET_SIGNAL_WIND;
#endif
#if defined (SIGPHONE)
  if (hostsig == SIGPHONE)
    return TARGET_SIGNAL_PHONE;
#endif
#if defined (SIGLOST)
  if (hostsig == SIGLOST)
    return TARGET_SIGNAL_LOST;
#endif
#if defined (SIGWAITING)
  if (hostsig == SIGWAITING)
    return TARGET_SIGNAL_WAITING;
#endif
#if defined (SIGCANCEL)
  if (hostsig == SIGCANCEL)
    return TARGET_SIGNAL_CANCEL;
#endif
#if defined (SIGLWP)
  if (hostsig == SIGLWP)
    return TARGET_SIGNAL_LWP;
#endif
#if defined (SIGDANGER)
  if (hostsig == SIGDANGER)
    return TARGET_SIGNAL_DANGER;
#endif
#if defined (SIGGRANT)
  if (hostsig == SIGGRANT)
    return TARGET_SIGNAL_GRANT;
#endif
#if defined (SIGRETRACT)
  if (hostsig == SIGRETRACT)
    return TARGET_SIGNAL_RETRACT;
#endif
#if defined (SIGMSG)
  if (hostsig == SIGMSG)
    return TARGET_SIGNAL_MSG;
#endif
#if defined (SIGSOUND)
  if (hostsig == SIGSOUND)
    return TARGET_SIGNAL_SOUND;
#endif
#if defined (SIGSAK)
  if (hostsig == SIGSAK)
    return TARGET_SIGNAL_SAK;
#endif
#if defined (SIGPRIO)
  if (hostsig == SIGPRIO)
    return TARGET_SIGNAL_PRIO;
#endif

  /* Mach exceptions.  Assumes that the values for EXC_ are positive! */
#if defined (EXC_BAD_ACCESS) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_BAD_ACCESS)
    return TARGET_EXC_BAD_ACCESS;
#endif
#if defined (EXC_BAD_INSTRUCTION) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_BAD_INSTRUCTION)
    return TARGET_EXC_BAD_INSTRUCTION;
#endif
#if defined (EXC_ARITHMETIC) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_ARITHMETIC)
    return TARGET_EXC_ARITHMETIC;
#endif
#if defined (EXC_EMULATION) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_EMULATION)
    return TARGET_EXC_EMULATION;
#endif
#if defined (EXC_SOFTWARE) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_SOFTWARE)
    return TARGET_EXC_SOFTWARE;
#endif
#if defined (EXC_BREAKPOINT) && defined (_NSIG)
  if (hostsig == _NSIG + EXC_BREAKPOINT)
    return TARGET_EXC_BREAKPOINT;
#endif

#if defined (SIGINFO)
  if (hostsig == SIGINFO)
    return TARGET_SIGNAL_INFO;
#endif

#if defined (REALTIME_LO)
  if (hostsig >= REALTIME_LO && hostsig < REALTIME_HI)
    {
      /* This block of TARGET_SIGNAL_REALTIME value is in order.  */
      if (33 <= hostsig && hostsig <= 63)
	return (enum target_signal)
	  (hostsig - 33 + (int) TARGET_SIGNAL_REALTIME_33);
      else if (hostsig == 32)
	return TARGET_SIGNAL_REALTIME_32;
      else if (64 <= hostsig && hostsig <= 127)
	return (enum target_signal)
	  (hostsig - 64 + (int) TARGET_SIGNAL_REALTIME_64);
      else
	error ("GDB bug: target.c (target_signal_from_host): unrecognized real-time signal");
    }
#endif

#if defined (SIGRTMIN)
  if (hostsig >= SIGRTMIN && hostsig <= SIGRTMAX)
    {
      /* This block of TARGET_SIGNAL_REALTIME value is in order.  */
      if (33 <= hostsig && hostsig <= 63)
	return (enum target_signal)
	  (hostsig - 33 + (int) TARGET_SIGNAL_REALTIME_33);
      else if (hostsig == 64)
	return TARGET_SIGNAL_REALTIME_64;
      else
	error ("GDB bug: target.c (target_signal_from_host): unrecognized real-time signal");
    }
#endif
  return TARGET_SIGNAL_UNKNOWN;
}

/* Convert a OURSIG (an enum target_signal) to the form used by the
   target operating system (refered to as the ``host'') or zero if the
   equivalent host signal is not available.  Set/clear OURSIG_OK
   accordingly. */

static int
do_target_signal_to_host (enum target_signal oursig,
			  int *oursig_ok)
{
  *oursig_ok = 1;
  switch (oursig)
    {
    case TARGET_SIGNAL_0:
      return 0;

#if defined (SIGHUP)
    case TARGET_SIGNAL_HUP:
      return SIGHUP;
#endif
#if defined (SIGINT)
    case TARGET_SIGNAL_INT:
      return SIGINT;
#endif
#if defined (SIGQUIT)
    case TARGET_SIGNAL_QUIT:
      return SIGQUIT;
#endif
#if defined (SIGILL)
    case TARGET_SIGNAL_ILL:
      return SIGILL;
#endif
#if defined (SIGTRAP)
    case TARGET_SIGNAL_TRAP:
      return SIGTRAP;
#endif
#if defined (SIGABRT)
    case TARGET_SIGNAL_ABRT:
      return SIGABRT;
#endif
#if defined (SIGEMT)
    case TARGET_SIGNAL_EMT:
      return SIGEMT;
#endif
#if defined (SIGFPE)
    case TARGET_SIGNAL_FPE:
      return SIGFPE;
#endif
#if defined (SIGKILL)
    case TARGET_SIGNAL_KILL:
      return SIGKILL;
#endif
#if defined (SIGBUS)
    case TARGET_SIGNAL_BUS:
      return SIGBUS;
#endif
#if defined (SIGSEGV)
    case TARGET_SIGNAL_SEGV:
      return SIGSEGV;
#endif
#if defined (SIGSYS)
    case TARGET_SIGNAL_SYS:
      return SIGSYS;
#endif
#if defined (SIGPIPE)
    case TARGET_SIGNAL_PIPE:
      return SIGPIPE;
#endif
#if defined (SIGALRM)
    case TARGET_SIGNAL_ALRM:
      return SIGALRM;
#endif
#if defined (SIGTERM)
    case TARGET_SIGNAL_TERM:
      return SIGTERM;
#endif
#if defined (SIGUSR1)
    case TARGET_SIGNAL_USR1:
      return SIGUSR1;
#endif
#if defined (SIGUSR2)
    case TARGET_SIGNAL_USR2:
      return SIGUSR2;
#endif
#if defined (SIGCHLD) || defined (SIGCLD)
    case TARGET_SIGNAL_CHLD:
#if defined (SIGCHLD)
      return SIGCHLD;
#else
      return SIGCLD;
#endif
#endif /* SIGCLD or SIGCHLD */
#if defined (SIGPWR)
    case TARGET_SIGNAL_PWR:
      return SIGPWR;
#endif
#if defined (SIGWINCH)
    case TARGET_SIGNAL_WINCH:
      return SIGWINCH;
#endif
#if defined (SIGURG)
    case TARGET_SIGNAL_URG:
      return SIGURG;
#endif
#if defined (SIGIO)
    case TARGET_SIGNAL_IO:
      return SIGIO;
#endif
#if defined (SIGPOLL)
    case TARGET_SIGNAL_POLL:
      return SIGPOLL;
#endif
#if defined (SIGSTOP)
    case TARGET_SIGNAL_STOP:
      return SIGSTOP;
#endif
#if defined (SIGTSTP)
    case TARGET_SIGNAL_TSTP:
      return SIGTSTP;
#endif
#if defined (SIGCONT)
    case TARGET_SIGNAL_CONT:
      return SIGCONT;
#endif
#if defined (SIGTTIN)
    case TARGET_SIGNAL_TTIN:
      return SIGTTIN;
#endif
#if defined (SIGTTOU)
    case TARGET_SIGNAL_TTOU:
      return SIGTTOU;
#endif
#if defined (SIGVTALRM)
    case TARGET_SIGNAL_VTALRM:
      return SIGVTALRM;
#endif
#if defined (SIGPROF)
    case TARGET_SIGNAL_PROF:
      return SIGPROF;
#endif
#if defined (SIGXCPU)
    case TARGET_SIGNAL_XCPU:
      return SIGXCPU;
#endif
#if defined (SIGXFSZ)
    case TARGET_SIGNAL_XFSZ:
      return SIGXFSZ;
#endif
#if defined (SIGWIND)
    case TARGET_SIGNAL_WIND:
      return SIGWIND;
#endif
#if defined (SIGPHONE)
    case TARGET_SIGNAL_PHONE:
      return SIGPHONE;
#endif
#if defined (SIGLOST)
    case TARGET_SIGNAL_LOST:
      return SIGLOST;
#endif
#if defined (SIGWAITING)
    case TARGET_SIGNAL_WAITING:
      return SIGWAITING;
#endif
#if defined (SIGCANCEL)
    case TARGET_SIGNAL_CANCEL:
      return SIGCANCEL;
#endif
#if defined (SIGLWP)
    case TARGET_SIGNAL_LWP:
      return SIGLWP;
#endif
#if defined (SIGDANGER)
    case TARGET_SIGNAL_DANGER:
      return SIGDANGER;
#endif
#if defined (SIGGRANT)
    case TARGET_SIGNAL_GRANT:
      return SIGGRANT;
#endif
#if defined (SIGRETRACT)
    case TARGET_SIGNAL_RETRACT:
      return SIGRETRACT;
#endif
#if defined (SIGMSG)
    case TARGET_SIGNAL_MSG:
      return SIGMSG;
#endif
#if defined (SIGSOUND)
    case TARGET_SIGNAL_SOUND:
      return SIGSOUND;
#endif
#if defined (SIGSAK)
    case TARGET_SIGNAL_SAK:
      return SIGSAK;
#endif
#if defined (SIGPRIO)
    case TARGET_SIGNAL_PRIO:
      return SIGPRIO;
#endif

      /* Mach exceptions.  Assumes that the values for EXC_ are positive! */
#if defined (EXC_BAD_ACCESS) && defined (_NSIG)
    case TARGET_EXC_BAD_ACCESS:
      return _NSIG + EXC_BAD_ACCESS;
#endif
#if defined (EXC_BAD_INSTRUCTION) && defined (_NSIG)
    case TARGET_EXC_BAD_INSTRUCTION:
      return _NSIG + EXC_BAD_INSTRUCTION;
#endif
#if defined (EXC_ARITHMETIC) && defined (_NSIG)
    case TARGET_EXC_ARITHMETIC:
      return _NSIG + EXC_ARITHMETIC;
#endif
#if defined (EXC_EMULATION) && defined (_NSIG)
    case TARGET_EXC_EMULATION:
      return _NSIG + EXC_EMULATION;
#endif
#if defined (EXC_SOFTWARE) && defined (_NSIG)
    case TARGET_EXC_SOFTWARE:
      return _NSIG + EXC_SOFTWARE;
#endif
#if defined (EXC_BREAKPOINT) && defined (_NSIG)
    case TARGET_EXC_BREAKPOINT:
      return _NSIG + EXC_BREAKPOINT;
#endif

#if defined (SIGINFO)
    case TARGET_SIGNAL_INFO:
      return SIGINFO;
#endif

    default:
#if defined (REALTIME_LO)
      if (oursig >= TARGET_SIGNAL_REALTIME_33
	  && oursig <= TARGET_SIGNAL_REALTIME_63)
	{
	  /* This block of signals is continuous, and
             TARGET_SIGNAL_REALTIME_33 is 33 by definition.  */
	  int retsig =
	    (int) oursig - (int) TARGET_SIGNAL_REALTIME_33 + 33;
	  if (retsig >= REALTIME_LO && retsig < REALTIME_HI)
	    return retsig;
	}
#if (REALTIME_LO < 33)
      else if (oursig == TARGET_SIGNAL_REALTIME_32)
	{
	  /* TARGET_SIGNAL_REALTIME_32 isn't contiguous with
             TARGET_SIGNAL_REALTIME_33.  It is 32 by definition.  */
	  return 32;
	}
#endif
#if (REALTIME_HI > 64)
      if (oursig >= TARGET_SIGNAL_REALTIME_64
	  && oursig <= TARGET_SIGNAL_REALTIME_127)
	{
	  /* This block of signals is continuous, and
             TARGET_SIGNAL_REALTIME_64 is 64 by definition.  */
	  int retsig =
	    (int) oursig - (int) TARGET_SIGNAL_REALTIME_64 + 64;
	  if (retsig >= REALTIME_LO && retsig < REALTIME_HI)
	    return retsig;
	}
      
#endif
#endif

#if defined (SIGRTMIN)
      if (oursig >= TARGET_SIGNAL_REALTIME_33
	  && oursig <= TARGET_SIGNAL_REALTIME_63)
	{
	  /* This block of signals is continuous, and
             TARGET_SIGNAL_REALTIME_33 is 33 by definition.  */
	  int retsig =
	    (int) oursig - (int) TARGET_SIGNAL_REALTIME_33 + 33;
	  if (retsig >= SIGRTMIN && retsig <= SIGRTMAX)
	    return retsig;
	}
      else if (oursig == TARGET_SIGNAL_REALTIME_64)
	return 64;
#endif
      *oursig_ok = 0;
      return 0;
    }
}

int
target_signal_to_host_p (enum target_signal oursig)
{
  int oursig_ok;
  do_target_signal_to_host (oursig, &oursig_ok);
  return oursig_ok;
}

int
target_signal_to_host (enum target_signal oursig)
{
  int oursig_ok;
  int targ_signo = do_target_signal_to_host (oursig, &oursig_ok);
  if (!oursig_ok)
    {
      /* The user might be trying to do "signal SIGSAK" where this system
         doesn't have SIGSAK.  */
      warning ("Signal %s does not exist on this system.\n",
	       target_signal_to_name (oursig));
      return 0;
    }
  else
    return targ_signo;
}

a1432 17
/* In some circumstances we allow a command to specify a numeric
   signal.  The idea is to keep these circumstances limited so that
   users (and scripts) develop portable habits.  For comparison,
   POSIX.2 `kill' requires that 1,2,3,6,9,14, and 15 work (and using a
   numeric signal at all is obsolescent.  We are slightly more
   lenient and allow 1-15 which should match host signal numbers on
   most systems.  Use of symbolic signal names is strongly encouraged.  */

enum target_signal
target_signal_from_command (int num)
{
  if (num >= 1 && num <= 15)
    return (enum target_signal) num;
  error ("Only signals 1-15 are valid as numeric signals.\n\
Use \"info signals\" for a list of symbolic signals.");
}

a2250 3

  if (!STREQ (signals[TARGET_SIGNAL_LAST].string, "TARGET_SIGNAL_MAGIC"))
    internal_error (__FILE__, __LINE__, "failed internal consistency check");
@


1.26
log
@Phase 1 of the ptid_t changes.
@
text
@d1490 63
d1855 3
d2129 13
@


1.25
log
@2001-04-26  Michael Snyder  <msnyder@@redhat.com>

	* target.c (normal_pid_to_str): Get rid of an ancient hack.
	* remote.c (remote_pid_to_str): New function for remote target.
@
text
@d74 1
a74 1
static void normal_target_post_startup_inferior (int pid);
d95 1
a95 1
static void debug_to_resume (int, int, enum target_signal);
d97 1
a97 1
static int debug_to_wait (int, struct target_waitstatus *);
d137 1
a137 1
static void debug_to_notice_signals (int);
d139 1
a139 1
static int debug_to_thread_alive (int);
d274 1
a274 1
  if (!inferior_pid)
d366 1
a366 1
	    (void (*) (int, int, enum target_signal)) 
d369 1
a369 1
	    (int (*) (int, struct target_waitstatus *)) 
d372 1
a372 1
	    (void (*) (int, int)) 
d419 1
a419 1
	    (void (*) (int)) 
d477 1
a477 1
	    (void (*) (int)) 
d480 1
a480 1
	    (int (*) (int)) 
d1379 1
a1379 1
  inferior_pid = 0;
d2165 1
a2165 1
normal_pid_to_str (int pid)
d2169 1
a2169 1
  sprintf (buf, "process %d", pid);
d2186 1
a2186 1
normal_target_post_startup_inferior (int pid)
d2273 1
a2273 1
debug_to_resume (int pid, int step, enum target_signal siggnal)
d2275 1
a2275 1
  debug_target.to_resume (pid, step, siggnal);
d2277 1
a2277 1
  fprintf_unfiltered (gdb_stdlog, "target_resume (%d, %s, %s)\n", pid,
d2282 2
a2283 2
static int
debug_to_wait (int pid, struct target_waitstatus *status)
d2285 1
a2285 1
  int retval;
d2287 1
a2287 1
  retval = debug_target.to_wait (pid, status);
d2290 2
a2291 1
		      "target_wait (%d, status) = %d,   ", pid, retval);
d2331 1
a2331 1
debug_to_post_wait (int pid, int status)
d2333 1
a2333 1
  debug_target.to_post_wait (pid, status);
d2336 1
a2336 1
		      pid, status);
d2525 1
a2525 1
debug_to_post_startup_inferior (int pid)
d2527 1
a2527 1
  debug_target.to_post_startup_inferior (pid);
d2530 1
a2530 1
		      pid);
d2780 1
a2780 1
debug_to_notice_signals (int pid)
d2782 1
a2782 1
  debug_target.to_notice_signals (pid);
d2784 2
a2785 1
  fprintf_unfiltered (gdb_stdlog, "target_notice_signals (%d)\n", pid);
d2789 1
a2789 1
debug_to_thread_alive (int pid)
d2793 1
a2793 1
  retval = debug_target.to_thread_alive (pid);
d2796 1
a2796 1
		      pid, retval);
@


1.24
log
@* target.h (target_ops): Removed to_core_file_to_sym_file vector
function.
* corelow.c (core_ops): Updated for above change.
* gnu-nat.c (core_ops): Likewise.
* inftarg.c (child_ops): Likewise.
* monitor.c (monitor_ops): Likewise.
* ppc-bdm.c (bdm_ppc_ops): Likewise.
* remote-adapt.c (adapt_ops): Likewise.
* remote-bug.c (bug_ops): Likewise.
* remote-e7000.c (e7000_ops): Likewise.
* remote-eb.c (eb_ops): Likewise.
* remote-es.c (es1800_ops, es1800_child_ops): Likewise.
* remote-mm.c (mm_ops): Likewise.
* remote-nindy.c (nindy_ops): Likewise.
* remote-nrom.c (nrom_ops): Likewise.
* remote-os9k.c (rombug_ops): Likewise.
* remote-rdp.c (remote_rdp_ops): Likewise.
* remote-sim.c (gdbsim_ops): Likewise.
* remote-st.c (st2000_ops): Likewise.
* v850ice.c (v850ice_ops): Likewise.
* target.c (cleanup_target): Likewise
(update_current_target): Likewise.
(setup_target_debug): Likewise
(debug_to_core_file_to_sym_file): Removed.

* corefile.c (core_file_command) [HPUXHPPA]: Removed code that
sets symbol file from information obtained from the core file.
* corelow.c (core_file_to_sym_file): Removed.
@
text
@d2169 1
a2169 5
  if (STREQ (current_target.to_shortname, "remote"))
    sprintf (buf, "thread %d", pid);
  else
    sprintf (buf, "process %d", pid);

@


1.23
log
@2001-03-06  J.T. Conklin  <jtc@@redback.com>

        * symtab.h (decode_line_1): Removed declaration.

        * symfile.c (#include <assert.h>): Removed.

        * arch-utils.c (#include <ctype.h>): Removed.
        * c-typeprint.c: Likewise.
        * dbxread.c: Likewise.
        * gdbtypes.c: Likewise.
        * target.c: Likewise.
        * os9kread.c: Likewise.

        * c-valprint.c (#include "demangle.h"): Removed.
        * ch-typeprint.c: Likewise.
        * eval.c: Likewise.
        * f-typeprint.c: Likewise.
        * f-valprint.c: Likewise.
        * m2-typeprint.c: Likewise.
        * typeprint.c: Likewise.
        * p-typeprint.c: Likewise.
        * valarith.c: Likewise.
        * valprint.c: Likewise.

        * m2-typeprint.c (#include "gdb_string.h"): Removed.
        * nlmread.c: Likewise.

        * mdebugread.c (#include "gdb-stabs.h"): Removed.
        * minsyms.c: Likewise.
        * mipsread.c: Likewise.
        * nlmread.c: Likewise.

        * m2-typeprint.c (#include "obstack.h"): Removed.
        * m2-valprint.c: Likewise.

        * event-loop.c (#include <setjmp.h>): Removed.
@
text
@a505 3
  de_fault (to_core_file_to_sym_file, 
	    (char *(*) (char *)) 
	    return_zero);
a598 1
      INHERIT (to_core_file_to_sym_file, t);
a2871 13
static char *
debug_to_core_file_to_sym_file (char *core)
{
  char *sym_file;

  sym_file = debug_target.to_core_file_to_sym_file (core);

  fprintf_unfiltered (gdb_stdlog, "target_core_file_to_sym_file (%s) = %s\n",
		      core, sym_file);

  return sym_file;
}

a2931 1
  current_target.to_core_file_to_sym_file = debug_to_core_file_to_sym_file;
@


1.22
log
@Update/correct copyright notices.
@
text
@a24 1
#include <ctype.h>
@


1.21
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1990, 1992-1995, 1998-2000, 2001 Free Software Foundation, Inc.
@


1.20
log
@Replace calls to abort() with calls to internal_error().
@
text
@d36 1
@


1.19
log
@* target.c (target_xfer_memory_partial): Return -1 on failure due
to invalid access mode attribute.
@
text
@d644 1
a644 1
      abort ();
d740 1
a740 1
  abort ();
d2996 1
a2996 1
    abort ();
@


1.18
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@d994 1
a994 1
	  return 0;
d1002 1
a1002 1
	  return 0;
@


1.17
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright 1990, 1992-1995, 1998-2000 Free Software Foundation, Inc.
d105 2
a106 1
debug_to_xfer_memory (CORE_ADDR, char *, int, int, struct target_ops *);
d383 1
a383 1
	    (int (*) (CORE_ADDR, char *, int, int, struct target_ops *)) 
d847 2
a848 1
do_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write)
d865 1
a865 1
    (memaddr, myaddr, len, write, &current_target);
d876 1
a876 1
	  res = t->to_xfer_memory (memaddr, myaddr, len, write, t);
d900 2
d911 7
a917 2
      res = dcache_xfer_memory(target_dcache, memaddr, myaddr, len, write);
      if (res <= 0)
d919 6
a924 2
	  /* If this address is for nonexistent memory,
	     read zeros if reading, or do nothing if writing.  Return error. */
a925 2
	    memset (myaddr, 0, len);
	  if (errno == 0)
d927 8
d936 20
a955 1
	    return errno;
a956 4

      memaddr += res;
      myaddr  += res;
      len     -= res;
d972 2
d982 32
a1013 1
  res = dcache_xfer_memory (target_dcache, memaddr, myaddr, len, write_p);
d2383 1
d2388 2
a2389 1
  retval = debug_target.to_xfer_memory (memaddr, myaddr, len, write, target);
@


1.16
log
@	* target.h (TARGET_SIGNAL_REALTIME_64):  Added for IRIX 6.
	* target.c (target_signal_from_host, do_target_signal_to_host):
	Handle TARGET_SIGNAL_REALTIME_64.
@
text
@d667 1
a667 1
	free (cur);
d721 1
a721 1
  free (cur);			/* Release the target_stack_item */
@


1.15
log
@2000-11-10  J.T. Conklin  <jtc@@redback.com>

        * target.c (do_xfer_memory): Only perform a single memory transfer
        instead of iterating to tranfer the entire region.  Higher layers
        are expected to call this function multiple times for partial
        transfers.
        (target_xfer_memory_partial): Remove unused local variables.

2000-11-10  Nick Duffek  <nsd@@redhat.com>

        * target.c (target_xfer_memory_partial): Return bytes transferred
        instead of 0.
@
text
@d1425 1
d1740 2
d2013 2
@


1.14
log
@* TODO: Note abstraction layer violation where "ocd reset" command
must invalidate the dcache, and how this might be fixed.

* monitor.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(monitor_open): Removed code that created local dcache.
(flush_monitor_dcache): Removed (unused function).
(monitor_resume): Removed call to dcache_invd().
(monitor_load): Likewise.
(monitor_xfer_memory): Changed to call monitor_write_memory(),
monitor_write_memory_block(), and monitor_read_memory() instead
of dcache_xfer_memory().
* monitor.h (flush_monitor_dcache): Removed (unused function).
* ocd.c (#include "dcache.h"): Removed.
(ocd_dcache): Removed.
(ocd_open): Removed code that created local dcache.
(ocd_resume): Removed call to dcache_invd().
(ocd_xfer_memory): Changed to call ocd_write_bytes() and
ocd_read_bytes() instead of dcache_xfer_memory().
(bdm_reset_command): Invalidate target dcache.
* remote-bug.c (bug_load): Remove call to dcache_invd().
(bug_resume): Likewise.
(bug_settings): Remove dcache, readfunc, and writefunc fields
from initializer.
(bug_xfer_memory): Changed to call bug_read_memory() and
bug_write_memory() instead of dcache_xfer_memory().
* remote-nindy.c (#include "dcache.h"): Removed.
(nindy_dcache): Removed.
(nindy_open): Removed code that created local dcache.
(nindy_resume): Removed call to dcache_invd().
(nindy_load): Likewise.
(nindy_xfer_inferior_memory): Changed to call ninMemPut() and
ninMemGet() instead of dcache_xfer_memory().
* remote-sds.c (#include "dcache.h"): Removed.
(sds_dcache): Removed.
(sds_open): Removed code that created local dcache.
(sds_resume): Removed call to dcache_invd().
(sds_xfer_memory): Changed to call sds_write_bytes() and
sds_read_bytes() instead of dcache_xfer_memory().
* remote-utils.c (gr_open): Removed code that created local dcache.
* remote-utils.h (#include "dcache.h"): Removed.
(struct gr_settings): Removed dcache, readfunc, and writefunc fields.
(gr_get_dcache, gr_set_dcache): Removed macro definitions.
* remote.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(remote_open_1): Removed code that created local dcache.
(remote_async_open_1): Likewise.
(remote_resume): Removed call to dcache_invd().
(remote_async_resume): Likewise.
(remote_xfer_memory): Changed to call remote_write_bytes() and
remote_read_bytes() instead of dcache_xfer_memory().
* wince.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(child_create_inferior): Removed code that created local dcache.
(child_xfer_memory): Changed to call remote_write_bytes() and
remote_read_bytes() instead of dcache_xfer_memory().
(child_resume): Removed call to dcache_invd().

* target.c (target_dcache): Added.
(target_load): Invalidate target_dcache.
(do_xfer_memory): New function.
(target_xfer_memory): Reimplement in terms of dcache_xfer_memory().
(target_xfer_memory_partial): Likewise.
(initialize_targets): Create target_dcache.
* target.h (#include "dcache.h"): Added.
(target_open): Invalidate target_dcache.
(target_resume): Likewise.
(do_xfer_memory): New declaration.

* dcache.c (dcache_init): Removed reading and writing arguments.
(dcache_struct): Removed read_memory and write_memory fields.
(dcache_write_line): Call do_xfer_memory.
(dcache_read_line): Likewise.
(dcache_xfer_memory): Likewise.
(dcache_invalidate): Renamed from dcache_invd.
(dcache_init): Updated.
(dcache_xfer_memory): Updated.
* dcache.h (memxferfunc): Removed definition.
@
text
@d840 2
a841 7
/* Move memory to or from the targets.  Iterate until all of it has
   been moved, if necessary.  The top target gets priority; anything
   it doesn't want, is offered to the next one down, etc.  Note the
   business with curlen:  if an early target says "no, but I have a
   boundary overlapping this xfer" then we shorten what we offer to
   the subsequent targets so the early guy will get a chance at the
   tail before the subsequent ones do. 
d843 1
a843 1
   Result is 0 or errno value.  */
d861 1
a861 1
  /* The quick case is that the top target does it all.  */
a863 2
  if (res == len)
    return len;
d865 2
a866 5
  if (res > 0)
    goto bump;
  /* If res <= 0 then we call it again in the loop.  Ah well.  */

  while (len > 0)
d882 1
a882 8
	{
	    return -1;
	}
    bump:
      done    += res;
      memaddr += res;
      myaddr  += res;
      len     -= res;
d884 2
a885 2
  
  return done;
d888 6
d929 3
a931 1
/* Perform a partial memory transfer.  */
a937 4
  int err_res;
  int len_res;
  struct target_ops *t;
  struct target_stack_item *item;
d958 1
a958 1
  return 0;
@


1.13
log
@
Corrected spelling errors in comments.
gdbarch.{c,sh} removed a word from a comment.
@
text
@d34 1
d181 2
d235 1
d850 2
a851 2
static int
target_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write)
a852 1
  int curlen;
d854 1
d870 1
a870 1
    return 0;
d876 1
a876 1
  for (; len > 0;)
a877 1
      curlen = len;		/* Want to do it all */
d884 1
a884 1
	  res = t->to_xfer_memory (memaddr, myaddr, curlen, write, t);
d893 28
d930 1
a930 1
    bump:
d932 2
a933 2
      myaddr += res;
      len -= res;
d935 1
d943 1
a943 1
target_xfer_memory_partial (CORE_ADDR memaddr, char *buf, int len,
d959 2
a960 3
  /* The quick case is that the top target does it all.  */
  res = current_target.to_xfer_memory (memaddr, buf, len, write_p, &current_target);
  if (res > 0)
d962 4
a965 6
      *err = 0;
      return res;
    }

  /* xfer memory doesn't always reliably set errno. */
  errno = 0;
d967 1
a967 15
  /* Try all levels of the target stack to see one can handle it. */
  for (item = target_stack; item; item = item->next)
    {
      t = item->target_ops;
      if (!t->to_has_memory)
	continue;
      res = t->to_xfer_memory (memaddr, buf, len, write_p, t);
      if (res > 0)
	{
	  /* Handled all or part of xfer */
	  *err = 0;
	  return res;
	}
      if (t->to_has_all_memory)
	break;
d970 2
a971 8
  /* Total failure.  Return error. */
  if (errno != 0)
    {
      *err = errno;
      return -1;
    }
  *err = EIO;
  return -1;
d2931 2
@


1.12
log
@2000-10-25  Fernando Nasser  <fnasser@@cygnus.com>

        * target.c (generic_mourn_inferior): Notify GUI that inferior is gone
        by calling detach_hook, if defined.
@
text
@d2079 1
a2079 1
   numeric signal at all is obscelescent.  We are slightly more
@


1.11
log
@	* target.c (target_signal_from_host, do_target_signal_to_host):
	Add support for Solaris realtime signals.
@
text
@d1338 3
@


1.10
log
@Protoization.
@
text
@d1732 12
d1998 13
@


1.9
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d184 1
a184 3
target_command (arg, from_tty)
     char *arg;
     int from_tty;
d193 1
a193 2
add_target (t)
     struct target_ops *t;
d225 1
a225 1
target_ignore ()
d237 2
a238 6
nomemory (memaddr, myaddr, len, write, t)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *t;
d245 1
a245 1
tcomplain ()
d252 1
a252 1
noprocess ()
d259 1
a259 3
nosymbol (name, addrp)
     char *name;
     CORE_ADDR *addrp;
d266 1
a266 1
nosupport_runtime ()
d277 1
a277 3
default_terminal_info (args, from_tty)
     char *args;
     int from_tty;
d288 1
a288 2
kill_or_be_killed (from_tty)
     int from_tty;
d310 1
a310 3
maybe_kill_then_attach (args, from_tty)
     char *args;
     int from_tty;
d317 1
a317 4
maybe_kill_then_create_inferior (exec, args, env)
     char *exec;
     char *args;
     char **env;
d324 1
a324 3
default_clone_and_follow_inferior (child_pid, followed_child)
     int child_pid;
     int *followed_child;
d333 1
a333 2
cleanup_target (t)
     struct target_ops *t;
d520 1
a520 1
update_current_target ()
d628 1
a628 2
push_target (t)
     struct target_ops *t;
d693 1
a693 2
unpush_target (t)
     struct target_ops *t;
d726 1
a726 1
pop_target ()
d748 1
a748 5
target_read_string (memaddr, string, len, errnop)
     CORE_ADDR memaddr;
     char **string;
     int len;
     int *errnop;
d825 1
a825 4
target_read_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d831 1
a831 4
target_write_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d847 1
a847 5
target_xfer_memory (memaddr, myaddr, len, write)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
d979 1
a979 3
target_info (args, from_tty)
     char *args;
     int from_tty;
d1014 1
a1014 2
target_preopen (from_tty)
     int from_tty;
d1037 1
a1037 3
target_detach (args, from_tty)
     char *args;
     int from_tty;
d1047 1
a1047 3
target_link (modname, t_reloc)
     char *modname;
     CORE_ADDR *t_reloc;
d1074 1
a1074 2
find_default_run_target (do_mesg)
     char *do_mesg;
d1099 1
a1099 3
find_default_attach (args, from_tty)
     char *args;
     int from_tty;
d1109 1
a1109 3
find_default_require_attach (args, from_tty)
     char *args;
     int from_tty;
d1119 1
a1119 4
find_default_require_detach (pid, args, from_tty)
     int pid;
     char *args;
     int from_tty;
d1129 1
a1129 4
find_default_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
d1139 1
a1139 3
find_default_clone_and_follow_inferior (child_pid, followed_child)
     int child_pid;
     int *followed_child;
d1149 1
a1149 1
return_zero ()
d1155 1
a1155 1
return_one ()
d1247 1
a1247 1
find_run_target ()
d1271 1
a1271 1
find_core_target ()
d1297 1
a1297 2
find_target_beneath (t)
     struct target_ops *t;
d1315 1
a1315 1
generic_mourn_inferior ()
d1450 1
a1450 2
target_signal_to_string (sig)
     enum target_signal sig;
d1460 1
a1460 2
target_signal_to_name (sig)
     enum target_signal sig;
d1471 1
a1471 2
target_signal_from_name (name)
     char *name;
d1495 1
a1495 2
target_signal_from_host (hostsig)
     int hostsig;
d2021 1
a2021 3
store_waitstatus (ourstatus, hoststatus)
     struct target_waitstatus *ourstatus;
     int hoststatus;
d2056 1
a2056 2
target_signal_from_command (num)
     int num;
d2072 1
a2072 2
normal_pid_to_str (pid)
     int pid;
d2097 1
a2097 2
normal_target_post_startup_inferior (pid)
     int pid;
d2106 1
a2106 1
init_dummy_target ()
d2125 1
a2125 3
debug_to_open (args, from_tty)
     char *args;
     int from_tty;
d2133 1
a2133 2
debug_to_close (quitting)
     int quitting;
d2141 1
a2141 3
debug_to_attach (args, from_tty)
     char *args;
     int from_tty;
d2150 1
a2150 2
debug_to_post_attach (pid)
     int pid;
d2158 1
a2158 3
debug_to_require_attach (args, from_tty)
     char *args;
     int from_tty;
d2167 1
a2167 3
debug_to_detach (args, from_tty)
     char *args;
     int from_tty;
d2175 1
a2175 4
debug_to_require_detach (pid, args, from_tty)
     int pid;
     char *args;
     int from_tty;
d2184 1
a2184 4
debug_to_resume (pid, step, siggnal)
     int pid;
     int step;
     enum target_signal siggnal;
d2194 1
a2194 3
debug_to_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d2241 1
a2241 3
debug_to_post_wait (pid, status)
     int pid;
     int status;
d2250 1
a2250 2
debug_to_fetch_registers (regno)
     int regno;
d2264 1
a2264 2
debug_to_store_registers (regno)
     int regno;
d2278 1
a2278 1
debug_to_prepare_to_store ()
d2286 2
a2287 6
debug_to_xfer_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;
d2319 1
a2319 2
debug_to_files_info (target)
     struct target_ops *target;
d2327 1
a2327 3
debug_to_insert_breakpoint (addr, save)
     CORE_ADDR addr;
     char *save;
d2341 1
a2341 3
debug_to_remove_breakpoint (addr, save)
     CORE_ADDR addr;
     char *save;
d2355 1
a2355 1
debug_to_terminal_init ()
d2363 1
a2363 1
debug_to_terminal_inferior ()
d2371 1
a2371 1
debug_to_terminal_ours_for_output ()
d2379 1
a2379 1
debug_to_terminal_ours ()
d2387 1
a2387 3
debug_to_terminal_info (arg, from_tty)
     char *arg;
     int from_tty;
d2396 1
a2396 1
debug_to_kill ()
d2404 1
a2404 3
debug_to_load (args, from_tty)
     char *args;
     int from_tty;
d2412 1
a2412 3
debug_to_lookup_symbol (name, addrp)
     char *name;
     CORE_ADDR *addrp;
d2424 1
a2424 4
debug_to_create_inferior (exec_file, args, env)
     char *exec_file;
     char *args;
     char **env;
d2433 1
a2433 2
debug_to_post_startup_inferior (pid)
     int pid;
d2442 1
a2442 2
debug_to_acknowledge_created_inferior (pid)
     int pid;
d2451 1
a2451 3
debug_to_clone_and_follow_inferior (child_pid, followed_child)
     int child_pid;
     int *followed_child;
d2461 1
a2461 1
debug_to_post_follow_inferior_by_clone ()
d2469 1
a2469 2
debug_to_insert_fork_catchpoint (pid)
     int pid;
d2482 1
a2482 2
debug_to_remove_fork_catchpoint (pid)
     int pid;
d2495 1
a2495 2
debug_to_insert_vfork_catchpoint (pid)
     int pid;
d2508 1
a2508 2
debug_to_remove_vfork_catchpoint (pid)
     int pid;
d2521 1
a2521 3
debug_to_has_forked (pid, child_pid)
     int pid;
     int *child_pid;
d2534 1
a2534 3
debug_to_has_vforked (pid, child_pid)
     int pid;
     int *child_pid;
d2547 1
a2547 1
debug_to_can_follow_vfork_prior_to_exec ()
d2560 2
a2561 5
debug_to_post_follow_vfork (parent_pid, followed_parent, child_pid, followed_child)
     int parent_pid;
     int followed_parent;
     int child_pid;
     int followed_child;
d2571 1
a2571 2
debug_to_insert_exec_catchpoint (pid)
     int pid;
d2584 1
a2584 2
debug_to_remove_exec_catchpoint (pid)
     int pid;
d2597 1
a2597 3
debug_to_has_execd (pid, execd_pathname)
     int pid;
     char **execd_pathname;
d2611 1
a2611 1
debug_to_reported_exec_events_per_exec_call ()
d2625 2
a2626 4
debug_to_has_syscall_event (pid, kind, syscall_id)
     int pid;
     enum target_waitkind *kind;
     int *syscall_id;
d2655 1
a2655 4
debug_to_has_exited (pid, wait_status, exit_status)
     int pid;
     int wait_status;
     int *exit_status;
d2668 1
a2668 1
debug_to_mourn_inferior ()
d2676 1
a2676 1
debug_to_can_run ()
d2688 1
a2688 2
debug_to_notice_signals (pid)
     int pid;
d2696 1
a2696 2
debug_to_thread_alive (pid)
     int pid;
d2709 1
a2709 1
debug_to_find_new_threads ()
d2717 1
a2717 1
debug_to_stop ()
d2725 1
a2725 5
debug_to_query (type, req, resp, siz)
     int type;
     char *req;
     char *resp;
     int *siz;
d2745 1
a2745 3
debug_to_enable_exception_callback (kind, enable)
     enum exception_event_kind kind;
     int enable;
d2756 1
a2756 1
debug_to_get_current_exception_event ()
d2765 1
a2765 2
debug_to_pid_to_exec_file (pid)
     int pid;
d2778 1
a2778 2
debug_to_core_file_to_sym_file (core)
     char *core;
d2791 1
a2791 1
setup_target_debug ()
d2876 1
a2876 1
initialize_targets ()
@


1.8
log
@PARAMS removal.
@
text
@d2129 1
a2129 1
int (*target_activity_function) PARAMS ((void));
@


1.7
log
@* target.h (target_memory_bfd_section): Removed declaration.
* target.c (target_memory_bfd_section): Removed.
* exec.c (xfer_memory): Removed #if'ed-out code which referenced
target_memory_bfd_section.

* target.h (target_read_memory_section): Removed declaration.
* target.c (target_read_memory_section): Removed.
(target_xfer_memory): Update, removed bfd_section argument.
(target_read_string, target_read_memory, target_write_memory):
Update for above change.

* gdbcore.h (read_memory_section): Removed declaration.
* corefile.c (read_memory_section): Removed.
* jv-lang.c (get_java_utf8_name): Changed calls to
read_memory_section to read_memory.
* printcmd.c (printf_command): Likewise.
* valops.c (value_at, value_fetch_lazy): Likewise.
@
text
@d38 1
a38 2
static void
target_info PARAMS ((char *, int));
d40 1
a40 2
static void
cleanup_target PARAMS ((struct target_ops *));
d42 1
a42 2
static void
maybe_kill_then_create_inferior PARAMS ((char *, char *, char **));
d44 1
a44 2
static void
default_clone_and_follow_inferior PARAMS ((int, int *));
d46 1
a46 2
static void
maybe_kill_then_attach PARAMS ((char *, int));
d48 1
a48 2
static void
kill_or_be_killed PARAMS ((int));
d50 1
a50 2
static void
default_terminal_info PARAMS ((char *, int));
d52 1
a52 2
static int
nosymbol PARAMS ((char *, CORE_ADDR *));
d54 1
a54 2
static void
tcomplain PARAMS ((void));
d56 1
a56 2
static int
nomemory PARAMS ((CORE_ADDR, char *, int, int, struct target_ops *));
d58 1
a58 2
static int
return_zero PARAMS ((void));
d60 1
a60 2
static int
return_one PARAMS ((void));
d62 1
a62 2
void
target_ignore PARAMS ((void));
d64 1
a64 2
static void
target_command PARAMS ((char *, int));
d66 1
a66 2
static struct target_ops *
find_default_run_target PARAMS ((char *));
d68 1
a68 2
static void
update_current_target PARAMS ((void));
d70 1
a70 1
static void nosupport_runtime PARAMS ((void));
d72 1
a72 1
static void normal_target_post_startup_inferior PARAMS ((int pid));
d81 1
a81 2
target_xfer_memory PARAMS ((CORE_ADDR memaddr, char *myaddr, int len,
			    int write));
d83 1
a83 1
static void init_dummy_target PARAMS ((void));
d85 1
a85 2
static void
debug_to_open PARAMS ((char *, int));
d87 1
a87 2
static void
debug_to_close PARAMS ((int));
d89 1
a89 2
static void
debug_to_attach PARAMS ((char *, int));
d91 1
a91 2
static void
debug_to_detach PARAMS ((char *, int));
d93 1
a93 2
static void
debug_to_resume PARAMS ((int, int, enum target_signal));
d95 1
a95 2
static int
debug_to_wait PARAMS ((int, struct target_waitstatus *));
d97 1
a97 2
static void
debug_to_fetch_registers PARAMS ((int));
d99 1
a99 2
static void
debug_to_store_registers PARAMS ((int));
d101 1
a101 2
static void
debug_to_prepare_to_store PARAMS ((void));
d104 1
a104 1
debug_to_xfer_memory PARAMS ((CORE_ADDR, char *, int, int, struct target_ops *));
d106 1
a106 2
static void
debug_to_files_info PARAMS ((struct target_ops *));
d108 1
a108 2
static int
debug_to_insert_breakpoint PARAMS ((CORE_ADDR, char *));
d110 1
a110 2
static int
debug_to_remove_breakpoint PARAMS ((CORE_ADDR, char *));
d112 1
a112 2
static void
debug_to_terminal_init PARAMS ((void));
d114 1
a114 2
static void
debug_to_terminal_inferior PARAMS ((void));
d116 1
a116 2
static void
debug_to_terminal_ours_for_output PARAMS ((void));
d118 1
a118 2
static void
debug_to_terminal_ours PARAMS ((void));
d120 1
a120 2
static void
debug_to_terminal_info PARAMS ((char *, int));
d122 1
a122 2
static void
debug_to_kill PARAMS ((void));
d124 1
a124 2
static void
debug_to_load PARAMS ((char *, int));
d126 1
a126 2
static int
debug_to_lookup_symbol PARAMS ((char *, CORE_ADDR *));
d128 1
a128 2
static void
debug_to_create_inferior PARAMS ((char *, char *, char **));
d130 1
a130 2
static void
debug_to_mourn_inferior PARAMS ((void));
d132 1
a132 2
static int
debug_to_can_run PARAMS ((void));
d134 1
a134 2
static void
debug_to_notice_signals PARAMS ((int));
d136 1
a136 2
static int
debug_to_thread_alive PARAMS ((int));
d138 1
a138 2
static void
debug_to_stop PARAMS ((void));
d140 1
a140 1
static int debug_to_query PARAMS ((int /*char */ , char *, char *, int *));
d178 1
a178 1
static void setup_target_debug PARAMS ((void));
@


1.6
log
@Cast function to correct type.
@
text
@d98 1
a98 1
			    int write, asection * bfd_section));
d839 1
a839 1
      errcode = target_xfer_memory (memaddr & ~3, buf, 4, 0, NULL);
d847 1
a847 1
	  errcode = target_xfer_memory (memaddr, buf, 1, 0, NULL);
d899 1
a899 11
  return target_xfer_memory (memaddr, myaddr, len, 0, NULL);
}

int
target_read_memory_section (memaddr, myaddr, len, bfd_section)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     asection *bfd_section;
{
  return target_xfer_memory (memaddr, myaddr, len, 0, bfd_section);
d908 1
a908 1
  return target_xfer_memory (memaddr, myaddr, len, 1, NULL);
a910 6
/* This variable is used to pass section information down to targets.  This
   *should* be done by adding an argument to the target_xfer_memory function
   of all the targets, but I didn't feel like changing 50+ files.  */

asection *target_memory_bfd_section = NULL;

d922 1
a922 1
target_xfer_memory (memaddr, myaddr, len, write, bfd_section)
a926 1
     asection *bfd_section;
a935 2

  target_memory_bfd_section = bfd_section;
@


1.5
log
@The set debug changes
@
text
@d3066 2
a3067 1
  if ((current_target.to_rcmd == (void*) tcomplain)
d3069 2
a3070 1
	  && (debug_target.to_rcmd == (void*) tcomplain)))
@


1.5.2.1
log
@Cast function to correct type.
@
text
@d3066 1
a3066 2
  if ((current_target.to_rcmd
       == (void (*) (char *, struct ui_file *)) tcomplain)
d3068 1
a3068 2
	  && (debug_target.to_rcmd
	      == (void (*) (char *, struct ui_file *)) tcomplain)))
@


1.4
log
@Deal with the inferior unloading shared objects.
* solib.c (current_sos): New function, replacing find_solib.
(find_solib): Deleted.
(free_so): New function.
(clear_solib): Call free_so, instead of writing it out.
(solib_add): Rewritten: compare the inferior's current list of
shared objects with GDB's list, and do the required loads and
unloads.
(info_sharedlibrary_command, solib_address): Don't use find_solib
to walk the list of shared libraries: call solib_add, and then
walk the list at so_list_head normally.
* objfiles.c (free_objfile): Don't call CLEAR_SOLIB, and don't
detach the core target.  These tasks are taken care of elsewhere.
* target.c (remove_target_sections): New function.
* target.h (remove_target_sections): New declaration.

* solib.c (symbol_add_stub): Check whether we've already created
an objfile for this shared object first, before doing all that
work to compute section addresses, etc.

* objfiles.c (unlink_objfile): Report an internal error if objfile
doesn't occur in the object_files list.

* solib.c (special_symbol_handling): Delete argument; it's not
used.

* solib.c (SOLIB_EXTRACT_ADDRESS):  New macro to extract addresses
from solib structures. Use it throughout solib.c, get rid of all
CORE_ADDR casts.
(struct so_list):  Change type of lmaddr to CORE_ADDR.
(first_link_map_member):  Change return value type to CORE_ADDR,
update callers.
(solib_add_common_symbols):  Change parameter type to CORE_ADDR,
update callers.
(open_symbol_file_object, find_solib):  Change type of lm variable
to CORE_ADDR.
@
text
@d3085 1
a3085 1
		add_set_cmd ("targetdebug", class_maintenance, var_zinteger,
d3088 2
a3089 2
When non-zero, target debugging is enabled.", &setlist),
		      &showlist);
@


1.3
log
@2000-02-16  Mark Kettenis  <kettenis@@gnu.org>

	* target.c (do_target_signal_to_host): Do not use REALTIME_LO in
	the conversion of the signal number.  TARGET_SIGNAL_REALTIME_33 is
	33 by definition, whereas REALTIME_LO might be 32 on systems that
	have SIG32 such as Linux.  Make sure that the signal number
	returned is within the range specified by REALTIME_LO and
	REALTIME_HI.
@
text
@d1328 33
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@a2024 2
    case TARGET_SIGNAL_REALTIME_32: return 32; /* by definition */ 

d2061 2
d2064 2
a2065 2
	  (int) oursig - (int) TARGET_SIGNAL_REALTIME_33 + REALTIME_LO;
	  if (retsig < REALTIME_HI)
d2068 8
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 1992-1995, 1998, 1999 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d33 1
a33 1
#include "wait.h"
d86 9
a94 4
/* Transfer LEN bytes between target address MEMADDR and GDB address MYADDR.
   Returns 0 for success, errno code for failure (which includes partial
   transfers--if you want a more useful response to partial transfers, try
   target_read_memory_partial).  */
d98 1
a98 1
			    int write, asection *bfd_section));
d183 1
a183 1
static int debug_to_query PARAMS ((int/*char*/, char *, char *, int *));
a216 1
#ifdef MAINTENANCE_CMDS
a222 2
#endif

d251 2
a252 2
	  xrealloc ((char *) target_structs, 
		    target_struct_allocsize * sizeof (*target_structs));
d255 1
a255 1
/*  cleanup_target (t);*/
d275 6
d290 2
a291 2
  errno = EIO;		/* Can't read/write this location */
  return 0;		/* No bytes handled */
d313 1
a313 1
  return 1;		/* Symbol does not exist in target env */
d317 1
a317 1
void
d333 1
a333 1
  printf_unfiltered("No saved terminal information.\n");
d349 11
a359 8
      if (query ("Kill it? ")) {
	target_kill ();
	if (target_has_execution)
	  error ("Killing the program did not help.");
	return;
      } else {
	error ("Program not killed.");
      }
d361 1
a361 1
  tcomplain();
d385 2
a386 2
  int  child_pid;
  int  *followed_child;
d400 2
a401 3
  if (!t->field)	t->field = value

  /*        FIELD			DEFAULT VALUE        */
d403 172
a574 55
  de_fault (to_open, 			(void (*) PARAMS((char *, int))) tcomplain);
  de_fault (to_close, 			(void (*) PARAMS((int))) target_ignore);
  de_fault (to_attach, 			maybe_kill_then_attach);
  de_fault (to_post_attach,             (void (*) PARAMS ((int))) target_ignore);
  de_fault (to_require_attach,          maybe_kill_then_attach);
  de_fault (to_detach, 			(void (*) PARAMS((char *, int))) target_ignore);
  de_fault (to_require_detach,          (void (*) PARAMS((int, char *, int))) target_ignore);
  de_fault (to_resume, 			(void (*) PARAMS((int, int, enum target_signal))) noprocess);
  de_fault (to_wait, 			(int (*) PARAMS((int, struct target_waitstatus *))) noprocess);
  de_fault (to_post_wait,               (void (*) PARAMS ((int, int))) target_ignore);
  de_fault (to_fetch_registers, 	(void (*) PARAMS((int))) target_ignore);
  de_fault (to_store_registers,		(void (*) PARAMS((int))) noprocess);
  de_fault (to_prepare_to_store,	(void (*) PARAMS((void))) noprocess);
  de_fault (to_xfer_memory,		(int (*) PARAMS((CORE_ADDR, char *, int, int, struct target_ops *))) nomemory);
  de_fault (to_files_info,		(void (*) PARAMS((struct target_ops *))) target_ignore);
  de_fault (to_insert_breakpoint,	memory_insert_breakpoint);
  de_fault (to_remove_breakpoint,	memory_remove_breakpoint);
  de_fault (to_terminal_init,		(void (*) PARAMS((void))) target_ignore);
  de_fault (to_terminal_inferior,	(void (*) PARAMS ((void))) target_ignore);
  de_fault (to_terminal_ours_for_output,(void (*) PARAMS ((void))) target_ignore);
  de_fault (to_terminal_ours,		(void (*) PARAMS ((void))) target_ignore);
  de_fault (to_terminal_info,		default_terminal_info);
  de_fault (to_kill,			(void (*) PARAMS((void))) noprocess);
  de_fault (to_load,			(void (*) PARAMS((char *, int))) tcomplain);
  de_fault (to_lookup_symbol,		(int (*) PARAMS ((char *, CORE_ADDR *))) nosymbol);
  de_fault (to_create_inferior,		maybe_kill_then_create_inferior);
  de_fault (to_post_startup_inferior,   (void (*) PARAMS ((int))) target_ignore);
  de_fault (to_acknowledge_created_inferior,            (void (*) PARAMS((int))) target_ignore);
  de_fault (to_clone_and_follow_inferior,               default_clone_and_follow_inferior);
  de_fault (to_post_follow_inferior_by_clone,           (void (*) PARAMS ((void))) target_ignore);
  de_fault (to_insert_fork_catchpoint,  (int (*) PARAMS ((int))) tcomplain);
  de_fault (to_remove_fork_catchpoint,  (int (*) PARAMS ((int))) tcomplain);
  de_fault (to_insert_vfork_catchpoint, (int (*) PARAMS ((int))) tcomplain);
  de_fault (to_remove_vfork_catchpoint, (int (*) PARAMS ((int))) tcomplain);
  de_fault (to_has_forked,              (int (*) PARAMS ((int, int *))) return_zero);
  de_fault (to_has_vforked,             (int (*) PARAMS ((int, int *))) return_zero);
  de_fault (to_can_follow_vfork_prior_to_exec, (int (*) PARAMS ((void ))) return_zero);
  de_fault (to_post_follow_vfork,       (void (*) PARAMS ((int, int, int, int))) target_ignore);
  de_fault (to_insert_exec_catchpoint,  (int (*) PARAMS ((int))) tcomplain);
  de_fault (to_remove_exec_catchpoint,  (int (*) PARAMS ((int))) tcomplain);
  de_fault (to_has_execd,               (int (*) PARAMS ((int, char **))) return_zero);
  de_fault (to_reported_exec_events_per_exec_call, (int (*) PARAMS ((void))) return_one);
  de_fault (to_has_syscall_event,       (int (*) PARAMS ((int, enum target_waitkind *, int *))) return_zero);
  de_fault (to_has_exited,              (int (*) PARAMS ((int, int, int *))) return_zero);
  de_fault (to_mourn_inferior,		(void (*) PARAMS ((void))) noprocess);
  de_fault (to_can_run,			return_zero);
  de_fault (to_notice_signals,		(void (*) PARAMS((int))) target_ignore);
  de_fault (to_thread_alive,		(int (*) PARAMS((int))) target_ignore);
  de_fault (to_stop,			(void (*) PARAMS((void))) target_ignore);
  de_fault (to_query,			(int (*) PARAMS((int/*char*/, char*, char *, int *))) target_ignore);
  de_fault (to_enable_exception_callback,	(struct symtab_and_line * (*) PARAMS((enum exception_event_kind, int))) nosupport_runtime);
  de_fault (to_get_current_exception_event,	(struct exception_event_record * (*) PARAMS((void))) nosupport_runtime);

  de_fault (to_pid_to_exec_file,        (char* (*) PARAMS((int))) return_zero);
  de_fault (to_core_file_to_sym_file,   (char* (*) PARAMS ((char *))) return_zero);
d650 3
d655 1
d670 4
d700 4
a703 4
      fprintf_unfiltered(gdb_stderr,
			 "Magic number of %s target struct wrong\n", 
			 t->to_shortname);
      abort();
d710 1
a710 1
      if ((int)(t->to_stratum) >= (int)(cur->target_ops->to_stratum))
d723 1
a723 1
	  prev->next = cur->next; /* Unchain old target_ops */
d725 1
a725 1
	  target_stack = cur->next; /* Unchain first on list */
d745 1
a745 1
  cleanup_target (&current_target); /* Fill in the gaps */
a746 1
#ifdef MAINTENANCE_CMDS
a748 1
#endif
d793 1
a793 1
  (current_target.to_close)(0);	/* Let it clean up */
d797 4
a800 4
  fprintf_unfiltered(gdb_stderr,
		     "pop_target couldn't find target %s\n", 
		     current_target.to_shortname);
  abort();
d875 1
a875 1
 done:
a911 42
/* Read LEN bytes of target memory at address MEMADDR, placing the results
   in GDB's memory at MYADDR.  Returns a count of the bytes actually read,
   and optionally an errno value in the location pointed to by ERRNOPTR
   if ERRNOPTR is non-null. */

int
target_read_memory_partial (memaddr, myaddr, len, errnoptr)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int *errnoptr;
{
  int nread;	/* Number of bytes actually read. */
  int errcode;	/* Error from last read. */

  /* First try a complete read. */
  errcode = target_xfer_memory (memaddr, myaddr, len, 0, NULL);
  if (errcode == 0)
    {
      /* Got it all. */
      nread = len;
    }
  else
    {
      /* Loop, reading one byte at a time until we get as much as we can. */
      for (errcode = 0, nread = 0; len > 0 && errcode == 0; nread++, len--)
	{
	  errcode = target_xfer_memory (memaddr++, myaddr++, 1, 0, NULL);
	}
      /* If an error, the last read was unsuccessful, so adjust count. */
      if (errcode != 0)
	{
	  nread--;
	}
    }
  if (errnoptr != NULL)
    {
      *errnoptr = errcode;
    }
  return (nread);
}

d920 1
a920 1
 
d962 1
a962 1
			(memaddr, myaddr, len, write, &current_target);
d997 1
a997 1
bump:
d999 2
a1000 2
      myaddr  += res;
      len     -= res;
d1006 69
d1084 1
a1084 1
  
d1100 1
a1100 1
      if ((int)(t->to_stratum) <= (int)dummy_stratum)
d1103 3
a1105 3
	printf_unfiltered("\tWhile running this, GDB does not access memory from...\n");
      printf_unfiltered("%s:\n", t->to_longname);
      (t->to_files_info)(t);
d1117 1
a1117 1
  dont_repeat();
d1120 4
a1123 3
    {   
      if (query ("A program is being debugged already.  Kill it? "))
        target_kill ();
d1125 1
a1125 1
        error ("Program not killed.");
d1154 1
a1154 1
  if (STREQ(current_target.to_shortname, "rombug"))
d1158 1
a1158 1
      error("Unable to link to %s and get relocation in rombug", modname);
d1161 9
a1169 1
    *t_reloc = (CORE_ADDR)-1;
d1191 1
a1191 1
      if ((*t)->to_can_run && target_can_run(*t))
d1211 1
a1211 1
  t = find_default_run_target("attach");
d1223 1
a1223 1
  t = find_default_run_target("require_attach");
d1230 3
a1232 3
  int  pid;
  char *  args;
  int  from_tty;
d1236 1
a1236 1
  t = find_default_run_target("require_detach");
d1249 1
a1249 1
  t = find_default_run_target("run");
d1256 2
a1257 2
  int  child_pid;
  int  *followed_child;
d1261 1
a1261 1
  t = find_default_run_target("run");
d1278 77
d1361 1
a1361 1
  
d1363 1
a1363 1
  
d1373 22
a1394 2
  
  return(count == 1 ? runable : NULL);
d1396 1
d1428 1
d1510 2
d1522 2
d1530 3
d1539 4
a1542 1
  return signals[sig].string;
d1572 1
a1572 1
       sig = (enum target_signal)((int)sig + 1))
d1590 2
a1591 1
  if (hostsig == 0) return TARGET_SIGNAL_0;
d1594 2
a1595 1
  if (hostsig == SIGHUP) return TARGET_SIGNAL_HUP;
d1598 2
a1599 1
  if (hostsig == SIGINT) return TARGET_SIGNAL_INT;
d1602 2
a1603 1
  if (hostsig == SIGQUIT) return TARGET_SIGNAL_QUIT;
d1606 2
a1607 1
  if (hostsig == SIGILL) return TARGET_SIGNAL_ILL;
d1610 2
a1611 1
  if (hostsig == SIGTRAP) return TARGET_SIGNAL_TRAP;
d1614 2
a1615 1
  if (hostsig == SIGABRT) return TARGET_SIGNAL_ABRT;
d1618 2
a1619 1
  if (hostsig == SIGEMT) return TARGET_SIGNAL_EMT;
d1622 2
a1623 1
  if (hostsig == SIGFPE) return TARGET_SIGNAL_FPE;
d1626 2
a1627 1
  if (hostsig == SIGKILL) return TARGET_SIGNAL_KILL;
d1630 2
a1631 1
  if (hostsig == SIGBUS) return TARGET_SIGNAL_BUS;
d1634 2
a1635 1
  if (hostsig == SIGSEGV) return TARGET_SIGNAL_SEGV;
d1638 2
a1639 1
  if (hostsig == SIGSYS) return TARGET_SIGNAL_SYS;
d1642 2
a1643 1
  if (hostsig == SIGPIPE) return TARGET_SIGNAL_PIPE;
d1646 2
a1647 1
  if (hostsig == SIGALRM) return TARGET_SIGNAL_ALRM;
d1650 2
a1651 1
  if (hostsig == SIGTERM) return TARGET_SIGNAL_TERM;
d1654 2
a1655 1
  if (hostsig == SIGUSR1) return TARGET_SIGNAL_USR1;
d1658 2
a1659 1
  if (hostsig == SIGUSR2) return TARGET_SIGNAL_USR2;
d1662 2
a1663 1
  if (hostsig == SIGCLD) return TARGET_SIGNAL_CHLD;
d1666 2
a1667 1
  if (hostsig == SIGCHLD) return TARGET_SIGNAL_CHLD;
d1670 2
a1671 1
  if (hostsig == SIGPWR) return TARGET_SIGNAL_PWR;
d1674 2
a1675 1
  if (hostsig == SIGWINCH) return TARGET_SIGNAL_WINCH;
d1678 2
a1679 1
  if (hostsig == SIGURG) return TARGET_SIGNAL_URG;
d1682 2
a1683 1
  if (hostsig == SIGIO) return TARGET_SIGNAL_IO;
d1686 2
a1687 1
  if (hostsig == SIGPOLL) return TARGET_SIGNAL_POLL;
d1690 2
a1691 1
  if (hostsig == SIGSTOP) return TARGET_SIGNAL_STOP;
d1694 2
a1695 1
  if (hostsig == SIGTSTP) return TARGET_SIGNAL_TSTP;
d1698 2
a1699 1
  if (hostsig == SIGCONT) return TARGET_SIGNAL_CONT;
d1702 2
a1703 1
  if (hostsig == SIGTTIN) return TARGET_SIGNAL_TTIN;
d1706 2
a1707 1
  if (hostsig == SIGTTOU) return TARGET_SIGNAL_TTOU;
d1710 2
a1711 1
  if (hostsig == SIGVTALRM) return TARGET_SIGNAL_VTALRM;
d1714 2
a1715 1
  if (hostsig == SIGPROF) return TARGET_SIGNAL_PROF;
d1718 2
a1719 1
  if (hostsig == SIGXCPU) return TARGET_SIGNAL_XCPU;
d1722 2
a1723 1
  if (hostsig == SIGXFSZ) return TARGET_SIGNAL_XFSZ;
d1726 2
a1727 1
  if (hostsig == SIGWIND) return TARGET_SIGNAL_WIND;
d1730 2
a1731 1
  if (hostsig == SIGPHONE) return TARGET_SIGNAL_PHONE;
d1734 2
a1735 1
  if (hostsig == SIGLOST) return TARGET_SIGNAL_LOST;
d1738 6
a1743 1
  if (hostsig == SIGWAITING) return TARGET_SIGNAL_WAITING;
d1746 2
a1747 1
  if (hostsig == SIGLWP) return TARGET_SIGNAL_LWP;
d1750 2
a1751 1
  if (hostsig == SIGDANGER) return TARGET_SIGNAL_DANGER;
d1754 2
a1755 1
  if (hostsig == SIGGRANT) return TARGET_SIGNAL_GRANT;
d1758 2
a1759 1
  if (hostsig == SIGRETRACT) return TARGET_SIGNAL_RETRACT;
d1762 2
a1763 1
  if (hostsig == SIGMSG) return TARGET_SIGNAL_MSG;
d1766 2
a1767 1
  if (hostsig == SIGSOUND) return TARGET_SIGNAL_SOUND;
d1770 2
a1771 1
  if (hostsig == SIGSAK) return TARGET_SIGNAL_SAK;
d1774 2
a1775 1
  if (hostsig == SIGPRIO) return TARGET_SIGNAL_PRIO;
d1780 2
a1781 1
  if (hostsig == _NSIG + EXC_BAD_ACCESS) return TARGET_EXC_BAD_ACCESS;
d1784 2
a1785 1
  if (hostsig == _NSIG + EXC_BAD_INSTRUCTION) return TARGET_EXC_BAD_INSTRUCTION;
d1788 2
a1789 1
  if (hostsig == _NSIG + EXC_ARITHMETIC) return TARGET_EXC_ARITHMETIC;
d1792 2
a1793 1
  if (hostsig == _NSIG + EXC_EMULATION) return TARGET_EXC_EMULATION;
d1796 2
a1797 1
  if (hostsig == _NSIG + EXC_SOFTWARE) return TARGET_EXC_SOFTWARE;
d1800 7
a1806 1
  if (hostsig == _NSIG + EXC_BREAKPOINT) return TARGET_EXC_BREAKPOINT;
d1811 10
a1820 2
    return (enum target_signal)
      (hostsig - 33 + (int) TARGET_SIGNAL_REALTIME_33);
d1825 8
a1832 3
int
target_signal_to_host (oursig)
     enum target_signal oursig;
d1834 1
d1837 2
a1838 1
    case TARGET_SIGNAL_0: return 0;
d1841 2
a1842 1
    case TARGET_SIGNAL_HUP: return SIGHUP;
d1845 2
a1846 1
    case TARGET_SIGNAL_INT: return SIGINT;
d1849 2
a1850 1
    case TARGET_SIGNAL_QUIT: return SIGQUIT;
d1853 2
a1854 1
    case TARGET_SIGNAL_ILL: return SIGILL;
d1857 2
a1858 1
    case TARGET_SIGNAL_TRAP: return SIGTRAP;
d1861 2
a1862 1
    case TARGET_SIGNAL_ABRT: return SIGABRT;
d1865 2
a1866 1
    case TARGET_SIGNAL_EMT: return SIGEMT;
d1869 2
a1870 1
    case TARGET_SIGNAL_FPE: return SIGFPE;
d1873 2
a1874 1
    case TARGET_SIGNAL_KILL: return SIGKILL;
d1877 2
a1878 1
    case TARGET_SIGNAL_BUS: return SIGBUS;
d1881 2
a1882 1
    case TARGET_SIGNAL_SEGV: return SIGSEGV;
d1885 2
a1886 1
    case TARGET_SIGNAL_SYS: return SIGSYS;
d1889 2
a1890 1
    case TARGET_SIGNAL_PIPE: return SIGPIPE;
d1893 2
a1894 1
    case TARGET_SIGNAL_ALRM: return SIGALRM;
d1897 2
a1898 1
    case TARGET_SIGNAL_TERM: return SIGTERM;
d1901 2
a1902 1
    case TARGET_SIGNAL_USR1: return SIGUSR1;
d1905 2
a1906 1
    case TARGET_SIGNAL_USR2: return SIGUSR2;
d1909 1
a1909 1
    case TARGET_SIGNAL_CHLD: 
d1917 2
a1918 1
    case TARGET_SIGNAL_PWR: return SIGPWR;
d1921 2
a1922 1
    case TARGET_SIGNAL_WINCH: return SIGWINCH;
d1925 2
a1926 1
    case TARGET_SIGNAL_URG: return SIGURG;
d1929 2
a1930 1
    case TARGET_SIGNAL_IO: return SIGIO;
d1933 2
a1934 1
    case TARGET_SIGNAL_POLL: return SIGPOLL;
d1937 2
a1938 1
    case TARGET_SIGNAL_STOP: return SIGSTOP;
d1941 2
a1942 1
    case TARGET_SIGNAL_TSTP: return SIGTSTP;
d1945 2
a1946 1
    case TARGET_SIGNAL_CONT: return SIGCONT;
d1949 2
a1950 1
    case TARGET_SIGNAL_TTIN: return SIGTTIN;
d1953 2
a1954 1
    case TARGET_SIGNAL_TTOU: return SIGTTOU;
d1957 2
a1958 1
    case TARGET_SIGNAL_VTALRM: return SIGVTALRM;
d1961 2
a1962 1
    case TARGET_SIGNAL_PROF: return SIGPROF;
d1965 2
a1966 1
    case TARGET_SIGNAL_XCPU: return SIGXCPU;
d1969 2
a1970 1
    case TARGET_SIGNAL_XFSZ: return SIGXFSZ;
d1973 2
a1974 1
    case TARGET_SIGNAL_WIND: return SIGWIND;
d1977 2
a1978 1
    case TARGET_SIGNAL_PHONE: return SIGPHONE;
d1981 2
a1982 1
    case TARGET_SIGNAL_LOST: return SIGLOST;
d1985 6
a1990 1
    case TARGET_SIGNAL_WAITING: return SIGWAITING;
d1993 2
a1994 1
    case TARGET_SIGNAL_LWP: return SIGLWP;
d1997 2
a1998 1
    case TARGET_SIGNAL_DANGER: return SIGDANGER;
d2001 2
a2002 1
    case TARGET_SIGNAL_GRANT: return SIGGRANT;
d2005 2
a2006 1
    case TARGET_SIGNAL_RETRACT: return SIGRETRACT;
d2009 2
a2010 1
    case TARGET_SIGNAL_MSG: return SIGMSG;
d2013 2
a2014 1
    case TARGET_SIGNAL_SOUND: return SIGSOUND;
d2017 2
a2018 1
    case TARGET_SIGNAL_SAK: return SIGSAK;
d2021 2
a2022 1
    case TARGET_SIGNAL_PRIO: return SIGPRIO;
d2025 2
d2029 2
a2030 1
    case TARGET_EXC_BAD_ACCESS: return _NSIG + EXC_BAD_ACCESS;
d2033 2
a2034 1
    case TARGET_EXC_BAD_INSTRUCTION: return _NSIG + EXC_BAD_INSTRUCTION;
d2037 2
a2038 1
    case TARGET_EXC_ARITHMETIC: return _NSIG + EXC_ARITHMETIC;
d2041 2
a2042 1
    case TARGET_EXC_EMULATION: return _NSIG + EXC_EMULATION;
d2045 2
a2046 1
    case TARGET_EXC_SOFTWARE: return _NSIG + EXC_SOFTWARE;
d2049 7
a2055 1
    case TARGET_EXC_BREAKPOINT: return _NSIG + EXC_BREAKPOINT;
d2064 1
a2064 1
	    (int)oursig - (int)TARGET_SIGNAL_REALTIME_33 + REALTIME_LO;
d2069 20
d2090 1
a2090 1
	 doesn't have SIGSAK.  */
d2095 2
d2144 1
a2144 1
    return (enum target_signal)num;
d2163 1
a2163 1
    sprintf (buf, "thread %d\0", pid);
d2165 1
a2165 1
    sprintf (buf, "process %d\0", pid);
d2177 1
a2177 1
   
d2181 2
a2182 2
   */
void
d2184 1
a2184 1
  int  pid;
d2203 1
d2207 1
a2208 2

#ifdef MAINTENANCE_CMDS
d2218 1
a2218 1
  fprintf_unfiltered (gdb_stderr, "target_open (%s, %d)\n", args, from_tty);
d2227 1
a2227 1
  fprintf_unfiltered (gdb_stderr, "target_close (%d)\n", quitting);
d2237 1
a2237 1
  fprintf_unfiltered (gdb_stderr, "target_attach (%s, %d)\n", args, from_tty);
d2243 1
a2243 1
  int  pid;
d2247 1
a2247 1
  fprintf_unfiltered (gdb_stderr, "target_post_attach (%d)\n", pid);
d2257 1
a2257 1
  fprintf_unfiltered (gdb_stderr,
d2268 1
a2268 1
  fprintf_unfiltered (gdb_stderr, "target_detach (%s, %d)\n", args, from_tty);
d2273 3
a2275 3
  int  pid;
  char *  args;
  int  from_tty;
d2279 2
a2280 2
  fprintf_unfiltered (gdb_stderr,
		      "target_require_detach (%d, %s, %d)\n", pid, args, from_tty);
d2291 1
a2291 1
  fprintf_unfiltered (gdb_stderr, "target_resume (%d, %s, %s)\n", pid,
d2305 1
a2305 1
  fprintf_unfiltered (gdb_stderr,
d2307 1
a2307 1
  fprintf_unfiltered (gdb_stderr, "status->kind = ");
d2311 1
a2311 1
      fprintf_unfiltered (gdb_stderr, "exited, status = %d\n",
d2315 1
a2315 1
      fprintf_unfiltered (gdb_stderr, "stopped, signal = %s\n",
d2319 1
a2319 1
      fprintf_unfiltered (gdb_stderr, "signalled, signal = %s\n",
d2323 1
a2323 1
      fprintf_unfiltered (gdb_stderr, "loaded\n");
d2326 1
a2326 1
      fprintf_unfiltered (gdb_stderr, "forked\n");
d2329 1
a2329 1
      fprintf_unfiltered (gdb_stderr, "vforked\n");
d2332 1
a2332 1
      fprintf_unfiltered (gdb_stderr, "execd\n");
d2335 1
a2335 1
      fprintf_unfiltered (gdb_stderr, "spurious\n");
d2338 1
a2338 1
      fprintf_unfiltered (gdb_stderr, "unknown???\n");
d2347 2
a2348 2
  int  pid;
  int  status;
d2352 1
a2352 1
  fprintf_unfiltered (gdb_stderr, "target_post_wait (%d, %d)\n",
d2362 1
a2362 1
  fprintf_unfiltered (gdb_stderr, "target_fetch_registers (%s)",
d2365 1
a2365 1
    fprintf_unfiltered (gdb_stderr, " = 0x%x %d",
d2367 2
a2368 2
			read_register (regno));
  fprintf_unfiltered (gdb_stderr, "\n");
d2378 1
a2378 1
    fprintf_unfiltered (gdb_stderr, "target_store_registers (%s) = 0x%x %d\n",
d2383 1
a2383 1
    fprintf_unfiltered (gdb_stderr, "target_store_registers (%d)\n", regno);
d2391 1
a2391 1
  fprintf_unfiltered (gdb_stderr, "target_prepare_to_store ()\n");
d2406 1
a2406 1
  fprintf_unfiltered (gdb_stderr,
d2408 1
a2408 1
		      (unsigned int) memaddr, /* possable truncate long long */
d2411 1
a2411 1
  
d2417 1
a2417 1
      fputs_unfiltered (", bytes =", gdb_stderr);
d2421 2
a2422 2
	    fprintf_unfiltered (gdb_stderr, "\n");
	  fprintf_unfiltered (gdb_stderr, " %02x", myaddr[i] & 0xff);
d2426 1
a2426 1
  fputc_unfiltered ('\n', gdb_stderr);
d2437 1
a2437 1
  fprintf_unfiltered (gdb_stderr, "target_files_info (xxx)\n");
d2449 4
a2452 3
  fprintf_unfiltered (gdb_stderr,
		      "target_insert_breakpoint (0x%x, xxx) = %d\n",
		      (unsigned long) addr, retval);
d2465 4
a2468 3
  fprintf_unfiltered (gdb_stderr,
		      "target_remove_breakpoint (0x%x, xxx) = %d\n",
		      (unsigned long)addr, retval);
d2477 1
a2477 1
  fprintf_unfiltered (gdb_stderr, "target_terminal_init ()\n");
d2485 1
a2485 1
  fprintf_unfiltered (gdb_stderr, "target_terminal_inferior ()\n");
d2493 1
a2493 1
  fprintf_unfiltered (gdb_stderr, "target_terminal_ours_for_output ()\n");
d2501 1
a2501 1
  fprintf_unfiltered (gdb_stderr, "target_terminal_ours ()\n");
d2511 1
a2511 1
  fprintf_unfiltered (gdb_stderr, "target_terminal_info (%s, %d)\n", arg,
d2520 1
a2520 1
  fprintf_unfiltered (gdb_stderr, "target_kill ()\n");
d2530 1
a2530 1
  fprintf_unfiltered (gdb_stderr, "target_load (%s, %d)\n", args, from_tty);
d2542 1
a2542 1
  fprintf_unfiltered (gdb_stderr, "target_lookup_symbol (%s, xxx)\n", name);
d2555 1
a2555 1
  fprintf_unfiltered (gdb_stderr, "target_create_inferior (%s, %s, xxx)\n",
d2561 1
a2561 1
  int  pid;
d2565 1
a2565 1
  fprintf_unfiltered (gdb_stderr, "target_post_startup_inferior (%d)\n",
d2571 1
a2571 1
  int  pid;
d2575 1
a2575 1
  fprintf_unfiltered (gdb_stderr, "target_acknowledge_created_inferior (%d)\n",
d2581 2
a2582 2
  int  child_pid;
  int  *followed_child;
d2586 1
a2586 1
  fprintf_unfiltered (gdb_stderr,
d2596 1
a2596 1
  fprintf_unfiltered (gdb_stderr, "target_post_follow_inferior_by_clone ()\n");
d2601 1
a2601 1
  int  pid;
d2603 1
a2603 1
  int  retval;
d2607 2
a2608 2
  fprintf_unfiltered (gdb_stderr, "target_insert_fork_catchpoint (%d) = %d\n",
                      pid, retval);
d2615 1
a2615 1
  int  pid;
d2617 1
a2617 1
  int  retval;
d2621 2
a2622 2
  fprintf_unfiltered (gdb_stderr, "target_remove_fork_catchpoint (%d) = %d\n",
                      pid, retval);
d2629 1
a2629 1
  int  pid;
d2631 1
a2631 1
  int  retval;
d2635 2
a2636 2
  fprintf_unfiltered (gdb_stderr, "target_insert_vfork_catchpoint (%d)= %d\n",
                      pid, retval);
d2643 1
a2643 1
  int  pid;
d2645 1
a2645 1
  int  retval;
d2649 2
a2650 2
  fprintf_unfiltered (gdb_stderr, "target_remove_vfork_catchpoint (%d) = %d\n",
                      pid, retval);
d2657 2
a2658 2
  int  pid;
  int *  child_pid;
d2660 1
a2660 1
  int  has_forked;
d2664 2
a2665 2
  fprintf_unfiltered (gdb_stderr, "target_has_forked (%d, %d) = %d\n",
                      pid, *child_pid, has_forked);
d2672 2
a2673 2
  int  pid;
  int *  child_pid;
d2675 1
a2675 1
  int  has_vforked;
d2679 2
a2680 2
  fprintf_unfiltered (gdb_stderr, "target_has_vforked (%d, %d) = %d\n",
                      pid, *child_pid, has_vforked);
d2688 1
a2688 1
  int  can_immediately_follow_vfork;
d2692 2
a2693 2
  fprintf_unfiltered (gdb_stderr, "target_can_follow_vfork_prior_to_exec () = %d\n",
                      can_immediately_follow_vfork);
d2700 4
a2703 4
  int  parent_pid;
  int  followed_parent;
  int  child_pid;
  int  followed_child;
d2707 1
a2707 1
  fprintf_unfiltered (gdb_stderr,
d2709 1
a2709 1
                      parent_pid, followed_parent, child_pid, followed_child);
d2714 1
a2714 1
  int  pid;
d2716 1
a2716 1
  int  retval;
d2720 2
a2721 2
  fprintf_unfiltered (gdb_stderr, "target_insert_exec_catchpoint (%d) = %d\n",
                      pid, retval);
d2728 1
a2728 1
  int  pid;
d2730 1
a2730 1
  int  retval;
d2734 2
a2735 2
  fprintf_unfiltered (gdb_stderr, "target_remove_exec_catchpoint (%d) = %d\n",
                      pid, retval);
d2742 2
a2743 2
  int  pid;
  char **  execd_pathname;
d2745 1
a2745 1
  int  has_execd;
d2749 3
a2751 2
  fprintf_unfiltered (gdb_stderr, "target_has_execd (%d, %s) = %d\n",
                      pid, *execd_pathname, has_execd);
d2759 1
a2759 1
  int  reported_exec_events;
d2763 1
a2763 1
  fprintf_unfiltered (gdb_stderr,
d2765 1
a2765 1
                      reported_exec_events);
d2772 3
a2774 3
  int  pid;
  enum target_waitkind *  kind;
  int *  syscall_id;
d2776 2
a2777 2
  int  has_syscall_event;
  char *  kind_spelling = "??";
d2783 10
a2792 10
        {
          case TARGET_WAITKIND_SYSCALL_ENTRY:
            kind_spelling = "SYSCALL_ENTRY";
            break;
          case TARGET_WAITKIND_SYSCALL_RETURN:
            kind_spelling = "SYSCALL_RETURN";
            break;
          default:
            break;
        }
d2795 1
a2795 1
  fprintf_unfiltered (gdb_stderr,
d2797 1
a2797 1
                      pid, kind_spelling, *syscall_id, has_syscall_event);
d2804 3
a2806 3
  int  pid;
  int  wait_status;
  int *  exit_status;
d2808 1
a2808 1
  int  has_exited;
d2812 2
a2813 2
  fprintf_unfiltered (gdb_stderr, "target_has_exited (%d, %d, %d) = %d\n",
                      pid, wait_status, *exit_status, has_exited);
d2823 1
a2823 1
  fprintf_unfiltered (gdb_stderr, "target_mourn_inferior ()\n");
d2833 1
a2833 1
  fprintf_unfiltered (gdb_stderr, "target_can_run () = %d\n", retval);
d2844 1
a2844 1
  fprintf_unfiltered (gdb_stderr, "target_notice_signals (%d)\n", pid);
d2855 1
a2855 1
  fprintf_unfiltered (gdb_stderr, "target_thread_alive (%d) = %d\n",
d2862 8
d2874 1
a2874 1
  fprintf_unfiltered (gdb_stderr, "target_stop ()\n");
d2879 4
a2882 4
  int type;
  char *req;
  char *resp;
  int *siz;
d2888 1
a2888 1
  fprintf_unfiltered (gdb_stderr, "target_query (%c, %s, %s,  %d) = %d\n", type, req, resp, *siz, retval);
d2893 8
d2903 2
a2904 2
  enum exception_event_kind kind;
  int enable;
d2906 3
a2908 3
  debug_target.to_enable_exception_callback (kind, enable);

  fprintf_unfiltered (gdb_stderr,
d2911 1
d2917 4
a2920 3
  debug_target.to_get_current_exception_event();

  fprintf_unfiltered (gdb_stderr, "target get_current_exception_event ()\n");
d2925 1
a2925 1
  int  pid;
d2927 1
a2927 1
  char *  exec_file;
d2931 2
a2932 2
  fprintf_unfiltered (gdb_stderr, "target_pid_to_exec_file (%d) = %s\n",
                      pid, exec_file);
d2939 1
a2939 1
  char *  core;
d2941 1
a2941 1
  char *  sym_file;
d2945 2
a2946 2
  fprintf_unfiltered (gdb_stderr, "target_core_file_to_sym_file (%s) = %s\n",
                      core, sym_file);
d3004 1
d3007 1
a3013 1
#endif /* MAINTENANCE_CMDS */
d3015 3
a3017 2
static char targ_desc[] = 
    "Names of targets and files being debugged.\n\
d3021 13
a3042 1
#ifdef MAINTENANCE_CMDS
d3044 3
a3046 3
     add_set_cmd ("targetdebug", class_maintenance, var_zinteger,
		  (char *)&targetdebug,
		 "Set target debugging.\n\
d3048 5
a3052 2
		     &showlist);
#endif
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d211 1
d218 2
d611 1
d614 1
a1107 24
/* Find a single runnable target in the stack and return it.  If for
   some reason there is more than one, return NULL.  */

struct target_ops *
find_run_target ()
{
  struct target_ops **t;
  struct target_ops *runable = NULL;
  int count;
  
  count = 0;
  
  for (t = target_structs; t < target_structs + target_struct_size; ++t)
    {
      if ((*t)->to_can_run && target_can_run(*t))
	{
	  runable = *t;
	  ++count;
	}
    }
  
  return (count == 1 ? runable : NULL);
}

a1250 2
  {"SIGINFO", "Information request"},

d1263 1
a1263 4
  if ((sig >= TARGET_SIGNAL_FIRST) && (sig <= TARGET_SIGNAL_LAST))
    return signals[sig].string;
  else
    return signals[TARGET_SIGNAL_UNKNOWN].string;
a1468 4
#if defined (SIGINFO)
  if (hostsig == SIGINFO) return TARGET_SIGNAL_INFO;
#endif

a1642 4
#if defined (SIGINFO)
    case TARGET_SIGNAL_INFO: return SIGINFO;
#endif

d1771 1
d2311 1
a2311 2
                      pid, (*execd_pathname ? *execd_pathname : "<NULL>"),
		      has_execd);
d2450 2
a2451 2
  struct symtab_and_line *result;
  result = debug_target.to_enable_exception_callback (kind, enable);
a2454 1
  return result;
d2460 2
a2461 2
  struct exception_event_record *result;
  result = debug_target.to_get_current_exception_event();
a2462 1
  return result;
d2554 1
a2554 1

d2570 1
d2577 1
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@a518 1
      INHERIT (to_find_new_threads, t);
@


1.1.1.4
log
@import gdb-1999-05-10
@
text
@a1260 1
  {"SIGCANCEL", "LWP internal signal"},
a1448 3
#if defined (SIGCANCEL)
  if (hostsig == SIGCANCEL) return TARGET_SIGNAL_CANCEL;
#endif
a1625 3
#endif
#if defined (SIGCANCEL)
    case TARGET_SIGNAL_CANCEL: return SIGCANCEL;
@


1.1.1.5
log
@import gdb-1999-05-25 snapshot
@
text
@a84 4
static void nosupport_runtime PARAMS ((void));

static void normal_target_post_startup_inferior PARAMS ((int pid));

d305 1
a305 1
static void
d1785 1
a1785 1
static void
@


1.1.1.6
log
@import gdb-1999-07-05 snapshot
@
text
@a537 1
      INHERIT (to_has_async_exec, t);
@


1.1.1.7
log
@import gdb-1999-07-07 pre reformat
@
text
@a1184 1
/* *INDENT-OFF* */
a1284 1
/* *INDENT-ON* */
@


1.1.1.8
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d80 1
a80 1
  find_default_run_target PARAMS ((char *));
d96 1
a96 1
			    int write, asection * bfd_section));
d181 1
a181 1
static int debug_to_query PARAMS ((int /*char */ , char *, char *, int *));
d249 2
a250 2
	xrealloc ((char *) target_structs,
		  target_struct_allocsize * sizeof (*target_structs));
d253 1
a253 1
/*  cleanup_target (t); */
d282 2
a283 2
  errno = EIO;			/* Can't read/write this location */
  return 0;			/* No bytes handled */
d305 1
a305 1
  return 1;			/* Symbol does not exist in target env */
d325 1
a325 1
  printf_unfiltered ("No saved terminal information.\n");
d341 8
a348 11
      if (query ("Kill it? "))
	{
	  target_kill ();
	  if (target_has_execution)
	    error ("Killing the program did not help.");
	  return;
	}
      else
	{
	  error ("Program not killed.");
	}
d350 1
a350 1
  tcomplain ();
d374 2
a375 2
     int child_pid;
     int *followed_child;
d391 1
a391 1
  /*        FIELD                       DEFAULT VALUE        */
d393 52
a444 52
  de_fault (to_open, (void (*)PARAMS ((char *, int))) tcomplain);
  de_fault (to_close, (void (*)PARAMS ((int))) target_ignore);
  de_fault (to_attach, maybe_kill_then_attach);
  de_fault (to_post_attach, (void (*)PARAMS ((int))) target_ignore);
  de_fault (to_require_attach, maybe_kill_then_attach);
  de_fault (to_detach, (void (*)PARAMS ((char *, int))) target_ignore);
  de_fault (to_require_detach, (void (*)PARAMS ((int, char *, int))) target_ignore);
  de_fault (to_resume, (void (*)PARAMS ((int, int, enum target_signal))) noprocess);
  de_fault (to_wait, (int (*)PARAMS ((int, struct target_waitstatus *))) noprocess);
  de_fault (to_post_wait, (void (*)PARAMS ((int, int))) target_ignore);
  de_fault (to_fetch_registers, (void (*)PARAMS ((int))) target_ignore);
  de_fault (to_store_registers, (void (*)PARAMS ((int))) noprocess);
  de_fault (to_prepare_to_store, (void (*)PARAMS ((void))) noprocess);
  de_fault (to_xfer_memory, (int (*)PARAMS ((CORE_ADDR, char *, int, int, struct target_ops *))) nomemory);
  de_fault (to_files_info, (void (*)PARAMS ((struct target_ops *))) target_ignore);
  de_fault (to_insert_breakpoint, memory_insert_breakpoint);
  de_fault (to_remove_breakpoint, memory_remove_breakpoint);
  de_fault (to_terminal_init, (void (*)PARAMS ((void))) target_ignore);
  de_fault (to_terminal_inferior, (void (*)PARAMS ((void))) target_ignore);
  de_fault (to_terminal_ours_for_output, (void (*)PARAMS ((void))) target_ignore);
  de_fault (to_terminal_ours, (void (*)PARAMS ((void))) target_ignore);
  de_fault (to_terminal_info, default_terminal_info);
  de_fault (to_kill, (void (*)PARAMS ((void))) noprocess);
  de_fault (to_load, (void (*)PARAMS ((char *, int))) tcomplain);
  de_fault (to_lookup_symbol, (int (*)PARAMS ((char *, CORE_ADDR *))) nosymbol);
  de_fault (to_create_inferior, maybe_kill_then_create_inferior);
  de_fault (to_post_startup_inferior, (void (*)PARAMS ((int))) target_ignore);
  de_fault (to_acknowledge_created_inferior, (void (*)PARAMS ((int))) target_ignore);
  de_fault (to_clone_and_follow_inferior, default_clone_and_follow_inferior);
  de_fault (to_post_follow_inferior_by_clone, (void (*)PARAMS ((void))) target_ignore);
  de_fault (to_insert_fork_catchpoint, (int (*)PARAMS ((int))) tcomplain);
  de_fault (to_remove_fork_catchpoint, (int (*)PARAMS ((int))) tcomplain);
  de_fault (to_insert_vfork_catchpoint, (int (*)PARAMS ((int))) tcomplain);
  de_fault (to_remove_vfork_catchpoint, (int (*)PARAMS ((int))) tcomplain);
  de_fault (to_has_forked, (int (*)PARAMS ((int, int *))) return_zero);
  de_fault (to_has_vforked, (int (*)PARAMS ((int, int *))) return_zero);
  de_fault (to_can_follow_vfork_prior_to_exec, (int (*)PARAMS ((void))) return_zero);
  de_fault (to_post_follow_vfork, (void (*)PARAMS ((int, int, int, int))) target_ignore);
  de_fault (to_insert_exec_catchpoint, (int (*)PARAMS ((int))) tcomplain);
  de_fault (to_remove_exec_catchpoint, (int (*)PARAMS ((int))) tcomplain);
  de_fault (to_has_execd, (int (*)PARAMS ((int, char **))) return_zero);
  de_fault (to_reported_exec_events_per_exec_call, (int (*)PARAMS ((void))) return_one);
  de_fault (to_has_syscall_event, (int (*)PARAMS ((int, enum target_waitkind *, int *))) return_zero);
  de_fault (to_has_exited, (int (*)PARAMS ((int, int, int *))) return_zero);
  de_fault (to_mourn_inferior, (void (*)PARAMS ((void))) noprocess);
  de_fault (to_can_run, return_zero);
  de_fault (to_notice_signals, (void (*)PARAMS ((int))) target_ignore);
  de_fault (to_thread_alive, (int (*)PARAMS ((int))) target_ignore);
  de_fault (to_stop, (void (*)PARAMS ((void))) target_ignore);
  de_fault (to_query, (int (*)PARAMS ((int /*char */ , char *, char *, int *))) target_ignore);
  de_fault (to_enable_exception_callback, (struct symtab_and_line * (*)PARAMS ((enum exception_event_kind, int))) nosupport_runtime);
  de_fault (to_get_current_exception_event, (struct exception_event_record * (*)PARAMS ((void))) nosupport_runtime);
d446 2
a447 2
  de_fault (to_pid_to_exec_file, (char *(*)PARAMS ((int))) return_zero);
  de_fault (to_core_file_to_sym_file, (char *(*)PARAMS ((char *))) return_zero);
d567 4
a570 4
      fprintf_unfiltered (gdb_stderr,
			  "Magic number of %s target struct wrong\n",
			  t->to_shortname);
      abort ();
d577 1
a577 1
      if ((int) (t->to_stratum) >= (int) (cur->target_ops->to_stratum))
d590 1
a590 1
	  prev->next = cur->next;	/* Unchain old target_ops */
d592 1
a592 1
	  target_stack = cur->next;	/* Unchain first on list */
d612 1
a612 1
  cleanup_target (&current_target);	/* Fill in the gaps */
d660 1
a660 1
  (current_target.to_close) (0);	/* Let it clean up */
d664 4
a667 4
  fprintf_unfiltered (gdb_stderr,
		      "pop_target couldn't find target %s\n",
		      current_target.to_shortname);
  abort ();
d742 1
a742 1
done:
d791 2
a792 2
  int nread;			/* Number of bytes actually read. */
  int errcode;			/* Error from last read. */
d829 1
a829 1

d871 1
a871 1
    (memaddr, myaddr, len, write, &current_target);
d906 1
a906 1
    bump:
d908 2
a909 2
      myaddr += res;
      len -= res;
d924 1
a924 1

d940 1
a940 1
      if ((int) (t->to_stratum) <= (int) dummy_stratum)
d943 3
a945 3
	printf_unfiltered ("\tWhile running this, GDB does not access memory from...\n");
      printf_unfiltered ("%s:\n", t->to_longname);
      (t->to_files_info) (t);
d957 1
a957 1
  dont_repeat ();
d960 1
a960 1
    {
d962 1
a962 1
	target_kill ();
d964 1
a964 1
	error ("Program not killed.");
d993 1
a993 1
  if (STREQ (current_target.to_shortname, "rombug"))
d997 1
a997 1
	error ("Unable to link to %s and get relocation in rombug", modname);
d1000 1
a1000 1
    *t_reloc = (CORE_ADDR) - 1;
d1022 1
a1022 1
      if ((*t)->to_can_run && target_can_run (*t))
d1042 1
a1042 1
  t = find_default_run_target ("attach");
d1054 1
a1054 1
  t = find_default_run_target ("require_attach");
d1061 3
a1063 3
     int pid;
     char *args;
     int from_tty;
d1067 1
a1067 1
  t = find_default_run_target ("require_detach");
d1080 1
a1080 1
  t = find_default_run_target ("run");
d1087 2
a1088 2
     int child_pid;
     int *followed_child;
d1092 1
a1092 1
  t = find_default_run_target ("run");
d1118 1
a1118 1

d1120 1
a1120 1

d1123 1
a1123 1
      if ((*t)->to_can_run && target_can_run (*t))
d1129 1
a1129 1

d1139 1
a1139 1

d1141 1
a1141 1

d1151 2
a1152 2

  return (count == 1 ? runable : NULL);
a1287 2


d1326 1
a1326 1
       sig = (enum target_signal) ((int) sig + 1))
d1344 1
a1344 2
  if (hostsig == 0)
    return TARGET_SIGNAL_0;
d1347 1
a1347 2
  if (hostsig == SIGHUP)
    return TARGET_SIGNAL_HUP;
d1350 1
a1350 2
  if (hostsig == SIGINT)
    return TARGET_SIGNAL_INT;
d1353 1
a1353 2
  if (hostsig == SIGQUIT)
    return TARGET_SIGNAL_QUIT;
d1356 1
a1356 2
  if (hostsig == SIGILL)
    return TARGET_SIGNAL_ILL;
d1359 1
a1359 2
  if (hostsig == SIGTRAP)
    return TARGET_SIGNAL_TRAP;
d1362 1
a1362 2
  if (hostsig == SIGABRT)
    return TARGET_SIGNAL_ABRT;
d1365 1
a1365 2
  if (hostsig == SIGEMT)
    return TARGET_SIGNAL_EMT;
d1368 1
a1368 2
  if (hostsig == SIGFPE)
    return TARGET_SIGNAL_FPE;
d1371 1
a1371 2
  if (hostsig == SIGKILL)
    return TARGET_SIGNAL_KILL;
d1374 1
a1374 2
  if (hostsig == SIGBUS)
    return TARGET_SIGNAL_BUS;
d1377 1
a1377 2
  if (hostsig == SIGSEGV)
    return TARGET_SIGNAL_SEGV;
d1380 1
a1380 2
  if (hostsig == SIGSYS)
    return TARGET_SIGNAL_SYS;
d1383 1
a1383 2
  if (hostsig == SIGPIPE)
    return TARGET_SIGNAL_PIPE;
d1386 1
a1386 2
  if (hostsig == SIGALRM)
    return TARGET_SIGNAL_ALRM;
d1389 1
a1389 2
  if (hostsig == SIGTERM)
    return TARGET_SIGNAL_TERM;
d1392 1
a1392 2
  if (hostsig == SIGUSR1)
    return TARGET_SIGNAL_USR1;
d1395 1
a1395 2
  if (hostsig == SIGUSR2)
    return TARGET_SIGNAL_USR2;
d1398 1
a1398 2
  if (hostsig == SIGCLD)
    return TARGET_SIGNAL_CHLD;
d1401 1
a1401 2
  if (hostsig == SIGCHLD)
    return TARGET_SIGNAL_CHLD;
d1404 1
a1404 2
  if (hostsig == SIGPWR)
    return TARGET_SIGNAL_PWR;
d1407 1
a1407 2
  if (hostsig == SIGWINCH)
    return TARGET_SIGNAL_WINCH;
d1410 1
a1410 2
  if (hostsig == SIGURG)
    return TARGET_SIGNAL_URG;
d1413 1
a1413 2
  if (hostsig == SIGIO)
    return TARGET_SIGNAL_IO;
d1416 1
a1416 2
  if (hostsig == SIGPOLL)
    return TARGET_SIGNAL_POLL;
d1419 1
a1419 2
  if (hostsig == SIGSTOP)
    return TARGET_SIGNAL_STOP;
d1422 1
a1422 2
  if (hostsig == SIGTSTP)
    return TARGET_SIGNAL_TSTP;
d1425 1
a1425 2
  if (hostsig == SIGCONT)
    return TARGET_SIGNAL_CONT;
d1428 1
a1428 2
  if (hostsig == SIGTTIN)
    return TARGET_SIGNAL_TTIN;
d1431 1
a1431 2
  if (hostsig == SIGTTOU)
    return TARGET_SIGNAL_TTOU;
d1434 1
a1434 2
  if (hostsig == SIGVTALRM)
    return TARGET_SIGNAL_VTALRM;
d1437 1
a1437 2
  if (hostsig == SIGPROF)
    return TARGET_SIGNAL_PROF;
d1440 1
a1440 2
  if (hostsig == SIGXCPU)
    return TARGET_SIGNAL_XCPU;
d1443 1
a1443 2
  if (hostsig == SIGXFSZ)
    return TARGET_SIGNAL_XFSZ;
d1446 1
a1446 2
  if (hostsig == SIGWIND)
    return TARGET_SIGNAL_WIND;
d1449 1
a1449 2
  if (hostsig == SIGPHONE)
    return TARGET_SIGNAL_PHONE;
d1452 1
a1452 2
  if (hostsig == SIGLOST)
    return TARGET_SIGNAL_LOST;
d1455 1
a1455 2
  if (hostsig == SIGWAITING)
    return TARGET_SIGNAL_WAITING;
d1458 1
a1458 2
  if (hostsig == SIGCANCEL)
    return TARGET_SIGNAL_CANCEL;
d1461 1
a1461 2
  if (hostsig == SIGLWP)
    return TARGET_SIGNAL_LWP;
d1464 1
a1464 2
  if (hostsig == SIGDANGER)
    return TARGET_SIGNAL_DANGER;
d1467 1
a1467 2
  if (hostsig == SIGGRANT)
    return TARGET_SIGNAL_GRANT;
d1470 1
a1470 2
  if (hostsig == SIGRETRACT)
    return TARGET_SIGNAL_RETRACT;
d1473 1
a1473 2
  if (hostsig == SIGMSG)
    return TARGET_SIGNAL_MSG;
d1476 1
a1476 2
  if (hostsig == SIGSOUND)
    return TARGET_SIGNAL_SOUND;
d1479 1
a1479 2
  if (hostsig == SIGSAK)
    return TARGET_SIGNAL_SAK;
d1482 1
a1482 2
  if (hostsig == SIGPRIO)
    return TARGET_SIGNAL_PRIO;
d1487 1
a1487 2
  if (hostsig == _NSIG + EXC_BAD_ACCESS)
    return TARGET_EXC_BAD_ACCESS;
d1490 1
a1490 2
  if (hostsig == _NSIG + EXC_BAD_INSTRUCTION)
    return TARGET_EXC_BAD_INSTRUCTION;
d1493 1
a1493 2
  if (hostsig == _NSIG + EXC_ARITHMETIC)
    return TARGET_EXC_ARITHMETIC;
d1496 1
a1496 2
  if (hostsig == _NSIG + EXC_EMULATION)
    return TARGET_EXC_EMULATION;
d1499 1
a1499 2
  if (hostsig == _NSIG + EXC_SOFTWARE)
    return TARGET_EXC_SOFTWARE;
d1502 1
a1502 2
  if (hostsig == _NSIG + EXC_BREAKPOINT)
    return TARGET_EXC_BREAKPOINT;
d1506 1
a1506 2
  if (hostsig == SIGINFO)
    return TARGET_SIGNAL_INFO;
d1523 1
a1523 2
    case TARGET_SIGNAL_0:
      return 0;
d1526 1
a1526 2
    case TARGET_SIGNAL_HUP:
      return SIGHUP;
d1529 1
a1529 2
    case TARGET_SIGNAL_INT:
      return SIGINT;
d1532 1
a1532 2
    case TARGET_SIGNAL_QUIT:
      return SIGQUIT;
d1535 1
a1535 2
    case TARGET_SIGNAL_ILL:
      return SIGILL;
d1538 1
a1538 2
    case TARGET_SIGNAL_TRAP:
      return SIGTRAP;
d1541 1
a1541 2
    case TARGET_SIGNAL_ABRT:
      return SIGABRT;
d1544 1
a1544 2
    case TARGET_SIGNAL_EMT:
      return SIGEMT;
d1547 1
a1547 2
    case TARGET_SIGNAL_FPE:
      return SIGFPE;
d1550 1
a1550 2
    case TARGET_SIGNAL_KILL:
      return SIGKILL;
d1553 1
a1553 2
    case TARGET_SIGNAL_BUS:
      return SIGBUS;
d1556 1
a1556 2
    case TARGET_SIGNAL_SEGV:
      return SIGSEGV;
d1559 1
a1559 2
    case TARGET_SIGNAL_SYS:
      return SIGSYS;
d1562 1
a1562 2
    case TARGET_SIGNAL_PIPE:
      return SIGPIPE;
d1565 1
a1565 2
    case TARGET_SIGNAL_ALRM:
      return SIGALRM;
d1568 1
a1568 2
    case TARGET_SIGNAL_TERM:
      return SIGTERM;
d1571 1
a1571 2
    case TARGET_SIGNAL_USR1:
      return SIGUSR1;
d1574 1
a1574 2
    case TARGET_SIGNAL_USR2:
      return SIGUSR2;
d1577 1
a1577 1
    case TARGET_SIGNAL_CHLD:
d1585 1
a1585 2
    case TARGET_SIGNAL_PWR:
      return SIGPWR;
d1588 1
a1588 2
    case TARGET_SIGNAL_WINCH:
      return SIGWINCH;
d1591 1
a1591 2
    case TARGET_SIGNAL_URG:
      return SIGURG;
d1594 1
a1594 2
    case TARGET_SIGNAL_IO:
      return SIGIO;
d1597 1
a1597 2
    case TARGET_SIGNAL_POLL:
      return SIGPOLL;
d1600 1
a1600 2
    case TARGET_SIGNAL_STOP:
      return SIGSTOP;
d1603 1
a1603 2
    case TARGET_SIGNAL_TSTP:
      return SIGTSTP;
d1606 1
a1606 2
    case TARGET_SIGNAL_CONT:
      return SIGCONT;
d1609 1
a1609 2
    case TARGET_SIGNAL_TTIN:
      return SIGTTIN;
d1612 1
a1612 2
    case TARGET_SIGNAL_TTOU:
      return SIGTTOU;
d1615 1
a1615 2
    case TARGET_SIGNAL_VTALRM:
      return SIGVTALRM;
d1618 1
a1618 2
    case TARGET_SIGNAL_PROF:
      return SIGPROF;
d1621 1
a1621 2
    case TARGET_SIGNAL_XCPU:
      return SIGXCPU;
d1624 1
a1624 2
    case TARGET_SIGNAL_XFSZ:
      return SIGXFSZ;
d1627 1
a1627 2
    case TARGET_SIGNAL_WIND:
      return SIGWIND;
d1630 1
a1630 2
    case TARGET_SIGNAL_PHONE:
      return SIGPHONE;
d1633 1
a1633 2
    case TARGET_SIGNAL_LOST:
      return SIGLOST;
d1636 1
a1636 2
    case TARGET_SIGNAL_WAITING:
      return SIGWAITING;
d1639 1
a1639 2
    case TARGET_SIGNAL_CANCEL:
      return SIGCANCEL;
d1642 1
a1642 2
    case TARGET_SIGNAL_LWP:
      return SIGLWP;
d1645 1
a1645 2
    case TARGET_SIGNAL_DANGER:
      return SIGDANGER;
d1648 1
a1648 2
    case TARGET_SIGNAL_GRANT:
      return SIGGRANT;
d1651 1
a1651 2
    case TARGET_SIGNAL_RETRACT:
      return SIGRETRACT;
d1654 1
a1654 2
    case TARGET_SIGNAL_MSG:
      return SIGMSG;
d1657 1
a1657 2
    case TARGET_SIGNAL_SOUND:
      return SIGSOUND;
d1660 1
a1660 2
    case TARGET_SIGNAL_SAK:
      return SIGSAK;
d1663 1
a1663 2
    case TARGET_SIGNAL_PRIO:
      return SIGPRIO;
d1668 1
a1668 2
    case TARGET_EXC_BAD_ACCESS:
      return _NSIG + EXC_BAD_ACCESS;
d1671 1
a1671 2
    case TARGET_EXC_BAD_INSTRUCTION:
      return _NSIG + EXC_BAD_INSTRUCTION;
d1674 1
a1674 2
    case TARGET_EXC_ARITHMETIC:
      return _NSIG + EXC_ARITHMETIC;
d1677 1
a1677 2
    case TARGET_EXC_EMULATION:
      return _NSIG + EXC_EMULATION;
d1680 1
a1680 2
    case TARGET_EXC_SOFTWARE:
      return _NSIG + EXC_SOFTWARE;
d1683 1
a1683 2
    case TARGET_EXC_BREAKPOINT:
      return _NSIG + EXC_BREAKPOINT;
d1687 1
a1687 2
    case TARGET_SIGNAL_INFO:
      return SIGINFO;
d1696 1
a1696 1
	  (int) oursig - (int) TARGET_SIGNAL_REALTIME_33 + REALTIME_LO;
d1702 1
a1702 1
         doesn't have SIGSAK.  */
d1754 1
a1754 1
    return (enum target_signal) num;
d1787 1
a1787 1

d1791 1
a1791 1
 */
d1794 1
a1794 1
     int pid;
d1816 1
a1817 1

d1852 1
a1852 1
     int pid;
d1882 3
a1884 3
     int pid;
     char *args;
     int from_tty;
d1889 1
a1889 1
	       "target_require_detach (%d, %s, %d)\n", pid, args, from_tty);
d1956 2
a1957 2
     int pid;
     int status;
d2017 1
a2017 1
		      (unsigned int) memaddr,	/* possable truncate long long */
d2020 1
a2020 1

d2075 1
a2075 1
		      (unsigned long) addr, retval);
d2168 1
a2168 1
     int pid;
d2178 1
a2178 1
     int pid;
d2188 2
a2189 2
     int child_pid;
     int *followed_child;
d2208 1
a2208 1
     int pid;
d2210 1
a2210 1
  int retval;
d2215 1
a2215 1
		      pid, retval);
d2222 1
a2222 1
     int pid;
d2224 1
a2224 1
  int retval;
d2229 1
a2229 1
		      pid, retval);
d2236 1
a2236 1
     int pid;
d2238 1
a2238 1
  int retval;
d2243 1
a2243 1
		      pid, retval);
d2250 1
a2250 1
     int pid;
d2252 1
a2252 1
  int retval;
d2257 1
a2257 1
		      pid, retval);
d2264 2
a2265 2
     int pid;
     int *child_pid;
d2267 1
a2267 1
  int has_forked;
d2272 1
a2272 1
		      pid, *child_pid, has_forked);
d2279 2
a2280 2
     int pid;
     int *child_pid;
d2282 1
a2282 1
  int has_vforked;
d2287 1
a2287 1
		      pid, *child_pid, has_vforked);
d2295 1
a2295 1
  int can_immediately_follow_vfork;
d2300 1
a2300 1
		      can_immediately_follow_vfork);
d2307 4
a2310 4
     int parent_pid;
     int followed_parent;
     int child_pid;
     int followed_child;
d2316 1
a2316 1
		    parent_pid, followed_parent, child_pid, followed_child);
d2321 1
a2321 1
     int pid;
d2323 1
a2323 1
  int retval;
d2328 1
a2328 1
		      pid, retval);
d2335 1
a2335 1
     int pid;
d2337 1
a2337 1
  int retval;
d2342 1
a2342 1
		      pid, retval);
d2349 2
a2350 2
     int pid;
     char **execd_pathname;
d2352 1
a2352 1
  int has_execd;
d2357 1
a2357 1
		      pid, (*execd_pathname ? *execd_pathname : "<NULL>"),
d2366 1
a2366 1
  int reported_exec_events;
d2372 1
a2372 1
		      reported_exec_events);
d2379 3
a2381 3
     int pid;
     enum target_waitkind *kind;
     int *syscall_id;
d2383 2
a2384 2
  int has_syscall_event;
  char *kind_spelling = "??";
d2390 10
a2399 10
	{
	case TARGET_WAITKIND_SYSCALL_ENTRY:
	  kind_spelling = "SYSCALL_ENTRY";
	  break;
	case TARGET_WAITKIND_SYSCALL_RETURN:
	  kind_spelling = "SYSCALL_RETURN";
	  break;
	default:
	  break;
	}
d2404 1
a2404 1
		      pid, kind_spelling, *syscall_id, has_syscall_event);
d2411 3
a2413 3
     int pid;
     int wait_status;
     int *exit_status;
d2415 1
a2415 1
  int has_exited;
d2420 1
a2420 1
		      pid, wait_status, *exit_status, has_exited);
d2478 4
a2481 4
     int type;
     char *req;
     char *resp;
     int *siz;
d2494 2
a2495 2
     enum exception_event_kind kind;
     int enable;
d2509 1
a2509 1
  result = debug_target.to_get_current_exception_event ();
d2516 1
a2516 1
     int pid;
d2518 1
a2518 1
  char *exec_file;
d2523 1
a2523 1
		      pid, exec_file);
d2530 1
a2530 1
     char *core;
d2532 1
a2532 1
  char *sym_file;
d2537 1
a2537 1
		      core, sym_file);
d2603 1
d2605 2
a2606 3

static char targ_desc[] =
"Names of targets and files being debugged.\n\
d2620 3
a2622 3
		add_set_cmd ("targetdebug", class_maintenance, var_zinteger,
			     (char *) &targetdebug,
			     "Set target debugging.\n\
d2624 1
a2624 1
		      &showlist);
@


1.1.1.9
log
@import gdb-1999-07-19 snapshot
@
text
@d965 1
a965 2
      if (!from_tty
          || query ("A program is being debugged already.  Kill it? "))
@


1.1.1.10
log
@import gdb-1999-08-09 snapshot
@
text
@a446 1
  de_fault (to_rcmd, (void (*) (char *, struct gdb_file *)) tcomplain);
a529 1
      INHERIT (to_rcmd, t);
d1940 1
a1940 1
  fprintf_unfiltered (gdb_stdlog, "target_open (%s, %d)\n", args, from_tty);
d1949 1
a1949 1
  fprintf_unfiltered (gdb_stdlog, "target_close (%d)\n", quitting);
d1959 1
a1959 1
  fprintf_unfiltered (gdb_stdlog, "target_attach (%s, %d)\n", args, from_tty);
d1969 1
a1969 1
  fprintf_unfiltered (gdb_stdlog, "target_post_attach (%d)\n", pid);
d1979 1
a1979 1
  fprintf_unfiltered (gdb_stdlog,
d1990 1
a1990 1
  fprintf_unfiltered (gdb_stdlog, "target_detach (%s, %d)\n", args, from_tty);
d2001 1
a2001 1
  fprintf_unfiltered (gdb_stdlog,
d2013 1
a2013 1
  fprintf_unfiltered (gdb_stdlog, "target_resume (%d, %s, %s)\n", pid,
d2027 1
a2027 1
  fprintf_unfiltered (gdb_stdlog,
d2029 1
a2029 1
  fprintf_unfiltered (gdb_stdlog, "status->kind = ");
d2033 1
a2033 1
      fprintf_unfiltered (gdb_stdlog, "exited, status = %d\n",
d2037 1
a2037 1
      fprintf_unfiltered (gdb_stdlog, "stopped, signal = %s\n",
d2041 1
a2041 1
      fprintf_unfiltered (gdb_stdlog, "signalled, signal = %s\n",
d2045 1
a2045 1
      fprintf_unfiltered (gdb_stdlog, "loaded\n");
d2048 1
a2048 1
      fprintf_unfiltered (gdb_stdlog, "forked\n");
d2051 1
a2051 1
      fprintf_unfiltered (gdb_stdlog, "vforked\n");
d2054 1
a2054 1
      fprintf_unfiltered (gdb_stdlog, "execd\n");
d2057 1
a2057 1
      fprintf_unfiltered (gdb_stdlog, "spurious\n");
d2060 1
a2060 1
      fprintf_unfiltered (gdb_stdlog, "unknown???\n");
d2074 1
a2074 1
  fprintf_unfiltered (gdb_stdlog, "target_post_wait (%d, %d)\n",
d2084 1
a2084 1
  fprintf_unfiltered (gdb_stdlog, "target_fetch_registers (%s)",
d2087 1
a2087 1
    fprintf_unfiltered (gdb_stdlog, " = 0x%x %d",
d2090 1
a2090 1
  fprintf_unfiltered (gdb_stdlog, "\n");
d2100 1
a2100 1
    fprintf_unfiltered (gdb_stdlog, "target_store_registers (%s) = 0x%x %d\n",
d2105 1
a2105 1
    fprintf_unfiltered (gdb_stdlog, "target_store_registers (%d)\n", regno);
d2113 1
a2113 1
  fprintf_unfiltered (gdb_stdlog, "target_prepare_to_store ()\n");
d2128 1
a2128 1
  fprintf_unfiltered (gdb_stdlog,
d2139 1
a2139 1
      fputs_unfiltered (", bytes =", gdb_stdlog);
d2143 2
a2144 2
	    fprintf_unfiltered (gdb_stdlog, "\n");
	  fprintf_unfiltered (gdb_stdlog, " %02x", myaddr[i] & 0xff);
d2148 1
a2148 1
  fputc_unfiltered ('\n', gdb_stdlog);
d2159 1
a2159 1
  fprintf_unfiltered (gdb_stdlog, "target_files_info (xxx)\n");
d2171 1
a2171 1
  fprintf_unfiltered (gdb_stdlog,
d2186 1
a2186 1
  fprintf_unfiltered (gdb_stdlog,
d2197 1
a2197 1
  fprintf_unfiltered (gdb_stdlog, "target_terminal_init ()\n");
d2205 1
a2205 1
  fprintf_unfiltered (gdb_stdlog, "target_terminal_inferior ()\n");
d2213 1
a2213 1
  fprintf_unfiltered (gdb_stdlog, "target_terminal_ours_for_output ()\n");
d2221 1
a2221 1
  fprintf_unfiltered (gdb_stdlog, "target_terminal_ours ()\n");
d2231 1
a2231 1
  fprintf_unfiltered (gdb_stdlog, "target_terminal_info (%s, %d)\n", arg,
d2240 1
a2240 1
  fprintf_unfiltered (gdb_stdlog, "target_kill ()\n");
d2250 1
a2250 1
  fprintf_unfiltered (gdb_stdlog, "target_load (%s, %d)\n", args, from_tty);
d2262 1
a2262 1
  fprintf_unfiltered (gdb_stdlog, "target_lookup_symbol (%s, xxx)\n", name);
d2275 1
a2275 1
  fprintf_unfiltered (gdb_stdlog, "target_create_inferior (%s, %s, xxx)\n",
d2285 1
a2285 1
  fprintf_unfiltered (gdb_stdlog, "target_post_startup_inferior (%d)\n",
d2295 1
a2295 1
  fprintf_unfiltered (gdb_stdlog, "target_acknowledge_created_inferior (%d)\n",
d2306 1
a2306 1
  fprintf_unfiltered (gdb_stdlog,
d2316 1
a2316 1
  fprintf_unfiltered (gdb_stdlog, "target_post_follow_inferior_by_clone ()\n");
d2327 1
a2327 1
  fprintf_unfiltered (gdb_stdlog, "target_insert_fork_catchpoint (%d) = %d\n",
d2341 1
a2341 1
  fprintf_unfiltered (gdb_stdlog, "target_remove_fork_catchpoint (%d) = %d\n",
d2355 1
a2355 1
  fprintf_unfiltered (gdb_stdlog, "target_insert_vfork_catchpoint (%d)= %d\n",
d2369 1
a2369 1
  fprintf_unfiltered (gdb_stdlog, "target_remove_vfork_catchpoint (%d) = %d\n",
d2384 1
a2384 1
  fprintf_unfiltered (gdb_stdlog, "target_has_forked (%d, %d) = %d\n",
d2399 1
a2399 1
  fprintf_unfiltered (gdb_stdlog, "target_has_vforked (%d, %d) = %d\n",
d2412 1
a2412 1
  fprintf_unfiltered (gdb_stdlog, "target_can_follow_vfork_prior_to_exec () = %d\n",
d2427 1
a2427 1
  fprintf_unfiltered (gdb_stdlog,
d2440 1
a2440 1
  fprintf_unfiltered (gdb_stdlog, "target_insert_exec_catchpoint (%d) = %d\n",
d2454 1
a2454 1
  fprintf_unfiltered (gdb_stdlog, "target_remove_exec_catchpoint (%d) = %d\n",
d2469 1
a2469 1
  fprintf_unfiltered (gdb_stdlog, "target_has_execd (%d, %s) = %d\n",
d2483 1
a2483 1
  fprintf_unfiltered (gdb_stdlog,
d2515 1
a2515 1
  fprintf_unfiltered (gdb_stdlog,
d2532 1
a2532 1
  fprintf_unfiltered (gdb_stdlog, "target_has_exited (%d, %d, %d) = %d\n",
d2543 1
a2543 1
  fprintf_unfiltered (gdb_stdlog, "target_mourn_inferior ()\n");
d2553 1
a2553 1
  fprintf_unfiltered (gdb_stdlog, "target_can_run () = %d\n", retval);
d2564 1
a2564 1
  fprintf_unfiltered (gdb_stdlog, "target_notice_signals (%d)\n", pid);
d2575 1
a2575 1
  fprintf_unfiltered (gdb_stdlog, "target_thread_alive (%d) = %d\n",
d2586 1
a2586 1
  fprintf_unfiltered (gdb_stdlog, "target_stop ()\n");
d2600 1
a2600 1
  fprintf_unfiltered (gdb_stdlog, "target_query (%c, %s, %s,  %d) = %d\n", type, req, resp, *siz, retval);
a2604 8
static void
debug_to_rcmd (char *command,
	       struct gdb_file *outbuf)
{
  debug_target.to_rcmd (command, outbuf);
  fprintf_unfiltered (gdb_stdlog, "target_rcmd (%s, ...)\n", command);
}

d2612 1
a2612 1
  fprintf_unfiltered (gdb_stdlog,
d2623 1
a2623 1
  fprintf_unfiltered (gdb_stdlog, "target get_current_exception_event ()\n");
d2635 1
a2635 1
  fprintf_unfiltered (gdb_stdlog, "target_pid_to_exec_file (%d) = %s\n",
d2649 1
a2649 1
  fprintf_unfiltered (gdb_stdlog, "target_core_file_to_sym_file (%s) = %s\n",
a2709 1
  current_target.to_rcmd = debug_to_rcmd;
a2722 13
static void
do_monitor_command (char *cmd,
		 int from_tty)
{
  if ((current_target.to_rcmd == (void*) tcomplain)
      || (current_target.to_rcmd == debug_to_rcmd
	  && (debug_target.to_rcmd == (void*) tcomplain)))
    {
      error ("\"monitor\" command not supported by this target.\n");
    }
  target_rcmd (cmd, gdb_stdtarg);
}

a2737 4


  add_com ("monitor", class_obscure, do_monitor_command,
	   "Send a command to the remote monitor (remote targets only).");
@


1.1.1.11
log
@import gdb-1999-08-30 snapshot
@
text
@d1888 1
a1888 1
    sprintf (buf, "thread %d", pid);
d1890 1
a1890 1
    sprintf (buf, "process %d", pid);
d2089 1
a2089 1
    fprintf_unfiltered (gdb_stdlog, " = 0x%lx %ld",
d2091 1
a2091 1
			(unsigned long) read_register (regno));
d2102 1
a2102 1
    fprintf_unfiltered (gdb_stdlog, "target_store_registers (%s) = 0x%lx %ld\n",
d2174 2
a2175 3
		      "target_insert_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) addr,
		      (unsigned long) retval);
d2189 2
a2190 3
		      "target_remove_breakpoint (0x%lx, xxx) = %ld\n",
		      (unsigned long) addr,
		      (unsigned long) retval);
@


1.1.1.12
log
@import gdb-1999-09-08 snapshot
@
text
@a1274 1
  {"SIG32", "Real-time event 32"},
d1574 2
a1575 10
    {
      /* This block of TARGET_SIGNAL_REALTIME value is in order.  */
      if (33 <= hostsig && hostsig <= 63)
	return (enum target_signal)
	  (hostsig - 33 + (int) TARGET_SIGNAL_REALTIME_33);
      else if (hostsig == 32)
	return TARGET_SIGNAL_REALTIME_32;
      else
	error ("GDB bug: target.c (target_signal_from_host): unrecognized real-time signal");
    }
a1772 2

    case TARGET_SIGNAL_REALTIME_32: return 32; /* by definition */ 
@


1.1.1.13
log
@import gdb-1999-09-28 snapshot
@
text
@a452 3
  de_fault (to_can_async_p, (int (*) (void)) return_zero);
  de_fault (to_is_async_p, (int (*) (void)) return_zero);
  de_fault (to_async, (void (*) (void (*) (int, void*, int), void*)) tcomplain);
d544 1
a546 3
      INHERIT (to_can_async_p, t);
      INHERIT (to_is_async_p, t);
      INHERIT (to_async, t);
a1113 50
}

/*
 * Resize the to_sections pointer.  Also make sure that anyone that
 * was holding on to an old value of it gets updated.
 * Returns the old size.
 */

int
target_resize_to_sections (struct target_ops *target, int num_added)
{
  struct target_ops **t;
  struct section_table *old_value;
  int old_count;

  old_value = target->to_sections;

  if (target->to_sections)
    {
      old_count = target->to_sections_end - target->to_sections;
      target->to_sections = (struct section_table *)
	xrealloc ((char *) target->to_sections,
		  (sizeof (struct section_table)) * (num_added + old_count));
    }
  else
    {
      old_count = 0;
      target->to_sections = (struct section_table *)
	xmalloc ((sizeof (struct section_table)) * num_added);
    }
  target->to_sections_end = target->to_sections + (num_added + old_count);

  /* Check to see if anyone else was pointing to this structure.
     If old_value was null, then no one was. */
     
  if (old_value)
    {
      for (t = target_structs; t < target_structs + target_struct_size;
	   ++t)
	{
	  if ((*t)->to_sections == old_value)
	    {
	      (*t)->to_sections = target->to_sections;
	      (*t)->to_sections_end = target->to_sections_end;
	    }
	}
    }
  
  return old_count;

@


1.1.1.14
log
@import gdb-1999-10-04 snapshot
@
text
@d455 1
a455 1
  de_fault (to_async, (void (*) (void (*) (enum inferior_event_type, void*), void*)) tcomplain);
d1012 1
a1012 1
    *t_reloc = (CORE_ADDR) -1;
@


1.1.1.15
log
@import gdb-1999-10-18 snapshot
@
text
@d90 4
a93 5
/* Transfer LEN bytes between target address MEMADDR and GDB address
   MYADDR.  Returns 0 for success, errno code for failure (which
   includes partial transfers -- if you want a more useful response to
   partial transfers, try either target_read_memory_partial or
   target_write_memory_partial).  */
d790 42
a924 69

/* Perform a partial memory transfer.  */

static int
target_xfer_memory_partial (CORE_ADDR memaddr, char *buf, int len,
			    int write_p, int *err)
{
  int res;
  int err_res;
  int len_res;
  struct target_ops *t;
  struct target_stack_item *item;

  /* Zero length requests are ok and require no work.  */
  if (len == 0)
    {
      *err = 0;
      return 0;
    }

  /* The quick case is that the top target does it all.  */
  res = current_target.to_xfer_memory (memaddr, buf, len, write_p, &current_target);
  if (res > 0)
    {
      *err = 0;
      return res;
    }

  /* xfer memory doesn't always reliably set errno. */
  errno = 0;

  /* Try all levels of the target stack to see one can handle it. */
  for (item = target_stack; item; item = item->next)
    {
      t = item->target_ops;
      if (!t->to_has_memory)
	continue;
      res = t->to_xfer_memory (memaddr, buf, len, write_p, t);
      if (res > 0)
	{
	  /* Handled all or part of xfer */
	  *err = 0;
	  return res;
	}
      if (t->to_has_all_memory)
	break;
    }

  /* Total failure.  Return error. */
  if (errno != 0)
    {
      *err = errno;
      return -1;
    }
  *err = EIO;
  return -1;
}

int
target_read_memory_partial (CORE_ADDR memaddr, char *buf, int len, int *err)
{
  return target_xfer_memory_partial (memaddr, buf, len, 0, err);
}

int
target_write_memory_partial (CORE_ADDR memaddr, char *buf, int len, int *err)
{
  return target_xfer_memory_partial (memaddr, buf, len, 1, err);
}
@


1.1.1.16
log
@import gdb-1999-11-08 snapshot
@
text
@a274 6
void
target_load (char *arg, int from_tty)
{
  (*current_target.to_load) (arg, from_tty);
}

@


1.1.1.17
log
@import gdb-1999-12-06 snapshot
@
text
@d1678 3
a1680 8
/* Convert a OURSIG (an enum target_signal) to the form used by the
   target operating system (refered to as the ``host'') or zero if the
   equivalent host signal is not available.  Set/clear OURSIG_OK
   accordingly. */

static int
do_target_signal_to_host (enum target_signal oursig,
			  int *oursig_ok)
a1681 1
  *oursig_ok = 1;
a1915 20
      *oursig_ok = 0;
      return 0;
    }
}

int
target_signal_to_host_p (enum target_signal oursig)
{
  int oursig_ok;
  do_target_signal_to_host (oursig, &oursig_ok);
  return oursig_ok;
}

int
target_signal_to_host (enum target_signal oursig)
{
  int oursig_ok;
  int targ_signo = do_target_signal_to_host (oursig, &oursig_ok);
  if (!oursig_ok)
    {
a1921 2
  else
    return targ_signo;
@


1.1.1.18
log
@import gdb-1999-12-21 snapshot
@
text
@d81 1
a81 1
find_default_run_target PARAMS ((char *));
a538 1
      INHERIT (to_pid_to_str, t);
a558 1
      INHERIT (to_async_mask_value, t);
a1048 8
int
target_async_mask (int mask)
{
  int saved_async_masked_status = target_async_mask_value;
  target_async_mask_value = mask;
  return saved_async_masked_status;
}

a1228 3
/* Find a single core_stratum target in the list of targets and return it.
   If for some reason there is more than one, return NULL.  */

a1249 21

/*
 * Find the next target down the stack from the specified target.
 */

struct target_ops *
find_target_beneath (t)
     struct target_ops *t;
{
  struct target_stack_item *cur;

  for (cur = target_stack; cur; cur = cur->next)
    if (cur->target_ops == t)
      break;

  if (cur == NULL || cur->next == NULL)
    return NULL;
  else
    return cur->next->target_ops;
}

a2055 1
  dummy_target.to_pid_to_str = normal_pid_to_str;
@


1.1.1.19
log
@import gdb-2000-01-10 snapshot
@
text
@d400 1
a400 2
  if (!t->field)               \
    t->field = value
d402 61
a462 172
  de_fault (to_open, 
	    (void (*) (char *, int)) 
	    tcomplain);
  de_fault (to_close, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_attach, 
	    maybe_kill_then_attach);
  de_fault (to_post_attach, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_require_attach, 
	    maybe_kill_then_attach);
  de_fault (to_detach, 
	    (void (*) (char *, int)) 
	    target_ignore);
  de_fault (to_require_detach, 
	    (void (*) (int, char *, int)) 
	    target_ignore);
  de_fault (to_resume, 
	    (void (*) (int, int, enum target_signal)) 
	    noprocess);
  de_fault (to_wait, 
	    (int (*) (int, struct target_waitstatus *)) 
	    noprocess);
  de_fault (to_post_wait, 
	    (void (*) (int, int)) 
	    target_ignore);
  de_fault (to_fetch_registers, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_store_registers, 
	    (void (*) (int)) 
	    noprocess);
  de_fault (to_prepare_to_store, 
	    (void (*) (void)) 
	    noprocess);
  de_fault (to_xfer_memory, 
	    (int (*) (CORE_ADDR, char *, int, int, struct target_ops *)) 
	    nomemory);
  de_fault (to_files_info, 
	    (void (*) (struct target_ops *)) 
	    target_ignore);
  de_fault (to_insert_breakpoint, 
	    memory_insert_breakpoint);
  de_fault (to_remove_breakpoint, 
	    memory_remove_breakpoint);
  de_fault (to_terminal_init, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_inferior, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_ours_for_output, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_ours, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_terminal_info, 
	    default_terminal_info);
  de_fault (to_kill, 
	    (void (*) (void)) 
	    noprocess);
  de_fault (to_load, 
	    (void (*) (char *, int)) 
	    tcomplain);
  de_fault (to_lookup_symbol, 
	    (int (*) (char *, CORE_ADDR *)) 
	    nosymbol);
  de_fault (to_create_inferior, 
	    maybe_kill_then_create_inferior);
  de_fault (to_post_startup_inferior, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_acknowledge_created_inferior, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_clone_and_follow_inferior, 
	    default_clone_and_follow_inferior);
  de_fault (to_post_follow_inferior_by_clone, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_insert_fork_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_remove_fork_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_insert_vfork_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_remove_vfork_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_has_forked, 
	    (int (*) (int, int *)) 
	    return_zero);
  de_fault (to_has_vforked, 
	    (int (*) (int, int *)) 
	    return_zero);
  de_fault (to_can_follow_vfork_prior_to_exec, 
	    (int (*) (void)) 
	    return_zero);
  de_fault (to_post_follow_vfork, 
	    (void (*) (int, int, int, int)) 
	    target_ignore);
  de_fault (to_insert_exec_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_remove_exec_catchpoint, 
	    (int (*) (int)) 
	    tcomplain);
  de_fault (to_has_execd, 
	    (int (*) (int, char **)) 
	    return_zero);
  de_fault (to_reported_exec_events_per_exec_call, 
	    (int (*) (void)) 
	    return_one);
  de_fault (to_has_syscall_event, 
	    (int (*) (int, enum target_waitkind *, int *)) 
	    return_zero);
  de_fault (to_has_exited, 
	    (int (*) (int, int, int *)) 
	    return_zero);
  de_fault (to_mourn_inferior, 
	    (void (*) (void)) 
	    noprocess);
  de_fault (to_can_run, 
	    return_zero);
  de_fault (to_notice_signals, 
	    (void (*) (int)) 
	    target_ignore);
  de_fault (to_thread_alive, 
	    (int (*) (int)) 
	    return_zero);
  de_fault (to_find_new_threads, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_extra_thread_info, 
	    (char *(*) (struct thread_info *)) 
	    return_zero);
  de_fault (to_stop, 
	    (void (*) (void)) 
	    target_ignore);
  de_fault (to_query, 
	    (int (*) (int, char *, char *, int *)) 
	    return_zero);
  de_fault (to_rcmd, 
	    (void (*) (char *, struct gdb_file *)) 
	    tcomplain);
  de_fault (to_enable_exception_callback, 
	    (struct symtab_and_line * (*) (enum exception_event_kind, int)) 
	    nosupport_runtime);
  de_fault (to_get_current_exception_event, 
	    (struct exception_event_record * (*) (void)) 
	    nosupport_runtime);
  de_fault (to_pid_to_exec_file, 
	    (char *(*) (int)) 
	    return_zero);
  de_fault (to_core_file_to_sym_file, 
	    (char *(*) (char *)) 
	    return_zero);
  de_fault (to_can_async_p, 
	    (int (*) (void)) 
	    return_zero);
  de_fault (to_is_async_p, 
	    (int (*) (void)) 
	    return_zero);
  de_fault (to_async, 
	    (void (*) (void (*) (enum inferior_event_type, void*), void*)) 
	    tcomplain);
a539 1
      INHERIT (to_extra_thread_info, t);
a2748 8
debug_to_find_new_threads ()
{
  debug_target.to_find_new_threads ();

  fputs_unfiltered ("target_find_new_threads ()\n", gdb_stdlog);
}

static void
a2882 1
  current_target.to_find_new_threads = debug_to_find_new_threads;
@


1.1.1.20
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1990, 1992-1995, 1998-2000 Free Software Foundation, Inc.
d552 1
a552 1
	    (void (*) (char *, struct ui_file *)) 
d2895 1
a2895 1
	       struct ui_file *outbuf)
@


