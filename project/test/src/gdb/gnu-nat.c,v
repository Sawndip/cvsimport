head	1.90;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.85
	gdb_7_6-2013-04-26-release:1.85
	gdb_7_6-branch:1.85.0.2
	gdb_7_6-2013-03-12-branchpoint:1.85
	gdb_7_5_1-2012-11-29-release:1.79
	gdb_7_5-2012-08-17-release:1.79
	gdb_7_5-branch:1.79.0.2
	gdb_7_5-2012-07-18-branchpoint:1.79
	gdb_7_4_1-2012-04-26-release:1.76.2.1
	gdb_7_4-2012-01-24-release:1.76.2.1
	gdb_7_4-branch:1.76.0.2
	gdb_7_4-2011-12-13-branchpoint:1.76
	gdb_7_3_1-2011-09-04-release:1.75
	gdb_7_3-2011-07-26-release:1.75
	gdb_7_3-branch:1.75.0.2
	gdb_7_3-2011-04-01-branchpoint:1.75
	gdb_7_2-2010-09-02-release:1.72
	gdb_7_2-branch:1.72.0.2
	gdb_7_2-2010-07-07-branchpoint:1.72
	gdb_7_1-2010-03-18-release:1.71
	gdb_7_1-branch:1.71.0.2
	gdb_7_1-2010-02-18-branchpoint:1.71
	gdb_7_0_1-2009-12-22-release:1.68
	gdb_7_0-2009-10-06-release:1.68
	gdb_7_0-branch:1.68.0.2
	gdb_7_0-2009-09-16-branchpoint:1.68
	arc-sim-20090309:1.46
	msnyder-checkpoint-072509-branch:1.67.0.2
	msnyder-checkpoint-072509-branchpoint:1.67
	arc-insight_6_8-branch:1.46.0.8
	arc-insight_6_8-branchpoint:1.46
	insight_6_8-branch:1.46.0.6
	insight_6_8-branchpoint:1.46
	reverse-20081226-branch:1.56.0.4
	reverse-20081226-branchpoint:1.56
	multiprocess-20081120-branch:1.56.0.2
	multiprocess-20081120-branchpoint:1.56
	reverse-20080930-branch:1.54.0.2
	reverse-20080930-branchpoint:1.54
	reverse-20080717-branch:1.49.0.2
	reverse-20080717-branchpoint:1.49
	msnyder-reverse-20080609-branch:1.46.0.4
	msnyder-reverse-20080609-branchpoint:1.46
	drow-reverse-20070409-branch:1.42.0.2
	drow-reverse-20070409-branchpoint:1.42
	gdb_6_8-2008-03-27-release:1.46
	gdb_6_8-branch:1.46.0.2
	gdb_6_8-2008-02-26-branchpoint:1.46
	gdb_6_7_1-2007-10-29-release:1.45
	gdb_6_7-2007-10-10-release:1.45
	gdb_6_7-branch:1.45.0.2
	gdb_6_7-2007-09-07-branchpoint:1.45
	insight_6_6-20070208-release:1.41
	gdb_6_6-2006-12-18-release:1.41
	gdb_6_6-branch:1.41.0.2
	gdb_6_6-2006-11-15-branchpoint:1.41
	insight_6_5-20061003-release:1.40
	gdb-csl-symbian-6_4_50_20060226-12:1.39
	gdb-csl-sourcerygxx-3_4_4-25:1.37.10.1
	nickrob-async-20060828-mergepoint:1.41
	gdb-csl-symbian-6_4_50_20060226-11:1.39
	gdb-csl-sourcerygxx-4_1-17:1.39
	gdb-csl-20060226-branch-local-2:1.39
	gdb-csl-sourcerygxx-4_1-14:1.39
	gdb-csl-sourcerygxx-4_1-13:1.39
	gdb-csl-sourcerygxx-4_1-12:1.39
	gdb-csl-sourcerygxx-3_4_4-21:1.39
	gdb_6_5-20060621-release:1.40
	gdb-csl-sourcerygxx-4_1-9:1.39
	gdb-csl-sourcerygxx-4_1-8:1.39
	gdb-csl-sourcerygxx-4_1-7:1.39
	gdb-csl-arm-2006q1-6:1.39
	gdb-csl-sourcerygxx-4_1-6:1.39
	gdb-csl-symbian-6_4_50_20060226-10:1.39
	gdb-csl-symbian-6_4_50_20060226-9:1.39
	gdb-csl-symbian-6_4_50_20060226-8:1.39
	gdb-csl-coldfire-4_1-11:1.39
	gdb-csl-sourcerygxx-3_4_4-19:1.39
	gdb-csl-coldfire-4_1-10:1.39
	gdb_6_5-branch:1.40.0.4
	gdb_6_5-2006-05-14-branchpoint:1.40
	gdb-csl-sourcerygxx-4_1-5:1.39
	nickrob-async-20060513-branch:1.40.0.2
	nickrob-async-20060513-branchpoint:1.40
	gdb-csl-sourcerygxx-4_1-4:1.39
	msnyder-reverse-20060502-branch:1.39.0.12
	msnyder-reverse-20060502-branchpoint:1.39
	gdb-csl-morpho-4_1-4:1.39
	gdb-csl-sourcerygxx-3_4_4-17:1.39
	readline_5_1-import-branch:1.39.0.10
	readline_5_1-import-branchpoint:1.39
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.39
	gdb-csl-symbian-20060226-branch:1.39.0.8
	gdb-csl-symbian-20060226-branchpoint:1.39
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.39
	msnyder-reverse-20060331-branch:1.39.0.6
	msnyder-reverse-20060331-branchpoint:1.39
	gdb-csl-available-20060303-branch:1.39.0.4
	gdb-csl-available-20060303-branchpoint:1.39
	gdb-csl-20060226-branch:1.39.0.2
	gdb-csl-20060226-branchpoint:1.39
	gdb_6_4-20051202-release:1.37
	msnyder-fork-checkpoint-branch:1.37.0.12
	msnyder-fork-checkpoint-branchpoint:1.37
	gdb-csl-gxxpro-6_3-branch:1.37.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.37
	gdb_6_4-branch:1.37.0.8
	gdb_6_4-2005-11-01-branchpoint:1.37
	gdb-csl-arm-20051020-branch:1.37.0.6
	gdb-csl-arm-20051020-branchpoint:1.37
	msnyder-tracepoint-checkpoint-branch:1.37.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.37
	gdb-csl-arm-20050325-2005-q1b:1.37
	gdb-csl-arm-20050325-2005-q1a:1.37
	csl-arm-20050325-branch:1.37.0.2
	csl-arm-20050325-branchpoint:1.37
	gdb-post-i18n-errorwarning-20050211:1.33
	gdb-pre-i18n-errorwarning-20050211:1.32
	gdb_6_3-20041109-release:1.32
	gdb_6_3-branch:1.32.0.2
	gdb_6_3-20041019-branchpoint:1.32
	drow_intercu-merge-20040921:1.31
	drow_intercu-merge-20040915:1.31
	jimb-gdb_6_2-e500-branch:1.31.0.6
	jimb-gdb_6_2-e500-branchpoint:1.31
	gdb_6_2-20040730-release:1.31
	gdb_6_2-branch:1.31.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.31
	gdb_6_1_1-20040616-release:1.28
	gdb_6_1-2004-04-05-release:1.28
	drow_intercu-merge-20040402:1.28
	drow_intercu-merge-20040327:1.28
	ezannoni_pie-20040323-branch:1.28.0.12
	ezannoni_pie-20040323-branchpoint:1.28
	cagney_tramp-20040321-mergepoint:1.28
	cagney_tramp-20040309-branch:1.28.0.10
	cagney_tramp-20040309-branchpoint:1.28
	gdb_6_1-branch:1.28.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.28
	drow_intercu-20040221-branch:1.28.0.6
	drow_intercu-20040221-branchpoint:1.28
	cagney_bfdfile-20040213-branch:1.28.0.4
	cagney_bfdfile-20040213-branchpoint:1.28
	drow-cplus-merge-20040208:1.28
	carlton_dictionary-20040126-merge:1.28
	cagney_bigcore-20040122-branch:1.28.0.2
	cagney_bigcore-20040122-branchpoint:1.28
	drow-cplus-merge-20040113:1.28
	drow-cplus-merge-20031224:1.28
	drow-cplus-merge-20031220:1.28
	carlton_dictionary-20031215-merge:1.28
	drow-cplus-merge-20031214:1.28
	carlton-dictionary-20031111-merge:1.28
	gdb_6_0-2003-10-04-release:1.26
	kettenis_sparc-20030918-branch:1.27.0.4
	kettenis_sparc-20030918-branchpoint:1.27
	carlton_dictionary-20030917-merge:1.27
	ezannoni_pie-20030916-branchpoint:1.27
	ezannoni_pie-20030916-branch:1.27.0.2
	cagney_x86i386-20030821-branch:1.26.0.4
	cagney_x86i386-20030821-branchpoint:1.26
	carlton_dictionary-20030805-merge:1.26
	carlton_dictionary-20030627-merge:1.26
	gdb_6_0-branch:1.26.0.2
	gdb_6_0-2003-06-23-branchpoint:1.26
	jimb-ppc64-linux-20030613-branch:1.25.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.25
	cagney_convert-20030606-branch:1.25.0.30
	cagney_convert-20030606-branchpoint:1.25
	cagney_writestrings-20030508-branch:1.25.0.28
	cagney_writestrings-20030508-branchpoint:1.25
	jimb-ppc64-linux-20030528-branch:1.25.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.25
	carlton_dictionary-20030523-merge:1.25
	cagney_fileio-20030521-branch:1.25.0.24
	cagney_fileio-20030521-branchpoint:1.25
	kettenis_i386newframe-20030517-mergepoint:1.25
	jimb-ppc64-linux-20030509-branch:1.25.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.25
	kettenis_i386newframe-20030504-mergepoint:1.25
	carlton_dictionary-20030430-merge:1.25
	kettenis_i386newframe-20030419-branch:1.25.0.20
	kettenis_i386newframe-20030419-branchpoint:1.25
	carlton_dictionary-20030416-merge:1.25
	cagney_frameaddr-20030409-mergepoint:1.25
	kettenis_i386newframe-20030406-branch:1.25.0.18
	kettenis_i386newframe-20030406-branchpoint:1.25
	cagney_frameaddr-20030403-branchpoint:1.25
	cagney_frameaddr-20030403-branch:1.25.0.16
	cagney_framebase-20030330-mergepoint:1.25
	cagney_framebase-20030326-branch:1.25.0.14
	cagney_framebase-20030326-branchpoint:1.25
	cagney_lazyid-20030317-branch:1.25.0.12
	cagney_lazyid-20030317-branchpoint:1.25
	kettenis-i386newframe-20030316-mergepoint:1.25
	offbyone-20030313-branch:1.25.0.10
	offbyone-20030313-branchpoint:1.25
	kettenis-i386newframe-20030308-branch:1.25.0.8
	kettenis-i386newframe-20030308-branchpoint:1.25
	carlton_dictionary-20030305-merge:1.25
	cagney_offbyone-20030303-branch:1.25.0.6
	cagney_offbyone-20030303-branchpoint:1.25
	carlton_dictionary-20030207-merge:1.25
	interps-20030203-mergepoint:1.25
	interps-20030202-branch:1.25.0.4
	interps-20030202-branchpoint:1.25
	cagney-unwind-20030108-branch:1.25.0.2
	cagney-unwind-20030108-branchpoint:1.25
	carlton_dictionary-20021223-merge:1.25
	gdb_5_3-2002-12-12-release:1.23.2.1
	carlton_dictionary-20021115-merge:1.25
	kseitz_interps-20021105-merge:1.24
	kseitz_interps-20021103-merge:1.24
	drow-cplus-merge-20021020:1.24
	drow-cplus-merge-20021025:1.24
	carlton_dictionary-20021025-merge:1.24
	carlton_dictionary-20021011-merge:1.24
	drow-cplus-branch:1.24.0.2
	drow-cplus-branchpoint:1.24
	kseitz_interps-20020930-merge:1.24
	carlton_dictionary-20020927-merge:1.23
	carlton_dictionary-branch:1.23.0.4
	carlton_dictionary-20020920-branchpoint:1.23
	gdb_5_3-branch:1.23.0.2
	gdb_5_3-2002-09-04-branchpoint:1.23
	kseitz_interps-20020829-merge:1.23
	cagney_sysregs-20020825-branch:1.22.0.10
	cagney_sysregs-20020825-branchpoint:1.22
	readline_4_3-import-branch:1.22.0.8
	readline_4_3-import-branchpoint:1.22
	gdb_5_2_1-2002-07-23-release:1.18
	kseitz_interps-20020528-branch:1.22.0.6
	kseitz_interps-20020528-branchpoint:1.22
	cagney_regbuf-20020515-branch:1.22.0.4
	cagney_regbuf-20020515-branchpoint:1.22
	jimb-macro-020506-branch:1.22.0.2
	jimb-macro-020506-branchpoint:1.22
	gdb_5_2-2002-04-29-release:1.18
	gdb_5_2-branch:1.18.0.2
	gdb_5_2-2002-03-03-branchpoint:1.18
	gdb_5_1_1-2002-01-24-release:1.16
	gdb_5_1_0_1-2002-01-03-release:1.16
	cygnus_cvs_20020108_pre:1.18
	gdb_5_1_0_1-2002-01-03-branchpoint:1.16
	gdb_5_1_0_1-2002-01-03-branch:1.16.0.8
	gdb_5_1-2001-11-21-release:1.16
	gdb_s390-2001-09-26-branch:1.16.0.6
	gdb_s390-2001-09-26-branchpoint:1.16
	gdb_5_1-2001-07-29-branch:1.16.0.4
	gdb_5_1-2001-07-29-branchpoint:1.16
	dberlin-typesystem-branch:1.16.0.2
	dberlin-typesystem-branchpoint:1.16
	gdb-post-ptid_t-2001-05-03:1.15
	gdb-pre-ptid_t-2001-05-03:1.14
	insight-precleanup-2001-01-01:1.9
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.5
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	repo-unification-2000-02-06:1.1.1.9
	insight-2000-02-04:1.1.1.9
	gdb-2000-02-04:1.1.1.9
	gdb-2000-02-02:1.1.1.9
	gdb-2000-02-01:1.1.1.9
	gdb-2000-01-31:1.1.1.9
	gdb-2000-01-26:1.1.1.8
	gdb-2000-01-24:1.1.1.8
	gdb-2000-01-17:1.1.1.8
	gdb-2000-01-10:1.1.1.8
	gdb-2000-01-05:1.1.1.8
	gdb-1999-12-21:1.1.1.8
	gdb-1999-12-13:1.1.1.7
	gdb-1999-12-07:1.1.1.7
	gdb-1999-12-06:1.1.1.7
	gdb-1999-11-16:1.1.1.7
	gdb-1999-11-08:1.1.1.7
	gdb-1999-11-01:1.1.1.7
	gdb-1999-10-25:1.1.1.7
	gdb-1999-10-18:1.1.1.7
	gdb-1999-10-11:1.1.1.7
	gdb-1999-10-04:1.1.1.7
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.6
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.6
	gdb-1999-08-23:1.1.1.6
	gdb-1999-08-16:1.1.1.6
	gdb-1999-08-09:1.1.1.6
	gdb-1999-08-02:1.1.1.6
	gdb-1999-07-26:1.1.1.6
	gdb-1999-07-19:1.1.1.6
	gdb-1999-07-12:1.1.1.6
	gdb-post-reformat-19990707:1.1.1.6
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.6
	gdb-pre-reformat-19990707:1.1.1.5
	gdb-1999-07-07:1.1.1.5
	gdb-1999-07-05:1.1.1.4
	gdb-1999-06-28:1.1.1.4
	gdb-1999-06-21:1.1.1.4
	gdb-1999-06-14:1.1.1.4
	gdb-1999-06-07:1.1.1.4
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.90
date	2013.09.30.11.50.11;	author luisgpm;	state Exp;
branches;
next	1.89;

1.89
date	2013.09.19.13.40.38;	author tschwinge;	state Exp;
branches;
next	1.88;

1.88
date	2013.09.18.14.47.51;	author palves;	state Exp;
branches;
next	1.87;

1.87
date	2013.09.18.12.00.06;	author palves;	state Exp;
branches;
next	1.86;

1.86
date	2013.06.07.14.39.31;	author palves;	state Exp;
branches;
next	1.85;

1.85
date	2013.01.01.06.32.44;	author brobecke;	state Exp;
branches;
next	1.84;

1.84
date	2012.11.20.22.51.04;	author muller;	state Exp;
branches;
next	1.83;

1.83
date	2012.11.09.19.57.59;	author tromey;	state Exp;
branches;
next	1.82;

1.82
date	2012.11.07.20.10.13;	author palves;	state Exp;
branches;
next	1.81;

1.81
date	2012.08.09.06.26.24;	author qiyao;	state Exp;
branches;
next	1.80;

1.80
date	2012.08.07.13.26.32;	author jkratoch;	state Exp;
branches;
next	1.79;

1.79
date	2012.05.24.16.51.34;	author palves;	state Exp;
branches;
next	1.78;

1.78
date	2012.05.24.16.39.08;	author palves;	state Exp;
branches;
next	1.77;

1.77
date	2012.01.04.08.17.03;	author brobecke;	state Exp;
branches;
next	1.76;

1.76
date	2011.09.22.10.22.28;	author gingold;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2011.01.07.19.36.19;	author msnyder;	state Exp;
branches;
next	1.74;

1.74
date	2011.01.01.15.33.05;	author brobecke;	state Exp;
branches;
next	1.73;

1.73
date	2010.08.31.18.08.43;	author jkratoch;	state Exp;
branches;
next	1.72;

1.72
date	2010.05.14.20.17.37;	author msnyder;	state Exp;
branches;
next	1.71;

1.71
date	2010.02.15.17.35.49;	author jkratoch;	state Exp;
branches;
next	1.70;

1.70
date	2010.01.01.07.31.32;	author brobecke;	state Exp;
branches;
next	1.69;

1.69
date	2009.10.19.09.51.41;	author palves;	state Exp;
branches;
next	1.68;

1.68
date	2009.07.30.17.42.24;	author tschwinge;	state Exp;
branches;
next	1.67;

1.67
date	2009.07.20.15.18.24;	author palves;	state Exp;
branches;
next	1.66;

1.66
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.65;

1.65
date	2009.06.07.16.46.48;	author palves;	state Exp;
branches;
next	1.64;

1.64
date	2009.05.21.15.48.41;	author palves;	state Exp;
branches;
next	1.63;

1.63
date	2009.05.12.16.51.12;	author palves;	state Exp;
branches;
next	1.62;

1.62
date	2009.04.17.15.44.28;	author muller;	state Exp;
branches;
next	1.61;

1.61
date	2009.03.17.19.28.08;	author brobecke;	state Exp;
branches;
next	1.60;

1.60
date	2009.02.25.02.14.22;	author teawater;	state Exp;
branches;
next	1.59;

1.59
date	2009.02.23.00.03.49;	author palves;	state Exp;
branches;
next	1.58;

1.58
date	2009.02.06.22.21.26;	author palves;	state Exp;
branches;
next	1.57;

1.57
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.56;

1.56
date	2008.11.09.11.27.17;	author vprus;	state Exp;
branches;
next	1.55;

1.55
date	2008.10.07.18.42.42;	author palves;	state Exp;
branches;
next	1.54;

1.54
date	2008.09.22.15.21.30;	author palves;	state Exp;
branches;
next	1.53;

1.53
date	2008.09.22.15.16.51;	author palves;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.09.15.49.04;	author palves;	state Exp;
branches;
next	1.51;

1.51
date	2008.09.09.12.08.12;	author palves;	state Exp;
branches;
next	1.50;

1.50
date	2008.09.08.21.33.25;	author palves;	state Exp;
branches;
next	1.49;

1.49
date	2008.07.09.22.49.56;	author palves;	state Exp;
branches;
next	1.48;

1.48
date	2008.07.03.17.38.08;	author palves;	state Exp;
branches;
next	1.47;

1.47
date	2008.06.20.06.51.34;	author muller;	state Exp;
branches;
next	1.46;

1.46
date	2008.01.01.22.53.10;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2007.08.23.18.08.33;	author brobecke;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.06.18.55.41;	author uweigand;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.06.14.34.37;	author uweigand;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.16.09.57.02;	author amszmidt;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.11.19.37.52;	author drow;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2006.01.24.22.09.28;	author drow;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.17.22.34.00;	author eliz;	state Exp;
branches;
next	1.37;

1.37
date	2005.02.21.17.14.03;	author cagney;	state Exp;
branches
	1.37.6.1
	1.37.10.1;
next	1.36;

1.36
date	2005.02.15.15.49.10;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.14.18.10.08;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.11.18.13.49;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2005.02.11.04.05.50;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2004.10.08.20.29.46;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.08.19.58.11;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.25.14.58.26;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.04.14.23.51;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.30.13.23.49;	author cagney;	state Exp;
branches
	1.28.6.1;
next	1.27;

1.27
date	2003.09.09.03.14.02;	author cagney;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2003.06.14.16.18.32;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.12.21.43.55;	author drow;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.29.15.25.30;	author cagney;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2002.08.26.19.18.33;	author ciceron;	state Exp;
branches
	1.23.2.1
	1.23.4.1;
next	1.22;

1.22
date	2002.04.30.21.12.30;	author msnyder;	state Exp;
branches
	1.22.6.1;
next	1.21;

1.21
date	2002.04.30.19.01.57;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.24.21.44.46;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.27.21.35.35;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.06.19.18.28;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.10.21.34.56;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.24.20.05.07;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.04.04.15.24;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.14.19.23.02;	author jtc;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.20.01.37.09;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.15.16.55.14;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.13.00.51.40;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.06.08.21.07;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.15.01.01.47;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.30.21.50.57;	author jtc;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.31.03.19.06;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.12.21.16.09;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.26.15.04.30;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.11.06.34.58;	author kingdon;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.45;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.01;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.76.2.1
date	2012.01.06.04.43.15;	author brobecke;	state Exp;
branches;
next	;

1.40.2.1
date	2006.08.28.07.48.48;	author nickrob;	state Exp;
branches;
next	;

1.37.6.1
date	2006.01.26.18.05.55;	author drow;	state Exp;
branches;
next	;

1.37.10.1
date	2006.01.26.18.10.22;	author drow;	state Exp;
branches;
next	;

1.28.6.1
date	2004.09.16.17.01.07;	author drow;	state Exp;
branches;
next	;

1.27.2.1
date	2003.09.29.22.40.19;	author ezannoni;	state Exp;
branches;
next	;

1.24.2.1
date	2003.12.14.20.27.16;	author drow;	state Exp;
branches;
next	;

1.23.2.1
date	2002.09.29.15.27.10;	author cagney;	state Exp;
branches;
next	;

1.23.4.1
date	2002.10.11.22.22.54;	author carlton;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2002.11.15.19.18.44;	author carlton;	state Exp;
branches;
next	1.23.4.3;

1.23.4.3
date	2003.06.27.21.49.57;	author carlton;	state Exp;
branches;
next	1.23.4.4;

1.23.4.4
date	2003.09.17.21.28.20;	author carlton;	state Exp;
branches;
next	1.23.4.5;

1.23.4.5
date	2003.11.11.23.50.44;	author carlton;	state Exp;
branches;
next	;

1.22.6.1
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	1.22.6.2;

1.22.6.2
date	2002.10.01.00.46.09;	author kseitz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.01;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.16;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.28;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.06.07.19.17.27;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.07.17.21.23;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.07.07.20.06.26;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.10.05.23.08.16;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.12.22.21.45.06;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2000.02.01.03.19.07;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.90
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@/* Interface GDB to the GNU Hurd.
   Copyright (C) 1992-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   Written by Miles Bader <miles@@gnu.ai.mit.edu>

   Some code and ideas from m3-nat.c by Jukka Virtanen <jtv@@hut.fi>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"

#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <setjmp.h>
#include <signal.h>
#include <stdio.h>
#include "gdb_string.h"
#include <sys/ptrace.h>

#include <mach.h>
#include <mach_error.h>
#include <mach/exception.h>
#include <mach/message.h>
#include <mach/notify.h>
#include <mach/vm_attributes.h>

#include <hurd.h>
#include <hurd/interrupt.h>
#include <hurd/msg.h>
#include <hurd/msg_request.h>
#include <hurd/process.h>
/* Defined in <hurd/process.h>, but we need forward declarations from
   <hurd/process_request.h> as well.  */
#undef _process_user_
#include <hurd/process_request.h>
#include <hurd/signal.h>
#include <hurd/sigpreempt.h>

#include <portinfo.h>

#include "inferior.h"
#include "symtab.h"
#include "value.h"
#include "language.h"
#include "target.h"
#include "gdb_wait.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "gdbthread.h"
#include "gdb_assert.h"
#include "gdb_obstack.h"

#include "gnu-nat.h"
#include "inf-child.h"

#include "exc_request_S.h"
#include "notify_S.h"
#include "process_reply_S.h"
#include "msg_reply_S.h"
#include "exc_request_U.h"
#include "msg_U.h"

static process_t proc_server = MACH_PORT_NULL;

/* If we've sent a proc_wait_request to the proc server, the pid of the
   process we asked about.  We can only ever have one outstanding.  */
int proc_wait_pid = 0;

/* The number of wait requests we've sent, and expect replies from.  */
int proc_waits_pending = 0;

int gnu_debug_flag = 0;

/* Forward decls */

struct inf *make_inf ();
void inf_clear_wait (struct inf *inf);
void inf_cleanup (struct inf *inf);
void inf_startup (struct inf *inf, int pid);
int inf_update_suspends (struct inf *inf);
void inf_set_pid (struct inf *inf, pid_t pid);
void inf_validate_procs (struct inf *inf);
void inf_steal_exc_ports (struct inf *inf);
void inf_restore_exc_ports (struct inf *inf);
struct proc *inf_tid_to_proc (struct inf *inf, int tid);
void inf_set_threads_resume_sc (struct inf *inf,
				struct proc *run_thread,
				int run_others);
int inf_set_threads_resume_sc_for_signal_thread (struct inf *inf);
void inf_suspend (struct inf *inf);
void inf_resume (struct inf *inf);
void inf_set_step_thread (struct inf *inf, struct proc *proc);
void inf_detach (struct inf *inf);
void inf_attach (struct inf *inf, int pid);
void inf_signal (struct inf *inf, enum gdb_signal sig);
void inf_continue (struct inf *inf);

#define inf_debug(_inf, msg, args...) \
  do { struct inf *__inf = (_inf); \
       debug ("{inf %d %s}: " msg, __inf->pid, \
       host_address_to_string (__inf) , ##args); } while (0)

void proc_abort (struct proc *proc, int force);
struct proc *make_proc (struct inf *inf, mach_port_t port, int tid);
struct proc *_proc_free (struct proc *proc);
int proc_update_sc (struct proc *proc);
error_t proc_get_exception_port (struct proc *proc, mach_port_t * port);
error_t proc_set_exception_port (struct proc *proc, mach_port_t port);
static mach_port_t _proc_get_exc_port (struct proc *proc);
void proc_steal_exc_port (struct proc *proc, mach_port_t exc_port);
void proc_restore_exc_port (struct proc *proc);
int proc_trace (struct proc *proc, int set);

/* Evaluate RPC_EXPR in a scope with the variables MSGPORT and REFPORT bound
   to INF's msg port and task port respectively.  If it has no msg port,
   EIEIO is returned.  INF must refer to a running process!  */
#define INF_MSGPORT_RPC(inf, rpc_expr) \
  HURD_MSGPORT_RPC (proc_getmsgport (proc_server, inf->pid, &msgport), \
		    (refport = inf->task->port, 0), 0, \
		    msgport ? (rpc_expr) : EIEIO)

/* Like INF_MSGPORT_RPC, but will also resume the signal thread to ensure
   there's someone around to deal with the RPC (and resuspend things
   afterwards).  This effects INF's threads' resume_sc count.  */
#define INF_RESUME_MSGPORT_RPC(inf, rpc_expr) \
  (inf_set_threads_resume_sc_for_signal_thread (inf) \
   ? ({ error_t __e; \
	inf_resume (inf); \
	__e = INF_MSGPORT_RPC (inf, rpc_expr); \
	inf_suspend (inf); \
	__e; }) \
   : EIEIO)


/* The state passed by an exception message.  */
struct exc_state
  {
    int exception;		/* The exception code.  */
    int code, subcode;
    mach_port_t handler;	/* The real exception port to handle this.  */
    mach_port_t reply;		/* The reply port from the exception call.  */
  };

/* The results of the last wait an inf did.  */
struct inf_wait
  {
    struct target_waitstatus status;	/* The status returned to gdb.  */
    struct exc_state exc;	/* The exception that caused us to return.  */
    struct proc *thread;	/* The thread in question.  */
    int suppress;		/* Something trivial happened.  */
  };

/* The state of an inferior.  */
struct inf
  {
    /* Fields describing the current inferior.  */

    struct proc *task;		/* The mach task.   */
    struct proc *threads;	/* A linked list of all threads in TASK.  */

    /* True if THREADS needn't be validated by querying the task.  We
       assume that we and the task in question are the only ones
       frobbing the thread list, so as long as we don't let any code
       run, we don't have to worry about THREADS changing.  */
    int threads_up_to_date;

    pid_t pid;			/* The real system PID.  */

    struct inf_wait wait;	/* What to return from target_wait.  */

    /* One thread proc in INF may be in `single-stepping mode'.  This
       is it.  */
    struct proc *step_thread;

    /* The thread we think is the signal thread.  */
    struct proc *signal_thread;

    mach_port_t event_port;	/* Where we receive various msgs.  */

    /* True if we think at least one thread in the inferior could currently be
       running.  */
    unsigned int running:1;

    /* True if the process has stopped (in the proc server sense).  Note that
       since a proc server `stop' leaves the signal thread running, the inf can
       be RUNNING && STOPPED...  */
    unsigned int stopped:1;

    /* True if the inferior has no message port.  */
    unsigned int nomsg:1;

    /* True if the inferior is traced.  */
    unsigned int traced:1;

    /* True if we shouldn't try waiting for the inferior, usually because we
       can't for some reason.  */
    unsigned int no_wait:1;

    /* When starting a new inferior, we don't try to validate threads until all
       the proper execs have been done.  This is a count of how many execs we
       expect to happen.  */
    unsigned pending_execs;

    /* Fields describing global state.  */

    /* The task suspend count used when gdb has control.  This is normally 1 to
       make things easier for us, but sometimes (like when attaching to vital
       system servers) it may be desirable to let the task continue to run
       (pausing individual threads as necessary).  */
    int pause_sc;

    /* The task suspend count left when detaching from a task.  */
    int detach_sc;

    /* The initial values used for the run_sc and pause_sc of newly discovered
       threads -- see the definition of those fields in struct proc.  */
    int default_thread_run_sc;
    int default_thread_pause_sc;
    int default_thread_detach_sc;

    /* True if the process should be traced when started/attached.  Newly
       started processes *must* be traced at first to exec them properly, but
       if this is false, tracing is turned off as soon it has done so.  */
    int want_signals;

    /* True if exceptions from the inferior process should be trapped.  This
       must be on to use breakpoints.  */
    int want_exceptions;
  };


int
__proc_pid (struct proc *proc)
{
  return proc->inf->pid;
}


/* Update PROC's real suspend count to match it's desired one.  Returns true
   if we think PROC is now in a runnable state.  */
int
proc_update_sc (struct proc *proc)
{
  int running;
  int err = 0;
  int delta = proc->sc - proc->cur_sc;

  if (delta)
    proc_debug (proc, "sc: %d --> %d", proc->cur_sc, proc->sc);

  if (proc->sc == 0 && proc->state_changed)
    /* Since PROC may start running, we must write back any state changes.  */
    {
      gdb_assert (proc_is_thread (proc));
      proc_debug (proc, "storing back changed thread state");
      err = thread_set_state (proc->port, THREAD_STATE_FLAVOR,
			 (thread_state_t) &proc->state, THREAD_STATE_SIZE);
      if (!err)
	proc->state_changed = 0;
    }

  if (delta > 0)
    {
      while (delta-- > 0 && !err)
	{
	  if (proc_is_task (proc))
	    err = task_suspend (proc->port);
	  else
	    err = thread_suspend (proc->port);
	}
    }
  else
    {
      while (delta++ < 0 && !err)
	{
	  if (proc_is_task (proc))
	    err = task_resume (proc->port);
	  else
	    err = thread_resume (proc->port);
	}
    }
  if (!err)
    proc->cur_sc = proc->sc;

  /* If we got an error, then the task/thread has disappeared.  */
  running = !err && proc->sc == 0;

  proc_debug (proc, "is %s", err ? "dead" : running ? "running" : "suspended");
  if (err)
    proc_debug (proc, "err = %s", safe_strerror (err));

  if (running)
    {
      proc->aborted = 0;
      proc->state_valid = proc->state_changed = 0;
      proc->fetched_regs = 0;
    }

  return running;
}


/* Thread_abort is called on PROC if needed.  PROC must be a thread proc.
   If PROC is deemed `precious', then nothing is done unless FORCE is true.
   In particular, a thread is precious if it's running (in which case forcing
   it includes suspending it first), or if it has an exception pending.  */
void
proc_abort (struct proc *proc, int force)
{
  gdb_assert (proc_is_thread (proc));

  if (!proc->aborted)
    {
      struct inf *inf = proc->inf;
      int running = (proc->cur_sc == 0 && inf->task->cur_sc == 0);

      if (running && force)
	{
	  proc->sc = 1;
	  inf_update_suspends (proc->inf);
	  running = 0;
	  warning (_("Stopped %s."), proc_string (proc));
	}
      else if (proc == inf->wait.thread && inf->wait.exc.reply && !force)
	/* An exception is pending on PROC, which don't mess with.  */
	running = 1;

      if (!running)
	/* We only abort the thread if it's not actually running.  */
	{
	  thread_abort (proc->port);
	  proc_debug (proc, "aborted");
	  proc->aborted = 1;
	}
      else
	proc_debug (proc, "not aborting");
    }
}

/* Make sure that the state field in PROC is up to date, and return a pointer
   to it, or 0 if something is wrong.  If WILL_MODIFY is true, makes sure
   that the thread is stopped and aborted first, and sets the state_changed
   field in PROC to true.  */
thread_state_t
proc_get_state (struct proc *proc, int will_modify)
{
  int was_aborted = proc->aborted;

  proc_debug (proc, "updating state info%s",
	      will_modify ? " (with intention to modify)" : "");

  proc_abort (proc, will_modify);

  if (!was_aborted && proc->aborted)
    /* PROC's state may have changed since we last fetched it.  */
    proc->state_valid = 0;

  if (!proc->state_valid)
    {
      mach_msg_type_number_t state_size = THREAD_STATE_SIZE;
      error_t err =
	thread_get_state (proc->port, THREAD_STATE_FLAVOR,
			  (thread_state_t) &proc->state, &state_size);

      proc_debug (proc, "getting thread state");
      proc->state_valid = !err;
    }

  if (proc->state_valid)
    {
      if (will_modify)
	proc->state_changed = 1;
      return (thread_state_t) &proc->state;
    }
  else
    return 0;
}


/* Set PORT to PROC's exception port.  */
error_t
proc_get_exception_port (struct proc * proc, mach_port_t * port)
{
  if (proc_is_task (proc))
    return task_get_exception_port (proc->port, port);
  else
    return thread_get_exception_port (proc->port, port);
}

/* Set PROC's exception port to PORT.  */
error_t
proc_set_exception_port (struct proc * proc, mach_port_t port)
{
  proc_debug (proc, "setting exception port: %d", port);
  if (proc_is_task (proc))
    return task_set_exception_port (proc->port, port);
  else
    return thread_set_exception_port (proc->port, port);
}

/* Get PROC's exception port, cleaning up a bit if proc has died.  */
static mach_port_t
_proc_get_exc_port (struct proc *proc)
{
  mach_port_t exc_port;
  error_t err = proc_get_exception_port (proc, &exc_port);

  if (err)
    /* PROC must be dead.  */
    {
      if (proc->exc_port)
	mach_port_deallocate (mach_task_self (), proc->exc_port);
      proc->exc_port = MACH_PORT_NULL;
      if (proc->saved_exc_port)
	mach_port_deallocate (mach_task_self (), proc->saved_exc_port);
      proc->saved_exc_port = MACH_PORT_NULL;
    }

  return exc_port;
}

/* Replace PROC's exception port with EXC_PORT, unless it's already
   been done.  Stash away any existing exception port so we can
   restore it later.  */
void
proc_steal_exc_port (struct proc *proc, mach_port_t exc_port)
{
  mach_port_t cur_exc_port = _proc_get_exc_port (proc);

  if (cur_exc_port)
    {
      error_t err = 0;

      proc_debug (proc, "inserting exception port: %d", exc_port);

      if (cur_exc_port != exc_port)
	/* Put in our exception port.  */
	err = proc_set_exception_port (proc, exc_port);

      if (err || cur_exc_port == proc->exc_port)
	/* We previously set the exception port, and it's still set.  So we
	   just keep the old saved port which is what the proc set.  */
	{
	  if (cur_exc_port)
	    mach_port_deallocate (mach_task_self (), cur_exc_port);
	}
      else
	/* Keep a copy of PROC's old exception port so it can be restored.  */
	{
	  if (proc->saved_exc_port)
	    mach_port_deallocate (mach_task_self (), proc->saved_exc_port);
	  proc->saved_exc_port = cur_exc_port;
	}

      proc_debug (proc, "saved exception port: %d", proc->saved_exc_port);

      if (!err)
	proc->exc_port = exc_port;
      else
	warning (_("Error setting exception port for %s: %s"),
		 proc_string (proc), safe_strerror (err));
    }
}

/* If we previously replaced PROC's exception port, put back what we
   found there at the time, unless *our* exception port has since been
   overwritten, in which case who knows what's going on.  */
void
proc_restore_exc_port (struct proc *proc)
{
  mach_port_t cur_exc_port = _proc_get_exc_port (proc);

  if (cur_exc_port)
    {
      error_t err = 0;

      proc_debug (proc, "restoring real exception port");

      if (proc->exc_port == cur_exc_port)
	/* Our's is still there.  */
	err = proc_set_exception_port (proc, proc->saved_exc_port);

      if (proc->saved_exc_port)
	mach_port_deallocate (mach_task_self (), proc->saved_exc_port);
      proc->saved_exc_port = MACH_PORT_NULL;

      if (!err)
	proc->exc_port = MACH_PORT_NULL;
      else
	warning (_("Error setting exception port for %s: %s"),
		 proc_string (proc), safe_strerror (err));
    }
}


/* Turns hardware tracing in PROC on or off when SET is true or false,
   respectively.  Returns true on success.  */
int
proc_trace (struct proc *proc, int set)
{
  thread_state_t state = proc_get_state (proc, 1);

  if (!state)
    return 0;			/* The thread must be dead.  */

  proc_debug (proc, "tracing %s", set ? "on" : "off");

  if (set)
    {
      /* XXX We don't get the exception unless the thread has its own
         exception port????  */
      if (proc->exc_port == MACH_PORT_NULL)
	proc_steal_exc_port (proc, proc->inf->event_port);
      THREAD_STATE_SET_TRACED (state);
    }
  else
    THREAD_STATE_CLEAR_TRACED (state);

  return 1;
}


/* A variable from which to assign new TIDs.  */
static int next_thread_id = 1;

/* Returns a new proc structure with the given fields.  Also adds a
   notification for PORT becoming dead to be sent to INF's notify port.  */
struct proc *
make_proc (struct inf *inf, mach_port_t port, int tid)
{
  error_t err;
  mach_port_t prev_port = MACH_PORT_NULL;
  struct proc *proc = xmalloc (sizeof (struct proc));

  proc->port = port;
  proc->tid = tid;
  proc->inf = inf;
  proc->next = 0;
  proc->saved_exc_port = MACH_PORT_NULL;
  proc->exc_port = MACH_PORT_NULL;

  proc->sc = 0;
  proc->cur_sc = 0;

  /* Note that these are all the values for threads; the task simply uses the
     corresponding field in INF directly.  */
  proc->run_sc = inf->default_thread_run_sc;
  proc->pause_sc = inf->default_thread_pause_sc;
  proc->detach_sc = inf->default_thread_detach_sc;
  proc->resume_sc = proc->run_sc;

  proc->aborted = 0;
  proc->dead = 0;
  proc->state_valid = 0;
  proc->state_changed = 0;

  proc_debug (proc, "is new");

  /* Get notified when things die.  */
  err =
    mach_port_request_notification (mach_task_self (), port,
				    MACH_NOTIFY_DEAD_NAME, 1,
				    inf->event_port,
				    MACH_MSG_TYPE_MAKE_SEND_ONCE,
				    &prev_port);
  if (err)
    warning (_("Couldn't request notification for port %d: %s"),
	     port, safe_strerror (err));
  else
    {
      proc_debug (proc, "notifications to: %d", inf->event_port);
      if (prev_port != MACH_PORT_NULL)
	mach_port_deallocate (mach_task_self (), prev_port);
    }

  if (inf->want_exceptions)
    {
      if (proc_is_task (proc))
	/* Make the task exception port point to us.  */
	proc_steal_exc_port (proc, inf->event_port);
      else
	/* Just clear thread exception ports -- they default to the
           task one.  */
	proc_steal_exc_port (proc, MACH_PORT_NULL);
    }

  return proc;
}

/* Frees PROC and any resources it uses, and returns the value of PROC's 
   next field.  */
struct proc *
_proc_free (struct proc *proc)
{
  struct inf *inf = proc->inf;
  struct proc *next = proc->next;

  proc_debug (proc, "freeing...");

  if (proc == inf->step_thread)
    /* Turn off single stepping.  */
    inf_set_step_thread (inf, 0);
  if (proc == inf->wait.thread)
    inf_clear_wait (inf);
  if (proc == inf->signal_thread)
    inf->signal_thread = 0;

  if (proc->port != MACH_PORT_NULL)
    {
      if (proc->exc_port != MACH_PORT_NULL)
	/* Restore the original exception port.  */
	proc_restore_exc_port (proc);
      if (proc->cur_sc != 0)
	/* Resume the thread/task.  */
	{
	  proc->sc = 0;
	  proc_update_sc (proc);
	}
      mach_port_deallocate (mach_task_self (), proc->port);
    }

  xfree (proc);
  return next;
}


struct inf *
make_inf (void)
{
  struct inf *inf = xmalloc (sizeof (struct inf));

  inf->task = 0;
  inf->threads = 0;
  inf->threads_up_to_date = 0;
  inf->pid = 0;
  inf->wait.status.kind = TARGET_WAITKIND_SPURIOUS;
  inf->wait.thread = 0;
  inf->wait.exc.handler = MACH_PORT_NULL;
  inf->wait.exc.reply = MACH_PORT_NULL;
  inf->step_thread = 0;
  inf->signal_thread = 0;
  inf->event_port = MACH_PORT_NULL;
  inf->running = 0;
  inf->stopped = 0;
  inf->nomsg = 1;
  inf->traced = 0;
  inf->no_wait = 0;
  inf->pending_execs = 0;
  inf->pause_sc = 1;
  inf->detach_sc = 0;
  inf->default_thread_run_sc = 0;
  inf->default_thread_pause_sc = 0;
  inf->default_thread_detach_sc = 0;
  inf->want_signals = 1;	/* By default */
  inf->want_exceptions = 1;	/* By default */

  return inf;
}

/* Clear INF's target wait status.  */
void
inf_clear_wait (struct inf *inf)
{
  inf_debug (inf, "clearing wait");
  inf->wait.status.kind = TARGET_WAITKIND_SPURIOUS;
  inf->wait.thread = 0;
  inf->wait.suppress = 0;
  if (inf->wait.exc.handler != MACH_PORT_NULL)
    {
      mach_port_deallocate (mach_task_self (), inf->wait.exc.handler);
      inf->wait.exc.handler = MACH_PORT_NULL;
    }
  if (inf->wait.exc.reply != MACH_PORT_NULL)
    {
      mach_port_deallocate (mach_task_self (), inf->wait.exc.reply);
      inf->wait.exc.reply = MACH_PORT_NULL;
    }
}


void
inf_cleanup (struct inf *inf)
{
  inf_debug (inf, "cleanup");

  inf_clear_wait (inf);

  inf_set_pid (inf, -1);
  inf->pid = 0;
  inf->running = 0;
  inf->stopped = 0;
  inf->nomsg = 1;
  inf->traced = 0;
  inf->no_wait = 0;
  inf->pending_execs = 0;

  if (inf->event_port)
    {
      mach_port_destroy (mach_task_self (), inf->event_port);
      inf->event_port = MACH_PORT_NULL;
    }
}

void
inf_startup (struct inf *inf, int pid)
{
  error_t err;

  inf_debug (inf, "startup: pid = %d", pid);

  inf_cleanup (inf);

  /* Make the port on which we receive all events.  */
  err = mach_port_allocate (mach_task_self (),
			    MACH_PORT_RIGHT_RECEIVE, &inf->event_port);
  if (err)
    error (_("Error allocating event port: %s"), safe_strerror (err));

  /* Make a send right for it, so we can easily copy it for other people.  */
  mach_port_insert_right (mach_task_self (), inf->event_port,
			  inf->event_port, MACH_MSG_TYPE_MAKE_SEND);
  inf_set_pid (inf, pid);
}


/* Close current process, if any, and attach INF to process PORT.  */
void
inf_set_pid (struct inf *inf, pid_t pid)
{
  task_t task_port;
  struct proc *task = inf->task;

  inf_debug (inf, "setting pid: %d", pid);

  if (pid < 0)
    task_port = MACH_PORT_NULL;
  else
    {
      error_t err = proc_pid2task (proc_server, pid, &task_port);

      if (err)
	error (_("Error getting task for pid %d: %s"),
	       pid, safe_strerror (err));
    }

  inf_debug (inf, "setting task: %d", task_port);

  if (inf->pause_sc)
    task_suspend (task_port);

  if (task && task->port != task_port)
    {
      inf->task = 0;
      inf_validate_procs (inf);	/* Trash all the threads.  */
      _proc_free (task);	/* And the task.  */
    }

  if (task_port != MACH_PORT_NULL)
    {
      inf->task = make_proc (inf, task_port, PROC_TID_TASK);
      inf->threads_up_to_date = 0;
    }

  if (inf->task)
    {
      inf->pid = pid;
      if (inf->pause_sc)
	/* Reflect task_suspend above.  */
	inf->task->sc = inf->task->cur_sc = 1;
    }
  else
    inf->pid = -1;
}


/* Validates INF's stopped, nomsg and traced field from the actual
   proc server state.  Note that the traced field is only updated from
   the proc server state if we do not have a message port.  If we do
   have a message port we'd better look at the tracemask itself.  */
static void
inf_validate_procinfo (struct inf *inf)
{
  char *noise;
  mach_msg_type_number_t noise_len = 0;
  struct procinfo *pi;
  mach_msg_type_number_t pi_len = 0;
  int info_flags = 0;
  error_t err =
    proc_getprocinfo (proc_server, inf->pid, &info_flags,
		      (procinfo_t *) &pi, &pi_len, &noise, &noise_len);

  if (!err)
    {
      inf->stopped = !!(pi->state & PI_STOPPED);
      inf->nomsg = !!(pi->state & PI_NOMSG);
      if (inf->nomsg)
	inf->traced = !!(pi->state & PI_TRACED);
      vm_deallocate (mach_task_self (), (vm_address_t) pi, pi_len);
      if (noise_len > 0)
	vm_deallocate (mach_task_self (), (vm_address_t) noise, noise_len);
    }
}

/* Validates INF's task suspend count.  If it's higher than we expect,
   verify with the user before `stealing' the extra count.  */
static void
inf_validate_task_sc (struct inf *inf)
{
  char *noise;
  mach_msg_type_number_t noise_len = 0;
  struct procinfo *pi;
  mach_msg_type_number_t pi_len = 0;
  int info_flags = PI_FETCH_TASKINFO;
  int suspend_count = -1;
  error_t err;

 retry:
  err = proc_getprocinfo (proc_server, inf->pid, &info_flags,
			  (procinfo_t *) &pi, &pi_len, &noise, &noise_len);
  if (err)
    {
      inf->task->dead = 1; /* oh well */
      return;
    }

  if (inf->task->cur_sc < pi->taskinfo.suspend_count && suspend_count == -1)
    {
      /* The proc server might have suspended the task while stopping
         it.  This happens when the task is handling a traced signal.
         Refetch the suspend count.  The proc server should be
         finished stopping the task by now.  */
      suspend_count = pi->taskinfo.suspend_count;
      goto retry;
    }

  suspend_count = pi->taskinfo.suspend_count;

  vm_deallocate (mach_task_self (), (vm_address_t) pi, pi_len);
  if (noise_len > 0)
    vm_deallocate (mach_task_self (), (vm_address_t) pi, pi_len);

  if (inf->task->cur_sc < suspend_count)
    {
      int abort;

      target_terminal_ours ();	/* Allow I/O.  */
      abort = !query (_("Pid %d has an additional task suspend count of %d;"
		      " clear it? "), inf->pid,
		      suspend_count - inf->task->cur_sc);
      target_terminal_inferior ();	/* Give it back to the child.  */

      if (abort)
	error (_("Additional task suspend count left untouched."));

      inf->task->cur_sc = suspend_count;
    }
}

/* Turns tracing for INF on or off, depending on ON, unless it already
   is.  If INF is running, the resume_sc count of INF's threads will
   be modified, and the signal thread will briefly be run to change
   the trace state.  */
void
inf_set_traced (struct inf *inf, int on)
{
  if (on == inf->traced)
    return;
  
  if (inf->task && !inf->task->dead)
    /* Make it take effect immediately.  */
    {
      sigset_t mask = on ? ~(sigset_t) 0 : 0;
      error_t err =
	INF_RESUME_MSGPORT_RPC (inf, msg_set_init_int (msgport, refport,
						       INIT_TRACEMASK, mask));

      if (err == EIEIO)
	{
	  if (on)
	    warning (_("Can't modify tracing state for pid %d: %s"),
		     inf->pid, "No signal thread");
	  inf->traced = on;
	}
      else if (err)
	warning (_("Can't modify tracing state for pid %d: %s"),
		 inf->pid, safe_strerror (err));
      else
	inf->traced = on;
    }
  else
    inf->traced = on;
}


/* Makes all the real suspend count deltas of all the procs in INF
   match the desired values.  Careful to always do thread/task suspend
   counts in the safe order.  Returns true if at least one thread is
   thought to be running.  */
int
inf_update_suspends (struct inf *inf)
{
  struct proc *task = inf->task;

  /* We don't have to update INF->threads even though we're iterating over it
     because we'll change a thread only if it already has an existing proc
     entry.  */
  inf_debug (inf, "updating suspend counts");

  if (task)
    {
      struct proc *thread;
      int task_running = (task->sc == 0), thread_running = 0;

      if (task->sc > task->cur_sc)
	/* The task is becoming _more_ suspended; do before any threads.  */
	task_running = proc_update_sc (task);

      if (inf->pending_execs)
	/* When we're waiting for an exec, things may be happening behind our
	   back, so be conservative.  */
	thread_running = 1;

      /* Do all the thread suspend counts.  */
      for (thread = inf->threads; thread; thread = thread->next)
	thread_running |= proc_update_sc (thread);

      if (task->sc != task->cur_sc)
	/* We didn't do the task first, because we wanted to wait for the
	   threads; do it now.  */
	task_running = proc_update_sc (task);

      inf_debug (inf, "%srunning...",
		 (thread_running && task_running) ? "" : "not ");

      inf->running = thread_running && task_running;

      /* Once any thread has executed some code, we can't depend on the
         threads list any more.  */
      if (inf->running)
	inf->threads_up_to_date = 0;

      return inf->running;
    }

  return 0;
}


/* Converts a GDB pid to a struct proc.  */
struct proc *
inf_tid_to_thread (struct inf *inf, int tid)
{
  struct proc *thread = inf->threads;

  while (thread)
    if (thread->tid == tid)
      return thread;
    else
      thread = thread->next;
  return 0;
}

/* Converts a thread port to a struct proc.  */
struct proc *
inf_port_to_thread (struct inf *inf, mach_port_t port)
{
  struct proc *thread = inf->threads;

  while (thread)
    if (thread->port == port)
      return thread;
    else
      thread = thread->next;
  return 0;
}


/* Make INF's list of threads be consistent with reality of TASK.  */
void
inf_validate_procs (struct inf *inf)
{
  thread_array_t threads;
  mach_msg_type_number_t num_threads, i;
  struct proc *task = inf->task;

  /* If no threads are currently running, this function will guarantee that
     things are up to date.  The exception is if there are zero threads --
     then it is almost certainly in an odd state, and probably some outside
     agent will create threads.  */
  inf->threads_up_to_date = inf->threads ? !inf->running : 0;

  if (task)
    {
      error_t err = task_threads (task->port, &threads, &num_threads);

      inf_debug (inf, "fetching threads");
      if (err)
	/* TASK must be dead.  */
	{
	  task->dead = 1;
	  task = 0;
	}
    }

  if (!task)
    {
      num_threads = 0;
      inf_debug (inf, "no task");
    }

  {
    /* Make things normally linear.  */
    mach_msg_type_number_t search_start = 0;
    /* Which thread in PROCS corresponds to each task thread, & the task.  */
    struct proc *matched[num_threads + 1];
    /* The last thread in INF->threads, so we can add to the end.  */
    struct proc *last = 0;
    /* The current thread we're considering.  */
    struct proc *thread = inf->threads;

    memset (matched, 0, sizeof (matched));

    while (thread)
      {
	mach_msg_type_number_t left;

	for (i = search_start, left = num_threads; left; i++, left--)
	  {
	    if (i >= num_threads)
	      i -= num_threads;	/* I wrapped around.  */
	    if (thread->port == threads[i])
	      /* We already know about this thread.  */
	      {
		matched[i] = thread;
		last = thread;
		thread = thread->next;
		search_start++;
		break;
	      }
	  }

	if (!left)
	  {
	    proc_debug (thread, "died!");
	    thread->port = MACH_PORT_NULL;
	    thread = _proc_free (thread);	/* THREAD is dead.  */
	    if (last)
	      last->next = thread;
	    else
	      inf->threads = thread;
	  }
      }

    for (i = 0; i < num_threads; i++)
      {
	if (matched[i])
	  /* Throw away the duplicate send right.  */
	  mach_port_deallocate (mach_task_self (), threads[i]);
	else
	  /* THREADS[I] is a thread we don't know about yet!  */
	  {
	    ptid_t ptid;

	    thread = make_proc (inf, threads[i], next_thread_id++);
	    if (last)
	      last->next = thread;
	    else
	      inf->threads = thread;
	    last = thread;
	    proc_debug (thread, "new thread: %d", threads[i]);

	    ptid = ptid_build (inf->pid, thread->tid, 0);

	    /* Tell GDB's generic thread code.  */

	    if (ptid_equal (inferior_ptid, pid_to_ptid (inf->pid)))
	      /* This is the first time we're hearing about thread
		 ids, after a fork-child.  */
	      thread_change_ptid (inferior_ptid, ptid);
	    else if (inf->pending_execs != 0)
	      /* This is a shell thread.  */
	      add_thread_silent (ptid);
	    else
	      add_thread (ptid);
	  }
      }

    vm_deallocate (mach_task_self (),
		   (vm_address_t) threads, (num_threads * sizeof (thread_t)));
  }
}


/* Makes sure that INF's thread list is synced with the actual process.  */
int
inf_update_procs (struct inf *inf)
{
  if (!inf->task)
    return 0;
  if (!inf->threads_up_to_date)
    inf_validate_procs (inf);
  return !!inf->task;
}

/* Sets the resume_sc of each thread in inf.  That of RUN_THREAD is set to 0,
   and others are set to their run_sc if RUN_OTHERS is true, and otherwise
   their pause_sc.  */
void
inf_set_threads_resume_sc (struct inf *inf,
			   struct proc *run_thread, int run_others)
{
  struct proc *thread;

  inf_update_procs (inf);
  for (thread = inf->threads; thread; thread = thread->next)
    if (thread == run_thread)
      thread->resume_sc = 0;
    else if (run_others)
      thread->resume_sc = thread->run_sc;
    else
      thread->resume_sc = thread->pause_sc;
}


/* Cause INF to continue execution immediately; individual threads may still
   be suspended (but their suspend counts will be updated).  */
void
inf_resume (struct inf *inf)
{
  struct proc *thread;

  inf_update_procs (inf);

  for (thread = inf->threads; thread; thread = thread->next)
    thread->sc = thread->resume_sc;

  if (inf->task)
    {
      if (!inf->pending_execs)
	/* Try to make sure our task count is correct -- in the case where
	   we're waiting for an exec though, things are too volatile, so just
	   assume things will be reasonable (which they usually will be).  */
	inf_validate_task_sc (inf);
      inf->task->sc = 0;
    }

  inf_update_suspends (inf);
}

/* Cause INF to stop execution immediately; individual threads may still
   be running.  */
void
inf_suspend (struct inf *inf)
{
  struct proc *thread;

  inf_update_procs (inf);

  for (thread = inf->threads; thread; thread = thread->next)
    thread->sc = thread->pause_sc;

  if (inf->task)
    inf->task->sc = inf->pause_sc;

  inf_update_suspends (inf);
}


/* INF has one thread PROC that is in single-stepping mode.  This
   function changes it to be PROC, changing any old step_thread to be
   a normal one.  A PROC of 0 clears any existing value.  */
void
inf_set_step_thread (struct inf *inf, struct proc *thread)
{
  gdb_assert (!thread || proc_is_thread (thread));

  if (thread)
    inf_debug (inf, "setting step thread: %d/%d", inf->pid, thread->tid);
  else
    inf_debug (inf, "clearing step thread");

  if (inf->step_thread != thread)
    {
      if (inf->step_thread && inf->step_thread->port != MACH_PORT_NULL)
	if (!proc_trace (inf->step_thread, 0))
	  return;
      if (thread && proc_trace (thread, 1))
	inf->step_thread = thread;
      else
	inf->step_thread = 0;
    }
}


/* Set up the thread resume_sc's so that only the signal thread is running
   (plus whatever other thread are set to always run).  Returns true if we
   did so, or false if we can't find a signal thread.  */
int
inf_set_threads_resume_sc_for_signal_thread (struct inf *inf)
{
  if (inf->signal_thread)
    {
      inf_set_threads_resume_sc (inf, inf->signal_thread, 0);
      return 1;
    }
  else
    return 0;
}

static void
inf_update_signal_thread (struct inf *inf)
{
  /* XXX for now we assume that if there's a msgport, the 2nd thread is
     the signal thread.  */
  inf->signal_thread = inf->threads ? inf->threads->next : 0;
}


/* Detachs from INF's inferior task, letting it run once again...  */
void
inf_detach (struct inf *inf)
{
  struct proc *task = inf->task;

  inf_debug (inf, "detaching...");

  inf_clear_wait (inf);
  inf_set_step_thread (inf, 0);

  if (task)
    {
      struct proc *thread;

      inf_validate_procinfo (inf);

      inf_set_traced (inf, 0);
      if (inf->stopped)
	{
	  if (inf->nomsg)
	    inf_continue (inf);
	  else
	    inf_signal (inf, GDB_SIGNAL_0);
	}

      proc_restore_exc_port (task);
      task->sc = inf->detach_sc;

      for (thread = inf->threads; thread; thread = thread->next)
	{
	  proc_restore_exc_port (thread);
	  thread->sc = thread->detach_sc;
	}

      inf_update_suspends (inf);
    }

  inf_cleanup (inf);
}

/* Attaches INF to the process with process id PID, returning it in a
   suspended state suitable for debugging.  */
void
inf_attach (struct inf *inf, int pid)
{
  inf_debug (inf, "attaching: %d", pid);

  if (inf->pid)
    inf_detach (inf);

  inf_startup (inf, pid);
}


/* Makes sure that we've got our exception ports entrenched in the process.  */
void
inf_steal_exc_ports (struct inf *inf)
{
  struct proc *thread;

  inf_debug (inf, "stealing exception ports");

  inf_set_step_thread (inf, 0);	/* The step thread is special.  */

  proc_steal_exc_port (inf->task, inf->event_port);
  for (thread = inf->threads; thread; thread = thread->next)
    proc_steal_exc_port (thread, MACH_PORT_NULL);
}

/* Makes sure the process has its own exception ports.  */
void
inf_restore_exc_ports (struct inf *inf)
{
  struct proc *thread;

  inf_debug (inf, "restoring exception ports");

  inf_set_step_thread (inf, 0);	/* The step thread is special.  */

  proc_restore_exc_port (inf->task);
  for (thread = inf->threads; thread; thread = thread->next)
    proc_restore_exc_port (thread);
}


/* Deliver signal SIG to INF.  If INF is stopped, delivering a signal, even
   signal 0, will continue it.  INF is assumed to be in a paused state, and
   the resume_sc's of INF's threads may be affected.  */
void
inf_signal (struct inf *inf, enum gdb_signal sig)
{
  error_t err = 0;
  int host_sig = gdb_signal_to_host (sig);

#define NAME gdb_signal_to_name (sig)

  if (host_sig >= _NSIG)
    /* A mach exception.  Exceptions are encoded in the signal space by
       putting them after _NSIG; this assumes they're positive (and not
       extremely large)!  */
    {
      struct inf_wait *w = &inf->wait;

      if (w->status.kind == TARGET_WAITKIND_STOPPED
	  && w->status.value.sig == sig
	  && w->thread && !w->thread->aborted)
	/* We're passing through the last exception we received.  This is
	   kind of bogus, because exceptions are per-thread whereas gdb
	   treats signals as per-process.  We just forward the exception to
	   the correct handler, even it's not for the same thread as TID --
	   i.e., we pretend it's global.  */
	{
	  struct exc_state *e = &w->exc;

	  inf_debug (inf, "passing through exception:"
		     " task = %d, thread = %d, exc = %d"
		     ", code = %d, subcode = %d",
		     w->thread->port, inf->task->port,
		     e->exception, e->code, e->subcode);
	  err =
	    exception_raise_request (e->handler,
				     e->reply, MACH_MSG_TYPE_MOVE_SEND_ONCE,
				     w->thread->port, inf->task->port,
				     e->exception, e->code, e->subcode);
	}
      else
	error (_("Can't forward spontaneous exception (%s)."), NAME);
    }
  else
    /* A Unix signal.  */
  if (inf->stopped)
    /* The process is stopped and expecting a signal.  Just send off a
       request and let it get handled when we resume everything.  */
    {
      inf_debug (inf, "sending %s to stopped process", NAME);
      err =
	INF_MSGPORT_RPC (inf,
			 msg_sig_post_untraced_request (msgport,
							inf->event_port,
					       MACH_MSG_TYPE_MAKE_SEND_ONCE,
							host_sig, 0,
							refport));
      if (!err)
	/* Posting an untraced signal automatically continues it.
	   We clear this here rather than when we get the reply
	   because we'd rather assume it's not stopped when it
	   actually is, than the reverse.  */
	inf->stopped = 0;
    }
  else
    /* It's not expecting it.  We have to let just the signal thread
       run, and wait for it to get into a reasonable state before we
       can continue the rest of the process.  When we finally resume the
       process the signal we request will be the very first thing that
       happens.  */
    {
      inf_debug (inf, "sending %s to unstopped process"
		 " (so resuming signal thread)", NAME);
      err =
	INF_RESUME_MSGPORT_RPC (inf,
				msg_sig_post_untraced (msgport, host_sig,
						       0, refport));
    }

  if (err == EIEIO)
    /* Can't do too much...  */
    warning (_("Can't deliver signal %s: No signal thread."), NAME);
  else if (err)
    warning (_("Delivering signal %s: %s"), NAME, safe_strerror (err));

#undef NAME
}


/* Continue INF without delivering a signal.  This is meant to be used
   when INF does not have a message port.  */
void
inf_continue (struct inf *inf)
{
  process_t proc;
  error_t err = proc_pid2proc (proc_server, inf->pid, &proc);

  if (!err)
    {
      inf_debug (inf, "continuing process");

      err = proc_mark_cont (proc);
      if (!err)
	{
	  struct proc *thread;

	  for (thread = inf->threads; thread; thread = thread->next)
	    thread_resume (thread->port);

	  inf->stopped = 0;
	}
    }

  if (err)
    warning (_("Can't continue process: %s"), safe_strerror (err));
}


/* The inferior used for all gdb target ops.  */
struct inf *gnu_current_inf = 0;

/* The inferior being waited for by gnu_wait.  Since GDB is decidely not
   multi-threaded, we don't bother to lock this.  */
struct inf *waiting_inf;

/* Wait for something to happen in the inferior, returning what in STATUS.  */
static ptid_t
gnu_wait (struct target_ops *ops,
	  ptid_t ptid, struct target_waitstatus *status, int options)
{
  struct msg
    {
      mach_msg_header_t hdr;
      mach_msg_type_t type;
      int data[8000];
    } msg;
  error_t err;
  struct proc *thread;
  struct inf *inf = gnu_current_inf;

  extern int exc_server (mach_msg_header_t *, mach_msg_header_t *);
  extern int msg_reply_server (mach_msg_header_t *, mach_msg_header_t *);
  extern int notify_server (mach_msg_header_t *, mach_msg_header_t *);
  extern int process_reply_server (mach_msg_header_t *, mach_msg_header_t *);

  gdb_assert (inf->task);

  if (!inf->threads && !inf->pending_execs)
    /* No threads!  Assume that maybe some outside agency is frobbing our
       task, and really look for new threads.  If we can't find any, just tell
       the user to try again later.  */
    {
      inf_validate_procs (inf);
      if (!inf->threads && !inf->task->dead)
	error (_("There are no threads; try again later."));
    }

  waiting_inf = inf;

  inf_debug (inf, "waiting for: %s", target_pid_to_str (ptid));

rewait:
  if (proc_wait_pid != inf->pid && !inf->no_wait)
    /* Always get information on events from the proc server.  */
    {
      inf_debug (inf, "requesting wait on pid %d", inf->pid);

      if (proc_wait_pid)
	/* The proc server is single-threaded, and only allows a single
	   outstanding wait request, so we have to cancel the previous one.  */
	{
	  inf_debug (inf, "cancelling previous wait on pid %d", proc_wait_pid);
	  interrupt_operation (proc_server, 0);
	}

      err =
	proc_wait_request (proc_server, inf->event_port, inf->pid, WUNTRACED);
      if (err)
	warning (_("wait request failed: %s"), safe_strerror (err));
      else
	{
	  inf_debug (inf, "waits pending: %d", proc_waits_pending);
	  proc_wait_pid = inf->pid;
	  /* Even if proc_waits_pending was > 0 before, we still won't
	     get any other replies, because it was either from a
	     different INF, or a different process attached to INF --
	     and the event port, which is the wait reply port, changes
	     when you switch processes.  */
	  proc_waits_pending = 1;
	}
    }

  inf_clear_wait (inf);

  /* What can happen? (1) Dead name notification; (2) Exceptions arrive;
     (3) wait reply from the proc server.  */

  inf_debug (inf, "waiting for an event...");
  err = mach_msg (&msg.hdr, MACH_RCV_MSG | MACH_RCV_INTERRUPT,
		  0, sizeof (struct msg), inf->event_port,
		  MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

  /* Re-suspend the task.  */
  inf_suspend (inf);

  if (!inf->task && inf->pending_execs)
    /* When doing an exec, it's possible that the old task wasn't reused
       (e.g., setuid execs).  So if the task seems to have disappeared,
       attempt to refetch it, as the pid should still be the same.  */
    inf_set_pid (inf, inf->pid);

  if (err == EMACH_RCV_INTERRUPTED)
    inf_debug (inf, "interrupted");
  else if (err)
    error (_("Couldn't wait for an event: %s"), safe_strerror (err));
  else
    {
      struct
	{
	  mach_msg_header_t hdr;
	  mach_msg_type_t err_type;
	  kern_return_t err;
	  char noise[200];
	}
      reply;

      inf_debug (inf, "event: msgid = %d", msg.hdr.msgh_id);

      /* Handle what we got.  */
      if (!notify_server (&msg.hdr, &reply.hdr)
	  && !exc_server (&msg.hdr, &reply.hdr)
	  && !process_reply_server (&msg.hdr, &reply.hdr)
	  && !msg_reply_server (&msg.hdr, &reply.hdr))
	/* Whatever it is, it's something strange.  */
	error (_("Got a strange event, msg id = %d."), msg.hdr.msgh_id);

      if (reply.err)
	error (_("Handling event, msgid = %d: %s"),
	       msg.hdr.msgh_id, safe_strerror (reply.err));
    }

  if (inf->pending_execs)
    /* We're waiting for the inferior to finish execing.  */
    {
      struct inf_wait *w = &inf->wait;
      enum target_waitkind kind = w->status.kind;

      if (kind == TARGET_WAITKIND_SPURIOUS)
	/* Since gdb is actually counting the number of times the inferior
	   stops, expecting one stop per exec, we only return major events
	   while execing.  */
	{
	  w->suppress = 1;
	  inf_debug (inf, "pending_execs = %d, ignoring minor event",
		     inf->pending_execs);
	}
      else if (kind == TARGET_WAITKIND_STOPPED
	       && w->status.value.sig == GDB_SIGNAL_TRAP)
	/* Ah hah!  A SIGTRAP from the inferior while starting up probably
	   means we've succesfully completed an exec!  */
	{
	  if (--inf->pending_execs == 0)
	    /* We're done!  */
	    {
#if 0				/* do we need this?  */
	      prune_threads (1);	/* Get rid of the old shell
					   threads.  */
	      renumber_threads (0);	/* Give our threads reasonable
					   names.  */
#endif
	    }
	  inf_debug (inf, "pending exec completed, pending_execs => %d",
		     inf->pending_execs);
	}
      else if (kind == TARGET_WAITKIND_STOPPED)
	/* It's possible that this signal is because of a crashed process
	   being handled by the hurd crash server; in this case, the process
	   will have an extra task suspend, which we need to know about.
	   Since the code in inf_resume that normally checks for this is
	   disabled while INF->pending_execs, we do the check here instead.  */
	inf_validate_task_sc (inf);
    }

  if (inf->wait.suppress)
    /* Some totally spurious event happened that we don't consider
       worth returning to gdb.  Just keep waiting.  */
    {
      inf_debug (inf, "suppressing return, rewaiting...");
      inf_resume (inf);
      goto rewait;
    }

  /* Pass back out our results.  */
  memcpy (status, &inf->wait.status, sizeof (*status));

  thread = inf->wait.thread;
  if (thread)
    ptid = ptid_build (inf->pid, thread->tid, 0);
  else if (ptid_equal (ptid, minus_one_ptid))
    thread = inf_tid_to_thread (inf, -1);
  else
    thread = inf_tid_to_thread (inf, ptid_get_lwp (ptid));

  if (!thread || thread->port == MACH_PORT_NULL)
    {
      /* TID is dead; try and find a new thread.  */
      if (inf_update_procs (inf) && inf->threads)
	ptid = ptid_build (inf->pid, inf->threads->tid, 0); /* The first
							       available
							       thread.  */
      else
	ptid = inferior_ptid;	/* let wait_for_inferior handle exit case */
    }

  if (thread
      && !ptid_equal (ptid, minus_one_ptid)
      && status->kind != TARGET_WAITKIND_SPURIOUS
      && inf->pause_sc == 0 && thread->pause_sc == 0)
    /* If something actually happened to THREAD, make sure we
       suspend it.  */
    {
      thread->sc = 1;
      inf_update_suspends (inf);
    }

  inf_debug (inf, "returning ptid = %s, status = %s (%d)",
	     target_pid_to_str (ptid),
	     status->kind == TARGET_WAITKIND_EXITED ? "EXITED"
	     : status->kind == TARGET_WAITKIND_STOPPED ? "STOPPED"
	     : status->kind == TARGET_WAITKIND_SIGNALLED ? "SIGNALLED"
	     : status->kind == TARGET_WAITKIND_LOADED ? "LOADED"
	     : status->kind == TARGET_WAITKIND_SPURIOUS ? "SPURIOUS"
	     : "?",
	     status->value.integer);

  return ptid;
}


/* The rpc handler called by exc_server.  */
error_t
S_exception_raise_request (mach_port_t port, mach_port_t reply_port,
			   thread_t thread_port, task_t task_port,
			   int exception, int code, int subcode)
{
  struct inf *inf = waiting_inf;
  struct proc *thread = inf_port_to_thread (inf, thread_port);

  inf_debug (waiting_inf,
	     "thread = %d, task = %d, exc = %d, code = %d, subcode = %d",
	     thread_port, task_port, exception, code, subcode);

  if (!thread)
    /* We don't know about thread?  */
    {
      inf_update_procs (inf);
      thread = inf_port_to_thread (inf, thread_port);
      if (!thread)
	/* Give up, the generating thread is gone.  */
	return 0;
    }

  mach_port_deallocate (mach_task_self (), thread_port);
  mach_port_deallocate (mach_task_self (), task_port);

  if (!thread->aborted)
    /* THREAD hasn't been aborted since this exception happened (abortion
       clears any exception state), so it must be real.  */
    {
      /* Store away the details; this will destroy any previous info.  */
      inf->wait.thread = thread;

      inf->wait.status.kind = TARGET_WAITKIND_STOPPED;

      if (exception == EXC_BREAKPOINT)
	/* GDB likes to get SIGTRAP for breakpoints.  */
	{
	  inf->wait.status.value.sig = GDB_SIGNAL_TRAP;
	  mach_port_deallocate (mach_task_self (), reply_port);
	}
      else
	/* Record the exception so that we can forward it later.  */
	{
	  if (thread->exc_port == port)
	    {
	      inf_debug (waiting_inf, "Handler is thread exception port <%d>",
			 thread->saved_exc_port);
	      inf->wait.exc.handler = thread->saved_exc_port;
	    }
	  else
	    {
	      inf_debug (waiting_inf, "Handler is task exception port <%d>",
			 inf->task->saved_exc_port);
	      inf->wait.exc.handler = inf->task->saved_exc_port;
	      gdb_assert (inf->task->exc_port == port);
	    }
	  if (inf->wait.exc.handler != MACH_PORT_NULL)
	    /* Add a reference to the exception handler.  */
	    mach_port_mod_refs (mach_task_self (),
				inf->wait.exc.handler, MACH_PORT_RIGHT_SEND,
				1);

	  inf->wait.exc.exception = exception;
	  inf->wait.exc.code = code;
	  inf->wait.exc.subcode = subcode;
	  inf->wait.exc.reply = reply_port;

	  /* Exceptions are encoded in the signal space by putting
	     them after _NSIG; this assumes they're positive (and not
	     extremely large)!  */
	  inf->wait.status.value.sig =
	    gdb_signal_from_host (_NSIG + exception);
	}
    }
  else
    /* A supppressed exception, which ignore.  */
    {
      inf->wait.suppress = 1;
      mach_port_deallocate (mach_task_self (), reply_port);
    }

  return 0;
}


/* Fill in INF's wait field after a task has died without giving us more
   detailed information.  */
void
inf_task_died_status (struct inf *inf)
{
  warning (_("Pid %d died with unknown exit status, using SIGKILL."),
	   inf->pid);
  inf->wait.status.kind = TARGET_WAITKIND_SIGNALLED;
  inf->wait.status.value.sig = GDB_SIGNAL_KILL;
}

/* Notify server routines.  The only real one is dead name notification.  */
error_t
do_mach_notify_dead_name (mach_port_t notify, mach_port_t dead_port)
{
  struct inf *inf = waiting_inf;

  inf_debug (waiting_inf, "port = %d", dead_port);

  if (inf->task && inf->task->port == dead_port)
    {
      proc_debug (inf->task, "is dead");
      inf->task->port = MACH_PORT_NULL;
      if (proc_wait_pid == inf->pid)
	/* We have a wait outstanding on the process, which will return more
	   detailed information, so delay until we get that.  */
	inf->wait.suppress = 1;
      else
	/* We never waited for the process (maybe it wasn't a child), so just
	   pretend it got a SIGKILL.  */
	inf_task_died_status (inf);
    }
  else
    {
      struct proc *thread = inf_port_to_thread (inf, dead_port);

      if (thread)
	{
	  proc_debug (thread, "is dead");
	  thread->port = MACH_PORT_NULL;
	}

      if (inf->task->dead)
	/* Since the task is dead, its threads are dying with it.  */
	inf->wait.suppress = 1;
    }

  mach_port_deallocate (mach_task_self (), dead_port);
  inf->threads_up_to_date = 0;	/* Just in case.  */

  return 0;
}


static error_t
ill_rpc (char *fun)
{
  warning (_("illegal rpc: %s"), fun);
  return 0;
}

error_t
do_mach_notify_no_senders (mach_port_t notify, mach_port_mscount_t count)
{
  return ill_rpc ("do_mach_notify_no_senders");
}

error_t
do_mach_notify_port_deleted (mach_port_t notify, mach_port_t name)
{
  return ill_rpc ("do_mach_notify_port_deleted");
}

error_t
do_mach_notify_msg_accepted (mach_port_t notify, mach_port_t name)
{
  return ill_rpc ("do_mach_notify_msg_accepted");
}

error_t
do_mach_notify_port_destroyed (mach_port_t notify, mach_port_t name)
{
  return ill_rpc ("do_mach_notify_port_destroyed");
}

error_t
do_mach_notify_send_once (mach_port_t notify)
{
  return ill_rpc ("do_mach_notify_send_once");
}


/* Process_reply server routines.  We only use process_wait_reply.  */

error_t
S_proc_wait_reply (mach_port_t reply, error_t err,
		   int status, int sigcode, rusage_t rusage, pid_t pid)
{
  struct inf *inf = waiting_inf;

  inf_debug (inf, "err = %s, pid = %d, status = 0x%x, sigcode = %d",
	     err ? safe_strerror (err) : "0", pid, status, sigcode);

  if (err && proc_wait_pid && (!inf->task || !inf->task->port))
    /* Ack.  The task has died, but the task-died notification code didn't
       tell anyone because it thought a more detailed reply from the
       procserver was forthcoming.  However, we now learn that won't
       happen...  So we have to act like the task just died, and this time,
       tell the world.  */
    inf_task_died_status (inf);

  if (--proc_waits_pending == 0)
    /* PROC_WAIT_PID represents the most recent wait.  We will always get
       replies in order because the proc server is single threaded.  */
    proc_wait_pid = 0;

  inf_debug (inf, "waits pending now: %d", proc_waits_pending);

  if (err)
    {
      if (err != EINTR)
	{
	  warning (_("Can't wait for pid %d: %s"),
		   inf->pid, safe_strerror (err));
	  inf->no_wait = 1;

	  /* Since we can't see the inferior's signals, don't trap them.  */
	  inf_set_traced (inf, 0);
	}
    }
  else if (pid == inf->pid)
    {
      store_waitstatus (&inf->wait.status, status);
      if (inf->wait.status.kind == TARGET_WAITKIND_STOPPED)
	/* The process has sent us a signal, and stopped itself in a sane
	   state pending our actions.  */
	{
	  inf_debug (inf, "process has stopped itself");
	  inf->stopped = 1;
	}
    }
  else
    inf->wait.suppress = 1;	/* Something odd happened.  Ignore.  */

  return 0;
}

error_t
S_proc_setmsgport_reply (mach_port_t reply, error_t err,
			 mach_port_t old_msg_port)
{
  return ill_rpc ("S_proc_setmsgport_reply");
}

error_t
S_proc_getmsgport_reply (mach_port_t reply, error_t err, mach_port_t msg_port)
{
  return ill_rpc ("S_proc_getmsgport_reply");
}


/* Msg_reply server routines.  We only use msg_sig_post_untraced_reply.  */

error_t
S_msg_sig_post_untraced_reply (mach_port_t reply, error_t err)
{
  struct inf *inf = waiting_inf;

  if (err == EBUSY)
    /* EBUSY is what we get when the crash server has grabbed control of the
       process and doesn't like what signal we tried to send it.  Just act
       like the process stopped (using a signal of 0 should mean that the
       *next* time the user continues, it will pass signal 0, which the crash
       server should like).  */
    {
      inf->wait.status.kind = TARGET_WAITKIND_STOPPED;
      inf->wait.status.value.sig = GDB_SIGNAL_0;
    }
  else if (err)
    warning (_("Signal delivery failed: %s"), safe_strerror (err));

  if (err)
    /* We only get this reply when we've posted a signal to a process which we
       thought was stopped, and which we expected to continue after the signal.
       Given that the signal has failed for some reason, it's reasonable to
       assume it's still stopped.  */
    inf->stopped = 1;
  else
    inf->wait.suppress = 1;

  return 0;
}

error_t
S_msg_sig_post_reply (mach_port_t reply, error_t err)
{
  return ill_rpc ("S_msg_sig_post_reply");
}


/* Returns the number of messages queued for the receive right PORT.  */
static mach_port_msgcount_t
port_msgs_queued (mach_port_t port)
{
  struct mach_port_status status;
  error_t err =
    mach_port_get_receive_status (mach_task_self (), port, &status);

  if (err)
    return 0;
  else
    return status.mps_msgcount;
}


/* Resume execution of the inferior process.

   If STEP is nonzero, single-step it.
   If SIGNAL is nonzero, give it that signal.

   TID  STEP:
   -1   true   Single step the current thread allowing other threads to run.
   -1   false  Continue the current thread allowing other threads to run.
   X    true   Single step the given thread, don't allow any others to run.
   X    false  Continue the given thread, do not allow any others to run.
   (Where X, of course, is anything except -1)

   Note that a resume may not `take' if there are pending exceptions/&c
   still unprocessed from the last resume we did (any given resume may result
   in multiple events returned by wait).  */

static void
gnu_resume (struct target_ops *ops,
	    ptid_t ptid, int step, enum gdb_signal sig)
{
  struct proc *step_thread = 0;
  int resume_all;
  struct inf *inf = gnu_current_inf;

  inf_debug (inf, "ptid = %s, step = %d, sig = %d",
	     target_pid_to_str (ptid), step, sig);

  inf_validate_procinfo (inf);

  if (sig != GDB_SIGNAL_0 || inf->stopped)
    {
      if (sig == GDB_SIGNAL_0 && inf->nomsg)
	inf_continue (inf);
      else
	inf_signal (inf, sig);
    }
  else if (inf->wait.exc.reply != MACH_PORT_NULL)
    /* We received an exception to which we have chosen not to forward, so
       abort the faulting thread, which will perhaps retake it.  */
    {
      proc_abort (inf->wait.thread, 1);
      warning (_("Aborting %s with unforwarded exception %s."),
	       proc_string (inf->wait.thread),
	       gdb_signal_to_name (inf->wait.status.value.sig));
    }

  if (port_msgs_queued (inf->event_port))
    /* If there are still messages in our event queue, don't bother resuming
       the process, as we're just going to stop it right away anyway.  */
    return;

  inf_update_procs (inf);

  /* A specific PTID means `step only this process id'.  */
  resume_all = ptid_equal (ptid, minus_one_ptid);

  if (resume_all)
    /* Allow all threads to run, except perhaps single-stepping one.  */
    {
      inf_debug (inf, "running all threads; tid = %d",
		 ptid_get_pid (inferior_ptid));
      ptid = inferior_ptid;	/* What to step.  */
      inf_set_threads_resume_sc (inf, 0, 1);
    }
  else
    /* Just allow a single thread to run.  */
    {
      struct proc *thread = inf_tid_to_thread (inf, ptid_get_lwp (ptid));

      if (!thread)
	error (_("Can't run single thread id %s: no such thread!"),
	       target_pid_to_str (ptid));
      inf_debug (inf, "running one thread: %s", target_pid_to_str (ptid));
      inf_set_threads_resume_sc (inf, thread, 0);
    }

  if (step)
    {
      step_thread = inf_tid_to_thread (inf, ptid_get_lwp (ptid));
      if (!step_thread)
	warning (_("Can't step thread id %s: no such thread."),
		 target_pid_to_str (ptid));
      else
	inf_debug (inf, "stepping thread: %s", target_pid_to_str (ptid));
    }
  if (step_thread != inf->step_thread)
    inf_set_step_thread (inf, step_thread);

  inf_debug (inf, "here we go...");
  inf_resume (inf);
}


static void
gnu_kill_inferior (struct target_ops *ops)
{
  struct proc *task = gnu_current_inf->task;

  if (task)
    {
      proc_debug (task, "terminating...");
      task_terminate (task->port);
      inf_set_pid (gnu_current_inf, -1);
    }
  target_mourn_inferior ();
}

/* Clean up after the inferior dies.  */
static void
gnu_mourn_inferior (struct target_ops *ops)
{
  inf_debug (gnu_current_inf, "rip");
  inf_detach (gnu_current_inf);
  unpush_target (ops);
  generic_mourn_inferior ();
}


/* Fork an inferior process, and start debugging it.  */

/* Set INFERIOR_PID to the first thread available in the child, if any.  */
static int
inf_pick_first_thread (void)
{
  if (gnu_current_inf->task && gnu_current_inf->threads)
    /* The first thread.  */
    return gnu_current_inf->threads->tid;
  else
    /* What may be the next thread.  */
    return next_thread_id;
}

static struct inf *
cur_inf (void)
{
  if (!gnu_current_inf)
    gnu_current_inf = make_inf ();
  return gnu_current_inf;
}

static void
gnu_create_inferior (struct target_ops *ops, 
		     char *exec_file, char *allargs, char **env,
		     int from_tty)
{
  struct inf *inf = cur_inf ();
  int pid;

  void trace_me ()
  {
    /* We're in the child; make this process stop as soon as it execs.  */
    inf_debug (inf, "tracing self");
    if (ptrace (PTRACE_TRACEME) != 0)
      error (_("ptrace (PTRACE_TRACEME) failed!"));
  }

  inf_debug (inf, "creating inferior");

  pid = fork_inferior (exec_file, allargs, env, trace_me,
                       NULL, NULL, NULL, NULL);

  /* Attach to the now stopped child, which is actually a shell...  */
  inf_debug (inf, "attaching to child: %d", pid);

  inf_attach (inf, pid);

  push_target (ops);

  inf->pending_execs = 2;
  inf->nomsg = 1;
  inf->traced = 1;

  /* Now let the child run again, knowing that it will stop
     immediately because of the ptrace.  */
  inf_resume (inf);

  /* We now have thread info.  */
  thread_change_ptid (inferior_ptid,
		      ptid_build (inf->pid, inf_pick_first_thread (), 0));

  startup_inferior (inf->pending_execs);

  inf_validate_procinfo (inf);
  inf_update_signal_thread (inf);
  inf_set_traced (inf, inf->want_signals);

  /* Execing the process will have trashed our exception ports; steal them
     back (or make sure they're restored if the user wants that).  */
  if (inf->want_exceptions)
    inf_steal_exc_ports (inf);
  else
    inf_restore_exc_ports (inf);
}


/* Attach to process PID, then initialize for debugging it
   and wait for the trace-trap that results from attaching.  */
static void
gnu_attach (struct target_ops *ops, char *args, int from_tty)
{
  int pid;
  char *exec_file;
  struct inf *inf = cur_inf ();
  struct inferior *inferior;

  pid = parse_pid_to_attach (args);

  if (pid == getpid ())		/* Trying to masturbate?  */
    error (_("I refuse to debug myself!"));

  if (from_tty)
    {
      exec_file = (char *) get_exec_file (0);

      if (exec_file)
	printf_unfiltered ("Attaching to program `%s', pid %d\n",
			   exec_file, pid);
      else
	printf_unfiltered ("Attaching to pid %d\n", pid);

      gdb_flush (gdb_stdout);
    }

  inf_debug (inf, "attaching to pid: %d", pid);

  inf_attach (inf, pid);

  push_target (ops);

  inferior = current_inferior ();
  inferior_appeared (inferior, pid);
  inferior->attach_flag = 1;

  inf_update_procs (inf);

  inferior_ptid = ptid_build (pid, inf_pick_first_thread (), 0);

  /* We have to initialize the terminal settings now, since the code
     below might try to restore them.  */
  target_terminal_init ();

  /* If the process was stopped before we attached, make it continue the next
     time the user does a continue.  */
  inf_validate_procinfo (inf);

  inf_update_signal_thread (inf);
  inf_set_traced (inf, inf->want_signals);

#if 0				/* Do we need this?  */
  renumber_threads (0);		/* Give our threads reasonable names.  */
#endif
}


/* Take a program previously attached to and detaches it.
   The program resumes execution and will no longer stop
   on signals, etc.  We'd better not have left any breakpoints
   in the program or it'll die when it hits one.  For this
   to work, it may be necessary for the process to have been
   previously attached.  It *might* work if the program was
   started via fork.  */
static void
gnu_detach (struct target_ops *ops, char *args, int from_tty)
{
  int pid;

  if (from_tty)
    {
      char *exec_file = get_exec_file (0);

      if (exec_file)
	printf_unfiltered ("Detaching from program `%s' pid %d\n",
			   exec_file, gnu_current_inf->pid);
      else
	printf_unfiltered ("Detaching from pid %d\n", gnu_current_inf->pid);
      gdb_flush (gdb_stdout);
    }

  pid = gnu_current_inf->pid;

  inf_detach (gnu_current_inf);

  inferior_ptid = null_ptid;
  detach_inferior (pid);

  unpush_target (ops);	/* Pop out of handling an inferior.  */
}

static void
gnu_terminal_init_inferior (void)
{
  gdb_assert (gnu_current_inf);
  terminal_init_inferior_with_pgrp (gnu_current_inf->pid);
}

static void
gnu_stop (ptid_t ptid)
{
  error (_("to_stop target function not implemented"));
}

static int
gnu_thread_alive (struct target_ops *ops, ptid_t ptid)
{
  inf_update_procs (gnu_current_inf);
  return !!inf_tid_to_thread (gnu_current_inf,
			      ptid_get_lwp (ptid));
}


/* Read inferior task's LEN bytes from ADDR and copy it to MYADDR in
   gdb's address space.  Return 0 on failure; number of bytes read
   otherwise.  */
static int
gnu_read_inferior (task_t task, CORE_ADDR addr, gdb_byte *myaddr, int length)
{
  error_t err;
  vm_address_t low_address = (vm_address_t) trunc_page (addr);
  vm_size_t aligned_length =
  (vm_size_t) round_page (addr + length) - low_address;
  pointer_t copied;
  int copy_count;

  /* Get memory from inferior with page aligned addresses.  */
  err = vm_read (task, low_address, aligned_length, &copied, &copy_count);
  if (err)
    return 0;

  err = hurd_safe_copyin (myaddr, (void *) (addr - low_address + copied),
			  length);
  if (err)
    {
      warning (_("Read from inferior faulted: %s"), safe_strerror (err));
      length = 0;
    }

  err = vm_deallocate (mach_task_self (), copied, copy_count);
  if (err)
    warning (_("gnu_read_inferior vm_deallocate failed: %s"),
	     safe_strerror (err));

  return length;
}

#define CHK_GOTO_OUT(str,ret) \
  do if (ret != KERN_SUCCESS) { errstr = #str; goto out; } while(0)

struct vm_region_list
{
  struct vm_region_list *next;
  vm_prot_t protection;
  vm_address_t start;
  vm_size_t length;
};

struct obstack region_obstack;

/* Write gdb's LEN bytes from MYADDR and copy it to ADDR in inferior
   task's address space.  */
static int
gnu_write_inferior (task_t task, CORE_ADDR addr,
		    const gdb_byte *myaddr, int length)
{
  error_t err = 0;
  vm_address_t low_address = (vm_address_t) trunc_page (addr);
  vm_size_t aligned_length =
  (vm_size_t) round_page (addr + length) - low_address;
  pointer_t copied;
  int copy_count;
  int deallocate = 0;

  char *errstr = "Bug in gnu_write_inferior";

  struct vm_region_list *region_element;
  struct vm_region_list *region_head = (struct vm_region_list *) NULL;

  /* Get memory from inferior with page aligned addresses.  */
  err = vm_read (task,
		 low_address,
		 aligned_length,
		 &copied,
		 &copy_count);
  CHK_GOTO_OUT ("gnu_write_inferior vm_read failed", err);

  deallocate++;

  err = hurd_safe_copyout ((void *) (addr - low_address + copied),
			   myaddr, length);
  CHK_GOTO_OUT ("Write to inferior faulted", err);

  obstack_init (&region_obstack);

  /* Do writes atomically.
     First check for holes and unwritable memory.  */
  {
    vm_size_t remaining_length = aligned_length;
    vm_address_t region_address = low_address;

    struct vm_region_list *scan;

    while (region_address < low_address + aligned_length)
      {
	vm_prot_t protection;
	vm_prot_t max_protection;
	vm_inherit_t inheritance;
	boolean_t shared;
	mach_port_t object_name;
	vm_offset_t offset;
	vm_size_t region_length = remaining_length;
	vm_address_t old_address = region_address;

	err = vm_region (task,
			 &region_address,
			 &region_length,
			 &protection,
			 &max_protection,
			 &inheritance,
			 &shared,
			 &object_name,
			 &offset);
	CHK_GOTO_OUT ("vm_region failed", err);

	/* Check for holes in memory.  */
	if (old_address != region_address)
	  {
	    warning (_("No memory at 0x%x. Nothing written"),
		     old_address);
	    err = KERN_SUCCESS;
	    length = 0;
	    goto out;
	  }

	if (!(max_protection & VM_PROT_WRITE))
	  {
	    warning (_("Memory at address 0x%x is unwritable. "
		       "Nothing written"),
		     old_address);
	    err = KERN_SUCCESS;
	    length = 0;
	    goto out;
	  }

	/* Chain the regions for later use.  */
	region_element =
	  (struct vm_region_list *)
	  obstack_alloc (&region_obstack, sizeof (struct vm_region_list));

	region_element->protection = protection;
	region_element->start = region_address;
	region_element->length = region_length;

	/* Chain the regions along with protections.  */
	region_element->next = region_head;
	region_head = region_element;

	region_address += region_length;
	remaining_length = remaining_length - region_length;
      }

    /* If things fail after this, we give up.
       Somebody is messing up inferior_task's mappings.  */

    /* Enable writes to the chained vm regions.  */
    for (scan = region_head; scan; scan = scan->next)
      {
	if (!(scan->protection & VM_PROT_WRITE))
	  {
	    err = vm_protect (task,
			      scan->start,
			      scan->length,
			      FALSE,
			      scan->protection | VM_PROT_WRITE);
	    CHK_GOTO_OUT ("vm_protect: enable write failed", err);
	  }
      }

    err = vm_write (task,
		    low_address,
		    copied,
		    aligned_length);
    CHK_GOTO_OUT ("vm_write failed", err);

    /* Set up the original region protections, if they were changed.  */
    for (scan = region_head; scan; scan = scan->next)
      {
	if (!(scan->protection & VM_PROT_WRITE))
	  {
	    err = vm_protect (task,
			      scan->start,
			      scan->length,
			      FALSE,
			      scan->protection);
	    CHK_GOTO_OUT ("vm_protect: enable write failed", err);
	  }
      }
  }

out:
  if (deallocate)
    {
      obstack_free (&region_obstack, 0);

      (void) vm_deallocate (mach_task_self (),
			    copied,
			    copy_count);
    }

  if (err != KERN_SUCCESS)
    {
      warning (_("%s: %s"), errstr, mach_error_string (err));
      return 0;
    }

  return length;
}



/* Helper for gnu_xfer_partial that handles memory transfers.  */

static LONGEST
gnu_xfer_memory (gdb_byte *readbuf, const gdb_byte *writebuf,
		 CORE_ADDR memaddr, LONGEST len)
{
  task_t task = (gnu_current_inf
		 ? (gnu_current_inf->task
		    ? gnu_current_inf->task->port : 0)
		 : 0);
  int res;

  if (task == MACH_PORT_NULL)
    return TARGET_XFER_E_IO;

  if (writebuf != NULL)
    {
      inf_debug (gnu_current_inf, "writing %s[%s] <-- %s",
		 paddress (target_gdbarch (), memaddr), plongest (len),
		 host_address_to_string (writebuf));
      res = gnu_write_inferior (task, memaddr, writebuf, len);
    }
  else
    {
      inf_debug (gnu_current_inf, "reading %s[%s] --> %s",
		 paddress (target_gdbarch (), memaddr), plongest (len),
		 host_address_to_string (readbuf));
      res = gnu_read_inferior (task, memaddr, readbuf, len);
    }
  if (res == 0)
    return TARGET_XFER_E_IO;
  return res;
}

/* Target to_xfer_partial implementation.  */

static LONGEST
gnu_xfer_partial (struct target_ops *ops, enum target_object object,
		  const char *annex, gdb_byte *readbuf,
		  const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  switch (object)
    {
    case TARGET_OBJECT_MEMORY:
      return gnu_xfer_memory (readbuf, writebuf, offset, len);

    default:
      return -1;
    }
}

/* Call FUNC on each memory region in the task.  */
static int
gnu_find_memory_regions (find_memory_region_ftype func, void *data)
{
  error_t err;
  task_t task;
  vm_address_t region_address, last_region_address, last_region_end;
  vm_prot_t last_protection;

  if (gnu_current_inf == 0 || gnu_current_inf->task == 0)
    return 0;
  task = gnu_current_inf->task->port;
  if (task == MACH_PORT_NULL)
    return 0;

  region_address = last_region_address = last_region_end = VM_MIN_ADDRESS;
  last_protection = VM_PROT_NONE;
  while (region_address < VM_MAX_ADDRESS)
    {
      vm_prot_t protection;
      vm_prot_t max_protection;
      vm_inherit_t inheritance;
      boolean_t shared;
      mach_port_t object_name;
      vm_offset_t offset;
      vm_size_t region_length = VM_MAX_ADDRESS - region_address;
      vm_address_t old_address = region_address;

      err = vm_region (task,
		       &region_address,
		       &region_length,
		       &protection,
		       &max_protection,
		       &inheritance,
		       &shared,
		       &object_name,
		       &offset);
      if (err == KERN_NO_SPACE)
	break;
      if (err != KERN_SUCCESS)
	{
	  warning (_("vm_region failed: %s"), mach_error_string (err));
	  return -1;
	}

      if (protection == last_protection && region_address == last_region_end)
	/* This region is contiguous with and indistinguishable from
	   the previous one, so we just extend that one.  */
	last_region_end = region_address += region_length;
      else
	{
	  /* This region is distinct from the last one we saw, so report
	     that previous one.  */
	  if (last_protection != VM_PROT_NONE)
	    (*func) (last_region_address,
		     last_region_end - last_region_address,
		     last_protection & VM_PROT_READ,
		     last_protection & VM_PROT_WRITE,
		     last_protection & VM_PROT_EXECUTE,
		     1, /* MODIFIED is unknown, pass it as true.  */
		     data);
	  last_region_address = region_address;
	  last_region_end = region_address += region_length;
	  last_protection = protection;
	}
    }

  /* Report the final region.  */
  if (last_region_end > last_region_address && last_protection != VM_PROT_NONE)
    (*func) (last_region_address, last_region_end - last_region_address,
	     last_protection & VM_PROT_READ,
	     last_protection & VM_PROT_WRITE,
	     last_protection & VM_PROT_EXECUTE,
	     1, /* MODIFIED is unknown, pass it as true.  */
	     data);

  return 0;
}


/* Return printable description of proc.  */
char *
proc_string (struct proc *proc)
{
  static char tid_str[80];

  if (proc_is_task (proc))
    xsnprintf (tid_str, sizeof (tid_str), "process %d", proc->inf->pid);
  else
    xsnprintf (tid_str, sizeof (tid_str), "Thread %d.%d",
	       proc->inf->pid, proc->tid);
  return tid_str;
}

static char *
gnu_pid_to_str (struct target_ops *ops, ptid_t ptid)
{
  struct inf *inf = gnu_current_inf;
  int tid = ptid_get_lwp (ptid);
  struct proc *thread = inf_tid_to_thread (inf, tid);

  if (thread)
    return proc_string (thread);
  else
    {
      static char tid_str[80];

      xsnprintf (tid_str, sizeof (tid_str), "bogus thread id %d", tid);
      return tid_str;
    }
}


/* Create a prototype generic GNU/Hurd target.  The client can
   override it with local methods.  */

struct target_ops *
gnu_target (void)
{
  struct target_ops *t = inf_child_target ();

  t->to_shortname = "GNU";
  t->to_longname = "GNU Hurd process";
  t->to_doc = "GNU Hurd process";

  t->to_attach = gnu_attach;
  t->to_attach_no_wait = 1;
  t->to_detach = gnu_detach;
  t->to_resume = gnu_resume;
  t->to_wait = gnu_wait;
  t->to_xfer_partial = gnu_xfer_partial;
  t->to_find_memory_regions = gnu_find_memory_regions;
  t->to_terminal_init = gnu_terminal_init_inferior;
  t->to_kill = gnu_kill_inferior;
  t->to_create_inferior = gnu_create_inferior;
  t->to_mourn_inferior = gnu_mourn_inferior;
  t->to_thread_alive = gnu_thread_alive;
  t->to_pid_to_str = gnu_pid_to_str;
  t->to_stop = gnu_stop;

  return t;
}


/* User task commands.  */

static struct cmd_list_element *set_task_cmd_list = 0;
static struct cmd_list_element *show_task_cmd_list = 0;
/* User thread commands.  */

/* Commands with a prefix of `set/show thread'.  */
extern struct cmd_list_element *thread_cmd_list;
struct cmd_list_element *set_thread_cmd_list = NULL;
struct cmd_list_element *show_thread_cmd_list = NULL;

/* Commands with a prefix of `set/show thread default'.  */
struct cmd_list_element *set_thread_default_cmd_list = NULL;
struct cmd_list_element *show_thread_default_cmd_list = NULL;

static void
set_thread_cmd (char *args, int from_tty)
{
  printf_unfiltered ("\"set thread\" must be followed by the "
		     "name of a thread property, or \"default\".\n");
}

static void
show_thread_cmd (char *args, int from_tty)
{
  printf_unfiltered ("\"show thread\" must be followed by the "
		     "name of a thread property, or \"default\".\n");
}

static void
set_thread_default_cmd (char *args, int from_tty)
{
  printf_unfiltered ("\"set thread default\" must be followed "
		     "by the name of a thread property.\n");
}

static void
show_thread_default_cmd (char *args, int from_tty)
{
  printf_unfiltered ("\"show thread default\" must be followed "
		     "by the name of a thread property.\n");
}

static int
parse_int_arg (char *args, char *cmd_prefix)
{
  if (args)
    {
      char *arg_end;
      int val = strtoul (args, &arg_end, 10);

      if (*args && *arg_end == '\0')
	return val;
    }
  error (_("Illegal argument for \"%s\" command, should be an integer."),
	 cmd_prefix);
}

static int
_parse_bool_arg (char *args, char *t_val, char *f_val, char *cmd_prefix)
{
  if (!args || strcmp (args, t_val) == 0)
    return 1;
  else if (strcmp (args, f_val) == 0)
    return 0;
  else
    error (_("Illegal argument for \"%s\" command, "
	     "should be \"%s\" or \"%s\"."),
	   cmd_prefix, t_val, f_val);
}

#define parse_bool_arg(args, cmd_prefix) \
  _parse_bool_arg (args, "on", "off", cmd_prefix)

static void
check_empty (char *args, char *cmd_prefix)
{
  if (args)
    error (_("Garbage after \"%s\" command: `%s'"), cmd_prefix, args);
}

/* Returns the alive thread named by INFERIOR_PID, or signals an error.  */
static struct proc *
cur_thread (void)
{
  struct inf *inf = cur_inf ();
  struct proc *thread = inf_tid_to_thread (inf,
					   ptid_get_lwp (inferior_ptid));
  if (!thread)
    error (_("No current thread."));
  return thread;
}

/* Returns the current inferior, but signals an error if it has no task.  */
static struct inf *
active_inf (void)
{
  struct inf *inf = cur_inf ();

  if (!inf->task)
    error (_("No current process."));
  return inf;
}


static void
set_task_pause_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();
  int old_sc = inf->pause_sc;

  inf->pause_sc = parse_bool_arg (args, "set task pause");

  if (old_sc == 0 && inf->pause_sc != 0)
    /* If the task is currently unsuspended, immediately suspend it,
       otherwise wait until the next time it gets control.  */
    inf_suspend (inf);
}

static void
show_task_pause_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();

  check_empty (args, "show task pause");
  printf_unfiltered ("The inferior task %s suspended while gdb has control.\n",
		     inf->task
		     ? (inf->pause_sc == 0 ? "isn't" : "is")
		     : (inf->pause_sc == 0 ? "won't be" : "will be"));
}

static void
set_task_detach_sc_cmd (char *args, int from_tty)
{
  cur_inf ()->detach_sc = parse_int_arg (args,
					 "set task detach-suspend-count");
}

static void
show_task_detach_sc_cmd (char *args, int from_tty)
{
  check_empty (args, "show task detach-suspend-count");
  printf_unfiltered ("The inferior task will be left with a "
		     "suspend count of %d when detaching.\n",
		     cur_inf ()->detach_sc);
}


static void
set_thread_default_pause_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();

  inf->default_thread_pause_sc =
    parse_bool_arg (args, "set thread default pause") ? 0 : 1;
}

static void
show_thread_default_pause_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();
  int sc = inf->default_thread_pause_sc;

  check_empty (args, "show thread default pause");
  printf_unfiltered ("New threads %s suspended while gdb has control%s.\n",
		     sc ? "are" : "aren't",
		     !sc && inf->pause_sc ? " (but the task is)" : "");
}

static void
set_thread_default_run_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();

  inf->default_thread_run_sc =
    parse_bool_arg (args, "set thread default run") ? 0 : 1;
}

static void
show_thread_default_run_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();

  check_empty (args, "show thread default run");
  printf_unfiltered ("New threads %s allowed to run.\n",
		     inf->default_thread_run_sc == 0 ? "are" : "aren't");
}

static void
set_thread_default_detach_sc_cmd (char *args, int from_tty)
{
  cur_inf ()->default_thread_detach_sc =
    parse_int_arg (args, "set thread default detach-suspend-count");
}

static void
show_thread_default_detach_sc_cmd (char *args, int from_tty)
{
  check_empty (args, "show thread default detach-suspend-count");
  printf_unfiltered ("New threads will get a detach-suspend-count of %d.\n",
		     cur_inf ()->default_thread_detach_sc);
}


/* Steal a send right called NAME in the inferior task, and make it PROC's
   saved exception port.  */
static void
steal_exc_port (struct proc *proc, mach_port_t name)
{
  error_t err;
  mach_port_t port;
  mach_msg_type_name_t port_type;

  if (!proc || !proc->inf->task)
    error (_("No inferior task."));

  err = mach_port_extract_right (proc->inf->task->port,
				 name, MACH_MSG_TYPE_COPY_SEND,
				 &port, &port_type);
  if (err)
    error (_("Couldn't extract send right %d from inferior: %s"),
	   name, safe_strerror (err));

  if (proc->saved_exc_port)
    /* Get rid of our reference to the old one.  */
    mach_port_deallocate (mach_task_self (), proc->saved_exc_port);

  proc->saved_exc_port = port;

  if (!proc->exc_port)
    /* If PROC is a thread, we may not have set its exception port
       before.  We can't use proc_steal_exc_port because it also sets
       saved_exc_port.  */
    {
      proc->exc_port = proc->inf->event_port;
      err = proc_set_exception_port (proc, proc->exc_port);
      error (_("Can't set exception port for %s: %s"),
	     proc_string (proc), safe_strerror (err));
    }
}

static void
set_task_exc_port_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();

  if (!args)
    error (_("No argument to \"set task exception-port\" command."));
  steal_exc_port (inf->task, parse_and_eval_address (args));
}

static void
set_stopped_cmd (char *args, int from_tty)
{
  cur_inf ()->stopped = _parse_bool_arg (args, "yes", "no", "set stopped");
}

static void
show_stopped_cmd (char *args, int from_tty)
{
  struct inf *inf = active_inf ();

  check_empty (args, "show stopped");
  printf_unfiltered ("The inferior process %s stopped.\n",
		     inf->stopped ? "is" : "isn't");
}

static void
set_sig_thread_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();

  if (!args || (!isdigit (*args) && strcmp (args, "none") != 0))
    error (_("Illegal argument to \"set signal-thread\" command.\n"
	   "Should be an integer thread ID, or `none'."));

  if (strcmp (args, "none") == 0)
    inf->signal_thread = 0;
  else
    {
      ptid_t ptid = thread_id_to_pid (atoi (args));

      if (ptid_equal (ptid, minus_one_ptid))
	error (_("Thread ID %s not known.  "
		 "Use the \"info threads\" command to\n"
	       "see the IDs of currently known threads."), args);
      inf->signal_thread = inf_tid_to_thread (inf, ptid_get_lwp (ptid));
    }
}

static void
show_sig_thread_cmd (char *args, int from_tty)
{
  struct inf *inf = active_inf ();

  check_empty (args, "show signal-thread");
  if (inf->signal_thread)
    printf_unfiltered ("The signal thread is %s.\n",
		       proc_string (inf->signal_thread));
  else
    printf_unfiltered ("There is no signal thread.\n");
}


static void
set_signals_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();

  inf->want_signals = parse_bool_arg (args, "set signals");

  if (inf->task && inf->want_signals != inf->traced)
    /* Make this take effect immediately in a running process.  */
    inf_set_traced (inf, inf->want_signals);
}

static void
show_signals_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();

  check_empty (args, "show signals");
  printf_unfiltered ("The inferior process's signals %s intercepted.\n",
		     inf->task
		     ? (inf->traced ? "are" : "aren't")
		     : (inf->want_signals ? "will be" : "won't be"));
}

static void
set_exceptions_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();
  int val = parse_bool_arg (args, "set exceptions");

  if (inf->task && inf->want_exceptions != val)
    /* Make this take effect immediately in a running process.  */
    /* XXX */ ;

  inf->want_exceptions = val;
}

static void
show_exceptions_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();

  check_empty (args, "show exceptions");
  printf_unfiltered ("Exceptions in the inferior %s trapped.\n",
		     inf->task
		     ? (inf->want_exceptions ? "are" : "aren't")
		     : (inf->want_exceptions ? "will be" : "won't be"));
}


static void
set_task_cmd (char *args, int from_tty)
{
  printf_unfiltered ("\"set task\" must be followed by the name"
		     " of a task property.\n");
}

static void
show_task_cmd (char *args, int from_tty)
{
  struct inf *inf = cur_inf ();

  check_empty (args, "show task");

  show_signals_cmd (0, from_tty);
  show_exceptions_cmd (0, from_tty);
  show_task_pause_cmd (0, from_tty);

  if (inf->pause_sc == 0)
    show_thread_default_pause_cmd (0, from_tty);
  show_thread_default_run_cmd (0, from_tty);

  if (inf->task)
    {
      show_stopped_cmd (0, from_tty);
      show_sig_thread_cmd (0, from_tty);
    }

  if (inf->detach_sc != 0)
    show_task_detach_sc_cmd (0, from_tty);
  if (inf->default_thread_detach_sc != 0)
    show_thread_default_detach_sc_cmd (0, from_tty);
}


static void
set_noninvasive_cmd (char *args, int from_tty)
{
  /* Invert the sense of the arg for each component.  */
  char *inv_args = parse_bool_arg (args, "set noninvasive") ? "off" : "on";

  set_task_pause_cmd (inv_args, from_tty);
  set_signals_cmd (inv_args, from_tty);
  set_exceptions_cmd (inv_args, from_tty);
}


static void
info_port_rights (char *args, mach_port_type_t only)
{
  struct inf *inf = active_inf ();
  struct value *vmark = value_mark ();

  if (args)
    /* Explicit list of port rights.  */
    {
      while (*args)
	{
	  struct value *val = parse_to_comma_and_eval (&args);
	  long right = value_as_long (val);
	  error_t err =
	    print_port_info (right, 0, inf->task->port, PORTINFO_DETAILS,
			     stdout);

	  if (err)
	    error (_("%ld: %s."), right, safe_strerror (err));
	}
    }
  else
    /* Print all of them.  */
    {
      error_t err =
	print_task_ports_info (inf->task->port, only, PORTINFO_DETAILS,
			       stdout);
      if (err)
	error (_("%s."), safe_strerror (err));
    }

  value_free_to_mark (vmark);
}

static void
info_send_rights_cmd (char *args, int from_tty)
{
  info_port_rights (args, MACH_PORT_TYPE_SEND);
}

static void
info_recv_rights_cmd (char *args, int from_tty)
{
  info_port_rights (args, MACH_PORT_TYPE_RECEIVE);
}

static void
info_port_sets_cmd (char *args, int from_tty)
{
  info_port_rights (args, MACH_PORT_TYPE_PORT_SET);
}

static void
info_dead_names_cmd (char *args, int from_tty)
{
  info_port_rights (args, MACH_PORT_TYPE_DEAD_NAME);
}

static void
info_port_rights_cmd (char *args, int from_tty)
{
  info_port_rights (args, ~0);
}


static void
add_task_commands (void)
{
  add_cmd ("pause", class_run, set_thread_default_pause_cmd, _("\
Set whether the new threads are suspended while gdb has control.\n\
This property normally has no effect because the whole task is\n\
suspended, however, that may be disabled with \"set task pause off\".\n\
The default value is \"off\"."),
	   &set_thread_default_cmd_list);
  add_cmd ("pause", no_class, show_thread_default_pause_cmd, _("\
Show whether new threads are suspended while gdb has control."),
	   &show_thread_default_cmd_list);
  
  add_cmd ("run", class_run, set_thread_default_run_cmd, _("\
Set whether new threads are allowed to run (once gdb has noticed them)."),
	   &set_thread_default_cmd_list);
  add_cmd ("run", no_class, show_thread_default_run_cmd, _("\
Show whether new threads are allowed to run (once gdb has noticed them)."),
	   &show_thread_default_cmd_list);
  
  add_cmd ("detach-suspend-count", class_run, set_thread_default_detach_sc_cmd,
	   _("Set the default detach-suspend-count value for new threads."),
	   &set_thread_default_cmd_list);
  add_cmd ("detach-suspend-count", no_class, show_thread_default_detach_sc_cmd,
	   _("Show the default detach-suspend-count value for new threads."),
	   &show_thread_default_cmd_list);

  add_cmd ("signals", class_run, set_signals_cmd, _("\
Set whether the inferior process's signals will be intercepted.\n\
Mach exceptions (such as breakpoint traps) are not affected."),
	   &setlist);
  add_alias_cmd ("sigs", "signals", class_run, 1, &setlist);
  add_cmd ("signals", no_class, show_signals_cmd, _("\
Show whether the inferior process's signals will be intercepted."),
	   &showlist);
  add_alias_cmd ("sigs", "signals", no_class, 1, &showlist);

  add_cmd ("signal-thread", class_run, set_sig_thread_cmd, _("\
Set the thread that gdb thinks is the libc signal thread.\n\
This thread is run when delivering a signal to a non-stopped process."),
	   &setlist);
  add_alias_cmd ("sigthread", "signal-thread", class_run, 1, &setlist);
  add_cmd ("signal-thread", no_class, show_sig_thread_cmd, _("\
Set the thread that gdb thinks is the libc signal thread."),
	   &showlist);
  add_alias_cmd ("sigthread", "signal-thread", no_class, 1, &showlist);

  add_cmd ("stopped", class_run, set_stopped_cmd, _("\
Set whether gdb thinks the inferior process is stopped as with SIGSTOP.\n\
Stopped process will be continued by sending them a signal."),
	   &setlist);
  add_cmd ("stopped", no_class, show_stopped_cmd, _("\
Show whether gdb thinks the inferior process is stopped as with SIGSTOP."),
	   &showlist);

  add_cmd ("exceptions", class_run, set_exceptions_cmd, _("\
Set whether exceptions in the inferior process will be trapped.\n\
When exceptions are turned off, neither breakpoints nor single-stepping\n\
will work."),
	   &setlist);
  /* Allow `set exc' despite conflict with `set exception-port'.  */
  add_alias_cmd ("exc", "exceptions", class_run, 1, &setlist);
  add_cmd ("exceptions", no_class, show_exceptions_cmd, _("\
Show whether exceptions in the inferior process will be trapped."),
	   &showlist);

  add_prefix_cmd ("task", no_class, set_task_cmd,
		  _("Command prefix for setting task attributes."),
		  &set_task_cmd_list, "set task ", 0, &setlist);
  add_prefix_cmd ("task", no_class, show_task_cmd,
		  _("Command prefix for showing task attributes."),
		  &show_task_cmd_list, "show task ", 0, &showlist);

  add_cmd ("pause", class_run, set_task_pause_cmd, _("\
Set whether the task is suspended while gdb has control.\n\
A value of \"on\" takes effect immediately, otherwise nothing happens\n\
until the next time the program is continued.\n\
When setting this to \"off\", \"set thread default pause on\" can be\n\
used to pause individual threads by default instead."),
	   &set_task_cmd_list);
  add_cmd ("pause", no_class, show_task_pause_cmd,
	   _("Show whether the task is suspended while gdb has control."),
	   &show_task_cmd_list);

  add_cmd ("detach-suspend-count", class_run, set_task_detach_sc_cmd,
	   _("Set the suspend count will leave on the thread when detaching."),
	   &set_task_cmd_list);
  add_cmd ("detach-suspend-count", no_class, show_task_detach_sc_cmd,
	   _("Show the suspend count will leave "
	     "on the thread when detaching."),
	   &show_task_cmd_list);

  add_cmd ("exception-port", no_class, set_task_exc_port_cmd, _("\
Set the task exception port to which we forward exceptions.\n\
The argument should be the value of the send right in the task."),
	   &set_task_cmd_list);
  add_alias_cmd ("excp", "exception-port", no_class, 1, &set_task_cmd_list);
  add_alias_cmd ("exc-port", "exception-port", no_class, 1,
		 &set_task_cmd_list);

  /* A convenient way of turning on all options require to noninvasively
     debug running tasks.  */
  add_cmd ("noninvasive", no_class, set_noninvasive_cmd, _("\
Set task options so that we interfere as little as possible.\n\
This is the same as setting `task pause', `exceptions', and\n\
`signals' to the opposite value."),
	   &setlist);

  /* Commands to show information about the task's ports.  */
  add_cmd ("send-rights", class_info, info_send_rights_cmd,
	   _("Show information about the task's send rights"),
	   &infolist);
  add_cmd ("receive-rights", class_info, info_recv_rights_cmd,
	   _("Show information about the task's receive rights"),
	   &infolist);
  add_cmd ("port-rights", class_info, info_port_rights_cmd,
	   _("Show information about the task's port rights"),
	   &infolist);
  add_cmd ("port-sets", class_info, info_port_sets_cmd,
	   _("Show information about the task's port sets"),
	   &infolist);
  add_cmd ("dead-names", class_info, info_dead_names_cmd,
	   _("Show information about the task's dead names"),
	   &infolist);
  add_info_alias ("ports", "port-rights", 1);
  add_info_alias ("port", "port-rights", 1);
  add_info_alias ("psets", "port-sets", 1);
}


static void
set_thread_pause_cmd (char *args, int from_tty)
{
  struct proc *thread = cur_thread ();
  int old_sc = thread->pause_sc;

  thread->pause_sc = parse_bool_arg (args, "set thread pause");
  if (old_sc == 0 && thread->pause_sc != 0 && thread->inf->pause_sc == 0)
    /* If the task is currently unsuspended, immediately suspend it,
       otherwise wait until the next time it gets control.  */
    inf_suspend (thread->inf);
}

static void
show_thread_pause_cmd (char *args, int from_tty)
{
  struct proc *thread = cur_thread ();
  int sc = thread->pause_sc;

  check_empty (args, "show task pause");
  printf_unfiltered ("Thread %s %s suspended while gdb has control%s.\n",
		     proc_string (thread),
		     sc ? "is" : "isn't",
		     !sc && thread->inf->pause_sc ? " (but the task is)" : "");
}

static void
set_thread_run_cmd (char *args, int from_tty)
{
  struct proc *thread = cur_thread ();

  thread->run_sc = parse_bool_arg (args, "set thread run") ? 0 : 1;
}

static void
show_thread_run_cmd (char *args, int from_tty)
{
  struct proc *thread = cur_thread ();

  check_empty (args, "show thread run");
  printf_unfiltered ("Thread %s %s allowed to run.",
		     proc_string (thread),
		     thread->run_sc == 0 ? "is" : "isn't");
}

static void
set_thread_detach_sc_cmd (char *args, int from_tty)
{
  cur_thread ()->detach_sc = parse_int_arg (args,
					    "set thread detach-suspend-count");
}

static void
show_thread_detach_sc_cmd (char *args, int from_tty)
{
  struct proc *thread = cur_thread ();

  check_empty (args, "show thread detach-suspend-count");
  printf_unfiltered ("Thread %s will be left with a suspend count"
		     " of %d when detaching.\n",
		     proc_string (thread),
		     thread->detach_sc);
}

static void
set_thread_exc_port_cmd (char *args, int from_tty)
{
  struct proc *thread = cur_thread ();

  if (!args)
    error (_("No argument to \"set thread exception-port\" command."));
  steal_exc_port (thread, parse_and_eval_address (args));
}

#if 0
static void
show_thread_cmd (char *args, int from_tty)
{
  struct proc *thread = cur_thread ();

  check_empty (args, "show thread");
  show_thread_run_cmd (0, from_tty);
  show_thread_pause_cmd (0, from_tty);
  if (thread->detach_sc != 0)
    show_thread_detach_sc_cmd (0, from_tty);
}
#endif

static void
thread_takeover_sc_cmd (char *args, int from_tty)
{
  struct proc *thread = cur_thread ();

  thread_basic_info_data_t _info;
  thread_basic_info_t info = &_info;
  mach_msg_type_number_t info_len = THREAD_BASIC_INFO_COUNT;
  error_t err =
  thread_info (thread->port, THREAD_BASIC_INFO, (int *) &info, &info_len);
  if (err)
    error (("%s."), safe_strerror (err));
  thread->sc = info->suspend_count;
  if (from_tty)
    printf_unfiltered ("Suspend count was %d.\n", thread->sc);
  if (info != &_info)
    vm_deallocate (mach_task_self (), (vm_address_t) info,
		   info_len * sizeof (int));
}


static void
add_thread_commands (void)
{
  add_prefix_cmd ("thread", no_class, set_thread_cmd,
		  _("Command prefix for setting thread properties."),
		  &set_thread_cmd_list, "set thread ", 0, &setlist);
  add_prefix_cmd ("default", no_class, show_thread_cmd,
		  _("Command prefix for setting default thread properties."),
		  &set_thread_default_cmd_list, "set thread default ", 0,
		  &set_thread_cmd_list);
  add_prefix_cmd ("thread", no_class, set_thread_default_cmd,
		  _("Command prefix for showing thread properties."),
		  &show_thread_cmd_list, "show thread ", 0, &showlist);
  add_prefix_cmd ("default", no_class, show_thread_default_cmd,
		  _("Command prefix for showing default thread properties."),
		  &show_thread_default_cmd_list, "show thread default ", 0,
		  &show_thread_cmd_list);

  add_cmd ("pause", class_run, set_thread_pause_cmd, _("\
Set whether the current thread is suspended while gdb has control.\n\
A value of \"on\" takes effect immediately, otherwise nothing happens\n\
until the next time the program is continued.  This property normally\n\
has no effect because the whole task is suspended, however, that may\n\
be disabled with \"set task pause off\".\n\
The default value is \"off\"."),
	   &set_thread_cmd_list);
  add_cmd ("pause", no_class, show_thread_pause_cmd, _("\
Show whether the current thread is suspended while gdb has control."),
	   &show_thread_cmd_list);

  add_cmd ("run", class_run, set_thread_run_cmd,
	   _("Set whether the current thread is allowed to run."),
	   &set_thread_cmd_list);
  add_cmd ("run", no_class, show_thread_run_cmd,
	   _("Show whether the current thread is allowed to run."),
	   &show_thread_cmd_list);

  add_cmd ("detach-suspend-count", class_run, set_thread_detach_sc_cmd, _("\
Set the suspend count will leave on the thread when detaching.\n\
Note that this is relative to suspend count when gdb noticed the thread;\n\
use the `thread takeover-suspend-count' to force it to an absolute value."),
	   &set_thread_cmd_list);
  add_cmd ("detach-suspend-count", no_class, show_thread_detach_sc_cmd, _("\
Show the suspend count will leave on the thread when detaching.\n\
Note that this is relative to suspend count when gdb noticed the thread;\n\
use the `thread takeover-suspend-count' to force it to an absolute value."),
	   &show_thread_cmd_list);

  add_cmd ("exception-port", no_class, set_thread_exc_port_cmd, _("\
Set the thread exception port to which we forward exceptions.\n\
This overrides the task exception port.\n\
The argument should be the value of the send right in the task."),
	   &set_thread_cmd_list);
  add_alias_cmd ("excp", "exception-port", no_class, 1, &set_thread_cmd_list);
  add_alias_cmd ("exc-port", "exception-port", no_class, 1,
		 &set_thread_cmd_list);

  add_cmd ("takeover-suspend-count", no_class, thread_takeover_sc_cmd, _("\
Force the threads absolute suspend-count to be gdb's.\n\
Prior to giving this command, gdb's thread suspend-counts are relative\n\
to the thread's initial suspend-count when gdb notices the threads."),
	   &thread_cmd_list);
}


void
_initialize_gnu_nat (void)
{
  proc_server = getproc ();

  add_task_commands ();
  add_thread_commands ();
  add_setshow_boolean_cmd ("gnu-nat", class_maintenance,
			   &gnu_debug_flag,
			   _("Set debugging output for the gnu backend."),
			   _("Show debugging output for the gnu backend."),
			   NULL,
			   NULL,
			   NULL,
			   &setdebuglist,
			   &showdebuglist);
}

#ifdef	FLUSH_INFERIOR_CACHE

/* When over-writing code on some machines the I-Cache must be flushed
   explicitly, because it is not kept coherent by the lazy hardware.
   This definitely includes breakpoints, for instance, or else we
   end up looping in mysterious Bpt traps.  */

void
flush_inferior_icache (CORE_ADDR pc, int amount)
{
  vm_machine_attribute_val_t flush = MATTR_VAL_ICACHE_FLUSH;
  error_t ret;

  ret = vm_machine_attribute (gnu_current_inf->task->port,
			      pc,
			      amount,
			      MATTR_CACHE,
			      &flush);
  if (ret != KERN_SUCCESS)
    warning (_("Error flushing inferior's cache : %s"), safe_strerror (ret));
}
#endif /* FLUSH_INFERIOR_CACHE */
@


1.89
log
@gnu-nat.c: Don't install a deprecated_xfer_memory method.

This removes another instance of a deprecated_xfer_memory user.

gdb/
2013-09-19  Pedro Alves  <palves@@redhat.com>
	    Thomas Schwinge  <thomas@@codesourcery.com>
	    Yue Lu  <hacklu.newborn@@gmail.com>

	* gnu-nat.c (gnu_read_inferior, gnu_write_inferior): Make static.
	Take a gdb_byte pointer instead of a char pointer.

	* gnu-nat.c (gnu_xfer_memory): Adjust interface as
	gnu_xfer_partial helper.
	(gnu_xfer_partial): New function.
	(gnu_target): Don't install a deprecated_xfer_memory hook.
	Install a to_xfer_partial hook.
@
text
@d2018 2
a2019 1
      inf_debug (inf, "running all threads; tid = %d", PIDGET (inferior_ptid));
@


1.88
log
@Subject: [PATCH] [Hurd/gnu-nat.c] Use ptid_t.lwpid to store thread ids
 instead of ptid_t.tid.

In preparation for reusing gnu-nat.c in gdbserver, switch to storing
thread ids in the lwpid field of ptid_t rather than in the tid
field.  The Hurd's thread model is 1:1, so it doesn't feel wrong
anyway.

gdb/
2013-09-18  Pedro Alves  <palves@@redhat.com>

	* gnu-nat.c (inf_validate_procs, gnu_wait, gnu_resume)
	(gnu_create_inferior)
	(gnu_attach, gnu_thread_alive, gnu_pid_to_str, cur_thread)
	(set_sig_thread_cmd): Use the lwpid field of ptids to
	store/extract thread ids instead of the tid field.
	* i386gnu-nat.c (gnu_fetch_registers): Adjust.
@
text
@d2271 2
a2272 2
int
gnu_read_inferior (task_t task, CORE_ADDR addr, char *myaddr, int length)
d2317 3
a2319 2
int
gnu_write_inferior (task_t task, CORE_ADDR addr, char *myaddr, int length)
d2475 6
a2480 6
/* Return 0 on failure, number of bytes handled otherwise.  TARGET
   is ignored.  */
static int
gnu_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len, int write,
		 struct mem_attrib *attrib,
		 struct target_ops *target)
d2486 1
d2489 9
a2497 1
    return 0;
d2500 24
a2523 8
      inf_debug (gnu_current_inf, "%s %s[%d] %s %s",
		 write ? "writing" : "reading",
		 paddress (target_gdbarch (), memaddr), len,
		 write ? "<--" : "-->", host_address_to_string (myaddr));
      if (write)
	return gnu_write_inferior (task, memaddr, myaddr, len);
      else
	return gnu_read_inferior (task, memaddr, myaddr, len);
d2657 1
a2657 1
  t->deprecated_xfer_memory = gnu_xfer_memory;
@


1.87
log
@[Hurd/gnu-nat] Fix old "signal-thread" command regression.

By inspection, I noticed that when I made the gnu-nat use
ptid(pid,0,tid) to represent a thread, instead of using ptid(tid,0,0),
in <https://sourceware.org/ml/gdb-patches/2008-08/msg00175.html>, I
introduced a bug.

The change was:

   else
     {
-      int tid = PIDGET (thread_id_to_pid (atoi (args)));
+      int tid = ptid_get_tid (thread_id_to_pid (atoi (args)));
       if (tid < 0)
 	error (_("Thread ID %s not known.  Use the \"info threads\" command to\n"
 	       "see the IDs of currently known threads."), args);

and thread_id_to_pid does:

 ptid_t
 thread_id_to_pid (int num)
 {
   struct thread_info *thread = find_thread_id (num);

   if (thread)
     return thread->ptid;
   else
     return pid_to_ptid (-1);
 }

(pid_to_ptid (-1) is the same as minus_one_ptid.)

So before, we were really looking at the pid, where thread_id_to_pid
stores the -1.

The right fix is to compare the whole ptid to minus_one_ptid, of
course.

Completely untested, but I think it's obvious enough, so I went ahead
and put it in.

gdb/
2013-09-18  Pedro Alves  <palves@@redhat.com>

	* gnu-nat.c (set_sig_thread_cmd): Compare the thread's ptid to
	minus_one_ptid instead of looking at the ptid's tid field and
	comparing that to -1.
@
text
@d1086 1
a1086 1
	    ptid = ptid_build (inf->pid, 0, thread->tid);
d1616 1
a1616 1
    ptid = ptid_build (inf->pid, 0, thread->tid);
d1620 1
a1620 1
    thread = inf_tid_to_thread (inf, ptid_get_tid (ptid));
d1626 1
a1626 1
	ptid = ptid_build (inf->pid, 0, inf->threads->tid); /* The first
d2025 1
a2025 1
      struct proc *thread = inf_tid_to_thread (inf, ptid_get_tid (ptid));
d2036 1
a2036 1
      step_thread = inf_tid_to_thread (inf, ptid_get_tid (ptid));
d2136 1
a2136 1
		      ptid_build (inf->pid, 0, inf_pick_first_thread ()));
d2193 1
a2193 1
  inferior_ptid = ptid_build (pid, 0, inf_pick_first_thread ());
d2264 1
a2264 1
			      ptid_get_tid (ptid));
d2599 1
a2599 1
  int tid = ptid_get_tid (ptid);
d2732 1
a2732 1
					   ptid_get_tid (inferior_ptid));
d2931 1
a2931 1
      inf->signal_thread = inf_tid_to_thread (inf, ptid_get_tid (ptid));
@


1.86
log
@Fix formating in copyright headers.

File list found with:
$ grep "along with this program" * -A 1 -rn \
	| grep "*/" \
	| grep -v "along with this program" \
	| sed 's,-[0-9]\+-.*,,g'

Tested on x86_64 Fedora 17.

gdb/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* darwin-nat.c: Fix formating in copyright header.
	* darwin-nat.h: Likewise.
	* gnu-nat.c: Likewise.
	* machoread.c: Likewise.

gdb/testsuite/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* gdb.ada/info_types.c: Fix formating in copyright header.
	* gdb.base/break-on-linker-gcd-function.cc: Likewise.
	* gdb.base/float.c: Likewise.
	* gdb.base/inferior-died.c: Likewise.
	* gdb.base/interp.c: Likewise.
	* gdb.base/jit-main.c: Likewise.
	* gdb.base/jit-solib.c: Likewise.
	* gdb.base/long_long.c: Likewise.
	* gdb.base/longjmp.c: Likewise.
	* gdb.base/nextoverexit.c: Likewise.
	* gdb.base/pr11022.c: Likewise.
	* gdb.base/prelink-lib.c: Likewise.
	* gdb.base/prelink.c: Likewise.
	* gdb.base/prologue.c: Likewise.
	* gdb.base/restore.c: Likewise.
	* gdb.base/sigchld.c: Likewise.
	* gdb.base/solib-search-lib1.c: Likewise.
	* gdb.base/solib-search-lib2.c: Likewise.
	* gdb.base/solib-search.c: Likewise.
	* gdb.base/solib-search.h: Likewise.
	* gdb.base/whatis.c: Likewise.
	* gdb.cp/abstract-origin.cc: Likewise.
	* gdb.cp/anon-struct.cc: Likewise.
	* gdb.cp/baseenum.cc: Likewise.
	* gdb.cp/bs15503.cc: Likewise.
	* gdb.cp/call-c-1.c: Likewise.
	* gdb.cp/call-c.cc: Likewise.
	* gdb.cp/class2.cc: Likewise.
	* gdb.cp/classes.cc: Likewise.
	* gdb.cp/cttiadd.cc: Likewise.
	* gdb.cp/cttiadd1.cc: Likewise.
	* gdb.cp/cttiadd2.cc: Likewise.
	* gdb.cp/cttiadd3.cc: Likewise.
	* gdb.cp/derivation.cc: Likewise.
	* gdb.cp/derivation2.cc: Likewise.
	* gdb.cp/dispcxx.cc: Likewise.
	* gdb.cp/exception.cc: Likewise.
	* gdb.cp/gdb2384-base.cc: Likewise.
	* gdb.cp/gdb2384-base.h: Likewise.
	* gdb.cp/gdb2384.cc: Likewise.
	* gdb.cp/gdb2495.cc: Likewise.
	* gdb.cp/mb-inline.h: Likewise.
	* gdb.cp/mb-inline1.cc: Likewise.
	* gdb.cp/mb-inline2.cc: Likewise.
	* gdb.cp/member-name.cc: Likewise.
	* gdb.cp/member-ptr.cc: Likewise.
	* gdb.cp/misc.cc: Likewise.
	* gdb.cp/namespace1.cc: Likewise.
	* gdb.cp/nextoverthrow.cc: Likewise.
	* gdb.cp/pr-574.cc: Likewise.
	* gdb.cp/pr9631.cc: Likewise.
	* gdb.cp/printmethod.cc: Likewise.
	* gdb.cp/psmang1.cc: Likewise.
	* gdb.cp/psmang2.cc: Likewise.
	* gdb.cp/psymtab-parameter.cc: Likewise.
	* gdb.cp/ptype-flags.cc: Likewise.
	* gdb.cp/ref-params.cc: Likewise.
	* gdb.cp/ref-types.cc: Likewise.
	* gdb.cp/smartp.cc: Likewise.
	* gdb.cp/try_catch.cc: Likewise.
	* gdb.cp/userdef.cc: Likewise.
	* gdb.cp/using-crash.cc: Likewise.
	* gdb.cp/virtfunc.cc: Likewise.
	* gdb.cp/virtfunc2.cc: Likewise.
	* gdb.dwarf2/callframecfa.S: Likewise.
	* gdb.dwarf2/dw2-ranges.c: Likewise.
	* gdb.dwarf2/dw2-ranges2.c: Likewise.
	* gdb.dwarf2/dw2-ranges3.c: Likewise.
	* gdb.dwarf2/dw2-restore.S: Likewise.
	* gdb.dwarf2/pieces.S: Likewise.
	* gdb.dwarf2/valop.S: Likewise.
	* gdb.java/jnpe.java: Likewise.
	* gdb.mi/mi-stepn.c: Likewise.
	* gdb.mi/mi-var-cp.cc: Likewise.
	* gdb.mi/mi-var-rtti.cc: Likewise.
	* gdb.mi/ns-stale-regcache.c: Likewise.
	* gdb.mi/pr11022.c: Likewise.
	* gdb.mi/solib-lib.c: Likewise.
	* gdb.mi/solib-main.c: Likewise.
	* gdb.python/py-arch.c: Likewise.
	* gdb.python/py-block.c: Likewise.
	* gdb.python/py-breakpoint.c: Likewise.
	* gdb.python/py-events.c: Likewise.
	* gdb.python/py-evthreads.c: Likewise.
	* gdb.python/py-explore.c: Likewise.
	* gdb.python/py-explore.cc: Likewise.
	* gdb.python/py-finish-breakpoint.c: Likewise.
	* gdb.python/py-finish-breakpoint2.cc: Likewise.
	* gdb.python/py-symbol.c: Likewise.
	* gdb.threads/execl.c: Likewise.
	* gdb.threads/execl1.c: Likewise.
@
text
@d2925 1
a2925 1
      int tid = ptid_get_tid (thread_id_to_pid (atoi (args)));
d2927 1
a2927 1
      if (tid < 0)
d2931 1
a2931 1
      inf->signal_thread = inf_tid_to_thread (inf, tid);
@


1.85
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d21 1
a21 2
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
@


1.84
log
@	ARI fixes: sprintf rule.
	Replace sprintf function calls for char arrays by
	calls to xsnprintf calls.
	* arm-tdep.c (arm_push_dummy_call): Replace sprintf by xsnprintf.
	(arm_dwarf_reg_to_regnum, arm_return_value): Ditto.
	(arm_neon_quad_read, arm_pseudo_read): Ditto.
	(arm_neon_quad_write, arm_pseudo_write): Ditto.
	* breakpoint.c (condition_completer): Ditto.
	(create_tracepoint_from_upload): Ditto.
	* dwarf2read.c (file_full_name): Ditto.
	* gcore.c (gcore_command): Ditto.
	* gnu-nat.c (proc_string, gnu_pid_to_str): Ditto.
	* go32-nat.c (go32_sysinfo): Ditto.
	* interps.c (interp_set): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	* ppc-linux-nat.c (fetch_register, store_register): Ditto.
	* remote-m32r-sdi.c (m32r_open): Ditto.
	* sol-thread.c (td_err_string): Ditto.
	(td_state_string, solaris_pid_to_str): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	* cli/cli-script.c (execute_control_command): Ditto.
	(define_command, document_command): Ditto.
	* tui/tui-io.c (tui_rl_display_match_list): Ditto.
	* tui/tui-stack.c (tui_make_status_line): Ditto.
	* tui/tui-win.c (tui_update_gdb_sizes): Ditto.
@
text
@d2 1
a2 2
   Copyright (C) 1992, 1995-2001, 2006-2012 Free Software Foundation,
   Inc.
@


1.83
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d2590 1
a2590 1
    sprintf (tid_str, "process %d", proc->inf->pid);
d2592 2
a2593 2
    sprintf (tid_str, "Thread %d.%d",
	     proc->inf->pid, proc->tid);
d2610 1
a2610 1
      sprintf (tid_str, "bogus thread id %d", tid);
@


1.82
log
@2012-11-07  Pedro Alves  <palves@@redhat.com>

	* arm-tdep.c: Make defs.h be the first include.
	* coff-pe-read.c: Ditto.
	* gnu-nat.c: Ditto.
	* go32-nat.c: Ditto.
	* i386-nat.c: Ditto.
	* ppcnbsd-nat.c: Ditto.
	* ada-varobj.h: Don't include defs.h.
	* i386-darwin-tdep.h: Ditto.
	* i386-nat.h: Ditto.
@
text
@d2494 1
a2494 1
		 paddress (target_gdbarch, memaddr), len,
@


1.81
log
@gdb/
	* cli/cli-dump.c: Add 'static' to some cmd_list_element variables.
	* gnu-nat.c, symfile.c: Likewise.
@
text
@d25 2
a56 1
#include "defs.h"
@


1.80
log
@gdb/
	PR 11804
	* defs.h (find_memory_region_ftype): New comment.  New arg modified.
	* fbsd-nat.c (fbsd_find_memory_regions): Add the passed modified value.
	* gcore.c (gcore_create_callback): New function comment.  Add modified
	parameter.  Only write modified regions.  Set SEC_READONLY exactly
	according to MODIFIED.
	(objfile_find_memory_regions): Ignore separate debug info files.  Ass
	the passed modified value to FUNC.
	* gnu-nat.c (gnu_find_memory_regions): Add the passed modified value.
	* linux-tdep.c (linux_find_memory_regions): Try to reads smaps file
	first.  New variables modified and has_anonymous.  Parse the lines of
	smaps file.  Add the passed MODIFIED value to FUNC.
	* procfs.c (find_memory_regions_callback): Add the passed modified
	value.

gdb/testsuite/
	PR 11804
	* gdb.base/gcore-relro.exp: New file.
	* gdb.base/gcore-relro-main.c: New file.
	* gdb.base/gcore-relro-lib.c: New file.
@
text
@d2648 2
a2649 2
struct cmd_list_element *set_task_cmd_list = 0;
struct cmd_list_element *show_task_cmd_list = 0;
@


1.79
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d2561 1
d2575 1
@


1.78
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d1257 1
a1257 1
	    inf_signal (inf, TARGET_SIGNAL_0);
d1577 1
a1577 1
	       && w->status.value.sig == TARGET_SIGNAL_TRAP)
d1697 1
a1697 1
	  inf->wait.status.value.sig = TARGET_SIGNAL_TRAP;
d1753 1
a1753 1
  inf->wait.status.value.sig = TARGET_SIGNAL_KILL;
d1921 1
a1921 1
      inf->wait.status.value.sig = TARGET_SIGNAL_0;
d1989 1
a1989 1
  if (sig != TARGET_SIGNAL_0 || inf->stopped)
d1991 1
a1991 1
      if (sig == TARGET_SIGNAL_0 && inf->nomsg)
@


1.77
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d110 1
a110 1
void inf_signal (struct inf *inf, enum target_signal sig);
d1324 1
a1324 1
inf_signal (struct inf *inf, enum target_signal sig)
d1327 1
a1327 1
  int host_sig = target_signal_to_host (sig);
d1329 1
a1329 1
#define NAME target_signal_to_name (sig)
d1731 1
a1731 1
	    target_signal_from_host (_NSIG + exception);
d1978 1
a1978 1
	    ptid_t ptid, int step, enum target_signal sig)
d2003 1
a2003 1
	       target_signal_to_name (inf->wait.status.value.sig));
@


1.76
log
@2011-09-22  Tristan Gingold  <gingold@@adacore.com>

	* fork-child.c (fork_inferior): Add exec_fun parameter.
	Call exec_fun or execvp.
	* inferior.h: Adjust prototype.
	* gnu-nat.c (gnu_create_inferior): Adjust fork_inferior call.
	* inf-ttrace.c (inf_ttrace_create_inferior): Ditto.
	* inf-ptrace.c (inf_ptrace_create_inferior): Ditto.
	* procfs.c (procfs_create_inferior): Ditto.
	* darwin-nat.c (darwin_execvp): New function.
	(darwin_create_inferior): Use it.
@
text
@d2 2
a3 2
   Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2006, 2007,
   2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.76.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1992, 1995-2001, 2006-2012 Free Software Foundation,
   Inc.
@


1.75
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d2117 2
a2118 1
  pid = fork_inferior (exec_file, allargs, env, trace_me, NULL, NULL, NULL);
@


1.74
log
@run copyright.sh for 2011.
@
text
@d153 1
a153 1
    int exception;		/* The exception code */
d155 2
a156 2
    mach_port_t handler;	/* The real exception port to handle this. */
    mach_port_t reply;		/* The reply port from the exception call. */
d159 1
a159 1
/* The results of the last wait an inf did. */
d163 1
a163 1
    struct exc_state exc;	/* The exception that caused us to return. */
d176 4
a179 4
    /* True if THREADS needn't be validated by querying the task.  We assume that
       we and the task in question are the only ones frobbing the thread list,
       so as long as we don't let any code run, we don't have to worry about
       THREADS changing.  */
d182 1
a182 1
    pid_t pid;			/* The real system PID. */
d186 2
a187 1
    /* One thread proc in INF may be in `single-stepping mode'.  This is it.  */
d219 1
a219 1
    /* Fields describing global state */
d267 1
a267 1
    /* Since PROC may start running, we must write back any state changes. */
d437 3
a439 2
/* Replace PROC's exception port with EXC_PORT, unless it's already been
   done.  Stash away any existing exception port so we can restore it later. */
d463 1
a463 1
	/* Keep a copy of PROC's old exception port so it can be restored. */
d519 1
a519 1
    return 0;			/* the thread must be dead.  */
d526 1
a526 1
         exception port???? */
d757 2
a758 1
	error (_("Error getting task for pid %d: %s"), pid, safe_strerror (err));
d769 2
a770 2
      inf_validate_procs (inf);	/* Trash all the threads. */
      _proc_free (task);	/* And the task. */
d913 1
a913 1
   thought to be running. */
d1033 1
a1033 1
    /* The current thread we're considering. */
d1289 1
a1289 1
/* Makes sure that we've got our exception ports entrenched in the process. */
d1297 1
a1297 1
  inf_set_step_thread (inf, 0);	/* The step thread is special. */
d1312 1
a1312 1
  inf_set_step_thread (inf, 0);	/* The step thread is special. */
d1389 1
a1389 1
       happens. */
d1400 1
a1400 1
    /* Can't do too much... */
d1445 1
a1445 1
/* Wait for something to happen in the inferior, returning what in STATUS. */
d1489 1
a1489 1
	   outstanding wait request, so we have to cancel the previous one. */
d1507 1
a1507 1
	     when you switch processes. */
d1584 5
a1588 3
#if 0				/* do we need this? */
	      prune_threads (1);	/* Get rid of the old shell threads */
	      renumber_threads (0);	/* Give our threads reasonable names. */
d1627 3
a1629 1
	ptid = ptid_build (inf->pid, 0, inf->threads->tid); /* The first available thread.  */
d1717 1
a1717 1
	    /* Add a reference to the exception handler. */
d1727 3
a1729 2
	  /* Exceptions are encoded in the signal space by putting them after
	     _NSIG; this assumes they're positive (and not extremely large)! */
d1750 2
a1751 1
  warning (_("Pid %d died with unknown exit status, using SIGKILL."), inf->pid);
d1793 1
a1793 1
  inf->threads_up_to_date = 0;	/* Just in case */
d1867 2
a1868 1
	  warning (_("Can't wait for pid %d: %s"), inf->pid, safe_strerror (err));
d1974 2
a1975 2
   in multiple events returned by wait).
 */
d2008 1
a2008 1
       the process, as we're just going to stop it right away anyway. */
d2020 1
a2020 1
      ptid = inferior_ptid;	/* What to step. */
d2131 1
a2131 1
     immediately because of the ptrace. */
d2206 2
a2207 2
#if 0				/* Do we need this? */
  renumber_threads (0);		/* Give our threads reasonable names. */
d2243 1
a2243 1
  unpush_target (ops);	/* Pop out of handling an inferior */
d2281 1
a2281 1
  /* Get memory from inferior with page aligned addresses */
d2286 2
a2287 1
  err = hurd_safe_copyin (myaddr, (void *) (addr - low_address + copied), length);
d2296 2
a2297 1
    warning (_("gnu_read_inferior vm_deallocate failed: %s"), safe_strerror (err));
d2333 1
a2333 1
  /* Get memory from inferior with page aligned addresses */
d2379 1
a2379 1
	/* Check for holes in memory */
d2391 2
a2392 1
	    warning (_("Memory at address 0x%x is unwritable. Nothing written"),
d2399 1
a2399 1
	/* Chain the regions for later use */
d2408 1
a2408 1
	/* Chain the regions along with protections */
d2419 1
a2419 1
    /* Enable writes to the chained vm regions */
d2439 1
a2439 1
    /* Set up the original region protections, if they were changed */
d2475 1
a2475 1
   is ignored. */
d2661 2
a2662 1
  printf_unfiltered ("\"set thread\" must be followed by the name of a thread property, or \"default\".\n");
d2668 2
a2669 1
  printf_unfiltered ("\"show thread\" must be followed by the name of a thread property, or \"default\".\n");
d2675 2
a2676 1
  printf_unfiltered ("\"set thread default\" must be followed by the name of a thread property.\n");
d2682 2
a2683 1
  printf_unfiltered ("\"show thread default\" must be followed by the name of a thread property.\n");
d2697 2
a2698 1
  error (_("Illegal argument for \"%s\" command, should be an integer."), cmd_prefix);
d2709 2
a2710 1
    error (_("Illegal argument for \"%s\" command, should be \"%s\" or \"%s\"."),
d2777 2
a2778 1
  cur_inf ()->detach_sc = parse_int_arg (args, "set task detach-suspend-count");
d2785 2
a2786 1
  printf_unfiltered ("The inferior task will be left with a suspend count of %d when detaching.\n",
d2873 3
a2875 2
    /* If PROC is a thread, we may not have set its exception port before.
       We can't use proc_steal_exc_port because it also sets saved_exc_port. */
d2926 2
a2927 1
	error (_("Thread ID %s not known.  Use the \"info threads\" command to\n"
d3197 2
a3198 1
	   _("Show the suspend count will leave on the thread when detaching."),
d3436 1
a3436 1
   end up looping in mysterious Bpt traps */
@


1.73
log
@gdb/
	Code cleanup.
	* defs.h (find_memory_region_ftype): New typedef.
	(exec_set_find_memory_regions): Use it.
	* exec.c (exec_set_find_memory_regions): Use find_memory_region_ftype.
	* fbsd-nat.c (fbsd_find_memory_regions): Likewise.
	* gcore.c (objfile_find_memory_regions): Likewise.
	* gnu-nat.c (gnu_find_memory_regions): Likewise.
	* linux-nat.c (linux_nat_find_memory_regions): Likewise.
	* procfs.c (iterate_over_mappings_cb_ftype): Remove.
	(iterate_over_mappings): Rename iterate_over_mappings_cb_ftype to
	find_memory_region_ftype.
	(insert_dbx_link_bpt_in_region): Likewise.
	(iterate_over_mappings): Likewise.  Drop the comment part about the
	function prototype.
	(find_memory_regions_callback): Use find_memory_region_ftype.
	(proc_find_memory_regions): Likewise.
	(info_mappings_callback): Rename iterate_over_mappings_cb_ftype to
	find_memory_region_ftype.
	* target.c (dummy_find_memory_regions): Use find_memory_region_ftype.
	* target.h (struct target_ops) <to_find_memory_regions>: Likewise.
@
text
@d3 1
a3 1
   2008, 2009, 2010 Free Software Foundation, Inc.
@


1.72
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* gcore.c: White space.
	* gdb.c: White space.
	* gdbtypes.c: White space.
	* gnu-nat.c: White space.
	* gnu-v2-abi.c: White space.
	* gnu-v3-abi.c: White space.
@
text
@d2490 1
a2490 5
gnu_find_memory_regions (int (*func) (CORE_ADDR,
				      unsigned long,
				      int, int, int,
				      void *),
			 void *data)
@


1.71
log
@gdb/
	* defs.h (parse_pid_to_attach): New.
	* utils.c (parse_pid_to_attach): New.
	* darwin-nat.c (darwin_attach): Replace ARGS parsing by parse_pid.
	* gnu-nat.c (gnu_attach): Likewise.
	* nto-procfs.c (procfs_attach): Likewise.
	* procfs.c (procfs_attach): Likewise.
	* windows-nat.c (windows_attach): Likewise.
	* inf-ptrace.c (inf_ptrace_attach): Likewise.  Remove variable dummy.
	* inf-ttrace.c (inf_ttrace_attach): Likewise.
	* remote.c (extended_remote_attach_1): Likewise.  New comment on getpid
	check.

gdb/testsuite/
	* gdb.base/attach.exp (attach to nonsense is prohibited): Make the
	"Illegal process-id" expect string more exact.
	(attach to digits-starting nonsense is prohibited): New.
@
text
@d376 3
a378 2
      thread_get_state (proc->port, THREAD_STATE_FLAVOR,
			(thread_state_t) &proc->state, &state_size);
d753 1
d801 2
a802 2
  proc_getprocinfo (proc_server, inf->pid, &info_flags,
		    (procinfo_t *) &pi, &pi_len, &noise, &noise_len);
d888 1
d915 1
a918 1

d980 1
d1007 1
d1125 1
d1334 1
d1345 1
d1771 1
d1941 1
a1941 1
  mach_port_get_receive_status (mach_task_self (), port, &status);
d2017 1
d2046 1
d2217 1
d2575 1
d2596 1
d2680 1
d2726 1
d2751 1
d2778 1
d2788 1
d2799 1
d2808 1
d2870 1
d2886 1
d2906 1
d2918 1
d2944 1
d2969 1
d3039 3
a3041 2
	  print_port_info (right, 0, inf->task->port, PORTINFO_DETAILS,
			   stdout);
d3050 2
a3051 2
      print_task_ports_info (inf->task->port, only, PORTINFO_DETAILS,
			     stdout);
d3224 1
d3237 1
d3249 1
d3257 1
d3275 1
d3287 1
d3298 1
d3311 1
@


1.70
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d2142 1
a2142 4
  if (!args)
    error_no_arg (_("process-id to attach"));

  pid = atoi (args);
d2144 1
a2144 1
  if (pid == getpid ())		/* Trying to masturbate? */
@


1.69
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d3 1
a3 1
   2008, 2009 Free Software Foundation, Inc.
@


1.68
log
@2009-07-30  Thomas Schwinge  <tschwinge@@gnu.org>

	* gnu-nat.c (add_task_commands) <stopped>: Register the correct
	callback function.
@
text
@d2169 2
a2170 1
  inferior = add_inferior (pid);
@


1.67
log
@	* gnu-nat.c: Include "inf-child.h".
	(gnu_mourn_inferior): Use the passed in target_ops
	instead of the gnu_ops global.
	(gnu_create_inferior): Inline `attach_to_child', use the passed in
	target_ops instead of the gnu_ops global.
	(gnu_can_run): Delete.
	(gnu_attach): Use the passed in target_ops instead of the gnu_ops
	global.
	(gnu_detach): Ditto.
	(gnu_prepare_to_store, gnu_open): Delete.
	(gnu_store_registers, gnu_fetch_registers): Delete declarations.
	(gnu_ops): Delete.
	(init_gnu_ops): Delete.
	(gnu_target): New.
	(_initialize_gnu_nat): Don't call init_gnu_ops or add_target here.
	* gnu-nat.h (gnu_target): Declare.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Make
	static.
	(_initialize_i386gnu_nat): New.
@
text
@d3115 1
a3115 1
  add_cmd ("stopped", no_class, show_signals_cmd, _("\
@


1.66
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d69 1
a90 2
extern struct target_ops gnu_ops;

d2051 1
a2051 1
  unpush_target (&gnu_ops);
d2084 1
a2092 4
  void attach_to_child (int pid)
  {
    /* Attach to the now stopped child, which is actually a shell...  */
    inf_debug (inf, "attaching to child: %d", pid);
d2094 3
a2096 1
    inf_attach (inf, pid);
d2098 2
a2099 1
    push_target (&gnu_ops);
d2101 1
a2101 3
    inf->pending_execs = 2;
    inf->nomsg = 1;
    inf->traced = 1;
d2103 1
a2103 3
    /* Now let the child run again, knowing that it will stop immediately
       because of the ptrace. */
    inf_resume (inf);
d2105 3
a2107 3
    /* We now have thread info.  */
    thread_change_ptid (inferior_ptid,
			ptid_build (inf->pid, 0, inf_pick_first_thread ()));
d2109 3
a2111 2
    startup_inferior (inf->pending_execs);
  }
d2113 3
a2115 1
  inf_debug (inf, "creating inferior");
d2117 1
a2117 2
  fork_inferior (exec_file, allargs, env, trace_me, attach_to_child,
		 NULL, NULL);
a2130 8
/* Mark our target-struct as eligible for stray "run" and "attach"
   commands.  */
static int
gnu_can_run (void)
{
  return 1;
}

d2167 1
a2167 1
  push_target (&gnu_ops);
d2223 1
a2223 1
  unpush_target (&gnu_ops);	/* Pop out of handling an inferior */
a2232 16
/* Get ready to modify the registers array.  On machines which store
   individual registers, this doesn't need to do anything.  On machines
   which store all the registers in one fell swoop, this makes sure
   that registers contains all the registers from the program being
   debugged.  */
static void
gnu_prepare_to_store (struct regcache *regcache)
{
}

static void
gnu_open (char *arg, int from_tty)
{
  error (_("Use the \"run\" command to start a Unix child process."));
}

d2591 29
a2619 47
extern void gnu_store_registers (struct target_ops *ops,
				 struct regcache *regcache, int regno);
extern void gnu_fetch_registers (struct target_ops *ops,
				 struct regcache *regcache, int regno);

struct target_ops gnu_ops;

static void
init_gnu_ops (void)
{
  gnu_ops.to_shortname = "GNU";		/* to_shortname */
  gnu_ops.to_longname = "GNU Hurd process"; /* to_longname */
  gnu_ops.to_doc = "GNU Hurd process";	/* to_doc */
  gnu_ops.to_open = gnu_open;		/* to_open */
  gnu_ops.to_attach = gnu_attach;	/* to_attach */
  gnu_ops.to_attach_no_wait = 1;	/* to_attach_no_wait */
  gnu_ops.to_detach = gnu_detach;	/* to_detach */
  gnu_ops.to_resume = gnu_resume;	/* to_resume */
  gnu_ops.to_wait = gnu_wait;		/* to_wait */
  gnu_ops.to_fetch_registers = gnu_fetch_registers;    /* to_fetch_registers */
  gnu_ops.to_store_registers = gnu_store_registers;    /* to_store_registers */
  gnu_ops.to_prepare_to_store = gnu_prepare_to_store; /* to_prepare_to_store */
  gnu_ops.deprecated_xfer_memory = gnu_xfer_memory;
  gnu_ops.to_find_memory_regions = gnu_find_memory_regions;
  gnu_ops.to_insert_breakpoint = memory_insert_breakpoint;
  gnu_ops.to_remove_breakpoint = memory_remove_breakpoint;
  gnu_ops.to_terminal_init = gnu_terminal_init_inferior;
  gnu_ops.to_terminal_inferior = terminal_inferior;
  gnu_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  gnu_ops.to_terminal_save_ours = terminal_save_ours;
  gnu_ops.to_terminal_ours = terminal_ours;
  gnu_ops.to_terminal_info = child_terminal_info;
  gnu_ops.to_kill = gnu_kill_inferior;	/* to_kill */
  gnu_ops.to_create_inferior = gnu_create_inferior; /* to_create_inferior */
  gnu_ops.to_mourn_inferior = gnu_mourn_inferior;	/* to_mourn_inferior */
  gnu_ops.to_can_run = gnu_can_run;	/* to_can_run */
  gnu_ops.to_thread_alive = gnu_thread_alive;	/* to_thread_alive */
  gnu_ops.to_pid_to_str = gnu_pid_to_str;   /* to_pid_to_str */
  gnu_ops.to_stop = gnu_stop;	/* to_stop */
  gnu_ops.to_stratum = process_stratum;		/* to_stratum */
  gnu_ops.to_has_all_memory = default_child_has_all_memory;
  gnu_ops.to_has_memory = default_child_has_memory;
  gnu_ops.to_has_stack = default_child_has_stack;
  gnu_ops.to_has_registers = default_child_has_registers;
  gnu_ops.to_has_execution = default_child_has_execution;
  gnu_ops.to_magic = OPS_MAGIC;		/* to_magic */
}				/* init_gnu_ops */
a3362 3
  
  init_gnu_ops ();
  add_target (&gnu_ops);
@


1.65
log
@	* target.h (struct target_ops): Make to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	methods instead of variables.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1)
	(target_has_registers_1, target_has_execution_1): Declare
	functions.
	(target_has_all_memory): Rewrite to call target_has_all_memory_1.
	(target_has_memory): Rewrite to call target_has_memory_1.
	(target_has_stack): Rewrite to call target_has_all_stack_1.
	(target_has_registers): Rewrite to call target_has_registers_1.
	(target_has_execution): Rewrite to call target_has_execution_1.
	(default_child_has_all_memory, default_child_has_memory)
	(default_child_has_stack, default_child_has_registers)
	(default_child_has_execution): Declare.
	(target_mark_running, target_mark_exited): Delete declarations.
	* target.c (default_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution): New.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1,
	target_has_registers_1, target_has_execution_1): New.
	(add_target): Default the to_has_all_memory, to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	callbacks to return 0.
	(update_current_target): Do not inherit to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers or to_has_execution.
	(target_mark_running, target_mark_exited): Delete.
	(memory_xfer_partial): Adjust.
	(target_read_memory, target_write_memory, target_search_memory):
	Dispatch to the the top-most target, not the flattened
	current_target.
	(target_info): Adjust.
	(init_dummy_target): Install return_zero as callback for
	to_has_all_memory, to_has_memory, to_has_stack, to_has_registers,
	to_has_execution.
	(set_maintenance_target_async_permitted): Use have_live_inferiors
	instead of target_has_execution.
	* target-memory.c (target_write_memory_blocks): Dispatch memory
	writes to the the top-most target, not the flattened
	current_target.

	* breakpoint.c (insert_breakpoints): Don't check for
	target_has_execution here.
	(update_global_location_list): Check if there are live inferiors
	to debug instead of target_has_execution.
	* infcmd.c (kill_command, detach_command): Check if there are
	inferiors instead of target_has_execution.
	* inferior.h (have_live_inferiors): Declare.
	* inferior.c (have_live_inferiors): New.
	* infrun.c (normal_stop): Don't check for target_has_execution to
	finish the thread states.
	* thread.c (is_thread_state, is_stopped, is_exited, is_running)
	(any_running, is_executing): Remove checks for
	target_has_execution.
	* top.c (kill_or_detach): Don't try to kill core inferiors.
	(quit_target): Don't check for target_has_execution.

	* corelow.c (core_has_memory, core_has_stack, core_has_registers):
	New.
	(init_core_ops): Install core_has_memory, core_has_stack and
	core_has_registers.
	* exec.c (exec_has_memory): New.
	(init_exec_ops): Install exec_has_memory.
	* remote.c (remote_add_inferior): Don't call target_mark_running.
	(remote_start_remote): Don't call target_mark_exited or call
	target_mark_running.
	(remote_open_1): Use have_inferiors instead of
	target_has_execution.  Don't use target_mark_exited.
	(init_remote_ops): Install deafult_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution.
	* bsd-kvm.c (bsd_kvm_return_one): New.
	(bsd_kvm_add_target): Register bsd_kvm_return_one as
	to_has_memory, to_has_stack and to_has_registers callbacks.
	* remote-m32r-sdi.c (m32r_return_one): New.
	(init_m32r_ops): Register it.
	* inf-child.c (inf_child_target): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.
	* gnu-nat.c (init_gnu_ops): Likewise.
	* go32-nat.c (init_go32_ops): Likewise.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* monitor.c (init_base_monitor_ops): Likewise.
	* nto-procfs.c (init_procfs_ops): Likewise.
	* remote-mips.c (_initialize_remote_mips): Likewise.
	* windows-nat.c (init_windows_ops): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Don't use
	target_mark_running or target_mark_exited.
	(gdbsim_mourn_inferior): Don't call target_mark_exited.
	(init_gdbsim_ops): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.

	* linux-nat.c (linux_nat_xfer_partial): If reading memory, and
	there's no inferior selected, defer to a lower stratum.
@
text
@d2495 2
a2496 1
		 write ? "writing" : "reading", paddr (memaddr), len,
@


1.64
log
@	* target.h (TARGET_WNOHANG): New.
	* target.c (target_wait): Add `options' argument.  Adjust.
	(struct target_ops) <to_wait>: Add `options' argument.
	(target_wait): Add `options' argument.
	* infrun.c (wait_for_inferior): Pass 0 as options to
	target_wait (blocking wait).
	(fetch_inferior_event): Pass TARGET_WNOHANG as options to
	target_wait.
	* fork-child.c (startup_inferior): Pass 0 as options to
	target_wait (blocking wait).
	* linux-nat.c (linux_nat_create_inferior): Remove async masking.
	(linux_nat_wait_1): Add `target_options' argument.  Use it instead
	of checking on target_can_async_p.
	(linux_nat_wait): Add `target_options' argument.  Adjust.
	* remote.c (remote_wait_ns): Add `options' argument.  Adjust to
	check on TARGET_WNOWAIT instead of checking on remote_is_async_p.
	(remote_wait_as): Add `options' argument.  Adjust to check on
	TARGET_WNOWAIT instead of checking on remote_is_async_p.  If doing
	a blocking wait, keep waiting until an interesting event comes
	out.
	(remote_wait): Add `options' argument.  Don't loop here if the
	target is in async mode, and a blocking wait has been requested.

	* top.c (deprecated_target_wait_hook): Add `options' argument.
	* linux-thread-db.c (thread_db_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ptrace.c (inf_ptrace_wait): Add `options' argument.
	* record.c (record_beneath_to_wait): Add `options' argument.
	(record_wait): Add `options' argument, and pass it down to the
	layer beneath.
	* bsd-uthread.c (bsd_uthread_wait): Add `options' argument.
	* darwin-nat.c (darwin_wait): Likewise.
	* defs.h (deprecated_target_wait_hook): Likewise.
	* gnu-nat.c (gnu_wait): Add `options' argument.
	* go32-nat.c (go32_wait): Likewise.
	* hpux-thread.c (hpux_thread_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ttrace.c (inf_ttrace_wait): Add `options' argument.
	* monitor.c (monitor_wait): Likewise.
	* nto-procfs.c (procfs_wait): Likewise.
	* remote-mips.c (mips_wait): Add `options' argument.
	* remote-sim.c (gdbsim_wait): Likewise.
	* rs6000-nat.c (rs6000_wait): Add `options' argument.
	* sol-thread.c (sol_thread_wait): Add `options' argument, and pass
	it down to the layer beneath.
	* spu-linux-nat.c (spu_child_wait): Add `options' argument.
	* windows-nat.c (windows_wait): Likewise.
	* tui/tui-hooks.c (tui_target_wait_hook): Likewise.  Adjust.
@
text
@d2657 5
a2661 5
  gnu_ops.to_has_all_memory = 1;	/* to_has_all_memory */
  gnu_ops.to_has_memory = 1;		/* to_has_memory */
  gnu_ops.to_has_stack = 1;		/* to_has_stack */
  gnu_ops.to_has_registers = 1;		/* to_has_registers */
  gnu_ops.to_has_execution = 1;		/* to_has_execution */
@


1.63
log
@gdb/
2009-05-12  Pedro Alves  <pedro@@codesourcery.com>

	* cli/cli-decode.c (deprecated_add_set_cmd): Delete.
	* command.h (deprecated_add_set_cmd): Delete declaration.
	* gnu-nat.c (_initialize_gnu_nat): Replace 'maint gnu-debug' with
	'set debug gnu-nat' and 'show debug gnu-nat'.
	* i386-nat.c (_initialize_i386_nat): Replace 'maint
	show-debug-registers' with 'maint set show-debug-registers' and
	'maint show show-debug-registers'.
	* mips-linux-nat.c (_initialize_mips_linux_nat): Replace 'maint
	show-debug-registers' with 'maint set show-debug-registers' and
	'maint show show-debug-registers'.

gdb/doc/
2009-05-12  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo: Document 'set/show debug gnu-nat'.  Replace 'maint
	show-debug-regs' docs by 'maint set show-debug-regs' and 'maint
	show show-debug-regs' docs.
@
text
@d1438 1
a1438 1
	  ptid_t ptid, struct target_waitstatus *status)
@


1.62
log
@	ARI fix: Do not use %p, replace by call to host_address_to_string
	for host pointers.
	* darwin-nat.c (darwin_xfer_partial): Apply change.
	* gnu-nat.c (inf_continue, gnu_xfer_memory): Ditto.
	* gnu-nat.h (proc_debug): Ditto.
	* symmisc.c (maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* windows-nat.c (handle_load_dll): Ditto.
	(handle_unload_dll, info_w32_command, handle_exception): Ditto.
	* xtensa-tdep.c (xtensa_unwind_pc): Ditto.
@
text
@d3413 9
a3421 4
  deprecated_add_set_cmd ("gnu-debug", class_maintenance,
			  var_boolean, (char *) &gnu_debug_flag,
			  "Set debugging output for the gnu backend.",
			  &maintenancelist);
@


1.61
log
@        Add a target_ops parameter to the to_kill method in struct target_ops.

        * target.h (struct target_ops): Add a "target_ops *" parameter to
        method to_kill.
        (target_kill): Remove macro. Add declaration.
        * target.c (debug_to_kill): Delete, no longer necessary.
        (target_kill): New function.
        (update_current_target):  Stop inheriting the to_kill method.
        Do not de_fault it to no_process either.
        (setup_target_debug): Do not set current_target.to_kill.
        * gnu-nat.c, go32-nat.c, hpux-thread.c, inf-ptrace.c, inf-ttrace.c,
        linux-nat.c, monitor.c, nto-procfs.c, procfs.c, remote-m32r-sdi.c,
        remote-mips.c, remote-sim.c, remote.c, windows-nat.c: Update
        accordingly.
@
text
@d116 2
a117 1
       debug ("{inf %d %p}: " msg, __inf->pid, __inf , ##args); } while (0)
d2494 3
a2496 3
      inf_debug (gnu_current_inf, "%s %p[%d] %s %p",
		 write ? "writing" : "reading", (void *) memaddr, len,
		 write ? "<--" : "-->", myaddr);
@


1.60
log
@2009-02-25  Hui Zhu  <teawater@@gmail.com>

	* cli/cli-script.c (define_command): Add _() to query.
	* gnu-nat.c (inf_validate_task_sc): Ditto.
	* infcmd.c (kill_if_already_running): Ditto.
	(jump_command): Ditto.
	(attach_command): Ditto.
	* inflow.c (kill_command): Ditto.
	* infrun.c (handle_command): Ditto.
	* maint.c (maintenance_dump_me): Ditto.
	* memattr.c (mem_delete_command): Ditto.
	* monitor.c (monitor_interrupt_query): Ditto.
	* nto-procfs.c (interrupt_query): Ditto.
	* printcmd.c (undisplay_command): Ditto.
	* remote-mips.c (mips_kill): Ditto.
	* remote.c (interrupt_query): Ditto.
	* solib-irix.c (irix_open_symbol_file_object): Ditto.
	* solib-osf.c (osf_open_symbol_file_object): Ditto.
	* solib-pa64.c (pa64_open_symbol_file_object): Ditto.
	* solib-som.c (som_open_symbol_file_object): Ditto.
	* solib-svr4.c (open_symbol_file_object): Ditto.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Ditto.
	* target.c (kill_or_be_killed): Ditto.
	* tracepoint.c (delete_trace_command): Ditto.
	* top.c (quit_confirm): Add _() to s that will be used
	in query.
@
text
@d2033 1
a2033 1
gnu_kill_inferior (void)
@


1.59
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d857 2
a858 2
      abort = !query ("Pid %d has an additional task suspend count of %d;"
		      " clear it? ", inf->pid,
@


1.58
log
@	* linux-nat.c (linux_nat_wait): Adjust.
	(linux_nat_pid_to_str): Adjust.  Remove call to thread_db_init.
	* linux-nat.h (thread_db_init): Delete declaration.
	* linux-thread-db.c (target_beneath): Delete.
	(thread_db_init): Delete.
	(thread_db_detach): Use find_target_beneath.
	(thread_db_wait): Adjust interface.  Use find_target_beneath.
	(thread_db_mourn_inferior): Use find_target_beneath.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): Delete.
	(thread_db_pid_to_str): Adjust interface.  Use
	find_target_beneath.
	(thread_db_get_thread_local_address): Adjust interface.  Use
	find_target_beneath.
	(init_thread_db_ops): Delete references to delete functions.
	* target.c (update_current_target): Don't inherit or default
	to_wait.  Don't inherit to_pid_to_str and
	to_get_thread_local_address.
	(target_translate_tls_address): Look for a pushed target that
	implements to_get_thread_local_address, and use it instead of
	checking for target_get_thread_local_address_p.
	(target_wait, target_pid_to_str): Reimplement as functions.
	(dummy_pid_to_str): New.
	(init_dummy_target): Register it.
	(debug_to_wait): Delete.
	* target.h (struct target_ops): Make to_wait, to_pid_to_str and
	to_get_thread_local_address accept a pointer to struct target_ops.
	(target_wait): Delete macro, and declare as function.
	(target_pid_to_str): Likewise.
	(target_get_thread_local_address)
	(target_get_thread_local_address_p): Delete.
	(noprocess): Add NORETURN and ATTR_NORETURN tags.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	(inf_ptrace_pid_to_str): New.
	(inf_ptrace_target): Use inf_ptrace_pid_to_str.
	* aix-thread.c (aix_thread_wait, aix_thread_pid_to_str): Adjust.
	* bsd-kvm.c (bsd_kvm_pid_to_str): Adjust.
	* bsd-uthread.c (bsd_uthread_wait, bsd_uthread_pid_to_str):
	Adjust.
	* corelow.c (core_pid_to_str): Adjust.
	* darwin-nat.c (darwin_wait, darwin_pid_to_str): Adjust.
	* dec-thread.c (dec_thread_wait, dec_thread_pid_to_str): Adjust.
	* gnu-nat.c (gnu_wait, gnu_pid_to_str): Adjust.
	* go32-nat.c (go32_wait, go32_pid_to_str): Adjust.
	* hpux-thread.c (hpux_thread_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait, inf_ttrace_pid_to_str): Adjust.
	* monitor.c (monitor_wait, monitor_pid_to_str): Adjust.
	* nto-procfs.c (procfs_wait, procfs_pid_to_str): Adjust.
	* procfs.c (procfs_pid_to_str): Adjust.
	* remote-m32r-sdi.c (m32r_wait, m32r_pid_to_str): Adjust.
	* remote-mips.c (mips_wait): Adjust.
	* remote-sim.c (gdbsim_wait, gdbsim_pid_to_str): Adjust.
	* remote.c (remote_wait, remote_pid_to_str)
	(remote_get_thread_local_address): Adjust.
	* rs6000-nat.c (rs6000_wait): Adjust.
	* sol-thread.c (procfs_pid_to_str): Adjust declaration.
	(sol_thread_wait, solaris_pid_to_str): Adjust.
	* spu-linux-nat.c (spu_child_wait): Adjust.
	* windows-nat.c (windows_wait, windows_pid_to_str): Adjust.
@
text
@d1958 2
a1959 1
gnu_resume (ptid_t ptid, int step, enum target_signal sig)
d2266 1
a2266 1
gnu_thread_alive (ptid_t ptid)
d2616 4
a2619 2
extern void gnu_store_registers (struct regcache *regcache, int regno);
extern void gnu_fetch_registers (struct regcache *regcache, int regno);
@


1.57
log
@        Updated copyright notices for most files.
@
text
@d1436 2
a1437 1
gnu_wait (ptid_t ptid, struct target_waitstatus *status)
d2598 1
a2598 1
gnu_pid_to_str (ptid_t ptid)
@


1.56
log
@	Kill pthread_ops_hack

	* target.h (struct target_ops): Make to_attach, to_detach,
	to_create_inferior and to_mourn_inferior accept a pointer
    	to struct target_ops.
	(target_attach, target_create_inferior, target_create_inferior):
	Convert from macros to function.  Find the right target to
	invoke a method of.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.
	* corefile.c (core_file_command): Pass target to to_detach.
	* corelow.c (core_detach): Add 'ops' parameter.
	* fork-child.c (fork_inferior): Return the pid.  Allow
	init_trace_fun to be NULL.
	* inf-ptrace (ptrace_ops_hack): Remove.
	(inf_ptrace_him): Remove, moving all logic into....
	(inf_ptrace_create_inferior): ... here.  Push the target
	passed as parameter.
	(inf_ptrace_mourn_inferior, inf_ptrace_attach, inf_ptrace_detach):
	Push/pop target passed as parameter, no ptrace_ops_hack.
	(inf_ptrace_target): Don't remember result.
	* inferior.h (fork_inferior): Adjust prototype.
	* linux-nat.c (linux_nat_create_inferior, linux_nat_attach)
	(linux_nat_detach, linux_nat_mourn_inferior): New parameter ops.
	Pass it to linux_ops target.
	* linux-thread-db.c (thread_db_detach, thread_db_mourn_inferior):
	New parameter ops. Pass it to the target beneath.
	* remote.c (remote_mourn, extended_remote_mourn, remote_detach)
	(extended_remote_create_inferior): New parameter ops. Pass it
	further.
	* target.c (debug_to_attach, debug_to_detach)
	(debug_to_mourn_inferior): New parameter ops.
	(target_create_inferior): New.
	(update_current_target): Do not inherit to_attach, to_detach,
	to_create_inferiour, to_mourn_inferior.  Do not default
	to_detach and to_mourn_inferior.
	(target_detach): Find the right target to use.
	(target_mourn_inferior): New.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.  Pass the found target when calling its method.
	(init_dummy_target): Provide fallback definition of to_detach.
	(target_attach): New.
	(debug_to_attach, debug_to_detach, debug_to_create_inferior)
	(debug_to_mourn_inferiour): New parameter ops.
        * aix-thread.c: Adjust.
        * bsd-uthread.c: Adjust.
        * gnu-nat.c: Adjust.
        * go32-nat.c: Adjust.
        * hpux-thread.c: Adjust.
        * inf-ttrace.c: Ajust.
        * monitor.c: Adjust.
        * nto-procfs.c: Adjust.
        * procfs.c: Adjust.
        * remote-m32r-sdi.c: Adjust.
        * remote-mips.c: Adjust.
        * remote-sim.c: Adjust.
        * rs6000-nat.c: Adjust.
        * sol-thread.c: Adjust.
        * win32-nat.c: Adjust.
	* dec-thread.c: Adjust.
@
text
@d3 1
a3 1
   2008 Free Software Foundation, Inc.
@


1.55
log
@	* gnu-nat.h: Rename `current_inferior' to `gnu_current_inf' to
	avoid a name collision.
	* gnu-nat.c: Likewise.
	* i386gnu-nat.c: Likewise.
@
text
@d2045 1
a2045 1
gnu_mourn_inferior (void)
d2077 2
a2078 1
gnu_create_inferior (char *exec_file, char *allargs, char **env,
d2143 1
a2143 1
gnu_attach (char *args, int from_tty)
d2209 1
a2209 1
gnu_detach (char *args, int from_tty)
@


1.54
log
@	Remove the attach_flag global, and make it per-inferior.

	* inferior.h (attach_flag): Delete.
	(inferior_process): Declare.
	* solib.c (update_solib_list): Adjust.
	* gnu-nat.c (gnu_create_inferior, gnu_attach): Adjust.
	* inf-ptrace.c (inf_ptrace_detach): Adjust.
	(inf_ptrace_files_info): Get it from the current inferior.
	* inf-ttrace.c (inf_ttrace_attach): Adjust.
	(inf_ttrace_files_info): Get it from the current
	inferior.
	* inflow.c (terminal_inferior, terminal_ours_1, set_sigint_trap)
	(clear_sigint_trap): Get it from the current process.
	* remote.c (extended_remote_attach_1)
	(extended_remote_create_inferior_1): Adjust.
	* top.c (quit_confirm, quit_target): Get it from the current inferior.
	* procfs.c (do_detach): Adjust.
	(procfs_wait): Get it from the event inferior.
	(procfs_files_info): Get it from the current inferior.
	* nto-procfs.c (procfs_files_info): Likewise.
	(procfs_attach): Adjust.  Set the attach_flag here.
	(do_attach): Don't set it here.
	(procfs_detach): Don't clear it.
	(procfs_mourn_inferior): Don't clear it.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* target.c (attach_flag): Delete.
	(generic_mourn_inferior): Don't clear it.
	* win32-nat.c (get_win32_debug_event): Get it from the event
	process.
	(do_initial_win32_stuff): Add attaching argument.  Set attach_flag
	in the inferior accordingly.
	(win32_attach): Don't set the attach_flag here.  Pass 1 to
	do_intial_win32_stuff.
	(win32_files_info): Get it from the current inferior.
	(win32_create_inferior): Dont clear attach_flag here.  Pass 0 to
	do_intial_win32_stuff.
@
text
@d1428 1
a1428 1
struct inf *current_inferior = 0;
d1446 1
a1446 1
  struct inf *inf = current_inferior;
d1961 1
a1961 1
  struct inf *inf = current_inferior;
d2033 1
a2033 1
  struct proc *task = current_inferior->task;
d2038 1
a2038 1
      inf_set_pid (current_inferior, -1);
d2047 2
a2048 2
  inf_debug (current_inferior, "rip");
  inf_detach (current_inferior);
d2060 1
a2060 1
  if (current_inferior->task && current_inferior->threads)
d2062 1
a2062 1
    return current_inferior->threads->tid;
d2071 3
a2073 3
  if (!current_inferior)
    current_inferior = make_inf ();
  return current_inferior;
d2217 1
a2217 1
			   exec_file, current_inferior->pid);
d2219 1
a2219 1
	printf_unfiltered ("Detaching from pid %d\n", current_inferior->pid);
d2223 1
a2223 1
  pid = current_inferior->pid;
d2225 1
a2225 1
  inf_detach (current_inferior);
d2236 2
a2237 2
  gdb_assert (current_inferior);
  terminal_init_inferior_with_pgrp (current_inferior->pid);
d2265 2
a2266 2
  inf_update_procs (current_inferior);
  return !!inf_tid_to_thread (current_inferior,
d2481 3
a2483 3
  task_t task = (current_inferior
		 ? (current_inferior->task
		    ? current_inferior->task->port : 0)
d2490 1
a2490 1
      inf_debug (current_inferior, "%s %p[%d] %s %p",
d2513 1
a2513 1
  if (current_inferior == 0 || current_inferior->task == 0)
d2515 1
a2515 1
  task = current_inferior->task->port;
d2598 1
a2598 1
  struct inf *inf = current_inferior;
d3426 1
a3426 1
  ret = vm_machine_attribute (current_inferior->task->port,
@


1.53
log
@	* gnu-nat.c (gnu_attach): Add process to inferiors table.
	(gnu_detach): Remove it.
	* go32-nat.c (go32_create_inferior): Add process to gdb's inferior
	table.
	* inf-ptrace.c (inf_ptrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ptrace_attach): Add new process to inferior table.
	(inf_ptrace_detach): Remove it.
	* inf-ttrace.c (inf_ttrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ttrace_attach): Add process to inferior table.
	(inf_ttrace_detach): Remove it.
	* linux-fork.c (init_fork_list): Delete any left over inferior.
	(linux_fork_mourn_inferior, detach_fork_command): Also delete
	processes from inferior list.
	* monitor.c (monitor_open): Add process to inferior list.
	(monitor_close): Remove it.
	* nto-procfs.c (procfs_attach): Add process to inferior list.
	Find threads after pushing the target.
	(procfs_detach): Remove process from inferior list.
	(procfs_create_inferior): Add process to inferior list.
	* procfs.c (procfs_detach): Remove process from inferior list.
	(do_attach): Add process to inferior list.
	* remote-sim.c (sim_create_inferior): Add process to inferior list.
	(gdbsim_close): Remove it.
	* target.c (generic_mourn_inferior): If inferior_ptid is not
	null_ptid, remove the corresponding inferior from inferior list.
	* win32-nat.c (do_initial_win32_stuff): Add process to inferior list.
	(win32_detach): Remove it.
	* linux-nat.c (linux_child_follow_fork): Delete and add inferiors
	to inferior list accordingly.
	* fork-child.c (fork_inferior): Add process to inferior list.
	* corelow.c (CORELOW_PID): Define.
	(core_close): Remove core from inferior list.
	(core_open): Add it.
@
text
@a2095 1
    attach_flag = 0;
d2147 1
d2176 2
a2177 1
  add_inferior (pid);
a2182 2
  attach_flag = 1;

@


1.52
log
@	* gnu-nat.c (gnu_pid_to_exec_file): Delete.
	(init_gnu_ops): Don't register it.
@
text
@d2176 2
d2211 2
d2224 2
d2229 1
@


1.51
log
@	* gnu-nat.c (gnu_attach): Push target before fetching the list of
	threads.
@
text
@a2255 8
static char *
gnu_pid_to_exec_file (int pid)
{
  error (_("to_pid_to_exec_file target function not implemented"));
  return NULL;
}


a2643 1
  gnu_ops.to_pid_to_exec_file = gnu_pid_to_exec_file; /* to_pid_to_exec_file */
@


1.50
log
@	Use ptid_t.tid to store thread ids instead of ptid_t.pid.

	* gnu-nat.c (inf_validate_procs): If this is the first time we're
	seeing a thread id, extend the main thread's ptid.  If we still
	have pending execs, don't be verbose about new threads.
	(gnu_wait, gnu_resume, gnu_attach, gnu_thread_alive)
	(gnu_pid_to_str, cur_thread, sig_thread_cmd): Adjust.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers):
	Adjust.
@
text
@d2173 3
a2180 1
  push_target (&gnu_ops);
@


1.49
log
@	Adjust all targets to new target_stop interface.

	* gnu-nat.c (gnu_stop): Add ptid argument.
	* go32-nat.c (go32_stop): Add ptid argument.
	(go32_create_inferior): Pass inferior_ptid to go32_stop.
	* hpux-thread.c (hpux_thread_stop): Add ptid argument.
	* monitor.c (monitor_stop): Add ptid argument.
	(monitor_open): Pass inferior_ptid to monitor_stop.
	(monitor_interrupt): Pass inferior_ptid to target_stop.
	(monitor_stop): Add ptid argument.
	* nto-procfs.c (nto_interrupt): Pass inferior_ptid to target_stop.
	(procfs_create_inferior): Add ptid argument.
	* procfs.c (procfs_stop): Add ptid argument.
	* remote-m32r-sdi.c (m32r_stop): Add ptid argument.
	* remote-sim.c (gdbsim_stop): Add ptid argument.
	* sol-thread.c (sol_thread_stop): Add ptid argument.
	* win32-nat.c (win32_stop): Add ptid argument.
@
text
@d1069 2
d1078 14
a1091 1
	    add_thread (pid_to_ptid (thread->tid));	/* Tell GDB's generic thread code.  */
d1436 1
a1436 1
gnu_wait (ptid_t tid, struct target_waitstatus *status)
d1467 1
a1467 1
  inf_debug (inf, "waiting for: %d", PIDGET (tid));
d1603 3
a1605 1
    tid = pid_to_ptid (thread->tid);
d1607 1
a1607 1
    thread = inf_tid_to_thread (inf, PIDGET (tid));
d1613 1
a1613 1
	tid = pid_to_ptid (inf->threads->tid); /* The first available thread.  */
d1615 1
a1615 1
	tid = inferior_ptid;	/* let wait_for_inferior handle exit case */
d1618 3
a1620 1
  if (thread && PIDGET (tid) >= 0 && status->kind != TARGET_WAITKIND_SPURIOUS
d1629 2
a1630 1
  inf_debug (inf, "returning tid = %d, status = %s (%d)", PIDGET (tid),
d1639 1
a1639 1
  return tid;
d1957 1
a1957 1
gnu_resume (ptid_t tid, int step, enum target_signal sig)
d1960 1
d1963 2
a1964 1
  inf_debug (inf, "tid = %d, step = %d, sig = %d", PIDGET (tid), step, sig);
d1992 4
a1995 1
  if (PIDGET (tid) < 0)
d1999 1
a1999 1
      tid = inferior_ptid;	/* What to step. */
d2005 1
a2005 1
      struct proc *thread = inf_tid_to_thread (inf, PIDGET (tid));
d2007 3
a2009 2
	error (_("Can't run single thread id %d: no such thread!"), inf->pid);
      inf_debug (inf, "running one thread: %d/%d", inf->pid, thread->tid);
d2015 1
a2015 1
      step_thread = inf_tid_to_thread (inf, PIDGET (tid));
d2017 2
a2018 1
	warning (_("Can't step thread id %d: no such thread."), PIDGET (tid));
d2020 1
a2020 1
	inf_debug (inf, "stepping thread: %d/%d", inf->pid, step_thread->tid);
d2106 4
a2109 1
    inferior_ptid = pid_to_ptid (inf_pick_first_thread ());
d2175 1
a2175 1
  inferior_ptid = pid_to_ptid (inf_pick_first_thread ());
d2263 1
a2263 1
gnu_thread_alive (ptid_t tid)
d2266 2
a2267 1
  return !!inf_tid_to_thread (current_inferior, PIDGET (tid));
d2591 1
a2591 1
	     proc->inf->pid, pid_to_thread_id (MERGEPID (proc->tid, 0)));
d2599 1
a2599 1
  int tid = PIDGET (ptid);
d2740 2
a2741 1
  struct proc *thread = inf_tid_to_thread (inf, PIDGET (inferior_ptid));
d2923 1
a2923 1
      int tid = PIDGET (thread_id_to_pid (atoi (args)));
@


1.48
log
@	* config/i386/nm-cygwin.h (ATTACH_NO_WAIT): Delete.
	* config/i386/nm-i386gnu.h (ATTACH_NO_WAIT): Delete.

	* target.h (struct target_ops): Add to_attach_no_wait member.
	(target_attach_no_wait): New.
	* target.c (update_current_target): Inherit to_attach_no_wait.

	* infcmd.c: Replace ATTACH_NO_WAIT compile time check by
	target_attach_no_wait runtime check.

	* gnu-nat.c (init_gnu_ops): Set to_attach_no_wait in gnu_ops.
	* win32-nat.c (init_win32_ops): Set to_attach_no_wait in
	win32_ops.
@
text
@d2219 1
a2219 1
gnu_stop (void)
@


1.47
log
@	* gnu-nat.c (proc_string): Use capital T for "Thread".
@
text
@d2595 1
@


1.46
log
@	Updated copyright notices for most files.
@
text
@d2559 1
a2559 1
    sprintf (tid_str, "thread %d.%d",
@


1.45
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d2 2
a3 2
   Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2006, 2007
   Free Software Foundation, Inc.
@


1.44
log
@	* target.h (struct target_ops): Add REGCACHE parameter to
	to_prepare_to_store.
	(target_prepare_to_store): Likewise.
	* target.c (debug_to_prepare_to_store): Add REGCACHE parameter.
	(update_current_target): Adapt prepare_to_store de_fault rule.

	* regcache.c (regcache_raw_write): Pass regcache to
	target_prepare_to_store.

	* inftarg.c (child_prepare_to_store): Add REGCACHE parameter.
	Do not call CHILD_PREPARE_TO_STORE.
	* gnu-nat.c (gnu_prepare_to_store): Likewise.
	* procfs.c (procfs_prepare_to_store): Likewise.

	* inf-child.c (inf_child_prepare_to_store): Add REGCACHE parameter.
	* go32-nat.c (go32_prepare_to_store): Likewise.
	* monitor.c (monitor_prepare_to_store): Likewise.
	* nto-procfs.c (procfs_prepare_to_store): Likewise.
	* remote-m32r-sdi.c (m32r_prepare_to_store): Likewise.
	* remote-mips.c (mips_prepare_to_store): Likewise.
	* remote-sim.c (gdbsim_prepare_to_store): Likewise.
	* win32-nat.c (win32_prepare_to_store): Likewise.

	* remote.c (remote_prepare_to_store): Add REGCACHE parameter.
	Use it instead of current_regcache.

	* hpux-thread.c (hpux_thread_prepare_to_store): Add REGCACHE
	parameter.  Pass it on to next target.
	* sol-thread.c (sol_thread_prepare_to_store): Likewise.
@
text
@d13 1
a13 1
   the Free Software Foundation; either version 2 of the License, or
d22 1
a22 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.
@


1.43
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d2210 1
a2210 1
gnu_prepare_to_store (void)
a2211 3
#ifdef CHILD_PREPARE_TO_STORE
  CHILD_PREPARE_TO_STORE ();
#endif
@


1.42
log
@Copyright updates for 2007.
@
text
@d2587 2
a2588 2
extern void gnu_store_registers (int regno);
extern void gnu_fetch_registers (int regno);
@


1.41
log
@Undefine _process_user_ before including
<hurd/process_request.h>.
(gnu_resume): Supply missing argument to error().
(gnu_read_inferior): Add extra parenthesis around arithmetic
expression to silence warnings from GCC.
(gnu_write_inferior): Likewise.
(gnu_xfer_memory): Changed type of MYADDR to `gdb_byte *'.
@
text
@d2 1
a2 1
   Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2006
@


1.40
log
@2006-05-11  Alfred M. Szmidt  <ams@@gnu.org>

	* gnu-nat.c (inf_validate_procs): Don't use lvalue in assignments.
@
text
@d48 3
d1984 1
a1984 1
	error (_("Can't run single thread id %d: no such thread!"));
d2263 1
a2263 1
  err = hurd_safe_copyin (myaddr, (void *) addr - low_address + copied, length);
d2318 1
a2318 1
  err = hurd_safe_copyout ((void *) addr - low_address + copied,
d2451 1
a2451 1
gnu_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
@


1.40.2.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a47 3
/* Defined in <hurd/process.h>, but we need forward declarations from
   <hurd/process_request.h> as well.  */
#undef _process_user_
d1981 1
a1981 1
	error (_("Can't run single thread id %d: no such thread!"), inf->pid);
d2260 1
a2260 1
  err = hurd_safe_copyin (myaddr, (void *) (addr - low_address + copied), length);
d2315 1
a2315 1
  err = hurd_safe_copyout ((void *) (addr - low_address + copied),
d2448 1
a2448 1
gnu_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len, int write,
@


1.39
log
@	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.

	* gnu-nat.c (gnu_create_inferior): Don't call proceed.
	* go32-nat.c (go32_create_inferior): Likewise.
	* nto-procfs.c (procfs_create_inferior): Likewise.
	* procfs.c (procfs_create_inferior): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Likewise.
	* remote.c (extended_remote_create_inferior)
	(extended_remote_async_create_inferior): Likewise.
	* win32-nat.c (win32_create_inferior): Likewise.
	* wince.c (child_create_inferior): Likewise.

	* monitor.c (monitor_create_inferior): Don't call proceed.
	Set the PC manually.
	* ocd.c (ocd_create_inferior): Likewise.
	* remote-e7000.c (e7000_create_inferior): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior): Likewise.
	* remote-mips.c (mips_create_inferior): Likewise.
	* remote-rdp.c (remote_rdp_create_inferior): Likewise.
	* remote-sds.c (sds_create_inferior): Likewise.
	* remote-st.c (st2000_create_inferior): Likewise.

	* inf-ptrace.c (inf_ptrace_create_inferior): Don't call
	proceed or observer_notify_inferior_created.
	* inf-ttrace.c (inf_ttrace_create_inferior): Likewise.
	* inftarg.c (child_create_inferior): Likewise.
@
text
@d1053 4
a1056 1
	    (last ? last->next : inf->threads) = thread;
d1069 4
a1072 1
	    (last ? last->next : inf->threads) = thread;
@


1.38
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d2 1
a2 1
   Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000, 2001
a2091 3

  /* Here we go!  */
  proceed ((CORE_ADDR) -1, 0, 0);
@


1.37
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	* command.h (deprecated_add_set_cmd): Rename add_set_cmd.
	* cli/cli-decode.h (add_set_cmd): Delete declaration.
	* cli/cli-decode.c (deprecated_add_set_cmd): Rename add_set_cmd.
	* i386-nat.c (_initialize_i386_nat): Update call.
	* valprint.c (_initialize_valprint): Update comment.
	* gnu-nat.c (_initialize_gnu_nat): Update call.
@
text
@d2 1
a2 1
   Copyright 1992, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d23 2
a24 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.
@


1.37.10.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d2092 3
@


1.37.6.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d2092 3
@


1.36
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d3374 4
a3377 3
  add_set_cmd ("gnu-debug", class_maintenance,
	       var_boolean, (char *) &gnu_debug_flag,
	       "Set debugging output for the gnu backend.", &maintenancelist);
@


1.35
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d3136 1
a3136 1
		  "Command prefix for setting task attributes.",
d3139 1
a3139 1
		  "Command prefix for showing task attributes.",
d3303 1
a3303 1
		  "Command prefix for setting thread properties.",
d3306 1
a3306 1
		  "Command prefix for setting default thread properties.",
d3310 1
a3310 1
		  "Command prefix for showing thread properties.",
d3313 1
a3313 1
		  "Command prefix for showing default thread properties.",
@


1.34
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d3072 2
a3073 2
  add_cmd ("pause", class_run, set_thread_default_pause_cmd,
	   "Set whether the new threads are suspended while gdb has control.\n\
d3076 1
a3076 1
The default value is \"off\".",
d3078 2
a3079 2
  add_cmd ("pause", no_class, show_thread_default_pause_cmd,
	   "Show whether new threads are suspended while gdb has control.",
d3082 2
a3083 3
  add_cmd ("run", class_run, set_thread_default_run_cmd,
	   "Set whether new threads are allowed to run \
(once gdb has noticed them).",
d3085 2
a3086 3
  add_cmd ("run", no_class, show_thread_default_run_cmd,
	   "Show whether new threads are allowed to run \
(once gdb has noticed them).",
d3090 1
a3090 1
	   "Set the default detach-suspend-count value for new threads.",
d3093 1
a3093 1
	   "Show the default detach-suspend-count value for new threads.",
d3096 3
a3098 3
  add_cmd ("signals", class_run, set_signals_cmd,
	   "Set whether the inferior process's signals will be intercepted.\n\
Mach exceptions (such as breakpoint traps) are not affected.",
d3101 2
a3102 2
  add_cmd ("signals", no_class, show_signals_cmd,
	   "Show whether the inferior process's signals will be intercepted.",
d3106 3
a3108 3
  add_cmd ("signal-thread", class_run, set_sig_thread_cmd,
	   "Set the thread that gdb thinks is the libc signal thread.\n\
This thread is run when delivering a signal to a non-stopped process.",
d3111 2
a3112 2
  add_cmd ("signal-thread", no_class, show_sig_thread_cmd,
	   "Set the thread that gdb thinks is the libc signal thread.",
d3116 3
a3118 4
  add_cmd ("stopped", class_run, set_stopped_cmd,
	   "Set whether gdb thinks the inferior process is stopped \
as with SIGSTOP.\n\
Stopped process will be continued by sending them a signal.",
d3120 2
a3121 3
  add_cmd ("stopped", no_class, show_signals_cmd,
	   "Show whether gdb thinks the inferior process is stopped \
as with SIGSTOP.",
d3124 2
a3125 2
  add_cmd ("exceptions", class_run, set_exceptions_cmd,
	   "Set whether exceptions in the inferior process will be trapped.\n\
d3127 1
a3127 1
will work.",
d3131 2
a3132 2
  add_cmd ("exceptions", no_class, show_exceptions_cmd,
	   "Show whether exceptions in the inferior process will be trapped.",
d3142 2
a3143 2
  add_cmd ("pause", class_run, set_task_pause_cmd,
	   "Set whether the task is suspended while gdb has control.\n\
d3147 1
a3147 1
used to pause individual threads by default instead.",
d3150 1
a3150 1
	   "Show whether the task is suspended while gdb has control.",
d3154 1
a3154 1
	   "Set the suspend count will leave on the thread when detaching.",
d3157 1
a3157 1
	   "Show the suspend count will leave on the thread when detaching.",
d3160 3
a3162 3
  add_cmd ("exception-port", no_class, set_task_exc_port_cmd,
	   "Set the task exception port to which we forward exceptions.\n\
The argument should be the value of the send right in the task.",
d3170 2
a3171 2
  add_cmd ("noninvasive", no_class, set_noninvasive_cmd,
	   "Set task options so that we interfere as little as possible.\n\
d3173 1
a3173 1
`signals' to the opposite value.",
d3178 1
a3178 1
	   "Show information about the task's send rights",
d3181 1
a3181 1
	   "Show information about the task's receive rights",
d3184 1
a3184 1
	   "Show information about the task's port rights",
d3187 1
a3187 1
	   "Show information about the task's port sets",
d3190 1
a3190 1
	   "Show information about the task's dead names",
d3317 2
a3318 3
  add_cmd ("pause", class_run, set_thread_pause_cmd,
	   "Set whether the current thread is suspended \
while gdb has control.\n\
d3323 1
a3323 1
The default value is \"off\".",
d3325 2
a3326 3
  add_cmd ("pause", no_class, show_thread_pause_cmd,
	   "Show whether the current thread is suspended \
while gdb has control.",
d3330 1
a3330 1
	   "Set whether the current thread is allowed to run.",
d3333 1
a3333 1
	   "Show whether the current thread is allowed to run.",
d3336 2
a3337 2
  add_cmd ("detach-suspend-count", class_run, set_thread_detach_sc_cmd,
	   "Set the suspend count will leave on the thread when detaching.\n\
d3339 1
a3339 1
use the `thread takeover-suspend-count' to force it to an absolute value.",
d3341 2
a3342 2
  add_cmd ("detach-suspend-count", no_class, show_thread_detach_sc_cmd,
	   "Show the suspend count will leave on the thread when detaching.\n\
d3344 1
a3344 1
use the `thread takeover-suspend-count' to force it to an absolute value.",
d3347 2
a3348 2
  add_cmd ("exception-port", no_class, set_thread_exc_port_cmd,
	   "Set the thread exception port to which we forward exceptions.\n\
d3350 1
a3350 1
The argument should be the value of the send right in the task.",
d3356 2
a3357 2
  add_cmd ("takeover-suspend-count", no_class, thread_takeover_sc_cmd,
	   "Force the threads absolute suspend-count to be gdb's.\n\
d3359 1
a3359 1
to the thread's initial suspend-count when gdb notices the threads.",
@


1.33
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d2116 1
a2116 1
    error_no_arg ("process-id to attach");
@


1.32
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d335 1
a335 1
	  warning ("Stopped %s.", proc_string (proc));
d471 1
a471 1
	warning ("Error setting exception port for %s: %s",
d501 1
a501 1
	warning ("Error setting exception port for %s: %s",
d578 1
a578 1
    warning ("Couldn't request notification for port %d: %s",
d728 1
a728 1
    error ("Error allocating event port: %s", safe_strerror (err));
d752 1
a752 1
	error ("Error getting task for pid %d: %s", pid, safe_strerror (err));
d862 1
a862 1
	error ("Additional task suspend count left untouched.");
d888 1
a888 1
	    warning ("Can't modify tracing state for pid %d: %s",
d893 1
a893 1
	warning ("Can't modify tracing state for pid %d: %s",
d1328 1
a1328 1
	error ("Can't forward spontaneous exception (%s).", NAME);
d1368 1
a1368 1
    warning ("Can't deliver signal %s: No signal thread.", NAME);
d1370 1
a1370 1
    warning ("Delivering signal %s: %s", NAME, safe_strerror (err));
d1401 1
a1401 1
    warning ("Can't continue process: %s", safe_strerror (err));
d1440 1
a1440 1
	error ("There are no threads; try again later.");
d1464 1
a1464 1
	warning ("wait request failed: %s", safe_strerror (err));
d1500 1
a1500 1
    error ("Couldn't wait for an event: %s", safe_strerror (err));
d1520 1
a1520 1
	error ("Got a strange event, msg id = %d.", msg.hdr.msgh_id);
d1523 1
a1523 1
	error ("Handling event, msgid = %d: %s",
d1706 1
a1706 1
  warning ("Pid %d died with unknown exit status, using SIGKILL.", inf->pid);
d1756 1
a1756 1
  warning ("illegal rpc: %s", fun);
d1821 1
a1821 1
	  warning ("Can't wait for pid %d: %s", inf->pid, safe_strerror (err));
d1877 1
a1877 1
    warning ("Signal delivery failed: %s", safe_strerror (err));
d1951 1
a1951 1
      warning ("Aborting %s with unforwarded exception %s.",
d1975 1
a1975 1
	error ("Can't run single thread id %d: no such thread!");
d1984 1
a1984 1
	warning ("Can't step thread id %d: no such thread.", PIDGET (tid));
d2053 1
a2053 1
      error ("ptrace (PTRACE_TRACEME) failed!");
d2121 1
a2121 1
    error ("I refuse to debug myself!");
d2214 1
a2214 1
  error ("Use the \"run\" command to start a Unix child process.");
d2220 1
a2220 1
  error ("to_stop target function not implemented");
d2226 1
a2226 1
  error ("to_pid_to_exec_file target function not implemented");
d2260 1
a2260 1
      warning ("Read from inferior faulted: %s", safe_strerror (err));
d2266 1
a2266 1
    warning ("gnu_read_inferior vm_deallocate failed: %s", safe_strerror (err));
d2351 1
a2351 1
	    warning ("No memory at 0x%x. Nothing written",
d2360 1
a2360 1
	    warning ("Memory at address 0x%x is unwritable. Nothing written",
d2434 1
a2434 1
      warning ("%s: %s", errstr, mach_error_string (err));
d2513 1
a2513 1
	  warning ("vm_region failed: %s", mach_error_string (err));
d2677 1
a2677 1
  error ("Illegal argument for \"%s\" command, should be an integer.", cmd_prefix);
d2688 1
a2688 1
    error ("Illegal argument for \"%s\" command, should be \"%s\" or \"%s\".",
d2699 1
a2699 1
    error ("Garbage after \"%s\" command: `%s'", cmd_prefix, args);
d2709 1
a2709 1
    error ("No current thread.");
d2719 1
a2719 1
    error ("No current process.");
d2826 1
a2826 1
    error ("No inferior task.");
d2832 1
a2832 1
    error ("Couldn't extract send right %d from inferior: %s",
d2847 1
a2847 1
      error ("Can't set exception port for %s: %s",
d2857 1
a2857 1
    error ("No argument to \"set task exception-port\" command.");
d2882 2
a2883 2
    error ("Illegal argument to \"set signal-thread\" command.\n"
	   "Should be an integer thread ID, or `none'.");
d2891 2
a2892 2
	error ("Thread ID %s not known.  Use the \"info threads\" command to\n"
	       "see the IDs of currently known threads.", args);
d3022 1
a3022 1
	    error ("%ld: %s.", right, safe_strerror (err));
d3032 1
a3032 1
	error ("%s.", safe_strerror (err));
d3266 1
a3266 1
    error ("No argument to \"set thread exception-port\" command.");
d3293 1
a3293 1
    error ("%s.", safe_strerror (err));
d3404 1
a3404 1
    warning ("Error flushing inferior's cache : %s", safe_strerror (ret));
@


1.31
log
@2004-06-08  Andrew Cagney  <cagney@@gnu.org>

	* infptrace.c [ATTACH_DETACH]: Remove #ifdef wrappers.
	(attach, detach): When neither PT_ATTACH / PT_DETACH nor
	PTRACE_ATTACH / PTRACE_DETACH available call error.
	(PT_ATTACH, PT_DETACH): Move definition to attach / detach.
	* infttrace.c (update_thread_state_after_attach, attach, detach):
	Remove #ifdef wrappers.
	* inftarg.c (child_attach, child_detach): Remove #ifdef wrappers.
	* gnu-nat.c [ATTACH_DETACH]: Remove #ifdef wrappers.
	* config/nm-bsd.h (ATTACH_DETACH): Delete.
	* config/nm-sysv4.h (ATTACH_DETACH): Delete.
	* config/nm-nbsd.h (ATTACH_DETACH): Delete.
	* config/nm-linux.h (ATTACH_DETACH): Delete.
	* config/rs6000/nm-rs6000.h (ATTACH_DETACH): Delete.
	* config/pa/nm-hppah.h (ATTACH_DETACH): Delete.
	* config/i386/nm-i386sco5.h (ATTACH_DETACH): Delete.
	* config/i386/nm-i386sco4.h (ATTACH_DETACH): Delete.
	* config/i386/nm-i386gnu.h (ATTACH_DETACH): Delete.

Index: doc/ChangeLog
2004-06-08  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Native Debugging): Delete documentation on
	ATTACH_DETACH.
@
text
@d2600 1
a2600 1
  gnu_ops.to_xfer_memory = gnu_xfer_memory; /* to_xfer_memory */
@


1.30
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@a2105 2
#ifdef ATTACH_DETACH

a2189 2
#endif /* ATTACH_DETACH */

@


1.29
log
@2004-04-04  Andrew Cagney  <cagney@@redhat.com>

	* gnu-nat.c (gnu_wait): Use memcpy instead of bcopy.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-vx68.c (vx_read_register, vx_write_register): Ditto.
@
text
@d2043 2
a2044 1
gnu_create_inferior (char *exec_file, char *allargs, char **env)
@


1.28
log
@2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* remote-vxsparc.c (vx_read_register): Replace bzero with memset.
	* remote-vxmips.c (vx_read_register): Ditto.
	* remote-vx68.c (vx_read_register): Ditto.
	* gnu-nat.c (inf_validate_procs): Ditto.
@
text
@d1577 1
a1577 1
  bcopy (&inf->wait.status, status, sizeof (*status));
@


1.28.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1577 1
a1577 1
  memcpy (status, &inf->wait.status, sizeof (*status));
d2043 1
a2043 2
gnu_create_inferior (char *exec_file, char *allargs, char **env,
		     int from_tty)
d2105 2
d2191 2
@


1.27
log
@2003-09-08  Andrew Cagney  <cagney@@redhat.com>

	* gnu-nat.c: Remove "inline" function attribute.
	* alpha-tdep.c, ppc-linux-tdep.c, macroexp.c: Ditto.
@
text
@d1027 1
a1027 1
    bzero (matched, sizeof (matched));
@


1.27.2.1
log
@2003-09-29  Elena Zannoni  <ezannoni@@redhat.com>

	* exec.c (exec_set_find_memory_regions): Update parameter list.
	* defs.h (exec_set_find_memory_regions): Update parameter list.
	* fbsd-proc.c (fbsd_find_memory_regions): Likewise. Update call to
	function parameter.
	* gcore.c (gcore_create_callback): Update paramter list.
	(objfile_find_memory_regions): Update parameter list. Update calls
	to function parameter.
	* gnu-nat.c (gnu_find_memory_regions): Update parameter
	list. Update calls to function parameter.
	* inftarg.c (inftarg_set_find_memory_regions): Update parameter
	list.
	* linux-proc.c (read_mapping): Prune the leading whitespaces in
	the filename.
	(linux_find_memory_regions): Update parameter list. Update call to
	function parameter.
	* procfs.c (find_memory_regions_callback): Update paremeters and
	calls.
	(proc_find_memory_regions): Update parameters.
	* sol-thread.c (sol_find_memory_regions): Update parameter list.
	* target.h (struct target_ops): Update definition of
	to_find_memory_regions field.
@
text
@d2476 1
a2476 1
				      char *, void *),
a2533 1
                     NULL,
@


1.26
log
@	* Makefile.in (exc_request_U_h): Define
	(exc_request_S_h): Likewise.
	(msg_reply_S_h): Likewise.
	(msg_U_h): Likewise.
	(notify_S_h): Likewise.
	(process_reply_S_h): Likewise.
	(gnu-nat.o): Depend on gdb_obstack_h
	* gnu-nat.c: Include "gdb_obstack.h".
@
text
@d101 6
a106 6
inline void inf_set_threads_resume_sc (struct inf *inf,
				       struct proc *run_thread,
				       int run_others);
inline int inf_set_threads_resume_sc_for_signal_thread (struct inf *inf);
inline void inf_suspend (struct inf *inf);
inline void inf_resume (struct inf *inf);
d1080 1
a1080 1
inline int
d1093 1
a1093 1
inline void
d1111 1
a1111 1
inline void
d1136 1
a1136 1
inline void
d1182 1
a1182 1
inline int
@


1.25
log
@	* gnu-nat.c (init_gnu_ops): Remove NULL initializations.
	* monitor.c (init_base_monitor_ops): Likewise.
	* ppc-bdm.c (init_bdm_ppc_ops): Likewise.
	* remote-array.c (init_array_ops): Likewise.
	* remote-e7000.c (init_e7000_ops): Likewise.
	* remote-es.c (init_es1800_ops): Likewise.
	(init_es1800_child_ops): Likewise.
	* remote-rdp.c (init_remote_rdp_ops): Likewise.
	* remote-sim.c (init_gdbsim_ops): Likewise.
	* remote-st.c (init_st2000_ops): Likewise.
	* sol-thread.c (init_sol_core_ops): Likewise.
	(init_sol_thread_ops): Likewise.
	* v850ice.c (init_850ice_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
@
text
@d65 1
@


1.24
log
@Zap __FUNCTION__.
@
text
@a2594 1
  gnu_ops.to_close = 0;			/* to_close */
a2595 2
  gnu_ops.to_post_attach = NULL;
  gnu_ops.to_require_attach = NULL;	/* to_require_attach */
a2596 1
  gnu_ops.to_require_detach = NULL;	/* to_require_detach */
a2598 1
  gnu_ops.to_post_wait = NULL;		/* to_post_wait */
a2603 1
  gnu_ops.to_files_info = 0;		/* to_files_info */
a2612 2
  gnu_ops.to_load = 0;			/* to_load */
  gnu_ops.to_lookup_symbol = 0;		/* to_lookup_symbol */
a2613 20
  gnu_ops.to_post_startup_inferior = NULL;    /* to_post_startup_inferior */
  /* to_acknowledge_created_inferior */
  gnu_ops.to_acknowledge_created_inferior = NULL;
  /* to_clone_and_follow_inferior */
  gnu_ops.to_clone_and_follow_inferior = NULL;
  /* to_post_follow_inferior_by_clone */
  gnu_ops.to_post_follow_inferior_by_clone = NULL;
  gnu_ops.to_insert_fork_catchpoint = NULL;
  gnu_ops.to_remove_fork_catchpoint = NULL;
  gnu_ops.to_insert_vfork_catchpoint = NULL;
  gnu_ops.to_remove_vfork_catchpoint = NULL;
  gnu_ops.to_has_forked = NULL;		/* to_has_forked */
  gnu_ops.to_has_vforked = NULL;	/* to_has_vforked */
  gnu_ops.to_can_follow_vfork_prior_to_exec = NULL;
  gnu_ops.to_post_follow_vfork = NULL;	/* to_post_follow_vfork */
  gnu_ops.to_insert_exec_catchpoint = NULL;
  gnu_ops.to_remove_exec_catchpoint = NULL;
  gnu_ops.to_has_execd = NULL;
  gnu_ops.to_reported_exec_events_per_exec_call = NULL;
  gnu_ops.to_has_exited = NULL;
a2615 1
  gnu_ops.to_notice_signals = 0;	/* to_notice_signals */
a2620 1
  gnu_ops.DONT_USE = 0;			/* to_next */
a2625 2
  gnu_ops.to_sections = 0;		/* sections */
  gnu_ops.to_sections_end = 0;		/* sections_end */
@


1.24.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a64 1
#include "gdb_obstack.h"
d100 6
a105 6
void inf_set_threads_resume_sc (struct inf *inf,
				struct proc *run_thread,
				int run_others);
int inf_set_threads_resume_sc_for_signal_thread (struct inf *inf);
void inf_suspend (struct inf *inf);
void inf_resume (struct inf *inf);
d1026 1
a1026 1
    memset (matched, 0, sizeof (matched));
d1079 1
a1079 1
int
d1092 1
a1092 1
void
d1110 1
a1110 1
void
d1135 1
a1135 1
void
d1181 1
a1181 1
int
d2595 1
d2597 2
d2600 1
d2603 1
d2609 1
d2619 2
d2622 20
d2644 1
d2650 1
d2656 2
@


1.23
log
@	Fix PR gdb/393:
	* inflow.c (terminal_save_ours): New function to save terminal
	settings.
	* inferior.h (terminal_save_ours): Declare.
	* target.c (debug_to_terminal_save_ours): New function.
	(cleanup_target): Defaults to_terminal_save_ours.
	(update_current_target): Inherit to_terminal_save_ours.
	(setup_target_debug): Set to_terminal_save_ours.
	* target.h (target_terminal_save_ours): New to save terminal settings.
	(target_ops): New member to_terminal_save_ours.
	* gnu-nat.c (init_gnu_ops): Set to_terminal_save_ours.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* inftarg.c (init_child_ops): Likewise.
	* m3-nat.c (init_m3_ops): Likewise.
	* procfs.c (init_procfs_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* sol-thread.c (init_sol_thread_ops): Likewise.
@
text
@d1762 1
a1762 1
  return ill_rpc (__FUNCTION__);
d1768 1
a1768 1
  return ill_rpc (__FUNCTION__);
d1774 1
a1774 1
  return ill_rpc (__FUNCTION__);
d1780 1
a1780 1
  return ill_rpc (__FUNCTION__);
d1786 1
a1786 1
  return ill_rpc (__FUNCTION__);
d1848 1
a1848 1
  return ill_rpc (__FUNCTION__);
d1854 1
a1854 1
  return ill_rpc (__FUNCTION__);
d1893 1
a1893 1
  return ill_rpc (__FUNCTION__);
@


1.23.4.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d1762 1
a1762 1
  return ill_rpc ("do_mach_notify_no_senders");
d1768 1
a1768 1
  return ill_rpc ("do_mach_notify_port_deleted");
d1774 1
a1774 1
  return ill_rpc ("do_mach_notify_msg_accepted");
d1780 1
a1780 1
  return ill_rpc ("do_mach_notify_port_destroyed");
d1786 1
a1786 1
  return ill_rpc ("do_mach_notify_send_once");
d1848 1
a1848 1
  return ill_rpc ("S_proc_setmsgport_reply");
d1854 1
a1854 1
  return ill_rpc ("S_proc_getmsgport_reply");
d1893 1
a1893 1
  return ill_rpc ("S_msg_sig_post_reply");
@


1.23.4.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d2595 1
d2597 2
d2600 1
d2603 1
d2609 1
d2619 2
d2622 20
d2644 1
d2650 1
d2656 2
@


1.23.4.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a64 1
#include "gdb_obstack.h"
@


1.23.4.4
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d101 6
a106 6
void inf_set_threads_resume_sc (struct inf *inf,
				struct proc *run_thread,
				int run_others);
int inf_set_threads_resume_sc_for_signal_thread (struct inf *inf);
void inf_suspend (struct inf *inf);
void inf_resume (struct inf *inf);
d1080 1
a1080 1
int
d1093 1
a1093 1
void
d1111 1
a1111 1
void
d1136 1
a1136 1
void
d1182 1
a1182 1
int
@


1.23.4.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1027 1
a1027 1
    memset (matched, 0, sizeof (matched));
@


1.23.2.1
log
@2002-09-29  Andrew Cagney  <ac131313@@redhat.com>

	* gnu-nat.h (debug): Use __FILE__ and __LINE__ instead of
	__FUNCTION__.
	* gnu-nat.c (do_mach_notify_no_senders): Replace __FUNCTION__
	with function name.
	(do_mach_notify_port_deleted, do_mach_notify_msg_accepted): Ditto.
	(do_mach_notify_port_destroyed, do_mach_notify_send_once): Ditto.
	(S_proc_setmsgport_reply, S_proc_getmsgport_reply): Ditto.
	(S_msg_sig_post_reply): Ditto.
@
text
@d1762 1
a1762 1
  return ill_rpc ("do_mach_notify_no_senders");
d1768 1
a1768 1
  return ill_rpc ("do_mach_notify_port_deleted");
d1774 1
a1774 1
  return ill_rpc ("do_mach_notify_msg_accepted");
d1780 1
a1780 1
  return ill_rpc ("do_mach_notify_port_destroyed");
d1786 1
a1786 1
  return ill_rpc ("do_mach_notify_send_once");
d1848 1
a1848 1
  return ill_rpc ("S_proc_setmsgport_reply");
d1854 1
a1854 1
  return ill_rpc ("S_proc_getmsgport_reply");
d1893 1
a1893 1
  return ill_rpc ("S_msg_sig_post_reply");
@


1.22
log
@2002-04-30  Michael Snyder  <msnyder@@redhat.com>

	* gnu-nat.c (gnu_find_memory_regions): Fix merge botch.
@
text
@d2615 1
@


1.22.6.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a2614 1
  gnu_ops.to_terminal_save_ours = terminal_save_ours;
@


1.22.6.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d1762 1
a1762 1
  return ill_rpc ("do_mach_notify_no_senders");
d1768 1
a1768 1
  return ill_rpc ("do_mach_notify_port_deleted");
d1774 1
a1774 1
  return ill_rpc ("do_mach_notify_msg_accepted");
d1780 1
a1780 1
  return ill_rpc ("do_mach_notify_port_destroyed");
d1786 1
a1786 1
  return ill_rpc ("do_mach_notify_send_once");
d1848 1
a1848 1
  return ill_rpc ("S_proc_setmsgport_reply");
d1854 1
a1854 1
  return ill_rpc ("S_proc_getmsgport_reply");
d1893 1
a1893 1
  return ill_rpc ("S_msg_sig_post_reply");
@


1.21
log
@2002-04-30  Michael Snyder  <msnyder@@redhat.com>

	* gnu-nat.c (gnu_find_memory_regions): Fix merge botch.
@
text
@d2539 1
d2547 2
@


1.20
log
@2002-04-24  Roland McGrath  <roland@@frob.com>

	* config/i386/i386gnu.mh (NATDEPFILES): Add core-regset.o here.
	* i386gnu-nat.c [HAVE_SYS_PROCFS_H]
	(supply_gregset, supply_fpregset): New functions.

	* gnu-nat.c (gnu_find_memory_regions): New function.
	(init_gnu_ops): Set `to_find_memory_regions' hook to that.
	(gnu_xfer_memory): Add a cast.
@
text
@d2539 7
@


1.19
log
@s/strerror/safe_strerror/
@
text
@d2461 1
a2461 1
		 write ? "writing" : "reading", memaddr, len,
d2470 71
d2598 1
@


1.18
log
@<string.h> -> "gdb_string.h"
@
text
@d302 1
a302 1
    proc_debug (proc, "err = %s", strerror (err));
d471 1
a471 1
		 proc_string (proc), strerror (err));
d501 1
a501 1
		 proc_string (proc), strerror (err));
d578 1
a578 1
	     port, strerror (err));
d727 1
a727 1
    error ("Error allocating event port: %s", strerror (err));
d751 1
a751 1
	error ("Error getting task for pid %d: %s", pid, strerror (err));
d893 1
a893 1
		 inf->pid, strerror (err));
d1369 1
a1369 1
    warning ("Delivering signal %s: %s", NAME, strerror (err));
d1400 1
a1400 1
    warning ("Can't continue process: %s", strerror (err));
d1463 1
a1463 1
	warning ("wait request failed: %s", strerror (err));
d1499 1
a1499 1
    error ("Couldn't wait for an event: %s", strerror (err));
d1523 1
a1523 1
	       msg.hdr.msgh_id, strerror (reply.err));
d1799 1
a1799 1
	     err ? strerror (err) : "0", pid, status, sigcode);
d1820 1
a1820 1
	  warning ("Can't wait for pid %d: %s", inf->pid, strerror (err));
d1876 1
a1876 1
    warning ("Signal delivery failed: %s", strerror (err));
d2262 1
a2262 1
      warning ("Read from inferior faulted: %s", strerror (err));
d2268 1
a2268 1
    warning ("gnu_read_inferior vm_deallocate failed: %s", strerror (err));
d2784 1
a2784 1
	   name, strerror (err));
d2799 1
a2799 1
	     proc_string (proc), strerror (err));
d2973 1
a2973 1
	    error ("%ld: %s.", right, strerror (err));
d2983 1
a2983 1
	error ("%s.", strerror (err));
d3244 1
a3244 1
    error ("%s.", strerror (err));
d3355 1
a3355 1
    warning ("Error flushing inferior's cache : %s", strerror (ret));
@


1.17
log
@s/value_ptr/struct value */
@
text
@d33 1
a33 1
#include <string.h>
@


1.16
log
@* gnu-nat.c: Include <ctype.h>.
(gnu_pid_to_exec_file): Add PID parameter.
(set_sig_thread_cmd): Use PIDGET on return value from
thread_id_to_pid.
(proc_string): Use MERGEPID to construct argument to
pid_to_thread_id.
@
text
@d2 1
a2 1
   Copyright 1992, 1995, 1996, 1997, 1998, 1999, 2000
d2960 1
a2960 1
  value_ptr vmark = value_mark ();
d2967 1
a2967 1
	  value_ptr val = parse_to_comma_and_eval (&args);
@


1.15
log
@Phase 1 of the ptid_t changes.
@
text
@d27 1
d2226 1
a2226 1
gnu_pid_to_exec_file (void)
d2480 1
a2480 1
	     proc->inf->pid, pid_to_thread_id (proc->tid));
d2840 1
a2840 1
      int tid = thread_id_to_pid (atoi (args));
@


1.14
log
@* target.h (target_ops): Removed to_core_file_to_sym_file vector
function.
* corelow.c (core_ops): Updated for above change.
* gnu-nat.c (core_ops): Likewise.
* inftarg.c (child_ops): Likewise.
* monitor.c (monitor_ops): Likewise.
* ppc-bdm.c (bdm_ppc_ops): Likewise.
* remote-adapt.c (adapt_ops): Likewise.
* remote-bug.c (bug_ops): Likewise.
* remote-e7000.c (e7000_ops): Likewise.
* remote-eb.c (eb_ops): Likewise.
* remote-es.c (es1800_ops, es1800_child_ops): Likewise.
* remote-mm.c (mm_ops): Likewise.
* remote-nindy.c (nindy_ops): Likewise.
* remote-nrom.c (nrom_ops): Likewise.
* remote-os9k.c (rombug_ops): Likewise.
* remote-rdp.c (remote_rdp_ops): Likewise.
* remote-sim.c (gdbsim_ops): Likewise.
* remote-st.c (st2000_ops): Likewise.
* v850ice.c (v850ice_ops): Likewise.
* target.c (cleanup_target): Likewise
(update_current_target): Likewise.
(setup_target_debug): Likewise
(debug_to_core_file_to_sym_file): Removed.

* corefile.c (core_file_command) [HPUXHPPA]: Removed code that
sets symbol file from information obtained from the core file.
* corelow.c (core_file_to_sym_file): Removed.
@
text
@d1067 1
a1067 1
	    add_thread (thread->tid);	/* Tell GDB's generic thread code.  */
d1411 2
a1412 2
static int
gnu_wait (int tid, struct target_waitstatus *status)
d1443 1
a1443 1
  inf_debug (inf, "waiting for: %d", tid);
d1579 1
a1579 1
    tid = thread->tid;
d1581 1
a1581 1
    thread = inf_tid_to_thread (inf, tid);
d1587 1
a1587 1
	tid = inf->threads->tid; /* The first available thread.  */
d1589 1
a1589 1
	tid = inferior_pid;	/* let wait_for_inferior handle exit case */
d1592 1
a1592 1
  if (thread && tid >= 0 && status->kind != TARGET_WAITKIND_SPURIOUS
d1601 1
a1601 1
  inf_debug (inf, "returning tid = %d, status = %s (%d)", tid,
d1928 1
a1928 1
gnu_resume (int tid, int step, enum target_signal sig)
d1933 1
a1933 1
  inf_debug (inf, "tid = %d, step = %d, sig = %d", tid, step, sig);
d1961 1
a1961 1
  if (tid < 0)
d1964 2
a1965 2
      inf_debug (inf, "running all threads; tid = %d", inferior_pid);
      tid = inferior_pid;	/* What to step. */
d1971 1
a1971 1
      struct proc *thread = inf_tid_to_thread (inf, tid);
d1980 1
a1980 1
      step_thread = inf_tid_to_thread (inf, tid);
d1982 1
a1982 1
	warning ("Can't step thread id %d: no such thread.", tid);
d2069 1
a2069 1
    inferior_pid = inf_pick_first_thread ();
d2140 1
a2140 1
  inferior_pid = inf_pick_first_thread ();
d2185 1
a2185 1
  inferior_pid = 0;
d2233 1
a2233 1
gnu_thread_alive (int tid)
d2236 1
a2236 1
  return !!inf_tid_to_thread (current_inferior, tid);
d2484 1
a2484 1
gnu_pid_to_str (int tid)
d2487 1
d2657 1
a2657 1
  struct proc *thread = inf_tid_to_thread (inf, inferior_pid);
@


1.13
log
@malloc() -> xmalloc.
Move malloc() decl to utils.c
@
text
@a2563 1
  gnu_ops.to_core_file_to_sym_file = NULL;
@


1.12
log
@Add ``attrib'' parameter to *xfer_memory() functions.
@
text
@d542 1
a542 1
  struct proc *proc = malloc (sizeof (struct proc));
d639 1
a639 4
  struct inf *inf = malloc (sizeof (struct inf));

  if (!inf)
    return 0;
@


1.11
log
@* gnu-nat.c: Include "gdb_assert.h" instead of <assert.h>.
(proc_update_sc): Use gdb_assert instead of assert.
(proc_abort): Ditto.
(inf_set_step_thread): Ditto.
(gnu_wait): Ditto.
(S_exception_raise_request): Ditto.
(gnu_terminal_init_inferior): Ditto.
@
text
@d2450 1
@


1.10
log
@Update/correct copyright notices.
@
text
@a26 1
#include <assert.h>
d63 1
d265 1
a265 1
      assert (proc_is_thread (proc));
d321 1
a321 1
  assert (proc_is_thread (proc));
d1160 1
a1160 1
  assert (!thread || proc_is_thread (thread));
d1432 1
a1432 1
  assert (inf->task);
d1672 1
a1672 1
	      assert (inf->task->exc_port == port);
d2198 1
a2198 1
  assert (current_inferior);
@


1.9
log
@Replace free() with xfree().
@
text
@d2 2
a3 1
   Copyright (C) 1992, 95, 96, 97, 1999, 2000 Free Software Foundation, Inc.
@


1.8
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@d630 1
a630 1
  free (proc);
@


1.7
log
@Protoization.
@
text
@d1662 1
a1662 1
	      inf_debug (waiting_inf, "Handler is thread exeption port <%d>",
d1668 1
a1668 1
	      inf_debug (waiting_inf, "Handler is task exeption port <%d>",
@


1.6
log
@Protoization.
@
text
@d2445 2
a2446 1
/* Return 0 on failure, number of bytes handled otherwise.  */
d2448 2
a2449 6
gnu_xfer_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* IGNORED */
@


1.5
log
@2000-03-11  Mark Kettenis  <kettenis@@gnu.org>

	* gnu-nat.c: Fix the formatting where indent misinterpreted `&' as
	a binary operator.
	(gnu_attach): Change error message for missing
	argument to be identical to the corresponding message in
	`inftarg.c'.  This makes the testsuite happy.
@
text
@d636 1
a636 1
make_inf ()
d1997 1
a1997 1
gnu_kill_inferior ()
d2011 1
a2011 1
gnu_mourn_inferior ()
d2024 1
a2024 1
inf_pick_first_thread ()
d2035 1
a2035 1
cur_inf ()
d2043 1
a2043 4
gnu_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
d2099 1
a2099 1
gnu_can_run ()
d2110 1
a2110 3
gnu_attach (args, from_tty)
     char *args;
     int from_tty;
d2172 1
a2172 3
gnu_detach (args, from_tty)
     char *args;
     int from_tty;
d2195 1
a2195 1
gnu_terminal_init_inferior ()
d2207 1
a2207 1
gnu_prepare_to_store ()
d2215 1
a2215 3
gnu_open (arg, from_tty)
     char *arg;
     int from_tty;
d2221 1
a2221 1
gnu_stop ()
d2227 1
a2227 1
gnu_pid_to_exec_file ()
d2246 1
a2246 5
gnu_read_inferior (task, addr, myaddr, length)
     task_t task;
     CORE_ADDR addr;
     char *myaddr;
     int length;
d2290 1
a2290 5
gnu_write_inferior (task, addr, myaddr, length)
     task_t task;
     CORE_ADDR addr;
     char *myaddr;
     int length;
d2658 1
a2658 1
cur_thread ()
d2669 1
a2669 1
active_inf ()
d3347 1
a3347 2
flush_inferior_icache (pc, amount)
     CORE_ADDR pc;
@


1.4
log
@2000-02-26  Mark Kettenis  <kettenis@@gnu.org>

	* gnu-nat.c: Include "gdbthread.h".  Include <hurd.h>.
	Reorder headers a bit.  Overall cleanup and minor reformatting.
	(MIG_SERVER_DIED): Remove define.
	(proc_update_sc): Add braces to silence compiler warning.
	(proc_steal_exc_port): Initialize err to zero.
	(make_proc): Add braces to silence compiler warning.
	(inf_validate_task_sc): Add cast to silence compiler warning.
	(inf_set_traced): Reorganize a bit to silence compiler warning.
	(inf_validate_procs): Use mach_msg_type_number_t for all thread
	numbers and add braces to silence compiler warning.
	(gnu_wait): Add prototypes for server functions and add braces to
	silence compiler warnings.
	(S_exception_raise_request): Pass subcode to inf_debug call.
	(gnu_write_inferior): Remove unused variable `protection_changed'.
	(gnu_xfer_memory): Remove unused variable `result'.
	(set_sig_thread_cmd): Remove unused varible `tid'.
	(set_signals_cmd): Remve unused variable `trace'.
	(add_task_commands): Provide complete prototype.  Reformat help
	strings a bit to make sure the first line is a full sentence.
	Call info_port_rights_cmd instead of info_send_rights_cmd for the
	"info port-rights" command.
	(add_thread_commands): Provide complete prototype.  Make static.
	Reformat help strings a bit to make sure the first line is a full
	sentence.
	(_initialize_gnu_nat): Provide complete prototype.
@
text
@d267 1
a267 1
			 (thread_state_t) & proc->state, THREAD_STATE_SIZE);
d373 1
a373 1
			(thread_state_t) & proc->state, &state_size);
d382 1
a382 1
      return (thread_state_t) & proc->state;
d799 1
a799 1
		    (procinfo_t *) & pi, &pi_len, &noise, &noise_len);
d2122 1
a2122 1
    error_no_arg ("PID to attach");
@


1.3
log
@2000-02-09  Mark Kettenis  <kettenis@@gnu.org>

	* gnu-nat.c (proc_string): Make global.
	(do_mach_notify_dead_name): Suppress dead name notifications if we
	know that the task is dead.

1999-12-13  Mark Kettenis  <kettenis@@gnu.org>

	* gnu-nat.c (inf_validate_task_sc): Get task info via proc server
	instead of directly from the kernel.  Add some hackery to make
	sure that the info isn't influenced by suspension of the task in
	the proc server itself.
@
text
@d26 5
a32 5
#include <errno.h>
#include <signal.h>
#include <assert.h>
#include <setjmp.h>
#include <limits.h>
d36 2
a39 2
#include <mach_error.h>
#include <mach/exception.h>
d42 4
a47 2
#include <hurd/msg.h>
#include <hurd/msg_request.h>
a48 1
#include <hurd/interrupt.h>
d62 1
a144 1
#define MIG_SERVER_DIED EMIG_SERVER_DIED	/* XXX */
d247 1
d273 9
a281 5
    while (delta-- > 0 && !err)
      if (proc_is_task (proc))
	err = task_suspend (proc->port);
      else
	err = thread_suspend (proc->port);
d283 9
a291 6
    while (delta++ < 0 && !err)
      if (proc_is_task (proc))
	err = task_resume (proc->port);
      else
	err = thread_resume (proc->port);

d311 1
d387 1
d440 1
a440 1
      error_t err;
d502 1
d529 1
d585 9
a593 6
    if (proc_is_task (proc))
      /* Make the task exception port point to us.  */
      proc_steal_exc_port (proc, inf->event_port);
    else
      /* Just clear thread exception ports -- they default to the task one.  */
      proc_steal_exc_port (proc, MACH_PORT_NULL);
d633 1
d671 1
a671 1
/* clear INF's target wait status.  */
d690 1
d735 1
d737 1
a737 1
/* close current process, if any, and attach INF to process PORT */
d777 2
a778 1
	inf->task->sc = inf->task->cur_sc = 1;	/* Reflect task_suspend above */
d783 1
d828 1
a828 1
			  &pi, &pi_len, &noise, &noise_len);
d868 4
a871 3
/* Turns tracing for INF on or off, depending on ON, unless it already is.
   If INF is running, the resume_sc count of INF's threads will be modified,
   and the signal thread will briefly be run to change the trace state.  */
d875 8
a882 6
  if (on != inf->traced)
    if (inf->task && !inf->task->dead)
      /* Make it take effect immediately.  */
      {
	sigset_t mask = on ? ~(sigset_t) 0 : 0;
	error_t err =
d884 6
a889 12
						     INIT_TRACEMASK, mask));
	if (err == EIEIO)
	  {
	    if (on)
	      warning ("Can't modify tracing state for pid %d: No signal thread",
		       inf->pid);
	    inf->traced = on;
	  }
	else if (err)
	  warning ("Can't modify tracing state for pid %d: %s",
		   inf->pid, strerror (err));
	else
d891 9
a899 3
      }
    else
      inf->traced = on;
d901 1
d903 4
a906 3
/* Makes all the real suspend count deltas of all the procs in INF match the
   desired values.  Careful to always do thread/task suspend counts in the
   safe order.  Returns true if at least one thread is thought to be running. */
d955 1
d983 1
a988 1
  int i;
d990 1
a990 1
  unsigned num_threads;
d1018 2
a1019 1
    unsigned search_start = 0;	/* Make things normally linear.  */
d1031 1
a1031 1
	unsigned left;
d1058 14
a1071 12
      if (matched[i])
	/* Throw away the duplicate send right.  */
	mach_port_deallocate (mach_task_self (), threads[i]);
      else
	/* THREADS[I] is a thread we don't know about yet!  */
	{
	  thread = make_proc (inf, threads[i], next_thread_id++);
	  (last ? last->next : inf->threads) = thread;
	  last = thread;
	  proc_debug (thread, "new thread: %d", threads[i]);
	  add_thread (thread->tid);	/* Tell GDB's generic thread code.  */
	}
d1074 1
a1074 1
		 (vm_address_t) threads, (num_threads * sizeof (thread_t)));
d1077 1
d1107 1
d1151 1
d1153 3
a1155 3
/* INF has one thread PROC that is in single-stepping mode.  This function
   changes it to be PROC, changing any old step_thread to be a normal one.  A
   PROC of 0 clears any existing value.  */
d1177 1
d1201 1
d1244 2
a1245 2
/* Attaches INF to the process with process id PID, returning it in a suspended
   state suitable for debugging.  */
d1256 1
d1287 1
d1358 2
a1359 1
      inf_debug (inf, "sending %s to unstopped process (so resuming signal thread)", NAME);
d1361 3
a1363 2
	INF_RESUME_MSGPORT_RPC (inf, msg_sig_post_untraced (msgport,
						     host_sig, 0, refport));
d1374 1
d1403 1
d1421 1
a1421 2
    }
  msg;
d1426 5
d1469 5
a1473 4
	  /* Even if proc_waits_pending was > 0 before, we still won't get
	     any other replies, because it was either from a different INF,
	     or a different process attached to INF -- and the event port,
	     which is the wait reply port, changes when you switch processes. */
d1586 7
a1592 5
    /* TID is dead; try and find a new thread.  */
    if (inf_update_procs (inf) && inf->threads)
      tid = inf->threads->tid;	/* The first available thread.  */
    else
      tid = inferior_pid;	/* let wait_for_inferior handle exit case */
d1596 2
a1597 1
    /* If something actually happened to THREAD, make sure we suspend it.  */
d1614 1
d1627 1
a1627 1
	     thread_port, task_port, exception, code);
d1699 1
d1751 1
d1789 1
d1857 1
d1896 1
d1911 1
d1994 1
a2009 1

d2018 1
d2106 1
d2167 1
d2200 1
a2212 1

d2249 1
d2251 3
a2253 6
/*
 * Read inferior task's LEN bytes from ADDR and copy it to MYADDR
 * in gdb's address space.
 *
 * Return 0 on failure; number of bytes read otherwise.
 */
d2300 2
a2301 4
/*
 * Write gdb's LEN bytes from MYADDR and copy it to ADDR
 * in inferior task's address space.
 */
d2332 2
a2333 1
  err = hurd_safe_copyout ((void *) addr - low_address + copied, myaddr, length);
d2339 1
a2339 2
   * First check for holes and unwritable memory.
   */
d2405 1
a2405 2
     * Somebody is messing up inferior_task's mappings.
     */
a2409 2
	boolean_t protection_changed = FALSE;

a2429 2
	boolean_t protection_changed = FALSE;

d2460 1
d2471 4
a2474 5
  int result;
  task_t task =
  current_inferior
  ? (current_inferior->task ? current_inferior->task->port : 0)
  : 0;
d2489 1
d2519 1
d2529 2
a2530 2
  gnu_ops.to_shortname = "GNU";	/* to_shortname */
  gnu_ops.to_longname = "GNU Hurd process";	/* to_longname */
d2532 2
a2533 2
  gnu_ops.to_open = gnu_open;	/* to_open */
  gnu_ops.to_close = 0;		/* to_close */
d2540 7
a2546 7
  gnu_ops.to_wait = gnu_wait;	/* to_wait */
  gnu_ops.to_post_wait = NULL;	/* to_post_wait */
  gnu_ops.to_fetch_registers = gnu_fetch_registers;	/* to_fetch_registers */
  gnu_ops.to_store_registers = gnu_store_registers;	/* to_store_registers */
  gnu_ops.to_prepare_to_store = gnu_prepare_to_store;	/* to_prepare_to_store */
  gnu_ops.to_xfer_memory = gnu_xfer_memory;	/* to_xfer_memory */
  gnu_ops.to_files_info = 0;	/* to_files_info */
d2555 10
a2564 7
  gnu_ops.to_load = 0;		/* to_load */
  gnu_ops.to_lookup_symbol = 0;	/* to_lookup_symbol */
  gnu_ops.to_create_inferior = gnu_create_inferior;	/* to_create_inferior */
  gnu_ops.to_post_startup_inferior = NULL;	/* to_post_startup_inferior */
  gnu_ops.to_acknowledge_created_inferior = NULL;	/* to_acknowledge_created_inferior */
  gnu_ops.to_clone_and_follow_inferior = NULL;	/* to_clone_and_follow_inferior */
  gnu_ops.to_post_follow_inferior_by_clone = NULL;	/* to_post_follow_inferior_by_clone */
d2569 1
a2569 1
  gnu_ops.to_has_forked = NULL;	/* to_has_forked */
d2584 1
a2584 1
  gnu_ops.to_pid_to_exec_file = gnu_pid_to_exec_file;	/* to_pid_to_exec_file */
d2587 1
a2587 1
  gnu_ops.DONT_USE = 0;		/* to_next */
d2589 7
a2595 7
  gnu_ops.to_has_memory = 1;	/* to_has_memory */
  gnu_ops.to_has_stack = 1;	/* to_has_stack */
  gnu_ops.to_has_registers = 1;	/* to_has_registers */
  gnu_ops.to_has_execution = 1;	/* to_has_execution */
  gnu_ops.to_sections = 0;	/* sections */
  gnu_ops.to_sections_end = 0;	/* sections_end */
  gnu_ops.to_magic = OPS_MAGIC;	/* to_magic */
d2597 1
d2693 1
d2733 1
d2785 1
d2822 1
a2822 1

a2849 1
  int tid;
d2879 1
a2883 1
  int trace;
d2927 1
d2932 2
a2933 1
  printf_unfiltered ("\"set task\" must be followed by the name of a task property.\n");
d2962 1
d2974 1
d3014 1
d3020 1
d3026 1
d3032 1
d3038 1
d3041 1
a3041 1
add_task_commands ()
d3044 4
a3047 4
	"Set whether the new threads are suspended while gdb has control.\n"
	   "This property normally has no effect because the whole task is\n"
   "suspended, however, that may be disabled with \"set task pause off\".\n"
	   "The default value is \"off\".",
d3052 1
d3054 2
a3055 1
  "Set whether new threads are allowed to run (once gdb has noticed them).",
d3058 2
a3059 1
  "Show whether new threads are allowed to run (once gdb has noticed them).",
d3061 1
d3070 2
a3071 2
	 "Set whether the inferior process's signals will be intercepted.\n"
	   "Mach exceptions (such as breakpoint traps) are not affected.",
d3075 1
a3075 1
	 "Show whether the inferior process's signals will be intercepted.",
d3080 2
a3081 2
	   "Set the thread that gdb thinks is the libc signal thread.\n"
    "This thread is run when delivering a signal to a non-stopped process.",
d3090 3
a3092 2
  "Set whether gdb thinks the inferior process is stopped as with SIGSTOP.\n"
	   "Stopped process will be continued by sending them a signal.",
d3095 2
a3096 1
  "Show whether gdb thinks the inferior process is stopped as with SIGSTOP.",
d3100 3
a3102 3
	 "Set whether exceptions in the inferior process will be trapped.\n"
  "When exceptions are turned off, neither breakpoints nor single-stepping\n"
	   "will work.",
d3107 1
a3107 1
	 "Show whether exceptions in the inferior process will be trapped.",
d3118 5
a3122 5
	   "Set whether the task is suspended while gdb has control.\n"
	   "A value of \"on\" takes effect immediately, otherwise nothing\n"
	   "happens until the next time the program is continued.\n"
	   "When setting this to \"off\", \"set thread default pause on\"\n"
	   "can be used to pause individual threads by default instead.",
d3127 1
d3136 2
a3137 2
	   "Set the task exception port to which we forward exceptions.\n"
	   "The argument should be the value of the send right in the task.",
d3140 2
a3141 1
  add_alias_cmd ("exc-port", "exception-port", no_class, 1, &set_task_cmd_list);
d3146 3
a3148 3
	   "Set task options so that we interfere as little as possible.\n"
	   "This is the same as setting `task pause', `exceptions', and"
	   "`signals' to the opposite value.",
d3158 1
a3158 1
  add_cmd ("port-rights", class_info, info_send_rights_cmd,
d3171 1
a3172 1

d3194 1
a3194 1
		  !sc && thread->inf->pause_sc ? " (but the task is)" : "");
d3217 2
a3218 1
  cur_thread ()->detach_sc = parse_int_arg (args, "set thread detach-suspend-count");
d3226 2
a3227 1
  printf_unfiltered ("Thread %s will be left with a suspend count of %d when detaching.\n",
d3269 2
a3270 1
    vm_deallocate (mach_task_self (), (vm_address_t) info, info_len * sizeof (int));
d3273 3
a3275 1
add_thread_commands ()
d3293 7
a3299 6
      "Set whether the current thread is suspended while gdb has control.\n"
	   "A value of \"on\" takes effect immediately, otherwise nothing\n"
	   "happens until the next time the program is continued.  This\n"
    "property normally has no effect because the whole task is suspended,\n"
	   "however, that may be disabled with \"set task pause off\".\n"
	   "The default value is \"off\".",
d3302 2
a3303 1
      "Show whether the current thread is suspended while gdb has control.",
d3314 3
a3316 3
	   "Set the suspend count will leave on the thread when detaching.\n"
	   "Note that this is relative to suspend count when gdb noticed the thread;\n"
	   "use the `thread takeover-suspend-count' to force it to an absolute value.",
d3319 3
a3321 3
	   "Show the suspend count will leave on the thread when detaching."
	   "Note that this is relative to suspend count when gdb noticed the thread;\n"
	   "use the `thread takeover-suspend-count' to force it to an absolute value.",
d3325 3
a3327 3
	   "Set the exception port to which we forward exceptions for the\n"
	   "current thread, overriding the task exception port.\n"
	   "The argument should be the value of the send right in the task.",
d3330 2
a3331 1
  add_alias_cmd ("exc-port", "exception-port", no_class, 1, &set_thread_cmd_list);
d3334 3
a3336 3
	   "Force the threads absolute suspend-count to be gdb's.\n"
	   "Prior to giving this command, gdb's thread suspend-counts are relative to\n"
	 "the thread's initial suspend-count when gdb notices the threads.",
d3339 1
d3342 1
a3342 1
_initialize_gnu_nat ()
d3345 1
d3348 1
a3350 1

d3353 1
a3353 1
	     "Set debugging output for the gnu backend.", &maintenancelist);
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d2 1
a2 1
   Copyright (C) 1992, 1995, 1996, 1997, 1999 Free Software Foundation, Inc.
a34 5
/* We include this because we don't need the access macros and they conflict
   with gdb's definitions (ick).  This is very non standard!  */
#define _SYS_WAIT_H		/* Inhibit warning from <bits/waitflags.h>.  */
#include <bits/waitflags.h>

d792 2
a793 2
/* Validates INF's task suspend count.  If it's higher than we expect, verify
   with the user before `stealing' the extra count.  */
d797 7
a803 4
  struct task_basic_info info;
  mach_msg_type_number_t info_len = TASK_BASIC_INFO_COUNT;
  error_t err =
  task_info (inf->task->port, TASK_BASIC_INFO, (task_info_t) & info, &info_len);
d805 3
d809 22
a830 2
    inf->task->dead = 1;	/* oh well */
  else if (inf->task->cur_sc < info.suspend_count)
d835 3
a837 3
      abort =
	!query ("Pid %d has an additional task suspend count of %d; clear it? ",
		inf->pid, info.suspend_count - inf->task->cur_sc);
d843 1
a843 1
      inf->task->cur_sc = info.suspend_count;
d1689 4
d2441 1
a2441 1
static char *
@


1.1
log
@Initial revision
@
text
@d1 2
a2 2
/* Interface GDB to the GNU Hurd
   Copyright (C) 1992, 1995, 1996, 1997 Free Software Foundation, Inc.
d22 3
a24 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*/
d27 1
d37 2
a38 1
#include <waitflags.h>
d63 1
a63 1
#include "wait.h"
a89 1
extern char *strerror();
a90 1
int inf_update_procs (struct inf *inf);
d101 2
a102 2
inline void inf_set_threads_resume_sc (struct inf *inf, 
				       struct proc *run_thread, 
d111 1
a117 1
thread_state_t proc_get_state (struct proc *proc, int force);
d121 1
a121 1
error_t proc_get_exception_port (struct proc *proc, mach_port_t *port);
a126 1
char *proc_string (struct proc *proc);
d148 1
a148 1
#define MIG_SERVER_DIED EMIG_SERVER_DIED /* XXX */
d152 6
a157 6
{
  int exception;		/* The exception code */
  int code, subcode;
  mach_port_t handler;		/* The real exception port to handle this. */
  mach_port_t reply;		/* The reply port from the exception call. */
};
d161 6
a166 6
{
  struct target_waitstatus status; /* The status returned to gdb.  */
  struct exc_state exc;		/* The exception that caused us to return. */
  struct proc *thread;		/* The thread in question.  */
  int suppress;			/* Something trivial happened.  */
};
d170 5
a174 2
{
  /* Fields describing the current inferior.  */
d176 5
a180 2
  struct proc *task;		/* The mach task.   */
  struct proc *threads;		/* A linked list of all threads in TASK.  */
d182 1
a182 5
  /* True if THREADS needn't be validated by querying the task.  We assume that
     we and the task in question are the only ones frobbing the thread list,
     so as long as we don't let any code run, we don't have to worry about
     THREADS changing.  */
  int threads_up_to_date;
d184 1
a184 1
  pid_t pid;			/* The real system PID. */
d186 2
a187 1
  struct inf_wait wait;		/* What to return from target_wait.  */
d189 2
a190 2
  /* One thread proc in INF may be in `single-stepping mode'.  This is it.  */
  struct proc *step_thread;
d192 1
a192 2
  /* The thread we think is the signal thread.  */
  struct proc *signal_thread;
d194 3
a196 1
  mach_port_t event_port;	/* Where we receive various msgs.  */
d198 4
a201 3
  /* True if we think at least one thread in the inferior could currently be
     running.  */
  int running : 1;
d203 2
a204 4
  /* True if the process has stopped (in the proc server sense).  Note that
     since a proc server `stop' leaves the signal thread running, the inf can
     be RUNNING && STOPPED...  */
  int stopped : 1;
d206 2
a207 2
  /* True if the inferior is traced.  */
  int traced : 1;
d209 3
a211 3
  /* True if we shouldn't try waiting for the inferior, usually because we
     can't for some reason.  */
  int no_wait : 1;
d213 4
a216 4
  /* When starting a new inferior, we don't try to validate threads until all
     the proper execs have been done.  This is a count of how many execs we
     expect to happen.  */
  unsigned pending_execs;
d218 1
a218 1
  /* Fields describing global state */
d220 5
a224 5
  /* The task suspend count used when gdb has control.  This is normally 1 to
     make things easier for us, but sometimes (like when attaching to vital
     system servers) it may be desirable to let the task continue to run
     (pausing individual threads as necessary).  */
  int pause_sc;
d226 2
a227 2
  /* The task suspend count left when detaching from a task.  */
  int detach_sc;
d229 5
a233 5
  /* The initial values used for the run_sc and pause_sc of newly discovered
     threads -- see the definition of those fields in struct proc.  */
  int default_thread_run_sc;
  int default_thread_pause_sc;
  int default_thread_detach_sc;
d235 4
a238 4
  /* True if the process should be traced when started/attached.  Newly
     started processes *must* be traced at first to exec them properly, but
     if this is false, tracing is turned off as soon it has done so.  */
  int want_signals;
d240 4
a243 4
  /* True if exceptions from the inferior process should be trapped.  This
     must be on to use breakpoints.  */
  int want_exceptions;
};
d246 2
a247 1
int __proc_pid (struct proc *proc)
d258 1
a258 1
  int err =  0;
d270 2
a271 2
			      (thread_state_t)&proc->state, THREAD_STATE_SIZE);
      if (! err)
d288 1
a288 1
  if (! err)
d317 1
a317 1
  if (! proc->aborted)
d333 1
a333 1
      if (! running)
d359 1
a359 1
  if (! was_aborted && proc->aborted)
d363 1
a363 1
  if (! proc->state_valid)
d367 2
a368 2
	thread_get_state (proc->port, THREAD_STATE_FLAVOR,
			  (thread_state_t)&proc->state, &state_size);
d377 1
a377 1
      return (thread_state_t)&proc->state;
d385 1
a385 1
proc_get_exception_port (struct proc *proc, mach_port_t *port)
d395 1
a395 1
proc_set_exception_port (struct proc *proc, mach_port_t port)
d504 1
a504 1
  if (! state)
d508 1
a508 1
  
d512 1
a512 1
	 exception port???? */
d561 1
a561 1
    mach_port_request_notification (mach_task_self(), port,
d623 2
a624 1
struct inf *make_inf ()
d642 1
d644 1
a644 1
  inf->running = 0;
d688 3
a692 2
  inf->stopped = 0;
  inf->running = 0;
d724 1
a724 1
void 
d763 1
a763 1
	inf->task->sc = inf->task->cur_sc = 1; /* Reflect task_suspend above */
d769 4
a772 1
/* Validates INF's stopped field from the actual proc server state.  */
d774 1
a774 1
inf_validate_stopped (struct inf *inf)
d782 2
a783 2
    proc_getprocinfo (proc_server, inf->pid, &info_flags,
		      (procinfo_t *)&pi, &pi_len, &noise, &noise_len);
d785 1
a785 1
  if (! err)
d788 4
a791 1
      vm_deallocate (mach_task_self (), (vm_address_t)pi, pi_len);
d793 1
a793 1
	vm_deallocate (mach_task_self (), (vm_address_t)noise, noise_len);
d805 1
a805 1
    task_info (inf->task->port, TASK_BASIC_INFO, (task_info_t)&info, &info_len);
d817 1
a817 1
      target_terminal_inferior (); /* Give it back to the child.  */
d836 1
a836 1
	sigset_t mask = on ? ~(sigset_t)0 : 0;
d838 2
a839 2
	  INF_RESUME_MSGPORT_RPC (inf, msg_set_init_int (msgport, refport,
							 INIT_TRACEMASK, mask));
d859 1
a859 1
   safe order.  Returns true if at least one thread is thought to be running.*/
d899 1
a899 1
	 threads list any more.  */
d987 1
a987 1
	      i -= num_threads; /* I wrapped around.  */
d999 1
a999 1
	if (! left)
d1003 1
a1003 1
	    thread = _proc_free (thread); /* THREAD is dead.  */
d1019 1
a1019 1
	  add_thread (thread->tid); /* Tell GDB's generic thread code.  */
d1022 2
a1023 2
    vm_deallocate(mach_task_self(),
		  (vm_address_t)threads, (num_threads * sizeof(thread_t)));
d1031 1
a1031 1
  if (! inf->task)
d1033 1
a1033 1
  if (! inf->threads_up_to_date)
d1041 1
a1041 1
inline void 
d1070 1
a1070 1
      if (! inf->pending_execs)
d1115 1
a1115 1
	if (! proc_trace (inf->step_thread, 0))
d1162 2
d1166 6
a1171 1
	inf_signal (inf, TARGET_SIGNAL_0);
d1202 2
a1203 1
void inf_steal_exc_ports (struct inf *inf)
d1217 2
a1218 1
void inf_restore_exc_ports (struct inf *inf)
d1274 31
a1304 31
    if (inf->stopped)
      /* The process is stopped and expecting a signal.  Just send off a
	 request and let it get handled when we resume everything.  */
      {
	inf_debug (inf, "sending %s to stopped process", NAME);
	err =
	  INF_MSGPORT_RPC (inf,
			   msg_sig_post_untraced_request (msgport,
							  inf->event_port,
							  MACH_MSG_TYPE_MAKE_SEND_ONCE,
							  host_sig, 0,
							  refport));
	if (! err)
	  /* Posting an untraced signal automatically continues it.
	     We clear this here rather than when we get the reply
	     because we'd rather assume it's not stopped when it
	     actually is, than the reverse.  */
	  inf->stopped = 0;
      }
    else
      /* It's not expecting it.  We have to let just the signal thread
	 run, and wait for it to get into a reasonable state before we
	 can continue the rest of the process.  When we finally resume the
	 process the signal we request will be the very first thing that
	 happens. */
      {
	inf_debug (inf, "sending %s to unstopped process (so resuming signal thread)", NAME);
	err = 
	  INF_RESUME_MSGPORT_RPC (inf, msg_sig_post_untraced (msgport,
							      host_sig, 0, refport));
      }
d1315 28
d1354 7
a1360 5
  struct msg {
    mach_msg_header_t hdr;
    mach_msg_type_t type;
    int data[8000];
  } msg;
d1381 1
a1381 1
 rewait:
d1406 1
a1406 1
	     which is the wait reply port, changes when you switch processes.*/
d1436 8
a1443 6
      struct {
	mach_msg_header_t hdr;
	mach_msg_type_t err_type;
	kern_return_t err;
	char noise[200];
      } reply;
d1448 4
a1451 4
      if (! notify_server (&msg.hdr, &reply.hdr)
	  && ! exc_server (&msg.hdr, &reply.hdr)
	  && ! process_reply_server (&msg.hdr, &reply.hdr)
	  && ! msg_reply_server (&msg.hdr, &reply.hdr))
d1483 1
a1483 1
#if 0	/* do we need this? */
d1485 1
a1485 1
	      renumber_threads (0); /* Give our threads reasonable names. */
d1523 1
a1523 1
      tid = inferior_pid; /* let wait_for_inferior handle exit case */
d1531 1
a1531 1
    }      
d1571 1
a1571 1
  if (! thread->aborted)
d1671 1
a1671 1
  inf->threads_up_to_date = 0; /* Just in case */
d1824 1
a1824 1
    mach_port_get_receive_status (mach_task_self (), port, &status);
d1847 1
a1847 1
*/
d1856 2
d1859 6
a1864 1
    inf_signal (inf, sig);
d1893 1
a1893 1
      if (! thread)
d1902 1
a1902 1
      if (! step_thread)
d1955 1
a1955 1
  if (! current_inferior)
d1969 10
a1978 10
    {
      /* We're in the child; make this process stop as soon as it execs.  */
      inf_debug (inf, "tracing self");
      if (ptrace (PTRACE_TRACEME) != 0)
	error ("ptrace (PTRACE_TRACEME) failed!");
    }
  int attach_to_child (int pid)
    {
      /* Attach to the now stopped child, which is actually a shell...  */
      inf_debug (inf, "attaching to child: %d", pid);
d1980 1
a1980 1
      inf_attach (inf, pid);
d1982 2
a1983 2
      attach_flag = 0;
      push_target (&gnu_ops);
d1985 3
a1987 2
      inf->pending_execs = 2;
      inf->traced = 1;
d1989 4
a1992 4
      /* Now let the child run again, knowing that it will stop immediately
	 because of the ptrace. */
      inf_resume (inf);
      inferior_pid = inf_pick_first_thread ();
d1994 2
a1995 4
      startup_inferior (inf->pending_execs);

      return inferior_pid;
    }
d1999 2
a2000 1
    fork_inferior (exec_file, allargs, env, trace_me, attach_to_child, NULL, NULL);
d2002 1
d2043 1
a2043 1
  if (pid == getpid())		/* Trying to masturbate? */
d2069 3
a2071 2
  inf_update_signal_thread (inf);
  inf_set_traced (inf, inf->want_signals);
d2075 4
a2078 1
  inf_validate_stopped (inf);
d2080 1
a2080 1
#if 0 /* Do we need this? */
d2107 1
a2107 1
  
d2112 1
a2112 1
  unpush_target (&gnu_ops);		/* Pop out of handling an inferior */
d2151 1
a2151 1
static void
d2155 1
d2157 1
a2157 1
 
d2182 3
a2184 3
    (vm_size_t) round_page (addr+length) - low_address;
  pointer_t    copied;
  int	       copy_count;
d2191 1
a2191 1
  err = hurd_safe_copyin (myaddr, (void*)addr - low_address + copied, length);
d2208 2
a2209 1
struct vm_region_list {
d2211 3
a2213 3
  vm_prot_t	protection;
  vm_address_t  start;
  vm_size_t	length;
d2216 1
a2216 1
struct obstack  region_obstack;
d2230 6
a2235 6
  vm_address_t low_address       = (vm_address_t) trunc_page (addr);
  vm_size_t    aligned_length = 
    			(vm_size_t) round_page (addr+length) - low_address;
  pointer_t    copied;
  int	       copy_count;
  int	       deallocate = 0;
d2237 1
a2237 1
  char         *errstr = "Bug in gnu_write_inferior";
d2240 1
a2240 1
  struct vm_region_list *region_head = (struct vm_region_list *)NULL;
d2252 1
a2252 1
  err = hurd_safe_copyout ((void*)addr - low_address + copied, myaddr, length);
d2261 2
a2262 2
    vm_size_t    remaining_length  = aligned_length;
    vm_address_t region_address    = low_address;
d2266 1
a2266 1
    while(region_address < low_address + aligned_length)
d2274 3
a2276 3
	vm_size_t   region_length = remaining_length;
	vm_address_t old_address  = region_address;
    
d2308 1
a2308 1
	region_element = 
d2310 2
a2311 2
	    obstack_alloc (&region_obstack, sizeof (struct vm_region_list));
    
d2313 2
a2314 2
	region_element->start      = region_address;
	region_element->length     = region_length;
d2318 2
a2319 2
	region_head          = region_element;
	
d2327 1
a2327 1
    
d2332 1
a2332 1
	
d2349 1
a2349 1
	
d2354 1
a2354 1
	
d2367 1
a2367 1
 out:
d2371 1
a2371 1
      
d2397 3
a2399 3
    current_inferior
      ? (current_inferior->task ? current_inferior->task->port : 0)
      : 0;
d2411 1
a2411 1
	return gnu_read_inferior  (task, memaddr, myaddr, len);
a2414 73
extern void gnu_store_registers (int regno);
extern void gnu_fetch_registers (int regno);

struct target_ops gnu_ops ;

static void
init_gnu_ops(void)
{
  gnu_ops.to_shortname =   "GNU";		/* to_shortname */
  gnu_ops.to_longname =   "GNU Hurd process";	/* to_longname */
  gnu_ops.to_doc =   "GNU Hurd process";	/* to_doc */
  gnu_ops.to_open =   gnu_open;			/* to_open */
  gnu_ops.to_close =   0;			/* to_close */
  gnu_ops.to_attach =   gnu_attach;		/* to_attach */
  gnu_ops.to_post_attach = NULL;
  gnu_ops.to_require_attach = NULL;             /* to_require_attach */
  gnu_ops.to_detach =   gnu_detach;	 	/* to_detach */
  gnu_ops.to_require_detach = NULL;             /* to_require_detach */
  gnu_ops.to_resume =   gnu_resume;		/* to_resume */
  gnu_ops.to_wait  =   gnu_wait;		/* to_wait */
  gnu_ops.to_post_wait = NULL;                         /* to_post_wait */
  gnu_ops.to_fetch_registers  =   gnu_fetch_registers;	/* to_fetch_registers */
  gnu_ops.to_store_registers  =   gnu_store_registers;	/* to_store_registers */
  gnu_ops.to_prepare_to_store =   gnu_prepare_to_store;	/* to_prepare_to_store */
  gnu_ops.to_xfer_memory  =   gnu_xfer_memory;	/* to_xfer_memory */
  gnu_ops.to_files_info  =   0;			/* to_files_info */
  gnu_ops.to_insert_breakpoint =   memory_insert_breakpoint;
  gnu_ops.to_remove_breakpoint =   memory_remove_breakpoint;
  gnu_ops.to_terminal_init  =   gnu_terminal_init_inferior;
  gnu_ops.to_terminal_inferior =   terminal_inferior;
  gnu_ops.to_terminal_ours_for_output =   terminal_ours_for_output;
  gnu_ops.to_terminal_ours  =   terminal_ours;
  gnu_ops.to_terminal_info  =   child_terminal_info;	
  gnu_ops.to_kill  =   gnu_kill_inferior;	/* to_kill */
  gnu_ops.to_load  =   0;			/* to_load */
  gnu_ops.to_lookup_symbol =   0;		/* to_lookup_symbol */
  gnu_ops.to_create_inferior =   gnu_create_inferior;	/* to_create_inferior */
  gnu_ops.to_post_startup_inferior = NULL;      /* to_post_startup_inferior */
  gnu_ops.to_acknowledge_created_inferior = NULL; /* to_acknowledge_created_inferior */
  gnu_ops.to_clone_and_follow_inferior = NULL;    /* to_clone_and_follow_inferior */
  gnu_ops.to_post_follow_inferior_by_clone = NULL; /* to_post_follow_inferior_by_clone */
  gnu_ops.to_insert_fork_catchpoint = NULL;
  gnu_ops.to_remove_fork_catchpoint = NULL;
  gnu_ops.to_insert_vfork_catchpoint = NULL;
  gnu_ops.to_remove_vfork_catchpoint = NULL;
  gnu_ops.to_has_forked = NULL;                    /* to_has_forked */
  gnu_ops.to_has_vforked = NULL;                   /* to_has_vforked */
  gnu_ops.to_can_follow_vfork_prior_to_exec = NULL;
  gnu_ops.to_post_follow_vfork = NULL;             /* to_post_follow_vfork */
  gnu_ops.to_insert_exec_catchpoint = NULL;
  gnu_ops.to_remove_exec_catchpoint = NULL;
  gnu_ops.to_has_execd = NULL;
  gnu_ops.to_reported_exec_events_per_exec_call = NULL;
  gnu_ops.to_has_exited = NULL;
  gnu_ops.to_mourn_inferior =   gnu_mourn_inferior; /* to_mourn_inferior */
  gnu_ops.to_can_run  =   gnu_can_run;		/* to_can_run */
  gnu_ops.to_notice_signals =   0;		/* to_notice_signals */
  gnu_ops.to_thread_alive  =   gnu_thread_alive;/* to_thread_alive */
  gnu_ops.to_stop  =   gnu_stop;		/* to_stop */
  gnu_ops.to_pid_to_exec_file = gnu_pid_to_exec_file;         /* to_pid_to_exec_file */
  gnu_ops.to_core_file_to_sym_file = NULL;
  gnu_ops.to_stratum =   process_stratum;	/* to_stratum */
  gnu_ops.DONT_USE =   0;			/* to_next */
  gnu_ops.to_has_all_memory =   1;		/* to_has_all_memory */
  gnu_ops.to_has_memory =   1;			/* to_has_memory */
  gnu_ops.to_has_stack =   1;			/* to_has_stack */
  gnu_ops.to_has_registers =   1;		/* to_has_registers */
  gnu_ops.to_has_execution =   1;		/* to_has_execution */
  gnu_ops.to_sections =   0;			/* sections */
  gnu_ops.to_sections_end =   0;		/* sections_end */
  gnu_ops.to_magic =   OPS_MAGIC ;		/* to_magic */
} /* init_gnu_ops */

d2416 2
a2417 1
char *proc_string (struct proc *proc)
d2428 2
a2429 2
char *
gnu_target_pid_to_str (int tid)
d2444 74
d2536 1
a2536 2
  printf_unfiltered ("\"set thread\" must be followed by the name of a thread
property, or \"default\".\n");
d2608 1
a2608 1
  if (! inf->task)
d2728 1
a2728 1
  if (! proc->exc_port)
d2732 4
a2735 4
       proc->exc_port = proc->inf->event_port;
       err = proc_set_exception_port (proc, proc->exc_port);
       error ("Can't set exception port for %s: %s",
	      proc_string (proc), strerror (err));
d2748 1
a2748 1
static void 
d2763 1
a2763 1
static void 
d2769 1
a2769 1
  if (!args || (! isdigit (*args) && strcmp (args, "none") != 0))
d2797 1
a2797 1
static void 
d2821 1
a2821 1
static void 
d2829 1
a2829 1
    /* XXX */;
d2903 2
a2904 2
	    print_port_info (right, 0, inf->task->port, PORTINFO_DETAILS,
			     stdout);
d2913 2
a2914 2
	print_task_ports_info (inf->task->port, only, PORTINFO_DETAILS,
			       stdout);
d2948 2
a2949 1
static void add_task_commands ()
d2952 1
a2952 1
	   "Set whether the new threads are suspended while gdb has control.\n"
d2954 1
a2954 1
	   "suspended, however, that may be disabled with \"set task pause off\".\n"
d2961 1
a2961 1
	   "Set whether new threads are allowed to run (once gdb has noticed them).",
d2964 1
a2964 2
	   "Show whether new threads are allowed to run (once gdb has noticed
them).",
d2974 1
a2974 1
	   "Set whether the inferior process's signals will be intercepted.\n"
d2979 1
a2979 1
	   "Show whether the inferior process's signals will be intercepted.",
d2985 1
a2985 1
	   "This thread is run when delivering a signal to a non-stopped process.",
d2994 1
a2994 1
	   "Set whether gdb thinks the inferior process is stopped as with SIGSTOP.\n"
d2998 1
a2998 1
	   "Show whether gdb thinks the inferior process is stopped as with SIGSTOP.",
d3002 2
a3003 2
	   "Set whether exceptions in the inferior process will be trapped.\n"
	   "When exceptions are turned off, neither breakpoints nor single-stepping\n"
d3009 1
a3009 1
	   "Show whether exceptions in the inferior process will be trapped.",
d3094 1
a3094 1
		     !sc && thread->inf->pause_sc ? " (but the task is)" : "");
d3160 1
a3160 1
    thread_info (thread->port, THREAD_BASIC_INFO, (int *)&info, &info_len);
d3167 1
a3167 1
    vm_deallocate (mach_task_self (), (vm_address_t)info, info_len * sizeof (int));
d3188 1
a3188 1
	   "Set whether the current thread is suspended while gdb has control.\n"
d3191 1
a3191 1
	   "property normally has no effect because the whole task is suspended,\n"
d3196 1
a3196 1
	   "Show whether the current thread is suspended while gdb has control.",
d3228 1
a3228 1
	   "the thread's initial suspend-count when gdb notices the threads.",
d3236 1
a3236 1
  init_gnu_ops() ;
a3240 1
#if MAINTENANCE_CMDS
d3242 2
a3243 3
	       var_boolean, (char *)&gnu_debug_flag,
	       "Set debugging output for the gnu backend.", &maintenancelist);
#endif
d3254 1
a3254 1
flush_inferior_icache(pc, amount)
d3258 2
a3259 2
  error_t   ret;
  
d3268 1
a3268 1
#endif	FLUSH_INFERIOR_CACHE
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a25 1
#include <string.h>
d35 1
a35 2
#define _SYS_WAIT_H		/* Inhibit warning from <bits/waitflags.h>.  */
#include <bits/waitflags.h>
d87 1
d1914 1
a1914 1
  void attach_to_child (int pid)
d1933 2
d1939 1
a1939 2
  fork_inferior (exec_file, allargs, env, trace_me, attach_to_child,
		 NULL, NULL);
d2085 1
a2085 1
static char *
a2088 1
  return NULL;
d3172 1
d3176 1
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@a2006 4
  /* We have to initialize the terminal settings now, since the code
     below might try to restore them.  */
  target_terminal_init ();
 
@


1.1.1.4
log
@import gdb-1999-06-07 snapshot
@
text
@d2 1
a2 1
   Copyright (C) 1992, 1995, 1996, 1997, 1999 Free Software Foundation, Inc.
a110 1
void inf_continue (struct inf *inf);
d197 1
a197 1
  unsigned int running : 1;
d202 1
a202 4
  unsigned int stopped : 1;

  /* True if the inferior has no message port.  */
  unsigned int nomsg : 1;
d205 1
a205 1
  unsigned int traced : 1;
d209 1
a209 1
  unsigned int no_wait : 1;
d638 1
a639 2
  inf->stopped = 0;
  inf->nomsg = 1;
a682 3
  inf->running = 0;
  inf->stopped = 0;
  inf->nomsg = 1;
d685 2
d763 1
a763 4
/* Validates INF's stopped, nomsg and traced field from the actual
   proc server state.  Note that the traced field is only updated from
   the proc server state if we do not have a message port.  If we do
   have a message port we'd better look at the tracemask itself.  */
d765 1
a765 1
inf_validate_procinfo (struct inf *inf)
a778 3
      inf->nomsg = !!(pi->state & PI_NOMSG);
      if (inf->nomsg)
	inf->traced = !!(pi->state & PI_TRACED);
a1149 2
      inf_validate_procinfo (inf);

d1152 1
a1152 6
	{
	  if (inf->nomsg)
	    inf_continue (inf);
	  else
	    inf_signal (inf, TARGET_SIGNAL_0);
	}
a1293 28
/* Continue INF without delivering a signal.  This is meant to be used
   when INF does not have a message port.  */
void
inf_continue (struct inf *inf)
{
  process_t proc;
  error_t err = proc_pid2proc (proc_server, inf->pid, &proc);

  if (! err)
    {
      inf_debug (inf, "continuing process");

      err = proc_mark_cont (proc);
      if (! err)
	{
	  struct proc *thread;

	  for (thread = inf->threads; thread; thread = thread->next)
	    thread_resume (thread->port);
	  
	  inf->stopped = 0;
	}
    }

  if (err)
    warning ("Can't continue process: %s", strerror (err));
}

a1802 2
  inf_validate_procinfo (inf);
  
d1804 1
a1804 6
    {
      if (sig == TARGET_SIGNAL_0 && inf->nomsg)
	inf_continue (inf);
      else
	inf_signal (inf, sig);
    }
a1925 1
      inf->nomsg = 1;
a1940 1
  inf_validate_procinfo (inf);
d2010 4
a2013 1
  
d2016 1
a2016 4
  inf_validate_procinfo (inf);

  inf_update_signal_thread (inf);
  inf_set_traced (inf, inf->want_signals);
@


1.1.1.5
log
@import gdb-1999-07-07 pre reformat
@
text
@d2527 2
a2528 1
  printf_unfiltered ("\"set thread\" must be followed by the name of a thread property, or \"default\".\n");
d2955 2
a2956 1
	   "Show whether new threads are allowed to run (once gdb has noticed them).",
@


1.1.1.6
log
@import gdb-1999-07-07 post reformat
@
text
@d22 2
a23 3
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.
 */
d101 2
a102 2
inline void inf_set_threads_resume_sc (struct inf *inf,
				       struct proc *run_thread,
d122 1
a122 1
error_t proc_get_exception_port (struct proc *proc, mach_port_t * port);
d150 1
a150 1
#define MIG_SERVER_DIED EMIG_SERVER_DIED	/* XXX */
d154 6
a159 6
  {
    int exception;		/* The exception code */
    int code, subcode;
    mach_port_t handler;	/* The real exception port to handle this. */
    mach_port_t reply;		/* The reply port from the exception call. */
  };
d163 6
a168 6
  {
    struct target_waitstatus status;	/* The status returned to gdb.  */
    struct exc_state exc;	/* The exception that caused us to return. */
    struct proc *thread;	/* The thread in question.  */
    int suppress;		/* Something trivial happened.  */
  };
d172 2
a173 2
  {
    /* Fields describing the current inferior.  */
d175 2
a176 2
    struct proc *task;		/* The mach task.   */
    struct proc *threads;	/* A linked list of all threads in TASK.  */
d178 5
a182 5
    /* True if THREADS needn't be validated by querying the task.  We assume that
       we and the task in question are the only ones frobbing the thread list,
       so as long as we don't let any code run, we don't have to worry about
       THREADS changing.  */
    int threads_up_to_date;
d184 1
a184 1
    pid_t pid;			/* The real system PID. */
d186 1
a186 1
    struct inf_wait wait;	/* What to return from target_wait.  */
d188 2
a189 2
    /* One thread proc in INF may be in `single-stepping mode'.  This is it.  */
    struct proc *step_thread;
d191 2
a192 2
    /* The thread we think is the signal thread.  */
    struct proc *signal_thread;
d194 1
a194 1
    mach_port_t event_port;	/* Where we receive various msgs.  */
d196 3
a198 3
    /* True if we think at least one thread in the inferior could currently be
       running.  */
    unsigned int running:1;
d200 4
a203 4
    /* True if the process has stopped (in the proc server sense).  Note that
       since a proc server `stop' leaves the signal thread running, the inf can
       be RUNNING && STOPPED...  */
    unsigned int stopped:1;
d205 2
a206 2
    /* True if the inferior has no message port.  */
    unsigned int nomsg:1;
d208 2
a209 2
    /* True if the inferior is traced.  */
    unsigned int traced:1;
d211 3
a213 3
    /* True if we shouldn't try waiting for the inferior, usually because we
       can't for some reason.  */
    unsigned int no_wait:1;
d215 4
a218 4
    /* When starting a new inferior, we don't try to validate threads until all
       the proper execs have been done.  This is a count of how many execs we
       expect to happen.  */
    unsigned pending_execs;
d220 1
a220 1
    /* Fields describing global state */
d222 5
a226 5
    /* The task suspend count used when gdb has control.  This is normally 1 to
       make things easier for us, but sometimes (like when attaching to vital
       system servers) it may be desirable to let the task continue to run
       (pausing individual threads as necessary).  */
    int pause_sc;
d228 2
a229 2
    /* The task suspend count left when detaching from a task.  */
    int detach_sc;
d231 5
a235 5
    /* The initial values used for the run_sc and pause_sc of newly discovered
       threads -- see the definition of those fields in struct proc.  */
    int default_thread_run_sc;
    int default_thread_pause_sc;
    int default_thread_detach_sc;
d237 4
a240 4
    /* True if the process should be traced when started/attached.  Newly
       started processes *must* be traced at first to exec them properly, but
       if this is false, tracing is turned off as soon it has done so.  */
    int want_signals;
d242 4
a245 4
    /* True if exceptions from the inferior process should be trapped.  This
       must be on to use breakpoints.  */
    int want_exceptions;
  };
d248 1
a248 2
int
__proc_pid (struct proc *proc)
d259 1
a259 1
  int err = 0;
d271 2
a272 2
			 (thread_state_t) & proc->state, THREAD_STATE_SIZE);
      if (!err)
d289 1
a289 1
  if (!err)
d318 1
a318 1
  if (!proc->aborted)
d334 1
a334 1
      if (!running)
d360 1
a360 1
  if (!was_aborted && proc->aborted)
d364 1
a364 1
  if (!proc->state_valid)
d368 2
a369 2
      thread_get_state (proc->port, THREAD_STATE_FLAVOR,
			(thread_state_t) & proc->state, &state_size);
d378 1
a378 1
      return (thread_state_t) & proc->state;
d386 1
a386 1
proc_get_exception_port (struct proc * proc, mach_port_t * port)
d396 1
a396 1
proc_set_exception_port (struct proc * proc, mach_port_t port)
d505 1
a505 1
  if (!state)
d509 1
a509 1

d513 1
a513 1
         exception port???? */
d562 1
a562 1
    mach_port_request_notification (mach_task_self (), port,
d624 1
a624 2
struct inf *
make_inf ()
d724 1
a724 1
void
d763 1
a763 1
	inf->task->sc = inf->task->cur_sc = 1;	/* Reflect task_suspend above */
d782 2
a783 2
  proc_getprocinfo (proc_server, inf->pid, &info_flags,
		    (procinfo_t *) & pi, &pi_len, &noise, &noise_len);
d785 1
a785 1
  if (!err)
d791 1
a791 1
      vm_deallocate (mach_task_self (), (vm_address_t) pi, pi_len);
d793 1
a793 1
	vm_deallocate (mach_task_self (), (vm_address_t) noise, noise_len);
d805 1
a805 1
  task_info (inf->task->port, TASK_BASIC_INFO, (task_info_t) & info, &info_len);
d817 1
a817 1
      target_terminal_inferior ();	/* Give it back to the child.  */
d836 1
a836 1
	sigset_t mask = on ? ~(sigset_t) 0 : 0;
d838 2
a839 2
	INF_RESUME_MSGPORT_RPC (inf, msg_set_init_int (msgport, refport,
						     INIT_TRACEMASK, mask));
d859 1
a859 1
   safe order.  Returns true if at least one thread is thought to be running. */
d899 1
a899 1
         threads list any more.  */
d987 1
a987 1
	      i -= num_threads;	/* I wrapped around.  */
d999 1
a999 1
	if (!left)
d1003 1
a1003 1
	    thread = _proc_free (thread);	/* THREAD is dead.  */
d1019 1
a1019 1
	  add_thread (thread->tid);	/* Tell GDB's generic thread code.  */
d1022 2
a1023 2
    vm_deallocate (mach_task_self (),
		 (vm_address_t) threads, (num_threads * sizeof (thread_t)));
d1031 1
a1031 1
  if (!inf->task)
d1033 1
a1033 1
  if (!inf->threads_up_to_date)
d1041 1
a1041 1
inline void
d1070 1
a1070 1
      if (!inf->pending_execs)
d1115 1
a1115 1
	if (!proc_trace (inf->step_thread, 0))
d1202 1
a1202 2
void
inf_steal_exc_ports (struct inf *inf)
d1216 1
a1216 2
void
inf_restore_exc_ports (struct inf *inf)
d1272 31
a1302 31
  if (inf->stopped)
    /* The process is stopped and expecting a signal.  Just send off a
       request and let it get handled when we resume everything.  */
    {
      inf_debug (inf, "sending %s to stopped process", NAME);
      err =
	INF_MSGPORT_RPC (inf,
			 msg_sig_post_untraced_request (msgport,
							inf->event_port,
					       MACH_MSG_TYPE_MAKE_SEND_ONCE,
							host_sig, 0,
							refport));
      if (!err)
	/* Posting an untraced signal automatically continues it.
	   We clear this here rather than when we get the reply
	   because we'd rather assume it's not stopped when it
	   actually is, than the reverse.  */
	inf->stopped = 0;
    }
  else
    /* It's not expecting it.  We have to let just the signal thread
       run, and wait for it to get into a reasonable state before we
       can continue the rest of the process.  When we finally resume the
       process the signal we request will be the very first thing that
       happens. */
    {
      inf_debug (inf, "sending %s to unstopped process (so resuming signal thread)", NAME);
      err =
	INF_RESUME_MSGPORT_RPC (inf, msg_sig_post_untraced (msgport,
						     host_sig, 0, refport));
    }
d1321 1
a1321 1
  if (!err)
d1326 1
a1326 1
      if (!err)
d1332 1
a1332 1

d1352 5
a1356 7
  struct msg
    {
      mach_msg_header_t hdr;
      mach_msg_type_t type;
      int data[8000];
    }
  msg;
d1377 1
a1377 1
rewait:
d1402 1
a1402 1
	     which is the wait reply port, changes when you switch processes. */
d1432 6
a1437 8
      struct
	{
	  mach_msg_header_t hdr;
	  mach_msg_type_t err_type;
	  kern_return_t err;
	  char noise[200];
	}
      reply;
d1442 4
a1445 4
      if (!notify_server (&msg.hdr, &reply.hdr)
	  && !exc_server (&msg.hdr, &reply.hdr)
	  && !process_reply_server (&msg.hdr, &reply.hdr)
	  && !msg_reply_server (&msg.hdr, &reply.hdr))
d1477 1
a1477 1
#if 0				/* do we need this? */
d1479 1
a1479 1
	      renumber_threads (0);	/* Give our threads reasonable names. */
d1517 1
a1517 1
      tid = inferior_pid;	/* let wait_for_inferior handle exit case */
d1525 1
a1525 1
    }
d1565 1
a1565 1
  if (!thread->aborted)
d1665 1
a1665 1
  inf->threads_up_to_date = 0;	/* Just in case */
d1818 1
a1818 1
  mach_port_get_receive_status (mach_task_self (), port, &status);
d1841 1
a1841 1
 */
d1851 1
a1851 1

d1887 1
a1887 1
      if (!thread)
d1896 1
a1896 1
      if (!step_thread)
d1949 1
a1949 1
  if (!current_inferior)
d1963 6
a1968 6
  {
    /* We're in the child; make this process stop as soon as it execs.  */
    inf_debug (inf, "tracing self");
    if (ptrace (PTRACE_TRACEME) != 0)
      error ("ptrace (PTRACE_TRACEME) failed!");
  }
d1970 3
a1972 3
  {
    /* Attach to the now stopped child, which is actually a shell...  */
    inf_debug (inf, "attaching to child: %d", pid);
d1974 1
a1974 1
    inf_attach (inf, pid);
d1976 2
a1977 2
    attach_flag = 0;
    push_target (&gnu_ops);
d1979 3
a1981 3
    inf->pending_execs = 2;
    inf->nomsg = 1;
    inf->traced = 1;
d1983 4
a1986 4
    /* Now let the child run again, knowing that it will stop immediately
       because of the ptrace. */
    inf_resume (inf);
    inferior_pid = inf_pick_first_thread ();
d1988 2
a1989 2
    startup_inferior (inf->pending_execs);
  }
d2008 1
a2008 1
  proceed ((CORE_ADDR) - 1, 0, 0);
d2037 1
a2037 1
  if (pid == getpid ())		/* Trying to masturbate? */
d2066 1
a2066 1

d2074 1
a2074 1
#if 0				/* Do we need this? */
d2101 1
a2101 1

d2106 1
a2106 1
  unpush_target (&gnu_ops);	/* Pop out of handling an inferior */
d2151 1
a2151 1

d2176 3
a2178 3
  (vm_size_t) round_page (addr + length) - low_address;
  pointer_t copied;
  int copy_count;
d2185 1
a2185 1
  err = hurd_safe_copyin (myaddr, (void *) addr - low_address + copied, length);
d2202 1
a2202 2
struct vm_region_list
{
d2204 3
a2206 3
  vm_prot_t protection;
  vm_address_t start;
  vm_size_t length;
d2209 1
a2209 1
struct obstack region_obstack;
d2223 6
a2228 6
  vm_address_t low_address = (vm_address_t) trunc_page (addr);
  vm_size_t aligned_length =
  (vm_size_t) round_page (addr + length) - low_address;
  pointer_t copied;
  int copy_count;
  int deallocate = 0;
d2230 1
a2230 1
  char *errstr = "Bug in gnu_write_inferior";
d2233 1
a2233 1
  struct vm_region_list *region_head = (struct vm_region_list *) NULL;
d2245 1
a2245 1
  err = hurd_safe_copyout ((void *) addr - low_address + copied, myaddr, length);
d2254 2
a2255 2
    vm_size_t remaining_length = aligned_length;
    vm_address_t region_address = low_address;
d2259 1
a2259 1
    while (region_address < low_address + aligned_length)
d2267 3
a2269 3
	vm_size_t region_length = remaining_length;
	vm_address_t old_address = region_address;

d2301 1
a2301 1
	region_element =
d2303 2
a2304 2
	  obstack_alloc (&region_obstack, sizeof (struct vm_region_list));

d2306 2
a2307 2
	region_element->start = region_address;
	region_element->length = region_length;
d2311 2
a2312 2
	region_head = region_element;

d2320 1
a2320 1

d2325 1
a2325 1

d2342 1
a2342 1

d2347 1
a2347 1

d2360 1
a2360 1
out:
d2364 1
a2364 1

d2390 3
a2392 3
  current_inferior
  ? (current_inferior->task ? current_inferior->task->port : 0)
  : 0;
d2404 1
a2404 1
	return gnu_read_inferior (task, memaddr, myaddr, len);
d2411 1
a2411 1
struct target_ops gnu_ops;
d2414 1
a2414 1
init_gnu_ops (void)
d2416 6
a2421 6
  gnu_ops.to_shortname = "GNU";	/* to_shortname */
  gnu_ops.to_longname = "GNU Hurd process";	/* to_longname */
  gnu_ops.to_doc = "GNU Hurd process";	/* to_doc */
  gnu_ops.to_open = gnu_open;	/* to_open */
  gnu_ops.to_close = 0;		/* to_close */
  gnu_ops.to_attach = gnu_attach;	/* to_attach */
d2423 26
a2448 26
  gnu_ops.to_require_attach = NULL;	/* to_require_attach */
  gnu_ops.to_detach = gnu_detach;	/* to_detach */
  gnu_ops.to_require_detach = NULL;	/* to_require_detach */
  gnu_ops.to_resume = gnu_resume;	/* to_resume */
  gnu_ops.to_wait = gnu_wait;	/* to_wait */
  gnu_ops.to_post_wait = NULL;	/* to_post_wait */
  gnu_ops.to_fetch_registers = gnu_fetch_registers;	/* to_fetch_registers */
  gnu_ops.to_store_registers = gnu_store_registers;	/* to_store_registers */
  gnu_ops.to_prepare_to_store = gnu_prepare_to_store;	/* to_prepare_to_store */
  gnu_ops.to_xfer_memory = gnu_xfer_memory;	/* to_xfer_memory */
  gnu_ops.to_files_info = 0;	/* to_files_info */
  gnu_ops.to_insert_breakpoint = memory_insert_breakpoint;
  gnu_ops.to_remove_breakpoint = memory_remove_breakpoint;
  gnu_ops.to_terminal_init = gnu_terminal_init_inferior;
  gnu_ops.to_terminal_inferior = terminal_inferior;
  gnu_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  gnu_ops.to_terminal_ours = terminal_ours;
  gnu_ops.to_terminal_info = child_terminal_info;
  gnu_ops.to_kill = gnu_kill_inferior;	/* to_kill */
  gnu_ops.to_load = 0;		/* to_load */
  gnu_ops.to_lookup_symbol = 0;	/* to_lookup_symbol */
  gnu_ops.to_create_inferior = gnu_create_inferior;	/* to_create_inferior */
  gnu_ops.to_post_startup_inferior = NULL;	/* to_post_startup_inferior */
  gnu_ops.to_acknowledge_created_inferior = NULL;	/* to_acknowledge_created_inferior */
  gnu_ops.to_clone_and_follow_inferior = NULL;	/* to_clone_and_follow_inferior */
  gnu_ops.to_post_follow_inferior_by_clone = NULL;	/* to_post_follow_inferior_by_clone */
d2453 2
a2454 2
  gnu_ops.to_has_forked = NULL;	/* to_has_forked */
  gnu_ops.to_has_vforked = NULL;	/* to_has_vforked */
d2456 1
a2456 1
  gnu_ops.to_post_follow_vfork = NULL;	/* to_post_follow_vfork */
d2462 6
a2467 6
  gnu_ops.to_mourn_inferior = gnu_mourn_inferior;	/* to_mourn_inferior */
  gnu_ops.to_can_run = gnu_can_run;	/* to_can_run */
  gnu_ops.to_notice_signals = 0;	/* to_notice_signals */
  gnu_ops.to_thread_alive = gnu_thread_alive;	/* to_thread_alive */
  gnu_ops.to_stop = gnu_stop;	/* to_stop */
  gnu_ops.to_pid_to_exec_file = gnu_pid_to_exec_file;	/* to_pid_to_exec_file */
d2469 11
a2479 11
  gnu_ops.to_stratum = process_stratum;		/* to_stratum */
  gnu_ops.DONT_USE = 0;		/* to_next */
  gnu_ops.to_has_all_memory = 1;	/* to_has_all_memory */
  gnu_ops.to_has_memory = 1;	/* to_has_memory */
  gnu_ops.to_has_stack = 1;	/* to_has_stack */
  gnu_ops.to_has_registers = 1;	/* to_has_registers */
  gnu_ops.to_has_execution = 1;	/* to_has_execution */
  gnu_ops.to_sections = 0;	/* sections */
  gnu_ops.to_sections_end = 0;	/* sections_end */
  gnu_ops.to_magic = OPS_MAGIC;	/* to_magic */
}				/* init_gnu_ops */
d2482 1
a2482 2
char *
proc_string (struct proc *proc)
d2599 1
a2599 1
  if (!inf->task)
d2719 1
a2719 1
  if (!proc->exc_port)
d2723 4
a2726 4
      proc->exc_port = proc->inf->event_port;
      err = proc_set_exception_port (proc, proc->exc_port);
      error ("Can't set exception port for %s: %s",
	     proc_string (proc), strerror (err));
d2739 1
a2739 1
static void
d2754 1
a2754 1
static void
d2760 1
a2760 1
  if (!args || (!isdigit (*args) && strcmp (args, "none") != 0))
d2788 1
a2788 1
static void
d2812 1
a2812 1
static void
d2820 1
a2820 1
    /* XXX */ ;
d2894 2
a2895 2
	  print_port_info (right, 0, inf->task->port, PORTINFO_DETAILS,
			   stdout);
d2904 2
a2905 2
      print_task_ports_info (inf->task->port, only, PORTINFO_DETAILS,
			     stdout);
d2939 1
a2939 2
static void
add_task_commands ()
d2942 1
a2942 1
	"Set whether the new threads are suspended while gdb has control.\n"
d2944 1
a2944 1
   "suspended, however, that may be disabled with \"set task pause off\".\n"
d2951 1
a2951 1
  "Set whether new threads are allowed to run (once gdb has noticed them).",
d2954 1
a2954 1
  "Show whether new threads are allowed to run (once gdb has noticed them).",
d2964 1
a2964 1
	 "Set whether the inferior process's signals will be intercepted.\n"
d2969 1
a2969 1
	 "Show whether the inferior process's signals will be intercepted.",
d2975 1
a2975 1
    "This thread is run when delivering a signal to a non-stopped process.",
d2984 1
a2984 1
  "Set whether gdb thinks the inferior process is stopped as with SIGSTOP.\n"
d2988 1
a2988 1
  "Show whether gdb thinks the inferior process is stopped as with SIGSTOP.",
d2992 2
a2993 2
	 "Set whether exceptions in the inferior process will be trapped.\n"
  "When exceptions are turned off, neither breakpoints nor single-stepping\n"
d2999 1
a2999 1
	 "Show whether exceptions in the inferior process will be trapped.",
d3084 1
a3084 1
		  !sc && thread->inf->pause_sc ? " (but the task is)" : "");
d3150 1
a3150 1
  thread_info (thread->port, THREAD_BASIC_INFO, (int *) &info, &info_len);
d3157 1
a3157 1
    vm_deallocate (mach_task_self (), (vm_address_t) info, info_len * sizeof (int));
d3178 1
a3178 1
      "Set whether the current thread is suspended while gdb has control.\n"
d3181 1
a3181 1
    "property normally has no effect because the whole task is suspended,\n"
d3186 1
a3186 1
      "Show whether the current thread is suspended while gdb has control.",
d3218 1
a3218 1
	 "the thread's initial suspend-count when gdb notices the threads.",
d3226 1
a3226 1
  init_gnu_ops ();
d3232 2
a3233 2
	       var_boolean, (char *) &gnu_debug_flag,
	     "Set debugging output for the gnu backend.", &maintenancelist);
d3244 1
a3244 1
flush_inferior_icache (pc, amount)
d3248 2
a3249 2
  error_t ret;

d3258 1
a3258 1
#endif /* FLUSH_INFERIOR_CACHE */
@


1.1.1.7
log
@import gdb-1999-10-04 snapshot
@
text
@d2017 1
a2017 1
  proceed ((CORE_ADDR) -1, 0, 0);
@


1.1.1.8
log
@import gdb-1999-12-21 snapshot
@
text
@a2417 29
/* Return printable description of proc.  */
static char *
proc_string (struct proc *proc)
{
  static char tid_str[80];
  if (proc_is_task (proc))
    sprintf (tid_str, "process %d", proc->inf->pid);
  else
    sprintf (tid_str, "thread %d.%d",
	     proc->inf->pid, pid_to_thread_id (proc->tid));
  return tid_str;
}

static char *
gnu_pid_to_str (int tid)
{
  struct inf *inf = current_inferior;
  struct proc *thread = inf_tid_to_thread (inf, tid);

  if (thread)
    return proc_string (thread);
  else
    {
      static char tid_str[80];
      sprintf (tid_str, "bogus thread id %d", tid);
      return tid_str;
    }
}

a2475 1
  gnu_ops.to_pid_to_str = gnu_pid_to_str;   /* to_pid_to_str */
d2490 29
@


1.1.1.9
log
@import gdb-2000-01-31 snapshot
@
text
@d1 1
a1 1
/* Interface GDB to the GNU Hurd.
d91 1
d119 1
d129 1
@


