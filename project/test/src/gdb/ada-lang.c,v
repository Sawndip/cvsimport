head	1.414;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.395
	gdb_7_6-2013-04-26-release:1.395
	gdb_7_6-branch:1.395.0.2
	gdb_7_6-2013-03-12-branchpoint:1.395
	gdb_7_5_1-2012-11-29-release:1.373
	gdb_7_5-2012-08-17-release:1.373
	gdb_7_5-branch:1.373.0.2
	gdb_7_5-2012-07-18-branchpoint:1.373
	gdb_7_4_1-2012-04-26-release:1.323.2.2
	gdb_7_4-2012-01-24-release:1.323.2.2
	gdb_7_4-branch:1.323.0.2
	gdb_7_4-2011-12-13-branchpoint:1.323
	gdb_7_3_1-2011-09-04-release:1.292.2.3
	gdb_7_3-2011-07-26-release:1.292.2.3
	gdb_7_3-branch:1.292.0.2
	gdb_7_3-2011-04-01-branchpoint:1.292
	gdb_7_2-2010-09-02-release:1.266
	gdb_7_2-branch:1.266.0.2
	gdb_7_2-2010-07-07-branchpoint:1.266
	gdb_7_1-2010-03-18-release:1.248
	gdb_7_1-branch:1.248.0.2
	gdb_7_1-2010-02-18-branchpoint:1.248
	gdb_7_0_1-2009-12-22-release:1.229
	gdb_7_0-2009-10-06-release:1.229
	gdb_7_0-branch:1.229.0.4
	gdb_7_0-2009-09-16-branchpoint:1.229
	arc-sim-20090309:1.135
	msnyder-checkpoint-072509-branch:1.229.0.2
	msnyder-checkpoint-072509-branchpoint:1.229
	arc-insight_6_8-branch:1.135.0.6
	arc-insight_6_8-branchpoint:1.135
	insight_6_8-branch:1.135.0.4
	insight_6_8-branchpoint:1.135
	reverse-20081226-branch:1.185.0.2
	reverse-20081226-branchpoint:1.185
	multiprocess-20081120-branch:1.183.0.2
	multiprocess-20081120-branchpoint:1.183
	reverse-20080930-branch:1.176.0.2
	reverse-20080930-branchpoint:1.176
	reverse-20080717-branch:1.150.0.2
	reverse-20080717-branchpoint:1.150
	msnyder-reverse-20080609-branch:1.149.0.2
	msnyder-reverse-20080609-branchpoint:1.149
	drow-reverse-20070409-branch:1.95.0.2
	drow-reverse-20070409-branchpoint:1.95
	gdb_6_8-2008-03-27-release:1.135
	gdb_6_8-branch:1.135.0.2
	gdb_6_8-2008-02-26-branchpoint:1.135
	gdb_6_7_1-2007-10-29-release:1.105
	gdb_6_7-2007-10-10-release:1.105
	gdb_6_7-branch:1.105.0.2
	gdb_6_7-2007-09-07-branchpoint:1.105
	insight_6_6-20070208-release:1.84
	gdb_6_6-2006-12-18-release:1.84
	gdb_6_6-branch:1.84.0.18
	gdb_6_6-2006-11-15-branchpoint:1.84
	insight_6_5-20061003-release:1.84
	gdb-csl-symbian-6_4_50_20060226-12:1.84
	gdb-csl-sourcerygxx-3_4_4-25:1.79
	nickrob-async-20060828-mergepoint:1.84
	gdb-csl-symbian-6_4_50_20060226-11:1.84
	gdb-csl-sourcerygxx-4_1-17:1.84
	gdb-csl-20060226-branch-local-2:1.84
	gdb-csl-sourcerygxx-4_1-14:1.84
	gdb-csl-sourcerygxx-4_1-13:1.84
	gdb-csl-sourcerygxx-4_1-12:1.84
	gdb-csl-sourcerygxx-3_4_4-21:1.84
	gdb_6_5-20060621-release:1.84
	gdb-csl-sourcerygxx-4_1-9:1.84
	gdb-csl-sourcerygxx-4_1-8:1.84
	gdb-csl-sourcerygxx-4_1-7:1.84
	gdb-csl-arm-2006q1-6:1.84
	gdb-csl-sourcerygxx-4_1-6:1.84
	gdb-csl-symbian-6_4_50_20060226-10:1.84
	gdb-csl-symbian-6_4_50_20060226-9:1.84
	gdb-csl-symbian-6_4_50_20060226-8:1.84
	gdb-csl-coldfire-4_1-11:1.84
	gdb-csl-sourcerygxx-3_4_4-19:1.84
	gdb-csl-coldfire-4_1-10:1.84
	gdb_6_5-branch:1.84.0.16
	gdb_6_5-2006-05-14-branchpoint:1.84
	gdb-csl-sourcerygxx-4_1-5:1.84
	nickrob-async-20060513-branch:1.84.0.14
	nickrob-async-20060513-branchpoint:1.84
	gdb-csl-sourcerygxx-4_1-4:1.84
	msnyder-reverse-20060502-branch:1.84.0.12
	msnyder-reverse-20060502-branchpoint:1.84
	gdb-csl-morpho-4_1-4:1.84
	gdb-csl-sourcerygxx-3_4_4-17:1.84
	readline_5_1-import-branch:1.84.0.10
	readline_5_1-import-branchpoint:1.84
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.84
	gdb-csl-symbian-20060226-branch:1.84.0.8
	gdb-csl-symbian-20060226-branchpoint:1.84
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.84
	msnyder-reverse-20060331-branch:1.84.0.6
	msnyder-reverse-20060331-branchpoint:1.84
	gdb-csl-available-20060303-branch:1.84.0.4
	gdb-csl-available-20060303-branchpoint:1.84
	gdb-csl-20060226-branch:1.84.0.2
	gdb-csl-20060226-branchpoint:1.84
	gdb_6_4-20051202-release:1.79
	msnyder-fork-checkpoint-branch:1.79.0.8
	msnyder-fork-checkpoint-branchpoint:1.79
	gdb-csl-gxxpro-6_3-branch:1.79.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.79
	gdb_6_4-branch:1.79.0.4
	gdb_6_4-2005-11-01-branchpoint:1.79
	gdb-csl-arm-20051020-branch:1.79.0.2
	gdb-csl-arm-20051020-branchpoint:1.79
	msnyder-tracepoint-checkpoint-branch:1.78.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.78
	gdb-csl-arm-20050325-2005-q1b:1.77
	gdb-csl-arm-20050325-2005-q1a:1.77
	csl-arm-20050325-branch:1.77.0.2
	csl-arm-20050325-branchpoint:1.77
	gdb-post-i18n-errorwarning-20050211:1.76
	gdb-pre-i18n-errorwarning-20050211:1.75
	gdb_6_3-20041109-release:1.59
	gdb_6_3-branch:1.59.0.2
	gdb_6_3-20041019-branchpoint:1.59
	drow_intercu-merge-20040921:1.54
	drow_intercu-merge-20040915:1.52
	jimb-gdb_6_2-e500-branch:1.48.0.6
	jimb-gdb_6_2-e500-branchpoint:1.48
	gdb_6_2-20040730-release:1.48
	gdb_6_2-branch:1.48.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.48
	gdb_6_1_1-20040616-release:1.35
	gdb_6_1-2004-04-05-release:1.35
	drow_intercu-merge-20040402:1.35
	drow_intercu-merge-20040327:1.35
	ezannoni_pie-20040323-branch:1.35.0.10
	ezannoni_pie-20040323-branchpoint:1.35
	cagney_tramp-20040321-mergepoint:1.35
	cagney_tramp-20040309-branch:1.35.0.8
	cagney_tramp-20040309-branchpoint:1.35
	gdb_6_1-branch:1.35.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.35
	drow_intercu-20040221-branch:1.35.0.4
	drow_intercu-20040221-branchpoint:1.35
	cagney_bfdfile-20040213-branch:1.35.0.2
	cagney_bfdfile-20040213-branchpoint:1.35
	drow-cplus-merge-20040208:1.35
	carlton_dictionary-20040126-merge:1.35
	cagney_bigcore-20040122-branch:1.34.0.2
	cagney_bigcore-20040122-branchpoint:1.34
	drow-cplus-merge-20040113:1.34
	drow-cplus-merge-20031224:1.34
	drow-cplus-merge-20031220:1.34
	carlton_dictionary-20031215-merge:1.34
	drow-cplus-merge-20031214:1.34
	carlton-dictionary-20031111-merge:1.33
	gdb_6_0-2003-10-04-release:1.30
	kettenis_sparc-20030918-branch:1.32.0.4
	kettenis_sparc-20030918-branchpoint:1.32
	carlton_dictionary-20030917-merge:1.32
	ezannoni_pie-20030916-branchpoint:1.32
	ezannoni_pie-20030916-branch:1.32.0.2
	cagney_x86i386-20030821-branch:1.31.0.2
	cagney_x86i386-20030821-branchpoint:1.31
	carlton_dictionary-20030805-merge:1.31
	carlton_dictionary-20030627-merge:1.31
	gdb_6_0-branch:1.30.0.2
	gdb_6_0-2003-06-23-branchpoint:1.30
	jimb-ppc64-linux-20030613-branch:1.29.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.29
	cagney_convert-20030606-branch:1.27.0.2
	cagney_convert-20030606-branchpoint:1.27
	cagney_writestrings-20030508-branch:1.24.0.4
	cagney_writestrings-20030508-branchpoint:1.24
	jimb-ppc64-linux-20030528-branch:1.26.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.26
	carlton_dictionary-20030523-merge:1.26
	cagney_fileio-20030521-branch:1.26.0.2
	cagney_fileio-20030521-branchpoint:1.26
	kettenis_i386newframe-20030517-mergepoint:1.25
	jimb-ppc64-linux-20030509-branch:1.24.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.24
	kettenis_i386newframe-20030504-mergepoint:1.24
	carlton_dictionary-20030430-merge:1.24
	kettenis_i386newframe-20030419-branch:1.23.0.6
	kettenis_i386newframe-20030419-branchpoint:1.23
	carlton_dictionary-20030416-merge:1.23
	cagney_frameaddr-20030409-mergepoint:1.23
	kettenis_i386newframe-20030406-branch:1.23.0.4
	kettenis_i386newframe-20030406-branchpoint:1.23
	cagney_frameaddr-20030403-branchpoint:1.23
	cagney_frameaddr-20030403-branch:1.23.0.2
	cagney_framebase-20030330-mergepoint:1.22
	cagney_framebase-20030326-branch:1.22.0.2
	cagney_framebase-20030326-branchpoint:1.22
	cagney_lazyid-20030317-branch:1.21.0.8
	cagney_lazyid-20030317-branchpoint:1.21
	kettenis-i386newframe-20030316-mergepoint:1.21
	offbyone-20030313-branch:1.21.0.6
	offbyone-20030313-branchpoint:1.21
	kettenis-i386newframe-20030308-branch:1.21.0.4
	kettenis-i386newframe-20030308-branchpoint:1.21
	carlton_dictionary-20030305-merge:1.21
	cagney_offbyone-20030303-branch:1.21.0.2
	cagney_offbyone-20030303-branchpoint:1.21
	carlton_dictionary-20030207-merge:1.17
	interps-20030203-mergepoint:1.17
	interps-20030202-branch:1.17.0.4
	interps-20030202-branchpoint:1.17
	cagney-unwind-20030108-branch:1.17.0.2
	cagney-unwind-20030108-branchpoint:1.17
	carlton_dictionary-20021223-merge:1.16
	gdb_5_3-2002-12-12-release:1.8.6.1
	carlton_dictionary-20021115-merge:1.12
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.4
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.2
	carlton_dictionary-20020920-branchpoint:1.9
	gdb_5_3-branch:1.8.0.6
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.4
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.2
	readline_4_3-import-branchpoint:1.8
	kseitz_interps-20020528-branch:1.2.0.2
	cagney_regbuf-20020515-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.414
date	2013.10.11.13.48.19;	author brobecke;	state Exp;
branches;
next	1.413;

1.413
date	2013.10.11.13.45.27;	author brobecke;	state Exp;
branches;
next	1.412;

1.412
date	2013.10.11.13.44.11;	author brobecke;	state Exp;
branches;
next	1.411;

1.411
date	2013.10.08.11.18.58;	author brobecke;	state Exp;
branches;
next	1.410;

1.410
date	2013.10.08.10.52.18;	author brobecke;	state Exp;
branches;
next	1.409;

1.409
date	2013.10.01.09.21.41;	author brobecke;	state Exp;
branches;
next	1.408;

1.408
date	2013.09.25.21.44.11;	author devans;	state Exp;
branches;
next	1.407;

1.407
date	2013.09.24.13.57.36;	author jkratoch;	state Exp;
branches;
next	1.406;

1.406
date	2013.08.05.15.51.02;	author tromey;	state Exp;
branches;
next	1.405;

1.405
date	2013.07.10.00.34.38;	author brobecke;	state Exp;
branches;
next	1.404;

1.404
date	2013.05.22.21.16.18;	author kseitz;	state Exp;
branches;
next	1.403;

1.403
date	2013.05.21.05.41.31;	author brobecke;	state Exp;
branches;
next	1.402;

1.402
date	2013.05.16.07.02.42;	author brobecke;	state Exp;
branches;
next	1.401;

1.401
date	2013.05.06.19.46.15;	author tromey;	state Exp;
branches;
next	1.400;

1.400
date	2013.04.19.15.35.58;	author palves;	state Exp;
branches;
next	1.399;

1.399
date	2013.04.19.15.09.45;	author palves;	state Exp;
branches;
next	1.398;

1.398
date	2013.04.08.19.56.02;	author tromey;	state Exp;
branches;
next	1.397;

1.397
date	2013.03.13.18.34.53;	author palves;	state Exp;
branches;
next	1.396;

1.396
date	2013.03.13.16.45.10;	author palves;	state Exp;
branches;
next	1.395;

1.395
date	2013.03.12.17.39.43;	author kseitz;	state Exp;
branches;
next	1.394;

1.394
date	2013.03.05.21.15.34;	author devans;	state Exp;
branches;
next	1.393;

1.393
date	2013.02.03.16.13.27;	author jkratoch;	state Exp;
branches;
next	1.392;

1.392
date	2013.02.01.20.06.35;	author aristovski;	state Exp;
branches;
next	1.391;

1.391
date	2013.01.24.18.04.33;	author tromey;	state Exp;
branches;
next	1.390;

1.390
date	2013.01.21.18.13.12;	author tromey;	state Exp;
branches;
next	1.389;

1.389
date	2013.01.09.21.51.18;	author green;	state Exp;
branches;
next	1.388;

1.388
date	2013.01.01.06.32.36;	author brobecke;	state Exp;
branches;
next	1.387;

1.387
date	2012.12.25.08.03.30;	author jkratoch;	state Exp;
branches;
next	1.386;

1.386
date	2012.12.07.20.09.08;	author tromey;	state Exp;
branches;
next	1.385;

1.385
date	2012.12.03.19.59.13;	author tromey;	state Exp;
branches;
next	1.384;

1.384
date	2012.11.29.16.29.54;	author guitton;	state Exp;
branches;
next	1.383;

1.383
date	2012.11.29.16.28.09;	author guitton;	state Exp;
branches;
next	1.382;

1.382
date	2012.11.29.16.26.12;	author guitton;	state Exp;
branches;
next	1.381;

1.381
date	2012.11.26.15.54.28;	author tromey;	state Exp;
branches;
next	1.380;

1.380
date	2012.11.12.17.14.54;	author tromey;	state Exp;
branches;
next	1.379;

1.379
date	2012.10.24.18.17.22;	author brobecke;	state Exp;
branches;
next	1.378;

1.378
date	2012.10.24.18.14.23;	author brobecke;	state Exp;
branches;
next	1.377;

1.377
date	2012.10.24.18.06.08;	author brobecke;	state Exp;
branches;
next	1.376;

1.376
date	2012.09.10.22.18.22;	author brobecke;	state Exp;
branches;
next	1.375;

1.375
date	2012.08.22.15.17.20;	author tromey;	state Exp;
branches;
next	1.374;

1.374
date	2012.08.17.17.36.59;	author kseitz;	state Exp;
branches;
next	1.373;

1.373
date	2012.06.27.18.08.39;	author tromey;	state Exp;
branches;
next	1.372;

1.372
date	2012.06.24.07.28.09;	author qiyao;	state Exp;
branches;
next	1.371;

1.371
date	2012.06.13.15.47.14;	author tromey;	state Exp;
branches;
next	1.370;

1.370
date	2012.05.31.09.34.40;	author mgretton;	state Exp;
branches;
next	1.369;

1.369
date	2012.05.21.19.47.53;	author tromey;	state Exp;
branches;
next	1.368;

1.368
date	2012.05.18.21.02.46;	author sergiodj;	state Exp;
branches;
next	1.367;

1.367
date	2012.05.10.19.50.06;	author tromey;	state Exp;
branches;
next	1.366;

1.366
date	2012.04.21.22.12.59;	author hilfingr;	state Exp;
branches;
next	1.365;

1.365
date	2012.04.18.06.46.45;	author jkratoch;	state Exp;
branches;
next	1.364;

1.364
date	2012.04.17.12.43.19;	author jkratoch;	state Exp;
branches;
next	1.363;

1.363
date	2012.03.29.23.30.55;	author brobecke;	state Exp;
branches;
next	1.362;

1.362
date	2012.03.29.23.30.46;	author brobecke;	state Exp;
branches;
next	1.361;

1.361
date	2012.03.29.23.30.38;	author brobecke;	state Exp;
branches;
next	1.360;

1.360
date	2012.03.29.23.30.29;	author brobecke;	state Exp;
branches;
next	1.359;

1.359
date	2012.03.29.23.30.21;	author brobecke;	state Exp;
branches;
next	1.358;

1.358
date	2012.03.29.23.30.13;	author brobecke;	state Exp;
branches;
next	1.357;

1.357
date	2012.03.29.23.30.04;	author brobecke;	state Exp;
branches;
next	1.356;

1.356
date	2012.03.29.23.29.56;	author brobecke;	state Exp;
branches;
next	1.355;

1.355
date	2012.03.29.23.29.47;	author brobecke;	state Exp;
branches;
next	1.354;

1.354
date	2012.03.29.23.29.37;	author brobecke;	state Exp;
branches;
next	1.353;

1.353
date	2012.03.29.23.29.28;	author brobecke;	state Exp;
branches;
next	1.352;

1.352
date	2012.03.29.23.29.19;	author brobecke;	state Exp;
branches;
next	1.351;

1.351
date	2012.03.29.18.23.00;	author brobecke;	state Exp;
branches;
next	1.350;

1.350
date	2012.03.16.17.55.43;	author brobecke;	state Exp;
branches;
next	1.349;

1.349
date	2012.03.02.19.29.00;	author brobecke;	state Exp;
branches;
next	1.348;

1.348
date	2012.03.01.21.03.13;	author palves;	state Exp;
branches;
next	1.347;

1.347
date	2012.02.29.19.51.49;	author brobecke;	state Exp;
branches;
next	1.346;

1.346
date	2012.02.29.19.50.22;	author brobecke;	state Exp;
branches;
next	1.345;

1.345
date	2012.02.29.19.46.47;	author brobecke;	state Exp;
branches;
next	1.344;

1.344
date	2012.02.29.19.44.12;	author brobecke;	state Exp;
branches;
next	1.343;

1.343
date	2012.02.29.19.37.07;	author brobecke;	state Exp;
branches;
next	1.342;

1.342
date	2012.02.29.19.35.37;	author brobecke;	state Exp;
branches;
next	1.341;

1.341
date	2012.02.29.19.34.39;	author brobecke;	state Exp;
branches;
next	1.340;

1.340
date	2012.02.29.19.30.53;	author brobecke;	state Exp;
branches;
next	1.339;

1.339
date	2012.02.29.19.29.11;	author brobecke;	state Exp;
branches;
next	1.338;

1.338
date	2012.02.29.19.09.47;	author brobecke;	state Exp;
branches;
next	1.337;

1.337
date	2012.02.08.19.54.36;	author brobecke;	state Exp;
branches;
next	1.336;

1.336
date	2012.02.07.04.48.18;	author devans;	state Exp;
branches;
next	1.335;

1.335
date	2012.02.01.16.10.30;	author gary;	state Exp;
branches;
next	1.334;

1.334
date	2012.02.01.15.49.33;	author tromey;	state Exp;
branches;
next	1.333;

1.333
date	2012.01.26.04.21.39;	author brobecke;	state Exp;
branches;
next	1.332;

1.332
date	2012.01.26.04.20.35;	author brobecke;	state Exp;
branches;
next	1.331;

1.331
date	2012.01.24.21.36.37;	author tromey;	state Exp;
branches;
next	1.330;

1.330
date	2012.01.06.03.34.45;	author sergiodj;	state Exp;
branches;
next	1.329;

1.329
date	2012.01.04.14.55.09;	author brobecke;	state Exp;
branches;
next	1.328;

1.328
date	2012.01.04.08.16.55;	author brobecke;	state Exp;
branches;
next	1.327;

1.327
date	2012.01.03.13.31.00;	author brobecke;	state Exp;
branches;
next	1.326;

1.326
date	2011.12.27.04.17.55;	author brobecke;	state Exp;
branches;
next	1.325;

1.325
date	2011.12.21.07.10.57;	author brobecke;	state Exp;
branches;
next	1.324;

1.324
date	2011.12.14.20.24.59;	author brobecke;	state Exp;
branches;
next	1.323;

1.323
date	2011.12.11.17.38.17;	author brobecke;	state Exp;
branches
	1.323.2.1;
next	1.322;

1.322
date	2011.12.11.17.37.56;	author brobecke;	state Exp;
branches;
next	1.321;

1.321
date	2011.12.11.17.36.10;	author brobecke;	state Exp;
branches;
next	1.320;

1.320
date	2011.12.11.17.35.34;	author brobecke;	state Exp;
branches;
next	1.319;

1.319
date	2011.12.11.02.31.04;	author ndreys;	state Exp;
branches;
next	1.318;

1.318
date	2011.12.06.18.54.38;	author tromey;	state Exp;
branches;
next	1.317;

1.317
date	2011.11.29.01.00.50;	author brobecke;	state Exp;
branches;
next	1.316;

1.316
date	2011.11.23.19.54.18;	author brobecke;	state Exp;
branches;
next	1.315;

1.315
date	2011.11.23.19.54.08;	author brobecke;	state Exp;
branches;
next	1.314;

1.314
date	2011.11.23.19.21.12;	author brobecke;	state Exp;
branches;
next	1.313;

1.313
date	2011.11.18.01.03.50;	author qiyao;	state Exp;
branches;
next	1.312;

1.312
date	2011.08.04.19.10.09;	author palves;	state Exp;
branches;
next	1.311;

1.311
date	2011.07.25.15.51.19;	author tromey;	state Exp;
branches;
next	1.310;

1.310
date	2011.07.25.11.24.44;	author palves;	state Exp;
branches;
next	1.309;

1.309
date	2011.07.25.11.23.03;	author palves;	state Exp;
branches;
next	1.308;

1.308
date	2011.07.25.11.21.08;	author palves;	state Exp;
branches;
next	1.307;

1.307
date	2011.07.25.11.16.47;	author palves;	state Exp;
branches;
next	1.306;

1.306
date	2011.07.05.04.34.55;	author bauermann;	state Exp;
branches;
next	1.305;

1.305
date	2011.07.01.18.35.35;	author brobecke;	state Exp;
branches;
next	1.304;

1.304
date	2011.07.01.18.26.49;	author brobecke;	state Exp;
branches;
next	1.303;

1.303
date	2011.07.01.18.25.59;	author brobecke;	state Exp;
branches;
next	1.302;

1.302
date	2011.07.01.18.25.49;	author brobecke;	state Exp;
branches;
next	1.301;

1.301
date	2011.07.01.18.24.52;	author brobecke;	state Exp;
branches;
next	1.300;

1.300
date	2011.06.22.17.53.44;	author palves;	state Exp;
branches;
next	1.299;

1.299
date	2011.06.22.17.52.37;	author palves;	state Exp;
branches;
next	1.298;

1.298
date	2011.06.22.17.14.28;	author palves;	state Exp;
branches;
next	1.297;

1.297
date	2011.05.18.17.29.59;	author brobecke;	state Exp;
branches;
next	1.296;

1.296
date	2011.05.06.18.46.31;	author bauermann;	state Exp;
branches;
next	1.295;

1.295
date	2011.04.20.19.42.50;	author jkratoch;	state Exp;
branches;
next	1.294;

1.294
date	2011.04.01.17.03.24;	author brobecke;	state Exp;
branches;
next	1.293;

1.293
date	2011.04.01.16.59.56;	author brobecke;	state Exp;
branches;
next	1.292;

1.292
date	2011.03.31.14.32.48;	author bauermann;	state Exp;
branches
	1.292.2.1;
next	1.291;

1.291
date	2011.03.21.14.43.37;	author brobecke;	state Exp;
branches;
next	1.290;

1.290
date	2011.03.21.14.43.14;	author brobecke;	state Exp;
branches;
next	1.289;

1.289
date	2011.03.07.18.29.13;	author schwab;	state Exp;
branches;
next	1.288;

1.288
date	2011.03.07.10.05.20;	author brobecke;	state Exp;
branches;
next	1.287;

1.287
date	2011.03.01.23.07.40;	author msnyder;	state Exp;
branches;
next	1.286;

1.286
date	2011.03.01.22.42.33;	author msnyder;	state Exp;
branches;
next	1.285;

1.285
date	2011.02.17.06.42.56;	author brobecke;	state Exp;
branches;
next	1.284;

1.284
date	2011.01.12.16.10.03;	author jkratoch;	state Exp;
branches;
next	1.283;

1.283
date	2011.01.11.19.23.02;	author bauermann;	state Exp;
branches;
next	1.282;

1.282
date	2011.01.07.19.36.14;	author msnyder;	state Exp;
branches;
next	1.281;

1.281
date	2010.12.29.08.15.24;	author brobecke;	state Exp;
branches;
next	1.280;

1.280
date	2010.12.29.08.01.30;	author brobecke;	state Exp;
branches;
next	1.279;

1.279
date	2010.11.23.01.12.05;	author brobecke;	state Exp;
branches;
next	1.278;

1.278
date	2010.11.23.01.10.54;	author brobecke;	state Exp;
branches;
next	1.277;

1.277
date	2010.11.23.01.07.22;	author brobecke;	state Exp;
branches;
next	1.276;

1.276
date	2010.11.23.01.03.54;	author brobecke;	state Exp;
branches;
next	1.275;

1.275
date	2010.11.16.22.13.02;	author jkratoch;	state Exp;
branches;
next	1.274;

1.274
date	2010.10.07.07.13.51;	author hilfingr;	state Exp;
branches;
next	1.273;

1.273
date	2010.10.07.06.53.44;	author hilfingr;	state Exp;
branches;
next	1.272;

1.272
date	2010.10.06.15.24.38;	author brobecke;	state Exp;
branches;
next	1.271;

1.271
date	2010.10.04.22.32.31;	author brobecke;	state Exp;
branches;
next	1.270;

1.270
date	2010.10.04.06.34.39;	author hilfingr;	state Exp;
branches;
next	1.269;

1.269
date	2010.10.01.16.25.00;	author brobecke;	state Exp;
branches;
next	1.268;

1.268
date	2010.09.30.10.29.00;	author jkratoch;	state Exp;
branches;
next	1.267;

1.267
date	2010.07.16.18.39.09;	author swagiaal;	state Exp;
branches;
next	1.266;

1.266
date	2010.06.04.21.39.47;	author sergiodj;	state Exp;
branches;
next	1.265;

1.265
date	2010.05.28.01.32.08;	author brobecke;	state Exp;
branches;
next	1.264;

1.264
date	2010.05.27.17.37.45;	author brobecke;	state Exp;
branches;
next	1.263;

1.263
date	2010.05.18.19.23.37;	author msnyder;	state Exp;
branches;
next	1.262;

1.262
date	2010.05.17.16.55.31;	author brobecke;	state Exp;
branches;
next	1.261;

1.261
date	2010.05.07.16.00.48;	author brobecke;	state Exp;
branches;
next	1.260;

1.260
date	2010.05.06.23.36.39;	author msnyder;	state Exp;
branches;
next	1.259;

1.259
date	2010.05.05.17.07.39;	author brobecke;	state Exp;
branches;
next	1.258;

1.258
date	2010.05.02.21.14.59;	author jkratoch;	state Exp;
branches;
next	1.257;

1.257
date	2010.04.22.23.15.41;	author jkratoch;	state Exp;
branches;
next	1.256;

1.256
date	2010.04.20.22.40.36;	author brobecke;	state Exp;
branches;
next	1.255;

1.255
date	2010.04.20.22.38.01;	author brobecke;	state Exp;
branches;
next	1.254;

1.254
date	2010.04.20.22.26.56;	author brobecke;	state Exp;
branches;
next	1.253;

1.253
date	2010.04.19.17.06.11;	author palves;	state Exp;
branches;
next	1.252;

1.252
date	2010.04.19.00.48.43;	author palves;	state Exp;
branches;
next	1.251;

1.251
date	2010.04.06.17.47.39;	author shebs;	state Exp;
branches;
next	1.250;

1.250
date	2010.03.10.18.20.06;	author tromey;	state Exp;
branches;
next	1.249;

1.249
date	2010.03.09.18.09.06;	author kseitz;	state Exp;
branches;
next	1.248;

1.248
date	2010.02.09.13.15.09;	author brobecke;	state Exp;
branches;
next	1.247;

1.247
date	2010.01.20.03.34.25;	author brobecke;	state Exp;
branches;
next	1.246;

1.246
date	2010.01.19.09.39.12;	author brobecke;	state Exp;
branches;
next	1.245;

1.245
date	2010.01.18.10.26.02;	author brobecke;	state Exp;
branches;
next	1.244;

1.244
date	2010.01.18.10.24.26;	author brobecke;	state Exp;
branches;
next	1.243;

1.243
date	2010.01.15.12.11.21;	author brobecke;	state Exp;
branches;
next	1.242;

1.242
date	2010.01.15.12.07.04;	author brobecke;	state Exp;
branches;
next	1.241;

1.241
date	2010.01.12.08.50.44;	author brobecke;	state Exp;
branches;
next	1.240;

1.240
date	2010.01.12.05.48.56;	author brobecke;	state Exp;
branches;
next	1.239;

1.239
date	2010.01.08.11.58.23;	author brobecke;	state Exp;
branches;
next	1.238;

1.238
date	2009.12.14.06.19.12;	author hilfingr;	state Exp;
branches;
next	1.237;

1.237
date	2009.12.02.19.29.41;	author ppluzhnikov;	state Exp;
branches;
next	1.236;

1.236
date	2009.11.27.15.33.47;	author brobecke;	state Exp;
branches;
next	1.235;

1.235
date	2009.11.27.01.49.41;	author brobecke;	state Exp;
branches;
next	1.234;

1.234
date	2009.11.19.22.45.56;	author brobecke;	state Exp;
branches;
next	1.233;

1.233
date	2009.11.19.22.42.48;	author brobecke;	state Exp;
branches;
next	1.232;

1.232
date	2009.11.19.22.37.35;	author brobecke;	state Exp;
branches;
next	1.231;

1.231
date	2009.11.19.22.36.05;	author brobecke;	state Exp;
branches;
next	1.230;

1.230
date	2009.11.19.22.34.50;	author brobecke;	state Exp;
branches;
next	1.229;

1.229
date	2009.07.02.17.25.52;	author uweigand;	state Exp;
branches;
next	1.228;

1.228
date	2009.07.02.17.21.05;	author uweigand;	state Exp;
branches;
next	1.227;

1.227
date	2009.07.02.17.12.23;	author uweigand;	state Exp;
branches;
next	1.226;

1.226
date	2009.07.02.12.57.14;	author uweigand;	state Exp;
branches;
next	1.225;

1.225
date	2009.07.02.12.55.30;	author uweigand;	state Exp;
branches;
next	1.224;

1.224
date	2009.07.02.12.48.53;	author uweigand;	state Exp;
branches;
next	1.223;

1.223
date	2009.07.02.12.20.17;	author uweigand;	state Exp;
branches;
next	1.222;

1.222
date	2009.06.29.17.33.31;	author uweigand;	state Exp;
branches;
next	1.221;

1.221
date	2009.06.29.17.31.24;	author uweigand;	state Exp;
branches;
next	1.220;

1.220
date	2009.06.29.17.30.12;	author uweigand;	state Exp;
branches;
next	1.219;

1.219
date	2009.06.29.17.28.59;	author uweigand;	state Exp;
branches;
next	1.218;

1.218
date	2009.06.29.17.26.29;	author uweigand;	state Exp;
branches;
next	1.217;

1.217
date	2009.06.29.17.22.10;	author uweigand;	state Exp;
branches;
next	1.216;

1.216
date	2009.06.29.13.24.41;	author uweigand;	state Exp;
branches;
next	1.215;

1.215
date	2009.06.23.16.43.24;	author brobecke;	state Exp;
branches;
next	1.214;

1.214
date	2009.06.23.16.37.18;	author brobecke;	state Exp;
branches;
next	1.213;

1.213
date	2009.05.28.00.53.51;	author tromey;	state Exp;
branches;
next	1.212;

1.212
date	2009.05.18.14.00.08;	author uweigand;	state Exp;
branches;
next	1.211;

1.211
date	2009.05.18.13.55.49;	author uweigand;	state Exp;
branches;
next	1.210;

1.210
date	2009.05.18.13.47.44;	author uweigand;	state Exp;
branches;
next	1.209;

1.209
date	2009.04.23.22.52.51;	author brobecke;	state Exp;
branches;
next	1.208;

1.208
date	2009.04.16.17.21.06;	author brobecke;	state Exp;
branches;
next	1.207;

1.207
date	2009.04.16.17.16.17;	author brobecke;	state Exp;
branches;
next	1.206;

1.206
date	2009.04.14.19.04.24;	author muller;	state Exp;
branches;
next	1.205;

1.205
date	2009.03.24.02.07.06;	author brobecke;	state Exp;
branches;
next	1.204;

1.204
date	2009.03.24.02.04.19;	author brobecke;	state Exp;
branches;
next	1.203;

1.203
date	2009.03.24.02.00.51;	author brobecke;	state Exp;
branches;
next	1.202;

1.202
date	2009.03.24.01.58.22;	author brobecke;	state Exp;
branches;
next	1.201;

1.201
date	2009.03.24.01.51.48;	author brobecke;	state Exp;
branches;
next	1.200;

1.200
date	2009.03.20.23.04.28;	author tromey;	state Exp;
branches;
next	1.199;

1.199
date	2009.03.20.22.00.10;	author tromey;	state Exp;
branches;
next	1.198;

1.198
date	2009.03.13.02.30.55;	author brobecke;	state Exp;
branches;
next	1.197;

1.197
date	2009.03.13.02.15.01;	author brobecke;	state Exp;
branches;
next	1.196;

1.196
date	2009.03.13.01.28.05;	author brobecke;	state Exp;
branches;
next	1.195;

1.195
date	2009.03.13.01.12.21;	author brobecke;	state Exp;
branches;
next	1.194;

1.194
date	2009.03.13.00.57.52;	author brobecke;	state Exp;
branches;
next	1.193;

1.193
date	2009.03.12.23.41.16;	author brobecke;	state Exp;
branches;
next	1.192;

1.192
date	2009.03.12.23.17.31;	author brobecke;	state Exp;
branches;
next	1.191;

1.191
date	2009.03.03.02.10.08;	author brobecke;	state Exp;
branches;
next	1.190;

1.190
date	2009.02.21.16.14.47;	author palves;	state Exp;
branches;
next	1.189;

1.189
date	2009.02.05.12.16.25;	author bauermann;	state Exp;
branches;
next	1.188;

1.188
date	2009.02.04.17.46.36;	author guitton;	state Exp;
branches;
next	1.187;

1.187
date	2009.01.13.10.34.30;	author palves;	state Exp;
branches;
next	1.186;

1.186
date	2008.12.28.14.14.18;	author jkratoch;	state Exp;
branches;
next	1.185;

1.185
date	2008.12.15.10.40.28;	author guitton;	state Exp;
branches;
next	1.184;

1.184
date	2008.11.24.23.21.15;	author tromey;	state Exp;
branches;
next	1.183;

1.183
date	2008.11.15.18.27.27;	author brobecke;	state Exp;
branches
	1.183.2.1;
next	1.182;

1.182
date	2008.10.28.17.19.55;	author tromey;	state Exp;
branches;
next	1.181;

1.181
date	2008.10.22.20.11.56;	author brobecke;	state Exp;
branches;
next	1.180;

1.180
date	2008.10.22.19.45.05;	author brobecke;	state Exp;
branches;
next	1.179;

1.179
date	2008.10.16.16.25.04;	author brobecke;	state Exp;
branches;
next	1.178;

1.178
date	2008.10.07.14.07.10;	author brobecke;	state Exp;
branches;
next	1.177;

1.177
date	2008.10.01.02.23.18;	author brobecke;	state Exp;
branches;
next	1.176;

1.176
date	2008.09.30.21.53.32;	author brobecke;	state Exp;
branches;
next	1.175;

1.175
date	2008.09.30.21.36.21;	author brobecke;	state Exp;
branches;
next	1.174;

1.174
date	2008.09.30.20.42.21;	author brobecke;	state Exp;
branches;
next	1.173;

1.173
date	2008.09.30.20.14.13;	author brobecke;	state Exp;
branches;
next	1.172;

1.172
date	2008.09.30.18.46.37;	author brobecke;	state Exp;
branches;
next	1.171;

1.171
date	2008.09.30.17.21.27;	author tromey;	state Exp;
branches;
next	1.170;

1.170
date	2008.09.27.21.29.29;	author tromey;	state Exp;
branches;
next	1.169;

1.169
date	2008.09.13.22.26.59;	author brobecke;	state Exp;
branches;
next	1.168;

1.168
date	2008.09.11.14.22.32;	author uweigand;	state Exp;
branches;
next	1.167;

1.167
date	2008.09.11.14.19.09;	author uweigand;	state Exp;
branches;
next	1.166;

1.166
date	2008.09.11.14.18.34;	author uweigand;	state Exp;
branches;
next	1.165;

1.165
date	2008.09.11.14.17.58;	author uweigand;	state Exp;
branches;
next	1.164;

1.164
date	2008.09.11.14.16.51;	author uweigand;	state Exp;
branches;
next	1.163;

1.163
date	2008.09.11.14.15.01;	author uweigand;	state Exp;
branches;
next	1.162;

1.162
date	2008.09.11.14.13.46;	author uweigand;	state Exp;
branches;
next	1.161;

1.161
date	2008.09.11.14.11.40;	author uweigand;	state Exp;
branches;
next	1.160;

1.160
date	2008.09.10.20.14.30;	author brobecke;	state Exp;
branches;
next	1.159;

1.159
date	2008.09.10.20.10.48;	author brobecke;	state Exp;
branches;
next	1.158;

1.158
date	2008.09.10.16.19.38;	author brobecke;	state Exp;
branches;
next	1.157;

1.157
date	2008.09.10.16.12.35;	author brobecke;	state Exp;
branches;
next	1.156;

1.156
date	2008.09.10.09.47.39;	author uweigand;	state Exp;
branches;
next	1.155;

1.155
date	2008.09.05.11.37.16;	author uweigand;	state Exp;
branches;
next	1.154;

1.154
date	2008.08.24.16.39.56;	author tromey;	state Exp;
branches;
next	1.153;

1.153
date	2008.08.19.10.10.39;	author hilfingr;	state Exp;
branches;
next	1.152;

1.152
date	2008.08.16.09.26.25;	author hilfingr;	state Exp;
branches;
next	1.151;

1.151
date	2008.07.21.16.47.10;	author tromey;	state Exp;
branches;
next	1.150;

1.150
date	2008.07.15.19.11.34;	author drow;	state Exp;
branches;
next	1.149;

1.149
date	2008.06.06.06.48.36;	author hilfingr;	state Exp;
branches;
next	1.148;

1.148
date	2008.05.27.19.29.51;	author schwab;	state Exp;
branches;
next	1.147;

1.147
date	2008.05.22.17.00.07;	author uweigand;	state Exp;
branches;
next	1.146;

1.146
date	2008.05.22.16.59.00;	author uweigand;	state Exp;
branches;
next	1.145;

1.145
date	2008.05.19.18.37.07;	author palves;	state Exp;
branches;
next	1.144;

1.144
date	2008.05.19.15.50.09;	author uweigand;	state Exp;
branches;
next	1.143;

1.143
date	2008.05.19.15.49.14;	author uweigand;	state Exp;
branches;
next	1.142;

1.142
date	2008.05.09.23.50.41;	author brobecke;	state Exp;
branches;
next	1.141;

1.141
date	2008.05.05.14.37.32;	author aristovski;	state Exp;
branches;
next	1.140;

1.140
date	2008.05.02.23.41.40;	author brobecke;	state Exp;
branches;
next	1.139;

1.139
date	2008.04.30.21.13.49;	author drow;	state Exp;
branches;
next	1.138;

1.138
date	2008.04.22.22.23.16;	author jkratoch;	state Exp;
branches;
next	1.137;

1.137
date	2008.04.06.08.56.36;	author vprus;	state Exp;
branches;
next	1.136;

1.136
date	2008.04.03.21.39.16;	author brobecke;	state Exp;
branches;
next	1.135;

1.135
date	2008.02.07.22.27.53;	author brobecke;	state Exp;
branches;
next	1.134;

1.134
date	2008.02.07.19.06.51;	author brobecke;	state Exp;
branches;
next	1.133;

1.133
date	2008.02.05.22.17.40;	author brobecke;	state Exp;
branches;
next	1.132;

1.132
date	2008.01.18.17.07.39;	author deuling;	state Exp;
branches;
next	1.131;

1.131
date	2008.01.08.19.28.08;	author brobecke;	state Exp;
branches;
next	1.130;

1.130
date	2008.01.08.17.40.09;	author brobecke;	state Exp;
branches;
next	1.129;

1.129
date	2008.01.05.15.44.53;	author brobecke;	state Exp;
branches;
next	1.128;

1.128
date	2008.01.04.21.36.25;	author brobecke;	state Exp;
branches;
next	1.127;

1.127
date	2008.01.04.20.45.05;	author brobecke;	state Exp;
branches;
next	1.126;

1.126
date	2008.01.04.19.01.30;	author brobecke;	state Exp;
branches;
next	1.125;

1.125
date	2008.01.03.19.15.10;	author brobecke;	state Exp;
branches;
next	1.124;

1.124
date	2008.01.03.14.07.09;	author brobecke;	state Exp;
branches;
next	1.123;

1.123
date	2008.01.03.13.11.51;	author brobecke;	state Exp;
branches;
next	1.122;

1.122
date	2008.01.03.12.30.38;	author brobecke;	state Exp;
branches;
next	1.121;

1.121
date	2008.01.02.12.03.06;	author brobecke;	state Exp;
branches;
next	1.120;

1.120
date	2008.01.02.11.18.03;	author brobecke;	state Exp;
branches;
next	1.119;

1.119
date	2008.01.01.12.39.48;	author brobecke;	state Exp;
branches;
next	1.118;

1.118
date	2008.01.01.07.38.37;	author brobecke;	state Exp;
branches;
next	1.117;

1.117
date	2008.01.01.07.21.59;	author brobecke;	state Exp;
branches;
next	1.116;

1.116
date	2007.12.29.05.37.25;	author brobecke;	state Exp;
branches;
next	1.115;

1.115
date	2007.12.28.13.06.16;	author brobecke;	state Exp;
branches;
next	1.114;

1.114
date	2007.12.28.06.25.56;	author brobecke;	state Exp;
branches;
next	1.113;

1.113
date	2007.12.28.06.13.51;	author brobecke;	state Exp;
branches;
next	1.112;

1.112
date	2007.12.24.16.52.24;	author brobecke;	state Exp;
branches;
next	1.111;

1.111
date	2007.12.24.06.29.27;	author brobecke;	state Exp;
branches;
next	1.110;

1.110
date	2007.12.21.11.50.11;	author brobecke;	state Exp;
branches;
next	1.109;

1.109
date	2007.12.04.23.33.00;	author uweigand;	state Exp;
branches;
next	1.108;

1.108
date	2007.11.02.19.34.11;	author uweigand;	state Exp;
branches;
next	1.107;

1.107
date	2007.10.30.21.39.15;	author uweigand;	state Exp;
branches;
next	1.106;

1.106
date	2007.09.23.16.25.03;	author drow;	state Exp;
branches;
next	1.105;

1.105
date	2007.08.23.18.08.25;	author brobecke;	state Exp;
branches;
next	1.104;

1.104
date	2007.08.15.18.43.14;	author brobecke;	state Exp;
branches;
next	1.103;

1.103
date	2007.08.15.18.36.37;	author brobecke;	state Exp;
branches;
next	1.102;

1.102
date	2007.08.14.20.16.16;	author brobecke;	state Exp;
branches;
next	1.101;

1.101
date	2007.08.14.18.32.45;	author msnyder;	state Exp;
branches;
next	1.100;

1.100
date	2007.08.06.20.07.44;	author msnyder;	state Exp;
branches;
next	1.99;

1.99
date	2007.06.13.17.11.09;	author drow;	state Exp;
branches;
next	1.98;

1.98
date	2007.06.12.16.33.20;	author uweigand;	state Exp;
branches;
next	1.97;

1.97
date	2007.06.12.15.33.03;	author uweigand;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.06.15.26.28;	author uweigand;	state Exp;
branches;
next	1.95;

1.95
date	2007.03.29.21.57.01;	author brobecke;	state Exp;
branches;
next	1.94;

1.94
date	2007.03.28.00.12.15;	author palves;	state Exp;
branches;
next	1.93;

1.93
date	2007.02.09.20.52.16;	author gdr;	state Exp;
branches;
next	1.92;

1.92
date	2007.01.26.21.31.05;	author brobecke;	state Exp;
branches;
next	1.91;

1.91
date	2007.01.21.16.55.49;	author drow;	state Exp;
branches;
next	1.90;

1.90
date	2007.01.08.04.37.52;	author brobecke;	state Exp;
branches;
next	1.89;

1.89
date	2007.01.08.03.14.18;	author brobecke;	state Exp;
branches;
next	1.88;

1.88
date	2007.01.04.06.31.51;	author brobecke;	state Exp;
branches;
next	1.87;

1.87
date	2007.01.04.05.27.31;	author brobecke;	state Exp;
branches;
next	1.86;

1.86
date	2007.01.03.19.01.25;	author drow;	state Exp;
branches;
next	1.85;

1.85
date	2006.12.01.00.32.29;	author jimb;	state Exp;
branches;
next	1.84;

1.84
date	2006.01.12.08.36.29;	author hilfingr;	state Exp;
branches;
next	1.83;

1.83
date	2006.01.08.07.19.39;	author hilfingr;	state Exp;
branches;
next	1.82;

1.82
date	2006.01.02.09.46.34;	author hilfingr;	state Exp;
branches;
next	1.81;

1.81
date	2006.01.02.09.39.21;	author hilfingr;	state Exp;
branches;
next	1.80;

1.80
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.79;

1.79
date	2005.10.03.21.21.20;	author brobecke;	state Exp;
branches;
next	1.78;

1.78
date	2005.05.09.21.20.29;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2005.02.12.00.39.17;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2005.02.11.04.05.41;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2005.02.08.04.57.03;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2005.02.08.00.25.30;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2005.02.07.23.51.02;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2005.02.07.15.04.42;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2005.02.07.00.09.51;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2005.02.02.22.34.30;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2005.02.02.00.20.00;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2005.01.29.01.59.29;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2005.01.28.19.56.00;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2005.01.12.18.31.29;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2004.12.21.10.03.55;	author hilfingr;	state Exp;
branches;
next	1.64;

1.64
date	2004.12.12.17.06.25;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2004.11.12.21.44.59;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2004.11.10.18.52.21;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2004.11.09.14.43.24;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2004.10.23.19.13.26;	author schwab;	state Exp;
branches;
next	1.59;

1.59
date	2004.10.15.09.12.24;	author hilfingr;	state Exp;
branches;
next	1.58;

1.58
date	2004.10.11.05.26.25;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2004.10.10.16.03.23;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2004.10.08.09.40.12;	author hilfingr;	state Exp;
branches;
next	1.55;

1.55
date	2004.10.01.10.23.08;	author hilfingr;	state Exp;
branches;
next	1.54;

1.54
date	2004.09.18.22.23.23;	author hilfingr;	state Exp;
branches;
next	1.53;

1.53
date	2004.09.18.10.11.06;	author hilfingr;	state Exp;
branches;
next	1.52;

1.52
date	2004.09.11.10.24.44;	author hilfingr;	state Exp;
branches;
next	1.51;

1.51
date	2004.08.29.10.12.13;	author dsl;	state Exp;
branches;
next	1.50;

1.50
date	2004.08.10.21.16.12;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2004.07.15.23.49.42;	author brobecke;	state Exp;
branches;
next	1.48;

1.48
date	2004.07.09.19.29.55;	author hilfingr;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.06.19.29.29;	author jjohnstn;	state Exp;
branches;
next	1.46;

1.46
date	2004.07.01.10.30.57;	author hilfingr;	state Exp;
branches;
next	1.45;

1.45
date	2004.07.01.10.11.11;	author hilfingr;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.28.23.59.27;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.28.18.59.13;	author brobecke;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.27.19.28.20;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.27.19.06.23;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.27.18.55.48;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.18.21.36.14;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.16.08.18.05;	author hilfingr;	state Exp;
branches;
next	1.37;

1.37
date	2004.06.08.08.42.03;	author hilfingr;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.02.09.55.36;	author hilfingr;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.23.23.03.28;	author carlton;	state Exp;
branches
	1.35.4.1;
next	1.34;

1.34
date	2003.11.23.20.41.16;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.06.22.37.37;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.11.15.17.13;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.26.17.18.41;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.17.21.20.41;	author ciceron;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.11.23.29.46;	author carlton;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.11.22.27.07;	author carlton;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.02.18.08.15;	author carlton;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.20.01.55.17;	author carlton;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.14.17.43.15;	author ezannoni;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.21.16.48.37;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.02.03.02.46;	author fedor;	state Exp;
branches
	1.23.6.1;
next	1.22;

1.22
date	2003.03.26.03.39.43;	author fedor;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.25.21.36.15;	author carlton;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.21.15.24.17;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.20.17.17.22;	author carlton;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.20.00.01.04;	author carlton;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.02.20.29.15;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.29.19.15.14;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.29.01.52.01;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.24.03.20.08;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.18.22.19.25;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.11.00.55.34;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.10.15.36.25;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.24.21.02.53;	author ezannoni;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.08.17.43.26;	author aidan;	state Exp;
branches
	1.9.2.1
	1.9.4.1;
next	1.8;

1.8
date	2002.08.18.18.23.41;	author aidan;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	2002.08.18.18.07.13;	author aidan;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.11.18.14.51;	author aidan;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.25.01.14.11;	author aidan;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.13.12.22.35;	author aidan;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.11.20.46.18;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.19.16.55.28;	author drow;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.06.04.15.28.47;	author aidan;	state Exp;
branches
	1.1.2.1;
next	;

1.323.2.1
date	2012.01.06.04.20.27;	author brobecke;	state Exp;
branches;
next	1.323.2.2;

1.323.2.2
date	2012.01.06.04.43.02;	author brobecke;	state Exp;
branches;
next	;

1.292.2.1
date	2011.04.20.20.10.29;	author jkratoch;	state Exp;
branches;
next	1.292.2.2;

1.292.2.2
date	2011.05.17.21.25.55;	author brobecke;	state Exp;
branches;
next	1.292.2.3;

1.292.2.3
date	2011.05.17.21.26.08;	author brobecke;	state Exp;
branches;
next	;

1.183.2.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	;

1.35.4.1
date	2004.09.16.17.00.51;	author drow;	state Exp;
branches;
next	1.35.4.2;

1.35.4.2
date	2004.09.21.20.44.12;	author drow;	state Exp;
branches;
next	;

1.23.6.1
date	2003.05.04.11.37.39;	author kettenis;	state Exp;
branches;
next	1.23.6.2;

1.23.6.2
date	2003.05.18.09.43.56;	author kettenis;	state Exp;
branches;
next	;

1.9.2.1
date	2002.09.20.18.52.15;	author carlton;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.09.24.00.04.49;	author carlton;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.09.25.00.19.26;	author carlton;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2002.10.18.23.42.57;	author carlton;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2002.10.25.23.49.52;	author carlton;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2002.10.29.01.07.47;	author carlton;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2002.11.15.19.18.35;	author carlton;	state Exp;
branches;
next	1.9.2.8;

1.9.2.8
date	2002.12.21.00.17.42;	author carlton;	state Exp;
branches;
next	1.9.2.9;

1.9.2.9
date	2002.12.23.19.38.10;	author carlton;	state Exp;
branches;
next	1.9.2.10;

1.9.2.10
date	2003.01.21.01.02.29;	author carlton;	state Exp;
branches;
next	1.9.2.11;

1.9.2.11
date	2003.02.07.19.17.43;	author carlton;	state Exp;
branches;
next	1.9.2.12;

1.9.2.12
date	2003.03.06.00.56.22;	author carlton;	state Exp;
branches;
next	1.9.2.13;

1.9.2.13
date	2003.04.16.19.56.48;	author carlton;	state Exp;
branches;
next	1.9.2.14;

1.9.2.14
date	2003.05.01.00.46.45;	author carlton;	state Exp;
branches;
next	1.9.2.15;

1.9.2.15
date	2003.05.23.18.40.34;	author carlton;	state Exp;
branches;
next	1.9.2.16;

1.9.2.16
date	2003.06.27.21.49.44;	author carlton;	state Exp;
branches;
next	1.9.2.17;

1.9.2.17
date	2003.09.17.21.28.05;	author carlton;	state Exp;
branches;
next	1.9.2.18;

1.9.2.18
date	2003.09.20.00.32.30;	author carlton;	state Exp;
branches;
next	1.9.2.19;

1.9.2.19
date	2003.11.11.23.50.37;	author carlton;	state Exp;
branches;
next	1.9.2.20;

1.9.2.20
date	2003.12.16.00.00.11;	author carlton;	state Exp;
branches;
next	1.9.2.21;

1.9.2.21
date	2004.01.26.19.11.14;	author carlton;	state Exp;
branches;
next	;

1.9.4.1
date	2002.10.26.17.12.04;	author drow;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.12.14.20.27.04;	author drow;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2004.02.09.19.43.30;	author drow;	state Exp;
branches;
next	;

1.8.6.1
date	2002.09.18.22.54.11;	author cagney;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.20.01.31.59;	author kseitz;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.07.22.21.46.55;	author kseitz;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.08.09.18.34.22;	author kseitz;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2002.08.30.22.52.41;	author kseitz;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2002.10.01.00.46.00;	author kseitz;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2002.11.04.00.17.28;	author ezannoni;	state Exp;
branches;
next	;

1.1.2.1
date	2002.06.15.16.42.49;	author cagney;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.06.21.16.19.10;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.414
log
@New GDB/MI commands to catch Ada exceptions

This patch introduces two new GDB/MI commands implementing the equivalent
of the "catch exception" and  "catch assert" GDB/CLI commands.

gdb/ChangeLog:

        * breakpoint.h (init_ada_exception_breakpoint): Add parameter
        "enabled".
        * breakpoint.c (init_ada_exception_breakpoint): Add parameter
        "enabled".  Set B->ENABLE_STATE accordingly.
        * ada-lang.h (ada_exception_catchpoint_kind): Move here from
        ada-lang.c.
        (create_ada_exception_catchpoint): Add declaration.
        * ada-lang.c (ada_exception_catchpoint_kind): Move to ada-lang.h.
        (create_ada_exception_catchpoint): Make non-static. Add new
        parameter "disabled". Use it in call to
        init_ada_exception_breakpoint.
        (catch_ada_exception_command): Add parameter "enabled" in call
        to create_ada_exception_catchpoint.
        (catch_assert_command): Likewise.

        * mi/mi-cmds.h (mi_cmd_catch_assert, mi_cmd_catch_exception):
        Add declarations.
        * mi/mi-cmds.c (mi_cmds): Add the "catch-assert" and
        "catch-exception" commands.
        * mi/mi-cmd-catch.c: Add #include "ada-lang.h".
        (mi_cmd_catch_assert, mi_cmd_catch_exception): New functions.
@
text
@/* Ada language support routines for GDB, the GNU debugger.

   Copyright (C) 1992-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


#include "defs.h"
#include <stdio.h>
#include "gdb_string.h"
#include <ctype.h>
#include <stdarg.h>
#include "demangle.h"
#include "gdb_regex.h"
#include "frame.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "expression.h"
#include "parser-defs.h"
#include "language.h"
#include "c-lang.h"
#include "inferior.h"
#include "symfile.h"
#include "objfiles.h"
#include "breakpoint.h"
#include "gdbcore.h"
#include "hashtab.h"
#include "gdb_obstack.h"
#include "ada-lang.h"
#include "completer.h"
#include "gdb_stat.h"
#ifdef UI_OUT
#include "ui-out.h"
#endif
#include "block.h"
#include "infcall.h"
#include "dictionary.h"
#include "exceptions.h"
#include "annotate.h"
#include "valprint.h"
#include "source.h"
#include "observer.h"
#include "vec.h"
#include "stack.h"
#include "gdb_vecs.h"
#include "typeprint.h"

#include "psymtab.h"
#include "value.h"
#include "mi/mi-common.h"
#include "arch-utils.h"
#include "exceptions.h"
#include "cli/cli-utils.h"

/* Define whether or not the C operator '/' truncates towards zero for
   differently signed operands (truncation direction is undefined in C).
   Copied from valarith.c.  */

#ifndef TRUNCATION_TOWARDS_ZERO
#define TRUNCATION_TOWARDS_ZERO ((-5 / 2) == -2)
#endif

static struct type *desc_base_type (struct type *);

static struct type *desc_bounds_type (struct type *);

static struct value *desc_bounds (struct value *);

static int fat_pntr_bounds_bitpos (struct type *);

static int fat_pntr_bounds_bitsize (struct type *);

static struct type *desc_data_target_type (struct type *);

static struct value *desc_data (struct value *);

static int fat_pntr_data_bitpos (struct type *);

static int fat_pntr_data_bitsize (struct type *);

static struct value *desc_one_bound (struct value *, int, int);

static int desc_bound_bitpos (struct type *, int, int);

static int desc_bound_bitsize (struct type *, int, int);

static struct type *desc_index_type (struct type *, int);

static int desc_arity (struct type *);

static int ada_type_match (struct type *, struct type *, int);

static int ada_args_match (struct symbol *, struct value **, int);

static int full_match (const char *, const char *);

static struct value *make_array_descriptor (struct type *, struct value *);

static void ada_add_block_symbols (struct obstack *,
                                   struct block *, const char *,
                                   domain_enum, struct objfile *, int);

static int is_nonfunction (struct ada_symbol_info *, int);

static void add_defn_to_vec (struct obstack *, struct symbol *,
                             struct block *);

static int num_defns_collected (struct obstack *);

static struct ada_symbol_info *defns_collected (struct obstack *, int);

static struct value *resolve_subexp (struct expression **, int *, int,
                                     struct type *);

static void replace_operator_with_call (struct expression **, int, int, int,
                                        struct symbol *, const struct block *);

static int possible_user_operator_p (enum exp_opcode, struct value **);

static char *ada_op_name (enum exp_opcode);

static const char *ada_decoded_op_name (enum exp_opcode);

static int numeric_type_p (struct type *);

static int integer_type_p (struct type *);

static int scalar_type_p (struct type *);

static int discrete_type_p (struct type *);

static enum ada_renaming_category parse_old_style_renaming (struct type *,
							    const char **,
							    int *,
							    const char **);

static struct symbol *find_old_style_renaming_symbol (const char *,
						      const struct block *);

static struct type *ada_lookup_struct_elt_type (struct type *, char *,
                                                int, int, int *);

static struct value *evaluate_subexp_type (struct expression *, int *);

static struct type *ada_find_parallel_type_with_name (struct type *,
                                                      const char *);

static int is_dynamic_field (struct type *, int);

static struct type *to_fixed_variant_branch_type (struct type *,
						  const gdb_byte *,
                                                  CORE_ADDR, struct value *);

static struct type *to_fixed_array_type (struct type *, struct value *, int);

static struct type *to_fixed_range_type (struct type *, struct value *);

static struct type *to_static_fixed_type (struct type *);
static struct type *static_unwrap_type (struct type *type);

static struct value *unwrap_value (struct value *);

static struct type *constrained_packed_array_type (struct type *, long *);

static struct type *decode_constrained_packed_array_type (struct type *);

static long decode_packed_array_bitsize (struct type *);

static struct value *decode_constrained_packed_array (struct value *);

static int ada_is_packed_array_type  (struct type *);

static int ada_is_unconstrained_packed_array_type (struct type *);

static struct value *value_subscript_packed (struct value *, int,
                                             struct value **);

static void move_bits (gdb_byte *, int, const gdb_byte *, int, int, int);

static struct value *coerce_unspec_val_to_type (struct value *,
                                                struct type *);

static struct value *get_var_value (char *, char *);

static int lesseq_defined_than (struct symbol *, struct symbol *);

static int equiv_types (struct type *, struct type *);

static int is_name_suffix (const char *);

static int advance_wild_match (const char **, const char *, int);

static int wild_match (const char *, const char *);

static struct value *ada_coerce_ref (struct value *);

static LONGEST pos_atr (struct value *);

static struct value *value_pos_atr (struct type *, struct value *);

static struct value *value_val_atr (struct type *, struct value *);

static struct symbol *standard_lookup (const char *, const struct block *,
                                       domain_enum);

static struct value *ada_search_struct_field (char *, struct value *, int,
                                              struct type *);

static struct value *ada_value_primitive_field (struct value *, int, int,
                                                struct type *);

static int find_struct_field (const char *, struct type *, int,
                              struct type **, int *, int *, int *, int *);

static struct value *ada_to_fixed_value_create (struct type *, CORE_ADDR,
                                                struct value *);

static int ada_resolve_function (struct ada_symbol_info *, int,
                                 struct value **, int, const char *,
                                 struct type *);

static int ada_is_direct_array_type (struct type *);

static void ada_language_arch_info (struct gdbarch *,
				    struct language_arch_info *);

static void check_size (const struct type *);

static struct value *ada_index_struct_field (int, struct value *, int,
					     struct type *);

static struct value *assign_aggregate (struct value *, struct value *, 
				       struct expression *,
				       int *, enum noside);

static void aggregate_assign_from_choices (struct value *, struct value *, 
					   struct expression *,
					   int *, LONGEST *, int *,
					   int, LONGEST, LONGEST);

static void aggregate_assign_positional (struct value *, struct value *,
					 struct expression *,
					 int *, LONGEST *, int *, int,
					 LONGEST, LONGEST);


static void aggregate_assign_others (struct value *, struct value *,
				     struct expression *,
				     int *, LONGEST *, int, LONGEST, LONGEST);


static void add_component_interval (LONGEST, LONGEST, LONGEST *, int *, int);


static struct value *ada_evaluate_subexp (struct type *, struct expression *,
					  int *, enum noside);

static void ada_forward_operator_length (struct expression *, int, int *,
					 int *);

static struct type *ada_find_any_type (const char *name);



/* Maximum-sized dynamic type.  */
static unsigned int varsize_limit;

/* FIXME: brobecker/2003-09-17: No longer a const because it is
   returned by a function that does not return a const char *.  */
static char *ada_completer_word_break_characters =
#ifdef VMS
  " \t\n!@@#%^&*()+=|~`}{[]\";:?/,-";
#else
  " \t\n!@@#$%^&*()+=|~`}{[]\";:?/,-";
#endif

/* The name of the symbol to use to get the name of the main subprogram.  */
static const char ADA_MAIN_PROGRAM_SYMBOL_NAME[]
  = "__gnat_ada_main_program_name";

/* Limit on the number of warnings to raise per expression evaluation.  */
static int warning_limit = 2;

/* Number of warning messages issued; reset to 0 by cleanups after
   expression evaluation.  */
static int warnings_issued = 0;

static const char *known_runtime_file_name_patterns[] = {
  ADA_KNOWN_RUNTIME_FILE_NAME_PATTERNS NULL
};

static const char *known_auxiliary_function_name_patterns[] = {
  ADA_KNOWN_AUXILIARY_FUNCTION_NAME_PATTERNS NULL
};

/* Space for allocating results of ada_lookup_symbol_list.  */
static struct obstack symbol_list_obstack;

			/* Inferior-specific data.  */

/* Per-inferior data for this module.  */

struct ada_inferior_data
{
  /* The ada__tags__type_specific_data type, which is used when decoding
     tagged types.  With older versions of GNAT, this type was directly
     accessible through a component ("tsd") in the object tag.  But this
     is no longer the case, so we cache it for each inferior.  */
  struct type *tsd_type;

  /* The exception_support_info data.  This data is used to determine
     how to implement support for Ada exception catchpoints in a given
     inferior.  */
  const struct exception_support_info *exception_info;
};

/* Our key to this module's inferior data.  */
static const struct inferior_data *ada_inferior_data;

/* A cleanup routine for our inferior data.  */
static void
ada_inferior_data_cleanup (struct inferior *inf, void *arg)
{
  struct ada_inferior_data *data;

  data = inferior_data (inf, ada_inferior_data);
  if (data != NULL)
    xfree (data);
}

/* Return our inferior data for the given inferior (INF).

   This function always returns a valid pointer to an allocated
   ada_inferior_data structure.  If INF's inferior data has not
   been previously set, this functions creates a new one with all
   fields set to zero, sets INF's inferior to it, and then returns
   a pointer to that newly allocated ada_inferior_data.  */

static struct ada_inferior_data *
get_ada_inferior_data (struct inferior *inf)
{
  struct ada_inferior_data *data;

  data = inferior_data (inf, ada_inferior_data);
  if (data == NULL)
    {
      data = XZALLOC (struct ada_inferior_data);
      set_inferior_data (inf, ada_inferior_data, data);
    }

  return data;
}

/* Perform all necessary cleanups regarding our module's inferior data
   that is required after the inferior INF just exited.  */

static void
ada_inferior_exit (struct inferior *inf)
{
  ada_inferior_data_cleanup (inf, NULL);
  set_inferior_data (inf, ada_inferior_data, NULL);
}

                        /* Utilities */

/* If TYPE is a TYPE_CODE_TYPEDEF type, return the target type after
   all typedef layers have been peeled.  Otherwise, return TYPE.

   Normally, we really expect a typedef type to only have 1 typedef layer.
   In other words, we really expect the target type of a typedef type to be
   a non-typedef type.  This is particularly true for Ada units, because
   the language does not have a typedef vs not-typedef distinction.
   In that respect, the Ada compiler has been trying to eliminate as many
   typedef definitions in the debugging information, since they generally
   do not bring any extra information (we still use typedef under certain
   circumstances related mostly to the GNAT encoding).

   Unfortunately, we have seen situations where the debugging information
   generated by the compiler leads to such multiple typedef layers.  For
   instance, consider the following example with stabs:

     .stabs  "pck__float_array___XUP:Tt(0,46)=s16P_ARRAY:(0,47)=[...]"[...]
     .stabs  "pck__float_array___XUP:t(0,36)=(0,46)",128,0,6,0

   This is an error in the debugging information which causes type
   pck__float_array___XUP to be defined twice, and the second time,
   it is defined as a typedef of a typedef.

   This is on the fringe of legality as far as debugging information is
   concerned, and certainly unexpected.  But it is easy to handle these
   situations correctly, so we can afford to be lenient in this case.  */

static struct type *
ada_typedef_target_type (struct type *type)
{
  while (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)
    type = TYPE_TARGET_TYPE (type);
  return type;
}

/* Given DECODED_NAME a string holding a symbol name in its
   decoded form (ie using the Ada dotted notation), returns
   its unqualified name.  */

static const char *
ada_unqualified_name (const char *decoded_name)
{
  const char *result = strrchr (decoded_name, '.');

  if (result != NULL)
    result++;                   /* Skip the dot...  */
  else
    result = decoded_name;

  return result;
}

/* Return a string starting with '<', followed by STR, and '>'.
   The result is good until the next call.  */

static char *
add_angle_brackets (const char *str)
{
  static char *result = NULL;

  xfree (result);
  result = xstrprintf ("<%s>", str);
  return result;
}

static char *
ada_get_gdb_completer_word_break_characters (void)
{
  return ada_completer_word_break_characters;
}

/* Print an array element index using the Ada syntax.  */

static void
ada_print_array_index (struct value *index_value, struct ui_file *stream,
                       const struct value_print_options *options)
{
  LA_VALUE_PRINT (index_value, stream, options);
  fprintf_filtered (stream, " => ");
}

/* Assuming VECT points to an array of *SIZE objects of size
   ELEMENT_SIZE, grow it to contain at least MIN_SIZE objects,
   updating *SIZE as necessary and returning the (new) array.  */

void *
grow_vect (void *vect, size_t *size, size_t min_size, int element_size)
{
  if (*size < min_size)
    {
      *size *= 2;
      if (*size < min_size)
        *size = min_size;
      vect = xrealloc (vect, *size * element_size);
    }
  return vect;
}

/* True (non-zero) iff TARGET matches FIELD_NAME up to any trailing
   suffix of FIELD_NAME beginning "___".  */

static int
field_name_match (const char *field_name, const char *target)
{
  int len = strlen (target);

  return
    (strncmp (field_name, target, len) == 0
     && (field_name[len] == '\0'
         || (strncmp (field_name + len, "___", 3) == 0
             && strcmp (field_name + strlen (field_name) - 6,
                        "___XVN") != 0)));
}


/* Assuming TYPE is a TYPE_CODE_STRUCT or a TYPE_CODE_TYPDEF to
   a TYPE_CODE_STRUCT, find the field whose name matches FIELD_NAME,
   and return its index.  This function also handles fields whose name
   have ___ suffixes because the compiler sometimes alters their name
   by adding such a suffix to represent fields with certain constraints.
   If the field could not be found, return a negative number if
   MAYBE_MISSING is set.  Otherwise raise an error.  */

int
ada_get_field_index (const struct type *type, const char *field_name,
                     int maybe_missing)
{
  int fieldno;
  struct type *struct_type = check_typedef ((struct type *) type);

  for (fieldno = 0; fieldno < TYPE_NFIELDS (struct_type); fieldno++)
    if (field_name_match (TYPE_FIELD_NAME (struct_type, fieldno), field_name))
      return fieldno;

  if (!maybe_missing)
    error (_("Unable to find field %s in struct %s.  Aborting"),
           field_name, TYPE_NAME (struct_type));

  return -1;
}

/* The length of the prefix of NAME prior to any "___" suffix.  */

int
ada_name_prefix_len (const char *name)
{
  if (name == NULL)
    return 0;
  else
    {
      const char *p = strstr (name, "___");

      if (p == NULL)
        return strlen (name);
      else
        return p - name;
    }
}

/* Return non-zero if SUFFIX is a suffix of STR.
   Return zero if STR is null.  */

static int
is_suffix (const char *str, const char *suffix)
{
  int len1, len2;

  if (str == NULL)
    return 0;
  len1 = strlen (str);
  len2 = strlen (suffix);
  return (len1 >= len2 && strcmp (str + len1 - len2, suffix) == 0);
}

/* The contents of value VAL, treated as a value of type TYPE.  The
   result is an lval in memory if VAL is.  */

static struct value *
coerce_unspec_val_to_type (struct value *val, struct type *type)
{
  type = ada_check_typedef (type);
  if (value_type (val) == type)
    return val;
  else
    {
      struct value *result;

      /* Make sure that the object size is not unreasonable before
         trying to allocate some memory for it.  */
      check_size (type);

      if (value_lazy (val)
          || TYPE_LENGTH (type) > TYPE_LENGTH (value_type (val)))
	result = allocate_value_lazy (type);
      else
	{
	  result = allocate_value (type);
	  memcpy (value_contents_raw (result), value_contents (val),
		  TYPE_LENGTH (type));
	}
      set_value_component_location (result, val);
      set_value_bitsize (result, value_bitsize (val));
      set_value_bitpos (result, value_bitpos (val));
      set_value_address (result, value_address (val));
      set_value_optimized_out (result, value_optimized_out_const (val));
      return result;
    }
}

static const gdb_byte *
cond_offset_host (const gdb_byte *valaddr, long offset)
{
  if (valaddr == NULL)
    return NULL;
  else
    return valaddr + offset;
}

static CORE_ADDR
cond_offset_target (CORE_ADDR address, long offset)
{
  if (address == 0)
    return 0;
  else
    return address + offset;
}

/* Issue a warning (as for the definition of warning in utils.c, but
   with exactly one argument rather than ...), unless the limit on the
   number of warnings has passed during the evaluation of the current
   expression.  */

/* FIXME: cagney/2004-10-10: This function is mimicking the behavior
   provided by "complaint".  */
static void lim_warning (const char *format, ...) ATTRIBUTE_PRINTF (1, 2);

static void
lim_warning (const char *format, ...)
{
  va_list args;

  va_start (args, format);
  warnings_issued += 1;
  if (warnings_issued <= warning_limit)
    vwarning (format, args);

  va_end (args);
}

/* Issue an error if the size of an object of type T is unreasonable,
   i.e. if it would be a bad idea to allocate a value of this type in
   GDB.  */

static void
check_size (const struct type *type)
{
  if (TYPE_LENGTH (type) > varsize_limit)
    error (_("object size is larger than varsize-limit"));
}

/* Maximum value of a SIZE-byte signed integer type.  */
static LONGEST
max_of_size (int size)
{
  LONGEST top_bit = (LONGEST) 1 << (size * 8 - 2);

  return top_bit | (top_bit - 1);
}

/* Minimum value of a SIZE-byte signed integer type.  */
static LONGEST
min_of_size (int size)
{
  return -max_of_size (size) - 1;
}

/* Maximum value of a SIZE-byte unsigned integer type.  */
static ULONGEST
umax_of_size (int size)
{
  ULONGEST top_bit = (ULONGEST) 1 << (size * 8 - 1);

  return top_bit | (top_bit - 1);
}

/* Maximum value of integral type T, as a signed quantity.  */
static LONGEST
max_of_type (struct type *t)
{
  if (TYPE_UNSIGNED (t))
    return (LONGEST) umax_of_size (TYPE_LENGTH (t));
  else
    return max_of_size (TYPE_LENGTH (t));
}

/* Minimum value of integral type T, as a signed quantity.  */
static LONGEST
min_of_type (struct type *t)
{
  if (TYPE_UNSIGNED (t)) 
    return 0;
  else
    return min_of_size (TYPE_LENGTH (t));
}

/* The largest value in the domain of TYPE, a discrete type, as an integer.  */
LONGEST
ada_discrete_type_high_bound (struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_RANGE:
      return TYPE_HIGH_BOUND (type);
    case TYPE_CODE_ENUM:
      return TYPE_FIELD_ENUMVAL (type, TYPE_NFIELDS (type) - 1);
    case TYPE_CODE_BOOL:
      return 1;
    case TYPE_CODE_CHAR:
    case TYPE_CODE_INT:
      return max_of_type (type);
    default:
      error (_("Unexpected type in ada_discrete_type_high_bound."));
    }
}

/* The smallest value in the domain of TYPE, a discrete type, as an integer.  */
LONGEST
ada_discrete_type_low_bound (struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_RANGE:
      return TYPE_LOW_BOUND (type);
    case TYPE_CODE_ENUM:
      return TYPE_FIELD_ENUMVAL (type, 0);
    case TYPE_CODE_BOOL:
      return 0;
    case TYPE_CODE_CHAR:
    case TYPE_CODE_INT:
      return min_of_type (type);
    default:
      error (_("Unexpected type in ada_discrete_type_low_bound."));
    }
}

/* The identity on non-range types.  For range types, the underlying
   non-range scalar type.  */

static struct type *
get_base_type (struct type *type)
{
  while (type != NULL && TYPE_CODE (type) == TYPE_CODE_RANGE)
    {
      if (type == TYPE_TARGET_TYPE (type) || TYPE_TARGET_TYPE (type) == NULL)
        return type;
      type = TYPE_TARGET_TYPE (type);
    }
  return type;
}

/* Return a decoded version of the given VALUE.  This means returning
   a value whose type is obtained by applying all the GNAT-specific
   encondings, making the resulting type a static but standard description
   of the initial type.  */

struct value *
ada_get_decoded_value (struct value *value)
{
  struct type *type = ada_check_typedef (value_type (value));

  if (ada_is_array_descriptor_type (type)
      || (ada_is_constrained_packed_array_type (type)
          && TYPE_CODE (type) != TYPE_CODE_PTR))
    {
      if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)  /* array access type.  */
        value = ada_coerce_to_simple_array_ptr (value);
      else
        value = ada_coerce_to_simple_array (value);
    }
  else
    value = ada_to_fixed_value (value);

  return value;
}

/* Same as ada_get_decoded_value, but with the given TYPE.
   Because there is no associated actual value for this type,
   the resulting type might be a best-effort approximation in
   the case of dynamic types.  */

struct type *
ada_get_decoded_type (struct type *type)
{
  type = to_static_fixed_type (type);
  if (ada_is_constrained_packed_array_type (type))
    type = ada_coerce_to_simple_array_type (type);
  return type;
}



                                /* Language Selection */

/* If the main program is in Ada, return language_ada, otherwise return LANG
   (the main program is in Ada iif the adainit symbol is found).  */

enum language
ada_update_initial_language (enum language lang)
{
  if (lookup_minimal_symbol ("adainit", (const char *) NULL,
                             (struct objfile *) NULL) != NULL)
    return language_ada;

  return lang;
}

/* If the main procedure is written in Ada, then return its name.
   The result is good until the next call.  Return NULL if the main
   procedure doesn't appear to be in Ada.  */

char *
ada_main_name (void)
{
  struct minimal_symbol *msym;
  static char *main_program_name = NULL;

  /* For Ada, the name of the main procedure is stored in a specific
     string constant, generated by the binder.  Look for that symbol,
     extract its address, and then read that string.  If we didn't find
     that string, then most probably the main procedure is not written
     in Ada.  */
  msym = lookup_minimal_symbol (ADA_MAIN_PROGRAM_SYMBOL_NAME, NULL, NULL);

  if (msym != NULL)
    {
      CORE_ADDR main_program_name_addr;
      int err_code;

      main_program_name_addr = SYMBOL_VALUE_ADDRESS (msym);
      if (main_program_name_addr == 0)
        error (_("Invalid address for Ada main program name."));

      xfree (main_program_name);
      target_read_string (main_program_name_addr, &main_program_name,
                          1024, &err_code);

      if (err_code != 0)
        return NULL;
      return main_program_name;
    }

  /* The main procedure doesn't seem to be in Ada.  */
  return NULL;
}

                                /* Symbols */

/* Table of Ada operators and their GNAT-encoded names.  Last entry is pair
   of NULLs.  */

const struct ada_opname_map ada_opname_table[] = {
  {"Oadd", "\"+\"", BINOP_ADD},
  {"Osubtract", "\"-\"", BINOP_SUB},
  {"Omultiply", "\"*\"", BINOP_MUL},
  {"Odivide", "\"/\"", BINOP_DIV},
  {"Omod", "\"mod\"", BINOP_MOD},
  {"Orem", "\"rem\"", BINOP_REM},
  {"Oexpon", "\"**\"", BINOP_EXP},
  {"Olt", "\"<\"", BINOP_LESS},
  {"Ole", "\"<=\"", BINOP_LEQ},
  {"Ogt", "\">\"", BINOP_GTR},
  {"Oge", "\">=\"", BINOP_GEQ},
  {"Oeq", "\"=\"", BINOP_EQUAL},
  {"One", "\"/=\"", BINOP_NOTEQUAL},
  {"Oand", "\"and\"", BINOP_BITWISE_AND},
  {"Oor", "\"or\"", BINOP_BITWISE_IOR},
  {"Oxor", "\"xor\"", BINOP_BITWISE_XOR},
  {"Oconcat", "\"&\"", BINOP_CONCAT},
  {"Oabs", "\"abs\"", UNOP_ABS},
  {"Onot", "\"not\"", UNOP_LOGICAL_NOT},
  {"Oadd", "\"+\"", UNOP_PLUS},
  {"Osubtract", "\"-\"", UNOP_NEG},
  {NULL, NULL}
};

/* The "encoded" form of DECODED, according to GNAT conventions.
   The result is valid until the next call to ada_encode.  */

char *
ada_encode (const char *decoded)
{
  static char *encoding_buffer = NULL;
  static size_t encoding_buffer_size = 0;
  const char *p;
  int k;

  if (decoded == NULL)
    return NULL;

  GROW_VECT (encoding_buffer, encoding_buffer_size,
             2 * strlen (decoded) + 10);

  k = 0;
  for (p = decoded; *p != '\0'; p += 1)
    {
      if (*p == '.')
        {
          encoding_buffer[k] = encoding_buffer[k + 1] = '_';
          k += 2;
        }
      else if (*p == '"')
        {
          const struct ada_opname_map *mapping;

          for (mapping = ada_opname_table;
               mapping->encoded != NULL
               && strncmp (mapping->decoded, p,
                           strlen (mapping->decoded)) != 0; mapping += 1)
            ;
          if (mapping->encoded == NULL)
            error (_("invalid Ada operator name: %s"), p);
          strcpy (encoding_buffer + k, mapping->encoded);
          k += strlen (mapping->encoded);
          break;
        }
      else
        {
          encoding_buffer[k] = *p;
          k += 1;
        }
    }

  encoding_buffer[k] = '\0';
  return encoding_buffer;
}

/* Return NAME folded to lower case, or, if surrounded by single
   quotes, unfolded, but with the quotes stripped away.  Result good
   to next call.  */

char *
ada_fold_name (const char *name)
{
  static char *fold_buffer = NULL;
  static size_t fold_buffer_size = 0;

  int len = strlen (name);
  GROW_VECT (fold_buffer, fold_buffer_size, len + 1);

  if (name[0] == '\'')
    {
      strncpy (fold_buffer, name + 1, len - 2);
      fold_buffer[len - 2] = '\000';
    }
  else
    {
      int i;

      for (i = 0; i <= len; i += 1)
        fold_buffer[i] = tolower (name[i]);
    }

  return fold_buffer;
}

/* Return nonzero if C is either a digit or a lowercase alphabet character.  */

static int
is_lower_alphanum (const char c)
{
  return (isdigit (c) || (isalpha (c) && islower (c)));
}

/* ENCODED is the linkage name of a symbol and LEN contains its length.
   This function saves in LEN the length of that same symbol name but
   without either of these suffixes:
     . .{DIGIT}+
     . ${DIGIT}+
     . ___{DIGIT}+
     . __{DIGIT}+.

   These are suffixes introduced by the compiler for entities such as
   nested subprogram for instance, in order to avoid name clashes.
   They do not serve any purpose for the debugger.  */

static void
ada_remove_trailing_digits (const char *encoded, int *len)
{
  if (*len > 1 && isdigit (encoded[*len - 1]))
    {
      int i = *len - 2;

      while (i > 0 && isdigit (encoded[i]))
        i--;
      if (i >= 0 && encoded[i] == '.')
        *len = i;
      else if (i >= 0 && encoded[i] == '$')
        *len = i;
      else if (i >= 2 && strncmp (encoded + i - 2, "___", 3) == 0)
        *len = i - 2;
      else if (i >= 1 && strncmp (encoded + i - 1, "__", 2) == 0)
        *len = i - 1;
    }
}

/* Remove the suffix introduced by the compiler for protected object
   subprograms.  */

static void
ada_remove_po_subprogram_suffix (const char *encoded, int *len)
{
  /* Remove trailing N.  */

  /* Protected entry subprograms are broken into two
     separate subprograms: The first one is unprotected, and has
     a 'N' suffix; the second is the protected version, and has
     the 'P' suffix.  The second calls the first one after handling
     the protection.  Since the P subprograms are internally generated,
     we leave these names undecoded, giving the user a clue that this
     entity is internal.  */

  if (*len > 1
      && encoded[*len - 1] == 'N'
      && (isdigit (encoded[*len - 2]) || islower (encoded[*len - 2])))
    *len = *len - 1;
}

/* Remove trailing X[bn]* suffixes (indicating names in package bodies).  */

static void
ada_remove_Xbn_suffix (const char *encoded, int *len)
{
  int i = *len - 1;

  while (i > 0 && (encoded[i] == 'b' || encoded[i] == 'n'))
    i--;

  if (encoded[i] != 'X')
    return;

  if (i == 0)
    return;

  if (isalnum (encoded[i-1]))
    *len = i;
}

/* If ENCODED follows the GNAT entity encoding conventions, then return
   the decoded form of ENCODED.  Otherwise, return "<%s>" where "%s" is
   replaced by ENCODED.

   The resulting string is valid until the next call of ada_decode.
   If the string is unchanged by decoding, the original string pointer
   is returned.  */

const char *
ada_decode (const char *encoded)
{
  int i, j;
  int len0;
  const char *p;
  char *decoded;
  int at_start_name;
  static char *decoding_buffer = NULL;
  static size_t decoding_buffer_size = 0;

  /* The name of the Ada main procedure starts with "_ada_".
     This prefix is not part of the decoded name, so skip this part
     if we see this prefix.  */
  if (strncmp (encoded, "_ada_", 5) == 0)
    encoded += 5;

  /* If the name starts with '_', then it is not a properly encoded
     name, so do not attempt to decode it.  Similarly, if the name
     starts with '<', the name should not be decoded.  */
  if (encoded[0] == '_' || encoded[0] == '<')
    goto Suppress;

  len0 = strlen (encoded);

  ada_remove_trailing_digits (encoded, &len0);
  ada_remove_po_subprogram_suffix (encoded, &len0);

  /* Remove the ___X.* suffix if present.  Do not forget to verify that
     the suffix is located before the current "end" of ENCODED.  We want
     to avoid re-matching parts of ENCODED that have previously been
     marked as discarded (by decrementing LEN0).  */
  p = strstr (encoded, "___");
  if (p != NULL && p - encoded < len0 - 3)
    {
      if (p[3] == 'X')
        len0 = p - encoded;
      else
        goto Suppress;
    }

  /* Remove any trailing TKB suffix.  It tells us that this symbol
     is for the body of a task, but that information does not actually
     appear in the decoded name.  */

  if (len0 > 3 && strncmp (encoded + len0 - 3, "TKB", 3) == 0)
    len0 -= 3;

  /* Remove any trailing TB suffix.  The TB suffix is slightly different
     from the TKB suffix because it is used for non-anonymous task
     bodies.  */

  if (len0 > 2 && strncmp (encoded + len0 - 2, "TB", 2) == 0)
    len0 -= 2;

  /* Remove trailing "B" suffixes.  */
  /* FIXME: brobecker/2006-04-19: Not sure what this are used for...  */

  if (len0 > 1 && strncmp (encoded + len0 - 1, "B", 1) == 0)
    len0 -= 1;

  /* Make decoded big enough for possible expansion by operator name.  */

  GROW_VECT (decoding_buffer, decoding_buffer_size, 2 * len0 + 1);
  decoded = decoding_buffer;

  /* Remove trailing __{digit}+ or trailing ${digit}+.  */

  if (len0 > 1 && isdigit (encoded[len0 - 1]))
    {
      i = len0 - 2;
      while ((i >= 0 && isdigit (encoded[i]))
             || (i >= 1 && encoded[i] == '_' && isdigit (encoded[i - 1])))
        i -= 1;
      if (i > 1 && encoded[i] == '_' && encoded[i - 1] == '_')
        len0 = i - 1;
      else if (encoded[i] == '$')
        len0 = i;
    }

  /* The first few characters that are not alphabetic are not part
     of any encoding we use, so we can copy them over verbatim.  */

  for (i = 0, j = 0; i < len0 && !isalpha (encoded[i]); i += 1, j += 1)
    decoded[j] = encoded[i];

  at_start_name = 1;
  while (i < len0)
    {
      /* Is this a symbol function?  */
      if (at_start_name && encoded[i] == 'O')
        {
          int k;

          for (k = 0; ada_opname_table[k].encoded != NULL; k += 1)
            {
              int op_len = strlen (ada_opname_table[k].encoded);
              if ((strncmp (ada_opname_table[k].encoded + 1, encoded + i + 1,
                            op_len - 1) == 0)
                  && !isalnum (encoded[i + op_len]))
                {
                  strcpy (decoded + j, ada_opname_table[k].decoded);
                  at_start_name = 0;
                  i += op_len;
                  j += strlen (ada_opname_table[k].decoded);
                  break;
                }
            }
          if (ada_opname_table[k].encoded != NULL)
            continue;
        }
      at_start_name = 0;

      /* Replace "TK__" with "__", which will eventually be translated
         into "." (just below).  */

      if (i < len0 - 4 && strncmp (encoded + i, "TK__", 4) == 0)
        i += 2;

      /* Replace "__B_{DIGITS}+__" sequences by "__", which will eventually
         be translated into "." (just below).  These are internal names
         generated for anonymous blocks inside which our symbol is nested.  */

      if (len0 - i > 5 && encoded [i] == '_' && encoded [i+1] == '_'
          && encoded [i+2] == 'B' && encoded [i+3] == '_'
          && isdigit (encoded [i+4]))
        {
          int k = i + 5;
          
          while (k < len0 && isdigit (encoded[k]))
            k++;  /* Skip any extra digit.  */

          /* Double-check that the "__B_{DIGITS}+" sequence we found
             is indeed followed by "__".  */
          if (len0 - k > 2 && encoded [k] == '_' && encoded [k+1] == '_')
            i = k;
        }

      /* Remove _E{DIGITS}+[sb] */

      /* Just as for protected object subprograms, there are 2 categories
         of subprograms created by the compiler for each entry.  The first
         one implements the actual entry code, and has a suffix following
         the convention above; the second one implements the barrier and
         uses the same convention as above, except that the 'E' is replaced
         by a 'B'.

         Just as above, we do not decode the name of barrier functions
         to give the user a clue that the code he is debugging has been
         internally generated.  */

      if (len0 - i > 3 && encoded [i] == '_' && encoded[i+1] == 'E'
          && isdigit (encoded[i+2]))
        {
          int k = i + 3;

          while (k < len0 && isdigit (encoded[k]))
            k++;

          if (k < len0
              && (encoded[k] == 'b' || encoded[k] == 's'))
            {
              k++;
              /* Just as an extra precaution, make sure that if this
                 suffix is followed by anything else, it is a '_'.
                 Otherwise, we matched this sequence by accident.  */
              if (k == len0
                  || (k < len0 && encoded[k] == '_'))
                i = k;
            }
        }

      /* Remove trailing "N" in [a-z0-9]+N__.  The N is added by
         the GNAT front-end in protected object subprograms.  */

      if (i < len0 + 3
          && encoded[i] == 'N' && encoded[i+1] == '_' && encoded[i+2] == '_')
        {
          /* Backtrack a bit up until we reach either the begining of
             the encoded name, or "__".  Make sure that we only find
             digits or lowercase characters.  */
          const char *ptr = encoded + i - 1;

          while (ptr >= encoded && is_lower_alphanum (ptr[0]))
            ptr--;
          if (ptr < encoded
              || (ptr > encoded && ptr[0] == '_' && ptr[-1] == '_'))
            i++;
        }

      if (encoded[i] == 'X' && i != 0 && isalnum (encoded[i - 1]))
        {
          /* This is a X[bn]* sequence not separated from the previous
             part of the name with a non-alpha-numeric character (in other
             words, immediately following an alpha-numeric character), then
             verify that it is placed at the end of the encoded name.  If
             not, then the encoding is not valid and we should abort the
             decoding.  Otherwise, just skip it, it is used in body-nested
             package names.  */
          do
            i += 1;
          while (i < len0 && (encoded[i] == 'b' || encoded[i] == 'n'));
          if (i < len0)
            goto Suppress;
        }
      else if (i < len0 - 2 && encoded[i] == '_' && encoded[i + 1] == '_')
        {
         /* Replace '__' by '.'.  */
          decoded[j] = '.';
          at_start_name = 1;
          i += 2;
          j += 1;
        }
      else
        {
          /* It's a character part of the decoded name, so just copy it
             over.  */
          decoded[j] = encoded[i];
          i += 1;
          j += 1;
        }
    }
  decoded[j] = '\000';

  /* Decoded names should never contain any uppercase character.
     Double-check this, and abort the decoding if we find one.  */

  for (i = 0; decoded[i] != '\0'; i += 1)
    if (isupper (decoded[i]) || decoded[i] == ' ')
      goto Suppress;

  if (strcmp (decoded, encoded) == 0)
    return encoded;
  else
    return decoded;

Suppress:
  GROW_VECT (decoding_buffer, decoding_buffer_size, strlen (encoded) + 3);
  decoded = decoding_buffer;
  if (encoded[0] == '<')
    strcpy (decoded, encoded);
  else
    xsnprintf (decoded, decoding_buffer_size, "<%s>", encoded);
  return decoded;

}

/* Table for keeping permanent unique copies of decoded names.  Once
   allocated, names in this table are never released.  While this is a
   storage leak, it should not be significant unless there are massive
   changes in the set of decoded names in successive versions of a 
   symbol table loaded during a single session.  */
static struct htab *decoded_names_store;

/* Returns the decoded name of GSYMBOL, as for ada_decode, caching it
   in the language-specific part of GSYMBOL, if it has not been
   previously computed.  Tries to save the decoded name in the same
   obstack as GSYMBOL, if possible, and otherwise on the heap (so that,
   in any case, the decoded symbol has a lifetime at least that of
   GSYMBOL).
   The GSYMBOL parameter is "mutable" in the C++ sense: logically
   const, but nevertheless modified to a semantically equivalent form
   when a decoded name is cached in it.  */

const char *
ada_decode_symbol (const struct general_symbol_info *arg)
{
  struct general_symbol_info *gsymbol = (struct general_symbol_info *) arg;
  const char **resultp =
    &gsymbol->language_specific.mangled_lang.demangled_name;

  if (!gsymbol->ada_mangled)
    {
      const char *decoded = ada_decode (gsymbol->name);
      struct obstack *obstack = gsymbol->language_specific.obstack;

      gsymbol->ada_mangled = 1;

      if (obstack != NULL)
	*resultp = obstack_copy0 (obstack, decoded, strlen (decoded));
      else
        {
	  /* Sometimes, we can't find a corresponding objfile, in
	     which case, we put the result on the heap.  Since we only
	     decode when needed, we hope this usually does not cause a
	     significant memory leak (FIXME).  */

          char **slot = (char **) htab_find_slot (decoded_names_store,
                                                  decoded, INSERT);

          if (*slot == NULL)
            *slot = xstrdup (decoded);
          *resultp = *slot;
        }
    }

  return *resultp;
}

static char *
ada_la_decode (const char *encoded, int options)
{
  return xstrdup (ada_decode (encoded));
}

/* Returns non-zero iff SYM_NAME matches NAME, ignoring any trailing
   suffixes that encode debugging information or leading _ada_ on
   SYM_NAME (see is_name_suffix commentary for the debugging
   information that is ignored).  If WILD, then NAME need only match a
   suffix of SYM_NAME minus the same suffixes.  Also returns 0 if
   either argument is NULL.  */

static int
match_name (const char *sym_name, const char *name, int wild)
{
  if (sym_name == NULL || name == NULL)
    return 0;
  else if (wild)
    return wild_match (sym_name, name) == 0;
  else
    {
      int len_name = strlen (name);

      return (strncmp (sym_name, name, len_name) == 0
              && is_name_suffix (sym_name + len_name))
        || (strncmp (sym_name, "_ada_", 5) == 0
            && strncmp (sym_name + 5, name, len_name) == 0
            && is_name_suffix (sym_name + len_name + 5));
    }
}


                                /* Arrays */

/* Assuming that INDEX_DESC_TYPE is an ___XA structure, a structure
   generated by the GNAT compiler to describe the index type used
   for each dimension of an array, check whether it follows the latest
   known encoding.  If not, fix it up to conform to the latest encoding.
   Otherwise, do nothing.  This function also does nothing if
   INDEX_DESC_TYPE is NULL.

   The GNAT encoding used to describle the array index type evolved a bit.
   Initially, the information would be provided through the name of each
   field of the structure type only, while the type of these fields was
   described as unspecified and irrelevant.  The debugger was then expected
   to perform a global type lookup using the name of that field in order
   to get access to the full index type description.  Because these global
   lookups can be very expensive, the encoding was later enhanced to make
   the global lookup unnecessary by defining the field type as being
   the full index type description.

   The purpose of this routine is to allow us to support older versions
   of the compiler by detecting the use of the older encoding, and by
   fixing up the INDEX_DESC_TYPE to follow the new one (at this point,
   we essentially replace each field's meaningless type by the associated
   index subtype).  */

void
ada_fixup_array_indexes_type (struct type *index_desc_type)
{
  int i;

  if (index_desc_type == NULL)
    return;
  gdb_assert (TYPE_NFIELDS (index_desc_type) > 0);

  /* Check if INDEX_DESC_TYPE follows the older encoding (it is sufficient
     to check one field only, no need to check them all).  If not, return
     now.

     If our INDEX_DESC_TYPE was generated using the older encoding,
     the field type should be a meaningless integer type whose name
     is not equal to the field name.  */
  if (TYPE_NAME (TYPE_FIELD_TYPE (index_desc_type, 0)) != NULL
      && strcmp (TYPE_NAME (TYPE_FIELD_TYPE (index_desc_type, 0)),
                 TYPE_FIELD_NAME (index_desc_type, 0)) == 0)
    return;

  /* Fixup each field of INDEX_DESC_TYPE.  */
  for (i = 0; i < TYPE_NFIELDS (index_desc_type); i++)
   {
     const char *name = TYPE_FIELD_NAME (index_desc_type, i);
     struct type *raw_type = ada_check_typedef (ada_find_any_type (name));

     if (raw_type)
       TYPE_FIELD_TYPE (index_desc_type, i) = raw_type;
   }
}

/* Names of MAX_ADA_DIMENS bounds in P_BOUNDS fields of array descriptors.  */

static char *bound_name[] = {
  "LB0", "UB0", "LB1", "UB1", "LB2", "UB2", "LB3", "UB3",
  "LB4", "UB4", "LB5", "UB5", "LB6", "UB6", "LB7", "UB7"
};

/* Maximum number of array dimensions we are prepared to handle.  */

#define MAX_ADA_DIMENS (sizeof(bound_name) / (2*sizeof(char *)))


/* The desc_* routines return primitive portions of array descriptors
   (fat pointers).  */

/* The descriptor or array type, if any, indicated by TYPE; removes
   level of indirection, if needed.  */

static struct type *
desc_base_type (struct type *type)
{
  if (type == NULL)
    return NULL;
  type = ada_check_typedef (type);
  if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)
    type = ada_typedef_target_type (type);

  if (type != NULL
      && (TYPE_CODE (type) == TYPE_CODE_PTR
          || TYPE_CODE (type) == TYPE_CODE_REF))
    return ada_check_typedef (TYPE_TARGET_TYPE (type));
  else
    return type;
}

/* True iff TYPE indicates a "thin" array pointer type.  */

static int
is_thin_pntr (struct type *type)
{
  return
    is_suffix (ada_type_name (desc_base_type (type)), "___XUT")
    || is_suffix (ada_type_name (desc_base_type (type)), "___XUT___XVE");
}

/* The descriptor type for thin pointer type TYPE.  */

static struct type *
thin_descriptor_type (struct type *type)
{
  struct type *base_type = desc_base_type (type);

  if (base_type == NULL)
    return NULL;
  if (is_suffix (ada_type_name (base_type), "___XVE"))
    return base_type;
  else
    {
      struct type *alt_type = ada_find_parallel_type (base_type, "___XVE");

      if (alt_type == NULL)
        return base_type;
      else
        return alt_type;
    }
}

/* A pointer to the array data for thin-pointer value VAL.  */

static struct value *
thin_data_pntr (struct value *val)
{
  struct type *type = ada_check_typedef (value_type (val));
  struct type *data_type = desc_data_target_type (thin_descriptor_type (type));

  data_type = lookup_pointer_type (data_type);

  if (TYPE_CODE (type) == TYPE_CODE_PTR)
    return value_cast (data_type, value_copy (val));
  else
    return value_from_longest (data_type, value_address (val));
}

/* True iff TYPE indicates a "thick" array pointer type.  */

static int
is_thick_pntr (struct type *type)
{
  type = desc_base_type (type);
  return (type != NULL && TYPE_CODE (type) == TYPE_CODE_STRUCT
          && lookup_struct_elt_type (type, "P_BOUNDS", 1) != NULL);
}

/* If TYPE is the type of an array descriptor (fat or thin pointer) or a
   pointer to one, the type of its bounds data; otherwise, NULL.  */

static struct type *
desc_bounds_type (struct type *type)
{
  struct type *r;

  type = desc_base_type (type);

  if (type == NULL)
    return NULL;
  else if (is_thin_pntr (type))
    {
      type = thin_descriptor_type (type);
      if (type == NULL)
        return NULL;
      r = lookup_struct_elt_type (type, "BOUNDS", 1);
      if (r != NULL)
        return ada_check_typedef (r);
    }
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT)
    {
      r = lookup_struct_elt_type (type, "P_BOUNDS", 1);
      if (r != NULL)
        return ada_check_typedef (TYPE_TARGET_TYPE (ada_check_typedef (r)));
    }
  return NULL;
}

/* If ARR is an array descriptor (fat or thin pointer), or pointer to
   one, a pointer to its bounds data.   Otherwise NULL.  */

static struct value *
desc_bounds (struct value *arr)
{
  struct type *type = ada_check_typedef (value_type (arr));

  if (is_thin_pntr (type))
    {
      struct type *bounds_type =
        desc_bounds_type (thin_descriptor_type (type));
      LONGEST addr;

      if (bounds_type == NULL)
        error (_("Bad GNAT array descriptor"));

      /* NOTE: The following calculation is not really kosher, but
         since desc_type is an XVE-encoded type (and shouldn't be),
         the correct calculation is a real pain.  FIXME (and fix GCC).  */
      if (TYPE_CODE (type) == TYPE_CODE_PTR)
        addr = value_as_long (arr);
      else
        addr = value_address (arr);

      return
        value_from_longest (lookup_pointer_type (bounds_type),
                            addr - TYPE_LENGTH (bounds_type));
    }

  else if (is_thick_pntr (type))
    {
      struct value *p_bounds = value_struct_elt (&arr, NULL, "P_BOUNDS", NULL,
					       _("Bad GNAT array descriptor"));
      struct type *p_bounds_type = value_type (p_bounds);

      if (p_bounds_type
	  && TYPE_CODE (p_bounds_type) == TYPE_CODE_PTR)
	{
	  struct type *target_type = TYPE_TARGET_TYPE (p_bounds_type);

	  if (TYPE_STUB (target_type))
	    p_bounds = value_cast (lookup_pointer_type
				   (ada_check_typedef (target_type)),
				   p_bounds);
	}
      else
	error (_("Bad GNAT array descriptor"));

      return p_bounds;
    }
  else
    return NULL;
}

/* If TYPE is the type of an array-descriptor (fat pointer),  the bit
   position of the field containing the address of the bounds data.  */

static int
fat_pntr_bounds_bitpos (struct type *type)
{
  return TYPE_FIELD_BITPOS (desc_base_type (type), 1);
}

/* If TYPE is the type of an array-descriptor (fat pointer), the bit
   size of the field containing the address of the bounds data.  */

static int
fat_pntr_bounds_bitsize (struct type *type)
{
  type = desc_base_type (type);

  if (TYPE_FIELD_BITSIZE (type, 1) > 0)
    return TYPE_FIELD_BITSIZE (type, 1);
  else
    return 8 * TYPE_LENGTH (ada_check_typedef (TYPE_FIELD_TYPE (type, 1)));
}

/* If TYPE is the type of an array descriptor (fat or thin pointer) or a
   pointer to one, the type of its array data (a array-with-no-bounds type);
   otherwise, NULL.  Use ada_type_of_array to get an array type with bounds
   data.  */

static struct type *
desc_data_target_type (struct type *type)
{
  type = desc_base_type (type);

  /* NOTE: The following is bogus; see comment in desc_bounds.  */
  if (is_thin_pntr (type))
    return desc_base_type (TYPE_FIELD_TYPE (thin_descriptor_type (type), 1));
  else if (is_thick_pntr (type))
    {
      struct type *data_type = lookup_struct_elt_type (type, "P_ARRAY", 1);

      if (data_type
	  && TYPE_CODE (ada_check_typedef (data_type)) == TYPE_CODE_PTR)
	return ada_check_typedef (TYPE_TARGET_TYPE (data_type));
    }

  return NULL;
}

/* If ARR is an array descriptor (fat or thin pointer), a pointer to
   its array data.  */

static struct value *
desc_data (struct value *arr)
{
  struct type *type = value_type (arr);

  if (is_thin_pntr (type))
    return thin_data_pntr (arr);
  else if (is_thick_pntr (type))
    return value_struct_elt (&arr, NULL, "P_ARRAY", NULL,
                             _("Bad GNAT array descriptor"));
  else
    return NULL;
}


/* If TYPE is the type of an array-descriptor (fat pointer), the bit
   position of the field containing the address of the data.  */

static int
fat_pntr_data_bitpos (struct type *type)
{
  return TYPE_FIELD_BITPOS (desc_base_type (type), 0);
}

/* If TYPE is the type of an array-descriptor (fat pointer), the bit
   size of the field containing the address of the data.  */

static int
fat_pntr_data_bitsize (struct type *type)
{
  type = desc_base_type (type);

  if (TYPE_FIELD_BITSIZE (type, 0) > 0)
    return TYPE_FIELD_BITSIZE (type, 0);
  else
    return TARGET_CHAR_BIT * TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0));
}

/* If BOUNDS is an array-bounds structure (or pointer to one), return
   the Ith lower bound stored in it, if WHICH is 0, and the Ith upper
   bound, if WHICH is 1.  The first bound is I=1.  */

static struct value *
desc_one_bound (struct value *bounds, int i, int which)
{
  return value_struct_elt (&bounds, NULL, bound_name[2 * i + which - 2], NULL,
                           _("Bad GNAT array descriptor bounds"));
}

/* If BOUNDS is an array-bounds structure type, return the bit position
   of the Ith lower bound stored in it, if WHICH is 0, and the Ith upper
   bound, if WHICH is 1.  The first bound is I=1.  */

static int
desc_bound_bitpos (struct type *type, int i, int which)
{
  return TYPE_FIELD_BITPOS (desc_base_type (type), 2 * i + which - 2);
}

/* If BOUNDS is an array-bounds structure type, return the bit field size
   of the Ith lower bound stored in it, if WHICH is 0, and the Ith upper
   bound, if WHICH is 1.  The first bound is I=1.  */

static int
desc_bound_bitsize (struct type *type, int i, int which)
{
  type = desc_base_type (type);

  if (TYPE_FIELD_BITSIZE (type, 2 * i + which - 2) > 0)
    return TYPE_FIELD_BITSIZE (type, 2 * i + which - 2);
  else
    return 8 * TYPE_LENGTH (TYPE_FIELD_TYPE (type, 2 * i + which - 2));
}

/* If TYPE is the type of an array-bounds structure, the type of its
   Ith bound (numbering from 1).  Otherwise, NULL.  */

static struct type *
desc_index_type (struct type *type, int i)
{
  type = desc_base_type (type);

  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)
    return lookup_struct_elt_type (type, bound_name[2 * i - 2], 1);
  else
    return NULL;
}

/* The number of index positions in the array-bounds type TYPE.
   Return 0 if TYPE is NULL.  */

static int
desc_arity (struct type *type)
{
  type = desc_base_type (type);

  if (type != NULL)
    return TYPE_NFIELDS (type) / 2;
  return 0;
}

/* Non-zero iff TYPE is a simple array type (not a pointer to one) or 
   an array descriptor type (representing an unconstrained array
   type).  */

static int
ada_is_direct_array_type (struct type *type)
{
  if (type == NULL)
    return 0;
  type = ada_check_typedef (type);
  return (TYPE_CODE (type) == TYPE_CODE_ARRAY
          || ada_is_array_descriptor_type (type));
}

/* Non-zero iff TYPE represents any kind of array in Ada, or a pointer
 * to one.  */

static int
ada_is_array_type (struct type *type)
{
  while (type != NULL 
	 && (TYPE_CODE (type) == TYPE_CODE_PTR 
	     || TYPE_CODE (type) == TYPE_CODE_REF))
    type = TYPE_TARGET_TYPE (type);
  return ada_is_direct_array_type (type);
}

/* Non-zero iff TYPE is a simple array type or pointer to one.  */

int
ada_is_simple_array_type (struct type *type)
{
  if (type == NULL)
    return 0;
  type = ada_check_typedef (type);
  return (TYPE_CODE (type) == TYPE_CODE_ARRAY
          || (TYPE_CODE (type) == TYPE_CODE_PTR
              && TYPE_CODE (ada_check_typedef (TYPE_TARGET_TYPE (type)))
                 == TYPE_CODE_ARRAY));
}

/* Non-zero iff TYPE belongs to a GNAT array descriptor.  */

int
ada_is_array_descriptor_type (struct type *type)
{
  struct type *data_type = desc_data_target_type (type);

  if (type == NULL)
    return 0;
  type = ada_check_typedef (type);
  return (data_type != NULL
	  && TYPE_CODE (data_type) == TYPE_CODE_ARRAY
	  && desc_arity (desc_bounds_type (type)) > 0);
}

/* Non-zero iff type is a partially mal-formed GNAT array
   descriptor.  FIXME: This is to compensate for some problems with
   debugging output from GNAT.  Re-examine periodically to see if it
   is still needed.  */

int
ada_is_bogus_array_descriptor (struct type *type)
{
  return
    type != NULL
    && TYPE_CODE (type) == TYPE_CODE_STRUCT
    && (lookup_struct_elt_type (type, "P_BOUNDS", 1) != NULL
        || lookup_struct_elt_type (type, "P_ARRAY", 1) != NULL)
    && !ada_is_array_descriptor_type (type);
}


/* If ARR has a record type in the form of a standard GNAT array descriptor,
   (fat pointer) returns the type of the array data described---specifically,
   a pointer-to-array type.  If BOUNDS is non-zero, the bounds data are filled
   in from the descriptor; otherwise, they are left unspecified.  If
   the ARR denotes a null array descriptor and BOUNDS is non-zero,
   returns NULL.  The result is simply the type of ARR if ARR is not
   a descriptor.  */
struct type *
ada_type_of_array (struct value *arr, int bounds)
{
  if (ada_is_constrained_packed_array_type (value_type (arr)))
    return decode_constrained_packed_array_type (value_type (arr));

  if (!ada_is_array_descriptor_type (value_type (arr)))
    return value_type (arr);

  if (!bounds)
    {
      struct type *array_type =
	ada_check_typedef (desc_data_target_type (value_type (arr)));

      if (ada_is_unconstrained_packed_array_type (value_type (arr)))
	TYPE_FIELD_BITSIZE (array_type, 0) =
	  decode_packed_array_bitsize (value_type (arr));
      
      return array_type;
    }
  else
    {
      struct type *elt_type;
      int arity;
      struct value *descriptor;

      elt_type = ada_array_element_type (value_type (arr), -1);
      arity = ada_array_arity (value_type (arr));

      if (elt_type == NULL || arity == 0)
        return ada_check_typedef (value_type (arr));

      descriptor = desc_bounds (arr);
      if (value_as_long (descriptor) == 0)
        return NULL;
      while (arity > 0)
        {
          struct type *range_type = alloc_type_copy (value_type (arr));
          struct type *array_type = alloc_type_copy (value_type (arr));
          struct value *low = desc_one_bound (descriptor, arity, 0);
          struct value *high = desc_one_bound (descriptor, arity, 1);

          arity -= 1;
          create_range_type (range_type, value_type (low),
                             longest_to_int (value_as_long (low)),
                             longest_to_int (value_as_long (high)));
          elt_type = create_array_type (array_type, elt_type, range_type);

	  if (ada_is_unconstrained_packed_array_type (value_type (arr)))
	    {
	      /* We need to store the element packed bitsize, as well as
	         recompute the array size, because it was previously
		 computed based on the unpacked element size.  */
	      LONGEST lo = value_as_long (low);
	      LONGEST hi = value_as_long (high);

	      TYPE_FIELD_BITSIZE (elt_type, 0) =
		decode_packed_array_bitsize (value_type (arr));
	      /* If the array has no element, then the size is already
	         zero, and does not need to be recomputed.  */
	      if (lo < hi)
		{
		  int array_bitsize =
		        (hi - lo + 1) * TYPE_FIELD_BITSIZE (elt_type, 0);

		  TYPE_LENGTH (array_type) = (array_bitsize + 7) / 8;
		}
	    }
        }

      return lookup_pointer_type (elt_type);
    }
}

/* If ARR does not represent an array, returns ARR unchanged.
   Otherwise, returns either a standard GDB array with bounds set
   appropriately or, if ARR is a non-null fat pointer, a pointer to a standard
   GDB array.  Returns NULL if ARR is a null fat pointer.  */

struct value *
ada_coerce_to_simple_array_ptr (struct value *arr)
{
  if (ada_is_array_descriptor_type (value_type (arr)))
    {
      struct type *arrType = ada_type_of_array (arr, 1);

      if (arrType == NULL)
        return NULL;
      return value_cast (arrType, value_copy (desc_data (arr)));
    }
  else if (ada_is_constrained_packed_array_type (value_type (arr)))
    return decode_constrained_packed_array (arr);
  else
    return arr;
}

/* If ARR does not represent an array, returns ARR unchanged.
   Otherwise, returns a standard GDB array describing ARR (which may
   be ARR itself if it already is in the proper form).  */

struct value *
ada_coerce_to_simple_array (struct value *arr)
{
  if (ada_is_array_descriptor_type (value_type (arr)))
    {
      struct value *arrVal = ada_coerce_to_simple_array_ptr (arr);

      if (arrVal == NULL)
        error (_("Bounds unavailable for null array pointer."));
      check_size (TYPE_TARGET_TYPE (value_type (arrVal)));
      return value_ind (arrVal);
    }
  else if (ada_is_constrained_packed_array_type (value_type (arr)))
    return decode_constrained_packed_array (arr);
  else
    return arr;
}

/* If TYPE represents a GNAT array type, return it translated to an
   ordinary GDB array type (possibly with BITSIZE fields indicating
   packing).  For other types, is the identity.  */

struct type *
ada_coerce_to_simple_array_type (struct type *type)
{
  if (ada_is_constrained_packed_array_type (type))
    return decode_constrained_packed_array_type (type);

  if (ada_is_array_descriptor_type (type))
    return ada_check_typedef (desc_data_target_type (type));

  return type;
}

/* Non-zero iff TYPE represents a standard GNAT packed-array type.  */

static int
ada_is_packed_array_type  (struct type *type)
{
  if (type == NULL)
    return 0;
  type = desc_base_type (type);
  type = ada_check_typedef (type);
  return
    ada_type_name (type) != NULL
    && strstr (ada_type_name (type), "___XP") != NULL;
}

/* Non-zero iff TYPE represents a standard GNAT constrained
   packed-array type.  */

int
ada_is_constrained_packed_array_type (struct type *type)
{
  return ada_is_packed_array_type (type)
    && !ada_is_array_descriptor_type (type);
}

/* Non-zero iff TYPE represents an array descriptor for a
   unconstrained packed-array type.  */

static int
ada_is_unconstrained_packed_array_type (struct type *type)
{
  return ada_is_packed_array_type (type)
    && ada_is_array_descriptor_type (type);
}

/* Given that TYPE encodes a packed array type (constrained or unconstrained),
   return the size of its elements in bits.  */

static long
decode_packed_array_bitsize (struct type *type)
{
  const char *raw_name;
  const char *tail;
  long bits;

  /* Access to arrays implemented as fat pointers are encoded as a typedef
     of the fat pointer type.  We need the name of the fat pointer type
     to do the decoding, so strip the typedef layer.  */
  if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)
    type = ada_typedef_target_type (type);

  raw_name = ada_type_name (ada_check_typedef (type));
  if (!raw_name)
    raw_name = ada_type_name (desc_base_type (type));

  if (!raw_name)
    return 0;

  tail = strstr (raw_name, "___XP");
  gdb_assert (tail != NULL);

  if (sscanf (tail + sizeof ("___XP") - 1, "%ld", &bits) != 1)
    {
      lim_warning
	(_("could not understand bit size information on packed array"));
      return 0;
    }

  return bits;
}

/* Given that TYPE is a standard GDB array type with all bounds filled
   in, and that the element size of its ultimate scalar constituents
   (that is, either its elements, or, if it is an array of arrays, its
   elements' elements, etc.) is *ELT_BITS, return an identical type,
   but with the bit sizes of its elements (and those of any
   constituent arrays) recorded in the BITSIZE components of its
   TYPE_FIELD_BITSIZE values, and with *ELT_BITS set to its total size
   in bits.  */

static struct type *
constrained_packed_array_type (struct type *type, long *elt_bits)
{
  struct type *new_elt_type;
  struct type *new_type;
  struct type *index_type_desc;
  struct type *index_type;
  LONGEST low_bound, high_bound;

  type = ada_check_typedef (type);
  if (TYPE_CODE (type) != TYPE_CODE_ARRAY)
    return type;

  index_type_desc = ada_find_parallel_type (type, "___XA");
  if (index_type_desc)
    index_type = to_fixed_range_type (TYPE_FIELD_TYPE (index_type_desc, 0),
				      NULL);
  else
    index_type = TYPE_INDEX_TYPE (type);

  new_type = alloc_type_copy (type);
  new_elt_type =
    constrained_packed_array_type (ada_check_typedef (TYPE_TARGET_TYPE (type)),
				   elt_bits);
  create_array_type (new_type, new_elt_type, index_type);
  TYPE_FIELD_BITSIZE (new_type, 0) = *elt_bits;
  TYPE_NAME (new_type) = ada_type_name (type);

  if (get_discrete_bounds (index_type, &low_bound, &high_bound) < 0)
    low_bound = high_bound = 0;
  if (high_bound < low_bound)
    *elt_bits = TYPE_LENGTH (new_type) = 0;
  else
    {
      *elt_bits *= (high_bound - low_bound + 1);
      TYPE_LENGTH (new_type) =
        (*elt_bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;
    }

  TYPE_FIXED_INSTANCE (new_type) = 1;
  return new_type;
}

/* The array type encoded by TYPE, where
   ada_is_constrained_packed_array_type (TYPE).  */

static struct type *
decode_constrained_packed_array_type (struct type *type)
{
  const char *raw_name = ada_type_name (ada_check_typedef (type));
  char *name;
  const char *tail;
  struct type *shadow_type;
  long bits;

  if (!raw_name)
    raw_name = ada_type_name (desc_base_type (type));

  if (!raw_name)
    return NULL;

  name = (char *) alloca (strlen (raw_name) + 1);
  tail = strstr (raw_name, "___XP");
  type = desc_base_type (type);

  memcpy (name, raw_name, tail - raw_name);
  name[tail - raw_name] = '\000';

  shadow_type = ada_find_parallel_type_with_name (type, name);

  if (shadow_type == NULL)
    {
      lim_warning (_("could not find bounds information on packed array"));
      return NULL;
    }
  CHECK_TYPEDEF (shadow_type);

  if (TYPE_CODE (shadow_type) != TYPE_CODE_ARRAY)
    {
      lim_warning (_("could not understand bounds "
		     "information on packed array"));
      return NULL;
    }

  bits = decode_packed_array_bitsize (type);
  return constrained_packed_array_type (shadow_type, &bits);
}

/* Given that ARR is a struct value *indicating a GNAT constrained packed
   array, returns a simple array that denotes that array.  Its type is a
   standard GDB array type except that the BITSIZEs of the array
   target types are set to the number of bits in each element, and the
   type length is set appropriately.  */

static struct value *
decode_constrained_packed_array (struct value *arr)
{
  struct type *type;

  arr = ada_coerce_ref (arr);

  /* If our value is a pointer, then dererence it.  Make sure that
     this operation does not cause the target type to be fixed, as
     this would indirectly cause this array to be decoded.  The rest
     of the routine assumes that the array hasn't been decoded yet,
     so we use the basic "value_ind" routine to perform the dereferencing,
     as opposed to using "ada_value_ind".  */
  if (TYPE_CODE (ada_check_typedef (value_type (arr))) == TYPE_CODE_PTR)
    arr = value_ind (arr);

  type = decode_constrained_packed_array_type (value_type (arr));
  if (type == NULL)
    {
      error (_("can't unpack array"));
      return NULL;
    }

  if (gdbarch_bits_big_endian (get_type_arch (value_type (arr)))
      && ada_is_modular_type (value_type (arr)))
    {
       /* This is a (right-justified) modular type representing a packed
 	 array with no wrapper.  In order to interpret the value through
 	 the (left-justified) packed array type we just built, we must
 	 first left-justify it.  */
      int bit_size, bit_pos;
      ULONGEST mod;

      mod = ada_modulus (value_type (arr)) - 1;
      bit_size = 0;
      while (mod > 0)
	{
	  bit_size += 1;
	  mod >>= 1;
	}
      bit_pos = HOST_CHAR_BIT * TYPE_LENGTH (value_type (arr)) - bit_size;
      arr = ada_value_primitive_packed_val (arr, NULL,
					    bit_pos / HOST_CHAR_BIT,
					    bit_pos % HOST_CHAR_BIT,
					    bit_size,
					    type);
    }

  return coerce_unspec_val_to_type (arr, type);
}


/* The value of the element of packed array ARR at the ARITY indices
   given in IND.   ARR must be a simple array.  */

static struct value *
value_subscript_packed (struct value *arr, int arity, struct value **ind)
{
  int i;
  int bits, elt_off, bit_off;
  long elt_total_bit_offset;
  struct type *elt_type;
  struct value *v;

  bits = 0;
  elt_total_bit_offset = 0;
  elt_type = ada_check_typedef (value_type (arr));
  for (i = 0; i < arity; i += 1)
    {
      if (TYPE_CODE (elt_type) != TYPE_CODE_ARRAY
          || TYPE_FIELD_BITSIZE (elt_type, 0) == 0)
        error
          (_("attempt to do packed indexing of "
	     "something other than a packed array"));
      else
        {
          struct type *range_type = TYPE_INDEX_TYPE (elt_type);
          LONGEST lowerbound, upperbound;
          LONGEST idx;

          if (get_discrete_bounds (range_type, &lowerbound, &upperbound) < 0)
            {
              lim_warning (_("don't know bounds of array"));
              lowerbound = upperbound = 0;
            }

          idx = pos_atr (ind[i]);
          if (idx < lowerbound || idx > upperbound)
            lim_warning (_("packed array index %ld out of bounds"),
			 (long) idx);
          bits = TYPE_FIELD_BITSIZE (elt_type, 0);
          elt_total_bit_offset += (idx - lowerbound) * bits;
          elt_type = ada_check_typedef (TYPE_TARGET_TYPE (elt_type));
        }
    }
  elt_off = elt_total_bit_offset / HOST_CHAR_BIT;
  bit_off = elt_total_bit_offset % HOST_CHAR_BIT;

  v = ada_value_primitive_packed_val (arr, NULL, elt_off, bit_off,
                                      bits, elt_type);
  return v;
}

/* Non-zero iff TYPE includes negative integer values.  */

static int
has_negatives (struct type *type)
{
  switch (TYPE_CODE (type))
    {
    default:
      return 0;
    case TYPE_CODE_INT:
      return !TYPE_UNSIGNED (type);
    case TYPE_CODE_RANGE:
      return TYPE_LOW_BOUND (type) < 0;
    }
}


/* Create a new value of type TYPE from the contents of OBJ starting
   at byte OFFSET, and bit offset BIT_OFFSET within that byte,
   proceeding for BIT_SIZE bits.  If OBJ is an lval in memory, then
   assigning through the result will set the field fetched from.
   VALADDR is ignored unless OBJ is NULL, in which case,
   VALADDR+OFFSET must address the start of storage containing the 
   packed value.  The value returned  in this case is never an lval.
   Assumes 0 <= BIT_OFFSET < HOST_CHAR_BIT.  */

struct value *
ada_value_primitive_packed_val (struct value *obj, const gdb_byte *valaddr,
				long offset, int bit_offset, int bit_size,
                                struct type *type)
{
  struct value *v;
  int src,                      /* Index into the source area */
    targ,                       /* Index into the target area */
    srcBitsLeft,                /* Number of source bits left to move */
    nsrc, ntarg,                /* Number of source and target bytes */
    unusedLS,                   /* Number of bits in next significant
                                   byte of source that are unused */
    accumSize;                  /* Number of meaningful bits in accum */
  unsigned char *bytes;         /* First byte containing data to unpack */
  unsigned char *unpacked;
  unsigned long accum;          /* Staging area for bits being transferred */
  unsigned char sign;
  int len = (bit_size + bit_offset + HOST_CHAR_BIT - 1) / 8;
  /* Transmit bytes from least to most significant; delta is the direction
     the indices move.  */
  int delta = gdbarch_bits_big_endian (get_type_arch (type)) ? -1 : 1;

  type = ada_check_typedef (type);

  if (obj == NULL)
    {
      v = allocate_value (type);
      bytes = (unsigned char *) (valaddr + offset);
    }
  else if (VALUE_LVAL (obj) == lval_memory && value_lazy (obj))
    {
      v = value_at (type, value_address (obj));
      bytes = (unsigned char *) alloca (len);
      read_memory (value_address (v) + offset, bytes, len);
    }
  else
    {
      v = allocate_value (type);
      bytes = (unsigned char *) value_contents (obj) + offset;
    }

  if (obj != NULL)
    {
      long new_offset = offset;

      set_value_component_location (v, obj);
      set_value_bitpos (v, bit_offset + value_bitpos (obj));
      set_value_bitsize (v, bit_size);
      if (value_bitpos (v) >= HOST_CHAR_BIT)
        {
	  ++new_offset;
          set_value_bitpos (v, value_bitpos (v) - HOST_CHAR_BIT);
        }
      set_value_offset (v, new_offset);

      /* Also set the parent value.  This is needed when trying to
	 assign a new value (in inferior memory).  */
      set_value_parent (v, obj);
    }
  else
    set_value_bitsize (v, bit_size);
  unpacked = (unsigned char *) value_contents (v);

  srcBitsLeft = bit_size;
  nsrc = len;
  ntarg = TYPE_LENGTH (type);
  sign = 0;
  if (bit_size == 0)
    {
      memset (unpacked, 0, TYPE_LENGTH (type));
      return v;
    }
  else if (gdbarch_bits_big_endian (get_type_arch (type)))
    {
      src = len - 1;
      if (has_negatives (type)
          && ((bytes[0] << bit_offset) & (1 << (HOST_CHAR_BIT - 1))))
        sign = ~0;

      unusedLS =
        (HOST_CHAR_BIT - (bit_size + bit_offset) % HOST_CHAR_BIT)
        % HOST_CHAR_BIT;

      switch (TYPE_CODE (type))
        {
        case TYPE_CODE_ARRAY:
        case TYPE_CODE_UNION:
        case TYPE_CODE_STRUCT:
          /* Non-scalar values must be aligned at a byte boundary...  */
          accumSize =
            (HOST_CHAR_BIT - bit_size % HOST_CHAR_BIT) % HOST_CHAR_BIT;
          /* ... And are placed at the beginning (most-significant) bytes
             of the target.  */
          targ = (bit_size + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT - 1;
          ntarg = targ + 1;
          break;
        default:
          accumSize = 0;
          targ = TYPE_LENGTH (type) - 1;
          break;
        }
    }
  else
    {
      int sign_bit_offset = (bit_size + bit_offset - 1) % 8;

      src = targ = 0;
      unusedLS = bit_offset;
      accumSize = 0;

      if (has_negatives (type) && (bytes[len - 1] & (1 << sign_bit_offset)))
        sign = ~0;
    }

  accum = 0;
  while (nsrc > 0)
    {
      /* Mask for removing bits of the next source byte that are not
         part of the value.  */
      unsigned int unusedMSMask =
        (1 << (srcBitsLeft >= HOST_CHAR_BIT ? HOST_CHAR_BIT : srcBitsLeft)) -
        1;
      /* Sign-extend bits for this byte.  */
      unsigned int signMask = sign & ~unusedMSMask;

      accum |=
        (((bytes[src] >> unusedLS) & unusedMSMask) | signMask) << accumSize;
      accumSize += HOST_CHAR_BIT - unusedLS;
      if (accumSize >= HOST_CHAR_BIT)
        {
          unpacked[targ] = accum & ~(~0L << HOST_CHAR_BIT);
          accumSize -= HOST_CHAR_BIT;
          accum >>= HOST_CHAR_BIT;
          ntarg -= 1;
          targ += delta;
        }
      srcBitsLeft -= HOST_CHAR_BIT - unusedLS;
      unusedLS = 0;
      nsrc -= 1;
      src += delta;
    }
  while (ntarg > 0)
    {
      accum |= sign << accumSize;
      unpacked[targ] = accum & ~(~0L << HOST_CHAR_BIT);
      accumSize -= HOST_CHAR_BIT;
      accum >>= HOST_CHAR_BIT;
      ntarg -= 1;
      targ += delta;
    }

  return v;
}

/* Move N bits from SOURCE, starting at bit offset SRC_OFFSET to
   TARGET, starting at bit offset TARG_OFFSET.  SOURCE and TARGET must
   not overlap.  */
static void
move_bits (gdb_byte *target, int targ_offset, const gdb_byte *source,
	   int src_offset, int n, int bits_big_endian_p)
{
  unsigned int accum, mask;
  int accum_bits, chunk_size;

  target += targ_offset / HOST_CHAR_BIT;
  targ_offset %= HOST_CHAR_BIT;
  source += src_offset / HOST_CHAR_BIT;
  src_offset %= HOST_CHAR_BIT;
  if (bits_big_endian_p)
    {
      accum = (unsigned char) *source;
      source += 1;
      accum_bits = HOST_CHAR_BIT - src_offset;

      while (n > 0)
        {
          int unused_right;

          accum = (accum << HOST_CHAR_BIT) + (unsigned char) *source;
          accum_bits += HOST_CHAR_BIT;
          source += 1;
          chunk_size = HOST_CHAR_BIT - targ_offset;
          if (chunk_size > n)
            chunk_size = n;
          unused_right = HOST_CHAR_BIT - (chunk_size + targ_offset);
          mask = ((1 << chunk_size) - 1) << unused_right;
          *target =
            (*target & ~mask)
            | ((accum >> (accum_bits - chunk_size - unused_right)) & mask);
          n -= chunk_size;
          accum_bits -= chunk_size;
          target += 1;
          targ_offset = 0;
        }
    }
  else
    {
      accum = (unsigned char) *source >> src_offset;
      source += 1;
      accum_bits = HOST_CHAR_BIT - src_offset;

      while (n > 0)
        {
          accum = accum + ((unsigned char) *source << accum_bits);
          accum_bits += HOST_CHAR_BIT;
          source += 1;
          chunk_size = HOST_CHAR_BIT - targ_offset;
          if (chunk_size > n)
            chunk_size = n;
          mask = ((1 << chunk_size) - 1) << targ_offset;
          *target = (*target & ~mask) | ((accum << targ_offset) & mask);
          n -= chunk_size;
          accum_bits -= chunk_size;
          accum >>= chunk_size;
          target += 1;
          targ_offset = 0;
        }
    }
}

/* Store the contents of FROMVAL into the location of TOVAL.
   Return a new value with the location of TOVAL and contents of
   FROMVAL.   Handles assignment into packed fields that have
   floating-point or non-scalar types.  */

static struct value *
ada_value_assign (struct value *toval, struct value *fromval)
{
  struct type *type = value_type (toval);
  int bits = value_bitsize (toval);

  toval = ada_coerce_ref (toval);
  fromval = ada_coerce_ref (fromval);

  if (ada_is_direct_array_type (value_type (toval)))
    toval = ada_coerce_to_simple_array (toval);
  if (ada_is_direct_array_type (value_type (fromval)))
    fromval = ada_coerce_to_simple_array (fromval);

  if (!deprecated_value_modifiable (toval))
    error (_("Left operand of assignment is not a modifiable lvalue."));

  if (VALUE_LVAL (toval) == lval_memory
      && bits > 0
      && (TYPE_CODE (type) == TYPE_CODE_FLT
          || TYPE_CODE (type) == TYPE_CODE_STRUCT))
    {
      int len = (value_bitpos (toval)
		 + bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;
      int from_size;
      gdb_byte *buffer = alloca (len);
      struct value *val;
      CORE_ADDR to_addr = value_address (toval);

      if (TYPE_CODE (type) == TYPE_CODE_FLT)
        fromval = value_cast (type, fromval);

      read_memory (to_addr, buffer, len);
      from_size = value_bitsize (fromval);
      if (from_size == 0)
	from_size = TYPE_LENGTH (value_type (fromval)) * TARGET_CHAR_BIT;
      if (gdbarch_bits_big_endian (get_type_arch (type)))
        move_bits (buffer, value_bitpos (toval),
		   value_contents (fromval), from_size - bits, bits, 1);
      else
        move_bits (buffer, value_bitpos (toval),
		   value_contents (fromval), 0, bits, 0);
      write_memory_with_notification (to_addr, buffer, len);

      val = value_copy (toval);
      memcpy (value_contents_raw (val), value_contents (fromval),
              TYPE_LENGTH (type));
      deprecated_set_value_type (val, type);

      return val;
    }

  return value_assign (toval, fromval);
}


/* Given that COMPONENT is a memory lvalue that is part of the lvalue 
 * CONTAINER, assign the contents of VAL to COMPONENTS's place in 
 * CONTAINER.  Modifies the VALUE_CONTENTS of CONTAINER only, not 
 * COMPONENT, and not the inferior's memory.  The current contents 
 * of COMPONENT are ignored.  */
static void
value_assign_to_component (struct value *container, struct value *component,
			   struct value *val)
{
  LONGEST offset_in_container =
    (LONGEST)  (value_address (component) - value_address (container));
  int bit_offset_in_container = 
    value_bitpos (component) - value_bitpos (container);
  int bits;
  
  val = value_cast (value_type (component), val);

  if (value_bitsize (component) == 0)
    bits = TARGET_CHAR_BIT * TYPE_LENGTH (value_type (component));
  else
    bits = value_bitsize (component);

  if (gdbarch_bits_big_endian (get_type_arch (value_type (container))))
    move_bits (value_contents_writeable (container) + offset_in_container, 
	       value_bitpos (container) + bit_offset_in_container,
	       value_contents (val),
	       TYPE_LENGTH (value_type (component)) * TARGET_CHAR_BIT - bits,
	       bits, 1);
  else
    move_bits (value_contents_writeable (container) + offset_in_container, 
	       value_bitpos (container) + bit_offset_in_container,
	       value_contents (val), 0, bits, 0);
}	       
			
/* The value of the element of array ARR at the ARITY indices given in IND.
   ARR may be either a simple array, GNAT array descriptor, or pointer
   thereto.  */

struct value *
ada_value_subscript (struct value *arr, int arity, struct value **ind)
{
  int k;
  struct value *elt;
  struct type *elt_type;

  elt = ada_coerce_to_simple_array (arr);

  elt_type = ada_check_typedef (value_type (elt));
  if (TYPE_CODE (elt_type) == TYPE_CODE_ARRAY
      && TYPE_FIELD_BITSIZE (elt_type, 0) > 0)
    return value_subscript_packed (elt, arity, ind);

  for (k = 0; k < arity; k += 1)
    {
      if (TYPE_CODE (elt_type) != TYPE_CODE_ARRAY)
        error (_("too many subscripts (%d expected)"), k);
      elt = value_subscript (elt, pos_atr (ind[k]));
    }
  return elt;
}

/* Assuming ARR is a pointer to a standard GDB array of type TYPE, the
   value of the element of *ARR at the ARITY indices given in
   IND.  Does not read the entire array into memory.  */

static struct value *
ada_value_ptr_subscript (struct value *arr, struct type *type, int arity,
                         struct value **ind)
{
  int k;

  for (k = 0; k < arity; k += 1)
    {
      LONGEST lwb, upb;

      if (TYPE_CODE (type) != TYPE_CODE_ARRAY)
        error (_("too many subscripts (%d expected)"), k);
      arr = value_cast (lookup_pointer_type (TYPE_TARGET_TYPE (type)),
                        value_copy (arr));
      get_discrete_bounds (TYPE_INDEX_TYPE (type), &lwb, &upb);
      arr = value_ptradd (arr, pos_atr (ind[k]) - lwb);
      type = TYPE_TARGET_TYPE (type);
    }

  return value_ind (arr);
}

/* Given that ARRAY_PTR is a pointer or reference to an array of type TYPE (the
   actual type of ARRAY_PTR is ignored), returns the Ada slice of HIGH-LOW+1
   elements starting at index LOW.  The lower bound of this array is LOW, as
   per Ada rules.  */
static struct value *
ada_value_slice_from_ptr (struct value *array_ptr, struct type *type,
                          int low, int high)
{
  struct type *type0 = ada_check_typedef (type);
  CORE_ADDR base = value_as_address (array_ptr)
    + ((low - ada_discrete_type_low_bound (TYPE_INDEX_TYPE (type0)))
       * TYPE_LENGTH (TYPE_TARGET_TYPE (type0)));
  struct type *index_type =
    create_range_type (NULL, TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (type0)),
                       low, high);
  struct type *slice_type =
    create_array_type (NULL, TYPE_TARGET_TYPE (type0), index_type);

  return value_at_lazy (slice_type, base);
}


static struct value *
ada_value_slice (struct value *array, int low, int high)
{
  struct type *type = ada_check_typedef (value_type (array));
  struct type *index_type =
    create_range_type (NULL, TYPE_INDEX_TYPE (type), low, high);
  struct type *slice_type =
    create_array_type (NULL, TYPE_TARGET_TYPE (type), index_type);

  return value_cast (slice_type, value_slice (array, low, high - low + 1));
}

/* If type is a record type in the form of a standard GNAT array
   descriptor, returns the number of dimensions for type.  If arr is a
   simple array, returns the number of "array of"s that prefix its
   type designation.  Otherwise, returns 0.  */

int
ada_array_arity (struct type *type)
{
  int arity;

  if (type == NULL)
    return 0;

  type = desc_base_type (type);

  arity = 0;
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)
    return desc_arity (desc_bounds_type (type));
  else
    while (TYPE_CODE (type) == TYPE_CODE_ARRAY)
      {
        arity += 1;
        type = ada_check_typedef (TYPE_TARGET_TYPE (type));
      }

  return arity;
}

/* If TYPE is a record type in the form of a standard GNAT array
   descriptor or a simple array type, returns the element type for
   TYPE after indexing by NINDICES indices, or by all indices if
   NINDICES is -1.  Otherwise, returns NULL.  */

struct type *
ada_array_element_type (struct type *type, int nindices)
{
  type = desc_base_type (type);

  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)
    {
      int k;
      struct type *p_array_type;

      p_array_type = desc_data_target_type (type);

      k = ada_array_arity (type);
      if (k == 0)
        return NULL;

      /* Initially p_array_type = elt_type(*)[]...(k times)...[].  */
      if (nindices >= 0 && k > nindices)
        k = nindices;
      while (k > 0 && p_array_type != NULL)
        {
          p_array_type = ada_check_typedef (TYPE_TARGET_TYPE (p_array_type));
          k -= 1;
        }
      return p_array_type;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      while (nindices != 0 && TYPE_CODE (type) == TYPE_CODE_ARRAY)
        {
          type = TYPE_TARGET_TYPE (type);
          nindices -= 1;
        }
      return type;
    }

  return NULL;
}

/* The type of nth index in arrays of given type (n numbering from 1).
   Does not examine memory.  Throws an error if N is invalid or TYPE
   is not an array type.  NAME is the name of the Ada attribute being
   evaluated ('range, 'first, 'last, or 'length); it is used in building
   the error message.  */

static struct type *
ada_index_type (struct type *type, int n, const char *name)
{
  struct type *result_type;

  type = desc_base_type (type);

  if (n < 0 || n > ada_array_arity (type))
    error (_("invalid dimension number to '%s"), name);

  if (ada_is_simple_array_type (type))
    {
      int i;

      for (i = 1; i < n; i += 1)
        type = TYPE_TARGET_TYPE (type);
      result_type = TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (type));
      /* FIXME: The stabs type r(0,0);bound;bound in an array type
         has a target type of TYPE_CODE_UNDEF.  We compensate here, but
         perhaps stabsread.c would make more sense.  */
      if (result_type && TYPE_CODE (result_type) == TYPE_CODE_UNDEF)
        result_type = NULL;
    }
  else
    {
      result_type = desc_index_type (desc_bounds_type (type), n);
      if (result_type == NULL)
	error (_("attempt to take bound of something that is not an array"));
    }

  return result_type;
}

/* Given that arr is an array type, returns the lower bound of the
   Nth index (numbering from 1) if WHICH is 0, and the upper bound if
   WHICH is 1.  This returns bounds 0 .. -1 if ARR_TYPE is an
   array-descriptor type.  It works for other arrays with bounds supplied
   by run-time quantities other than discriminants.  */

static LONGEST
ada_array_bound_from_type (struct type * arr_type, int n, int which)
{
  struct type *type, *elt_type, *index_type_desc, *index_type;
  int i;

  gdb_assert (which == 0 || which == 1);

  if (ada_is_constrained_packed_array_type (arr_type))
    arr_type = decode_constrained_packed_array_type (arr_type);

  if (arr_type == NULL || !ada_is_simple_array_type (arr_type))
    return (LONGEST) - which;

  if (TYPE_CODE (arr_type) == TYPE_CODE_PTR)
    type = TYPE_TARGET_TYPE (arr_type);
  else
    type = arr_type;

  elt_type = type;
  for (i = n; i > 1; i--)
    elt_type = TYPE_TARGET_TYPE (type);

  index_type_desc = ada_find_parallel_type (type, "___XA");
  ada_fixup_array_indexes_type (index_type_desc);
  if (index_type_desc != NULL)
    index_type = to_fixed_range_type (TYPE_FIELD_TYPE (index_type_desc, n - 1),
				      NULL);
  else
    index_type = TYPE_INDEX_TYPE (elt_type);

  return
    (LONGEST) (which == 0
               ? ada_discrete_type_low_bound (index_type)
               : ada_discrete_type_high_bound (index_type));
}

/* Given that arr is an array value, returns the lower bound of the
   nth index (numbering from 1) if WHICH is 0, and the upper bound if
   WHICH is 1.  This routine will also work for arrays with bounds
   supplied by run-time quantities other than discriminants.  */

static LONGEST
ada_array_bound (struct value *arr, int n, int which)
{
  struct type *arr_type = value_type (arr);

  if (ada_is_constrained_packed_array_type (arr_type))
    return ada_array_bound (decode_constrained_packed_array (arr), n, which);
  else if (ada_is_simple_array_type (arr_type))
    return ada_array_bound_from_type (arr_type, n, which);
  else
    return value_as_long (desc_one_bound (desc_bounds (arr), n, which));
}

/* Given that arr is an array value, returns the length of the
   nth index.  This routine will also work for arrays with bounds
   supplied by run-time quantities other than discriminants.
   Does not work for arrays indexed by enumeration types with representation
   clauses at the moment.  */

static LONGEST
ada_array_length (struct value *arr, int n)
{
  struct type *arr_type = ada_check_typedef (value_type (arr));

  if (ada_is_constrained_packed_array_type (arr_type))
    return ada_array_length (decode_constrained_packed_array (arr), n);

  if (ada_is_simple_array_type (arr_type))
    return (ada_array_bound_from_type (arr_type, n, 1)
	    - ada_array_bound_from_type (arr_type, n, 0) + 1);
  else
    return (value_as_long (desc_one_bound (desc_bounds (arr), n, 1))
	    - value_as_long (desc_one_bound (desc_bounds (arr), n, 0)) + 1);
}

/* An empty array whose type is that of ARR_TYPE (an array type),
   with bounds LOW to LOW-1.  */

static struct value *
empty_array (struct type *arr_type, int low)
{
  struct type *arr_type0 = ada_check_typedef (arr_type);
  struct type *index_type =
    create_range_type (NULL, TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (arr_type0)),
                       low, low - 1);
  struct type *elt_type = ada_array_element_type (arr_type0, 1);

  return allocate_value (create_array_type (NULL, elt_type, index_type));
}


                                /* Name resolution */

/* The "decoded" name for the user-definable Ada operator corresponding
   to OP.  */

static const char *
ada_decoded_op_name (enum exp_opcode op)
{
  int i;

  for (i = 0; ada_opname_table[i].encoded != NULL; i += 1)
    {
      if (ada_opname_table[i].op == op)
        return ada_opname_table[i].decoded;
    }
  error (_("Could not find operator name for opcode"));
}


/* Same as evaluate_type (*EXP), but resolves ambiguous symbol
   references (marked by OP_VAR_VALUE nodes in which the symbol has an
   undefined namespace) and converts operators that are
   user-defined into appropriate function calls.  If CONTEXT_TYPE is
   non-null, it provides a preferred result type [at the moment, only
   type void has any effect---causing procedures to be preferred over
   functions in calls].  A null CONTEXT_TYPE indicates that a non-void
   return type is preferred.  May change (expand) *EXP.  */

static void
resolve (struct expression **expp, int void_context_p)
{
  struct type *context_type = NULL;
  int pc = 0;

  if (void_context_p)
    context_type = builtin_type ((*expp)->gdbarch)->builtin_void;

  resolve_subexp (expp, &pc, 1, context_type);
}

/* Resolve the operator of the subexpression beginning at
   position *POS of *EXPP.  "Resolving" consists of replacing
   the symbols that have undefined namespaces in OP_VAR_VALUE nodes
   with their resolutions, replacing built-in operators with
   function calls to user-defined operators, where appropriate, and,
   when DEPROCEDURE_P is non-zero, converting function-valued variables
   into parameterless calls.  May expand *EXPP.  The CONTEXT_TYPE functions
   are as in ada_resolve, above.  */

static struct value *
resolve_subexp (struct expression **expp, int *pos, int deprocedure_p,
                struct type *context_type)
{
  int pc = *pos;
  int i;
  struct expression *exp;       /* Convenience: == *expp.  */
  enum exp_opcode op = (*expp)->elts[pc].opcode;
  struct value **argvec;        /* Vector of operand types (alloca'ed).  */
  int nargs;                    /* Number of operands.  */
  int oplen;

  argvec = NULL;
  nargs = 0;
  exp = *expp;

  /* Pass one: resolve operands, saving their types and updating *pos,
     if needed.  */
  switch (op)
    {
    case OP_FUNCALL:
      if (exp->elts[pc + 3].opcode == OP_VAR_VALUE
          && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)
        *pos += 7;
      else
        {
          *pos += 3;
          resolve_subexp (expp, pos, 0, NULL);
        }
      nargs = longest_to_int (exp->elts[pc + 1].longconst);
      break;

    case UNOP_ADDR:
      *pos += 1;
      resolve_subexp (expp, pos, 0, NULL);
      break;

    case UNOP_QUAL:
      *pos += 3;
      resolve_subexp (expp, pos, 1, check_typedef (exp->elts[pc + 1].type));
      break;

    case OP_ATR_MODULUS:
    case OP_ATR_SIZE:
    case OP_ATR_TAG:
    case OP_ATR_FIRST:
    case OP_ATR_LAST:
    case OP_ATR_LENGTH:
    case OP_ATR_POS:
    case OP_ATR_VAL:
    case OP_ATR_MIN:
    case OP_ATR_MAX:
    case TERNOP_IN_RANGE:
    case BINOP_IN_BOUNDS:
    case UNOP_IN_RANGE:
    case OP_AGGREGATE:
    case OP_OTHERS:
    case OP_CHOICES:
    case OP_POSITIONAL:
    case OP_DISCRETE_RANGE:
    case OP_NAME:
      ada_forward_operator_length (exp, pc, &oplen, &nargs);
      *pos += oplen;
      break;

    case BINOP_ASSIGN:
      {
        struct value *arg1;

        *pos += 1;
        arg1 = resolve_subexp (expp, pos, 0, NULL);
        if (arg1 == NULL)
          resolve_subexp (expp, pos, 1, NULL);
        else
          resolve_subexp (expp, pos, 1, value_type (arg1));
        break;
      }

    case UNOP_CAST:
      *pos += 3;
      nargs = 1;
      break;

    case BINOP_ADD:
    case BINOP_SUB:
    case BINOP_MUL:
    case BINOP_DIV:
    case BINOP_REM:
    case BINOP_MOD:
    case BINOP_EXP:
    case BINOP_CONCAT:
    case BINOP_LOGICAL_AND:
    case BINOP_LOGICAL_OR:
    case BINOP_BITWISE_AND:
    case BINOP_BITWISE_IOR:
    case BINOP_BITWISE_XOR:

    case BINOP_EQUAL:
    case BINOP_NOTEQUAL:
    case BINOP_LESS:
    case BINOP_GTR:
    case BINOP_LEQ:
    case BINOP_GEQ:

    case BINOP_REPEAT:
    case BINOP_SUBSCRIPT:
    case BINOP_COMMA:
      *pos += 1;
      nargs = 2;
      break;

    case UNOP_NEG:
    case UNOP_PLUS:
    case UNOP_LOGICAL_NOT:
    case UNOP_ABS:
    case UNOP_IND:
      *pos += 1;
      nargs = 1;
      break;

    case OP_LONG:
    case OP_DOUBLE:
    case OP_VAR_VALUE:
      *pos += 4;
      break;

    case OP_TYPE:
    case OP_BOOL:
    case OP_LAST:
    case OP_INTERNALVAR:
      *pos += 3;
      break;

    case UNOP_MEMVAL:
      *pos += 3;
      nargs = 1;
      break;

    case OP_REGISTER:
      *pos += 4 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);
      break;

    case STRUCTOP_STRUCT:
      *pos += 4 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);
      nargs = 1;
      break;

    case TERNOP_SLICE:
      *pos += 1;
      nargs = 3;
      break;

    case OP_STRING:
      break;

    default:
      error (_("Unexpected operator during name resolution"));
    }

  argvec = (struct value * *) alloca (sizeof (struct value *) * (nargs + 1));
  for (i = 0; i < nargs; i += 1)
    argvec[i] = resolve_subexp (expp, pos, 1, NULL);
  argvec[i] = NULL;
  exp = *expp;

  /* Pass two: perform any resolution on principal operator.  */
  switch (op)
    {
    default:
      break;

    case OP_VAR_VALUE:
      if (SYMBOL_DOMAIN (exp->elts[pc + 2].symbol) == UNDEF_DOMAIN)
        {
          struct ada_symbol_info *candidates;
          int n_candidates;

          n_candidates =
            ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME
                                    (exp->elts[pc + 2].symbol),
                                    exp->elts[pc + 1].block, VAR_DOMAIN,
                                    &candidates);

          if (n_candidates > 1)
            {
              /* Types tend to get re-introduced locally, so if there
                 are any local symbols that are not types, first filter
                 out all types.  */
              int j;
              for (j = 0; j < n_candidates; j += 1)
                switch (SYMBOL_CLASS (candidates[j].sym))
                  {
                  case LOC_REGISTER:
                  case LOC_ARG:
                  case LOC_REF_ARG:
                  case LOC_REGPARM_ADDR:
                  case LOC_LOCAL:
                  case LOC_COMPUTED:
                    goto FoundNonType;
                  default:
                    break;
                  }
            FoundNonType:
              if (j < n_candidates)
                {
                  j = 0;
                  while (j < n_candidates)
                    {
                      if (SYMBOL_CLASS (candidates[j].sym) == LOC_TYPEDEF)
                        {
                          candidates[j] = candidates[n_candidates - 1];
                          n_candidates -= 1;
                        }
                      else
                        j += 1;
                    }
                }
            }

          if (n_candidates == 0)
            error (_("No definition found for %s"),
                   SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
          else if (n_candidates == 1)
            i = 0;
          else if (deprocedure_p
                   && !is_nonfunction (candidates, n_candidates))
            {
              i = ada_resolve_function
                (candidates, n_candidates, NULL, 0,
                 SYMBOL_LINKAGE_NAME (exp->elts[pc + 2].symbol),
                 context_type);
              if (i < 0)
                error (_("Could not find a match for %s"),
                       SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
            }
          else
            {
              printf_filtered (_("Multiple matches for %s\n"),
                               SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
              user_select_syms (candidates, n_candidates, 1);
              i = 0;
            }

          exp->elts[pc + 1].block = candidates[i].block;
          exp->elts[pc + 2].symbol = candidates[i].sym;
          if (innermost_block == NULL
              || contained_in (candidates[i].block, innermost_block))
            innermost_block = candidates[i].block;
        }

      if (deprocedure_p
          && (TYPE_CODE (SYMBOL_TYPE (exp->elts[pc + 2].symbol))
              == TYPE_CODE_FUNC))
        {
          replace_operator_with_call (expp, pc, 0, 0,
                                      exp->elts[pc + 2].symbol,
                                      exp->elts[pc + 1].block);
          exp = *expp;
        }
      break;

    case OP_FUNCALL:
      {
        if (exp->elts[pc + 3].opcode == OP_VAR_VALUE
            && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)
          {
            struct ada_symbol_info *candidates;
            int n_candidates;

            n_candidates =
              ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME
                                      (exp->elts[pc + 5].symbol),
                                      exp->elts[pc + 4].block, VAR_DOMAIN,
                                      &candidates);
            if (n_candidates == 1)
              i = 0;
            else
              {
                i = ada_resolve_function
                  (candidates, n_candidates,
                   argvec, nargs,
                   SYMBOL_LINKAGE_NAME (exp->elts[pc + 5].symbol),
                   context_type);
                if (i < 0)
                  error (_("Could not find a match for %s"),
                         SYMBOL_PRINT_NAME (exp->elts[pc + 5].symbol));
              }

            exp->elts[pc + 4].block = candidates[i].block;
            exp->elts[pc + 5].symbol = candidates[i].sym;
            if (innermost_block == NULL
                || contained_in (candidates[i].block, innermost_block))
              innermost_block = candidates[i].block;
          }
      }
      break;
    case BINOP_ADD:
    case BINOP_SUB:
    case BINOP_MUL:
    case BINOP_DIV:
    case BINOP_REM:
    case BINOP_MOD:
    case BINOP_CONCAT:
    case BINOP_BITWISE_AND:
    case BINOP_BITWISE_IOR:
    case BINOP_BITWISE_XOR:
    case BINOP_EQUAL:
    case BINOP_NOTEQUAL:
    case BINOP_LESS:
    case BINOP_GTR:
    case BINOP_LEQ:
    case BINOP_GEQ:
    case BINOP_EXP:
    case UNOP_NEG:
    case UNOP_PLUS:
    case UNOP_LOGICAL_NOT:
    case UNOP_ABS:
      if (possible_user_operator_p (op, argvec))
        {
          struct ada_symbol_info *candidates;
          int n_candidates;

          n_candidates =
            ada_lookup_symbol_list (ada_encode (ada_decoded_op_name (op)),
                                    (struct block *) NULL, VAR_DOMAIN,
                                    &candidates);
          i = ada_resolve_function (candidates, n_candidates, argvec, nargs,
                                    ada_decoded_op_name (op), NULL);
          if (i < 0)
            break;

          replace_operator_with_call (expp, pc, nargs, 1,
                                      candidates[i].sym, candidates[i].block);
          exp = *expp;
        }
      break;

    case OP_TYPE:
    case OP_REGISTER:
      return NULL;
    }

  *pos = pc;
  return evaluate_subexp_type (exp, pos);
}

/* Return non-zero if formal type FTYPE matches actual type ATYPE.  If
   MAY_DEREF is non-zero, the formal may be a pointer and the actual
   a non-pointer.  */
/* The term "match" here is rather loose.  The match is heuristic and
   liberal.  */

static int
ada_type_match (struct type *ftype, struct type *atype, int may_deref)
{
  ftype = ada_check_typedef (ftype);
  atype = ada_check_typedef (atype);

  if (TYPE_CODE (ftype) == TYPE_CODE_REF)
    ftype = TYPE_TARGET_TYPE (ftype);
  if (TYPE_CODE (atype) == TYPE_CODE_REF)
    atype = TYPE_TARGET_TYPE (atype);

  switch (TYPE_CODE (ftype))
    {
    default:
      return TYPE_CODE (ftype) == TYPE_CODE (atype);
    case TYPE_CODE_PTR:
      if (TYPE_CODE (atype) == TYPE_CODE_PTR)
        return ada_type_match (TYPE_TARGET_TYPE (ftype),
                               TYPE_TARGET_TYPE (atype), 0);
      else
        return (may_deref
                && ada_type_match (TYPE_TARGET_TYPE (ftype), atype, 0));
    case TYPE_CODE_INT:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_RANGE:
      switch (TYPE_CODE (atype))
        {
        case TYPE_CODE_INT:
        case TYPE_CODE_ENUM:
        case TYPE_CODE_RANGE:
          return 1;
        default:
          return 0;
        }

    case TYPE_CODE_ARRAY:
      return (TYPE_CODE (atype) == TYPE_CODE_ARRAY
              || ada_is_array_descriptor_type (atype));

    case TYPE_CODE_STRUCT:
      if (ada_is_array_descriptor_type (ftype))
        return (TYPE_CODE (atype) == TYPE_CODE_ARRAY
                || ada_is_array_descriptor_type (atype));
      else
        return (TYPE_CODE (atype) == TYPE_CODE_STRUCT
                && !ada_is_array_descriptor_type (atype));

    case TYPE_CODE_UNION:
    case TYPE_CODE_FLT:
      return (TYPE_CODE (atype) == TYPE_CODE (ftype));
    }
}

/* Return non-zero if the formals of FUNC "sufficiently match" the
   vector of actual argument types ACTUALS of size N_ACTUALS.  FUNC
   may also be an enumeral, in which case it is treated as a 0-
   argument function.  */

static int
ada_args_match (struct symbol *func, struct value **actuals, int n_actuals)
{
  int i;
  struct type *func_type = SYMBOL_TYPE (func);

  if (SYMBOL_CLASS (func) == LOC_CONST
      && TYPE_CODE (func_type) == TYPE_CODE_ENUM)
    return (n_actuals == 0);
  else if (func_type == NULL || TYPE_CODE (func_type) != TYPE_CODE_FUNC)
    return 0;

  if (TYPE_NFIELDS (func_type) != n_actuals)
    return 0;

  for (i = 0; i < n_actuals; i += 1)
    {
      if (actuals[i] == NULL)
        return 0;
      else
        {
          struct type *ftype = ada_check_typedef (TYPE_FIELD_TYPE (func_type,
								   i));
          struct type *atype = ada_check_typedef (value_type (actuals[i]));

          if (!ada_type_match (ftype, atype, 1))
            return 0;
        }
    }
  return 1;
}

/* False iff function type FUNC_TYPE definitely does not produce a value
   compatible with type CONTEXT_TYPE.  Conservatively returns 1 if
   FUNC_TYPE is not a valid function type with a non-null return type
   or an enumerated type.  A null CONTEXT_TYPE indicates any non-void type.  */

static int
return_match (struct type *func_type, struct type *context_type)
{
  struct type *return_type;

  if (func_type == NULL)
    return 1;

  if (TYPE_CODE (func_type) == TYPE_CODE_FUNC)
    return_type = get_base_type (TYPE_TARGET_TYPE (func_type));
  else
    return_type = get_base_type (func_type);
  if (return_type == NULL)
    return 1;

  context_type = get_base_type (context_type);

  if (TYPE_CODE (return_type) == TYPE_CODE_ENUM)
    return context_type == NULL || return_type == context_type;
  else if (context_type == NULL)
    return TYPE_CODE (return_type) != TYPE_CODE_VOID;
  else
    return TYPE_CODE (return_type) == TYPE_CODE (context_type);
}


/* Returns the index in SYMS[0..NSYMS-1] that contains  the symbol for the
   function (if any) that matches the types of the NARGS arguments in
   ARGS.  If CONTEXT_TYPE is non-null and there is at least one match
   that returns that type, then eliminate matches that don't.  If
   CONTEXT_TYPE is void and there is at least one match that does not
   return void, eliminate all matches that do.

   Asks the user if there is more than one match remaining.  Returns -1
   if there is no such symbol or none is selected.  NAME is used
   solely for messages.  May re-arrange and modify SYMS in
   the process; the index returned is for the modified vector.  */

static int
ada_resolve_function (struct ada_symbol_info syms[],
                      int nsyms, struct value **args, int nargs,
                      const char *name, struct type *context_type)
{
  int fallback;
  int k;
  int m;                        /* Number of hits */

  m = 0;
  /* In the first pass of the loop, we only accept functions matching
     context_type.  If none are found, we add a second pass of the loop
     where every function is accepted.  */
  for (fallback = 0; m == 0 && fallback < 2; fallback++)
    {
      for (k = 0; k < nsyms; k += 1)
        {
          struct type *type = ada_check_typedef (SYMBOL_TYPE (syms[k].sym));

          if (ada_args_match (syms[k].sym, args, nargs)
              && (fallback || return_match (type, context_type)))
            {
              syms[m] = syms[k];
              m += 1;
            }
        }
    }

  if (m == 0)
    return -1;
  else if (m > 1)
    {
      printf_filtered (_("Multiple matches for %s\n"), name);
      user_select_syms (syms, m, 1);
      return 0;
    }
  return 0;
}

/* Returns true (non-zero) iff decoded name N0 should appear before N1
   in a listing of choices during disambiguation (see sort_choices, below).
   The idea is that overloadings of a subprogram name from the
   same package should sort in their source order.  We settle for ordering
   such symbols by their trailing number (__N  or $N).  */

static int
encoded_ordered_before (const char *N0, const char *N1)
{
  if (N1 == NULL)
    return 0;
  else if (N0 == NULL)
    return 1;
  else
    {
      int k0, k1;

      for (k0 = strlen (N0) - 1; k0 > 0 && isdigit (N0[k0]); k0 -= 1)
        ;
      for (k1 = strlen (N1) - 1; k1 > 0 && isdigit (N1[k1]); k1 -= 1)
        ;
      if ((N0[k0] == '_' || N0[k0] == '$') && N0[k0 + 1] != '\000'
          && (N1[k1] == '_' || N1[k1] == '$') && N1[k1 + 1] != '\000')
        {
          int n0, n1;

          n0 = k0;
          while (N0[n0] == '_' && n0 > 0 && N0[n0 - 1] == '_')
            n0 -= 1;
          n1 = k1;
          while (N1[n1] == '_' && n1 > 0 && N1[n1 - 1] == '_')
            n1 -= 1;
          if (n0 == n1 && strncmp (N0, N1, n0) == 0)
            return (atoi (N0 + k0 + 1) < atoi (N1 + k1 + 1));
        }
      return (strcmp (N0, N1) < 0);
    }
}

/* Sort SYMS[0..NSYMS-1] to put the choices in a canonical order by the
   encoded names.  */

static void
sort_choices (struct ada_symbol_info syms[], int nsyms)
{
  int i;

  for (i = 1; i < nsyms; i += 1)
    {
      struct ada_symbol_info sym = syms[i];
      int j;

      for (j = i - 1; j >= 0; j -= 1)
        {
          if (encoded_ordered_before (SYMBOL_LINKAGE_NAME (syms[j].sym),
                                      SYMBOL_LINKAGE_NAME (sym.sym)))
            break;
          syms[j + 1] = syms[j];
        }
      syms[j + 1] = sym;
    }
}

/* Given a list of NSYMS symbols in SYMS, select up to MAX_RESULTS>0 
   by asking the user (if necessary), returning the number selected, 
   and setting the first elements of SYMS items.  Error if no symbols
   selected.  */

/* NOTE: Adapted from decode_line_2 in symtab.c, with which it ought
   to be re-integrated one of these days.  */

int
user_select_syms (struct ada_symbol_info *syms, int nsyms, int max_results)
{
  int i;
  int *chosen = (int *) alloca (sizeof (int) * nsyms);
  int n_chosen;
  int first_choice = (max_results == 1) ? 1 : 2;
  const char *select_mode = multiple_symbols_select_mode ();

  if (max_results < 1)
    error (_("Request to select 0 symbols!"));
  if (nsyms <= 1)
    return nsyms;

  if (select_mode == multiple_symbols_cancel)
    error (_("\
canceled because the command is ambiguous\n\
See set/show multiple-symbol."));
  
  /* If select_mode is "all", then return all possible symbols.
     Only do that if more than one symbol can be selected, of course.
     Otherwise, display the menu as usual.  */
  if (select_mode == multiple_symbols_all && max_results > 1)
    return nsyms;

  printf_unfiltered (_("[0] cancel\n"));
  if (max_results > 1)
    printf_unfiltered (_("[1] all\n"));

  sort_choices (syms, nsyms);

  for (i = 0; i < nsyms; i += 1)
    {
      if (syms[i].sym == NULL)
        continue;

      if (SYMBOL_CLASS (syms[i].sym) == LOC_BLOCK)
        {
          struct symtab_and_line sal =
            find_function_start_sal (syms[i].sym, 1);

	  if (sal.symtab == NULL)
	    printf_unfiltered (_("[%d] %s at <no source file available>:%d\n"),
			       i + first_choice,
			       SYMBOL_PRINT_NAME (syms[i].sym),
			       sal.line);
	  else
	    printf_unfiltered (_("[%d] %s at %s:%d\n"), i + first_choice,
			       SYMBOL_PRINT_NAME (syms[i].sym),
			       symtab_to_filename_for_display (sal.symtab),
			       sal.line);
          continue;
        }
      else
        {
          int is_enumeral =
            (SYMBOL_CLASS (syms[i].sym) == LOC_CONST
             && SYMBOL_TYPE (syms[i].sym) != NULL
             && TYPE_CODE (SYMBOL_TYPE (syms[i].sym)) == TYPE_CODE_ENUM);
          struct symtab *symtab = SYMBOL_SYMTAB (syms[i].sym);

          if (SYMBOL_LINE (syms[i].sym) != 0 && symtab != NULL)
            printf_unfiltered (_("[%d] %s at %s:%d\n"),
                               i + first_choice,
                               SYMBOL_PRINT_NAME (syms[i].sym),
			       symtab_to_filename_for_display (symtab),
			       SYMBOL_LINE (syms[i].sym));
          else if (is_enumeral
                   && TYPE_NAME (SYMBOL_TYPE (syms[i].sym)) != NULL)
            {
              printf_unfiltered (("[%d] "), i + first_choice);
              ada_print_type (SYMBOL_TYPE (syms[i].sym), NULL,
                              gdb_stdout, -1, 0, &type_print_raw_options);
              printf_unfiltered (_("'(%s) (enumeral)\n"),
                                 SYMBOL_PRINT_NAME (syms[i].sym));
            }
          else if (symtab != NULL)
            printf_unfiltered (is_enumeral
                               ? _("[%d] %s in %s (enumeral)\n")
                               : _("[%d] %s at %s:?\n"),
                               i + first_choice,
                               SYMBOL_PRINT_NAME (syms[i].sym),
                               symtab_to_filename_for_display (symtab));
          else
            printf_unfiltered (is_enumeral
                               ? _("[%d] %s (enumeral)\n")
                               : _("[%d] %s at ?\n"),
                               i + first_choice,
                               SYMBOL_PRINT_NAME (syms[i].sym));
        }
    }

  n_chosen = get_selections (chosen, nsyms, max_results, max_results > 1,
                             "overload-choice");

  for (i = 0; i < n_chosen; i += 1)
    syms[i] = syms[chosen[i]];

  return n_chosen;
}

/* Read and validate a set of numeric choices from the user in the
   range 0 .. N_CHOICES-1.  Place the results in increasing
   order in CHOICES[0 .. N-1], and return N.

   The user types choices as a sequence of numbers on one line
   separated by blanks, encoding them as follows:

     + A choice of 0 means to cancel the selection, throwing an error.
     + If IS_ALL_CHOICE, a choice of 1 selects the entire set 0 .. N_CHOICES-1.
     + The user chooses k by typing k+IS_ALL_CHOICE+1.

   The user is not allowed to choose more than MAX_RESULTS values.

   ANNOTATION_SUFFIX, if present, is used to annotate the input
   prompts (for use with the -f switch).  */

int
get_selections (int *choices, int n_choices, int max_results,
                int is_all_choice, char *annotation_suffix)
{
  char *args;
  char *prompt;
  int n_chosen;
  int first_choice = is_all_choice ? 2 : 1;

  prompt = getenv ("PS2");
  if (prompt == NULL)
    prompt = "> ";

  args = command_line_input (prompt, 0, annotation_suffix);

  if (args == NULL)
    error_no_arg (_("one or more choice numbers"));

  n_chosen = 0;

  /* Set choices[0 .. n_chosen-1] to the users' choices in ascending
     order, as given in args.  Choices are validated.  */
  while (1)
    {
      char *args2;
      int choice, j;

      args = skip_spaces (args);
      if (*args == '\0' && n_chosen == 0)
        error_no_arg (_("one or more choice numbers"));
      else if (*args == '\0')
        break;

      choice = strtol (args, &args2, 10);
      if (args == args2 || choice < 0
          || choice > n_choices + first_choice - 1)
        error (_("Argument must be choice number"));
      args = args2;

      if (choice == 0)
        error (_("cancelled"));

      if (choice < first_choice)
        {
          n_chosen = n_choices;
          for (j = 0; j < n_choices; j += 1)
            choices[j] = j;
          break;
        }
      choice -= first_choice;

      for (j = n_chosen - 1; j >= 0 && choice < choices[j]; j -= 1)
        {
        }

      if (j < 0 || choice != choices[j])
        {
          int k;

          for (k = n_chosen - 1; k > j; k -= 1)
            choices[k + 1] = choices[k];
          choices[j + 1] = choice;
          n_chosen += 1;
        }
    }

  if (n_chosen > max_results)
    error (_("Select no more than %d of the above"), max_results);

  return n_chosen;
}

/* Replace the operator of length OPLEN at position PC in *EXPP with a call
   on the function identified by SYM and BLOCK, and taking NARGS
   arguments.  Update *EXPP as needed to hold more space.  */

static void
replace_operator_with_call (struct expression **expp, int pc, int nargs,
                            int oplen, struct symbol *sym,
                            const struct block *block)
{
  /* A new expression, with 6 more elements (3 for funcall, 4 for function
     symbol, -oplen for operator being replaced).  */
  struct expression *newexp = (struct expression *)
    xzalloc (sizeof (struct expression)
             + EXP_ELEM_TO_BYTES ((*expp)->nelts + 7 - oplen));
  struct expression *exp = *expp;

  newexp->nelts = exp->nelts + 7 - oplen;
  newexp->language_defn = exp->language_defn;
  newexp->gdbarch = exp->gdbarch;
  memcpy (newexp->elts, exp->elts, EXP_ELEM_TO_BYTES (pc));
  memcpy (newexp->elts + pc + 7, exp->elts + pc + oplen,
          EXP_ELEM_TO_BYTES (exp->nelts - pc - oplen));

  newexp->elts[pc].opcode = newexp->elts[pc + 2].opcode = OP_FUNCALL;
  newexp->elts[pc + 1].longconst = (LONGEST) nargs;

  newexp->elts[pc + 3].opcode = newexp->elts[pc + 6].opcode = OP_VAR_VALUE;
  newexp->elts[pc + 4].block = block;
  newexp->elts[pc + 5].symbol = sym;

  *expp = newexp;
  xfree (exp);
}

/* Type-class predicates */

/* True iff TYPE is numeric (i.e., an INT, RANGE (of numeric type),
   or FLOAT).  */

static int
numeric_type_p (struct type *type)
{
  if (type == NULL)
    return 0;
  else
    {
      switch (TYPE_CODE (type))
        {
        case TYPE_CODE_INT:
        case TYPE_CODE_FLT:
          return 1;
        case TYPE_CODE_RANGE:
          return (type == TYPE_TARGET_TYPE (type)
                  || numeric_type_p (TYPE_TARGET_TYPE (type)));
        default:
          return 0;
        }
    }
}

/* True iff TYPE is integral (an INT or RANGE of INTs).  */

static int
integer_type_p (struct type *type)
{
  if (type == NULL)
    return 0;
  else
    {
      switch (TYPE_CODE (type))
        {
        case TYPE_CODE_INT:
          return 1;
        case TYPE_CODE_RANGE:
          return (type == TYPE_TARGET_TYPE (type)
                  || integer_type_p (TYPE_TARGET_TYPE (type)));
        default:
          return 0;
        }
    }
}

/* True iff TYPE is scalar (INT, RANGE, FLOAT, ENUM).  */

static int
scalar_type_p (struct type *type)
{
  if (type == NULL)
    return 0;
  else
    {
      switch (TYPE_CODE (type))
        {
        case TYPE_CODE_INT:
        case TYPE_CODE_RANGE:
        case TYPE_CODE_ENUM:
        case TYPE_CODE_FLT:
          return 1;
        default:
          return 0;
        }
    }
}

/* True iff TYPE is discrete (INT, RANGE, ENUM).  */

static int
discrete_type_p (struct type *type)
{
  if (type == NULL)
    return 0;
  else
    {
      switch (TYPE_CODE (type))
        {
        case TYPE_CODE_INT:
        case TYPE_CODE_RANGE:
        case TYPE_CODE_ENUM:
        case TYPE_CODE_BOOL:
          return 1;
        default:
          return 0;
        }
    }
}

/* Returns non-zero if OP with operands in the vector ARGS could be
   a user-defined function.  Errs on the side of pre-defined operators
   (i.e., result 0).  */

static int
possible_user_operator_p (enum exp_opcode op, struct value *args[])
{
  struct type *type0 =
    (args[0] == NULL) ? NULL : ada_check_typedef (value_type (args[0]));
  struct type *type1 =
    (args[1] == NULL) ? NULL : ada_check_typedef (value_type (args[1]));

  if (type0 == NULL)
    return 0;

  switch (op)
    {
    default:
      return 0;

    case BINOP_ADD:
    case BINOP_SUB:
    case BINOP_MUL:
    case BINOP_DIV:
      return (!(numeric_type_p (type0) && numeric_type_p (type1)));

    case BINOP_REM:
    case BINOP_MOD:
    case BINOP_BITWISE_AND:
    case BINOP_BITWISE_IOR:
    case BINOP_BITWISE_XOR:
      return (!(integer_type_p (type0) && integer_type_p (type1)));

    case BINOP_EQUAL:
    case BINOP_NOTEQUAL:
    case BINOP_LESS:
    case BINOP_GTR:
    case BINOP_LEQ:
    case BINOP_GEQ:
      return (!(scalar_type_p (type0) && scalar_type_p (type1)));

    case BINOP_CONCAT:
      return !ada_is_array_type (type0) || !ada_is_array_type (type1);

    case BINOP_EXP:
      return (!(numeric_type_p (type0) && integer_type_p (type1)));

    case UNOP_NEG:
    case UNOP_PLUS:
    case UNOP_LOGICAL_NOT:
    case UNOP_ABS:
      return (!numeric_type_p (type0));

    }
}

                                /* Renaming */

/* NOTES: 

   1. In the following, we assume that a renaming type's name may
      have an ___XD suffix.  It would be nice if this went away at some
      point.
   2. We handle both the (old) purely type-based representation of 
      renamings and the (new) variable-based encoding.  At some point,
      it is devoutly to be hoped that the former goes away 
      (FIXME: hilfinger-2007-07-09).
   3. Subprogram renamings are not implemented, although the XRS
      suffix is recognized (FIXME: hilfinger-2007-07-09).  */

/* If SYM encodes a renaming, 

       <renaming> renames <renamed entity>,

   sets *LEN to the length of the renamed entity's name,
   *RENAMED_ENTITY to that name (not null-terminated), and *RENAMING_EXPR to
   the string describing the subcomponent selected from the renamed
   entity.  Returns ADA_NOT_RENAMING if SYM does not encode a renaming
   (in which case, the values of *RENAMED_ENTITY, *LEN, and *RENAMING_EXPR
   are undefined).  Otherwise, returns a value indicating the category
   of entity renamed: an object (ADA_OBJECT_RENAMING), exception
   (ADA_EXCEPTION_RENAMING), package (ADA_PACKAGE_RENAMING), or
   subprogram (ADA_SUBPROGRAM_RENAMING).  Does no allocation; the
   strings returned in *RENAMED_ENTITY and *RENAMING_EXPR should not be
   deallocated.  The values of RENAMED_ENTITY, LEN, or RENAMING_EXPR
   may be NULL, in which case they are not assigned.

   [Currently, however, GCC does not generate subprogram renamings.]  */

enum ada_renaming_category
ada_parse_renaming (struct symbol *sym,
		    const char **renamed_entity, int *len, 
		    const char **renaming_expr)
{
  enum ada_renaming_category kind;
  const char *info;
  const char *suffix;

  if (sym == NULL)
    return ADA_NOT_RENAMING;
  switch (SYMBOL_CLASS (sym)) 
    {
    default:
      return ADA_NOT_RENAMING;
    case LOC_TYPEDEF:
      return parse_old_style_renaming (SYMBOL_TYPE (sym), 
				       renamed_entity, len, renaming_expr);
    case LOC_LOCAL:
    case LOC_STATIC:
    case LOC_COMPUTED:
    case LOC_OPTIMIZED_OUT:
      info = strstr (SYMBOL_LINKAGE_NAME (sym), "___XR");
      if (info == NULL)
	return ADA_NOT_RENAMING;
      switch (info[5])
	{
	case '_':
	  kind = ADA_OBJECT_RENAMING;
	  info += 6;
	  break;
	case 'E':
	  kind = ADA_EXCEPTION_RENAMING;
	  info += 7;
	  break;
	case 'P':
	  kind = ADA_PACKAGE_RENAMING;
	  info += 7;
	  break;
	case 'S':
	  kind = ADA_SUBPROGRAM_RENAMING;
	  info += 7;
	  break;
	default:
	  return ADA_NOT_RENAMING;
	}
    }

  if (renamed_entity != NULL)
    *renamed_entity = info;
  suffix = strstr (info, "___XE");
  if (suffix == NULL || suffix == info)
    return ADA_NOT_RENAMING;
  if (len != NULL)
    *len = strlen (info) - strlen (suffix);
  suffix += 5;
  if (renaming_expr != NULL)
    *renaming_expr = suffix;
  return kind;
}

/* Assuming TYPE encodes a renaming according to the old encoding in
   exp_dbug.ads, returns details of that renaming in *RENAMED_ENTITY,
   *LEN, and *RENAMING_EXPR, as for ada_parse_renaming, above.  Returns
   ADA_NOT_RENAMING otherwise.  */
static enum ada_renaming_category
parse_old_style_renaming (struct type *type,
			  const char **renamed_entity, int *len, 
			  const char **renaming_expr)
{
  enum ada_renaming_category kind;
  const char *name;
  const char *info;
  const char *suffix;

  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_ENUM 
      || TYPE_NFIELDS (type) != 1)
    return ADA_NOT_RENAMING;

  name = type_name_no_tag (type);
  if (name == NULL)
    return ADA_NOT_RENAMING;
  
  name = strstr (name, "___XR");
  if (name == NULL)
    return ADA_NOT_RENAMING;
  switch (name[5])
    {
    case '\0':
    case '_':
      kind = ADA_OBJECT_RENAMING;
      break;
    case 'E':
      kind = ADA_EXCEPTION_RENAMING;
      break;
    case 'P':
      kind = ADA_PACKAGE_RENAMING;
      break;
    case 'S':
      kind = ADA_SUBPROGRAM_RENAMING;
      break;
    default:
      return ADA_NOT_RENAMING;
    }

  info = TYPE_FIELD_NAME (type, 0);
  if (info == NULL)
    return ADA_NOT_RENAMING;
  if (renamed_entity != NULL)
    *renamed_entity = info;
  suffix = strstr (info, "___XE");
  if (renaming_expr != NULL)
    *renaming_expr = suffix + 5;
  if (suffix == NULL || suffix == info)
    return ADA_NOT_RENAMING;
  if (len != NULL)
    *len = suffix - info;
  return kind;
}

/* Compute the value of the given RENAMING_SYM, which is expected to
   be a symbol encoding a renaming expression.  BLOCK is the block
   used to evaluate the renaming.  */

static struct value *
ada_read_renaming_var_value (struct symbol *renaming_sym,
			     struct block *block)
{
  const char *sym_name;
  struct expression *expr;
  struct value *value;
  struct cleanup *old_chain = NULL;

  sym_name = SYMBOL_LINKAGE_NAME (renaming_sym);
  expr = parse_exp_1 (&sym_name, 0, block, 0);
  old_chain = make_cleanup (free_current_contents, &expr);
  value = evaluate_expression (expr);

  do_cleanups (old_chain);
  return value;
}


                                /* Evaluation: Function Calls */

/* Return an lvalue containing the value VAL.  This is the identity on
   lvalues, and otherwise has the side-effect of allocating memory
   in the inferior where a copy of the value contents is copied.  */

static struct value *
ensure_lval (struct value *val)
{
  if (VALUE_LVAL (val) == not_lval
      || VALUE_LVAL (val) == lval_internalvar)
    {
      int len = TYPE_LENGTH (ada_check_typedef (value_type (val)));
      const CORE_ADDR addr =
        value_as_long (value_allocate_space_in_inferior (len));

      set_value_address (val, addr);
      VALUE_LVAL (val) = lval_memory;
      write_memory (addr, value_contents (val), len);
    }

  return val;
}

/* Return the value ACTUAL, converted to be an appropriate value for a
   formal of type FORMAL_TYPE.  Use *SP as a stack pointer for
   allocating any necessary descriptors (fat pointers), or copies of
   values not residing in memory, updating it as needed.  */

struct value *
ada_convert_actual (struct value *actual, struct type *formal_type0)
{
  struct type *actual_type = ada_check_typedef (value_type (actual));
  struct type *formal_type = ada_check_typedef (formal_type0);
  struct type *formal_target =
    TYPE_CODE (formal_type) == TYPE_CODE_PTR
    ? ada_check_typedef (TYPE_TARGET_TYPE (formal_type)) : formal_type;
  struct type *actual_target =
    TYPE_CODE (actual_type) == TYPE_CODE_PTR
    ? ada_check_typedef (TYPE_TARGET_TYPE (actual_type)) : actual_type;

  if (ada_is_array_descriptor_type (formal_target)
      && TYPE_CODE (actual_target) == TYPE_CODE_ARRAY)
    return make_array_descriptor (formal_type, actual);
  else if (TYPE_CODE (formal_type) == TYPE_CODE_PTR
	   || TYPE_CODE (formal_type) == TYPE_CODE_REF)
    {
      struct value *result;

      if (TYPE_CODE (formal_target) == TYPE_CODE_ARRAY
          && ada_is_array_descriptor_type (actual_target))
	result = desc_data (actual);
      else if (TYPE_CODE (actual_type) != TYPE_CODE_PTR)
        {
          if (VALUE_LVAL (actual) != lval_memory)
            {
              struct value *val;

              actual_type = ada_check_typedef (value_type (actual));
              val = allocate_value (actual_type);
              memcpy ((char *) value_contents_raw (val),
                      (char *) value_contents (actual),
                      TYPE_LENGTH (actual_type));
              actual = ensure_lval (val);
            }
          result = value_addr (actual);
        }
      else
	return actual;
      return value_cast_pointers (formal_type, result, 0);
    }
  else if (TYPE_CODE (actual_type) == TYPE_CODE_PTR)
    return ada_value_ind (actual);

  return actual;
}

/* Convert VALUE (which must be an address) to a CORE_ADDR that is a pointer of
   type TYPE.  This is usually an inefficient no-op except on some targets
   (such as AVR) where the representation of a pointer and an address
   differs.  */

static CORE_ADDR
value_pointer (struct value *value, struct type *type)
{
  struct gdbarch *gdbarch = get_type_arch (type);
  unsigned len = TYPE_LENGTH (type);
  gdb_byte *buf = alloca (len);
  CORE_ADDR addr;

  addr = value_address (value);
  gdbarch_address_to_pointer (gdbarch, type, buf, addr);
  addr = extract_unsigned_integer (buf, len, gdbarch_byte_order (gdbarch));
  return addr;
}


/* Push a descriptor of type TYPE for array value ARR on the stack at
   *SP, updating *SP to reflect the new descriptor.  Return either
   an lvalue representing the new descriptor, or (if TYPE is a pointer-
   to-descriptor type rather than a descriptor type), a struct value *
   representing a pointer to this descriptor.  */

static struct value *
make_array_descriptor (struct type *type, struct value *arr)
{
  struct type *bounds_type = desc_bounds_type (type);
  struct type *desc_type = desc_base_type (type);
  struct value *descriptor = allocate_value (desc_type);
  struct value *bounds = allocate_value (bounds_type);
  int i;

  for (i = ada_array_arity (ada_check_typedef (value_type (arr)));
       i > 0; i -= 1)
    {
      modify_field (value_type (bounds), value_contents_writeable (bounds),
		    ada_array_bound (arr, i, 0),
		    desc_bound_bitpos (bounds_type, i, 0),
		    desc_bound_bitsize (bounds_type, i, 0));
      modify_field (value_type (bounds), value_contents_writeable (bounds),
		    ada_array_bound (arr, i, 1),
		    desc_bound_bitpos (bounds_type, i, 1),
		    desc_bound_bitsize (bounds_type, i, 1));
    }

  bounds = ensure_lval (bounds);

  modify_field (value_type (descriptor),
		value_contents_writeable (descriptor),
		value_pointer (ensure_lval (arr),
			       TYPE_FIELD_TYPE (desc_type, 0)),
		fat_pntr_data_bitpos (desc_type),
		fat_pntr_data_bitsize (desc_type));

  modify_field (value_type (descriptor),
		value_contents_writeable (descriptor),
		value_pointer (bounds,
			       TYPE_FIELD_TYPE (desc_type, 1)),
		fat_pntr_bounds_bitpos (desc_type),
		fat_pntr_bounds_bitsize (desc_type));

  descriptor = ensure_lval (descriptor);

  if (TYPE_CODE (type) == TYPE_CODE_PTR)
    return value_addr (descriptor);
  else
    return descriptor;
}

/* Dummy definitions for an experimental caching module that is not
 * used in the public sources.  */

static int
lookup_cached_symbol (const char *name, domain_enum namespace,
                      struct symbol **sym, struct block **block)
{
  return 0;
}

static void
cache_symbol (const char *name, domain_enum namespace, struct symbol *sym,
              const struct block *block)
{
}

                                /* Symbol Lookup */

/* Return nonzero if wild matching should be used when searching for
   all symbols matching LOOKUP_NAME.

   LOOKUP_NAME is expected to be a symbol name after transformation
   for Ada lookups (see ada_name_for_lookup).  */

static int
should_use_wild_match (const char *lookup_name)
{
  return (strstr (lookup_name, "__") == NULL);
}

/* Return the result of a standard (literal, C-like) lookup of NAME in
   given DOMAIN, visible from lexical block BLOCK.  */

static struct symbol *
standard_lookup (const char *name, const struct block *block,
                 domain_enum domain)
{
  /* Initialize it just to avoid a GCC false warning.  */
  struct symbol *sym = NULL;

  if (lookup_cached_symbol (name, domain, &sym, NULL))
    return sym;
  sym = lookup_symbol_in_language (name, block, domain, language_c, 0);
  cache_symbol (name, domain, sym, block_found);
  return sym;
}


/* Non-zero iff there is at least one non-function/non-enumeral symbol
   in the symbol fields of SYMS[0..N-1].  We treat enumerals as functions, 
   since they contend in overloading in the same way.  */
static int
is_nonfunction (struct ada_symbol_info syms[], int n)
{
  int i;

  for (i = 0; i < n; i += 1)
    if (TYPE_CODE (SYMBOL_TYPE (syms[i].sym)) != TYPE_CODE_FUNC
        && (TYPE_CODE (SYMBOL_TYPE (syms[i].sym)) != TYPE_CODE_ENUM
            || SYMBOL_CLASS (syms[i].sym) != LOC_CONST))
      return 1;

  return 0;
}

/* If true (non-zero), then TYPE0 and TYPE1 represent equivalent
   struct types.  Otherwise, they may not.  */

static int
equiv_types (struct type *type0, struct type *type1)
{
  if (type0 == type1)
    return 1;
  if (type0 == NULL || type1 == NULL
      || TYPE_CODE (type0) != TYPE_CODE (type1))
    return 0;
  if ((TYPE_CODE (type0) == TYPE_CODE_STRUCT
       || TYPE_CODE (type0) == TYPE_CODE_ENUM)
      && ada_type_name (type0) != NULL && ada_type_name (type1) != NULL
      && strcmp (ada_type_name (type0), ada_type_name (type1)) == 0)
    return 1;

  return 0;
}

/* True iff SYM0 represents the same entity as SYM1, or one that is
   no more defined than that of SYM1.  */

static int
lesseq_defined_than (struct symbol *sym0, struct symbol *sym1)
{
  if (sym0 == sym1)
    return 1;
  if (SYMBOL_DOMAIN (sym0) != SYMBOL_DOMAIN (sym1)
      || SYMBOL_CLASS (sym0) != SYMBOL_CLASS (sym1))
    return 0;

  switch (SYMBOL_CLASS (sym0))
    {
    case LOC_UNDEF:
      return 1;
    case LOC_TYPEDEF:
      {
        struct type *type0 = SYMBOL_TYPE (sym0);
        struct type *type1 = SYMBOL_TYPE (sym1);
        const char *name0 = SYMBOL_LINKAGE_NAME (sym0);
        const char *name1 = SYMBOL_LINKAGE_NAME (sym1);
        int len0 = strlen (name0);

        return
          TYPE_CODE (type0) == TYPE_CODE (type1)
          && (equiv_types (type0, type1)
              || (len0 < strlen (name1) && strncmp (name0, name1, len0) == 0
                  && strncmp (name1 + len0, "___XV", 5) == 0));
      }
    case LOC_CONST:
      return SYMBOL_VALUE (sym0) == SYMBOL_VALUE (sym1)
        && equiv_types (SYMBOL_TYPE (sym0), SYMBOL_TYPE (sym1));
    default:
      return 0;
    }
}

/* Append (SYM,BLOCK,SYMTAB) to the end of the array of struct ada_symbol_info
   records in OBSTACKP.  Do nothing if SYM is a duplicate.  */

static void
add_defn_to_vec (struct obstack *obstackp,
                 struct symbol *sym,
                 struct block *block)
{
  int i;
  struct ada_symbol_info *prevDefns = defns_collected (obstackp, 0);

  /* Do not try to complete stub types, as the debugger is probably
     already scanning all symbols matching a certain name at the
     time when this function is called.  Trying to replace the stub
     type by its associated full type will cause us to restart a scan
     which may lead to an infinite recursion.  Instead, the client
     collecting the matching symbols will end up collecting several
     matches, with at least one of them complete.  It can then filter
     out the stub ones if needed.  */

  for (i = num_defns_collected (obstackp) - 1; i >= 0; i -= 1)
    {
      if (lesseq_defined_than (sym, prevDefns[i].sym))
        return;
      else if (lesseq_defined_than (prevDefns[i].sym, sym))
        {
          prevDefns[i].sym = sym;
          prevDefns[i].block = block;
          return;
        }
    }

  {
    struct ada_symbol_info info;

    info.sym = sym;
    info.block = block;
    obstack_grow (obstackp, &info, sizeof (struct ada_symbol_info));
  }
}

/* Number of ada_symbol_info structures currently collected in 
   current vector in *OBSTACKP.  */

static int
num_defns_collected (struct obstack *obstackp)
{
  return obstack_object_size (obstackp) / sizeof (struct ada_symbol_info);
}

/* Vector of ada_symbol_info structures currently collected in current 
   vector in *OBSTACKP.  If FINISH, close off the vector and return
   its final address.  */

static struct ada_symbol_info *
defns_collected (struct obstack *obstackp, int finish)
{
  if (finish)
    return obstack_finish (obstackp);
  else
    return (struct ada_symbol_info *) obstack_base (obstackp);
}

/* Return a bound minimal symbol matching NAME according to Ada
   decoding rules.  Returns an invalid symbol if there is no such
   minimal symbol.  Names prefixed with "standard__" are handled
   specially: "standard__" is first stripped off, and only static and
   global symbols are searched.  */

struct bound_minimal_symbol
ada_lookup_simple_minsym (const char *name)
{
  struct bound_minimal_symbol result;
  struct objfile *objfile;
  struct minimal_symbol *msymbol;
  const int wild_match_p = should_use_wild_match (name);

  memset (&result, 0, sizeof (result));

  /* Special case: If the user specifies a symbol name inside package
     Standard, do a non-wild matching of the symbol name without
     the "standard__" prefix.  This was primarily introduced in order
     to allow the user to specifically access the standard exceptions
     using, for instance, Standard.Constraint_Error when Constraint_Error
     is ambiguous (due to the user defining its own Constraint_Error
     entity inside its program).  */
  if (strncmp (name, "standard__", sizeof ("standard__") - 1) == 0)
    name += sizeof ("standard__") - 1;

  ALL_MSYMBOLS (objfile, msymbol)
  {
    if (match_name (SYMBOL_LINKAGE_NAME (msymbol), name, wild_match_p)
        && MSYMBOL_TYPE (msymbol) != mst_solib_trampoline)
      {
	result.minsym = msymbol;
	result.objfile = objfile;
	break;
      }
  }

  return result;
}

/* For all subprograms that statically enclose the subprogram of the
   selected frame, add symbols matching identifier NAME in DOMAIN
   and their blocks to the list of data in OBSTACKP, as for
   ada_add_block_symbols (q.v.).   If WILD_MATCH_P, treat as NAME
   with a wildcard prefix.  */

static void
add_symbols_from_enclosing_procs (struct obstack *obstackp,
                                  const char *name, domain_enum namespace,
                                  int wild_match_p)
{
}

/* True if TYPE is definitely an artificial type supplied to a symbol
   for which no debugging information was given in the symbol file.  */

static int
is_nondebugging_type (struct type *type)
{
  const char *name = ada_type_name (type);

  return (name != NULL && strcmp (name, "<variable, no debug info>") == 0);
}

/* Return nonzero if TYPE1 and TYPE2 are two enumeration types
   that are deemed "identical" for practical purposes.

   This function assumes that TYPE1 and TYPE2 are both TYPE_CODE_ENUM
   types and that their number of enumerals is identical (in other
   words, TYPE_NFIELDS (type1) == TYPE_NFIELDS (type2)).  */

static int
ada_identical_enum_types_p (struct type *type1, struct type *type2)
{
  int i;

  /* The heuristic we use here is fairly conservative.  We consider
     that 2 enumerate types are identical if they have the same
     number of enumerals and that all enumerals have the same
     underlying value and name.  */

  /* All enums in the type should have an identical underlying value.  */
  for (i = 0; i < TYPE_NFIELDS (type1); i++)
    if (TYPE_FIELD_ENUMVAL (type1, i) != TYPE_FIELD_ENUMVAL (type2, i))
      return 0;

  /* All enumerals should also have the same name (modulo any numerical
     suffix).  */
  for (i = 0; i < TYPE_NFIELDS (type1); i++)
    {
      const char *name_1 = TYPE_FIELD_NAME (type1, i);
      const char *name_2 = TYPE_FIELD_NAME (type2, i);
      int len_1 = strlen (name_1);
      int len_2 = strlen (name_2);

      ada_remove_trailing_digits (TYPE_FIELD_NAME (type1, i), &len_1);
      ada_remove_trailing_digits (TYPE_FIELD_NAME (type2, i), &len_2);
      if (len_1 != len_2
          || strncmp (TYPE_FIELD_NAME (type1, i),
		      TYPE_FIELD_NAME (type2, i),
		      len_1) != 0)
	return 0;
    }

  return 1;
}

/* Return nonzero if all the symbols in SYMS are all enumeral symbols
   that are deemed "identical" for practical purposes.  Sometimes,
   enumerals are not strictly identical, but their types are so similar
   that they can be considered identical.

   For instance, consider the following code:

      type Color is (Black, Red, Green, Blue, White);
      type RGB_Color is new Color range Red .. Blue;

   Type RGB_Color is a subrange of an implicit type which is a copy
   of type Color. If we call that implicit type RGB_ColorB ("B" is
   for "Base Type"), then type RGB_ColorB is a copy of type Color.
   As a result, when an expression references any of the enumeral
   by name (Eg. "print green"), the expression is technically
   ambiguous and the user should be asked to disambiguate. But
   doing so would only hinder the user, since it wouldn't matter
   what choice he makes, the outcome would always be the same.
   So, for practical purposes, we consider them as the same.  */

static int
symbols_are_identical_enums (struct ada_symbol_info *syms, int nsyms)
{
  int i;

  /* Before performing a thorough comparison check of each type,
     we perform a series of inexpensive checks.  We expect that these
     checks will quickly fail in the vast majority of cases, and thus
     help prevent the unnecessary use of a more expensive comparison.
     Said comparison also expects us to make some of these checks
     (see ada_identical_enum_types_p).  */

  /* Quick check: All symbols should have an enum type.  */
  for (i = 0; i < nsyms; i++)
    if (TYPE_CODE (SYMBOL_TYPE (syms[i].sym)) != TYPE_CODE_ENUM)
      return 0;

  /* Quick check: They should all have the same value.  */
  for (i = 1; i < nsyms; i++)
    if (SYMBOL_VALUE (syms[i].sym) != SYMBOL_VALUE (syms[0].sym))
      return 0;

  /* Quick check: They should all have the same number of enumerals.  */
  for (i = 1; i < nsyms; i++)
    if (TYPE_NFIELDS (SYMBOL_TYPE (syms[i].sym))
        != TYPE_NFIELDS (SYMBOL_TYPE (syms[0].sym)))
      return 0;

  /* All the sanity checks passed, so we might have a set of
     identical enumeration types.  Perform a more complete
     comparison of the type of each symbol.  */
  for (i = 1; i < nsyms; i++)
    if (!ada_identical_enum_types_p (SYMBOL_TYPE (syms[i].sym),
                                     SYMBOL_TYPE (syms[0].sym)))
      return 0;

  return 1;
}

/* Remove any non-debugging symbols in SYMS[0 .. NSYMS-1] that definitely
   duplicate other symbols in the list (The only case I know of where
   this happens is when object files containing stabs-in-ecoff are
   linked with files containing ordinary ecoff debugging symbols (or no
   debugging symbols)).  Modifies SYMS to squeeze out deleted entries.
   Returns the number of items in the modified list.  */

static int
remove_extra_symbols (struct ada_symbol_info *syms, int nsyms)
{
  int i, j;

  /* We should never be called with less than 2 symbols, as there
     cannot be any extra symbol in that case.  But it's easy to
     handle, since we have nothing to do in that case.  */
  if (nsyms < 2)
    return nsyms;

  i = 0;
  while (i < nsyms)
    {
      int remove_p = 0;

      /* If two symbols have the same name and one of them is a stub type,
         the get rid of the stub.  */

      if (TYPE_STUB (SYMBOL_TYPE (syms[i].sym))
          && SYMBOL_LINKAGE_NAME (syms[i].sym) != NULL)
        {
          for (j = 0; j < nsyms; j++)
            {
              if (j != i
                  && !TYPE_STUB (SYMBOL_TYPE (syms[j].sym))
                  && SYMBOL_LINKAGE_NAME (syms[j].sym) != NULL
                  && strcmp (SYMBOL_LINKAGE_NAME (syms[i].sym),
                             SYMBOL_LINKAGE_NAME (syms[j].sym)) == 0)
                remove_p = 1;
            }
        }

      /* Two symbols with the same name, same class and same address
         should be identical.  */

      else if (SYMBOL_LINKAGE_NAME (syms[i].sym) != NULL
          && SYMBOL_CLASS (syms[i].sym) == LOC_STATIC
          && is_nondebugging_type (SYMBOL_TYPE (syms[i].sym)))
        {
          for (j = 0; j < nsyms; j += 1)
            {
              if (i != j
                  && SYMBOL_LINKAGE_NAME (syms[j].sym) != NULL
                  && strcmp (SYMBOL_LINKAGE_NAME (syms[i].sym),
                             SYMBOL_LINKAGE_NAME (syms[j].sym)) == 0
                  && SYMBOL_CLASS (syms[i].sym) == SYMBOL_CLASS (syms[j].sym)
                  && SYMBOL_VALUE_ADDRESS (syms[i].sym)
                  == SYMBOL_VALUE_ADDRESS (syms[j].sym))
                remove_p = 1;
            }
        }
      
      if (remove_p)
        {
          for (j = i + 1; j < nsyms; j += 1)
            syms[j - 1] = syms[j];
          nsyms -= 1;
        }

      i += 1;
    }

  /* If all the remaining symbols are identical enumerals, then
     just keep the first one and discard the rest.

     Unlike what we did previously, we do not discard any entry
     unless they are ALL identical.  This is because the symbol
     comparison is not a strict comparison, but rather a practical
     comparison.  If all symbols are considered identical, then
     we can just go ahead and use the first one and discard the rest.
     But if we cannot reduce the list to a single element, we have
     to ask the user to disambiguate anyways.  And if we have to
     present a multiple-choice menu, it's less confusing if the list
     isn't missing some choices that were identical and yet distinct.  */
  if (symbols_are_identical_enums (syms, nsyms))
    nsyms = 1;

  return nsyms;
}

/* Given a type that corresponds to a renaming entity, use the type name
   to extract the scope (package name or function name, fully qualified,
   and following the GNAT encoding convention) where this renaming has been
   defined.  The string returned needs to be deallocated after use.  */

static char *
xget_renaming_scope (struct type *renaming_type)
{
  /* The renaming types adhere to the following convention:
     <scope>__<rename>___<XR extension>.
     So, to extract the scope, we search for the "___XR" extension,
     and then backtrack until we find the first "__".  */

  const char *name = type_name_no_tag (renaming_type);
  char *suffix = strstr (name, "___XR");
  char *last;
  int scope_len;
  char *scope;

  /* Now, backtrack a bit until we find the first "__".  Start looking
     at suffix - 3, as the <rename> part is at least one character long.  */

  for (last = suffix - 3; last > name; last--)
    if (last[0] == '_' && last[1] == '_')
      break;

  /* Make a copy of scope and return it.  */

  scope_len = last - name;
  scope = (char *) xmalloc ((scope_len + 1) * sizeof (char));

  strncpy (scope, name, scope_len);
  scope[scope_len] = '\0';

  return scope;
}

/* Return nonzero if NAME corresponds to a package name.  */

static int
is_package_name (const char *name)
{
  /* Here, We take advantage of the fact that no symbols are generated
     for packages, while symbols are generated for each function.
     So the condition for NAME represent a package becomes equivalent
     to NAME not existing in our list of symbols.  There is only one
     small complication with library-level functions (see below).  */

  char *fun_name;

  /* If it is a function that has not been defined at library level,
     then we should be able to look it up in the symbols.  */
  if (standard_lookup (name, NULL, VAR_DOMAIN) != NULL)
    return 0;

  /* Library-level function names start with "_ada_".  See if function
     "_ada_" followed by NAME can be found.  */

  /* Do a quick check that NAME does not contain "__", since library-level
     functions names cannot contain "__" in them.  */
  if (strstr (name, "__") != NULL)
    return 0;

  fun_name = xstrprintf ("_ada_%s", name);

  return (standard_lookup (fun_name, NULL, VAR_DOMAIN) == NULL);
}

/* Return nonzero if SYM corresponds to a renaming entity that is
   not visible from FUNCTION_NAME.  */

static int
old_renaming_is_invisible (const struct symbol *sym, const char *function_name)
{
  char *scope;
  struct cleanup *old_chain;

  if (SYMBOL_CLASS (sym) != LOC_TYPEDEF)
    return 0;

  scope = xget_renaming_scope (SYMBOL_TYPE (sym));
  old_chain = make_cleanup (xfree, scope);

  /* If the rename has been defined in a package, then it is visible.  */
  if (is_package_name (scope))
    {
      do_cleanups (old_chain);
      return 0;
    }

  /* Check that the rename is in the current function scope by checking
     that its name starts with SCOPE.  */

  /* If the function name starts with "_ada_", it means that it is
     a library-level function.  Strip this prefix before doing the
     comparison, as the encoding for the renaming does not contain
     this prefix.  */
  if (strncmp (function_name, "_ada_", 5) == 0)
    function_name += 5;

  {
    int is_invisible = strncmp (function_name, scope, strlen (scope)) != 0;

    do_cleanups (old_chain);
    return is_invisible;
  }
}

/* Remove entries from SYMS that corresponds to a renaming entity that
   is not visible from the function associated with CURRENT_BLOCK or
   that is superfluous due to the presence of more specific renaming
   information.  Places surviving symbols in the initial entries of
   SYMS and returns the number of surviving symbols.
   
   Rationale:
   First, in cases where an object renaming is implemented as a
   reference variable, GNAT may produce both the actual reference
   variable and the renaming encoding.  In this case, we discard the
   latter.

   Second, GNAT emits a type following a specified encoding for each renaming
   entity.  Unfortunately, STABS currently does not support the definition
   of types that are local to a given lexical block, so all renamings types
   are emitted at library level.  As a consequence, if an application
   contains two renaming entities using the same name, and a user tries to
   print the value of one of these entities, the result of the ada symbol
   lookup will also contain the wrong renaming type.

   This function partially covers for this limitation by attempting to
   remove from the SYMS list renaming symbols that should be visible
   from CURRENT_BLOCK.  However, there does not seem be a 100% reliable
   method with the current information available.  The implementation
   below has a couple of limitations (FIXME: brobecker-2003-05-12):  
   
      - When the user tries to print a rename in a function while there
        is another rename entity defined in a package:  Normally, the
        rename in the function has precedence over the rename in the
        package, so the latter should be removed from the list.  This is
        currently not the case.
        
      - This function will incorrectly remove valid renames if
        the CURRENT_BLOCK corresponds to a function which symbol name
        has been changed by an "Export" pragma.  As a consequence,
        the user will be unable to print such rename entities.  */

static int
remove_irrelevant_renamings (struct ada_symbol_info *syms,
			     int nsyms, const struct block *current_block)
{
  struct symbol *current_function;
  const char *current_function_name;
  int i;
  int is_new_style_renaming;

  /* If there is both a renaming foo___XR... encoded as a variable and
     a simple variable foo in the same block, discard the latter.
     First, zero out such symbols, then compress.  */
  is_new_style_renaming = 0;
  for (i = 0; i < nsyms; i += 1)
    {
      struct symbol *sym = syms[i].sym;
      const struct block *block = syms[i].block;
      const char *name;
      const char *suffix;

      if (sym == NULL || SYMBOL_CLASS (sym) == LOC_TYPEDEF)
	continue;
      name = SYMBOL_LINKAGE_NAME (sym);
      suffix = strstr (name, "___XR");

      if (suffix != NULL)
	{
	  int name_len = suffix - name;
	  int j;

	  is_new_style_renaming = 1;
	  for (j = 0; j < nsyms; j += 1)
	    if (i != j && syms[j].sym != NULL
		&& strncmp (name, SYMBOL_LINKAGE_NAME (syms[j].sym),
			    name_len) == 0
		&& block == syms[j].block)
	      syms[j].sym = NULL;
	}
    }
  if (is_new_style_renaming)
    {
      int j, k;

      for (j = k = 0; j < nsyms; j += 1)
	if (syms[j].sym != NULL)
	    {
	      syms[k] = syms[j];
	      k += 1;
	    }
      return k;
    }

  /* Extract the function name associated to CURRENT_BLOCK.
     Abort if unable to do so.  */

  if (current_block == NULL)
    return nsyms;

  current_function = block_linkage_function (current_block);
  if (current_function == NULL)
    return nsyms;

  current_function_name = SYMBOL_LINKAGE_NAME (current_function);
  if (current_function_name == NULL)
    return nsyms;

  /* Check each of the symbols, and remove it from the list if it is
     a type corresponding to a renaming that is out of the scope of
     the current block.  */

  i = 0;
  while (i < nsyms)
    {
      if (ada_parse_renaming (syms[i].sym, NULL, NULL, NULL)
          == ADA_OBJECT_RENAMING
          && old_renaming_is_invisible (syms[i].sym, current_function_name))
        {
          int j;

          for (j = i + 1; j < nsyms; j += 1)
            syms[j - 1] = syms[j];
          nsyms -= 1;
        }
      else
        i += 1;
    }

  return nsyms;
}

/* Add to OBSTACKP all symbols from BLOCK (and its super-blocks)
   whose name and domain match NAME and DOMAIN respectively.
   If no match was found, then extend the search to "enclosing"
   routines (in other words, if we're inside a nested function,
   search the symbols defined inside the enclosing functions).
   If WILD_MATCH_P is nonzero, perform the naming matching in
   "wild" mode (see function "wild_match" for more info).

   Note: This function assumes that OBSTACKP has 0 (zero) element in it.  */

static void
ada_add_local_symbols (struct obstack *obstackp, const char *name,
                       struct block *block, domain_enum domain,
                       int wild_match_p)
{
  int block_depth = 0;

  while (block != NULL)
    {
      block_depth += 1;
      ada_add_block_symbols (obstackp, block, name, domain, NULL,
			     wild_match_p);

      /* If we found a non-function match, assume that's the one.  */
      if (is_nonfunction (defns_collected (obstackp, 0),
                          num_defns_collected (obstackp)))
        return;

      block = BLOCK_SUPERBLOCK (block);
    }

  /* If no luck so far, try to find NAME as a local symbol in some lexically
     enclosing subprogram.  */
  if (num_defns_collected (obstackp) == 0 && block_depth > 2)
    add_symbols_from_enclosing_procs (obstackp, name, domain, wild_match_p);
}

/* An object of this type is used as the user_data argument when
   calling the map_matching_symbols method.  */

struct match_data
{
  struct objfile *objfile;
  struct obstack *obstackp;
  struct symbol *arg_sym;
  int found_sym;
};

/* A callback for add_matching_symbols that adds SYM, found in BLOCK,
   to a list of symbols.  DATA0 is a pointer to a struct match_data *
   containing the obstack that collects the symbol list, the file that SYM
   must come from, a flag indicating whether a non-argument symbol has
   been found in the current block, and the last argument symbol
   passed in SYM within the current block (if any).  When SYM is null,
   marking the end of a block, the argument symbol is added if no
   other has been found.  */

static int
aux_add_nonlocal_symbols (struct block *block, struct symbol *sym, void *data0)
{
  struct match_data *data = (struct match_data *) data0;
  
  if (sym == NULL)
    {
      if (!data->found_sym && data->arg_sym != NULL) 
	add_defn_to_vec (data->obstackp,
			 fixup_symbol_section (data->arg_sym, data->objfile),
			 block);
      data->found_sym = 0;
      data->arg_sym = NULL;
    }
  else 
    {
      if (SYMBOL_CLASS (sym) == LOC_UNRESOLVED)
	return 0;
      else if (SYMBOL_IS_ARGUMENT (sym))
	data->arg_sym = sym;
      else
	{
	  data->found_sym = 1;
	  add_defn_to_vec (data->obstackp,
			   fixup_symbol_section (sym, data->objfile),
			   block);
	}
    }
  return 0;
}

/* Implements compare_names, but only applying the comparision using
   the given CASING.  */

static int
compare_names_with_case (const char *string1, const char *string2,
			 enum case_sensitivity casing)
{
  while (*string1 != '\0' && *string2 != '\0')
    {
      char c1, c2;

      if (isspace (*string1) || isspace (*string2))
	return strcmp_iw_ordered (string1, string2);

      if (casing == case_sensitive_off)
	{
	  c1 = tolower (*string1);
	  c2 = tolower (*string2);
	}
      else
	{
	  c1 = *string1;
	  c2 = *string2;
	}
      if (c1 != c2)
	break;

      string1 += 1;
      string2 += 1;
    }

  switch (*string1)
    {
    case '(':
      return strcmp_iw_ordered (string1, string2);
    case '_':
      if (*string2 == '\0')
	{
	  if (is_name_suffix (string1))
	    return 0;
	  else
	    return 1;
	}
      /* FALLTHROUGH */
    default:
      if (*string2 == '(')
	return strcmp_iw_ordered (string1, string2);
      else
	{
	  if (casing == case_sensitive_off)
	    return tolower (*string1) - tolower (*string2);
	  else
	    return *string1 - *string2;
	}
    }
}

/* Compare STRING1 to STRING2, with results as for strcmp.
   Compatible with strcmp_iw_ordered in that...

       strcmp_iw_ordered (STRING1, STRING2) <= 0

   ... implies...

       compare_names (STRING1, STRING2) <= 0

   (they may differ as to what symbols compare equal).  */

static int
compare_names (const char *string1, const char *string2)
{
  int result;

  /* Similar to what strcmp_iw_ordered does, we need to perform
     a case-insensitive comparison first, and only resort to
     a second, case-sensitive, comparison if the first one was
     not sufficient to differentiate the two strings.  */

  result = compare_names_with_case (string1, string2, case_sensitive_off);
  if (result == 0)
    result = compare_names_with_case (string1, string2, case_sensitive_on);

  return result;
}

/* Add to OBSTACKP all non-local symbols whose name and domain match
   NAME and DOMAIN respectively.  The search is performed on GLOBAL_BLOCK
   symbols if GLOBAL is non-zero, or on STATIC_BLOCK symbols otherwise.  */

static void
add_nonlocal_symbols (struct obstack *obstackp, const char *name,
		      domain_enum domain, int global,
		      int is_wild_match)
{
  struct objfile *objfile;
  struct match_data data;

  memset (&data, 0, sizeof data);
  data.obstackp = obstackp;

  ALL_OBJFILES (objfile)
    {
      data.objfile = objfile;

      if (is_wild_match)
	objfile->sf->qf->map_matching_symbols (objfile, name, domain, global,
					       aux_add_nonlocal_symbols, &data,
					       wild_match, NULL);
      else
	objfile->sf->qf->map_matching_symbols (objfile, name, domain, global,
					       aux_add_nonlocal_symbols, &data,
					       full_match, compare_names);
    }

  if (num_defns_collected (obstackp) == 0 && global && !is_wild_match)
    {
      ALL_OBJFILES (objfile)
        {
	  char *name1 = alloca (strlen (name) + sizeof ("_ada_"));
	  strcpy (name1, "_ada_");
	  strcpy (name1 + sizeof ("_ada_") - 1, name);
	  data.objfile = objfile;
	  objfile->sf->qf->map_matching_symbols (objfile, name1, domain,
						 global,
						 aux_add_nonlocal_symbols,
						 &data,
						 full_match, compare_names);
	}
    }      	
}

/* Find symbols in DOMAIN matching NAME0, in BLOCK0 and, if full_search is
   non-zero, enclosing scope and in global scopes, returning the number of
   matches.
   Sets *RESULTS to point to a vector of (SYM,BLOCK) tuples,
   indicating the symbols found and the blocks and symbol tables (if
   any) in which they were found.  This vector is transient---good only to
   the next call of ada_lookup_symbol_list.

   When full_search is non-zero, any non-function/non-enumeral
   symbol match within the nest of blocks whose innermost member is BLOCK0,
   is the one match returned (no other matches in that or
   enclosing blocks is returned).  If there are any matches in or
   surrounding BLOCK0, then these alone are returned.

   Names prefixed with "standard__" are handled specially: "standard__"
   is first stripped off, and only static and global symbols are searched.  */

static int
ada_lookup_symbol_list_worker (const char *name0, const struct block *block0,
			       domain_enum namespace,
			       struct ada_symbol_info **results,
			       int full_search)
{
  struct symbol *sym;
  struct block *block;
  const char *name;
  const int wild_match_p = should_use_wild_match (name0);
  int cacheIfUnique;
  int ndefns;

  obstack_free (&symbol_list_obstack, NULL);
  obstack_init (&symbol_list_obstack);

  cacheIfUnique = 0;

  /* Search specified block and its superiors.  */

  name = name0;
  block = (struct block *) block0;      /* FIXME: No cast ought to be
                                           needed, but adding const will
                                           have a cascade effect.  */

  /* Special case: If the user specifies a symbol name inside package
     Standard, do a non-wild matching of the symbol name without
     the "standard__" prefix.  This was primarily introduced in order
     to allow the user to specifically access the standard exceptions
     using, for instance, Standard.Constraint_Error when Constraint_Error
     is ambiguous (due to the user defining its own Constraint_Error
     entity inside its program).  */
  if (strncmp (name0, "standard__", sizeof ("standard__") - 1) == 0)
    {
      block = NULL;
      name = name0 + sizeof ("standard__") - 1;
    }

  /* Check the non-global symbols.  If we have ANY match, then we're done.  */

  if (block != NULL)
    {
      if (full_search)
	{
	  ada_add_local_symbols (&symbol_list_obstack, name, block,
				 namespace, wild_match_p);
	}
      else
	{
	  /* In the !full_search case we're are being called by
	     ada_iterate_over_symbols, and we don't want to search
	     superblocks.  */
	  ada_add_block_symbols (&symbol_list_obstack, block, name,
				 namespace, NULL, wild_match_p);
	}
      if (num_defns_collected (&symbol_list_obstack) > 0 || !full_search)
	goto done;
    }

  /* No non-global symbols found.  Check our cache to see if we have
     already performed this search before.  If we have, then return
     the same result.  */

  cacheIfUnique = 1;
  if (lookup_cached_symbol (name0, namespace, &sym, &block))
    {
      if (sym != NULL)
        add_defn_to_vec (&symbol_list_obstack, sym, block);
      goto done;
    }

  /* Search symbols from all global blocks.  */
 
  add_nonlocal_symbols (&symbol_list_obstack, name, namespace, 1,
			wild_match_p);

  /* Now add symbols from all per-file blocks if we've gotten no hits
     (not strictly correct, but perhaps better than an error).  */

  if (num_defns_collected (&symbol_list_obstack) == 0)
    add_nonlocal_symbols (&symbol_list_obstack, name, namespace, 0,
			  wild_match_p);

done:
  ndefns = num_defns_collected (&symbol_list_obstack);
  *results = defns_collected (&symbol_list_obstack, 1);

  ndefns = remove_extra_symbols (*results, ndefns);

  if (ndefns == 0 && full_search)
    cache_symbol (name0, namespace, NULL, NULL);

  if (ndefns == 1 && full_search && cacheIfUnique)
    cache_symbol (name0, namespace, (*results)[0].sym, (*results)[0].block);

  ndefns = remove_irrelevant_renamings (*results, ndefns, block0);

  return ndefns;
}

/* Find symbols in DOMAIN matching NAME0, in BLOCK0 and enclosing scope and
   in global scopes, returning the number of matches, and setting *RESULTS
   to a vector of (SYM,BLOCK) tuples.
   See ada_lookup_symbol_list_worker for further details.  */

int
ada_lookup_symbol_list (const char *name0, const struct block *block0,
			domain_enum domain, struct ada_symbol_info **results)
{
  return ada_lookup_symbol_list_worker (name0, block0, domain, results, 1);
}

/* Implementation of the la_iterate_over_symbols method.  */

static void
ada_iterate_over_symbols (const struct block *block,
			  const char *name, domain_enum domain,
			  symbol_found_callback_ftype *callback,
			  void *data)
{
  int ndefs, i;
  struct ada_symbol_info *results;

  ndefs = ada_lookup_symbol_list_worker (name, block, domain, &results, 0);
  for (i = 0; i < ndefs; ++i)
    {
      if (! (*callback) (results[i].sym, data))
	break;
    }
}

/* If NAME is the name of an entity, return a string that should
   be used to look that entity up in Ada units.  This string should
   be deallocated after use using xfree.

   NAME can have any form that the "break" or "print" commands might
   recognize.  In other words, it does not have to be the "natural"
   name, or the "encoded" name.  */

char *
ada_name_for_lookup (const char *name)
{
  char *canon;
  int nlen = strlen (name);

  if (name[0] == '<' && name[nlen - 1] == '>')
    {
      canon = xmalloc (nlen - 1);
      memcpy (canon, name + 1, nlen - 2);
      canon[nlen - 2] = '\0';
    }
  else
    canon = xstrdup (ada_encode (ada_fold_name (name)));
  return canon;
}

/* The result is as for ada_lookup_symbol_list with FULL_SEARCH set
   to 1, but choosing the first symbol found if there are multiple
   choices.

   The result is stored in *INFO, which must be non-NULL.
   If no match is found, INFO->SYM is set to NULL.  */

void
ada_lookup_encoded_symbol (const char *name, const struct block *block,
			   domain_enum namespace,
			   struct ada_symbol_info *info)
{
  struct ada_symbol_info *candidates;
  int n_candidates;

  gdb_assert (info != NULL);
  memset (info, 0, sizeof (struct ada_symbol_info));

  n_candidates = ada_lookup_symbol_list (name, block, namespace, &candidates);
  if (n_candidates == 0)
    return;

  *info = candidates[0];
  info->sym = fixup_symbol_section (info->sym, NULL);
}

/* Return a symbol in DOMAIN matching NAME, in BLOCK0 and enclosing
   scope and in global scopes, or NULL if none.  NAME is folded and
   encoded first.  Otherwise, the result is as for ada_lookup_symbol_list,
   choosing the first symbol if there are multiple choices.
   If IS_A_FIELD_OF_THIS is not NULL, it is set to zero.  */

struct symbol *
ada_lookup_symbol (const char *name, const struct block *block0,
                   domain_enum namespace, int *is_a_field_of_this)
{
  struct ada_symbol_info info;

  if (is_a_field_of_this != NULL)
    *is_a_field_of_this = 0;

  ada_lookup_encoded_symbol (ada_encode (ada_fold_name (name)),
			     block0, namespace, &info);
  return info.sym;
}

static struct symbol *
ada_lookup_symbol_nonlocal (const char *name,
                            const struct block *block,
                            const domain_enum domain)
{
  return ada_lookup_symbol (name, block_static_block (block), domain, NULL);
}


/* True iff STR is a possible encoded suffix of a normal Ada name
   that is to be ignored for matching purposes.  Suffixes of parallel
   names (e.g., XVE) are not included here.  Currently, the possible suffixes
   are given by any of the regular expressions:

   [.$][0-9]+       [nested subprogram suffix, on platforms such as GNU/Linux]
   ___[0-9]+        [nested subprogram suffix, on platforms such as HP/UX]
   TKB              [subprogram suffix for task bodies]
   _E[0-9]+[bs]$    [protected object entry suffixes]
   (X[nb]*)?((\$|__)[0-9](_?[0-9]+)|___(JM|LJM|X([FDBUP].*|R[^T]?)))?$

   Also, any leading "__[0-9]+" sequence is skipped before the suffix
   match is performed.  This sequence is used to differentiate homonyms,
   is an optional part of a valid name suffix.  */

static int
is_name_suffix (const char *str)
{
  int k;
  const char *matching;
  const int len = strlen (str);

  /* Skip optional leading __[0-9]+.  */

  if (len > 3 && str[0] == '_' && str[1] == '_' && isdigit (str[2]))
    {
      str += 3;
      while (isdigit (str[0]))
        str += 1;
    }
  
  /* [.$][0-9]+ */

  if (str[0] == '.' || str[0] == '$')
    {
      matching = str + 1;
      while (isdigit (matching[0]))
        matching += 1;
      if (matching[0] == '\0')
        return 1;
    }

  /* ___[0-9]+ */

  if (len > 3 && str[0] == '_' && str[1] == '_' && str[2] == '_')
    {
      matching = str + 3;
      while (isdigit (matching[0]))
        matching += 1;
      if (matching[0] == '\0')
        return 1;
    }

  /* "TKB" suffixes are used for subprograms implementing task bodies.  */

  if (strcmp (str, "TKB") == 0)
    return 1;

#if 0
  /* FIXME: brobecker/2005-09-23: Protected Object subprograms end
     with a N at the end.  Unfortunately, the compiler uses the same
     convention for other internal types it creates.  So treating
     all entity names that end with an "N" as a name suffix causes
     some regressions.  For instance, consider the case of an enumerated
     type.  To support the 'Image attribute, it creates an array whose
     name ends with N.
     Having a single character like this as a suffix carrying some
     information is a bit risky.  Perhaps we should change the encoding
     to be something like "_N" instead.  In the meantime, do not do
     the following check.  */
  /* Protected Object Subprograms */
  if (len == 1 && str [0] == 'N')
    return 1;
#endif

  /* _E[0-9]+[bs]$ */
  if (len > 3 && str[0] == '_' && str [1] == 'E' && isdigit (str[2]))
    {
      matching = str + 3;
      while (isdigit (matching[0]))
        matching += 1;
      if ((matching[0] == 'b' || matching[0] == 's')
          && matching [1] == '\0')
        return 1;
    }

  /* ??? We should not modify STR directly, as we are doing below.  This
     is fine in this case, but may become problematic later if we find
     that this alternative did not work, and want to try matching
     another one from the begining of STR.  Since we modified it, we
     won't be able to find the begining of the string anymore!  */
  if (str[0] == 'X')
    {
      str += 1;
      while (str[0] != '_' && str[0] != '\0')
        {
          if (str[0] != 'n' && str[0] != 'b')
            return 0;
          str += 1;
        }
    }

  if (str[0] == '\000')
    return 1;

  if (str[0] == '_')
    {
      if (str[1] != '_' || str[2] == '\000')
        return 0;
      if (str[2] == '_')
        {
          if (strcmp (str + 3, "JM") == 0)
            return 1;
          /* FIXME: brobecker/2004-09-30: GNAT will soon stop using
             the LJM suffix in favor of the JM one.  But we will
             still accept LJM as a valid suffix for a reasonable
             amount of time, just to allow ourselves to debug programs
             compiled using an older version of GNAT.  */
          if (strcmp (str + 3, "LJM") == 0)
            return 1;
          if (str[3] != 'X')
            return 0;
          if (str[4] == 'F' || str[4] == 'D' || str[4] == 'B'
              || str[4] == 'U' || str[4] == 'P')
            return 1;
          if (str[4] == 'R' && str[5] != 'T')
            return 1;
          return 0;
        }
      if (!isdigit (str[2]))
        return 0;
      for (k = 3; str[k] != '\0'; k += 1)
        if (!isdigit (str[k]) && str[k] != '_')
          return 0;
      return 1;
    }
  if (str[0] == '$' && isdigit (str[1]))
    {
      for (k = 2; str[k] != '\0'; k += 1)
        if (!isdigit (str[k]) && str[k] != '_')
          return 0;
      return 1;
    }
  return 0;
}

/* Return non-zero if the string starting at NAME and ending before
   NAME_END contains no capital letters.  */

static int
is_valid_name_for_wild_match (const char *name0)
{
  const char *decoded_name = ada_decode (name0);
  int i;

  /* If the decoded name starts with an angle bracket, it means that
     NAME0 does not follow the GNAT encoding format.  It should then
     not be allowed as a possible wild match.  */
  if (decoded_name[0] == '<')
    return 0;

  for (i=0; decoded_name[i] != '\0'; i++)
    if (isalpha (decoded_name[i]) && !islower (decoded_name[i]))
      return 0;

  return 1;
}

/* Advance *NAMEP to next occurrence of TARGET0 in the string NAME0
   that could start a simple name.  Assumes that *NAMEP points into
   the string beginning at NAME0.  */

static int
advance_wild_match (const char **namep, const char *name0, int target0)
{
  const char *name = *namep;

  while (1)
    {
      int t0, t1;

      t0 = *name;
      if (t0 == '_')
	{
	  t1 = name[1];
	  if ((t1 >= 'a' && t1 <= 'z') || (t1 >= '0' && t1 <= '9'))
	    {
	      name += 1;
	      if (name == name0 + 5 && strncmp (name0, "_ada", 4) == 0)
		break;
	      else
		name += 1;
	    }
	  else if (t1 == '_' && ((name[2] >= 'a' && name[2] <= 'z')
				 || name[2] == target0))
	    {
	      name += 2;
	      break;
	    }
	  else
	    return 0;
	}
      else if ((t0 >= 'a' && t0 <= 'z') || (t0 >= '0' && t0 <= '9'))
	name += 1;
      else
	return 0;
    }

  *namep = name;
  return 1;
}

/* Return 0 iff NAME encodes a name of the form prefix.PATN.  Ignores any
   informational suffixes of NAME (i.e., for which is_name_suffix is
   true).  Assumes that PATN is a lower-cased Ada simple name.  */

static int
wild_match (const char *name, const char *patn)
{
  const char *p;
  const char *name0 = name;

  while (1)
    {
      const char *match = name;

      if (*name == *patn)
	{
	  for (name += 1, p = patn + 1; *p != '\0'; name += 1, p += 1)
	    if (*p != *name)
	      break;
	  if (*p == '\0' && is_name_suffix (name))
	    return match != name0 && !is_valid_name_for_wild_match (name0);

	  if (name[-1] == '_')
	    name -= 1;
	}
      if (!advance_wild_match (&name, name0, *patn))
	return 1;
    }
}

/* Returns 0 iff symbol name SYM_NAME matches SEARCH_NAME, apart from
   informational suffix.  */

static int
full_match (const char *sym_name, const char *search_name)
{
  return !match_name (sym_name, search_name, 0);
}


/* Add symbols from BLOCK matching identifier NAME in DOMAIN to
   vector *defn_symbols, updating the list of symbols in OBSTACKP 
   (if necessary).  If WILD, treat as NAME with a wildcard prefix.
   OBJFILE is the section containing BLOCK.  */

static void
ada_add_block_symbols (struct obstack *obstackp,
                       struct block *block, const char *name,
                       domain_enum domain, struct objfile *objfile,
                       int wild)
{
  struct block_iterator iter;
  int name_len = strlen (name);
  /* A matching argument symbol, if any.  */
  struct symbol *arg_sym;
  /* Set true when we find a matching non-argument symbol.  */
  int found_sym;
  struct symbol *sym;

  arg_sym = NULL;
  found_sym = 0;
  if (wild)
    {
      for (sym = block_iter_match_first (block, name, wild_match, &iter);
	   sym != NULL; sym = block_iter_match_next (name, wild_match, &iter))
      {
        if (symbol_matches_domain (SYMBOL_LANGUAGE (sym),
                                   SYMBOL_DOMAIN (sym), domain)
            && wild_match (SYMBOL_LINKAGE_NAME (sym), name) == 0)
          {
	    if (SYMBOL_CLASS (sym) == LOC_UNRESOLVED)
	      continue;
	    else if (SYMBOL_IS_ARGUMENT (sym))
	      arg_sym = sym;
	    else
	      {
                found_sym = 1;
                add_defn_to_vec (obstackp,
                                 fixup_symbol_section (sym, objfile),
                                 block);
              }
          }
      }
    }
  else
    {
     for (sym = block_iter_match_first (block, name, full_match, &iter);
	  sym != NULL; sym = block_iter_match_next (name, full_match, &iter))
      {
        if (symbol_matches_domain (SYMBOL_LANGUAGE (sym),
                                   SYMBOL_DOMAIN (sym), domain))
          {
	    if (SYMBOL_CLASS (sym) != LOC_UNRESOLVED)
	      {
		if (SYMBOL_IS_ARGUMENT (sym))
		  arg_sym = sym;
		else
		  {
		    found_sym = 1;
		    add_defn_to_vec (obstackp,
				     fixup_symbol_section (sym, objfile),
				     block);
		  }
	      }
          }
      }
    }

  if (!found_sym && arg_sym != NULL)
    {
      add_defn_to_vec (obstackp,
                       fixup_symbol_section (arg_sym, objfile),
                       block);
    }

  if (!wild)
    {
      arg_sym = NULL;
      found_sym = 0;

      ALL_BLOCK_SYMBOLS (block, iter, sym)
      {
        if (symbol_matches_domain (SYMBOL_LANGUAGE (sym),
                                   SYMBOL_DOMAIN (sym), domain))
          {
            int cmp;

            cmp = (int) '_' - (int) SYMBOL_LINKAGE_NAME (sym)[0];
            if (cmp == 0)
              {
                cmp = strncmp ("_ada_", SYMBOL_LINKAGE_NAME (sym), 5);
                if (cmp == 0)
                  cmp = strncmp (name, SYMBOL_LINKAGE_NAME (sym) + 5,
                                 name_len);
              }

            if (cmp == 0
                && is_name_suffix (SYMBOL_LINKAGE_NAME (sym) + name_len + 5))
              {
		if (SYMBOL_CLASS (sym) != LOC_UNRESOLVED)
		  {
		    if (SYMBOL_IS_ARGUMENT (sym))
		      arg_sym = sym;
		    else
		      {
			found_sym = 1;
			add_defn_to_vec (obstackp,
					 fixup_symbol_section (sym, objfile),
					 block);
		      }
		  }
              }
          }
      }

      /* NOTE: This really shouldn't be needed for _ada_ symbols.
         They aren't parameters, right?  */
      if (!found_sym && arg_sym != NULL)
        {
          add_defn_to_vec (obstackp,
                           fixup_symbol_section (arg_sym, objfile),
                           block);
        }
    }
}


                                /* Symbol Completion */

/* If SYM_NAME is a completion candidate for TEXT, return this symbol
   name in a form that's appropriate for the completion.  The result
   does not need to be deallocated, but is only good until the next call.

   TEXT_LEN is equal to the length of TEXT.
   Perform a wild match if WILD_MATCH_P is set.
   ENCODED_P should be set if TEXT represents the start of a symbol name
   in its encoded form.  */

static const char *
symbol_completion_match (const char *sym_name,
                         const char *text, int text_len,
                         int wild_match_p, int encoded_p)
{
  const int verbatim_match = (text[0] == '<');
  int match = 0;

  if (verbatim_match)
    {
      /* Strip the leading angle bracket.  */
      text = text + 1;
      text_len--;
    }

  /* First, test against the fully qualified name of the symbol.  */

  if (strncmp (sym_name, text, text_len) == 0)
    match = 1;

  if (match && !encoded_p)
    {
      /* One needed check before declaring a positive match is to verify
         that iff we are doing a verbatim match, the decoded version
         of the symbol name starts with '<'.  Otherwise, this symbol name
         is not a suitable completion.  */
      const char *sym_name_copy = sym_name;
      int has_angle_bracket;

      sym_name = ada_decode (sym_name);
      has_angle_bracket = (sym_name[0] == '<');
      match = (has_angle_bracket == verbatim_match);
      sym_name = sym_name_copy;
    }

  if (match && !verbatim_match)
    {
      /* When doing non-verbatim match, another check that needs to
         be done is to verify that the potentially matching symbol name
         does not include capital letters, because the ada-mode would
         not be able to understand these symbol names without the
         angle bracket notation.  */
      const char *tmp;

      for (tmp = sym_name; *tmp != '\0' && !isupper (*tmp); tmp++);
      if (*tmp != '\0')
        match = 0;
    }

  /* Second: Try wild matching...  */

  if (!match && wild_match_p)
    {
      /* Since we are doing wild matching, this means that TEXT
         may represent an unqualified symbol name.  We therefore must
         also compare TEXT against the unqualified name of the symbol.  */
      sym_name = ada_unqualified_name (ada_decode (sym_name));

      if (strncmp (sym_name, text, text_len) == 0)
        match = 1;
    }

  /* Finally: If we found a mach, prepare the result to return.  */

  if (!match)
    return NULL;

  if (verbatim_match)
    sym_name = add_angle_brackets (sym_name);

  if (!encoded_p)
    sym_name = ada_decode (sym_name);

  return sym_name;
}

/* A companion function to ada_make_symbol_completion_list().
   Check if SYM_NAME represents a symbol which name would be suitable
   to complete TEXT (TEXT_LEN is the length of TEXT), in which case
   it is appended at the end of the given string vector SV.

   ORIG_TEXT is the string original string from the user command
   that needs to be completed.  WORD is the entire command on which
   completion should be performed.  These two parameters are used to
   determine which part of the symbol name should be added to the
   completion vector.
   if WILD_MATCH_P is set, then wild matching is performed.
   ENCODED_P should be set if TEXT represents a symbol name in its
   encoded formed (in which case the completion should also be
   encoded).  */

static void
symbol_completion_add (VEC(char_ptr) **sv,
                       const char *sym_name,
                       const char *text, int text_len,
                       const char *orig_text, const char *word,
                       int wild_match_p, int encoded_p)
{
  const char *match = symbol_completion_match (sym_name, text, text_len,
                                               wild_match_p, encoded_p);
  char *completion;

  if (match == NULL)
    return;

  /* We found a match, so add the appropriate completion to the given
     string vector.  */

  if (word == orig_text)
    {
      completion = xmalloc (strlen (match) + 5);
      strcpy (completion, match);
    }
  else if (word > orig_text)
    {
      /* Return some portion of sym_name.  */
      completion = xmalloc (strlen (match) + 5);
      strcpy (completion, match + (word - orig_text));
    }
  else
    {
      /* Return some of ORIG_TEXT plus sym_name.  */
      completion = xmalloc (strlen (match) + (orig_text - word) + 5);
      strncpy (completion, word, orig_text - word);
      completion[orig_text - word] = '\0';
      strcat (completion, match);
    }

  VEC_safe_push (char_ptr, *sv, completion);
}

/* An object of this type is passed as the user_data argument to the
   expand_partial_symbol_names method.  */
struct add_partial_datum
{
  VEC(char_ptr) **completions;
  const char *text;
  int text_len;
  const char *text0;
  const char *word;
  int wild_match;
  int encoded;
};

/* A callback for expand_partial_symbol_names.  */
static int
ada_expand_partial_symbol_name (const char *name, void *user_data)
{
  struct add_partial_datum *data = user_data;
  
  return symbol_completion_match (name, data->text, data->text_len,
                                  data->wild_match, data->encoded) != NULL;
}

/* Return a list of possible symbol names completing TEXT0.  WORD is
   the entire command on which completion is made.  */

static VEC (char_ptr) *
ada_make_symbol_completion_list (const char *text0, const char *word,
				 enum type_code code)
{
  char *text;
  int text_len;
  int wild_match_p;
  int encoded_p;
  VEC(char_ptr) *completions = VEC_alloc (char_ptr, 128);
  struct symbol *sym;
  struct symtab *s;
  struct minimal_symbol *msymbol;
  struct objfile *objfile;
  struct block *b, *surrounding_static_block = 0;
  int i;
  struct block_iterator iter;
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);

  gdb_assert (code == TYPE_CODE_UNDEF);

  if (text0[0] == '<')
    {
      text = xstrdup (text0);
      make_cleanup (xfree, text);
      text_len = strlen (text);
      wild_match_p = 0;
      encoded_p = 1;
    }
  else
    {
      text = xstrdup (ada_encode (text0));
      make_cleanup (xfree, text);
      text_len = strlen (text);
      for (i = 0; i < text_len; i++)
        text[i] = tolower (text[i]);

      encoded_p = (strstr (text0, "__") != NULL);
      /* If the name contains a ".", then the user is entering a fully
         qualified entity name, and the match must not be done in wild
         mode.  Similarly, if the user wants to complete what looks like
         an encoded name, the match must not be done in wild mode.  */
      wild_match_p = (strchr (text0, '.') == NULL && !encoded_p);
    }

  /* First, look at the partial symtab symbols.  */
  {
    struct add_partial_datum data;

    data.completions = &completions;
    data.text = text;
    data.text_len = text_len;
    data.text0 = text0;
    data.word = word;
    data.wild_match = wild_match_p;
    data.encoded = encoded_p;
    expand_partial_symbol_names (ada_expand_partial_symbol_name, &data);
  }

  /* At this point scan through the misc symbol vectors and add each
     symbol you find to the list.  Eventually we want to ignore
     anything that isn't a text symbol (everything else will be
     handled by the psymtab code above).  */

  ALL_MSYMBOLS (objfile, msymbol)
  {
    QUIT;
    symbol_completion_add (&completions, SYMBOL_LINKAGE_NAME (msymbol),
			   text, text_len, text0, word, wild_match_p,
			   encoded_p);
  }

  /* Search upwards from currently selected frame (so that we can
     complete on local vars.  */

  for (b = get_selected_block (0); b != NULL; b = BLOCK_SUPERBLOCK (b))
    {
      if (!BLOCK_SUPERBLOCK (b))
        surrounding_static_block = b;   /* For elmin of dups */

      ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
        symbol_completion_add (&completions, SYMBOL_LINKAGE_NAME (sym),
                               text, text_len, text0, word,
                               wild_match_p, encoded_p);
      }
    }

  /* Go through the symtabs and check the externs and statics for
     symbols which match.  */

  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
    ALL_BLOCK_SYMBOLS (b, iter, sym)
    {
      symbol_completion_add (&completions, SYMBOL_LINKAGE_NAME (sym),
                             text, text_len, text0, word,
                             wild_match_p, encoded_p);
    }
  }

  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
    /* Don't do this block twice.  */
    if (b == surrounding_static_block)
      continue;
    ALL_BLOCK_SYMBOLS (b, iter, sym)
    {
      symbol_completion_add (&completions, SYMBOL_LINKAGE_NAME (sym),
                             text, text_len, text0, word,
                             wild_match_p, encoded_p);
    }
  }

  do_cleanups (old_chain);
  return completions;
}

                                /* Field Access */

/* Return non-zero if TYPE is a pointer to the GNAT dispatch table used
   for tagged types.  */

static int
ada_is_dispatch_table_ptr_type (struct type *type)
{
  const char *name;

  if (TYPE_CODE (type) != TYPE_CODE_PTR)
    return 0;

  name = TYPE_NAME (TYPE_TARGET_TYPE (type));
  if (name == NULL)
    return 0;

  return (strcmp (name, "ada__tags__dispatch_table") == 0);
}

/* Return non-zero if TYPE is an interface tag.  */

static int
ada_is_interface_tag (struct type *type)
{
  const char *name = TYPE_NAME (type);

  if (name == NULL)
    return 0;

  return (strcmp (name, "ada__tags__interface_tag") == 0);
}

/* True if field number FIELD_NUM in struct or union type TYPE is supposed
   to be invisible to users.  */

int
ada_is_ignored_field (struct type *type, int field_num)
{
  if (field_num < 0 || field_num > TYPE_NFIELDS (type))
    return 1;

  /* Check the name of that field.  */
  {
    const char *name = TYPE_FIELD_NAME (type, field_num);

    /* Anonymous field names should not be printed.
       brobecker/2007-02-20: I don't think this can actually happen
       but we don't want to print the value of annonymous fields anyway.  */
    if (name == NULL)
      return 1;

    /* Normally, fields whose name start with an underscore ("_")
       are fields that have been internally generated by the compiler,
       and thus should not be printed.  The "_parent" field is special,
       however: This is a field internally generated by the compiler
       for tagged types, and it contains the components inherited from
       the parent type.  This field should not be printed as is, but
       should not be ignored either.  */
    if (name[0] == '_' && strncmp (name, "_parent", 7) != 0)
      return 1;
  }

  /* If this is the dispatch table of a tagged type or an interface tag,
     then ignore.  */
  if (ada_is_tagged_type (type, 1)
      && (ada_is_dispatch_table_ptr_type (TYPE_FIELD_TYPE (type, field_num))
	  || ada_is_interface_tag (TYPE_FIELD_TYPE (type, field_num))))
    return 1;

  /* Not a special field, so it should not be ignored.  */
  return 0;
}

/* True iff TYPE has a tag field.  If REFOK, then TYPE may also be a
   pointer or reference type whose ultimate target has a tag field.  */

int
ada_is_tagged_type (struct type *type, int refok)
{
  return (ada_lookup_struct_elt_type (type, "_tag", refok, 1, NULL) != NULL);
}

/* True iff TYPE represents the type of X'Tag */

int
ada_is_tag_type (struct type *type)
{
  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_PTR)
    return 0;
  else
    {
      const char *name = ada_type_name (TYPE_TARGET_TYPE (type));

      return (name != NULL
              && strcmp (name, "ada__tags__dispatch_table") == 0);
    }
}

/* The type of the tag on VAL.  */

struct type *
ada_tag_type (struct value *val)
{
  return ada_lookup_struct_elt_type (value_type (val), "_tag", 1, 0, NULL);
}

/* Return 1 if TAG follows the old scheme for Ada tags (used for Ada 95,
   retired at Ada 05).  */

static int
is_ada95_tag (struct value *tag)
{
  return ada_value_struct_elt (tag, "tsd", 1) != NULL;
}

/* The value of the tag on VAL.  */

struct value *
ada_value_tag (struct value *val)
{
  return ada_value_struct_elt (val, "_tag", 0);
}

/* The value of the tag on the object of type TYPE whose contents are
   saved at VALADDR, if it is non-null, or is at memory address
   ADDRESS.  */

static struct value *
value_tag_from_contents_and_address (struct type *type,
				     const gdb_byte *valaddr,
                                     CORE_ADDR address)
{
  int tag_byte_offset;
  struct type *tag_type;

  if (find_struct_field ("_tag", type, 0, &tag_type, &tag_byte_offset,
                         NULL, NULL, NULL))
    {
      const gdb_byte *valaddr1 = ((valaddr == NULL)
				  ? NULL
				  : valaddr + tag_byte_offset);
      CORE_ADDR address1 = (address == 0) ? 0 : address + tag_byte_offset;

      return value_from_contents_and_address (tag_type, valaddr1, address1);
    }
  return NULL;
}

static struct type *
type_from_tag (struct value *tag)
{
  const char *type_name = ada_tag_name (tag);

  if (type_name != NULL)
    return ada_find_any_type (ada_encode (type_name));
  return NULL;
}

/* Given a value OBJ of a tagged type, return a value of this
   type at the base address of the object.  The base address, as
   defined in Ada.Tags, it is the address of the primary tag of
   the object, and therefore where the field values of its full
   view can be fetched.  */

struct value *
ada_tag_value_at_base_address (struct value *obj)
{
  volatile struct gdb_exception e;
  struct value *val;
  LONGEST offset_to_top = 0;
  struct type *ptr_type, *obj_type;
  struct value *tag;
  CORE_ADDR base_address;

  obj_type = value_type (obj);

  /* It is the responsability of the caller to deref pointers.  */

  if (TYPE_CODE (obj_type) == TYPE_CODE_PTR
      || TYPE_CODE (obj_type) == TYPE_CODE_REF)
    return obj;

  tag = ada_value_tag (obj);
  if (!tag)
    return obj;

  /* Base addresses only appeared with Ada 05 and multiple inheritance.  */

  if (is_ada95_tag (tag))
    return obj;

  ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;
  ptr_type = lookup_pointer_type (ptr_type);
  val = value_cast (ptr_type, tag);
  if (!val)
    return obj;

  /* It is perfectly possible that an exception be raised while
     trying to determine the base address, just like for the tag;
     see ada_tag_name for more details.  We do not print the error
     message for the same reason.  */

  TRY_CATCH (e, RETURN_MASK_ERROR)
    {
      offset_to_top = value_as_long (value_ind (value_ptradd (val, -2)));
    }

  if (e.reason < 0)
    return obj;

  /* If offset is null, nothing to do.  */

  if (offset_to_top == 0)
    return obj;

  /* -1 is a special case in Ada.Tags; however, what should be done
     is not quite clear from the documentation.  So do nothing for
     now.  */

  if (offset_to_top == -1)
    return obj;

  base_address = value_address (obj) - offset_to_top;
  tag = value_tag_from_contents_and_address (obj_type, NULL, base_address);

  /* Make sure that we have a proper tag at the new address.
     Otherwise, offset_to_top is bogus (which can happen when
     the object is not initialized yet).  */

  if (!tag)
    return obj;

  obj_type = type_from_tag (tag);

  if (!obj_type)
    return obj;

  return value_from_contents_and_address (obj_type, NULL, base_address);
}

/* Return the "ada__tags__type_specific_data" type.  */

static struct type *
ada_get_tsd_type (struct inferior *inf)
{
  struct ada_inferior_data *data = get_ada_inferior_data (inf);

  if (data->tsd_type == 0)
    data->tsd_type = ada_find_any_type ("ada__tags__type_specific_data");
  return data->tsd_type;
}

/* Return the TSD (type-specific data) associated to the given TAG.
   TAG is assumed to be the tag of a tagged-type entity.

   May return NULL if we are unable to get the TSD.  */

static struct value *
ada_get_tsd_from_tag (struct value *tag)
{
  struct value *val;
  struct type *type;

  /* First option: The TSD is simply stored as a field of our TAG.
     Only older versions of GNAT would use this format, but we have
     to test it first, because there are no visible markers for
     the current approach except the absence of that field.  */

  val = ada_value_struct_elt (tag, "tsd", 1);
  if (val)
    return val;

  /* Try the second representation for the dispatch table (in which
     there is no explicit 'tsd' field in the referent of the tag pointer,
     and instead the tsd pointer is stored just before the dispatch
     table.  */

  type = ada_get_tsd_type (current_inferior());
  if (type == NULL)
    return NULL;
  type = lookup_pointer_type (lookup_pointer_type (type));
  val = value_cast (type, tag);
  if (val == NULL)
    return NULL;
  return value_ind (value_ptradd (val, -1));
}

/* Given the TSD of a tag (type-specific data), return a string
   containing the name of the associated type.

   The returned value is good until the next call.  May return NULL
   if we are unable to determine the tag name.  */

static char *
ada_tag_name_from_tsd (struct value *tsd)
{
  static char name[1024];
  char *p;
  struct value *val;

  val = ada_value_struct_elt (tsd, "expanded_name", 1);
  if (val == NULL)
    return NULL;
  read_memory_string (value_as_address (val), name, sizeof (name) - 1);
  for (p = name; *p != '\0'; p += 1)
    if (isalpha (*p))
      *p = tolower (*p);
  return name;
}

/* The type name of the dynamic type denoted by the 'tag value TAG, as
   a C string.

   Return NULL if the TAG is not an Ada tag, or if we were unable to
   determine the name of that tag.  The result is good until the next
   call.  */

const char *
ada_tag_name (struct value *tag)
{
  volatile struct gdb_exception e;
  char *name = NULL;

  if (!ada_is_tag_type (value_type (tag)))
    return NULL;

  /* It is perfectly possible that an exception be raised while trying
     to determine the TAG's name, even under normal circumstances:
     The associated variable may be uninitialized or corrupted, for
     instance. We do not let any exception propagate past this point.
     instead we return NULL.

     We also do not print the error message either (which often is very
     low-level (Eg: "Cannot read memory at 0x[...]"), but instead let
     the caller print a more meaningful message if necessary.  */
  TRY_CATCH (e, RETURN_MASK_ERROR)
    {
      struct value *tsd = ada_get_tsd_from_tag (tag);

      if (tsd != NULL)
	name = ada_tag_name_from_tsd (tsd);
    }

  return name;
}

/* The parent type of TYPE, or NULL if none.  */

struct type *
ada_parent_type (struct type *type)
{
  int i;

  type = ada_check_typedef (type);

  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT)
    return NULL;

  for (i = 0; i < TYPE_NFIELDS (type); i += 1)
    if (ada_is_parent_field (type, i))
      {
        struct type *parent_type = TYPE_FIELD_TYPE (type, i);

        /* If the _parent field is a pointer, then dereference it.  */
        if (TYPE_CODE (parent_type) == TYPE_CODE_PTR)
          parent_type = TYPE_TARGET_TYPE (parent_type);
        /* If there is a parallel XVS type, get the actual base type.  */
        parent_type = ada_get_base_type (parent_type);

        return ada_check_typedef (parent_type);
      }

  return NULL;
}

/* True iff field number FIELD_NUM of structure type TYPE contains the
   parent-type (inherited) fields of a derived type.  Assumes TYPE is
   a structure type with at least FIELD_NUM+1 fields.  */

int
ada_is_parent_field (struct type *type, int field_num)
{
  const char *name = TYPE_FIELD_NAME (ada_check_typedef (type), field_num);

  return (name != NULL
          && (strncmp (name, "PARENT", 6) == 0
              || strncmp (name, "_parent", 7) == 0));
}

/* True iff field number FIELD_NUM of structure type TYPE is a
   transparent wrapper field (which should be silently traversed when doing
   field selection and flattened when printing).  Assumes TYPE is a
   structure type with at least FIELD_NUM+1 fields.  Such fields are always
   structures.  */

int
ada_is_wrapper_field (struct type *type, int field_num)
{
  const char *name = TYPE_FIELD_NAME (type, field_num);

  return (name != NULL
          && (strncmp (name, "PARENT", 6) == 0
              || strcmp (name, "REP") == 0
              || strncmp (name, "_parent", 7) == 0
              || name[0] == 'S' || name[0] == 'R' || name[0] == 'O'));
}

/* True iff field number FIELD_NUM of structure or union type TYPE
   is a variant wrapper.  Assumes TYPE is a structure type with at least
   FIELD_NUM+1 fields.  */

int
ada_is_variant_part (struct type *type, int field_num)
{
  struct type *field_type = TYPE_FIELD_TYPE (type, field_num);

  return (TYPE_CODE (field_type) == TYPE_CODE_UNION
          || (is_dynamic_field (type, field_num)
              && (TYPE_CODE (TYPE_TARGET_TYPE (field_type)) 
		  == TYPE_CODE_UNION)));
}

/* Assuming that VAR_TYPE is a variant wrapper (type of the variant part)
   whose discriminants are contained in the record type OUTER_TYPE,
   returns the type of the controlling discriminant for the variant.
   May return NULL if the type could not be found.  */

struct type *
ada_variant_discrim_type (struct type *var_type, struct type *outer_type)
{
  char *name = ada_variant_discrim_name (var_type);

  return ada_lookup_struct_elt_type (outer_type, name, 1, 1, NULL);
}

/* Assuming that TYPE is the type of a variant wrapper, and FIELD_NUM is a
   valid field number within it, returns 1 iff field FIELD_NUM of TYPE
   represents a 'when others' clause; otherwise 0.  */

int
ada_is_others_clause (struct type *type, int field_num)
{
  const char *name = TYPE_FIELD_NAME (type, field_num);

  return (name != NULL && name[0] == 'O');
}

/* Assuming that TYPE0 is the type of the variant part of a record,
   returns the name of the discriminant controlling the variant.
   The value is valid until the next call to ada_variant_discrim_name.  */

char *
ada_variant_discrim_name (struct type *type0)
{
  static char *result = NULL;
  static size_t result_len = 0;
  struct type *type;
  const char *name;
  const char *discrim_end;
  const char *discrim_start;

  if (TYPE_CODE (type0) == TYPE_CODE_PTR)
    type = TYPE_TARGET_TYPE (type0);
  else
    type = type0;

  name = ada_type_name (type);

  if (name == NULL || name[0] == '\000')
    return "";

  for (discrim_end = name + strlen (name) - 6; discrim_end != name;
       discrim_end -= 1)
    {
      if (strncmp (discrim_end, "___XVN", 6) == 0)
        break;
    }
  if (discrim_end == name)
    return "";

  for (discrim_start = discrim_end; discrim_start != name + 3;
       discrim_start -= 1)
    {
      if (discrim_start == name + 1)
        return "";
      if ((discrim_start > name + 3
           && strncmp (discrim_start - 3, "___", 3) == 0)
          || discrim_start[-1] == '.')
        break;
    }

  GROW_VECT (result, result_len, discrim_end - discrim_start + 1);
  strncpy (result, discrim_start, discrim_end - discrim_start);
  result[discrim_end - discrim_start] = '\0';
  return result;
}

/* Scan STR for a subtype-encoded number, beginning at position K.
   Put the position of the character just past the number scanned in
   *NEW_K, if NEW_K!=NULL.  Put the scanned number in *R, if R!=NULL.
   Return 1 if there was a valid number at the given position, and 0
   otherwise.  A "subtype-encoded" number consists of the absolute value
   in decimal, followed by the letter 'm' to indicate a negative number.
   Assumes 0m does not occur.  */

int
ada_scan_number (const char str[], int k, LONGEST * R, int *new_k)
{
  ULONGEST RU;

  if (!isdigit (str[k]))
    return 0;

  /* Do it the hard way so as not to make any assumption about
     the relationship of unsigned long (%lu scan format code) and
     LONGEST.  */
  RU = 0;
  while (isdigit (str[k]))
    {
      RU = RU * 10 + (str[k] - '0');
      k += 1;
    }

  if (str[k] == 'm')
    {
      if (R != NULL)
        *R = (-(LONGEST) (RU - 1)) - 1;
      k += 1;
    }
  else if (R != NULL)
    *R = (LONGEST) RU;

  /* NOTE on the above: Technically, C does not say what the results of
     - (LONGEST) RU or (LONGEST) -RU are for RU == largest positive
     number representable as a LONGEST (although either would probably work
     in most implementations).  When RU>0, the locution in the then branch
     above is always equivalent to the negative of RU.  */

  if (new_k != NULL)
    *new_k = k;
  return 1;
}

/* Assuming that TYPE is a variant part wrapper type (a VARIANTS field),
   and FIELD_NUM is a valid field number within it, returns 1 iff VAL is
   in the range encoded by field FIELD_NUM of TYPE; otherwise 0.  */

int
ada_in_variant (LONGEST val, struct type *type, int field_num)
{
  const char *name = TYPE_FIELD_NAME (type, field_num);
  int p;

  p = 0;
  while (1)
    {
      switch (name[p])
        {
        case '\0':
          return 0;
        case 'S':
          {
            LONGEST W;

            if (!ada_scan_number (name, p + 1, &W, &p))
              return 0;
            if (val == W)
              return 1;
            break;
          }
        case 'R':
          {
            LONGEST L, U;

            if (!ada_scan_number (name, p + 1, &L, &p)
                || name[p] != 'T' || !ada_scan_number (name, p + 1, &U, &p))
              return 0;
            if (val >= L && val <= U)
              return 1;
            break;
          }
        case 'O':
          return 1;
        default:
          return 0;
        }
    }
}

/* FIXME: Lots of redundancy below.  Try to consolidate.  */

/* Given a value ARG1 (offset by OFFSET bytes) of a struct or union type
   ARG_TYPE, extract and return the value of one of its (non-static)
   fields.  FIELDNO says which field.   Differs from value_primitive_field
   only in that it can handle packed values of arbitrary type.  */

static struct value *
ada_value_primitive_field (struct value *arg1, int offset, int fieldno,
                           struct type *arg_type)
{
  struct type *type;

  arg_type = ada_check_typedef (arg_type);
  type = TYPE_FIELD_TYPE (arg_type, fieldno);

  /* Handle packed fields.  */

  if (TYPE_FIELD_BITSIZE (arg_type, fieldno) != 0)
    {
      int bit_pos = TYPE_FIELD_BITPOS (arg_type, fieldno);
      int bit_size = TYPE_FIELD_BITSIZE (arg_type, fieldno);

      return ada_value_primitive_packed_val (arg1, value_contents (arg1),
                                             offset + bit_pos / 8,
                                             bit_pos % 8, bit_size, type);
    }
  else
    return value_primitive_field (arg1, offset, fieldno, arg_type);
}

/* Find field with name NAME in object of type TYPE.  If found, 
   set the following for each argument that is non-null:
    - *FIELD_TYPE_P to the field's type; 
    - *BYTE_OFFSET_P to OFFSET + the byte offset of the field within 
      an object of that type;
    - *BIT_OFFSET_P to the bit offset modulo byte size of the field; 
    - *BIT_SIZE_P to its size in bits if the field is packed, and 
      0 otherwise;
   If INDEX_P is non-null, increment *INDEX_P by the number of source-visible
   fields up to but not including the desired field, or by the total
   number of fields if not found.   A NULL value of NAME never
   matches; the function just counts visible fields in this case.
   
   Returns 1 if found, 0 otherwise.  */

static int
find_struct_field (const char *name, struct type *type, int offset,
                   struct type **field_type_p,
                   int *byte_offset_p, int *bit_offset_p, int *bit_size_p,
		   int *index_p)
{
  int i;

  type = ada_check_typedef (type);

  if (field_type_p != NULL)
    *field_type_p = NULL;
  if (byte_offset_p != NULL)
    *byte_offset_p = 0;
  if (bit_offset_p != NULL)
    *bit_offset_p = 0;
  if (bit_size_p != NULL)
    *bit_size_p = 0;

  for (i = 0; i < TYPE_NFIELDS (type); i += 1)
    {
      int bit_pos = TYPE_FIELD_BITPOS (type, i);
      int fld_offset = offset + bit_pos / 8;
      const char *t_field_name = TYPE_FIELD_NAME (type, i);

      if (t_field_name == NULL)
        continue;

      else if (name != NULL && field_name_match (t_field_name, name))
        {
          int bit_size = TYPE_FIELD_BITSIZE (type, i);

	  if (field_type_p != NULL)
	    *field_type_p = TYPE_FIELD_TYPE (type, i);
	  if (byte_offset_p != NULL)
	    *byte_offset_p = fld_offset;
	  if (bit_offset_p != NULL)
	    *bit_offset_p = bit_pos % 8;
	  if (bit_size_p != NULL)
	    *bit_size_p = bit_size;
          return 1;
        }
      else if (ada_is_wrapper_field (type, i))
        {
	  if (find_struct_field (name, TYPE_FIELD_TYPE (type, i), fld_offset,
				 field_type_p, byte_offset_p, bit_offset_p,
				 bit_size_p, index_p))
            return 1;
        }
      else if (ada_is_variant_part (type, i))
        {
	  /* PNH: Wait.  Do we ever execute this section, or is ARG always of 
	     fixed type?? */
          int j;
          struct type *field_type
	    = ada_check_typedef (TYPE_FIELD_TYPE (type, i));

          for (j = 0; j < TYPE_NFIELDS (field_type); j += 1)
            {
              if (find_struct_field (name, TYPE_FIELD_TYPE (field_type, j),
                                     fld_offset
                                     + TYPE_FIELD_BITPOS (field_type, j) / 8,
                                     field_type_p, byte_offset_p,
                                     bit_offset_p, bit_size_p, index_p))
                return 1;
            }
        }
      else if (index_p != NULL)
	*index_p += 1;
    }
  return 0;
}

/* Number of user-visible fields in record type TYPE.  */

static int
num_visible_fields (struct type *type)
{
  int n;

  n = 0;
  find_struct_field (NULL, type, 0, NULL, NULL, NULL, NULL, &n);
  return n;
}

/* Look for a field NAME in ARG.  Adjust the address of ARG by OFFSET bytes,
   and search in it assuming it has (class) type TYPE.
   If found, return value, else return NULL.

   Searches recursively through wrapper fields (e.g., '_parent').  */

static struct value *
ada_search_struct_field (char *name, struct value *arg, int offset,
                         struct type *type)
{
  int i;

  type = ada_check_typedef (type);
  for (i = 0; i < TYPE_NFIELDS (type); i += 1)
    {
      const char *t_field_name = TYPE_FIELD_NAME (type, i);

      if (t_field_name == NULL)
        continue;

      else if (field_name_match (t_field_name, name))
        return ada_value_primitive_field (arg, offset, i, type);

      else if (ada_is_wrapper_field (type, i))
        {
          struct value *v =     /* Do not let indent join lines here.  */
            ada_search_struct_field (name, arg,
                                     offset + TYPE_FIELD_BITPOS (type, i) / 8,
                                     TYPE_FIELD_TYPE (type, i));

          if (v != NULL)
            return v;
        }

      else if (ada_is_variant_part (type, i))
        {
	  /* PNH: Do we ever get here?  See find_struct_field.  */
          int j;
          struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type,
									i));
          int var_offset = offset + TYPE_FIELD_BITPOS (type, i) / 8;

          for (j = 0; j < TYPE_NFIELDS (field_type); j += 1)
            {
              struct value *v = ada_search_struct_field /* Force line
							   break.  */
                (name, arg,
                 var_offset + TYPE_FIELD_BITPOS (field_type, j) / 8,
                 TYPE_FIELD_TYPE (field_type, j));

              if (v != NULL)
                return v;
            }
        }
    }
  return NULL;
}

static struct value *ada_index_struct_field_1 (int *, struct value *,
					       int, struct type *);


/* Return field #INDEX in ARG, where the index is that returned by
 * find_struct_field through its INDEX_P argument.  Adjust the address
 * of ARG by OFFSET bytes, and search in it assuming it has (class) type TYPE.
 * If found, return value, else return NULL.  */

static struct value *
ada_index_struct_field (int index, struct value *arg, int offset,
			struct type *type)
{
  return ada_index_struct_field_1 (&index, arg, offset, type);
}


/* Auxiliary function for ada_index_struct_field.  Like
 * ada_index_struct_field, but takes index from *INDEX_P and modifies
 * *INDEX_P.  */

static struct value *
ada_index_struct_field_1 (int *index_p, struct value *arg, int offset,
			  struct type *type)
{
  int i;
  type = ada_check_typedef (type);

  for (i = 0; i < TYPE_NFIELDS (type); i += 1)
    {
      if (TYPE_FIELD_NAME (type, i) == NULL)
        continue;
      else if (ada_is_wrapper_field (type, i))
        {
          struct value *v =     /* Do not let indent join lines here.  */
            ada_index_struct_field_1 (index_p, arg,
				      offset + TYPE_FIELD_BITPOS (type, i) / 8,
				      TYPE_FIELD_TYPE (type, i));

          if (v != NULL)
            return v;
        }

      else if (ada_is_variant_part (type, i))
        {
	  /* PNH: Do we ever get here?  See ada_search_struct_field,
	     find_struct_field.  */
	  error (_("Cannot assign this kind of variant record"));
        }
      else if (*index_p == 0)
        return ada_value_primitive_field (arg, offset, i, type);
      else
	*index_p -= 1;
    }
  return NULL;
}

/* Given ARG, a value of type (pointer or reference to a)*
   structure/union, extract the component named NAME from the ultimate
   target structure/union and return it as a value with its
   appropriate type.

   The routine searches for NAME among all members of the structure itself
   and (recursively) among all members of any wrapper members
   (e.g., '_parent').

   If NO_ERR, then simply return NULL in case of error, rather than 
   calling error.  */

struct value *
ada_value_struct_elt (struct value *arg, char *name, int no_err)
{
  struct type *t, *t1;
  struct value *v;

  v = NULL;
  t1 = t = ada_check_typedef (value_type (arg));
  if (TYPE_CODE (t) == TYPE_CODE_REF)
    {
      t1 = TYPE_TARGET_TYPE (t);
      if (t1 == NULL)
	goto BadValue;
      t1 = ada_check_typedef (t1);
      if (TYPE_CODE (t1) == TYPE_CODE_PTR)
        {
          arg = coerce_ref (arg);
          t = t1;
        }
    }

  while (TYPE_CODE (t) == TYPE_CODE_PTR)
    {
      t1 = TYPE_TARGET_TYPE (t);
      if (t1 == NULL)
	goto BadValue;
      t1 = ada_check_typedef (t1);
      if (TYPE_CODE (t1) == TYPE_CODE_PTR)
        {
          arg = value_ind (arg);
          t = t1;
        }
      else
        break;
    }

  if (TYPE_CODE (t1) != TYPE_CODE_STRUCT && TYPE_CODE (t1) != TYPE_CODE_UNION)
    goto BadValue;

  if (t1 == t)
    v = ada_search_struct_field (name, arg, 0, t);
  else
    {
      int bit_offset, bit_size, byte_offset;
      struct type *field_type;
      CORE_ADDR address;

      if (TYPE_CODE (t) == TYPE_CODE_PTR)
	address = value_address (ada_value_ind (arg));
      else
	address = value_address (ada_coerce_ref (arg));

      t1 = ada_to_fixed_type (ada_get_base_type (t1), NULL, address, NULL, 1);
      if (find_struct_field (name, t1, 0,
                             &field_type, &byte_offset, &bit_offset,
                             &bit_size, NULL))
        {
          if (bit_size != 0)
            {
              if (TYPE_CODE (t) == TYPE_CODE_REF)
                arg = ada_coerce_ref (arg);
              else
                arg = ada_value_ind (arg);
              v = ada_value_primitive_packed_val (arg, NULL, byte_offset,
                                                  bit_offset, bit_size,
                                                  field_type);
            }
          else
            v = value_at_lazy (field_type, address + byte_offset);
        }
    }

  if (v != NULL || no_err)
    return v;
  else
    error (_("There is no member named %s."), name);

 BadValue:
  if (no_err)
    return NULL;
  else
    error (_("Attempt to extract a component of "
	     "a value that is not a record."));
}

/* Given a type TYPE, look up the type of the component of type named NAME.
   If DISPP is non-null, add its byte displacement from the beginning of a
   structure (pointed to by a value) of type TYPE to *DISPP (does not
   work for packed fields).

   Matches any field whose name has NAME as a prefix, possibly
   followed by "___".

   TYPE can be either a struct or union.  If REFOK, TYPE may also 
   be a (pointer or reference)+ to a struct or union, and the
   ultimate target type will be searched.

   Looks recursively into variant clauses and parent types.

   If NOERR is nonzero, return NULL if NAME is not suitably defined or
   TYPE is not a type of the right kind.  */

static struct type *
ada_lookup_struct_elt_type (struct type *type, char *name, int refok,
                            int noerr, int *dispp)
{
  int i;

  if (name == NULL)
    goto BadName;

  if (refok && type != NULL)
    while (1)
      {
        type = ada_check_typedef (type);
        if (TYPE_CODE (type) != TYPE_CODE_PTR
            && TYPE_CODE (type) != TYPE_CODE_REF)
          break;
        type = TYPE_TARGET_TYPE (type);
      }

  if (type == NULL
      || (TYPE_CODE (type) != TYPE_CODE_STRUCT
          && TYPE_CODE (type) != TYPE_CODE_UNION))
    {
      if (noerr)
        return NULL;
      else
        {
          target_terminal_ours ();
          gdb_flush (gdb_stdout);
	  if (type == NULL)
	    error (_("Type (null) is not a structure or union type"));
	  else
	    {
	      /* XXX: type_sprint */
	      fprintf_unfiltered (gdb_stderr, _("Type "));
	      type_print (type, "", gdb_stderr, -1);
	      error (_(" is not a structure or union type"));
	    }
        }
    }

  type = to_static_fixed_type (type);

  for (i = 0; i < TYPE_NFIELDS (type); i += 1)
    {
      const char *t_field_name = TYPE_FIELD_NAME (type, i);
      struct type *t;
      int disp;

      if (t_field_name == NULL)
        continue;

      else if (field_name_match (t_field_name, name))
        {
          if (dispp != NULL)
            *dispp += TYPE_FIELD_BITPOS (type, i) / 8;
          return ada_check_typedef (TYPE_FIELD_TYPE (type, i));
        }

      else if (ada_is_wrapper_field (type, i))
        {
          disp = 0;
          t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (type, i), name,
                                          0, 1, &disp);
          if (t != NULL)
            {
              if (dispp != NULL)
                *dispp += disp + TYPE_FIELD_BITPOS (type, i) / 8;
              return t;
            }
        }

      else if (ada_is_variant_part (type, i))
        {
          int j;
          struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type,
									i));

          for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
            {
	      /* FIXME pnh 2008/01/26: We check for a field that is
	         NOT wrapped in a struct, since the compiler sometimes
		 generates these for unchecked variant types.  Revisit
	         if the compiler changes this practice.  */
	      const char *v_field_name = TYPE_FIELD_NAME (field_type, j);
              disp = 0;
	      if (v_field_name != NULL 
		  && field_name_match (v_field_name, name))
		t = ada_check_typedef (TYPE_FIELD_TYPE (field_type, j));
	      else
		t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (field_type,
								 j),
						name, 0, 1, &disp);

              if (t != NULL)
                {
                  if (dispp != NULL)
                    *dispp += disp + TYPE_FIELD_BITPOS (type, i) / 8;
                  return t;
                }
            }
        }

    }

BadName:
  if (!noerr)
    {
      target_terminal_ours ();
      gdb_flush (gdb_stdout);
      if (name == NULL)
        {
	  /* XXX: type_sprint */
	  fprintf_unfiltered (gdb_stderr, _("Type "));
	  type_print (type, "", gdb_stderr, -1);
	  error (_(" has no component named <null>"));
	}
      else
	{
	  /* XXX: type_sprint */
	  fprintf_unfiltered (gdb_stderr, _("Type "));
	  type_print (type, "", gdb_stderr, -1);
	  error (_(" has no component named %s"), name);
	}
    }

  return NULL;
}

/* Assuming that VAR_TYPE is the type of a variant part of a record (a union),
   within a value of type OUTER_TYPE, return true iff VAR_TYPE
   represents an unchecked union (that is, the variant part of a
   record that is named in an Unchecked_Union pragma).  */

static int
is_unchecked_variant (struct type *var_type, struct type *outer_type)
{
  char *discrim_name = ada_variant_discrim_name (var_type);

  return (ada_lookup_struct_elt_type (outer_type, discrim_name, 0, 1, NULL) 
	  == NULL);
}


/* Assuming that VAR_TYPE is the type of a variant part of a record (a union),
   within a value of type OUTER_TYPE that is stored in GDB at
   OUTER_VALADDR, determine which variant clause (field number in VAR_TYPE,
   numbering from 0) is applicable.  Returns -1 if none are.  */

int
ada_which_variant_applies (struct type *var_type, struct type *outer_type,
                           const gdb_byte *outer_valaddr)
{
  int others_clause;
  int i;
  char *discrim_name = ada_variant_discrim_name (var_type);
  struct value *outer;
  struct value *discrim;
  LONGEST discrim_val;

  outer = value_from_contents_and_address (outer_type, outer_valaddr, 0);
  discrim = ada_value_struct_elt (outer, discrim_name, 1);
  if (discrim == NULL)
    return -1;
  discrim_val = value_as_long (discrim);

  others_clause = -1;
  for (i = 0; i < TYPE_NFIELDS (var_type); i += 1)
    {
      if (ada_is_others_clause (var_type, i))
        others_clause = i;
      else if (ada_in_variant (discrim_val, var_type, i))
        return i;
    }

  return others_clause;
}



                                /* Dynamic-Sized Records */

/* Strategy: The type ostensibly attached to a value with dynamic size
   (i.e., a size that is not statically recorded in the debugging
   data) does not accurately reflect the size or layout of the value.
   Our strategy is to convert these values to values with accurate,
   conventional types that are constructed on the fly.  */

/* There is a subtle and tricky problem here.  In general, we cannot
   determine the size of dynamic records without its data.  However,
   the 'struct value' data structure, which GDB uses to represent
   quantities in the inferior process (the target), requires the size
   of the type at the time of its allocation in order to reserve space
   for GDB's internal copy of the data.  That's why the
   'to_fixed_xxx_type' routines take (target) addresses as parameters,
   rather than struct value*s.

   However, GDB's internal history variables ($1, $2, etc.) are
   struct value*s containing internal copies of the data that are not, in
   general, the same as the data at their corresponding addresses in
   the target.  Fortunately, the types we give to these values are all
   conventional, fixed-size types (as per the strategy described
   above), so that we don't usually have to perform the
   'to_fixed_xxx_type' conversions to look at their values.
   Unfortunately, there is one exception: if one of the internal
   history variables is an array whose elements are unconstrained
   records, then we will need to create distinct fixed types for each
   element selected.  */

/* The upshot of all of this is that many routines take a (type, host
   address, target address) triple as arguments to represent a value.
   The host address, if non-null, is supposed to contain an internal
   copy of the relevant data; otherwise, the program is to consult the
   target at the target address.  */

/* Assuming that VAL0 represents a pointer value, the result of
   dereferencing it.  Differs from value_ind in its treatment of
   dynamic-sized types.  */

struct value *
ada_value_ind (struct value *val0)
{
  struct value *val = value_ind (val0);

  if (ada_is_tagged_type (value_type (val), 0))
    val = ada_tag_value_at_base_address (val);

  return ada_to_fixed_value (val);
}

/* The value resulting from dereferencing any "reference to"
   qualifiers on VAL0.  */

static struct value *
ada_coerce_ref (struct value *val0)
{
  if (TYPE_CODE (value_type (val0)) == TYPE_CODE_REF)
    {
      struct value *val = val0;

      val = coerce_ref (val);

      if (ada_is_tagged_type (value_type (val), 0))
	val = ada_tag_value_at_base_address (val);

      return ada_to_fixed_value (val);
    }
  else
    return val0;
}

/* Return OFF rounded upward if necessary to a multiple of
   ALIGNMENT (a power of 2).  */

static unsigned int
align_value (unsigned int off, unsigned int alignment)
{
  return (off + alignment - 1) & ~(alignment - 1);
}

/* Return the bit alignment required for field #F of template type TYPE.  */

static unsigned int
field_alignment (struct type *type, int f)
{
  const char *name = TYPE_FIELD_NAME (type, f);
  int len;
  int align_offset;

  /* The field name should never be null, unless the debugging information
     is somehow malformed.  In this case, we assume the field does not
     require any alignment.  */
  if (name == NULL)
    return 1;

  len = strlen (name);

  if (!isdigit (name[len - 1]))
    return 1;

  if (isdigit (name[len - 2]))
    align_offset = len - 2;
  else
    align_offset = len - 1;

  if (align_offset < 7 || strncmp ("___XV", name + align_offset - 6, 5) != 0)
    return TARGET_CHAR_BIT;

  return atoi (name + align_offset) * TARGET_CHAR_BIT;
}

/* Find a typedef or tag symbol named NAME.  Ignores ambiguity.  */

static struct symbol *
ada_find_any_type_symbol (const char *name)
{
  struct symbol *sym;

  sym = standard_lookup (name, get_selected_block (NULL), VAR_DOMAIN);
  if (sym != NULL && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
    return sym;

  sym = standard_lookup (name, NULL, STRUCT_DOMAIN);
  return sym;
}

/* Find a type named NAME.  Ignores ambiguity.  This routine will look
   solely for types defined by debug info, it will not search the GDB
   primitive types.  */

static struct type *
ada_find_any_type (const char *name)
{
  struct symbol *sym = ada_find_any_type_symbol (name);

  if (sym != NULL)
    return SYMBOL_TYPE (sym);

  return NULL;
}

/* Given NAME_SYM and an associated BLOCK, find a "renaming" symbol
   associated with NAME_SYM's name.  NAME_SYM may itself be a renaming
   symbol, in which case it is returned.  Otherwise, this looks for
   symbols whose name is that of NAME_SYM suffixed with  "___XR".
   Return symbol if found, and NULL otherwise.  */

struct symbol *
ada_find_renaming_symbol (struct symbol *name_sym, const struct block *block)
{
  const char *name = SYMBOL_LINKAGE_NAME (name_sym);
  struct symbol *sym;

  if (strstr (name, "___XR") != NULL)
     return name_sym;

  sym = find_old_style_renaming_symbol (name, block);

  if (sym != NULL)
    return sym;

  /* Not right yet.  FIXME pnh 7/20/2007.  */
  sym = ada_find_any_type_symbol (name);
  if (sym != NULL && strstr (SYMBOL_LINKAGE_NAME (sym), "___XR") != NULL)
    return sym;
  else
    return NULL;
}

static struct symbol *
find_old_style_renaming_symbol (const char *name, const struct block *block)
{
  const struct symbol *function_sym = block_linkage_function (block);
  char *rename;

  if (function_sym != NULL)
    {
      /* If the symbol is defined inside a function, NAME is not fully
         qualified.  This means we need to prepend the function name
         as well as adding the ``___XR'' suffix to build the name of
         the associated renaming symbol.  */
      const char *function_name = SYMBOL_LINKAGE_NAME (function_sym);
      /* Function names sometimes contain suffixes used
         for instance to qualify nested subprograms.  When building
         the XR type name, we need to make sure that this suffix is
         not included.  So do not include any suffix in the function
         name length below.  */
      int function_name_len = ada_name_prefix_len (function_name);
      const int rename_len = function_name_len + 2      /*  "__" */
        + strlen (name) + 6 /* "___XR\0" */ ;

      /* Strip the suffix if necessary.  */
      ada_remove_trailing_digits (function_name, &function_name_len);
      ada_remove_po_subprogram_suffix (function_name, &function_name_len);
      ada_remove_Xbn_suffix (function_name, &function_name_len);

      /* Library-level functions are a special case, as GNAT adds
         a ``_ada_'' prefix to the function name to avoid namespace
         pollution.  However, the renaming symbols themselves do not
         have this prefix, so we need to skip this prefix if present.  */
      if (function_name_len > 5 /* "_ada_" */
          && strstr (function_name, "_ada_") == function_name)
        {
	  function_name += 5;
	  function_name_len -= 5;
        }

      rename = (char *) alloca (rename_len * sizeof (char));
      strncpy (rename, function_name, function_name_len);
      xsnprintf (rename + function_name_len, rename_len - function_name_len,
		 "__%s___XR", name);
    }
  else
    {
      const int rename_len = strlen (name) + 6;

      rename = (char *) alloca (rename_len * sizeof (char));
      xsnprintf (rename, rename_len * sizeof (char), "%s___XR", name);
    }

  return ada_find_any_type_symbol (rename);
}

/* Because of GNAT encoding conventions, several GDB symbols may match a
   given type name.  If the type denoted by TYPE0 is to be preferred to
   that of TYPE1 for purposes of type printing, return non-zero;
   otherwise return 0.  */

int
ada_prefer_type (struct type *type0, struct type *type1)
{
  if (type1 == NULL)
    return 1;
  else if (type0 == NULL)
    return 0;
  else if (TYPE_CODE (type1) == TYPE_CODE_VOID)
    return 1;
  else if (TYPE_CODE (type0) == TYPE_CODE_VOID)
    return 0;
  else if (TYPE_NAME (type1) == NULL && TYPE_NAME (type0) != NULL)
    return 1;
  else if (ada_is_constrained_packed_array_type (type0))
    return 1;
  else if (ada_is_array_descriptor_type (type0)
           && !ada_is_array_descriptor_type (type1))
    return 1;
  else
    {
      const char *type0_name = type_name_no_tag (type0);
      const char *type1_name = type_name_no_tag (type1);

      if (type0_name != NULL && strstr (type0_name, "___XR") != NULL
	  && (type1_name == NULL || strstr (type1_name, "___XR") == NULL))
	return 1;
    }
  return 0;
}

/* The name of TYPE, which is either its TYPE_NAME, or, if that is
   null, its TYPE_TAG_NAME.  Null if TYPE is null.  */

const char *
ada_type_name (struct type *type)
{
  if (type == NULL)
    return NULL;
  else if (TYPE_NAME (type) != NULL)
    return TYPE_NAME (type);
  else
    return TYPE_TAG_NAME (type);
}

/* Search the list of "descriptive" types associated to TYPE for a type
   whose name is NAME.  */

static struct type *
find_parallel_type_by_descriptive_type (struct type *type, const char *name)
{
  struct type *result;

  /* If there no descriptive-type info, then there is no parallel type
     to be found.  */
  if (!HAVE_GNAT_AUX_INFO (type))
    return NULL;

  result = TYPE_DESCRIPTIVE_TYPE (type);
  while (result != NULL)
    {
      const char *result_name = ada_type_name (result);

      if (result_name == NULL)
        {
          warning (_("unexpected null name on descriptive type"));
          return NULL;
        }

      /* If the names match, stop.  */
      if (strcmp (result_name, name) == 0)
	break;

      /* Otherwise, look at the next item on the list, if any.  */
      if (HAVE_GNAT_AUX_INFO (result))
	result = TYPE_DESCRIPTIVE_TYPE (result);
      else
	result = NULL;
    }

  /* If we didn't find a match, see whether this is a packed array.  With
     older compilers, the descriptive type information is either absent or
     irrelevant when it comes to packed arrays so the above lookup fails.
     Fall back to using a parallel lookup by name in this case.  */
  if (result == NULL && ada_is_constrained_packed_array_type (type))
    return ada_find_any_type (name);

  return result;
}

/* Find a parallel type to TYPE with the specified NAME, using the
   descriptive type taken from the debugging information, if available,
   and otherwise using the (slower) name-based method.  */

static struct type *
ada_find_parallel_type_with_name (struct type *type, const char *name)
{
  struct type *result = NULL;

  if (HAVE_GNAT_AUX_INFO (type))
    result = find_parallel_type_by_descriptive_type (type, name);
  else
    result = ada_find_any_type (name);

  return result;
}

/* Same as above, but specify the name of the parallel type by appending
   SUFFIX to the name of TYPE.  */

struct type *
ada_find_parallel_type (struct type *type, const char *suffix)
{
  char *name;
  const char *typename = ada_type_name (type);
  int len;

  if (typename == NULL)
    return NULL;

  len = strlen (typename);

  name = (char *) alloca (len + strlen (suffix) + 1);

  strcpy (name, typename);
  strcpy (name + len, suffix);

  return ada_find_parallel_type_with_name (type, name);
}

/* If TYPE is a variable-size record type, return the corresponding template
   type describing its fields.  Otherwise, return NULL.  */

static struct type *
dynamic_template_type (struct type *type)
{
  type = ada_check_typedef (type);

  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT
      || ada_type_name (type) == NULL)
    return NULL;
  else
    {
      int len = strlen (ada_type_name (type));

      if (len > 6 && strcmp (ada_type_name (type) + len - 6, "___XVE") == 0)
        return type;
      else
        return ada_find_parallel_type (type, "___XVE");
    }
}

/* Assuming that TEMPL_TYPE is a union or struct type, returns
   non-zero iff field FIELD_NUM of TEMPL_TYPE has dynamic size.  */

static int
is_dynamic_field (struct type *templ_type, int field_num)
{
  const char *name = TYPE_FIELD_NAME (templ_type, field_num);

  return name != NULL
    && TYPE_CODE (TYPE_FIELD_TYPE (templ_type, field_num)) == TYPE_CODE_PTR
    && strstr (name, "___XVL") != NULL;
}

/* The index of the variant field of TYPE, or -1 if TYPE does not
   represent a variant record type.  */

static int
variant_field_index (struct type *type)
{
  int f;

  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT)
    return -1;

  for (f = 0; f < TYPE_NFIELDS (type); f += 1)
    {
      if (ada_is_variant_part (type, f))
        return f;
    }
  return -1;
}

/* A record type with no fields.  */

static struct type *
empty_record (struct type *template)
{
  struct type *type = alloc_type_copy (template);

  TYPE_CODE (type) = TYPE_CODE_STRUCT;
  TYPE_NFIELDS (type) = 0;
  TYPE_FIELDS (type) = NULL;
  INIT_CPLUS_SPECIFIC (type);
  TYPE_NAME (type) = "<empty>";
  TYPE_TAG_NAME (type) = NULL;
  TYPE_LENGTH (type) = 0;
  return type;
}

/* An ordinary record type (with fixed-length fields) that describes
   the value of type TYPE at VALADDR or ADDRESS (see comments at
   the beginning of this section) VAL according to GNAT conventions.
   DVAL0 should describe the (portion of a) record that contains any
   necessary discriminants.  It should be NULL if value_type (VAL) is
   an outer-level type (i.e., as opposed to a branch of a variant.)  A
   variant field (unless unchecked) is replaced by a particular branch
   of the variant.

   If not KEEP_DYNAMIC_FIELDS, then all fields whose position or
   length are not statically known are discarded.  As a consequence,
   VALADDR, ADDRESS and DVAL0 are ignored.

   NOTE: Limitations: For now, we assume that dynamic fields and
   variants occupy whole numbers of bytes.  However, they need not be
   byte-aligned.  */

struct type *
ada_template_to_fixed_record_type_1 (struct type *type,
				     const gdb_byte *valaddr,
                                     CORE_ADDR address, struct value *dval0,
                                     int keep_dynamic_fields)
{
  struct value *mark = value_mark ();
  struct value *dval;
  struct type *rtype;
  int nfields, bit_len;
  int variant_field;
  long off;
  int fld_bit_len;
  int f;

  /* Compute the number of fields in this record type that are going
     to be processed: unless keep_dynamic_fields, this includes only
     fields whose position and length are static will be processed.  */
  if (keep_dynamic_fields)
    nfields = TYPE_NFIELDS (type);
  else
    {
      nfields = 0;
      while (nfields < TYPE_NFIELDS (type)
             && !ada_is_variant_part (type, nfields)
             && !is_dynamic_field (type, nfields))
        nfields++;
    }

  rtype = alloc_type_copy (type);
  TYPE_CODE (rtype) = TYPE_CODE_STRUCT;
  INIT_CPLUS_SPECIFIC (rtype);
  TYPE_NFIELDS (rtype) = nfields;
  TYPE_FIELDS (rtype) = (struct field *)
    TYPE_ALLOC (rtype, nfields * sizeof (struct field));
  memset (TYPE_FIELDS (rtype), 0, sizeof (struct field) * nfields);
  TYPE_NAME (rtype) = ada_type_name (type);
  TYPE_TAG_NAME (rtype) = NULL;
  TYPE_FIXED_INSTANCE (rtype) = 1;

  off = 0;
  bit_len = 0;
  variant_field = -1;

  for (f = 0; f < nfields; f += 1)
    {
      off = align_value (off, field_alignment (type, f))
	+ TYPE_FIELD_BITPOS (type, f);
      SET_FIELD_BITPOS (TYPE_FIELD (rtype, f), off);
      TYPE_FIELD_BITSIZE (rtype, f) = 0;

      if (ada_is_variant_part (type, f))
        {
          variant_field = f;
          fld_bit_len = 0;
        }
      else if (is_dynamic_field (type, f))
        {
	  const gdb_byte *field_valaddr = valaddr;
	  CORE_ADDR field_address = address;
	  struct type *field_type =
	    TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, f));

          if (dval0 == NULL)
	    {
	      /* rtype's length is computed based on the run-time
		 value of discriminants.  If the discriminants are not
		 initialized, the type size may be completely bogus and
		 GDB may fail to allocate a value for it.  So check the
		 size first before creating the value.  */
	      check_size (rtype);
	      dval = value_from_contents_and_address (rtype, valaddr, address);
	    }
          else
            dval = dval0;

	  /* If the type referenced by this field is an aligner type, we need
	     to unwrap that aligner type, because its size might not be set.
	     Keeping the aligner type would cause us to compute the wrong
	     size for this field, impacting the offset of the all the fields
	     that follow this one.  */
	  if (ada_is_aligner_type (field_type))
	    {
	      long field_offset = TYPE_FIELD_BITPOS (field_type, f);

	      field_valaddr = cond_offset_host (field_valaddr, field_offset);
	      field_address = cond_offset_target (field_address, field_offset);
	      field_type = ada_aligned_type (field_type);
	    }

	  field_valaddr = cond_offset_host (field_valaddr,
					    off / TARGET_CHAR_BIT);
	  field_address = cond_offset_target (field_address,
					      off / TARGET_CHAR_BIT);

	  /* Get the fixed type of the field.  Note that, in this case,
	     we do not want to get the real type out of the tag: if
	     the current field is the parent part of a tagged record,
	     we will get the tag of the object.  Clearly wrong: the real
	     type of the parent is not the real type of the child.  We
	     would end up in an infinite loop.	*/
	  field_type = ada_get_base_type (field_type);
	  field_type = ada_to_fixed_type (field_type, field_valaddr,
					  field_address, dval, 0);
	  /* If the field size is already larger than the maximum
	     object size, then the record itself will necessarily
	     be larger than the maximum object size.  We need to make
	     this check now, because the size might be so ridiculously
	     large (due to an uninitialized variable in the inferior)
	     that it would cause an overflow when adding it to the
	     record size.  */
	  check_size (field_type);

	  TYPE_FIELD_TYPE (rtype, f) = field_type;
          TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);
	  /* The multiplication can potentially overflow.  But because
	     the field length has been size-checked just above, and
	     assuming that the maximum size is a reasonable value,
	     an overflow should not happen in practice.  So rather than
	     adding overflow recovery code to this already complex code,
	     we just assume that it's not going to happen.  */
          fld_bit_len =
            TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, f)) * TARGET_CHAR_BIT;
        }
      else
        {
	  /* Note: If this field's type is a typedef, it is important
	     to preserve the typedef layer.

	     Otherwise, we might be transforming a typedef to a fat
	     pointer (encoding a pointer to an unconstrained array),
	     into a basic fat pointer (encoding an unconstrained
	     array).  As both types are implemented using the same
	     structure, the typedef is the only clue which allows us
	     to distinguish between the two options.  Stripping it
	     would prevent us from printing this field appropriately.  */
          TYPE_FIELD_TYPE (rtype, f) = TYPE_FIELD_TYPE (type, f);
          TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);
          if (TYPE_FIELD_BITSIZE (type, f) > 0)
            fld_bit_len =
              TYPE_FIELD_BITSIZE (rtype, f) = TYPE_FIELD_BITSIZE (type, f);
          else
	    {
	      struct type *field_type = TYPE_FIELD_TYPE (type, f);

	      /* We need to be careful of typedefs when computing
		 the length of our field.  If this is a typedef,
		 get the length of the target type, not the length
		 of the typedef.  */
	      if (TYPE_CODE (field_type) == TYPE_CODE_TYPEDEF)
		field_type = ada_typedef_target_type (field_type);

              fld_bit_len =
                TYPE_LENGTH (ada_check_typedef (field_type)) * TARGET_CHAR_BIT;
	    }
        }
      if (off + fld_bit_len > bit_len)
        bit_len = off + fld_bit_len;
      off += fld_bit_len;
      TYPE_LENGTH (rtype) =
        align_value (bit_len, TARGET_CHAR_BIT) / TARGET_CHAR_BIT;
    }

  /* We handle the variant part, if any, at the end because of certain
     odd cases in which it is re-ordered so as NOT to be the last field of
     the record.  This can happen in the presence of representation
     clauses.  */
  if (variant_field >= 0)
    {
      struct type *branch_type;

      off = TYPE_FIELD_BITPOS (rtype, variant_field);

      if (dval0 == NULL)
        dval = value_from_contents_and_address (rtype, valaddr, address);
      else
        dval = dval0;

      branch_type =
        to_fixed_variant_branch_type
        (TYPE_FIELD_TYPE (type, variant_field),
         cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
         cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
      if (branch_type == NULL)
        {
          for (f = variant_field + 1; f < TYPE_NFIELDS (rtype); f += 1)
            TYPE_FIELDS (rtype)[f - 1] = TYPE_FIELDS (rtype)[f];
          TYPE_NFIELDS (rtype) -= 1;
        }
      else
        {
          TYPE_FIELD_TYPE (rtype, variant_field) = branch_type;
          TYPE_FIELD_NAME (rtype, variant_field) = "S";
          fld_bit_len =
            TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, variant_field)) *
            TARGET_CHAR_BIT;
          if (off + fld_bit_len > bit_len)
            bit_len = off + fld_bit_len;
          TYPE_LENGTH (rtype) =
            align_value (bit_len, TARGET_CHAR_BIT) / TARGET_CHAR_BIT;
        }
    }

  /* According to exp_dbug.ads, the size of TYPE for variable-size records
     should contain the alignment of that record, which should be a strictly
     positive value.  If null or negative, then something is wrong, most
     probably in the debug info.  In that case, we don't round up the size
     of the resulting type.  If this record is not part of another structure,
     the current RTYPE length might be good enough for our purposes.  */
  if (TYPE_LENGTH (type) <= 0)
    {
      if (TYPE_NAME (rtype))
	warning (_("Invalid type size for `%s' detected: %d."),
		 TYPE_NAME (rtype), TYPE_LENGTH (type));
      else
	warning (_("Invalid type size for <unnamed> detected: %d."),
		 TYPE_LENGTH (type));
    }
  else
    {
      TYPE_LENGTH (rtype) = align_value (TYPE_LENGTH (rtype),
                                         TYPE_LENGTH (type));
    }

  value_free_to_mark (mark);
  if (TYPE_LENGTH (rtype) > varsize_limit)
    error (_("record type with dynamic size is larger than varsize-limit"));
  return rtype;
}

/* As for ada_template_to_fixed_record_type_1 with KEEP_DYNAMIC_FIELDS
   of 1.  */

static struct type *
template_to_fixed_record_type (struct type *type, const gdb_byte *valaddr,
                               CORE_ADDR address, struct value *dval0)
{
  return ada_template_to_fixed_record_type_1 (type, valaddr,
                                              address, dval0, 1);
}

/* An ordinary record type in which ___XVL-convention fields and
   ___XVU- and ___XVN-convention field types in TYPE0 are replaced with
   static approximations, containing all possible fields.  Uses
   no runtime values.  Useless for use in values, but that's OK,
   since the results are used only for type determinations.   Works on both
   structs and unions.  Representation note: to save space, we memorize
   the result of this function in the TYPE_TARGET_TYPE of the
   template type.  */

static struct type *
template_to_static_fixed_type (struct type *type0)
{
  struct type *type;
  int nfields;
  int f;

  if (TYPE_TARGET_TYPE (type0) != NULL)
    return TYPE_TARGET_TYPE (type0);

  nfields = TYPE_NFIELDS (type0);
  type = type0;

  for (f = 0; f < nfields; f += 1)
    {
      struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type0, f));
      struct type *new_type;

      if (is_dynamic_field (type0, f))
        new_type = to_static_fixed_type (TYPE_TARGET_TYPE (field_type));
      else
        new_type = static_unwrap_type (field_type);
      if (type == type0 && new_type != field_type)
        {
          TYPE_TARGET_TYPE (type0) = type = alloc_type_copy (type0);
          TYPE_CODE (type) = TYPE_CODE (type0);
          INIT_CPLUS_SPECIFIC (type);
          TYPE_NFIELDS (type) = nfields;
          TYPE_FIELDS (type) = (struct field *)
            TYPE_ALLOC (type, nfields * sizeof (struct field));
          memcpy (TYPE_FIELDS (type), TYPE_FIELDS (type0),
                  sizeof (struct field) * nfields);
          TYPE_NAME (type) = ada_type_name (type0);
          TYPE_TAG_NAME (type) = NULL;
	  TYPE_FIXED_INSTANCE (type) = 1;
          TYPE_LENGTH (type) = 0;
        }
      TYPE_FIELD_TYPE (type, f) = new_type;
      TYPE_FIELD_NAME (type, f) = TYPE_FIELD_NAME (type0, f);
    }
  return type;
}

/* Given an object of type TYPE whose contents are at VALADDR and
   whose address in memory is ADDRESS, returns a revision of TYPE,
   which should be a non-dynamic-sized record, in which the variant
   part, if any, is replaced with the appropriate branch.  Looks
   for discriminant values in DVAL0, which can be NULL if the record
   contains the necessary discriminant values.  */

static struct type *
to_record_with_fixed_variant_part (struct type *type, const gdb_byte *valaddr,
                                   CORE_ADDR address, struct value *dval0)
{
  struct value *mark = value_mark ();
  struct value *dval;
  struct type *rtype;
  struct type *branch_type;
  int nfields = TYPE_NFIELDS (type);
  int variant_field = variant_field_index (type);

  if (variant_field == -1)
    return type;

  if (dval0 == NULL)
    dval = value_from_contents_and_address (type, valaddr, address);
  else
    dval = dval0;

  rtype = alloc_type_copy (type);
  TYPE_CODE (rtype) = TYPE_CODE_STRUCT;
  INIT_CPLUS_SPECIFIC (rtype);
  TYPE_NFIELDS (rtype) = nfields;
  TYPE_FIELDS (rtype) =
    (struct field *) TYPE_ALLOC (rtype, nfields * sizeof (struct field));
  memcpy (TYPE_FIELDS (rtype), TYPE_FIELDS (type),
          sizeof (struct field) * nfields);
  TYPE_NAME (rtype) = ada_type_name (type);
  TYPE_TAG_NAME (rtype) = NULL;
  TYPE_FIXED_INSTANCE (rtype) = 1;
  TYPE_LENGTH (rtype) = TYPE_LENGTH (type);

  branch_type = to_fixed_variant_branch_type
    (TYPE_FIELD_TYPE (type, variant_field),
     cond_offset_host (valaddr,
                       TYPE_FIELD_BITPOS (type, variant_field)
                       / TARGET_CHAR_BIT),
     cond_offset_target (address,
                         TYPE_FIELD_BITPOS (type, variant_field)
                         / TARGET_CHAR_BIT), dval);
  if (branch_type == NULL)
    {
      int f;

      for (f = variant_field + 1; f < nfields; f += 1)
        TYPE_FIELDS (rtype)[f - 1] = TYPE_FIELDS (rtype)[f];
      TYPE_NFIELDS (rtype) -= 1;
    }
  else
    {
      TYPE_FIELD_TYPE (rtype, variant_field) = branch_type;
      TYPE_FIELD_NAME (rtype, variant_field) = "S";
      TYPE_FIELD_BITSIZE (rtype, variant_field) = 0;
      TYPE_LENGTH (rtype) += TYPE_LENGTH (branch_type);
    }
  TYPE_LENGTH (rtype) -= TYPE_LENGTH (TYPE_FIELD_TYPE (type, variant_field));

  value_free_to_mark (mark);
  return rtype;
}

/* An ordinary record type (with fixed-length fields) that describes
   the value at (TYPE0, VALADDR, ADDRESS) [see explanation at
   beginning of this section].   Any necessary discriminants' values
   should be in DVAL, a record value; it may be NULL if the object
   at ADDR itself contains any necessary discriminant values.
   Additionally, VALADDR and ADDRESS may also be NULL if no discriminant
   values from the record are needed.  Except in the case that DVAL,
   VALADDR, and ADDRESS are all 0 or NULL, a variant field (unless
   unchecked) is replaced by a particular branch of the variant.

   NOTE: the case in which DVAL and VALADDR are NULL and ADDRESS is 0
   is questionable and may be removed.  It can arise during the
   processing of an unconstrained-array-of-record type where all the
   variant branches have exactly the same size.  This is because in
   such cases, the compiler does not bother to use the XVS convention
   when encoding the record.  I am currently dubious of this
   shortcut and suspect the compiler should be altered.  FIXME.  */

static struct type *
to_fixed_record_type (struct type *type0, const gdb_byte *valaddr,
                      CORE_ADDR address, struct value *dval)
{
  struct type *templ_type;

  if (TYPE_FIXED_INSTANCE (type0))
    return type0;

  templ_type = dynamic_template_type (type0);

  if (templ_type != NULL)
    return template_to_fixed_record_type (templ_type, valaddr, address, dval);
  else if (variant_field_index (type0) >= 0)
    {
      if (dval == NULL && valaddr == NULL && address == 0)
        return type0;
      return to_record_with_fixed_variant_part (type0, valaddr, address,
                                                dval);
    }
  else
    {
      TYPE_FIXED_INSTANCE (type0) = 1;
      return type0;
    }

}

/* An ordinary record type (with fixed-length fields) that describes
   the value at (VAR_TYPE0, VALADDR, ADDRESS), where VAR_TYPE0 is a
   union type.  Any necessary discriminants' values should be in DVAL,
   a record value.  That is, this routine selects the appropriate
   branch of the union at ADDR according to the discriminant value
   indicated in the union's type name.  Returns VAR_TYPE0 itself if
   it represents a variant subject to a pragma Unchecked_Union.  */

static struct type *
to_fixed_variant_branch_type (struct type *var_type0, const gdb_byte *valaddr,
                              CORE_ADDR address, struct value *dval)
{
  int which;
  struct type *templ_type;
  struct type *var_type;

  if (TYPE_CODE (var_type0) == TYPE_CODE_PTR)
    var_type = TYPE_TARGET_TYPE (var_type0);
  else
    var_type = var_type0;

  templ_type = ada_find_parallel_type (var_type, "___XVU");

  if (templ_type != NULL)
    var_type = templ_type;

  if (is_unchecked_variant (var_type, value_type (dval)))
      return var_type0;
  which =
    ada_which_variant_applies (var_type,
                               value_type (dval), value_contents (dval));

  if (which < 0)
    return empty_record (var_type);
  else if (is_dynamic_field (var_type, which))
    return to_fixed_record_type
      (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (var_type, which)),
       valaddr, address, dval);
  else if (variant_field_index (TYPE_FIELD_TYPE (var_type, which)) >= 0)
    return
      to_fixed_record_type
      (TYPE_FIELD_TYPE (var_type, which), valaddr, address, dval);
  else
    return TYPE_FIELD_TYPE (var_type, which);
}

/* Assuming that TYPE0 is an array type describing the type of a value
   at ADDR, and that DVAL describes a record containing any
   discriminants used in TYPE0, returns a type for the value that
   contains no dynamic components (that is, no components whose sizes
   are determined by run-time quantities).  Unless IGNORE_TOO_BIG is
   true, gives an error message if the resulting type's size is over
   varsize_limit.  */

static struct type *
to_fixed_array_type (struct type *type0, struct value *dval,
                     int ignore_too_big)
{
  struct type *index_type_desc;
  struct type *result;
  int constrained_packed_array_p;

  type0 = ada_check_typedef (type0);
  if (TYPE_FIXED_INSTANCE (type0))
    return type0;

  constrained_packed_array_p = ada_is_constrained_packed_array_type (type0);
  if (constrained_packed_array_p)
    type0 = decode_constrained_packed_array_type (type0);

  index_type_desc = ada_find_parallel_type (type0, "___XA");
  ada_fixup_array_indexes_type (index_type_desc);
  if (index_type_desc == NULL)
    {
      struct type *elt_type0 = ada_check_typedef (TYPE_TARGET_TYPE (type0));

      /* NOTE: elt_type---the fixed version of elt_type0---should never
         depend on the contents of the array in properly constructed
         debugging data.  */
      /* Create a fixed version of the array element type.
         We're not providing the address of an element here,
         and thus the actual object value cannot be inspected to do
         the conversion.  This should not be a problem, since arrays of
         unconstrained objects are not allowed.  In particular, all
         the elements of an array of a tagged type should all be of
         the same type specified in the debugging info.  No need to
         consult the object tag.  */
      struct type *elt_type = ada_to_fixed_type (elt_type0, 0, 0, dval, 1);

      /* Make sure we always create a new array type when dealing with
	 packed array types, since we're going to fix-up the array
	 type length and element bitsize a little further down.  */
      if (elt_type0 == elt_type && !constrained_packed_array_p)
        result = type0;
      else
        result = create_array_type (alloc_type_copy (type0),
                                    elt_type, TYPE_INDEX_TYPE (type0));
    }
  else
    {
      int i;
      struct type *elt_type0;

      elt_type0 = type0;
      for (i = TYPE_NFIELDS (index_type_desc); i > 0; i -= 1)
        elt_type0 = TYPE_TARGET_TYPE (elt_type0);

      /* NOTE: result---the fixed version of elt_type0---should never
         depend on the contents of the array in properly constructed
         debugging data.  */
      /* Create a fixed version of the array element type.
         We're not providing the address of an element here,
         and thus the actual object value cannot be inspected to do
         the conversion.  This should not be a problem, since arrays of
         unconstrained objects are not allowed.  In particular, all
         the elements of an array of a tagged type should all be of
         the same type specified in the debugging info.  No need to
         consult the object tag.  */
      result =
        ada_to_fixed_type (ada_check_typedef (elt_type0), 0, 0, dval, 1);

      elt_type0 = type0;
      for (i = TYPE_NFIELDS (index_type_desc) - 1; i >= 0; i -= 1)
        {
          struct type *range_type =
            to_fixed_range_type (TYPE_FIELD_TYPE (index_type_desc, i), dval);

          result = create_array_type (alloc_type_copy (elt_type0),
                                      result, range_type);
	  elt_type0 = TYPE_TARGET_TYPE (elt_type0);
        }
      if (!ignore_too_big && TYPE_LENGTH (result) > varsize_limit)
        error (_("array type with dynamic size is larger than varsize-limit"));
    }

  /* We want to preserve the type name.  This can be useful when
     trying to get the type name of a value that has already been
     printed (for instance, if the user did "print VAR; whatis $".  */
  TYPE_NAME (result) = TYPE_NAME (type0);

  if (constrained_packed_array_p)
    {
      /* So far, the resulting type has been created as if the original
	 type was a regular (non-packed) array type.  As a result, the
	 bitsize of the array elements needs to be set again, and the array
	 length needs to be recomputed based on that bitsize.  */
      int len = TYPE_LENGTH (result) / TYPE_LENGTH (TYPE_TARGET_TYPE (result));
      int elt_bitsize = TYPE_FIELD_BITSIZE (type0, 0);

      TYPE_FIELD_BITSIZE (result, 0) = TYPE_FIELD_BITSIZE (type0, 0);
      TYPE_LENGTH (result) = len * elt_bitsize / HOST_CHAR_BIT;
      if (TYPE_LENGTH (result) * HOST_CHAR_BIT < len * elt_bitsize)
        TYPE_LENGTH (result)++;
    }

  TYPE_FIXED_INSTANCE (result) = 1;
  return result;
}


/* A standard type (containing no dynamically sized components)
   corresponding to TYPE for the value (TYPE, VALADDR, ADDRESS)
   DVAL describes a record containing any discriminants used in TYPE0,
   and may be NULL if there are none, or if the object of type TYPE at
   ADDRESS or in VALADDR contains these discriminants.
   
   If CHECK_TAG is not null, in the case of tagged types, this function
   attempts to locate the object's tag and use it to compute the actual
   type.  However, when ADDRESS is null, we cannot use it to determine the
   location of the tag, and therefore compute the tagged type's actual type.
   So we return the tagged type without consulting the tag.  */
   
static struct type *
ada_to_fixed_type_1 (struct type *type, const gdb_byte *valaddr,
                   CORE_ADDR address, struct value *dval, int check_tag)
{
  type = ada_check_typedef (type);
  switch (TYPE_CODE (type))
    {
    default:
      return type;
    case TYPE_CODE_STRUCT:
      {
        struct type *static_type = to_static_fixed_type (type);
        struct type *fixed_record_type =
          to_fixed_record_type (type, valaddr, address, NULL);

        /* If STATIC_TYPE is a tagged type and we know the object's address,
           then we can determine its tag, and compute the object's actual
           type from there.  Note that we have to use the fixed record
           type (the parent part of the record may have dynamic fields
           and the way the location of _tag is expressed may depend on
           them).  */

        if (check_tag && address != 0 && ada_is_tagged_type (static_type, 0))
          {
	    struct value *tag =
	      value_tag_from_contents_and_address
	      (fixed_record_type,
	       valaddr,
	       address);
	    struct type *real_type = type_from_tag (tag);
	    struct value *obj =
	      value_from_contents_and_address (fixed_record_type,
					       valaddr,
					       address);
            if (real_type != NULL)
              return to_fixed_record_type
		(real_type, NULL,
		 value_address (ada_tag_value_at_base_address (obj)), NULL);
          }

        /* Check to see if there is a parallel ___XVZ variable.
           If there is, then it provides the actual size of our type.  */
        else if (ada_type_name (fixed_record_type) != NULL)
          {
            const char *name = ada_type_name (fixed_record_type);
            char *xvz_name = alloca (strlen (name) + 7 /* "___XVZ\0" */);
            int xvz_found = 0;
            LONGEST size;

            xsnprintf (xvz_name, strlen (name) + 7, "%s___XVZ", name);
            size = get_int_var_value (xvz_name, &xvz_found);
            if (xvz_found && TYPE_LENGTH (fixed_record_type) != size)
              {
                fixed_record_type = copy_type (fixed_record_type);
                TYPE_LENGTH (fixed_record_type) = size;

                /* The FIXED_RECORD_TYPE may have be a stub.  We have
                   observed this when the debugging info is STABS, and
                   apparently it is something that is hard to fix.

                   In practice, we don't need the actual type definition
                   at all, because the presence of the XVZ variable allows us
                   to assume that there must be a XVS type as well, which we
                   should be able to use later, when we need the actual type
                   definition.

                   In the meantime, pretend that the "fixed" type we are
                   returning is NOT a stub, because this can cause trouble
                   when using this type to create new types targeting it.
                   Indeed, the associated creation routines often check
                   whether the target type is a stub and will try to replace
                   it, thus using a type with the wrong size.  This, in turn,
                   might cause the new type to have the wrong size too.
                   Consider the case of an array, for instance, where the size
                   of the array is computed from the number of elements in
                   our array multiplied by the size of its element.  */
                TYPE_STUB (fixed_record_type) = 0;
              }
          }
        return fixed_record_type;
      }
    case TYPE_CODE_ARRAY:
      return to_fixed_array_type (type, dval, 1);
    case TYPE_CODE_UNION:
      if (dval == NULL)
        return type;
      else
        return to_fixed_variant_branch_type (type, valaddr, address, dval);
    }
}

/* The same as ada_to_fixed_type_1, except that it preserves the type
   if it is a TYPE_CODE_TYPEDEF of a type that is already fixed.

   The typedef layer needs be preserved in order to differentiate between
   arrays and array pointers when both types are implemented using the same
   fat pointer.  In the array pointer case, the pointer is encoded as
   a typedef of the pointer type.  For instance, considering:

	  type String_Access is access String;
	  S1 : String_Access := null;

   To the debugger, S1 is defined as a typedef of type String.  But
   to the user, it is a pointer.  So if the user tries to print S1,
   we should not dereference the array, but print the array address
   instead.

   If we didn't preserve the typedef layer, we would lose the fact that
   the type is to be presented as a pointer (needs de-reference before
   being printed).  And we would also use the source-level type name.  */

struct type *
ada_to_fixed_type (struct type *type, const gdb_byte *valaddr,
                   CORE_ADDR address, struct value *dval, int check_tag)

{
  struct type *fixed_type =
    ada_to_fixed_type_1 (type, valaddr, address, dval, check_tag);

  /*  If TYPE is a typedef and its target type is the same as the FIXED_TYPE,
      then preserve the typedef layer.

      Implementation note: We can only check the main-type portion of
      the TYPE and FIXED_TYPE, because eliminating the typedef layer
      from TYPE now returns a type that has the same instance flags
      as TYPE.  For instance, if TYPE is a "typedef const", and its
      target type is a "struct", then the typedef elimination will return
      a "const" version of the target type.  See check_typedef for more
      details about how the typedef layer elimination is done.

      brobecker/2010-11-19: It seems to me that the only case where it is
      useful to preserve the typedef layer is when dealing with fat pointers.
      Perhaps, we could add a check for that and preserve the typedef layer
      only in that situation.  But this seems unecessary so far, probably
      because we call check_typedef/ada_check_typedef pretty much everywhere.
      */
  if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF
      && (TYPE_MAIN_TYPE (ada_typedef_target_type (type))
	  == TYPE_MAIN_TYPE (fixed_type)))
    return type;

  return fixed_type;
}

/* A standard (static-sized) type corresponding as well as possible to
   TYPE0, but based on no runtime data.  */

static struct type *
to_static_fixed_type (struct type *type0)
{
  struct type *type;

  if (type0 == NULL)
    return NULL;

  if (TYPE_FIXED_INSTANCE (type0))
    return type0;

  type0 = ada_check_typedef (type0);

  switch (TYPE_CODE (type0))
    {
    default:
      return type0;
    case TYPE_CODE_STRUCT:
      type = dynamic_template_type (type0);
      if (type != NULL)
        return template_to_static_fixed_type (type);
      else
        return template_to_static_fixed_type (type0);
    case TYPE_CODE_UNION:
      type = ada_find_parallel_type (type0, "___XVU");
      if (type != NULL)
        return template_to_static_fixed_type (type);
      else
        return template_to_static_fixed_type (type0);
    }
}

/* A static approximation of TYPE with all type wrappers removed.  */

static struct type *
static_unwrap_type (struct type *type)
{
  if (ada_is_aligner_type (type))
    {
      struct type *type1 = TYPE_FIELD_TYPE (ada_check_typedef (type), 0);
      if (ada_type_name (type1) == NULL)
        TYPE_NAME (type1) = ada_type_name (type);

      return static_unwrap_type (type1);
    }
  else
    {
      struct type *raw_real_type = ada_get_base_type (type);

      if (raw_real_type == type)
        return type;
      else
        return to_static_fixed_type (raw_real_type);
    }
}

/* In some cases, incomplete and private types require
   cross-references that are not resolved as records (for example,
      type Foo;
      type FooP is access Foo;
      V: FooP;
      type Foo is array ...;
   ).  In these cases, since there is no mechanism for producing
   cross-references to such types, we instead substitute for FooP a
   stub enumeration type that is nowhere resolved, and whose tag is
   the name of the actual type.  Call these types "non-record stubs".  */

/* A type equivalent to TYPE that is not a non-record stub, if one
   exists, otherwise TYPE.  */

struct type *
ada_check_typedef (struct type *type)
{
  if (type == NULL)
    return NULL;

  /* If our type is a typedef type of a fat pointer, then we're done.
     We don't want to strip the TYPE_CODE_TYPDEF layer, because this is
     what allows us to distinguish between fat pointers that represent
     array types, and fat pointers that represent array access types
     (in both cases, the compiler implements them as fat pointers).  */
  if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF
      && is_thick_pntr (ada_typedef_target_type (type)))
    return type;

  CHECK_TYPEDEF (type);
  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_ENUM
      || !TYPE_STUB (type)
      || TYPE_TAG_NAME (type) == NULL)
    return type;
  else
    {
      const char *name = TYPE_TAG_NAME (type);
      struct type *type1 = ada_find_any_type (name);

      if (type1 == NULL)
        return type;

      /* TYPE1 might itself be a TYPE_CODE_TYPEDEF (this can happen with
	 stubs pointing to arrays, as we don't create symbols for array
	 types, only for the typedef-to-array types).  If that's the case,
	 strip the typedef layer.  */
      if (TYPE_CODE (type1) == TYPE_CODE_TYPEDEF)
	type1 = ada_check_typedef (type1);

      return type1;
    }
}

/* A value representing the data at VALADDR/ADDRESS as described by
   type TYPE0, but with a standard (static-sized) type that correctly
   describes it.  If VAL0 is not NULL and TYPE0 already is a standard
   type, then return VAL0 [this feature is simply to avoid redundant
   creation of struct values].  */

static struct value *
ada_to_fixed_value_create (struct type *type0, CORE_ADDR address,
                           struct value *val0)
{
  struct type *type = ada_to_fixed_type (type0, 0, address, NULL, 1);

  if (type == type0 && val0 != NULL)
    return val0;
  else
    return value_from_contents_and_address (type, 0, address);
}

/* A value representing VAL, but with a standard (static-sized) type
   that correctly describes it.  Does not necessarily create a new
   value.  */

struct value *
ada_to_fixed_value (struct value *val)
{
  val = unwrap_value (val);
  val = ada_to_fixed_value_create (value_type (val),
				      value_address (val),
				      val);
  return val;
}


/* Attributes */

/* Table mapping attribute numbers to names.
   NOTE: Keep up to date with enum ada_attribute definition in ada-lang.h.  */

static const char *attribute_names[] = {
  "<?>",

  "first",
  "last",
  "length",
  "image",
  "max",
  "min",
  "modulus",
  "pos",
  "size",
  "tag",
  "val",
  0
};

const char *
ada_attribute_name (enum exp_opcode n)
{
  if (n >= OP_ATR_FIRST && n <= (int) OP_ATR_VAL)
    return attribute_names[n - OP_ATR_FIRST + 1];
  else
    return attribute_names[0];
}

/* Evaluate the 'POS attribute applied to ARG.  */

static LONGEST
pos_atr (struct value *arg)
{
  struct value *val = coerce_ref (arg);
  struct type *type = value_type (val);

  if (!discrete_type_p (type))
    error (_("'POS only defined on discrete types"));

  if (TYPE_CODE (type) == TYPE_CODE_ENUM)
    {
      int i;
      LONGEST v = value_as_long (val);

      for (i = 0; i < TYPE_NFIELDS (type); i += 1)
        {
          if (v == TYPE_FIELD_ENUMVAL (type, i))
            return i;
        }
      error (_("enumeration value is invalid: can't find 'POS"));
    }
  else
    return value_as_long (val);
}

static struct value *
value_pos_atr (struct type *type, struct value *arg)
{
  return value_from_longest (type, pos_atr (arg));
}

/* Evaluate the TYPE'VAL attribute applied to ARG.  */

static struct value *
value_val_atr (struct type *type, struct value *arg)
{
  if (!discrete_type_p (type))
    error (_("'VAL only defined on discrete types"));
  if (!integer_type_p (value_type (arg)))
    error (_("'VAL requires integral argument"));

  if (TYPE_CODE (type) == TYPE_CODE_ENUM)
    {
      long pos = value_as_long (arg);

      if (pos < 0 || pos >= TYPE_NFIELDS (type))
        error (_("argument to 'VAL out of range"));
      return value_from_longest (type, TYPE_FIELD_ENUMVAL (type, pos));
    }
  else
    return value_from_longest (type, value_as_long (arg));
}


                                /* Evaluation */

/* True if TYPE appears to be an Ada character type.
   [At the moment, this is true only for Character and Wide_Character;
   It is a heuristic test that could stand improvement].  */

int
ada_is_character_type (struct type *type)
{
  const char *name;

  /* If the type code says it's a character, then assume it really is,
     and don't check any further.  */
  if (TYPE_CODE (type) == TYPE_CODE_CHAR)
    return 1;
  
  /* Otherwise, assume it's a character type iff it is a discrete type
     with a known character type name.  */
  name = ada_type_name (type);
  return (name != NULL
          && (TYPE_CODE (type) == TYPE_CODE_INT
              || TYPE_CODE (type) == TYPE_CODE_RANGE)
          && (strcmp (name, "character") == 0
              || strcmp (name, "wide_character") == 0
              || strcmp (name, "wide_wide_character") == 0
              || strcmp (name, "unsigned char") == 0));
}

/* True if TYPE appears to be an Ada string type.  */

int
ada_is_string_type (struct type *type)
{
  type = ada_check_typedef (type);
  if (type != NULL
      && TYPE_CODE (type) != TYPE_CODE_PTR
      && (ada_is_simple_array_type (type)
          || ada_is_array_descriptor_type (type))
      && ada_array_arity (type) == 1)
    {
      struct type *elttype = ada_array_element_type (type, 1);

      return ada_is_character_type (elttype);
    }
  else
    return 0;
}

/* The compiler sometimes provides a parallel XVS type for a given
   PAD type.  Normally, it is safe to follow the PAD type directly,
   but older versions of the compiler have a bug that causes the offset
   of its "F" field to be wrong.  Following that field in that case
   would lead to incorrect results, but this can be worked around
   by ignoring the PAD type and using the associated XVS type instead.

   Set to True if the debugger should trust the contents of PAD types.
   Otherwise, ignore the PAD type if there is a parallel XVS type.  */
static int trust_pad_over_xvs = 1;

/* True if TYPE is a struct type introduced by the compiler to force the
   alignment of a value.  Such types have a single field with a
   distinctive name.  */

int
ada_is_aligner_type (struct type *type)
{
  type = ada_check_typedef (type);

  if (!trust_pad_over_xvs && ada_find_parallel_type (type, "___XVS") != NULL)
    return 0;

  return (TYPE_CODE (type) == TYPE_CODE_STRUCT
          && TYPE_NFIELDS (type) == 1
          && strcmp (TYPE_FIELD_NAME (type, 0), "F") == 0);
}

/* If there is an ___XVS-convention type parallel to SUBTYPE, return
   the parallel type.  */

struct type *
ada_get_base_type (struct type *raw_type)
{
  struct type *real_type_namer;
  struct type *raw_real_type;

  if (raw_type == NULL || TYPE_CODE (raw_type) != TYPE_CODE_STRUCT)
    return raw_type;

  if (ada_is_aligner_type (raw_type))
    /* The encoding specifies that we should always use the aligner type.
       So, even if this aligner type has an associated XVS type, we should
       simply ignore it.

       According to the compiler gurus, an XVS type parallel to an aligner
       type may exist because of a stabs limitation.  In stabs, aligner
       types are empty because the field has a variable-sized type, and
       thus cannot actually be used as an aligner type.  As a result,
       we need the associated parallel XVS type to decode the type.
       Since the policy in the compiler is to not change the internal
       representation based on the debugging info format, we sometimes
       end up having a redundant XVS type parallel to the aligner type.  */
    return raw_type;

  real_type_namer = ada_find_parallel_type (raw_type, "___XVS");
  if (real_type_namer == NULL
      || TYPE_CODE (real_type_namer) != TYPE_CODE_STRUCT
      || TYPE_NFIELDS (real_type_namer) != 1)
    return raw_type;

  if (TYPE_CODE (TYPE_FIELD_TYPE (real_type_namer, 0)) != TYPE_CODE_REF)
    {
      /* This is an older encoding form where the base type needs to be
	 looked up by name.  We prefer the newer enconding because it is
	 more efficient.  */
      raw_real_type = ada_find_any_type (TYPE_FIELD_NAME (real_type_namer, 0));
      if (raw_real_type == NULL)
	return raw_type;
      else
	return raw_real_type;
    }

  /* The field in our XVS type is a reference to the base type.  */
  return TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (real_type_namer, 0));
}

/* The type of value designated by TYPE, with all aligners removed.  */

struct type *
ada_aligned_type (struct type *type)
{
  if (ada_is_aligner_type (type))
    return ada_aligned_type (TYPE_FIELD_TYPE (type, 0));
  else
    return ada_get_base_type (type);
}


/* The address of the aligned value in an object at address VALADDR
   having type TYPE.  Assumes ada_is_aligner_type (TYPE).  */

const gdb_byte *
ada_aligned_value_addr (struct type *type, const gdb_byte *valaddr)
{
  if (ada_is_aligner_type (type))
    return ada_aligned_value_addr (TYPE_FIELD_TYPE (type, 0),
                                   valaddr +
                                   TYPE_FIELD_BITPOS (type,
                                                      0) / TARGET_CHAR_BIT);
  else
    return valaddr;
}



/* The printed representation of an enumeration literal with encoded
   name NAME.  The value is good to the next call of ada_enum_name.  */
const char *
ada_enum_name (const char *name)
{
  static char *result;
  static size_t result_len = 0;
  char *tmp;

  /* First, unqualify the enumeration name:
     1. Search for the last '.' character.  If we find one, then skip
     all the preceding characters, the unqualified name starts
     right after that dot.
     2. Otherwise, we may be debugging on a target where the compiler
     translates dots into "__".  Search forward for double underscores,
     but stop searching when we hit an overloading suffix, which is
     of the form "__" followed by digits.  */

  tmp = strrchr (name, '.');
  if (tmp != NULL)
    name = tmp + 1;
  else
    {
      while ((tmp = strstr (name, "__")) != NULL)
        {
          if (isdigit (tmp[2]))
            break;
          else
            name = tmp + 2;
        }
    }

  if (name[0] == 'Q')
    {
      int v;

      if (name[1] == 'U' || name[1] == 'W')
        {
          if (sscanf (name + 2, "%x", &v) != 1)
            return name;
        }
      else
        return name;

      GROW_VECT (result, result_len, 16);
      if (isascii (v) && isprint (v))
        xsnprintf (result, result_len, "'%c'", v);
      else if (name[1] == 'U')
        xsnprintf (result, result_len, "[\"%02x\"]", v);
      else
        xsnprintf (result, result_len, "[\"%04x\"]", v);

      return result;
    }
  else
    {
      tmp = strstr (name, "__");
      if (tmp == NULL)
	tmp = strstr (name, "$");
      if (tmp != NULL)
        {
          GROW_VECT (result, result_len, tmp - name + 1);
          strncpy (result, name, tmp - name);
          result[tmp - name] = '\0';
          return result;
        }

      return name;
    }
}

/* Evaluate the subexpression of EXP starting at *POS as for
   evaluate_type, updating *POS to point just past the evaluated
   expression.  */

static struct value *
evaluate_subexp_type (struct expression *exp, int *pos)
{
  return evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
}

/* If VAL is wrapped in an aligner or subtype wrapper, return the
   value it wraps.  */

static struct value *
unwrap_value (struct value *val)
{
  struct type *type = ada_check_typedef (value_type (val));

  if (ada_is_aligner_type (type))
    {
      struct value *v = ada_value_struct_elt (val, "F", 0);
      struct type *val_type = ada_check_typedef (value_type (v));

      if (ada_type_name (val_type) == NULL)
        TYPE_NAME (val_type) = ada_type_name (type);

      return unwrap_value (v);
    }
  else
    {
      struct type *raw_real_type =
        ada_check_typedef (ada_get_base_type (type));

      /* If there is no parallel XVS or XVE type, then the value is
	 already unwrapped.  Return it without further modification.  */
      if ((type == raw_real_type)
	  && ada_find_parallel_type (type, "___XVE") == NULL)
	return val;

      return
        coerce_unspec_val_to_type
        (val, ada_to_fixed_type (raw_real_type, 0,
                                 value_address (val),
                                 NULL, 1));
    }
}

static struct value *
cast_to_fixed (struct type *type, struct value *arg)
{
  LONGEST val;

  if (type == value_type (arg))
    return arg;
  else if (ada_is_fixed_point_type (value_type (arg)))
    val = ada_float_to_fixed (type,
                              ada_fixed_to_float (value_type (arg),
                                                  value_as_long (arg)));
  else
    {
      DOUBLEST argd = value_as_double (arg);

      val = ada_float_to_fixed (type, argd);
    }

  return value_from_longest (type, val);
}

static struct value *
cast_from_fixed (struct type *type, struct value *arg)
{
  DOUBLEST val = ada_fixed_to_float (value_type (arg),
                                     value_as_long (arg));

  return value_from_double (type, val);
}

/* Given two array types T1 and T2, return nonzero iff both arrays
   contain the same number of elements.  */

static int
ada_same_array_size_p (struct type *t1, struct type *t2)
{
  LONGEST lo1, hi1, lo2, hi2;

  /* Get the array bounds in order to verify that the size of
     the two arrays match.  */
  if (!get_array_bounds (t1, &lo1, &hi1)
      || !get_array_bounds (t2, &lo2, &hi2))
    error (_("unable to determine array bounds"));

  /* To make things easier for size comparison, normalize a bit
     the case of empty arrays by making sure that the difference
     between upper bound and lower bound is always -1.  */
  if (lo1 > hi1)
    hi1 = lo1 - 1;
  if (lo2 > hi2)
    hi2 = lo2 - 1;

  return (hi1 - lo1 == hi2 - lo2);
}

/* Assuming that VAL is an array of integrals, and TYPE represents
   an array with the same number of elements, but with wider integral
   elements, return an array "casted" to TYPE.  In practice, this
   means that the returned array is built by casting each element
   of the original array into TYPE's (wider) element type.  */

static struct value *
ada_promote_array_of_integrals (struct type *type, struct value *val)
{
  struct type *elt_type = TYPE_TARGET_TYPE (type);
  LONGEST lo, hi;
  struct value *res;
  LONGEST i;

  /* Verify that both val and type are arrays of scalars, and
     that the size of val's elements is smaller than the size
     of type's element.  */
  gdb_assert (TYPE_CODE (type) == TYPE_CODE_ARRAY);
  gdb_assert (is_integral_type (TYPE_TARGET_TYPE (type)));
  gdb_assert (TYPE_CODE (value_type (val)) == TYPE_CODE_ARRAY);
  gdb_assert (is_integral_type (TYPE_TARGET_TYPE (value_type (val))));
  gdb_assert (TYPE_LENGTH (TYPE_TARGET_TYPE (type))
	      > TYPE_LENGTH (TYPE_TARGET_TYPE (value_type (val))));

  if (!get_array_bounds (type, &lo, &hi))
    error (_("unable to determine array bounds"));

  res = allocate_value (type);

  /* Promote each array element.  */
  for (i = 0; i < hi - lo + 1; i++)
    {
      struct value *elt = value_cast (elt_type, value_subscript (val, lo + i));

      memcpy (value_contents_writeable (res) + (i * TYPE_LENGTH (elt_type)),
	      value_contents_all (elt), TYPE_LENGTH (elt_type));
    }

  return res;
}

/* Coerce VAL as necessary for assignment to an lval of type TYPE, and
   return the converted value.  */

static struct value *
coerce_for_assign (struct type *type, struct value *val)
{
  struct type *type2 = value_type (val);

  if (type == type2)
    return val;

  type2 = ada_check_typedef (type2);
  type = ada_check_typedef (type);

  if (TYPE_CODE (type2) == TYPE_CODE_PTR
      && TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      val = ada_value_ind (val);
      type2 = value_type (val);
    }

  if (TYPE_CODE (type2) == TYPE_CODE_ARRAY
      && TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      if (!ada_same_array_size_p (type, type2))
	error (_("cannot assign arrays of different length"));

      if (is_integral_type (TYPE_TARGET_TYPE (type))
	  && is_integral_type (TYPE_TARGET_TYPE (type2))
	  && TYPE_LENGTH (TYPE_TARGET_TYPE (type2))
	       < TYPE_LENGTH (TYPE_TARGET_TYPE (type)))
	{
	  /* Allow implicit promotion of the array elements to
	     a wider type.  */
	  return ada_promote_array_of_integrals (type, val);
	}

      if (TYPE_LENGTH (TYPE_TARGET_TYPE (type2))
          != TYPE_LENGTH (TYPE_TARGET_TYPE (type)))
        error (_("Incompatible types in assignment"));
      deprecated_set_value_type (val, type);
    }
  return val;
}

static struct value *
ada_value_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)
{
  struct value *val;
  struct type *type1, *type2;
  LONGEST v, v1, v2;

  arg1 = coerce_ref (arg1);
  arg2 = coerce_ref (arg2);
  type1 = get_base_type (ada_check_typedef (value_type (arg1)));
  type2 = get_base_type (ada_check_typedef (value_type (arg2)));

  if (TYPE_CODE (type1) != TYPE_CODE_INT
      || TYPE_CODE (type2) != TYPE_CODE_INT)
    return value_binop (arg1, arg2, op);

  switch (op)
    {
    case BINOP_MOD:
    case BINOP_DIV:
    case BINOP_REM:
      break;
    default:
      return value_binop (arg1, arg2, op);
    }

  v2 = value_as_long (arg2);
  if (v2 == 0)
    error (_("second operand of %s must not be zero."), op_string (op));

  if (TYPE_UNSIGNED (type1) || op == BINOP_MOD)
    return value_binop (arg1, arg2, op);

  v1 = value_as_long (arg1);
  switch (op)
    {
    case BINOP_DIV:
      v = v1 / v2;
      if (!TRUNCATION_TOWARDS_ZERO && v1 * (v1 % v2) < 0)
        v += v > 0 ? -1 : 1;
      break;
    case BINOP_REM:
      v = v1 % v2;
      if (v * v1 < 0)
        v -= v2;
      break;
    default:
      /* Should not reach this point.  */
      v = 0;
    }

  val = allocate_value (type1);
  store_unsigned_integer (value_contents_raw (val),
                          TYPE_LENGTH (value_type (val)),
			  gdbarch_byte_order (get_type_arch (type1)), v);
  return val;
}

static int
ada_value_equal (struct value *arg1, struct value *arg2)
{
  if (ada_is_direct_array_type (value_type (arg1))
      || ada_is_direct_array_type (value_type (arg2)))
    {
      /* Automatically dereference any array reference before
         we attempt to perform the comparison.  */
      arg1 = ada_coerce_ref (arg1);
      arg2 = ada_coerce_ref (arg2);
      
      arg1 = ada_coerce_to_simple_array (arg1);
      arg2 = ada_coerce_to_simple_array (arg2);
      if (TYPE_CODE (value_type (arg1)) != TYPE_CODE_ARRAY
          || TYPE_CODE (value_type (arg2)) != TYPE_CODE_ARRAY)
        error (_("Attempt to compare array with non-array"));
      /* FIXME: The following works only for types whose
         representations use all bits (no padding or undefined bits)
         and do not have user-defined equality.  */
      return
        TYPE_LENGTH (value_type (arg1)) == TYPE_LENGTH (value_type (arg2))
        && memcmp (value_contents (arg1), value_contents (arg2),
                   TYPE_LENGTH (value_type (arg1))) == 0;
    }
  return value_equal (arg1, arg2);
}

/* Total number of component associations in the aggregate starting at
   index PC in EXP.  Assumes that index PC is the start of an
   OP_AGGREGATE.  */

static int
num_component_specs (struct expression *exp, int pc)
{
  int n, m, i;

  m = exp->elts[pc + 1].longconst;
  pc += 3;
  n = 0;
  for (i = 0; i < m; i += 1)
    {
      switch (exp->elts[pc].opcode) 
	{
	default:
	  n += 1;
	  break;
	case OP_CHOICES:
	  n += exp->elts[pc + 1].longconst;
	  break;
	}
      ada_evaluate_subexp (NULL, exp, &pc, EVAL_SKIP);
    }
  return n;
}

/* Assign the result of evaluating EXP starting at *POS to the INDEXth 
   component of LHS (a simple array or a record), updating *POS past
   the expression, assuming that LHS is contained in CONTAINER.  Does
   not modify the inferior's memory, nor does it modify LHS (unless
   LHS == CONTAINER).  */

static void
assign_component (struct value *container, struct value *lhs, LONGEST index,
		  struct expression *exp, int *pos)
{
  struct value *mark = value_mark ();
  struct value *elt;

  if (TYPE_CODE (value_type (lhs)) == TYPE_CODE_ARRAY)
    {
      struct type *index_type = builtin_type (exp->gdbarch)->builtin_int;
      struct value *index_val = value_from_longest (index_type, index);

      elt = unwrap_value (ada_value_subscript (lhs, 1, &index_val));
    }
  else
    {
      elt = ada_index_struct_field (index, lhs, 0, value_type (lhs));
      elt = ada_to_fixed_value (elt);
    }

  if (exp->elts[*pos].opcode == OP_AGGREGATE)
    assign_aggregate (container, elt, exp, pos, EVAL_NORMAL);
  else
    value_assign_to_component (container, elt, 
			       ada_evaluate_subexp (NULL, exp, pos, 
						    EVAL_NORMAL));

  value_free_to_mark (mark);
}

/* Assuming that LHS represents an lvalue having a record or array
   type, and EXP->ELTS[*POS] is an OP_AGGREGATE, evaluate an assignment
   of that aggregate's value to LHS, advancing *POS past the
   aggregate.  NOSIDE is as for evaluate_subexp.  CONTAINER is an
   lvalue containing LHS (possibly LHS itself).  Does not modify
   the inferior's memory, nor does it modify the contents of 
   LHS (unless == CONTAINER).  Returns the modified CONTAINER.  */

static struct value *
assign_aggregate (struct value *container, 
		  struct value *lhs, struct expression *exp, 
		  int *pos, enum noside noside)
{
  struct type *lhs_type;
  int n = exp->elts[*pos+1].longconst;
  LONGEST low_index, high_index;
  int num_specs;
  LONGEST *indices;
  int max_indices, num_indices;
  int i;

  *pos += 3;
  if (noside != EVAL_NORMAL)
    {
      for (i = 0; i < n; i += 1)
	ada_evaluate_subexp (NULL, exp, pos, noside);
      return container;
    }

  container = ada_coerce_ref (container);
  if (ada_is_direct_array_type (value_type (container)))
    container = ada_coerce_to_simple_array (container);
  lhs = ada_coerce_ref (lhs);
  if (!deprecated_value_modifiable (lhs))
    error (_("Left operand of assignment is not a modifiable lvalue."));

  lhs_type = value_type (lhs);
  if (ada_is_direct_array_type (lhs_type))
    {
      lhs = ada_coerce_to_simple_array (lhs);
      lhs_type = value_type (lhs);
      low_index = TYPE_ARRAY_LOWER_BOUND_VALUE (lhs_type);
      high_index = TYPE_ARRAY_UPPER_BOUND_VALUE (lhs_type);
    }
  else if (TYPE_CODE (lhs_type) == TYPE_CODE_STRUCT)
    {
      low_index = 0;
      high_index = num_visible_fields (lhs_type) - 1;
    }
  else
    error (_("Left-hand side must be array or record."));

  num_specs = num_component_specs (exp, *pos - 3);
  max_indices = 4 * num_specs + 4;
  indices = alloca (max_indices * sizeof (indices[0]));
  indices[0] = indices[1] = low_index - 1;
  indices[2] = indices[3] = high_index + 1;
  num_indices = 4;

  for (i = 0; i < n; i += 1)
    {
      switch (exp->elts[*pos].opcode)
	{
	  case OP_CHOICES:
	    aggregate_assign_from_choices (container, lhs, exp, pos, indices, 
					   &num_indices, max_indices,
					   low_index, high_index);
	    break;
	  case OP_POSITIONAL:
	    aggregate_assign_positional (container, lhs, exp, pos, indices,
					 &num_indices, max_indices,
					 low_index, high_index);
	    break;
	  case OP_OTHERS:
	    if (i != n-1)
	      error (_("Misplaced 'others' clause"));
	    aggregate_assign_others (container, lhs, exp, pos, indices, 
				     num_indices, low_index, high_index);
	    break;
	  default:
	    error (_("Internal error: bad aggregate clause"));
	}
    }

  return container;
}
	      
/* Assign into the component of LHS indexed by the OP_POSITIONAL
   construct at *POS, updating *POS past the construct, given that
   the positions are relative to lower bound LOW, where HIGH is the 
   upper bound.  Record the position in INDICES[0 .. MAX_INDICES-1]
   updating *NUM_INDICES as needed.  CONTAINER is as for
   assign_aggregate.  */
static void
aggregate_assign_positional (struct value *container,
			     struct value *lhs, struct expression *exp,
			     int *pos, LONGEST *indices, int *num_indices,
			     int max_indices, LONGEST low, LONGEST high) 
{
  LONGEST ind = longest_to_int (exp->elts[*pos + 1].longconst) + low;
  
  if (ind - 1 == high)
    warning (_("Extra components in aggregate ignored."));
  if (ind <= high)
    {
      add_component_interval (ind, ind, indices, num_indices, max_indices);
      *pos += 3;
      assign_component (container, lhs, ind, exp, pos);
    }
  else
    ada_evaluate_subexp (NULL, exp, pos, EVAL_SKIP);
}

/* Assign into the components of LHS indexed by the OP_CHOICES
   construct at *POS, updating *POS past the construct, given that
   the allowable indices are LOW..HIGH.  Record the indices assigned
   to in INDICES[0 .. MAX_INDICES-1], updating *NUM_INDICES as
   needed.  CONTAINER is as for assign_aggregate.  */
static void
aggregate_assign_from_choices (struct value *container,
			       struct value *lhs, struct expression *exp,
			       int *pos, LONGEST *indices, int *num_indices,
			       int max_indices, LONGEST low, LONGEST high) 
{
  int j;
  int n_choices = longest_to_int (exp->elts[*pos+1].longconst);
  int choice_pos, expr_pc;
  int is_array = ada_is_direct_array_type (value_type (lhs));

  choice_pos = *pos += 3;

  for (j = 0; j < n_choices; j += 1)
    ada_evaluate_subexp (NULL, exp, pos, EVAL_SKIP);
  expr_pc = *pos;
  ada_evaluate_subexp (NULL, exp, pos, EVAL_SKIP);
  
  for (j = 0; j < n_choices; j += 1)
    {
      LONGEST lower, upper;
      enum exp_opcode op = exp->elts[choice_pos].opcode;

      if (op == OP_DISCRETE_RANGE)
	{
	  choice_pos += 1;
	  lower = value_as_long (ada_evaluate_subexp (NULL, exp, pos,
						      EVAL_NORMAL));
	  upper = value_as_long (ada_evaluate_subexp (NULL, exp, pos, 
						      EVAL_NORMAL));
	}
      else if (is_array)
	{
	  lower = value_as_long (ada_evaluate_subexp (NULL, exp, &choice_pos, 
						      EVAL_NORMAL));
	  upper = lower;
	}
      else
	{
	  int ind;
	  const char *name;

	  switch (op)
	    {
	    case OP_NAME:
	      name = &exp->elts[choice_pos + 2].string;
	      break;
	    case OP_VAR_VALUE:
	      name = SYMBOL_NATURAL_NAME (exp->elts[choice_pos + 2].symbol);
	      break;
	    default:
	      error (_("Invalid record component association."));
	    }
	  ada_evaluate_subexp (NULL, exp, &choice_pos, EVAL_SKIP);
	  ind = 0;
	  if (! find_struct_field (name, value_type (lhs), 0, 
				   NULL, NULL, NULL, NULL, &ind))
	    error (_("Unknown component name: %s."), name);
	  lower = upper = ind;
	}

      if (lower <= upper && (lower < low || upper > high))
	error (_("Index in component association out of bounds."));

      add_component_interval (lower, upper, indices, num_indices,
			      max_indices);
      while (lower <= upper)
	{
	  int pos1;

	  pos1 = expr_pc;
	  assign_component (container, lhs, lower, exp, &pos1);
	  lower += 1;
	}
    }
}

/* Assign the value of the expression in the OP_OTHERS construct in
   EXP at *POS into the components of LHS indexed from LOW .. HIGH that
   have not been previously assigned.  The index intervals already assigned
   are in INDICES[0 .. NUM_INDICES-1].  Updates *POS to after the 
   OP_OTHERS clause.  CONTAINER is as for assign_aggregate.  */
static void
aggregate_assign_others (struct value *container,
			 struct value *lhs, struct expression *exp,
			 int *pos, LONGEST *indices, int num_indices,
			 LONGEST low, LONGEST high) 
{
  int i;
  int expr_pc = *pos + 1;
  
  for (i = 0; i < num_indices - 2; i += 2)
    {
      LONGEST ind;

      for (ind = indices[i + 1] + 1; ind < indices[i + 2]; ind += 1)
	{
	  int localpos;

	  localpos = expr_pc;
	  assign_component (container, lhs, ind, exp, &localpos);
	}
    }
  ada_evaluate_subexp (NULL, exp, pos, EVAL_SKIP);
}

/* Add the interval [LOW .. HIGH] to the sorted set of intervals 
   [ INDICES[0] .. INDICES[1] ],..., [ INDICES[*SIZE-2] .. INDICES[*SIZE-1] ],
   modifying *SIZE as needed.  It is an error if *SIZE exceeds
   MAX_SIZE.  The resulting intervals do not overlap.  */
static void
add_component_interval (LONGEST low, LONGEST high, 
			LONGEST* indices, int *size, int max_size)
{
  int i, j;

  for (i = 0; i < *size; i += 2) {
    if (high >= indices[i] && low <= indices[i + 1])
      {
	int kh;

	for (kh = i + 2; kh < *size; kh += 2)
	  if (high < indices[kh])
	    break;
	if (low < indices[i])
	  indices[i] = low;
	indices[i + 1] = indices[kh - 1];
	if (high > indices[i + 1])
	  indices[i + 1] = high;
	memcpy (indices + i + 2, indices + kh, *size - kh);
	*size -= kh - i - 2;
	return;
      }
    else if (high < indices[i])
      break;
  }
	
  if (*size == max_size)
    error (_("Internal error: miscounted aggregate components."));
  *size += 2;
  for (j = *size-1; j >= i+2; j -= 1)
    indices[j] = indices[j - 2];
  indices[i] = low;
  indices[i + 1] = high;
}

/* Perform and Ada cast of ARG2 to type TYPE if the type of ARG2
   is different.  */

static struct value *
ada_value_cast (struct type *type, struct value *arg2, enum noside noside)
{
  if (type == ada_check_typedef (value_type (arg2)))
    return arg2;

  if (ada_is_fixed_point_type (type))
    return (cast_to_fixed (type, arg2));

  if (ada_is_fixed_point_type (value_type (arg2)))
    return cast_from_fixed (type, arg2);

  return value_cast (type, arg2);
}

/*  Evaluating Ada expressions, and printing their result.
    ------------------------------------------------------

    1. Introduction:
    ----------------

    We usually evaluate an Ada expression in order to print its value.
    We also evaluate an expression in order to print its type, which
    happens during the EVAL_AVOID_SIDE_EFFECTS phase of the evaluation,
    but we'll focus mostly on the EVAL_NORMAL phase.  In practice, the
    EVAL_AVOID_SIDE_EFFECTS phase allows us to simplify certain aspects of
    the evaluation compared to the EVAL_NORMAL, but is otherwise very
    similar.

    Evaluating expressions is a little more complicated for Ada entities
    than it is for entities in languages such as C.  The main reason for
    this is that Ada provides types whose definition might be dynamic.
    One example of such types is variant records.  Or another example
    would be an array whose bounds can only be known at run time.

    The following description is a general guide as to what should be
    done (and what should NOT be done) in order to evaluate an expression
    involving such types, and when.  This does not cover how the semantic
    information is encoded by GNAT as this is covered separatly.  For the
    document used as the reference for the GNAT encoding, see exp_dbug.ads
    in the GNAT sources.

    Ideally, we should embed each part of this description next to its
    associated code.  Unfortunately, the amount of code is so vast right
    now that it's hard to see whether the code handling a particular
    situation might be duplicated or not.  One day, when the code is
    cleaned up, this guide might become redundant with the comments
    inserted in the code, and we might want to remove it.

    2. ``Fixing'' an Entity, the Simple Case:
    -----------------------------------------

    When evaluating Ada expressions, the tricky issue is that they may
    reference entities whose type contents and size are not statically
    known.  Consider for instance a variant record:

       type Rec (Empty : Boolean := True) is record
          case Empty is
             when True => null;
             when False => Value : Integer;
          end case;
       end record;
       Yes : Rec := (Empty => False, Value => 1);
       No  : Rec := (empty => True);

    The size and contents of that record depends on the value of the
    descriminant (Rec.Empty).  At this point, neither the debugging
    information nor the associated type structure in GDB are able to
    express such dynamic types.  So what the debugger does is to create
    "fixed" versions of the type that applies to the specific object.
    We also informally refer to this opperation as "fixing" an object,
    which means creating its associated fixed type.

    Example: when printing the value of variable "Yes" above, its fixed
    type would look like this:

       type Rec is record
          Empty : Boolean;
          Value : Integer;
       end record;

    On the other hand, if we printed the value of "No", its fixed type
    would become:

       type Rec is record
          Empty : Boolean;
       end record;

    Things become a little more complicated when trying to fix an entity
    with a dynamic type that directly contains another dynamic type,
    such as an array of variant records, for instance.  There are
    two possible cases: Arrays, and records.

    3. ``Fixing'' Arrays:
    ---------------------

    The type structure in GDB describes an array in terms of its bounds,
    and the type of its elements.  By design, all elements in the array
    have the same type and we cannot represent an array of variant elements
    using the current type structure in GDB.  When fixing an array,
    we cannot fix the array element, as we would potentially need one
    fixed type per element of the array.  As a result, the best we can do
    when fixing an array is to produce an array whose bounds and size
    are correct (allowing us to read it from memory), but without having
    touched its element type.  Fixing each element will be done later,
    when (if) necessary.

    Arrays are a little simpler to handle than records, because the same
    amount of memory is allocated for each element of the array, even if
    the amount of space actually used by each element differs from element
    to element.  Consider for instance the following array of type Rec:

       type Rec_Array is array (1 .. 2) of Rec;

    The actual amount of memory occupied by each element might be different
    from element to element, depending on the value of their discriminant.
    But the amount of space reserved for each element in the array remains
    fixed regardless.  So we simply need to compute that size using
    the debugging information available, from which we can then determine
    the array size (we multiply the number of elements of the array by
    the size of each element).

    The simplest case is when we have an array of a constrained element
    type. For instance, consider the following type declarations:

        type Bounded_String (Max_Size : Integer) is
           Length : Integer;
           Buffer : String (1 .. Max_Size);
        end record;
        type Bounded_String_Array is array (1 ..2) of Bounded_String (80);

    In this case, the compiler describes the array as an array of
    variable-size elements (identified by its XVS suffix) for which
    the size can be read in the parallel XVZ variable.

    In the case of an array of an unconstrained element type, the compiler
    wraps the array element inside a private PAD type.  This type should not
    be shown to the user, and must be "unwrap"'ed before printing.  Note
    that we also use the adjective "aligner" in our code to designate
    these wrapper types.

    In some cases, the size allocated for each element is statically
    known.  In that case, the PAD type already has the correct size,
    and the array element should remain unfixed.

    But there are cases when this size is not statically known.
    For instance, assuming that "Five" is an integer variable:

        type Dynamic is array (1 .. Five) of Integer;
        type Wrapper (Has_Length : Boolean := False) is record
           Data : Dynamic;
           case Has_Length is
              when True => Length : Integer;
              when False => null;
           end case;
        end record;
        type Wrapper_Array is array (1 .. 2) of Wrapper;

        Hello : Wrapper_Array := (others => (Has_Length => True,
                                             Data => (others => 17),
                                             Length => 1));


    The debugging info would describe variable Hello as being an
    array of a PAD type.  The size of that PAD type is not statically
    known, but can be determined using a parallel XVZ variable.
    In that case, a copy of the PAD type with the correct size should
    be used for the fixed array.

    3. ``Fixing'' record type objects:
    ----------------------------------

    Things are slightly different from arrays in the case of dynamic
    record types.  In this case, in order to compute the associated
    fixed type, we need to determine the size and offset of each of
    its components.  This, in turn, requires us to compute the fixed
    type of each of these components.

    Consider for instance the example:

        type Bounded_String (Max_Size : Natural) is record
           Str : String (1 .. Max_Size);
           Length : Natural;
        end record;
        My_String : Bounded_String (Max_Size => 10);

    In that case, the position of field "Length" depends on the size
    of field Str, which itself depends on the value of the Max_Size
    discriminant.  In order to fix the type of variable My_String,
    we need to fix the type of field Str.  Therefore, fixing a variant
    record requires us to fix each of its components.

    However, if a component does not have a dynamic size, the component
    should not be fixed.  In particular, fields that use a PAD type
    should not fixed.  Here is an example where this might happen
    (assuming type Rec above):

       type Container (Big : Boolean) is record
          First : Rec;
          After : Integer;
          case Big is
             when True => Another : Integer;
             when False => null;
          end case;
       end record;
       My_Container : Container := (Big => False,
                                    First => (Empty => True),
                                    After => 42);

    In that example, the compiler creates a PAD type for component First,
    whose size is constant, and then positions the component After just
    right after it.  The offset of component After is therefore constant
    in this case.

    The debugger computes the position of each field based on an algorithm
    that uses, among other things, the actual position and size of the field
    preceding it.  Let's now imagine that the user is trying to print
    the value of My_Container.  If the type fixing was recursive, we would
    end up computing the offset of field After based on the size of the
    fixed version of field First.  And since in our example First has
    only one actual field, the size of the fixed type is actually smaller
    than the amount of space allocated to that field, and thus we would
    compute the wrong offset of field After.

    To make things more complicated, we need to watch out for dynamic
    components of variant records (identified by the ___XVL suffix in
    the component name).  Even if the target type is a PAD type, the size
    of that type might not be statically known.  So the PAD type needs
    to be unwrapped and the resulting type needs to be fixed.  Otherwise,
    we might end up with the wrong size for our component.  This can be
    observed with the following type declarations:

        type Octal is new Integer range 0 .. 7;
        type Octal_Array is array (Positive range <>) of Octal;
        pragma Pack (Octal_Array);

        type Octal_Buffer (Size : Positive) is record
           Buffer : Octal_Array (1 .. Size);
           Length : Integer;
        end record;

    In that case, Buffer is a PAD type whose size is unset and needs
    to be computed by fixing the unwrapped type.

    4. When to ``Fix'' un-``Fixed'' sub-elements of an entity:
    ----------------------------------------------------------

    Lastly, when should the sub-elements of an entity that remained unfixed
    thus far, be actually fixed?

    The answer is: Only when referencing that element.  For instance
    when selecting one component of a record, this specific component
    should be fixed at that point in time.  Or when printing the value
    of a record, each component should be fixed before its value gets
    printed.  Similarly for arrays, the element of the array should be
    fixed when printing each element of the array, or when extracting
    one element out of that array.  On the other hand, fixing should
    not be performed on the elements when taking a slice of an array!

    Note that one of the side-effects of miscomputing the offset and
    size of each field is that we end up also miscomputing the size
    of the containing type.  This can have adverse results when computing
    the value of an entity.  GDB fetches the value of an entity based
    on the size of its type, and thus a wrong size causes GDB to fetch
    the wrong amount of memory.  In the case where the computed size is
    too small, GDB fetches too little data to print the value of our
    entiry.  Results in this case as unpredicatble, as we usually read
    past the buffer containing the data =:-o.  */

/* Implement the evaluate_exp routine in the exp_descriptor structure
   for the Ada language.  */

static struct value *
ada_evaluate_subexp (struct type *expect_type, struct expression *exp,
                     int *pos, enum noside noside)
{
  enum exp_opcode op;
  int tem;
  int pc;
  struct value *arg1 = NULL, *arg2 = NULL, *arg3;
  struct type *type;
  int nargs, oplen;
  struct value **argvec;

  pc = *pos;
  *pos += 1;
  op = exp->elts[pc].opcode;

  switch (op)
    {
    default:
      *pos -= 1;
      arg1 = evaluate_subexp_standard (expect_type, exp, pos, noside);

      if (noside == EVAL_NORMAL)
	arg1 = unwrap_value (arg1);

      /* If evaluating an OP_DOUBLE and an EXPECT_TYPE was provided,
         then we need to perform the conversion manually, because
         evaluate_subexp_standard doesn't do it.  This conversion is
         necessary in Ada because the different kinds of float/fixed
         types in Ada have different representations.

         Similarly, we need to perform the conversion from OP_LONG
         ourselves.  */
      if ((op == OP_DOUBLE || op == OP_LONG) && expect_type != NULL)
        arg1 = ada_value_cast (expect_type, arg1, noside);

      return arg1;

    case OP_STRING:
      {
        struct value *result;

        *pos -= 1;
        result = evaluate_subexp_standard (expect_type, exp, pos, noside);
        /* The result type will have code OP_STRING, bashed there from 
           OP_ARRAY.  Bash it back.  */
        if (TYPE_CODE (value_type (result)) == TYPE_CODE_STRING)
          TYPE_CODE (value_type (result)) = TYPE_CODE_ARRAY;
        return result;
      }

    case UNOP_CAST:
      (*pos) += 2;
      type = exp->elts[pc + 1].type;
      arg1 = evaluate_subexp (type, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      arg1 = ada_value_cast (type, arg1, noside);
      return arg1;

    case UNOP_QUAL:
      (*pos) += 2;
      type = exp->elts[pc + 1].type;
      return ada_evaluate_subexp (type, exp, pos, noside);

    case BINOP_ASSIGN:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (exp->elts[*pos].opcode == OP_AGGREGATE)
	{
	  arg1 = assign_aggregate (arg1, arg1, exp, pos, noside);
	  if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)
	    return arg1;
	  return ada_value_assign (arg1, arg1);
	}
      /* Force the evaluation of the rhs ARG2 to the type of the lhs ARG1,
         except if the lhs of our assignment is a convenience variable.
         In the case of assigning to a convenience variable, the lhs
         should be exactly the result of the evaluation of the rhs.  */
      type = value_type (arg1);
      if (VALUE_LVAL (arg1) == lval_internalvar)
         type = NULL;
      arg2 = evaluate_subexp (type, exp, pos, noside);
      if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)
        return arg1;
      if (ada_is_fixed_point_type (value_type (arg1)))
        arg2 = cast_to_fixed (value_type (arg1), arg2);
      else if (ada_is_fixed_point_type (value_type (arg2)))
        error
          (_("Fixed-point values must be assigned to fixed-point variables"));
      else
        arg2 = coerce_for_assign (value_type (arg1), arg2);
      return ada_value_assign (arg1, arg2);

    case BINOP_ADD:
      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      if (TYPE_CODE (value_type (arg1)) == TYPE_CODE_PTR)
        return (value_from_longest
                 (value_type (arg1),
                  value_as_long (arg1) + value_as_long (arg2)));
      if ((ada_is_fixed_point_type (value_type (arg1))
           || ada_is_fixed_point_type (value_type (arg2)))
          && value_type (arg1) != value_type (arg2))
        error (_("Operands of fixed-point addition must have the same type"));
      /* Do the addition, and cast the result to the type of the first
         argument.  We cannot cast the result to a reference type, so if
         ARG1 is a reference type, find its underlying type.  */
      type = value_type (arg1);
      while (TYPE_CODE (type) == TYPE_CODE_REF)
        type = TYPE_TARGET_TYPE (type);
      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
      return value_cast (type, value_binop (arg1, arg2, BINOP_ADD));

    case BINOP_SUB:
      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      if (TYPE_CODE (value_type (arg1)) == TYPE_CODE_PTR)
        return (value_from_longest
                 (value_type (arg1),
                  value_as_long (arg1) - value_as_long (arg2)));
      if ((ada_is_fixed_point_type (value_type (arg1))
           || ada_is_fixed_point_type (value_type (arg2)))
          && value_type (arg1) != value_type (arg2))
        error (_("Operands of fixed-point subtraction "
		 "must have the same type"));
      /* Do the substraction, and cast the result to the type of the first
         argument.  We cannot cast the result to a reference type, so if
         ARG1 is a reference type, find its underlying type.  */
      type = value_type (arg1);
      while (TYPE_CODE (type) == TYPE_CODE_REF)
        type = TYPE_TARGET_TYPE (type);
      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
      return value_cast (type, value_binop (arg1, arg2, BINOP_SUB));

    case BINOP_MUL:
    case BINOP_DIV:
    case BINOP_REM:
    case BINOP_MOD:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        {
          binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
          return value_zero (value_type (arg1), not_lval);
        }
      else
        {
          type = builtin_type (exp->gdbarch)->builtin_double;
          if (ada_is_fixed_point_type (value_type (arg1)))
            arg1 = cast_from_fixed (type, arg1);
          if (ada_is_fixed_point_type (value_type (arg2)))
            arg2 = cast_from_fixed (type, arg2);
          binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
          return ada_value_binop (arg1, arg2, op);
        }

    case BINOP_EQUAL:
    case BINOP_NOTEQUAL:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
        tem = 0;
      else
	{
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
	  tem = ada_value_equal (arg1, arg2);
	}
      if (op == BINOP_NOTEQUAL)
        tem = !tem;
      type = language_bool_type (exp->language_defn, exp->gdbarch);
      return value_from_longest (type, (LONGEST) tem);

    case UNOP_NEG:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (ada_is_fixed_point_type (value_type (arg1)))
        return value_cast (value_type (arg1), value_neg (arg1));
      else
	{
	  unop_promote (exp->language_defn, exp->gdbarch, &arg1);
	  return value_neg (arg1);
	}

    case BINOP_LOGICAL_AND:
    case BINOP_LOGICAL_OR:
    case UNOP_LOGICAL_NOT:
      {
        struct value *val;

        *pos -= 1;
        val = evaluate_subexp_standard (expect_type, exp, pos, noside);
	type = language_bool_type (exp->language_defn, exp->gdbarch);
        return value_cast (type, val);
      }

    case BINOP_BITWISE_AND:
    case BINOP_BITWISE_IOR:
    case BINOP_BITWISE_XOR:
      {
        struct value *val;

        arg1 = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
        *pos = pc;
        val = evaluate_subexp_standard (expect_type, exp, pos, noside);

        return value_cast (value_type (arg1), val);
      }

    case OP_VAR_VALUE:
      *pos -= 1;

      if (noside == EVAL_SKIP)
        {
          *pos += 4;
          goto nosideret;
        }
      else if (SYMBOL_DOMAIN (exp->elts[pc + 2].symbol) == UNDEF_DOMAIN)
        /* Only encountered when an unresolved symbol occurs in a
           context other than a function call, in which case, it is
           invalid.  */
        error (_("Unexpected unresolved symbol, %s, during evaluation"),
               SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        {
          type = static_unwrap_type (SYMBOL_TYPE (exp->elts[pc + 2].symbol));
          /* Check to see if this is a tagged type.  We also need to handle
             the case where the type is a reference to a tagged type, but
             we have to be careful to exclude pointers to tagged types.
             The latter should be shown as usual (as a pointer), whereas
             a reference should mostly be transparent to the user.  */
          if (ada_is_tagged_type (type, 0)
              || (TYPE_CODE(type) == TYPE_CODE_REF
                  && ada_is_tagged_type (TYPE_TARGET_TYPE (type), 0)))
          {
            /* Tagged types are a little special in the fact that the real
               type is dynamic and can only be determined by inspecting the
               object's tag.  This means that we need to get the object's
               value first (EVAL_NORMAL) and then extract the actual object
               type from its tag.

               Note that we cannot skip the final step where we extract
               the object type from its tag, because the EVAL_NORMAL phase
               results in dynamic components being resolved into fixed ones.
               This can cause problems when trying to print the type
               description of tagged types whose parent has a dynamic size:
               We use the type name of the "_parent" component in order
               to print the name of the ancestor type in the type description.
               If that component had a dynamic size, the resolution into
               a fixed type would result in the loss of that type name,
               thus preventing us from printing the name of the ancestor
               type in the type description.  */
            arg1 = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_NORMAL);

	    if (TYPE_CODE (type) != TYPE_CODE_REF)
	      {
		struct type *actual_type;

		actual_type = type_from_tag (ada_value_tag (arg1));
		if (actual_type == NULL)
		  /* If, for some reason, we were unable to determine
		     the actual type from the tag, then use the static
		     approximation that we just computed as a fallback.
		     This can happen if the debugging information is
		     incomplete, for instance.  */
		  actual_type = type;
		return value_zero (actual_type, not_lval);
	      }
	    else
	      {
		/* In the case of a ref, ada_coerce_ref takes care
		   of determining the actual type.  But the evaluation
		   should return a ref as it should be valid to ask
		   for its address; so rebuild a ref after coerce.  */
		arg1 = ada_coerce_ref (arg1);
		return value_ref (arg1);
	      }
          }

          *pos += 4;
          return value_zero
            (to_static_fixed_type
             (static_unwrap_type (SYMBOL_TYPE (exp->elts[pc + 2].symbol))),
             not_lval);
        }
      else
        {
          arg1 = evaluate_subexp_standard (expect_type, exp, pos, noside);
          return ada_to_fixed_value (arg1);
        }

    case OP_FUNCALL:
      (*pos) += 2;

      /* Allocate arg vector, including space for the function to be
         called in argvec[0] and a terminating NULL.  */
      nargs = longest_to_int (exp->elts[pc + 1].longconst);
      argvec =
        (struct value **) alloca (sizeof (struct value *) * (nargs + 2));

      if (exp->elts[*pos].opcode == OP_VAR_VALUE
          && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)
        error (_("Unexpected unresolved symbol, %s, during evaluation"),
               SYMBOL_PRINT_NAME (exp->elts[pc + 5].symbol));
      else
        {
          for (tem = 0; tem <= nargs; tem += 1)
            argvec[tem] = evaluate_subexp (NULL_TYPE, exp, pos, noside);
          argvec[tem] = 0;

          if (noside == EVAL_SKIP)
            goto nosideret;
        }

      if (ada_is_constrained_packed_array_type
	  (desc_base_type (value_type (argvec[0]))))
        argvec[0] = ada_coerce_to_simple_array (argvec[0]);
      else if (TYPE_CODE (value_type (argvec[0])) == TYPE_CODE_ARRAY
               && TYPE_FIELD_BITSIZE (value_type (argvec[0]), 0) != 0)
        /* This is a packed array that has already been fixed, and
	   therefore already coerced to a simple array.  Nothing further
	   to do.  */
        ;
      else if (TYPE_CODE (value_type (argvec[0])) == TYPE_CODE_REF
               || (TYPE_CODE (value_type (argvec[0])) == TYPE_CODE_ARRAY
                   && VALUE_LVAL (argvec[0]) == lval_memory))
        argvec[0] = value_addr (argvec[0]);

      type = ada_check_typedef (value_type (argvec[0]));

      /* Ada allows us to implicitly dereference arrays when subscripting
	 them.  So, if this is an array typedef (encoding use for array
	 access types encoded as fat pointers), strip it now.  */
      if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)
	type = ada_typedef_target_type (type);

      if (TYPE_CODE (type) == TYPE_CODE_PTR)
        {
          switch (TYPE_CODE (ada_check_typedef (TYPE_TARGET_TYPE (type))))
            {
            case TYPE_CODE_FUNC:
              type = ada_check_typedef (TYPE_TARGET_TYPE (type));
              break;
            case TYPE_CODE_ARRAY:
              break;
            case TYPE_CODE_STRUCT:
              if (noside != EVAL_AVOID_SIDE_EFFECTS)
                argvec[0] = ada_value_ind (argvec[0]);
              type = ada_check_typedef (TYPE_TARGET_TYPE (type));
              break;
            default:
              error (_("cannot subscript or call something of type `%s'"),
                     ada_type_name (value_type (argvec[0])));
              break;
            }
        }

      switch (TYPE_CODE (type))
        {
        case TYPE_CODE_FUNC:
          if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    {
	      struct type *rtype = TYPE_TARGET_TYPE (type);

	      if (TYPE_GNU_IFUNC (type))
		return allocate_value (TYPE_TARGET_TYPE (rtype));
	      return allocate_value (rtype);
	    }
          return call_function_by_hand (argvec[0], nargs, argvec + 1);
	case TYPE_CODE_INTERNAL_FUNCTION:
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    /* We don't know anything about what the internal
	       function might return, but we have to return
	       something.  */
	    return value_zero (builtin_type (exp->gdbarch)->builtin_int,
			       not_lval);
	  else
	    return call_internal_function (exp->gdbarch, exp->language_defn,
					   argvec[0], nargs, argvec + 1);

        case TYPE_CODE_STRUCT:
          {
            int arity;

            arity = ada_array_arity (type);
            type = ada_array_element_type (type, nargs);
            if (type == NULL)
              error (_("cannot subscript or call a record"));
            if (arity != nargs)
              error (_("wrong number of subscripts; expecting %d"), arity);
            if (noside == EVAL_AVOID_SIDE_EFFECTS)
              return value_zero (ada_aligned_type (type), lval_memory);
            return
              unwrap_value (ada_value_subscript
                            (argvec[0], nargs, argvec + 1));
          }
        case TYPE_CODE_ARRAY:
          if (noside == EVAL_AVOID_SIDE_EFFECTS)
            {
              type = ada_array_element_type (type, nargs);
              if (type == NULL)
                error (_("element type of array unknown"));
              else
                return value_zero (ada_aligned_type (type), lval_memory);
            }
          return
            unwrap_value (ada_value_subscript
                          (ada_coerce_to_simple_array (argvec[0]),
                           nargs, argvec + 1));
        case TYPE_CODE_PTR:     /* Pointer to array */
          type = to_fixed_array_type (TYPE_TARGET_TYPE (type), NULL, 1);
          if (noside == EVAL_AVOID_SIDE_EFFECTS)
            {
              type = ada_array_element_type (type, nargs);
              if (type == NULL)
                error (_("element type of array unknown"));
              else
                return value_zero (ada_aligned_type (type), lval_memory);
            }
          return
            unwrap_value (ada_value_ptr_subscript (argvec[0], type,
                                                   nargs, argvec + 1));

        default:
          error (_("Attempt to index or call something other than an "
		   "array or function"));
        }

    case TERNOP_SLICE:
      {
        struct value *array = evaluate_subexp (NULL_TYPE, exp, pos, noside);
        struct value *low_bound_val =
          evaluate_subexp (NULL_TYPE, exp, pos, noside);
        struct value *high_bound_val =
          evaluate_subexp (NULL_TYPE, exp, pos, noside);
        LONGEST low_bound;
        LONGEST high_bound;

        low_bound_val = coerce_ref (low_bound_val);
        high_bound_val = coerce_ref (high_bound_val);
        low_bound = pos_atr (low_bound_val);
        high_bound = pos_atr (high_bound_val);

        if (noside == EVAL_SKIP)
          goto nosideret;

        /* If this is a reference to an aligner type, then remove all
           the aligners.  */
        if (TYPE_CODE (value_type (array)) == TYPE_CODE_REF
            && ada_is_aligner_type (TYPE_TARGET_TYPE (value_type (array))))
          TYPE_TARGET_TYPE (value_type (array)) =
            ada_aligned_type (TYPE_TARGET_TYPE (value_type (array)));

        if (ada_is_constrained_packed_array_type (value_type (array)))
          error (_("cannot slice a packed array"));

        /* If this is a reference to an array or an array lvalue,
           convert to a pointer.  */
        if (TYPE_CODE (value_type (array)) == TYPE_CODE_REF
            || (TYPE_CODE (value_type (array)) == TYPE_CODE_ARRAY
                && VALUE_LVAL (array) == lval_memory))
          array = value_addr (array);

        if (noside == EVAL_AVOID_SIDE_EFFECTS
            && ada_is_array_descriptor_type (ada_check_typedef
                                             (value_type (array))))
          return empty_array (ada_type_of_array (array, 0), low_bound);

        array = ada_coerce_to_simple_array_ptr (array);

        /* If we have more than one level of pointer indirection,
           dereference the value until we get only one level.  */
        while (TYPE_CODE (value_type (array)) == TYPE_CODE_PTR
               && (TYPE_CODE (TYPE_TARGET_TYPE (value_type (array)))
                     == TYPE_CODE_PTR))
          array = value_ind (array);

        /* Make sure we really do have an array type before going further,
           to avoid a SEGV when trying to get the index type or the target
           type later down the road if the debug info generated by
           the compiler is incorrect or incomplete.  */
        if (!ada_is_simple_array_type (value_type (array)))
          error (_("cannot take slice of non-array"));

        if (TYPE_CODE (ada_check_typedef (value_type (array)))
            == TYPE_CODE_PTR)
          {
            struct type *type0 = ada_check_typedef (value_type (array));

            if (high_bound < low_bound || noside == EVAL_AVOID_SIDE_EFFECTS)
              return empty_array (TYPE_TARGET_TYPE (type0), low_bound);
            else
              {
                struct type *arr_type0 =
                  to_fixed_array_type (TYPE_TARGET_TYPE (type0), NULL, 1);

                return ada_value_slice_from_ptr (array, arr_type0,
                                                 longest_to_int (low_bound),
                                                 longest_to_int (high_bound));
              }
          }
        else if (noside == EVAL_AVOID_SIDE_EFFECTS)
          return array;
        else if (high_bound < low_bound)
          return empty_array (value_type (array), low_bound);
        else
          return ada_value_slice (array, longest_to_int (low_bound),
				  longest_to_int (high_bound));
      }

    case UNOP_IN_RANGE:
      (*pos) += 2;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      type = check_typedef (exp->elts[pc + 1].type);

      if (noside == EVAL_SKIP)
        goto nosideret;

      switch (TYPE_CODE (type))
        {
        default:
          lim_warning (_("Membership test incompletely implemented; "
			 "always returns true"));
	  type = language_bool_type (exp->language_defn, exp->gdbarch);
	  return value_from_longest (type, (LONGEST) 1);

        case TYPE_CODE_RANGE:
	  arg2 = value_from_longest (type, TYPE_LOW_BOUND (type));
	  arg3 = value_from_longest (type, TYPE_HIGH_BOUND (type));
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg3);
	  type = language_bool_type (exp->language_defn, exp->gdbarch);
	  return
	    value_from_longest (type,
                                (value_less (arg1, arg3)
                                 || value_equal (arg1, arg3))
                                && (value_less (arg2, arg1)
                                    || value_equal (arg2, arg1)));
        }

    case BINOP_IN_BOUNDS:
      (*pos) += 2;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      if (noside == EVAL_SKIP)
        goto nosideret;

      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  type = language_bool_type (exp->language_defn, exp->gdbarch);
	  return value_zero (type, not_lval);
	}

      tem = longest_to_int (exp->elts[pc + 1].longconst);

      type = ada_index_type (value_type (arg2), tem, "range");
      if (!type)
	type = value_type (arg1);

      arg3 = value_from_longest (type, ada_array_bound (arg2, tem, 1));
      arg2 = value_from_longest (type, ada_array_bound (arg2, tem, 0));

      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg3);
      type = language_bool_type (exp->language_defn, exp->gdbarch);
      return
        value_from_longest (type,
                            (value_less (arg1, arg3)
                             || value_equal (arg1, arg3))
                            && (value_less (arg2, arg1)
                                || value_equal (arg2, arg1)));

    case TERNOP_IN_RANGE:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg3 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      if (noside == EVAL_SKIP)
        goto nosideret;

      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg3);
      type = language_bool_type (exp->language_defn, exp->gdbarch);
      return
        value_from_longest (type,
                            (value_less (arg1, arg3)
                             || value_equal (arg1, arg3))
                            && (value_less (arg2, arg1)
                                || value_equal (arg2, arg1)));

    case OP_ATR_FIRST:
    case OP_ATR_LAST:
    case OP_ATR_LENGTH:
      {
        struct type *type_arg;

        if (exp->elts[*pos].opcode == OP_TYPE)
          {
            evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
            arg1 = NULL;
            type_arg = check_typedef (exp->elts[pc + 2].type);
          }
        else
          {
            arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
            type_arg = NULL;
          }

        if (exp->elts[*pos].opcode != OP_LONG)
          error (_("Invalid operand to '%s"), ada_attribute_name (op));
        tem = longest_to_int (exp->elts[*pos + 2].longconst);
        *pos += 4;

        if (noside == EVAL_SKIP)
          goto nosideret;

        if (type_arg == NULL)
          {
            arg1 = ada_coerce_ref (arg1);

            if (ada_is_constrained_packed_array_type (value_type (arg1)))
              arg1 = ada_coerce_to_simple_array (arg1);

            type = ada_index_type (value_type (arg1), tem,
				   ada_attribute_name (op));
            if (type == NULL)
	      type = builtin_type (exp->gdbarch)->builtin_int;

            if (noside == EVAL_AVOID_SIDE_EFFECTS)
              return allocate_value (type);

            switch (op)
              {
              default:          /* Should never happen.  */
                error (_("unexpected attribute encountered"));
              case OP_ATR_FIRST:
                return value_from_longest
			(type, ada_array_bound (arg1, tem, 0));
              case OP_ATR_LAST:
                return value_from_longest
			(type, ada_array_bound (arg1, tem, 1));
              case OP_ATR_LENGTH:
                return value_from_longest
			(type, ada_array_length (arg1, tem));
              }
          }
        else if (discrete_type_p (type_arg))
          {
            struct type *range_type;
            const char *name = ada_type_name (type_arg);

            range_type = NULL;
            if (name != NULL && TYPE_CODE (type_arg) != TYPE_CODE_ENUM)
              range_type = to_fixed_range_type (type_arg, NULL);
            if (range_type == NULL)
              range_type = type_arg;
            switch (op)
              {
              default:
                error (_("unexpected attribute encountered"));
              case OP_ATR_FIRST:
		return value_from_longest 
		  (range_type, ada_discrete_type_low_bound (range_type));
              case OP_ATR_LAST:
                return value_from_longest
		  (range_type, ada_discrete_type_high_bound (range_type));
              case OP_ATR_LENGTH:
                error (_("the 'length attribute applies only to array types"));
              }
          }
        else if (TYPE_CODE (type_arg) == TYPE_CODE_FLT)
          error (_("unimplemented type attribute"));
        else
          {
            LONGEST low, high;

            if (ada_is_constrained_packed_array_type (type_arg))
              type_arg = decode_constrained_packed_array_type (type_arg);

            type = ada_index_type (type_arg, tem, ada_attribute_name (op));
            if (type == NULL)
	      type = builtin_type (exp->gdbarch)->builtin_int;

            if (noside == EVAL_AVOID_SIDE_EFFECTS)
              return allocate_value (type);

            switch (op)
              {
              default:
                error (_("unexpected attribute encountered"));
              case OP_ATR_FIRST:
                low = ada_array_bound_from_type (type_arg, tem, 0);
                return value_from_longest (type, low);
              case OP_ATR_LAST:
                high = ada_array_bound_from_type (type_arg, tem, 1);
                return value_from_longest (type, high);
              case OP_ATR_LENGTH:
                low = ada_array_bound_from_type (type_arg, tem, 0);
                high = ada_array_bound_from_type (type_arg, tem, 1);
                return value_from_longest (type, high - low + 1);
              }
          }
      }

    case OP_ATR_TAG:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;

      if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (ada_tag_type (arg1), not_lval);

      return ada_value_tag (arg1);

    case OP_ATR_MIN:
    case OP_ATR_MAX:
      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (value_type (arg1), not_lval);
      else
	{
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
	  return value_binop (arg1, arg2,
			      op == OP_ATR_MIN ? BINOP_MIN : BINOP_MAX);
	}

    case OP_ATR_MODULUS:
      {
        struct type *type_arg = check_typedef (exp->elts[pc + 2].type);

        evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
        if (noside == EVAL_SKIP)
          goto nosideret;

        if (!ada_is_modular_type (type_arg))
          error (_("'modulus must be applied to modular type"));

        return value_from_longest (TYPE_TARGET_TYPE (type_arg),
                                   ada_modulus (type_arg));
      }


    case OP_ATR_POS:
      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      type = builtin_type (exp->gdbarch)->builtin_int;
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return value_zero (type, not_lval);
      else
	return value_pos_atr (type, arg1);

    case OP_ATR_SIZE:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      type = value_type (arg1);

      /* If the argument is a reference, then dereference its type, since
         the user is really asking for the size of the actual object,
         not the size of the pointer.  */
      if (TYPE_CODE (type) == TYPE_CODE_REF)
        type = TYPE_TARGET_TYPE (type);

      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (builtin_type (exp->gdbarch)->builtin_int, not_lval);
      else
        return value_from_longest (builtin_type (exp->gdbarch)->builtin_int,
                                   TARGET_CHAR_BIT * TYPE_LENGTH (type));

    case OP_ATR_VAL:
      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      type = exp->elts[pc + 2].type;
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (type, not_lval);
      else
        return value_val_atr (type, arg1);

    case BINOP_EXP:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (value_type (arg1), not_lval);
      else
	{
	  /* For integer exponentiation operations,
	     only promote the first argument.  */
	  if (is_integral_type (value_type (arg2)))
	    unop_promote (exp->language_defn, exp->gdbarch, &arg1);
	  else
	    binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);

	  return value_binop (arg1, arg2, op);
	}

    case UNOP_PLUS:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else
        return arg1;

    case UNOP_ABS:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      unop_promote (exp->language_defn, exp->gdbarch, &arg1);
      if (value_less (arg1, value_zero (value_type (arg1), not_lval)))
        return value_neg (arg1);
      else
        return arg1;

    case UNOP_IND:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      type = ada_check_typedef (value_type (arg1));
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
        {
          if (ada_is_array_descriptor_type (type))
            /* GDB allows dereferencing GNAT array descriptors.  */
            {
              struct type *arrType = ada_type_of_array (arg1, 0);

              if (arrType == NULL)
                error (_("Attempt to dereference null array pointer."));
              return value_at_lazy (arrType, 0);
            }
          else if (TYPE_CODE (type) == TYPE_CODE_PTR
                   || TYPE_CODE (type) == TYPE_CODE_REF
                   /* In C you can dereference an array to get the 1st elt.  */
                   || TYPE_CODE (type) == TYPE_CODE_ARRAY)
            {
              type = to_static_fixed_type
                (ada_aligned_type
                 (ada_check_typedef (TYPE_TARGET_TYPE (type))));
              check_size (type);
              return value_zero (type, lval_memory);
            }
          else if (TYPE_CODE (type) == TYPE_CODE_INT)
	    {
	      /* GDB allows dereferencing an int.  */
	      if (expect_type == NULL)
		return value_zero (builtin_type (exp->gdbarch)->builtin_int,
				   lval_memory);
	      else
		{
		  expect_type = 
		    to_static_fixed_type (ada_aligned_type (expect_type));
		  return value_zero (expect_type, lval_memory);
		}
	    }
          else
            error (_("Attempt to take contents of a non-pointer value."));
        }
      arg1 = ada_coerce_ref (arg1);     /* FIXME: What is this for??  */
      type = ada_check_typedef (value_type (arg1));

      if (TYPE_CODE (type) == TYPE_CODE_INT)
          /* GDB allows dereferencing an int.  If we were given
             the expect_type, then use that as the target type.
             Otherwise, assume that the target type is an int.  */
        {
          if (expect_type != NULL)
	    return ada_value_ind (value_cast (lookup_pointer_type (expect_type),
					      arg1));
	  else
	    return value_at_lazy (builtin_type (exp->gdbarch)->builtin_int,
				  (CORE_ADDR) value_as_address (arg1));
        }

      if (ada_is_array_descriptor_type (type))
        /* GDB allows dereferencing GNAT array descriptors.  */
        return ada_coerce_to_simple_array (arg1);
      else
        return ada_value_ind (arg1);

    case STRUCTOP_STRUCT:
      tem = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
        {
          struct type *type1 = value_type (arg1);

          if (ada_is_tagged_type (type1, 1))
            {
              type = ada_lookup_struct_elt_type (type1,
                                                 &exp->elts[pc + 2].string,
                                                 1, 1, NULL);
              if (type == NULL)
                /* In this case, we assume that the field COULD exist
                   in some extension of the type.  Return an object of 
                   "type" void, which will match any formal 
                   (see ada_type_match).  */
                return value_zero (builtin_type (exp->gdbarch)->builtin_void,
				   lval_memory);
            }
          else
            type =
              ada_lookup_struct_elt_type (type1, &exp->elts[pc + 2].string, 1,
                                          0, NULL);

          return value_zero (ada_aligned_type (type), lval_memory);
        }
      else
        arg1 = ada_value_struct_elt (arg1, &exp->elts[pc + 2].string, 0);
        arg1 = unwrap_value (arg1);
        return ada_to_fixed_value (arg1);

    case OP_TYPE:
      /* The value is not supposed to be used.  This is here to make it
         easier to accommodate expressions that contain types.  */
      (*pos) += 2;
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return allocate_value (exp->elts[pc + 1].type);
      else
        error (_("Attempt to use a type name as an expression"));

    case OP_AGGREGATE:
    case OP_CHOICES:
    case OP_OTHERS:
    case OP_DISCRETE_RANGE:
    case OP_POSITIONAL:
    case OP_NAME:
      if (noside == EVAL_NORMAL)
	switch (op) 
	  {
	  case OP_NAME:
	    error (_("Undefined name, ambiguous name, or renaming used in "
		     "component association: %s."), &exp->elts[pc+2].string);
	  case OP_AGGREGATE:
	    error (_("Aggregates only allowed on the right of an assignment"));
	  default:
	    internal_error (__FILE__, __LINE__,
			    _("aggregate apparently mangled"));
	  }

      ada_forward_operator_length (exp, pc, &oplen, &nargs);
      *pos += oplen - 1;
      for (tem = 0; tem < nargs; tem += 1) 
	ada_evaluate_subexp (NULL, exp, pos, noside);
      goto nosideret;
    }

nosideret:
  return value_from_longest (builtin_type (exp->gdbarch)->builtin_int, 1);
}


                                /* Fixed point */

/* If TYPE encodes an Ada fixed-point type, return the suffix of the
   type name that encodes the 'small and 'delta information.
   Otherwise, return NULL.  */

static const char *
fixed_type_info (struct type *type)
{
  const char *name = ada_type_name (type);
  enum type_code code = (type == NULL) ? TYPE_CODE_UNDEF : TYPE_CODE (type);

  if ((code == TYPE_CODE_INT || code == TYPE_CODE_RANGE) && name != NULL)
    {
      const char *tail = strstr (name, "___XF_");

      if (tail == NULL)
        return NULL;
      else
        return tail + 5;
    }
  else if (code == TYPE_CODE_RANGE && TYPE_TARGET_TYPE (type) != type)
    return fixed_type_info (TYPE_TARGET_TYPE (type));
  else
    return NULL;
}

/* Returns non-zero iff TYPE represents an Ada fixed-point type.  */

int
ada_is_fixed_point_type (struct type *type)
{
  return fixed_type_info (type) != NULL;
}

/* Return non-zero iff TYPE represents a System.Address type.  */

int
ada_is_system_address_type (struct type *type)
{
  return (TYPE_NAME (type)
          && strcmp (TYPE_NAME (type), "system__address") == 0);
}

/* Assuming that TYPE is the representation of an Ada fixed-point
   type, return its delta, or -1 if the type is malformed and the
   delta cannot be determined.  */

DOUBLEST
ada_delta (struct type *type)
{
  const char *encoding = fixed_type_info (type);
  DOUBLEST num, den;

  /* Strictly speaking, num and den are encoded as integer.  However,
     they may not fit into a long, and they will have to be converted
     to DOUBLEST anyway.  So scan them as DOUBLEST.  */
  if (sscanf (encoding, "_%" DOUBLEST_SCAN_FORMAT "_%" DOUBLEST_SCAN_FORMAT,
	      &num, &den) < 2)
    return -1.0;
  else
    return num / den;
}

/* Assuming that ada_is_fixed_point_type (TYPE), return the scaling
   factor ('SMALL value) associated with the type.  */

static DOUBLEST
scaling_factor (struct type *type)
{
  const char *encoding = fixed_type_info (type);
  DOUBLEST num0, den0, num1, den1;
  int n;

  /* Strictly speaking, num's and den's are encoded as integer.  However,
     they may not fit into a long, and they will have to be converted
     to DOUBLEST anyway.  So scan them as DOUBLEST.  */
  n = sscanf (encoding,
	      "_%" DOUBLEST_SCAN_FORMAT "_%" DOUBLEST_SCAN_FORMAT
	      "_%" DOUBLEST_SCAN_FORMAT "_%" DOUBLEST_SCAN_FORMAT,
	      &num0, &den0, &num1, &den1);

  if (n < 2)
    return 1.0;
  else if (n == 4)
    return num1 / den1;
  else
    return num0 / den0;
}


/* Assuming that X is the representation of a value of fixed-point
   type TYPE, return its floating-point equivalent.  */

DOUBLEST
ada_fixed_to_float (struct type *type, LONGEST x)
{
  return (DOUBLEST) x *scaling_factor (type);
}

/* The representation of a fixed-point value of type TYPE
   corresponding to the value X.  */

LONGEST
ada_float_to_fixed (struct type *type, DOUBLEST x)
{
  return (LONGEST) (x / scaling_factor (type) + 0.5);
}



                                /* Range types */

/* Scan STR beginning at position K for a discriminant name, and
   return the value of that discriminant field of DVAL in *PX.  If
   PNEW_K is not null, put the position of the character beyond the
   name scanned in *PNEW_K.  Return 1 if successful; return 0 and do
   not alter *PX and *PNEW_K if unsuccessful.  */

static int
scan_discrim_bound (char *str, int k, struct value *dval, LONGEST * px,
                    int *pnew_k)
{
  static char *bound_buffer = NULL;
  static size_t bound_buffer_len = 0;
  char *bound;
  char *pend;
  struct value *bound_val;

  if (dval == NULL || str == NULL || str[k] == '\0')
    return 0;

  pend = strstr (str + k, "__");
  if (pend == NULL)
    {
      bound = str + k;
      k += strlen (bound);
    }
  else
    {
      GROW_VECT (bound_buffer, bound_buffer_len, pend - (str + k) + 1);
      bound = bound_buffer;
      strncpy (bound_buffer, str + k, pend - (str + k));
      bound[pend - (str + k)] = '\0';
      k = pend - str;
    }

  bound_val = ada_search_struct_field (bound, dval, 0, value_type (dval));
  if (bound_val == NULL)
    return 0;

  *px = value_as_long (bound_val);
  if (pnew_k != NULL)
    *pnew_k = k;
  return 1;
}

/* Value of variable named NAME in the current environment.  If
   no such variable found, then if ERR_MSG is null, returns 0, and
   otherwise causes an error with message ERR_MSG.  */

static struct value *
get_var_value (char *name, char *err_msg)
{
  struct ada_symbol_info *syms;
  int nsyms;

  nsyms = ada_lookup_symbol_list (name, get_selected_block (0), VAR_DOMAIN,
                                  &syms);

  if (nsyms != 1)
    {
      if (err_msg == NULL)
        return 0;
      else
        error (("%s"), err_msg);
    }

  return value_of_variable (syms[0].sym, syms[0].block);
}

/* Value of integer variable named NAME in the current environment.  If
   no such variable found, returns 0, and sets *FLAG to 0.  If
   successful, sets *FLAG to 1.  */

LONGEST
get_int_var_value (char *name, int *flag)
{
  struct value *var_val = get_var_value (name, 0);

  if (var_val == 0)
    {
      if (flag != NULL)
        *flag = 0;
      return 0;
    }
  else
    {
      if (flag != NULL)
        *flag = 1;
      return value_as_long (var_val);
    }
}


/* Return a range type whose base type is that of the range type named
   NAME in the current environment, and whose bounds are calculated
   from NAME according to the GNAT range encoding conventions.
   Extract discriminant values, if needed, from DVAL.  ORIG_TYPE is the
   corresponding range type from debug information; fall back to using it
   if symbol lookup fails.  If a new type must be created, allocate it
   like ORIG_TYPE was.  The bounds information, in general, is encoded
   in NAME, the base type given in the named range type.  */

static struct type *
to_fixed_range_type (struct type *raw_type, struct value *dval)
{
  const char *name;
  struct type *base_type;
  char *subtype_info;

  gdb_assert (raw_type != NULL);
  gdb_assert (TYPE_NAME (raw_type) != NULL);

  if (TYPE_CODE (raw_type) == TYPE_CODE_RANGE)
    base_type = TYPE_TARGET_TYPE (raw_type);
  else
    base_type = raw_type;

  name = TYPE_NAME (raw_type);
  subtype_info = strstr (name, "___XD");
  if (subtype_info == NULL)
    {
      LONGEST L = ada_discrete_type_low_bound (raw_type);
      LONGEST U = ada_discrete_type_high_bound (raw_type);

      if (L < INT_MIN || U > INT_MAX)
	return raw_type;
      else
	return create_range_type (alloc_type_copy (raw_type), raw_type,
				  ada_discrete_type_low_bound (raw_type),
				  ada_discrete_type_high_bound (raw_type));
    }
  else
    {
      static char *name_buf = NULL;
      static size_t name_len = 0;
      int prefix_len = subtype_info - name;
      LONGEST L, U;
      struct type *type;
      char *bounds_str;
      int n;

      GROW_VECT (name_buf, name_len, prefix_len + 5);
      strncpy (name_buf, name, prefix_len);
      name_buf[prefix_len] = '\0';

      subtype_info += 5;
      bounds_str = strchr (subtype_info, '_');
      n = 1;

      if (*subtype_info == 'L')
        {
          if (!ada_scan_number (bounds_str, n, &L, &n)
              && !scan_discrim_bound (bounds_str, n, dval, &L, &n))
            return raw_type;
          if (bounds_str[n] == '_')
            n += 2;
          else if (bounds_str[n] == '.')     /* FIXME? SGI Workshop kludge.  */
            n += 1;
          subtype_info += 1;
        }
      else
        {
          int ok;

          strcpy (name_buf + prefix_len, "___L");
          L = get_int_var_value (name_buf, &ok);
          if (!ok)
            {
              lim_warning (_("Unknown lower bound, using 1."));
              L = 1;
            }
        }

      if (*subtype_info == 'U')
        {
          if (!ada_scan_number (bounds_str, n, &U, &n)
              && !scan_discrim_bound (bounds_str, n, dval, &U, &n))
            return raw_type;
        }
      else
        {
          int ok;

          strcpy (name_buf + prefix_len, "___U");
          U = get_int_var_value (name_buf, &ok);
          if (!ok)
            {
              lim_warning (_("Unknown upper bound, using %ld."), (long) L);
              U = L;
            }
        }

      type = create_range_type (alloc_type_copy (raw_type), base_type, L, U);
      TYPE_NAME (type) = name;
      return type;
    }
}

/* True iff NAME is the name of a range type.  */

int
ada_is_range_type_name (const char *name)
{
  return (name != NULL && strstr (name, "___XD"));
}


                                /* Modular types */

/* True iff TYPE is an Ada modular type.  */

int
ada_is_modular_type (struct type *type)
{
  struct type *subranged_type = get_base_type (type);

  return (subranged_type != NULL && TYPE_CODE (type) == TYPE_CODE_RANGE
          && TYPE_CODE (subranged_type) == TYPE_CODE_INT
          && TYPE_UNSIGNED (subranged_type));
}

/* Assuming ada_is_modular_type (TYPE), the modulus of TYPE.  */

ULONGEST
ada_modulus (struct type *type)
{
  return (ULONGEST) TYPE_HIGH_BOUND (type) + 1;
}


/* Ada exception catchpoint support:
   ---------------------------------

   We support 3 kinds of exception catchpoints:
     . catchpoints on Ada exceptions
     . catchpoints on unhandled Ada exceptions
     . catchpoints on failed assertions

   Exceptions raised during failed assertions, or unhandled exceptions
   could perfectly be caught with the general catchpoint on Ada exceptions.
   However, we can easily differentiate these two special cases, and having
   the option to distinguish these two cases from the rest can be useful
   to zero-in on certain situations.

   Exception catchpoints are a specialized form of breakpoint,
   since they rely on inserting breakpoints inside known routines
   of the GNAT runtime.  The implementation therefore uses a standard
   breakpoint structure of the BP_BREAKPOINT type, but with its own set
   of breakpoint_ops.

   Support in the runtime for exception catchpoints have been changed
   a few times already, and these changes affect the implementation
   of these catchpoints.  In order to be able to support several
   variants of the runtime, we use a sniffer that will determine
   the runtime variant used by the program being debugged.  */

/* Ada's standard exceptions.  */

static char *standard_exc[] = {
  "constraint_error",
  "program_error",
  "storage_error",
  "tasking_error"
};

typedef CORE_ADDR (ada_unhandled_exception_name_addr_ftype) (void);

/* A structure that describes how to support exception catchpoints
   for a given executable.  */

struct exception_support_info
{
   /* The name of the symbol to break on in order to insert
      a catchpoint on exceptions.  */
   const char *catch_exception_sym;

   /* The name of the symbol to break on in order to insert
      a catchpoint on unhandled exceptions.  */
   const char *catch_exception_unhandled_sym;

   /* The name of the symbol to break on in order to insert
      a catchpoint on failed assertions.  */
   const char *catch_assert_sym;

   /* Assuming that the inferior just triggered an unhandled exception
      catchpoint, this function is responsible for returning the address
      in inferior memory where the name of that exception is stored.
      Return zero if the address could not be computed.  */
   ada_unhandled_exception_name_addr_ftype *unhandled_exception_name_addr;
};

static CORE_ADDR ada_unhandled_exception_name_addr (void);
static CORE_ADDR ada_unhandled_exception_name_addr_from_raise (void);

/* The following exception support info structure describes how to
   implement exception catchpoints with the latest version of the
   Ada runtime (as of 2007-03-06).  */

static const struct exception_support_info default_exception_support_info =
{
  "__gnat_debug_raise_exception", /* catch_exception_sym */
  "__gnat_unhandled_exception", /* catch_exception_unhandled_sym */
  "__gnat_debug_raise_assert_failure", /* catch_assert_sym */
  ada_unhandled_exception_name_addr
};

/* The following exception support info structure describes how to
   implement exception catchpoints with a slightly older version
   of the Ada runtime.  */

static const struct exception_support_info exception_support_info_fallback =
{
  "__gnat_raise_nodefer_with_msg", /* catch_exception_sym */
  "__gnat_unhandled_exception", /* catch_exception_unhandled_sym */
  "system__assertions__raise_assert_failure",  /* catch_assert_sym */
  ada_unhandled_exception_name_addr_from_raise
};

/* Return nonzero if we can detect the exception support routines
   described in EINFO.

   This function errors out if an abnormal situation is detected
   (for instance, if we find the exception support routines, but
   that support is found to be incomplete).  */

static int
ada_has_this_exception_support (const struct exception_support_info *einfo)
{
  struct symbol *sym;

  /* The symbol we're looking up is provided by a unit in the GNAT runtime
     that should be compiled with debugging information.  As a result, we
     expect to find that symbol in the symtabs.  */

  sym = standard_lookup (einfo->catch_exception_sym, NULL, VAR_DOMAIN);
  if (sym == NULL)
    {
      /* Perhaps we did not find our symbol because the Ada runtime was
	 compiled without debugging info, or simply stripped of it.
	 It happens on some GNU/Linux distributions for instance, where
	 users have to install a separate debug package in order to get
	 the runtime's debugging info.  In that situation, let the user
	 know why we cannot insert an Ada exception catchpoint.

	 Note: Just for the purpose of inserting our Ada exception
	 catchpoint, we could rely purely on the associated minimal symbol.
	 But we would be operating in degraded mode anyway, since we are
	 still lacking the debugging info needed later on to extract
	 the name of the exception being raised (this name is printed in
	 the catchpoint message, and is also used when trying to catch
	 a specific exception).  We do not handle this case for now.  */
      struct minimal_symbol *msym
	= lookup_minimal_symbol (einfo->catch_exception_sym, NULL, NULL);

      if (msym && MSYMBOL_TYPE (msym) != mst_solib_trampoline)
	error (_("Your Ada runtime appears to be missing some debugging "
		 "information.\nCannot insert Ada exception catchpoint "
		 "in this configuration."));

      return 0;
    }

  /* Make sure that the symbol we found corresponds to a function.  */

  if (SYMBOL_CLASS (sym) != LOC_BLOCK)
    error (_("Symbol \"%s\" is not a function (class = %d)"),
           SYMBOL_LINKAGE_NAME (sym), SYMBOL_CLASS (sym));

  return 1;
}

/* Inspect the Ada runtime and determine which exception info structure
   should be used to provide support for exception catchpoints.

   This function will always set the per-inferior exception_info,
   or raise an error.  */

static void
ada_exception_support_info_sniffer (void)
{
  struct ada_inferior_data *data = get_ada_inferior_data (current_inferior ());

  /* If the exception info is already known, then no need to recompute it.  */
  if (data->exception_info != NULL)
    return;

  /* Check the latest (default) exception support info.  */
  if (ada_has_this_exception_support (&default_exception_support_info))
    {
      data->exception_info = &default_exception_support_info;
      return;
    }

  /* Try our fallback exception suport info.  */
  if (ada_has_this_exception_support (&exception_support_info_fallback))
    {
      data->exception_info = &exception_support_info_fallback;
      return;
    }

  /* Sometimes, it is normal for us to not be able to find the routine
     we are looking for.  This happens when the program is linked with
     the shared version of the GNAT runtime, and the program has not been
     started yet.  Inform the user of these two possible causes if
     applicable.  */

  if (ada_update_initial_language (language_unknown) != language_ada)
    error (_("Unable to insert catchpoint.  Is this an Ada main program?"));

  /* If the symbol does not exist, then check that the program is
     already started, to make sure that shared libraries have been
     loaded.  If it is not started, this may mean that the symbol is
     in a shared library.  */

  if (ptid_get_pid (inferior_ptid) == 0)
    error (_("Unable to insert catchpoint. Try to start the program first."));

  /* At this point, we know that we are debugging an Ada program and
     that the inferior has been started, but we still are not able to
     find the run-time symbols.  That can mean that we are in
     configurable run time mode, or that a-except as been optimized
     out by the linker...  In any case, at this point it is not worth
     supporting this feature.  */

  error (_("Cannot insert Ada exception catchpoints in this configuration."));
}

/* True iff FRAME is very likely to be that of a function that is
   part of the runtime system.  This is all very heuristic, but is
   intended to be used as advice as to what frames are uninteresting
   to most users.  */

static int
is_known_support_routine (struct frame_info *frame)
{
  struct symtab_and_line sal;
  char *func_name;
  enum language func_lang;
  int i;
  const char *fullname;

  /* If this code does not have any debugging information (no symtab),
     This cannot be any user code.  */

  find_frame_sal (frame, &sal);
  if (sal.symtab == NULL)
    return 1;

  /* If there is a symtab, but the associated source file cannot be
     located, then assume this is not user code:  Selecting a frame
     for which we cannot display the code would not be very helpful
     for the user.  This should also take care of case such as VxWorks
     where the kernel has some debugging info provided for a few units.  */

  fullname = symtab_to_fullname (sal.symtab);
  if (access (fullname, R_OK) != 0)
    return 1;

  /* Check the unit filename againt the Ada runtime file naming.
     We also check the name of the objfile against the name of some
     known system libraries that sometimes come with debugging info
     too.  */

  for (i = 0; known_runtime_file_name_patterns[i] != NULL; i += 1)
    {
      re_comp (known_runtime_file_name_patterns[i]);
      if (re_exec (lbasename (sal.symtab->filename)))
        return 1;
      if (sal.symtab->objfile != NULL
          && re_exec (objfile_name (sal.symtab->objfile)))
        return 1;
    }

  /* Check whether the function is a GNAT-generated entity.  */

  find_frame_funname (frame, &func_name, &func_lang, NULL);
  if (func_name == NULL)
    return 1;

  for (i = 0; known_auxiliary_function_name_patterns[i] != NULL; i += 1)
    {
      re_comp (known_auxiliary_function_name_patterns[i]);
      if (re_exec (func_name))
	{
	  xfree (func_name);
	  return 1;
	}
    }

  xfree (func_name);
  return 0;
}

/* Find the first frame that contains debugging information and that is not
   part of the Ada run-time, starting from FI and moving upward.  */

void
ada_find_printable_frame (struct frame_info *fi)
{
  for (; fi != NULL; fi = get_prev_frame (fi))
    {
      if (!is_known_support_routine (fi))
        {
          select_frame (fi);
          break;
        }
    }

}

/* Assuming that the inferior just triggered an unhandled exception
   catchpoint, return the address in inferior memory where the name
   of the exception is stored.
   
   Return zero if the address could not be computed.  */

static CORE_ADDR
ada_unhandled_exception_name_addr (void)
{
  return parse_and_eval_address ("e.full_name");
}

/* Same as ada_unhandled_exception_name_addr, except that this function
   should be used when the inferior uses an older version of the runtime,
   where the exception name needs to be extracted from a specific frame
   several frames up in the callstack.  */

static CORE_ADDR
ada_unhandled_exception_name_addr_from_raise (void)
{
  int frame_level;
  struct frame_info *fi;
  struct ada_inferior_data *data = get_ada_inferior_data (current_inferior ());
  struct cleanup *old_chain;

  /* To determine the name of this exception, we need to select
     the frame corresponding to RAISE_SYM_NAME.  This frame is
     at least 3 levels up, so we simply skip the first 3 frames
     without checking the name of their associated function.  */
  fi = get_current_frame ();
  for (frame_level = 0; frame_level < 3; frame_level += 1)
    if (fi != NULL)
      fi = get_prev_frame (fi); 

  old_chain = make_cleanup (null_cleanup, NULL);
  while (fi != NULL)
    {
      char *func_name;
      enum language func_lang;

      find_frame_funname (fi, &func_name, &func_lang, NULL);
      if (func_name != NULL)
	{
	  make_cleanup (xfree, func_name);

          if (strcmp (func_name,
		      data->exception_info->catch_exception_sym) == 0)
	    break; /* We found the frame we were looking for...  */
	  fi = get_prev_frame (fi);
	}
    }
  do_cleanups (old_chain);

  if (fi == NULL)
    return 0;

  select_frame (fi);
  return parse_and_eval_address ("id.full_name");
}

/* Assuming the inferior just triggered an Ada exception catchpoint
   (of any type), return the address in inferior memory where the name
   of the exception is stored, if applicable.

   Return zero if the address could not be computed, or if not relevant.  */

static CORE_ADDR
ada_exception_name_addr_1 (enum ada_exception_catchpoint_kind ex,
                           struct breakpoint *b)
{
  struct ada_inferior_data *data = get_ada_inferior_data (current_inferior ());

  switch (ex)
    {
      case ada_catch_exception:
        return (parse_and_eval_address ("e.full_name"));
        break;

      case ada_catch_exception_unhandled:
        return data->exception_info->unhandled_exception_name_addr ();
        break;
      
      case ada_catch_assert:
        return 0;  /* Exception name is not relevant in this case.  */
        break;

      default:
        internal_error (__FILE__, __LINE__, _("unexpected catchpoint type"));
        break;
    }

  return 0; /* Should never be reached.  */
}

/* Same as ada_exception_name_addr_1, except that it intercepts and contains
   any error that ada_exception_name_addr_1 might cause to be thrown.
   When an error is intercepted, a warning with the error message is printed,
   and zero is returned.  */

static CORE_ADDR
ada_exception_name_addr (enum ada_exception_catchpoint_kind ex,
                         struct breakpoint *b)
{
  volatile struct gdb_exception e;
  CORE_ADDR result = 0;

  TRY_CATCH (e, RETURN_MASK_ERROR)
    {
      result = ada_exception_name_addr_1 (ex, b);
    }

  if (e.reason < 0)
    {
      warning (_("failed to get exception name: %s"), e.message);
      return 0;
    }

  return result;
}

static char *ada_exception_catchpoint_cond_string (const char *excep_string);

/* Ada catchpoints.

   In the case of catchpoints on Ada exceptions, the catchpoint will
   stop the target on every exception the program throws.  When a user
   specifies the name of a specific exception, we translate this
   request into a condition expression (in text form), and then parse
   it into an expression stored in each of the catchpoint's locations.
   We then use this condition to check whether the exception that was
   raised is the one the user is interested in.  If not, then the
   target is resumed again.  We store the name of the requested
   exception, in order to be able to re-set the condition expression
   when symbols change.  */

/* An instance of this type is used to represent an Ada catchpoint
   breakpoint location.  It includes a "struct bp_location" as a kind
   of base class; users downcast to "struct bp_location *" when
   needed.  */

struct ada_catchpoint_location
{
  /* The base class.  */
  struct bp_location base;

  /* The condition that checks whether the exception that was raised
     is the specific exception the user specified on catchpoint
     creation.  */
  struct expression *excep_cond_expr;
};

/* Implement the DTOR method in the bp_location_ops structure for all
   Ada exception catchpoint kinds.  */

static void
ada_catchpoint_location_dtor (struct bp_location *bl)
{
  struct ada_catchpoint_location *al = (struct ada_catchpoint_location *) bl;

  xfree (al->excep_cond_expr);
}

/* The vtable to be used in Ada catchpoint locations.  */

static const struct bp_location_ops ada_catchpoint_location_ops =
{
  ada_catchpoint_location_dtor
};

/* An instance of this type is used to represent an Ada catchpoint.
   It includes a "struct breakpoint" as a kind of base class; users
   downcast to "struct breakpoint *" when needed.  */

struct ada_catchpoint
{
  /* The base class.  */
  struct breakpoint base;

  /* The name of the specific exception the user specified.  */
  char *excep_string;
};

/* Parse the exception condition string in the context of each of the
   catchpoint's locations, and store them for later evaluation.  */

static void
create_excep_cond_exprs (struct ada_catchpoint *c)
{
  struct cleanup *old_chain;
  struct bp_location *bl;
  char *cond_string;

  /* Nothing to do if there's no specific exception to catch.  */
  if (c->excep_string == NULL)
    return;

  /* Same if there are no locations... */
  if (c->base.loc == NULL)
    return;

  /* Compute the condition expression in text form, from the specific
     expection we want to catch.  */
  cond_string = ada_exception_catchpoint_cond_string (c->excep_string);
  old_chain = make_cleanup (xfree, cond_string);

  /* Iterate over all the catchpoint's locations, and parse an
     expression for each.  */
  for (bl = c->base.loc; bl != NULL; bl = bl->next)
    {
      struct ada_catchpoint_location *ada_loc
	= (struct ada_catchpoint_location *) bl;
      struct expression *exp = NULL;

      if (!bl->shlib_disabled)
	{
	  volatile struct gdb_exception e;
	  const char *s;

	  s = cond_string;
	  TRY_CATCH (e, RETURN_MASK_ERROR)
	    {
	      exp = parse_exp_1 (&s, bl->address,
				 block_for_pc (bl->address), 0);
	    }
	  if (e.reason < 0)
	    warning (_("failed to reevaluate internal exception condition "
		       "for catchpoint %d: %s"),
		     c->base.number, e.message);
	}

      ada_loc->excep_cond_expr = exp;
    }

  do_cleanups (old_chain);
}

/* Implement the DTOR method in the breakpoint_ops structure for all
   exception catchpoint kinds.  */

static void
dtor_exception (enum ada_exception_catchpoint_kind ex, struct breakpoint *b)
{
  struct ada_catchpoint *c = (struct ada_catchpoint *) b;

  xfree (c->excep_string);

  bkpt_breakpoint_ops.dtor (b);
}

/* Implement the ALLOCATE_LOCATION method in the breakpoint_ops
   structure for all exception catchpoint kinds.  */

static struct bp_location *
allocate_location_exception (enum ada_exception_catchpoint_kind ex,
			     struct breakpoint *self)
{
  struct ada_catchpoint_location *loc;

  loc = XNEW (struct ada_catchpoint_location);
  init_bp_location (&loc->base, &ada_catchpoint_location_ops, self);
  loc->excep_cond_expr = NULL;
  return &loc->base;
}

/* Implement the RE_SET method in the breakpoint_ops structure for all
   exception catchpoint kinds.  */

static void
re_set_exception (enum ada_exception_catchpoint_kind ex, struct breakpoint *b)
{
  struct ada_catchpoint *c = (struct ada_catchpoint *) b;

  /* Call the base class's method.  This updates the catchpoint's
     locations.  */
  bkpt_breakpoint_ops.re_set (b);

  /* Reparse the exception conditional expressions.  One for each
     location.  */
  create_excep_cond_exprs (c);
}

/* Returns true if we should stop for this breakpoint hit.  If the
   user specified a specific exception, we only want to cause a stop
   if the program thrown that exception.  */

static int
should_stop_exception (const struct bp_location *bl)
{
  struct ada_catchpoint *c = (struct ada_catchpoint *) bl->owner;
  const struct ada_catchpoint_location *ada_loc
    = (const struct ada_catchpoint_location *) bl;
  volatile struct gdb_exception ex;
  int stop;

  /* With no specific exception, should always stop.  */
  if (c->excep_string == NULL)
    return 1;

  if (ada_loc->excep_cond_expr == NULL)
    {
      /* We will have a NULL expression if back when we were creating
	 the expressions, this location's had failed to parse.  */
      return 1;
    }

  stop = 1;
  TRY_CATCH (ex, RETURN_MASK_ALL)
    {
      struct value *mark;

      mark = value_mark ();
      stop = value_true (evaluate_expression (ada_loc->excep_cond_expr));
      value_free_to_mark (mark);
    }
  if (ex.reason < 0)
    exception_fprintf (gdb_stderr, ex,
		       _("Error in testing exception condition:\n"));
  return stop;
}

/* Implement the CHECK_STATUS method in the breakpoint_ops structure
   for all exception catchpoint kinds.  */

static void
check_status_exception (enum ada_exception_catchpoint_kind ex, bpstat bs)
{
  bs->stop = should_stop_exception (bs->bp_location_at);
}

/* Implement the PRINT_IT method in the breakpoint_ops structure
   for all exception catchpoint kinds.  */

static enum print_stop_action
print_it_exception (enum ada_exception_catchpoint_kind ex, bpstat bs)
{
  struct ui_out *uiout = current_uiout;
  struct breakpoint *b = bs->breakpoint_at;

  annotate_catchpoint (b->number);

  if (ui_out_is_mi_like_p (uiout))
    {
      ui_out_field_string (uiout, "reason",
			   async_reason_lookup (EXEC_ASYNC_BREAKPOINT_HIT));
      ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));
    }

  ui_out_text (uiout,
               b->disposition == disp_del ? "\nTemporary catchpoint "
	                                  : "\nCatchpoint ");
  ui_out_field_int (uiout, "bkptno", b->number);
  ui_out_text (uiout, ", ");

  switch (ex)
    {
      case ada_catch_exception:
      case ada_catch_exception_unhandled:
	{
	  const CORE_ADDR addr = ada_exception_name_addr (ex, b);
	  char exception_name[256];

	  if (addr != 0)
	    {
	      read_memory (addr, (gdb_byte *) exception_name,
			   sizeof (exception_name) - 1);
	      exception_name [sizeof (exception_name) - 1] = '\0';
	    }
	  else
	    {
	      /* For some reason, we were unable to read the exception
		 name.  This could happen if the Runtime was compiled
		 without debugging info, for instance.  In that case,
		 just replace the exception name by the generic string
		 "exception" - it will read as "an exception" in the
		 notification we are about to print.  */
	      memcpy (exception_name, "exception", sizeof ("exception"));
	    }
	  /* In the case of unhandled exception breakpoints, we print
	     the exception name as "unhandled EXCEPTION_NAME", to make
	     it clearer to the user which kind of catchpoint just got
	     hit.  We used ui_out_text to make sure that this extra
	     info does not pollute the exception name in the MI case.  */
	  if (ex == ada_catch_exception_unhandled)
	    ui_out_text (uiout, "unhandled ");
	  ui_out_field_string (uiout, "exception-name", exception_name);
	}
	break;
      case ada_catch_assert:
	/* In this case, the name of the exception is not really
	   important.  Just print "failed assertion" to make it clearer
	   that his program just hit an assertion-failure catchpoint.
	   We used ui_out_text because this info does not belong in
	   the MI output.  */
	ui_out_text (uiout, "failed assertion");
	break;
    }
  ui_out_text (uiout, " at ");
  ada_find_printable_frame (get_current_frame ());

  return PRINT_SRC_AND_LOC;
}

/* Implement the PRINT_ONE method in the breakpoint_ops structure
   for all exception catchpoint kinds.  */

static void
print_one_exception (enum ada_exception_catchpoint_kind ex,
                     struct breakpoint *b, struct bp_location **last_loc)
{ 
  struct ui_out *uiout = current_uiout;
  struct ada_catchpoint *c = (struct ada_catchpoint *) b;
  struct value_print_options opts;

  get_user_print_options (&opts);
  if (opts.addressprint)
    {
      annotate_field (4);
      ui_out_field_core_addr (uiout, "addr", b->loc->gdbarch, b->loc->address);
    }

  annotate_field (5);
  *last_loc = b->loc;
  switch (ex)
    {
      case ada_catch_exception:
        if (c->excep_string != NULL)
          {
            char *msg = xstrprintf (_("`%s' Ada exception"), c->excep_string);

            ui_out_field_string (uiout, "what", msg);
            xfree (msg);
          }
        else
          ui_out_field_string (uiout, "what", "all Ada exceptions");
        
        break;

      case ada_catch_exception_unhandled:
        ui_out_field_string (uiout, "what", "unhandled Ada exceptions");
        break;
      
      case ada_catch_assert:
        ui_out_field_string (uiout, "what", "failed Ada assertions");
        break;

      default:
        internal_error (__FILE__, __LINE__, _("unexpected catchpoint type"));
        break;
    }
}

/* Implement the PRINT_MENTION method in the breakpoint_ops structure
   for all exception catchpoint kinds.  */

static void
print_mention_exception (enum ada_exception_catchpoint_kind ex,
                         struct breakpoint *b)
{
  struct ada_catchpoint *c = (struct ada_catchpoint *) b;
  struct ui_out *uiout = current_uiout;

  ui_out_text (uiout, b->disposition == disp_del ? _("Temporary catchpoint ")
                                                 : _("Catchpoint "));
  ui_out_field_int (uiout, "bkptno", b->number);
  ui_out_text (uiout, ": ");

  switch (ex)
    {
      case ada_catch_exception:
        if (c->excep_string != NULL)
	  {
	    char *info = xstrprintf (_("`%s' Ada exception"), c->excep_string);
	    struct cleanup *old_chain = make_cleanup (xfree, info);

	    ui_out_text (uiout, info);
	    do_cleanups (old_chain);
	  }
        else
          ui_out_text (uiout, _("all Ada exceptions"));
        break;

      case ada_catch_exception_unhandled:
        ui_out_text (uiout, _("unhandled Ada exceptions"));
        break;
      
      case ada_catch_assert:
        ui_out_text (uiout, _("failed Ada assertions"));
        break;

      default:
        internal_error (__FILE__, __LINE__, _("unexpected catchpoint type"));
        break;
    }
}

/* Implement the PRINT_RECREATE method in the breakpoint_ops structure
   for all exception catchpoint kinds.  */

static void
print_recreate_exception (enum ada_exception_catchpoint_kind ex,
			  struct breakpoint *b, struct ui_file *fp)
{
  struct ada_catchpoint *c = (struct ada_catchpoint *) b;

  switch (ex)
    {
      case ada_catch_exception:
	fprintf_filtered (fp, "catch exception");
	if (c->excep_string != NULL)
	  fprintf_filtered (fp, " %s", c->excep_string);
	break;

      case ada_catch_exception_unhandled:
	fprintf_filtered (fp, "catch exception unhandled");
	break;

      case ada_catch_assert:
	fprintf_filtered (fp, "catch assert");
	break;

      default:
	internal_error (__FILE__, __LINE__, _("unexpected catchpoint type"));
    }
  print_recreate_thread (b, fp);
}

/* Virtual table for "catch exception" breakpoints.  */

static void
dtor_catch_exception (struct breakpoint *b)
{
  dtor_exception (ada_catch_exception, b);
}

static struct bp_location *
allocate_location_catch_exception (struct breakpoint *self)
{
  return allocate_location_exception (ada_catch_exception, self);
}

static void
re_set_catch_exception (struct breakpoint *b)
{
  re_set_exception (ada_catch_exception, b);
}

static void
check_status_catch_exception (bpstat bs)
{
  check_status_exception (ada_catch_exception, bs);
}

static enum print_stop_action
print_it_catch_exception (bpstat bs)
{
  return print_it_exception (ada_catch_exception, bs);
}

static void
print_one_catch_exception (struct breakpoint *b, struct bp_location **last_loc)
{
  print_one_exception (ada_catch_exception, b, last_loc);
}

static void
print_mention_catch_exception (struct breakpoint *b)
{
  print_mention_exception (ada_catch_exception, b);
}

static void
print_recreate_catch_exception (struct breakpoint *b, struct ui_file *fp)
{
  print_recreate_exception (ada_catch_exception, b, fp);
}

static struct breakpoint_ops catch_exception_breakpoint_ops;

/* Virtual table for "catch exception unhandled" breakpoints.  */

static void
dtor_catch_exception_unhandled (struct breakpoint *b)
{
  dtor_exception (ada_catch_exception_unhandled, b);
}

static struct bp_location *
allocate_location_catch_exception_unhandled (struct breakpoint *self)
{
  return allocate_location_exception (ada_catch_exception_unhandled, self);
}

static void
re_set_catch_exception_unhandled (struct breakpoint *b)
{
  re_set_exception (ada_catch_exception_unhandled, b);
}

static void
check_status_catch_exception_unhandled (bpstat bs)
{
  check_status_exception (ada_catch_exception_unhandled, bs);
}

static enum print_stop_action
print_it_catch_exception_unhandled (bpstat bs)
{
  return print_it_exception (ada_catch_exception_unhandled, bs);
}

static void
print_one_catch_exception_unhandled (struct breakpoint *b,
				     struct bp_location **last_loc)
{
  print_one_exception (ada_catch_exception_unhandled, b, last_loc);
}

static void
print_mention_catch_exception_unhandled (struct breakpoint *b)
{
  print_mention_exception (ada_catch_exception_unhandled, b);
}

static void
print_recreate_catch_exception_unhandled (struct breakpoint *b,
					  struct ui_file *fp)
{
  print_recreate_exception (ada_catch_exception_unhandled, b, fp);
}

static struct breakpoint_ops catch_exception_unhandled_breakpoint_ops;

/* Virtual table for "catch assert" breakpoints.  */

static void
dtor_catch_assert (struct breakpoint *b)
{
  dtor_exception (ada_catch_assert, b);
}

static struct bp_location *
allocate_location_catch_assert (struct breakpoint *self)
{
  return allocate_location_exception (ada_catch_assert, self);
}

static void
re_set_catch_assert (struct breakpoint *b)
{
  re_set_exception (ada_catch_assert, b);
}

static void
check_status_catch_assert (bpstat bs)
{
  check_status_exception (ada_catch_assert, bs);
}

static enum print_stop_action
print_it_catch_assert (bpstat bs)
{
  return print_it_exception (ada_catch_assert, bs);
}

static void
print_one_catch_assert (struct breakpoint *b, struct bp_location **last_loc)
{
  print_one_exception (ada_catch_assert, b, last_loc);
}

static void
print_mention_catch_assert (struct breakpoint *b)
{
  print_mention_exception (ada_catch_assert, b);
}

static void
print_recreate_catch_assert (struct breakpoint *b, struct ui_file *fp)
{
  print_recreate_exception (ada_catch_assert, b, fp);
}

static struct breakpoint_ops catch_assert_breakpoint_ops;

/* Return a newly allocated copy of the first space-separated token
   in ARGSP, and then adjust ARGSP to point immediately after that
   token.

   Return NULL if ARGPS does not contain any more tokens.  */

static char *
ada_get_next_arg (char **argsp)
{
  char *args = *argsp;
  char *end;
  char *result;

  args = skip_spaces (args);
  if (args[0] == '\0')
    return NULL; /* No more arguments.  */
  
  /* Find the end of the current argument.  */

  end = skip_to_space (args);

  /* Adjust ARGSP to point to the start of the next argument.  */

  *argsp = end;

  /* Make a copy of the current argument and return it.  */

  result = xmalloc (end - args + 1);
  strncpy (result, args, end - args);
  result[end - args] = '\0';
  
  return result;
}

/* Split the arguments specified in a "catch exception" command.  
   Set EX to the appropriate catchpoint type.
   Set EXCEP_STRING to the name of the specific exception if
   specified by the user.
   If a condition is found at the end of the arguments, the condition
   expression is stored in COND_STRING (memory must be deallocated
   after use).  Otherwise COND_STRING is set to NULL.  */

static void
catch_ada_exception_command_split (char *args,
                                   enum ada_exception_catchpoint_kind *ex,
				   char **excep_string,
				   char **cond_string)
{
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  char *exception_name;
  char *cond = NULL;

  exception_name = ada_get_next_arg (&args);
  if (exception_name != NULL && strcmp (exception_name, "if") == 0)
    {
      /* This is not an exception name; this is the start of a condition
	 expression for a catchpoint on all exceptions.  So, "un-get"
	 this token, and set exception_name to NULL.  */
      xfree (exception_name);
      exception_name = NULL;
      args -= 2;
    }
  make_cleanup (xfree, exception_name);

  /* Check to see if we have a condition.  */

  args = skip_spaces (args);
  if (strncmp (args, "if", 2) == 0
      && (isspace (args[2]) || args[2] == '\0'))
    {
      args += 2;
      args = skip_spaces (args);

      if (args[0] == '\0')
        error (_("Condition missing after `if' keyword"));
      cond = xstrdup (args);
      make_cleanup (xfree, cond);

      args += strlen (args);
    }

  /* Check that we do not have any more arguments.  Anything else
     is unexpected.  */

  if (args[0] != '\0')
    error (_("Junk at end of expression"));

  discard_cleanups (old_chain);

  if (exception_name == NULL)
    {
      /* Catch all exceptions.  */
      *ex = ada_catch_exception;
      *excep_string = NULL;
    }
  else if (strcmp (exception_name, "unhandled") == 0)
    {
      /* Catch unhandled exceptions.  */
      *ex = ada_catch_exception_unhandled;
      *excep_string = NULL;
    }
  else
    {
      /* Catch a specific exception.  */
      *ex = ada_catch_exception;
      *excep_string = exception_name;
    }
  *cond_string = cond;
}

/* Return the name of the symbol on which we should break in order to
   implement a catchpoint of the EX kind.  */

static const char *
ada_exception_sym_name (enum ada_exception_catchpoint_kind ex)
{
  struct ada_inferior_data *data = get_ada_inferior_data (current_inferior ());

  gdb_assert (data->exception_info != NULL);

  switch (ex)
    {
      case ada_catch_exception:
        return (data->exception_info->catch_exception_sym);
        break;
      case ada_catch_exception_unhandled:
        return (data->exception_info->catch_exception_unhandled_sym);
        break;
      case ada_catch_assert:
        return (data->exception_info->catch_assert_sym);
        break;
      default:
        internal_error (__FILE__, __LINE__,
                        _("unexpected catchpoint kind (%d)"), ex);
    }
}

/* Return the breakpoint ops "virtual table" used for catchpoints
   of the EX kind.  */

static const struct breakpoint_ops *
ada_exception_breakpoint_ops (enum ada_exception_catchpoint_kind ex)
{
  switch (ex)
    {
      case ada_catch_exception:
        return (&catch_exception_breakpoint_ops);
        break;
      case ada_catch_exception_unhandled:
        return (&catch_exception_unhandled_breakpoint_ops);
        break;
      case ada_catch_assert:
        return (&catch_assert_breakpoint_ops);
        break;
      default:
        internal_error (__FILE__, __LINE__,
                        _("unexpected catchpoint kind (%d)"), ex);
    }
}

/* Return the condition that will be used to match the current exception
   being raised with the exception that the user wants to catch.  This
   assumes that this condition is used when the inferior just triggered
   an exception catchpoint.
   
   The string returned is a newly allocated string that needs to be
   deallocated later.  */

static char *
ada_exception_catchpoint_cond_string (const char *excep_string)
{
  int i;

  /* The standard exceptions are a special case.  They are defined in
     runtime units that have been compiled without debugging info; if
     EXCEP_STRING is the not-fully-qualified name of a standard
     exception (e.g. "constraint_error") then, during the evaluation
     of the condition expression, the symbol lookup on this name would
     *not* return this standard exception.  The catchpoint condition
     may then be set only on user-defined exceptions which have the
     same not-fully-qualified name (e.g. my_package.constraint_error).

     To avoid this unexcepted behavior, these standard exceptions are
     systematically prefixed by "standard".  This means that "catch
     exception constraint_error" is rewritten into "catch exception
     standard.constraint_error".

     If an exception named contraint_error is defined in another package of
     the inferior program, then the only way to specify this exception as a
     breakpoint condition is to use its fully-qualified named:
     e.g. my_package.constraint_error.  */

  for (i = 0; i < sizeof (standard_exc) / sizeof (char *); i++)
    {
      if (strcmp (standard_exc [i], excep_string) == 0)
	{
          return xstrprintf ("long_integer (e) = long_integer (&standard.%s)",
                             excep_string);
	}
    }
  return xstrprintf ("long_integer (e) = long_integer (&%s)", excep_string);
}

/* Return the symtab_and_line that should be used to insert an exception
   catchpoint of the TYPE kind.

   EXCEP_STRING should contain the name of a specific exception that
   the catchpoint should catch, or NULL otherwise.

   ADDR_STRING returns the name of the function where the real
   breakpoint that implements the catchpoints is set, depending on the
   type of catchpoint we need to create.  */

static struct symtab_and_line
ada_exception_sal (enum ada_exception_catchpoint_kind ex, char *excep_string,
		   char **addr_string, const struct breakpoint_ops **ops)
{
  const char *sym_name;
  struct symbol *sym;

  /* First, find out which exception support info to use.  */
  ada_exception_support_info_sniffer ();

  /* Then lookup the function on which we will break in order to catch
     the Ada exceptions requested by the user.  */
  sym_name = ada_exception_sym_name (ex);
  sym = standard_lookup (sym_name, NULL, VAR_DOMAIN);

  /* We can assume that SYM is not NULL at this stage.  If the symbol
     did not exist, ada_exception_support_info_sniffer would have
     raised an exception.

     Also, ada_exception_support_info_sniffer should have already
     verified that SYM is a function symbol.  */
  gdb_assert (sym != NULL);
  gdb_assert (SYMBOL_CLASS (sym) == LOC_BLOCK);

  /* Set ADDR_STRING.  */
  *addr_string = xstrdup (sym_name);

  /* Set OPS.  */
  *ops = ada_exception_breakpoint_ops (ex);

  return find_function_start_sal (sym, 1);
}

/* Create an Ada exception catchpoint.

   EX_KIND is the kind of exception catchpoint to be created.

   EXCEPT_STRING, if not NULL, indicates the name of the exception
   to which this catchpoint applies.  If NULL, this catchpoint is
   expected to trigger for all exceptions.

   COND_STRING, if not NULL, is the catchpoint condition.

   TEMPFLAG, if nonzero, means that the underlying breakpoint
   should be temporary.

   FROM_TTY is the usual argument passed to all commands implementations.  */

void
create_ada_exception_catchpoint (struct gdbarch *gdbarch,
				 enum ada_exception_catchpoint_kind ex_kind,
				 char *excep_string,
				 char *cond_string,
				 int tempflag,
				 int disabled,
				 int from_tty)
{
  struct ada_catchpoint *c;
  char *addr_string = NULL;
  const struct breakpoint_ops *ops = NULL;
  struct symtab_and_line sal
    = ada_exception_sal (ex_kind, excep_string, &addr_string, &ops);

  c = XNEW (struct ada_catchpoint);
  init_ada_exception_breakpoint (&c->base, gdbarch, sal, addr_string,
				 ops, tempflag, disabled, from_tty);
  c->excep_string = excep_string;
  create_excep_cond_exprs (c);
  if (cond_string != NULL)
    set_breakpoint_condition (&c->base, cond_string, from_tty);
  install_breakpoint (0, &c->base, 1);
}

/* Implement the "catch exception" command.  */

static void
catch_ada_exception_command (char *arg, int from_tty,
			     struct cmd_list_element *command)
{
  struct gdbarch *gdbarch = get_current_arch ();
  int tempflag;
  enum ada_exception_catchpoint_kind ex_kind;
  char *excep_string = NULL;
  char *cond_string = NULL;

  tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

  if (!arg)
    arg = "";
  catch_ada_exception_command_split (arg, &ex_kind, &excep_string,
				     &cond_string);
  create_ada_exception_catchpoint (gdbarch, ex_kind,
				   excep_string, cond_string,
				   tempflag, 1 /* enabled */,
				   from_tty);
}

/* Split the arguments specified in a "catch assert" command.

   ARGS contains the command's arguments (or the empty string if
   no arguments were passed).

   If ARGS contains a condition, set COND_STRING to that condition
   (the memory needs to be deallocated after use).  */

static void
catch_ada_assert_command_split (char *args, char **cond_string)
{
  args = skip_spaces (args);

  /* Check whether a condition was provided.  */
  if (strncmp (args, "if", 2) == 0
      && (isspace (args[2]) || args[2] == '\0'))
    {
      args += 2;
      args = skip_spaces (args);
      if (args[0] == '\0')
        error (_("condition missing after `if' keyword"));
      *cond_string = xstrdup (args);
    }

  /* Otherwise, there should be no other argument at the end of
     the command.  */
  else if (args[0] != '\0')
    error (_("Junk at end of arguments."));
}

/* Implement the "catch assert" command.  */

static void
catch_assert_command (char *arg, int from_tty,
		      struct cmd_list_element *command)
{
  struct gdbarch *gdbarch = get_current_arch ();
  int tempflag;
  char *cond_string = NULL;

  tempflag = get_cmd_context (command) == CATCH_TEMPORARY;

  if (!arg)
    arg = "";
  catch_ada_assert_command_split (arg, &cond_string);
  create_ada_exception_catchpoint (gdbarch, ada_catch_assert,
				   NULL, cond_string,
				   tempflag, 1 /* enabled */,
				   from_tty);
}
                                /* Operators */
/* Information about operators given special treatment in functions
   below.  */
/* Format: OP_DEFN (<operator>, <operator length>, <# args>, <binop>).  */

#define ADA_OPERATORS \
    OP_DEFN (OP_VAR_VALUE, 4, 0, 0) \
    OP_DEFN (BINOP_IN_BOUNDS, 3, 2, 0) \
    OP_DEFN (TERNOP_IN_RANGE, 1, 3, 0) \
    OP_DEFN (OP_ATR_FIRST, 1, 2, 0) \
    OP_DEFN (OP_ATR_LAST, 1, 2, 0) \
    OP_DEFN (OP_ATR_LENGTH, 1, 2, 0) \
    OP_DEFN (OP_ATR_IMAGE, 1, 2, 0) \
    OP_DEFN (OP_ATR_MAX, 1, 3, 0) \
    OP_DEFN (OP_ATR_MIN, 1, 3, 0) \
    OP_DEFN (OP_ATR_MODULUS, 1, 1, 0) \
    OP_DEFN (OP_ATR_POS, 1, 2, 0) \
    OP_DEFN (OP_ATR_SIZE, 1, 1, 0) \
    OP_DEFN (OP_ATR_TAG, 1, 1, 0) \
    OP_DEFN (OP_ATR_VAL, 1, 2, 0) \
    OP_DEFN (UNOP_QUAL, 3, 1, 0) \
    OP_DEFN (UNOP_IN_RANGE, 3, 1, 0) \
    OP_DEFN (OP_OTHERS, 1, 1, 0) \
    OP_DEFN (OP_POSITIONAL, 3, 1, 0) \
    OP_DEFN (OP_DISCRETE_RANGE, 1, 2, 0)

static void
ada_operator_length (const struct expression *exp, int pc, int *oplenp,
		     int *argsp)
{
  switch (exp->elts[pc - 1].opcode)
    {
    default:
      operator_length_standard (exp, pc, oplenp, argsp);
      break;

#define OP_DEFN(op, len, args, binop) \
    case op: *oplenp = len; *argsp = args; break;
      ADA_OPERATORS;
#undef OP_DEFN

    case OP_AGGREGATE:
      *oplenp = 3;
      *argsp = longest_to_int (exp->elts[pc - 2].longconst);
      break;

    case OP_CHOICES:
      *oplenp = 3;
      *argsp = longest_to_int (exp->elts[pc - 2].longconst) + 1;
      break;
    }
}

/* Implementation of the exp_descriptor method operator_check.  */

static int
ada_operator_check (struct expression *exp, int pos,
		    int (*objfile_func) (struct objfile *objfile, void *data),
		    void *data)
{
  const union exp_element *const elts = exp->elts;
  struct type *type = NULL;

  switch (elts[pos].opcode)
    {
      case UNOP_IN_RANGE:
      case UNOP_QUAL:
	type = elts[pos + 1].type;
	break;

      default:
	return operator_check_standard (exp, pos, objfile_func, data);
    }

  /* Invoke callbacks for TYPE and OBJFILE if they were set as non-NULL.  */

  if (type && TYPE_OBJFILE (type)
      && (*objfile_func) (TYPE_OBJFILE (type), data))
    return 1;

  return 0;
}

static char *
ada_op_name (enum exp_opcode opcode)
{
  switch (opcode)
    {
    default:
      return op_name_standard (opcode);

#define OP_DEFN(op, len, args, binop) case op: return #op;
      ADA_OPERATORS;
#undef OP_DEFN

    case OP_AGGREGATE:
      return "OP_AGGREGATE";
    case OP_CHOICES:
      return "OP_CHOICES";
    case OP_NAME:
      return "OP_NAME";
    }
}

/* As for operator_length, but assumes PC is pointing at the first
   element of the operator, and gives meaningful results only for the 
   Ada-specific operators, returning 0 for *OPLENP and *ARGSP otherwise.  */

static void
ada_forward_operator_length (struct expression *exp, int pc,
                             int *oplenp, int *argsp)
{
  switch (exp->elts[pc].opcode)
    {
    default:
      *oplenp = *argsp = 0;
      break;

#define OP_DEFN(op, len, args, binop) \
    case op: *oplenp = len; *argsp = args; break;
      ADA_OPERATORS;
#undef OP_DEFN

    case OP_AGGREGATE:
      *oplenp = 3;
      *argsp = longest_to_int (exp->elts[pc + 1].longconst);
      break;

    case OP_CHOICES:
      *oplenp = 3;
      *argsp = longest_to_int (exp->elts[pc + 1].longconst) + 1;
      break;

    case OP_STRING:
    case OP_NAME:
      {
	int len = longest_to_int (exp->elts[pc + 1].longconst);

	*oplenp = 4 + BYTES_TO_EXP_ELEM (len + 1);
	*argsp = 0;
	break;
      }
    }
}

static int
ada_dump_subexp_body (struct expression *exp, struct ui_file *stream, int elt)
{
  enum exp_opcode op = exp->elts[elt].opcode;
  int oplen, nargs;
  int pc = elt;
  int i;

  ada_forward_operator_length (exp, elt, &oplen, &nargs);

  switch (op)
    {
      /* Ada attributes ('Foo).  */
    case OP_ATR_FIRST:
    case OP_ATR_LAST:
    case OP_ATR_LENGTH:
    case OP_ATR_IMAGE:
    case OP_ATR_MAX:
    case OP_ATR_MIN:
    case OP_ATR_MODULUS:
    case OP_ATR_POS:
    case OP_ATR_SIZE:
    case OP_ATR_TAG:
    case OP_ATR_VAL:
      break;

    case UNOP_IN_RANGE:
    case UNOP_QUAL:
      /* XXX: gdb_sprint_host_address, type_sprint */
      fprintf_filtered (stream, _("Type @@"));
      gdb_print_host_address (exp->elts[pc + 1].type, stream);
      fprintf_filtered (stream, " (");
      type_print (exp->elts[pc + 1].type, NULL, stream, 0);
      fprintf_filtered (stream, ")");
      break;
    case BINOP_IN_BOUNDS:
      fprintf_filtered (stream, " (%d)",
			longest_to_int (exp->elts[pc + 2].longconst));
      break;
    case TERNOP_IN_RANGE:
      break;

    case OP_AGGREGATE:
    case OP_OTHERS:
    case OP_DISCRETE_RANGE:
    case OP_POSITIONAL:
    case OP_CHOICES:
      break;

    case OP_NAME:
    case OP_STRING:
      {
	char *name = &exp->elts[elt + 2].string;
	int len = longest_to_int (exp->elts[elt + 1].longconst);

	fprintf_filtered (stream, "Text: `%.*s'", len, name);
	break;
      }

    default:
      return dump_subexp_body_standard (exp, stream, elt);
    }

  elt += oplen;
  for (i = 0; i < nargs; i += 1)
    elt = dump_subexp (exp, stream, elt);

  return elt;
}

/* The Ada extension of print_subexp (q.v.).  */

static void
ada_print_subexp (struct expression *exp, int *pos,
                  struct ui_file *stream, enum precedence prec)
{
  int oplen, nargs, i;
  int pc = *pos;
  enum exp_opcode op = exp->elts[pc].opcode;

  ada_forward_operator_length (exp, pc, &oplen, &nargs);

  *pos += oplen;
  switch (op)
    {
    default:
      *pos -= oplen;
      print_subexp_standard (exp, pos, stream, prec);
      return;

    case OP_VAR_VALUE:
      fputs_filtered (SYMBOL_NATURAL_NAME (exp->elts[pc + 2].symbol), stream);
      return;

    case BINOP_IN_BOUNDS:
      /* XXX: sprint_subexp */
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered (" in ", stream);
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered ("'range", stream);
      if (exp->elts[pc + 1].longconst > 1)
        fprintf_filtered (stream, "(%ld)",
                          (long) exp->elts[pc + 1].longconst);
      return;

    case TERNOP_IN_RANGE:
      if (prec >= PREC_EQUAL)
        fputs_filtered ("(", stream);
      /* XXX: sprint_subexp */
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered (" in ", stream);
      print_subexp (exp, pos, stream, PREC_EQUAL);
      fputs_filtered (" .. ", stream);
      print_subexp (exp, pos, stream, PREC_EQUAL);
      if (prec >= PREC_EQUAL)
        fputs_filtered (")", stream);
      return;

    case OP_ATR_FIRST:
    case OP_ATR_LAST:
    case OP_ATR_LENGTH:
    case OP_ATR_IMAGE:
    case OP_ATR_MAX:
    case OP_ATR_MIN:
    case OP_ATR_MODULUS:
    case OP_ATR_POS:
    case OP_ATR_SIZE:
    case OP_ATR_TAG:
    case OP_ATR_VAL:
      if (exp->elts[*pos].opcode == OP_TYPE)
        {
          if (TYPE_CODE (exp->elts[*pos + 1].type) != TYPE_CODE_VOID)
            LA_PRINT_TYPE (exp->elts[*pos + 1].type, "", stream, 0, 0,
			   &type_print_raw_options);
          *pos += 3;
        }
      else
        print_subexp (exp, pos, stream, PREC_SUFFIX);
      fprintf_filtered (stream, "'%s", ada_attribute_name (op));
      if (nargs > 1)
        {
          int tem;

          for (tem = 1; tem < nargs; tem += 1)
            {
              fputs_filtered ((tem == 1) ? " (" : ", ", stream);
              print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);
            }
          fputs_filtered (")", stream);
        }
      return;

    case UNOP_QUAL:
      type_print (exp->elts[pc + 1].type, "", stream, 0);
      fputs_filtered ("'(", stream);
      print_subexp (exp, pos, stream, PREC_PREFIX);
      fputs_filtered (")", stream);
      return;

    case UNOP_IN_RANGE:
      /* XXX: sprint_subexp */
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered (" in ", stream);
      LA_PRINT_TYPE (exp->elts[pc + 1].type, "", stream, 1, 0,
		     &type_print_raw_options);
      return;

    case OP_DISCRETE_RANGE:
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered ("..", stream);
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      return;

    case OP_OTHERS:
      fputs_filtered ("others => ", stream);
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      return;

    case OP_CHOICES:
      for (i = 0; i < nargs-1; i += 1)
	{
	  if (i > 0)
	    fputs_filtered ("|", stream);
	  print_subexp (exp, pos, stream, PREC_SUFFIX);
	}
      fputs_filtered (" => ", stream);
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      return;
      
    case OP_POSITIONAL:
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      return;

    case OP_AGGREGATE:
      fputs_filtered ("(", stream);
      for (i = 0; i < nargs; i += 1)
	{
	  if (i > 0)
	    fputs_filtered (", ", stream);
	  print_subexp (exp, pos, stream, PREC_SUFFIX);
	}
      fputs_filtered (")", stream);
      return;
    }
}

/* Table mapping opcodes into strings for printing operators
   and precedences of the operators.  */

static const struct op_print ada_op_print_tab[] = {
  {":=", BINOP_ASSIGN, PREC_ASSIGN, 1},
  {"or else", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},
  {"and then", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},
  {"or", BINOP_BITWISE_IOR, PREC_BITWISE_IOR, 0},
  {"xor", BINOP_BITWISE_XOR, PREC_BITWISE_XOR, 0},
  {"and", BINOP_BITWISE_AND, PREC_BITWISE_AND, 0},
  {"=", BINOP_EQUAL, PREC_EQUAL, 0},
  {"/=", BINOP_NOTEQUAL, PREC_EQUAL, 0},
  {"<=", BINOP_LEQ, PREC_ORDER, 0},
  {">=", BINOP_GEQ, PREC_ORDER, 0},
  {">", BINOP_GTR, PREC_ORDER, 0},
  {"<", BINOP_LESS, PREC_ORDER, 0},
  {">>", BINOP_RSH, PREC_SHIFT, 0},
  {"<<", BINOP_LSH, PREC_SHIFT, 0},
  {"+", BINOP_ADD, PREC_ADD, 0},
  {"-", BINOP_SUB, PREC_ADD, 0},
  {"&", BINOP_CONCAT, PREC_ADD, 0},
  {"*", BINOP_MUL, PREC_MUL, 0},
  {"/", BINOP_DIV, PREC_MUL, 0},
  {"rem", BINOP_REM, PREC_MUL, 0},
  {"mod", BINOP_MOD, PREC_MUL, 0},
  {"**", BINOP_EXP, PREC_REPEAT, 0},
  {"@@", BINOP_REPEAT, PREC_REPEAT, 0},
  {"-", UNOP_NEG, PREC_PREFIX, 0},
  {"+", UNOP_PLUS, PREC_PREFIX, 0},
  {"not ", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},
  {"not ", UNOP_COMPLEMENT, PREC_PREFIX, 0},
  {"abs ", UNOP_ABS, PREC_PREFIX, 0},
  {".all", UNOP_IND, PREC_SUFFIX, 1},
  {"'access", UNOP_ADDR, PREC_SUFFIX, 1},
  {"'size", OP_ATR_SIZE, PREC_SUFFIX, 1},
  {NULL, 0, 0, 0}
};

enum ada_primitive_types {
  ada_primitive_type_int,
  ada_primitive_type_long,
  ada_primitive_type_short,
  ada_primitive_type_char,
  ada_primitive_type_float,
  ada_primitive_type_double,
  ada_primitive_type_void,
  ada_primitive_type_long_long,
  ada_primitive_type_long_double,
  ada_primitive_type_natural,
  ada_primitive_type_positive,
  ada_primitive_type_system_address,
  nr_ada_primitive_types
};

static void
ada_language_arch_info (struct gdbarch *gdbarch,
			struct language_arch_info *lai)
{
  const struct builtin_type *builtin = builtin_type (gdbarch);

  lai->primitive_type_vector
    = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_ada_primitive_types + 1,
			      struct type *);

  lai->primitive_type_vector [ada_primitive_type_int]
    = arch_integer_type (gdbarch, gdbarch_int_bit (gdbarch),
			 0, "integer");
  lai->primitive_type_vector [ada_primitive_type_long]
    = arch_integer_type (gdbarch, gdbarch_long_bit (gdbarch),
			 0, "long_integer");
  lai->primitive_type_vector [ada_primitive_type_short]
    = arch_integer_type (gdbarch, gdbarch_short_bit (gdbarch),
			 0, "short_integer");
  lai->string_char_type
    = lai->primitive_type_vector [ada_primitive_type_char]
    = arch_integer_type (gdbarch, TARGET_CHAR_BIT, 0, "character");
  lai->primitive_type_vector [ada_primitive_type_float]
    = arch_float_type (gdbarch, gdbarch_float_bit (gdbarch),
		       "float", NULL);
  lai->primitive_type_vector [ada_primitive_type_double]
    = arch_float_type (gdbarch, gdbarch_double_bit (gdbarch),
		       "long_float", NULL);
  lai->primitive_type_vector [ada_primitive_type_long_long]
    = arch_integer_type (gdbarch, gdbarch_long_long_bit (gdbarch),
			 0, "long_long_integer");
  lai->primitive_type_vector [ada_primitive_type_long_double]
    = arch_float_type (gdbarch, gdbarch_double_bit (gdbarch),
		       "long_long_float", NULL);
  lai->primitive_type_vector [ada_primitive_type_natural]
    = arch_integer_type (gdbarch, gdbarch_int_bit (gdbarch),
			 0, "natural");
  lai->primitive_type_vector [ada_primitive_type_positive]
    = arch_integer_type (gdbarch, gdbarch_int_bit (gdbarch),
			 0, "positive");
  lai->primitive_type_vector [ada_primitive_type_void]
    = builtin->builtin_void;

  lai->primitive_type_vector [ada_primitive_type_system_address]
    = lookup_pointer_type (arch_type (gdbarch, TYPE_CODE_VOID, 1, "void"));
  TYPE_NAME (lai->primitive_type_vector [ada_primitive_type_system_address])
    = "system__address";

  lai->bool_type_symbol = NULL;
  lai->bool_type_default = builtin->builtin_bool;
}

				/* Language vector */

/* Not really used, but needed in the ada_language_defn.  */

static void
emit_char (int c, struct type *type, struct ui_file *stream, int quoter)
{
  ada_emit_char (c, type, stream, quoter, 1);
}

static int
parse (void)
{
  warnings_issued = 0;
  return ada_parse ();
}

static const struct exp_descriptor ada_exp_descriptor = {
  ada_print_subexp,
  ada_operator_length,
  ada_operator_check,
  ada_op_name,
  ada_dump_subexp_body,
  ada_evaluate_subexp
};

/* Implement the "la_get_symbol_name_cmp" language_defn method
   for Ada.  */

static symbol_name_cmp_ftype
ada_get_symbol_name_cmp (const char *lookup_name)
{
  if (should_use_wild_match (lookup_name))
    return wild_match;
  else
    return compare_names;
}

/* Implement the "la_read_var_value" language_defn method for Ada.  */

static struct value *
ada_read_var_value (struct symbol *var, struct frame_info *frame)
{
  struct block *frame_block = NULL;
  struct symbol *renaming_sym = NULL;

  /* The only case where default_read_var_value is not sufficient
     is when VAR is a renaming...  */
  if (frame)
    frame_block = get_frame_block (frame, NULL);
  if (frame_block)
    renaming_sym = ada_find_renaming_symbol (var, frame_block);
  if (renaming_sym != NULL)
    return ada_read_renaming_var_value (renaming_sym, frame_block);

  /* This is a typical case where we expect the default_read_var_value
     function to work.  */
  return default_read_var_value (var, frame);
}

const struct language_defn ada_language_defn = {
  "ada",                        /* Language name */
  language_ada,
  range_check_off,
  case_sensitive_on,            /* Yes, Ada is case-insensitive, but
                                   that's not quite what this means.  */
  array_row_major,
  macro_expansion_no,
  &ada_exp_descriptor,
  parse,
  ada_error,
  resolve,
  ada_printchar,                /* Print a character constant */
  ada_printstr,                 /* Function to print string constant */
  emit_char,                    /* Function to print single char (not used) */
  ada_print_type,               /* Print a type using appropriate syntax */
  ada_print_typedef,            /* Print a typedef using appropriate syntax */
  ada_val_print,                /* Print a value using appropriate syntax */
  ada_value_print,              /* Print a top-level value */
  ada_read_var_value,		/* la_read_var_value */
  NULL,                         /* Language specific skip_trampoline */
  NULL,                         /* name_of_this */
  ada_lookup_symbol_nonlocal,   /* Looking up non-local symbols.  */
  basic_lookup_transparent_type,        /* lookup_transparent_type */
  ada_la_decode,                /* Language specific symbol demangler */
  NULL,                         /* Language specific
				   class_name_from_physname */
  ada_op_print_tab,             /* expression operators for printing */
  0,                            /* c-style arrays */
  1,                            /* String lower bound */
  ada_get_gdb_completer_word_break_characters,
  ada_make_symbol_completion_list,
  ada_language_arch_info,
  ada_print_array_index,
  default_pass_by_reference,
  c_get_string,
  ada_get_symbol_name_cmp,	/* la_get_symbol_name_cmp */
  ada_iterate_over_symbols,
  LANG_MAGIC
};

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_ada_language;

/* Command-list for the "set/show ada" prefix command.  */
static struct cmd_list_element *set_ada_list;
static struct cmd_list_element *show_ada_list;

/* Implement the "set ada" prefix command.  */

static void
set_ada_command (char *arg, int from_tty)
{
  printf_unfiltered (_(\
"\"set ada\" must be followed by the name of a setting.\n"));
  help_list (set_ada_list, "set ada ", -1, gdb_stdout);
}

/* Implement the "show ada" prefix command.  */

static void
show_ada_command (char *args, int from_tty)
{
  cmd_show_list (show_ada_list, from_tty, "");
}

static void
initialize_ada_catchpoint_ops (void)
{
  struct breakpoint_ops *ops;

  initialize_breakpoint_ops ();

  ops = &catch_exception_breakpoint_ops;
  *ops = bkpt_breakpoint_ops;
  ops->dtor = dtor_catch_exception;
  ops->allocate_location = allocate_location_catch_exception;
  ops->re_set = re_set_catch_exception;
  ops->check_status = check_status_catch_exception;
  ops->print_it = print_it_catch_exception;
  ops->print_one = print_one_catch_exception;
  ops->print_mention = print_mention_catch_exception;
  ops->print_recreate = print_recreate_catch_exception;

  ops = &catch_exception_unhandled_breakpoint_ops;
  *ops = bkpt_breakpoint_ops;
  ops->dtor = dtor_catch_exception_unhandled;
  ops->allocate_location = allocate_location_catch_exception_unhandled;
  ops->re_set = re_set_catch_exception_unhandled;
  ops->check_status = check_status_catch_exception_unhandled;
  ops->print_it = print_it_catch_exception_unhandled;
  ops->print_one = print_one_catch_exception_unhandled;
  ops->print_mention = print_mention_catch_exception_unhandled;
  ops->print_recreate = print_recreate_catch_exception_unhandled;

  ops = &catch_assert_breakpoint_ops;
  *ops = bkpt_breakpoint_ops;
  ops->dtor = dtor_catch_assert;
  ops->allocate_location = allocate_location_catch_assert;
  ops->re_set = re_set_catch_assert;
  ops->check_status = check_status_catch_assert;
  ops->print_it = print_it_catch_assert;
  ops->print_one = print_one_catch_assert;
  ops->print_mention = print_mention_catch_assert;
  ops->print_recreate = print_recreate_catch_assert;
}

void
_initialize_ada_language (void)
{
  add_language (&ada_language_defn);

  initialize_ada_catchpoint_ops ();

  add_prefix_cmd ("ada", no_class, set_ada_command,
                  _("Prefix command for changing Ada-specfic settings"),
                  &set_ada_list, "set ada ", 0, &setlist);

  add_prefix_cmd ("ada", no_class, show_ada_command,
                  _("Generic command for showing Ada-specific settings."),
                  &show_ada_list, "show ada ", 0, &showlist);

  add_setshow_boolean_cmd ("trust-PAD-over-XVS", class_obscure,
                           &trust_pad_over_xvs, _("\
Enable or disable an optimization trusting PAD types over XVS types"), _("\
Show whether an optimization trusting PAD types over XVS types is activated"),
                           _("\
This is related to the encoding used by the GNAT compiler.  The debugger\n\
should normally trust the contents of PAD types, but certain older versions\n\
of GNAT have a bug that sometimes causes the information in the PAD type\n\
to be incorrect.  Turning this setting \"off\" allows the debugger to\n\
work around this bug.  It is always safe to turn this option \"off\", but\n\
this incurs a slight performance penalty, so it is recommended to NOT change\n\
this option to \"off\" unless necessary."),
                            NULL, NULL, &set_ada_list, &show_ada_list);

  add_catch_command ("exception", _("\
Catch Ada exceptions, when raised.\n\
With an argument, catch only exceptions with the given name."),
		     catch_ada_exception_command,
                     NULL,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);
  add_catch_command ("assert", _("\
Catch failed Ada assertions, when raised.\n\
With an argument, catch only exceptions with the given name."),
		     catch_assert_command,
                     NULL,
		     CATCH_PERMANENT,
		     CATCH_TEMPORARY);

  varsize_limit = 65536;

  obstack_init (&symbol_list_obstack);

  decoded_names_store = htab_create_alloc
    (256, htab_hash_string, (int (*)(const void *, const void *)) streq,
     NULL, xcalloc, xfree);

  /* Setup per-inferior data.  */
  observer_attach_inferior_exit (ada_inferior_exit);
  ada_inferior_data
    = register_inferior_data_with_cleanup (NULL, ada_inferior_data_cleanup);
}
@


1.413
log
@Add "ada_" prefix to enum ada_exception_catchpoint_kind

This is in preparation for making that type public, in order to be
able to use make create_ada_exception_catchpoint public as well,
making it usable from the GDB/MI implementation.

gdb/ChangeLog:

        * ada-lang.c (enum ada_exception_catchpoint_kind): Renames
        "enum exception_catchpoint_kind".  Replace the "ex_" prefix
        of all its enumerates with "ada_".  Update the rest of this
        file throughout.
@
text
@a10983 10
/* The different types of catchpoints that we introduced for catching
   Ada exceptions.  */

enum ada_exception_catchpoint_kind
{
  ada_catch_exception,
  ada_catch_exception_unhandled,
  ada_catch_assert
};

d12183 1
a12183 1
static void
d12189 1
d12200 1
a12200 1
				 ops, tempflag, from_tty);
d12228 2
a12229 1
				   tempflag, from_tty);
d12279 2
a12280 1
				   tempflag, from_tty);
@


1.412
log
@Rework a bit Ada exception catchpoint support (in prep for GDB/MI)

This patch reworks a bit how the different steps required to insert
an Ada exception catchpoints are organized. They used to be:

  1. Call a "decode" function which does:
        1.a.  Parse the command and its arguments
        1.b.  Create a SAL & OPS from some of those arguments

  2. Call create_ada_exception_catchpoint using SAL as well
     as some of the arguments extracted above.

The bulk of the change consists in integrating step (1.b) into
step (2) in order to turn create_ada_exception_catchpoint into
a function whose arguments are all user-level concepts. This
paves the way from a straightforward implementation of the equivalent
commands in the GDB/MI interpreter.

gdb/ChangeLog:

        * ada-lang.c (ada_decode_exception_location): Delete.
        (create_ada_exception_catchpoint): Remove arguments "sal",
        "addr_string" and "ops".  Add argument "ex_kind" instead.
        Adjust implementation accordingly, calling ada_exception_sal
        to get the entities it no longer gets passed as arguments.
        Document the function's arguments.
        (catch_ada_exception_command): Use catch_ada_exception_command_split
        instead of ada_decode_exception_location, and update call to
        create_ada_exception_catchpoint.
        (catch_ada_assert_command_split): Renames
        ada_decode_assert_location.  Remove parameters "addr_string" and
        "ops", and now returns void.  Adjust implementation accordingly.
        Update the function documentation.
        (catch_assert_command): Use catch_ada_assert_command_split
        instead of ada_decode_assert_location.  Update call to
        create_ada_exception_catchpoint.
@
text
@d10987 1
a10987 1
enum exception_catchpoint_kind
d10989 3
a10991 3
  ex_catch_exception,
  ex_catch_exception_unhandled,
  ex_catch_assert
d11315 1
a11315 1
ada_exception_name_addr_1 (enum exception_catchpoint_kind ex,
d11322 1
a11322 1
      case ex_catch_exception:
d11326 1
a11326 1
      case ex_catch_exception_unhandled:
d11330 1
a11330 1
      case ex_catch_assert:
d11348 1
a11348 1
ada_exception_name_addr (enum exception_catchpoint_kind ex,
d11488 1
a11488 1
dtor_exception (enum exception_catchpoint_kind ex, struct breakpoint *b)
d11501 1
a11501 1
allocate_location_exception (enum exception_catchpoint_kind ex,
d11516 1
a11516 1
re_set_exception (enum exception_catchpoint_kind ex, struct breakpoint *b)
d11572 1
a11572 1
check_status_exception (enum exception_catchpoint_kind ex, bpstat bs)
d11581 1
a11581 1
print_it_exception (enum exception_catchpoint_kind ex, bpstat bs)
d11603 2
a11604 2
      case ex_catch_exception:
      case ex_catch_exception_unhandled:
d11630 1
a11630 1
	  if (ex == ex_catch_exception_unhandled)
d11635 1
a11635 1
      case ex_catch_assert:
d11654 1
a11654 1
print_one_exception (enum exception_catchpoint_kind ex,
d11672 1
a11672 1
      case ex_catch_exception:
d11685 1
a11685 1
      case ex_catch_exception_unhandled:
d11689 1
a11689 1
      case ex_catch_assert:
d11703 1
a11703 1
print_mention_exception (enum exception_catchpoint_kind ex,
d11716 1
a11716 1
      case ex_catch_exception:
d11729 1
a11729 1
      case ex_catch_exception_unhandled:
d11733 1
a11733 1
      case ex_catch_assert:
d11747 1
a11747 1
print_recreate_exception (enum exception_catchpoint_kind ex,
d11754 1
a11754 1
      case ex_catch_exception:
d11760 1
a11760 1
      case ex_catch_exception_unhandled:
d11764 1
a11764 1
      case ex_catch_assert:
d11779 1
a11779 1
  dtor_exception (ex_catch_exception, b);
d11785 1
a11785 1
  return allocate_location_exception (ex_catch_exception, self);
d11791 1
a11791 1
  re_set_exception (ex_catch_exception, b);
d11797 1
a11797 1
  check_status_exception (ex_catch_exception, bs);
d11803 1
a11803 1
  return print_it_exception (ex_catch_exception, bs);
d11809 1
a11809 1
  print_one_exception (ex_catch_exception, b, last_loc);
d11815 1
a11815 1
  print_mention_exception (ex_catch_exception, b);
d11821 1
a11821 1
  print_recreate_exception (ex_catch_exception, b, fp);
d11831 1
a11831 1
  dtor_exception (ex_catch_exception_unhandled, b);
d11837 1
a11837 1
  return allocate_location_exception (ex_catch_exception_unhandled, self);
d11843 1
a11843 1
  re_set_exception (ex_catch_exception_unhandled, b);
d11849 1
a11849 1
  check_status_exception (ex_catch_exception_unhandled, bs);
d11855 1
a11855 1
  return print_it_exception (ex_catch_exception_unhandled, bs);
d11862 1
a11862 1
  print_one_exception (ex_catch_exception_unhandled, b, last_loc);
d11868 1
a11868 1
  print_mention_exception (ex_catch_exception_unhandled, b);
d11875 1
a11875 1
  print_recreate_exception (ex_catch_exception_unhandled, b, fp);
d11885 1
a11885 1
  dtor_exception (ex_catch_assert, b);
d11891 1
a11891 1
  return allocate_location_exception (ex_catch_assert, self);
d11897 1
a11897 1
  re_set_exception (ex_catch_assert, b);
d11903 1
a11903 1
  check_status_exception (ex_catch_assert, bs);
d11909 1
a11909 1
  return print_it_exception (ex_catch_assert, bs);
d11915 1
a11915 1
  print_one_exception (ex_catch_assert, b, last_loc);
d11921 1
a11921 1
  print_mention_exception (ex_catch_assert, b);
d11927 1
a11927 1
  print_recreate_exception (ex_catch_assert, b, fp);
d11976 1
a11976 1
                                   enum exception_catchpoint_kind *ex,
d12024 1
a12024 1
      *ex = ex_catch_exception;
d12030 1
a12030 1
      *ex = ex_catch_exception_unhandled;
d12036 1
a12036 1
      *ex = ex_catch_exception;
d12046 1
a12046 1
ada_exception_sym_name (enum exception_catchpoint_kind ex)
d12054 1
a12054 1
      case ex_catch_exception:
d12057 1
a12057 1
      case ex_catch_exception_unhandled:
d12060 1
a12060 1
      case ex_catch_assert:
d12073 1
a12073 1
ada_exception_breakpoint_ops (enum exception_catchpoint_kind ex)
d12077 1
a12077 1
      case ex_catch_exception:
d12080 1
a12080 1
      case ex_catch_exception_unhandled:
d12083 1
a12083 1
      case ex_catch_assert:
d12146 1
a12146 1
ada_exception_sal (enum exception_catchpoint_kind ex, char *excep_string,
d12195 1
a12195 1
				 enum exception_catchpoint_kind ex_kind,
d12225 1
a12225 1
  enum exception_catchpoint_kind ex_kind;
d12285 1
a12285 1
  create_ada_exception_catchpoint (gdbarch, ex_catch_assert,
@


1.411
log
@[Ada] psymbol search failure due to comparison function discrepancy

Upon trying to print the value of a variant record, a user noticed
the following problem:

        (gdb) print rt
        warning: Unknown upper bound, using 1.
        warning: Unknown upper bound, using 1.
        $1 = (a => ((a1 => (4), a2 => (4)), (a1 => (8), a2 => (8))))

The expected output is:

        (gdb) print rt
        $1 = (a => ((a1 => (4, 4), a2 => (8, 8)), (a1 => (4, 4),
              a2 => (8, 8))))

The problems comes from the fact that components "a1" and "a2" are
defined as arrays whose upper bound is dynamic.  To determine the value
of that upper bound, GDB relies on the GNAT encoding and searches
for the parallel ___U variable.  Unfortunately, the search fails
while doing a binary search inside the partial symtab of the unit
where the array and its bound (and therefore the parallel ___U variable)
are defined.

It fails because partial symbols are sorted using strcmp_iw_ordered,
while Ada symbol lookups are performed using a different comparison
function (ada-lang.c:compare_names). The two functions are supposed
to be compatible, but a change performed in April 2011 modified
strcmp_iw_ordered, introducing case-sensitivity issues. As a result,
the two functions would now disagree when passed the following
two arguments:

  string1="common__inner_arr___SIZE_A_UNIT"
  string2="common__inner_arr__T4s___U"

The difference starts at "_SIZE_A_UNIT" vs "T4s___U". So, it's mostly
a matter of comparing '_' with 'T'.

On the one hand, strcmp_iw_ordered would return -1, while compare_names
returned 11. The change that made all the difference is that
strcmp_iw_ordered now performs a case-insensitive comparison,
and only resorts to case-sentitive comparison if the first comparison
finds an equality. This changes everything, because while 'T' (84)
and 't' (116) are on opposite sides of '_' (95).

This patch aims at restoring the compatibility between the two
functions, by adding case-sensitivity handling in the Ada comparison
function.

gdb/ChangeLog:

        * ada-lang.c (compare_names_with_case): Renamed from
        compare_names, adding a new parameter "casing" and its handling.
        New function documentation.
        (compare_names): New function, implemented using
        compare_names_with_case.
@
text
@d12178 1
a12178 4
/* Parse the arguments (ARGS) of the "catch exception" command.
 
   If the user asked the catchpoint to catch only a specific
   exception, then save the exception name in ADDR_STRING.
d12180 1
a12180 3
   If the user provided a condition, then set COND_STRING to
   that condition expression (the memory must be deallocated
   after use).  Otherwise, set COND_STRING to NULL.
d12182 3
a12184 2
   See ada_exception_sal for a description of all the remaining
   function arguments of this function.  */
d12186 1
a12186 7
static struct symtab_and_line
ada_decode_exception_location (char *args, char **addr_string,
                               char **excep_string,
			       char **cond_string,
                               const struct breakpoint_ops **ops)
{
  enum exception_catchpoint_kind ex;
d12188 2
a12189 3
  catch_ada_exception_command_split (args, &ex, excep_string, cond_string);
  return ada_exception_sal (ex, *excep_string, addr_string, ops);
}
d12191 1
a12191 1
/* Create an Ada exception catchpoint.  */
d12195 1
a12195 2
				 struct symtab_and_line sal,
				 char *addr_string,
a12197 1
				 const struct breakpoint_ops *ops,
d12202 4
d12225 1
a12225 2
  struct symtab_and_line sal;
  char *addr_string = NULL;
a12227 1
  const struct breakpoint_ops *ops = NULL;
d12233 4
a12236 4
  sal = ada_decode_exception_location (arg, &addr_string, &excep_string,
				       &cond_string, &ops);
  create_ada_exception_catchpoint (gdbarch, sal, addr_string,
				   excep_string, cond_string, ops,
d12240 1
a12240 3
/* Assuming that ARGS contains the arguments of a "catch assert"
   command, parse those arguments and return a symtab_and_line object
   for a failed assertion catchpoint.
d12242 2
a12243 2
   Set ADDR_STRING to the name of the function where the real
   breakpoint that implements the catchpoint is set.
d12246 1
a12246 2
   (the memory needs to be deallocated after use).  Otherwise, set
   COND_STRING to NULL.  */
d12248 2
a12249 4
static struct symtab_and_line
ada_decode_assert_location (char *args, char **addr_string,
			    char **cond_string,
                            const struct breakpoint_ops **ops)
a12267 2

  return ada_exception_sal (ex_catch_assert, NULL, addr_string, ops);
a12277 2
  struct symtab_and_line sal;
  char *addr_string = NULL;
a12278 1
  const struct breakpoint_ops *ops = NULL;
d12284 4
a12287 4
  sal = ada_decode_assert_location (arg, &addr_string, &cond_string, &ops);
  create_ada_exception_catchpoint (gdbarch, sal, addr_string,
				   NULL, cond_string, ops, tempflag,
				   from_tty);
@


1.410
log
@[Ada] Remove unnecessary ada_exception_sal advance declaration.

gdb/ChangeLog:

        * ada-lang.c (ada_exception_sal): Remove advance declaration.
@
text
@d4985 2
a4986 4
/* Compare STRING1 to STRING2, with results as for strcmp.
   Compatible with strcmp_iw in that strcmp_iw (STRING1, STRING2) <= 0
   implies compare_names (STRING1, STRING2) (they may differ as to
   what symbols compare equal).  */
d4989 2
a4990 1
compare_names (const char *string1, const char *string2)
d4994 2
d4998 12
a5009 1
      if (*string1 != *string2)
d5011 1
d5015 1
d5033 6
a5038 1
	return *string1 - *string2;
d5042 28
@


1.409
log
@wrong "catch exception" error message when finding trampoline msym.

When building the program with the shared GNAT runtime, the debugger
is unable to insert Ada exception catchpoints until that runtime
has been mapped to memory. In other words, we expect the user to start
the program first, before attempting to insert that catchpoint.

The detection mechanism that tries to provide some useful tips to
the user fails when the program itself contains a trampoline symbol
matching the symbol that the catchpoint is trying to use. This
results in the following error message:

    (gdb) catch exception
    Your Ada runtime appears to be missing some debugging information.
    Cannot insert Ada exception catchpoint in this configuration.

Instead, we expected the following error message:

    (gdb) catch exception
    Unable to insert catchpoint. Try to start the program first.

gdb/ChangeLog:

        * ada-lang.c (ada_has_this_exception_support): Ignore
        mst_solib_trampoline minimal symbols.
@
text
@a11320 3
static struct symtab_and_line ada_exception_sal (enum exception_catchpoint_kind,
						 char *, char **,
						 const struct breakpoint_ops **);
@


1.408
log
@	* symfile.h (struct quick_symbol_functions): Reorg arg list of
	map_matching_symbols so objfile is first.  All uses updated.
	* dwarf2read.c (dw2_map_matching_symbols): Update signature.
	* psymtab.c (map_matching_symbols_psymtab): Update signature.
@
text
@d11042 4
a11045 1
      if (lookup_minimal_symbol (einfo->catch_exception_sym, NULL, NULL))
@


1.407
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@d5043 1
a5043 1
	objfile->sf->qf->map_matching_symbols (name, domain, objfile, global,
d5047 1
a5047 1
	objfile->sf->qf->map_matching_symbols (name, domain, objfile, global,
d5060 2
a5061 2
	  objfile->sf->qf->map_matching_symbols (name1, domain,
						 objfile, global,
@


1.406
log
@remove msymbol_objfile

This is another patch in my ongoing series to "split" objfile to share
more read-only data across inferiors.  See

    http://sourceware.org/gdb/wiki/ObjfileSplitting

When symbols are finally shared, there will be no back-link from the
symbol to its containing objfile, because there may be more than one
such objfile.  So, all such back-links must be removed.

One hidden back-link is the msymbol_objfile function.  Since
(eventually) a symbol may appear in more than one objfile, trying to
look up the objfile given just a symbol cannot work.

This patch removes msymbol_objfile in favor of using a bound minimal
symbol.  It introduces a new function to make this conversion simpler
in some spots.

The bonus of this patch is that using msymbol_objfile is slower than
simply looking up the owning objfile in the first place.

Built and regtested on x86-64 Fedora 18.

	* ada-exp.y (write_var_or_type): Use bound_minimal_symbol.
	* ada-lang.c (ada_lookup_simple_minsym): Return
	bound_minimal_symbol.
	* ada-lang.h (ada_lookup_simple_minsym): Update.
	* c-exp.y (variable): Use lookup_bound_minimal_symbol.
	* f-exp.y (variable): Use lookup_bound_minimal_symbol.
	* go-exp.y (variable): Use lookup_bound_minimal_symbol.
	* jv-exp.y (push_expression_name): Use lookup_bound_minimal_symbol.
	* m2-exp.y (variable): Use lookup_bound_minimal_symbol.
	* minsyms.c (msymbol_objfile): Remove.
	(lookup_minimal_symbol_internal): New function, from
	lookup_minimal_symbol.
	(lookup_minimal_symbol): Rewrite using
	lookup_minimal_symbol_internal.
	(lookup_bound_minimal_symbol): New function.
	* minsyms.h (msymbol_objfile): Remove.
	(lookup_bound_minimal_symbol): Declare.
	* p-exp.y (variable): Use lookup_bound_minimal_symbol.
	* parse.c (write_exp_msymbol): Change parameter to a
	bound_minimal_symbol.
	(write_dollar_variable): Use lookup_bound_minimal_symbol.
	* parser-defs.h (write_exp_msymbol): Update.
	* printcmd.c (address_info): Use lookup_bound_minimal_symbol.
	* symfile.c (simple_read_overlay_table): Use
	lookup_bound_minimal_symbol.
	* symtab.c (skip_prologue_sal): Don't use msymbol_objfile.
	(search_symbols): Likewise.
	(print_msymbol_info): Take a bound_minimal_symbol argument.
	(symtab_symbol_info, rbreak_command): Update.
	* symtab.h (struct symbol_search) <msymbol>: Change type
	to bound_minimal_symbol.
	* valops.c (find_function_in_inferior): Use
	lookup_bound_minimal_symbol.
	* value.c (value_fn_field): Use lookup_bound_minimal_symbol.
@
text
@d11157 1
a11157 1
          && re_exec (sal.symtab->objfile->name))
@


1.405
log
@ada-lang.c:coerce_unspec_val_to_type: Preserve laziness.

ada-lang.c:coerce_unspec_val_to_type does:

      if (value_lazy (val)
	  || TYPE_LENGTH (type) > TYPE_LENGTH (value_type (val)))
	result = allocate_value_lazy (type);
      else
	{
	  result = allocate_value (type);
	  memcpy (value_contents_raw (result), value_contents (val),
		  TYPE_LENGTH (type));
	}
      set_value_component_location (result, val);
      set_value_bitsize (result, value_bitsize (val));
      set_value_bitpos (result, value_bitpos (val));
      set_value_address (result, value_address (val));
      set_value_optimized_out (result, value_optimized_out (val));

Notice that before value_optimized_out was made to auto-fetch lazy
values, VAL would end up still lazy if it was lazy on entry.  It's not
really a problem here if VAL is lazy, and VAL->optimized_out is 0,
because RESULT is also left lazy.  IOW, this just wants to copy the
VAL->optimized_out flag to RESULT->optimized_out, nothing else.

As a side-effect of the change in value_optimized_out, the following
testcase now regresses. Consider:

       type Small is range -64 .. 63;
       for Small'Size use 7;
       type Arr is array (1..10) of Small;
       pragma Pack (Arr);

       type Arr_Ptr is access Arr;
       An_Arr_Ptr : Arr_Ptr := new Arr'(10, 20, 30, 40, 50, 60, 62, 63,
                                        -23, 42);

    Trying to print one element of An_Arr_Ptr yields:

        (gdb) p an_arr_ptr(3)
        Cannot access memory at address 0x0

The patch adds the value_optimized_out_const function for that,
allowing us to avoid trying to fetch a value at a dummy address.

(I found this out by grepping for set_value_optimized_out and trying
to convert the uses I found to instead allocate the value with
allocate_optimized_out_value.)

Tested on x86_64 Fedora 17.

gdb/
2013-07-09  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (coerce_unspec_val_to_type): Use
	value_optimized_out_const.
	* value.c (value_optimized_out_const): New function.
	* value.h (value_optimized_out_const): New declaration.
@
text
@d4408 5
a4412 4
/* Return a minimal symbol matching NAME according to Ada decoding
   rules.  Returns NULL if there is no such minimal symbol.  Names
   prefixed with "standard__" are handled specially: "standard__" is
   first stripped off, and only static and global symbols are searched.  */
d4414 1
a4414 1
struct minimal_symbol *
d4417 1
d4422 2
d4438 5
a4442 1
      return msymbol;
d4445 1
a4445 1
  return NULL;
@


1.404
log
@	* ada-lang.c (is_known_support_routine): Add explicit free of
	'func_name' from find_frame_funname.
	(ada_unhandled_exception_name_addr_from_raise): Add cleanups
	for func_name from find_frame_funname.
	* python/py-frame.c (frapy_name): Add explicit free of
	'name' from find_frame_funname.
	* stack.c (find_frame_funname): Add comment explaining that
	funcp must be freed by the caller.
	Return copy of symbol names instead of pointers.
	(print_frame): Add a cleanup for 'funname' from
	find_frame_funname.
	* stack.h (find_frame_funname): Remove "const" from
	'funname' parameter.
@
text
@d584 1
a584 1
      set_value_optimized_out (result, value_optimized_out (val));
@


1.403
log
@[Ada] Fix cleanup leak in ada-lang.c:old_renaming_is_invisible

gdb/ChangeLog:

	* ada-lang.c (old_renaming_is_invisible): Fix cleanup leak.
@
text
@d11116 1
a11116 1
  const char *func_name;
d11163 4
a11166 1
        return 1;
d11169 1
d11213 1
d11224 1
d11227 1
a11227 1
      const char *func_name;
d11231 9
a11239 4
      if (func_name != NULL
          && strcmp (func_name, data->exception_info->catch_exception_sym) == 0)
        break; /* We found the frame we were looking for...  */
      fi = get_prev_frame (fi);
d11241 1
@


1.402
log
@Missing do_cleanups in ada_make_symbol_completion_list.

This results in an internal-warning when trying the completion
when in Ada mode:

    (gdb) b simple<TAB>
    /[...]/cleanups.c:265: internal-warning: restore_my_cleanups has found a stale cleanup
    A problem internal to GDB has been detected,
    further debugging may prove unreliable.
    Quit this debugging session? (y or n)

gdb/ChangeLog:

        * ada-lang.c (ada_make_symbol_completion_list): Make sure
        all cleanups are done before returning from this function.

gdb/testsuite/ChangeLog:

        * gdb.ada/complete.exp: Add test verifying completion using
        the "tab" key.
@
text
@d4729 1
d4735 1
a4735 2

  make_cleanup (xfree, scope);
d4739 4
a4742 1
    return 0;
d4754 6
a4759 1
  return (strncmp (function_name, scope, strlen (scope)) != 0);
@


1.401
log
@	* ada-lang.c (ada_value_primitive_packed_val): Don't
	call value_incref.
	* value.c (set_value_parent): Incref the new parent and decref
	the old parent.
	(value_copy, value_primitive_field): Use set_value_parent.
@
text
@d5844 1
d5945 1
@


1.400
log
@-Wpointer-sign: ada-lang.c, ada-tasks.c.

We're reading strings using the target memory access routines, which
work with raw bytes, so we need a couple casts.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (print_it_exception): Add cast to gdb_byte *.
	* ada-tasks.c (read_fat_string_value): Likewise.
@
text
@a2327 1
      value_incref (obj);
@


1.399
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d11535 2
a11536 1
	      read_memory (addr, exception_name, sizeof (exception_name) - 1);
@


1.398
log
@	* ada-lang.c (ada_decode_symbol): Check and set 'ada_mangled'.
	Use symbol's obstack, not an objfile.
	* coffread.c (process_coff_symbol): Update.
	* dwarf2read.c (fixup_go_packaging, new_symbol_full): Update.
	* jv-lang.c (add_class_symbol): Update.
	* mdebugread.c (new_symbol): Update.
	* minsyms.c (prim_record_minimal_symbol_full)
	(terminate_minimal_symbol_table): Update.
	* psymtab.c (add_psymbol_to_bcache): Clear entire symbol.  Update.
	* stabsread.c (define_symbol, read_enum_type): Update.
	* symtab.c (symbol_set_demangled_name, symbol_get_demangled_name):
	Handle Ada specially.
	(symbol_set_language): Add 'obstack' argument.
	(symbol_set_names): Update.
	(symbol_natural_name, symbol_demangled_name): Always use
	ada_decode_symbol.
	* symtab.h (struct general_symbol_info)
	<language_specific::obstack>: New field.
	<ada_mangled>: New field.
	(SYMBOL_SET_LANGUAGE): Add 'obstack' argument.
	(symbol_set_language): Update.
@
text
@d2521 1
a2521 1
      char *buffer = (char *) alloca (len);
@


1.397
log
@Constify strings in tracepoint.c, lookup_cmd and the completers.

This is sort of a continuation of Keith's parse_exp_1 constification
patch.  It started out by undoing these bits:

  @@@@ -754,9 +754,12 @@@@ validate_actionline (char **line, struct
   	  tmp_p = p;
   	  for (loc = t->base.loc; loc; loc = loc->next)
   	    {
  -	      p = tmp_p;
  -	      exp = parse_exp_1 (&p, loc->address,
  +	      const char *q;
  +
  +	      q = tmp_p;
  +	      exp = parse_exp_1 (&q, loc->address,
   				 block_for_pc (loc->address), 1);
  +	      p = (char *) q;

and progressively making more things const upwards, fixing fallout,
rinse repeat, until GDB built again (--enable-targets=all).

That ended up constifying lookup_cmd/add_cmd and (lots of) friends,
and the completers.

I didn't try to constify the command hooks themselves, because I know
upfront there are commands that write to the command string argument,
and I think I managed to stop at a nice non-hacky split point already.

I think the only non-really-super-obvious changes are
tracepoint.c:validate_actionline, and tracepoint.c:trace_dump_actions.

The rest is just mostly about 'char *' => 'const char *', 'char **'=>
'const char **', and the occasional (e.g., deprecated_cmd_warning)
case of 'char **'=> 'const char *', where/when I noticed that nothing
actually cares about the pointer to pointer output.

Tested on x86_64 Fedora 17, native and gdbserver.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (struct add_partial_datum) <text, text0, word>: Make
	fields const.
	(ada_make_symbol_completion_list): Make "text0" parameter const.
	* ax-gdb.c (agent_eval_command_one): Make "exp" parameter const.
	* breakpoint.c (condition_completer): Make "text" and "word"
	parameters const.  Adjust.
	(check_tracepoint_command): Adjust to validate_actionline
	prototype change.
	(catch_syscall_completer): Make "text" and "word" parameters
	const.
	* cli/cli-cmds.c (show_user): Make "comname" local const.
	(valid_command_p): Make "command" parameter const.
	(alias_command): Make "alias_prefix" and "command_prefix" locals
	const.
	* cli/cli-decode.c (add_cmd): Make "name" parameter const.
	(add_alias_cmd): Make "name" and "oldname" parameters const.
	Adjust.  No longer make copy of OLDNAME.
	(add_prefix_cmd, add_abbrev_prefix_cmd, add_set_or_show_cmd)
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd, add_setshow_zuinteger_cmd)
	(delete_cmd, add_info, add_info_alias, add_com, add_com_alias):
	Make "name" parameter const.
	(help_cmd): Rename "command" parameter to "arg".  New const local
	"command".
	(find_cmd): Make "command" parameter const.
	(lookup_cmd_1): Make "text" parameter pointer to const.  Adjust to
	deprecated_cmd_warning prototype change.
	(undef_cmd_error): Make "cmdtype" parameter const.
	(lookup_cmd): Make "line" parameter const.
	(deprecated_cmd_warning): Change type of "text" parameter to
	pointer to const char, from pointer to pointer to char.  Adjust.
	(lookup_cmd_composition): Make "text" parameter const.
	(complete_on_cmdlist, complete_on_enum): Make "text" and "word"
	parameters const.
	* cli/cli-decode.h (struct cmd_list_element) <name>: Make field
	const.
	* cli/cli-script.c (validate_comname): Make "tem" local const.
	(define_command): New const local "tem_c".  Use it in calls to
	lookup_cmd.
	(document_command): Make "tem" and "comfull" locals const.
	(show_user_1): Make "prefix" and "name" parameters const.
	* cli-script.h (show_user_1): Make "prefix" and "name" parameters
	const.
	* command.h (add_cmd, add_alias_cmd, add_prefix_cmd)
	(add_abbrev_prefix_cmd, completer_ftype, lookup_cmd, lookup_cmd_1)
	(deprecated_cmd_warning, lookup_cmd_composition, add_com)
	(add_com_alias, add_info, add_info_alias, complete_on_cmdlist)
	(complete_on_enum, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_cmd, add_setshow_zuinteger_unlimited_cmd):
	Change prototypes, constifying strings.
	* completer.c (noop_completer, filename_completer): Make "text"
	and "prefix" parameters const.
	(location_completer, expression_completer)
	(complete_line_internal): Make "text" and "prefix" parameters
	const and adjust.
	(command_completer, signal_completer): Make "text" and "prefix"
	parameters const.
	* completer.h (noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer)
	(signal_completer): Change prototypes.
	* corefile.c (complete_set_gnutarget): Make "text" and "word"
	parameters const.
	* cp-abi.c (cp_abi_completer): Likewise.
	* expression.h (parse_expression_for_completion): Change
	prototype.
	* f-lang.c (f_make_symbol_completion_list): Make "text" and "word"
	parameters const.
	* infcmd.c (_initialize_infcmd): Make "cmd_name" local const.
	* infrun.c (handle_completer): Make "text" and "word" parameters
	const.
	* interps.c (interpreter_completer): Make "text" and "word"
	parameters const.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Make "text" and "word"
	parameters const.
	* parse.c (parse_exp_1): Move const hack to parse_exp_in_context.
	(parse_exp_in_context): Rename to ...
	(parse_exp_in_context_1): ... this.
	(parse_exp_in_context): Reimplement, with const hack from
	parse_exp_1.
	(parse_expression_for_completion): Make "string" parameter const.
	* printcmd.c (decode_format): Make "string_ptr" parameter pointer
	to pointer to const char.  Adjust.
	(print_command_1): Make "exp" parameter const.
	(output_command): Rename to ...
	(output_command_const): ... this.  Make "exp" parameter const.
	(output_command): Reimplement.
	(x_command): Adjust.
	(display_command): Rename "exp" parameter to "arg".  New "exp"
	local, const version of "arg".
	* python/py-auto-load.c (gdbpy_initialize_auto_load): Make
	"cmd_name" local const.
	* python/py-cmd.c (cmdpy_destroyer): Cast const away in xfree
	call.
	(cmdpy_completer): Make "text" and "word" parameters const.
	(gdbpy_parse_command_name): Make "prefix_text2" local const.
	* python/py-param.c (add_setshow_generic): Make "tmp_name" local
	const.
	* remote.c (_initialize_remote): Make "cmd_name" local const.
	* symtab.c (language_search_unquoted_string): Make "text" and "p"
	parameters const.  Adjust.
	(completion_list_add_fields): Make "sym_text", "text" and "word"
	parameters const.
	(struct add_name_data) <sym_text, text, word>: Make fields const.
	(default_make_symbol_completion_list_break_on): Make "text" and
	"word" parameters const.  Adjust locals.
	(default_make_symbol_completion_list)
	(make_symbol_completion_list, make_symbol_completion_type)
	(make_symbol_completion_list_fn): Make "text" and "word"
	parameters const.
	(make_file_symbol_completion_list): Make "text", "word" and
	"srcfile" parameters const.  Adjust locals.
	(add_filename_to_list): Make "text" and "word" parameters const.
	(struct add_partial_filename_data) <text, word>: Make fields
	const.
	(make_source_files_completion_list): Make "text" and "word"
	parameters const.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_type enum type_code)
	(make_symbol_completion_list_fn make_file_symbol_completion_list)
	(make_source_files_completion_list): Change prototype.
	* top.c (execute_command): Adjust to pass pointer to pointer to
	const char to lookup_cmd, and to deprecated_cmd_warning prototype
	change.
	(set_verbose): Make "cmdname" local const.
	* tracepoint.c (decode_agent_options): Make "exp" parameter const,
	and adjust.
	(validate_actionline): Make "line" parameter a pointer to const
	char, and adjust.
	(encode_actions_1): Make "action_exp" local const, and adjust.
	(encode_actions): Adjust.
	(replace_comma): Delete.
	(trace_dump_actions): Make "action_exp" and "next_comma" locals
	const, and adjust.  Don't frob the action string while splitting
	it at commas.  Instead, make a copy of each split substring in
	turn.
	(trace_dump_command): Adjust to validate_actionline prototype
	change.
	* tracepoint.h (decode_agent_options, decode_agent_options)
	(encode_actions, validate_actionline): Change prototypes.
	* valprint.h (output_command): Delete declaration.
	(output_command_const): Declare.
	* value.c (function_destroyer): Cast const away in xfree call.
@
text
@d1300 1
a1300 1
ada_decode_symbol (const struct general_symbol_info *gsymbol)
d1302 3
a1304 4
  struct general_symbol_info *gsymbol_rw
    = (struct general_symbol_info *) gsymbol;
  const char **resultp
    = &gsymbol_rw->language_specific.mangled_lang.demangled_name;
d1306 1
a1306 1
  if (*resultp == NULL)
d1309 1
d1311 5
a1315 1
      if (gsymbol->obj_section != NULL)
d1317 4
a1320 1
	  struct objfile *objf = gsymbol->obj_section->objfile;
a1321 9
	  *resultp = obstack_copy0 (&objf->objfile_obstack,
				    decoded, strlen (decoded));
        }
      /* Sometimes, we can't find a corresponding objfile, in which
         case, we put the result on the heap.  Since we only decode
         when needed, we hope this usually does not cause a
         significant memory leak (FIXME).  */
      if (*resultp == NULL)
        {
@


1.396
log
@More invalid pointer to pointer conversions.

As a follow up to:

  http://sourceware.org/ml/gdb-patches/2013-03/msg00449.html

In a nutshell, casts between 'char **' <-> 'unsigned char **' and
'char **' <-> 'const char **' are invalid.

I grepped for "\*\*) &" and found these.  There's another one in
demangle.c, but I've split fixing that one to a separate patch.

I think the ada_decode_symbol change is perhaps the one that could be
surprising.  The function's description has this comment, which makes
things much clearer:

   The GSYMBOL parameter is "mutable" in the C++ sense: logically
   const, but nevertheless modified to a semantically equivalent form
   when a decoded name is cached in it.  */

 const char *
 ada_decode_symbol (const struct general_symbol_info *gsymbol)

With that out of the way, I think the patch ends up being pretty
obvious.

Tested on x86_64 Fedora 17.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (ada_decode_symbol): Cast away constness of GSYMBOL
	rather than casting 'const char * const *' to 'const char **'.
	* ada-lex.l (processInt): Make "trailer" local const.  Remove
	'const char **' cast.
	* arm-linux-tdep.c (arm_stap_parse_special_token): Add 'char *'
	locals, and use those as strtol output pointer, instead than doing
	invalid casts to from 'const char **' to 'char **'.
	(_initialize_demangle): Remove cast.
	* i386-tdep.c (i386_stap_parse_special_token): : Add 'char *'
	locals, and use those as strtol output pointer, instead than doing
	invalid casts to from 'const char **' to 'char **'.
	* solib-dsbt.c (dsbt_get_initial_loadmaps): Remove 'gdb_byte**'
	casts.
	* stap-probe.c (stap_parse_register_operand)
	(stap_parse_single_operand): Likewise.
@
text
@d5810 1
a5810 1
  char *text;
d5812 2
a5813 2
  char *text0;
  char *word;
d5832 2
a5833 1
ada_make_symbol_completion_list (char *text0, char *word, enum type_code code)
@


1.395
log
@	* ada-lang.c (ada_read_renaming_var_value): Pass const
	pointer to expression string to parse_exp_1.
	(create_excep_cond_exprs): Likewise.
	* ax-gdb.c (agent_eval_command_one): Likewise.
	(maint_agent_printf_command): Likewise.
	Constify much of the string handling/parsing.
	* breakpoint.c (set_breakpoint_condition): Pass const
	pointer to expression string to parse_exp_1.
	(update_watchpoint): Likewise.
	(parse_cmd_to_aexpr): Constify string handling.
	Pass const pointer to parse_exp_1.
	(init_breakpoint_sal): Pass const pointer to parse_exp_1.
	(find_condition_and_thread): Likewise.
	Make TOK const.
	(watch_command_1): Make "arg" const.
	Constify string handling.
	Copy the expression string instead of changing the input
	string.
	(update_breakpoint_location): Pass const pointer to
	parse_exp_1.
	* eval.c (parse_and_eval_address): Make "exp" const.
	(parse_to_comma_and_eval): Make "expp" const.
	(parse_and_eval): Make "exp" const.
	* expression.h (parse_expression): Make argument const.
	(parse_exp_1): Make first argument const.
	* findcmd.c (parse_find_args): Treat "args" as const.
	* linespec.c (parse_linespec): Pass const pointer to
	linespec_expression_to_pc.
	(linespec_expression_to_pc): Make "exp_ptr" const.
	* parse.c (parse_exp_1): Make "stringptr" const.
	Make a copy of the expression to pass to parse_exp_in_context until
	this whole interface can be constified.
	(parse_expression): Make "string" const.
	* printcmd.c (ui_printf): Treat "arg" as const.
	Handle const strings.
	* tracepoint.c (validate_actionline): Pass const pointer to
	all calls to parse_exp_1.
	(encode_actions_1): Likewise.
	* value.h (parse_to_comma_and_eval): Make argument const.
	(parse_and_eval_address): Likewise.
	(parse_and_eval): Likewise.
	* varobj.c (varobj_create): Pass const pointer to parse_exp_1.
	(varobj_set_value): Likewise.
	* cli/cli-cmds.c (disassemble_command): Treat "arg" as const and
	constify string handling.
	Pass const pointers to parse_and_eval_address and
	parse_to_comman_and_eval.
	* cli/cli-utils.c (skip_to_space): Rename to ...
	(skip_to_space_const): ... this. Handle const strings.
	* cli/cli-utils.h (skip_to_space): Turn into macro which invokes
	skip_to_space_const.
	(skip_to_space_const): Declare.
	* common/format.c (parse_format_string): Make "arg" const.
	Handle const strings.
	* common/format.h (parse_format_string): Make "arg" const.
	* gdbserver/ax.c (ax_printf): Make "format" const.
	* python/python.c (gdbpy_parse_and_eval): Do not make a copy
	of the expression string.
@
text
@d1302 4
a1305 2
  const char **resultp =
    (const char **) &gsymbol->language_specific.mangled_lang.demangled_name;
@


1.394
log
@	* ada-lang.c (ada_lookup_symbol_list_worker): New function, contents
	of old ada_lookup_symbol_list.  In !full_search case, don't
	search superblocks.
	(ada_lookup_symbol_list): Delete arg full_search, all callers
	updated.  Call ada_lookup_symbol_list_worker.
	(ada_iterate_over_symbols): Call ada_lookup_symbol_list_worker.
	* ada-lang.h (ada_lookup_symbol_list): Update.
	* language.h (language_defn): Update comment for
	la_iterate_over_symbols.
	* linespec.c (iterate_over_file_blocks): New function.
	(iterate_over_all_matching_symtabs): Call it.
	(lookup_prefix_sym): Ditto.
	(get_current_search_block): New function.
	(get_search_block): Delete.
	(find_label_symbols): Call get_current_search_block.
	(add_matching_symbols_to_info): Call iterate_over_file_blocks.
	* symtab.c (iterate_over_symbols): Don't search superblocks.
@
text
@d4059 1
a4059 1
  char *sym_name;
d4064 1
a4064 2
  sym_name = xstrdup (SYMBOL_LINKAGE_NAME (renaming_sym));
  old_chain = make_cleanup (xfree, sym_name);
d4066 1
a4066 1
  make_cleanup (free_current_contents, &expr);
d11387 1
a11387 1
	  char *s;
@


1.393
log
@gdb/
	* ada-lang.c (user_select_syms): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* breakpoint.c (print_breakpoint_location, resolve_sal_pc): Likewise.
	(clear_command): New variable sal_fullname, initialize it.  Replace
	compare_filenames_for_search by filename_cmp with sal_fullname.
	(say_where, update_static_tracepoint): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* cli/cli-cmds.c (edit_command, list_command, ambiguous_line_spec):
	Likewise.
	* dwarf2read.c: Include source.h.
	(fixup_go_packaging): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* linespec.c (add_sal_to_sals): Rename variable filename to fullname.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(create_sals_line_offset, convert_linespec_to_sals): New variable
	fullname, initialize it, replace symtab->filename reference by the
	variable.
	* linux-fork.c: Include source.h.
	(info_checkpoints_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* macroscope.c (sal_macro_scope): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* mdebugread.c: Include source.h.
	(psymtab_to_symtab_1): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(mi_cmd_file_list_exec_source_files): Likewise.
	* printcmd.c: Include source.h.
	(build_address_symbolic): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* psymtab.c (partial_map_symtabs_matching_filename)
	(read_psymtabs_with_fullname): Call compare_filenames_for_search also
	with psymtab_to_fullname.
	* python/py-symtab.c (stpy_str): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(stpy_get_filename): New variable filename, initialize it, use instead
	of symtab->filename refererences.
	(salpy_str): Make variable filename const char *.  Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	* skip.c: Include source.h and filenames.h.
	(skip_file_command): Remove const from the symtab variable.  Replace
	symtab->filename refererences by symtab_to_fullname call.
	(function_name_is_marked_for_skip): New variables searched_for_fullname
	and fullname.  Use them to search also with symtab's fullname.
	* source.c (find_source_lines): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(print_source_lines_base): New variable filename, use it instead of
	symtab->filename.  Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(line_info, forward_search_command): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	(reverse_search_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.  New variable filename for it.
	* stack.c (frame_info): Likewise.
	* symmisc.c: Include source.h.
	(dump_objfile, dump_symtab_1, maintenance_print_symbols)
	(maintenance_info_symtabs): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* symtab.c (iterate_over_some_symtabs): Call
	compare_filenames_for_search also with symtab_to_fullname.
	(lookup_symbol_aux_quick, basic_lookup_transparent_type_quick): Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	(find_line_symtab): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(file_matches): Replace filename_cmp by compare_filenames_for_search.
	(print_symbol_info): Make the last parameter const char *.  New
	variable s_filename.  Use it in the function.
	(symtab_symbol_info): Make the last_filename variable const char *.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(rbreak_command): New variable fullname.  Use it.  Replace
	symtab->filename refererence by symtab_to_filename_for_display call.
	* tracepoint.c (set_traceframe_context, trace_find_line_command)
	(print_one_static_tracepoint_marker): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* tui/tui-source.c (tui_set_source_content): New variables filename and
	s_filename.  Replace symtab->filename refererences by this variable.
	Replace other symtab->filename refererences by
	symtab_to_filename_for_display calls.
@
text
@d3113 1
a3113 1
                                    &candidates, 1);
d3205 1
a3205 1
                                      &candidates, 1);
d3257 1
a3257 1
                                    &candidates, 1);
d5055 3
a5057 2
/* Find symbols in DOMAIN matching NAME0, in BLOCK0 and enclosing
   scope and in global scopes, returning the number of matches.
d5060 4
a5063 2
   any) in which they were found.  This vector are transient---good only to
   the next call of ada_lookup_symbol_list.  Any non-function/non-enumeral
d5067 2
a5068 3
   surrounding BLOCK0, then these alone are returned.  Otherwise, if
   FULL_SEARCH is non-zero, then the search extends to global and
   file-scope (static) symbol tables.
d5072 5
a5076 5
int
ada_lookup_symbol_list (const char *name0, const struct block *block0,
			domain_enum namespace,
			struct ada_symbol_info **results,
			int full_search)
d5112 18
a5129 4
  ada_add_local_symbols (&symbol_list_obstack, name, block, namespace,
                         wild_match_p);
  if (num_defns_collected (&symbol_list_obstack) > 0 || !full_search)
    goto done;
d5172 31
a5227 19
/* Implementation of the la_iterate_over_symbols method.  */

static void
ada_iterate_over_symbols (const struct block *block,
			  const char *name, domain_enum domain,
			  symbol_found_callback_ftype *callback,
			  void *data)
{
  int ndefs, i;
  struct ada_symbol_info *results;

  ndefs = ada_lookup_symbol_list (name, block, domain, &results, 0);
  for (i = 0; i < ndefs; ++i)
    {
      if (! (*callback) (results[i].sym, data))
	break;
    }
}

d5246 1
a5246 3
  n_candidates = ada_lookup_symbol_list (name, block, namespace, &candidates,
					 1);

d5538 1
a5538 2
   OBJFILE is the section containing BLOCK.
   SYMTAB is recorded with each symbol added.  */
d10720 1
a10720 1
                                  &syms, 1);
@


1.392
log
@2013-02-01  Aleksandar Ristovski  <aristovski@@qnx.com>

        * ada-lang.c (assign_aggregate): Remove unused 'is_array_aggregate'.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00732.html
@
text
@d3576 2
a3577 1
			       sal.symtab->filename, sal.line);
d3592 2
a3593 1
                               symtab->filename, SYMBOL_LINE (syms[i].sym));
d3609 1
a3609 1
                               symtab->filename);
@


1.391
log
@	* ada-lang.h (ada_decode_symbol): Make return type const.
	* ada-lang.c (ada_decode_symbol): Likewise.
@
text
@a9031 1
  int is_array_aggregate;
a9055 1
      is_array_aggregate = 1;
a9060 1
      is_array_aggregate = 0;
@


1.390
log
@	* symfile.h (obsavestring): Don't declare.
	* symfile.c (obsavestring): Remove.
	* ada-exp.y: Use obstack_copy0, not obsavestring.
	* ada-lang.c: Use obstack_copy0, not obsavestring.
	* coffread.c: Use obstack_copy0, not obsavestring.
	* cp-namespace.c: Use obstack_copy0, not obsavestring.
	* dbxread.c: Use obstack_copy0, not obsavestring.
	* dwarf2read.c: Use obstack_copy0, not obsavestring.
	* jit.c: Use obstack_copy0, not obsavestring.
	* mdebugread.c: Use obstack_copy0, not obsavestring.
	* psymtab.c: Use obstack_copy0, not obsavestring.
	* stabsread.c: Use obstack_copy0, not obsavestring.
	* xcoffread.c: Use obstack_copy0, not obsavestring.
@
text
@d1299 1
a1299 1
char *
d1302 2
a1303 2
  char **resultp =
    (char **) &gsymbol->language_specific.mangled_lang.demangled_name;
@


1.389
log
@Fixes for solaris compiler
@
text
@d1313 2
a1314 2
	  *resultp = obsavestring (decoded, strlen (decoded),
				   &objf->objfile_obstack);
@


1.388
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d11796 1
a11796 1
  return re_set_exception (ex_catch_assert, b);
@


1.387
log
@gdb/
	* ada-lang.c (is_known_support_routine): New variable fullname.  Use
	access call to verify the symtab_to_fullname result.
	* breakpoint.c (print_breakpoint_location, update_static_tracepoint):
	Remove NULL check of symtab_to_fullname result.
	* cli/cli-cmds.c (edit_command): Likewise.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(mi_cmd_file_list_exec_source_files): Likewise.
	* python/py-symtab.c (stpy_fullname): Likewise.
	* source.c (symtab_to_fullname): Update function comment.  Rename
	variable r to fd, move it to inner block.  Always provide non-NULL
	result.
	(print_source_lines_base): Remove NULL check of symtab_to_fullname
	result.
	* stack.c (print_frame): Likewise.
	* symtab.c (iterate_over_some_symtabs, find_line_symtab, sources_info):
	Likewise.
	* tracepoint.c (print_one_static_tracepoint_marker): Likewise.

gdb/doc/
	* gdb.texinfo (GDB/MI Data Manipulation) (fullname): Make it always
	present.
	(GDB/MI File Commands) (-file-list-exec-source-files): Make the
	fullname output always present.

gdb/testsuite/
	* gdb.mi/mi-fullname-deleted.exp: New file.
@
text
@d3 1
a3 2
   Copyright (C) 1992-1994, 1997-2000, 2003-2005, 2007-2012 Free
   Software Foundation, Inc.
@


1.386
log
@	* ada-lang.c (ada_make_symbol_completion_list): Add 'code'
	argument, assertion.
	* c-exp.y (typebase): Add completion productions.
	* completer.c (expression_completer): Handle tag completion.
	* expression.h (parse_expression_for_completion): Add argument.
	* f-lang.c (f_make_symbol_completion_list): Add 'code'
	argument.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Add 'code' argument.
	* parse.c (expout_tag_completion_type, expout_completion_name):
	New globals.
	(mark_struct_expression): Add assertion.
	(mark_completion_tag): New function.
	(parse_exp_in_context): Initialize new globals.
	(parse_expression_for_completion): Add 'code' argument.  Handle
	tag completion.
	* parser-defs.h (mark_completion_tag): Declare.
	* symtab.c (default_make_symbol_completion_list_break_on): Add
	'code' argument.  Update.
	(default_make_symbol_completion_list): Add 'code' argument.
	(make_symbol_completion_list): Update.
	(make_symbol_completion_type): New function.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list): Update.
	(make_symbol_completion_type): Declare.
testsuite
	* gdb.base/break1.c (enum some_enum, union some_union): New.
	(some_enum_global, some_union_global, some_value): New globals.
	* gdb.base/completion.exp: Add tag completion tests.
@
text
@d11087 1
d11102 2
a11103 1
  if (symtab_to_fullname (sal.symtab) == NULL)
@


1.385
log
@	* ada-exp.y (write_object_renaming, write_var_or_type)
	(write_ambiguous_var, write_var_from_sym): Make blocks const.
	* ada-lang.c (replace_operator_with_call)
	(find_old_style_renaming_symbol): Make blocks const.
	* ada-lang.h (ada_find_renaming_symbol): Update.
	(struct ada_symbol_info) <block>: Now const.
	* breakpoint.c (watch_command_1): Update.
	* breakpoint.h (struct watchpoint) <exp_valid_block,
	cond_exp_valid_block>: Now const.
	* c-exp.y (classify_inner_name, classify_name): Make block
	argument const.
	* expprint.c (print_subexp_standard) <OP_VAR_VALUE>: Make 'b'
	const.
	* expression.h (innermost_block, parse_exp_1): Update.
	(union exp_element) <block>: Now const.
	* gdbtypes.c (lookup_template_type, lookup_enum, lookup_union)
	(lookup_struct): Make block argument const.
	* gdbtypes.h (lookup_template_type): Update.
	* go-exp.y (classify_name, classify_packaged_name)
	(package_name_p): Make block argument const.
	* objc-lang.c (lookup_struct_typedef): Make block argument const.
	* objc-lang.h (lookup_struct_typedef): Update.
	* parse.c (parse_exp_in_context, parse_exp_1)
	(write_exp_elt_block): Make block arguments const.
	(expression_context_block, innermost_block): Now const.
	* parser-defs.h (write_exp_elt_block): Update.
	(expression_context_block, innermost_block, block_found): Now
	const.
	* printcmd.c (struct display) <block>: Now const.
	* symtab.h (lookup_struct, lookup_union, lookup_enum): Update.
	* valops.c (address_of_variable): Make block argument const.
	* value.h (value_of_variable): Update.
	* varobj.c (struct varobj_root) <valid_block>: Now const.
@
text
@d5805 1
a5805 1
ada_make_symbol_completion_list (char *text0, char *word)
d5820 2
@


1.384
log
@Strip interface tags from visible fields

The following Ada type:

   type Circle is new Shape and Drawable with record
        Center : Point;
        Radius : Natural;
   end record;

...is displayed as follow in GDB:

 (gdb) ptype circle
 type = new classes.shape with record
     V51s: ada.tags.interface_tag;
     center: classes.point;
     radius: natural;
 end record

V51s is an internal field that is of no interest for the user. It should
not be displayed.

gdb/ChangeLog:

	* ada-lang.c (ada_is_interface_tag): New function.
	(ada_is_ignored_field): Add interface tags to the list
	of ignored fields.
@
text
@d131 1
a131 1
                                        struct symbol *, struct block *);
d153 1
a153 1
						      struct block *);
d3722 1
a3722 1
                            struct block *block)
d4235 1
a4235 1
              struct block *block)
d4808 1
a4808 1
      struct block *block = syms[i].block;
d7198 1
a7198 1
ada_find_renaming_symbol (struct symbol *name_sym, struct block *block)
d7220 1
a7220 1
find_old_style_renaming_symbol (const char *name, struct block *block)
@


1.383
log
@Full view of interface-wide types

For displaying the full view of a class-wide object, GDB relies on
the assumption that this view will have the same address as the
address of the object. In the case of simple inheritance, this
assumption is correct; the proper type is deduced by decoding
the tag of the object and converting the result to this full-view
type.

Consider for example an abstract class Shape, a child Circle
which implements an interface Drawable, and the corresponding
following objects:

   My_Circle   : Circle := ((1, 2), 3);
   My_Shape    : Shape'Class := Shape'Class (My_Circle);
   My_Drawable : Drawable'Class := Drawable'Class (My_Circle);

To display My_Shape, the debugger first extracts the tag (an internal
field, usually the first one of the record):

 (gdb) p my_shape'address
 $2 = (system.address) 0x8063e28
 (gdb) x/x my_shape'address
 0x8063e28 <classes__my_shape>: 0x08059ec4

Then the type specific data and the expanded name of the tag is read
from there:

 (gdb) p my_shape'tag
 $3 = (access ada.tags.dispatch_table) 0x8059ec4 (classes.circle)

To get the full view, the debugger converts to the corresponding type:

 (gdb) p {classes.circle}0x8063e28
 $4 = (center => (x => 1, y => 2), radius => 3)

Now, in the case of multiple inheritance, the assumption does not hold
anymore. The address that we have usually points to some
place lower. The offset to the original address is saved in the field
Offset_To_Top of the metadata that are above the tag, at address
obj'tag - 8. In the case of my_shape, this offset is 0:

 (gdb) x/x my_shape'tag - 8
 0x8059ebc <classes__circleT+12>:        0x00000000

...but in the case of an interface-wide object, it is not null:

 (gdb) x/x my_drawable'tag - 8
 0x8063b28 <classes__classes__circle_classes__drawable1T56s+12>: 0x00000004
 (gdb) p {classes.circle}(my_drawable'address - 4)
 $7 = (center => (x => 1, y => 2), radius => 3)

The following change handles this relocation in the most common cases.
Remaining cases that are still to be investigated are signaled by
comments.

gdb/ChangeLog:

	* ada-lang.h (ada_tag_value_at_base_address): New function
	declaration.
	* ada-lang.c (is_ada95_tag, ada_tag_value_at_base_address):
	New functions.
	(ada_to_fixed_type_1, ada_evaluate_subexp): Let ada_tag_base_address
	relocate the class-wide value if need be.
	(ada_value_struct_elt, ada_value_ind, ada_coerce_ref):
	Let ada_tag_value_at_base_address relocate the class-wide access/ref
	before dereferencing it.
	* ada-valprint.c (ada_val_print_1): Relocate to base address
	before displaying the content of an interface-wide ref.

gdb/testsuite/ChangeLog:

        * gdb.ada/ptype_tagged_param.exp: Adjust expected output in
        ptype test.
@
text
@d5940 13
d5983 2
a5984 1
  /* If this is the dispatch table of a tagged type, then ignore.  */
d5986 2
a5987 1
      && ada_is_dispatch_table_ptr_type (TYPE_FIELD_TYPE (type, field_num)))
@


1.382
log
@Handle other cases than EVAL_NORMAL in the default case

In the evaluation of an expression in Ada mode, the default case
unwraps the argument unconditionally. For an object of a variant
record type, this unwrapping builds a fixed type from the
specification of the variant type and the actual values of the
object's discriminants.  It means that unwrapping needs the "proper"
value for the object, not just a zero value with the proper type.

When not in EVAL_NORMAL, we cannot assume that the evaluation returns
such a proper value; it may well return a zero value of the
appropriate type e.g in EVAL_AVOID_SIDE_EFFECTS. It is wrong to try to
unwrap in that case.

In particular, a problem shows up when using expression of the form
{VARIANT_TYPE}OBJ. GDB first evaluates this expression in
EVAL_AVOID_SIDE_EFFECTS to compute the type, the evaluation of OBJ
in most cases returns a zero value of its type, and as UNOP_MEMVAL
is mapped to the default case its evaluation ends up trying to
read memory around address 0.

gdb/ChangeLog:

	* ada-lang.c (ada_evaluate_subexp): Unwrap only in EVAL_NORMAL.
@
text
@d6012 9
d6064 82
d6801 1
a6801 1
        address = value_as_address (arg);
d6803 1
a6803 1
        address = unpack_pointer (t, value_contents (arg));
d7079 3
d7096 4
d8083 10
a8092 6
            struct type *real_type =
              type_from_tag (value_tag_from_contents_and_address
                             (fixed_record_type,
                              valaddr,
                              address));

d8094 3
a8096 1
              return to_fixed_record_type (real_type, valaddr, address, NULL);
a9798 2
            struct type *actual_type;

a9799 8
            actual_type = type_from_tag (ada_value_tag (arg1));
            if (actual_type == NULL)
              /* If, for some reason, we were unable to determine
                 the actual type from the tag, then use the static
                 approximation that we just computed as a fallback.
                 This can happen if the debugging information is
                 incomplete, for instance.  */
              actual_type = type;
d9801 23
a9823 1
            return value_zero (actual_type, not_lval);
@


1.381
log
@	* ada-lang.c (user_select_syms): Use SYMBOL_SYMTAB.
	* dwarf2read.c (dw2_find_symbol_file, fixup_go_packaging): Use
	SYMBOL_SYMTAB.
	* skip.c (skip_info): Use SYMBOL_SYMTAB.
@
text
@d9456 3
a9458 1
      arg1 = unwrap_value (arg1);
@


1.380
log
@	* ada-lang.c (user_select_syms, ada_print_subexp): Pass flags
	to type-printing functions.
	* ada-lang.h (ada_print_type): Add argument.
	* ada-typeprint.c (print_array_type, print_variant_clauses,
	print_variant_part, print_selected_record_field_types,
	print_record_field_types, print_unchecked_union_type,
	print_func_type, ada_print_type): Add flags argument.
	(ada_print_typedef): Update.
	* c-exp.y (OPERATOR conversion_type_id): Update.
	* c-lang.h (c_print_type, c_type_print_base): Update.
	* c-typeprint.c (c_print_type, c_type_print_varspec_prefix,
	c_type_print_modifier, c_type_print_args,
	c_type_print_varspec_suffix, c_type_print_base): Add flags
	argument.
	* cp-valprint.c (cp_print_class_member): Update.
	* dwarf2read.c (dwarf2_compute_name): Update.
	* f-lang.h (f_print_type): Add argument.
	* f-typeprint.c (f_print_type): Add flags argument.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update.
	* go-lang.h (go_print_type): Add argument.
	* go-typeprint.c (go_print_type): Add flags argument.
	* jv-lang.h (java_print_type): Add argument.
	* jv-typeprint.c (java_type_print_base, java_print_type): Add
	flags argument.
	* language.c (unk_lang_print_type): Add flags argument.
	* language.h (struct language_defn) <la_print_type>: Add flags
	argument.
	(LA_PRINT_TYPE): Likewise.
	* m2-lang.h (m2_print_type): Add argument.
	* m2-typeprint.c (m2_print_type, m2_range, m2_typedef,
	m2_array, m2_pointer, m2_ref, m2_procedure, m2_long_set,
	m2_unbounded_array, m2_record_fields): Add flags argument.
	* p-lang.h (pascal_print_type, pascal_type_print_base,
	pascal_type_print_varspec_prefix): Add argument.
	* p-typeprint.c (pascal_print_type,
	pascal_type_print_varspec_prefix, pascal_print_func_args,
	pascal_type_print_varspec_suffix, pascal_type_print_base): Add
	flags argument.
	* symmisc.c (print_symbol): Update.
	* typeprint.c (type_print_raw_options, default_ptype_flags):
	New globals.
	(type_print): Update.
	* typeprint.h (struct type_print_options): New.
	(type_print_raw_options): Declare.
	(c_type_print_varspec_suffix, c_type_print_args): Add argument.
@
text
@d3586 1
a3586 1
          struct symtab *symtab = syms[i].sym->symtab;
@


1.379
log
@[Ada] use lbasename when testing if file is part of Ada runtime.

We use a list of regular expressions to match a symtab filenames
against the names of the files in the Ada runtime.  These regular
expressions do assume that the filename is a basename, however.
So make sure to evaluate these regular expressions against
the symtab's filename.

Without this patch, we run into problems when the Ada runtime was built
using a project file (through gprbuild).

gdb/ChangeLog:

        * ada-lang.c (is_known_support_routine): Use lbasename when
        matching the symtab's filename against
        known_runtime_file_name_patterns.
@
text
@d61 1
d3598 1
a3598 1
                              gdb_stdout, -1, 0);
d12350 2
a12351 1
            LA_PRINT_TYPE (exp->elts[*pos + 1].type, "", stream, 0, 0);
d12381 2
a12382 1
      LA_PRINT_TYPE (exp->elts[pc + 1].type, "", stream, 1, 0);
@


1.378
log
@[Ada] Allow assignment to wide string.

Given the following variable declaration...

   Www : Wide_String := "12345";

... this patch allows the following assignment to work:

   (gdb) set variable www := "qwert"

Without this patch, the debugger rejects the assignment because
the size of the array elements are different:

   (gdb) set www := "asdfg"
   Incompatible types in assignment

(on the lhs, we have an array of 2-bytes elements, and on the rhs,
we have a standard 1-byte string).

gdb/ChangeLog:

        * ada-lang.c (ada_same_array_size_p): New function.
        (ada_promote_array_of_integrals): New function.
        (coerce_for_assign): Add handling of arrays where the elements
        are integrals of a smaller size than the size of the target
        array element type.

gdb/testsuite/ChangeLog:

        * gdb.ada/set_wstr: New testcase.
@
text
@d10976 1
a10976 1
      if (re_exec (sal.symtab->filename))
@


1.377
log
@[Ada] Pointers to unconstrained arrays inside variant record.

gdb/ChangeLog:

        * ada-lang.c (ada_template_to_fixed_record_type_1): Do not
        strip typedef layer when computing the fixed type's field type,
        only when computing its size.

gdb/testsuite/ChangeLog:

        * gdb.ada/unc_arr_ptr_in_var_rec: New testcase.
@
text
@d8632 66
d8722 15
a8736 3
      if (TYPE_LENGTH (type2) != TYPE_LENGTH (type)
          || TYPE_LENGTH (TYPE_TARGET_TYPE (type2))
          != TYPE_LENGTH (TYPE_TARGET_TYPE (type2)))
@


1.376
log
@crash printing optimized out variant type

Assuming the following declarations:

   type Discriminants_Record (A : Integer; B : Boolean) is record
      C : Float;
   end record;
   Z : Discriminants_Record := (A => 1, B => False, C => 2.0);

If variable Z is not used, and the compiler optimizes it out,
GDB would crash as follow:

    (gdb) print Z
    /[...]/gdb/valops.c:1121: internal-error: Unexpected lazy value type.

This is because the ada-lang module forgot to set the optimized_out
flag in the value returned by ada_evaluate_subexp during the value's
"fixing" process.  Later on, when trying to print the resulting value,
GDB finds that the value is still lazily allocated, and thus tries to
fetch it. But this is not allowed for not_lval values, hence the internal
error.

gdb/ChangeLog:

        * ada-lang.c (coerce_unspec_val_to_type): Make sure that
        the optimized_out flag is preserved.

gdb/testsuite/ChangeLog:

        * gdb.ada/optim_drec: New testcase.
@
text
@d7507 2
a7508 1
          struct type *field_type = TYPE_FIELD_TYPE (type, f);
d7510 8
a7517 10
	  /* If our field is a typedef type (most likely a typedef of
	     a fat pointer, encoding an array access), then we need to
	     look at its target type to determine its characteristics.
	     In particular, we would miscompute the field size if we took
	     the size of the typedef (zero), instead of the size of
	     the target type.  */
	  if (TYPE_CODE (field_type) == TYPE_CODE_TYPEDEF)
	    field_type = ada_typedef_target_type (field_type);

          TYPE_FIELD_TYPE (rtype, f) = field_type;
d7523 13
a7535 2
            fld_bit_len =
              TYPE_LENGTH (ada_check_typedef (field_type)) * TARGET_CHAR_BIT;
@


1.375
log
@	* auto-load.c (_initialize_auto_load): Update.
	* solib-svr4.c (_initialize_svr4_solib): Update
	* solib-dsbt.c (_initialize_dsbt_solib): Update.
	* solib-darwin.c (_initialize_darwin_solib): Update.
	* registry.h: New file.
	* python/py-progspace.c (gdbpy_initialize_pspace): Update.
	* python/py-inferior.c (gdbpy_initialize_inferior): Update.
	* progspace.h: Include registry.h.  Use DECLARE_REGISTRY.
	(register_program_space_data_with_cleanup)
	(register_program_space_data, program_space_alloc_data)
	(clear_program_space_data, set_program_space_data)
	(program_space_data): Don't declare.
	* progspace.c: Use DEFINE_REGISTRY.
	(struct program_space_data, struct
	program_space_data_registration, struct
	program_space_data_registry, program_space_data_registry)
	(register_program_space_data_with_cleanup)
	(register_program_space_data, program_space_alloc_data)
	(program_space_free_data, clear_program_space_data)
	(set_program_space_data, program_space_data): Remove.
	* objfiles.h: Include registry.h.  Use DECLARE_REGISTRY.
	(struct objfile) <data, num_data>: Replace with REGISTRY_FIELDS.
	(register_objfile_data_with_cleanup, register_objfile_data)
	(clear_objfile_data, set_objfile_data, objfile_data): Don't
	declare.
	* objfiles.c: Use DEFINE_REGISTRY.
	(struct objfile_data, struct objfile_data_registration, struct
	objfile_data_registry, objfile_data_registry)
	(register_objfile_data_with_cleanup, register_objfile_data)
	(objfile_alloc_data, objfile_free_data, clear_objfile_data)
	(set_objfile_data, objfile_data): Remove.
	(_initialize_objfiles): Update.
	* jit.c (_initialize_jit): Update.
	* inflow.c (_initialize_inflow): Update.
	* inferior.h: Include registry.h.  Use DECLARE_REGISTRY.
	(struct inferior) <data, num_data>: Replace with REGISTRY_FIELDS.
	(register_inferior_data_with_cleanup, register_inferior_data)
	(clear_inferior_data, set_inferior_data, inferior_data): Don't
	declare.
	* inferior.c: Use DEFINE_REGISTRY.
	(struct inferior_data, struct inferior_data_registration, struct
	inferior_data_registry, inferior_data_registry)
	(register_inferior_data_with_cleanup, register_inferior_data)
	(inferior_alloc_data, inferior_free_data  clear_inferior_data)
	(set_inferior_data, inferior_data): Remove.
	* auxv.c (_initialize_auxv): Update.
	* ada-lang.c (_initialize_ada_language): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* i386-nat.c (i386_use_watchpoints): Update.
@
text
@d584 1
@


1.374
log
@	PR c++/13356
	* gdbtypes.c (strict_type_checking): New variable.
	(show_strict_type_checking): New function.
	(rank_one_type): Return NS_POINTER_INTEGER_CONVERSION_BADNESS
	if strict type checking is disabled.
	(_initialize_gdbtypes): Add "check type" subcommand.
	* gdbtypes.h (NS_INTEGER_POINTER_CONVERSION_BADNESS): New struct.

	PR c++/13356
	* gdb.base/default.exp: Update all "check type" tests.
	* gdb.base/help.exp: Likewise.
	* gdb.base/setshow.exp: Likewise.
	* gdb.cp/converts.cc (foo1_type_check): New function.
	(foo2_type_check): New function.
	(foo3_type_check): New function.
	(main): Call new functions.
	* converts.exp: Add tests for integer-to-pointer conversions
	with/without strict type-checking.

	PR c++/13356
	* gdb.texinfo (Type and Range Checking): Remove warning.
	Remove spurious commas.
	Update text and examples for re-implementation of set/show
	check type.
	(C and C++ Type and Range Checks): Likewise.

	* language.h (type_mode): Remove.
	(type_check): Remove.
	(struct language_defn): Remove la_type_check.
	(STRICT_TYPE): Remove unused macro.
	(type_error): Remove.
	* language.c (set_type_range_case): Renamed to ...
	(set_range_case): ... this.  Update all callers.
	Remove type_mode/type_check.
	(type_mode): Remove.
	(type_check): Remove.
	(show_type_command): Remove.
	(set_type_command): Remove.
	(language_info): Remove type checking output.
	(type_error): Remove unused function.
	(range_error): Update comment.
	(unknown_language_defn): Remove la_type_check.
	(auto_language_defn): Likewise.
	(local_language_defn): Likewise.
	(_initialize_language): Remove "check type" subcommand.
	* ada-lang.c (ada_language_defn): Remove la_type_check.
	* c-lang.c (c_language_defn): Likewise.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	* d-lang.c (d_language_defn): Likewise.
	* f-lang.c (f_language_defn): Likewise.
	* go-lang.c (go_language_defn): Likewise.
	* jv-lang.c (java_language_defn): Likewise.
	* m2-lang.c (m2_language_defn): Likewise.
	* objc-lang.c (objc_language_defn): Likewise.
	* opencl-lang.c (opencl_language_defn): Likewise.
	* p-lang.c (pascal_language_defn): Likewise.
@
text
@d12660 1
a12660 1
    = register_inferior_data_with_cleanup (ada_inferior_data_cleanup);
@


1.373
log
@	PR macros/7961:
	* varobj.c (varobj_create): Update.
	(varobj_set_value): Update.
	* tracepoint.c (validate_actionline): Update.
	(encode_actions_1): Update.
	* parse.c (parse_exp_1): Add 'pc' argument.
	(parse_exp_in_context): Add 'pc' argument.  Change how
	expression_context_pc is set.
	(parse_expression): Update.
	(parse_field_expression): Update.
	* expression.h (parse_exp_1): Update.
	* eval.c (parse_to_comma_and_eval): Update.
	* breakpoint.c (set_breakpoint_condition): Update.
	(update_watchpoint): Update.
	(init_breakpoint_sal): Update
	(find_condition_and_thread): Update.
	(watch_command_1): Update.
	(update_breakpoint_locations): Update.
	* ada-lang.c (ada_read_renaming_var_value): Update.
	(create_excep_cond_exprs): Update.
testsuite
	* gdb.base/macscp1.c (macscp_expr): Add breakpoint comment.
	* gdb.base/macscp.exp (maybe_kfail): Add test for macro scope.
@
text
@a12501 1
  type_check_off,
@


1.372
log
@gdb:
	* corefile.c (write_memory_with_notification): New.
	* gdbcore.h: Declare write_memory_with_notification.
	* ada-lang.c (ada_value_assign): Replace 'write_memory' and
	'observer_notify_memory_changed' with 'write_memory_with_notification'.
	* valops.c (value_assign): Likewise.
	* python/py-inferior.c (infpy_write_memory): Call
	'write_memory_with_notification'.
@
text
@d4063 1
a4063 1
  expr = parse_exp_1 (&sym_name, block, 0);
d11143 2
a11144 1
	      exp = parse_exp_1 (&s, block_for_pc (bl->address), 0);
@


1.371
log
@	* ada-lang.c (ada_make_symbol_completion_list): Return a VEC.
	* breakpoint.c (catch_syscall_completer): Return a VEC.
	* cli/cli-cmds.c (complete_command): Update.
	* cli/cli-decode.c (complete_on_cmdlist): Return a VEC.
	(complete_on_enum): Likewise.
	* command.h: Include gdb_vecs.h.
	(completer_ftype): Change return type.
	(complete_on_cmdlist, complete_on_enum): Likewise.
	* completer.c (noop_completer, filename_completer)
	(location_completer): Return a VEC.
	(add_struct_fields): Remove 'nextp' argument.  Change 'output'
	to a VEC.
	(expression_completer, complete_line_internal, complete_line)
	(command_completer): Return a VEC.
	(gdb_completion_word_break_characters, line_completion_function):
	Update.
	* completer.h: Include gdb_vecs.h.
	(complete_line, noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer):
	Update.
	* f-lang.c (f_word_break_characters): Return a VEC.
	* interps.c (interpreter_completer): Return a VEC.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Return a VEC.
	* python/py-cmd.c (cmdpy_completer): Return a VEC.
	* symtab.c (free_completion_list): Take a VEC.
	(return_val_size, return_val_index): Remove.
	(return_val): Now a VEC.
	(completion_list_add_name): Update.
	(default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_list_fn, make_file_symbol_completion_list):
	Return a VEC.
	(add_filename_to_list): Update.
	(struct add_partial_filename_data) <list_used, list_alloced>: Remove.
	<list>: Now a VEC.
	(maybe_add_partial_symtab_filename): Update.
	(make_source_files_completion_list): Return a VEC.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_list_fn, make_file_symbol_completion_list)
	(make_source_files_completion_list): Update.
@
text
@d2537 1
a2537 2
      write_memory (to_addr, buffer, len);
      observer_notify_memory_changed (to_addr, len, buffer);
@


1.370
log
@	* gdb/ada-lang.c (standard_lookup): Prevent uninitialized variable
	warning.
@
text
@d5800 2
a5801 3
/* Return a list of possible symbol names completing TEXT0.  The list
   is NULL terminated.  WORD is the entire command on which completion
   is made.  */
d5803 1
a5803 1
static char **
d5916 1
a5916 18
  /* Append the closing NULL entry.  */
  VEC_safe_push (char_ptr, completions, NULL);

  /* Make a copy of the COMPLETIONS VEC before we free it, and then
     return the copy.  It's unfortunate that we have to make a copy
     of an array that we're about to destroy, but there is nothing much
     we can do about it.  Fortunately, it's typically not a very large
     array.  */
  {
    const size_t completions_size = 
      VEC_length (char_ptr, completions) * sizeof (char *);
    char **result = xmalloc (completions_size);
    
    memcpy (result, VEC_address (char_ptr, completions), completions_size);

    VEC_free (char_ptr, completions);
    return result;
  }
@


1.369
log
@	PR c++/7173:
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Return early for Java
	types.
	* value.h (value_cast_pointers): Update.
	* valops.c (value_cast_pointers): Add 'subclass_check' argument.
	(value_cast): Update.
	(update_search_result): New function.
	(do_search_struct_field): New, from search_struct_field.  Check
	for ambiguous results.
	(search_struct_field): Rewrite.
	* infcall.c (value_arg_coerce): Update.
	* eval.c (evaluate_subexp_standard) <STRUCTOP_MEMBER>: Use
	value_cast_pointers.
	* ada-lang.c (ada_convert_actual): Update.
testsuite
	* gdb.cp/inherit.exp (test_print_mi_members): Expect errors.
	Remove kfails.
	(test_print_mi_member_types): Likewise.
@
text
@d4259 2
a4260 1
  struct symbol *sym;
@


1.368
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d4142 1
a4142 1
      return value_cast_pointers (formal_type, result);
@


1.367
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (lookup_block_symbol, iterate_over_symbols)
	(find_pc_sect_symtab, search_symbols)
	(default_make_symbol_completion_list_break_on)
	(make_file_symbol_completion_list): Update.
	* symmisc.c (dump_symtab_1): Update.
	* stack.c (print_frame_args, iterate_over_block_locals)
	(print_frame_labels, iterate_over_block_arg_vars): Update.
	* python/py-block.c (block_object) <dict>: Remove.
	<block>: New field.
	<iter>: Change type.
	(blpy_iter): Update.
	(blpy_block_syms_iternext): Update.
	* psymtab.c (map_block): Use block iterators.
	* objfiles.c (objfile_relocate1): Use ALL_DICT_SYMBOLS.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* mdebugread.c (parse_symbol, mylookup_symbol): Update.
	* infrun.c (check_exception_resume): Update.
	* cp-support.c (make_symbol_overload_list_block): Update.
	* coffread.c (patch_opaque_types): Update.
	* buildsym.c (finish_block, end_symtab): Use ALL_DICT_SYMBOLS.
	* block.h (struct block_iterator): New.
	(block_iterator_first, block_iterator_next, block_iter_name_first)
	(block_iter_name_next, block_iter_match_first)
	(block_iter_match_next): Declare.
	(ALL_BLOCK_SYMBOLS): Redefine.
	* block.c (block_iterator_first, block_iterator_next)
	(block_iter_name_first, block_iter_name_next)
	(block_iter_match_first, block_iter_match_next): New functions.
	* ada-lang.c (ada_add_block_symbols)
	(ada_make_symbol_completion_list): Use block iterator.
@
text
@d5473 1
a5473 1
  const char *p, *n;
a10821 1
  struct symbol *sym;
@


1.366
log
@Add proper handling for internal functions and STT_GNU_IFUNC symbols in Ada mode.

The code for handling calls to internal functions (esp., Python
functions) and for handling STT_GNU_IFUNC had not been added to the Ada
expression evaluator.  This change adapts them from eval.c.

gdb/Changelog:

        * ada-lang.c (ada_evaluate_subexp): Add cases for
          TYPE_CODE_INTERNAL_FUNCTION and for TYPE_GNU_IFUNC, following
          their treatment in eval.c.
@
text
@d5518 1
a5518 1
  struct dict_iterator iter;
d5530 2
a5531 3
      for (sym = dict_iter_match_first (BLOCK_DICT (block), name,
					wild_match, &iter);
	   sym != NULL; sym = dict_iter_match_next (name, wild_match, &iter))
d5553 2
a5554 3
     for (sym = dict_iter_match_first (BLOCK_DICT (block), name,
				       full_match, &iter);
	   sym != NULL; sym = dict_iter_match_next (name, full_match, &iter))
d5817 1
a5817 1
  struct dict_iterator iter;
@


1.365
log
@gdb/
	PR symtab/7259:
	* ada-exp.y (convert_char_literal): Use TYPE_FIELD_ENUMVAL.
	* ada-lang.c (ada_discrete_type_high_bound)
	(ada_discrete_type_low_bound): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(ada_identical_enum_types_p): Use TYPE_FIELD_ENUMVAL.
	(pos_atr, value_val_atr): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* ada-typeprint.c (print_enum_type): Change variable lastval to LONGEST.
	Use TYPE_FIELD_ENUMVAL.
	* ada-valprint.c (print_optional_low_bound, ada_print_scalar)
	(ada_val_print_1): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* c-typeprint.c (c_type_print_base): Move variable lastval to inner
	block, change it to LONGEST.  Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* coffread.c (coff_read_enum_type): Use SET_FIELD_ENUMVAL.
	* dwarf2read.c (process_enumeration_scope): Likewise.
	* gdb-gdb.py (TypeFlagsPrinter): Use field.enumval instead of
	field.bitpos.
	(class StructMainTypePrettyPrinter): Support also
	FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.c (get_discrete_bounds): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(recursive_dump_type): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(copy_type_recursive): Support also FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.h (enum field_loc_kind): New FIELD_LOC_KIND_ENUMVAL.
	(struct main_type.flds_bnds.fields.loc): Adjust bitpos comment.  New
	field enumval.
	(struct main_type.flds_bnds.bields): Adjust loc_kind and bitsize to
	accommodate enumval.
	(struct call_site): Adjust loc_kind to accommodate enumval.
	(FIELD_ENUMVAL, FIELD_ENUMVAL_LVAL, SET_FIELD_ENUMVAL)
	(TYPE_FIELD_ENUMVAL): New macros.
	* m2-typeprint.c (m2_enum): Use TYPE_FIELD_ENUMVAL.
	* mdebugread.c (parse_symbol): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* python/lib/gdb/printing.py (class FlagEnumerationPrinter): Use
	enumval.
	* python/lib/gdb/types.py (make_enum_dict): Likewise.
	* python/py-type.c (convert_field): New variable addrstring.  Use
	TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(check_types_equal): Support also FIELD_LOC_KIND_ENUMVAL.
	* stabsread.c (read_enum_type): Use SET_FIELD_ENUMVAL.
	* typepint.c (print_type_scalar): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* valprint.c (generic_val_print): Likewise.

gdb/testsuite/
	PR symtab/7259:
	* gdb.base/enumval.c: New test case.
	* gdb.base/enumval.exp: New test case.
	* gdb.python/py-type.exp (test_enums): Use field.enumval instead of
	field.bitpos.
@
text
@d9720 7
a9726 1
            return allocate_value (TYPE_TARGET_TYPE (type));
d9728 11
@


1.364
log
@gdb/
	Do not rely on FIELD_LOC_KIND_BITPOS being zero.
	* ada-lang.c (ada_template_to_fixed_record_type_1): Replace
	TYPE_FIELD_BITPOS used as lvalue by SET_FIELD_BITPOS.
	* gdbtypes.c (append_flags_type_flag): Likewise, twice.
	* jv-lang.c (java_link_class_type): Likewise, once.
	* stabsread.c (read_enum_type): Likewise.
@
text
@d693 1
a693 1
      return TYPE_FIELD_BITPOS (type, TYPE_NFIELDS (type) - 1);
d704 1
a704 1
/* The largest value in the domain of TYPE, a discrete type, as an integer.  */
d713 1
a713 1
      return TYPE_FIELD_BITPOS (type, 0);
d4482 1
a4482 1
    if (TYPE_FIELD_BITPOS (type1, i) != TYPE_FIELD_BITPOS (type2, i))
d8301 1
a8301 1
          if (v == TYPE_FIELD_BITPOS (type, i))
d8332 1
a8332 1
      return value_from_longest (type, TYPE_FIELD_BITPOS (type, pos));
@


1.363
log
@Rename variables in ada-lang.c:ada_make_symbol_completion_list.

This renaming allows us to have variable names that are consistent
with the names of the parameters in the functions where these
variables are used.  This also allows us to avoid a -Wshadow warning
in the case of variable "wild_match", which is now renamed to
"wild_match_p".

gdb/ChangeLog:

        -Wshadow warning fix.
        * ada-lang.c (ada_make_symbol_completion_list): Rename parameters
        "wild_match" and "encoded" into "wild_match_p" and "encoded_p".
        Adjust code accordingly.
@
text
@d7448 1
a7448 1
      TYPE_FIELD_BITPOS (rtype, f) = off;
@


1.362
log
@Rename "encoded" parameter in ada-lang.c:symbol_completion_add...

... This is mostly to be consistent with the style used for the other
parameter of the same kind ("wild_match_p") in that function.

gdb/ChangeLog:

        * ada-lang.c (symbol_completion_add): Rename parameter
        "encoded" into "encoded_p".  Ajust code and documentation
        accordingly.
@
text
@d5810 2
a5811 2
  int wild_match;
  int encoded;
d5826 2
a5827 2
      wild_match = 0;
      encoded = 1;
d5837 1
a5837 1
      encoded = (strstr (text0, "__") != NULL);
d5842 1
a5842 1
      wild_match = (strchr (text0, '.') == NULL && !encoded);
d5854 2
a5855 2
    data.wild_match = wild_match;
    data.encoded = encoded;
d5868 2
a5869 1
                           text, text_len, text0, word, wild_match, encoded);
d5884 1
a5884 1
                               wild_match, encoded);
d5899 1
a5899 1
                             wild_match, encoded);
d5914 1
a5914 1
                             wild_match, encoded);
@


1.361
log
@Rename "wild_match" parameter in ada-lang.c:symbol_completion_add...

... to avoid a -Wshadow warning.

gdb/ChangeLog:

        -Wshadow warning fix.
        * ada-lang.c (symbol_completion_add): Rename parameter
        "wild_match" into wild_match_p.  Update code and documentation
        accordingly.
@
text
@d5734 1
a5734 1
   ENCODED should be set if TEXT represents a symbol name in its
d5743 1
a5743 1
                       int wild_match_p, int encoded)
d5746 1
a5746 1
                                               wild_match_p, encoded);
@


1.360
log
@Rename "encoded" parameter in ada-lang.c:symbol_completion_match...

... This is mostly to be consistent with the style used for the other
parameter of the same kind ("wild_match_p") in that function.

gdb/ChangeLog:

        * ada-lang.c (symbol_completion_match): Rename parameter
        "encoded" into "encoded_p".  Ajust code and documentation
        accordingly.
@
text
@d5733 1
a5733 1
   if WILD_MATCH is set, then wild matching is performed.
d5743 1
a5743 1
                       int wild_match, int encoded)
d5746 1
a5746 1
                                               wild_match, encoded);
@


1.359
log
@Rename "wild_match" parameter in ada-lang.c:symbol_completion_match

gdb/ChangeLog:

        -Wshadow warning fix.
        * ada-lang.c (symbol_completion_match): Rename parameter
        "wild_match" into "wild_match_p".  Adjust code and function
        documentation accordingly.
@
text
@d5644 1
a5644 1
   ENCODED should be set if TEXT represents the start of a symbol name
d5650 1
a5650 1
                         int wild_match_p, int encoded)
d5667 1
a5667 1
  if (match && !encoded)
d5717 1
a5717 1
  if (!encoded)
@


1.358
log
@rename "symbol_info" to "sym_info" in ada-lang.c...

... to avoid a -Wshadow warning with a symbol exported by BFD.

gdb/ChangeLog:

        -Wshadow warning fix.
        * ada-lang.c (ada_lookup_encoded_symbol): Rename parameter
        "symbol_info" into "info".  Adjust code accordingly.
        (ada_lookup_symbol): Likewise.
@
text
@d5643 1
a5643 1
   Perform a wild match if WILD_MATCH is set.
d5650 1
a5650 1
                         int wild_match, int encoded)
d5698 1
a5698 1
  if (!match && wild_match)
@


1.357
log
@Minor reformatting of ada_lookup_symbol_list's documentation.

This patch mostly removes a few trailing spaces.

gdb/ChangeLog:

        * ada-lang.c (ada_lookup_symbol_list): Minor reformatting
        of this function's documentation.
@
text
@d5201 2
a5202 2
   The result is stored in *SYMBOL_INFO, which must be non-NULL.
   If no match is found, SYMBOL_INFO->SYM is set to NULL.  */
d5207 1
a5207 1
			   struct ada_symbol_info *symbol_info)
d5212 2
a5213 2
  gdb_assert (symbol_info != NULL);
  memset (symbol_info, 0, sizeof (struct ada_symbol_info));
d5221 2
a5222 2
  *symbol_info = candidates[0];
  symbol_info->sym = fixup_symbol_section (symbol_info->sym, NULL);
d5235 1
a5235 1
  struct ada_symbol_info symbol_info;
d5241 2
a5242 2
			     block0, namespace, &symbol_info);
  return symbol_info.sym;
@


1.356
log
@Rename "wild_match" variable in ada-lang.c:ada_lookup_symbol_list

... to avoid -Wshadow warning...

gdb/ChangeLog:

        -Wshadow warning fix.
        * ada-lang.c (ada_lookup_symbol_list): Rename "wild_match"
        variable into "wild_match_p".  Adjust code accordingly.
@
text
@d5053 2
a5054 2
   scope and in global scopes, returning the number of matches.  Sets
   *RESULTS to point to a vector of (SYM,BLOCK) tuples,
d5056 2
a5057 2
   any) in which they were found.  This vector are transient---good only to 
   the next call of ada_lookup_symbol_list.  Any non-function/non-enumeral 
d5064 1
a5064 1
   Names prefixed with "standard__" are handled specially: "standard__" 
@


1.355
log
@Rename "wild_match" parameter in ada-lang.c:ada_add_local_symbols

... to avoid -Wshadow warning...

gdb/ChangeLog:

        -Wshadow warning fix.
        * ada-lang.c (ada_add_local_symbols): Rename "wild_match"
        parameter into "wild_match_p".  Adjust code accordingly.
        Document this parameter in the function description.
@
text
@d5076 1
a5076 1
  const int wild_match = should_use_wild_match (name0);
d5108 1
a5108 1
                         wild_match);
d5127 1
a5127 1
			wild_match);
d5134 1
a5134 1
			  wild_match);
@


1.354
log
@Rename "wild_match" parameter in add_symbols_from_enclosing_procs

gdb/ChangeLog:

        -Wshadow warning fix.
        * ada-lang.c (add_symbols_from_enclosing_procs): Rename
        "wild_match" parameter to "wild_match_p" (-Wshadow).
@
text
@d4885 2
d4893 1
a4893 1
                       int wild_match)
d4900 2
a4901 1
      ada_add_block_symbols (obstackp, block, name, domain, NULL, wild_match);
d4914 1
a4914 1
    add_symbols_from_enclosing_procs (obstackp, name, domain, wild_match);
@


1.353
log
@Remove trailing spaces in ada-lang.c:ada_lookup_simple_minsym doc.

gdb/ChangeLog:

        * ada-lang.c (ada_lookup_simple_minsym): Remove trailing spaces
        in function documentation.
@
text
@d4442 2
a4443 2
   ada_add_block_symbols (q.v.).   If WILD, treat as NAME with a
   wildcard prefix.  */
d4448 1
a4448 1
                                  int wild_match)
@


1.352
log
@Fix -Wshadow warning in ada-lang.c:ada_lookup_simple_minsym

gdb/ChangeLog:

        -Wshadow warning fix.
        * ada-lang.c (ada_lookup_simple_minsym): Rename wild_match local
        variable into wild_match_p.  Adjust code accordingly.
@
text
@d4408 2
a4409 2
   rules.  Returns NULL if there is no such minimal symbol.  Names 
   prefixed with "standard__" are handled specially: "standard__" is 
@


1.351
log
@Make ada_lookup_encoded_symbol "return" a struct ada_symbol_info

This makes ada_lookup_encoded_symbol more consistent with other functions
such as ada_lookup_symbol_list, and also makes it clearer in the code
using that function that symbol and block are related.

gdb/ChangeLog:

        * ada-lang.c (ada_lookup_encoded_symbol): Now returns void.
        Replace block_found argument by symbol_info.  Adjust
        implementation accordingly.  Add function documentation.
        (ada_lookup_symbol): Adjust to new ada_lookup_encoded_symbol.
        Fix documentation.
        * ada-lang.h (ada_lookup_encoded_symbol): Update declaration.
        * ada-exp.y (write_object_renaming): Adjust to new
        ada_lookup_encoded_symbol API.
@
text
@d4417 1
a4417 1
  const int wild_match = should_use_wild_match (name);
d4431 1
a4431 1
    if (match_name (SYMBOL_LINKAGE_NAME (msymbol), name, wild_match)
@


1.350
log
@[Ada] Crash when trying to set value of packed array element

Consider the following declaration:

   type Small is new Integer range 0 .. 2 ** 4 - 1;
   type Simple_Array is array (1 .. 4) of Small;
   pragma Pack (Simple_Array);

   SA : Simple_Array := (1, 2, 3, 4);

Trying to change the value of one of the elements in the packed array
causes the debugger to crash:

    (gdb) set sa(3) := 9
    [1]    4880 segmentation fault  gdb -q foo

The circumstances leading to the crash are as follow:

   . ada_evaluate_subexp creates a value corresponding to "sa(3)".

   . ada_evaluate_subexp then tries to assign 9 to this value, and
     for this calls value_assign (via ada_value_assign).

   . Because the array is packed, the destination value is 3 bits long,
     and as a result, value_assign uses the parent to determine that
     element byte address and offset:

      | if (value_bitsize (toval))
      |   {
      |     struct value *parent = value_parent (toval);
      |
      |     changed_addr = value_address (parent) + value_offset (toval);

The destination value (corresponding to "sa(3)") was incorrectly created
by ada-lang.c:ada_value_primitive_packed_val, because the "parent" was
left as NULL. So, when we try to dereference it to get the parent address,
GDB crashed.

The first part of the fix therefore consists in setting that field.
This required the addition of a new "setter" in value.[hc].  It fixes
the crash, but is still not sufficient for the assignment to actually
work.

The second part of the problem came from the fact that value_assign
seems to expect the "child"'s address to be equal to the parent's address,
with the difference being the offset. Unfortunately, this requirement was
not followed by ada_value_primitive_packed_val, so the second part of
the fix consisted in fixing that.

Still, this was not sufficient, because it caused a regression when
trying to perform an aggregate assignment of a packed array of packed
record.  The key element here is the nesting of packed entities.
Looking at the way ada_value_primitive_packed_val creates the value
of each sub-component, one can see that the value's offset is set
to the offset compared to the start of the parent. This was meant to
match what value_primitive_field does as well.

So, with our array of records, if the record offset was 2, and if
the field we're interested in that record is at offset 1, the record
value's offset would be set to 2, and the field value's offset would
be set to 1. But the address for both values would be left to the
array's address. This is where things start breaking down, because
the value_address function for our field value would return the
address of the array + 1, instead of + 3.

This is what causes the final issue, here, because ada-lang.c's
value_assign_to_component needs to compute the offset of the
subcomponent compared to the top-level aggregate's start address
(the array in our case). And it does so by subtracting the array's
address from the sub-component's address.  When you have two levels
of packed components, and the mid-level component is at an offset of
the top-level component, things didn't work, because the component's
address was miscomputed (the parent's offset is missing).

The fix consists is fixing value_address to match the work done by
value_primitive_field (where we ignore the parent's offset).

gdb/ChangeLog:

        * value.h (set_value_parent): Add declaration.
        * value.c (set_value_parent): New function.
        (value_address): If VALUE->PARENT is not NULL, then use it as
        the base address instead of VALUE->LOCATION.address.
        * ada-lang.c (ada_value_primitive_packed_val): Keep V's address
        the same as OBJ's address.  Adjust V's offset accordingly.
        Set V's parent.

gdb/testsuite/ChangeLog:

        * gdb.ada/set_pckd_arr_elt: New testcase.
@
text
@d5194 11
a5204 3
struct symbol *
ada_lookup_encoded_symbol (const char *name, const struct block *block0,
			   domain_enum namespace, struct block **block_found)
d5209 4
a5212 1
  n_candidates = ada_lookup_symbol_list (name, block0, namespace, &candidates,
d5216 1
a5216 1
    return NULL;
d5218 3
a5220 5
  if (block_found != NULL)
    *block_found = candidates[0].block;

  return fixup_symbol_section (candidates[0].sym, NULL);
}  
d5226 2
a5227 3
   *IS_A_FIELD_OF_THIS is set to 0 and *SYMTAB is set to the symbol
   table in which the symbol was found (in both cases, these
   assignments occur only if the pointers are non-null).  */
d5232 2
d5237 3
a5239 3
  return
    ada_lookup_encoded_symbol (ada_encode (ada_fold_name (name)),
			       block0, namespace, NULL);
@


1.349
log
@language-specific read_var_value for Ada renamings

The purpose of this patch is to better support renamings in the
"info locals" command. Consider ...

    procedure Foo is
       GV : Integer renames Pck.Global_Variable;
    begin
       Increment (GV); -- STOP
    end Foo;

... Pck.Global_Variable is just an integer. After having stopped at
the "STOP" line, "info locals" yields:

    (gdb) info locals
    gv = <error reading variable gv (Cannot access memory at address 0xffffffffffffffff)>

In reality, two things are happening:

   (1) Variable "GV" does not exist, which is normal, since there is
       "GV" the renaming of another variable;

   (2) But to allow the user access to that renaming the same way
       the code has, the compiler produces an artificial variable
       whose name encodes the renaming:

        gv___XR_pck__global_variable___XE

       For practical reasons, the artificial variable itself is given
       irrelevant types and addresses.

But the "info locals" command does not act as if it was a short-cut
of "foreach VAR in locals, print VAR". Instead it gets the value of
each VAR directly, which does not work in this case, since the variable
is artificial and needs to be decoded first.

This patch makes the "read_var_value" routine language-specific.
The old implementation of "read_var_value" gets renamed to
"default_read_var_value" and all languages now use it (unchanged
behavior), except for Ada. In Ada, the new function ada_read_var_value
checks if we have a renaming, and if so, evaluates its value, or else
defers to default_read_var_value.

gdb/ChangeLog:

        * language.h (struct language_defn): New "method" la_read_var_value.
        * findvar.c: #include "language.h".
        (default_read_var_value): Renames read_var_value.  Rewrite
        function description.
        (read_var_value): New function.
        * value.h (default_read_var_value): Add prototype.
        * ada-lang.c (ada_read_renaming_var_value, ada_read_var_value):
        New functions.
        (ada_language_defn): Add entry for la_read_var_value.
        * c-lang.c, d-lang.c, f-lang.c, jv-lang.c, language.c,
        * m2-lang.c, objc-lang.c, opencl-lang.c, p-lang.c: Update
        language_defn structures to add entry for new la_read_var_value
        field.
@
text
@d2300 1
a2300 2
      v = value_at (type,
                    value_address (obj) + offset);
d2302 1
a2302 1
      read_memory (value_address (v), bytes, len);
d2312 1
a2312 1
      CORE_ADDR new_addr;
a2314 1
      new_addr = value_address (obj) + offset;
d2319 1
a2319 1
	  ++new_addr;
d2322 6
a2327 1
      set_value_address (v, new_addr);
@


1.348
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (ada_modulus_from_name): Delete.
	* ada-lex.l (lexer_init): Make static.
@
text
@d4044 20
a4063 1
}  
d4065 3
d12462 22
d12504 1
@


1.347
log
@ada-lang.c:ada_find_renaming_symbol minor improvement.

This is a minor improvement in ada_find_renaming_symbol: What we were
doing was going from a symbol, get its name, and then search for
renamings.  But if the original symbol was already itself a renaming,
then we'd look the symbol up again to return it.  Since we had the
symbol in the first place, we shouldn't need to look it up again.

This is what this patch does: Modify ada_find_renaming_symbol to
take a symbol instead of the symbol's (linkage) name, and then updates
the one caller.

gdb/ChangeLog:

        * ada-lang.h (ada_find_renaming_symbol): Replace parameter
        "name" with "struct symbol *name_sym".
        * ada-exp.y (write_var_or_type): Update call to
        ada_find_renaming_symbol.
        * ada-lang.c (ada_find_renaming_symbol): Replace parameter
        "name" with "struct symbol *name_sym". Adjust Implementation
        accordingly.  Adjust the function documentation.
@
text
@a10600 31
/* Try to determine the lower and upper bounds of the given modular type
   using the type name only.  Return non-zero and set L and U as the lower
   and upper bounds (respectively) if successful.  */

int
ada_modulus_from_name (struct type *type, ULONGEST *modulus)
{
  const char *name = ada_type_name (type);
  const char *suffix;
  int k;
  LONGEST U;

  if (name == NULL)
    return 0;

  /* Discrete type bounds are encoded using an __XD suffix.  In our case,
     we are looking for static bounds, which means an __XDLU suffix.
     Moreover, we know that the lower bound of modular types is always
     zero, so the actual suffix should start with "__XDLU_0__", and
     then be followed by the upper bound value.  */
  suffix = strstr (name, "__XDLU_0__");
  if (suffix == NULL)
    return 0;
  k = 10;
  if (!ada_scan_number (suffix, k, &U, NULL))
    return 0;

  *modulus = (ULONGEST) U + 1;
  return 1;
}

@


1.346
log
@Minor cleanup to a couple of functions in ada-lang.c.

gdb/ChangeLog:

        * ada-lang.h (ada_find_any_symbol, ada_find_any_type): Delete.
        * ada-lang.c (ada_find_any_type): Add advance declaration.
        Make static.  Replace ada_find_any_symbol by
        ada_find_any_type_symbol.
        (ada_find_any_type_symbol): Renames ada_find_any_symbol.
        Improve function description.  Make static.
        (ada_find_renaming_symbol, find_old_style_renaming_symbol):
        Replace ada_find_any_symbol by ada_find_any_type_symbol.
@
text
@d7057 5
a7061 4
/* Given NAME and an associated BLOCK, search all symbols for
   NAME suffixed with  "___XR", which is the ``renaming'' symbol
   associated to NAME.  Return this symbol if found, return
   NULL otherwise.  */
d7064 1
a7064 1
ada_find_renaming_symbol (const char *name, struct block *block)
d7066 1
d7069 3
@


1.345
log
@[Ada] avoid error message pollution with uninitialized tagged variable

Consider the following function...

  3 procedure Foo is
  4    I : Integer := Ident (10);
  5    Obj : Base;
  6 begin
  7    Obj.X := I;
  8    Do_Nothing (Obj.X'Address);
  9 end Foo;

... where type "Base" is defined as a plain tagged record. If the user
stops execution before "Obj" gets initialized (for example, by inserting
a breakpoint "on" the function - or in other words, by inserting a
breakpoint using the function name as the location), one might get
the following of output if you try printing the value of obj:

    (gdb) p obj
    object size is larger than varsize-limit
    object size is larger than varsize-limit
    object size is larger than varsize-limit
    $1 = object size is larger than varsize-limit
    (x => 4204154)

Same thing with "info locals":

   (gdb) info locals
    i = 0
    obj = object size is larger than varsize-limit
    (x => 4204154)

We have also seen different error messages such as "Cannot read
memory at 0x...".

The error happens because we are trying to read the dispatch table
of a tagged type variable before it gets initialized.  So the errors
might legitimately occur, and are supposed to be be contained.
However, the way things are written in ada-lang.c:ada_tag_name,
although the exception is in fact contained, the error message still
gets to be printed out.

This patch prevents this from happening by eliminating the use of
catch_errors, and using a TRY_CATCH block instead.  Doing this removed
the need to use functions specifically fitted for catch_errors, and
thus some other simplifications could me made.  In the end, the code
got reorganized a bit to better show the logic behind it, as well as
the common patterns.

gdb/ChangeLog:

        * ada-lang.c (struct tag_args): Delete.
        (ada_get_tsd_type): Function body moved up in source file.
        (ada_tag_name_1, ada_tag_name_2): Delete.
        (ada_get_tsd_from_tag): New function.
        (ada_tag_name_from_tsd): New function.
        (ada_tag_name): Use a TRY_CATCH block instead of catch_errors
        to determine the tag name.

gdb/testsuite/ChangeLog:

        * gdb.ada/tagged_not_init: New testcase.
@
text
@d274 2
d7027 1
a7027 1
/* Find a symbol named NAME.  Ignores ambiguity.  */
d7029 2
a7030 2
struct symbol *
ada_find_any_symbol (const char *name)
d7046 1
a7046 1
struct type *
d7049 1
a7049 1
  struct symbol *sym = ada_find_any_symbol (name);
d7073 1
a7073 1
  sym = ada_find_any_symbol (name);
d7131 1
a7131 1
  return ada_find_any_symbol (rename);
@


1.344
log
@[Ada] New functions to decode Ada types and values

This patch introduces two new functions that will be used to support
the implementation of the ada-varobj effort.  The function descriptions
should say it all...

gdb/ChangeLog:

        * ada-lang.h (ada_get_decoded_value, ada_get_decoded_type): Add
        declaration.
        * ada-lang.c (ada_get_decoded_value, ada_get_decoded_type): New
        function.
@
text
@d6032 4
a6035 1
struct tag_args
d6037 1
a6037 3
  struct value *tag;
  char *name;
};
d6039 4
d6044 2
a6045 2
static int ada_tag_name_1 (void *);
static int ada_tag_name_2 (struct tag_args *);
d6047 1
a6047 4
/* Wrapper function used by ada_tag_name.  Given a struct tag_args*
   value ARGS, sets ARGS->name to the tag name of ARGS->tag.
   The value stored in ARGS->name is valid until the next call to 
   ada_tag_name_1.  */
d6049 2
a6050 2
static int
ada_tag_name_1 (void *args0)
a6051 3
  struct tag_args *args = (struct tag_args *) args0;
  static char name[1024];
  char *p;
d6053 10
d6064 10
a6073 2
  args->name = NULL;
  val = ada_value_struct_elt (args->tag, "tsd", 1);
d6075 2
a6076 10
    return ada_tag_name_2 (args);
  val = ada_value_struct_elt (val, "expanded_name", 1);
  if (val == NULL)
    return 0;
  read_memory_string (value_as_address (val), name, sizeof (name) - 1);
  for (p = name; *p != '\0'; p += 1)
    if (isalpha (*p))
      *p = tolower (*p);
  args->name = name;
  return 0;
d6079 2
a6080 1
/* Return the "ada__tags__type_specific_data" type.  */
d6082 2
a6083 4
static struct type *
ada_get_tsd_type (struct inferior *inf)
{
  struct ada_inferior_data *data = get_ada_inferior_data (inf);
d6085 2
a6086 12
  if (data->tsd_type == 0)
    data->tsd_type = ada_find_any_type ("ada__tags__type_specific_data");
  return data->tsd_type;
}

/* Utility function for ada_tag_name_1 that tries the second
   representation for the dispatch table (in which there is no
   explicit 'tsd' field in the referent of the tag pointer, and instead
   the tsd pointer is stored just before the dispatch table.  */
   
static int
ada_tag_name_2 (struct tag_args *args)
a6087 1
  struct type *info_type;
d6090 1
a6090 1
  struct value *val, *valp;
d6092 1
a6092 9
  args->name = NULL;
  info_type = ada_get_tsd_type (current_inferior());
  if (info_type == NULL)
    return 0;
  info_type = lookup_pointer_type (lookup_pointer_type (info_type));
  valp = value_cast (info_type, args->tag);
  if (valp == NULL)
    return 0;
  val = value_ind (value_ptradd (valp, -1));
d6094 1
a6094 4
    return 0;
  val = ada_value_struct_elt (val, "expanded_name", 1);
  if (val == NULL)
    return 0;
d6099 1
a6099 2
  args->name = name;
  return 0;
d6103 5
a6107 1
   a C string.  */
d6112 2
a6113 1
  struct tag_args args;
d6117 19
a6135 4
  args.tag = tag;
  args.name = NULL;
  catch_errors (ada_tag_name_1, &args, NULL, RETURN_MASK_ALL);
  return args.name;
@


1.343
log
@[Ada] Fix comment in ada-lang.c:ada_is_ignored_field

Fix a comment that completly mistunderstood the code...

gdb/ChangeLog:

        * ada-lang.c (ada_is_ignored_field): Rewrite wrong comment.
@
text
@d736 40
@


1.342
log
@[Ada] Do not cache lookup result if not full_search

The ada_lookup_symbol_list function has recently been changed to accept
a "full_search" parameter. When null, this parameter instructs the
function to perform a partial search (global and static symbols are not
searched). When doing a partial search, the result should not be saved
into the lookup cache, as the result might be incomplete.

This manifested itself when trying to perform a function call on AVR
after having inserted a breakpoint inside that function:

    (gdb) b same
    Breakpoint 2 at 0x78: file r.adb, line 5.
    (gdb) call same(42)

    Breakpoint 2, r.same (i=42) at r.adb:5
    5             return I;
    The program being debugged stopped while in a function called from GDB.
    Evaluation of the expression containing the function
    (at 0x0x800068) will be abandoned.
    ^^^^^^^^^^^^^^^
    When the function is done executing, GDB will silently stop.

The expected output for the underlined portion is "(r.same)".

What happens is that the breakpoint command triggers 3 lookups of the
name "same":
  1. full search in LABEL_DOMAIN -> no match, cached;
  2. full search in VAR_DOMAIN -> 1 match, cached;
  3. partial search in VAR_DOMAIN -> no match, cached.

The third lookup therefore causes the results of the partial search
to be cached, thus overriding the result of the full search lookup.

During the following command, the reference to "same" triggers a lookup
of that symbol again. And since GDB CAN find the result of that lookup
in the cache, it returns just that, which is: No match. (wrong!)

As a result, we fallback on the symbol table to resolve the lookup.
And instead of pushing an OP_VAR_VALUE subexpression for symbol "same",
the parser ends up pushing an UNOP_MEMVAL subexpression using the value
of the minimal symbol. This is where being on AVR becomes important:
addresses on AVR are modular types, and if GDB thinks an address is
a data address, it converts it.

This is where one notices the fact that the breakpoint was inserted
at 0x78, and yet GDB says that the function we stopped at is at
0x0x800068...

This patch fixes the problem by making sure we only cache the result
of full searches.

gdb/ChangeLog:

        * ada-lang.c (ada_lookup_symbol_list): Only cache the result of
        full searches.
@
text
@d5885 1
a5885 1
   
d5896 7
a5902 2
    /* A field named "_parent" is internally generated by GNAT for
       tagged types, and should not be printed either.  */
@


1.341
log
@[Ada] print packed arrays indexed by enumerated type

Consider the following declarations (a packed array indexed by an
enumerated type):

    type Color is (Black, Red, Green, Blue, White);
    type Full_Table is array (Color) of Boolean;
    pragma Pack (Full_Table);
    Full : Full_Table := (False, True, False, True, False);

GDB is unable to print the index values correctly. It prints the
enumeration's underlying value instead of the enumeration name:

    (gdb) p full
    $1 = (0 => false, true, false, true, false)
    (gdb) p full'first
    $2 = 0

And yet, it is capable of printing the correct type description:

    (gdb) ptype full
    type = array (black .. white) of boolean <packed: 1-bit elements>

To get to the real index type, one has to follow the parallel XA type.
We already do this for normal arrays. We can do it for this packed
array as well.

gdb/ChangeLog:

        * ada-lang.c (constrained_packed_array_type): If there is a
        parallel XA type, use it to determine the array index type.

gdb/testsuite/ChangeLog:

        * gdb.ada/arrayidx.exp: Adjust expected output for p_one_two_three.
        * gdb.ada/enum_idx_packed: New testcase.
@
text
@d5072 1
a5072 1
  if (ndefns == 0)
d5075 1
a5075 1
  if (ndefns == 1 && cacheIfUnique)
@


1.340
log
@Ada: ada_to_fixed_value should also unwrap_value

We should always unwrap a value before trying to "fix" it. It is
therefore logical that ada_to_fixed_value would call unwrap_value
before creating the fixed value.

This simplifies the code in ada-lang.c a bit.

gdb/ChangeLog:

        * ada-lang.c (ada_to_fixed_value): Call unwrap_value before
        creating fixed value.
        (ada_value_ind, ada_coerce_ref, assign_component)
        (ada_evaluate_subexp): Remove call to unwrap_value before
        call to ada_to_fixed_value.
@
text
@d2009 2
d2017 7
d2028 1
a2028 1
  create_array_type (new_type, new_elt_type, TYPE_INDEX_TYPE (type));
d2032 1
a2032 2
  if (get_discrete_bounds (TYPE_INDEX_TYPE (type),
                           &low_bound, &high_bound) < 0)
@


1.339
log
@[Ada] whatis not printing array type name for value from history

Consider the following declaration:

   type Full_Table is array (Color) of Integer;
   Full : Full_Table := (144, 233, 377, 610, 987);

The debugger correctly prints the type name of variable "full":

        (gdb) whatis full
        type = pck.full_table

But is unable to do so when using the value history:

        (gdb) print full
        $1 = (144, 233, 377, 610, 987)
        (gdb) whatis $
 !!! -> type = array (black .. white) of integer

This is because the evaluation creates a "fixed" version of
the array type, and that "fixed" version is missing a type name.
As a result, whatis falls back to describing the type (a la ptype)
instead of printing the type name.

gdb/ChangeLog:

        * ada-lang.c (to_fixed_array_type): Set result's type name.

gdb/testsuite/ChangeLog:

        * gdb.ada/whatis_array_val: New testcase.
@
text
@d6905 1
a6905 1
  struct value *val = unwrap_value (value_ind (val0));
a6920 1
      val = unwrap_value (val);
d8140 5
a8144 3
  return ada_to_fixed_value_create (value_type (val),
                                    value_address (val),
                                    val);
d8706 1
a8706 1
      elt = ada_to_fixed_value (unwrap_value (elt));
a9542 1
          arg1 = unwrap_value (arg1);
@


1.338
log
@Add support for condition in Ada exception catchpoint commands

Previously, conditions could be associated to Ada exception catchpoints,
but not while creating the exception catchpoint:

    (gdb) catch exception first_exception if except_counter = 5
    Junk at end of expression

This patch improves the parsing of the command arguments to allow
an "if CONDITION" at the end.  All Ada exception catchpoint commands
have been enhanced to support this.

gdb/ChangeLog:

        * ada-lang.c (catch_ada_exception_command_split): Add new
        argument cond_string.  Add support for condition at end of
        "catch exception" commands.
        (ada_decode_exception_location): Add new argument cond_string.
        Update call to catch_ada_exception_command_split.
        (create_ada_exception_catchpoint): Add new argument cond_string.
        Set the breakpoint condition if needed.
        (catch_ada_exception_command): Update call to
        ada_decode_exception_location.
        (ada_decode_assert_location): Add function documentation.
        Add support for condition at end of "catch assert" command.
        (catch_assert_command): Update calls to ada_decode_assert_location
        and create_ada_exception_catchpoint.
@
text
@d7829 5
@


1.337
log
@Rename la_get_symbol_name_match_p into la_get_symbol_name_cmp

The la_get_symbol_name_match_p language hook was poorly named, as
it suggested that the function should return nonzero if the names
match, whereas it is the exact opposite.  This patch therefore
renames the hook and associated typedef, as well some of the code
that uses that hook.

gdb/ChangeLog:

        * language.h (symbol_name_cmp_ftype): Renames
        symbol_name_match_p_ftype.
        (struct language_defn)[la_get_symbol_name_cmp]: Renames
        la_get_symbol_name_match_p.
        * ada-lang.c (ada_get_symbol_name_cmp): Renames
        ada_get_symbol_name_match_p.  Update comment.
        (ada_language_defn)[la_get_symbol_name_cmp]: Update value.
        * linespec.c (struct symbol_matcher_data)[symbol_name_cmp]:
        Renames symbol_name_match_p.  Update field type.
        (iterate_name_matcher, iterate_over_all_matching_symtabs): Adjust.
        * c-lang.c, d-lang.c, f-lang.c, jv-lang.c, m2-lang.c, objc-lang.c,
        opencl-lang.c, p-lang.c: Replace "la_get_symbol_name_match_p" by
        "la_get_symbol_name_cmp" in comments.
        * language.c: Likewise.
@
text
@d11567 4
a11570 1
   specified by the user.  */
d11575 2
a11576 1
                                   char **excep_string)
d11580 1
d11583 9
d11594 17
a11613 2
  args = skip_spaces (args);

d11637 1
d11781 4
d11791 1
d11796 1
a11796 1
  catch_ada_exception_command_split (args, &ex, excep_string);
d11807 1
d11819 2
d11835 1
d11842 2
a11843 1
  sal = ada_decode_exception_location (arg, &addr_string, &excep_string, &ops);
d11845 2
a11846 1
				   excep_string, ops, tempflag, from_tty);
d11849 11
d11862 1
d11865 1
a11865 1
  /* Check that no argument where provided at the end of the command.  */
d11867 3
a11869 1
  if (args != NULL)
d11871 1
d11873 3
a11875 2
      if (*args != '\0')
        error (_("Junk at end of arguments."));
d11878 5
d11896 1
d11903 1
a11903 1
  sal = ada_decode_assert_location (arg, &addr_string, &ops);
d11905 2
a11906 1
				   NULL, ops, tempflag, from_tty);
@


1.336
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d12325 1
a12325 1
/* Implement the "la_get_symbol_name_match_p" language_defn method
d12328 2
a12329 2
static symbol_name_match_p_ftype
ada_get_symbol_name_match_p (const char *lookup_name)
d12373 1
a12373 1
  ada_get_symbol_name_match_p,	/* la_get_symbol_name_match_p */
@


1.335
log
@2012-02-01  Gary Benson  <gbenson@@redhat.com>

	* symtab.h (symbol_name_match_p_ftype): New typedef.
	(iterate_over_symbols): Use the above.
	* symtab.c (iterate_over_symbols): Likewise.
	* language.h (language_defn->la_iterate_over_symbols): Likewise.
	* ada-lang.c (ada_iterate_over_symbols): Likewise.
	* linespec.c (iterate_over_all_matching_symtabs): Likewise.
	(iterate_name_matcher): Document return values.
	(collect_one_symbol): Likewise.
	(collect_function_symbols): Likewise.
	(collect_symbols): Likewise.
@
text
@d226 1
a226 1
static int find_struct_field (char *, struct type *, int,
d1373 1
a1373 1
     char *name = TYPE_FIELD_NAME (index_desc_type, i);
d1965 2
a1966 2
  char *raw_name;
  char *tail;
d2045 1
a2045 1
  char *raw_name = ada_type_name (ada_check_typedef (type));
d2047 1
a2047 1
  char *tail;
d3410 1
a3410 1
encoded_ordered_before (char *N0, char *N1)
d4251 2
a4252 2
        char *name0 = SYMBOL_LINKAGE_NAME (sym0);
        char *name1 = SYMBOL_LINKAGE_NAME (sym1);
d4383 1
a4383 1
  char *name = ada_type_name (type);
d4414 2
a4415 2
      char *name_1 = TYPE_FIELD_NAME (type1, i);
      char *name_2 = TYPE_FIELD_NAME (type2, i);
d4650 1
a4650 1
old_renaming_is_invisible (const struct symbol *sym, char *function_name)
d4720 1
a4720 1
  char *current_function_name;
d5857 1
a5857 1
  char *name;
d6370 1
a6370 1
find_struct_field (char *name, struct type *type, int offset,
d6392 1
a6392 1
      char *t_field_name = TYPE_FIELD_NAME (type, i);
d6469 1
a6469 1
      char *t_field_name = TYPE_FIELD_NAME (type, i);
d6728 1
a6728 1
      char *t_field_name = TYPE_FIELD_NAME (type, i);
d6767 1
a6767 1
	      char *v_field_name = TYPE_FIELD_NAME (field_type, j);
d7033 1
a7033 1
      char *function_name = SYMBOL_LINKAGE_NAME (function_sym);
d7113 1
a7113 1
char *
d7140 1
a7140 1
      char *result_name = ada_type_name (result);
d7192 2
a7193 1
  char *name, *typename = ada_type_name (type);
d7899 1
a7899 1
            char *name = ada_type_name (fixed_record_type);
d8094 1
a8094 1
      char *name = TYPE_TAG_NAME (type);
d8874 1
a8874 1
	  char *name;
d9883 1
a9883 1
            char *name = ada_type_name (type_arg);
d10415 1
a10415 1
  char *name;
d10538 2
a10539 2
  char *name = ada_type_name (type);
  char *suffix;
d10785 1
a10785 1
  char *func_name;
d10888 1
a10888 1
      char *func_name;
@


1.334
log
@	* ada-lang.c (resolve_subexp): Update.
	(ada_lookup_symbol_list): Add 'full_search' argument.
	(ada_iterate_over_symbols): Pass 0 as full_search argument to
	ada_lookup_symbol_list.
	(ada_lookup_encoded_symbol): Update.
	(get_var_value): Update.
	* ada-exp.y (block_lookup): Update.
	(write_var_or_type): Update.
	(write_name_assoc): Update.
	* ada-lang.h (ada_lookup_symbol_list): Update.
@
text
@d5105 1
a5105 1
			  int (*callback) (struct symbol *, void *),
@


1.333
log
@Remove language param from name_matcher in struct quick_symbol_functions

The quick_symbol_functions struct contains a field which is pointer
a function which takes another function, called name_matcher, as
its parameter.  This name_matcher currently has 3 arguments, one
of them being the language. This parameter is no longer used, and
thus deleted.

gdb/ChangeLog:

        * symfile.h (struct quick_symbol_functions) [expand_symtabs_matching]:
        Remove language parameter from name_matcher.  Adjust the comment.
        * symtab.c (search_symbols_name_matches, expand_partial_symbol_name):
        Remove language parameter.
        * ada-lang.c (ada_expand_partial_symbol_name): Likewise.
        * linespec.c (iterate_name_matcher): Likewise.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust type of
        name_matcher.  Adjust call accordingly.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (maintenance_check_symtabs): Adjust type of parameter "fun".
        * psymtab.h (maintenance_check_symtabs): Likewise.
@
text
@d3060 1
a3060 1
                                    &candidates);
d3152 1
a3152 1
                                      &candidates);
d3204 1
a3204 1
                                    &candidates);
d4982 4
a4985 3
     enclosing blocks is returned).  If there are any matches in or
   surrounding BLOCK0, then these alone are returned.  Otherwise, the
   search extends to global and file-scope (static) symbol tables.
d4991 3
a4993 2
                        domain_enum namespace,
                        struct ada_symbol_info **results)
d5031 1
a5031 1
  if (num_defns_collected (&symbol_list_obstack) > 0)
d5111 1
a5111 1
  ndefs = ada_lookup_symbol_list (name, block, domain, &results);
d5126 2
a5127 1
  n_candidates = ada_lookup_symbol_list (name, block0, namespace, &candidates);
d10365 1
a10365 1
                                  &syms);
@


1.332
log
@Ada: allow unqualified function names in linespecs

This is the meat, where we replace the old la_symbol_name_compare
language method with the new ada_get_symbol_name_match_p.
It fixes the problem when trying to insert a breakpoint on "+".

gdb/ChangeLog:

        * language.h (symbol_name_match_p_ftype): New typedef.
        (struct language_defn): Replace field la_symbol_name_compare
        by la_get_symbol_name_match_p.
        * ada-lang.c (ada_get_symbol_name_match_p): New function.
        (ada_language_defn): Use it.
        * linespec.c (struct symbol_matcher_data): New type.
        (iterate_name_matcher): Rewrite.
        (iterate_over_all_matching_symtabs): Pass a pointer to
        a symbol_matcher_data struct to expand_symtabs_matching
        instead of just the lookup name.
        * c-lang.c, d-lang.c, jv-lang.c, m2-lang.c, objc-lang.c,
        opencl-lang.c, p-lang.c, language.c: Delete field
        la_symbol_name_compare, and replace by NULL for new field
        la_get_symbol_name_match_p.
        * symfile.h (struct quick_symbol_functions): Update comment.
@
text
@d5702 1
a5702 2
ada_expand_partial_symbol_name (const struct language_defn *language,
				const char *name, void *user_data)
@


1.331
log
@	* ada-lang.c: Include gdb_vecs.h.
	* charset.c: Include gdb_vecs.h.
	* tracepoint.h: Include gdb_vecs.h.
	* gdb_vecs.h: New file.
@
text
@d12322 12
d12370 1
a12370 1
  compare_names,
@


1.330
log
@2012-01-06  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* ada-lang.c (ada_exception_name_addr): Add `volatile' keyword
	before `struct gdb_exception'.
	* breakpoint.c (update_global_location_list_nothrow)
	(update_breakpoint_locations, enable_breakpoint_disp): Likewise.
	* cp-abi.c (value_rtti_type): Likewise.
	* cp-support.c (cp_validate_operator): Likewise.
	* infrun.c (insert_exception_resume_breakpoint)
	(check_exception_resume, keep_going): Likewise.
	* mi-interp.c (mi_breakpoint_created)
	(mi_breakpoint_modified): Likewise.
	* rs6000-aix-tdep.c (rs6000_convert_from_func_ptr_addr): Likewise.
	* solib-ia64-hpux.c (ia64_hpux_at_dld_breakpoint_p)
	(ia64_hpux_handle_dld_breakpoint_1): Likewise.
@
text
@d60 1
a5631 2
DEF_VEC_P (char_ptr);

@


1.329
log
@Use skip_spaces and skip_to_space in ada-lang.c

This is just a minor cleanup that reduces a bit the code in ada-lang.c
by using skip_spaces or skip_to_space, instead of doing the skipping
ourselves.

gdb/ChangeLog:

        * ada-lang.c: #include "cli/cli-utils.h".
        (get_selections): Use skip_spaces.
        (ada_get_next_arg): Use skip_spaces and skip_to_space.
        (catch_ada_exception_command_split): Use skip_spaces.
        (ada_decode_assert_location): Likewise.
@
text
@d10946 1
a10946 1
  struct gdb_exception e;
@


1.328
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d66 1
d3615 1
a3615 2
      while (isspace (*args))
        args += 1;
d11541 1
a11541 5
  /* Skip any leading white space.  */

  while (isspace (*args))
    args++;

d11547 1
a11547 3
  end = args;
  while (*end != '\0' && !isspace (*end))
    end++;
d11581 1
a11581 2
  while (isspace (*args))
    args++;
d11814 1
a11814 2
      while (isspace (*args))
        args++;
@


1.327
log
@more copyright notice reformatting.

gdb/ChangeLog:

        * ada-lang.c: Reformat the copyright notice.

gdb/testsuite/ChangeLog:

        * gdb.base/auxv.exp: Reformat the copyright notice.
@
text
@d3 2
a4 2
   Copyright (C) 1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004,
   2005, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.326
log
@New function ada-lang.c:should_use_wild_match...

... to avoid code duplication.

gdb/ChangeLog:

        * ada-lang.c (should_use_wild_match): New function.
        (ada_lookup_simple_minsym): Use should_use_wild_match.
        Minor simplification.  Add comment.
        (ada_lookup_symbol_list): Use should_use_wild_match.
        Minor simplification.
@
text
@d1 1
a1 1
/* Ada language support routines for GDB, the GNU debugger.  Copyright (C)
d3 2
a4 2
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004, 2005, 2007, 2008,
   2009 Free Software Foundation, Inc.
@


1.325
log
@[Ada] Breakpoints on task bodies

Consider the following declaration:

    package Pck is
       task Dummy_Task is
          entry Start;
       end Dummy_Task;
    end Pck;

Inserting a breakpoint on the body of that task does not currently
work:

    (gdb) b pck.dummy_task
    "pck.dummy_task" is not a function
    Make breakpoint pending on future shared library load? (y or [n]) n

What happens here is that the compiler generates two symbols:

  (a) Symbol `pck__dummy_task' which is a *variable* referencing
      the task;

  (b) Symbol `pck__dummy_taskTKB' which is the subprogram implementing
      the body of the task.

The symbol lookup only finds the variable before of the TKB suffix in
the subprogram name. This patch fixes the problem by adjusting the
ada-lang.c:is_name_suffix routine to recognize "TKB" suffixes.  But
that's not enough, because the search in the symtab is performed via
the block dictionary, using a hashing algorithm. So, for the search
to find `pck__dummy_taskTKB', I had to modify the hashing function
to ignore TKB suffixes as well.

gdb/ChangeLog:

        * ada-lang.c (is_name_suffix): Add handling of "TKB" suffixes.
        Update function documentation.
        * dictionary.c (dict_hash): Ignore "TKB" suffixes in hash
        computation.

gdb/testsuite/ChangeLog:

        * gdb.ada/task_bp: New testcase.
@
text
@d4164 12
d4341 1
a4341 1
  int wild_match;
d4343 7
d4351 1
a4351 6
    {
      name += sizeof ("standard__") - 1;
      wild_match = 0;
    }
  else
    wild_match = (strstr (name, "__") == NULL);
d4995 1
a4995 1
  int wild_match;
a5005 1
  wild_match = (strstr (name0, "__") == NULL);
a5019 1
      wild_match = 0;
@


1.324
log
@fix uninitialized field in ada-lang.c (struct match_data)

Field found_sym in add_nonlocal_symbols's struct match_data is
used uninitialized.  Rather than adding the initialization of
this field (to zero), we set the entire structure to zero first,
and then set the fields that need to be initialized to non-zero
next.

gdb/ChangeLog:

        * ada-lang.c (add_nonlocal_symbols): Initialize data to
        all zeros.  Remove setting of data.arg_sym to NULL.
@
text
@d5157 1
d5203 5
@


1.323
log
@[Ada] improve message when cannot insert Ada exception catchpoint.

gdb/ChangeLog:

        * ada-lang.c (ada_exception_support_info_sniffer): Improve
        error message.
@
text
@d4925 1
a4926 1
  data.arg_sym = NULL;
@


1.323.2.1
log
@more copyright notice reformatting.

gdb/ChangeLog:

        * ada-lang.c: Reformat the copyright notice.

gdb/testsuite/ChangeLog:

        * gdb.base/auxv.exp: Reformat the copyright notice.
@
text
@d1 1
a1 1
/* Ada language support routines for GDB, the GNU debugger.
d3 2
a4 2
   Copyright (C) 1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004,
   2005, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.323.2.2
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 2
   Copyright (C) 1992-1994, 1997-2000, 2003-2005, 2007-2012 Free
   Software Foundation, Inc.
@


1.322
log
@[Ada] Make the exception_support_info data per inferior.

The ada-lang module was using a static global called "exception_info"
for all inferiors.  But each inferior might be different, and thus
this patch makes this data per-inferior.

gdb/ChangeLog:

        * ada-lang.c (struct ada_inferior_data) [exception_info]:
        New field.
        (exception_info): Delete.
        (ada_exception_support_info_sniffer): Get exception_support_info
        data from our per-inferior data.  Adjust code accordingly.
        (ada_unhandled_exception_name_addr_from_raise): Likewise.
        (ada_exception_name_addr_1, ada_exception_sym_name): Ditto.
        (ada_executable_changed_observer): Delete.
        (_initialize_ada_language): Remove call to
        observer_attach_executable_changed.
@
text
@d10753 1
a10753 1
  error (_("Cannot insert catchpoints in this configuration."));
@


1.321
log
@Warn if missing debug info for Ada exception catchpoints

This patch should help the user understand why the debugger is not
able to insert Ada exception catchpoints when the Ada runtime was
stripped of debugging info, as is often the case on many GNU/Linux
distros:

    (gdb) catch exception
    Your Ada runtime appears to be missing some debugging information.
    Cannot insert Ada exception catchpoint in this configuration.

gdb/ChangeLog:

        * ada-lang.c (ada_has_this_exception_support): Raise an error
        if we could find the Ada exception hook in the Ada runtime,
        but no debugging info for that hook.

gdb/testsuite/ChangeLog:

        * gdb.ada/catch_ex.exp, gdb.ada/mi_catch_ex.exp: Adjust
        expected output for unsupported case.
@
text
@d320 5
a10698 5
/* For each executable, we sniff which exception info structure to use
   and cache it in the following global variable.  */

static const struct exception_support_info *exception_info = NULL;

d10702 2
a10703 1
   This function will always set exception_info, or raise an error.  */
d10708 1
d10712 1
a10712 1
  if (exception_info != NULL)
d10718 1
a10718 1
      exception_info = &default_exception_support_info;
d10725 1
a10725 1
      exception_info = &exception_support_info_fallback;
a10755 13
/* An observer of "executable_changed" events.
   Its role is to clear certain cached values that need to be recomputed
   each time a new executable is loaded by GDB.  */

static void
ada_executable_changed_observer (void)
{
  /* If the executable changed, then it is possible that the Ada runtime
     is different.  So we need to invalidate the exception support info
     cache.  */
  exception_info = NULL;
}

d10855 1
d10873 1
a10873 1
          && strcmp (func_name, exception_info->catch_exception_sym) == 0)
d10895 2
d10904 1
a10904 1
        return exception_info->unhandled_exception_name_addr ();
d11603 3
a11605 1
  gdb_assert (exception_info != NULL);
d11610 1
a11610 1
        return (exception_info->catch_exception_sym);
d11613 1
a11613 1
        return (exception_info->catch_exception_unhandled_sym);
d11616 1
a11616 1
        return (exception_info->catch_assert_sym);
a12471 2
  observer_attach_executable_changed (ada_executable_changed_observer);

@


1.320
log
@Ada exception catchpoint support cleanup.

This patch cleans up a bit the way we detect which type of runtime
the program uses with respect to Ada exceptions. It also removes
an unnecessary check in ada_exception_sal which is already performed
by ada_exception_support_info_sniffer.

Some of the changes are preparation work for detecting the situation
where the Ada runtime is found, but lacking debugging info.

gdb/ChangeLog:

        * ada-lang.c (ada_has_this_exception_support): New function,
        extracted out of ada_exception_sal and ada_exception_sal.
        (ada_exception_support_info_sniffer): Simplify by using
        ada_has_this_exception_support.
        (ada_exception_sal): Replace unnecessary checks by assertions.
        Minor simplifications.
@
text
@d10662 22
a10683 1
    return 0;
@


1.319
log
@* ada-lang.c (remove_extra_symbols): Rename `remove' to
`remove_p'(-Wshadow).
@
text
@d10644 29
d10693 1
a10693 3
  sym = standard_lookup (default_exception_support_info.catch_exception_sym,
                         NULL, VAR_DOMAIN);
  if (sym != NULL)
d10700 1
a10700 3
  sym = standard_lookup (exception_support_info_fallback.catch_exception_sym,
                         NULL, VAR_DOMAIN);
  if (sym != NULL)
a11690 1
  struct symtab_and_line sal;
a11696 1

d11700 8
a11707 26
  /* The symbol we're looking up is provided by a unit in the GNAT runtime
     that should be compiled with debugging information.  As a result, we
     expect to find that symbol in the symtabs.  If we don't find it, then
     the target most likely does not support Ada exceptions, or we cannot
     insert exception breakpoints yet, because the GNAT runtime hasn't been
     loaded yet.  */

  /* brobecker/2006-12-26: It is conceivable that the runtime was compiled
     in such a way that no debugging information is produced for the symbol
     we are looking for.  In this case, we could search the minimal symbols
     as a fall-back mechanism.  This would still be operating in degraded
     mode, however, as we would still be missing the debugging information
     that is needed in order to extract the name of the exception being
     raised (this name is printed in the catchpoint message, and is also
     used when trying to catch a specific exception).  We do not handle
     this case for now.  */

  if (sym == NULL)
    error (_("Unable to break on '%s' in this configuration."), sym_name);

  /* Make sure that the symbol we found corresponds to a function.  */
  if (SYMBOL_CLASS (sym) != LOC_BLOCK)
    error (_("Symbol \"%s\" is not a function (class = %d)"),
           sym_name, SYMBOL_CLASS (sym));

  sal = find_function_start_sal (sym, 1);
a11709 1

d11715 1
a11715 1
  return sal;
@


1.318
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d4491 1
a4491 1
      int remove = 0;
d4506 1
a4506 1
                remove = 1;
d4526 1
a4526 1
                remove = 1;
d4530 1
a4530 1
      if (remove)
@


1.317
log
@wrong value returned by ada-lang.c:compare_names

The ada-lang.c:compare_names function returns the wrong value
when the first string starts with the same contents as the second
string, followed by '_' and then some characters that do not make
a symbol name suffix.  For instance:

    string1 = "generics__test_generics__instance__print"
    string2 = "generics__test_generics"

In that case, compare_names (string1, string2) return -1, when
clearly, string1 is greater than string2.

A consequence of this problem is that GDB may fail to lookup
"generics.test_generics" from our partial symtabs, because
partial symbols are ordered by strcmp_iw_ordered:

    (gdb) b generics.test_generics
    Function "generics.test_generics" not defined.
    Make breakpoint pending on future shared library load? (y or [n])

gdb/ChangeLog:

        * ada-lang.c (compare_names): Fix wrong return value in case
        string1 starts with the same contents as string2, followed
        by an underscore that do not start a symbol name suffix.

gdb/testsuite/ChangeLog:

        * gdb.ada/fullname_bp: New testcase.
@
text
@d5055 44
d5680 2
a5681 1
ada_expand_partial_symbol_name (const char *name, void *user_data)
d12330 2
@


1.316
log
@Minor reformatting in ada-lang.c:assign_aggregate

No code change.

gdb/ChangeLog:

        From Andrey Smirnov <andrew.smirnov@@gmail.com>:
        * ada-lang.c (assign_aggregate): Minor reformatting.
@
text
@d4897 1
a4897 1
	    return -1;
@


1.315
log
@fix -Wshadow warning inside ada-lang.c:assign_aggregate

gdb/ChangeLog:

        From Andrey Smirnov <andrew.smirnov@@gmail.com>:
        * ada-lang.c (assign_aggregate): Remove declaration of local
        variable `i' which is shadowing another variable with the same
        name declared in the outer scope.
@
text
@d8709 7
a8715 2
	case OP_CHOICES:
	  aggregate_assign_from_choices (container, lhs, exp, pos, indices, 
d8718 9
a8726 14
	  break;
	case OP_POSITIONAL:
	  aggregate_assign_positional (container, lhs, exp, pos, indices,
				       &num_indices, max_indices,
				       low_index, high_index);
	  break;
	case OP_OTHERS:
	  if (i != n-1)
	    error (_("Misplaced 'others' clause"));
	  aggregate_assign_others (container, lhs, exp, pos, indices, 
				   num_indices, low_index, high_index);
	  break;
	default:
	  error (_("Internal error: bad aggregate clause"));
@


1.314
log
@ada-lang.c: Rename function base_type into get_base_type

This avoids shadowing issues with variables named base_type.

gdb/ChangeLog:

        * ada-lang.c (get_base_type): Renames base_type.  Adjust all
        calls throughout this file.
@
text
@a8667 2
      int i;

@


1.313
log
@	* breakpoint.c (install_breakpoint):  Add one more parameter so that
	update_global_location_list is called conditionally.
	(create_fork_vfork_event_catchpoint): Update.
	(create_syscall_event_catchpoint): Update.
	(create_breakpoint_sal): Update.
	(create_breakpoint_sal): Update. Call do_cleanups before
	install_breakpoint.
	* ada-lang.c (create_ada_exception_catchpoint): Update.
	* breakpoint.h (install_breakpoint): Update declaration.
@
text
@d719 1
a719 1
base_type (struct type *type)
d3328 1
a3328 1
    return_type = base_type (TYPE_TARGET_TYPE (func_type));
d3330 1
a3330 1
    return_type = base_type (func_type);
d3334 1
a3334 1
  context_type = base_type (context_type);
d8503 2
a8504 2
  type1 = base_type (ada_check_typedef (value_type (arg1)));
  type2 = base_type (ada_check_typedef (value_type (arg2)));
d10456 1
a10456 1
  struct type *subranged_type = base_type (type);
@


1.312
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@d11708 1
a11708 1
  install_breakpoint (0, &c->base);
@


1.311
log
@	* ada-lang.c (ada_exception_breakpoint_ops): Make return type
	const.
	(ada_exception_sal): Make 'ops' const.
	(ada_decode_exception_location): Likewise.
	(ada_decode_assert_location): Likewise.
	(catch_assert_command): Update.
	(catch_ada_exception_command): Update.
	(create_ada_exception_catchpoint): Make 'ops' const.
	* breakpoint.c (set_raw_breakpoint_without_location)
	(set_raw_breakpoint, momentary_breakpoint_from_master): Make 'ops'
	const.
	(create_internal_breakpoint): Update.
	(init_raw_breakpoint_without_location): Make 'ops' const.
	(init_raw_breakpoint, init_catchpoint)
	(create_fork_vfork_event_catchpoint)
	(create_syscall_event_catchpoint, init_breakpoint_sal)
	(create_breakpoint_sal, create_breakpoints_sal)
	(create_breakpoint, init_ada_exception_breakpoint): Likewise.
	* breakpoint.h (struct breakpoint) <ops>: Now const.
	(init_ada_exception_breakpoint, create_breakpoint): Make 'ops'
	const.
@
text
@d11081 1
d11154 1
d11204 1
@


1.310
log
@2011-07-25  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.h (print_recreate_thread): Declare.
	(struct breakpoint): Move step_count, pass_count,
	number_on_target, static_trace_marker_id,
	static_trace_marker_id_idx ...
	(struct tracepoint): ... to this new struct.
	(get_tracepoint, get_tracepoint_by_number_on_target)
	(get_tracepoint_by_number): Change return type to struct
	tracepoint pointer.
	* breakpoint.c (is_tracepoint_type): New, factored out from
	is_tracepoint.
	(is_tracepoint): Adjust.
	(print_one_breakpoint_location): Cast to struct tracepoint as
	necessary, and adjust.
	(print_recreate_catch_fork, print_recreate_catch_vfork)
	(print_recreate_catch_syscall, print_recreate_catch_exec): Call
	print_recreate_thread.
	(init_breakpoint_sal): New, factored out from
	create_breakpoint_sal.
	(create_breakpoint_sal): Reimplement.
	(create_breakpoint): Allocate a struct tracecepoint if the caller
	wanted a tracepoint.  Use init_breakpoint_sal and
	install_breakpoint.
	(print_recreate_ranged_breakpoint, print_recreate_watchpoint)
	(print_recreate_masked_watchpoint)
	(print_recreate_exception_catchpoint): Call print_recreate_thread.
	(tracepoint_print_one_detail): Adjust.
	(tracepoint_print_recreate): Adjust.  Call print_recreate_thread.
	Dump the pass count here.
	(update_static_tracepoint): Adjust.
	(addr_string_to_sals): Adjust.
	(create_tracepoint_from_upload): Adjust.  Change return type to
	struct tracepoint pointer.
	(trace_pass_set_count): Change parameter type to struct tracepoint
	pointer, and adjust.
	(trace_pass_command): Adjust.
	(get_tracepoint, get_tracepoint_by_number_on_target)
	(get_tracepoint_by_number): Change return type to struct
	tracepoint pointer, and adjust.
	(print_recreate_thread): New, factored out from save_breakpoints.
	(save_breakpoints): Don't print thread and task and passcount
	recreation here.
	* remote.c (remote_download_tracepoint): Adjust.
	* tracepoint.c (trace_actions_command, validate_actionline)
	(start_tracing, tfind_1, trace_find_tracepoint_command)
	(trace_dump_command): Adjust.
	(find_matching_tracepoint): Change return type to struct
	tracepoint pointer, and adjust.
	(merge_uploaded_tracepoints, tfile_get_traceframe_address)
	(tfile_trace_find, tfile_fetch_registers): Adjust.
	* tracepoint.h (create_tracepoint_from_upload): Change return type
	to struct tracepoint pointer.
	* ada-lang.c (print_recreate_exception): Call
	print_recreate_thread.
	* mi/mi-cmd-break.c (mi_cmd_break_passcount): Adjust.
@
text
@d10866 1
a10866 1
						 struct breakpoint_ops **);
d11541 1
a11541 1
static struct breakpoint_ops *
d11616 1
a11616 1
		   char **addr_string, struct breakpoint_ops **ops)
d11679 1
a11679 1
                               struct breakpoint_ops **ops)
d11694 1
a11694 1
				 struct breakpoint_ops *ops,
d11719 1
a11719 1
  struct breakpoint_ops *ops = NULL;
d11732 1
a11732 1
                            struct breakpoint_ops **ops)
d11757 1
a11757 1
  struct breakpoint_ops *ops = NULL;
@


1.309
log
@2011-07-25  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* breakpoint.h (struct breakpoint): Move ops as first field.  Move
	exp_string, exp_string_reparse, exp, exp_valid_block, cond_exp,
	cond_exp_valid_block, val, val_valid, watchpoint_frame,
	watchpoint_thread, watchpoint_triggered ...
	(struct watchpoint): ... to this new struct.
	(is_watchpoint): Declare.
	(install_breakpoint): Add new `internal' parameter.
	* breakpoint.c (is_watchpoint): Delete declaration.
	(set_breakpoint_condition): Handle watchpoints.
	(is_watchpoint): Make public.
	(watchpoint_in_thread_scope): Change parameter type to struct
	watchpoint.
	(watchpoint_del_at_next_stop): Change parameter type to struct
	watchpoint.  Remove assertion.  Adjust.
	(update_watchpoint): Ditto.
	(insert_breakpoints, breakpoint_init_inferior)
	(watchpoints_triggered, watchpoint_check)
	(bpstat_check_watchpoint, bpstat_check_breakpoint_conditions)
	(bpstat_stop_status, print_one_breakpoint_location)
	(print_one_breakpoint_location, watchpoint_locations_match): Cast
	to struct watchpoint as necessary, and adjust.
	(install_breakpoint): Add `internal' argument.  If true, don't
	mention the new breakpoint.  Use set_breakpoint_number.
	(create_fork_vfork_event_catchpoint)
	(create_syscall_event_catchpoint): Adjust.
	(dtor_watchpoint): New.
	(re_set_watchpoint, insert_watchpoint, remove_watchpoint)
	(breakpoint_hit_watchpoint, resources_needed_watchpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_recreate_watchpoint, insert_masked_watchpoint)
	(remove_masked_watchpoint, resources_needed_masked_watchpoint)
	(print_one_detail_masked_watchpoint)
	(print_mention_masked_watchpoint)
	(print_recreate_masked_watchpoint): Cast to struct watchpoint as
	necessary, and adjust.
	(watch_command_1): Allocate and initialize a struct watchpoint
	instead of a struct breakpoint.  Use install_breakpoint.
	(catch_exec_command_1): Adjust.
	(base_breakpoint_dtor): Delete accesses to watchpoint specific
	fields.
	(delete_breakpoint, enable_breakpoint_disp)
	(invalidate_bp_value_on_memory_change): Cast to struct watchpoint
	as necessary, and adjust.
	(initialize_breakpoint_ops): Install dtor_watchpoint as
	watchpoints' dtor method.
	* ada-lang.c (create_ada_exception_catchpoint): Adjust.
	* python/py-breakpoint.c (bppy_get_expression): Use is_watchpoint.
	to struct watchpoint as necessary, and adjust.
@
text
@d11265 1
@


1.308
log
@2011-07-25  Pedro Alves  <pedro@@codesourcery.com>

	* ada-lang.c (dtor_exception, re_set_exception): Indirect through
	the the base class ops table.
	(catch_exception_breakpoint_ops)
	(catch_exception_unhandled_breakpoint_ops)
	(catch_assert_breakpoint_ops): Don't statically initialize.
	(initialize_ada_catchpoint_ops): New.
	(_initialize_ada_language): Call it.
	* breakpoint.c (base_breakpoint_ops, bkpt_base_breakpoint_ops)
	(bkpt_breakpoint_ops): Forward declare.
	(catch_fork_breakpoint_ops, catch_vfork_breakpoint_ops)
	(catch_syscall_breakpoint_ops, catch_exec_breakpoint_ops)
	(ranged_breakpoint_ops, watchpoint_breakpoint_ops)
	(masked_watchpoint_breakpoint_ops)
	(gnu_v3_exception_catchpoint_ops): Don't statically initialize.
	(dtor_catch_syscall, dtor_catch_exec): Indirect through the the
	base class ops table.
	(null_re_set, null_check_status, null_works_in_software_mode)
	(null_resources_needed, null_print_one_detail): Delete.
	(bkpt_dtor): Rename to ...
	(base_breakpoint_dtor): ... this.  Make static.
	(bkpt_allocate_location): Rename to ...
	(base_breakpoint_allocate_location): ... this.  Make static.
	(base_breakpoint_re_set): New.
	(internal_error_pure_virtual_called): New.
	(base_breakpoint_insert_location, base_breakpoint_remove_location)
	(base_breakpoint_breakpoint_hit, base_breakpoint_check_status)
	(base_breakpoint_works_in_software_mode)
	(base_breakpoint_resources_needed, base_breakpoint_print_it)
	(base_breakpoint_print_one_detail, base_breakpoint_print_mention)
	(base_breakpoint_print_recreate): New functions.
	(base_breakpoint_ops): New global.
	(bkpt_re_set, bkpt_insert_location, bkpt_remove_location)
	(bkpt_breakpoint_hit): Make static.
	(bkpt_check_status): Delete.
	(bkpt_resources_needed): Make static.
	(bkpt_works_in_software_mode): Delete.
	(bkpt_print_it, bkpt_print_mention, bkpt_print_recreate): Make
	static.
	(bkpt_breakpoint_ops, internal_breakpoint_ops)
	(momentary_breakpoint_ops): Don't statically initialize.
	(internal_bkpt_print_recreate, momentary_bkpt_print_recreate):
	Delete.
	(tracepoint_insert_location, tracepoint_remove_location)
	(tracepoint_check_status, tracepoint_works_in_software_mode)
	(tracepoint_print_it): Delete.
	(tracepoint_breakpoint_ops): Don't statically initialize.
	(initialize_breakpoint_ops): New.
	(_initialize_breakpoint): Call it.
	* breakpoint.h (null_re_set, null_works_in_software_mode)
	(null_resources_needed, null_check_status, null_print_one_detail):
	(bkpt_dtor, bkpt_allocate_location, bkpt_re_set)
	(bkpt_insert_location, bkpt_remove_location, bkpt_breakpoint_hit)
	(bkpt_check_status, bkpt_resources_needed)
	(bkpt_works_in_software_mode, bkpt_print_it)
	(null_print_one_detail, bkpt_print_mention, bkpt_print_recreate):
	Delete declarations.
	(initialize_breakpoint_ops): Declare.
@
text
@d11704 1
a11704 1
  install_breakpoint (&c->base);
@


1.307
log
@2011-07-25  Pedro Alves  <pedro@@codesourcery.com>

	Implement most breakpoint_ops methods for all breakpoint types,
	and move the default handlings to the proper callbacks.

	gdb/
	* breakpoint.c (update_watchpoint): Always call the breakpoint's
	works_in_software_mode method.
	(insert_bp_location): Go through breakpoint_ops->insert_location
	for software and hardware watchpoints.
	(create_internal_breakpoint): Pass bkpt_breakpoint_ops as
	breakpoint_ops.
	(remove_breakpoint_1): Go through breakpoint_ops->remove_location
	for software and hardware watchpoints.
	(print_it_typical): Delete.
	(print_bp_stop_message): Always call the breakpoint_ops->print_it
	method.
	(watchpoint_check): Adjust comment.
	(bpstat_check_location): Simply always call the breakpoint's
	breakpoint_hit method.
	(bpstat_stop_status): Always call the breakpoint's check_status
	method.  Remove special cases for watchpoints and internal event
	breakpoints from here (moved to the check_status implementations).
	(print_one_breakpoint_location): Assume b->ops is never NULL.
	Remove static tracepoint marker id printing from here (moved to
	the print_one_detail callback implementation of tracepoints).
	(init_bp_location): Assert OPS is never NULL.
	(allocate_bp_location): Always call the breakpoint's
	allocate_location method, and remove the default code from here.
	(free_bp_location): Always call the location's dtor method, and
	remove the default code from here.
	(init_raw_breakpoint_without_location): Assert OPS is never NULL.
	(set_raw_breakpoint_without_location): Add new breakpoint_ops
	parameter.  Pass it down.
	(set_raw_breakpoint): Ditto.
	(print_it_catch_fork): Adjust to take a bpstat as argument.
	(catch_fork_breakpoint_ops): Install methods.
	(print_it_catch_vfork): Adjust to take a bpstat as argument.
	(catch_vfork_breakpoint_ops): Install methods.
	(dtor_catch_syscall): Call the base dtor.
	(print_it_catch_syscall): Adjust to take a bpstat as argument.
	(catch_syscall_breakpoint_ops): Install methods.
	(dtor_catch_exec): Call the base dtor.
	(print_it_catch_exec): Adjust to take a bpstat as argument.
	(catch_exec_breakpoint_ops): Install methods.
	(hw_breakpoint_used_count, hw_watchpoint_used_count): Always call
	the breakpoint's resources_needed method, and remove the default
	code from here.
	(set_momentary_breakpoint): Pass bkpt_breakpoint_ops as
	breakpoint_ops.
	(clone_momentary_breakpoint): Clone the original's ops.
	(mention): Always call the breakpoint's print_mention method, and
	remove the default code from here.
	(create_breakpoint_sal): Adjust to pass the ops to
	set_raw_breakpoint rather than setting it manually.
	(create_breakpoint): Assert ops is never NULL.  Adjust to pass the
	ops to set_raw_breakpoint_without_location rather than setting it
	manually.
	(break_command_1): Pass bkpt_breakpoint_ops as breakpoint_ops.
	(print_it_ranged_breakpoint): Adjust to take a bpstat as argument.
	(ranged_breakpoint_ops): Install methods.
	(break_range_command): Adjust to pass the ops to
	set_raw_breakpoint rather than setting it manually.
	(re_set_watchpoint, breakpoint_hit_watchpoint)
	(check_status_watchpoint, resources_needed_watchpoint)
	(works_in_software_mode_watchpoint, print_it_watchpoint)
	(print_mention_watchpoint, print_recreate_watchpoint): New
	functions.
	(watchpoint_breakpoint_ops): Install new methods.
	(print_it_masked_watchpoint): New function.
	(masked_watchpoint_breakpoint_ops): Install new methods.
	(watch_command_1): Adjust to pass the right breakpoint_ops to
	set_raw_breakpoint_without_location rather than setting it
	manually later.  Record the current pspace.
	(print_it_exception_catchpoint): Adjust to take a bpstat as
	argument.
	(gnu_v3_exception_catchpoint_ops): Install new methods.
	(say_where): New function.
	(null_re_set, null_check_status, null_works_in_software_mode)
	(null_resources_needed, null_print_one_detail, bp_location_dtor):
	New functions.
	(bp_location_ops): New global.
	(bkpt_dtor, bkpt_allocate_location, bkpt_re_set)
	(bkpt_insert_location, bkpt_remove_location, bkpt_breakpoint_hit)
	(bkpt_check_status, bkpt_resources_needed)
	(bkpt_works_in_software_mode, bkpt_print_it, bkpt_print_mention)
	(bkpt_print_recreate): New functions.
	(bkpt_breakpoint_ops): New global.
	(tracepoint_re_set, tracepoint_insert_location)
	(tracepoint_remove_location, tracepoint_breakpoint_hit)
	(tracepoint_check_status, tracepoint_works_in_software_mode)
	(tracepoint_print_it, tracepoint_print_one_detail)
	(tracepoint_print_mention, tracepoint_print_recreate): New
	functions.
	(tracepoint_breakpoint_ops): New global.
	(delete_breakpoint): Always call the breakpoint's dtor method, and
	remove the default handling from here.
	(breakpoint_re_set_default): Make static.
	(breakpoint_re_set_one): Always call the breakpoints re_set
	method, and remove the default handling from here.
	(trace_command, ftrace_command, strace_command)
	(create_tracepoint_from_upload): Pass appropriate breakpoints_ops
	to create_breakpoint.
	(save_breakpoints): Always call the breakpoint's print_recreate
	method, and remove the default handling from here.

	* ada-lang.c (dtor_exception): Call the base dtor.
	(re_set_exception): Call the base method.
	(print_it_exception, print_it_catch_exception): Adjust to take a
	bpstat as argument.
	(catch_exception_breakpoint_ops): Install methods.
	(print_it_catch_exception_unhandled): Adjust to take a bpstat as
	argument.
	(catch_exception_unhandled_breakpoint_ops): Install methods.
	(print_it_catch_assert): Adjust to take a bpstat as argument.
	(catch_assert_breakpoint_ops): Install methods.

	* breakpoint.h (struct breakpoint_ops): Adjust the print_it method
	to take a bpstat as argument.
	(enum print_stop_action): Add describing comments to each enum
	value.
	(breakpoint_re_set_default): Delete declaration.
	(null_re_set, null_works_in_software_mode, null_resources_needed)
	(null_check_status, null_print_one_detail): Declare.
	(bkpt_breakpoint_ops): Declare.
	(bkpt_dtor, bkpt_allocate_location, bkpt_re_set)
	(bkpt_insert_location, bkpt_remove_location, bkpt_breakpoint_hit)
	(bkpt_check_status, bkpt_resources_needed)
	(bkpt_works_in_software_mode, bkpt_print_it)
	(null_print_one_detail, bkpt_print_mention, bkpt_print_recreate):
	Declare.

	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust to pass
	bkpt_breakpoint_ops.
	* python/py-breakpoint.c (bppy_init): Ditto.
@
text
@d10992 1
a10992 1
  bkpt_dtor (b);
d11020 1
a11020 1
  bkpt_re_set (b);
d11317 1
a11317 17
static struct breakpoint_ops catch_exception_breakpoint_ops =
{
  dtor_catch_exception,
  allocate_location_catch_exception,
  re_set_catch_exception,
  bkpt_insert_location,
  bkpt_remove_location,
  bkpt_breakpoint_hit,
  check_status_catch_exception,
  bkpt_resources_needed,
  null_works_in_software_mode,
  print_it_catch_exception,
  print_one_catch_exception,
  null_print_one_detail,
  print_mention_catch_exception,
  print_recreate_catch_exception
};
d11371 1
a11371 16
static struct breakpoint_ops catch_exception_unhandled_breakpoint_ops = {
  dtor_catch_exception_unhandled,
  allocate_location_catch_exception_unhandled,
  re_set_catch_exception_unhandled,
  bkpt_insert_location,
  bkpt_remove_location,
  bkpt_breakpoint_hit,
  check_status_catch_exception_unhandled,
  bkpt_resources_needed,
  null_works_in_software_mode,
  print_it_catch_exception_unhandled,
  print_one_catch_exception_unhandled,
  null_print_one_detail,
  print_mention_catch_exception_unhandled,
  print_recreate_catch_exception_unhandled
};
d11423 1
a11423 16
static struct breakpoint_ops catch_assert_breakpoint_ops = {
  dtor_catch_assert,
  allocate_location_catch_assert,
  re_set_catch_assert,
  bkpt_insert_location,
  bkpt_remove_location,
  bkpt_breakpoint_hit,
  check_status_catch_assert,
  bkpt_resources_needed,
  null_works_in_software_mode,
  print_it_catch_assert,
  print_one_catch_assert,
  null_print_one_detail,
  print_mention_catch_assert,
  print_recreate_catch_assert
};
d12311 41
d12357 2
@


1.306
log
@gdb/
	* ada-lang.c: Fix typos.
	* amd64-tdep.c: Likewise.
	* breakpoint.c: Likewise.
	* cli/cli-decode.c: Likewise.
	* findcmd.c: Likewise.
	* inline-frame.c: Likewise.
	* mi/mi-main.c: Likewise.
	* minsyms.c: Likewise.
	* monitor.c: Likewise.
	* monitor.h: Likewise.
	* prologue-value.c: Likewise.
	* reverse.c: Likewise.
	* s390-tdep.c: Likewise.

gdb/testsuite/
	* gdb.base/call-sc.c: Likewise.
	* gdb.base/ifelse.exp: Likewise.
	* gdb.base/structs.c: Likewise.

gdb/doc/
	* gdb.texinfo: Likewise.
@
text
@d10991 2
d11020 1
a11020 1
  breakpoint_re_set_default (b);
d11079 1
a11079 1
print_it_exception (enum exception_catchpoint_kind ex, struct breakpoint *b)
d11081 2
d11294 1
a11294 1
print_it_catch_exception (struct breakpoint *b)
d11296 1
a11296 1
  return print_it_exception (ex_catch_exception, b);
d11322 3
a11324 3
  NULL, /* insert */
  NULL, /* remove */
  NULL, /* breakpoint_hit */
d11326 2
a11327 2
  NULL, /* resources_needed */
  NULL, /* works_in_software_mode */
d11330 1
a11330 1
  NULL, /* print_one_detail */
d11362 1
a11362 1
print_it_catch_exception_unhandled (struct breakpoint *b)
d11364 1
a11364 1
  return print_it_exception (ex_catch_exception_unhandled, b);
d11391 3
a11393 3
  NULL, /* insert */
  NULL, /* remove */
  NULL, /* breakpoint_hit */
d11395 2
a11396 2
  NULL, /* resources_needed */
  NULL, /* works_in_software_mode */
d11399 1
a11399 1
  NULL, /* print_one_detail */
d11431 1
a11431 1
print_it_catch_assert (struct breakpoint *b)
d11433 1
a11433 1
  return print_it_exception (ex_catch_assert, b);
d11458 3
a11460 3
  NULL, /* insert */
  NULL, /* remove */
  NULL, /* breakpoint_hit */
d11462 2
a11463 2
  NULL, /* resources_needed */
  NULL, /* works_in_software_mode */
d11466 1
a11466 1
  NULL, /* print_one_detail */
@


1.305
log
@bettter display for temporary Ada exception catchpoints

Temporary catchpoints on Ada exceptions are now displayed as "Temporary
catchpoint" as opposed to just "Catchpoint".  This is cosmetic only, but
in line with what's done for other catchpoints as well as breakpoints.

gdb/ChangeLog:

        * ada-lang.c (print_it_exception): Print temporary catchpoints
        as "Temporary catchpoint".
        (print_mention_exception): Likewise.

gdb/testsuite/ChangeLog:

        * gdb.ada/catch_ex.exp: Add temporary catchpoint tests.
@
text
@d8324 1
a8324 1
     all the preceeding characters, the unqualified name starts
@


1.304
log
@treat identical enum types as the same type

This is to avoid an unnecessary multiple-choice menu for an
expression involving an enumeral declared in two types, when
the second type is an identical copy of the first type. This
happens in the following situation:

       type Color is (Black, Red, Green, Blue, White);
       type RGB_Color is new Color range Red .. Blue;

In that case, an implict type is created, and is used as the base
type for type RGB_Color.  This base type is a copy of type Color.
We've added some extensive comments explaining the situation and
our approach further.

gdb/ChangeLog:

        * ada-lang.c (ada_identical_enum_types_p): New function.
        (symbols_are_identical_enums): New function.
        (remove_extra_symbols): Do nothing if NSYMS < 2.
        Use symbols_are_identical_enums.

gdb/testsuite/ChangeLog:

        * gdb.ada/same_enum: New testcase.
@
text
@d11088 3
a11090 1
  ui_out_text (uiout, "\nCatchpoint ");
d11199 5
d11208 7
a11214 2
          printf_filtered (_("Catchpoint %d: `%s' Ada exception"),
                           b->number, c->excep_string);
d11216 1
a11216 2
          printf_filtered (_("Catchpoint %d: all Ada exceptions"), b->number);
        
d11220 1
a11220 2
        printf_filtered (_("Catchpoint %d: unhandled Ada exceptions"),
                         b->number);
d11224 1
a11224 1
        printf_filtered (_("Catchpoint %d: failed Ada assertions"), b->number);
@


1.303
log
@Add missing word in comment (ada-lang.c)

gdb/ChangeLog:

        * ada-lang.c (ada_evaluate_subexp): Add missing word in comment.
@
text
@d4368 102
d4482 6
d4539 16
@


1.302
log
@variables whose type is a typedef to an array pointer

If we declare a type as being an access to array type, and then
declare a variable of that type, for instance:

        type Some_Array is array [...];
        type Array_Access is access all Some_Array;
        Table : Array_Access := [...];

The variable "Table" may be defined in the debugging information
as being a typedef to the array pointer type. In the past, it was
defined directly as the array pointer type, but this has been changed
to make sure that the typedef type gets used.

If the typedef type wasn't used, it would allow the compiler to stop
emitting that typedef type when compiling with
-feliminate-unused-debug-types.  The removal of this typedef would
be a problem, because GDB relies on the typedef to create symbols
for pointer types, and without it, we would no longer be able to
do "ptype array_access".

This patch helps prevent incorrect output or even crashes when that
extra typedef layer is used.

The testing is already mostly covered by arrayptr.exp, but I still
added a 'ptype' test, just for good measure.

gdb/ChangeLog: (Eric Botcazou)

        * ada-lang.c (thin_descriptor_type): Deal with typedefs.
        (decode_constrained_packed_array): Likewise.
        (ada_evaluate_subexp) <TERNOP_SLICE>: Likewise.

gdb/testsuite/ChangeLog (Joel Brobecker):

        * gdb.ada/arrayptr.exp: Add ptype test.
@
text
@d9389 2
a9390 2
         them.  So, if this is an typedef (encoding use for array access
	 types encoded as fat pointers), strip it now.  */
@


1.301
log
@Document ada_remove_trailing_digits more

gdb/ChangeLog:

        * ada-lang.c (ada_remove_trailing_digits): Expand documentation.
@
text
@d1446 1
a1446 1
  struct type *type = value_type (val);
d2096 1
a2096 1
  if (TYPE_CODE (value_type (arr)) == TYPE_CODE_PTR)
d9525 2
a9526 1
        if (TYPE_CODE (value_type (array)) == TYPE_CODE_PTR)
d9528 2
d9531 1
a9531 2
              return empty_array (TYPE_TARGET_TYPE (value_type (array)),
                                  low_bound);
d9535 1
a9535 2
                  to_fixed_array_type (TYPE_TARGET_TYPE (value_type (array)),
                                       NULL, 1);
@


1.300
log
@2011-06-22  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.c (bpstat_stop_status): Call the check_status
	breakpoint_ops method.
	(print_one_breakpoint_location): Also print the condition for Ada
	exception catchpoints.
	(allocate_bp_location): New, factored out from
	allocate_bp_location.
	(allocate_bp_location): Adjust.  Call the owner breakpoint's
	allocate_location method, if there is one.
	(free_bp_location): Call the locations's dtor method, if there is
	one.
	(init_raw_breakpoint_without_location): New breakpoint_ops
	parameter.  Use it.
	(set_raw_breakpoint_without_location): Adjust.
	(init_raw_breakpoint): New breakpoint_ops parameter.  Pass it down.
	(set_raw_breakpoint): Adjust.
	(catch_fork_breakpoint_ops, catch_vfork_breakpoint_ops)
	(catch_syscall_breakpoint_ops): Install NULL allocate_location,
	re_set and check_status methods.
	(init_catchpoint): Don't memset, initialize thread, addr_string
	and enable_state.  Pass the ops down to init_raw_breakpoint.
	(install_catchpoint): Rename to ...
	(install_breakpoint): ... this, and make extern.
	(create_fork_vfork_event_catchpoint): Adjust.
	(catch_exec_breakpoint_ops): Install NULL allocate_location,
	re_set and check_status methods.
	(create_syscall_event_catchpoint): Adjust.
	(ranged_breakpoint_ops, watchpoint_breakpoint_ops)
	(masked_watchpoint_breakpoint_ops): Install NULL
	allocate_location, re_set and check_status methods.
	(catch_exec_command_1): Adjust.
	(gnu_v3_exception_catchpoint_ops): Install NULL allocate_location,
	re_set and check_status methods.
	(create_ada_exception_breakpoint): Rename to ...
	(init_ada_exception_breakpoint): ... this.  Add a struct
	breakpoint parameter, and delete the exp_string, cond_string and
	cond parameters.  Use init_raw_breakpoint, and don't install or
	mention the breakpoint yet.  Don't clear breakpoint fields that
	init_raw_breakpoint already clears.
	(re_set_breakpoint): Delete, split into ...
	(breakpoint_re_set_default, prepare_re_set_context): ... these new
	functions.
	(breakpoint_re_set_one): Call the breakpoint's
	breakpoint_ops->re_set implementation, if there's one.  Adjust.
	* breakpoint.h: Forward declare struct bpstats and struct bp_location.
	(struct bp_location_ops): New type.
	(struct bp_location): New field `ops'.
	(struct breakpoint_ops): New `allocate_location', `re_set' and
	`check_status' fields.  Make `breakpoint_hit''s description match
	reality.
	(init_bp_location): Declare.
	(breakpoint_re_set_default): Declare.
	(create_ada_exception_breakpoint): Rename to ...
	(init_ada_exception_breakpoint): ... this.  Add a struct
	breakpoint parameter, and delete the exp_string, cond_string and
	cond parameters.
	(install_breakpoint): Declare.
	* ada-lang.c: Include exceptions.h.
	<Ada exceptions description>: Update.
	(struct ada_catchpoint_location): New type.
	(ada_catchpoint_location_dtor): New function.
	(ada_catchpoint_location_ops): New global.
	(ada_catchpoint): New type.
	(create_excep_cond_exprs): New function.
	(dtor_exception, allocate_location_exception, re_set_exception)
	(should_stop_exception, check_status_exception): New functions.
	(print_one_exception, print_mention_exception)
	(print_recreate_exception): Adjust.
	(dtor_catch_exception, allocate_location_catch_exception)
	(re_set_catch_exception, check_status_catch_exception): New
	functions.
	(catch_exception_breakpoint_ops): Install them.
	(dtor_catch_exception_unhandled)
	(allocate_location_catch_exception_unhandled)
	(re_set_catch_exception_unhandled)
	(check_status_catch_exception_unhandled): New functions.
	(catch_exception_unhandled_breakpoint_ops): Install them.
	(dtor_catch_assert, allocate_location_catch_assert)
	(re_set_catch_assert, check_status_catch_assert): New functions.
	(catch_assert_breakpoint_ops): Install them.
	(ada_exception_catchpoint_p): Delete.
	(catch_ada_exception_command_split)
	(ada_exception_catchpoint_cond_string): Rename exp_string
	parameter to excep_string.  Adjust.
	(ada_parse_catchpoint_condition): Delete.
	(ada_exception_sal): Rename the exp_string parameter to
	excep_string.  Delete the cond_string and cond parameters.
	Adjust.
	(ada_decode_exception_location): Rename the exp_string parameter
	to excep_string.  Delete the cond_string and cond parameters.
	Adjust.
	(create_ada_exception_catchpoint): New function.
	(catch_ada_exception_command, ada_decode_assert_location)
	(catch_assert_command): Adjust.
	* ada-lang.h (ada_exception_catchpoint_p): Delete declaration.
@
text
@d903 3
a905 1
/* Remove either of these suffixes:
d910 1
@


1.299
log
@2011-06-22  Pedro Alves  <pedro@@codesourcery.com>

	* ada-lang.c: Include arch-utils.h.
	(ada_decode_exception_location): Make static.
	(catch_ada_exception_command): Moved here from breakpoint.c.
	(ada_decode_assert_location): Make static.
	(catch_assert_command): Moved here from breakpoint.c.
	(_initialize_ada_lang): Install the exception and assert
	catchpoint commands here.
	* ada-lang.h (ada_decode_exception_location)
	(ada_decode_assert_location): Delete declarations.
	* breakpoint.c (CATCH_PERMANENT, CATCH_TEMPORARY): Moved to
	breakpoint.h.
	(create_ada_exception_breakpoint): Make extern.
	(catch_ada_exception_command, catch_assert_command): Moved to
	ada-lang.c.
	(add_catch_command): Make extern.
	(_initilize_breakpoint): Don't install the exception and assert
	catchpoint commands here.
	* breakpoint.h (CATCH_PERMANENT, CATCH_TEMPORARY): Moved from
	breakpoint.c
	(add_catch_command, create_ada_exception_breakpoint): Declare.
@
text
@d65 1
d10399 1
a10399 13
   the runtime variant used by the program being debugged.

   At this time, we do not support the use of conditions on Ada exception
   catchpoints.  The COND and COND_STRING fields are therefore set
   to NULL (most of the time, see below).
   
   Conditions where EXP_STRING, COND, and COND_STRING are used:

     When a user specifies the name of a specific exception in the case
     of catchpoints on Ada exceptions, we store the name of that exception
     in the EXP_STRING.  We then translate this request into an actual
     condition stored in COND_STRING, and then parse it into an expression
     stored in COND.  */
d10736 209
d11019 1
d11034 1
a11034 1
        if (b->exp_string != NULL)
d11036 2
a11037 2
            char *msg = xstrprintf (_("`%s' Ada exception"), b->exp_string);
            
d11067 2
d11072 1
a11072 1
        if (b->exp_string != NULL)
d11074 1
a11074 1
                           b->number, b->exp_string);
d11102 2
d11108 2
a11109 2
	if (b->exp_string != NULL)
	  fprintf_filtered (fp, " %s", b->exp_string);
d11127 24
d11177 3
a11179 1
  NULL, /* dtor */
d11183 1
d11195 24
d11246 3
a11248 1
  NULL, /* dtor */
d11252 1
d11264 24
d11313 3
a11315 1
  NULL, /* dtor */
d11319 1
a11328 10
/* Return non-zero if B is an Ada exception catchpoint.  */

int
ada_exception_catchpoint_p (struct breakpoint *b)
{
  return (b->ops == &catch_exception_breakpoint_ops
          || b->ops == &catch_exception_unhandled_breakpoint_ops
          || b->ops == &catch_assert_breakpoint_ops);
}

d11371 1
a11371 1
   Set EXP_STRING to the name of the specific exception if
d11377 1
a11377 1
                                   char **exp_string)
d11400 1
a11400 1
      *exp_string = NULL;
d11406 1
a11406 1
      *exp_string = NULL;
d11412 1
a11412 1
      *exp_string = exception_name;
d11473 1
a11473 1
ada_exception_catchpoint_cond_string (const char *exp_string)
d11479 1
a11479 1
     EXP_STRING is the not-fully-qualified name of a standard
d11498 1
a11498 1
      if (strcmp (standard_exc [i], exp_string) == 0)
d11501 1
a11501 1
                             exp_string);
d11504 1
a11504 10
  return xstrprintf ("long_integer (e) = long_integer (&%s)", exp_string);
}

/* Return the expression corresponding to COND_STRING evaluated at SAL.  */

static struct expression *
ada_parse_catchpoint_condition (char *cond_string,
                                struct symtab_and_line sal)
{
  return (parse_exp_1 (&cond_string, block_for_pc (sal.pc), 0));
d11510 2
a11511 2
   EX_STRING should contain the name of a specific exception
   that the catchpoint should catch, or NULL otherwise.
d11513 3
a11515 9
   The idea behind all the remaining parameters is that their names match
   the name of certain fields in the breakpoint structure that are used to
   handle exception catchpoints.  This function returns the value to which
   these fields should be set, depending on the type of catchpoint we need
   to create.
   
   If COND and COND_STRING are both non-NULL, any value they might
   hold will be free'ed, and then replaced by newly allocated ones.
   These parameters are left untouched otherwise.  */
d11518 2
a11519 3
ada_exception_sal (enum exception_catchpoint_kind ex, char *exp_string,
                   char **addr_string, char **cond_string,
                   struct expression **cond, struct breakpoint_ops **ops)
a11564 21
  /* Set the COND and COND_STRING (if not NULL).  */

  if (cond_string != NULL && cond != NULL)
    {
      if (*cond_string != NULL)
        {
          xfree (*cond_string);
          *cond_string = NULL;
        }
      if (*cond != NULL)
        {
          xfree (*cond);
          *cond = NULL;
        }
      if (exp_string != NULL)
        {
          *cond_string = ada_exception_catchpoint_cond_string (exp_string);
          *cond = ada_parse_catchpoint_condition (*cond_string, sal);
        }
    }

a11572 1
   Set TYPE to the appropriate exception catchpoint type.
d11581 1
a11581 2
                               char **exp_string, char **cond_string,
                               struct expression **cond,
d11586 23
a11608 3
  catch_ada_exception_command_split (args, &ex, exp_string);
  return ada_exception_sal (ex, *exp_string, addr_string, cond_string,
                            cond, ops);
d11621 1
a11621 3
  char *exp_string = NULL;
  char *cond_string = NULL;
  struct expression *cond = NULL;
d11628 3
a11630 5
  sal = ada_decode_exception_location (arg, &addr_string, &exp_string,
                                       &cond_string, &cond, &ops);
  create_ada_exception_breakpoint (gdbarch, sal, addr_string, exp_string,
                                   cond_string, cond, ops, tempflag,
                                   from_tty);
d11647 1
a11647 2
  return ada_exception_sal (ex_catch_assert, NULL, addr_string, NULL, NULL,
                            ops);
d11667 2
a11668 2
  create_ada_exception_breakpoint (gdbarch, sal, addr_string, NULL, NULL, NULL,
				   ops, tempflag, from_tty);
@


1.298
log
@2011-06-22  Pedro Alves  <pedro@@codesourcery.com>

	* breakpoint.h (struct breakpoint_ops): New field `dtor'.
	(struct breakpoint): Delete field `syscalls_to_be_caught'.
	* breakpoint.c (init_raw_breakpoint_without_location): Remove
	reference to syscalls_to_be_caught.
	(catch_fork_breakpoint_ops, catch_vfork_breakpoint_ops): Install a
	NULL `dtor'.
	(struct syscall_catchpoint): New type.
	(dtor_catch_syscall): New function.
	(insert_catch_syscall, remove_catch_syscall)
	(breakpoint_hit_catch_syscall, print_one_catch_syscall)
	(print_recreate_catch_syscall): Adjust.
	(catch_syscall_breakpoint_ops): Install dtor_catch_syscall.
	(catch_exec_breakpoint_ops): Install a NULL `dtor'.
	(create_syscall_event_catchpoint): Adjust to use init_catchpoint.
	(ranged_breakpoint_ops, watchpoint_breakpoint_ops)
	(masked_watchpoint_breakpoint_ops)
	(gnu_v3_exception_catchpoint_ops): Install a NULL `dtor'.
	(delete_breakpoint): Call the `dtor' breakpoint_ops method, if
	there is one.  Remove references to syscalls_to_be_caught.
	(catching_syscall_number): Adjust.
	* ada-lang.c (catch_exception_breakpoint_ops)
	(catch_exception_unhandled_breakpoint_ops)
	(catch_assert_breakpoint_ops): Install a NULL `dtor'.
@
text
@d64 1
d11343 1
a11343 1
struct symtab_and_line
d11356 27
a11382 1
struct symtab_and_line
d11400 20
d11992 15
@


1.297
log
@Remove one use of sprintf in ada-lang.c (print_it_exception)

This is just a minor cleanup of an ARI violation.  As this affects
code that is normally unreachable (you'd need a runtime where
the unit providing the exception hook has been compiled without
debugging information), I tested this manually by commenting out
the code just above, thus forcing this part of the code to be
exercised.

gdb/ChangeLog:

        * ada-lang.c (print_it_exception): Avoid use of sprintf.

Tested on x86_64-linux.
@
text
@d10949 1
d10991 1
d11031 1
@


1.296
log
@2011-05-06  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Implement support for PowerPC BookE masked watchpoints.

gdb/
	* NEWS: Mention masked watchpoint support.  Create "Changed commands"
	section.
	* breakpoint.h (struct breakpoint_ops) <works_in_software_mode>: New
	method.  Initialize to NULL in all existing breakpoint_ops instances.
	(struct breakpoint) <hw_wp_mask>: New field.
	* breakpoint.c (is_masked_watchpoint): Add prototype.
	(update_watchpoint): Don't set b->val for masked watchpoints.  Call
	breakpoint's breakpoint_ops.works_in_software_mode if available.
	(watchpoints_triggered): Handle the case of a hardware masked
	watchpoint trigger.
	(watchpoint_check): Likewise.
	(works_in_software_mode_watchpoint): New function.
	(insert_masked_watchpoint, remove_masked_watchpoint)
	(resources_needed_masked_watchpoint)
	(works_in_software_mode_masked_watchpoint, print_it_masked_watchpoint)
	(print_one_detail_masked_watchpoint, print_mention_masked_watchpoint)
	(print_recreate_masked_watchpoint, is_masked_watchpoint): New
	functions.
	(masked_watchpoint_breakpoint_ops): New structure.
	(watch_command_1): Check for the existence of the `mask' parameter.
	Set b->ops according to the type of hardware watchpoint being created.
	* ppc-linux-nat.c (ppc_linux_insert_mask_watchpoint)
	(ppc_linux_remove_mask_watchpoint)
	(ppc_linux_masked_watch_num_registers): New functions.
	(_initialize_ppc_linux_nat): Initialize to_insert_mask_watchpoint,
	to_remove_mask_watchpoint and to_masked_watch_num_registers.
	* target.c (update_current_target): Mention to_insert_mask_watchpoint,
	to_remove_mask_watchpoint, and to_masked_watch_num_registers.
	(target_insert_mask_watchpoint, target_remove_mask_watchpoint)
	(target_masked_watch_num_registers): New functions.
	* target.h (struct target_ops) <to_insert_mask_watchpoint>,
	<to_remove_mask_watchpoint>, <to_masked_watch_num_registers>: New
	methods.
	(target_insert_mask_watchpoint, target_remove_mask_watchpoint)
	(target_masked_watch_num_registers): Add prototypes.

gdb/doc/
	* gdb.texinfo (Set Watchpoints): Document mask parameter.
	(PowerPC Embedded): Mention support of masked watchpoints.
@
text
@d10786 1
a10786 1
	      sprintf (exception_name, "exception");
@


1.295
log
@gdb/
	* ada-lang.c (struct add_partial_datum): Update the comment for
	expand_partial_symbol_name.
	(ada_add_partial_symbol_completions): Rename to ...
	(ada_expand_partial_symbol_name): ... here, change return type, update
	function comment, call symbol_completion_match instead of
	symbol_completion_add.
	(ada_make_symbol_completion_list): Use now expand_partial_symbol_names
	and ada_expand_partial_symbol_name.
	* dwarf2read.c (dw2_expand_symtabs_matching): Support NULL
	FILE_MATCHER.
	(dw2_map_symbol_names): Remove.
	(dwarf2_gdb_index_functions): Unlist dw2_map_symbol_names.
	* psymtab.c (map_symbol_names_psymtab): Remove.
	(expand_symtabs_matching_via_partial): Support NULL FILE_MATCHER.
	Support KIND == ALL_DOMAIN.  Exchange the NAME_MATCHER and KIND check
	order.
	(psym_functions): Unlist map_symbol_names_psymtab.
	(map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type, call
	expand_symtabs_matching with ALL_DOMAIN and NULL FILE_MATCHER now.
	* psymtab.h (map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type.
	* symfile.h (struct quick_symbol_functions): Update the description of
	expand_symtabs_matching.  Remove map_symbol_names.
	* symtab.c (search_symbols): Add ALL_DOMAIN to the function comment.
	(struct add_name_data): Update the comment for
	expand_partial_symbol_name.
	(add_partial_symbol_name): Rename to ...
	(expand_partial_symbol_name): ... here.  Replace
	completion_list_add_name call by strncmp.
	(default_make_symbol_completion_list_break_on): Use now
	expand_partial_symbol_names and expand_partial_symbol_name.
	* symtab.h (enum search_domain): New element ALL_DOMAIN.

gdb/testsuite/
	* gdb.cp/cpcompletion.exp (complete class methods)
	(complete class methods beginning with F): Move them above runto.  New
	comment about the runto delimiter.
@
text
@d10953 1
d10994 1
d11033 1
@


1.294
log
@[Ada] fix printing slice of array defined as typedef

A change we are making in the compiler to help preserve useful
types when using -feliminate-unused-debug-types exposed a small
hole in our value-printing code.

One example of the problem happens when trying to print a slice
of an array pointer.  If the variable is defined as a pointer to
the typedef of an array, then we fail to print the slice, like so:

    (gdb) p arr_ptr(1..2)
    cannot take slice of non-array

gdb/ChangeLog:

        * ada-lang.c (ada_is_simple_array_type, ada_value_slice_from_ptr)
        (ada_value_slice, empty_array, to_fixed_array_type): Deal with
        typedefs.
@
text
@d5493 1
a5493 1
   map_partial_symbol_names method.  */
d5505 3
a5507 3
/* A callback for map_partial_symbol_names.  */
static void
ada_add_partial_symbol_completions (const char *name, void *user_data)
d5510 3
a5512 4

  symbol_completion_add (data->completions, name,
			 data->text, data->text_len, data->text0, data->word,
			 data->wild_match, data->encoded);
d5570 1
a5570 1
    map_partial_symbol_names (ada_add_partial_symbol_completions, &data);
@


1.293
log
@improve Ada exception catchpoint MI notification

This rewrites the code generating the Ada exception catchpoint hit
notification for both the GDB/MI case as well as the non-MI case,
by using the relevant ui_out_* functions to generate the output.
the MI notifications for Ada exception catchpoints now include
the stop reason, and the breakpoint "disp", much like other breakpoint
events do.  It also introduces a new field "exception-name" for
exception catchpoints (excluding "failed assertion catchpoints,
where we just want to know that it was a failed assertion).

gdb/ChangeLog:

        * breakpoint.h (bpdisp_text): Add declaration.
        * breakpoint.c (bpdisp_text): Make non-static.
        * ada-lang.c: #include "mi/mi-common.h".
        (print_it_exception): Rewrite to improve GDB/MI output.

gdb/doc/ChangeLog:

        * gdb.texinfo (GDB/MI Ada Exception Information): Document
        the "exception-name" field in the *stopped async record.

gdb/testsuite/ChangeLog:

        * gdb.ada/mi_catch_ex: New testcase.
@
text
@d1736 2
a1737 1
              && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ARRAY));
d2582 1
d2584 2
a2585 2
    + ((low - ada_discrete_type_low_bound (TYPE_INDEX_TYPE (type)))
       * TYPE_LENGTH (TYPE_TARGET_TYPE (type)));
d2587 1
a2587 1
    create_range_type (NULL, TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (type)),
d2590 1
a2590 1
    create_array_type (NULL, TYPE_TARGET_TYPE (type), index_type);
d2599 1
a2599 1
  struct type *type = value_type (array);
d2808 1
d2810 1
a2810 1
    create_range_type (NULL, TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (arr_type)),
d2812 1
a2812 1
  struct type *elt_type = ada_array_element_type (arr_type, 1);
d7558 1
@


1.292
log
@2011-03-31  Thiago Jung Bauermann  <bauerman@@br.ibm.com>
	    Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>

	Implement support for PowerPC BookE ranged breakpoints.

gdb/
	* NEWS: Mention support for ranged breakpoints on embedded PowerPC.
	* breakpoint.h (struct bp_target_info) <length>: New member
	variable.
	(struct breakpoint_ops) <breakpoint_hit>: Take struct bp_location
	instead of struct breakpoint as argument, and also add ASPACE
	and BP_ADDR arguments.  Update all callers.
	(struct breakpoint_ops) <print_one_detail>: New method.
	(struct breakpoint) <addr_string_range_end>: New member variable.
	* breakpoint.c (breakpoint_location_address_match): Add function
	prototype.
	(insert_bp_location): Set bl->target_info.length.
	(breakpoint_here_p): Call breakpoint_location_address_match.
	(moribund_breakpoint_here_p): Likewise.
	(regular_breakpoint_inserted_here_p): Likewise.
	(breakpoint_thread_match): Likewise.
	(bpstat_stop_status): Likewise.
	(bpstat_check_location): Move call to
	breakpoint_ops.breakpoint_hit to the top.
	(print_one_breakpoint_location): Call
	breakpoint_ops.print_one_detail if available.
	(breakpoint_address_match_range): New function.
	(breakpoint_location_address_match): Likewise.
	(breakpoint_locations_match): Compare the length field of the
	locations too.
	(hw_breakpoint_used_count): Count resources used by all locations
	in a breakpoint, and use breakpoint_ops.resources_needed if
	available.
	(breakpoint_hit_ranged_breakpoint): New function.
	(resources_needed_ranged_breakpoint): Likewise.
	(print_it_ranged_breakpoint): Likewise.
	(print_one_ranged_breakpoint): Likewise.
	(print_one_detail_ranged_breakpoint): Likewise.
	(print_mention_ranged_breakpoint): Likewise.
	(print_recreate_ranged_breakpoint): Likewise.
	(ranged_breakpoint_ops): New structure.
	(find_breakpoint_range_end): New function.
	(break_range_command): Likewise.
	(delete_breakpoint): Free addr_string_range_end.
	(update_breakpoint_locations): Add SALS_END argument.  Update
	all callers.  Calculate breakpoint length if a non-zero SALS_END
	is given.  Call breakpoint_locations_match instead of
	breakpoint_address_match.
	(reset_breakpoint): Find SaL of the end of the range if B is a
	ranged breakpoint.
	(_initialize_breakpoint): Register break-range command.
	* defs.h (print_core_address): Add function prototype.
	* ppc-linux-nat.c (ppc_linux_ranged_break_num_registers): New
	function.
	(ppc_linux_insert_hw_breakpoint): Support ranged breakpoints.
	(ppc_linux_remove_hw_breakpoint): Likewise.
	(_initialize_ppc_linux_nat): Initialize
	to_ranged_break_num_registers.
	* target.c (update_current_target): Add comment about
	to_ranged_break_num_registers.
	(target_ranged_break_num_registers): New function.
	* target.h (struct target_ops) <to_ranged_break_num_registers>:
	New method.
	(target_ranged_break_num_registers): Add function prototype.
	* ui-out.c (ui_out_field_core_addr): Move address-printing logic to ...
	* utils.c (print_core_address): ... here.

gdb/doc/
	* gdb.texinfo (PowerPC Embedded): Document ranged breakpoints.
@
text
@d63 1
d10749 1
a10749 2
  const CORE_ADDR addr = ada_exception_name_addr (ex, b);
  char exception_name[256];
d10751 1
a10751 1
  if (addr != 0)
d10753 3
a10755 2
      read_memory (addr, exception_name, sizeof (exception_name) - 1);
      exception_name [sizeof (exception_name) - 1] = '\0';
d10758 3
a10760 1
  ada_find_printable_frame (get_current_frame ());
a10761 1
  annotate_catchpoint (b->number);
a10764 6
        if (addr != 0)
          printf_filtered (_("\nCatchpoint %d, %s at "),
                           b->number, exception_name);
        else
          printf_filtered (_("\nCatchpoint %d, exception at "), b->number);
        break;
d10766 29
a10794 7
        if (addr != 0)
          printf_filtered (_("\nCatchpoint %d, unhandled %s at "),
                           b->number, exception_name);
        else
          printf_filtered (_("\nCatchpoint %d, unhandled exception at "),
                           b->number);
        break;
d10796 7
a10802 3
        printf_filtered (_("\nCatchpoint %d, failed assertion at "),
                         b->number);
        break;
d10804 2
@


1.292.2.1
log
@gdb/
	* ada-lang.c (struct add_partial_datum): Update the comment for
	expand_partial_symbol_name.
	(ada_add_partial_symbol_completions): Rename to ...
	(ada_expand_partial_symbol_name): ... here, change return type, update
	function comment, call symbol_completion_match instead of
	symbol_completion_add.
	(ada_make_symbol_completion_list): Use now expand_partial_symbol_names
	and ada_expand_partial_symbol_name.
	* dwarf2read.c (dw2_expand_symtabs_matching): Support NULL
	FILE_MATCHER.
	(dw2_map_symbol_names): Remove.
	(dwarf2_gdb_index_functions): Unlist dw2_map_symbol_names.
	* psymtab.c (map_symbol_names_psymtab): Remove.
	(expand_symtabs_matching_via_partial): Support NULL FILE_MATCHER.
	Support KIND == ALL_DOMAIN.  Exchange the NAME_MATCHER and KIND check
	order.
	(psym_functions): Unlist map_symbol_names_psymtab.
	(map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type, call
	expand_symtabs_matching with ALL_DOMAIN and NULL FILE_MATCHER now.
	* psymtab.h (map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type.
	* symfile.h (struct quick_symbol_functions): Update the description of
	expand_symtabs_matching.  Remove map_symbol_names.
	* symtab.c (search_symbols): Add ALL_DOMAIN to the function comment.
	(struct add_name_data): Update the comment for
	expand_partial_symbol_name.
	(add_partial_symbol_name): Rename to ...
	(expand_partial_symbol_name): ... here.  Replace
	completion_list_add_name call by strncmp.
	(default_make_symbol_completion_list_break_on): Use now
	expand_partial_symbol_names and expand_partial_symbol_name.
	* symtab.h (enum search_domain): New element ALL_DOMAIN.

gdb/testsuite/
	* gdb.cp/cpcompletion.exp (complete class methods)
	(complete class methods beginning with F): Move them above runto.  New
	comment about the runto delimiter.
@
text
@d5489 1
a5489 1
   expand_partial_symbol_names method.  */
d5501 3
a5503 3
/* A callback for expand_partial_symbol_names.  */
static int
ada_expand_partial_symbol_name (const char *name, void *user_data)
d5506 4
a5509 3
  
  return symbol_completion_match (name, data->text, data->text_len,
                                  data->wild_match, data->encoded) != NULL;
d5567 1
a5567 1
    expand_partial_symbol_names (ada_expand_partial_symbol_name, &data);
@


1.292.2.2
log
@improve Ada exception catchpoint MI notification

This rewrites the code generating the Ada exception catchpoint hit
notification for both the GDB/MI case as well as the non-MI case,
by using the relevant ui_out_* functions to generate the output.
the MI notifications for Ada exception catchpoints now include
the stop reason, and the breakpoint "disp", much like other breakpoint
events do.  It also introduces a new field "exception-name" for
exception catchpoints (excluding "failed assertion catchpoints,
where we just want to know that it was a failed assertion).

gdb/ChangeLog:

        * breakpoint.h (bpdisp_text): Add declaration.
        * breakpoint.c (bpdisp_text): Make non-static.
        * ada-lang.c: #include "mi/mi-common.h".
        (print_it_exception): Rewrite to improve GDB/MI output.

gdb/doc/ChangeLog:

        * gdb.texinfo (GDB/MI Ada Exception Information): Document
        the "exception-name" field in the *stopped async record.

gdb/testsuite/ChangeLog:

        * gdb.ada/mi_catch_ex: New testcase.
@
text
@a62 1
#include "mi/mi-common.h"
d10747 2
a10748 1
  annotate_catchpoint (b->number);
d10750 1
a10750 1
  if (ui_out_is_mi_like_p (uiout))
d10752 2
a10753 3
      ui_out_field_string (uiout, "reason",
			   async_reason_lookup (EXEC_ASYNC_BREAKPOINT_HIT));
      ui_out_field_string (uiout, "disp", bpdisp_text (b->disposition));
d10756 1
a10756 3
  ui_out_text (uiout, "\nCatchpoint ");
  ui_out_field_int (uiout, "bkptno", b->number);
  ui_out_text (uiout, ", ");
d10758 1
d10762 6
d10769 7
a10775 29
	{
	  const CORE_ADDR addr = ada_exception_name_addr (ex, b);
	  char exception_name[256];

	  if (addr != 0)
	    {
	      read_memory (addr, exception_name, sizeof (exception_name) - 1);
	      exception_name [sizeof (exception_name) - 1] = '\0';
	    }
	  else
	    {
	      /* For some reason, we were unable to read the exception
		 name.  This could happen if the Runtime was compiled
		 without debugging info, for instance.  In that case,
		 just replace the exception name by the generic string
		 "exception" - it will read as "an exception" in the
		 notification we are about to print.  */
	      sprintf (exception_name, "exception");
	    }
	  /* In the case of unhandled exception breakpoints, we print
	     the exception name as "unhandled EXCEPTION_NAME", to make
	     it clearer to the user which kind of catchpoint just got
	     hit.  We used ui_out_text to make sure that this extra
	     info does not pollute the exception name in the MI case.  */
	  if (ex == ex_catch_exception_unhandled)
	    ui_out_text (uiout, "unhandled ");
	  ui_out_field_string (uiout, "exception-name", exception_name);
	}
	break;
d10777 3
a10779 7
	/* In this case, the name of the exception is not really
	   important.  Just print "failed assertion" to make it clearer
	   that his program just hit an assertion-failure catchpoint.
	   We used ui_out_text because this info does not belong in
	   the MI output.  */
	ui_out_text (uiout, "failed assertion");
	break;
a10780 2
  ui_out_text (uiout, " at ");
  ada_find_printable_frame (get_current_frame ());
@


1.292.2.3
log
@[Ada] fix printing slice of array defined as typedef

A change we are making in the compiler to help preserve useful
types when using -feliminate-unused-debug-types exposed a small
hole in our value-printing code.

One example of the problem happens when trying to print a slice
of an array pointer.  If the variable is defined as a pointer to
the typedef of an array, then we fail to print the slice, like so:

    (gdb) p arr_ptr(1..2)
    cannot take slice of non-array

gdb/ChangeLog:

        * ada-lang.c (ada_is_simple_array_type, ada_value_slice_from_ptr)
        (ada_value_slice, empty_array, to_fixed_array_type): Deal with
        typedefs.
@
text
@d1736 1
a1736 2
              && TYPE_CODE (ada_check_typedef (TYPE_TARGET_TYPE (type)))
                 == TYPE_CODE_ARRAY));
a2580 1
  struct type *type0 = ada_check_typedef (type);
d2582 2
a2583 2
    + ((low - ada_discrete_type_low_bound (TYPE_INDEX_TYPE (type0)))
       * TYPE_LENGTH (TYPE_TARGET_TYPE (type0)));
d2585 1
a2585 1
    create_range_type (NULL, TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (type0)),
d2588 1
a2588 1
    create_array_type (NULL, TYPE_TARGET_TYPE (type0), index_type);
d2597 1
a2597 1
  struct type *type = ada_check_typedef (value_type (array));
a2805 1
  struct type *arr_type0 = ada_check_typedef (arr_type);
d2807 1
a2807 1
    create_range_type (NULL, TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (arr_type0)),
d2809 1
a2809 1
  struct type *elt_type = ada_array_element_type (arr_type0, 1);
a7553 1
  type0 = ada_check_typedef (type0);
@


1.291
log
@undefined newexpr->gdbarch field in ada-lang.c:replace_operator_with_call

2011-03-20  Jan Kratochvil  <jan.kratochvil@@redhat.com>

        * ada-lang.c (replace_operator_with_call): Copy also GDBARCH.
@
text
@d10928 1
d10968 1
d11006 1
@


1.290
log
@use xzalloc in ada-lang.c:replace_operator_with_call

This is to make sure that we cannot have a field with an undefined
value (currently, we are not setting the gdbarch).

gdb/ChangeLog:

	* ada-lang.c (replace_operator_with_call): Use xzalloc instead
	of xmalloc.
@
text
@d3664 1
@


1.289
log
@* ada-lang.c (compare_names): Call is_name_suffix with string1
instead of string2.
@
text
@d3658 1
a3658 1
    xmalloc (sizeof (struct expression)
@


1.288
log
@add FALLTHROUGH comment in ada-lang.c:compare_names

gdb/ChangeLog:

	* ada-lang.c (compare_names): Add FALLTHROUGH comment.
@
text
@d4760 1
a4760 1
	  if (is_name_suffix (string2))
@


1.287
log
@2011-03-01  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c (ada_make_symbol_completion_list): Replace malloc
	with xmalloc.
@
text
@d4765 1
@


1.286
log
@2011-03-01  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c (aggregate_assign_others): Rename inner scope variable
	which shadows function parameter.
@
text
@d5637 1
a5637 1
    char **result = malloc (completions_size);
@


1.285
log
@[Ada] Fix unconstrained packed array size

When ada-lang transforms an array descriptor type (an XUP structure)
into an array type, the size of the array type is computed by using
the element size, and multiplying it by the number of elements in
that array. This does not work, however, for packed arrays, where
the *packed* size in bits needs to be used.

This usually does not cause any problem, because we end up reading
more memory than needed.  However, we have observed on LynxOS
a memory error while trying to read the entire array, because
the larger-than-needed read tried to read past the end of the stack
into inaccessible memory.

This patch fixes the problem by correctly computing the array size
in bytes in the case of packed arrays.

gdb/ChangeLog:

        * ada-lang.c (ada_type_of_array): Fix the size of the array
        in the case of an unconstrained packed array.

gdb/testsuite/ChangeLog:

        * gdb.ada/packed_array: Expand testcase to test printing of
        unconstrained packed array.
@
text
@d8720 1
a8720 1
  int expr_pc = *pos+1;
d8728 1
a8728 1
	  int pos;
d8730 2
a8731 2
	  pos = expr_pc;
	  assign_component (container, lhs, ind, exp, &pos);
@


1.284
log
@gdb/
	Make value allocations more lazy.
	* ada-lang.c (coerce_unspec_val_to_type): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy when possible.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy.
	* findvar.c (value_of_register_lazy): Likewise.
	(read_var_value): Remove V preallocation, call just check_typedef in
	advance.  Move allocate_value to LOC_CONST, LOC_LABEL,
	LOC_CONST_BYTES.  Use allocate_value_lazy in LOC_STATIC, LOC_ARG,
	LOC_REF_ARG, LOC_LOCAL, LOC_BLOCK.  Set ADDR instead of
	set_value_address and break in LOC_BLOCK.  Use allocate_value_lazy and
	remove lval_memory set in LOC_REGPARM_ADDR.  Use allocate_value_lazy
	in LOC_UNRESOLVED and LOC_OPTIMIZED_OUT.  Add setting lval_memory at
	the end, remove set_value_lazy there.
	* valarith.c (value_subscripted_rvalue): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy when possible.
	* valops.c (value_fetch_lazy): Do nop for value_optimized_out VAL.
	* value.c (allocate_computed_value): Use allocate_value_lazy instead
	of allocate_value and set_value_lazy.
	(value_from_contents_and_address): Use allocate_value_lazy instead of
	allocate_value and set_value_lazy when possible.
@
text
@d1826 19
a1844 2
	    TYPE_FIELD_BITSIZE (elt_type, 0) =
	      decode_packed_array_bitsize (value_type (arr));
@


1.283
log
@2011-01-11  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Implement support for PowerPC BookE ranged watchpoints.

gdb/
	* breakpoint.h
	(struct breakpoint_ops) <resources_needed>: New method.
	Initialize to NULL in all existing breakpoint_ops instances.
	(struct breakpoint) <exact>: New field.
	(target_exact_watchpoints): Declare external global.
	* breakpoint.c (target_exact_watchpoints): New global flag.
	(update_watchpoint): Set b->type to bp_hardware_watchpoint and
	b->enable_state to bp_enabled before calling
	hw_watchpoint_used_count.
	(hw_watchpoint_used_count): Iterate over all bp_locations in a
	watchpoint.  Call breakpoint's breakpoint_ops.resources_needed
	if available.
	(insert_watchpoint, remove_watchpoint): Use fixed length of 1 byte
	if the watchpoint is exact.
	(resources_needed_watchpoint): New function.
	(watchpoint_breakpoint_ops): Add resources_needed_watchpoint.
	(watch_command_1): Set b->exact if the user asked for an exact
	watchpoint and one can be set.
	(can_use_hardware_watchpoint): Add exact_watchpoints argument.
	Pass fixed length of 1 to target_region_ok_for_hw_watchpoint if
	the user asks for an exact watchpoint and one can be set.  Return
	number of needed debug registers to watch the expression.
	* gdbtypes.c (is_scalar_type): New function, based on
	valprint.c:scalar_type_p.
	(is_scalar_type_recursive): New function.
	* gdbtypes.h (is_scalar_type_recursive): Declare.
	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint): Always
	handle regions when ranged watchpoints are available.
	(create_watchpoint_request): New function.
	(ppc_linux_insert_watchpoint, ppc_linux_remove_watchpoint): Use
	create_watchpoint_request.
	* rs6000-tdep.c (show_powerpc_exact_watchpoints): New function.
	(_initialize_rs6000_tdep): Add `exact-watchpoints' boolean to the
	`set powerpc' and `show powerpc' commands.
	* target.h (struct target_ops) <to_region_ok_for_hw_watchpoint>:
	Mention documentation comment in the target macro.
	(target_region_ok_for_hw_watchpoint): Document return value.

gdb/doc/
	* gdb.texinfo (PowerPC Embedded): Document ranged watchpoints and
	the "set powerpc exact-watchpoints" flag.
@
text
@d559 9
a567 1
      result = allocate_value (type);
a571 6
      if (value_lazy (val)
          || TYPE_LENGTH (type) > TYPE_LENGTH (value_type (val)))
        set_value_lazy (result, 1);
      else
        memcpy (value_contents_raw (result), value_contents (val),
                TYPE_LENGTH (type));
@


1.282
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d10904 1
d10943 1
d10980 1
@


1.281
log
@Fix typo in ada-lang.c comment.

gdb/ChangeLog:

        * ada-lang.c: Fix typo in comment.
@
text
@d65 1
a65 1
   differently signed operands (truncation direction is undefined in C). 
d242 2
a243 1
				       struct expression *, int *, enum noside);
d625 1
a625 1
/* Maximum value of a SIZE-byte signed integer type. */
d634 1
a634 1
/* Minimum value of a SIZE-byte signed integer type. */
d641 1
a641 1
/* Maximum value of a SIZE-byte unsigned integer type. */
d650 1
a650 1
/* Maximum value of integral type T, as a signed quantity. */
d660 1
a660 1
/* Minimum value of integral type T, as a signed quantity. */
d938 1
a938 1
     the 'P' suffix. The second calls the first one after handling
d1118 1
a1118 1
         of subprograms created by the compiler for each entry. The first
d1236 1
a1236 1
   GSYMBOL).  
d1239 1
a1239 2
   when a decoded name is cached in it.
*/
d1711 1
a1711 1
 * to one. */
d2042 2
a2043 1
      lim_warning (_("could not understand bounds information on packed array"));
d2129 2
a2130 1
          (_("attempt to do packed indexing of something other than a packed array"));
d2145 2
a2146 1
            lim_warning (_("packed array index %ld out of bounds"), (long) idx);
d2180 1
a2180 1
   assigning through the result will set the field fetched from.  
d2556 1
a2556 1
   per Ada rules. */
d3829 1
a3829 1
   entity. Returns ADA_NOT_RENAMING if SYM does not encode a renaming
d4075 2
a4076 1
  for (i = ada_array_arity (ada_check_typedef (value_type (arr))); i > 0; i -= 1)
d4113 1
a4113 1
 * used in the public sources. */
d4414 1
a4414 1
     <scope>__<rename>___<XR extension>. 
d4553 1
a4553 1
     First, zero out such symbols, then compress. */
d4791 4
a4794 2
	  objfile->sf->qf->map_matching_symbols (name1, domain, objfile, global,
						 aux_add_nonlocal_symbols, &data,
d4922 1
a4922 1
   choosing the first symbol if there are multiple choices.  
d5001 2
a5002 2
     with a N at the end. Unfortunately, the compiler uses the same
     convention for other internal types it creates. So treating
d5004 2
a5005 2
     some regressions. For instance, consider the case of an enumerated
     type. To support the 'Image attribute, it creates an array whose
d5008 1
a5008 1
     information is a bit risky. Perhaps we should change the encoding
d5195 1
a5195 1
   (if necessary).  If WILD, treat as NAME with a wildcard prefix. 
d5682 1
a5682 1
   pointer or reference type whose ultimate target has a tag field. */
d5724 1
a5724 1
   ADDRESS. */
d5768 1
a5768 1
   value ARGS, sets ARGS->name to the tag name of ARGS->tag.  
d5810 1
a5810 1
   the tsd pointer is stored just before the dispatch table. */
d6101 1
a6101 1
/* FIXME: Lots of redundancy below.  Try to consolidate. */
d6145 1
a6145 1
   Returns 1 if found, 0 otherwise. */
d6220 1
a6220 1
/* Number of user-visible fields in record type TYPE. */
d6257 1
a6257 1
          struct value *v =     /* Do not let indent join lines here. */
d6268 1
a6268 1
	  /* PNH: Do we ever get here?  See find_struct_field. */
d6276 2
a6277 1
              struct value *v = ada_search_struct_field /* Force line break.  */
d6297 1
a6297 1
 * If found, return value, else return NULL. */
d6309 1
a6309 1
 * *INDEX_P. */
d6324 1
a6324 1
          struct value *v =     /* Do not let indent join lines here. */
d6336 1
a6336 1
	     find_struct_field. */
d6440 2
a6441 1
    error (_("Attempt to extract a component of a value that is not a record."));
d6452 1
a6452 1
   TYPE can be either a struct or union. If REFOK, TYPE may also 
d6544 1
a6544 1
	         if the compiler changes this practice. */
d6551 2
a6552 1
		t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (field_type, j),
d6593 1
a6593 1
   record that is named in an Unchecked_Union pragma). */
d6791 1
a6791 1
  /* Not right yet.  FIXME pnh 7/20/2007. */
d7142 1
a7142 1
		 GDB may fail to allocate a value for it. So check the
d7271 1
a7271 1
     of the resulting type. If this record is not part of another structure,
d7477 1
a7477 1
   it represents a variant subject to a pragma Unchecked_Union. */
d7654 1
a7654 1
           type from there. Note that we have to use the fixed record
d7702 1
a7702 1
                   it, thus using a type with the wrong size. This, in turn,
d8427 1
a8427 1
   OP_AGGREGATE. */
d8495 1
a8495 1
   LHS (unless == CONTAINER).  Returns the modified CONTAINER. */
d8586 1
a8586 1
   assign_aggregate. */
d8611 1
a8611 1
   needed.  CONTAINER is as for assign_aggregate. */
d8693 1
a8693 1
   OP_OTHERS clause.  CONTAINER is as for assign_aggregate*/
d9158 2
a9159 1
        error (_("Operands of fixed-point subtraction must have the same type"));
d9876 1
a9876 1
      arg1 = ada_coerce_ref (arg1);     /* FIXME: What is this for?? */
d9917 1
a9917 1
                   (see ada_type_match). */
d9959 2
a9960 1
	    internal_error (__FILE__, __LINE__, _("aggregate apparently mangled"));
d10243 1
a10243 1
          else if (bounds_str[n] == '.')        /* FIXME? SGI Workshop kludge.  */
d10514 1
a10514 1
     find the run-time symbols. That can mean that we are in
d11142 1
a11142 1
  /* The standard exceptions are a special case. They are defined in
d11147 1
a11147 1
     *not* return this standard exception. The catchpoint condition
d11152 1
a11152 1
     systematically prefixed by "standard". This means that "catch
d11819 2
a11820 1
  NULL,                         /* Language specific class_name_from_physname */
@


1.280
log
@[Ada] do not print arrays as array pointers

This patch enhances the debugger to distinguish between fat pointers
that represent either: array types, or array access types.  In the latter
case, the object/type is encoded as a typedef type pointing to the fat
pointer.

The first part of the change is to adjust ada_check_typedef to avoid
stripping the typedef layer when it points to a fat pointer.  The rest
of the patch is adjustments required in various places to deal with
the fact that the type is uses might now be a typedef.

gdb/ChangeLog:

        * ada-lang.h (ada_coerce_to_simple_array): Add declaration.
        * ada-lang.c (ada_typedef_target_type): New function.
        (desc_base_type): Add handling of fat pointer typedefs.
        (ada_coerce_to_simple_array): Make non-static.
        (decode_packed_array_bitsize): Add handling of fat pointer typedefs.
        Add assertion.
        (ada_template_to_fixed_record_type_1, ada_to_fixed_type)
        (ada_check_typedef): Add handling of fat pointer typedefs.
        (ada_evaluate_subexp) [OP_FUNCALL]: Likewise.
        * ada-typeprint.c (ada_print_type): Add handling of fat pointer
        typedefs.
        * ada-valprint.c (ada_val_print_1): Convert fat pointers that are not
        array accesses to simple arrays rather than simple array pointers.
        (ada_value_print): In the case of array descriptors, do not print
        the value type description unless it is an array access.

gdb/testsuite/ChangeLog:

        * gdb.ada/lang_switch.exp: Correct expected parameter value.

gdb/doc/ChangeLog:

        * gdb.texinfo (Ada Glitches): Remove paragraph describing the
        occasional case where the debugger prints an array address
        instead of the array itself.
@
text
@d368 1
a368 1
   all typedef layers have been pealed.  Otherwise, return TYPE.
@


1.279
log
@Delete redundant variable in ada_template_to_fixed_record_type_1.

gdb/ChangeLog:

        * ada-lang.c (ada_template_to_fixed_record_type_1): Delete bit_incr.
@
text
@a230 2
static struct value *ada_coerce_to_simple_array (struct value *);

d367 35
d1390 3
d1858 1
a1858 1
static struct value *
d1932 1
a1932 1
  char *raw_name = ada_type_name (ada_check_typedef (type));
d1936 7
d1950 1
d7193 9
d7759 1
a7759 1
      && (TYPE_MAIN_TYPE (TYPE_TARGET_TYPE (type))
d7845 9
d9347 7
@


1.278
log
@[Ada] array pointers encoded as typedef to fat pointer

A recent change in check_typedef caused the following regression,
considering:

        type String_Access is access String;
        S1 : String_Access := null;

Trying to print S1, we get:

        (gdb) print s1
        $1 = (string) (null)

The type name is wrong.  We were expecting:

        (gdb) print s1
        $1 = (string_bug.string_access) (null)

The extensive comment in this patch explains how pointers to arrays
are encoded when the array is a "fat pointer".  What happened is
that the change in check_typedef broke a type-equality test that
we were performing.   The test really was on the fringe, but it
turns out that, for what we're doing, we're really only interested
in the main-type portion of the type.

The patch adjust the check accordingly.

gdb/ChangeLog:

        * ada-lang.c (ada_to_fixed_type): Expand function documentation.
        Return the original type if the main type portions match rather
         than when the type themselves match.
@
text
@d7033 1
a7033 1
  int fld_bit_len, bit_incr;
d7075 1
a7075 1
          fld_bit_len = bit_incr = 0;
d7142 1
a7142 1
          bit_incr = fld_bit_len =
d7152 1
a7152 1
            bit_incr = fld_bit_len =
d7155 1
a7155 1
            bit_incr = fld_bit_len =
d7160 1
a7160 1
      off += bit_incr;
@


1.277
log
@GDB SEGV while trying to print uninitialize variant record

We have a variant record whose value is defined as follow:

   type Discriminant_Record (Num1, Num2,
                             Num3, Num4 : Natural) is record
      Field1 : My_Record_Array (1 .. Num2);
      Field2 : My_Record_Array (Num1 .. 10);
      Field3 : My_Record_Array (Num1 .. Num2);
      Field4 : My_Record_Array (Num3 .. Num2);
      Field5 : My_Record_Array (Num4 .. Num2);
   end record;
   Dire : Discriminant_Record (1, 7, 3, 0);

However, we're trying to print "Dire" before it is elaborated.
This is common if one breaks on a function and then starts doing
"info locals" for instance.

What happens is that GDB reads bogus values for fields Num1 to
Num4, and deduces a bogus (ginormouos) size for component
"Field1".  The length is so large that it then later causes
an overflow in the overall record length computation. Things
go downhill from there, because length(field1) > length(record).
So, when after we've fetched the value of the record based on
the computed size, we crash trying to access unallocated memory
when accessing field1...

The first fix we can do is to check the size of the field
against the maximum object size.  If it exceeds that size,
then we know the record will also exceed that size...

gdb/ChangeLog:

        * ada-lang.c (ada_template_to_fixed_record_type_1):
        For dynamic fields, check the field size against the maximum
        object size.
@
text
@d7662 17
a7678 1
   ada_to_fixed_type_1 would return the type referenced by TYPE.  */
d7688 17
d7706 2
a7707 1
      && TYPE_TARGET_TYPE (type) == fixed_type)
@


1.276
log
@infinite recursion with ada_check_typedef

When trying to resolve an incomplete type, if there is no complete
version of that type available, GDB can go in an infinite loop.

This is because ada_check_typedef makes a recursive call to itself,
in an attempt to make sure that the returned type is never a typedef.
However, when no complete type is found, the current logic causes us
to keep going indefinitely through the same path...

This patch fixes the problem by performing the recursive call to
ada_check_typedef only when a TYPE_CODE_TYPDEF layer needs to be
stripped.

gdb/ChangeLog:

        * ada-lang.c (ada_check_typedef): Call ada_check_typedef only
        if type1 is a typedef.
@
text
@d7125 8
d7136 6
@


1.275
log
@gdb/
	* ada-lang.c (modify_general_field): Remove.
	(make_array_descriptor): Replace all modify_general_field calls by
	modify_field.
	* value.c (modify_field): Update comment.  New variable bytesize.
	Normalize BITPOS.  Initialize BYTESIZE, use it.
@
text
@d7759 6
a7764 4
	 types, only for the typedef-to-array types).  This is why
	 we process TYPE1 with ada_check_typedef before returning
	 the result.  */
      return ada_check_typedef (type1);
@


1.274
log
@Rework symbol searches to move Ada-specific stuff to ada-lang.c.

This is a clean-up of some of our symbol-lookup machinery to pull some
kludgy Ada-specific definitions out of psymtab.c.  In place of
map_ada_symtabs and ada_lookup_partial_symbol, we have a method
map_matching_symbols, which searches through all symbol tables and
partial symbol tables looking for a symbol that matches according to
a matching function that is passed as a parameter. This requires some
care, because partial symbol tables speed up searches by binary search,
while full symbol tables use hashing. To call map_matching_symbols, therefore,
you may need to supply both a matching function that is compatible with the
dictionary hash function and an ordering relation that is compatible with
strcmp_iw, which is used to order partial symbol tables.

Having added this general routine to psymtab.c, we use it in ada-lang.c
to rework add_non_local_symbols (now renamed add_nonlocal_symbols).

Changelog:

    gdb/

    * ada-lang.c (full_match): Declare.
    (ada_match_name): Rename to match_name (we should avoid prefixing static
    symbols with "ada_").
    (match_name): New name for ada_match_name.
    (struct ada_psym_data): Remove and replace with...
    (struct match_data): User data for map_matching_symbols.
    (ada_add_psyms): Remove.
    (aux_add_nonlocal_symbols): New function, used as callback for
    map_matching_symbols.
    (compare_names): Ordering function adopted from strcmp_iw for Ada-encoded
    symbols.
    (ada_add_non_local_symbols): Rename to add_nonlocal_symbols.
    (add_nonlocal_symbols): Renamed from ada_add_non_local_symbols.
    Rework to use map_matching_symbols instead of map_ada_symtabs.
    (ada_lookup_symbol_list): Use add_nonlocal_symbols.
    * psymtab.c: Include dependency on dictionary.h.
    (match_partial_symbol): New function.
    (ada_lookup_partial_symbol): Remove.
    (map_block): New function, auxiliary to map_matching_symbols_psymtab.
    (map_matching_symbols_psymtab): New function.
    (psym_functions): Replace map_ada_symtabs with map_matching_symbols_psymtab.
    * symfile.h: Replace map_ada_symtabs definition with map_matching_symbols.
@
text
@a71 2
static void modify_general_field (struct type *, char *, LONGEST, int, int);

a1343 9
/* Like modify_field, but allows bitpos > wordlength.  */

static void
modify_general_field (struct type *type, char *addr,
		      LONGEST fieldval, int bitpos, int bitsize)
{
  modify_field (type, addr + bitpos / 8, fieldval, bitpos % 8, bitsize);
}

d4030 8
a4037 10
      modify_general_field (value_type (bounds),
			    value_contents_writeable (bounds),
                            ada_array_bound (arr, i, 0),
                            desc_bound_bitpos (bounds_type, i, 0),
                            desc_bound_bitsize (bounds_type, i, 0));
      modify_general_field (value_type (bounds),
			    value_contents_writeable (bounds),
                            ada_array_bound (arr, i, 1),
                            desc_bound_bitpos (bounds_type, i, 1),
                            desc_bound_bitsize (bounds_type, i, 1));
d4042 13
a4054 13
  modify_general_field (value_type (descriptor),
			value_contents_writeable (descriptor),
                        value_pointer (ensure_lval (arr),
                                       TYPE_FIELD_TYPE (desc_type, 0)),
                        fat_pntr_data_bitpos (desc_type),
                        fat_pntr_data_bitsize (desc_type));

  modify_general_field (value_type (descriptor),
			value_contents_writeable (descriptor),
                        value_pointer (bounds,
                                       TYPE_FIELD_TYPE (desc_type, 1)),
                        fat_pntr_bounds_bitpos (desc_type),
                        fat_pntr_bounds_bitsize (desc_type));
@


1.273
log
@Extend hashed symbol dictionaries to work with Ada

This patch allows Ada to speed up symbol lookup by using the facilities
in dictionary.[ch] for hashed lookups.  First, we generalize dictionary
search to allow clients to specify any matching function compatible with
the hashing function. Next, we modify the hashing algorithm so that symbols
that wild-match a name hash to the same value.  Finally, we modify Ada
symbol lookup to use these facilities.

Because this patch touches on a hashing algorithm used by other
languages, I took the precaution of doing a speed test on a list of
about 12000 identifiers (repeatedly inserting all of them into a table
and then doing a lookup on a million names at random, thus testing the
speed of the hashing algorithm and how well it distributed names).
There was actually a slight speedup, probably as a result of open-
coding some of the tests in msymbol_hash_iw.  By design, the revised
hashing algorithm produces the same results as the original on most
"normal" C identifiers.

We considered augmenting the dictionary interface still further by allowing
different hashing algorithms for different dictionaries, based on the
(supposed) language of the symbols in that dictionary.  While this produced
better isolation of the changes to Ada programs, the additional flexibility
also complicated the dictionary interface.  I'd prefer to keep things
simple for now.

Tested w/o regressions on Linux i686.

ChangeLog:

	gdb/
	* ada-lang.c (ada_match_name): Use new API for wild_match.
	(wild_match): Change API to be consistent with that of strcmp_iw;
	return 0 for a match, and switch operand order.
	(full_match): New function.
	(ada_add_block_symbols): Use dict_iter_match_{first,next} for
	matching to allow use of hashing.
	* dictionary.c (struct dict_vector): Generalize iter_name_first,
	iter_name_next ot iter_match_first, iter_match_next.
	(iter_name_first_hashed): Replace with iter_match_first_hashed.
	(iter_name_next_hashed): Replace with iter_match_next_hashed.
	(iter_name_first_linear): Replace with iter_match_first_linear.
	(iter_name_next_linear): Replace with iter_match_next_linear.
	(dict_iter_name_first): Re-implement to use dict_iter_match_first.
	(dict_iter_name_next): Re-implement to use dict_iter_match_next.
	(dict_iter_match_first): New function.
	(dict_iter_match_next): New function.
	(dict_hash): New function.
	* dictionary.h (dict_iter_match_first, dict_iter_match_next): Declare.
	* psymtab.c (ada_lookup_partial_symbol): Use new wild_match API.
@
text
@d106 2
d1259 1
a1259 1
ada_match_name (const char *sym_name, const char *name, int wild)
d4272 1
a4272 1
    if (ada_match_name (SYMBOL_LINKAGE_NAME (msymbol), name, wild_match)
d4632 1
a4632 1
   calling the map_ada_symtabs method.  */
d4634 1
a4634 1
struct ada_psym_data
d4636 1
d4638 2
a4639 4
  const char *name;
  domain_enum domain;
  int global;
  int wild_match;
d4642 8
a4649 1
/* Callback function for map_ada_symtabs.  */
d4651 2
a4652 2
static void
ada_add_psyms (struct objfile *objfile, struct symtab *s, void *user_data)
d4654 32
a4685 2
  struct ada_psym_data *data = user_data;
  const int block_kind = data->global ? GLOBAL_BLOCK : STATIC_BLOCK;
d4687 30
a4716 3
  ada_add_block_symbols (data->obstackp,
			 BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), block_kind),
			 data->name, data->domain, objfile, data->wild_match);
d4724 3
a4726 3
ada_add_non_local_symbols (struct obstack *obstackp, const char *name,
                           domain_enum domain, int global,
                           int is_wild_match)
d4729 1
a4729 1
  struct ada_psym_data data;
d4732 1
a4732 4
  data.name = name;
  data.domain = domain;
  data.global = global;
  data.wild_match = is_wild_match;
d4735 26
a4760 7
  {
    if (objfile->sf)
      objfile->sf->qf->map_ada_symtabs (objfile, wild_match, is_name_suffix,
					ada_add_psyms, name,
					global, domain,
					is_wild_match, &data);
  }
d4837 2
a4838 2
  ada_add_non_local_symbols (&symbol_list_obstack, name, namespace, 1,
                             wild_match);
d4844 2
a4845 2
    ada_add_non_local_symbols (&symbol_list_obstack, name, namespace, 0,
                               wild_match);
d5146 3
d5152 1
a5152 1
  return !ada_match_name (sym_name, search_name, 0);
d5205 1
a5205 1
					full_match, &iter);
@


1.272
log
@[Ada] Fix ARI warnings in advance_wild_match

gdb/ChangeLog:

        * ada-lang.c (advance_wild_match): Delete local variable t2.
        Adjust code accordingly.  Minor reformatting.
@
text
@d5065 7
d5096 3
a5098 3
      struct symbol *sym;

      ALL_BLOCK_SYMBOLS (block, iter, sym)
d5120 3
a5122 1
      ALL_BLOCK_SYMBOLS (block, iter, sym)
d5127 5
a5131 6
            int cmp = strncmp (name, SYMBOL_LINKAGE_NAME (sym), name_len);

            if (cmp == 0
                && is_name_suffix (SYMBOL_LINKAGE_NAME (sym) + name_len))
              {
		if (SYMBOL_CLASS (sym) != LOC_UNRESOLVED)
d5133 4
a5136 9
		    if (SYMBOL_IS_ARGUMENT (sym))
		      arg_sym = sym;
		    else
		      {
			found_sym = 1;
			add_defn_to_vec (obstackp,
					 fixup_symbol_section (sym, objfile),
					 block);
		      }
d5138 1
a5138 1
              }
@


1.271
log
@[Ada/funcalls] do not coerce fat pointers on the stack

When one of the parameter values in a subprogram calls is an array
whose value does not come from inferior memory, the debugger first
copies the array value in inferior memory.  Up to now, the memory
used to hold that copy was taken from the stack (just below the SP),
but this is causing problems on SPARC v9.

So the immediate fix is to follow what C does with arrays and strings,
which is allocate memory on the heap.

gdb/ChangeLog:

        * ada-lang.c: #include "value.h".
        (ensure_lval): Delete advance declaration.  Remove gdbarch and sp
        arguments.  Implement using value_allocate_space_in_inferior
        instead of allocating memory from the stack.
        (make_array_descriptor): Remove gdbarch and sp parameters.  Update
        calls to ensure_lval.
        (ada_convert_actual): Remove gdbarch and sp parameters.  Update
        calls to make_array_descriptor and ensure_lval.
        * ada-lang.h (ada_convert_actual): Update declaration.
        * infcall.c (value_arg_coerce): Update call to ada_convert_actual.
@
text
@d5002 1
a5002 1
      int t0, t1, t2;
d5016 2
a5017 2
	  else if (t1 == '_' &&
		   (((t2 = name[2]) >= 'a' && t2 <= 'z') || t2 == target0))
@


1.270
log
@Replace wild_match with faster version and modify its interface.

This new version of wild_match is comparable in speed to strcmp_iw, and has
the same signature and same return value for equal names.

gdb/ChangeLog:
    * ada-lang.c (wild_match): Reimplement.
    Change API to eliminate unused length argument, reverse arguments and
    make 0 the 'true' return value.
    (advance_wild_match): New auxiliary function for wild_match to improve
    readability.
    (ada_match_name, ada_add_block_symbols): Use new API for wild_match.
    * psymtab.c (ada_lookup_partial_symbol, map_ada_symtabs): Use new
    API for wild_match.
    * symfile.h (map_ada_symtabs): Modify declaration to use new API for
    wild_match.
    * dwarf2read.c (dw2_map_ada_symtabs): Ditto.
@
text
@d62 1
d106 1
a106 5
static struct value *ensure_lval (struct value *,
				  struct gdbarch *, CORE_ADDR *);

static struct value *make_array_descriptor (struct type *, struct value *,
                                            struct gdbarch *, CORE_ADDR *);
d3928 2
a3929 3
   lvalues, and otherwise has the side-effect of pushing a copy of VAL 
   on the stack, using and updating *SP as the stack pointer, and 
   returning an lvalue whose value_address points to the copy.  */
d3932 1
a3932 1
ensure_lval (struct value *val, struct gdbarch *gdbarch, CORE_ADDR *sp)
d3934 2
a3935 1
  if (! VALUE_LVAL (val))
d3938 2
d3941 1
a3941 23
      /* The following is taken from the structure-return code in
	 call_function_by_hand. FIXME: Therefore, some refactoring seems 
	 indicated. */
      if (gdbarch_inner_than (gdbarch, 1, 2))
	{
	  /* Stack grows downward.  Align SP and value_address (val) after
	     reserving sufficient space. */
	  *sp -= len;
	  if (gdbarch_frame_align_p (gdbarch))
	    *sp = gdbarch_frame_align (gdbarch, *sp);
	  set_value_address (val, *sp);
	}
      else
	{
	  /* Stack grows upward.  Align the frame, allocate space, and
	     then again, re-align the frame. */
	  if (gdbarch_frame_align_p (gdbarch))
	    *sp = gdbarch_frame_align (gdbarch, *sp);
	  set_value_address (val, *sp);
	  *sp += len;
	  if (gdbarch_frame_align_p (gdbarch))
	    *sp = gdbarch_frame_align (gdbarch, *sp);
	}
d3943 1
a3943 2

      write_memory (value_address (val), value_contents (val), len);
d3955 1
a3955 2
ada_convert_actual (struct value *actual, struct type *formal_type0,
                    struct gdbarch *gdbarch, CORE_ADDR *sp)
d3968 1
a3968 1
    return make_array_descriptor (formal_type, actual, gdbarch, sp);
d3988 1
a3988 1
              actual = ensure_lval (val, gdbarch, sp);
d4029 1
a4029 2
make_array_descriptor (struct type *type, struct value *arr,
		       struct gdbarch *gdbarch, CORE_ADDR *sp)
d4051 1
a4051 1
  bounds = ensure_lval (bounds, gdbarch, sp);
d4055 1
a4055 1
                        value_pointer (ensure_lval (arr, gdbarch, sp),
d4067 1
a4067 1
  descriptor = ensure_lval (descriptor, gdbarch, sp);
@


1.269
log
@[Ada] array and bounds in fat pointer can be a stub

This patch adds handling of the case when a fat pointer has the
P_ARRAY and/or P_BOUNDS fields defined as a stub.  In that case,
this stub needs to be resolved.

There are two issues:

  . First, making sure that the resolution takes place itself.
    That's the change to ada_check_typedef.

  . Make sure that the type returned after resolution is not itself
    a typedef.  This is the change to ada_check_typedef.

gdb/ChangeLog (Jerome Guitton, Joel Brobecker):

        * ada-lang.c (desc_bounds): Add handling of the case where
        the P_BOUNDS field is a pointer to a stub.
        (desc_data_target_type): Same for P_ARRAY field.
        (ada_check_typedef): Strip the typedef layers from the type
        found by ada_find_any_type.
@
text
@d203 3
a205 1
static int wild_match (const char *, int, const char *);
d1265 1
a1265 1
    return wild_match (name, strlen (name), sym_name);
d5017 45
a5061 2
/* True if NAME represents a name of the form A1.A2....An, n>=1 and
   PATN[0..PATN_LEN-1] = Ak.Ak+1.....An for some k >= 1.  Ignores
d5063 1
a5063 1
   true).  */
d5066 1
a5066 1
wild_match (const char *patn0, int patn_len, const char *name0)
d5068 2
a5069 2
  char* match;
  const char* start;
a5070 1
  start = name0;
d5073 15
a5087 10
      match = strstr (start, patn0);
      if (match == NULL)
	return 0;
      if ((match == name0 
	   || match[-1] == '.' 
	   || (match > name0 + 1 && match[-1] == '_' && match[-2] == '_')
	   || (match == name0 + 5 && strncmp ("_ada_", name0, 5) == 0))
          && is_name_suffix (match + patn_len))
        return (match == name0 || is_valid_name_for_wild_match (name0));
      start = match + 1;
d5121 1
a5121 1
            && wild_match (name, name_len, SYMBOL_LINKAGE_NAME (sym)))
@


1.268
log
@gdb/
	Fix printing parameters of inlined functions.
	* ada-lang.c (is_known_support_routine)
	(ada_unhandled_exception_name_addr_from_raise): Provide NULL parameter
	for find_frame_funname.
	* python/py-frame.c (frapy_name): Likewise.
	* stack.c (find_frame_funname): New parameter funcp.  Update the
	function comment.  Fill it in.
	(print_frame): New variable func.  Initialize it by
	find_frame_funname.  Print arguments only if FUNC is not NULL.  Use
	FUNC as the parameter of print_args_stub.
	* stack.h (find_frame_funname): New parameter funcp.  Remove the
	function declaration comment.

gdb/testsuite/
	Fix printing parameters of inlined functions.
	* gdb.dwarf2/dw2-inline-param.exp: New file.
	* gdb.dwarf2/dw2-inline-param-main.c: New file.
	* gdb.dwarf2/dw2-inline-param.S: New file.
@
text
@d1494 20
a1513 2
    return value_struct_elt (&arr, NULL, "P_BOUNDS", NULL,
                             _("Bad GNAT array descriptor"));
d1560 1
a1560 1
	return TYPE_TARGET_TYPE (data_type);
d7657 9
a7665 1
      return (type1 == NULL) ? type : type1;
@


1.267
log
@Rename cplus_specific mangled_lang.

2010-07-16  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h: Renamed cplus_specific to mangled_lang.
	* symtab.c (symbol_init_language_specific): Updated.
	(symbol_set_names): Updated.
	(symbol_natural_name): Updated.
	(symbol_demangled_name): Updated.
	* ada-lang.c (ada_decode_symbol): Updated.
	* dwarf2read.c (new_symbol): Updated.
@
text
@d10328 1
a10328 1
  find_frame_funname (frame, &func_name, &func_lang);
d10396 1
a10396 1
      find_frame_funname (fi, &func_name, &func_lang);
@


1.266
log
@2010-06-04  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c (ada_operator_length): Constify `struct expression'.
	* parse.c (operator_length): Likewise.
	(operator_length_standard): Likewise.
	* parser-defs.h (operator_length): Likewise.
	(operator_length_standard): Likewise.
	(struct exp_descriptor <operator_length>): Likewise.
@
text
@d1213 1
a1213 1
    (char **) &gsymbol->language_specific.cplus_specific.demangled_name;
@


1.265
log
@Cache the TSD type in inferior-data (performance).

This is something I noticed while looking at ada_find_any_type.
Use of that function is expensive, since it causes a global lookup.
Reviewing some of the uses, I found that we were calling it to get
a specific type everytime we print a tagged type (the equivalent of
classes in C++); and not only that, we did it 4 times [1]!

Since the type in question (ada__tags__type_specific_data) is guarantied
to remain the same througout the entire life of the inferior, the solution
was to cache that type in inferior private data.  This patch creates
an ada-land private-data area, and uses it to store that type after
the first time we look it up.

[1]: The problem is mitigated in AdaCore's tree because we use an Ada
     symbol cache which we are thinking of contributing to the FSF tree.
     But that's still pretty bad, regardless.

2010-05-27  Joel Brobecker  <brobecker@@adacore.com>

        * ada-lang.c (ada_inferior_data): New struct.
        (ada_inferior_data): New static global.
        (ada_inferior_data_cleanup, get_ada_inferior_data, ada_inferior_exit)
        (ada_get_tsd_type): New functions.
        (ada_tag_name_2): Use ada_get_tsd_type instead of ada_find_any_type
        to look the tsd type up.
        (_initialize_ada_language): Attach ada_inferior_exit to inferior_exit
        event.  Set ada_inferior_data.
@
text
@d11087 2
a11088 1
ada_operator_length (struct expression *exp, int pc, int *oplenp, int *argsp)
@


1.264
log
@Replace call to value_contents_raw by call to value_contents.

This is something that Tom spotted.  It shouldn't make much of a difference
in practice with the current code, but Tom is planning on making some
changes (bitwise optimized-out tracking) in value_contents...

2010-05-27  Joel Brobecker  <brobecker@@adacore.com>

        * ada-lang.c (ensure_lval): Replace call to value_contents_raw
        by call to value_contents.
@
text
@d308 60
d5630 12
d5656 1
a5656 1
  info_type = ada_find_any_type ("ada__tags__type_specific_data");
d5678 1
a5678 1
 * a C string.  */
d11639 5
@


1.263
log
@2010-05-18  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: White space.
	* ada-typeprint.c: White space.
	* ada-valprint.c: White space.
	* addrmap.c: White space.
	* auxv.c: White space.
	* ax-gdb.c: White space.
@
text
@d3887 1
a3887 1
      write_memory (value_address (val), value_contents_raw (val), len);
@


1.262
log
@Avoid global lookup when decoding XA type.

This patch enhances GDB to take advantage of a recent change in the GNAT
encoding regarding XA types.  A detailed description of the logic has
been added at the start of ada_fixup_array_indexes_type to give the
context behind this enhancement.

2010-05-17  Joel Brobecker  <brobecker@@adacore.com>

        * ada-lang.c (to_fixed_range_type): The the raw index type as
        argument instead of the raw type name.  Remove orig_type parameter.
        Update calls throughout.
        (ada_fixup_array_indexes_type): New function.
        (ada_array_bound_from_type): Add call to ada_fixup_array_indexes_type.
        * ada-lang.h (ada_fixup_array_indexes_type): Add declaration.
        * ada-typeprint.c (print_range_type): Renames print_range_type_named.
        Remove name parameter.
        (print_array_type): Add call to ada_fixup_array_indexes_type.
        Update calls to print_range_type.
        (ada_print_type): Update calls to print_range_type.
@
text
@d380 1
d426 1
d441 1
d512 1
a513 1

d537 1
d553 1
d789 1
d820 1
d977 1
d1154 1
d1158 1
d1162 1
d1174 1
d1207 1
d1331 1
d1339 1
d1354 1
d1410 1
d1495 1
d1712 1
a1713 1

d1739 1
d1760 1
d2116 1
d2193 1
d2246 1
d2454 1
d2467 1
d2675 1
d3160 2
a3161 1
          struct type *ftype = ada_check_typedef (TYPE_FIELD_TYPE (func_type, i));
d3269 1
d3278 1
d3299 1
d3364 1
d3498 1
d3918 1
d3927 1
d4116 1
d4244 1
d4480 1
d4529 1
d4594 1
d4947 1
d4989 1
d5018 1
d5260 1
d5475 1
d5508 1
d5526 1
d5554 1
d5612 1
d5658 1
d5674 1
d5690 1
d5706 1
d5718 1
d5838 1
d5848 1
d5941 1
d5989 1
d6006 1
a6007 1

d6024 1
d6033 2
a6034 1
          struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type, i));
d6043 1
d6090 1
d6297 2
a6298 1
          struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type, i));
d6359 1
d6444 1
d6457 1
d6605 1
d6760 1
d6775 1
d6806 1
d7144 1
d7282 1
d7333 1
d7388 1
d7403 1
d7529 1
d7566 1
d7582 1
d7679 1
d7878 1
d7931 1
d7936 1
d7975 1
d7987 1
d7998 1
d8117 1
d8149 1
d8154 1
d8199 1
d8318 1
d8337 1
d8365 1
d8390 1
d8394 1
d8411 1
d8416 1
d8756 1
d9124 1
d9181 1
d9282 1
d9337 1
d9420 1
a9421 1

d9520 1
d9583 1
d9665 1
d9885 1
d9925 1
d9944 1
d11124 1
d11186 1
d11273 1
d11395 1
@


1.261
log
@        * ada-lang.c (assign_aggregate): Remove unused variable.
@
text
@d168 1
a168 2
static struct type *to_fixed_range_type (char *, struct value *,
                                         struct type *);
d1206 55
d2587 1
d2589 2
a2590 2
    index_type = to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, n - 1),
				      NULL, TYPE_INDEX_TYPE (elt_type));
d7208 1
d7261 1
a7261 2
            to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, i),
                                 dval, TYPE_INDEX_TYPE (elt_type0));
d9240 1
a9240 1
              range_type = to_fixed_range_type (name, NULL, type_arg);
d9762 1
a9762 1
to_fixed_range_type (char *name, struct value *dval, struct type *orig_type)
d9764 1
a9764 1
  struct type *raw_type = ada_find_any_type (name);
d9768 2
a9769 3
  /* Fall back to the original type if symbol lookup failed.  */
  if (raw_type == NULL)
    raw_type = orig_type;
d9776 1
d9785 1
a9785 1
	return create_range_type (alloc_type_copy (orig_type), raw_type,
d9848 1
a9848 1
      type = create_range_type (alloc_type_copy (orig_type), base_type, L, U);
@


1.260
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c (add_defn_to_vec): Delete unused variable.
	(decode_constrained_packed_array_type): Delete unused variable.
	(add_defn_to_vec): Delete unused variable.
	(symbol_completion_match): Delete unused variable.
	(value_tag_from_contents_and_address): Delete unused variable.
	(ada_evaluate_subexp): Delete unused variable.
	* c-lang.c (classify_type): Delete unused variable.
	* f-lang.c (f_printstr): Delete unused variable.
	* objc-lang.c (objc_printstr): Delete unused variable.
	* ada-tasks.c (get_known_tasks_addr): Delete unused variable.
	* jv-lang.c (type_from_class): ifdef unused variable.
	(java_class_name_from_physname): Delete unused variable.
	* m2-lang.c (m2_printstr): Delete unused variable.
@
text
@a8051 1
  struct value *mark = value_mark ();
@


1.259
log
@Remove unused MAX_OF*/MIN_OF* macros.

FWIW: They can no longer work either, as they depend on other macros
which have been missing for quite a while.

ChangeLog:

        * gdbtypes.h (MAX_OF_TYPE, MIN_OF_TYPE): Delete macros.
        * ada-lang.c: Remove comment mentioning these macros.
        * m2-exp.y: Delete commented out code.
@
text
@a1825 2
  struct symbol *sym;
  struct block **blocks;
a1830 1
  int i, n;
a4049 1
  size_t tmp;
a5016 1
  char *result;
d5407 1
a5407 1
  int tag_byte_offset, dummy1, dummy2;
d8573 1
a8573 1
  int tem, tem2, tem3;
@


1.258
log
@gdb/
	* ada-lang.c (lim_warning): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* amd64-tdep.c (amd64_insn_length_fprintf): Likewise.
	* cli-out.c (cli_field_fmt): New ATTRIBUTE_PRINTF.
	(cli_message, out_field_fmt): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* complaints.c (find_complaint): New ATTRIBUTE_PRINTF.
	(vcomplaint): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* complaints.h (complaint, internal_complaint): Likewise.
	* defs.h: Change ATTR_FORMAT to ATTRIBUTE_PRINTF in the top comment.
	(ATTR_FORMAT): Remove.
	(query, nquery, yquery, vprintf_filtered, vfprintf_filtered)
	(fprintf_filtered, fprintfi_filtered, printf_filtered, printfi_filtered)
	(vprintf_unfiltered, vfprintf_unfiltered, fprintf_unfiltered)
	(printf_unfiltered, xasprintf, xvasprintf, xstrprintf, xstrvprintf)
	(xsnprintf, verror, error, vfatal, fatal, internal_verror)
	(internal_error, internal_vwarning, internal_warning, warning)
	(vwarning): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* disasm.c (fprintf_disasm): Likewise.
	* exceptions.c (throw_it): Likewise.
	* exceptions.h (exception_fprintf, throw_verror, throw_vfatal)
	(throw_error): Likewise.
	* language.h (type_error, range_error): Likewise.
	* linespec.c (cplusplus_error): Likewise.
	* mi/mi-interp.c (mi_interp_query_hook): Likewise.
	* mi/mi-out.c (mi_field_fmt, mi_message): Likewise.
	* monitor.c (monitor_debug): Likewise.
	* parser-defs.h (parser_fprintf): Likewise.
	* serial.h (serial_printf): Likewise.
	* tui/tui-hooks.c (tui_query_hook): Likewise.
	* ui-out.c (default_field_fmt, default_message, uo_field_fmt)
	(uo_message): Likewise.
	* ui-out.h (ui_out_field_fmt, ui_out_message): Likewise.
	* utils.c (vfprintf_maybe_filtered, internal_vproblem, defaulted_query):
	Likewise.
	* xml-support.h (gdb_xml_debug, gdb_xml_error): Likewise.
@
text
@a529 5

/* Note: would have used MAX_OF_TYPE and MIN_OF_TYPE macros from
   gdbtypes.h, but some of the necessary definitions in that file
   seem to have gone missing. */

@


1.257
log
@gdb/
	Fix crashes on dangling display expressions.
	* ada-lang.c (ada_operator_check): New function.
	(ada_exp_descriptor): Fill-in the field operator_check.
	* c-lang.c (exp_descriptor_c): Fill-in the field operator_check.
	* jv-lang.c (exp_descriptor_java): Likewise.
	* m2-lang.c (exp_descriptor_modula2): Likewise.
	* scm-lang.c (exp_descriptor_scm): Likewise.
	* parse.c (exp_descriptor_standard): Likewise.
	(operator_check_standard): New function.
	(exp_iterate, exp_uses_objfile_iter, exp_uses_objfile): New functions.
	* parser-defs.h (struct exp_descriptor): New field operator_check.
	(operator_check_standard, exp_uses_objfile): New declarations.
	* printcmd.c: Remove the inclusion of solib.h.
	(display_uses_solib_p): Remove the function.
	(clear_dangling_display_expressions): Call lookup_objfile_from_block
	and exp_uses_objfile instead of display_uses_solib_p.
	* solist.h (struct so_list) <objfile>: New comment.
	* symtab.c (lookup_objfile_from_block): Remove the static qualifier.
	* symtab.h (lookup_objfile_from_block): New declaration.
	(struct general_symbol_info) <obj_section>: Extend the comment.

gdb/testsuite/
	Fix crashes on dangling display expressions.
	* gdb.base/solib-display.exp: Call gdb_gnu_strip_debug if LIBSEPDEBUG
	is SEP.
	(lib_flags): Remove the "debug" keyword.
	(libsepdebug): New variable for iterating new loop.
	(save_pf_prefix): New variable wrapping the loop.
	(sep_lib_flags): New variable derived from LIB_FLAGS.  Use it.
	* lib/gdb.exp (gdb_gnu_strip_debug): Document the return code.
@
text
@d504 1
a504 1
static void lim_warning (const char *format, ...) ATTR_FORMAT (printf, 1, 2);
@


1.256
log
@[AVR] inferior call of subprogram with pointer as argument

On AVR, the gdb view of an address is different from the machine view of the
same address.  We need to use special machinery implemented by value_pointer
to take the pointer of a value.

For instance, considering the following function...

  procedure Trace (Unit    : T; Message : String);

... where T is an access Integer (a pointer to an integer), call to this
function currently triggers the following warnings:

    (gdb) call debug.trace (me, "You")
    warning: Value does not fit in 16 bits.
    warning: Value does not fit in 16 bits.
    Tracing message: You

It could have been worse if Trace actually tried to dereference the Unit
argument...

gdb/ChangeLog (from Tristan Gingold):

	* ada-lang.c (value_pointer): New function.
	(make_array_descriptor): Call value_pointer to convert addresses to
	pointers.

Tested on avr and x86_64-linux.
@
text
@d10890 30
d11308 1
@


1.255
log
@"unsupported language" error in info types when using Ada.

This implements a rudimentary version of the la_print_typedef method
for Ada.  Ada usually does not use typedefs, but there is one exception:
pointers to unconstrained arrays.  Without this patch, we sometimes
get an error in the "info types" output:

    (gdb) info types new_integer_type
    All types matching regular expression "new_integer_type":

    File foo.adb:
    Language not supported.

For now, we treat the typedef as if it did not exist - using the
underlying type instead.  This is the right thing to do for most cases,
the only exception being access to array types.  Since we already have
a general issue in handling these pointers (we confuse them with fat
pointers), we will enhance ada_print_typedef to handle these pointers
at the same time we address the general issue.

gdb/ChangeLog:

        * ada-typeprint.c (ada_print_typedef): New function.
        * ada-lang.h (ada_print_typedef): Add declaration.
        * ada-lang.c (ada_language_defn): set la_print_typdef field
        to ada_print_typedef.

gdb/testsuite/ChangeLog:

        * info_types.c, info_types.exp: New files.

Tested on x86_64-linux.
@
text
@d3866 19
d3920 2
a3921 1
                        value_address (ensure_lval (arr, gdbarch, sp)),
d3927 2
a3928 1
                        value_address (bounds),
@


1.254
log
@Wrong value printed by info locals for dynamic object.

The problem is printing the wrong value for dynamic local variables
when using the "info locals" command. Consider the following code:

   procedure Print (I1 : Positive; I2 : Positive) is
      type My_String is array (I1 .. I2) of Character;
      I : My_String := (others => 'A');
      S : String (1 .. I2 + 3) := (others => ' ');
   begin
      S (I1 .. I2) := String (I); --  BREAK
      Put_Line (S);
   end Print;

After the debugger stopped at BREAK, we try printing all local variables.
Here is what we get:

        (gdb) info locals
        i = "["00"]["00"]"
        s = "["00"]["00"]["00"]["00"]["00"]["00"]["00"]["00"]"

Curiously, printing their value using the "print" command works:

        (gdb) print i
        $1 = "AA"
        (gdb) print s
        $2 = "        "

We traced the problem to trying to get the contents of a variable
(call to value_contents) before "fix'ing" it.  For those not familiar
with the Ada language support, "fixing" a value consists of swapping
the value's dynamic type with a static version that is appropriate
for our actual value.  As a result, the dynamic type was used to
determine the value size, which is zero, and thus the value contents
was empty.

gdb/ChangeLog:

        * valprint.c (common_val_print): Fix the value before extracting
        its contents.
        * ada-lang.c (ada_to_fixed_value): Make this function extern.
        * ada-lang.h (ada_to_fixed_value): New function declaration.
        * ada-valprint.c (ada_value_print): Use ada_to_fixed_value
        to avoid code duplication and fix a bug in the handling of
        fixed types contents.

gdb/testsuite/ChangeLog:

        * gdb.ada/dyn_loc: New testcase.
@
text
@d11279 1
a11279 1
  default_print_typedef,	/* Print a typedef using appropriate syntax */
@


1.253
log
@	* ada-lang.c (print_recreate_exception)
	<ex_catch_exception_unhandled>: It's "catch exception unhandled",
	not "catch unhandled".
@
text
@a228 2
static struct value *ada_to_fixed_value (struct value *);

d7450 1
a7450 1
static struct value *
@


1.252
log
@	PR breakpoints/8554.

	Implement `save-breakpoints'.

	gdb/
	* breakpoint.c (save_cmdlist): New.
	(breakpoint_set_cmdlist, breakpoint_show_cmdlist): Moved up close
	to save_cmdlist.
	(print_recreate_catch_fork): New.
	(catch_fork_breakpoint_ops): Install it.
	(print_recreate_catch_vfork): New.
	(catch_vfork_breakpoint_ops): Install it.
	(print_recreate_catch_syscall): New.
	(catch_syscall_breakpoint_ops): Install it.
	(print_recreate_catch_exec): New.
	(catch_exec_breakpoint_ops): Install it.
	(print_recreate_exception_catchpoint): New.
	(gnu_v3_exception_catchpoint_ops): Install it.
	(save_breakpoints): New, based on tracepoint_save_command, but
	handle all breakpoint types.
	(save_breakpoints_command): New.
	(tracepoint_save_command): Rename to...
	(save_tracepoints_command): ... this, and reimplement using
	save_breakpoints.
	(save_command): New.
	(_initialize_breakpoints): Install the "save" command prefix.
	Install the "save breakpoints" command.  Make "save-tracepoints" a
	deprecated alias for "save tracepoints".
	* breakpoint.h (struct breakpoint_ops): New field `print_recreate'.
	* ada-lang.c (print_recreate_exception): New.
	(print_recreate_catch_exception): New.
	(catch_exception_breakpoint_ops): Install it.
	(print_recreate_catch_exception_unhandled): New.
	(catch_exception_unhandled_breakpoint_ops): Install it.
	(print_recreate_catch_assert): New.
	(catch_assert_breakpoint_ops): Install it.

	* NEWS: Mention the new `save breakpoints' command.  Mention the
	new `save tracepoints' alias and that `save-tracepoints' is now
	deprecated.

	gdb/doc/
	* gdb.texinfo (Save Breakpoints): New node.
	(save-tracepoints): Rename to ...
	(save tracepoints): ... this.  Mention that `save-tracepoints' is
	a deprecated alias to `save tracepoints'.

	gdb/testsuite/
	* gdb.trace/save-trace.exp: Adjust.
@
text
@d10367 1
a10367 1
	fprintf_filtered (fp, "catch unhandled");
@


1.251
log
@2010-04-06  Stan Shebs  <stan@@codesourcery.com>

	* defs.h (char_ptr): Move typedef here from...
	* ada-lang.c (char_ptr): Remove.
	* charset.c (char_ptr): Remove.
	* tracepoint.h (struct uploaded_string): Remove.
	(struct uploaded_tp): Use vectors for string arrays.
	* tracepoint.c (trace_save): Use vectors of actions.
	(parse_tracepoint_definition): Ditto.
	(get_uploaded_tp): Clear vectors.
	* breakpoint.c (create_tracepoint_from_upload): Use vectors.
	(next_cmd): Change to an int.
	(read_next_cmd): Use vector of command strings.
@
text
@d10351 28
d10399 6
d10412 2
a10413 1
  print_mention_catch_exception
d10437 7
d10450 2
a10451 1
  print_mention_catch_exception_unhandled
d10474 6
d10486 2
a10487 1
  print_mention_catch_assert
@


1.250
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@a5078 1
typedef char *char_ptr;
@


1.249
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d61 2
a123 4
static struct partial_symbol *ada_lookup_partial_symbol (struct partial_symtab
                                                         *, const char *, int,
                                                         domain_enum, int);

d639 1
a639 3
   (the main program is in Ada iif the adainit symbol is found).

   MAIN_PST is not used.  */
d642 1
a642 2
ada_update_initial_language (enum language lang,
                             struct partial_symtab *main_pst)
a4093 137
/* Look, in partial_symtab PST, for symbol NAME in given namespace.
   Check the global symbols if GLOBAL, the static symbols if not.
   Do wild-card match if WILD.  */

static struct partial_symbol *
ada_lookup_partial_symbol (struct partial_symtab *pst, const char *name,
                           int global, domain_enum namespace, int wild)
{
  struct partial_symbol **start;
  int name_len = strlen (name);
  int length = (global ? pst->n_global_syms : pst->n_static_syms);
  int i;

  if (length == 0)
    {
      return (NULL);
    }

  start = (global ?
           pst->objfile->global_psymbols.list + pst->globals_offset :
           pst->objfile->static_psymbols.list + pst->statics_offset);

  if (wild)
    {
      for (i = 0; i < length; i += 1)
        {
          struct partial_symbol *psym = start[i];

          if (symbol_matches_domain (SYMBOL_LANGUAGE (psym),
                                     SYMBOL_DOMAIN (psym), namespace)
              && wild_match (name, name_len, SYMBOL_LINKAGE_NAME (psym)))
            return psym;
        }
      return NULL;
    }
  else
    {
      if (global)
        {
          int U;
          i = 0;
          U = length - 1;
          while (U - i > 4)
            {
              int M = (U + i) >> 1;
              struct partial_symbol *psym = start[M];
              if (SYMBOL_LINKAGE_NAME (psym)[0] < name[0])
                i = M + 1;
              else if (SYMBOL_LINKAGE_NAME (psym)[0] > name[0])
                U = M - 1;
              else if (strcmp (SYMBOL_LINKAGE_NAME (psym), name) < 0)
                i = M + 1;
              else
                U = M;
            }
        }
      else
        i = 0;

      while (i < length)
        {
          struct partial_symbol *psym = start[i];

          if (symbol_matches_domain (SYMBOL_LANGUAGE (psym),
                                     SYMBOL_DOMAIN (psym), namespace))
            {
              int cmp = strncmp (name, SYMBOL_LINKAGE_NAME (psym), name_len);

              if (cmp < 0)
                {
                  if (global)
                    break;
                }
              else if (cmp == 0
                       && is_name_suffix (SYMBOL_LINKAGE_NAME (psym)
                                          + name_len))
                return psym;
            }
          i += 1;
        }

      if (global)
        {
          int U;
          i = 0;
          U = length - 1;
          while (U - i > 4)
            {
              int M = (U + i) >> 1;
              struct partial_symbol *psym = start[M];
              if (SYMBOL_LINKAGE_NAME (psym)[0] < '_')
                i = M + 1;
              else if (SYMBOL_LINKAGE_NAME (psym)[0] > '_')
                U = M - 1;
              else if (strcmp (SYMBOL_LINKAGE_NAME (psym), "_ada_") < 0)
                i = M + 1;
              else
                U = M;
            }
        }
      else
        i = 0;

      while (i < length)
        {
          struct partial_symbol *psym = start[i];

          if (symbol_matches_domain (SYMBOL_LANGUAGE (psym),
                                     SYMBOL_DOMAIN (psym), namespace))
            {
              int cmp;

              cmp = (int) '_' - (int) SYMBOL_LINKAGE_NAME (psym)[0];
              if (cmp == 0)
                {
                  cmp = strncmp ("_ada_", SYMBOL_LINKAGE_NAME (psym), 5);
                  if (cmp == 0)
                    cmp = strncmp (name, SYMBOL_LINKAGE_NAME (psym) + 5,
                                   name_len);
                }

              if (cmp < 0)
                {
                  if (global)
                    break;
                }
              else if (cmp == 0
                       && is_name_suffix (SYMBOL_LINKAGE_NAME (psym)
                                          + name_len + 5))
                return psym;
            }
          i += 1;
        }
    }
  return NULL;
}

d4472 24
d4503 1
a4503 1
                           int wild_match)
d4506 1
a4506 1
  struct partial_symtab *ps;
d4508 7
a4514 1
  ALL_PSYMTABS (objfile, ps)
d4516 5
a4520 13
    QUIT;
    if (ps->readin
        || ada_lookup_partial_symbol (ps, name, global, domain, wild_match))
      {
        struct symtab *s = PSYMTAB_TO_SYMTAB (ps);
        const int block_kind = global ? GLOBAL_BLOCK : STATIC_BLOCK;

        if (s == NULL || !s->primary)
          continue;
        ada_add_block_symbols (obstackp,
                               BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), block_kind),
                               name, domain, objfile, wild_match);
      }
d5137 23
a5173 1
  struct partial_symtab *ps;
a5204 1
  ALL_PSYMTABS (objfile, ps)
d5206 1
a5206 16
    struct partial_symbol **psym;

    /* If the psymtab's been read in we'll get it when we search
       through the blockvector.  */
    if (ps->readin)
      continue;

    for (psym = objfile->global_psymbols.list + ps->globals_offset;
         psym < (objfile->global_psymbols.list + ps->globals_offset
                 + ps->n_global_syms); psym++)
      {
        QUIT;
        symbol_completion_add (&completions, SYMBOL_LINKAGE_NAME (*psym),
                               text, text_len, text0, word,
                               wild_match, encoded);
      }
d5208 8
a5215 9
    for (psym = objfile->static_psymbols.list + ps->statics_offset;
         psym < (objfile->static_psymbols.list + ps->statics_offset
                 + ps->n_static_syms); psym++)
      {
        QUIT;
        symbol_completion_add (&completions, SYMBOL_LINKAGE_NAME (*psym),
                               text, text_len, text0, word,
                               wild_match, encoded);
      }
d10008 1
a10008 1
  if (ada_update_initial_language (language_unknown, NULL) != language_ada)
@


1.248
log
@Wrong type description for tagged type parameter.

        * ada-lang.c (ada_evaluate_subexp) [OP_VAR_VALUE]: When noside is
        EVAL_AVOID_SIDE_EFFECTS, also handle the case when type is a
        reference to a tagged type.
@
text
@a4783 1
                            const char *linkage_name,
d4787 1
a4787 4
  if (linkage_name == NULL)
    linkage_name = name;
  return ada_lookup_symbol (linkage_name, block_static_block (block), domain,
                            NULL);
@


1.247
log
@Get rid of ada-lang.c:function_name_from_pc.

        * ada-lang.c: Add "stack.h" #include.
        (function_name_from_pc): Delete.
        (is_known_support_routine): Replace call to function_name_from_pc
        by call to find_frame_funname.
        (ada_unhandled_exception_name_addr_from_raise): Likewise.
@
text
@d8909 8
a8916 1
          if (ada_is_tagged_type (type, 0))
@


1.246
log
@Delete unused or undefined functions.

        * breakpoint.c (ep_parse_optional_filename): Delete.
        * dcache.c (dcache_write_line): Remove declaration.
        * infrun.c (build_infrun): Remove declaration.
        * tracepoint.c (tracepoint_save_command): Remove declaration.
        * linux-nat.c (init_lwp_list): Delete. No longer used.
        * event-loop.c (check_async_signal_handlers): Delete declaration.
        * infrun.c (init_execution_control_state): Delete.
        (proceed): Update comment to avoid mentioning
        init_execution_control_state.
        * target.c (kill_or_be_killed, nosupport_runtime): Delete.
        * ada-lang.c (ada_to_static_fixed_value): Delete.
        * scm-lang.c (evaluate_subexp_scm): Delete declaration.
        * cp-namespace.c (cp_copy_usings): Delete.
        * xml-syscall.c (xml_number_of_syscalls): Delete.
        * progspace.c (find_program_space_by_num): Delete.
        * inflow.c (handle_sigio): Delete declaration.
        * hppa-tdep.c (hppa_alignof): Delete.
        * mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset)
        (mipsnbsd_core_osabi_sniffer): Delete.
@
text
@d59 1
a10153 15
/* Return the name of the function at PC, NULL if could not find it.
   This function only checks the debugging information, not the symbol
   table.  */

static char *
function_name_from_pc (CORE_ADDR pc)
{
  char *func_name;

  if (!find_pc_partial_function (pc, &func_name, NULL, NULL))
    return NULL;

  return func_name;
}

d10164 1
d10200 1
a10200 1
  func_name = function_name_from_pc (get_frame_address_in_block (frame));
d10265 4
a10268 2
      const char *func_name =
        function_name_from_pc (get_frame_address_in_block (fi));
@


1.245
log
@Use XVS field type instead of doing a parallel lookup.

        * ada-lang.c (ada_get_base_type): Follow the XVS field type
        if it is a reference type instead of doing a type lookup using
        the XVS field name.
@
text
@a7577 16

/* A value representing VAL, but with a standard (static-sized) type
   chosen to approximate the real type of VAL as well as possible, but
   without consulting any runtime values.  For Ada dynamic-sized
   types, therefore, the type of the result is likely to be inaccurate.  */

static struct value *
ada_to_static_fixed_value (struct value *val)
{
  struct type *type =
    to_static_fixed_type (static_unwrap_type (value_type (val)));
  if (type == value_type (val))
    return val;
  else
    return coerce_unspec_val_to_type (val, type);
}
@


1.244
log
@        Trust PAD types instead of using PAD___XVS.
        * ada-lang.c (trust_pad_over_xvs): New static variable.
        (ada_is_aligner_type): If !trust_pad_over_xvs and there is a
        parallel XVS type, follow the XVS type instead of the PAD type.
        (unwrap_value): Make sure that there is no parallel XVE type
        before returning the value as is.
        (set_ada_list, show_ada_list): New static variables.
        (set_ada_command, show_ada_command): New functions.
        (_initialize_ada_language): Add new "set/show ada" prefix commands.
        Add new "set/show ada trust-PAD-over-XVS" setting.
@
text
@d7791 14
a7804 5
  raw_real_type = ada_find_any_type (TYPE_FIELD_NAME (real_type_namer, 0));
  if (raw_real_type == NULL)
    return raw_type;
  else
    return raw_real_type;
@


1.243
log
@"info tasks" broken by typedefs in ATCB type definitions.

        * ada-lang.c (ada_template_to_fixed_record_type_1): Add call to
        ada_check_typedef before retrieving the length of the type for
        regular fields.
@
text
@d7730 10
d7750 1
a7750 4
  /* If we can find a parallel XVS type, then the XVS type should
     be used instead of this type.  And hence, this is not an aligner
     type.  */
  if (ada_find_parallel_type (type, "___XVS") != NULL)
d7928 5
a7932 2
      if (type == raw_real_type)
        return val;
d11386 22
d11413 22
@


1.242
log
@Do not use name-based lookup for unconstrained packed arrays.

        * ada-lang.c (find_parallel_type_by_descriptive_type):
        Limit the fallback to name-based lookups to the case where
        the type is a constrained packed array.
@
text
@d6932 3
a6934 1
          TYPE_FIELD_TYPE (rtype, f) = TYPE_FIELD_TYPE (type, f);
d6941 1
a6941 1
              TYPE_LENGTH (TYPE_FIELD_TYPE (type, f)) * TARGET_CHAR_BIT;
@


1.241
log
@Delete dead function.

        * ada-lang.c (extract_string): Delete.  No longer used.
@
text
@d6690 1
a6690 1
  if (result == NULL && ada_is_packed_array_type (type))
@


1.240
log
@gdb/ChangeLog:

        Add support for DW_AT_GNAT_descriptive_type.
        * gdbtypes.h (enum type_specific_kind): New enum.
        (struct main_type) [type_specific_field]: New component.
        [type_specific]: Add new component "gnat_stuff".
        (struct gnat_aux_type): New type.
        (INIT_CPLUS_SPECIFIC): Also set TYPE_SPECIFIC_FIELD (type).
        (HAVE_CPLUS_STRUCT): Also check TYPE_SPECIFIC_FIELD (type).
        (gnat_aux_default, allocate_gnat_aux_type): Add declaration.
        (INIT_GNAT_SPECIFIC, ALLOCATE_GNAT_AUX_TYPE, HAVE_GNAT_AUX_INFO)
        (TYPE_SPECIFIC_FIELD): New macros.
        (TYPE_CPLUS_SPECIFIC): Return cplus_struct_default if the given
        type does not hold any cplus-specific data.
        (TYPE_RAW_CPLUS_SPECIFIC): New macro.
        (TYPE_GNAT_SPECIFIC, TYPE_DESCRIPTIVE_TYPE): New macros.
        (TYPE_IS_OPAQUE): Use HAVE_CPLUS_STRUCT to check if type has
        cplus-specific data.
        * gdbtypes.c (allocate_cplus_struct_type): Minor stylistic rewrite.
        Set new component TYPE_SPECIFIC_FIELD (type).
        (gnat_aux_default): New constant.
        (allocate_gnat_aux_type): New function.
        (init_type): Add initialization the type-specific stuff for
        TYPE_CODE_FLT and TYPE_CODE_FUNC types.
        (print_gnat_stuff): New function.
        (recursive_dump_type): Use HAVE_CPLUS_STRUCT to check for cplus-
        specific data.  Adjust code that prints the contents of the
        type-specific union using the TYPE_SPECIFIC_FIELD value.
        * dwarf2read.c (dwarf2_attach_fields_to_type): Do not allocate
        the type cplus stuff for Ada types.
        (dwarf2_add_member_fn, dwarf2_attach_fn_fields_to_type):
        Error out if these routines are called with an Ada type.
        (read_structure_type, read_array_type, read_subrange_type):
        Add call to set_descriptive_type.
        (set_die_type): Initialize the gnat-specific data if necessary.
        (need_gnat_info, die_descriptive_type, set_descriptive_type):
        New functions.
        * ada-lang.c (decode_constrained_packed_array_type): Use
        decode_constrained_packed_array_type instead of doing a standard
        lookup to locate a parallel type.
        (find_parallel_type_by_descriptive_type): New function.
        (ada_find_parallel_type_with_name): New function.
        (ada_find_parallel_type): Reimplement using
        ada_find_parallel_type_with_name.
        * ada-valprint.c (print_field_values): Use HAVE_CPLUS_STRUCT
        to check if type has a cplus stuff.
        * linespec.c (total_number_of_methods): Likewise.
        * mdebugread.c (new_type): Likewise.

gdb/testsuite/ChangeLog:

        * gdb.base/maint.exp: Adjust the expected output for the
        "maint print type" test. Use gdb_test_multiple instead of
        gdb_sent/gdb_expect.
@
text
@a67 2
static void extract_string (CORE_ADDR addr, char *buf);

a359 19
/* Read the string located at ADDR from the inferior and store the
   result into BUF.  */

static void
extract_string (CORE_ADDR addr, char *buf)
{
  int char_index = 0;

  /* Loop, reading one byte at a time, until we reach the '\000'
     end-of-string marker.  */
  do
    {
      target_read_memory (addr + char_index * sizeof (char),
                          buf + char_index * sizeof (char), sizeof (char));
      char_index++;
    }
  while (buf[char_index - 1] != '\000');
}

@


1.239
log
@Get rid of support for VAX Floats.

        * ada-lang.h (ada_is_vax_floating_type, ada_vax_float_type_suffix)
        (ada_vax_float_print_function): Delete.
        * ada-lang.c (ada_is_vax_floating_type, ada_vax_float_type_suffix)
        (ada_vax_float_print_function): Delete.
        * ada-typeprint.c (print_vax_floating_point_type): Delete.
        (ada_print_type): Remove support for VAX floats.
        * ada-valprint.c (ada_val_print_1): Remove support for VAX floats.
@
text
@d160 3
d1880 3
a1882 2
  sym = standard_lookup (name, get_selected_block (0), VAR_DOMAIN);
  if (sym == NULL || SYMBOL_TYPE (sym) == NULL)
a1886 1
  shadow_type = SYMBOL_TYPE (sym);
d6672 63
a6734 1
/* Find a parallel type to TYPE whose name is formed by appending
d6740 1
a6740 2
  static char *name;
  static size_t name_len = 0;
a6741 1
  char *typename = ada_type_name (type);
d6748 1
a6748 1
  GROW_VECT (name, name_len, len + strlen (suffix) + 1);
d6753 1
a6753 1
  return ada_find_any_type (name);
a6755 1

@


1.238
log
@* dwarf2read.c (struct attribute): Increase sizes of unsnd and snd
fields to allow larger integer sizes.
(read_subrange_type): Increase size of bound values.
Add logic to determine signedness based on base-type size, signedness.
(read_attribute_value): Change format for bad byte size in message.
(read_8_bytes): Increase size of result type.
(dump_die_shallow): Change format for value.
(dwarf2_get_attr_constant_value): Increase size of return type.
Correct comment.
* gdbtypes.c (create_range_type): Change API to increase size of
bounds. struct field -> union field.
Always take signedness from base type.
(check_typedef): Use new API for TYPE_LOW_BOUND, TYPE_HIGH_BOUND.
(recursive_dump_type, copy_type_recursive): Adjust to new
representation of range types.
* gdbtypes.h (fields_or_bounds): New union containing struct field and
new struct range_bounds, used for range types.
(TYPE_RANGE_DATA): New macro to access range_bounds member.
(TYPE_LOW_BOUND, TYPE_HIGH_BOUND): Represent with new TYPE_RANGE_DATA.
(TYPE_LOW_BOUND_UNDEFINED, TYPE_HIGH_BOUND_UNDEFINED): New macros,
taking over the job of TYPE_FIELD_ARTIFICIAL for range bounds.
(SET_TYPE_LOW_BOUND, SET_TYPE_HIGH_BOUND, SET_TYPE_LOW_BOUND_DEFINED)
(SET_TYPE_HIGH_BOUND_DEFINED): New macros.
(TYPE_FIELDS, TYPE_BASECLASS, TYPE_BASECLASS_NAME, TYPE_FIELD)
(TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED)
(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED, TYPE_ARRAY_UPPER_BOUND_VALUE)
(TYPE_ARRAY_LOWER_BOUND_VALUE):	Adjust to new representation.
(create_range_type): Adjust API.
* ada-lang.c (ada_modulus): Use new extended bound values.
(discrete_type_low_bound): Rename to...
(ada_discrete_type_low_bound): ... and make external.
(discrete_type_high_bound): Rename to...
(ada_discrete_type_high_bound): ... and make external.
(ada_value_slice_from_ptr, ada_array_bound_from_type)
(ada_evaluate_subexp, to_fixed_range_type):
Use ada_discrete_type_low_bound, ada_discrete_type_high_bound.
* ada-typeprint.c (print_range): Use ada_discrete_type_low_bound,
ada_discrete_type_high_bound.  Don't look at field count, which
is no longer meaningful.  Print bounds whenever argument is a range
or enumeration.
* ada-lang.h (ada_discrete_type_low_bound,ada_discrete_type_high_bound):
Declare.
* varobj.c (c_describe_child): Adjust to render larger values.
* mdebugread.c (parse_type): Use proper abstractions for range types:
TYPE_RANGE_DATA, SET_TYPE_LOW_BOUND_DEFINED,
SET_TYPE_HIGH_BOUND_DEFINED.
* p-typeprint.c (pascal_type_print_varspec_prefix): Use larger format
for bounds.
@
text
@a9658 46

                                /* VAX floating formats */

/* Non-zero iff TYPE represents one of the special VAX floating-point
   types.  */

int
ada_is_vax_floating_type (struct type *type)
{
  int name_len =
    (ada_type_name (type) == NULL) ? 0 : strlen (ada_type_name (type));
  return
    name_len > 6
    && (TYPE_CODE (type) == TYPE_CODE_INT
        || TYPE_CODE (type) == TYPE_CODE_RANGE)
    && strncmp (ada_type_name (type) + name_len - 6, "___XF", 5) == 0;
}

/* The type of special VAX floating-point type this is, assuming
   ada_is_vax_floating_point.  */

int
ada_vax_float_type_suffix (struct type *type)
{
  return ada_type_name (type)[strlen (ada_type_name (type)) - 1];
}

/* A value representing the special debugging function that outputs
   VAX floating-point values of the type represented by TYPE.  Assumes
   ada_is_vax_floating_type (TYPE).  */

struct value *
ada_vax_float_print_function (struct type *type)
{
  switch (ada_vax_float_type_suffix (type))
    {
    case 'F':
      return get_var_value ("DEBUG_STRING_F", 0);
    case 'D':
      return get_var_value ("DEBUG_STRING_D", 0);
    case 'G':
      return get_var_value ("DEBUG_STRING_G", 0);
    default:
      error (_("invalid VAX floating-point type"));
    }
}
@


1.237
log
@gdb/ChangeLog:

2009-12-02  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* ada-lang.c (ada_value_assign): Use observer_notify_memory_changed.
	* valops.c (value_assign): Likewise.
	* defs.h (deprecated_memory_changed_hook): Remove.
	* top.c (deprecated_memory_changed_hook): Likewise.
	* interps.c (clear_interpreter_hooks): Adjust.

gdb/gdbtk/ChangeLog:

2009-12-02  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* generic/gdbtk-hooks.c (gdbtk_memory_changed): Adjust.
	(gdbtk_add_hooks): Adjust.

gdb/doc/ChangeLog:

2009-12-02  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* observer.texi: New memory_changed observer.
@
text
@d600 2
a601 2
static LONGEST
discrete_type_high_bound (struct type *type)
d615 1
a615 1
      error (_("Unexpected type in discrete_type_high_bound."));
d620 2
a621 2
static LONGEST
discrete_type_low_bound (struct type *type)
d635 1
a635 1
      error (_("Unexpected type in discrete_type_low_bound."));
d2402 1
a2402 1
    + ((low - TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type)))
a2544 1
  LONGEST retval;
d2571 4
a2574 16
  switch (TYPE_CODE (index_type))
    {
    case TYPE_CODE_RANGE:
      retval = which == 0 ? TYPE_LOW_BOUND (index_type)
			  : TYPE_HIGH_BOUND (index_type);
      break;
    case TYPE_CODE_ENUM:
      retval = which == 0 ? TYPE_FIELD_BITPOS (index_type, 0)
			  : TYPE_FIELD_BITPOS (index_type,
					       TYPE_NFIELDS (index_type) - 1);
      break;
    default:
      internal_error (__FILE__, __LINE__, _("invalid type code of index type"));
    }

  return retval;
d9252 1
a9252 1
		  (range_type, discrete_type_low_bound (range_type));
d9255 1
a9255 1
		  (range_type, discrete_type_high_bound (range_type));
d9829 2
a9830 2
      LONGEST L = discrete_type_low_bound (raw_type);
      LONGEST U = discrete_type_high_bound (raw_type);
d9835 2
a9836 2
				  discrete_type_low_bound (raw_type),
				  discrete_type_high_bound (raw_type));
d9962 1
a9962 14
  ULONGEST modulus;

  /* Normally, the modulus of a modular type is equal to the value of
     its upper bound + 1.  However, the upper bound is currently stored
     as an int, which is not always big enough to hold the actual bound
     value.  To workaround this, try to take advantage of the encoding
     that GNAT uses with with discrete types.  To avoid some unnecessary
     parsing, we do this only when the size of TYPE is greater than
     the size of the field holding the bound.  */
  if (TYPE_LENGTH (type) > sizeof (TYPE_HIGH_BOUND (type))
      && ada_modulus_from_name (type, &modulus))
    return modulus;

  return (ULONGEST) (unsigned int) TYPE_HIGH_BOUND (type) + 1;
@


1.236
log
@        * ada-lang.c: Apply some corrections to the previous comment addition.
@
text
@d2292 2
a2293 3
      if (deprecated_memory_changed_hook)
	deprecated_memory_changed_hook (to_addr, len);
      
@


1.235
log
@        * ada-lang.c: Update the comment explaining how to evaluate
        Ada expressions.
@
text
@d8483 1
a8483 1
    the amount of space actually used by each element changes from element
d8488 2
a8489 2
    The actual amount of memory occupied by each element might change
    from element to element, depending on the their discriminant value.
d8491 1
a8491 1
    constant regardless.  So we simply need to compute that size using
d8515 1
a8515 1
    In some cases, the size of allocated for each element is statically
@


1.234
log
@        * ada-lang.c (discrete_type_p): TYPE_CODE_BOOL is also a discrete type.
@
text
@d8392 3
d8423 3
d8467 18
a8484 4
    Arrays are a little simpler to handle, because the same amount of
    memory is allocated for each element of the array, even if the amount
    of space used by each element changes from element to element.
    Consider for instance the following array of type Rec:
d8488 24
a8511 12
    The type structure in GDB describes an array in terms of its
    bounds, and the type of its elements.  By design, all elements
    in the array have the same type.  So we cannot use a fixed type
    for the array elements in this case, since the fixed type depends
    on the actual value of each element.

    Fortunately, what happens in practice is that each element of
    the array has the same size, which is the maximum size that
    might be needed in order to hold an object of the element type.
    And the compiler shows it in the debugging information by wrapping
    the array element inside a private PAD type.  This type should not
    be shown to the user, and must be "unwrap"'ed before printing. Note
d8515 6
a8520 6
    These wrapper types should have a constant size, which is the size
    of each element of the array.  In the case when the size is statically
    known, the PAD type will already have the right size, and the array
    element type should remain unfixed.  But there are cases when
    this size is not statically known.  For instance, assuming that
    "Five" is an integer variable:
d8543 4
a8546 1
    However, things are slightly different in the case of dynamic
d8562 1
a8562 1
    discriminant. In order to fix the type of variable My_String,
d8590 2
a8591 2
    preceding it.  Let's now imagine that the user is trying to print the
    value of My_Container.  If the type fixing was recursive, we would
d8598 7
a8604 7
    Unfortunately, we need to watch out for dynamic components of variant
    records (identified by the ___XVL suffix in the component name).
    Even if the target type is a PAD type, the size of that type might
    not be statically known.  So the PAD type needs to be unwrapped and
    the resulting type needs to be fixed.  Otherwise, we might end up
    with the wrong size for our component.  This can be observed with
    the following type declarations:
d8618 4
a8621 1
    Lastly, when should the sub-elements of a type that remained unfixed
@


1.233
log
@        * ada-lang.c (packed_array_type): Rename to...
        (constrained_packed_array_type): ...and update comment.
        (decode_packed_array, decode_constrained_packed_array): Ditto.
        (decode_packed_array_type, decode_constrained_packed_array_type):
        Ditto.
        (ada_is_constrained_packed_array_type): New function.
        (ada_is_unconstrained_packed_array_type): New function.
        (decode_packed_array_bitsize): New function, extracted from
        decode_packed_array_type.
        (ada_type_of_array): Add support for unconstrained packed arrays.
        (ada_coerce_to_simple_array_ptr, ada_coerce_to_simple_array)
        (ada_array_bound_from_type, ada_array_bound, ada_array_length)
        (ada_prefer_type, to_fixed_array_type, ada_evaluate_subexp): Resync.
        * ada-lang.h (ada_is_packed_array_type,
        ada_is_constrained_packed_array_type): Renaming.
        * ada-valprint.c (ada_val_print_1): Resync.
        * ada-typeprint.c (print_array_type, ada_print_type): Resync.
@
text
@d3588 1
@


1.232
log
@    Wrong function used to perform address addition/subtraction.
    * ada-lang.c (ada_type_match): Stop making TYPE_CODE_VOID
    a wildcard matching any type.  For types that we don't already
    handle specifically, make sure that both types have the same code.
@
text
@d176 1
a176 1
static struct type *packed_array_type (struct type *, long *);
d178 1
a178 1
static struct type *decode_packed_array_type (struct type *);
d180 7
a186 1
static struct value *decode_packed_array (struct value *);
d1631 2
a1632 2
  if (ada_is_packed_array_type (value_type (arr)))
    return decode_packed_array_type (value_type (arr));
d1638 10
a1647 2
    return
      ada_check_typedef (desc_data_target_type (value_type (arr)));
d1675 4
d1700 2
a1701 2
  else if (ada_is_packed_array_type (value_type (arr)))
    return decode_packed_array (arr);
d1721 2
a1722 2
  else if (ada_is_packed_array_type (value_type (arr)))
    return decode_packed_array (arr);
d1734 2
a1735 2
  if (ada_is_packed_array_type (type))
    return decode_packed_array_type (type);
d1745 2
a1746 2
int
ada_is_packed_array_type (struct type *type)
d1757 48
d1815 1
a1815 1
packed_array_type (struct type *type, long *elt_bits)
d1826 3
a1828 2
  new_elt_type = packed_array_type (ada_check_typedef (TYPE_TARGET_TYPE (type)),
                                    elt_bits);
d1849 2
a1850 1
/* The array type encoded by TYPE, where ada_is_packed_array_type (TYPE).  */
d1853 1
a1853 1
decode_packed_array_type (struct type *type)
d1892 2
a1893 8
  if (sscanf (tail + sizeof ("___XP") - 1, "%ld", &bits) != 1)
    {
      lim_warning
	(_("could not understand bit size information on packed array"));
      return NULL;
    }

  return packed_array_type (shadow_type, &bits);
d1896 2
a1897 2
/* Given that ARR is a struct value *indicating a GNAT packed array,
   returns a simple array that denotes that array.  Its type is a
d1903 1
a1903 1
decode_packed_array (struct value *arr)
d1918 1
a1918 1
  type = decode_packed_array_type (value_type (arr));
d2551 2
a2552 2
  if (ada_is_packed_array_type (arr_type))
    arr_type = decode_packed_array_type (arr_type);
d2601 2
a2602 2
  if (ada_is_packed_array_type (arr_type))
    return ada_array_bound (decode_packed_array (arr), n, which);
d2620 2
a2621 2
  if (ada_is_packed_array_type (arr_type))
    return ada_array_length (decode_packed_array (arr), n);
d6651 1
a6651 1
  else if (ada_is_packed_array_type (type0))
d7223 1
a7223 1
  int packed_array_p;
d7228 3
a7230 3
  packed_array_p = ada_is_packed_array_type (type0);
  if (packed_array_p)
    type0 = decode_packed_array_type (type0);
d7252 1
a7252 1
      if (elt_type0 == elt_type && !packed_array_p)
d7295 1
a7295 1
  if (packed_array_p)
d8907 2
a8908 1
      if (ada_is_packed_array_type (desc_base_type (value_type (argvec[0]))))
d9021 1
a9021 1
        if (ada_is_packed_array_type (value_type (array)))
d9186 1
a9186 1
            if (ada_is_packed_array_type (value_type (arg1)))
d9241 2
a9242 2
            if (ada_is_packed_array_type (type_arg))
              type_arg = decode_packed_array_type (type_arg);
@


1.231
log
@    * ada-lang.c (ada_decode): Add handling of "TB" suffixes for
    task bodies.
@
text
@d2980 1
a2980 2
   a non-pointer.   A type of 'void' (which is never a valid expression type)
   by convention matches anything. */
d2982 1
a2982 1
   liberal.  FIXME: TOO liberal, in fact.  */
a2994 4
  if (TYPE_CODE (ftype) == TYPE_CODE_VOID
      || TYPE_CODE (atype) == TYPE_CODE_VOID)
    return 1;

d2998 1
a2998 1
      return 1;
@


1.230
log
@    * ada-lang.c (ada_remove_Xbn_suffix): New function.
    (find_old_style_renaming_symbol): Add handling for function suffixes
    present in the name of various procedures.
    Do not overwrite the function symbol's name.
@
text
@d949 7
@


1.229
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d873 20
d6534 1
a6534 1
      const int function_name_len = ada_name_prefix_len (function_name);
d6539 3
a6541 1
      function_name[function_name_len] = '\0';
d6549 4
a6552 1
        function_name = function_name + 5;
d6555 3
a6557 2
      xsnprintf (rename, rename_len * sizeof (char), "%s__%s___XR", 
		 function_name, name);
@


1.228
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d7925 2
a7926 1
                          TYPE_LENGTH (value_type (val)), v);
@


1.227
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d10304 1
a10304 1
      ui_out_field_core_addr (uiout, "addr", b->loc->address);
@


1.226
log
@	* gdbtypes.c (make_pointer_type, make_reference_type,
	smash_to_memberptr_type, lookup_array_range_type, check_stub_method):
	Use type architecture instead of current_gdbarch.

	* gdbtypes.h (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH paramter.
	* gdbtypes.c (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH parameter.   Use it instead of current_gdbarch.
	* c-typeprint.c (c_type_print_modifier): Update call.
	* parse.c (push_type_address_space): Likewise.

	* findvar.c (extract_typed_address, store_typed_address): Use type
	architecture instead of current_gdbarch.

	* value.c (value_as_address, unpack_field_as_long): Use type architecture
	instead of current_gdbarch.

	* doublest.c (floatformat_from_length): Add GDBARCH argument.  Use it
	instead of current_gdbarch.
	(floatformat_from_type): Pass type architecture.

	* infcall.c (find_function_addr): Use type architecture instead
	of current_gdbarch.

	* valarith.c (value_bitstring_subscript, value_x_binop, value_neg,
	value_bit_index): Use type architecture instead of current_gdbarch.
	* valops.c (value_cast, value_slice): Likewise.

	* value.h (modify_field): Add TYPE argument.
	* value.c (modify_field): Add TYPE argument.  Use type architecture
	instead of current_gdbarch.
	(set_internalvar_component): Likewise.
	* eval.c (evaluate_struct_tuple): Update call.
	* valops.c (value_assign): Likewise.
	* ada-lang.c (modify_general_field): Likewise.  Add TYPE argument.
	(make_array_descriptor): Update calls.
	(move_bits): Add BITS_BIG_ENDIAN_P argument.  Use it instead of
	current_gdbarch.
	(ada_value_assign, value_assign_to_component): Update calls.
	(decode_packed_array, ada_value_primitive_packed_val, ada_value_assign,
	value_assign_to_component): Use type arch instead of current_gdbarch.

	* printcmd.c (float_type_from_length): Remove GDBARCH argument,
	use type architecture instead.
	(print_scalar_formatted, printf_command): Update calls.  Use type
	architecture instead of current_gdbarch.
	* valprint.c (val_print_type_code_int): Use type architecture
	instead of current_gdbarch.
	* varobj.c (value_get_print_value): Likewise.
	* python/python-prettyprint.c (print_string_repr): Add GDBARCH
	argument.  Use it instead of current_gdbarch.
	(apply_val_pretty_printer): Update call.

	* ada-valprint.c (ada_val_print_1): Use type architecture instead
	of current_gdbarch.
	* c-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(c_val_print): Update calls passing type architecture.
	* f-valprint.c (f_val_print): Use type architecture instead of
	current_gdbarch.
	* jv-valprint (java_value_print): Likewise.
	* m2-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(print_unpacked_pointer): Update calls passing type architecture.
	* scm-valprint.c (scm_scmval_print): Use type architecture instead of
	current_gdbarch.

	* gnu-v3-abi.c (get_class_arch): Remove.
	(gnuv3_rtti_type): Use get_type_arch instead of get_class_arch.  Remove
	special-case check for Java classes.
	(gnuv3_virtual_fn_field, gnuv3_baseclass_offset, gnuv3_print_method_ptr,
	gnuv3_method_ptr_size, gnuv3_make_method_ptr, gnuv3_method_ptr_to_value):
	Use get_type_arch instead of get_class_arch.
@
text
@d10296 1
a10296 1
                     struct breakpoint *b, CORE_ADDR *last_addr)
d10308 1
a10308 1
  *last_addr = b->loc->address;
d10380 1
a10380 1
print_one_catch_exception (struct breakpoint *b, CORE_ADDR *last_addr)
d10382 1
a10382 1
  print_one_exception (ex_catch_exception, b, last_addr);
d10410 2
a10411 1
print_one_catch_exception_unhandled (struct breakpoint *b, CORE_ADDR *last_addr)
d10413 1
a10413 1
  print_one_exception (ex_catch_exception_unhandled, b, last_addr);
d10440 1
a10440 1
print_one_catch_assert (struct breakpoint *b, CORE_ADDR *last_addr)
d10442 1
a10442 1
  print_one_exception (ex_catch_assert, b, last_addr);
@


1.225
log
@	* gdbtypes.h (TYPE_OBJFILE_OWNED, TYPE_OWNER): New macros.
	(TYPE_OBJFILE, TYPE_ALLOC, TYPE_ZALLOC): Reimplement.
	(alloc_type_arch): Add prototype.
	(alloc_type_copy): Likewise.
	(get_type_arch): Likewise.
	(arch_type): Likewise.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.

	* gdbtypes.c (alloc_type): No longer support NULL objfile.
	(init_type): Likewise.
	(alloc_type_arch): New function.
	(alloc_type_copy): New function.
	(get_type_arch): New function.

	(smash_type): Preserve type ownership information.
	(make_pointer_type, make_reference_type, make_function_type,
	smash_to_memberptr_type, smash_to_method_type): No longer
	preserve OBJFILE across smash_type calls.
	(make_pointer_type, make_reference_type, make_function_type,
	lookup_memberptr_type, lookup_methodptr_type, allocate_stub_method,
	create_range_type, create_array_type, create_set_type, copy_type):
	Use alloc_type_copy when allocating types.
	(check_typedef): Use alloc_type_arch.
	(copy_type_recursive): Likewise.  Preserve type ownership data
	after copying type.
	(recursive_dump_type): Dump type ownership data.
	(alloc_type_instance): Update type ownership check.
	(copy_type, copy_type_recursive): Likewise.

	(arch_type): New function.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(append_flags_type_flag): Move down.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.
	(append_composite_type_field_aligned,
	append_composite_type_field): Move down.

	* gdbarch.c (gdbtypes_post_init): Allocate all types
	using per-architecture routines.
	* ada-lang.c (ada_language_arch_info): Likewise.
	* f-lang.c (build_fortran_types): Likewise.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* scm-lang.c (build_scm_types): Likewise.

	* ada-lang.c (ada_type_of_array): Use alloc_type_copy.
	(packed_array_type): Likewise.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_variant_branch_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_fixed_range_type): Likewise.
	(empty_record): Use type instead of objfile argument.
	Use alloc_type_copy.
	(to_fixed_variant_branch_type): Update call to empty_record.
	* jv-lang.c (type_from_class): Use alloc_type_arch.

	* arm-tdep.c (arm_ext_type): Allocate per-architecture type.
	* i386-tdep.c (i386_eflags_type, i386_mxcsr_type, i387_ext_type,
	i386_mmx_type, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_ext_type): Likewise.
	* m32c-tdep.c (make_types): Likewise.
	* m68k-tdep.c (m68k_ps_type, m68881_ext_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* sparc-tdep.c (sparc_psr_type, sparc_fsr_type): Likewise.
	* sparc64-tdep.c (sparc64_pstate_type, sparc64_fsr_type,
	sparc64_fprs_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* target-descriptions.c (tdesc_gdb_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
@
text
@d70 1
a70 1
static void modify_general_field (char *, LONGEST, int, int);
d185 1
a185 1
static void move_bits (gdb_byte *, int, const gdb_byte *, int, int);
d1217 2
a1218 1
modify_general_field (char *addr, LONGEST fieldval, int bitpos, int bitsize)
d1220 1
a1220 1
  modify_field (addr + bitpos / 8, fieldval, bitpos % 8, bitsize);
d1836 1
a1836 1
  if (gdbarch_bits_big_endian (current_gdbarch)
d1960 1
a1960 1
  int delta = gdbarch_bits_big_endian (current_gdbarch) ? -1 : 1;
d2009 1
a2009 1
  else if (gdbarch_bits_big_endian (current_gdbarch))
d2095 1
a2095 1
	   int src_offset, int n)
d2104 1
a2104 1
  if (gdbarch_bits_big_endian (current_gdbarch))
d2196 1
a2196 1
      if (gdbarch_bits_big_endian (current_gdbarch))
d2198 1
a2198 1
		   value_contents (fromval), from_size - bits, bits);
d2200 2
a2201 2
        move_bits (buffer, value_bitpos (toval), value_contents (fromval),
                   0, bits);
d2240 1
a2240 1
  if (gdbarch_bits_big_endian (current_gdbarch))
d2245 1
a2245 1
	       bits);
d2249 1
a2249 1
	       value_contents (val), 0, bits);
d3838 2
a3839 1
      modify_general_field (value_contents_writeable (bounds),
d3843 2
a3844 1
      modify_general_field (value_contents_writeable (bounds),
d3852 2
a3853 1
  modify_general_field (value_contents_writeable (descriptor),
d3858 2
a3859 1
  modify_general_field (value_contents_writeable (descriptor),
@


1.224
log
@	* gdbtypes.h (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(init_float_type, init_complex_type): Add prototypes.
	* gdbtypes.c (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(build_flt): Rename to ...
	(init_float_type): ... this.  Make global.
	(build_complex): Rename to ...
	(init_complex_type): ... this.  Make global.  Remove BIT argument.
	(gdbtypes_post_init): Update calls.

	* ada-lang.c (ada_language_arch_info): Use init_float_type.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* f-lang.c (build_fortran_types): Use init_float_type and
	init_complex_type.

	* target-descriptions.c (tdesc_gdb_type): Call init_float_type instead
	of using builtin_type_ieee_single, builtin_type_ieee_double, or
	builtin_type_arm_ext.

	* ia64-tdep.h (struct gdbarch_tdep): Add ia64_ext_type member.
	* ia64-tdep.c (builtin_type_ia64_ext): Remove.
	(_initialize_ia64_tdep): Do not initialize it.
	(floatformat_valid, floatformat_ia64_ext, floatformats_ia64_ext):
	Move up.
	(ia64_ext_type): New function.
	(ia64_register_reggroup_p, ia64_convert_register_p,
	ia64_register_to_value, ia64_value_to_register,
	ia64_extract_return_value, ia64_store_return_value): Use ia64_ext_type
	instead of builtin_type_ia64_ext.

	* i386-tdep.h (struct gdbarch_tdep): Add i387_ext_type member.
	(i387_ext_type): Add prototype.
	* i386-tdep.c (i387_ext_type): New function.
	(i386_extract_return_value, i386_store_return_value,
	i386_register_type): Use it instead of builtin_type_i387_ext.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* i387-tdep.c (print_i387_value, i387_register_to_value,
	i387_value_to_register): Likewise.
	(print_i387_value, print_i387_ext): Add GDBARCH argument.
	(print_i387_ext, i387_print_float_info): Pass to subroutines.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68881_ext_type member.
	* m68k-tdep.c (m68881_ext_type): New function.
	(m68k_register_type, m68k_convert_register_p): Use it instead
	of builtin_type_m68881_ext.

	* arm-tdep.h (struct gdbarch_tdep): Add arm_ext_type member.
	* arm-tdep.c (arm_ext_type): New function.
	(arm_register_type): Use it instead of builtin_type_arm_ext.

	* alpha-tdep.c (alpha_register_type): Use builtin types
	instead of builtin_type_ieee_double.

	* mips-tdep.c (mips_float_register_type, mips_double_register_type):
	Remove.
	(mips_register_type): Use builtin types instead of
	builtin_type_ieee_single and builtin_type_ieee_double.
	(mips_print_fp_register): Use builtin types instead of
	mips_float_register_type and mips_double_register_type.

	* hppa-tdep.c (hppa32_register_type, hppa64_register_type):
	Use builtin types instead of builtin_type_ieee_single and
	builtin_type_ieee_double.
@
text
@a1610 1
      struct objfile *objf = TYPE_OBJFILE (value_type (arr));
d1623 2
a1624 2
          struct type *range_type = alloc_type (objf);
          struct type *array_type = alloc_type (objf);
d1731 1
a1731 1
  new_type = alloc_type (TYPE_OBJFILE (type));
d6667 1
a6667 1
empty_record (struct objfile *objfile)
d6669 1
a6669 1
  struct type *type = alloc_type (objfile);
d6726 1
a6726 1
  rtype = alloc_type (TYPE_OBJFILE (type));
d6936 1
a6936 1
          TYPE_TARGET_TYPE (type0) = type = alloc_type (TYPE_OBJFILE (type0));
d6981 1
a6981 1
  rtype = alloc_type (TYPE_OBJFILE (type));
d7101 1
a7101 1
    return empty_record (TYPE_OBJFILE (var_type));
d7160 1
a7160 1
        result = create_array_type (alloc_type (TYPE_OBJFILE (type0)),
d7192 1
a7192 1
          result = create_array_type (alloc_type (TYPE_OBJFILE (elt_type0)),
d9712 1
a9712 2
	return create_range_type (alloc_type (TYPE_OBJFILE (orig_type)),
				  raw_type,
d9775 1
a9775 2
      type = create_range_type (alloc_type (TYPE_OBJFILE (orig_type)),
				base_type, L, U);
d11160 36
a11195 42
  lai->primitive_type_vector [ada_primitive_type_int] =
    init_type (TYPE_CODE_INT,
	       gdbarch_int_bit (gdbarch) / TARGET_CHAR_BIT,
	       0, "integer", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_long] =
    init_type (TYPE_CODE_INT,
	       gdbarch_long_bit (gdbarch) / TARGET_CHAR_BIT,
	       0, "long_integer", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_short] =
    init_type (TYPE_CODE_INT,
	       gdbarch_short_bit (gdbarch) / TARGET_CHAR_BIT,
	       0, "short_integer", (struct objfile *) NULL);
  lai->string_char_type = 
    lai->primitive_type_vector [ada_primitive_type_char] =
    init_type (TYPE_CODE_INT, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
               0, "character", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_float] =
    init_float_type (gdbarch_float_bit (gdbarch),
		     "float", NULL);
  lai->primitive_type_vector [ada_primitive_type_double] =
    init_float_type (gdbarch_double_bit (gdbarch),
		     "long_float", NULL);
  lai->primitive_type_vector [ada_primitive_type_long_long] =
    init_type (TYPE_CODE_INT, 
	       gdbarch_long_long_bit (gdbarch) / TARGET_CHAR_BIT,
               0, "long_long_integer", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_long_double] =
    init_float_type (gdbarch_double_bit (gdbarch),
		     "long_long_float", NULL);
  lai->primitive_type_vector [ada_primitive_type_natural] =
    init_type (TYPE_CODE_INT,
	       gdbarch_int_bit (gdbarch) / TARGET_CHAR_BIT,
	       0, "natural", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_positive] =
    init_type (TYPE_CODE_INT,
	       gdbarch_int_bit (gdbarch) / TARGET_CHAR_BIT,
	       0, "positive", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_void] = builtin->builtin_void;

  lai->primitive_type_vector [ada_primitive_type_system_address] =
    lookup_pointer_type (init_type (TYPE_CODE_VOID, 1, 0, "void",
                                    (struct objfile *) NULL));
@


1.223
log
@	* ada-lang.c (assign_component): Use platform-specific integer type
	instead of builtin_type_int32 type.
	(ada_evaluate_subexp) [OP_ATR_SIZE]: Likewise.

	* ax-gdb.c (gen_expr) [UNOP_NEG]: Use platform-specific integer type
	instead of builtin_type_int8 type.
	* valarith.c (value_x_unop): Likewise.
	* python/python-value.c (valpy_absolute): Avoid reference to
	builtin_type_int8 type.

	* eval.c (evaluate_subexp_standard): Use platform-specific integer
	type instead of builtin_type_int8 as EVAL_SKIP return value type.
	* ada-lang.c (ada_evaluate_subexp): Likewise.
	* jv-lang.c (evaluate_subexp_java): Likewise.
	* m2-lang.c (evaluate_subexp_modula2): Likewise.
	* scm-lang.c (evaluate_exp): Likewise.

	* value.h (value_bitstring): Add INDEX_TYPE argument.
	* valops.c (value_bitstring): Add INDEX_TYPE argument, use it instead
	of builtin_type_int32 as base range type.
	* eval.c (evaluate_subexp_standard): Update value_bitstring call.
@
text
@d11180 2
a11181 3
    init_type (TYPE_CODE_FLT,
	       gdbarch_float_bit (gdbarch)/ TARGET_CHAR_BIT,
               0, "float", (struct objfile *) NULL);
d11183 2
a11184 3
    init_type (TYPE_CODE_FLT,
	       gdbarch_double_bit (gdbarch) / TARGET_CHAR_BIT,
               0, "long_float", (struct objfile *) NULL);
d11190 2
a11191 3
    init_type (TYPE_CODE_FLT,
	       gdbarch_double_bit (gdbarch) / TARGET_CHAR_BIT,
               0, "long_long_float", (struct objfile *) NULL);
@


1.222
log
@	* ada-lang.h (ada_convert_actual): Add GDBARCH argument.
	* ada-lang.c (convert_actual): Remove stale prototype.
	(ensure_lval, make_array_descriptor, ada_convert_actual):
	Add GDBARCH argument and pass through to subroutine calls.
	(ensure_lval): Use GDBARCH instead of current_gdbarch.
	* infcall.c (value_arg_coerce): Update ada_convert_actual call.
@
text
@d7993 2
a7994 1
      struct value *index_val = value_from_longest (builtin_type_int32, index);
d9239 1
a9239 1
        return value_zero (builtin_type_int32, not_lval);
d9241 1
a9241 1
        return value_from_longest (builtin_type_int32,
d9426 1
a9426 1
  return value_from_longest (builtin_type_int8, (LONGEST) 1);
@


1.221
log
@	* ada-lang.c (resolve): Use per-architecture void type instead
	of platform-independent one.
	(ada_evaluate_subexp) [STRUCTOP_STRUCT]: Likewise.
	(ada_resolve_function): Reimplement fallback logic to avoid
	explicit reference to builtin_type_void.
@
text
@d104 2
a105 4
static struct value *ensure_lval (struct value *, CORE_ADDR *);

static struct value *convert_actual (struct value *, struct type *,
                                     CORE_ADDR *);
d108 1
a108 1
                                            CORE_ADDR *);
d3730 1
a3730 1
ensure_lval (struct value *val, CORE_ADDR *sp)
d3739 1
a3739 1
      if (gdbarch_inner_than (current_gdbarch, 1, 2))
d3744 2
a3745 2
	  if (gdbarch_frame_align_p (current_gdbarch))
	    *sp = gdbarch_frame_align (current_gdbarch, *sp);
d3752 2
a3753 2
	  if (gdbarch_frame_align_p (current_gdbarch))
	    *sp = gdbarch_frame_align (current_gdbarch, *sp);
d3756 2
a3757 2
	  if (gdbarch_frame_align_p (current_gdbarch))
	    *sp = gdbarch_frame_align (current_gdbarch, *sp);
d3774 1
a3774 1
                    CORE_ADDR *sp)
d3787 1
a3787 1
    return make_array_descriptor (formal_type, actual, sp);
d3805 1
a3805 1
              actual = ensure_lval (val, sp);
d3827 2
a3828 1
make_array_descriptor (struct type *type, struct value *arr, CORE_ADDR *sp)
d3848 1
a3848 1
  bounds = ensure_lval (bounds, sp);
d3851 1
a3851 1
                        value_address (ensure_lval (arr, sp)),
d3860 1
a3860 1
  descriptor = ensure_lval (descriptor, sp);
@


1.220
log
@	* ada-valprint.c (ada_print_scalar): Accept NULL type argument
	to indicate scalar should be printed as default integer.
	(print_optional_low_bound): Pass NULL to ada_print_scalar to
	indicate default integer output.
	* ada-typeprint.c (print_range, print_range_bound): Likewise.
	(print_choices): Likewise.  Thus, accept NULL as val_type.
	* ada-lang.c (ada_variant_discrim_type): Return NULL when failed
	to look up controlling discriminant name.
@
text
@d2589 7
a2595 3
  int pc;
  pc = 0;
  resolve_subexp (expp, &pc, 1, void_context_p ? builtin_type_void : NULL);
d3101 1
a3103 8
  struct type *fallback;
  struct type *return_type;

  return_type = context_type;
  if (context_type == NULL)
    fallback = builtin_type_void;
  else
    fallback = NULL;
d3106 4
a3109 1
  while (1)
d3116 1
a3116 1
              && return_match (type, return_type))
a3121 4
      if (m > 0 || return_type == fallback)
        break;
      else
        return_type = fallback;
d9374 2
a9375 1
                return value_zero (builtin_type_void, lval_memory);
@


1.219
log
@	* ada-lang.c (to_fixed_range_type): Add ORIG_TYPE argument.
	Fall back to orig_type as index type if symbol lookup fails.
	Allocate result types from ORIG_TYPE's objfile.
	(ada_array_bound_from_type, to_fixed_array_type,
	ada_evaluate_subexp): Pass original index type to
	to_fixed_range_type.  Do not pass objfile.

	* ada-typeprint.c (print_range_type_named): Add ORIG_TYPE argument.
	Fall back to orig_type as index type if symbol lookup fails.
	(print_array_type, ada_print_type): Pass original index type
	to print_range_type_named.
@
text
@d5651 2
a5652 1
   returns the type of the controlling discriminant for the variant.  */
d5658 1
a5658 6
  struct type *type =
    ada_lookup_struct_elt_type (outer_type, name, 1, 1, NULL);
  if (type == NULL)
    return builtin_type_int32;
  else
    return type;
@


1.218
log
@	* ada-lang.c (ada_index_type): Update comment.
@
text
@d171 1
a171 1
                                         struct objfile *);
d2458 1
a2458 1
  struct type *type, *index_type_desc, *index_type;
d2460 1
d2475 4
d2482 1
a2482 1
				      NULL, TYPE_OBJFILE (arr_type));
d2484 1
a2484 9
    {
      while (n > 1)
        {
          type = TYPE_TARGET_TYPE (type);
          n -= 1;
        }

      index_type = TYPE_INDEX_TYPE (type);
    }
d7195 2
d7201 2
a7202 2
                                 dval, TYPE_OBJFILE (type0));
          result = create_array_type (alloc_type (TYPE_OBJFILE (type0)),
d7204 1
d9130 1
a9130 2
              range_type =
                to_fixed_range_type (name, NULL, TYPE_OBJFILE (type_arg));
d9690 5
a9694 4
   Extract discriminant values, if needed, from DVAL.  If a new type
   must be created, allocate in OBJFILE's space.  The bounds
   information, in general, is encoded in NAME, the base type given in
   the named range type.  */
d9697 1
a9697 1
to_fixed_range_type (char *name, struct value *dval, struct objfile *objfile)
d9703 1
a9703 1
  /* Also search primitive types if type symbol could not be found.  */
d9705 1
a9705 2
    raw_type = language_lookup_primitive_type_by_name
		(language_def (language_ada), current_gdbarch, name);
d9707 1
a9707 3
  if (raw_type == NULL)
    base_type = builtin_type_int32;
  else if (TYPE_CODE (raw_type) == TYPE_CODE_RANGE)
d9720 2
a9721 1
	return create_range_type (alloc_type (objfile), raw_type, 
d9784 2
a9785 3
      if (objfile == NULL)
        objfile = TYPE_OBJFILE (base_type);
      type = create_range_type (alloc_type (objfile), base_type, L, U);
@


1.217
log
@	* ada-lang.c (ada_index_type): Make static.  Add NAME argument.
	Throw error on invalid input arguments.  Return NULL if unable
	to determine index type.

	(ada_array_bound_from_type): Remove TYPEP argument.
	(ada_array_bound): Make static.  Return LONGEST instead of value.
	Update for ada_array_bound_from_type change.
	(ada_array_length): Return LONGEST instead of value.
	Update for ada_array_bound_from_type change.
	(make_array_descriptor): Update for ada_array_bound change.

	(ada_evaluate_subexp) [OP_ATR_RANGE, OP_ATR_FIRST, OP_ATR_LAST,
	OP_ATR_LENGTH]: Update for ada_array_bound_from_type,
	ada_array_bound, ada_array_length, ada_index_type changes.
	Always use ada_index_type to compute result type; fall back
	to architecture-specific integer type if ada_index_type fails.

	* ada-lang.h (ada_index_type): Remove prototype.
	(ada_array_bound): Likewise.
@
text
@d2411 4
a2414 1
   Does not examine memory.  */
@


1.216
log
@	* value.h (value_subscript, value_subscripted_rvalue,
	value_bitstring_subscript, value_ptradd): Use LONGEST instead
	of value as type of the index argument.
	(value_ptrsub): Remove.
	* valarith.c (value_subscript, value_subscripted_rvalue,
	value_bitstring_subscript, value_ptradd): Use LONGEST instead
	of value as type of the index argument.
	(value_ptrsub): Remove.

	* wrapper.h (gdb_value_subscript): Use LONGEST instead of
	value as type of the index argument.
	* wrapper.c (gdb_value_subscript): Likewise.

	Update calls to gdb_value_subscript, value_subscript,
	value_subscripted_rvalue, value_bitstring_subscript and
	value_ptradd to use LONGEST instead of value as index
	argument type.  Use value_ptradd instead of value_ptrsub.
	* ada-lang.c (ada_value_subscript, ada_value_ptr_subscript,
	ada_tag_name_2): Update.
	* ada-tasks.c (read_atcb): Update.
	* eval.c (evaluate_subexp_standard): Update.
	* valarith.c (value_subscript): Update.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Update.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	gnuv3_method_ptr_to_value): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* m2-lang.c (evaluate_subexp_modula2): Update.
	* python/python-value.c (valpy_getitem, valpy_binop): Update.
	* wrapper.c (gdb_value_subscript): Update.
	* varobj.c (c_describe_child): Update.
@
text
@d2413 2
a2414 2
struct type *
ada_index_type (struct type *type, int n)
d2420 2
a2421 2
  if (n > ada_array_arity (type))
    return NULL;
d2433 2
a2434 4
      if (result_type == NULL || TYPE_CODE (result_type) == TYPE_CODE_UNDEF)
        result_type = builtin_type_int32;

      return result_type;
d2437 7
a2443 1
    return desc_index_type (desc_bounds_type (type), n);
d2449 2
a2450 3
   array-descriptor type.  If TYPEP is non-null, *TYPEP is set to the
   bounds type.  It works for other arrays with bounds supplied by
   run-time quantities other than discriminants.  */
d2453 1
a2453 2
ada_array_bound_from_type (struct type * arr_type, int n, int which,
                           struct type ** typep)
d2464 1
a2464 5
    {
      if (typep != NULL)
        *typep = builtin_type_int32;
      return (LONGEST) - which;
    }
a2500 3
  if (typep != NULL)
    *typep = index_type;

d2509 1
a2509 1
struct value *
d2517 1
a2517 5
    {
      struct type *type;
      LONGEST v = ada_array_bound_from_type (arr_type, n, which, &type);
      return value_from_longest (type, v);
    }
d2519 1
a2519 1
    return desc_one_bound (desc_bounds (arr), n, which);
d2528 1
a2528 1
static struct value *
d2537 2
a2538 7
    {
      struct type *type;
      LONGEST v =
        ada_array_bound_from_type (arr_type, n, 1, &type) -
        ada_array_bound_from_type (arr_type, n, 0, NULL) + 1;
      return value_from_longest (type, v);
    }
d2540 2
a2541 6
    return
      value_from_longest (builtin_type_int32,
                          value_as_long (desc_one_bound (desc_bounds (arr),
                                                         n, 1))
                          - value_as_long (desc_one_bound (desc_bounds (arr),
                                                           n, 0)) + 1);
d3844 1
a3844 1
                            value_as_long (ada_array_bound (arr, i, 0)),
d3848 1
a3848 1
                            value_as_long (ada_array_bound (arr, i, 1)),
d9031 3
a9033 2
      if (tem < 1 || tem > ada_array_arity (value_type (arg2)))
        error (_("invalid dimension number to 'range"));
d9035 2
a9036 2
      arg3 = ada_array_bound (arg2, tem, 1);
      arg2 = ada_array_bound (arg2, tem, 0);
d9098 4
a9101 3
            if (tem < 1 || tem > ada_array_arity (value_type (arg1)))
              error (_("invalid dimension number to '%s"),
                     ada_attribute_name (op));
d9104 1
a9104 7
              {
                type = ada_index_type (value_type (arg1), tem);
                if (type == NULL)
                  error
                    (_("attempt to take bound of something that is not an array"));
                return allocate_value (type);
              }
d9111 2
a9112 1
                return ada_array_bound (arg1, tem, 0);
d9114 2
a9115 1
                return ada_array_bound (arg1, tem, 1);
d9117 2
a9118 1
                return ada_array_length (arg1, tem);
d9154 3
a9156 3
            if (tem < 1 || tem > ada_array_arity (type_arg))
              error (_("invalid dimension number to '%s"),
                     ada_attribute_name (op));
a9157 4
            type = ada_index_type (type_arg, tem);
            if (type == NULL)
              error
                (_("attempt to take bound of something that is not an array"));
d9166 1
a9166 1
                low = ada_array_bound_from_type (type_arg, tem, 0, &type);
d9169 1
a9169 1
                high = ada_array_bound_from_type (type_arg, tem, 1, &type);
d9172 2
a9173 2
                low = ada_array_bound_from_type (type_arg, tem, 0, &type);
                high = ada_array_bound_from_type (type_arg, tem, 1, NULL);
@


1.215
log
@        * ada-lang.c (decode_packed_array): If the value is a pointer to
        an array, then use value_ind to dereference it, not ada_value_ind.
        (ada_template_to_fixed_record_type_1): Handle the case where a
        dynamic field is an aligner type.
        (to_fixed_array_type): Add handling for packed array types.
        (ada_get_base_type): Do not follow the XVS type if the type is
        an aligner type.
        (ada_evaluate_subexp): Split a few statements up for clarity
        and debuggability.
        <OP_FUNCALL>: Add handling of the case of a packed array that
        has already been fixed.
@
text
@d2276 1
a2276 1
      elt = value_subscript (elt, value_pos_atr (builtin_type_int32, ind[k]));
a2293 1
      struct value *idx;
d2300 1
a2300 6
      idx = value_pos_atr (builtin_type_int32, ind[k]);
      if (lwb != 0)
	idx = value_binop (idx, value_from_longest (value_type (idx), lwb),
			   BINOP_SUB);

      arr = value_ptradd (arr, idx);
d5565 1
a5565 2
  val = value_ind (value_ptradd (valp,
				 value_from_longest (builtin_type_int8, -1)));
@


1.214
log
@        * ada-lang.c (evaluate_subexp): Delete.  Use the version from eval.c.
        (evaluate_subexp_type): Reimplement using evaluate_subexp.
        * value.h (evaluate_subexp): Add declaration.
        * eval.c (evaluate_subexp): Make non-static.
        * objc-lang.c (print_object_command): Use evaluate_subexp.
@
text
@d1821 7
d1829 1
a1829 1
    arr = ada_value_ind (arr);
d6790 5
d6808 30
a6837 12
          /* Get the fixed type of the field. Note that, in this case, we
             do not want to get the real type out of the tag: if the current
             field is the parent part of a tagged record, we will get the
             tag of the object. Clearly wrong: the real type of the parent
             is not the real type of the child. We would end up in an infinite
             loop.  */
          TYPE_FIELD_TYPE (rtype, f) =
            ada_to_fixed_type
            (ada_get_base_type
             (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, f))),
             cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
             cond_offset_target (address, off / TARGET_CHAR_BIT), dval, 0);
d7163 1
d7165 1
a7165 2
  if (ada_is_packed_array_type (type0)  /* revisit? */
      || TYPE_FIXED_INSTANCE (type0))
d7168 4
d7189 4
a7192 1
      if (elt_type0 == elt_type)
d7232 15
d7670 15
d8323 219
d8814 2
a8815 3
          arg1 =
            unwrap_value (evaluate_subexp_standard
                          (expect_type, exp, pos, noside));
d8844 6
d9420 4
a9423 4
        return
          ada_to_fixed_value (unwrap_value
                              (ada_value_struct_elt
                               (arg1, &exp->elts[pc + 2].string, 0)));
@


1.213
log
@2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* mi/mi-main.c (mi_cmd_data_evaluate_expression): Use
	value_address.
	* cli/cli-dump.c (dump_value_to_file): Use value_address.
	* valprint.c (common_val_print): Likewise.
	* v850-tdep.c (v850_push_dummy_call): Use value_address.
	* tracepoint.c (encode_actions): Use value_address.
	* printcmd.c (print_formatted): Use value_address.
	(x_command): Likewise.
	* p-valprint.c (pascal_object_print_static_field): Use
	value_address.
	* mn10300-tdep.c (mn10300_push_dummy_call): Use value_address.
	* mips-tdep.c (mips_eabi_push_dummy_call): Use value_address.
	* m32r-tdep.c (m32r_push_dummy_call): Use value_address.
	* jv-valprint.c (java_value_print): Use value_address.
	* infcall.c (find_function_addr): Use value_address.
	* gnu-v3-abi.c (gnuv3_rtti_type): Use value_address.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Use value_address.
	* frv-tdep.c (frv_push_dummy_call): Use value_address.
	* frame.c (frame_register_unwind): Use value_address.
	(frame_unwind_register_value): Likewise.
	* darwin-nat-info.c (info_mach_region_command): Use
	value_address.
	* cp-valprint.c (cp_print_static_field): Use value_address.
	* c-valprint.c (c_value_print): Use value_address.
	* breakpoint.c (update_watchpoint): Use value_address.
	(can_use_hardware_watchpoint): Likewise.
	* ada-valprint.c (ada_val_print_1): Use value_address.
	(ada_value_print): Likewise.
	* ada-tasks.c (read_fat_string_value): Use value_address.
	* jv-lang.c (java_link_class_type): Use set_value_address.
	(java_link_class_type): Likewise.
	(get_java_utf8_name): Use value_address.
	(type_from_class): Likewise.
	(java_link_class_type): Likewise.
	* findvar.c (value_of_register): Use set_value_address.
	(read_var_value): Likewise.
	(read_var_value): Likewise.
	* eval.c (evaluate_subexp_standard): Use set_value_address.
	(evaluate_subexp_standard): Use value_address.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Use set_value_address.
	* ada-lang.c (coerce_unspec_val_to_type): Use set_value_address.
	(ada_value_primitive_packed_val): Likewise.
	(ensure_lval): Likewise.
	(thin_data_pntr): Use value_address.
	(desc_bounds): Likewise.
	(ada_value_primitive_packed_val): Likewise.
	(value_assign_to_component): Likewise.
	(ensure_lval): Likewise.
	(make_array_descriptor): Likewise.
	(ada_to_fixed_value): Likewise.
	(unwrap_value): Likewise.
	* value.c (deprecated_value_address_hack): Remove.
	(value_address): New function.
	(value_raw_address): Likewise.
	(set_value_address): Likewise.
	(value_fn_field): Use set_value_address.
	(value_from_contents_and_address): Likewise.
	(value_fn_field): Likewise.
	(allocate_value_lazy): Don't use VALUE_ADDRESS.
	(value_as_address): Use value_address.
	(value_static_field): Likewise.
	* valops.c (search_struct_field): Use set_value_address.
	(value_at): Likewise.
	(value_at_lazy): Likewise.
	(value_repeat): Likewise.
	(value_cast_structs): Use value_address.
	(value_cast): Likewise.
	(value_fetch_lazy): Likewise.
	(value_assign): Likewise.
	(value_repeat): Likewise.
	(address_of_variable): Likewise.
	(value_coerce_array): Likewise.
	(value_coerce_function): Likewise.
	(value_addr): Likewise.
	(search_struct_field): Likewise.
	(search_struct_method): Likewise.
	(find_method_list): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(value_full_object): Likewise.
	* jv-valprint.c (java_value_print): Use set_value_address.
	* value.h (deprecated_value_address_hack): Remove.
	(VALUE_ADDRESS): Remove.
	(value_address): Declare.
	(value_raw_address): Declare.
	(set_value_address): Declare.
@
text
@a159 3
static struct value *evaluate_subexp (struct type *, struct expression *,
                                      int *, enum noside);

a7729 8
static struct value *
evaluate_subexp (struct type *expect_type, struct expression *exp, int *pos,
                 enum noside noside)
{
  return (*exp->language_defn->la_exp_desc->evaluate_exp)
    (expect_type, exp, pos, noside);
}

d7737 1
a7737 2
  return (*exp->language_defn->la_exp_desc->evaluate_exp)
    (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
@


1.212
log
@	* ada-lang.c (ada_find_any_type): Move check for primitive types ...
	(to_fixed_range_type): ... to here.
@
text
@d488 1
a488 1
      VALUE_ADDRESS (result) += value_offset (val);
d1290 1
a1290 2
    return value_from_longest (data_type,
                               VALUE_ADDRESS (val) + value_offset (val));
d1355 1
a1355 1
        addr = VALUE_ADDRESS (arr) + value_offset (arr);
d1970 1
a1970 1
                    VALUE_ADDRESS (obj) + value_offset (obj) + offset);
d1972 1
a1972 1
      read_memory (VALUE_ADDRESS (v), bytes, len);
d1982 1
d1984 1
a1984 1
      VALUE_ADDRESS (v) += value_offset (obj) + offset;
d1989 1
a1989 1
          VALUE_ADDRESS (v) += 1;
d1992 1
d2185 1
a2185 1
      CORE_ADDR to_addr = VALUE_ADDRESS (toval) + value_offset (toval);
d2226 1
a2226 2
    (LONGEST)  (VALUE_ADDRESS (component) + value_offset (component)
		- VALUE_ADDRESS (container) - value_offset (container));
d3753 1
a3753 1
   returning an lvalue whose VALUE_ADDRESS points to the copy.  */
d3767 1
a3767 1
	  /* Stack grows downward.  Align SP and VALUE_ADDRESS (val) after
d3772 1
a3772 1
	  VALUE_ADDRESS (val) = *sp;
d3780 1
a3780 1
	  VALUE_ADDRESS (val) = *sp;
d3787 1
a3787 1
      write_memory (VALUE_ADDRESS (val), value_contents_raw (val), len);
d3876 1
a3876 1
                        VALUE_ADDRESS (ensure_lval (arr, sp)),
d3881 1
a3881 1
                        VALUE_ADDRESS (bounds),
d7433 1
a7433 1
                                    VALUE_ADDRESS (val) + value_offset (val),
d7779 1
a7779 1
                                 VALUE_ADDRESS (val) + value_offset (val),
@


1.211
log
@	* ada-lang.c (desc_data_type): Remove, replace by ...
	(desc_data_target_type): ... this.
	(thin_data_pntr): Use desc_data_target_type instead of desc_data_type.
	(ada_is_array_descriptor_type): Likewise.
	(ada_type_of_array): Likewise.
	(ada_coerce_to_simple_array_type): Likewise.
	(ada_array_element_type): Likewise.
@
text
@d6484 3
a6486 1
/* Find a type named NAME.  Ignores ambiguity.  */
a6491 1
  struct type *type = NULL;
d6494 1
a6494 1
    type = SYMBOL_TYPE (sym);
d6496 1
a6496 5
  if (type == NULL)
    type = language_lookup_primitive_type_by_name
      (language_def (language_ada), current_gdbarch, name);

  return type;
d9451 5
@


1.210
log
@	* ada-lang.c (ada_coerce_to_simple_array_type): Reimplement to
	avoid creating a dummy value.
@
text
@d82 1
a82 1
static struct type *desc_data_type (struct type *);
d1284 3
d1288 1
a1288 2
    return value_cast (desc_data_type (thin_descriptor_type (type)),
                       value_copy (val));
d1290 1
a1290 1
    return value_from_longest (desc_data_type (thin_descriptor_type (type)),
d1394 3
a1396 3
   pointer to one, the type of its array data (a
   pointer-to-array-with-no-bounds type); otherwise, NULL.  Use
   ada_type_of_array to get an array type with bounds data.  */
d1399 1
a1399 1
desc_data_type (struct type *type)
d1405 1
a1405 2
    return lookup_pointer_type
      (desc_base_type (TYPE_FIELD_TYPE (thin_descriptor_type (type), 1)));
d1407 9
a1415 3
    return lookup_struct_elt_type (type, "P_ARRAY", 1);
  else
    return NULL;
d1566 1
a1566 1
  struct type *data_type = desc_data_type (type);
d1571 3
a1573 7
  return
    data_type != NULL
    && ((TYPE_CODE (data_type) == TYPE_CODE_PTR
         && TYPE_TARGET_TYPE (data_type) != NULL
         && TYPE_CODE (TYPE_TARGET_TYPE (data_type)) == TYPE_CODE_ARRAY)
        || TYPE_CODE (data_type) == TYPE_CODE_ARRAY)
    && desc_arity (desc_bounds_type (type)) > 0;
d1611 1
a1611 1
      ada_check_typedef (TYPE_TARGET_TYPE (desc_data_type (value_type (arr))));
d1699 1
a1699 1
    return ada_check_typedef (TYPE_TARGET_TYPE (desc_data_type (type)));
d2383 1
a2383 1
      p_array_type = desc_data_type (type);
a2391 1
      p_array_type = TYPE_TARGET_TYPE (p_array_type);
@


1.209
log
@        * ada-lang.c: Remove an extra empty line. No code change.
@
text
@d1692 7
a1698 7
  struct value *mark = value_mark ();
  struct value *dummy = value_from_longest (builtin_type_int32, 0);
  struct type *result;
  deprecated_set_value_type (dummy, type);
  result = ada_type_of_array (dummy, 0);
  value_free_to_mark (mark);
  return result;
@


1.208
log
@        * ada-lang.c (symtab_for_sym): Delete.
        (user_select_syms): Use sym->symtab instead of calling symtab_for_sym.
@
text
@a4947 1

@


1.207
log
@        * ada-lang.c (extract_string): Delete.
        (ada_main_name): Reimplement using target_read_string instead of
        extract_string.
@
text
@a128 2
static struct symtab *symtab_for_sym (struct symbol *);

d3282 1
a3282 1
          struct symtab *symtab = symtab_for_sym (syms[i].sym);
a4200 57
/* Find a symbol table containing symbol SYM or NULL if none.  */

static struct symtab *
symtab_for_sym (struct symbol *sym)
{
  struct symtab *s;
  struct objfile *objfile;
  struct block *b;
  struct symbol *tmp_sym;
  struct dict_iterator iter;
  int j;

  ALL_PRIMARY_SYMTABS (objfile, s)
  {
    switch (SYMBOL_CLASS (sym))
      {
      case LOC_CONST:
      case LOC_STATIC:
      case LOC_TYPEDEF:
      case LOC_REGISTER:
      case LOC_LABEL:
      case LOC_BLOCK:
      case LOC_CONST_BYTES:
        b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
        ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
          return s;
        b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
        ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
          return s;
        break;
      default:
        break;
      }
    switch (SYMBOL_CLASS (sym))
      {
      case LOC_REGISTER:
      case LOC_ARG:
      case LOC_REF_ARG:
      case LOC_REGPARM_ADDR:
      case LOC_LOCAL:
      case LOC_TYPEDEF:
      case LOC_COMPUTED:
        for (j = FIRST_LOCAL_BLOCK;
             j < BLOCKVECTOR_NBLOCKS (BLOCKVECTOR (s)); j += 1)
          {
            b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), j);
            ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
              return s;
          }
        break;
      default:
        break;
      }
  }
  return NULL;
}

@


1.206
log
@	ARI fix: sprintf rule.
	* ada-exp.y (convert_char_literal): Replace sprintf by xsnprintf.
	* ada-lang.c (add_angle_brackets): Use xstrprintf.
	(ada_decode): Replace sprintf by xsnprintf.
	(find_old_style_renaming_symbol): Ditto.
	(ada_to_fixed_type_1, ada_enum_name): Ditto.
@
text
@d682 1
a682 2
  CORE_ADDR main_program_name_addr;
  static char main_program_name[1024];
d693 3
d700 6
a705 1
      extract_string (main_program_name_addr, main_program_name);
@


1.205
log
@        * ada-lang.c (resolve_subexp) [UNOP_QUAL]: Resolve typedefs before
        trying to resolve the type qualification.
@
text
@d340 1
a340 3
  result = (char *) xmalloc ((strlen (str) + 3) * sizeof (char));

  sprintf (result, "<%s>", str);
d1115 1
a1115 1
    sprintf (decoded, "<%s>", encoded);
d6610 2
a6611 1
      sprintf (rename, "%s__%s___XR", function_name, name);
d6617 1
a6617 1
      sprintf (rename, "%s___XR", name);
d7310 1
a7310 1
            sprintf (xvz_name, "%s___XVZ", name);
d7762 1
a7762 1
        sprintf (result, "'%c'", v);
d7764 1
a7764 1
        sprintf (result, "[\"%02x\"]", v);
d7766 1
a7766 1
        sprintf (result, "[\"%04x\"]", v);
@


1.204
log
@        * ada-lang.c (ada_evaluate_subexp) [UNOP_IN_RANGE]: make sure
        we try to apply the attribute on the real type, rather than
        its associated typedef.
@
text
@d2657 1
a2657 1
      resolve_subexp (expp, pos, 1, exp->elts[pc + 1].type);
@


1.203
log
@        * ada-lang.c (ada_evaluate_subexp) [OP_ATR_MODULUS]: Use check_typdef
        to make sure we try to get the modulus of the actual type, not the
        associated typedef.
@
text
@d8789 1
a8789 1
      type = exp->elts[pc + 1].type;
@


1.202
log
@        * ada-lang.c (ada_evaluate_subexp): [OP_ATR_FIRST, OP_ATR_LAST]
        [OP_ATR_LENGTH]: When using the attribute on a type, make sure
        to get the real type, not the associated typedef.
@
text
@d9013 1
a9013 1
        struct type *type_arg = exp->elts[pc + 2].type;
@


1.201
log
@        * ada-lang.c (ada_get_field_index): Add handling of the case
        when TYPE is a typedef of a struct.
@
text
@d8875 1
a8875 1
            type_arg = exp->elts[pc + 2].type;
@


1.200
log
@gdb:
2009-03-19  Tom Tromey  <tromey@@redhat.com>
	    Julian Brown  <julian@@codesourcery.com>

	PR i18n/7220, PR i18n/7821, PR exp/8815, PR exp/9103,
	PR i18n/9401, PR exp/9613:
	* NEWS: Update
	* value.h (value_typed_string): Declare.
	(val_print_string): Update.
	* valprint.h (print_char_chars): Update.
	* valprint.c (print_char_chars): Add type argument.  Update.
	(val_print_string): Likewise.
	* valops.c (value_typed_string): New function.
	* utils.c (host_char_to_target): New function.
	(parse_escape): Use host_char_to_target, host_hex_value.  Update.
	Remove '^' case.
	(no_control_char_error): Remove.
	* typeprint.c (print_type_scalar): Update.
	* scm-valprint.c (scm_scmval_print): Update.
	* scm-lang.h (scm_printchar, scm_printstr): Update.
	* scm-lang.c (scm_printchar): Add type argument.
	(scm_printstr): Likewise.
	* printcmd.c (print_formatted): Update.
	(print_scalar_formatted): Update.
	(printf_command) <wide_string_arg, wide_char_arg>: New constants.
	Handle '%lc' and '%ls'.
	* parser-defs.h (struct typed_stoken): New type.
	(struct stoken_vector): Likewise.
	(write_exp_string_vector): Declare.
	* parse.c (write_exp_string_vector): New function.
	* p-valprint.c (pascal_val_print): Update.
	* p-lang.h (is_pascal_string_type, pascal_printchar,
	pascal_printstr): Update.
	* p-lang.c (is_pascal_string_type): Remove 'char_size' argument.
	Add 'char_type' argument.
	(pascal_emit_char): Add type argument.
	(pascal_printchar): Likewise.
	(pascal_printstr): Likewise.
	* objc-lang.c (objc_emit_char): Add type argument.
	(objc_printchar): Likewise.
	(objc_printstr): Likewise.
	* macroexp.c (get_character_constant): Handle unicode characters.
	Use c_parse_escape.
	(get_string_literal): Handle unicode strings.  Use
	c_parse_escape.
	* m2-valprint.c (print_unpacked_pointer): Update.
	(m2_print_array_contents): Update.
	(m2_val_print): Update.
	* m2-lang.c (m2_emit_char): Add type argument.
	(m2_printchar): Likewise.
	(m2_printstr): Likewise.
	* language.h (struct language_defn) <la_printchar>: Add type
	argument.
	<la_printstr, la_emitchar>: Likewise.
	(LA_PRINT_CHAR): Likewise.
	(LA_PRINT_STRING): Likewise.
	(LA_EMIT_CHAR): Likewise.
	* language.c (unk_lang_emit_char): Add type argument.
	(unk_lang_printchar): Likewise.
	(unk_lang_printstr): Likewise.
	* jv-valprint.c (java_val_print): Update.
	* jv-lang.c (java_emit_char): Add type argument.
	* f-valprint.c (f_val_print): Update.
	* f-lang.c (f_emit_char): Add type argument.
	(f_printchar): Likewise.
	(f_printstr): Likewise.
	* expprint.c (print_subexp_standard): Update.
	* charset.h (target_wide_charset): Declare.
	(c_target_char_has_backslash_escape, c_parse_backslash,
	host_char_print_literally, host_char_to_target,
	target_char_to_host, target_char_to_control_char): Remove.
	(enum transliterations): New type.
	(convert_between_encodings): Declare.
	(HOST_ESCAPE_CHAR): New define.
	(host_letter_to_control_character, host_hex_value): Declare.
	(enum wchar_iterate_result): New enum.
	(struct wchar_iterator): Declare.
	(make_wchar_iterator, make_cleanup_wchar_iterator, wchar_iterator,
	wchar_push_back): Declare.
	* charset-list.h: New file.
	* c-valprint.c (textual_name): New function.
	(textual_element_type): Handle wide character types.
	(c_val_print): Pass original type to textual_element_type.  Handle
	wide character types.
	(c_value_print): Use textual_element_type.  Pass original type of
	value to val_print.
	* c-lang.h (enum c_string_type): New type.
	(c_printchar, c_printstr): Update.
	* c-lang.c (classify_type): New function.
	(print_wchar): Likewise.
	(c_emit_char): Add type argument.  Handle wide characters.
	(c_printchar): Likewise.
	(c_printstr): Add type argument.  Handle wide and multibyte
	character sets.
	(convert_ucn): New function.
	(emit_numeric_character): Likewise.
	(convert_octal): Likewise.
	(convert_hex): Likewise.
	(ADVANCE): New macro.
	(convert_escape): New function.
	(parse_one_string): Likewise.
	(evaluate_subexp_c): Likewise.
	(exp_descriptor_c): New global.
	(c_language_defn): Use exp_descriptor_c.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	(charset_for_string_type): New function.
	* c-exp.y (%union): Add 'svec' and 'tsval'.
	(CHAR): New token.
	(exp): Add CHAR production.
	(string_exp): Rewrite.
	(exp) <string_exp>: Rewrite.
	(tempbuf): Now global.
	(tempbuf_init): New global.
	(parse_string_or_char): New function.
	(yylex) <tempbuf>: Now global.
	<tokptr, tempbufindex, tempbufsize, token_string, class_prefix>:
	Remove.
	Handle 'u', 'U', and 'L' prefixes.  Call parse_string_or_char.
	(c_parse_escape): New function.
	* auxv.c (fprint_target_auxv): Update.
	* ada-valprint.c (ada_emit_char): Add type argument.
	(ada_printchar): Likewise.
	(ada_print_scalar): Update.
	(printstr): Add type argument.  Update calls to ada_emit_char.
	(ada_printstr): Add type argument.
	(ada_val_print_array): Update.
	(ada_val_print_1): Likewise.
	* ada-lang.c (emit_char): Add type argument.
	* ada-lang.h (ada_emit_char, ada_printchar, ada_printstr): Add
	type arguments.
	* gdb_locale.h: Include langinfo.h.
	* charset.c (_initialize_charset): Set default host charset from
	the locale.  Don't register charsets.  Add target-wide-charset
	commands.  Call find_charset_names.
	(struct charset, struct translation): Remove.
	(GDB_DEFAULT_HOST_CHARSET): Remove.
	(GDB_DEFAULT_TARGET_WIDE_CHARSET): New define.
	(target_wide_charset_name): New global.
	(show_host_charset_name): Handle "auto".
	(show_target_wide_charset_name): New function.
	(host_charset_enum, target_charset_enum): Remove.
	(charset_enum): New global.
	(all_charsets, register_charset, lookup_charset, all_translations,
	register_translation, lookup_translation): Remove.
	(simple_charset, ascii_print_literally, ascii_to_control): Remove.
	(iso_8859_print_literally, iso_8859_to_control,
	iso_8859_family_charset): Remove.
	(ebcdic_print_literally, ebcdic_to_control,
	ebcdic_family_charset): Remove.
	(struct cached_iconv, check_iconv_cache, cached_iconv_convert,
	register_iconv_charsets): Remove.
	(target_wide_charset_be_name, target_wide_charset_le_name): New
	globals.
	(identity_either_char_to_other): Remove.
	(set_be_le_names, validate): New functions.
	(backslashable, backslashed, represented): Remove.
	(default_c_target_char_has_backslash_escape): Remove.
	(default_c_parse_backslash, iconv_convert): Remove.
	(ascii_to_iso_8859_1_table, ascii_to_ebcdic_us_table,
	ascii_to_ibm1047_table, iso_8859_1_to_ascii_table,
	iso_8859_1_to_ebcdic_us_table, iso_8859_1_to_ibm1047_table,
	ebcdic_us_to_ascii_table, ebcdic_us_to_iso_8859_1_table,
	ebcdic_us_to_ibm1047_table, ibm1047_to_ascii_table,
	ibm1047_to_iso_8859_1_table, ibm1047_to_ebcdic_us_table): Remove.
	(table_convert_char, table_translation, simple_table_translation):
	Remove.
	(current_host_charset, current_target_charset,
	c_target_char_has_backslash_escape_func,
	c_target_char_has_backslash_escape_baton): Remove.
	(c_parse_backslash_func, c_parse_backslash_baton): Remove.
	(host_char_to_target_func, host_char_to_target_baton): Remove.
	(target_char_to_host_func, target_char_to_host_baton): Remove.
	(cached_iconv_host_to_target, cached_iconv_target_to_host):
	Remove.
	(lookup_charset_or_error, check_valid_host_charset): Remove.
	(set_host_and_target_charsets): Remove.
	(set_host_charset, set_target_charset): Remove.
	(set_host_charset_sfunc, set_target_charset_sfunc): Rewrite.
	(set_target_wide_charset_sfunc): New function.
	(show_charset): Print target wide character set.
	(host_charset, target_charset): Rewrite.
	(target_wide_charset): New function.
	(c_target_char_has_backslash_escape): Remove.
	(c_parse_backslash): Remove.
	(host_letter_to_control_character): New function.
	(host_char_print_literally): Remove.
	(host_hex_value): New function.
	(target_char_to_control_char): Remove.
	(cleanup_iconv): New function.
	(convert_between_encodings): New function.
	(target_char_to_host): Remove.
	(struct wchar_iterator): Define.
	(make_wchar_iterator, make_cleanup_wchar_iterator, wchar_iterator,
	wchar_push_back): New functions.
	(do_cleanup_iterator): New function.
	(char_ptr): New typedef.
	(charsets): New global.
	(add_one, find_charset_names): New functions.
	(default_charset_names): New global.
	(auto_host_charset_name): Likewise.
	* aclocal.m4, config.in, configure: Rebuild.
	* configure.ac: Call AM_LANGINFO_CODESET.
	(GDB_DEFAULT_HOST_CHARSET): Default to UTF-8.
	(AM_ICONV): Invoke earlier.
	* acinclude.m4: Include codeset.m4.  Subst LIBICONV_INCLUDE and
	LIBICONV_LIBDIR.  Check for libiconv in build tree.
	* Makefile.in (LIBICONV_LIBDIR, LIBICONV_INCLUDE): New macros.
	(INTERNAL_CFLAGS_BASE): Add LIBICONV_INCLUDE.
	(INTERNAL_LDFLAGS): Add LIBICONV_LIBDIR.
	* gdb_obstack.h (obstack_grow_wstr): New define.
        * gdb_wchar.h: New file.
        * defs.h: Include it.
gdb/testsuite:
	* gdb.base/store.exp: Update for change to escape output.
	* gdb.base/callfuncs.exp (fetch_all_registers): Update for change
	to escape output.
	* gdb.base/pointers.exp: Update for change to escape output.
	* gdb.base/long_long.exp (gdb_test_long_long): Update for change
	to escape output.
	* gdb.base/constvars.exp (do_constvar_tests): Update for change to
	escape output.
	* gdb.base/call-rt-st.exp (print_struct_call): Update for change
	to escape output.
	* gdb.cp/ref-types.exp (gdb_start_again): Update for change to
	escape output.
	* gdb.base/setvar.exp: Update for change to escape output.
	* lib/gdb.exp (default_gdb_start): Set LC_CTYPE to C.
	* gdb.base/printcmds.exp (test_print_all_chars): Update for change
	to escape output.
	(test_print_string_constants): Likewise.
	* gdb.base/charset.exp (valid_host_charset): Check size of
	wchar_t.  Handle UCS-2 and UCS-4.  Add tests for wide and unicode
	cases.  Handle "auto"-related output.
	* gdb.base/charset.c (char16_t, char32_t): New typedefs.
	(uvar, Uvar): New globals.
gdb/doc:
	* gdb.texinfo (Character Sets): Remove obsolete text.  Document
	set target-wide-charset.
	(Requirements): Mention iconv.
@
text
@d414 7
a420 6
/* Assuming TYPE is a TYPE_CODE_STRUCT, find the field whose name matches
   FIELD_NAME, and return its index.  This function also handles fields
   whose name have ___ suffixes because the compiler sometimes alters
   their name by adding such a suffix to represent fields with certain
   constraints.  If the field could not be found, return a negative
   number if MAYBE_MISSING is set.  Otherwise raise an error.  */
d427 4
a430 2
  for (fieldno = 0; fieldno < TYPE_NFIELDS (type); fieldno++)
    if (field_name_match (TYPE_FIELD_NAME (type, fieldno), field_name))
d435 1
a435 1
           field_name, TYPE_NAME (type));
@


1.199
log
@2009-03-20  Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* dwarf2read.c (process_die): Handle DW_TAG_typedef.
	* eval.c (evaluate_subexp_standard) <OP_TYPE>: Strip a single
	typedef.
	* ada-lang.c (decode_packed_array_type): Call CHECK_TYPEDEF on the
	SYMBOL_TYPE result.
	* ada-typeprint.c (print_array_type): Do the NULL check
	unconditionally.
@
text
@d11025 1
a11025 1
emit_char (int c, struct ui_file *stream, int quoter)
d11027 1
a11027 1
  ada_emit_char (c, stream, quoter, 1);
@


1.198
log
@        * ada-lang.c (ada_evaluate_subexp): Merge case BINOP_REM and
        BINOP_MOD cases with the handling of case BINOP_DIV and BINOP_MUL.
        Remove useless op value checks when EVAL_AVOID_SIDE_EFFECTS.
@
text
@d1786 1
@


1.197
log
@        * ada-lang.c (ada_evaluate_subexp) <BINOP_DIV>: make sure to
        promote the operands when noside is EVAL_AVOID_SIDE_EFFECTS.
@
text
@d8455 2
d8461 1
a8461 2
      else if (noside == EVAL_AVOID_SIDE_EFFECTS
               && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
a8476 15
    case BINOP_REM:
    case BINOP_MOD:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS
               && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
        return value_zero (value_type (arg1), not_lval);
      else
	{
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
	  return ada_value_binop (arg1, arg2, op);
	}

@


1.196
log
@        * ada-lang.c (ada_delta): Change the type of numerators and
        denominators to DOUBLEST, as they may not fit into a long.
        (scaling_factor): Ditto.
@
text
@d8461 4
a8464 1
        return value_zero (value_type (arg1), not_lval);
@


1.195
log
@        * language.c (lang_bool_type): Return a builtin bool type in the
        Ada case.
@
text
@d9299 1
a9299 1
  long num, den;
d9301 5
a9305 1
  if (sscanf (encoding, "_%ld_%ld", &num, &den) < 2)
d9308 1
a9308 1
    return (DOUBLEST) num / (DOUBLEST) den;
d9318 1
a9318 1
  unsigned long num0, den0, num1, den1;
d9321 7
a9327 1
  n = sscanf (encoding, "_%lu_%lu_%lu_%lu", &num0, &den0, &num1, &den1);
d9332 1
a9332 1
    return (DOUBLEST) num1 / (DOUBLEST) den1;
d9334 1
a9334 1
    return (DOUBLEST) num0 / (DOUBLEST) den0;
@


1.194
log
@        * ada-lang.c (ada_evaluate_subexp) [OP_VAR_VALUE]: For tagged
        types, if we are unable to determine the actual symbol type
        from its tag, then use the static approximation instead.
@
text
@d11016 1
a11016 1
  lai->bool_type_symbol = "boolean";
@


1.193
log
@        Fix crash printing packed record with packed array.

        * ada-lang.c (ada_modulus_from_name): New function.
        (ada_modulus): In the case where the type length is bigger than
        the size of the type used to hold the bounds, try determining
        the modulus from the type name.
        (ada_value_primitive_packed_val): Fix bug in the computation of
        ntarg causing an out-of-buffer invalid access.
@
text
@d8579 2
d8582 10
a8591 1
            return value_zero (type_from_tag (ada_value_tag (arg1)), not_lval);
@


1.192
log
@        Fix segfault when printing short_integer'last.

        * ada-lang.c (ada_find_any_type): Search in the primitive types
        if a symbol could not be found.
@
text
@d2018 1
d9601 31
d9635 1
a9635 1
ada_modulus (struct type * type)
d9637 13
@


1.191
log
@        Remove some unused routines.

        * ada-lang.c (is_suppressed_name, ada_suppress_symbol_printing):
        Delete.
        * ada-lang.c (ada_task_list_iterator_ftype)
        (iterate_over_live_ada_tasks): Delete.
        * ada-tasks.c (ada_get_environment_task, iterate_over_live_ada_tasks):
        Delete.
@
text
@d6538 1
d6541 1
a6541 1
    return SYMBOL_TYPE (sym);
d6543 5
a6547 1
  return NULL;
@


1.190
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@a734 36
/* Return non-zero if STR should be suppressed in info listings.  */

static int
is_suppressed_name (const char *str)
{
  if (strncmp (str, "_ada_", 5) == 0)
    str += 5;
  if (str[0] == '_' || str[0] == '\000')
    return 1;
  else
    {
      const char *p;
      const char *suffix = strstr (str, "___");
      if (suffix != NULL && suffix[3] != 'X')
        return 1;
      if (suffix == NULL)
        suffix = str + strlen (str);
      for (p = suffix - 1; p != str; p -= 1)
        if (isupper (*p))
          {
            int i;
            if (p[0] == 'X' && p[-1] != '_')
              goto OK;
            if (*p != 'O')
              return 1;
            for (i = 0; ada_opname_table[i].encoded != NULL; i += 1)
              if (strncmp (ada_opname_table[i].encoded, p,
                           strlen (ada_opname_table[i].encoded)) == 0)
                goto OK;
            return 1;
          OK:;
          }
      return 0;
    }
}

a1197 12

/* True (non-zero) iff, in Ada mode, the symbol SYM should be
   suppressed in info listings.  */

static int
ada_suppress_symbol_printing (struct symbol *sym)
{
  if (SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN)
    return 1;
  else
    return is_suppressed_name (SYMBOL_LINKAGE_NAME (sym));
}
@


1.189
log
@2009-02-05  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* language.h (language_dfn): Add la_get_string member.
	(LA_GET_STRING): New macro.
	(default_get_string): New prototype.
	* language.c (default_get_string): New function.
	(unknown_language_defn, auto_language_defn, local_language_defn): Use
	default_get_string for la_get_string.
	* c-lang.c (c_get_string): New function.
	(c_language_defn, cplus_language_defn, asm_language_defn): Use
	c_get_string for la_get_string.
	(minimal_language_defn): Likewise
	* ada-lang.c (ada_language_defn): Likewise.
	* f-lang.c (f_language_defn): Use default_get_string for
	la_get_string.
	* jv-lang.c (java_language_defn): Likewise.
	* m2-lang.c (m2_language_defn): Likewise.
	* objc-lang.c (objc_language_defn): Likewise.
	* p-lang.c (p_language_defn): Likewise.
	* scm-lang.c (scm_language_defn): Likewise.
	* typeprint.c (type_to_string): New function.
	* value.h (type_to_string): New prototype.
	* valprint.c (val_print_string): Factor out code for reading string
	from the inferior into its own function.  Put 2 spaces after period
	in comments.
	(read_string): New function.
	* valprint.h (read_string): New prototype.
@
text
@d1204 1
a1204 1
char *
d1217 1
a1217 1
int
d1238 1
a1238 1
int
d1573 1
a1573 1
int
d2318 1
a2318 1
struct value *
d2577 1
a2577 1
struct value *
d7535 1
a7535 1
struct value *
d11070 3
@


1.188
log
@	* ada-lang.c (ada_template_to_fixed_record_type_1): Check size
	of type to guard against a crash.
@
text
@d3 2
a4 2
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004, 2005, 2007
   Free Software Foundation, Inc.
d11066 1
@


1.187
log
@2009-01-13  Jim Blandy  <jimb@@codesourcery.com>

	Abstract out common code for copying value locations.

	* value.h (set_value_component_location): New declaration.
	* value.c (set_value_component_location): New function.
	(value_primitive_field): Use it.
	* valarith.c (value_subscript, value_subscripted_rvalue): Same.
	* valops.c (search_struct_field, value_slice): Same.
	* ada-lang.c (coerce_unspec_val_to_type)
	(ada_value_primitive_packed_val): Same.
@
text
@d6880 9
a6888 1
            dval = value_from_contents_and_address (rtype, valaddr, address);
@


1.186
log
@	Fix TYPE_HIGH_BOUND for TYPE_CODE_RANGE using arbitrary TYPE_NFIELDS in
	preparation for supporting DW_AT_byte_stride.
	* ada-lang.c (packed_array_type, ada_index_type): Use TYPE_INDEX_TYPE.
	(ada_array_bound_from_type): Move `index_type' declaration to the
	function start.  New variable `retval'.  Return the bounds for
	TYPE_CODE_RANGE using TYPE_LOW_BOUND and TYPE_HIGH_BOUND.  Abort on
	invalid index type codes.
	* ada-typeprint.c (print_range): Set `upper_bound' for TYPE_CODE_RANGE
	now using TYPE_HIGH_BOUND.
	* ada-valprint.c (val_print_packed_array_elements): Use `index_type'.
	* eval.c (evaluate_subexp_standard): Use TYPE_INDEX_TYPE.
	* gdbtypes.c (create_range_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	refer to the number of fields only through TYPE_NFIELDS.
	(create_array_type): Use TYPE_INDEX_TYPE.
	(check_typedef): Use TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND.
	* gdbtypes.h (TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED)
	(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED): Use TYPE_INDEX_TYPE.
	(TYPE_ARRAY_UPPER_BOUND_VALUE, TYPE_ARRAY_LOWER_BOUND_VALUE): Use
	TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* hppa-tdep.c (hppa_alignof <TYPE_CODE_ARRAY>): Use TYPE_INDEX_TYPE.
	* mdebugread.c (parse_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* valarith.c (value_bit_index): Use TYPE_INDEX_TYPE.
@
text
@d486 1
a486 1
      VALUE_LVAL (result) = VALUE_LVAL (val);
d489 1
a489 1
      VALUE_ADDRESS (result) = VALUE_ADDRESS (val) + value_offset (val);
d2021 2
a2022 4
      VALUE_LVAL (v) = VALUE_LVAL (obj);
      if (VALUE_LVAL (obj) == lval_internalvar)
        VALUE_LVAL (v) = lval_internalvar_component;
      VALUE_ADDRESS (v) = VALUE_ADDRESS (obj) + value_offset (obj) + offset;
@


1.185
log
@	* ada-lang.c (ada_value_slice_ptr): Rename to...
	(ada_value_slice_from_ptr): ... this. Return a lazy value instead
	of a reference.	Update comment.
	(ada_value_struct_elt): Ditto if arg is a pointer or a reference.
	Update comment as well.
	(ada_evaluate_subexp): Update use of ada_value_slice_ptr.
@
text
@d1780 1
a1780 1
  create_array_type (new_type, new_elt_type, TYPE_FIELD_TYPE (type, 0));
d1784 1
a1784 1
  if (get_discrete_bounds (TYPE_FIELD_TYPE (type, 0),
d2471 1
a2471 1
      result_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 0));
d2495 4
a2498 2
  struct type *type;
  struct type *index_type_desc;
d2516 4
a2519 1
  if (index_type_desc == NULL)
a2520 2
      struct type *index_type;

d2528 1
a2528 2
      if (typep != NULL)
        *typep = index_type;
d2530 13
a2542 10
      /* The index type is either a range type or an enumerated type.
         For the range type, we have some macros that allow us to
         extract the value of the low and high bounds.  But they
         do now work for enumerated types.  The expressions used
         below work for both range and enum types.  */
      return
        (LONGEST) (which == 0
                   ? TYPE_FIELD_BITPOS (index_type, 0)
                   : TYPE_FIELD_BITPOS (index_type,
                                        TYPE_NFIELDS (index_type) - 1));
a2543 5
  else
    {
      struct type *index_type =
        to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, n - 1),
                             NULL, TYPE_OBJFILE (arr_type));
d2545 2
a2546 2
      if (typep != NULL)
        *typep = index_type;
d2548 1
a2548 5
      return
        (LONGEST) (which == 0
                   ? TYPE_LOW_BOUND (index_type)
                   : TYPE_HIGH_BOUND (index_type));
    }
@


1.184
log
@	* ada-lang.c (value_from_contents_and_address): Move...
	* value.c: ... here.
	* ada-lang.h (value_from_contents_and_address): Move
	declaration...
	* value.h: ... here.
@
text
@d2349 3
a2351 3
   actual type of ARRAY_PTR is ignored), returns a reference to
   the Ada slice of HIGH-LOW+1 elements starting at index LOW.  The lower
   bound of this array is LOW, as per Ada rules. */
d2353 2
a2354 2
ada_value_slice_ptr (struct value *array_ptr, struct type *type,
                     int low, int high)
d2364 1
a2364 1
  return value_from_pointer (lookup_reference_type (slice_type), base);
d6181 1
a6181 3
   appropriate type.  If ARG is a pointer or reference and the field
   is not packed, returns a reference to the field, otherwise the
   value of the field (an lvalue if ARG is an lvalue).     
d6258 1
a6258 2
            v = value_from_pointer (lookup_reference_type (field_type),
                                    address + byte_offset);
d8808 3
a8810 3
                return ada_value_slice_ptr (array, arr_type0,
                                            longest_to_int (low_bound),
					    longest_to_int (high_bound));
@


1.183
log
@	* ada-lang.c (ada_evaluate_subexp): Improve handling of integer
	type dereferencing.
@
text
@a467 20
/* Create a value of type TYPE whose contents come from VALADDR, if it
   is non-null, and whose memory address (in the inferior) is
   ADDRESS.  */

struct value *
value_from_contents_and_address (struct type *type,
				 const gdb_byte *valaddr,
                                 CORE_ADDR address)
{
  struct value *v = allocate_value (type);
  if (valaddr == NULL)
    set_value_lazy (v, 1);
  else
    memcpy (value_contents_raw (v), valaddr, TYPE_LENGTH (type));
  VALUE_ADDRESS (v) = address;
  if (address != 0)
    VALUE_LVAL (v) = lval_memory;
  return v;
}

@


1.183.2.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a4873 1
			    const struct exec *exec,
@


1.182
log
@gdb
	* varobj.c (value_get_print_value): Include valprint.h.
	(value_get_print_value): Use get_formatted_print_options.
	* value.h (struct value_print_options): Declare.
	(value_print, val_print, common_val_print, val_print_string):
	Update.
	* value.c: Include valprint.h.
	(show_values): Use get_user_print_options.
	(show_convenience): Likewise.
	* valprint.h (prettyprint_arrays, prettyprint_structs): Don't
	declare.
	(struct value_print_options): New type.
	(vtblprint, unionprint, addressprint, objectprint, print_max,
	inspect_it, repeat_count_threshold, output_format,
	stop_print_at_null): Don't declare.
	(user_print_options, get_user_print_options,
	get_raw_print_options, get_formatted_print_options): Declare.
	(print_array_indexes_p): Don't declare.
	(maybe_print_array_index, val_print_array_elements): Update.
	* valprint.c (print_max): Remove.
	(user_print_options): New global.
	(get_user_print_options, get_raw_print_options,
	get_formatted_print_options): New functions.
	(print_array_indexes, repeat_count_threshold, stop_print_at_null,
	prettyprint_structs, prettyprint_arrays, unionprint,
	addressprint): Remove.
	(val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(common_val_print): Likewise.
	(print_array_indexes_p): Remove.
	(maybe_print_array_index): Remove format, pretty arguments; add
	options.  Update.
	(val_print_array_elements): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(val_print_string): Add options argument.  Update.
	(_initialize_valprint): Use user_print_options.
	(output_format): Remove.
	(set_output_radix_1): Use user_print_options.
	* typeprint.c: Include valprint.h.
	(objectprint): Don't declare.
	(whatis_exp): Use get_user_print_options.
	* tui/tui-regs.c: Include valprint.h.
	(tui_register_format): Use get_formatted_print_options.
	* tracepoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(trace_mention): Use get_user_print_options.
	(tracepoints_info): Likewise.
	* stack.c (print_frame_args): Use get_raw_print_options.
	(print_frame_info): Use get_user_print_options.
	(print_frame): Likewise.
	* sh64-tdep.c: Include valprint.h
	(sh64_do_register): Use get_formatted_print_options.
	* scm-valprint.c (scm_inferior_print): Remove format, deref_ref,
	pretty arguments; add options.
	(scm_scmlist_print): Likewise.  Update.
	(scm_scmval_print): Likewise.
	(scm_val_print): Likewise.
	(scm_value_print): Remove format, pretty arguments; add options.
	Update.
	* scm-lang.h (scm_value_print, scm_val_print, scm_scmval_print):
	Update.
	* scm-lang.c (scm_printstr): Add options argument.
	* python/python-value.c: Include valprint.h.
	(valpy_str): Use get_user_print_options.
	* printcmd.c: Include valprint.h.
	(addressprint): Don't declare.
	(inspect_it): Remove.
	(print_formatted): Remove format option; add options.  Update.
	(print_scalar_formatted): Likewise.
	(print_address_demangle): Use get_user_print_options.
	(do_examine): Use get_formatted_print_options.
	(print_command_1): Likewise.
	(output_command): Use get_formatted_print_options.
	(do_one_display): Likewise.
	(print_variable_value): Use get_user_print_options.
	* p-valprint.c (pascal_val_print): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(pascal_value_print): Remove format, pretty arguments; add
	options.  Update.
	(vtblprint, objectprint): Don't declare.
	(pascal_static_field_print): Remove.
	(pascal_object_print_value_fields): Remove format, pretty
	arguments; add options.  Update.
	(pascal_object_print_static_field): Likewise.
	(_initialize_pascal_valprint): Use user_print_options.  Update.
	* p-lang.h (pascal_val_print, pascal_value_print,
	pascal_printstr, pascal_object_print_value_fields): Update.
	(vtblprint, static_field_print): Don't declare.
	* p-lang.c (pascal_printstr): Add options argument.  Update.
	* objc-lang.c (objc_printstr): Add options argument.  Update.
	* mt-tdep.c: Include valprint.h.
	(mt_registers_info): Use get_raw_print_options.
	* mips-tdep.c: Include valprint.h.
	(mips_print_fp_register): Use get_formatted_print_options.
	(mips_print_register): Likewise.
	* mi/mi-main.c: Include valprint.h.
	(get_register): Use get_user_print_options.
	(mi_cmd_data_evaluate_expression): Likewise.
	(mi_cmd_data_read_memory): Use get_formatted_print_options.
	* mi/mi-cmd-stack.c: Include valprint.h.
	(list_args_or_locals): Use get_raw_print_options.
	* m2-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(m2_print_long_set): Remove format, pretty arguments.
	(m2_print_unbounded_array): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(print_unpacked_pointer): Remove format argument; add options.
	Now static.  Update.
	(print_variable_at_address): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(m2_print_array_contents): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* m2-lang.c (m2_printstr): Add options argument. Update.
	* language.h (struct value_print_options): Declare.
	(struct language_defn) <la_printstr>: Add options argument.
	<la_val_print>: Remove format, deref_ref, pretty argument; add
	options.
	<la_value_print>: Remove format, pretty arguments; add options.
	<la_print_array_index>: Likewise.
	(LA_VAL_PRINT, LA_VALUE_PRINT, LA_PRINT_STRING,
	LA_PRINT_ARRAY_INDEX): Update.
	(default_print_array_index): Update.
	* language.c (default_print_array_index): Remove format, pretty
	arguments; add options.  Update.
	(unk_lang_printstr): Add options argument.
	(unk_lang_val_print): Remove format, deref_ref, pretty arguments;
	add options.
	(unk_lang_value_print): Remove format, pretty arguments; add
	options.
	* jv-valprint.c (java_value_print): Remove format, pretty
	arguments; add options.  Update.
	(java_print_value_fields): Likewise.
	(java_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	* jv-lang.h (java_val_print, java_value_print): Declare.
	* infcmd.c: Include valprint.h.
	(print_return_value): Use get_raw_print_options.
	(default_print_registers_info): Use get_user_print_options,
	get_formatted_print_options.
	(registers_info): Use get_formatted_print_options.
	* gdbtypes.h (struct value_print_options): Declare.
	(print_scalar_formatted): Update.
	* f-valprint.c (f77_print_array_1): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Update.
	* f-lang.c (f_printstr): Add options argument.  Update.
	(c_value_print): Update declaration.
	* expprint.c: Include valprint.h.
	(print_subexp_standard): Use get_raw_print_options,
	get_user_print_options.
	* eval.c: Include valprint.h.
	(objectprint): Don't declare.
	(evaluate_subexp_standard): Use get_user_print_options.
	* cp-valprint.c (vtblprint, objectprint, static_field_print):
	Remove.
	(cp_print_value_fields): Remove format, pretty arguments; add
	options.  Update.
	(cp_print_value): Likewise.
	(cp_print_static_field): Likewise.
	(_initialize_cp_valprint): Use user_print_options.  Update.
	* c-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(c_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(c_value_print): Add options argument.  Update.
	* c-lang.h (c_val_print, c_value_print, c_printstr): Update.
	(vtblprint, static_field_print): Don't declare.
	(cp_print_value_fields): Update.
	* c-lang.c (c_printstr): Add options argument.  Update.
	* breakpoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(watchpoint_value_print): Use get_user_print_options.
	(print_one_breakpoint_location): Likewise.
	(breakpoint_1, print_it_catch_fork, print_it_catch_vfork, mention,
	print_exception_catchpoint): Likewise.
	* auxv.c (fprint_target_auxv): Don't declare addressprint.  Use
	get_user_print_options.
	* ada-valprint.c (struct ada_val_print_args): Remove format,
	deref_ref, and pretty; add options.
	(print_optional_low_bound): Add options argument.
	(val_print_packed_array_elements): Remove format and pretty
	arguments; add options.  Update.
	(printstr): Add options argument.  Update.
	(ada_printstr): Likewise.
	(ada_val_print): Remove format, deref_ref, pretty arguments; add
	options argument.  Update.
	(ada_val_print_stub): Update.
	(ada_val_print_array): Remove format, deref_ref, pretty arguments;
	add options.  Update.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Remove format, pretty arguments; add options.
	Update.
	(print_record): Likewise.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print, ada_value_print, ada_printstr):
	Update.
	* ada-lang.c (ada_print_array_index): Add options argument; remove
	format and pretty arguments.
	(print_one_exception): Use get_user_print_options.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add enum formatting tests.
@
text
@d9207 12
a9218 6
      if (TYPE_CODE (type) == TYPE_CODE_INT && expect_type != NULL)
	  /* GDB allows dereferencing an int.  We give it the expected
	     type (which will be set in the case of a coercion or
	     qualification). */
	return ada_value_ind (value_cast (lookup_pointer_type (expect_type),
					  arg1));
@


1.181
log
@        * gdbtypes.c (copy_type): New function.
        * gdbtypes.h (copy_type): Add declaration.
        * ada-lang.c (ada_to_fixed_type_1): If there is a parallel XVZ
        variable, then use it.
@
text
@d356 1
a356 1
                       int format, enum val_prettyprint pretty)
d358 1
a358 1
  LA_VALUE_PRINT (index_value, stream, format, pretty);
d10103 4
a10106 1
  if (addressprint)
@


1.180
log
@        * target.h (struct target_ops): Add new field to_get_ada_task_ptid.
        (target_get_ada_task_ptid): New macro.
        * target.c (default_get_ada_task_ptid): New function.
        (update_current_target): Inherit field default_get_ada_task_ptid.
        (update_current_target): Make default_get_ada_task_ptid the default
        value for field to_get_ada_task_ptid.
        * ada-lang.h (struct task_control_block): Delete. Never used.
        (struct task_ptid, task_ptid_t, struct task_entry, task_list):
        Likewise.
        (struct ada_task_info): New.
        (ada_task_is_alive, ada_find_printable_frame)
        (ada_task_list_iterator_ftype, iterate_over_live_ada_tasks): Add
        declarations.
        (ada_build_task_list): Update prototype.
        (init_task_list, ada_is_exception_breakpoint): Remove prototypes.
        * ada-lang.c (ada_find_printable_frame): Make non-static.
        * ada-tasks.c: New file.
        * Makefile.in (SFILES): Add ada-tasks.c.
        (COMMON_OBS): Add ada-tasks.o.
        * linux-thread-db.c (thread_db_find_thread_from_tid)
        (thread_db_get_ada_task_ptid): New functions.
        (init_thread_db_ops): Set thread_db_ops.to_get_ada_task_ptid.
@
text
@d7360 40
@


1.179
log
@        * breakpoint.h (enum bptype): New enum bp_catchpoint.
        Delete bp_catch_fork and bp_catch_vfork.
        (struct breakpoint_ops): Add new methods "insert", "remove"
        and "breakpoint_hit".
        * breakpoint.c (create_fork_vfork_event_catchpoint)
        (create_fork_event_catchpoint, create_vfork_event_catchpoint): Remove.
        (insert_catchpoint): Remove handling of bp_catch_fork and
        bp_catch_vfork catchpoints, and handle them as bp_catchpoint
        catchpoints instead.
        (insert_bp_location, update_breakpoints_after_exec)
        (remove_breakpoint, bpstat_check_location, bpstat_what)
        (allocate_bp_location): Likewise.
        (print_it_typical, print_one_breakpoint_location, mention): Remove
        handling of bp_catch_fork and bp_catch_vfork breakpoints.
        (ep_is_catchpoint, user_settable_breakpoint)
        (breakpoint_address_is_meaningful, adjust_breakpoint_address)
        (breakpoint_re_set_one, disable_command, enable_command):
        Remove use of bp_catch_fork and bp_catch_vfork.  Add handling of
        bp_catchpoint breakpoints.
        (insert_catch_fork, remove_catch_fork, breakpoint_hit_catch_fork)
        (print_it_catch_fork, print_one_catch_fork, print_mention_catch_fork):
        New functions.
        (catch_fork_breakpoint_ops): New static constant.
        (insert_catch_vfork, remove_catch_vfork, breakpoint_hit_catch_vfork)
        (print_it_catch_vfork, print_one_catch_vfork)
        (print_mention_catch_vfork): New functions.
        (catch_vfork_breakpoint_ops): New static constant.
        (create_catchpoint, create_fork_vfork_event_catchpoint): New functions.
        (catch_fork_command_1): Use create_fork_vfork_event_catchpoint
        to create the fork and vfork catchpoints.
        (gnu_v3_exception_catchpoint_ops): Set new breakpoint_ops fields.
        * ada-lang.c (catch_exception_breakpoint_ops): Set new breakpoint_ops
        fields.
        (catch_exception_unhandled_breakpoint_ops): Likewise.
        (catch_assert_breakpoint_ops): Likewise.
@
text
@d9891 1
a9891 1
static void
@


1.178
log
@        * ada-lang.c (ada_evaluate_subexp) [OP_ATR_SIZE]: Add handling
        of arguments that are references.
@
text
@d10155 3
d10184 3
d10213 3
@


1.177
log
@        * ada-lang.c (is_digits_suffix): Delete unused function.
@
text
@d9059 8
d9073 1
a9073 2
                                   TARGET_CHAR_BIT
                                   * TYPE_LENGTH (value_type (arg1)));
@


1.176
log
@        * ada-lang.c (ada_modulus): Correct to avoid sign problem with
        moduli >= 2**31.
@
text
@a204 2
static int is_digits_suffix (const char *str);

a5022 11
/* Return nonzero if the given string contains only digits.
   The empty string also matches.  */

static int
is_digits_suffix (const char *str)
{
  while (isdigit (str[0]))
    str++;
  return (str[0] == '\0');
}

@


1.175
log
@        * ada-lang.c (ada_lookup_struct_elt_type): Handle case of a "naked"
        variant branch.
        (empty_record): Use INIT_CPLUS_SPECIFIC, since this field is not
        supposed to be null.  Fixes debugger segfaults.
        (is_unchecked_variant): New function.
        (to_fixed_variant_branch_type): Modify to leave unchecked unions
        untouched.
        (ada_template_to_fixed_record_type_1): Fix comment.
@
text
@d9629 1
a9629 1
  return (ULONGEST) TYPE_HIGH_BOUND (type) + 1;
@


1.174
log
@        * ada-lang.c (standard_exc): New static constant.
        (ada_exception_catchpoint_cond_string): Add special handling
        for the predefined exceptions.
@
text
@d6406 5
d6412 7
a6418 2
              t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (field_type, j),
                                              name, 0, 1, &disp);
d6455 14
d6839 1
d6961 1
a6961 1
     odd cases in which it is re-ordered so as NOT the last field of
d7208 2
a7209 1
   indicated in the union's type name.  */
d7229 2
@


1.173
log
@        * ada-lang.c (ADA_RETAIN_DOTS): Delete this dead macro.  Update
        the code accordingly.
@
text
@d9653 9
d10346 29
@


1.172
log
@        * ada-lang.c (ada_evaluate_subexp) [UNOP_IND]: Remove strange
        treatment of expect_type. Return the correct type when dereferencing
        an integer.
@
text
@a59 4
#ifndef ADA_RETAIN_DOTS
#define ADA_RETAIN_DOTS 0
#endif

d813 1
a813 1
      if (!ADA_RETAIN_DOTS && *p == '.')
d1135 1
a1135 2
      else if (!ADA_RETAIN_DOTS
               && i < len0 - 2 && encoded[i] == '_' && encoded[i + 1] == '_')
@


1.171
log
@gdb
	PR gdb/2484:
	* symtab.c (struct add_macro_name_data): New struct.
	(add_macro_name): New function.
	(default_make_symbol_completion_list): Complete macro names.
	* scm-lang.c (scm_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* macrotab.h (macro_callback_fn): Add user_data argument.
	(macro_for_each): Likewise.
	(macro_for_each_in_scope): Declare.
	* macrotab.c: (struct macro_for_each_data): New struct.
	(foreach_macro): Use it.
	(macro_for_each): Likewise.
	(foreach_macro_in_scope): New function.
	(macro_for_each_in_scope): Likewise.
	* macrocmd.c (print_one_macro): Add argument.
	(macro_list_command): Pass NULL to macro_for_each.
	* m2-lang.c (m2_language_defn): Update.
	* language.h (struct language_defn) <la_macro_expansion>: New
	field.
	(macro_expansion): New enum.
	* language.c (unknown_language_defn): Update.  Fix order of
	initializers.
	(auto_language_defn): Likewise.
	(local_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* c-lang.c (c_language_defn): Update.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	* ada-lang.c (ada_language_defn): Update.
gdb/testsuite
	* gdb.base/macscp.exp: Add completion tests.
	* gdb.base/macscp1.c (FIFTY_SEVEN): New macro.
	(TWENTY_THREE): Likewise.
	(FORTY_EIGHT): Likewise.
@
text
@d9106 1
a9106 3
      if (expect_type && TYPE_CODE (expect_type) == TYPE_CODE_PTR)
        expect_type = TYPE_TARGET_TYPE (ada_check_typedef (expect_type));
      arg1 = evaluate_subexp (expect_type, exp, pos, noside);
d9132 12
a9143 3
            /* GDB allows dereferencing an int.  */
            return value_zero (builtin_type (exp->gdbarch)->builtin_int,
			       lval_memory);
d9150 7
a9159 4
      else if (TYPE_CODE (type) == TYPE_CODE_INT)
	/* GDB allows dereferencing an int.  */
	return value_at_lazy (builtin_type (exp->gdbarch)->builtin_int,
			      (CORE_ADDR) value_as_address (arg1));
@


1.170
log
@gdb
	* scm-lang.c (scm_language_defn): Update.
	* p-typeprint.c (pascal_print_typedef): New function.
	* p-lang.h: (pascal_print_typedef): Declare.
	* p-lang.c (pascal_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* m2-typeprint.c (m2_print_typedef): New function.
	* m2-lang.h (m2_print_typedef): Declare.
	* m2-lang.c (m2_language_defn): Update.
	* language.h (_LANG_c, _LANG_m2, _LANG_fortran, _LANG_pascal):
	Remove.
	(struct language_defn) <la_print_typedef>: New field.
	(default_print_typedef): Declare.
	(LA_PRINT_TYPEDEF): New define.
	* language.c (unknown_language_defn): Update.
	(auto_language_defn): Update.
	(local_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* c-typeprint.c (c_print_typedef): New function.
	* c-lang.h (c_print_typedef): Declare.
	* c-lang.c (c_language_defn): Update.
	(cplus_language_defn): Update.
	(asm_language_defn): Update.
	(minimal_language_defn): Update.
	* ada-lang.c (ada_language_defn): Update.
	* typeprint.c (default_print_typedef): New function.
gdb/doc
	* gdbint.texinfo (Language Support): Remove text about omitting
	support for a language.
@
text
@d10938 1
@


1.169
log
@        * ada-lang.c (remove_extra_symbols): Remove stub symbols if
        the associated complete symbol is also in the list.
        (ada_add_local_symbols, ada_add_non_local_symbols): New functions,
        extracted out from ada_lookup_symbol_list.
        (ada_lookup_symbol_list): Use them.  Remove the search through
        the minimal symbols.
@
text
@d10946 1
@


1.168
log
@	* ada-lang.c (ada_coerce_to_simple_array_type): Use builtin_type_int32
	instead of builtin_type_int as default unspecified integral type.
	(ada_index_type, ada_array_bound_from_type, ada_variant_discrim_type,
	assign_component, to_fixed_range_type): Likewise.
	* ada-typeprint.c (print_range, print_range_bound,
	print_range_type_named): Likewise.
	* ada-valprint.c (print_optional_low_bound, ada_val_print_1): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Likewise.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	build_gdb_vtable_type): Likewise.
	* jv-lang.c (java_array_type): Likewise.
	* m2-typeprint.c (m2_print_bounds, m2_is_long_set_of_type): Likewise.
	* m2-valprint.c (m2_print_long_set): Likewise.
	* parse.c (follow_types): Likewise.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* valops.c (value_one, value_array, value_string,
	value_bitstring): Likewise.
	* value.c (allocate_repeat_value, value_from_string): Likewise.
	* varobj.c (c_describe_child): Likewise.
	* mt-tdep.c (mt_register_type): Likewise.
	* sh-tdep.c (sh_sh4_build_float_register_type): Likewise.
	* sh64-tdep.c (sh64_build_float_register_type): Likewise.
@
text
@d4399 23
a4421 1
      if (SYMBOL_LINKAGE_NAME (syms[i].sym) != NULL
d4434 1
a4434 7
                {
                  int k;
                  for (k = i + 1; k < nsyms; k += 1)
                    syms[k - 1] = syms[k];
                  nsyms -= 1;
                  goto NextSymbol;
                }
d4437 8
a4445 2
    NextSymbol:
      ;
d4675 64
a4758 4
  struct symtab *s;
  struct partial_symtab *ps;
  struct blockvector *bv;
  struct objfile *objfile;
a4760 1
  struct minimal_symbol *msymbol;
a4762 1
  int block_depth;
d4777 8
d4792 1
a4792 22
  block_depth = 0;
  while (block != NULL)
    {
      block_depth += 1;
      ada_add_block_symbols (&symbol_list_obstack, block, name,
                             namespace, NULL, wild_match);

      /* If we found a non-function match, assume that's the one.  */
      if (is_nonfunction (defns_collected (&symbol_list_obstack, 0),
                          num_defns_collected (&symbol_list_obstack)))
        goto done;

      block = BLOCK_SUPERBLOCK (block);
    }

  /* If no luck so far, try to find NAME as a local symbol in some lexically
     enclosing subprogram.  */
  if (num_defns_collected (&symbol_list_obstack) == 0 && block_depth > 2)
    add_symbols_from_enclosing_procs (&symbol_list_obstack,
                                      name, namespace, wild_match);

  /* If we found ANY matches among non-global symbols, we're done.  */
d4794 2
d4799 4
d4811 4
a4814 75
  /* Now add symbols from all global blocks: symbol tables, minimal symbol
     tables, and psymtab's.  */

  ALL_PRIMARY_SYMTABS (objfile, s)
  {
    QUIT;
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    ada_add_block_symbols (&symbol_list_obstack, block, name, namespace,
                           objfile, wild_match);
  }

  if (namespace == VAR_DOMAIN)
    {
      ALL_MSYMBOLS (objfile, msymbol)
      {
        if (ada_match_name (SYMBOL_LINKAGE_NAME (msymbol), name, wild_match))
          {
            switch (MSYMBOL_TYPE (msymbol))
              {
              case mst_solib_trampoline:
                break;
              default:
                s = find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol));
                if (s != NULL)
                  {
                    int ndefns0 = num_defns_collected (&symbol_list_obstack);
 		    char *raw_name = SYMBOL_LINKAGE_NAME (msymbol);
 		    char *name1;
 		    const char *suffix;
                    QUIT;
 		    suffix = strrchr (raw_name, '.');
 		    if (suffix == NULL)
 		      suffix = strrchr (raw_name, '$');
 		    if (suffix != NULL && is_digits_suffix (suffix + 1))
 		      {
 			name1 = alloca (suffix - raw_name + 1);
 			strncpy (name1, raw_name, suffix - raw_name);
 			name1[suffix - raw_name] = '\0';
 		      }
 		    else
 		      name1 = raw_name;
 			
                    bv = BLOCKVECTOR (s);
                    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
                    ada_add_block_symbols (&symbol_list_obstack, block,
                                           name1, namespace, objfile, 0);

                    if (num_defns_collected (&symbol_list_obstack) == ndefns0)
                      {
                        block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
                        ada_add_block_symbols (&symbol_list_obstack, block,
                                               name1, namespace, objfile, 0);
                      }
                  }
              }
          }
      }
    }

  ALL_PSYMTABS (objfile, ps)
  {
    QUIT;
    if (!ps->readin
        && ada_lookup_partial_symbol (ps, name, 1, namespace, wild_match))
      {
        s = PSYMTAB_TO_SYMTAB (ps);
        if (!s->primary)
          continue;
        bv = BLOCKVECTOR (s);
        block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
        ada_add_block_symbols (&symbol_list_obstack, block, name,
                               namespace, objfile, wild_match);
      }
  }
d4817 1
a4817 2
     (Not strictly correct, but perhaps better than an error).
     Do the symtabs first, then check the psymtabs.  */
d4820 2
a4821 27
    {

      ALL_PRIMARY_SYMTABS (objfile, s)
      {
        QUIT;
        bv = BLOCKVECTOR (s);
        block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
        ada_add_block_symbols (&symbol_list_obstack, block, name, namespace,
                               objfile, wild_match);
      }

      ALL_PSYMTABS (objfile, ps)
      {
        QUIT;
        if (!ps->readin
            && ada_lookup_partial_symbol (ps, name, 0, namespace, wild_match))
          {
            s = PSYMTAB_TO_SYMTAB (ps);
            bv = BLOCKVECTOR (s);
            if (!s->primary)
              continue;
            block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
            ada_add_block_symbols (&symbol_list_obstack, block, name,
                                   namespace, objfile, wild_match);
          }
      }
    }
@


1.167
log
@	* ada-lang.c (value_pos_atr): Add TYPE argument.  Use it as
	result type instead of builtin_type_int.
	(value_subscript_packed): Use pos_atr instead of value_pos_atr.
	(ada_value_subscript): Update call to value_pos_atr.
	(ada_value_ptr_subscript): Likewise.
	(ada_evaluate_subexp): Likewise.
@
text
@d1762 1
a1762 1
  struct value *dummy = value_from_longest (builtin_type_long, 0);
d2503 1
a2503 1
        result_type = builtin_type_int;
d2531 1
a2531 1
        *typep = builtin_type_int;
d5845 1
a5845 1
    return builtin_type_int;
d8057 1
a8057 1
      struct value *index_val = value_from_longest (builtin_type_int, index);
d9507 1
a9507 1
    base_type = builtin_type_int;
@


1.166
log
@	* ada-lang.c (cast_to_fixed): Do not cast to builtin_type_double.
	(cast_from_fixed_to_double): Rename to ...
	(cast_from_fixed): ... this.  Add TYPE parameter.  Use it instead
	of builtin_type_double.
	(ada_value_cast): Use cast_from_fixed instead of casting result
	of cast_from_fixed_to_double.
	(ada_evaluate_subexp): Update calls to cast_from_fixed_to_double.
@
text
@d217 1
a217 1
static struct value *value_pos_atr (struct value *);
d1962 1
a1962 1
          idx = value_as_long (value_pos_atr (ind[i]));
d2338 1
a2338 1
      elt = value_subscript (elt, value_pos_atr (ind[k]));
d2363 1
a2363 1
      idx = value_pos_atr (ind[k]);
d7601 1
a7601 1
value_pos_atr (struct value *arg)
d7603 1
a7603 1
  return value_from_longest (builtin_type_int, pos_atr (arg));
d9065 3
a9067 2
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (builtin_type_int, not_lval);
d9069 1
a9069 1
        return value_pos_atr (arg1);
@


1.165
log
@	* valops.c (value_ind): No longer allow dereferencing an
	integer type.
	* eval.c (evaluate_subexp_standard): Handle deferencing an
	integer type here.
	* ada-lang.c (ada_evaluate_subexp): Likewise.
@
text
@d7885 1
a7885 2
      DOUBLEST argd =
        value_as_double (value_cast (builtin_type_double, value_copy (arg)));
d7893 1
a7893 1
cast_from_fixed_to_double (struct value *arg)
d7897 1
a7897 1
  return value_from_double (builtin_type_double, val);
d8351 1
a8351 1
    return value_cast (type, cast_from_fixed_to_double (arg2));
d8501 1
d8503 1
a8503 1
            arg1 = cast_from_fixed_to_double (arg1);
d8505 1
a8505 1
            arg2 = cast_from_fixed_to_double (arg2);
@


1.164
log
@	* eval.c (evaluate_subexp_standard): Use builtin_type_int8
	to construct the EVAL_SKIP dummy return value.
	* ada-lang.c (ada_evaluate_subexp): Likewise.
	* jv-lang.c (evaluate_subexp_java): Likewise.
	* m2-lang.c (evaluate_subexp_modula2): Likewise.
	* scm-lang.c (evaluate_exp): Likewise.
@
text
@d9158 2
a9159 1
            return value_zero (builtin_type_int, lval_memory);
d9169 4
@


1.163
log
@	* eval.c (evaluate_subexp_standard): Add calls to binop_promote
	and unop_promote before calling value_binop et. al.
	* ada-lang.c (ada_evaluate_subexp): Add calls to binop_promote
	and unop_promote before calling value_binop et. al.

	* valarith.c (value_binop): Do not call binop_promote or unop_promote.
	(value_pos): Do not call unop_promote.
	(value_neg, value_complement): Likewise.
@
text
@d9241 1
a9241 1
  return value_from_longest (builtin_type_long, (LONGEST) 1);
@


1.162
log
@	* value.h (value_add, value_sub): Remove.
	(value_ptradd, value_ptrsub, value_ptrdiff): Add prototypes.
	* valarith.c (value_add, value_sub): Remove.
	(value_ptradd, value_ptrsub, value_ptrdiff): New functions.
	(find_size_for_pointer_math): Add assertion.  Update comment.
	(value_binop): Update comment.

	* eval.c (ptrmath_type_p): New function.
	(evaluate_subexp_standard): Replace value_add and value_sub
	by value_ptradd, value_ptrsub, value_ptrdiff or value_binop.
	Use builtin_type_uint8 instead of builtin_type_char to hold
	the increment for BINOP_{PRE,POST}{IN,DE}CREMENT operations.
	* valarith.c (value_subscript): Replace value_add by
	value_ptradd.  Replace value_sub by value_binop.
	* ada-lang.c (ada_value_ptr_subscript): Likewise.
	(ada_tag_name_2): Replace value_add by value_ptradd.
	(ada_evaluate_subexp): Replace value_add and value_sub by
	value_binop.
	* m2-lang.c (evaluate_subexp_modula2): Replace value_add
	by value_ptradd.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Likewise.
	* gnu-v3-abi.c (gnuv3_method_ptr_to_value): Likewise.
@
text
@d8466 1
d8488 1
d8506 1
d8520 4
a8523 1
        return ada_value_binop (arg1, arg2, op);
d8534 4
a8537 1
        tem = ada_value_equal (arg1, arg2);
d8550 4
a8553 1
        return value_neg (arg1);
d8838 2
d8871 2
d8889 2
d9038 5
a9042 2
        return value_binop (arg1, arg2,
                            op == OP_ATR_MIN ? BINOP_MIN : BINOP_MAX);
d9100 10
a9109 1
        return value_binop (arg1, arg2, op);
d9122 1
@


1.161
log
@	* language.h (struct language_arch_info): New members
	bool_type_default and bool_type_symbol.
	(lang_bool_type): Remove prototype.
	(LA_BOOL_TYPE): Remove macro.
	(language_bool_type): Add prototype.
	* language.c (lang_bool_type): Remove.
	(language_bool_type): New function.

	* value.h (value_in): Change return value to int.
	* value.c (value_in): Return int instead of struct value *.

	* eval.c (evaluate_subexp_standard): Call language_bool_type instead
	of using LA_BOOL_TYPE.  Update call to value_in.
	* ada-lang.c (ada_evaluate_subexp): Call language_bool_type instead
	of using LA_BOOL_TYPE or builtin_type_int for boolean values.

	* language.c (unknown_language_arch_info): Set bool_type_default member
	of struct language_arch_info.
	* ada-lang.c (ada_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* c-lang.c (c_language_arch_info): Set bool_type_default member
	of struct language_arch_info.
	(cplus_language_arch_info): Set bool_type_symbol and bool_type_default
	members of struct language_arch_info.
	* f-lang.c (f_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* jv-lang.c (java_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* m2-lang.c (m2_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* p-lang.c (p_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
@
text
@d2365 4
a2368 2
        idx = value_sub (idx, value_from_longest (builtin_type_int, lwb));
      arr = value_add (arr, idx);
d5731 2
a5732 1
  val = value_ind (value_add (valp, value_from_longest (builtin_type_int, -1)));
d8466 1
a8466 1
      return value_cast (type, value_add (arg1, arg2));
d8487 1
a8487 1
      return value_cast (type, value_sub (arg1, arg2));
@


1.160
log
@        * ada-lang.c (ada_parent_type): Add handling of the case where
        the _parent field is a pointer and/or has a parallel XVS type.
        (ada_evaluate_subexp) [OP_VAR_VALUE]: When doing an
        EVAL_AVOID_SIDE_EFFECTS evaluation of a tagged type, return
        the type of the tag instead of doing forcing an EVAL_NORMAL
        expression evaluation.
@
text
@d8528 2
a8529 1
      return value_from_longest (LA_BOOL_TYPE, (LONGEST) tem);
d8548 2
a8549 1
        return value_cast (LA_BOOL_TYPE, val);
d8817 2
a8818 1
          return value_from_longest (builtin_type_int, (LONGEST) 1);
d8823 3
a8825 2
          return
            value_from_longest (builtin_type_int,
d8841 4
a8844 1
        return value_zero (builtin_type_int, not_lval);
d8854 1
d8856 1
a8856 1
        value_from_longest (builtin_type_int,
d8870 1
d8872 1
a8872 1
        value_from_longest (builtin_type_int,
d10884 3
@


1.159
log
@        * ada-lang.c (is_digits_suffix): New function.
        (is_dot_digits_suffix): Remove.
        (ada_lookup_symbol_list): Remove digits suffix from minimal symbols
        before looking up in symbol table, and do not use wild matches on them.
        (wild_match): Reimplement for speed and to allow matching of operator
        symbols.
        (is_valid_name_for_wild_match): Return zero for names that do not
        follow the GNAT encoding.

        (is_name_suffix): Fix typo in comment.
        (to_record_with_fixed_variant_part): Ditto.
@
text
@d5772 11
a5782 1
      return ada_check_typedef (TYPE_FIELD_TYPE (type, i));
a8565 8
      /* Tagged types are a little special in the fact that the real type
         is dynamic and can only be determined by inspecting the object
         value.  So even if we're support to do an EVAL_AVOID_SIDE_EFFECTS
         evaluation, we force an EVAL_NORMAL evaluation for tagged types.  */
      if (noside == EVAL_AVOID_SIDE_EFFECTS
          && ada_is_tagged_type (SYMBOL_TYPE (exp->elts[pc + 2].symbol), 1))
        noside = EVAL_NORMAL;

d8579 24
@


1.158
log
@        * ada-lang.c (ada_evaluate_subexp) [OP_ATR_SIZE]: Use
        archecture-neutral builtin_type_int32 instead of builtin_type_int.
@
text
@d209 2
d4763 3
d4767 12
d4782 1
a4782 2
                                           SYMBOL_LINKAGE_NAME (msymbol),
                                           namespace, objfile, wild_match);
d4788 1
a4788 3
                                               SYMBOL_LINKAGE_NAME (msymbol),
                                               namespace, objfile,
                                               wild_match);
d4915 1
a4915 1
   are given by either of the regular expression:
d5052 2
a5053 10
/* Return nonzero if the given string starts with a dot ('.')
   followed by zero or more digits.  
   
   Note: brobecker/2003-11-10: A forward declaration has not been
   added at the begining of this file yet, because this function
   is only used to work around a problem found during wild matching
   when trying to match minimal symbol names against symbol names
   obtained from dwarf-2 data.  This function is therefore currently
   only used in wild_match() and is likely to be deleted when the
   problem in dwarf-2 is fixed.  */
d5056 1
a5056 1
is_dot_digits_suffix (const char *str)
a5057 4
  if (str[0] != '.')
    return 0;

  str++;
d5072 6
d5093 4
a5096 55
  int name_len;
  char *name;
  char *name_start;
  char *patn;

  /* FIXME: brobecker/2003-11-10: For some reason, the symbol name
     stored in the symbol table for nested function names is sometimes
     different from the name of the associated entity stored in
     the dwarf-2 data: This is the case for nested subprograms, where
     the minimal symbol name contains a trailing ".[:digit:]+" suffix,
     while the symbol name from the dwarf-2 data does not.

     Although the DWARF-2 standard documents that entity names stored
     in the dwarf-2 data should be identical to the name as seen in
     the source code, GNAT takes a different approach as we already use
     a special encoding mechanism to convey the information so that
     a C debugger can still use the information generated to debug
     Ada programs.  A corollary is that the symbol names in the dwarf-2
     data should match the names found in the symbol table.  I therefore
     consider this issue as a compiler defect.

     Until the compiler is properly fixed, we work-around the problem
     by ignoring such suffixes during the match.  We do so by making
     a copy of PATN0 and NAME0, and then by stripping such a suffix
     if present.  We then perform the match on the resulting strings.  */
  {
    char *dot;
    name_len = strlen (name0);

    name = name_start = (char *) alloca ((name_len + 1) * sizeof (char));
    strcpy (name, name0);
    dot = strrchr (name, '.');
    if (dot != NULL && is_dot_digits_suffix (dot))
      *dot = '\0';

    patn = (char *) alloca ((patn_len + 1) * sizeof (char));
    strncpy (patn, patn0, patn_len);
    patn[patn_len] = '\0';
    dot = strrchr (patn, '.');
    if (dot != NULL && is_dot_digits_suffix (dot))
      {
        *dot = '\0';
        patn_len = dot - patn;
      }
  }

  /* Now perform the wild match.  */

  name_len = strlen (name);
  if (name_len >= patn_len + 5 && strncmp (name, "_ada_", 5) == 0
      && strncmp (patn, name + 5, patn_len) == 0
      && is_name_suffix (name + patn_len + 5))
    return 1;

  while (name_len >= patn_len)
d5098 10
a5107 26
      if (strncmp (patn, name, patn_len) == 0
          && is_name_suffix (name + patn_len))
        return (name == name_start || is_valid_name_for_wild_match (name0));
      do
        {
          name += 1;
          name_len -= 1;
        }
      while (name_len > 0
             && name[0] != '.' && (name[0] != '_' || name[1] != '_'));
      if (name_len <= 0)
        return 0;
      if (name[0] == '_')
        {
          if (!islower (name[2]))
            return 0;
          name += 2;
          name_len -= 2;
        }
      else
        {
          if (!islower (name[1]))
            return 0;
          name += 1;
          name_len -= 1;
        }
a5108 2

  return 0;
d7082 3
a7084 3
   whose address in memory is ADDRESS, returns a revision of TYPE --
   a non-dynamic-sized record with a variant part -- in which
   the variant part is replaced with the appropriate branch.  Looks
@


1.157
log
@        * ada-lang.c (ada_evaluate_subexp) [BINOP_ADD, BINOP_SUB]:
        Add special handling for pointer types.
@
text
@d9077 1
a9077 1
        return value_zero (builtin_type_int, not_lval);
d9079 1
a9079 1
        return value_from_longest (builtin_type_int,
@


1.156
log
@	* ada-lang.c (ada_array_length): Use builtin_type_int32 instead
	of builtin_type_int.
	(ada_evaluate_subexp) [UNOP_IN_RANGE]: Use operand range type
	instead of builtin_type_int.
@
text
@d8500 4
d8521 4
@


1.155
log
@	* breakpoint.h (struct bp_location): Change type of section
	member to "struct obj_section *".
	* tracepoint.h (struct tracepoint): Likewise.
	* symtab.h (struct general_symbol_info): Replace bfd_section
	member with obj_section.
	(struct symtab_and_line): Change type of section member to
	"struct obj_section *".
	(SYMBOL_BFD_SECTION): Remove macro, replace by ...
	(SYMBOL_OBJ_SECTION): ... this.

	* minsym.c (prim_record_minimal_symbol_and_info): Record symbol
	section as obj_section instead of bfd_section.

	* ada-lang.c (ada_decode_symbol): Use gsymbol->obj_section
	directly instead of looking of obj_section from bfd_section.

	* objfiles.h (find_pc_sect_section): Remove.
	* objfiles.c (find_pc_sect_section): Remove.
	(find_pc_section): Inline find_pc_sect_section code.

	* symfile.h (find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(section_is_overlay, section_is_mapped): Change type of section
	argument to struct obj_section *.
	(pc_in_mapped_range, pc_in_unmapped_range): Likewise.
	(overlay_mapped_address, overlay_unmapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	* symtab.h (symbol_overlayed_address): Likewise.
	* symfile.c (overlay_is_mapped): Remove.
	(section_is_mapped): Inline overlay_is_mapped code.  Update.
	(overlay_invalidate_all): Update.
	(section_is_overlay): Change section argument to type
	"struct obj_section *".  Use bfd_ methods.
	(pc_in_unmapped_range): Likewise.  Handle relocated sections.
	(pc_in_mapped_range): Likewise.  Handle relocated sections.
	(sections_overlap): Likewise.
	(overlay_unmapped_address): Likewise.
	(overlay_mapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	(find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(list_overlays_command): Update.
	(map_overlay_command, unmap_overlay_command): Update.
	(simple_overlay_update): Update.

	* block.h (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* block.c (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* symtab.h (find_pc_sect_function, find_pc_sect_psymtab,
	find_pc_sect_symtab, find_pc_sect_psymbol, find_pc_sect_line,
	lookup_minimal_symbol_by_pc_section, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.
	* blockframe.c (find_pc_sect_function): Likewise.
	* breakpoint.c (describe_other_breakpoints): Likewise.
	(breakpoint_has_pc, check_duplicates_for): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_minimal_symbol_by_pc_section): Likewise.
	* symtab.c (find_pc_sect_psymtab_closer): Likewise.
	(find_pc_sect_psymtab, find_pc_sect_psymbol, find_pc_sect_symtab,
	find_pc_sect_line, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.

	* blockframe.c (find_pc_partial_function): Update to section
	type changes.  No longer call find_pc_sect_section.
	(cache_pc_function_section): Change to type "struct obj_section *".
	* breakpoint.c (resolve_sal_pc): Update to section type changes.
	* exec.c (xfer_memory): Likewise.
	* findvar.c (read_var_value): Likewise.
	* infcmd.c (jump_command): Likewise.
	* linespec.c (minsym_found): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_solib_trampoline_symbol_by_pc): Likewise.
	* parse.c (write_exp_msymbol): Likewise.
	* printcmd.c (build_address_symbolic): Likewise.
	(address_info, sym_info): Likewise.
	* symmisc.c (dump_msymbols, print_symbol): Likewise.
	* symtab.c (fixup_section): Likewise.
	(fixup_symbol_section, fixup_psymbol_section): Likewise.
	(find_pc_line, find_function_start_sal): Likewise.
	* target.c (memory_xfer_partial): Likewise.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline): Likewise.
	* spu-tdep.c (spu_overlay_update): Likewise.
@
text
@d2624 1
a2624 1
      value_from_longest (builtin_type_int,
d8845 2
a8846 3
          arg2 = value_from_longest (builtin_type_int, TYPE_LOW_BOUND (type));
          arg3 = value_from_longest (builtin_type_int,
                                     TYPE_HIGH_BOUND (type));
@


1.154
log
@gdb:
	* xml-tdesc.c (tdesc_end_union): Update.
	* stabsread.c (define_symbol): Update.
	(read_type): Update.
	(read_struct_type): Update.
	(read_enum_type): Update.
	* spu-tdep.c (spu_builtin_type_vec128): Update.
	* sh-tdep.c (sh_push_dummy_call_fpu): Update.
	(sh_push_dummy_call_nofpu): Update.
	* mdebugread.c (parse_symbol): Update.
	(parse_symbol): Update.
	(parse_symbol): Update.
	(upgrade_type): Update.
	* jv-lang.c (java_lookup_class): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address): Update.
	* i386-tdep.c (i386_mmx_type): Update.
	(i386_sse_type): Update.
	* gdbtypes.h (enum type_flag_value): New enum.
	(enum type_instance_flag_value): New enum.
	(TYPE_FLAG_UNSIGNED, TYPE_FLAG_NOSIGN, TYPE_FLAG_STUB,
	TYPE_FLAG_TARGET_STUB, TYPE_FLAG_STATIC, TYPE_FLAG_PROTOTYPED,
	TYPE_FLAG_INCOMPLETE, TYPE_FLAG_VARARGS, TYPE_FLAG_VECTOR,
	TYPE_FLAG_FIXED_INSTANCE, TYPE_FLAG_STUB_SUPPORTED,
	TYPE_FLAG_NOTTEXT): Now enum constants.
	(TYPE_FLAG_CONST, TYPE_FLAG_VOLATILE, TYPE_FLAG_CODE_SPACE,
	TYPE_FLAG_DATA_SPACE, TYPE_FLAG_ADDRESS_CLASS_1,
	TYPE_FLAG_ADDRESS_CLASS_2): Remove.
	(TYPE_INSTANCE_FLAG_CONST, TYPE_INSTANCE_FLAG_VOLATILE,
	TYPE_INSTANCE_FLAG_CODE_SPACE, TYPE_INSTANCE_FLAG_DATA_SPACE,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2): New constants.
	(TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB, TYPE_TARGET_STUB,
	TYPE_STATIC, TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_VARARGS,
	TYPE_VECTOR, TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED,
	TYPE_NOTTEXT): Update.
	(TYPE_FLAG_ADDRESS_CLASS_ALL): Remove.
	(TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL): New define.
	(TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE,
	TYPE_ADDRESS_CLASS_1, TYPE_ADDRESS_CLASS_2,
	TYPE_ADDRESS_CLASS_ALL): Update.
	(struct main_type) <flags>: Remove.
	<flag_unsigned, flag_nosign, flag_stub, flag_target_stub,
	flag_static, flag_prototyped, flag_incomplete, flag_varargs,
	flag_vector, flag_stub_supported, flag_nottext,
	flag_fixed_instance>: New fields.
	<nfields, vptr_fieldno>: Move earlier.
	(TYPE_FLAGS): Remove.
	* gdbtypes.c (make_pointer_type): Update.
	(address_space_name_to_int): Update.
	(address_space_int_to_name): Update.
	(make_type_with_address_space): Update.
	(make_cv_type): Update.
	(create_range_type): Update.
	(get_discrete_bounds): Update.
	(create_set_type): Update.
	(make_vector_type): Update.
	(smash_to_method_type): Update.
	(check_typedef): Update.
	(check_stub_method): Update.
	(init_type): Individually assign flag fields.
	(recursive_dump_type): Don't print entire TYPE_FLAGS field.  Do
	print TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED, and TYPE_NOTTEXT.
	(copy_type_recursive): Copy the entire main type.  Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-altivec64l.c
	(initialize_tdesc_powerpc_altivec64l): Update.
	* features/rs6000/powerpc-altivec64.c
	(initialize_tdesc_powerpc_altivec64): Update.
	* features/rs6000/powerpc-altivec32l.c
	(initialize_tdesc_powerpc_altivec32l): Update.
	* features/rs6000/powerpc-altivec32.c
	(initialize_tdesc_powerpc_altivec32): Update.
	* features/rs6000/powerpc-7400.c (initialize_tdesc_powerpc_7400):
	Update.
	* features/arm-with-iwmmxt.c (initialize_tdesc_arm_with_iwmmxt):
	Update.
	* dwarf2read.c (read_structure_type): Update.
	(read_enumeration_type): Likewise.
	(process_enumeration_scope): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_base_type): Likewise.
	* coffread.c (coff_read_enum_type): Update.
	* ada-valprint.c (adjust_type_signedness): Update.
	* ada-typeprint.c (print_record_field_types): Update.
	* ada-lang.c (packed_array_type): Update.
	(empty_record): Don't reset TYPE_FLAGS.
	(ada_template_to_fixed_record_type_1): Update.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_record_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_static_fixed_type): Likewise.
gdb/testsuite:
	* gdb.base/maint.exp: Update "maint print type".
@
text
@d1206 1
a1206 1
      if (gsymbol->bfd_section != NULL)
d1208 3
a1210 14
          bfd *obfd = gsymbol->bfd_section->owner;
          if (obfd != NULL)
            {
              struct objfile *objf;
              ALL_OBJFILES (objf)
              {
                if (obfd == objf->obfd)
                  {
                    *resultp = obsavestring (decoded, strlen (decoded),
                                             &objf->objfile_obstack);
                    break;
                  }
              }
            }
@


1.153
log
@* ada-lang.c (discrete_type_high_bound,discrete_type_low_bound): Change
API to return LONGEST values rather than struct values.
(ada_evaluate_subexp): Change to use new API of discrete_type_low_bound
and discrete_type_high_bound.
(to_fixed_range_type): Create a range type in cases where
argument is base type and its limits are representable as ints.
(ada_is_modular_type): Correct so that base type must be integral.
* ada-lex.l (TRUEKEYWORD,FALSEKEYWORD): Make 'true' and 'false'
keywords when they appear alone, since we are phasing out
direct representation of these identifiers in ebugging data.
* ada-exp.y: Define 'true' and 'false' as primaries.
(type_boolean): New function.
(type_int,type_long,type_long_long,type_floattype_double)
(type_long_double): Remove uses of current_gdbarch for consistency
with type_boolean.
(write_int): Change comment to indicate that it might write boolean
constant as well.
* ada-typeprint.c (ada_print_type): Print '(false, true)' for boolean
type, since will no longer be represented as enumerated type in
debugging data.
* ada-valprint.c (print_optional_low_bound): Handle boolean case
as well.
@
text
@d1832 1
a1832 1
  TYPE_FLAGS (new_type) |= TYPE_FLAG_FIXED_INSTANCE;
a6904 1
  TYPE_FLAGS (type) = 0;
d6964 1
a6964 1
  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE;
d7144 1
a7144 1
          TYPE_FLAGS (type) |= TYPE_FLAG_FIXED_INSTANCE;
d7189 1
a7189 1
  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE;
d7244 1
a7244 1
  if (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE)
d7260 1
a7260 1
      TYPE_FLAGS (type0) |= TYPE_FLAG_FIXED_INSTANCE;
d7325 1
a7325 1
      || (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE))
d7385 1
a7385 1
  TYPE_FLAGS (result) |= TYPE_FLAG_FIXED_INSTANCE;
d7475 1
a7475 1
  if (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE)
@


1.152
log
@(pos_atr): Account for the possibility that the argument may be a reference.
@
text
@d624 1
a624 1
static struct value *
d630 1
a630 2
      return value_from_longest (TYPE_TARGET_TYPE (type),
                                 TYPE_HIGH_BOUND (type));
d632 4
a635 4
      return
        value_from_longest (type,
                            TYPE_FIELD_BITPOS (type,
                                               TYPE_NFIELDS (type) - 1));
d637 1
a637 1
      return value_from_longest (type, max_of_type (type));
d644 1
a644 1
static struct value *
d650 1
a650 2
      return value_from_longest (TYPE_TARGET_TYPE (type),
                                 TYPE_LOW_BOUND (type));
d652 4
a655 1
      return value_from_longest (type, TYPE_FIELD_BITPOS (type, 0));
d657 1
a657 1
      return value_from_longest (type, min_of_type (type));
d8981 2
a8982 1
                return discrete_type_low_bound (range_type);
d8984 2
a8985 1
                return discrete_type_high_bound (range_type);
d9506 10
a9515 1
    return raw_type;
d9602 1
a9602 1
          && TYPE_CODE (subranged_type) != TYPE_CODE_ENUM
@


1.151
log
@gdb
	* symfile.c (reread_symbols): Don't pass argument to observer.
	* exec.c (exec_file_attach): Don't pass argument to observer.
	* ada-lang.c (ada_executable_changed_observer): Remove argument.
	* symtab.c (symtab_observer_executable_changed): Remove argument.
	* observer.sh: Handle functions with no arguments.
gdb/doc
	* observer.texi (GDB Observers): Remove obsolete comment.
	<executable_changed>: Remove argument.
@
text
@d7637 2
a7638 1
  struct type *type = value_type (arg);
d7646 1
a7646 1
      LONGEST v = value_as_long (arg);
d7656 1
a7656 1
    return value_as_long (arg);
@


1.150
log
@	* block.c (block_function): Renamed to ...
	(block_linkage_function): ... this.  All callers changed.
	* block.h (block_function): Renamed to ...
	(block_linkage_function): ... this.
@
text
@d9772 1
a9772 1
ada_executable_changed_observer (void *unused)
@


1.149
log
@ada_value_assign: Correct big-endian case to take into account the bitsize
  of the 'from' operand.
@
text
@d4628 1
a4628 1
  current_function = block_function (current_block);
d6724 1
a6724 1
  const struct symbol *function_sym = block_function (block);
@


1.148
log
@	* symtab.h (enum address_class): Remove LOC_REGPARM and
	LOC_COMPUTED_ARG.
	(struct symbol): Add is_argument.
	(SYMBOL_IS_ARGUMENT): Define.

	* ada-lang.c (ada_add_block_symbols): Use SYMBOL_IS_ARGUMENT.
	* buildsym.c (finish_block): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals)
	(print_frame_arg_vars): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (add_local_symbols): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.

	* coffread.c (process_coff_symbol): Set SYMBOL_IS_ARGUMENT.
	* dwarf2read.c (new_symbol): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.

	* ada-exp.y (select_possible_type_sym): Don't handle LOC_REGPARM
	and LOC_COMPUTED_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* eval.c (evaluate_subexp_for_address): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (collect_symbol, scope_info): Likewise.

testsuite/:
	* gdb.base/frame-args.exp: Handle arguments that are optimized
	out.
@
text
@d2255 1
d2264 3
d2269 1
a2269 3
                   value_contents (fromval),
                   TYPE_LENGTH (value_type (fromval)) * TARGET_CHAR_BIT -
                   bits, bits);
@


1.147
log
@	* symtab.h (enum address_class): Remove LOC_BASEREG and
	LOC_BASEREG_ARG.
	(struct symbol): Remove "basereg" member of "aux_value" union.
	(SYMBOL_BASEREG): Remove.

	* ada-exp.y (select_possible_type_sym): Do not handle LOC_BASEREG
	or LOC_BASEREG_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	(ada_add_block_symbols): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* buildsym.c (finish_block): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
	* printcmd.c (address_info): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals): Likewise.
	(print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (collect_symbol, add_local_symbols): Likewise.
	(scope_info): Likewise.
@
text
@a2892 1
                  case LOC_REGPARM:
a2895 1
                  case LOC_COMPUTED_ARG:
a4315 1
      case LOC_REGPARM:
a4319 1
      case LOC_COMPUTED_ARG:
d5212 6
a5217 12
            switch (SYMBOL_CLASS (sym))
              {
              case LOC_ARG:
              case LOC_REF_ARG:
              case LOC_REGPARM:
              case LOC_REGPARM_ADDR:
              case LOC_COMPUTED_ARG:
                arg_sym = sym;
                break;
              case LOC_UNRESOLVED:
                continue;
              default:
a5221 1
                break;
d5237 12
a5248 18
                switch (SYMBOL_CLASS (sym))
                  {
                  case LOC_ARG:
                  case LOC_REF_ARG:
                  case LOC_REGPARM:
                  case LOC_REGPARM_ADDR:
                  case LOC_COMPUTED_ARG:
                    arg_sym = sym;
                    break;
                  case LOC_UNRESOLVED:
                    break;
                  default:
                    found_sym = 1;
                    add_defn_to_vec (obstackp,
                                     fixup_symbol_section (sym, objfile),
                                     block);
                    break;
                  }
d5285 12
a5296 18
                switch (SYMBOL_CLASS (sym))
                  {
                  case LOC_ARG:
                  case LOC_REF_ARG:
                  case LOC_REGPARM:
                  case LOC_REGPARM_ADDR:
                  case LOC_COMPUTED_ARG:
                    arg_sym = sym;
                    break;
                  case LOC_UNRESOLVED:
                    break;
                  default:
                    found_sym = 1;
                    add_defn_to_vec (obstackp,
                                     fixup_symbol_section (sym, objfile),
                                     block);
                    break;
                  }
@


1.146
log
@	* symtab.h (enum address_class): Remove LOC_LOCAL_ARG.

	* ada-exp.y (select_possible_type_sym): Do not handle LOC_LOCAL_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	(ada_add_block_symbols): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* buildsyms.c (finish_block): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
	* printcmd.c (address_info): Likewise.
	* stack.c (print_frame_args, print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (collect_symbol, add_local_symbols): Likewise.
	(scope_info): Likewise.
@
text
@a2895 2
                  case LOC_BASEREG:
                  case LOC_BASEREG_ARG:
a4321 2
      case LOC_BASEREG:
      case LOC_BASEREG_ARG:
a5221 1
              case LOC_BASEREG_ARG:
a5253 1
                  case LOC_BASEREG_ARG:
a5307 1
                  case LOC_BASEREG_ARG:
@


1.145
log
@	* symtab.h (lookup_symbol_in_language): Update comment.
	* symtab.c (lookup_symbol_aux_block): Update comment.
	* ada-lang.c (ada_lookup_symbol_list): Update comment.
@
text
@a2895 1
                  case LOC_LOCAL_ARG:
a4323 1
      case LOC_LOCAL_ARG:
a5222 1
              case LOC_LOCAL_ARG:
a5255 1
                  case LOC_LOCAL_ARG:
a5310 1
                  case LOC_LOCAL_ARG:
@


1.144
log
@	* symtab.h (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	* symtab.c (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	(search_symbols): Update.

	* linespec.c (find_methods, collect_methods): Update.
	(add_matching_methods, add_constructors): Update.
	(decode_compound, decode_dollar, decode_variable): Update.
	(lookup_prefix_sym): Update.

	(symbol_found): Remove SYM_SYMTAB parameter.
	Use SYMBOL_SYMTAB (sym) instead.

	* gdbtypes.c (lookup_typename): Update.
	(lookup_struct, lookup_union, lookup_enum): Update.
	(lookup_template_type): Update.
	(check_typedef): Update.
	* language.c (lang_bool_type): Update.
	* mdebugread.c (parse_procedure): Update.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* parse.c (write_dollar_variable): Update.
	* printcmd.c (address_info): Update.
	* source.c (select_source_symtab): Update.
	* stack.c (print_frame_args, print_frame_arg_vars): Update.
	* valops.c (find_function_in_inferior): Update.
	(value_struct_elt_for_reference): Update.
	* value.c (value_static_field, value_fn_field): Update.

	* alpha-mdebug-tdep.c (find_proc_desc): Update.
	* arm-tdep.c (arm_skip_prologue): Update.
	* mt-tdep.c (mt_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Update.

	* ada-lang.h (struct ada_symbol_info): Remove SYMTAB member.
	* ada-lang.c (ada_add_block_symbols): Remove SYMTAB parameter.
	(add_defn_to_vec): Likewise.
	(ada_add_block_symbols): Likewise.
	(lookup_cached_symbol, cache_symbol): Likewise.
	(standard_lookup): Update.
	(ada_lookup_symbol_list): Update.

	* c-valprint.c (c_val_print): Update.
	* cp-support.c (cp_lookup_rtti_type): Update.
	* jv-lang.c (java_lookup_class, get_java_object_type): Update.
	* objc-lang.c (lookup_struct_typedef, find_imps): Update.
	* p-valprint.c (pascal_val_print): Update.
	* scm-lang.c (scm_lookup_name): Update.

	* c-exp.y: Update.
	* f-exp.y: Update.
	* jv-exp.y: Update.
	* m2-exp.y: Update.
	* objc-exp.y: Update.
	* p-exp.y: Update.
@
text
@d4669 1
a4669 1
   *RESULTS to point to a vector of (SYM,BLOCK,SYMTAB) triples,
@


1.143
log
@	* language.h (struct language_defn): Remove SYMTAB parameter from
	la_lookup_symbol_nonlocal callback function pointer.

	* ada-lang.h (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	(ada_lookup_encoded_symbol): Likewise.
	* ada-lang.c (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	Always call fixup_symbol_section.
	(ada_lookup_symbol): Remove SYMTAB parameter.
	(ada_lookup_symbol_nonlocal): Likewise.
	* ada-exp.y (write_object_renaming): Update.
	(find_primitive_type): Likewise.

	* cp-support.h (cp_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(cp_lookup_symbol_namespace): Likewise.
	* cp-namespace.c (lookup_namespace_scope): Remove SYMTAB parameter.
	(lookup_symbol_file): Likewise.
	(lookup_possible_namespace_symbol): Likewise.
	(cp_lookup_symbol_nonlocal): Likewise.
	(cp_lookup_symbol_namespace): Likewise.
	(cp_lookup_nested_type): Update.

	* scm-valprint.c (scm_inferior_print): Update.
	* valops.c (value_maybe_namespace_elt): Update.

	* solist.h (struct target_so_ops): Remove SYMTAB parameter from
	lookup_lib_global_symbol callback function pointer.
	(solib_global_lookup): Remove SYMTAB parameter.
	* solib.c (solib_global_lookup): Remove SYMTAB parameter.
	* solib-svr4.c (elf_lookup_lib_symbol): Likewise.

	* symtab.h (basic_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	* symtab.c (lookup_symbol_aux): Remove SYMTAB parameter.
	(lookup_symbol_aux_local): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_symbol_aux_symtabs): Likewise.
	(lookup_symbol_aux_psymtabs): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	(basic_lookup_symbol_nonlocal): Likewise.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.

	(lookup_symbol_in_language): Do not pass SYMTAB to lookup_symbol_aux.
@
text
@d118 1
a118 2
                                   domain_enum, struct objfile *,
                                   struct symtab *, int);
d123 1
a123 1
                             struct block *, struct symtab *);
d3978 1
a3978 2
                      struct symbol **sym, struct block **block,
                      struct symtab **symtab)
d3985 1
a3985 1
              struct block *block, struct symtab *symtab)
a3998 1
  struct symtab *symtab;
d4000 1
a4000 1
  if (lookup_cached_symbol (name, domain, &sym, NULL, NULL))
d4002 2
a4003 3
  sym =
    lookup_symbol_in_language (name, block, domain, language_c, 0, &symtab);
  cache_symbol (name, domain, sym, block_found, symtab);
d4088 1
a4088 1
                 struct block *block, struct symtab *symtab)
a4110 1
          prevDefns[i].symtab = symtab;
a4119 1
    info.symtab = symtab;
d4723 1
a4723 1
                             namespace, NULL, NULL, wild_match);
d4745 1
a4745 1
  if (lookup_cached_symbol (name0, namespace, &sym, &block, &s))
d4748 1
a4748 1
        add_defn_to_vec (&symbol_list_obstack, sym, block, s);
d4761 1
a4761 1
                           objfile, s, wild_match);
d4784 1
a4784 1
                                           namespace, objfile, s, wild_match);
d4791 1
a4791 1
                                               namespace, objfile, s,
d4812 1
a4812 1
                               namespace, objfile, s, wild_match);
d4829 1
a4829 1
                               objfile, s, wild_match);
d4844 1
a4844 1
                                   namespace, objfile, s, wild_match);
d4856 1
a4856 1
    cache_symbol (name0, namespace, NULL, NULL, NULL);
d4859 1
a4859 2
    cache_symbol (name0, namespace, (*results)[0].sym, (*results)[0].block,
                  (*results)[0].symtab);
d5201 1
a5201 1
                       struct symtab *symtab, int wild)
d5239 1
a5239 1
                                 block, symtab);
d5273 1
a5273 1
                                     block, symtab);
d5285 1
a5285 1
                       block, symtab);
d5329 1
a5329 1
                                     block, symtab);
d5342 1
a5342 1
                           block, symtab);
@


1.142
log
@        * ada-lang.c (ada_evaluate_subexp) [BINOP_ASSIGN]: Do not force
        the type of the right hand side of the assignment to the type
        of the left hand side if the left hand side is a convenience
        variable.
@
text
@d4875 1
a4875 2
			   domain_enum namespace, 
			   struct block **block_found, struct symtab **symtab)
d4888 1
a4888 34
  if (symtab != NULL)
    {
      *symtab = candidates[0].symtab;
      if (*symtab == NULL && candidates[0].block != NULL)
        {
          struct objfile *objfile;
          struct symtab *s;
          struct block *b;
          struct blockvector *bv;

          /* Search the list of symtabs for one which contains the
             address of the start of this block.  */
          ALL_PRIMARY_SYMTABS (objfile, s)
          {
            bv = BLOCKVECTOR (s);
            b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
            if (BLOCK_START (b) <= BLOCK_START (candidates[0].block)
                && BLOCK_END (b) > BLOCK_START (candidates[0].block))
              {
                *symtab = s;
                return fixup_symbol_section (candidates[0].sym, objfile);
              }
          }
          /* FIXME: brobecker/2004-11-12: I think that we should never
             reach this point.  I don't see a reason why we would not
             find a symtab for a given block, so I suggest raising an
             internal_error exception here.  Otherwise, we end up
             returning a symbol but no symtab, which certain parts of
             the code that rely (indirectly) on this function do not
             expect, eventually causing a SEGV.  */
          return fixup_symbol_section (candidates[0].sym, NULL);
        }
    }
  return candidates[0].sym;
d4900 1
a4900 2
                   domain_enum namespace, int *is_a_field_of_this,
                   struct symtab **symtab)
d4907 1
a4907 1
			       block0, namespace, NULL, symtab);
d4914 1
a4914 1
                            const domain_enum domain, struct symtab **symtab)
d4919 1
a4919 1
                            NULL, symtab);
@


1.141
log
@	* ada-lang.c: Update throughout to use symbol_matches_domain
	instead of matching the symbol domain explictly.
	* dwarf2read.c (add_partial_symbol): Do not add new psym for
	STRUCT_DOMAIN. Make sure you recognize c++ struct and java and ada
	class as typedefs. See lookup_partial_symbol function.
	(new_symbol): Similar to add_partial_symbol, do not create
	symbol for the typedef. See lookup_block_symbol.
	* symtab.c (symbol_matches_domain): New function, takes care
	of dual meaning of STRUCT_DOMAIN symbol for c++, ada and java.
	(lookup_partial_symbol): Use symbol_matches_domain to see if the
	found psym domain matches the given domain.
	(lookup_block_symbol): Likewise.
@
text
@d8561 8
a8568 1
      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);
@


1.140
log
@        * ada-lang.c (unwrap_value): Handle the case where the "F" field
        inside a PAD type is a bitfield.
@
text
@d4180 2
a4181 1
          if (SYMBOL_DOMAIN (psym) == namespace
d4215 2
a4216 1
          if (SYMBOL_DOMAIN (psym) == namespace)
d4259 2
a4260 1
          if (SYMBOL_DOMAIN (psym) == namespace)
d5260 2
a5261 1
        if (SYMBOL_DOMAIN (sym) == domain
d5291 2
a5292 1
        if (SYMBOL_DOMAIN (sym) == domain)
d5337 2
a5338 1
        if (SYMBOL_DOMAIN (sym) == domain)
@


1.139
log
@	* ada-lang.c (ada_value_primitive_packed_val): Only check
	value_lazy for memory lvals.
	* findvar.c (value_of_register_lazy): New function.
	(locate_var_value): Only check value_lazy for memory lvals.
	* valarith.c (value_subscripted_rvalue): Likewise.
	* valops.c (value_fetch_lazy): Handle both memory and register
	lvals.
	(search_struct_field, value_slice): Only check value_lazy for memory
	lvals.
	* value.c (struct value): Update comment for lazy.
	(value_primitive_field): Only check value_lazy for memory lvals.
	* value.h (value_lazy): Update comment.
	(value_of_register_lazy): Declare.
@
text
@d7976 1
a7976 2
      struct value *v = value_struct_elt (&val, NULL, "F",
                                          NULL, "internal structure");
@


1.138
log
@	* ada-lang.c (get_selections): Variable PROMPT made non-const and
	initialized with a trailing space now.  Use PROMPT_ARG of
	COMMAND_LINE_INPUT instead of printing it ourselves.
@
text
@d2042 1
a2042 1
  else if (value_lazy (obj))
@


1.137
log
@	Fix breakpoint condition that use member variables.
        * valops.c (check_field): Remove.
        (check_field_in): Rename to check_field.
        (value_of_this): Use la_name_of_this.
        * value.h (check_field): Adjust prototype.

        * language.h (la_value_of_this): Rename to la_name_of_this.
        * language.c (unknown_language_defn): Specify "this" for
        name_of_this.
        (auto_language_defn): Likewise.
        (local_language_defn): Likewise.
        * ada-lang.c (ada_language_defn): Adjust comment.
        * c-lang.c (c_language_defn): Adjust comment.
        (cplus_language_defn): Specify "this" for name_of_this.
        (asm_language_defn): Adjust comment.
        (minimal_language_defn): Adjust comment.
        * f-lang.c (f_language_defn): Specify NULL for name_of_this.
        * jv-lang.c (java_language_defn): Specify "this" for name_of_this.
        * m2-lang.c (m2_language_defn): Specify "this" for name_of_this.
        * objc-lang.c (objc_language_defn): Specify "self" for
        name_of_this.
        * p-lang.c (pascal_language_defn): Specify "this" for
        name_of_this.
        * scm-lang.c (scm_language_defn): Specify NULL for name_of_this.

        * symtab.c (lookup_symbol_aux): Lookup "this" in the
        proper scope, and check for field in type of "this", without
        trying to create a value.
@
text
@d3427 1
a3427 1
  const char *prompt;
d3433 1
a3433 1
    prompt = ">";
d3435 1
a3435 4
  printf_unfiltered (("%s "), prompt);
  gdb_flush (gdb_stdout);

  args = command_line_input ((char *) NULL, 0, annotation_suffix);
@


1.136
log
@        * symtab.c (multiple_symbols_ask, multiple_symbols_all)
        (multiple_symbols_cancel): New constants.
        (multiple_symbols_modes, multiple_symbols_mode): New static globals.
        (multiple_symbols_select_mode): New function.
        (_initialize_symtab): Add new set/show multiple-symbols commands.
        * symtab.h (multiple_symbols_ask, multiple_symbols_all)
        (multiple_symbols_cancel, multiple_symbols_select_mode): Declare.
        * ada-lang.c (user_select_syms): Add handling of new multiple-symbols
        setting.
        * linespec.c (decode_line_2): Likewise.
@
text
@d11014 1
a11014 1
  NULL,                         /* value_of_this */
@


1.135
log
@        * ada-lang.c (symbol_completion_add): Make SV parameter a VEC**
        instead of just a VEC*. Update use of SV.
        (ada_make_symbol_completion_list): Update symbol_completion_add calls.
@
text
@d3315 1
d3322 11
@


1.134
log
@        * ada-lang.c: #include "vec.h".
        (struct string_vector, new_string_vector, string_vector_append):
        Delete.
        (char_ptr): New typedef.
        (DEF_VEC_P (char_ptr)): New VEC type.
        (symbol_completion_add): Update profile to take the new VEC type
        instead of the old string_vector structure. Update code accordingly.
        (ada_make_symbol_completion_list): Use the new VEC type instead of
        the old string_vector structure, and update the code accordingly.
        * Makefile.in (ada-lang.o): Add dependency on vec.h.
@
text
@d5482 1
a5482 1
symbol_completion_add (VEC(char_ptr) *sv,
d5518 1
a5518 1
  VEC_safe_push (char_ptr, sv, completion);
d5581 1
a5581 1
        symbol_completion_add (completions, SYMBOL_LINKAGE_NAME (*psym),
d5591 1
a5591 1
        symbol_completion_add (completions, SYMBOL_LINKAGE_NAME (*psym),
d5605 1
a5605 1
    symbol_completion_add (completions, SYMBOL_LINKAGE_NAME (msymbol),
d5619 1
a5619 1
        symbol_completion_add (completions, SYMBOL_LINKAGE_NAME (sym),
d5634 1
a5634 1
      symbol_completion_add (completions, SYMBOL_LINKAGE_NAME (sym),
d5649 1
a5649 1
      symbol_completion_add (completions, SYMBOL_LINKAGE_NAME (sym),
@


1.133
log
@        * language.h (struct language_defn): Add new field
        la_make_symbol_completion_list.
        * symtab.c (default_make_symbol_completion_list): Renames
        make_symbol_completion_list.
        (make_symbol_completion_list): New function.
        * symtab.h (default_make_symbol_completion_list): Add declaration.
        * langauge.c (unknown_language): Set la_make_symbol_completion_list.
        (auto_language, local_language): Likewise.
        * objc-lang.c (objc_language_defn): Likewise.
        * scm-lang.c (scm_language_defn): Likewise.
        * m2-lang.c (m2_language_defn): Likewise.
        * f-lang.c (f_language_defn): Likewise.
        * jv-lang.c (java_language_defn): Likewise.
        * p-lang.c (pascal_language_defn): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn, asm_language_defn)
        (minimal_language_defn): Likewise.
        * ada-lang.c (struct string_vector): New structure.
        (new_string_vector, string_vector_append, ada_unqualified_name)
        (add_angle_brackets, symbol_completion_match, symbol_completion_add)
        (ada_make_symbol_completion_list): New functions.
        (ada_language_defn): Set la_make_symbol_completion_list.
        * ada-lang.h (ada_make_symbol_completion_list): Remove declaration,
        this function is static.
@
text
@d58 1
a71 19
/* A structure that contains a vector of strings.
   The main purpose of this type is to group the vector and its
   associated parameters in one structure.  This makes it easier
   to handle and pass around.
   
   brobecker/2008-02-04:  GDB does provide a generic VEC which should be
   preferable.  But we are using the string_vector structure in the context
   of symbol completion, and the current infrastructure is such that it's
   more convenient to use the string vector for now.  It would become
   advantageous to switch to VECs if the rest of the completion-related
   code switches to VECs as well.  */

struct string_vector
{
  char **array; /* The vector itself.  */
  int index;    /* Index of the next available element in the array.  */
  size_t size;  /* The number of entries allocated in the array.  */
};

a318 28
/* Create a new empty string_vector struct with an initial size of
   INITIAL_SIZE.  */

static struct string_vector
new_string_vector (int initial_size)
{
  struct string_vector result;

  result.array = (char **) xmalloc ((initial_size + 1) * sizeof (char *));
  result.index = 0;
  result.size = initial_size;

  return result;
}

/* Add STR at the end of the given string vector SV.  If SV is already
   full, its size is automatically increased (doubled).  */

static void
string_vector_append (struct string_vector *sv, char *str)
{
  if (sv->index >= sv->size)
    GROW_VECT (sv->array, sv->size, sv->size * 2);

  sv->array[sv->index] = str;
  sv->index++;
}

d5463 3
d5482 1
a5482 1
symbol_completion_add (struct string_vector *sv,
d5518 1
a5518 1
  string_vector_append (sv, completion);
d5532 1
a5532 1
  struct string_vector result = new_string_vector (128);
d5581 1
a5581 1
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (*psym),
d5591 1
a5591 1
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (*psym),
d5605 1
a5605 1
    symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (msymbol),
d5619 1
a5619 1
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
d5634 1
a5634 1
      symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
d5649 1
a5649 1
      symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
d5656 1
a5656 1
  string_vector_append (&result, NULL);
d5658 15
a5672 1
  return (result.array);
@


1.132
log
@	* gdbarch.sh (function_list): Add new property bits_big_endian to
	gdbarch structure.
	* gdbarch.{c,h}: Regenerate.

	* value.c (struct value): Replace BITS_BIG_ENDIAN by
	gdbarch_bits_big_endian (comment).
	(unpack_field_as_long, modify_field): Likewise.
	* value.h: Likewise (comment).
	* valops.c (value_slice): Likewise.
	* valarith.c (value_subscript, value_bit_index): Likewise.
	* gdbtypes.h (field): Likewise (comment).
	* eval.c (evaluate_subexp_standard): Likewise.
	* dwarf2read.c (dwarf2_add_field): Likewise.
	* ada-lang.c (decode_packed_array, ada_value_primitive_packed_val)
	(move_bits, ada_value_assign, value_assign_to_component): Likewise.

	* defs.h (BITS_BIG_ENDIAN): Remove.



	* gdbint.texinfo (Target Conditionals): Replace the description of
	BITS_BIG_ENDIAN with a description of gdbarch_bits_big_endian.
@
text
@d71 18
d337 59
d5420 284
d11040 1
@


1.131
log
@        * ada-lang.c (ada_convert_actual): Renames convert_actual.
        Make non-static.
        (ada_convert_actuals): Delete.
        * ada-lang.h (ada_convert_actual): Add declaration.
        (ada_convert_actuals): Remove declaration.
        * infcall.c: #include "ada-lang.h".
        (value_arg_coerce): Add new parameter sp.  Update function
        documetnation.  Add handling of Ada function call parameters.
        * Makefile.in (infcall.o): Update dependencies.
@
text
@d1878 2
a1879 1
  if (BITS_BIG_ENDIAN && ada_is_modular_type (value_type (arr)))
d2002 1
a2002 1
  int delta = BITS_BIG_ENDIAN ? -1 : 1;
d2051 1
a2051 1
  else if (BITS_BIG_ENDIAN)
d2145 1
a2145 1
  if (BITS_BIG_ENDIAN)
d2233 1
a2233 1
      if (BITS_BIG_ENDIAN)
d2280 1
a2280 1
  if (BITS_BIG_ENDIAN)
@


1.130
log
@        * ada-lang.c (ensure_lval): Fix value lval kind.
        (convert_actual): Add handling for arguments passed by reference.
@
text
@d3838 3
a3840 3
static struct value *
convert_actual (struct value *actual, struct type *formal_type0,
                CORE_ADDR *sp)
a3931 24


/* Assuming a dummy frame has been established on the target, perform any
   conversions needed for calling function FUNC on the NARGS actual
   parameters in ARGS, other than standard C conversions.  Does
   nothing if FUNC does not have Ada-style prototype data, or if NARGS
   does not match the number of arguments expected.  Use *SP as a
   stack pointer for additional data that must be pushed, updating its
   value as needed.  */

void
ada_convert_actuals (struct value *func, int nargs, struct value *args[],
                     CORE_ADDR *sp)
{
  int i;

  if (TYPE_NFIELDS (value_type (func)) == 0
      || nargs != TYPE_NFIELDS (value_type (func)))
    return;

  for (i = 0; i < nargs; i += 1)
    args[i] =
      convert_actual (args[i], TYPE_FIELD_TYPE (value_type (func), i), sp);
}
@


1.129
log
@        * ada-lang.c (ada_which_variant_applies): Correctly compute
        the value of the discriminant when the variant record is packed.
@
text
@d3825 1
d3854 2
a3855 1
  else if (TYPE_CODE (formal_type) == TYPE_CODE_PTR)
d3857 1
d3860 1
a3860 1
        return desc_data (actual);
d3873 1
a3873 1
          return value_addr (actual);
d3875 3
@


1.128
log
@        * ada-lang.c (is_name_suffix): Handle middle-name numeric suffixes
        that are used to differentiate homonyms.
@
text
@a6286 2
  int disp;
  struct type *discrim_type;
d6288 2
d6292 3
a6294 4
  disp = 0;
  discrim_type =
    ada_lookup_struct_elt_type (outer_type, discrim_name, 1, 1, &disp);
  if (discrim_type == NULL)
d6296 1
a6296 1
  discrim_val = unpack_long (discrim_type, outer_valaddr + disp);
@


1.127
log
@        * ada-lang.c (decode_packed_array_type): Avoid a seg fault
        when the type is an anonymous pointer type.
        (ada_check_typedef): Avoid a seg fault when the type is null.
        * ada-typeprint.c (print_array_type): Add support for pointer
        to packed arrays.
@
text
@d4937 3
a4939 4
   (__[0-9]+)?[.$][0-9]+  [nested subprogram suffix, on platforms such 
                           as GNU/Linux]
   ___[0-9]+            [nested subprogram suffix, on platforms such as HP/UX]
   _E[0-9]+[bs]$          [protected object entry suffixes]
d4941 4
a4944 1
 */
d4953 2
a4954 2
  /* (__[0-9]+)?\.[0-9]+ */
  matching = str;
d4957 3
a4959 5
      matching += 3;
      while (isdigit (matching[0]))
        matching += 1;
      if (matching[0] == '\0')
        return 1;
d4961 2
d4964 1
a4964 1
  if (matching[0] == '.' || matching[0] == '$')
d4966 1
a4966 1
      matching += 1;
d4974 1
d5027 1
d5030 1
@


1.126
log
@        * ada-lang.c (ada_evaluate_subexp): Evaluate tagged types in
        EVAL_NORMAL mode when noside is EVAL_AVOID_SIDE_EFFECTS.
@
text
@d1812 3
a1814 3
  const char *raw_name = ada_type_name (ada_check_typedef (type));
  char *name = (char *) alloca (strlen (raw_name) + 1);
  char *tail = strstr (raw_name, "___XP");
d1819 8
d7280 3
@


1.125
log
@        * ada-lang.c (resolve_subexp): Add handling of OP_REGISTER
        expressions.  These expressions do not need to be rewriten.
@
text
@d8342 9
@


1.124
log
@        * ada-lang.c (ada_array_bound_from_type): Make non-static.
        Handle properly the case when the index type is an enumerated type.
        Do not return the subtype of the bounds type, just return the
        bounds type directly - this is not needed and is more consistent
        with what we do for arrays when no XA parallel type exists.
@
text
@d3002 1
@


1.123
log
@        * ada-lang.c (static_unwrap_type): Add forward declaration.
        (template_to_static_fixed_type): Fields of dynamic types sometimes
        also need to be unwrapped. Take this into account.
        (ada_to_fixed_type_1): Renamed from ada_to_fixed_type.
        (ada_to_fixed_type): New wrapper around ada_to_fixed_type_1.
        * ada-typeprint.c (ada_print_type): Get the typename from
        the original type, not the base type.
@
text
@d2483 1
a2483 1
LONGEST
a2507 1
      struct type *range_type;
d2516 1
a2516 4
      range_type = TYPE_INDEX_TYPE (type);
      index_type = TYPE_TARGET_TYPE (range_type);
      if (TYPE_CODE (index_type) == TYPE_CODE_UNDEF)
        index_type = builtin_type_long;
d2519 6
d2527 3
a2529 2
                   ? TYPE_LOW_BOUND (range_type)
                   : TYPE_HIGH_BOUND (range_type));
d2536 1
d2538 2
a2539 1
        *typep = TYPE_TARGET_TYPE (index_type);
d2548 2
a2549 2
   nth index (numbering from 1) if which is 0, and the upper bound if
   which is 1.  This routine will also work for arrays with bounds
@


1.122
log
@        * ada-lang.c (ada_value_struct_elt, to_fixed_array_type)
        (to_fixed_array_type, ada_to_fixed_value_create, unwrap_value):
        Update calls to ada_to_fixed_type.
        (ada_template_to_fixed_record_type_1): Ditto, but without looking
        for the tag.
        (ada_to_fixed_type): Add check_tag parameter; do not look for
        tag if null.  When looking for a tag, use a fixed record type.
        * ada-lang.h (ada_to_fixed_type): Add check_tag parameter.
        * ada-valprint.c (printable_val_type, ada_value_print): Update
        calls to ada_to_fixed_type.
@
text
@d184 1
d6858 1
a6858 1
        new_type = to_static_fixed_type (field_type);
d7129 2
a7130 2
struct type *
ada_to_fixed_type (struct type *type, const gdb_byte *valaddr,
d7172 19
@


1.121
log
@        * ada-lang.c (ada_evaluate_subexp): Modify the value returned
        when noside is EVAL_AVOID_SIDE_EFFECTS to be an lval_memory.
        This is needed to make sure that any other treatment applied
        to the resulting value does not fail for spurious reason,
        such as trying to take the address of this value.
@
text
@d6089 1
a6089 1
      t1 = ada_to_fixed_type (ada_get_base_type (t1), NULL, address, NULL);
d6715 6
d6726 1
a6726 1
             cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
d7069 1
a7069 1
      struct type *elt_type = ada_to_fixed_type (elt_type0, 0, 0, dval);
d7097 2
a7098 1
      result = ada_to_fixed_type (ada_check_typedef (elt_type0), 0, 0, dval);
d7122 5
a7126 5
   In the case of tagged types, this function attempts to locate the object's
   tag and use it to compute the actual type.  However, when ADDRESS is null,
   we cannot use it to determine the location of the tag, and therefore
   compute the tagged type's actual type.  So we return the tagged type
   without consulting the tag.  */
d7130 1
a7130 1
                   CORE_ADDR address, struct value *dval)
d7140 2
a7141 1

d7144 4
a7147 1
           type from there.  */
d7149 1
a7149 1
        if (address != 0 && ada_is_tagged_type (static_type, 0))
d7152 4
a7155 3
              type_from_tag (value_tag_from_contents_and_address (static_type,
                                                                  valaddr,
                                                                  address));
d7157 1
a7157 1
              type = real_type;
d7159 1
a7159 1
        return to_fixed_record_type (type, valaddr, address, NULL);
d7269 1
a7269 1
  struct type *type = ada_to_fixed_type (type0, 0, address, NULL);
d7631 1
a7631 1
                                 NULL));
@


1.120
log
@        * ada-lang.c (ada_value_equal): Dereference reference types when
        comparing arrays.
@
text
@d8400 1
a8400 1
              return allocate_value (ada_aligned_type (type));
d8412 1
a8412 1
                return allocate_value (ada_aligned_type (type));
d8426 1
a8426 1
                return allocate_value (ada_aligned_type (type));
@


1.119
log
@        * ada-lang.c (ada_remove_trailing_digits): New function.
        (ada_remove_po_subprogram_suffix): New function.
        (ada_decode): Improve. Move the description of the algorithm
        directly inside the code, instead of in the function global
        description.
@
text
@d7747 5
@


1.118
log
@        * ada-lang.c (ada_evaluate_subexp, case BINOP_SUB): Add handling
        of the case where the first argument is a reference.
        (ada_evaluate_subexp, case BINOP_ADD): Likewise.
@
text
@d850 53
a902 16
/* Decode:
      . Discard trailing .{DIGIT}+, ${DIGIT}+ or ___{DIGIT}+
        These are suffixes introduced by GNAT5 to nested subprogram
        names, and do not serve any purpose for the debugger.
      . Discard final __{DIGIT}+ or $({DIGIT}+(__{DIGIT}+)*)
      . Discard final N if it follows a lowercase alphanumeric character
        (protected object subprogram suffix)
      . Convert other instances of embedded "__" to `.'.
      . Discard leading _ada_.
      . Convert operator names to the appropriate quoted symbols.
      . Remove everything after first ___ if it is followed by
        'X'.
      . Replace TK__ with __, and a trailing B or TKB with nothing.
      . Replace _[EB]{DIGIT}+[sb] with nothing (protected object entries)
      . Put symbols that should be suppressed in <...> brackets.
      . Remove trailing X[bn]* suffix (indicating names in package bodies).
d905 1
a905 1
   If the string is unchanged by demangling, the original string pointer
d919 3
d925 3
a930 1
  /* Remove trailing .{DIGIT}+ or ___{DIGIT}+ or __{DIGIT}+.  */
a931 14
  if (len0 > 1 && isdigit (encoded[len0 - 1]))
    {
      i = len0 - 2;
      while (i > 0 && isdigit (encoded[i]))
        i--;
      if (i >= 0 && encoded[i] == '.')
        len0 = i;
      else if (i >= 0 && encoded[i] == '$')
        len0 = i;
      else if (i >= 2 && strncmp (encoded + i - 2, "___", 3) == 0)
        len0 = i - 2;
      else if (i >= 1 && strncmp (encoded + i - 1, "__", 2) == 0)
        len0 = i - 1;
    }
d933 2
a934 14
  /* Remove trailing N.  */

  /* Protected entry subprograms are broken into two
     separate subprograms: The first one is unprotected, and has
     a 'N' suffix; the second is the protected version, and has
     the 'P' suffix. The second calls the first one after handling
     the protection.  Since the P subprograms are internally generated,
     we leave these names undecoded, giving the user a clue that this
     entity is internal.  */

  if (len0 > 1
      && encoded[len0 - 1] == 'N'
      && (isdigit (encoded[len0 - 2]) || islower (encoded[len0 - 2])))
    len0--;
d949 4
d956 3
d963 1
d967 2
d981 3
d990 1
d1019 19
d1092 7
d1108 1
d1116 2
d1125 3
@


1.117
log
@        Implement support for Ada interface types.

        * ada-lang.c (ada_is_dispatch_table_ptr_type): New function.
        (ada_is_ignored_field): Ignore fields that are a dispatch table
        of a tagged type.
@
text
@d8133 7
a8139 1
      return value_cast (value_type (arg1), value_add (arg1, arg2));
d8150 7
a8156 1
      return value_cast (value_type (arg1), value_sub (arg1, arg2));
@


1.116
log
@        * ada-lang.c (_initialize_ada_language): Attach executable_changed
        observer.
@
text
@d5280 18
d5306 24
a5329 6
  else
    {
      const char *name = TYPE_FIELD_NAME (type, field_num);
      return (name == NULL
              || (name[0] == '_' && strncmp (name, "_parent", 7) != 0));
    }
@


1.115
log
@        * ada-lang.c (ada_evaluate_subexp): Break two large expressions
        using temporary variables.
@
text
@d10537 2
@


1.114
log
@        * ada-lang.c (ada_value_cast): New function, extracted out from
        the code in ada_evaluate_subexp, case UNOP_CAST.  The code handling
        the obscure case has been removed as we think that it is actually
        unnecessary.
        (ada_evaluate_subexp): Add type case when evaluating an OP_DOUBLE
        or an OP_LONG with a non-null expect_type. Replace extracted-out
        code with call to new ada_value_cast function.
@
text
@d8166 7
a8172 4
      *pos -= 1;
      return value_cast (LA_BOOL_TYPE, 
			 evaluate_subexp_standard (expect_type, exp,
						   pos, noside));
d8177 9
a8185 6
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
      *pos = pc;
      return value_cast (value_type (arg1),
			 evaluate_subexp_standard (expect_type, exp,
						   pos, noside));
			 
@


1.113
log
@        * ada-lang.c (ada_evaluate_subexp): Add cases for BINOP_LOGICAL_AND,
        BINOP_LOGICAL_OR, UNOP_LOGICAL_NOT, BINOP_BITWISE_IOR,
        BINOP_BITWISE_XOR, BINOP_BITWISE_AND.
        * language.c (lang_bool_type): Add Ada case.
@
text
@d7987 18
d8025 15
a8039 3
      return
        unwrap_value (evaluate_subexp_standard
                      (expect_type, exp, pos, noside));
d8059 1
a8059 22
      if (type != ada_check_typedef (value_type (arg1)))
        {
          if (ada_is_fixed_point_type (type))
            arg1 = cast_to_fixed (type, arg1);
          else if (ada_is_fixed_point_type (value_type (arg1)))
            arg1 = value_cast (type, cast_from_fixed_to_double (arg1));
          else if (VALUE_LVAL (arg1) == lval_memory)
            {
              /* This is in case of the really obscure (and undocumented,
                 but apparently expected) case of (Foo) Bar.all, where Bar
                 is an integer constant and Foo is a dynamic-sized type.
                 If we don't do this, ARG1 will simply be relabeled with
                 TYPE.  */
              if (noside == EVAL_AVOID_SIDE_EFFECTS)
                return value_zero (to_static_fixed_type (type), not_lval);
              arg1 =
                ada_to_fixed_value_create
                (type, VALUE_ADDRESS (arg1) + value_offset (arg1), 0);
            }
          else
            arg1 = value_cast (type, arg1);
        }
@


1.112
log
@        * ada-lang.c (ada_is_character_type): Add recognition of type
        "Wide_Wide_Character".
@
text
@d8154 18
@


1.111
log
@        * dwarf2read.c (read_base_type): Set code to TYPE_CODE_CHAR
        for char and unsigned char types of Ada compilation units.
        * ada-lang.c (ada_is_character_type): Always return true if
        the type code is TYPE_CODE_CHAR.
@
text
@d7304 1
@


1.110
log
@        * ada-lang.h (ada_renaming_category): New enumerated type.
        (ada_lookup_encoded_symbol): Declare.
        (ada_parse_renaming): Declare.
        (ada_renaming_type,ada_is_object_renaming)
        (ada_simple_renamed_entity): Delete declarations.
        * ada-lang.c (ada_parse_renaming): New function to concentrate
        extraction of information from renaming symbols.
        (parse_old_style_renaming): New function to concentrate
        extraction of old-style (purely type-based) renaming information.
        (renaming_is_visible): Rename to...
        (old_renaming_is_invisible): Rename and change sense of
        renaming_is_visible.
        (remove_out_of_scope_renamings): Rename to...
        (remove_irrelevant_renamings): Renames remove_out_of_scope_renamings
        and augments with additional logic to handle cases where the same
        object renaming is encoded both as a reference variable and an
        encoded renaming.
        (ada_renaming_type,ada_is_object_renaming)
        (ada_simple_renamed_entity): Delete definitions.
        (ada_lookup_encoded_symbol): New function factored out of
        ada_lookup_symbol.
        (ada_lookup_symbol): Reimplement to call ada_lookup_encoded_symbol.
        (wild_match): Don't reject perfect match of prefix.
        (ada_find_renaming_symbol): Factor old-style renaming logic into
        find_old_style_renaming_symbol.
        (find_old_style_renaming_symbol): New name for content of old
        ada_find_renaming_symbol.
        (ada_prefer_type): Reimplement not to use ada_renaming_type.
        * ada-exp.y (write_object_renaming): Change interface.  Reimplement
        to use new arguments and ada_parse_renaming.
        Correct blocks used to find array index.
        (write_var_or_type): Reimplement to use ada_parse_renaming.
@
text
@d7289 16
a7304 9
  const char *name = ada_type_name (type);
  return
    name != NULL
    && (TYPE_CODE (type) == TYPE_CODE_CHAR
        || TYPE_CODE (type) == TYPE_CODE_INT
        || TYPE_CODE (type) == TYPE_CODE_RANGE)
    && (strcmp (name, "character") == 0
        || strcmp (name, "wide_character") == 0
        || strcmp (name, "unsigned char") == 0);
@


1.109
log
@	* coffread.c (decode_type): Use builtin_type_int32 instead
	of FT_INTEGER fundamental type for array range index type.
	(decode_base_type): Use builtin types of current_gdbarch
	instead of fundamental types.

	* dwarf2read.c (struct dwarf2_cu): Remove ftypes member.
	(read_file_scope): Do not initialize ftypes member.
	(dwarf_base_type, dwarf2_fundamental_types): Remove functions.
	(read_array_type): Use builtin_type_int32 instead of FT_INTEGER
	fundamental type for array range index type.
	(read_tag_string_type): Likewise for string range index type.
	Also, do not overwrite FT_CHAR type with new string type.
	(read_base_type): If DW_AT_name is missing, create unnamed type
	with given properties instead of looking for a fundamental type.
	Create new types as TYPE_TARGET_TYPE for DW_ATE_address and
	DW_ATE_complex_float types.
	(read_subrange_type): Create new type to represent missing
	DW_AT_type instead of looking for a fundamental type.
	(die_type): Use builtin type to represent "void" instead of
	looking for a fundamental type.

	* stabsread.c (define_symbol): Use builtin types to represent
	'r' and 'i' floating-point and integer constants.

	* gdbtypes.c (lookup_fundamental_type): Remove.
	* gdbtypes.h (lookup_fundamental_type): Remove prototype.
	(FT_VOID, FT_BOOLEAN, FT_CHAR, FT_SIGNED_CHAR, FT_UNSIGNED_CHAR,
	FT_SHORT, FT_SIGNED_SHORT, FT_UNSIGNED_SHORT, FT_INTEGER,
	FT_SIGNED_INTEGER, FT_UNSIGNED_INTEGER, FT_LONG, FT_SIGNED_LONG,
	FT_UNSIGNED_LONG, FT_LONG_LONG, FT_SIGNED_LONG_LONG,
	FT_UNSIGNED_LONG_LONG, FT_FLOAT, FT_DBL_PREC_FLOAT, FT_EXT_PREC_FLOAT,
	FT_COMPLEX, FT_DBL_PREC_COMPLEX, FT_EXT_PREC_COMPLEX, FT_STRING,
	FT_FIXED_DECIMAL, FT_FLOAT_DECIMAL, FT_BYTE, FT_UNSIGNED_BYTE,
	FT_TEMPLATE_ARG, FT_DECFLOAT, FT_DBL_PREC_DECFLOAT,
	FT_EXT_PREC_DECFLOAT, FT_NUM_MEMBERS): Remove macros.
	* objfiles.c (struct objfile): Remove fundamental_types member.
	* symfile.c (reread_symbols): Do not clear fundamental_types.

	* language.h (struct language_defn): Remove la_fund_type member.
	(create_fundamental_type): Remove.
	* language.c (unk_lang_create_fundamental_type): Remove.
	(unknown_language_defn, auto_language_defn,
	local_language_defn): Adapt initializer.
	* ada-lang.c (ada_create_fundamental_type): Remove.
	(ada_language_defn): Adapt initializer.
	* c-lang.h (c_create_fundamental_type): Remove prototype.
	* c-lang.c (c_create_fundamental_type): Remove.
	(c_language_defn, cplus_language_defn, asm_language_defn,
	minimal_language_defn): Adapt initializer.
	* f-lang.c (f_create_fundamental_type): Remove.
	(f_language_defn): Adapt initializer.
	* jv-lang.c (java_create_fundamental_type): Remove.
	(java_language_defn): Adapt initializer.
	* m2-lang.c (m2_create_fundamental_type): Remove.
	(m2_language_defn): Adapt initializer.
	* objc-lang.c (objc_create_fundamental_type): Remove.
	(objc_language_defn): Adapt initializer.
	* p-lang.h (pascal_create_fundamental_type): Remove prototype.
	* p-lang.c (pascal_create_fundamental_type): Remove.
	(pascal_language_defn): Adapt initializer.
	* scm-lang.c (scm_language_defn): Adapt initializer.
@
text
@d156 8
d3558 1
a3558 8
/* NOTE: In the following, we assume that a renaming type's name may
   have an ___XD suffix.  It would be nice if this went away at some
   point.  */

/* If TYPE encodes a renaming, returns the renaming suffix, which
   is XR for an object renaming, XRP for a procedure renaming, XRE for
   an exception renaming, and XRS for a subprogram renaming.  Returns
   NULL if NAME encodes none of these.  */
d3560 41
a3600 4
const char *
ada_renaming_type (struct type *type)
{
  if (type != NULL && TYPE_CODE (type) == TYPE_CODE_ENUM)
d3602 33
a3634 7
      const char *name = type_name_no_tag (type);
      const char *suffix = (name == NULL) ? NULL : strstr (name, "___XR");
      if (suffix == NULL
          || (suffix[5] != '\000' && strchr ("PES_", suffix[5]) == NULL))
        return NULL;
      else
        return suffix + 3;
a3635 5
  else
    return NULL;
}

/* Return non-zero iff SYM encodes an object renaming.  */
d3637 21
a3657 2
int
ada_is_object_renaming (struct symbol *sym)
d3659 4
a3662 4
  const char *renaming_type = ada_renaming_type (SYMBOL_TYPE (sym));
  return renaming_type != NULL
    && (renaming_type[2] == '\0' || renaming_type[2] == '_');
}
d3664 3
a3666 3
/* Assuming that SYM encodes a non-object renaming, returns the original
   name of the renamed entity.  The name is good until the end of
   parsing.  */
d3668 25
a3692 7
char *
ada_simple_renamed_entity (struct symbol *sym)
{
  struct type *type;
  const char *raw_name;
  int len;
  char *result;
d3694 14
a3707 14
  type = SYMBOL_TYPE (sym);
  if (type == NULL || TYPE_NFIELDS (type) < 1)
    error (_("Improperly encoded renaming."));

  raw_name = TYPE_FIELD_NAME (type, 0);
  len = (raw_name == NULL ? 0 : strlen (raw_name)) - 5;
  if (len <= 0)
    error (_("Improperly encoded renaming."));

  result = xmalloc (len + 1);
  strncpy (result, raw_name, len);
  result[len] = '\000';
  return result;
}
d4414 1
a4414 1
   visible from FUNCTION_NAME.  */
d4417 1
a4417 1
renaming_is_visible (const struct symbol *sym, char *function_name)
d4419 6
a4424 1
  char *scope = xget_renaming_scope (SYMBOL_TYPE (sym));
d4430 1
a4430 1
    return 1;
d4442 1
a4442 1
  return (strncmp (function_name, scope, strlen (scope)) == 0);
d4445 5
a4449 3
/* Iterates over the SYMS list and remove any entry that corresponds to
   a renaming entity that is not visible from the function associated
   with CURRENT_BLOCK. 
d4452 6
a4457 1
   GNAT emits a type following a specified encoding for each renaming
d4483 2
a4484 2
remove_out_of_scope_renamings (struct ada_symbol_info *syms,
                               int nsyms, const struct block *current_block)
d4489 43
d4554 3
a4556 2
      if (ada_is_object_renaming (syms[i].sym)
          && !renaming_is_visible (syms[i].sym, current_function_name))
d4559 1
a4559 1
          for (j = i + 1; j < nsyms; j++)
d4765 1
a4765 1
  ndefns = remove_out_of_scope_renamings (*results, ndefns, block0);
a4769 8
/* Return a symbol in DOMAIN matching NAME, in BLOCK0 and enclosing
   scope and in global scopes, or NULL if none.  NAME is folded and
   encoded first.  Otherwise, the result is as for ada_lookup_symbol_list,
   choosing the first symbol if there are multiple choices.  
   *IS_A_FIELD_OF_THIS is set to 0 and *SYMTAB is set to the symbol
   table in which the symbol was found (in both cases, these
   assignments occur only if the pointers are non-null).  */

d4771 3
a4773 3
ada_lookup_symbol (const char *name, const struct block *block0,
                   domain_enum namespace, int *is_a_field_of_this,
                   struct symtab **symtab)
d4778 1
a4778 2
  n_candidates = ada_lookup_symbol_list (ada_encode (ada_fold_name (name)),
                                         block0, namespace, &candidates);
d4783 2
a4784 2
  if (is_a_field_of_this != NULL)
    *is_a_field_of_this = 0;
d4820 20
d5013 2
a5014 4
/* Return non-zero if NAME0 is a valid match when doing wild matching.
   Certain symbols appear at first to match, except that they turn out
   not to follow the Ada encoding and hence should not be used as a wild
   match of a given pattern.  */
d5039 1
d5066 1
a5066 1
    name = (char *) alloca ((name_len + 1) * sizeof (char));
d5095 1
a5095 1
        return (is_valid_name_for_wild_match (name0));
d6326 2
a6327 2
/* Given a symbol NAME and its associated BLOCK, search all symbols
   for its ___XR counterpart, which is the ``renaming'' symbol
d6334 18
d6376 1
a6376 1
         pollution.  However, the renaming symbol themselves do not
d6418 9
a6426 3
  else if (ada_renaming_type (type0) != NULL
           && ada_renaming_type (type1) == NULL)
    return 1;
@


1.108
log
@	* language.h (struct language_defn): Remove la_builtin_type_vector
	and string_char_type members.
	* language.c (language_string_char_type): No longer consult
	la->string_char_type.
	(language_lookup_primitive_type_by_name): No longer consult
	current_language->la_builtin_type_vector.

	* language.c (unknown_language_defn, auto_language_defn,
	local_language_defn): Adapt initializer.
	* ada-lang.c (ada_language_defn): Likewise.
	* c-lang.c (c_language_defn, cplus_language_defn, asm_language_defn,
	minimal_language_defn): Likewise.
	* f-lang.c (f_language_defn): Likewise.
	* jv-lang.c (java_language_defn): Likewise.
	* m2-lang.c (m2_language_defn): Likewise.
	* objc-lang.c (objc_language_defn): Likewise.
	* p-lang.c (pascal_language_defn): Likewise.
	* scm-lang.c (scm_language_defn): Likewise.
@
text
@a73 2
static struct type *ada_create_fundamental_type (struct objfile *, int);

a10165 145
				/* Fundamental Ada Types */

/* Create a fundamental Ada type using default reasonable for the current
   target machine.

   Some object/debugging file formats (DWARF version 1, COFF, etc) do not
   define fundamental types such as "int" or "double".  Others (stabs or
   DWARF version 2, etc) do define fundamental types.  For the formats which
   don't provide fundamental types, gdb can create such types using this
   function.

   FIXME:  Some compilers distinguish explicitly signed integral types
   (signed short, signed int, signed long) from "regular" integral types
   (short, int, long) in the debugging information.  There is some dis-
   agreement as to how useful this feature is.  In particular, gcc does
   not support this.  Also, only some debugging formats allow the
   distinction to be passed on to a debugger.  For now, we always just
   use "short", "int", or "long" as the type name, for both the implicit
   and explicitly signed types.  This also makes life easier for the
   gdb test suite since we don't have to account for the differences
   in output depending upon what the compiler and debugging format
   support.  We will probably have to re-examine the issue when gdb
   starts taking it's fundamental type information directly from the
   debugging information supplied by the compiler.  fnf@@cygnus.com */

static struct type *
ada_create_fundamental_type (struct objfile *objfile, int typeid)
{
  struct type *type = NULL;

  switch (typeid)
    {
    default:
      /* FIXME:  For now, if we are asked to produce a type not in this
         language, create the equivalent of a C integer type with the
         name "<?type?>".  When all the dust settles from the type
         reconstruction work, this should probably become an error.  */
      type = init_type (TYPE_CODE_INT,
                        gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT,
                        0, "<?type?>", objfile);
      warning (_("internal error: no Ada fundamental type %d"), typeid);
      break;
    case FT_VOID:
      type = init_type (TYPE_CODE_VOID,
                        TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                        0, "void", objfile);
      break;
    case FT_CHAR:
      type = init_type (TYPE_CODE_INT,
                        TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                        0, "character", objfile);
      break;
    case FT_SIGNED_CHAR:
      type = init_type (TYPE_CODE_INT,
                        TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                        0, "signed char", objfile);
      break;
    case FT_UNSIGNED_CHAR:
      type = init_type (TYPE_CODE_INT,
                        TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned char", objfile);
      break;
    case FT_SHORT:
      type = init_type (TYPE_CODE_INT,
                        gdbarch_short_bit (current_gdbarch) / TARGET_CHAR_BIT,
                        0, "short_integer", objfile);
      break;
    case FT_SIGNED_SHORT:
      type = init_type (TYPE_CODE_INT,
                        gdbarch_short_bit (current_gdbarch) / TARGET_CHAR_BIT,
                        0, "short_integer", objfile);
      break;
    case FT_UNSIGNED_SHORT:
      type = init_type (TYPE_CODE_INT,
                        gdbarch_short_bit (current_gdbarch) / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned short", objfile);
      break;
    case FT_INTEGER:
      type = init_type (TYPE_CODE_INT,
                        gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT,
                        0, "integer", objfile);
      break;
    case FT_SIGNED_INTEGER:
      type = init_type (TYPE_CODE_INT,
			gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT,
			0, "integer", objfile);        /* FIXME -fnf */
      break;
    case FT_UNSIGNED_INTEGER:
      type = init_type (TYPE_CODE_INT,
                        gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned int", objfile);
      break;
    case FT_LONG:
      type = init_type (TYPE_CODE_INT,
                        gdbarch_long_bit (current_gdbarch) / TARGET_CHAR_BIT,
                        0, "long_integer", objfile);
      break;
    case FT_SIGNED_LONG:
      type = init_type (TYPE_CODE_INT,
                        gdbarch_long_bit (current_gdbarch) / TARGET_CHAR_BIT,
                        0, "long_integer", objfile);
      break;
    case FT_UNSIGNED_LONG:
      type = init_type (TYPE_CODE_INT,
                        gdbarch_long_bit (current_gdbarch) / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned long", objfile);
      break;
    case FT_LONG_LONG:
      type = init_type (TYPE_CODE_INT,
			gdbarch_long_long_bit (current_gdbarch)
			  / TARGET_CHAR_BIT,
			0, "long_long_integer", objfile);
      break;
    case FT_SIGNED_LONG_LONG:
      type = init_type (TYPE_CODE_INT,
			gdbarch_long_long_bit (current_gdbarch)
			  / TARGET_CHAR_BIT,
			0, "long_long_integer", objfile);
      break;
    case FT_UNSIGNED_LONG_LONG:
      type = init_type (TYPE_CODE_INT,
			gdbarch_long_long_bit (current_gdbarch)
			  / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned long long", objfile);
      break;
    case FT_FLOAT:
      type = init_type (TYPE_CODE_FLT,
                        gdbarch_float_bit (current_gdbarch) / TARGET_CHAR_BIT,
                        0, "float", objfile);
      break;
    case FT_DBL_PREC_FLOAT:
      type = init_type (TYPE_CODE_FLT,
                        gdbarch_double_bit (current_gdbarch) / TARGET_CHAR_BIT,
                        0, "long_float", objfile);
      break;
    case FT_EXT_PREC_FLOAT:
      type = init_type (TYPE_CODE_FLT,
                        gdbarch_long_double_bit (current_gdbarch)
			  / TARGET_CHAR_BIT,
                        0, "long_long_float", objfile);
      break;
    }
  return (type);
}

a10278 1
  ada_create_fundamental_type,  /* Create fundamental type in this language */
@


1.107
log
@2007-10-30  Markus Deuling  <deuling@@de.ibm.com>

	* ada-lang.c (ada_language_arch_info): Replace current_gdbarch by
	gdbarch.
@
text
@a10413 1
  NULL,
a10438 1
  NULL,
@


1.106
log
@	* infcall.c (call_function_by_hand): Handle language-specific
	pass and return by reference.

	* cp-abi.c (cp_pass_by_reference): New.
	* cp-abi.h (cp_pass_by_reference): Declare.
	(struct cp_abi_ops): Add pass_by_reference.
	* gnu-v3-abi.c (gnuv3_pass_by_reference): New.
	(init_gnuv3_ops): Set pass_by_reference.

	* language.c (language_pass_by_reference): New.
	(default_pass_by_reference): New.
	(unknown_language_defn, auto_language_defn, local_language_defn): Add
	default_pass_by_reference.
	* langauge.h (struct language_defn): Add la_pass_by_reference.
	(language_pass_by_reference, default_pass_by_reference): Declare.
	* ada-lang.c (ada_language_defn): Add default_pass_by_reference.
	* c-lang.c (c_language_defn, asm_language_defn)
	(minimal_language_defn): Likewise.
	(cplus_language_defn): Add cp_pass_by_reference.
	* f-lang.c (f_language_defn): Add default_pass_by_reference.
	* jv-lang.c (java_language_defn): Likewise.
	* m2-lang.c (m2_language_defn): Likewise.
	* objc-lang.c (objc_language_defn): Likewise.
	* p-lang.c (pascal_language_defn): Likewise.
	* scm-lang.c (scm_language_defn): Likewise

	* gdb.cp/pass-by-ref.cc, gdb.cp/pass-by-ref.exp: New files.
@
text
@d10330 1
a10330 1
ada_language_arch_info (struct gdbarch *current_gdbarch,
d10333 1
a10333 1
  const struct builtin_type *builtin = builtin_type (current_gdbarch);
d10335 1
a10335 1
    = GDBARCH_OBSTACK_CALLOC (current_gdbarch, nr_ada_primitive_types + 1,
d10339 1
a10339 1
	       gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT,
d10343 1
a10343 1
	       gdbarch_long_bit (current_gdbarch) / TARGET_CHAR_BIT,
d10347 1
a10347 1
	       gdbarch_short_bit (current_gdbarch) / TARGET_CHAR_BIT,
d10355 1
a10355 1
	       gdbarch_float_bit (current_gdbarch)/ TARGET_CHAR_BIT,
d10359 1
a10359 1
	       gdbarch_double_bit (current_gdbarch) / TARGET_CHAR_BIT,
d10363 1
a10363 1
	       gdbarch_long_long_bit (current_gdbarch) / TARGET_CHAR_BIT,
d10367 1
a10367 1
	       gdbarch_double_bit (current_gdbarch) / TARGET_CHAR_BIT,
d10371 1
a10371 1
	       gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT,
d10375 1
a10375 1
	       gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT,
@


1.105
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d10444 1
@


1.104
log
@        * ada-lang.c (resolve_subexp): Correct arity of binary operators.
@
text
@d6 1
a6 1
This file is part of GDB.
d8 12
a19 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
@


1.103
log
@        * ada-lang.c (possible_user_operator_p): Alternative fix to last
        checkin guarding against NULL.
@
text
@d2694 3
@


1.102
log
@        * ada-lang.c (field_alignment): Guard against NULL.
@
text
@d3535 1
a3535 8
      return
        ((TYPE_CODE (type0) != TYPE_CODE_ARRAY
          && (TYPE_CODE (type0) != TYPE_CODE_PTR
              || TYPE_CODE (TYPE_TARGET_TYPE (type0)) != TYPE_CODE_ARRAY))
         || (type1 != NULL && TYPE_CODE (type1) != TYPE_CODE_ARRAY
             && (TYPE_CODE (type1) != TYPE_CODE_PTR
                 || (TYPE_CODE (TYPE_TARGET_TYPE (type1)) 
		     != TYPE_CODE_ARRAY))));
@


1.101
log
@2007-08-14  Michael Snyder  <msnyder@@access-company.com>

	* ada-lang.c (possible_user_operator_p): Guard against NULL.
@
text
@d6119 1
a6119 1
  int len = (name == NULL) ? 0 : strlen (name);
d6122 8
@


1.100
log
@2007-08-06  Michael Snyder  <msnyder@@access-company.com>

	* ada-lang.c (desc_bounds): Comparison of function address to NULL.
@
text
@d3539 1
a3539 1
         || (TYPE_CODE (type1) != TYPE_CODE_ARRAY
@


1.99
log
@	* expression.h (enum exp_opcode): Document a register name for
	OP_REGISTER.
	* parse.c (write_dollar_variable): Write the register name for
	OP_REGISTER.
	(operator_length_standard): Expect the register name following
	OP_REGISTER.
	* ada-lang.c (resolve_subexp): Likewise.
	* ax-gdb.c (gen_expr): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* expprint.c (print_subexp_standard, dump_subexp_body_standard):
	Likewise.
	* tracepoint.c (encode_actions): Likewise.
@
text
@d1325 1
a1325 1
      if (desc_bounds_type == NULL)
@


1.98
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_FLOAT_BIT): Replace by gdbarch_float_bit.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* mdebugread.c (_initialize_mdebugread): Likewise.
	* m2-lang.c (m2_create_fundamental_type)
	(_initialize_m2_language): Likewise.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbarch.sh (TARGET_FLOAT_FORMAT): Replace by gdbarch_float_format.
	* value.c (unpack_double): Likewise (comment).
	* gdbtypes.c (build_gdbtypes): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* gdbarch.sh (TARGET_DOUBLE_BIT): Replace by gdbarch_double_bit.
	* valarith.c (value_binop): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* mdebugread.c (_initialize_mdebugread): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* cris-tdep.c (cris_gdbarch_init): Likewise (comment).
	* c-lang.c (c_create_fundamental_type): Likewise.
	* ada-lex.l (processReal): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbarch.sh (TARGET_DOUBLE_FORMAT): Replace by gdbarch_double_format.
	* value.c (unpack_double): Likewise (comment).
	* gdbtypes.c (build_gdbtypes): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* gdbarch.sh (TARGET_LONG_DOUBLE_BIT): Replace by
	gdbarch_long_double_bit.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* ada-lex.l (processReal): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbarch.sh (TARGET_LONG_DOUBLE_FORMAT): Replace by
	gdbarch_long_double_format.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@a2712 1
    case OP_REGISTER:
d2722 4
@


1.97
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_SHORT_BIT): Replace by gdbarch_int_bit.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* gdbarch.sh (TARGET_INT_BIT): Replace by gdbarch_int_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type, ada_language_arch_info)
	(gdbtypes_post_init, build_gdbtypes): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* parse.c (build_parse): Likewise.
	* xcoffread.c (_initialize_xcoffread): Likewise.
	* stabsread.c (define_symbol, read_one_struct_field, read_enum_type)
	(read_range_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* f-lang.c (build_fortran_types, f_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type, _initialize_m2_language)
	(m2_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (coff_read_enum_type): Likewise.
	* mdebugread.c (parse_symbol, _initialize_mdebugread): Likewise.
	* dwarf2read.c (new_symbol): Likewise.
	* gdbarch.sh (TARGET_LONG_BIT): Replace by gdbarch_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* valarith.c (value_binop): Likewise.
	* symfile.c (read_target_long_array, simple_overlay_update_1): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* symfile.c (TARGET_LONG_BYTES): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (decode_base_type): Likewise.
	* gdbarch.sh (TARGET_LONG_LONG_BIT): Replace by gdbarch_long_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (gdbtypes_post_init, build_gdbtypes): Likewise.
	* stabsread.c (read_range_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d10290 1
a10290 1
                        TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
d10295 1
a10295 1
                        TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
d10300 2
a10301 1
                        TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
d10349 2
a10350 1
    init_type (TYPE_CODE_FLT, TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
d10353 2
a10354 1
    init_type (TYPE_CODE_FLT, TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
d10361 2
a10362 1
    init_type (TYPE_CODE_FLT, TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
@


1.96
log
@2007-06-06  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (INNER_THAN): Replace by gdbarch_inner_than.
	* infcall.c (call_function_by_hand): Likewise.
	* gcore.c (derive_stack_segment): Likewise.
	* frame.c (frame_id_inner): Likewise.
	* arch-utils.c (core_addr_lessthan): Likewise (comment).
	* ada-lang.c (ensure_lval): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d10201 1
a10201 1
                        TARGET_INT_BIT / TARGET_CHAR_BIT,
d10227 1
a10227 1
                        TARGET_SHORT_BIT / TARGET_CHAR_BIT,
d10232 1
a10232 1
                        TARGET_SHORT_BIT / TARGET_CHAR_BIT,
d10237 1
a10237 1
                        TARGET_SHORT_BIT / TARGET_CHAR_BIT,
d10242 1
a10242 1
                        TARGET_INT_BIT / TARGET_CHAR_BIT,
d10246 2
a10247 2
      type = init_type (TYPE_CODE_INT, TARGET_INT_BIT /
			TARGET_CHAR_BIT, 
d10252 1
a10252 1
                        TARGET_INT_BIT / TARGET_CHAR_BIT,
d10257 1
a10257 1
                        TARGET_LONG_BIT / TARGET_CHAR_BIT,
d10262 1
a10262 1
                        TARGET_LONG_BIT / TARGET_CHAR_BIT,
d10267 1
a10267 1
                        TARGET_LONG_BIT / TARGET_CHAR_BIT,
d10272 3
a10274 2
                        TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
                        0, "long_long_integer", objfile);
d10278 3
a10280 2
                        TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
                        0, "long_long_integer", objfile);
d10284 3
a10286 2
                        TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned long long", objfile);
d10332 3
a10334 2
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
               0, "integer", (struct objfile *) NULL);
d10336 3
a10338 2
    init_type (TYPE_CODE_INT, TARGET_LONG_BIT / TARGET_CHAR_BIT,
               0, "long_integer", (struct objfile *) NULL);
d10340 3
a10342 2
    init_type (TYPE_CODE_INT, TARGET_SHORT_BIT / TARGET_CHAR_BIT,
               0, "short_integer", (struct objfile *) NULL);
d10354 2
a10355 1
    init_type (TYPE_CODE_INT, TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
d10361 3
a10363 2
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
               0, "natural", (struct objfile *) NULL);
d10365 3
a10367 2
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
               0, "positive", (struct objfile *) NULL);
@


1.95
log
@        Add support for exception handling with multiple versions of
        the Ada runtime:
        * ada-lang.c: Update general comments on how Ada exception catchpoints
        are implemented.
        (raise_sym_name, raise_unhandled_sym_name, raise_assert_sym_name)
        (__gnat_raise_nodefer_with_msg): Delete.
        (ada_unhandled_exception_name_addr_ftype): New type.
        (exception_support_info): New type.
        (ada_unhandled_exception_name_addr): Add forward declaration.
        (ada_unhandled_exception_name_addr_from_raise): Likewise.
        (default_exception_support_info): New constant.
        (exception_support_info_fallback): Likewise.
        (exception_info): New global variable.
        (ada_exception_support_info_sniffer): New function.
        (ada_executable_changed_observer): Likewise.
        (ada_unhandled_exception_name_addr_from_raise): Renamed from
        ada_unhandled_exception_name_addr.
        (ada_unhandled_exception_name_addr): Reimplement to match the
        latest Ada runtime implementation.
        (error_breakpoint_runtime_sym_not_found): Delete.
        (ada_exception_sym_name): Get the exception sym name from
        exception_info rather than hardcoding it.
        (ada_exception_sal): Add call to ada_exception_support_info_sniffer.
        Update error handling.
        * Makefile.in (ada-lang.o): Add dependency on observer.h.
@
text
@d3637 1
a3637 1
      if (INNER_THAN (1, 2))
@


1.94
log
@	* linespec.c: Include language.h.
	(find_methods): Add language parameter.  Call
	lookup_symbol_in_language.  Pass language down.
	(add_matching_methods): Likewise.  Call
	lookup_symbol_in_language.
	(add_constructors): Likewise.
	(find_method): Pass sym_class to collect_methods.
	(collect_methods): Add sym_class parameter.  Pass language
	down.
	* symtab.c (lookup_symbol): Rename to ...
	(lookup_symbol_in_language): ... this.  Add language
	parameter.  Use passed language instead of current_language.
	(lookup_symbol): New as wrapper around
	lookup_symbol_in_language.
	(lookup_symbol_aux): Add language parameter.  Use passed
	language instead of current_language.
	(search_symbols): Indent.
	* symtab.h (enum language): Forward declare.
	(lookup_symbol_in_language): Declare.
	(lookup_symbol): Update description.
	* ada-lang.h (lookup_symbol_in_language): Remove declaration.
	* ada-lang.c (restore_language): Remove.
	(lookup_symbol_in_language): Remove.
@
text
@d59 1
a293 17
/* The name of the runtime function called when an exception is raised.  */
static const char raise_sym_name[] = "__gnat_raise_nodefer_with_msg";

/* The name of the runtime function called when an unhandled exception
   is raised.  */
static const char raise_unhandled_sym_name[] = "__gnat_unhandled_exception";

/* The name of the runtime function called when an assert failure is
   raised.  */
static const char raise_assert_sym_name[] =
  "system__assertions__raise_assert_failure";

/* A string that reflects the longest exception expression rewrite,
   aside from the exception name.  */
static const char longest_exception_template[] =
  "'__gnat_raise_nodefer_with_msg' if long_integer(e) = long_integer(&)";

d8954 6
d8982 130
d9212 11
d9240 1
a9240 1
          && strcmp (func_name, raise_sym_name) == 0)
d9269 1
a9269 1
        return ada_unhandled_exception_name_addr ();
a9519 33
/* Cause the appropriate error if no appropriate runtime symbol is
   found to set a breakpoint, using ERR_DESC to describe the
   breakpoint.  */

static void
error_breakpoint_runtime_sym_not_found (const char *err_desc)
{
  /* If we are not debugging an Ada program, we cannot put exception
     catchpoints!  */

  if (ada_update_initial_language (language_unknown, NULL) != language_ada)
    error (_("Unable to break on %s.  Is this an Ada main program?"),
           err_desc);

  /* If the symbol does not exist, then check that the program is
     already started, to make sure that shared libraries have been
     loaded.  If it is not started, this may mean that the symbol is
     in a shared library.  */

  if (ptid_get_pid (inferior_ptid) == 0)
    error (_("Unable to break on %s. Try to start the program first."),
           err_desc);

  /* At this point, we know that we are debugging an Ada program and
     that the inferior has been started, but we still are not able to
     find the run-time symbols. That can mean that we are in
     configurable run time mode, or that a-except as been optimized
     out by the linker...  In any case, at this point it is not worth
     supporting this feature.  */

  error (_("Cannot break on %s in this configuration."), err_desc);
}

d9613 2
d9618 1
a9618 1
        return (raise_sym_name);
d9621 1
a9621 1
        return (raise_unhandled_sym_name);
d9624 1
a9624 1
        return (raise_assert_sym_name);
d9703 4
a9706 1
  /* First lookup the function on which we will break in order to catch
d9730 1
a9730 1
    error_breakpoint_runtime_sym_not_found (sym_name);
@


1.93
log
@2007-02-09  Gabriel Dos Reis  <gdr@@integrable-solutions.net>

        * ada-lang.c (remove_out_of_scope_renamings): Change third
          parameter's
        type to a pointer to const struct block.
        (ada_lookup_symbol_list): Don't cast away constness when
          calling
        remove_out_of_scope_renamings.

2007-02-09  Gabriel Dos Reis  <gdr@@integrable-solutions.net>

        * linux-nat.c (linux_nat_find_memory_regions): Don't check the
        address of 'filename'; it is always non null.
@
text
@a4215 25
/* FIXME: The next two routines belong in symtab.c */

static void
restore_language (void *lang)
{
  set_language ((enum language) lang);
}

/* As for lookup_symbol, but performed as if the current language 
   were LANG. */

struct symbol *
lookup_symbol_in_language (const char *name, const struct block *block,
                           domain_enum domain, enum language lang,
                           int *is_a_field_of_this, struct symtab **symtab)
{
  struct cleanup *old_chain
    = make_cleanup (restore_language, (void *) current_language->la_language);
  struct symbol *result;
  set_language (lang);
  result = lookup_symbol (name, block, domain, is_a_field_of_this, symtab);
  do_cleanups (old_chain);
  return result;
}

@


1.92
log
@        * ada-lang.c (ada_exception_breakpoint_ops): Fix typo in function name.
        (ada_exception_sal): Update accordingly.
@
text
@d4422 1
a4422 1
                               int nsyms, struct block *current_block)
d4659 1
a4659 2
  ndefns = remove_out_of_scope_renamings (*results, ndefns,
                                          (struct block *) block0);
@


1.91
log
@	* objfiles.h (ALL_PRIMARY_SYMTABS): Define.

	* ada-lang.c (symtab_for_sym, ada_lookup_symbol_list)
	(ada_lookup_symbol): Use ALL_PRIMARY_SYMTABS.
	* cp-support.c (make_symbol_overload_list_qualified): Likewise.
	* symtab.c (lookup_symbol_aux_block, lookup_symbol_aux_symtabs)
	(basic_lookup_transparent_type, find_pc_sect_symtab, search_symbols)
	(make_symbol_completion_list): Likewise.
@
text
@d9562 1
a9562 1
ada_exception_breakption_ops (enum exception_catchpoint_kind ex)
d9688 1
a9688 1
  *ops = ada_exception_breakption_ops (ex);
@


1.90
log
@        * ada-lang.c (is_known_support_routine): Improve the implementation.
@
text
@d4123 1
a4123 1
  ALL_SYMTABS (objfile, s)
d4552 1
a4552 1
  ALL_SYMTABS (objfile, s)
a4554 2
    if (!s->primary)
      continue;
d4620 1
a4620 1
      ALL_SYMTABS (objfile, s)
a4622 2
        if (!s->primary)
          continue;
d4702 1
a4702 1
          ALL_SYMTABS (objfile, s)
@


1.89
log
@        * ada-lang.c: Add include of source.h.
        (is_known_support_routine): Improve the check verifying that the file
        associated to this frame exists.
        * Makefile.in (ada-lang.o): Add dependency on source.h.
@
text
@d9045 1
a9045 13
  struct frame_info *next_frame = get_next_frame (frame);
  /* If frame is not innermost, that normally means that frame->pc
     points to *after* the call instruction, and we want to get the line
     containing the call, never the next line.  But if the next frame is
     a signal_handler_caller or a dummy frame, then the next frame was
     not entered as the result of a call, and we want to get the line
     containing frame->pc.  */
  const int pc_is_after_call =
    next_frame != NULL
    && get_frame_type (next_frame) != SIGTRAMP_FRAME
    && get_frame_type (next_frame) != DUMMY_FRAME;
  struct symtab_and_line sal
    = find_pc_line (get_frame_pc (frame), pc_is_after_call);
d9049 2
a9050 6
  /* The heuristic:
     1. The symtab is null (indicating no debugging symbols)
     2. The symtab's filename does not exist.
     3. The object file's name is one of the standard libraries.
     4. The symtab's file name has the form of an Ada library source file.
     5. The function at frame's PC has a GNAT-compiler-generated name.  */
d9052 1
d9056 5
a9060 3
  /* On some systems (e.g. VxWorks), the kernel contains debugging
     symbols; in this case, the filename referenced by these symbols
     does not exists.  */
d9065 5
d9075 3
a9077 9
    }
  if (sal.symtab->objfile != NULL)
    {
      for (i = 0; known_runtime_file_name_patterns[i] != NULL; i += 1)
        {
          re_comp (known_runtime_file_name_patterns[i]);
          if (re_exec (sal.symtab->objfile->name))
            return 1;
        }
d9080 1
a9080 9
  /* If the frame PC points after the call instruction, then we need to
     decrement it in order to search for the function associated to this
     PC.  Otherwise, if the associated call was the last instruction of
     the function, we might either find the wrong function or even fail
     during the function name lookup.  */
  if (pc_is_after_call)
    func_name = function_name_from_pc (get_frame_pc (frame) - 1);
  else
    func_name = function_name_from_pc (get_frame_pc (frame));
d9082 1
@


1.88
log
@        * ada-lang.c (ada_evaluate_subexp) [OP_TYPE]: Return a value with
        the appropriate type rather than a bogus void type.
@
text
@d58 1
a9059 1
  struct stat st;
d9075 1
a9075 1
  if (stat (sal.symtab->filename, &st))
@


1.87
log
@        * ada-lang.h (ada_find_printable_frame): Remove.
        (ada_exception_catchpoint_p, ada_decode_exception_location)
        (ada_decode_assert_location): Add declaration.
        * ada-lang.c: Add include of annotate.h and valprint.h.
        (exception_catchpoint_kind): New enum.
        (function_name_from_pc, is_known_support_routine)
        (ada_find_printable_frame, ada_unhandled_exception_name_addr)
        (ada_exception_name_addr_1, ada_exception_name_addr)
        (print_it_exception, print_one_exception, print_mention_exception)
        (print_it_catch_exception, print_one_catch_exception)
        (print_mention_catch_exception, catch_exception_breakpoint_ops)
        (print_it_catch_exception_unhandled)
        (print_one_catch_exception_unhandled)
        (print_mention_catch_exception_unhandled, print_it_catch_assert)
        (print_one_catch_assert, print_mention_catch_assert)
        (ada_exception_catchpoint_p, error_breakpoint_runtime_sym_not_found)
        (ada_get_next_arg, catch_ada_exception_command_split)
        (ada_exception_sym_name, ada_exception_sym_name)
        (ada_exception_breakption_ops, ada_exception_catchpoint_cond_string)
        (ada_parse_catchpoint_condition, ada_exception_sal)
        (ada_decode_exception_location)
        (ada_decode_assert_location): New function.
        (catch_exception_unhandled_breakpoint_ops): New global variable.
        (catch_assert_breakpoint_ops): New global variable.
        * breakpoint.c: Add include of ada-lang.h.
        (print_one_breakpoint): Do not print the condition for Ada
        exception catchpoints.
        (create_ada_exception_breakpoint): New function.
        (catch_ada_exception_command, catch_assert_command): New function.
        (catch_command_1): Add support for the new "catch exception" and
        "catch assert" commands.
        (_initialize_breakpoint): Add help description for the new catch
        commands.
        * Makefile.in (ada-lang.o): Add dependency on annotate.h and
        valprint.h.
        (breakpoint.o): Add dependency on ada-lang.h.
@
text
@d8581 1
a8581 1
        return allocate_value (builtin_type_void);
@


1.86
log
@	Warning fixes.
	* ada-lang.c (find_struct_field): Initialize *byte_offset_p.
	* breakpoint.c (do_enable_breakpoint): Ignore both mem_cnt and i.
	* c-typeprint.c (c_type_print_varspec_suffix): Don't test length
	greater than or equal to zero.
	* m2-typeprint.c (m2_array): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	* gdbtypes.c (copy_type_recursive): Correct == typo.
	* i386-tdep.c (i386_skip_prologue): Remove stray semicolon.
	* linux-nat.c (linux_nat_info_proc_cmd): Don't compare a pointer
	greater than zero.
	* macroscope.c (sal_macro_scope): Don't name a local variable "main".
	(default_macro_scope): Remove unused variable.
	* prologue-value.h (pv_area_find_reg): Don't name an argument
	"register".
	* remote-fileio.c (remote_fio_func_map): Add missing braces.
	* remote.c (sigint_remote_twice_token, sigint_remote_token): Change
	type.
	(cleanup_sigint_signal_handler): Remove casts.
	* valprint.c (val_print): Use a volatile local for the modified
	argument.
	* varobj.c (languages): Remove extra array dimension.
	(varobj_create): Correct access to languages array.
	* mi/mi-cmd-break.c (mi_cmd_break_insert, mi_cmd_break_watch): Add
	missing braces.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Likewise.
	* mi/mi-cmd-env.c (mi_cmd_env_path, mi_cmd_env_dir): Likewise.
	* mi/mi-getopt.c (mi_valid_noargs): Likewise.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	(mi_cmd_data_write_memory): Likewise.
	* signals/signals.c (target_signal_to_string): Cast to int before
	comparing.
	* tui/tui-layout.c (init_and_make_win): Take and return a void *.
	Update all callers.
@
text
@d3 2
a4 2
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004, 2005 Free
   Software Foundation, Inc.
d56 2
d8978 780
@


1.85
log
@2006-11-30  Jim Blandy  <jimb@@codesourcery.com>

	* ada-lang.c (value_subscript_packed): Don't bother to set the
	lvalue type of the returned value here;
	ada_value_primitive_packed_val takes care of that.
@
text
@d5631 1
a5631 1
    *byte_offset_p;
@


1.84
log
@* ada-exp.y (yyerror): Change message to ignore the argument, avoiding
translation problems.
* ada-lang.c (ada_value_struct_elt): Change interface and handling
of errors to avoid translation problem (and less than optimal error
messages).
(ada_value_tag, ada_tag_name_1, ada_tag_name_2,	ada_evaluate_subexp):
Use new interface to ada_value_struct_elt.
* ada_lang.h (ada_value_struct_elt): Update declaration to new
interface.

* ChangeLog: remove reference to ada-tasks.c from entry of
2006-01-07.
@
text
@a1889 4
  if (VALUE_LVAL (arr) == lval_internalvar)
    VALUE_LVAL (v) = lval_internalvar_component;
  else
    VALUE_LVAL (v) = VALUE_LVAL (arr);
@


1.83
log
@* ada-exp.y, ada-lex.l, ada-typeprint.c: I18n markup.
* ada-tasks.c, ada-lang.c: I18n markup.
Editorial: change "can not" => "cannot" throughout.
@
text
@d5223 1
a5223 1
  return ada_value_struct_elt (val, "_tag", "record");
d5282 1
a5282 1
  val = ada_value_struct_elt (args->tag, "tsd", NULL);
d5285 1
a5285 1
  val = ada_value_struct_elt (val, "expanded_name", NULL);
d5320 1
a5320 1
  val = ada_value_struct_elt (val, "expanded_name", NULL);
d5826 2
a5827 5
   ERR is a name (for use in error messages) that identifies the class
   of entity that ARG is supposed to be.  ERR may be null, indicating
   that on error, the function simply returns NULL, and does not
   throw an error.  (FIXME: True only if ARG is a pointer or reference
   at the moment). */
d5830 1
a5830 1
ada_value_struct_elt (struct value *arg, char *name, char *err)
d5841 1
a5841 6
        {
          if (err == NULL)
            return NULL;
          else
            error (_("Bad value type in a %s."), err);
        }
d5854 1
a5854 6
        {
          if (err == NULL)
            return NULL;
          else
            error (_("Bad value type in a %s."), err);
        }
d5866 1
a5866 7
    {
      if (err == NULL)
        return NULL;
      else
        error (_("Attempt to extract a component of a value that is not a %s."),
               err);
    }
d5902 3
a5904 1
  if (v == NULL && err != NULL)
d5907 5
a5911 1
  return v;
d8575 1
a8575 1
                               (arg1, &exp->elts[pc + 2].string, _("record"))));
@


1.82
log
@	* ada-exp.y: Considerable reorganization to move functionality
	from ada-lex.l to here, where it is logically more appropriate.
	The original reason, however, was to prevent premature name
	lookups for selector names in record aggregates.
	(BLOCKNAME, TYPENAME, OBJECT_RENAMING): Remove; lexer now returns
	NAME for all of these.
	(VAR): New artificial token to clarify precedence rules.
	(OTHERS): New lexeme.
	(empty_stoken): New symbol.
	(%union): Remove ssym, voidval.
	(%type): Remove <voidval> type declarations.
	(syntax definitions): Add aggregates.
	Remove distinction between NAME, TYPENAME, BLOCKNAME, OBJECT_RENAMING.
	Rename some non-terminals to be closer to reference manual usage.
	Tighten up expression syntax to disallow certain non-Ada
	constructions such as X and then Y or else Z.
	(ada_parse): Remove initialization of left_block_context.
	(write_var_from_name): Remove.
	(write_var_or_type): New function, containing previous code from
	defunct write_var_from_name and name_lookup.
	(block_lookup): New function, moved from ada-lex.l
	(select_possible_type_sym): New function, factored out of
	name_lookup, which used to be in ada-lex.l.
	(find_primitive_type): Ditto.
	(chop_selector): Ditto.
	(write_ambiguous_var): New function, factored out of defunct
	write_var_from_name.
	(write_selectors): New function.
	(write_name_assoc): New function.
	(write_exp_op_with_string): New function.

	* ada-lex.l (processId): Change interface to return stoken.
	(tempbuf, resize_tempbuf, tempbuf_size, tempbuf_len): Remove.
	(block_lookup, name_lookup): Remove.  Functionality moved to
	ada-exp.y.
	(state IN_STRING): Remove.
	(rules): Handle string escapes in processString.
	Add 'others' token.
	Return all NAMEs, BLOCKNAMEs, OBJECT_RENAMINGs, TYPENAMEs in
	yylval.sval (as simple strings).
	All name look-ups now handled in ada-exp.y.
	Introduce "::" (COLONCOLON) token and return as separate token.
	(processId): Change return convention.  Comment.
	Leave leading "'" in place.
	(processString): New function.
	(find_dot_all): Add note to comment.
	Fix problem that allowed match only at the end.

	* ada-lang.c: Introduce aggregates.
	(find_struct_field): Add new parameter to count fields skipped, and
	allow other output parameters to be NULL.
	(value_tag_from_contents_and_address, ada_value_struct_elt): Use
	new find_struct_field.
	(ada_index_struct_field, assign_aggregate, ada_is_array_type)
	(num_visible_fields, ada_index_struct_field_1, ada_index_struct_field)
	(num_component_specs, assign_component, assign_aggregate):
	(aggregate_assign_from_choices,aggregate_assign_positional)
	(aggregate_assign_others,add_component_interval):
	New functions.
	(ada_evaluate_subexp): Declare.
	Add aggregate-related operators.
	(ada_forward_operator_length): Declare.
	(resolve_subexp): Add cases for new aggregate operators and OP_NAME.
	Consolidate Ada operators, using ada_forward_operator_length.
	(ada_search_struct_field): Search in forward order.
	(ADA_OPERATORS): Add new aggregate operators.
	(ada_operator_length, ada_op_name, ada_forward_operator_length)
	(ada_dump_subexp_body, ada_print_subexp): Handle new aggregate
	operators and OP_NAME.
	(ada_type_of_array): Use longest_to_int.
	(value_assign_to_component): New function.
	(ada_forward_operator_length, ada_op_name, ada_dump_subexp_body):
	Add OP_NAME case.
	(ada_forward_operator_length, ada_dump_subexp_body):
	Add OP_STRING case.

	* ada-lang.h (enum ada_operator): Add OP_AGGREGATE, OP_OTHERS,
	OP_CHOICES, OP_DISCRETE_RANGE, OP_POSITIONAL.
@
text
@d4355 1
a4355 1
     functions names can not contain "__" in them.  */
d6830 1
a6830 1
         and thus the actual object value can not be inspected to do
d6858 1
a6858 1
         and thus the actual object value can not be inspected to do
d7695 1
a7695 1
    warning ("Extra components in aggregate ignored.");
d8148 2
a8149 2
          error (_("Attempt to index or call something other than an \
array or function"));
d8242 2
a8243 2
          lim_warning (_("Membership test incompletely implemented; \
always returns true"));
d8588 1
a8588 1
                               (arg1, &exp->elts[pc + 2].string, "record")));
d8611 1
a8611 1
		   "component association: %s."), &exp->elts[pc+2].string);
d8615 1
a8615 1
	    internal_error (__FILE__, __LINE__, "aggregate apparently mangled");
@


1.81
log
@	* ada-lang.c (process_raise_exception_name): Remove extraneous
        definition from unsubmitted code.
	(is_lower_alphanum): New function.
	(ada_decode):  Add support for decoding protected object subprograms
	and entries, and of entities declared inside protected object
	subprograms.
	Also add missing handling for__{DIGITS}+ suffixes.
	Allow '$<digits>' as valid overloading suffix.
	(is_name_suffix): Add handling for protected type entriy suffixes.
	Also add support for protected type subprogram suffixes, but keep
	it commented out for now, as there is an ambiguity between these
	entities and other internally generated entities.
	Allow '$<digits>' as valid overloading suffix.
	(is_valid_name_for_wild_match): New function.
	(wild_match): Add an exra level of verification of the entity name
	before declaring it a match for the given pattern.
	(ada_type_of_array, ada_evaluate_subexp): Use more proper
	longest_to_int rather than cast.
	(ada_evaluate_subexp): Use "invalid" rather than "illegal" in comment.
	(ada_coerce_to_simple_array): Call check_size to make sure
	that the object size is reasonable.
	(ada_value_primitive_packed_val):  Use correct location in target
	buffer for extracting packed record fields that are themselves records.
	(add_defn_to_vec): Do not try to replace a stub type by its full
	type. Avoids a potential infinite loop.
	(ada_lookup_symbol): Move return incorrectly placed return statement,
	causing a loop that should be scanning all object files to only
	scan the first one.
	(ada_tag_name_2): New function.
	(ada_tag_name_1): If no 'tsd' field found in the dispatching table,
	use alternative representation.
	(ada_find_renaming_symbol): Strip the function name suffix when
	computing the XR type name.
	(ada_to_fixed_type): Try determining the tag only if we have the
	object's address.
	(to_fixed_array_type): Add comments.
	(ada_check_typedef): Replace expression checking whether the given
	type is a stub or not by a "call" to TYPE_STUB. Clearer and more
	consistent.

	* ada-lang.h (ADA_KNOWN_AUXILIARY_FUNCTION_NAME_PATTERNS): Allow
	'$' in addition to '.' for runtime auxiliary function name suffixes.
	See changes to ada_decode above.
	(struct task_control_block): Add field called_task.  (This change is
	to keep synchronized with our local sources; it does not affect the
	public version yet.)

	* ada-typeprint.c (ada_print_type): Use int_string for printing
	modulus of modular type.
	(print_range): Trivial editorial comment fix.

	* ada-valprint.c (ada_emit_char): Use normal Ada syntax for
	double quote in string.
@
text
@d188 2
d221 1
a221 1
                              struct type **, int *, int *, int *);
d240 31
d1521 13
d2148 8
a2158 2
  toval = coerce_ref (toval);

d2168 1
d2173 1
a2173 1
      read_memory (VALUE_ADDRESS (toval) + value_offset (toval), buffer, len);
d2182 4
a2185 3
      write_memory (VALUE_ADDRESS (toval) + value_offset (toval), buffer,
                    len);

d2198 35
d2614 1
d2620 2
a2621 1
  /* Pass one: resolve operands, saving their types and updating *pos.  */
a2635 5
    case UNOP_QUAL:
      *pos += 3;
      resolve_subexp (expp, pos, 1, exp->elts[pc + 1].type);
      break;

d2641 3
a2643 2
    case OP_ATR_MODULUS:
      *pos += 4;
d2646 1
a2648 4
      *pos += 1;
      nargs = 1;
      break;

a2653 4
      *pos += 1;
      nargs = 2;
      break;

d2656 11
a2666 2
      *pos += 1;
      nargs = 3;
a2682 1
    case UNOP_IN_RANGE:
a2710 3
      *pos += 1;
      nargs = 2;
      break;
a2744 6
    case OP_STRING:
      (*pos) += 3 
        + BYTES_TO_EXP_ELEM (longest_to_int (exp->elts[pc + 1].longconst) 
                             + 1);
      break;

a2745 1
    case TERNOP_IN_RANGE:
d2750 1
a2750 3
    case BINOP_IN_BOUNDS:
      *pos += 3;
      nargs = 2;
d3634 1
d5238 1
a5238 1
                         &dummy1, &dummy2))
d5607 15
a5621 7
/* Find field with name NAME in object of type TYPE.  If found, return 1
   after setting *FIELD_TYPE_P to the field's type, *BYTE_OFFSET_P to 
   OFFSET + the byte offset of the field within an object of that type, 
   *BIT_OFFSET_P to the bit offset modulo byte size of the field, and
   *BIT_SIZE_P to its size in bits if the field is packed, and 0 otherwise.
   Looks inside wrappers for the field.  Returns 0 if field not
   found. */
d5625 2
a5626 1
                   int *byte_offset_p, int *bit_offset_p, int *bit_size_p)
a5630 2
  *field_type_p = NULL;
  *byte_offset_p = *bit_offset_p = *bit_size_p = 0;
d5632 10
a5641 1
  for (i = TYPE_NFIELDS (type) - 1; i >= 0; i -= 1)
d5650 1
a5650 1
      else if (field_name_match (t_field_name, name))
d5653 8
a5660 4
          *field_type_p = TYPE_FIELD_TYPE (type, i);
          *byte_offset_p = fld_offset;
          *bit_offset_p = bit_pos % 8;
          *bit_size_p = bit_size;
d5665 3
a5667 3
          if (find_struct_field (name, TYPE_FIELD_TYPE (type, i), fld_offset,
                                 field_type_p, byte_offset_p, bit_offset_p,
                                 bit_size_p))
d5672 2
d5675 2
a5676 1
          struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type, i));
d5678 1
a5678 1
          for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
d5684 1
a5684 1
                                     bit_offset_p, bit_size_p))
d5688 2
d5694 1
d5696 8
d5718 1
a5718 1
  for (i = TYPE_NFIELDS (type) - 1; i >= 0; i -= 1)
d5740 1
d5745 1
a5745 1
          for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
d5759 56
d5903 1
a5903 1
                             &bit_size))
d7528 323
a7850 1
struct value *
d7859 1
a7859 1
  int nargs;
d7923 7
d8027 1
a8027 1
           illegal.  */
d8599 24
d9014 4
a9017 1
    OP_DEFN (UNOP_IN_RANGE, 3, 1, 0)
d9032 10
d9052 1
d9056 7
d9068 1
a9068 1
   Ada-specific operators.  */
d9079 1
d9084 19
d9142 2
a9143 1
      fprintf_filtered (stream, " (%d)", (int) exp->elts[pc + 2].longconst);
d9148 16
d9181 1
a9181 1
  int oplen, nargs;
d9187 1
d9191 1
a9195 1
      *pos += oplen;
a9200 1
      *pos += oplen;
a9210 1
      *pos += oplen;
a9233 1
      *pos += oplen;
a9255 1
      *pos += oplen;
a9262 1
      *pos += oplen;
d9268 37
@


1.80
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@a268 6
/* When GDB stops on an unhandled exception, GDB will go up the stack until
   if finds a frame corresponding to this function, in order to extract the
   name of the exception that has been raised from one of the parameters.  */
static const char process_raise_exception_name[] =
  "ada__exceptions__process_raise_exception";

d818 10
a827 2
/* decode:
     0. Discard trailing .{DIGIT}+ or trailing ___{DIGIT}+
d830 7
a836 5
     1. Discard final __{DIGIT}+ or $({DIGIT}+(__{DIGIT}+)*)
     2. Convert other instances of embedded "__" to `.'.
     3. Discard leading _ada_.
     4. Convert operator names to the appropriate quoted symbols.
     5. Remove everything after first ___ if it is followed by
d838 4
a841 3
     6. Replace TK__ with __, and a trailing B or TKB with nothing.
     7. Put symbols that should be suppressed in <...> brackets.
     8. Remove trailing X[bn]* suffix (indicating names in package bodies).
d864 1
a864 1
  /* Remove trailing .{DIGIT}+ or ___{DIGIT}+.  */
d873 2
d877 2
d881 15
d959 3
d964 53
d1581 2
a1582 2
                             (int) value_as_long (low),
                             (int) value_as_long (high));
d1623 1
d1967 1
a1967 1
          targ = src;
a2090 1

d3847 9
a3855 2
  if (SYMBOL_TYPE (sym) != NULL)
    SYMBOL_TYPE (sym) = ada_check_typedef (SYMBOL_TYPE (sym));
a4639 1
            return fixup_symbol_section (candidates[0].sym, NULL);
d4641 8
d4672 2
a4673 2
   (__[0-9]+)?\.[0-9]+  [nested subprogram suffix, on platforms such 
                         as GNU/Linux]
d4675 1
d4697 1
a4697 1
  if (matching[0] == '.')
d4716 28
d4825 18
d4908 1
a4908 1
        return 1;
d5188 4
d5207 35
d6071 6
a6076 1
      const int function_name_len = strlen (function_name);
d6080 3
d6660 8
d6688 8
d6718 8
a6725 2
   ADDRESS or in VALADDR contains these discriminants.  */

d6738 6
a6743 1
        if (ada_is_tagged_type (static_type, 0))
d6841 1
a6841 1
      || (TYPE_FLAGS (type) & TYPE_FLAG_STUB) == 0
d7721 2
a7722 2
                                            (int) low_bound, 
					    (int) high_bound);
d7730 2
a7731 1
          return ada_value_slice (array, (int) low_bound, (int) high_bound);
@


1.79
log
@2005-10-03  Joel Brobecker  <brobecker@@adacore.com>

        * language.h (language_defn): New field la_print_array_index.
        (LA_PRINT_ARRAY_INDEX): New macro.
        (default_print_array_index): Add declaration.
        * language.c (default_print_array_index): new function.
        (unknown_language): Add value for new field.
        (auto_language): Likewise.
        (local_language): Likewise.
        * ada-lang.c (ada_print_array_index): New function.
        (ada_language_defn): Add value for new field.
        * c-lang.c (c_language_defn): Likewise.
        (cpluc_language_defn): Likewise.
        (asm_language_defn): Likewise.
        (minimal_language_defn): Likewise.
        * f-lang.c (f_language_defn): Likewise.
        * jv-lang.c (java_language_defn): Likewise.
        * m2-lang.c (m2_language_defn): Likewise.
        * objc-lang.c (objc_language_defn): Likewise.
        * p-lang.c (pascal_language_defn): Likewise.
        * scm-lang.c (scm_language_defn): Likewise.
        * valprint.h (print_array_indexes_p): Add declaration.
        (get_array_low_bound): Add declaration.
        (maybe_print_array_index): Add declaration.
        * valprint.c (print_array_indexes): New static variable.
        (show_print_array_indexes): New function.
        (print_array_indexes_p): New function.
        (get_array_low_bound): New function.
        (maybe_print_array_index): New function.
        (val_print_array_elements): Print the index of each element if
        requested by the user.
        (_initialize_valprint): Add new array-indexes "set/show print" command.
        * ada-valprint.c (print_optional_low_bound): Replace extracted code
        by call to ada_get_array_low_bound_and_type(). Stop printing the low
        bound if indexes will be printed for all elements of the array.
        (val_print_packed_array_elements): Print the index of each element
        of the array if necessary.
@
text
@d1 1
a1 1
/* Ada language support routines for GDB, the GNU debugger.  Copyright
d20 2
a21 1
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
@


1.78
log
@2005-05-09  Andrew Cagney  <cagney@@gnu.org>

	Use gdb_byte in preference to bfd_byte.
	* gdbarch.sh: Update.
	* gdbarch.h, gdbarch.c: Re-generate.
	* ada-lang.c, ada-lang.h, ada-valprint.c, arch-utils.c: Update.
	* c-lang.c, c-lang.h, c-valprint.c, cp-valprint.c: Update.
	* f-lang.c, f-lang.h, f-valprint.c, gdbcore.h, jv-lang.h: Update.
	* jv-valprint.c, language.c, language.h, m2-lang.c: Update.
	* m2-lang.h, m2-valprint.c, objc-lang.c, p-lang.c: Update.
	* p-lang.h, p-valprint.c, regcache.c, scm-lang.c: Update.
	* scm-lang.h, scm-valprint.c, target.c, target.h: Update.
	* tramp-frame.c, valarith.c, valops.c, valprint.c: Update.
	* valprint.h, value.c, value.h: Update.
@
text
@d306 10
d8779 1
@


1.77
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d166 1
a166 1
						  const bfd_byte *,
d418 1
a418 1
				 const bfd_byte *valaddr,
d464 2
a465 2
static const bfd_byte *
cond_offset_host (const bfd_byte *valaddr, long offset)
d1786 1
a1786 1
ada_value_primitive_packed_val (struct value *obj, const bfd_byte *valaddr,
d1938 1
a1938 1
move_bits (bfd_byte *target, int targ_offset, const bfd_byte *source,
d5003 1
a5003 1
				     const bfd_byte *valaddr,
d5011 1
a5011 1
      const bfd_byte *valaddr1 = ((valaddr == NULL)
d5709 1
a5709 1
                           const bfd_byte *outer_valaddr)
d6060 1
a6060 1
				     const bfd_byte *valaddr,
d6220 1
a6220 1
template_to_fixed_record_type (struct type *type, const bfd_byte *valaddr,
d6287 1
a6287 1
to_record_with_fixed_variant_part (struct type *type, const bfd_byte *valaddr,
d6365 1
a6365 1
to_fixed_record_type (struct type *type0, const bfd_byte *valaddr,
d6400 1
a6400 1
to_fixed_variant_branch_type (struct type *var_type0, const bfd_byte *valaddr,
d6506 1
a6506 1
ada_to_fixed_type (struct type *type, const bfd_byte *valaddr,
d6858 2
a6859 2
const bfd_byte *
ada_aligned_value_addr (struct type *type, const bfd_byte *valaddr)
@


1.76
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d3094 1
a3094 1
              printf_unfiltered ("[%d] ", i + first_choice);
d3154 1
a3154 1
  printf_unfiltered ("%s ", prompt);
@


1.75
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.c (set_value_bitpos, set_value_bitsize): Define.
	* value.h (set_value_bitpos, set_value_bitsize): Declare.
	* ada-lang.c, valarith.c: Update.
@
text
@d8092 1
a8092 1
        error ("%s", err_msg);
@


1.74
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (deprecated_set_value_modifiable)
	(deprecated_value_modifiable): Declare.
	* value.c (deprecated_set_value_modifiable): Define.
	(deprecated_value_modifiable): Define.
	* ada-lang.c, valops.c, breakpoint.c, tracepoint.c: Update.
@
text
@d451 2
a452 2
      result->bitsize = value_bitsize (val);
      result->bitpos = value_bitpos (val);
d1833 2
a1834 2
      v->bitpos = bit_offset + value_bitpos (obj);
      v->bitsize = bit_size;
d1838 1
a1838 1
          v->bitpos -= HOST_CHAR_BIT;
d1842 1
a1842 1
    v->bitsize = bit_size;
@


1.73
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (deprecated_set_value_type): Declare.
	* value.c (deprecated_set_value_type): Define.
	* hpacc-abi.c, gnu-v2-abi.c, cp-valprint.c: Update.
	* c-valprint.c, jv-lang.c, objc-lang.c, ada-lang.c: Update.
	* infcall.c, printcmd.c, valops.c, eval.c, p-exp.y: Update.
	* ax-gdb.c, tracepoint.c: Update.
@
text
@d2011 1
a2011 1
  if (!toval->modifiable)
@


1.72
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_LAZY): Delete
	(set_value_lazy): Declare.
	* value.c (set_value_lazy): Define.
	* valops.c, valarith.c, jv-valprint.c, jv-lang.c: Update.
	* gnu-v2-abi.c, findvar.c, dwarf2loc.c, ada-lang.c: Update.
@
text
@d1550 1
a1550 1
  dummy->type = type;
d2044 1
a2044 1
      val->type = type;
d7050 1
a7050 1
      val->type = type;
@


1.71
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d423 1
a423 1
    VALUE_LAZY (v) = 1;
d456 1
a456 1
        VALUE_LAZY (result) = 1;
@


1.70
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.h (value_lazy): Declare.
	* varobj.c, value.c, valops.c, valarith.c, printcmd.c: Update.
	* cp-valprint.c, breakpoint.c, ada-lang.c: Update.
@
text
@d458 1
a458 1
        memcpy (value_contents_raw (result), VALUE_CONTENTS (val),
d1824 1
a1824 1
      bytes = (unsigned char *) VALUE_CONTENTS (obj) + offset;
d1843 1
a1843 1
  unpacked = (unsigned char *) VALUE_CONTENTS (v);
d1938 2
a1939 1
move_bits (char *target, int targ_offset, char *source, int src_offset, int n)
d2032 1
a2032 1
                   VALUE_CONTENTS (fromval),
d2036 1
a2036 1
        move_bits (buffer, value_bitpos (toval), VALUE_CONTENTS (fromval),
d2042 1
a2042 1
      memcpy (value_contents_raw (val), VALUE_CONTENTS (fromval),
d3547 1
a3547 1
                      (char *) VALUE_CONTENTS (actual),
d3578 1
a3578 1
      modify_general_field (VALUE_CONTENTS (bounds),
d3582 1
a3582 1
      modify_general_field (VALUE_CONTENTS (bounds),
d3590 1
a3590 1
  modify_general_field (VALUE_CONTENTS (descriptor),
d3595 1
a3595 1
  modify_general_field (VALUE_CONTENTS (descriptor),
d5331 1
a5331 1
      return ada_value_primitive_packed_val (arg1, VALUE_CONTENTS (arg1),
d5539 1
a5539 1
        address = unpack_pointer (t, VALUE_CONTENTS (arg));
d6419 1
a6419 1
                               value_type (dval), VALUE_CONTENTS (dval));
d7128 1
a7128 1
        && memcmp (VALUE_CONTENTS (arg1), VALUE_CONTENTS (arg2),
@


1.69
log
@2005-02-01  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents_all_raw)
	(value_contents_raw): New functions.
	* value.h (VALUE_CONTENTS_ALL_RAW, VALUE_CONTENTS_RAW): Delete.
	(value_contents_raw, value_contents_all_raw): Declare functions.
	(VALUE_CONTENTS, VALUE_CONTENTS_ALL): Update.
	* std-regs.c, valarith.c, valops.c, eval.c: Update.
	* tracepoint.c, findvar.c: Update.
@
text
@d454 1
a454 1
      if (VALUE_LAZY (val)
d1814 1
a1814 1
  else if (VALUE_LAZY (obj))
@


1.68
log
@2005-01-28  Andrew Cagney  <cagney@@gnu.org>

	* language.h (struct language_defn): Make la_val_print's buffer
	parameter a const bfd_byte.
	* cp-valprint.c (cp_print_value_fields, cp_print_value): Update.
	* ada-lang.c (ada_aligned_value_addr)
	(ada_value_primitive_packed_val, ada_which_variant_applies): Update.
	* valprint.c (val_print_array_elements): Update.
	* valprint.h (val_print_array_elements): Update.
	* ada-lang.h (ada_val_print, ada_aligned_value_addr)
	(ada_value_primitive_packed_val, ada_which_variant_applies): Update.
	* ada-valprint.c (ada_val_print, struct ada_val_print_args)
	(ada_val_print_1, ada_print_floating, printable_val_type)
	(print_record, val_print_packed_array_elements)
	(print_field_values, print_variant_part): Update.
	* c-lang.h (c_val_print, cp_print_value_fields): Update.
	* c-valprint.c (c_val_print): Update.
	* f-lang.h (f_val_print): Update.
	* f-valprint.c (f_val_print, f77_print_array_1)
	(f77_print_array): Update.
	* jv-lang.h (java_val_print): Update.
	* jv-valprint.c (java_print_value_fields, java_val_print): Update.
	* language.c (unk_lang_val_print): Update.
	* m2-lang.h (m2_val_print): Update.
	* m2-valprint.c (m2_val_print): Update.
	* p-lang.h (pascal_val_print): Update.
	(pascal_object_print_value_fields): Update.
	* p-valprint.c (pascal_val_print)
	(pascal_object_print_value_fields, pascal_object_print_value)
	(pascal_object_print_value): Update.
	* scm-lang.h (scm_val_print): Update.
	* scm-valprint.c (scm_val_print): Update.
	* value.h (val_print): Update.
@
text
@d425 1
a425 1
    memcpy (VALUE_CONTENTS_RAW (v), valaddr, TYPE_LENGTH (type));
d458 1
a458 1
        memcpy (VALUE_CONTENTS_RAW (result), VALUE_CONTENTS (val),
d2041 1
a2041 1
      memcpy (VALUE_CONTENTS_RAW (val), VALUE_CONTENTS (fromval),
d3506 1
a3506 1
      write_memory (VALUE_ADDRESS (val), VALUE_CONTENTS_RAW (val), len);
d3545 1
a3545 1
              memcpy ((char *) VALUE_CONTENTS_RAW (val),
d7106 1
a7106 1
  store_unsigned_integer (VALUE_CONTENTS_RAW (val),
@


1.67
log
@2005-01-28  Andrew Cagney  <cagney@@gnu.org>

	* ada-lang.c (value_from_contents_and_address)
	(to_record_with_fixed_variant_part)
	(value_tag_from_contents_and_address, ada_to_fixed_type)
	(to_fixed_variant_branch_type, to_fixed_record_type)
	(ada_template_to_fixed_record_type, cond_offset_host)
	(ada_template_to_fixed_record_type_1): Make buffer a const
	bfd_byte.
	* ada-lang.h (ada_template_to_fixed_record_type_1)
	(value_from_contents_and_address, ada_to_fixed_type): Ditto.
@
text
@d1786 2
a1787 2
ada_value_primitive_packed_val (struct value *obj, char *valaddr, long offset,
                                int bit_offset, int bit_size,
d5708 1
a5708 1
                           char *outer_valaddr)
d6857 2
a6858 2
char *
ada_aligned_value_addr (struct type *type, char *valaddr)
@


1.66
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d2 3
a4 2
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004.
   Free Software Foundation, Inc.
d165 2
a166 1
static struct type *to_fixed_variant_branch_type (struct type *, char *,
d417 2
a418 1
value_from_contents_and_address (struct type *type, char *valaddr,
d464 2
a465 2
static char *
cond_offset_host (char *valaddr, long offset)
d5001 2
a5002 1
value_tag_from_contents_and_address (struct type *type, char *valaddr,
d5010 3
a5012 1
      char *valaddr1 = (valaddr == NULL) ? NULL : valaddr + tag_byte_offset;
d6058 2
a6059 1
ada_template_to_fixed_record_type_1 (struct type *type, char *valaddr,
d6219 1
a6219 1
template_to_fixed_record_type (struct type *type, char *valaddr,
d6286 1
a6286 1
to_record_with_fixed_variant_part (struct type *type, char *valaddr,
d6364 1
a6364 1
to_fixed_record_type (struct type *type0, char *valaddr,
d6399 1
a6399 1
to_fixed_variant_branch_type (struct type *var_type0, char *valaddr,
d6505 1
a6505 1
ada_to_fixed_type (struct type *type, char *valaddr,
@


1.65
log
@* ada-lang.c (ada_print_subexp): Remove i18n markup from Ada code
output.
* ada-typeprint.c (ada_typedef_print): Ditto.
(print_unchecked_union_type): Ditto.
(print_record_type): Ditto, and correct output for non-derived
types that was inadvertently left off during the markup.
@
text
@d53 1
@


1.64
log
@2004-11-27  Baurjan Ismagulov  <ibr@@ata.cs.hun.edu.tr>

	Committed by Andrw Cagney.
	* abug-rom.c, ada-lang.c, ada-typeprint.c, alpha-tdep.c: i18n
	markup.
@
text
@d8387 1
a8387 1
      fputs_filtered (_(" in "), stream);
d8389 1
a8389 1
      fputs_filtered (_("'range"), stream);
d8401 1
a8401 1
      fputs_filtered (_(" in "), stream);
d8454 1
a8454 1
      fputs_filtered (_(" in "), stream);
@


1.63
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d372 1
a372 1
    error ("Unable to find field %s in struct %s.  Aborting",
d508 1
a508 1
    error ("object size is larger than varsize-limit");
d576 1
a576 1
      error ("Unexpected type in discrete_type_high_bound.");
d594 1
a594 1
      error ("Unexpected type in discrete_type_low_bound.");
d654 1
a654 1
        error ("Invalid address for Ada main program name.");
d765 1
a765 1
            error ("invalid Ada operator name: %s", p);
d1211 1
a1211 1
        error ("Bad GNAT array descriptor");
d1228 1
a1228 1
                             "Bad GNAT array descriptor");
d1287 1
a1287 1
                             "Bad GNAT array descriptor");
d1324 1
a1324 1
                           "Bad GNAT array descriptor bounds");
d1527 1
a1527 1
        error ("Bounds unavailable for null array pointer.");
d1631 1
a1631 1
      lim_warning ("could not find bounds information on packed array");
d1638 1
a1638 1
      lim_warning ("could not understand bounds information on packed array");
d1645 1
a1645 1
	("could not understand bit size information on packed array");
d1670 1
a1670 1
      error ("can't unpack array");
d1722 1
a1722 1
          ("attempt to do packed indexing of something other than a packed array");
d1731 1
a1731 1
              lim_warning ("don't know bounds of array");
d1737 1
a1737 1
            lim_warning ("packed array index %ld out of bounds", (long) idx);
d2007 1
a2007 1
    error ("Left operand of assignment is not a modifiable lvalue.");
d2069 1
a2069 1
        error ("too many subscripts (%d expected)", k);
d2091 1
a2091 1
        error ("too many subscripts (%d expected)", k);
d2389 1
a2389 1
  error ("Could not find operator name for opcode");
d2582 1
a2582 1
      error ("Unexpected operator during name resolution");
d2651 1
a2651 1
            error ("No definition found for %s",
d2663 1
a2663 1
                error ("Could not find a match for %s",
d2668 1
a2668 1
              printf_filtered ("Multiple matches for %s\n",
d2715 1
a2715 1
                  error ("Could not find a match for %s",
d2959 1
a2959 1
      printf_filtered ("Multiple matches for %s\n", name);
d3043 1
a3043 1
    error ("Request to select 0 symbols!");
d3047 1
a3047 1
  printf_unfiltered ("[0] cancel\n");
d3049 1
a3049 1
    printf_unfiltered ("[1] all\n");
d3062 9
a3070 5
          printf_unfiltered ("[%d] %s at %s:%d\n", i + first_choice,
                             SYMBOL_PRINT_NAME (syms[i].sym),
                             (sal.symtab == NULL
                              ? "<no source file available>"
                              : sal.symtab->filename), sal.line);
d3082 1
a3082 1
            printf_unfiltered ("[%d] %s at %s:%d\n",
d3092 1
a3092 1
              printf_unfiltered ("'(%s) (enumeral)\n",
d3097 2
a3098 2
                               ? "[%d] %s in %s (enumeral)\n"
                               : "[%d] %s at %s:?\n",
d3104 2
a3105 2
                               ? "[%d] %s (enumeral)\n"
                               : "[%d] %s at ?\n",
d3155 1
a3155 1
    error_no_arg ("one or more choice numbers");
d3169 1
a3169 1
        error_no_arg ("one or more choice numbers");
d3176 1
a3176 1
        error ("Argument must be choice number");
d3180 1
a3180 1
        error ("cancelled");
d3206 1
a3206 1
    error ("Select no more than %d of the above", max_results);
d3450 1
a3450 1
    error ("Improperly encoded renaming.");
d3455 1
a3455 1
    error ("Improperly encoded renaming.");
d5481 1
a5481 1
            error ("Bad value type in a %s.", err);
d5499 1
a5499 1
            error ("Bad value type in a %s.", err);
d5516 1
a5516 1
        error ("Attempt to extract a component of a value that is not a %s.",
d5555 1
a5555 1
    error ("There is no member named %s.", name);
d5606 9
a5614 6
          fprintf_unfiltered (gdb_stderr, "Type ");
          if (type == NULL)
            fprintf_unfiltered (gdb_stderr, "(null)");
          else
            type_print (type, "", gdb_stderr, -1);
          error (" is not a structure or union type");
d5675 14
a5688 4
      fprintf_unfiltered (gdb_stderr, "Type ");
      type_print (type, "", gdb_stderr, -1);
      fprintf_unfiltered (gdb_stderr, " has no component named ");
      error ("%s", name == NULL ? "<null>" : name);
d6188 6
a6193 3
      warning ("Invalid type size for `%s' detected: %d.",
               TYPE_NAME (rtype) ? TYPE_NAME (rtype) : "<unnamed>",
               TYPE_LENGTH (type));
d6203 1
a6203 1
    error ("record type with dynamic size is larger than varsize-limit");
d6482 1
a6482 1
        error ("array type with dynamic size is larger than varsize-limit");
d6702 1
a6702 1
    error ("'POS only defined on discrete types");
d6714 1
a6714 1
      error ("enumeration value is invalid: can't find 'POS");
d6732 1
a6732 1
    error ("'VAL only defined on discrete types");
d6734 1
a6734 1
    error ("'VAL requires integral argument");
d6740 1
a6740 1
        error ("argument to 'VAL out of range");
d7040 1
a7040 1
        error ("Incompatible types in assignment");
d7074 1
a7074 1
    error ("second operand of %s must not be zero.", op_string (op));
d7113 1
a7113 1
        error ("Attempt to compare array with non-array");
d7205 1
a7205 1
          ("Fixed-point values must be assigned to fixed-point variables");
d7218 1
a7218 1
        error ("Operands of fixed-point addition must have the same type");
d7229 1
a7229 1
        error ("Operands of fixed-point subtraction must have the same type");
d7296 1
a7296 1
        error ("Unexpected unresolved symbol, %s, during evaluation",
d7325 1
a7325 1
        error ("Unexpected unresolved symbol, %s, during evaluation",
d7360 1
a7360 1
              error ("cannot subscript or call something of type `%s'",
d7379 1
a7379 1
              error ("cannot subscript or call a record");
d7381 1
a7381 1
              error ("wrong number of subscripts; expecting %d", arity);
d7393 1
a7393 1
                error ("element type of array unknown");
d7407 1
a7407 1
                error ("element type of array unknown");
d7416 2
a7417 2
          error ("Attempt to index or call something other than an "
		 "array or function");
d7445 1
a7445 1
          error ("cannot slice a packed array");
d7473 1
a7473 1
          error ("cannot take slice of non-array");
d7509 2
a7510 2
          lim_warning ("Membership test incompletely implemented; "
                       "always returns true");
d7539 1
a7539 1
        error ("invalid dimension number to '%s", "range");
d7584 1
a7584 1
          error ("illegal operand to '%s", ada_attribute_name (op));
d7599 1
a7599 1
              error ("invalid dimension number to '%s",
d7607 1
a7607 1
                    ("attempt to take bound of something that is not an array");
d7614 1
a7614 1
                error ("unexpected attribute encountered");
d7636 1
a7636 1
                error ("unexpected attribute encountered");
d7642 1
a7642 1
                error ("the 'length attribute applies only to array types");
d7646 1
a7646 1
          error ("unimplemented type attribute");
d7655 1
a7655 1
              error ("invalid dimension number to '%s",
d7661 1
a7661 1
                ("attempt to take bound of something that is not an array");
d7668 1
a7668 1
                error ("unexpected attribute encountered");
d7715 1
a7715 1
          error ("'modulus must be applied to modular type");
d7794 1
a7794 1
                error ("Attempt to dereference null array pointer.");
d7812 1
a7812 1
            error ("Attempt to take contents of a non-pointer value.");
d7865 1
a7865 1
        error ("Attempt to use a type name as an expression");
d8014 1
a8014 1
      error ("invalid VAX floating-point type");
d8174 1
a8174 1
              lim_warning ("Unknown lower bound, using 1.");
d8192 1
a8192 1
              lim_warning ("Unknown upper bound, using %ld.", (long) L);
d8336 2
a8337 1
      fprintf_filtered (stream, "Type @@");
d8384 1
d8387 1
a8387 1
      fputs_filtered (" in ", stream);
d8389 1
a8389 1
      fputs_filtered ("'range", stream);
d8399 1
d8401 1
a8401 1
      fputs_filtered (" in ", stream);
d8452 1
d8454 1
a8454 1
      fputs_filtered (" in ", stream);
d8538 1
a8538 1
      warning ("internal error: no Ada fundamental type %d", typeid);
@


1.62
log
@2004-11-10  Andrew Cagney  <cagney@@gnu.org>

	* value.h (COERCE_REF, COERCE_ARRAY, COERCE_NUMBER, COERCE_ENUM)
	(coerce_ref, coerce_array, coerce_number, coerce_enum): Replace
	macros with function declarations.
	* value.c (coerce_ref, coerce_array, coerce_number)
	(coerce_enum): New functions.
	(value_as_long, value_as_address): Update.
	* ada-lang.c (ada_coerce_ref, ada_value_binop)
	(ada_evaluate_subexp, ada_value_assign, ada_value_struct_elt): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* valarith.c (value_less, value_neg, value_complement)
	(value_binop, value_add, value_subscript, value_x_binop)
	(value_logical_not, value_sub): Update.
	* valops.c (check_field, value_struct_elt, value_ind)
	(value_find_oload_method_list, value_cast, value_assign): Update.
	* eval.c (evaluate_subexp_standard): Update.
@
text
@d435 1
a435 1
  if (VALUE_TYPE (val) == type)
d447 3
a449 3
      VALUE_BITSIZE (result) = VALUE_BITSIZE (val);
      VALUE_BITPOS (result) = VALUE_BITPOS (val);
      VALUE_ADDRESS (result) = VALUE_ADDRESS (val) + VALUE_OFFSET (val);
d451 1
a451 1
          || TYPE_LENGTH (type) > TYPE_LENGTH (VALUE_TYPE (val)))
d1148 1
a1148 1
  struct type *type = VALUE_TYPE (val);
d1154 1
a1154 1
                               VALUE_ADDRESS (val) + VALUE_OFFSET (val));
d1203 1
a1203 1
  struct type *type = ada_check_typedef (VALUE_TYPE (arr));
d1219 1
a1219 1
        addr = VALUE_ADDRESS (arr) + VALUE_OFFSET (arr);
d1282 1
a1282 1
  struct type *type = VALUE_TYPE (arr);
d1452 2
a1453 2
  if (ada_is_packed_array_type (VALUE_TYPE (arr)))
    return decode_packed_array_type (VALUE_TYPE (arr));
d1455 2
a1456 2
  if (!ada_is_array_descriptor_type (VALUE_TYPE (arr)))
    return VALUE_TYPE (arr);
d1460 1
a1460 1
      ada_check_typedef (TYPE_TARGET_TYPE (desc_data_type (VALUE_TYPE (arr))));
d1466 1
a1466 1
      struct objfile *objf = TYPE_OBJFILE (VALUE_TYPE (arr));
d1468 2
a1469 2
      elt_type = ada_array_element_type (VALUE_TYPE (arr), -1);
      arity = ada_array_arity (VALUE_TYPE (arr));
d1472 1
a1472 1
        return ada_check_typedef (VALUE_TYPE (arr));
d1485 1
a1485 1
          create_range_type (range_type, VALUE_TYPE (low),
d1503 1
a1503 1
  if (ada_is_array_descriptor_type (VALUE_TYPE (arr)))
d1510 1
a1510 1
  else if (ada_is_packed_array_type (VALUE_TYPE (arr)))
d1523 1
a1523 1
  if (ada_is_array_descriptor_type (VALUE_TYPE (arr)))
d1530 1
a1530 1
  else if (ada_is_packed_array_type (VALUE_TYPE (arr)))
d1546 1
a1546 1
  VALUE_TYPE (dummy) = type;
d1664 1
a1664 1
  if (TYPE_CODE (VALUE_TYPE (arr)) == TYPE_CODE_PTR)
d1667 1
a1667 1
  type = decode_packed_array_type (VALUE_TYPE (arr));
d1674 1
a1674 1
  if (BITS_BIG_ENDIAN && ada_is_modular_type (VALUE_TYPE (arr)))
d1683 1
a1683 1
      mod = ada_modulus (VALUE_TYPE (arr)) - 1;
d1690 1
a1690 1
      bit_pos = HOST_CHAR_BIT * TYPE_LENGTH (VALUE_TYPE (arr)) - bit_size;
d1716 1
a1716 1
  elt_type = ada_check_typedef (VALUE_TYPE (arr));
d1813 1
a1813 1
                    VALUE_ADDRESS (obj) + VALUE_OFFSET (obj) + offset);
d1828 4
a1831 4
      VALUE_ADDRESS (v) = VALUE_ADDRESS (obj) + VALUE_OFFSET (obj) + offset;
      VALUE_BITPOS (v) = bit_offset + VALUE_BITPOS (obj);
      VALUE_BITSIZE (v) = bit_size;
      if (VALUE_BITPOS (v) >= HOST_CHAR_BIT)
d1834 1
a1834 1
          VALUE_BITPOS (v) -= HOST_CHAR_BIT;
d1838 1
a1838 1
    VALUE_BITSIZE (v) = bit_size;
d2003 2
a2004 2
  struct type *type = VALUE_TYPE (toval);
  int bits = VALUE_BITSIZE (toval);
d2016 2
a2017 2
      int len =
        (VALUE_BITPOS (toval) + bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;
d2024 1
a2024 1
      read_memory (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval), buffer, len);
d2026 1
a2026 1
        move_bits (buffer, VALUE_BITPOS (toval),
d2028 1
a2028 1
                   TYPE_LENGTH (VALUE_TYPE (fromval)) * TARGET_CHAR_BIT -
d2031 1
a2031 1
        move_bits (buffer, VALUE_BITPOS (toval), VALUE_CONTENTS (fromval),
d2033 1
a2033 1
      write_memory (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval), buffer,
d2039 1
a2039 1
      VALUE_TYPE (val) = type;
d2061 1
a2061 1
  elt_type = ada_check_typedef (VALUE_TYPE (elt));
d2128 1
a2128 1
  struct type *type = VALUE_TYPE (array);
d2315 1
a2315 1
  struct type *arr_type = VALUE_TYPE (arr);
d2338 1
a2338 1
  struct type *arr_type = ada_check_typedef (VALUE_TYPE (arr));
d2493 1
a2493 1
          resolve_subexp (expp, pos, 1, VALUE_TYPE (arg1));
d2867 1
a2867 1
          struct type *atype = ada_check_typedef (VALUE_TYPE (actuals[i]));
d3339 1
a3339 1
    (args[0] == NULL) ? NULL : ada_check_typedef (VALUE_TYPE (args[0]));
d3341 1
a3341 1
    (args[1] == NULL) ? NULL : ada_check_typedef (VALUE_TYPE (args[1]));
d3472 1
a3472 1
      int len = TYPE_LENGTH (ada_check_typedef (VALUE_TYPE (val)));
d3513 1
a3513 1
  struct type *actual_type = ada_check_typedef (VALUE_TYPE (actual));
d3535 1
a3535 1
              actual_type = ada_check_typedef (VALUE_TYPE (actual));
d3567 1
a3567 1
  for (i = ada_array_arity (ada_check_typedef (VALUE_TYPE (arr))); i > 0; i -= 1)
d3614 2
a3615 2
  if (TYPE_NFIELDS (VALUE_TYPE (func)) == 0
      || nargs != TYPE_NFIELDS (VALUE_TYPE (func)))
d3620 1
a3620 1
      convert_actual (args[i], TYPE_FIELD_TYPE (VALUE_TYPE (func), i), sp);
d4977 1
a4977 1
  return ada_lookup_struct_elt_type (VALUE_TYPE (val), "_tag", 1, 0, NULL);
d5058 1
a5058 1
  if (!ada_is_tag_type (VALUE_TYPE (tag)))
d5468 1
a5468 1
  t1 = t = ada_check_typedef (VALUE_TYPE (arg));
d5766 1
a5766 1
  if (TYPE_CODE (VALUE_TYPE (val0)) == TYPE_CODE_REF)
d6020 1
a6020 1
   necessary discriminants.  It should be NULL if VALUE_TYPE (VAL) is
d6390 1
a6390 1
                               VALUE_TYPE (dval), VALUE_CONTENTS (dval));
d6621 2
a6622 2
  return ada_to_fixed_value_create (VALUE_TYPE (val),
                                    VALUE_ADDRESS (val) + VALUE_OFFSET (val),
d6635 2
a6636 2
    to_static_fixed_type (static_unwrap_type (VALUE_TYPE (val)));
  if (type == VALUE_TYPE (val))
d6679 1
a6679 1
  struct type *type = VALUE_TYPE (arg);
d6713 1
a6713 1
  if (!integer_type_p (VALUE_TYPE (arg)))
d6938 1
a6938 1
  struct type *type = ada_check_typedef (VALUE_TYPE (val));
d6943 1
a6943 1
      struct type *val_type = ada_check_typedef (VALUE_TYPE (v));
d6960 1
a6960 1
                                 VALUE_ADDRESS (val) + VALUE_OFFSET (val),
d6970 1
a6970 1
  if (type == VALUE_TYPE (arg))
d6972 1
a6972 1
  else if (ada_is_fixed_point_type (VALUE_TYPE (arg)))
d6974 1
a6974 1
                              ada_fixed_to_float (VALUE_TYPE (arg),
d6989 1
a6989 1
  DOUBLEST val = ada_fixed_to_float (VALUE_TYPE (arg),
d7000 1
a7000 1
  struct type *type2 = VALUE_TYPE (val);
d7011 1
a7011 1
      type2 = VALUE_TYPE (val);
d7021 1
a7021 1
      VALUE_TYPE (val) = type;
d7035 2
a7036 2
  type1 = base_type (ada_check_typedef (VALUE_TYPE (arg1)));
  type2 = base_type (ada_check_typedef (VALUE_TYPE (arg2)));
d7079 1
a7079 1
                          TYPE_LENGTH (VALUE_TYPE (val)), v);
d7086 2
a7087 2
  if (ada_is_direct_array_type (VALUE_TYPE (arg1))
      || ada_is_direct_array_type (VALUE_TYPE (arg2)))
d7091 2
a7092 2
      if (TYPE_CODE (VALUE_TYPE (arg1)) != TYPE_CODE_ARRAY
          || TYPE_CODE (VALUE_TYPE (arg2)) != TYPE_CODE_ARRAY)
d7098 1
a7098 1
        TYPE_LENGTH (VALUE_TYPE (arg1)) == TYPE_LENGTH (VALUE_TYPE (arg2))
d7100 1
a7100 1
                   TYPE_LENGTH (VALUE_TYPE (arg1))) == 0;
d7136 2
a7137 2
        if (TYPE_CODE (VALUE_TYPE (result)) == TYPE_CODE_STRING)
          TYPE_CODE (VALUE_TYPE (result)) = TYPE_CODE_ARRAY;
d7147 1
a7147 1
      if (type != ada_check_typedef (VALUE_TYPE (arg1)))
d7151 1
a7151 1
          else if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
d7164 1
a7164 1
                (type, VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1), 0);
d7178 1
a7178 1
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
d7181 3
a7183 3
      if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
        arg2 = cast_to_fixed (VALUE_TYPE (arg1), arg2);
      else if (ada_is_fixed_point_type (VALUE_TYPE (arg2)))
d7187 1
a7187 1
        arg2 = coerce_for_assign (VALUE_TYPE (arg1), arg2);
d7195 3
a7197 3
      if ((ada_is_fixed_point_type (VALUE_TYPE (arg1))
           || ada_is_fixed_point_type (VALUE_TYPE (arg2)))
          && VALUE_TYPE (arg1) != VALUE_TYPE (arg2))
d7199 1
a7199 1
      return value_cast (VALUE_TYPE (arg1), value_add (arg1, arg2));
d7206 3
a7208 3
      if ((ada_is_fixed_point_type (VALUE_TYPE (arg1))
           || ada_is_fixed_point_type (VALUE_TYPE (arg2)))
          && VALUE_TYPE (arg1) != VALUE_TYPE (arg2))
d7210 1
a7210 1
      return value_cast (VALUE_TYPE (arg1), value_sub (arg1, arg2));
d7220 1
a7220 1
        return value_zero (VALUE_TYPE (arg1), not_lval);
d7223 1
a7223 1
          if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
d7225 1
a7225 1
          if (ada_is_fixed_point_type (VALUE_TYPE (arg2)))
d7238 1
a7238 1
        return value_zero (VALUE_TYPE (arg1), not_lval);
d7245 1
a7245 1
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
d7260 2
a7261 2
      else if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
        return value_cast (VALUE_TYPE (arg1), value_neg (arg1));
d7317 1
a7317 1
      if (ada_is_packed_array_type (desc_base_type (VALUE_TYPE (argvec[0]))))
d7319 2
a7320 2
      else if (TYPE_CODE (VALUE_TYPE (argvec[0])) == TYPE_CODE_REF
               || (TYPE_CODE (VALUE_TYPE (argvec[0])) == TYPE_CODE_ARRAY
d7324 1
a7324 1
      type = ada_check_typedef (VALUE_TYPE (argvec[0]));
d7341 1
a7341 1
                     ada_type_name (VALUE_TYPE (argvec[0])));
d7419 4
a7422 4
        if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_REF
            && ada_is_aligner_type (TYPE_TARGET_TYPE (VALUE_TYPE (array))))
          TYPE_TARGET_TYPE (VALUE_TYPE (array)) =
            ada_aligned_type (TYPE_TARGET_TYPE (VALUE_TYPE (array)));
d7424 1
a7424 1
        if (ada_is_packed_array_type (VALUE_TYPE (array)))
d7429 2
a7430 2
        if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_REF
            || (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_ARRAY
d7436 1
a7436 1
                                             (VALUE_TYPE (array))))
d7443 2
a7444 2
        while (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_PTR
               && (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (array)))
d7452 1
a7452 1
        if (!ada_is_simple_array_type (VALUE_TYPE (array)))
d7455 1
a7455 1
        if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_PTR)
d7458 1
a7458 1
              return empty_array (TYPE_TARGET_TYPE (VALUE_TYPE (array)),
d7463 1
a7463 1
                  to_fixed_array_type (TYPE_TARGET_TYPE (VALUE_TYPE (array)),
d7473 1
a7473 1
          return empty_array (VALUE_TYPE (array), low_bound);
d7518 1
a7518 1
      if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg2)))
d7575 1
a7575 1
            if (ada_is_packed_array_type (VALUE_TYPE (arg1)))
d7578 1
a7578 1
            if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg1)))
d7584 1
a7584 1
                type = ada_index_type (VALUE_TYPE (arg1), tem);
d7681 1
a7681 1
        return value_zero (VALUE_TYPE (arg1), not_lval);
d7721 1
a7721 1
                                   * TYPE_LENGTH (VALUE_TYPE (arg1)));
d7740 1
a7740 1
        return value_zero (VALUE_TYPE (arg1), not_lval);
d7755 1
a7755 1
      if (value_less (arg1, value_zero (VALUE_TYPE (arg1), not_lval)))
d7766 1
a7766 1
      type = ada_check_typedef (VALUE_TYPE (arg1));
d7795 1
a7795 1
      type = ada_check_typedef (VALUE_TYPE (arg1));
d7811 1
a7811 1
          struct type *type1 = VALUE_TYPE (arg1);
d8035 1
a8035 1
  bound_val = ada_search_struct_field (bound, dval, 0, VALUE_TYPE (dval));
@


1.61
log
@2004-11-09  Andrew Cagney  <cagney@@gnu.org>

	* value.h (struct value): Delete field bfd_section.
	(VALUE_BFD_SECTION): Delete macro.
	(COERCE_REF): Update.
	(value_at, value_at_lazy): Delete asection parameter.
	* printcmd.c (print_formatted, x_command): Update.
	(do_examine): Delete asection parameter.
	(next_section): Delete variable.
	* valops.c (value_cast, value_at, value_at_lazy)
	(value_coerce_function, value_addr, value_ind, value_string)
	(find_rt_vbase_offset, value_full_object): Update.
	* hpacc-abi.c (hpacc_virtual_fn_field)
	(hpacc_value_rtti_type): Update.
	* gnu-v3-abi.c (gnuv3_rtti_type, gnuv3_virtual_fn_field)
	(gnuv3_baseclass_offset): Update.
	* f-valprint.c (f_val_print): Update.
	* c-valprint.c (c_val_print): Update.
	* p-valprint.c (pascal_val_print): Update.
	* jv-valprint.c (java_value_print): Update.
	* jv-lang.c (java_class_from_object, evaluate_subexp_java): Update.
	* ada-lang.c (ada_value_primitive_packed_val)
	(ada_evaluate_subexp): Update.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Update.
	* expprint.c (print_subexp_standard): Update.
	* infcall.c (call_function_by_hand): Update.
	* valarith.c (value_add): Update.
	* eval.c (evaluate_subexp_standard): Update.
	* values.c (allocate_value, value_copy, value_static_field): Update.
	* findvar.c (read_var_value, locate_var_value): Update.
@
text
@d2009 1
a2009 1
  COERCE_REF (toval);
d5482 1
a5482 1
          COERCE_REF (arg);
d5769 1
a5769 1
      COERCE_REF (val);
d7033 2
a7034 2
  COERCE_REF (arg1);
  COERCE_REF (arg2);
d7409 2
a7410 2
        COERCE_REF (low_bound_val);
        COERCE_REF (high_bound_val);
@


1.60
log
@	* ada-lang.c (grow_vect): Return the new array instead of
	expecting pointer to pointer to avoid violation of aliasing rules.
	* ada-lang.h (GROW_VECT): Adapt call to grow_vect.
@
text
@d1813 1
a1813 1
                    VALUE_ADDRESS (obj) + VALUE_OFFSET (obj) + offset, NULL);
d7775 1
a7775 1
              return value_at_lazy (arrType, 0, NULL);
@


1.59
log
@
* ada-lang.c (ada_lookup_symbol): Correct comment.
(ada_evaluate_subexp): Change error message for
OP_FUNCALL case so as not to indicate an internal error.

From Joel Brobecker; committed by Paul Hilfinger.
* ada-lang.c (ada_template_to_fixed_record_type_1): Detect bogus
type sizes in XVE/XVU types, and emit a warning when that happens,
instead of rounding up the size of the resulting type.
Some minor reformatting.
(ada_is_aligner_type): Do not consider a type as an aligner type
if there is a corresponding XVS type as well.
(ada_evaluate_subexp): For TERNOP_SLICE, handle cases where we
have several levels of pointer indirection to the array.

From Jerome Guitton; committed by Paul Hilfinger.
* ada-lang.c (check_size): New function.
(coerce_unspec_val_to_type): call check_size to make sure
that the object size is reasonable.
(ada_evaluate_subexp): in UNOP_IND: Ditto. In TERNOP_SLICE:
Implements the case when we get a reference when we evaluate
the expression of one of the bounds of the slice.
(ada_value_struct_elt): when a packed array field is
a reference, use ada_coerce_ref to dereference it; use
ada_value_ind only if it is a pointer.
@
text
@d322 1
a322 1
/* Assuming *OLD_VECT points to an array of *SIZE objects of size
d324 1
a324 1
   updating *OLD_VECT and *SIZE as necessary.  */
d326 2
a327 2
void
grow_vect (void **old_vect, size_t * size, size_t min_size, int element_size)
d334 1
a334 1
      *old_vect = xrealloc (*old_vect, *size * element_size);
d336 1
@


1.58
log
@2004-10-10  Andrew Cagney  <cagney@@gnu.org>

	* ada-lang.c (lim_warning): Add ATTR_FORMAT prototype and FIXME
	comment.
@
text
@d232 2
d442 1
a442 2
      if (TYPE_LENGTH (type) > varsize_limit)
        error ("object size is larger than varsize-limit");
d499 12
d4488 5
a4492 4
   but is disambiguated by user query if needed.  *IS_A_FIELD_OF_THIS is
   set to 0 and *SYMTAB is set to the symbol table in which the symbol
   was found (in both cases, these assignments occur only if the
   pointers are non-null).  */
d5535 4
a5538 1
              arg = ada_value_ind (arg);
d6162 17
a6178 1
  TYPE_LENGTH (rtype) = align_value (TYPE_LENGTH (rtype), TYPE_LENGTH (type));
d6776 7
d7395 2
a7396 1
          error ("Internal error in evaluate_subexp");
d7404 8
a7411 3
        LONGEST low_bound = pos_atr (low_bound_val);
        LONGEST high_bound
          = pos_atr (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d7440 14
d7780 7
a7786 5
            return
              value_zero
              (to_static_fixed_type
               (ada_aligned_type (check_typedef (TYPE_TARGET_TYPE (type)))),
               lval_memory);
@


1.57
log
@* ada-lang.c (lim_warning): Re-implement as a varargs function.
(decode_packed_array_type, value_subscript_packed)
(ada_evaluate_subexp, to_fixed_range_type): Remove redundant
argument in call to lim_warning.
@
text
@d481 4
@


1.56
log
@* ada-typeprint.c (ada_print_type): Use int_string for printing
modulus of modular type.
* ada-lang.h (ada_modulus): Change return type to unsigned.
* ada-lang.c (ada_language_arch_info): Correct type of
string_char_type.
(ada_modulus): Return unsigned result.
(ada_lookup_symbol): Remove user disambiguation and modify comment
accordingly.

2004-10-08 Eric Botcazou  <ebotcazou@@act-europe.fr>

Committed by Paul Hilfinger.
* ada-lang.c (decode_packed_array): On big-endian targets,
left-justify the value if it comes with a modular type.

2004-10-08  Joel Brobecker  <brobecker@@gnat.com>

Committed by Paul Hilfinger.
* ada-lang.c (template_to_static_fixed_type): Fix a small typo.
(is_name_suffix): Add support for "___JM" suffixes.
(ada_check_typedef): Renames ada_completed_type.
Update all users of CHECK_TYPEDEF, check_typedef, and
ada_complete_type to call ada_check_typedef.
* ada-typeprint.c: Likewise.
* ada-valprint.c: Likewise.
@
text
@d480 1
d482 1
a482 1
lim_warning (const char *format, long arg)
d484 3
d489 3
a491 1
    warning (format, arg);
d1613 1
a1613 1
      lim_warning ("could not find bounds information on packed array", 0);
d1620 1
a1620 2
      lim_warning ("could not understand bounds information on packed array",
                   0);
d1627 1
a1627 1
        ("could not understand bit size information on packed array", 0);
d1713 1
a1713 1
              lim_warning ("don't know bounds of array", 0);
d7425 1
a7425 1
                       "always returns true", 0);
d8087 1
a8087 1
              lim_warning ("Unknown lower bound, using 1.", 1);
@


1.55
log
@First part of turning on initial Ada support.

* symfile.c (init_filename_language_table): Add extensions for
Ada.
* defs.h (enum language): Add language_ada.
* gdbtypes.h (TYPE_FLAG_FIXED_INSTANCE): Define.
* ada-lang.c: Strip code that is conditionalized out by GNAT_GDB.
(add_symbols_from_enclosing_procs): Make a no-op for now.
(ada_unqualified_name,add_angle_brackets,function_name_from_pc)
(extended_canonical_line_spec, find_sal_from_funcs_and_line)
(find_line_in_linetable, find_next_line_in_linetable)
(read_all_symtabs, is_plausible_func_for_line)
(adjust_pc_past_prologue, error_breakpoint_runtime_sym_not_found)
(is_runtime_sym_defined, check_size): Remove declaration.
(function_name_from_pc, ada_translate_error_message)
(ada_lookup_minimal_symbol): Remove definition.
(ada_add_block_symbols): Remove useless label.
* ada-lang.h (ada_maybe_exception_partial_symbol): Remove
useless declaration.
(ada_is_exception_sym): Likewise.
@
text
@d431 1
a431 1
  CHECK_TYPEDEF (type);
d1080 1
a1080 1
  CHECK_TYPEDEF (type);
d1084 1
a1084 1
    return check_typedef (TYPE_TARGET_TYPE (type));
d1162 1
a1162 1
        return check_typedef (r);
d1168 1
a1168 1
        return check_typedef (TYPE_TARGET_TYPE (check_typedef (r)));
d1179 1
a1179 1
  struct type *type = check_typedef (VALUE_TYPE (arr));
d1229 1
a1229 1
    return 8 * TYPE_LENGTH (check_typedef (TYPE_FIELD_TYPE (type, 1)));
d1364 1
a1364 1
  CHECK_TYPEDEF (type);
d1376 1
a1376 1
  CHECK_TYPEDEF (type);
d1391 1
a1391 1
  CHECK_TYPEDEF (type);
d1436 1
a1436 1
      check_typedef (TYPE_TARGET_TYPE (desc_data_type (VALUE_TYPE (arr))));
d1448 1
a1448 1
        return check_typedef (VALUE_TYPE (arr));
d1536 1
a1536 1
  CHECK_TYPEDEF (type);
d1558 1
a1558 1
  CHECK_TYPEDEF (type);
d1563 1
a1563 1
  new_elt_type = packed_array_type (check_typedef (TYPE_TARGET_TYPE (type)),
d1592 1
a1592 1
  const char *raw_name = ada_type_name (check_typedef (type));
d1650 25
d1693 1
a1693 1
  elt_type = check_typedef (VALUE_TYPE (arr));
d1717 1
a1717 1
          elt_type = check_typedef (TYPE_TARGET_TYPE (elt_type));
d1780 1
a1780 1
  CHECK_TYPEDEF (type);
d2038 1
a2038 1
  elt_type = check_typedef (VALUE_TYPE (elt));
d2135 1
a2135 1
        type = check_typedef (TYPE_TARGET_TYPE (type));
d2168 1
a2168 1
          p_array_type = check_typedef (TYPE_TARGET_TYPE (p_array_type));
d2315 1
a2315 1
  struct type *arr_type = check_typedef (VALUE_TYPE (arr));
d2763 2
a2764 2
  CHECK_TYPEDEF (ftype);
  CHECK_TYPEDEF (atype);
d2843 2
a2844 2
          struct type *ftype = check_typedef (TYPE_FIELD_TYPE (func_type, i));
          struct type *atype = check_typedef (VALUE_TYPE (actuals[i]));
d2917 1
a2917 1
          struct type *type = check_typedef (SYMBOL_TYPE (syms[k].sym));
d3316 1
a3316 1
    (args[0] == NULL) ? NULL : check_typedef (VALUE_TYPE (args[0]));
d3318 1
a3318 1
    (args[1] == NULL) ? NULL : check_typedef (VALUE_TYPE (args[1]));
d3449 1
a3449 1
      int len = TYPE_LENGTH (check_typedef (VALUE_TYPE (val)));
d3490 2
a3491 2
  struct type *actual_type = check_typedef (VALUE_TYPE (actual));
  struct type *formal_type = check_typedef (formal_type0);
d3494 1
a3494 1
    ? check_typedef (TYPE_TARGET_TYPE (formal_type)) : formal_type;
d3497 1
a3497 1
    ? check_typedef (TYPE_TARGET_TYPE (actual_type)) : actual_type;
d3512 1
a3512 1
              actual_type = check_typedef (VALUE_TYPE (actual));
d3544 1
a3544 1
  for (i = ada_array_arity (check_typedef (VALUE_TYPE (arr))); i > 0; i -= 1)
d3725 1
a3725 1
    CHECK_TYPEDEF (SYMBOL_TYPE (sym));
a4482 2
  else if (n_candidates != 1)
    user_select_syms (candidates, n_candidates, 1);
d4537 1
a4537 1
   (X[nb]*)?((\$|__)[0-9](_?[0-9]+)|___(LJM|X([FDBUP].*|R[^T]?)))?$
d4600 7
d5049 1
a5049 1
  CHECK_TYPEDEF (type);
d5056 1
a5056 1
      return check_typedef (TYPE_FIELD_TYPE (type, i));
d5068 1
a5068 1
  const char *name = TYPE_FIELD_NAME (check_typedef (type), field_num);
d5285 1
a5285 1
  CHECK_TYPEDEF (arg_type);
d5317 1
a5317 1
  CHECK_TYPEDEF (type);
d5349 1
a5349 1
          struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, i));
d5378 1
a5378 1
  CHECK_TYPEDEF (type);
d5403 1
a5403 1
          struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, i));
d5444 1
a5444 1
  t1 = t = check_typedef (VALUE_TYPE (arg));
d5455 1
a5455 1
      CHECK_TYPEDEF (t1);
d5473 1
a5473 1
      CHECK_TYPEDEF (t1);
d5558 1
a5558 1
        CHECK_TYPEDEF (type);
d5599 1
a5599 1
          return check_typedef (TYPE_FIELD_TYPE (type, i));
d5618 1
a5618 1
          struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, i));
d5927 1
a5927 1
  CHECK_TYPEDEF (type);
d6179 1
a6179 1
      struct type *field_type = CHECK_TYPEDEF (TYPE_FIELD_TYPE (type0, f));
d6385 1
a6385 1
      struct type *elt_type0 = check_typedef (TYPE_TARGET_TYPE (type0));
d6409 1
a6409 1
      result = ada_to_fixed_type (check_typedef (elt_type0), 0, 0, dval);
d6437 1
a6437 1
  CHECK_TYPEDEF (type);
d6480 1
a6480 1
  CHECK_TYPEDEF (type0);
d6508 1
a6508 1
      struct type *type1 = TYPE_FIELD_TYPE (check_typedef (type), 0);
d6539 1
a6539 1
ada_completed_type (struct type *type)
d6710 1
a6710 1
  CHECK_TYPEDEF (type);
d6733 1
a6733 1
  CHECK_TYPEDEF (type);
d6888 1
a6888 1
  struct type *type = check_typedef (VALUE_TYPE (val));
d6893 1
a6893 1
      struct type *val_type = check_typedef (VALUE_TYPE (v));
d6902 1
a6902 1
        ada_completed_type (ada_get_base_type (type));
d6954 2
a6955 2
  CHECK_TYPEDEF (type2);
  CHECK_TYPEDEF (type);
d6985 2
a6986 2
  type1 = base_type (check_typedef (VALUE_TYPE (arg1)));
  type2 = base_type (check_typedef (VALUE_TYPE (arg2)));
d7097 1
a7097 1
      if (type != check_typedef (VALUE_TYPE (arg1)))
d7274 1
a7274 1
      type = check_typedef (VALUE_TYPE (argvec[0]));
d7277 1
a7277 1
          switch (TYPE_CODE (check_typedef (TYPE_TARGET_TYPE (type))))
d7280 1
a7280 1
              type = check_typedef (TYPE_TARGET_TYPE (type));
d7287 1
a7287 1
              type = check_typedef (TYPE_TARGET_TYPE (type));
d7379 2
a7380 2
            && ada_is_array_descriptor_type (check_typedef
					     (VALUE_TYPE (array))))
d7692 1
a7692 1
        expect_type = TYPE_TARGET_TYPE (check_typedef (expect_type));
d7696 1
a7696 1
      type = check_typedef (VALUE_TYPE (arg1));
d7723 1
a7723 1
      type = check_typedef (VALUE_TYPE (arg1));
d8138 1
a8138 1
LONGEST
d8141 1
a8141 1
  return TYPE_HIGH_BOUND (type) + 1;
d8576 2
a8577 1
  lai->primitive_type_vector [ada_primitive_type_char] =
a8579 1
  lai->string_char_type = builtin->builtin_char;
@


1.54
log
@* ada-exp.y (type_int): New function to add layer of abstraction
around references to expression types.
(type_long): Ditto.
(type_long_long): Ditto.
(type_float): Ditto.
(type_double): Ditto.
(type_long_double): Ditto.
(type_char): Ditto.
(type_system_address): Ditto.
(simple_exp): Use type_* functions in place of builtin_*
variables.
(exp): Ditto.
(write_var_from_name): Ditto.
(write_object_renaming): Ditto.
* ada-lang.c (ada_create_fundamental_type): Remove redundant
declaration.
(build_ada_types): Remove, replacing with...
(ada_language_arch_info): New function to initialize primitive
type vector in language_arch_info.
(ada_array_length): Remove use of builtin_type_ada_int.
(value_pos_atr): Ditto.
(ada_evaluate_subexp): Ditto.
(builtin_type_ada_int, builtin_type_ada_short, builtin_type_ada_long,
builtin_type_ada_long_long, builtin_type_ada_char,
builtin_type_ada_float, builtin_type_ada_double,
builtin_type_ada_long_double, builtin_type_ada_natural,
builtin_type_ada_positive, builtin_type_ada_system_address): Remove.
(ada_builtin_types): Remove.
(ada_language_defn): Remove entries for la_builtin_type_vector and
string_char_type and use ada_language_arch_info.
(_initialize_ada_language): Do type-vector initialization along
the lines of c-lang.c.
(ada_create_fundamental_type): Break up line.
(ada_dump_symtab): Remove unused function.
(enum ada_primitive_types): Define.
* ada-lang.h (builtin_type_ada_int, builtin_type_ada_short,
builtin_type_ada_long,builtin_type_ada_long_long,builtin_type_ada_char,
builtin_type_ada_float, builtin_type_ada_double,
builtin_type_ada_long_double, builtin_type_ada_natural,
builtin_type_ada_positive, builtin_type_ada_system_address): Remove.
* ada-lex.l: Use type_* functions in place of builtin_* variables.
(processInt): Ditto.
(processReal): Ditto.
(name_lookup): Ditto.
* ada-typeprint.c (print_range): Use builtin_type_int, not
builtin_type_ada_int.
@
text
@a21 12
/* Sections of code marked 

     #ifdef GNAT_GDB 
     ...
     #endif

   indicate sections that are used in sources distributed by 
   ACT, Inc., but not yet integrated into the public tree (where
   GNAT_GDB is not defined).  They are retained here nevertheless 
   to minimize the problems of maintaining different versions 
   of the source and to make the full source available. */

a65 16
#ifdef GNAT_GDB
/* A structure that contains a vector of strings.
   The main purpose of this type is to group the vector and its
   associated parameters in one structure.  This makes it easier
   to handle and pass around.  */

struct string_vector
{
  char **array; /* The vector itself.  */
  int index;    /* Index of the next available element in the array.  */
  size_t size;  /* The number of entries allocated in the array.  */
};

static struct string_vector xnew_string_vector (int initial_size);
static void string_vector_append (struct string_vector *sv, char *str);
#endif /* GNAT_GDB */
a66 2
static const char *ada_unqualified_name (const char *decoded_name);
static char *add_angle_brackets (const char *str);
a67 1
static char *function_name_from_pc (CORE_ADDR pc);
a155 3
static char *extended_canonical_line_spec (struct symtab_and_line,
                                           const char *);

a196 13
static struct symtabs_and_lines
find_sal_from_funcs_and_line (const char *, int,
                              struct ada_symbol_info *, int);

static int find_line_in_linetable (struct linetable *, int,
                                   struct ada_symbol_info *, int, int *);

static int find_next_line_in_linetable (struct linetable *, int, int, int);

static void read_all_symtabs (const char *);

static int is_plausible_func_for_line (struct symbol *, int);

a221 2
static void adjust_pc_past_prologue (CORE_ADDR *);

a229 4
static void error_breakpoint_runtime_sym_not_found (const char *err_desc);

static int is_runtime_sym_defined (const char *name, int allow_tramp);

a231 2

static void check_size (const struct type *);
a293 63
#ifdef GNAT_GDB

/* Create a new empty string_vector struct with an initial size of
   INITIAL_SIZE.  */

static struct string_vector
xnew_string_vector (int initial_size)
{
  struct string_vector result;

  result.array = (char **) xmalloc ((initial_size + 1) * sizeof (char *));
  result.index = 0;
  result.size = initial_size;

  return result;
}

/* Add STR at the end of the given string vector SV.  If SV is already
   full, its size is automatically increased (doubled).  */

static void
string_vector_append (struct string_vector *sv, char *str)
{
  if (sv->index >= sv->size)
    GROW_VECT (sv->array, sv->size, sv->size * 2);

  sv->array[sv->index] = str;
  sv->index++;
}

/* Given DECODED_NAME a string holding a symbol name in its
   decoded form (ie using the Ada dotted notation), returns
   its unqualified name.  */

static const char *
ada_unqualified_name (const char *decoded_name)
{
  const char *result = strrchr (decoded_name, '.');

  if (result != NULL)
    result++;                   /* Skip the dot...  */
  else
    result = decoded_name;

  return result;
}

/* Return a string starting with '<', followed by STR, and '>'.
   The result is good until the next call.  */

static char *
add_angle_brackets (const char *str)
{
  static char *result = NULL;

  xfree (result);
  result = (char *) xmalloc ((strlen (str) + 3) * sizeof (char));

  sprintf (result, "<%s>", str);
  return result;
}

#endif /* GNAT_GDB */
a319 14
/* Return the name of the function owning the instruction located at PC.
   Return NULL if no such function could be found.  */

static char *
function_name_from_pc (CORE_ADDR pc)
{
  char *func_name;

  if (!find_pc_partial_function (pc, &func_name, NULL, NULL))
    return NULL;

  return func_name;
}

a487 9
static const char *
ada_translate_error_message (const char *string)
{
  if (strcmp (string, "Invalid cast.") == 0)
    return "Invalid type conversion.";
  else
    return string;
}

d3575 2
a3576 99
                                /* Experimental Symbol Cache Module */

/* This module may well have been OBE, due to improvements in the 
   symbol-table module.  So until proven otherwise, it is disabled in
   the submitted public code, and may be removed from all sources
   in the future. */

#ifdef GNAT_GDB

/* This section implements a simple, fixed-sized hash table for those
   Ada-mode symbols that get looked up in the course of executing the user's
   commands.  The size is fixed on the grounds that there are not
   likely to be all that many symbols looked up during any given
   session, regardless of the size of the symbol table.  If we decide
   to go to a resizable table, let's just use the stuff from libiberty
   instead.  */

#define HASH_SIZE 1009

struct cache_entry
{
  const char *name;
  domain_enum namespace;
  struct symbol *sym;
  struct symtab *symtab;
  struct block *block;
  struct cache_entry *next;
};

static struct obstack cache_space;

static struct cache_entry *cache[HASH_SIZE];

/* Clear all entries from the symbol cache.  */

void
clear_ada_sym_cache (void)
{
  obstack_free (&cache_space, NULL);
  obstack_init (&cache_space);
  memset (cache, '\000', sizeof (cache));
}

static struct cache_entry **
find_entry (const char *name, domain_enum namespace)
{
  int h = msymbol_hash (name) % HASH_SIZE;
  struct cache_entry **e;
  for (e = &cache[h]; *e != NULL; e = &(*e)->next)
    {
      if (namespace == (*e)->namespace && strcmp (name, (*e)->name) == 0)
        return e;
    }
  return NULL;
}

/* Return (in SYM) the last cached definition for global or static symbol NAME
   in namespace DOMAIN.  Returns 1 if entry found, 0 otherwise.
   If SYMTAB is non-NULL, store the symbol
   table in which the symbol was found there, or NULL if not found.
   *BLOCK is set to the block in which NAME is found.  */

static int
lookup_cached_symbol (const char *name, domain_enum namespace,
                      struct symbol **sym, struct block **block,
                      struct symtab **symtab)
{
  struct cache_entry **e = find_entry (name, namespace);
  if (e == NULL)
    return 0;
  if (sym != NULL)
    *sym = (*e)->sym;
  if (block != NULL)
    *block = (*e)->block;
  if (symtab != NULL)
    *symtab = (*e)->symtab;
  return 1;
}

/* Set the cached definition of NAME in DOMAIN to SYM in block
   BLOCK and symbol table SYMTAB.  */

static void
cache_symbol (const char *name, domain_enum namespace, struct symbol *sym,
              struct block *block, struct symtab *symtab)
{
  int h = msymbol_hash (name) % HASH_SIZE;
  char *copy;
  struct cache_entry *e =
    (struct cache_entry *) obstack_alloc (&cache_space, sizeof (*e));
  e->next = cache[h];
  cache[h] = e;
  e->name = copy = obstack_alloc (&cache_space, strlen (name) + 1);
  strcpy (copy, name);
  e->sym = sym;
  e->namespace = namespace;
  e->symtab = symtab;
  e->block = block;
}
a3577 1
#else
a3590 1
#endif /* GNAT_GDB */
a3971 10
/* Return up minimal symbol for NAME, folded and encoded according to 
   Ada conventions, or NULL if none.  The last two arguments are ignored.  */

static struct minimal_symbol *
ada_lookup_minimal_symbol (const char *name, const char *sfile,
                           struct objfile *objf)
{
  return ada_lookup_simple_minsym (ada_encode (name));
}

a3982 66
#ifdef HAVE_ADD_SYMBOLS_FROM_ENCLOSING_PROCS
  /* Use a heuristic to find the frames of enclosing subprograms: treat the
     pointer-sized value at location 0 from the local-variable base of a
     frame as a static link, and then search up the call stack for a
     frame with that same local-variable base.  */
  static struct symbol static_link_sym;
  static struct symbol *static_link;
  struct value *target_link_val;

  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  struct frame_info *frame;

  if (!target_has_stack)
    return;

  if (static_link == NULL)
    {
      /* Initialize the local variable symbol that stands for the
         static link (when there is one).  */
      static_link = &static_link_sym;
      SYMBOL_LINKAGE_NAME (static_link) = "";
      SYMBOL_LANGUAGE (static_link) = language_unknown;
      SYMBOL_CLASS (static_link) = LOC_LOCAL;
      SYMBOL_DOMAIN (static_link) = VAR_DOMAIN;
      SYMBOL_TYPE (static_link) = lookup_pointer_type (builtin_type_void);
      SYMBOL_VALUE (static_link) =
        -(long) TYPE_LENGTH (SYMBOL_TYPE (static_link));
    }

  frame = get_selected_frame ();
  if (frame == NULL || inside_main_func (get_frame_address_in_block (frame)))
    return;

  target_link_val = read_var_value (static_link, frame);
  while (target_link_val != NULL
         && num_defns_collected (obstackp) == 0
         && frame_relative_level (frame) <= MAX_ENCLOSING_FRAME_LEVELS)
    {
      CORE_ADDR target_link = value_as_address (target_link_val);

      frame = get_prev_frame (frame);
      if (frame == NULL)
        break;

      if (get_frame_locals_address (frame) == target_link)
        {
          struct block *block;

          QUIT;

          block = get_frame_block (frame, 0);
          while (block != NULL && block_function (block) != NULL
                 && num_defns_collected (obstackp) == 0)
            {
              QUIT;

              ada_add_block_symbols (obstackp, block, name, namespace,
                                     NULL, NULL, wild_match);

              block = BLOCK_SUPERBLOCK (block);
            }
        }
    }

  do_cleanups (old_chain);
#endif
a4444 2


a4862 1
      end_loop2:;
d4876 1
a4876 1
#ifdef GNAT_GDB
d4878 2
a4879 1
                                /* Symbol Completion */
d4881 2
a4882 13
/* If SYM_NAME is a completion candidate for TEXT, return this symbol
   name in a form that's appropriate for the completion.  The result
   does not need to be deallocated, but is only good until the next call.

   TEXT_LEN is equal to the length of TEXT.
   Perform a wild match if WILD_MATCH is set.
   ENCODED should be set if TEXT represents the start of a symbol name
   in its encoded form.  */

static const char *
symbol_completion_match (const char *sym_name,
                         const char *text, int text_len,
                         int wild_match, int encoded)
d4884 3
a4886 5
  char *result;
  const int verbatim_match = (text[0] == '<');
  int match = 0;

  if (verbatim_match)
d4888 3
a4890 3
      /* Strip the leading angle bracket.  */
      text = text + 1;
      text_len--;
d4892 1
d4894 2
a4895 1
  /* First, test against the fully qualified name of the symbol.  */
d4897 5
a4901 2
  if (strncmp (sym_name, text, text_len) == 0)
    match = 1;
d4903 1
a4903 8
  if (match && !encoded)
    {
      /* One needed check before declaring a positive match is to verify
         that iff we are doing a verbatim match, the decoded version
         of the symbol name starts with '<'.  Otherwise, this symbol name
         is not a suitable completion.  */
      const char *sym_name_copy = sym_name;
      int has_angle_bracket;
d4905 6
a4910 7
      sym_name = ada_decode (sym_name);
      has_angle_bracket = (sym_name[0] == '<');
      match = (has_angle_bracket == verbatim_match);
      sym_name = sym_name_copy;
    }

  if (match && !verbatim_match)
d4912 3
a4914 10
      /* When doing non-verbatim match, another check that needs to
         be done is to verify that the potentially matching symbol name
         does not include capital letters, because the ada-mode would
         not be able to understand these symbol names without the
         angle bracket notation.  */
      const char *tmp;

      for (tmp = sym_name; *tmp != '\0' && !isupper (*tmp); tmp++);
      if (*tmp != '\0')
        match = 0;
d4916 1
d4918 1
a4918 1
  /* Second: Try wild matching...  */
d4920 5
a4924 6
  if (!match && wild_match)
    {
      /* Since we are doing wild matching, this means that TEXT
         may represent an unqualified symbol name.  We therefore must
         also compare TEXT against the unqualified name of the symbol.  */
      sym_name = ada_unqualified_name (ada_decode (sym_name));
d4926 1
a4926 3
      if (strncmp (sym_name, text, text_len) == 0)
        match = 1;
    }
d4928 5
a4932 1
  /* Finally: If we found a mach, prepare the result to return.  */
d4934 3
a4936 2
  if (!match)
    return NULL;
d4938 11
a4948 2
  if (verbatim_match)
    sym_name = add_angle_brackets (sym_name);
d4950 4
a4953 2
  if (!encoded)
    sym_name = ada_decode (sym_name);
d4955 7
a4961 1
  return sym_name;
d4964 5
a4968 14
/* A companion function to ada_make_symbol_completion_list().
   Check if SYM_NAME represents a symbol which name would be suitable
   to complete TEXT (TEXT_LEN is the length of TEXT), in which case
   it is appended at the end of the given string vector SV.

   ORIG_TEXT is the string original string from the user command
   that needs to be completed.  WORD is the entire command on which
   completion should be performed.  These two parameters are used to
   determine which part of the symbol name should be added to the
   completion vector.
   if WILD_MATCH is set, then wild matching is performed.
   ENCODED should be set if TEXT represents a symbol name in its
   encoded formed (in which case the completion should also be
   encoded).  */
d4970 4
a4973 10
static void
symbol_completion_add (struct string_vector *sv,
                       const char *sym_name,
                       const char *text, int text_len,
                       const char *orig_text, const char *word,
                       int wild_match, int encoded)
{
  const char *match = symbol_completion_match (sym_name, text, text_len,
                                               wild_match, encoded);
  char *completion;
d4975 20
a4994 27
  if (match == NULL)
    return;

  /* We found a match, so add the appropriate completion to the given
     string vector.  */

  if (word == orig_text)
    {
      completion = xmalloc (strlen (match) + 5);
      strcpy (completion, match);
    }
  else if (word > orig_text)
    {
      /* Return some portion of sym_name.  */
      completion = xmalloc (strlen (match) + 5);
      strcpy (completion, match + (word - orig_text));
    }
  else
    {
      /* Return some of ORIG_TEXT plus sym_name.  */
      completion = xmalloc (strlen (match) + (orig_text - word) + 5);
      strncpy (completion, word, orig_text - word);
      completion[orig_text - word] = '\0';
      strcat (completion, match);
    }

  string_vector_append (sv, completion);
d4997 2
a4998 3
/* Return a list of possible symbol names completing TEXT0.  The list
   is NULL terminated.  WORD is the entire command on which completion
   is made.  */
d5000 2
a5001 2
char **
ada_make_symbol_completion_list (const char *text0, const char *word)
d5003 1
a5003 1358
  /* Note: This function is almost a copy of make_symbol_completion_list(),
     except it has been adapted for Ada.  It is somewhat of a shame to
     duplicate so much code, but we don't really have the infrastructure
     yet to develop a language-aware version of he symbol completer...  */
  char *text;
  int text_len;
  int wild_match;
  int encoded;
  struct string_vector result = xnew_string_vector (128);
  struct symbol *sym;
  struct symtab *s;
  struct partial_symtab *ps;
  struct minimal_symbol *msymbol;
  struct objfile *objfile;
  struct block *b, *surrounding_static_block = 0;
  int i;
  struct dict_iterator iter;

  if (text0[0] == '<')
    {
      text = xstrdup (text0);
      make_cleanup (xfree, text);
      text_len = strlen (text);
      wild_match = 0;
      encoded = 1;
    }
  else
    {
      text = xstrdup (ada_encode (text0));
      make_cleanup (xfree, text);
      text_len = strlen (text);
      for (i = 0; i < text_len; i++)
        text[i] = tolower (text[i]);

      /* FIXME: brobecker/2003-09-17: When we get rid of ADA_RETAIN_DOTS,
         we can restrict the wild_match check to searching "__" only.  */
      wild_match = (strstr (text0, "__") == NULL
                    && strchr (text0, '.') == NULL);
      encoded = (strstr (text0, "__") != NULL);
    }

  /* First, look at the partial symtab symbols.  */
  ALL_PSYMTABS (objfile, ps)
  {
    struct partial_symbol **psym;

    /* If the psymtab's been read in we'll get it when we search
       through the blockvector.  */
    if (ps->readin)
      continue;

    for (psym = objfile->global_psymbols.list + ps->globals_offset;
         psym < (objfile->global_psymbols.list + ps->globals_offset
                 + ps->n_global_syms); psym++)
      {
        QUIT;
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (*psym),
                               text, text_len, text0, word,
                               wild_match, encoded);
      }

    for (psym = objfile->static_psymbols.list + ps->statics_offset;
         psym < (objfile->static_psymbols.list + ps->statics_offset
                 + ps->n_static_syms); psym++)
      {
        QUIT;
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (*psym),
                               text, text_len, text0, word,
                               wild_match, encoded);
      }
  }

  /* At this point scan through the misc symbol vectors and add each
     symbol you find to the list.  Eventually we want to ignore
     anything that isn't a text symbol (everything else will be
     handled by the psymtab code above).  */

  ALL_MSYMBOLS (objfile, msymbol)
  {
    QUIT;
    symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (msymbol),
                           text, text_len, text0, word, wild_match, encoded);
  }

  /* Search upwards from currently selected frame (so that we can
     complete on local vars.  */

  for (b = get_selected_block (0); b != NULL; b = BLOCK_SUPERBLOCK (b))
    {
      if (!BLOCK_SUPERBLOCK (b))
        surrounding_static_block = b;   /* For elmin of dups */

      ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
                               text, text_len, text0, word,
                               wild_match, encoded);
      }
    }

  /* Go through the symtabs and check the externs and statics for
     symbols which match.  */

  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
    ALL_BLOCK_SYMBOLS (b, iter, sym)
    {
      symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
                             text, text_len, text0, word,
                             wild_match, encoded);
    }
  }

  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
    /* Don't do this block twice.  */
    if (b == surrounding_static_block)
      continue;
    ALL_BLOCK_SYMBOLS (b, iter, sym)
    {
      symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
                             text, text_len, text0, word,
                             wild_match, encoded);
    }
  }

  /* Append the closing NULL entry.  */
  string_vector_append (&result, NULL);

  return (result.array);
}

#endif /* GNAT_GDB */

#ifdef GNAT_GDB
                                /* Breakpoint-related */

/* Assuming that LINE is pointing at the beginning of an argument to
   'break', return a pointer to the delimiter for the initial segment
   of that name.  This is the first ':', ' ', or end of LINE.  */

char *
ada_start_decode_line_1 (char *line)
{
  /* NOTE: strpbrk would be more elegant, but I am reluctant to be
     the first to use such a library function in GDB code.  */
  char *p;
  for (p = line; *p != '\000' && *p != ' ' && *p != ':'; p += 1)
    ;
  return p;
}

/* *SPEC points to a function and line number spec (as in a break
   command), following any initial file name specification.

   Return all symbol table/line specfications (sals) consistent with the
   information in *SPEC and FILE_TABLE in the following sense:
     + FILE_TABLE is null, or the sal refers to a line in the file
       named by FILE_TABLE.
     + If *SPEC points to an argument with a trailing ':LINENUM',
       then the sal refers to that line (or one following it as closely as
       possible).
     + If *SPEC does not start with '*', the sal is in a function with
       that name.

   Returns with 0 elements if no matching non-minimal symbols found.

   If *SPEC begins with a function name of the form <NAME>, then NAME
   is taken as a literal name; otherwise the function name is subject
   to the usual encoding.

   *SPEC is updated to point after the function/line number specification.

   FUNFIRSTLINE is non-zero if we desire the first line of real code
   in each function.

   If CANONICAL is non-NULL, and if any of the sals require a
   'canonical line spec', then *CANONICAL is set to point to an array
   of strings, corresponding to and equal in length to the returned
   list of sals, such that (*CANONICAL)[i] is non-null and contains a
   canonical line spec for the ith returned sal, if needed.  If no
   canonical line specs are required and CANONICAL is non-null,
   *CANONICAL is set to NULL.

   A 'canonical line spec' is simply a name (in the format of the
   breakpoint command) that uniquely identifies a breakpoint position,
   with no further contextual information or user selection.  It is
   needed whenever the file name, function name, and line number
   information supplied is insufficient for this unique
   identification.  Currently overloaded functions, the name '*',
   or static functions without a filename yield a canonical line spec.
   The array and the line spec strings are allocated on the heap; it
   is the caller's responsibility to free them.  */

struct symtabs_and_lines
ada_finish_decode_line_1 (char **spec, struct symtab *file_table,
                          int funfirstline, char ***canonical)
{
  struct ada_symbol_info *symbols;
  const struct block *block;
  int n_matches, i, line_num;
  struct symtabs_and_lines selected;
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  char *name;
  int is_quoted;

  int len;
  char *lower_name;
  char *unquoted_name;

  if (file_table == NULL)
    block = block_static_block (get_selected_block (0));
  else
    block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (file_table), STATIC_BLOCK);

  if (canonical != NULL)
    *canonical = (char **) NULL;

  is_quoted = (**spec && strchr (get_gdb_completer_quote_characters (),
                                 **spec) != NULL);

  name = *spec;
  if (**spec == '*')
    *spec += 1;
  else
    {
      if (is_quoted)
        *spec = skip_quoted (*spec);
      while (**spec != '\000'
             && !strchr (ada_completer_word_break_characters, **spec))
        *spec += 1;
    }
  len = *spec - name;

  line_num = -1;
  if (file_table != NULL && (*spec)[0] == ':' && isdigit ((*spec)[1]))
    {
      line_num = strtol (*spec + 1, spec, 10);
      while (**spec == ' ' || **spec == '\t')
        *spec += 1;
    }

  if (name[0] == '*')
    {
      if (line_num == -1)
        error ("Wild-card function with no line number or file name.");

      return ada_sals_for_line (file_table->filename, line_num,
                                funfirstline, canonical, 0);
    }

  if (name[0] == '\'')
    {
      name += 1;
      len -= 2;
    }

  if (name[0] == '<')
    {
      unquoted_name = (char *) alloca (len - 1);
      memcpy (unquoted_name, name + 1, len - 2);
      unquoted_name[len - 2] = '\000';
      lower_name = NULL;
    }
  else
    {
      unquoted_name = (char *) alloca (len + 1);
      memcpy (unquoted_name, name, len);
      unquoted_name[len] = '\000';
      lower_name = (char *) alloca (len + 1);
      for (i = 0; i < len; i += 1)
        lower_name[i] = tolower (name[i]);
      lower_name[len] = '\000';
    }

  n_matches = 0;
  if (lower_name != NULL)
    n_matches = ada_lookup_symbol_list (ada_encode (lower_name), block,
                                        VAR_DOMAIN, &symbols);
  if (n_matches == 0)
    n_matches = ada_lookup_symbol_list (unquoted_name, block,
                                        VAR_DOMAIN, &symbols);
  if (n_matches == 0 && line_num >= 0)
    error ("No line number information found for %s.", unquoted_name);
  else if (n_matches == 0)
    {
#ifdef HPPA_COMPILER_BUG
      /* FIXME: See comment in symtab.c::decode_line_1 */
#undef volatile
      volatile struct symtab_and_line val;
#define volatile                /*nothing */
#else
      struct symtab_and_line val;
#endif
      struct minimal_symbol *msymbol;

      init_sal (&val);

      msymbol = NULL;
      if (lower_name != NULL)
        msymbol = ada_lookup_simple_minsym (ada_encode (lower_name));
      if (msymbol == NULL)
        msymbol = ada_lookup_simple_minsym (unquoted_name);
      if (msymbol != NULL)
        {
          val.pc = SYMBOL_VALUE_ADDRESS (msymbol);
          val.section = SYMBOL_BFD_SECTION (msymbol);
          if (funfirstline)
            {
              val.pc = gdbarch_convert_from_func_ptr_addr (current_gdbarch,
							   val.pc,
							   &current_target);
              SKIP_PROLOGUE (val.pc);
            }
          selected.sals = (struct symtab_and_line *)
            xmalloc (sizeof (struct symtab_and_line));
          selected.sals[0] = val;
          selected.nelts = 1;
          return selected;
        }

      if (!have_full_symbols ()
          && !have_partial_symbols () && !have_minimal_symbols ())
        error ("No symbol table is loaded.  Use the \"file\" command.");

      error ("Function \"%s\" not defined.", unquoted_name);
      return selected;          /* for lint */
    }

  if (line_num >= 0)
    {
      struct symtabs_and_lines best_sal =
        find_sal_from_funcs_and_line (file_table->filename, line_num,
                                      symbols, n_matches);
      if (funfirstline)
        adjust_pc_past_prologue (&best_sal.sals[0].pc);
      return best_sal;
    }
  else
    {
      selected.nelts = user_select_syms (symbols, n_matches, n_matches);
    }

  selected.sals = (struct symtab_and_line *)
    xmalloc (sizeof (struct symtab_and_line) * selected.nelts);
  memset (selected.sals, 0, selected.nelts * sizeof (selected.sals[i]));
  make_cleanup (xfree, selected.sals);

  i = 0;
  while (i < selected.nelts)
    {
      if (SYMBOL_CLASS (symbols[i].sym) == LOC_BLOCK)
        selected.sals[i]
          = find_function_start_sal (symbols[i].sym, funfirstline);
      else if (SYMBOL_LINE (symbols[i].sym) != 0)
        {
          selected.sals[i].symtab =
            symbols[i].symtab
            ? symbols[i].symtab : symtab_for_sym (symbols[i].sym);
          selected.sals[i].line = SYMBOL_LINE (symbols[i].sym);
        }
      else if (line_num >= 0)
        {
          /* Ignore this choice */
          symbols[i] = symbols[selected.nelts - 1];
          selected.nelts -= 1;
          continue;
        }
      else
        error ("Line number not known for symbol \"%s\"", unquoted_name);
      i += 1;
    }

  if (canonical != NULL && (line_num >= 0 || n_matches > 1))
    {
      *canonical = (char **) xmalloc (sizeof (char *) * selected.nelts);
      for (i = 0; i < selected.nelts; i += 1)
        (*canonical)[i] =
          extended_canonical_line_spec (selected.sals[i],
                                        SYMBOL_PRINT_NAME (symbols[i].sym));
    }

  discard_cleanups (old_chain);
  return selected;
}

/* The (single) sal corresponding to line LINE_NUM in a symbol table
   with file name FILENAME that occurs in one of the functions listed
   in the symbol fields of SYMBOLS[0 .. NSYMS-1].  */

static struct symtabs_and_lines
find_sal_from_funcs_and_line (const char *filename, int line_num,
                              struct ada_symbol_info *symbols, int nsyms)
{
  struct symtabs_and_lines sals;
  int best_index, best;
  struct linetable *best_linetable;
  struct objfile *objfile;
  struct symtab *s;
  struct symtab *best_symtab;

  read_all_symtabs (filename);

  best_index = 0;
  best_linetable = NULL;
  best_symtab = NULL;
  best = 0;
  ALL_SYMTABS (objfile, s)
  {
    struct linetable *l;
    int ind, exact;

    QUIT;

    if (strcmp (filename, s->filename) != 0)
      continue;
    l = LINETABLE (s);
    ind = find_line_in_linetable (l, line_num, symbols, nsyms, &exact);
    if (ind >= 0)
      {
        if (exact)
          {
            best_index = ind;
            best_linetable = l;
            best_symtab = s;
            goto done;
          }
        if (best == 0 || l->item[ind].line < best)
          {
            best = l->item[ind].line;
            best_index = ind;
            best_linetable = l;
            best_symtab = s;
          }
      }
  }

  if (best == 0)
    error ("Line number not found in designated function.");

done:

  sals.nelts = 1;
  sals.sals = (struct symtab_and_line *) xmalloc (sizeof (sals.sals[0]));

  init_sal (&sals.sals[0]);

  sals.sals[0].line = best_linetable->item[best_index].line;
  sals.sals[0].pc = best_linetable->item[best_index].pc;
  sals.sals[0].symtab = best_symtab;

  return sals;
}

/* Return the index in LINETABLE of the best match for LINE_NUM whose
   pc falls within one of the functions denoted by the symbol fields
   of SYMBOLS[0..NSYMS-1].  Set *EXACTP to 1 if the match is exact, 
   and 0 otherwise.  */

static int
find_line_in_linetable (struct linetable *linetable, int line_num,
                        struct ada_symbol_info *symbols, int nsyms,
                        int *exactp)
{
  int i, len, best_index, best;

  if (line_num <= 0 || linetable == NULL)
    return -1;

  len = linetable->nitems;
  for (i = 0, best_index = -1, best = 0; i < len; i += 1)
    {
      int k;
      struct linetable_entry *item = &(linetable->item[i]);

      for (k = 0; k < nsyms; k += 1)
        {
          if (symbols[k].sym != NULL
              && SYMBOL_CLASS (symbols[k].sym) == LOC_BLOCK
              && item->pc >= BLOCK_START (SYMBOL_BLOCK_VALUE (symbols[k].sym))
              && item->pc < BLOCK_END (SYMBOL_BLOCK_VALUE (symbols[k].sym)))
            goto candidate;
        }
      continue;

    candidate:

      if (item->line == line_num)
        {
          *exactp = 1;
          return i;
        }

      if (item->line > line_num && (best == 0 || item->line < best))
        {
          best = item->line;
          best_index = i;
        }
    }

  *exactp = 0;
  return best_index;
}

/* Find the smallest k >= LINE_NUM such that k is a line number in
   LINETABLE, and k falls strictly within a named function that begins at
   or before LINE_NUM.  Return -1 if there is no such k.  */

static int
nearest_line_number_in_linetable (struct linetable *linetable, int line_num)
{
  int i, len, best;

  if (line_num <= 0 || linetable == NULL || linetable->nitems == 0)
    return -1;
  len = linetable->nitems;

  i = 0;
  best = INT_MAX;
  while (i < len)
    {
      struct linetable_entry *item = &(linetable->item[i]);

      if (item->line >= line_num && item->line < best)
        {
          char *func_name;
          CORE_ADDR start, end;

          func_name = NULL;
          find_pc_partial_function (item->pc, &func_name, &start, &end);

          if (func_name != NULL && item->pc < end)
            {
              if (item->line == line_num)
                return line_num;
              else
                {
                  struct symbol *sym =
                    standard_lookup (func_name, NULL, VAR_DOMAIN);
                  if (is_plausible_func_for_line (sym, line_num))
                    best = item->line;
                  else
                    {
                      do
                        i += 1;
                      while (i < len && linetable->item[i].pc < end);
                      continue;
                    }
                }
            }
        }

      i += 1;
    }

  return (best == INT_MAX) ? -1 : best;
}


/* Return the next higher index, k, into LINETABLE such that k > IND,
   entry k in LINETABLE has a line number equal to LINE_NUM, k
   corresponds to a PC that is in a function different from that
   corresponding to IND, and falls strictly within a named function
   that begins at a line at or preceding STARTING_LINE.
   Return -1 if there is no such k.
   IND == -1 corresponds to no function.  */

static int
find_next_line_in_linetable (struct linetable *linetable, int line_num,
                             int starting_line, int ind)
{
  int i, len;

  if (line_num <= 0 || linetable == NULL || ind >= linetable->nitems)
    return -1;
  len = linetable->nitems;

  if (ind >= 0)
    {
      CORE_ADDR start, end;

      if (find_pc_partial_function (linetable->item[ind].pc,
                                    (char **) NULL, &start, &end))
        {
          while (ind < len && linetable->item[ind].pc < end)
            ind += 1;
        }
      else
        ind += 1;
    }
  else
    ind = 0;

  i = ind;
  while (i < len)
    {
      struct linetable_entry *item = &(linetable->item[i]);

      if (item->line >= line_num)
        {
          char *func_name;
          CORE_ADDR start, end;

          func_name = NULL;
          find_pc_partial_function (item->pc, &func_name, &start, &end);

          if (func_name != NULL && item->pc < end)
            {
              if (item->line == line_num)
                {
                  struct symbol *sym =
                    standard_lookup (func_name, NULL, VAR_DOMAIN);
                  if (is_plausible_func_for_line (sym, starting_line))
                    return i;
                  else
                    {
                      while ((i + 1) < len && linetable->item[i + 1].pc < end)
                        i += 1;
                    }
                }
            }
        }
      i += 1;
    }

  return -1;
}

/* True iff function symbol SYM starts somewhere at or before line #
   LINE_NUM.  */

static int
is_plausible_func_for_line (struct symbol *sym, int line_num)
{
  struct symtab_and_line start_sal;

  if (sym == NULL)
    return 0;

  start_sal = find_function_start_sal (sym, 0);

  return (start_sal.line != 0 && line_num >= start_sal.line);
}

/* Read in all symbol tables corresponding to partial symbol tables
   with file name FILENAME.  */

static void
read_all_symtabs (const char *filename)
{
  struct partial_symtab *ps;
  struct objfile *objfile;

  ALL_PSYMTABS (objfile, ps)
  {
    QUIT;

    if (strcmp (filename, ps->filename) == 0)
      PSYMTAB_TO_SYMTAB (ps);
  }
}

/* All sals corresponding to line LINE_NUM in a symbol table from file
   FILENAME, as filtered by the user.  Filter out any lines that
   reside in functions with "suppressed" names (not corresponding to
   explicit Ada functions), if there is at least one in a function
   with a non-suppressed name.  If CANONICAL is not null, set
   it to a corresponding array of canonical line specs.
   If ONE_LOCATION_ONLY is set and several matches are found for
   the given location, then automatically select the first match found
   instead of asking the user which instance should be returned.  */

struct symtabs_and_lines
ada_sals_for_line (const char *filename, int line_num,
                   int funfirstline, char ***canonical, int one_location_only)
{
  struct symtabs_and_lines result;
  struct objfile *objfile;
  struct symtab *s;
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  size_t len;

  read_all_symtabs (filename);

  result.sals =
    (struct symtab_and_line *) xmalloc (4 * sizeof (result.sals[0]));
  result.nelts = 0;
  len = 4;
  make_cleanup (free_current_contents, &result.sals);

  ALL_SYMTABS (objfile, s)
  {
    int ind, target_line_num;

    QUIT;

    if (strcmp (s->filename, filename) != 0)
      continue;

    target_line_num =
      nearest_line_number_in_linetable (LINETABLE (s), line_num);
    if (target_line_num == -1)
      continue;

    ind = -1;
    while (1)
      {
        ind =
          find_next_line_in_linetable (LINETABLE (s),
                                       target_line_num, line_num, ind);

        if (ind < 0)
          break;

        GROW_VECT (result.sals, len, result.nelts + 1);
        init_sal (&result.sals[result.nelts]);
        result.sals[result.nelts].line = line_num;
        result.sals[result.nelts].pc = LINETABLE (s)->item[ind].pc;
        result.sals[result.nelts].symtab = s;

        if (funfirstline)
          adjust_pc_past_prologue (&result.sals[result.nelts].pc);

        result.nelts += 1;
      }
  }

  if (canonical != NULL || result.nelts > 1)
    {
      int k, j, n;
      char **func_names = (char **) alloca (result.nelts * sizeof (char *));
      int first_choice = (result.nelts > 1) ? 2 : 1;
      int *choices = (int *) alloca (result.nelts * sizeof (int));

      for (k = 0; k < result.nelts; k += 1)
        {
          find_pc_partial_function (result.sals[k].pc, &func_names[k],
                                    (CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
          if (func_names[k] == NULL)
            error ("Could not find function for one or more breakpoints.");
        }

      /* Remove suppressed names, unless all are suppressed.  */
      for (j = 0; j < result.nelts; j += 1)
        if (!is_suppressed_name (func_names[j]))
          {
            /* At least one name is unsuppressed, so remove all
               suppressed names.  */
            for (k = n = 0; k < result.nelts; k += 1)
              if (!is_suppressed_name (func_names[k]))
                {
                  func_names[n] = func_names[k];
                  result.sals[n] = result.sals[k];
                  n += 1;
                }
            result.nelts = n;
            break;
          }

      if (result.nelts > 1)
        {
          if (one_location_only)
            {
              /* Automatically select the first of all possible choices.  */
              n = 1;
              choices[0] = 0;
            }
          else
            {
              printf_unfiltered ("[0] cancel\n");
              if (result.nelts > 1)
                printf_unfiltered ("[1] all\n");
              for (k = 0; k < result.nelts; k += 1)
                printf_unfiltered ("[%d] %s\n", k + first_choice,
                                   ada_decode (func_names[k]));

              n = get_selections (choices, result.nelts, result.nelts,
                                  result.nelts > 1, "instance-choice");
            }

          for (k = 0; k < n; k += 1)
            {
              result.sals[k] = result.sals[choices[k]];
              func_names[k] = func_names[choices[k]];
            }
          result.nelts = n;
        }

      if (canonical != NULL && result.nelts == 0)
        *canonical = NULL;
      else if (canonical != NULL)
        {
          *canonical = (char **) xmalloc (result.nelts * sizeof (char **));
          make_cleanup (xfree, *canonical);
          for (k = 0; k < result.nelts; k += 1)
            {
              (*canonical)[k] =
                extended_canonical_line_spec (result.sals[k], func_names[k]);
              if ((*canonical)[k] == NULL)
                error ("Could not locate one or more breakpoints.");
              make_cleanup (xfree, (*canonical)[k]);
            }
        }
    }

  if (result.nelts == 0)
    {
      do_cleanups (old_chain);
      result.sals = NULL;
    }
  else
    discard_cleanups (old_chain);
  return result;
}


/* A canonical line specification of the form FILE:NAME:LINENUM for
   symbol table and line data SAL.  NULL if insufficient
   information.  The caller is responsible for releasing any space
   allocated.  */

static char *
extended_canonical_line_spec (struct symtab_and_line sal, const char *name)
{
  char *r;

  if (sal.symtab == NULL || sal.symtab->filename == NULL || sal.line <= 0)
    return NULL;

  r = (char *) xmalloc (strlen (name) + strlen (sal.symtab->filename)
                        + sizeof (sal.line) * 3 + 3);
  sprintf (r, "%s:'%s':%d", sal.symtab->filename, name, sal.line);
  return r;
}


				/* Exception-related */

int
ada_is_exception_sym (struct symbol *sym)
{
  char *type_name = type_name_no_tag (SYMBOL_TYPE (sym));

  return (SYMBOL_CLASS (sym) != LOC_TYPEDEF
          && SYMBOL_CLASS (sym) != LOC_BLOCK
          && SYMBOL_CLASS (sym) != LOC_CONST
          && type_name != NULL && strcmp (type_name, "exception") == 0);
}

/* Return type of Ada breakpoint associated with bp_stat:
   0 if not an Ada-specific breakpoint, 1 for break on specific exception,
   2 for break on unhandled exception, 3 for assert.  */

static int
ada_exception_breakpoint_type (bpstat bs)
{
  return ((!bs || !bs->breakpoint_at) ? 0
          : bs->breakpoint_at->break_on_exception);
}

/* True iff FRAME is very likely to be that of a function that is
   part of the runtime system.  This is all very heuristic, but is
   intended to be used as advice as to what frames are uninteresting
   to most users.  */

static int
is_known_support_routine (struct frame_info *frame)
{
  struct frame_info *next_frame = get_next_frame (frame);
  /* If frame is not innermost, that normally means that frame->pc
     points to *after* the call instruction, and we want to get the line
     containing the call, never the next line.  But if the next frame is
     a signal_handler_caller or a dummy frame, then the next frame was
     not entered as the result of a call, and we want to get the line
     containing frame->pc.  */
  const int pc_is_after_call =
    next_frame != NULL
    && get_frame_type (next_frame) != SIGTRAMP_FRAME
    && get_frame_type (next_frame) != DUMMY_FRAME;
  struct symtab_and_line sal
    = find_pc_line (get_frame_pc (frame), pc_is_after_call);
  char *func_name;
  int i;
  struct stat st;

  /* The heuristic:
     1. The symtab is null (indicating no debugging symbols)
     2. The symtab's filename does not exist.
     3. The object file's name is one of the standard libraries.
     4. The symtab's file name has the form of an Ada library source file.
     5. The function at frame's PC has a GNAT-compiler-generated name.  */

  if (sal.symtab == NULL)
    return 1;

  /* On some systems (e.g. VxWorks), the kernel contains debugging
     symbols; in this case, the filename referenced by these symbols
     does not exists.  */

  if (stat (sal.symtab->filename, &st))
    return 1;

  for (i = 0; known_runtime_file_name_patterns[i] != NULL; i += 1)
    {
      re_comp (known_runtime_file_name_patterns[i]);
      if (re_exec (sal.symtab->filename))
        return 1;
    }
  if (sal.symtab->objfile != NULL)
    {
      for (i = 0; known_runtime_file_name_patterns[i] != NULL; i += 1)
        {
          re_comp (known_runtime_file_name_patterns[i]);
          if (re_exec (sal.symtab->objfile->name))
            return 1;
        }
    }

  /* If the frame PC points after the call instruction, then we need to
     decrement it in order to search for the function associated to this
     PC.  Otherwise, if the associated call was the last instruction of
     the function, we might either find the wrong function or even fail
     during the function name lookup.  */
  if (pc_is_after_call)
    func_name = function_name_from_pc (get_frame_pc (frame) - 1);
  else
    func_name = function_name_from_pc (get_frame_pc (frame));

  if (func_name == NULL)
    return 1;

  for (i = 0; known_auxiliary_function_name_patterns[i] != NULL; i += 1)
    {
      re_comp (known_auxiliary_function_name_patterns[i]);
      if (re_exec (func_name))
        return 1;
    }

  return 0;
}

/* Find the first frame that contains debugging information and that is not
   part of the Ada run-time, starting from FI and moving upward.  */

void
ada_find_printable_frame (struct frame_info *fi)
{
  for (; fi != NULL; fi = get_prev_frame (fi))
    {
      if (!is_known_support_routine (fi))
        {
          select_frame (fi);
          break;
        }
    }

}

/* Name found for exception associated with last bpstat sent to
   ada_adjust_exception_stop.  Set to the null string if that bpstat
   did not correspond to an Ada exception or no name could be found.  */

static char last_exception_name[256];

/* If BS indicates a stop in an Ada exception, try to go up to a frame
   that will be meaningful to the user, and save the name of the last
   exception (truncated, if necessary) in last_exception_name.  */

void
ada_adjust_exception_stop (bpstat bs)
{
  CORE_ADDR addr;
  struct frame_info *fi;
  int frame_level;
  char *selected_frame_func;

  addr = 0;
  last_exception_name[0] = '\0';
  fi = get_selected_frame ();
  selected_frame_func = function_name_from_pc (get_frame_pc (fi));

  switch (ada_exception_breakpoint_type (bs))
    {
    default:
      return;
    case 1:
      break;
    case 2:
      /* Unhandled exceptions.  Select the frame corresponding to
         ada.exceptions.process_raise_exception.  This frame is at
         least 2 levels up, so we simply skip the first 2 frames
         without checking the name of their associated function.  */
      for (frame_level = 0; frame_level < 2; frame_level += 1)
        if (fi != NULL)
          fi = get_prev_frame (fi);
      while (fi != NULL)
        {
          const char *func_name = function_name_from_pc (get_frame_pc (fi));
          if (func_name != NULL
              && strcmp (func_name, process_raise_exception_name) == 0)
            break;              /* We found the frame we were looking for...  */
          fi = get_prev_frame (fi);
        }
      if (fi == NULL)
        break;
      select_frame (fi);
      break;
    }

  addr = parse_and_eval_address ("e.full_name");

  if (addr != 0)
    read_memory (addr, last_exception_name, sizeof (last_exception_name) - 1);
  last_exception_name[sizeof (last_exception_name) - 1] = '\0';
  ada_find_printable_frame (get_selected_frame ());
}

/* Output Ada exception name (if any) associated with last call to
   ada_adjust_exception_stop.  */

void
ada_print_exception_stop (bpstat bs)
{
  if (last_exception_name[0] != '\000')
    {
      ui_out_text (uiout, last_exception_name);
      ui_out_text (uiout, " at ");
    }
}

/* Parses the CONDITION string associated with a breakpoint exception
   to get the name of the exception on which the breakpoint has been
   set.  The returned string needs to be deallocated after use.  */

static char *
exception_name_from_cond (const char *condition)
{
  char *start, *end, *exception_name;
  int exception_name_len;

  start = strrchr (condition, '&') + 1;
  end = strchr (start, ')') - 1;
  exception_name_len = end - start + 1;

  exception_name =
    (char *) xmalloc ((exception_name_len + 1) * sizeof (char));
  sprintf (exception_name, "%.*s", exception_name_len, start);

  return exception_name;
}

/* Print Ada-specific exception information about B, other than task
   clause.  Return non-zero iff B was an Ada exception breakpoint.  */

int
ada_print_exception_breakpoint_nontask (struct breakpoint *b)
{
  if (b->break_on_exception == 1)
    {
      if (b->cond_string)       /* the breakpoint is on a specific exception.  */
        {
          char *exception_name = exception_name_from_cond (b->cond_string);

          make_cleanup (xfree, exception_name);

          ui_out_text (uiout, "on ");
          if (ui_out_is_mi_like_p (uiout))
            ui_out_field_string (uiout, "exception", exception_name);
          else
            {
              ui_out_text (uiout, "exception ");
              ui_out_text (uiout, exception_name);
              ui_out_text (uiout, " ");
            }
        }
      else
        ui_out_text (uiout, "on all exceptions");
    }
  else if (b->break_on_exception == 2)
    ui_out_text (uiout, "on unhandled exception");
  else if (b->break_on_exception == 3)
    ui_out_text (uiout, "on assert failure");
  else
    return 0;
  return 1;
}

/* Print task identifier for breakpoint B, if it is an Ada-specific
   breakpoint with non-zero tasking information.  */

void
ada_print_exception_breakpoint_task (struct breakpoint *b)
{
  if (b->task != 0)
    {
      ui_out_text (uiout, " task ");
      ui_out_field_int (uiout, "task", b->task);
    }
}

/* Cause the appropriate error if no appropriate runtime symbol is
   found to set a breakpoint, using ERR_DESC to describe the
   breakpoint.  */

static void
error_breakpoint_runtime_sym_not_found (const char *err_desc)
{
  /* If we are not debugging an Ada program, we can not put exception
     breakpoints!  */

  if (ada_update_initial_language (language_unknown, NULL) != language_ada)
    error ("Unable to break on %s.  Is this an Ada main program?", err_desc);

  /* If the symbol does not exist, then check that the program is
     already started, to make sure that shared libraries have been
     loaded.  If it is not started, this may mean that the symbol is
     in a shared library.  */

  if (ptid_get_pid (inferior_ptid) == 0)
    error ("Unable to break on %s. Try to start the program first.",
           err_desc);

  /* At this point, we know that we are debugging an Ada program and
     that the inferior has been started, but we still are not able to
     find the run-time symbols. That can mean that we are in
     configurable run time mode, or that a-except as been optimized
     out by the linker...  In any case, at this point it is not worth
     supporting this feature.  */

  error ("Cannot break on %s in this configuration.", err_desc);
}

/* Test if NAME is currently defined, and that either ALLOW_TRAMP or
   the symbol is not a shared-library trampoline.  Return the result of
   the test.  */

static int
is_runtime_sym_defined (const char *name, int allow_tramp)
{
  struct minimal_symbol *msym;

  msym = lookup_minimal_symbol (name, NULL, NULL);
  return (msym != NULL && msym->type != mst_unknown
          && (allow_tramp || msym->type != mst_solib_trampoline));
}

/* If ARG points to an Ada exception or assert breakpoint, rewrite
   into equivalent form.  Return resulting argument string.  Set
   *BREAK_ON_EXCEPTIONP to 1 for ordinary break on exception, 2 for
   break on unhandled, 3 for assert, 0 otherwise.  */

char *
ada_breakpoint_rewrite (char *arg, int *break_on_exceptionp)
{
  if (arg == NULL)
    return arg;
  *break_on_exceptionp = 0;
  if (current_language->la_language == language_ada
      && strncmp (arg, "exception", 9) == 0
      && (arg[9] == ' ' || arg[9] == '\t' || arg[9] == '\0'))
    {
      char *tok, *end_tok;
      int toklen;
      int has_exception_propagation =
        is_runtime_sym_defined (raise_sym_name, 1);

      *break_on_exceptionp = 1;

      tok = arg + 9;
      while (*tok == ' ' || *tok == '\t')
        tok += 1;

      end_tok = tok;

      while (*end_tok != ' ' && *end_tok != '\t' && *end_tok != '\000')
        end_tok += 1;

      toklen = end_tok - tok;

      arg = (char *) xmalloc (sizeof (longest_exception_template) + toklen);
      make_cleanup (xfree, arg);
      if (toklen == 0)
        {
          if (has_exception_propagation)
            sprintf (arg, "'%s'", raise_sym_name);
          else
            error_breakpoint_runtime_sym_not_found ("exception");
        }
      else if (strncmp (tok, "unhandled", toklen) == 0)
        {
          if (is_runtime_sym_defined (raise_unhandled_sym_name, 1))
            sprintf (arg, "'%s'", raise_unhandled_sym_name);
          else
            error_breakpoint_runtime_sym_not_found ("exception");

          *break_on_exceptionp = 2;
        }
      else
        {
          if (is_runtime_sym_defined (raise_sym_name, 0))
            sprintf (arg, "'%s' if long_integer(e) = long_integer(&%.*s)",
                     raise_sym_name, toklen, tok);
          else
            error_breakpoint_runtime_sym_not_found ("specific exception");
        }
    }
  else if (current_language->la_language == language_ada
           && strncmp (arg, "assert", 6) == 0
           && (arg[6] == ' ' || arg[6] == '\t' || arg[6] == '\0'))
    {
      char *tok = arg + 6;

      if (!is_runtime_sym_defined (raise_assert_sym_name, 1))
        error_breakpoint_runtime_sym_not_found ("failed assertion");

      *break_on_exceptionp = 3;

      arg =
        (char *) xmalloc (sizeof (raise_assert_sym_name) + strlen (tok) + 2);
      make_cleanup (xfree, arg);
      sprintf (arg, "'%s'%s", raise_assert_sym_name, tok);
    }
  return arg;
}
#endif /* GNAT_GDB */

                                /* Field Access */

/* True if field number FIELD_NUM in struct or union type TYPE is supposed
   to be invisible to users.  */

int
ada_is_ignored_field (struct type *type, int field_num)
{
  if (field_num < 0 || field_num > TYPE_NFIELDS (type))
    return 1;
  else
    {
      const char *name = TYPE_FIELD_NAME (type, field_num);
      return (name == NULL
              || (name[0] == '_' && strncmp (name, "_parent", 7) != 0));
    }
}

/* True iff TYPE has a tag field.  If REFOK, then TYPE may also be a
   pointer or reference type whose ultimate target has a tag field. */

int
ada_is_tagged_type (struct type *type, int refok)
{
  return (ada_lookup_struct_elt_type (type, "_tag", refok, 1, NULL) != NULL);
}

/* True iff TYPE represents the type of X'Tag */

int
ada_is_tag_type (struct type *type)
{
  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_PTR)
    return 0;
  else
    {
      const char *name = ada_type_name (TYPE_TARGET_TYPE (type));
      return (name != NULL
              && strcmp (name, "ada__tags__dispatch_table") == 0);
    }
}

/* The type of the tag on VAL.  */

struct type *
ada_tag_type (struct value *val)
{
  return ada_lookup_struct_elt_type (VALUE_TYPE (val), "_tag", 1, 0, NULL);
}

/* The value of the tag on VAL.  */

struct value *
ada_value_tag (struct value *val)
{
  return ada_value_struct_elt (val, "_tag", "record");
}

/* The value of the tag on the object of type TYPE whose contents are
   saved at VALADDR, if it is non-null, or is at memory address
   ADDRESS. */

static struct value *
value_tag_from_contents_and_address (struct type *type, char *valaddr,
                                     CORE_ADDR address)
{
  int tag_byte_offset, dummy1, dummy2;
  struct type *tag_type;
  if (find_struct_field ("_tag", type, 0, &tag_type, &tag_byte_offset,
                         &dummy1, &dummy2))
    {
      char *valaddr1 = (valaddr == NULL) ? NULL : valaddr + tag_byte_offset;
      CORE_ADDR address1 = (address == 0) ? 0 : address + tag_byte_offset;

      return value_from_contents_and_address (tag_type, valaddr1, address1);
    }
  return NULL;
}

static struct type *
type_from_tag (struct value *tag)
{
  const char *type_name = ada_tag_name (tag);
  if (type_name != NULL)
    return ada_find_any_type (ada_encode (type_name));
  return NULL;
}

struct tag_args
{
  struct value *tag;
  char *name;
};

/* Wrapper function used by ada_tag_name.  Given a struct tag_args*
   value ARGS, sets ARGS->name to the tag name of ARGS->tag.  
   The value stored in ARGS->name is valid until the next call to 
   ada_tag_name_1.  */

static int
ada_tag_name_1 (void *args0)
{
  struct tag_args *args = (struct tag_args *) args0;
  static char name[1024];
  char *p;
  struct value *val;
  args->name = NULL;
  val = ada_value_struct_elt (args->tag, "tsd", NULL);
  if (val == NULL)
    return 0;
  val = ada_value_struct_elt (val, "expanded_name", NULL);
  if (val == NULL)
    return 0;
  read_memory_string (value_as_address (val), name, sizeof (name) - 1);
  for (p = name; *p != '\0'; p += 1)
    if (isalpha (*p))
      *p = tolower (*p);
  args->name = name;
  return 0;
}

/* The type name of the dynamic type denoted by the 'tag value TAG, as
 * a C string.  */

const char *
ada_tag_name (struct value *tag)
{
  struct tag_args args;
a6552 18
/* If the PC is pointing inside a function prologue, then re-adjust it
   past this prologue.  */

static void
adjust_pc_past_prologue (CORE_ADDR *pc)
{
  struct symbol *func_sym = find_pc_function (*pc);

  if (func_sym)
    {
      const struct symtab_and_line sal =
        find_function_start_sal (func_sym, 1);

      if (*pc <= sal.pc)
        *pc = sal.pc;
    }
}

d7327 1
a8609 4
#ifdef GNAT_GDB
  ada_lookup_symbol,
  ada_lookup_minimal_symbol,
#endif /* GNAT_GDB */
a8633 4
#ifdef GNAT_GDB
  ada_translate_error_message,  /* Substitute Ada-specific terminology
                                   in errors and warnings.  */
#endif /* GNAT_GDB */
a8642 8
#ifdef GNAT_GDB
  add_setshow_uinteger_cmd ("varsize-limit", class_support,
			    &varsize_limit, "\
Set the maximum number of bytes allowed in a dynamic-sized object.", "\
Show the maximum number of bytes allowed in a dynamic-sized object.",
			    NULL, NULL, &setlist, &showlist);
  obstack_init (&cache_space);
#endif /* GNAT_GDB */
@


1.53
log
@Minor formatting changes:

(ada_main_name, ada_value_slice_ptr, ada_value_slice,
ada_breakpoint_rewrite, ada_template_to_fixed_record_type_1):
Minor formatting changes.
(empty_array): Slight rewrite for formatting.
(emit_char,parse,ada_language_defn,build_ada_types,
ada_is_exception_sym, _initialize_ada_language): Move
definitions around.
(ada_dump_symtab): Remove unused definition.
(ada_maybe_exception_partial_symbol): Remove unused definition.
@
text
@a194 2
static struct type *ada_create_fundamental_type (struct objfile *, int);

d282 5
d2446 1
a2446 1
      value_from_longest (builtin_type_ada_int,
d8349 1
a8349 1
  return value_from_longest (builtin_type_ada_int, pos_atr (arg));
d9326 1
a9326 1
        return value_zero (builtin_type_ada_int, not_lval);
d9335 1
a9335 1
        return value_zero (builtin_type_ada_int, not_lval);
d9337 1
a9337 1
        return value_from_longest (builtin_type_ada_int,
d10173 3
a10175 1
      type = init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT, 0, "integer", objfile);        /* FIXME -fnf */
d10231 15
a10245 40
struct type *builtin_type_ada_int;
struct type *builtin_type_ada_short;
struct type *builtin_type_ada_long;
struct type *builtin_type_ada_long_long;
struct type *builtin_type_ada_char;
struct type *builtin_type_ada_float;
struct type *builtin_type_ada_double;
struct type *builtin_type_ada_long_double;
struct type *builtin_type_ada_natural;
struct type *builtin_type_ada_positive;
struct type *builtin_type_ada_system_address;

struct type **const (ada_builtin_types[]) =
{
  &builtin_type_ada_int,
    &builtin_type_ada_long,
    &builtin_type_ada_short,
    &builtin_type_ada_char,
    &builtin_type_ada_float,
    &builtin_type_ada_double,
    &builtin_type_ada_long_long,
    &builtin_type_ada_long_double,
    &builtin_type_ada_natural, &builtin_type_ada_positive,
    /* The following types are carried over from C for convenience.  */
&builtin_type_int,
    &builtin_type_long,
    &builtin_type_short,
    &builtin_type_char,
    &builtin_type_float,
    &builtin_type_double,
    &builtin_type_long_long,
    &builtin_type_void,
    &builtin_type_signed_char,
    &builtin_type_unsigned_char,
    &builtin_type_unsigned_short,
    &builtin_type_unsigned_int,
    &builtin_type_unsigned_long,
    &builtin_type_unsigned_long_long,
    &builtin_type_long_double,
    &builtin_type_complex, &builtin_type_double_complex, 0};
d10248 2
a10249 1
build_ada_types (struct gdbarch *current_gdbarch)
d10251 5
a10255 1
  builtin_type_ada_int =
d10258 1
a10258 1
  builtin_type_ada_long =
d10261 1
a10261 1
  builtin_type_ada_short =
d10264 1
a10264 1
  builtin_type_ada_char =
d10267 2
a10268 1
  builtin_type_ada_float =
d10271 1
a10271 1
  builtin_type_ada_double =
d10274 1
a10274 1
  builtin_type_ada_long_long =
d10277 1
a10277 1
  builtin_type_ada_long_double =
d10280 1
a10280 1
  builtin_type_ada_natural =
d10283 1
a10283 1
  builtin_type_ada_positive =
d10286 1
d10288 1
a10288 2

  builtin_type_ada_system_address =
d10291 2
a10292 1
  TYPE_NAME (builtin_type_ada_system_address) = "system__address";
a10293 1

d10323 1
a10323 1
  ada_builtin_types,
d10353 1
a10353 1
  &builtin_type_ada_char,
d10355 1
a10365 3

  build_ada_types (current_gdbarch);
  gdbarch_data_register_post_init (build_ada_types);
@


1.52
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d756 1
d2200 1
a2200 1
ada_value_slice_ptr (struct value *array_ptr, struct type *type, 
d2203 1
a2203 1
  CORE_ADDR base = value_as_address (array_ptr) 
d2206 2
a2207 2
  struct type *index_type = 
    create_range_type (NULL, TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (type)), 
d2209 1
a2209 1
  struct type *slice_type = 
d2219 1
a2219 1
  struct type *index_type = 
d2221 1
a2221 1
  struct type *slice_type = 
d2223 1
a2223 1
  return value_cast (slice_type, value_slice (array, low, high-low+1));
d2456 1
a2456 1
  struct type *index_type = 
d6183 14
a6447 19
int
ada_is_exception_sym (struct symbol *sym)
{
  char *type_name = type_name_no_tag (SYMBOL_TYPE (sym));

  return (SYMBOL_CLASS (sym) != LOC_TYPEDEF
          && SYMBOL_CLASS (sym) != LOC_BLOCK
          && SYMBOL_CLASS (sym) != LOC_CONST
          && type_name != NULL && strcmp (type_name, "exception") == 0);
}

int
ada_maybe_exception_partial_symbol (struct partial_symbol *sym)
{
  return (SYMBOL_CLASS (sym) != LOC_TYPEDEF
          && SYMBOL_CLASS (sym) != LOC_BLOCK
          && SYMBOL_CLASS (sym) != LOC_CONST);
}

d6572 1
a6572 1
#endif
d7719 2
a7720 3
      off =
        align_value (off,
                     field_alignment (type, f)) + TYPE_FIELD_BITPOS (type, f);
d9064 1
a9064 1
            && ada_is_array_descriptor_type (check_typedef 
d9081 2
a9082 1
                                            (int) low_bound, (int) high_bound);
d10087 1
a10087 173
                        /* Assorted Types and Interfaces */

struct type *builtin_type_ada_int;
struct type *builtin_type_ada_short;
struct type *builtin_type_ada_long;
struct type *builtin_type_ada_long_long;
struct type *builtin_type_ada_char;
struct type *builtin_type_ada_float;
struct type *builtin_type_ada_double;
struct type *builtin_type_ada_long_double;
struct type *builtin_type_ada_natural;
struct type *builtin_type_ada_positive;
struct type *builtin_type_ada_system_address;

struct type **const (ada_builtin_types[]) =
{
  &builtin_type_ada_int,
    &builtin_type_ada_long,
    &builtin_type_ada_short,
    &builtin_type_ada_char,
    &builtin_type_ada_float,
    &builtin_type_ada_double,
    &builtin_type_ada_long_long,
    &builtin_type_ada_long_double,
    &builtin_type_ada_natural, &builtin_type_ada_positive,
    /* The following types are carried over from C for convenience.  */
&builtin_type_int,
    &builtin_type_long,
    &builtin_type_short,
    &builtin_type_char,
    &builtin_type_float,
    &builtin_type_double,
    &builtin_type_long_long,
    &builtin_type_void,
    &builtin_type_signed_char,
    &builtin_type_unsigned_char,
    &builtin_type_unsigned_short,
    &builtin_type_unsigned_int,
    &builtin_type_unsigned_long,
    &builtin_type_unsigned_long_long,
    &builtin_type_long_double,
    &builtin_type_complex, &builtin_type_double_complex, 0};

/* Not really used, but needed in the ada_language_defn.  */

static void
emit_char (int c, struct ui_file *stream, int quoter)
{
  ada_emit_char (c, stream, quoter, 1);
}

static int
parse (void)
{
  warnings_issued = 0;
  return ada_parse ();
}

static const struct exp_descriptor ada_exp_descriptor = {
  ada_print_subexp,
  ada_operator_length,
  ada_op_name,
  ada_dump_subexp_body,
  ada_evaluate_subexp
};

const struct language_defn ada_language_defn = {
  "ada",                        /* Language name */
  language_ada,
  ada_builtin_types,
  range_check_off,
  type_check_off,
  case_sensitive_on,            /* Yes, Ada is case-insensitive, but
                                   that's not quite what this means.  */
#ifdef GNAT_GDB
  ada_lookup_symbol,
  ada_lookup_minimal_symbol,
#endif /* GNAT_GDB */
  array_row_major,
  &ada_exp_descriptor,
  parse,
  ada_error,
  resolve,
  ada_printchar,                /* Print a character constant */
  ada_printstr,                 /* Function to print string constant */
  emit_char,                    /* Function to print single char (not used) */
  ada_create_fundamental_type,  /* Create fundamental type in this language */
  ada_print_type,               /* Print a type using appropriate syntax */
  ada_val_print,                /* Print a value using appropriate syntax */
  ada_value_print,              /* Print a top-level value */
  NULL,                         /* Language specific skip_trampoline */
  NULL,                         /* value_of_this */
  ada_lookup_symbol_nonlocal,   /* Looking up non-local symbols.  */
  basic_lookup_transparent_type,        /* lookup_transparent_type */
  ada_la_decode,                /* Language specific symbol demangler */
  NULL,                         /* Language specific class_name_from_physname */
  ada_op_print_tab,             /* expression operators for printing */
  0,                            /* c-style arrays */
  1,                            /* String lower bound */
  &builtin_type_ada_char,
  ada_get_gdb_completer_word_break_characters,
#ifdef GNAT_GDB
  ada_translate_error_message,  /* Substitute Ada-specific terminology
                                   in errors and warnings.  */
#endif /* GNAT_GDB */
  LANG_MAGIC
};

static void
build_ada_types (struct gdbarch *current_gdbarch)
{
  builtin_type_ada_int =
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
               0, "integer", (struct objfile *) NULL);
  builtin_type_ada_long =
    init_type (TYPE_CODE_INT, TARGET_LONG_BIT / TARGET_CHAR_BIT,
               0, "long_integer", (struct objfile *) NULL);
  builtin_type_ada_short =
    init_type (TYPE_CODE_INT, TARGET_SHORT_BIT / TARGET_CHAR_BIT,
               0, "short_integer", (struct objfile *) NULL);
  builtin_type_ada_char =
    init_type (TYPE_CODE_INT, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
               0, "character", (struct objfile *) NULL);
  builtin_type_ada_float =
    init_type (TYPE_CODE_FLT, TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
               0, "float", (struct objfile *) NULL);
  builtin_type_ada_double =
    init_type (TYPE_CODE_FLT, TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
               0, "long_float", (struct objfile *) NULL);
  builtin_type_ada_long_long =
    init_type (TYPE_CODE_INT, TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
               0, "long_long_integer", (struct objfile *) NULL);
  builtin_type_ada_long_double =
    init_type (TYPE_CODE_FLT, TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
               0, "long_long_float", (struct objfile *) NULL);
  builtin_type_ada_natural =
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
               0, "natural", (struct objfile *) NULL);
  builtin_type_ada_positive =
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
               0, "positive", (struct objfile *) NULL);


  builtin_type_ada_system_address =
    lookup_pointer_type (init_type (TYPE_CODE_VOID, 1, 0, "void",
                                    (struct objfile *) NULL));
  TYPE_NAME (builtin_type_ada_system_address) = "system__address";
}

void
_initialize_ada_language (void)
{

  build_ada_types (current_gdbarch);
  gdbarch_data_register_post_init (build_ada_types);
  add_language (&ada_language_defn);

  varsize_limit = 65536;
#ifdef GNAT_GDB
  add_setshow_uinteger_cmd ("varsize-limit", class_support,
			    &varsize_limit, "\
Set the maximum number of bytes allowed in a dynamic-sized object.", "\
Show the maximum number of bytes allowed in a dynamic-sized object.",
			    NULL, NULL, &setlist, &showlist);
  obstack_init (&cache_space);
#endif /* GNAT_GDB */

  obstack_init (&symbol_list_obstack);

  decoded_names_store = htab_create_alloc
    (256, htab_hash_string, (int (*)(const void *, const void *)) streq,
     NULL, xcalloc, xfree);
}
d10226 150
d10377 1
a10377 1
ada_dump_symtab (struct symtab *s)
d10379 20
a10398 15
  int i;
  fprintf (stderr, "New symtab: [\n");
  fprintf (stderr, "  Name: %s/%s;\n",
           s->dirname ? s->dirname : "?", s->filename ? s->filename : "?");
  fprintf (stderr, "  Format: %s;\n", s->debugformat);
  if (s->linetable != NULL)
    {
      fprintf (stderr, "  Line table (section %d):\n", s->block_line_section);
      for (i = 0; i < s->linetable->nitems; i += 1)
        {
          struct linetable_entry *e = s->linetable->item + i;
          fprintf (stderr, "    %4ld: %8lx\n", (long) e->line, (long) e->pc);
        }
    }
  fprintf (stderr, "]\n");
@


1.51
log
@2004-08-29  David Lecomber  <david@@streamline-computing.com>

	Fix PR gdb/648
	* language.h (enum array_ordering): New enum.
	* language.h (struct language_defn): New la_array_ordering
	attribute.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Ditto.
	* ada-lang.c (ada_language_defn): Ditto.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Ditto.
	* f-lang.c (f_language_defn): Ditto.
	* jv-lang.c (java_language_defn): Ditto.
	* m2-lang.c (f_language_defn): Ditto.
	* objc-lang.c (objc_language_defn): Ditto.
	* p-lang.c (pascal_language_defn): Ditto.
	* scm-lang.c (scm_language_defn): Ditto.
	* eval.c (evaluate_subexp_standard): Assume Fortran arrays are
	oriented large to small in type structure.
	* dwarf2read.c (read_array_order): New function.
	(read_array_type): Use read_array_order to check row/column
	major ordering.
@
text
@a10186 5
  {"", "", "", ""},             /* Binary format info */
  /* Copied from c-lang.c.  */
  {"0%lo", "0", "o", ""},       /* Octal format info */
  {"%ld", "", "d", ""},         /* Decimal format info */
  {"0x%lx", "0x", "x", ""},     /* Hex format info */
@


1.50
log
@2004-08-10  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (xmcalloc): Delete declaration.
	* utils.c (xmcalloc): Delete.
	(xcalloc): Inline calls to xmcalloc and mcalloc.
	* ada-lang.c (_initialize_ada_language): Use htab_create_alloc,
	xcalloc and xfree.
	* symtab.c (create_demangled_names_hash): Ditto.
@
text
@d10169 1
@


1.49
log
@	* ada-lang.c (ada_language_defn): Remove commented out code.
@
text
@d10264 1
a10264 1
  decoded_names_store = htab_create_alloc_ex
d10266 1
a10266 1
     NULL, NULL, xmcalloc, xmfree);
@


1.48
log
@Remove ARI problems:

* ada-exp.y (write_var_from_sym): Reformat to put operator at
beginning of line.

* ada-lang.c (MAX_OF_SIZE): Rename max_of_size.
Add comment.
Add comment concerning MAX_OF_TYPE and MIN_OF_TYPE.
(MIN_OF_SIZE): Rename min_of_size.  Add comment.
(UMAX_OF_SIZE): Renmae umax_of_size.  Add comment.
(UMIN_OF_SIZE): Remove.
(max_of_type): New function to replace orphan macro in gdbtypes.h
(min_of_type): Ditto.
(discrete_type_high_bound): Use max_of_type.
(discrete_type_low_bound): Use min_of_type.
(possible_user_operator_p): Move operator to beginning of line.
(ada_is_variant_part): Ditto.
(ensure_lval): Rewrite to avoid deprecated operations.
(ada_finish_decode_line_1): Use gdbarch_convert_from_func_ptr_addr
rather than adding DEPRECATED_FUNCTION_START_OFFSET.
(ada_enum_name): Remove assignments in 'if' statements.
(build_ada_types): Add gdbarch parameter.
(_initialize_ada_language): Replace deprecated_register_gdbarch_swap
with gdbarch_data_register_post_init.
Use add_setshow_uinteger_cmd rather than add_set_cmd and
add_show_from_set.

* ada-valprint.c (inspect_it): Remove declaration.
(repeat_count_threshold): Remove declaration.
(ada_print_floating): Remove assignments in 'if' statements.
(print_str): Move operator to beginning of line.
@
text
@a10186 5
#if 0
  {"8#%lo#", "8#", "o", "#"},   /* Octal format info */
  {"%ld", "", "d", ""},         /* Decimal format info */
  {"16#%lx#", "16#", "x", "#"}, /* Hex format info */
#else
a10190 1
#endif
@


1.47
log
@
2004-07-06  Jeff Johnston <jjohnstn@@redhat.com>

        * language.h (struct_language_defn): Add new function pointer:
        la_class_name_from_physname.  Also add new prototype for
        language_class_name_from_physname.
        * language.c (language_class_name_from_physname): New function.
        (unk_lang_class_name): Ditto.
        (unknown_language_defn, auto_language_defn): Change
        to add unk_lang_class_name function pointer for
        la_class_name_from_physname.
        (local_language_defn): Ditto.
        * dwarf2read.c (guess_structure_name): Change to call
        language_class_name_from_physname.
        (determine_class_name): Ditto.
        * cp-support.c (class_name_from_physname): Renamed.
        (cp_class_name_from_physname): New name of function.
        * cp-support.h: Ditto.
        * c-lang.c (c_language_defn): Change to add NULL
        for class_name_from_physname function pointer.
        (cplus_language_defn): Change to add cp_class_name_from_physname.
        * jv-lang.c (java_class_name_physname): New function.
        (java_find_last_component): New static routine.
        (java_language_defn): Add java_class_name_from_physname pointer.
        * ada-lang.c (ada_language_defn): Change to add NULL
        for class_name_from_physname function pointer.
        * f-lang.c (f_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * scm-lang.c (scm_language_defn): Ditto.
@
text
@d626 5
d632 1
a632 1
MAX_OF_SIZE (int size)
d638 1
d640 1
a640 1
MIN_OF_SIZE (int size)
d642 1
a642 1
  return -MAX_OF_SIZE (size) - 1;
d645 1
d647 1
a647 1
UMAX_OF_SIZE (int size)
d653 13
a665 2
static ULONGEST
UMIN_OF_SIZE (int size)
d667 4
a670 1
  return 0;
d688 1
a688 1
      return value_from_longest (type, MAX_OF_TYPE (type));
d706 1
a706 1
      return value_from_longest (type, MIN_OF_TYPE (type));
d3468 2
a3469 2
                 || (TYPE_CODE (TYPE_TARGET_TYPE (type1)) !=
                     TYPE_CODE_ARRAY))));
d3559 3
a3561 1
  CORE_ADDR old_sp = *sp;
d3563 23
a3585 2
  if (VALUE_LVAL (val))
    return val;
d3587 2
a3588 13
  if (DEPRECATED_STACK_ALIGN_P ())
    *sp = push_bytes (*sp, VALUE_CONTENTS_RAW (val),
                      DEPRECATED_STACK_ALIGN
                      (TYPE_LENGTH (check_typedef (VALUE_TYPE (val)))));
  else
    *sp = push_bytes (*sp, VALUE_CONTENTS_RAW (val),
                      TYPE_LENGTH (check_typedef (VALUE_TYPE (val))));

  VALUE_LVAL (val) = lval_memory;
  if (INNER_THAN (1, 2))
    VALUE_ADDRESS (val) = *sp;
  else
    VALUE_ADDRESS (val) = old_sp;
d5656 3
a5658 1
              val.pc += DEPRECATED_FUNCTION_START_OFFSET;
d6773 2
a6774 2
              && TYPE_CODE (TYPE_TARGET_TYPE (field_type)) ==
              TYPE_CODE_UNION));
d8502 2
a8503 1
  if ((tmp = strrchr (name, '.')) != NULL)
d8539 4
a8542 2
      if ((tmp = strstr (name, "__")) != NULL
          || (tmp = strstr (name, "$")) != NULL)
d10210 1
a10210 1
build_ada_types (void)
d10254 2
a10255 2
  build_ada_types ();
  deprecated_register_gdbarch_swap (NULL, 0, build_ada_types);
d10260 5
a10264 5
  add_show_from_set
    (add_set_cmd ("varsize-limit", class_support, var_uinteger,
                  (char *) &varsize_limit,
                  "Set maximum bytes in dynamic-sized object.",
                  &setlist), &showlist);
@


1.46
log
@* ada-lang.c (decode_packed_array): Minor change to comment.
(ada_value_slice_ptr): New function.
(ada_value_slice): New function.
(ada_evaluate_subexp): Remove XVS-suffix code from subscripting
test.  Don't know why it is there.
Change slice code to use ada_value_slice_ptr and ada_value_slice, and
to avoid dereferencing huge arrays from which one is slicing.
(empty_array): Correct to return an array rather than
a subrange value.
* ada-valprint.c (print_optional_low_bound): Don't print lower bound
on empty arrays (let'em use 'FIRST instead).
@
text
@d10147 1
@


1.45
log
@Address complaints from gdb_ari.sh:

* ada-exp.y: Include gdb_string.h rather than string.h.
(convert_char_literal): Reformat declaration.
* ada-lang.h: Include opaque struct declaration for struct frame_info.
* ada-lex.l: Change use of free to xfree (the macro would do so
anyway, but this is harmless).
Include gdb_string.h rather than string.h.
* ada-valprint.c (ada_val_print_stub): Change PTR => void*.

* ada-lang.c (parse): Remove K&Rism in parameter list.
(is_name_suffix): Correct Linux => GNU/Linux in comment.
@
text
@d2173 31
d2434 5
a2438 2
  return allocate_value (create_range_type (NULL, TYPE_INDEX_TYPE (arr_type),
                                            low, low - 1));
a8958 5
            /* Make sure to use the parallel ___XVS type if any.
               Otherwise, we won't be able to find the array arity
               and element type.  */
            type = ada_get_base_type (type);

a9012 8
        /* If this is a reference type or a pointer type, and
           the target type has an XVS parallel type, then get
           the real target type.  */
        if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_REF
            || TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_PTR)
          TYPE_TARGET_TYPE (VALUE_TYPE (array)) =
            ada_get_base_type (TYPE_TARGET_TYPE (VALUE_TYPE (array)));

d9031 3
a9033 9
            && ada_is_array_descriptor_type
            (check_typedef (VALUE_TYPE (array))))
          {
            /* Try dereferencing the array, in case it is an access
               to array.  */
            struct type *arrType = ada_type_of_array (array, 0);
            if (arrType != NULL)
              array = value_at_lazy (arrType, 0, NULL);
          }
a9036 3
        /* When EVAL_AVOID_SIDE_EFFECTS, we may get the bounds wrong,
           but only in contexts where the value is not being requested
           (FIXME?).  */
d9039 1
a9039 3
            if (noside == EVAL_AVOID_SIDE_EFFECTS)
              return ada_value_ind (array);
            else if (high_bound < low_bound)
d9047 2
a9048 9
                struct value *item0 =
                  ada_value_ptr_subscript (array, arr_type0, 1,
                                           &low_bound_val);
                struct value *slice =
                  value_repeat (item0, high_bound - low_bound + 1);
                struct type *arr_type1 = VALUE_TYPE (slice);
                TYPE_LOW_BOUND (TYPE_INDEX_TYPE (arr_type1)) = low_bound;
                TYPE_HIGH_BOUND (TYPE_INDEX_TYPE (arr_type1)) += low_bound;
                return slice;
d9056 1
a9056 1
          return value_slice (array, low_bound, high_bound - low_bound + 1);
@


1.44
log
@2004-06-26  Andrew Cagney  <cagney@@gnu.org>

	* xcoffsolib.c (xcoff_solib_address): Replace xasprintf with
	xstrprintf.
	* varobj.c (varobj_gen_name, create_child, c_name_of_child)
	(c_value_of_variable): Ditto.
	* utils.c (internal_vproblem): Ditto.
	* solib-aix5.c (build_so_list_from_mapfile): Ditto.
	* remote.c (add_packet_config_cmd): Ditto.
	* remote-rdp.c (rdp_set_command_line): Ditto.
	* regcache.c (regcache_dump): Ditto.
	* frv-tdep.c (new_variant, new_variant): Ditto.
	* fbsd-proc.c (child_pid_to_exec_file): Ditto.
	(fbsd_find_memory_regions): Ditto.
	* breakpoint.c (create_thread_event_breakpoint)
	(create_breakpoints): Ditto.
	* aix-thread.c (aix_thread_pid_to_str): Ditto.
	* ada-lang.c (is_package_name): Ditto.  Also delete xmalloc call.

Index: doc/ChangeLog
2004-06-26  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Coding): Replace xasprintf with xstrprintf.
@
text
@d2599 3
a2601 3
      (*pos) += 3
        + BYTES_TO_EXP_ELEM (longest_to_int (exp->elts[pc + 1].longconst) +
                             1);
d4758 2
a4759 1
   (__[0-9]+)?\.[0-9]+  [nested subprogram suffix, on platforms such as Linux]
d10102 1
a10102 1
parse ()
@


1.43
log
@        * ada-lang.c: Re-indent file, with some massaging to help indent
        a bit when the result is otherwise really too ugly.
@
text
@d4372 1
a4372 2
  fun_name = (char *) alloca (strlen (name) + 5 + 1);
  xasprintf (&fun_name, "_ada_%s", name);
@


1.42
log
@        * ada-lang.c: Minor reformatting to conform to GNU coding standards.
@
text
@d996 3
a998 2
              if (strncmp (ada_opname_table[k].encoded + 1, encoded + i + 1,
                           op_len - 1) == 0 && !isalnum (encoded[i + op_len]))
d2692 4
a2695 5
              i = ada_resolve_function (candidates, n_candidates, NULL, 0,
                                        SYMBOL_LINKAGE_NAME (exp->
                                                             elts[pc +
                                                                  2].symbol),
                                        context_type);
d2743 5
a2747 7
                i = ada_resolve_function (candidates, n_candidates,
                                          argvec, nargs,
                                          SYMBOL_LINKAGE_NAME (exp->
                                                               elts[pc +
                                                                    5].
                                                               symbol),
                                          context_type);
d3098 3
a3100 3
                             sal.symtab ==
                             NULL ? "<no source file available>" : sal.
                             symtab->filename, sal.line);
d6995 4
a6998 7
          struct value *v = ada_search_struct_field (name, arg,
                                                     offset +
                                                     TYPE_FIELD_BITPOS (type,
                                                                        i) /
                                                     8,
                                                     TYPE_FIELD_TYPE (type,
                                                                      i));
d7011 4
a7014 7
              struct value *v = ada_search_struct_field (name, arg,
                                                         var_offset
                                                         +
                                                         TYPE_FIELD_BITPOS
                                                         (field_type, j) / 8,
                                                         TYPE_FIELD_TYPE
                                                         (field_type, j));
@


1.41
log
@        * ada-lang.c: Re-indent file.
@
text
@d577 2
a578 2
      if (VALUE_LAZY (val) ||
          TYPE_LENGTH (type) > TYPE_LENGTH (VALUE_TYPE (val)))
d852 3
a854 3
               mapping->encoded != NULL &&
               strncmp (mapping->decoded, p,
                        strlen (mapping->decoded)) != 0; mapping += 1)
d1196 3
a1198 3
  if (type != NULL &&
      (TYPE_CODE (type) == TYPE_CODE_PTR
       || TYPE_CODE (type) == TYPE_CODE_REF))
d1512 1
a1512 2
        ||
        TYPE_CODE (data_type) == TYPE_CODE_ARRAY)
d1920 2
a1921 2
      if (has_negatives (type) &&
          ((bytes[0] << bit_offset) & (1 << (HOST_CHAR_BIT - 1))))
d2710 2
a2711 2
          if (innermost_block == NULL ||
              contained_in (candidates[i].block, innermost_block))
d2757 2
a2758 2
            if (innermost_block == NULL ||
                contained_in (candidates[i].block, innermost_block))
d2843 2
a2844 2
        return (may_deref &&
                ada_type_match (TYPE_TARGET_TYPE (ftype), atype, 0));
d2887 2
a2888 2
  if (SYMBOL_CLASS (func) == LOC_CONST &&
      TYPE_CODE (func_type) == TYPE_CODE_ENUM)
d3409 8
a3416 7
      return ((TYPE_CODE (type0) != TYPE_CODE_ARRAY &&
               (TYPE_CODE (type0) != TYPE_CODE_PTR ||
                TYPE_CODE (TYPE_TARGET_TYPE (type0))
                != TYPE_CODE_ARRAY))
              || (TYPE_CODE (type1) != TYPE_CODE_ARRAY &&
                  (TYPE_CODE (type1) != TYPE_CODE_PTR ||
                   TYPE_CODE (TYPE_TARGET_TYPE (type1)) != TYPE_CODE_ARRAY)));
d3945 2
a3946 2
          if (SYMBOL_DOMAIN (psym) == namespace &&
              wild_match (name, name_len, SYMBOL_LINKAGE_NAME (psym)))
d4830 2
a4831 2
          if (str[4] == 'F' || str[4] == 'D' || str[4] == 'B' ||
              str[4] == 'U' || str[4] == 'P')
d4999 2
a5000 2
        if (SYMBOL_DOMAIN (sym) == domain &&
            wild_match (name, name_len, SYMBOL_LINKAGE_NAME (sym)))
d5510 2
a5511 2
      while (**spec != '\000' &&
             !strchr (ada_completer_word_break_characters, **spec))
d5601 2
a5602 2
      if (!have_full_symbols () &&
          !have_partial_symbols () && !have_minimal_symbols ())
d7177 2
a7178 2
      || (TYPE_CODE (type) != TYPE_CODE_STRUCT &&
          TYPE_CODE (type) != TYPE_CODE_UNION))
d9017 3
a9019 2
        if (noside == EVAL_AVOID_SIDE_EFFECTS &&
            ada_is_array_descriptor_type (check_typedef (VALUE_TYPE (array))))
@


1.40
log
@        * ada-lang.c (symtab_symbol_info): Remove unused declaration.
        (no_symtab_msg): Likewise.
@
text
@d86 3
a88 3
  char **array;  /* The vector itself.  */
  int index;     /* Index of the next available element in the array.  */
  size_t size;      /* The number of entries allocated in the array.  */
d145 1
a145 1
				   struct block *, const char *,
d147 1
a147 1
				   struct symtab *, int);
d151 2
a152 2
static void add_defn_to_vec (struct obstack *, struct symbol *, struct block *,
			     struct symtab *);
d159 2
a160 2
							 *, const char *, int,
							 domain_enum, int);
d165 1
a165 1
				     struct type *);
d185 1
a185 1
						int, int, int *);
d233 1
a233 1
static struct symtabs_and_lines 
d235 1
a235 1
			      struct ada_symbol_info *, int);
d237 2
a238 3
static int find_line_in_linetable (struct linetable *, int, 
				   struct ada_symbol_info *,
				   int, int *);
d263 2
a264 2
static int find_struct_field (char *, struct type *, int, 
			      struct type **, int *, int *, int *);
d283 2
a284 1
static int is_runtime_sym_defined  (const char *name, int allow_tramp);
a285 1

d300 1
a300 1
static const char ADA_MAIN_PROGRAM_SYMBOL_NAME[] 
d355 1
a355 1
  
d386 1
a386 1
    result++; /* Skip the dot...  */
d389 1
a389 1
    
d476 2
a477 1
             && strcmp (field_name + strlen (field_name) - 6, "___XVN") != 0)));
d627 1
a627 1
MAX_OF_SIZE (int size) 
d629 2
a630 2
  LONGEST top_bit = (LONGEST) 1 << (size*8-2);
  return top_bit | (top_bit-1);
d636 1
a636 1
  return - MAX_OF_SIZE (size) - 1;
d642 2
a643 2
  ULONGEST top_bit = (ULONGEST) 1 << (size*8-1);
  return top_bit | (top_bit-1);
d656 1
a656 1
  switch (TYPE_CODE (type)) 
d660 1
a660 1
				 TYPE_HIGH_BOUND (type));
d662 5
a666 4
      return 
	value_from_longest (type, 
			    TYPE_FIELD_BITPOS (type, TYPE_NFIELDS (type)-1));
    case TYPE_CODE_INT:	
d677 1
a677 1
  switch (TYPE_CODE (type)) 
d681 1
a681 1
				 TYPE_LOW_BOUND (type));
d683 2
a684 2
      return value_from_longest (type, TYPE_FIELD_BITPOS (type, 0)); 
    case TYPE_CODE_INT:	
d692 1
a692 1
   non-range scalar type.  */  
d699 2
a700 3
      if (type == TYPE_TARGET_TYPE (type) 
	  || TYPE_TARGET_TYPE (type) == NULL)	
	return type;
d705 1
a706 1

d854 1
a854 2
                        strlen (mapping->decoded)) != 0;
               mapping += 1)
d964 1
a964 1
      
d997 1
a997 2
                           op_len - 1) == 0
                  && !isalnum (encoded[i + op_len]))
d1074 1
a1074 1
*/ 
d1076 2
a1077 1
char *ada_decode_symbol (const struct general_symbol_info *gsymbol)
d1079 1
a1079 1
  char **resultp = 
d1085 16
a1100 16
	{
	  bfd *obfd = gsymbol->bfd_section->owner;
	  if (obfd != NULL)
	    {
	      struct objfile *objf;
	      ALL_OBJFILES (objf)
		{
		  if (obfd == objf->obfd)
		    {
		      *resultp = obsavestring (decoded, strlen (decoded), 
					       &objf->objfile_obstack);
		      break;
		    }
		}
	    }
	}
d1102 3
a1104 3
	 case, we put the result on the heap.  Since we only decode
	 when needed, we hope this usually does not cause a
	 significant memory leak (FIXME).  */
d1106 7
a1112 8
	{
	  char **slot = 
	    (char **) htab_find_slot (decoded_names_store, 
				     decoded, INSERT);
	  if (*slot == NULL) 
	    *slot = xstrdup (decoded);
	  *resultp = *slot;
	}
d1117 3
a1119 2
	
char *ada_la_decode (const char *encoded, int options)
d1260 1
a1260 1
  
d1432 1
a1432 1
  static int
d1474 2
a1475 2
static int 
ada_is_direct_array_type (struct type *type) 
d1481 1
a1481 1
	  || ada_is_array_descriptor_type (type));
d2268 3
a2270 4
	 perhaps stabsread.c would make more sense.  */
      if (result_type == NULL 
	  || TYPE_CODE (result_type) == TYPE_CODE_UNDEF)
	result_type = builtin_type_int;
d2455 1
a2455 1
		struct type *context_type)
d2473 2
a2474 2
	  && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)
	*pos += 7;
d2599 3
a2601 2
      (*pos) += 3 
	+ BYTES_TO_EXP_ELEM (longest_to_int (exp->elts[pc + 1].longconst) + 1);
d2619 1
a2619 2
  argvec =
    (struct value * *) alloca (sizeof (struct value *) * (nargs + 1));
d2633 92
a2724 91
	{
	  struct ada_symbol_info *candidates;
	  int n_candidates;

	  n_candidates =
	    ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME (exp->elts[pc + 2]
							 .symbol),
				    exp->elts[pc + 1].block,
				    VAR_DOMAIN, &candidates);

	  if (n_candidates > 1)
	    {
	      /* Types tend to get re-introduced locally, so if there
		 are any local symbols that are not types, first filter
		 out all types.  */
	      int j;
	      for (j = 0; j < n_candidates; j += 1)
		switch (SYMBOL_CLASS (candidates[j].sym))
		  {
		  case LOC_REGISTER:
		  case LOC_ARG:
		  case LOC_REF_ARG:
		  case LOC_REGPARM:
		  case LOC_REGPARM_ADDR:
		  case LOC_LOCAL:
		  case LOC_LOCAL_ARG:
		  case LOC_BASEREG:
		  case LOC_BASEREG_ARG:
		  case LOC_COMPUTED:
		  case LOC_COMPUTED_ARG:
		    goto FoundNonType;
		  default:
		    break;
		  }
	    FoundNonType:
	      if (j < n_candidates)
		{
		  j = 0;
		  while (j < n_candidates)
		    {
		      if (SYMBOL_CLASS (candidates[j].sym) == LOC_TYPEDEF)
			{
			  candidates[j] = candidates[n_candidates - 1];
			  n_candidates -= 1;
			}
		      else
			j += 1;
		    }
		}
	    }

	  if (n_candidates == 0)
	    error ("No definition found for %s",
		   SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
	  else if (n_candidates == 1)
	    i = 0;
	  else if (deprocedure_p
		   && !is_nonfunction (candidates, n_candidates))
	    {
	      i = ada_resolve_function (candidates, n_candidates, NULL, 0,
					SYMBOL_LINKAGE_NAME (exp->elts[pc + 2]
							     .symbol),
					context_type);
	      if (i < 0)
		error ("Could not find a match for %s",
		       SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
	    }
	  else
	    {
	      printf_filtered ("Multiple matches for %s\n",
			       SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
	      user_select_syms (candidates, n_candidates, 1);
	      i = 0;
	    }

	  exp->elts[pc + 1].block = candidates[i].block;
	  exp->elts[pc + 2].symbol = candidates[i].sym;
	  if (innermost_block == NULL ||
	      contained_in (candidates[i].block, innermost_block))
	    innermost_block = candidates[i].block;
	}

      if (deprocedure_p 
	  && (TYPE_CODE (SYMBOL_TYPE (exp->elts[pc + 2].symbol)) 
	      == TYPE_CODE_FUNC))
	{
	  replace_operator_with_call (expp, pc, 0, 0,
				      exp->elts[pc + 2].symbol,
				      exp->elts[pc + 1].block);
	  exp = *expp;
	}
d2730 1
a2730 1
	    && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)
d2736 4
a2739 4
	      ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME (exp->elts[pc + 5]
							   .symbol),
				      exp->elts[pc + 4].block,
				      VAR_DOMAIN, &candidates);
d2744 6
a2749 4
                i = ada_resolve_function (candidates, n_candidates, 
					  argvec, nargs,
                                          SYMBOL_LINKAGE_NAME (exp->elts[pc+5]
							       .symbol),
d2795 1
a2795 1
				    ada_decoded_op_name (op), NULL);
d2799 2
a2800 2
          replace_operator_with_call (expp, pc, nargs, 1, 
				      candidates[i].sym, candidates[i].block);
d2900 9
a2908 9
	return 0;
      else	
	{
	  struct type *ftype = check_typedef (TYPE_FIELD_TYPE (func_type, i));
	  struct type *atype = check_typedef (VALUE_TYPE (actuals[i]));

	  if (!ada_type_match (ftype, atype, 1))
	    return 0;
	}
d3097 3
a3099 3
          struct symtab_and_line sal = find_function_start_sal (syms[i].sym, 1);
          printf_unfiltered ("[%d] %s at %s:%d\n",
                             i + first_choice,
d3101 3
a3103 3
                             sal.symtab == NULL
                             ? "<no source file available>"
                             : sal.symtab->filename, sal.line);
d3119 2
a3120 1
          else if (is_enumeral && TYPE_NAME (SYMBOL_TYPE (syms[i].sym)) != NULL)
d3123 2
a3124 2
              ada_print_type (SYMBOL_TYPE (syms[i].sym), NULL, 
			      gdb_stdout, -1, 0);
d3191 1
a3191 1
  
d3375 1
a3375 1
  struct type *type0 = 
d3513 2
a3514 2
                      DEPRECATED_STACK_ALIGN 
		      (TYPE_LENGTH (check_typedef (VALUE_TYPE (val)))));
d3606 3
a3608 3
			VALUE_ADDRESS (ensure_lval (arr, sp)),
			fat_pntr_data_bitpos (desc_type),
			fat_pntr_data_bitsize (desc_type));
d3647 1
a3647 1
				/* Experimental Symbol Cache Module */
d3666 2
a3667 1
struct cache_entry {
d3698 1
a3698 1
	return e;
d3711 2
a3712 2
		      struct symbol **sym, struct block **block,
		      struct symtab **symtab)
d3731 1
a3731 1
	      struct block *block, struct symtab *symtab)
d3736 1
a3736 1
    (struct cache_entry *) obstack_alloc(&cache_space, sizeof (*e));
d3750 2
a3751 2
		      struct symbol **sym, struct block **block,
		      struct symtab **symtab)
d3758 1
a3758 1
	      struct block *block, struct symtab *symtab)
d3761 1
a3761 1
#endif   /* GNAT_GDB */
d3777 2
a3778 1
  sym = lookup_symbol_in_language (name, block, domain, language_c, 0, &symtab);
d3862 3
a3864 4
add_defn_to_vec (struct obstack *obstackp, 
		 struct symbol *sym, 
		 struct block *block, 
		 struct symtab *symtab)
d3880 1
a3880 1
	  prevDefns[i].symtab = symtab;
d3882 1
a3882 1
	}
d3898 2
a3899 2
static int 
num_defns_collected (struct obstack *obstackp) 
d3908 1
a3908 1
static struct ada_symbol_info * 
d3990 1
a3990 1
					  + name_len))
d4032 1
a4032 1
				   name_len);
d4042 1
a4042 1
					  + name_len + 5))
d4074 6
a4079 6
	b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
	ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
	  return s;
	b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
	ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
	  return s;
d4098 8
a4105 8
	for (j = FIRST_LOCAL_BLOCK;
	     j < BLOCKVECTOR_NBLOCKS (BLOCKVECTOR (s)); j += 1)
	  {
	    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), j);
	    ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
	      return s;
	  }
	break;
d4148 1
a4148 1
			   struct objfile *objf)
d4161 1
a4161 1
				  const char *name, domain_enum namespace,
d4176 1
a4176 1
  if (! target_has_stack)
d4194 1
a4194 2
  if (frame == NULL
      || inside_main_func (get_frame_address_in_block (frame)))
d4199 2
a4200 2
	 && num_defns_collected (obstackp) == 0 
	 && frame_relative_level (frame) <= MAX_ENCLOSING_FRAME_LEVELS)
d4206 1
a4206 1
	break;
d4209 17
a4225 17
	{
	  struct block *block;
      
	  QUIT;

	  block = get_frame_block (frame, 0);
	  while (block != NULL && block_function (block) != NULL 
		 && num_defns_collected (obstackp) == 0)
	    {
	      QUIT;

	      ada_add_block_symbols (obstackp, block, name, namespace,
				     NULL, NULL, wild_match);
	      
	      block = BLOCK_SUPERBLOCK (block);
	    }
	}
d4234 2
a4235 1
static void restore_language (void* lang)
d4245 2
a4246 2
			   domain_enum domain, enum language lang,
			   int *is_a_field_of_this, struct symtab **symtab)
d4248 2
a4249 2
  struct cleanup *old_chain 
    = make_cleanup (restore_language, (void*) current_language->la_language);
d4291 1
a4291 1
			     SYMBOL_LINKAGE_NAME (syms[j].sym)) == 0
d4298 1
a4298 1
		    syms[k - 1] = syms[k];
d4323 1
a4323 1
     
d4336 1
a4336 1
  
d4360 1
a4360 1
  
d4396 1
a4396 1
     
d4439 1
a4439 2
                               int nsyms,
                               struct block *current_block)
d4447 1
a4447 1
   
d4450 1
a4450 1
  
d4471 1
a4471 1
	    syms[j - 1] = syms[j];
d4497 2
a4498 2
                        domain_enum namespace, 
			struct ada_symbol_info **results)
d4522 3
a4524 3
  block = (struct block *) block0; /* FIXME: No cast ought to be
				     needed, but adding const will
				     have a cascade effect.  */
d4536 2
a4537 2
      ada_add_block_symbols (&symbol_list_obstack, block, name, 
			     namespace, NULL, NULL, wild_match);
d4541 1
a4541 1
			  num_defns_collected (&symbol_list_obstack)))
d4551 1
a4551 1
				      name, namespace, wild_match);
d4576 2
a4577 2
    ada_add_block_symbols (&symbol_list_obstack, block, name, namespace, 
			   objfile, s, wild_match);
d4601 1
a4601 1
					   
d4628 1
a4628 1
			       namespace, objfile, s, wild_match);
d4646 2
a4647 2
        ada_add_block_symbols (&symbol_list_obstack, block, name, namespace, 
			       objfile, s, wild_match);
d4661 2
a4662 2
            ada_add_block_symbols (&symbol_list_obstack, block, name, 
				   namespace, objfile, s, wild_match);
d4677 2
a4678 2
    cache_symbol (name0, namespace, (*results)[0].sym, (*results)[0].block, 
		  (*results)[0].symtab);
d4698 1
a4698 1
		   struct symtab **symtab)
d4714 1
a4714 1
  if (symtab != NULL) 
d4717 23
a4739 23
      if (*symtab == NULL && candidates[0].block != NULL) 
	{
	  struct objfile *objfile;
	  struct symtab *s;
	  struct block *b;
	  struct blockvector *bv;

	  /* Search the list of symtabs for one which contains the
	     address of the start of this block.  */
	  ALL_SYMTABS (objfile, s)
	    {
	      bv = BLOCKVECTOR (s);
	      b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	      if (BLOCK_START (b) <= BLOCK_START (candidates[0].block)
		  && BLOCK_END (b) > BLOCK_START (candidates[0].block))
		{
		  *symtab = s;
		  return fixup_symbol_section (candidates[0].sym, objfile);
		}
	      return fixup_symbol_section (candidates[0].sym, NULL);
	    }
	}
    }	
d4745 3
a4747 4
			    const char *linkage_name,
			    const struct block *block,
			    const domain_enum domain,
			    struct symtab **symtab)
d4751 2
a4752 2
  return  ada_lookup_symbol (linkage_name, block_static_block (block), domain,
			     NULL, symtab);
d4904 1
a4904 1
     
d4980 1
a4980 1
		       struct block *block, const char *name,
d4998 26
a5023 26
        {
          if (SYMBOL_DOMAIN (sym) == domain &&
              wild_match (name, name_len, SYMBOL_LINKAGE_NAME (sym)))
            {
              switch (SYMBOL_CLASS (sym))
                {
                case LOC_ARG:
                case LOC_LOCAL_ARG:
                case LOC_REF_ARG:
                case LOC_REGPARM:
                case LOC_REGPARM_ADDR:
                case LOC_BASEREG_ARG:
		case LOC_COMPUTED_ARG:
                  arg_sym = sym;
                  break;
                case LOC_UNRESOLVED:
                  continue;
                default:
                  found_sym = 1;
                  add_defn_to_vec (obstackp, 
				   fixup_symbol_section (sym, objfile),
                                   block, symtab);
                  break;
                }
            }
        }
d5028 30
a5057 30
	{
	  if (SYMBOL_DOMAIN (sym) == domain)
	    {
	      int cmp = strncmp (name, SYMBOL_LINKAGE_NAME (sym), name_len);
	      if (cmp == 0
		  && is_name_suffix (SYMBOL_LINKAGE_NAME (sym) + name_len))
		{
		  switch (SYMBOL_CLASS (sym))
		    {
		    case LOC_ARG:
		    case LOC_LOCAL_ARG:
		    case LOC_REF_ARG:
		    case LOC_REGPARM:
		    case LOC_REGPARM_ADDR:
		    case LOC_BASEREG_ARG:
		    case LOC_COMPUTED_ARG:
		      arg_sym = sym;
		      break;
		    case LOC_UNRESOLVED:
		      break;
		    default:
		      found_sym = 1;
		      add_defn_to_vec (obstackp,
				       fixup_symbol_section (sym, objfile),
				       block, symtab);
		      break;
		    }
		}
	    }
	}
d5062 3
a5064 3
      add_defn_to_vec (obstackp, 
		       fixup_symbol_section (arg_sym, objfile),
		       block, symtab);
d5073 41
a5113 41
	  {
	    if (SYMBOL_DOMAIN (sym) == domain)
	      {
		int cmp;

		cmp = (int) '_' - (int) SYMBOL_LINKAGE_NAME (sym)[0];
		if (cmp == 0)
		  {
		    cmp = strncmp ("_ada_", SYMBOL_LINKAGE_NAME (sym), 5);
		    if (cmp == 0)
		      cmp = strncmp (name, SYMBOL_LINKAGE_NAME (sym) + 5,
				     name_len);
		  }

		if (cmp == 0
		    && is_name_suffix (SYMBOL_LINKAGE_NAME (sym) + name_len + 5))
		  {
		    switch (SYMBOL_CLASS (sym))
		      {
		      case LOC_ARG:
		      case LOC_LOCAL_ARG:
		      case LOC_REF_ARG:
		      case LOC_REGPARM:
		      case LOC_REGPARM_ADDR:
		      case LOC_BASEREG_ARG:
		      case LOC_COMPUTED_ARG:
			arg_sym = sym;
			break;
		      case LOC_UNRESOLVED:
			break;
		      default:
			found_sym = 1;
			add_defn_to_vec (obstackp,
					 fixup_symbol_section (sym, objfile),
					 block, symtab);
			break;
		      }
		  }
	      }
	  end_loop2: ;
	  }
d5120 2
a5121 2
			   fixup_symbol_section (arg_sym, objfile),
			   block, symtab);
d5128 1
a5128 1
				/* Symbol Completion */
d5140 1
a5140 1
symbol_completion_match (const char *sym_name, 
d5168 1
a5168 1
      
d5170 1
a5170 1
      has_angle_bracket = (sym_name [0] == '<');
d5230 1
a5230 1
   
d5321 2
a5322 2
    {
      struct partial_symbol **psym;
d5324 4
a5327 4
      /* If the psymtab's been read in we'll get it when we search
         through the blockvector.  */
      if (ps->readin)
        continue;
d5329 9
a5337 10
      for (psym = objfile->global_psymbols.list + ps->globals_offset;
           psym < (objfile->global_psymbols.list + ps->globals_offset
          	 + ps->n_global_syms);
           psym++)
        {
          QUIT;
          symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (*psym),
                                 text, text_len, text0, word,
                                 wild_match, encoded);
        }
d5339 9
a5347 10
      for (psym = objfile->static_psymbols.list + ps->statics_offset;
           psym < (objfile->static_psymbols.list + ps->statics_offset
          	 + ps->n_static_syms);
           psym++)
        {
          QUIT;
          symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (*psym),
                                 text, text_len, text0, word,
                                 wild_match, encoded);
        }
d5359 1
a5359 2
                           text, text_len, text0, word,
                           wild_match, encoded);
d5368 1
a5368 1
	surrounding_static_block = b;		/* For elmin of dups */
d5371 5
a5375 5
	{
          symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
                                 text, text_len, text0, word,
                                 wild_match, encoded);
	}
d5386 5
a5390 5
      {
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
                               text, text_len, text0, word,
                               wild_match, encoded);
      }
d5401 5
a5405 5
      {
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
                               text, text_len, text0, word,
                               wild_match, encoded);
      }
d5414 1
a5414 1
#endif	/* GNAT_GDB */
d5492 1
a5492 1
  if (file_table == NULL) 
d5620 1
a5620 2
      selected.nelts =
        user_select_syms (symbols, n_matches, n_matches);
d5632 2
a5633 2
        selected.sals[i] 
	  = find_function_start_sal (symbols[i].sym, funfirstline);
d5636 3
a5638 3
          selected.sals[i].symtab = 
	    symbols[i].symtab 
	    ? symbols[i].symtab : symtab_for_sym (symbols[i].sym);
d5741 2
a5742 1
                        struct ada_symbol_info *symbols, int nsyms, int *exactp)
d5757 2
a5758 2
          if (symbols[k].sym != NULL 
	      && SYMBOL_CLASS (symbols[k].sym) == LOC_BLOCK
d5954 1
a5954 2
                   int funfirstline, char ***canonical,
                   int one_location_only)
d6122 2
a6123 2
  return ((! bs || ! bs->breakpoint_at) ? 0
	  : bs->breakpoint_at->break_on_exception);
d6141 1
a6141 1
  const int pc_is_after_call = 
d6145 1
a6145 1
  struct symtab_and_line sal 
d6152 5
a6156 5
       1. The symtab is null (indicating no debugging symbols)
       2. The symtab's filename does not exist.
       3. The object file's name is one of the standard libraries.
       4. The symtab's file name has the form of an Ada library source file.
       5. The function at frame's PC has a GNAT-compiler-generated name.  */
d6260 1
a6260 1
    	  fi = get_prev_frame (fi);
d6266 1
a6266 1
            break;  /* We found the frame we were looking for...  */
d6270 1
a6270 1
	break;
d6275 1
a6275 1
    addr = parse_and_eval_address ("e.full_name");
d6278 1
a6278 2
    read_memory (addr, last_exception_name,
		 sizeof (last_exception_name) - 1);
d6325 1
a6325 1
      if (b->cond_string)  /* the breakpoint is on a specific exception.  */
d6404 2
a6405 1
    error ("Unable to break on %s. Try to start the program first.", err_desc);
d6422 1
a6422 1
is_runtime_sym_defined  (const char *name, int allow_tramp)
d6428 1
a6428 1
	  && (allow_tramp || msym->type != mst_solib_trampoline));
d6449 1
a6449 1
	is_runtime_sym_defined (raise_sym_name, 1);
d6468 4
a6471 4
	  if (has_exception_propagation)
	    sprintf (arg, "'%s'", raise_sym_name);
	  else
	    error_breakpoint_runtime_sym_not_found ("exception");
d6475 4
a6478 4
	  if (is_runtime_sym_defined (raise_unhandled_sym_name, 1))
	    sprintf (arg, "'%s'", raise_unhandled_sym_name);
	  else
	    error_breakpoint_runtime_sym_not_found ("exception");
d6480 1
a6480 1
	  *break_on_exceptionp = 2;
d6484 5
a6488 5
	  if (is_runtime_sym_defined (raise_sym_name, 0))
	    sprintf (arg, "'%s' if long_integer(e) = long_integer(&%.*s)",
		     raise_sym_name, toklen, tok);
	  else
	    error_breakpoint_runtime_sym_not_found ("specific exception");
d6498 1
a6498 1
	error_breakpoint_runtime_sym_not_found ("failed assertion");
d6543 1
a6543 1
  if (type  == NULL || TYPE_CODE (type) != TYPE_CODE_PTR)
d6545 6
a6550 5
  else {
    const char *name = ada_type_name (TYPE_TARGET_TYPE (type));
    return (name != NULL 
	    && strcmp (name, "ada__tags__dispatch_table") == 0);
  }
d6575 1
a6575 1
				     CORE_ADDR address)
d6580 1
a6580 1
			 &dummy1, &dummy2))
d6599 2
a6600 1
struct tag_args {
d6615 1
a6615 1
  char* p;
d6639 1
a6639 1
  if (! ada_is_tag_type (VALUE_TYPE (tag)))
d6641 1
a6641 1
  args.tag = tag; 
d6718 1
a6718 1
  struct type *type = 
d6775 1
a6775 1
      if ((discrim_start > name + 3 
d6916 3
a6918 3
find_struct_field (char *name, struct type *type, int offset, 
		   struct type **field_type_p,
		   int *byte_offset_p, int *bit_offset_p, int *bit_size_p)
d6925 1
a6925 1
  
d6931 1
a6931 1
      
d6936 8
a6943 8
	{
	  int bit_size = TYPE_FIELD_BITSIZE (type, i);
	  *field_type_p = TYPE_FIELD_TYPE (type, i);
	  *byte_offset_p = fld_offset;
	  *bit_offset_p = bit_pos % 8;
	  *bit_size_p = bit_size;
	  return 1;
	}
d6946 5
a6950 5
	  if (find_struct_field (name, TYPE_FIELD_TYPE (type, i), fld_offset,
				 field_type_p, byte_offset_p, bit_offset_p,
				 bit_size_p))
	    return 1;
	}
d6958 6
a6963 6
	      if (find_struct_field (name, TYPE_FIELD_TYPE (field_type, j),
				     fld_offset 
				     + TYPE_FIELD_BITPOS (field_type, j)/8,
				     field_type_p, byte_offset_p, bit_offset_p,
				     bit_size_p))
		return 1;
d6997 7
a7003 4
          struct value *v = 
	    ada_search_struct_field (name, arg,
				     offset + TYPE_FIELD_BITPOS (type, i) / 8,
				     TYPE_FIELD_TYPE (type, i));
d7016 7
a7022 5
              struct value *v = 
		ada_search_struct_field (name, arg,
					 var_offset 
					 + TYPE_FIELD_BITPOS (field_type, j)/8,
					 TYPE_FIELD_TYPE (field_type, j));
d7060 6
a7065 6
	{
	  if (err == NULL)
	    return NULL;
	  else
	    error ("Bad value type in a %s.", err);
	}
d7068 4
a7071 4
	{
	  COERCE_REF (arg);
	  t = t1;
	}
d7078 6
a7083 6
	{
	  if (err == NULL)
	    return NULL;
	  else
	    error ("Bad value type in a %s.", err);
	}
d7086 4
a7089 4
	{
	  arg = value_ind (arg);
	  t = t1;
	}
d7091 1
a7091 1
	break;
d7097 1
a7097 1
	return NULL;
d7099 2
a7100 2
	error ("Attempt to extract a component of a value that is not a %s.",
	       err);
d7111 2
a7112 2
      if (TYPE_CODE (t) == TYPE_CODE_PTR) 
	address = value_as_address (arg);
d7114 1
a7114 1
	address = unpack_pointer (t, VALUE_CONTENTS (arg));
d7117 15
a7131 14
      if (find_struct_field (name, t1, 0, 
			     &field_type, &byte_offset, &bit_offset, &bit_size))
	{
	  if (bit_size != 0) 
	    {
	      arg = ada_value_ind (arg);
	      v = ada_value_primitive_packed_val (arg, NULL, byte_offset,
						  bit_offset, bit_size, 
						  field_type);
	    }
	  else
	    v = value_from_pointer (lookup_reference_type (field_type), 
				    address + byte_offset);
	}
d7133 1
a7133 1
				     
d7158 2
a7159 2
ada_lookup_struct_elt_type (struct type *type, char *name, int refok, 
			    int noerr, int *dispp)
d7166 1
a7166 1
  if (refok && type != NULL) 
d7169 5
a7173 5
	CHECK_TYPEDEF (type);
	if (TYPE_CODE (type) != TYPE_CODE_PTR
	    && TYPE_CODE (type) != TYPE_CODE_REF)
	  break;
	type = TYPE_TARGET_TYPE (type);
d7176 1
a7176 1
  if (type == NULL 
d7178 1
a7178 1
	  TYPE_CODE (type) != TYPE_CODE_UNION))
d7181 1
a7181 1
	return NULL;
d7183 10
a7192 10
	{
	  target_terminal_ours ();
	  gdb_flush (gdb_stdout);
	  fprintf_unfiltered (gdb_stderr, "Type ");
	  if (type == NULL)
	    fprintf_unfiltered (gdb_stderr, "(null)");
	  else
	    type_print (type, "", gdb_stderr, -1);
	  error (" is not a structure or union type");
	}
d7440 2
a7441 4
      const int rename_len = function_name_len
                             + 2  /*  "__" */
                             + strlen (name)
                             + 6  /* "___XR\0" */;
d7639 1
a7639 1
      while (nfields < TYPE_NFIELDS (type) 
d8056 11
a8066 11
	struct type *static_type = to_static_fixed_type (type);
	if (ada_is_tagged_type (static_type, 0))
	  { 
	    struct type *real_type = 
	      type_from_tag (value_tag_from_contents_and_address (static_type, 
								  valaddr,
								  address));
	    if (real_type != NULL)
	      type = real_type;
	  }
	return to_fixed_record_type (type, valaddr, address, NULL);
d8205 2
a8206 1
      const struct symtab_and_line sal = find_function_start_sal (func_sym, 1);
d8343 2
a8344 1
      && (ada_is_simple_array_type (type) || ada_is_array_descriptor_type (type))
d8434 2
a8435 2
        all the preceeding characters, the unqualified name starts
        right after that dot.
d8437 3
a8439 3
        translates dots into "__".  Search forward for double underscores,
        but stop searching when we hit an overloading suffix, which is
        of the form "__" followed by digits.  */
d8494 1
a8494 1
  return (*exp->language_defn->la_exp_desc->evaluate_exp) 
d8615 2
a8616 1
  if (TYPE_CODE (type1) != TYPE_CODE_INT || TYPE_CODE (type2) != TYPE_CODE_INT)
d8619 1
a8619 1
  switch (op) 
d8641 2
a8642 2
      if (! TRUNCATION_TOWARDS_ZERO && v1 * (v1%v2) < 0)
	v += v > 0 ? -1 : 1;
d8646 2
a8647 2
      if (v*v1 < 0)
	v -= v2;
d8656 1
a8656 2
			  TYPE_LENGTH (VALUE_TYPE (val)),
			  v);
d8663 1
a8663 1
  if (ada_is_direct_array_type (VALUE_TYPE (arg1)) 
d8669 2
a8670 2
	  || TYPE_CODE (VALUE_TYPE (arg2)) != TYPE_CODE_ARRAY)
	error ("Attempt to compare array with non-array");
d8672 6
a8677 6
	 representations use all bits (no padding or undefined bits)
	 and do not have user-defined equality.  */
      return 
	TYPE_LENGTH (VALUE_TYPE (arg1)) == TYPE_LENGTH (VALUE_TYPE (arg2))
	&& memcmp (VALUE_CONTENTS (arg1), VALUE_CONTENTS (arg2), 
		   TYPE_LENGTH (VALUE_TYPE (arg1))) == 0;
d8708 8
a8715 8
	struct value *result;
	*pos -= 1;
	result = evaluate_subexp_standard (expect_type, exp, pos, noside);
	/* The result type will have code OP_STRING, bashed there from 
	   OP_ARRAY.  Bash it back.  */
	if (TYPE_CODE (VALUE_TYPE (result)) == TYPE_CODE_STRING)
	  TYPE_CODE (VALUE_TYPE (result)) = TYPE_CODE_ARRAY;
	return result;
d8759 1
a8759 1
	arg2 = cast_to_fixed (VALUE_TYPE (arg1), arg2);
d8761 2
a8762 2
	error
	  ("Fixed-point values must be assigned to fixed-point variables");
d8764 1
a8764 1
	arg2 = coerce_for_assign (VALUE_TYPE (arg1), arg2);
d8773 3
a8775 4
	   || ada_is_fixed_point_type (VALUE_TYPE (arg2)))
	  && VALUE_TYPE (arg1) != VALUE_TYPE (arg2))
	error
	  ("Operands of fixed-point addition must have the same type");
d8784 3
a8786 4
	   || ada_is_fixed_point_type (VALUE_TYPE (arg2)))
	  && VALUE_TYPE (arg1) != VALUE_TYPE (arg2))
	error
	  ("Operands of fixed-point subtraction must have the same type");
d8796 1
a8796 1
	       && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
d8812 1
a8812 1
	goto nosideret;
d8814 2
a8815 2
	       && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
	return value_zero (VALUE_TYPE (arg1), not_lval);
d8817 1
a8817 1
	return ada_value_binop (arg1, arg2, op);
d8824 1
a8824 1
	goto nosideret;
d8826 1
a8826 1
	tem = 0;
d8828 1
a8828 1
	tem = ada_value_equal (arg1, arg2);
d8830 1
a8830 1
	tem = ! tem;
d8850 3
a8852 3
	/* Only encountered when an unresolved symbol occurs in a
	   context other than a function call, in which case, it is
	   illegal.  */
d8881 1
a8881 1
	  && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)
d8897 2
a8898 2
          || (TYPE_CODE (VALUE_TYPE (argvec[0])) == TYPE_CODE_ARRAY
              && VALUE_LVAL (argvec[0]) == lval_memory))
d9007 2
a9008 2
	if (ada_is_packed_array_type (VALUE_TYPE (array)))
	  error ("cannot slice a packed array");
d9079 1
a9079 2
          arg2 = value_from_longest (builtin_type_int,
                                     TYPE_LOW_BOUND (type));
d9135 111
a9245 111
	struct type *type_arg;
	if (exp->elts[*pos].opcode == OP_TYPE)
	  {
	    evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
	    arg1 = NULL;
	    type_arg = exp->elts[pc + 2].type;
	  }
	else
	  {
	    arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	    type_arg = NULL;
	  }

	if (exp->elts[*pos].opcode != OP_LONG)
	  error ("illegal operand to '%s", ada_attribute_name (op));
	tem = longest_to_int (exp->elts[*pos + 2].longconst);
	*pos += 4;

	if (noside == EVAL_SKIP)
	  goto nosideret;

	if (type_arg == NULL)
	  {
	    arg1 = ada_coerce_ref (arg1);

	    if (ada_is_packed_array_type (VALUE_TYPE (arg1)))
	      arg1 = ada_coerce_to_simple_array (arg1);

	    if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg1)))
	      error ("invalid dimension number to '%s",
		     ada_attribute_name (op));

	    if (noside == EVAL_AVOID_SIDE_EFFECTS)
	      {
		type = ada_index_type (VALUE_TYPE (arg1), tem);
		if (type == NULL)
		  error
		    ("attempt to take bound of something that is not an array");
		return allocate_value (type);
	      }

	    switch (op)
	      {
	      default: /* Should never happen.  */
		error ("unexpected attribute encountered");
	      case OP_ATR_FIRST:
		return ada_array_bound (arg1, tem, 0);
	      case OP_ATR_LAST:
		return ada_array_bound (arg1, tem, 1);
	      case OP_ATR_LENGTH:
		return ada_array_length (arg1, tem);
	      }
	  }
	else if (discrete_type_p (type_arg))
	  {
	    struct type *range_type;
	    char *name = ada_type_name (type_arg);
	    range_type = NULL;
	    if (name != NULL && TYPE_CODE (type_arg) != TYPE_CODE_ENUM)
	      range_type =
		to_fixed_range_type (name, NULL, TYPE_OBJFILE (type_arg));
	    if (range_type == NULL)
	      range_type = type_arg;
	    switch (op)
	      {
	      default:
		error ("unexpected attribute encountered");
	      case OP_ATR_FIRST:
		return discrete_type_low_bound (range_type);
	      case OP_ATR_LAST:
		return discrete_type_high_bound (range_type);
	      case OP_ATR_LENGTH:
		error ("the 'length attribute applies only to array types");
	      }
	  }
	else if (TYPE_CODE (type_arg) == TYPE_CODE_FLT)
	  error ("unimplemented type attribute");
	else
	  {
	    LONGEST low, high;

	    if (ada_is_packed_array_type (type_arg))
	      type_arg = decode_packed_array_type (type_arg);

	    if (tem < 1 || tem > ada_array_arity (type_arg))
	      error ("invalid dimension number to '%s",
		     ada_attribute_name (op));

	    type = ada_index_type (type_arg, tem);
	    if (type == NULL)
	      error ("attempt to take bound of something that is not an array");
	    if (noside == EVAL_AVOID_SIDE_EFFECTS)
	      return allocate_value (type);

	    switch (op)
	      {
	      default:
		error ("unexpected attribute encountered");
	      case OP_ATR_FIRST:
		low = ada_array_bound_from_type (type_arg, tem, 0, &type);
		return value_from_longest (type, low);
	      case OP_ATR_LAST:
		high =
		  ada_array_bound_from_type (type_arg, tem, 1, &type);
		return value_from_longest (type, high);
	      case OP_ATR_LENGTH:
		low = ada_array_bound_from_type (type_arg, tem, 0, &type);
		high = ada_array_bound_from_type (type_arg, tem, 1, NULL);
		return value_from_longest (type, high - low + 1);
	      }
	  }
d9251 1
a9251 1
	goto nosideret;
d9254 1
a9254 1
	return value_zero (ada_tag_type (arg1), not_lval);
d9264 1
a9264 1
	goto nosideret;
d9266 1
a9266 1
	return value_zero (VALUE_TYPE (arg1), not_lval);
d9268 2
a9269 2
	return value_binop (arg1, arg2,
			    op == OP_ATR_MIN ? BINOP_MIN : BINOP_MAX);
d9273 2
a9274 2
	struct type *type_arg = exp->elts[pc + 2].type;
	evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
d9276 2
a9277 2
	if (noside == EVAL_SKIP)
	  goto nosideret;
d9279 2
a9280 2
	if (!ada_is_modular_type (type_arg))
	  error ("'modulus must be applied to modular type");
d9282 2
a9283 2
	return value_from_longest (TYPE_TARGET_TYPE (type_arg),
				   ada_modulus (type_arg));
d9291 1
a9291 1
	goto nosideret;
d9293 1
a9293 1
	return value_zero (builtin_type_ada_int, not_lval);
d9295 1
a9295 1
	return value_pos_atr (arg1);
d9300 1
a9300 1
	goto nosideret;
d9302 1
a9302 1
	return value_zero (builtin_type_ada_int, not_lval);
d9304 3
a9306 3
	return value_from_longest (builtin_type_ada_int,
				   TARGET_CHAR_BIT
				   * TYPE_LENGTH (VALUE_TYPE (arg1)));
d9313 1
a9313 1
	goto nosideret;
d9315 1
a9315 1
	return value_zero (type, not_lval);
d9317 1
a9317 1
	return value_val_atr (type, arg1);
d9377 1
a9377 1
      arg1 = ada_coerce_ref (arg1);  /* FIXME: What is this for?? */
d9393 26
a9418 25
	{
	  struct type *type1 = VALUE_TYPE (arg1);
	  if (ada_is_tagged_type (type1, 1)) 
	    {
	      type = ada_lookup_struct_elt_type (type1, 
						 &exp->elts[pc + 2].string,
						 1, 1, NULL);
	      if (type == NULL)
	    /* In this case, we assume that the field COULD exist
	       in some extension of the type.  Return an object of 
	       "type" void, which will match any formal 
	       (see ada_type_match). */
		return value_zero (builtin_type_void, lval_memory);
	    }
	  else
	    type = ada_lookup_struct_elt_type (type1, &exp->elts[pc + 2].string,
					       1, 0, NULL);

	  return value_zero (ada_aligned_type (type), lval_memory);
	}
      else
        return 
	  ada_to_fixed_value (unwrap_value 
			      (ada_value_struct_elt
			       (arg1, &exp->elts[pc + 2].string, "record")));
d9592 1
a9592 1
		    int *pnew_k)
d9827 1
a9827 1
    default: 
d9843 1
a9843 1
    default: 
d9856 2
a9857 2
ada_forward_operator_length (struct expression *exp, int pc, 
			     int *oplenp, int *argsp)
d9859 1
a9859 1
  switch (exp->elts[pc].opcode) 
d9878 1
a9878 1
  
d9881 1
a9881 1
  switch (op) 
d9883 1
a9883 1
    /* Ada attributes ('Foo).  */
d9924 3
a9926 3
static void 
ada_print_subexp (struct expression *exp, int *pos, 
		  struct ui_file *stream, enum precedence prec)
d9952 2
a9953 1
	fprintf_filtered (stream, "(%ld)", (long) exp->elts[pc + 1].longconst);
d9959 1
a9959 1
	fputs_filtered ("(", stream);
d9966 2
a9967 2
	fputs_filtered (")", stream);
      return;      
d9982 5
a9986 5
	{
	  if (TYPE_CODE (exp->elts[*pos + 1].type) != TYPE_CODE_VOID)
	    LA_PRINT_TYPE (exp->elts[*pos + 1].type, "", stream, 0, 0);
	  *pos += 3;
	}
d9988 1
a9988 1
	print_subexp (exp, pos, stream, PREC_SUFFIX);
d9991 9
a9999 9
	{
	  int tem;
	  for (tem = 1; tem < nargs; tem += 1)
	    {
	      fputs_filtered ( (tem == 1) ? " (" : ", ", stream);
	      print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);
	    }
	  fputs_filtered (")", stream);
	}
d10074 25
a10098 28
  &builtin_type_ada_long,
  &builtin_type_ada_short,
  &builtin_type_ada_char,
  &builtin_type_ada_float,
  &builtin_type_ada_double,
  &builtin_type_ada_long_long,
  &builtin_type_ada_long_double,
  &builtin_type_ada_natural, &builtin_type_ada_positive,
  /* The following types are carried over from C for convenience.  */
  &builtin_type_int,
  &builtin_type_long,
  &builtin_type_short,
  &builtin_type_char,
  &builtin_type_float,
  &builtin_type_double,
  &builtin_type_long_long,
  &builtin_type_void,
  &builtin_type_signed_char,
  &builtin_type_unsigned_char,
  &builtin_type_unsigned_short,
  &builtin_type_unsigned_int,
  &builtin_type_unsigned_long,
  &builtin_type_unsigned_long_long,
  &builtin_type_long_double,
  &builtin_type_complex,
  &builtin_type_double_complex,
  0
};
d10115 1
a10115 2
static const struct exp_descriptor ada_exp_descriptor = 
{
d10134 1
a10134 1
#endif  /* GNAT_GDB */
d10139 9
a10147 9
  ada_printchar,		/* Print a character constant */
  ada_printstr,			/* Function to print string constant */
  emit_char,			/* Function to print single char (not used) */
  ada_create_fundamental_type,	/* Create fundamental type in this language */
  ada_print_type,		/* Print a type using appropriate syntax */
  ada_val_print,		/* Print a value using appropriate syntax */
  ada_value_print,		/* Print a top-level value */
  NULL,				/* Language specific skip_trampoline */
  NULL,				/* value_of_this */
d10149 3
a10151 3
  basic_lookup_transparent_type,/* lookup_transparent_type */
  ada_la_decode,		/* Language specific symbol demangler */
  {"", "", "", ""},		/* Binary format info */
d10169 2
a10170 2
				   in errors and warnings.  */
#endif  /* GNAT_GDB */
d10175 2
a10176 1
build_ada_types (void) {
d10231 1
a10231 1
#endif  /* GNAT_GDB */
d10235 2
a10236 2
  decoded_names_store = htab_create_alloc_ex 
    (256, htab_hash_string, (int (*) (const void *, const void *)) streq,
@


1.39
log
@2004-06-18  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_FUNCTION_START_OFFSET): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* ada-lang.c (ada_finish_decode_line_1): Update.
	* infrun.c (handle_inferior_event): Update.
	* infcall.c (find_function_addr): Update.
	* linespec.c (minsym_found): Update.
	* symtab.c (find_function_start_sal, skip_prologue_using_sal):
	Update.
	* blockframe.c (legacy_frameless_look_for_prologue): Update.
	* cli/cli-cmds.c (disassemble_command): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-18  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	FUNCTION_START_OFFSET.
@
text
@a257 3
extern void symtab_symbol_info (char *regexp, domain_enum kind,
                                int from_tty);

a5420 3
/* Import message from symtab.c.  */
extern char no_symtab_msg[];

@


1.38
log
@	* ada-tasks.c: Rename build_task_list to ada_build_task_list, and
	make it non-static.
	* ada-lang.h (task_control_block): declaration moved from ada-task.c
	to ada-lang.h; this is needed to be able to implement the kill command
	in multi-task mode.
	(task_ptid): Ditto.
	(task_entry): Ditto.
	(task_list): Ditto.
	(ada_build_task_list): Ditto.

	* ada-lang.c: Conditionalize routines and data structures related
	to breakpoints, exceptions, completion, and symbol caching on
	GNAT_GDB, since these are not yet used in the submitted public sources.
	(ada_main_name): Editorial: Move definition out of exception-related
	code.
@
text
@d5599 1
a5599 1
              val.pc += FUNCTION_START_OFFSET;
@


1.37
log
@2004-06-08  Paul N. Hilfinger  <Hilfinger@@gnat.com>

	* ada-lang.c (lookup_symbol_in_language): New function to allow
	re-use of another language's symbol lookup code.  (Placed here
	temporarily while Ada support is being integrated into the public
	tree).
	(restore_language): New auxiliary function for
	lookup_symbol_in_language.
	* ada-lang.h (lookup_symbol_in_language): Declare (Placed here
	temporarily while Ada support is being integrated into the public
	tree).
@
text
@d21 13
d78 1
d93 1
d350 2
d412 2
d727 31
d3650 7
d3746 16
d3917 3
a3919 3
/* If SYM_NAME is a completion candidate for TEXT, return this symbol
   name in a form that's appropriate for the completion.  The result
   does not need to be deallocated, but is only good until the next call.
d3921 3
a3923 9
   TEXT_LEN is equal to the length of TEXT.
   Perform a wild match if WILD_MATCH is set.
   ENCODED should be set if TEXT represents the start of a symbol name
   in its encoded form.  */

static const char *
symbol_completion_match (const char *sym_name, 
                         const char *text, int text_len,
                         int wild_match, int encoded)
d3925 4
a3928 3
  char *result;
  const int verbatim_match = (text[0] == '<');
  int match = 0;
d3930 1
a3930 1
  if (verbatim_match)
d3932 1
a3932 3
      /* Strip the leading angle bracket.  */
      text = text + 1;
      text_len--;
d3935 3
a3937 1
  /* First, test against the fully qualified name of the symbol.  */
d3939 5
a3943 2
  if (strncmp (sym_name, text, text_len) == 0)
    match = 1;
d3945 5
a3949 13
  if (match && !encoded)
    {
      /* One needed check before declaring a positive match is to verify
         that iff we are doing a verbatim match, the decoded version
         of the symbol name starts with '<'.  Otherwise, this symbol name
         is not a suitable completion.  */
      const char *sym_name_copy = sym_name;
      int has_angle_bracket;
      
      sym_name = ada_decode (sym_name);
      has_angle_bracket = (sym_name [0] == '<');
      match = (has_angle_bracket == verbatim_match);
      sym_name = sym_name_copy;
d3951 1
a3951 2

  if (match && !verbatim_match)
d3953 21
a3973 6
      /* When doing non-verbatim match, another check that needs to
         be done is to verify that the potentially matching symbol name
         does not include capital letters, because the ada-mode would
         not be able to understand these symbol names without the
         angle bracket notation.  */
      const char *tmp;
d3975 3
a3977 4
      for (tmp = sym_name; *tmp != '\0' && !isupper (*tmp); tmp++);
      if (*tmp != '\0')
        match = 0;
    }
d3979 3
a3981 1
  /* Second: Try wild matching...  */
d3983 12
a3994 6
  if (!match && wild_match)
    {
      /* Since we are doing wild matching, this means that TEXT
         may represent an unqualified symbol name.  We therefore must
         also compare TEXT against the unqualified name of the symbol.  */
      sym_name = ada_unqualified_name (ada_decode (sym_name));
d3996 21
a4016 3
      if (strncmp (sym_name, text, text_len) == 0)
        match = 1;
    }
d4018 3
a4020 1
  /* Finally: If we found a mach, prepare the result to return.  */
d4022 3
a4024 2
  if (!match)
    return NULL;
d4026 8
a4033 2
  if (verbatim_match)
    sym_name = add_angle_brackets (sym_name);
d4035 15
a4049 2
  if (!encoded)
    sym_name = ada_decode (sym_name);
d4051 1
a4051 2
  return sym_name;
}
d4053 9
a4061 4
/* A companion function to ada_make_symbol_completion_list().
   Check if SYM_NAME represents a symbol which name would be suitable
   to complete TEXT (TEXT_LEN is the length of TEXT), in which case
   it is appended at the end of the given string vector SV.
d4063 48
a4110 48
   ORIG_TEXT is the string original string from the user command
   that needs to be completed.  WORD is the entire command on which
   completion should be performed.  These two parameters are used to
   determine which part of the symbol name should be added to the
   completion vector.
   if WILD_MATCH is set, then wild matching is performed.
   ENCODED should be set if TEXT represents a symbol name in its
   encoded formed (in which case the completion should also be
   encoded).  */
   
static void
symbol_completion_add (struct string_vector *sv,
                       const char *sym_name,
                       const char *text, int text_len,
                       const char *orig_text, const char *word,
                       int wild_match, int encoded)
{
  const char *match = symbol_completion_match (sym_name, text, text_len,
                                               wild_match, encoded);
  char *completion;

  if (match == NULL)
    return;

  /* We found a match, so add the appropriate completion to the given
     string vector.  */

  if (word == orig_text)
    {
      completion = xmalloc (strlen (match) + 5);
      strcpy (completion, match);
    }
  else if (word > orig_text)
    {
      /* Return some portion of sym_name.  */
      completion = xmalloc (strlen (match) + 5);
      strcpy (completion, match + (word - orig_text));
    }
  else
    {
      /* Return some of ORIG_TEXT plus sym_name.  */
      completion = xmalloc (strlen (match) + (orig_text - word) + 5);
      strncpy (completion, word, orig_text - word);
      completion[orig_text - word] = '\0';
      strcat (completion, match);
    }

  string_vector_append (sv, completion);
d4113 4
a4116 3
/* Return a list of possible symbol names completing TEXT0.  The list
   is NULL terminated.  WORD is the entire command on which completion
   is made.  */
d4118 2
a4119 2
char **
ada_make_symbol_completion_list (const char *text0, const char *word)
d4121 2
a4122 6
  /* Note: This function is almost a copy of make_symbol_completion_list(),
     except it has been adapted for Ada.  It is somewhat of a shame to
     duplicate so much code, but we don't really have the infrastructure
     yet to develop a language-aware version of he symbol completer...  */
  char *text;
  int text_len;
a4123 10
  int encoded;
  struct string_vector result = xnew_string_vector (128);
  struct symbol *sym;
  struct symtab *s;
  struct partial_symtab *ps;
  struct minimal_symbol *msymbol;
  struct objfile *objfile;
  struct block *b, *surrounding_static_block = 0;
  int i;
  struct dict_iterator iter;
d4125 1
a4125 1
  if (text0[0] == '<')
d4127 1
a4127 3
      text = xstrdup (text0);
      make_cleanup (xfree, text);
      text_len = strlen (text);
a4128 1
      encoded = 1;
d4131 1
a4131 6
    {
      text = xstrdup (ada_encode (text0));
      make_cleanup (xfree, text);
      text_len = strlen (text);
      for (i = 0; i < text_len; i++)
        text[i] = tolower (text[i]);
d4133 6
a4138 6
      /* FIXME: brobecker/2003-09-17: When we get rid of ADA_RETAIN_DOTS,
         we can restrict the wild_match check to searching "__" only.  */
      wild_match = (strstr (text0, "__") == NULL
                    && strchr (text0, '.') == NULL);
      encoded = (strstr (text0, "__") != NULL);
    }
d4140 2
a4141 4
  /* First, look at the partial symtab symbols.  */
  ALL_PSYMTABS (objfile, ps)
    {
      struct partial_symbol **psym;
d4143 2
a4144 4
      /* If the psymtab's been read in we'll get it when we search
         through the blockvector.  */
      if (ps->readin)
        continue;
d4146 6
a4151 10
      for (psym = objfile->global_psymbols.list + ps->globals_offset;
           psym < (objfile->global_psymbols.list + ps->globals_offset
          	 + ps->n_global_syms);
           psym++)
        {
          QUIT;
          symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (*psym),
                                 text, text_len, text0, word,
                                 wild_match, encoded);
        }
d4153 5
a4157 11
      for (psym = objfile->static_psymbols.list + ps->statics_offset;
           psym < (objfile->static_psymbols.list + ps->statics_offset
          	 + ps->n_static_syms);
           psym++)
        {
          QUIT;
          symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (*psym),
                                 text, text_len, text0, word,
                                 wild_match, encoded);
        }
  }
d4159 13
a4171 4
  /* At this point scan through the misc symbol vectors and add each
     symbol you find to the list.  Eventually we want to ignore
     anything that isn't a text symbol (everything else will be
     handled by the psymtab code above).  */
d4173 2
a4174 7
  ALL_MSYMBOLS (objfile, msymbol)
  {
    QUIT;
    symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (msymbol),
                           text, text_len, text0, word,
                           wild_match, encoded);
  }
d4176 2
a4177 2
  /* Search upwards from currently selected frame (so that we can
     complete on local vars.  */
d4179 1
a4179 1
  for (b = get_selected_block (0); b != NULL; b = BLOCK_SUPERBLOCK (b))
d4181 11
a4191 2
      if (!BLOCK_SUPERBLOCK (b))
	surrounding_static_block = b;		/* For elmin of dups */
d4193 4
a4196 7
      ALL_BLOCK_SYMBOLS (b, iter, sym)
	{
          symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
                                 text, text_len, text0, word,
                                 wild_match, encoded);
	}
    }
d4198 6
a4203 2
  /* Go through the symtabs and check the externs and statics for
     symbols which match.  */
d4205 9
a4213 11
  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
    ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
                               text, text_len, text0, word,
                               wild_match, encoded);
      }
  }
d4215 5
a4219 14
  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
    /* Don't do this block twice.  */
    if (b == surrounding_static_block)
      continue;
    ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
                               text, text_len, text0, word,
                               wild_match, encoded);
      }
  }
d4221 7
a4227 2
  /* Append the closing NULL entry.  */
  string_vector_append (&result, NULL);
d4229 2
a4230 1
  return (result.array);
d4233 1
a4233 3
/* Look, in partial_symtab PST, for symbol NAME in given namespace.
   Check the global symbols if GLOBAL, the static symbols if not.
   Do wild-card match if WILD.  */
d4235 1
a4235 3
static struct partial_symbol *
ada_lookup_partial_symbol (struct partial_symtab *pst, const char *name,
                           int global, domain_enum namespace, int wild)
d4237 2
a4238 4
  struct partial_symbol **start;
  int name_len = strlen (name);
  int length = (global ? pst->n_global_syms : pst->n_static_syms);
  int i;
d4240 2
a4241 4
  if (length == 0)
    {
      return (NULL);
    }
d4243 13
a4255 3
  start = (global ?
           pst->objfile->global_psymbols.list + pst->globals_offset :
           pst->objfile->static_psymbols.list + pst->statics_offset);
d4257 2
a4258 5
  if (wild)
    {
      for (i = 0; i < length; i += 1)
        {
          struct partial_symbol *psym = start[i];
d4260 6
a4265 29
          if (SYMBOL_DOMAIN (psym) == namespace &&
              wild_match (name, name_len, SYMBOL_LINKAGE_NAME (psym)))
            return psym;
        }
      return NULL;
    }
  else
    {
      if (global)
        {
          int U;
          i = 0;
          U = length - 1;
          while (U - i > 4)
            {
              int M = (U + i) >> 1;
              struct partial_symbol *psym = start[M];
              if (SYMBOL_LINKAGE_NAME (psym)[0] < name[0])
                i = M + 1;
              else if (SYMBOL_LINKAGE_NAME (psym)[0] > name[0])
                U = M - 1;
              else if (strcmp (SYMBOL_LINKAGE_NAME (psym), name) < 0)
                i = M + 1;
              else
                U = M;
            }
        }
      else
        i = 0;
d4267 6
a4272 3
      while (i < length)
        {
          struct partial_symbol *psym = start[i];
d4274 4
a4277 3
          if (SYMBOL_DOMAIN (psym) == namespace)
            {
              int cmp = strncmp (name, SYMBOL_LINKAGE_NAME (psym), name_len);
d4279 6
a4284 14
              if (cmp < 0)
                {
                  if (global)
                    break;
                }
              else if (cmp == 0
                       && is_name_suffix (SYMBOL_LINKAGE_NAME (psym)
					  + name_len))
                return psym;
            }
          i += 1;
        }

      if (global)
d4286 1
a4286 4
          int U;
          i = 0;
          U = length - 1;
          while (U - i > 4)
d4288 7
a4294 25
              int M = (U + i) >> 1;
              struct partial_symbol *psym = start[M];
              if (SYMBOL_LINKAGE_NAME (psym)[0] < '_')
                i = M + 1;
              else if (SYMBOL_LINKAGE_NAME (psym)[0] > '_')
                U = M - 1;
              else if (strcmp (SYMBOL_LINKAGE_NAME (psym), "_ada_") < 0)
                i = M + 1;
              else
                U = M;
            }
        }
      else
        i = 0;

      while (i < length)
        {
          struct partial_symbol *psym = start[i];

          if (SYMBOL_DOMAIN (psym) == namespace)
            {
              int cmp;

              cmp = (int) '_' - (int) SYMBOL_LINKAGE_NAME (psym)[0];
              if (cmp == 0)
d4296 5
a4300 10
                  cmp = strncmp ("_ada_", SYMBOL_LINKAGE_NAME (psym), 5);
                  if (cmp == 0)
                    cmp = strncmp (name, SYMBOL_LINKAGE_NAME (psym) + 5,
				   name_len);
                }

              if (cmp < 0)
                {
                  if (global)
                    break;
a4301 4
              else if (cmp == 0
                       && is_name_suffix (SYMBOL_LINKAGE_NAME (psym)
					  + name_len + 5))
                return psym;
a4302 1
          i += 1;
d4304 3
d4308 1
a4308 1
  return NULL;
d4311 4
a4314 1
/* Find a symbol table containing symbol SYM or NULL if none.  */
d4316 2
a4317 2
static struct symtab *
symtab_for_sym (struct symbol *sym)
d4319 250
a4568 6
  struct symtab *s;
  struct objfile *objfile;
  struct block *b;
  struct symbol *tmp_sym;
  struct dict_iterator iter;
  int j;
d4572 12
a4583 1
    switch (SYMBOL_CLASS (sym))
d4585 29
a4613 16
      case LOC_CONST:
      case LOC_STATIC:
      case LOC_TYPEDEF:
      case LOC_REGISTER:
      case LOC_LABEL:
      case LOC_BLOCK:
      case LOC_CONST_BYTES:
	b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
	ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
	  return s;
	b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
	ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
	  return s;
        break;
      default:
        break;
d4615 7
a4621 1
    switch (SYMBOL_CLASS (sym))
d4623 7
a4629 22
      case LOC_REGISTER:
      case LOC_ARG:
      case LOC_REF_ARG:
      case LOC_REGPARM:
      case LOC_REGPARM_ADDR:
      case LOC_LOCAL:
      case LOC_TYPEDEF:
      case LOC_LOCAL_ARG:
      case LOC_BASEREG:
      case LOC_BASEREG_ARG:
      case LOC_COMPUTED:
      case LOC_COMPUTED_ARG:
	for (j = FIRST_LOCAL_BLOCK;
	     j < BLOCKVECTOR_NBLOCKS (BLOCKVECTOR (s)); j += 1)
	  {
	    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), j);
	    ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
	      return s;
	  }
	break;
      default:
        break;
a4631 2
  return NULL;
}
d4633 40
a4672 4
/* Return a minimal symbol matching NAME according to Ada decoding
   rules.  Returns NULL if there is no such minimal symbol.  Names 
   prefixed with "standard__" are handled specially: "standard__" is 
   first stripped off, and only static and global symbols are searched.  */
d4674 2
a4675 6
struct minimal_symbol *
ada_lookup_simple_minsym (const char *name)
{
  struct objfile *objfile;
  struct minimal_symbol *msymbol;
  int wild_match;
d4677 3
a4679 7
  if (strncmp (name, "standard__", sizeof ("standard__") - 1) == 0)
    {
      name += sizeof ("standard__") - 1;
      wild_match = 0;
    }
  else
    wild_match = (strstr (name, "__") == NULL);
d4681 2
a4682 6
  ALL_MSYMBOLS (objfile, msymbol)
  {
    if (ada_match_name (SYMBOL_LINKAGE_NAME (msymbol), name, wild_match)
        && MSYMBOL_TYPE (msymbol) != mst_solib_trampoline)
      return msymbol;
  }
d4684 1
a4684 1
  return NULL;
d4687 7
a4693 2
/* Return up minimal symbol for NAME, folded and encoded according to 
   Ada conventions, or NULL if none.  The last two arguments are ignored.  */
a4694 6
static struct minimal_symbol *
ada_lookup_minimal_symbol (const char *name, const char *sfile,
			   struct objfile *objf)
{
  return ada_lookup_simple_minsym (ada_encode (name));
}
d4696 4
a4699 10
/* For all subprograms that statically enclose the subprogram of the
   selected frame, add symbols matching identifier NAME in DOMAIN
   and their blocks to the list of data in OBSTACKP, as for
   ada_add_block_symbols (q.v.).   If WILD, treat as NAME with a
   wildcard prefix.  */

static void
add_symbols_from_enclosing_procs (struct obstack *obstackp,
				  const char *name, domain_enum namespace,
                                  int wild_match)
d4701 2
a4702 8
#ifdef HAVE_ADD_SYMBOLS_FROM_ENCLOSING_PROCS
  /* Use a heuristic to find the frames of enclosing subprograms: treat the
     pointer-sized value at location 0 from the local-variable base of a
     frame as a static link, and then search up the call stack for a
     frame with that same local-variable base.  */
  static struct symbol static_link_sym;
  static struct symbol *static_link;
  struct value *target_link_val;
d4704 2
a4705 2
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  struct frame_info *frame;
d4707 4
a4710 2
  if (! target_has_stack)
    return;
d4712 2
a4713 13
  if (static_link == NULL)
    {
      /* Initialize the local variable symbol that stands for the
         static link (when there is one).  */
      static_link = &static_link_sym;
      SYMBOL_LINKAGE_NAME (static_link) = "";
      SYMBOL_LANGUAGE (static_link) = language_unknown;
      SYMBOL_CLASS (static_link) = LOC_LOCAL;
      SYMBOL_DOMAIN (static_link) = VAR_DOMAIN;
      SYMBOL_TYPE (static_link) = lookup_pointer_type (builtin_type_void);
      SYMBOL_VALUE (static_link) =
        -(long) TYPE_LENGTH (SYMBOL_TYPE (static_link));
    }
d4715 1
a4715 9
  frame = get_selected_frame ();
  if (frame == NULL
      || inside_main_func (get_frame_address_in_block (frame)))
    return;

  target_link_val = read_var_value (static_link, frame);
  while (target_link_val != NULL
	 && num_defns_collected (obstackp) == 0 
	 && frame_relative_level (frame) <= MAX_ENCLOSING_FRAME_LEVELS)
d4717 2
a4718 7
      CORE_ADDR target_link = value_as_address (target_link_val);

      frame = get_prev_frame (frame);
      if (frame == NULL)
	break;

      if (get_frame_locals_address (frame) == target_link)
d4720 4
a4723 3
	  struct block *block;
      
	  QUIT;
d4725 3
a4727 3
	  block = get_frame_block (frame, 0);
	  while (block != NULL && block_function (block) != NULL 
		 && num_defns_collected (obstackp) == 0)
d4729 9
a4737 6
	      QUIT;

	      ada_add_block_symbols (obstackp, block, name, namespace,
				     NULL, NULL, wild_match);
	      
	      block = BLOCK_SUPERBLOCK (block);
d4740 2
a4741 4
    }

  do_cleanups (old_chain);
#endif
d4744 6
a4749 3
/* FIXME: The next two routines belong in symtab.c */

static void restore_language (void* lang)
d4751 4
a4754 1
  set_language ((enum language) lang);
a4756 2
/* As for lookup_symbol, but performed as if the current language 
   were LANG. */
d4758 4
a4761 13
struct symbol *
lookup_symbol_in_language (const char *name, const struct block *block,
			   domain_enum domain, enum language lang,
			   int *is_a_field_of_this, struct symtab **symtab)
{
  struct cleanup *old_chain 
    = make_cleanup (restore_language, (void*) current_language->la_language);
  struct symbol *result;
  set_language (lang);
  result = lookup_symbol (name, block, domain, is_a_field_of_this, symtab);
  do_cleanups (old_chain);
  return result;
}
d4763 4
a4766 72
/* True if TYPE is definitely an artificial type supplied to a symbol
   for which no debugging information was given in the symbol file.  */

static int
is_nondebugging_type (struct type *type)
{
  char *name = ada_type_name (type);
  return (name != NULL && strcmp (name, "<variable, no debug info>") == 0);
}

/* Remove any non-debugging symbols in SYMS[0 .. NSYMS-1] that definitely
   duplicate other symbols in the list (The only case I know of where
   this happens is when object files containing stabs-in-ecoff are
   linked with files containing ordinary ecoff debugging symbols (or no
   debugging symbols)).  Modifies SYMS to squeeze out deleted entries.
   Returns the number of items in the modified list.  */

static int
remove_extra_symbols (struct ada_symbol_info *syms, int nsyms)
{
  int i, j;

  i = 0;
  while (i < nsyms)
    {
      if (SYMBOL_LINKAGE_NAME (syms[i].sym) != NULL
          && SYMBOL_CLASS (syms[i].sym) == LOC_STATIC
          && is_nondebugging_type (SYMBOL_TYPE (syms[i].sym)))
        {
          for (j = 0; j < nsyms; j += 1)
            {
              if (i != j
                  && SYMBOL_LINKAGE_NAME (syms[j].sym) != NULL
                  && strcmp (SYMBOL_LINKAGE_NAME (syms[i].sym),
			     SYMBOL_LINKAGE_NAME (syms[j].sym)) == 0
                  && SYMBOL_CLASS (syms[i].sym) == SYMBOL_CLASS (syms[j].sym)
                  && SYMBOL_VALUE_ADDRESS (syms[i].sym)
                  == SYMBOL_VALUE_ADDRESS (syms[j].sym))
                {
                  int k;
                  for (k = i + 1; k < nsyms; k += 1)
		    syms[k - 1] = syms[k];
                  nsyms -= 1;
                  goto NextSymbol;
                }
            }
        }
      i += 1;
    NextSymbol:
      ;
    }
  return nsyms;
}

/* Given a type that corresponds to a renaming entity, use the type name
   to extract the scope (package name or function name, fully qualified,
   and following the GNAT encoding convention) where this renaming has been
   defined.  The string returned needs to be deallocated after use.  */

static char *
xget_renaming_scope (struct type *renaming_type)
{
  /* The renaming types adhere to the following convention:
     <scope>__<rename>___<XR extension>. 
     So, to extract the scope, we search for the "___XR" extension,
     and then backtrack until we find the first "__".  */
     
  const char *name = type_name_no_tag (renaming_type);
  char *suffix = strstr (name, "___XR");
  char *last;
  int scope_len;
  char *scope;
d4768 6
a4773 2
  /* Now, backtrack a bit until we find the first "__".  Start looking
     at suffix - 3, as the <rename> part is at least one character long.  */
d4775 10
a4784 5
  for (last = suffix - 3; last > name; last--)
    if (last[0] == '_' && last[1] == '_')
      break;
  
  /* Make a copy of scope and return it.  */
d4786 8
a4793 2
  scope_len = last - name;
  scope = (char *) xmalloc ((scope_len + 1) * sizeof (char));
d4795 9
a4803 2
  strncpy (scope, name, scope_len);
  scope[scope_len] = '\0';
d4805 49
a4853 1
  return scope;
d4856 10
a4865 1
/* Return nonzero if NAME corresponds to a package name.  */
d4868 1
a4868 1
is_package_name (const char *name)
d4870 1
a4870 11
  /* Here, We take advantage of the fact that no symbols are generated
     for packages, while symbols are generated for each function.
     So the condition for NAME represent a package becomes equivalent
     to NAME not existing in our list of symbols.  There is only one
     small complication with library-level functions (see below).  */

  char *fun_name;
  
  /* If it is a function that has not been defined at library level,
     then we should be able to look it up in the symbols.  */
  if (standard_lookup (name, NULL, VAR_DOMAIN) != NULL)
d4873 4
a4876 12
  /* Library-level function names start with "_ada_".  See if function
     "_ada_" followed by NAME can be found.  */

  /* Do a quick check that NAME does not contain "__", since library-level
     functions names can not contain "__" in them.  */
  if (strstr (name, "__") != NULL)
    return 0;

  fun_name = (char *) alloca (strlen (name) + 5 + 1);
  xasprintf (&fun_name, "_ada_%s", name);

  return (standard_lookup (fun_name, NULL, VAR_DOMAIN) == NULL);
d4879 4
a4882 2
/* Return nonzero if SYM corresponds to a renaming entity that is
   visible from FUNCTION_NAME.  */
d4885 1
a4885 1
renaming_is_visible (const struct symbol *sym, char *function_name)
d4887 3
a4889 1
  char *scope = xget_renaming_scope (SYMBOL_TYPE (sym));
d4891 6
a4896 1
  make_cleanup (xfree, scope);
d4898 8
a4905 6
  /* If the rename has been defined in a package, then it is visible.  */
  if (is_package_name (scope))
    return 1;

  /* Check that the rename is in the current function scope by checking
     that its name starts with SCOPE.  */
d4907 7
a4913 6
  /* If the function name starts with "_ada_", it means that it is
     a library-level function.  Strip this prefix before doing the
     comparison, as the encoding for the renaming does not contain
     this prefix.  */
  if (strncmp (function_name, "_ada_", 5) == 0)
    function_name += 5;
d4915 5
a4919 2
  return (strncmp (function_name, scope, strlen (scope)) == 0);
}
d4921 10
a4930 12
/* Iterates over the SYMS list and remove any entry that corresponds to
   a renaming entity that is not visible from the function associated
   with CURRENT_BLOCK. 
   
   Rationale:
   GNAT emits a type following a specified encoding for each renaming
   entity.  Unfortunately, STABS currently does not support the definition
   of types that are local to a given lexical block, so all renamings types
   are emitted at library level.  As a consequence, if an application
   contains two renaming entities using the same name, and a user tries to
   print the value of one of these entities, the result of the ada symbol
   lookup will also contain the wrong renaming type.
d4932 1
a4932 16
   This function partially covers for this limitation by attempting to
   remove from the SYMS list renaming symbols that should be visible
   from CURRENT_BLOCK.  However, there does not seem be a 100% reliable
   method with the current information available.  The implementation
   below has a couple of limitations (FIXME: brobecker-2003-05-12):  
   
      - When the user tries to print a rename in a function while there
        is another rename entity defined in a package:  Normally, the
        rename in the function has precedence over the rename in the
        package, so the latter should be removed from the list.  This is
        currently not the case.
        
      - This function will incorrectly remove valid renames if
        the CURRENT_BLOCK corresponds to a function which symbol name
        has been changed by an "Export" pragma.  As a consequence,
        the user will be unable to print such rename entities.  */
d4934 5
a4938 26
static int
remove_out_of_scope_renamings (struct ada_symbol_info *syms,
                               int nsyms,
                               struct block *current_block)
{
  struct symbol *current_function;
  char *current_function_name;
  int i;

  /* Extract the function name associated to CURRENT_BLOCK.
     Abort if unable to do so.  */
   
  if (current_block == NULL)
    return nsyms;
  
  current_function = block_function (current_block);
  if (current_function == NULL)
    return nsyms;

  current_function_name = SYMBOL_LINKAGE_NAME (current_function);
  if (current_function_name == NULL)
    return nsyms;

  /* Check each of the symbols, and remove it from the list if it is
     a type corresponding to a renaming that is out of the scope of
     the current block.  */
d4940 1
a4940 2
  i = 0;
  while (i < nsyms)
d4942 13
a4954 2
      if (ada_is_object_renaming (syms[i].sym)
          && !renaming_is_visible (syms[i].sym, current_function_name))
d4956 4
a4959 4
          int j;
          for (j = i + 1; j < nsyms; j++)
	    syms[j - 1] = syms[j];
          nsyms -= 1;
d4962 6
a4967 1
        i += 1;
d4970 1
a4970 1
  return nsyms;
a4972 13
/* Find symbols in DOMAIN matching NAME0, in BLOCK0 and enclosing
   scope and in global scopes, returning the number of matches.  Sets
   *RESULTS to point to a vector of (SYM,BLOCK,SYMTAB) triples,
   indicating the symbols found and the blocks and symbol tables (if
   any) in which they were found.  This vector are transient---good only to 
   the next call of ada_lookup_symbol_list.  Any non-function/non-enumeral 
   symbol match within the nest of blocks whose innermost member is BLOCK0,
   is the one match returned (no other matches in that or
     enclosing blocks is returned).  If there are any matches in or
   surrounding BLOCK0, then these alone are returned.  Otherwise, the
   search extends to global and file-scope (static) symbol tables.
   Names prefixed with "standard__" are handled specially: "standard__" 
   is first stripped off, and only static and global symbols are searched.  */
d4974 11
a4984 4
int
ada_lookup_symbol_list (const char *name0, const struct block *block0,
                        domain_enum namespace, 
			struct ada_symbol_info **results)
d4986 6
a4992 11
  struct symtab *s;
  struct partial_symtab *ps;
  struct blockvector *bv;
  struct objfile *objfile;
  struct block *block;
  const char *name;
  struct minimal_symbol *msymbol;
  int wild_match;
  int cacheIfUnique;
  int block_depth;
  int ndefns;
d4994 67
a5060 2
  obstack_free (&symbol_list_obstack, NULL);
  obstack_init (&symbol_list_obstack);
d5062 1
a5062 10
  cacheIfUnique = 0;

  /* Search specified block and its superiors.  */

  wild_match = (strstr (name0, "__") == NULL);
  name = name0;
  block = (struct block *) block0; /* FIXME: No cast ought to be
				     needed, but adding const will
				     have a cascade effect.  */
  if (strncmp (name0, "standard__", sizeof ("standard__") - 1) == 0)
d5064 3
a5066 3
      wild_match = 0;
      block = NULL;
      name = name0 + sizeof ("standard__") - 1;
d5069 1
a5069 2
  block_depth = 0;
  while (block != NULL)
d5071 17
a5087 3
      block_depth += 1;
      ada_add_block_symbols (&symbol_list_obstack, block, name, 
			     namespace, NULL, NULL, wild_match);
d5089 27
a5115 4
      /* If we found a non-function match, assume that's the one.  */
      if (is_nonfunction (defns_collected (&symbol_list_obstack, 0),
			  num_defns_collected (&symbol_list_obstack)))
        goto done;
d5117 8
a5124 1
      block = BLOCK_SUPERBLOCK (block);
d5126 3
d5130 5
a5134 5
  /* If no luck so far, try to find NAME as a local symbol in some lexically
     enclosing subprogram.  */
  if (num_defns_collected (&symbol_list_obstack) == 0 && block_depth > 2)
    add_symbols_from_enclosing_procs (&symbol_list_obstack,
				      name, namespace, wild_match);
d5136 4
a5139 1
  /* If we found ANY matches among non-global symbols, we're done.  */
d5141 8
a5148 2
  if (num_defns_collected (&symbol_list_obstack) > 0)
    goto done;
d5150 1
a5150 2
  cacheIfUnique = 1;
  if (lookup_cached_symbol (name0, namespace, &sym, &block, &s))
d5152 3
a5154 3
      if (sym != NULL)
        add_defn_to_vec (&symbol_list_obstack, sym, block, s);
      goto done;
d5157 1
a5157 2
  /* Now add symbols from all global blocks: symbol tables, minimal symbol
     tables, and psymtab's.  */
d5159 2
a5160 10
  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    if (!s->primary)
      continue;
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    ada_add_block_symbols (&symbol_list_obstack, block, name, namespace, 
			   objfile, s, wild_match);
  }
d5162 1
a5162 1
  if (namespace == VAR_DOMAIN)
d5164 11
a5174 32
      ALL_MSYMBOLS (objfile, msymbol)
      {
        if (ada_match_name (SYMBOL_LINKAGE_NAME (msymbol), name, wild_match))
          {
            switch (MSYMBOL_TYPE (msymbol))
              {
              case mst_solib_trampoline:
                break;
              default:
                s = find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol));
                if (s != NULL)
                  {
                    int ndefns0 = num_defns_collected (&symbol_list_obstack);
                    QUIT;
                    bv = BLOCKVECTOR (s);
                    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
                    ada_add_block_symbols (&symbol_list_obstack, block,
                                           SYMBOL_LINKAGE_NAME (msymbol),
                                           namespace, objfile, s, wild_match);
					   
                    if (num_defns_collected (&symbol_list_obstack) == ndefns0)
                      {
                        block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
                        ada_add_block_symbols (&symbol_list_obstack, block,
                                               SYMBOL_LINKAGE_NAME (msymbol),
                                               namespace, objfile, s,
                                               wild_match);
                      }
                  }
              }
          }
      }
d5177 1
a5177 21
  ALL_PSYMTABS (objfile, ps)
  {
    QUIT;
    if (!ps->readin
        && ada_lookup_partial_symbol (ps, name, 1, namespace, wild_match))
      {
        s = PSYMTAB_TO_SYMTAB (ps);
        if (!s->primary)
          continue;
        bv = BLOCKVECTOR (s);
        block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
        ada_add_block_symbols (&symbol_list_obstack, block, name,
			       namespace, objfile, s, wild_match);
      }
  }

  /* Now add symbols from all per-file blocks if we've gotten no hits
     (Not strictly correct, but perhaps better than an error).
     Do the symtabs first, then check the psymtabs.  */

  if (num_defns_collected (&symbol_list_obstack) == 0)
d5179 6
d5186 3
a5188 26
      ALL_SYMTABS (objfile, s)
      {
        QUIT;
        if (!s->primary)
          continue;
        bv = BLOCKVECTOR (s);
        block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
        ada_add_block_symbols (&symbol_list_obstack, block, name, namespace, 
			       objfile, s, wild_match);
      }

      ALL_PSYMTABS (objfile, ps)
      {
        QUIT;
        if (!ps->readin
            && ada_lookup_partial_symbol (ps, name, 0, namespace, wild_match))
          {
            s = PSYMTAB_TO_SYMTAB (ps);
            bv = BLOCKVECTOR (s);
            if (!s->primary)
              continue;
            block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
            ada_add_block_symbols (&symbol_list_obstack, block, name, 
				   namespace, objfile, s, wild_match);
          }
      }
d5191 1
a5191 3
done:
  ndefns = num_defns_collected (&symbol_list_obstack);
  *results = defns_collected (&symbol_list_obstack, 1);
d5193 6
a5198 1
  ndefns = remove_extra_symbols (*results, ndefns);
d5200 3
a5202 2
  if (ndefns == 0)
    cache_symbol (name0, namespace, NULL, NULL, NULL);
d5204 1
a5204 3
  if (ndefns == 1 && cacheIfUnique)
    cache_symbol (name0, namespace, (*results)[0].sym, (*results)[0].block, 
		  (*results)[0].symtab);
d5206 1
a5206 27
  ndefns = remove_out_of_scope_renamings (*results, ndefns,
                                          (struct block *) block0);

  return ndefns;
}

/* Return a symbol in DOMAIN matching NAME, in BLOCK0 and enclosing
   scope and in global scopes, or NULL if none.  NAME is folded and
   encoded first.  Otherwise, the result is as for ada_lookup_symbol_list,
   but is disambiguated by user query if needed.  *IS_A_FIELD_OF_THIS is
   set to 0 and *SYMTAB is set to the symbol table in which the symbol
   was found (in both cases, these assignments occur only if the
   pointers are non-null).  */


struct symbol *
ada_lookup_symbol (const char *name, const struct block *block0,
                   domain_enum namespace, int *is_a_field_of_this,
		   struct symtab **symtab)
{
  struct ada_symbol_info *candidates;
  int n_candidates;

  n_candidates = ada_lookup_symbol_list (ada_encode (ada_fold_name (name)),
                                         block0, namespace, &candidates);

  if (n_candidates == 0)
a5207 2
  else if (n_candidates != 1)
    user_select_syms (candidates, n_candidates, 1);
d5209 2
a5210 2
  if (is_a_field_of_this != NULL)
    *is_a_field_of_this = 0;
d5212 2
a5213 9
  if (symtab != NULL) 
    {
      *symtab = candidates[0].symtab;
      if (*symtab == NULL && candidates[0].block != NULL) 
	{
	  struct objfile *objfile;
	  struct symtab *s;
	  struct block *b;
	  struct blockvector *bv;
d5215 1
a5215 17
	  /* Search the list of symtabs for one which contains the
	     address of the start of this block.  */
	  ALL_SYMTABS (objfile, s)
	    {
	      bv = BLOCKVECTOR (s);
	      b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	      if (BLOCK_START (b) <= BLOCK_START (candidates[0].block)
		  && BLOCK_END (b) > BLOCK_START (candidates[0].block))
		{
		  *symtab = s;
		  return fixup_symbol_section (candidates[0].sym, objfile);
		}
	      return fixup_symbol_section (candidates[0].sym, NULL);
	    }
	}
    }	
  return candidates[0].sym;
d5218 4
a5221 12
static struct symbol *
ada_lookup_symbol_nonlocal (const char *name,
			    const char *linkage_name,
			    const struct block *block,
			    const domain_enum domain,
			    struct symtab **symtab)
{
  if (linkage_name == NULL)
    linkage_name = name;
  return  ada_lookup_symbol (linkage_name, block_static_block (block), domain,
			     NULL, symtab);
}
d5223 16
a5238 13

/* True iff STR is a possible encoded suffix of a normal Ada name
   that is to be ignored for matching purposes.  Suffixes of parallel
   names (e.g., XVE) are not included here.  Currently, the possible suffixes
   are given by either of the regular expression:

   (__[0-9]+)?\.[0-9]+  [nested subprogram suffix, on platforms such as Linux]
   ___[0-9]+            [nested subprogram suffix, on platforms such as HP/UX]
   (X[nb]*)?((\$|__)[0-9](_?[0-9]+)|___(LJM|X([FDBUP].*|R[^T]?)))?$
 */

static int
is_name_suffix (const char *str)
d5240 3
a5242 3
  int k;
  const char *matching;
  const int len = strlen (str);
d5244 2
a5245 10
  /* (__[0-9]+)?\.[0-9]+ */
  matching = str;
  if (len > 3 && str[0] == '_' && str[1] == '_' && isdigit (str[2]))
    {
      matching += 3;
      while (isdigit (matching[0]))
        matching += 1;
      if (matching[0] == '\0')
        return 1;
    }
d5247 2
a5248 8
  if (matching[0] == '.')
    {
      matching += 1;
      while (isdigit (matching[0]))
        matching += 1;
      if (matching[0] == '\0')
        return 1;
    }
d5250 1
a5250 2
  /* ___[0-9]+ */
  if (len > 3 && str[0] == '_' && str[1] == '_' && str[2] == '_')
d5252 2
a5253 5
      matching = str + 3;
      while (isdigit (matching[0]))
        matching += 1;
      if (matching[0] == '\0')
        return 1;
d5255 1
a5255 7

  /* ??? We should not modify STR directly, as we are doing below.  This
     is fine in this case, but may become problematic later if we find
     that this alternative did not work, and want to try matching
     another one from the begining of STR.  Since we modified it, we
     won't be able to find the begining of the string anymore!  */
  if (str[0] == 'X')
d5257 3
a5259 7
      str += 1;
      while (str[0] != '_' && str[0] != '\0')
        {
          if (str[0] != 'n' && str[0] != 'b')
            return 0;
          str += 1;
        }
d5261 1
a5261 3
  if (str[0] == '\000')
    return 1;
  if (str[0] == '_')
d5263 5
a5267 28
      if (str[1] != '_' || str[2] == '\000')
        return 0;
      if (str[2] == '_')
        {
          if (strcmp (str + 3, "LJM") == 0)
            return 1;
          if (str[3] != 'X')
            return 0;
          if (str[4] == 'F' || str[4] == 'D' || str[4] == 'B' ||
              str[4] == 'U' || str[4] == 'P')
            return 1;
          if (str[4] == 'R' && str[5] != 'T')
            return 1;
          return 0;
        }
      if (!isdigit (str[2]))
        return 0;
      for (k = 3; str[k] != '\0'; k += 1)
        if (!isdigit (str[k]) && str[k] != '_')
          return 0;
      return 1;
    }
  if (str[0] == '$' && isdigit (str[1]))
    {
      for (k = 2; str[k] != '\0'; k += 1)
        if (!isdigit (str[k]) && str[k] != '_')
          return 0;
      return 1;
a5268 2
  return 0;
}
d5270 1
a5270 21
/* Return nonzero if the given string starts with a dot ('.')
   followed by zero or more digits.  
   
   Note: brobecker/2003-11-10: A forward declaration has not been
   added at the begining of this file yet, because this function
   is only used to work around a problem found during wild matching
   when trying to match minimal symbol names against symbol names
   obtained from dwarf-2 data.  This function is therefore currently
   only used in wild_match() and is likely to be deleted when the
   problem in dwarf-2 is fixed.  */

static int
is_dot_digits_suffix (const char *str)
{
  if (str[0] != '.')
    return 0;

  str++;
  while (isdigit (str[0]))
    str++;
  return (str[0] == '\0');
d5273 3
a5275 4
/* True if NAME represents a name of the form A1.A2....An, n>=1 and
   PATN[0..PATN_LEN-1] = Ak.Ak+1.....An for some k >= 1.  Ignores
   informational suffixes of NAME (i.e., for which is_name_suffix is
   true).  */
d5277 2
a5278 2
static int
wild_match (const char *patn0, int patn_len, const char *name0)
d5280 17
a5296 3
  int name_len;
  char *name;
  char *patn;
d5298 15
a5312 6
  /* FIXME: brobecker/2003-11-10: For some reason, the symbol name
     stored in the symbol table for nested function names is sometimes
     different from the name of the associated entity stored in
     the dwarf-2 data: This is the case for nested subprograms, where
     the minimal symbol name contains a trailing ".[:digit:]+" suffix,
     while the symbol name from the dwarf-2 data does not.
d5314 6
a5319 16
     Although the DWARF-2 standard documents that entity names stored
     in the dwarf-2 data should be identical to the name as seen in
     the source code, GNAT takes a different approach as we already use
     a special encoding mechanism to convey the information so that
     a C debugger can still use the information generated to debug
     Ada programs.  A corollary is that the symbol names in the dwarf-2
     data should match the names found in the symbol table.  I therefore
     consider this issue as a compiler defect.
     
     Until the compiler is properly fixed, we work-around the problem
     by ignoring such suffixes during the match.  We do so by making
     a copy of PATN0 and NAME0, and then by stripping such a suffix
     if present.  We then perform the match on the resulting strings.  */
  {
    char *dot;
    name_len = strlen (name0);
d5321 4
a5324 5
    name = (char *) alloca ((name_len + 1) * sizeof (char));
    strcpy (name, name0);
    dot = strrchr (name, '.');
    if (dot != NULL && is_dot_digits_suffix (dot))
      *dot = '\0';
d5326 4
a5329 10
    patn = (char *) alloca ((patn_len + 1) * sizeof (char));
    strncpy (patn, patn0, patn_len);
    patn[patn_len] = '\0';
    dot = strrchr (patn, '.');
    if (dot != NULL && is_dot_digits_suffix (dot))
      {
        *dot = '\0';
        patn_len = dot - patn;
      }
  }
d5331 4
a5334 14
  /* Now perform the wild match.  */

  name_len = strlen (name);
  if (name_len >= patn_len + 5 && strncmp (name, "_ada_", 5) == 0
      && strncmp (patn, name + 5, patn_len) == 0
      && is_name_suffix (name + patn_len + 5))
    return 1;

  while (name_len >= patn_len)
    {
      if (strncmp (patn, name, patn_len) == 0
          && is_name_suffix (name + patn_len))
        return 1;
      do
d5336 4
a5339 2
          name += 1;
          name_len -= 1;
d5341 5
a5345 5
      while (name_len > 0
             && name[0] != '.' && (name[0] != '_' || name[1] != '_'));
      if (name_len <= 0)
        return 0;
      if (name[0] == '_')
d5347 4
a5350 4
          if (!islower (name[2]))
            return 0;
          name += 2;
          name_len -= 2;
d5352 1
a5352 8
      else
        {
          if (!islower (name[1]))
            return 0;
          name += 1;
          name_len -= 1;
        }
    }
d5354 4
a5357 2
  return 0;
}
d5359 7
d5367 2
a5368 5
/* Add symbols from BLOCK matching identifier NAME in DOMAIN to
   vector *defn_symbols, updating the list of symbols in OBSTACKP 
   (if necessary).  If WILD, treat as NAME with a wildcard prefix. 
   OBJFILE is the section containing BLOCK.
   SYMTAB is recorded with each symbol added.  */
d5370 4
a5373 13
static void
ada_add_block_symbols (struct obstack *obstackp,
		       struct block *block, const char *name,
                       domain_enum domain, struct objfile *objfile,
                       struct symtab *symtab, int wild)
{
  struct dict_iterator iter;
  int name_len = strlen (name);
  /* A matching argument symbol, if any.  */
  struct symbol *arg_sym;
  /* Set true when we find a matching non-argument symbol.  */
  int found_sym;
  struct symbol *sym;
d5375 1
a5375 36
  arg_sym = NULL;
  found_sym = 0;
  if (wild)
    {
      struct symbol *sym;
      ALL_BLOCK_SYMBOLS (block, iter, sym)
        {
          if (SYMBOL_DOMAIN (sym) == domain &&
              wild_match (name, name_len, SYMBOL_LINKAGE_NAME (sym)))
            {
              switch (SYMBOL_CLASS (sym))
                {
                case LOC_ARG:
                case LOC_LOCAL_ARG:
                case LOC_REF_ARG:
                case LOC_REGPARM:
                case LOC_REGPARM_ADDR:
                case LOC_BASEREG_ARG:
		case LOC_COMPUTED_ARG:
                  arg_sym = sym;
                  break;
                case LOC_UNRESOLVED:
                  continue;
                default:
                  found_sym = 1;
                  add_defn_to_vec (obstackp, 
				   fixup_symbol_section (sym, objfile),
                                   block, symtab);
                  break;
                }
            }
        }
    }
  else
    {
      ALL_BLOCK_SYMBOLS (block, iter, sym)
d5377 3
a5379 28
	  if (SYMBOL_DOMAIN (sym) == domain)
	    {
	      int cmp = strncmp (name, SYMBOL_LINKAGE_NAME (sym), name_len);
	      if (cmp == 0
		  && is_name_suffix (SYMBOL_LINKAGE_NAME (sym) + name_len))
		{
		  switch (SYMBOL_CLASS (sym))
		    {
		    case LOC_ARG:
		    case LOC_LOCAL_ARG:
		    case LOC_REF_ARG:
		    case LOC_REGPARM:
		    case LOC_REGPARM_ADDR:
		    case LOC_BASEREG_ARG:
		    case LOC_COMPUTED_ARG:
		      arg_sym = sym;
		      break;
		    case LOC_UNRESOLVED:
		      break;
		    default:
		      found_sym = 1;
		      add_defn_to_vec (obstackp,
				       fixup_symbol_section (sym, objfile),
				       block, symtab);
		      break;
		    }
		}
	    }
d5383 2
a5384 6
  if (!found_sym && arg_sym != NULL)
    {
      add_defn_to_vec (obstackp, 
		       fixup_symbol_section (arg_sym, objfile),
		       block, symtab);
    }
d5386 11
a5396 4
  if (!wild)
    {
      arg_sym = NULL;
      found_sym = 0;
d5398 14
a5411 5
      ALL_BLOCK_SYMBOLS (block, iter, sym)
	  {
	    if (SYMBOL_DOMAIN (sym) == domain)
	      {
		int cmp;
d5413 2
a5414 8
		cmp = (int) '_' - (int) SYMBOL_LINKAGE_NAME (sym)[0];
		if (cmp == 0)
		  {
		    cmp = strncmp ("_ada_", SYMBOL_LINKAGE_NAME (sym), 5);
		    if (cmp == 0)
		      cmp = strncmp (name, SYMBOL_LINKAGE_NAME (sym) + 5,
				     name_len);
		  }
d5416 2
a5417 27
		if (cmp == 0
		    && is_name_suffix (SYMBOL_LINKAGE_NAME (sym) + name_len + 5))
		  {
		    switch (SYMBOL_CLASS (sym))
		      {
		      case LOC_ARG:
		      case LOC_LOCAL_ARG:
		      case LOC_REF_ARG:
		      case LOC_REGPARM:
		      case LOC_REGPARM_ADDR:
		      case LOC_BASEREG_ARG:
		      case LOC_COMPUTED_ARG:
			arg_sym = sym;
			break;
		      case LOC_UNRESOLVED:
			break;
		      default:
			found_sym = 1;
			add_defn_to_vec (obstackp,
					 fixup_symbol_section (sym, objfile),
					 block, symtab);
			break;
		      }
		  }
	      }
	  end_loop2: ;
	  }
d5419 1
a5419 10
      /* NOTE: This really shouldn't be needed for _ada_ symbols.
         They aren't parameters, right?  */
      if (!found_sym && arg_sym != NULL)
        {
          add_defn_to_vec (obstackp,
			   fixup_symbol_section (arg_sym, objfile),
			   block, symtab);
        }
    }
}
d5421 1
a6123 31
/* If the main procedure is written in Ada, then return its name.
   The result is good until the next call.  Return NULL if the main
   procedure doesn't appear to be in Ada.  */

char *
ada_main_name (void)
{
  struct minimal_symbol *msym;
  CORE_ADDR main_program_name_addr;
  static char main_program_name[1024];
  /* For Ada, the name of the main procedure is stored in a specific
     string constant, generated by the binder.  Look for that symbol,
     extract its address, and then read that string.  If we didn't find
     that string, then most probably the main procedure is not written
     in Ada.  */
  msym = lookup_minimal_symbol (ADA_MAIN_PROGRAM_SYMBOL_NAME, NULL, NULL);

  if (msym != NULL)
    {
      main_program_name_addr = SYMBOL_VALUE_ADDRESS (msym);
      if (main_program_name_addr == 0)
        error ("Invalid address for Ada main program name.");

      extract_string (main_program_name_addr, main_program_name);
      return main_program_name;
    }

  /* The main procedure doesn't seem to be in Ada.  */
  return NULL;
}

a6130 1
#ifdef GNAT_GDB
a6132 3
#else
  return 0;
#endif
a6332 1
#ifdef GNAT_GDB
a6360 3
#else
  return 0;
#endif
a6368 1
#ifdef GNAT_GDB
a6373 1
#endif
d6518 1
a6519 1

d10140 1
a10140 1
#endif
d10176 1
a10176 1
#endif
d10228 1
d10235 2
a10236 2
#endif
  varsize_limit = 65536;
a10238 1
  obstack_init (&cache_space);
@


1.36
log
@ada-exp.y: Synchronize with current ACT sources.
ada-lang.c: Ditto.
ada-lang.h: Ditto.
ada-lex.l: Ditto.
ada-tasks.c: Ditto.
ada-typeprint.c: Ditto.
ada-valprint.c: Ditto.
@
text
@d4447 24
@


1.35
log
@2004-01-23  David Carlton  <carlton@@kealia.com>

	Partial workaround for PR c++/1511:
	* cp-namespace.c: Include frame.h.
	(cp_lookup_transparent_type): New
	(cp_lookup_transparent_type_loop): New.
	* cp-support.h: Declare cp_lookup_transparent_type.
	* symtab.c (basic_lookup_transparent_type): Renamed from
	lookup_transparent_type.
	(lookup_transparent_type): Replace old body by a call to
	current_language->la_lookup_transparent_type.
	* symtab.h: Update copyright.  Declare
	basic_lookup_transparent_type.
	* language.h: Update copyright.
	(struct language_defn): Add la_lookup_transparent_type.
	* language.c: Update copyright.
	(unknown_language_defn): Add basic_lookup_transparent_type.
	(auto_language_defn): Add basic_lookup_transparent_type.
	(local_language_defn): Add basic_lookup_transparent_type.
	* ada-lang.c: Update copyright.
	(ada_language_defn): Add basic_lookup_transparent_type.
	* c-lang.c: Update copyright.
	(c_language_defn): Add basic_lookup_transparent_type.
	(cplus_language_defn): Add basic_lookup_transparent_type.
	(asm_language_defn): Add basic_lookup_transparent_type.
	(minimal_language_defn): Add basic_lookup_transparent_type.
	* f-lang.c: Update copyright.
	(f_language_defn): Add basic_lookup_transparent_type.
	* jv-lang.c: Update copyright.
	(java_language_defn): Add basic_lookup_transparent_type.
	* m2-lang.c: Update copyright.
	(m2_language_defn): Add basic_lookup_transparent_type.
	* objc-lang.c: Update copyright.
	(objc_language_defn): Add basic_lookup_transparent_type.
	* p-lang.c: Update copyright.
	(p_language_defn): Add basic_lookup_transparent_type.
	* scm-lang.c: Update copyright.
	(scm_language_defn): Add basic_lookup_transparent_type.
	* Makefile.in (cp-namespace.o): Depend on frame.h.

2004-01-23  David Carlton  <carlton@@kealia.com>

	* gdb.cp/rtti.exp: Don't include full path in ${srcfile}.  Add
	test for cp_lookup_transparent_type.
	* gdb.cp/rtti1.cc: Update copyright.  Add n2::func and refer_to;
	call them.
@
text
@d2 1
a2 1
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004
d21 1
d27 2
a28 1
#include "defs.h"
d41 2
d44 3
d48 1
d53 26
a78 1
struct cleanup *unresolved_names;
d80 4
a83 1
void extract_string (CORE_ADDR addr, char *buf);
d121 1
a121 1
static struct value *place_on_stack (struct value *, CORE_ADDR *);
d124 1
a124 1
				     CORE_ADDR *);
d127 1
a127 1
					    CORE_ADDR *);
d129 4
a132 2
static void ada_add_block_symbols (struct block *, const char *,
				   domain_enum, struct objfile *, int);
d134 1
a134 1
static void fill_in_ada_prototype (struct symbol *);
d136 2
a137 1
static int is_nonfunction (struct symbol **, int);
d139 3
a141 1
static void add_defn_to_vec (struct symbol *, struct block *);
d149 2
a150 2
static struct value *ada_resolve_subexp (struct expression **, int *, int,
					 struct type *);
d153 1
a153 1
					struct symbol *, struct block *);
d157 3
a159 1
static const char *ada_op_name (enum exp_opcode);
d169 3
d173 1
a173 1
					   const char *);
d176 1
a176 1
				      int *, enum noside);
d185 3
a187 1
						  CORE_ADDR, struct value *);
d190 1
a190 1
					 struct objfile *);
d203 1
a203 1
					     struct value **);
d205 2
a206 2
static struct value *coerce_unspec_val_to_type (struct value *, long,
						struct type *);
d218 3
a220 4
static struct symtabs_and_lines find_sal_from_funcs_and_line (const char *,
							      int,
							      struct symbol
							      **, int);
d222 2
a223 1
static int find_line_in_linetable (struct linetable *, int, struct symbol **,
a227 3
static struct symtabs_and_lines all_sals_for_line (const char *, int,
						   char ***);

d234 2
d240 33
a272 1
static struct symbol *standard_lookup (const char *, domain_enum);
a273 2
extern void markTimeStart (int index);
extern void markTimeStop (int index);
d276 1
a276 2

/* Maximum-sized dynamic type. */
d279 6
a284 1
static const char *ada_completer_word_break_characters =
d286 108
d395 5
a399 2
/* The name of the symbol to use to get the name of the main subprogram */
#define ADA_MAIN_PROGRAM_SYMBOL_NAME "__gnat_ada_main_program_name"
d401 2
a402 1
				/* Utilities */
d404 1
a404 6
/* extract_string
 *
 * read the string located at ADDR from the inferior and store the
 * result into BUF
 */
void
d409 2
a410 2
  /* Loop, reading one byte at a time, until we reach the '\000' 
     end-of-string marker */
d414 1
a414 1
			  buf + char_index * sizeof (char), sizeof (char));
d420 14
d436 1
a436 1
   updating *OLD_VECT and *SIZE as necessary. */
d445 1
a445 1
	*size = min_size;
d451 1
a451 1
   suffix of FIELD_NAME beginning "___" */
d458 4
a461 4
    DEPRECATED_STREQN (field_name, target, len)
    && (field_name[len] == '\0'
	|| (DEPRECATED_STREQN (field_name + len, "___", 3)
	    && !DEPRECATED_STREQ (field_name + strlen (field_name) - 6, "___XVN")));
d465 24
a488 1
/* The length of the prefix of NAME prior to any "___" suffix. */
d499 1
a499 1
	return strlen (name);
d501 1
a501 1
	return p - name;
d505 3
a507 1
/* SUFFIX is a suffix of STR. False if STR is null. */
d516 1
a516 1
  return (len1 >= len2 && DEPRECATED_STREQ (str + len1 - len2, suffix));
d520 3
a522 2
 * is non-null, and whose memory address (in the inferior) is
 * ADDRESS. */
d525 1
a525 1
				 CORE_ADDR address)
d538 2
a539 2
/* The contents of value VAL, beginning at offset OFFSET, treated as a
   value of type TYPE.  The result is an lval in memory if VAL is. */
d542 1
a542 1
coerce_unspec_val_to_type (struct value *val, long offset, struct type *type)
d545 2
a546 4
  if (VALUE_LVAL (val) == lval_memory)
    return value_at_lazy (type,
			  VALUE_ADDRESS (val) + VALUE_OFFSET (val) + offset,
			  NULL);
d549 15
a563 6
      struct value *result = allocate_value (type);
      VALUE_LVAL (result) = not_lval;
      if (VALUE_ADDRESS (val) == 0)
	memcpy (VALUE_CONTENTS_RAW (result), VALUE_CONTENTS (val) + offset,
		TYPE_LENGTH (type) > TYPE_LENGTH (VALUE_TYPE (val))
		? TYPE_LENGTH (VALUE_TYPE (val)) : TYPE_LENGTH (type));
d565 2
a566 5
	{
	  VALUE_ADDRESS (result) =
	    VALUE_ADDRESS (val) + VALUE_OFFSET (val) + offset;
	  VALUE_LAZY (result) = 1;
	}
d589 4
a592 2
/* Perform execute_command on the result of concatenating all
   arguments up to NULL. */
d594 85
a678 1
do_command (const char *arg, ...)
d680 6
a685 17
  int len;
  char *cmd;
  const char *s;
  va_list ap;

  va_start (ap, arg);
  len = 0;
  s = arg;
  cmd = "";
  for (; s != NULL; s = va_arg (ap, const char *))
    {
      char *cmd1;
      len += strlen (s);
      cmd1 = alloca (len + 1);
      strcpy (cmd1, cmd);
      strcat (cmd1, s);
      cmd = cmd1;
d687 1
a687 2
  va_end (ap);
  execute_command (cmd, 0);
d689 1
d691 1
a691 2

				/* Language Selection */
d696 1
a696 1
   MAIN_PST is not used. */
d700 1
a700 1
			     struct partial_symtab *main_pst)
d703 2
a704 4
			     (struct objfile *) NULL) != NULL)
    /*    return language_ada; */
    /* FIXME: language_ada should be defined in defs.h */
    return language_unknown;
d709 1
d711 2
a712 4
				/* Symbols */

/* Table of Ada operators and their GNAT-mangled names.  Last entry is pair 
   of NULLs. */
d739 2
a740 1
/* True if STR should be suppressed in info listings. */
d744 1
a744 1
  if (DEPRECATED_STREQN (str, "_ada_", 5))
d753 1
a753 1
	return 1;
d755 1
a755 1
	suffix = str + strlen (str);
d757 14
a770 14
	if (isupper (*p))
	  {
	    int i;
	    if (p[0] == 'X' && p[-1] != '_')
	      goto OK;
	    if (*p != 'O')
	      return 1;
	    for (i = 0; ada_opname_table[i].mangled != NULL; i += 1)
	      if (DEPRECATED_STREQN (ada_opname_table[i].mangled, p,
			  strlen (ada_opname_table[i].mangled)))
		goto OK;
	    return 1;
	  OK:;
	  }
d775 3
a777 2
/* The "mangled" form of DEMANGLED, according to GNAT conventions.
 * The result is valid until the next call to ada_mangle. */
d779 1
a779 1
ada_mangle (const char *demangled)
d781 2
a782 2
  static char *mangling_buffer = NULL;
  static size_t mangling_buffer_size = 0;
d786 1
a786 1
  if (demangled == NULL)
d789 2
a790 2
  GROW_VECT (mangling_buffer, mangling_buffer_size,
	     2 * strlen (demangled) + 10);
d793 1
a793 1
  for (p = demangled; *p != '\0'; p += 1)
d795 5
a799 5
      if (*p == '.')
	{
	  mangling_buffer[k] = mangling_buffer[k + 1] = '_';
	  k += 2;
	}
d801 2
a802 2
	{
	  const struct ada_opname_map *mapping;
d804 17
a820 16
	  for (mapping = ada_opname_table;
	       mapping->mangled != NULL &&
	       !DEPRECATED_STREQN (mapping->demangled, p, strlen (mapping->demangled));
	       p += 1)
	    ;
	  if (mapping->mangled == NULL)
	    error ("invalid Ada operator name: %s", p);
	  strcpy (mangling_buffer + k, mapping->mangled);
	  k += strlen (mapping->mangled);
	  break;
	}
      else
	{
	  mangling_buffer[k] = *p;
	  k += 1;
	}
d823 2
a824 2
  mangling_buffer[k] = '\0';
  return mangling_buffer;
d828 3
a830 2
 * quotes, unfolded, but with the quotes stripped away.  Result good
 * to next call. */
d849 1
a849 1
	fold_buffer[i] = tolower (name[i]);
d855 5
a859 2
/* Demangle: 
     1. Discard final __{DIGIT}+ or ${DIGIT}+
d863 1
a863 1
     5. Remove everything after first ___ if it is followed by 
a867 2
   The resulting string is valid until the next call of ada_demangle.
  */
d869 6
a874 2
char *
ada_demangle (const char *mangled)
d879 1
a879 1
  char *demangled;
d881 2
a882 2
  static char *demangling_buffer = NULL;
  static size_t demangling_buffer_size = 0;
d884 2
a885 2
  if (DEPRECATED_STREQN (mangled, "_ada_", 5))
    mangled += 5;
d887 1
a887 1
  if (mangled[0] == '_' || mangled[0] == '<')
d890 19
a908 4
  p = strstr (mangled, "___");
  if (p == NULL)
    len0 = strlen (mangled);
  else
d911 1
a911 1
	len0 = p - mangled;
d913 1
a913 1
	goto Suppress;
d915 2
a916 1
  if (len0 > 3 && DEPRECATED_STREQ (mangled + len0 - 3, "TKB"))
d918 2
a919 1
  if (len0 > 1 && DEPRECATED_STREQ (mangled + len0 - 1, "B"))
d922 14
a935 12
  /* Make demangled big enough for possible expansion by operator name. */
  GROW_VECT (demangling_buffer, demangling_buffer_size, 2 * len0 + 1);
  demangled = demangling_buffer;

  if (isdigit (mangled[len0 - 1]))
    {
      for (i = len0 - 2; i >= 0 && isdigit (mangled[i]); i -= 1)
	;
      if (i > 1 && mangled[i] == '_' && mangled[i - 1] == '_')
	len0 = i - 1;
      else if (mangled[i] == '$')
	len0 = i;
d938 2
a939 2
  for (i = 0, j = 0; i < len0 && !isalpha (mangled[i]); i += 1, j += 1)
    demangled[j] = mangled[i];
d944 95
a1038 1
      if (at_start_name && mangled[i] == 'O')
d1040 2
a1041 2
	  int k;
	  for (k = 0; ada_opname_table[k].mangled != NULL; k += 1)
d1043 2
a1044 4
	      int op_len = strlen (ada_opname_table[k].mangled);
	      if (DEPRECATED_STREQN
		  (ada_opname_table[k].mangled + 1, mangled + i + 1,
		   op_len - 1) && !isalnum (mangled[i + op_len]))
d1046 6
a1051 5
		  strcpy (demangled + j, ada_opname_table[k].demangled);
		  at_start_name = 0;
		  i += op_len;
		  j += strlen (ada_opname_table[k].demangled);
		  break;
a1053 2
	  if (ada_opname_table[k].mangled != NULL)
	    continue;
d1055 5
a1059 13
      at_start_name = 0;

      if (i < len0 - 4 && DEPRECATED_STREQN (mangled + i, "TK__", 4))
	i += 2;
      if (mangled[i] == 'X' && i != 0 && isalnum (mangled[i - 1]))
	{
	  do
	    i += 1;
	  while (i < len0 && (mangled[i] == 'b' || mangled[i] == 'n'));
	  if (i < len0)
	    goto Suppress;
	}
      else if (i < len0 - 2 && mangled[i] == '_' && mangled[i + 1] == '_')
d1061 6
a1066 10
	  demangled[j] = '.';
	  at_start_name = 1;
	  i += 2;
	  j += 1;
	}
      else
	{
	  demangled[j] = mangled[i];
	  i += 1;
	  j += 1;
a1068 16
  demangled[j] = '\000';

  for (i = 0; demangled[i] != '\0'; i += 1)
    if (isupper (demangled[i]) || demangled[i] == ' ')
      goto Suppress;

  return demangled;

Suppress:
  GROW_VECT (demangling_buffer, demangling_buffer_size, strlen (mangled) + 3);
  demangled = demangling_buffer;
  if (mangled[0] == '<')
    strcpy (demangled, mangled);
  else
    sprintf (demangled, "<%s>", mangled);
  return demangled;
d1070 6
d1079 5
a1083 5
 * suffixes that encode debugging information or leading _ada_ on
 * SYM_NAME (see is_name_suffix commentary for the debugging
 * information that is ignored).  If WILD, then NAME need only match a
 * suffix of SYM_NAME minus the same suffixes. Also returns 0 if
 * either argument is NULL. */
d1095 5
a1099 5
      return (DEPRECATED_STREQN (sym_name, name, len_name)
	      && is_name_suffix (sym_name + len_name))
	|| (DEPRECATED_STREQN (sym_name, "_ada_", 5)
	    && DEPRECATED_STREQN (sym_name + 5, name, len_name)
	    && is_name_suffix (sym_name + len_name + 5));
d1103 2
a1104 2
/* True (non-zero) iff in Ada mode, the symbol SYM should be
   suppressed in info listings. */
d1112 1
a1112 1
    return is_suppressed_name (DEPRECATED_SYMBOL_NAME (sym));
d1116 1
a1116 1
				/* Arrays */
d1118 1
a1118 2
/* Names of MAX_ADA_DIMENS bounds in P_BOUNDS fields of 
   array descriptors.  */
d1127 1
a1127 1
#define MAX_ADA_DIMENS (sizeof(bound_name) / (2*sizeof(char*)))
d1129 1
a1129 1
/* Like modify_field, but allows bitpos > wordlength. */
d1134 1
a1134 2
  modify_field (addr + sizeof (LONGEST) * bitpos / (8 * sizeof (LONGEST)),
		fieldval, bitpos % (8 * sizeof (LONGEST)), bitsize);
d1138 2
a1139 2
/* The desc_* routines return primitive portions of array descriptors 
   (fat pointers). */
d1142 2
a1143 1
   level of indirection, if needed. */
d1150 3
a1152 1
  if (type != NULL && TYPE_CODE (type) == TYPE_CODE_PTR)
d1158 2
a1159 1
/* True iff TYPE indicates a "thin" array pointer type. */
d1168 2
a1169 1
/* The descriptor type for thin pointer type TYPE. */
d1182 1
a1182 1
	return base_type;
d1184 1
a1184 1
	return alt_type;
d1188 2
a1189 1
/* A pointer to the array data for thin-pointer value VAL. */
d1196 1
a1196 1
		       value_copy (val));
d1199 1
a1199 1
			       VALUE_ADDRESS (val) + VALUE_OFFSET (val));
d1202 2
a1203 1
/* True iff TYPE indicates a "thick" array pointer type. */
d1209 1
a1209 1
	  && lookup_struct_elt_type (type, "P_BOUNDS", 1) != NULL);
d1212 3
a1214 2
/* If TYPE is the type of an array descriptor (fat or thin pointer) or a 
   pointer to one, the type of its bounds data; otherwise, NULL. */
d1228 1
a1228 1
	return NULL;
d1231 1
a1231 1
	return check_typedef (r);
d1237 1
a1237 1
	return check_typedef (TYPE_TARGET_TYPE (check_typedef (r)));
d1243 2
a1244 1
   one, a pointer to its bounds data.   Otherwise NULL. */
d1252 1
a1252 1
	desc_bounds_type (thin_descriptor_type (type));
d1256 1
a1256 1
	error ("Bad GNAT array descriptor");
d1260 1
a1260 1
         the correct calculation is a real pain. FIXME (and fix GCC). */
d1262 1
a1262 1
	addr = value_as_long (arr);
d1264 1
a1264 1
	addr = VALUE_ADDRESS (arr) + VALUE_OFFSET (arr);
d1267 2
a1268 2
	value_from_longest (lookup_pointer_type (bounds_type),
			    addr - TYPE_LENGTH (bounds_type));
d1273 1
a1273 1
			     "Bad GNAT array descriptor");
d1278 3
a1280 2
/* If TYPE is the type of an array-descriptor (fat pointer), the bit
   position of the field containing the address of the bounds data. */
d1288 2
a1289 1
   size of the field containing the address of the bounds data. */
d1301 1
a1301 1
/* If TYPE is the type of an array descriptor (fat or thin pointer) or a 
d1303 3
a1305 2
   pointer-to-array-with-no-bounds type); otherwise,  NULL.  Use
   ada_type_of_array to get an array type with bounds data. */
d1311 1
a1311 1
  /* NOTE: The following is bogus; see comment in desc_bounds. */
d1323 1
d1332 1
a1332 1
			     "Bad GNAT array descriptor");
d1339 2
a1340 1
   position of the field containing the address of the data. */
d1348 2
a1349 1
   size of the field containing the address of the data. */
d1361 1
a1361 1
/* If BOUNDS is an array-bounds structure (or pointer to one), return 
d1363 2
a1364 1
   bound, if WHICH is 1.  The first bound is I=1. */
d1369 1
a1369 1
			   "Bad GNAT array descriptor bounds");
d1374 2
a1375 1
   bound, if WHICH is 1.  The first bound is I=1. */
d1384 3
a1386 2
   bound, if WHICH is 1.  The first bound is I=1. */
static int
d1398 2
a1399 1
   Ith bound (numbering from 1). Otherwise, NULL. */
d1411 3
a1413 2
/* The number of index positions in the array-bounds type TYPE.  0
   if TYPE is NULL. */
d1424 15
a1439 1
/* Non-zero iff type is a simple array type (or pointer to one). */
d1441 1
a1441 1
ada_is_simple_array (struct type *type)
d1447 2
a1448 2
	  || (TYPE_CODE (type) == TYPE_CODE_PTR
	      && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ARRAY));
d1451 2
a1452 1
/* Non-zero iff type belongs to a GNAT array descriptor. */
d1454 1
a1454 1
ada_is_array_descriptor (struct type *type)
d1464 4
a1467 4
	 && TYPE_TARGET_TYPE (data_type) != NULL
	 && TYPE_CODE (TYPE_TARGET_TYPE (data_type)) == TYPE_CODE_ARRAY)
	||
	TYPE_CODE (data_type) == TYPE_CODE_ARRAY)
d1472 1
a1472 1
   descriptor.  (FIXME: This is to compensate for some problems with 
d1474 2
a1475 1
   is still needed. */
d1483 2
a1484 2
	|| lookup_struct_elt_type (type, "P_ARRAY", 1) != NULL)
    && !ada_is_array_descriptor (type);
d1488 1
a1488 1
/* If ARR has a record type in the form of a standard GNAT array descriptor, 
d1490 1
a1490 1
   a pointer-to-array type.  If BOUNDS is non-zero, the bounds data are filled 
d1492 2
a1493 2
   the ARR denotes a null array descriptor and BOUNDS is non-zero, 
   returns NULL.  The result is simply the type of ARR if ARR is not 
d1501 1
a1501 1
  if (!ada_is_array_descriptor (VALUE_TYPE (arr)))
d1518 1
a1518 1
	return check_typedef (VALUE_TYPE (arr));
d1522 1
a1522 1
	return NULL;
d1524 12
a1535 12
	{
	  struct type *range_type = alloc_type (objf);
	  struct type *array_type = alloc_type (objf);
	  struct value *low = desc_one_bound (descriptor, arity, 0);
	  struct value *high = desc_one_bound (descriptor, arity, 1);
	  arity -= 1;

	  create_range_type (range_type, VALUE_TYPE (low),
			     (int) value_as_long (low),
			     (int) value_as_long (high));
	  elt_type = create_array_type (array_type, elt_type, range_type);
	}
d1542 4
a1545 3
   Otherwise, returns either a standard GDB array with bounds set 
   appropriately or, if ARR is a non-null fat pointer, a pointer to a standard 
   GDB array.  Returns NULL if ARR is a null fat pointer. */
d1549 1
a1549 1
  if (ada_is_array_descriptor (VALUE_TYPE (arr)))
d1553 1
a1553 1
	return NULL;
d1564 3
a1566 2
   be ARR itself if it already is in the proper form). */
struct value *
d1569 1
a1569 1
  if (ada_is_array_descriptor (VALUE_TYPE (arr)))
d1573 1
a1573 1
	error ("Bounds unavailable for null array pointer.");
d1584 2
a1585 1
   packing). For other types, is the identity. */
d1594 1
a1594 1
  value_free_to_mark (dummy);
d1598 2
a1599 1
/* Non-zero iff TYPE represents a standard GNAT packed-array type. */
d1605 1
d1618 3
a1620 2
   TYPE_FIELD_BITSIZE values, and with *ELT_BITS set to its total size 
   in bits. */
d1634 1
a1634 1
				    elt_bits);
d1640 1
a1640 1
			   &low_bound, &high_bound) < 0)
d1648 1
a1648 1
	(*elt_bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;
d1651 1
a1651 2
  /*  TYPE_FLAGS (new_type) |= TYPE_FLAG_FIXED_INSTANCE; */
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
d1655 2
a1656 2
/* The array type encoded by TYPE, where ada_is_packed_array_type (TYPE).
 */
d1660 1
a1660 1
  struct symbol **syms;
d1669 2
d1674 2
a1675 9
  /* NOTE: Use ada_lookup_symbol_list because of bug in some versions
   * of gcc (Solaris, e.g.). FIXME when compiler is fixed. */
  n = ada_lookup_symbol_list (name, get_selected_block (NULL),
			      VAR_DOMAIN, &syms, &blocks);
  for (i = 0; i < n; i += 1)
    if (syms[i] != NULL && SYMBOL_CLASS (syms[i]) == LOC_TYPEDEF
	&& DEPRECATED_STREQ (name, ada_type_name (SYMBOL_TYPE (syms[i]))))
      break;
  if (i >= n)
d1677 1
a1677 1
      warning ("could not find bounds information on packed array");
d1680 1
a1680 1
  shadow_type = SYMBOL_TYPE (syms[i]);
d1684 2
a1685 1
      warning ("could not understand bounds information on packed array");
d1691 2
a1692 1
      warning ("could not understand bit size information on packed array");
d1699 1
a1699 1
/* Given that ARR is a struct value* indicating a GNAT packed array,
d1703 1
a1703 1
   type length is set appropriately. */
d1708 1
a1708 1
  struct type *type = decode_packed_array_type (VALUE_TYPE (arr));
d1710 5
d1720 1
a1720 2
  else
    return coerce_unspec_val_to_type (arr, 0, type);
d1725 1
a1725 1
   given in IND.   ARR must be a simple array. */
d1742 22
a1763 22
	  || TYPE_FIELD_BITSIZE (elt_type, 0) == 0)
	error
	  ("attempt to do packed indexing of something other than a packed array");
      else
	{
	  struct type *range_type = TYPE_INDEX_TYPE (elt_type);
	  LONGEST lowerbound, upperbound;
	  LONGEST idx;

	  if (get_discrete_bounds (range_type, &lowerbound, &upperbound) < 0)
	    {
	      warning ("don't know bounds of array");
	      lowerbound = upperbound = 0;
	    }

	  idx = value_as_long (value_pos_atr (ind[i]));
	  if (idx < lowerbound || idx > upperbound)
	    warning ("packed array index %ld out of bounds", (long) idx);
	  bits = TYPE_FIELD_BITSIZE (elt_type, 0);
	  elt_total_bit_offset += (idx - lowerbound) * bits;
	  elt_type = check_typedef (TYPE_TARGET_TYPE (elt_type));
	}
d1769 1
a1769 1
				      bits, elt_type);
d1777 1
a1777 1
/* Non-zero iff TYPE includes negative integer values. */
d1797 5
a1801 5
   assigning through the result will set the field fetched from. OBJ
   may also be NULL, in which case, VALADDR+OFFSET must address the
   start of storage containing the packed value.  The value returned 
   in this case is never an lval.   
   Assumes 0 <= BIT_OFFSET < HOST_CHAR_BIT. */
d1805 2
a1806 2
				int bit_offset, int bit_size,
				struct type *type)
d1809 8
a1816 8
  int src,			/* Index into the source area. */
    targ,			/* Index into the target area. */
    i, srcBitsLeft,		/* Number of source bits left to move. */
    nsrc, ntarg,		/* Number of source and target bytes. */
    unusedLS,			/* Number of bits in next significant
				 * byte of source that are unused. */
    accumSize;			/* Number of meaningful bits in accum */
  unsigned char *bytes;		/* First byte containing data to unpack. */
d1818 1
a1818 1
  unsigned long accum;		/* Staging area for bits being transferred */
d1821 2
a1822 2
  /* Transmit bytes from least to most significant; delta is the
   * direction the indices move. */
d1835 1
a1835 1
		    VALUE_ADDRESS (obj) + VALUE_OFFSET (obj) + offset, NULL);
d1849 1
a1849 1
	VALUE_LVAL (v) = lval_internalvar_component;
d1854 4
a1857 4
	{
	  VALUE_ADDRESS (v) += 1;
	  VALUE_BITPOS (v) -= HOST_CHAR_BIT;
	}
d1876 2
a1877 2
	  ((bytes[0] << bit_offset) & (1 << (HOST_CHAR_BIT - 1))))
	sign = ~0;
d1880 2
a1881 2
	(HOST_CHAR_BIT - (bit_size + bit_offset) % HOST_CHAR_BIT)
	% HOST_CHAR_BIT;
d1884 18
a1901 18
	{
	case TYPE_CODE_ARRAY:
	case TYPE_CODE_UNION:
	case TYPE_CODE_STRUCT:
	  /* Non-scalar values must be aligned at a byte boundary. */
	  accumSize =
	    (HOST_CHAR_BIT - bit_size % HOST_CHAR_BIT) % HOST_CHAR_BIT;
	  /* And are placed at the beginning (most-significant) bytes
	   * of the target. */
	  targ = src;
	  break;
	default:
	  accumSize = 0;
	  targ = TYPE_LENGTH (type) - 1;
	  break;
	}
    }
  else
d1910 1
a1910 1
	sign = ~0;
d1917 1
a1917 1
       * part of the value. */
d1919 3
a1921 3
	(1 << (srcBitsLeft >= HOST_CHAR_BIT ? HOST_CHAR_BIT : srcBitsLeft)) -
	1;
      /* Sign-extend bits for this byte. */
d1924 1
a1924 1
	(((bytes[src] >> unusedLS) & unusedMSMask) | signMask) << accumSize;
d1927 7
a1933 7
	{
	  unpacked[targ] = accum & ~(~0L << HOST_CHAR_BIT);
	  accumSize -= HOST_CHAR_BIT;
	  accum >>= HOST_CHAR_BIT;
	  ntarg -= 1;
	  targ += delta;
	}
d1954 1
a1954 1
   not overlap. */
d1972 18
a1989 18
	{
	  int unused_right;
	  accum = (accum << HOST_CHAR_BIT) + (unsigned char) *source;
	  accum_bits += HOST_CHAR_BIT;
	  source += 1;
	  chunk_size = HOST_CHAR_BIT - targ_offset;
	  if (chunk_size > n)
	    chunk_size = n;
	  unused_right = HOST_CHAR_BIT - (chunk_size + targ_offset);
	  mask = ((1 << chunk_size) - 1) << unused_right;
	  *target =
	    (*target & ~mask)
	    | ((accum >> (accum_bits - chunk_size - unused_right)) & mask);
	  n -= chunk_size;
	  accum_bits -= chunk_size;
	  target += 1;
	  targ_offset = 0;
	}
d1998 15
a2012 15
	{
	  accum = accum + ((unsigned char) *source << accum_bits);
	  accum_bits += HOST_CHAR_BIT;
	  source += 1;
	  chunk_size = HOST_CHAR_BIT - targ_offset;
	  if (chunk_size > n)
	    chunk_size = n;
	  mask = ((1 << chunk_size) - 1) << targ_offset;
	  *target = (*target & ~mask) | ((accum << targ_offset) & mask);
	  n -= chunk_size;
	  accum_bits -= chunk_size;
	  accum >>= chunk_size;
	  target += 1;
	  targ_offset = 0;
	}
d2020 1
a2020 1
   floating-point or non-scalar types. */
d2036 1
a2036 1
	  || TYPE_CODE (type) == TYPE_CODE_STRUCT))
d2039 1
a2039 1
	(VALUE_BITPOS (toval) + bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;
d2044 1
a2044 1
	fromval = value_cast (type, fromval);
d2048 4
a2051 4
	move_bits (buffer, VALUE_BITPOS (toval),
		   VALUE_CONTENTS (fromval),
		   TYPE_LENGTH (VALUE_TYPE (fromval)) * TARGET_CHAR_BIT -
		   bits, bits);
d2053 2
a2054 2
	move_bits (buffer, VALUE_BITPOS (toval), VALUE_CONTENTS (fromval),
		   0, bits);
d2056 1
a2056 1
		    len);
d2060 1
a2060 1
	      TYPE_LENGTH (type));
d2070 2
a2071 2
/* The value of the element of array ARR at the ARITY indices given in IND. 
   ARR may be either a simple array, GNAT array descriptor, or pointer 
d2091 1
a2091 1
	error ("too many subscripts (%d expected)", k);
d2099 1
a2099 1
   IND. Does not read the entire array into memory. */
d2103 1
a2103 1
			 struct value **ind)
d2113 1
a2113 1
	error ("too many subscripts (%d expected)", k);
d2115 1
a2115 1
			value_copy (arr));
d2117 3
a2119 4
      if (lwb == 0)
	idx = ind[k];
      else
	idx = value_sub (ind[k], value_from_longest (builtin_type_int, lwb));
d2130 1
a2130 1
   type designation. Otherwise, returns 0. */
d2148 2
a2149 2
	arity += 1;
	type = check_typedef (TYPE_TARGET_TYPE (type));
d2158 1
a2158 1
   NINDICES is -1. Otherwise, returns NULL. */
d2174 1
a2174 1
	return NULL;
d2176 1
a2176 1
      /* Initially p_array_type = elt_type(*)[]...(k times)...[] */
d2178 1
a2178 1
	k = nindices;
d2181 4
a2184 4
	{
	  p_array_type = check_typedef (TYPE_TARGET_TYPE (p_array_type));
	  k -= 1;
	}
d2190 4
a2193 4
	{
	  type = TYPE_TARGET_TYPE (type);
	  nindices -= 1;
	}
d2200 2
a2201 2
/* The type of nth index in arrays of given type (n numbering from 1).  Does 
   not examine memory. */
d2206 2
d2213 1
a2213 1
  if (ada_is_simple_array (type))
d2218 8
a2225 1
	type = TYPE_TARGET_TYPE (type);
d2227 1
a2227 1
      return TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 0));
d2235 4
a2238 4
   WHICH is 1. This returns bounds 0 .. -1 if ARR_TYPE is an
   array-descriptor type.  If TYPEP is non-null, *TYPEP is set to the 
   bounds type.  It works for other arrays with bounds supplied by 
   run-time quantities other than discriminants. */
d2242 1
a2242 1
			   struct type ** typep)
d2250 1
a2250 1
  if (arr_type == NULL || !ada_is_simple_array (arr_type))
d2253 1
a2253 1
	*typep = builtin_type_int;
d2269 4
a2272 4
	{
	  type = TYPE_TARGET_TYPE (type);
	  n -= 1;
	}
d2277 1
a2277 1
	index_type = builtin_type_long;
d2279 1
a2279 1
	*typep = index_type;
d2281 3
a2283 3
	(LONGEST) (which == 0
		   ? TYPE_LOW_BOUND (range_type)
		   : TYPE_HIGH_BOUND (range_type));
d2288 2
a2289 2
	to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, n - 1),
			     NULL, TYPE_OBJFILE (arr_type));
d2291 1
a2291 1
	*typep = TYPE_TARGET_TYPE (index_type);
d2293 3
a2295 3
	(LONGEST) (which == 0
		   ? TYPE_LOW_BOUND (index_type)
		   : TYPE_HIGH_BOUND (index_type));
d2301 2
a2302 2
   which is 1. This routine will also work for arrays with bounds
   supplied by run-time quantities other than discriminants. */
d2311 1
a2311 1
  else if (ada_is_simple_array (arr_type))
d2323 3
a2325 3
   supplied by run-time quantities other than discriminants. Does not
   work for arrays indexed by enumeration types with representation
   clauses at the moment. */
a2330 1
  struct type *index_type_desc;
d2335 1
a2335 1
  if (ada_is_simple_array (arr_type))
d2339 2
a2340 2
	ada_array_bound_from_type (arr_type, n, 1, &type) -
	ada_array_bound_from_type (arr_type, n, 0, NULL) + 1;
d2346 14
a2359 4
			  value_as_long (desc_one_bound (desc_bounds (arr),
							 n, 1))
			  - value_as_long (desc_one_bound (desc_bounds (arr),
							   n, 0)) + 1);
d2363 1
a2363 1
				/* Name resolution */
d2365 2
a2366 2
/* The "demangled" name for the user-definable Ada operator corresponding
   to op. */
d2369 1
a2369 1
ada_op_name (enum exp_opcode op)
d2373 1
a2373 1
  for (i = 0; ada_opname_table[i].mangled != NULL; i += 1)
d2376 1
a2376 1
	return ada_opname_table[i].demangled;
d2382 4
a2385 3
/* Same as evaluate_type (*EXP), but resolves ambiguous symbol 
   references (OP_UNRESOLVED_VALUES) and converts operators that are 
   user-defined into appropriate function calls.  If CONTEXT_TYPE is 
d2389 1
a2389 3
   return type is preferred.  The variable unresolved_names contains a list
   of character strings referenced by expout that should be freed.  
   May change (expand) *EXP.  */
d2391 2
a2392 2
void
ada_resolve (struct expression **expp, struct type *context_type)
d2396 1
a2396 1
  ada_resolve_subexp (expp, &pc, 1, context_type);
d2399 8
a2406 7
/* Resolve the operator of the subexpression beginning at 
   position *POS of *EXPP. "Resolving" consists of replacing
   OP_UNRESOLVED_VALUE with an appropriate OP_VAR_VALUE, replacing
   built-in operators with function calls to user-defined operators,
   where appropriate, and (when DEPROCEDURE_P is non-zero), converting
   function-valued variables into parameterless calls.  May expand
   EXP. The CONTEXT_TYPE functions as in ada_resolve, above. */
d2409 2
a2410 2
ada_resolve_subexp (struct expression **expp, int *pos, int deprocedure_p,
		    struct type *context_type)
d2414 1
a2414 1
  struct expression *exp;	/* Convenience: == *expp */
d2416 2
a2417 2
  struct value **argvec;	/* Vector of operand types (alloca'ed). */
  int nargs;			/* Number of operands */
d2423 1
a2423 1
  /* Pass one: resolve operands, saving their types and updating *pos. */
d2426 23
a2448 3
    case OP_VAR_VALUE:
      /*    case OP_UNRESOLVED_VALUE: */
      /* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
d2452 3
a2454 41
    case OP_FUNCALL:
      nargs = longest_to_int (exp->elts[pc + 1].longconst) + 1;
      /* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
      /*      if (exp->elts[pc+3].opcode == OP_UNRESOLVED_VALUE)        
         {
         *pos += 7;

         argvec = (struct value* *) alloca (sizeof (struct value*) * (nargs + 1));
         for (i = 0; i < nargs-1; i += 1)
         argvec[i] = ada_resolve_subexp (expp, pos, 1, NULL);
         argvec[i] = NULL;
         }
         else
         {
         *pos += 3;
         ada_resolve_subexp (expp, pos, 0, NULL);
         for (i = 1; i < nargs; i += 1)
         ada_resolve_subexp (expp, pos, 1, NULL);
         }
       */
      exp = *expp;
      break;

      /* FIXME:  UNOP_QUAL should be defined in expression.h */
      /*    case UNOP_QUAL:
         nargs = 1;
         *pos += 3;
         ada_resolve_subexp (expp, pos, 1, exp->elts[pc + 1].type);
         exp = *expp;
         break;
       */
      /* FIXME:  OP_ATTRIBUTE should be defined in expression.h */
      /*    case OP_ATTRIBUTE:
         nargs = longest_to_int (exp->elts[pc + 1].longconst) + 1;
         *pos += 4;
         for (i = 0; i < nargs; i += 1)
         ada_resolve_subexp (expp, pos, 1, NULL);
         exp = *expp;
         break;
       */
    case UNOP_ADDR:
d2456 13
d2470 1
a2470 2
      ada_resolve_subexp (expp, pos, 0, NULL);
      exp = *expp;
d2475 9
a2483 9
	struct value *arg1;
	nargs = 2;
	*pos += 1;
	arg1 = ada_resolve_subexp (expp, pos, 0, NULL);
	if (arg1 == NULL)
	  ada_resolve_subexp (expp, pos, 1, NULL);
	else
	  ada_resolve_subexp (expp, pos, 1, VALUE_TYPE (arg1));
	break;
d2486 42
a2527 38
    default:
      switch (op)
	{
	default:
	  error ("Unexpected operator during name resolution");
	case UNOP_CAST:
	  /*    case UNOP_MBR:
	     nargs = 1;
	     *pos += 3;
	     break;
	   */
	case BINOP_ADD:
	case BINOP_SUB:
	case BINOP_MUL:
	case BINOP_DIV:
	case BINOP_REM:
	case BINOP_MOD:
	case BINOP_EXP:
	case BINOP_CONCAT:
	case BINOP_LOGICAL_AND:
	case BINOP_LOGICAL_OR:
	case BINOP_BITWISE_AND:
	case BINOP_BITWISE_IOR:
	case BINOP_BITWISE_XOR:

	case BINOP_EQUAL:
	case BINOP_NOTEQUAL:
	case BINOP_LESS:
	case BINOP_GTR:
	case BINOP_LEQ:
	case BINOP_GEQ:

	case BINOP_REPEAT:
	case BINOP_SUBSCRIPT:
	case BINOP_COMMA:
	  nargs = 2;
	  *pos += 1;
	  break;
d2529 5
a2533 8
	case UNOP_NEG:
	case UNOP_PLUS:
	case UNOP_LOGICAL_NOT:
	case UNOP_ABS:
	case UNOP_IND:
	  nargs = 1;
	  *pos += 1;
	  break;
d2535 7
a2541 5
	case OP_LONG:
	case OP_DOUBLE:
	case OP_VAR_VALUE:
	  *pos += 4;
	  break;
d2543 4
a2546 7
	case OP_TYPE:
	case OP_BOOL:
	case OP_LAST:
	case OP_REGISTER:
	case OP_INTERNALVAR:
	  *pos += 3;
	  break;
d2548 4
a2551 4
	case UNOP_MEMVAL:
	  *pos += 3;
	  nargs = 1;
	  break;
d2553 4
a2556 5
	case STRUCTOP_STRUCT:
	case STRUCTOP_PTR:
	  nargs = 1;
	  *pos += 4 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);
	  break;
d2558 5
a2562 22
	case OP_ARRAY:
	  *pos += 4;
	  nargs = longest_to_int (exp->elts[pc + 2].longconst) + 1;
	  nargs -= longest_to_int (exp->elts[pc + 1].longconst);
	  /* A null array contains one dummy element to give the type. */
	  /*      if (nargs == 0)
	     nargs = 1;
	     break; */

	case TERNOP_SLICE:
	  /* FIXME: TERNOP_MBR should be defined in expression.h */
	  /*    case TERNOP_MBR:
	     *pos += 1;
	     nargs = 3;
	     break;
	   */
	  /* FIXME: BINOP_MBR should be defined in expression.h */
	  /*    case BINOP_MBR:
	     *pos += 3;
	     nargs = 2;
	     break; */
	}
d2564 3
a2566 6
      argvec =
	(struct value * *) alloca (sizeof (struct value *) * (nargs + 1));
      for (i = 0; i < nargs; i += 1)
	argvec[i] = ada_resolve_subexp (expp, pos, 1, NULL);
      argvec[i] = NULL;
      exp = *expp;
d2568 3
d2573 8
a2580 1
  /* Pass two: perform any resolution on principal operator. */
d2586 83
a2668 87
      /* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
      /*    case OP_UNRESOLVED_VALUE:
         {
         struct symbol** candidate_syms;
         struct block** candidate_blocks;
         int n_candidates;

         n_candidates = ada_lookup_symbol_list (exp->elts[pc + 2].name,
         exp->elts[pc + 1].block,
         VAR_DOMAIN,
         &candidate_syms,
         &candidate_blocks);

         if (n_candidates > 1) 
         { */
      /* Types tend to get re-introduced locally, so if there
         are any local symbols that are not types, first filter
   out all types. *//*
   int j;
   for (j = 0; j < n_candidates; j += 1) 
   switch (SYMBOL_CLASS (candidate_syms[j])) 
   {
   case LOC_REGISTER:
   case LOC_ARG:
   case LOC_REF_ARG:
   case LOC_REGPARM:
   case LOC_REGPARM_ADDR:
   case LOC_LOCAL:
   case LOC_LOCAL_ARG:
   case LOC_BASEREG:
   case LOC_BASEREG_ARG:
   case LOC_COMPUTED:
   case LOC_COMPUTED_ARG:
   goto FoundNonType;
   default:
   break;
   }
   FoundNonType:
   if (j < n_candidates) 
   {
   j = 0;
   while (j < n_candidates) 
   {
   if (SYMBOL_CLASS (candidate_syms[j]) == LOC_TYPEDEF)
   {
   candidate_syms[j] = candidate_syms[n_candidates-1];
   candidate_blocks[j] = candidate_blocks[n_candidates-1];
   n_candidates -= 1;
   }
   else
   j += 1;
   }
   }
   }

   if (n_candidates == 0)
   error ("No definition found for %s", 
   ada_demangle (exp->elts[pc + 2].name));
   else if (n_candidates == 1)
   i = 0;
   else if (deprocedure_p 
   && ! is_nonfunction (candidate_syms, n_candidates))
   {
   i = ada_resolve_function (candidate_syms, candidate_blocks,
   n_candidates, NULL, 0,
   exp->elts[pc + 2].name, context_type);
   if (i < 0) 
   error ("Could not find a match for %s", 
   ada_demangle (exp->elts[pc + 2].name));
   }
   else 
   {
   printf_filtered ("Multiple matches for %s\n", 
   ada_demangle (exp->elts[pc+2].name));
   user_select_syms (candidate_syms, candidate_blocks, 
   n_candidates, 1);
   i = 0;
   }

   exp->elts[pc].opcode = exp->elts[pc + 3].opcode = OP_VAR_VALUE;
   exp->elts[pc + 1].block = candidate_blocks[i];
   exp->elts[pc + 2].symbol = candidate_syms[i];
   if (innermost_block == NULL ||
   contained_in (candidate_blocks[i], innermost_block))
   innermost_block = candidate_blocks[i];
   } */
      /* FALL THROUGH */
d2670 3
a2672 4
    case OP_VAR_VALUE:
      if (deprocedure_p &&
	  TYPE_CODE (SYMBOL_TYPE (exp->elts[pc + 2].symbol)) ==
	  TYPE_CODE_FUNC)
d2683 31
a2713 32
	/* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
	/*      if (exp->elts[pc+3].opcode == OP_UNRESOLVED_VALUE)      
	   {
	   struct symbol** candidate_syms;
	   struct block** candidate_blocks;
	   int n_candidates;

	   n_candidates = ada_lookup_symbol_list (exp->elts[pc + 5].name,
	   exp->elts[pc + 4].block,
	   VAR_DOMAIN,
	   &candidate_syms,
	   &candidate_blocks);
	   if (n_candidates == 1)
	   i = 0;
	   else
	   {
	   i = ada_resolve_function (candidate_syms, candidate_blocks,
	   n_candidates, argvec, nargs-1,
	   exp->elts[pc + 5].name, context_type);
	   if (i < 0) 
	   error ("Could not find a match for %s", 
	   ada_demangle (exp->elts[pc + 5].name));
	   }

	   exp->elts[pc + 3].opcode = exp->elts[pc + 6].opcode = OP_VAR_VALUE;
	   exp->elts[pc + 4].block = candidate_blocks[i];
	   exp->elts[pc + 5].symbol = candidate_syms[i];
	   if (innermost_block == NULL ||
	   contained_in (candidate_blocks[i], innermost_block))
	   innermost_block = candidate_blocks[i];
	   } */

d2738 18
a2755 4
	{
	  struct symbol **candidate_syms;
	  struct block **candidate_blocks;
	  int n_candidates;
d2757 2
a2758 16
	  n_candidates =
	    ada_lookup_symbol_list (ada_mangle (ada_op_name (op)),
				    (struct block *) NULL, VAR_DOMAIN,
				    &candidate_syms, &candidate_blocks);
	  i =
	    ada_resolve_function (candidate_syms, candidate_blocks,
				  n_candidates, argvec, nargs,
				  ada_op_name (op), NULL);
	  if (i < 0)
	    break;

	  replace_operator_with_call (expp, pc, nargs, 1,
				      candidate_syms[i], candidate_blocks[i]);
	  exp = *expp;
	}
      break;
d2766 3
a2768 2
   MAY_DEREF is non-zero, the formal may be a pointer and the actual 
   a non-pointer. */
d2770 1
a2770 1
   liberal.  FIXME: TOO liberal, in fact. */
d2793 2
a2794 2
	return ada_type_match (TYPE_TARGET_TYPE (ftype),
			       TYPE_TARGET_TYPE (atype), 0);
d2796 2
a2797 2
	return (may_deref &&
		ada_type_match (TYPE_TARGET_TYPE (ftype), atype, 0));
d2802 8
a2809 8
	{
	case TYPE_CODE_INT:
	case TYPE_CODE_ENUM:
	case TYPE_CODE_RANGE:
	  return 1;
	default:
	  return 0;
	}
d2813 1
a2813 1
	      || ada_is_array_descriptor (atype));
d2816 3
a2818 3
      if (ada_is_array_descriptor (ftype))
	return (TYPE_CODE (atype) == TYPE_CODE_ARRAY
		|| ada_is_array_descriptor (atype));
d2820 2
a2821 2
	return (TYPE_CODE (atype) == TYPE_CODE_STRUCT
		&& !ada_is_array_descriptor (atype));
d2832 1
a2832 1
   argument function. */
d2851 6
a2856 2
      struct type *ftype = check_typedef (TYPE_FIELD_TYPE (func_type, i));
      struct type *atype = check_typedef (VALUE_TYPE (actuals[i]));
d2858 3
a2860 3
      if (!ada_type_match (TYPE_FIELD_TYPE (func_type, i),
			   VALUE_TYPE (actuals[i]), 1))
	return 0;
d2878 4
a2881 5
  /* FIXME: base_type should be declared in gdbtypes.h, implemented in valarith.c */
  /*  if (TYPE_CODE (func_type) == TYPE_CODE_FUNC)
     return_type = base_type (TYPE_TARGET_TYPE (func_type));
     else 
     return_type = base_type (func_type); */
d2885 1
a2885 2
  /* FIXME: base_type should be declared in gdbtypes.h, implemented in valarith.c */
  /*  context_type = base_type (context_type); */
d2896 1
a2896 1
/* Return the index in SYMS[0..NSYMS-1] of symbol for the 
d2898 5
a2902 3
   ARGS.  If CONTEXT_TYPE is non-null, and there is at least one match
   that returns type CONTEXT_TYPE, then eliminate other matches.  If
   CONTEXT_TYPE is null, prefer a non-void-returning function.
d2905 2
a2906 3
   solely for messages.   May re-arrange and modify SYMS in
   the process; the index returned is for the modified vector.  BLOCKS
   is modified in parallel to SYMS. */
d2908 4
a2911 4
int
ada_resolve_function (struct symbol *syms[], struct block *blocks[],
		      int nsyms, struct value **args, int nargs,
		      const char *name, struct type *context_type)
d2914 1
a2914 1
  int m;			/* Number of hits */
d2928 2
a2929 2
	{
	  struct type *type = check_typedef (SYMBOL_TYPE (syms[k]));
d2931 7
a2937 9
	  if (ada_args_match (syms[k], args, nargs)
	      && return_match (SYMBOL_TYPE (syms[k]), return_type))
	    {
	      syms[m] = syms[k];
	      if (blocks != NULL)
		blocks[m] = blocks[k];
	      m += 1;
	    }
	}
d2939 1
a2939 1
	break;
d2941 1
a2941 1
	return_type = fallback;
d2949 1
a2949 1
      user_select_syms (syms, blocks, m, 1);
d2955 6
a2960 5
/* Returns true (non-zero) iff demangled name N0 should appear before N1 */
/* in a listing of choices during disambiguation (see sort_choices, below). */
/* The idea is that overloadings of a subprogram name from the */
/* same package should sort in their source order.  We settle for ordering */
/* such symbols by their trailing number (__N  or $N). */
d2962 1
a2962 1
mangled_ordered_before (char *N0, char *N1)
d2972 1
a2972 1
	;
d2974 1
a2974 1
	;
d2976 12
a2987 12
	  && (N1[k1] == '_' || N1[k1] == '$') && N1[k1 + 1] != '\000')
	{
	  int n0, n1;
	  n0 = k0;
	  while (N0[n0] == '_' && n0 > 0 && N0[n0 - 1] == '_')
	    n0 -= 1;
	  n1 = k1;
	  while (N1[n1] == '_' && n1 > 0 && N1[n1 - 1] == '_')
	    n1 -= 1;
	  if (n0 == n1 && DEPRECATED_STREQN (N0, N1, n0))
	    return (atoi (N0 + k0 + 1) < atoi (N1 + k1 + 1));
	}
d2992 3
a2994 3
/* Sort SYMS[0..NSYMS-1] to put the choices in a canonical order by their */
/* mangled names, rearranging BLOCKS[0..NSYMS-1] according to the same */
/* permutation. */
d2996 1
a2996 1
sort_choices (struct symbol *syms[], struct block *blocks[], int nsyms)
d2998 1
a2998 1
  int i, j;
d3001 1
a3001 2
      struct symbol *sym = syms[i];
      struct block *block = blocks[i];
d3005 6
a3010 7
	{
	  if (mangled_ordered_before (DEPRECATED_SYMBOL_NAME (syms[j]),
				      DEPRECATED_SYMBOL_NAME (sym)))
	    break;
	  syms[j + 1] = syms[j];
	  blocks[j + 1] = blocks[j];
	}
a3011 1
      blocks[j + 1] = block;
d3015 4
a3018 6
/* Given a list of NSYMS symbols in SYMS and corresponding blocks in */
/* BLOCKS, select up to MAX_RESULTS>0 by asking the user (if */
/* necessary), returning the number selected, and setting the first */
/* elements of SYMS and BLOCKS to the selected symbols and */
/* corresponding blocks.  Error if no symbols selected.   BLOCKS may */
/* be NULL, in which case it is ignored. */
d3021 1
a3021 1
   to be re-integrated one of these days. */
d3024 1
a3024 2
user_select_syms (struct symbol *syms[], struct block *blocks[], int nsyms,
		  int max_results)
d3040 1
a3040 1
  sort_choices (syms, blocks, nsyms);
d3044 2
a3045 2
      if (syms[i] == NULL)
	continue;
d3047 46
a3092 45
      if (SYMBOL_CLASS (syms[i]) == LOC_BLOCK)
	{
	  struct symtab_and_line sal = find_function_start_sal (syms[i], 1);
	  printf_unfiltered ("[%d] %s at %s:%d\n",
			     i + first_choice,
			     SYMBOL_PRINT_NAME (syms[i]),
			     sal.symtab == NULL
			     ? "<no source file available>"
			     : sal.symtab->filename, sal.line);
	  continue;
	}
      else
	{
	  int is_enumeral =
	    (SYMBOL_CLASS (syms[i]) == LOC_CONST
	     && SYMBOL_TYPE (syms[i]) != NULL
	     && TYPE_CODE (SYMBOL_TYPE (syms[i])) == TYPE_CODE_ENUM);
	  struct symtab *symtab = symtab_for_sym (syms[i]);

	  if (SYMBOL_LINE (syms[i]) != 0 && symtab != NULL)
	    printf_unfiltered ("[%d] %s at %s:%d\n",
			       i + first_choice,
			       SYMBOL_PRINT_NAME (syms[i]),
			       symtab->filename, SYMBOL_LINE (syms[i]));
	  else if (is_enumeral && TYPE_NAME (SYMBOL_TYPE (syms[i])) != NULL)
	    {
	      printf_unfiltered ("[%d] ", i + first_choice);
	      ada_print_type (SYMBOL_TYPE (syms[i]), NULL, gdb_stdout, -1, 0);
	      printf_unfiltered ("'(%s) (enumeral)\n",
				 SYMBOL_PRINT_NAME (syms[i]));
	    }
	  else if (symtab != NULL)
	    printf_unfiltered (is_enumeral
			       ? "[%d] %s in %s (enumeral)\n"
			       : "[%d] %s at %s:?\n",
			       i + first_choice,
			       SYMBOL_PRINT_NAME (syms[i]),
			       symtab->filename);
	  else
	    printf_unfiltered (is_enumeral
			       ? "[%d] %s (enumeral)\n"
			       : "[%d] %s at ?\n",
			       i + first_choice,
			       SYMBOL_PRINT_NAME (syms[i]));
	}
d3096 1
a3096 1
			     "overload-choice");
d3099 1
a3099 5
    {
      syms[i] = syms[chosen[i]];
      if (blocks != NULL)
	blocks[i] = blocks[chosen[i]];
    }
d3105 1
a3105 1
   range 0 .. N_CHOICES-1. Place the results in increasing
d3111 1
a3111 1
     + A choice of 0 means to cancel the selection, throwing an error.  
d3115 1
a3115 1
   The user is not allowed to choose more than MAX_RESULTS values. 
d3118 1
a3118 1
   prompts (for use with the -f switch). */
d3122 1
a3122 1
		int is_all_choice, char *annotation_suffix)
a3123 1
  int i;
d3142 3
a3144 3

  /* Set choices[0 .. n_chosen-1] to the users' choices in ascending 
     order, as given in args.   Choices are validated. */
d3151 1
a3151 1
	args += 1;
d3153 1
a3153 1
	error_no_arg ("one or more choice numbers");
d3155 1
a3155 1
	break;
d3159 2
a3160 2
	  || choice > n_choices + first_choice - 1)
	error ("Argument must be choice number");
d3164 1
a3164 1
	error ("cancelled");
d3167 6
a3172 6
	{
	  n_chosen = n_choices;
	  for (j = 0; j < n_choices; j += 1)
	    choices[j] = j;
	  break;
	}
d3176 2
a3177 2
	{
	}
d3180 7
a3186 7
	{
	  int k;
	  for (k = n_chosen - 1; k > j; k -= 1)
	    choices[k + 1] = choices[k];
	  choices[j + 1] = choice;
	  n_chosen += 1;
	}
d3195 3
a3197 3
/* Replace the operator of length OPLEN at position PC in *EXPP with a call */
/* on the function identified by SYM and BLOCK, and taking NARGS */
/* arguments.  Update *EXPP as needed to hold more space. */
d3201 2
a3202 2
			    int oplen, struct symbol *sym,
			    struct block *block)
d3205 1
a3205 1
     symbol, -oplen for operator being replaced). */
d3208 1
a3208 1
	     + EXP_ELEM_TO_BYTES ((*expp)->nelts + 7 - oplen));
d3215 1
a3215 1
	  EXP_ELEM_TO_BYTES (exp->nelts - pc - oplen));
d3230 2
a3231 2
/* True iff TYPE is numeric (i.e., an INT, RANGE (of numeric type), or */
/* FLOAT.) */
d3241 10
a3250 10
	{
	case TYPE_CODE_INT:
	case TYPE_CODE_FLT:
	  return 1;
	case TYPE_CODE_RANGE:
	  return (type == TYPE_TARGET_TYPE (type)
		  || numeric_type_p (TYPE_TARGET_TYPE (type)));
	default:
	  return 0;
	}
d3254 1
a3254 1
/* True iff TYPE is integral (an INT or RANGE of INTs). */
d3264 9
a3272 9
	{
	case TYPE_CODE_INT:
	  return 1;
	case TYPE_CODE_RANGE:
	  return (type == TYPE_TARGET_TYPE (type)
		  || integer_type_p (TYPE_TARGET_TYPE (type)));
	default:
	  return 0;
	}
d3276 1
a3276 1
/* True iff TYPE is scalar (INT, RANGE, FLOAT, ENUM). */
d3286 9
a3294 9
	{
	case TYPE_CODE_INT:
	case TYPE_CODE_RANGE:
	case TYPE_CODE_ENUM:
	case TYPE_CODE_FLT:
	  return 1;
	default:
	  return 0;
	}
d3298 1
a3298 1
/* True iff TYPE is discrete (INT, RANGE, ENUM). */
d3308 8
a3315 8
	{
	case TYPE_CODE_INT:
	case TYPE_CODE_RANGE:
	case TYPE_CODE_ENUM:
	  return 1;
	default:
	  return 0;
	}
d3319 3
a3321 3
/* Returns non-zero if OP with operatands in the vector ARGS could be
   a user-defined function. Errs on the side of pre-defined operators
   (i.e., result 0). */
d3326 2
a3327 1
  struct type *type0 = check_typedef (VALUE_TYPE (args[0]));
d3331 3
d3362 6
a3367 6
	       (TYPE_CODE (type0) != TYPE_CODE_PTR ||
		TYPE_CODE (TYPE_TARGET_TYPE (type0))
		!= TYPE_CODE_ARRAY))
	      || (TYPE_CODE (type1) != TYPE_CODE_ARRAY &&
		  (TYPE_CODE (type1) != TYPE_CODE_PTR ||
		   TYPE_CODE (TYPE_TARGET_TYPE (type1)) != TYPE_CODE_ARRAY)));
d3381 1
a3381 1
				/* Renaming */
d3383 3
a3385 3
/** NOTE: In the following, we assume that a renaming type's name may
 *  have an ___XD suffix.  It would be nice if this went away at some
 *  point. */
d3388 4
a3391 3
 * is XR for an object renaming, XRP for a procedure renaming, XRE for
 * an exception renaming, and XRS for a subprogram renaming.  Returns
 * NULL if NAME encodes none of these. */
d3400 2
a3401 2
	  || (suffix[5] != '\000' && strchr ("PES_", suffix[5]) == NULL))
	return NULL;
d3403 1
a3403 1
	return suffix + 3;
d3409 2
a3410 1
/* Return non-zero iff SYM encodes an object renaming. */
d3420 4
a3423 3
 * name of the renamed entity.   The name is good until the end of
 * parsing. */
const char *
a3440 2
  /* FIXME: add_name_string_cleanup should be defined in parse.c */
  /*  add_name_string_cleanup (result); */
d3447 1
a3447 1
				/* Evaluation: Function Calls */
d3449 4
a3452 2
/* Copy VAL onto the stack, using and updating *SP as the stack 
   pointer. Return VAL as an lvalue. */
d3455 1
a3455 1
place_on_stack (struct value *val, CORE_ADDR *sp)
d3459 10
a3468 8
#ifdef DEPRECATED_STACK_ALIGN
  *sp = push_bytes (*sp, VALUE_CONTENTS_RAW (val),
		    DEPRECATED_STACK_ALIGN (TYPE_LENGTH
				 (check_typedef (VALUE_TYPE (val)))));
#else
  *sp = push_bytes (*sp, VALUE_CONTENTS_RAW (val),
		    TYPE_LENGTH (check_typedef (VALUE_TYPE (val))));
#endif
d3482 1
a3482 1
   values not residing in memory, updating it as needed. */
d3486 1
a3486 1
		CORE_ADDR *sp)
d3497 1
a3497 1
  if (ada_is_array_descriptor (formal_target)
d3503 2
a3504 2
	  && ada_is_array_descriptor (actual_target))
	return desc_data (actual);
d3506 13
a3518 13
	{
	  if (VALUE_LVAL (actual) != lval_memory)
	    {
	      struct value *val;
	      actual_type = check_typedef (VALUE_TYPE (actual));
	      val = allocate_value (actual_type);
	      memcpy ((char *) VALUE_CONTENTS_RAW (val),
		      (char *) VALUE_CONTENTS (actual),
		      TYPE_LENGTH (actual_type));
	      actual = place_on_stack (val, sp);
	    }
	  return value_addr (actual);
	}
d3527 2
a3528 2
/* Push a descriptor of type TYPE for array value ARR on the stack at 
   *SP, updating *SP to reflect the new descriptor.  Return either 
d3530 2
a3531 2
   to-descriptor type rather than a descriptor type), a struct value*
   representing a pointer to this descriptor. */
a3539 1
  CORE_ADDR bounds_addr;
d3545 3
a3547 3
			    value_as_long (ada_array_bound (arr, i, 0)),
			    desc_bound_bitpos (bounds_type, i, 0),
			    desc_bound_bitsize (bounds_type, i, 0));
d3549 3
a3551 3
			    value_as_long (ada_array_bound (arr, i, 1)),
			    desc_bound_bitpos (bounds_type, i, 1),
			    desc_bound_bitsize (bounds_type, i, 1));
d3554 1
a3554 1
  bounds = place_on_stack (bounds, sp);
d3557 1
a3557 1
			arr,
d3560 1
d3562 3
a3564 3
			VALUE_ADDRESS (bounds),
			fat_pntr_bounds_bitpos (desc_type),
			fat_pntr_bounds_bitsize (desc_type));
d3566 1
a3566 1
  descriptor = place_on_stack (descriptor, sp);
d3575 1
a3575 1
/* Assuming a dummy frame has been established on the target, perform any 
d3577 1
a3577 1
   parameters in ARGS, other than standard C conversions.   Does
d3579 1
a3579 1
   does not match the number of arguments expected.   Use *SP as a
d3581 1
a3581 1
   value as needed. */
d3585 1
a3585 1
		     CORE_ADDR *sp)
d3598 1
d3600 7
a3606 1
				/* Symbol Lookup */
d3608 1
d3610 8
a3617 2
/* The vectors of symbols and blocks ultimately returned from */
/* ada_lookup_symbol_list. */
d3619 1
a3619 2
/* Current size of defn_symbols and defn_blocks */
static size_t defn_vector_size = 0;
d3621 1
a3621 2
/* Current number of symbols found. */
static int ndefns = 0;
d3623 1
a3623 2
static struct symbol **defn_symbols = NULL;
static struct block **defn_blocks = NULL;
d3625 7
a3631 2
/* Return the result of a standard (literal, C-like) lookup of NAME in 
 * given DOMAIN. */
d3633 2
a3634 2
static struct symbol *
standard_lookup (const char *name, domain_enum domain)
d3636 8
a3643 3
  struct symbol *sym;
  sym = lookup_symbol (name, (struct block *) NULL, domain, 0, NULL);
  return sym;
d3646 5
a3651 3
/* Non-zero iff there is at least one non-function/non-enumeral symbol */
/* in SYMS[0..N-1].  We treat enumerals as functions, since they */
/* contend in overloading in the same way. */
d3653 3
a3655 1
is_nonfunction (struct symbol *syms[], int n)
d3657 11
a3667 1
  int i;
d3669 2
a3670 4
  for (i = 0; i < n; i += 1)
    if (TYPE_CODE (SYMBOL_TYPE (syms[i])) != TYPE_CODE_FUNC
	&& TYPE_CODE (SYMBOL_TYPE (syms[i])) != TYPE_CODE_ENUM)
      return 1;
d3672 16
a3687 1
  return 0;
d3689 2
d3692 2
a3693 2
/* If true (non-zero), then TYPE0 and TYPE1 represent equivalent
   struct types.  Otherwise, they may not. */
d3695 37
a3731 2
static int
equiv_types (struct type *type0, struct type *type1)
d3741 1
a3741 1
      && DEPRECATED_STREQ (ada_type_name (type0), ada_type_name (type1)))
d3748 1
a3748 1
   no more defined than that of SYM1. */
d3765 10
a3774 10
	struct type *type0 = SYMBOL_TYPE (sym0);
	struct type *type1 = SYMBOL_TYPE (sym1);
	char *name0 = DEPRECATED_SYMBOL_NAME (sym0);
	char *name1 = DEPRECATED_SYMBOL_NAME (sym1);
	int len0 = strlen (name0);
	return
	  TYPE_CODE (type0) == TYPE_CODE (type1)
	  && (equiv_types (type0, type1)
	      || (len0 < strlen (name1) && DEPRECATED_STREQN (name0, name1, len0)
		  && DEPRECATED_STREQN (name1 + len0, "___XV", 5)));
d3778 1
a3778 1
	&& equiv_types (SYMBOL_TYPE (sym0), SYMBOL_TYPE (sym1));
d3784 2
a3785 3
/* Append SYM to the end of defn_symbols, and BLOCK to the end of
   defn_blocks, updating ndefns, and expanding defn_symbols and
   defn_blocks as needed.   Do not include SYM if it is a duplicate.  */
d3788 4
a3791 1
add_defn_to_vec (struct symbol *sym, struct block *block)
d3795 1
d3799 1
a3799 1
  for (i = 0; i < ndefns; i += 1)
d3801 287
a4087 3
      if (lesseq_defined_than (sym, defn_symbols[i]))
	return;
      else if (lesseq_defined_than (defn_symbols[i], sym))
d4089 3
a4091 3
	  defn_symbols[i] = sym;
	  defn_blocks[i] = block;
	  return;
d4095 34
a4128 7
  tmp = defn_vector_size;
  GROW_VECT (defn_symbols, tmp, ndefns + 2);
  GROW_VECT (defn_blocks, defn_vector_size, ndefns + 2);

  defn_symbols[ndefns] = sym;
  defn_blocks[ndefns] = block;
  ndefns += 1;
d4131 3
a4133 3
/* Look, in partial_symtab PST, for symbol NAME in given domain.
   Check the global symbols if GLOBAL, the static symbols if not.  Do
   wild-card match if WILD. */
d4137 1
a4137 1
			   int global, domain_enum domain, int wild)
d4150 2
a4151 2
	   pst->objfile->global_psymbols.list + pst->globals_offset :
	   pst->objfile->static_psymbols.list + pst->statics_offset);
d4156 2
a4157 2
	{
	  struct partial_symbol *psym = start[i];
d4159 4
a4162 4
	  if (SYMBOL_DOMAIN (psym) == domain &&
	      wild_match (name, name_len, DEPRECATED_SYMBOL_NAME (psym)))
	    return psym;
	}
d4168 18
a4185 18
	{
	  int U;
	  i = 0;
	  U = length - 1;
	  while (U - i > 4)
	    {
	      int M = (U + i) >> 1;
	      struct partial_symbol *psym = start[M];
	      if (DEPRECATED_SYMBOL_NAME (psym)[0] < name[0])
		i = M + 1;
	      else if (DEPRECATED_SYMBOL_NAME (psym)[0] > name[0])
		U = M - 1;
	      else if (strcmp (DEPRECATED_SYMBOL_NAME (psym), name) < 0)
		i = M + 1;
	      else
		U = M;
	    }
	}
d4187 1
a4187 1
	i = 0;
d4190 2
a4191 6
	{
	  struct partial_symbol *psym = start[i];

	  if (SYMBOL_DOMAIN (psym) == domain)
	    {
	      int cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (psym), name_len);
d4193 16
a4208 11
	      if (cmp < 0)
		{
		  if (global)
		    break;
		}
	      else if (cmp == 0
		       && is_name_suffix (DEPRECATED_SYMBOL_NAME (psym) + name_len))
		return psym;
	    }
	  i += 1;
	}
d4211 18
a4228 18
	{
	  int U;
	  i = 0;
	  U = length - 1;
	  while (U - i > 4)
	    {
	      int M = (U + i) >> 1;
	      struct partial_symbol *psym = start[M];
	      if (DEPRECATED_SYMBOL_NAME (psym)[0] < '_')
		i = M + 1;
	      else if (DEPRECATED_SYMBOL_NAME (psym)[0] > '_')
		U = M - 1;
	      else if (strcmp (DEPRECATED_SYMBOL_NAME (psym), "_ada_") < 0)
		i = M + 1;
	      else
		U = M;
	    }
	}
d4230 1
a4230 1
	i = 0;
d4233 2
a4234 26
	{
	  struct partial_symbol *psym = start[i];

	  if (SYMBOL_DOMAIN (psym) == domain)
	    {
	      int cmp;

	      cmp = (int) '_' - (int) DEPRECATED_SYMBOL_NAME (psym)[0];
	      if (cmp == 0)
		{
		  cmp = strncmp ("_ada_", DEPRECATED_SYMBOL_NAME (psym), 5);
		  if (cmp == 0)
		    cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (psym) + 5, name_len);
		}

	      if (cmp < 0)
		{
		  if (global)
		    break;
		}
	      else if (cmp == 0
		       && is_name_suffix (DEPRECATED_SYMBOL_NAME (psym) + name_len + 5))
		return psym;
	    }
	  i += 1;
	}
d4236 25
d4265 1
a4266 1
/* Find a symbol table containing symbol SYM or NULL if none.  */
d4294 1
a4294 1
	break;
d4296 1
a4296 1
	break;
d4321 1
a4321 1
	break;
d4327 4
a4330 2
/* Return a minimal symbol matching NAME according to Ada demangling 
   rules. Returns NULL if there is no such minimal symbol. */
d4333 1
a4333 1
ada_lookup_minimal_symbol (const char *name)
d4337 9
a4345 1
  int wild_match = (strstr (name, "__") == NULL);
d4349 2
a4350 2
    if (ada_match_name (DEPRECATED_SYMBOL_NAME (msymbol), name, wild_match)
	&& MSYMBOL_TYPE (msymbol) != mst_solib_trampoline)
d4357 10
d4368 5
a4372 8
 * selected frame, add symbols matching identifier NAME in DOMAIN
 * and their blocks to vectors *defn_symbols and *defn_blocks, as for
 * ada_add_block_symbols (q.v.).   If WILD, treat as NAME with a
 * wildcard prefix.  At the moment, this function uses a heuristic to
 * find the frames of enclosing subprograms: it treats the
 * pointer-sized value at location 0 from the local-variable base of a
 * frame as a static link, and then searches up the call stack for a
 * frame with that same local-variable base. */
d4374 9
a4382 4
add_symbols_from_enclosing_procs (const char *name, domain_enum domain,
				  int wild_match)
{
#ifdef i386
d4385 1
d4389 3
a4391 1
  struct frame_info *target_frame;
d4396 1
a4396 1
       * static link (when it exists). */
d4398 1
a4398 1
      DEPRECATED_SYMBOL_NAME (static_link) = "";
d4404 1
a4404 1
	-(long) TYPE_LENGTH (SYMBOL_TYPE (static_link));
d4407 9
a4415 2
  frame = deprecated_selected_frame;
  while (frame != NULL && ndefns == 0)
d4417 1
a4417 3
      struct block *block;
      struct value *target_link_val = read_var_value (static_link, frame);
      CORE_ADDR target_link;
d4419 2
a4420 1
      if (target_link_val == NULL)
a4421 1
      QUIT;
d4423 1
a4423 2
      target_link = target_link_val;
      do
d4425 2
a4427 3
	  frame = get_prev_frame (frame);
	}
      while (frame != NULL && DEPRECATED_FRAME_LOCALS_ADDRESS (frame) != target_link);
d4429 5
a4433 2
      if (frame == NULL)
	break;
d4435 5
a4439 6
      block = get_frame_block (frame, 0);
      while (block != NULL && block_function (block) != NULL && ndefns == 0)
	{
	  ada_add_block_symbols (block, name, domain, NULL, wild_match);

	  block = BLOCK_SUPERBLOCK (block);
d4448 2
a4449 1
 * for which no debugging information was given in the symbol file. */
d4454 1
a4454 1
  return (name != NULL && DEPRECATED_STREQ (name, "<variable, no debug info>"));
d4457 7
a4463 8
/* Remove any non-debugging symbols in SYMS[0 .. NSYMS-1] that definitely 
 * duplicate other symbols in the list.  (The only case I know of where
 * this happens is when object files containing stabs-in-ecoff are
 * linked with files containing ordinary ecoff debugging symbols (or no
 * debugging symbols)). Modifies SYMS to squeeze out deleted symbols,
 * and applies the same modification to BLOCKS to maintain the
 * correspondence between SYMS[i] and BLOCKS[i].  Returns the number
 * of symbols in the modified list. */
d4465 1
a4465 1
remove_extra_symbols (struct symbol **syms, struct block **blocks, int nsyms)
d4472 22
a4493 24
      if (DEPRECATED_SYMBOL_NAME (syms[i]) != NULL
	  && SYMBOL_CLASS (syms[i]) == LOC_STATIC
	  && is_nondebugging_type (SYMBOL_TYPE (syms[i])))
	{
	  for (j = 0; j < nsyms; j += 1)
	    {
	      if (i != j
		  && DEPRECATED_SYMBOL_NAME (syms[j]) != NULL
		  && DEPRECATED_STREQ (DEPRECATED_SYMBOL_NAME (syms[i]), DEPRECATED_SYMBOL_NAME (syms[j]))
		  && SYMBOL_CLASS (syms[i]) == SYMBOL_CLASS (syms[j])
		  && SYMBOL_VALUE_ADDRESS (syms[i])
		  == SYMBOL_VALUE_ADDRESS (syms[j]))
		{
		  int k;
		  for (k = i + 1; k < nsyms; k += 1)
		    {
		      syms[k - 1] = syms[k];
		      blocks[k - 1] = blocks[k];
		    }
		  nsyms -= 1;
		  goto NextSymbol;
		}
	    }
	}
d4501 184
a4684 10
/* Find symbols in DOMAIN matching NAME, in BLOCK0 and enclosing 
   scope and in global scopes, returning the number of matches.  Sets 
   *SYMS to point to a vector of matching symbols, with *BLOCKS
   pointing to the vector of corresponding blocks in which those
   symbols reside.  These two vectors are transient---good only to the
   next call of ada_lookup_symbol_list.  Any non-function/non-enumeral symbol
   match within the nest of blocks whose innermost member is BLOCK0,
   is the outermost match returned (no other matches in that or
   enclosing blocks is returned).  If there are any matches in or
   surrounding BLOCK0, then these alone are returned. */
d4687 3
a4689 3
ada_lookup_symbol_list (const char *name, struct block *block0,
			domain_enum domain, struct symbol ***syms,
			struct block ***blocks)
a4695 1
  struct block *b;
d4697 1
d4699 1
a4699 1
  int wild_match = (strstr (name, "__") == NULL);
d4701 2
d4704 2
a4705 3
#ifdef TIMING
  markTimeStart (0);
#endif
a4706 1
  ndefns = 0;
d4711 13
a4723 1
  block = block0;
d4726 8
a4733 5
      ada_add_block_symbols (block, name, domain, NULL, wild_match);

      /* If we found a non-function match, assume that's the one. */
      if (is_nonfunction (defn_symbols, ndefns))
	goto done;
d4738 5
a4742 1
  /* If we found ANY matches in the specified BLOCK, we're done. */
d4744 3
a4746 1
  if (ndefns > 0)
d4750 6
d4758 1
a4758 1
     tables, and psymtab's */
d4767 2
a4768 1
    ada_add_block_symbols (block, name, domain, objfile, wild_match);
d4771 1
a4771 1
  if (domain == VAR_DOMAIN)
d4775 29
a4803 28
	if (ada_match_name (DEPRECATED_SYMBOL_NAME (msymbol), name, wild_match))
	  {
	    switch (MSYMBOL_TYPE (msymbol))
	      {
	      case mst_solib_trampoline:
		break;
	      default:
		s = find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol));
		if (s != NULL)
		  {
		    int old_ndefns = ndefns;
		    QUIT;
		    bv = BLOCKVECTOR (s);
		    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
		    ada_add_block_symbols (block,
					   DEPRECATED_SYMBOL_NAME (msymbol),
					   domain, objfile, wild_match);
		    if (ndefns == old_ndefns)
		      {
			block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
			ada_add_block_symbols (block,
					       DEPRECATED_SYMBOL_NAME (msymbol),
					       domain, objfile,
					       wild_match);
		      }
		  }
	      }
	  }
d4811 1
a4811 1
	&& ada_lookup_partial_symbol (ps, name, 1, domain, wild_match))
d4813 7
a4819 6
	s = PSYMTAB_TO_SYMTAB (ps);
	if (!s->primary)
	  continue;
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	ada_add_block_symbols (block, name, domain, objfile, wild_match);
d4823 1
a4823 1
  /* Now add symbols from all per-file blocks if we've gotten no hits.  
d4825 1
a4825 1
     Do the symtabs first, then check the psymtabs */
d4827 1
a4827 1
  if (ndefns == 0)
d4832 7
a4838 6
	QUIT;
	if (!s->primary)
	  continue;
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	ada_add_block_symbols (block, name, domain, objfile, wild_match);
d4843 12
a4854 12
	QUIT;
	if (!ps->readin
	    && ada_lookup_partial_symbol (ps, name, 0, domain, wild_match))
	  {
	    s = PSYMTAB_TO_SYMTAB (ps);
	    bv = BLOCKVECTOR (s);
	    if (!s->primary)
	      continue;
	    block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	    ada_add_block_symbols (block, name, domain,
				   objfile, wild_match);
	  }
d4858 6
a4863 3
  /* Finally, we try to find NAME as a local symbol in some lexically
     enclosing block.  We do this last, expecting this case to be
     rare. */
d4865 1
a4865 5
    {
      add_symbols_from_enclosing_procs (name, domain, wild_match);
      if (ndefns > 0)
	goto done;
    }
d4867 3
a4869 2
done:
  ndefns = remove_extra_symbols (defn_symbols, defn_blocks, ndefns);
d4871 2
a4873 5
  *syms = defn_symbols;
  *blocks = defn_blocks;
#ifdef TIMING
  markTimeStop (0);
#endif
d4877 8
a4884 5
/* Return a symbol in DOMAIN matching NAME, in BLOCK0 and enclosing 
 * scope and in global scopes, or NULL if none.  NAME is folded to
 * lower case first, unless it is surrounded in single quotes. 
 * Otherwise, the result is as for ada_lookup_symbol_list, but is 
 * disambiguated by user query if needed. */
d4887 3
a4889 2
ada_lookup_symbol (const char *name, struct block *block0,
		   domain_enum domain)
d4891 1
a4891 2
  struct symbol **candidate_syms;
  struct block **candidate_blocks;
d4894 2
a4895 3
  n_candidates = ada_lookup_symbol_list (name,
					 block0, domain,
					 &candidate_syms, &candidate_blocks);
d4900 33
a4932 1
    user_select_syms (candidate_syms, candidate_blocks, n_candidates, 1);
d4934 11
a4944 1
  return candidate_syms[0];
d4948 8
a4955 6
/* True iff STR is a possible encoded suffix of a normal Ada name 
 * that is to be ignored for matching purposes.  Suffixes of parallel
 * names (e.g., XVE) are not included here.  Currently, the possible suffixes 
 * are given by the regular expression:
 *        (X[nb]*)?(__[0-9]+|\$[0-9]+|___(LJM|X([FDBUP].*|R[^T]?)))?$
 * 
d4957 1
d4962 38
d5004 5
a5008 5
	{
	  if (str[0] != 'n' && str[0] != 'b')
	    return 0;
	  str += 1;
	}
d5015 1
a5015 1
	return 0;
d5017 17
a5033 15
	{
	  if (DEPRECATED_STREQ (str + 3, "LJM"))
	    return 1;
	  if (str[3] != 'X')
	    return 0;
	  if (str[4] == 'F' || str[4] == 'D' || str[4] == 'B' ||
	      str[4] == 'U' || str[4] == 'P')
	    return 1;
	  if (str[4] == 'R' && str[5] != 'T')
	    return 1;
	  return 0;
	}
      for (k = 2; str[k] != '\0'; k += 1)
	if (!isdigit (str[k]))
	  return 0;
d5036 1
a5036 1
  if (str[0] == '$' && str[1] != '\000')
d5038 3
a5040 3
      for (k = 1; str[k] != '\0'; k += 1)
	if (!isdigit (str[k]))
	  return 0;
d5046 28
a5073 4
/* True if NAME represents a name of the form A1.A2....An, n>=1 and 
 * PATN[0..PATN_LEN-1] = Ak.Ak+1.....An for some k >= 1.  Ignores
 * informational suffixes of NAME (i.e., for which is_name_suffix is
 * true). */
d5075 1
a5075 1
wild_match (const char *patn, int patn_len, const char *name)
d5078 45
a5122 1
  int s, e;
d5125 2
a5126 2
  if (name_len >= patn_len + 5 && DEPRECATED_STREQN (name, "_ada_", 5)
      && DEPRECATED_STREQN (patn, name + 5, patn_len)
d5132 3
a5134 2
      if (DEPRECATED_STREQN (patn, name, patn_len) && is_name_suffix (name + patn_len))
	return 1;
d5136 4
a5139 4
	{
	  name += 1;
	  name_len -= 1;
	}
d5141 1
a5141 1
	     && name[0] != '.' && (name[0] != '_' || name[1] != '_'));
d5143 1
a5143 1
	return 0;
d5145 13
a5157 13
	{
	  if (!islower (name[2]))
	    return 0;
	  name += 2;
	  name_len -= 2;
	}
      else
	{
	  if (!islower (name[1]))
	    return 0;
	  name += 1;
	  name_len -= 1;
	}
d5164 5
a5168 5
/* Add symbols from BLOCK matching identifier NAME in DOMAIN to 
   vector *defn_symbols, updating *defn_symbols (if necessary), *SZ (the size of
   the vector *defn_symbols), and *ndefns (the number of symbols
   currently stored in *defn_symbols).  If WILD, treat as NAME with a
   wildcard prefix. OBJFILE is the section containing BLOCK. */
d5171 4
a5174 3
ada_add_block_symbols (struct block *block, const char *name,
		       domain_enum domain, struct objfile *objfile,
		       int wild)
d5178 1
a5178 1
  /* A matching argument symbol, if any. */
d5180 1
a5180 1
  /* Set true when we find a matching non-argument symbol */
d5190 26
a5215 25
      {
	if (SYMBOL_DOMAIN (sym) == domain &&
	    wild_match (name, name_len, DEPRECATED_SYMBOL_NAME (sym)))
	  {
	    switch (SYMBOL_CLASS (sym))
	      {
	      case LOC_ARG:
	      case LOC_LOCAL_ARG:
	      case LOC_REF_ARG:
	      case LOC_REGPARM:
	      case LOC_REGPARM_ADDR:
	      case LOC_BASEREG_ARG:
	      case LOC_COMPUTED_ARG:
		arg_sym = sym;
		break;
	      case LOC_UNRESOLVED:
		continue;
	      default:
		found_sym = 1;
		fill_in_ada_prototype (sym);
		add_defn_to_vec (fixup_symbol_section (sym, objfile), block);
		break;
	      }
	  }
      }
d5220 30
a5249 31
	  {
	    if (SYMBOL_DOMAIN (sym) == domain)
	      {
		int cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (sym), name_len);

		if (cmp == 0
		    && is_name_suffix (DEPRECATED_SYMBOL_NAME (sym) + name_len))
		  {
		    switch (SYMBOL_CLASS (sym))
		      {
		      case LOC_ARG:
		      case LOC_LOCAL_ARG:
		      case LOC_REF_ARG:
		      case LOC_REGPARM:
		      case LOC_REGPARM_ADDR:
		      case LOC_BASEREG_ARG:
		      case LOC_COMPUTED_ARG:
			arg_sym = sym;
			break;
		      case LOC_UNRESOLVED:
			break;
		      default:
			found_sym = 1;
			fill_in_ada_prototype (sym);
			add_defn_to_vec (fixup_symbol_section (sym, objfile),
					 block);
			break;
		      }
		  }
	      }
	  }
d5254 3
a5256 2
      fill_in_ada_prototype (arg_sym);
      add_defn_to_vec (fixup_symbol_section (arg_sym, objfile), block);
d5270 1
a5270 1
		cmp = (int) '_' - (int) DEPRECATED_SYMBOL_NAME (sym)[0];
d5273 1
a5273 1
		    cmp = strncmp ("_ada_", DEPRECATED_SYMBOL_NAME (sym), 5);
d5275 2
a5276 1
		      cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (sym) + 5, name_len);
d5280 1
a5280 1
		    && is_name_suffix (DEPRECATED_SYMBOL_NAME (sym) + name_len + 5))
d5297 3
a5299 3
			fill_in_ada_prototype (sym);
			add_defn_to_vec (fixup_symbol_section (sym, objfile),
					 block);
d5304 1
d5308 1
a5308 1
         They aren't parameters, right? */
d5310 5
a5314 100
	{
	  fill_in_ada_prototype (arg_sym);
	  add_defn_to_vec (fixup_symbol_section (arg_sym, objfile), block);
	}
    }
}


				/* Function Types */

/* Assuming that SYM is the symbol for a function, fill in its type 
   with prototype information, if it is not already there.  */

static void
fill_in_ada_prototype (struct symbol *func)
{
  struct block *b;
  int nargs, nsyms;
  struct dict_iterator iter;
  struct type *ftype;
  struct type *rtype;
  size_t max_fields;
  struct symbol *sym;

  if (func == NULL
      || TYPE_CODE (SYMBOL_TYPE (func)) != TYPE_CODE_FUNC
      || TYPE_FIELDS (SYMBOL_TYPE (func)) != NULL)
    return;

  /* We make each function type unique, so that each may have its own */
  /* parameter types.  This particular way of doing so wastes space: */
  /* it would be nicer to build the argument types while the original */
  /* function type is being built (FIXME). */
  rtype = check_typedef (TYPE_TARGET_TYPE (SYMBOL_TYPE (func)));
  ftype = alloc_type (TYPE_OBJFILE (SYMBOL_TYPE (func)));
  make_function_type (rtype, &ftype);
  SYMBOL_TYPE (func) = ftype;

  b = SYMBOL_BLOCK_VALUE (func);

  nargs = 0;
  max_fields = 8;
  TYPE_FIELDS (ftype) =
    (struct field *) xmalloc (sizeof (struct field) * max_fields);
  ALL_BLOCK_SYMBOLS (b, iter, sym)
  {
    GROW_VECT (TYPE_FIELDS (ftype), max_fields, nargs + 1);

    switch (SYMBOL_CLASS (sym))
      {
      case LOC_REF_ARG:
      case LOC_REGPARM_ADDR:
	TYPE_FIELD_BITPOS (ftype, nargs) = nargs;
	TYPE_FIELD_BITSIZE (ftype, nargs) = 0;
	TYPE_FIELD_STATIC_KIND (ftype, nargs) = 0;
	TYPE_FIELD_TYPE (ftype, nargs) =
	  lookup_pointer_type (check_typedef (SYMBOL_TYPE (sym)));
	TYPE_FIELD_NAME (ftype, nargs) = DEPRECATED_SYMBOL_NAME (sym);
	nargs += 1;

	break;

      case LOC_ARG:
      case LOC_REGPARM:
      case LOC_LOCAL_ARG:
      case LOC_BASEREG_ARG:
      case LOC_COMPUTED_ARG:
	TYPE_FIELD_BITPOS (ftype, nargs) = nargs;
	TYPE_FIELD_BITSIZE (ftype, nargs) = 0;
	TYPE_FIELD_STATIC_KIND (ftype, nargs) = 0;
	TYPE_FIELD_TYPE (ftype, nargs) = check_typedef (SYMBOL_TYPE (sym));
	TYPE_FIELD_NAME (ftype, nargs) = DEPRECATED_SYMBOL_NAME (sym);
	nargs += 1;

	break;

      default:
	break;
      }
  }

  /* Re-allocate fields vector; if there are no fields, make the */
  /* fields pointer non-null anyway, to mark that this function type */
  /* has been filled in. */

  TYPE_NFIELDS (ftype) = nargs;
  if (nargs == 0)
    {
      static struct field dummy_field = { 0, 0, 0, 0 };
      xfree (TYPE_FIELDS (ftype));
      TYPE_FIELDS (ftype) = &dummy_field;
    }
  else
    {
      struct field *fields =
	(struct field *) TYPE_ALLOC (ftype, nargs * sizeof (struct field));
      memcpy ((char *) fields,
	      (char *) TYPE_FIELDS (ftype), nargs * sizeof (struct field));
      xfree (TYPE_FIELDS (ftype));
      TYPE_FIELDS (ftype) = fields;
d5318 1
d5320 2
a5321 4
				/* Breakpoint-related */

char no_symtab_msg[] =
  "No symbol table is loaded.  Use the \"file\" command.";
d5325 2
a5326 2
   of that name.  This is the first ':', ' ', or end of LINE. 
*/
d5330 2
a5331 2
  /* [NOTE: strpbrk would be more elegant, but I am reluctant to be
     the first to use such a library function in GDB code.] */
d5342 1
a5342 2
   information in *SPEC and FILE_TABLE in the
   following sense: 
d5346 1
a5346 1
       then the sal refers to that line (or one following it as closely as 
d5348 1
a5348 1
     + If *SPEC does not start with '*', the sal is in a function with 
d5355 1
a5355 1
   to the usual mangling.
d5360 1
a5360 1
   in each function (this is ignored in the presence of a LINENUM spec.).
d5365 3
a5367 3
   list of sals, such that (*CANONICAL)[i] is non-null and contains a 
   canonical line spec for the ith returned sal, if needed.  If no 
   canonical line specs are required and CANONICAL is non-null, 
d5375 1
a5375 1
   identification.  Currently overloaded functions, the name '*', 
d5378 1
a5378 1
   is the caller's responsibility to free them.   */
d5382 1
a5382 1
			  int funfirstline, char ***canonical)
d5384 2
a5385 3
  struct symbol **symbols;
  struct block **blocks;
  struct block *block;
d5390 1
d5396 2
a5397 2
  if (file_table == NULL)
    block = get_selected_block (NULL);
d5404 3
d5412 2
d5415 2
a5416 2
	     !strchr (ada_completer_word_break_characters, **spec))
	*spec += 1;
d5425 1
a5425 1
	*spec += 1;
d5431 1
a5431 1
	error ("Wild-card function with no line number or file name.");
d5433 2
a5434 1
      return all_sals_for_line (file_table->filename, line_num, canonical);
d5457 1
a5457 1
	lower_name[i] = tolower (name[i]);
d5463 2
a5464 2
    n_matches = ada_lookup_symbol_list (ada_mangle (lower_name), block,
					VAR_DOMAIN, &symbols, &blocks);
d5467 1
a5467 1
					VAR_DOMAIN, &symbols, &blocks);
d5476 1
a5476 1
#define volatile		/*nothing */
d5486 1
a5486 1
	msymbol = ada_lookup_minimal_symbol (ada_mangle (lower_name));
d5488 1
a5488 1
	msymbol = ada_lookup_minimal_symbol (unquoted_name);
d5490 14
a5503 14
	{
	  val.pc = SYMBOL_VALUE_ADDRESS (msymbol);
	  val.section = SYMBOL_BFD_SECTION (msymbol);
	  if (funfirstline)
	    {
	      val.pc += FUNCTION_START_OFFSET;
	      SKIP_PROLOGUE (val.pc);
	    }
	  selected.sals = (struct symtab_and_line *)
	    xmalloc (sizeof (struct symtab_and_line));
	  selected.sals[0] = val;
	  selected.nelts = 1;
	  return selected;
	}
d5506 2
a5507 2
	  !have_partial_symbols () && !have_minimal_symbols ())
	error (no_symtab_msg);
d5510 1
a5510 1
      return selected;		/* for lint */
d5515 6
a5520 3
      return
	find_sal_from_funcs_and_line (file_table->filename, line_num,
				      symbols, n_matches);
d5525 1
a5525 1
	user_select_syms (symbols, blocks, n_matches, n_matches);
d5536 10
a5545 7
      if (SYMBOL_CLASS (symbols[i]) == LOC_BLOCK)
	selected.sals[i] = find_function_start_sal (symbols[i], funfirstline);
      else if (SYMBOL_LINE (symbols[i]) != 0)
	{
	  selected.sals[i].symtab = symtab_for_sym (symbols[i]);
	  selected.sals[i].line = SYMBOL_LINE (symbols[i]);
	}
d5547 6
a5552 7
	{
	  /* Ignore this choice */
	  symbols[i] = symbols[selected.nelts - 1];
	  blocks[i] = blocks[selected.nelts - 1];
	  selected.nelts -= 1;
	  continue;
	}
d5554 1
a5554 1
	error ("Line number not known for symbol \"%s\"", unquoted_name);
d5562 3
a5564 3
	(*canonical)[i] =
	  extended_canonical_line_spec (selected.sals[i],
					SYMBOL_PRINT_NAME (symbols[i]));
d5572 3
a5574 2
   with file name FILENAME that occurs in one of the functions listed 
   in SYMBOLS[0 .. NSYMS-1]. */
d5577 1
a5577 1
			      struct symbol **symbols, int nsyms)
d5599 1
a5599 1
    if (!DEPRECATED_STREQ (filename, s->filename))
d5605 14
a5618 14
	if (exact)
	  {
	    best_index = ind;
	    best_linetable = l;
	    best_symtab = s;
	    goto done;
	  }
	if (best == 0 || l->item[ind].line < best)
	  {
	    best = l->item[ind].line;
	    best_index = ind;
	    best_linetable = l;
	    best_symtab = s;
	  }
d5640 4
a5643 2
   pc falls within one of the functions denoted by SYMBOLS[0..NSYMS-1].  
   Set *EXACTP to the 1 if the match is exact, and 0 otherwise. */
d5646 1
a5646 1
			struct symbol **symbols, int nsyms, int *exactp)
d5660 7
a5666 6
	{
	  if (symbols[k] != NULL && SYMBOL_CLASS (symbols[k]) == LOC_BLOCK
	      && item->pc >= BLOCK_START (SYMBOL_BLOCK_VALUE (symbols[k]))
	      && item->pc < BLOCK_END (SYMBOL_BLOCK_VALUE (symbols[k])))
	    goto candidate;
	}
d5672 4
a5675 4
	{
	  *exactp = 1;
	  return i;
	}
d5678 4
a5681 4
	{
	  best = item->line;
	  best_index = i;
	}
d5690 2
a5691 1
   or before LINE_NUM.  Return -1 if there is no such k. */
a5704 1
      int k;
d5708 27
a5734 27
	{
	  char *func_name;
	  CORE_ADDR start, end;

	  func_name = NULL;
	  find_pc_partial_function (item->pc, &func_name, &start, &end);

	  if (func_name != NULL && item->pc < end)
	    {
	      if (item->line == line_num)
		return line_num;
	      else
		{
		  struct symbol *sym =
		    standard_lookup (func_name, VAR_DOMAIN);
		  if (is_plausible_func_for_line (sym, line_num))
		    best = item->line;
		  else
		    {
		      do
			i += 1;
		      while (i < len && linetable->item[i].pc < end);
		      continue;
		    }
		}
	    }
	}
d5743 1
a5743 1
/* Return the next higher index, k, into LINETABLE such that k > IND, 
d5745 1
a5745 1
   corresponds to a PC that is in a function different from that 
d5747 3
a5749 3
   that begins at a line at or preceding STARTING_LINE.  
   Return -1 if there is no such k.  
   IND == -1 corresponds to no function. */
d5753 1
a5753 1
			     int starting_line, int ind)
d5766 5
a5770 5
				    (char **) NULL, &start, &end))
	{
	  while (ind < len && linetable->item[ind].pc < end)
	    ind += 1;
	}
d5772 1
a5772 1
	ind += 1;
a5779 1
      int k;
d5783 23
a5805 23
	{
	  char *func_name;
	  CORE_ADDR start, end;

	  func_name = NULL;
	  find_pc_partial_function (item->pc, &func_name, &start, &end);

	  if (func_name != NULL && item->pc < end)
	    {
	      if (item->line == line_num)
		{
		  struct symbol *sym =
		    standard_lookup (func_name, VAR_DOMAIN);
		  if (is_plausible_func_for_line (sym, starting_line))
		    return i;
		  else
		    {
		      while ((i + 1) < len && linetable->item[i + 1].pc < end)
			i += 1;
		    }
		}
	    }
	}
d5813 2
a5814 1
   LINE_NUM. */
d5828 2
a5829 59
static void
debug_print_lines (struct linetable *lt)
{
  int i;

  if (lt == NULL)
    return;

  fprintf (stderr, "\t");
  for (i = 0; i < lt->nitems; i += 1)
    fprintf (stderr, "(%d->%p) ", lt->item[i].line, (void *) lt->item[i].pc);
  fprintf (stderr, "\n");
}

static void
debug_print_block (struct block *b)
{
  struct dict_iterator iter;
  struct symbol *sym;

  fprintf (stderr, "Block: %p; [0x%lx, 0x%lx]",
	   b, BLOCK_START (b), BLOCK_END (b));
  if (BLOCK_FUNCTION (b) != NULL)
    fprintf (stderr, " Function: %s", DEPRECATED_SYMBOL_NAME (BLOCK_FUNCTION (b)));
  fprintf (stderr, "\n");
  fprintf (stderr, "\t    Superblock: %p\n", BLOCK_SUPERBLOCK (b));
  fprintf (stderr, "\t    Symbols:");
  ALL_BLOCK_SYMBOLS (b, iter, sym)
  {
    fprintf (stderr, " %s", DEPRECATED_SYMBOL_NAME (sym));
  }
  fprintf (stderr, "\n");
}

static void
debug_print_blocks (struct blockvector *bv)
{
  int i;

  if (bv == NULL)
    return;
  for (i = 0; i < BLOCKVECTOR_NBLOCKS (bv); i += 1)
    {
      fprintf (stderr, "%6d. ", i);
      debug_print_block (BLOCKVECTOR_BLOCK (bv, i));
    }
}

static void
debug_print_symtab (struct symtab *s)
{
  fprintf (stderr, "Symtab %p\n    File: %s; Dir: %s\n", s,
	   s->filename, s->dirname);
  fprintf (stderr, "    Blockvector: %p, Primary: %d\n",
	   BLOCKVECTOR (s), s->primary);
  debug_print_blocks (BLOCKVECTOR (s));
  fprintf (stderr, "    Line table: %p\n", LINETABLE (s));
  debug_print_lines (LINETABLE (s));
}
a5830 2
/* Read in all symbol tables corresponding to partial symbol tables
   with file name FILENAME. */
d5841 1
a5841 1
    if (DEPRECATED_STREQ (filename, ps->filename))
d5847 13
a5859 4
   FILENAME, as filtered by the user.  If CANONICAL is not null, set
   it to a corresponding array of canonical line specs. */
static struct symtabs_and_lines
all_sals_for_line (const char *filename, int line_num, char ***canonical)
d5881 1
a5881 1
    if (!DEPRECATED_STREQ (s->filename, filename))
d5892 12
a5903 3
	ind =
	  find_next_line_in_linetable (LINETABLE (s),
				       target_line_num, line_num, ind);
d5905 2
a5906 2
	if (ind < 0)
	  break;
d5908 1
a5908 6
	GROW_VECT (result.sals, len, result.nelts + 1);
	init_sal (&result.sals[result.nelts]);
	result.sals[result.nelts].line = LINETABLE (s)->item[ind].line;
	result.sals[result.nelts].pc = LINETABLE (s)->item[ind].pc;
	result.sals[result.nelts].symtab = s;
	result.nelts += 1;
d5914 1
a5914 1
      int k;
a5916 1
      int n;
d5920 23
a5942 6
	{
	  find_pc_partial_function (result.sals[k].pc, &func_names[k],
				    (CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
	  if (func_names[k] == NULL)
	    error ("Could not find function for one or more breakpoints.");
	}
d5945 44
a5988 7
	{
	  printf_unfiltered ("[0] cancel\n");
	  if (result.nelts > 1)
	    printf_unfiltered ("[1] all\n");
	  for (k = 0; k < result.nelts; k += 1)
	    printf_unfiltered ("[%d] %s\n", k + first_choice,
			       ada_demangle (func_names[k]));
d5990 4
a5993 24
	  n = get_selections (choices, result.nelts, result.nelts,
			      result.nelts > 1, "instance-choice");

	  for (k = 0; k < n; k += 1)
	    {
	      result.sals[k] = result.sals[choices[k]];
	      func_names[k] = func_names[choices[k]];
	    }
	  result.nelts = n;
	}

      if (canonical != NULL)
	{
	  *canonical = (char **) xmalloc (result.nelts * sizeof (char **));
	  make_cleanup (xfree, *canonical);
	  for (k = 0; k < result.nelts; k += 1)
	    {
	      (*canonical)[k] =
		extended_canonical_line_spec (result.sals[k], func_names[k]);
	      if ((*canonical)[k] == NULL)
		error ("Could not locate one or more breakpoints.");
	      make_cleanup (xfree, (*canonical)[k]);
	    }
	}
d5995 2
a5996 2

  discard_cleanups (old_chain);
d6003 2
a6004 2
   information. The caller is responsible for releasing any space
   allocated. */
d6014 131
a6144 4
  r = (char *) xmalloc (strlen (name) + strlen (sal.symtab->filename)
			+ sizeof (sal.line) * 3 + 3);
  sprintf (r, "%s:'%s':%d", sal.symtab->filename, name, sal.line);
  return r;
d6147 2
a6148 4
#if 0
int begin_bnum = -1;
#endif
int begin_annotate_level = 0;
d6150 2
a6151 2
static void
begin_cleanup (void *dummy)
d6153 9
a6161 1
  begin_annotate_level = 0;
d6164 12
a6175 2
static void
begin_command (char *args, int from_tty)
d6177 37
a6213 15
  struct minimal_symbol *msym;
  CORE_ADDR main_program_name_addr;
  char main_program_name[1024];
  struct cleanup *old_chain = make_cleanup (begin_cleanup, NULL);
  begin_annotate_level = 2;

  /* Check that there is a program to debug */
  if (!have_full_symbols () && !have_partial_symbols ())
    error ("No symbol table is loaded.  Use the \"file\" command.");

  /* Check that we are debugging an Ada program */
  /*  if (ada_update_initial_language (language_unknown, NULL) != language_ada)
     error ("Cannot find the Ada initialization procedure.  Is this an Ada main program?");
   */
  /* FIXME: language_ada should be defined in defs.h */
d6215 1
a6215 2
  /* Get the address of the name of the main procedure */
  msym = lookup_minimal_symbol (ADA_MAIN_PROGRAM_SYMBOL_NAME, NULL, NULL);
d6217 6
a6222 5
  if (msym != NULL)
    {
      main_program_name_addr = SYMBOL_VALUE_ADDRESS (msym);
      if (main_program_name_addr == 0)
	error ("Invalid address for Ada main program name.");
d6224 2
a6225 2
      /* Read the name of the main procedure */
      extract_string (main_program_name_addr, main_program_name);
d6227 4
a6230 5
      /* Put a temporary breakpoint in the Ada main program and run */
      do_command ("tbreak ", main_program_name, 0);
      do_command ("run ", args, 0);
    }
  else
d6232 2
a6233 20
      /* If we could not find the symbol containing the name of the
         main program, that means that the compiler that was used to build
         was not recent enough. In that case, we fallback to the previous
         mechanism, which is a little bit less reliable, but has proved to work
         in most cases. The only cases where it will fail is when the user
         has set some breakpoints which will be hit before the end of the
         begin command processing (eg in the initialization code).

         The begining of the main Ada subprogram is located by breaking
         on the adainit procedure. Since we know that the binder generates
         the call to this procedure exactly 2 calls before the call to the
         Ada main subprogram, it is then easy to put a breakpoint on this
         Ada main subprogram once we hit adainit.
       */
      do_command ("tbreak adainit", 0);
      do_command ("run ", args, 0);
      do_command ("up", 0);
      do_command ("tbreak +2", 0);
      do_command ("continue", 0);
      do_command ("step", 0);
d6235 1
d6237 3
a6239 2
  do_cleanups (old_chain);
}
d6241 2
a6242 2
int
is_ada_runtime_file (char *filename)
d6244 12
a6255 3
  return (DEPRECATED_STREQN (filename, "s-", 2) ||
	  DEPRECATED_STREQN (filename, "a-", 2) ||
	  DEPRECATED_STREQN (filename, "g-", 2) || DEPRECATED_STREQN (filename, "i-", 2));
d6258 2
a6259 2
/* find the first frame that contains debugging information and that is not
   part of the Ada run-time, starting from fi and moving upward. */
d6262 1
a6262 1
find_printable_frame (struct frame_info *fi, int level)
d6264 2
a6265 3
  struct symtab_and_line sal;

  for (; fi != NULL; level += 1, fi = get_prev_frame (fi))
d6267 28
a6294 10
      find_frame_sal (fi, &sal);
      if (sal.symtab && !is_ada_runtime_file (sal.symtab->filename))
	{
#if defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET)
	  /* libpthread.so contains some debugging information that prevents us
	     from finding the right frame */

	  if (sal.symtab->objfile &&
	      DEPRECATED_STREQ (sal.symtab->objfile->name, "/usr/shlib/libpthread.so"))
	    continue;
d6296 1
a6296 4
	  deprecated_selected_frame = fi;
	  break;
	}
    }
d6298 2
a6299 2
  return level;
}
d6302 1
a6302 1
ada_report_exception_break (struct breakpoint *b)
d6304 7
a6310 37
  /* FIXME: break_on_exception should be defined in breakpoint.h */
  /*  if (b->break_on_exception == 1)
     {
     /* Assume that cond has 16 elements, the 15th
   being the exception *//*
   if (b->cond && b->cond->nelts == 16)
   {
   ui_out_text (uiout, "on ");
   ui_out_field_string (uiout, "exception",
   SYMBOL_NAME (b->cond->elts[14].symbol));
   }
   else
   ui_out_text (uiout, "on all exceptions");
   }
   else if (b->break_on_exception == 2)
   ui_out_text (uiout, "on unhandled exception");
   else if (b->break_on_exception == 3)
   ui_out_text (uiout, "on assert failure");
   #else
   if (b->break_on_exception == 1)
   { */
  /* Assume that cond has 16 elements, the 15th
   being the exception *//*
   if (b->cond && b->cond->nelts == 16)
   {
   fputs_filtered ("on ", gdb_stdout);
   fputs_filtered (SYMBOL_NAME
   (b->cond->elts[14].symbol), gdb_stdout);
   }
   else
   fputs_filtered ("on all exceptions", gdb_stdout);
   }
   else if (b->break_on_exception == 2)
   fputs_filtered ("on unhandled exception", gdb_stdout);
   else if (b->break_on_exception == 3)
   fputs_filtered ("on assert failure", gdb_stdout);
 */
d6319 3
a6321 3
	  && SYMBOL_CLASS (sym) != LOC_BLOCK
	  && SYMBOL_CLASS (sym) != LOC_CONST
	  && type_name != NULL && DEPRECATED_STREQ (type_name, "exception"));
d6328 47
a6374 2
	  && SYMBOL_CLASS (sym) != LOC_BLOCK
	  && SYMBOL_CLASS (sym) != LOC_CONST);
d6378 1
a6378 1
   into equivalent form.  Return resulting argument string. Set
d6380 2
a6381 1
   break on unhandled, 3 for assert, 0 otherwise. */
d6388 65
a6452 54
  /* FIXME: language_ada should be defined in defs.h */
  /*  if (current_language->la_language == language_ada
     && DEPRECATED_STREQN (arg, "exception", 9) &&
     (arg[9] == ' ' || arg[9] == '\t' || arg[9] == '\0'))
     {
     char *tok, *end_tok;
     int toklen;

     *break_on_exceptionp = 1;

     tok = arg+9;
     while (*tok == ' ' || *tok == '\t')
     tok += 1;

     end_tok = tok;

     while (*end_tok != ' ' && *end_tok != '\t' && *end_tok != '\000')
     end_tok += 1;

     toklen = end_tok - tok;

     arg = (char*) xmalloc (sizeof ("__gnat_raise_nodefer_with_msg if "
     "long_integer(e) = long_integer(&)")
     + toklen + 1);
     make_cleanup (xfree, arg);
     if (toklen == 0)
     strcpy (arg, "__gnat_raise_nodefer_with_msg");
     else if (DEPRECATED_STREQN (tok, "unhandled", toklen))
     {
     *break_on_exceptionp = 2;
     strcpy (arg, "__gnat_unhandled_exception");
     }
     else
     {
     sprintf (arg, "__gnat_raise_nodefer_with_msg if "
     "long_integer(e) = long_integer(&%.*s)", 
     toklen, tok);
     }
     }
     else if (current_language->la_language == language_ada
     && DEPRECATED_STREQN (arg, "assert", 6) &&
     (arg[6] == ' ' || arg[6] == '\t' || arg[6] == '\0'))
     {
     char *tok = arg + 6;

     *break_on_exceptionp = 3;

     arg = (char*) 
     xmalloc (sizeof ("system__assertions__raise_assert_failure")
     + strlen (tok) + 1);
     make_cleanup (xfree, arg);
     sprintf (arg, "system__assertions__raise_assert_failure%s", tok);
     }
   */
d6457 1
a6457 1
				/* Field Access */
d6460 1
a6460 1
   to be invisible to users. */
d6471 1
a6471 1
	      || (name[0] == '_' && !DEPRECATED_STREQN (name, "_parent", 7)));
d6475 10
a6484 1
/* True iff structure type TYPE has a tag field. */
d6487 1
a6487 1
ada_is_tagged_type (struct type *type)
d6489 1
a6489 1
  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT)
d6491 5
a6495 2

  return (ada_lookup_struct_elt_type (type, "_tag", 1, NULL) != NULL);
d6498 1
a6498 1
/* The type of the tag on VAL. */
d6503 1
a6503 1
  return ada_lookup_struct_elt_type (VALUE_TYPE (val), "_tag", 0, NULL);
d6506 1
a6506 1
/* The value of the tag on VAL. */
d6514 78
a6591 1
/* The parent type of TYPE, or NULL if none. */
d6610 3
a6612 3
/* True iff field number FIELD_NUM of structure type TYPE contains the 
   parent-type (inherited) fields of a derived type.  Assumes TYPE is 
   a structure type with at least FIELD_NUM+1 fields. */
d6618 3
a6620 2
  return (name != NULL &&
	  (DEPRECATED_STREQN (name, "PARENT", 6) || DEPRECATED_STREQN (name, "_parent", 7)));
d6623 1
a6623 1
/* True iff field number FIELD_NUM of structure type TYPE is a 
d6625 1
a6625 1
   field selection and flattened when printing).  Assumes TYPE is a 
d6627 1
a6627 1
   structures. */
d6634 4
a6637 3
	  && (DEPRECATED_STREQN (name, "PARENT", 6) || DEPRECATED_STREQ (name, "REP")
	      || DEPRECATED_STREQN (name, "_parent", 7)
	      || name[0] == 'S' || name[0] == 'R' || name[0] == 'O'));
d6640 3
a6642 3
/* True iff field number FIELD_NUM of structure or union type TYPE 
   is a variant wrapper.  Assumes TYPE is a structure type with at least 
   FIELD_NUM+1 fields. */
d6649 3
a6651 3
	  || (is_dynamic_field (type, field_num)
	      && TYPE_CODE (TYPE_TARGET_TYPE (field_type)) ==
	      TYPE_CODE_UNION));
d6655 1
a6655 1
   whose discriminants are contained in the record type OUTER_TYPE, 
d6662 2
a6663 1
  struct type *type = ada_lookup_struct_elt_type (outer_type, name, 1, NULL);
d6670 1
a6670 1
/* Assuming that TYPE is the type of a variant wrapper, and FIELD_NUM is a 
d6672 1
a6672 1
   represents a 'when others' clause; otherwise 0. */
d6682 2
a6683 2
   returns the name of the discriminant controlling the variant.  The
   value is valid until the next call to ada_variant_discrim_name. */
d6708 2
a6709 2
      if (DEPRECATED_STREQN (discrim_end, "___XVN", 6))
	break;
d6718 5
a6722 4
	return "";
      if ((discrim_start > name + 3 && DEPRECATED_STREQN (discrim_start - 3, "___", 3))
	  || discrim_start[-1] == '.')
	break;
d6731 7
a6737 7
/* Scan STR for a subtype-encoded number, beginning at position K. Put the 
   position of the character just past the number scanned in *NEW_K, 
   if NEW_K!=NULL. Put the scanned number in *R, if R!=NULL.  Return 1 
   if there was a valid number at the given position, and 0 otherwise.  A 
   "subtype-encoded" number consists of the absolute value in decimal, 
   followed by the letter 'm' to indicate a negative number.  Assumes 0m 
   does not occur. */
d6747 1
a6747 1
  /* Do it the hard way so as not to make any assumption about 
d6749 1
a6749 1
     LONGEST. */
d6760 1
a6760 1
	*R = (-(LONGEST) (RU - 1)) - 1;
d6766 1
a6766 1
  /* NOTE on the above: Technically, C does not say what the results of 
d6770 1
a6770 1
     above is always equivalent to the negative of RU. */
d6777 3
a6779 3
/* Assuming that TYPE is a variant part wrapper type (a VARIANTS field), 
   and FIELD_NUM is a valid field number within it, returns 1 iff VAL is 
   in the range encoded by field FIELD_NUM of TYPE; otherwise 0. */
d6791 27
a6817 27
	{
	case '\0':
	  return 0;
	case 'S':
	  {
	    LONGEST W;
	    if (!ada_scan_number (name, p + 1, &W, &p))
	      return 0;
	    if (val == W)
	      return 1;
	    break;
	  }
	case 'R':
	  {
	    LONGEST L, U;
	    if (!ada_scan_number (name, p + 1, &L, &p)
		|| name[p] != 'T' || !ada_scan_number (name, p + 1, &U, &p))
	      return 0;
	    if (val >= L && val <= U)
	      return 1;
	    break;
	  }
	case 'O':
	  return 1;
	default:
	  return 0;
	}
d6821 6
a6826 5
/* Given a value ARG1 (offset by OFFSET bytes)
   of a struct or union type ARG_TYPE,
   extract and return the value of one of its (non-static) fields.
   FIELDNO says which field.   Differs from value_primitive_field only
   in that it can handle packed values of arbitrary type. */
d6828 1
a6828 1
struct value *
d6830 1
a6830 1
			   struct type *arg_type)
a6831 1
  struct value *v;
d6837 1
a6837 1
  /* Handle packed fields */
d6845 2
a6846 2
					     offset + bit_pos / 8,
					     bit_pos % 8, bit_size, type);
d6852 63
d6916 1
a6916 1
/* Look for a field NAME in ARG. Adjust the address of ARG by OFFSET bytes,
d6920 1
a6920 1
   Searches recursively through wrapper fields (e.g., '_parent'). */
d6922 1
a6922 1
struct value *
d6924 1
a6924 1
			 struct type *type)
d6934 1
a6934 1
	continue;
d6937 1
a6937 1
	return ada_value_primitive_field (arg, offset, i, type);
d6940 8
a6947 11
	{
	  struct value *v = ada_search_struct_field (name, arg,
						     offset +
						     TYPE_FIELD_BITPOS (type,
									i) /
						     8,
						     TYPE_FIELD_TYPE (type,
								      i));
	  if (v != NULL)
	    return v;
	}
d6950 16
a6965 18
	{
	  int j;
	  struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, i));
	  int var_offset = offset + TYPE_FIELD_BITPOS (type, i) / 8;

	  for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
	    {
	      struct value *v = ada_search_struct_field (name, arg,
							 var_offset
							 +
							 TYPE_FIELD_BITPOS
							 (field_type, j) / 8,
							 TYPE_FIELD_TYPE
							 (field_type, j));
	      if (v != NULL)
		return v;
	    }
	}
d6970 6
a6975 3
/* Given ARG, a value of type (pointer to a)* structure/union,
   extract the component named NAME from the ultimate target structure/union
   and return it as a value with its appropriate type.
d6977 2
a6978 2
   The routine searches for NAME among all members of the structure itself 
   and (recursively) among all members of any wrapper members 
d6981 5
a6985 2
   ERR is a name (for use in error messages) that identifies the class 
   of entity that ARG is supposed to be. */
d6990 1
a6990 1
  struct type *t;
d6993 19
a7011 2
  arg = ada_coerce_ref (arg);
  t = check_typedef (VALUE_TYPE (arg));
d7013 19
a7031 1
  /* Follow pointers until we get to a non-pointer.  */
d7033 1
a7033 1
  while (TYPE_CODE (t) == TYPE_CODE_PTR || TYPE_CODE (t) == TYPE_CODE_REF)
d7035 5
a7039 2
      arg = ada_value_ind (arg);
      t = check_typedef (VALUE_TYPE (arg));
d7042 12
a7053 3
  if (TYPE_CODE (t) != TYPE_CODE_STRUCT && TYPE_CODE (t) != TYPE_CODE_UNION)
    error ("Attempt to extract a component of a value that is not a %s.",
	   err);
d7055 18
a7072 2
  v = ada_search_struct_field (name, arg, 0, t);
  if (v == NULL)
d7079 2
a7080 2
   If DISPP is non-null, add its byte displacement from the beginning of a 
   structure (pointed to by a value) of type TYPE to *DISPP (does not 
d7084 1
a7084 1
   followed by "___". 
d7086 3
a7088 3
   TYPE can be either a struct or union, or a pointer or reference to 
   a struct or union.  If it is a pointer or reference, its target 
   type is automatically used.
d7092 2
a7093 1
   If NOERR is nonzero, return NULL if NAME is not suitably defined. */
d7095 3
a7097 3
struct type *
ada_lookup_struct_elt_type (struct type *type, char *name, int noerr,
			    int *dispp)
d7104 9
a7112 8
  while (1)
    {
      CHECK_TYPEDEF (type);
      if (TYPE_CODE (type) != TYPE_CODE_PTR
	  && TYPE_CODE (type) != TYPE_CODE_REF)
	break;
      type = TYPE_TARGET_TYPE (type);
    }
d7114 3
a7116 2
  if (TYPE_CODE (type) != TYPE_CODE_STRUCT &&
      TYPE_CODE (type) != TYPE_CODE_UNION)
d7118 13
a7130 5
      target_terminal_ours ();
      gdb_flush (gdb_stdout);
      fprintf_unfiltered (gdb_stderr, "Type ");
      type_print (type, "", gdb_stderr, -1);
      error (" is not a structure or union type");
d7142 1
a7142 1
	continue;
d7145 5
a7149 5
	{
	  if (dispp != NULL)
	    *dispp += TYPE_FIELD_BITPOS (type, i) / 8;
	  return check_typedef (TYPE_FIELD_TYPE (type, i));
	}
d7152 11
a7162 11
	{
	  disp = 0;
	  t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (type, i), name,
					  1, &disp);
	  if (t != NULL)
	    {
	      if (dispp != NULL)
		*dispp += disp + TYPE_FIELD_BITPOS (type, i) / 8;
	      return t;
	    }
	}
d7165 17
a7181 17
	{
	  int j;
	  struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, i));

	  for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
	    {
	      disp = 0;
	      t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (field_type, j),
					      name, 1, &disp);
	      if (t != NULL)
		{
		  if (dispp != NULL)
		    *dispp += disp + TYPE_FIELD_BITPOS (type, i) / 8;
		  return t;
		}
	    }
	}
d7201 2
a7202 2
   OUTER_VALADDR, determine which variant clause (field number in VAR_TYPE, 
   numbering from 0) is applicable.  Returns -1 if none are. */
d7206 1
a7206 1
			   char *outer_valaddr)
d7217 1
a7217 1
    ada_lookup_struct_elt_type (outer_type, discrim_name, 1, &disp);
d7226 1
a7226 1
	others_clause = i;
d7228 1
a7228 1
	return i;
d7236 1
a7236 1
				/* Dynamic-Sized Records */
d7242 1
a7242 1
   conventional types that are constructed on the fly. */
d7251 1
a7251 1
   rather than struct value*s.  
d7269 1
a7269 1
   target at the target address. */
d7273 1
a7273 1
   dynamic-sized types. */
d7279 1
a7279 2
  return ada_to_fixed_value (VALUE_TYPE (val), 0,
			     VALUE_ADDRESS (val) + VALUE_OFFSET (val), val);
d7283 2
a7284 1
 * qualifiers on VAL0. */
d7293 1
a7293 3
      return ada_to_fixed_value (VALUE_TYPE (val), 0,
				 VALUE_ADDRESS (val) + VALUE_OFFSET (val),
				 val);
d7300 1
a7300 1
   ALIGNMENT (a power of 2). */
d7308 1
a7308 16
/* Return the additional bit offset required by field F of template
   type TYPE. */

static unsigned int
field_offset (struct type *type, int f)
{
  int n = TYPE_FIELD_BITPOS (type, f);
  /* Kludge (temporary?) to fix problem with dwarf output. */
  if (n < 0)
    return (unsigned int) n & 0xffff;
  else
    return n;
}


/* Return the bit alignment required for field #F of template type TYPE. */
d7317 2
a7318 2
  if (len < 8 || !isdigit (name[len - 1]))
    return TARGET_CHAR_BIT;
d7325 1
a7325 1
  if (align_offset < 7 || !DEPRECATED_STREQN ("___XV", name + align_offset - 6, 5))
d7331 15
d7347 1
d7351 1
a7351 5
  struct symbol *sym;

  sym = standard_lookup (name, VAR_DOMAIN);
  if (sym != NULL && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
    return SYMBOL_TYPE (sym);
a7352 1
  sym = standard_lookup (name, STRUCT_DOMAIN);
d7359 45
d7405 1
a7405 1
   given type name. If the type denoted by TYPE0 is to be preferred to
d7407 2
a7408 1
   otherwise return 0. */
d7420 2
d7424 2
a7425 2
  else if (ada_is_array_descriptor (type0)
	   && !ada_is_array_descriptor (type1))
d7428 1
a7428 1
	   && ada_renaming_type (type1) == NULL)
d7434 2
a7435 1
   null, its TYPE_TAG_NAME.  Null if TYPE is null. */
d7448 1
a7448 1
   SUFFIX to the name of TYPE. */
a7454 3
  struct symbol **syms;
  struct block **blocks;
  int nsyms;
d7473 1
a7473 1
   type describing its fields.  Otherwise, return NULL. */
d7486 2
a7487 2
      if (len > 6 && DEPRECATED_STREQ (ada_type_name (type) + len - 6, "___XVE"))
	return type;
d7489 1
a7489 1
	return ada_find_parallel_type (type, "___XVE");
d7494 1
a7494 1
   non-zero iff field FIELD_NUM of TEMPL_TYPE has dynamic size. */
d7505 2
a7506 2
/* Assuming that TYPE is a struct type, returns non-zero iff TYPE
   contains a variant part. */
d7509 1
a7509 1
contains_variant_part (struct type *type)
d7513 9
a7521 4
  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT
      || TYPE_NFIELDS (type) <= 0)
    return 0;
  return ada_is_variant_part (type, TYPE_NFIELDS (type) - 1);
d7524 2
a7525 1
/* A record type with no fields, . */
d7541 3
a7543 3
   the value of type TYPE at VALADDR or ADDRESS (see comments at 
   the beginning of this section) VAL according to GNAT conventions.  
   DVAL0 should describe the (portion of a) record that contains any 
d7547 1
a7547 4
   of the variant. */
/* NOTE: Limitations: For now, we assume that dynamic fields and
 * variants occupy whole numbers of bytes.  However, they need not be
 * byte-aligned.  */
d7549 12
a7560 3
static struct type *
template_to_fixed_record_type (struct type *type, char *valaddr,
			       CORE_ADDR address, struct value *dval0)
d7566 1
d7568 1
d7571 14
a7584 1
  nfields = TYPE_NFIELDS (type);
d7594 1
a7594 3
  /* FIXME: TYPE_FLAG_FIXED_INSTANCE should be defined in
     gdbtypes.h */
  /*  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE; */
d7598 2
a7601 1
      int fld_bit_len, bit_incr;
d7603 2
a7604 5
	align_value (off,
		     field_alignment (type, f)) + TYPE_FIELD_BITPOS (type, f);
      /* NOTE: used to use field_offset above, but that causes
       * problems with really negative bit positions.  So, let's
       * rediscover why we needed field_offset and fix it properly. */
a7606 1
      TYPE_FIELD_STATIC_KIND (rtype, f) = 0;
d7609 4
a7612 24
	{
	  struct type *branch_type;

	  if (dval0 == NULL)
	    dval = value_from_contents_and_address (rtype, valaddr, address);
	  else
	    dval = dval0;

	  branch_type =
	    to_fixed_variant_branch_type
	    (TYPE_FIELD_TYPE (type, f),
	     cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
	     cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
	  if (branch_type == NULL)
	    TYPE_NFIELDS (rtype) -= 1;
	  else
	    {
	      TYPE_FIELD_TYPE (rtype, f) = branch_type;
	      TYPE_FIELD_NAME (rtype, f) = "S";
	    }
	  bit_incr = 0;
	  fld_bit_len =
	    TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, f)) * TARGET_CHAR_BIT;
	}
d7614 27
a7640 27
	{
	  if (dval0 == NULL)
	    dval = value_from_contents_and_address (rtype, valaddr, address);
	  else
	    dval = dval0;

	  TYPE_FIELD_TYPE (rtype, f) =
	    ada_to_fixed_type
	    (ada_get_base_type
	     (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, f))),
	     cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
	     cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
	  TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);
	  bit_incr = fld_bit_len =
	    TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, f)) * TARGET_CHAR_BIT;
	}
      else
	{
	  TYPE_FIELD_TYPE (rtype, f) = TYPE_FIELD_TYPE (type, f);
	  TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);
	  if (TYPE_FIELD_BITSIZE (type, f) > 0)
	    bit_incr = fld_bit_len =
	      TYPE_FIELD_BITSIZE (rtype, f) = TYPE_FIELD_BITSIZE (type, f);
	  else
	    bit_incr = fld_bit_len =
	      TYPE_LENGTH (TYPE_FIELD_TYPE (type, f)) * TARGET_CHAR_BIT;
	}
d7642 1
a7642 1
	bit_len = off + fld_bit_len;
d7644 42
a7685 1
      TYPE_LENGTH (rtype) = bit_len / TARGET_CHAR_BIT;
d7687 1
d7696 19
a7714 6
/* As for template_to_fixed_record_type, but uses no run-time values.
   As a result, this type can only be approximate, but that's OK,
   since it is used only for type determinations.   Works on both
   structs and unions.
   Representation note: to save space, we memoize the result of this
   function in the TYPE_TARGET_TYPE of the template type. */
d7717 1
a7717 1
template_to_static_fixed_type (struct type *templ_type)
d7723 2
a7724 2
  if (TYPE_TARGET_TYPE (templ_type) != NULL)
    return TYPE_TARGET_TYPE (templ_type);
d7726 2
a7727 14
  nfields = TYPE_NFIELDS (templ_type);
  TYPE_TARGET_TYPE (templ_type) = type =
    alloc_type (TYPE_OBJFILE (templ_type));
  TYPE_CODE (type) = TYPE_CODE (templ_type);
  INIT_CPLUS_SPECIFIC (type);
  TYPE_NFIELDS (type) = nfields;
  TYPE_FIELDS (type) = (struct field *)
    TYPE_ALLOC (type, nfields * sizeof (struct field));
  memset (TYPE_FIELDS (type), 0, sizeof (struct field) * nfields);
  TYPE_NAME (type) = ada_type_name (templ_type);
  TYPE_TAG_NAME (type) = NULL;
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
  /*  TYPE_FLAGS (type) |= TYPE_FLAG_FIXED_INSTANCE; */
  TYPE_LENGTH (type) = 0;
d7731 2
a7732 3
      TYPE_FIELD_BITPOS (type, f) = 0;
      TYPE_FIELD_BITSIZE (type, f) = 0;
      TYPE_FIELD_STATIC_KIND (type, f) = 0;
d7734 2
a7735 7
      if (is_dynamic_field (templ_type, f))
	{
	  TYPE_FIELD_TYPE (type, f) =
	    to_static_fixed_type (TYPE_TARGET_TYPE
				  (TYPE_FIELD_TYPE (templ_type, f)));
	  TYPE_FIELD_NAME (type, f) = TYPE_FIELD_NAME (templ_type, f);
	}
d7737 18
a7754 5
	{
	  TYPE_FIELD_TYPE (type, f) =
	    check_typedef (TYPE_FIELD_TYPE (templ_type, f));
	  TYPE_FIELD_NAME (type, f) = TYPE_FIELD_NAME (templ_type, f);
	}
a7755 1

d7759 7
a7765 3
/* A revision of TYPE0 -- a non-dynamic-sized record with a variant
   part -- in which the variant part is replaced with the appropriate
   branch. */
d7768 1
a7768 1
				   CORE_ADDR address, struct value *dval)
d7771 1
d7775 1
d7777 1
a7777 1
  if (dval == NULL)
d7780 5
d7787 2
a7788 2
  INIT_CPLUS_SPECIFIC (type);
  TYPE_NFIELDS (rtype) = TYPE_NFIELDS (type);
d7792 1
a7792 1
	  sizeof (struct field) * nfields);
d7795 1
a7795 2
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
  /*  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE; */
d7798 2
a7799 3
  branch_type =
    to_fixed_variant_branch_type
    (TYPE_FIELD_TYPE (type, nfields - 1),
d7801 2
a7802 2
		       TYPE_FIELD_BITPOS (type,
					  nfields - 1) / TARGET_CHAR_BIT),
d7804 2
a7805 3
			 TYPE_FIELD_BITPOS (type,
					    nfields - 1) / TARGET_CHAR_BIT),
     dval);
d7808 3
a7811 2
      TYPE_LENGTH (rtype) -=
	TYPE_LENGTH (TYPE_FIELD_TYPE (type, nfields - 1));
d7815 3
a7817 4
      TYPE_FIELD_TYPE (rtype, nfields - 1) = branch_type;
      TYPE_FIELD_NAME (rtype, nfields - 1) = "S";
      TYPE_FIELD_BITSIZE (rtype, nfields - 1) = 0;
      TYPE_FIELD_STATIC_KIND (rtype, nfields - 1) = 0;
a7818 1
      -TYPE_LENGTH (TYPE_FIELD_TYPE (type, nfields - 1));
d7820 1
d7822 1
d7829 14
a7842 4
   should be in DVAL, a record value; it should be NULL if the object
   at ADDR itself contains any necessary  discriminant values.  A
   variant field (unless unchecked) is replaced by a particular branch
   of the variant. */
d7845 2
a7846 2
to_fixed_record_type (struct type *type0, char *valaddr, CORE_ADDR address,
		      struct value *dval)
d7850 3
a7852 4
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
  /*  if (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE)
     return type0;
   */
d7857 7
a7863 2
  else if (contains_variant_part (type0))
    return to_record_with_fixed_variant_part (type0, valaddr, address, dval);
d7866 1
a7866 2
      /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
      /*      TYPE_FLAGS (type0) |= TYPE_FLAG_FIXED_INSTANCE; */
d7877 1
a7877 1
   indicated in the union's type name. */
d7881 1
a7881 1
			      CORE_ADDR address, struct value *dval)
d7899 1
a7899 1
			       VALUE_TYPE (dval), VALUE_CONTENTS (dval));
d7904 1
a7904 2
    return
      to_fixed_record_type
d7907 1
a7907 1
  else if (contains_variant_part (TYPE_FIELD_TYPE (var_type, which)))
d7921 1
a7921 2
   varsize_limit.
*/
d7925 1
a7925 1
		     int ignore_too_big)
d7930 3
a7932 4
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
/*  if (ada_is_packed_array_type (type0)  /* revisit? *//*
   || (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE))
   return type0; */
d7939 2
a7940 2
       * depend on the contents of the array in properly constructed
       * debugging data. */
d7944 1
a7944 1
	result = type0;
d7946 2
a7947 2
	result = create_array_type (alloc_type (TYPE_OBJFILE (type0)),
				    elt_type, TYPE_INDEX_TYPE (type0));
d7956 1
a7956 1
	elt_type0 = TYPE_TARGET_TYPE (elt_type0);
d7959 2
a7960 2
       * depend on the contents of the array in properly constructed
       * debugging data. */
d7963 7
a7969 7
	{
	  struct type *range_type =
	    to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, i),
				 dval, TYPE_OBJFILE (type0));
	  result = create_array_type (alloc_type (TYPE_OBJFILE (type0)),
				      result, range_type);
	}
d7971 1
a7971 1
	error ("array type with dynamic size is larger than varsize-limit");
d7974 1
a7974 2
/* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
/*  TYPE_FLAGS (result) |= TYPE_FLAG_FIXED_INSTANCE; */
d7982 2
a7983 1
   and may be NULL if there are none. */
d7986 2
a7987 2
ada_to_fixed_type (struct type *type, char *valaddr, CORE_ADDR address,
		   struct value *dval)
d7995 13
a8007 1
      return to_fixed_record_type (type, valaddr, address, NULL);
d8009 1
a8009 1
      return to_fixed_array_type (type, dval, 0);
d8012 1
a8012 1
	return type;
d8014 1
a8014 1
	return to_fixed_variant_branch_type (type, valaddr, address, dval);
d8019 1
a8019 1
   TYPE0, but based on no runtime data. */
d8029 3
a8031 4
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
  /*  if (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE)
     return type0;
   */
d8041 3
a8043 2
	return template_to_static_fixed_type (type);
      return type0;
d8047 3
a8049 2
	return template_to_static_fixed_type (type);
      return type0;
d8053 2
a8054 1
/* A static approximation of TYPE with all type wrappers removed. */
d8062 1
a8062 1
	TYPE_NAME (type1) = ada_type_name (type);
d8070 1
a8070 1
	return type;
d8072 1
a8072 1
	return to_static_fixed_type (raw_real_type);
d8077 1
a8077 1
   cross-references that are not resolved as records (for example, 
d8082 1
a8082 1
   ). In these cases, since there is no mechanism for producing 
d8085 1
a8085 1
   the name of the actual type.  Call these types "non-record stubs". */
d8088 2
a8089 1
   exists, otherwise TYPE. */
d8110 1
a8110 1
   creation of struct values]. */
d8112 3
a8114 3
struct value *
ada_to_fixed_value (struct type *type0, char *valaddr, CORE_ADDR address,
		    struct value *val0)
d8116 1
a8116 1
  struct type *type = ada_to_fixed_type (type0, valaddr, address, NULL);
d8120 30
a8149 1
    return value_from_contents_and_address (type, valaddr, address);
d8152 1
a8152 1
/* A value representing VAL, but with a standard (static-sized) type 
d8155 1
a8155 1
   types, therefore, the type of the result is likely to be inaccurate. */
d8165 1
a8165 1
    return coerce_unspec_val_to_type (val, 0, type);
a8168 3



d8171 2
a8172 2
/* Table mapping attribute numbers to names */
/* NOTE: Keep up to date with enum ada_attribute definition in ada-lang.h */
a8180 1
  "img",
d8183 4
a8186 1
  "pos" "tag",
a8187 1

d8192 1
a8192 1
ada_attribute_name (int n)
d8194 2
a8195 2
  if (n > 0 && n < (int) ATR_END)
    return attribute_names[n];
d8200 1
a8200 1
/* Evaluate the 'POS attribute applied to ARG. */
d8202 2
a8203 2
static struct value *
value_pos_atr (struct value *arg)
d8216 4
a8219 4
	{
	  if (v == TYPE_FIELD_BITPOS (type, i))
	    return value_from_longest (builtin_type_ada_int, i);
	}
d8223 7
a8229 1
    return value_from_longest (builtin_type_ada_int, value_as_long (arg));
d8232 1
a8232 1
/* Evaluate the TYPE'VAL attribute applied to ARG. */
d8246 1
a8246 1
	error ("argument to 'VAL out of range");
d8254 1
a8254 1
				/* Evaluation */
d8256 3
a8258 3
/* True if TYPE appears to be an Ada character type.  
 * [At the moment, this is true only for Character and Wide_Character;
 * It is a heuristic test that could stand improvement]. */
d8267 5
a8271 4
	|| TYPE_CODE (type) == TYPE_CODE_INT
	|| TYPE_CODE (type) == TYPE_CODE_RANGE)
    && (DEPRECATED_STREQ (name, "character") || DEPRECATED_STREQ (name, "wide_character")
	|| DEPRECATED_STREQ (name, "unsigned char"));
d8274 1
a8274 1
/* True if TYPE appears to be an Ada string type. */
d8282 1
a8282 1
      && (ada_is_simple_array (type) || ada_is_array_descriptor (type))
d8296 1
a8296 1
   distinctive name. */
d8303 2
a8304 2
	  && TYPE_NFIELDS (type) == 1
	  && DEPRECATED_STREQ (TYPE_FIELD_NAME (type, 0), "F"));
d8308 1
a8308 1
   the parallel type. */
a8314 1
  struct type *real_type;
d8332 1
a8332 1
/* The type of value designated by TYPE, with all aligners removed. */
d8345 1
a8345 1
   having type TYPE.  Assumes ada_is_aligner_type (TYPE). */
d8352 3
a8354 3
				   valaddr +
				   TYPE_FIELD_BITPOS (type,
						      0) / TARGET_CHAR_BIT);
d8359 2
d8362 1
a8362 1
   name NAME. The value is good to the next call of ada_enum_name. */
d8366 2
d8370 20
a8389 8
  while (1)
    {
      if ((tmp = strstr (name, "__")) != NULL)
	name = tmp + 2;
      else if ((tmp = strchr (name, '.')) != NULL)
	name = tmp + 1;
      else
	break;
a8393 1
      static char result[16];
d8396 4
a8399 4
	{
	  if (sscanf (name + 2, "%x", &v) != 1)
	    return name;
	}
d8401 1
a8401 1
	return name;
d8403 1
d8405 1
a8405 1
	sprintf (result, "'%c'", v);
d8407 1
a8407 1
	sprintf (result, "[\"%02x\"]", v);
d8409 1
a8409 1
	sprintf (result, "[\"%04x\"]", v);
d8414 12
a8425 1
    return name;
d8430 1
a8430 1
		 enum noside noside)
d8432 2
a8433 1
  return (*exp->language_defn->evaluate_exp) (expect_type, exp, pos, noside);
d8438 1
a8438 1
   expression. */
d8443 1
a8443 1
  return (*exp->language_defn->evaluate_exp)
d8448 1
a8448 1
   value it wraps. */
d8457 1
a8457 1
					  NULL, "internal structure");
d8460 1
a8460 1
	TYPE_NAME (val_type) = ada_type_name (type);
d8467 1
a8467 1
	ada_completed_type (ada_get_base_type (type));
d8470 1
a8470 1
	return val;
d8473 4
a8476 4
	coerce_unspec_val_to_type
	(val, 0, ada_to_fixed_type (raw_real_type, 0,
				    VALUE_ADDRESS (val) + VALUE_OFFSET (val),
				    NULL));
d8489 2
a8490 2
			      ada_fixed_to_float (VALUE_TYPE (arg),
						  value_as_long (arg)));
d8494 1
a8494 1
	value_as_double (value_cast (builtin_type_double, value_copy (arg)));
d8505 1
a8505 1
				     value_as_long (arg));
d8509 3
a8511 2
/* Coerce VAL as necessary for assignment to an lval of type TYPE, and 
 * return the converted value. */
d8533 3
a8535 3
	  || TYPE_LENGTH (TYPE_TARGET_TYPE (type2))
	  != TYPE_LENGTH (TYPE_TARGET_TYPE (type2)))
	error ("Incompatible types in assignment");
d8541 79
d8622 1
a8622 1
		     int *pos, enum noside noside)
a8624 1
  enum ada_attribute atr;
d8641 14
a8654 2
	unwrap_value (evaluate_subexp_standard
		      (expect_type, exp, pos, noside));
d8661 1
a8661 1
	goto nosideret;
d8663 21
a8683 21
	{
	  if (ada_is_fixed_point_type (type))
	    arg1 = cast_to_fixed (type, arg1);
	  else if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
	    arg1 = value_cast (type, cast_from_fixed_to_double (arg1));
	  else if (VALUE_LVAL (arg1) == lval_memory)
	    {
	      /* This is in case of the really obscure (and undocumented,
	         but apparently expected) case of (Foo) Bar.all, where Bar 
	         is an integer constant and Foo is a dynamic-sized type.
	         If we don't do this, ARG1 will simply be relabeled with
	         TYPE. */
	      if (noside == EVAL_AVOID_SIDE_EFFECTS)
		return value_zero (to_static_fixed_type (type), not_lval);
	      arg1 =
		ada_to_fixed_value
		(type, 0, VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1), 0);
	    }
	  else
	    arg1 = value_cast (type, arg1);
	}
d8686 5
a8690 6
      /* FIXME:  UNOP_QUAL should be defined in expression.h */
      /*    case UNOP_QUAL:
         (*pos) += 2;
         type = exp->elts[pc + 1].type;
         return ada_evaluate_subexp (type, exp, pos, noside);
       */
d8695 6
a8700 3
	return arg1;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, EVAL_NORMAL);
d8702 2
a8703 10
	{
	  if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
	    arg2 = cast_to_fixed (VALUE_TYPE (arg1), arg2);
	  else if (ada_is_fixed_point_type (VALUE_TYPE (arg2)))
	    error
	      ("Fixed-point values must be assigned to fixed-point variables");
	  else
	    arg2 = coerce_for_assign (VALUE_TYPE (arg1), arg2);
	  return ada_value_assign (arg1, arg2);
	}
d8709 7
a8715 12
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, EVAL_NORMAL);
      else
	{
	  if ((ada_is_fixed_point_type (VALUE_TYPE (arg1))
	       || ada_is_fixed_point_type (VALUE_TYPE (arg2)))
	      && VALUE_TYPE (arg1) != VALUE_TYPE (arg2))
	    error
	      ("Operands of fixed-point addition must have the same type");
	  return value_cast (VALUE_TYPE (arg1), value_add (arg1, arg2));
	}
d8721 7
a8727 12
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, EVAL_NORMAL);
      else
	{
	  if ((ada_is_fixed_point_type (VALUE_TYPE (arg1))
	       || ada_is_fixed_point_type (VALUE_TYPE (arg2)))
	      && VALUE_TYPE (arg1) != VALUE_TYPE (arg2))
	    error
	      ("Operands of fixed-point subtraction must have the same type");
	  return value_cast (VALUE_TYPE (arg1), value_sub (arg1, arg2));
	}
d8734 18
d8753 3
a8755 2
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, EVAL_NORMAL);
d8757 10
a8766 3
	if (noside == EVAL_AVOID_SIDE_EFFECTS
	    && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
	return value_zero (VALUE_TYPE (arg1), not_lval);
d8768 4
a8771 7
	{
	  if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
	    arg1 = cast_from_fixed_to_double (arg1);
	  if (ada_is_fixed_point_type (VALUE_TYPE (arg2)))
	    arg2 = cast_from_fixed_to_double (arg2);
	  return value_binop (arg1, arg2, op);
	}
d8776 1
a8776 3
	goto nosideret;
      if (unop_user_defined_p (op, arg1))
	return value_x_unop (arg1, op, EVAL_NORMAL);
d8778 1
a8778 1
	return value_cast (VALUE_TYPE (arg1), value_neg (arg1));
d8780 1
a8780 1
	return value_neg (arg1);
a8781 12
      /* FIXME:  OP_UNRESOLVED_VALUE should be defined in expression.h */
      /*    case OP_UNRESOLVED_VALUE:
         /* Only encountered when an unresolved symbol occurs in a
         context other than a function call, in which case, it is
   illegal. *//*
   (*pos) += 3;
   if (noside == EVAL_SKIP)
   goto nosideret;
   else 
   error ("Unexpected unresolved symbol, %s, during evaluation",
   ada_demangle (exp->elts[pc + 2].name));
 */
d8785 10
a8794 4
	{
	  *pos += 4;
	  goto nosideret;
	}
d8796 234
a9029 16
	{
	  *pos += 4;
	  return value_zero
	    (to_static_fixed_type
	     (static_unwrap_type (SYMBOL_TYPE (exp->elts[pc + 2].symbol))),
	     not_lval);
	}
      else
	{
	  arg1 =
	    unwrap_value (evaluate_subexp_standard
			  (expect_type, exp, pos, noside));
	  return ada_to_fixed_value (VALUE_TYPE (arg1), 0,
				     VALUE_ADDRESS (arg1) +
				     VALUE_OFFSET (arg1), arg1);
	}
d9031 4
a9034 6
    case OP_ARRAY:
      (*pos) += 3;
      tem2 = longest_to_int (exp->elts[pc + 1].longconst);
      tem3 = longest_to_int (exp->elts[pc + 2].longconst);
      nargs = tem3 - tem2 + 1;
      type = expect_type ? check_typedef (expect_type) : NULL_TYPE;
a9035 8
      argvec =
	(struct value * *) alloca (sizeof (struct value *) * (nargs + 1));
      for (tem = 0; tem == 0 || tem < nargs; tem += 1)
	/* At least one element gets inserted for the type */
	{
	  /* Ensure that array expressions are coerced into pointer objects. */
	  argvec[tem] = evaluate_subexp_with_coercion (exp, pos, noside);
	}
d9037 1
a9037 2
	goto nosideret;
      return value_array (tem2, tem3, argvec);
d9039 2
a9040 2
    case OP_FUNCALL:
      (*pos) += 2;
d9042 1
a9042 5
      /* Allocate arg vector, including space for the function to be
         called in argvec[0] and a terminating NULL */
      nargs = longest_to_int (exp->elts[pc + 1].longconst);
      argvec =
	(struct value * *) alloca (sizeof (struct value *) * (nargs + 2));
d9044 2
a9045 15
      /* FIXME: OP_UNRESOLVED_VALUE should be defined in expression.h */
      /* FIXME: name should be defined in expresion.h */
      /*      if (exp->elts[*pos].opcode == OP_UNRESOLVED_VALUE)
         error ("Unexpected unresolved symbol, %s, during evaluation",
         ada_demangle (exp->elts[pc + 5].name));
       */
      if (0)
	{
	  error ("unexpected code path, FIXME");
	}
      else
	{
	  for (tem = 0; tem <= nargs; tem += 1)
	    argvec[tem] = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  argvec[tem] = 0;
d9047 2
a9048 3
	  if (noside == EVAL_SKIP)
	    goto nosideret;
	}
d9050 6
a9055 2
      if (TYPE_CODE (VALUE_TYPE (argvec[0])) == TYPE_CODE_REF)
	argvec[0] = value_addr (argvec[0]);
d9057 4
a9060 2
      if (ada_is_packed_array_type (VALUE_TYPE (argvec[0])))
	argvec[0] = ada_coerce_to_simple_array (argvec[0]);
d9062 2
a9063 21
      type = check_typedef (VALUE_TYPE (argvec[0]));
      if (TYPE_CODE (type) == TYPE_CODE_PTR)
	{
	  switch (TYPE_CODE (check_typedef (TYPE_TARGET_TYPE (type))))
	    {
	    case TYPE_CODE_FUNC:
	      type = check_typedef (TYPE_TARGET_TYPE (type));
	      break;
	    case TYPE_CODE_ARRAY:
	      break;
	    case TYPE_CODE_STRUCT:
	      if (noside != EVAL_AVOID_SIDE_EFFECTS)
		argvec[0] = ada_value_ind (argvec[0]);
	      type = check_typedef (TYPE_TARGET_TYPE (type));
	      break;
	    default:
	      error ("cannot subscript or call something of type `%s'",
		     ada_type_name (VALUE_TYPE (argvec[0])));
	      break;
	    }
	}
d9065 19
a9083 7
      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_FUNC:
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    return allocate_value (TYPE_TARGET_TYPE (type));
	  return call_function_by_hand (argvec[0], nargs, argvec + 1);
	case TYPE_CODE_STRUCT:
d9085 2
a9086 11
	    int arity = ada_array_arity (type);
	    type = ada_array_element_type (type, nargs);
	    if (type == NULL)
	      error ("cannot subscript or call a record");
	    if (arity != nargs)
	      error ("wrong number of subscripts; expecting %d", arity);
	    if (noside == EVAL_AVOID_SIDE_EFFECTS)
	      return allocate_value (ada_aligned_type (type));
	    return
	      unwrap_value (ada_value_subscript
			    (argvec[0], nargs, argvec + 1));
a9087 26
	case TYPE_CODE_ARRAY:
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    {
	      type = ada_array_element_type (type, nargs);
	      if (type == NULL)
		error ("element type of array unknown");
	      else
		return allocate_value (ada_aligned_type (type));
	    }
	  return
	    unwrap_value (ada_value_subscript
			  (ada_coerce_to_simple_array (argvec[0]),
			   nargs, argvec + 1));
	case TYPE_CODE_PTR:	/* Pointer to array */
	  type = to_fixed_array_type (TYPE_TARGET_TYPE (type), NULL, 1);
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    {
	      type = ada_array_element_type (type, nargs);
	      if (type == NULL)
		error ("element type of array unknown");
	      else
		return allocate_value (ada_aligned_type (type));
	    }
	  return
	    unwrap_value (ada_value_ptr_subscript (argvec[0], type,
						   nargs, argvec + 1));
d9089 4
a9092 3
	default:
	  error ("Internal error in evaluate_subexp");
	}
a9093 7
    case TERNOP_SLICE:
      {
	struct value *array = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	int lowbound
	  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
	int upper
	  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d9097 1
a9097 6
	/* If this is a reference to an array, then dereference it */
	if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_REF
	    && TYPE_TARGET_TYPE (VALUE_TYPE (array)) != NULL
	    && TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (array))) ==
	    TYPE_CODE_ARRAY
	    && !ada_is_array_descriptor (check_typedef (VALUE_TYPE (array))))
d9099 29
a9127 1
	    array = ada_coerce_ref (array);
d9129 1
a9129 3

	if (noside == EVAL_AVOID_SIDE_EFFECTS &&
	    ada_is_array_descriptor (check_typedef (VALUE_TYPE (array))))
d9131 19
a9149 4
	    /* Try to dereference the array, in case it is an access to array */
	    struct type *arrType = ada_type_of_array (array, 0);
	    if (arrType != NULL)
	      array = value_at_lazy (arrType, 0, NULL);
d9151 12
a9162 2
	if (ada_is_array_descriptor (VALUE_TYPE (array)))
	  array = ada_coerce_to_simple_array (array);
d9164 22
a9185 9
	/* If at this point we have a pointer to an array, it means that
	   it is a pointer to a simple (non-ada) array. We just then
	   dereference it */
	if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_PTR
	    && TYPE_TARGET_TYPE (VALUE_TYPE (array)) != NULL
	    && TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (array))) ==
	    TYPE_CODE_ARRAY)
	  {
	    array = ada_value_ind (array);
d9187 32
d9220 5
a9224 6
	if (noside == EVAL_AVOID_SIDE_EFFECTS)
	  /* The following will get the bounds wrong, but only in contexts
	     where the value is not being requested (FIXME?). */
	  return array;
	else
	  return value_slice (array, lowbound, upper - lowbound + 1);
d9227 33
a9259 291
      /* FIXME: UNOP_MBR should be defined in expression.h */
      /*    case UNOP_MBR:
         (*pos) += 2;
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         type = exp->elts[pc + 1].type;

         if (noside == EVAL_SKIP)
         goto nosideret;

         switch (TYPE_CODE (type)) 
         {
         default:
         warning ("Membership test incompletely implemented; always returns true");
         return value_from_longest (builtin_type_int, (LONGEST) 1);

         case TYPE_CODE_RANGE:
         arg2 = value_from_longest (builtin_type_int, 
         (LONGEST) TYPE_LOW_BOUND (type));
         arg3 = value_from_longest (builtin_type_int, 
         (LONGEST) TYPE_HIGH_BOUND (type));
         return 
         value_from_longest (builtin_type_int,
         (value_less (arg1,arg3) 
         || value_equal (arg1,arg3))
         && (value_less (arg2,arg1)
         || value_equal (arg2,arg1)));
         }
       */
      /* FIXME: BINOP_MBR should be defined in expression.h */
      /*    case BINOP_MBR:
         (*pos) += 2;
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

         if (noside == EVAL_SKIP)
         goto nosideret;

         if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (builtin_type_int, not_lval);

         tem = longest_to_int (exp->elts[pc + 1].longconst);

         if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg2)))
         error ("invalid dimension number to '%s", "range");

         arg3 = ada_array_bound (arg2, tem, 1);
         arg2 = ada_array_bound (arg2, tem, 0);

         return 
         value_from_longest (builtin_type_int,
         (value_less (arg1,arg3) 
         || value_equal (arg1,arg3))
         && (value_less (arg2,arg1)
         || value_equal (arg2,arg1)));
       */
      /* FIXME: TERNOP_MBR should be defined in expression.h */
      /*    case TERNOP_MBR:
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         arg3 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

         if (noside == EVAL_SKIP)
         goto nosideret;

         return 
         value_from_longest (builtin_type_int,
         (value_less (arg1,arg3) 
         || value_equal (arg1,arg3))
         && (value_less (arg2,arg1)
         || value_equal (arg2,arg1)));
       */
      /* FIXME: OP_ATTRIBUTE should be defined in expression.h */
      /*    case OP_ATTRIBUTE:
         *pos += 3;
         atr = (enum ada_attribute) longest_to_int (exp->elts[pc + 2].longconst);
         switch (atr) 
         {
         default:
         error ("unexpected attribute encountered");

         case ATR_FIRST:
         case ATR_LAST:
         case ATR_LENGTH:
         {
         struct type* type_arg;
         if (exp->elts[*pos].opcode == OP_TYPE)
         {
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         arg1 = NULL;
         type_arg = exp->elts[pc + 5].type;
         }
         else
         {
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         type_arg = NULL;
         }

         if (exp->elts[*pos].opcode != OP_LONG) 
         error ("illegal operand to '%s", ada_attribute_name (atr));
         tem = longest_to_int (exp->elts[*pos+2].longconst);
         *pos += 4;

         if (noside == EVAL_SKIP)
         goto nosideret;

         if (type_arg == NULL)
         {
         arg1 = ada_coerce_ref (arg1);

         if (ada_is_packed_array_type (VALUE_TYPE (arg1)))
         arg1 = ada_coerce_to_simple_array (arg1);

         if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg1)))
         error ("invalid dimension number to '%s", 
         ada_attribute_name (atr));

         if (noside == EVAL_AVOID_SIDE_EFFECTS)
         {
         type = ada_index_type (VALUE_TYPE (arg1), tem);
         if (type == NULL) 
         error ("attempt to take bound of something that is not an array");
         return allocate_value (type);
         }

         switch (atr) 
         {
         default: 
         error ("unexpected attribute encountered");
         case ATR_FIRST:
         return ada_array_bound (arg1, tem, 0);
         case ATR_LAST:
         return ada_array_bound (arg1, tem, 1);
         case ATR_LENGTH:
         return ada_array_length (arg1, tem);
         }
         }
         else if (TYPE_CODE (type_arg) == TYPE_CODE_RANGE
         || TYPE_CODE (type_arg) == TYPE_CODE_INT) 
         {
         struct type* range_type;
         char* name = ada_type_name (type_arg);
         if (name == NULL)
         {
         if (TYPE_CODE (type_arg) == TYPE_CODE_RANGE) 
         range_type = type_arg;
         else
         error ("unimplemented type attribute");
         }
         else 
         range_type = 
         to_fixed_range_type (name, NULL, TYPE_OBJFILE (type_arg));
         switch (atr) 
         {
         default: 
         error ("unexpected attribute encountered");
         case ATR_FIRST:
         return value_from_longest (TYPE_TARGET_TYPE (range_type),
         TYPE_LOW_BOUND (range_type));
         case ATR_LAST:
         return value_from_longest (TYPE_TARGET_TYPE (range_type),
         TYPE_HIGH_BOUND (range_type));
         }
         }              
         else if (TYPE_CODE (type_arg) == TYPE_CODE_ENUM)
         {
         switch (atr) 
         {
         default: 
         error ("unexpected attribute encountered");
         case ATR_FIRST:
         return value_from_longest 
         (type_arg, TYPE_FIELD_BITPOS (type_arg, 0));
         case ATR_LAST:
         return value_from_longest 
         (type_arg, 
         TYPE_FIELD_BITPOS (type_arg,
         TYPE_NFIELDS (type_arg) - 1));
         }
         }
         else if (TYPE_CODE (type_arg) == TYPE_CODE_FLT)
         error ("unimplemented type attribute");
         else 
         {
         LONGEST low, high;

         if (ada_is_packed_array_type (type_arg))
         type_arg = decode_packed_array_type (type_arg);

         if (tem < 1 || tem > ada_array_arity (type_arg))
         error ("invalid dimension number to '%s", 
         ada_attribute_name (atr));

         if (noside == EVAL_AVOID_SIDE_EFFECTS)
         {
         type = ada_index_type (type_arg, tem);
         if (type == NULL) 
         error ("attempt to take bound of something that is not an array");
         return allocate_value (type);
         }

         switch (atr) 
         {
         default: 
         error ("unexpected attribute encountered");
         case ATR_FIRST:
         low = ada_array_bound_from_type (type_arg, tem, 0, &type);
         return value_from_longest (type, low);
         case ATR_LAST:
         high = ada_array_bound_from_type (type_arg, tem, 1, &type);
         return value_from_longest (type, high);
         case ATR_LENGTH:
         low = ada_array_bound_from_type (type_arg, tem, 0, &type);
         high = ada_array_bound_from_type (type_arg, tem, 1, NULL);
         return value_from_longest (type, high-low+1);
         }
         }
         }

         case ATR_TAG:
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         if (noside == EVAL_SKIP)
         goto nosideret;

         if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return         
         value_zero (ada_tag_type (arg1), not_lval);

         return ada_value_tag (arg1);

         case ATR_MIN:
         case ATR_MAX:
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         if (noside == EVAL_SKIP)
         goto nosideret;
         else if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (VALUE_TYPE (arg1), not_lval);
         else
         return value_binop (arg1, arg2, 
         atr == ATR_MIN ? BINOP_MIN : BINOP_MAX);

         case ATR_MODULUS:
         {
         struct type* type_arg = exp->elts[pc + 5].type;
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         *pos += 4;

         if (noside == EVAL_SKIP)
         goto nosideret;

         if (! ada_is_modular_type (type_arg))
         error ("'modulus must be applied to modular type");

         return value_from_longest (TYPE_TARGET_TYPE (type_arg),
         ada_modulus (type_arg));
         }


         case ATR_POS:
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         if (noside == EVAL_SKIP)
         goto nosideret;
         else if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (builtin_type_ada_int, not_lval);
         else 
         return value_pos_atr (arg1);

         case ATR_SIZE:
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         if (noside == EVAL_SKIP)
         goto nosideret;
         else if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (builtin_type_ada_int, not_lval);
         else
         return value_from_longest (builtin_type_ada_int,
         TARGET_CHAR_BIT 
         * TYPE_LENGTH (VALUE_TYPE (arg1)));

         case ATR_VAL:
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         type = exp->elts[pc + 5].type;
         if (noside == EVAL_SKIP)
         goto nosideret;
         else if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (type, not_lval);
         else 
         return value_val_atr (type, arg1);
         } */
d9264 1
a9264 4
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	return unwrap_value (value_x_binop (arg1, arg2, op, OP_NULL,
					    EVAL_NORMAL));
d9266 1
a9266 1
	return value_zero (VALUE_TYPE (arg1), not_lval);
d9268 1
a9268 1
	return value_binop (arg1, arg2, op);
d9273 1
a9273 3
	goto nosideret;
      if (unop_user_defined_p (op, arg1))
	return unwrap_value (value_x_unop (arg1, op, EVAL_NORMAL));
d9275 1
a9275 1
	return arg1;
d9280 1
a9280 1
	goto nosideret;
d9282 1
a9282 1
	return value_neg (arg1);
d9284 1
a9284 1
	return arg1;
d9288 1
a9288 1
	expect_type = TYPE_TARGET_TYPE (check_typedef (expect_type));
d9291 1
a9291 1
	goto nosideret;
d9294 25
a9318 25
	{
	  if (ada_is_array_descriptor (type))
	    /* GDB allows dereferencing GNAT array descriptors. */
	    {
	      struct type *arrType = ada_type_of_array (arg1, 0);
	      if (arrType == NULL)
		error ("Attempt to dereference null array pointer.");
	      return value_at_lazy (arrType, 0, NULL);
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_PTR
		   || TYPE_CODE (type) == TYPE_CODE_REF
		   /* In C you can dereference an array to get the 1st elt.  */
		   || TYPE_CODE (type) == TYPE_CODE_ARRAY)
	    return
	      value_zero
	      (to_static_fixed_type
	       (ada_aligned_type (check_typedef (TYPE_TARGET_TYPE (type)))),
	       lval_memory);
	  else if (TYPE_CODE (type) == TYPE_CODE_INT)
	    /* GDB allows dereferencing an int.  */
	    return value_zero (builtin_type_int, lval_memory);
	  else
	    error ("Attempt to take contents of a non-pointer value.");
	}
      arg1 = ada_coerce_ref (arg1);
d9321 3
a9323 3
      if (ada_is_array_descriptor (type))
	/* GDB allows dereferencing GNAT array descriptors. */
	return ada_coerce_to_simple_array (arg1);
d9325 1
a9325 1
	return ada_value_ind (arg1);
d9332 1
a9332 1
	goto nosideret;
d9334 25
a9358 10
	return value_zero (ada_aligned_type
			   (ada_lookup_struct_elt_type (VALUE_TYPE (arg1),
							&exp->elts[pc +
								   2].string,
							0, NULL)),
			   lval_memory);
      else
	return unwrap_value (ada_value_struct_elt (arg1,
						   &exp->elts[pc + 2].string,
						   "record"));
d9360 2
a9361 2
      /* The value is not supposed to be used. This is here to make it
         easier to accommodate expressions that contain types. */
d9364 1
a9364 1
	goto nosideret;
d9366 1
a9366 1
	return allocate_value (builtin_type_void);
d9368 1
a9368 19
	error ("Attempt to use a type name as an expression");

    case STRUCTOP_PTR:
      tem = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return value_zero (ada_aligned_type
			   (ada_lookup_struct_elt_type (VALUE_TYPE (arg1),
							&exp->elts[pc +
								   2].string,
							0, NULL)),
			   lval_memory);
      else
	return unwrap_value (ada_value_struct_elt (arg1,
						   &exp->elts[pc + 2].string,
						   "record access"));
d9376 1
a9376 1
				/* Fixed point */
d9380 1
a9380 1
   Otherwise, return NULL. */
d9392 1
a9392 1
	return NULL;
d9394 1
a9394 1
	return tail + 5;
d9402 1
a9402 1
/* Returns non-zero iff TYPE represents an Ada fixed-point type. */
d9410 9
d9421 1
a9421 1
   delta cannot be determined. */
d9436 1
a9436 1
   factor ('SMALL value) associated with the type. */
d9457 1
a9457 1
   type TYPE, return its floating-point equivalent. */
d9465 2
a9466 2
/* The representation of a fixed-point value of type TYPE 
   corresponding to the value X. */
d9475 1
a9475 1
				/* VAX floating formats */
d9478 2
a9479 1
   types. */
d9488 2
a9489 2
	|| TYPE_CODE (type) == TYPE_CODE_RANGE)
    && DEPRECATED_STREQN (ada_type_name (type) + name_len - 6, "___XF", 5);
d9493 2
a9494 1
   ada_is_vax_floating_point */
d9501 1
a9501 1
/* A value representing the special debugging function that outputs 
d9503 2
a9504 1
   ada_is_vax_floating_type (TYPE). */
d9522 1
a9522 1
				/* Range types */
d9528 1
a9528 1
   not alter *PX and *PNEW_K if unsuccessful. */
d9570 2
a9571 1
   otherwise causes an error with message ERR_MSG. */
d9575 1
a9575 2
  struct symbol **syms;
  struct block **blocks;
d9578 2
a9579 3
  nsyms =
    ada_lookup_symbol_list (name, get_selected_block (NULL), VAR_DOMAIN,
			    &syms, &blocks);
d9584 1
a9584 1
	return 0;
d9586 1
a9586 1
	error ("%s", err_msg);
d9589 1
a9589 1
  return value_of_variable (syms[0], blocks[0]);
d9593 3
a9595 2
   no such variable found, then if ERR_MSG is null, returns 0, and sets
   *FLAG to 0.  If successful, sets *FLAG to 1. */
d9597 1
a9597 1
get_int_var_value (char *name, char *err_msg, int *flag)
d9599 1
a9599 1
  struct value *var_val = get_var_value (name, err_msg);
d9604 1
a9604 1
	*flag = 0;
d9610 1
a9610 1
	*flag = 1;
d9618 1
a9618 1
   from NAME according to the GNAT range encoding conventions. 
d9622 1
a9622 1
   the named range type. */
a9628 1
  LONGEST low, high;
d9660 21
a9680 15
	{
	  if (!ada_scan_number (bounds_str, n, &L, &n)
	      && !scan_discrim_bound (bounds_str, n, dval, &L, &n))
	    return raw_type;
	  if (bounds_str[n] == '_')
	    n += 2;
	  else if (bounds_str[n] == '.')	/* FIXME? SGI Workshop kludge. */
	    n += 1;
	  subtype_info += 1;
	}
      else
	{
	  strcpy (name_buf + prefix_len, "___L");
	  L = get_int_var_value (name_buf, "Index bound unknown.", NULL);
	}
d9683 16
a9698 10
	{
	  if (!ada_scan_number (bounds_str, n, &U, &n)
	      && !scan_discrim_bound (bounds_str, n, dval, &U, &n))
	    return raw_type;
	}
      else
	{
	  strcpy (name_buf + prefix_len, "___U");
	  U = get_int_var_value (name_buf, "Index bound unknown.", NULL);
	}
d9701 1
a9701 1
	objfile = TYPE_OBJFILE (base_type);
d9708 2
a9709 1
/* True iff NAME is the name of a range type. */
d9717 3
a9719 1
				/* Modular types */
a9720 1
/* True iff TYPE is an Ada modular type. */
d9724 1
a9724 3
  /* FIXME: base_type should be declared in gdbtypes.h, implemented in
     valarith.c */
  struct type *subranged_type;	/* = base_type (type); */
d9727 2
a9728 2
	  && TYPE_CODE (subranged_type) != TYPE_CODE_ENUM
	  && TYPE_UNSIGNED (subranged_type));
d9731 2
a9732 1
/* Assuming ada_is_modular_type (TYPE), the modulus of TYPE. */
d9739 122
d9862 78
d9941 16
a9956 1
				/* Operators */
d9990 3
a9992 2
  {".all", UNOP_IND, PREC_SUFFIX, 1},	/* FIXME: postfix .ALL */
  {"'access", UNOP_ADDR, PREC_SUFFIX, 1},	/* FIXME: postfix 'ACCESS */
d9996 1
a9996 1
			/* Assorted Types and Interfaces */
d10012 29
d10042 1
a10042 26
  &builtin_type_ada_int,
    &builtin_type_ada_long,
    &builtin_type_ada_short,
    &builtin_type_ada_char,
    &builtin_type_ada_float,
    &builtin_type_ada_double,
    &builtin_type_ada_long_long,
    &builtin_type_ada_long_double,
    &builtin_type_ada_natural, &builtin_type_ada_positive,
    /* The following types are carried over from C for convenience. */
&builtin_type_int,
    &builtin_type_long,
    &builtin_type_short,
    &builtin_type_char,
    &builtin_type_float,
    &builtin_type_double,
    &builtin_type_long_long,
    &builtin_type_void,
    &builtin_type_signed_char,
    &builtin_type_unsigned_char,
    &builtin_type_unsigned_short,
    &builtin_type_unsigned_int,
    &builtin_type_unsigned_long,
    &builtin_type_unsigned_long_long,
    &builtin_type_long_double,
    &builtin_type_complex, &builtin_type_double_complex, 0};
a10043 1
/* Not really used, but needed in the ada_language_defn. */
d10050 16
d10067 2
a10068 4
  "ada",			/* Language name */
  /*  language_ada, */
  language_unknown,
  /* FIXME: language_ada should be defined in defs.h */
d10072 8
a10079 3
  case_sensitive_on,		/* Yes, Ada is case-insensitive, but
				 * that's not quite what this means. */
  ada_parse,
d10081 1
a10081 1
  ada_evaluate_subexp,
d10090 2
a10091 2
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal  */
d10093 1
a10093 1
  NULL,				/* Language specific symbol demangler */
d10096 3
a10098 3
  {"8#%lo#", "8#", "o", "#"},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"16#%lx#", "16#", "x", "#"},	/* Hex format info */
d10100 4
a10103 4
  /* Copied from c-lang.c. */
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
d10105 3
a10107 3
  ada_op_print_tab,		/* expression operators for printing */
  1,				/* c-style arrays (FIXME?) */
  0,				/* String lower bound (FIXME?) */
d10109 5
a10113 1
  default_word_break_characters,
d10117 2
a10118 3
void
_initialize_ada_language (void)
{
d10121 1
a10121 1
	       0, "integer", (struct objfile *) NULL);
d10124 1
a10124 1
	       0, "long_integer", (struct objfile *) NULL);
d10127 1
a10127 1
	       0, "short_integer", (struct objfile *) NULL);
d10130 1
a10130 1
	       0, "character", (struct objfile *) NULL);
d10133 1
a10133 1
	       0, "float", (struct objfile *) NULL);
d10136 1
a10136 1
	       0, "long_float", (struct objfile *) NULL);
d10139 1
a10139 1
	       0, "long_long_integer", (struct objfile *) NULL);
d10142 1
a10142 1
	       0, "long_long_float", (struct objfile *) NULL);
d10145 1
a10145 1
	       0, "natural", (struct objfile *) NULL);
d10148 1
a10148 1
	       0, "positive", (struct objfile *) NULL);
d10153 1
a10153 1
				    (struct objfile *) NULL));
d10155 5
d10161 2
d10165 1
d10168 4
a10171 3
		  (char *) &varsize_limit,
		  "Set maximum bytes in dynamic-sized object.",
		  &setlist), &showlist);
d10174 6
a10179 4
  add_com ("begin", class_breakpoint, begin_command,
	   "Start the debugged program, stopping at the beginning of the\n\
main program.  You may specify command-line arguments to give it, as for\n\
the \"run\" command (q.v.).");
a10181 1

d10216 1
a10216 1
         reconstruction work, this should probably become an error. */
d10218 2
a10219 2
			TARGET_INT_BIT / TARGET_CHAR_BIT,
			0, "<?type?>", objfile);
d10224 2
a10225 2
			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			0, "void", objfile);
d10229 2
a10230 2
			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			0, "character", objfile);
d10234 2
a10235 2
			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			0, "signed char", objfile);
d10239 2
a10240 2
			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned char", objfile);
d10244 2
a10245 2
			TARGET_SHORT_BIT / TARGET_CHAR_BIT,
			0, "short_integer", objfile);
d10249 2
a10250 2
			TARGET_SHORT_BIT / TARGET_CHAR_BIT,
			0, "short_integer", objfile);
d10254 2
a10255 2
			TARGET_SHORT_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned short", objfile);
d10259 2
a10260 2
			TARGET_INT_BIT / TARGET_CHAR_BIT,
			0, "integer", objfile);
d10263 1
a10263 1
      type = init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT, 0, "integer", objfile);	/* FIXME -fnf */
d10267 2
a10268 2
			TARGET_INT_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned int", objfile);
d10272 2
a10273 2
			TARGET_LONG_BIT / TARGET_CHAR_BIT,
			0, "long_integer", objfile);
d10277 2
a10278 2
			TARGET_LONG_BIT / TARGET_CHAR_BIT,
			0, "long_integer", objfile);
d10282 2
a10283 2
			TARGET_LONG_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned long", objfile);
d10287 2
a10288 2
			TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
			0, "long_long_integer", objfile);
d10292 2
a10293 2
			TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
			0, "long_long_integer", objfile);
d10297 2
a10298 2
			TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned long long", objfile);
d10302 2
a10303 2
			TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
			0, "float", objfile);
d10307 2
a10308 2
			TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
			0, "long_float", objfile);
d10312 2
a10313 2
			TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
			0, "long_long_float", objfile);
d10325 1
a10325 1
	   s->dirname ? s->dirname : "?", s->filename ? s->filename : "?");
d10331 4
a10334 4
	{
	  struct linetable_entry *e = s->linetable->item + i;
	  fprintf (stderr, "    %4ld: %8lx\n", (long) e->line, (long) e->pc);
	}
@


1.35.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004.
a20 14

/* Sections of code marked 

     #ifdef GNAT_GDB 
     ...
     #endif

   indicate sections that are used in sources distributed by 
   ACT, Inc., but not yet integrated into the public tree (where
   GNAT_GDB is not defined).  They are retained here nevertheless 
   to minimize the problems of maintaining different versions 
   of the source and to make the full source available. */

#include "defs.h"
d26 1
a26 2
#include "gdb_regex.h"
#include "frame.h"
a38 2
#include "hashtab.h"
#include "gdb_obstack.h"
a39 3
#include "completer.h"
#include "gdb_stat.h"
#ifdef UI_OUT
a40 1
#endif
d45 1
a45 7
#ifndef ADA_RETAIN_DOTS
#define ADA_RETAIN_DOTS 0
#endif

/* Define whether or not the C operator '/' truncates towards zero for
   differently signed operands (truncation direction is undefined in C). 
   Copied from valarith.c.  */
d47 1
a47 25
#ifndef TRUNCATION_TOWARDS_ZERO
#define TRUNCATION_TOWARDS_ZERO ((-5 / 2) == -2)
#endif

#ifdef GNAT_GDB
/* A structure that contains a vector of strings.
   The main purpose of this type is to group the vector and its
   associated parameters in one structure.  This makes it easier
   to handle and pass around.  */

struct string_vector
{
  char **array; /* The vector itself.  */
  int index;    /* Index of the next available element in the array.  */
  size_t size;  /* The number of entries allocated in the array.  */
};

static struct string_vector xnew_string_vector (int initial_size);
static void string_vector_append (struct string_vector *sv, char *str);
#endif /* GNAT_GDB */

static const char *ada_unqualified_name (const char *decoded_name);
static char *add_angle_brackets (const char *str);
static void extract_string (CORE_ADDR addr, char *buf);
static char *function_name_from_pc (CORE_ADDR pc);
d85 1
a85 1
static struct value *ensure_lval (struct value *, CORE_ADDR *);
d88 1
a88 1
                                     CORE_ADDR *);
d91 1
a91 1
                                            CORE_ADDR *);
d93 2
a94 4
static void ada_add_block_symbols (struct obstack *,
                                   struct block *, const char *,
                                   domain_enum, struct objfile *,
                                   struct symtab *, int);
d96 1
a96 1
static int is_nonfunction (struct ada_symbol_info *, int);
d98 1
a98 2
static void add_defn_to_vec (struct obstack *, struct symbol *,
                             struct block *, struct symtab *);
d100 1
a100 3
static int num_defns_collected (struct obstack *);

static struct ada_symbol_info *defns_collected (struct obstack *, int);
d103 2
a104 2
                                                         *, const char *, int,
                                                         domain_enum, int);
d108 2
a109 2
static struct value *resolve_subexp (struct expression **, int *, int,
                                     struct type *);
d112 1
a112 1
                                        struct symbol *, struct block *);
d116 1
a116 3
static char *ada_op_name (enum exp_opcode);

static const char *ada_decoded_op_name (enum exp_opcode);
a125 3
static struct type *ada_lookup_struct_elt_type (struct type *, char *,
                                                int, int, int *);

d127 1
a127 1
                                           const char *);
d130 1
a130 1
                                      int *, enum noside);
d139 1
a139 3
                                                  CORE_ADDR, struct value *);

static struct type *to_fixed_array_type (struct type *, struct value *, int);
d142 1
a142 1
                                         struct objfile *);
d155 1
a155 1
                                             struct value **);
d157 2
a158 2
static struct value *coerce_unspec_val_to_type (struct value *,
                                                struct type *);
d170 4
a173 3
static struct symtabs_and_lines
find_sal_from_funcs_and_line (const char *, int,
                              struct ada_symbol_info *, int);
d175 2
a176 2
static int find_line_in_linetable (struct linetable *, int,
                                   struct ada_symbol_info *, int, int *);
d180 3
a188 2
static LONGEST pos_atr (struct value *);

d193 1
a193 16
static struct symbol *standard_lookup (const char *, const struct block *,
                                       domain_enum);

static struct value *ada_search_struct_field (char *, struct value *, int,
                                              struct type *);

static struct value *ada_value_primitive_field (struct value *, int, int,
                                                struct type *);

static int find_struct_field (char *, struct type *, int,
                              struct type **, int *, int *, int *);

static struct value *ada_to_fixed_value_create (struct type *, CORE_ADDR,
                                                struct value *);

static struct value *ada_to_fixed_value (struct value *);
d195 2
a196 13
static void adjust_pc_past_prologue (CORE_ADDR *);

static int ada_resolve_function (struct ada_symbol_info *, int,
                                 struct value **, int, const char *,
                                 struct type *);

static struct value *ada_coerce_to_simple_array (struct value *);

static int ada_is_direct_array_type (struct type *);

static void error_breakpoint_runtime_sym_not_found (const char *err_desc);

static int is_runtime_sym_defined (const char *name, int allow_tramp);
d200 1
a200 1
/* Maximum-sized dynamic type.  */
d203 1
a203 6
/* FIXME: brobecker/2003-09-17: No longer a const because it is
   returned by a function that does not return a const char *.  */
static char *ada_completer_word_break_characters =
#ifdef VMS
  " \t\n!@@#%^&*()+=|~`}{[]\";:?/,-";
#else
a204 35
#endif

/* The name of the symbol to use to get the name of the main subprogram.  */
static const char ADA_MAIN_PROGRAM_SYMBOL_NAME[]
  = "__gnat_ada_main_program_name";

/* The name of the runtime function called when an exception is raised.  */
static const char raise_sym_name[] = "__gnat_raise_nodefer_with_msg";

/* The name of the runtime function called when an unhandled exception
   is raised.  */
static const char raise_unhandled_sym_name[] = "__gnat_unhandled_exception";

/* The name of the runtime function called when an assert failure is
   raised.  */
static const char raise_assert_sym_name[] =
  "system__assertions__raise_assert_failure";

/* When GDB stops on an unhandled exception, GDB will go up the stack until
   if finds a frame corresponding to this function, in order to extract the
   name of the exception that has been raised from one of the parameters.  */
static const char process_raise_exception_name[] =
  "ada__exceptions__process_raise_exception";

/* A string that reflects the longest exception expression rewrite,
   aside from the exception name.  */
static const char longest_exception_template[] =
  "'__gnat_raise_nodefer_with_msg' if long_integer(e) = long_integer(&)";

/* Limit on the number of warnings to raise per expression evaluation.  */
static int warning_limit = 2;

/* Number of warning messages issued; reset to 0 by cleanups after
   expression evaluation.  */
static int warnings_issued = 0;
d206 2
a207 3
static const char *known_runtime_file_name_patterns[] = {
  ADA_KNOWN_RUNTIME_FILE_NAME_PATTERNS NULL
};
d209 1
a209 3
static const char *known_auxiliary_function_name_patterns[] = {
  ADA_KNOWN_AUXILIARY_FUNCTION_NAME_PATTERNS NULL
};
d211 6
a216 79
/* Space for allocating results of ada_lookup_symbol_list.  */
static struct obstack symbol_list_obstack;

                        /* Utilities */

#ifdef GNAT_GDB

/* Create a new empty string_vector struct with an initial size of
   INITIAL_SIZE.  */

static struct string_vector
xnew_string_vector (int initial_size)
{
  struct string_vector result;

  result.array = (char **) xmalloc ((initial_size + 1) * sizeof (char *));
  result.index = 0;
  result.size = initial_size;

  return result;
}

/* Add STR at the end of the given string vector SV.  If SV is already
   full, its size is automatically increased (doubled).  */

static void
string_vector_append (struct string_vector *sv, char *str)
{
  if (sv->index >= sv->size)
    GROW_VECT (sv->array, sv->size, sv->size * 2);

  sv->array[sv->index] = str;
  sv->index++;
}

/* Given DECODED_NAME a string holding a symbol name in its
   decoded form (ie using the Ada dotted notation), returns
   its unqualified name.  */

static const char *
ada_unqualified_name (const char *decoded_name)
{
  const char *result = strrchr (decoded_name, '.');

  if (result != NULL)
    result++;                   /* Skip the dot...  */
  else
    result = decoded_name;

  return result;
}

/* Return a string starting with '<', followed by STR, and '>'.
   The result is good until the next call.  */

static char *
add_angle_brackets (const char *str)
{
  static char *result = NULL;

  xfree (result);
  result = (char *) xmalloc ((strlen (str) + 3) * sizeof (char));

  sprintf (result, "<%s>", str);
  return result;
}

#endif /* GNAT_GDB */

static char *
ada_get_gdb_completer_word_break_characters (void)
{
  return ada_completer_word_break_characters;
}

/* Read the string located at ADDR from the inferior and store the
   result into BUF.  */

static void
d221 2
a222 2
  /* Loop, reading one byte at a time, until we reach the '\000'
     end-of-string marker.  */
d226 1
a226 1
                          buf + char_index * sizeof (char), sizeof (char));
a231 14
/* Return the name of the function owning the instruction located at PC.
   Return NULL if no such function could be found.  */

static char *
function_name_from_pc (CORE_ADDR pc)
{
  char *func_name;

  if (!find_pc_partial_function (pc, &func_name, NULL, NULL))
    return NULL;

  return func_name;
}

d234 1
a234 1
   updating *OLD_VECT and *SIZE as necessary.  */
d243 1
a243 1
        *size = min_size;
d249 1
a249 1
   suffix of FIELD_NAME beginning "___".  */
d256 4
a259 5
    (strncmp (field_name, target, len) == 0
     && (field_name[len] == '\0'
         || (strncmp (field_name + len, "___", 3) == 0
             && strcmp (field_name + strlen (field_name) - 6,
                        "___XVN") != 0)));
d263 1
a263 24
/* Assuming TYPE is a TYPE_CODE_STRUCT, find the field whose name matches
   FIELD_NAME, and return its index.  This function also handles fields
   whose name have ___ suffixes because the compiler sometimes alters
   their name by adding such a suffix to represent fields with certain
   constraints.  If the field could not be found, return a negative
   number if MAYBE_MISSING is set.  Otherwise raise an error.  */

int
ada_get_field_index (const struct type *type, const char *field_name,
                     int maybe_missing)
{
  int fieldno;
  for (fieldno = 0; fieldno < TYPE_NFIELDS (type); fieldno++)
    if (field_name_match (TYPE_FIELD_NAME (type, fieldno), field_name))
      return fieldno;

  if (!maybe_missing)
    error ("Unable to find field %s in struct %s.  Aborting",
           field_name, TYPE_NAME (type));

  return -1;
}

/* The length of the prefix of NAME prior to any "___" suffix.  */
d274 1
a274 1
        return strlen (name);
d276 1
a276 1
        return p - name;
d280 1
a280 3
/* Return non-zero if SUFFIX is a suffix of STR.
   Return zero if STR is null.  */

d289 1
a289 1
  return (len1 >= len2 && strcmp (str + len1 - len2, suffix) == 0);
d293 2
a294 3
   is non-null, and whose memory address (in the inferior) is
   ADDRESS.  */

d297 1
a297 1
                                 CORE_ADDR address)
d310 2
a311 2
/* The contents of value VAL, treated as a value of type TYPE.  The
   result is an lval in memory if VAL is.  */
d314 1
a314 1
coerce_unspec_val_to_type (struct value *val, struct type *type)
d317 4
a320 2
  if (VALUE_TYPE (val) == type)
    return val;
d323 6
a328 15
      struct value *result;

      /* Make sure that the object size is not unreasonable before
         trying to allocate some memory for it.  */
      if (TYPE_LENGTH (type) > varsize_limit)
        error ("object size is larger than varsize-limit");

      result = allocate_value (type);
      VALUE_LVAL (result) = VALUE_LVAL (val);
      VALUE_BITSIZE (result) = VALUE_BITSIZE (val);
      VALUE_BITPOS (result) = VALUE_BITPOS (val);
      VALUE_ADDRESS (result) = VALUE_ADDRESS (val) + VALUE_OFFSET (val);
      if (VALUE_LAZY (val)
          || TYPE_LENGTH (type) > TYPE_LENGTH (VALUE_TYPE (val)))
        VALUE_LAZY (result) = 1;
d330 5
a334 2
        memcpy (VALUE_CONTENTS_RAW (result), VALUE_CONTENTS (val),
                TYPE_LENGTH (type));
d357 2
a358 4
/* Issue a warning (as for the definition of warning in utils.c, but
   with exactly one argument rather than ...), unless the limit on the
   number of warnings has passed during the evaluation of the current
   expression.  */
d360 1
a360 1
lim_warning (const char *format, long arg)
d362 17
a378 111
  warnings_issued += 1;
  if (warnings_issued <= warning_limit)
    warning (format, arg);
}

static const char *
ada_translate_error_message (const char *string)
{
  if (strcmp (string, "Invalid cast.") == 0)
    return "Invalid type conversion.";
  else
    return string;
}

/* Note: would have used MAX_OF_TYPE and MIN_OF_TYPE macros from
   gdbtypes.h, but some of the necessary definitions in that file
   seem to have gone missing. */

/* Maximum value of a SIZE-byte signed integer type. */
static LONGEST
max_of_size (int size)
{
  LONGEST top_bit = (LONGEST) 1 << (size * 8 - 2);
  return top_bit | (top_bit - 1);
}

/* Minimum value of a SIZE-byte signed integer type. */
static LONGEST
min_of_size (int size)
{
  return -max_of_size (size) - 1;
}

/* Maximum value of a SIZE-byte unsigned integer type. */
static ULONGEST
umax_of_size (int size)
{
  ULONGEST top_bit = (ULONGEST) 1 << (size * 8 - 1);
  return top_bit | (top_bit - 1);
}

/* Maximum value of integral type T, as a signed quantity. */
static LONGEST
max_of_type (struct type *t)
{
  if (TYPE_UNSIGNED (t))
    return (LONGEST) umax_of_size (TYPE_LENGTH (t));
  else
    return max_of_size (TYPE_LENGTH (t));
}

/* Minimum value of integral type T, as a signed quantity. */
static LONGEST
min_of_type (struct type *t)
{
  if (TYPE_UNSIGNED (t)) 
    return 0;
  else
    return min_of_size (TYPE_LENGTH (t));
}

/* The largest value in the domain of TYPE, a discrete type, as an integer.  */
static struct value *
discrete_type_high_bound (struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_RANGE:
      return value_from_longest (TYPE_TARGET_TYPE (type),
                                 TYPE_HIGH_BOUND (type));
    case TYPE_CODE_ENUM:
      return
        value_from_longest (type,
                            TYPE_FIELD_BITPOS (type,
                                               TYPE_NFIELDS (type) - 1));
    case TYPE_CODE_INT:
      return value_from_longest (type, max_of_type (type));
    default:
      error ("Unexpected type in discrete_type_high_bound.");
    }
}

/* The largest value in the domain of TYPE, a discrete type, as an integer.  */
static struct value *
discrete_type_low_bound (struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_RANGE:
      return value_from_longest (TYPE_TARGET_TYPE (type),
                                 TYPE_LOW_BOUND (type));
    case TYPE_CODE_ENUM:
      return value_from_longest (type, TYPE_FIELD_BITPOS (type, 0));
    case TYPE_CODE_INT:
      return value_from_longest (type, min_of_type (type));
    default:
      error ("Unexpected type in discrete_type_low_bound.");
    }
}

/* The identity on non-range types.  For range types, the underlying
   non-range scalar type.  */

static struct type *
base_type (struct type *type)
{
  while (type != NULL && TYPE_CODE (type) == TYPE_CODE_RANGE)
    {
      if (type == TYPE_TARGET_TYPE (type) || TYPE_TARGET_TYPE (type) == NULL)
        return type;
      type = TYPE_TARGET_TYPE (type);
d380 2
a381 1
  return type;
d385 1
a385 1
                                /* Language Selection */
d390 1
a390 1
   MAIN_PST is not used.  */
d394 1
a394 1
                             struct partial_symtab *main_pst)
d397 4
a400 2
                             (struct objfile *) NULL) != NULL)
    return language_ada;
d404 1
d406 1
a406 32
/* If the main procedure is written in Ada, then return its name.
   The result is good until the next call.  Return NULL if the main
   procedure doesn't appear to be in Ada.  */

char *
ada_main_name (void)
{
  struct minimal_symbol *msym;
  CORE_ADDR main_program_name_addr;
  static char main_program_name[1024];
  /* For Ada, the name of the main procedure is stored in a specific
     string constant, generated by the binder.  Look for that symbol,
     extract its address, and then read that string.  If we didn't find
     that string, then most probably the main procedure is not written
     in Ada.  */
  msym = lookup_minimal_symbol (ADA_MAIN_PROGRAM_SYMBOL_NAME, NULL, NULL);

  if (msym != NULL)
    {
      main_program_name_addr = SYMBOL_VALUE_ADDRESS (msym);
      if (main_program_name_addr == 0)
        error ("Invalid address for Ada main program name.");

      extract_string (main_program_name_addr, main_program_name);
      return main_program_name;
    }

  /* The main procedure doesn't seem to be in Ada.  */
  return NULL;
}

                                /* Symbols */
d408 2
a409 2
/* Table of Ada operators and their GNAT-encoded names.  Last entry is pair
   of NULLs.  */
d436 1
a436 2
/* Return non-zero if STR should be suppressed in info listings.  */

d440 1
a440 1
  if (strncmp (str, "_ada_", 5) == 0)
d449 1
a449 1
        return 1;
d451 1
a451 1
        suffix = str + strlen (str);
d453 14
a466 14
        if (isupper (*p))
          {
            int i;
            if (p[0] == 'X' && p[-1] != '_')
              goto OK;
            if (*p != 'O')
              return 1;
            for (i = 0; ada_opname_table[i].encoded != NULL; i += 1)
              if (strncmp (ada_opname_table[i].encoded, p,
                           strlen (ada_opname_table[i].encoded)) == 0)
                goto OK;
            return 1;
          OK:;
          }
d471 2
a472 3
/* The "encoded" form of DECODED, according to GNAT conventions.
   The result is valid until the next call to ada_encode.  */

d474 1
a474 1
ada_encode (const char *decoded)
d476 2
a477 2
  static char *encoding_buffer = NULL;
  static size_t encoding_buffer_size = 0;
d481 1
a481 1
  if (decoded == NULL)
d484 2
a485 2
  GROW_VECT (encoding_buffer, encoding_buffer_size,
             2 * strlen (decoded) + 10);
d488 1
a488 1
  for (p = decoded; *p != '\0'; p += 1)
d490 5
a494 5
      if (!ADA_RETAIN_DOTS && *p == '.')
        {
          encoding_buffer[k] = encoding_buffer[k + 1] = '_';
          k += 2;
        }
d496 2
a497 2
        {
          const struct ada_opname_map *mapping;
d499 16
a514 16
          for (mapping = ada_opname_table;
               mapping->encoded != NULL
               && strncmp (mapping->decoded, p,
                           strlen (mapping->decoded)) != 0; mapping += 1)
            ;
          if (mapping->encoded == NULL)
            error ("invalid Ada operator name: %s", p);
          strcpy (encoding_buffer + k, mapping->encoded);
          k += strlen (mapping->encoded);
          break;
        }
      else
        {
          encoding_buffer[k] = *p;
          k += 1;
        }
d517 2
a518 2
  encoding_buffer[k] = '\0';
  return encoding_buffer;
d522 2
a523 3
   quotes, unfolded, but with the quotes stripped away.  Result good
   to next call.  */

d542 1
a542 1
        fold_buffer[i] = tolower (name[i]);
d548 2
a549 5
/* decode:
     0. Discard trailing .{DIGIT}+ or trailing ___{DIGIT}+
        These are suffixes introduced by GNAT5 to nested subprogram
        names, and do not serve any purpose for the debugger.
     1. Discard final __{DIGIT}+ or $({DIGIT}+(__{DIGIT}+)*)
d553 1
a553 1
     5. Remove everything after first ___ if it is followed by
d558 2
d561 2
a562 6
   The resulting string is valid until the next call of ada_decode.
   If the string is unchanged by demangling, the original string pointer
   is returned.  */

const char *
ada_decode (const char *encoded)
d567 1
a567 1
  char *decoded;
d569 2
a570 2
  static char *decoding_buffer = NULL;
  static size_t decoding_buffer_size = 0;
d572 2
a573 2
  if (strncmp (encoded, "_ada_", 5) == 0)
    encoded += 5;
d575 1
a575 1
  if (encoded[0] == '_' || encoded[0] == '<')
d578 4
a581 19
  /* Remove trailing .{DIGIT}+ or ___{DIGIT}+.  */
  len0 = strlen (encoded);
  if (len0 > 1 && isdigit (encoded[len0 - 1]))
    {
      i = len0 - 2;
      while (i > 0 && isdigit (encoded[i]))
        i--;
      if (i >= 0 && encoded[i] == '.')
        len0 = i;
      else if (i >= 2 && strncmp (encoded + i - 2, "___", 3) == 0)
        len0 = i - 2;
    }

  /* Remove the ___X.* suffix if present.  Do not forget to verify that
     the suffix is located before the current "end" of ENCODED.  We want
     to avoid re-matching parts of ENCODED that have previously been
     marked as discarded (by decrementing LEN0).  */
  p = strstr (encoded, "___");
  if (p != NULL && p - encoded < len0 - 3)
d584 1
a584 1
        len0 = p - encoded;
d586 1
a586 1
        goto Suppress;
d588 1
a588 2

  if (len0 > 3 && strncmp (encoded + len0 - 3, "TKB", 3) == 0)
d590 1
a590 2

  if (len0 > 1 && strncmp (encoded + len0 - 1, "B", 1) == 0)
d593 12
a604 14
  /* Make decoded big enough for possible expansion by operator name.  */
  GROW_VECT (decoding_buffer, decoding_buffer_size, 2 * len0 + 1);
  decoded = decoding_buffer;

  if (len0 > 1 && isdigit (encoded[len0 - 1]))
    {
      i = len0 - 2;
      while ((i >= 0 && isdigit (encoded[i]))
             || (i >= 1 && encoded[i] == '_' && isdigit (encoded[i - 1])))
        i -= 1;
      if (i > 1 && encoded[i] == '_' && encoded[i - 1] == '_')
        len0 = i - 1;
      else if (encoded[i] == '$')
        len0 = i;
d607 2
a608 2
  for (i = 0, j = 0; i < len0 && !isalpha (encoded[i]); i += 1, j += 1)
    decoded[j] = encoded[i];
d613 20
a632 20
      if (at_start_name && encoded[i] == 'O')
        {
          int k;
          for (k = 0; ada_opname_table[k].encoded != NULL; k += 1)
            {
              int op_len = strlen (ada_opname_table[k].encoded);
              if ((strncmp (ada_opname_table[k].encoded + 1, encoded + i + 1,
                            op_len - 1) == 0)
                  && !isalnum (encoded[i + op_len]))
                {
                  strcpy (decoded + j, ada_opname_table[k].decoded);
                  at_start_name = 0;
                  i += op_len;
                  j += strlen (ada_opname_table[k].decoded);
                  break;
                }
            }
          if (ada_opname_table[k].encoded != NULL)
            continue;
        }
d635 23
a657 24
      if (i < len0 - 4 && strncmp (encoded + i, "TK__", 4) == 0)
        i += 2;
      if (encoded[i] == 'X' && i != 0 && isalnum (encoded[i - 1]))
        {
          do
            i += 1;
          while (i < len0 && (encoded[i] == 'b' || encoded[i] == 'n'));
          if (i < len0)
            goto Suppress;
        }
      else if (!ADA_RETAIN_DOTS
               && i < len0 - 2 && encoded[i] == '_' && encoded[i + 1] == '_')
        {
          decoded[j] = '.';
          at_start_name = 1;
          i += 2;
          j += 1;
        }
      else
        {
          decoded[j] = encoded[i];
          i += 1;
          j += 1;
        }
d659 1
a659 1
  decoded[j] = '\000';
d661 2
a662 2
  for (i = 0; decoded[i] != '\0'; i += 1)
    if (isupper (decoded[i]) || decoded[i] == ' ')
d665 1
a665 4
  if (strcmp (decoded, encoded) == 0)
    return encoded;
  else
    return decoded;
d668 7
a674 66
  GROW_VECT (decoding_buffer, decoding_buffer_size, strlen (encoded) + 3);
  decoded = decoding_buffer;
  if (encoded[0] == '<')
    strcpy (decoded, encoded);
  else
    sprintf (decoded, "<%s>", encoded);
  return decoded;

}

/* Table for keeping permanent unique copies of decoded names.  Once
   allocated, names in this table are never released.  While this is a
   storage leak, it should not be significant unless there are massive
   changes in the set of decoded names in successive versions of a 
   symbol table loaded during a single session.  */
static struct htab *decoded_names_store;

/* Returns the decoded name of GSYMBOL, as for ada_decode, caching it
   in the language-specific part of GSYMBOL, if it has not been
   previously computed.  Tries to save the decoded name in the same
   obstack as GSYMBOL, if possible, and otherwise on the heap (so that,
   in any case, the decoded symbol has a lifetime at least that of
   GSYMBOL).  
   The GSYMBOL parameter is "mutable" in the C++ sense: logically
   const, but nevertheless modified to a semantically equivalent form
   when a decoded name is cached in it.
*/

char *
ada_decode_symbol (const struct general_symbol_info *gsymbol)
{
  char **resultp =
    (char **) &gsymbol->language_specific.cplus_specific.demangled_name;
  if (*resultp == NULL)
    {
      const char *decoded = ada_decode (gsymbol->name);
      if (gsymbol->bfd_section != NULL)
        {
          bfd *obfd = gsymbol->bfd_section->owner;
          if (obfd != NULL)
            {
              struct objfile *objf;
              ALL_OBJFILES (objf)
              {
                if (obfd == objf->obfd)
                  {
                    *resultp = obsavestring (decoded, strlen (decoded),
                                             &objf->objfile_obstack);
                    break;
                  }
              }
            }
        }
      /* Sometimes, we can't find a corresponding objfile, in which
         case, we put the result on the heap.  Since we only decode
         when needed, we hope this usually does not cause a
         significant memory leak (FIXME).  */
      if (*resultp == NULL)
        {
          char **slot = (char **) htab_find_slot (decoded_names_store,
                                                  decoded, INSERT);
          if (*slot == NULL)
            *slot = xstrdup (decoded);
          *resultp = *slot;
        }
    }
a675 7
  return *resultp;
}

char *
ada_la_decode (const char *encoded, int options)
{
  return xstrdup (ada_decode (encoded));
d679 5
a683 5
   suffixes that encode debugging information or leading _ada_ on
   SYM_NAME (see is_name_suffix commentary for the debugging
   information that is ignored).  If WILD, then NAME need only match a
   suffix of SYM_NAME minus the same suffixes.  Also returns 0 if
   either argument is NULL.  */
d695 5
a699 5
      return (strncmp (sym_name, name, len_name) == 0
              && is_name_suffix (sym_name + len_name))
        || (strncmp (sym_name, "_ada_", 5) == 0
            && strncmp (sym_name + 5, name, len_name) == 0
            && is_name_suffix (sym_name + len_name + 5));
d703 2
a704 2
/* True (non-zero) iff, in Ada mode, the symbol SYM should be
   suppressed in info listings.  */
d712 1
a712 1
    return is_suppressed_name (SYMBOL_LINKAGE_NAME (sym));
d716 1
a716 1
                                /* Arrays */
d718 2
a719 1
/* Names of MAX_ADA_DIMENS bounds in P_BOUNDS fields of array descriptors.  */
d728 1
a728 1
#define MAX_ADA_DIMENS (sizeof(bound_name) / (2*sizeof(char *)))
d730 1
a730 1
/* Like modify_field, but allows bitpos > wordlength.  */
d735 2
a736 1
  modify_field (addr + bitpos / 8, fieldval, bitpos % 8, bitsize);
d740 2
a741 2
/* The desc_* routines return primitive portions of array descriptors
   (fat pointers).  */
d744 1
a744 2
   level of indirection, if needed.  */

d751 1
a751 3
  if (type != NULL
      && (TYPE_CODE (type) == TYPE_CODE_PTR
          || TYPE_CODE (type) == TYPE_CODE_REF))
d757 1
a757 2
/* True iff TYPE indicates a "thin" array pointer type.  */

d766 1
a766 2
/* The descriptor type for thin pointer type TYPE.  */

d779 1
a779 1
        return base_type;
d781 1
a781 1
        return alt_type;
d785 1
a785 2
/* A pointer to the array data for thin-pointer value VAL.  */

d792 1
a792 1
                       value_copy (val));
d795 1
a795 1
                               VALUE_ADDRESS (val) + VALUE_OFFSET (val));
d798 1
a798 2
/* True iff TYPE indicates a "thick" array pointer type.  */

d804 1
a804 1
          && lookup_struct_elt_type (type, "P_BOUNDS", 1) != NULL);
d807 2
a808 3
/* If TYPE is the type of an array descriptor (fat or thin pointer) or a
   pointer to one, the type of its bounds data; otherwise, NULL.  */

d822 1
a822 1
        return NULL;
d825 1
a825 1
        return check_typedef (r);
d831 1
a831 1
        return check_typedef (TYPE_TARGET_TYPE (check_typedef (r)));
d837 1
a837 2
   one, a pointer to its bounds data.   Otherwise NULL.  */

d845 1
a845 1
        desc_bounds_type (thin_descriptor_type (type));
d849 1
a849 1
        error ("Bad GNAT array descriptor");
d853 1
a853 1
         the correct calculation is a real pain.  FIXME (and fix GCC).  */
d855 1
a855 1
        addr = value_as_long (arr);
d857 1
a857 1
        addr = VALUE_ADDRESS (arr) + VALUE_OFFSET (arr);
d860 2
a861 2
        value_from_longest (lookup_pointer_type (bounds_type),
                            addr - TYPE_LENGTH (bounds_type));
d866 1
a866 1
                             "Bad GNAT array descriptor");
d871 2
a872 3
/* If TYPE is the type of an array-descriptor (fat pointer),  the bit
   position of the field containing the address of the bounds data.  */

d880 1
a880 2
   size of the field containing the address of the bounds data.  */

d892 1
a892 1
/* If TYPE is the type of an array descriptor (fat or thin pointer) or a
d894 2
a895 3
   pointer-to-array-with-no-bounds type); otherwise, NULL.  Use
   ada_type_of_array to get an array type with bounds data.  */

d901 1
a901 1
  /* NOTE: The following is bogus; see comment in desc_bounds.  */
a912 1

d921 1
a921 1
                             "Bad GNAT array descriptor");
d928 1
a928 2
   position of the field containing the address of the data.  */

d936 1
a936 2
   size of the field containing the address of the data.  */

d948 1
a948 1
/* If BOUNDS is an array-bounds structure (or pointer to one), return
d950 1
a950 2
   bound, if WHICH is 1.  The first bound is I=1.  */

d955 1
a955 1
                           "Bad GNAT array descriptor bounds");
d960 1
a960 2
   bound, if WHICH is 1.  The first bound is I=1.  */

d969 1
a969 2
   bound, if WHICH is 1.  The first bound is I=1.  */

d982 1
a982 2
   Ith bound (numbering from 1).  Otherwise, NULL.  */

d994 2
a995 3
/* The number of index positions in the array-bounds type TYPE.
   Return 0 if TYPE is NULL.  */

a1005 15
/* Non-zero iff TYPE is a simple array type (not a pointer to one) or 
   an array descriptor type (representing an unconstrained array
   type).  */

static int
ada_is_direct_array_type (struct type *type)
{
  if (type == NULL)
    return 0;
  CHECK_TYPEDEF (type);
  return (TYPE_CODE (type) == TYPE_CODE_ARRAY
          || ada_is_array_descriptor_type (type));
}

/* Non-zero iff TYPE is a simple array type or pointer to one.  */
d1007 1
d1009 1
a1009 1
ada_is_simple_array_type (struct type *type)
d1015 2
a1016 2
          || (TYPE_CODE (type) == TYPE_CODE_PTR
              && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ARRAY));
d1019 1
a1019 2
/* Non-zero iff TYPE belongs to a GNAT array descriptor.  */

d1021 1
a1021 1
ada_is_array_descriptor_type (struct type *type)
d1031 4
a1034 3
         && TYPE_TARGET_TYPE (data_type) != NULL
         && TYPE_CODE (TYPE_TARGET_TYPE (data_type)) == TYPE_CODE_ARRAY)
        || TYPE_CODE (data_type) == TYPE_CODE_ARRAY)
d1039 1
a1039 1
   descriptor.  FIXME: This is to compensate for some problems with
d1041 1
a1041 2
   is still needed.  */

d1049 2
a1050 2
        || lookup_struct_elt_type (type, "P_ARRAY", 1) != NULL)
    && !ada_is_array_descriptor_type (type);
d1054 1
a1054 1
/* If ARR has a record type in the form of a standard GNAT array descriptor,
d1056 1
a1056 1
   a pointer-to-array type.  If BOUNDS is non-zero, the bounds data are filled
d1058 2
a1059 2
   the ARR denotes a null array descriptor and BOUNDS is non-zero,
   returns NULL.  The result is simply the type of ARR if ARR is not
d1067 1
a1067 1
  if (!ada_is_array_descriptor_type (VALUE_TYPE (arr)))
d1084 1
a1084 1
        return check_typedef (VALUE_TYPE (arr));
d1088 1
a1088 1
        return NULL;
d1090 12
a1101 12
        {
          struct type *range_type = alloc_type (objf);
          struct type *array_type = alloc_type (objf);
          struct value *low = desc_one_bound (descriptor, arity, 0);
          struct value *high = desc_one_bound (descriptor, arity, 1);
          arity -= 1;

          create_range_type (range_type, VALUE_TYPE (low),
                             (int) value_as_long (low),
                             (int) value_as_long (high));
          elt_type = create_array_type (array_type, elt_type, range_type);
        }
d1108 3
a1110 4
   Otherwise, returns either a standard GDB array with bounds set
   appropriately or, if ARR is a non-null fat pointer, a pointer to a standard
   GDB array.  Returns NULL if ARR is a null fat pointer.  */

d1114 1
a1114 1
  if (ada_is_array_descriptor_type (VALUE_TYPE (arr)))
d1118 1
a1118 1
        return NULL;
d1129 2
a1130 3
   be ARR itself if it already is in the proper form).  */

static struct value *
d1133 1
a1133 1
  if (ada_is_array_descriptor_type (VALUE_TYPE (arr)))
d1137 1
a1137 1
        error ("Bounds unavailable for null array pointer.");
d1148 1
a1148 2
   packing).  For other types, is the identity.  */

d1157 1
a1157 1
  value_free_to_mark (mark);
d1161 1
a1161 2
/* Non-zero iff TYPE represents a standard GNAT packed-array type.  */

a1166 1
  type = desc_base_type (type);
d1179 2
a1180 3
   TYPE_FIELD_BITSIZE values, and with *ELT_BITS set to its total size
   in bits.  */

d1194 1
a1194 1
                                    elt_bits);
d1200 1
a1200 1
                           &low_bound, &high_bound) < 0)
d1208 1
a1208 1
        (*elt_bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;
d1211 2
a1212 1
  TYPE_FLAGS (new_type) |= TYPE_FLAG_FIXED_INSTANCE;
d1216 2
a1217 2
/* The array type encoded by TYPE, where ada_is_packed_array_type (TYPE).  */

d1221 1
a1221 1
  struct symbol *sym;
a1229 2
  type = desc_base_type (type);

d1233 9
a1241 2
  sym = standard_lookup (name, get_selected_block (0), VAR_DOMAIN);
  if (sym == NULL || SYMBOL_TYPE (sym) == NULL)
d1243 1
a1243 1
      lim_warning ("could not find bounds information on packed array", 0);
d1246 1
a1246 1
  shadow_type = SYMBOL_TYPE (sym);
d1250 1
a1250 2
      lim_warning ("could not understand bounds information on packed array",
                   0);
d1256 1
a1256 2
      lim_warning
        ("could not understand bit size information on packed array", 0);
d1263 1
a1263 1
/* Given that ARR is a struct value *indicating a GNAT packed array,
d1267 1
a1267 1
   type length is set appropriately.  */
d1272 1
a1272 1
  struct type *type;
a1273 5
  arr = ada_coerce_ref (arr);
  if (TYPE_CODE (VALUE_TYPE (arr)) == TYPE_CODE_PTR)
    arr = ada_value_ind (arr);

  type = decode_packed_array_type (VALUE_TYPE (arr));
d1279 2
a1280 1
  return coerce_unspec_val_to_type (arr, type);
d1285 1
a1285 1
   given in IND.   ARR must be a simple array.  */
d1302 22
a1323 22
          || TYPE_FIELD_BITSIZE (elt_type, 0) == 0)
        error
          ("attempt to do packed indexing of something other than a packed array");
      else
        {
          struct type *range_type = TYPE_INDEX_TYPE (elt_type);
          LONGEST lowerbound, upperbound;
          LONGEST idx;

          if (get_discrete_bounds (range_type, &lowerbound, &upperbound) < 0)
            {
              lim_warning ("don't know bounds of array", 0);
              lowerbound = upperbound = 0;
            }

          idx = value_as_long (value_pos_atr (ind[i]));
          if (idx < lowerbound || idx > upperbound)
            lim_warning ("packed array index %ld out of bounds", (long) idx);
          bits = TYPE_FIELD_BITSIZE (elt_type, 0);
          elt_total_bit_offset += (idx - lowerbound) * bits;
          elt_type = check_typedef (TYPE_TARGET_TYPE (elt_type));
        }
d1329 1
a1329 1
                                      bits, elt_type);
d1337 1
a1337 1
/* Non-zero iff TYPE includes negative integer values.  */
d1357 5
a1361 5
   assigning through the result will set the field fetched from.  
   VALADDR is ignored unless OBJ is NULL, in which case,
   VALADDR+OFFSET must address the start of storage containing the 
   packed value.  The value returned  in this case is never an lval.
   Assumes 0 <= BIT_OFFSET < HOST_CHAR_BIT.  */
d1365 2
a1366 2
                                int bit_offset, int bit_size,
                                struct type *type)
d1369 8
a1376 8
  int src,                      /* Index into the source area */
    targ,                       /* Index into the target area */
    srcBitsLeft,                /* Number of source bits left to move */
    nsrc, ntarg,                /* Number of source and target bytes */
    unusedLS,                   /* Number of bits in next significant
                                   byte of source that are unused */
    accumSize;                  /* Number of meaningful bits in accum */
  unsigned char *bytes;         /* First byte containing data to unpack */
d1378 1
a1378 1
  unsigned long accum;          /* Staging area for bits being transferred */
d1381 2
a1382 2
  /* Transmit bytes from least to most significant; delta is the direction
     the indices move.  */
d1395 1
a1395 1
                    VALUE_ADDRESS (obj) + VALUE_OFFSET (obj) + offset, NULL);
d1409 1
a1409 1
        VALUE_LVAL (v) = lval_internalvar_component;
d1414 4
a1417 4
        {
          VALUE_ADDRESS (v) += 1;
          VALUE_BITPOS (v) -= HOST_CHAR_BIT;
        }
d1435 3
a1437 3
      if (has_negatives (type)
          && ((bytes[0] << bit_offset) & (1 << (HOST_CHAR_BIT - 1))))
        sign = ~0;
d1440 2
a1441 2
        (HOST_CHAR_BIT - (bit_size + bit_offset) % HOST_CHAR_BIT)
        % HOST_CHAR_BIT;
d1444 16
a1459 16
        {
        case TYPE_CODE_ARRAY:
        case TYPE_CODE_UNION:
        case TYPE_CODE_STRUCT:
          /* Non-scalar values must be aligned at a byte boundary...  */
          accumSize =
            (HOST_CHAR_BIT - bit_size % HOST_CHAR_BIT) % HOST_CHAR_BIT;
          /* ... And are placed at the beginning (most-significant) bytes
             of the target.  */
          targ = src;
          break;
        default:
          accumSize = 0;
          targ = TYPE_LENGTH (type) - 1;
          break;
        }
d1470 1
a1470 1
        sign = ~0;
d1477 1
a1477 1
         part of the value.  */
d1479 3
a1481 3
        (1 << (srcBitsLeft >= HOST_CHAR_BIT ? HOST_CHAR_BIT : srcBitsLeft)) -
        1;
      /* Sign-extend bits for this byte.  */
d1484 1
a1484 1
        (((bytes[src] >> unusedLS) & unusedMSMask) | signMask) << accumSize;
d1487 7
a1493 7
        {
          unpacked[targ] = accum & ~(~0L << HOST_CHAR_BIT);
          accumSize -= HOST_CHAR_BIT;
          accum >>= HOST_CHAR_BIT;
          ntarg -= 1;
          targ += delta;
        }
d1514 1
a1514 1
   not overlap.  */
d1532 18
a1549 18
        {
          int unused_right;
          accum = (accum << HOST_CHAR_BIT) + (unsigned char) *source;
          accum_bits += HOST_CHAR_BIT;
          source += 1;
          chunk_size = HOST_CHAR_BIT - targ_offset;
          if (chunk_size > n)
            chunk_size = n;
          unused_right = HOST_CHAR_BIT - (chunk_size + targ_offset);
          mask = ((1 << chunk_size) - 1) << unused_right;
          *target =
            (*target & ~mask)
            | ((accum >> (accum_bits - chunk_size - unused_right)) & mask);
          n -= chunk_size;
          accum_bits -= chunk_size;
          target += 1;
          targ_offset = 0;
        }
d1558 15
a1572 15
        {
          accum = accum + ((unsigned char) *source << accum_bits);
          accum_bits += HOST_CHAR_BIT;
          source += 1;
          chunk_size = HOST_CHAR_BIT - targ_offset;
          if (chunk_size > n)
            chunk_size = n;
          mask = ((1 << chunk_size) - 1) << targ_offset;
          *target = (*target & ~mask) | ((accum << targ_offset) & mask);
          n -= chunk_size;
          accum_bits -= chunk_size;
          accum >>= chunk_size;
          target += 1;
          targ_offset = 0;
        }
d1580 1
a1580 1
   floating-point or non-scalar types.  */
d1596 1
a1596 1
          || TYPE_CODE (type) == TYPE_CODE_STRUCT))
d1599 1
a1599 1
        (VALUE_BITPOS (toval) + bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;
d1604 1
a1604 1
        fromval = value_cast (type, fromval);
d1608 4
a1611 4
        move_bits (buffer, VALUE_BITPOS (toval),
                   VALUE_CONTENTS (fromval),
                   TYPE_LENGTH (VALUE_TYPE (fromval)) * TARGET_CHAR_BIT -
                   bits, bits);
d1613 2
a1614 2
        move_bits (buffer, VALUE_BITPOS (toval), VALUE_CONTENTS (fromval),
                   0, bits);
d1616 1
a1616 1
                    len);
d1620 1
a1620 1
              TYPE_LENGTH (type));
d1630 2
a1631 2
/* The value of the element of array ARR at the ARITY indices given in IND.
   ARR may be either a simple array, GNAT array descriptor, or pointer
d1651 1
a1651 1
        error ("too many subscripts (%d expected)", k);
d1659 1
a1659 1
   IND.  Does not read the entire array into memory.  */
d1663 1
a1663 1
                         struct value **ind)
d1673 1
a1673 1
        error ("too many subscripts (%d expected)", k);
d1675 1
a1675 1
                        value_copy (arr));
d1677 4
a1680 3
      idx = value_pos_atr (ind[k]);
      if (lwb != 0)
        idx = value_sub (idx, value_from_longest (builtin_type_int, lwb));
a1687 31
/* Given that ARRAY_PTR is a pointer or reference to an array of type TYPE (the
   actual type of ARRAY_PTR is ignored), returns a reference to
   the Ada slice of HIGH-LOW+1 elements starting at index LOW.  The lower
   bound of this array is LOW, as per Ada rules. */
static struct value *
ada_value_slice_ptr (struct value *array_ptr, struct type *type, 
                     int low, int high)
{
  CORE_ADDR base = value_as_address (array_ptr) 
    + ((low - TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type)))
       * TYPE_LENGTH (TYPE_TARGET_TYPE (type)));
  struct type *index_type = 
    create_range_type (NULL, TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (type)), 
                       low, high);
  struct type *slice_type = 
    create_array_type (NULL, TYPE_TARGET_TYPE (type), index_type);
  return value_from_pointer (lookup_reference_type (slice_type), base);
}


static struct value *
ada_value_slice (struct value *array, int low, int high)
{
  struct type *type = VALUE_TYPE (array);
  struct type *index_type = 
    create_range_type (NULL, TYPE_INDEX_TYPE (type), low, high);
  struct type *slice_type = 
    create_array_type (NULL, TYPE_TARGET_TYPE (type), index_type);
  return value_cast (slice_type, value_slice (array, low, high-low+1));
}

d1691 1
a1691 1
   type designation.  Otherwise, returns 0.  */
d1709 2
a1710 2
        arity += 1;
        type = check_typedef (TYPE_TARGET_TYPE (type));
d1719 1
a1719 1
   NINDICES is -1.  Otherwise, returns NULL.  */
d1735 1
a1735 1
        return NULL;
d1737 1
a1737 1
      /* Initially p_array_type = elt_type(*)[]...(k times)...[].  */
d1739 1
a1739 1
        k = nindices;
d1742 4
a1745 4
        {
          p_array_type = check_typedef (TYPE_TARGET_TYPE (p_array_type));
          k -= 1;
        }
d1751 4
a1754 4
        {
          type = TYPE_TARGET_TYPE (type);
          nindices -= 1;
        }
d1761 2
a1762 2
/* The type of nth index in arrays of given type (n numbering from 1).
   Does not examine memory.  */
a1766 2
  struct type *result_type;

d1772 1
a1772 1
  if (ada_is_simple_array_type (type))
d1777 1
a1777 7
        type = TYPE_TARGET_TYPE (type);
      result_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 0));
      /* FIXME: The stabs type r(0,0);bound;bound in an array type
         has a target type of TYPE_CODE_UNDEF.  We compensate here, but
         perhaps stabsread.c would make more sense.  */
      if (result_type == NULL || TYPE_CODE (result_type) == TYPE_CODE_UNDEF)
        result_type = builtin_type_int;
d1779 1
a1779 1
      return result_type;
d1787 4
a1790 4
   WHICH is 1.  This returns bounds 0 .. -1 if ARR_TYPE is an
   array-descriptor type.  If TYPEP is non-null, *TYPEP is set to the
   bounds type.  It works for other arrays with bounds supplied by
   run-time quantities other than discriminants.  */
d1794 1
a1794 1
                           struct type ** typep)
d1802 1
a1802 1
  if (arr_type == NULL || !ada_is_simple_array_type (arr_type))
d1805 1
a1805 1
        *typep = builtin_type_int;
d1821 4
a1824 4
        {
          type = TYPE_TARGET_TYPE (type);
          n -= 1;
        }
d1829 1
a1829 1
        index_type = builtin_type_long;
d1831 1
a1831 1
        *typep = index_type;
d1833 3
a1835 3
        (LONGEST) (which == 0
                   ? TYPE_LOW_BOUND (range_type)
                   : TYPE_HIGH_BOUND (range_type));
d1840 2
a1841 2
        to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, n - 1),
                             NULL, TYPE_OBJFILE (arr_type));
d1843 1
a1843 1
        *typep = TYPE_TARGET_TYPE (index_type);
d1845 3
a1847 3
        (LONGEST) (which == 0
                   ? TYPE_LOW_BOUND (index_type)
                   : TYPE_HIGH_BOUND (index_type));
d1853 2
a1854 2
   which is 1.  This routine will also work for arrays with bounds
   supplied by run-time quantities other than discriminants.  */
d1863 1
a1863 1
  else if (ada_is_simple_array_type (arr_type))
d1875 3
a1877 3
   supplied by run-time quantities other than discriminants.
   Does not work for arrays indexed by enumeration types with representation
   clauses at the moment.  */
d1883 1
d1888 1
a1888 1
  if (ada_is_simple_array_type (arr_type))
d1892 2
a1893 2
        ada_array_bound_from_type (arr_type, n, 1, &type) -
        ada_array_bound_from_type (arr_type, n, 0, NULL) + 1;
d1899 4
a1902 17
                          value_as_long (desc_one_bound (desc_bounds (arr),
                                                         n, 1))
                          - value_as_long (desc_one_bound (desc_bounds (arr),
                                                           n, 0)) + 1);
}

/* An empty array whose type is that of ARR_TYPE (an array type),
   with bounds LOW to LOW-1.  */

static struct value *
empty_array (struct type *arr_type, int low)
{
  struct type *index_type = 
    create_range_type (NULL, TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (arr_type)),
                       low, low - 1);
  struct type *elt_type = ada_array_element_type (arr_type, 1);
  return allocate_value (create_array_type (NULL, elt_type, index_type));
d1906 1
a1906 1
                                /* Name resolution */
d1908 2
a1909 2
/* The "decoded" name for the user-definable Ada operator corresponding
   to OP.  */
d1912 1
a1912 1
ada_decoded_op_name (enum exp_opcode op)
d1916 1
a1916 1
  for (i = 0; ada_opname_table[i].encoded != NULL; i += 1)
d1919 1
a1919 1
        return ada_opname_table[i].decoded;
d1925 3
a1927 4
/* Same as evaluate_type (*EXP), but resolves ambiguous symbol
   references (marked by OP_VAR_VALUE nodes in which the symbol has an
   undefined namespace) and converts operators that are
   user-defined into appropriate function calls.  If CONTEXT_TYPE is
d1931 3
a1933 1
   return type is preferred.  May change (expand) *EXP.  */
d1935 2
a1936 2
static void
resolve (struct expression **expp, int void_context_p)
d1940 1
a1940 1
  resolve_subexp (expp, &pc, 1, void_context_p ? builtin_type_void : NULL);
d1943 7
a1949 8
/* Resolve the operator of the subexpression beginning at
   position *POS of *EXPP.  "Resolving" consists of replacing
   the symbols that have undefined namespaces in OP_VAR_VALUE nodes
   with their resolutions, replacing built-in operators with
   function calls to user-defined operators, where appropriate, and,
   when DEPROCEDURE_P is non-zero, converting function-valued variables
   into parameterless calls.  May expand *EXPP.  The CONTEXT_TYPE functions
   are as in ada_resolve, above.  */
d1952 2
a1953 2
resolve_subexp (struct expression **expp, int *pos, int deprocedure_p,
                struct type *context_type)
d1957 1
a1957 1
  struct expression *exp;       /* Convenience: == *expp.  */
d1959 2
a1960 2
  struct value **argvec;        /* Vector of operand types (alloca'ed).  */
  int nargs;                    /* Number of operands.  */
d1966 1
a1966 1
  /* Pass one: resolve operands, saving their types and updating *pos.  */
d1969 4
a1972 15
    case OP_FUNCALL:
      if (exp->elts[pc + 3].opcode == OP_VAR_VALUE
          && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)
        *pos += 7;
      else
        {
          *pos += 3;
          resolve_subexp (expp, pos, 0, NULL);
        }
      nargs = longest_to_int (exp->elts[pc + 1].longconst);
      break;

    case UNOP_QUAL:
      *pos += 3;
      resolve_subexp (expp, pos, 1, exp->elts[pc + 1].type);
d1975 40
a2015 11
      *pos += 1;
      resolve_subexp (expp, pos, 0, NULL);
      break;

    case OP_ATR_MODULUS:
      *pos += 4;
      break;

    case OP_ATR_SIZE:
    case OP_ATR_TAG:
      *pos += 1;
a2016 13
      break;

    case OP_ATR_FIRST:
    case OP_ATR_LAST:
    case OP_ATR_LENGTH:
    case OP_ATR_POS:
    case OP_ATR_VAL:
      *pos += 1;
      nargs = 2;
      break;

    case OP_ATR_MIN:
    case OP_ATR_MAX:
d2018 2
a2019 1
      nargs = 3;
d2024 9
a2032 9
        struct value *arg1;

        *pos += 1;
        arg1 = resolve_subexp (expp, pos, 0, NULL);
        if (arg1 == NULL)
          resolve_subexp (expp, pos, 1, NULL);
        else
          resolve_subexp (expp, pos, 1, VALUE_TYPE (arg1));
        break;
d2035 95
a2129 5
    case UNOP_CAST:
    case UNOP_IN_RANGE:
      *pos += 3;
      nargs = 1;
      break;
d2131 6
a2136 54
    case BINOP_ADD:
    case BINOP_SUB:
    case BINOP_MUL:
    case BINOP_DIV:
    case BINOP_REM:
    case BINOP_MOD:
    case BINOP_EXP:
    case BINOP_CONCAT:
    case BINOP_LOGICAL_AND:
    case BINOP_LOGICAL_OR:
    case BINOP_BITWISE_AND:
    case BINOP_BITWISE_IOR:
    case BINOP_BITWISE_XOR:

    case BINOP_EQUAL:
    case BINOP_NOTEQUAL:
    case BINOP_LESS:
    case BINOP_GTR:
    case BINOP_LEQ:
    case BINOP_GEQ:

    case BINOP_REPEAT:
    case BINOP_SUBSCRIPT:
    case BINOP_COMMA:
      *pos += 1;
      nargs = 2;
      break;

    case UNOP_NEG:
    case UNOP_PLUS:
    case UNOP_LOGICAL_NOT:
    case UNOP_ABS:
    case UNOP_IND:
      *pos += 1;
      nargs = 1;
      break;

    case OP_LONG:
    case OP_DOUBLE:
    case OP_VAR_VALUE:
      *pos += 4;
      break;

    case OP_TYPE:
    case OP_BOOL:
    case OP_LAST:
    case OP_REGISTER:
    case OP_INTERNALVAR:
      *pos += 3;
      break;

    case UNOP_MEMVAL:
      *pos += 3;
      nargs = 1;
a2137 25

    case STRUCTOP_STRUCT:
      *pos += 4 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);
      nargs = 1;
      break;

    case OP_STRING:
      (*pos) += 3 
        + BYTES_TO_EXP_ELEM (longest_to_int (exp->elts[pc + 1].longconst) 
                             + 1);
      break;

    case TERNOP_SLICE:
    case TERNOP_IN_RANGE:
      *pos += 1;
      nargs = 3;
      break;

    case BINOP_IN_BOUNDS:
      *pos += 3;
      nargs = 2;
      break;

    default:
      error ("Unexpected operator during name resolution");
d2140 1
a2140 7
  argvec = (struct value * *) alloca (sizeof (struct value *) * (nargs + 1));
  for (i = 0; i < nargs; i += 1)
    argvec[i] = resolve_subexp (expp, pos, 1, NULL);
  argvec[i] = NULL;
  exp = *expp;

  /* Pass two: perform any resolution on principal operator.  */
d2146 88
d2235 9
a2243 92
      if (SYMBOL_DOMAIN (exp->elts[pc + 2].symbol) == UNDEF_DOMAIN)
        {
          struct ada_symbol_info *candidates;
          int n_candidates;

          n_candidates =
            ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME
                                    (exp->elts[pc + 2].symbol),
                                    exp->elts[pc + 1].block, VAR_DOMAIN,
                                    &candidates);

          if (n_candidates > 1)
            {
              /* Types tend to get re-introduced locally, so if there
                 are any local symbols that are not types, first filter
                 out all types.  */
              int j;
              for (j = 0; j < n_candidates; j += 1)
                switch (SYMBOL_CLASS (candidates[j].sym))
                  {
                  case LOC_REGISTER:
                  case LOC_ARG:
                  case LOC_REF_ARG:
                  case LOC_REGPARM:
                  case LOC_REGPARM_ADDR:
                  case LOC_LOCAL:
                  case LOC_LOCAL_ARG:
                  case LOC_BASEREG:
                  case LOC_BASEREG_ARG:
                  case LOC_COMPUTED:
                  case LOC_COMPUTED_ARG:
                    goto FoundNonType;
                  default:
                    break;
                  }
            FoundNonType:
              if (j < n_candidates)
                {
                  j = 0;
                  while (j < n_candidates)
                    {
                      if (SYMBOL_CLASS (candidates[j].sym) == LOC_TYPEDEF)
                        {
                          candidates[j] = candidates[n_candidates - 1];
                          n_candidates -= 1;
                        }
                      else
                        j += 1;
                    }
                }
            }

          if (n_candidates == 0)
            error ("No definition found for %s",
                   SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
          else if (n_candidates == 1)
            i = 0;
          else if (deprocedure_p
                   && !is_nonfunction (candidates, n_candidates))
            {
              i = ada_resolve_function
                (candidates, n_candidates, NULL, 0,
                 SYMBOL_LINKAGE_NAME (exp->elts[pc + 2].symbol),
                 context_type);
              if (i < 0)
                error ("Could not find a match for %s",
                       SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
            }
          else
            {
              printf_filtered ("Multiple matches for %s\n",
                               SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
              user_select_syms (candidates, n_candidates, 1);
              i = 0;
            }

          exp->elts[pc + 1].block = candidates[i].block;
          exp->elts[pc + 2].symbol = candidates[i].sym;
          if (innermost_block == NULL
              || contained_in (candidates[i].block, innermost_block))
            innermost_block = candidates[i].block;
        }

      if (deprocedure_p
          && (TYPE_CODE (SYMBOL_TYPE (exp->elts[pc + 2].symbol))
              == TYPE_CODE_FUNC))
        {
          replace_operator_with_call (expp, pc, 0, 0,
                                      exp->elts[pc + 2].symbol,
                                      exp->elts[pc + 1].block);
          exp = *expp;
        }
d2248 32
a2279 31
        if (exp->elts[pc + 3].opcode == OP_VAR_VALUE
            && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)
          {
            struct ada_symbol_info *candidates;
            int n_candidates;

            n_candidates =
              ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME
                                      (exp->elts[pc + 5].symbol),
                                      exp->elts[pc + 4].block, VAR_DOMAIN,
                                      &candidates);
            if (n_candidates == 1)
              i = 0;
            else
              {
                i = ada_resolve_function
                  (candidates, n_candidates,
                   argvec, nargs,
                   SYMBOL_LINKAGE_NAME (exp->elts[pc + 5].symbol),
                   context_type);
                if (i < 0)
                  error ("Could not find a match for %s",
                         SYMBOL_PRINT_NAME (exp->elts[pc + 5].symbol));
              }

            exp->elts[pc + 4].block = candidates[i].block;
            exp->elts[pc + 5].symbol = candidates[i].sym;
            if (innermost_block == NULL
                || contained_in (candidates[i].block, innermost_block))
              innermost_block = candidates[i].block;
          }
d2304 20
a2323 17
        {
          struct ada_symbol_info *candidates;
          int n_candidates;

          n_candidates =
            ada_lookup_symbol_list (ada_encode (ada_decoded_op_name (op)),
                                    (struct block *) NULL, VAR_DOMAIN,
                                    &candidates);
          i = ada_resolve_function (candidates, n_candidates, argvec, nargs,
                                    ada_decoded_op_name (op), NULL);
          if (i < 0)
            break;

          replace_operator_with_call (expp, pc, nargs, 1,
                                      candidates[i].sym, candidates[i].block);
          exp = *expp;
        }
a2324 3

    case OP_TYPE:
      return NULL;
d2332 2
a2333 3
   MAY_DEREF is non-zero, the formal may be a pointer and the actual
   a non-pointer.   A type of 'void' (which is never a valid expression type)
   by convention matches anything. */
d2335 1
a2335 1
   liberal.  FIXME: TOO liberal, in fact.  */
d2358 2
a2359 2
        return ada_type_match (TYPE_TARGET_TYPE (ftype),
                               TYPE_TARGET_TYPE (atype), 0);
d2361 2
a2362 2
        return (may_deref
                && ada_type_match (TYPE_TARGET_TYPE (ftype), atype, 0));
d2367 8
a2374 8
        {
        case TYPE_CODE_INT:
        case TYPE_CODE_ENUM:
        case TYPE_CODE_RANGE:
          return 1;
        default:
          return 0;
        }
d2378 1
a2378 1
              || ada_is_array_descriptor_type (atype));
d2381 3
a2383 3
      if (ada_is_array_descriptor_type (ftype))
        return (TYPE_CODE (atype) == TYPE_CODE_ARRAY
                || ada_is_array_descriptor_type (atype));
d2385 2
a2386 2
        return (TYPE_CODE (atype) == TYPE_CODE_STRUCT
                && !ada_is_array_descriptor_type (atype));
d2397 1
a2397 1
   argument function.  */
d2405 2
a2406 2
  if (SYMBOL_CLASS (func) == LOC_CONST
      && TYPE_CODE (func_type) == TYPE_CODE_ENUM)
d2416 6
a2421 10
      if (actuals[i] == NULL)
        return 0;
      else
        {
          struct type *ftype = check_typedef (TYPE_FIELD_TYPE (func_type, i));
          struct type *atype = check_typedef (VALUE_TYPE (actuals[i]));

          if (!ada_type_match (ftype, atype, 1))
            return 0;
        }
d2439 5
a2443 4
  if (TYPE_CODE (func_type) == TYPE_CODE_FUNC)
    return_type = base_type (TYPE_TARGET_TYPE (func_type));
  else
    return_type = base_type (func_type);
d2447 2
a2448 1
  context_type = base_type (context_type);
d2459 1
a2459 1
/* Returns the index in SYMS[0..NSYMS-1] that contains  the symbol for the
d2461 3
a2463 5
   ARGS.  If CONTEXT_TYPE is non-null and there is at least one match
   that returns that type, then eliminate matches that don't.  If
   CONTEXT_TYPE is void and there is at least one match that does not
   return void, eliminate all matches that do.

d2466 3
a2468 2
   solely for messages.  May re-arrange and modify SYMS in
   the process; the index returned is for the modified vector.  */
d2470 4
a2473 4
static int
ada_resolve_function (struct ada_symbol_info syms[],
                      int nsyms, struct value **args, int nargs,
                      const char *name, struct type *context_type)
d2476 1
a2476 1
  int m;                        /* Number of hits */
d2490 2
a2491 2
        {
          struct type *type = check_typedef (SYMBOL_TYPE (syms[k].sym));
d2493 9
a2501 7
          if (ada_args_match (syms[k].sym, args, nargs)
              && return_match (type, return_type))
            {
              syms[m] = syms[k];
              m += 1;
            }
        }
d2503 1
a2503 1
        break;
d2505 1
a2505 1
        return_type = fallback;
d2513 1
a2513 1
      user_select_syms (syms, m, 1);
d2519 5
a2523 6
/* Returns true (non-zero) iff decoded name N0 should appear before N1
   in a listing of choices during disambiguation (see sort_choices, below).
   The idea is that overloadings of a subprogram name from the
   same package should sort in their source order.  We settle for ordering
   such symbols by their trailing number (__N  or $N).  */

d2525 1
a2525 1
encoded_ordered_before (char *N0, char *N1)
d2535 1
a2535 1
        ;
d2537 1
a2537 1
        ;
d2539 12
a2550 12
          && (N1[k1] == '_' || N1[k1] == '$') && N1[k1 + 1] != '\000')
        {
          int n0, n1;
          n0 = k0;
          while (N0[n0] == '_' && n0 > 0 && N0[n0 - 1] == '_')
            n0 -= 1;
          n1 = k1;
          while (N1[n1] == '_' && n1 > 0 && N1[n1 - 1] == '_')
            n1 -= 1;
          if (n0 == n1 && strncmp (N0, N1, n0) == 0)
            return (atoi (N0 + k0 + 1) < atoi (N1 + k1 + 1));
        }
d2555 3
a2557 3
/* Sort SYMS[0..NSYMS-1] to put the choices in a canonical order by the
   encoded names.  */

d2559 1
a2559 1
sort_choices (struct ada_symbol_info syms[], int nsyms)
d2561 1
a2561 1
  int i;
d2564 2
a2565 1
      struct ada_symbol_info sym = syms[i];
d2569 7
a2575 6
        {
          if (encoded_ordered_before (SYMBOL_LINKAGE_NAME (syms[j].sym),
                                      SYMBOL_LINKAGE_NAME (sym.sym)))
            break;
          syms[j + 1] = syms[j];
        }
d2577 1
d2581 6
a2586 4
/* Given a list of NSYMS symbols in SYMS, select up to MAX_RESULTS>0 
   by asking the user (if necessary), returning the number selected, 
   and setting the first elements of SYMS items.  Error if no symbols
   selected.  */
d2589 1
a2589 1
   to be re-integrated one of these days.  */
d2592 2
a2593 1
user_select_syms (struct ada_symbol_info *syms, int nsyms, int max_results)
d2609 1
a2609 1
  sort_choices (syms, nsyms);
d2613 2
a2614 2
      if (syms[i].sym == NULL)
        continue;
d2616 45
a2660 47
      if (SYMBOL_CLASS (syms[i].sym) == LOC_BLOCK)
        {
          struct symtab_and_line sal =
            find_function_start_sal (syms[i].sym, 1);
          printf_unfiltered ("[%d] %s at %s:%d\n", i + first_choice,
                             SYMBOL_PRINT_NAME (syms[i].sym),
                             (sal.symtab == NULL
                              ? "<no source file available>"
                              : sal.symtab->filename), sal.line);
          continue;
        }
      else
        {
          int is_enumeral =
            (SYMBOL_CLASS (syms[i].sym) == LOC_CONST
             && SYMBOL_TYPE (syms[i].sym) != NULL
             && TYPE_CODE (SYMBOL_TYPE (syms[i].sym)) == TYPE_CODE_ENUM);
          struct symtab *symtab = symtab_for_sym (syms[i].sym);

          if (SYMBOL_LINE (syms[i].sym) != 0 && symtab != NULL)
            printf_unfiltered ("[%d] %s at %s:%d\n",
                               i + first_choice,
                               SYMBOL_PRINT_NAME (syms[i].sym),
                               symtab->filename, SYMBOL_LINE (syms[i].sym));
          else if (is_enumeral
                   && TYPE_NAME (SYMBOL_TYPE (syms[i].sym)) != NULL)
            {
              printf_unfiltered ("[%d] ", i + first_choice);
              ada_print_type (SYMBOL_TYPE (syms[i].sym), NULL,
                              gdb_stdout, -1, 0);
              printf_unfiltered ("'(%s) (enumeral)\n",
                                 SYMBOL_PRINT_NAME (syms[i].sym));
            }
          else if (symtab != NULL)
            printf_unfiltered (is_enumeral
                               ? "[%d] %s in %s (enumeral)\n"
                               : "[%d] %s at %s:?\n",
                               i + first_choice,
                               SYMBOL_PRINT_NAME (syms[i].sym),
                               symtab->filename);
          else
            printf_unfiltered (is_enumeral
                               ? "[%d] %s (enumeral)\n"
                               : "[%d] %s at ?\n",
                               i + first_choice,
                               SYMBOL_PRINT_NAME (syms[i].sym));
        }
d2664 1
a2664 1
                             "overload-choice");
d2667 5
a2671 1
    syms[i] = syms[chosen[i]];
d2677 1
a2677 1
   range 0 .. N_CHOICES-1.  Place the results in increasing
d2683 1
a2683 1
     + A choice of 0 means to cancel the selection, throwing an error.
d2687 1
a2687 1
   The user is not allowed to choose more than MAX_RESULTS values.
d2690 1
a2690 1
   prompts (for use with the -f switch).  */
d2694 1
a2694 1
                int is_all_choice, char *annotation_suffix)
d2696 1
d2716 2
a2717 2
  /* Set choices[0 .. n_chosen-1] to the users' choices in ascending
     order, as given in args.  Choices are validated.  */
d2724 1
a2724 1
        args += 1;
d2726 1
a2726 1
        error_no_arg ("one or more choice numbers");
d2728 1
a2728 1
        break;
d2732 2
a2733 2
          || choice > n_choices + first_choice - 1)
        error ("Argument must be choice number");
d2737 1
a2737 1
        error ("cancelled");
d2740 6
a2745 6
        {
          n_chosen = n_choices;
          for (j = 0; j < n_choices; j += 1)
            choices[j] = j;
          break;
        }
d2749 2
a2750 2
        {
        }
d2753 7
a2759 7
        {
          int k;
          for (k = n_chosen - 1; k > j; k -= 1)
            choices[k + 1] = choices[k];
          choices[j + 1] = choice;
          n_chosen += 1;
        }
d2768 3
a2770 3
/* Replace the operator of length OPLEN at position PC in *EXPP with a call
   on the function identified by SYM and BLOCK, and taking NARGS
   arguments.  Update *EXPP as needed to hold more space.  */
d2774 2
a2775 2
                            int oplen, struct symbol *sym,
                            struct block *block)
d2778 1
a2778 1
     symbol, -oplen for operator being replaced).  */
d2781 1
a2781 1
             + EXP_ELEM_TO_BYTES ((*expp)->nelts + 7 - oplen));
d2788 1
a2788 1
          EXP_ELEM_TO_BYTES (exp->nelts - pc - oplen));
d2803 2
a2804 2
/* True iff TYPE is numeric (i.e., an INT, RANGE (of numeric type),
   or FLOAT).  */
d2814 10
a2823 10
        {
        case TYPE_CODE_INT:
        case TYPE_CODE_FLT:
          return 1;
        case TYPE_CODE_RANGE:
          return (type == TYPE_TARGET_TYPE (type)
                  || numeric_type_p (TYPE_TARGET_TYPE (type)));
        default:
          return 0;
        }
d2827 1
a2827 1
/* True iff TYPE is integral (an INT or RANGE of INTs).  */
d2837 9
a2845 9
        {
        case TYPE_CODE_INT:
          return 1;
        case TYPE_CODE_RANGE:
          return (type == TYPE_TARGET_TYPE (type)
                  || integer_type_p (TYPE_TARGET_TYPE (type)));
        default:
          return 0;
        }
d2849 1
a2849 1
/* True iff TYPE is scalar (INT, RANGE, FLOAT, ENUM).  */
d2859 9
a2867 9
        {
        case TYPE_CODE_INT:
        case TYPE_CODE_RANGE:
        case TYPE_CODE_ENUM:
        case TYPE_CODE_FLT:
          return 1;
        default:
          return 0;
        }
d2871 1
a2871 1
/* True iff TYPE is discrete (INT, RANGE, ENUM).  */
d2881 8
a2888 8
        {
        case TYPE_CODE_INT:
        case TYPE_CODE_RANGE:
        case TYPE_CODE_ENUM:
          return 1;
        default:
          return 0;
        }
d2892 3
a2894 3
/* Returns non-zero if OP with operands in the vector ARGS could be
   a user-defined function.  Errs on the side of pre-defined operators
   (i.e., result 0).  */
d2899 1
a2899 2
  struct type *type0 =
    (args[0] == NULL) ? NULL : check_typedef (VALUE_TYPE (args[0]));
a2902 3
  if (type0 == NULL)
    return 0;

d2930 7
a2936 8
      return
        ((TYPE_CODE (type0) != TYPE_CODE_ARRAY
          && (TYPE_CODE (type0) != TYPE_CODE_PTR
              || TYPE_CODE (TYPE_TARGET_TYPE (type0)) != TYPE_CODE_ARRAY))
         || (TYPE_CODE (type1) != TYPE_CODE_ARRAY
             && (TYPE_CODE (type1) != TYPE_CODE_PTR
                 || (TYPE_CODE (TYPE_TARGET_TYPE (type1)) 
		     != TYPE_CODE_ARRAY))));
d2950 1
a2950 1
                                /* Renaming */
d2952 3
a2954 3
/* NOTE: In the following, we assume that a renaming type's name may
   have an ___XD suffix.  It would be nice if this went away at some
   point.  */
d2957 3
a2959 4
   is XR for an object renaming, XRP for a procedure renaming, XRE for
   an exception renaming, and XRS for a subprogram renaming.  Returns
   NULL if NAME encodes none of these.  */

d2968 2
a2969 2
          || (suffix[5] != '\000' && strchr ("PES_", suffix[5]) == NULL))
        return NULL;
d2971 1
a2971 1
        return suffix + 3;
d2977 1
a2977 2
/* Return non-zero iff SYM encodes an object renaming.  */

d2987 3
a2989 4
   name of the renamed entity.  The name is good until the end of
   parsing.  */

char *
d3007 2
d3015 1
a3015 1
                                /* Evaluation: Function Calls */
d3017 2
a3018 4
/* Return an lvalue containing the value VAL.  This is the identity on
   lvalues, and otherwise has the side-effect of pushing a copy of VAL 
   on the stack, using and updating *SP as the stack pointer, and 
   returning an lvalue whose VALUE_ADDRESS points to the copy.  */
d3021 1
a3021 1
ensure_lval (struct value *val, CORE_ADDR *sp)
d3023 1
a3023 3
  if (! VALUE_LVAL (val))
    {
      int len = TYPE_LENGTH (check_typedef (VALUE_TYPE (val)));
d3025 8
a3032 23
      /* The following is taken from the structure-return code in
	 call_function_by_hand. FIXME: Therefore, some refactoring seems 
	 indicated. */
      if (INNER_THAN (1, 2))
	{
	  /* Stack grows downward.  Align SP and VALUE_ADDRESS (val) after
	     reserving sufficient space. */
	  *sp -= len;
	  if (gdbarch_frame_align_p (current_gdbarch))
	    *sp = gdbarch_frame_align (current_gdbarch, *sp);
	  VALUE_ADDRESS (val) = *sp;
	}
      else
	{
	  /* Stack grows upward.  Align the frame, allocate space, and
	     then again, re-align the frame. */
	  if (gdbarch_frame_align_p (current_gdbarch))
	    *sp = gdbarch_frame_align (current_gdbarch, *sp);
	  VALUE_ADDRESS (val) = *sp;
	  *sp += len;
	  if (gdbarch_frame_align_p (current_gdbarch))
	    *sp = gdbarch_frame_align (current_gdbarch, *sp);
	}
d3034 5
a3038 2
      write_memory (VALUE_ADDRESS (val), VALUE_CONTENTS_RAW (val), len);
    }
d3046 1
a3046 1
   values not residing in memory, updating it as needed.  */
d3050 1
a3050 1
                CORE_ADDR *sp)
d3061 1
a3061 1
  if (ada_is_array_descriptor_type (formal_target)
d3067 2
a3068 2
          && ada_is_array_descriptor_type (actual_target))
        return desc_data (actual);
d3070 13
a3082 13
        {
          if (VALUE_LVAL (actual) != lval_memory)
            {
              struct value *val;
              actual_type = check_typedef (VALUE_TYPE (actual));
              val = allocate_value (actual_type);
              memcpy ((char *) VALUE_CONTENTS_RAW (val),
                      (char *) VALUE_CONTENTS (actual),
                      TYPE_LENGTH (actual_type));
              actual = ensure_lval (val, sp);
            }
          return value_addr (actual);
        }
d3091 2
a3092 2
/* Push a descriptor of type TYPE for array value ARR on the stack at
   *SP, updating *SP to reflect the new descriptor.  Return either
d3094 2
a3095 2
   to-descriptor type rather than a descriptor type), a struct value *
   representing a pointer to this descriptor.  */
d3104 1
d3110 3
a3112 3
                            value_as_long (ada_array_bound (arr, i, 0)),
                            desc_bound_bitpos (bounds_type, i, 0),
                            desc_bound_bitsize (bounds_type, i, 0));
d3114 3
a3116 3
                            value_as_long (ada_array_bound (arr, i, 1)),
                            desc_bound_bitpos (bounds_type, i, 1),
                            desc_bound_bitsize (bounds_type, i, 1));
d3119 1
a3119 1
  bounds = ensure_lval (bounds, sp);
d3122 3
a3124 4
                        VALUE_ADDRESS (ensure_lval (arr, sp)),
                        fat_pntr_data_bitpos (desc_type),
                        fat_pntr_data_bitsize (desc_type));

d3126 3
a3128 3
                        VALUE_ADDRESS (bounds),
                        fat_pntr_bounds_bitpos (desc_type),
                        fat_pntr_bounds_bitsize (desc_type));
d3130 1
a3130 1
  descriptor = ensure_lval (descriptor, sp);
d3139 1
a3139 1
/* Assuming a dummy frame has been established on the target, perform any
d3141 1
a3141 1
   parameters in ARGS, other than standard C conversions.  Does
d3143 1
a3143 1
   does not match the number of arguments expected.  Use *SP as a
d3145 1
a3145 1
   value as needed.  */
d3149 1
a3149 1
                     CORE_ADDR *sp)
a3161 28
                                /* Experimental Symbol Cache Module */

/* This module may well have been OBE, due to improvements in the 
   symbol-table module.  So until proven otherwise, it is disabled in
   the submitted public code, and may be removed from all sources
   in the future. */

#ifdef GNAT_GDB

/* This section implements a simple, fixed-sized hash table for those
   Ada-mode symbols that get looked up in the course of executing the user's
   commands.  The size is fixed on the grounds that there are not
   likely to be all that many symbols looked up during any given
   session, regardless of the size of the symbol table.  If we decide
   to go to a resizable table, let's just use the stuff from libiberty
   instead.  */

#define HASH_SIZE 1009

struct cache_entry
{
  const char *name;
  domain_enum namespace;
  struct symbol *sym;
  struct symtab *symtab;
  struct block *block;
  struct cache_entry *next;
};
d3163 1
a3163 1
static struct obstack cache_space;
a3164 47
static struct cache_entry *cache[HASH_SIZE];

/* Clear all entries from the symbol cache.  */

void
clear_ada_sym_cache (void)
{
  obstack_free (&cache_space, NULL);
  obstack_init (&cache_space);
  memset (cache, '\000', sizeof (cache));
}

static struct cache_entry **
find_entry (const char *name, domain_enum namespace)
{
  int h = msymbol_hash (name) % HASH_SIZE;
  struct cache_entry **e;
  for (e = &cache[h]; *e != NULL; e = &(*e)->next)
    {
      if (namespace == (*e)->namespace && strcmp (name, (*e)->name) == 0)
        return e;
    }
  return NULL;
}

/* Return (in SYM) the last cached definition for global or static symbol NAME
   in namespace DOMAIN.  Returns 1 if entry found, 0 otherwise.
   If SYMTAB is non-NULL, store the symbol
   table in which the symbol was found there, or NULL if not found.
   *BLOCK is set to the block in which NAME is found.  */

static int
lookup_cached_symbol (const char *name, domain_enum namespace,
                      struct symbol **sym, struct block **block,
                      struct symtab **symtab)
{
  struct cache_entry **e = find_entry (name, namespace);
  if (e == NULL)
    return 0;
  if (sym != NULL)
    *sym = (*e)->sym;
  if (block != NULL)
    *block = (*e)->block;
  if (symtab != NULL)
    *symtab = (*e)->symtab;
  return 1;
}
d3166 2
a3167 2
/* Set the cached definition of NAME in DOMAIN to SYM in block
   BLOCK and symbol table SYMTAB.  */
d3169 2
a3170 17
static void
cache_symbol (const char *name, domain_enum namespace, struct symbol *sym,
              struct block *block, struct symtab *symtab)
{
  int h = msymbol_hash (name) % HASH_SIZE;
  char *copy;
  struct cache_entry *e =
    (struct cache_entry *) obstack_alloc (&cache_space, sizeof (*e));
  e->next = cache[h];
  cache[h] = e;
  e->name = copy = obstack_alloc (&cache_space, strlen (name) + 1);
  strcpy (copy, name);
  e->sym = sym;
  e->namespace = namespace;
  e->symtab = symtab;
  e->block = block;
}
d3172 2
a3173 8
#else
static int
lookup_cached_symbol (const char *name, domain_enum namespace,
                      struct symbol **sym, struct block **block,
                      struct symtab **symtab)
{
  return 0;
}
d3175 2
a3176 8
static void
cache_symbol (const char *name, domain_enum namespace, struct symbol *sym,
              struct block *block, struct symtab *symtab)
{
}
#endif /* GNAT_GDB */

                                /* Symbol Lookup */
d3178 2
a3179 2
/* Return the result of a standard (literal, C-like) lookup of NAME in
   given DOMAIN, visible from lexical block BLOCK.  */
d3182 1
a3182 2
standard_lookup (const char *name, const struct block *block,
                 domain_enum domain)
d3185 1
a3185 7
  struct symtab *symtab;

  if (lookup_cached_symbol (name, domain, &sym, NULL, NULL))
    return sym;
  sym =
    lookup_symbol_in_language (name, block, domain, language_c, 0, &symtab);
  cache_symbol (name, domain, sym, block_found, symtab);
d3190 3
a3192 3
/* Non-zero iff there is at least one non-function/non-enumeral symbol
   in the symbol fields of SYMS[0..N-1].  We treat enumerals as functions, 
   since they contend in overloading in the same way.  */
d3194 1
a3194 1
is_nonfunction (struct ada_symbol_info syms[], int n)
d3199 2
a3200 3
    if (TYPE_CODE (SYMBOL_TYPE (syms[i].sym)) != TYPE_CODE_FUNC
        && (TYPE_CODE (SYMBOL_TYPE (syms[i].sym)) != TYPE_CODE_ENUM
            || SYMBOL_CLASS (syms[i].sym) != LOC_CONST))
d3207 1
a3207 1
   struct types.  Otherwise, they may not.  */
d3220 1
a3220 1
      && strcmp (ada_type_name (type0), ada_type_name (type1)) == 0)
d3227 1
a3227 1
   no more defined than that of SYM1.  */
d3244 10
a3253 10
        struct type *type0 = SYMBOL_TYPE (sym0);
        struct type *type1 = SYMBOL_TYPE (sym1);
        char *name0 = SYMBOL_LINKAGE_NAME (sym0);
        char *name1 = SYMBOL_LINKAGE_NAME (sym1);
        int len0 = strlen (name0);
        return
          TYPE_CODE (type0) == TYPE_CODE (type1)
          && (equiv_types (type0, type1)
              || (len0 < strlen (name1) && strncmp (name0, name1, len0) == 0
                  && strncmp (name1 + len0, "___XV", 5) == 0));
d3257 1
a3257 1
        && equiv_types (SYMBOL_TYPE (sym0), SYMBOL_TYPE (sym1));
d3263 3
a3265 2
/* Append (SYM,BLOCK,SYMTAB) to the end of the array of struct ada_symbol_info
   records in OBSTACKP.  Do nothing if SYM is a duplicate.  */
d3268 1
a3268 3
add_defn_to_vec (struct obstack *obstackp,
                 struct symbol *sym,
                 struct block *block, struct symtab *symtab)
a3271 1
  struct ada_symbol_info *prevDefns = defns_collected (obstackp, 0);
d3275 1
a3275 1
  for (i = num_defns_collected (obstackp) - 1; i >= 0; i -= 1)
d3277 8
a3284 9
      if (lesseq_defined_than (sym, prevDefns[i].sym))
        return;
      else if (lesseq_defined_than (prevDefns[i].sym, sym))
        {
          prevDefns[i].sym = sym;
          prevDefns[i].block = block;
          prevDefns[i].symtab = symtab;
          return;
        }
d3287 7
a3293 30
  {
    struct ada_symbol_info info;

    info.sym = sym;
    info.block = block;
    info.symtab = symtab;
    obstack_grow (obstackp, &info, sizeof (struct ada_symbol_info));
  }
}

/* Number of ada_symbol_info structures currently collected in 
   current vector in *OBSTACKP.  */

static int
num_defns_collected (struct obstack *obstackp)
{
  return obstack_object_size (obstackp) / sizeof (struct ada_symbol_info);
}

/* Vector of ada_symbol_info structures currently collected in current 
   vector in *OBSTACKP.  If FINISH, close off the vector and return
   its final address.  */

static struct ada_symbol_info *
defns_collected (struct obstack *obstackp, int finish)
{
  if (finish)
    return obstack_finish (obstackp);
  else
    return (struct ada_symbol_info *) obstack_base (obstackp);
d3296 3
a3298 3
/* Look, in partial_symtab PST, for symbol NAME in given namespace.
   Check the global symbols if GLOBAL, the static symbols if not.
   Do wild-card match if WILD.  */
d3302 1
a3302 1
                           int global, domain_enum namespace, int wild)
d3315 2
a3316 2
           pst->objfile->global_psymbols.list + pst->globals_offset :
           pst->objfile->static_psymbols.list + pst->statics_offset);
d3321 2
a3322 2
        {
          struct partial_symbol *psym = start[i];
d3324 4
a3327 4
          if (SYMBOL_DOMAIN (psym) == namespace
              && wild_match (name, name_len, SYMBOL_LINKAGE_NAME (psym)))
            return psym;
        }
d3333 18
a3350 18
        {
          int U;
          i = 0;
          U = length - 1;
          while (U - i > 4)
            {
              int M = (U + i) >> 1;
              struct partial_symbol *psym = start[M];
              if (SYMBOL_LINKAGE_NAME (psym)[0] < name[0])
                i = M + 1;
              else if (SYMBOL_LINKAGE_NAME (psym)[0] > name[0])
                U = M - 1;
              else if (strcmp (SYMBOL_LINKAGE_NAME (psym), name) < 0)
                i = M + 1;
              else
                U = M;
            }
        }
d3352 1
a3352 1
        i = 0;
d3355 2
a3356 2
        {
          struct partial_symbol *psym = start[i];
d3358 15
a3372 16
          if (SYMBOL_DOMAIN (psym) == namespace)
            {
              int cmp = strncmp (name, SYMBOL_LINKAGE_NAME (psym), name_len);

              if (cmp < 0)
                {
                  if (global)
                    break;
                }
              else if (cmp == 0
                       && is_name_suffix (SYMBOL_LINKAGE_NAME (psym)
                                          + name_len))
                return psym;
            }
          i += 1;
        }
d3375 18
a3392 18
        {
          int U;
          i = 0;
          U = length - 1;
          while (U - i > 4)
            {
              int M = (U + i) >> 1;
              struct partial_symbol *psym = start[M];
              if (SYMBOL_LINKAGE_NAME (psym)[0] < '_')
                i = M + 1;
              else if (SYMBOL_LINKAGE_NAME (psym)[0] > '_')
                U = M - 1;
              else if (strcmp (SYMBOL_LINKAGE_NAME (psym), "_ada_") < 0)
                i = M + 1;
              else
                U = M;
            }
        }
d3394 1
a3394 1
        i = 0;
d3397 26
a3422 2
        {
          struct partial_symbol *psym = start[i];
a3423 25
          if (SYMBOL_DOMAIN (psym) == namespace)
            {
              int cmp;

              cmp = (int) '_' - (int) SYMBOL_LINKAGE_NAME (psym)[0];
              if (cmp == 0)
                {
                  cmp = strncmp ("_ada_", SYMBOL_LINKAGE_NAME (psym), 5);
                  if (cmp == 0)
                    cmp = strncmp (name, SYMBOL_LINKAGE_NAME (psym) + 5,
                                   name_len);
                }

              if (cmp < 0)
                {
                  if (global)
                    break;
                }
              else if (cmp == 0
                       && is_name_suffix (SYMBOL_LINKAGE_NAME (psym)
                                          + name_len + 5))
                return psym;
            }
          i += 1;
        }
d3428 1
a3429 1

d3451 7
a3457 7
        b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
        ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
          return s;
        b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
        ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
          return s;
        break;
d3459 1
a3459 1
        break;
d3475 8
a3482 8
        for (j = FIRST_LOCAL_BLOCK;
             j < BLOCKVECTOR_NBLOCKS (BLOCKVECTOR (s)); j += 1)
          {
            b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), j);
            ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
              return s;
          }
        break;
d3484 1
a3484 1
        break;
d3490 2
a3491 4
/* Return a minimal symbol matching NAME according to Ada decoding
   rules.  Returns NULL if there is no such minimal symbol.  Names 
   prefixed with "standard__" are handled specially: "standard__" is 
   first stripped off, and only static and global symbols are searched.  */
d3494 1
a3494 1
ada_lookup_simple_minsym (const char *name)
d3498 1
a3498 9
  int wild_match;

  if (strncmp (name, "standard__", sizeof ("standard__") - 1) == 0)
    {
      name += sizeof ("standard__") - 1;
      wild_match = 0;
    }
  else
    wild_match = (strstr (name, "__") == NULL);
d3502 2
a3503 2
    if (ada_match_name (SYMBOL_LINKAGE_NAME (msymbol), name, wild_match)
        && MSYMBOL_TYPE (msymbol) != mst_solib_trampoline)
a3509 10
/* Return up minimal symbol for NAME, folded and encoded according to 
   Ada conventions, or NULL if none.  The last two arguments are ignored.  */

static struct minimal_symbol *
ada_lookup_minimal_symbol (const char *name, const char *sfile,
                           struct objfile *objf)
{
  return ada_lookup_simple_minsym (ada_encode (name));
}

d3511 8
a3518 5
   selected frame, add symbols matching identifier NAME in DOMAIN
   and their blocks to the list of data in OBSTACKP, as for
   ada_add_block_symbols (q.v.).   If WILD, treat as NAME with a
   wildcard prefix.  */

d3520 4
a3523 9
add_symbols_from_enclosing_procs (struct obstack *obstackp,
                                  const char *name, domain_enum namespace,
                                  int wild_match)
{
#ifdef HAVE_ADD_SYMBOLS_FROM_ENCLOSING_PROCS
  /* Use a heuristic to find the frames of enclosing subprograms: treat the
     pointer-sized value at location 0 from the local-variable base of a
     frame as a static link, and then search up the call stack for a
     frame with that same local-variable base.  */
a3525 1
  struct value *target_link_val;
d3529 1
a3529 3

  if (!target_has_stack)
    return;
d3534 1
a3534 1
         static link (when there is one).  */
d3536 1
a3536 1
      SYMBOL_LINKAGE_NAME (static_link) = "";
d3542 1
a3542 1
        -(long) TYPE_LENGTH (SYMBOL_TYPE (static_link));
d3545 10
a3554 3
  frame = get_selected_frame ();
  if (frame == NULL || inside_main_func (get_frame_address_in_block (frame)))
    return;
d3556 7
a3562 6
  target_link_val = read_var_value (static_link, frame);
  while (target_link_val != NULL
         && num_defns_collected (obstackp) == 0
         && frame_relative_level (frame) <= MAX_ENCLOSING_FRAME_LEVELS)
    {
      CORE_ADDR target_link = value_as_address (target_link_val);
a3563 1
      frame = get_prev_frame (frame);
d3565 1
a3565 1
        break;
d3567 7
a3573 18
      if (get_frame_locals_address (frame) == target_link)
        {
          struct block *block;

          QUIT;

          block = get_frame_block (frame, 0);
          while (block != NULL && block_function (block) != NULL
                 && num_defns_collected (obstackp) == 0)
            {
              QUIT;

              ada_add_block_symbols (obstackp, block, name, namespace,
                                     NULL, NULL, wild_match);

              block = BLOCK_SUPERBLOCK (block);
            }
        }
a3579 25
/* FIXME: The next two routines belong in symtab.c */

static void
restore_language (void *lang)
{
  set_language ((enum language) lang);
}

/* As for lookup_symbol, but performed as if the current language 
   were LANG. */

struct symbol *
lookup_symbol_in_language (const char *name, const struct block *block,
                           domain_enum domain, enum language lang,
                           int *is_a_field_of_this, struct symtab **symtab)
{
  struct cleanup *old_chain
    = make_cleanup (restore_language, (void *) current_language->la_language);
  struct symbol *result;
  set_language (lang);
  result = lookup_symbol (name, block, domain, is_a_field_of_this, symtab);
  do_cleanups (old_chain);
  return result;
}

d3581 1
a3581 2
   for which no debugging information was given in the symbol file.  */

d3586 1
a3586 1
  return (name != NULL && strcmp (name, "<variable, no debug info>") == 0);
d3589 8
a3596 7
/* Remove any non-debugging symbols in SYMS[0 .. NSYMS-1] that definitely
   duplicate other symbols in the list (The only case I know of where
   this happens is when object files containing stabs-in-ecoff are
   linked with files containing ordinary ecoff debugging symbols (or no
   debugging symbols)).  Modifies SYMS to squeeze out deleted entries.
   Returns the number of items in the modified list.  */

d3598 1
a3598 1
remove_extra_symbols (struct ada_symbol_info *syms, int nsyms)
d3605 24
a3628 22
      if (SYMBOL_LINKAGE_NAME (syms[i].sym) != NULL
          && SYMBOL_CLASS (syms[i].sym) == LOC_STATIC
          && is_nondebugging_type (SYMBOL_TYPE (syms[i].sym)))
        {
          for (j = 0; j < nsyms; j += 1)
            {
              if (i != j
                  && SYMBOL_LINKAGE_NAME (syms[j].sym) != NULL
                  && strcmp (SYMBOL_LINKAGE_NAME (syms[i].sym),
                             SYMBOL_LINKAGE_NAME (syms[j].sym)) == 0
                  && SYMBOL_CLASS (syms[i].sym) == SYMBOL_CLASS (syms[j].sym)
                  && SYMBOL_VALUE_ADDRESS (syms[i].sym)
                  == SYMBOL_VALUE_ADDRESS (syms[j].sym))
                {
                  int k;
                  for (k = i + 1; k < nsyms; k += 1)
                    syms[k - 1] = syms[k];
                  nsyms -= 1;
                  goto NextSymbol;
                }
            }
        }
d3636 10
a3645 182
/* Given a type that corresponds to a renaming entity, use the type name
   to extract the scope (package name or function name, fully qualified,
   and following the GNAT encoding convention) where this renaming has been
   defined.  The string returned needs to be deallocated after use.  */

static char *
xget_renaming_scope (struct type *renaming_type)
{
  /* The renaming types adhere to the following convention:
     <scope>__<rename>___<XR extension>. 
     So, to extract the scope, we search for the "___XR" extension,
     and then backtrack until we find the first "__".  */

  const char *name = type_name_no_tag (renaming_type);
  char *suffix = strstr (name, "___XR");
  char *last;
  int scope_len;
  char *scope;

  /* Now, backtrack a bit until we find the first "__".  Start looking
     at suffix - 3, as the <rename> part is at least one character long.  */

  for (last = suffix - 3; last > name; last--)
    if (last[0] == '_' && last[1] == '_')
      break;

  /* Make a copy of scope and return it.  */

  scope_len = last - name;
  scope = (char *) xmalloc ((scope_len + 1) * sizeof (char));

  strncpy (scope, name, scope_len);
  scope[scope_len] = '\0';

  return scope;
}

/* Return nonzero if NAME corresponds to a package name.  */

static int
is_package_name (const char *name)
{
  /* Here, We take advantage of the fact that no symbols are generated
     for packages, while symbols are generated for each function.
     So the condition for NAME represent a package becomes equivalent
     to NAME not existing in our list of symbols.  There is only one
     small complication with library-level functions (see below).  */

  char *fun_name;

  /* If it is a function that has not been defined at library level,
     then we should be able to look it up in the symbols.  */
  if (standard_lookup (name, NULL, VAR_DOMAIN) != NULL)
    return 0;

  /* Library-level function names start with "_ada_".  See if function
     "_ada_" followed by NAME can be found.  */

  /* Do a quick check that NAME does not contain "__", since library-level
     functions names can not contain "__" in them.  */
  if (strstr (name, "__") != NULL)
    return 0;

  fun_name = xstrprintf ("_ada_%s", name);

  return (standard_lookup (fun_name, NULL, VAR_DOMAIN) == NULL);
}

/* Return nonzero if SYM corresponds to a renaming entity that is
   visible from FUNCTION_NAME.  */

static int
renaming_is_visible (const struct symbol *sym, char *function_name)
{
  char *scope = xget_renaming_scope (SYMBOL_TYPE (sym));

  make_cleanup (xfree, scope);

  /* If the rename has been defined in a package, then it is visible.  */
  if (is_package_name (scope))
    return 1;

  /* Check that the rename is in the current function scope by checking
     that its name starts with SCOPE.  */

  /* If the function name starts with "_ada_", it means that it is
     a library-level function.  Strip this prefix before doing the
     comparison, as the encoding for the renaming does not contain
     this prefix.  */
  if (strncmp (function_name, "_ada_", 5) == 0)
    function_name += 5;

  return (strncmp (function_name, scope, strlen (scope)) == 0);
}

/* Iterates over the SYMS list and remove any entry that corresponds to
   a renaming entity that is not visible from the function associated
   with CURRENT_BLOCK. 
   
   Rationale:
   GNAT emits a type following a specified encoding for each renaming
   entity.  Unfortunately, STABS currently does not support the definition
   of types that are local to a given lexical block, so all renamings types
   are emitted at library level.  As a consequence, if an application
   contains two renaming entities using the same name, and a user tries to
   print the value of one of these entities, the result of the ada symbol
   lookup will also contain the wrong renaming type.

   This function partially covers for this limitation by attempting to
   remove from the SYMS list renaming symbols that should be visible
   from CURRENT_BLOCK.  However, there does not seem be a 100% reliable
   method with the current information available.  The implementation
   below has a couple of limitations (FIXME: brobecker-2003-05-12):  
   
      - When the user tries to print a rename in a function while there
        is another rename entity defined in a package:  Normally, the
        rename in the function has precedence over the rename in the
        package, so the latter should be removed from the list.  This is
        currently not the case.
        
      - This function will incorrectly remove valid renames if
        the CURRENT_BLOCK corresponds to a function which symbol name
        has been changed by an "Export" pragma.  As a consequence,
        the user will be unable to print such rename entities.  */

static int
remove_out_of_scope_renamings (struct ada_symbol_info *syms,
                               int nsyms, struct block *current_block)
{
  struct symbol *current_function;
  char *current_function_name;
  int i;

  /* Extract the function name associated to CURRENT_BLOCK.
     Abort if unable to do so.  */

  if (current_block == NULL)
    return nsyms;

  current_function = block_function (current_block);
  if (current_function == NULL)
    return nsyms;

  current_function_name = SYMBOL_LINKAGE_NAME (current_function);
  if (current_function_name == NULL)
    return nsyms;

  /* Check each of the symbols, and remove it from the list if it is
     a type corresponding to a renaming that is out of the scope of
     the current block.  */

  i = 0;
  while (i < nsyms)
    {
      if (ada_is_object_renaming (syms[i].sym)
          && !renaming_is_visible (syms[i].sym, current_function_name))
        {
          int j;
          for (j = i + 1; j < nsyms; j++)
            syms[j - 1] = syms[j];
          nsyms -= 1;
        }
      else
        i += 1;
    }

  return nsyms;
}

/* Find symbols in DOMAIN matching NAME0, in BLOCK0 and enclosing
   scope and in global scopes, returning the number of matches.  Sets
   *RESULTS to point to a vector of (SYM,BLOCK,SYMTAB) triples,
   indicating the symbols found and the blocks and symbol tables (if
   any) in which they were found.  This vector are transient---good only to 
   the next call of ada_lookup_symbol_list.  Any non-function/non-enumeral 
   symbol match within the nest of blocks whose innermost member is BLOCK0,
   is the one match returned (no other matches in that or
     enclosing blocks is returned).  If there are any matches in or
   surrounding BLOCK0, then these alone are returned.  Otherwise, the
   search extends to global and file-scope (static) symbol tables.
   Names prefixed with "standard__" are handled specially: "standard__" 
   is first stripped off, and only static and global symbols are searched.  */
d3648 3
a3650 3
ada_lookup_symbol_list (const char *name0, const struct block *block0,
                        domain_enum namespace,
                        struct ada_symbol_info **results)
d3657 1
a3658 1
  const char *name;
d3660 1
a3660 1
  int wild_match;
a3661 2
  int block_depth;
  int ndefns;
d3663 3
a3665 2
  obstack_free (&symbol_list_obstack, NULL);
  obstack_init (&symbol_list_obstack);
d3667 1
d3672 1
a3672 13
  wild_match = (strstr (name0, "__") == NULL);
  name = name0;
  block = (struct block *) block0;      /* FIXME: No cast ought to be
                                           needed, but adding const will
                                           have a cascade effect.  */
  if (strncmp (name0, "standard__", sizeof ("standard__") - 1) == 0)
    {
      wild_match = 0;
      block = NULL;
      name = name0 + sizeof ("standard__") - 1;
    }

  block_depth = 0;
d3675 5
a3679 8
      block_depth += 1;
      ada_add_block_symbols (&symbol_list_obstack, block, name,
                             namespace, NULL, NULL, wild_match);

      /* If we found a non-function match, assume that's the one.  */
      if (is_nonfunction (defns_collected (&symbol_list_obstack, 0),
                          num_defns_collected (&symbol_list_obstack)))
        goto done;
d3684 1
a3684 7
  /* If no luck so far, try to find NAME as a local symbol in some lexically
     enclosing subprogram.  */
  if (num_defns_collected (&symbol_list_obstack) == 0 && block_depth > 2)
    add_symbols_from_enclosing_procs (&symbol_list_obstack,
                                      name, namespace, wild_match);

  /* If we found ANY matches among non-global symbols, we're done.  */
d3686 1
a3686 1
  if (num_defns_collected (&symbol_list_obstack) > 0)
a3689 6
  if (lookup_cached_symbol (name0, namespace, &sym, &block, &s))
    {
      if (sym != NULL)
        add_defn_to_vec (&symbol_list_obstack, sym, block, s);
      goto done;
    }
d3692 1
a3692 1
     tables, and psymtab's.  */
d3701 1
a3701 2
    ada_add_block_symbols (&symbol_list_obstack, block, name, namespace,
                           objfile, s, wild_match);
d3704 1
a3704 1
  if (namespace == VAR_DOMAIN)
d3708 28
a3735 29
        if (ada_match_name (SYMBOL_LINKAGE_NAME (msymbol), name, wild_match))
          {
            switch (MSYMBOL_TYPE (msymbol))
              {
              case mst_solib_trampoline:
                break;
              default:
                s = find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol));
                if (s != NULL)
                  {
                    int ndefns0 = num_defns_collected (&symbol_list_obstack);
                    QUIT;
                    bv = BLOCKVECTOR (s);
                    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
                    ada_add_block_symbols (&symbol_list_obstack, block,
                                           SYMBOL_LINKAGE_NAME (msymbol),
                                           namespace, objfile, s, wild_match);

                    if (num_defns_collected (&symbol_list_obstack) == ndefns0)
                      {
                        block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
                        ada_add_block_symbols (&symbol_list_obstack, block,
                                               SYMBOL_LINKAGE_NAME (msymbol),
                                               namespace, objfile, s,
                                               wild_match);
                      }
                  }
              }
          }
d3743 1
a3743 1
        && ada_lookup_partial_symbol (ps, name, 1, namespace, wild_match))
d3745 6
a3750 7
        s = PSYMTAB_TO_SYMTAB (ps);
        if (!s->primary)
          continue;
        bv = BLOCKVECTOR (s);
        block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
        ada_add_block_symbols (&symbol_list_obstack, block, name,
                               namespace, objfile, s, wild_match);
d3754 1
a3754 1
  /* Now add symbols from all per-file blocks if we've gotten no hits
d3756 1
a3756 1
     Do the symtabs first, then check the psymtabs.  */
d3758 1
a3758 1
  if (num_defns_collected (&symbol_list_obstack) == 0)
d3763 6
a3768 7
        QUIT;
        if (!s->primary)
          continue;
        bv = BLOCKVECTOR (s);
        block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
        ada_add_block_symbols (&symbol_list_obstack, block, name, namespace,
                               objfile, s, wild_match);
d3773 12
a3784 12
        QUIT;
        if (!ps->readin
            && ada_lookup_partial_symbol (ps, name, 0, namespace, wild_match))
          {
            s = PSYMTAB_TO_SYMTAB (ps);
            bv = BLOCKVECTOR (s);
            if (!s->primary)
              continue;
            block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
            ada_add_block_symbols (&symbol_list_obstack, block, name,
                                   namespace, objfile, s, wild_match);
          }
d3788 3
a3790 6
done:
  ndefns = num_defns_collected (&symbol_list_obstack);
  *results = defns_collected (&symbol_list_obstack, 1);

  ndefns = remove_extra_symbols (*results, ndefns);

d3792 5
a3796 1
    cache_symbol (name0, namespace, NULL, NULL, NULL);
d3798 2
a3799 3
  if (ndefns == 1 && cacheIfUnique)
    cache_symbol (name0, namespace, (*results)[0].sym, (*results)[0].block,
                  (*results)[0].symtab);
a3800 2
  ndefns = remove_out_of_scope_renamings (*results, ndefns,
                                          (struct block *) block0);
d3802 5
d3810 5
a3814 8
/* Return a symbol in DOMAIN matching NAME, in BLOCK0 and enclosing
   scope and in global scopes, or NULL if none.  NAME is folded and
   encoded first.  Otherwise, the result is as for ada_lookup_symbol_list,
   but is disambiguated by user query if needed.  *IS_A_FIELD_OF_THIS is
   set to 0 and *SYMTAB is set to the symbol table in which the symbol
   was found (in both cases, these assignments occur only if the
   pointers are non-null).  */

d3817 2
a3818 3
ada_lookup_symbol (const char *name, const struct block *block0,
                   domain_enum namespace, int *is_a_field_of_this,
                   struct symtab **symtab)
d3820 2
a3821 1
  struct ada_symbol_info *candidates;
d3824 3
a3826 2
  n_candidates = ada_lookup_symbol_list (ada_encode (ada_fold_name (name)),
                                         block0, namespace, &candidates);
d3831 1
a3831 33
    user_select_syms (candidates, n_candidates, 1);

  if (is_a_field_of_this != NULL)
    *is_a_field_of_this = 0;

  if (symtab != NULL)
    {
      *symtab = candidates[0].symtab;
      if (*symtab == NULL && candidates[0].block != NULL)
        {
          struct objfile *objfile;
          struct symtab *s;
          struct block *b;
          struct blockvector *bv;

          /* Search the list of symtabs for one which contains the
             address of the start of this block.  */
          ALL_SYMTABS (objfile, s)
          {
            bv = BLOCKVECTOR (s);
            b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
            if (BLOCK_START (b) <= BLOCK_START (candidates[0].block)
                && BLOCK_END (b) > BLOCK_START (candidates[0].block))
              {
                *symtab = s;
                return fixup_symbol_section (candidates[0].sym, objfile);
              }
            return fixup_symbol_section (candidates[0].sym, NULL);
          }
        }
    }
  return candidates[0].sym;
}
d3833 1
a3833 10
static struct symbol *
ada_lookup_symbol_nonlocal (const char *name,
                            const char *linkage_name,
                            const struct block *block,
                            const domain_enum domain, struct symtab **symtab)
{
  if (linkage_name == NULL)
    linkage_name = name;
  return ada_lookup_symbol (linkage_name, block_static_block (block), domain,
                            NULL, symtab);
d3837 6
a3842 9
/* True iff STR is a possible encoded suffix of a normal Ada name
   that is to be ignored for matching purposes.  Suffixes of parallel
   names (e.g., XVE) are not included here.  Currently, the possible suffixes
   are given by either of the regular expression:

   (__[0-9]+)?\.[0-9]+  [nested subprogram suffix, on platforms such 
                         as GNU/Linux]
   ___[0-9]+            [nested subprogram suffix, on platforms such as HP/UX]
   (X[nb]*)?((\$|__)[0-9](_?[0-9]+)|___(LJM|X([FDBUP].*|R[^T]?)))?$
a3843 1

a3847 38
  const char *matching;
  const int len = strlen (str);

  /* (__[0-9]+)?\.[0-9]+ */
  matching = str;
  if (len > 3 && str[0] == '_' && str[1] == '_' && isdigit (str[2]))
    {
      matching += 3;
      while (isdigit (matching[0]))
        matching += 1;
      if (matching[0] == '\0')
        return 1;
    }

  if (matching[0] == '.')
    {
      matching += 1;
      while (isdigit (matching[0]))
        matching += 1;
      if (matching[0] == '\0')
        return 1;
    }

  /* ___[0-9]+ */
  if (len > 3 && str[0] == '_' && str[1] == '_' && str[2] == '_')
    {
      matching = str + 3;
      while (isdigit (matching[0]))
        matching += 1;
      if (matching[0] == '\0')
        return 1;
    }

  /* ??? We should not modify STR directly, as we are doing below.  This
     is fine in this case, but may become problematic later if we find
     that this alternative did not work, and want to try matching
     another one from the begining of STR.  Since we modified it, we
     won't be able to find the begining of the string anymore!  */
d3852 5
a3856 5
        {
          if (str[0] != 'n' && str[0] != 'b')
            return 0;
          str += 1;
        }
d3863 1
a3863 1
        return 0;
d3865 15
a3879 17
        {
          if (strcmp (str + 3, "LJM") == 0)
            return 1;
          if (str[3] != 'X')
            return 0;
          if (str[4] == 'F' || str[4] == 'D' || str[4] == 'B'
              || str[4] == 'U' || str[4] == 'P')
            return 1;
          if (str[4] == 'R' && str[5] != 'T')
            return 1;
          return 0;
        }
      if (!isdigit (str[2]))
        return 0;
      for (k = 3; str[k] != '\0'; k += 1)
        if (!isdigit (str[k]) && str[k] != '_')
          return 0;
d3882 1
a3882 1
  if (str[0] == '$' && isdigit (str[1]))
d3884 3
a3886 3
      for (k = 2; str[k] != '\0'; k += 1)
        if (!isdigit (str[k]) && str[k] != '_')
          return 0;
d3892 4
a3895 11
/* Return nonzero if the given string starts with a dot ('.')
   followed by zero or more digits.  
   
   Note: brobecker/2003-11-10: A forward declaration has not been
   added at the begining of this file yet, because this function
   is only used to work around a problem found during wild matching
   when trying to match minimal symbol names against symbol names
   obtained from dwarf-2 data.  This function is therefore currently
   only used in wild_match() and is likely to be deleted when the
   problem in dwarf-2 is fixed.  */

d3897 1
a3897 18
is_dot_digits_suffix (const char *str)
{
  if (str[0] != '.')
    return 0;

  str++;
  while (isdigit (str[0]))
    str++;
  return (str[0] == '\0');
}

/* True if NAME represents a name of the form A1.A2....An, n>=1 and
   PATN[0..PATN_LEN-1] = Ak.Ak+1.....An for some k >= 1.  Ignores
   informational suffixes of NAME (i.e., for which is_name_suffix is
   true).  */

static int
wild_match (const char *patn0, int patn_len, const char *name0)
d3900 1
a3900 45
  char *name;
  char *patn;

  /* FIXME: brobecker/2003-11-10: For some reason, the symbol name
     stored in the symbol table for nested function names is sometimes
     different from the name of the associated entity stored in
     the dwarf-2 data: This is the case for nested subprograms, where
     the minimal symbol name contains a trailing ".[:digit:]+" suffix,
     while the symbol name from the dwarf-2 data does not.

     Although the DWARF-2 standard documents that entity names stored
     in the dwarf-2 data should be identical to the name as seen in
     the source code, GNAT takes a different approach as we already use
     a special encoding mechanism to convey the information so that
     a C debugger can still use the information generated to debug
     Ada programs.  A corollary is that the symbol names in the dwarf-2
     data should match the names found in the symbol table.  I therefore
     consider this issue as a compiler defect.

     Until the compiler is properly fixed, we work-around the problem
     by ignoring such suffixes during the match.  We do so by making
     a copy of PATN0 and NAME0, and then by stripping such a suffix
     if present.  We then perform the match on the resulting strings.  */
  {
    char *dot;
    name_len = strlen (name0);

    name = (char *) alloca ((name_len + 1) * sizeof (char));
    strcpy (name, name0);
    dot = strrchr (name, '.');
    if (dot != NULL && is_dot_digits_suffix (dot))
      *dot = '\0';

    patn = (char *) alloca ((patn_len + 1) * sizeof (char));
    strncpy (patn, patn0, patn_len);
    patn[patn_len] = '\0';
    dot = strrchr (patn, '.');
    if (dot != NULL && is_dot_digits_suffix (dot))
      {
        *dot = '\0';
        patn_len = dot - patn;
      }
  }

  /* Now perform the wild match.  */
d3903 2
a3904 2
  if (name_len >= patn_len + 5 && strncmp (name, "_ada_", 5) == 0
      && strncmp (patn, name + 5, patn_len) == 0
d3910 2
a3911 3
      if (strncmp (patn, name, patn_len) == 0
          && is_name_suffix (name + patn_len))
        return 1;
d3913 4
a3916 4
        {
          name += 1;
          name_len -= 1;
        }
d3918 1
a3918 1
             && name[0] != '.' && (name[0] != '_' || name[1] != '_'));
d3920 1
a3920 1
        return 0;
d3922 13
a3934 13
        {
          if (!islower (name[2]))
            return 0;
          name += 2;
          name_len -= 2;
        }
      else
        {
          if (!islower (name[1]))
            return 0;
          name += 1;
          name_len -= 1;
        }
d3941 5
a3945 5
/* Add symbols from BLOCK matching identifier NAME in DOMAIN to
   vector *defn_symbols, updating the list of symbols in OBSTACKP 
   (if necessary).  If WILD, treat as NAME with a wildcard prefix. 
   OBJFILE is the section containing BLOCK.
   SYMTAB is recorded with each symbol added.  */
d3948 3
a3950 4
ada_add_block_symbols (struct obstack *obstackp,
                       struct block *block, const char *name,
                       domain_enum domain, struct objfile *objfile,
                       struct symtab *symtab, int wild)
d3954 1
a3954 1
  /* A matching argument symbol, if any.  */
d3956 1
a3956 1
  /* Set true when we find a matching non-argument symbol.  */
d3967 23
a3989 24
        if (SYMBOL_DOMAIN (sym) == domain
            && wild_match (name, name_len, SYMBOL_LINKAGE_NAME (sym)))
          {
            switch (SYMBOL_CLASS (sym))
              {
              case LOC_ARG:
              case LOC_LOCAL_ARG:
              case LOC_REF_ARG:
              case LOC_REGPARM:
              case LOC_REGPARM_ADDR:
              case LOC_BASEREG_ARG:
              case LOC_COMPUTED_ARG:
                arg_sym = sym;
                break;
              case LOC_UNRESOLVED:
                continue;
              default:
                found_sym = 1;
                add_defn_to_vec (obstackp,
                                 fixup_symbol_section (sym, objfile),
                                 block, symtab);
                break;
              }
          }
d3995 31
a4025 30
      {
        if (SYMBOL_DOMAIN (sym) == domain)
          {
            int cmp = strncmp (name, SYMBOL_LINKAGE_NAME (sym), name_len);
            if (cmp == 0
                && is_name_suffix (SYMBOL_LINKAGE_NAME (sym) + name_len))
              {
                switch (SYMBOL_CLASS (sym))
                  {
                  case LOC_ARG:
                  case LOC_LOCAL_ARG:
                  case LOC_REF_ARG:
                  case LOC_REGPARM:
                  case LOC_REGPARM_ADDR:
                  case LOC_BASEREG_ARG:
                  case LOC_COMPUTED_ARG:
                    arg_sym = sym;
                    break;
                  case LOC_UNRESOLVED:
                    break;
                  default:
                    found_sym = 1;
                    add_defn_to_vec (obstackp,
                                     fixup_symbol_section (sym, objfile),
                                     block, symtab);
                    break;
                  }
              }
          }
      }
d4030 2
a4031 3
      add_defn_to_vec (obstackp,
                       fixup_symbol_section (arg_sym, objfile),
                       block, symtab);
d4040 39
a4078 41
      {
        if (SYMBOL_DOMAIN (sym) == domain)
          {
            int cmp;

            cmp = (int) '_' - (int) SYMBOL_LINKAGE_NAME (sym)[0];
            if (cmp == 0)
              {
                cmp = strncmp ("_ada_", SYMBOL_LINKAGE_NAME (sym), 5);
                if (cmp == 0)
                  cmp = strncmp (name, SYMBOL_LINKAGE_NAME (sym) + 5,
                                 name_len);
              }

            if (cmp == 0
                && is_name_suffix (SYMBOL_LINKAGE_NAME (sym) + name_len + 5))
              {
                switch (SYMBOL_CLASS (sym))
                  {
                  case LOC_ARG:
                  case LOC_LOCAL_ARG:
                  case LOC_REF_ARG:
                  case LOC_REGPARM:
                  case LOC_REGPARM_ADDR:
                  case LOC_BASEREG_ARG:
                  case LOC_COMPUTED_ARG:
                    arg_sym = sym;
                    break;
                  case LOC_UNRESOLVED:
                    break;
                  default:
                    found_sym = 1;
                    add_defn_to_vec (obstackp,
                                     fixup_symbol_section (sym, objfile),
                                     block, symtab);
                    break;
                  }
              }
          }
      end_loop2:;
      }
d4081 1
a4081 1
         They aren't parameters, right?  */
d4083 4
a4086 5
        {
          add_defn_to_vec (obstackp,
                           fixup_symbol_section (arg_sym, objfile),
                           block, symtab);
        }
a4089 1
#ifdef GNAT_GDB
d4091 1
a4091 1
                                /* Symbol Completion */
d4093 2
a4094 8
/* If SYM_NAME is a completion candidate for TEXT, return this symbol
   name in a form that's appropriate for the completion.  The result
   does not need to be deallocated, but is only good until the next call.

   TEXT_LEN is equal to the length of TEXT.
   Perform a wild match if WILD_MATCH is set.
   ENCODED should be set if TEXT represents the start of a symbol name
   in its encoded form.  */
d4096 2
a4097 4
static const char *
symbol_completion_match (const char *sym_name,
                         const char *text, int text_len,
                         int wild_match, int encoded)
d4099 7
a4105 12
  char *result;
  const int verbatim_match = (text[0] == '<');
  int match = 0;

  if (verbatim_match)
    {
      /* Strip the leading angle bracket.  */
      text = text + 1;
      text_len--;
    }

  /* First, test against the fully qualified name of the symbol.  */
d4107 3
a4109 86
  if (strncmp (sym_name, text, text_len) == 0)
    match = 1;

  if (match && !encoded)
    {
      /* One needed check before declaring a positive match is to verify
         that iff we are doing a verbatim match, the decoded version
         of the symbol name starts with '<'.  Otherwise, this symbol name
         is not a suitable completion.  */
      const char *sym_name_copy = sym_name;
      int has_angle_bracket;

      sym_name = ada_decode (sym_name);
      has_angle_bracket = (sym_name[0] == '<');
      match = (has_angle_bracket == verbatim_match);
      sym_name = sym_name_copy;
    }

  if (match && !verbatim_match)
    {
      /* When doing non-verbatim match, another check that needs to
         be done is to verify that the potentially matching symbol name
         does not include capital letters, because the ada-mode would
         not be able to understand these symbol names without the
         angle bracket notation.  */
      const char *tmp;

      for (tmp = sym_name; *tmp != '\0' && !isupper (*tmp); tmp++);
      if (*tmp != '\0')
        match = 0;
    }

  /* Second: Try wild matching...  */

  if (!match && wild_match)
    {
      /* Since we are doing wild matching, this means that TEXT
         may represent an unqualified symbol name.  We therefore must
         also compare TEXT against the unqualified name of the symbol.  */
      sym_name = ada_unqualified_name (ada_decode (sym_name));

      if (strncmp (sym_name, text, text_len) == 0)
        match = 1;
    }

  /* Finally: If we found a mach, prepare the result to return.  */

  if (!match)
    return NULL;

  if (verbatim_match)
    sym_name = add_angle_brackets (sym_name);

  if (!encoded)
    sym_name = ada_decode (sym_name);

  return sym_name;
}

/* A companion function to ada_make_symbol_completion_list().
   Check if SYM_NAME represents a symbol which name would be suitable
   to complete TEXT (TEXT_LEN is the length of TEXT), in which case
   it is appended at the end of the given string vector SV.

   ORIG_TEXT is the string original string from the user command
   that needs to be completed.  WORD is the entire command on which
   completion should be performed.  These two parameters are used to
   determine which part of the symbol name should be added to the
   completion vector.
   if WILD_MATCH is set, then wild matching is performed.
   ENCODED should be set if TEXT represents a symbol name in its
   encoded formed (in which case the completion should also be
   encoded).  */

static void
symbol_completion_add (struct string_vector *sv,
                       const char *sym_name,
                       const char *text, int text_len,
                       const char *orig_text, const char *word,
                       int wild_match, int encoded)
{
  const char *match = symbol_completion_match (sym_name, text, text_len,
                                               wild_match, encoded);
  char *completion;

  if (match == NULL)
d4112 8
a4119 2
  /* We found a match, so add the appropriate completion to the given
     string vector.  */
d4121 1
a4121 19
  if (word == orig_text)
    {
      completion = xmalloc (strlen (match) + 5);
      strcpy (completion, match);
    }
  else if (word > orig_text)
    {
      /* Return some portion of sym_name.  */
      completion = xmalloc (strlen (match) + 5);
      strcpy (completion, match + (word - orig_text));
    }
  else
    {
      /* Return some of ORIG_TEXT plus sym_name.  */
      completion = xmalloc (strlen (match) + (orig_text - word) + 5);
      strncpy (completion, word, orig_text - word);
      completion[orig_text - word] = '\0';
      strcat (completion, match);
    }
d4123 5
a4127 53
  string_vector_append (sv, completion);
}

/* Return a list of possible symbol names completing TEXT0.  The list
   is NULL terminated.  WORD is the entire command on which completion
   is made.  */

char **
ada_make_symbol_completion_list (const char *text0, const char *word)
{
  /* Note: This function is almost a copy of make_symbol_completion_list(),
     except it has been adapted for Ada.  It is somewhat of a shame to
     duplicate so much code, but we don't really have the infrastructure
     yet to develop a language-aware version of he symbol completer...  */
  char *text;
  int text_len;
  int wild_match;
  int encoded;
  struct string_vector result = xnew_string_vector (128);
  struct symbol *sym;
  struct symtab *s;
  struct partial_symtab *ps;
  struct minimal_symbol *msymbol;
  struct objfile *objfile;
  struct block *b, *surrounding_static_block = 0;
  int i;
  struct dict_iterator iter;

  if (text0[0] == '<')
    {
      text = xstrdup (text0);
      make_cleanup (xfree, text);
      text_len = strlen (text);
      wild_match = 0;
      encoded = 1;
    }
  else
    {
      text = xstrdup (ada_encode (text0));
      make_cleanup (xfree, text);
      text_len = strlen (text);
      for (i = 0; i < text_len; i++)
        text[i] = tolower (text[i]);

      /* FIXME: brobecker/2003-09-17: When we get rid of ADA_RETAIN_DOTS,
         we can restrict the wild_match check to searching "__" only.  */
      wild_match = (strstr (text0, "__") == NULL
                    && strchr (text0, '.') == NULL);
      encoded = (strstr (text0, "__") != NULL);
    }

  /* First, look at the partial symtab symbols.  */
  ALL_PSYMTABS (objfile, ps)
d4129 1
a4129 1
    struct partial_symbol **psym;
d4131 1
a4131 8
    /* If the psymtab's been read in we'll get it when we search
       through the blockvector.  */
    if (ps->readin)
      continue;

    for (psym = objfile->global_psymbols.list + ps->globals_offset;
         psym < (objfile->global_psymbols.list + ps->globals_offset
                 + ps->n_global_syms); psym++)
d4133 9
a4141 16
        QUIT;
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (*psym),
                               text, text_len, text0, word,
                               wild_match, encoded);
      }

    for (psym = objfile->static_psymbols.list + ps->statics_offset;
         psym < (objfile->static_psymbols.list + ps->statics_offset
                 + ps->n_static_syms); psym++)
      {
        QUIT;
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (*psym),
                               text, text_len, text0, word,
                               wild_match, encoded);
      }
  }
d4143 1
a4143 4
  /* At this point scan through the misc symbol vectors and add each
     symbol you find to the list.  Eventually we want to ignore
     anything that isn't a text symbol (everything else will be
     handled by the psymtab code above).  */
d4145 11
a4155 6
  ALL_MSYMBOLS (objfile, msymbol)
  {
    QUIT;
    symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (msymbol),
                           text, text_len, text0, word, wild_match, encoded);
  }
d4157 1
a4157 2
  /* Search upwards from currently selected frame (so that we can
     complete on local vars.  */
d4159 2
a4160 10
  for (b = get_selected_block (0); b != NULL; b = BLOCK_SUPERBLOCK (b))
    {
      if (!BLOCK_SUPERBLOCK (b))
        surrounding_static_block = b;   /* For elmin of dups */

      ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
        symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
                               text, text_len, text0, word,
                               wild_match, encoded);
d4162 1
a4162 1
    }
d4164 3
a4166 2
  /* Go through the symtabs and check the externs and statics for
     symbols which match.  */
d4168 2
a4169 5
  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
    ALL_BLOCK_SYMBOLS (b, iter, sym)
d4171 3
a4173 3
      symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
                             text, text_len, text0, word,
                             wild_match, encoded);
d4175 1
a4175 10
  }

  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
    /* Don't do this block twice.  */
    if (b == surrounding_static_block)
      continue;
    ALL_BLOCK_SYMBOLS (b, iter, sym)
d4177 6
a4182 3
      symbol_completion_add (&result, SYMBOL_LINKAGE_NAME (sym),
                             text, text_len, text0, word,
                             wild_match, encoded);
d4184 2
a4185 1
  }
d4187 1
a4187 2
  /* Append the closing NULL entry.  */
  string_vector_append (&result, NULL);
d4189 2
a4190 7
  return (result.array);
}

#endif /* GNAT_GDB */

#ifdef GNAT_GDB
                                /* Breakpoint-related */
d4194 2
a4195 2
   of that name.  This is the first ':', ' ', or end of LINE.  */

d4199 2
a4200 2
  /* NOTE: strpbrk would be more elegant, but I am reluctant to be
     the first to use such a library function in GDB code.  */
d4211 2
a4212 1
   information in *SPEC and FILE_TABLE in the following sense:
d4216 1
a4216 1
       then the sal refers to that line (or one following it as closely as
d4218 1
a4218 1
     + If *SPEC does not start with '*', the sal is in a function with
d4225 1
a4225 1
   to the usual encoding.
d4230 1
a4230 1
   in each function.
d4235 3
a4237 3
   list of sals, such that (*CANONICAL)[i] is non-null and contains a
   canonical line spec for the ith returned sal, if needed.  If no
   canonical line specs are required and CANONICAL is non-null,
d4245 1
a4245 1
   identification.  Currently overloaded functions, the name '*',
d4248 1
a4248 1
   is the caller's responsibility to free them.  */
d4252 1
a4252 1
                          int funfirstline, char ***canonical)
d4254 3
a4256 2
  struct ada_symbol_info *symbols;
  const struct block *block;
a4260 1
  int is_quoted;
d4267 1
a4267 1
    block = block_static_block (get_selected_block (0));
a4273 3
  is_quoted = (**spec && strchr (get_gdb_completer_quote_characters (),
                                 **spec) != NULL);

d4279 3
a4281 5
      if (is_quoted)
        *spec = skip_quoted (*spec);
      while (**spec != '\000'
             && !strchr (ada_completer_word_break_characters, **spec))
        *spec += 1;
d4290 1
a4290 1
        *spec += 1;
d4296 1
a4296 1
        error ("Wild-card function with no line number or file name.");
d4298 1
a4298 2
      return ada_sals_for_line (file_table->filename, line_num,
                                funfirstline, canonical, 0);
d4321 1
a4321 1
        lower_name[i] = tolower (name[i]);
d4327 2
a4328 2
    n_matches = ada_lookup_symbol_list (ada_encode (lower_name), block,
                                        VAR_DOMAIN, &symbols);
d4331 1
a4331 1
                                        VAR_DOMAIN, &symbols);
d4340 1
a4340 1
#define volatile                /*nothing */
d4350 1
a4350 1
        msymbol = ada_lookup_simple_minsym (ada_encode (lower_name));
d4352 1
a4352 1
        msymbol = ada_lookup_simple_minsym (unquoted_name);
d4354 18
a4371 20
        {
          val.pc = SYMBOL_VALUE_ADDRESS (msymbol);
          val.section = SYMBOL_BFD_SECTION (msymbol);
          if (funfirstline)
            {
              val.pc = gdbarch_convert_from_func_ptr_addr (current_gdbarch,
							   val.pc,
							   &current_target);
              SKIP_PROLOGUE (val.pc);
            }
          selected.sals = (struct symtab_and_line *)
            xmalloc (sizeof (struct symtab_and_line));
          selected.sals[0] = val;
          selected.nelts = 1;
          return selected;
        }

      if (!have_full_symbols ()
          && !have_partial_symbols () && !have_minimal_symbols ())
        error ("No symbol table is loaded.  Use the \"file\" command.");
d4374 1
a4374 1
      return selected;          /* for lint */
d4379 3
a4381 6
      struct symtabs_and_lines best_sal =
        find_sal_from_funcs_and_line (file_table->filename, line_num,
                                      symbols, n_matches);
      if (funfirstline)
        adjust_pc_past_prologue (&best_sal.sals[0].pc);
      return best_sal;
d4385 2
a4386 1
      selected.nelts = user_select_syms (symbols, n_matches, n_matches);
d4397 7
a4403 10
      if (SYMBOL_CLASS (symbols[i].sym) == LOC_BLOCK)
        selected.sals[i]
          = find_function_start_sal (symbols[i].sym, funfirstline);
      else if (SYMBOL_LINE (symbols[i].sym) != 0)
        {
          selected.sals[i].symtab =
            symbols[i].symtab
            ? symbols[i].symtab : symtab_for_sym (symbols[i].sym);
          selected.sals[i].line = SYMBOL_LINE (symbols[i].sym);
        }
d4405 7
a4411 6
        {
          /* Ignore this choice */
          symbols[i] = symbols[selected.nelts - 1];
          selected.nelts -= 1;
          continue;
        }
d4413 1
a4413 1
        error ("Line number not known for symbol \"%s\"", unquoted_name);
d4421 3
a4423 3
        (*canonical)[i] =
          extended_canonical_line_spec (selected.sals[i],
                                        SYMBOL_PRINT_NAME (symbols[i].sym));
d4431 2
a4432 3
   with file name FILENAME that occurs in one of the functions listed
   in the symbol fields of SYMBOLS[0 .. NSYMS-1].  */

d4435 1
a4435 1
                              struct ada_symbol_info *symbols, int nsyms)
d4457 1
a4457 1
    if (strcmp (filename, s->filename) != 0)
d4463 14
a4476 14
        if (exact)
          {
            best_index = ind;
            best_linetable = l;
            best_symtab = s;
            goto done;
          }
        if (best == 0 || l->item[ind].line < best)
          {
            best = l->item[ind].line;
            best_index = ind;
            best_linetable = l;
            best_symtab = s;
          }
d4498 2
a4499 4
   pc falls within one of the functions denoted by the symbol fields
   of SYMBOLS[0..NSYMS-1].  Set *EXACTP to 1 if the match is exact, 
   and 0 otherwise.  */

d4502 1
a4502 2
                        struct ada_symbol_info *symbols, int nsyms,
                        int *exactp)
d4516 6
a4521 7
        {
          if (symbols[k].sym != NULL
              && SYMBOL_CLASS (symbols[k].sym) == LOC_BLOCK
              && item->pc >= BLOCK_START (SYMBOL_BLOCK_VALUE (symbols[k].sym))
              && item->pc < BLOCK_END (SYMBOL_BLOCK_VALUE (symbols[k].sym)))
            goto candidate;
        }
d4527 4
a4530 4
        {
          *exactp = 1;
          return i;
        }
d4533 4
a4536 4
        {
          best = item->line;
          best_index = i;
        }
d4545 1
a4545 2
   or before LINE_NUM.  Return -1 if there is no such k.  */

d4559 1
d4563 27
a4589 27
        {
          char *func_name;
          CORE_ADDR start, end;

          func_name = NULL;
          find_pc_partial_function (item->pc, &func_name, &start, &end);

          if (func_name != NULL && item->pc < end)
            {
              if (item->line == line_num)
                return line_num;
              else
                {
                  struct symbol *sym =
                    standard_lookup (func_name, NULL, VAR_DOMAIN);
                  if (is_plausible_func_for_line (sym, line_num))
                    best = item->line;
                  else
                    {
                      do
                        i += 1;
                      while (i < len && linetable->item[i].pc < end);
                      continue;
                    }
                }
            }
        }
d4598 1
a4598 1
/* Return the next higher index, k, into LINETABLE such that k > IND,
d4600 1
a4600 1
   corresponds to a PC that is in a function different from that
d4602 3
a4604 3
   that begins at a line at or preceding STARTING_LINE.
   Return -1 if there is no such k.
   IND == -1 corresponds to no function.  */
d4608 1
a4608 1
                             int starting_line, int ind)
d4621 5
a4625 5
                                    (char **) NULL, &start, &end))
        {
          while (ind < len && linetable->item[ind].pc < end)
            ind += 1;
        }
d4627 1
a4627 1
        ind += 1;
d4635 1
d4639 23
a4661 23
        {
          char *func_name;
          CORE_ADDR start, end;

          func_name = NULL;
          find_pc_partial_function (item->pc, &func_name, &start, &end);

          if (func_name != NULL && item->pc < end)
            {
              if (item->line == line_num)
                {
                  struct symbol *sym =
                    standard_lookup (func_name, NULL, VAR_DOMAIN);
                  if (is_plausible_func_for_line (sym, starting_line))
                    return i;
                  else
                    {
                      while ((i + 1) < len && linetable->item[i + 1].pc < end)
                        i += 1;
                    }
                }
            }
        }
d4669 1
a4669 2
   LINE_NUM.  */

d4683 60
d4744 1
a4744 2
   with file name FILENAME.  */

d4755 1
a4755 1
    if (strcmp (filename, ps->filename) == 0)
d4761 4
a4764 12
   FILENAME, as filtered by the user.  Filter out any lines that
   reside in functions with "suppressed" names (not corresponding to
   explicit Ada functions), if there is at least one in a function
   with a non-suppressed name.  If CANONICAL is not null, set
   it to a corresponding array of canonical line specs.
   If ONE_LOCATION_ONLY is set and several matches are found for
   the given location, then automatically select the first match found
   instead of asking the user which instance should be returned.  */

struct symtabs_and_lines
ada_sals_for_line (const char *filename, int line_num,
                   int funfirstline, char ***canonical, int one_location_only)
d4786 1
a4786 1
    if (strcmp (s->filename, filename) != 0)
d4797 13
a4809 17
        ind =
          find_next_line_in_linetable (LINETABLE (s),
                                       target_line_num, line_num, ind);

        if (ind < 0)
          break;

        GROW_VECT (result.sals, len, result.nelts + 1);
        init_sal (&result.sals[result.nelts]);
        result.sals[result.nelts].line = line_num;
        result.sals[result.nelts].pc = LINETABLE (s)->item[ind].pc;
        result.sals[result.nelts].symtab = s;

        if (funfirstline)
          adjust_pc_past_prologue (&result.sals[result.nelts].pc);

        result.nelts += 1;
d4815 1
a4815 1
      int k, j, n;
d4818 1
d4822 6
a4827 23
        {
          find_pc_partial_function (result.sals[k].pc, &func_names[k],
                                    (CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
          if (func_names[k] == NULL)
            error ("Could not find function for one or more breakpoints.");
        }

      /* Remove suppressed names, unless all are suppressed.  */
      for (j = 0; j < result.nelts; j += 1)
        if (!is_suppressed_name (func_names[j]))
          {
            /* At least one name is unsuppressed, so remove all
               suppressed names.  */
            for (k = n = 0; k < result.nelts; k += 1)
              if (!is_suppressed_name (func_names[k]))
                {
                  func_names[n] = func_names[k];
                  result.sals[n] = result.sals[k];
                  n += 1;
                }
            result.nelts = n;
            break;
          }
d4830 32
a4861 43
        {
          if (one_location_only)
            {
              /* Automatically select the first of all possible choices.  */
              n = 1;
              choices[0] = 0;
            }
          else
            {
              printf_unfiltered ("[0] cancel\n");
              if (result.nelts > 1)
                printf_unfiltered ("[1] all\n");
              for (k = 0; k < result.nelts; k += 1)
                printf_unfiltered ("[%d] %s\n", k + first_choice,
                                   ada_decode (func_names[k]));

              n = get_selections (choices, result.nelts, result.nelts,
                                  result.nelts > 1, "instance-choice");
            }

          for (k = 0; k < n; k += 1)
            {
              result.sals[k] = result.sals[choices[k]];
              func_names[k] = func_names[choices[k]];
            }
          result.nelts = n;
        }

      if (canonical != NULL && result.nelts == 0)
        *canonical = NULL;
      else if (canonical != NULL)
        {
          *canonical = (char **) xmalloc (result.nelts * sizeof (char **));
          make_cleanup (xfree, *canonical);
          for (k = 0; k < result.nelts; k += 1)
            {
              (*canonical)[k] =
                extended_canonical_line_spec (result.sals[k], func_names[k]);
              if ((*canonical)[k] == NULL)
                error ("Could not locate one or more breakpoints.");
              make_cleanup (xfree, (*canonical)[k]);
            }
        }
d4864 1
a4864 7
  if (result.nelts == 0)
    {
      do_cleanups (old_chain);
      result.sals = NULL;
    }
  else
    discard_cleanups (old_chain);
d4871 2
a4872 2
   information.  The caller is responsible for releasing any space
   allocated.  */
d4883 1
a4883 1
                        + sizeof (sal.line) * 3 + 3);
d4888 4
a4891 3
/* Return type of Ada breakpoint associated with bp_stat:
   0 if not an Ada-specific breakpoint, 1 for break on specific exception,
   2 for break on unhandled exception, 3 for assert.  */
d4893 2
a4894 2
static int
ada_exception_breakpoint_type (bpstat bs)
d4896 1
a4896 2
  return ((!bs || !bs->breakpoint_at) ? 0
          : bs->breakpoint_at->break_on_exception);
d4899 2
a4900 7
/* True iff FRAME is very likely to be that of a function that is
   part of the runtime system.  This is all very heuristic, but is
   intended to be used as advice as to what frames are uninteresting
   to most users.  */

static int
is_known_support_routine (struct frame_info *frame)
d4902 15
a4916 16
  struct frame_info *next_frame = get_next_frame (frame);
  /* If frame is not innermost, that normally means that frame->pc
     points to *after* the call instruction, and we want to get the line
     containing the call, never the next line.  But if the next frame is
     a signal_handler_caller or a dummy frame, then the next frame was
     not entered as the result of a call, and we want to get the line
     containing frame->pc.  */
  const int pc_is_after_call =
    next_frame != NULL
    && get_frame_type (next_frame) != SIGTRAMP_FRAME
    && get_frame_type (next_frame) != DUMMY_FRAME;
  struct symtab_and_line sal
    = find_pc_line (get_frame_pc (frame), pc_is_after_call);
  char *func_name;
  int i;
  struct stat st;
d4918 2
a4919 6
  /* The heuristic:
     1. The symtab is null (indicating no debugging symbols)
     2. The symtab's filename does not exist.
     3. The object file's name is one of the standard libraries.
     4. The symtab's file name has the form of an Ada library source file.
     5. The function at frame's PC has a GNAT-compiler-generated name.  */
d4921 5
a4925 2
  if (sal.symtab == NULL)
    return 1;
d4927 2
a4928 6
  /* On some systems (e.g. VxWorks), the kernel contains debugging
     symbols; in this case, the filename referenced by these symbols
     does not exists.  */

  if (stat (sal.symtab->filename, &st))
    return 1;
d4930 3
a4932 14
  for (i = 0; known_runtime_file_name_patterns[i] != NULL; i += 1)
    {
      re_comp (known_runtime_file_name_patterns[i]);
      if (re_exec (sal.symtab->filename))
        return 1;
    }
  if (sal.symtab->objfile != NULL)
    {
      for (i = 0; known_runtime_file_name_patterns[i] != NULL; i += 1)
        {
          re_comp (known_runtime_file_name_patterns[i]);
          if (re_exec (sal.symtab->objfile->name))
            return 1;
        }
a4933 8

  /* If the frame PC points after the call instruction, then we need to
     decrement it in order to search for the function associated to this
     PC.  Otherwise, if the associated call was the last instruction of
     the function, we might either find the wrong function or even fail
     during the function name lookup.  */
  if (pc_is_after_call)
    func_name = function_name_from_pc (get_frame_pc (frame) - 1);
a4934 6
    func_name = function_name_from_pc (get_frame_pc (frame));

  if (func_name == NULL)
    return 1;

  for (i = 0; known_auxiliary_function_name_patterns[i] != NULL; i += 1)
d4936 20
a4955 3
      re_comp (known_auxiliary_function_name_patterns[i]);
      if (re_exec (func_name))
        return 1;
d4958 1
a4958 1
  return 0;
d4961 2
a4962 5
/* Find the first frame that contains debugging information and that is not
   part of the Ada run-time, starting from FI and moving upward.  */

void
ada_find_printable_frame (struct frame_info *fi)
d4964 3
a4966 9
  for (; fi != NULL; fi = get_prev_frame (fi))
    {
      if (!is_known_support_routine (fi))
        {
          select_frame (fi);
          break;
        }
    }

d4969 2
a4970 3
/* Name found for exception associated with last bpstat sent to
   ada_adjust_exception_stop.  Set to the null string if that bpstat
   did not correspond to an Ada exception or no name could be found.  */
d4972 2
a4973 8
static char last_exception_name[256];

/* If BS indicates a stop in an Ada exception, try to go up to a frame
   that will be meaningful to the user, and save the name of the last
   exception (truncated, if necessary) in last_exception_name.  */

void
ada_adjust_exception_stop (bpstat bs)
d4975 1
a4975 9
  CORE_ADDR addr;
  struct frame_info *fi;
  int frame_level;
  char *selected_frame_func;

  addr = 0;
  last_exception_name[0] = '\0';
  fi = get_selected_frame ();
  selected_frame_func = function_name_from_pc (get_frame_pc (fi));
d4977 1
a4977 1
  switch (ada_exception_breakpoint_type (bs))
d4979 14
a4992 24
    default:
      return;
    case 1:
      break;
    case 2:
      /* Unhandled exceptions.  Select the frame corresponding to
         ada.exceptions.process_raise_exception.  This frame is at
         least 2 levels up, so we simply skip the first 2 frames
         without checking the name of their associated function.  */
      for (frame_level = 0; frame_level < 2; frame_level += 1)
        if (fi != NULL)
          fi = get_prev_frame (fi);
      while (fi != NULL)
        {
          const char *func_name = function_name_from_pc (get_frame_pc (fi));
          if (func_name != NULL
              && strcmp (func_name, process_raise_exception_name) == 0)
            break;              /* We found the frame we were looking for...  */
          fi = get_prev_frame (fi);
        }
      if (fi == NULL)
        break;
      select_frame (fi);
      break;
d4995 1
a4995 6
  addr = parse_and_eval_address ("e.full_name");

  if (addr != 0)
    read_memory (addr, last_exception_name, sizeof (last_exception_name) - 1);
  last_exception_name[sizeof (last_exception_name) - 1] = '\0';
  ada_find_printable_frame (get_selected_frame ());
a4997 3
/* Output Ada exception name (if any) associated with last call to
   ada_adjust_exception_stop.  */

d4999 1
a4999 1
ada_print_exception_stop (bpstat bs)
d5001 37
a5037 75
  if (last_exception_name[0] != '\000')
    {
      ui_out_text (uiout, last_exception_name);
      ui_out_text (uiout, " at ");
    }
}

/* Parses the CONDITION string associated with a breakpoint exception
   to get the name of the exception on which the breakpoint has been
   set.  The returned string needs to be deallocated after use.  */

static char *
exception_name_from_cond (const char *condition)
{
  char *start, *end, *exception_name;
  int exception_name_len;

  start = strrchr (condition, '&') + 1;
  end = strchr (start, ')') - 1;
  exception_name_len = end - start + 1;

  exception_name =
    (char *) xmalloc ((exception_name_len + 1) * sizeof (char));
  sprintf (exception_name, "%.*s", exception_name_len, start);

  return exception_name;
}

/* Print Ada-specific exception information about B, other than task
   clause.  Return non-zero iff B was an Ada exception breakpoint.  */

int
ada_print_exception_breakpoint_nontask (struct breakpoint *b)
{
  if (b->break_on_exception == 1)
    {
      if (b->cond_string)       /* the breakpoint is on a specific exception.  */
        {
          char *exception_name = exception_name_from_cond (b->cond_string);

          make_cleanup (xfree, exception_name);

          ui_out_text (uiout, "on ");
          if (ui_out_is_mi_like_p (uiout))
            ui_out_field_string (uiout, "exception", exception_name);
          else
            {
              ui_out_text (uiout, "exception ");
              ui_out_text (uiout, exception_name);
              ui_out_text (uiout, " ");
            }
        }
      else
        ui_out_text (uiout, "on all exceptions");
    }
  else if (b->break_on_exception == 2)
    ui_out_text (uiout, "on unhandled exception");
  else if (b->break_on_exception == 3)
    ui_out_text (uiout, "on assert failure");
  else
    return 0;
  return 1;
}

/* Print task identifier for breakpoint B, if it is an Ada-specific
   breakpoint with non-zero tasking information.  */

void
ada_print_exception_breakpoint_task (struct breakpoint *b)
{
  if (b->task != 0)
    {
      ui_out_text (uiout, " task ");
      ui_out_field_int (uiout, "task", b->task);
    }
d5046 3
a5048 3
          && SYMBOL_CLASS (sym) != LOC_BLOCK
          && SYMBOL_CLASS (sym) != LOC_CONST
          && type_name != NULL && strcmp (type_name, "exception") == 0);
d5055 2
a5056 48
          && SYMBOL_CLASS (sym) != LOC_BLOCK
          && SYMBOL_CLASS (sym) != LOC_CONST);
}

/* Cause the appropriate error if no appropriate runtime symbol is
   found to set a breakpoint, using ERR_DESC to describe the
   breakpoint.  */

static void
error_breakpoint_runtime_sym_not_found (const char *err_desc)
{
  /* If we are not debugging an Ada program, we can not put exception
     breakpoints!  */

  if (ada_update_initial_language (language_unknown, NULL) != language_ada)
    error ("Unable to break on %s.  Is this an Ada main program?", err_desc);

  /* If the symbol does not exist, then check that the program is
     already started, to make sure that shared libraries have been
     loaded.  If it is not started, this may mean that the symbol is
     in a shared library.  */

  if (ptid_get_pid (inferior_ptid) == 0)
    error ("Unable to break on %s. Try to start the program first.",
           err_desc);

  /* At this point, we know that we are debugging an Ada program and
     that the inferior has been started, but we still are not able to
     find the run-time symbols. That can mean that we are in
     configurable run time mode, or that a-except as been optimized
     out by the linker...  In any case, at this point it is not worth
     supporting this feature.  */

  error ("Cannot break on %s in this configuration.", err_desc);
}

/* Test if NAME is currently defined, and that either ALLOW_TRAMP or
   the symbol is not a shared-library trampoline.  Return the result of
   the test.  */

static int
is_runtime_sym_defined (const char *name, int allow_tramp)
{
  struct minimal_symbol *msym;

  msym = lookup_minimal_symbol (name, NULL, NULL);
  return (msym != NULL && msym->type != mst_unknown
          && (allow_tramp || msym->type != mst_solib_trampoline));
d5060 1
a5060 1
   into equivalent form.  Return resulting argument string.  Set
d5062 1
a5062 2
   break on unhandled, 3 for assert, 0 otherwise.  */

d5069 54
a5122 65
  if (current_language->la_language == language_ada
      && strncmp (arg, "exception", 9) == 0
      && (arg[9] == ' ' || arg[9] == '\t' || arg[9] == '\0'))
    {
      char *tok, *end_tok;
      int toklen;
      int has_exception_propagation =
        is_runtime_sym_defined (raise_sym_name, 1);

      *break_on_exceptionp = 1;

      tok = arg + 9;
      while (*tok == ' ' || *tok == '\t')
        tok += 1;

      end_tok = tok;

      while (*end_tok != ' ' && *end_tok != '\t' && *end_tok != '\000')
        end_tok += 1;

      toklen = end_tok - tok;

      arg = (char *) xmalloc (sizeof (longest_exception_template) + toklen);
      make_cleanup (xfree, arg);
      if (toklen == 0)
        {
          if (has_exception_propagation)
            sprintf (arg, "'%s'", raise_sym_name);
          else
            error_breakpoint_runtime_sym_not_found ("exception");
        }
      else if (strncmp (tok, "unhandled", toklen) == 0)
        {
          if (is_runtime_sym_defined (raise_unhandled_sym_name, 1))
            sprintf (arg, "'%s'", raise_unhandled_sym_name);
          else
            error_breakpoint_runtime_sym_not_found ("exception");

          *break_on_exceptionp = 2;
        }
      else
        {
          if (is_runtime_sym_defined (raise_sym_name, 0))
            sprintf (arg, "'%s' if long_integer(e) = long_integer(&%.*s)",
                     raise_sym_name, toklen, tok);
          else
            error_breakpoint_runtime_sym_not_found ("specific exception");
        }
    }
  else if (current_language->la_language == language_ada
           && strncmp (arg, "assert", 6) == 0
           && (arg[6] == ' ' || arg[6] == '\t' || arg[6] == '\0'))
    {
      char *tok = arg + 6;

      if (!is_runtime_sym_defined (raise_assert_sym_name, 1))
        error_breakpoint_runtime_sym_not_found ("failed assertion");

      *break_on_exceptionp = 3;

      arg =
        (char *) xmalloc (sizeof (raise_assert_sym_name) + strlen (tok) + 2);
      make_cleanup (xfree, arg);
      sprintf (arg, "'%s'%s", raise_assert_sym_name, tok);
    }
a5124 1
#endif
d5126 2
a5127 1
                                /* Field Access */
d5130 1
a5130 1
   to be invisible to users.  */
d5141 1
a5141 1
              || (name[0] == '_' && strncmp (name, "_parent", 7) != 0));
d5145 1
a5145 2
/* True iff TYPE has a tag field.  If REFOK, then TYPE may also be a
   pointer or reference type whose ultimate target has a tag field. */
d5148 1
a5148 1
ada_is_tagged_type (struct type *type, int refok)
d5150 1
a5150 9
  return (ada_lookup_struct_elt_type (type, "_tag", refok, 1, NULL) != NULL);
}

/* True iff TYPE represents the type of X'Tag */

int
ada_is_tag_type (struct type *type)
{
  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_PTR)
a5151 39
  else
    {
      const char *name = ada_type_name (TYPE_TARGET_TYPE (type));
      return (name != NULL
              && strcmp (name, "ada__tags__dispatch_table") == 0);
    }
}

/* The type of the tag on VAL.  */

struct type *
ada_tag_type (struct value *val)
{
  return ada_lookup_struct_elt_type (VALUE_TYPE (val), "_tag", 1, 0, NULL);
}

/* The value of the tag on VAL.  */

struct value *
ada_value_tag (struct value *val)
{
  return ada_value_struct_elt (val, "_tag", "record");
}

/* The value of the tag on the object of type TYPE whose contents are
   saved at VALADDR, if it is non-null, or is at memory address
   ADDRESS. */

static struct value *
value_tag_from_contents_and_address (struct type *type, char *valaddr,
                                     CORE_ADDR address)
{
  int tag_byte_offset, dummy1, dummy2;
  struct type *tag_type;
  if (find_struct_field ("_tag", type, 0, &tag_type, &tag_byte_offset,
                         &dummy1, &dummy2))
    {
      char *valaddr1 = (valaddr == NULL) ? NULL : valaddr + tag_byte_offset;
      CORE_ADDR address1 = (address == 0) ? 0 : address + tag_byte_offset;
d5153 1
a5153 12
      return value_from_contents_and_address (tag_type, valaddr1, address1);
    }
  return NULL;
}

static struct type *
type_from_tag (struct value *tag)
{
  const char *type_name = ada_tag_name (tag);
  if (type_name != NULL)
    return ada_find_any_type (ada_encode (type_name));
  return NULL;
d5156 1
a5156 5
struct tag_args
{
  struct value *tag;
  char *name;
};
d5158 2
a5159 7
/* Wrapper function used by ada_tag_name.  Given a struct tag_args*
   value ARGS, sets ARGS->name to the tag name of ARGS->tag.  
   The value stored in ARGS->name is valid until the next call to 
   ada_tag_name_1.  */

static int
ada_tag_name_1 (void *args0)
d5161 1
a5161 17
  struct tag_args *args = (struct tag_args *) args0;
  static char name[1024];
  char *p;
  struct value *val;
  args->name = NULL;
  val = ada_value_struct_elt (args->tag, "tsd", NULL);
  if (val == NULL)
    return 0;
  val = ada_value_struct_elt (val, "expanded_name", NULL);
  if (val == NULL)
    return 0;
  read_memory_string (value_as_address (val), name, sizeof (name) - 1);
  for (p = name; *p != '\0'; p += 1)
    if (isalpha (*p))
      *p = tolower (*p);
  args->name = name;
  return 0;
d5164 1
a5164 2
/* The type name of the dynamic type denoted by the 'tag value TAG, as
 * a C string.  */
d5166 2
a5167 2
const char *
ada_tag_name (struct value *tag)
d5169 1
a5169 7
  struct tag_args args;
  if (!ada_is_tag_type (VALUE_TYPE (tag)))
    return NULL;
  args.tag = tag;
  args.name = NULL;
  catch_errors (ada_tag_name_1, &args, NULL, RETURN_MASK_ALL);
  return args.name;
d5172 1
a5172 1
/* The parent type of TYPE, or NULL if none.  */
d5191 3
a5193 3
/* True iff field number FIELD_NUM of structure type TYPE contains the
   parent-type (inherited) fields of a derived type.  Assumes TYPE is
   a structure type with at least FIELD_NUM+1 fields.  */
d5199 2
a5200 3
  return (name != NULL
          && (strncmp (name, "PARENT", 6) == 0
              || strncmp (name, "_parent", 7) == 0));
d5203 1
a5203 1
/* True iff field number FIELD_NUM of structure type TYPE is a
d5205 1
a5205 1
   field selection and flattened when printing).  Assumes TYPE is a
d5207 1
a5207 1
   structures.  */
d5214 3
a5216 4
          && (strncmp (name, "PARENT", 6) == 0
              || strcmp (name, "REP") == 0
              || strncmp (name, "_parent", 7) == 0
              || name[0] == 'S' || name[0] == 'R' || name[0] == 'O'));
d5219 3
a5221 3
/* True iff field number FIELD_NUM of structure or union type TYPE
   is a variant wrapper.  Assumes TYPE is a structure type with at least
   FIELD_NUM+1 fields.  */
d5228 3
a5230 3
          || (is_dynamic_field (type, field_num)
              && (TYPE_CODE (TYPE_TARGET_TYPE (field_type)) 
		  == TYPE_CODE_UNION)));
d5234 1
a5234 1
   whose discriminants are contained in the record type OUTER_TYPE,
d5241 1
a5241 2
  struct type *type =
    ada_lookup_struct_elt_type (outer_type, name, 1, 1, NULL);
d5248 1
a5248 1
/* Assuming that TYPE is the type of a variant wrapper, and FIELD_NUM is a
d5250 1
a5250 1
   represents a 'when others' clause; otherwise 0.  */
d5260 2
a5261 2
   returns the name of the discriminant controlling the variant.
   The value is valid until the next call to ada_variant_discrim_name.  */
d5286 2
a5287 2
      if (strncmp (discrim_end, "___XVN", 6) == 0)
        break;
d5296 4
a5299 5
        return "";
      if ((discrim_start > name + 3
           && strncmp (discrim_start - 3, "___", 3) == 0)
          || discrim_start[-1] == '.')
        break;
d5308 7
a5314 7
/* Scan STR for a subtype-encoded number, beginning at position K.
   Put the position of the character just past the number scanned in
   *NEW_K, if NEW_K!=NULL.  Put the scanned number in *R, if R!=NULL.
   Return 1 if there was a valid number at the given position, and 0
   otherwise.  A "subtype-encoded" number consists of the absolute value
   in decimal, followed by the letter 'm' to indicate a negative number.
   Assumes 0m does not occur.  */
d5324 1
a5324 1
  /* Do it the hard way so as not to make any assumption about
d5326 1
a5326 1
     LONGEST.  */
d5337 1
a5337 1
        *R = (-(LONGEST) (RU - 1)) - 1;
d5343 1
a5343 1
  /* NOTE on the above: Technically, C does not say what the results of
d5347 1
a5347 1
     above is always equivalent to the negative of RU.  */
d5354 3
a5356 3
/* Assuming that TYPE is a variant part wrapper type (a VARIANTS field),
   and FIELD_NUM is a valid field number within it, returns 1 iff VAL is
   in the range encoded by field FIELD_NUM of TYPE; otherwise 0.  */
d5368 27
a5394 27
        {
        case '\0':
          return 0;
        case 'S':
          {
            LONGEST W;
            if (!ada_scan_number (name, p + 1, &W, &p))
              return 0;
            if (val == W)
              return 1;
            break;
          }
        case 'R':
          {
            LONGEST L, U;
            if (!ada_scan_number (name, p + 1, &L, &p)
                || name[p] != 'T' || !ada_scan_number (name, p + 1, &U, &p))
              return 0;
            if (val >= L && val <= U)
              return 1;
            break;
          }
        case 'O':
          return 1;
        default:
          return 0;
        }
d5398 5
a5402 6
/* FIXME: Lots of redundancy below.  Try to consolidate. */

/* Given a value ARG1 (offset by OFFSET bytes) of a struct or union type
   ARG_TYPE, extract and return the value of one of its (non-static)
   fields.  FIELDNO says which field.   Differs from value_primitive_field
   only in that it can handle packed values of arbitrary type.  */
d5404 1
a5404 1
static struct value *
d5406 1
a5406 1
                           struct type *arg_type)
d5408 1
d5414 1
a5414 1
  /* Handle packed fields.  */
d5422 2
a5423 2
                                             offset + bit_pos / 8,
                                             bit_pos % 8, bit_size, type);
a5428 62
/* Find field with name NAME in object of type TYPE.  If found, return 1
   after setting *FIELD_TYPE_P to the field's type, *BYTE_OFFSET_P to 
   OFFSET + the byte offset of the field within an object of that type, 
   *BIT_OFFSET_P to the bit offset modulo byte size of the field, and
   *BIT_SIZE_P to its size in bits if the field is packed, and 0 otherwise.
   Looks inside wrappers for the field.  Returns 0 if field not
   found. */
static int
find_struct_field (char *name, struct type *type, int offset,
                   struct type **field_type_p,
                   int *byte_offset_p, int *bit_offset_p, int *bit_size_p)
{
  int i;

  CHECK_TYPEDEF (type);
  *field_type_p = NULL;
  *byte_offset_p = *bit_offset_p = *bit_size_p = 0;

  for (i = TYPE_NFIELDS (type) - 1; i >= 0; i -= 1)
    {
      int bit_pos = TYPE_FIELD_BITPOS (type, i);
      int fld_offset = offset + bit_pos / 8;
      char *t_field_name = TYPE_FIELD_NAME (type, i);

      if (t_field_name == NULL)
        continue;

      else if (field_name_match (t_field_name, name))
        {
          int bit_size = TYPE_FIELD_BITSIZE (type, i);
          *field_type_p = TYPE_FIELD_TYPE (type, i);
          *byte_offset_p = fld_offset;
          *bit_offset_p = bit_pos % 8;
          *bit_size_p = bit_size;
          return 1;
        }
      else if (ada_is_wrapper_field (type, i))
        {
          if (find_struct_field (name, TYPE_FIELD_TYPE (type, i), fld_offset,
                                 field_type_p, byte_offset_p, bit_offset_p,
                                 bit_size_p))
            return 1;
        }
      else if (ada_is_variant_part (type, i))
        {
          int j;
          struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, i));

          for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
            {
              if (find_struct_field (name, TYPE_FIELD_TYPE (field_type, j),
                                     fld_offset
                                     + TYPE_FIELD_BITPOS (field_type, j) / 8,
                                     field_type_p, byte_offset_p,
                                     bit_offset_p, bit_size_p))
                return 1;
            }
        }
    }
  return 0;
}

d5430 1
a5430 2

/* Look for a field NAME in ARG.  Adjust the address of ARG by OFFSET bytes,
d5434 1
a5434 1
   Searches recursively through wrapper fields (e.g., '_parent').  */
d5436 1
a5436 1
static struct value *
d5438 1
a5438 1
                         struct type *type)
d5448 1
a5448 1
        continue;
d5451 1
a5451 1
        return ada_value_primitive_field (arg, offset, i, type);
d5454 11
a5464 8
        {
          struct value *v =     /* Do not let indent join lines here. */
            ada_search_struct_field (name, arg,
                                     offset + TYPE_FIELD_BITPOS (type, i) / 8,
                                     TYPE_FIELD_TYPE (type, i));
          if (v != NULL)
            return v;
        }
d5467 18
a5484 15
        {
          int j;
          struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, i));
          int var_offset = offset + TYPE_FIELD_BITPOS (type, i) / 8;

          for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
            {
              struct value *v = ada_search_struct_field /* Force line break.  */
                (name, arg,
                 var_offset + TYPE_FIELD_BITPOS (field_type, j) / 8,
                 TYPE_FIELD_TYPE (field_type, j));
              if (v != NULL)
                return v;
            }
        }
d5489 3
a5491 6
/* Given ARG, a value of type (pointer or reference to a)*
   structure/union, extract the component named NAME from the ultimate
   target structure/union and return it as a value with its
   appropriate type.  If ARG is a pointer or reference and the field
   is not packed, returns a reference to the field, otherwise the
   value of the field (an lvalue if ARG is an lvalue).     
d5493 2
a5494 2
   The routine searches for NAME among all members of the structure itself
   and (recursively) among all members of any wrapper members
d5497 2
a5498 5
   ERR is a name (for use in error messages) that identifies the class
   of entity that ARG is supposed to be.  ERR may be null, indicating
   that on error, the function simply returns NULL, and does not
   throw an error.  (FIXME: True only if ARG is a pointer or reference
   at the moment). */
d5503 1
a5503 1
  struct type *t, *t1;
d5506 9
a5514 78
  v = NULL;
  t1 = t = check_typedef (VALUE_TYPE (arg));
  if (TYPE_CODE (t) == TYPE_CODE_REF)
    {
      t1 = TYPE_TARGET_TYPE (t);
      if (t1 == NULL)
        {
          if (err == NULL)
            return NULL;
          else
            error ("Bad value type in a %s.", err);
        }
      CHECK_TYPEDEF (t1);
      if (TYPE_CODE (t1) == TYPE_CODE_PTR)
        {
          COERCE_REF (arg);
          t = t1;
        }
    }

  while (TYPE_CODE (t) == TYPE_CODE_PTR)
    {
      t1 = TYPE_TARGET_TYPE (t);
      if (t1 == NULL)
        {
          if (err == NULL)
            return NULL;
          else
            error ("Bad value type in a %s.", err);
        }
      CHECK_TYPEDEF (t1);
      if (TYPE_CODE (t1) == TYPE_CODE_PTR)
        {
          arg = value_ind (arg);
          t = t1;
        }
      else
        break;
    }

  if (TYPE_CODE (t1) != TYPE_CODE_STRUCT && TYPE_CODE (t1) != TYPE_CODE_UNION)
    {
      if (err == NULL)
        return NULL;
      else
        error ("Attempt to extract a component of a value that is not a %s.",
               err);
    }

  if (t1 == t)
    v = ada_search_struct_field (name, arg, 0, t);
  else
    {
      int bit_offset, bit_size, byte_offset;
      struct type *field_type;
      CORE_ADDR address;

      if (TYPE_CODE (t) == TYPE_CODE_PTR)
        address = value_as_address (arg);
      else
        address = unpack_pointer (t, VALUE_CONTENTS (arg));

      t1 = ada_to_fixed_type (ada_get_base_type (t1), NULL, address, NULL);
      if (find_struct_field (name, t1, 0,
                             &field_type, &byte_offset, &bit_offset,
                             &bit_size))
        {
          if (bit_size != 0)
            {
              arg = ada_value_ind (arg);
              v = ada_value_primitive_packed_val (arg, NULL, byte_offset,
                                                  bit_offset, bit_size,
                                                  field_type);
            }
          else
            v = value_from_pointer (lookup_reference_type (field_type),
                                    address + byte_offset);
        }
d5517 6
a5522 1
  if (v == NULL && err != NULL)
d5529 2
a5530 2
   If DISPP is non-null, add its byte displacement from the beginning of a
   structure (pointed to by a value) of type TYPE to *DISPP (does not
d5534 1
a5534 1
   followed by "___".
d5536 3
a5538 3
   TYPE can be either a struct or union. If REFOK, TYPE may also 
   be a (pointer or reference)+ to a struct or union, and the
   ultimate target type will be searched.
d5542 1
a5542 2
   If NOERR is nonzero, return NULL if NAME is not suitably defined or
   TYPE is not a type of the right kind.  */
d5544 3
a5546 3
static struct type *
ada_lookup_struct_elt_type (struct type *type, char *name, int refok,
                            int noerr, int *dispp)
d5553 8
a5560 9
  if (refok && type != NULL)
    while (1)
      {
        CHECK_TYPEDEF (type);
        if (TYPE_CODE (type) != TYPE_CODE_PTR
            && TYPE_CODE (type) != TYPE_CODE_REF)
          break;
        type = TYPE_TARGET_TYPE (type);
      }
d5562 8
a5569 17
  if (type == NULL
      || (TYPE_CODE (type) != TYPE_CODE_STRUCT
          && TYPE_CODE (type) != TYPE_CODE_UNION))
    {
      if (noerr)
        return NULL;
      else
        {
          target_terminal_ours ();
          gdb_flush (gdb_stdout);
          fprintf_unfiltered (gdb_stderr, "Type ");
          if (type == NULL)
            fprintf_unfiltered (gdb_stderr, "(null)");
          else
            type_print (type, "", gdb_stderr, -1);
          error (" is not a structure or union type");
        }
d5581 1
a5581 1
        continue;
d5584 5
a5588 5
        {
          if (dispp != NULL)
            *dispp += TYPE_FIELD_BITPOS (type, i) / 8;
          return check_typedef (TYPE_FIELD_TYPE (type, i));
        }
d5591 11
a5601 11
        {
          disp = 0;
          t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (type, i), name,
                                          0, 1, &disp);
          if (t != NULL)
            {
              if (dispp != NULL)
                *dispp += disp + TYPE_FIELD_BITPOS (type, i) / 8;
              return t;
            }
        }
d5604 17
a5620 17
        {
          int j;
          struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, i));

          for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)
            {
              disp = 0;
              t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (field_type, j),
                                              name, 0, 1, &disp);
              if (t != NULL)
                {
                  if (dispp != NULL)
                    *dispp += disp + TYPE_FIELD_BITPOS (type, i) / 8;
                  return t;
                }
            }
        }
d5640 2
a5641 2
   OUTER_VALADDR, determine which variant clause (field number in VAR_TYPE,
   numbering from 0) is applicable.  Returns -1 if none are.  */
d5645 1
a5645 1
                           char *outer_valaddr)
d5656 1
a5656 1
    ada_lookup_struct_elt_type (outer_type, discrim_name, 1, 1, &disp);
d5665 1
a5665 1
        others_clause = i;
d5667 1
a5667 1
        return i;
d5675 1
a5675 1
                                /* Dynamic-Sized Records */
d5681 1
a5681 1
   conventional types that are constructed on the fly.  */
d5690 1
a5690 1
   rather than struct value*s.
d5708 1
a5708 1
   target at the target address.  */
d5712 1
a5712 1
   dynamic-sized types.  */
d5718 2
a5719 1
  return ada_to_fixed_value (val);
d5723 1
a5723 2
   qualifiers on VAL0.  */

d5732 3
a5734 1
      return ada_to_fixed_value (val);
d5741 1
a5741 1
   ALIGNMENT (a power of 2).  */
d5749 16
a5764 1
/* Return the bit alignment required for field #F of template type TYPE.  */
d5773 2
a5774 2
  if (!isdigit (name[len - 1]))
    return 1;
d5781 1
a5781 1
  if (align_offset < 7 || strncmp ("___XV", name + align_offset - 6, 5) != 0)
d5787 3
a5789 4
/* Find a symbol named NAME.  Ignores ambiguity.  */

struct symbol *
ada_find_any_symbol (const char *name)
d5793 1
a5793 1
  sym = standard_lookup (name, get_selected_block (NULL), VAR_DOMAIN);
d5795 1
a5795 12
    return sym;

  sym = standard_lookup (name, NULL, STRUCT_DOMAIN);
  return sym;
}

/* Find a type named NAME.  Ignores ambiguity.  */

struct type *
ada_find_any_type (const char *name)
{
  struct symbol *sym = ada_find_any_symbol (name);
d5797 1
a5803 43
/* Given a symbol NAME and its associated BLOCK, search all symbols
   for its ___XR counterpart, which is the ``renaming'' symbol
   associated to NAME.  Return this symbol if found, return
   NULL otherwise.  */

struct symbol *
ada_find_renaming_symbol (const char *name, struct block *block)
{
  const struct symbol *function_sym = block_function (block);
  char *rename;

  if (function_sym != NULL)
    {
      /* If the symbol is defined inside a function, NAME is not fully
         qualified.  This means we need to prepend the function name
         as well as adding the ``___XR'' suffix to build the name of
         the associated renaming symbol.  */
      char *function_name = SYMBOL_LINKAGE_NAME (function_sym);
      const int function_name_len = strlen (function_name);
      const int rename_len = function_name_len + 2      /*  "__" */
        + strlen (name) + 6 /* "___XR\0" */ ;

      /* Library-level functions are a special case, as GNAT adds
         a ``_ada_'' prefix to the function name to avoid namespace
         pollution.  However, the renaming symbol themselves do not
         have this prefix, so we need to skip this prefix if present.  */
      if (function_name_len > 5 /* "_ada_" */
          && strstr (function_name, "_ada_") == function_name)
        function_name = function_name + 5;

      rename = (char *) alloca (rename_len * sizeof (char));
      sprintf (rename, "%s__%s___XR", function_name, name);
    }
  else
    {
      const int rename_len = strlen (name) + 6;
      rename = (char *) alloca (rename_len * sizeof (char));
      sprintf (rename, "%s___XR", name);
    }

  return ada_find_any_symbol (rename);
}

d5805 1
a5805 1
   given type name.  If the type denoted by TYPE0 is to be preferred to
d5807 1
a5807 2
   otherwise return 0.  */

a5818 2
  else if (TYPE_NAME (type1) == NULL && TYPE_NAME (type0) != NULL)
    return 1;
d5821 2
a5822 2
  else if (ada_is_array_descriptor_type (type0)
           && !ada_is_array_descriptor_type (type1))
d5825 1
a5825 1
           && ada_renaming_type (type1) == NULL)
d5831 1
a5831 2
   null, its TYPE_TAG_NAME.  Null if TYPE is null.  */

d5844 1
a5844 1
   SUFFIX to the name of TYPE.  */
d5851 3
d5872 1
a5872 1
   type describing its fields.  Otherwise, return NULL.  */
d5885 2
a5886 2
      if (len > 6 && strcmp (ada_type_name (type) + len - 6, "___XVE") == 0)
        return type;
d5888 1
a5888 1
        return ada_find_parallel_type (type, "___XVE");
d5893 1
a5893 1
   non-zero iff field FIELD_NUM of TEMPL_TYPE has dynamic size.  */
d5904 2
a5905 2
/* The index of the variant field of TYPE, or -1 if TYPE does not
   represent a variant record type.  */
d5908 1
a5908 1
variant_field_index (struct type *type)
d5912 4
a5915 9
  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_STRUCT)
    return -1;

  for (f = 0; f < TYPE_NFIELDS (type); f += 1)
    {
      if (ada_is_variant_part (type, f))
        return f;
    }
  return -1;
d5918 1
a5918 2
/* A record type with no fields.  */

d5934 3
a5936 3
   the value of type TYPE at VALADDR or ADDRESS (see comments at
   the beginning of this section) VAL according to GNAT conventions.
   DVAL0 should describe the (portion of a) record that contains any
d5940 4
a5943 1
   of the variant.
d5945 3
a5947 12
   If not KEEP_DYNAMIC_FIELDS, then all fields whose position or
   length are not statically known are discarded.  As a consequence,
   VALADDR, ADDRESS and DVAL0 are ignored.

   NOTE: Limitations: For now, we assume that dynamic fields and
   variants occupy whole numbers of bytes.  However, they need not be
   byte-aligned.  */

struct type *
ada_template_to_fixed_record_type_1 (struct type *type, char *valaddr,
                                     CORE_ADDR address, struct value *dval0,
                                     int keep_dynamic_fields)
a5952 1
  int variant_field;
a5953 1
  int fld_bit_len, bit_incr;
d5956 1
a5956 14
  /* Compute the number of fields in this record type that are going
     to be processed: unless keep_dynamic_fields, this includes only
     fields whose position and length are static will be processed.  */
  if (keep_dynamic_fields)
    nfields = TYPE_NFIELDS (type);
  else
    {
      nfields = 0;
      while (nfields < TYPE_NFIELDS (type)
             && !ada_is_variant_part (type, nfields)
             && !is_dynamic_field (type, nfields))
        nfields++;
    }

d5966 3
a5968 1
  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE;
a5971 2
  variant_field = -1;

d5974 1
d5976 5
a5980 2
        align_value (off,
                     field_alignment (type, f)) + TYPE_FIELD_BITPOS (type, f);
d5983 1
d5986 24
a6009 4
        {
          variant_field = f;
          fld_bit_len = bit_incr = 0;
        }
d6011 27
a6037 27
        {
          if (dval0 == NULL)
            dval = value_from_contents_and_address (rtype, valaddr, address);
          else
            dval = dval0;

          TYPE_FIELD_TYPE (rtype, f) =
            ada_to_fixed_type
            (ada_get_base_type
             (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, f))),
             cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
             cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
          TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);
          bit_incr = fld_bit_len =
            TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, f)) * TARGET_CHAR_BIT;
        }
      else
        {
          TYPE_FIELD_TYPE (rtype, f) = TYPE_FIELD_TYPE (type, f);
          TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);
          if (TYPE_FIELD_BITSIZE (type, f) > 0)
            bit_incr = fld_bit_len =
              TYPE_FIELD_BITSIZE (rtype, f) = TYPE_FIELD_BITSIZE (type, f);
          else
            bit_incr = fld_bit_len =
              TYPE_LENGTH (TYPE_FIELD_TYPE (type, f)) * TARGET_CHAR_BIT;
        }
d6039 1
a6039 1
        bit_len = off + fld_bit_len;
d6041 1
a6041 42
      TYPE_LENGTH (rtype) =
        align_value (bit_len, TARGET_CHAR_BIT) / TARGET_CHAR_BIT;
    }

  /* We handle the variant part, if any, at the end because of certain
     odd cases in which it is re-ordered so as NOT the last field of
     the record.  This can happen in the presence of representation
     clauses.  */
  if (variant_field >= 0)
    {
      struct type *branch_type;

      off = TYPE_FIELD_BITPOS (rtype, variant_field);

      if (dval0 == NULL)
        dval = value_from_contents_and_address (rtype, valaddr, address);
      else
        dval = dval0;

      branch_type =
        to_fixed_variant_branch_type
        (TYPE_FIELD_TYPE (type, variant_field),
         cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
         cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
      if (branch_type == NULL)
        {
          for (f = variant_field + 1; f < TYPE_NFIELDS (rtype); f += 1)
            TYPE_FIELDS (rtype)[f - 1] = TYPE_FIELDS (rtype)[f];
          TYPE_NFIELDS (rtype) -= 1;
        }
      else
        {
          TYPE_FIELD_TYPE (rtype, variant_field) = branch_type;
          TYPE_FIELD_NAME (rtype, variant_field) = "S";
          fld_bit_len =
            TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, variant_field)) *
            TARGET_CHAR_BIT;
          if (off + fld_bit_len > bit_len)
            bit_len = off + fld_bit_len;
          TYPE_LENGTH (rtype) =
            align_value (bit_len, TARGET_CHAR_BIT) / TARGET_CHAR_BIT;
        }
a6042 1

d6051 6
a6056 19
/* As for ada_template_to_fixed_record_type_1 with KEEP_DYNAMIC_FIELDS
   of 1.  */

static struct type *
template_to_fixed_record_type (struct type *type, char *valaddr,
                               CORE_ADDR address, struct value *dval0)
{
  return ada_template_to_fixed_record_type_1 (type, valaddr,
                                              address, dval0, 1);
}

/* An ordinary record type in which ___XVL-convention fields and
   ___XVU- and ___XVN-convention field types in TYPE0 are replaced with
   static approximations, containing all possible fields.  Uses
   no runtime values.  Useless for use in values, but that's OK,
   since the results are used only for type determinations.   Works on both
   structs and unions.  Representation note: to save space, we memorize
   the result of this function in the TYPE_TARGET_TYPE of the
   template type.  */
d6059 1
a6059 1
template_to_static_fixed_type (struct type *type0)
d6065 2
a6066 2
  if (TYPE_TARGET_TYPE (type0) != NULL)
    return TYPE_TARGET_TYPE (type0);
d6068 14
a6081 2
  nfields = TYPE_NFIELDS (type0);
  type = type0;
d6085 3
a6087 2
      struct type *field_type = CHECK_TYPEDEF (TYPE_FIELD_TYPE (type0, f));
      struct type *new_type;
d6089 7
a6095 2
      if (is_dynamic_field (type0, f))
        new_type = to_static_fixed_type (TYPE_TARGET_TYPE (field_type));
d6097 5
a6101 18
        new_type = to_static_fixed_type (field_type);
      if (type == type0 && new_type != field_type)
        {
          TYPE_TARGET_TYPE (type0) = type = alloc_type (TYPE_OBJFILE (type0));
          TYPE_CODE (type) = TYPE_CODE (type0);
          INIT_CPLUS_SPECIFIC (type);
          TYPE_NFIELDS (type) = nfields;
          TYPE_FIELDS (type) = (struct field *)
            TYPE_ALLOC (type, nfields * sizeof (struct field));
          memcpy (TYPE_FIELDS (type), TYPE_FIELDS (type0),
                  sizeof (struct field) * nfields);
          TYPE_NAME (type) = ada_type_name (type0);
          TYPE_TAG_NAME (type) = NULL;
          TYPE_FLAGS (type) |= TYPE_FLAG_FIXED_INSTANCE;
          TYPE_LENGTH (type) = 0;
        }
      TYPE_FIELD_TYPE (type, f) = new_type;
      TYPE_FIELD_NAME (type, f) = TYPE_FIELD_NAME (type0, f);
d6103 1
d6107 3
a6109 7
/* Given an object of type TYPE whose contents are at VALADDR and
   whose address in memory is ADDRESS, returns a revision of TYPE --
   a non-dynamic-sized record with a variant part -- in which
   the variant part is replaced with the appropriate branch.  Looks
   for discriminant values in DVAL0, which can be NULL if the record
   contains the necessary discriminant values.  */

d6112 1
a6112 1
                                   CORE_ADDR address, struct value *dval0)
a6114 1
  struct value *dval;
a6117 1
  int variant_field = variant_field_index (type);
d6119 1
a6119 1
  if (variant_field == -1)
a6121 5
  if (dval0 == NULL)
    dval = value_from_contents_and_address (type, valaddr, address);
  else
    dval = dval0;

d6124 2
a6125 2
  INIT_CPLUS_SPECIFIC (rtype);
  TYPE_NFIELDS (rtype) = nfields;
d6129 1
a6129 1
          sizeof (struct field) * nfields);
d6132 2
a6133 1
  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE;
d6136 3
a6138 2
  branch_type = to_fixed_variant_branch_type
    (TYPE_FIELD_TYPE (type, variant_field),
d6140 2
a6141 2
                       TYPE_FIELD_BITPOS (type, variant_field)
                       / TARGET_CHAR_BIT),
d6143 3
a6145 2
                         TYPE_FIELD_BITPOS (type, variant_field)
                         / TARGET_CHAR_BIT), dval);
a6147 3
      int f;
      for (f = variant_field + 1; f < nfields; f += 1)
        TYPE_FIELDS (rtype)[f - 1] = TYPE_FIELDS (rtype)[f];
d6149 2
d6154 4
a6157 3
      TYPE_FIELD_TYPE (rtype, variant_field) = branch_type;
      TYPE_FIELD_NAME (rtype, variant_field) = "S";
      TYPE_FIELD_BITSIZE (rtype, variant_field) = 0;
d6159 1
a6160 1
  TYPE_LENGTH (rtype) -= TYPE_LENGTH (TYPE_FIELD_TYPE (type, variant_field));
a6161 1
  value_free_to_mark (mark);
d6168 4
a6171 14
   should be in DVAL, a record value; it may be NULL if the object
   at ADDR itself contains any necessary discriminant values.
   Additionally, VALADDR and ADDRESS may also be NULL if no discriminant
   values from the record are needed.  Except in the case that DVAL,
   VALADDR, and ADDRESS are all 0 or NULL, a variant field (unless
   unchecked) is replaced by a particular branch of the variant.

   NOTE: the case in which DVAL and VALADDR are NULL and ADDRESS is 0
   is questionable and may be removed.  It can arise during the
   processing of an unconstrained-array-of-record type where all the
   variant branches have exactly the same size.  This is because in
   such cases, the compiler does not bother to use the XVS convention
   when encoding the record.  I am currently dubious of this
   shortcut and suspect the compiler should be altered.  FIXME.  */
d6174 2
a6175 2
to_fixed_record_type (struct type *type0, char *valaddr,
                      CORE_ADDR address, struct value *dval)
d6179 4
a6182 3
  if (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE)
    return type0;

d6187 2
a6188 7
  else if (variant_field_index (type0) >= 0)
    {
      if (dval == NULL && valaddr == NULL && address == 0)
        return type0;
      return to_record_with_fixed_variant_part (type0, valaddr, address,
                                                dval);
    }
d6191 2
a6192 1
      TYPE_FLAGS (type0) |= TYPE_FLAG_FIXED_INSTANCE;
d6203 1
a6203 1
   indicated in the union's type name.  */
d6207 1
a6207 1
                              CORE_ADDR address, struct value *dval)
d6225 1
a6225 1
                               VALUE_TYPE (dval), VALUE_CONTENTS (dval));
d6230 2
a6231 1
    return to_fixed_record_type
d6234 1
a6234 1
  else if (variant_field_index (TYPE_FIELD_TYPE (var_type, which)) >= 0)
d6248 2
a6249 1
   varsize_limit.  */
d6253 1
a6253 1
                     int ignore_too_big)
d6258 4
a6261 3
  if (ada_is_packed_array_type (type0)  /* revisit? */
      || (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE))
    return type0;
d6268 2
a6269 2
         depend on the contents of the array in properly constructed
         debugging data.  */
d6273 1
a6273 1
        result = type0;
d6275 2
a6276 2
        result = create_array_type (alloc_type (TYPE_OBJFILE (type0)),
                                    elt_type, TYPE_INDEX_TYPE (type0));
d6285 1
a6285 1
        elt_type0 = TYPE_TARGET_TYPE (elt_type0);
d6288 2
a6289 2
         depend on the contents of the array in properly constructed
         debugging data.  */
d6292 7
a6298 7
        {
          struct type *range_type =
            to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, i),
                                 dval, TYPE_OBJFILE (type0));
          result = create_array_type (alloc_type (TYPE_OBJFILE (type0)),
                                      result, range_type);
        }
d6300 1
a6300 1
        error ("array type with dynamic size is larger than varsize-limit");
d6303 2
a6304 1
  TYPE_FLAGS (result) |= TYPE_FLAG_FIXED_INSTANCE;
d6312 1
a6312 2
   and may be NULL if there are none, or if the object of type TYPE at
   ADDRESS or in VALADDR contains these discriminants.  */
d6315 2
a6316 2
ada_to_fixed_type (struct type *type, char *valaddr,
                   CORE_ADDR address, struct value *dval)
d6324 1
a6324 13
      {
        struct type *static_type = to_static_fixed_type (type);
        if (ada_is_tagged_type (static_type, 0))
          {
            struct type *real_type =
              type_from_tag (value_tag_from_contents_and_address (static_type,
                                                                  valaddr,
                                                                  address));
            if (real_type != NULL)
              type = real_type;
          }
        return to_fixed_record_type (type, valaddr, address, NULL);
      }
d6326 1
a6326 1
      return to_fixed_array_type (type, dval, 1);
d6329 1
a6329 1
        return type;
d6331 1
a6331 1
        return to_fixed_variant_branch_type (type, valaddr, address, dval);
d6336 1
a6336 1
   TYPE0, but based on no runtime data.  */
d6346 4
a6349 3
  if (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE)
    return type0;

d6359 2
a6360 3
        return template_to_static_fixed_type (type);
      else
        return template_to_static_fixed_type (type0);
d6364 2
a6365 3
        return template_to_static_fixed_type (type);
      else
        return template_to_static_fixed_type (type0);
d6369 1
a6369 2
/* A static approximation of TYPE with all type wrappers removed.  */

d6377 1
a6377 1
        TYPE_NAME (type1) = ada_type_name (type);
d6385 1
a6385 1
        return type;
d6387 1
a6387 1
        return to_static_fixed_type (raw_real_type);
d6392 1
a6392 1
   cross-references that are not resolved as records (for example,
d6397 1
a6397 1
   ).  In these cases, since there is no mechanism for producing
d6400 1
a6400 1
   the name of the actual type.  Call these types "non-record stubs".  */
d6403 1
a6403 2
   exists, otherwise TYPE.  */

d6424 1
a6424 1
   creation of struct values].  */
d6426 3
a6428 3
static struct value *
ada_to_fixed_value_create (struct type *type0, CORE_ADDR address,
                           struct value *val0)
d6430 1
a6430 1
  struct type *type = ada_to_fixed_type (type0, 0, address, NULL);
d6434 1
a6434 31
    return value_from_contents_and_address (type, 0, address);
}

/* A value representing VAL, but with a standard (static-sized) type
   that correctly describes it.  Does not necessarily create a new
   value.  */

static struct value *
ada_to_fixed_value (struct value *val)
{
  return ada_to_fixed_value_create (VALUE_TYPE (val),
                                    VALUE_ADDRESS (val) + VALUE_OFFSET (val),
                                    val);
}

/* If the PC is pointing inside a function prologue, then re-adjust it
   past this prologue.  */

static void
adjust_pc_past_prologue (CORE_ADDR *pc)
{
  struct symbol *func_sym = find_pc_function (*pc);

  if (func_sym)
    {
      const struct symtab_and_line sal =
        find_function_start_sal (func_sym, 1);

      if (*pc <= sal.pc)
        *pc = sal.pc;
    }
d6437 1
a6437 1
/* A value representing VAL, but with a standard (static-sized) type
d6440 1
a6440 1
   types, therefore, the type of the result is likely to be inaccurate.  */
d6450 1
a6450 1
    return coerce_unspec_val_to_type (val, type);
d6454 3
d6459 2
a6460 2
/* Table mapping attribute numbers to names.
   NOTE: Keep up to date with enum ada_attribute definition in ada-lang.h.  */
d6469 1
d6472 1
a6472 4
  "modulus",
  "pos",
  "size",
  "tag",
d6474 1
d6479 1
a6479 1
ada_attribute_name (enum exp_opcode n)
d6481 2
a6482 2
  if (n >= OP_ATR_FIRST && n <= (int) OP_ATR_VAL)
    return attribute_names[n - OP_ATR_FIRST + 1];
d6487 1
a6487 1
/* Evaluate the 'POS attribute applied to ARG.  */
d6489 2
a6490 2
static LONGEST
pos_atr (struct value *arg)
d6503 4
a6506 4
        {
          if (v == TYPE_FIELD_BITPOS (type, i))
            return i;
        }
d6510 1
a6510 7
    return value_as_long (arg);
}

static struct value *
value_pos_atr (struct value *arg)
{
  return value_from_longest (builtin_type_ada_int, pos_atr (arg));
d6513 1
a6513 1
/* Evaluate the TYPE'VAL attribute applied to ARG.  */
d6527 1
a6527 1
        error ("argument to 'VAL out of range");
d6535 1
a6535 1
                                /* Evaluation */
d6537 3
a6539 3
/* True if TYPE appears to be an Ada character type.
   [At the moment, this is true only for Character and Wide_Character;
   It is a heuristic test that could stand improvement].  */
d6548 4
a6551 5
        || TYPE_CODE (type) == TYPE_CODE_INT
        || TYPE_CODE (type) == TYPE_CODE_RANGE)
    && (strcmp (name, "character") == 0
        || strcmp (name, "wide_character") == 0
        || strcmp (name, "unsigned char") == 0);
d6554 1
a6554 1
/* True if TYPE appears to be an Ada string type.  */
d6562 1
a6562 2
      && (ada_is_simple_array_type (type)
          || ada_is_array_descriptor_type (type))
d6576 1
a6576 1
   distinctive name.  */
d6583 2
a6584 2
          && TYPE_NFIELDS (type) == 1
          && strcmp (TYPE_FIELD_NAME (type, 0), "F") == 0);
d6588 1
a6588 1
   the parallel type.  */
d6595 1
d6613 1
a6613 1
/* The type of value designated by TYPE, with all aligners removed.  */
d6626 1
a6626 1
   having type TYPE.  Assumes ada_is_aligner_type (TYPE).  */
d6633 3
a6635 3
                                   valaddr +
                                   TYPE_FIELD_BITPOS (type,
                                                      0) / TARGET_CHAR_BIT);
a6639 2


d6641 1
a6641 1
   name NAME.  The value is good to the next call of ada_enum_name.  */
a6644 2
  static char *result;
  static size_t result_len = 0;
d6647 8
a6654 21
  /* First, unqualify the enumeration name:
     1. Search for the last '.' character.  If we find one, then skip
     all the preceeding characters, the unqualified name starts
     right after that dot.
     2. Otherwise, we may be debugging on a target where the compiler
     translates dots into "__".  Search forward for double underscores,
     but stop searching when we hit an overloading suffix, which is
     of the form "__" followed by digits.  */

  tmp = strrchr (name, '.');
  if (tmp != NULL)
    name = tmp + 1;
  else
    {
      while ((tmp = strstr (name, "__")) != NULL)
        {
          if (isdigit (tmp[2]))
            break;
          else
            name = tmp + 2;
        }
d6659 1
d6662 4
a6665 4
        {
          if (sscanf (name + 2, "%x", &v) != 1)
            return name;
        }
d6667 1
a6667 1
        return name;
a6668 1
      GROW_VECT (result, result_len, 16);
d6670 1
a6670 1
        sprintf (result, "'%c'", v);
d6672 1
a6672 1
        sprintf (result, "[\"%02x\"]", v);
d6674 1
a6674 1
        sprintf (result, "[\"%04x\"]", v);
d6679 1
a6679 14
    {
      tmp = strstr (name, "__");
      if (tmp == NULL)
	tmp = strstr (name, "$");
      if (tmp != NULL)
        {
          GROW_VECT (result, result_len, tmp - name + 1);
          strncpy (result, name, tmp - name);
          result[tmp - name] = '\0';
          return result;
        }

      return name;
    }
d6684 1
a6684 1
                 enum noside noside)
d6686 1
a6686 2
  return (*exp->language_defn->la_exp_desc->evaluate_exp)
    (expect_type, exp, pos, noside);
d6691 1
a6691 1
   expression.  */
d6696 1
a6696 1
  return (*exp->language_defn->la_exp_desc->evaluate_exp)
d6701 1
a6701 1
   value it wraps.  */
d6710 1
a6710 1
                                          NULL, "internal structure");
d6713 1
a6713 1
        TYPE_NAME (val_type) = ada_type_name (type);
d6720 1
a6720 1
        ada_completed_type (ada_get_base_type (type));
d6723 1
a6723 1
        return val;
d6726 4
a6729 4
        coerce_unspec_val_to_type
        (val, ada_to_fixed_type (raw_real_type, 0,
                                 VALUE_ADDRESS (val) + VALUE_OFFSET (val),
                                 NULL));
d6742 2
a6743 2
                              ada_fixed_to_float (VALUE_TYPE (arg),
                                                  value_as_long (arg)));
d6747 1
a6747 1
        value_as_double (value_cast (builtin_type_double, value_copy (arg)));
d6758 1
a6758 1
                                     value_as_long (arg));
d6762 2
a6763 3
/* Coerce VAL as necessary for assignment to an lval of type TYPE, and
   return the converted value.  */

d6774 2
a6775 54
  if (TYPE_CODE (type2) == TYPE_CODE_PTR
      && TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      val = ada_value_ind (val);
      type2 = VALUE_TYPE (val);
    }

  if (TYPE_CODE (type2) == TYPE_CODE_ARRAY
      && TYPE_CODE (type) == TYPE_CODE_ARRAY)
    {
      if (TYPE_LENGTH (type2) != TYPE_LENGTH (type)
          || TYPE_LENGTH (TYPE_TARGET_TYPE (type2))
          != TYPE_LENGTH (TYPE_TARGET_TYPE (type2)))
        error ("Incompatible types in assignment");
      VALUE_TYPE (val) = type;
    }
  return val;
}

static struct value *
ada_value_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)
{
  struct value *val;
  struct type *type1, *type2;
  LONGEST v, v1, v2;

  COERCE_REF (arg1);
  COERCE_REF (arg2);
  type1 = base_type (check_typedef (VALUE_TYPE (arg1)));
  type2 = base_type (check_typedef (VALUE_TYPE (arg2)));

  if (TYPE_CODE (type1) != TYPE_CODE_INT
      || TYPE_CODE (type2) != TYPE_CODE_INT)
    return value_binop (arg1, arg2, op);

  switch (op)
    {
    case BINOP_MOD:
    case BINOP_DIV:
    case BINOP_REM:
      break;
    default:
      return value_binop (arg1, arg2, op);
    }

  v2 = value_as_long (arg2);
  if (v2 == 0)
    error ("second operand of %s must not be zero.", op_string (op));

  if (TYPE_UNSIGNED (type1) || op == BINOP_MOD)
    return value_binop (arg1, arg2, op);

  v1 = value_as_long (arg1);
  switch (op)
d6777 2
a6778 13
    case BINOP_DIV:
      v = v1 / v2;
      if (!TRUNCATION_TOWARDS_ZERO && v1 * (v1 % v2) < 0)
        v += v > 0 ? -1 : 1;
      break;
    case BINOP_REM:
      v = v1 % v2;
      if (v * v1 < 0)
        v -= v2;
      break;
    default:
      /* Should not reach this point.  */
      v = 0;
d6781 2
a6782 11
  val = allocate_value (type1);
  store_unsigned_integer (VALUE_CONTENTS_RAW (val),
                          TYPE_LENGTH (VALUE_TYPE (val)), v);
  return val;
}

static int
ada_value_equal (struct value *arg1, struct value *arg2)
{
  if (ada_is_direct_array_type (VALUE_TYPE (arg1))
      || ada_is_direct_array_type (VALUE_TYPE (arg2)))
d6784 5
a6788 12
      arg1 = ada_coerce_to_simple_array (arg1);
      arg2 = ada_coerce_to_simple_array (arg2);
      if (TYPE_CODE (VALUE_TYPE (arg1)) != TYPE_CODE_ARRAY
          || TYPE_CODE (VALUE_TYPE (arg2)) != TYPE_CODE_ARRAY)
        error ("Attempt to compare array with non-array");
      /* FIXME: The following works only for types whose
         representations use all bits (no padding or undefined bits)
         and do not have user-defined equality.  */
      return
        TYPE_LENGTH (VALUE_TYPE (arg1)) == TYPE_LENGTH (VALUE_TYPE (arg2))
        && memcmp (VALUE_CONTENTS (arg1), VALUE_CONTENTS (arg2),
                   TYPE_LENGTH (VALUE_TYPE (arg1))) == 0;
d6790 1
a6790 1
  return value_equal (arg1, arg2);
d6795 1
a6795 1
                     int *pos, enum noside noside)
d6798 1
d6815 2
a6816 14
        unwrap_value (evaluate_subexp_standard
                      (expect_type, exp, pos, noside));

    case OP_STRING:
      {
        struct value *result;
        *pos -= 1;
        result = evaluate_subexp_standard (expect_type, exp, pos, noside);
        /* The result type will have code OP_STRING, bashed there from 
           OP_ARRAY.  Bash it back.  */
        if (TYPE_CODE (VALUE_TYPE (result)) == TYPE_CODE_STRING)
          TYPE_CODE (VALUE_TYPE (result)) = TYPE_CODE_ARRAY;
        return result;
      }
d6823 1
a6823 1
        goto nosideret;
d6825 21
a6845 21
        {
          if (ada_is_fixed_point_type (type))
            arg1 = cast_to_fixed (type, arg1);
          else if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
            arg1 = value_cast (type, cast_from_fixed_to_double (arg1));
          else if (VALUE_LVAL (arg1) == lval_memory)
            {
              /* This is in case of the really obscure (and undocumented,
                 but apparently expected) case of (Foo) Bar.all, where Bar
                 is an integer constant and Foo is a dynamic-sized type.
                 If we don't do this, ARG1 will simply be relabeled with
                 TYPE.  */
              if (noside == EVAL_AVOID_SIDE_EFFECTS)
                return value_zero (to_static_fixed_type (type), not_lval);
              arg1 =
                ada_to_fixed_value_create
                (type, VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1), 0);
            }
          else
            arg1 = value_cast (type, arg1);
        }
d6848 6
a6853 5
    case UNOP_QUAL:
      (*pos) += 2;
      type = exp->elts[pc + 1].type;
      return ada_evaluate_subexp (type, exp, pos, noside);

d6858 3
a6860 6
        return arg1;
      if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
        arg2 = cast_to_fixed (VALUE_TYPE (arg1), arg2);
      else if (ada_is_fixed_point_type (VALUE_TYPE (arg2)))
        error
          ("Fixed-point values must be assigned to fixed-point variables");
d6862 10
a6871 2
        arg2 = coerce_for_assign (VALUE_TYPE (arg1), arg2);
      return ada_value_assign (arg1, arg2);
d6877 12
a6888 6
        goto nosideret;
      if ((ada_is_fixed_point_type (VALUE_TYPE (arg1))
           || ada_is_fixed_point_type (VALUE_TYPE (arg2)))
          && VALUE_TYPE (arg1) != VALUE_TYPE (arg2))
        error ("Operands of fixed-point addition must have the same type");
      return value_cast (VALUE_TYPE (arg1), value_add (arg1, arg2));
d6894 12
a6905 6
        goto nosideret;
      if ((ada_is_fixed_point_type (VALUE_TYPE (arg1))
           || ada_is_fixed_point_type (VALUE_TYPE (arg2)))
          && VALUE_TYPE (arg1) != VALUE_TYPE (arg2))
        error ("Operands of fixed-point subtraction must have the same type");
      return value_cast (VALUE_TYPE (arg1), value_sub (arg1, arg2));
d6912 7
a6918 22
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS
               && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
        return value_zero (VALUE_TYPE (arg1), not_lval);
      else
        {
          if (ada_is_fixed_point_type (VALUE_TYPE (arg1)))
            arg1 = cast_from_fixed_to_double (arg1);
          if (ada_is_fixed_point_type (VALUE_TYPE (arg2)))
            arg2 = cast_from_fixed_to_double (arg2);
          return ada_value_binop (arg1, arg2, op);
        }

    case BINOP_REM:
    case BINOP_MOD:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS
               && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
        return value_zero (VALUE_TYPE (arg1), not_lval);
d6920 7
a6926 15
        return ada_value_binop (arg1, arg2, op);

    case BINOP_EQUAL:
    case BINOP_NOTEQUAL:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
        tem = 0;
      else
        tem = ada_value_equal (arg1, arg2);
      if (op == BINOP_NOTEQUAL)
        tem = !tem;
      return value_from_longest (LA_BOOL_TYPE, (LONGEST) tem);
d6931 3
a6933 1
        goto nosideret;
d6935 1
a6935 1
        return value_cast (VALUE_TYPE (arg1), value_neg (arg1));
d6937 1
a6937 1
        return value_neg (arg1);
d6939 12
d6954 4
a6957 10
        {
          *pos += 4;
          goto nosideret;
        }
      else if (SYMBOL_DOMAIN (exp->elts[pc + 2].symbol) == UNDEF_DOMAIN)
        /* Only encountered when an unresolved symbol occurs in a
           context other than a function call, in which case, it is
           illegal.  */
        error ("Unexpected unresolved symbol, %s, during evaluation",
               SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));
d6959 35
a6993 14
        {
          *pos += 4;
          return value_zero
            (to_static_fixed_type
             (static_unwrap_type (SYMBOL_TYPE (exp->elts[pc + 2].symbol))),
             not_lval);
        }
      else
        {
          arg1 =
            unwrap_value (evaluate_subexp_standard
                          (expect_type, exp, pos, noside));
          return ada_to_fixed_value (arg1);
        }
d6999 1
a6999 1
         called in argvec[0] and a terminating NULL.  */
d7002 1
a7002 1
        (struct value **) alloca (sizeof (struct value *) * (nargs + 2));
d7004 15
a7018 20
      if (exp->elts[*pos].opcode == OP_VAR_VALUE
          && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)
        error ("Unexpected unresolved symbol, %s, during evaluation",
               SYMBOL_PRINT_NAME (exp->elts[pc + 5].symbol));
      else
        {
          for (tem = 0; tem <= nargs; tem += 1)
            argvec[tem] = evaluate_subexp (NULL_TYPE, exp, pos, noside);
          argvec[tem] = 0;

          if (noside == EVAL_SKIP)
            goto nosideret;
        }

      if (ada_is_packed_array_type (desc_base_type (VALUE_TYPE (argvec[0]))))
        argvec[0] = ada_coerce_to_simple_array (argvec[0]);
      else if (TYPE_CODE (VALUE_TYPE (argvec[0])) == TYPE_CODE_REF
               || (TYPE_CODE (VALUE_TYPE (argvec[0])) == TYPE_CODE_ARRAY
                   && VALUE_LVAL (argvec[0]) == lval_memory))
        argvec[0] = value_addr (argvec[0]);
d7020 3
a7022 21
      type = check_typedef (VALUE_TYPE (argvec[0]));
      if (TYPE_CODE (type) == TYPE_CODE_PTR)
        {
          switch (TYPE_CODE (check_typedef (TYPE_TARGET_TYPE (type))))
            {
            case TYPE_CODE_FUNC:
              type = check_typedef (TYPE_TARGET_TYPE (type));
              break;
            case TYPE_CODE_ARRAY:
              break;
            case TYPE_CODE_STRUCT:
              if (noside != EVAL_AVOID_SIDE_EFFECTS)
                argvec[0] = ada_value_ind (argvec[0]);
              type = check_typedef (TYPE_TARGET_TYPE (type));
              break;
            default:
              error ("cannot subscript or call something of type `%s'",
                     ada_type_name (VALUE_TYPE (argvec[0])));
              break;
            }
        }
d7024 2
a7025 52
      switch (TYPE_CODE (type))
        {
        case TYPE_CODE_FUNC:
          if (noside == EVAL_AVOID_SIDE_EFFECTS)
            return allocate_value (TYPE_TARGET_TYPE (type));
          return call_function_by_hand (argvec[0], nargs, argvec + 1);
        case TYPE_CODE_STRUCT:
          {
            int arity;

            arity = ada_array_arity (type);
            type = ada_array_element_type (type, nargs);
            if (type == NULL)
              error ("cannot subscript or call a record");
            if (arity != nargs)
              error ("wrong number of subscripts; expecting %d", arity);
            if (noside == EVAL_AVOID_SIDE_EFFECTS)
              return allocate_value (ada_aligned_type (type));
            return
              unwrap_value (ada_value_subscript
                            (argvec[0], nargs, argvec + 1));
          }
        case TYPE_CODE_ARRAY:
          if (noside == EVAL_AVOID_SIDE_EFFECTS)
            {
              type = ada_array_element_type (type, nargs);
              if (type == NULL)
                error ("element type of array unknown");
              else
                return allocate_value (ada_aligned_type (type));
            }
          return
            unwrap_value (ada_value_subscript
                          (ada_coerce_to_simple_array (argvec[0]),
                           nargs, argvec + 1));
        case TYPE_CODE_PTR:     /* Pointer to array */
          type = to_fixed_array_type (TYPE_TARGET_TYPE (type), NULL, 1);
          if (noside == EVAL_AVOID_SIDE_EFFECTS)
            {
              type = ada_array_element_type (type, nargs);
              if (type == NULL)
                error ("element type of array unknown");
              else
                return allocate_value (ada_aligned_type (type));
            }
          return
            unwrap_value (ada_value_ptr_subscript (argvec[0], type,
                                                   nargs, argvec + 1));

        default:
          error ("Internal error in evaluate_subexp");
        }
d7027 2
a7028 56
    case TERNOP_SLICE:
      {
        struct value *array = evaluate_subexp (NULL_TYPE, exp, pos, noside);
        struct value *low_bound_val =
          evaluate_subexp (NULL_TYPE, exp, pos, noside);
        LONGEST low_bound = pos_atr (low_bound_val);
        LONGEST high_bound
          = pos_atr (evaluate_subexp (NULL_TYPE, exp, pos, noside));
        if (noside == EVAL_SKIP)
          goto nosideret;

        /* If this is a reference to an aligner type, then remove all
           the aligners.  */
        if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_REF
            && ada_is_aligner_type (TYPE_TARGET_TYPE (VALUE_TYPE (array))))
          TYPE_TARGET_TYPE (VALUE_TYPE (array)) =
            ada_aligned_type (TYPE_TARGET_TYPE (VALUE_TYPE (array)));

        if (ada_is_packed_array_type (VALUE_TYPE (array)))
          error ("cannot slice a packed array");

        /* If this is a reference to an array or an array lvalue,
           convert to a pointer.  */
        if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_REF
            || (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_ARRAY
                && VALUE_LVAL (array) == lval_memory))
          array = value_addr (array);

        if (noside == EVAL_AVOID_SIDE_EFFECTS
            && ada_is_array_descriptor_type (check_typedef 
					     (VALUE_TYPE (array))))
          return empty_array (ada_type_of_array (array, 0), low_bound);

        array = ada_coerce_to_simple_array_ptr (array);

        if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_PTR)
          {
            if (high_bound < low_bound || noside == EVAL_AVOID_SIDE_EFFECTS)
              return empty_array (TYPE_TARGET_TYPE (VALUE_TYPE (array)),
                                  low_bound);
            else
              {
                struct type *arr_type0 =
                  to_fixed_array_type (TYPE_TARGET_TYPE (VALUE_TYPE (array)),
                                       NULL, 1);
                return ada_value_slice_ptr (array, arr_type0,
                                            (int) low_bound, (int) high_bound);
              }
          }
        else if (noside == EVAL_AVOID_SIDE_EFFECTS)
          return array;
        else if (high_bound < low_bound)
          return empty_array (VALUE_TYPE (array), low_bound);
        else
          return ada_value_slice (array, (int) low_bound, (int) high_bound);
      }
d7030 21
a7050 7
    case UNOP_IN_RANGE:
      (*pos) += 2;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      type = exp->elts[pc + 1].type;

      if (noside == EVAL_SKIP)
        goto nosideret;
d7053 45
a7097 17
        {
        default:
          lim_warning ("Membership test incompletely implemented; "
                       "always returns true", 0);
          return value_from_longest (builtin_type_int, (LONGEST) 1);

        case TYPE_CODE_RANGE:
          arg2 = value_from_longest (builtin_type_int, TYPE_LOW_BOUND (type));
          arg3 = value_from_longest (builtin_type_int,
                                     TYPE_HIGH_BOUND (type));
          return
            value_from_longest (builtin_type_int,
                                (value_less (arg1, arg3)
                                 || value_equal (arg1, arg3))
                                && (value_less (arg2, arg1)
                                    || value_equal (arg2, arg1)));
        }
d7099 3
a7101 4
    case BINOP_IN_BOUNDS:
      (*pos) += 2;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d7103 1
a7103 177
      if (noside == EVAL_SKIP)
        goto nosideret;

      if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (builtin_type_int, not_lval);

      tem = longest_to_int (exp->elts[pc + 1].longconst);

      if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg2)))
        error ("invalid dimension number to '%s", "range");

      arg3 = ada_array_bound (arg2, tem, 1);
      arg2 = ada_array_bound (arg2, tem, 0);

      return
        value_from_longest (builtin_type_int,
                            (value_less (arg1, arg3)
                             || value_equal (arg1, arg3))
                            && (value_less (arg2, arg1)
                                || value_equal (arg2, arg1)));

    case TERNOP_IN_RANGE:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg3 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      if (noside == EVAL_SKIP)
        goto nosideret;

      return
        value_from_longest (builtin_type_int,
                            (value_less (arg1, arg3)
                             || value_equal (arg1, arg3))
                            && (value_less (arg2, arg1)
                                || value_equal (arg2, arg1)));

    case OP_ATR_FIRST:
    case OP_ATR_LAST:
    case OP_ATR_LENGTH:
      {
        struct type *type_arg;
        if (exp->elts[*pos].opcode == OP_TYPE)
          {
            evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
            arg1 = NULL;
            type_arg = exp->elts[pc + 2].type;
          }
        else
          {
            arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
            type_arg = NULL;
          }

        if (exp->elts[*pos].opcode != OP_LONG)
          error ("illegal operand to '%s", ada_attribute_name (op));
        tem = longest_to_int (exp->elts[*pos + 2].longconst);
        *pos += 4;

        if (noside == EVAL_SKIP)
          goto nosideret;

        if (type_arg == NULL)
          {
            arg1 = ada_coerce_ref (arg1);

            if (ada_is_packed_array_type (VALUE_TYPE (arg1)))
              arg1 = ada_coerce_to_simple_array (arg1);

            if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg1)))
              error ("invalid dimension number to '%s",
                     ada_attribute_name (op));

            if (noside == EVAL_AVOID_SIDE_EFFECTS)
              {
                type = ada_index_type (VALUE_TYPE (arg1), tem);
                if (type == NULL)
                  error
                    ("attempt to take bound of something that is not an array");
                return allocate_value (type);
              }

            switch (op)
              {
              default:          /* Should never happen.  */
                error ("unexpected attribute encountered");
              case OP_ATR_FIRST:
                return ada_array_bound (arg1, tem, 0);
              case OP_ATR_LAST:
                return ada_array_bound (arg1, tem, 1);
              case OP_ATR_LENGTH:
                return ada_array_length (arg1, tem);
              }
          }
        else if (discrete_type_p (type_arg))
          {
            struct type *range_type;
            char *name = ada_type_name (type_arg);
            range_type = NULL;
            if (name != NULL && TYPE_CODE (type_arg) != TYPE_CODE_ENUM)
              range_type =
                to_fixed_range_type (name, NULL, TYPE_OBJFILE (type_arg));
            if (range_type == NULL)
              range_type = type_arg;
            switch (op)
              {
              default:
                error ("unexpected attribute encountered");
              case OP_ATR_FIRST:
                return discrete_type_low_bound (range_type);
              case OP_ATR_LAST:
                return discrete_type_high_bound (range_type);
              case OP_ATR_LENGTH:
                error ("the 'length attribute applies only to array types");
              }
          }
        else if (TYPE_CODE (type_arg) == TYPE_CODE_FLT)
          error ("unimplemented type attribute");
        else
          {
            LONGEST low, high;

            if (ada_is_packed_array_type (type_arg))
              type_arg = decode_packed_array_type (type_arg);

            if (tem < 1 || tem > ada_array_arity (type_arg))
              error ("invalid dimension number to '%s",
                     ada_attribute_name (op));

            type = ada_index_type (type_arg, tem);
            if (type == NULL)
              error
                ("attempt to take bound of something that is not an array");
            if (noside == EVAL_AVOID_SIDE_EFFECTS)
              return allocate_value (type);

            switch (op)
              {
              default:
                error ("unexpected attribute encountered");
              case OP_ATR_FIRST:
                low = ada_array_bound_from_type (type_arg, tem, 0, &type);
                return value_from_longest (type, low);
              case OP_ATR_LAST:
                high = ada_array_bound_from_type (type_arg, tem, 1, &type);
                return value_from_longest (type, high);
              case OP_ATR_LENGTH:
                low = ada_array_bound_from_type (type_arg, tem, 0, &type);
                high = ada_array_bound_from_type (type_arg, tem, 1, NULL);
                return value_from_longest (type, high - low + 1);
              }
          }
      }

    case OP_ATR_TAG:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;

      if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (ada_tag_type (arg1), not_lval);

      return ada_value_tag (arg1);

    case OP_ATR_MIN:
    case OP_ATR_MAX:
      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (VALUE_TYPE (arg1), not_lval);
      else
        return value_binop (arg1, arg2,
                            op == OP_ATR_MIN ? BINOP_MIN : BINOP_MAX);

    case OP_ATR_MODULUS:
d7105 46
a7150 11
        struct type *type_arg = exp->elts[pc + 2].type;
        evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);

        if (noside == EVAL_SKIP)
          goto nosideret;

        if (!ada_is_modular_type (type_arg))
          error ("'modulus must be applied to modular type");

        return value_from_longest (TYPE_TARGET_TYPE (type_arg),
                                   ada_modulus (type_arg));
d7153 291
a7443 33

    case OP_ATR_POS:
      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (builtin_type_ada_int, not_lval);
      else
        return value_pos_atr (arg1);

    case OP_ATR_SIZE:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (builtin_type_ada_int, not_lval);
      else
        return value_from_longest (builtin_type_ada_int,
                                   TARGET_CHAR_BIT
                                   * TYPE_LENGTH (VALUE_TYPE (arg1)));

    case OP_ATR_VAL:
      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      type = exp->elts[pc + 2].type;
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
        return value_zero (type, not_lval);
      else
        return value_val_atr (type, arg1);

d7448 4
a7451 1
        goto nosideret;
d7453 1
a7453 1
        return value_zero (VALUE_TYPE (arg1), not_lval);
d7455 1
a7455 1
        return value_binop (arg1, arg2, op);
d7460 3
a7462 1
        goto nosideret;
d7464 1
a7464 1
        return arg1;
d7469 1
a7469 1
        goto nosideret;
d7471 1
a7471 1
        return value_neg (arg1);
d7473 1
a7473 1
        return arg1;
d7477 1
a7477 1
        expect_type = TYPE_TARGET_TYPE (check_typedef (expect_type));
d7480 1
a7480 1
        goto nosideret;
d7483 25
a7507 25
        {
          if (ada_is_array_descriptor_type (type))
            /* GDB allows dereferencing GNAT array descriptors.  */
            {
              struct type *arrType = ada_type_of_array (arg1, 0);
              if (arrType == NULL)
                error ("Attempt to dereference null array pointer.");
              return value_at_lazy (arrType, 0, NULL);
            }
          else if (TYPE_CODE (type) == TYPE_CODE_PTR
                   || TYPE_CODE (type) == TYPE_CODE_REF
                   /* In C you can dereference an array to get the 1st elt.  */
                   || TYPE_CODE (type) == TYPE_CODE_ARRAY)
            return
              value_zero
              (to_static_fixed_type
               (ada_aligned_type (check_typedef (TYPE_TARGET_TYPE (type)))),
               lval_memory);
          else if (TYPE_CODE (type) == TYPE_CODE_INT)
            /* GDB allows dereferencing an int.  */
            return value_zero (builtin_type_int, lval_memory);
          else
            error ("Attempt to take contents of a non-pointer value.");
        }
      arg1 = ada_coerce_ref (arg1);     /* FIXME: What is this for?? */
d7510 3
a7512 3
      if (ada_is_array_descriptor_type (type))
        /* GDB allows dereferencing GNAT array descriptors.  */
        return ada_coerce_to_simple_array (arg1);
d7514 1
a7514 1
        return ada_value_ind (arg1);
d7521 1
a7521 1
        goto nosideret;
d7523 10
a7532 26
        {
          struct type *type1 = VALUE_TYPE (arg1);
          if (ada_is_tagged_type (type1, 1))
            {
              type = ada_lookup_struct_elt_type (type1,
                                                 &exp->elts[pc + 2].string,
                                                 1, 1, NULL);
              if (type == NULL)
                /* In this case, we assume that the field COULD exist
                   in some extension of the type.  Return an object of 
                   "type" void, which will match any formal 
                   (see ada_type_match). */
                return value_zero (builtin_type_void, lval_memory);
            }
          else
            type =
              ada_lookup_struct_elt_type (type1, &exp->elts[pc + 2].string, 1,
                                          0, NULL);

          return value_zero (ada_aligned_type (type), lval_memory);
        }
      else
        return
          ada_to_fixed_value (unwrap_value
                              (ada_value_struct_elt
                               (arg1, &exp->elts[pc + 2].string, "record")));
d7534 2
a7535 2
      /* The value is not supposed to be used.  This is here to make it
         easier to accommodate expressions that contain types.  */
d7538 1
a7538 1
        goto nosideret;
d7540 1
a7540 1
        return allocate_value (builtin_type_void);
d7542 19
a7560 1
        error ("Attempt to use a type name as an expression");
d7568 1
a7568 1
                                /* Fixed point */
d7572 1
a7572 1
   Otherwise, return NULL.  */
d7584 1
a7584 1
        return NULL;
d7586 1
a7586 1
        return tail + 5;
d7594 1
a7594 1
/* Returns non-zero iff TYPE represents an Ada fixed-point type.  */
a7601 9
/* Return non-zero iff TYPE represents a System.Address type.  */

int
ada_is_system_address_type (struct type *type)
{
  return (TYPE_NAME (type)
          && strcmp (TYPE_NAME (type), "system__address") == 0);
}

d7604 1
a7604 1
   delta cannot be determined.  */
d7619 1
a7619 1
   factor ('SMALL value) associated with the type.  */
d7640 1
a7640 1
   type TYPE, return its floating-point equivalent.  */
d7648 2
a7649 2
/* The representation of a fixed-point value of type TYPE
   corresponding to the value X.  */
d7658 1
a7658 1
                                /* VAX floating formats */
d7661 1
a7661 2
   types.  */

d7670 2
a7671 2
        || TYPE_CODE (type) == TYPE_CODE_RANGE)
    && strncmp (ada_type_name (type) + name_len - 6, "___XF", 5) == 0;
d7675 1
a7675 2
   ada_is_vax_floating_point.  */

d7682 1
a7682 1
/* A value representing the special debugging function that outputs
d7684 1
a7684 2
   ada_is_vax_floating_type (TYPE).  */

d7702 1
a7702 1
                                /* Range types */
d7708 1
a7708 1
   not alter *PX and *PNEW_K if unsuccessful.  */
d7712 1
a7712 1
                    int *pnew_k)
d7750 1
a7750 2
   otherwise causes an error with message ERR_MSG.  */

d7754 2
a7755 1
  struct ada_symbol_info *syms;
d7758 3
a7760 2
  nsyms = ada_lookup_symbol_list (name, get_selected_block (0), VAR_DOMAIN,
                                  &syms);
d7765 1
a7765 1
        return 0;
d7767 1
a7767 1
        error ("%s", err_msg);
d7770 1
a7770 1
  return value_of_variable (syms[0].sym, syms[0].block);
d7774 2
a7775 3
   no such variable found, returns 0, and sets *FLAG to 0.  If
   successful, sets *FLAG to 1.  */

d7777 1
a7777 1
get_int_var_value (char *name, int *flag)
d7779 1
a7779 1
  struct value *var_val = get_var_value (name, 0);
d7784 1
a7784 1
        *flag = 0;
d7790 1
a7790 1
        *flag = 1;
d7798 1
a7798 1
   from NAME according to the GNAT range encoding conventions.
d7802 1
a7802 1
   the named range type.  */
d7809 1
d7841 15
a7855 21
        {
          if (!ada_scan_number (bounds_str, n, &L, &n)
              && !scan_discrim_bound (bounds_str, n, dval, &L, &n))
            return raw_type;
          if (bounds_str[n] == '_')
            n += 2;
          else if (bounds_str[n] == '.')        /* FIXME? SGI Workshop kludge.  */
            n += 1;
          subtype_info += 1;
        }
      else
        {
          int ok;
          strcpy (name_buf + prefix_len, "___L");
          L = get_int_var_value (name_buf, &ok);
          if (!ok)
            {
              lim_warning ("Unknown lower bound, using 1.", 1);
              L = 1;
            }
        }
d7858 10
a7867 16
        {
          if (!ada_scan_number (bounds_str, n, &U, &n)
              && !scan_discrim_bound (bounds_str, n, dval, &U, &n))
            return raw_type;
        }
      else
        {
          int ok;
          strcpy (name_buf + prefix_len, "___U");
          U = get_int_var_value (name_buf, &ok);
          if (!ok)
            {
              lim_warning ("Unknown upper bound, using %ld.", (long) L);
              U = L;
            }
        }
d7870 1
a7870 1
        objfile = TYPE_OBJFILE (base_type);
d7877 1
a7877 2
/* True iff NAME is the name of a range type.  */

d7885 1
a7885 3
                                /* Modular types */

/* True iff TYPE is an Ada modular type.  */
d7887 1
d7891 3
a7893 1
  struct type *subranged_type = base_type (type);
d7896 2
a7897 2
          && TYPE_CODE (subranged_type) != TYPE_CODE_ENUM
          && TYPE_UNSIGNED (subranged_type));
d7900 1
a7900 2
/* Assuming ada_is_modular_type (TYPE), the modulus of TYPE.  */

a7906 51
                                /* Operators */
/* Information about operators given special treatment in functions
   below.  */
/* Format: OP_DEFN (<operator>, <operator length>, <# args>, <binop>).  */

#define ADA_OPERATORS \
    OP_DEFN (OP_VAR_VALUE, 4, 0, 0) \
    OP_DEFN (BINOP_IN_BOUNDS, 3, 2, 0) \
    OP_DEFN (TERNOP_IN_RANGE, 1, 3, 0) \
    OP_DEFN (OP_ATR_FIRST, 1, 2, 0) \
    OP_DEFN (OP_ATR_LAST, 1, 2, 0) \
    OP_DEFN (OP_ATR_LENGTH, 1, 2, 0) \
    OP_DEFN (OP_ATR_IMAGE, 1, 2, 0) \
    OP_DEFN (OP_ATR_MAX, 1, 3, 0) \
    OP_DEFN (OP_ATR_MIN, 1, 3, 0) \
    OP_DEFN (OP_ATR_MODULUS, 1, 1, 0) \
    OP_DEFN (OP_ATR_POS, 1, 2, 0) \
    OP_DEFN (OP_ATR_SIZE, 1, 1, 0) \
    OP_DEFN (OP_ATR_TAG, 1, 1, 0) \
    OP_DEFN (OP_ATR_VAL, 1, 2, 0) \
    OP_DEFN (UNOP_QUAL, 3, 1, 0) \
    OP_DEFN (UNOP_IN_RANGE, 3, 1, 0)

static void
ada_operator_length (struct expression *exp, int pc, int *oplenp, int *argsp)
{
  switch (exp->elts[pc - 1].opcode)
    {
    default:
      operator_length_standard (exp, pc, oplenp, argsp);
      break;

#define OP_DEFN(op, len, args, binop) \
    case op: *oplenp = len; *argsp = args; break;
      ADA_OPERATORS;
#undef OP_DEFN
    }
}

static char *
ada_op_name (enum exp_opcode opcode)
{
  switch (opcode)
    {
    default:
      return op_name_standard (opcode);
#define OP_DEFN(op, len, args, binop) case op: return #op;
      ADA_OPERATORS;
#undef OP_DEFN
    }
}
a7907 3
/* As for operator_length, but assumes PC is pointing at the first
   element of the operator, and gives meaningful results only for the 
   Ada-specific operators.  */
d7909 1
a7909 163
static void
ada_forward_operator_length (struct expression *exp, int pc,
                             int *oplenp, int *argsp)
{
  switch (exp->elts[pc].opcode)
    {
    default:
      *oplenp = *argsp = 0;
      break;
#define OP_DEFN(op, len, args, binop) \
    case op: *oplenp = len; *argsp = args; break;
      ADA_OPERATORS;
#undef OP_DEFN
    }
}

static int
ada_dump_subexp_body (struct expression *exp, struct ui_file *stream, int elt)
{
  enum exp_opcode op = exp->elts[elt].opcode;
  int oplen, nargs;
  int pc = elt;
  int i;

  ada_forward_operator_length (exp, elt, &oplen, &nargs);

  switch (op)
    {
      /* Ada attributes ('Foo).  */
    case OP_ATR_FIRST:
    case OP_ATR_LAST:
    case OP_ATR_LENGTH:
    case OP_ATR_IMAGE:
    case OP_ATR_MAX:
    case OP_ATR_MIN:
    case OP_ATR_MODULUS:
    case OP_ATR_POS:
    case OP_ATR_SIZE:
    case OP_ATR_TAG:
    case OP_ATR_VAL:
      break;

    case UNOP_IN_RANGE:
    case UNOP_QUAL:
      fprintf_filtered (stream, "Type @@");
      gdb_print_host_address (exp->elts[pc + 1].type, stream);
      fprintf_filtered (stream, " (");
      type_print (exp->elts[pc + 1].type, NULL, stream, 0);
      fprintf_filtered (stream, ")");
      break;
    case BINOP_IN_BOUNDS:
      fprintf_filtered (stream, " (%d)", (int) exp->elts[pc + 2].longconst);
      break;
    case TERNOP_IN_RANGE:
      break;

    default:
      return dump_subexp_body_standard (exp, stream, elt);
    }

  elt += oplen;
  for (i = 0; i < nargs; i += 1)
    elt = dump_subexp (exp, stream, elt);

  return elt;
}

/* The Ada extension of print_subexp (q.v.).  */

static void
ada_print_subexp (struct expression *exp, int *pos,
                  struct ui_file *stream, enum precedence prec)
{
  int oplen, nargs;
  int pc = *pos;
  enum exp_opcode op = exp->elts[pc].opcode;

  ada_forward_operator_length (exp, pc, &oplen, &nargs);

  switch (op)
    {
    default:
      print_subexp_standard (exp, pos, stream, prec);
      return;

    case OP_VAR_VALUE:
      *pos += oplen;
      fputs_filtered (SYMBOL_NATURAL_NAME (exp->elts[pc + 2].symbol), stream);
      return;

    case BINOP_IN_BOUNDS:
      *pos += oplen;
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered (" in ", stream);
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered ("'range", stream);
      if (exp->elts[pc + 1].longconst > 1)
        fprintf_filtered (stream, "(%ld)",
                          (long) exp->elts[pc + 1].longconst);
      return;

    case TERNOP_IN_RANGE:
      *pos += oplen;
      if (prec >= PREC_EQUAL)
        fputs_filtered ("(", stream);
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered (" in ", stream);
      print_subexp (exp, pos, stream, PREC_EQUAL);
      fputs_filtered (" .. ", stream);
      print_subexp (exp, pos, stream, PREC_EQUAL);
      if (prec >= PREC_EQUAL)
        fputs_filtered (")", stream);
      return;

    case OP_ATR_FIRST:
    case OP_ATR_LAST:
    case OP_ATR_LENGTH:
    case OP_ATR_IMAGE:
    case OP_ATR_MAX:
    case OP_ATR_MIN:
    case OP_ATR_MODULUS:
    case OP_ATR_POS:
    case OP_ATR_SIZE:
    case OP_ATR_TAG:
    case OP_ATR_VAL:
      *pos += oplen;
      if (exp->elts[*pos].opcode == OP_TYPE)
        {
          if (TYPE_CODE (exp->elts[*pos + 1].type) != TYPE_CODE_VOID)
            LA_PRINT_TYPE (exp->elts[*pos + 1].type, "", stream, 0, 0);
          *pos += 3;
        }
      else
        print_subexp (exp, pos, stream, PREC_SUFFIX);
      fprintf_filtered (stream, "'%s", ada_attribute_name (op));
      if (nargs > 1)
        {
          int tem;
          for (tem = 1; tem < nargs; tem += 1)
            {
              fputs_filtered ((tem == 1) ? " (" : ", ", stream);
              print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);
            }
          fputs_filtered (")", stream);
        }
      return;

    case UNOP_QUAL:
      *pos += oplen;
      type_print (exp->elts[pc + 1].type, "", stream, 0);
      fputs_filtered ("'(", stream);
      print_subexp (exp, pos, stream, PREC_PREFIX);
      fputs_filtered (")", stream);
      return;

    case UNOP_IN_RANGE:
      *pos += oplen;
      print_subexp (exp, pos, stream, PREC_SUFFIX);
      fputs_filtered (" in ", stream);
      LA_PRINT_TYPE (exp->elts[pc + 1].type, "", stream, 1, 0);
      return;
    }
}
d7943 2
a7944 3
  {".all", UNOP_IND, PREC_SUFFIX, 1},
  {"'access", UNOP_ADDR, PREC_SUFFIX, 1},
  {"'size", OP_ATR_SIZE, PREC_SUFFIX, 1},
d7948 1
a7948 1
                        /* Assorted Types and Interfaces */
d7964 1
d7974 1
a7974 1
    /* The following types are carried over from C for convenience.  */
d7992 1
a7992 2
/* Not really used, but needed in the ada_language_defn.  */

a7998 15
static int
parse (void)
{
  warnings_issued = 0;
  return ada_parse ();
}

static const struct exp_descriptor ada_exp_descriptor = {
  ada_print_subexp,
  ada_operator_length,
  ada_op_name,
  ada_dump_subexp_body,
  ada_evaluate_subexp
};

d8000 4
a8003 2
  "ada",                        /* Language name */
  language_ada,
d8007 3
a8009 9
  case_sensitive_on,            /* Yes, Ada is case-insensitive, but
                                   that's not quite what this means.  */
#ifdef GNAT_GDB
  ada_lookup_symbol,
  ada_lookup_minimal_symbol,
#endif /* GNAT_GDB */
  array_row_major,
  &ada_exp_descriptor,
  parse,
d8011 27
a8037 17
  resolve,
  ada_printchar,                /* Print a character constant */
  ada_printstr,                 /* Function to print string constant */
  emit_char,                    /* Function to print single char (not used) */
  ada_create_fundamental_type,  /* Create fundamental type in this language */
  ada_print_type,               /* Print a type using appropriate syntax */
  ada_val_print,                /* Print a value using appropriate syntax */
  ada_value_print,              /* Print a top-level value */
  NULL,                         /* Language specific skip_trampoline */
  NULL,                         /* value_of_this */
  ada_lookup_symbol_nonlocal,   /* Looking up non-local symbols.  */
  basic_lookup_transparent_type,        /* lookup_transparent_type */
  ada_la_decode,                /* Language specific symbol demangler */
  NULL,                         /* Language specific class_name_from_physname */
  ada_op_print_tab,             /* expression operators for printing */
  0,                            /* c-style arrays */
  1,                            /* String lower bound */
d8039 1
a8039 5
  ada_get_gdb_completer_word_break_characters,
#ifdef GNAT_GDB
  ada_translate_error_message,  /* Substitute Ada-specific terminology
                                   in errors and warnings.  */
#endif /* GNAT_GDB */
d8043 2
a8044 2
static void
build_ada_types (struct gdbarch *current_gdbarch)
d8048 1
a8048 1
               0, "integer", (struct objfile *) NULL);
d8051 1
a8051 1
               0, "long_integer", (struct objfile *) NULL);
d8054 1
a8054 1
               0, "short_integer", (struct objfile *) NULL);
d8057 1
a8057 1
               0, "character", (struct objfile *) NULL);
d8060 1
a8060 1
               0, "float", (struct objfile *) NULL);
d8063 1
a8063 1
               0, "long_float", (struct objfile *) NULL);
d8066 1
a8066 1
               0, "long_long_integer", (struct objfile *) NULL);
d8069 1
a8069 1
               0, "long_long_float", (struct objfile *) NULL);
d8072 1
a8072 1
               0, "natural", (struct objfile *) NULL);
d8075 1
a8075 1
               0, "positive", (struct objfile *) NULL);
d8080 1
a8080 1
                                    (struct objfile *) NULL));
a8081 1
}
a8082 6
void
_initialize_ada_language (void)
{

  build_ada_types (current_gdbarch);
  gdbarch_data_register_post_init (build_ada_types);
d8085 5
d8091 5
a8095 14
#ifdef GNAT_GDB
  add_setshow_uinteger_cmd ("varsize-limit", class_support,
			    &varsize_limit, "\
Set the maximum number of bytes allowed in a dynamic-sized object.", "\
Show the maximum number of bytes allowed in a dynamic-sized object.",
			    NULL, NULL, &setlist, &showlist);
  obstack_init (&cache_space);
#endif /* GNAT_GDB */

  obstack_init (&symbol_list_obstack);

  decoded_names_store = htab_create_alloc
    (256, htab_hash_string, (int (*)(const void *, const void *)) streq,
     NULL, xcalloc, xfree);
d8098 1
d8133 1
a8133 1
         reconstruction work, this should probably become an error.  */
d8135 2
a8136 2
                        TARGET_INT_BIT / TARGET_CHAR_BIT,
                        0, "<?type?>", objfile);
d8141 2
a8142 2
                        TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                        0, "void", objfile);
d8146 2
a8147 2
                        TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                        0, "character", objfile);
d8151 2
a8152 2
                        TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                        0, "signed char", objfile);
d8156 2
a8157 2
                        TARGET_CHAR_BIT / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned char", objfile);
d8161 2
a8162 2
                        TARGET_SHORT_BIT / TARGET_CHAR_BIT,
                        0, "short_integer", objfile);
d8166 2
a8167 2
                        TARGET_SHORT_BIT / TARGET_CHAR_BIT,
                        0, "short_integer", objfile);
d8171 2
a8172 2
                        TARGET_SHORT_BIT / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned short", objfile);
d8176 2
a8177 2
                        TARGET_INT_BIT / TARGET_CHAR_BIT,
                        0, "integer", objfile);
d8180 1
a8180 1
      type = init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT, 0, "integer", objfile);        /* FIXME -fnf */
d8184 2
a8185 2
                        TARGET_INT_BIT / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned int", objfile);
d8189 2
a8190 2
                        TARGET_LONG_BIT / TARGET_CHAR_BIT,
                        0, "long_integer", objfile);
d8194 2
a8195 2
                        TARGET_LONG_BIT / TARGET_CHAR_BIT,
                        0, "long_integer", objfile);
d8199 2
a8200 2
                        TARGET_LONG_BIT / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned long", objfile);
d8204 2
a8205 2
                        TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
                        0, "long_long_integer", objfile);
d8209 2
a8210 2
                        TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
                        0, "long_long_integer", objfile);
d8214 2
a8215 2
                        TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
                        TYPE_FLAG_UNSIGNED, "unsigned long long", objfile);
d8219 2
a8220 2
                        TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
                        0, "float", objfile);
d8224 2
a8225 2
                        TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
                        0, "long_float", objfile);
d8229 2
a8230 2
                        TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
                        0, "long_long_float", objfile);
d8242 1
a8242 1
           s->dirname ? s->dirname : "?", s->filename ? s->filename : "?");
d8248 4
a8251 4
        {
          struct linetable_entry *e = s->linetable->item + i;
          fprintf (stderr, "    %4ld: %8lx\n", (long) e->line, (long) e->pc);
        }
@


1.35.4.2
log
@Merge from mainline.
@
text
@d195 2
a283 5

static void ada_language_arch_info (struct gdbarch *,
				    struct language_arch_info *);

static void check_size (const struct type *);
a755 1

d2199 1
a2199 1
ada_value_slice_ptr (struct value *array_ptr, struct type *type,
d2202 1
a2202 1
  CORE_ADDR base = value_as_address (array_ptr)
d2205 2
a2206 2
  struct type *index_type =
    create_range_type (NULL, TYPE_TARGET_TYPE (TYPE_INDEX_TYPE (type)),
d2208 1
a2208 1
  struct type *slice_type =
d2218 1
a2218 1
  struct type *index_type =
d2220 1
a2220 1
  struct type *slice_type =
d2222 1
a2222 1
  return value_cast (slice_type, value_slice (array, low, high - low + 1));
d2442 1
a2442 1
      value_from_longest (builtin_type_int,
d2455 1
a2455 1
  struct type *index_type =
a6181 14

				/* Exception-related */

int
ada_is_exception_sym (struct symbol *sym)
{
  char *type_name = type_name_no_tag (SYMBOL_TYPE (sym));

  return (SYMBOL_CLASS (sym) != LOC_TYPEDEF
          && SYMBOL_CLASS (sym) != LOC_BLOCK
          && SYMBOL_CLASS (sym) != LOC_CONST
          && type_name != NULL && strcmp (type_name, "exception") == 0);
}

d6433 19
d6576 1
a6576 1
#endif /* GNAT_GDB */
d7723 3
a7725 2
      off = align_value (off, field_alignment (type, f))
	+ TYPE_FIELD_BITPOS (type, f);
d8351 1
a8351 1
  return value_from_longest (builtin_type_int, pos_atr (arg));
d9069 1
a9069 1
            && ada_is_array_descriptor_type (check_typedef
d9086 1
a9086 2
                                            (int) low_bound, 
					    (int) high_bound);
d9327 1
a9327 1
        return value_zero (builtin_type_int, not_lval);
d9336 1
a9336 1
        return value_zero (builtin_type_int, not_lval);
d9338 1
a9338 1
        return value_from_longest (builtin_type_int,
d10091 173
a10263 1
				/* Fundamental Ada Types */
d10346 1
a10346 3
      type = init_type (TYPE_CODE_INT, TARGET_INT_BIT /
			TARGET_CHAR_BIT, 
			0, "integer", objfile);        /* FIXME -fnf */
a10401 132
enum ada_primitive_types {
  ada_primitive_type_int,
  ada_primitive_type_long,
  ada_primitive_type_short,
  ada_primitive_type_char,
  ada_primitive_type_float,
  ada_primitive_type_double,
  ada_primitive_type_void,
  ada_primitive_type_long_long,
  ada_primitive_type_long_double,
  ada_primitive_type_natural,
  ada_primitive_type_positive,
  ada_primitive_type_system_address,
  nr_ada_primitive_types
};

static void
ada_language_arch_info (struct gdbarch *current_gdbarch,
			struct language_arch_info *lai)
{
  const struct builtin_type *builtin = builtin_type (current_gdbarch);
  lai->primitive_type_vector
    = GDBARCH_OBSTACK_CALLOC (current_gdbarch, nr_ada_primitive_types + 1,
			      struct type *);
  lai->primitive_type_vector [ada_primitive_type_int] =
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
               0, "integer", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_long] =
    init_type (TYPE_CODE_INT, TARGET_LONG_BIT / TARGET_CHAR_BIT,
               0, "long_integer", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_short] =
    init_type (TYPE_CODE_INT, TARGET_SHORT_BIT / TARGET_CHAR_BIT,
               0, "short_integer", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_char] =
    init_type (TYPE_CODE_INT, TARGET_CHAR_BIT / TARGET_CHAR_BIT,
               0, "character", (struct objfile *) NULL);
  lai->string_char_type = builtin->builtin_char;
  lai->primitive_type_vector [ada_primitive_type_float] =
    init_type (TYPE_CODE_FLT, TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
               0, "float", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_double] =
    init_type (TYPE_CODE_FLT, TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
               0, "long_float", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_long_long] =
    init_type (TYPE_CODE_INT, TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
               0, "long_long_integer", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_long_double] =
    init_type (TYPE_CODE_FLT, TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
               0, "long_long_float", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_natural] =
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
               0, "natural", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_positive] =
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT,
               0, "positive", (struct objfile *) NULL);
  lai->primitive_type_vector [ada_primitive_type_void] = builtin->builtin_void;

  lai->primitive_type_vector [ada_primitive_type_system_address] =
    lookup_pointer_type (init_type (TYPE_CODE_VOID, 1, 0, "void",
                                    (struct objfile *) NULL));
  TYPE_NAME (lai->primitive_type_vector [ada_primitive_type_system_address])
    = "system__address";
}

				/* Language vector */

/* Not really used, but needed in the ada_language_defn.  */

static void
emit_char (int c, struct ui_file *stream, int quoter)
{
  ada_emit_char (c, stream, quoter, 1);
}

static int
parse (void)
{
  warnings_issued = 0;
  return ada_parse ();
}

static const struct exp_descriptor ada_exp_descriptor = {
  ada_print_subexp,
  ada_operator_length,
  ada_op_name,
  ada_dump_subexp_body,
  ada_evaluate_subexp
};

const struct language_defn ada_language_defn = {
  "ada",                        /* Language name */
  language_ada,
  NULL,
  range_check_off,
  type_check_off,
  case_sensitive_on,            /* Yes, Ada is case-insensitive, but
                                   that's not quite what this means.  */
#ifdef GNAT_GDB
  ada_lookup_symbol,
  ada_lookup_minimal_symbol,
#endif /* GNAT_GDB */
  array_row_major,
  &ada_exp_descriptor,
  parse,
  ada_error,
  resolve,
  ada_printchar,                /* Print a character constant */
  ada_printstr,                 /* Function to print string constant */
  emit_char,                    /* Function to print single char (not used) */
  ada_create_fundamental_type,  /* Create fundamental type in this language */
  ada_print_type,               /* Print a type using appropriate syntax */
  ada_val_print,                /* Print a value using appropriate syntax */
  ada_value_print,              /* Print a top-level value */
  NULL,                         /* Language specific skip_trampoline */
  NULL,                         /* value_of_this */
  ada_lookup_symbol_nonlocal,   /* Looking up non-local symbols.  */
  basic_lookup_transparent_type,        /* lookup_transparent_type */
  ada_la_decode,                /* Language specific symbol demangler */
  NULL,                         /* Language specific class_name_from_physname */
  ada_op_print_tab,             /* expression operators for printing */
  0,                            /* c-style arrays */
  1,                            /* String lower bound */
  NULL,
  ada_get_gdb_completer_word_break_characters,
  ada_language_arch_info,
#ifdef GNAT_GDB
  ada_translate_error_message,  /* Substitute Ada-specific terminology
                                   in errors and warnings.  */
#endif /* GNAT_GDB */
  LANG_MAGIC
};

d10403 1
a10403 1
_initialize_ada_language (void)
d10405 15
a10419 17
  add_language (&ada_language_defn);

  varsize_limit = 65536;
#ifdef GNAT_GDB
  add_setshow_uinteger_cmd ("varsize-limit", class_support,
			    &varsize_limit, "\
Set the maximum number of bytes allowed in a dynamic-sized object.", "\
Show the maximum number of bytes allowed in a dynamic-sized object.",
			    NULL, NULL, &setlist, &showlist);
  obstack_init (&cache_space);
#endif /* GNAT_GDB */

  obstack_init (&symbol_list_obstack);

  decoded_names_store = htab_create_alloc
    (256, htab_hash_string, (int (*)(const void *, const void *)) streq,
     NULL, xcalloc, xfree);
@


1.34
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@d2 1
a2 1
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003
d8022 1
@


1.33
log
@        * language.h (language_defn): new field, la_word_break_characters.
        * language.c (unknown_language_defn): Set new field to
        default_word_break_characters.
        (auto_language_defn): Likewise.
        (local_language_defn): Likewise.
        * ada-lang.c (ada_language_defn): Likewise.
        * c-lang.c (c_language_defn): Likewise.
        (cplus_language_defn): Likewise.
        (asm_language_defn): Likewise.
        (minimal_language_defn): Likewise.
        * f-lang.c (f_language_defn): Likewise.
        * jv-lang.c (java_language_defn): Likewise.
        * m2-lang.c (m2_language_defn): Likewise.
        * objc-lang.c (objc_language_defn): Likewise.
        * p-lang.c (pascal_language_defn): Likewise.
        * scm-lang.c (scm_language_defn): Likewise.
@
text
@d256 1
a256 1
    STREQN (field_name, target, len)
d258 2
a259 2
	|| (STREQN (field_name + len, "___", 3)
	    && !STREQ (field_name + strlen (field_name) - 6, "___XVN")));
d289 1
a289 1
  return (len1 >= len2 && STREQ (str + len1 - len2, suffix));
d440 1
a440 1
  if (STREQN (str, "_ada_", 5))
d461 1
a461 1
	      if (STREQN (ada_opname_table[i].mangled, p,
d501 1
a501 1
	       !STREQN (mapping->demangled, p, strlen (mapping->demangled));
d572 1
a572 1
  if (STREQN (mangled, "_ada_", 5))
d588 1
a588 1
  if (len0 > 3 && STREQ (mangled + len0 - 3, "TKB"))
d590 1
a590 1
  if (len0 > 1 && STREQ (mangled + len0 - 1, "B"))
d619 1
a619 1
	      if (STREQN
d635 1
a635 1
      if (i < len0 - 4 && STREQN (mangled + i, "TK__", 4))
d695 1
a695 1
      return (STREQN (sym_name, name, len_name)
d697 2
a698 2
	|| (STREQN (sym_name, "_ada_", 5)
	    && STREQN (sym_name + 5, name, len_name)
d1239 1
a1239 1
	&& STREQ (name, ada_type_name (SYMBOL_TYPE (syms[i]))))
d2548 1
a2548 1
	  if (n0 == n1 && STREQN (N0, N1, n0))
d3220 1
a3220 1
      && STREQ (ada_type_name (type0), ada_type_name (type1)))
d3252 2
a3253 2
	      || (len0 < strlen (name1) && STREQN (name0, name1, len0)
		  && STREQN (name1 + len0, "___XV", 5)));
d3586 1
a3586 1
  return (name != NULL && STREQ (name, "<variable, no debug info>"));
d3613 1
a3613 1
		  && STREQ (DEPRECATED_SYMBOL_NAME (syms[i]), DEPRECATED_SYMBOL_NAME (syms[j]))
d3866 1
a3866 1
	  if (STREQ (str + 3, "LJM"))
d3903 2
a3904 2
  if (name_len >= patn_len + 5 && STREQN (name, "_ada_", 5)
      && STREQN (patn, name + 5, patn_len)
d3910 1
a3910 1
      if (STREQN (patn, name, patn_len) && is_name_suffix (name + patn_len))
d4457 1
a4457 1
    if (!STREQ (filename, s->filename))
d4755 1
a4755 1
    if (STREQ (filename, ps->filename))
d4786 1
a4786 1
    if (!STREQ (s->filename, filename))
d4964 3
a4966 3
  return (STREQN (filename, "s-", 2) ||
	  STREQN (filename, "a-", 2) ||
	  STREQN (filename, "g-", 2) || STREQN (filename, "i-", 2));
d4987 1
a4987 1
	      STREQ (sal.symtab->objfile->name, "/usr/shlib/libpthread.so"))
d5048 1
a5048 1
	  && type_name != NULL && STREQ (type_name, "exception"));
d5071 1
a5071 1
     && STREQN (arg, "exception", 9) &&
d5096 1
a5096 1
     else if (STREQN (tok, "unhandled", toklen))
d5109 1
a5109 1
     && STREQN (arg, "assert", 6) &&
d5141 1
a5141 1
	      || (name[0] == '_' && !STREQN (name, "_parent", 7)));
d5200 1
a5200 1
	  (STREQN (name, "PARENT", 6) || STREQN (name, "_parent", 7)));
d5214 2
a5215 2
	  && (STREQN (name, "PARENT", 6) || STREQ (name, "REP")
	      || STREQN (name, "_parent", 7)
d5286 1
a5286 1
      if (STREQN (discrim_end, "___XVN", 6))
d5297 1
a5297 1
      if ((discrim_start > name + 3 && STREQN (discrim_start - 3, "___", 3))
d5781 1
a5781 1
  if (align_offset < 7 || !STREQN ("___XV", name + align_offset - 6, 5))
d5885 1
a5885 1
      if (len > 6 && STREQ (ada_type_name (type) + len - 6, "___XVE"))
d6550 2
a6551 2
    && (STREQ (name, "character") || STREQ (name, "wide_character")
	|| STREQ (name, "unsigned char"));
d6584 1
a6584 1
	  && STREQ (TYPE_FIELD_NAME (type, 0), "F"));
d7671 1
a7671 1
    && STREQN (ada_type_name (type) + name_len - 6, "___XF", 5);
@


1.32
log
@2003-09-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STACK_ALIGN): Rename STACK_ALIGN.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Update.
	* hppa-tdep.c (hppa_push_arguments): Update.
	* ada-lang.c (place_on_stack): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Delete comment refering to
	stack_align.
@
text
@d8038 1
@


1.31
log
@2003-06-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_ADDRESS): Add predicate.  Deprecate.
	(FRAME_LOCALS_ADDRESS): Add predicate.  Deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame-base.c (default_frame_args_address): Update.  Use
	default_frame_base_address when DEPRECATED_FRAME_ARGS_ADDRESS is
	not available.
	(default_frame_locals_address): Ditto for
	DEPRECATED_FRAME_LOCALS_ADDRESS.
	* vax-tdep.c (vax_sigtramp_saved_pc): Update.
	(vax_frame_num_args): Update.
	(vax_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* symtab.h (address_class): Update comments.
	* ns32k-tdep.c (ns32k_sigtramp_saved_pc): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_ARGS_ADDRESS): Update.
	(DEPRECATED_FRAME_LOCALS_ADDRESS): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_FRAME_ARGS_ADDRESS): Update.
	(DEPRECATED_FRAME_LOCALS_ADDRESS): Update.
	(DEPRECATED_FRAME_LOCALS_ADDRESS): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_ARGS_ADDRESS): Update.
	* alpha-mdebug-tdep.c: Update.
	* ada-lang.c (add_symbols_from_enclosing_procs): Update.
@
text
@d3025 1
a3025 1
#ifdef STACK_ALIGN
d3027 1
a3027 1
		    STACK_ALIGN (TYPE_LENGTH
@


1.30
log
@	* ada-lang.c (scan_discrim_bound): Name first argument.
	(ada_add_block_symbols): Remove BLOCK_SYM to use local variable
	declared by ALL_BLOCK_SYMBOLS.
@
text
@d3562 1
a3562 1
      while (frame != NULL && FRAME_LOCALS_ADDRESS (frame) != target_link);
@


1.29
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* dictionary.h: New.
	* dictionary.c: New.
	* block.h: Add opaque declaration for struct dictionary.
	(struct block): Add 'dict' member; delete 'hashtable', 'nsyms',
	'sym' members.
	(BLOCK_DICT): New macro.
	Delete macros BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM,
	BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE,
	BLOCK_SHOULD_SORT.
	(ALL_BLOCK_SYMBOLS): Update definition.
	* Makefile.in (SFILES): Add dictionary.c.
	(dictionary_h): New.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New.
	(ada-lang.o): Depend on dictionary_h.
	(buildsym.o, coffread.o, jv-lang.o, mdebugread.o, objfiles.o)
	(stack.o, symmisc.o, symtab.o, tracepoint.o, valops.o)
	(mi-cmd-stack.o): Ditto.
	(gdbtk-cmds.o): Update dependencies.
	(gdbtk-stack.o): Ditto.
	* ada-lang.c: Include dictionary.h.
	(symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Ditto.
	(ada_add_block_symbols): Update uses of ALL_BLOCK_SYMBOLS; replace
	explicit iteration by use of ALL_BLOCK_SYMBOLS.  Delete variable
	'is_sorted'.
	* mdebugread.c: Include dictionary.h.
	(struct parse_stack): Delete 'maxsyms' member.
	(parse_symbol): Update calls to new_block.  Delete calls to
	shrink_block.  Use dictionary methods.
	(psymtab_to_symtab_1): Delete calls to sort_symtab_syms.
	Update calls to new_symtab.  Don't maintain maxsyms data.
	(mylookup_symbol): Update use of ALL_BLOCK_SYMBOLS.
	(add_symbol): Just call dict_add_symbol.
	(new_symtab): Delete 'maxsyms' argument.
	(new_symtab): Update calls to new_block.
	(new_block): Delete 'maxsyms' argument; add 'function' argument.
	(shrink_block): Delete function.
	(fixup_sigtramp): Update call to new_block.  Add symbol via
	dict_add_symbol.
	* jv-lang.c: Include dictionary.h.
	(get_java_class_symtab): Set the BLOCK_DICT of the blocks
	appropriately.  Set class_symtab->free_func.  Make sure the
	blockvector is big enough to hold two blocks.
	(add_class_symtab_symbol): Use dictionary methods.
	(free_class_block): New function.
	(type_from_class): Replace explicit iteration by
	ALL_BLOCK_SYMBOLS.
	* symtab.h (struct symtab): Replace 'free_ptr' method by
	'free_func'.
	* dwarf2read.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* dwarfread.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Delete call to sort_symtab_syms.
	Include dictionary.h.
	(patch_opaque_types): Update use of ALL_BLOCK_SYMBOLS.
	* dbxread.c (dbx_psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* objfiles.c: Include dictionary.h.
	(objfile_relocate): Update use of ALL_BLOCK_SYMBOLS.
	* buildsym.c: Include dictionary.h.
	(finish_block): Use dictionary methods.
	(end_symtab): Set free_func to NULL, not free_ptr.
	* tracepoint.c: Include dictionary.h.
	(add_local_symbols): Update use of ALL_BLOCK_SYMBOLS.
	(scope_info): Ditto.
	* stack.c: Include dictionary.h.
	(print_block_frame_locals): Update use of ALL_BLOCK_SYMBOLS.
	(print_block_frame_labels, print_frame_arg_vars)
	(print_frame_args): Ditto.
	* symmisc.c (free_symtab_block): Use dictionary methods.
	(dump_symtab): Ditto.
	(free_symtab): Replace use of 'free_ptr' by 'free_func'.
	Include	dictionary.h.
	* symfile.h: Delete declarations of sort_block_syms,
	sort_symtab_syms.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Delete.
	* symtab.c: Include dictionary.h.
	(lookup_block_symbol): Use dictionary iterators.
	(find_pc_sect_symtab): Update use of ALL_BLOCK_SYMBOLS.
	(search_symbols, make_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* valops.c (value_of_local): Use dict_empty.
	Include dictionary.h.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* generic/gdbtk-stack.c: Include dictionary.h.
	(gdb_block_vars): Update use of ALL_BLOCK_SYMBOLS.
	(gdb_get_blocks, gdb_get_vars_command): Ditto.
	* generic/gdbtk-cmds.c: Include dictionary.h.
	(gdb_listfuncs): Update use of ALL_BLOCK_SYMBOLS.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* mi-cmd-stack.c: Include dictionary.h.
	(list_args_or_locals): Update use of ALL_BLOCK_SYMBOLS.
@
text
@a4040 2
	    struct symbol *sym = BLOCK_SYM (block, i);

d7711 1
a7711 1
scan_discrim_bound (char *, int k, struct value *dval, LONGEST * px,
@


1.28
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* block.h (BLOCK_SHOULD_SORT): Delete.
	* symtab.c (lookup_block_symbol): Don't worry about sorted linear
	blocks.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Ditto.
	* symfile.h: Delete sort_symtabs_syms and sort_block_syms
	declarations.
	* coffread.c (coff_symfile_read): Don't call sort_symtab_syms.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
@
text
@d43 1
d3437 2
a3438 1
  int i, j;
d3452 1
a3452 1
	ALL_BLOCK_SYMBOLS (b, i, tmp_sym) if (sym == tmp_sym)
d3455 1
a3455 1
	ALL_BLOCK_SYMBOLS (b, i, tmp_sym) if (sym == tmp_sym)
d3479 1
a3479 1
	    ALL_BLOCK_SYMBOLS (b, i, tmp_sym) if (sym == tmp_sym)
d3952 1
a3952 1
  int i;
d3965 1
a3965 1
      ALL_BLOCK_SYMBOLS (block, i, sym)
d3994 1
a3994 1
      ALL_BLOCK_SYMBOLS (block, i, sym)
d4039 1
a4039 1
      ALL_BLOCK_SYMBOLS (block, i, sym)
d4103 1
a4103 1
  int i;
d4129 1
a4129 1
  ALL_BLOCK_SYMBOLS (b, i, sym)
d4702 2
a4703 2
  int i;
  struct symbol *i;
d4712 1
a4712 1
  ALL_BLOCK_SYMBOLS (b, i, sym)
a4713 2
    if (i > 0 && i % 4 == 0)
      fprintf (stderr, "\n\t\t    ");
@


1.27
log
@2003-06-02  David Carlton  <carlton@@math.stanford.edu>

	* objc-lang.c (find_imps): Delete unneeded variable 'sym_symtab'.
	* c-valprint.c (c_val_print): Delete unneeded variable 's'.
	* p-valprint.c (pascal_val_print): Ditto.
	* ada-lang.c (standard_lookup): Delete unneded variable 'symtab'.
@
text
@a3955 1
  int is_sorted = BLOCK_SHOULD_SORT (block);
d3992 1
a3992 24
      if (is_sorted)
	{
	  int U;
	  i = 0;
	  U = BLOCK_NSYMS (block) - 1;
	  while (U - i > 4)
	    {
	      int M = (U + i) >> 1;
	      struct symbol *sym = BLOCK_SYM (block, M);
	      if (DEPRECATED_SYMBOL_NAME (sym)[0] < name[0])
		i = M + 1;
	      else if (DEPRECATED_SYMBOL_NAME (sym)[0] > name[0])
		U = M - 1;
	      else if (strcmp (DEPRECATED_SYMBOL_NAME (sym), name) < 0)
		i = M + 1;
	      else
		U = M;
	    }
	}
      else
	i = 0;

      for (; i < BLOCK_BUCKETS (block); i += 1)
	for (sym = BLOCK_BUCKET (block, i); sym != NULL; sym = sym->hash_next)
d3998 2
a3999 10
		if (cmp < 0)
		  {
		    if (is_sorted)
		      {
			i = BLOCK_BUCKETS (block);
			break;
		      }
		  }
		else if (cmp == 0
			 && is_name_suffix (DEPRECATED_SYMBOL_NAME (sym) + name_len))
a4035 21
      if (is_sorted)
	{
	  int U;
	  i = 0;
	  U = BLOCK_NSYMS (block) - 1;
	  while (U - i > 4)
	    {
	      int M = (U + i) >> 1;
	      struct symbol *sym = BLOCK_SYM (block, M);
	      if (DEPRECATED_SYMBOL_NAME (sym)[0] < '_')
		i = M + 1;
	      else if (DEPRECATED_SYMBOL_NAME (sym)[0] > '_')
		U = M - 1;
	      else if (strcmp (DEPRECATED_SYMBOL_NAME (sym), "_ada_") < 0)
		i = M + 1;
	      else
		U = M;
	    }
	}
      else
	i = 0;
d4037 1
a4037 2
      for (; i < BLOCK_BUCKETS (block); i += 1)
	for (sym = BLOCK_BUCKET (block, i); sym != NULL; sym = sym->hash_next)
d4053 2
a4054 10
		if (cmp < 0)
		  {
		    if (is_sorted)
		      {
			i = BLOCK_BUCKETS (block);
			break;
		      }
		  }
		else if (cmp == 0
			 && is_name_suffix (DEPRECATED_SYMBOL_NAME (sym) + name_len + 5))
@


1.26
log
@2003-05-19  David Carlton  <carlton@@bactrian.org>

	* language.h (struct language_defn): Add 'la_value_of_this'
	and 'la_lookup_symbol_nonlocal' members.
	* symtab.h: Declare basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global,
	lookup_symbol_aux_block.
	* symtab.c (lookup_symbol_aux): Call language hooks to determine
	if we should search fields of this and how to do static/global
	lookup.
	(lookup_symbol_aux_block): Make extern.
	(basic_lookup_symbol_nonlocal): New.
	(lookup_symbol_static, lookup_symbol_global): Ditto.
	* ada-lang.c (ada_language_defn): Set 'la_value_of_this' and
	'la_lookup_symbol_nonlocal' members.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Ditto.
	* jv-lang.c (java_language_defn): Ditto.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Ditto.
	* m2-lang.c (m2_language_defn): Ditto.
	* objc-lang.c (objc_language_defn): Ditto.
	* scm-lang.c (scm_language_defn): Ditto.
	* f-lang.c (f_language_defn): Ditto, and include value.h as well.
	* p-lang.c (pascal_language_defn): Ditto for both.
	* Makefile.in (f-lang.o): Depend on value_h.
	(p-lang.o): Ditto.
@
text
@d3184 1
a3184 2
  struct symtab *symtab;
  sym = lookup_symbol (name, (struct block *) NULL, domain, 0, &symtab);
@


1.25
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d8085 2
@


1.24
log
@2003-04-21  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c: New file.
	* infcall.h: New file.
	* valarith.c: Include "infcall.h".
	* scm-lang.c, objc-lang.cm, hppa-tdep.c, gcore.c: Ditto.
	* eval.c, ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (valarith.o, scm-lang.o): Update dependencies.
	(objc-lang.o, hppa-tdep.o, gcore.o): Update dependencies.
	(eval.o, ada-valprint.o, ada-lang.o): Update dependencies.
	(SFILES): Add "infcall.c"
	(COMMON_OBS): Add "infcall.o".
	(infcall.o): Specify dependencies.
	* value.h (call_function_by_hand): Delete declaration.
	* inferior.h (run_stack_dummy): Delete declaration.
	* infcmd.c (breakpoint_auto_delete_contents): Move to "infcall.c".
	(run_stack_dummy): Move to "infcall.c", merged into
	call_function_by_hand.
	* valops.c (call_function_by_hand): Moved to "infcall.c".
	(find_function_addr, value_arg_coerce): Ditto.
	(unwindonsignal_p, coerce_float_to_double): Ditto.
	(_initialize_valops): Move "set/show coerce-float-to-double", and
	"set/show unwindonsignal" commands to "infcall.c".
	* v850-tdep.c, target.h: Update comments.
	* sparc-tdep.c (sparc_fix_call_dummy): Update comments.
	* sh-tdep.c (sh_init_extra_frame_info): Update comments.
	(sh64_init_extra_frame_info): Update comments.
	* mn10300-tdep.c: Update comments.
	* mcore-tdep.c (mcore_init_extra_frame_info): Update comments.
	* config/sparc/tm-sparc.h: Update comments.
	* breakpoint.h: Update comments.
	* avr-tdep.c (avr_init_extra_frame_info): Update comments.
	* arm-tdep.c: Update comment.
@
text
@d93 1
a93 1
				   namespace_enum, struct objfile *, int);
d103 1
a103 1
							 namespace_enum, int);
d192 1
a192 1
static struct symbol *standard_lookup (const char *, namespace_enum);
d708 1
a708 1
  if (SYMBOL_NAMESPACE (sym) == STRUCT_NAMESPACE)
d1235 1
a1235 1
			      VAR_NAMESPACE, &syms, &blocks);
d2154 1
a2154 1
         VAR_NAMESPACE,
d2256 1
a2256 1
	   VAR_NAMESPACE,
d2310 1
a2310 1
				    (struct block *) NULL, VAR_NAMESPACE,
d3178 1
a3178 1
 * given NAMESPACE. */
d3181 1
a3181 1
standard_lookup (const char *name, namespace_enum namespace)
d3185 1
a3185 1
  sym = lookup_symbol (name, (struct block *) NULL, namespace, 0, &symtab);
d3234 1
a3234 1
  if (SYMBOL_NAMESPACE (sym0) != SYMBOL_NAMESPACE (sym1)
d3296 1
a3296 1
/* Look, in partial_symtab PST, for symbol NAME in given namespace.
d3302 1
a3302 1
			   int global, namespace_enum namespace, int wild)
d3324 1
a3324 1
	  if (SYMBOL_NAMESPACE (psym) == namespace &&
d3358 1
a3358 1
	  if (SYMBOL_NAMESPACE (psym) == namespace)
d3400 1
a3400 1
	  if (SYMBOL_NAMESPACE (psym) == namespace)
d3510 1
a3510 1
 * selected frame, add symbols matching identifier NAME in NAMESPACE
d3519 1
a3519 1
add_symbols_from_enclosing_procs (const char *name, namespace_enum namespace,
d3538 1
a3538 1
      SYMBOL_NAMESPACE (static_link) = VAR_NAMESPACE;
d3569 1
a3569 1
	  ada_add_block_symbols (block, name, namespace, NULL, wild_match);
d3635 1
a3635 1
/* Find symbols in NAMESPACE matching NAME, in BLOCK0 and enclosing 
d3648 1
a3648 1
			namespace_enum namespace, struct symbol ***syms,
d3674 1
a3674 1
      ada_add_block_symbols (block, name, namespace, NULL, wild_match);
d3700 1
a3700 1
    ada_add_block_symbols (block, name, namespace, objfile, wild_match);
d3703 1
a3703 1
  if (namespace == VAR_NAMESPACE)
d3723 1
a3723 1
					   namespace, objfile, wild_match);
d3729 1
a3729 1
					       namespace, objfile,
d3742 1
a3742 1
	&& ada_lookup_partial_symbol (ps, name, 1, namespace, wild_match))
d3749 1
a3749 1
	ada_add_block_symbols (block, name, namespace, objfile, wild_match);
d3767 1
a3767 1
	ada_add_block_symbols (block, name, namespace, objfile, wild_match);
d3774 1
a3774 1
	    && ada_lookup_partial_symbol (ps, name, 0, namespace, wild_match))
d3781 1
a3781 1
	    ada_add_block_symbols (block, name, namespace,
d3792 1
a3792 1
      add_symbols_from_enclosing_procs (name, namespace, wild_match);
d3809 1
a3809 1
/* Return a symbol in NAMESPACE matching NAME, in BLOCK0 and enclosing 
d3817 1
a3817 1
		   namespace_enum namespace)
d3824 1
a3824 1
					 block0, namespace,
d3940 1
a3940 1
/* Add symbols from BLOCK matching identifier NAME in NAMESPACE to 
d3948 1
a3948 1
		       namespace_enum namespace, struct objfile *objfile,
d3967 1
a3967 1
	if (SYMBOL_NAMESPACE (sym) == namespace &&
d4019 1
a4019 1
	    if (SYMBOL_NAMESPACE (sym) == namespace)
d4096 1
a4096 1
	    if (SYMBOL_NAMESPACE (sym) == namespace)
d4391 1
a4391 1
					VAR_NAMESPACE, &symbols, &blocks);
d4394 1
a4394 1
					VAR_NAMESPACE, &symbols, &blocks);
d4640 1
a4640 1
		    standard_lookup (func_name, VAR_NAMESPACE);
d4714 1
a4714 1
		    standard_lookup (func_name, VAR_NAMESPACE);
d5858 1
a5858 1
  sym = standard_lookup (name, VAR_NAMESPACE);
d5862 1
a5862 1
  sym = standard_lookup (name, STRUCT_NAMESPACE);
d7824 1
a7824 1
    ada_lookup_symbol_list (name, get_selected_block (NULL), VAR_NAMESPACE,
@


1.23
log
@* Makefile.in (c_lang.o, jv_lang.o, language.o): Add $(demangle_h).
* language.h (struct language_defn): Add la_demangle.
(language_demangle): Declare.
* language.c (language_demangle): New function.
(unk_lang_demangle): Likewise.
(unknown_language_defn, auto_language_defn, local_language_defn):
Add ukn_lang_demangle.
* ada-lang.c (ada_language_defn): Add NULL for la_demangle element.
* f-lang.c, m2-lang.c, p-lang.c, scm-lang.c: Likewise.
* c-lang.c (c_language_defn, asm_language_defn): Likewise.
(cplus_language_defn): Add cplus_demangle for la_demangle element.
* jv-lang.c (java_demangle): New function
(java_language_defn): Use it for la_demangle element.
* objc-lang.c (objc_demangle): Add options argument
(objc_language_defn): Use objc_demangle for la_demangle element.
* maint.c (maintenance_demangle): Replace switch with
call to language_demangle.
* utils.c (fprintf_symbol_filtered): Likewise.
@
text
@d42 1
@


1.23.6.1
log
@Merge from mainline.
@
text
@a41 1
#include "infcall.h"
@


1.23.6.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d93 1
a93 1
				   domain_enum, struct objfile *, int);
d103 1
a103 1
							 domain_enum, int);
d192 1
a192 1
static struct symbol *standard_lookup (const char *, domain_enum);
d708 1
a708 1
  if (SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN)
d1235 1
a1235 1
			      VAR_DOMAIN, &syms, &blocks);
d2154 1
a2154 1
         VAR_DOMAIN,
d2256 1
a2256 1
	   VAR_DOMAIN,
d2310 1
a2310 1
				    (struct block *) NULL, VAR_DOMAIN,
d3178 1
a3178 1
 * given DOMAIN. */
d3181 1
a3181 1
standard_lookup (const char *name, domain_enum domain)
d3185 1
a3185 1
  sym = lookup_symbol (name, (struct block *) NULL, domain, 0, &symtab);
d3234 1
a3234 1
  if (SYMBOL_DOMAIN (sym0) != SYMBOL_DOMAIN (sym1)
d3296 1
a3296 1
/* Look, in partial_symtab PST, for symbol NAME in given domain.
d3302 1
a3302 1
			   int global, domain_enum domain, int wild)
d3324 1
a3324 1
	  if (SYMBOL_DOMAIN (psym) == domain &&
d3358 1
a3358 1
	  if (SYMBOL_DOMAIN (psym) == domain)
d3400 1
a3400 1
	  if (SYMBOL_DOMAIN (psym) == domain)
d3510 1
a3510 1
 * selected frame, add symbols matching identifier NAME in DOMAIN
d3519 1
a3519 1
add_symbols_from_enclosing_procs (const char *name, domain_enum domain,
d3538 1
a3538 1
      SYMBOL_DOMAIN (static_link) = VAR_DOMAIN;
d3569 1
a3569 1
	  ada_add_block_symbols (block, name, domain, NULL, wild_match);
d3635 1
a3635 1
/* Find symbols in DOMAIN matching NAME, in BLOCK0 and enclosing 
d3648 1
a3648 1
			domain_enum domain, struct symbol ***syms,
d3674 1
a3674 1
      ada_add_block_symbols (block, name, domain, NULL, wild_match);
d3700 1
a3700 1
    ada_add_block_symbols (block, name, domain, objfile, wild_match);
d3703 1
a3703 1
  if (domain == VAR_DOMAIN)
d3723 1
a3723 1
					   domain, objfile, wild_match);
d3729 1
a3729 1
					       domain, objfile,
d3742 1
a3742 1
	&& ada_lookup_partial_symbol (ps, name, 1, domain, wild_match))
d3749 1
a3749 1
	ada_add_block_symbols (block, name, domain, objfile, wild_match);
d3767 1
a3767 1
	ada_add_block_symbols (block, name, domain, objfile, wild_match);
d3774 1
a3774 1
	    && ada_lookup_partial_symbol (ps, name, 0, domain, wild_match))
d3781 1
a3781 1
	    ada_add_block_symbols (block, name, domain,
d3792 1
a3792 1
      add_symbols_from_enclosing_procs (name, domain, wild_match);
d3809 1
a3809 1
/* Return a symbol in DOMAIN matching NAME, in BLOCK0 and enclosing 
d3817 1
a3817 1
		   domain_enum domain)
d3824 1
a3824 1
					 block0, domain,
d3940 1
a3940 1
/* Add symbols from BLOCK matching identifier NAME in DOMAIN to 
d3948 1
a3948 1
		       domain_enum domain, struct objfile *objfile,
d3967 1
a3967 1
	if (SYMBOL_DOMAIN (sym) == domain &&
d4019 1
a4019 1
	    if (SYMBOL_DOMAIN (sym) == domain)
d4096 1
a4096 1
	    if (SYMBOL_DOMAIN (sym) == domain)
d4391 1
a4391 1
					VAR_DOMAIN, &symbols, &blocks);
d4394 1
a4394 1
					VAR_DOMAIN, &symbols, &blocks);
d4640 1
a4640 1
		    standard_lookup (func_name, VAR_DOMAIN);
d4714 1
a4714 1
		    standard_lookup (func_name, VAR_DOMAIN);
d5858 1
a5858 1
  sym = standard_lookup (name, VAR_DOMAIN);
d5862 1
a5862 1
  sym = standard_lookup (name, STRUCT_DOMAIN);
d7824 1
a7824 1
    ada_lookup_symbol_list (name, get_selected_block (NULL), VAR_DOMAIN,
@


1.22
log
@* Makefile.in (infrun.o): Add $(language_h)
* infrun.c (handle_inferior_event): Use skip_language_trampoline
for language specific trampolines.
* language.h (struct language_defn): Add skip_trampoline.
(skip_language_trampoline): Declare.
* language.c (unk_lang_trampoline, skip_language_trampoline):
New functions.
(unknown_language_defn, auto_language_defn, local_language_defn):
Add ukn_lang_trampoline.
* ada-lang.c (ada_language_defn): Add NULL for language
specific skip_trampoline.
* c-lang.c, f-lang.c, jv-lang.c, m2-lang.c, p-lang.c,
scm-lang.c: Likewise.
* objc-lang.c (objc_skip_trampoline): New function.
(objc_language_defn): Add objc_skip_trampoline.
@
text
@d8084 1
@


1.21
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d8083 1
@


1.20
log
@	Based on a patch from Daniel Berlin (dberlin@@dberlin.org).
	* symtab.h: Add opaque declarations of struct axs_value and
	struct agent_expr.
	(enum address_class): Add LOC_COMPUTED and LOC_COMPUTED_ARG.
	(struct location_funcs): New type.
	(struct symbol): Add "loc" to aux_value.
	(SYMBOL_LOCATION_BATON, SYMBOL_LOCATION_FUNCS): New macros.
	* dwarf2read.c: Include "dwarf2expr.h".
	(dwarf2_symbol_mark_computed): New function.
	(read_func_scope): Use it.
	(var_decode_location): New function.
	(new_symbol): Use it.
	* dwarf2expr.c, dwarf2expr.h, dwarf2loc.c, dwarf2loc.h: New files.

	* Makefile.in (SFILES): Add dwarf2loc.c and dwarf2expr.c.
	(dwarf2expr_h, dwarf2loc_h): New variables.
	(COMMON_OBS): Add dwarf2expr.o and dwarf2loc.o.
	(dwarf2expr.o, dwarf2loc.o): New rules.
	(dwarf2read.o): Add $(dwarf2expr_h) and $(dwarf2loc_h).
	* buildsym.c (finish_block): Handle LOC_COMPUTED and
	LOC_COMPUTED_ARG.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info, print_frame_args): Likewise.
	* stack.c (print_block_frame_locals, print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* ada-lang.c (ada_resolve_subexp, symtab_for_sym)
	(ada_add_block_symbols, fill_in_ada_prototype): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
@
text
@d710 1
a710 1
    return is_suppressed_name (SYMBOL_NAME (sym));
d2568 2
a2569 2
	  if (mangled_ordered_before (SYMBOL_NAME (syms[j]),
				      SYMBOL_NAME (sym)))
d3245 2
a3246 2
	char *name0 = SYMBOL_NAME (sym0);
	char *name1 = SYMBOL_NAME (sym1);
d3324 1
a3324 1
	      wild_match (name, name_len, SYMBOL_NAME (psym)))
d3340 1
a3340 1
	      if (SYMBOL_NAME (psym)[0] < name[0])
d3342 1
a3342 1
	      else if (SYMBOL_NAME (psym)[0] > name[0])
d3344 1
a3344 1
	      else if (strcmp (SYMBOL_NAME (psym), name) < 0)
d3359 1
a3359 1
	      int cmp = strncmp (name, SYMBOL_NAME (psym), name_len);
d3367 1
a3367 1
		       && is_name_suffix (SYMBOL_NAME (psym) + name_len))
d3382 1
a3382 1
	      if (SYMBOL_NAME (psym)[0] < '_')
d3384 1
a3384 1
	      else if (SYMBOL_NAME (psym)[0] > '_')
d3386 1
a3386 1
	      else if (strcmp (SYMBOL_NAME (psym), "_ada_") < 0)
d3403 1
a3403 1
	      cmp = (int) '_' - (int) SYMBOL_NAME (psym)[0];
d3406 1
a3406 1
		  cmp = strncmp ("_ada_", SYMBOL_NAME (psym), 5);
d3408 1
a3408 1
		    cmp = strncmp (name, SYMBOL_NAME (psym) + 5, name_len);
d3417 1
a3417 1
		       && is_name_suffix (SYMBOL_NAME (psym) + name_len + 5))
d3500 1
a3500 1
    if (ada_match_name (SYMBOL_NAME (msymbol), name, wild_match)
d3534 1
a3534 1
      SYMBOL_NAME (static_link) = "";
d3603 1
a3603 1
      if (SYMBOL_NAME (syms[i]) != NULL
d3610 2
a3611 2
		  && SYMBOL_NAME (syms[j]) != NULL
		  && STREQ (SYMBOL_NAME (syms[i]), SYMBOL_NAME (syms[j]))
d3706 1
a3706 1
	if (ada_match_name (SYMBOL_NAME (msymbol), name, wild_match))
d3721 1
a3721 1
					   SYMBOL_NAME (msymbol),
d3727 1
a3727 1
					       SYMBOL_NAME (msymbol),
d3967 1
a3967 1
	    wild_match (name, name_len, SYMBOL_NAME (sym)))
d4002 1
a4002 1
	      if (SYMBOL_NAME (sym)[0] < name[0])
d4004 1
a4004 1
	      else if (SYMBOL_NAME (sym)[0] > name[0])
d4006 1
a4006 1
	      else if (strcmp (SYMBOL_NAME (sym), name) < 0)
d4020 1
a4020 1
		int cmp = strncmp (name, SYMBOL_NAME (sym), name_len);
d4031 1
a4031 1
			 && is_name_suffix (SYMBOL_NAME (sym) + name_len))
d4077 1
a4077 1
	      if (SYMBOL_NAME (sym)[0] < '_')
d4079 1
a4079 1
	      else if (SYMBOL_NAME (sym)[0] > '_')
d4081 1
a4081 1
	      else if (strcmp (SYMBOL_NAME (sym), "_ada_") < 0)
d4099 1
a4099 1
		cmp = (int) '_' - (int) SYMBOL_NAME (sym)[0];
d4102 1
a4102 1
		    cmp = strncmp ("_ada_", SYMBOL_NAME (sym), 5);
d4104 1
a4104 1
		      cmp = strncmp (name, SYMBOL_NAME (sym) + 5, name_len);
d4116 1
a4116 1
			 && is_name_suffix (SYMBOL_NAME (sym) + name_len + 5))
d4202 1
a4202 1
	TYPE_FIELD_NAME (ftype, nargs) = SYMBOL_NAME (sym);
d4216 1
a4216 1
	TYPE_FIELD_NAME (ftype, nargs) = SYMBOL_NAME (sym);
d4768 1
a4768 1
    fprintf (stderr, " Function: %s", SYMBOL_NAME (BLOCK_FUNCTION (b)));
d4776 1
a4776 1
    fprintf (stderr, " %s", SYMBOL_NAME (sym));
@


1.19
log
@2003-02-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME;
	expand comment.
	* ada-lang.c (user_select_syms, ada_finish_decode_line_1): Replace
	SYMBOL_PRINT_NAME with SYMBOL_SOURCE_NAME.
	* ada-typeprint.c (ada_typedef_print): Ditto.
	* ax-gdb.c (gen_var_ref): Ditto.
	* breakpoint.c (print_one_breakpoint): Ditto.
	* buildsym.c (finish_block): Ditto.
	* c-valprint.c (c_val_print): Ditto.
	* expprint.c (print_subexp): Ditto.
	* findvar.c (locate_var_value): Ditto.
	* infcmd.c (jump_command): Ditto.
	* linespec.c (decode_line_2, decode_compound): Ditto.
	* maint.c (maintenance_translate_address): Ditto.
	* objc-lang.c (compare_selectors, compare_classes): Ditto.
	* printcmd.c (build_address_symbolic, sym_info, print_frame_args):
	Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* stack.c (print_frame, frame_info, print_block_frame_locals)
	(print_frame_arg_vars, return_command): Ditto.
	* symfile.c (compare_symbols, compare_psymbols): Ditto.
	* symmisc.c (print_symbol): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol)
	(compare_search_syms, print_symbol_info, print_msymbol_info)
	(rbreak_command): Ditto.
	* tracepoint.c (tracepoints_info): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* valops.c (value_of_variable, hand_function_call): Ditto.
	* cli/cli-cmds.c (edit_command, list_command): Ditto.
	* ada-typeprint.c: Update Copyright.
	* infcmd.c, objc-lang.c, p-valprint.c, symmisc.c: Ditto.
	* tracepoint.c, cli/cli-cmds.c: Ditto.
@
text
@d2175 2
d3471 2
d3977 1
d4041 1
d4126 1
d4211 1
@


1.18
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d2 2
a3 1
   1992, 1993, 1994, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d2617 1
a2617 1
			     SYMBOL_SOURCE_NAME (syms[i]),
d2634 1
a2634 1
			       SYMBOL_SOURCE_NAME (syms[i]),
d2641 1
a2641 1
				 SYMBOL_SOURCE_NAME (syms[i]));
d2648 1
a2648 1
			       SYMBOL_SOURCE_NAME (syms[i]),
d2655 1
a2655 1
			       SYMBOL_SOURCE_NAME (syms[i]));
d4477 1
a4477 1
					SYMBOL_SOURCE_NAME (symbols[i]));
@


1.17
log
@* configure.in: Remove UI_OUT configuration code.
* ada-lang.c: Update assuming UI_OUT is always true.
* Makefile.in (UIOUT_CFLAGS): Remove.
* configure: Regenerated.
* TODO: Remove blurb about elimination of -DUI_OUT.
@
text
@d40 1
@


1.16
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@a38 1
#ifdef UI_OUT
a39 1
#endif
a5054 1
#ifdef UI_OUT
a5091 1
#endif
@


1.15
log
@2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (pc_notcurrent): New function.
	(find_frame_sal): New function.
	* frame.h (find_frame_sal): Declare.
	(struct symtab_and_line): Add opaque declaration.
	* stack.c (print_frame_info_base): Use find_pc_line instead of
	find_frame_sal.
	(frame_info): Ditto.
	* ada-lang.c (find_printable_frame): Ditto.

Index: tui/ChangeLog
2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use find_frame_sal instead of
	find_pc_line.
@
text
@d3539 1
a3539 1
  frame = selected_frame;
d5046 1
a5046 1
	  selected_frame = fi;
@


1.14
log
@2002-11-23  Andrew Cagney  <ac131313@@redhat.com>

	* breakpoint.c: Include "gdb_assert.h".
	(deprecated_frame_in_dummy): Assert that generic dummy frames are
	not being used.
	* Makefile.in (breakpoint.o): Update dependencies.
	* ada-lang.c (find_printable_frame): Use get_frame_type instead of
	deprecated_frame_in_dummy.
	* stack.c (print_frame_info_base): Ditto.
	(frame_info): Ditto.
	(print_frame_info_base): Ditto.  Delete dead code.

Index: tui/ChangeLog
2002-11-23  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	deprecated_frame_in_dummy.  Fix coding style.
@
text
@d5035 1
a5035 14
      /* If fi is not the innermost frame, that normally means that
         fi->pc points at the return instruction (which is *after* the
         call instruction), and we want to get the line containing the
         call (because the call is where the user thinks the program
         is).  However, if the next frame is either a SIGTRAMP_FRAME
         or a DUMMY_FRAME, then the next frame will contain a saved
         interrupt PC and such a PC indicates the current (rather than
         next) instruction/line, consequently, for such cases, want to
         get the line containing fi->pc.  */
      sal =
	find_pc_line (fi->pc,
		      fi->next != NULL
		      && !(get_frame_type (fi->next) == SIGTRAMP_FRAME)
		      && !(get_frame_type (fi->next) == DUMMY_FRAME));
@


1.13
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@d5048 1
a5048 1
		      && !deprecated_frame_in_dummy (fi->next));
@


1.12
log
@	* gdbtypes.h (struct main_type): Move artificial flag out of
	loc.  New member of ``struct field'' named static_kind.  Reduce
	overloaded meaning of bitsize.
	(FIELD_ARTIFICIAL, SET_FIELD_PHYSNAME, SET_FIELD_PHYSADDR)
	(TYPE_FIELD_STATIC, TYPE_FIELD_STATIC_HAS_ADDR): Likewise.
	(FIELD_STATIC_KIND, TYPE_FIELD_STATIC_KIND): New macros.

	* ada-lang.c (fill_in_ada_prototype): Initialize static_kind for
	new fields.
	(template_to_fixed_record_type, template_to_static_fixed_type)
	(to_record_with_fixed_variant_part): Likewise.
	* coffread.c (coff_read_struct_type, coff_read_enum_type): Likewise.
	* dwarf2read.c (dwarf2_add_field, read_enumeration): Likewise.
	* dwarfread.c (struct_type, enum_type): Likewise.
	* hpread.c (hpread_read_enum_type)
	(hpread_read_function_type, hpread_read_doc_function_type)
	(hpread_read_struct_type): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
@
text
@d5035 9
a5043 6
      /* If fi is not the innermost frame, that normally means that fi->pc
         points to *after* the call instruction, and we want to get the line
         containing the call, never the next line.  But if the next frame is
         a signal_handler_caller or a dummy frame, then the next frame was
         not entered as the result of a call, and we want to get the line
         containing fi->pc.  */
d5047 1
a5047 1
		      && !fi->next->signal_handler_caller
@


1.11
log
@2002-11-10  Andrew Cagney  <ac131313@@redhat.com>

	* breakpoint.h (deprecated_frame_in_dummy): Rename frame_in_dummy.
	* stack.c (print_frame_info_base): Update.
	(print_frame_info_base, frame_info): Update.
	* sparc-tdep.c (sparc_init_extra_frame_info): Update.
	(sparc_frame_saved_pc): Update.
	* ada-lang.c (find_printable_frame): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
@
text
@d4192 1
d4206 1
d6051 1
d6155 1
d6225 1
@


1.10
log
@2002-10-24  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (INIT_SAL): Delete macro.
	(init_sal): Export.
	* symtab.c (init_sal): New function.

	* ada-lang.c (ada_finish_decode_line_1): Change INIT_SAL macro
	to init_sal function call.
	(find_sal_from_funcs_and_line): Ditto.
	(all_sals_for_line): Ditto.
	* breakpoint.c (create_internal_breakpoint): Ditto.
	(create_fork_vfork_event_catchpoint): Ditto.
	(create_exec_event_catchpoint): Ditto.
	(parse_breakpoint_sals): Ditto.
	(watch_command_1): Ditto.
	(handle_gnu_4_16_catch_command): Ditto.
	(clear_command): Ditto.
	* hppa-tdep.c (child_enable_exception_callback): Ditto.
	* infcmd.c (run_stack_dummy): Ditto.
	* infrun.c (process_event_stop_test): Ditto.
	(check_sigtramp2): Ditto.
	(step_over_function): Ditto.
	* linespec.c (decode_line_2): Ditto.
	(decode_line_1): Ditto.
	* source.c (line_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
@
text
@d5043 1
a5043 1
		      && !frame_in_dummy (fi->next));
@


1.9
log
@	* ada-lang.c (ada_array_bound, ada_type_match,
	_initialize_ada_language): Fix K&R definitions.
	* ada-tasks.c (get_current_task): Fix K&R definitions.
	* ada-valprint.c (adjust_type_signedness): Fix K&R definitions.
@
text
@d4398 1
a4398 1
      INIT_SAL (&val);
d4540 1
a4540 1
  INIT_SAL (&sals.sals[0]);
d4859 1
a4859 1
	INIT_SAL (&result.sals[result.nelts]);
@


1.9.4.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d4398 1
a4398 1
      init_sal (&val);
d4540 1
a4540 1
  init_sal (&sals.sals[0]);
d4859 1
a4859 1
	init_sal (&result.sals[result.nelts]);
@


1.9.4.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 2
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003
   Free Software Foundation, Inc.
d39 1
d41 1
a41 3
#include "block.h"
#include "infcall.h"
#include "dictionary.h"
d92 1
a92 1
				   domain_enum, struct objfile *, int);
d102 1
a102 1
							 domain_enum, int);
d191 1
a191 1
static struct symbol *standard_lookup (const char *, domain_enum);
d254 1
a254 1
    DEPRECATED_STREQN (field_name, target, len)
d256 2
a257 2
	|| (DEPRECATED_STREQN (field_name + len, "___", 3)
	    && !DEPRECATED_STREQ (field_name + strlen (field_name) - 6, "___XVN")));
d287 1
a287 1
  return (len1 >= len2 && DEPRECATED_STREQ (str + len1 - len2, suffix));
d438 1
a438 1
  if (DEPRECATED_STREQN (str, "_ada_", 5))
d459 1
a459 1
	      if (DEPRECATED_STREQN (ada_opname_table[i].mangled, p,
d499 1
a499 1
	       !DEPRECATED_STREQN (mapping->demangled, p, strlen (mapping->demangled));
d570 1
a570 1
  if (DEPRECATED_STREQN (mangled, "_ada_", 5))
d586 1
a586 1
  if (len0 > 3 && DEPRECATED_STREQ (mangled + len0 - 3, "TKB"))
d588 1
a588 1
  if (len0 > 1 && DEPRECATED_STREQ (mangled + len0 - 1, "B"))
d617 1
a617 1
	      if (DEPRECATED_STREQN
d633 1
a633 1
      if (i < len0 - 4 && DEPRECATED_STREQN (mangled + i, "TK__", 4))
d693 1
a693 1
      return (DEPRECATED_STREQN (sym_name, name, len_name)
d695 2
a696 2
	|| (DEPRECATED_STREQN (sym_name, "_ada_", 5)
	    && DEPRECATED_STREQN (sym_name + 5, name, len_name)
d707 1
a707 1
  if (SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN)
d710 1
a710 1
    return is_suppressed_name (DEPRECATED_SYMBOL_NAME (sym));
d1234 1
a1234 1
			      VAR_DOMAIN, &syms, &blocks);
d1237 1
a1237 1
	&& DEPRECATED_STREQ (name, ada_type_name (SYMBOL_TYPE (syms[i]))))
d2153 1
a2153 1
         VAR_DOMAIN,
a2174 2
   case LOC_COMPUTED:
   case LOC_COMPUTED_ARG:
d2253 1
a2253 1
	   VAR_DOMAIN,
d2307 1
a2307 1
				    (struct block *) NULL, VAR_DOMAIN,
d2544 1
a2544 1
	  if (n0 == n1 && DEPRECATED_STREQN (N0, N1, n0))
d2566 2
a2567 2
	  if (mangled_ordered_before (DEPRECATED_SYMBOL_NAME (syms[j]),
				      DEPRECATED_SYMBOL_NAME (sym)))
d2617 1
a2617 1
			     SYMBOL_PRINT_NAME (syms[i]),
d2634 1
a2634 1
			       SYMBOL_PRINT_NAME (syms[i]),
d2641 1
a2641 1
				 SYMBOL_PRINT_NAME (syms[i]));
d2648 1
a2648 1
			       SYMBOL_PRINT_NAME (syms[i]),
d2655 1
a2655 1
			       SYMBOL_PRINT_NAME (syms[i]));
d3021 1
a3021 1
#ifdef DEPRECATED_STACK_ALIGN
d3023 1
a3023 1
		    DEPRECATED_STACK_ALIGN (TYPE_LENGTH
d3175 1
a3175 1
 * given DOMAIN. */
d3178 1
a3178 1
standard_lookup (const char *name, domain_enum domain)
d3181 2
a3182 1
  sym = lookup_symbol (name, (struct block *) NULL, domain, 0, NULL);
d3217 1
a3217 1
      && DEPRECATED_STREQ (ada_type_name (type0), ada_type_name (type1)))
d3231 1
a3231 1
  if (SYMBOL_DOMAIN (sym0) != SYMBOL_DOMAIN (sym1)
d3243 2
a3244 2
	char *name0 = DEPRECATED_SYMBOL_NAME (sym0);
	char *name1 = DEPRECATED_SYMBOL_NAME (sym1);
d3249 2
a3250 2
	      || (len0 < strlen (name1) && DEPRECATED_STREQN (name0, name1, len0)
		  && DEPRECATED_STREQN (name1 + len0, "___XV", 5)));
d3293 1
a3293 1
/* Look, in partial_symtab PST, for symbol NAME in given domain.
d3299 1
a3299 1
			   int global, domain_enum domain, int wild)
d3321 2
a3322 2
	  if (SYMBOL_DOMAIN (psym) == domain &&
	      wild_match (name, name_len, DEPRECATED_SYMBOL_NAME (psym)))
d3338 1
a3338 1
	      if (DEPRECATED_SYMBOL_NAME (psym)[0] < name[0])
d3340 1
a3340 1
	      else if (DEPRECATED_SYMBOL_NAME (psym)[0] > name[0])
d3342 1
a3342 1
	      else if (strcmp (DEPRECATED_SYMBOL_NAME (psym), name) < 0)
d3355 1
a3355 1
	  if (SYMBOL_DOMAIN (psym) == domain)
d3357 1
a3357 1
	      int cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (psym), name_len);
d3365 1
a3365 1
		       && is_name_suffix (DEPRECATED_SYMBOL_NAME (psym) + name_len))
d3380 1
a3380 1
	      if (DEPRECATED_SYMBOL_NAME (psym)[0] < '_')
d3382 1
a3382 1
	      else if (DEPRECATED_SYMBOL_NAME (psym)[0] > '_')
d3384 1
a3384 1
	      else if (strcmp (DEPRECATED_SYMBOL_NAME (psym), "_ada_") < 0)
d3397 1
a3397 1
	  if (SYMBOL_DOMAIN (psym) == domain)
d3401 1
a3401 1
	      cmp = (int) '_' - (int) DEPRECATED_SYMBOL_NAME (psym)[0];
d3404 1
a3404 1
		  cmp = strncmp ("_ada_", DEPRECATED_SYMBOL_NAME (psym), 5);
d3406 1
a3406 1
		    cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (psym) + 5, name_len);
d3415 1
a3415 1
		       && is_name_suffix (DEPRECATED_SYMBOL_NAME (psym) + name_len + 5))
d3434 1
a3434 2
  struct dict_iterator iter;
  int j;
d3448 1
a3448 1
	ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
d3451 1
a3451 1
	ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
a3468 2
      case LOC_COMPUTED:
      case LOC_COMPUTED_ARG:
d3473 1
a3473 1
	    ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
d3496 1
a3496 1
    if (ada_match_name (DEPRECATED_SYMBOL_NAME (msymbol), name, wild_match)
d3505 1
a3505 1
 * selected frame, add symbols matching identifier NAME in DOMAIN
d3514 1
a3514 1
add_symbols_from_enclosing_procs (const char *name, domain_enum domain,
d3530 1
a3530 1
      DEPRECATED_SYMBOL_NAME (static_link) = "";
d3533 1
a3533 1
      SYMBOL_DOMAIN (static_link) = VAR_DOMAIN;
d3539 1
a3539 1
  frame = deprecated_selected_frame;
d3556 1
a3556 1
      while (frame != NULL && DEPRECATED_FRAME_LOCALS_ADDRESS (frame) != target_link);
d3564 1
a3564 1
	  ada_add_block_symbols (block, name, domain, NULL, wild_match);
d3580 1
a3580 1
  return (name != NULL && DEPRECATED_STREQ (name, "<variable, no debug info>"));
d3599 1
a3599 1
      if (DEPRECATED_SYMBOL_NAME (syms[i]) != NULL
d3606 2
a3607 2
		  && DEPRECATED_SYMBOL_NAME (syms[j]) != NULL
		  && DEPRECATED_STREQ (DEPRECATED_SYMBOL_NAME (syms[i]), DEPRECATED_SYMBOL_NAME (syms[j]))
d3630 1
a3630 1
/* Find symbols in DOMAIN matching NAME, in BLOCK0 and enclosing 
d3643 1
a3643 1
			domain_enum domain, struct symbol ***syms,
d3669 1
a3669 1
      ada_add_block_symbols (block, name, domain, NULL, wild_match);
d3695 1
a3695 1
    ada_add_block_symbols (block, name, domain, objfile, wild_match);
d3698 1
a3698 1
  if (domain == VAR_DOMAIN)
d3702 1
a3702 1
	if (ada_match_name (DEPRECATED_SYMBOL_NAME (msymbol), name, wild_match))
d3717 2
a3718 2
					   DEPRECATED_SYMBOL_NAME (msymbol),
					   domain, objfile, wild_match);
d3723 2
a3724 2
					       DEPRECATED_SYMBOL_NAME (msymbol),
					       domain, objfile,
d3737 1
a3737 1
	&& ada_lookup_partial_symbol (ps, name, 1, domain, wild_match))
d3744 1
a3744 1
	ada_add_block_symbols (block, name, domain, objfile, wild_match);
d3762 1
a3762 1
	ada_add_block_symbols (block, name, domain, objfile, wild_match);
d3769 1
a3769 1
	    && ada_lookup_partial_symbol (ps, name, 0, domain, wild_match))
d3776 1
a3776 1
	    ada_add_block_symbols (block, name, domain,
d3787 1
a3787 1
      add_symbols_from_enclosing_procs (name, domain, wild_match);
d3804 1
a3804 1
/* Return a symbol in DOMAIN matching NAME, in BLOCK0 and enclosing 
d3812 1
a3812 1
		   domain_enum domain)
d3819 1
a3819 1
					 block0, domain,
d3860 1
a3860 1
	  if (DEPRECATED_STREQ (str + 3, "LJM"))
d3897 2
a3898 2
  if (name_len >= patn_len + 5 && DEPRECATED_STREQN (name, "_ada_", 5)
      && DEPRECATED_STREQN (patn, name + 5, patn_len)
d3904 1
a3904 1
      if (DEPRECATED_STREQN (patn, name, patn_len) && is_name_suffix (name + patn_len))
d3935 1
a3935 1
/* Add symbols from BLOCK matching identifier NAME in DOMAIN to 
d3943 1
a3943 1
		       domain_enum domain, struct objfile *objfile,
d3946 1
a3946 1
  struct dict_iterator iter;
d3952 1
d3960 1
a3960 1
      ALL_BLOCK_SYMBOLS (block, iter, sym)
d3962 2
a3963 2
	if (SYMBOL_DOMAIN (sym) == domain &&
	    wild_match (name, name_len, DEPRECATED_SYMBOL_NAME (sym)))
a3972 1
	      case LOC_COMPUTED_ARG:
d3988 24
a4011 1
      ALL_BLOCK_SYMBOLS (block, iter, sym)
d4013 1
a4013 1
	    if (SYMBOL_DOMAIN (sym) == domain)
d4015 1
a4015 1
		int cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (sym), name_len);
d4017 10
a4026 2
		if (cmp == 0
		    && is_name_suffix (DEPRECATED_SYMBOL_NAME (sym) + name_len))
a4035 1
		      case LOC_COMPUTED_ARG:
d4062 21
d4084 2
a4085 1
      ALL_BLOCK_SYMBOLS (block, iter, sym)
d4087 3
a4089 1
	    if (SYMBOL_DOMAIN (sym) == domain)
d4093 1
a4093 1
		cmp = (int) '_' - (int) DEPRECATED_SYMBOL_NAME (sym)[0];
d4096 1
a4096 1
		    cmp = strncmp ("_ada_", DEPRECATED_SYMBOL_NAME (sym), 5);
d4098 1
a4098 1
		      cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (sym) + 5, name_len);
d4101 10
a4110 2
		if (cmp == 0
		    && is_name_suffix (DEPRECATED_SYMBOL_NAME (sym) + name_len + 5))
a4119 1
		      case LOC_COMPUTED_ARG:
d4156 1
a4156 1
  struct dict_iterator iter;
d4182 1
a4182 1
  ALL_BLOCK_SYMBOLS (b, iter, sym)
a4191 1
	TYPE_FIELD_STATIC_KIND (ftype, nargs) = 0;
d4194 1
a4194 1
	TYPE_FIELD_NAME (ftype, nargs) = DEPRECATED_SYMBOL_NAME (sym);
a4202 1
      case LOC_COMPUTED_ARG:
a4204 1
	TYPE_FIELD_STATIC_KIND (ftype, nargs) = 0;
d4206 1
a4206 1
	TYPE_FIELD_NAME (ftype, nargs) = DEPRECATED_SYMBOL_NAME (sym);
d4380 1
a4380 1
					VAR_DOMAIN, &symbols, &blocks);
d4383 1
a4383 1
					VAR_DOMAIN, &symbols, &blocks);
d4475 1
a4475 1
					SYMBOL_PRINT_NAME (symbols[i]));
d4509 1
a4509 1
    if (!DEPRECATED_STREQ (filename, s->filename))
d4629 1
a4629 1
		    standard_lookup (func_name, VAR_DOMAIN);
d4703 1
a4703 1
		    standard_lookup (func_name, VAR_DOMAIN);
d4752 2
a4753 2
  struct dict_iterator iter;
  struct symbol *sym;
d4758 1
a4758 1
    fprintf (stderr, " Function: %s", DEPRECATED_SYMBOL_NAME (BLOCK_FUNCTION (b)));
d4762 1
a4762 1
  ALL_BLOCK_SYMBOLS (b, iter, sym)
d4764 3
a4766 1
    fprintf (stderr, " %s", DEPRECATED_SYMBOL_NAME (sym));
d4809 1
a4809 1
    if (DEPRECATED_STREQ (filename, ps->filename))
d4840 1
a4840 1
    if (!DEPRECATED_STREQ (s->filename, filename))
d5018 3
a5020 3
  return (DEPRECATED_STREQN (filename, "s-", 2) ||
	  DEPRECATED_STREQN (filename, "a-", 2) ||
	  DEPRECATED_STREQN (filename, "g-", 2) || DEPRECATED_STREQN (filename, "i-", 2));
d5033 11
a5043 1
      find_frame_sal (fi, &sal);
d5051 1
a5051 1
	      DEPRECATED_STREQ (sal.symtab->objfile->name, "/usr/shlib/libpthread.so"))
d5054 1
a5054 1
	  deprecated_selected_frame = fi;
d5065 1
d5103 1
d5114 1
a5114 1
	  && type_name != NULL && DEPRECATED_STREQ (type_name, "exception"));
d5137 1
a5137 1
     && DEPRECATED_STREQN (arg, "exception", 9) &&
d5162 1
a5162 1
     else if (DEPRECATED_STREQN (tok, "unhandled", toklen))
d5175 1
a5175 1
     && DEPRECATED_STREQN (arg, "assert", 6) &&
d5207 1
a5207 1
	      || (name[0] == '_' && !DEPRECATED_STREQN (name, "_parent", 7)));
d5266 1
a5266 1
	  (DEPRECATED_STREQN (name, "PARENT", 6) || DEPRECATED_STREQN (name, "_parent", 7)));
d5280 2
a5281 2
	  && (DEPRECATED_STREQN (name, "PARENT", 6) || DEPRECATED_STREQ (name, "REP")
	      || DEPRECATED_STREQN (name, "_parent", 7)
d5352 1
a5352 1
      if (DEPRECATED_STREQN (discrim_end, "___XVN", 6))
d5363 1
a5363 1
      if ((discrim_start > name + 3 && DEPRECATED_STREQN (discrim_start - 3, "___", 3))
d5847 1
a5847 1
  if (align_offset < 7 || !DEPRECATED_STREQN ("___XV", name + align_offset - 6, 5))
d5859 1
a5859 1
  sym = standard_lookup (name, VAR_DOMAIN);
d5863 1
a5863 1
  sym = standard_lookup (name, STRUCT_DOMAIN);
d5951 1
a5951 1
      if (len > 6 && DEPRECATED_STREQ (ada_type_name (type) + len - 6, "___XVE"))
a6048 1
      TYPE_FIELD_STATIC_KIND (rtype, f) = 0;
a6151 1
      TYPE_FIELD_STATIC_KIND (type, f) = 0;
a6220 1
      TYPE_FIELD_STATIC_KIND (rtype, nfields - 1) = 0;
d6613 2
a6614 2
    && (DEPRECATED_STREQ (name, "character") || DEPRECATED_STREQ (name, "wide_character")
	|| DEPRECATED_STREQ (name, "unsigned char"));
d6647 1
a6647 1
	  && DEPRECATED_STREQ (TYPE_FIELD_NAME (type, 0), "F"));
d7734 1
a7734 1
    && DEPRECATED_STREQN (ada_type_name (type) + name_len - 6, "___XF", 5);
d7774 1
a7774 1
scan_discrim_bound (char *str, int k, struct value *dval, LONGEST * px,
d7822 1
a7822 1
    ada_lookup_symbol_list (name, get_selected_block (NULL), VAR_DOMAIN,
a8081 4
  NULL,				/* Language specific skip_trampoline */
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal  */
  NULL,				/* Language specific symbol demangler */
a8096 1
  default_word_break_characters,
@


1.9.4.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2 1
a2 1
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004
a8021 1
  basic_lookup_transparent_type,/* lookup_transparent_type */
@


1.9.2.1
log
@2002-09-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h: Delete BLOCK_SHOULD_SORT.
	* symtab.c (lookup_block_symbol): Assume non-hashed blocks aren't
	sorted.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.h: Delete prototypes for sort_block_syms and
	sort_symtab_syms.
	* symfile.c: Delete functions sort_block_syms and
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Remove call to
	sort_symtab_syms.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.

2002-09-20  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (c-lang.o): Correct dependencies.
	(utils.o): Gather dependencies.
	(charset.o): Move.
@
text
@d3952 1
d3988 24
a4011 1
      ALL_BLOCK_SYMBOLS (block, i, sym)
d4017 10
a4026 2
		if (cmp == 0
		    && is_name_suffix (SYMBOL_NAME (sym) + name_len))
d4062 21
d4084 2
a4085 1
      ALL_BLOCK_SYMBOLS (block, i, sym)
d4101 10
a4110 2
		if (cmp == 0
		    && is_name_suffix (SYMBOL_NAME (sym) + name_len + 5))
@


1.9.2.2
log
@2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c (struct dict_vtbl): 'add_symbol' field.
	(add_symbol_generic): New function.
	(free_obstack): New function.
	(dict_create_hashed): New function.
	(lookup_hashed): New function.
	(iterator_first_hashed): New function.
	(iterator_hashed_advance): New function.
	(iterator_next_hashed): New function.
	* dictionary.h: A few more declarations.
	* mdebugread.c (parse_symbol): Use dict_iterator when finding
	parameters.
	* Makefile.in (valops.o): Depend on dictionary_h.
	* valops.c (value_of_this): Check empty block via dict_empty.
	#include "dictionary.h"
	* symfile.c (free_named_symtabs): Check empty block via dict_empty.
	* dictionary.h: Declare dict_empty.
	* symmisc.c (dump_symtab): Don't print out number of
	symbols/buckets.
	* printcmd.c (print_frame_args): Delete assertion that block isn't
	a hashtable.
	* symmisc.c (free_symtab_block): Update to use dictionary
	methods.
	* symtab.h (struct symtab): Comment on free_contents.
	* jv-lang.c (get_java_class_symtab): Set class_symtab->free_code.
	* mdebugread.c (add_symbol): Delete 'nsyms' variable.
	(fixup_sigtramp): Add symbol via dict_add_symbol_block.
	* Makefile.in (mi-cmd-stack.o): Depend on dictionary_h.
	* ada-lang.c (symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(ada_add_block_symbols): Ditto.
	(debug_print_block): Ditto.
	(fill_in_ada_prototype): Ditto.
	* breakpoint.c (get_catch_sals): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	(scope_info): Ditto.
	* symtab.c (find_pc_sect_symtab): Ditto.
	(search_symbols): Ditto.
	(make_symbol_completion_list): Ditto.
	(find_addr_symbol): Ditto.
	(make_file_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* symmisc.c (dump_symtab): Ditto.
	* stack.c (print_block_frame_locals): Ditto.
	(print_block_frame_labels): Ditto.
	(print_frame_arg_vars): Ditto.
	* printcmd.c (print_frame_args): Ditto.
	* objfiles.c (objfile_relocate): Ditto.
	* mdebugread.c (mylookup_symbol): Ditto.
	* Makefile.in (ada-lang.o): Depend on dictionary_h.
	* Makefile.in (tracepoint.o): Ditto.
	* Makefile.in (symmisc.o): Ditto.
	* Makefile.in (stack.o): Ditto.
	* Makefile.in (printcmd.o): Ditto.
	* Makefile.in (objfiles.o): Ditto.
	* Makefile.in (coffread.o): Ditto.
	* Makefile.in (breakpoint.o): Ditto.
	* ada-lang.c: #include "dictionary.h"
	* tracepoint.c: Ditto.
	* symmisc.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* coffread.c: Ditto.
	* breakpoint.c: Ditto.
	* symtab.h: Comment out ALL_BLOCK_SYMBOLS.  (Moved to
	dictionary.h.)
	* dictionary.c: Dict_iterator accessor macros.
	(struct dict_vtbl): Add iterator_first, iterator_next.
	(dict_iterator_first): New function.
	(dict_iterator_next): New function.
	(iterator_first_block): New function.
	(iterator_next_block): New function.
	(iterator_block_hashed_advance): New function.
	* dictionary.h: Add dict_iterator stuff.
	* Makefile.in (symtab.o): Depend on dictionary_h.
	* symtab.c: #include "dictionary.h"
	* dictionary.c: Move down #include "dictionary.h", for now...
	(free_block): Rename from dict_free_block.
	(struct dict_vtbl): Add LOOKUP member.
	(dict_lookup): New function.
	(lookup_block): New function.
	* dictionary.h: Declare dict_lookup.
	* symtab.c (lookup_block_symbol): Use dict_lookup.

2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c (list_args_or_locals): Update use of
	ALL_BLOCK_SYMBOLS.
	#include "dictionary.h"
@
text
@a38 1
#include "dictionary.h"
d3434 1
a3434 2
  int j;
  struct dict_iterator iter;
d3448 2
a3449 3
	ALL_BLOCK_SYMBOLS (b, iter, tmp_sym)
	  if (sym == tmp_sym)
	    return s;
d3451 2
a3452 3
	ALL_BLOCK_SYMBOLS (b, iter, tmp_sym)
	  if (sym == tmp_sym)
	    return s;
d3473 2
a3474 3
	    ALL_BLOCK_SYMBOLS (b, iter, tmp_sym)
	      if (sym == tmp_sym)
		return s;
d3946 1
a3946 1
  struct dict_iterator;
d3959 1
a3959 1
      ALL_BLOCK_SYMBOLS (block, iter, sym)
d3987 1
a3987 1
      ALL_BLOCK_SYMBOLS (block, iter, sym)
d4031 1
a4031 1
      ALL_BLOCK_SYMBOLS (block, iter, sym)
d4033 2
d4094 1
a4094 1
  struct dict_iterator iter;
d4120 1
a4120 1
  ALL_BLOCK_SYMBOLS (b, iter, sym)
d4690 2
a4691 2
  struct dict_iterator iter;
  struct symbol *sym;
d4700 1
a4700 1
  ALL_BLOCK_SYMBOLS (b, iter, sym)
d4702 2
a4703 1
    fprintf (stderr, "\n\t\t    ");
@


1.9.2.3
log
@2002-09-24  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c: Comment out block-specific stuff.
	* jv-lang.c (get_java_class_symtab): Allocate GLOBAL_BLOCK on
	obstack.
	(free_class_block): Don't free GLOBAL_BLOCK.
	* dictionary.h: Comment out block-specific stuff.
	* symtab.h: Comment out the members of struct block that
	BLOCK_DICT obsoletes, and their accessors.
	* Makefile.in (buildsym.o): Depend on gdb_assert_h.
	* buildsym.c (finish_block): Don't count number of symbols.
	(finish_block): Replace BLOCK_SYM reference with use of iterator.
	#include "gdb_assert.h"
	* symfile.c (free_named_symtabs): Fix calls to dict_empty
	(which would seem to be #if'd out; oops...).
	* buildsym.c (finish_block): Don't set BLOCK_HASHTABLE.
	* jv-lang.c (get_java_class_symtab): Don't set BLOCK_HASHTABLE and
	BLOCK_NSYMS.
	* mdebugread.c (new_block): Allocate BLOCK_DICT via
	dict_create_linear_expandable.
	(add_symbol): Add symbol via dict_add_symbol; no need to chase
	pointers.
	(fixup_sigtramp): Add symbol via dict_add_symbol.
	(new_symtab): Add FIXME comment on freeing blocks.
	* jv-lang.c (get_java_class_symtab): Allocate GLOBAL_BLOCK's dict
	using dict_create_linear_expandable.
	(add_class_symtab_symbol): Add symbol using dict_add_symbol.
	* dictionary.c (struct dictionary_linear_expandable): New struct.
	(struct dictionary): Added member 'linear_expandable'.
	(DICT_LINEAR_EXPANDABLE_MAXSYMS): New macro.
	New variable dict_block_vtbl.  Made all the _vtbl variables static.
	Renamed all 'maxsyms' to 'capacity'.
	(dict_create_linear_expandable): New function.
	(add_symbol_linear_expandable): New function.
	(free_linear_expandable): New function.
	* jv-lang.c (get_java_class_symtab): Create static block's
	dictionary with dict_create_linear.
	* buildsym.c (finish_block): Create function blocks' dictionaries
	with dict_create_linear.
	* dictionary.c (lookup_linear): New function.
	(iterator_first_linear): New function.
	(iterator_next_linear): New function.
	* dictionary.h: Moved comment.
	* dictionary.c (struct dictionary_linear): New struct.
	(struct dictionary): Added 'linear' member.
	(DICT_LINEAR_NSYMS): New macro.
	(DICT_LINEAR_SYMS): New macro.
	(DICT_LINEAR_SYM): New macro.
	New variable dict_linear_vtbl.
	(dict_create_linear): New function.
@
text
@d3951 1
a3951 1
  struct dict_iterator iter;
@


1.9.2.4
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a26 1
#include "block.h"
@


1.9.2.5
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d4340 1
a4340 1
      init_sal (&val);
d4482 1
a4482 1
  init_sal (&sals.sals[0]);
d4800 1
a4800 1
	init_sal (&result.sals[result.nelts]);
@


1.9.2.6
log
@2002-10-28  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (dl1_initialize_defaults): New function.
	(dl1_indirect): Ditto.
	(dl1_set_flags): Ditto.
	(dl1_locate_first_half): Ditto.
	(decode_line_1): Call the above functions.
	* symtab.c (lookup_symbol_aux_minsyms): Add block_index argument,
	and delete is_a_field_of_this argument.
	(lookup_symbol_aux_nonlocal): Add call to
	lookup_symbol_aux_minsyms, and expand HP comment.
	(lookup_symbol_aux): Delete calls to lookup_symbol_aux_minsyms.
	Expand on comment before lookup_transparent_type.
@
text
@d3183 2
a3184 2

  sym = lookup_symbol (name, (struct block *) NULL, namespace, 0, NULL);
@


1.9.2.7
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a4133 1
	TYPE_FIELD_STATIC_KIND (ftype, nargs) = 0;
a4146 1
	TYPE_FIELD_STATIC_KIND (ftype, nargs) = 0;
d4984 1
a4984 1
		      && !deprecated_frame_in_dummy (fi->next));
a5989 1
      TYPE_FIELD_STATIC_KIND (rtype, f) = 0;
a6092 1
      TYPE_FIELD_STATIC_KIND (type, f) = 0;
a6161 1
      TYPE_FIELD_STATIC_KIND (rtype, nfields - 1) = 0;
@


1.9.2.8
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d2619 1
a2619 1
			     SYMBOL_PRINT_NAME (syms[i]),
d2636 1
a2636 1
			       SYMBOL_PRINT_NAME (syms[i]),
d2643 1
a2643 1
				 SYMBOL_PRINT_NAME (syms[i]));
d2650 1
a2650 1
			       SYMBOL_PRINT_NAME (syms[i]),
d2657 1
a2657 1
			       SYMBOL_PRINT_NAME (syms[i]));
d4419 1
a4419 1
					SYMBOL_BEST_NAME (symbols[i]));
@


1.9.2.9
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d3545 1
a3545 1
  frame = deprecated_selected_frame;
d4976 11
a4986 1
      find_frame_sal (fi, &sal);
d4997 1
a4997 1
	  deprecated_selected_frame = fi;
@


1.9.2.10
log
@2003-01-20  David Carlton  <carlton@@math.stanford.edu>

	* p-exp.y: Add block to OP_FUNCALL.
	* objc-exp.y: Add block to OP_FUNCALL.
	* m2-exp.y: Add block to OP_FUNCALL.
	* c-exp.y: Add block to OP_FUNCALL.
	* ada-exp.y: Add block to OP_FUNCALL.
	(write_object_renaming): Ditto.
	* parse.c (length_of_subexp): Split off OP_FUNCALL.
	(prefixify_subexp): Ditto.
	* expprint.c (print_subexp): Change offset for OP_FUNCALL.
	(dump_subexp): Ditto.
	* eval.c (evaluate_subexp_standard): Change offset for
	OP_FUNCALL.
	* ada-lang.c (ada_resolve_subexp): Add comment on OP_FUNCALL.
	(replace_operator_with_call): Add block to OP_FUNCALL.
	(ada_evaluate_subexp): Change offset for OP_FUNCALL.
	* expression.h (exp_opcode): Change comments before OP_FUNCALL and
	OP_F77_UNDETERMINED_ARGLIST.

2003-01-14  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (search_symbols): Add comment.
	(lookup_symbol_aux_using): Function name should start line.
	(lookup_symbol_aux_using_loop): Ditto.
	(lookup_block_symbol): Add comment.

2003-01-13  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Add comment.
	(add_partial_structure): Ditto.
	* symtab.c (lookup_transparent_type): Add comment.
@
text
@a1975 3
      /* FIXME: carlton/2002-01-20: I don't understand this well
	 enough to know if it should be changed after I added the
	 current block to an OP_FUNCALL.  */
a2789 1
  newexp->elts[pc + 2].block = block;
d2791 3
a2793 3
  newexp->elts[pc + 4].opcode = newexp->elts[pc + 6].opcode = OP_VAR_VALUE;
  newexp->elts[pc + 5].block = block;
  newexp->elts[pc + 6].symbol = sym;
d6995 1
a6995 1
      (*pos) += 3;
@


1.9.2.11
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d41 1
d43 1
d5002 1
d5040 1
@


1.9.2.12
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 2
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003
   Free Software Foundation, Inc.
d27 1
a41 1
#include "block.h"
d710 1
a710 1
    return is_suppressed_name (DEPRECATED_SYMBOL_NAME (sym));
a2177 2
   case LOC_COMPUTED:
   case LOC_COMPUTED_ARG:
d2569 2
a2570 2
	  if (mangled_ordered_before (DEPRECATED_SYMBOL_NAME (syms[j]),
				      DEPRECATED_SYMBOL_NAME (sym)))
d3247 2
a3248 2
	char *name0 = DEPRECATED_SYMBOL_NAME (sym0);
	char *name1 = DEPRECATED_SYMBOL_NAME (sym1);
d3326 1
a3326 1
	      wild_match (name, name_len, DEPRECATED_SYMBOL_NAME (psym)))
d3342 1
a3342 1
	      if (DEPRECATED_SYMBOL_NAME (psym)[0] < name[0])
d3344 1
a3344 1
	      else if (DEPRECATED_SYMBOL_NAME (psym)[0] > name[0])
d3346 1
a3346 1
	      else if (strcmp (DEPRECATED_SYMBOL_NAME (psym), name) < 0)
d3361 1
a3361 1
	      int cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (psym), name_len);
d3369 1
a3369 1
		       && is_name_suffix (DEPRECATED_SYMBOL_NAME (psym) + name_len))
d3384 1
a3384 1
	      if (DEPRECATED_SYMBOL_NAME (psym)[0] < '_')
d3386 1
a3386 1
	      else if (DEPRECATED_SYMBOL_NAME (psym)[0] > '_')
d3388 1
a3388 1
	      else if (strcmp (DEPRECATED_SYMBOL_NAME (psym), "_ada_") < 0)
d3405 1
a3405 1
	      cmp = (int) '_' - (int) DEPRECATED_SYMBOL_NAME (psym)[0];
d3408 1
a3408 1
		  cmp = strncmp ("_ada_", DEPRECATED_SYMBOL_NAME (psym), 5);
d3410 1
a3410 1
		    cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (psym) + 5, name_len);
d3419 1
a3419 1
		       && is_name_suffix (DEPRECATED_SYMBOL_NAME (psym) + name_len + 5))
a3475 2
      case LOC_COMPUTED:
      case LOC_COMPUTED_ARG:
d3504 1
a3504 1
    if (ada_match_name (DEPRECATED_SYMBOL_NAME (msymbol), name, wild_match)
d3538 1
a3538 1
      DEPRECATED_SYMBOL_NAME (static_link) = "";
d3607 1
a3607 1
      if (DEPRECATED_SYMBOL_NAME (syms[i]) != NULL
d3614 2
a3615 2
		  && DEPRECATED_SYMBOL_NAME (syms[j]) != NULL
		  && STREQ (DEPRECATED_SYMBOL_NAME (syms[i]), DEPRECATED_SYMBOL_NAME (syms[j]))
d3710 1
a3710 1
	if (ada_match_name (DEPRECATED_SYMBOL_NAME (msymbol), name, wild_match))
d3725 1
a3725 1
					   DEPRECATED_SYMBOL_NAME (msymbol),
d3731 1
a3731 1
					       DEPRECATED_SYMBOL_NAME (msymbol),
d3970 1
a3970 1
	    wild_match (name, name_len, DEPRECATED_SYMBOL_NAME (sym)))
a3979 1
	      case LOC_COMPUTED_ARG:
d3999 1
a3999 1
		int cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (sym), name_len);
d4002 1
a4002 1
		    && is_name_suffix (DEPRECATED_SYMBOL_NAME (sym) + name_len))
a4011 1
		      case LOC_COMPUTED_ARG:
d4045 1
a4045 1
		cmp = (int) '_' - (int) DEPRECATED_SYMBOL_NAME (sym)[0];
d4048 1
a4048 1
		    cmp = strncmp ("_ada_", DEPRECATED_SYMBOL_NAME (sym), 5);
d4050 1
a4050 1
		      cmp = strncmp (name, DEPRECATED_SYMBOL_NAME (sym) + 5, name_len);
d4054 1
a4054 1
		    && is_name_suffix (DEPRECATED_SYMBOL_NAME (sym) + name_len + 5))
a4063 1
		      case LOC_COMPUTED_ARG:
d4139 1
a4139 1
	TYPE_FIELD_NAME (ftype, nargs) = DEPRECATED_SYMBOL_NAME (sym);
a4147 1
      case LOC_COMPUTED_ARG:
d4152 1
a4152 1
	TYPE_FIELD_NAME (ftype, nargs) = DEPRECATED_SYMBOL_NAME (sym);
d4421 1
a4421 1
					SYMBOL_PRINT_NAME (symbols[i]));
d4704 1
a4704 1
    fprintf (stderr, " Function: %s", DEPRECATED_SYMBOL_NAME (BLOCK_FUNCTION (b)));
d4710 2
a4711 3
    if (i > 0 && i % 4 == 0)
      fprintf (stderr, "\n\t\t    ");
    fprintf (stderr, " %s", DEPRECATED_SYMBOL_NAME (sym));
@


1.9.2.13
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a8027 2
  NULL,				/* Language specific skip_trampoline */
  NULL,				/* Language specific symbol demangler */
@


1.9.2.14
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@a42 1
#include "infcall.h"
@


1.9.2.15
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d94 1
a94 1
				   domain_enum, struct objfile *, int);
d104 1
a104 1
							 domain_enum, int);
d193 1
a193 1
static struct symbol *standard_lookup (const char *, domain_enum);
d709 1
a709 1
  if (SYMBOL_DOMAIN (sym) == STRUCT_DOMAIN)
d1236 1
a1236 1
			      VAR_DOMAIN, &syms, &blocks);
d2158 1
a2158 1
         VAR_DOMAIN,
d2260 1
a2260 1
	   VAR_DOMAIN,
d2314 1
a2314 1
				    (struct block *) NULL, VAR_DOMAIN,
d3183 1
a3183 1
 * given DOMAIN. */
d3186 1
a3186 1
standard_lookup (const char *name, domain_enum domain)
d3190 1
a3190 1
  sym = lookup_symbol (name, (struct block *) NULL, domain, 0, NULL);
d3239 1
a3239 1
  if (SYMBOL_DOMAIN (sym0) != SYMBOL_DOMAIN (sym1)
d3301 1
a3301 1
/* Look, in partial_symtab PST, for symbol NAME in given domain.
d3307 1
a3307 1
			   int global, domain_enum domain, int wild)
d3329 1
a3329 1
	  if (SYMBOL_DOMAIN (psym) == domain &&
d3363 1
a3363 1
	  if (SYMBOL_DOMAIN (psym) == domain)
d3405 1
a3405 1
	  if (SYMBOL_DOMAIN (psym) == domain)
d3519 1
a3519 1
 * selected frame, add symbols matching identifier NAME in DOMAIN
d3528 1
a3528 1
add_symbols_from_enclosing_procs (const char *name, domain_enum domain,
d3547 1
a3547 1
      SYMBOL_DOMAIN (static_link) = VAR_DOMAIN;
d3578 1
a3578 1
	  ada_add_block_symbols (block, name, domain, NULL, wild_match);
d3644 1
a3644 1
/* Find symbols in DOMAIN matching NAME, in BLOCK0 and enclosing 
d3657 1
a3657 1
			domain_enum domain, struct symbol ***syms,
d3683 1
a3683 1
      ada_add_block_symbols (block, name, domain, NULL, wild_match);
d3709 1
a3709 1
    ada_add_block_symbols (block, name, domain, objfile, wild_match);
d3712 1
a3712 1
  if (domain == VAR_DOMAIN)
d3732 1
a3732 1
					   domain, objfile, wild_match);
d3738 1
a3738 1
					       domain, objfile,
d3751 1
a3751 1
	&& ada_lookup_partial_symbol (ps, name, 1, domain, wild_match))
d3758 1
a3758 1
	ada_add_block_symbols (block, name, domain, objfile, wild_match);
d3776 1
a3776 1
	ada_add_block_symbols (block, name, domain, objfile, wild_match);
d3783 1
a3783 1
	    && ada_lookup_partial_symbol (ps, name, 0, domain, wild_match))
d3790 1
a3790 1
	    ada_add_block_symbols (block, name, domain,
d3801 1
a3801 1
      add_symbols_from_enclosing_procs (name, domain, wild_match);
d3818 1
a3818 1
/* Return a symbol in DOMAIN matching NAME, in BLOCK0 and enclosing 
d3826 1
a3826 1
		   domain_enum domain)
d3833 1
a3833 1
					 block0, domain,
d3949 1
a3949 1
/* Add symbols from BLOCK matching identifier NAME in DOMAIN to 
d3957 1
a3957 1
		       domain_enum domain, struct objfile *objfile,
d3975 1
a3975 1
	if (SYMBOL_DOMAIN (sym) == domain &&
d4004 1
a4004 1
	    if (SYMBOL_DOMAIN (sym) == domain)
d4049 1
a4049 1
	    if (SYMBOL_DOMAIN (sym) == domain)
d4336 1
a4336 1
					VAR_DOMAIN, &symbols, &blocks);
d4339 1
a4339 1
					VAR_DOMAIN, &symbols, &blocks);
d4585 1
a4585 1
		    standard_lookup (func_name, VAR_DOMAIN);
d4659 1
a4659 1
		    standard_lookup (func_name, VAR_DOMAIN);
d5803 1
a5803 1
  sym = standard_lookup (name, VAR_DOMAIN);
d5807 1
a5807 1
  sym = standard_lookup (name, STRUCT_DOMAIN);
d7769 1
a7769 1
    ada_lookup_symbol_list (name, get_selected_block (NULL), VAR_DOMAIN,
a8029 2
  value_of_this,		/* value_of_this */
  basic_lookup_symbol_nonlocal,	/* lookup_symbol_nonlocal  */
@


1.9.2.16
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a43 1
#include "dictionary.h"
d3189 1
d3442 1
a3443 1
  int j;
d3457 3
a3459 2
	ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
	  return s;
d3461 3
a3463 2
	ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
	  return s;
d3486 3
a3488 2
	    ALL_BLOCK_SYMBOLS (b, iter, tmp_sym) if (sym == tmp_sym)
	      return s;
d3570 1
a3570 1
      while (frame != NULL && DEPRECATED_FRAME_LOCALS_ADDRESS (frame) != target_link);
d4720 2
d7721 1
a7721 1
scan_discrim_bound (char *str, int k, struct value *dval, LONGEST * px,
@


1.9.2.17
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d3030 1
a3030 1
#ifdef DEPRECATED_STACK_ALIGN
d3032 1
a3032 1
		    DEPRECATED_STACK_ALIGN (TYPE_LENGTH
@


1.9.2.18
log
@2003-09-19  David Carlton  <carlton@@kealia.com>

	* expression.h (enum exp_opcode): Revert to mainline's OP_FUNCALL,
	OP_SCOPE.
	* ada-exp.y, m2-exp.y, objc-exp.y, p-exp.y: Ditto.
	* jv-exp.y (push_qualified_expression_name): Ditto.
	* ada-lang.c (ada_resolve_subexp, replace_operator_with_call)
	(ada_evaluate_subexp): Ditto.
	* eval.c (evaluate_subexp_standard): Ditto.
	* expprint.c (print_subexp, dump_subexp): Ditto.
	* parse.c (length_of_subexp, prefixify_subexp): Ditto.
	* c-exp.y: Ditto, and add comment.
	* cp-support.c (make_symbol_overload_list): Delete 'block'
	argument; change calls to make_symbol_overload_list_using
	appropriately.
	(make_symbol_overload_list_using): Delete 'block' argument;
	replace it by get_selected_block (0).
	* cp-support.h: Delete 'block' argument from
	make_symbol_overload_list.
	* valops.c (find_overload_match): Delete 'block' argument, and
	update calls using it.
	(find_oload_champ_namespace, find_oload_champ_namespace_loop)
	(value_aggregate_elt, value_struct_elt_for_reference)
	(value_namespace_elt): Ditto.
	(value_maybe_namespace_elt): Delete 'block' argument, and use
	get_selected_block (0) instead.
	* value.h: Delete 'block' argument from value_struct_elt,
	value_find_oload.
@
text
@d1977 3
d2796 1
d2798 3
a2800 3
  newexp->elts[pc + 3].opcode = newexp->elts[pc + 6].opcode = OP_VAR_VALUE;
  newexp->elts[pc + 4].block = block;
  newexp->elts[pc + 5].symbol = sym;
d7001 1
a7001 1
      (*pos) += 2;
@


1.9.2.19
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a8038 1
  default_word_break_characters,
@


1.9.2.20
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d257 1
a257 1
    DEPRECATED_STREQN (field_name, target, len)
d259 2
a260 2
	|| (DEPRECATED_STREQN (field_name + len, "___", 3)
	    && !DEPRECATED_STREQ (field_name + strlen (field_name) - 6, "___XVN")));
d290 1
a290 1
  return (len1 >= len2 && DEPRECATED_STREQ (str + len1 - len2, suffix));
d441 1
a441 1
  if (DEPRECATED_STREQN (str, "_ada_", 5))
d462 1
a462 1
	      if (DEPRECATED_STREQN (ada_opname_table[i].mangled, p,
d502 1
a502 1
	       !DEPRECATED_STREQN (mapping->demangled, p, strlen (mapping->demangled));
d573 1
a573 1
  if (DEPRECATED_STREQN (mangled, "_ada_", 5))
d589 1
a589 1
  if (len0 > 3 && DEPRECATED_STREQ (mangled + len0 - 3, "TKB"))
d591 1
a591 1
  if (len0 > 1 && DEPRECATED_STREQ (mangled + len0 - 1, "B"))
d620 1
a620 1
	      if (DEPRECATED_STREQN
d636 1
a636 1
      if (i < len0 - 4 && DEPRECATED_STREQN (mangled + i, "TK__", 4))
d696 1
a696 1
      return (DEPRECATED_STREQN (sym_name, name, len_name)
d698 2
a699 2
	|| (DEPRECATED_STREQN (sym_name, "_ada_", 5)
	    && DEPRECATED_STREQN (sym_name + 5, name, len_name)
d1240 1
a1240 1
	&& DEPRECATED_STREQ (name, ada_type_name (SYMBOL_TYPE (syms[i]))))
d2549 1
a2549 1
	  if (n0 == n1 && DEPRECATED_STREQN (N0, N1, n0))
d3221 1
a3221 1
      && DEPRECATED_STREQ (ada_type_name (type0), ada_type_name (type1)))
d3253 2
a3254 2
	      || (len0 < strlen (name1) && DEPRECATED_STREQN (name0, name1, len0)
		  && DEPRECATED_STREQN (name1 + len0, "___XV", 5)));
d3587 1
a3587 1
  return (name != NULL && DEPRECATED_STREQ (name, "<variable, no debug info>"));
d3614 1
a3614 1
		  && DEPRECATED_STREQ (DEPRECATED_SYMBOL_NAME (syms[i]), DEPRECATED_SYMBOL_NAME (syms[j]))
d3867 1
a3867 1
	  if (DEPRECATED_STREQ (str + 3, "LJM"))
d3904 2
a3905 2
  if (name_len >= patn_len + 5 && DEPRECATED_STREQN (name, "_ada_", 5)
      && DEPRECATED_STREQN (patn, name + 5, patn_len)
d3911 1
a3911 1
      if (DEPRECATED_STREQN (patn, name, patn_len) && is_name_suffix (name + patn_len))
d4458 1
a4458 1
    if (!DEPRECATED_STREQ (filename, s->filename))
d4756 1
a4756 1
    if (DEPRECATED_STREQ (filename, ps->filename))
d4787 1
a4787 1
    if (!DEPRECATED_STREQ (s->filename, filename))
d4965 3
a4967 3
  return (DEPRECATED_STREQN (filename, "s-", 2) ||
	  DEPRECATED_STREQN (filename, "a-", 2) ||
	  DEPRECATED_STREQN (filename, "g-", 2) || DEPRECATED_STREQN (filename, "i-", 2));
d4988 1
a4988 1
	      DEPRECATED_STREQ (sal.symtab->objfile->name, "/usr/shlib/libpthread.so"))
d5049 1
a5049 1
	  && type_name != NULL && DEPRECATED_STREQ (type_name, "exception"));
d5072 1
a5072 1
     && DEPRECATED_STREQN (arg, "exception", 9) &&
d5097 1
a5097 1
     else if (DEPRECATED_STREQN (tok, "unhandled", toklen))
d5110 1
a5110 1
     && DEPRECATED_STREQN (arg, "assert", 6) &&
d5142 1
a5142 1
	      || (name[0] == '_' && !DEPRECATED_STREQN (name, "_parent", 7)));
d5201 1
a5201 1
	  (DEPRECATED_STREQN (name, "PARENT", 6) || DEPRECATED_STREQN (name, "_parent", 7)));
d5215 2
a5216 2
	  && (DEPRECATED_STREQN (name, "PARENT", 6) || DEPRECATED_STREQ (name, "REP")
	      || DEPRECATED_STREQN (name, "_parent", 7)
d5287 1
a5287 1
      if (DEPRECATED_STREQN (discrim_end, "___XVN", 6))
d5298 1
a5298 1
      if ((discrim_start > name + 3 && DEPRECATED_STREQN (discrim_start - 3, "___", 3))
d5782 1
a5782 1
  if (align_offset < 7 || !DEPRECATED_STREQN ("___XV", name + align_offset - 6, 5))
d5886 1
a5886 1
      if (len > 6 && DEPRECATED_STREQ (ada_type_name (type) + len - 6, "___XVE"))
d6551 2
a6552 2
    && (DEPRECATED_STREQ (name, "character") || DEPRECATED_STREQ (name, "wide_character")
	|| DEPRECATED_STREQ (name, "unsigned char"));
d6585 1
a6585 1
	  && DEPRECATED_STREQ (TYPE_FIELD_NAME (type, 0), "F"));
d7672 1
a7672 1
    && DEPRECATED_STREQN (ada_type_name (type) + name_len - 6, "___XF", 5);
@


1.9.2.21
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 1
a2 1
   1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004
a8022 1
  basic_lookup_transparent_type,/* lookup_transparent_type */
@


1.8
log
@	* ada-lang.c: Use gdb_string.h instead of <string.h>.
	* ada-typeprint.c: Use gdb_string.h instead of <string.h>.
@
text
@d1855 1
a1855 4
ada_array_bound (arr, n, which)
     struct value *arr;
     int n;
     int which;
d2334 1
a2334 4
ada_type_match (ftype, atype, may_deref)
     struct type *ftype;
     struct type *atype;
     int may_deref;
d8101 1
a8101 1
_initialize_ada_language ()
@


1.8.6.1
log
@Import ada-lang.c, ada-tasks.c and ada-valprint.c from mainline.
@
text
@d1855 4
a1858 1
ada_array_bound (struct value *arr, int n, int which)
d2337 4
a2340 1
ada_type_match (struct type *ftype, struct type *atype, int may_deref)
d8107 1
a8107 1
_initialize_ada_language (void)
@


1.7
log
@        * ada-lang.c: run through gdb_indent.sh
        * ada-lang.h: run through gdb_indent.sh
        * ada-tasks.c: run through gdb_indent.sh
        * ada-typeprint.c: run through gdb_indent.sh
        * ada-valprint.c: run through gdb_indent.sh
@
text
@d21 1
a21 1
#include <string.h>
@


1.6
log
@	* ada-lang.c (ada_lookup_partial_symbol)
	(to_fixed_variant_branch_type) (find_line_in_linetable): Fix
	prototype names so that grep ^func works properly.

	* ada-lang.c (ada_array_element_type)
	(ada_lookup_partial_symbol): Fix typos in parameter list.

	* ada-valprint.c (val_print_packed_array_elements) (ada_val_print_1):
	Fix prototype names so that grep ^func works properly.
@
text
@d43 1
a43 1
struct cleanup* unresolved_names;
d47 1
a47 1
static struct type * ada_create_fundamental_type (struct objfile *, int);
d51 1
a51 1
static struct type* desc_base_type (struct type*);
d53 1
a53 1
static struct type* desc_bounds_type (struct type*);
d55 1
a55 1
static struct value* desc_bounds (struct value*);
d57 1
a57 1
static int fat_pntr_bounds_bitpos (struct type*);
d59 1
a59 1
static int fat_pntr_bounds_bitsize (struct type*);
d61 1
a61 1
static struct type* desc_data_type (struct type*);
d63 1
a63 1
static struct value* desc_data (struct value*);
d65 1
a65 1
static int fat_pntr_data_bitpos (struct type*);
d67 1
a67 1
static int fat_pntr_data_bitsize (struct type*);
d69 1
a69 1
static struct value* desc_one_bound (struct value*, int, int);
d71 1
a71 1
static int desc_bound_bitpos (struct type*, int, int);
d73 1
a73 1
static int desc_bound_bitsize (struct type*, int, int);
d75 1
a75 1
static struct type*  desc_index_type (struct type*, int);
d77 1
a77 1
static int desc_arity (struct type*);
d79 1
a79 1
static int ada_type_match (struct type*, struct type*, int);
d81 1
a81 1
static int ada_args_match (struct symbol*, struct value**, int);
d83 1
a83 1
static struct value* place_on_stack (struct value*, CORE_ADDR*);
d85 2
a86 1
static struct value* convert_actual (struct value*, struct type*, CORE_ADDR*);
d88 2
a89 1
static struct value* make_array_descriptor (struct type*, struct value*, CORE_ADDR*);
d91 2
a92 2
static void ada_add_block_symbols (struct block*, const char*,
				   namespace_enum, struct objfile*, int);
d94 1
a94 1
static void fill_in_ada_prototype (struct symbol*);
d96 1
a96 1
static int is_nonfunction (struct symbol**, int);
d98 1
a98 1
static void add_defn_to_vec (struct symbol*, struct block*);
d100 3
a102 2
static struct partial_symbol* ada_lookup_partial_symbol (struct partial_symtab*, const char*, 
							 int, namespace_enum, int);
d104 1
a104 1
static struct symtab* symtab_for_sym (struct symbol*);
d106 2
a107 1
static struct value* ada_resolve_subexp (struct expression**, int*, int, struct type*);
d109 2
a110 2
static void replace_operator_with_call (struct expression**, int, int, int,
					struct symbol*, struct block*);
d112 1
a112 1
static int possible_user_operator_p (enum exp_opcode, struct value**);
d114 1
a114 1
static const char* ada_op_name (enum exp_opcode);
d116 1
a116 1
static int numeric_type_p (struct type*);
d118 1
a118 1
static int integer_type_p (struct type*);
d120 1
a120 1
static int scalar_type_p (struct type*);
d122 1
a122 1
static int discrete_type_p (struct type*);
d124 2
a125 1
static char* extended_canonical_line_spec (struct symtab_and_line, const char*);
d127 2
a128 1
static struct value* evaluate_subexp (struct type*, struct expression*, int*, enum noside);
d130 1
a130 1
static struct value* evaluate_subexp_type (struct expression*, int*);
d132 1
a132 1
static struct type * ada_create_fundamental_type (struct objfile*, int);
d134 1
a134 1
static int  is_dynamic_field (struct type *, int);
d136 2
a137 1
static struct type* to_fixed_variant_branch_type (struct type*, char*, CORE_ADDR, struct value*);
d139 2
a140 1
static struct type* to_fixed_range_type (char*, struct value*, struct objfile*);
d142 1
a142 1
static struct type* to_static_fixed_type (struct type*);
d144 1
a144 1
static struct value* unwrap_value (struct value*);
d146 1
a146 1
static struct type* packed_array_type (struct type*, long*);
d148 1
a148 1
static struct type* decode_packed_array_type (struct type*);
d150 1
a150 1
static struct value* decode_packed_array (struct value*);
d152 2
a153 1
static struct value* value_subscript_packed (struct value*, int, struct value**);
d155 2
a156 1
static struct value* coerce_unspec_val_to_type (struct value*, long, struct type*);
d158 1
a158 1
static struct value* get_var_value (char*, char*);
d160 1
a160 1
static int lesseq_defined_than (struct symbol*, struct symbol*);
d162 1
a162 1
static int equiv_types (struct type*, struct type*);
d164 1
a164 1
static int is_name_suffix (const char*);
d166 1
a166 1
static int wild_match (const char*, int, const char*);
d168 4
a171 1
static struct symtabs_and_lines find_sal_from_funcs_and_line (const char*, int, struct symbol**, int);
d173 2
a174 1
static int find_line_in_linetable (struct linetable*, int, struct symbol**, int, int*);
d176 1
a176 1
static int find_next_line_in_linetable (struct linetable*, int, int, int);
d178 2
a179 1
static struct symtabs_and_lines all_sals_for_line (const char*, int, char***);
d181 1
a181 1
static void read_all_symtabs (const char*);
d183 1
a183 1
static int is_plausible_func_for_line (struct symbol*, int);
d185 1
a185 1
static struct value*  ada_coerce_ref (struct value*);
d187 1
a187 1
static struct value* value_pos_atr (struct value*);
d189 1
a189 1
static struct value* value_val_atr (struct type*, struct value*);
d191 1
a191 1
static struct symbol* standard_lookup (const char*, namespace_enum);
d195 1
a196 1

d201 1
a201 1
static const char* ada_completer_word_break_characters =
d217 1
a217 1
   int char_index = 0;
d219 9
a227 10
   /* Loop, reading one byte at a time, until we reach the '\000' 
      end-of-string marker */
   do
   {
     target_read_memory (addr + char_index * sizeof (char), 
                         buf + char_index * sizeof (char), 
                         sizeof (char));
     char_index++;
   }
   while (buf[char_index - 1] != '\000');
d235 1
a235 1
grow_vect (void** old_vect, size_t* size, size_t min_size, int element_size)
d237 7
a243 6
  if (*size < min_size) {
    *size *= 2;
    if (*size < min_size)
      *size = min_size;
    *old_vect = xrealloc (*old_vect, *size * element_size);
  }
d253 3
a255 3
  return 
    STREQN (field_name, target, len) 
    && (field_name[len] == '\0' 
d257 1
a257 1
	   && ! STREQ (field_name + strlen (field_name) - 6, "___XVN")));
d264 1
a264 1
ada_name_prefix_len (const char* name)
d268 1
a268 1
  else 
d270 1
a270 1
      const char* p = strstr (name, "___");
d280 1
a280 1
is_suffix (const char* str, const char* suffix)
d293 3
a295 2
struct value*
value_from_contents_and_address (struct type* type, char* valaddr, CORE_ADDR address)
d297 2
a298 2
  struct value* v = allocate_value (type);
  if (valaddr == NULL) 
d311 2
a312 2
static struct value*
coerce_unspec_val_to_type (struct value* val, long offset, struct type *type)
d317 3
a319 2
      VALUE_ADDRESS (val) + VALUE_OFFSET (val) + offset, NULL);
  else 
d321 1
a321 1
      struct value* result = allocate_value (type);
d323 1
a323 1
      if (VALUE_ADDRESS (val) == 0) 
d325 1
a325 1
		TYPE_LENGTH (type) > TYPE_LENGTH (VALUE_TYPE (val)) 
d327 1
a327 1
      else 
d329 1
a329 1
	  VALUE_ADDRESS (result) = 
d337 2
a338 2
static char*
cond_offset_host (char* valaddr, long offset)
d351 1
a351 1
  else 
d358 1
a358 1
do_command (const char* arg, ...)
d361 2
a362 2
  char* cmd;
  const char* s;
d369 1
a369 1
  for (; s != NULL; s = va_arg (ap, const char*)) 
d371 1
a371 1
      char* cmd1;
d373 1
a373 1
      cmd1 = alloca (len+1);
d381 1
a382 1

d389 1
a389 1
   
d391 2
a392 1
ada_update_initial_language (enum language lang, struct partial_symtab* main_pst)
d394 2
a395 2
  if (lookup_minimal_symbol ("adainit", (const char*) NULL,
			     (struct objfile*) NULL) != NULL)
a401 1
      
d403 1
d409 23
a431 24
const struct ada_opname_map ada_opname_table[] =
{
  { "Oadd", "\"+\"", BINOP_ADD },
  { "Osubtract", "\"-\"", BINOP_SUB },
  { "Omultiply", "\"*\"", BINOP_MUL },
  { "Odivide", "\"/\"", BINOP_DIV },
  { "Omod", "\"mod\"", BINOP_MOD },
  { "Orem", "\"rem\"", BINOP_REM },
  { "Oexpon", "\"**\"", BINOP_EXP },
  { "Olt", "\"<\"", BINOP_LESS },
  { "Ole", "\"<=\"", BINOP_LEQ },
  { "Ogt", "\">\"", BINOP_GTR },
  { "Oge", "\">=\"", BINOP_GEQ },
  { "Oeq", "\"=\"", BINOP_EQUAL },
  { "One", "\"/=\"", BINOP_NOTEQUAL },
  { "Oand", "\"and\"", BINOP_BITWISE_AND },
  { "Oor", "\"or\"", BINOP_BITWISE_IOR },
  { "Oxor", "\"xor\"", BINOP_BITWISE_XOR },
  { "Oconcat", "\"&\"", BINOP_CONCAT },
  { "Oabs", "\"abs\"", UNOP_ABS },
  { "Onot", "\"not\"", UNOP_LOGICAL_NOT },
  { "Oadd", "\"+\"", UNOP_PLUS },
  { "Osubtract", "\"-\"", UNOP_NEG },
  { NULL, NULL }
d436 1
a436 1
is_suppressed_name (const char* str) 
d444 2
a445 2
      const char* p;
      const char* suffix = strstr (str, "___");
d450 1
a450 1
      for (p = suffix-1; p != str; p -= 1)
d459 1
a459 1
	      if (STREQN (ada_opname_table[i].mangled, p, 
d463 1
a463 1
	  OK: ;
d472 1
a472 1
ada_mangle (const char* demangled)
d474 1
a474 1
  static char* mangling_buffer = NULL;
d476 1
a476 1
  const char* p;
d478 1
a478 1
  
d482 2
a483 1
  GROW_VECT (mangling_buffer, mangling_buffer_size, 2*strlen (demangled) + 10);
d488 1
a488 1
      if (*p == '.') 
d490 1
a490 1
	  mangling_buffer[k] = mangling_buffer[k+1] = '_';
d495 1
a495 1
	  const struct ada_opname_map* mapping;
d498 2
a499 2
	       mapping->mangled != NULL && 
	       ! STREQN (mapping->demangled, p, strlen (mapping->demangled));
d504 1
a504 1
	  strcpy (mangling_buffer+k, mapping->mangled);
d508 1
a508 1
      else 
d522 2
a523 2
char*
ada_fold_name (const char* name)
d525 1
a525 1
  static char* fold_buffer = NULL;
d529 1
a529 1
  GROW_VECT (fold_buffer, fold_buffer_size, len+1);
d533 2
a534 2
      strncpy (fold_buffer, name+1, len-2);
      fold_buffer[len-2] = '\000';
d560 1
a560 1
ada_demangle (const char* mangled)
d564 2
a565 2
  const char* p;
  char* demangled;
d567 1
a567 1
  static char* demangling_buffer = NULL;
d569 1
a569 1
  
d579 1
a579 1
  else 
d592 1
a592 1
  GROW_VECT (demangling_buffer, demangling_buffer_size, 2*len0+1);
d595 9
a603 8
  if (isdigit (mangled[len0 - 1])) {
    for (i = len0-2; i >= 0 && isdigit (mangled[i]); i -= 1)
      ;
    if (i > 1 && mangled[i] == '_' && mangled[i-1] == '_')
      len0 = i - 1;
    else if (mangled[i] == '$')
      len0 = i;
  }
d605 1
a605 1
  for (i = 0, j = 0; i < len0 && ! isalpha (mangled[i]); i += 1, j += 1)
d616 4
a619 3
	      int op_len = strlen (ada_opname_table[k].mangled); 
	      if (STREQN (ada_opname_table[k].mangled+1, mangled+i+1, op_len-1)
		  && ! isalnum (mangled[i + op_len]))
d633 1
a633 1
      if (i < len0-4 && STREQN (mangled+i, "TK__", 4))
d635 1
a635 1
      if (mangled[i] == 'X' && i != 0 && isalnum (mangled[i-1]))
d643 1
a643 1
      else if (i < len0-2 && mangled[i] == '_' && mangled[i+1] == '_') 
d647 2
a648 1
	  i += 2; j += 1;
d653 2
a654 1
	  i += 1;  j += 1;
d666 1
a666 2
  GROW_VECT (demangling_buffer, demangling_buffer_size, 
	     strlen (mangled) + 3);  
d684 1
a684 1
ada_match_name (const char* sym_name, const char* name, int wild)
d690 9
a698 8
  else {
    int len_name = strlen (name);
    return (STREQN (sym_name, name, len_name) 
	    && is_name_suffix (sym_name+len_name))
      ||   (STREQN (sym_name, "_ada_", 5) 
	    && STREQN (sym_name+5, name, len_name)
	    && is_name_suffix (sym_name+len_name+5));
  }
d709 1
a709 1
  else 
d712 1
a713 1

d719 2
a720 2
static char* bound_name[] = {
  "LB0", "UB0", "LB1", "UB1", "LB2", "UB2", "LB3", "UB3", 
d733 2
a734 3
  modify_field (addr + sizeof (LONGEST) * bitpos / (8 * sizeof (LONGEST)), 
		fieldval, bitpos % (8 * sizeof (LONGEST)), 
		bitsize);
d743 2
a744 2
static struct type*
desc_base_type (struct type* type)
d757 1
a757 1
is_thin_pntr (struct type* type)
d759 1
a759 1
  return 
d765 2
a766 2
static struct type*
thin_descriptor_type (struct type* type)
d768 1
a768 1
  struct type* base_type = desc_base_type (type);
d773 1
a773 1
  else 
d775 1
a775 2
      struct type* alt_type = 
	ada_find_parallel_type (base_type, "___XVE");
d784 2
a785 2
static struct value*
thin_data_pntr (struct value* val)
d787 1
a787 1
  struct type* type = VALUE_TYPE (val);
d789 1
a789 1
    return value_cast (desc_data_type (thin_descriptor_type (type)), 
d791 1
a791 1
  else	
d798 1
a798 1
is_thick_pntr (struct type* type) 
d807 2
a808 2
static struct type*
desc_bounds_type (struct type* type)
d810 1
a810 1
  struct type* r;
d836 2
a837 2
static struct value*
desc_bounds (struct value* arr)
d839 2
a840 2
  struct type* type = check_typedef (VALUE_TYPE (arr));
  if (is_thin_pntr (type)) 
d842 2
a843 1
      struct type* bounds_type = desc_bounds_type (thin_descriptor_type (type));
d850 2
a851 2
	 since desc_type is an XVE-encoded type (and shouldn't be),
	 the correct calculation is a real pain. FIXME (and fix GCC). */
d854 1
a854 1
      else 
d857 3
a859 3
      return 
	  value_from_longest (lookup_pointer_type (bounds_type), 
			      addr - TYPE_LENGTH (bounds_type));
d863 1
a863 1
    return value_struct_elt (&arr, NULL, "P_BOUNDS", NULL, 
d872 1
a872 1
fat_pntr_bounds_bitpos (struct type* type)
d880 1
a880 1
fat_pntr_bounds_bitsize (struct type* type)
d884 1
a884 1
  if (TYPE_FIELD_BITSIZE (type, 1) > 0) 
d894 2
a895 2
static struct type*
desc_data_type (struct type* type)
d901 2
a902 2
    return lookup_pointer_type 
      (desc_base_type (TYPE_FIELD_TYPE (thin_descriptor_type (type),1)));
d911 2
a912 2
static struct value*
desc_data (struct value* arr)
d914 1
a914 1
  struct type* type = VALUE_TYPE (arr);
d918 1
a918 1
    return value_struct_elt (&arr, NULL, "P_ARRAY", NULL, 
d928 1
a928 1
fat_pntr_data_bitpos (struct type* type)
d936 1
a936 1
fat_pntr_data_bitsize (struct type* type)
d942 1
a942 1
  else 
d949 2
a950 2
static struct value*
desc_one_bound (struct value* bounds, int i, int which)
d952 1
a952 1
  return value_struct_elt (&bounds, NULL, bound_name[2*i+which-2], NULL,
d960 1
a960 1
desc_bound_bitpos (struct type* type, int i, int which)
d962 1
a962 1
  return TYPE_FIELD_BITPOS (desc_base_type (type), 2*i+which-2);
d969 1
a969 1
desc_bound_bitsize (struct type* type, int i, int which)
d973 4
a976 4
  if (TYPE_FIELD_BITSIZE (type, 2*i+which-2) > 0)
    return TYPE_FIELD_BITSIZE (type, 2*i+which-2);
  else 
    return 8 * TYPE_LENGTH (TYPE_FIELD_TYPE (type, 2*i+which-2));
d980 3
a982 3
   Ith bound (numbering from 1). Otherwise, NULL. */ 
static struct type* 
desc_index_type (struct type* type, int i)
d987 2
a988 2
    return lookup_struct_elt_type (type, bound_name[2*i-2], 1);
  else 
d995 1
a995 1
desc_arity (struct type* type)
d1007 1
a1007 1
ada_is_simple_array (struct type* type)
d1019 1
a1019 1
ada_is_array_descriptor (struct type* type)
d1021 1
a1021 1
  struct type* data_type = desc_data_type (type);
d1026 1
a1026 1
  return 
d1031 1
a1031 1
	|| 
d1043 1
a1043 1
  return 
d1048 1
a1048 1
    && ! ada_is_array_descriptor (type);
d1059 2
a1060 2
struct type*
ada_type_of_array (struct value* arr, int bounds)
d1065 1
a1065 1
  if (! ada_is_array_descriptor (VALUE_TYPE (arr)))
d1067 4
a1070 3
  
  if (! bounds)
    return check_typedef (TYPE_TARGET_TYPE (desc_data_type (VALUE_TYPE (arr))));
d1073 1
a1073 1
      struct type* elt_type;
d1075 1
a1075 1
      struct value* descriptor;
d1081 1
a1081 1
      if (elt_type == NULL || arity == 0) 
d1085 1
a1085 1
      if (value_as_long (descriptor) == 0) 
d1087 13
a1099 12
      while (arity > 0) {
	struct type* range_type = alloc_type (objf);
	struct type* array_type = alloc_type (objf);
	struct value* low = desc_one_bound (descriptor, arity, 0);
	struct value* high = desc_one_bound (descriptor, arity, 1);
	arity -= 1;

	create_range_type (range_type, VALUE_TYPE (low), 
			   (int) value_as_long (low), 
			   (int) value_as_long (high));
	elt_type = create_array_type (array_type, elt_type, range_type);
      }
d1109 2
a1110 2
struct value*
ada_coerce_to_simple_array_ptr (struct value* arr)
d1114 1
a1114 1
      struct type* arrType = ada_type_of_array (arr, 1);
d1128 2
a1129 2
struct value*
ada_coerce_to_simple_array (struct value* arr)
d1133 1
a1133 1
      struct value* arrVal = ada_coerce_to_simple_array_ptr (arr);
d1140 1
a1140 1
  else 
d1147 2
a1148 2
struct type*
ada_coerce_to_simple_array_type (struct type*type)
d1150 3
a1152 3
  struct value* mark = value_mark ();
  struct value* dummy = value_from_longest (builtin_type_long, 0);
  struct type* result;
d1161 1
a1161 1
ada_is_packed_array_type (struct type* type)
d1166 1
a1166 1
  return 
d1179 2
a1180 2
static struct type*
packed_array_type (struct type* type, long* elt_bits)
d1182 2
a1183 2
  struct type* new_elt_type;
  struct type* new_type;
d1197 1
a1197 1
  if (get_discrete_bounds (TYPE_FIELD_TYPE (type, 0), 
d1202 1
a1202 1
  else 
d1205 1
a1205 1
      TYPE_LENGTH (new_type) = 
d1216 2
a1217 2
static struct type*
decode_packed_array_type (struct type* type)
d1219 6
a1224 6
  struct symbol** syms;
  struct block** blocks;
  const char* raw_name = ada_type_name (check_typedef (type));
  char* name = (char*) alloca (strlen (raw_name) + 1);
  char* tail = strstr (raw_name, "___XP");
  struct type* shadow_type;
d1233 1
a1233 1
  n = ada_lookup_symbol_list (name, get_selected_block (NULL), 
d1251 1
a1251 1
				 				 
d1257 1
a1257 1
    
d1267 2
a1268 2
static struct value*
decode_packed_array (struct value* arr)
d1270 1
a1270 1
  struct type* type = decode_packed_array_type (VALUE_TYPE (arr));
d1285 2
a1286 2
static struct value*
value_subscript_packed (struct value* arr, int arity, struct value** ind)
d1291 2
a1292 2
  struct type* elt_type;
  struct value* v;
d1297 1
a1297 1
  for (i = 0; i < arity; i += 1) 
d1299 1
a1299 1
      if (TYPE_CODE (elt_type) != TYPE_CODE_ARRAY 
d1301 2
a1302 1
	error ("attempt to do packed indexing of something other than a packed array");
d1309 1
a1309 2
	  if (get_discrete_bounds (range_type, &lowerbound,
				   &upperbound) < 0)
d1314 1
a1314 1
      
d1325 2
a1326 2
  
  v = ada_value_primitive_packed_val (arr, NULL, elt_off, bit_off, 
d1338 1
a1338 1
has_negatives (struct type* type)
d1340 9
a1348 8
  switch (TYPE_CODE (type)) {
  default:
    return 0;
  case TYPE_CODE_INT:
    return ! TYPE_UNSIGNED (type);
  case TYPE_CODE_RANGE:
    return TYPE_LOW_BOUND (type) < 0;
  }
d1350 1
a1350 1
      
d1361 4
a1364 3
struct value*
ada_value_primitive_packed_val (struct value* obj, char* valaddr, long offset, int bit_offset, 
				int bit_size, struct type* type)
d1366 1
a1366 1
  struct value* v;
d1369 1
a1369 2
    i, 
    srcBitsLeft, 		/* Number of source bits left to move. */
d1374 2
a1375 2
  unsigned char* bytes;   /* First byte containing data to unpack. */
  unsigned char* unpacked;
d1380 1
a1380 1
   * direction the indices move. */     
d1388 1
a1388 1
      bytes = (unsigned char*) (valaddr + offset);
d1394 1
a1394 1
      bytes = (unsigned char*) alloca (len);
d1397 1
a1397 1
  else 
d1400 1
a1400 1
      bytes = (unsigned char*) VALUE_CONTENTS (obj) + offset;
d1402 2
a1403 2
      
  if (obj != NULL) 
d1412 4
a1415 4
        {
          VALUE_ADDRESS (v) += 1;
          VALUE_BITPOS (v) -= HOST_CHAR_BIT;
        }
d1419 1
a1419 1
  unpacked = (unsigned char*) VALUE_CONTENTS (v);
d1432 3
a1434 3
      src = len-1;
      if (has_negatives (type) && 
	  ((bytes[0] << bit_offset) & (1 << (HOST_CHAR_BIT-1))))
d1436 2
a1437 2
      
      unusedLS = 
d1442 7
a1448 7
        {
        case TYPE_CODE_ARRAY:
        case TYPE_CODE_UNION:
        case TYPE_CODE_STRUCT:
          /* Non-scalar values must be aligned at a byte boundary. */
          accumSize =
            (HOST_CHAR_BIT - bit_size % HOST_CHAR_BIT) % HOST_CHAR_BIT;
d1452 2
a1453 2
          break;
        default:
d1456 2
a1457 2
          break;
        }
d1459 1
a1459 1
  else 
d1467 1
a1467 1
      if (has_negatives (type) && (bytes[len-1] & (1 << sign_bit_offset)))
d1470 1
a1470 1
      
d1476 3
a1478 2
      unsigned int unusedMSMask = 
	(1 << (srcBitsLeft >= HOST_CHAR_BIT ? HOST_CHAR_BIT : srcBitsLeft))-1;
d1481 1
a1481 1
      accum |= 
d1484 1
a1484 1
      if (accumSize >= HOST_CHAR_BIT) 
d1509 1
a1509 1
      
d1514 1
a1514 1
move_bits (char* target, int targ_offset, char* source, int src_offset, int n)
d1523 1
a1523 1
  if (BITS_BIG_ENDIAN) 
d1529 1
a1529 1
      while (n > 0) 
d1540 2
a1541 2
	  *target = 
	    (*target & ~mask) 
d1555 1
a1555 1
      while (n > 0) 
d1564 1
a1564 2
	  *target = 
	    (*target & ~mask) | ((accum << targ_offset) & mask);
d1580 2
a1581 2
static struct value*
ada_value_assign (struct value* toval, struct value* fromval)
d1583 1
a1583 1
  struct type* type = VALUE_TYPE (toval);
d1591 1
a1591 1
  if (VALUE_LVAL (toval) == lval_memory 
d1593 1
a1593 1
      && (TYPE_CODE (type) == TYPE_CODE_FLT 
d1596 4
a1599 5
      int len = 
	(VALUE_BITPOS (toval) + bits + HOST_CHAR_BIT - 1)
	/ HOST_CHAR_BIT;
      char* buffer = (char*) alloca (len);
      struct value* val;
d1606 4
a1609 4
	move_bits (buffer, VALUE_BITPOS (toval), 
		   VALUE_CONTENTS (fromval), 
		   TYPE_LENGTH (VALUE_TYPE (fromval)) * TARGET_CHAR_BIT - bits,
		   bits);
d1611 1
a1611 1
	move_bits (buffer, VALUE_BITPOS (toval), VALUE_CONTENTS (fromval), 
d1613 2
a1614 1
      write_memory (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval), buffer, len);
d1620 1
a1620 1
  
d1632 2
a1633 2
struct value*
ada_value_subscript (struct value* arr, int arity, struct value** ind)
d1636 2
a1637 2
  struct value* elt;
  struct type* elt_type;
d1642 1
a1642 1
  if (TYPE_CODE (elt_type) == TYPE_CODE_ARRAY 
d1649 1
a1649 1
	error("too many subscripts (%d expected)", k);
d1659 3
a1661 2
struct value*
ada_value_ptr_subscript (struct value* arr, struct type* type, int arity, struct value** ind)
d1668 1
a1668 1
      struct value* idx;
d1671 2
a1672 2
	error("too many subscripts (%d expected)", k);
      arr = value_cast (lookup_pointer_type (TYPE_TARGET_TYPE (type)), 
d1675 1
a1675 1
      if (lwb == 0) 
d1692 1
a1692 1
ada_array_arity (struct type* type)
d1702 1
a1702 1
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT) 
d1704 2
a1705 2
  else 
    while (TYPE_CODE (type) == TYPE_CODE_ARRAY) 
d1710 1
a1710 1
	    
d1719 2
a1720 2
struct type*
ada_array_element_type (struct type* type, int nindices)
d1724 1
a1724 1
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT) 
d1727 1
a1727 1
      struct type* p_array_type;
d1734 1
a1734 1
      
d1739 1
a1739 1
      while (k > 0 && p_array_type != NULL) 
d1762 2
a1763 2
struct type*
ada_index_type (struct type* type, int n)
d1779 1
a1779 1
  else 
d1791 2
a1792 1
ada_array_bound_from_type (struct type* arr_type, int n, int which, struct type** typep)
d1794 2
a1795 2
  struct type* type;
  struct type* index_type_desc;
d1800 1
a1800 1
  if (arr_type == NULL || ! ada_is_simple_array (arr_type)) 
d1804 1
a1804 1
      return (LONGEST) -which;
d1813 1
a1813 1
  if (index_type_desc == NULL) 
d1815 2
a1816 2
      struct type* range_type;
      struct type* index_type;
d1818 1
a1818 1
      while (n > 1) 
d1827 1
a1827 1
	  index_type = builtin_type_long;
d1830 2
a1831 2
      return 
	(LONGEST) (which == 0 
d1835 1
a1835 1
  else 
d1837 2
a1838 2
      struct type* index_type =
	to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, n-1),
d1842 2
a1843 2
      return 
	(LONGEST) (which == 0 
d1854 1
a1854 1
struct value*
d1856 2
a1857 2
     struct value* arr;
     int n; 
d1860 1
a1860 1
  struct type* arr_type = VALUE_TYPE (arr);
d1864 1
a1864 1
  else if (ada_is_simple_array (arr_type)) 
d1866 1
a1866 1
      struct type* type;
d1878 1
a1878 1
   clauses at the moment. */ 
d1880 2
a1881 2
struct value*
ada_array_length (struct value* arr, int n)
d1883 2
a1884 2
  struct type* arr_type = check_typedef (VALUE_TYPE (arr));
  struct type* index_type_desc;
d1891 1
a1891 1
      struct type* type;
d1898 1
a1898 1
    return 
d1903 1
a1903 2
							   n, 0))
			  + 1);
d1905 1
a1906 1

d1912 1
a1912 1
static const char*
d1937 1
a1937 1
ada_resolve (struct expression** expp, struct type* context_type)
d1952 3
a1954 2
static struct value*
ada_resolve_subexp (struct expression** expp, int *pos, int deprocedure_p, struct type* context_type) 
d1958 1
a1958 1
  struct expression* exp;	/* Convenience: == *expp */
d1960 1
a1960 1
  struct value** argvec;		/* Vector of operand types (alloca'ed). */
d1971 1
a1971 1
      /*    case OP_UNRESOLVED_VALUE:*/
d1979 17
a1995 17
      /*      if (exp->elts[pc+3].opcode == OP_UNRESOLVED_VALUE) 	
	{
	  *pos += 7;

	  argvec = (struct value* *) alloca (sizeof (struct value*) * (nargs + 1));
	  for (i = 0; i < nargs-1; i += 1)
	    argvec[i] = ada_resolve_subexp (expp, pos, 1, NULL);
	  argvec[i] = NULL;
	}
      else
	{
	  *pos += 3;
	  ada_resolve_subexp (expp, pos, 0, NULL);
	  for (i = 1; i < nargs; i += 1)
	    ada_resolve_subexp (expp, pos, 1, NULL);
	}
      */
d2001 7
a2007 7
      nargs = 1;
      *pos += 3;
      ada_resolve_subexp (expp, pos, 1, exp->elts[pc + 1].type);
      exp = *expp;
      break;
      */
      /* FIXME:  OP_ATTRIBUTE should be defined in expression.h */      
d2009 7
a2015 7
      nargs = longest_to_int (exp->elts[pc + 1].longconst) + 1;
      *pos += 4;
      for (i = 0; i < nargs; i += 1)
	ada_resolve_subexp (expp, pos, 1, NULL);
      exp = *expp;
      break;
      */
d2025 1
a2025 1
	struct value* arg1;
d2037 1
a2037 1
      switch (op) 
d2042 5
a2046 5
	  /*	case UNOP_MBR:
	  nargs = 1;
	  *pos += 3;
	  break;
	  */
d2110 1
a2110 1
	  *pos += 4;  
d2114 3
a2116 3
	  /*	  if (nargs == 0)
	    nargs = 1;
	    break;*/
d2120 5
a2124 5
	  /*	case TERNOP_MBR:
	  *pos += 1;
	  nargs = 3;
	  break;
	  */
d2126 4
a2129 4
	  /*	case BINOP_MBR:
	  *pos += 3;
	  nargs = 2;
	  break;*/
d2132 2
a2133 1
      argvec = (struct value* *) alloca (sizeof (struct value*) * (nargs + 1));
d2149 50
a2198 50
      {
	struct symbol** candidate_syms;
	struct block** candidate_blocks;
	int n_candidates;

	n_candidates = ada_lookup_symbol_list (exp->elts[pc + 2].name,
					       exp->elts[pc + 1].block,
					       VAR_NAMESPACE,
					       &candidate_syms,
					       &candidate_blocks);
	
	if (n_candidates > 1) 
	{*/
	    /* Types tend to get re-introduced locally, so if there
	       are any local symbols that are not types, first filter
	       out all types.*/	       /*
	    int j;
	    for (j = 0; j < n_candidates; j += 1) 
	      switch (SYMBOL_CLASS (candidate_syms[j])) 
		{
		case LOC_REGISTER:
		case LOC_ARG:
		case LOC_REF_ARG:
		case LOC_REGPARM:
		case LOC_REGPARM_ADDR:
		case LOC_LOCAL:
		case LOC_LOCAL_ARG:
		case LOC_BASEREG:
		case LOC_BASEREG_ARG:
		  goto FoundNonType;
		default:
		  break;
		}
	  FoundNonType:
	    if (j < n_candidates) 
	      {
		j = 0;
		while (j < n_candidates) 
		  {
		    if (SYMBOL_CLASS (candidate_syms[j]) == LOC_TYPEDEF)
		      {
			candidate_syms[j] = candidate_syms[n_candidates-1];
			candidate_blocks[j] = candidate_blocks[n_candidates-1];
			n_candidates -= 1;
		      }
		    else
		      j += 1;
		  }
	      }
	  }
d2200 23
a2222 23
	if (n_candidates == 0)
	  error ("No definition found for %s", 
		 ada_demangle (exp->elts[pc + 2].name));
	else if (n_candidates == 1)
	  i = 0;
	else if (deprocedure_p 
		 && ! is_nonfunction (candidate_syms, n_candidates))
	  {
	    i = ada_resolve_function (candidate_syms, candidate_blocks,
				      n_candidates, NULL, 0,
				      exp->elts[pc + 2].name, context_type);
	    if (i < 0) 
	      error ("Could not find a match for %s", 
		     ada_demangle (exp->elts[pc + 2].name));
	  }
	else 
	  {
	    printf_filtered ("Multiple matches for %s\n", 
			     ada_demangle (exp->elts[pc+2].name));
	    user_select_syms (candidate_syms, candidate_blocks, 
			      n_candidates, 1);
	    i = 0;
	  }
d2224 7
a2230 7
	exp->elts[pc].opcode = exp->elts[pc + 3].opcode = OP_VAR_VALUE;
	exp->elts[pc + 1].block = candidate_blocks[i];
	exp->elts[pc + 2].symbol = candidate_syms[i];
	if (innermost_block == NULL ||
	    contained_in (candidate_blocks[i], innermost_block))
	  innermost_block = candidate_blocks[i];
      }*/
d2234 7
a2240 6
      if (deprocedure_p && 
	  TYPE_CODE (SYMBOL_TYPE (exp->elts[pc+2].symbol)) == TYPE_CODE_FUNC)
	{
	  replace_operator_with_call (expp, pc, 0, 0, 
				      exp->elts[pc+2].symbol,
				      exp->elts[pc+1].block);
d2248 30
a2277 22
	/*	if (exp->elts[pc+3].opcode == OP_UNRESOLVED_VALUE) 	
	  {
	    struct symbol** candidate_syms;
	    struct block** candidate_blocks;
	    int n_candidates;

	    n_candidates = ada_lookup_symbol_list (exp->elts[pc + 5].name,
						   exp->elts[pc + 4].block,
						   VAR_NAMESPACE,
						   &candidate_syms,
						   &candidate_blocks);
	    if (n_candidates == 1)
	      i = 0;
	    else
	      {
		i = ada_resolve_function (candidate_syms, candidate_blocks,
					  n_candidates, argvec, nargs-1,
					  exp->elts[pc + 5].name, context_type);
		if (i < 0) 
		  error ("Could not find a match for %s", 
			 ada_demangle (exp->elts[pc + 5].name));
	      }
a2278 8
	    exp->elts[pc + 3].opcode = exp->elts[pc + 6].opcode = OP_VAR_VALUE;
	    exp->elts[pc + 4].block = candidate_blocks[i];
	    exp->elts[pc + 5].symbol = candidate_syms[i];
	    if (innermost_block == NULL ||
		contained_in (candidate_blocks[i], innermost_block))
	      innermost_block = candidate_blocks[i];
	      }*/
	
d2304 2
a2305 2
	  struct symbol** candidate_syms;
	  struct block** candidate_blocks;
d2308 8
a2315 8
	  n_candidates = ada_lookup_symbol_list (ada_mangle (ada_op_name (op)),
						 (struct block*) NULL,
						 VAR_NAMESPACE,
						 &candidate_syms,
						 &candidate_blocks);
	  i = ada_resolve_function (candidate_syms, candidate_blocks,
				    n_candidates, argvec, nargs,
				    ada_op_name (op), NULL);
d2332 1
a2332 1
   a non-pointer. */ 
d2338 2
a2339 2
     struct type* ftype;
     struct type* atype;
d2350 1
a2350 1
  if (TYPE_CODE (ftype) == TYPE_CODE_VOID 
d2354 1
a2354 1
  switch (TYPE_CODE (ftype)) 
d2362 3
a2364 2
      else return (may_deref && 
		   ada_type_match (TYPE_TARGET_TYPE (ftype), atype, 0));
d2379 1
a2379 1
      return (TYPE_CODE (atype) == TYPE_CODE_ARRAY 
d2384 1
a2384 1
	return (TYPE_CODE (atype) == TYPE_CODE_ARRAY 
d2388 1
a2388 1
		&& ! ada_is_array_descriptor (atype));
d2402 1
a2402 1
ada_args_match (struct symbol* func, struct value** actuals, int n_actuals)
d2405 1
a2405 1
  struct type* func_type = SYMBOL_TYPE (func);
d2407 1
a2407 1
  if (SYMBOL_CLASS (func) == LOC_CONST && 
d2418 2
a2419 2
      struct type* ftype = check_typedef (TYPE_FIELD_TYPE (func_type, i));
      struct type* atype = check_typedef (VALUE_TYPE (actuals[i]));
d2421 2
a2422 2
      if (! ada_type_match (TYPE_FIELD_TYPE (func_type, i), 
			    VALUE_TYPE (actuals[i]), 1))
d2434 1
a2434 1
return_match (struct type* func_type, struct type* context_type)
d2436 1
a2436 1
  struct type* return_type;
d2443 3
a2445 3
        return_type = base_type (TYPE_TARGET_TYPE (func_type));
      else 
	return_type = base_type (func_type);*/
d2450 1
a2450 1
  /*  context_type = base_type (context_type);*/
d2473 3
a2475 3
ada_resolve_function (struct symbol* syms[], struct block* blocks[], int nsyms,
		      struct value** args, int nargs, const char* name,
		      struct type* context_type)
d2479 2
a2480 2
  struct type* fallback;
  struct type* return_type;
d2488 1
a2488 1
  m = 0; 
d2493 1
a2493 1
	  struct type* type = check_typedef (SYMBOL_TYPE (syms[k]));
d2527 1
a2527 1
mangled_ordered_before (char* N0, char* N1)
d2536 1
a2536 1
      for (k0 = strlen (N0)-1; k0 > 0 && isdigit (N0[k0]); k0 -= 1)
d2538 1
a2538 1
      for (k1 = strlen (N1)-1; k1 > 0 && isdigit (N1[k1]); k1 -= 1)
d2540 2
a2541 2
      if ((N0[k0] == '_' || N0[k0] == '$') && N0[k0+1] != '\000'
	  && (N1[k1] == '_' || N1[k1] == '$') && N1[k1+1] != '\000')
d2545 1
a2545 1
	  while (N0[n0] == '_' && n0 > 0 && N0[n0-1] == '_')
d2548 1
a2548 1
	  while (N1[n1] == '_' && n1 > 0 && N1[n1-1] == '_')
d2551 1
a2551 1
	    return (atoi (N0+k0+1) < atoi (N1+k1+1));
d2556 1
a2556 1
	  
d2560 2
a2561 2
static void 
sort_choices (struct symbol* syms[], struct block* blocks[], int nsyms)
d2564 1
a2564 1
  for (i = 1; i < nsyms; i += 1) 
d2566 2
a2567 2
      struct symbol* sym = syms[i];
      struct block* block = blocks[i];
d2570 1
a2570 1
      for (j = i-1; j >= 0; j -= 1) 
d2575 2
a2576 2
	  syms[j+1] = syms[j];
	  blocks[j+1] = blocks[j];
d2578 2
a2579 2
      syms[j+1] = sym;
      blocks[j+1] = block;
d2594 1
a2594 1
user_select_syms (struct symbol* syms[], struct block* blocks[], int nsyms,
d2598 1
a2598 1
  int* chosen = (int*) alloca (sizeof(int) * nsyms);
d2607 1
a2607 1
  printf_unfiltered("[0] cancel\n");
d2609 1
a2609 1
      printf_unfiltered("[1] all\n");
d2622 1
a2622 1
			     i + first_choice, 
d2624 3
a2626 4
			     sal.symtab == NULL 
			       ? "<no source file available>"
			       : sal.symtab->filename, 
			     sal.line);
d2629 1
a2629 1
      else 
d2631 1
a2631 1
	  int is_enumeral = 
d2634 2
a2635 3
	     && TYPE_CODE (SYMBOL_TYPE (syms[i]))
	        == TYPE_CODE_ENUM);
	  struct symtab* symtab = symtab_for_sym (syms[i]);
d2642 1
a2642 2
	  else if (is_enumeral && 
		   TYPE_NAME (SYMBOL_TYPE (syms[i])) != NULL)
d2650 1
a2650 1
	    printf_unfiltered (is_enumeral 
d2660 2
a2661 1
			       i + first_choice, SYMBOL_SOURCE_NAME (syms[i]));
d2664 1
a2664 1
  
d2671 1
a2671 1
      if (blocks != NULL) 
d2695 2
a2696 2
get_selections (int* choices, int n_choices, int max_results,
		int is_all_choice, char* annotation_suffix)
d2699 2
a2700 2
  char* args;
  const char* prompt;
d2703 1
a2703 1
  
d2712 1
a2712 1
  
d2722 1
a2722 1
      char* args2;
d2733 2
a2734 1
      if (args == args2 || choice < 0 || choice > n_choices + first_choice - 1)
d2738 1
a2738 1
      if (choice == 0) 
d2750 3
a2752 2
      for (j = n_chosen-1; j >= 0 && choice < choices[j]; j -= 1)
	{}
d2757 3
a2759 3
	  for (k = n_chosen-1; k > j; k -= 1)
	    choices[k+1] = choices[k];
	  choices[j+1] = choice;
d2766 1
a2766 1
  
d2775 3
a2777 3
replace_operator_with_call (struct expression** expp, int pc, int nargs,
			    int oplen, struct symbol* sym,
			    struct block* block)
d2781 1
a2781 1
  struct expression* newexp = (struct expression*)
d2784 1
a2784 1
  struct expression* exp = *expp;
d2789 1
a2789 1
  memcpy (newexp->elts + pc + 7, exp->elts + pc + oplen, 
d2801 1
a2801 1
}  
d2809 1
a2809 1
numeric_type_p (struct type* type)
d2813 14
a2826 13
  else {
    switch (TYPE_CODE (type))
      {
      case TYPE_CODE_INT:
      case TYPE_CODE_FLT:
	return 1;
      case TYPE_CODE_RANGE:
	return (type == TYPE_TARGET_TYPE (type)
		|| numeric_type_p (TYPE_TARGET_TYPE (type)));
      default:
	return 0;
      }
  }
d2832 1
a2832 1
integer_type_p (struct type* type)
d2836 13
a2848 12
  else {
    switch (TYPE_CODE (type))
      {
      case TYPE_CODE_INT:
	return 1;
      case TYPE_CODE_RANGE:
	return (type == TYPE_TARGET_TYPE (type) 
		|| integer_type_p (TYPE_TARGET_TYPE (type)));
      default:
	return 0;
      }
  }
d2854 1
a2854 1
scalar_type_p (struct type* type)
d2858 13
a2870 12
  else {
    switch (TYPE_CODE (type))
      {
      case TYPE_CODE_INT:
      case TYPE_CODE_RANGE:
      case TYPE_CODE_ENUM:
      case TYPE_CODE_FLT:
	return 1;
      default:
	return 0;
      }
  }
d2876 1
a2876 1
discrete_type_p (struct type* type)
d2880 12
a2891 11
  else {
    switch (TYPE_CODE (type))
      {
      case TYPE_CODE_INT:
      case TYPE_CODE_RANGE:
      case TYPE_CODE_ENUM:
	return 1;
      default:
	return 0;
      }
  }
d2899 1
a2899 1
possible_user_operator_p (enum exp_opcode op, struct value* args[])
d2901 2
a2902 2
  struct type* type0 = check_typedef (VALUE_TYPE (args[0]));
  struct type* type1 = 
d2904 1
a2904 1
  
d2914 1
a2914 1
      return (! (numeric_type_p (type0) && numeric_type_p (type1)));
d2921 1
a2921 1
      return (! (integer_type_p (type0) && integer_type_p (type1)));
d2929 1
a2929 1
      return (! (scalar_type_p (type0) && scalar_type_p (type1)));
d2932 7
a2938 8
      return ((TYPE_CODE (type0) != TYPE_CODE_ARRAY && 
	       (TYPE_CODE (type0) != TYPE_CODE_PTR || 
		TYPE_CODE (TYPE_TARGET_TYPE (type0)) 
		    != TYPE_CODE_ARRAY))
	      || (TYPE_CODE (type1) != TYPE_CODE_ARRAY && 
		  (TYPE_CODE (type1) != TYPE_CODE_PTR || 
		   TYPE_CODE (TYPE_TARGET_TYPE (type1)) 
		     != TYPE_CODE_ARRAY)));
d2941 1
a2941 1
      return (! (numeric_type_p (type0) && integer_type_p (type1)));
d2946 2
a2947 2
    case UNOP_ABS:      
      return (! numeric_type_p (type0));
d2962 2
a2963 2
const char*
ada_renaming_type (struct type* type)
d2967 4
a2970 4
      const char* name = type_name_no_tag (type);
      const char* suffix = (name == NULL) ? NULL : strstr (name, "___XR");
      if (suffix == NULL 
      || (suffix[5] != '\000' && strchr ("PES_", suffix[5]) == NULL))
d2981 1
a2981 1
ada_is_object_renaming (struct symbol* sym)
d2983 2
a2984 2
  const char* renaming_type = ada_renaming_type (SYMBOL_TYPE (sym));
  return renaming_type != NULL 
d2991 2
a2992 2
const char*
ada_simple_renamed_entity (struct symbol* sym)
d2994 2
a2995 2
  struct type* type;
  const char* raw_name;
d2997 1
a2997 1
  char* result;
d3009 2
a3010 2
  /* FIXME: add_name_string_cleanup should be defined in parse.c */  
  /*  add_name_string_cleanup (result);*/
d3015 1
a3016 1

d3022 2
a3023 2
static struct value*
place_on_stack (struct value* val, CORE_ADDR* sp)
d3028 3
a3030 2
  *sp = push_bytes (*sp, VALUE_CONTENTS_RAW (val), 
		    STACK_ALIGN (TYPE_LENGTH (check_typedef (VALUE_TYPE (val)))));
d3032 1
a3032 1
  *sp = push_bytes (*sp, VALUE_CONTENTS_RAW (val), 
d3048 1
a3048 1
   values not residing in memory, updating it as needed. */ 
d3050 12
a3061 11
static struct value*
convert_actual (struct value* actual, struct type* formal_type0, CORE_ADDR* sp)
{
  struct type* actual_type = check_typedef (VALUE_TYPE (actual));
  struct type* formal_type = check_typedef (formal_type0);
  struct type* formal_target =
    TYPE_CODE (formal_type) == TYPE_CODE_PTR 
      ? check_typedef (TYPE_TARGET_TYPE (formal_type)) : formal_type;
  struct type* actual_target = 
    TYPE_CODE (actual_type) == TYPE_CODE_PTR 
      ? check_typedef (TYPE_TARGET_TYPE (actual_type)) : actual_type;
d3069 1
a3069 1
	  && ada_is_array_descriptor (actual_target)) 
d3075 1
a3075 1
	      struct value* val;
d3078 2
a3079 2
	      memcpy ((char*) VALUE_CONTENTS_RAW (val), 
		      (char*) VALUE_CONTENTS (actual),
d3099 2
a3100 2
static struct value*
make_array_descriptor (struct type* type, struct value* arr, CORE_ADDR* sp)
d3102 4
a3105 4
  struct type* bounds_type = desc_bounds_type (type);
  struct type* desc_type = desc_base_type (type);
  struct value* descriptor = allocate_value (desc_type);
  struct value* bounds = allocate_value (bounds_type);
d3108 1
a3108 1
  
d3112 1
a3112 1
			    value_as_long (ada_array_bound (arr, i, 0)), 
d3116 1
a3116 1
			    value_as_long (ada_array_bound (arr, i, 1)), 
d3120 1
a3120 1
  
d3122 1
a3122 1
  
d3150 2
a3151 1
ada_convert_actuals (struct value* func, int nargs, struct value* args[], CORE_ADDR* sp)
d3155 1
a3155 1
  if (TYPE_NFIELDS (VALUE_TYPE (func)) == 0 
d3160 2
a3161 4
    args[i] = 
      convert_actual (args[i], 
		      TYPE_FIELD_TYPE (VALUE_TYPE (func), i), 
		      sp);
d3163 1
a3164 1

d3172 1
a3172 1
static size_t defn_vector_size = 0; 
d3177 2
a3178 2
static struct symbol** defn_symbols = NULL;
static struct block** defn_blocks = NULL;
d3183 2
a3184 2
static struct symbol*
standard_lookup (const char* name, namespace_enum namespace)
d3186 3
a3188 3
  struct symbol* sym;
  struct symtab* symtab;
  sym = lookup_symbol (name, (struct block*) NULL, namespace, 0, &symtab);
d3191 1
a3191 1
  
d3195 1
a3195 1
/* contend in overloading in the same way. */ 
d3197 1
a3197 1
is_nonfunction (struct symbol* syms[], int n)
d3213 1
a3213 1
equiv_types (struct type* type0, struct type* type1)
d3215 1
a3215 1
  if (type0 == type1) 
d3217 1
a3217 1
  if (type0 == NULL || type1 == NULL 
d3220 1
a3220 1
  if ((TYPE_CODE (type0) == TYPE_CODE_STRUCT 
d3225 1
a3225 1
  
d3233 1
a3233 1
lesseq_defined_than (struct symbol* sym0, struct symbol* sym1)
d3241 1
a3241 1
  switch (SYMBOL_CLASS (sym0)) 
d3247 4
a3250 4
	struct type* type0 = SYMBOL_TYPE (sym0);
	struct type* type1 = SYMBOL_TYPE (sym1);
	char* name0 = SYMBOL_NAME (sym0);
	char* name1 = SYMBOL_NAME (sym1);
d3252 1
a3252 1
	return 
d3261 2
a3262 2
    default: 
      return 0;      
d3271 1
a3271 1
add_defn_to_vec (struct symbol* sym, struct block* block)
d3276 1
a3276 1
  if (SYMBOL_TYPE (sym) != NULL) 
d3291 2
a3292 2
  GROW_VECT (defn_symbols, tmp, ndefns+2);
  GROW_VECT (defn_blocks, defn_vector_size, ndefns+2);
d3304 2
a3305 1
ada_lookup_partial_symbol (struct partial_symtab *pst, const char *name, int global, namespace_enum namespace, int wild)
d3316 1
a3316 1
  
d3319 1
a3319 1
	   pst->objfile->static_psymbols.list + pst->statics_offset  );
d3325 1
a3325 1
	  struct partial_symbol* psym = start[i];
d3333 1
a3333 1
  else 
d3338 3
a3340 2
	  i = 0; U = length-1;
	  while (U - i > 4) 
d3342 2
a3343 2
	      int M = (U+i) >> 1;
	      struct partial_symbol* psym = start[M];
d3345 1
a3345 1
		i = M+1;
d3347 1
a3347 1
		U = M-1;
d3349 1
a3349 1
		i = M+1;
d3364 2
a3365 2
	
	      if (cmp < 0) 
d3370 2
a3371 2
	      else if (cmp == 0 
		       && is_name_suffix (SYMBOL_NAME (psym) + name_len)) 
d3380 3
a3382 2
	  i = 0; U = length-1;
	  while (U - i > 4) 
d3384 1
a3384 1
	      int M = (U+i) >> 1;
d3387 1
a3387 1
		i = M+1;
d3389 1
a3389 1
		U = M-1;
d3391 1
a3391 1
		i = M+1;
d3401 1
a3401 1
	  struct partial_symbol* psym = start[i];
d3408 1
a3408 1
	      if (cmp == 0) 
d3414 2
a3415 2
	
	      if (cmp < 0) 
d3420 2
a3421 2
	      else if (cmp == 0 
		       && is_name_suffix (SYMBOL_NAME (psym) + name_len + 5)) 
d3426 1
a3426 1
      
d3433 2
a3434 2
static struct symtab*
symtab_for_sym (struct symbol* sym)
d3436 1
a3436 1
  struct symtab* s;
d3443 37
a3479 13
    {
      switch (SYMBOL_CLASS (sym))
	{
	case LOC_CONST:
	case LOC_STATIC:
	case LOC_TYPEDEF:
	case LOC_REGISTER:
	case LOC_LABEL:
	case LOC_BLOCK:
	case LOC_CONST_BYTES:
	  b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
	  ALL_BLOCK_SYMBOLS (b, i, tmp_sym)
	    if (sym == tmp_sym)
d3481 6
a3486 33
	  b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
	  ALL_BLOCK_SYMBOLS (b, i, tmp_sym)
	    if (sym == tmp_sym)
	      return s;
	  break;
	default:
	  break;
	}
      switch (SYMBOL_CLASS (sym))
	{
	case LOC_REGISTER:
	case LOC_ARG:
	case LOC_REF_ARG:
	case LOC_REGPARM:
	case LOC_REGPARM_ADDR:
	case LOC_LOCAL:
	case LOC_TYPEDEF:
	case LOC_LOCAL_ARG:
	case LOC_BASEREG:
	case LOC_BASEREG_ARG:
	  for (j = FIRST_LOCAL_BLOCK; 
	       j < BLOCKVECTOR_NBLOCKS (BLOCKVECTOR (s)); j += 1)
	    {
	      b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), j);
	      ALL_BLOCK_SYMBOLS (b, i, tmp_sym)
		if (sym == tmp_sym)
		  return s;
	    }
	  break;
	default:
	  break;
	}
    }
d3493 2
a3494 2
struct minimal_symbol*
ada_lookup_minimal_symbol (const char* name)
d3496 2
a3497 2
  struct objfile* objfile;
  struct minimal_symbol* msymbol;
d3501 5
a3505 5
    {
      if (ada_match_name (SYMBOL_NAME (msymbol), name, wild_match)
	  && MSYMBOL_TYPE (msymbol) != mst_solib_trampoline)
	return msymbol;
    }
d3520 2
a3521 1
add_symbols_from_enclosing_procs (const char* name, namespace_enum namespace, int wild_match)
d3527 3
a3529 3
  struct cleanup* old_chain = make_cleanup (null_cleanup, NULL);
  struct frame_info* frame;
  struct frame_info* target_frame;
d3541 2
a3542 2
      SYMBOL_VALUE (static_link) = 
	- (long) TYPE_LENGTH (SYMBOL_TYPE (static_link));
d3548 2
a3549 2
      struct block* block;
      struct value* target_link_val = read_var_value (static_link, frame);
d3557 2
a3558 1
      do {
d3561 2
a3562 1
      } while (frame != NULL && FRAME_LOCALS_ADDRESS (frame) != target_link);
d3571 1
a3571 1
      
d3583 1
a3583 1
is_nondebugging_type (struct type* type)
d3585 1
a3585 1
  char* name = ada_type_name (type);
d3598 1
a3598 1
remove_extra_symbols (struct symbol** syms, struct block** blocks, int nsyms)
d3605 2
a3606 1
      if (SYMBOL_NAME (syms[i]) != NULL && SYMBOL_CLASS (syms[i]) == LOC_STATIC
d3611 1
a3611 1
	      if (i != j 
d3615 1
a3615 1
		  && SYMBOL_VALUE_ADDRESS (syms[i]) 
d3619 1
a3619 1
		  for (k = i+1; k < nsyms; k += 1) 
d3621 2
a3622 2
		      syms[k-1] = syms[k];
		      blocks[k-1] = blocks[k];
d3649 2
a3650 2
			namespace_enum namespace, struct symbol*** syms,
			struct block*** blocks)
d3688 1
a3688 1
  
d3695 8
a3702 8
    {
      QUIT;
      if (! s->primary)
	continue;
      bv = BLOCKVECTOR (s);
      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
      ada_add_block_symbols (block, name, namespace, objfile, wild_match);
    }
d3707 30
a3736 30
	{
	  if (ada_match_name (SYMBOL_NAME (msymbol), name, wild_match))
	    {
	      switch (MSYMBOL_TYPE (msymbol))
		{
		case mst_solib_trampoline:
		  break;
		default:
		  s = find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol));
		  if (s != NULL)
		    {
		      int old_ndefns = ndefns;
		      QUIT;
		      bv = BLOCKVECTOR (s);
		      block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
		      ada_add_block_symbols (block, 
					     SYMBOL_NAME (msymbol), 
					     namespace, objfile, wild_match);
		      if (ndefns == old_ndefns) 
			{
			  block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
			  ada_add_block_symbols (block, 
						 SYMBOL_NAME (msymbol), 
						 namespace, objfile,
						 wild_match);
			}
		    }
		}
	    }
	}
d3738 1
a3738 1
      
d3740 14
a3753 14
    {
      QUIT;
      if (!ps->readin 
	  && ada_lookup_partial_symbol (ps, name, 1, namespace, wild_match))
	{
	  s = PSYMTAB_TO_SYMTAB (ps);
	  if (! s->primary)
	    continue;
	  bv = BLOCKVECTOR (s);
	  block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	  ada_add_block_symbols (block, name, namespace, objfile, wild_match);
	}
    }
  
d3757 1
a3757 1
  
d3762 9
a3770 9
	{
	  QUIT;
	  if (! s->primary)
	    continue;
	  bv = BLOCKVECTOR (s);
	  block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	  ada_add_block_symbols (block, name, namespace, objfile, wild_match);
	}
      
d3772 15
a3786 15
	{
	  QUIT;
	  if (!ps->readin 
	      && ada_lookup_partial_symbol (ps, name, 0, namespace, wild_match))
	    {
	      s = PSYMTAB_TO_SYMTAB(ps);
	      bv = BLOCKVECTOR (s);
	      if (! s->primary)
		continue;
	      block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	      ada_add_block_symbols (block, name, namespace, 
				     objfile, wild_match);
	    }
	}
    }  
d3791 1
a3791 1
  if (ndefns == 0) 
d3798 1
a3798 1
 done:
d3816 3
a3818 2
struct symbol*
ada_lookup_symbol (const char *name, struct block *block0, namespace_enum namespace)
d3820 2
a3821 2
  struct symbol** candidate_syms;
  struct block** candidate_blocks;
d3845 1
a3845 1
is_name_suffix (const char* str)
d3851 1
a3851 1
      while (str[0] != '_' && str[0] != '\0') 
d3856 1
a3856 1
	} 
d3860 1
a3860 1
  if (str[0] == '_') 
d3864 1
a3864 1
      if (str[2] == '_') 
d3866 1
a3866 1
	  if (STREQ (str+3, "LJM"))
d3891 1
a3891 1
      
d3895 1
a3895 1
 * true). */ 
d3897 1
a3897 1
wild_match (const char* patn, int patn_len, const char* name)
d3903 3
a3905 3
  if (name_len >= patn_len+5 && STREQN (name, "_ada_", 5)
      && STREQN (patn, name+5, patn_len)
      && is_name_suffix (name+patn_len+5))
d3908 1
a3908 1
  while (name_len >= patn_len) 
d3910 1
a3910 2
      if (STREQN (patn, name, patn_len)
	  && is_name_suffix (name+patn_len))
d3912 7
a3918 4
      do {
	name += 1; name_len -= 1;
      } while (name_len > 0
	       && name[0] != '.' && (name[0] != '_' || name[1] != '_'));
d3923 1
a3923 1
	  if (! islower (name[2]))
d3925 2
a3926 1
	  name += 2; name_len -= 2;
d3930 1
a3930 1
	  if (! islower (name[1]))
d3932 2
a3933 1
	  name += 1; name_len -= 1;
d3947 3
a3949 3
static void 
ada_add_block_symbols (struct block* block, const char* name,
		       namespace_enum namespace, struct objfile* objfile,
d3961 2
a3962 1
  arg_sym = NULL; found_sym = 0;
d3967 24
a3990 24
	{
	  if (SYMBOL_NAMESPACE (sym) == namespace &&
	      wild_match (name, name_len, SYMBOL_NAME (sym)))
	    {
	      switch (SYMBOL_CLASS (sym))
		{
		case LOC_ARG:
		case LOC_LOCAL_ARG:
		case LOC_REF_ARG:
		case LOC_REGPARM:
		case LOC_REGPARM_ADDR:
		case LOC_BASEREG_ARG:
		  arg_sym = sym;
		  break;
		case LOC_UNRESOLVED:
		  continue;
		default:
		  found_sym = 1;
		  fill_in_ada_prototype (sym);
		  add_defn_to_vec (fixup_symbol_section (sym, objfile), block);
		  break;
		}
	    }
	}
d3992 1
a3992 1
  else 
d3997 3
a3999 2
	  i = 0; U = BLOCK_NSYMS (block)-1;
	  while (U - i > 4) 
d4001 1
a4001 1
	      int M = (U+i) >> 1;
d4004 1
a4004 1
		i = M+1;
d4006 1
a4006 1
		U = M-1;
d4008 1
a4008 1
		i = M+1;
d4023 1
a4023 1
		if (cmp < 0) 
d4031 2
a4032 2
		else if (cmp == 0 
			 && is_name_suffix (SYMBOL_NAME (sym) + name_len)) 
d4058 1
a4058 1
  if (! found_sym && arg_sym != NULL)
d4064 1
a4064 1
  if (! wild)
d4066 2
a4067 1
      arg_sym = NULL; found_sym = 0;
d4071 3
a4073 2
	  i = 0; U = BLOCK_NSYMS (block)-1;
	  while (U - i > 4) 
d4075 1
a4075 1
	      int M = (U+i) >> 1;
d4078 1
a4078 1
		i = M+1;
d4080 1
a4080 1
		U = M-1;
d4082 1
a4082 1
		i = M+1;
d4100 1
a4100 1
		if (cmp == 0) 
d4107 1
a4107 1
		if (cmp < 0) 
d4115 2
a4116 2
		else if (cmp == 0 
			 && is_name_suffix (SYMBOL_NAME (sym) + name_len + 5)) 
d4140 1
a4140 1
  
d4142 2
a4143 2
	 They aren't parameters, right? */
      if (! found_sym && arg_sym != NULL)
d4150 1
a4151 1

d4158 1
a4158 1
fill_in_ada_prototype (struct symbol* func)
d4160 1
a4160 1
  struct block* b;
d4163 2
a4164 2
  struct type* ftype;
  struct type* rtype;
d4185 3
a4187 3
  max_fields = 8; 
  TYPE_FIELDS (ftype) = 
    (struct field*) xmalloc (sizeof (struct field) * max_fields);
d4189 25
a4213 15
    {
      GROW_VECT (TYPE_FIELDS (ftype), max_fields, nargs+1);
	
      switch (SYMBOL_CLASS (sym)) 
	{
	case LOC_REF_ARG:
	case LOC_REGPARM_ADDR:
	  TYPE_FIELD_BITPOS (ftype, nargs) = nargs;
	  TYPE_FIELD_BITSIZE (ftype, nargs) = 0;
	  TYPE_FIELD_TYPE (ftype, nargs) = 
	    lookup_pointer_type (check_typedef (SYMBOL_TYPE (sym)));
	  TYPE_FIELD_NAME (ftype, nargs) = SYMBOL_NAME (sym);
	  nargs += 1;
	
	  break;
d4215 1
a4215 11
	case LOC_ARG:
	case LOC_REGPARM:
	case LOC_LOCAL_ARG:
	case LOC_BASEREG_ARG:
	  TYPE_FIELD_BITPOS (ftype, nargs) = nargs;
	  TYPE_FIELD_BITSIZE (ftype, nargs) = 0;
	  TYPE_FIELD_TYPE (ftype, nargs) = check_typedef (SYMBOL_TYPE (sym));
	  TYPE_FIELD_NAME (ftype, nargs) = SYMBOL_NAME (sym);
	  nargs += 1;
	
	  break;
d4217 4
a4220 4
	default:
	  break;
	}
    }
d4229 1
a4229 1
      static struct field dummy_field = {0, 0, 0, 0};
d4235 4
a4238 5
      struct field* fields = 
	(struct field*) TYPE_ALLOC (ftype, nargs * sizeof (struct field));
      memcpy ((char*) fields, 
	      (char*) TYPE_FIELDS (ftype), 
	      nargs * sizeof (struct field));
d4243 1
a4244 1

d4247 2
a4248 1
char no_symtab_msg[] = "No symbol table is loaded.  Use the \"file\" command.";
d4254 2
a4255 2
char*
ada_start_decode_line_1 (char* line)
d4259 1
a4259 1
  char* p;
d4309 2
a4310 2
ada_finish_decode_line_1 (char** spec, struct symtab* file_table, 
			  int funfirstline, char*** canonical)
d4312 3
a4314 3
  struct symbol** symbols;
  struct block** blocks;
  struct block* block;
d4317 2
a4318 2
  struct cleanup* old_chain = make_cleanup (null_cleanup, NULL);
  char* name;
d4321 2
a4322 2
  char* lower_name;
  char* unquoted_name;
d4330 1
a4330 1
    *canonical = (char**) NULL;
d4333 1
a4333 1
  if (**spec == '*') 
d4337 2
a4338 2
      while (**spec != '\000' && 
	     ! strchr (ada_completer_word_break_characters, **spec))
d4347 1
a4347 1
      while (**spec == ' ' || **spec == '\t') 
d4351 1
a4351 1
  if (name[0] == '*') 
d4367 3
a4369 3
      unquoted_name = (char*) alloca (len-1);
      memcpy (unquoted_name, name+1, len-2);
      unquoted_name[len-2] = '\000';
d4374 1
a4374 1
      unquoted_name = (char*) alloca (len+1);
d4377 1
a4377 1
      lower_name = (char*) alloca (len + 1);
d4384 2
a4385 2
  if (lower_name != NULL) 
    n_matches = ada_lookup_symbol_list (ada_mangle (lower_name), block, 
d4388 1
a4388 1
    n_matches = ada_lookup_symbol_list (unquoted_name, block, 
d4398 1
a4398 1
#define volatile /*nothing*/
d4402 1
a4402 1
      struct minimal_symbol* msymbol;
d4407 1
a4407 1
      if (lower_name != NULL) 
d4413 1
a4413 1
	  val.pc      = SYMBOL_VALUE_ADDRESS (msymbol);
d4425 2
a4426 2
	}	
      
d4432 1
a4432 1
      return selected;	/* for lint */
d4437 2
a4438 2
      return 
	find_sal_from_funcs_and_line (file_table->filename, line_num, 
d4443 2
a4444 1
      selected.nelts = user_select_syms (symbols, blocks, n_matches, n_matches);
d4447 1
a4447 1
  selected.sals = (struct symtab_and_line*) 
d4455 1
a4455 1
      if (SYMBOL_CLASS (symbols[i]) == LOC_BLOCK) 
d4457 1
a4457 1
      else if (SYMBOL_LINE (symbols[i]) != 0) 
d4465 2
a4466 2
	  symbols[i] = symbols[selected.nelts-1];
	  blocks[i] = blocks[selected.nelts-1];
d4470 1
a4470 1
      else 
d4477 1
a4477 1
      *canonical = (char**) xmalloc (sizeof(char*) * selected.nelts);
d4479 2
a4480 2
	(*canonical)[i] = 
	  extended_canonical_line_spec (selected.sals[i], 
d4483 1
a4483 1
   
d4486 2
a4487 2
}  
      
d4490 1
a4490 1
   in SYMBOLS[0 .. NSYMS-1]. */   
d4492 2
a4493 2
find_sal_from_funcs_and_line (const char* filename, int line_num,
			      struct symbol** symbols, int nsyms)
d4497 4
a4500 4
  struct linetable* best_linetable;
  struct objfile* objfile;
  struct symtab* s;
  struct symtab* best_symtab;
d4504 3
a4506 1
  best_index = 0; best_linetable = NULL; best_symtab = NULL;
d4509 3
a4511 3
    {
      struct linetable *l;
      int ind, exact;
d4513 1
a4513 1
      QUIT;	
d4515 22
a4536 22
      if (!STREQ (filename, s->filename))
	continue;
      l = LINETABLE (s);
      ind = find_line_in_linetable (l, line_num, symbols, nsyms, &exact);
      if (ind >= 0)
	{
	  if (exact)
	    {
	      best_index = ind;
	      best_linetable = l;
	      best_symtab = s;
	      goto done;
	    }
	  if (best == 0 || l->item[ind].line < best)
	    {
	      best = l->item[ind].line;
	      best_index = ind;
	      best_linetable = l;
	      best_symtab = s;
	    }
	}
    }
d4541 2
a4542 2
 done:
  
d4544 1
a4544 1
  sals.sals = (struct symtab_and_line*) xmalloc (sizeof (sals.sals[0]));
d4547 1
a4547 1
  
d4559 2
a4560 2
find_line_in_linetable (struct linetable* linetable, int line_num,
			struct symbol** symbols, int nsyms, int* exactp)
d4571 1
a4571 1
      struct linetable_entry* item = &(linetable->item[i]);
d4605 1
a4605 1
nearest_line_number_in_linetable (struct linetable* linetable, int line_num)
d4613 2
a4614 1
  i = 0; best = INT_MAX;
d4618 1
a4618 1
      struct linetable_entry* item = &(linetable->item[i]);
d4622 1
a4622 1
	  char* func_name;
d4632 1
a4632 1
	      else 
d4634 1
a4634 1
		  struct symbol* sym = 
d4665 1
a4665 1
find_next_line_in_linetable (struct linetable* linetable, int line_num,
d4674 1
a4674 1
  if (ind >= 0) 
d4679 1
a4679 1
				    (char**) NULL, &start, &end)) 
d4694 1
a4694 1
      struct linetable_entry* item = &(linetable->item[i]);
d4698 1
a4698 1
	  char* func_name;
d4708 1
a4708 1
		  struct symbol* sym = 
d4714 1
a4714 1
		      while ((i+1) < len && linetable->item[i+1].pc < end)
d4729 1
a4729 1
is_plausible_func_for_line (struct symbol* sym, int line_num)
d4742 1
a4742 1
debug_print_lines (struct linetable* lt)
d4746 1
a4746 1
  if (lt == NULL) 
d4756 1
a4756 1
debug_print_block (struct block* b)
d4761 4
a4764 4
  fprintf (stderr, "Block: %p; [0x%lx, 0x%lx]", 
	   b, BLOCK_START(b), BLOCK_END(b));
  if (BLOCK_FUNCTION(b) != NULL)
    fprintf (stderr, " Function: %s", SYMBOL_NAME (BLOCK_FUNCTION(b)));
d4766 1
a4766 1
  fprintf (stderr, "\t    Superblock: %p\n", BLOCK_SUPERBLOCK(b));
d4769 5
a4773 5
    {
      if (i > 0 && i % 4 == 0)
	fprintf (stderr, "\n\t\t    ");
      fprintf (stderr, " %s", SYMBOL_NAME (sym));
    }
d4778 1
a4778 1
debug_print_blocks (struct blockvector* bv)
d4784 5
a4788 4
  for (i = 0; i < BLOCKVECTOR_NBLOCKS (bv); i += 1) {
    fprintf (stderr, "%6d. ", i);
    debug_print_block (BLOCKVECTOR_BLOCK (bv, i));
  }
d4792 1
a4792 1
debug_print_symtab (struct symtab* s)
d4797 2
a4798 2
	   BLOCKVECTOR(s), s->primary);
  debug_print_blocks (BLOCKVECTOR(s));
d4800 1
a4800 1
  debug_print_lines (LINETABLE(s));
d4806 1
a4806 1
read_all_symtabs (const char* filename)
d4808 2
a4809 2
  struct partial_symtab* ps;
  struct objfile* objfile;
d4812 2
a4813 2
    {
      QUIT;
d4815 3
a4817 3
      if (STREQ (filename, ps->filename))
	PSYMTAB_TO_SYMTAB (ps);
    }
d4824 1
a4824 1
all_sals_for_line (const char* filename, int line_num, char*** canonical)
d4827 3
a4829 3
  struct objfile* objfile;
  struct symtab* s;
  struct cleanup* old_chain = make_cleanup (null_cleanup, NULL);
d4834 2
a4835 1
  result.sals = (struct symtab_and_line*) xmalloc (4 * sizeof (result.sals[0]));
d4840 5
a4844 3
  ALL_SYMTABS (objfile, s) 
    {
      int ind, target_line_num;
d4846 2
a4847 1
      QUIT;
d4849 4
a4852 2
      if (!STREQ (s->filename, filename))
	continue;
d4854 6
a4859 4
      target_line_num = 
	nearest_line_number_in_linetable (LINETABLE (s), line_num);
      if (target_line_num == -1)
	continue;
d4861 2
a4862 9
      ind = -1;
      while (1) 
	{
	  ind = 
	    find_next_line_in_linetable (LINETABLE (s),
					 target_line_num, line_num, ind);
	  
	  if (ind < 0)
	    break;
d4864 8
a4871 8
	  GROW_VECT (result.sals, len, result.nelts+1);
	  INIT_SAL (&result.sals[result.nelts]);
	  result.sals[result.nelts].line = LINETABLE(s)->item[ind].line;
	  result.sals[result.nelts].pc = LINETABLE(s)->item[ind].pc;
	  result.sals[result.nelts].symtab = s;
	  result.nelts += 1;
	}
    }
d4876 1
a4876 1
      char** func_names = (char**) alloca (result.nelts * sizeof (char*));
d4879 3
a4881 3
      int* choices = (int*) alloca (result.nelts * sizeof (int));
      
      for (k = 0; k < result.nelts; k += 1) 
d4883 2
a4884 2
	  find_pc_partial_function (result.sals[k].pc, &func_names[k], 
				    (CORE_ADDR*) NULL, (CORE_ADDR*) NULL);
d4888 2
a4889 2
      
      if (result.nelts > 1) 
d4891 3
a4893 3
	  printf_unfiltered("[0] cancel\n");
	  if (result.nelts > 1) 
	    printf_unfiltered("[1] all\n");
d4895 1
a4895 1
	    printf_unfiltered ("[%d] %s\n", k + first_choice, 
d4897 1
a4897 1
	  
d4900 2
a4901 2
      
	  for (k = 0; k < n; k += 1) 
d4909 1
a4909 1
      if (canonical != NULL) 
d4911 1
a4911 1
	  *canonical = (char**) xmalloc (result.nelts * sizeof (char**));
d4913 1
a4913 1
	  for (k = 0; k < result.nelts; k += 1) 
d4915 1
a4915 1
	      (*canonical)[k] = 
d4934 2
a4935 2
static char*
extended_canonical_line_spec (struct symtab_and_line sal, const char* name)
d4937 1
a4937 1
  char* r;
d4939 1
a4939 2
  if (sal.symtab == NULL || sal.symtab->filename == NULL || 
      sal.line <= 0)
d4942 2
a4943 2
  r = (char*) xmalloc (strlen (name) + strlen (sal.symtab->filename)  
		       + sizeof(sal.line)*3 + 3);
d4953 2
a4954 2
static void 
begin_cleanup (void* dummy) 
d4965 1
a4965 1
  struct cleanup* old_chain = make_cleanup (begin_cleanup, NULL);
d4971 1
a4971 1
  
d4974 2
a4975 2
    error ("Cannot find the Ada initialization procedure.  Is this an Ada main program?");
  */
d4982 12
a4993 12
  {
    main_program_name_addr = SYMBOL_VALUE_ADDRESS (msym);
    if (main_program_name_addr == 0)
      error ("Invalid address for Ada main program name.");

    /* Read the name of the main procedure */
    extract_string (main_program_name_addr, main_program_name);

    /* Put a temporary breakpoint in the Ada main program and run */
    do_command ("tbreak ", main_program_name, 0);
    do_command ("run ", args, 0);
  }
d4995 22
a5016 22
  {
    /* If we could not find the symbol containing the name of the
       main program, that means that the compiler that was used to build
       was not recent enough. In that case, we fallback to the previous
       mechanism, which is a little bit less reliable, but has proved to work
       in most cases. The only cases where it will fail is when the user
       has set some breakpoints which will be hit before the end of the
       begin command processing (eg in the initialization code).

       The begining of the main Ada subprogram is located by breaking
       on the adainit procedure. Since we know that the binder generates
       the call to this procedure exactly 2 calls before the call to the
       Ada main subprogram, it is then easy to put a breakpoint on this
       Ada main subprogram once we hit adainit.
     */
     do_command ("tbreak adainit", 0);
     do_command ("run ", args, 0);
     do_command ("up", 0);
     do_command ("tbreak +2", 0);
     do_command ("continue", 0);
     do_command ("step", 0);
  }
d5026 1
a5026 2
	  STREQN (filename, "g-", 2) ||
	  STREQN (filename, "i-", 2));
d5036 1
a5036 1
  
d5040 5
a5044 5
	 points to *after* the call instruction, and we want to get the line
	 containing the call, never the next line.  But if the next frame is
	 a signal_handler_caller or a dummy frame, then the next frame was
	 not entered as the result of a call, and we want to get the line
	 containing fi->pc.  */
d5046 1
a5046 1
        find_pc_line (fi->pc,
d5053 2
a5054 2
	/* libpthread.so contains some debugging information that prevents us
	   from finding the right frame */
d5058 1
a5058 1
	      continue;
d5074 35
a5108 35
    {
      /* Assume that cond has 16 elements, the 15th
	 being the exception */ /*
      if (b->cond && b->cond->nelts == 16)
	{
	  ui_out_text (uiout, "on ");
	  ui_out_field_string (uiout, "exception",
			       SYMBOL_NAME (b->cond->elts[14].symbol));
	}
      else
	ui_out_text (uiout, "on all exceptions");
    }
  else if (b->break_on_exception == 2)
    ui_out_text (uiout, "on unhandled exception");
  else if (b->break_on_exception == 3)
    ui_out_text (uiout, "on assert failure");
#else
  if (b->break_on_exception == 1)
  {*/
      /* Assume that cond has 16 elements, the 15th
	 being the exception */ /*
      if (b->cond && b->cond->nelts == 16)
	{
	  fputs_filtered ("on ", gdb_stdout);
	  fputs_filtered (SYMBOL_NAME
			  (b->cond->elts[14].symbol), gdb_stdout);
	}
      else
	fputs_filtered ("on all exceptions", gdb_stdout);
    }
  else if (b->break_on_exception == 2)
    fputs_filtered ("on unhandled exception", gdb_stdout);
  else if (b->break_on_exception == 3)
    fputs_filtered ("on assert failure", gdb_stdout);
*/    
d5113 1
a5113 1
ada_is_exception_sym (struct symbol* sym)
d5116 1
a5116 1
  
d5120 1
a5120 2
	  && type_name != NULL
	  && STREQ (type_name, "exception"));
d5124 1
a5124 1
ada_maybe_exception_partial_symbol (struct partial_symbol* sym)
d5135 2
a5136 1
char* ada_breakpoint_rewrite (char* arg, int* break_on_exceptionp)
d5141 1
a5141 1
  /* FIXME: language_ada should be defined in defs.h */  
d5143 52
a5194 52
      && STREQN (arg, "exception", 9) &&
      (arg[9] == ' ' || arg[9] == '\t' || arg[9] == '\0'))
    {
      char *tok, *end_tok;
      int toklen;

      *break_on_exceptionp = 1;

      tok = arg+9;
      while (*tok == ' ' || *tok == '\t')
	tok += 1;

      end_tok = tok;

      while (*end_tok != ' ' && *end_tok != '\t' && *end_tok != '\000')
	end_tok += 1;

      toklen = end_tok - tok;

      arg = (char*) xmalloc (sizeof ("__gnat_raise_nodefer_with_msg if "
				     "long_integer(e) = long_integer(&)")
			     + toklen + 1);
      make_cleanup (xfree, arg);
      if (toklen == 0)
	strcpy (arg, "__gnat_raise_nodefer_with_msg");
      else if (STREQN (tok, "unhandled", toklen))
	{
	  *break_on_exceptionp = 2;
	  strcpy (arg, "__gnat_unhandled_exception");
	}
      else
	{
	  sprintf (arg, "__gnat_raise_nodefer_with_msg if "
		   "long_integer(e) = long_integer(&%.*s)", 
		   toklen, tok);
	}
    }
  else if (current_language->la_language == language_ada
	   && STREQN (arg, "assert", 6) &&
	   (arg[6] == ' ' || arg[6] == '\t' || arg[6] == '\0'))
    {
      char *tok = arg + 6;

      *break_on_exceptionp = 3;

      arg = (char*) 
	xmalloc (sizeof ("system__assertions__raise_assert_failure")
		 + strlen (tok) + 1);
      make_cleanup (xfree, arg);
      sprintf (arg, "system__assertions__raise_assert_failure%s", tok);
    }
  */
d5197 1
a5198 1

d5209 1
a5209 1
  else 
d5211 1
a5211 1
      const char* name = TYPE_FIELD_NAME (type, field_num);
d5213 1
a5213 1
	      || (name[0] == '_' && ! STREQN (name, "_parent", 7)));
d5230 2
a5231 2
struct type*
ada_tag_type (struct value* val)
d5238 2
a5239 2
struct value*
ada_value_tag (struct value* val)
d5246 1
a5246 1
struct type*
d5270 2
a5271 2
  const char* name = TYPE_FIELD_NAME (check_typedef (type), field_num);
  return (name != NULL && 
d5284 3
a5286 3
  const char* name = TYPE_FIELD_NAME (type, field_num);
  return (name != NULL 
	  && (STREQN (name, "PARENT", 6) || STREQ (name, "REP") 
d5293 1
a5293 1
   FIELD_NUM+1 fields. */ 
d5298 1
a5298 1
  struct type* field_type = TYPE_FIELD_TYPE (type, field_num);
d5301 2
a5302 1
	      && TYPE_CODE (TYPE_TARGET_TYPE (field_type)) == TYPE_CODE_UNION));
d5309 1
a5309 1
struct type*
d5312 2
a5313 3
  char* name = ada_variant_discrim_name (var_type);
  struct type *type = 
    ada_lookup_struct_elt_type (outer_type, name, 1, NULL);
d5327 1
a5327 1
  const char* name = TYPE_FIELD_NAME (type, field_num);
d5335 1
a5335 1
char * 
d5338 1
a5338 1
  static char* result = NULL;
d5340 4
a5343 4
  struct type* type;
  const char* name;
  const char* discrim_end; 
  const char* discrim_start;
d5364 1
a5364 1
  for (discrim_start = discrim_end; discrim_start != name+3;
d5367 1
a5367 1
      if (discrim_start == name+1)
d5369 1
a5369 1
      if ((discrim_start > name+3 && STREQN (discrim_start-3, "___", 3))
d5376 1
a5376 1
  result[discrim_end-discrim_start] = '\0';
d5389 1
a5389 1
ada_scan_number (const char str[], int k, LONGEST *R, int *new_k)
d5393 1
a5393 1
  if (! isdigit (str[k]))
d5402 1
a5402 1
      RU = RU*10 + (str[k] - '0');
d5406 1
a5406 1
  if (str[k] == 'm') 
d5409 1
a5409 1
	*R = (- (LONGEST) (RU-1)) - 1;
d5430 1
a5430 1
int 
d5433 1
a5433 1
  const char* name = TYPE_FIELD_NAME (type, field_num);
d5439 1
a5439 1
      switch (name[p]) 
d5446 1
a5446 1
	    if (! ada_scan_number (name, p + 1, &W, &p))
d5455 2
a5456 3
	    if (! ada_scan_number (name, p + 1, &L, &p)
		|| name[p] != 'T'
		|| ! ada_scan_number (name, p + 1, &U, &p))
d5476 2
a5477 2
struct value*
ada_value_primitive_field (struct value* arg1, int offset, int fieldno,
d5480 1
a5480 1
  struct value* v;
d5492 1
a5492 1
      
d5494 2
a5495 2
					     offset + bit_pos/8, bit_pos % 8,
					     bit_size, type);
d5508 2
a5509 2
struct value*
ada_search_struct_field (char *name, struct value* arg, int offset,
d5515 1
a5515 1
  for (i = TYPE_NFIELDS (type)-1; i >= 0; i -= 1)
d5523 1
a5523 1
	  return ada_value_primitive_field (arg, offset, i, type);
d5527 7
a5533 4
	  struct value* v = 
	    ada_search_struct_field (name, arg, 
				     offset + TYPE_FIELD_BITPOS (type, i) / 8, 
				     TYPE_FIELD_TYPE (type, i));
d5546 7
a5552 5
	      struct value* v = 
		ada_search_struct_field (name, arg, 
					 var_offset 
					 + TYPE_FIELD_BITPOS (field_type, j)/8,
					 TYPE_FIELD_TYPE (field_type, j));
d5560 1
a5560 1
  
d5572 1
a5572 1
struct value*
d5576 1
a5576 1
  struct value* v;
d5589 3
a5591 3
  if (   TYPE_CODE (t) != TYPE_CODE_STRUCT
      && TYPE_CODE (t) != TYPE_CODE_UNION)
    error ("Attempt to extract a component of a value that is not a %s.", err);
d5617 2
a5618 1
ada_lookup_struct_elt_type (struct type *type, char *name, int noerr, int *dispp)
d5651 1
a5651 1
  
d5657 1
a5657 1
	  if (dispp != NULL) 
d5665 1
a5665 1
	  t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (type, i), name, 
d5687 1
a5687 1
		  if (dispp != NULL) 
d5697 1
a5697 1
  if (! noerr)
d5715 1
a5715 1
int 
d5717 1
a5717 1
			   char* outer_valaddr)
d5722 2
a5723 2
  struct type* discrim_type;
  char* discrim_name = ada_variant_discrim_name (var_type);
d5727 1
a5727 1
  discrim_type = 
d5744 1
a5746 1

d5786 2
a5787 2
struct value*
ada_value_ind (struct value* val0)
d5789 1
a5789 1
  struct value* val = unwrap_value (value_ind (val0));
d5791 1
a5791 2
			     VALUE_ADDRESS (val) + VALUE_OFFSET (val),
			     val);
d5796 2
a5797 2
static struct value* 
ada_coerce_ref (struct value* val0)
d5799 10
a5808 8
  if (TYPE_CODE (VALUE_TYPE (val0)) == TYPE_CODE_REF) {
    struct value* val = val0;
    COERCE_REF (val);
    val = unwrap_value (val);
    return ada_to_fixed_value (VALUE_TYPE (val), 0, 
			       VALUE_ADDRESS (val) + VALUE_OFFSET (val),
			       val);
  } else
d5841 1
a5841 1
  const char* name = TYPE_FIELD_NAME (type, f);
d5845 1
a5845 1
  if (len < 8 || ! isdigit (name[len-1]))
d5848 1
a5848 1
  if (isdigit (name[len-2]))
d5853 1
a5853 1
  if (align_offset < 7 || ! STREQN ("___XV", name+align_offset-6, 5))
d5856 1
a5856 1
  return atoi (name+align_offset) * TARGET_CHAR_BIT;
d5860 1
a5860 1
struct type*
d5863 1
a5863 1
  struct symbol* sym;
d5881 1
a5881 1
ada_prefer_type (struct type* type0, struct type* type1)
d5893 2
a5894 1
  else if (ada_is_array_descriptor (type0) && ! ada_is_array_descriptor (type1))
d5896 1
a5896 1
  else if (ada_renaming_type (type0) != NULL 
d5904 2
a5905 2
char*
ada_type_name (struct type* type)
d5907 1
a5907 1
  if (type == NULL) 
d5918 1
a5918 1
struct type*
d5921 1
a5921 1
  static char* name;
d5923 2
a5924 2
  struct symbol** syms;
  struct block** blocks;
d5927 2
a5928 2
  char* typename = ada_type_name (type);
  
d5934 1
a5934 1
  GROW_VECT (name, name_len, len+strlen (suffix)+1);
d5946 2
a5947 2
static struct type*
dynamic_template_type (struct type* type)
d5952 1
a5952 1
      || ada_type_name (type) == NULL) 
d5954 1
a5954 1
  else 
d5967 2
a5968 2
static int 
is_dynamic_field (struct type* templ_type, int field_num)
d5971 1
a5971 1
  return name != NULL 
d5979 2
a5980 2
static int 
contains_variant_part (struct type* type)
d5991 2
a5992 2
static struct type*
empty_record (struct objfile* objfile) 
d5994 1
a5994 1
  struct type* type = alloc_type (objfile);
d6017 7
a6023 7
static struct type*
template_to_fixed_record_type (struct type* type, char* valaddr,
			       CORE_ADDR address, struct value* dval0)
{
  struct value* mark = value_mark();
  struct value* dval;
  struct type* rtype;
d6033 1
a6033 1
  TYPE_FIELDS (rtype) = (struct field*) 
d6039 2
a6040 2
     gdbtypes.h */  
  /*  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE;*/
d6042 2
a6043 1
  off = 0; bit_len = 0;
d6047 3
a6049 2
      off = 
	align_value (off, field_alignment (type, f))+TYPE_FIELD_BITPOS (type,f);
d6054 1
a6054 1
      TYPE_FIELD_BITSIZE (rtype, f) = 0;  
d6056 1
a6056 1
      if (ada_is_variant_part (type, f)) 
d6061 1
a6061 2
	    dval = 
	      value_from_contents_and_address (rtype, valaddr, address);
d6065 6
a6070 7
	  branch_type = 
	    to_fixed_variant_branch_type 
	      (TYPE_FIELD_TYPE (type, f),
	       cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
	       cond_offset_target (address, off / TARGET_CHAR_BIT),
	       dval);
	  if (branch_type == NULL) 
d6084 1
a6084 2
	    dval = 
	      value_from_contents_and_address (rtype, valaddr, address);
d6088 6
a6093 7
	  TYPE_FIELD_TYPE (rtype, f) = 
	    ada_to_fixed_type 
	      (ada_get_base_type 
	       (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, f))),
	       cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
	       cond_offset_target (address, off / TARGET_CHAR_BIT),
	       dval);
d6103 1
a6103 1
	    bit_incr = fld_bit_len = 
d6117 1
a6117 1
  if (TYPE_LENGTH (rtype) > varsize_limit) 
d6129 2
a6130 2
static struct type*
template_to_static_fixed_type (struct type* templ_type)
d6140 2
a6141 1
  TYPE_TARGET_TYPE (templ_type) = type = alloc_type (TYPE_OBJFILE (templ_type));
d6145 1
a6145 1
  TYPE_FIELDS (type) = (struct field*) 
d6150 1
a6150 1
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */  
d6157 1
a6157 1
      TYPE_FIELD_BITSIZE (type, f) = 0;  
d6161 2
a6162 2
	  TYPE_FIELD_TYPE (type, f) = 
	    to_static_fixed_type (TYPE_TARGET_TYPE 
d6168 1
a6168 1
	  TYPE_FIELD_TYPE (type, f) = 
d6180 3
a6182 3
static struct type*
to_record_with_fixed_variant_part (struct type* type, char* valaddr,
				   CORE_ADDR address, struct value* dval)
d6184 2
a6185 2
  struct value* mark = value_mark();
  struct type* rtype;
d6196 3
a6198 3
  TYPE_FIELDS (rtype) = 
    (struct field*) TYPE_ALLOC (rtype, nfields * sizeof (struct field));
  memcpy (TYPE_FIELDS (rtype), TYPE_FIELDS (type), 
d6202 1
a6202 1
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */  
d6206 11
a6216 9
  branch_type = 
    to_fixed_variant_branch_type 
      (TYPE_FIELD_TYPE (type, nfields - 1),
       cond_offset_host (valaddr, 
			 TYPE_FIELD_BITPOS (type, nfields-1) / TARGET_CHAR_BIT),
       cond_offset_target (address, 
			 TYPE_FIELD_BITPOS (type, nfields-1) / TARGET_CHAR_BIT),
       dval);
  if (branch_type == NULL) 
d6219 2
a6220 1
      TYPE_LENGTH (rtype) -= TYPE_LENGTH (TYPE_FIELD_TYPE (type, nfields - 1));
d6224 3
a6226 3
      TYPE_FIELD_TYPE (rtype, nfields-1) = branch_type;
      TYPE_FIELD_NAME (rtype, nfields-1) = "S";
      TYPE_FIELD_BITSIZE (rtype, nfields-1) = 0;
d6228 1
a6228 1
	- TYPE_LENGTH (TYPE_FIELD_TYPE (type, nfields - 1));
d6230 1
a6230 1
  
d6240 1
a6240 1
   of the variant. */ 
d6242 3
a6244 3
static struct type*
to_fixed_record_type (struct type* type0, char* valaddr, CORE_ADDR address,
		      struct value* dval)
d6246 1
a6246 1
  struct type* templ_type;
d6250 3
a6252 3
    return type0;
  */
  templ_type = dynamic_template_type (type0);  
d6260 1
a6260 1
      /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */      
d6274 3
a6276 3
static struct type*
to_fixed_variant_branch_type (struct type* var_type0, char* valaddr,
			      CORE_ADDR address, struct value* dval)
d6279 2
a6280 2
  struct type* templ_type;
  struct type* var_type;
d6284 1
a6284 1
  else 
d6292 2
a6293 2
  which = 
    ada_which_variant_applies (var_type, 
d6299 4
a6302 4
    return 
      to_fixed_record_type 
         (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (var_type, which)),
	  valaddr, address, dval);
d6304 3
a6306 3
    return 
      to_fixed_record_type 
         (TYPE_FIELD_TYPE (var_type, which), valaddr, address, dval);
d6320 2
a6321 2
static struct type*
to_fixed_array_type (struct type* type0, struct value* dval,
d6324 2
a6325 2
  struct type* index_type_desc;
  struct type* result;
d6328 3
a6330 3
  /*  if (ada_is_packed_array_type (type0)  /* revisit? */ /*
      || (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE))
    return type0;*/
d6338 2
a6339 3
       * debugging data. */       
      struct type *elt_type = 
	ada_to_fixed_type (elt_type0, 0, 0, dval);
d6344 1
a6344 1
	result = create_array_type (alloc_type (TYPE_OBJFILE (type0)), 
d6358 2
a6359 3
       * debugging data. */       
      result = 
	ada_to_fixed_type (check_typedef (elt_type0), 0, 0, dval);
d6362 1
a6362 1
	  struct type *range_type = 
d6368 1
a6368 1
      if (! ignore_too_big && TYPE_LENGTH (result) > varsize_limit) 
d6375 1
a6375 1
}  
d6383 3
a6385 3
struct type*
ada_to_fixed_type (struct type* type, char* valaddr, CORE_ADDR address,
		   struct value* dval)
d6388 3
a6390 9
  switch (TYPE_CODE (type)) {
  default:
    return type;
  case TYPE_CODE_STRUCT:
    return to_fixed_record_type (type, valaddr, address, NULL);
  case TYPE_CODE_ARRAY:
    return to_fixed_array_type (type, dval, 0);
  case TYPE_CODE_UNION:
    if (dval == NULL) 
d6392 10
a6401 3
    else
      return to_fixed_variant_branch_type (type, valaddr, address, dval);
  }
d6407 2
a6408 2
static struct type*
to_static_fixed_type (struct type* type0)
d6410 1
a6410 1
  struct type* type;
d6417 2
a6418 2
    return type0;
  */
d6420 1
a6420 1
  
d6427 1
a6427 1
      if (type != NULL) 
d6439 2
a6440 2
static struct type*
static_unwrap_type (struct type* type)
d6444 1
a6444 1
      struct type* type1 = TYPE_FIELD_TYPE (check_typedef (type), 0);
d6450 1
a6450 1
  else 
d6452 2
a6453 2
      struct type* raw_real_type = ada_get_base_type (type);
      if (raw_real_type == type) 
d6473 2
a6474 2
struct type*
ada_completed_type (struct type* type)
d6481 1
a6481 1
  else 
d6483 2
a6484 2
      char* name = TYPE_TAG_NAME (type);
      struct type* type1 = ada_find_any_type (name);
d6493 1
a6493 1
   creation of struct values]. */ 
d6495 3
a6497 3
struct value*
ada_to_fixed_value (struct type* type0, char* valaddr, CORE_ADDR address,
		    struct value* val0)
d6499 1
a6499 1
  struct type* type = ada_to_fixed_type (type0, valaddr, address, NULL);
d6502 2
a6503 1
  else return value_from_contents_and_address (type, valaddr, address);
d6511 2
a6512 2
struct value*
ada_to_static_fixed_value (struct value* val)
d6514 1
a6514 1
  struct type *type = 
d6521 1
a6523 1

d6531 1
a6531 1
static const char* attribute_names[] = {
d6534 1
a6534 1
  "first", 
d6541 1
a6541 2
  "pos"
  "tag",
d6547 1
a6547 1
const char*
d6558 2
a6559 2
static struct value*
value_pos_atr (struct value* arg)
d6563 1
a6563 1
  if (! discrete_type_p (type))
d6571 1
a6571 1
      for (i = 0; i < TYPE_NFIELDS (type); i += 1) 
d6584 2
a6585 2
static struct value*
value_val_atr (struct type *type, struct value* arg)
d6587 1
a6587 1
  if (! discrete_type_p (type))
d6589 1
a6589 1
  if (! integer_type_p (VALUE_TYPE (arg)))
d6597 1
a6597 2
      return 
	value_from_longest (type, TYPE_FIELD_BITPOS (type, pos));
d6602 1
a6603 1

d6610 2
a6611 2
int 
ada_is_character_type (struct type* type)
d6613 2
a6614 2
  const char* name = ada_type_name (type);
  return 
d6616 1
a6616 1
    && (TYPE_CODE (type) == TYPE_CODE_CHAR 
d6629 1
a6629 1
  if (type != NULL 
d6638 1
a6638 1
  else 
d6659 2
a6660 2
struct type*
ada_get_base_type (struct type* raw_type)
d6662 3
a6664 3
  struct type* real_type_namer;
  struct type* raw_real_type;
  struct type* real_type;
d6670 1
a6670 1
  if (real_type_namer == NULL 
d6676 1
a6676 1
  if (raw_real_type == NULL) 
d6680 1
a6680 1
}  
d6684 2
a6685 2
struct type*
ada_aligned_type (struct type* type)
d6697 1
a6697 1
char*
d6700 1
a6700 1
  if (ada_is_aligner_type (type)) 
d6702 3
a6704 2
				   valaddr + 
				   TYPE_FIELD_BITPOS (type, 0)/TARGET_CHAR_BIT);
d6711 2
a6712 2
const char*
ada_enum_name (const char* name)
d6714 1
a6714 1
  char* tmp;
d6716 1
a6716 1
  while (1) 
d6719 1
a6719 1
	name = tmp+2;
d6721 1
a6721 1
	name = tmp+1;
d6732 1
a6732 1
	  if (sscanf (name+2, "%x", &v) != 1) 
d6747 1
a6747 1
  else 
d6751 1
a6751 1
static struct value*
d6762 2
a6763 2
static struct value*
evaluate_subexp_type (struct expression* exp, int* pos)
d6765 1
a6765 1
  return (*exp->language_defn->evaluate_exp) 
d6770 1
a6770 1
   value it wraps. */ 
d6772 2
a6773 2
static struct value*
unwrap_value (struct value* val)
d6775 1
a6775 1
  struct type* type = check_typedef (VALUE_TYPE (val));
d6778 3
a6780 3
      struct value* v = value_struct_elt (&val, NULL, "F", 
				      NULL, "internal structure");
      struct type* val_type = check_typedef (VALUE_TYPE (v));
d6786 1
a6786 1
  else 
d6788 1
a6788 1
      struct type* raw_real_type = 
d6790 1
a6790 1
      
d6794 2
a6795 2
      return 
	coerce_unspec_val_to_type 
d6801 3
a6803 3
    
static struct value*
cast_to_fixed (struct type *type, struct value* arg)
d6810 1
a6810 1
    val = ada_float_to_fixed (type, 
d6813 1
a6813 1
  else 
d6815 1
a6815 1
      DOUBLEST argd = 
d6823 2
a6824 2
static struct value*
cast_from_fixed_to_double (struct value* arg)
d6833 2
a6834 2
static struct value*
coerce_for_assign (struct type* type, struct value* val)
d6836 1
a6836 1
  struct type* type2 = VALUE_TYPE (val);
d6843 2
a6844 1
  if (TYPE_CODE (type2) == TYPE_CODE_PTR && TYPE_CODE (type) == TYPE_CODE_ARRAY)
d6850 1
a6850 1
  if (TYPE_CODE (type2) == TYPE_CODE_ARRAY 
d6855 1
a6855 1
	     != TYPE_LENGTH (TYPE_TARGET_TYPE (type2)))
d6859 1
a6859 1
  return val;  
d6862 1
a6862 1
struct value*
d6873 1
a6873 1
  struct value* *argvec;
d6875 2
a6876 1
  pc = *pos; *pos += 1;
d6879 1
a6879 1
  switch (op) 
d6883 3
a6885 1
      return unwrap_value (evaluate_subexp_standard (expect_type, exp, pos, noside));
d6899 1
a6899 1
	  else if (VALUE_LVAL (arg1) == lval_memory) 
d6902 5
a6906 5
		 but apparently expected) case of (Foo) Bar.all, where Bar 
		 is an integer constant and Foo is a dynamic-sized type.
		 If we don't do this, ARG1 will simply be relabeled with
		 TYPE. */
	      if (noside == EVAL_AVOID_SIDE_EFFECTS) 
d6908 3
a6910 3
	      arg1 = 
		ada_to_fixed_value 
		  (type, 0, VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1), 0);
d6912 2
a6913 2
	  else		 
	    arg1 = value_cast (type, arg1);	
d6919 4
a6922 4
      (*pos) += 2;
      type = exp->elts[pc + 1].type;
      return ada_evaluate_subexp (type, exp, pos, noside);
      */
d6930 1
a6930 1
      else 
d6935 3
a6937 2
	    error ("Fixed-point values must be assigned to fixed-point variables");
	  else 
d6954 2
a6955 1
	    error ("Operands of fixed-point addition must have the same type");
d6971 2
a6972 1
	    error ("Operands of fixed-point subtraction must have the same type");		
d6987 1
a6987 1
	  return value_zero (VALUE_TYPE (arg1), not_lval);
d7010 1
a7010 1
      /* Only encountered when an unresolved symbol occurs in a
d7012 8
a7019 8
	 illegal. *//*
      (*pos) += 3;
      if (noside == EVAL_SKIP)
	goto nosideret;
      else 
	error ("Unexpected unresolved symbol, %s, during evaluation",
	       ada_demangle (exp->elts[pc + 2].name));
      */
d7026 1
a7026 1
	} 
d7030 3
a7032 3
	  return value_zero 
	    (to_static_fixed_type 
	     (static_unwrap_type (SYMBOL_TYPE (exp->elts[pc+2].symbol))),
d7035 1
a7035 1
      else 
d7037 3
a7039 2
	  arg1 = unwrap_value (evaluate_subexp_standard (expect_type, exp, pos, 
							 noside));
d7041 2
a7042 2
				     VALUE_ADDRESS (arg1) + VALUE_OFFSET(arg1),
				     arg1);
d7052 2
a7053 1
      argvec = (struct value* *) alloca (sizeof (struct value*) * (nargs + 1));
d7068 1
a7068 1
	 called in argvec[0] and a terminating NULL */
d7070 2
a7071 1
      argvec = (struct value* *) alloca (sizeof (struct value*) * (nargs + 2));
d7076 4
a7079 4
	error ("Unexpected unresolved symbol, %s, during evaluation",
	       ada_demangle (exp->elts[pc + 5].name));
      */
      if (0) 
d7101 1
a7101 1
	{	
d7118 1
a7118 1
	  }
d7120 1
a7120 1
	  
d7127 1
a7127 1
	case TYPE_CODE_STRUCT: 
d7131 1
a7131 1
	    if (type == NULL) 
d7133 1
a7133 1
	    if (arity != nargs) 
d7135 1
a7135 1
	    if (noside == EVAL_AVOID_SIDE_EFFECTS) 
d7137 3
a7139 1
	    return unwrap_value (ada_value_subscript (argvec[0], nargs, argvec+1));
d7143 1
a7143 1
	    {	
d7150 1
a7150 1
	  return 
d7153 2
a7154 2
			   nargs, argvec+1));
	case TYPE_CODE_PTR: /* Pointer to array */
d7157 1
a7157 1
	    {	
d7164 3
a7166 3
	  return 
	    unwrap_value (ada_value_ptr_subscript (argvec[0], type, 
						   nargs, argvec+1));
d7174 1
a7174 1
	struct value* array = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d7181 10
a7190 11
        
        /* If this is a reference to an array, then dereference it */
        if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_REF
            && TYPE_TARGET_TYPE (VALUE_TYPE (array)) != NULL
            && TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (array))) ==
                 TYPE_CODE_ARRAY
            && !ada_is_array_descriptor (check_typedef (VALUE_TYPE
               (array))))
          {
            array = ada_coerce_ref (array);
          }
d7196 1
a7196 1
	    struct type * arrType = ada_type_of_array (array, 0);
d7198 1
a7198 1
	      array = value_at_lazy (arrType, 0, NULL); 
d7203 11
a7213 11
        /* If at this point we have a pointer to an array, it means that
           it is a pointer to a simple (non-ada) array. We just then
           dereference it */
        if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_PTR
            && TYPE_TARGET_TYPE (VALUE_TYPE (array)) != NULL
            && TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (array))) ==
                 TYPE_CODE_ARRAY)
          {
              array = ada_value_ind (array);
          }
        
d7224 27
a7250 27
      (*pos) += 2;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      type = exp->elts[pc + 1].type;

      if (noside == EVAL_SKIP)
	goto nosideret;

      switch (TYPE_CODE (type)) 
	{
	default:
	  warning ("Membership test incompletely implemented; always returns true");
	  return value_from_longest (builtin_type_int, (LONGEST) 1);
	  
	case TYPE_CODE_RANGE:
	  arg2 = value_from_longest (builtin_type_int, 
				     (LONGEST) TYPE_LOW_BOUND (type));
	  arg3 = value_from_longest (builtin_type_int, 
				     (LONGEST) TYPE_HIGH_BOUND (type));
	  return 
	    value_from_longest (builtin_type_int,
				(value_less (arg1,arg3) 
				 || value_equal (arg1,arg3))
				&& (value_less (arg2,arg1)
				    || value_equal (arg2,arg1)));
	}
      */
      /* FIXME: BINOP_MBR should be defined in expression.h */      
d7252 25
a7276 25
      (*pos) += 2;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      if (noside == EVAL_SKIP)
	goto nosideret;

      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return value_zero (builtin_type_int, not_lval);

      tem = longest_to_int (exp->elts[pc + 1].longconst);

      if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg2)))
	error ("invalid dimension number to '%s", "range");

      arg3 = ada_array_bound (arg2, tem, 1);
      arg2 = ada_array_bound (arg2, tem, 0);

      return 
	value_from_longest (builtin_type_int,
			    (value_less (arg1,arg3) 
			     || value_equal (arg1,arg3))
			    && (value_less (arg2,arg1)
				|| value_equal (arg2,arg1)));
      */
d7279 14
a7292 14
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg3 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      if (noside == EVAL_SKIP)
	goto nosideret;

      return 
	value_from_longest (builtin_type_int,
			    (value_less (arg1,arg3) 
			     || value_equal (arg1,arg3))
			    && (value_less (arg2,arg1)
				|| value_equal (arg2,arg1)));
      */
d7295 218
a7512 218
      *pos += 3;
      atr = (enum ada_attribute) longest_to_int (exp->elts[pc + 2].longconst);
      switch (atr) 
	{
	default:
	  error ("unexpected attribute encountered");

	case ATR_FIRST:
	case ATR_LAST:
	case ATR_LENGTH:
	  {
	    struct type* type_arg;
	    if (exp->elts[*pos].opcode == OP_TYPE)
	      {
		evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
		arg1 = NULL;
		type_arg = exp->elts[pc + 5].type;
	      }
	    else
	      {
		arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
		type_arg = NULL;
	      }

	    if (exp->elts[*pos].opcode != OP_LONG) 
	      error ("illegal operand to '%s", ada_attribute_name (atr));
	    tem = longest_to_int (exp->elts[*pos+2].longconst);
	    *pos += 4;

	    if (noside == EVAL_SKIP)
	      goto nosideret;

	    if (type_arg == NULL)
	      {
		arg1 = ada_coerce_ref (arg1);

		if (ada_is_packed_array_type (VALUE_TYPE (arg1)))
		  arg1 = ada_coerce_to_simple_array (arg1);

		if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg1)))
		  error ("invalid dimension number to '%s", 
			 ada_attribute_name (atr));

		if (noside == EVAL_AVOID_SIDE_EFFECTS)
		  {
		    type = ada_index_type (VALUE_TYPE (arg1), tem);
		    if (type == NULL) 
		      error ("attempt to take bound of something that is not an array");
		    return allocate_value (type);
		  }

		switch (atr) 
		  {
		  default: 
		    error ("unexpected attribute encountered");
		  case ATR_FIRST:
		    return ada_array_bound (arg1, tem, 0);
		  case ATR_LAST:
		    return ada_array_bound (arg1, tem, 1);
		  case ATR_LENGTH:
		    return ada_array_length (arg1, tem);
		  }
	      }
	    else if (TYPE_CODE (type_arg) == TYPE_CODE_RANGE
		     || TYPE_CODE (type_arg) == TYPE_CODE_INT) 
	      {
		struct type* range_type;
		char* name = ada_type_name (type_arg);
		if (name == NULL)
		  {
		    if (TYPE_CODE (type_arg) == TYPE_CODE_RANGE) 
		      range_type = type_arg;
		    else
		      error ("unimplemented type attribute");
		  }
		else 
		  range_type = 
		    to_fixed_range_type (name, NULL, TYPE_OBJFILE (type_arg));
		switch (atr) 
		  {
		  default: 
		    error ("unexpected attribute encountered");
		  case ATR_FIRST:
		    return value_from_longest (TYPE_TARGET_TYPE (range_type),
					       TYPE_LOW_BOUND (range_type));
		  case ATR_LAST:
		    return value_from_longest (TYPE_TARGET_TYPE (range_type),
					       TYPE_HIGH_BOUND (range_type));
		  }
	      }		
	    else if (TYPE_CODE (type_arg) == TYPE_CODE_ENUM)
	      {
		switch (atr) 
		  {
		  default: 
		    error ("unexpected attribute encountered");
		  case ATR_FIRST:
		    return value_from_longest 
		      (type_arg, TYPE_FIELD_BITPOS (type_arg, 0));
		  case ATR_LAST:
		    return value_from_longest 
		      (type_arg, 
		       TYPE_FIELD_BITPOS (type_arg,
					  TYPE_NFIELDS (type_arg) - 1));
		  }
	      }
	    else if (TYPE_CODE (type_arg) == TYPE_CODE_FLT)
	      error ("unimplemented type attribute");
	    else 
	      {
		LONGEST low, high;

		if (ada_is_packed_array_type (type_arg))
		  type_arg = decode_packed_array_type (type_arg);

		if (tem < 1 || tem > ada_array_arity (type_arg))
		  error ("invalid dimension number to '%s", 
			 ada_attribute_name (atr));

		if (noside == EVAL_AVOID_SIDE_EFFECTS)
		  {
		    type = ada_index_type (type_arg, tem);
		    if (type == NULL) 
		      error ("attempt to take bound of something that is not an array");
		    return allocate_value (type);
		  }

		switch (atr) 
		  {
		  default: 
		    error ("unexpected attribute encountered");
		  case ATR_FIRST:
		    low = ada_array_bound_from_type (type_arg, tem, 0, &type);
		    return value_from_longest (type, low);
		  case ATR_LAST:
		    high = ada_array_bound_from_type (type_arg, tem, 1, &type);
		    return value_from_longest (type, high);
		  case ATR_LENGTH:
		    low = ada_array_bound_from_type (type_arg, tem, 0, &type);
		    high = ada_array_bound_from_type (type_arg, tem, 1, NULL);
		    return value_from_longest (type, high-low+1);
		  }
	      }
	  }

	case ATR_TAG:
	  arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  if (noside == EVAL_SKIP)
	    goto nosideret;

	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    return 	
	      value_zero (ada_tag_type (arg1), not_lval);
	  
	  return ada_value_tag (arg1);
	  
	case ATR_MIN:
	case ATR_MAX:
	  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
	  arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  if (noside == EVAL_SKIP)
	    goto nosideret;
	  else if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    return value_zero (VALUE_TYPE (arg1), not_lval);
	  else
	    return value_binop (arg1, arg2, 
				atr == ATR_MIN ? BINOP_MIN : BINOP_MAX);

	case ATR_MODULUS:
	  {
	    struct type* type_arg = exp->elts[pc + 5].type;
	    evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
	    *pos += 4;

	    if (noside == EVAL_SKIP)
	      goto nosideret;

	    if (! ada_is_modular_type (type_arg))
	      error ("'modulus must be applied to modular type");

	    return value_from_longest (TYPE_TARGET_TYPE (type_arg),
				       ada_modulus (type_arg));
	  }
	  

	case ATR_POS:
	  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
	  arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  if (noside == EVAL_SKIP)
	    goto nosideret;
	  else if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    return value_zero (builtin_type_ada_int, not_lval);
	  else 
	    return value_pos_atr (arg1);

	case ATR_SIZE:
	  arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  if (noside == EVAL_SKIP)
	    goto nosideret;
	  else if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    return value_zero (builtin_type_ada_int, not_lval);
	  else
	    return value_from_longest (builtin_type_ada_int,
				       TARGET_CHAR_BIT 
				       * TYPE_LENGTH (VALUE_TYPE (arg1)));

	case ATR_VAL:
	  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
	  arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  type = exp->elts[pc + 5].type;
	  if (noside == EVAL_SKIP)
	    goto nosideret;
	  else if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    return value_zero (type, not_lval);
	  else 
	    return value_val_atr (type, arg1);
	    }*/
d7520 3
a7522 4
	  EVAL_NORMAL));
      else
	if (noside == EVAL_AVOID_SIDE_EFFECTS)
	  return value_zero (VALUE_TYPE (arg1), not_lval);
d7546 1
a7546 1
        expect_type = TYPE_TARGET_TYPE (check_typedef (expect_type));
d7556 1
a7556 1
	      struct type* arrType = ada_type_of_array (arg1, 0); 
d7562 8
a7569 9
	      || TYPE_CODE (type) == TYPE_CODE_REF
	      /* In C you can dereference an array to get the 1st elt.  */
	      || TYPE_CODE (type) == TYPE_CODE_ARRAY
	      )
	    return 
	      value_zero 
	        (to_static_fixed_type 
		  (ada_aligned_type (check_typedef (TYPE_TARGET_TYPE (type)))),
		 lval_memory);
d7578 1
a7578 1
	  
d7592 1
a7592 1
	return value_zero (ada_aligned_type 
d7594 2
a7595 1
							&exp->elts[pc + 2].string,
d7610 1
a7610 1
      else 
d7612 1
a7612 1
      
d7620 1
a7620 1
	return value_zero (ada_aligned_type 
d7622 2
a7623 1
							&exp->elts[pc + 2].string,
d7635 1
a7636 1

d7643 1
a7643 1
static const char*
d7646 1
a7646 1
  const char* name = ada_type_name (type);
d7649 2
a7650 3
  if ((code == TYPE_CODE_INT || code == TYPE_CODE_RANGE)
      && name != NULL)
    {	
d7654 1
a7654 1
      else 
d7683 1
a7683 1
  else 
d7696 1
a7696 1
  
d7703 1
a7703 1
  else 
d7714 1
a7714 1
  return (DOUBLEST) x * scaling_factor (type);
d7732 1
a7732 1
ada_is_vax_floating_type (struct type* type)
d7734 1
a7734 1
  int name_len = 
d7736 1
a7736 1
  return 
d7738 1
a7738 1
    && (TYPE_CODE (type) == TYPE_CODE_INT 
d7746 1
a7746 1
ada_vax_float_type_suffix (struct type* type)
d7748 1
a7748 1
  return ada_type_name (type)[strlen (ada_type_name (type))-1];
d7754 2
a7755 2
struct value*
ada_vax_float_print_function (struct type* type)
d7757 11
a7767 13
  switch (ada_vax_float_type_suffix (type)) {
  case 'F':
    return 
      get_var_value ("DEBUG_STRING_F", 0);
  case 'D':
    return 
      get_var_value ("DEBUG_STRING_D", 0);
  case 'G':
    return 
      get_var_value ("DEBUG_STRING_G", 0);
  default:
    error ("invalid VAX floating-point type");
  }
d7769 1
a7770 1

d7780 2
a7781 1
scan_discrim_bound (char *, int k, struct value* dval, LONGEST *px, int *pnew_k)
d7787 1
a7787 1
  struct value* bound_val;
d7792 1
a7792 1
  pend = strstr (str+k, "__");
d7795 1
a7795 1
      bound = str+k;
d7798 1
a7798 1
  else 
d7800 1
a7800 1
      GROW_VECT (bound_buffer, bound_buffer_len, pend - (str+k) + 1);
d7802 6
a7807 7
      strncpy (bound_buffer, str+k, pend-(str+k));
      bound[pend-(str+k)] = '\0';
      k = pend-str;
    }
  
  bound_val = 
    ada_search_struct_field (bound, dval, 0, VALUE_TYPE (dval));
d7820 2
a7821 2
static struct value*
get_var_value (char* name, char* err_msg)
d7823 2
a7824 2
  struct symbol** syms;
  struct block** blocks;
d7827 3
a7829 2
  nsyms = ada_lookup_symbol_list (name, get_selected_block (NULL), VAR_NAMESPACE,
				  &syms, &blocks);
d7841 1
a7841 1
 
d7846 1
a7846 1
get_int_var_value (char* name, char* err_msg, int* flag)
d7848 2
a7849 2
  struct value* var_val = get_var_value (name, err_msg);
  
d7863 1
a7863 1
 
d7873 1
a7873 1
static struct type*
d7879 1
a7879 1
  char* subtype_info;
d7909 1
a7909 1
      if (*subtype_info == 'L') 
d7911 2
a7912 2
	  if (! ada_scan_number (bounds_str, n, &L, &n)
	      && ! scan_discrim_bound (bounds_str, n, dval, &L, &n))
d7916 1
a7916 1
	  else if (bounds_str[n] == '.') /* FIXME? SGI Workshop kludge. */
d7920 1
a7920 1
      else 
d7922 1
a7922 1
	  strcpy (name_buf+prefix_len, "___L");
d7926 1
a7926 1
      if (*subtype_info == 'U') 
d7928 1
a7928 1
	  if (! ada_scan_number (bounds_str, n, &U, &n)
d7932 1
a7932 1
      else 
d7934 1
a7934 1
	  strcpy (name_buf+prefix_len, "___U");
d7938 1
a7938 1
      if (objfile == NULL) 
d7941 1
a7941 1
      TYPE_NAME (type) = name; 
d7948 1
a7948 1
ada_is_range_type_name (const char* name)
d7951 2
a7952 1
}	  
a7953 1

d7958 1
a7958 1
ada_is_modular_type (struct type* type)
d7961 2
a7962 2
     valarith.c */  
  struct type* subranged_type; /* = base_type (type);*/
d7971 1
a7971 1
ada_modulus (struct type* type)
d7973 1
a7973 1
    return TYPE_HIGH_BOUND (type) + 1;
d7975 1
a7977 1

d7983 32
a8014 33
static const struct op_print ada_op_print_tab[] =
  {
    {":=",  BINOP_ASSIGN, PREC_ASSIGN, 1},
    {"or else", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},
    {"and then", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},
    {"or",  BINOP_BITWISE_IOR, PREC_BITWISE_IOR, 0},
    {"xor",  BINOP_BITWISE_XOR, PREC_BITWISE_XOR, 0},
    {"and",  BINOP_BITWISE_AND, PREC_BITWISE_AND, 0},
    {"=", BINOP_EQUAL, PREC_EQUAL, 0},
    {"/=", BINOP_NOTEQUAL, PREC_EQUAL, 0},
    {"<=", BINOP_LEQ, PREC_ORDER, 0},
    {">=", BINOP_GEQ, PREC_ORDER, 0},
    {">",  BINOP_GTR, PREC_ORDER, 0},
    {"<",  BINOP_LESS, PREC_ORDER, 0},
    {">>", BINOP_RSH, PREC_SHIFT, 0},
    {"<<", BINOP_LSH, PREC_SHIFT, 0},
    {"+",  BINOP_ADD, PREC_ADD, 0},
    {"-",  BINOP_SUB, PREC_ADD, 0},
    {"&",  BINOP_CONCAT, PREC_ADD, 0},
    {"*",  BINOP_MUL, PREC_MUL, 0},
    {"/",  BINOP_DIV, PREC_MUL, 0},
    {"rem",  BINOP_REM, PREC_MUL, 0},
    {"mod",  BINOP_MOD, PREC_MUL, 0},
    {"**", BINOP_EXP, PREC_REPEAT, 0 },
    {"@@",  BINOP_REPEAT, PREC_REPEAT, 0},
    {"-",  UNOP_NEG, PREC_PREFIX, 0},
    {"+",  UNOP_PLUS, PREC_PREFIX, 0},
    {"not ",  UNOP_LOGICAL_NOT, PREC_PREFIX, 0},
    {"not ",  UNOP_COMPLEMENT, PREC_PREFIX, 0},
    {"abs ",  UNOP_ABS, PREC_PREFIX, 0},
    {".all",  UNOP_IND, PREC_SUFFIX, 1},  /* FIXME: postfix .ALL */
    {"'access",  UNOP_ADDR, PREC_SUFFIX, 1}, /* FIXME: postfix 'ACCESS */
    {NULL, 0, 0, 0}
d8019 11
a8029 11
struct type* builtin_type_ada_int;
struct type* builtin_type_ada_short;
struct type* builtin_type_ada_long;
struct type* builtin_type_ada_long_long;
struct type* builtin_type_ada_char;
struct type* builtin_type_ada_float;
struct type* builtin_type_ada_double;
struct type* builtin_type_ada_long_double;
struct type* builtin_type_ada_natural;
struct type* builtin_type_ada_positive;
struct type* builtin_type_ada_system_address;
d8031 1
a8031 1
struct type ** const (ada_builtin_types[]) = 
d8033 1
a8033 1
  
d8035 25
a8059 30
  &builtin_type_ada_long,
  &builtin_type_ada_short,
  &builtin_type_ada_char,
  &builtin_type_ada_float,
  &builtin_type_ada_double,
  &builtin_type_ada_long_long,
  &builtin_type_ada_long_double,
  &builtin_type_ada_natural,
  &builtin_type_ada_positive,

  /* The following types are carried over from C for convenience. */
  &builtin_type_int,
  &builtin_type_long,
  &builtin_type_short,
  &builtin_type_char,
  &builtin_type_float,
  &builtin_type_double,
  &builtin_type_long_long,
  &builtin_type_void,
  &builtin_type_signed_char,
  &builtin_type_unsigned_char,
  &builtin_type_unsigned_short,
  &builtin_type_unsigned_int,
  &builtin_type_unsigned_long,
  &builtin_type_unsigned_long_long,
  &builtin_type_long_double,
  &builtin_type_complex,
  &builtin_type_double_complex,
  0
};
d8062 2
a8063 1
static void emit_char (int c, struct ui_file* stream, int quoter) 
d8088 1
a8088 1
  {"",     "",    "",  ""},	/* Binary format info */
d8090 3
a8092 3
  {"8#%lo#",  "8#",   "o", "#"},	/* Octal format info */
  {"%ld",   "",    "d", ""},	/* Decimal format info */
  {"16#%lx#", "16#",  "x", "#"},	/* Hex format info */
d8095 3
a8097 3
  {"0%lo",  "0",   "o", ""},	/* Octal format info */
  {"%ld",   "",    "d", ""},	/* Decimal format info */
  {"0x%lx", "0x",  "x", ""},	/* Hex format info */
d8111 1
a8111 2
	       0,
	       "integer", (struct objfile *) NULL);
d8114 1
a8114 2
	       0,
	       "long_integer", (struct objfile *) NULL);
d8117 1
a8117 2
	       0,
	       "short_integer", (struct objfile *) NULL);
d8120 1
a8120 2
	       0,
	       "character", (struct objfile *) NULL);
d8123 1
a8123 2
	       0,
	       "float", (struct objfile *) NULL);
d8126 1
a8126 2
	       0,
	       "long_float", (struct objfile *) NULL);
d8129 1
a8129 2
	       0,
	       "long_long_integer", (struct objfile *) NULL);
d8132 1
a8132 2
	       0,
	       "long_long_float", (struct objfile *) NULL);
d8135 1
a8135 2
	       0,
	       "natural", (struct objfile *) NULL);
d8138 1
a8138 2
	       0,
	       "positive", (struct objfile *) NULL);
d8141 2
a8142 2
  builtin_type_ada_system_address = 
    lookup_pointer_type (init_type (TYPE_CODE_VOID, 1, 0, "void", 
d8148 1
a8148 1
  add_show_from_set 
d8150 1
a8150 1
		  (char*) &varsize_limit,
d8152 1
a8152 2
		  &setlist),
     &showlist);
d8192 104
a8295 106
      default:
	/* FIXME:  For now, if we are asked to produce a type not in this
	   language, create the equivalent of a C integer type with the
	   name "<?type?>".  When all the dust settles from the type
	   reconstruction work, this should probably become an error. */
	type = init_type (TYPE_CODE_INT,
			  TARGET_INT_BIT / TARGET_CHAR_BIT,
			  0, "<?type?>", objfile);
        warning ("internal error: no Ada fundamental type %d", typeid);
	break;
      case FT_VOID:
	type = init_type (TYPE_CODE_VOID,
			  TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			  0, "void", objfile);
	break;
      case FT_CHAR:
	type = init_type (TYPE_CODE_INT,
			  TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			  0, "character", objfile);
	break;
      case FT_SIGNED_CHAR:
	type = init_type (TYPE_CODE_INT,
			  TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			  0, "signed char", objfile);
	break;
      case FT_UNSIGNED_CHAR:
	type = init_type (TYPE_CODE_INT,
			  TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			  TYPE_FLAG_UNSIGNED, "unsigned char", objfile);
	break;
      case FT_SHORT:
	type = init_type (TYPE_CODE_INT,
			  TARGET_SHORT_BIT / TARGET_CHAR_BIT,
			  0, "short_integer", objfile);
	break;
      case FT_SIGNED_SHORT:
	type = init_type (TYPE_CODE_INT,
			  TARGET_SHORT_BIT / TARGET_CHAR_BIT,
			  0, "short_integer", objfile);	
	break;
      case FT_UNSIGNED_SHORT:
	type = init_type (TYPE_CODE_INT,
			  TARGET_SHORT_BIT / TARGET_CHAR_BIT,
			  TYPE_FLAG_UNSIGNED, "unsigned short", objfile);
	break;
      case FT_INTEGER:
	type = init_type (TYPE_CODE_INT,
			  TARGET_INT_BIT / TARGET_CHAR_BIT,
			  0, "integer", objfile);
	break;
      case FT_SIGNED_INTEGER:
	type = init_type (TYPE_CODE_INT,
			  TARGET_INT_BIT / TARGET_CHAR_BIT,
			  0, "integer", objfile); /* FIXME -fnf */
	break;
      case FT_UNSIGNED_INTEGER:
	type = init_type (TYPE_CODE_INT,
			  TARGET_INT_BIT / TARGET_CHAR_BIT,
			  TYPE_FLAG_UNSIGNED, "unsigned int", objfile);
	break;
      case FT_LONG:
	type = init_type (TYPE_CODE_INT,
			  TARGET_LONG_BIT / TARGET_CHAR_BIT,
			  0, "long_integer", objfile);
	break;
      case FT_SIGNED_LONG:
	type = init_type (TYPE_CODE_INT,
			  TARGET_LONG_BIT / TARGET_CHAR_BIT,
			  0, "long_integer", objfile);
	break;
      case FT_UNSIGNED_LONG:
	type = init_type (TYPE_CODE_INT,
			  TARGET_LONG_BIT / TARGET_CHAR_BIT,
			  TYPE_FLAG_UNSIGNED, "unsigned long", objfile);
	break;
      case FT_LONG_LONG:
	type = init_type (TYPE_CODE_INT,
			  TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
			  0, "long_long_integer", objfile);
	break;
      case FT_SIGNED_LONG_LONG:
	type = init_type (TYPE_CODE_INT,
			  TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
			  0, "long_long_integer", objfile);
	break;
      case FT_UNSIGNED_LONG_LONG:
	type = init_type (TYPE_CODE_INT,
			  TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
			  TYPE_FLAG_UNSIGNED, "unsigned long long", objfile);
	break;
      case FT_FLOAT:
	type = init_type (TYPE_CODE_FLT,
			  TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
			  0, "float", objfile);
	break;
      case FT_DBL_PREC_FLOAT:
	type = init_type (TYPE_CODE_FLT,
			  TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
			  0, "long_float", objfile);
	break;
      case FT_EXT_PREC_FLOAT:
	type = init_type (TYPE_CODE_FLT,
			  TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
			  0, "long_long_float", objfile);
	break;
      }
d8299 2
a8300 1
void ada_dump_symtab (struct symtab* s)
d8304 2
a8305 3
  fprintf (stderr, "  Name: %s/%s;\n", 
	   s->dirname ? s->dirname : "?", 
	   s->filename ? s->filename : "?");
d8312 1
a8312 1
	  struct linetable_entry* e = s->linetable->item + i;
a8317 1

@


1.5
log
@        * ada-lang.c: Change k&r style function definitions to prototyped
        form.
        * ada-typeprint.c: Change k&r style function definitions to prototyped
        form.
        * ada-valprint.c: Change k&r style function definitions to prototyped
        form.
@
text
@d98 2
a99 3
static struct partial_symbol* 
ada_lookup_partial_symbol (struct partial_symtab*, const char*, 
			   int, namespace_enum, int);
d130 1
a130 2
static struct type*
to_fixed_variant_branch_type (struct type*, char*, CORE_ADDR, struct value*);
d160 1
a160 2
static int
find_line_in_linetable (struct linetable*, int, struct symbol**, int, int*);
d1695 1
a1695 1
ada_array_element_type (struct btype* type, int nindices)
d3271 1
a3271 1
ada_lookup_partial_symbol (struct partial_symtab *pst, const char *name, int global, namespace_enumnamespace, int wild)
@


1.4
log
@	* ada-tasks.c (add_task_entry): replace calls to
	malloc() with xmalloc
	* ada-tasks.c (init_task_list): replace calls to free with xfree()

	* ada-lang.c (replace_operator_with_call, fill_in_ada_prototype,
	ada_finish_decode_line_1, all_sals_for_line
	ada_breakpoint_rewrite): replace calls to free() with xfree()
@
text
@d224 1
a224 5
grow_vect (old_vect, size, min_size, element_size)
     void** old_vect;
     size_t* size;
     size_t min_size;
     int element_size;
d238 1
a238 3
field_name_match (field_name, target)
     const char *field_name;
     const char *target;
d252 1
a252 2
ada_name_prefix_len (name)
     const char* name;
d282 1
a282 4
value_from_contents_and_address (type, valaddr, address)
     struct type* type;
     char* valaddr;
     CORE_ADDR address;
d299 1
a299 4
coerce_unspec_val_to_type (val, offset, type)
     struct value* val;
     long offset;
     struct type *type;
d324 1
a324 3
cond_offset_host (valaddr, offset)
     char* valaddr;
     long offset;
d333 1
a333 3
cond_offset_target (address, offset)
     CORE_ADDR address;
     long offset;
d377 1
a377 3
ada_update_initial_language (lang, main_pst)
     enum language lang;
     struct partial_symtab* main_pst;
d422 1
a422 2
is_suppressed_name (str) 
     const char* str;
d458 1
a458 2
ada_mangle (demangled)
     const char* demangled;
d545 1
a545 2
ada_demangle (mangled)
     const char* mangled;
d666 1
a666 4
ada_match_name (sym_name, name, wild)
     const char* sym_name;
     const char* name;
     int wild;
d686 1
a686 2
ada_suppress_symbol_printing (sym)
     struct symbol *sym;
d712 1
a712 4
modify_general_field (addr, fieldval, bitpos, bitsize)
     char *addr;
     LONGEST fieldval;
     int bitpos, bitsize;
d726 1
a726 2
desc_base_type (type)
     struct type* type;
d791 1
a791 2
desc_bounds_type (type)
     struct type* type;
d820 1
a820 2
desc_bounds (arr)
     struct value* arr;
d854 1
a854 2
fat_pntr_bounds_bitpos (type)
     struct type* type;
d862 1
a862 2
fat_pntr_bounds_bitsize (type)
     struct type* type;
d877 1
a877 2
desc_data_type (type)
     struct type* type;
d894 1
a894 2
desc_data (arr)
     struct value* arr;
d910 1
a910 2
fat_pntr_data_bitpos (type)
     struct type* type;
d918 1
a918 2
fat_pntr_data_bitsize (type)
     struct type* type;
d932 1
a932 4
desc_one_bound (bounds, i, which)
     struct value* bounds;
     int i;
     int which;
d942 1
a942 4
desc_bound_bitpos (type, i, which)
     struct type* type;
     int i;
     int which;
d951 1
a951 4
desc_bound_bitsize (type, i, which)
     struct type* type;
     int i;
     int which;
d964 1
a964 3
desc_index_type (type, i)
     struct type* type;
     int i;
d977 1
a977 2
desc_arity (type)
     struct type* type;
d989 1
a989 2
ada_is_simple_array (type)
     struct type* type;
d1001 1
a1001 2
ada_is_array_descriptor (type)
     struct type* type;
d1023 1
a1023 2
ada_is_bogus_array_descriptor (type)
     struct type *type;
d1042 1
a1042 3
ada_type_of_array (arr, bounds)
     struct value* arr;
     int bounds;
d1090 1
a1090 2
ada_coerce_to_simple_array_ptr (arr)
     struct value* arr;
d1109 1
a1109 2
ada_coerce_to_simple_array (arr)
     struct value* arr;
d1128 1
a1128 2
ada_coerce_to_simple_array_type (type)
     struct type* type;
d1141 1
a1141 2
ada_is_packed_array_type (type)
     struct type* type;
d1160 1
a1160 3
packed_array_type (type, elt_bits)
     struct type* type;
     long* elt_bits;
d1197 1
a1197 2
decode_packed_array_type (type)
     struct type* type;
d1248 1
a1248 2
decode_packed_array (arr)
     struct value* arr;
d1266 1
a1266 4
value_subscript_packed (arr, arity, ind)
     struct value* arr;
     int arity;
     struct value** ind;
d1318 1
a1318 2
has_negatives (type)
     struct type* type;
d1341 2
a1342 8
ada_value_primitive_packed_val (obj, valaddr, offset, bit_offset, 
				bit_size, type)
     struct value* obj;
     char* valaddr;
     long offset;
     int bit_offset;
     int bit_size;
     struct type* type;
d1612 1
a1612 4
ada_value_subscript (arr, arity, ind)
     struct value* arr;
     int arity;
     struct value** ind;
d1639 1
a1639 5
ada_value_ptr_subscript (arr, type, arity, ind)
     struct value* arr;
     struct type* type;
     int arity;
     struct value** ind;
d1670 1
a1670 2
ada_array_arity (type)
     struct type* type;
d1698 1
a1698 3
ada_array_element_type (type, nindices)
     struct type* type;
     int nindices;
d1741 1
a1741 3
ada_index_type (type, n)
     struct type* type;
     int n;
d1769 1
a1769 5
ada_array_bound_from_type (arr_type, n, which, typep)
     struct type* arr_type;
     int n; 
     int which;
     struct type** typep;
d1858 1
a1858 3
ada_array_length (arr, n)
     struct value* arr;
     int n; 
d1891 1
a1891 2
ada_op_name (op)
     enum exp_opcode op;
d1915 1
a1915 3
ada_resolve (expp, context_type)
     struct expression** expp;
     struct type* context_type;
d1931 1
a1931 5
ada_resolve_subexp (expp, pos, deprocedure_p, context_type) 
     struct expression** expp;
     int *pos;
     int deprocedure_p;
     struct type* context_type;
d2376 1
a2376 4
ada_args_match (func, actuals, n_actuals)
     struct symbol* func;
     struct value** actuals;
     int n_actuals;
d2408 1
a2408 3
return_match (func_type, context_type)
     struct type* func_type;
     struct type* context_type;
d2447 3
a2449 7
ada_resolve_function (syms, blocks, nsyms, args, nargs, name, context_type)
     struct symbol* syms[];
     struct block* blocks[];
     struct value** args;
     int nsyms, nargs;
     const char* name;
     struct type* context_type;
d2535 1
a2535 4
sort_choices (syms, blocks, nsyms)
     struct symbol* syms[];
     struct block* blocks[];
     int nsyms;
d2568 2
a2569 5
user_select_syms (syms, blocks, nsyms, max_results)
     struct symbol* syms[];
     struct block* blocks[];
     int nsyms;
     int max_results;
d2671 2
a2672 7
get_selections (choices, n_choices, max_results, is_all_choice, 
		annotation_suffix)
     int* choices;
     int n_choices;
     int max_results;
     int is_all_choice;
     char* annotation_suffix;
d2749 3
a2751 5
replace_operator_with_call (expp, pc, nargs, oplen, sym, block)
     struct expression** expp;
     int pc, nargs, oplen;
     struct symbol* sym;
     struct block* block; 
d2783 1
a2783 2
numeric_type_p (type)
     struct type* type;
d2805 1
a2805 2
integer_type_p (type)
     struct type* type;
d2826 1
a2826 2
scalar_type_p (type)
     struct type* type;
d2847 1
a2847 2
discrete_type_p (type)
     struct type* type;
d2869 1
a2869 3
possible_user_operator_p (op, args)
     enum exp_opcode op;
     struct value* args[];
d2934 1
a2934 2
ada_renaming_type (type)
     struct type* type;
d2952 1
a2952 2
ada_is_object_renaming (sym)
     struct symbol* sym;
d2963 1
a2963 2
ada_simple_renamed_entity (sym)
     struct symbol* sym;
d2994 1
a2994 3
place_on_stack (val, sp)
    struct value* val;
     CORE_ADDR* sp;
d3021 1
a3021 4
convert_actual (actual, formal_type0, sp)
     struct value* actual;
     struct type* formal_type0;
     CORE_ADDR* sp;
d3069 1
a3069 4
make_array_descriptor (type, arr, sp)
     struct type* type;
     struct value* arr;
     CORE_ADDR* sp;
d3119 1
a3119 5
ada_convert_actuals (func, nargs, args, sp)
     struct value* func;
     int nargs;
     struct value* args[];
     CORE_ADDR* sp;
d3154 1
a3154 3
standard_lookup (name, namespace)
     const char* name;
     namespace_enum namespace;
d3167 1
a3167 3
is_nonfunction (syms, n)
     struct symbol* syms[];
     int n;
d3183 1
a3183 3
equiv_types (type0, type1)
     struct type* type0;
     struct type* type1;
d3203 1
a3203 3
lesseq_defined_than (sym0, sym1)
     struct symbol* sym0;
     struct symbol* sym1;
d3241 1
a3241 3
add_defn_to_vec (sym, block)
     struct symbol* sym;
     struct block* block;
d3274 1
a3274 6
ada_lookup_partial_symbol (pst, name, global, namespace, wild)
     struct partial_symtab *pst;
     const char *name;
     int global;
     namespace_enum namespace;
     int wild;
d3401 1
a3401 2
symtab_for_sym (sym)
     struct symbol* sym;
d3464 1
a3464 2
ada_lookup_minimal_symbol (name)
     const char* name;
d3490 1
a3490 4
add_symbols_from_enclosing_procs (name, namespace, wild_match)
     const char* name;
     namespace_enum namespace;
     int wild_match;
d3550 1
a3550 2
is_nondebugging_type (type)
     struct type* type;
d3565 1
a3565 4
remove_extra_symbols (syms, blocks, nsyms)
     struct symbol** syms;
     struct block** blocks;
     int nsyms;
d3614 3
a3616 6
ada_lookup_symbol_list (name, block0, namespace, syms, blocks)
     const char *name;
     struct block *block0;
     namespace_enum namespace;
     struct symbol*** syms;
     struct block*** blocks;
d3783 1
a3783 4
ada_lookup_symbol (name, block0, namespace)
     const char *name;
     struct block *block0;
     namespace_enum namespace;
d3810 1
a3810 2
is_name_suffix (str)
     const char* str;
d3862 1
a3862 4
wild_match (patn, patn_len, name)
     const char* patn;
     int patn_len;
     const char* name;
d3909 3
a3911 6
ada_add_block_symbols (block, name, namespace, objfile, wild)
     struct block* block;
     const char* name;
     namespace_enum namespace;
     struct objfile* objfile;
     int wild;
d4115 1
a4115 2
fill_in_ada_prototype (func)
     struct symbol* func;
d4212 1
a4212 2
ada_start_decode_line_1 (line)
     char* line;
d4266 2
a4267 5
ada_finish_decode_line_1 (spec, file_table, funfirstline, canonical)
     char** spec;
     struct symtab* file_table;
     int funfirstline;
     char*** canonical;
d4448 2
a4449 5
find_sal_from_funcs_and_line (filename, line_num, symbols, nsyms)
     const char* filename;
     int line_num;
     struct symbol** symbols;
     int nsyms;
d4513 2
a4514 6
find_line_in_linetable (linetable, line_num, symbols, nsyms, exactp)
     struct linetable* linetable;
     int line_num;
     struct symbol** symbols;
     int nsyms;
     int* exactp;
d4559 1
a4559 3
nearest_line_number_in_linetable (linetable, line_num)
     struct linetable* linetable;
     int line_num;
d4618 2
a4619 5
find_next_line_in_linetable (linetable, line_num, starting_line, ind)
     struct linetable* linetable;
     int line_num;
     int starting_line;
     int ind;
d4682 1
a4682 3
is_plausible_func_for_line (sym, line_num)
     struct symbol* sym;
     int line_num;
d4695 1
a4695 2
debug_print_lines (lt)
     struct linetable* lt;
d4709 1
a4709 2
debug_print_block (b)
     struct block* b;
d4731 1
a4731 2
debug_print_blocks (bv)
     struct blockvector* bv;
d4744 1
a4744 2
debug_print_symtab (s)
     struct symtab* s;
d4758 1
a4758 2
read_all_symtabs (filename)
     const char* filename;
d4776 1
a4776 4
all_sals_for_line (filename, line_num, canonical)
     const char* filename;
     int line_num;
     char*** canonical;
d4886 1
a4886 3
extended_canonical_line_spec (sal, name)
     struct symtab_and_line sal;
     const char* name;
d4912 1
a4912 3
begin_command (args, from_tty)
     char *args;
     int from_tty;
d4974 1
a4974 2
is_ada_runtime_file (filename)
     char *filename;
d4986 1
a4986 3
find_printable_frame (fi, level)
     struct frame_info *fi;
     int level;
d5022 1
a5022 2
ada_report_exception_break (b)
     struct breakpoint *b;
d5158 1
a5158 3
ada_is_ignored_field (type, field_num)
     struct type *type;
     int field_num;
d5173 1
a5173 2
ada_is_tagged_type (type)
     struct type *type;
d5184 1
a5184 2
ada_tag_type (val)
     struct value* val;
d5192 1
a5192 2
ada_value_tag (val)
     struct value* val;
d5200 1
a5200 2
ada_parent_type (type)
     struct type *type;
d5221 1
a5221 3
ada_is_parent_field (type, field_num)
     struct type *type;
     int field_num;
d5235 1
a5235 3
ada_is_wrapper_field (type, field_num)
     struct type *type;
     int field_num;
d5249 1
a5249 3
ada_is_variant_part (type, field_num)
     struct type *type;
     int field_num;
d5262 1
a5262 3
ada_variant_discrim_type (var_type, outer_type)
     struct type *var_type;
     struct type *outer_type;
d5278 1
a5278 3
ada_is_others_clause (type, field_num)
     struct type *type;
     int field_num;
d5289 1
a5289 2
ada_variant_discrim_name (type0)
     struct type *type0;
d5342 1
a5342 5
ada_scan_number (str, k, R, new_k)
     const char str[];
     int k;
     LONGEST *R;
     int *new_k;
d5384 1
a5384 4
ada_in_variant (val, type, field_num)
     LONGEST val;
     struct type *type;
     int field_num;
d5431 2
a5432 5
ada_value_primitive_field (arg1, offset, fieldno, arg_type)
     struct value* arg1;
     int offset;
     int fieldno;
     struct type *arg_type;
d5463 2
a5464 5
ada_search_struct_field (name, arg, offset, type)
     char *name;
     struct value* arg;
     int offset;
     struct type *type;
d5522 1
a5522 4
ada_value_struct_elt (arg, name, err)
     struct value* arg;
     char *name;
     char *err;
d5566 1
a5566 5
ada_lookup_struct_elt_type (type, name, noerr, dispp)
     struct type *type;
     char *name;
     int noerr;
     int *dispp;
d5664 2
a5665 4
ada_which_variant_applies (var_type, outer_type, outer_valaddr)
     struct type *var_type;
     struct type *outer_type;
     char* outer_valaddr;
d5735 1
a5735 2
ada_value_ind (val0)
     struct value* val0;
d5746 1
a5746 2
ada_coerce_ref (val0)
     struct value* val0;
d5763 1
a5763 3
align_value (off, alignment)
     unsigned int off;
     unsigned int alignment;
d5772 1
a5772 3
field_offset (type, f)
     struct type *type;
     int f;
d5786 1
a5786 3
field_alignment (type, f)
     struct type *type;
     int f;
d5808 1
a5808 2
ada_find_any_type (name)
     const char *name;
d5828 1
a5828 3
ada_prefer_type (type0, type1)
     struct type* type0;
     struct type* type1;
d5851 1
a5851 2
ada_type_name (type)
     struct type* type;
d5865 1
a5865 3
ada_find_parallel_type (type, suffix)
     struct type *type;
     const char *suffix;
d5893 1
a5893 2
dynamic_template_type (type)
     struct type* type;
d5914 1
a5914 3
is_dynamic_field (templ_type, field_num)
     struct type* templ_type;
     int field_num;
d5926 1
a5926 2
contains_variant_part (type)
     struct type* type;
d5938 1
a5938 2
empty_record (objfile) 
     struct objfile* objfile;
d5964 2
a5965 6
template_to_fixed_record_type (type, valaddr, address, dval0)
     struct type* type;
     char* valaddr;
     CORE_ADDR address;
     struct value* dval0;

d6078 1
a6078 2
template_to_static_fixed_type (templ_type)
     struct type* templ_type;
d6128 2
a6129 5
to_record_with_fixed_variant_part (type, valaddr, address, dval)
     struct type* type;
     char* valaddr;
     CORE_ADDR address;
     struct value* dval;
d6187 2
a6188 5
to_fixed_record_type (type0, valaddr, address, dval)
     struct type* type0;
     char* valaddr;
     CORE_ADDR address;
     struct value* dval;
d6219 2
a6220 5
to_fixed_variant_branch_type (var_type0, valaddr, address, dval)
     struct type* var_type0;
     char* valaddr;
     CORE_ADDR address;
     struct value* dval;
d6265 2
a6266 4
to_fixed_array_type (type0, dval, ignore_too_big)
     struct type* type0;
     struct value* dval;
     int ignore_too_big;
d6330 2
a6331 5
ada_to_fixed_type (type, valaddr, address, dval)
     struct type* type;
     char* valaddr;
     CORE_ADDR address;
     struct value* dval;
d6353 1
a6353 2
to_static_fixed_type (type0)
     struct type* type0;
d6385 1
a6385 2
static_unwrap_type (type)
     struct type* type;
d6419 1
a6419 2
ada_completed_type (type)
     struct type* type;
d6441 2
a6442 5
ada_to_fixed_value (type0, valaddr, address, val0)
     struct type* type0;
     char* valaddr;
     CORE_ADDR address;
     struct value* val0;
d6456 1
a6456 2
ada_to_static_fixed_value (val)
     struct value* val;
d6493 1
a6493 2
ada_attribute_name (n)
     int n;
d6504 1
a6504 2
value_pos_atr (arg)
     struct value* arg;
d6530 1
a6530 3
value_val_atr (type, arg)
     struct type *type;
     struct value* arg;
d6557 1
a6557 2
ada_is_character_type (type)
     struct type* type;
d6572 1
a6572 2
ada_is_string_type (type)
     struct type *type;
d6594 1
a6594 2
ada_is_aligner_type (type)
     struct type *type;
d6606 1
a6606 2
ada_get_base_type (raw_type)
     struct type* raw_type;
d6631 1
a6631 2
ada_aligned_type (type)
     struct type* type;
d6644 1
a6644 3
ada_aligned_value_addr (type, valaddr)
     struct type *type;
     char *valaddr;
d6657 1
a6657 2
ada_enum_name (name)
     const char* name;
d6697 2
a6698 5
evaluate_subexp (expect_type, exp, pos, noside)
     struct type *expect_type;
     struct expression *exp;
     int *pos;
     enum noside noside;
d6708 1
a6708 3
evaluate_subexp_type (exp, pos)
     struct expression* exp;
     int* pos;
d6718 1
a6718 2
unwrap_value (val)
     struct value* val;
d6748 1
a6748 3
cast_to_fixed (type, arg)
     struct type *type;
     struct value* arg;
d6769 1
a6769 2
cast_from_fixed_to_double (arg)
     struct value* arg;
d6779 1
a6779 3
coerce_for_assign (type, val)
     struct type* type;
     struct value* val;
d6807 2
a6808 5
ada_evaluate_subexp (expect_type, exp, pos, noside)
     struct type *expect_type;
     struct expression *exp;
     int *pos;
     enum noside noside;
d7578 1
a7578 2
fixed_type_info (type)
     struct type *type;
d7601 1
a7601 2
ada_is_fixed_point_type (type)
     struct type *type;
d7611 1
a7611 2
ada_delta (type)
     struct type *type;
d7626 1
a7626 2
scaling_factor (type)
     struct type *type;
d7647 1
a7647 3
ada_fixed_to_float (type, x)
     struct type *type;
     LONGEST x;
d7656 1
a7656 3
ada_float_to_fixed (type, x)
     struct type *type;
     DOUBLEST x;
d7667 1
a7667 2
ada_is_vax_floating_type (type)
     struct type* type;
d7681 1
a7681 2
ada_vax_float_type_suffix (type)
     struct type* type;
d7690 1
a7690 3
ada_vax_float_print_function (type)

     struct type* type;
d7717 1
a7717 6
scan_discrim_bound (str, k, dval, px, pnew_k)
     char *str;
     int k;
     struct value* dval;
     LONGEST *px;
     int *pnew_k;
d7758 1
a7758 3
get_var_value (name, err_msg)
     char* name;
     char* err_msg;
d7782 1
a7782 4
get_int_var_value (name, err_msg, flag)
     char* name;
     char* err_msg;
     int* flag;
d7810 1
a7810 4
to_fixed_range_type (name, dval, objfile)
     char *name;
     struct value *dval;
     struct objfile *objfile;
d7884 1
a7884 2
ada_is_range_type_name (name)
     const char* name;
d7894 1
a7894 2
ada_is_modular_type (type)
     struct type* type;
d7907 1
a7907 2
ada_modulus (type)
     struct type* type;
d8138 1
a8138 3
ada_create_fundamental_type (objfile, typeid)
     struct objfile *objfile;
     int typeid;
@


1.3
log
@2002-07-11  Daniel Jacobowitz  <drow@@mvista.com>

	Based on patch from Daniel Berlin <dberlin@@dberlin.org>.
	* buildsym.c: Include "demangle.h" for SYMBOL_INIT_DEMANGLED_NAME.
	(finish_block) For non-function blocks, hash the symbol table.  For
	function blocks, mark the symbol table as unhashed.
	* minsyms.c (msymbol_hash): Return hash value without taking modulus.
	(msymbol_hash_iw): Likewise.
	(add_minsym_to_hash_table): Take modulus of msymbol_hash's return
	value.
	(add_minsym_to_demangled_hash_table): Likewise for msymbol_hash_iw.
	(lookup_minimal_symbol): Likewise for both.
	* symtab.h (struct block): Add `hashtable' flag.  Comment the
	hashtable.
	(BLOCK_HASHTABLE, BLOCK_BUCKETS, BLOCK_BUCKET): New macro.
	(ALL_BLOCK_SYMBOLS): Update.
	(BLOCK_SHOULD_SORT): Do not sort hashed blocks.
	(struct symbol): Add `hash_next' pointer.
	* symtab.c (lookup_block_symbol): Search using the hash table when
	possible.
	(find_pc_sect_symtab): Use ALL_BLOCK_SYMBOLS.
	(search_symbols, find_addr_symbol): Likewise.

	* dstread.c (process_dst_block): Clear hashtable bit for new block.
	(read_dst_symtab): Likewise.
	* jv-lang.c (get_java_class_symtab): Likewise.
	* mdebugread.c: Include "gdb_assert.h".
	(shrink_block): Assert that the block being modified is not hashed.
	* coffread.c (patch_opaque_types): Use ALL_BLOCK_SYMBOLS.
	* symmisc.c (free_symtab_block): Walk the hash table when freeing
	symbols.
	(dump_symtab): Recognize hashed blocks.
	* printcmd.c (print_frame_args):  Assert that function blocks do not
	have hashed symbol tables.
	* ada-lang.c (symtab_for_sym): Use ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Likewise.
	(ada_add_block_symbols): Use ALL_BLOCK_SYMBOLS.  Handle hash tables.
@
text
@d2894 1
a2894 1
  free (exp);
d4366 1
a4366 1
      free (TYPE_FIELDS (ftype));
d4376 1
a4376 1
      free (TYPE_FIELDS (ftype));
d4589 1
a4589 1
  make_cleanup (free, selected.sals);
d5068 1
a5068 1
	  make_cleanup (free, *canonical);
d5075 1
a5075 1
	      make_cleanup (free, (*canonical)[k]);
d5331 1
a5331 1
      make_cleanup (free, arg);
d5357 1
a5357 1
      make_cleanup (free, arg);
@


1.2
log
@2002-06-19  Daniel Jacobowitz  <drow@@mvista.com>

        * ada-lang.c (fill_in_ada_prototype): Update comment.
@
text
@d3563 1
d3578 2
a3579 2
	  for (i = 0; i < BLOCK_NSYMS (b); i += 1)
	    if (sym == BLOCK_SYM (b, i))
d3582 2
a3583 2
	  for (i = 0; i < BLOCK_NSYMS (b); i += 1)
	    if (sym == BLOCK_SYM (b, i))
d3605 2
a3606 2
	      for (i = 0; i < BLOCK_NSYMS (b); i += 1)
		if (sym == BLOCK_SYM (b, i))
d4098 1
d4103 2
a4104 1
      for (i = 0; i < BLOCK_NSYMS (block); i += 1)
a4105 2
	  struct symbol *sym = BLOCK_SYM (block, i);

d4153 40
a4192 38
      for (; i < BLOCK_NSYMS (block); i += 1)
	{
	  struct symbol *sym = BLOCK_SYM (block, i);

	  if (SYMBOL_NAMESPACE (sym) == namespace)
	    {
	      int cmp = strncmp (name, SYMBOL_NAME (sym), name_len);
	
	      if (cmp < 0) 
		{
		  if (is_sorted)
		    break;
		}
	      else if (cmp == 0 
		       && is_name_suffix (SYMBOL_NAME (sym) + name_len)) 
		{
		  switch (SYMBOL_CLASS (sym))
		    {
		    case LOC_ARG:
		    case LOC_LOCAL_ARG:
		    case LOC_REF_ARG:
		    case LOC_REGPARM:
		    case LOC_REGPARM_ADDR:
		    case LOC_BASEREG_ARG:
		      arg_sym = sym;
		      break;
		    case LOC_UNRESOLVED:
		      break;
		    default:
		      found_sym = 1;
		      fill_in_ada_prototype (sym);
		      add_defn_to_vec (fixup_symbol_section (sym, objfile),
				       block);
		      break;
		    }
		}
	    }
	}
d4225 51
a4275 47
      for (; i < BLOCK_NSYMS (block); i += 1)
	{
	  struct symbol *sym = BLOCK_SYM (block, i);

	  if (SYMBOL_NAMESPACE (sym) == namespace)
	    {
	      int cmp;

	      cmp = (int) '_' - (int) SYMBOL_NAME (sym)[0];
	      if (cmp == 0) 
		{
		  cmp = strncmp ("_ada_", SYMBOL_NAME (sym), 5);
		  if (cmp == 0)
		    cmp = strncmp (name, SYMBOL_NAME (sym) + 5, name_len);
		}
	
	      if (cmp < 0) 
		{
		  if (is_sorted)
		    break;
		}
	      else if (cmp == 0 
		       && is_name_suffix (SYMBOL_NAME (sym) + name_len + 5)) 
		{
		  switch (SYMBOL_CLASS (sym))
		    {
		    case LOC_ARG:
		    case LOC_LOCAL_ARG:
		    case LOC_REF_ARG:
		    case LOC_REGPARM:
		    case LOC_REGPARM_ADDR:
		    case LOC_BASEREG_ARG:
		      arg_sym = sym;
		      break;
		    case LOC_UNRESOLVED:
		      break;
		    default:
		      found_sym = 1;
		      fill_in_ada_prototype (sym);
		      add_defn_to_vec (fixup_symbol_section (sym, objfile),
				       block);
		      break;
		    }
		}
	    }
	}
      
d4302 1
a4318 1
  nsyms = BLOCK_NSYMS (b);
d4324 1
a4324 1
  for (i = 0; i < nsyms; i += 1)
a4325 2
      struct symbol *sym = BLOCK_SYM (b, i);

d4911 2
d4920 1
a4920 1
  for (i = 0; i < BLOCK_NSYMS (b); i += 1)
d4924 1
a4924 1
      fprintf (stderr, " %s", SYMBOL_NAME (BLOCK_SYM (b, i)));
@


1.2.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@@


1.2.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2894 1
a2894 1
  xfree (exp);
a3562 1
  struct symbol *tmp_sym;
d3577 2
a3578 2
	  ALL_BLOCK_SYMBOLS (b, i, tmp_sym)
	    if (sym == tmp_sym)
d3581 2
a3582 2
	  ALL_BLOCK_SYMBOLS (b, i, tmp_sym)
	    if (sym == tmp_sym)
d3604 2
a3605 2
	      ALL_BLOCK_SYMBOLS (b, i, tmp_sym)
		if (sym == tmp_sym)
a4096 1
  struct symbol *sym;
d4101 1
a4101 2
      struct symbol *sym;
      ALL_BLOCK_SYMBOLS (block, i, sym)
d4103 2
d4152 38
a4189 40
      for (; i < BLOCK_BUCKETS (block); i += 1)
	for (sym = BLOCK_BUCKET (block, i); sym != NULL; sym = sym->hash_next)
	  {
	    if (SYMBOL_NAMESPACE (sym) == namespace)
	      {
		int cmp = strncmp (name, SYMBOL_NAME (sym), name_len);

		if (cmp < 0) 
		  {
		    if (is_sorted)
		      {
			i = BLOCK_BUCKETS (block);
			break;
		      }
		  }
		else if (cmp == 0 
			 && is_name_suffix (SYMBOL_NAME (sym) + name_len)) 
		  {
		    switch (SYMBOL_CLASS (sym))
		      {
		      case LOC_ARG:
		      case LOC_LOCAL_ARG:
		      case LOC_REF_ARG:
		      case LOC_REGPARM:
		      case LOC_REGPARM_ADDR:
		      case LOC_BASEREG_ARG:
			arg_sym = sym;
			break;
		      case LOC_UNRESOLVED:
			break;
		      default:
			found_sym = 1;
			fill_in_ada_prototype (sym);
			add_defn_to_vec (fixup_symbol_section (sym, objfile),
					 block);
			break;
		      }
		  }
	      }
	  }
d4222 47
a4268 51
      for (; i < BLOCK_BUCKETS (block); i += 1)
	for (sym = BLOCK_BUCKET (block, i); sym != NULL; sym = sym->hash_next)
	  {
	    struct symbol *sym = BLOCK_SYM (block, i);

	    if (SYMBOL_NAMESPACE (sym) == namespace)
	      {
		int cmp;

		cmp = (int) '_' - (int) SYMBOL_NAME (sym)[0];
		if (cmp == 0) 
		  {
		    cmp = strncmp ("_ada_", SYMBOL_NAME (sym), 5);
		    if (cmp == 0)
		      cmp = strncmp (name, SYMBOL_NAME (sym) + 5, name_len);
		  }

		if (cmp < 0) 
		  {
		    if (is_sorted)
		      {
			i = BLOCK_BUCKETS (block);
			break;
		      }
		  }
		else if (cmp == 0 
			 && is_name_suffix (SYMBOL_NAME (sym) + name_len + 5)) 
		  {
		    switch (SYMBOL_CLASS (sym))
		      {
		      case LOC_ARG:
		      case LOC_LOCAL_ARG:
		      case LOC_REF_ARG:
		      case LOC_REGPARM:
		      case LOC_REGPARM_ADDR:
		      case LOC_BASEREG_ARG:
			arg_sym = sym;
			break;
		      case LOC_UNRESOLVED:
			break;
		      default:
			found_sym = 1;
			fill_in_ada_prototype (sym);
			add_defn_to_vec (fixup_symbol_section (sym, objfile),
					 block);
			break;
		      }
		  }
	      }
	  }
  
a4294 1
  struct symbol *sym;
d4311 1
d4317 1
a4317 1
  ALL_BLOCK_SYMBOLS (b, i, sym)
d4319 2
d4361 1
a4361 1
      xfree (TYPE_FIELDS (ftype));
d4371 1
a4371 1
      xfree (TYPE_FIELDS (ftype));
d4584 1
a4584 1
  make_cleanup (xfree, selected.sals);
a4905 2
  struct symbol *i;

d4913 1
a4913 1
  ALL_BLOCK_SYMBOLS (b, i, sym)
d4917 1
a4917 1
      fprintf (stderr, " %s", SYMBOL_NAME (sym));
d5061 1
a5061 1
	  make_cleanup (xfree, *canonical);
d5068 1
a5068 1
	      make_cleanup (xfree, (*canonical)[k]);
d5324 1
a5324 1
      make_cleanup (xfree, arg);
d5350 1
a5350 1
      make_cleanup (xfree, arg);
@


1.2.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d224 5
a228 1
grow_vect (void** old_vect, size_t* size, size_t min_size, int element_size)
d242 3
a244 1
field_name_match (const char *field_name, const char *target)
d258 2
a259 1
ada_name_prefix_len (const char* name)
d289 4
a292 1
value_from_contents_and_address (struct type* type, char* valaddr, CORE_ADDR address)
d309 4
a312 1
coerce_unspec_val_to_type (struct value* val, long offset, struct type *type)
d337 3
a339 1
cond_offset_host (char* valaddr, long offset)
d348 3
a350 1
cond_offset_target (CORE_ADDR address, long offset)
d394 3
a396 1
ada_update_initial_language (enum language lang, struct partial_symtab* main_pst)
d441 2
a442 1
is_suppressed_name (const char* str) 
d478 2
a479 1
ada_mangle (const char* demangled)
d566 2
a567 1
ada_demangle (const char* mangled)
d688 4
a691 1
ada_match_name (const char* sym_name, const char* name, int wild)
d711 2
a712 1
ada_suppress_symbol_printing (struct symbol *sym)
d738 4
a741 1
modify_general_field (char *addr, LONGEST fieldval, int bitpos, int bitsize)
d755 2
a756 1
desc_base_type (struct type* type)
d821 2
a822 1
desc_bounds_type (struct type* type)
d851 2
a852 1
desc_bounds (struct value* arr)
d886 2
a887 1
fat_pntr_bounds_bitpos (struct type* type)
d895 2
a896 1
fat_pntr_bounds_bitsize (struct type* type)
d911 2
a912 1
desc_data_type (struct type* type)
d929 2
a930 1
desc_data (struct value* arr)
d946 2
a947 1
fat_pntr_data_bitpos (struct type* type)
d955 2
a956 1
fat_pntr_data_bitsize (struct type* type)
d970 4
a973 1
desc_one_bound (struct value* bounds, int i, int which)
d983 4
a986 1
desc_bound_bitpos (struct type* type, int i, int which)
d995 4
a998 1
desc_bound_bitsize (struct type* type, int i, int which)
d1011 3
a1013 1
desc_index_type (struct type* type, int i)
d1026 2
a1027 1
desc_arity (struct type* type)
d1039 2
a1040 1
ada_is_simple_array (struct type* type)
d1052 2
a1053 1
ada_is_array_descriptor (struct type* type)
d1075 2
a1076 1
ada_is_bogus_array_descriptor (struct type *type)
d1095 3
a1097 1
ada_type_of_array (struct value* arr, int bounds)
d1145 2
a1146 1
ada_coerce_to_simple_array_ptr (struct value* arr)
d1165 2
a1166 1
ada_coerce_to_simple_array (struct value* arr)
d1185 2
a1186 1
ada_coerce_to_simple_array_type (struct type*type)
d1199 2
a1200 1
ada_is_packed_array_type (struct type* type)
d1219 3
a1221 1
packed_array_type (struct type* type, long* elt_bits)
d1258 2
a1259 1
decode_packed_array_type (struct type* type)
d1310 2
a1311 1
decode_packed_array (struct value* arr)
d1329 4
a1332 1
value_subscript_packed (struct value* arr, int arity, struct value** ind)
d1384 2
a1385 1
has_negatives (struct type* type)
d1408 8
a1415 2
ada_value_primitive_packed_val (struct value* obj, char* valaddr, long offset, int bit_offset, 
				int bit_size, struct type* type)
d1685 4
a1688 1
ada_value_subscript (struct value* arr, int arity, struct value** ind)
d1715 5
a1719 1
ada_value_ptr_subscript (struct value* arr, struct type* type, int arity, struct value** ind)
d1750 2
a1751 1
ada_array_arity (struct type* type)
d1779 3
a1781 1
ada_array_element_type (struct btype* type, int nindices)
d1824 3
a1826 1
ada_index_type (struct type* type, int n)
d1854 5
a1858 1
ada_array_bound_from_type (struct type* arr_type, int n, int which, struct type** typep)
d1947 3
a1949 1
ada_array_length (struct value* arr, int n)
d1982 2
a1983 1
ada_op_name (enum exp_opcode op)
d2007 3
a2009 1
ada_resolve (struct expression** expp, struct type* context_type)
d2025 5
a2029 1
ada_resolve_subexp (struct expression** expp, int *pos, int deprocedure_p, struct type* context_type) 
d2474 4
a2477 1
ada_args_match (struct symbol* func, struct value** actuals, int n_actuals)
d2509 3
a2511 1
return_match (struct type* func_type, struct type* context_type)
d2550 7
a2556 3
ada_resolve_function (struct symbol* syms[], struct block* blocks[], int nsyms,
		      struct value** args, int nargs, const char* name,
		      struct type* context_type)
d2642 4
a2645 1
sort_choices (struct symbol* syms[], struct block* blocks[], int nsyms)
d2678 5
a2682 2
user_select_syms (struct symbol* syms[], struct block* blocks[], int nsyms,
		  int max_results)
d2784 7
a2790 2
get_selections (int* choices, int n_choices, int max_results,
		int is_all_choice, char* annotation_suffix)
d2867 5
a2871 3
replace_operator_with_call (struct expression** expp, int pc, int nargs,
			    int oplen, struct symbol* sym,
			    struct block* block)
d2903 2
a2904 1
numeric_type_p (struct type* type)
d2926 2
a2927 1
integer_type_p (struct type* type)
d2948 2
a2949 1
scalar_type_p (struct type* type)
d2970 2
a2971 1
discrete_type_p (struct type* type)
d2993 3
a2995 1
possible_user_operator_p (enum exp_opcode op, struct value* args[])
d3060 2
a3061 1
ada_renaming_type (struct type* type)
d3079 2
a3080 1
ada_is_object_renaming (struct symbol* sym)
d3091 2
a3092 1
ada_simple_renamed_entity (struct symbol* sym)
d3123 3
a3125 1
place_on_stack (struct value* val, CORE_ADDR* sp)
d3152 4
a3155 1
convert_actual (struct value* actual, struct type* formal_type0, CORE_ADDR* sp)
d3203 4
a3206 1
make_array_descriptor (struct type* type, struct value* arr, CORE_ADDR* sp)
d3256 5
a3260 1
ada_convert_actuals (struct value* func, int nargs, struct value* args[], CORE_ADDR* sp)
d3295 3
a3297 1
standard_lookup (const char* name, namespace_enum namespace)
d3310 3
a3312 1
is_nonfunction (struct symbol* syms[], int n)
d3328 3
a3330 1
equiv_types (struct type* type0, struct type* type1)
d3350 3
a3352 1
lesseq_defined_than (struct symbol* sym0, struct symbol* sym1)
d3390 3
a3392 1
add_defn_to_vec (struct symbol* sym, struct block* block)
d3425 6
a3430 1
ada_lookup_partial_symbol (struct partial_symtab *pst, const char *name, int global, namespace_enumnamespace, int wild)
d3557 2
a3558 1
symtab_for_sym (struct symbol* sym)
d3621 2
a3622 1
ada_lookup_minimal_symbol (const char* name)
d3648 4
a3651 1
add_symbols_from_enclosing_procs (const char* name, namespace_enum namespace, int wild_match)
d3711 2
a3712 1
is_nondebugging_type (struct type* type)
d3727 4
a3730 1
remove_extra_symbols (struct symbol** syms, struct block** blocks, int nsyms)
d3779 6
a3784 3
ada_lookup_symbol_list (const char *name, struct block *block0,
			namespace_enum namespace, struct symbol*** syms,
			struct block*** blocks)
d3951 4
a3954 1
ada_lookup_symbol (const char *name, struct block *block0, namespace_enum namespace)
d3981 2
a3982 1
is_name_suffix (const char* str)
d4034 4
a4037 1
wild_match (const char* patn, int patn_len, const char* name)
d4084 6
a4089 3
ada_add_block_symbols (struct block* block, const char* name,
		       namespace_enum namespace, struct objfile* objfile,
		       int wild)
d4293 2
a4294 1
fill_in_ada_prototype (struct symbol* func)
d4391 2
a4392 1
ada_start_decode_line_1 (char* line)
d4446 5
a4450 2
ada_finish_decode_line_1 (char** spec, struct symtab* file_table, 
			  int funfirstline, char*** canonical)
d4631 5
a4635 2
find_sal_from_funcs_and_line (const char* filename, int line_num,
			      struct symbol** symbols, int nsyms)
d4699 6
a4704 2
find_line_in_linetable (struct linetable* linetable, int line_num,
			struct symbol** symbols, int nsyms, int* exactp)
d4749 3
a4751 1
nearest_line_number_in_linetable (struct linetable* linetable, int line_num)
d4810 5
a4814 2
find_next_line_in_linetable (struct linetable* linetable, int line_num,
			     int starting_line, int ind)
d4877 3
a4879 1
is_plausible_func_for_line (struct symbol* sym, int line_num)
d4892 2
a4893 1
debug_print_lines (struct linetable* lt)
d4907 2
a4908 1
debug_print_block (struct block* b)
d4930 2
a4931 1
debug_print_blocks (struct blockvector* bv)
d4944 2
a4945 1
debug_print_symtab (struct symtab* s)
d4959 2
a4960 1
read_all_symtabs (const char* filename)
d4978 4
a4981 1
all_sals_for_line (const char* filename, int line_num, char*** canonical)
d5091 3
a5093 1
extended_canonical_line_spec (struct symtab_and_line sal, const char* name)
d5119 3
a5121 1
begin_command (char *args, int from_tty)
d5183 2
a5184 1
is_ada_runtime_file (char *filename)
d5196 3
a5198 1
find_printable_frame (struct frame_info *fi, int level)
d5234 2
a5235 1
ada_report_exception_break (struct breakpoint *b)
d5371 3
a5373 1
ada_is_ignored_field (struct type *type, int field_num)
d5388 2
a5389 1
ada_is_tagged_type (struct type *type)
d5400 2
a5401 1
ada_tag_type (struct value* val)
d5409 2
a5410 1
ada_value_tag (struct value* val)
d5418 2
a5419 1
ada_parent_type (struct type *type)
d5440 3
a5442 1
ada_is_parent_field (struct type *type, int field_num)
d5456 3
a5458 1
ada_is_wrapper_field (struct type *type, int field_num)
d5472 3
a5474 1
ada_is_variant_part (struct type *type, int field_num)
d5487 3
a5489 1
ada_variant_discrim_type (struct type *var_type, struct type *outer_type)
d5505 3
a5507 1
ada_is_others_clause (struct type *type, int field_num)
d5518 2
a5519 1
ada_variant_discrim_name (struct type *type0)
d5572 5
a5576 1
ada_scan_number (const char str[], int k, LONGEST *R, int *new_k)
d5618 4
a5621 1
ada_in_variant (LONGEST val, struct type *type, int field_num)
d5668 5
a5672 2
ada_value_primitive_field (struct value* arg1, int offset, int fieldno,
			   struct type *arg_type)
d5703 5
a5707 2
ada_search_struct_field (char *name, struct value* arg, int offset,
			 struct type *type)
d5765 4
a5768 1
ada_value_struct_elt (struct value *arg, char *name, char *err)
d5812 5
a5816 1
ada_lookup_struct_elt_type (struct type *type, char *name, int noerr, int *dispp)
d5914 4
a5917 2
ada_which_variant_applies (struct type *var_type, struct type *outer_type,
			   char* outer_valaddr)
d5987 2
a5988 1
ada_value_ind (struct value* val0)
d5999 2
a6000 1
ada_coerce_ref (struct value* val0)
d6017 3
a6019 1
align_value (unsigned int off, unsigned int alignment)
d6028 3
a6030 1
field_offset (struct type *type, int f)
d6044 3
a6046 1
field_alignment (struct type *type, int f)
d6068 2
a6069 1
ada_find_any_type (const char *name)
d6089 3
a6091 1
ada_prefer_type (struct type* type0, struct type* type1)
d6114 2
a6115 1
ada_type_name (struct type* type)
d6129 3
a6131 1
ada_find_parallel_type (struct type *type, const char *suffix)
d6159 2
a6160 1
dynamic_template_type (struct type* type)
d6181 3
a6183 1
is_dynamic_field (struct type* templ_type, int field_num)
d6195 2
a6196 1
contains_variant_part (struct type* type)
d6208 2
a6209 1
empty_record (struct objfile* objfile) 
d6235 6
a6240 2
template_to_fixed_record_type (struct type* type, char* valaddr,
			       CORE_ADDR address, struct value* dval0)
d6353 2
a6354 1
template_to_static_fixed_type (struct type* templ_type)
d6404 5
a6408 2
to_record_with_fixed_variant_part (struct type* type, char* valaddr,
				   CORE_ADDR address, struct value* dval)
d6466 5
a6470 2
to_fixed_record_type (struct type* type0, char* valaddr, CORE_ADDR address,
		      struct value* dval)
d6501 5
a6505 2
to_fixed_variant_branch_type (struct type* var_type0, char* valaddr,
			      CORE_ADDR address, struct value* dval)
d6550 4
a6553 2
to_fixed_array_type (struct type* type0, struct value* dval,
		     int ignore_too_big)
d6617 5
a6621 2
ada_to_fixed_type (struct type* type, char* valaddr, CORE_ADDR address,
		   struct value* dval)
d6643 2
a6644 1
to_static_fixed_type (struct type* type0)
d6676 2
a6677 1
static_unwrap_type (struct type* type)
d6711 2
a6712 1
ada_completed_type (struct type* type)
d6734 5
a6738 2
ada_to_fixed_value (struct type* type0, char* valaddr, CORE_ADDR address,
		    struct value* val0)
d6752 2
a6753 1
ada_to_static_fixed_value (struct value* val)
d6790 2
a6791 1
ada_attribute_name (int n)
d6802 2
a6803 1
value_pos_atr (struct value* arg)
d6829 3
a6831 1
value_val_atr (struct type *type, struct value* arg)
d6858 2
a6859 1
ada_is_character_type (struct type* type)
d6874 2
a6875 1
ada_is_string_type (struct type *type)
d6897 2
a6898 1
ada_is_aligner_type (struct type *type)
d6910 2
a6911 1
ada_get_base_type (struct type* raw_type)
d6936 2
a6937 1
ada_aligned_type (struct type* type)
d6950 3
a6952 1
ada_aligned_value_addr (struct type *type, char *valaddr)
d6965 2
a6966 1
ada_enum_name (const char* name)
d7006 5
a7010 2
evaluate_subexp (struct type *expect_type, struct expression *exp, int *pos,
		 enum noside noside)
d7020 3
a7022 1
evaluate_subexp_type (struct expression* exp, int* pos)
d7032 2
a7033 1
unwrap_value (struct value* val)
d7063 3
a7065 1
cast_to_fixed (struct type *type, struct value* arg)
d7086 2
a7087 1
cast_from_fixed_to_double (struct value* arg)
d7097 3
a7099 1
coerce_for_assign (struct type* type, struct value* val)
d7127 5
a7131 2
ada_evaluate_subexp (struct type *expect_type, struct expression *exp,
		     int *pos, enum noside noside)
d7901 2
a7902 1
fixed_type_info (struct type *type)
d7925 2
a7926 1
ada_is_fixed_point_type (struct type *type)
d7936 2
a7937 1
ada_delta (struct type *type)
d7952 2
a7953 1
scaling_factor (struct type *type)
d7974 3
a7976 1
ada_fixed_to_float (struct type *type, LONGEST x)
d7985 3
a7987 1
ada_float_to_fixed (struct type *type, DOUBLEST x)
d7998 2
a7999 1
ada_is_vax_floating_type (struct type* type)
d8013 2
a8014 1
ada_vax_float_type_suffix (struct type* type)
d8023 3
a8025 1
ada_vax_float_print_function (struct type* type)
d8052 6
a8057 1
scan_discrim_bound (char *, int k, struct value* dval, LONGEST *px, int *pnew_k)
d8098 3
a8100 1
get_var_value (char* name, char* err_msg)
d8124 4
a8127 1
get_int_var_value (char* name, char* err_msg, int* flag)
d8155 4
a8158 1
to_fixed_range_type (char *name, struct value *dval, struct objfile *objfile)
d8232 2
a8233 1
ada_is_range_type_name (const char* name)
d8243 2
a8244 1
ada_is_modular_type (struct type* type)
d8257 2
a8258 1
ada_modulus (struct type* type)
d8489 3
a8491 1
ada_create_fundamental_type (struct objfile *objfile, int typeid)
@


1.2.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d21 1
a21 1
#include "gdb_string.h"
d43 1
a43 1
struct cleanup *unresolved_names;
d47 1
a47 1
static struct type *ada_create_fundamental_type (struct objfile *, int);
d51 1
a51 1
static struct type *desc_base_type (struct type *);
d53 1
a53 1
static struct type *desc_bounds_type (struct type *);
d55 1
a55 1
static struct value *desc_bounds (struct value *);
d57 1
a57 1
static int fat_pntr_bounds_bitpos (struct type *);
d59 1
a59 1
static int fat_pntr_bounds_bitsize (struct type *);
d61 1
a61 1
static struct type *desc_data_type (struct type *);
d63 1
a63 1
static struct value *desc_data (struct value *);
d65 1
a65 1
static int fat_pntr_data_bitpos (struct type *);
d67 1
a67 1
static int fat_pntr_data_bitsize (struct type *);
d69 1
a69 1
static struct value *desc_one_bound (struct value *, int, int);
d71 1
a71 1
static int desc_bound_bitpos (struct type *, int, int);
d73 1
a73 1
static int desc_bound_bitsize (struct type *, int, int);
d75 1
a75 1
static struct type *desc_index_type (struct type *, int);
d77 1
a77 1
static int desc_arity (struct type *);
d79 1
a79 1
static int ada_type_match (struct type *, struct type *, int);
d81 1
a81 1
static int ada_args_match (struct symbol *, struct value **, int);
d83 1
a83 1
static struct value *place_on_stack (struct value *, CORE_ADDR *);
d85 1
a85 2
static struct value *convert_actual (struct value *, struct type *,
				     CORE_ADDR *);
d87 1
a87 2
static struct value *make_array_descriptor (struct type *, struct value *,
					    CORE_ADDR *);
d89 2
a90 2
static void ada_add_block_symbols (struct block *, const char *,
				   namespace_enum, struct objfile *, int);
d92 1
a92 1
static void fill_in_ada_prototype (struct symbol *);
d94 1
a94 1
static int is_nonfunction (struct symbol **, int);
d96 1
a96 1
static void add_defn_to_vec (struct symbol *, struct block *);
d98 3
a100 3
static struct partial_symbol *ada_lookup_partial_symbol (struct partial_symtab
							 *, const char *, int,
							 namespace_enum, int);
d102 1
a102 1
static struct symtab *symtab_for_sym (struct symbol *);
d104 1
a104 2
static struct value *ada_resolve_subexp (struct expression **, int *, int,
					 struct type *);
d106 2
a107 2
static void replace_operator_with_call (struct expression **, int, int, int,
					struct symbol *, struct block *);
d109 1
a109 1
static int possible_user_operator_p (enum exp_opcode, struct value **);
d111 1
a111 1
static const char *ada_op_name (enum exp_opcode);
d113 1
a113 1
static int numeric_type_p (struct type *);
d115 1
a115 1
static int integer_type_p (struct type *);
d117 1
a117 1
static int scalar_type_p (struct type *);
d119 1
a119 1
static int discrete_type_p (struct type *);
d121 1
a121 2
static char *extended_canonical_line_spec (struct symtab_and_line,
					   const char *);
d123 1
a123 2
static struct value *evaluate_subexp (struct type *, struct expression *,
				      int *, enum noside);
d125 1
a125 1
static struct value *evaluate_subexp_type (struct expression *, int *);
d127 1
a127 1
static struct type *ada_create_fundamental_type (struct objfile *, int);
d129 1
a129 1
static int is_dynamic_field (struct type *, int);
d131 2
a132 2
static struct type *to_fixed_variant_branch_type (struct type *, char *,
						  CORE_ADDR, struct value *);
d134 1
a134 2
static struct type *to_fixed_range_type (char *, struct value *,
					 struct objfile *);
d136 1
a136 1
static struct type *to_static_fixed_type (struct type *);
d138 1
a138 1
static struct value *unwrap_value (struct value *);
d140 1
a140 1
static struct type *packed_array_type (struct type *, long *);
d142 1
a142 1
static struct type *decode_packed_array_type (struct type *);
d144 1
a144 1
static struct value *decode_packed_array (struct value *);
d146 1
a146 2
static struct value *value_subscript_packed (struct value *, int,
					     struct value **);
d148 1
a148 2
static struct value *coerce_unspec_val_to_type (struct value *, long,
						struct type *);
d150 1
a150 1
static struct value *get_var_value (char *, char *);
d152 1
a152 1
static int lesseq_defined_than (struct symbol *, struct symbol *);
d154 1
a154 1
static int equiv_types (struct type *, struct type *);
d156 1
a156 1
static int is_name_suffix (const char *);
d158 1
a158 1
static int wild_match (const char *, int, const char *);
d160 1
a160 4
static struct symtabs_and_lines find_sal_from_funcs_and_line (const char *,
							      int,
							      struct symbol
							      **, int);
d162 2
a163 2
static int find_line_in_linetable (struct linetable *, int, struct symbol **,
				   int, int *);
d165 1
a165 1
static int find_next_line_in_linetable (struct linetable *, int, int, int);
d167 1
a167 2
static struct symtabs_and_lines all_sals_for_line (const char *, int,
						   char ***);
d169 1
a169 1
static void read_all_symtabs (const char *);
d171 1
a171 1
static int is_plausible_func_for_line (struct symbol *, int);
d173 1
a173 1
static struct value *ada_coerce_ref (struct value *);
d175 1
a175 1
static struct value *value_pos_atr (struct value *);
d177 1
a177 1
static struct value *value_val_atr (struct type *, struct value *);
d179 1
a179 1
static struct symbol *standard_lookup (const char *, namespace_enum);
d183 1
a185 1

d189 1
a189 1
static const char *ada_completer_word_break_characters =
d205 1
a205 1
  int char_index = 0;
d207 10
a216 9
  /* Loop, reading one byte at a time, until we reach the '\000' 
     end-of-string marker */
  do
    {
      target_read_memory (addr + char_index * sizeof (char),
			  buf + char_index * sizeof (char), sizeof (char));
      char_index++;
    }
  while (buf[char_index - 1] != '\000');
d224 1
a224 1
grow_vect (void **old_vect, size_t * size, size_t min_size, int element_size)
d226 6
a231 7
  if (*size < min_size)
    {
      *size *= 2;
      if (*size < min_size)
	*size = min_size;
      *old_vect = xrealloc (*old_vect, *size * element_size);
    }
d241 3
a243 3
  return
    STREQN (field_name, target, len)
    && (field_name[len] == '\0'
d245 1
a245 1
	    && !STREQ (field_name + strlen (field_name) - 6, "___XVN")));
d252 1
a252 1
ada_name_prefix_len (const char *name)
d256 1
a256 1
  else
d258 1
a258 1
      const char *p = strstr (name, "___");
d268 1
a268 1
is_suffix (const char *str, const char *suffix)
d281 2
a282 3
struct value *
value_from_contents_and_address (struct type *type, char *valaddr,
				 CORE_ADDR address)
d284 2
a285 2
  struct value *v = allocate_value (type);
  if (valaddr == NULL)
d298 2
a299 2
static struct value *
coerce_unspec_val_to_type (struct value *val, long offset, struct type *type)
d304 2
a305 3
			  VALUE_ADDRESS (val) + VALUE_OFFSET (val) + offset,
			  NULL);
  else
d307 1
a307 1
      struct value *result = allocate_value (type);
d309 1
a309 1
      if (VALUE_ADDRESS (val) == 0)
d311 1
a311 1
		TYPE_LENGTH (type) > TYPE_LENGTH (VALUE_TYPE (val))
d313 1
a313 1
      else
d315 1
a315 1
	  VALUE_ADDRESS (result) =
d323 2
a324 2
static char *
cond_offset_host (char *valaddr, long offset)
d337 1
a337 1
  else
d344 1
a344 1
do_command (const char *arg, ...)
d347 2
a348 2
  char *cmd;
  const char *s;
d355 1
a355 1
  for (; s != NULL; s = va_arg (ap, const char *))
d357 1
a357 1
      char *cmd1;
d359 1
a359 1
      cmd1 = alloca (len + 1);
d367 1
a368 1

d375 1
a375 1

d377 1
a377 2
ada_update_initial_language (enum language lang,
			     struct partial_symtab *main_pst)
d379 2
a380 2
  if (lookup_minimal_symbol ("adainit", (const char *) NULL,
			     (struct objfile *) NULL) != NULL)
d387 1
a388 1

d394 24
a417 23
const struct ada_opname_map ada_opname_table[] = {
  {"Oadd", "\"+\"", BINOP_ADD},
  {"Osubtract", "\"-\"", BINOP_SUB},
  {"Omultiply", "\"*\"", BINOP_MUL},
  {"Odivide", "\"/\"", BINOP_DIV},
  {"Omod", "\"mod\"", BINOP_MOD},
  {"Orem", "\"rem\"", BINOP_REM},
  {"Oexpon", "\"**\"", BINOP_EXP},
  {"Olt", "\"<\"", BINOP_LESS},
  {"Ole", "\"<=\"", BINOP_LEQ},
  {"Ogt", "\">\"", BINOP_GTR},
  {"Oge", "\">=\"", BINOP_GEQ},
  {"Oeq", "\"=\"", BINOP_EQUAL},
  {"One", "\"/=\"", BINOP_NOTEQUAL},
  {"Oand", "\"and\"", BINOP_BITWISE_AND},
  {"Oor", "\"or\"", BINOP_BITWISE_IOR},
  {"Oxor", "\"xor\"", BINOP_BITWISE_XOR},
  {"Oconcat", "\"&\"", BINOP_CONCAT},
  {"Oabs", "\"abs\"", UNOP_ABS},
  {"Onot", "\"not\"", UNOP_LOGICAL_NOT},
  {"Oadd", "\"+\"", UNOP_PLUS},
  {"Osubtract", "\"-\"", UNOP_NEG},
  {NULL, NULL}
d422 1
a422 1
is_suppressed_name (const char *str)
d430 2
a431 2
      const char *p;
      const char *suffix = strstr (str, "___");
d436 1
a436 1
      for (p = suffix - 1; p != str; p -= 1)
d445 1
a445 1
	      if (STREQN (ada_opname_table[i].mangled, p,
d449 1
a449 1
	  OK:;
d458 1
a458 1
ada_mangle (const char *demangled)
d460 1
a460 1
  static char *mangling_buffer = NULL;
d462 1
a462 1
  const char *p;
d464 1
a464 1

d468 1
a468 2
  GROW_VECT (mangling_buffer, mangling_buffer_size,
	     2 * strlen (demangled) + 10);
d473 1
a473 1
      if (*p == '.')
d475 1
a475 1
	  mangling_buffer[k] = mangling_buffer[k + 1] = '_';
d480 1
a480 1
	  const struct ada_opname_map *mapping;
d483 2
a484 2
	       mapping->mangled != NULL &&
	       !STREQN (mapping->demangled, p, strlen (mapping->demangled));
d489 1
a489 1
	  strcpy (mangling_buffer + k, mapping->mangled);
d493 1
a493 1
      else
d507 2
a508 2
char *
ada_fold_name (const char *name)
d510 1
a510 1
  static char *fold_buffer = NULL;
d514 1
a514 1
  GROW_VECT (fold_buffer, fold_buffer_size, len + 1);
d518 2
a519 2
      strncpy (fold_buffer, name + 1, len - 2);
      fold_buffer[len - 2] = '\000';
d545 1
a545 1
ada_demangle (const char *mangled)
d549 2
a550 2
  const char *p;
  char *demangled;
d552 1
a552 1
  static char *demangling_buffer = NULL;
d554 1
a554 1

d564 1
a564 1
  else
d577 1
a577 1
  GROW_VECT (demangling_buffer, demangling_buffer_size, 2 * len0 + 1);
d580 8
a587 9
  if (isdigit (mangled[len0 - 1]))
    {
      for (i = len0 - 2; i >= 0 && isdigit (mangled[i]); i -= 1)
	;
      if (i > 1 && mangled[i] == '_' && mangled[i - 1] == '_')
	len0 = i - 1;
      else if (mangled[i] == '$')
	len0 = i;
    }
d589 1
a589 1
  for (i = 0, j = 0; i < len0 && !isalpha (mangled[i]); i += 1, j += 1)
d600 3
a602 4
	      int op_len = strlen (ada_opname_table[k].mangled);
	      if (STREQN
		  (ada_opname_table[k].mangled + 1, mangled + i + 1,
		   op_len - 1) && !isalnum (mangled[i + op_len]))
d616 1
a616 1
      if (i < len0 - 4 && STREQN (mangled + i, "TK__", 4))
d618 1
a618 1
      if (mangled[i] == 'X' && i != 0 && isalnum (mangled[i - 1]))
d626 1
a626 1
      else if (i < len0 - 2 && mangled[i] == '_' && mangled[i + 1] == '_')
d630 1
a630 2
	  i += 2;
	  j += 1;
d635 1
a635 2
	  i += 1;
	  j += 1;
d647 2
a648 1
  GROW_VECT (demangling_buffer, demangling_buffer_size, strlen (mangled) + 3);
d666 1
a666 1
ada_match_name (const char *sym_name, const char *name, int wild)
d672 8
a679 9
  else
    {
      int len_name = strlen (name);
      return (STREQN (sym_name, name, len_name)
	      && is_name_suffix (sym_name + len_name))
	|| (STREQN (sym_name, "_ada_", 5)
	    && STREQN (sym_name + 5, name, len_name)
	    && is_name_suffix (sym_name + len_name + 5));
    }
d690 1
a690 1
  else
d693 1
a694 1

d700 2
a701 2
static char *bound_name[] = {
  "LB0", "UB0", "LB1", "UB1", "LB2", "UB2", "LB3", "UB3",
d714 3
a716 2
  modify_field (addr + sizeof (LONGEST) * bitpos / (8 * sizeof (LONGEST)),
		fieldval, bitpos % (8 * sizeof (LONGEST)), bitsize);
d725 2
a726 2
static struct type *
desc_base_type (struct type *type)
d739 1
a739 1
is_thin_pntr (struct type *type)
d741 1
a741 1
  return
d747 2
a748 2
static struct type *
thin_descriptor_type (struct type *type)
d750 1
a750 1
  struct type *base_type = desc_base_type (type);
d755 1
a755 1
  else
d757 2
a758 1
      struct type *alt_type = ada_find_parallel_type (base_type, "___XVE");
d767 2
a768 2
static struct value *
thin_data_pntr (struct value *val)
d770 1
a770 1
  struct type *type = VALUE_TYPE (val);
d772 1
a772 1
    return value_cast (desc_data_type (thin_descriptor_type (type)),
d774 1
a774 1
  else
d781 1
a781 1
is_thick_pntr (struct type *type)
d790 2
a791 2
static struct type *
desc_bounds_type (struct type *type)
d793 1
a793 1
  struct type *r;
d819 2
a820 2
static struct value *
desc_bounds (struct value *arr)
d822 2
a823 2
  struct type *type = check_typedef (VALUE_TYPE (arr));
  if (is_thin_pntr (type))
d825 1
a825 2
      struct type *bounds_type =
	desc_bounds_type (thin_descriptor_type (type));
d832 2
a833 2
         since desc_type is an XVE-encoded type (and shouldn't be),
         the correct calculation is a real pain. FIXME (and fix GCC). */
d836 1
a836 1
      else
d839 3
a841 3
      return
	value_from_longest (lookup_pointer_type (bounds_type),
			    addr - TYPE_LENGTH (bounds_type));
d845 1
a845 1
    return value_struct_elt (&arr, NULL, "P_BOUNDS", NULL,
d854 1
a854 1
fat_pntr_bounds_bitpos (struct type *type)
d862 1
a862 1
fat_pntr_bounds_bitsize (struct type *type)
d866 1
a866 1
  if (TYPE_FIELD_BITSIZE (type, 1) > 0)
d876 2
a877 2
static struct type *
desc_data_type (struct type *type)
d883 2
a884 2
    return lookup_pointer_type
      (desc_base_type (TYPE_FIELD_TYPE (thin_descriptor_type (type), 1)));
d893 2
a894 2
static struct value *
desc_data (struct value *arr)
d896 1
a896 1
  struct type *type = VALUE_TYPE (arr);
d900 1
a900 1
    return value_struct_elt (&arr, NULL, "P_ARRAY", NULL,
d910 1
a910 1
fat_pntr_data_bitpos (struct type *type)
d918 1
a918 1
fat_pntr_data_bitsize (struct type *type)
d924 1
a924 1
  else
d931 2
a932 2
static struct value *
desc_one_bound (struct value *bounds, int i, int which)
d934 1
a934 1
  return value_struct_elt (&bounds, NULL, bound_name[2 * i + which - 2], NULL,
d942 1
a942 1
desc_bound_bitpos (struct type *type, int i, int which)
d944 1
a944 1
  return TYPE_FIELD_BITPOS (desc_base_type (type), 2 * i + which - 2);
d951 1
a951 1
desc_bound_bitsize (struct type *type, int i, int which)
d955 4
a958 4
  if (TYPE_FIELD_BITSIZE (type, 2 * i + which - 2) > 0)
    return TYPE_FIELD_BITSIZE (type, 2 * i + which - 2);
  else
    return 8 * TYPE_LENGTH (TYPE_FIELD_TYPE (type, 2 * i + which - 2));
d962 3
a964 3
   Ith bound (numbering from 1). Otherwise, NULL. */
static struct type *
desc_index_type (struct type *type, int i)
d969 2
a970 2
    return lookup_struct_elt_type (type, bound_name[2 * i - 2], 1);
  else
d977 1
a977 1
desc_arity (struct type *type)
d989 1
a989 1
ada_is_simple_array (struct type *type)
d1001 1
a1001 1
ada_is_array_descriptor (struct type *type)
d1003 1
a1003 1
  struct type *data_type = desc_data_type (type);
d1008 1
a1008 1
  return
d1013 1
a1013 1
	||
d1025 1
a1025 1
  return
d1030 1
a1030 1
    && !ada_is_array_descriptor (type);
d1041 2
a1042 2
struct type *
ada_type_of_array (struct value *arr, int bounds)
d1047 1
a1047 1
  if (!ada_is_array_descriptor (VALUE_TYPE (arr)))
d1049 3
a1051 4

  if (!bounds)
    return
      check_typedef (TYPE_TARGET_TYPE (desc_data_type (VALUE_TYPE (arr))));
d1054 1
a1054 1
      struct type *elt_type;
d1056 1
a1056 1
      struct value *descriptor;
d1062 1
a1062 1
      if (elt_type == NULL || arity == 0)
d1066 1
a1066 1
      if (value_as_long (descriptor) == 0)
d1068 12
a1079 13
      while (arity > 0)
	{
	  struct type *range_type = alloc_type (objf);
	  struct type *array_type = alloc_type (objf);
	  struct value *low = desc_one_bound (descriptor, arity, 0);
	  struct value *high = desc_one_bound (descriptor, arity, 1);
	  arity -= 1;

	  create_range_type (range_type, VALUE_TYPE (low),
			     (int) value_as_long (low),
			     (int) value_as_long (high));
	  elt_type = create_array_type (array_type, elt_type, range_type);
	}
d1089 2
a1090 2
struct value *
ada_coerce_to_simple_array_ptr (struct value *arr)
d1094 1
a1094 1
      struct type *arrType = ada_type_of_array (arr, 1);
d1108 2
a1109 2
struct value *
ada_coerce_to_simple_array (struct value *arr)
d1113 1
a1113 1
      struct value *arrVal = ada_coerce_to_simple_array_ptr (arr);
d1120 1
a1120 1
  else
d1127 2
a1128 2
struct type *
ada_coerce_to_simple_array_type (struct type *type)
d1130 3
a1132 3
  struct value *mark = value_mark ();
  struct value *dummy = value_from_longest (builtin_type_long, 0);
  struct type *result;
d1141 1
a1141 1
ada_is_packed_array_type (struct type *type)
d1146 1
a1146 1
  return
d1159 2
a1160 2
static struct type *
packed_array_type (struct type *type, long *elt_bits)
d1162 2
a1163 2
  struct type *new_elt_type;
  struct type *new_type;
d1177 1
a1177 1
  if (get_discrete_bounds (TYPE_FIELD_TYPE (type, 0),
d1182 1
a1182 1
  else
d1185 1
a1185 1
      TYPE_LENGTH (new_type) =
d1196 2
a1197 2
static struct type *
decode_packed_array_type (struct type *type)
d1199 6
a1204 6
  struct symbol **syms;
  struct block **blocks;
  const char *raw_name = ada_type_name (check_typedef (type));
  char *name = (char *) alloca (strlen (raw_name) + 1);
  char *tail = strstr (raw_name, "___XP");
  struct type *shadow_type;
d1213 1
a1213 1
  n = ada_lookup_symbol_list (name, get_selected_block (NULL),
d1231 1
a1231 1

d1237 1
a1237 1

d1247 2
a1248 2
static struct value *
decode_packed_array (struct value *arr)
d1250 1
a1250 1
  struct type *type = decode_packed_array_type (VALUE_TYPE (arr));
d1265 2
a1266 2
static struct value *
value_subscript_packed (struct value *arr, int arity, struct value **ind)
d1271 2
a1272 2
  struct type *elt_type;
  struct value *v;
d1277 1
a1277 1
  for (i = 0; i < arity; i += 1)
d1279 1
a1279 1
      if (TYPE_CODE (elt_type) != TYPE_CODE_ARRAY
d1281 1
a1281 2
	error
	  ("attempt to do packed indexing of something other than a packed array");
d1288 2
a1289 1
	  if (get_discrete_bounds (range_type, &lowerbound, &upperbound) < 0)
d1294 1
a1294 1

d1305 2
a1306 2

  v = ada_value_primitive_packed_val (arr, NULL, elt_off, bit_off,
d1318 1
a1318 1
has_negatives (struct type *type)
d1320 8
a1327 9
  switch (TYPE_CODE (type))
    {
    default:
      return 0;
    case TYPE_CODE_INT:
      return !TYPE_UNSIGNED (type);
    case TYPE_CODE_RANGE:
      return TYPE_LOW_BOUND (type) < 0;
    }
d1329 1
a1329 1

d1340 3
a1342 4
struct value *
ada_value_primitive_packed_val (struct value *obj, char *valaddr, long offset,
				int bit_offset, int bit_size,
				struct type *type)
d1344 1
a1344 1
  struct value *v;
d1347 2
a1348 1
    i, srcBitsLeft,		/* Number of source bits left to move. */
d1353 2
a1354 2
  unsigned char *bytes;		/* First byte containing data to unpack. */
  unsigned char *unpacked;
d1359 1
a1359 1
   * direction the indices move. */
d1367 1
a1367 1
      bytes = (unsigned char *) (valaddr + offset);
d1373 1
a1373 1
      bytes = (unsigned char *) alloca (len);
d1376 1
a1376 1
  else
d1379 1
a1379 1
      bytes = (unsigned char *) VALUE_CONTENTS (obj) + offset;
d1381 2
a1382 2

  if (obj != NULL)
d1391 4
a1394 4
	{
	  VALUE_ADDRESS (v) += 1;
	  VALUE_BITPOS (v) -= HOST_CHAR_BIT;
	}
d1398 1
a1398 1
  unpacked = (unsigned char *) VALUE_CONTENTS (v);
d1411 3
a1413 3
      src = len - 1;
      if (has_negatives (type) &&
	  ((bytes[0] << bit_offset) & (1 << (HOST_CHAR_BIT - 1))))
d1415 2
a1416 2

      unusedLS =
d1421 7
a1427 7
	{
	case TYPE_CODE_ARRAY:
	case TYPE_CODE_UNION:
	case TYPE_CODE_STRUCT:
	  /* Non-scalar values must be aligned at a byte boundary. */
	  accumSize =
	    (HOST_CHAR_BIT - bit_size % HOST_CHAR_BIT) % HOST_CHAR_BIT;
d1431 2
a1432 2
	  break;
	default:
d1435 2
a1436 2
	  break;
	}
d1438 1
a1438 1
  else
d1446 1
a1446 1
      if (has_negatives (type) && (bytes[len - 1] & (1 << sign_bit_offset)))
d1449 1
a1449 1

d1455 2
a1456 3
      unsigned int unusedMSMask =
	(1 << (srcBitsLeft >= HOST_CHAR_BIT ? HOST_CHAR_BIT : srcBitsLeft)) -
	1;
d1459 1
a1459 1
      accum |=
d1462 1
a1462 1
      if (accumSize >= HOST_CHAR_BIT)
d1487 1
a1487 1

d1492 1
a1492 1
move_bits (char *target, int targ_offset, char *source, int src_offset, int n)
d1501 1
a1501 1
  if (BITS_BIG_ENDIAN)
d1507 1
a1507 1
      while (n > 0)
d1518 2
a1519 2
	  *target =
	    (*target & ~mask)
d1533 1
a1533 1
      while (n > 0)
d1542 2
a1543 1
	  *target = (*target & ~mask) | ((accum << targ_offset) & mask);
d1559 2
a1560 2
static struct value *
ada_value_assign (struct value *toval, struct value *fromval)
d1562 1
a1562 1
  struct type *type = VALUE_TYPE (toval);
d1570 1
a1570 1
  if (VALUE_LVAL (toval) == lval_memory
d1572 1
a1572 1
      && (TYPE_CODE (type) == TYPE_CODE_FLT
d1575 5
a1579 4
      int len =
	(VALUE_BITPOS (toval) + bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;
      char *buffer = (char *) alloca (len);
      struct value *val;
d1586 4
a1589 4
	move_bits (buffer, VALUE_BITPOS (toval),
		   VALUE_CONTENTS (fromval),
		   TYPE_LENGTH (VALUE_TYPE (fromval)) * TARGET_CHAR_BIT -
		   bits, bits);
d1591 1
a1591 1
	move_bits (buffer, VALUE_BITPOS (toval), VALUE_CONTENTS (fromval),
d1593 1
a1593 2
      write_memory (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval), buffer,
		    len);
d1599 1
a1599 1

d1611 2
a1612 2
struct value *
ada_value_subscript (struct value *arr, int arity, struct value **ind)
d1615 2
a1616 2
  struct value *elt;
  struct type *elt_type;
d1621 1
a1621 1
  if (TYPE_CODE (elt_type) == TYPE_CODE_ARRAY
d1628 1
a1628 1
	error ("too many subscripts (%d expected)", k);
d1638 2
a1639 3
struct value *
ada_value_ptr_subscript (struct value *arr, struct type *type, int arity,
			 struct value **ind)
d1646 1
a1646 1
      struct value *idx;
d1649 2
a1650 2
	error ("too many subscripts (%d expected)", k);
      arr = value_cast (lookup_pointer_type (TYPE_TARGET_TYPE (type)),
d1653 1
a1653 1
      if (lwb == 0)
d1670 1
a1670 1
ada_array_arity (struct type *type)
d1680 1
a1680 1
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)
d1682 2
a1683 2
  else
    while (TYPE_CODE (type) == TYPE_CODE_ARRAY)
d1688 1
a1688 1

d1697 2
a1698 2
struct type *
ada_array_element_type (struct type *type, int nindices)
d1702 1
a1702 1
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)
d1705 1
a1705 1
      struct type *p_array_type;
d1712 1
a1712 1

d1717 1
a1717 1
      while (k > 0 && p_array_type != NULL)
d1740 2
a1741 2
struct type *
ada_index_type (struct type *type, int n)
d1757 1
a1757 1
  else
d1769 1
a1769 2
ada_array_bound_from_type (struct type * arr_type, int n, int which,
			   struct type ** typep)
d1771 2
a1772 2
  struct type *type;
  struct type *index_type_desc;
d1777 1
a1777 1
  if (arr_type == NULL || !ada_is_simple_array (arr_type))
d1781 1
a1781 1
      return (LONGEST) - which;
d1790 1
a1790 1
  if (index_type_desc == NULL)
d1792 2
a1793 2
      struct type *range_type;
      struct type *index_type;
d1795 1
a1795 1
      while (n > 1)
d1804 1
a1804 1
	index_type = builtin_type_long;
d1807 2
a1808 2
      return
	(LONGEST) (which == 0
d1812 1
a1812 1
  else
d1814 2
a1815 2
      struct type *index_type =
	to_fixed_range_type (TYPE_FIELD_NAME (index_type_desc, n - 1),
d1819 2
a1820 2
      return
	(LONGEST) (which == 0
d1831 1
a1831 1
struct value *
d1833 2
a1834 2
     struct value *arr;
     int n;
d1837 1
a1837 1
  struct type *arr_type = VALUE_TYPE (arr);
d1841 1
a1841 1
  else if (ada_is_simple_array (arr_type))
d1843 1
a1843 1
      struct type *type;
d1855 1
a1855 1
   clauses at the moment. */
d1857 2
a1858 2
struct value *
ada_array_length (struct value *arr, int n)
d1860 2
a1861 2
  struct type *arr_type = check_typedef (VALUE_TYPE (arr));
  struct type *index_type_desc;
d1868 1
a1868 1
      struct type *type;
d1875 1
a1875 1
    return
d1880 2
a1881 1
							   n, 0)) + 1);
d1883 1
a1884 1

d1890 1
a1890 1
static const char *
d1915 1
a1915 1
ada_resolve (struct expression **expp, struct type *context_type)
d1930 2
a1931 3
static struct value *
ada_resolve_subexp (struct expression **expp, int *pos, int deprocedure_p,
		    struct type *context_type)
d1935 1
a1935 1
  struct expression *exp;	/* Convenience: == *expp */
d1937 1
a1937 1
  struct value **argvec;	/* Vector of operand types (alloca'ed). */
d1948 1
a1948 1
      /*    case OP_UNRESOLVED_VALUE: */
d1956 17
a1972 17
      /*      if (exp->elts[pc+3].opcode == OP_UNRESOLVED_VALUE)        
         {
         *pos += 7;

         argvec = (struct value* *) alloca (sizeof (struct value*) * (nargs + 1));
         for (i = 0; i < nargs-1; i += 1)
         argvec[i] = ada_resolve_subexp (expp, pos, 1, NULL);
         argvec[i] = NULL;
         }
         else
         {
         *pos += 3;
         ada_resolve_subexp (expp, pos, 0, NULL);
         for (i = 1; i < nargs; i += 1)
         ada_resolve_subexp (expp, pos, 1, NULL);
         }
       */
d1978 7
a1984 7
         nargs = 1;
         *pos += 3;
         ada_resolve_subexp (expp, pos, 1, exp->elts[pc + 1].type);
         exp = *expp;
         break;
       */
      /* FIXME:  OP_ATTRIBUTE should be defined in expression.h */
d1986 7
a1992 7
         nargs = longest_to_int (exp->elts[pc + 1].longconst) + 1;
         *pos += 4;
         for (i = 0; i < nargs; i += 1)
         ada_resolve_subexp (expp, pos, 1, NULL);
         exp = *expp;
         break;
       */
d2002 1
a2002 1
	struct value *arg1;
d2014 1
a2014 1
      switch (op)
d2019 5
a2023 5
	  /*    case UNOP_MBR:
	     nargs = 1;
	     *pos += 3;
	     break;
	   */
d2087 1
a2087 1
	  *pos += 4;
d2091 3
a2093 3
	  /*      if (nargs == 0)
	     nargs = 1;
	     break; */
d2097 5
a2101 5
	  /*    case TERNOP_MBR:
	     *pos += 1;
	     nargs = 3;
	     break;
	   */
d2103 4
a2106 4
	  /*    case BINOP_MBR:
	     *pos += 3;
	     nargs = 2;
	     break; */
d2109 1
a2109 2
      argvec =
	(struct value * *) alloca (sizeof (struct value *) * (nargs + 1));
d2125 50
a2174 50
         {
         struct symbol** candidate_syms;
         struct block** candidate_blocks;
         int n_candidates;

         n_candidates = ada_lookup_symbol_list (exp->elts[pc + 2].name,
         exp->elts[pc + 1].block,
         VAR_NAMESPACE,
         &candidate_syms,
         &candidate_blocks);

         if (n_candidates > 1) 
         { */
      /* Types tend to get re-introduced locally, so if there
         are any local symbols that are not types, first filter
   out all types. *//*
   int j;
   for (j = 0; j < n_candidates; j += 1) 
   switch (SYMBOL_CLASS (candidate_syms[j])) 
   {
   case LOC_REGISTER:
   case LOC_ARG:
   case LOC_REF_ARG:
   case LOC_REGPARM:
   case LOC_REGPARM_ADDR:
   case LOC_LOCAL:
   case LOC_LOCAL_ARG:
   case LOC_BASEREG:
   case LOC_BASEREG_ARG:
   goto FoundNonType;
   default:
   break;
   }
   FoundNonType:
   if (j < n_candidates) 
   {
   j = 0;
   while (j < n_candidates) 
   {
   if (SYMBOL_CLASS (candidate_syms[j]) == LOC_TYPEDEF)
   {
   candidate_syms[j] = candidate_syms[n_candidates-1];
   candidate_blocks[j] = candidate_blocks[n_candidates-1];
   n_candidates -= 1;
   }
   else
   j += 1;
   }
   }
   }
d2176 23
a2198 23
   if (n_candidates == 0)
   error ("No definition found for %s", 
   ada_demangle (exp->elts[pc + 2].name));
   else if (n_candidates == 1)
   i = 0;
   else if (deprocedure_p 
   && ! is_nonfunction (candidate_syms, n_candidates))
   {
   i = ada_resolve_function (candidate_syms, candidate_blocks,
   n_candidates, NULL, 0,
   exp->elts[pc + 2].name, context_type);
   if (i < 0) 
   error ("Could not find a match for %s", 
   ada_demangle (exp->elts[pc + 2].name));
   }
   else 
   {
   printf_filtered ("Multiple matches for %s\n", 
   ada_demangle (exp->elts[pc+2].name));
   user_select_syms (candidate_syms, candidate_blocks, 
   n_candidates, 1);
   i = 0;
   }
d2200 7
a2206 7
   exp->elts[pc].opcode = exp->elts[pc + 3].opcode = OP_VAR_VALUE;
   exp->elts[pc + 1].block = candidate_blocks[i];
   exp->elts[pc + 2].symbol = candidate_syms[i];
   if (innermost_block == NULL ||
   contained_in (candidate_blocks[i], innermost_block))
   innermost_block = candidate_blocks[i];
   } */
d2210 6
a2215 7
      if (deprocedure_p &&
	  TYPE_CODE (SYMBOL_TYPE (exp->elts[pc + 2].symbol)) ==
	  TYPE_CODE_FUNC)
	{
	  replace_operator_with_call (expp, pc, 0, 0,
				      exp->elts[pc + 2].symbol,
				      exp->elts[pc + 1].block);
d2223 22
a2244 30
	/*      if (exp->elts[pc+3].opcode == OP_UNRESOLVED_VALUE)      
	   {
	   struct symbol** candidate_syms;
	   struct block** candidate_blocks;
	   int n_candidates;

	   n_candidates = ada_lookup_symbol_list (exp->elts[pc + 5].name,
	   exp->elts[pc + 4].block,
	   VAR_NAMESPACE,
	   &candidate_syms,
	   &candidate_blocks);
	   if (n_candidates == 1)
	   i = 0;
	   else
	   {
	   i = ada_resolve_function (candidate_syms, candidate_blocks,
	   n_candidates, argvec, nargs-1,
	   exp->elts[pc + 5].name, context_type);
	   if (i < 0) 
	   error ("Could not find a match for %s", 
	   ada_demangle (exp->elts[pc + 5].name));
	   }

	   exp->elts[pc + 3].opcode = exp->elts[pc + 6].opcode = OP_VAR_VALUE;
	   exp->elts[pc + 4].block = candidate_blocks[i];
	   exp->elts[pc + 5].symbol = candidate_syms[i];
	   if (innermost_block == NULL ||
	   contained_in (candidate_blocks[i], innermost_block))
	   innermost_block = candidate_blocks[i];
	   } */
d2246 8
d2279 2
a2280 2
	  struct symbol **candidate_syms;
	  struct block **candidate_blocks;
d2283 8
a2290 8
	  n_candidates =
	    ada_lookup_symbol_list (ada_mangle (ada_op_name (op)),
				    (struct block *) NULL, VAR_NAMESPACE,
				    &candidate_syms, &candidate_blocks);
	  i =
	    ada_resolve_function (candidate_syms, candidate_blocks,
				  n_candidates, argvec, nargs,
				  ada_op_name (op), NULL);
d2307 1
a2307 1
   a non-pointer. */
d2313 2
a2314 2
     struct type *ftype;
     struct type *atype;
d2325 1
a2325 1
  if (TYPE_CODE (ftype) == TYPE_CODE_VOID
d2329 1
a2329 1
  switch (TYPE_CODE (ftype))
d2337 2
a2338 3
      else
	return (may_deref &&
		ada_type_match (TYPE_TARGET_TYPE (ftype), atype, 0));
d2353 1
a2353 1
      return (TYPE_CODE (atype) == TYPE_CODE_ARRAY
d2358 1
a2358 1
	return (TYPE_CODE (atype) == TYPE_CODE_ARRAY
d2362 1
a2362 1
		&& !ada_is_array_descriptor (atype));
d2376 1
a2376 1
ada_args_match (struct symbol *func, struct value **actuals, int n_actuals)
d2379 1
a2379 1
  struct type *func_type = SYMBOL_TYPE (func);
d2381 1
a2381 1
  if (SYMBOL_CLASS (func) == LOC_CONST &&
d2392 2
a2393 2
      struct type *ftype = check_typedef (TYPE_FIELD_TYPE (func_type, i));
      struct type *atype = check_typedef (VALUE_TYPE (actuals[i]));
d2395 2
a2396 2
      if (!ada_type_match (TYPE_FIELD_TYPE (func_type, i),
			   VALUE_TYPE (actuals[i]), 1))
d2408 1
a2408 1
return_match (struct type *func_type, struct type *context_type)
d2410 1
a2410 1
  struct type *return_type;
d2417 3
a2419 3
     return_type = base_type (TYPE_TARGET_TYPE (func_type));
     else 
     return_type = base_type (func_type); */
d2424 1
a2424 1
  /*  context_type = base_type (context_type); */
d2447 3
a2449 3
ada_resolve_function (struct symbol *syms[], struct block *blocks[],
		      int nsyms, struct value **args, int nargs,
		      const char *name, struct type *context_type)
d2453 2
a2454 2
  struct type *fallback;
  struct type *return_type;
d2462 1
a2462 1
  m = 0;
d2467 1
a2467 1
	  struct type *type = check_typedef (SYMBOL_TYPE (syms[k]));
d2501 1
a2501 1
mangled_ordered_before (char *N0, char *N1)
d2510 1
a2510 1
      for (k0 = strlen (N0) - 1; k0 > 0 && isdigit (N0[k0]); k0 -= 1)
d2512 1
a2512 1
      for (k1 = strlen (N1) - 1; k1 > 0 && isdigit (N1[k1]); k1 -= 1)
d2514 2
a2515 2
      if ((N0[k0] == '_' || N0[k0] == '$') && N0[k0 + 1] != '\000'
	  && (N1[k1] == '_' || N1[k1] == '$') && N1[k1 + 1] != '\000')
d2519 1
a2519 1
	  while (N0[n0] == '_' && n0 > 0 && N0[n0 - 1] == '_')
d2522 1
a2522 1
	  while (N1[n1] == '_' && n1 > 0 && N1[n1 - 1] == '_')
d2525 1
a2525 1
	    return (atoi (N0 + k0 + 1) < atoi (N1 + k1 + 1));
d2530 1
a2530 1

d2534 2
a2535 2
static void
sort_choices (struct symbol *syms[], struct block *blocks[], int nsyms)
d2538 1
a2538 1
  for (i = 1; i < nsyms; i += 1)
d2540 2
a2541 2
      struct symbol *sym = syms[i];
      struct block *block = blocks[i];
d2544 1
a2544 1
      for (j = i - 1; j >= 0; j -= 1)
d2549 2
a2550 2
	  syms[j + 1] = syms[j];
	  blocks[j + 1] = blocks[j];
d2552 2
a2553 2
      syms[j + 1] = sym;
      blocks[j + 1] = block;
d2568 1
a2568 1
user_select_syms (struct symbol *syms[], struct block *blocks[], int nsyms,
d2572 1
a2572 1
  int *chosen = (int *) alloca (sizeof (int) * nsyms);
d2581 1
a2581 1
  printf_unfiltered ("[0] cancel\n");
d2583 1
a2583 1
    printf_unfiltered ("[1] all\n");
d2596 1
a2596 1
			     i + first_choice,
d2598 4
a2601 3
			     sal.symtab == NULL
			     ? "<no source file available>"
			     : sal.symtab->filename, sal.line);
d2604 1
a2604 1
      else
d2606 1
a2606 1
	  int is_enumeral =
d2609 3
a2611 2
	     && TYPE_CODE (SYMBOL_TYPE (syms[i])) == TYPE_CODE_ENUM);
	  struct symtab *symtab = symtab_for_sym (syms[i]);
d2618 2
a2619 1
	  else if (is_enumeral && TYPE_NAME (SYMBOL_TYPE (syms[i])) != NULL)
d2627 1
a2627 1
	    printf_unfiltered (is_enumeral
d2637 1
a2637 2
			       i + first_choice,
			       SYMBOL_SOURCE_NAME (syms[i]));
d2640 1
a2640 1

d2647 1
a2647 1
      if (blocks != NULL)
d2671 2
a2672 2
get_selections (int *choices, int n_choices, int max_results,
		int is_all_choice, char *annotation_suffix)
d2675 2
a2676 2
  char *args;
  const char *prompt;
d2679 1
a2679 1

d2688 1
a2688 1

d2698 1
a2698 1
      char *args2;
d2709 1
a2709 2
      if (args == args2 || choice < 0
	  || choice > n_choices + first_choice - 1)
d2713 1
a2713 1
      if (choice == 0)
d2725 2
a2726 3
      for (j = n_chosen - 1; j >= 0 && choice < choices[j]; j -= 1)
	{
	}
d2731 3
a2733 3
	  for (k = n_chosen - 1; k > j; k -= 1)
	    choices[k + 1] = choices[k];
	  choices[j + 1] = choice;
d2740 1
a2740 1

d2749 3
a2751 3
replace_operator_with_call (struct expression **expp, int pc, int nargs,
			    int oplen, struct symbol *sym,
			    struct block *block)
d2755 1
a2755 1
  struct expression *newexp = (struct expression *)
d2758 1
a2758 1
  struct expression *exp = *expp;
d2763 1
a2763 1
  memcpy (newexp->elts + pc + 7, exp->elts + pc + oplen,
d2775 1
a2775 1
}
d2783 1
a2783 1
numeric_type_p (struct type *type)
d2787 13
a2799 14
  else
    {
      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_INT:
	case TYPE_CODE_FLT:
	  return 1;
	case TYPE_CODE_RANGE:
	  return (type == TYPE_TARGET_TYPE (type)
		  || numeric_type_p (TYPE_TARGET_TYPE (type)));
	default:
	  return 0;
	}
    }
d2805 1
a2805 1
integer_type_p (struct type *type)
d2809 12
a2820 13
  else
    {
      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_INT:
	  return 1;
	case TYPE_CODE_RANGE:
	  return (type == TYPE_TARGET_TYPE (type)
		  || integer_type_p (TYPE_TARGET_TYPE (type)));
	default:
	  return 0;
	}
    }
d2826 1
a2826 1
scalar_type_p (struct type *type)
d2830 12
a2841 13
  else
    {
      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_INT:
	case TYPE_CODE_RANGE:
	case TYPE_CODE_ENUM:
	case TYPE_CODE_FLT:
	  return 1;
	default:
	  return 0;
	}
    }
d2847 1
a2847 1
discrete_type_p (struct type *type)
d2851 11
a2861 12
  else
    {
      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_INT:
	case TYPE_CODE_RANGE:
	case TYPE_CODE_ENUM:
	  return 1;
	default:
	  return 0;
	}
    }
d2869 1
a2869 1
possible_user_operator_p (enum exp_opcode op, struct value *args[])
d2871 2
a2872 2
  struct type *type0 = check_typedef (VALUE_TYPE (args[0]));
  struct type *type1 =
d2874 1
a2874 1

d2884 1
a2884 1
      return (!(numeric_type_p (type0) && numeric_type_p (type1)));
d2891 1
a2891 1
      return (!(integer_type_p (type0) && integer_type_p (type1)));
d2899 1
a2899 1
      return (!(scalar_type_p (type0) && scalar_type_p (type1)));
d2902 8
a2909 7
      return ((TYPE_CODE (type0) != TYPE_CODE_ARRAY &&
	       (TYPE_CODE (type0) != TYPE_CODE_PTR ||
		TYPE_CODE (TYPE_TARGET_TYPE (type0))
		!= TYPE_CODE_ARRAY))
	      || (TYPE_CODE (type1) != TYPE_CODE_ARRAY &&
		  (TYPE_CODE (type1) != TYPE_CODE_PTR ||
		   TYPE_CODE (TYPE_TARGET_TYPE (type1)) != TYPE_CODE_ARRAY)));
d2912 1
a2912 1
      return (!(numeric_type_p (type0) && integer_type_p (type1)));
d2917 2
a2918 2
    case UNOP_ABS:
      return (!numeric_type_p (type0));
d2933 2
a2934 2
const char *
ada_renaming_type (struct type *type)
d2938 4
a2941 4
      const char *name = type_name_no_tag (type);
      const char *suffix = (name == NULL) ? NULL : strstr (name, "___XR");
      if (suffix == NULL
	  || (suffix[5] != '\000' && strchr ("PES_", suffix[5]) == NULL))
d2952 1
a2952 1
ada_is_object_renaming (struct symbol *sym)
d2954 2
a2955 2
  const char *renaming_type = ada_renaming_type (SYMBOL_TYPE (sym));
  return renaming_type != NULL
d2962 2
a2963 2
const char *
ada_simple_renamed_entity (struct symbol *sym)
d2965 2
a2966 2
  struct type *type;
  const char *raw_name;
d2968 1
a2968 1
  char *result;
d2980 2
a2981 2
  /* FIXME: add_name_string_cleanup should be defined in parse.c */
  /*  add_name_string_cleanup (result); */
d2986 1
a2987 1

d2993 2
a2994 2
static struct value *
place_on_stack (struct value *val, CORE_ADDR *sp)
d2999 2
a3000 3
  *sp = push_bytes (*sp, VALUE_CONTENTS_RAW (val),
		    STACK_ALIGN (TYPE_LENGTH
				 (check_typedef (VALUE_TYPE (val)))));
d3002 1
a3002 1
  *sp = push_bytes (*sp, VALUE_CONTENTS_RAW (val),
d3018 1
a3018 1
   values not residing in memory, updating it as needed. */
d3020 11
a3030 12
static struct value *
convert_actual (struct value *actual, struct type *formal_type0,
		CORE_ADDR *sp)
{
  struct type *actual_type = check_typedef (VALUE_TYPE (actual));
  struct type *formal_type = check_typedef (formal_type0);
  struct type *formal_target =
    TYPE_CODE (formal_type) == TYPE_CODE_PTR
    ? check_typedef (TYPE_TARGET_TYPE (formal_type)) : formal_type;
  struct type *actual_target =
    TYPE_CODE (actual_type) == TYPE_CODE_PTR
    ? check_typedef (TYPE_TARGET_TYPE (actual_type)) : actual_type;
d3038 1
a3038 1
	  && ada_is_array_descriptor (actual_target))
d3044 1
a3044 1
	      struct value *val;
d3047 2
a3048 2
	      memcpy ((char *) VALUE_CONTENTS_RAW (val),
		      (char *) VALUE_CONTENTS (actual),
d3068 2
a3069 2
static struct value *
make_array_descriptor (struct type *type, struct value *arr, CORE_ADDR *sp)
d3071 4
a3074 4
  struct type *bounds_type = desc_bounds_type (type);
  struct type *desc_type = desc_base_type (type);
  struct value *descriptor = allocate_value (desc_type);
  struct value *bounds = allocate_value (bounds_type);
d3077 1
a3077 1

d3081 1
a3081 1
			    value_as_long (ada_array_bound (arr, i, 0)),
d3085 1
a3085 1
			    value_as_long (ada_array_bound (arr, i, 1)),
d3089 1
a3089 1

d3091 1
a3091 1

d3119 1
a3119 2
ada_convert_actuals (struct value *func, int nargs, struct value *args[],
		     CORE_ADDR *sp)
d3123 1
a3123 1
  if (TYPE_NFIELDS (VALUE_TYPE (func)) == 0
d3128 4
a3131 2
    args[i] =
      convert_actual (args[i], TYPE_FIELD_TYPE (VALUE_TYPE (func), i), sp);
d3133 1
a3134 1

d3142 1
a3142 1
static size_t defn_vector_size = 0;
d3147 2
a3148 2
static struct symbol **defn_symbols = NULL;
static struct block **defn_blocks = NULL;
d3153 2
a3154 2
static struct symbol *
standard_lookup (const char *name, namespace_enum namespace)
d3156 3
a3158 3
  struct symbol *sym;
  struct symtab *symtab;
  sym = lookup_symbol (name, (struct block *) NULL, namespace, 0, &symtab);
d3161 1
a3161 1

d3165 1
a3165 1
/* contend in overloading in the same way. */
d3167 1
a3167 1
is_nonfunction (struct symbol *syms[], int n)
d3183 1
a3183 1
equiv_types (struct type *type0, struct type *type1)
d3185 1
a3185 1
  if (type0 == type1)
d3187 1
a3187 1
  if (type0 == NULL || type1 == NULL
d3190 1
a3190 1
  if ((TYPE_CODE (type0) == TYPE_CODE_STRUCT
d3195 1
a3195 1

d3203 1
a3203 1
lesseq_defined_than (struct symbol *sym0, struct symbol *sym1)
d3211 1
a3211 1
  switch (SYMBOL_CLASS (sym0))
d3217 4
a3220 4
	struct type *type0 = SYMBOL_TYPE (sym0);
	struct type *type1 = SYMBOL_TYPE (sym1);
	char *name0 = SYMBOL_NAME (sym0);
	char *name1 = SYMBOL_NAME (sym1);
d3222 1
a3222 1
	return
d3231 2
a3232 2
    default:
      return 0;
d3241 1
a3241 1
add_defn_to_vec (struct symbol *sym, struct block *block)
d3246 1
a3246 1
  if (SYMBOL_TYPE (sym) != NULL)
d3261 2
a3262 2
  GROW_VECT (defn_symbols, tmp, ndefns + 2);
  GROW_VECT (defn_blocks, defn_vector_size, ndefns + 2);
d3274 1
a3274 2
ada_lookup_partial_symbol (struct partial_symtab *pst, const char *name,
			   int global, namespace_enum namespace, int wild)
d3285 1
a3285 1

d3288 1
a3288 1
	   pst->objfile->static_psymbols.list + pst->statics_offset);
d3294 1
a3294 1
	  struct partial_symbol *psym = start[i];
d3302 1
a3302 1
  else
d3307 2
a3308 3
	  i = 0;
	  U = length - 1;
	  while (U - i > 4)
d3310 2
a3311 2
	      int M = (U + i) >> 1;
	      struct partial_symbol *psym = start[M];
d3313 1
a3313 1
		i = M + 1;
d3315 1
a3315 1
		U = M - 1;
d3317 1
a3317 1
		i = M + 1;
d3332 2
a3333 2

	      if (cmp < 0)
d3338 2
a3339 2
	      else if (cmp == 0
		       && is_name_suffix (SYMBOL_NAME (psym) + name_len))
d3348 2
a3349 3
	  i = 0;
	  U = length - 1;
	  while (U - i > 4)
d3351 1
a3351 1
	      int M = (U + i) >> 1;
d3354 1
a3354 1
		i = M + 1;
d3356 1
a3356 1
		U = M - 1;
d3358 1
a3358 1
		i = M + 1;
d3368 1
a3368 1
	  struct partial_symbol *psym = start[i];
d3375 1
a3375 1
	      if (cmp == 0)
d3381 2
a3382 2

	      if (cmp < 0)
d3387 2
a3388 2
	      else if (cmp == 0
		       && is_name_suffix (SYMBOL_NAME (psym) + name_len + 5))
d3393 1
a3393 1

d3400 2
a3401 2
static struct symtab *
symtab_for_sym (struct symbol *sym)
d3403 1
a3403 1
  struct symtab *s;
d3410 17
a3426 37
  {
    switch (SYMBOL_CLASS (sym))
      {
      case LOC_CONST:
      case LOC_STATIC:
      case LOC_TYPEDEF:
      case LOC_REGISTER:
      case LOC_LABEL:
      case LOC_BLOCK:
      case LOC_CONST_BYTES:
	b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
	ALL_BLOCK_SYMBOLS (b, i, tmp_sym) if (sym == tmp_sym)
	  return s;
	b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
	ALL_BLOCK_SYMBOLS (b, i, tmp_sym) if (sym == tmp_sym)
	  return s;
	break;
      default:
	break;
      }
    switch (SYMBOL_CLASS (sym))
      {
      case LOC_REGISTER:
      case LOC_ARG:
      case LOC_REF_ARG:
      case LOC_REGPARM:
      case LOC_REGPARM_ADDR:
      case LOC_LOCAL:
      case LOC_TYPEDEF:
      case LOC_LOCAL_ARG:
      case LOC_BASEREG:
      case LOC_BASEREG_ARG:
	for (j = FIRST_LOCAL_BLOCK;
	     j < BLOCKVECTOR_NBLOCKS (BLOCKVECTOR (s)); j += 1)
	  {
	    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), j);
	    ALL_BLOCK_SYMBOLS (b, i, tmp_sym) if (sym == tmp_sym)
d3428 29
a3456 6
	  }
	break;
      default:
	break;
      }
  }
d3463 2
a3464 2
struct minimal_symbol *
ada_lookup_minimal_symbol (const char *name)
d3466 2
a3467 2
  struct objfile *objfile;
  struct minimal_symbol *msymbol;
d3471 5
a3475 5
  {
    if (ada_match_name (SYMBOL_NAME (msymbol), name, wild_match)
	&& MSYMBOL_TYPE (msymbol) != mst_solib_trampoline)
      return msymbol;
  }
d3490 1
a3490 2
add_symbols_from_enclosing_procs (const char *name, namespace_enum namespace,
				  int wild_match)
d3496 3
a3498 3
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  struct frame_info *frame;
  struct frame_info *target_frame;
d3510 2
a3511 2
      SYMBOL_VALUE (static_link) =
	-(long) TYPE_LENGTH (SYMBOL_TYPE (static_link));
d3517 2
a3518 2
      struct block *block;
      struct value *target_link_val = read_var_value (static_link, frame);
d3526 1
a3526 2
      do
	{
d3529 1
a3529 2
	}
      while (frame != NULL && FRAME_LOCALS_ADDRESS (frame) != target_link);
d3538 1
a3538 1

d3550 1
a3550 1
is_nondebugging_type (struct type *type)
d3552 1
a3552 1
  char *name = ada_type_name (type);
d3565 1
a3565 1
remove_extra_symbols (struct symbol **syms, struct block **blocks, int nsyms)
d3572 1
a3572 2
      if (SYMBOL_NAME (syms[i]) != NULL
	  && SYMBOL_CLASS (syms[i]) == LOC_STATIC
d3577 1
a3577 1
	      if (i != j
d3581 1
a3581 1
		  && SYMBOL_VALUE_ADDRESS (syms[i])
d3585 1
a3585 1
		  for (k = i + 1; k < nsyms; k += 1)
d3587 2
a3588 2
		      syms[k - 1] = syms[k];
		      blocks[k - 1] = blocks[k];
d3615 2
a3616 2
			namespace_enum namespace, struct symbol ***syms,
			struct block ***blocks)
d3654 1
a3654 1

d3661 8
a3668 8
  {
    QUIT;
    if (!s->primary)
      continue;
    bv = BLOCKVECTOR (s);
    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    ada_add_block_symbols (block, name, namespace, objfile, wild_match);
  }
d3673 30
a3702 30
      {
	if (ada_match_name (SYMBOL_NAME (msymbol), name, wild_match))
	  {
	    switch (MSYMBOL_TYPE (msymbol))
	      {
	      case mst_solib_trampoline:
		break;
	      default:
		s = find_pc_symtab (SYMBOL_VALUE_ADDRESS (msymbol));
		if (s != NULL)
		  {
		    int old_ndefns = ndefns;
		    QUIT;
		    bv = BLOCKVECTOR (s);
		    block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
		    ada_add_block_symbols (block,
					   SYMBOL_NAME (msymbol),
					   namespace, objfile, wild_match);
		    if (ndefns == old_ndefns)
		      {
			block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
			ada_add_block_symbols (block,
					       SYMBOL_NAME (msymbol),
					       namespace, objfile,
					       wild_match);
		      }
		  }
	      }
	  }
      }
d3704 1
a3704 1

d3706 14
a3719 14
  {
    QUIT;
    if (!ps->readin
	&& ada_lookup_partial_symbol (ps, name, 1, namespace, wild_match))
      {
	s = PSYMTAB_TO_SYMTAB (ps);
	if (!s->primary)
	  continue;
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	ada_add_block_symbols (block, name, namespace, objfile, wild_match);
      }
  }

d3723 1
a3723 1

d3728 9
a3736 9
      {
	QUIT;
	if (!s->primary)
	  continue;
	bv = BLOCKVECTOR (s);
	block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	ada_add_block_symbols (block, name, namespace, objfile, wild_match);
      }

d3738 15
a3752 15
      {
	QUIT;
	if (!ps->readin
	    && ada_lookup_partial_symbol (ps, name, 0, namespace, wild_match))
	  {
	    s = PSYMTAB_TO_SYMTAB (ps);
	    bv = BLOCKVECTOR (s);
	    if (!s->primary)
	      continue;
	    block = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	    ada_add_block_symbols (block, name, namespace,
				   objfile, wild_match);
	  }
      }
    }
d3757 1
a3757 1
  if (ndefns == 0)
d3764 1
a3764 1
done:
d3782 2
a3783 3
struct symbol *
ada_lookup_symbol (const char *name, struct block *block0,
		   namespace_enum namespace)
d3785 2
a3786 2
  struct symbol **candidate_syms;
  struct block **candidate_blocks;
d3810 1
a3810 1
is_name_suffix (const char *str)
d3816 1
a3816 1
      while (str[0] != '_' && str[0] != '\0')
d3821 1
a3821 1
	}
d3825 1
a3825 1
  if (str[0] == '_')
d3829 1
a3829 1
      if (str[2] == '_')
d3831 1
a3831 1
	  if (STREQ (str + 3, "LJM"))
d3856 1
a3856 1

d3860 1
a3860 1
 * true). */
d3862 1
a3862 1
wild_match (const char *patn, int patn_len, const char *name)
d3868 3
a3870 3
  if (name_len >= patn_len + 5 && STREQN (name, "_ada_", 5)
      && STREQN (patn, name + 5, patn_len)
      && is_name_suffix (name + patn_len + 5))
d3873 1
a3873 1
  while (name_len >= patn_len)
d3875 2
a3876 1
      if (STREQN (patn, name, patn_len) && is_name_suffix (name + patn_len))
d3878 4
a3881 7
      do
	{
	  name += 1;
	  name_len -= 1;
	}
      while (name_len > 0
	     && name[0] != '.' && (name[0] != '_' || name[1] != '_'));
d3886 1
a3886 1
	  if (!islower (name[2]))
d3888 1
a3888 2
	  name += 2;
	  name_len -= 2;
d3892 1
a3892 1
	  if (!islower (name[1]))
d3894 1
a3894 2
	  name += 1;
	  name_len -= 1;
d3908 3
a3910 3
static void
ada_add_block_symbols (struct block *block, const char *name,
		       namespace_enum namespace, struct objfile *objfile,
d3922 1
a3922 2
  arg_sym = NULL;
  found_sym = 0;
d3927 24
a3950 24
      {
	if (SYMBOL_NAMESPACE (sym) == namespace &&
	    wild_match (name, name_len, SYMBOL_NAME (sym)))
	  {
	    switch (SYMBOL_CLASS (sym))
	      {
	      case LOC_ARG:
	      case LOC_LOCAL_ARG:
	      case LOC_REF_ARG:
	      case LOC_REGPARM:
	      case LOC_REGPARM_ADDR:
	      case LOC_BASEREG_ARG:
		arg_sym = sym;
		break;
	      case LOC_UNRESOLVED:
		continue;
	      default:
		found_sym = 1;
		fill_in_ada_prototype (sym);
		add_defn_to_vec (fixup_symbol_section (sym, objfile), block);
		break;
	      }
	  }
      }
d3952 1
a3952 1
  else
d3957 2
a3958 3
	  i = 0;
	  U = BLOCK_NSYMS (block) - 1;
	  while (U - i > 4)
d3960 1
a3960 1
	      int M = (U + i) >> 1;
d3963 1
a3963 1
		i = M + 1;
d3965 1
a3965 1
		U = M - 1;
d3967 1
a3967 1
		i = M + 1;
d3982 1
a3982 1
		if (cmp < 0)
d3990 2
a3991 2
		else if (cmp == 0
			 && is_name_suffix (SYMBOL_NAME (sym) + name_len))
d4017 1
a4017 1
  if (!found_sym && arg_sym != NULL)
d4023 1
a4023 1
  if (!wild)
d4025 1
a4025 2
      arg_sym = NULL;
      found_sym = 0;
d4029 2
a4030 3
	  i = 0;
	  U = BLOCK_NSYMS (block) - 1;
	  while (U - i > 4)
d4032 1
a4032 1
	      int M = (U + i) >> 1;
d4035 1
a4035 1
		i = M + 1;
d4037 1
a4037 1
		U = M - 1;
d4039 1
a4039 1
		i = M + 1;
d4057 1
a4057 1
		if (cmp == 0)
d4064 1
a4064 1
		if (cmp < 0)
d4072 2
a4073 2
		else if (cmp == 0
			 && is_name_suffix (SYMBOL_NAME (sym) + name_len + 5))
d4097 1
a4097 1

d4099 2
a4100 2
         They aren't parameters, right? */
      if (!found_sym && arg_sym != NULL)
d4107 1
a4108 1

d4115 1
a4115 1
fill_in_ada_prototype (struct symbol *func)
d4117 1
a4117 1
  struct block *b;
d4120 2
a4121 2
  struct type *ftype;
  struct type *rtype;
d4142 3
a4144 3
  max_fields = 8;
  TYPE_FIELDS (ftype) =
    (struct field *) xmalloc (sizeof (struct field) * max_fields);
d4146 15
a4160 2
  {
    GROW_VECT (TYPE_FIELDS (ftype), max_fields, nargs + 1);
d4162 11
a4172 10
    switch (SYMBOL_CLASS (sym))
      {
      case LOC_REF_ARG:
      case LOC_REGPARM_ADDR:
	TYPE_FIELD_BITPOS (ftype, nargs) = nargs;
	TYPE_FIELD_BITSIZE (ftype, nargs) = 0;
	TYPE_FIELD_TYPE (ftype, nargs) =
	  lookup_pointer_type (check_typedef (SYMBOL_TYPE (sym)));
	TYPE_FIELD_NAME (ftype, nargs) = SYMBOL_NAME (sym);
	nargs += 1;
d4174 4
a4177 18
	break;

      case LOC_ARG:
      case LOC_REGPARM:
      case LOC_LOCAL_ARG:
      case LOC_BASEREG_ARG:
	TYPE_FIELD_BITPOS (ftype, nargs) = nargs;
	TYPE_FIELD_BITSIZE (ftype, nargs) = 0;
	TYPE_FIELD_TYPE (ftype, nargs) = check_typedef (SYMBOL_TYPE (sym));
	TYPE_FIELD_NAME (ftype, nargs) = SYMBOL_NAME (sym);
	nargs += 1;

	break;

      default:
	break;
      }
  }
d4186 1
a4186 1
      static struct field dummy_field = { 0, 0, 0, 0 };
d4192 5
a4196 4
      struct field *fields =
	(struct field *) TYPE_ALLOC (ftype, nargs * sizeof (struct field));
      memcpy ((char *) fields,
	      (char *) TYPE_FIELDS (ftype), nargs * sizeof (struct field));
d4201 1
a4202 1

d4205 1
a4205 2
char no_symtab_msg[] =
  "No symbol table is loaded.  Use the \"file\" command.";
d4211 2
a4212 2
char *
ada_start_decode_line_1 (char *line)
d4216 1
a4216 1
  char *p;
d4266 2
a4267 2
ada_finish_decode_line_1 (char **spec, struct symtab *file_table,
			  int funfirstline, char ***canonical)
d4269 3
a4271 3
  struct symbol **symbols;
  struct block **blocks;
  struct block *block;
d4274 2
a4275 2
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  char *name;
d4278 2
a4279 2
  char *lower_name;
  char *unquoted_name;
d4287 1
a4287 1
    *canonical = (char **) NULL;
d4290 1
a4290 1
  if (**spec == '*')
d4294 2
a4295 2
      while (**spec != '\000' &&
	     !strchr (ada_completer_word_break_characters, **spec))
d4304 1
a4304 1
      while (**spec == ' ' || **spec == '\t')
d4308 1
a4308 1
  if (name[0] == '*')
d4324 3
a4326 3
      unquoted_name = (char *) alloca (len - 1);
      memcpy (unquoted_name, name + 1, len - 2);
      unquoted_name[len - 2] = '\000';
d4331 1
a4331 1
      unquoted_name = (char *) alloca (len + 1);
d4334 1
a4334 1
      lower_name = (char *) alloca (len + 1);
d4341 2
a4342 2
  if (lower_name != NULL)
    n_matches = ada_lookup_symbol_list (ada_mangle (lower_name), block,
d4345 1
a4345 1
    n_matches = ada_lookup_symbol_list (unquoted_name, block,
d4355 1
a4355 1
#define volatile		/*nothing */
d4359 1
a4359 1
      struct minimal_symbol *msymbol;
d4364 1
a4364 1
      if (lower_name != NULL)
d4370 1
a4370 1
	  val.pc = SYMBOL_VALUE_ADDRESS (msymbol);
d4382 2
a4383 2
	}

d4389 1
a4389 1
      return selected;		/* for lint */
d4394 2
a4395 2
      return
	find_sal_from_funcs_and_line (file_table->filename, line_num,
d4400 1
a4400 2
      selected.nelts =
	user_select_syms (symbols, blocks, n_matches, n_matches);
d4403 1
a4403 1
  selected.sals = (struct symtab_and_line *)
d4411 1
a4411 1
      if (SYMBOL_CLASS (symbols[i]) == LOC_BLOCK)
d4413 1
a4413 1
      else if (SYMBOL_LINE (symbols[i]) != 0)
d4421 2
a4422 2
	  symbols[i] = symbols[selected.nelts - 1];
	  blocks[i] = blocks[selected.nelts - 1];
d4426 1
a4426 1
      else
d4433 1
a4433 1
      *canonical = (char **) xmalloc (sizeof (char *) * selected.nelts);
d4435 2
a4436 2
	(*canonical)[i] =
	  extended_canonical_line_spec (selected.sals[i],
d4439 1
a4439 1

d4442 2
a4443 2
}

d4446 1
a4446 1
   in SYMBOLS[0 .. NSYMS-1]. */
d4448 2
a4449 2
find_sal_from_funcs_and_line (const char *filename, int line_num,
			      struct symbol **symbols, int nsyms)
d4453 4
a4456 4
  struct linetable *best_linetable;
  struct objfile *objfile;
  struct symtab *s;
  struct symtab *best_symtab;
d4460 1
a4460 3
  best_index = 0;
  best_linetable = NULL;
  best_symtab = NULL;
d4463 3
a4465 3
  {
    struct linetable *l;
    int ind, exact;
d4467 1
a4467 1
    QUIT;
d4469 22
a4490 22
    if (!STREQ (filename, s->filename))
      continue;
    l = LINETABLE (s);
    ind = find_line_in_linetable (l, line_num, symbols, nsyms, &exact);
    if (ind >= 0)
      {
	if (exact)
	  {
	    best_index = ind;
	    best_linetable = l;
	    best_symtab = s;
	    goto done;
	  }
	if (best == 0 || l->item[ind].line < best)
	  {
	    best = l->item[ind].line;
	    best_index = ind;
	    best_linetable = l;
	    best_symtab = s;
	  }
      }
  }
d4495 2
a4496 2
done:

d4498 1
a4498 1
  sals.sals = (struct symtab_and_line *) xmalloc (sizeof (sals.sals[0]));
d4501 1
a4501 1

d4513 2
a4514 2
find_line_in_linetable (struct linetable *linetable, int line_num,
			struct symbol **symbols, int nsyms, int *exactp)
d4525 1
a4525 1
      struct linetable_entry *item = &(linetable->item[i]);
d4559 1
a4559 1
nearest_line_number_in_linetable (struct linetable *linetable, int line_num)
d4567 1
a4567 2
  i = 0;
  best = INT_MAX;
d4571 1
a4571 1
      struct linetable_entry *item = &(linetable->item[i]);
d4575 1
a4575 1
	  char *func_name;
d4585 1
a4585 1
	      else
d4587 1
a4587 1
		  struct symbol *sym =
d4618 1
a4618 1
find_next_line_in_linetable (struct linetable *linetable, int line_num,
d4627 1
a4627 1
  if (ind >= 0)
d4632 1
a4632 1
				    (char **) NULL, &start, &end))
d4647 1
a4647 1
      struct linetable_entry *item = &(linetable->item[i]);
d4651 1
a4651 1
	  char *func_name;
d4661 1
a4661 1
		  struct symbol *sym =
d4667 1
a4667 1
		      while ((i + 1) < len && linetable->item[i + 1].pc < end)
d4682 1
a4682 1
is_plausible_func_for_line (struct symbol *sym, int line_num)
d4695 1
a4695 1
debug_print_lines (struct linetable *lt)
d4699 1
a4699 1
  if (lt == NULL)
d4709 1
a4709 1
debug_print_block (struct block *b)
d4714 4
a4717 4
  fprintf (stderr, "Block: %p; [0x%lx, 0x%lx]",
	   b, BLOCK_START (b), BLOCK_END (b));
  if (BLOCK_FUNCTION (b) != NULL)
    fprintf (stderr, " Function: %s", SYMBOL_NAME (BLOCK_FUNCTION (b)));
d4719 1
a4719 1
  fprintf (stderr, "\t    Superblock: %p\n", BLOCK_SUPERBLOCK (b));
d4722 5
a4726 5
  {
    if (i > 0 && i % 4 == 0)
      fprintf (stderr, "\n\t\t    ");
    fprintf (stderr, " %s", SYMBOL_NAME (sym));
  }
d4731 1
a4731 1
debug_print_blocks (struct blockvector *bv)
d4737 4
a4740 5
  for (i = 0; i < BLOCKVECTOR_NBLOCKS (bv); i += 1)
    {
      fprintf (stderr, "%6d. ", i);
      debug_print_block (BLOCKVECTOR_BLOCK (bv, i));
    }
d4744 1
a4744 1
debug_print_symtab (struct symtab *s)
d4749 2
a4750 2
	   BLOCKVECTOR (s), s->primary);
  debug_print_blocks (BLOCKVECTOR (s));
d4752 1
a4752 1
  debug_print_lines (LINETABLE (s));
d4758 1
a4758 1
read_all_symtabs (const char *filename)
d4760 2
a4761 2
  struct partial_symtab *ps;
  struct objfile *objfile;
d4764 2
a4765 2
  {
    QUIT;
d4767 3
a4769 3
    if (STREQ (filename, ps->filename))
      PSYMTAB_TO_SYMTAB (ps);
  }
d4776 1
a4776 1
all_sals_for_line (const char *filename, int line_num, char ***canonical)
d4779 3
a4781 3
  struct objfile *objfile;
  struct symtab *s;
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
d4786 1
a4786 2
  result.sals =
    (struct symtab_and_line *) xmalloc (4 * sizeof (result.sals[0]));
d4791 3
a4793 3
  ALL_SYMTABS (objfile, s)
  {
    int ind, target_line_num;
d4795 1
a4795 1
    QUIT;
d4797 2
a4798 2
    if (!STREQ (s->filename, filename))
      continue;
d4800 4
a4803 4
    target_line_num =
      nearest_line_number_in_linetable (LINETABLE (s), line_num);
    if (target_line_num == -1)
      continue;
d4805 9
a4813 6
    ind = -1;
    while (1)
      {
	ind =
	  find_next_line_in_linetable (LINETABLE (s),
				       target_line_num, line_num, ind);
d4815 8
a4822 11
	if (ind < 0)
	  break;

	GROW_VECT (result.sals, len, result.nelts + 1);
	INIT_SAL (&result.sals[result.nelts]);
	result.sals[result.nelts].line = LINETABLE (s)->item[ind].line;
	result.sals[result.nelts].pc = LINETABLE (s)->item[ind].pc;
	result.sals[result.nelts].symtab = s;
	result.nelts += 1;
      }
  }
d4827 1
a4827 1
      char **func_names = (char **) alloca (result.nelts * sizeof (char *));
d4830 3
a4832 3
      int *choices = (int *) alloca (result.nelts * sizeof (int));

      for (k = 0; k < result.nelts; k += 1)
d4834 2
a4835 2
	  find_pc_partial_function (result.sals[k].pc, &func_names[k],
				    (CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
d4839 2
a4840 2

      if (result.nelts > 1)
d4842 3
a4844 3
	  printf_unfiltered ("[0] cancel\n");
	  if (result.nelts > 1)
	    printf_unfiltered ("[1] all\n");
d4846 1
a4846 1
	    printf_unfiltered ("[%d] %s\n", k + first_choice,
d4848 1
a4848 1

d4851 2
a4852 2

	  for (k = 0; k < n; k += 1)
d4860 1
a4860 1
      if (canonical != NULL)
d4862 1
a4862 1
	  *canonical = (char **) xmalloc (result.nelts * sizeof (char **));
d4864 1
a4864 1
	  for (k = 0; k < result.nelts; k += 1)
d4866 1
a4866 1
	      (*canonical)[k] =
d4885 2
a4886 2
static char *
extended_canonical_line_spec (struct symtab_and_line sal, const char *name)
d4888 1
a4888 1
  char *r;
d4890 2
a4891 1
  if (sal.symtab == NULL || sal.symtab->filename == NULL || sal.line <= 0)
d4894 2
a4895 2
  r = (char *) xmalloc (strlen (name) + strlen (sal.symtab->filename)
			+ sizeof (sal.line) * 3 + 3);
d4905 2
a4906 2
static void
begin_cleanup (void *dummy)
d4917 1
a4917 1
  struct cleanup *old_chain = make_cleanup (begin_cleanup, NULL);
d4923 1
a4923 1

d4926 2
a4927 2
     error ("Cannot find the Ada initialization procedure.  Is this an Ada main program?");
   */
d4934 12
a4945 12
    {
      main_program_name_addr = SYMBOL_VALUE_ADDRESS (msym);
      if (main_program_name_addr == 0)
	error ("Invalid address for Ada main program name.");

      /* Read the name of the main procedure */
      extract_string (main_program_name_addr, main_program_name);

      /* Put a temporary breakpoint in the Ada main program and run */
      do_command ("tbreak ", main_program_name, 0);
      do_command ("run ", args, 0);
    }
d4947 22
a4968 22
    {
      /* If we could not find the symbol containing the name of the
         main program, that means that the compiler that was used to build
         was not recent enough. In that case, we fallback to the previous
         mechanism, which is a little bit less reliable, but has proved to work
         in most cases. The only cases where it will fail is when the user
         has set some breakpoints which will be hit before the end of the
         begin command processing (eg in the initialization code).

         The begining of the main Ada subprogram is located by breaking
         on the adainit procedure. Since we know that the binder generates
         the call to this procedure exactly 2 calls before the call to the
         Ada main subprogram, it is then easy to put a breakpoint on this
         Ada main subprogram once we hit adainit.
       */
      do_command ("tbreak adainit", 0);
      do_command ("run ", args, 0);
      do_command ("up", 0);
      do_command ("tbreak +2", 0);
      do_command ("continue", 0);
      do_command ("step", 0);
    }
d4978 2
a4979 1
	  STREQN (filename, "g-", 2) || STREQN (filename, "i-", 2));
d4989 1
a4989 1

d4993 5
a4997 5
         points to *after* the call instruction, and we want to get the line
         containing the call, never the next line.  But if the next frame is
         a signal_handler_caller or a dummy frame, then the next frame was
         not entered as the result of a call, and we want to get the line
         containing fi->pc.  */
d4999 1
a4999 1
	find_pc_line (fi->pc,
d5006 2
a5007 2
	  /* libpthread.so contains some debugging information that prevents us
	     from finding the right frame */
d5011 1
a5011 1
	    continue;
d5027 35
a5061 35
     {
     /* Assume that cond has 16 elements, the 15th
   being the exception *//*
   if (b->cond && b->cond->nelts == 16)
   {
   ui_out_text (uiout, "on ");
   ui_out_field_string (uiout, "exception",
   SYMBOL_NAME (b->cond->elts[14].symbol));
   }
   else
   ui_out_text (uiout, "on all exceptions");
   }
   else if (b->break_on_exception == 2)
   ui_out_text (uiout, "on unhandled exception");
   else if (b->break_on_exception == 3)
   ui_out_text (uiout, "on assert failure");
   #else
   if (b->break_on_exception == 1)
   { */
  /* Assume that cond has 16 elements, the 15th
   being the exception *//*
   if (b->cond && b->cond->nelts == 16)
   {
   fputs_filtered ("on ", gdb_stdout);
   fputs_filtered (SYMBOL_NAME
   (b->cond->elts[14].symbol), gdb_stdout);
   }
   else
   fputs_filtered ("on all exceptions", gdb_stdout);
   }
   else if (b->break_on_exception == 2)
   fputs_filtered ("on unhandled exception", gdb_stdout);
   else if (b->break_on_exception == 3)
   fputs_filtered ("on assert failure", gdb_stdout);
 */
d5066 1
a5066 1
ada_is_exception_sym (struct symbol *sym)
d5069 1
a5069 1

d5073 2
a5074 1
	  && type_name != NULL && STREQ (type_name, "exception"));
d5078 1
a5078 1
ada_maybe_exception_partial_symbol (struct partial_symbol *sym)
d5089 1
a5089 2
char *
ada_breakpoint_rewrite (char *arg, int *break_on_exceptionp)
d5094 1
a5094 1
  /* FIXME: language_ada should be defined in defs.h */
d5096 52
a5147 52
     && STREQN (arg, "exception", 9) &&
     (arg[9] == ' ' || arg[9] == '\t' || arg[9] == '\0'))
     {
     char *tok, *end_tok;
     int toklen;

     *break_on_exceptionp = 1;

     tok = arg+9;
     while (*tok == ' ' || *tok == '\t')
     tok += 1;

     end_tok = tok;

     while (*end_tok != ' ' && *end_tok != '\t' && *end_tok != '\000')
     end_tok += 1;

     toklen = end_tok - tok;

     arg = (char*) xmalloc (sizeof ("__gnat_raise_nodefer_with_msg if "
     "long_integer(e) = long_integer(&)")
     + toklen + 1);
     make_cleanup (xfree, arg);
     if (toklen == 0)
     strcpy (arg, "__gnat_raise_nodefer_with_msg");
     else if (STREQN (tok, "unhandled", toklen))
     {
     *break_on_exceptionp = 2;
     strcpy (arg, "__gnat_unhandled_exception");
     }
     else
     {
     sprintf (arg, "__gnat_raise_nodefer_with_msg if "
     "long_integer(e) = long_integer(&%.*s)", 
     toklen, tok);
     }
     }
     else if (current_language->la_language == language_ada
     && STREQN (arg, "assert", 6) &&
     (arg[6] == ' ' || arg[6] == '\t' || arg[6] == '\0'))
     {
     char *tok = arg + 6;

     *break_on_exceptionp = 3;

     arg = (char*) 
     xmalloc (sizeof ("system__assertions__raise_assert_failure")
     + strlen (tok) + 1);
     make_cleanup (xfree, arg);
     sprintf (arg, "system__assertions__raise_assert_failure%s", tok);
     }
   */
d5150 1
a5151 1

d5162 1
a5162 1
  else
d5164 1
a5164 1
      const char *name = TYPE_FIELD_NAME (type, field_num);
d5166 1
a5166 1
	      || (name[0] == '_' && !STREQN (name, "_parent", 7)));
d5183 2
a5184 2
struct type *
ada_tag_type (struct value *val)
d5191 2
a5192 2
struct value *
ada_value_tag (struct value *val)
d5199 1
a5199 1
struct type *
d5223 2
a5224 2
  const char *name = TYPE_FIELD_NAME (check_typedef (type), field_num);
  return (name != NULL &&
d5237 3
a5239 3
  const char *name = TYPE_FIELD_NAME (type, field_num);
  return (name != NULL
	  && (STREQN (name, "PARENT", 6) || STREQ (name, "REP")
d5246 1
a5246 1
   FIELD_NUM+1 fields. */
d5251 1
a5251 1
  struct type *field_type = TYPE_FIELD_TYPE (type, field_num);
d5254 1
a5254 2
	      && TYPE_CODE (TYPE_TARGET_TYPE (field_type)) ==
	      TYPE_CODE_UNION));
d5261 1
a5261 1
struct type *
d5264 3
a5266 2
  char *name = ada_variant_discrim_name (var_type);
  struct type *type = ada_lookup_struct_elt_type (outer_type, name, 1, NULL);
d5280 1
a5280 1
  const char *name = TYPE_FIELD_NAME (type, field_num);
d5288 1
a5288 1
char *
d5291 1
a5291 1
  static char *result = NULL;
d5293 4
a5296 4
  struct type *type;
  const char *name;
  const char *discrim_end;
  const char *discrim_start;
d5317 1
a5317 1
  for (discrim_start = discrim_end; discrim_start != name + 3;
d5320 1
a5320 1
      if (discrim_start == name + 1)
d5322 1
a5322 1
      if ((discrim_start > name + 3 && STREQN (discrim_start - 3, "___", 3))
d5329 1
a5329 1
  result[discrim_end - discrim_start] = '\0';
d5342 1
a5342 1
ada_scan_number (const char str[], int k, LONGEST * R, int *new_k)
d5346 1
a5346 1
  if (!isdigit (str[k]))
d5355 1
a5355 1
      RU = RU * 10 + (str[k] - '0');
d5359 1
a5359 1
  if (str[k] == 'm')
d5362 1
a5362 1
	*R = (-(LONGEST) (RU - 1)) - 1;
d5383 1
a5383 1
int
d5386 1
a5386 1
  const char *name = TYPE_FIELD_NAME (type, field_num);
d5392 1
a5392 1
      switch (name[p])
d5399 1
a5399 1
	    if (!ada_scan_number (name, p + 1, &W, &p))
d5408 3
a5410 2
	    if (!ada_scan_number (name, p + 1, &L, &p)
		|| name[p] != 'T' || !ada_scan_number (name, p + 1, &U, &p))
d5430 2
a5431 2
struct value *
ada_value_primitive_field (struct value *arg1, int offset, int fieldno,
d5434 1
a5434 1
  struct value *v;
d5446 1
a5446 1

d5448 2
a5449 2
					     offset + bit_pos / 8,
					     bit_pos % 8, bit_size, type);
d5462 2
a5463 2
struct value *
ada_search_struct_field (char *name, struct value *arg, int offset,
d5469 1
a5469 1
  for (i = TYPE_NFIELDS (type) - 1; i >= 0; i -= 1)
d5477 1
a5477 1
	return ada_value_primitive_field (arg, offset, i, type);
d5481 4
a5484 7
	  struct value *v = ada_search_struct_field (name, arg,
						     offset +
						     TYPE_FIELD_BITPOS (type,
									i) /
						     8,
						     TYPE_FIELD_TYPE (type,
								      i));
d5497 5
a5501 7
	      struct value *v = ada_search_struct_field (name, arg,
							 var_offset
							 +
							 TYPE_FIELD_BITPOS
							 (field_type, j) / 8,
							 TYPE_FIELD_TYPE
							 (field_type, j));
d5509 1
a5509 1

d5521 1
a5521 1
struct value *
d5525 1
a5525 1
  struct value *v;
d5538 3
a5540 3
  if (TYPE_CODE (t) != TYPE_CODE_STRUCT && TYPE_CODE (t) != TYPE_CODE_UNION)
    error ("Attempt to extract a component of a value that is not a %s.",
	   err);
d5566 1
a5566 2
ada_lookup_struct_elt_type (struct type *type, char *name, int noerr,
			    int *dispp)
d5599 1
a5599 1

d5605 1
a5605 1
	  if (dispp != NULL)
d5613 1
a5613 1
	  t = ada_lookup_struct_elt_type (TYPE_FIELD_TYPE (type, i), name,
d5635 1
a5635 1
		  if (dispp != NULL)
d5645 1
a5645 1
  if (!noerr)
d5663 1
a5663 1
int
d5665 1
a5665 1
			   char *outer_valaddr)
d5670 2
a5671 2
  struct type *discrim_type;
  char *discrim_name = ada_variant_discrim_name (var_type);
d5675 1
a5675 1
  discrim_type =
a5691 1

d5694 1
d5734 2
a5735 2
struct value *
ada_value_ind (struct value *val0)
d5737 1
a5737 1
  struct value *val = unwrap_value (value_ind (val0));
d5739 2
a5740 1
			     VALUE_ADDRESS (val) + VALUE_OFFSET (val), val);
d5745 2
a5746 2
static struct value *
ada_coerce_ref (struct value *val0)
d5748 8
a5755 10
  if (TYPE_CODE (VALUE_TYPE (val0)) == TYPE_CODE_REF)
    {
      struct value *val = val0;
      COERCE_REF (val);
      val = unwrap_value (val);
      return ada_to_fixed_value (VALUE_TYPE (val), 0,
				 VALUE_ADDRESS (val) + VALUE_OFFSET (val),
				 val);
    }
  else
d5788 1
a5788 1
  const char *name = TYPE_FIELD_NAME (type, f);
d5792 1
a5792 1
  if (len < 8 || !isdigit (name[len - 1]))
d5795 1
a5795 1
  if (isdigit (name[len - 2]))
d5800 1
a5800 1
  if (align_offset < 7 || !STREQN ("___XV", name + align_offset - 6, 5))
d5803 1
a5803 1
  return atoi (name + align_offset) * TARGET_CHAR_BIT;
d5807 1
a5807 1
struct type *
d5810 1
a5810 1
  struct symbol *sym;
d5828 1
a5828 1
ada_prefer_type (struct type *type0, struct type *type1)
d5840 1
a5840 2
  else if (ada_is_array_descriptor (type0)
	   && !ada_is_array_descriptor (type1))
d5842 1
a5842 1
  else if (ada_renaming_type (type0) != NULL
d5850 2
a5851 2
char *
ada_type_name (struct type *type)
d5853 1
a5853 1
  if (type == NULL)
d5864 1
a5864 1
struct type *
d5867 1
a5867 1
  static char *name;
d5869 2
a5870 2
  struct symbol **syms;
  struct block **blocks;
d5873 2
a5874 2
  char *typename = ada_type_name (type);

d5880 1
a5880 1
  GROW_VECT (name, name_len, len + strlen (suffix) + 1);
d5892 2
a5893 2
static struct type *
dynamic_template_type (struct type *type)
d5898 1
a5898 1
      || ada_type_name (type) == NULL)
d5900 1
a5900 1
  else
d5913 2
a5914 2
static int
is_dynamic_field (struct type *templ_type, int field_num)
d5917 1
a5917 1
  return name != NULL
d5925 2
a5926 2
static int
contains_variant_part (struct type *type)
d5937 2
a5938 2
static struct type *
empty_record (struct objfile *objfile)
d5940 1
a5940 1
  struct type *type = alloc_type (objfile);
d5963 7
a5969 7
static struct type *
template_to_fixed_record_type (struct type *type, char *valaddr,
			       CORE_ADDR address, struct value *dval0)
{
  struct value *mark = value_mark ();
  struct value *dval;
  struct type *rtype;
d5979 1
a5979 1
  TYPE_FIELDS (rtype) = (struct field *)
d5985 2
a5986 2
     gdbtypes.h */
  /*  TYPE_FLAGS (rtype) |= TYPE_FLAG_FIXED_INSTANCE; */
d5988 1
a5988 2
  off = 0;
  bit_len = 0;
d5992 2
a5993 3
      off =
	align_value (off,
		     field_alignment (type, f)) + TYPE_FIELD_BITPOS (type, f);
d5998 1
a5998 1
      TYPE_FIELD_BITSIZE (rtype, f) = 0;
d6000 1
a6000 1
      if (ada_is_variant_part (type, f))
d6005 2
a6006 1
	    dval = value_from_contents_and_address (rtype, valaddr, address);
d6010 7
a6016 6
	  branch_type =
	    to_fixed_variant_branch_type
	    (TYPE_FIELD_TYPE (type, f),
	     cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
	     cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
	  if (branch_type == NULL)
d6030 2
a6031 1
	    dval = value_from_contents_and_address (rtype, valaddr, address);
d6035 7
a6041 6
	  TYPE_FIELD_TYPE (rtype, f) =
	    ada_to_fixed_type
	    (ada_get_base_type
	     (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, f))),
	     cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
	     cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
d6051 1
a6051 1
	    bit_incr = fld_bit_len =
d6065 1
a6065 1
  if (TYPE_LENGTH (rtype) > varsize_limit)
d6077 2
a6078 2
static struct type *
template_to_static_fixed_type (struct type *templ_type)
d6088 1
a6088 2
  TYPE_TARGET_TYPE (templ_type) = type =
    alloc_type (TYPE_OBJFILE (templ_type));
d6092 1
a6092 1
  TYPE_FIELDS (type) = (struct field *)
d6097 1
a6097 1
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
d6104 1
a6104 1
      TYPE_FIELD_BITSIZE (type, f) = 0;
d6108 2
a6109 2
	  TYPE_FIELD_TYPE (type, f) =
	    to_static_fixed_type (TYPE_TARGET_TYPE
d6115 1
a6115 1
	  TYPE_FIELD_TYPE (type, f) =
d6127 3
a6129 3
static struct type *
to_record_with_fixed_variant_part (struct type *type, char *valaddr,
				   CORE_ADDR address, struct value *dval)
d6131 2
a6132 2
  struct value *mark = value_mark ();
  struct type *rtype;
d6143 3
a6145 3
  TYPE_FIELDS (rtype) =
    (struct field *) TYPE_ALLOC (rtype, nfields * sizeof (struct field));
  memcpy (TYPE_FIELDS (rtype), TYPE_FIELDS (type),
d6149 1
a6149 1
  /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
d6153 9
a6161 11
  branch_type =
    to_fixed_variant_branch_type
    (TYPE_FIELD_TYPE (type, nfields - 1),
     cond_offset_host (valaddr,
		       TYPE_FIELD_BITPOS (type,
					  nfields - 1) / TARGET_CHAR_BIT),
     cond_offset_target (address,
			 TYPE_FIELD_BITPOS (type,
					    nfields - 1) / TARGET_CHAR_BIT),
     dval);
  if (branch_type == NULL)
d6164 1
a6164 2
      TYPE_LENGTH (rtype) -=
	TYPE_LENGTH (TYPE_FIELD_TYPE (type, nfields - 1));
d6168 3
a6170 3
      TYPE_FIELD_TYPE (rtype, nfields - 1) = branch_type;
      TYPE_FIELD_NAME (rtype, nfields - 1) = "S";
      TYPE_FIELD_BITSIZE (rtype, nfields - 1) = 0;
d6172 1
a6172 1
      -TYPE_LENGTH (TYPE_FIELD_TYPE (type, nfields - 1));
d6174 1
a6174 1

d6184 1
a6184 1
   of the variant. */
d6186 3
a6188 3
static struct type *
to_fixed_record_type (struct type *type0, char *valaddr, CORE_ADDR address,
		      struct value *dval)
d6190 1
a6190 1
  struct type *templ_type;
d6194 3
a6196 3
     return type0;
   */
  templ_type = dynamic_template_type (type0);
d6204 1
a6204 1
      /* FIXME:  TYPE_FLAG_FIXED_INSTANCE should be defined in gdbtypes.h */
d6218 3
a6220 3
static struct type *
to_fixed_variant_branch_type (struct type *var_type0, char *valaddr,
			      CORE_ADDR address, struct value *dval)
d6223 2
a6224 2
  struct type *templ_type;
  struct type *var_type;
d6228 1
a6228 1
  else
d6236 2
a6237 2
  which =
    ada_which_variant_applies (var_type,
d6243 4
a6246 4
    return
      to_fixed_record_type
      (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (var_type, which)),
       valaddr, address, dval);
d6248 3
a6250 3
    return
      to_fixed_record_type
      (TYPE_FIELD_TYPE (var_type, which), valaddr, address, dval);
d6264 2
a6265 2
static struct type *
to_fixed_array_type (struct type *type0, struct value *dval,
d6268 2
a6269 2
  struct type *index_type_desc;
  struct type *result;
d6272 3
a6274 3
/*  if (ada_is_packed_array_type (type0)  /* revisit? *//*
   || (TYPE_FLAGS (type0) & TYPE_FLAG_FIXED_INSTANCE))
   return type0; */
d6282 3
a6284 2
       * debugging data. */
      struct type *elt_type = ada_to_fixed_type (elt_type0, 0, 0, dval);
d6289 1
a6289 1
	result = create_array_type (alloc_type (TYPE_OBJFILE (type0)),
d6303 3
a6305 2
       * debugging data. */
      result = ada_to_fixed_type (check_typedef (elt_type0), 0, 0, dval);
d6308 1
a6308 1
	  struct type *range_type =
d6314 1
a6314 1
      if (!ignore_too_big && TYPE_LENGTH (result) > varsize_limit)
d6321 1
a6321 1
}
d6329 3
a6331 3
struct type *
ada_to_fixed_type (struct type *type, char *valaddr, CORE_ADDR address,
		   struct value *dval)
d6334 9
a6342 3
  switch (TYPE_CODE (type))
    {
    default:
d6344 3
a6346 10
    case TYPE_CODE_STRUCT:
      return to_fixed_record_type (type, valaddr, address, NULL);
    case TYPE_CODE_ARRAY:
      return to_fixed_array_type (type, dval, 0);
    case TYPE_CODE_UNION:
      if (dval == NULL)
	return type;
      else
	return to_fixed_variant_branch_type (type, valaddr, address, dval);
    }
d6352 2
a6353 2
static struct type *
to_static_fixed_type (struct type *type0)
d6355 1
a6355 1
  struct type *type;
d6362 2
a6363 2
     return type0;
   */
d6365 1
a6365 1

d6372 1
a6372 1
      if (type != NULL)
d6384 2
a6385 2
static struct type *
static_unwrap_type (struct type *type)
d6389 1
a6389 1
      struct type *type1 = TYPE_FIELD_TYPE (check_typedef (type), 0);
d6395 1
a6395 1
  else
d6397 2
a6398 2
      struct type *raw_real_type = ada_get_base_type (type);
      if (raw_real_type == type)
d6418 2
a6419 2
struct type *
ada_completed_type (struct type *type)
d6426 1
a6426 1
  else
d6428 2
a6429 2
      char *name = TYPE_TAG_NAME (type);
      struct type *type1 = ada_find_any_type (name);
d6438 1
a6438 1
   creation of struct values]. */
d6440 3
a6442 3
struct value *
ada_to_fixed_value (struct type *type0, char *valaddr, CORE_ADDR address,
		    struct value *val0)
d6444 1
a6444 1
  struct type *type = ada_to_fixed_type (type0, valaddr, address, NULL);
d6447 1
a6447 2
  else
    return value_from_contents_and_address (type, valaddr, address);
d6455 2
a6456 2
struct value *
ada_to_static_fixed_value (struct value *val)
d6458 1
a6458 1
  struct type *type =
a6464 1

d6467 1
d6475 1
a6475 1
static const char *attribute_names[] = {
d6478 1
a6478 1
  "first",
d6485 2
a6486 1
  "pos" "tag",
d6492 1
a6492 1
const char *
d6503 2
a6504 2
static struct value *
value_pos_atr (struct value *arg)
d6508 1
a6508 1
  if (!discrete_type_p (type))
d6516 1
a6516 1
      for (i = 0; i < TYPE_NFIELDS (type); i += 1)
d6529 2
a6530 2
static struct value *
value_val_atr (struct type *type, struct value *arg)
d6532 1
a6532 1
  if (!discrete_type_p (type))
d6534 1
a6534 1
  if (!integer_type_p (VALUE_TYPE (arg)))
d6542 2
a6543 1
      return value_from_longest (type, TYPE_FIELD_BITPOS (type, pos));
d6548 1
a6549 1

d6556 2
a6557 2
int
ada_is_character_type (struct type *type)
d6559 2
a6560 2
  const char *name = ada_type_name (type);
  return
d6562 1
a6562 1
    && (TYPE_CODE (type) == TYPE_CODE_CHAR
d6575 1
a6575 1
  if (type != NULL
d6584 1
a6584 1
  else
d6605 2
a6606 2
struct type *
ada_get_base_type (struct type *raw_type)
d6608 3
a6610 3
  struct type *real_type_namer;
  struct type *raw_real_type;
  struct type *real_type;
d6616 1
a6616 1
  if (real_type_namer == NULL
d6622 1
a6622 1
  if (raw_real_type == NULL)
d6626 1
a6626 1
}
d6630 2
a6631 2
struct type *
ada_aligned_type (struct type *type)
d6643 1
a6643 1
char *
d6646 1
a6646 1
  if (ada_is_aligner_type (type))
d6648 2
a6649 3
				   valaddr +
				   TYPE_FIELD_BITPOS (type,
						      0) / TARGET_CHAR_BIT);
d6656 2
a6657 2
const char *
ada_enum_name (const char *name)
d6659 1
a6659 1
  char *tmp;
d6661 1
a6661 1
  while (1)
d6664 1
a6664 1
	name = tmp + 2;
d6666 1
a6666 1
	name = tmp + 1;
d6677 1
a6677 1
	  if (sscanf (name + 2, "%x", &v) != 1)
d6692 1
a6692 1
  else
d6696 1
a6696 1
static struct value *
d6707 2
a6708 2
static struct value *
evaluate_subexp_type (struct expression *exp, int *pos)
d6710 1
a6710 1
  return (*exp->language_defn->evaluate_exp)
d6715 1
a6715 1
   value it wraps. */
d6717 2
a6718 2
static struct value *
unwrap_value (struct value *val)
d6720 1
a6720 1
  struct type *type = check_typedef (VALUE_TYPE (val));
d6723 3
a6725 3
      struct value *v = value_struct_elt (&val, NULL, "F",
					  NULL, "internal structure");
      struct type *val_type = check_typedef (VALUE_TYPE (v));
d6731 1
a6731 1
  else
d6733 1
a6733 1
      struct type *raw_real_type =
d6735 1
a6735 1

d6739 2
a6740 2
      return
	coerce_unspec_val_to_type
d6746 3
a6748 3

static struct value *
cast_to_fixed (struct type *type, struct value *arg)
d6755 1
a6755 1
    val = ada_float_to_fixed (type,
d6758 1
a6758 1
  else
d6760 1
a6760 1
      DOUBLEST argd =
d6768 2
a6769 2
static struct value *
cast_from_fixed_to_double (struct value *arg)
d6778 2
a6779 2
static struct value *
coerce_for_assign (struct type *type, struct value *val)
d6781 1
a6781 1
  struct type *type2 = VALUE_TYPE (val);
d6788 1
a6788 2
  if (TYPE_CODE (type2) == TYPE_CODE_PTR
      && TYPE_CODE (type) == TYPE_CODE_ARRAY)
d6794 1
a6794 1
  if (TYPE_CODE (type2) == TYPE_CODE_ARRAY
d6799 1
a6799 1
	  != TYPE_LENGTH (TYPE_TARGET_TYPE (type2)))
d6803 1
a6803 1
  return val;
d6806 1
a6806 1
struct value *
d6817 1
a6817 1
  struct value **argvec;
d6819 1
a6819 2
  pc = *pos;
  *pos += 1;
d6822 1
a6822 1
  switch (op)
d6826 1
a6826 3
      return
	unwrap_value (evaluate_subexp_standard
		      (expect_type, exp, pos, noside));
d6840 1
a6840 1
	  else if (VALUE_LVAL (arg1) == lval_memory)
d6843 5
a6847 5
	         but apparently expected) case of (Foo) Bar.all, where Bar 
	         is an integer constant and Foo is a dynamic-sized type.
	         If we don't do this, ARG1 will simply be relabeled with
	         TYPE. */
	      if (noside == EVAL_AVOID_SIDE_EFFECTS)
d6849 3
a6851 3
	      arg1 =
		ada_to_fixed_value
		(type, 0, VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1), 0);
d6853 2
a6854 2
	  else
	    arg1 = value_cast (type, arg1);
d6860 4
a6863 4
         (*pos) += 2;
         type = exp->elts[pc + 1].type;
         return ada_evaluate_subexp (type, exp, pos, noside);
       */
d6871 1
a6871 1
      else
d6876 2
a6877 3
	    error
	      ("Fixed-point values must be assigned to fixed-point variables");
	  else
d6894 1
a6894 2
	    error
	      ("Operands of fixed-point addition must have the same type");
d6910 1
a6910 2
	    error
	      ("Operands of fixed-point subtraction must have the same type");
d6925 1
a6925 1
	return value_zero (VALUE_TYPE (arg1), not_lval);
d6948 1
a6948 1
         /* Only encountered when an unresolved symbol occurs in a
d6950 8
a6957 8
   illegal. *//*
   (*pos) += 3;
   if (noside == EVAL_SKIP)
   goto nosideret;
   else 
   error ("Unexpected unresolved symbol, %s, during evaluation",
   ada_demangle (exp->elts[pc + 2].name));
 */
d6964 1
a6964 1
	}
d6968 3
a6970 3
	  return value_zero
	    (to_static_fixed_type
	     (static_unwrap_type (SYMBOL_TYPE (exp->elts[pc + 2].symbol))),
d6973 1
a6973 1
      else
d6975 2
a6976 3
	  arg1 =
	    unwrap_value (evaluate_subexp_standard
			  (expect_type, exp, pos, noside));
d6978 2
a6979 2
				     VALUE_ADDRESS (arg1) +
				     VALUE_OFFSET (arg1), arg1);
d6989 1
a6989 2
      argvec =
	(struct value * *) alloca (sizeof (struct value *) * (nargs + 1));
d7004 1
a7004 1
         called in argvec[0] and a terminating NULL */
d7006 1
a7006 2
      argvec =
	(struct value * *) alloca (sizeof (struct value *) * (nargs + 2));
d7011 4
a7014 4
         error ("Unexpected unresolved symbol, %s, during evaluation",
         ada_demangle (exp->elts[pc + 5].name));
       */
      if (0)
d7036 1
a7036 1
	{
d7053 1
a7053 1
	    }
d7055 1
a7055 1

d7062 1
a7062 1
	case TYPE_CODE_STRUCT:
d7066 1
a7066 1
	    if (type == NULL)
d7068 1
a7068 1
	    if (arity != nargs)
d7070 1
a7070 1
	    if (noside == EVAL_AVOID_SIDE_EFFECTS)
d7072 1
a7072 3
	    return
	      unwrap_value (ada_value_subscript
			    (argvec[0], nargs, argvec + 1));
d7076 1
a7076 1
	    {
d7083 1
a7083 1
	  return
d7086 2
a7087 2
			   nargs, argvec + 1));
	case TYPE_CODE_PTR:	/* Pointer to array */
d7090 1
a7090 1
	    {
d7097 3
a7099 3
	  return
	    unwrap_value (ada_value_ptr_subscript (argvec[0], type,
						   nargs, argvec + 1));
d7107 1
a7107 1
	struct value *array = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d7114 11
a7124 10

	/* If this is a reference to an array, then dereference it */
	if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_REF
	    && TYPE_TARGET_TYPE (VALUE_TYPE (array)) != NULL
	    && TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (array))) ==
	    TYPE_CODE_ARRAY
	    && !ada_is_array_descriptor (check_typedef (VALUE_TYPE (array))))
	  {
	    array = ada_coerce_ref (array);
	  }
d7130 1
a7130 1
	    struct type *arrType = ada_type_of_array (array, 0);
d7132 1
a7132 1
	      array = value_at_lazy (arrType, 0, NULL);
d7137 11
a7147 11
	/* If at this point we have a pointer to an array, it means that
	   it is a pointer to a simple (non-ada) array. We just then
	   dereference it */
	if (TYPE_CODE (VALUE_TYPE (array)) == TYPE_CODE_PTR
	    && TYPE_TARGET_TYPE (VALUE_TYPE (array)) != NULL
	    && TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (array))) ==
	    TYPE_CODE_ARRAY)
	  {
	    array = ada_value_ind (array);
	  }

d7158 27
a7184 27
         (*pos) += 2;
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         type = exp->elts[pc + 1].type;

         if (noside == EVAL_SKIP)
         goto nosideret;

         switch (TYPE_CODE (type)) 
         {
         default:
         warning ("Membership test incompletely implemented; always returns true");
         return value_from_longest (builtin_type_int, (LONGEST) 1);

         case TYPE_CODE_RANGE:
         arg2 = value_from_longest (builtin_type_int, 
         (LONGEST) TYPE_LOW_BOUND (type));
         arg3 = value_from_longest (builtin_type_int, 
         (LONGEST) TYPE_HIGH_BOUND (type));
         return 
         value_from_longest (builtin_type_int,
         (value_less (arg1,arg3) 
         || value_equal (arg1,arg3))
         && (value_less (arg2,arg1)
         || value_equal (arg2,arg1)));
         }
       */
      /* FIXME: BINOP_MBR should be defined in expression.h */
d7186 25
a7210 25
         (*pos) += 2;
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

         if (noside == EVAL_SKIP)
         goto nosideret;

         if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (builtin_type_int, not_lval);

         tem = longest_to_int (exp->elts[pc + 1].longconst);

         if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg2)))
         error ("invalid dimension number to '%s", "range");

         arg3 = ada_array_bound (arg2, tem, 1);
         arg2 = ada_array_bound (arg2, tem, 0);

         return 
         value_from_longest (builtin_type_int,
         (value_less (arg1,arg3) 
         || value_equal (arg1,arg3))
         && (value_less (arg2,arg1)
         || value_equal (arg2,arg1)));
       */
d7213 14
a7226 14
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         arg3 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

         if (noside == EVAL_SKIP)
         goto nosideret;

         return 
         value_from_longest (builtin_type_int,
         (value_less (arg1,arg3) 
         || value_equal (arg1,arg3))
         && (value_less (arg2,arg1)
         || value_equal (arg2,arg1)));
       */
d7229 218
a7446 218
         *pos += 3;
         atr = (enum ada_attribute) longest_to_int (exp->elts[pc + 2].longconst);
         switch (atr) 
         {
         default:
         error ("unexpected attribute encountered");

         case ATR_FIRST:
         case ATR_LAST:
         case ATR_LENGTH:
         {
         struct type* type_arg;
         if (exp->elts[*pos].opcode == OP_TYPE)
         {
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         arg1 = NULL;
         type_arg = exp->elts[pc + 5].type;
         }
         else
         {
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         type_arg = NULL;
         }

         if (exp->elts[*pos].opcode != OP_LONG) 
         error ("illegal operand to '%s", ada_attribute_name (atr));
         tem = longest_to_int (exp->elts[*pos+2].longconst);
         *pos += 4;

         if (noside == EVAL_SKIP)
         goto nosideret;

         if (type_arg == NULL)
         {
         arg1 = ada_coerce_ref (arg1);

         if (ada_is_packed_array_type (VALUE_TYPE (arg1)))
         arg1 = ada_coerce_to_simple_array (arg1);

         if (tem < 1 || tem > ada_array_arity (VALUE_TYPE (arg1)))
         error ("invalid dimension number to '%s", 
         ada_attribute_name (atr));

         if (noside == EVAL_AVOID_SIDE_EFFECTS)
         {
         type = ada_index_type (VALUE_TYPE (arg1), tem);
         if (type == NULL) 
         error ("attempt to take bound of something that is not an array");
         return allocate_value (type);
         }

         switch (atr) 
         {
         default: 
         error ("unexpected attribute encountered");
         case ATR_FIRST:
         return ada_array_bound (arg1, tem, 0);
         case ATR_LAST:
         return ada_array_bound (arg1, tem, 1);
         case ATR_LENGTH:
         return ada_array_length (arg1, tem);
         }
         }
         else if (TYPE_CODE (type_arg) == TYPE_CODE_RANGE
         || TYPE_CODE (type_arg) == TYPE_CODE_INT) 
         {
         struct type* range_type;
         char* name = ada_type_name (type_arg);
         if (name == NULL)
         {
         if (TYPE_CODE (type_arg) == TYPE_CODE_RANGE) 
         range_type = type_arg;
         else
         error ("unimplemented type attribute");
         }
         else 
         range_type = 
         to_fixed_range_type (name, NULL, TYPE_OBJFILE (type_arg));
         switch (atr) 
         {
         default: 
         error ("unexpected attribute encountered");
         case ATR_FIRST:
         return value_from_longest (TYPE_TARGET_TYPE (range_type),
         TYPE_LOW_BOUND (range_type));
         case ATR_LAST:
         return value_from_longest (TYPE_TARGET_TYPE (range_type),
         TYPE_HIGH_BOUND (range_type));
         }
         }              
         else if (TYPE_CODE (type_arg) == TYPE_CODE_ENUM)
         {
         switch (atr) 
         {
         default: 
         error ("unexpected attribute encountered");
         case ATR_FIRST:
         return value_from_longest 
         (type_arg, TYPE_FIELD_BITPOS (type_arg, 0));
         case ATR_LAST:
         return value_from_longest 
         (type_arg, 
         TYPE_FIELD_BITPOS (type_arg,
         TYPE_NFIELDS (type_arg) - 1));
         }
         }
         else if (TYPE_CODE (type_arg) == TYPE_CODE_FLT)
         error ("unimplemented type attribute");
         else 
         {
         LONGEST low, high;

         if (ada_is_packed_array_type (type_arg))
         type_arg = decode_packed_array_type (type_arg);

         if (tem < 1 || tem > ada_array_arity (type_arg))
         error ("invalid dimension number to '%s", 
         ada_attribute_name (atr));

         if (noside == EVAL_AVOID_SIDE_EFFECTS)
         {
         type = ada_index_type (type_arg, tem);
         if (type == NULL) 
         error ("attempt to take bound of something that is not an array");
         return allocate_value (type);
         }

         switch (atr) 
         {
         default: 
         error ("unexpected attribute encountered");
         case ATR_FIRST:
         low = ada_array_bound_from_type (type_arg, tem, 0, &type);
         return value_from_longest (type, low);
         case ATR_LAST:
         high = ada_array_bound_from_type (type_arg, tem, 1, &type);
         return value_from_longest (type, high);
         case ATR_LENGTH:
         low = ada_array_bound_from_type (type_arg, tem, 0, &type);
         high = ada_array_bound_from_type (type_arg, tem, 1, NULL);
         return value_from_longest (type, high-low+1);
         }
         }
         }

         case ATR_TAG:
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         if (noside == EVAL_SKIP)
         goto nosideret;

         if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return         
         value_zero (ada_tag_type (arg1), not_lval);

         return ada_value_tag (arg1);

         case ATR_MIN:
         case ATR_MAX:
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         if (noside == EVAL_SKIP)
         goto nosideret;
         else if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (VALUE_TYPE (arg1), not_lval);
         else
         return value_binop (arg1, arg2, 
         atr == ATR_MIN ? BINOP_MIN : BINOP_MAX);

         case ATR_MODULUS:
         {
         struct type* type_arg = exp->elts[pc + 5].type;
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         *pos += 4;

         if (noside == EVAL_SKIP)
         goto nosideret;

         if (! ada_is_modular_type (type_arg))
         error ("'modulus must be applied to modular type");

         return value_from_longest (TYPE_TARGET_TYPE (type_arg),
         ada_modulus (type_arg));
         }


         case ATR_POS:
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         if (noside == EVAL_SKIP)
         goto nosideret;
         else if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (builtin_type_ada_int, not_lval);
         else 
         return value_pos_atr (arg1);

         case ATR_SIZE:
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         if (noside == EVAL_SKIP)
         goto nosideret;
         else if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (builtin_type_ada_int, not_lval);
         else
         return value_from_longest (builtin_type_ada_int,
         TARGET_CHAR_BIT 
         * TYPE_LENGTH (VALUE_TYPE (arg1)));

         case ATR_VAL:
         evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
         arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
         type = exp->elts[pc + 5].type;
         if (noside == EVAL_SKIP)
         goto nosideret;
         else if (noside == EVAL_AVOID_SIDE_EFFECTS)
         return value_zero (type, not_lval);
         else 
         return value_val_atr (type, arg1);
         } */
d7454 4
a7457 3
					    EVAL_NORMAL));
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return value_zero (VALUE_TYPE (arg1), not_lval);
d7481 1
a7481 1
	expect_type = TYPE_TARGET_TYPE (check_typedef (expect_type));
d7491 1
a7491 1
	      struct type *arrType = ada_type_of_array (arg1, 0);
d7497 9
a7505 8
		   || TYPE_CODE (type) == TYPE_CODE_REF
		   /* In C you can dereference an array to get the 1st elt.  */
		   || TYPE_CODE (type) == TYPE_CODE_ARRAY)
	    return
	      value_zero
	      (to_static_fixed_type
	       (ada_aligned_type (check_typedef (TYPE_TARGET_TYPE (type)))),
	       lval_memory);
d7514 1
a7514 1

d7528 1
a7528 1
	return value_zero (ada_aligned_type
d7530 1
a7530 2
							&exp->elts[pc +
								   2].string,
d7545 1
a7545 1
      else
d7547 1
a7547 1

d7555 1
a7555 1
	return value_zero (ada_aligned_type
d7557 1
a7557 2
							&exp->elts[pc +
								   2].string,
d7569 1
a7570 1

d7577 1
a7577 1
static const char *
d7580 1
a7580 1
  const char *name = ada_type_name (type);
d7583 3
a7585 2
  if ((code == TYPE_CODE_INT || code == TYPE_CODE_RANGE) && name != NULL)
    {
d7589 1
a7589 1
      else
d7618 1
a7618 1
  else
d7631 1
a7631 1

d7638 1
a7638 1
  else
d7649 1
a7649 1
  return (DOUBLEST) x *scaling_factor (type);
d7667 1
a7667 1
ada_is_vax_floating_type (struct type *type)
d7669 1
a7669 1
  int name_len =
d7671 1
a7671 1
  return
d7673 1
a7673 1
    && (TYPE_CODE (type) == TYPE_CODE_INT
d7681 1
a7681 1
ada_vax_float_type_suffix (struct type *type)
d7683 1
a7683 1
  return ada_type_name (type)[strlen (ada_type_name (type)) - 1];
d7689 2
a7690 2
struct value *
ada_vax_float_print_function (struct type *type)
d7692 13
a7704 11
  switch (ada_vax_float_type_suffix (type))
    {
    case 'F':
      return get_var_value ("DEBUG_STRING_F", 0);
    case 'D':
      return get_var_value ("DEBUG_STRING_D", 0);
    case 'G':
      return get_var_value ("DEBUG_STRING_G", 0);
    default:
      error ("invalid VAX floating-point type");
    }
d7706 1
a7707 1

d7717 1
a7717 2
scan_discrim_bound (char *, int k, struct value *dval, LONGEST * px,
		    int *pnew_k)
d7723 1
a7723 1
  struct value *bound_val;
d7728 1
a7728 1
  pend = strstr (str + k, "__");
d7731 1
a7731 1
      bound = str + k;
d7734 1
a7734 1
  else
d7736 1
a7736 1
      GROW_VECT (bound_buffer, bound_buffer_len, pend - (str + k) + 1);
d7738 7
a7744 6
      strncpy (bound_buffer, str + k, pend - (str + k));
      bound[pend - (str + k)] = '\0';
      k = pend - str;
    }

  bound_val = ada_search_struct_field (bound, dval, 0, VALUE_TYPE (dval));
d7757 2
a7758 2
static struct value *
get_var_value (char *name, char *err_msg)
d7760 2
a7761 2
  struct symbol **syms;
  struct block **blocks;
d7764 2
a7765 3
  nsyms =
    ada_lookup_symbol_list (name, get_selected_block (NULL), VAR_NAMESPACE,
			    &syms, &blocks);
d7777 1
a7777 1

d7782 1
a7782 1
get_int_var_value (char *name, char *err_msg, int *flag)
d7784 2
a7785 2
  struct value *var_val = get_var_value (name, err_msg);

d7799 1
a7799 1

d7809 1
a7809 1
static struct type *
d7815 1
a7815 1
  char *subtype_info;
d7845 1
a7845 1
      if (*subtype_info == 'L')
d7847 2
a7848 2
	  if (!ada_scan_number (bounds_str, n, &L, &n)
	      && !scan_discrim_bound (bounds_str, n, dval, &L, &n))
d7852 1
a7852 1
	  else if (bounds_str[n] == '.')	/* FIXME? SGI Workshop kludge. */
d7856 1
a7856 1
      else
d7858 1
a7858 1
	  strcpy (name_buf + prefix_len, "___L");
d7862 1
a7862 1
      if (*subtype_info == 'U')
d7864 1
a7864 1
	  if (!ada_scan_number (bounds_str, n, &U, &n)
d7868 1
a7868 1
      else
d7870 1
a7870 1
	  strcpy (name_buf + prefix_len, "___U");
d7874 1
a7874 1
      if (objfile == NULL)
d7877 1
a7877 1
      TYPE_NAME (type) = name;
d7884 1
a7884 1
ada_is_range_type_name (const char *name)
d7887 2
a7888 1
}
a7889 1

d7894 1
a7894 1
ada_is_modular_type (struct type *type)
d7897 2
a7898 2
     valarith.c */
  struct type *subranged_type;	/* = base_type (type); */
d7907 1
a7907 1
ada_modulus (struct type * type)
d7909 1
a7909 1
  return TYPE_HIGH_BOUND (type) + 1;
a7910 1

d7913 1
d7919 33
a7951 32
static const struct op_print ada_op_print_tab[] = {
  {":=", BINOP_ASSIGN, PREC_ASSIGN, 1},
  {"or else", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},
  {"and then", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},
  {"or", BINOP_BITWISE_IOR, PREC_BITWISE_IOR, 0},
  {"xor", BINOP_BITWISE_XOR, PREC_BITWISE_XOR, 0},
  {"and", BINOP_BITWISE_AND, PREC_BITWISE_AND, 0},
  {"=", BINOP_EQUAL, PREC_EQUAL, 0},
  {"/=", BINOP_NOTEQUAL, PREC_EQUAL, 0},
  {"<=", BINOP_LEQ, PREC_ORDER, 0},
  {">=", BINOP_GEQ, PREC_ORDER, 0},
  {">", BINOP_GTR, PREC_ORDER, 0},
  {"<", BINOP_LESS, PREC_ORDER, 0},
  {">>", BINOP_RSH, PREC_SHIFT, 0},
  {"<<", BINOP_LSH, PREC_SHIFT, 0},
  {"+", BINOP_ADD, PREC_ADD, 0},
  {"-", BINOP_SUB, PREC_ADD, 0},
  {"&", BINOP_CONCAT, PREC_ADD, 0},
  {"*", BINOP_MUL, PREC_MUL, 0},
  {"/", BINOP_DIV, PREC_MUL, 0},
  {"rem", BINOP_REM, PREC_MUL, 0},
  {"mod", BINOP_MOD, PREC_MUL, 0},
  {"**", BINOP_EXP, PREC_REPEAT, 0},
  {"@@", BINOP_REPEAT, PREC_REPEAT, 0},
  {"-", UNOP_NEG, PREC_PREFIX, 0},
  {"+", UNOP_PLUS, PREC_PREFIX, 0},
  {"not ", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},
  {"not ", UNOP_COMPLEMENT, PREC_PREFIX, 0},
  {"abs ", UNOP_ABS, PREC_PREFIX, 0},
  {".all", UNOP_IND, PREC_SUFFIX, 1},	/* FIXME: postfix .ALL */
  {"'access", UNOP_ADDR, PREC_SUFFIX, 1},	/* FIXME: postfix 'ACCESS */
  {NULL, 0, 0, 0}
d7956 11
a7966 11
struct type *builtin_type_ada_int;
struct type *builtin_type_ada_short;
struct type *builtin_type_ada_long;
struct type *builtin_type_ada_long_long;
struct type *builtin_type_ada_char;
struct type *builtin_type_ada_float;
struct type *builtin_type_ada_double;
struct type *builtin_type_ada_long_double;
struct type *builtin_type_ada_natural;
struct type *builtin_type_ada_positive;
struct type *builtin_type_ada_system_address;
d7968 1
a7968 1
struct type **const (ada_builtin_types[]) =
d7970 1
a7970 1

d7972 30
a8001 25
    &builtin_type_ada_long,
    &builtin_type_ada_short,
    &builtin_type_ada_char,
    &builtin_type_ada_float,
    &builtin_type_ada_double,
    &builtin_type_ada_long_long,
    &builtin_type_ada_long_double,
    &builtin_type_ada_natural, &builtin_type_ada_positive,
    /* The following types are carried over from C for convenience. */
&builtin_type_int,
    &builtin_type_long,
    &builtin_type_short,
    &builtin_type_char,
    &builtin_type_float,
    &builtin_type_double,
    &builtin_type_long_long,
    &builtin_type_void,
    &builtin_type_signed_char,
    &builtin_type_unsigned_char,
    &builtin_type_unsigned_short,
    &builtin_type_unsigned_int,
    &builtin_type_unsigned_long,
    &builtin_type_unsigned_long_long,
    &builtin_type_long_double,
    &builtin_type_complex, &builtin_type_double_complex, 0};
d8004 1
a8004 2
static void
emit_char (int c, struct ui_file *stream, int quoter)
d8029 1
a8029 1
  {"", "", "", ""},		/* Binary format info */
d8031 3
a8033 3
  {"8#%lo#", "8#", "o", "#"},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"16#%lx#", "16#", "x", "#"},	/* Hex format info */
d8036 3
a8038 3
  {"0%lo", "0", "o", ""},	/* Octal format info */
  {"%ld", "", "d", ""},		/* Decimal format info */
  {"0x%lx", "0x", "x", ""},	/* Hex format info */
d8052 2
a8053 1
	       0, "integer", (struct objfile *) NULL);
d8056 2
a8057 1
	       0, "long_integer", (struct objfile *) NULL);
d8060 2
a8061 1
	       0, "short_integer", (struct objfile *) NULL);
d8064 2
a8065 1
	       0, "character", (struct objfile *) NULL);
d8068 2
a8069 1
	       0, "float", (struct objfile *) NULL);
d8072 2
a8073 1
	       0, "long_float", (struct objfile *) NULL);
d8076 2
a8077 1
	       0, "long_long_integer", (struct objfile *) NULL);
d8080 2
a8081 1
	       0, "long_long_float", (struct objfile *) NULL);
d8084 2
a8085 1
	       0, "natural", (struct objfile *) NULL);
d8088 2
a8089 1
	       0, "positive", (struct objfile *) NULL);
d8092 2
a8093 2
  builtin_type_ada_system_address =
    lookup_pointer_type (init_type (TYPE_CODE_VOID, 1, 0, "void",
d8099 1
a8099 1
  add_show_from_set
d8101 1
a8101 1
		  (char *) &varsize_limit,
d8103 2
a8104 1
		  &setlist), &showlist);
d8144 106
a8249 104
    default:
      /* FIXME:  For now, if we are asked to produce a type not in this
         language, create the equivalent of a C integer type with the
         name "<?type?>".  When all the dust settles from the type
         reconstruction work, this should probably become an error. */
      type = init_type (TYPE_CODE_INT,
			TARGET_INT_BIT / TARGET_CHAR_BIT,
			0, "<?type?>", objfile);
      warning ("internal error: no Ada fundamental type %d", typeid);
      break;
    case FT_VOID:
      type = init_type (TYPE_CODE_VOID,
			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			0, "void", objfile);
      break;
    case FT_CHAR:
      type = init_type (TYPE_CODE_INT,
			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			0, "character", objfile);
      break;
    case FT_SIGNED_CHAR:
      type = init_type (TYPE_CODE_INT,
			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			0, "signed char", objfile);
      break;
    case FT_UNSIGNED_CHAR:
      type = init_type (TYPE_CODE_INT,
			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned char", objfile);
      break;
    case FT_SHORT:
      type = init_type (TYPE_CODE_INT,
			TARGET_SHORT_BIT / TARGET_CHAR_BIT,
			0, "short_integer", objfile);
      break;
    case FT_SIGNED_SHORT:
      type = init_type (TYPE_CODE_INT,
			TARGET_SHORT_BIT / TARGET_CHAR_BIT,
			0, "short_integer", objfile);
      break;
    case FT_UNSIGNED_SHORT:
      type = init_type (TYPE_CODE_INT,
			TARGET_SHORT_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned short", objfile);
      break;
    case FT_INTEGER:
      type = init_type (TYPE_CODE_INT,
			TARGET_INT_BIT / TARGET_CHAR_BIT,
			0, "integer", objfile);
      break;
    case FT_SIGNED_INTEGER:
      type = init_type (TYPE_CODE_INT, TARGET_INT_BIT / TARGET_CHAR_BIT, 0, "integer", objfile);	/* FIXME -fnf */
      break;
    case FT_UNSIGNED_INTEGER:
      type = init_type (TYPE_CODE_INT,
			TARGET_INT_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned int", objfile);
      break;
    case FT_LONG:
      type = init_type (TYPE_CODE_INT,
			TARGET_LONG_BIT / TARGET_CHAR_BIT,
			0, "long_integer", objfile);
      break;
    case FT_SIGNED_LONG:
      type = init_type (TYPE_CODE_INT,
			TARGET_LONG_BIT / TARGET_CHAR_BIT,
			0, "long_integer", objfile);
      break;
    case FT_UNSIGNED_LONG:
      type = init_type (TYPE_CODE_INT,
			TARGET_LONG_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned long", objfile);
      break;
    case FT_LONG_LONG:
      type = init_type (TYPE_CODE_INT,
			TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
			0, "long_long_integer", objfile);
      break;
    case FT_SIGNED_LONG_LONG:
      type = init_type (TYPE_CODE_INT,
			TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
			0, "long_long_integer", objfile);
      break;
    case FT_UNSIGNED_LONG_LONG:
      type = init_type (TYPE_CODE_INT,
			TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
			TYPE_FLAG_UNSIGNED, "unsigned long long", objfile);
      break;
    case FT_FLOAT:
      type = init_type (TYPE_CODE_FLT,
			TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
			0, "float", objfile);
      break;
    case FT_DBL_PREC_FLOAT:
      type = init_type (TYPE_CODE_FLT,
			TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
			0, "long_float", objfile);
      break;
    case FT_EXT_PREC_FLOAT:
      type = init_type (TYPE_CODE_FLT,
			TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
			0, "long_long_float", objfile);
      break;
    }
d8253 1
a8253 2
void
ada_dump_symtab (struct symtab *s)
d8257 3
a8259 2
  fprintf (stderr, "  Name: %s/%s;\n",
	   s->dirname ? s->dirname : "?", s->filename ? s->filename : "?");
d8266 1
a8266 1
	  struct linetable_entry *e = s->linetable->item + i;
d8272 1
@


1.2.2.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d1855 4
a1858 1
ada_array_bound (struct value *arr, int n, int which)
d2337 4
a2340 1
ada_type_match (struct type *ftype, struct type *atype, int may_deref)
d8107 1
a8107 1
_initialize_ada_language (void)
@


1.2.2.6
log
@merge from mainline
@
text
@d4398 1
a4398 1
      init_sal (&val);
d4540 1
a4540 1
  init_sal (&sals.sals[0]);
d4859 1
a4859 1
	init_sal (&result.sals[result.nelts]);
@


1.1
log
@Add base ada language files
@
text
@d4283 1
a4283 9
   with prototype information, if it is not already there.  
   
   Why is there provision in struct type for BOTH an array of argument
   types (TYPE_ARG_TYPES) and for an array of typed fields, whose
   comment suggests it may also represent argument types?  I presume
   this is some attempt to save space.  The problem is that argument
   names in Ada are significant.  Therefore, for Ada we use the
   (apparently older) TYPE_FIELD_* stuff to store argument types. */

@


1.1.2.1
log
@merge from trunk
@
text
@@


1.1.2.2
log
@Merge with trunk.
@
text
@d4283 9
a4291 1
   with prototype information, if it is not already there.  */
@


