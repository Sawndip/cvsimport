head	1.16;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.16
	gdb_7_6-2013-04-26-release:1.16
	gdb_7_6-branch:1.16.0.2
	gdb_7_6-2013-03-12-branchpoint:1.16
	gdb_7_5_1-2012-11-29-release:1.15
	gdb_7_5-2012-08-17-release:1.15
	gdb_7_5-branch:1.15.0.2
	gdb_7_5-2012-07-18-branchpoint:1.15
	gdb_7_4_1-2012-04-26-release:1.14.4.1
	gdb_7_4-2012-01-24-release:1.14.4.1
	gdb_7_4-branch:1.14.0.4
	gdb_7_4-2011-12-13-branchpoint:1.14
	gdb_7_3_1-2011-09-04-release:1.14
	gdb_7_3-2011-07-26-release:1.14
	gdb_7_3-branch:1.14.0.2
	gdb_7_3-2011-04-01-branchpoint:1.14
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.4
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.2
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.10
	gdb_7_0-2009-10-06-release:1.10
	gdb_7_0-branch:1.10.0.4
	gdb_7_0-2009-09-16-branchpoint:1.10
	arc-sim-20090309:1.9
	msnyder-checkpoint-072509-branch:1.10.0.2
	msnyder-checkpoint-072509-branchpoint:1.10
	arc-insight_6_8-branch:1.9.0.16
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.14
	insight_6_8-branchpoint:1.9
	reverse-20081226-branch:1.9.0.12
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.10
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.8
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.9.0.6
	reverse-20080717-branchpoint:1.9
	msnyder-reverse-20080609-branch:1.9.0.4
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.6.0.2
	drow-reverse-20070409-branchpoint:1.6
	gdb_6_8-2008-03-27-release:1.9
	gdb_6_8-branch:1.9.0.2
	gdb_6_8-2008-02-26-branchpoint:1.9
	gdb_6_7_1-2007-10-29-release:1.7.2.1
	gdb_6_7-2007-10-10-release:1.7
	gdb_6_7-branch:1.7.0.2
	gdb_6_7-2007-09-07-branchpoint:1.7
	insight_6_6-20070208-release:1.3
	gdb_6_6-2006-12-18-release:1.3
	gdb_6_6-branch:1.3.0.2
	gdb_6_6-2006-11-15-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.16
date	2013.01.01.06.32.47;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.04.08.17.06;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2011.02.02.16.12.58;	author palves;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2011.01.25.09.49.59;	author palves;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.01.15.33.10;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2010.01.01.07.31.37;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.25.21.43.42;	author palves;	state Exp;
branches;
next	1.7;

1.7
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2007.01.09.17.58.52;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.04.22.11.44;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.29.09.46.35;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.05.19.42.31;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.03.15.54.01;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.21.13.54.02;	author drow;	state Exp;
branches;
next	;

1.14.4.1
date	2012.01.06.04.43.20;	author brobecke;	state Exp;
branches;
next	;

1.7.2.1
date	2007.10.25.21.40.55;	author palves;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Routines for handling XML memory maps provided by target.

   Copyright (C) 2006-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "memory-map.h"
#include "gdb_assert.h"
#include "exceptions.h"

#include "gdb_string.h"

#if !defined(HAVE_LIBEXPAT)

VEC(mem_region_s) *
parse_memory_map (const char *memory_map)
{
  static int have_warned;

  if (!have_warned)
    {
      have_warned = 1;
      warning (_("Can not parse XML memory map; XML support was disabled "
		 "at compile time"));
    }

  return NULL;
}

#else /* HAVE_LIBEXPAT */

#include "xml-support.h"

/* Internal parsing data passed to all XML callbacks.  */
struct memory_map_parsing_data
  {
    VEC(mem_region_s) **memory_map;
    char property_name[32];
  };

/* Handle the start of a <memory> element.  */

static void
memory_map_start_memory (struct gdb_xml_parser *parser,
			 const struct gdb_xml_element *element,
			 void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct memory_map_parsing_data *data = user_data;
  struct mem_region *r = VEC_safe_push (mem_region_s, *data->memory_map, NULL);
  ULONGEST *start_p, *length_p, *type_p;

  start_p = xml_find_attribute (attributes, "start")->value;
  length_p = xml_find_attribute (attributes, "length")->value;
  type_p = xml_find_attribute (attributes, "type")->value;

  mem_region_init (r);
  r->lo = *start_p;
  r->hi = r->lo + *length_p;
  r->attrib.mode = *type_p;
  r->attrib.blocksize = -1;
}

/* Handle the end of a <memory> element.  Verify that any necessary
   children were present.  */

static void
memory_map_end_memory (struct gdb_xml_parser *parser,
		       const struct gdb_xml_element *element,
		       void *user_data, const char *body_text)
{
  struct memory_map_parsing_data *data = user_data;
  struct mem_region *r = VEC_last (mem_region_s, *data->memory_map);

  if (r->attrib.mode == MEM_FLASH && r->attrib.blocksize == -1)
    gdb_xml_error (parser, _("Flash block size is not set"));
}

/* Handle the start of a <property> element by saving the name
   attribute for later.  */

static void
memory_map_start_property (struct gdb_xml_parser *parser,
			   const struct gdb_xml_element *element,
			   void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct memory_map_parsing_data *data = user_data;
  char *name;

  name = xml_find_attribute (attributes, "name")->value;
  snprintf (data->property_name, sizeof (data->property_name), "%s", name);
}

/* Handle the end of a <property> element and its value.  */

static void
memory_map_end_property (struct gdb_xml_parser *parser,
			 const struct gdb_xml_element *element,
			 void *user_data, const char *body_text)
{
  struct memory_map_parsing_data *data = user_data;
  char *name = data->property_name;

  if (strcmp (name, "blocksize") == 0)
    {
      struct mem_region *r = VEC_last (mem_region_s, *data->memory_map);

      r->attrib.blocksize = gdb_xml_parse_ulongest (parser, body_text);
    }
  else
    gdb_xml_debug (parser, _("Unknown property \"%s\""), name);
}

/* Discard the constructed memory map (if an error occurs).  */

static void
clear_result (void *p)
{
  VEC(mem_region_s) **result = p;
  VEC_free (mem_region_s, *result);
  *result = NULL;
}

/* The allowed elements and attributes for an XML memory map.  */

const struct gdb_xml_attribute property_attributes[] = {
  { "name", GDB_XML_AF_NONE, NULL, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

const struct gdb_xml_element memory_children[] = {
  { "property", property_attributes, NULL,
    GDB_XML_EF_REPEATABLE | GDB_XML_EF_OPTIONAL,
    memory_map_start_property, memory_map_end_property },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

const struct gdb_xml_enum memory_type_enum[] = {
  { "ram", MEM_RW },
  { "rom", MEM_RO },
  { "flash", MEM_FLASH },
  { NULL, 0 }
};

const struct gdb_xml_attribute memory_attributes[] = {
  { "start", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },
  { "length", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },
  { "type", GDB_XML_AF_NONE, gdb_xml_parse_attr_enum, &memory_type_enum },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

const struct gdb_xml_element memory_map_children[] = {
  { "memory", memory_attributes, memory_children, GDB_XML_EF_REPEATABLE,
    memory_map_start_memory, memory_map_end_memory },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

const struct gdb_xml_element memory_map_elements[] = {
  { "memory-map", NULL, memory_map_children, GDB_XML_EF_NONE,
    NULL, NULL },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

VEC(mem_region_s) *
parse_memory_map (const char *memory_map)
{
  VEC(mem_region_s) *result = NULL;
  struct cleanup *back_to;
  struct memory_map_parsing_data data = { NULL };

  data.memory_map = &result;
  back_to = make_cleanup (clear_result, &result);
  if (gdb_xml_parse_quick (_("target memory map"), NULL, memory_map_elements,
			   memory_map, &data) == 0)
    {
      /* Parsed successfully, keep the result.  */
      discard_cleanups (back_to);
      return result;
    }

  do_cleanups (back_to);
  return NULL;
}

#endif /* HAVE_LIBEXPAT */
@


1.15
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.14
log
@	* xml-support.c (xml_find_attribute): New.
	(xinclude_start_include): Use it.
	* xml-support.h (xml_find_attribute): Declare.
	* memory-map.c (memory_map_start_memory)
	(memory_map_start_property): Use xml_find_attribute.
	* osdata.c (osdata_start_osdata, osdata_start_column): Use
	xml_find_attribute.
	* remote.c (start_thread): Use xml_find_attribute.
	* solib-target.c (library_list_start_segment)
	(library_list_start_section, library_list_start_library)
	(library_list_start_list): Use xml_find_attribute.
	* xml-tdesc.c (tdesc_start_target, tdesc_start_feature)
	(tdesc_start_union, tdesc_start_struct, tdesc_start_flags)
	(tdesc_start_field): Use xml_find_attribute.
@
text
@d3 1
a3 2
   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.14.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.13
log
@	Simplify XML parsing a bit.

	* xml-support.h (gdb_xml_parse_quick): Declare.
	* xml-support.c (gdb_xml_create_parser_and_cleanup_1): Renamed
	from gdb_xml_create_parser_and_cleanup, and added `old_chain'
	parameter.
	(gdb_xml_create_parser_and_cleanup): Reimplement on top of
	gdb_xml_create_parser_and_cleanup_1.
	(gdb_xml_parse_quick): New.
	* memory-map.c (parse_memory_map): Use gdb_xml_parse_quick.
	* osdata.c (osdata_parse): Ditto.
	* remote.c (remote_threads_info): Ditto.
	* solib-target.c (solib_target_parse_libraries): Ditto.
	* xml-syscall.c (syscall_parse_xml): Ditto.
	* xml-tdesc.c (tdesc_parse_xml): Ditto.
@
text
@d67 3
a69 3
  start_p = VEC_index (gdb_xml_value_s, attributes, 0)->value;
  length_p = VEC_index (gdb_xml_value_s, attributes, 1)->value;
  type_p = VEC_index (gdb_xml_value_s, attributes, 2)->value;
d104 1
a104 1
  name = VEC_index (gdb_xml_value_s, attributes, 0)->value;
@


1.12
log
@run copyright.sh for 2011.
@
text
@a180 1
  struct gdb_xml_parser *parser;
d182 1
a182 1
  struct cleanup *before_deleting_result, *back_to;
a184 6
  back_to = make_cleanup (null_cleanup, NULL);
  parser = gdb_xml_create_parser_and_cleanup (_("target memory map"),
					      memory_map_elements, &data);

  /* Note: 'clear_result' will zero 'result'.  */
  before_deleting_result = make_cleanup (clear_result, &result);
d186 8
a193 4

  if (gdb_xml_parse (parser, memory_map) == 0)
    /* Parsed successfully, don't need to delete the result.  */
    discard_cleanups (before_deleting_result);
d196 1
a196 1
  return result;
@


1.11
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d3 2
a4 1
   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.10
log
@        Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.9
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.8
log
@	* memory-map.c (parse_memory_map): Don't use an empty struct
	initializer.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
@


1.7
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d183 1
a183 1
  struct memory_map_parsing_data data = {};
@


1.7.2.1
log
@	* memory-map.c (parse_memory_map): Don't use an empty struct
	initializer.
@
text
@d183 1
a183 1
  struct memory_map_parsing_data data = { NULL };
@


1.6
log
@Copyright updates for 2007.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.5
log
@	* memory-map.c (struct_memory_map_parsing_data): Remove most
	members.  Make property_name an array.
	(free_memory_map_parsing_data, memory_map_start_element)
	(memory_map_end_element, memory_map_character_data): Delete.
	(memory_map_start_memory, memory_map_end_memory)
	(memory_map_start_property, memory_map_end_property): New functions.
	(property_attributes, memory_children, memory_type_enum)
	(memory_attributes, memory_map_children, memory_map_elements): New.
	(parse_memory_map): Rewrite.
	* xml-support.c (debug_xml): New.
	(xml_get_required_attribute, xml_get_integer_attribute)
	(xml_get_enum_value, free_xml_parser, make_cleanup_free_xml_parser):
	Delete.
	(struct scope_level, struct gdb_xml_parser, gdb_xml_body_text)
	(gdb_xml_debug, gdb_xml_error, gdb_xml_values_cleanup)
	(gdb_xml_start_element, gdb_xml_start_element_wrapper)
	(gdb_xml_end_element, gdb_xml_end_element_wrapper, gdb_xml_cleanup)
	(gdb_xml_create_parser_and_cleanup, gdb_xml_parse)
	(gdb_xml_parse_ulongest, gdb_xml_parse_attr_ulongest)
	(gdb_xml_parse_attr_enum, show_debug_xml, _initialize_xml_support):
	New.
	* xml-support.h (struct gdb_xml_value, gdb_xml_attribute_handler)
	(enum gdb_xml_attribute_flag, struct gdb_xml_attribute)
	(enum gdb_xml_element_flag, struct gdb_xml_element)
	(gdb_xml_element_start_handler, gdb_xml_element_end_handler)
	(struct gdb_xml_enum): New.
	(gdb_xml_create_parser_and_cleanup, gdb_xml_parse, gdb_xml_debug)
	(gdb_xml_error, gdb_xml_parse_attr_ulongest)
	(gdb_xml_parse_attr_enum, gdb_xml_parse_ulongest): New prototypes.
	(xml_get_required_attribute, xml_get_integer_attribute)
	(xml_get_enum_value, make_cleanup_free_xml_parser): Delete prototypes.
	* Makefile.in (xml_support_h, xml-support.o): Update.

	* gdb.texinfo (Debugging Output): Document "set debug xml"
	and "show debug xml".
@
text
@d3 1
a3 2
   Copyright (C) 2006
   Free Software Foundation, Inc.
@


1.4
log
@* memory-map.c (memory_map_end_element): Move variable
declarations to the begining of the block.
@
text
@d51 1
a51 3
#include "gdb_expat.h"

/* Internal parsing data passed to all Expat callbacks.  */
d55 1
a55 4
    struct mem_region *currently_parsing;
    char *character_data;
    const char *property_name;
    int capture_text;
d58 2
d61 17
a77 5
free_memory_map_parsing_data (void *p_)
{
  struct memory_map_parsing_data *p = p_;

  xfree (p->character_data);
d80 2
a81 10
/* Callback called by Expat on start of element.
   DATA_ is pointer to memory_map_parsing_data
   NAME is the name of element
   ATTRS is the zero-terminated array of attribute names and
   attribute values.

   This function handles the following elements:
   - 'memory' -- creates a new memory region and initializes it
     from attributes.  Sets DATA_.currently_parsing to the new region.
   - 'properties' -- sets DATA.capture_text.  */
d84 3
a86 2
memory_map_start_element (void *data_, const XML_Char *name,
			  const XML_Char **attrs)
d88 2
a89 27
  static const XML_Char *type_names[] = {"ram", "rom", "flash", 0};
  static int type_values[] = { MEM_RW, MEM_RO, MEM_FLASH };
  struct memory_map_parsing_data *data = data_;
  struct gdb_exception ex;

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      if (strcmp (name, "memory") == 0)
	{
	  struct mem_region *r;

	  r = VEC_safe_push (mem_region_s, *data->memory_map, NULL);
	  mem_region_init (r);

	  r->lo = xml_get_integer_attribute (attrs, "start");
	  r->hi = r->lo + xml_get_integer_attribute (attrs, "length");
	  r->attrib.mode = xml_get_enum_value (attrs, "type", type_names,
					       type_values);
	  r->attrib.blocksize = -1;

	  data->currently_parsing = r;
	}
      else if (strcmp (name, "property") == 0)
	{
	  if (!data->currently_parsing)
	    throw_error (XML_PARSE_ERROR,
		_("memory map: found 'property' element outside 'memory'"));
d91 2
a92 8
	  data->capture_text = 1;

	  data->property_name = xml_get_required_attribute (attrs, "name");
	}
    }
  if (ex.reason < 0)
    throw_error
      (ex.error, _("While parsing element %s:\n%s"), name, ex.message);
d95 2
a96 7
/* Callback called by Expat on start of element.  DATA_ is a pointer
   to our memory_map_parsing_data.  NAME is the name of the element.

   This function handles the following elements:
   - 'property' -- check that the property name is 'blocksize' and
     sets DATA->currently_parsing->attrib.blocksize
   - 'memory' verifies that flash block size is set.  */
d99 3
a101 1
memory_map_end_element (void *data_, const XML_Char *name)
d103 2
a104 2
  struct memory_map_parsing_data *data = data_;
  struct gdb_exception ex;
d106 2
a107 37
  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      if (strcmp (name, "property") == 0)
	{
	  if (strcmp (data->property_name, "blocksize") == 0)
	    {
	      char *end = NULL;

	      if (!data->character_data)
		throw_error (XML_PARSE_ERROR,
			     _("Empty content of 'property' element"));
	      data->currently_parsing->attrib.blocksize
		= strtoul (data->character_data, &end, 0);
	      if (*end != '\0')
		throw_error (XML_PARSE_ERROR,
			     _("Invalid content of the 'blocksize' property"));
	    }
	  else
	    throw_error (XML_PARSE_ERROR,
			 _("Unknown memory region property: %s"), name);

	  data->capture_text = 0;
	}
      else if (strcmp (name, "memory") == 0)
	{
	  if (data->currently_parsing->attrib.mode == MEM_FLASH
	      && data->currently_parsing->attrib.blocksize == -1)
	    throw_error (XML_PARSE_ERROR,
			 _("Flash block size is not set"));

	  data->currently_parsing = 0;
	  data->character_data = 0;
	}
    }
  if (ex.reason < 0)
    throw_error
      (ex.error, _("while parsing element %s: \n%s"), name, ex.message);
d110 1
a110 4
/* Callback called by expat for all character data blocks.
   DATA_ is the pointer to memory_map_parsing_data.
   S is the point to character data.
   LEN is the length of data; the data is not zero-terminated.
a111 2
   If DATA_->CAPTURE_TEXT is 1, appends this block of characters
   to DATA_->CHARACTER_DATA.  */
d113 3
a115 2
memory_map_character_data (void *data_, const XML_Char *s,
			   int len)
d117 2
a118 2
  struct memory_map_parsing_data *data = data_;
  int current_size = 0;
d120 3
a122 2
  if (!data->capture_text)
    return;
d124 2
a125 8
  /* Expat interface does not guarantee that a single call to
     a handler will be made. Actually, one call for each line
     will be made, and character data can possibly span several
     lines.

     Take care to realloc the data if needed.  */
  if (!data->character_data)
    data->character_data = xmalloc (len + 1);
d127 2
a128 5
    {
      current_size = strlen (data->character_data);
      data->character_data = xrealloc (data->character_data,
				       current_size + len + 1);
    }
d130 1
a130 3
  memcpy (data->character_data + current_size, s, len);
  data->character_data[current_size + len] = '\0';
}
d140 40
d183 1
d185 1
a185 6
  struct cleanup *back_to = make_cleanup (null_cleanup, NULL);
  struct cleanup *before_deleting_result;
  struct cleanup *saved;
  volatile struct gdb_exception ex;
  int ok = 0;

d188 3
a190 3
  XML_Parser parser = XML_ParserCreateNS (NULL, '!');
  if (parser == NULL)
    goto out;
a191 2
  make_cleanup_free_xml_parser (parser);
  make_cleanup (free_memory_map_parsing_data, &data);
a193 5

  XML_SetElementHandler (parser, memory_map_start_element,
			 memory_map_end_element);
  XML_SetCharacterDataHandler (parser, memory_map_character_data);
  XML_SetUserData (parser, &data);
d196 1
a196 19
  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      if (XML_Parse (parser, memory_map, strlen (memory_map), 1)
	  != XML_STATUS_OK)
	{
	  enum XML_Error err = XML_GetErrorCode (parser);

	  throw_error (XML_PARSE_ERROR, "%s", XML_ErrorString (err));
	}
    }
  if (ex.reason != GDB_NO_ERROR)
    {
      if (ex.error == XML_PARSE_ERROR)
	/* Just report it.  */
	warning (_("Could not parse XML memory map: %s"), ex.message);
      else
	throw_exception (ex);
    }
  else
a199 1
 out:
@


1.3
log
@	* Makefile.in (gdb_expat_h): New.
	(xml_support_h): Add gdb_expat.h dependency.
	(memory-map.o, xml-support.o): Likewise.
	* gdb_expat.h: New file.
	* xml-support.h: Include it.
	* memory-map.c, xml-support.c: Likewise.  Remove XML_STATUS_OK
	definitions.
@
text
@d144 2
a148 1
	      char *end = NULL;
@


1.2
log
@	* memory-map.c (XML_STATUS_OK, XML_STATUS_ERROR): Provide default
	definitions.
	* xml-support.c (XML_STATUS_OK, XML_STATUS_ERROR): Likewise.
@
text
@a49 1
#include <expat.h>
d51 1
a51 4
#ifndef XML_STATUS_OK
# define XML_STATUS_OK    1
# define XML_STATUS_ERROR 0
#endif
@


1.1
log
@gdb/
2006-09-21  Vladimir Prus  <vladimir@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Nathan Sidwell  <nathan@@codesourcery.com>

	* Makefile.in (SFILES): Add memory-map.c and xml-support.c.
	(memory_map_h, xml_support_h): New.
	(target_h): Add vec_h dependency.
	(COMMON_OBS): Add memory-map.o and xml-support.o.
	(memory-map.o, xml-support.o): New rules.
	(remote.o): Update.
	* exceptions.h (enum errors): Add XML_PARSE_ERROR.
	* infcmd.c (run_command_1, attach_command): Call target_pre_inferior.
	* memattr.c (default_mem_attrib): Initialize blocksize.
	(target_mem_region_list, mem_use_target)
	(target_mem_regions_valid, mem_region_cmp, mem_region_init)
	(require_user_regions, require_target_regions)
	(invalidate_target_mem_regions): New.
	(create_mem_region): Use mem_region_init.
	(mem_clear): Move higher.
	(lookup_mem_region): Use require_target_regions.
	(mem_command): Implement "mem auto".
	(mem_info_command): Handle target-supplied regions and flash
	attributes.
	(mem_enable_command, mem_disable_command, mem_delete_command): Use
	require_user_regions.
	(_initialize_mem): Mention "mem auto" in help.
	* memattr.h (enum mem_access_mode): Add MEM_FLASH.
	(struct mem_attrib): Add blocksize.
	(invalidate_target_mem_regions, mem_region_init, mem_region_cmp): New
	prototypes.
	* remote.c: Include "memory-map.h".
	(PACKET_qXfer_memory_map): New enum value.
	(remote_protocol_features): Add qXfer:memory-map:read.
	(remote_xfer_partial): Handle memory maps.
	(remote_memory_map): New.
	(init_remote_ops, init_remote_async_ops): Set to_memory_map.
	(_initialize_remote): Register qXfer:memory-map:read.
	* target.c (update_current_target): Mention to_memory_map.
	(target_memory_map, target_pre_inferior): New.
	(target_preopen): Call target_pre_inferior.
	* target.h: Include "vec.h".
	(enum target_object): Add TARGET_OBJECT_MEMORY_MAP.
	(struct target_ops): Add to_memory_map.
	(target_memory_map, target_pre_inferior): New prototypes.
	* memory-map.c, memory-map.h, xml-support.c, xml-support.h: New files.
gdb/doc/
2006-09-21  Vladimir Prus  <vladimir@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb.texinfo (Memory Region Attributes): Mention target-supplied
	memory regions and "mem auto".
@
text
@d52 5
@

