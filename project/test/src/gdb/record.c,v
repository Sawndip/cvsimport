head	1.90;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.83
	gdb_7_6-2013-04-26-release:1.83
	gdb_7_6-branch:1.83.0.2
	gdb_7_6-2013-03-12-branchpoint:1.83
	gdb_7_5_1-2012-11-29-release:1.71
	gdb_7_5-2012-08-17-release:1.71
	gdb_7_5-branch:1.71.0.2
	gdb_7_5-2012-07-18-branchpoint:1.71
	gdb_7_4_1-2012-04-26-release:1.65.2.1
	gdb_7_4-2012-01-24-release:1.65.2.1
	gdb_7_4-branch:1.65.0.2
	gdb_7_4-2011-12-13-branchpoint:1.65
	gdb_7_3_1-2011-09-04-release:1.63
	gdb_7_3-2011-07-26-release:1.63
	gdb_7_3-branch:1.63.0.2
	gdb_7_3-2011-04-01-branchpoint:1.63
	gdb_7_2-2010-09-02-release:1.50.2.1
	gdb_7_2-branch:1.50.0.2
	gdb_7_2-2010-07-07-branchpoint:1.50
	gdb_7_1-2010-03-18-release:1.42
	gdb_7_1-branch:1.42.0.2
	gdb_7_1-2010-02-18-branchpoint:1.42
	gdb_7_0_1-2009-12-22-release:1.17.2.3
	gdb_7_0-2009-10-06-release:1.17.2.3
	gdb_7_0-branch:1.17.0.2
	gdb_7_0-2009-09-16-branchpoint:1.17
	msnyder-checkpoint-072509-branch:1.9.0.2
	msnyder-checkpoint-072509-branchpoint:1.9
	reverse-20081226-branch:1.1.0.6
	reverse-20080930-branch:1.1.0.4
	reverse-20080717-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.90
date	2013.09.30.11.50.12;	author luisgpm;	state Exp;
branches;
next	1.89;

1.89
date	2013.09.02.15.06.11;	author mmetzger;	state Exp;
branches;
next	1.88;

1.88
date	2013.05.15.07.04.11;	author mmetzger;	state Exp;
branches;
next	1.87;

1.87
date	2013.04.19.15.37.31;	author palves;	state Exp;
branches;
next	1.86;

1.86
date	2013.04.10.15.11.11;	author palves;	state Exp;
branches;
next	1.85;

1.85
date	2013.03.27.09.42.47;	author mmetzger;	state Exp;
branches;
next	1.84;

1.84
date	2013.03.26.18.03.03;	author palves;	state Exp;
branches;
next	1.83;

1.83
date	2013.03.11.08.53.17;	author mmetzger;	state Exp;
branches;
next	1.82;

1.82
date	2013.03.11.08.50.05;	author mmetzger;	state Exp;
branches;
next	1.81;

1.81
date	2013.03.11.08.48.38;	author mmetzger;	state Exp;
branches;
next	1.80;

1.80
date	2013.03.11.08.47.10;	author mmetzger;	state Exp;
branches;
next	1.79;

1.79
date	2013.03.11.08.42.55;	author mmetzger;	state Exp;
branches;
next	1.78;

1.78
date	2013.01.01.06.32.49;	author brobecke;	state Exp;
branches;
next	1.77;

1.77
date	2012.11.09.19.58.00;	author tromey;	state Exp;
branches;
next	1.76;

1.76
date	2012.09.21.01.46.42;	author qiyao;	state Exp;
branches;
next	1.75;

1.75
date	2012.08.02.09.36.39;	author qiyao;	state Exp;
branches;
next	1.74;

1.74
date	2012.07.20.11.22.32;	author palves;	state Exp;
branches;
next	1.73;

1.73
date	2012.07.19.17.53.00;	author palves;	state Exp;
branches;
next	1.72;

1.72
date	2012.07.18.19.33.34;	author tromey;	state Exp;
branches;
next	1.71;

1.71
date	2012.05.24.16.51.35;	author palves;	state Exp;
branches;
next	1.70;

1.70
date	2012.05.24.16.39.11;	author palves;	state Exp;
branches;
next	1.69;

1.69
date	2012.04.24.14.33.12;	author qiyao;	state Exp;
branches;
next	1.68;

1.68
date	2012.03.01.21.13.59;	author palves;	state Exp;
branches;
next	1.67;

1.67
date	2012.01.18.11.51.55;	author palves;	state Exp;
branches;
next	1.66;

1.66
date	2012.01.04.08.17.09;	author brobecke;	state Exp;
branches;
next	1.65;

1.65
date	2011.06.06.12.47.07;	author palves;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2011.05.26.18.11.33;	author palves;	state Exp;
branches;
next	1.63;

1.63
date	2011.03.18.14.22.34;	author muller;	state Exp;
branches;
next	1.62;

1.62
date	2011.03.18.13.09.47;	author muller;	state Exp;
branches;
next	1.61;

1.61
date	2011.03.16.17.59.02;	author muller;	state Exp;
branches;
next	1.60;

1.60
date	2011.03.07.15.58.13;	author tromey;	state Exp;
branches;
next	1.59;

1.59
date	2011.03.02.18.09.11;	author msnyder;	state Exp;
branches;
next	1.58;

1.58
date	2011.03.01.20.24.48;	author msnyder;	state Exp;
branches;
next	1.57;

1.57
date	2011.01.10.20.38.50;	author msnyder;	state Exp;
branches;
next	1.56;

1.56
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.55;

1.55
date	2011.01.01.15.33.13;	author brobecke;	state Exp;
branches;
next	1.54;

1.54
date	2010.09.02.22.52.06;	author brobecke;	state Exp;
branches;
next	1.53;

1.53
date	2010.08.18.19.13.33;	author devans;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.19.17.51.23;	author jkratoch;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.19.07.55.43;	author teawater;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.29.05.52.17;	author teawater;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2010.06.22.02.15.46;	author teawater;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.08.02.25.31;	author teawater;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.16.21.11.14;	author msnyder;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.09.20.04.52;	author devans;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.07.02.09.55;	author msnyder;	state Exp;
branches;
next	1.44;

1.44
date	2010.03.08.13.34.38;	author teawater;	state Exp;
branches;
next	1.43;

1.43
date	2010.03.08.01.49.35;	author msnyder;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.01.07.31.38;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2009.12.22.03.16.40;	author teawater;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.24.01.47.51;	author palves;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.22.15.47.31;	author palves;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.22.15.38.59;	author palves;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.20.17.23.38;	author msnyder;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.31.14.56.26;	author palves;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.23.23.42.25;	author msnyder;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.23.17.12.25;	author devans;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.23.16.11.37;	author msnyder;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.23.14.35.30;	author teawater;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.23.01.00.35;	author ppluzhnikov;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.22.19.36.06;	author msnyder;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.22.19.32.11;	author msnyder;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.21.15.21.16;	author msnyder;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.20.23.06.13;	author msnyder;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.20.22.56.04;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.19.09.51.41;	author palves;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.18.16.10.42;	author msnyder;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.15.17.27.54;	author msnyder;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.15.17.15.56;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.15.16.57.36;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.27.02.49.34;	author teawater;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.24.17.58.04;	author brobecke;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.21.05.54.09;	author teawater;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.08.00.50.42;	author msnyder;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2009.09.02.01.31.09;	author teawater;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.01.11.41.41;	author teawater;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.01.03.32.49;	author teawater;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.28.02.10.18;	author teawater;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.21.06.16.51;	author teawater;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.08.01.57.44;	author teawater;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.04.18.19.52;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.22.05.31.26;	author teawater;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.02.17.12.26;	author uweigand;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.17.18.44.23;	author uweigand;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.21.15.48.41;	author palves;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.05.13.24.49;	author uweigand;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.01.17.57.31;	author eliz;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.30.02.58.37;	author teawater;	state Exp;
branches;
next	1.1;

1.1
date	2008.07.20.14.30.11;	author teawater;	state dead;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1;
next	;

1.65.2.1
date	2012.01.06.04.43.26;	author brobecke;	state Exp;
branches;
next	;

1.50.2.1
date	2010.09.02.23.16.42;	author brobecke;	state Exp;
branches;
next	;

1.17.2.1
date	2009.09.21.06.57.03;	author teawater;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2009.09.24.17.59.12;	author brobecke;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2009.09.29.01.53.26;	author teawater;	state Exp;
branches;
next	;

1.9.2.1
date	2009.07.26.23.15.07;	author msnyder;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2009.07.27.02.23.53;	author msnyder;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2009.08.07.00.57.19;	author msnyder;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2009.08.07.00.59.15;	author msnyder;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2009.08.07.01.06.42;	author msnyder;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2009.08.07.01.10.57;	author msnyder;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2009.08.07.02.15.55;	author msnyder;	state Exp;
branches;
next	1.9.2.8;

1.9.2.8
date	2009.08.07.02.53.15;	author msnyder;	state Exp;
branches;
next	1.9.2.9;

1.9.2.9
date	2009.08.07.02.55.22;	author msnyder;	state Exp;
branches;
next	1.9.2.10;

1.9.2.10
date	2009.08.07.03.19.11;	author msnyder;	state Exp;
branches;
next	;

1.1.2.1
date	2008.07.20.14.30.11;	author teawater;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2008.07.27.07.47.56;	author teawater;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2008.07.30.03.43.30;	author teawater;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2008.08.01.20.42.26;	author msnyder;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2008.08.07.03.04.25;	author teawater;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2008.08.15.06.47.49;	author teawater;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2008.09.02.09.18.28;	author teawater;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2008.09.07.01.10.53;	author msnyder;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2008.09.07.01.41.46;	author msnyder;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2008.09.07.07.17.54;	author teawater;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2008.09.11.07.44.05;	author teawater;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2008.09.18.17.17.42;	author teawater;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	2008.09.22.17.26.55;	author msnyder;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	2008.09.22.17.43.11;	author msnyder;	state Exp;
branches;
next	1.1.2.15;

1.1.2.15
date	2008.10.03.23.03.47;	author msnyder;	state Exp;
branches;
next	1.1.2.16;

1.1.2.16
date	2008.10.06.01.13.38;	author msnyder;	state Exp;
branches;
next	1.1.2.17;

1.1.2.17
date	2008.10.06.17.52.17;	author msnyder;	state Exp;
branches;
next	1.1.2.18;

1.1.2.18
date	2008.10.07.01.18.15;	author msnyder;	state Exp;
branches;
next	1.1.2.19;

1.1.2.19
date	2008.10.07.07.37.37;	author teawater;	state Exp;
branches;
next	1.1.2.20;

1.1.2.20
date	2008.10.08.00.26.49;	author msnyder;	state Exp;
branches;
next	1.1.2.21;

1.1.2.21
date	2008.10.09.03.42.44;	author teawater;	state Exp;
branches;
next	;

1.1.4.1
date	2008.10.01.03.16.04;	author msnyder;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2008.10.03.17.50.15;	author msnyder;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2008.10.04.18.56.36;	author msnyder;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2008.10.06.18.00.47;	author msnyder;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2008.10.07.08.33.15;	author teawater;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2008.10.08.00.26.28;	author msnyder;	state Exp;
branches;
next	1.1.4.7;

1.1.4.7
date	2008.10.09.03.46.37;	author teawater;	state Exp;
branches;
next	1.1.4.8;

1.1.4.8
date	2008.10.16.01.50.37;	author teawater;	state Exp;
branches;
next	1.1.4.9;

1.1.4.9
date	2008.11.05.02.52.05;	author teawater;	state Exp;
branches;
next	1.1.4.10;

1.1.4.10
date	2008.11.06.02.18.11;	author teawater;	state Exp;
branches;
next	;

1.1.6.1
date	2008.12.26.21.09.13;	author msnyder;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2008.12.27.20.28.12;	author msnyder;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2008.12.28.20.33.32;	author msnyder;	state Exp;
branches;
next	1.1.6.4;

1.1.6.4
date	2008.12.30.05.42.04;	author teawater;	state Exp;
branches;
next	1.1.6.5;

1.1.6.5
date	2008.12.30.06.28.30;	author teawater;	state Exp;
branches;
next	;


desc
@@


1.90
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@/* Process record and replay target for GDB, the GNU debugger.

   Copyright (C) 2008-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdbcmd.h"
#include "completer.h"
#include "record.h"
#include "observer.h"
#include "inferior.h"
#include "common/common-utils.h"
#include "cli/cli-utils.h"
#include "disasm.h"

#include <ctype.h>

/* This is the debug switch for process record.  */
unsigned int record_debug = 0;

/* The number of instructions to print in "record instruction-history".  */
static unsigned int record_insn_history_size = 10;

/* The variable registered as control variable in the "record
   instruction-history" command.  Necessary for extra input
   validation.  */
static unsigned int record_insn_history_size_setshow_var;

/* The number of functions to print in "record function-call-history".  */
static unsigned int record_call_history_size = 10;

/* The variable registered as control variable in the "record
   call-history" command.  Necessary for extra input validation.  */
static unsigned int record_call_history_size_setshow_var;

struct cmd_list_element *record_cmdlist = NULL;
struct cmd_list_element *record_goto_cmdlist = NULL;
struct cmd_list_element *set_record_cmdlist = NULL;
struct cmd_list_element *show_record_cmdlist = NULL;
struct cmd_list_element *info_record_cmdlist = NULL;

#define DEBUG(msg, args...)						\
  if (record_debug)							\
    fprintf_unfiltered (gdb_stdlog, "record: " msg "\n", ##args)

/* Find the record target in the target stack.  */

static struct target_ops *
find_record_target (void)
{
  struct target_ops *t;

  for (t = current_target.beneath; t != NULL; t = t->beneath)
    if (t->to_stratum == record_stratum)
      return t;

  return NULL;
}

/* Check that recording is active.  Throw an error, if it isn't.  */

static struct target_ops *
require_record_target (void)
{
  struct target_ops *t;

  t = find_record_target ();
  if (t == NULL)
    error (_("No record target is currently active.\n"
	     "Use one of the \"target record-<tab><tab>\" commands first."));

  return t;
}

/* See record.h.  */

int
record_read_memory (struct gdbarch *gdbarch,
		    CORE_ADDR memaddr, gdb_byte *myaddr,
		    ssize_t len)
{
  int ret = target_read_memory (memaddr, myaddr, len);

  if (ret != 0)
    DEBUG ("error reading memory at addr %s len = %ld.\n",
	   paddress (gdbarch, memaddr), (long) len);

  return ret;
}

/* Stop recording.  */

static void
record_stop (struct target_ops *t)
{
  DEBUG ("stop %s", t->to_shortname);

  if (t->to_stop_recording != NULL)
    t->to_stop_recording ();
}

/* Unpush the record target.  */

static void
record_unpush (struct target_ops *t)
{
  DEBUG ("unpush %s", t->to_shortname);

  unpush_target (t);
}

/* See record.h.  */

void
record_disconnect (struct target_ops *t, char *args, int from_tty)
{
  gdb_assert (t->to_stratum == record_stratum);

  DEBUG ("disconnect %s", t->to_shortname);

  record_stop (t);
  record_unpush (t);

  target_disconnect (args, from_tty);
}

/* See record.h.  */

void
record_detach (struct target_ops *t, char *args, int from_tty)
{
  gdb_assert (t->to_stratum == record_stratum);

  DEBUG ("detach %s", t->to_shortname);

  record_stop (t);
  record_unpush (t);

  target_detach (args, from_tty);
}

/* See record.h.  */

void
record_mourn_inferior (struct target_ops *t)
{
  gdb_assert (t->to_stratum == record_stratum);

  DEBUG ("mourn inferior %s", t->to_shortname);

  /* It is safer to not stop recording.  Resources will be freed when
     threads are discarded.  */
  record_unpush (t);

  target_mourn_inferior ();
}

/* See record.h.  */

void
record_kill (struct target_ops *t)
{
  gdb_assert (t->to_stratum == record_stratum);

  DEBUG ("kill %s", t->to_shortname);

  /* It is safer to not stop recording.  Resources will be freed when
     threads are discarded.  */
  record_unpush (t);

  target_kill ();
}

/* Implement "show record debug" command.  */

static void
show_record_debug (struct ui_file *file, int from_tty,
		   struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Debugging of process record target is %s.\n"),
		    value);
}

/* Alias for "target record".  */

static void
cmd_record_start (char *args, int from_tty)
{
  execute_command ("target record-full", from_tty);
}

/* Truncate the record log from the present point
   of replay until the end.  */

static void
cmd_record_delete (char *args, int from_tty)
{
  require_record_target ();

  if (!target_record_is_replaying ())
    {
      printf_unfiltered (_("Already at end of record list.\n"));
      return;
    }

  if (!target_supports_delete_record ())
    {
      printf_unfiltered (_("The current record target does not support "
			   "this operation.\n"));
      return;
    }

  if (!from_tty || query (_("Delete the log from this point forward "
			    "and begin to record the running message "
			    "at current PC?")))
    target_delete_record ();
}

/* Implement the "stoprecord" or "record stop" command.  */

static void
cmd_record_stop (char *args, int from_tty)
{
  struct target_ops *t;

  t = require_record_target ();

  record_stop (t);
  record_unpush (t);

  printf_unfiltered (_("Process record is stopped and all execution "
		       "logs are deleted.\n"));

  observer_notify_record_changed (current_inferior (), 0);
}

/* The "set record" command.  */

static void
set_record_command (char *args, int from_tty)
{
  printf_unfiltered (_("\"set record\" must be followed "
		       "by an apporpriate subcommand.\n"));
  help_list (set_record_cmdlist, "set record ", all_commands, gdb_stdout);
}

/* The "show record" command.  */

static void
show_record_command (char *args, int from_tty)
{
  cmd_show_list (show_record_cmdlist, from_tty, "");
}

/* The "info record" command.  */

static void
info_record_command (char *args, int from_tty)
{
  struct target_ops *t;

  t = find_record_target ();
  if (t == NULL)
    {
      printf_filtered (_("No record target is currently active.\n"));
      return;
    }

  printf_filtered (_("Active record target: %s\n"), t->to_shortname);
  if (t->to_info_record != NULL)
    t->to_info_record ();
}

/* The "record save" command.  */

static void
cmd_record_save (char *args, int from_tty)
{
  char *recfilename, recfilename_buffer[40];

  require_record_target ();

  if (args != NULL && *args != 0)
    recfilename = args;
  else
    {
      /* Default recfile name is "gdb_record.PID".  */
      xsnprintf (recfilename_buffer, sizeof (recfilename_buffer),
                "gdb_record.%d", ptid_get_pid (inferior_ptid));
      recfilename = recfilename_buffer;
    }

  target_save_record (recfilename);
}

/* "record goto" command.  Argument is an instruction number,
   as given by "info record".

   Rewinds the recording (forward or backward) to the given instruction.  */

void
cmd_record_goto (char *arg, int from_tty)
{
  ULONGEST insn;

  if (arg == NULL || *arg == '\0')
    error (_("Command requires an argument (insn number to go to)."));

  insn = parse_and_eval_long (arg);

  require_record_target ();
  target_goto_record (insn);
}

/* The "record goto begin" command.  */

static void
cmd_record_goto_begin (char *arg, int from_tty)
{
  if (arg != NULL && *arg != '\0')
    error (_("Junk after argument: %s."), arg);

  require_record_target ();
  target_goto_record_begin ();
}

/* The "record goto end" command.  */

static void
cmd_record_goto_end (char *arg, int from_tty)
{
  if (arg != NULL && *arg != '\0')
    error (_("Junk after argument: %s."), arg);

  require_record_target ();
  target_goto_record_end ();
}

/* Read an instruction number from an argument string.  */

static ULONGEST
get_insn_number (char **arg)
{
  ULONGEST number;
  const char *begin, *end, *pos;

  begin = *arg;
  pos = skip_spaces_const (begin);

  if (!isdigit (*pos))
    error (_("Expected positive number, got: %s."), pos);

  number = strtoulst (pos, &end, 10);

  *arg += (end - begin);

  return number;
}

/* Read a context size from an argument string.  */

static int
get_context_size (char **arg)
{
  char *pos;
  int number;

  pos = skip_spaces (*arg);

  if (!isdigit (*pos))
    error (_("Expected positive number, got: %s."), pos);

  return strtol (pos, arg, 10);
}

/* Complain about junk at the end of an argument string.  */

static void
no_chunk (char *arg)
{
  if (*arg != 0)
    error (_("Junk after argument: %s."), arg);
}

/* Read instruction-history modifiers from an argument string.  */

static int
get_insn_history_modifiers (char **arg)
{
  int modifiers;
  char *args;

  modifiers = 0;
  args = *arg;

  if (args == NULL)
    return modifiers;

  while (*args == '/')
    {
      ++args;

      if (*args == '\0')
	error (_("Missing modifier."));

      for (; *args; ++args)
	{
	  if (isspace (*args))
	    break;

	  if (*args == '/')
	    continue;

	  switch (*args)
	    {
	    case 'm':
	      modifiers |= DISASSEMBLY_SOURCE;
	      modifiers |= DISASSEMBLY_FILENAME;
	      break;
	    case 'r':
	      modifiers |= DISASSEMBLY_RAW_INSN;
	      break;
	    case 'f':
	      modifiers |= DISASSEMBLY_OMIT_FNAME;
	      break;
	    case 'p':
	      modifiers |= DISASSEMBLY_OMIT_PC;
	      break;
	    default:
	      error (_("Invalid modifier: %c."), *args);
	    }
	}

      args = skip_spaces (args);
    }

  /* Update the argument string.  */
  *arg = args;

  return modifiers;
}

/* The "set record instruction-history-size / set record
   function-call-history-size" commands are unsigned, with UINT_MAX
   meaning unlimited.  The target interfaces works with signed int
   though, to indicate direction, so map "unlimited" to INT_MAX, which
   is about the same as unlimited in practice.  If the user does have
   a log that huge, she can fetch it in chunks across several requests,
   but she'll likely have other problems first...  */

static int
command_size_to_target_size (unsigned int size)
{
  gdb_assert (size <= INT_MAX || size == UINT_MAX);

  if (size == UINT_MAX)
    return INT_MAX;
  else
    return size;
}

/* The "record instruction-history" command.  */

static void
cmd_record_insn_history (char *arg, int from_tty)
{
  int flags, size;

  require_record_target ();

  flags = get_insn_history_modifiers (&arg);

  size = command_size_to_target_size (record_insn_history_size);

  if (arg == NULL || *arg == 0 || strcmp (arg, "+") == 0)
    target_insn_history (size, flags);
  else if (strcmp (arg, "-") == 0)
    target_insn_history (-size, flags);
  else
    {
      ULONGEST begin, end;

      begin = get_insn_number (&arg);

      if (*arg == ',')
	{
	  arg = skip_spaces (++arg);

	  if (*arg == '+')
	    {
	      arg += 1;
	      size = get_context_size (&arg);

	      no_chunk (arg);

	      target_insn_history_from (begin, size, flags);
	    }
	  else if (*arg == '-')
	    {
	      arg += 1;
	      size = get_context_size (&arg);

	      no_chunk (arg);

	      target_insn_history_from (begin, -size, flags);
	    }
	  else
	    {
	      end = get_insn_number (&arg);

	      no_chunk (arg);

	      target_insn_history_range (begin, end, flags);
	    }
	}
      else
	{
	  no_chunk (arg);

	  target_insn_history_from (begin, size, flags);
	}

      dont_repeat ();
    }
}

/* Read function-call-history modifiers from an argument string.  */

static int
get_call_history_modifiers (char **arg)
{
  int modifiers;
  char *args;

  modifiers = 0;
  args = *arg;

  if (args == NULL)
    return modifiers;

  while (*args == '/')
    {
      ++args;

      if (*args == '\0')
	error (_("Missing modifier."));

      for (; *args; ++args)
	{
	  if (isspace (*args))
	    break;

	  if (*args == '/')
	    continue;

	  switch (*args)
	    {
	    case 'l':
	      modifiers |= RECORD_PRINT_SRC_LINE;
	      break;
	    case 'i':
	      modifiers |= RECORD_PRINT_INSN_RANGE;
	      break;
	    default:
	      error (_("Invalid modifier: %c."), *args);
	    }
	}

      args = skip_spaces (args);
    }

  /* Update the argument string.  */
  *arg = args;

  return modifiers;
}

/* The "record function-call-history" command.  */

static void
cmd_record_call_history (char *arg, int from_tty)
{
  int flags, size;

  require_record_target ();

  flags = get_call_history_modifiers (&arg);

  size = command_size_to_target_size (record_call_history_size);

  if (arg == NULL || *arg == 0 || strcmp (arg, "+") == 0)
    target_call_history (size, flags);
  else if (strcmp (arg, "-") == 0)
    target_call_history (-size, flags);
  else
    {
      ULONGEST begin, end;

      begin = get_insn_number (&arg);

      if (*arg == ',')
	{
	  arg = skip_spaces (++arg);

	  if (*arg == '+')
	    {
	      arg += 1;
	      size = get_context_size (&arg);

	      no_chunk (arg);

	      target_call_history_from (begin, size, flags);
	    }
	  else if (*arg == '-')
	    {
	      arg += 1;
	      size = get_context_size (&arg);

	      no_chunk (arg);

	      target_call_history_from (begin, -size, flags);
	    }
	  else
	    {
	      end = get_insn_number (&arg);

	      no_chunk (arg);

	      target_call_history_range (begin, end, flags);
	    }
	}
      else
	{
	  no_chunk (arg);

	  target_call_history_from (begin, size, flags);
	}

      dont_repeat ();
    }
}

/* Helper for "set record instruction-history-size" and "set record
   function-call-history-size" input validation.  COMMAND_VAR is the
   variable registered in the command as control variable.  *SETTING
   is the real setting the command allows changing.  */

static void
validate_history_size (unsigned int *command_var, unsigned int *setting)
{
  if (*command_var != UINT_MAX && *command_var > INT_MAX)
    {
      unsigned int new_value = *command_var;

      /* Restore previous value.  */
      *command_var = *setting;
      error (_("integer %u out of range"), new_value);
    }

  /* Commit new value.  */
  *setting = *command_var;
}

/* Called by do_setshow_command.  We only want values in the
   [0..INT_MAX] range, while the command's machinery accepts
   [0..UINT_MAX].  See command_size_to_target_size.  */

static void
set_record_insn_history_size (char *args, int from_tty,
			      struct cmd_list_element *c)
{
  validate_history_size (&record_insn_history_size_setshow_var,
			 &record_insn_history_size);
}

/* Called by do_setshow_command.  We only want values in the
   [0..INT_MAX] range, while the command's machinery accepts
   [0..UINT_MAX].  See command_size_to_target_size.  */

static void
set_record_call_history_size (char *args, int from_tty,
			      struct cmd_list_element *c)
{
  validate_history_size (&record_call_history_size_setshow_var,
			 &record_call_history_size);
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_record;

void
_initialize_record (void)
{
  struct cmd_list_element *c;

  add_setshow_zuinteger_cmd ("record", no_class, &record_debug,
			     _("Set debugging of record/replay feature."),
			     _("Show debugging of record/replay feature."),
			     _("When enabled, debugging output for "
			       "record/replay feature is displayed."),
			     NULL, show_record_debug, &setdebuglist,
			     &showdebuglist);

  add_setshow_uinteger_cmd ("instruction-history-size", no_class,
			    &record_insn_history_size_setshow_var, _("\
Set number of instructions to print in \"record instruction-history\"."), _("\
Show number of instructions to print in \"record instruction-history\"."), _("\
A size of \"unlimited\" means unlimited instructions.  The default is 10."),
			    set_record_insn_history_size, NULL,
			    &set_record_cmdlist, &show_record_cmdlist);

  add_setshow_uinteger_cmd ("function-call-history-size", no_class,
			    &record_call_history_size_setshow_var, _("\
Set number of function to print in \"record function-call-history\"."), _("\
Show number of functions to print in \"record function-call-history\"."), _("\
A size of \"unlimited\" means unlimited lines.  The default is 10."),
			    set_record_call_history_size, NULL,
			    &set_record_cmdlist, &show_record_cmdlist);

  c = add_prefix_cmd ("record", class_obscure, cmd_record_start,
		      _("Start recording."),
		      &record_cmdlist, "record ", 0, &cmdlist);
  set_cmd_completer (c, filename_completer);

  add_com_alias ("rec", "record", class_obscure, 1);
  add_prefix_cmd ("record", class_support, set_record_command,
		  _("Set record options"), &set_record_cmdlist,
		  "set record ", 0, &setlist);
  add_alias_cmd ("rec", "record", class_obscure, 1, &setlist);
  add_prefix_cmd ("record", class_support, show_record_command,
		  _("Show record options"), &show_record_cmdlist,
		  "show record ", 0, &showlist);
  add_alias_cmd ("rec", "record", class_obscure, 1, &showlist);
  add_prefix_cmd ("record", class_support, info_record_command,
		  _("Info record options"), &info_record_cmdlist,
		  "info record ", 0, &infolist);
  add_alias_cmd ("rec", "record", class_obscure, 1, &infolist);

  c = add_cmd ("save", class_obscure, cmd_record_save,
	       _("Save the execution log to a file.\n\
Argument is optional filename.\n\
Default filename is 'gdb_record.<process_id>'."),
	       &record_cmdlist);
  set_cmd_completer (c, filename_completer);

  add_cmd ("delete", class_obscure, cmd_record_delete,
	   _("Delete the rest of execution log and start recording it anew."),
           &record_cmdlist);
  add_alias_cmd ("d", "delete", class_obscure, 1, &record_cmdlist);
  add_alias_cmd ("del", "delete", class_obscure, 1, &record_cmdlist);

  add_cmd ("stop", class_obscure, cmd_record_stop,
	   _("Stop the record/replay target."),
           &record_cmdlist);
  add_alias_cmd ("s", "stop", class_obscure, 1, &record_cmdlist);

  add_prefix_cmd ("goto", class_obscure, cmd_record_goto, _("\
Restore the program to its state at instruction number N.\n\
Argument is instruction number, as shown by 'info record'."),
		  &record_goto_cmdlist, "record goto ", 1, &record_cmdlist);

  add_cmd ("begin", class_obscure, cmd_record_goto_begin,
	   _("Go to the beginning of the execution log."),
	   &record_goto_cmdlist);
  add_alias_cmd ("start", "begin", class_obscure, 1, &record_goto_cmdlist);

  add_cmd ("end", class_obscure, cmd_record_goto_end,
	   _("Go to the end of the execution log."),
	   &record_goto_cmdlist);

  add_cmd ("instruction-history", class_obscure, cmd_record_insn_history, _("\
Print disassembled instructions stored in the execution log.\n\
With a /m modifier, source lines are included (if available).\n\
With a /r modifier, raw instructions in hex are included.\n\
With a /f modifier, function names are omitted.\n\
With a /p modifier, current position markers are omitted.\n\
With no argument, disassembles ten more instructions after the previous \
disassembly.\n\
\"record instruction-history -\" disassembles ten instructions before a \
previous disassembly.\n\
One argument specifies an instruction number as shown by 'info record', and \
ten instructions are disassembled after that instruction.\n\
Two arguments with comma between them specify starting and ending instruction \
numbers to disassemble.\n\
If the second argument is preceded by '+' or '-', it specifies the distance \
from the first argument.\n\
The number of instructions to disassemble can be defined with \"set record \
instruction-history-size\"."),
           &record_cmdlist);

  add_cmd ("function-call-history", class_obscure, cmd_record_call_history, _("\
Prints the execution history at function granularity.\n\
It prints one line for each sequence of instructions that belong to the same \
function.\n\
Without modifiers, it prints the function name.\n\
With a /l modifier, the source file and line number range is included.\n\
With a /i modifier, the instruction number range is included.\n\
With no argument, prints ten more lines after the previous ten-line print.\n\
\"record function-call-history -\" prints ten lines before a previous ten-line \
print.\n\
One argument specifies a function number as shown by 'info record', and \
ten lines are printed after that function.\n\
Two arguments with comma between them specify a range of functions to print.\n\
If the second argument is preceded by '+' or '-', it specifies the distance \
from the first argument.\n\
The number of functions to print can be defined with \"set record \
function-call-history-size\"."),
           &record_cmdlist);

  /* Sync command control variables.  */
  record_insn_history_size_setshow_var = record_insn_history_size;
  record_call_history_size_setshow_var = record_call_history_size;
}
@


1.89
log
@record: upcase record_print_flag enumeration constants

	* record.h (record_print_flag) <record_print_src_line,
	record_print_insn_range>: Rename into ...
	(record_print_flag) <record_print_src_line,
	record_print_insn_range>: ... this.  Update all users.
@
text
@d303 1
a303 1
                "gdb_record.%d", PIDGET (inferior_ptid));
@


1.88
log
@The "record goto" command scans its arguments for "begin", "start", or "end".
Turn those into sub-commands.

Document the "record goto" command.
@
text
@d573 1
a573 1
	      modifiers |= record_print_src_line;
d576 1
a576 1
	      modifiers |= record_print_insn_range;
@


1.87
log
@-Wpointer-sign: record.c.

../../src/gdb/record.c: In function ‘set_record_insn_history_size’:
../../src/gdb/record.c:670:5: error: pointer targets in passing argument 2 of ‘validate_history_size’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/record.c:646:1: note: expected ‘int *’ but argument is of type ‘unsigned int *’
../../src/gdb/record.c: In function ‘set_record_call_history_size’:
../../src/gdb/record.c:682:5: error: pointer targets in passing argument 2 of ‘validate_history_size’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/record.c:646:1: note: expected ‘int *’ but argument is of type ‘unsigned int *’

This fixes it in the obvious way.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* record.c (validate_history_size): Make parameter 'setting'
	unsigned.
@
text
@d51 1
d318 1
a318 1
  require_record_target ();
d323 25
a347 8
  if (strncmp (arg, "start", strlen ("start")) == 0
      || strncmp (arg, "begin", strlen ("begin")) == 0)
    target_goto_record_begin ();
  else if (strncmp (arg, "end", strlen ("end")) == 0)
    target_goto_record_end ();
  else
    {
      ULONGEST insn;
d349 2
a350 3
      insn = parse_and_eval_long (arg);
      target_goto_record (insn);
    }
d771 1
a771 1
  add_cmd ("goto", class_obscure, cmd_record_goto, _("\
d774 10
a783 1
	   &record_cmdlist);
@


1.86
log
@Accept "set foo unlimited" in integer/uinteger/zuinteger_unlimited commands.

Currently, several commands take "0" or "-1" to mean "unlimited".

"show" knows when to print "unlimited":

 (gdb) show height
 Number of lines gdb thinks are in a page is 45.
 (gdb) set height 0
 (gdb) show height
 Number of lines gdb thinks are in a page is unlimited.

However, the user can't herself specify "unlimited" directly:

 (gdb) set height unlimited
 No symbol table is loaded.  Use the "file" command.
 (gdb)

This patch addresses that, by adjusting the set handler for all
integer/uinteger/zuinteger_unlimited commands to accept literal
"unlimited".  It also installs a completer.  Presently, we complete on
symbols by default, and at
<http://sourceware.org/ml/gdb-patches/2013-03/msg00864.html> I've
shown a WIP prototype that tried to keep that half working in these
commands.  In the end, it turned out to be more complicated than
justifiable, IMO.  It's super rare to want to pass the value of a
variable/symbol in the program to a GDB set/show knob.  That'll still
work, it's just that we won't assist with completion anymore.  This
patch just sticks with the simple, and completes on "unlimited", and
nothing else.  This simplification means that

  "set he<tab><tab>"

is all it takes to get to:

  "set height unlimited"

The patch then goes through all integer/uinteger/zuinteger_unlimited
commands in the tree, and updates both the online help and the manual
to mention that "unlimited" is accepted in addition to 0/-1.  In the
cases where the command had no online help text at all, this adds it.
I've tried to make the texts read in a way that "unlimited" is
suggested before "0" or "-1" is.

Tested on x86_64 Fedora 17.

gdb/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* cli/cli-decode.c (integer_unlimited_completer): New function.
	(add_setshow_integer_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd): Install the "unlimited"
	completer.
	* cli/cli-setshow.c: Include "cli/cli-utils.h".
	(is_unlimited_literal): New function.
	(do_set_command): Handle literal "unlimited" arguments.
	* frame.c (_initialize_frame) <set backtrace limit>: Document
	"unlimited".
	* printcmd.c (_initialize_printcmd) <set print
	max-symbolic-offset>: Add help text.
	* record-full.c (_initialize_record_full) <set record full
	insn-number-max>: Likewise.
	* record.c (_initialize_record) <set record
	instruction-history-size, set record function-call-history-size>:
	Add help text.
	* ser-tcp.c (_initialize_ser_tcp) <set tcp connect-timeout>: Add
	help text.
	* tracepoint.c (_initialize_tracepoint) <set trace-buffer-size>:
	Likewise.
	* source.c (_initialize_source) <set listsize>: Add help text.
	* utils.c (initialize_utils) <set height, set width>: Likewise.
	<set pagination>: Mention "set height unlimited".
	* valprint.c (_initialize_valprint) <set print elements, set print
	repeats>: Document "unlimited".

gdb/doc/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (Process Record and Replay): Document that "set
	record full insn-number-max", "set record
	instruction-history-size" and "set record
	function-call-history-size" accept "unlimited".
	(Backtrace): Document that "set backtrace limit" accepts
	"unlimited".
	(List): Document that "set listsize" accepts "unlimited".
	(Print Settings)" Document that "set print max-symbolic-offset",
	"set print elements" and "set print repeats" accept "unlimited".
	(Starting and Stopping Trace Experiments): Document that "set
	trace-buffer-size" accepts "unlimited".
	(Remote Configuration): Document that "set tcp connect-timeout"
	accepts "unlimited".
	(Command History): Document that "set history size" accepts
	"unlimited".
	(Screen Size): Document that "set height" and "set width" accepts
	"unlimited".  Adjust "set pagination"'s description to suggest
	"set height unlimited" instead of "set height 0".

gdb/testsuite/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* gdb.base/completion.exp: Test "set height", "set listsize" and
	"set trace-buffer-size" completion.
	* gdb.base/setshow.exp: Test "set height unlimited".
	* gdb.trace/trace-buffer-size.exp: Test "set trace-buffer-size
	unlimited".
@
text
@d646 1
a646 1
validate_history_size (unsigned int *command_var, int *setting)
@


1.85
log
@record: fix instruction-history-size regression

	* record.c (command_size_to_target_size): Fix size comparison.
	Change parameter type from pointer to integer to integer.
	Update all users.
@
text
@d704 2
a705 2
Show number of instructions to print in \"record instruction-history\"."),
			    NULL,
d712 2
a713 2
Show number of functions to print in \"record function-call-history\"."),
			    NULL,
@


1.84
log
@"set record instruction-history-size"/"set record function-call-history-size" range validation.

While the commands are uinteger, the target interfaces are limited to
INT_MAX.  Don't let the user request more than we can handle.

gdb/
2013-03-26  Pedro Alves  <palves@@redhat.com>

	* record.c (record_insn_history_size_setshow_var)
	(record_call_history_size_setshow_var): New globals.
	(command_size_to_target_size): New function.
	(cmd_record_insn_history, cmd_record_call_history): Use
	command_size_to_target_size instead of cast.
	(validate_history_size, set_record_insn_history_size)
	(set_record_call_history_size): New functions.
	(_initialize_record): Install set_record_insn_history_size and
	set_record_call_history_size as "set" hooks of "set record
	instruction-history-size" and "set record
	function-call-history-size".
@
text
@d445 2
a446 2
   a log that huge, she can can fetch it in chunks across several
   requests, but she'll likely have other problems first...  */
d449 1
a449 1
command_size_to_target_size (unsigned int *command)
d451 1
a451 1
  gdb_assert (*command <= INT_MAX || *command == UINT_MAX);
d453 1
a453 1
  if (record_call_history_size == UINT_MAX)
d456 1
a456 1
    return *command;
d470 1
a470 1
  size = command_size_to_target_size (&record_insn_history_size);
d586 1
a586 1
  size = command_size_to_target_size (&record_call_history_size);
@


1.83
log
@Add a disassembly flag to omit the pc prefix and use it in the "record
instruction-history" command of record-btrace.

The pc prefix would appear multiple times in the branch trace disassembly,
which is more confusing than helpful.

gdb/
	* record-btrace.c (btrace_insn_history): Omit the pc prefix in
	the instruction history disassembly.
	* disasm.c (dump_insns): Omit the pc prefix, if requested.
	* disasm.h (DISASSEMBLY_OMIT_PC): New.
@
text
@d38 5
d46 4
d440 19
d470 1
a470 5
  /* We use a signed size to also indicate the direction.  Make sure that
     unlimited remains unlimited.  */
  size = (int) record_insn_history_size;
  if (size < 0)
    size = INT_MAX;
d586 1
a586 5
  /* We use a signed size to also indicate the direction.  Make sure that
     unlimited remains unlimited.  */
  size = (int) record_call_history_size;
  if (size < 0)
    size = INT_MAX;
d640 45
d702 1
a702 1
			    &record_insn_history_size, _("\
d705 3
a707 2
			    NULL, NULL, NULL, &set_record_cmdlist,
			    &show_record_cmdlist);
d710 1
a710 1
			    &record_call_history_size, _("\
d713 3
a715 2
			    NULL, NULL, NULL, &set_record_cmdlist,
			    &show_record_cmdlist);
d797 4
@


1.82
log
@Add command to print the function names from recorded instructions.

This command provides a quick high-level overview over the recorded execution
log at function granularity without having to reverse-step.

gdb/
	* target.c (target_call_history, target_call_history_from,
	target_call_history_range): New.
	* target.h (target_ops) <to_call_history, to_call_history_from,
	to_call_history_range>: New fields.
	(target_call_history, target_call_history_from,
	target_call_history_range): New declaration.
	* record.c (get_call_history_modifiers, cmd_record_call_history,
	record_call_history_size): New.
	(_initialize_record): Add the "record function-call-history" command.
	Add "set/show record function-call-history-size" commands.
	* record.h (record_print_flag): New.
@
text
@d414 3
d697 1
@


1.81
log
@Add a command to provide a disassembly of the execution trace log.

gdb/
	* target.h (target_ops) <to_insn_history, to_insn_history_from,
	to_insn_history_range>: New fields.
	(target_insn_history): New.
	(target_insn_history_from): New.
	(target_insn_history_range): New.
	* target.c (target_insn_history): New.
	(target_insn_history_from): New.
	(target_insn_history_range): New.
	* record.c: Include cli/cli-utils.h, disasm.h, ctype.h.
	(record_insn_history_size): New.
	(get_insn_number): New.
	(get_context_size): New.
	(no_chunk): New.
	(get_insn_history_modifiers): New.
	(cmd_record_insn_history): New.
	(_initialize_record): Add "set/show record instruction-history-size"
	command. Add "record instruction-history" command.
@
text
@d38 3
d497 120
d640 7
d707 19
@


1.80
log
@Provide default target methods for record targets that are likely to be shared
between different record targets.

gdb/
	* record.h (record_disconnect): New.
	(record_detach): New.
	(record_mourn_inferior): New.
	(record_kill): New.
	* record-full.c (record_disconnect, record_detach,
	record_mourn_inferior, record_kill): Move to...
	* record.c: ...here.
	(DEBUG): New.
	(record_stop): New.
	(record_unpush): New.
	(cmd_record_stop): Call record_stop. Replace unpush_target
	call with record_unpush call.
	(record_disconnect, record_detach): Assert that the target
	is of record stratum. Call record_unpush, record_stop, and
	DEBUG.
	(record_mourn_inferior, record_kill): Assert that the target
	is of record stratum. Call record_unpush and DEBUG.
@
text
@d27 4
d35 3
d324 170
d510 7
d558 19
@


1.79
log
@Split record.h into record.h and record-full.h.
Split record.c into record.c and record-full.c.

The split leaves the command part in record.c and moves the target part into
record-full.c.

gdb/
	* record.h: Split into this and ...
	* record-full.h: ... this.
	* record.c: Split into this and ...
	* record-full.c: ... this.
	* target.h (target_ops): Add new fields to_info_record,
	to_save_record, to_delete_record, to_record_is_replaying,
	to_goto_record_begin, to_goto_record_end, to_goto_record.
	(target_info_record): New.
	(target_save_record): New.
	(target_supports_delete_record): New.
	(target_delete_record): New.
	(target_record_is_replaying): New.
	(target_goto_record_begin): New.
	(target_goto_record_end): New.
	(target_goto_record): New.
	* target.c (target_info_record): New.
	(target_save_record): New.
	(target_supports_delete_record): New.
	(target_delete_record): New.
	(target_record_is_replaying): New.
	(target_goto_record_begin): New.
	(target_goto_record_end): New.
	(target_goto_record): New.
	* record.h: Declare struct cmd_list_element.
	(record_cmdlist): New declaration.
	(set_record_cmdlist): New declaration.
	(show_record_cmdlist): New declaration.
	(info_record_cmdlist): New declaration.
	(cmd_record_goto): New declaration.
	* record.c: Remove unnecessary includes.
	Include inferior.h.
	(cmd_record_goto): Remove declaration.
	(record_cmdlist): Now extern. Initialize.
	(set_record_cmdlist): Now extern. Initialize.
	(show_record_cmdlist): Now extern. Initialize.
	(info_record_cmdlist): Now extern. Initialize.
	(find_record_target): New.
	(require_record_target): New.
	(cmd_record_start): Update.
	(cmd_record_delete): Remove target-specific code.
	Call target_delete_record.
	(cmd_record_stop): Unpush any record target.
	(set_record_insn_max_num): Move to record-full.c
	(set_record_command): Add comment.
	(show_record_command): Add comment.
	(info_record_command): Update comment.
	Remove target-specific code.
	Call the record target's to_info_record.
	(cmd_record_start): New.
	(cmd_record_goto): Now extern.
	Remove target-specific code.
	Call target_goto_begin,  target_goto_end, or target_goto.
	(_initialize_record): Move record target ops initialization to
	record-full.c.
	Change "record" command help text.
	Move "record restore", "record set", and "record show" commands to
	record-full.c.
	* Makefile.in (SFILES): Add record-full.c.
	(HFILES_NO_SRCDIR): Add record-full.h.
	(COMMON_OBS): Add record-full.o.
	* amd64-linux-tdep.c: Include record-full.h instead of record.h.
	* arm-tdep.c: Include record-full.h.
	* i386-linux-tdep.c: Include record-full.h instead of record.h.
	* i386-tdep.c: Include record-full.h.
	* infrun.c: Include record-full.h.
	* linux-record.c: Include record-full.h.
	* moxie-tdep.c: Include record-full.h.
	* record-full.c: Include record-full.h.
	Change module comment.
	(set_record_full_cmdlist): New.
	(show_record_full_cmdlist): New.
	(record_full_cmdlist): New.
	(record_goto_insn): New declaration.
	(record_save): New declaration.
	(record_check_insn_num): Change query string.
	(record_info): New.
	(record_delete): New.
	(record_is_replaying): New.
	(record_goto_entry): New.
	(record_goto_begin): New.
	(record_goto_end): New.
	(record_goto): New.
	(init_record_ops): Update.
	(init_record_core_ops): Update.
	(cmd_record_save): Rename to record_save. Remove target and arg checks.
	(cmd_record_start): New.
	(set_record_insn_max_num): Moved from record.c
	(set_record_full_command): New.
	(show_record_full_command): New.
	(_initialize_record_full): New.
@
text
@d36 4
d78 4
a81 4
  if (ret && record_debug)
    printf_unfiltered (_("Process record: error reading memory "
			 "at addr %s len = %ld.\n"),
		       paddress (gdbarch, memaddr), (long) len);
d85 83
d221 3
a223 1
  unpush_target (t);
@


1.78
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a21 4
#include "regcache.h"
#include "gdbthread.h"
#include "event-top.h"
#include "exceptions.h"
a22 3
#include "arch-utils.h"
#include "gdbcore.h"
#include "exec.h"
a23 5
#include "elf-bfd.h"
#include "gcore.h"
#include "event-loop.h"
#include "inf-loop.h"
#include "gdb_bfd.h"
d25 2
a26 118

#include <signal.h>

/* This module implements "target record", also known as "process
   record and replay".  This target sits on top of a "normal" target
   (a target that "has execution"), and provides a record and replay
   functionality, including reverse debugging.

   Target record has two modes: recording, and replaying.

   In record mode, we intercept the to_resume and to_wait methods.
   Whenever gdb resumes the target, we run the target in single step
   mode, and we build up an execution log in which, for each executed
   instruction, we record all changes in memory and register state.
   This is invisible to the user, to whom it just looks like an
   ordinary debugging session (except for performance degredation).

   In replay mode, instead of actually letting the inferior run as a
   process, we simulate its execution by playing back the recorded
   execution log.  For each instruction in the log, we simulate the
   instruction's side effects by duplicating the changes that it would
   have made on memory and registers.  */

#define DEFAULT_RECORD_INSN_MAX_NUM	200000

#define RECORD_IS_REPLAY \
     (record_list->next || execution_direction == EXEC_REVERSE)

#define RECORD_FILE_MAGIC	netorder32(0x20091016)

/* These are the core structs of the process record functionality.

   A record_entry is a record of the value change of a register
   ("record_reg") or a part of memory ("record_mem").  And each
   instruction must have a struct record_entry ("record_end") that
   indicates that this is the last struct record_entry of this
   instruction.

   Each struct record_entry is linked to "record_list" by "prev" and
   "next" pointers.  */

struct record_mem_entry
{
  CORE_ADDR addr;
  int len;
  /* Set this flag if target memory for this entry
     can no longer be accessed.  */
  int mem_entry_not_accessible;
  union
  {
    gdb_byte *ptr;
    gdb_byte buf[sizeof (gdb_byte *)];
  } u;
};

struct record_reg_entry
{
  unsigned short num;
  unsigned short len;
  union 
  {
    gdb_byte *ptr;
    gdb_byte buf[2 * sizeof (gdb_byte *)];
  } u;
};

struct record_end_entry
{
  enum gdb_signal sigval;
  ULONGEST insn_num;
};

enum record_type
{
  record_end = 0,
  record_reg,
  record_mem
};

/* This is the data structure that makes up the execution log.

   The execution log consists of a single linked list of entries
   of type "struct record_entry".  It is doubly linked so that it
   can be traversed in either direction.

   The start of the list is anchored by a struct called
   "record_first".  The pointer "record_list" either points to the
   last entry that was added to the list (in record mode), or to the
   next entry in the list that will be executed (in replay mode).

   Each list element (struct record_entry), in addition to next and
   prev pointers, consists of a union of three entry types: mem, reg,
   and end.  A field called "type" determines which entry type is
   represented by a given list element.

   Each instruction that is added to the execution log is represented
   by a variable number of list elements ('entries').  The instruction
   will have one "reg" entry for each register that is changed by 
   executing the instruction (including the PC in every case).  It 
   will also have one "mem" entry for each memory change.  Finally,
   each instruction will have an "end" entry that separates it from
   the changes associated with the next instruction.  */

struct record_entry
{
  struct record_entry *prev;
  struct record_entry *next;
  enum record_type type;
  union
  {
    /* reg */
    struct record_reg_entry reg;
    /* mem */
    struct record_mem_entry mem;
    /* end */
    struct record_end_entry end;
  } u;
};
d31 4
a34 1575
/* If true, query if PREC cannot record memory
   change of next instruction.  */
int record_memory_query = 0;

struct record_core_buf_entry
{
  struct record_core_buf_entry *prev;
  struct target_section *p;
  bfd_byte *buf;
};

/* Record buf with core target.  */
static gdb_byte *record_core_regbuf = NULL;
static struct target_section *record_core_start;
static struct target_section *record_core_end;
static struct record_core_buf_entry *record_core_buf_list = NULL;

/* The following variables are used for managing the linked list that
   represents the execution log.

   record_first is the anchor that holds down the beginning of the list.

   record_list serves two functions:
     1) In record mode, it anchors the end of the list.
     2) In replay mode, it traverses the list and points to
        the next instruction that must be emulated.

   record_arch_list_head and record_arch_list_tail are used to manage
   a separate list, which is used to build up the change elements of
   the currently executing instruction during record mode.  When this
   instruction has been completely annotated in the "arch list", it 
   will be appended to the main execution log.  */

static struct record_entry record_first;
static struct record_entry *record_list = &record_first;
static struct record_entry *record_arch_list_head = NULL;
static struct record_entry *record_arch_list_tail = NULL;

/* 1 ask user. 0 auto delete the last struct record_entry.  */
static int record_stop_at_limit = 1;
/* Maximum allowed number of insns in execution log.  */
static unsigned int record_insn_max_num = DEFAULT_RECORD_INSN_MAX_NUM;
/* Actual count of insns presently in execution log.  */
static int record_insn_num = 0;
/* Count of insns logged so far (may be larger
   than count of insns presently in execution log).  */
static ULONGEST record_insn_count;

/* The target_ops of process record.  */
static struct target_ops record_ops;
static struct target_ops record_core_ops;

/* The beneath function pointers.  */
static struct target_ops *record_beneath_to_resume_ops;
static void (*record_beneath_to_resume) (struct target_ops *, ptid_t, int,
                                         enum gdb_signal);
static struct target_ops *record_beneath_to_wait_ops;
static ptid_t (*record_beneath_to_wait) (struct target_ops *, ptid_t,
					 struct target_waitstatus *,
					 int);
static struct target_ops *record_beneath_to_store_registers_ops;
static void (*record_beneath_to_store_registers) (struct target_ops *,
                                                  struct regcache *,
						  int regno);
static struct target_ops *record_beneath_to_xfer_partial_ops;
static LONGEST (*record_beneath_to_xfer_partial) (struct target_ops *ops,
						  enum target_object object,
						  const char *annex,
						  gdb_byte *readbuf,
						  const gdb_byte *writebuf,
						  ULONGEST offset,
						  LONGEST len);
static int (*record_beneath_to_insert_breakpoint) (struct gdbarch *,
						   struct bp_target_info *);
static int (*record_beneath_to_remove_breakpoint) (struct gdbarch *,
						   struct bp_target_info *);
static int (*record_beneath_to_stopped_by_watchpoint) (void);
static int (*record_beneath_to_stopped_data_address) (struct target_ops *,
						      CORE_ADDR *);
static void (*record_beneath_to_async) (void (*) (enum inferior_event_type, void *), void *);

/* Alloc and free functions for record_reg, record_mem, and record_end 
   entries.  */

/* Alloc a record_reg record entry.  */

static inline struct record_entry *
record_reg_alloc (struct regcache *regcache, int regnum)
{
  struct record_entry *rec;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);

  rec = (struct record_entry *) xcalloc (1, sizeof (struct record_entry));
  rec->type = record_reg;
  rec->u.reg.num = regnum;
  rec->u.reg.len = register_size (gdbarch, regnum);
  if (rec->u.reg.len > sizeof (rec->u.reg.u.buf))
    rec->u.reg.u.ptr = (gdb_byte *) xmalloc (rec->u.reg.len);

  return rec;
}

/* Free a record_reg record entry.  */

static inline void
record_reg_release (struct record_entry *rec)
{
  gdb_assert (rec->type == record_reg);
  if (rec->u.reg.len > sizeof (rec->u.reg.u.buf))
    xfree (rec->u.reg.u.ptr);
  xfree (rec);
}

/* Alloc a record_mem record entry.  */

static inline struct record_entry *
record_mem_alloc (CORE_ADDR addr, int len)
{
  struct record_entry *rec;

  rec = (struct record_entry *) xcalloc (1, sizeof (struct record_entry));
  rec->type = record_mem;
  rec->u.mem.addr = addr;
  rec->u.mem.len = len;
  if (rec->u.mem.len > sizeof (rec->u.mem.u.buf))
    rec->u.mem.u.ptr = (gdb_byte *) xmalloc (len);

  return rec;
}

/* Free a record_mem record entry.  */

static inline void
record_mem_release (struct record_entry *rec)
{
  gdb_assert (rec->type == record_mem);
  if (rec->u.mem.len > sizeof (rec->u.mem.u.buf))
    xfree (rec->u.mem.u.ptr);
  xfree (rec);
}

/* Alloc a record_end record entry.  */

static inline struct record_entry *
record_end_alloc (void)
{
  struct record_entry *rec;

  rec = (struct record_entry *) xcalloc (1, sizeof (struct record_entry));
  rec->type = record_end;

  return rec;
}

/* Free a record_end record entry.  */

static inline void
record_end_release (struct record_entry *rec)
{
  xfree (rec);
}

/* Free one record entry, any type.
   Return entry->type, in case caller wants to know.  */

static inline enum record_type
record_entry_release (struct record_entry *rec)
{
  enum record_type type = rec->type;

  switch (type) {
  case record_reg:
    record_reg_release (rec);
    break;
  case record_mem:
    record_mem_release (rec);
    break;
  case record_end:
    record_end_release (rec);
    break;
  }
  return type;
}

/* Free all record entries in list pointed to by REC.  */

static void
record_list_release (struct record_entry *rec)
{
  if (!rec)
    return;

  while (rec->next)
    rec = rec->next;

  while (rec->prev)
    {
      rec = rec->prev;
      record_entry_release (rec->next);
    }

  if (rec == &record_first)
    {
      record_insn_num = 0;
      record_first.next = NULL;
    }
  else
    record_entry_release (rec);
}

/* Free all record entries forward of the given list position.  */

static void
record_list_release_following (struct record_entry *rec)
{
  struct record_entry *tmp = rec->next;

  rec->next = NULL;
  while (tmp)
    {
      rec = tmp->next;
      if (record_entry_release (tmp) == record_end)
	{
	  record_insn_num--;
	  record_insn_count--;
	}
      tmp = rec;
    }
}

/* Delete the first instruction from the beginning of the log, to make
   room for adding a new instruction at the end of the log.

   Note -- this function does not modify record_insn_num.  */

static void
record_list_release_first (void)
{
  struct record_entry *tmp;

  if (!record_first.next)
    return;

  /* Loop until a record_end.  */
  while (1)
    {
      /* Cut record_first.next out of the linked list.  */
      tmp = record_first.next;
      record_first.next = tmp->next;
      tmp->next->prev = &record_first;

      /* tmp is now isolated, and can be deleted.  */
      if (record_entry_release (tmp) == record_end)
	break;	/* End loop at first record_end.  */

      if (!record_first.next)
	{
	  gdb_assert (record_insn_num == 1);
	  break;	/* End loop when list is empty.  */
	}
    }
}

/* Add a struct record_entry to record_arch_list.  */

static void
record_arch_list_add (struct record_entry *rec)
{
  if (record_debug > 1)
    fprintf_unfiltered (gdb_stdlog,
			"Process record: record_arch_list_add %s.\n",
			host_address_to_string (rec));

  if (record_arch_list_tail)
    {
      record_arch_list_tail->next = rec;
      rec->prev = record_arch_list_tail;
      record_arch_list_tail = rec;
    }
  else
    {
      record_arch_list_head = rec;
      record_arch_list_tail = rec;
    }
}

/* Return the value storage location of a record entry.  */
static inline gdb_byte *
record_get_loc (struct record_entry *rec)
{
  switch (rec->type) {
  case record_mem:
    if (rec->u.mem.len > sizeof (rec->u.mem.u.buf))
      return rec->u.mem.u.ptr;
    else
      return rec->u.mem.u.buf;
  case record_reg:
    if (rec->u.reg.len > sizeof (rec->u.reg.u.buf))
      return rec->u.reg.u.ptr;
    else
      return rec->u.reg.u.buf;
  case record_end:
  default:
    gdb_assert_not_reached ("unexpected record_entry type");
    return NULL;
  }
}

/* Record the value of a register NUM to record_arch_list.  */

int
record_arch_list_add_reg (struct regcache *regcache, int regnum)
{
  struct record_entry *rec;

  if (record_debug > 1)
    fprintf_unfiltered (gdb_stdlog,
			"Process record: add register num = %d to "
			"record list.\n",
			regnum);

  rec = record_reg_alloc (regcache, regnum);

  regcache_raw_read (regcache, regnum, record_get_loc (rec));

  record_arch_list_add (rec);

  return 0;
}

int
record_read_memory (struct gdbarch *gdbarch,
		    CORE_ADDR memaddr, gdb_byte *myaddr,
		    ssize_t len)
{
  int ret = target_read_memory (memaddr, myaddr, len);

  if (ret && record_debug)
    printf_unfiltered (_("Process record: error reading memory "
			 "at addr %s len = %ld.\n"),
		       paddress (gdbarch, memaddr), (long) len);
  return ret;
}

/* Record the value of a region of memory whose address is ADDR and
   length is LEN to record_arch_list.  */

int
record_arch_list_add_mem (CORE_ADDR addr, int len)
{
  struct record_entry *rec;

  if (record_debug > 1)
    fprintf_unfiltered (gdb_stdlog,
			"Process record: add mem addr = %s len = %d to "
			"record list.\n",
			paddress (target_gdbarch (), addr), len);

  if (!addr)	/* FIXME: Why?  Some arch must permit it...  */
    return 0;

  rec = record_mem_alloc (addr, len);

  if (record_read_memory (target_gdbarch (), addr, record_get_loc (rec), len))
    {
      record_mem_release (rec);
      return -1;
    }

  record_arch_list_add (rec);

  return 0;
}

/* Add a record_end type struct record_entry to record_arch_list.  */

int
record_arch_list_add_end (void)
{
  struct record_entry *rec;

  if (record_debug > 1)
    fprintf_unfiltered (gdb_stdlog,
			"Process record: add end to arch list.\n");

  rec = record_end_alloc ();
  rec->u.end.sigval = GDB_SIGNAL_0;
  rec->u.end.insn_num = ++record_insn_count;

  record_arch_list_add (rec);

  return 0;
}

static void
record_check_insn_num (int set_terminal)
{
  if (record_insn_max_num)
    {
      gdb_assert (record_insn_num <= record_insn_max_num);
      if (record_insn_num == record_insn_max_num)
	{
	  /* Ask user what to do.  */
	  if (record_stop_at_limit)
	    {
	      int q;

	      if (set_terminal)
		target_terminal_ours ();
	      q = yquery (_("Do you want to auto delete previous execution "
			    "log entries when record/replay buffer becomes "
			    "full (record stop-at-limit)?"));
	      if (set_terminal)
		target_terminal_inferior ();
	      if (q)
		record_stop_at_limit = 0;
	      else
		error (_("Process record: stopped by user."));
	    }
	}
    }
}

static void
record_arch_list_cleanups (void *ignore)
{
  record_list_release (record_arch_list_tail);
}

/* Before inferior step (when GDB record the running message, inferior
   only can step), GDB will call this function to record the values to
   record_list.  This function will call gdbarch_process_record to
   record the running message of inferior and set them to
   record_arch_list, and add it to record_list.  */

static int
record_message (struct regcache *regcache, enum gdb_signal signal)
{
  int ret;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct cleanup *old_cleanups = make_cleanup (record_arch_list_cleanups, 0);

  record_arch_list_head = NULL;
  record_arch_list_tail = NULL;

  /* Check record_insn_num.  */
  record_check_insn_num (1);

  /* If gdb sends a signal value to target_resume,
     save it in the 'end' field of the previous instruction.

     Maybe process record should record what really happened,
     rather than what gdb pretends has happened.

     So if Linux delivered the signal to the child process during
     the record mode, we will record it and deliver it again in
     the replay mode.

     If user says "ignore this signal" during the record mode, then
     it will be ignored again during the replay mode (no matter if
     the user says something different, like "deliver this signal"
     during the replay mode).

     User should understand that nothing he does during the replay
     mode will change the behavior of the child.  If he tries,
     then that is a user error.

     But we should still deliver the signal to gdb during the replay,
     if we delivered it during the recording.  Therefore we should
     record the signal during record_wait, not record_resume.  */
  if (record_list != &record_first)    /* FIXME better way to check */
    {
      gdb_assert (record_list->type == record_end);
      record_list->u.end.sigval = signal;
    }

  if (signal == GDB_SIGNAL_0
      || !gdbarch_process_record_signal_p (gdbarch))
    ret = gdbarch_process_record (gdbarch,
				  regcache,
				  regcache_read_pc (regcache));
  else
    ret = gdbarch_process_record_signal (gdbarch,
					 regcache,
					 signal);

  if (ret > 0)
    error (_("Process record: inferior program stopped."));
  if (ret < 0)
    error (_("Process record: failed to record execution log."));

  discard_cleanups (old_cleanups);

  record_list->next = record_arch_list_head;
  record_arch_list_head->prev = record_list;
  record_list = record_arch_list_tail;

  if (record_insn_num == record_insn_max_num && record_insn_max_num)
    record_list_release_first ();
  else
    record_insn_num++;

  return 1;
}

struct record_message_args {
  struct regcache *regcache;
  enum gdb_signal signal;
};

static int
record_message_wrapper (void *args)
{
  struct record_message_args *record_args = args;

  return record_message (record_args->regcache, record_args->signal);
}

static int
record_message_wrapper_safe (struct regcache *regcache,
                             enum gdb_signal signal)
{
  struct record_message_args args;

  args.regcache = regcache;
  args.signal = signal;

  return catch_errors (record_message_wrapper, &args, NULL, RETURN_MASK_ALL);
}

/* Set to 1 if record_store_registers and record_xfer_partial
   doesn't need record.  */

static int record_gdb_operation_disable = 0;

struct cleanup *
record_gdb_operation_disable_set (void)
{
  struct cleanup *old_cleanups = NULL;

  old_cleanups =
    make_cleanup_restore_integer (&record_gdb_operation_disable);
  record_gdb_operation_disable = 1;

  return old_cleanups;
}

/* Flag set to TRUE for target_stopped_by_watchpoint.  */
static int record_hw_watchpoint = 0;

/* Execute one instruction from the record log.  Each instruction in
   the log will be represented by an arbitrary sequence of register
   entries and memory entries, followed by an 'end' entry.  */

static inline void
record_exec_insn (struct regcache *regcache, struct gdbarch *gdbarch,
		  struct record_entry *entry)
{
  switch (entry->type)
    {
    case record_reg: /* reg */
      {
        gdb_byte reg[MAX_REGISTER_SIZE];

        if (record_debug > 1)
          fprintf_unfiltered (gdb_stdlog,
                              "Process record: record_reg %s to "
                              "inferior num = %d.\n",
                              host_address_to_string (entry),
                              entry->u.reg.num);

        regcache_cooked_read (regcache, entry->u.reg.num, reg);
        regcache_cooked_write (regcache, entry->u.reg.num, 
			       record_get_loc (entry));
        memcpy (record_get_loc (entry), reg, entry->u.reg.len);
      }
      break;

    case record_mem: /* mem */
      {
	/* Nothing to do if the entry is flagged not_accessible.  */
        if (!entry->u.mem.mem_entry_not_accessible)
          {
            gdb_byte *mem = alloca (entry->u.mem.len);

            if (record_debug > 1)
              fprintf_unfiltered (gdb_stdlog,
                                  "Process record: record_mem %s to "
                                  "inferior addr = %s len = %d.\n",
                                  host_address_to_string (entry),
                                  paddress (gdbarch, entry->u.mem.addr),
                                  entry->u.mem.len);

            if (record_read_memory (gdbarch,
				    entry->u.mem.addr, mem, entry->u.mem.len))
	      entry->u.mem.mem_entry_not_accessible = 1;
            else
              {
                if (target_write_memory (entry->u.mem.addr, 
					 record_get_loc (entry),
					 entry->u.mem.len))
                  {
                    entry->u.mem.mem_entry_not_accessible = 1;
                    if (record_debug)
                      warning (_("Process record: error writing memory at "
				 "addr = %s len = %d."),
                               paddress (gdbarch, entry->u.mem.addr),
                               entry->u.mem.len);
                  }
                else
		  {
		    memcpy (record_get_loc (entry), mem, entry->u.mem.len);

		    /* We've changed memory --- check if a hardware
		       watchpoint should trap.  Note that this
		       presently assumes the target beneath supports
		       continuable watchpoints.  On non-continuable
		       watchpoints target, we'll want to check this
		       _before_ actually doing the memory change, and
		       not doing the change at all if the watchpoint
		       traps.  */
		    if (hardware_watchpoint_inserted_in_range
			(get_regcache_aspace (regcache),
			 entry->u.mem.addr, entry->u.mem.len))
		      record_hw_watchpoint = 1;
		  }
              }
          }
      }
      break;
    }
}

static struct target_ops *tmp_to_resume_ops;
static void (*tmp_to_resume) (struct target_ops *, ptid_t, int,
			      enum gdb_signal);
static struct target_ops *tmp_to_wait_ops;
static ptid_t (*tmp_to_wait) (struct target_ops *, ptid_t,
			      struct target_waitstatus *,
			      int);
static struct target_ops *tmp_to_store_registers_ops;
static void (*tmp_to_store_registers) (struct target_ops *,
				       struct regcache *,
				       int regno);
static struct target_ops *tmp_to_xfer_partial_ops;
static LONGEST (*tmp_to_xfer_partial) (struct target_ops *ops,
				       enum target_object object,
				       const char *annex,
				       gdb_byte *readbuf,
				       const gdb_byte *writebuf,
				       ULONGEST offset,
				       LONGEST len);
static int (*tmp_to_insert_breakpoint) (struct gdbarch *,
					struct bp_target_info *);
static int (*tmp_to_remove_breakpoint) (struct gdbarch *,
					struct bp_target_info *);
static int (*tmp_to_stopped_by_watchpoint) (void);
static int (*tmp_to_stopped_data_address) (struct target_ops *, CORE_ADDR *);
static int (*tmp_to_stopped_data_address) (struct target_ops *, CORE_ADDR *);
static void (*tmp_to_async) (void (*) (enum inferior_event_type, void *), void *);

static void record_restore (void);

/* Asynchronous signal handle registered as event loop source for when
   we have pending events ready to be passed to the core.  */

static struct async_event_handler *record_async_inferior_event_token;

static void
record_async_inferior_event_handler (gdb_client_data data)
{
  inferior_event_handler (INF_REG_EVENT, NULL);
}

/* Open the process record target.  */

static void
record_core_open_1 (char *name, int from_tty)
{
  struct regcache *regcache = get_current_regcache ();
  int regnum = gdbarch_num_regs (get_regcache_arch (regcache));
  int i;

  /* Get record_core_regbuf.  */
  target_fetch_registers (regcache, -1);
  record_core_regbuf = xmalloc (MAX_REGISTER_SIZE * regnum);
  for (i = 0; i < regnum; i ++)
    regcache_raw_collect (regcache, i,
			  record_core_regbuf + MAX_REGISTER_SIZE * i);

  /* Get record_core_start and record_core_end.  */
  if (build_section_table (core_bfd, &record_core_start, &record_core_end))
    {
      xfree (record_core_regbuf);
      record_core_regbuf = NULL;
      error (_("\"%s\": Can't find sections: %s"),
	     bfd_get_filename (core_bfd), bfd_errmsg (bfd_get_error ()));
    }

  push_target (&record_core_ops);
  record_restore ();
}

/* "to_open" target method for 'live' processes.  */

static void
record_open_1 (char *name, int from_tty)
{
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "Process record: record_open\n");

  /* check exec */
  if (!target_has_execution)
    error (_("Process record: the program is not being run."));
  if (non_stop)
    error (_("Process record target can't debug inferior in non-stop mode "
	     "(non-stop)."));

  if (!gdbarch_process_record_p (target_gdbarch ()))
    error (_("Process record: the current architecture doesn't support "
	     "record function."));

  if (!tmp_to_resume)
    error (_("Could not find 'to_resume' method on the target stack."));
  if (!tmp_to_wait)
    error (_("Could not find 'to_wait' method on the target stack."));
  if (!tmp_to_store_registers)
    error (_("Could not find 'to_store_registers' "
	     "method on the target stack."));
  if (!tmp_to_insert_breakpoint)
    error (_("Could not find 'to_insert_breakpoint' "
	     "method on the target stack."));
  if (!tmp_to_remove_breakpoint)
    error (_("Could not find 'to_remove_breakpoint' "
	     "method on the target stack."));
  if (!tmp_to_stopped_by_watchpoint)
    error (_("Could not find 'to_stopped_by_watchpoint' "
	     "method on the target stack."));
  if (!tmp_to_stopped_data_address)
    error (_("Could not find 'to_stopped_data_address' "
	     "method on the target stack."));

  push_target (&record_ops);
}

static void record_init_record_breakpoints (void);

/* "to_open" target method.  Open the process record target.  */

static void
record_open (char *name, int from_tty)
{
  struct target_ops *t;

  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "Process record: record_open\n");

  /* Check if record target is already running.  */
  if (current_target.to_stratum == record_stratum)
    error (_("Process record target already running.  Use \"record stop\" to "
             "stop record target first."));

  /* Reset the tmp beneath pointers.  */
  tmp_to_resume_ops = NULL;
  tmp_to_resume = NULL;
  tmp_to_wait_ops = NULL;
  tmp_to_wait = NULL;
  tmp_to_store_registers_ops = NULL;
  tmp_to_store_registers = NULL;
  tmp_to_xfer_partial_ops = NULL;
  tmp_to_xfer_partial = NULL;
  tmp_to_insert_breakpoint = NULL;
  tmp_to_remove_breakpoint = NULL;
  tmp_to_stopped_by_watchpoint = NULL;
  tmp_to_stopped_data_address = NULL;
  tmp_to_async = NULL;

  /* Set the beneath function pointers.  */
  for (t = current_target.beneath; t != NULL; t = t->beneath)
    {
      if (!tmp_to_resume)
        {
	  tmp_to_resume = t->to_resume;
	  tmp_to_resume_ops = t;
        }
      if (!tmp_to_wait)
        {
	  tmp_to_wait = t->to_wait;
	  tmp_to_wait_ops = t;
        }
      if (!tmp_to_store_registers)
        {
	  tmp_to_store_registers = t->to_store_registers;
	  tmp_to_store_registers_ops = t;
        }
      if (!tmp_to_xfer_partial)
        {
	  tmp_to_xfer_partial = t->to_xfer_partial;
	  tmp_to_xfer_partial_ops = t;
        }
      if (!tmp_to_insert_breakpoint)
	tmp_to_insert_breakpoint = t->to_insert_breakpoint;
      if (!tmp_to_remove_breakpoint)
	tmp_to_remove_breakpoint = t->to_remove_breakpoint;
      if (!tmp_to_stopped_by_watchpoint)
	tmp_to_stopped_by_watchpoint = t->to_stopped_by_watchpoint;
      if (!tmp_to_stopped_data_address)
	tmp_to_stopped_data_address = t->to_stopped_data_address;
      if (!tmp_to_async)
	tmp_to_async = t->to_async;
    }
  if (!tmp_to_xfer_partial)
    error (_("Could not find 'to_xfer_partial' method on the target stack."));

  /* Reset */
  record_insn_num = 0;
  record_insn_count = 0;
  record_list = &record_first;
  record_list->next = NULL;

  /* Set the tmp beneath pointers to beneath pointers.  */
  record_beneath_to_resume_ops = tmp_to_resume_ops;
  record_beneath_to_resume = tmp_to_resume;
  record_beneath_to_wait_ops = tmp_to_wait_ops;
  record_beneath_to_wait = tmp_to_wait;
  record_beneath_to_store_registers_ops = tmp_to_store_registers_ops;
  record_beneath_to_store_registers = tmp_to_store_registers;
  record_beneath_to_xfer_partial_ops = tmp_to_xfer_partial_ops;
  record_beneath_to_xfer_partial = tmp_to_xfer_partial;
  record_beneath_to_insert_breakpoint = tmp_to_insert_breakpoint;
  record_beneath_to_remove_breakpoint = tmp_to_remove_breakpoint;
  record_beneath_to_stopped_by_watchpoint = tmp_to_stopped_by_watchpoint;
  record_beneath_to_stopped_data_address = tmp_to_stopped_data_address;
  record_beneath_to_async = tmp_to_async;

  if (core_bfd)
    record_core_open_1 (name, from_tty);
  else
    record_open_1 (name, from_tty);

  /* Register extra event sources in the event loop.  */
  record_async_inferior_event_token
    = create_async_event_handler (record_async_inferior_event_handler,
				  NULL);

  record_init_record_breakpoints ();

  observer_notify_record_changed (current_inferior (),  1);
}

/* "to_close" target method.  Close the process record target.  */

static void
record_close (int quitting)
{
  struct record_core_buf_entry *entry;

  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "Process record: record_close\n");

  record_list_release (record_list);

  /* Release record_core_regbuf.  */
  if (record_core_regbuf)
    {
      xfree (record_core_regbuf);
      record_core_regbuf = NULL;
    }

  /* Release record_core_buf_list.  */
  if (record_core_buf_list)
    {
      for (entry = record_core_buf_list->prev; entry; entry = entry->prev)
	{
	  xfree (record_core_buf_list);
	  record_core_buf_list = entry;
	}
      record_core_buf_list = NULL;
    }

  if (record_async_inferior_event_token)
    delete_async_event_handler (&record_async_inferior_event_token);
}

static int record_resume_step = 0;

/* True if we've been resumed, and so each record_wait call should
   advance execution.  If this is false, record_wait will return a
   TARGET_WAITKIND_IGNORE.  */
static int record_resumed = 0;

/* The execution direction of the last resume we got.  This is
   necessary for async mode.  Vis (order is not strictly accurate):

   1. user has the global execution direction set to forward
   2. user does a reverse-step command
   3. record_resume is called with global execution direction
      temporarily switched to reverse
   4. GDB's execution direction is reverted back to forward
   5. target record notifies event loop there's an event to handle
   6. infrun asks the target which direction was it going, and switches
      the global execution direction accordingly (to reverse)
   7. infrun polls an event out of the record target, and handles it
   8. GDB goes back to the event loop, and goto #4.
*/
static enum exec_direction_kind record_execution_dir = EXEC_FORWARD;

/* "to_resume" target method.  Resume the process record target.  */

static void
record_resume (struct target_ops *ops, ptid_t ptid, int step,
               enum gdb_signal signal)
{
  record_resume_step = step;
  record_resumed = 1;
  record_execution_dir = execution_direction;

  if (!RECORD_IS_REPLAY)
    {
      struct gdbarch *gdbarch = target_thread_architecture (ptid);

      record_message (get_current_regcache (), signal);

      if (!step)
        {
          /* This is not hard single step.  */
          if (!gdbarch_software_single_step_p (gdbarch))
            {
              /* This is a normal continue.  */
              step = 1;
            }
          else
            {
              /* This arch support soft sigle step.  */
              if (single_step_breakpoints_inserted ())
                {
                  /* This is a soft single step.  */
                  record_resume_step = 1;
                }
              else
                {
                  /* This is a continue.
                     Try to insert a soft single step breakpoint.  */
                  if (!gdbarch_software_single_step (gdbarch,
                                                     get_current_frame ()))
                    {
                      /* This system don't want use soft single step.
                         Use hard sigle step.  */
                      step = 1;
                    }
                }
            }
        }

      /* Make sure the target beneath reports all signals.  */
      target_pass_signals (0, NULL);

      record_beneath_to_resume (record_beneath_to_resume_ops,
                                ptid, step, signal);
    }

  /* We are about to start executing the inferior (or simulate it),
     let's register it with the event loop.  */
  if (target_can_async_p ())
    {
      target_async (inferior_event_handler, 0);
      /* Notify the event loop there's an event to wait for.  We do
	 most of the work in record_wait.  */
      mark_async_event_handler (record_async_inferior_event_token);
    }
}

static int record_get_sig = 0;

/* SIGINT signal handler, registered by "to_wait" method.  */

static void
record_sig_handler (int signo)
{
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "Process record: get a signal\n");

  /* It will break the running inferior in replay mode.  */
  record_resume_step = 1;

  /* It will let record_wait set inferior status to get the signal
     SIGINT.  */
  record_get_sig = 1;
}

static void
record_wait_cleanups (void *ignore)
{
  if (execution_direction == EXEC_REVERSE)
    {
      if (record_list->next)
	record_list = record_list->next;
    }
  else
    record_list = record_list->prev;
}

/* "to_wait" target method for process record target.

   In record mode, the target is always run in singlestep mode
   (even when gdb says to continue).  The to_wait method intercepts
   the stop events and determines which ones are to be passed on to
   gdb.  Most stop events are just singlestep events that gdb is not
   to know about, so the to_wait method just records them and keeps
   singlestepping.

   In replay mode, this function emulates the recorded execution log, 
   one instruction at a time (forward or backward), and determines 
   where to stop.  */

static ptid_t
record_wait_1 (struct target_ops *ops,
	       ptid_t ptid, struct target_waitstatus *status,
	       int options)
{
  struct cleanup *set_cleanups = record_gdb_operation_disable_set ();

  if (record_debug)
    fprintf_unfiltered (gdb_stdlog,
			"Process record: record_wait "
			"record_resume_step = %d, record_resumed = %d, direction=%s\n",
			record_resume_step, record_resumed,
			record_execution_dir == EXEC_FORWARD ? "forward" : "reverse");

  if (!record_resumed)
    {
      gdb_assert ((options & TARGET_WNOHANG) != 0);

      /* No interesting event.  */
      status->kind = TARGET_WAITKIND_IGNORE;
      return minus_one_ptid;
    }

  record_get_sig = 0;
  signal (SIGINT, record_sig_handler);

  if (!RECORD_IS_REPLAY && ops != &record_core_ops)
    {
      if (record_resume_step)
	{
	  /* This is a single step.  */
	  return record_beneath_to_wait (record_beneath_to_wait_ops,
					 ptid, status, options);
	}
      else
	{
	  /* This is not a single step.  */
	  ptid_t ret;
	  CORE_ADDR tmp_pc;
	  struct gdbarch *gdbarch = target_thread_architecture (inferior_ptid);

	  while (1)
	    {
	      ret = record_beneath_to_wait (record_beneath_to_wait_ops,
					    ptid, status, options);
	      if (status->kind == TARGET_WAITKIND_IGNORE)
		{
		  if (record_debug)
		    fprintf_unfiltered (gdb_stdlog,
					"Process record: record_wait "
					"target beneath not done yet\n");
		  return ret;
		}

              if (single_step_breakpoints_inserted ())
                remove_single_step_breakpoints ();

	      if (record_resume_step)
		return ret;

	      /* Is this a SIGTRAP?  */
	      if (status->kind == TARGET_WAITKIND_STOPPED
		  && status->value.sig == GDB_SIGNAL_TRAP)
		{
		  struct regcache *regcache;
		  struct address_space *aspace;

		  /* Yes -- this is likely our single-step finishing,
		     but check if there's any reason the core would be
		     interested in the event.  */

		  registers_changed ();
		  regcache = get_current_regcache ();
		  tmp_pc = regcache_read_pc (regcache);
		  aspace = get_regcache_aspace (regcache);

		  if (target_stopped_by_watchpoint ())
		    {
		      /* Always interested in watchpoints.  */
		    }
		  else if (breakpoint_inserted_here_p (aspace, tmp_pc))
		    {
		      /* There is a breakpoint here.  Let the core
			 handle it.  */
		      if (software_breakpoint_inserted_here_p (aspace, tmp_pc))
			{
			  struct gdbarch *gdbarch
			    = get_regcache_arch (regcache);
			  CORE_ADDR decr_pc_after_break
			    = gdbarch_decr_pc_after_break (gdbarch);
			  if (decr_pc_after_break)
			    regcache_write_pc (regcache,
					       tmp_pc + decr_pc_after_break);
			}
		    }
		  else
		    {
		      /* This is a single-step trap.  Record the
		         insn and issue another step.
                         FIXME: this part can be a random SIGTRAP too.
                         But GDB cannot handle it.  */
                      int step = 1;

		      if (!record_message_wrapper_safe (regcache,
                                                        GDB_SIGNAL_0))
  			{
                           status->kind = TARGET_WAITKIND_STOPPED;
                           status->value.sig = GDB_SIGNAL_0;
                           break;
  			}

                      if (gdbarch_software_single_step_p (gdbarch))
			{
			  /* Try to insert the software single step breakpoint.
			     If insert success, set step to 0.  */
			  set_executing (inferior_ptid, 0);
			  reinit_frame_cache ();
			  if (gdbarch_software_single_step (gdbarch,
                                                            get_current_frame ()))
			    step = 0;
			  set_executing (inferior_ptid, 1);
			}

		      if (record_debug)
			fprintf_unfiltered (gdb_stdlog,
					    "Process record: record_wait "
					    "issuing one more step in the target beneath\n");
		      record_beneath_to_resume (record_beneath_to_resume_ops,
						ptid, step,
						GDB_SIGNAL_0);
		      continue;
		    }
		}

	      /* The inferior is broken by a breakpoint or a signal.  */
	      break;
	    }

	  return ret;
	}
    }
  else
    {
      struct regcache *regcache = get_current_regcache ();
      struct gdbarch *gdbarch = get_regcache_arch (regcache);
      struct address_space *aspace = get_regcache_aspace (regcache);
      int continue_flag = 1;
      int first_record_end = 1;
      struct cleanup *old_cleanups = make_cleanup (record_wait_cleanups, 0);
      CORE_ADDR tmp_pc;

      record_hw_watchpoint = 0;
      status->kind = TARGET_WAITKIND_STOPPED;

      /* Check breakpoint when forward execute.  */
      if (execution_direction == EXEC_FORWARD)
	{
	  tmp_pc = regcache_read_pc (regcache);
	  if (breakpoint_inserted_here_p (aspace, tmp_pc))
	    {
	      int decr_pc_after_break = gdbarch_decr_pc_after_break (gdbarch);

	      if (record_debug)
		fprintf_unfiltered (gdb_stdlog,
				    "Process record: break at %s.\n",
				    paddress (gdbarch, tmp_pc));

	      if (decr_pc_after_break
		  && !record_resume_step
		  && software_breakpoint_inserted_here_p (aspace, tmp_pc))
		regcache_write_pc (regcache,
				   tmp_pc + decr_pc_after_break);
	      goto replay_out;
	    }
	}

      /* If GDB is in terminal_inferior mode, it will not get the signal.
         And in GDB replay mode, GDB doesn't need to be in terminal_inferior
         mode, because inferior will not executed.
         Then set it to terminal_ours to make GDB get the signal.  */
      target_terminal_ours ();

      /* In EXEC_FORWARD mode, record_list points to the tail of prev
         instruction.  */
      if (execution_direction == EXEC_FORWARD && record_list->next)
	record_list = record_list->next;

      /* Loop over the record_list, looking for the next place to
	 stop.  */
      do
	{
	  /* Check for beginning and end of log.  */
	  if (execution_direction == EXEC_REVERSE
	      && record_list == &record_first)
	    {
	      /* Hit beginning of record log in reverse.  */
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
	      break;
	    }
	  if (execution_direction != EXEC_REVERSE && !record_list->next)
	    {
	      /* Hit end of record log going forward.  */
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
	      break;
	    }

          record_exec_insn (regcache, gdbarch, record_list);

	  if (record_list->type == record_end)
	    {
	      if (record_debug > 1)
		fprintf_unfiltered (gdb_stdlog,
				    "Process record: record_end %s to "
				    "inferior.\n",
				    host_address_to_string (record_list));

	      if (first_record_end && execution_direction == EXEC_REVERSE)
		{
		  /* When reverse excute, the first record_end is the part of
		     current instruction.  */
		  first_record_end = 0;
		}
	      else
		{
		  /* In EXEC_REVERSE mode, this is the record_end of prev
		     instruction.
		     In EXEC_FORWARD mode, this is the record_end of current
		     instruction.  */
		  /* step */
		  if (record_resume_step)
		    {
		      if (record_debug > 1)
			fprintf_unfiltered (gdb_stdlog,
					    "Process record: step.\n");
		      continue_flag = 0;
		    }

		  /* check breakpoint */
		  tmp_pc = regcache_read_pc (regcache);
		  if (breakpoint_inserted_here_p (aspace, tmp_pc))
		    {
		      int decr_pc_after_break
			= gdbarch_decr_pc_after_break (gdbarch);

		      if (record_debug)
			fprintf_unfiltered (gdb_stdlog,
					    "Process record: break "
					    "at %s.\n",
					    paddress (gdbarch, tmp_pc));
		      if (decr_pc_after_break
			  && execution_direction == EXEC_FORWARD
			  && !record_resume_step
			  && software_breakpoint_inserted_here_p (aspace,
								  tmp_pc))
			regcache_write_pc (regcache,
					   tmp_pc + decr_pc_after_break);
		      continue_flag = 0;
		    }

		  if (record_hw_watchpoint)
		    {
		      if (record_debug)
			fprintf_unfiltered (gdb_stdlog,
					    "Process record: hit hw "
					    "watchpoint.\n");
		      continue_flag = 0;
		    }
		  /* Check target signal */
		  if (record_list->u.end.sigval != GDB_SIGNAL_0)
		    /* FIXME: better way to check */
		    continue_flag = 0;
		}
	    }

	  if (continue_flag)
	    {
	      if (execution_direction == EXEC_REVERSE)
		{
		  if (record_list->prev)
		    record_list = record_list->prev;
		}
	      else
		{
		  if (record_list->next)
		    record_list = record_list->next;
		}
	    }
	}
      while (continue_flag);

replay_out:
      if (record_get_sig)
	status->value.sig = GDB_SIGNAL_INT;
      else if (record_list->u.end.sigval != GDB_SIGNAL_0)
	/* FIXME: better way to check */
	status->value.sig = record_list->u.end.sigval;
      else
	status->value.sig = GDB_SIGNAL_TRAP;

      discard_cleanups (old_cleanups);
    }

  signal (SIGINT, handle_sigint);

  do_cleanups (set_cleanups);
  return inferior_ptid;
}

static ptid_t
record_wait (struct target_ops *ops,
	     ptid_t ptid, struct target_waitstatus *status,
	     int options)
{
  ptid_t return_ptid;

  return_ptid = record_wait_1 (ops, ptid, status, options);
  if (status->kind != TARGET_WAITKIND_IGNORE)
    {
      /* We're reporting a stop.  Make sure any spurious
	 target_wait(WNOHANG) doesn't advance the target until the
	 core wants us resumed again.  */
      record_resumed = 0;
    }
  return return_ptid;
}

static int
record_stopped_by_watchpoint (void)
{
  if (RECORD_IS_REPLAY)
    return record_hw_watchpoint;
  else
    return record_beneath_to_stopped_by_watchpoint ();
}

static int
record_stopped_data_address (struct target_ops *ops, CORE_ADDR *addr_p)
{
  if (RECORD_IS_REPLAY)
    return 0;
  else
    return record_beneath_to_stopped_data_address (ops, addr_p);
}

/* "to_disconnect" method for process record target.  */

static void
record_disconnect (struct target_ops *target, char *args, int from_tty)
{
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "Process record: record_disconnect\n");

  unpush_target (&record_ops);
  target_disconnect (args, from_tty);
}

/* "to_detach" method for process record target.  */

static void
record_detach (struct target_ops *ops, char *args, int from_tty)
{
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "Process record: record_detach\n");

  unpush_target (&record_ops);
  target_detach (args, from_tty);
}

/* "to_mourn_inferior" method for process record target.  */

static void
record_mourn_inferior (struct target_ops *ops)
{
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "Process record: "
			            "record_mourn_inferior\n");

  unpush_target (&record_ops);
  target_mourn_inferior ();
}

/* Close process record target before killing the inferior process.  */

static void
record_kill (struct target_ops *ops)
{
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "Process record: record_kill\n");

  unpush_target (&record_ops);
  target_kill ();
}

/* Record registers change (by user or by GDB) to list as an instruction.  */

static void
record_registers_change (struct regcache *regcache, int regnum)
{
  /* Check record_insn_num.  */
  record_check_insn_num (0);

  record_arch_list_head = NULL;
  record_arch_list_tail = NULL;

  if (regnum < 0)
    {
      int i;

      for (i = 0; i < gdbarch_num_regs (get_regcache_arch (regcache)); i++)
	{
	  if (record_arch_list_add_reg (regcache, i))
	    {
	      record_list_release (record_arch_list_tail);
	      error (_("Process record: failed to record execution log."));
	    }
	}
    }
  else
    {
      if (record_arch_list_add_reg (regcache, regnum))
	{
	  record_list_release (record_arch_list_tail);
	  error (_("Process record: failed to record execution log."));
	}
    }
  if (record_arch_list_add_end ())
    {
      record_list_release (record_arch_list_tail);
      error (_("Process record: failed to record execution log."));
    }
  record_list->next = record_arch_list_head;
  record_arch_list_head->prev = record_list;
  record_list = record_arch_list_tail;

  if (record_insn_num == record_insn_max_num && record_insn_max_num)
    record_list_release_first ();
  else
    record_insn_num++;
}

/* "to_store_registers" method for process record target.  */

static void
record_store_registers (struct target_ops *ops, struct regcache *regcache,
                        int regno)
{
  if (!record_gdb_operation_disable)
    {
      if (RECORD_IS_REPLAY)
	{
	  int n;

	  /* Let user choose if he wants to write register or not.  */
	  if (regno < 0)
	    n =
	      query (_("Because GDB is in replay mode, changing the "
		       "value of a register will make the execution "
		       "log unusable from this point onward.  "
		       "Change all registers?"));
	  else
	    n =
	      query (_("Because GDB is in replay mode, changing the value "
		       "of a register will make the execution log unusable "
		       "from this point onward.  Change register %s?"),
		      gdbarch_register_name (get_regcache_arch (regcache),
					       regno));

	  if (!n)
	    {
	      /* Invalidate the value of regcache that was set in function
	         "regcache_raw_write".  */
	      if (regno < 0)
		{
		  int i;

		  for (i = 0;
		       i < gdbarch_num_regs (get_regcache_arch (regcache));
		       i++)
		    regcache_invalidate (regcache, i);
		}
	      else
		regcache_invalidate (regcache, regno);

	      error (_("Process record canceled the operation."));
	    }

	  /* Destroy the record from here forward.  */
	  record_list_release_following (record_list);
	}

      record_registers_change (regcache, regno);
    }
  record_beneath_to_store_registers (record_beneath_to_store_registers_ops,
                                     regcache, regno);
}

/* "to_xfer_partial" method.  Behavior is conditional on RECORD_IS_REPLAY.
   In replay mode, we cannot write memory unles we are willing to
   invalidate the record/replay log from this point forward.  */

static LONGEST
record_xfer_partial (struct target_ops *ops, enum target_object object,
		     const char *annex, gdb_byte *readbuf,
		     const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  if (!record_gdb_operation_disable
      && (object == TARGET_OBJECT_MEMORY
	  || object == TARGET_OBJECT_RAW_MEMORY) && writebuf)
    {
      if (RECORD_IS_REPLAY)
	{
	  /* Let user choose if he wants to write memory or not.  */
	  if (!query (_("Because GDB is in replay mode, writing to memory "
		        "will make the execution log unusable from this "
		        "point onward.  Write memory at address %s?"),
		       paddress (target_gdbarch (), offset)))
	    error (_("Process record canceled the operation."));

	  /* Destroy the record from here forward.  */
	  record_list_release_following (record_list);
	}

      /* Check record_insn_num */
      record_check_insn_num (0);

      /* Record registers change to list as an instruction.  */
      record_arch_list_head = NULL;
      record_arch_list_tail = NULL;
      if (record_arch_list_add_mem (offset, len))
	{
	  record_list_release (record_arch_list_tail);
	  if (record_debug)
	    fprintf_unfiltered (gdb_stdlog,
				"Process record: failed to record "
				"execution log.");
	  return -1;
	}
      if (record_arch_list_add_end ())
	{
	  record_list_release (record_arch_list_tail);
	  if (record_debug)
	    fprintf_unfiltered (gdb_stdlog,
				"Process record: failed to record "
				"execution log.");
	  return -1;
	}
      record_list->next = record_arch_list_head;
      record_arch_list_head->prev = record_list;
      record_list = record_arch_list_tail;

      if (record_insn_num == record_insn_max_num && record_insn_max_num)
	record_list_release_first ();
      else
	record_insn_num++;
    }

  return record_beneath_to_xfer_partial (record_beneath_to_xfer_partial_ops,
                                         object, annex, readbuf, writebuf,
                                         offset, len);
}
d36 1
a36 6
/* This structure represents a breakpoint inserted while the record
   target is active.  We use this to know when to install/remove
   breakpoints in/from the target beneath.  For example, a breakpoint
   may be inserted while recording, but removed when not replaying nor
   recording.  In that case, the breakpoint had not been inserted on
   the target beneath, so we should not try to remove it there.  */
d38 2
a39 1
struct record_breakpoint
d41 1
a41 16
  /* The address and address space the breakpoint was set at.  */
  struct address_space *address_space;
  CORE_ADDR addr;

  /* True when the breakpoint has been also installed in the target
     beneath.  This will be false for breakpoints set during replay or
     when recording.  */
  int in_target_beneath;
};

typedef struct record_breakpoint *record_breakpoint_p;
DEF_VEC_P(record_breakpoint_p);

/* The list of breakpoints inserted while the record target is
   active.  */
VEC(record_breakpoint_p) *record_breakpoints = NULL;
d43 3
a45 12
static void
record_sync_record_breakpoints (struct bp_location *loc, void *data)
{
  if (loc->loc_type != bp_loc_software_breakpoint)
      return;

  if (loc->inserted)
    {
      struct record_breakpoint *bp = XNEW (struct record_breakpoint);

      bp->addr = loc->target_info.placed_address;
      bp->address_space = loc->target_info.placed_address_space;
d47 1
a47 4
      bp->in_target_beneath = 1;

      VEC_safe_push (record_breakpoint_p, record_breakpoints, bp);
    }
d50 1
a50 1
/* Sync existing breakpoints to record_breakpoints.  */
d52 2
a53 2
static void
record_init_record_breakpoints (void)
d55 1
a55 29
  VEC_free (record_breakpoint_p, record_breakpoints);

  iterate_over_bp_locations (record_sync_record_breakpoints);
}

/* Behavior is conditional on RECORD_IS_REPLAY.  We will not actually
   insert or remove breakpoints in the real target when replaying, nor
   when recording.  */

static int
record_insert_breakpoint (struct gdbarch *gdbarch,
			  struct bp_target_info *bp_tgt)
{
  struct record_breakpoint *bp;
  int in_target_beneath = 0;

  if (!RECORD_IS_REPLAY)
    {
      /* When recording, we currently always single-step, so we don't
	 really need to install regular breakpoints in the inferior.
	 However, we do have to insert software single-step
	 breakpoints, in case the target can't hardware step.  To keep
	 things single, we always insert.  */
      struct cleanup *old_cleanups;
      int ret;

      old_cleanups = record_gdb_operation_disable_set ();
      ret = record_beneath_to_insert_breakpoint (gdbarch, bp_tgt);
      do_cleanups (old_cleanups);
d57 4
a60 2
      if (ret != 0)
	return ret;
d62 1
a62 9
      in_target_beneath = 1;
    }

  bp = XNEW (struct record_breakpoint);
  bp->addr = bp_tgt->placed_address;
  bp->address_space = bp_tgt->placed_address_space;
  bp->in_target_beneath = in_target_beneath;
  VEC_safe_push (record_breakpoint_p, record_breakpoints, bp);
  return 0;
d65 1
a65 1
/* "to_remove_breakpoint" method for process record target.  */
d67 4
a70 3
static int
record_remove_breakpoint (struct gdbarch *gdbarch,
			  struct bp_target_info *bp_tgt)
d72 1
a72 2
  struct record_breakpoint *bp;
  int ix;
d74 4
a77 56
  for (ix = 0;
       VEC_iterate (record_breakpoint_p, record_breakpoints, ix, bp);
       ++ix)
    {
      if (bp->addr == bp_tgt->placed_address
	  && bp->address_space == bp_tgt->placed_address_space)
	{
	  if (bp->in_target_beneath)
	    {
	      struct cleanup *old_cleanups;
	      int ret;

	      old_cleanups = record_gdb_operation_disable_set ();
	      ret = record_beneath_to_remove_breakpoint (gdbarch, bp_tgt);
	      do_cleanups (old_cleanups);

	      if (ret != 0)
		return ret;
	    }

	  VEC_unordered_remove (record_breakpoint_p, record_breakpoints, ix);
	  return 0;
	}
    }

  gdb_assert_not_reached ("removing unknown breakpoint");
}

/* "to_can_execute_reverse" method for process record target.  */

static int
record_can_execute_reverse (void)
{
  return 1;
}

/* "to_get_bookmark" method for process record and prec over core.  */

static gdb_byte *
record_get_bookmark (char *args, int from_tty)
{
  gdb_byte *ret = NULL;

  /* Return stringified form of instruction count.  */
  if (record_list && record_list->type == record_end)
    ret = xstrdup (pulongest (record_list->u.end.insn_num));

  if (record_debug)
    {
      if (ret)
	fprintf_unfiltered (gdb_stdlog,
			    "record_get_bookmark returns %s\n", ret);
      else
	fprintf_unfiltered (gdb_stdlog,
			    "record_get_bookmark returns NULL\n");
    }
a80 318
/* The implementation of the command "record goto".  */
static void cmd_record_goto (char *, int);

/* "to_goto_bookmark" method for process record and prec over core.  */

static void
record_goto_bookmark (gdb_byte *bookmark, int from_tty)
{
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog,
			"record_goto_bookmark receives %s\n", bookmark);

  if (bookmark[0] == '\'' || bookmark[0] == '\"')
    {
      if (bookmark[strlen (bookmark) - 1] != bookmark[0])
	error (_("Unbalanced quotes: %s"), bookmark);

      /* Strip trailing quote.  */
      bookmark[strlen (bookmark) - 1] = '\0';
      /* Strip leading quote.  */
      bookmark++;
      /* Pass along to cmd_record_goto.  */
    }

  cmd_record_goto ((char *) bookmark, from_tty);
  return;
}

static void
record_async (void (*callback) (enum inferior_event_type event_type,
				void *context), void *context)
{
  /* If we're on top of a line target (e.g., linux-nat, remote), then
     set it to async mode as well.  Will be NULL if we're sitting on
     top of the core target, for "record restore".  */
  if (record_beneath_to_async != NULL)
    record_beneath_to_async (callback, context);
}

static int
record_can_async_p (void)
{
  /* We only enable async when the user specifically asks for it.  */
  return target_async_permitted;
}

static int
record_is_async_p (void)
{
  /* We only enable async when the user specifically asks for it.  */
  return target_async_permitted;
}

static enum exec_direction_kind
record_execution_direction (void)
{
  return record_execution_dir;
}

static void
init_record_ops (void)
{
  record_ops.to_shortname = "record";
  record_ops.to_longname = "Process record and replay target";
  record_ops.to_doc =
    "Log program while executing and replay execution from log.";
  record_ops.to_open = record_open;
  record_ops.to_close = record_close;
  record_ops.to_resume = record_resume;
  record_ops.to_wait = record_wait;
  record_ops.to_disconnect = record_disconnect;
  record_ops.to_detach = record_detach;
  record_ops.to_mourn_inferior = record_mourn_inferior;
  record_ops.to_kill = record_kill;
  record_ops.to_create_inferior = find_default_create_inferior;
  record_ops.to_store_registers = record_store_registers;
  record_ops.to_xfer_partial = record_xfer_partial;
  record_ops.to_insert_breakpoint = record_insert_breakpoint;
  record_ops.to_remove_breakpoint = record_remove_breakpoint;
  record_ops.to_stopped_by_watchpoint = record_stopped_by_watchpoint;
  record_ops.to_stopped_data_address = record_stopped_data_address;
  record_ops.to_can_execute_reverse = record_can_execute_reverse;
  record_ops.to_stratum = record_stratum;
  /* Add bookmark target methods.  */
  record_ops.to_get_bookmark = record_get_bookmark;
  record_ops.to_goto_bookmark = record_goto_bookmark;
  record_ops.to_async = record_async;
  record_ops.to_can_async_p = record_can_async_p;
  record_ops.to_is_async_p = record_is_async_p;
  record_ops.to_execution_direction = record_execution_direction;
  record_ops.to_magic = OPS_MAGIC;
}

/* "to_resume" method for prec over corefile.  */

static void
record_core_resume (struct target_ops *ops, ptid_t ptid, int step,
                    enum gdb_signal signal)
{
  record_resume_step = step;
  record_resumed = 1;
  record_execution_dir = execution_direction;

  /* We are about to start executing the inferior (or simulate it),
     let's register it with the event loop.  */
  if (target_can_async_p ())
    {
      target_async (inferior_event_handler, 0);

      /* Notify the event loop there's an event to wait for.  */
      mark_async_event_handler (record_async_inferior_event_token);
    }
}

/* "to_kill" method for prec over corefile.  */

static void
record_core_kill (struct target_ops *ops)
{
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "Process record: record_core_kill\n");

  unpush_target (&record_core_ops);
}

/* "to_fetch_registers" method for prec over corefile.  */

static void
record_core_fetch_registers (struct target_ops *ops,
                             struct regcache *regcache,
                             int regno)
{
  if (regno < 0)
    {
      int num = gdbarch_num_regs (get_regcache_arch (regcache));
      int i;

      for (i = 0; i < num; i ++)
        regcache_raw_supply (regcache, i,
                             record_core_regbuf + MAX_REGISTER_SIZE * i);
    }
  else
    regcache_raw_supply (regcache, regno,
                         record_core_regbuf + MAX_REGISTER_SIZE * regno);
}

/* "to_prepare_to_store" method for prec over corefile.  */

static void
record_core_prepare_to_store (struct regcache *regcache)
{
}

/* "to_store_registers" method for prec over corefile.  */

static void
record_core_store_registers (struct target_ops *ops,
                             struct regcache *regcache,
                             int regno)
{
  if (record_gdb_operation_disable)
    regcache_raw_collect (regcache, regno,
                          record_core_regbuf + MAX_REGISTER_SIZE * regno);
  else
    error (_("You can't do that without a process to debug."));
}

/* "to_xfer_partial" method for prec over corefile.  */

static LONGEST
record_core_xfer_partial (struct target_ops *ops, enum target_object object,
		          const char *annex, gdb_byte *readbuf,
		          const gdb_byte *writebuf, ULONGEST offset,
                          LONGEST len)
{
  if (object == TARGET_OBJECT_MEMORY)
    {
      if (record_gdb_operation_disable || !writebuf)
	{
	  struct target_section *p;

	  for (p = record_core_start; p < record_core_end; p++)
	    {
	      if (offset >= p->addr)
		{
		  struct record_core_buf_entry *entry;
		  ULONGEST sec_offset;

		  if (offset >= p->endaddr)
		    continue;

		  if (offset + len > p->endaddr)
		    len = p->endaddr - offset;

		  sec_offset = offset - p->addr;

		  /* Read readbuf or write writebuf p, offset, len.  */
		  /* Check flags.  */
		  if (p->the_bfd_section->flags & SEC_CONSTRUCTOR
		      || (p->the_bfd_section->flags & SEC_HAS_CONTENTS) == 0)
		    {
		      if (readbuf)
			memset (readbuf, 0, len);
		      return len;
		    }
		  /* Get record_core_buf_entry.  */
		  for (entry = record_core_buf_list; entry;
		       entry = entry->prev)
		    if (entry->p == p)
		      break;
		  if (writebuf)
		    {
		      if (!entry)
			{
			  /* Add a new entry.  */
			  entry = (struct record_core_buf_entry *)
			    xmalloc (sizeof (struct record_core_buf_entry));
			  entry->p = p;
			  if (!bfd_malloc_and_get_section (p->bfd,
							   p->the_bfd_section,
							   &entry->buf))
			    {
			      xfree (entry);
			      return 0;
			    }
			  entry->prev = record_core_buf_list;
			  record_core_buf_list = entry;
			}

		      memcpy (entry->buf + sec_offset, writebuf,
			      (size_t) len);
		    }
		  else
		    {
		      if (!entry)
			return record_beneath_to_xfer_partial
			  (record_beneath_to_xfer_partial_ops,
			   object, annex, readbuf, writebuf,
			   offset, len);

		      memcpy (readbuf, entry->buf + sec_offset,
			      (size_t) len);
		    }

		  return len;
		}
	    }

	  return -1;
	}
      else
	error (_("You can't do that without a process to debug."));
    }

  return record_beneath_to_xfer_partial (record_beneath_to_xfer_partial_ops,
                                         object, annex, readbuf, writebuf,
                                         offset, len);
}

/* "to_insert_breakpoint" method for prec over corefile.  */

static int
record_core_insert_breakpoint (struct gdbarch *gdbarch,
			       struct bp_target_info *bp_tgt)
{
  return 0;
}

/* "to_remove_breakpoint" method for prec over corefile.  */

static int
record_core_remove_breakpoint (struct gdbarch *gdbarch,
			       struct bp_target_info *bp_tgt)
{
  return 0;
}

/* "to_has_execution" method for prec over corefile.  */

static int
record_core_has_execution (struct target_ops *ops, ptid_t the_ptid)
{
  return 1;
}

static void
init_record_core_ops (void)
{
  record_core_ops.to_shortname = "record-core";
  record_core_ops.to_longname = "Process record and replay target";
  record_core_ops.to_doc =
    "Log program while executing and replay execution from log.";
  record_core_ops.to_open = record_open;
  record_core_ops.to_close = record_close;
  record_core_ops.to_resume = record_core_resume;
  record_core_ops.to_wait = record_wait;
  record_core_ops.to_kill = record_core_kill;
  record_core_ops.to_fetch_registers = record_core_fetch_registers;
  record_core_ops.to_prepare_to_store = record_core_prepare_to_store;
  record_core_ops.to_store_registers = record_core_store_registers;
  record_core_ops.to_xfer_partial = record_core_xfer_partial;
  record_core_ops.to_insert_breakpoint = record_core_insert_breakpoint;
  record_core_ops.to_remove_breakpoint = record_core_remove_breakpoint;
  record_core_ops.to_stopped_by_watchpoint = record_stopped_by_watchpoint;
  record_core_ops.to_stopped_data_address = record_stopped_data_address;
  record_core_ops.to_can_execute_reverse = record_can_execute_reverse;
  record_core_ops.to_has_execution = record_core_has_execution;
  record_core_ops.to_stratum = record_stratum;
  /* Add bookmark target methods.  */
  record_core_ops.to_get_bookmark = record_get_bookmark;
  record_core_ops.to_goto_bookmark = record_goto_bookmark;
  record_core_ops.to_async = record_async;
  record_core_ops.to_can_async_p = record_can_async_p;
  record_core_ops.to_is_async_p = record_is_async_p;
  record_core_ops.to_execution_direction = record_execution_direction;
  record_core_ops.to_magic = OPS_MAGIC;
}

d96 1
a96 1
  execute_command ("target record", from_tty);
d105 3
a107 1
  if (current_target.to_stratum == record_stratum)
d109 3
a111 9
      if (RECORD_IS_REPLAY)
	{
	  if (!from_tty || query (_("Delete the log from this point forward "
		                    "and begin to record the running message "
		                    "at current PC?")))
	    record_list_release_following (record_list);
	}
      else
	  printf_unfiltered (_("Already at end of record list.\n"));
d113 5
d119 5
a123 2
  else
    printf_unfiltered (_("Process record is not started.\n"));
d131 1
a131 5
  if (current_target.to_stratum == record_stratum)
    {
      unpush_target (&record_ops);
      printf_unfiltered (_("Process record is stopped and all execution "
                           "logs are deleted.\n"));
d133 2
a134 5
      observer_notify_record_changed (current_inferior (), 0);
    }
  else
    printf_unfiltered (_("Process record is not started.\n"));
}
d136 2
a137 1
/* Set upper limit of record log size.  */
d139 1
a139 12
static void
set_record_insn_max_num (char *args, int from_tty, struct cmd_list_element *c)
{
  if (record_insn_num > record_insn_max_num && record_insn_max_num)
    {
      /* Count down record_insn_num while releasing records from list.  */
      while (record_insn_num > record_insn_max_num)
	{
	  record_list_release_first ();
	  record_insn_num--;
	}
    }
d142 1
a142 2
static struct cmd_list_element *record_cmdlist, *set_record_cmdlist,
			       *show_record_cmdlist, *info_record_cmdlist;
d152 2
d160 1
a160 1
/* Display some statistics about the execution log.  */
d165 1
a165 1
  struct record_entry *p;
d167 2
a168 1
  if (current_target.to_stratum == record_stratum)
d170 2
a171 298
      if (RECORD_IS_REPLAY)
	printf_filtered (_("Replay mode:\n"));
      else
	printf_filtered (_("Record mode:\n"));

      /* Find entry for first actual instruction in the log.  */
      for (p = record_first.next;
	   p != NULL && p->type != record_end;
	   p = p->next)
	;

      /* Do we have a log at all?  */
      if (p != NULL && p->type == record_end)
	{
	  /* Display instruction number for first instruction in the log.  */
	  printf_filtered (_("Lowest recorded instruction number is %s.\n"),
			   pulongest (p->u.end.insn_num));

	  /* If in replay mode, display where we are in the log.  */
	  if (RECORD_IS_REPLAY)
	    printf_filtered (_("Current instruction number is %s.\n"),
			     pulongest (record_list->u.end.insn_num));

	  /* Display instruction number for last instruction in the log.  */
	  printf_filtered (_("Highest recorded instruction number is %s.\n"), 
			   pulongest (record_insn_count));

	  /* Display log count.  */
	  printf_filtered (_("Log contains %d instructions.\n"), 
			   record_insn_num);
	}
      else
	{
	  printf_filtered (_("No instructions have been logged.\n"));
	}
    }
  else
    {
      printf_filtered (_("target record is not active.\n"));
    }

  /* Display max log size.  */
  printf_filtered (_("Max logged instructions is %d.\n"),
		   record_insn_max_num);
}

/* Record log save-file format
   Version 1 (never released)

   Header:
     4 bytes: magic number htonl(0x20090829).
       NOTE: be sure to change whenever this file format changes!

   Records:
     record_end:
       1 byte:  record type (record_end, see enum record_type).
     record_reg:
       1 byte:  record type (record_reg, see enum record_type).
       8 bytes: register id (network byte order).
       MAX_REGISTER_SIZE bytes: register value.
     record_mem:
       1 byte:  record type (record_mem, see enum record_type).
       8 bytes: memory length (network byte order).
       8 bytes: memory address (network byte order).
       n bytes: memory value (n == memory length).

   Version 2
     4 bytes: magic number netorder32(0x20091016).
       NOTE: be sure to change whenever this file format changes!

   Records:
     record_end:
       1 byte:  record type (record_end, see enum record_type).
       4 bytes: signal
       4 bytes: instruction count
     record_reg:
       1 byte:  record type (record_reg, see enum record_type).
       4 bytes: register id (network byte order).
       n bytes: register value (n == actual register size).
                (eg. 4 bytes for x86 general registers).
     record_mem:
       1 byte:  record type (record_mem, see enum record_type).
       4 bytes: memory length (network byte order).
       8 bytes: memory address (network byte order).
       n bytes: memory value (n == memory length).

*/

/* bfdcore_read -- read bytes from a core file section.  */

static inline void
bfdcore_read (bfd *obfd, asection *osec, void *buf, int len, int *offset)
{
  int ret = bfd_get_section_contents (obfd, osec, buf, *offset, len);

  if (ret)
    *offset += len;
  else
    error (_("Failed to read %d bytes from core file %s ('%s')."),
	   len, bfd_get_filename (obfd),
	   bfd_errmsg (bfd_get_error ()));
}

static inline uint64_t
netorder64 (uint64_t input)
{
  uint64_t ret;

  store_unsigned_integer ((gdb_byte *) &ret, sizeof (ret), 
			  BFD_ENDIAN_BIG, input);
  return ret;
}

static inline uint32_t
netorder32 (uint32_t input)
{
  uint32_t ret;

  store_unsigned_integer ((gdb_byte *) &ret, sizeof (ret), 
			  BFD_ENDIAN_BIG, input);
  return ret;
}

static inline uint16_t
netorder16 (uint16_t input)
{
  uint16_t ret;

  store_unsigned_integer ((gdb_byte *) &ret, sizeof (ret), 
			  BFD_ENDIAN_BIG, input);
  return ret;
}

/* Restore the execution log from a core_bfd file.  */
static void
record_restore (void)
{
  uint32_t magic;
  struct cleanup *old_cleanups;
  struct record_entry *rec;
  asection *osec;
  uint32_t osec_size;
  int bfd_offset = 0;
  struct regcache *regcache;

  /* We restore the execution log from the open core bfd,
     if there is one.  */
  if (core_bfd == NULL)
    return;

  /* "record_restore" can only be called when record list is empty.  */
  gdb_assert (record_first.next == NULL);
 
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "Restoring recording from core file.\n");

  /* Now need to find our special note section.  */
  osec = bfd_get_section_by_name (core_bfd, "null0");
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "Find precord section %s.\n",
			osec ? "succeeded" : "failed");
  if (osec == NULL)
    return;
  osec_size = bfd_section_size (core_bfd, osec);
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "%s", bfd_section_name (core_bfd, osec));

  /* Check the magic code.  */
  bfdcore_read (core_bfd, osec, &magic, sizeof (magic), &bfd_offset);
  if (magic != RECORD_FILE_MAGIC)
    error (_("Version mis-match or file format error in core file %s."),
	   bfd_get_filename (core_bfd));
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog,
			"  Reading 4-byte magic cookie "
			"RECORD_FILE_MAGIC (0x%s)\n",
			phex_nz (netorder32 (magic), 4));

  /* Restore the entries in recfd into record_arch_list_head and
     record_arch_list_tail.  */
  record_arch_list_head = NULL;
  record_arch_list_tail = NULL;
  record_insn_num = 0;
  old_cleanups = make_cleanup (record_arch_list_cleanups, 0);
  regcache = get_current_regcache ();

  while (1)
    {
      uint8_t rectype;
      uint32_t regnum, len, signal, count;
      uint64_t addr;

      /* We are finished when offset reaches osec_size.  */
      if (bfd_offset >= osec_size)
	break;
      bfdcore_read (core_bfd, osec, &rectype, sizeof (rectype), &bfd_offset);

      switch (rectype)
        {
        case record_reg: /* reg */
          /* Get register number to regnum.  */
          bfdcore_read (core_bfd, osec, &regnum,
			sizeof (regnum), &bfd_offset);
	  regnum = netorder32 (regnum);

          rec = record_reg_alloc (regcache, regnum);

          /* Get val.  */
          bfdcore_read (core_bfd, osec, record_get_loc (rec),
			rec->u.reg.len, &bfd_offset);

	  if (record_debug)
	    fprintf_unfiltered (gdb_stdlog,
				"  Reading register %d (1 "
				"plus %lu plus %d bytes)\n",
				rec->u.reg.num,
				(unsigned long) sizeof (regnum),
				rec->u.reg.len);
          break;

        case record_mem: /* mem */
          /* Get len.  */
          bfdcore_read (core_bfd, osec, &len, 
			sizeof (len), &bfd_offset);
	  len = netorder32 (len);

          /* Get addr.  */
          bfdcore_read (core_bfd, osec, &addr,
			sizeof (addr), &bfd_offset);
	  addr = netorder64 (addr);

          rec = record_mem_alloc (addr, len);

          /* Get val.  */
          bfdcore_read (core_bfd, osec, record_get_loc (rec),
			rec->u.mem.len, &bfd_offset);

	  if (record_debug)
	    fprintf_unfiltered (gdb_stdlog,
				"  Reading memory %s (1 plus "
				"%lu plus %lu plus %d bytes)\n",
				paddress (get_current_arch (),
					  rec->u.mem.addr),
				(unsigned long) sizeof (addr),
				(unsigned long) sizeof (len),
				rec->u.mem.len);
          break;

        case record_end: /* end */
          rec = record_end_alloc ();
          record_insn_num ++;

	  /* Get signal value.  */
	  bfdcore_read (core_bfd, osec, &signal, 
			sizeof (signal), &bfd_offset);
	  signal = netorder32 (signal);
	  rec->u.end.sigval = signal;

	  /* Get insn count.  */
	  bfdcore_read (core_bfd, osec, &count, 
			sizeof (count), &bfd_offset);
	  count = netorder32 (count);
	  rec->u.end.insn_num = count;
	  record_insn_count = count + 1;
	  if (record_debug)
	    fprintf_unfiltered (gdb_stdlog,
				"  Reading record_end (1 + "
				"%lu + %lu bytes), offset == %s\n",
				(unsigned long) sizeof (signal),
				(unsigned long) sizeof (count),
				paddress (get_current_arch (),
					  bfd_offset));
          break;

        default:
          error (_("Bad entry type in core file %s."),
		 bfd_get_filename (core_bfd));
          break;
        }

      /* Add rec to record arch list.  */
      record_arch_list_add (rec);
    }

  discard_cleanups (old_cleanups);

  /* Add record_arch_list_head to the end of record list.  */
  record_first.next = record_arch_list_head;
  record_arch_list_head->prev = &record_first;
  record_arch_list_tail->next = NULL;
  record_list = &record_first;

  /* Update record_insn_max_num.  */
  if (record_insn_num > record_insn_max_num)
    {
      record_insn_max_num = record_insn_num;
      warning (_("Auto increase record/replay buffer limit to %d."),
               record_insn_max_num);
d174 3
a176 41
  /* Succeeded.  */
  printf_filtered (_("Restored records from core file %s.\n"),
		   bfd_get_filename (core_bfd));

  print_stack_frame (get_selected_frame (NULL), 1, SRC_AND_LOC);
}

/* bfdcore_write -- write bytes into a core file section.  */

static inline void
bfdcore_write (bfd *obfd, asection *osec, void *buf, int len, int *offset)
{
  int ret = bfd_set_section_contents (obfd, osec, buf, *offset, len);

  if (ret)
    *offset += len;
  else
    error (_("Failed to write %d bytes to core file %s ('%s')."),
	   len, bfd_get_filename (obfd),
	   bfd_errmsg (bfd_get_error ()));
}

/* Restore the execution log from a file.  We use a modified elf
   corefile format, with an extra section for our data.  */

static void
cmd_record_restore (char *args, int from_tty)
{
  core_file_command (args, from_tty);
  record_open (args, from_tty);
}

static void
record_save_cleanups (void *data)
{
  bfd *obfd = data;
  char *pathname = xstrdup (bfd_get_filename (obfd));

  gdb_bfd_unref (obfd);
  unlink (pathname);
  xfree (pathname);
d179 1
a179 2
/* Save the execution log to a file.  We use a modified elf corefile
   format, with an extra section for our data.  */
a184 14
  struct record_entry *cur_record_list;
  uint32_t magic;
  struct regcache *regcache;
  struct gdbarch *gdbarch;
  struct cleanup *old_cleanups;
  struct cleanup *set_cleanups;
  bfd *obfd;
  int save_size = 0;
  asection *osec = NULL;
  int bfd_offset = 0;

  if (strcmp (current_target.to_shortname, "record") != 0)
    error (_("This command can only be used with target 'record'.\n"
	     "Use 'target record' first.\n"));
d186 3
a188 1
  if (args && *args)
d193 1
a193 1
      snprintf (recfilename_buffer, sizeof (recfilename_buffer),
d198 1
a198 214
  /* Open the save file.  */
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, "Saving execution log to core file '%s'\n",
			recfilename);

  /* Open the output file.  */
  obfd = create_gcore_bfd (recfilename);
  old_cleanups = make_cleanup (record_save_cleanups, obfd);

  /* Save the current record entry to "cur_record_list".  */
  cur_record_list = record_list;

  /* Get the values of regcache and gdbarch.  */
  regcache = get_current_regcache ();
  gdbarch = get_regcache_arch (regcache);

  /* Disable the GDB operation record.  */
  set_cleanups = record_gdb_operation_disable_set ();

  /* Reverse execute to the begin of record list.  */
  while (1)
    {
      /* Check for beginning and end of log.  */
      if (record_list == &record_first)
        break;

      record_exec_insn (regcache, gdbarch, record_list);

      if (record_list->prev)
        record_list = record_list->prev;
    }

  /* Compute the size needed for the extra bfd section.  */
  save_size = 4;	/* magic cookie */
  for (record_list = record_first.next; record_list;
       record_list = record_list->next)
    switch (record_list->type)
      {
      case record_end:
	save_size += 1 + 4 + 4;
	break;
      case record_reg:
	save_size += 1 + 4 + record_list->u.reg.len;
	break;
      case record_mem:
	save_size += 1 + 4 + 8 + record_list->u.mem.len;
	break;
      }

  /* Make the new bfd section.  */
  osec = bfd_make_section_anyway_with_flags (obfd, "precord",
                                             SEC_HAS_CONTENTS
                                             | SEC_READONLY);
  if (osec == NULL)
    error (_("Failed to create 'precord' section for corefile %s: %s"),
	   recfilename,
           bfd_errmsg (bfd_get_error ()));
  bfd_set_section_size (obfd, osec, save_size);
  bfd_set_section_vma (obfd, osec, 0);
  bfd_set_section_alignment (obfd, osec, 0);
  bfd_section_lma (obfd, osec) = 0;

  /* Save corefile state.  */
  write_gcore_file (obfd);

  /* Write out the record log.  */
  /* Write the magic code.  */
  magic = RECORD_FILE_MAGIC;
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog,
			"  Writing 4-byte magic cookie "
			"RECORD_FILE_MAGIC (0x%s)\n",
		      phex_nz (magic, 4));
  bfdcore_write (obfd, osec, &magic, sizeof (magic), &bfd_offset);

  /* Save the entries to recfd and forward execute to the end of
     record list.  */
  record_list = &record_first;
  while (1)
    {
      /* Save entry.  */
      if (record_list != &record_first)
        {
	  uint8_t type;
	  uint32_t regnum, len, signal, count;
          uint64_t addr;

	  type = record_list->type;
          bfdcore_write (obfd, osec, &type, sizeof (type), &bfd_offset);

          switch (record_list->type)
            {
            case record_reg: /* reg */
	      if (record_debug)
		fprintf_unfiltered (gdb_stdlog,
				    "  Writing register %d (1 "
				    "plus %lu plus %d bytes)\n",
				    record_list->u.reg.num,
				    (unsigned long) sizeof (regnum),
				    record_list->u.reg.len);

              /* Write regnum.  */
              regnum = netorder32 (record_list->u.reg.num);
              bfdcore_write (obfd, osec, &regnum,
			     sizeof (regnum), &bfd_offset);

              /* Write regval.  */
              bfdcore_write (obfd, osec, record_get_loc (record_list),
			     record_list->u.reg.len, &bfd_offset);
              break;

            case record_mem: /* mem */
	      if (record_debug)
		fprintf_unfiltered (gdb_stdlog,
				    "  Writing memory %s (1 plus "
				    "%lu plus %lu plus %d bytes)\n",
				    paddress (gdbarch,
					      record_list->u.mem.addr),
				    (unsigned long) sizeof (addr),
				    (unsigned long) sizeof (len),
				    record_list->u.mem.len);

	      /* Write memlen.  */
	      len = netorder32 (record_list->u.mem.len);
	      bfdcore_write (obfd, osec, &len, sizeof (len), &bfd_offset);

	      /* Write memaddr.  */
	      addr = netorder64 (record_list->u.mem.addr);
	      bfdcore_write (obfd, osec, &addr, 
			     sizeof (addr), &bfd_offset);

	      /* Write memval.  */
	      bfdcore_write (obfd, osec, record_get_loc (record_list),
			     record_list->u.mem.len, &bfd_offset);
              break;

              case record_end:
		if (record_debug)
		  fprintf_unfiltered (gdb_stdlog,
				      "  Writing record_end (1 + "
				      "%lu + %lu bytes)\n", 
				      (unsigned long) sizeof (signal),
				      (unsigned long) sizeof (count));
		/* Write signal value.  */
		signal = netorder32 (record_list->u.end.sigval);
		bfdcore_write (obfd, osec, &signal,
			       sizeof (signal), &bfd_offset);

		/* Write insn count.  */
		count = netorder32 (record_list->u.end.insn_num);
		bfdcore_write (obfd, osec, &count,
			       sizeof (count), &bfd_offset);
                break;
            }
        }

      /* Execute entry.  */
      record_exec_insn (regcache, gdbarch, record_list);

      if (record_list->next)
        record_list = record_list->next;
      else
        break;
    }

  /* Reverse execute to cur_record_list.  */
  while (1)
    {
      /* Check for beginning and end of log.  */
      if (record_list == cur_record_list)
        break;

      record_exec_insn (regcache, gdbarch, record_list);

      if (record_list->prev)
        record_list = record_list->prev;
    }

  do_cleanups (set_cleanups);
  gdb_bfd_unref (obfd);
  discard_cleanups (old_cleanups);

  /* Succeeded.  */
  printf_filtered (_("Saved core file %s with execution log.\n"),
		   recfilename);
}

/* record_goto_insn -- rewind the record log (forward or backward,
   depending on DIR) to the given entry, changing the program state
   correspondingly.  */

static void
record_goto_insn (struct record_entry *entry,
		  enum exec_direction_kind dir)
{
  struct cleanup *set_cleanups = record_gdb_operation_disable_set ();
  struct regcache *regcache = get_current_regcache ();
  struct gdbarch *gdbarch = get_regcache_arch (regcache);

  /* Assume everything is valid: we will hit the entry,
     and we will not hit the end of the recording.  */

  if (dir == EXEC_FORWARD)
    record_list = record_list->next;

  do
    {
      record_exec_insn (regcache, gdbarch, record_list);
      if (dir == EXEC_REVERSE)
	record_list = record_list->prev;
      else
	record_list = record_list->next;
    } while (record_list != entry);
  do_cleanups (set_cleanups);
d206 1
a206 1
static void
d209 1
a209 2
  struct record_entry *p = NULL;
  ULONGEST target_insn = 0;
d216 1
a216 8
    {
      /* Special case.  Find first insn.  */
      for (p = &record_first; p != NULL; p = p->next)
	if (p->type == record_end)
	  break;
      if (p)
	target_insn = p->u.end.insn_num;
    }
d218 1
a218 10
    {
      /* Special case.  Find last insn.  */
      for (p = record_list; p->next != NULL; p = p->next)
	;
      for (; p!= NULL; p = p->prev)
	if (p->type == record_end)
	  break;
      if (p)
	target_insn = p->u.end.insn_num;
    }
d221 1
a221 7
      /* General case.  Find designated insn.  */
      target_insn = parse_and_eval_long (arg);

      for (p = &record_first; p != NULL; p = p->next)
	if (p->type == record_end && p->u.end.insn_num == target_insn)
	  break;
    }
d223 2
a224 15
  if (p == NULL)
    error (_("Target insn '%s' not found."), arg);
  else if (p == record_list)
    error (_("Already at insn '%s'."), arg);
  else if (p->u.end.insn_num > record_list->u.end.insn_num)
    {
      printf_filtered (_("Go forward to insn number %s\n"),
		       pulongest (target_insn));
      record_goto_insn (p, EXEC_FORWARD);
    }
  else
    {
      printf_filtered (_("Go backward to insn number %s\n"),
		       pulongest (target_insn));
      record_goto_insn (p, EXEC_REVERSE);
a225 3
  registers_changed ();
  reinit_frame_cache ();
  print_stack_frame (get_selected_frame (NULL), 1, SRC_AND_LOC);
a235 10
  /* Init record_first.  */
  record_first.prev = NULL;
  record_first.next = NULL;
  record_first.type = record_end;

  init_record_ops ();
  add_target (&record_ops);
  init_record_core_ops ();
  add_target (&record_core_ops);

d245 1
a245 1
		      _("Abbreviated form of \"target record\" command."),
a269 6
  c = add_cmd ("restore", class_obscure, cmd_record_restore,
	       _("Restore the execution log from a file.\n\
Argument is filename.  File must be created with 'record save'."),
	       &record_cmdlist);
  set_cmd_completer (c, filename_completer);

a280 20
  /* Record instructions number limit command.  */
  add_setshow_boolean_cmd ("stop-at-limit", no_class,
			   &record_stop_at_limit, _("\
Set whether record/replay stops when record/replay buffer becomes full."), _("\
Show whether record/replay stops when record/replay buffer becomes full."),
			   _("Default is ON.\n\
When ON, if the record/replay buffer becomes full, ask user what to do.\n\
When OFF, if the record/replay buffer becomes full,\n\
delete the oldest recorded instruction to make room for each new one."),
			   NULL, NULL,
			   &set_record_cmdlist, &show_record_cmdlist);
  add_setshow_uinteger_cmd ("insn-number-max", no_class,
			    &record_insn_max_num,
			    _("Set record/replay buffer limit."),
			    _("Show record/replay buffer limit."), _("\
Set the maximum number of instructions to be stored in the\n\
record/replay buffer.  Zero means unlimited.  Default is 200000."),
			    set_record_insn_max_num,
			    NULL, &set_record_cmdlist, &show_record_cmdlist);

a284 12

  add_setshow_boolean_cmd ("memory-query", no_class,
			   &record_memory_query, _("\
Set whether query if PREC cannot record memory change of next instruction."),
                           _("\
Show whether query if PREC cannot record memory change of next instruction."),
                           _("\
Default is OFF.\n\
When ON, query if PREC cannot record memory change of next instruction."),
			   NULL, NULL,
			   &set_record_cmdlist, &show_record_cmdlist);

@


1.77
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d3 1
a3 1
   Copyright (C) 2008-2012 Free Software Foundation, Inc.
@


1.76
log
@gdb/doc:
2012-09-21  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (GDB/MI Async Records): Document notification
	'record-started' and 'record-stopped'.
	* observer.texi (GDB Observers): New observer 'record-changed'.
gdb:
2012-09-21  Yao Qi  <yao@@codesourcery.com>

	* mi/mi-interp.c: Declare mi_record_changed.
	(mi_interpreter_init): Call observer_attach_record_changed.
	(mi_record_changed): New.
	* record.c (record_open): Call observer_notify_record_changed.
	(cmd_record_stop): Call observer_notify_record_changed.
	* NEWS: Mention it.

gdb/testsuite:
2012-09-21  Yao Qi  <yao@@codesourcery.com>

	* gdb.mi/mi-record-changed.exp: New.
	* gdb.mi/mi-reverse.exp: Adjust expected output.
@
text
@d515 1
a515 1
			paddress (target_gdbarch, addr), len);
d522 1
a522 1
  if (record_read_memory (target_gdbarch, addr, record_get_loc (rec), len))
d877 1
a877 1
  if (!gdbarch_process_record_p (target_gdbarch))
d1689 1
a1689 1
		       paddress (target_gdbarch, offset)))
@


1.75
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@d36 1
d1005 2
d2266 2
@


1.74
log
@2012-07-20  Pedro Alves  <palves@@redhat.com>

	* i386-tdep.c (i386_record_modrm, i386_record_lea_modrm_addr)
	(i386_process_record): Use record_read_memory.
	* record.c (record_read_memory): New function.
	(record_arch_list_add_mem, record_exec_insn): Use
	record_read_memory.
	* record.h (record_read_memory): Declare.
@
text
@d156 1
a156 1
int record_debug = 0;
d2985 7
a2991 7
  add_setshow_zinteger_cmd ("record", no_class, &record_debug,
			    _("Set debugging of record/replay feature."),
			    _("Show debugging of record/replay feature."),
			    _("When enabled, debugging output for "
			      "record/replay feature is displayed."),
			    NULL, show_record_debug, &setdebuglist,
			    &showdebuglist);
@


1.73
log
@2012-07-19  Pedro Alves  <palves@@redhat.com>

	* record.c (record_resume): Ask the target beneath to report all
	signals.
@
text
@d488 14
d521 1
a521 1
  if (target_read_memory (addr, record_get_loc (rec), len))
a522 5
      if (record_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Process record: error reading memory at "
			    "addr = %s len = %d.\n",
			    paddress (target_gdbarch, addr), len);
d751 3
a753 9
            if (target_read_memory (entry->u.mem.addr, mem, entry->u.mem.len))
              {
                entry->u.mem.mem_entry_not_accessible = 1;
                if (record_debug)
                  warning (_("Process record: error reading memory at "
			     "addr = %s len = %d."),
                           paddress (gdbarch, entry->u.mem.addr),
                           entry->u.mem.len);
              }
@


1.72
log
@	* dwarf2read.c (try_open_dwo_file): Use gdb_bfd_ref and
	gdb_bfd_unref.
	(free_dwo_file): Use gdb_bfd_unref.
	* cli/cli-dump.c: Include gdb_bfd.h.
	(bfd_openw_with_cleanup): Use gdb_bfd_ref.
	(bfd_openr_with_cleanup): Likewise.
	* windows-nat.c (windows_make_so): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* utils.c: Include gdb_bfd.h.
	(do_bfd_close_cleanup): Use gdb_bfd_unref.
	* symfile.c: Include gdb_bfd.h.
	(separate_debug_file_exists): Use gdb_bfd_unref.
	(bfd_open_maybe_remote): Use gdb_bfd_ref.
	(symfile_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	(generic_load): Use gdb_bfd_ref.
	(reread_symbols): Use gdb_bfd_unref.
	* symfile-mem.c: Include gdb_bfd.h.
	(symbol_file_add_from_memory): Use make_cleanup_bfd_close.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib.c: Include gdb_bfd.h.
	(solib_bfd_fopen): Use gdb_bfd_ref.
	(solib_bfd_open): Use gdb_bfd_unref.
	(free_so_symbols): Use gdb_bfd_unref.
	(reload_shared_libraries_1): Use gdb_bfd_unref.
	* solib-spu.c: Include gdb_bfd.h.
	(spu_bfd_fopen): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* solib-frv.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-dsbt.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-darwin.c: Include gdb_bfd.h.
	(darwin_solib_get_all_image_info_addr_at_init): Use gdb_bfd_ref,
	gdb_bfd_unref.
	(darwin_bfd_open): Use gdb_bfd_unref.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_ref, gdb_bfd_unref.
	* remote-mips.c: Include gdb_bfd.h.
	(mips_load_srec): Use gdb_bfd_ref.
	(pmon_load_fast): Use gdb_bfd_ref.
	* remote-m32r-sdi.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	* record.c: Include gdb_bfd.h.
	(record_save_cleanups): Use gdb_bfd_unref.
	(cmd_record_save): Use gdb_bfd_unref.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* objfiles.h (gdb_bfd_close_or_warn): Remove.
	(gdb_bfd_ref, gdb_bfd_unref): Move to gdb_bfd.h.
	* objfiles.c: Include gdb_bfd.h.
	(free_objfile): Use gdb_bfd_unref.
	(gdb_bfd_close_or_warn, gdb_bfd_ref, gdb_bfd_unref): Move to
	gdb_bfd.c.
	* machoread.c (macho_add_oso_symfile): Use gdb_bfd_unref.
	(macho_symfile_read_all_oso): Use gdb_bfd_ref, gdb_bfd_unref.
	(macho_check_dsym): Likewise.
	* m32r-rom.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	(m32r_upload_command): Use gdb_bfd_ref.
	* jit.c: Include gdb_bfd.h.
	(jit_bfd_try_read_symtab): Use gdb_bfd_ref, gdb_bfd_unref.
	* gdb_bfd.h: New file.
	* gdb_bfd.c: New file.
	* gcore.c: Include gdb_bfd.h.
	(create_gcore_bfd): Use gdb_bfd_ref.
	(do_bfd_delete_cleanup): Use gdb_bfd_unref.
	(gcore_command): Use gdb_bfd_unref.
	* exec.c: Include gdb_bfd.h.
	(exec_close): Use gdb_bfd_unref.
	(exec_close_1): Use gdb_bfd_unref.
	(exec_file_attach): Use gdb_bfd_ref.
	* elfread.c: Include gdb_bfd.h.
	(build_id_verify): Use gdb_bfd_unref.
	* dsrec.c: Include gdb_bfd.h.
	(load_srec): Use gdb_bfd_ref.
	* corelow.c: Include gdb_bfd.h.
	(core_close): Use gdb_bfd_unref.
	(core_open): Use gdb_bfd_ref.
	* bfd-target.c: Include gdb_bfd.h.
	(target_bfd_xclose): Use gdb_bfd_unref.
	(target_bfd_reopen): Use gdb_bfd_ref.
	* Makefile.in (SFILES): Add gdb_bfd.c.
	(HFILES_NO_SRCDIR): Add gdb_bfd.h.
	(COMMON_OBS): Add gdb_bfd.o.
@
text
@d1107 3
@


1.71
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d35 1
d2642 1
a2642 1
  bfd_close (obfd);
d2858 1
a2858 1
  bfd_close (obfd);
@


1.70
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d534 1
a534 1
  rec->u.end.sigval = TARGET_SIGNAL_0;
d624 1
a624 1
  if (signal == TARGET_SIGNAL_0
d1226 1
a1226 1
		  && status->value.sig == TARGET_SIGNAL_TRAP)
d1268 1
a1268 1
                                                        TARGET_SIGNAL_0))
d1271 1
a1271 1
                           status->value.sig = TARGET_SIGNAL_0;
d1293 1
a1293 1
						TARGET_SIGNAL_0);
d1432 1
a1432 1
		  if (record_list->u.end.sigval != TARGET_SIGNAL_0)
d1456 2
a1457 2
	status->value.sig = TARGET_SIGNAL_INT;
      else if (record_list->u.end.sigval != TARGET_SIGNAL_0)
d1461 1
a1461 1
	status->value.sig = TARGET_SIGNAL_TRAP;
@


1.69
log
@gdb:
	Revert this patch to allow breakpoint always-inserted
	in record target.
	2011-12-05  Pedro Alves  <pedro@@codesourcery.com>
        * breakpoint.c: Include record.h.
        (breakpoints_always_inserted_mode): Return false when the record
        target is in use.

	* breakpoint.c (iterate_over_bp_locations): New.
	* breakpoint.h: Declare.
	New typedef walk_bp_location_callback.
	* record.c (record_open): Call record_init_record_breakpoints.
	(record_sync_record_breakpoints): New.
	(record_init_record_breakpoints): New.
	* NEWS: Mention supporting breakpoint always-inserted mode in
	record target.
@
text
@d103 1
a103 1
  enum target_signal sigval;
d212 1
a212 1
                                         enum target_signal);
d584 1
a584 1
record_message (struct regcache *regcache, enum target_signal signal)
d655 1
a655 1
  enum target_signal signal;
d668 1
a668 1
                             enum target_signal signal)
d789 1
a789 1
			      enum target_signal);
d1063 1
a1063 1
               enum target_signal signal)
d1984 1
a1984 1
                    enum target_signal signal)
@


1.68
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-tdep.c (amd64_linux_record_signal): Make static.
	* breakpoint.c (create_exception_master_breakpoint, trace_command)
	(ftrace_command, strace_command): Make static.
	* d-lang.c (_initialize_d_language): Declare.
	* dwarf2expr.c (_initialize_dwarf2expr): Declare.
	* dwarf2loc.c (_initialize_dwarf2loc):
	* dwarf2read.c (process_psymtab_comp_unit): Make static.
	* exec.c (exec_get_section_table): Make static.
	* i386-linux-tdep.c (i386_linux_record_signal): Make static.
	* infcmd.c (ensure_valid_thread, ensure_not_tfind_mode): Make static.
	* inferior.c (remove_inferior_command, add_inferior_command)
	(clone_inferior_command): Make static.
	* linux-nat.c (linux_nat_thread_address_space)
	(linux_nat_core_of_thread): Make static.
	* linux-tdep.c (_initialize_linux_tdep): Declare.
	* objc-lang.c (_initialize_objc_lang): Declare.
	* opencl-lang.c (builtin_opencl_type, opencl_language_arch_info):
	Make static.
	(_initialize_opencl_language): Declare.
	* record.c (_initialize_record): Declare.
	* remote.c (demand_private_info, remote_get_tib_address)
	(remote_supports_cond_tracepoints)
	(remote_supports_fast_tracepoints, remote_get_tracepoint_status):
	Make static.
	* skip.c (_initialize_step_skip): Declare.
	* symtab.c (skip_prologue_using_lineinfo): Make static.
	* tracepoint.c (delete_trace_state_variable)
	(trace_variable_command, delete_trace_variable_command)
	(get_uploaded_tsv, find_matching_tracepoint_location)
	(find_matching_tsv, create_tsv_from_upload, get_traceframe_info):
	Make static.
	* value.c (pack_unsigned_long): Make static.
	* varobj.c (varobj_ensure_python_env): Make static.
	* windows-tdep.c (_initialize_windows_tdep): Declare.
	* xml-syscall.c (make_cleanup_free_syscalls_info): Make static.
@
text
@d899 2
d998 2
d1751 29
@


1.67
log
@2012-01-18  Pedro Alves  <palves@@redhat.com>

	* record.c (struct record_breakpoint, record_breakpoint_p)
	(record_breakpoints): New.
	(record_insert_breakpoint, record_remove_breakpoint): Manage
	record breakpoints list.  Only remove breakpoints from the
	inferior if they had been inserted there in the first place.
@
text
@d2927 3
@


1.66
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1721 29
a1749 3
/* Behavior is conditional on RECORD_IS_REPLAY.
   We will not actually insert or remove breakpoints when replaying,
   nor when recording.  */
d1755 3
d1760 7
a1766 2
      struct cleanup *old_cleanups = record_gdb_operation_disable_set ();
      int ret = record_beneath_to_insert_breakpoint (gdbarch, bp_tgt);
d1768 2
d1772 4
a1775 1
      return ret;
d1778 5
d1792 6
a1797 1
  if (!RECORD_IS_REPLAY)
d1799 7
a1805 2
      struct cleanup *old_cleanups = record_gdb_operation_disable_set ();
      int ret = record_beneath_to_remove_breakpoint (gdbarch, bp_tgt);
d1807 7
a1813 1
      do_cleanups (old_cleanups);
d1815 3
a1817 1
      return ret;
d1820 1
a1820 1
  return 0;
@


1.65
log
@2011-06-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* infcall.c (run_inferior_call): Don't mask async.  Instead force
	a synchronous wait, if the target can async.

	* target.h (struct target_ops): Delete to_async_mask.
	(target_async_mask): Delete.
	* target.c (update_current_target): Delete references to to_async_mask.
	* linux-nat.c (linux_nat_async_mask_value): Delete.
	(linux_nat_is_async_p, linux_nat_can_async_p): Remove references
	to linux_nat_async_mask_value.
	(linux_nat_async_mask): Delete.
	(linux_nat_async, linux_nat_close): Remove references to
	linux_nat_async_mask_value.
	* record.c (record_async_mask_value): Delete.
	(record_async): Remove references to record_async_mask_value.
	(record_async_mask): Delete.
	(record_can_async_p, record_is_async_p): Remove references to
	record_async_mask_value.
	(init_record_ops, init_record_core_ops): Remove references to
	record_async_mask.
	* remote.c (remote_async_mask_value): Delete.
	(init_remote_ops): Remove reference to remote_async_mask.
	(remote_can_async_p, remote_is_async_p): Remove references to
	remote_async_mask_value.
	(remote_async): Remove references to remote_async_mask_value.
	(remote_async_mask): Delete.

	* infrun.c (fetch_inferior_event): Don't claim registers changed
	if the current thread is already not executing.
@
text
@d3 1
a3 1
   Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.65.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 2008-2012 Free Software Foundation, Inc.
@


1.64
log
@2011-05-26  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* record.c: Include event-loop.h, inf-loop.h.
	(record_beneath_to_async): New global.
	(tmp_to_async): New global.
	(record_async_inferior_event_token): New global.
	(record_open_1): Don't error out if async is enabled.
	(record_open): Handle to_async.  Create an async event source in
	the event loop.
	(record_close): Delete the async event source.
	(record_resumed): New global.
	(record_execution_dir): New global.
	(record_resume, record_core_resume): Set them.  Register the
	target on the event loop.
	(record_wait): Rename to ...
	(record_wait_1): ... this.  Add more debug output.  Handle
	TARGET_WNOHANG, and the target beneath returning
	TARGET_WAITKIND_IGNORE.
	(record_wait): Reimplement on top of record_wait_1.
	(record_async_mask_value): New global.
	(record_async, record_async_mask, record_can_async_p)
	(record_is_async_p, record_execution_direction): New functions.
	(init_record_ops, init_record_core_ops): Install new methods.
	* infrun.c (fetch_inferior_event): Temporarily switch the global
	execution direction to the direction the target was going.
	(execution_direction): Change type to int.
	* target.c (default_execution_direction): New function.
	(update_current_target): Inherit and de_fault
	to_execution_direction.
	* target.h (struct target_ops) <to_execution_direction>: New
	field.
	(target_execution_direction): New macro.
	* inferior.h (execution_direction): Change type to int.
@
text
@a1819 2
static int record_async_mask_value = 1;

a1823 4
  if (record_async_mask_value == 0)
    internal_error (__FILE__, __LINE__,
		    _("Calling record_async when async is masked"));

a1831 9
record_async_mask (int new_mask)
{
  int curr_mask = record_async_mask_value;

  record_async_mask_value = new_mask;
  return curr_mask;
}

static int
d1835 1
a1835 4
  if (!target_async_permitted)
    return 0;

  return record_async_mask_value;
d1842 1
a1842 4
  if (!target_async_permitted)
    return 0;

  return record_async_mask_value;
a1880 1
  record_ops.to_async_mask = record_async_mask;
a2105 1
  record_core_ops.to_async_mask = record_async_mask;
@


1.63
log
@	ARI fixes: Add missing internationalization markups throughout
	C source files.
	* darwin-nat-info.c: Ditto.
	* record.c: Ditto.
	* remote.c: Ditto.
	* mi/mi-main.c: Ditto.
@
text
@d33 2
d236 1
d812 2
d817 11
a870 3
  if (target_async_permitted)
    error (_("Process record target can't debug inferior in asynchronous "
	     "mode (target-async)."));
d927 1
d960 2
d985 1
d991 5
d1027 3
d1034 21
d1062 2
d1105 10
d1161 3
a1163 3
record_wait (struct target_ops *ops,
	     ptid_t ptid, struct target_waitstatus *status,
	     int options)
d1170 12
a1181 2
			"record_resume_step = %d\n",
			record_resume_step);
d1205 8
d1218 1
a1218 1
	        return ret;
d1283 4
d1468 18
d1820 52
d1899 5
d1914 12
d2125 5
@


1.62
log
@	ARI fixes: Messages should have no trailing new lines.
	* darwin-nat.c (mach_check_error): Remove trailing new line from
	warning function call message.
	* record.c (bfdcore_read): Idem for error call.
@
text
@d742 2
a743 2
                  warning ("Process record: error reading memory at "
			   "addr = %s len = %d.",
d755 2
a756 2
                      warning ("Process record: error writing memory at "
			       "addr = %s len = %d.",
@


1.61
log
@	Fix ARI warnings about new lines at the end of messages, which
	are unneeded as there is a new line added at the end of the message
	automatically.
	* darwin-nat.c (darwin_stop_inferior): Ditto.
	* dec-thread.c (dec_thread_get_ada_task_ptid): Ditto.
	* dfp.c (decimal_to_number): Ditto.
	* exec.c (print_section_info): Ditto.
	* i386-darwin-nat.c (darwin_set_sstep): Ditto.
	* osdata.c (get_osdata): Ditto.
	* record.c (bfdcore_write): Ditto.
	* remote-mips.c (mips_readchar): Ditto.
	* remote.c (read_ptid): Ditto.
	* ser-mingw.c (ser_windows_raw): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	* windows-nat.c (fake_create_process): Ditto.
@
text
@d2157 1
a2157 1
    error (_("Failed to read %d bytes from core file %s ('%s').\n"),
@


1.60
log
@	* target.h (struct target_ops) <to_has_execution>: Add ptid_t
	parameter.
	(target_has_execution_1): Update.
	(target_has_execution_current): Declare.
	(target_has_execution): Call target_has_execution_current.
	(default_child_has_execution): Update.
	* target.c (default_child_has_execution): Add 'the_ptid'
	parameter.
	(target_has_execution_1): Likewise.
	(target_has_execution_current): New function.
	(add_target): Update.
	(init_dummy_target): Update.
	* remote-m32r-sdi.c (m32r_has_execution): New function.
	(init_m32r_ops): Use it.
	* record.c (record_core_has_execution): Now static.  Add
	'the_ptid' parameter.
	* inferior.c (have_live_inferiors): Don't save current thread.
	Use target_has_execution_1.
@
text
@d2376 1
a2376 1
    error (_("Failed to write %d bytes to core file %s ('%s').\n"),
@


1.59
log
@2011-03-02  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_restore): Move printf to before error return.
@
text
@d1926 2
a1927 2
int
record_core_has_execution (struct target_ops *ops)
@


1.58
log
@2011-03-01  Michael Snyder  <msnyder@@vmware.com>

	* reverse.c (record_restore): Move null-check to before pointer
	dereference.
@
text
@d2217 3
a2223 3
    fprintf_unfiltered (gdb_stdlog, "Find precord section %s.\n",
			osec ? "succeeded" : "failed");
  if (record_debug)
@


1.57
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d2217 2
a2222 2
  if (osec == NULL)
    return;
@


1.56
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d498 1
a498 1
  if (!addr)	/* FIXME: Why?  Some arch must permit it... */
@


1.55
log
@run copyright.sh for 2011.
@
text
@d868 2
a869 1
    error (_("Could not find 'to_store_registers' method on the target stack."));
d871 2
a872 1
    error (_("Could not find 'to_insert_breakpoint' method on the target stack."));
d874 2
a875 1
    error (_("Could not find 'to_remove_breakpoint' method on the target stack."));
d877 2
a878 1
    error (_("Could not find 'to_stopped_by_watchpoint' method on the target stack."));
d880 2
a881 1
    error (_("Could not find 'to_stopped_data_address' method on the target stack."));
d1170 2
a1171 1
			  struct gdbarch *gdbarch = get_regcache_arch (regcache);
d1342 3
a1344 2
			fprintf_unfiltered (gdb_stdlog, "\
Process record: hit hw watchpoint.\n");
d2039 2
a2040 2
  printf_unfiltered (_("\
\"set record\" must be followed by an apporpriate subcommand.\n"));
d2232 3
a2234 2
    fprintf_unfiltered (gdb_stdlog, "\
  Reading 4-byte magic cookie RECORD_FILE_MAGIC (0x%s)\n",
d2271 3
a2273 2
	    fprintf_unfiltered (gdb_stdlog, "\
  Reading register %d (1 plus %lu plus %d bytes)\n",
d2297 3
a2299 2
	    fprintf_unfiltered (gdb_stdlog, "\
  Reading memory %s (1 plus %lu plus %lu plus %d bytes)\n",
d2324 3
a2326 2
	    fprintf_unfiltered (gdb_stdlog, "\
  Reading record_end (1 + %lu + %lu bytes), offset == %s\n",
d2503 3
a2505 2
    fprintf_unfiltered (gdb_stdlog, "\
  Writing 4-byte magic cookie RECORD_FILE_MAGIC (0x%s)\n",
d2528 3
a2530 2
		fprintf_unfiltered (gdb_stdlog, "\
  Writing register %d (1 plus %lu plus %d bytes)\n",
d2547 3
a2549 2
		fprintf_unfiltered (gdb_stdlog, "\
  Writing memory %s (1 plus %lu plus %lu plus %d bytes)\n",
d2572 3
a2574 2
		  fprintf_unfiltered (gdb_stdlog, "\
  Writing record_end (1 + %lu + %lu bytes)\n", 
d2786 2
a2787 2
Show whether record/replay stops when record/replay buffer becomes full."), _("\
Default is ON.\n\
@


1.54
log
@Back out the change introducing the "record pic" feature.

gdb/ChangeLog:

	Back out the following change:
	| 2010-06-29  Hui Zhu  <teawater@@gmail.com>
	| * record.c (set_record_pic_cmdlist,
	| show_record_pic_cmdlist): New variables.
	| (set_record_pic_command,
	| show_record_pic_command): New functions.
	| (record_pic_function, record_pic_line, record_pic_enum,
	| set_record_pic_type, record_pic_hide_nofunction,
	| record_pic_hide_nosource, record_pic_hide_same): New variables.
	| (record_pic_fputs): New function.
	| (function_list, node_list, edge_list): New struct.
	| (function_list, node_list, edge_list): New variables.
	| (record_pic_cleanups, record_pic_node,
	| record_pic_edge, cmd_record_pic): New functions.
	| (_initialize_record): Add new commands for record pic.
@
text
@d3 1
a3 1
   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.53
log
@	* gdb_assert.h (gdb_assert_not_reached): New macro.
	(gdb_assert_fail): Fix typo in comment.
	* avr-tdep.c (avr_return_value): Use gdb_assert_not_reached instead of
	gdb_assert (0).
	* darwin-nat.c (darwin_check_new_threads): Ditto.
	* dwarf2read.c (dwarf2_get_section_info): Ditto.
	(munmap_section_buffer): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	(m32c_decode_srcdest4, m32c_decode_sd23, m32c_frame_base): Ditto.
	* macroexp.c (get_character_constant): Ditto.
	(get_string_literal): Ditto.
	* mep-tdep.c (mep_pseudo_cr_size): Ditto.
	(mep_pseudo_cr_index, mep_register_type): Ditto.
	(mep_pseudo_register_read, mep_pseudo_register_write): Ditto.
	(mep_get_insn, mep_analyze_prologue): Ditto.
	* objfiles.c (qsort_cmp): Ditto.
	* prologue-value.c (pv_is_identical): Ditto.
	* record.c (record_get_loc): Ditto.
	* value.c (value_static_field): Ditto.
	* xtensa-tdep.c (call0_track_op): Ditto.
@
text
@a2605 549
/* For "record pic" command.  */

static struct cmd_list_element *set_record_pic_cmdlist,
                               *show_record_pic_cmdlist;

static void
set_record_pic_command (char *args, int from_tty)
{
  printf_unfiltered (_("\
\"set record pic\" must be followed by an apporpriate subcommand.\n"));
  help_list (set_record_cmdlist, "set record pic ", all_commands, gdb_stdout);
}

static void
show_record_pic_command (char *args, int from_tty)
{
  cmd_show_list (show_record_pic_cmdlist, from_tty, "");
}

static const char record_pic_function[] = "function";
static const char record_pic_line[] = "line";
static const char *record_pic_enum[] =
{
  record_pic_function,
  record_pic_line,
  NULL,
};
static const char *set_record_pic_type = record_pic_line;

static int record_pic_hide_nofunction = 1;
static int record_pic_hide_nosource = 1;
static int  record_pic_hide_same = 1;

static void
record_pic_fputs (FILE *fp, const char *buf)
{
  if (fputs (buf, fp) == EOF)
    error (_("Write to file error."));
}

struct function_list
{
  struct function_list *next;
  CORE_ADDR addr;
  int fid;
};
struct node_list
{
  struct node_list *next;
  int count;
  CORE_ADDR addr;
  int showall;
  struct symtab *symtab;
  int line;
  struct minimal_symbol *function;
  int fid;
};
struct edge_list
{
  struct edge_list *next;
  int count;
  struct node_list *s;
  struct node_list *t;
  int frame_diff;
  int is_return;
};
struct function_list *function_list = NULL;
struct node_list *node_list = NULL;
struct edge_list *edge_list = NULL;

static void
record_pic_cleanups (void *data)
{
  FILE *fp = data;
  struct function_list *fl, *fl2;
  struct node_list *nl, *nl2;
  struct edge_list *el, *el2;

  fl = function_list;
  while (fl)
    {
      fl2 = fl;
      fl = fl->next;
      xfree (fl2);
    }
  function_list = NULL;

  nl = node_list;
  while (nl)
    {
      nl2 = nl;
      nl = nl->next;
      xfree (nl2);
    }
  node_list = NULL;

  el = edge_list;
  while (el)
    {
      el2 = el;
      el = el->next;
      xfree (el2);
    }
  edge_list = NULL;

  fclose (fp);
}

static void
record_pic_node (char *buf, int buf_max, struct gdbarch *gdbarch,
                 const char *type, struct node_list *nlp)
{
  if (type == record_pic_function)
    {
      snprintf (buf, buf_max, "%s %s %s",
		(nlp->symtab) ? nlp->symtab->filename : "",
                (nlp->function) ? SYMBOL_LINKAGE_NAME (nlp->function) : "",
                (!nlp->function) ? paddress (gdbarch, nlp->addr) : "");
    }
  else
    {
      if (nlp->showall)
        {
	  snprintf (buf, buf_max, "%s:%d %s %s", nlp->symtab->filename,
                    nlp->line,
                    (nlp->function) ? SYMBOL_LINKAGE_NAME (nlp->function) : "",
                    paddress (gdbarch, nlp->addr));
        }
      else
        {
          if (nlp->symtab)
	    snprintf (buf, buf_max, "%s %d %s",
                      (nlp->function) ? SYMBOL_LINKAGE_NAME (nlp->function) : "",
                      nlp->line, paddress (gdbarch, nlp->addr));
          else
            snprintf (buf, buf_max, "%s %s",
                      (nlp->function) ? SYMBOL_LINKAGE_NAME (nlp->function) : "",
                      paddress (gdbarch, nlp->addr));
        }
    }
}

static void
record_pic_edge (char *buf, int buf_max, struct edge_list *elp,
		 char *node, char *prev_node)
{
  if (elp->frame_diff)
    {
      if (elp->is_return)
        snprintf (buf, buf_max, "edge: {color:blue sourcename: \"%s\" "
                                "targetname: \"%s\"",
		  prev_node, node);
      else
        snprintf (buf, buf_max, "edge: {color:red sourcename: \"%s\" "
                                "targetname: \"%s\"",
		  prev_node, node);
    }
  else
    snprintf (buf, buf_max,
              "edge: {sourcename: \"%s\" targetname: \"%s\"",
              prev_node, node);
}

/* Save the execution log to a vcg file.  */

static void
cmd_record_pic (char *args, int from_tty)
{
  char *recfilename, recfilename_buffer[40];
  FILE *fp;
  struct cleanup *old_cleanups, *set_cleanups;
  struct regcache *regcache;
  struct gdbarch *gdbarch;
  struct record_entry *cur_record_list;
  char prev_node[256], line[256];
  CORE_ADDR prev_addr;
  struct frame_id fi, caller_fi, prev_fi, prev_caller_fi;
  struct function_list *function_list_tail, *function_list_prev;
  struct edge_list *edge_list_tail = NULL;
  struct node_list *node_list_tail = NULL;
  struct symtab_and_line sal, prev_sal;
  struct node_list *prev_nlp;
  struct node_list prev_nlp_real;
  int fid_count = 1;

  /* Check if record target is running.  */
  if (current_target.to_stratum != record_stratum)
    error (_("This command can only be used with target 'record' \
or target 'record-core'."));

  if (args && *args)
    recfilename = args;
  else
    {
      /* Default recfile name is "gdb_record_PID.vcg".  */
      snprintf (recfilename_buffer, sizeof (recfilename_buffer),
                "gdb_record_%d.vcg", PIDGET (inferior_ptid));
      recfilename = recfilename_buffer;
    }

  /* Open the output file.  */
  fp = fopen (recfilename, "wb");
  if (!fp)
    error (_("Unable to open file '%s'"), recfilename);

  old_cleanups = make_cleanup (record_pic_cleanups, fp);

  /* Save the current record entry to "cur_record_list".  */
  cur_record_list = record_list;

  /* Get the values of regcache and gdbarch.  */
  regcache = get_current_regcache ();
  gdbarch = get_regcache_arch (regcache);

  /* Disable the GDB operation record.  */
  set_cleanups = record_gdb_operation_disable_set ();

  /* Reverse execute to the begin of record list.  */
  while (1)
    {
      /* Check for beginning and end of log.  */
      if (record_list == &record_first)
        break;

      record_exec_insn (regcache, gdbarch, record_list);

      if (record_list->prev)
        record_list = record_list->prev;
    }

  /* Write out the record log.  */
  /* Write the head.  */
  record_pic_fputs (fp, "graph: {title: \"GDB process record\"\n");

  /* Write the first node.  */
  record_pic_fputs (fp, "node: {title: \"[BEGIN]\" vertical_order:0}\n");

  /* Initialization.  */
  snprintf (prev_node, 256, "[BEGIN]");
  prev_fi = null_frame_id;
  prev_caller_fi = null_frame_id;
  prev_addr = 0;
  prev_sal.symtab = NULL;
  prev_sal.pc = 0;
  prev_sal.end = 0;
  prev_nlp_real.addr = 0;
  prev_nlp = &prev_nlp_real;

  /* Create first entry for function_list.  */
  function_list = xmalloc (sizeof (struct function_list));
  function_list->next = NULL;
  function_list->addr = 0;
  function_list->fid = -1;
  function_list_tail = function_list;
  function_list_prev = function_list;

  /* Save the entries to fp and forward execute to the end of
     record list.  */
  record_list = &record_first;
  while (1)
    {
      if (record_list->type == record_end)
        {
          int frame_diff = 0;
          CORE_ADDR addr = regcache_read_pc (regcache);

          /* Check if the ADDR is stil in the same line with the
             prev cycle.  */
          if (prev_sal.symtab
              && addr >= prev_sal.pc && addr < prev_sal.end)
            goto exec;
          sal = find_pc_line (addr, 0);

          if (record_pic_hide_nosource && !sal.symtab)
            goto exec;

          /* Check if the inferior is in same frame with prev cycle.
             Check both the current fi and caller fi because the last
             addr of function is different with current function.  */
          reinit_frame_cache ();
          fi = get_frame_id (get_current_frame ());
          caller_fi = frame_unwind_caller_id (get_current_frame ());
          if (!frame_id_eq (prev_fi, fi)
              && !frame_id_eq (prev_caller_fi, caller_fi))
            frame_diff = 1;

          if (set_record_pic_type == record_pic_line || frame_diff)
            {
              int is_return = 0;
              struct node_list *nlp = NULL;
              struct edge_list *elp = NULL;
              char node[256];
              struct minimal_symbol *function;

	      /* Get the node addr.  */
              if (set_record_pic_type == record_pic_function)
                {
                  /* Get the start addr of function.  */
                  addr = get_pc_function_start (addr);
                  if (addr == 0)
                    {
                      if (record_pic_hide_nofunction)
                        goto exec;
                      addr = regcache_read_pc (regcache);
                    }
                }
              else
                {
                  /* Get the start addr of line.  */
                  if (sal.symtab)
                    addr = sal.pc;
                }

              function = lookup_minimal_symbol_by_pc (addr);
              if (!function && record_pic_hide_nofunction)
                goto exec;

              if (frame_id_eq (fi, prev_caller_fi))
                is_return = 1;

              if (record_pic_hide_same)
                {
                  /* Check if addr in node_list.  */
                  for (nlp = node_list; nlp; nlp = nlp->next)
                    {
                      if (nlp->addr == addr)
                        {
			  if (!is_return
			      || set_record_pic_type != record_pic_function)
                            nlp->count ++;
                          break;
                        }
                    }

                  /* Check if prev_addr and addr in edge_list.  */
	          if (nlp)
	            {
                      for (elp = edge_list; elp; elp = elp->next)
                        {
                          if (elp->s->addr == prev_addr && elp->t->addr == addr)
                            {
                              elp->count ++;
                              break;
                            }
                        }
		    }
                }

              if (!nlp)
                {
                  struct node_list nl;
                  CORE_ADDR function_addr;
                  struct function_list *flp;

                  nl.addr = addr;
                  if (frame_diff && sal.symtab)
                    nl.showall = 1;
                  else
                    nl.showall = 0;
                  nl.symtab = sal.symtab;
                  nl.line = sal.line;
                  nl.function = function;

                  /* Get the fid of the nl.  */
                  if (set_record_pic_type != record_pic_function)
                    function_addr = get_pc_function_start (addr);
                  else
                    function_addr = addr;
                  if (function_list_prev->addr == function_addr)
                    nl.fid = function_list_prev->fid;
                  else
                    {
                      for (flp = function_list; flp; flp = flp->next)
                        {
                          if (flp->addr == function_addr)
                            {
                              nl.fid = flp->fid;
                              break;
                            }
                        }
                      if (flp == NULL)
                        {
                          /* Creat a new entry to function_list.  */
                          nl.fid = fid_count ++;
                          flp = xmalloc (sizeof (struct function_list));
                          flp->addr = function_addr;
                          flp->fid = nl.fid;
                          flp->next = NULL;
		          function_list_tail->next = flp;
                          function_list_tail = flp;
                        }
                      function_list_prev = flp;
                    }

                  if (record_pic_hide_same)
                    {
                      nlp = xmalloc (sizeof (struct node_list));
                      *nlp = nl;
                      nlp->count = 1;

                      /* Add node to node_list.  */
                      nlp->next = NULL;
		      if (node_list_tail)
                        node_list_tail->next = nlp;
		      if (node_list == NULL)
		        node_list = nlp;
                      node_list_tail = nlp;
                    }
                  else
                    {
                      /* Draw the node.  */
                      record_pic_node (node, 256, gdbarch,
                                       set_record_pic_type, &nl);
		      snprintf (line, 256, "%s i:%s", node,
		                pulongest (record_list->u.end.insn_num));
		      strcpy (node, line);
                      snprintf (line, 256, "node: {title: \"%s\" "
                                           "vertical_order: %d}\n",
                                node, nl.fid);
                      record_pic_fputs (fp, line);
                    }
                }

              if (!elp)
                {
                  struct edge_list el;

                  el.is_return = is_return;
                  el.frame_diff = frame_diff;

                  if (record_pic_hide_same)
                    {
                      elp = xmalloc (sizeof (struct edge_list));
                      *elp = el;
		      elp->s = prev_nlp;
                      elp->t = nlp;
                      elp->count = 1;

                      /* Add edge to edge_list.  */
                      elp->next = NULL;
		      if (edge_list_tail)
                        edge_list_tail->next = elp;
		      if (edge_list == NULL)
		        edge_list = elp;
                      edge_list_tail = elp;
                    }
                  else
                    {
                      /* Draw the edge.  */
                      record_pic_edge (line, 256, &el, node, prev_node);
                      record_pic_fputs (fp, line);
		      record_pic_fputs (fp, " }\n");
                    }
                }

              if (record_pic_hide_same)
                prev_nlp = nlp;
              else
                snprintf (prev_node, 256, "%s", node);
              prev_addr = addr;
            }

          prev_sal = sal;
          prev_fi = fi;
          prev_caller_fi = caller_fi;
        }

exec:
      /* Execute entry.  */
      record_exec_insn (regcache, gdbarch, record_list);

      if (record_list->next)
        record_list = record_list->next;
      else
        break;
    }

  if (record_pic_hide_same)
    {
      struct node_list *nlp = NULL;
      struct edge_list *elp = NULL;
      char node[256];

      for (nlp = node_list; nlp; nlp = nlp->next)
        {
          /* Draw the node.  */
          record_pic_node (node, 256, gdbarch, set_record_pic_type, nlp);
          snprintf (line, 256, "node: {title: \"%s c:%d\" "
                               "vertical_order: %d}\n", node,
		    nlp->count, nlp->fid);
          record_pic_fputs (fp, line);
	}

      record_pic_node (node, 256, gdbarch, set_record_pic_type, edge_list->t);
      snprintf (line, 256,
	        "edge: {color:red sourcename: \"[BEGIN]\" targetname: \"%s c:%d\"}\n",
	        node, edge_list->count);
      record_pic_fputs (fp, line);
      for (elp = edge_list->next; elp; elp = elp->next)
        {
          /* Draw the edge.  */
	  record_pic_node (prev_node, 256, gdbarch, set_record_pic_type,
			   elp->s);
	  snprintf (line, 256, "%s c:%d", prev_node, elp->s->count);
	  strcpy (prev_node, line);
	  record_pic_node (node, 256, gdbarch, set_record_pic_type,
			   elp->t);
	  snprintf (line, 256, "%s c:%d", node, elp->t->count);
	  strcpy (node, line);
          record_pic_edge (line, 256, elp, node, prev_node);
          record_pic_fputs (fp, line);
          snprintf (line, 256, " label: \"c:%d\"}\n", elp->count);
	  record_pic_fputs (fp, line);
        }
    }

  /* Write the last node.  */
  snprintf (line, 256, "node: {title: \"[END]\" vertical_order: %d}\n",
            fid_count);
  record_pic_fputs (fp, line);
  snprintf (line, 256,
	    "edge: {color:red sourcename: \"%s\" targetname: \"[END]\" }\n",
	    prev_node);
  record_pic_fputs (fp, line);

  /* Write the tail.  */
  record_pic_fputs (fp, "}\n");

  /* Reverse execute to cur_record_list.  */
  while (1)
    {
      /* Check for beginning and end of log.  */
      if (record_list == cur_record_list)
        break;

      record_exec_insn (regcache, gdbarch, record_list);

      if (record_list->prev)
        record_list = record_list->prev;
    }

  do_cleanups (set_cleanups);
  do_cleanups (old_cleanups);

  /* Succeeded.  */
  printf_filtered (_("Saved file %s with execution log.\n"),
		   recfilename);
}

a2802 60
  /* For "record pic" command.  */
  c = add_cmd ("pic", class_obscure, cmd_record_pic,
	       _("Save the execution log to a vcg file.\n\
Argument is optional filename.\n\
Default filename is 'gdb_record_<process_id>.vcg'."),
	       &record_cmdlist);
  set_cmd_completer (c, filename_completer);
  add_prefix_cmd ("pic", class_support, set_record_pic_command,
		  _("Set record pic options"), &set_record_pic_cmdlist,
		  "set record pic ", 0, &set_record_cmdlist);
  add_prefix_cmd ("pic", class_support, show_record_pic_command,
		  _("Show record pic options"), &show_record_pic_cmdlist,
		  "show record pic ", 0, &show_record_cmdlist);
  add_setshow_enum_cmd ("type", no_class,
			record_pic_enum, &set_record_pic_type, _("\
Set the type of the nodes that record pic command saved."), _("\
Show the type of the nodes that record pic command saved."), _("\
When LINE, each node of vcg file that command record pic saved\n\
will be a line of the inferior.\n\
When FUNCTION, each node of vcg file that command record pic saved\n\
will be a function of the inferior."),
			NULL, NULL,
			&set_record_pic_cmdlist, &show_record_pic_cmdlist);
  add_setshow_boolean_cmd ("hide-nofunction", no_class,
			   &record_pic_hide_nofunction, _("\
Set whether record pic command hide the nodes that don't have the function name."), _("\
Show whether record pic command hide the nodes that don't have the function name."), _("\
Default is ON.\n\
When ON, record pic command will hide the nodes that don't have\n\
the function name.\n\
When OFF, record pic command will show the nodes that don't have\n\
the function name."),
			   NULL, NULL,
			   &set_record_pic_cmdlist, &show_record_pic_cmdlist);
  add_setshow_boolean_cmd ("hide-nosource", no_class,
			   &record_pic_hide_nosource, _("\
Set whether record pic command hide the nodes that don't have the source message."), _("\
Show whether record pic command hide the nodes that don't have the source message."), _("\
Default is ON.\n\
When ON, record pic command will hide the nodes that don't have\n\
the source message.\n\
When OFF, record pic command will show the nodes that don't have\n\
the source message."),
			   NULL, NULL,
			   &set_record_pic_cmdlist, &show_record_pic_cmdlist);
  add_setshow_boolean_cmd ("hide-sameaddr", no_class,
			   &record_pic_hide_same, _("\
Set whether record pic command hide the nodes that have the same address node in vcg file."), _("\
Show whether record pic command hide the nodes that have the same address node in vcg file."), _("\
Default is ON.\n\
When ON, record pic command will hide the nodes that have\n\
the same address node in vcg file.\n\
And record pic will show the execute count number of this line\n\
in format \"c:number\".\n\
When OFF, record pic command will show the nodes that have\n\
the same address node in vcg file.\n\
And record pic show the instruction number in format \"i:number\"\n\
that \"record goto\" support."),
			   NULL, NULL,
			   &set_record_pic_cmdlist, &show_record_pic_cmdlist);
@


1.52
log
@gdb/
	Make core files the process_stratum.
	* corefile.c (core_target): New variable.
	(core_file_command): Remove variable t, use core_target.
	* corelow.c (core_ops): Make it static.
	(init_core_ops): Change to process_stratum.  Initialize CORE_TARGET.
	* defs.h (make_cleanup_unpush_target): New prototype.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (core_pid_to_str): Remove core_stratum from its comment.
	* gdbcore.h (core_target): New declaration.
	* inf-ptrace.c (inf_ptrace_create_inferior, inf_ptrace_attach): New
	variables ops_already_pushed and back_to.  Use push_target,
	make_cleanup_unpush_target and discard_cleanups calls.
	* record.c (record_open): Replace core_stratum by a core_bfd check.
	* target.c (target_is_pushed): New function.
	(find_core_target): Remove.
	* target.h (enum strata) <core_stratum>: Remove.
	(target_is_pushed): New declaration.
	(find_core_target): Remove declaration.
	* tracepoint.c (init_tfile_ops) <to_stratum>: Remove comment.
	* utils.c (do_unpush_target, make_cleanup_unpush_target): New functions.

gdb/doc/
	Make core files the process_stratum.
	* gdb.texinfo (Active Targets): Remove core_stratum.  Include
	record_stratum example.

gdb/testsuite/
	Make core files the process_stratum.
	* gdb.base/corefile.exp (run: load core again)
	(run: sanity check we see the core file, run: with core)
	(run: core file is cleared, attach: load core again)
	(attach: sanity check we see the core file, attach: with core)
	(attach: core file is cleared): New tests.
	* gdb.base/coremaker.c (main): New parameters.  Implement "sleep" argv.
@
text
@d457 1
a457 1
    gdb_assert (0);
@


1.51
log
@2010-07-19  Hui Zhu  <teawater@@gmail.com>

	* breakpoint.c (single_step_breakpoints_inserted): New
	function.
	* breakpoint.h (single_step_breakpoints_inserted): Extern.
	* infrun.c (maybe_software_singlestep): Add check code.
	* record.c (record_resume): Add code for software single step.
	(record_wait): Ditto.
@
text
@d965 1
a965 1
  if (current_target.to_stratum == core_stratum)
@


1.50
log
@2010-06-29  Hui Zhu  <teawater@@gmail.com>

	* record.c (set_record_pic_cmdlist,
	show_record_pic_cmdlist): New variables.
	(set_record_pic_command,
	show_record_pic_command): New functions.
	(record_pic_function, record_pic_line, record_pic_enum,
	set_record_pic_type, record_pic_hide_nofunction,
	record_pic_hide_nosource, record_pic_hide_same): New variables.
	(record_pic_fputs): New function.
	(function_list, node_list, edge_list): New struct.
	(function_list, node_list, edge_list): New variables.
	(record_pic_cleanups, record_pic_node,
	record_pic_edge, cmd_record_pic): New functions.
	(_initialize_record): Add new commands for record pic.
@
text
@d1014 2
d1017 34
a1050 2
      record_beneath_to_resume (record_beneath_to_resume_ops, ptid, 1,
                                signal);
d1126 1
d1133 3
d1175 6
a1180 2
		      /* This must be a single-step trap.  Record the
		         insn and issue another step.  */
d1189 12
d1202 1
a1202 1
						ptid, 1,
@


1.50.2.1
log
@Back out the change introducing the "record pic" feature.

gdb/ChangeLog:

        Back out the following change:
        | 2010-06-29  Hui Zhu  <teawater@@gmail.com>
        | * record.c (set_record_pic_cmdlist,
        | show_record_pic_cmdlist): New variables.
        | (set_record_pic_command,
        | show_record_pic_command): New functions.
        | (record_pic_function, record_pic_line, record_pic_enum,
        | set_record_pic_type, record_pic_hide_nofunction,
        | record_pic_hide_nosource, record_pic_hide_same): New variables.
        | (record_pic_fputs): New function.
        | (function_list, node_list, edge_list): New struct.
        | (function_list, node_list, edge_list): New variables.
        | (record_pic_cleanups, record_pic_node,
        | record_pic_edge, cmd_record_pic): New functions.
        | (_initialize_record): Add new commands for record pic.
@
text
@d2552 549
d3298 60
@


1.49
log
@2010-06-22  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c (i386_record_lea_modrm): Change warning to query.
	(i386_process_record): Ditto.
	* record.c (record_memory_query): New variable.
	(_initialize_record): New command "set record memory-query".
	* record.h (record_memory_query): New extern.

2010-06-22  Hui Zhu  <teawater@@gmail.com>

	* gdb.texinfo: (Process Record and Replay): Add documentation
	for command "set record memory-query".
@
text
@d2552 549
d3297 61
@


1.48
log
@2010-06-08  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_wait): Move signal out of replay code.
@
text
@d155 4
d2737 11
@


1.47
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* record.c: White space.
	* regcache.c: White space.
	* reggroups.c: White space.
	* remote-fileio.c: White space.
	* remote-m32r-sdi.c: White space.
	* remote-mips.c: White space.
	* remote-sim.c: White space.
@
text
@d1072 3
d1094 3
a1191 2
      record_get_sig = 0;
      signal (SIGINT, record_sig_handler);
a1304 2
      signal (SIGINT, handle_sigint);

d1317 2
@


1.46
log
@	* record.c (init_record_core_ops): Rename record_core to record-core.
@
text
@d547 1
d1400 1
d1467 1
d1753 78
a1830 79
   if (object == TARGET_OBJECT_MEMORY)
     {
       if (record_gdb_operation_disable || !writebuf)
         {
           struct target_section *p;
           for (p = record_core_start; p < record_core_end; p++)
             {
               if (offset >= p->addr)
                 {
                   struct record_core_buf_entry *entry;
		   ULONGEST sec_offset;

                   if (offset >= p->endaddr)
                     continue;

                   if (offset + len > p->endaddr)
                     len = p->endaddr - offset;

                   sec_offset = offset - p->addr;

                   /* Read readbuf or write writebuf p, offset, len.  */
                   /* Check flags.  */
                   if (p->the_bfd_section->flags & SEC_CONSTRUCTOR
                       || (p->the_bfd_section->flags & SEC_HAS_CONTENTS) == 0)
                     {
                       if (readbuf)
                         memset (readbuf, 0, len);
                       return len;
                     }
                   /* Get record_core_buf_entry.  */
                   for (entry = record_core_buf_list; entry;
                        entry = entry->prev)
                     if (entry->p == p)
                       break;
                   if (writebuf)
                     {
                       if (!entry)
                         {
                           /* Add a new entry.  */
                           entry
                             = (struct record_core_buf_entry *)
                                 xmalloc
                                   (sizeof (struct record_core_buf_entry));
                           entry->p = p;
                           if (!bfd_malloc_and_get_section (p->bfd,
                                                            p->the_bfd_section,
                                                            &entry->buf))
                             {
                               xfree (entry);
                               return 0;
                             }
                           entry->prev = record_core_buf_list;
                           record_core_buf_list = entry;
                         }

                        memcpy (entry->buf + sec_offset, writebuf,
				(size_t) len);
                     }
                   else
                     {
                       if (!entry)
                         return record_beneath_to_xfer_partial
                                  (record_beneath_to_xfer_partial_ops,
                                   object, annex, readbuf, writebuf,
                                   offset, len);

                       memcpy (readbuf, entry->buf + sec_offset,
			       (size_t) len);
                     }

                   return len;
                 }
             }

           return -1;
         }
       else
         error (_("You can't do that without a process to debug."));
     }
d2323 1
@


1.45
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* xml-support.c (xinclude_start_include): Delete unused variable.
	(xml_process_xincludes): Delete unused variable.
	* xml-syscall.c (syscall_parse_xml): Delete unused variable.
	* target-descriptions.c (tdesc_gdb_type): Delete unused variable.
	(tdesc_find_arch_register): Delete unused variable.
	(tdesc_use_registers): Delete unused variable.
	* xml-tdesc.c (tdesc_start_target): Delete unused variable.
	* inferior.c (print_inferior): Delete unused variable.
	* record.c (record_open_1): Delete unused variable.
	(record_restore): Delete unused variable.
	(cmd_record_save): Delete unused variable.
	* gcore.c (derive_heap_segment): Delete unused variable.
	(objfile_find_memory_regions): Use unused variable.
	* jit.c (jit_inferior_init): Delete unused variable.
	* progspace.c (clone_program_space): Delete unused variable.
	(pspace_empty_p): Delete unused variable.
@
text
@d1864 1
a1864 1
  record_core_ops.to_shortname = "record_core";
@


1.44
log
@2010-03-08  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Hui Zhu  <teawater@@gmail.com>

	* record.c (record_open_1): Check tmp_to_stopped_by_watchpoint and
	tmp_to_stopped_data_address.
	(record_open): Reset tmp_to_stopped_by_watchpoint and
	tmp_to_stopped_data_address.
	* target.c (init_dummy_target): Add to_stopped_by_watchpoint and
	to_stopped_data_address.
@
text
@a840 2
  struct target_ops *t;

a2174 1
      int ret;
a2332 1
  int recfd;
@


1.43
log
@2010-03-07  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_restore): Rename tmpu8 to rectype.
@
text
@d870 4
d904 2
@


1.42
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d2172 1
a2172 1
      uint8_t tmpu8;
d2179 1
a2179 1
      bfdcore_read (core_bfd, osec, &tmpu8, sizeof (tmpu8), &bfd_offset);
d2181 1
a2181 1
      switch (tmpu8)
@


1.41
log
@2009-12-22  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_message): Change argument.
	(record_message_wrapper): New function.
	(do_record_message): Change it name to
	"record_message_wrapper_safe".
	Let it call "record_message_wrapper".
	(record_resume_error): Deleted.
	(record_resume): Call "record_message".
	(record_wait): Deleted record_resume_error.
	Call "record_message_wrapper_safe".
	Set status when do_record_message need stop the inferior.

2009-12-22  Hui Zhu  <teawater@@gmail.com>

	* gdb.reverse/sigall-reverse.exp: Adjust.
@
text
@d3 1
a3 1
   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
@


1.40
log
@	* record.c (init_record_ops, init_record_core_ops): Actually
	install record_stopped_data_address.
@
text
@a574 5
struct record_message_args {
  struct regcache *regcache;
  enum target_signal signal;
};

d576 1
a576 1
record_message (void *args)
d579 1
a579 2
  struct record_message_args *myargs = args;
  struct gdbarch *gdbarch = get_regcache_arch (myargs->regcache);
d613 1
a613 1
      record_list->u.end.sigval = myargs->signal;
d616 1
a616 1
  if (myargs->signal == TARGET_SIGNAL_0
d619 2
a620 2
				  myargs->regcache,
				  regcache_read_pc (myargs->regcache));
d623 2
a624 2
					 myargs->regcache,
					 myargs->signal);
d645 5
d651 10
a660 2
do_record_message (struct regcache *regcache,
		   enum target_signal signal)
d666 2
a667 1
  return catch_errors (record_message, &args, NULL, RETURN_MASK_ALL);
a993 1
static int record_resume_error;
d1005 1
a1005 9
      if (do_record_message (get_current_regcache (), signal))
        {
          record_resume_error = 0;
        }
      else
        {
          record_resume_error = 1;
          return;
        }
a1068 8
      if (record_resume_error)
	{
	  /* If record_resume get error, return directly.  */
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_ABRT;
	  return inferior_ptid;
	}

d1124 7
a1130 2
		      if (!do_record_message (regcache, TARGET_SIGNAL_0))
			break;
@


1.39
log
@        Make hardware breakpoints work for process repord.

	* record.c (record_wait): Only adjust PC on software breakpoints
	hits.
@
text
@d1671 1
d1880 1
@


1.38
log
@        Make hardware watchpoints work for process record.

        * breakpoint.c (hardware_watchpoint_inserted_in_range): New.
	* breakpoint.h (hardware_watchpoint_inserted_in_range): Declare.
	* record.c (record_beneath_to_stopped_by_watchpoint)
	(record_beneath_to_stopped_data_address, record_hw_watchpoint):
	New globals.
	(record_exec_insn): Check for watchpoint hits.
	(tmp_to_stopped_by_watchpoint, tmp_to_stopped_data_address): New
	globals.
	(record_open): Set tmp_to_stopped_by_watchpoint,
	tmp_to_stopped_data_address,
	record_beneath_to_stopped_by_watchpoint and
	record_beneath_to_stopped_data_address.
	(record_wait): Report watchpoint hits to the core.  Update and
	extend comments.
	(record_stopped_by_watchpoint): New.
	(record_stopped_data_address): New.
	(init_record_ops): Install them.
	(init_record_core_ops): Ditto.
@
text
@d1100 1
d1109 1
d1115 1
a1115 2
		  else if (breakpoint_inserted_here_p (get_regcache_aspace (regcache),
						       tmp_pc))
d1119 9
a1127 6
		      struct gdbarch *gdbarch = get_regcache_arch (regcache);
		      CORE_ADDR decr_pc_after_break
			= gdbarch_decr_pc_after_break (gdbarch);
		      if (decr_pc_after_break)
			regcache_write_pc (regcache,
					   tmp_pc + decr_pc_after_break);
d1154 1
d1167 1
a1167 2
	  if (breakpoint_inserted_here_p (get_regcache_aspace (regcache),
					  tmp_pc))
d1169 2
d1175 4
a1178 2
	      if (gdbarch_decr_pc_after_break (gdbarch)
		  && !record_resume_step)
d1180 1
a1180 2
				   tmp_pc +
				   gdbarch_decr_pc_after_break (gdbarch));
d1250 1
a1250 2
		  if (breakpoint_inserted_here_p (get_regcache_aspace (regcache),
						  tmp_pc))
d1252 3
d1260 1
a1260 1
		      if (gdbarch_decr_pc_after_break (gdbarch)
d1262 3
a1264 1
			  && !record_resume_step)
d1266 1
a1266 2
					   tmp_pc +
					   gdbarch_decr_pc_after_break (gdbarch));
d1273 2
a1274 2
			fprintf_unfiltered (gdb_stdlog,
					    "Process record: hit hw watchpoint.\n");
@


1.37
log
@2009-10-25  Michael Snyder  <msnyder@@vmware.com>

        * target.h (struct target_ops): New methods to_get_bookmark
        and to_goto_bookmark.
        (target_get_bookmark): New macro.
        (target_goto_bookmark): New macro.
        * target.c (dummy_get_bookmark): New function, default implementation.
        (dummy_goto_bookmark): New function, default implementation.
        (update_current_target): Inherit new methods.
        * record.c (record_get_bookmark): New function.
        (record_goto_bookmark): New function.
        (init_record_ops): Set to_get_bookmark and to_goto_bookmark methods.
        * reverse.c (struct bookmark): New type.
        (save_bookmark_command): New function (command).
        (delete_bookmark_command): New function (command).
        (goto_bookmark_command): New function (command).
        (bookmarks_info): New function (command).
        (_initialize_reverse): Add new bookmark commands.
	* command.h (enum command_class): Add class_bookmark.
	* NEWS: Mention bookmark commands.
@
text
@d227 3
d679 3
d748 16
a763 1
                  memcpy (record_get_loc (entry), mem, entry->u.mem.len);
d794 2
d920 4
d945 2
d1101 4
a1104 1
		  /* Yes -- check if there is a breakpoint.  */
d1108 7
a1114 2
		  if (breakpoint_inserted_here_p (get_regcache_aspace (regcache),
						  tmp_pc))
d1116 2
a1117 1
		      /* There is a breakpoint.  GDB will want to stop.  */
d1127 2
a1128 4
		      /* There is not a breakpoint, and gdb is not
		         stepping, therefore gdb will not stop.
			 Therefore we will not return to gdb.
		         Record the insn and resume.  */
d1155 1
d1259 8
d1308 18
d1660 1
d1868 1
@


1.36
log
@	* record.c (record_restore, cmd_record_save): Debug output goes to
	gdb_stdlog.
@
text
@d1526 51
d1599 3
d1807 3
d2466 95
d2646 5
@


1.35
log
@2009-10-23  Michael Snyder  <msnyder@@vmware.com>

	* record.c (top level): Don't include byteswap.h.
	(netorder64): Use store_unsigned_integer instead of bswap_64.
	(netorder32): Use store_unsigned_integer instead of bswap_32.
	(netorder16): Use store_unsigned_integer instead of bswap_16.
@
text
@d2008 1
a2008 1
    printf_filtered ("Restoring recording from core file.\n");
d2014 3
a2016 3
    printf_filtered ("Find precord section %s.\n",
		     osec ? "succeeded" : "failed");
  if (!osec)
d2019 1
a2019 1
    printf_filtered ("%s", bfd_section_name (core_bfd, osec));
d2027 1
a2027 1
    printf_filtered ("\
d2029 1
a2029 1
		     phex_nz (netorder32 (magic), 4));
d2065 2
a2066 2
          if (record_debug)
            printf_filtered ("\
d2068 3
a2070 3
			     rec->u.reg.num,
			     (unsigned long) sizeof (regnum),
			     rec->u.reg.len);
d2090 2
a2091 2
          if (record_debug)
            printf_filtered ("\
d2093 5
a2097 5
			     paddress (get_current_arch (),
				       rec->u.mem.addr),
			     (unsigned long) sizeof (addr),
			     (unsigned long) sizeof (len),
			     rec->u.mem.len);
d2116 2
a2117 2
          if (record_debug)
            printf_filtered ("\
d2119 4
a2122 4
			     (unsigned long) sizeof (signal),
			     (unsigned long) sizeof (count),
			     paddress (get_current_arch (),
				       bfd_offset));
d2228 2
a2229 1
    printf_filtered ("Saving execution log to core file '%s'\n", recfilename);
d2295 1
a2295 1
    printf_filtered ("\
d2297 1
a2297 1
		     phex_nz (magic, 4));
d2318 2
a2319 2
              if (record_debug)
		printf_filtered ("\
d2321 3
a2323 3
				 record_list->u.reg.num,
				 (unsigned long) sizeof (regnum),
				 record_list->u.reg.len);
d2337 1
a2337 1
		printf_filtered ("\
d2339 5
a2343 5
				 paddress (gdbarch,
					   record_list->u.mem.addr),
				 (unsigned long) sizeof (addr),
				 (unsigned long) sizeof (len),
				 record_list->u.mem.len);
d2360 2
a2361 2
                if (record_debug)
                  printf_filtered ("\
d2363 2
a2364 2
				   (unsigned long) sizeof (signal),
				   (unsigned long) sizeof (count));
@


1.34
log
@	* record.c (record_core_xfer_partial): Pass correct offset to
	record_beneath_to_xfer_partial.
@
text
@a33 1
#include <byteswap.h>
d1958 1
a1958 1
netorder64 (uint64_t fromfile)
d1960 5
a1964 3
  return (BYTE_ORDER == BFD_ENDIAN_LITTLE) 
    ? bswap_64 (fromfile) 
    : fromfile;
d1968 1
a1968 1
netorder32 (uint32_t fromfile)
d1970 5
a1974 3
  return (BYTE_ORDER == BFD_ENDIAN_LITTLE) 
    ? bswap_32 (fromfile) 
    : fromfile;
d1978 1
a1978 1
netorder16 (uint16_t fromfile)
d1980 5
a1984 3
  return (BYTE_ORDER == BFD_ENDIAN_LITTLE) 
    ? bswap_16 (fromfile) 
    : fromfile;
@


1.33
log
@2009-10-23  Michael Snyder  <msnyder@@vmware.com>

	* record.c (netorder64): Use BFD_ENDIAN_LITTLE not LITTLE_ENDIAN.
	(netorder32): Ditto.
	(netorder16): Ditto.
@
text
@d1632 1
d1640 1
a1640 1
                   offset -= p->addr;
d1677 2
a1678 1
                        memcpy (entry->buf + offset, writebuf, (size_t) len);
d1688 2
a1689 1
                       memcpy (readbuf, entry->buf + offset, (size_t) len);
@


1.32
log
@2009-10-23  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_restore): Use phex_nz.
@
text
@d1958 1
a1958 1
  return (BYTE_ORDER == LITTLE_ENDIAN) 
d1966 1
a1966 1
  return (BYTE_ORDER == LITTLE_ENDIAN) 
d1974 1
a1974 1
  return (BYTE_ORDER == LITTLE_ENDIAN) 
@


1.31
log
@2009-10-22  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* record.c (record_restore, cmd_record_save): Fix warnings.
@
text
@d2020 2
a2021 2
  Reading 4-byte magic cookie RECORD_FILE_MAGIC (0x%08x)\n",
		     netorder32 (magic));
d2287 2
a2288 2
  Writing 4-byte magic cookie RECORD_FILE_MAGIC (0x%08x)\n",
		     magic);
@


1.30
log
@2009-10-16  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* record.c (RECORD_FILE_MAGIC): New constant.
	(record_arch_list_cleanups): Renamed from record_message_cleanups.
	(bfdcore_read): New function.
	(netorder64): New function.
	(netorder32): New function.
	(netorder16): New function.
	(record_restore): New function.  Restore a saved record log.
	(bfdcore_write): New function.
	(cmd_record_restore): New function.
	(cmd_record_save): New function.  Save a record log to a file.
	(_initialize_record): Set up commands for save and restore.

2009-10-17  Michael Snyder  <msnyder@@vmware.com>

	* gcore.h: New file.
	* gcore.c (create_gcore_bfd): New function.
	(write_gcore_file): New function.
	(call_target_sbrk): New function.  Abstracted from gcore_command.
	(gcore_command): Call call_target_sbrk.
@
text
@d2059 1
a2059 1
  Reading register %d (1 plus %d plus %d bytes)\n",
d2061 1
a2061 1
			     sizeof (regnum),
d2084 1
a2084 1
  Reading memory %s (1 plus %d plus %d plus %d bytes)\n",
d2087 2
a2088 2
			     sizeof (addr),
			     sizeof (len),
d2110 3
a2112 3
  Reading record_end (1 + %d + %d bytes), offset == %s\n",
			     sizeof (signal),
			     sizeof (count),
d2311 1
a2311 1
  Writing register %d (1 plus %d plus %d bytes)\n",
d2313 1
a2313 1
				 sizeof (regnum),
d2329 1
a2329 1
  Writing memory %s (1 plus %d plus %d plus %d bytes)\n",
d2332 2
a2333 2
				 sizeof (addr),
				 sizeof (len),
d2353 3
a2355 3
  Writing record_end (1 + %d + %d bytes)\n", 
				   sizeof (signal),
				   sizeof (count));
@


1.29
log
@2009-10-22  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_core_ops): New ops target vector.
	(record_core_open_1): New function.  Open core target.
	(record_open_1): New function.  Open normal process record.
	(record_open): Call one of the above.
	(record_close): Allow for both core and normal targets.
	(record_core_resume): New function.
	(record_core_kill): New function.
	(record_core_fetch_registers): New function.
	(record_core_prepare_to_store): New function.
	(record_core_store_registers): New function.
	(record_core_xfer_partial): New function.
	(record_core_insert_breakpoint): New function.
	(record_core_remove_breakpoint): New function.
	(record_core_has_execution): New function.
	(init_record_core_ops): New function.
	(_initialize_record): Call init_record_core_ops, add_target.
@
text
@d26 2
d31 2
d34 1
d62 2
d555 1
a555 1
		error (_("Process record: inferior program stopped."));
d561 6
a572 6
static void
record_message_cleanups (void *ignore)
{
  record_list_release (record_arch_list_tail);
}

d584 1
a584 1
  struct cleanup *old_cleanups = make_cleanup (record_message_cleanups, 0);
d724 2
a725 2
                  warning (_("Process record: error reading memory at "
                             "addr = %s len = %d."),
d737 2
a738 2
                      warning (_("Process record: error writing memory at "
                                 "addr = %s len = %d."),
d775 2
d803 1
d1451 2
a1452 2
				_("Process record: failed to record "
				  "execution log."));
d1460 2
a1461 2
				_("Process record: failed to record "
				  "execution log."));
d1898 502
d2403 2
d2423 5
a2427 3
  add_prefix_cmd ("record", class_obscure, cmd_record_start,
		  _("Abbreviated form of \"target record\" command."),
 		  &record_cmdlist, "record ", 0, &cmdlist);
d2442 12
@


1.28
log
@2009-10-21  Michael Snyder  <msnyder@@vmware.com>

	Elaborate "info record".
	* record.c (struct record_end_entry): New field 'insn_num'.
	(record_insn_count): New variable.
	(record_open): Initialize record_insn_count.
	(info_record_command): Display contents of record log as
	lowest, current, and highest instruction counts.
	(show_record_insn_number): Delete.
	(_initialize_record): Remove add_cmd show_record_insn_number.
@
text
@d26 2
d149 13
d195 1
d744 53
a796 1
/* "to_open" target method.  Open the process record target.  */
d799 1
a799 1
record_open (char *name, int from_tty)
d820 24
d849 11
a859 7
  /*Reset the beneath function pointers.  */
  record_beneath_to_resume = NULL;
  record_beneath_to_wait = NULL;
  record_beneath_to_store_registers = NULL;
  record_beneath_to_xfer_partial = NULL;
  record_beneath_to_insert_breakpoint = NULL;
  record_beneath_to_remove_breakpoint = NULL;
d864 1
a864 1
      if (!record_beneath_to_resume)
d866 2
a867 2
	  record_beneath_to_resume = t->to_resume;
	  record_beneath_to_resume_ops = t;
d869 1
a869 1
      if (!record_beneath_to_wait)
d871 2
a872 2
	  record_beneath_to_wait = t->to_wait;
	  record_beneath_to_wait_ops = t;
d874 1
a874 1
      if (!record_beneath_to_store_registers)
d876 2
a877 2
	  record_beneath_to_store_registers = t->to_store_registers;
	  record_beneath_to_store_registers_ops = t;
d879 1
a879 1
      if (!record_beneath_to_xfer_partial)
d881 2
a882 2
	  record_beneath_to_xfer_partial = t->to_xfer_partial;
	  record_beneath_to_xfer_partial_ops = t;
d884 7
a890 19
      if (!record_beneath_to_insert_breakpoint)
	record_beneath_to_insert_breakpoint = t->to_insert_breakpoint;
      if (!record_beneath_to_remove_breakpoint)
	record_beneath_to_remove_breakpoint = t->to_remove_breakpoint;
    }
  if (!record_beneath_to_resume)
    error (_("Process record can't get to_resume."));
  if (!record_beneath_to_wait)
    error (_("Process record can't get to_wait."));
  if (!record_beneath_to_store_registers)
    error (_("Process record can't get to_store_registers."));
  if (!record_beneath_to_xfer_partial)
    error (_("Process record can't get to_xfer_partial."));
  if (!record_beneath_to_insert_breakpoint)
    error (_("Process record can't get to_insert_breakpoint."));
  if (!record_beneath_to_remove_breakpoint)
    error (_("Process record can't get to_remove_breakpoint."));

  push_target (&record_ops);
d897 17
d921 2
d927 18
d1030 1
a1030 1
  if (!RECORD_IS_REPLAY)
d1404 1
a1404 1
/* Behavior is conditional on RECORD_IS_REPLAY.
d1510 1
d1542 202
d1898 2
@


1.27
log
@2009-10-20  Michael Snyder  <msnyder@@vmware.com>

	* record.c: Add some top-level comments for general explanation.
@
text
@d94 1
d170 1
d172 1
d174 3
d347 4
a350 1
	record_insn_num--;
d378 1
a378 4
	{
	  record_insn_num--;
	  break;	/* End loop at first record_end.  */
	}
d503 1
d810 1
d1469 2
a1470 2
      printf_unfiltered (_("Process record is stoped and all execution "
                           "log is deleted.\n"));
a1491 10
/* Print the current index into the record log (number of insns recorded
   so far).  */

static void
show_record_insn_number (char *ignore, int from_tty)
{
  printf_unfiltered (_("Record instruction number is %d.\n"),
		     record_insn_num);
}

d1509 2
d1514 48
a1561 1
  cmd_show_list (info_record_cmdlist, from_tty, "");
a1630 3
  add_cmd ("insn-number", class_obscure, show_record_insn_number,
	   _("Show the current number of instructions in the "
	     "record/replay buffer."), &info_record_cmdlist);
@


1.26
log
@2009-10-20  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_exec_insn): New function.  Emulate one
	instruction, forward or backward.  Abstracted from record_wait.
	(record_wait) Call record_exec_insn.
@
text
@d30 20
d103 24
d146 16
a161 1
/* These list is for execution log.  */
d721 2
d807 2
d821 2
d847 2
d875 12
a886 2
/* In replay mode, this function examines the recorded log and
   determines where to stop.  */
d1125 2
d1137 2
d1149 2
d1220 2
d1361 2
d1380 1
d1412 2
d1453 1
a1453 1
/* Implement the "stoprecord" command.  */
@


1.25
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d588 74
d958 3
a960 71
	  /* Set ptid, register and memory according to record_list.  */
	  if (record_list->type == record_reg)
	    {
	      /* reg */
	      gdb_byte reg[MAX_REGISTER_SIZE];
	      if (record_debug > 1)
		fprintf_unfiltered (gdb_stdlog,
				    "Process record: record_reg %s to "
				    "inferior num = %d.\n",
				    host_address_to_string (record_list),
				    record_list->u.reg.num);
	      regcache_cooked_read (regcache, record_list->u.reg.num, reg);
	      regcache_cooked_write (regcache, record_list->u.reg.num,
				     record_get_loc (record_list));
	      memcpy (record_get_loc (record_list), reg, 
		      record_list->u.reg.len);
	    }
	  else if (record_list->type == record_mem)
	    {
	      /* mem */
	      /* Nothing to do if the entry is flagged not_accessible.  */
	      if (!record_list->u.mem.mem_entry_not_accessible)
		{
		  gdb_byte *mem = alloca (record_list->u.mem.len);
		  if (record_debug > 1)
		    fprintf_unfiltered (gdb_stdlog,
				        "Process record: record_mem %s to "
				        "inferior addr = %s len = %d.\n",
				        host_address_to_string (record_list),
				        paddress (gdbarch,
					          record_list->u.mem.addr),
				        record_list->u.mem.len);

		  if (target_read_memory (record_list->u.mem.addr, mem,
		                          record_list->u.mem.len))
	            {
		      if (execution_direction != EXEC_REVERSE)
		        error (_("Process record: error reading memory at "
			         "addr = %s len = %d."),
		               paddress (gdbarch, record_list->u.mem.addr),
		               record_list->u.mem.len);
		      else
			/* Read failed -- 
			   flag entry as not_accessible.  */
		        record_list->u.mem.mem_entry_not_accessible = 1;
		    }
		  else
		    {
		      if (target_write_memory (record_list->u.mem.addr,
					       record_get_loc (record_list),
		                               record_list->u.mem.len))
	                {
			  if (execution_direction != EXEC_REVERSE)
			    error (_("Process record: error writing memory at "
			             "addr = %s len = %d."),
		                   paddress (gdbarch, record_list->u.mem.addr),
		                   record_list->u.mem.len);
			  else
			    /* Write failed -- 
			       flag entry as not_accessible.  */
			    record_list->u.mem.mem_entry_not_accessible = 1;
			}
		      else
		        {
			  memcpy (record_get_loc (record_list), mem,
				  record_list->u.mem.len);
			}
		    }
		}
	    }
	  else
@


1.24
log
@2009-10-15  Michael Snyder  <msnyder@@vmware.com>

	* record.c (struct record_reg_entry): Replace ptr with union
	of ptr and buf.
	(struct record_mem_entry): Ditto.
	(record_reg_alloc): Don't alloc ptr if reg will fit into buf.
	(record_mem_alloc): Ditto.
	(record_reg_release): Don't free ptr if reg was stored in buf.
	(record_mem_release): Ditto.
	(record_get_loc): New function.  Return a pointer to where the
	value (mem or reg) is to be stored.
	(record_arch_list_add_reg): Call record_get_loc instead of using ptr.
	(record_arch_list_add_mem): Ditto.
	(record_wait): Ditto.
@
text
@d781 2
d785 4
a788 2
		  tmp_pc = regcache_read_pc (get_current_regcache ());
		  if (breakpoint_inserted_here_p (tmp_pc))
d791 3
a793 3
		      CORE_ADDR decr_pc_after_break =
			gdbarch_decr_pc_after_break
			(get_regcache_arch (get_current_regcache ()));
d795 2
a796 4
			{
			  regcache_write_pc (get_thread_regcache (ret),
					     tmp_pc + decr_pc_after_break);
			}
d804 3
a806 5
		      if (!do_record_message (get_current_regcache (),
					      TARGET_SIGNAL_0))
			{
                          break;
			}
d836 2
a837 1
	  if (breakpoint_inserted_here_p (tmp_pc))
d985 2
a986 1
		  if (breakpoint_inserted_here_p (tmp_pc))
@


1.23
log
@2009-10-15  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_insn_max_num): Make unsigned.
	(_initialize_record): Use uinteger instead of zinteger for
	set command, so that it will report "unlimited" for zero.
@
text
@a45 6
struct record_reg_entry
{
  int num;
  gdb_byte *val;
};

d53 16
a68 1
  gdb_byte *val;
d155 3
a157 1
  rec->u.reg.val = (gdb_byte *) xmalloc (MAX_REGISTER_SIZE);
d168 2
a169 1
  xfree (rec->u.reg.val);
d184 2
a185 1
  rec->u.mem.val = (gdb_byte *) xmalloc (len);
d196 2
a197 1
  xfree (rec->u.mem.val);
d346 23
a368 1
/* Record the value of a register REGNUM to record_arch_list.  */
d383 1
a383 1
  regcache_raw_read (regcache, regnum, rec->u.reg.val);
d409 1
a409 1
  if (target_read_memory (addr, rec->u.mem.val, len))
d896 3
a898 2
				     record_list->u.reg.val);
	      memcpy (record_list->u.reg.val, reg, MAX_REGISTER_SIZE);
d932 1
a932 1
					       record_list->u.mem.val,
d947 1
a947 1
			  memcpy (record_list->u.mem.val, mem,
@


1.22
log
@2009-10-15  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_reg_alloc): New function.
	(record_reg_release): New function.
	(record_mem_alloc): New function.
	(record_mem_release): New function.
	(record_end_alloc): New function.
	(record_end_release): New function.
	(record_entry_release): New function.
	(record_list_release): Simplify, call record_entry_release.
	(record_list_release_next): Rename to record_list_release_following.
	Simplify and call record_entry_release.
	(record_list_release_first): Simplify, comment, and use
	record_entry_release.
	(record_arch_list_add_reg): Simplify, call record_reg_alloc.
	(record_arch_list_add_mem): Simplify, call record_mem_alloc.
	(record_arch_list_add_end): Simplify, call record_end_alloc.
@
text
@d101 1
a101 1
static int record_insn_max_num = DEFAULT_RECORD_INSN_MAX_NUM;
d1441 1
a1441 1
  add_setshow_zinteger_cmd ("insn-number-max", no_class,
@


1.21
log
@2009-10-12  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_list_release_first): Do not decrement
	record_insn_num.
	(set_insn_num_max): Remove printf.
	Decrement record_insn_num in the loop.
@
text
@d132 100
a234 2
  struct record_entry *tmp;

d239 1
a239 3
    {
      rec = rec->next;
    }
a242 1
      tmp = rec;
d244 1
a244 5
      if (tmp->type == record_reg)
	xfree (tmp->u.reg.val);
      else if (tmp->type == record_mem)
	xfree (tmp->u.mem.val);
      xfree (tmp);
d247 7
a253 2
  if (rec != &record_first)
    xfree (rec);
d256 2
d259 1
a259 1
record_list_release_next (void)
a260 1
  struct record_entry *rec = record_list;
d262 1
d267 1
a267 1
      if (tmp->type == record_end)
a268 5
      else if (tmp->type == record_reg)
	xfree (tmp->u.reg.val);
      else if (tmp->type == record_mem)
	xfree (tmp->u.mem.val);
      xfree (tmp);
d281 1
a281 2
  struct record_entry *tmp = NULL;
  enum record_type type;
d286 1
d289 1
a289 6
      type = record_first.next->type;

      if (type == record_reg)
	xfree (record_first.next->u.reg.val);
      else if (type == record_mem)
	xfree (record_first.next->u.mem.val);
d292 8
a299 1
      xfree (tmp);
d304 1
a304 1
	  break;
a305 5

      record_first.next->prev = &record_first;

      if (type == record_end)
	break;
d332 1
a332 1
/* Record the value of a register NUM to record_arch_list.  */
d335 1
a335 1
record_arch_list_add_reg (struct regcache *regcache, int num)
d343 1
a343 1
			num);
d345 1
a345 6
  rec = (struct record_entry *) xmalloc (sizeof (struct record_entry));
  rec->u.reg.val = (gdb_byte *) xmalloc (MAX_REGISTER_SIZE);
  rec->prev = NULL;
  rec->next = NULL;
  rec->type = record_reg;
  rec->u.reg.num = num;
d347 1
a347 1
  regcache_raw_read (regcache, num, rec->u.reg.val);
d368 1
a368 1
  if (!addr)
d371 1
a371 8
  rec = (struct record_entry *) xmalloc (sizeof (struct record_entry));
  rec->u.mem.val = (gdb_byte *) xmalloc (len);
  rec->prev = NULL;
  rec->next = NULL;
  rec->type = record_mem;
  rec->u.mem.addr = addr;
  rec->u.mem.len = len;
  rec->u.mem.mem_entry_not_accessible = 0;
d380 1
a380 2
      xfree (rec->u.mem.val);
      xfree (rec);
d400 1
a400 4
  rec = (struct record_entry *) xmalloc (sizeof (struct record_entry));
  rec->prev = NULL;
  rec->next = NULL;
  rec->type = record_end;
d895 1
a895 1
			                       record_list->u.mem.val,
d1136 1
a1136 1
	  record_list_release_next ();
d1168 1
a1168 1
	  record_list_release_next ();
d1308 1
a1308 1
	    record_list_release_next ();
@


1.20
log
@2009-09-27  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_open): Change "query" to "error".
	(cmd_record_stop): Change "query" to "printf_unfiltered".
@
text
@d180 5
a216 2

  record_insn_num--;
d1266 1
a1266 4
      printf_unfiltered (_("Record instructions number is bigger than "
		           "record instructions max number.  Auto delete "
		           "the first ones?\n"));

d1268 4
a1271 1
	record_list_release_first ();
@


1.19
log
@        * record.c (record_open, record_store_registers, record_xfer_partial):
        Replace calls to nquery by calls to query.
@
text
@d499 2
a500 6
    {
      if (!query
	  (_("Process record target already running, do you want to delete "
	     "the old record log?")))
	return;
    }
d1248 3
a1250 3
      if (!record_list || !from_tty || query (_("Delete recorded log and "
	                                        "stop recording?")))
	unpush_target (&record_ops);
@


1.18
log
@2009-09-21  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_end_entry): New struct.
	(record_type): Add end.
	(record_arch_list_add_end): Set rec->u.end.sigval to
	TARGET_SIGNAL_0.
	(record_message_args): New struct.
	(record_message): Call gdbarch_process_record_signal.
	(do_record_message): Add argument "signal".
	(record_resume): Ditto.
	(record_wait): Ditto.  Check record_list->u.end.sigval
	in replay mode.
@
text
@d500 1
a500 1
      if (!nquery
d1032 4
a1035 4
	      nquery (_("Because GDB is in replay mode, changing the "
			"value of a register will make the execution "
			"log unusable from this point onward.  "
			"Change all registers?"));
d1038 3
a1040 3
	      nquery (_("Because GDB is in replay mode, changing the value "
			"of a register will make the execution log unusable "
			"from this point onward.  Change register %s?"),
d1088 3
a1090 3
	  if (!nquery (_("Because GDB is in replay mode, writing to memory "
		         "will make the execution log unusable from this "
		         "point onward.  Write memory at address %s?"),
@


1.17
log
@2009-09-07  Michael Snyder  <msnyder@@vmware.com>

	* record.c: Minor comment and white space fix-ups.
@
text
@d62 5
d85 2
d324 1
d371 5
d380 2
a381 1
  struct regcache *regcache = args;
d390 38
a427 3
  ret = gdbarch_process_record (get_regcache_arch (regcache),
				regcache,
				regcache_read_pc (regcache));
d448 2
a449 1
do_record_message (struct regcache *regcache)
d451 5
a455 1
  return catch_errors (record_message, regcache, NULL, RETURN_MASK_ALL);
d577 1
a577 1
               enum target_signal siggnal)
d583 1
a583 1
      if (do_record_message (get_current_regcache ()))
d593 1
a593 1
                                siggnal);
d668 1
d672 1
a672 1
		  /* Check if there is a breakpoint.  */
d677 1
a677 1
		      /* There is a breakpoint.  */
d689 6
a694 2
		      /* There is not a breakpoint.  */
		      if (!do_record_message (get_current_regcache ()))
d889 4
d917 3
@


1.17.2.1
log
@2009-09-21  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@vmware.com>

	* amd64-linux-tdep.c (amd64_all_but_ip_registers_record): New
	function.
	(amd64_linux_syscall_record): Call
	amd64_all_but_ip_registers_record if syscall is
	sys_rt_sigreturn.
	(AMD64_LINUX_redzone, AMD64_LINUX_xstate,
	AMD64_LINUX_frame_size): New macros.
	(amd64_linux_record_signal): New function.
	(amd64_linux_init_abi): Call set_gdbarch_process_record_signal.

2009-09-21  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@vmware.com>

	* i386-linux-tdep.c (i386_all_but_ip_registers_record): New
	function.
	(i386_linux_intx80_sysenter_record): Call
	i386_all_but_ip_registers_record if syscall is sys_sigreturn
	or sys_rt_sigreturn.
	(I386_LINUX_xstate, I386_LINUX_frame_size): New macros.
	(i386_linux_record_signal): New function.
	(i386_linux_init_abi): Call set_gdbarch_process_record_signal.

2009-09-21  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_end_entry): New struct.
	(record_type): Add end.
	(record_arch_list_add_end): Set rec->u.end.sigval to
	TARGET_SIGNAL_0.
	(record_message_args): New struct.
	(record_message): Call gdbarch_process_record_signal.
	(do_record_message): Add argument "signal".
	(record_resume): Ditto.
	(record_wait): Ditto.  Check record_list->u.end.sigval
	in replay mode.

2009-09-21  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@vmware.com>

	* gdbarch.sh (process_record_signal): New interface.
@
text
@a61 5
struct record_end_entry
{
  enum target_signal sigval;
};

a79 2
    /* end */
    struct record_end_entry end;
a316 1
  rec->u.end.sigval = TARGET_SIGNAL_0;
a362 5
struct record_message_args {
  struct regcache *regcache;
  enum target_signal signal;
};

d367 1
a367 2
  struct record_message_args *myargs = args;
  struct gdbarch *gdbarch = get_regcache_arch (myargs->regcache);
d376 3
a378 38
  /* If gdb sends a signal value to target_resume,
     save it in the 'end' field of the previous instruction.

     Maybe process record should record what really happened,
     rather than what gdb pretends has happened.

     So if Linux delivered the signal to the child process during
     the record mode, we will record it and deliver it again in
     the replay mode.

     If user says "ignore this signal" during the record mode, then
     it will be ignored again during the replay mode (no matter if
     the user says something different, like "deliver this signal"
     during the replay mode).

     User should understand that nothing he does during the replay
     mode will change the behavior of the child.  If he tries,
     then that is a user error.

     But we should still deliver the signal to gdb during the replay,
     if we delivered it during the recording.  Therefore we should
     record the signal during record_wait, not record_resume.  */
  if (record_list != &record_first)    /* FIXME better way to check */
    {
      gdb_assert (record_list->type == record_end);
      record_list->u.end.sigval = myargs->signal;
    }

  if (myargs->signal == TARGET_SIGNAL_0
      || !gdbarch_process_record_signal_p (gdbarch))
    ret = gdbarch_process_record (gdbarch,
				  myargs->regcache,
				  regcache_read_pc (myargs->regcache));
  else
    ret = gdbarch_process_record_signal (gdbarch,
					 myargs->regcache,
					 myargs->signal);

d399 1
a399 2
do_record_message (struct regcache *regcache,
		   enum target_signal signal)
d401 1
a401 5
  struct record_message_args args;

  args.regcache = regcache;
  args.signal = signal;
  return catch_errors (record_message, &args, NULL, RETURN_MASK_ALL);
d523 1
a523 1
               enum target_signal signal)
d529 1
a529 1
      if (do_record_message (get_current_regcache (), signal))
d539 1
a539 1
                                signal);
a613 1
	      /* Is this a SIGTRAP?  */
d617 1
a617 1
		  /* Yes -- check if there is a breakpoint.  */
d622 1
a622 1
		      /* There is a breakpoint.  GDB will want to stop.  */
d634 2
a635 6
		      /* There is not a breakpoint, and gdb is not
		         stepping, therefore gdb will not stop.
			 Therefore we will not return to gdb.
		         Record the insn and resume.  */
		      if (!do_record_message (get_current_regcache (),
					      TARGET_SIGNAL_0))
a829 4
		  /* Check target signal */
		  if (record_list->u.end.sigval != TARGET_SIGNAL_0)
		    /* FIXME: better way to check */
		    continue_flag = 0;
a853 3
      else if (record_list->u.end.sigval != TARGET_SIGNAL_0)
	/* FIXME: better way to check */
	status->value.sig = record_list->u.end.sigval;
@


1.17.2.2
log
@        * record.c (record_open, record_store_registers, record_xfer_partial):
        Replace calls to nquery by calls to query.
@
text
@d500 1
a500 1
      if (!query
d1032 4
a1035 4
	      query (_("Because GDB is in replay mode, changing the "
		       "value of a register will make the execution "
		       "log unusable from this point onward.  "
		       "Change all registers?"));
d1038 3
a1040 3
	      query (_("Because GDB is in replay mode, changing the value "
		       "of a register will make the execution log unusable "
		       "from this point onward.  Change register %s?"),
d1088 3
a1090 3
	  if (!query (_("Because GDB is in replay mode, writing to memory "
		        "will make the execution log unusable from this "
		        "point onward.  Write memory at address %s?"),
@


1.17.2.3
log
@2009-09-29  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_open): Change "query" to "error".
	(cmd_record_stop): Change "query" to "printf_unfiltered".
@
text
@d499 6
a504 2
     error (_("Process record target already running.  Use \"record stop\" to "
 	     "stop record target first."));
d1252 3
a1254 3
      unpush_target (&record_ops);
      printf_unfiltered (_("Process record is stoped and all execution "
                           "log is deleted.\n"));
@


1.16
log
@2009-09-02  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_resume): Change "signal" to "siggnal".
@
text
@d35 1
a35 1
/* These are the core struct of record function.
d37 1
a37 1
   An record_entry is a record of the value change of a register
d39 3
a41 2
   instruction must has a struct record_entry ("record_end") that points out this
   is the last struct record_entry of this instruction.
d43 2
a44 1
   Each struct record_entry is linked to "record_list" by "prev" and "next". */
d1293 1
a1293 1
			    &record_stop_at_limit, _("\
d1300 2
a1301 2
			    NULL, NULL,
                            &set_record_cmdlist, &show_record_cmdlist);
d1311 2
a1312 2
	    _("Show the current number of instructions in the "
	      "record/replay buffer."), &info_record_cmdlist);
@


1.15
log
@2009-09-01  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_resume): Change "siggnal" to "signal".
@
text
@d521 1
a521 1
               enum target_signal signal)
d537 1
a537 1
                                signal);
@


1.14
log
@2009-08-31  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_resume_siggnal): Deleted.
	(record_resume): Ditto.
	(record_wait): Change record_resume_siggnal to
	TARGET_SIGNAL_0.
@
text
@d521 1
a521 1
               enum target_signal siggnal)
d537 1
a537 1
                                siggnal);
@


1.13
log
@2009-08-28  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_list_release_next): Change the first
	record_reg to record_end.
@
text
@a516 1
static enum target_signal record_resume_siggnal;
a523 1
  record_resume_siggnal = siggnal;
d639 1
a639 1
						record_resume_siggnal);
@


1.12
log
@2009-08-21  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_wait): Change the argument of
	record_beneath_to_wait to options.
@
text
@d160 1
a160 1
      if (tmp->type == record_reg)
@


1.11
log
@2009-08-08  Aleksandar Ristovski  <aristovski@@qnx.com>
            Hui Zhu  <teawater@@gmail.com>

	* record.c (record_store_registers): Remove unused variable.
@
text
@d601 1
a601 1
					 ptid, status, 0);
d612 1
a612 1
					    ptid, status, 0);
@


1.10
log
@2009-08-04  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_mem_entry): New field 'mem_entry_not_accessible'.
	(record_arch_list_add_mem): Initialize 'mem_entry_not_accessible'.
	(record_wait): Set 'mem_entry_not_accessible' flag if target
	memory not readable.  Don't try to change target memory if
	'mem_entry_not_accessible' is set.
@
text
@a961 1
	  struct cleanup *old_cleanups;
@


1.9
log
@2009-07-22  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_xfer_partial): Call error When nquery
	return "n".
@
text
@d54 3
d281 1
d734 49
a782 26
	      gdb_byte *mem = alloca (record_list->u.mem.len);
	      if (record_debug > 1)
		fprintf_unfiltered (gdb_stdlog,
				    "Process record: record_mem %s to "
				    "inferior addr = %s len = %d.\n",
				    host_address_to_string (record_list),
				    paddress (gdbarch, record_list->u.mem.addr),
				    record_list->u.mem.len);

	      if (target_read_memory
		  (record_list->u.mem.addr, mem, record_list->u.mem.len))
		error (_("Process record: error reading memory at "
			 "addr = %s len = %d."),
		       paddress (gdbarch, record_list->u.mem.addr),
		       record_list->u.mem.len);

	      if (target_write_memory
		  (record_list->u.mem.addr, record_list->u.mem.val,
		   record_list->u.mem.len))
		error (_
		       ("Process record: error writing memory at "
			"addr = %s len = %d."),
		       paddress (gdbarch, record_list->u.mem.addr),
		       record_list->u.mem.len);

	      memcpy (record_list->u.mem.val, mem, record_list->u.mem.len);
@


1.9.2.1
log
@2009-07-26  Michael Snyder  <msnyder@@vmware.com>

	In-flux state: target methods temporarily broken.

	* checkpoint.c (checkpoint_insert): New function.
	(checkpint_first): New function.
	(checkpoint_next): New function.
	(checkpoint_unlink): New function.
	(checkpoint_find_id): New function.
	(checkpoint_command): Manage list locally.
	(delete_checkpoint_command): Ditto.
	(info_checkpoints_command): Ditto.
	(restart_command): Ditto

	* checkpoint.h (checkpoint_insert, checkpoint_first,
	checkpoint_next, checkpoint_unlink, checkpoint_find_id): Export.

	* record.c (record_insert_checkpoint): New function.
	(record_delete_checkpoint): New function.
	(record_show_checkpoint_info): New function.
	(record_goto_checkpoint): New function.
	(record_restore_checkpoint): New function.
@
text
@a26 1
#include "checkpoint.h"
a1216 159
/*
 * Process Record checkpoint stuff
 */

struct record_checkpoint_info
{
  struct record_entry *position;	/* pointer into the record log */
  int insn_num;				/* numbered position in log */
  CORE_ADDR pc;				/* program counter of checkpoint */
};

void *
record_insert_checkpoint (struct checkpoint_info *cp, int from_tty)
{
  struct record_checkpoint_info *rp;
  rp = XZALLOC (struct record_checkpoint_info);
  rp->position = record_list;
  rp->insn_num = record_insn_num;
  rp->pc = stop_pc;	/* FIXME: should I use this?  */
  if (from_tty && info_verbose)
    {
      printf_filtered (_(" at pos 0x%08x, count 0x%08x, pc 0x%08x"),
		       (unsigned int) rp->position,
		       (unsigned int) rp->insn_num,
		       (unsigned int) rp->pc);
    }
  return rp;
}

void
record_delete_checkpoint (struct checkpoint_info *cp, int from_tty)
{
  xfree (cp->client_data);
}

void
record_show_checkpoint_info (struct checkpoint_info *cp, int from_tty)
{
  struct record_checkpoint_info *re = cp->client_data;

  printf_filtered (_("\
Checkpoint #%d at pos 0x%08x, count 0x%08x, pc 0x%08x\n"),
		   cp->checkpoint_id, 
		   (unsigned int) re->position,
		   (unsigned int) re->insn_num,
		   (unsigned int) re->pc);
}

static void
record_goto_checkpoint (struct record_entry *checkpoint, 
			enum exec_direction_kind dir)
{
  struct cleanup *set_cleanups = record_gdb_operation_disable_set ();
  struct regcache *regcache = get_current_regcache ();
  struct gdbarch *gdbarch = get_regcache_arch (regcache);

  /* Assume everything is valid: we will hit the checkpoint,
     and we will not hit the end of the recording.  */

  if (dir == EXEC_FORWARD)
    record_list = record_list->next;

  do
    {
      /* Set ptid, register and memory according to record_list.  */
      if (record_list->type == record_reg)
	{
	  /* reg */
	  gdb_byte reg[MAX_REGISTER_SIZE];
	  if (record_debug > 1)
	    fprintf_unfiltered (gdb_stdlog,
				"Process record: record_reg %s to "
				"inferior num = %d.\n",
				host_address_to_string (record_list),
				record_list->u.reg.num);
	  regcache_cooked_read (regcache, record_list->u.reg.num, reg);
	  regcache_cooked_write (regcache, record_list->u.reg.num,
				 record_list->u.reg.val);
	  memcpy (record_list->u.reg.val, reg, MAX_REGISTER_SIZE);
	}
      else if (record_list->type == record_mem)
	{
	  /* mem */
	  gdb_byte *mem = alloca (record_list->u.mem.len);
	  if (record_debug > 1)
	    fprintf_unfiltered (gdb_stdlog,
				"Process record: record_mem %s to "
				"inferior addr = %s len = %d.\n",
				host_address_to_string (record_list),
				paddress (gdbarch, record_list->u.mem.addr),
				record_list->u.mem.len);

	  if (target_read_memory (record_list->u.mem.addr, 
				  mem, record_list->u.mem.len))
	    error (_("Process record: error reading memory at "
		     "addr = %s len = %d."),
		   paddress (gdbarch, record_list->u.mem.addr),
		   record_list->u.mem.len);

	  if (target_write_memory (record_list->u.mem.addr, 
				   record_list->u.mem.val,
				   record_list->u.mem.len))
	    error (_("Process record: error writing memory at "
		     "addr = %s len = %d."),
		   paddress (gdbarch, record_list->u.mem.addr),
		   record_list->u.mem.len);

	  memcpy (record_list->u.mem.val, mem, record_list->u.mem.len);
	}

      if (dir == EXEC_REVERSE)
	record_list = record_list->prev;
      else
	record_list = record_list->next;
    } while (record_list != checkpoint);
  do_cleanups (set_cleanups);
}

void
record_restore_checkpoint (struct checkpoint_info *cp, int from_tty)
{
  int i = 0, checkpoint_index = 0, current_index = 0;
  struct record_entry *p;
  struct record_checkpoint_info *rp;

  rp = cp->client_data;
  for (p = &record_first; p != NULL; p = p->next)
    {
      if (p == rp->position)
	checkpoint_index = i;
      if (p == record_list)
	current_index = i;
      i++;
    }
  if (from_tty && info_verbose)
    {
      printf_filtered ("Checkpoint is at index %d\n", checkpoint_index);
      printf_filtered ("Cur point is at index %d\n", current_index);
      printf_filtered ("Counted %d (officially %d)\n", i-1, record_insn_num);
    }

  if (checkpoint_index == 0)
    error (_("Checkpoint index not found.\n"));
  else if (current_index == checkpoint_index)
    error (_("Already at checkpoint.\n"));
  else if (current_index > checkpoint_index)
    {
      if (from_tty)
	printf_filtered ("Go backward to checkpoint.\n");
      record_goto_checkpoint (rp->position, EXEC_REVERSE);
    }
  else
    {
      if (from_tty)
	printf_filtered ("Go forward to checkpoint.\n");
      record_goto_checkpoint (rp->position, EXEC_FORWARD);
    }
}

@


1.9.2.2
log
@2009-07-26  Michael Snyder  <msnyder@@vmware.com>

	Nearly working.

	* target.h (struct target_ops): Change func args of
	checkpoint methods.

	checkpoint.c (checkpoint_command): Use target method,
	bail if it isn't implemented.
	(delete_checkpoint_command): Ditto.
	(info_checkpoints_command): Ditto.
	(restart_command): Ditto.

	linux-fork.c (fork_list): Delete, use checkpoint list instead.
	(forks_exist_p): Check checkpoint list instead of fork_list.
	(delete_fork): Ditto.
	(find_fork_ptid): Ditto.
	(find_fork_id): Ditto.
	(find_fork_pid): Ditto.
	(add_fork): Ditto.
	(linux_fork_killall): Ditto.
	(linux_fork_mourn_inferior): Ditto.
	(linux_fork_detach): Ditto.
	(init_fork_list): Delete, no longer needed.
	(delete_checkpoint_command): Ditto.
	(info_checkpoints_command): Ditto.
	(checkpoint_command): Ditto.
	(restart_command): Ditto.
	(linux_unset_checkpoint): New function (target method).
	(linux_show_checkpoints_info): Ditto.
	(linux_set_checkpoint): Ditto.
	(linux_restore_checkpoint): Ditto.
	(_initialize_linux_fork): Use new target methods.

	* record.c (init_record_ops): Use new target methods.
@
text
@a120 7
/* Checkpoint target methods.  */

static void *record_insert_checkpoint (struct checkpoint_info *, int);
static void record_delete_checkpoint (struct checkpoint_info *, int);
static void record_show_checkpoint_info (struct checkpoint_info *, int);
static void record_restore_checkpoint (struct checkpoint_info *, int);

a1111 5
  /* Checkpoints */
  record_ops.to_set_checkpoint = record_insert_checkpoint;
  record_ops.to_unset_checkpoint = record_delete_checkpoint;
  record_ops.to_info_checkpoints = record_show_checkpoint_info;
  record_ops.to_restore_checkpoint = record_restore_checkpoint;
d1229 1
a1229 1
static void *
d1247 1
a1247 1
static void
d1253 1
a1253 1
static void
d1336 1
a1336 1
static void
@


1.9.2.3
log
@2009-08-06  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_restore_checkpoint): Count instructions, not
	record entries.
@
text
@d1362 1
a1362 2
      if (p->type == record_end)
	i++;
a1368 4
      if (rp->position->type == record_end)
	printf_filtered ("Checkpoint is record_end\n");
      if (record_list->type == record_end)
	printf_filtered ("record_list is record_end\n");
@


1.9.2.4
log
@2009-08-04  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@vmware.com>
	    (Import from main branch)
	* record.c (record_mem_entry): New field 'mem_entry_not_accessible'.
	(record_arch_list_add_mem): Initialize 'mem_entry_not_accessible'.
	(record_wait): Set 'mem_entry_not_accessible' flag if target
	memory not readable.  Don't try to change target memory if
	'mem_entry_not_accessible' is set.
@
text
@a54 3
  /* Set this flag if target memory for this entry
     can no longer be accessed.  */
  int mem_entry_not_accessible;
a285 1
  rec->u.mem.mem_entry_not_accessible = 0;
d738 26
a763 49
	      /* Nothing to do if the entry is flagged not_accessible.  */
	      if (!record_list->u.mem.mem_entry_not_accessible)
		{
		  gdb_byte *mem = alloca (record_list->u.mem.len);
		  if (record_debug > 1)
		    fprintf_unfiltered (gdb_stdlog,
				        "Process record: record_mem %s to "
				        "inferior addr = %s len = %d.\n",
				        host_address_to_string (record_list),
				        paddress (gdbarch,
					          record_list->u.mem.addr),
				        record_list->u.mem.len);

		  if (target_read_memory (record_list->u.mem.addr, mem,
		                          record_list->u.mem.len))
	            {
		      if (execution_direction != EXEC_REVERSE)
		        error (_("Process record: error reading memory at "
			         "addr = %s len = %d."),
		               paddress (gdbarch, record_list->u.mem.addr),
		               record_list->u.mem.len);
		      else
			/* Read failed -- 
			   flag entry as not_accessible.  */
		        record_list->u.mem.mem_entry_not_accessible = 1;
		    }
		  else
		    {
		      if (target_write_memory (record_list->u.mem.addr,
			                       record_list->u.mem.val,
		                               record_list->u.mem.len))
	                {
			  if (execution_direction != EXEC_REVERSE)
			    error (_("Process record: error writing memory at "
			             "addr = %s len = %d."),
		                   paddress (gdbarch, record_list->u.mem.addr),
		                   record_list->u.mem.len);
			  else
			    /* Write failed -- 
			       flag entry as not_accessible.  */
			    record_list->u.mem.mem_entry_not_accessible = 1;
			}
		      else
		        {
			  memcpy (record_list->u.mem.val, mem,
				  record_list->u.mem.len);
			}
		    }
		}
@


1.9.2.5
log
@2009-08-04  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_exec_entry): New function.
	(record_wait): Call 'record_exec_entry'.
@
text
@a426 83
static inline void
record_exec_entry (struct regcache *regcache, struct gdbarch *gdbarch,
                   struct record_entry *entry)
{
  switch (entry->type)
    {
    case record_reg: /* reg */
      {
        gdb_byte reg[MAX_REGISTER_SIZE];

        if (record_debug > 1)
          fprintf_unfiltered (gdb_stdlog,
                              "Process record: record_reg %s to "
                              "inferior num = %d.\n",
                              host_address_to_string (entry),
                              entry->u.reg.num);

        regcache_cooked_read (regcache, entry->u.reg.num, reg);
        regcache_cooked_write (regcache, entry->u.reg.num, entry->u.reg.val);
        memcpy (entry->u.reg.val, reg, MAX_REGISTER_SIZE);
      }
      break;

    case record_mem: /* mem */
      {
        if (!record_list->u.mem.mem_entry_not_accessible)
          {
            gdb_byte *mem = alloca (entry->u.mem.len);

            if (record_debug > 1)
              fprintf_unfiltered (gdb_stdlog,
                                  "Process record: record_mem %s to "
                                  "inferior addr = %s len = %d.\n",
                                  host_address_to_string (entry),
                                  paddress (gdbarch, entry->u.mem.addr),
                                  record_list->u.mem.len);

            if (target_read_memory (entry->u.mem.addr, mem, entry->u.mem.len))
              {
                if (execution_direction == EXEC_REVERSE)
                  {
                    record_list->u.mem.mem_entry_not_accessible = 1;
                    if (record_debug)
                      warning (_("Process record: error reading memory at "
                                 "addr = %s len = %d."),
                               paddress (gdbarch, entry->u.mem.addr),
                               entry->u.mem.len);
                  }
                else
                  error (_("Process record: error reading memory at "
                           "addr = %s len = %d."),
                         paddress (gdbarch, entry->u.mem.addr),
                        entry->u.mem.len);
              }
            else
              {
                if (target_write_memory (entry->u.mem.addr, entry->u.mem.val,
                                         entry->u.mem.len))
                  {
                    if (execution_direction == EXEC_REVERSE)
                      {
                        record_list->u.mem.mem_entry_not_accessible = 1;
                        if (record_debug)
                          warning (_("Process record: error writing memory at "
                                     "addr = %s len = %d."),
                                   paddress (gdbarch, entry->u.mem.addr),
                                   entry->u.mem.len);
                      }
                    else
                      error (_("Process record: error writing memory at "
                               "addr = %s len = %d."),
                             paddress (gdbarch, entry->u.mem.addr),
                            entry->u.mem.len);
                  }
              }

            memcpy (entry->u.mem.val, mem, entry->u.mem.len);
          }
      }
      break;
    }
}

d723 70
a792 3
	  record_exec_entry (regcache, gdbarch, record_list);

 	  if (record_list->type == record_end)
@


1.9.2.6
log
@2009-08-06  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_goto_checkpoint): Call record_exec_entry.
@
text
@d1337 46
a1382 1
      record_exec_entry (regcache, gdbarch, record_list);
@


1.9.2.7
log
@2009-08-06  Hui Zhu  <teawater@@gmail.com>
	    Michael Snyder  <msnyder@@vmware.com>
	(Add record dump/load commands: draft version, not ready for release).

	* record.c (RECORD_FILE_MAGIC): New constant.
	(record_arch_list_add_reg): Use xcalloc instead of xmalloc.
	(record_exec_entry): Pre-zero the register buffer.
	(cmd_record_fd_cleanup): New function (dead).
	(cmd_record_dump): New function.
	(bfdcore_read): New function.
	(cmd_record_load): New function.
	(_initialize_record): Add 'record dump' and 'record load' commands.
@
text
@a25 1
#include "completer.h"
a28 1
#include <byteswap.h>
a29 1
#include <netinet/in.h>
a35 2
#define RECORD_FILE_MAGIC	htonl(0x20090726) /* Host to network order */

d252 1
a252 1
  rec->u.reg.val = (gdb_byte *) xcalloc (1, MAX_REGISTER_SIZE);
a443 1
        memset (reg, 0, sizeof (reg));
a451 1
	/* Nothing to do if the entry is flagged not_accessible.  */
a467 2
		    /* Read failed -- 
		       flag entry as not_accessible.  */
d479 1
a479 1
			 entry->u.mem.len);
a487 2
			/* Write failed -- 
			   flag entry as not_accessible.  */
d499 1
a499 1
			     entry->u.mem.len);
a500 2
		else
		  memcpy (entry->u.mem.val, mem, entry->u.mem.len);
d502 2
d806 1
a806 1
          record_exec_entry (regcache, gdbarch, record_list);
d808 1
a808 1
	  if (record_list->type == record_end)
a1026 1

a1185 622
static void
cmd_record_fd_cleanups (void *recfdp)
{
  int recfd = *(int *) recfdp;
  close (recfd);
}

/* Record log save-file format
   Version 1

     Header:
       4 bytes: magic number RECORD_FILE_MAGIC.
                NOTE: be sure to change whenever this file format changes!

     Records: 
      record_end:
       1 byte:  record type (record_end)
      record_reg:
       1 byte:  record type (record_reg)
       8 bytes: register id
      16 bytes: register value
      record_mem:
       1 byte:  record type (record_mem)
       8 bytes: memory address
       8 bytes: memory length
       n bytes: memory value (n == memory length)

   Version 2 (proposed)

     Header:
       4 bytes: magic number RECORD_FILE_MAGIC.
                NOTE: be sure to change whenever this file format changes!
       n bytes: architecture...
       4 bytes: size of register snapshot
       n bytes: register snapshot
       4 bytes: number of section crcs
       n bytes: section names with crcs
       
     Records:
       See version 1.
 */

/* Dump the execution log to a file.  */

#include "elf-bfd.h"

static void
cmd_record_dump (char *args, int from_tty)
{
  char *recfilename, recfilename_buffer[40];
  int recfd;
  struct record_entry *cur_record_list;
  uint32_t magic;
  struct regcache *regcache;
  struct gdbarch *gdbarch;
  struct cleanup *old_cleanups;
  struct cleanup *set_cleanups;

  if (current_target.to_stratum != record_stratum)
    error (_("Process record is not started.\n"));

  if (args && *args)
    recfilename = args;
  else
    {
      /* Default recfile name is "rec.PID".  */
      sprintf (recfilename_buffer, "rec.%d", PIDGET (inferior_ptid));
      recfilename = recfilename_buffer;
    }

  /* Open the dump file.  */
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, 
			_("Saving recording to file '%s'\n"), 
			recfilename);

  /* Michael-style, elf core dump file.  */
  {
    extern void write_gcore_file (bfd *);
    extern bfd *create_gcore_bfd (char *);
    bfd *obfd;
    int dump_size = 0;
    asection *osec = NULL;
    struct record_entry *p;
    int bfd_offset = 0;

    /* Open the output file.  */
    obfd = create_gcore_bfd (recfilename);

    /* Need a cleanup that will close the file (FIXME: delete it?).  */
    old_cleanups = make_cleanup_bfd_close (obfd);

    /* Save the current record entry to "cur_record_list".  */
    cur_record_list = record_list;

    /* Get the values of regcache and gdbarch.  */
    regcache = get_current_regcache ();
    gdbarch = get_regcache_arch (regcache);

    /* Disable the GDB operation record.  */
    set_cleanups = record_gdb_operation_disable_set ();

    /* Reverse execute to the begin of record list.  */
    for (; record_list && record_list != &record_first; 
	 record_list = record_list->prev)
      {
	record_exec_entry (regcache, gdbarch, record_list);
      }

    /* Compute the size needed for the extra bfd section.  */
    dump_size = 4;	/* magic cookie */
    for (p = &record_first; p; p = p->next)
      switch (p->type)
	{
	case record_end:
	  dump_size += 1;
	  break;
	case record_reg:
	  dump_size += 1 + 8 + MAX_REGISTER_SIZE;
	  break;
	case record_mem:
	  dump_size += 1 + 8 + 8 + p->u.mem.len;
	  break;
	}

    /* Make the new bfd section.  */
    osec = bfd_make_section_anyway (obfd, "precord");
    bfd_set_section_size (obfd, osec, dump_size);
    bfd_set_section_vma (obfd, osec, 0);
    bfd_section_lma (obfd, osec) = 0;
    bfd_set_section_flags (obfd, osec, SEC_ALLOC | SEC_HAS_CONTENTS);

    /* Save corefile state.  */
    write_gcore_file (obfd);

    /* Write out the record log (modified Hui method).  */
    /* Write the magic code.  */
    magic = RECORD_FILE_MAGIC;
    if (record_debug)
      fprintf_unfiltered (gdb_stdlog, _("\
  Writing 4-byte magic cookie RECORD_FILE_MAGIC (0x%08x)\n"),
			  magic);
    if (bfd_set_section_contents (obfd, osec, &magic, 
				  bfd_offset, sizeof (magic)))
      bfd_offset += sizeof (magic);
    else
      error (_("Failed to write 'magic' to %s (%s)"), 
	     recfilename, bfd_errmsg (bfd_get_error ()));

    /* Dump the entries into the new bfd section.  */
    for (p = &record_first; p; p = p->next)
      {
	uint8_t tmpu8;
	uint64_t tmpu64;

	tmpu8 = p->type;
	if (bfd_set_section_contents (obfd, osec, &tmpu8, 
				      bfd_offset, sizeof (tmpu8)))
	  bfd_offset += sizeof (tmpu8);
	else
	  error (_("Failed to write 'type' to %s (%s)"), 
		 recfilename, bfd_errmsg (bfd_get_error ()));

	switch (p->type)
	  {
	  case record_reg: /* reg */
	    tmpu64 = p->u.reg.num;
	    if (BYTE_ORDER == LITTLE_ENDIAN)
	      tmpu64 = bswap_64 (tmpu64);

	    if (record_debug)
	      fprintf_unfiltered (gdb_stdlog, _("\
  Writing register %d val 0x%016llx (1 plus 8 plus %d bytes)\n"),
				  p->u.reg.num,
				  *(ULONGEST *) p->u.reg.val, 
				  MAX_REGISTER_SIZE);
	    /* FIXME: register num does not need 8 bytes.  */
	    if (bfd_set_section_contents (obfd, osec, &tmpu64,
					  bfd_offset, sizeof (tmpu64)))
	      bfd_offset += sizeof (tmpu64);
	    else
	      error (_("Failed to write regnum to %s (%s)"), 
		     recfilename, bfd_errmsg (bfd_get_error ()));

	    /* FIXME: add a len field, and write the smaller value.  */
	    if (bfd_set_section_contents (obfd, osec, 
					  p->u.reg.val,
					  bfd_offset, 
					  MAX_REGISTER_SIZE))
	      bfd_offset += MAX_REGISTER_SIZE;
	    else
	      error (_("Failed to write regval to %s (%s)"), 
		     recfilename, bfd_errmsg (bfd_get_error ()));
	    break;
	  case record_mem: /* mem */
	    tmpu64 = p->u.mem.addr;
	    if (BYTE_ORDER == LITTLE_ENDIAN)
	      tmpu64 = bswap_64 (tmpu64);

	    if (record_debug)
	      fprintf_unfiltered (gdb_stdlog, _("\
  Writing memory 0x%08x (1 plus 8 plus 8 bytes plus %d bytes)\n"),
				  (unsigned int) p->u.mem.addr,
				  p->u.mem.len);
	    if (bfd_set_section_contents (obfd, osec, &tmpu64, 
					  bfd_offset, sizeof (tmpu64)))
	      bfd_offset += sizeof (tmpu64);
	    else
	      error (_("Failed to write memaddr to %s (%s)"),
		     recfilename, bfd_errmsg (bfd_get_error ()));

	    tmpu64 = p->u.mem.len;
	    if (BYTE_ORDER == LITTLE_ENDIAN)
	      tmpu64 = bswap_64 (tmpu64);

	    /* FIXME: len does not need 8 bytes.  */
	    if (bfd_set_section_contents (obfd, osec, &tmpu64, 
					  bfd_offset, sizeof (tmpu64)))
	      bfd_offset += sizeof (tmpu64);
	    else
	      error (_("Failed to write memlen to %s (%s)"), 
		     recfilename, bfd_errmsg (bfd_get_error ()));

	    if (bfd_set_section_contents (obfd, osec, 
					  p->u.mem.val,
					  bfd_offset, 
					  p->u.mem.len))
	      bfd_offset += p->u.mem.len;
	    else
	      error (_("Failed to write memval to %s (%s)"),
		     recfilename, bfd_errmsg (bfd_get_error ()));
	    break;
	  case record_end:
	      /* FIXME: record the contents of record_end rec.  */
	      if (record_debug)
		fprintf_unfiltered (gdb_stdlog, _("\
  Writing record_end (1 byte)\n"));
	    break;
	  }
      }

    /* Now forward-execute back to the saved entry.  */
    for (record_list = &record_first; 
	 record_list && record_list != cur_record_list; 
	 record_list = record_list->next)
      {
	record_exec_entry (regcache, gdbarch, record_list);
      }
    /* Clean-ups will close the output file and free malloc memory.  */
    do_cleanups (old_cleanups);
  }

  /* Succeeded.  */
  fprintf_filtered (gdb_stdout, "Saved recfile %s.\n", recfilename);
}

static int
bfdcore_read (bfd *obfd, asection *osec, void *buf, int len, int *offset)
{
  int ret = bfd_get_section_contents (obfd, osec, buf, *offset, len);

  if (ret)
    *offset += len;
  return ret;
}

/* Load the execution log from a file.  */

#include "gdbcore.h"
#include <ctype.h>

static void
cmd_record_load (char *args, int from_tty)
{
  extern void nullify_last_target_wait_ptid (void);
  int recfd;
  uint32_t magic;
  struct cleanup *old_cleanups;
  struct cleanup *old_cleanups2;
  struct record_entry *rec;
  int insn_number = 0;

  if (!args || (args && !*args))
    error (_("Argument for filename required.\n"));

  /* Open the load file.  */
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, 
			_("Restoring recording from file '%s'\n"), args);
#if 1
  /* Michael-style elf core dump file.  */
  {
    bfd *core_bfd;
    asection *osec;
    extern bfd *load_corefile (char *, int);

   /* Restore corefile regs and mem sections.  */
   core_bfd = load_corefile (args, from_tty);
   old_cleanups = make_cleanup_bfd_close (core_bfd);

   /* Now need to find our special note section.  */
   osec = bfd_get_section_by_name (core_bfd, "null0");
   printf_filtered ("Find precord section %s.\n",
		    osec ? "succeeded" : "failed");

   if (osec) 
     {
       int i, len;
       int bfd_offset = 0;

       printf_filtered ("osec name = '%s'\n",
			bfd_section_name (core_bfd, osec));
       len = (int) bfd_section_size (core_bfd, osec);
       printf_filtered ("osec size = %d\n", len);

       /* Check the magic code.  */
       if (!bfdcore_read (core_bfd, osec, &magic, 
			  sizeof (magic), &bfd_offset))
	 error (_("Failed to read 'magic' from %s (%s)"),
		args, bfd_errmsg (bfd_get_error ()));

       if (magic != RECORD_FILE_MAGIC)
	 error (_("'%s', version mis-match / file format error."), 
		args);

       if (record_debug)
	 fprintf_unfiltered (gdb_stdlog, _("\
  Reading 4-byte magic cookie RECORD_FILE_MAGIC (0x%08x)\n"),
			     magic);
       if (current_target.to_stratum != record_stratum)
	 {
	   /* FIXME need cleanup!  We might error out.  */
	   cmd_record_start (NULL, from_tty);
	   printf_unfiltered (_("Auto start process record.\n"));
	 }

       /* Load the entries in recfd to the record_arch_list_head and
	  record_arch_list_tail.  */
       /* FIXME free old records? */
       record_list_release (record_arch_list_tail);
       record_arch_list_head = NULL;
       record_arch_list_tail = NULL;
       old_cleanups2 = make_cleanup (record_message_cleanups, 0);

       while (1)
	 {
	   uint8_t tmpu8;
	   uint64_t tmpu64;

	   if (!bfdcore_read (core_bfd, osec, &tmpu8, 
			      sizeof (tmpu8), &bfd_offset))
	     break;

	   switch (tmpu8)
	     {
	     case record_reg: /* reg */
	       /* FIXME: abstract out into an 'insert' function.  */
	       rec = (struct record_entry *) 
		 xmalloc (sizeof (struct record_entry));
	       rec->u.reg.val = (gdb_byte *) xcalloc (1, MAX_REGISTER_SIZE);
	       rec->prev = NULL;
	       rec->next = NULL;
	       rec->type = record_reg;
	       /* Get num.  */
	       /* FIXME: register num does not need 8 bytes.  */
	       if (!bfdcore_read (core_bfd, osec, &tmpu64, 
				  sizeof (tmpu64), &bfd_offset))
		 error (_("Failed to read regnum from %s (%s)"),
			args, bfd_errmsg (bfd_get_error ()));

	       if (BYTE_ORDER == LITTLE_ENDIAN)
		 tmpu64 = bswap_64 (tmpu64);
	       rec->u.reg.num = tmpu64;

	       /* Get val.  */
	       if (!bfdcore_read (core_bfd, osec, rec->u.reg.val,
				  MAX_REGISTER_SIZE, &bfd_offset))
		 error (_("Failed to read regval from  %s (%s)"),
			args, bfd_errmsg (bfd_get_error ()));

	       if (record_debug)
		 fprintf_unfiltered (gdb_stdlog, _("\
  Reading register %d val 0x%016llx (1 plus 8 plus %d bytes)\n"),
				     rec->u.reg.num, 
				     *(ULONGEST *) rec->u.reg.val, 
				     MAX_REGISTER_SIZE);
	       record_arch_list_add (rec);
	       break;

	     case record_mem: /* mem */
	       rec = (struct record_entry *) 
		 xmalloc (sizeof (struct record_entry));
	       rec->prev = NULL;
	       rec->next = NULL;
	       rec->type = record_mem;
	       /* Get addr.  */
	       if (!bfdcore_read (core_bfd, osec, &tmpu64, 
				  sizeof (tmpu64), &bfd_offset))
		 error (_("Failed to read memaddr from %s (%s)"),
			args, bfd_errmsg (bfd_get_error ()));
	       if (BYTE_ORDER == LITTLE_ENDIAN)
		 tmpu64 = bswap_64 (tmpu64);
	       rec->u.mem.addr = tmpu64;

	       /* Get len.  */
	       /* FIXME: len does not need 8 bytes.  */
	       if (!bfdcore_read (core_bfd, osec, &tmpu64, 
				  sizeof (tmpu64), &bfd_offset))
		 error (_("Failed to read memlen from %s (%s)"),
			args, bfd_errmsg (bfd_get_error ()));
	       if (BYTE_ORDER == LITTLE_ENDIAN)
		 tmpu64 = bswap_64 (tmpu64);
	       rec->u.mem.len = tmpu64;

	       rec->u.mem.mem_entry_not_accessible = 0;
	       rec->u.mem.val = (gdb_byte *) xmalloc (rec->u.mem.len);
	       /* Get val.  */
	       if (!bfdcore_read (core_bfd, osec, rec->u.mem.val,
				 rec->u.mem.len, &bfd_offset))
		 error (_("Failed to read memval from %s (%s)"),
			args, bfd_errmsg (bfd_get_error ()));
	       if (record_debug)
		 fprintf_unfiltered (gdb_stdlog, _("\
  Reading memory 0x%08x (1 plus 8 plus %d bytes)\n"),
				     (unsigned int) rec->u.mem.addr,
				     rec->u.mem.len);
	       record_arch_list_add (rec);
	       break;

	     case record_end: /* end */
	       /* FIXME: restore the contents of record_end rec.  */
	       rec = (struct record_entry *) 
		 xmalloc (sizeof (struct record_entry));
	       rec->prev = NULL;
	       rec->next = NULL;
	       rec->type = record_end;
	       if (record_debug)
		 fprintf_unfiltered (gdb_stdlog, _("\
  Reading record_end (one byte)\n"));
	       record_arch_list_add (rec);
	       insn_number ++;
	       break;

	     default:
	       error (_("Format of '%s' is not right."), args);
	       break;

	     }
	 }
     }

   discard_cleanups (old_cleanups2);

   /* Add record_arch_list_head to the end of record list.  (??? FIXME)*/
   for (rec = record_list; rec->next; rec = rec->next);
   rec->next = record_arch_list_head;
   record_arch_list_head->prev = rec;

   /* Update record_insn_num and record_insn_max_num.  */
   record_insn_num += insn_number;
   if (record_insn_num > record_insn_max_num)
     {
       record_insn_max_num = record_insn_num;
       warning (_("Auto increase record/replay buffer limit to %d."),
		record_insn_max_num);
     }

   do_cleanups (old_cleanups);
  }
#endif

#if 0
  /* Hui-style binary dump file.  */
  recfd = open (args, O_RDONLY | O_BINARY);
  if (recfd < 0)
    error (_("Failed to open '%s' for load."), args);
  old_cleanups = make_cleanup (cmd_record_fd_cleanups, &recfd);

  /* Check the magic code.  */
  if (read (recfd, &magic, 4) != 4)
    error (_("Failed to read '%s' for load."), args);
  if (magic != RECORD_FILE_MAGIC)
    error (_("'%s' is not a record dump."), args);
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, _("\
  Reading 4-byte magic cookie RECORD_FILE_MAGIC (0x%08x)\n"),
			magic);

  if (current_target.to_stratum != record_stratum)
    {
      /* FIXME need cleanup!  We might error out.  */
      cmd_record_start (NULL, from_tty);
      printf_unfiltered (_("Auto start process record.\n"));
    }

  /* Load the entries in recfd to the record_arch_list_head and
     record_arch_list_tail.  */
  record_arch_list_head = NULL;
  record_arch_list_tail = NULL;
  old_cleanups2 = make_cleanup (record_message_cleanups, 0);

  while (1)
    {
      int ret;
      uint8_t tmpu8;
      uint64_t tmpu64;

      ret = read (recfd, &tmpu8, 1);
      if (ret < 0)
        error (_("Failed to read '%s' for load."), args);
      if (ret == 0)
        break;

      switch (tmpu8)
        {
        case record_reg: /* reg */
	  /* FIXME: abstract out into an 'insert' function.  */
          rec = (struct record_entry *) xmalloc (sizeof (struct record_entry));
          rec->u.reg.val = (gdb_byte *) xcalloc (1, MAX_REGISTER_SIZE);
          rec->prev = NULL;
          rec->next = NULL;
          rec->type = record_reg;
          /* Get num.  */
	  /* FIXME: register num does not need 8 bytes.  */
          if (read (recfd, &tmpu64, 8) != 8)
            error (_("Failed to read '%s' for load."), args);
	  if (BYTE_ORDER == LITTLE_ENDIAN)
	    tmpu64 = bswap_64 (tmpu64);

          rec->u.reg.num = tmpu64;
          /* Get val.  */
          if (read (recfd, rec->u.reg.val,
                    MAX_REGISTER_SIZE) != MAX_REGISTER_SIZE)
            error (_("Failed to read '%s' for load."), args);
	  if (record_debug)
	    fprintf_unfiltered (gdb_stdlog, _("\
  Reading register %d val 0x%016llx (1 plus 8 plus %d bytes)\n"),
				rec->u.reg.num, 
				*(ULONGEST *) rec->u.reg.val, 
				MAX_REGISTER_SIZE);
          record_arch_list_add (rec);
          break;

        case record_mem: /* mem */
          rec = (struct record_entry *) xmalloc (sizeof (struct record_entry));
          rec->prev = NULL;
          rec->next = NULL;
          rec->type = record_mem;
          /* Get addr.  */
          if (read (recfd, &tmpu64, 8) != 8)
            error (_("Failed to read '%s' for load."), args);
	  if (BYTE_ORDER == LITTLE_ENDIAN)
	    tmpu64 = bswap_64 (tmpu64);

          rec->u.mem.addr = tmpu64;
          /* Get len.  */
	  /* FIXME: len does not need 8 bytes.  */
          if (read (recfd, &tmpu64, 8) != 8)
            error (_("Failed to read '%s' for load."), args);
	  if (BYTE_ORDER == LITTLE_ENDIAN)
	    tmpu64 = bswap_64 (tmpu64);

          rec->u.mem.len = tmpu64;
          rec->u.mem.mem_entry_not_accessible = 0;
          rec->u.mem.val = (gdb_byte *) xmalloc (rec->u.mem.len);
          /* Get val.  */
          if (read (recfd, rec->u.mem.val,
                    rec->u.mem.len) != rec->u.mem.len)
            error (_("Failed to read '%s' for load."), args);
	  if (record_debug)
	    fprintf_unfiltered (gdb_stdlog, _("\
  Reading memory 0x%08x (1 plus 8 plus %d bytes)\n"),
				(unsigned int) rec->u.mem.addr,
				rec->u.mem.len);
          record_arch_list_add (rec);
          break;

        case record_end: /* end */
	  /* FIXME: restore the contents of record_end rec.  */
          rec = (struct record_entry *) xmalloc (sizeof (struct record_entry));
          rec->prev = NULL;
          rec->next = NULL;
          rec->type = record_end;
	  if (record_debug)
	    fprintf_unfiltered (gdb_stdlog, _("\
  Reading record_end (one byte)\n"));
          record_arch_list_add (rec);
          insn_number ++;
          break;

        default:
          error (_("Format of '%s' is not right."), args);
          break;
        }
    }

  discard_cleanups (old_cleanups2);

  /* Add record_arch_list_head to the end of record list.  */
  for (rec = record_list; rec->next; rec = rec->next);
  rec->next = record_arch_list_head;
  record_arch_list_head->prev = rec;

  /* Update record_insn_num and record_insn_max_num.  */
  record_insn_num += insn_number;
  if (record_insn_num > record_insn_max_num)
    {
      record_insn_max_num = record_insn_num;
      warning (_("Auto increase record/replay buffer limit to %d."),
               record_insn_max_num);
    }

  do_cleanups (old_cleanups);
#endif
  /* Succeeded.  */
  fprintf_filtered (gdb_stdout, "Loaded recfile %s.\n", args);
  registers_changed ();
  reinit_frame_cache ();
  nullify_last_target_wait_ptid ();
  print_stack_frame (get_selected_frame (NULL), 1, SRC_AND_LOC);
}

a1394 2
  struct cmd_list_element *c;

a1427 9
  c = add_cmd ("dump", class_obscure, cmd_record_dump,
	       _("Dump the execution log to a file.\n\
Argument is optional filename.  Default filename is 'rec.<process_id>'."),
               &record_cmdlist);
  set_cmd_completer (c, filename_completer);
  c = add_cmd ("load", class_obscure, cmd_record_load,
	       _("Load the execution log from a file.  Argument is filename."),
               &record_cmdlist);
  set_cmd_completer (c, filename_completer);
d1442 1
a1442 1
			   &record_stop_at_limit, _("\
d1449 2
a1450 2
			   NULL, NULL,
			   &set_record_cmdlist, &show_record_cmdlist);
@


1.9.2.8
log
@2009-08-06  Michael Snyder  <msnyder@@vmware.com>

	* record.c (cmd_record_dump): Clean up draft version.
	(cmd_record_load): Ditto.
@
text
@a1254 8
  extern void write_gcore_file (bfd *);
  extern bfd *create_gcore_bfd (char *);
  bfd *obfd;
  int dump_size = 0;
  asection *osec = NULL;
  struct record_entry *p;
  int bfd_offset = 0;

d1274 29
a1302 25
  /* Open the output file.  */
  obfd = create_gcore_bfd (recfilename);

  /* Need a cleanup that will close the file (FIXME: delete it?).  */
  old_cleanups = make_cleanup_bfd_close (obfd);

  /* Save the current record entry to "cur_record_list".  */
  cur_record_list = record_list;

  /* Get the values of regcache and gdbarch.  */
  regcache = get_current_regcache ();
  gdbarch = get_regcache_arch (regcache);

  /* Disable the GDB operation record.  */
  set_cleanups = record_gdb_operation_disable_set ();

  /* Reverse execute to the begin of record list.  */
  for (; record_list && record_list != &record_first; 
       record_list = record_list->prev)
    record_exec_entry (regcache, gdbarch, record_list);

  /* Compute the size needed for the extra bfd section.  */
  dump_size = 4;	/* magic cookie */
  for (p = &record_first; p; p = p->next)
    switch (p->type)
d1304 1
a1304 9
      case record_end:
	dump_size += 1;
	break;
      case record_reg:
	dump_size += 1 + 8 + MAX_REGISTER_SIZE;
	break;
      case record_mem:
	dump_size += 1 + 8 + 8 + p->u.mem.len;
	break;
d1307 31
a1337 15
  /* Make the new bfd section.  */
  osec = bfd_make_section_anyway (obfd, "precord");
  bfd_set_section_size (obfd, osec, dump_size);
  bfd_set_section_vma (obfd, osec, 0);
  bfd_section_lma (obfd, osec) = 0;
  bfd_set_section_flags (obfd, osec, SEC_ALLOC | SEC_HAS_CONTENTS);

  /* Save corefile state.  */
  write_gcore_file (obfd);

  /* Write out the record log (modified Hui method).  */
  /* Write the magic code.  */
  magic = RECORD_FILE_MAGIC;
  if (record_debug)
    fprintf_unfiltered (gdb_stdlog, _("\
d1339 7
a1345 7
			magic);
  if (bfd_set_section_contents (obfd, osec, &magic, 
				bfd_offset, sizeof (magic)))
    bfd_offset += sizeof (magic);
  else
    error (_("Failed to write 'magic' to %s (%s)"), 
	   recfilename, bfd_errmsg (bfd_get_error ()));
d1347 5
a1351 13
  /* Dump the entries into the new bfd section.  */
  for (p = &record_first; p; p = p->next)
    {
      uint8_t tmpu8;
      uint64_t tmpu64;

      tmpu8 = p->type;
      if (bfd_set_section_contents (obfd, osec, &tmpu8, 
				    bfd_offset, sizeof (tmpu8)))
	bfd_offset += sizeof (tmpu8);
      else
	error (_("Failed to write 'type' to %s (%s)"), 
	       recfilename, bfd_errmsg (bfd_get_error ()));
d1353 14
a1366 6
      switch (p->type)
	{
	case record_reg: /* reg */
	  tmpu64 = p->u.reg.num;
	  if (BYTE_ORDER == LITTLE_ENDIAN)
	    tmpu64 = bswap_64 (tmpu64);
d1368 2
a1369 2
	  if (record_debug)
	    fprintf_unfiltered (gdb_stdlog, _("\
d1371 25
a1395 25
				p->u.reg.num,
				*(ULONGEST *) p->u.reg.val, 
				MAX_REGISTER_SIZE);
	  /* FIXME: register num does not need 8 bytes.  */
	  if (bfd_set_section_contents (obfd, osec, &tmpu64,
					bfd_offset, sizeof (tmpu64)))
	    bfd_offset += sizeof (tmpu64);
	  else
	    error (_("Failed to write regnum to %s (%s)"), 
		   recfilename, bfd_errmsg (bfd_get_error ()));

	  /* FIXME: add a len field, and write the smaller value.  */
	  if (bfd_set_section_contents (obfd, osec, 
					p->u.reg.val,
					bfd_offset, 
					MAX_REGISTER_SIZE))
	    bfd_offset += MAX_REGISTER_SIZE;
	  else
	    error (_("Failed to write regval to %s (%s)"), 
		   recfilename, bfd_errmsg (bfd_get_error ()));
	  break;
	case record_mem: /* mem */
	  tmpu64 = p->u.mem.addr;
	  if (BYTE_ORDER == LITTLE_ENDIAN)
	    tmpu64 = bswap_64 (tmpu64);
d1397 2
a1398 2
	  if (record_debug)
	    fprintf_unfiltered (gdb_stdlog, _("\
d1400 34
a1433 34
				(unsigned int) p->u.mem.addr,
				p->u.mem.len);
	  if (bfd_set_section_contents (obfd, osec, &tmpu64, 
					bfd_offset, sizeof (tmpu64)))
	    bfd_offset += sizeof (tmpu64);
	  else
	    error (_("Failed to write memaddr to %s (%s)"),
		   recfilename, bfd_errmsg (bfd_get_error ()));

	  tmpu64 = p->u.mem.len;
	  if (BYTE_ORDER == LITTLE_ENDIAN)
	    tmpu64 = bswap_64 (tmpu64);

	  /* FIXME: len does not need 8 bytes.  */
	  if (bfd_set_section_contents (obfd, osec, &tmpu64, 
					bfd_offset, sizeof (tmpu64)))
	    bfd_offset += sizeof (tmpu64);
	  else
	    error (_("Failed to write memlen to %s (%s)"), 
		   recfilename, bfd_errmsg (bfd_get_error ()));

	  if (bfd_set_section_contents (obfd, osec, 
					p->u.mem.val,
					bfd_offset, 
					p->u.mem.len))
	    bfd_offset += p->u.mem.len;
	  else
	    error (_("Failed to write memval to %s (%s)"),
		   recfilename, bfd_errmsg (bfd_get_error ()));
	  break;
	case record_end:
	  /* FIXME: record the contents of record_end rec.  */
	  if (record_debug)
	    fprintf_unfiltered (gdb_stdlog, _("\
d1435 3
a1437 3
	  break;
	}
    }
d1439 10
a1448 8
  /* Now forward-execute back to the saved entry.  */
  for (record_list = &record_first; 
       record_list && record_list != cur_record_list; 
       record_list = record_list->next)
    record_exec_entry (regcache, gdbarch, record_list);

  /* Clean-ups will close the output file and free malloc memory.  */
  do_cleanups (old_cleanups);
a1478 3
  bfd *core_bfd;
  asection *osec;
  extern bfd *load_corefile (char *, int);
d1487 35
d1523 54
a1576 29
  /* Restore corefile regs and mem sections.  */
  core_bfd = load_corefile (args, from_tty);
  old_cleanups = make_cleanup_bfd_close (core_bfd);

  /* Now need to find our special note section.  */
  osec = bfd_get_section_by_name (core_bfd, "null0");
  printf_filtered ("Find precord section %s.\n",
		   osec ? "succeeded" : "failed");

  if (osec)
    {
      int i, len;
      int bfd_offset = 0;

      if (record_debug)
	fprintf_unfiltered (gdb_stdlog, "osec name = '%s'\n",
			    bfd_section_name (core_bfd, osec));
      len = (int) bfd_section_size (core_bfd, osec);
      printf_filtered ("osec size = %d\n", len);

      /* Check the magic code.  */
      if (!bfdcore_read (core_bfd, osec, &magic, 
			 sizeof (magic), &bfd_offset))
	error (_("Failed to read 'magic' from %s (%s)"),
	       args, bfd_errmsg (bfd_get_error ()));

      if (magic != RECORD_FILE_MAGIC)
	error (_("'%s', version mis-match / file format error."), 
	       args);
d1578 105
a1682 2
      if (record_debug)
	fprintf_unfiltered (gdb_stdlog, _("\
d1684 1
a1684 7
			    magic);
      if (current_target.to_stratum != record_stratum)
	{
	  /* FIXME need cleanup!  We might error out.  */
	  cmd_record_start (NULL, from_tty);
	  printf_unfiltered (_("Auto start process record.\n"));
	}
d1686 6
a1691 6
      /* Free any existing record log, and load the entries in
	 core_bfd to the new record log.  */
      record_list_release (record_arch_list_tail);
      record_arch_list_head = 0;
      record_arch_list_tail = 0;
      old_cleanups2 = make_cleanup (record_message_cleanups, 0);
d1693 5
a1697 4
      while (1)
	{
	  uint8_t tmpu8;
	  uint64_t tmpu64;
d1699 5
a1703 4
	  /* FIXME: Check offset for end-of-section.  */
	  if (!bfdcore_read (core_bfd, osec, &tmpu8, 
			     sizeof (tmpu8), &bfd_offset))
	    break;
d1705 21
a1725 26
	  switch (tmpu8)
	    {
	    case record_reg: /* reg */
	      /* FIXME: abstract out into an 'insert' function.  */
	      rec = (struct record_entry *) 
		xmalloc (sizeof (struct record_entry));
	      rec->u.reg.val = (gdb_byte *) xcalloc (1, MAX_REGISTER_SIZE);
	      rec->prev = NULL;
	      rec->next = NULL;
	      rec->type = record_reg;
	      /* Get num.  */
	      /* FIXME: register num does not need 8 bytes.  */
	      if (!bfdcore_read (core_bfd, osec, &tmpu64, 
				 sizeof (tmpu64), &bfd_offset))
		error (_("Failed to read regnum from %s (%s)"),
		       args, bfd_errmsg (bfd_get_error ()));

	      if (BYTE_ORDER == LITTLE_ENDIAN)
		tmpu64 = bswap_64 (tmpu64);
	      rec->u.reg.num = tmpu64;

	      /* Get val.  */
	      if (!bfdcore_read (core_bfd, osec, rec->u.reg.val,
				 MAX_REGISTER_SIZE, &bfd_offset))
		error (_("Failed to read regval from  %s (%s)"),
		       args, bfd_errmsg (bfd_get_error ()));
d1727 7
a1733 2
	      if (record_debug)
		fprintf_unfiltered (gdb_stdlog, _("\
d1735 34
a1768 40
				    rec->u.reg.num, 
				    *(ULONGEST *) rec->u.reg.val, 
				    MAX_REGISTER_SIZE);
	      record_arch_list_add (rec);
	      break;

	    case record_mem: /* mem */
	      rec = (struct record_entry *) 
		xmalloc (sizeof (struct record_entry));
	      rec->prev = NULL;
	      rec->next = NULL;
	      rec->type = record_mem;
	      /* Get addr.  */
	      if (!bfdcore_read (core_bfd, osec, &tmpu64, 
				 sizeof (tmpu64), &bfd_offset))
		error (_("Failed to read memaddr from %s (%s)"),
		       args, bfd_errmsg (bfd_get_error ()));
	      if (BYTE_ORDER == LITTLE_ENDIAN)
		tmpu64 = bswap_64 (tmpu64);
	      rec->u.mem.addr = tmpu64;

	      /* Get len.  */
	      /* FIXME: len does not need 8 bytes.  */
	      if (!bfdcore_read (core_bfd, osec, &tmpu64, 
				 sizeof (tmpu64), &bfd_offset))
		error (_("Failed to read memlen from %s (%s)"),
		       args, bfd_errmsg (bfd_get_error ()));
	      if (BYTE_ORDER == LITTLE_ENDIAN)
		tmpu64 = bswap_64 (tmpu64);
	      rec->u.mem.len = tmpu64;

	      rec->u.mem.mem_entry_not_accessible = 0;
	      rec->u.mem.val = (gdb_byte *) xmalloc (rec->u.mem.len);
	      /* Get val.  */
	      if (!bfdcore_read (core_bfd, osec, rec->u.mem.val,
				 rec->u.mem.len, &bfd_offset))
		error (_("Failed to read memval from %s (%s)"),
		       args, bfd_errmsg (bfd_get_error ()));
	      if (record_debug)
		fprintf_unfiltered (gdb_stdlog, _("\
d1770 13
a1782 14
				    (unsigned int) rec->u.mem.addr,
				    rec->u.mem.len);
	      record_arch_list_add (rec);
	      break;

	    case record_end: /* end */
	      /* FIXME: restore the contents of record_end rec.  */
	      rec = (struct record_entry *) 
		xmalloc (sizeof (struct record_entry));
	      rec->prev = NULL;
	      rec->next = NULL;
	      rec->type = record_end;
	      if (record_debug)
		fprintf_unfiltered (gdb_stdlog, _("\
d1784 8
a1791 9
	      record_arch_list_add (rec);
	      insn_number ++;
	      break;

	    default:
	      error (_("Format of '%s' is not right."), args);
	      break;
	    }
	}
d1796 1
a1796 1
  /* Add record_arch_list_head to the end of record list.  (??? FIXME)*/
d1807 1
a1807 1
	       record_insn_max_num);
d1811 1
a1811 1

@


1.9.2.9
log
@2009-08-06  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_list_release): Finish releasing record list.
	(cmd_record_load): No longer necessary to null out
	record list pointers: record_list_release does it.
@
text
@a161 5

  record_list = &record_first;
  record_arch_list_tail = NULL;
  record_arch_list_tail = NULL;
  record_insn_num = 0;
d1529 2
@


1.9.2.10
log
@2009-08-06  Michael Snyder  <msnyder@@vmware.com>

	* record.c (bfdcore_write): New function, abstracted out
	from cmd_record_dump.
	(cmd_record_dump): Call bfdcore_write.
	(cmd_record_load): Fix setting of record_insn_num.
@
text
@a1248 10
static int
bfdcore_write (bfd *obfd, asection *osec, void *buf, int len, int *offset)
{
  int ret = bfd_set_section_contents (obfd, osec, buf, *offset, len);

  if (ret)
    *offset += len;
  return ret;
}

d1341 4
a1344 1
  if (!bfdcore_write (obfd, osec, &magic, sizeof (magic), &bfd_offset))
d1355 4
a1358 1
      if (!bfdcore_write (obfd, osec, &tmpu8, sizeof (tmpu8), &bfd_offset))
d1376 4
a1379 2
	  if (!bfdcore_write (obfd, osec, &tmpu64, 
			      sizeof (tmpu64), &bfd_offset))
d1384 6
a1389 2
	  if (!bfdcore_write (obfd, osec, p->u.reg.val,
					MAX_REGISTER_SIZE, &bfd_offset))
d1403 4
a1406 1
	  if (!bfdcore_write (obfd, osec, &tmpu64, sizeof (tmpu64), &bfd_offset))
d1415 4
a1418 1
	  if (!bfdcore_write (obfd, osec, &tmpu64, sizeof (tmpu64), &bfd_offset))
d1422 6
a1427 2
	  if (!bfdcore_write (obfd, osec, p->u.mem.val,
			      p->u.mem.len, &bfd_offset))
d1651 1
a1651 1
  record_insn_num = insn_number;
@


1.8
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d1000 1
a1000 1
	    return -1;
@


1.7
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d264 1
a264 1
			"Process record: add mem addr = 0x%s len = %d to "
d266 1
a266 1
			paddr_nz (addr), len);
d284 2
a285 2
			    "addr = 0x%s len = %d.\n",
			    paddr_nz (addr), len);
d652 1
d668 3
a670 3
				    "Process record: break at 0x%s.\n",
				    paddr_nz (tmp_pc));
	      if (gdbarch_decr_pc_after_break (get_regcache_arch (regcache))
d674 1
a674 2
				   gdbarch_decr_pc_after_break
				   (get_regcache_arch (regcache)));
d734 1
a734 1
				    "inferior addr = 0x%s len = %d.\n",
d736 1
a736 1
				    paddr_nz (record_list->u.mem.addr),
d742 2
a743 2
			 "addr = 0x%s len = %d."),
		       paddr_nz (record_list->u.mem.addr),
d751 2
a752 2
			"addr = 0x%s len = %d."),
		       paddr_nz (record_list->u.mem.addr),
d793 3
a795 3
					    "at 0x%s.\n",
					    paddr_nz (tmp_pc));
		      if (gdbarch_decr_pc_after_break (get_regcache_arch (regcache))
d800 1
a800 2
					   gdbarch_decr_pc_after_break
					   (get_regcache_arch (regcache)));
d998 2
a999 2
		         "point onward.  Write memory at address 0x%s?"),
		       paddr_nz (offset)))
@


1.6
log
@	* ada-tasks.c (read_known_tasks_array): Use target_gdbarch instead
	of current_gdbarch.
	* aix-thread.c (pd_enable): Likewise.
	* amd64-linux-nat.c (ps_get_thread_area): Likewise.
	* bsd-uthread.c (bsd_uthread_activate): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* linux-thread-db.c (enable_thread_event): Likewise.
	* monitor.c (monitor_write_memory, monitor_read_memory): Likewise.
	* nto-procfs.c (procfs_open): Likewise.
	* procfs.c (invalidate_cache, procfs_insert_watchpoint,
	info_proc_mappings, info_mappings_callback): Likewise.
	* record.c (record_open): Likewise.
	* rs6000-nat.c (ARCH64): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	(darwin_bfd_open): Likewise.
	* memattr.c (mem_info_command): Likewise.

	* windows-nat.c (win32_resume): Use current regcache architecture
	instead of current_gdbarch.

	* dbug-rom.c (dbug_regname): Remove check against number of
	registers in current_gdbarch.
	* solib-pa64.c (read_dynamic_info): Remove unused variable.
@
text
@d115 4
a118 2
static int (*record_beneath_to_insert_breakpoint) (struct bp_target_info *);
static int (*record_beneath_to_remove_breakpoint) (struct bp_target_info *);
d1051 2
a1052 1
record_insert_breakpoint (struct bp_target_info *bp_tgt)
d1057 1
a1057 1
      int ret = record_beneath_to_insert_breakpoint (bp_tgt);
d1068 2
a1069 1
record_remove_breakpoint (struct bp_target_info *bp_tgt)
d1074 1
a1074 1
      int ret = record_beneath_to_remove_breakpoint (bp_tgt);
@


1.5
log
@	* target.h (TARGET_WNOHANG): New.
	* target.c (target_wait): Add `options' argument.  Adjust.
	(struct target_ops) <to_wait>: Add `options' argument.
	(target_wait): Add `options' argument.
	* infrun.c (wait_for_inferior): Pass 0 as options to
	target_wait (blocking wait).
	(fetch_inferior_event): Pass TARGET_WNOHANG as options to
	target_wait.
	* fork-child.c (startup_inferior): Pass 0 as options to
	target_wait (blocking wait).
	* linux-nat.c (linux_nat_create_inferior): Remove async masking.
	(linux_nat_wait_1): Add `target_options' argument.  Use it instead
	of checking on target_can_async_p.
	(linux_nat_wait): Add `target_options' argument.  Adjust.
	* remote.c (remote_wait_ns): Add `options' argument.  Adjust to
	check on TARGET_WNOWAIT instead of checking on remote_is_async_p.
	(remote_wait_as): Add `options' argument.  Adjust to check on
	TARGET_WNOWAIT instead of checking on remote_is_async_p.  If doing
	a blocking wait, keep waiting until an interesting event comes
	out.
	(remote_wait): Add `options' argument.  Don't loop here if the
	target is in async mode, and a blocking wait has been requested.

	* top.c (deprecated_target_wait_hook): Add `options' argument.
	* linux-thread-db.c (thread_db_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ptrace.c (inf_ptrace_wait): Add `options' argument.
	* record.c (record_beneath_to_wait): Add `options' argument.
	(record_wait): Add `options' argument, and pass it down to the
	layer beneath.
	* bsd-uthread.c (bsd_uthread_wait): Add `options' argument.
	* darwin-nat.c (darwin_wait): Likewise.
	* defs.h (deprecated_target_wait_hook): Likewise.
	* gnu-nat.c (gnu_wait): Add `options' argument.
	* go32-nat.c (go32_wait): Likewise.
	* hpux-thread.c (hpux_thread_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ttrace.c (inf_ttrace_wait): Add `options' argument.
	* monitor.c (monitor_wait): Likewise.
	* nto-procfs.c (procfs_wait): Likewise.
	* remote-mips.c (mips_wait): Add `options' argument.
	* remote-sim.c (gdbsim_wait): Likewise.
	* rs6000-nat.c (rs6000_wait): Add `options' argument.
	* sol-thread.c (sol_thread_wait): Add `options' argument, and pass
	it down to the layer beneath.
	* spu-linux-nat.c (spu_child_wait): Add `options' argument.
	* windows-nat.c (windows_wait): Likewise.
	* tui/tui-hooks.c (tui_target_wait_hook): Likewise.  Adjust.
@
text
@d431 1
a431 1
  if (!gdbarch_process_record_p (current_gdbarch))
@


1.4
log
@	* inferior.h (read_pc, write_pc): Remove.
	* regcache.c (read_pc, write_pc): Remove.

	* infrun.c (displaced_step_fixup): Use regcache_read_pc instead
	of read_pc.
	(handle_inferior_event): Use regcache_read_pc instead of read_pc
	when determining value of stop_pc.  Replace subsequent uses of
	read_pc by inspecting already-retrieved stop_pc value.
	(keep_going): Use regcache_read_pc instead of read_pc.

	* breakpoint.c (watchpoint_check): Use current frame architecture
	and PC instead of current_gdbarch and read_pc ().
	* tracepoint.c (set_traceframe_context): Replace PC argument
	with FRAME argument.
	(trace_start_command, finish_tfind_command): Update calls.
	(finish_tfind_command): Compare frame IDs to identify transitions
	between frames.
	(trace_find_pc_command): Use regcache_read_pc instead of read_pc.
	* rs6000-nat.c (exec_one_dummy_insn): Pass in regcache instead
	of gdbarch.  Use regcache_read_pc and regcache_write_pc instead
	of read_pc and write_pc.
	(store_register): Make regcache argument non-const.  Update call
	to exec_one_dummy_insn.

	* thread.c (switch_to_thread): Use regcache_read_pc instead of read_pc.
	* infcmd.c (post_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (enable_break, svr4_relocate_main_executable): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* record.c (record_wait): Likewise.
	* procfs.c (procfs_wait): Likewise.
	* remote-mips.c (common_open, mips_wait): Likewise.
	* remote-m32r-sdi.c (m32r_resume): Likewise.

	* symfile.c (generic_load): Use regcache_write_pc instead of write_pc.
	* monitor.c (monitor_create_inferior, monitor_load): Likewise.
	* m32r-rom.c (m32r_load, m32r_upload_command): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior, m32r_load): Likewise.
	* remote-mips.c (mips_create_inferior, mips_load): Likewise.

	* solib-darwin.c: Include "regcache.h".
	* solib-pa64.c: Include "regcache.h".
	* solib-svr4.c: Include "regcache.h.".

	* symfile.c: Do not mention read_pc or write_pc in comments.
	* dink32-rom.c: Likewise.
	* m32r-rom.c: Likewise.
	* mips-tdep.c: Likewise.
@
text
@d101 2
a102 1
					 struct target_waitstatus *);
d570 2
a571 1
              ptid_t ptid, struct target_waitstatus *status)
d595 1
a595 1
                                                      ptid, status);
d606 1
a606 1
					    ptid, status);
@


1.3
log
@
	* record.c (_initialize_record): Reformat and clarify doc strings
	for stop-at-limit and insn-number-max.
@
text
@d611 1
a611 1
		  tmp_pc = read_pc ();
@


1.2
log
@Process record and replay target.

* Makefile.in (SFILES): Add record.c.
(COMMON_OBS): Add record.o.
* record.c, record.h: New file.
@
text
@d1262 7
a1268 12
			    &record_stop_at_limit,
			    _("Set whether record/replay stop when "
			      "record/replay buffer becomes full."),
			    _("Show whether record/replay stop when "
			      "record/replay buffer becomes full."),
	                    _("Enable is default value.\n"
	                      "When enabled, if the record/replay buffer "
			      "becomes full,\n"
                              "ask user what to do.\n"
                              "When disabled, if the record/replay buffer "
			      "becomes full,\n"
                              "delete it and start new recording."),
d1274 3
a1276 5
			    _("Show record/replay buffer limit."),
			    _("Set the maximum number of instructions to be "
                              "stored in the\n"
                              "record/replay buffer.  "
                              "Zero means unlimited (default 200000)."),
@


1.1
log
@file record.c was initially added on branch reverse-20080717-branch.
@
text
@d1 1289
@


1.1.6.1
log
@2008-12-26  Michael Snyder  <msnyder@@vmware.com>

	* Marker: adding teawater patches to branch.
@
text
@a0 1272
/* Process record and replay target for GDB, the GNU debugger.

   Copyright (C) 2008 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "target.h"
#include "gdbcmd.h"
#include "regcache.h"
#include "inferior.h"
#include "gdbthread.h"
#include "record.h"

#include <signal.h>

#define DEFAULT_RECORD_INSN_MAX_NUM	200000

int record_debug = 0;

record_t record_first;
record_t *record_list = &record_first;
record_t *record_arch_list_head = NULL;
record_t *record_arch_list_tail = NULL;
struct regcache *record_regcache = NULL;

/* 1 ask user. 0 auto delete the last record_t.  */
static int record_stop_at_limit = 1;
static int record_insn_max_num = DEFAULT_RECORD_INSN_MAX_NUM;
static int record_insn_num = 0;

struct target_ops record_ops;
static int record_resume_step = 0;
static enum target_signal record_resume_siggnal;
static int record_get_sig = 0;
static sigset_t record_maskall;
static int record_not_record = 0;
int record_will_store_registers = 0;

extern struct bp_location *bp_location_chain;

/* The real beneath function pointers.  */
void (*record_beneath_to_resume) (ptid_t, int, enum target_signal);
ptid_t (*record_beneath_to_wait) (ptid_t, struct target_waitstatus *);
void (*record_beneath_to_store_registers) (struct regcache *, int regno);
LONGEST (*record_beneath_to_xfer_partial) (struct target_ops * ops,
					   enum target_object object,
					   const char *annex,
					   gdb_byte * readbuf,
					   const gdb_byte * writebuf,
					   ULONGEST offset, LONGEST len);
int (*record_beneath_to_insert_breakpoint) (struct bp_target_info *);
int (*record_beneath_to_remove_breakpoint) (struct bp_target_info *);

static void
record_list_release (record_t * rec)
{
  record_t *tmp;

  if (!rec)
    return;

  while (rec->next)
    {
      rec = rec->next;
    }

  while (rec->prev)
    {
      tmp = rec;
      rec = rec->prev;
      if (tmp->type == record_reg)
	{
	  xfree (tmp->u.reg.val);
	}
      else if (tmp->type == record_mem)
	{
	  xfree (tmp->u.mem.val);
	}
      xfree (tmp);
    }

  if (rec != &record_first)
    {
      xfree (rec);
    }
}

static void
record_list_release_next (void)
{
  record_t *rec = record_list;
  record_t *tmp = rec->next;
  rec->next = NULL;
  while (tmp)
    {
      rec = tmp->next;
      if (tmp->type == record_reg)
	{
	  record_insn_num--;
	}
      else if (tmp->type == record_reg)
	{
	  xfree (tmp->u.reg.val);
	}
      else if (tmp->type == record_mem)
	{
	  xfree (tmp->u.mem.val);
	}
      xfree (tmp);
      tmp = rec;
    }
}

static void
record_list_release_first (void)
{
  record_t *tmp = NULL;
  enum record_type type;

  if (!record_first.next)
    {
      return;
    }

  while (1)
    {
      type = record_first.next->type;

      if (type == record_reg)
	{
	  xfree (record_first.next->u.reg.val);
	}
      else if (type == record_mem)
	{
	  xfree (record_first.next->u.mem.val);
	}
      tmp = record_first.next;
      record_first.next = tmp->next;
      xfree (tmp);

      if (!record_first.next)
	{
	  gdb_assert (record_insn_num == 1);
	  break;
	}

      record_first.next->prev = &record_first;

      if (type == record_end)
	{
	  break;
	}
    }

  record_insn_num--;
}

/* Add a record_t to record_arch_list.  */
static void
record_arch_list_add (record_t * rec)
{
  if (record_arch_list_tail)
    {
      record_arch_list_tail->next = rec;
      rec->prev = record_arch_list_tail;
      record_arch_list_tail = rec;
    }
  else
    {
      record_arch_list_head = rec;
      record_arch_list_tail = rec;
    }
}

/* Record the value of a register ("num") to record_arch_list.  */
int
record_arch_list_add_reg (int num)
{
  record_t *rec;

  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Process record: add register num = %d to record list.\n",
			  num);
    }

  rec = (record_t *) xmalloc (sizeof (record_t));
  rec->u.reg.val = (gdb_byte *) xmalloc (MAX_REGISTER_SIZE);
  rec->prev = NULL;
  rec->next = NULL;
  rec->type = record_reg;
  rec->u.reg.num = num;

  regcache_raw_read (record_regcache, num, rec->u.reg.val);

  record_arch_list_add (rec);

  return (0);
}

/* Record the value of a region of memory whose address is "addr" and
   length is "len" to record_arch_list.  */

int
record_arch_list_add_mem (CORE_ADDR addr, int len)
{
  record_t *rec;

  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Process record: add mem addr = 0x%s len = %d to record list.\n",
			  paddr_nz (addr), len);
    }

  if (!addr)
    {
      return (0);
    }

  rec = (record_t *) xmalloc (sizeof (record_t));
  rec->u.mem.val = (gdb_byte *) xmalloc (len);
  rec->prev = NULL;
  rec->next = NULL;
  rec->type = record_mem;
  rec->u.mem.addr = addr;
  rec->u.mem.len = len;

  if (target_read_memory (addr, rec->u.mem.val, len))
    {
      if (record_debug)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "Process record: error reading memory at addr = 0x%s len = %d.\n",
			      paddr_nz (addr), len);
	}
      xfree (rec->u.mem.val);
      xfree (rec);
      return (-1);
    }

  record_arch_list_add (rec);

  return (0);
}

/* Add a record_end type record_t to record_arch_list.  */
int
record_arch_list_add_end (int need_dasm)
{
  record_t *rec;

  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Process record: add end need_dasm = %d to arch list.\n",
			  need_dasm);
    }

  rec = (record_t *) xmalloc (sizeof (record_t));
  rec->prev = NULL;
  rec->next = NULL;
  rec->type = record_end;

  rec->u.need_dasm = need_dasm;

  record_arch_list_add (rec);

  return (0);
}

static void
record_check_insn_num (int set_terminal)
{
  if (record_insn_max_num)
    {
      gdb_assert (record_insn_num <= record_insn_max_num);
      if (record_insn_num == record_insn_max_num)
	{
	  /* Ask user what to do */
	  if (record_stop_at_limit)
	    {
	      int q;
	      if (set_terminal)
		target_terminal_ours ();
	      q = yquery (_("Do you want to auto delete previous execute log entries when record/replay buffer becomes full (record-stop-at-limit)?"));
	      if (set_terminal)
		target_terminal_inferior ();
	      if (q)
		{
		  record_stop_at_limit = 0;
		}
	      else
		{
		  error (_("Process record: inferior program stopped."));
		}
	    }
	}
    }
}

/* Before inferior step (when GDB record the running message, inferior
   only can step), GDB will call this function to record the values to
   record_list.  This function will call gdbarch_process_record to
   record the running message of inferior and set them to
   record_arch_list, and add it to record_list.  */

static void
record_message_cleanups (void *ignore)
{
  record_list_release (record_arch_list_tail);
  set_executing (inferior_ptid, 0);
  normal_stop ();
}

void
record_message (struct gdbarch *gdbarch)
{
  int ret;
  struct cleanup *old_cleanups = make_cleanup (record_message_cleanups, 0);

  /* Check record_insn_num.  */
  record_check_insn_num (1);

  record_arch_list_head = NULL;
  record_arch_list_tail = NULL;
  record_regcache = get_current_regcache ();

  ret = gdbarch_process_record (gdbarch,
				regcache_read_pc (record_regcache));
  if (ret > 0)
    error (_("Process record: inferior program stopped."));
  if (ret < 0)
    error (_("Process record: failed to record execution log."));

  discard_cleanups (old_cleanups);

  record_list->next = record_arch_list_head;
  record_arch_list_head->prev = record_list;
  record_list = record_arch_list_tail;

  if (record_insn_num == record_insn_max_num && record_insn_max_num)
    {
      record_list_release_first ();
    }
  else
    {
      record_insn_num++;
    }
}

/* Things to clean up if we QUIT out of function that set
   record_not_record.  */
static void
record_not_record_cleanups (void *ignore)
{
  record_not_record = 0;
}

void
record_not_record_set (void)
{
  struct cleanup *old_cleanups = make_cleanup (record_not_record_cleanups, 0);
  record_not_record = 1;
}

static void
record_open (char *name, int from_tty)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Process record: record_open\n");
    }

  /* check exec */
  if (!target_has_execution)
    {
      error (_("Process record: the program is not being run."));
    }
  if (non_stop)
    {
      error (_("Process record target can't debug inferior in non-stop mode (non-stop)."));
    }
  if (target_async_permitted)
    {
      error (_("Process record target can't debug inferior in asynchronous mode (target-async)."));
    }

  if (!gdbarch_process_record_p (current_gdbarch))
    {
      error (_("Process record: the current architecture doesn't support record function."));
    }

  /* Check if record target is already running */
  if (RECORD_IS_USED)
    {
      if (!nquery
	  (_("Process record target already running, do you want to delete the old record log?")))
	{
	  return;
	}
    }

  push_target (&record_ops);

  /* Reset */
  record_insn_num = 0;
  record_list = &record_first;
  record_list->next = NULL;
}

static void
record_close (int quitting)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Process record: record_close\n");
    }
  record_list_release (record_list);
}

static void
record_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  record_resume_step = step;
  record_resume_siggnal = siggnal;

  if (!RECORD_IS_REPLAY)
    {
      record_message (current_gdbarch);
      record_beneath_to_resume (ptid, 1, siggnal);
    }
}

static void
record_sig_handler (int signo)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Process record: get a signal\n");
    }
  record_resume_step = 1;
  record_get_sig = 1;
}

static void
record_wait_cleanups (void *ignore)
{
  if (execution_direction == EXEC_REVERSE)
    {
      if (record_list->next)
	{
	  record_list = record_list->next;
	}
    }
  else
    {
      record_list = record_list->prev;
    }
  set_executing (inferior_ptid, 0);
  normal_stop ();
}

/* record_wait
   In replay mode, this function examines the recorded log and
   determines where to stop.  */

static ptid_t
record_wait (ptid_t ptid, struct target_waitstatus *status)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Process record: record_wait record_resume_step = %d\n",
			  record_resume_step);
    }

  if (!RECORD_IS_REPLAY)
    {
      if (record_resume_step)
	{
	  /* This is a single step.  */
	  return record_beneath_to_wait (ptid, status);
	}
      else
	{
	  if (record_resume_step)
	    {
	      /* This is a single step.  */
	      return record_beneath_to_wait (ptid, status);
	    }
	  else
	    {
	      /* This is not a single step.  */
	      ptid_t ret;
	      int is_breakpoint = 1;
	      CORE_ADDR pc;
	      int pc_is_read = 0;
	      struct bp_location *bl;
	      struct breakpoint *b;

	      do
		{
		  ret = record_beneath_to_wait (ptid, status);

		  if (status->kind == TARGET_WAITKIND_STOPPED
		      && status->value.sig == TARGET_SIGNAL_TRAP)
		    {
		      /* Check if there is a breakpoint.  */
		      pc_is_read = 0;
		      registers_changed ();
		      for (bl = bp_location_chain; bl; bl = bl->global_next)
			{
			  b = bl->owner;
			  gdb_assert (b);
			  if (b->enable_state != bp_enabled
			      && b->enable_state != bp_permanent)
			    continue;
			  if (!pc_is_read)
			    {
			      pc =
				regcache_read_pc (get_thread_regcache (ret));
			      pc_is_read = 1;
			    }
			  switch (b->type)
			    {
			    default:
			      if (bl->address == pc)
				{
				  goto breakpoint;
				}
			      break;

			    case bp_watchpoint:
			      /*XXX teawater: I still not very clear how to deal with it.  */
			      goto breakpoint;
			      break;

			    case bp_catchpoint:
			      gdb_assert (b->ops != NULL
					  && b->ops->breakpoint_hit != NULL);
			      if (b->ops->breakpoint_hit (b))
				{
				  goto breakpoint;
				}
			      break;

			    case bp_hardware_watchpoint:
			    case bp_read_watchpoint:
			    case bp_access_watchpoint:
			      if (STOPPED_BY_WATCHPOINT (0))
				{
				  goto breakpoint;
				}
			      break;
			    }
			}

		      /* There is not a breakpoint.  */
		      record_message (current_gdbarch);
		      record_beneath_to_resume (ptid, 1,
						record_resume_siggnal);
		      continue;
		    }

		  is_breakpoint = 0;

		breakpoint:
		  /* Add gdbarch_decr_pc_after_break to pc because pc will
		     be break at address add gdbarch_decr_pc_after_break
		     when inferior non-step execute.  */
		  if (is_breakpoint)
		    {
		      CORE_ADDR decr_pc_after_break =
			gdbarch_decr_pc_after_break (current_gdbarch);
		      if (decr_pc_after_break)
			{
			  if (!pc_is_read)
			    {
			      pc =
				regcache_read_pc (get_thread_regcache (ret));
			    }
			  regcache_write_pc (get_thread_regcache (ret),
					     pc + decr_pc_after_break);
			}
		    }

		  break;
		}
	      while (1);

	      return ret;
	    }
	}
    }
  else
    {
      struct sigaction act, old_act;
      int need_dasm = 0;
      struct regcache *regcache = get_current_regcache ();
      int continue_flag = 1;
      int first_record_end = 1;
      struct cleanup *old_cleanups = make_cleanup (record_wait_cleanups, 0);
      CORE_ADDR tmp_pc;

      status->kind = TARGET_WAITKIND_STOPPED;

      /* Check breakpoint when forward execute.  */
      if (execution_direction == EXEC_FORWARD)
	{
	  tmp_pc = regcache_read_pc (regcache);
	  if (breakpoint_inserted_here_p (tmp_pc))
	    {
	      if (record_debug)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Process record: break at 0x%s.\n",
				      paddr_nz (tmp_pc));
		}
	      if (gdbarch_decr_pc_after_break (get_regcache_arch (regcache))
		  && !record_resume_step)
		{
		  regcache_write_pc (regcache,
				     tmp_pc +
				     gdbarch_decr_pc_after_break
				     (get_regcache_arch (regcache)));
		}
	      goto replay_out;
	    }
	}

      record_get_sig = 0;
      act.sa_handler = record_sig_handler;
      act.sa_mask = record_maskall;
      act.sa_flags = SA_RESTART;
      if (sigaction (SIGINT, &act, &old_act))
	{
	  perror_with_name (_("Process record: sigaction failed"));
	}
      /* If GDB is in terminal_inferior, it will not get the signal.
         And in GDB replay mode, GDB doesn't need to in terminal_inferior
         because inferior will not executed.
         Then set it to terminal_ours to make GDB get the signal.  */
      target_terminal_ours ();

      /* In EXEC_FORWARD mode, record_list point to the tail of prev
         instruction.  */
      if (execution_direction == EXEC_FORWARD && record_list->next)
        {
	  record_list = record_list->next;
	}

      /* Loop over the record_list, looking for the next place to
	 stop.  */
      do
	{
	  /* Check for beginning and end of log.  */
	  if (execution_direction == EXEC_REVERSE
	      && record_list == &record_first)
	    {
	      /* Hit beginning of record log in reverse.  */
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
	      break;
	    }
	  if (execution_direction != EXEC_REVERSE && !record_list->next)
	    {
	      /* Hit end of record log going forward.  */
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
	      break;
	    }

	  /* set ptid, register and memory according to record_list */
	  if (record_list->type == record_reg)
	    {
	      /* reg */
	      gdb_byte reg[MAX_REGISTER_SIZE];
	      if (record_debug > 1)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Process record: record_reg 0x%s to inferior num = %d.\n",
				      paddr_nz ((CORE_ADDR)record_list),
				      record_list->u.reg.num);
		}
	      regcache_cooked_read (regcache, record_list->u.reg.num, reg);
	      regcache_cooked_write (regcache, record_list->u.reg.num,
				     record_list->u.reg.val);
	      memcpy (record_list->u.reg.val, reg, MAX_REGISTER_SIZE);
	    }
	  else if (record_list->type == record_mem)
	    {
	      /* mem */
	      gdb_byte *mem = alloca (record_list->u.mem.len);
	      if (record_debug > 1)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Process record: record_mem 0x%s to inferior addr = 0x%s len = %d.\n",
				      paddr_nz ((CORE_ADDR)record_list),
				      paddr_nz (record_list->u.mem.addr),
				      record_list->u.mem.len);
		}
	      if (target_read_memory
		  (record_list->u.mem.addr, mem, record_list->u.mem.len))
		{
		  error (_("Process record: error reading memory at addr = 0x%s len = %d."),
			 paddr_nz (record_list->u.mem.addr),
			 record_list->u.mem.len);
		}
	      if (target_write_memory
		  (record_list->u.mem.addr, record_list->u.mem.val,
		   record_list->u.mem.len))
		{
		  error (_
			 ("Process record: error writing memory at addr = 0x%s len = %d."),
			 paddr_nz (record_list->u.mem.addr),
			 record_list->u.mem.len);
		}
	      memcpy (record_list->u.mem.val, mem, record_list->u.mem.len);
	    }
	  else
	    {
	      if (record_debug > 1)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Process record: record_end 0x%s to inferior need_dasm = %d.\n",
				      paddr_nz ((CORE_ADDR)record_list),
				      record_list->u.need_dasm);
		}

	      if (execution_direction == EXEC_FORWARD)
		{
		  need_dasm = record_list->u.need_dasm;
		}
	      if (need_dasm)
		{
		  gdbarch_process_record_dasm (current_gdbarch);
		}

	      if (first_record_end && execution_direction == EXEC_REVERSE)
		{
		  /* When reverse excute, the first record_end is the part of
		     current instruction.  */
		  first_record_end = 0;
		}
	      else
		{
		  /* In EXEC_REVERSE mode, this is the record_end of prev
		     instruction.
		     In EXEC_FORWARD mode, this is the record_end of current
		     instruction.  */
		  /* step */
		  if (record_resume_step)
		    {
		      if (record_debug > 1)
			{
			  fprintf_unfiltered (gdb_stdlog, "Process record: step.\n");
			}
		      continue_flag = 0;
		    }

		  /* check breakpoint */
		  tmp_pc = regcache_read_pc (regcache);
		  if (breakpoint_inserted_here_p (tmp_pc))
		    {
		      if (record_debug)
			{
			  fprintf_unfiltered (gdb_stdlog,
					      "Process record: break at 0x%s.\n",
					      paddr_nz (tmp_pc));
			}
		      if (gdbarch_decr_pc_after_break (get_regcache_arch (regcache))
			  && execution_direction == EXEC_FORWARD
			  && !record_resume_step)
 			{
			  regcache_write_pc (regcache,
					     tmp_pc +
					     gdbarch_decr_pc_after_break
					     (get_regcache_arch (regcache)));
 			}
		      continue_flag = 0;
		    }
		}
	      if (execution_direction == EXEC_REVERSE)
		{
		  need_dasm = record_list->u.need_dasm;
		}
	    }

next:
	  if (continue_flag)
	    {
	      if (execution_direction == EXEC_REVERSE)
		{
		  if (record_list->prev)
		    record_list = record_list->prev;
		}
	      else
		{
		  if (record_list->next)
		    record_list = record_list->next;
		}
	    }
	}
      while (continue_flag);

      if (sigaction (SIGALRM, &old_act, NULL))
	{
	  perror_with_name (_("Process record: sigaction failed"));
	}

replay_out:
      if (record_get_sig)
	{
	  status->value.sig = TARGET_SIGNAL_INT;
	}
      else
	{
	  status->value.sig = TARGET_SIGNAL_TRAP;
	}

      discard_cleanups (old_cleanups);
    }

  return inferior_ptid;
}

static void
record_disconnect (struct target_ops *target, char *args, int from_tty)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Process record: record_disconnect\n");
    }
  unpush_target (&record_ops);
  target_disconnect (args, from_tty);
}

static void
record_detach (struct target_ops *ops, char *args, int from_tty)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Process record: record_detach\n");
    }
  unpush_target (&record_ops);
  target_detach (args, from_tty);
}

static void
record_mourn_inferior (struct target_ops *ops)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Process record: record_mourn_inferior\n");
    }
  unpush_target (&record_ops);
  target_mourn_inferior ();
}

/* Close process record target before kill the inferior process.  */
static void
record_kill (void)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Process record: record_kill\n");
    }
  unpush_target (&record_ops);
  target_kill ();
}

/* Record registers change (by user or by GDB) to list as an instruction.  */
static void
record_registers_change (struct regcache *regcache, int regnum)
{
  /* Check record_insn_num.  */
  record_check_insn_num (0);

  record_arch_list_head = NULL;
  record_arch_list_tail = NULL;

  record_regcache = get_current_regcache ();

  if (regnum < 0)
    {
      int i;
      for (i = 0; i < gdbarch_num_regs (get_regcache_arch (regcache)); i++)
	{
	  if (record_arch_list_add_reg (i))
	    {
	      record_list_release (record_arch_list_tail);
	      error (_("Process record: failed to record execution log."));
	    }
	}
    }
  else
    {
      if (record_arch_list_add_reg (regnum))
	{
	  record_list_release (record_arch_list_tail);
	  error (_("Process record: failed to record execution log."));
	}
    }
  if (record_arch_list_add_end (0))
    {
      record_list_release (record_arch_list_tail);
      error (_("Process record: failed to record execution log."));
    }
  record_list->next = record_arch_list_head;
  record_arch_list_head->prev = record_list;
  record_list = record_arch_list_tail;

  if (record_insn_num == record_insn_max_num && record_insn_max_num)
    {
      record_list_release_first ();
    }
  else
    {
      record_insn_num++;
    }
}

static void
record_store_registers (struct regcache *regcache, int regno)
{
  if (!record_not_record)
    {
      if (RECORD_IS_REPLAY)
	{
	  int n;
	  struct cleanup *old_cleanups;

	  /* Let user choice if he want to write register or not.  */
	  if (regno < 0)
	    {
	      n =
		nquery (_
			("Becuse GDB is in replay mode, changing the value of a register will make the execute log unusable from this point onward.  Change all register?"));
	    }
	  else
	    {
	      n =
		nquery (_
			("Becuse GDB is in replay mode, changing the value of a register will make the execute log unusable from this point onward.  Change register %s?"),
			gdbarch_register_name (get_regcache_arch (regcache),
					       regno));
	    }

	  if (!n)
	    {
	      /* Invalidate the value of regcache that set in function
	         "regcache_raw_write".  */
	      if (regno < 0)
		{
		  int i;
		  for (i = 0;
		       i < gdbarch_num_regs (get_regcache_arch (regcache));
		       i++)
		    {
		      regcache_invalidate (regcache, i);
		    }
		}
	      else
		{
		  regcache_invalidate (regcache, regno);
		}

	      error (_("Process record canceled the operation."));
	    }

	  /* Destroy the record from here forward.  */
	  record_list_release_next ();
	}

      record_registers_change (regcache, regno);
    }
  record_beneath_to_store_registers (regcache, regno);
}

/* record_xfer_partial -- behavior is conditional on RECORD_IS_REPLAY.
   In replay mode, we cannot write memory unles we are willing to
   invalidate the record/replay log from this point forward.  */

static LONGEST
record_xfer_partial (struct target_ops *ops, enum target_object object,
		     const char *annex, gdb_byte * readbuf,
		     const gdb_byte * writebuf, ULONGEST offset, LONGEST len)
{
  if (!record_not_record
      && (object == TARGET_OBJECT_MEMORY
	  || object == TARGET_OBJECT_RAW_MEMORY) && writebuf)
    {
      if (RECORD_IS_REPLAY)
	{
	  /* Let user choice if he want to write memory or not.  */
	  if (!nquery (_("Because GDB is in replay mode, writing to memory will make the execute log unusable from this point onward.  Write memory at address 0x%s?"),
		       paddr_nz (offset)))
	    {
	      return -1;
	    }

	  /* Destroy the record from here forward.  */
	  record_list_release_next ();
	}

      /* Check record_insn_num */
      record_check_insn_num (0);

      /* Record registers change to list as an instruction.  */
      record_arch_list_head = NULL;
      record_arch_list_tail = NULL;
      if (record_arch_list_add_mem (offset, len))
	{
	  record_list_release (record_arch_list_tail);
	  if (record_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  _
				  ("Process record: failed to record execution log."));
	    }
	  return -1;
	}
      if (record_arch_list_add_end (0))
	{
	  record_list_release (record_arch_list_tail);
	  if (record_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  _
				  ("Process record: failed to record execution log."));
	    }
	  return -1;
	}
      record_list->next = record_arch_list_head;
      record_arch_list_head->prev = record_list;
      record_list = record_arch_list_tail;

      if (record_insn_num == record_insn_max_num && record_insn_max_num)
	{
	  record_list_release_first ();
	}
      else
	{
	  record_insn_num++;
	}
    }

  return record_beneath_to_xfer_partial (ops, object, annex, readbuf,
					 writebuf, offset, len);
}

/* record_insert_breakpoint
   record_remove_breakpoint
   Behavior is conditional on RECORD_IS_REPLAY.
   We will not actually insert or remove breakpoints when replaying.  */

static int
record_insert_breakpoint (struct bp_target_info *bp_tgt)
{
  if (!RECORD_IS_REPLAY)
    {
      return record_beneath_to_insert_breakpoint (bp_tgt);
    }

  return 0;
}

static int
record_remove_breakpoint (struct bp_target_info *bp_tgt)
{
  if (!RECORD_IS_REPLAY)
    {
      return record_beneath_to_remove_breakpoint (bp_tgt);
    }

  return 0;
}

static int
record_can_execute_reverse (void)
{
  return 1;
}

static void
init_record_ops (void)
{
  record_ops.to_shortname = "record";
  record_ops.to_longname = "Process record and replay target";
  record_ops.to_doc =
    "Log program while executing and replay execution from log.";
  record_ops.to_open = record_open;
  record_ops.to_close = record_close;
  record_ops.to_resume = record_resume;
  record_ops.to_wait = record_wait;
  record_ops.to_disconnect = record_disconnect;
  record_ops.to_detach = record_detach;
  record_ops.to_mourn_inferior = record_mourn_inferior;
  record_ops.to_kill = record_kill;
  record_ops.to_create_inferior = find_default_create_inferior;	/* Make record suppport command "run".  */
  record_ops.to_store_registers = record_store_registers;
  record_ops.to_xfer_partial = record_xfer_partial;
  record_ops.to_insert_breakpoint = record_insert_breakpoint;
  record_ops.to_remove_breakpoint = record_remove_breakpoint;
  record_ops.to_can_execute_reverse = record_can_execute_reverse;
  record_ops.to_stratum = record_stratum;
  record_ops.to_magic = OPS_MAGIC;
}

static void
show_record_debug (struct ui_file *file, int from_tty,
		   struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Debugging of process record target is %s.\n"), value);
}

/* cmd_record_start -- alias for "target record".  */

static void
cmd_record_start (char *args, int from_tty)
{
  execute_command ("target record", from_tty);
}

/* cmd_record_delete -- truncate the record log from the present point
   of replay until the end.  */

static void
cmd_record_delete (char *args, int from_tty)
{
  if (RECORD_IS_USED)
    {
      if (RECORD_IS_REPLAY)
	{
	  if (!from_tty || query (_("Delete the log from this point forward and begin to record the running message at current PC?")))
	    {
	      record_list_release_next ();
	    }
	}
      else
	{
	  printf_unfiltered (_("Already at end of record list.\n"));
	}

    }
  else
    {
      printf_unfiltered (_("Process record is not started.\n"));
    }
}

/* cmd_record_stop -- implement the "stoprecord" command.  */

static void
cmd_record_stop (char *args, int from_tty)
{
  if (RECORD_IS_USED)
    {
      if (!record_list || !from_tty || query (_("Delete recorded log and stop recording?")))
	{
	  unpush_target (&record_ops);
	}
    }
  else
    {
      printf_unfiltered (_("Process record is not started.\n"));
    }
}

/* set_record_insn_max_num -- set upper limit of record log size.  */

static void
set_record_insn_max_num (char *args, int from_tty, struct cmd_list_element *c)
{
  if (record_insn_num > record_insn_max_num && record_insn_max_num)
    {
      printf_unfiltered (_("Record instructions number is bigger than record instructions max number.  Auto delete the first ones?\n"));

      while (record_insn_num > record_insn_max_num)
	{
	  record_list_release_first ();
	}
    }
}

/* show_record_insn_number -- print the current index
   into the record log (number of insns recorded so far).  */

static void
show_record_insn_number (char *ignore, int from_tty)
{
  printf_unfiltered (_("Record instruction number is %d.\n"),
		     record_insn_num);
}

void
_initialize_record (void)
{
  /* Init record_maskall.  */
  if (sigfillset (&record_maskall) == -1)
    {
      perror_with_name (_("Process record: sigfillset failed"));
    }

  /* Init record_first.  */
  record_first.prev = NULL;
  record_first.next = NULL;
  record_first.type = record_end;
  record_first.u.need_dasm = 0;

  init_record_ops ();
  add_target (&record_ops);

  add_setshow_zinteger_cmd ("record", no_class, &record_debug,
			    _("Set debugging of record/replay feature."),
			    _("Show debugging of record/replay feature."),
			    _
			    ("When enabled, debugging output for record/replay feature is displayed."),
			    NULL, show_record_debug, &setdebuglist,
			    &showdebuglist);

  add_com ("record", class_obscure, cmd_record_start,
	   _("Abbreviated form of \"target record\" command."));

  add_com_alias ("rec", "record", class_obscure, 1);

  /* XXX: I try to use some simple commands such as "disconnect" and
     "detach" to support this functions.  But these commands all have
     other affect to GDB such as call function "no_shared_libraries".
     So I add special commands to GDB.  */
  add_com ("delrecord", class_obscure, cmd_record_delete,
	   _("Delete the rest of execution log and start recording it anew."));
  add_com_alias ("dr", "delrecord", class_obscure, 1);
  add_com ("stoprecord", class_obscure, cmd_record_stop,
	   _("Stop the record/replay target."));
  add_com_alias ("sr", "stoprecord", class_obscure, 1);

  /* Record instructions number limit command.  */
  add_setshow_boolean_cmd ("record-stop-at-limit", no_class,
			    &record_stop_at_limit,
			    _("Set whether record/replay stop when record/replay buffer becomes full."),
			    _("Show whether record/replay stop when record/replay buffer becomes full."), _("\
Enable is default value.\n\
When enabled, if the record/replay buffer becomes full,\n\
ask user what to do.\n\
When disabled, if the record/replay buffer becomes full,\n\
delete it and start new recording."), NULL, NULL, &setlist, &showlist);
  add_setshow_zinteger_cmd ("record-insn-number-max", no_class,
			    &record_insn_max_num,
			    _("Set record/replay buffer limit."),
			    _("Show record/replay buffer limit."), _("\
Set the maximum number of instructions to be stored in the\n\
record/replay buffer.  Zero means unlimited (default 200000)."),
			    set_record_insn_max_num,
			    NULL, &setlist, &showlist);
  add_info ("record-insn-number", show_record_insn_number, _("\
Show the current number of instructions in the record/replay buffer."));
}
@


1.1.6.2
log
@2008-12-26  Michael Snyder  <msnyder@@vmware.com>

	* record.h: Don't export record_not_record.
	* infrun.c (proceed): Don't call record_not_record_set.
	* record.h (record_not_record): Rename to in_record_wait.
	(record_not_record_set): Rename to in_record_wait_set.
	(record_not_record_cleanup): Rename to in_record_wait_cleanup.
	(record_store_registers): Check in_record_wait flag.
	(record_xfer_partial): Ditto.
@
text
@d50 1
a50 1
static int in_record_wait = 0;
d367 2
a368 2
/* Things to clean up if we error or QUIT out of function that set
   in_record_wait (ie. command that called 'proceed').  */
d370 1
a370 1
in_record_wait_cleanups (void *ignore)
d372 1
a372 1
  in_record_wait = 0;
d376 1
a376 1
in_record_wait_set (void)
d378 2
a379 2
  struct cleanup *old_cleanups = make_cleanup (in_record_wait_cleanups, 0);
  in_record_wait = 1;
a485 1
  in_record_wait_set ();
a698 1
	      /* MVS: This step fetches the reg from the target.  */
a699 1
	      /* MVS: This step writes the execution log reg to the target.  */
a701 1
	      /* MVS: And this step saves the target reg in the exec log.  */
a702 1
	      /* MVS: Net result -- swap.  */
a715 2

	      /* MVS: This step fetches 'mem' from the target.  */
a722 2

	      /* MVS: This step writes from the exec log to the target.  */
a731 1
	      /* MVS: And this step writes target 'mem' to the exec log.  */
a732 1
	      /* MVS: Net result: swap.  */
d940 1
a940 1
  if (!in_record_wait)
d1003 1
a1003 1
  if (!in_record_wait
d1061 1
d1074 1
a1074 1
  if (!RECORD_IS_USED)
d1085 1
a1085 1
  if (!RECORD_IS_USED)
@


1.1.6.3
log
@2008-12-28  Michael Snyder  <msnyder@@vmware.com>

	* Comments, spelling, white space clean-ups.
@
text
@d295 1
a295 1
	  /* Ask user what to do.  */
d301 1
a301 1
	      q = yquery (_("Do you want to auto delete previous execution log entries when record/replay buffer becomes full (record-stop-at-limit)?"));
d368 1
a368 1
   in_record_wait (ie. command that caused target_wait to be called).  */
d409 1
a409 1
  /* Check if record target is already running.  */
d585 3
a587 3
		  /* Add gdbarch_decr_pc_after_break to pc because gdb will
		     expect the pc to be at address plus decr_pc_after_break
		     when the inferior stops at a breakpoint.  */
d656 3
a658 3
      /* If GDB is in terminal_inferior mode, it will not get the signal.
         And in GDB replay mode, GDB doesn't need to be in terminal_inferior
         mode, because inferior will not executed.
d662 1
a662 1
      /* In EXEC_FORWARD mode, record_list points to the tail of prev
d688 1
a688 1
	  /* Set ptid, register and memory according to record_list.  */
d700 1
d702 1
d705 1
d707 1
d722 1
d731 1
d741 1
d743 1
d781 1
a781 2
			  fprintf_unfiltered (gdb_stdlog, 
					      "Process record: step.\n");
d885 1
a885 1
/* Close process record target before killing the inferior process.  */
d958 1
a958 1
	  /* Let user choose if he wants to write register or not.  */
d963 1
a963 1
			("Because GDB is in replay mode, changing the value of a register will make the execution log unusable from this point onward.  Change all registers?"));
d969 1
a969 1
			("Because GDB is in replay mode, changing the value of a register will make the execution log unusable from this point onward.  Change register %s?"),
d976 1
a976 1
	      /* Invalidate the value of regcache that was set in function
d1020 2
a1021 2
	  /* Let user choose if he wants to write memory or not.  */
	  if (!nquery (_("Because GDB is in replay mode, writing to memory will make the execution log unusable from this point onward.  Write memory at address 0x%s?"),
d1078 2
a1079 3
   Behavior is conditional on RECORD_IS_USED.
   We will not actually insert or remove breakpoints when replaying,
   nor when recording.  */
d1124 1
a1124 1
  record_ops.to_create_inferior = find_default_create_inferior;	/* Make record support command "run".  */
d1138 1
a1138 2
  fprintf_filtered (file, _("Debugging of process record target is %s.\n"), 
		    value);
@


1.1.6.4
log
@Change "RECORD_IS_USED" to "TARGET_IS_PROCESS_RECORD".
@
text
@d410 1
a410 1
  if (TARGET_IS_PROCESS_RECORD)
d513 1
a513 1
	      CORE_ADDR pc = 0;
d1071 1
a1071 1
   Behavior is conditional on TARGET_IS_PROCESS_RECORD.
d1078 1
a1078 1
  if (!TARGET_IS_PROCESS_RECORD)
d1089 1
a1089 1
  if (!TARGET_IS_PROCESS_RECORD)
d1150 1
a1150 1
  if (TARGET_IS_PROCESS_RECORD)
d1176 1
a1176 1
  if (TARGET_IS_PROCESS_RECORD)
@


1.1.6.5
log
@Add a debug message to function "record_arch_list_add".
@
text
@a175 7
  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Process record: record_arch_list_add 0x%s.\n",
			  paddr_nz ((CORE_ADDR)rec));
    }

@


1.1.4.1
log
@2008-09-30  Hui Zhu  <teawater@@gmail.com>
	Add process record and replay to GDB.
	* record.c, record.h: New files. Record and reverse target.
	* gdbarch.sh: New methods process_record and process_record_dasm.
	* gdbarch.c, gdbarch.h: Re-generate.
	* target.h (enum strata): Add record_stratum.
	* target.h (target_ops): Add a element "to_support_record_wait".
	Default value is 0. meaning that this target doesn't support record
	wait.
	* target.c: Add include of "record.h".
	(update_current_target): Set the real beneath function.
	(add_target): Set the default value of "to_support_record_wait".
	pointers.
 	* Makefile.in: Add files record.c, record.o.
@
text
@a0 1123
/* Record and reverse target for GDB, the GNU debugger.

   Copyright (C) 2008 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "target.h"
#include "gdbcmd.h"
#include "regcache.h"
#include "inferior.h"
#include "gdbthread.h"
#include "record.h"

#include <signal.h>

#define DEFAULT_RECORD_INSN_MAX_NUM	200000

int record_debug = 0;

record_t record_first;
record_t *record_list = &record_first;
record_t *record_arch_list_head = NULL;
record_t *record_arch_list_tail = NULL;
struct regcache *record_regcache = NULL;

/* 0 ask user. 1 auto delete the last record_t.  */
static int record_insn_max_mode = 0;
static int record_insn_max_num = DEFAULT_RECORD_INSN_MAX_NUM;
static int record_insn_num = 0;

struct target_ops record_ops;
int record_resume_step = 0;
enum exec_direction_kind record_execdir = EXEC_FORWARD;
int record_linux_async_permitted = 0;
static int record_get_sig = 0;
static sigset_t record_maskall;
static int record_not_record = 0;
int record_regcache_raw_write_regnum = 0;
int record_will_store_registers = 0;

extern struct bp_location *bp_location_chain;

/* The real beneath function pointers.  */
void (*record_beneath_to_resume) (ptid_t, int, enum target_signal);
ptid_t (*record_beneath_to_wait) (ptid_t, struct target_waitstatus *);
void (*record_beneath_to_prepare_to_store) (struct regcache *);
LONGEST (*record_beneath_to_xfer_partial) (struct target_ops * ops,
					   enum target_object object,
					   const char *annex,
					   gdb_byte * readbuf,
					   const gdb_byte * writebuf,
					   ULONGEST offset, LONGEST len);
int (*record_beneath_to_insert_breakpoint) (struct bp_target_info *);
int (*record_beneath_to_remove_breakpoint) (struct bp_target_info *);

static void
record_list_release (record_t * rec)
{
  record_t *tmp;

  if (!rec)
    return;

  while (rec->next)
    {
      rec = rec->next;
    }

  while (rec->prev)
    {
      tmp = rec;
      rec = rec->prev;
      if (tmp->type == record_reg)
	{
	  xfree (tmp->u.reg.val);
	}
      else if (tmp->type == record_mem)
	{
	  xfree (tmp->u.mem.val);
	}
      xfree (tmp);
    }

  if (rec != &record_first)
    {
      xfree (rec);
    }
}

static void
record_list_release_next (void)
{
  record_t *rec = record_list;
  record_t *tmp = rec->next;
  rec->next = NULL;
  while (tmp)
    {
      rec = tmp->next;
      if (tmp->type == record_reg)
	{
	  record_insn_num--;
	}
      else if (tmp->type == record_reg)
	{
	  xfree (tmp->u.reg.val);
	}
      else if (tmp->type == record_mem)
	{
	  xfree (tmp->u.mem.val);
	}
      xfree (tmp);
      tmp = rec;
    }
}

static void
record_list_release_first (void)
{
  record_t *tmp = NULL;
  enum record_type type;

  if (!record_first.next)
    {
      return;
    }

  while (1)
    {
      type = record_first.next->type;

      if (type == record_reg)
	{
	  xfree (record_first.next->u.reg.val);
	}
      else if (type == record_mem)
	{
	  xfree (record_first.next->u.mem.val);
	}
      tmp = record_first.next;
      record_first.next = tmp->next;
      xfree (tmp);

      if (!record_first.next)
	{
	  gdb_assert (record_insn_num == 1);
	  break;
	}

      record_first.next->prev = &record_first;

      if (type == record_end)
	{
	  break;
	}
    }

  record_insn_num--;
}

/* Add a record_t to record_arch_list.  */
static void
record_arch_list_add (record_t * rec)
{
  if (record_arch_list_tail)
    {
      record_arch_list_tail->next = rec;
      rec->prev = record_arch_list_tail;
      record_arch_list_tail = rec;
    }
  else
    {
      record_arch_list_head = rec;
      record_arch_list_tail = rec;
    }
}

/* Record the value of a register ("num") to record_arch_list.  */
int
record_arch_list_add_reg (int num)
{
  record_t *rec;

  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Record: add register num = %d to record list.\n", 
			  num);
    }

  rec = (record_t *) xmalloc (sizeof (record_t));
  rec->u.reg.val = (gdb_byte *) xmalloc (MAX_REGISTER_SIZE);
  rec->prev = NULL;
  rec->next = NULL;
  rec->type = record_reg;
  rec->u.reg.num = num;

  regcache_raw_read (record_regcache, num, rec->u.reg.val);

  record_arch_list_add (rec);

  return (0);
}

/* Record the value of a region of memory whose address is "addr" and
   length is "len" to record_arch_list.  */

int
record_arch_list_add_mem (CORE_ADDR addr, int len)
{
  record_t *rec;

  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Record: add mem addr = 0x%s len = %d to record list.\n",
			  paddr_nz (addr), len);
    }

  if (!addr)
    {
      return (0);
    }

  rec = (record_t *) xmalloc (sizeof (record_t));
  rec->u.mem.val = (gdb_byte *) xmalloc (len);
  rec->prev = NULL;
  rec->next = NULL;
  rec->type = record_mem;
  rec->u.mem.addr = addr;
  rec->u.mem.len = len;

  if (target_read_memory (addr, rec->u.mem.val, len))
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Record: read memory addr = 0x%s len = %d error.\n",
			  paddr_nz (addr), len);
      xfree (rec->u.mem.val);
      xfree (rec);
      return (-1);
    }

  record_arch_list_add (rec);

  return (0);
}

/* Add a record_end type record_t to record_arch_list.  */
int
record_arch_list_add_end (int need_dasm)
{
  record_t *rec;

  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Record: add end need_dasm = %d to arch list.\n",
			  need_dasm);
    }

  rec = (record_t *) xmalloc (sizeof (record_t));
  rec->prev = NULL;
  rec->next = NULL;
  rec->type = record_end;

  rec->u.need_dasm = need_dasm;

  record_arch_list_add (rec);

  return (0);
}

static void
record_check_insn_num (int set_terminal)
{
  if (record_insn_max_num)
    {
      gdb_assert (record_insn_num <= record_insn_max_num);
      if (record_insn_num == record_insn_max_num)
	{
	  /* Ask user how to do */
	  if (!record_insn_max_mode)
	    {
	      int q;
	      if (set_terminal)
		target_terminal_ours ();
	      q = yquery (_("The record instruction number (record-insn-number) is equal to record-insn-number-max.  Do you want to open auto delete first record_t function (record-auto-delete)?"));
	      if (set_terminal)
		target_terminal_inferior ();
	      if (q)
		{
		  record_insn_max_mode = 1;
		}
	      else
		{
		  error (_("Record: record stop the program."));
		}
	    }
	}
    }
}

/* Before inferior step (when GDB record the running message, inferior
   only can step), GDB will call this function to record the values to
   record_list.  This function will call gdbarch_process_record to
   record the running message of inferior and set them to
   record_arch_list, and add it to record_list.  */

static void
record_message_cleanups (void *ignore)
{
  record_list_release (record_arch_list_tail);
  set_executing (inferior_ptid, 0);
  normal_stop ();
}

void
record_message (struct gdbarch *gdbarch)
{
  int ret;
  struct cleanup *old_cleanups = make_cleanup (record_message_cleanups, 0);

  /* Check record_insn_num.  */
  record_check_insn_num (1);

  record_arch_list_head = NULL;
  record_arch_list_tail = NULL;
  record_regcache = get_current_regcache ();

  ret = gdbarch_process_record (gdbarch, 
				regcache_read_pc (record_regcache));
  if (ret > 0)
    error (_("Record: record pause the program."));
  if (ret < 0)
    error (_("Record: record message error."));

  discard_cleanups (old_cleanups);

  record_list->next = record_arch_list_head;
  record_arch_list_head->prev = record_list;
  record_list = record_arch_list_tail;

  if (record_insn_num == record_insn_max_num && record_insn_max_num)
    {
      record_list_release_first ();
    }
  else
    {
      record_insn_num++;
    }
}

/* Things to clean up if we QUIT out of function that set
   record_not_record.  */
static void
record_not_record_cleanups (void *ignore)
{
  record_not_record = 0;
}

void
record_not_record_set (void)
{
  struct cleanup *old_cleanups = make_cleanup (record_not_record_cleanups, 0);
  record_not_record = 1;
}

static void
record_open (char *name, int from_tty)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: record_open\n");
    }

  /* check exec */
  if (!target_has_execution)
    {
      error (_("Record: the program is not being run."));
    }
  if (non_stop)
    {
      error (_("Record: record target can't debug inferior in non-stop mode (non-stop)."));
    }
  if (record_linux_async_permitted)
    {
      error (_("Record: record target can't debug the GNU/Linux inferior in asynchronous mode (linux-async)."));
    }

  if (!gdbarch_process_record_p (current_gdbarch))
    {
      error (_("Record: the current architecture doesn't support record function."));
    }

  /* Check if record target is already running */
  if (RECORD_IS_USED)
    {
      if (!nquery
	  (_("Record target already running, do you want delete the old record log?")))
	{
	  return;
	}
    }

  /* Reset */
  record_insn_num = 0;
  record_execdir = EXEC_FORWARD;
  record_list = &record_first;
  record_list->next = NULL;

  push_target (&record_ops);
}

static void
record_close (int quitting)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: record_close\n");
    }
  record_list_release (record_list);
}

static void
record_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  record_resume_step = step;

  if (!RECORD_IS_REPLAY)
    {
      record_message (current_gdbarch);
      record_beneath_to_resume (ptid, 1, siggnal);
    }
}

static void
record_sig_handler (int signo)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: get a signal\n");
    }
  record_resume_step = 1;
  record_get_sig = 1;
}

static void
record_wait_cleanups (void *ignore)
{
  if (record_execdir == EXEC_REVERSE)
    {
      if (record_list->next)
	{
	  record_list = record_list->next;
	}
    }
  else
    {
      record_list = record_list->prev;
    }
  set_executing (inferior_ptid, 0);
  normal_stop ();
}

/* record_wait
   In replay mode, this function examines the recorded log and
   determines where to stop.  */

static ptid_t
record_wait (ptid_t ptid, struct target_waitstatus *status)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Record: record_wait record_resume_step = %d\n",
			  record_resume_step);
    }

  if (!RECORD_IS_REPLAY)
    {
      return record_beneath_to_wait (ptid, status);
    }
  else
    {
      struct sigaction act, old_act;
      int need_dasm = 0;
      struct regcache *regcache = get_current_regcache ();
      int continue_flag = 1;
      int first_record_end = 1;
      struct cleanup *old_cleanups = make_cleanup (record_wait_cleanups, 0);

      record_get_sig = 0;
      act.sa_handler = record_sig_handler;
      act.sa_mask = record_maskall;
      act.sa_flags = SA_RESTART;
      if (sigaction (SIGINT, &act, &old_act))
	{
	  perror_with_name (_("Record: sigaction"));
	}
      /* If GDB is in terminal_inferior, it will not get the signal.
         And in GDB replay mode, GDB don't need to in terminal_inferior
         because inferior will not executed.
         Then set it to terminal_ours to make GDB get the signal.  */
      target_terminal_ours ();

      /* In EXEC_FORWARD mode, record_list point to the tail of prev
         instruction.  */
      if (record_execdir == EXEC_FORWARD && record_list->next)
        {
	  record_list = record_list->next;
	}

      /* Loop over the record_list, looking for the next place to
	 stop.  */
      status->kind = TARGET_WAITKIND_STOPPED;
      do
	{
	  /* Check for beginning and end of log.  */
	  if (record_execdir == EXEC_REVERSE 
	      && record_list == &record_first)
	    {
	      /* Hit beginning of record log in reverse.  */
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
	      break;
	    }
	  if (record_execdir != EXEC_REVERSE && !record_list->next)
	    {
	      /* Hit end of record log going forward.  */
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
	      break;
	    }

	  /* set ptid, register and memory according to record_list */
	  if (record_list->type == record_reg)
	    {
	      /* reg */
	      gdb_byte reg[MAX_REGISTER_SIZE];
	      if (record_debug > 1)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Record: record_reg 0x%s to inferior num = %d.\n",
				      paddr_nz ((CORE_ADDR)record_list),
				      record_list->u.reg.num);
		}
	      regcache_cooked_read (regcache, record_list->u.reg.num, reg);
	      regcache_cooked_write (regcache, record_list->u.reg.num,
				     record_list->u.reg.val);
	      memcpy (record_list->u.reg.val, reg, MAX_REGISTER_SIZE);
	    }
	  else if (record_list->type == record_mem)
	    {
	      /* mem */
	      gdb_byte *mem = alloca (record_list->u.mem.len);
	      if (record_debug > 1)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Record: record_mem 0x%s to inferior addr = 0x%s len = %d.\n",
				      paddr_nz ((CORE_ADDR)record_list),
				      paddr_nz (record_list->u.mem.addr),
				      record_list->u.mem.len);
		}
	      if (target_read_memory
		  (record_list->u.mem.addr, mem, record_list->u.mem.len))
		{
		  error (_("Record: read memory addr = 0x%s len = %d error."),
			 paddr_nz (record_list->u.mem.addr),
			 record_list->u.mem.len);
		}
	      if (target_write_memory
		  (record_list->u.mem.addr, record_list->u.mem.val,
		   record_list->u.mem.len))
		{
		  error (_
			 ("Record: write memory addr = 0x%s len = %d error."),
			 paddr_nz (record_list->u.mem.addr),
			 record_list->u.mem.len);
		}
	      memcpy (record_list->u.mem.val, mem, record_list->u.mem.len);
	    }
	  else
	    {
	      CORE_ADDR tmp_pc;
	      struct bp_location *bl;
	      struct breakpoint *b;

	      if (record_debug > 1)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Record: record_end 0x%s to inferior need_dasm = %d.\n",
				      paddr_nz ((CORE_ADDR)record_list),
				      record_list->u.need_dasm);
		}

	      if (record_execdir == EXEC_FORWARD)
		{
		  need_dasm = record_list->u.need_dasm;
		}
	      if (need_dasm)
		{
		  gdbarch_process_record_dasm (current_gdbarch);
		}

	      if (first_record_end && record_execdir == EXEC_REVERSE)
		{
		  /* When reverse excute, the first record_end is the part of
		     current instruction. */
		  first_record_end = 0;
		}
	      else
		{
		  /* In EXEC_REVERSE mode, this is the record_end of prev
		     instruction.
		     In EXEC_FORWARD mode, this is the record_end of current
		     instruction.  */
		  /* step */
		  if (record_resume_step)
		    {
		      if (record_debug > 1)
			{
			  fprintf_unfiltered (gdb_stdlog, "Record: step.\n");
			}
		      continue_flag = 0;
		    }

		  /* check breakpoint */
		  tmp_pc = read_pc ();
		  for (bl = bp_location_chain; bl; bl = bl->global_next)
		    {
		      b = bl->owner;
		      gdb_assert (b);
		      if (b->enable_state != bp_enabled
			  && b->enable_state != bp_permanent)
			continue;

		      if (b->type == bp_watchpoint || b->type == bp_catch_fork
			  || b->type == bp_catch_vfork
			  || b->type == bp_catch_exec
			  || b->type == bp_hardware_watchpoint
			  || b->type == bp_read_watchpoint
			  || b->type == bp_access_watchpoint)
			{
			  continue;
			}
		      if (bl->address == tmp_pc)
			{
			  if (record_debug)
			    {
			      fprintf_unfiltered (gdb_stdlog,
						  "Record: break at 0x%s.\n",
						  paddr_nz (tmp_pc));
			    }
			  continue_flag = 0;
			  break;
			}
		    }
		}
	      if (record_execdir == EXEC_REVERSE)
		{
		  need_dasm = record_list->u.need_dasm;
		}
	    }

next:
	  if (continue_flag)
	    {
	      if (record_execdir == EXEC_REVERSE)
		{
		  if (record_list->prev)
		    record_list = record_list->prev;
		}
	      else
		{
		  if (record_list->next)
		    record_list = record_list->next;
		}
	    }
	}
      while (continue_flag);

      if (sigaction (SIGALRM, &old_act, NULL))
	{
	  perror_with_name (_("Record: sigaction"));
	}

      if (record_get_sig)
	{
	  status->value.sig = TARGET_SIGNAL_INT;
	}
      else
	{
	  status->value.sig = TARGET_SIGNAL_TRAP;
	}

      discard_cleanups (old_cleanups);
    }

  return inferior_ptid;
}

static void
record_disconnect (struct target_ops *target, char *args, int from_tty)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: record_disconnect\n");
    }
  unpush_target (&record_ops);
  target_disconnect (args, from_tty);
}

static void
record_detach (char *args, int from_tty)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: record_detach\n");
    }
  unpush_target (&record_ops);
  target_detach (args, from_tty);
}

static void
record_mourn_inferior (void)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: record_mourn_inferior\n");
    }
  unpush_target (&record_ops);
  target_mourn_inferior ();
}

/* Close record target before kill the inferior process.  */
static void
record_kill (void)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: record_kill\n");
    }
  unpush_target (&record_ops);
  target_kill ();
}

/* Record registers change (by user or by GDB) to list as an instruction.  */
static void
record_registers_change (struct regcache *regcache, int regnum)
{
  /* Check record_insn_num.  */
  record_check_insn_num (0);

  record_arch_list_head = NULL;
  record_arch_list_tail = NULL;

  record_regcache = get_current_regcache ();

  if (regnum < 0)
    {
      int i;
      for (i = 0; i < gdbarch_num_regs (get_regcache_arch (regcache)); i++)
	{
	  if (record_arch_list_add_reg (i))
	    {
	      record_list_release (record_arch_list_tail);
	      error (_("Record: record message error."));
	    }
	}
    }
  else
    {
      if (record_arch_list_add_reg (regnum))
	{
	  record_list_release (record_arch_list_tail);
	  error (_("Record: record message error."));
	}
    }
  if (record_arch_list_add_end (0))
    {
      record_list_release (record_arch_list_tail);
      error (_("Record: record message error."));
    }
  record_list->next = record_arch_list_head;
  record_arch_list_head->prev = record_list;
  record_list = record_arch_list_tail;

  if (record_insn_num == record_insn_max_num && record_insn_max_num)
    {
      record_list_release_first ();
    }
  else
    {
      record_insn_num++;
    }
}

/* XXX: I don't know how to do if GDB call function target_store_registers
   without call function target_prepare_to_store.  */

static void
record_prepare_to_store (struct regcache *regcache)
{
  if (!record_not_record)
    {
      if (RECORD_IS_REPLAY)
	{
	  struct cleanup *old_cleanups;
	  /* Let user choice if he want to write register or not.  */
	  if (!nquery (_("Becuse GDB is in replay mode, changing the value of a register will destroy the record from this point forward.  Change register %s?"),
		       gdbarch_register_name (get_regcache_arch
					      (regcache),
					      record_regcache_raw_write_regnum)))
	    {
	      error (_("Record: record cancel the operation."));
	    }

	  /* Destroy the record from here forward.  */
	  record_list_release_next ();
	}

      record_registers_change (regcache, record_regcache_raw_write_regnum);
    }
  record_beneath_to_prepare_to_store (regcache);
}

/* record_xfer_partial -- behavior is conditional on RECORD_IS_REPLAY.
   In replay mode, we cannot write memory unles we are willing to 
   invalidate the record/replay log from this point forward.  */

static LONGEST
record_xfer_partial (struct target_ops *ops, enum target_object object,
		     const char *annex, gdb_byte * readbuf,
		     const gdb_byte * writebuf, ULONGEST offset, LONGEST len)
{
  if (!record_not_record
      && (object == TARGET_OBJECT_MEMORY
	  || object == TARGET_OBJECT_RAW_MEMORY) && writebuf)
    {
      if (RECORD_IS_REPLAY)
	{
	  /* Let user choice if he want to write memory or not.  */
	  if (!nquery (_("Because GDB is in replay mode, writing to memory will destroy the record from this point forward.  Write memory at address 0x%s?"),
		       paddr_nz (offset)))
	    {
	      return -1;
	    }

	  /* Destroy the record from here forward.  */
	  record_list_release_next ();
	}

      /* Check record_insn_num */
      record_check_insn_num (0);

      /* Record registers change to list as an instruction.  */
      record_arch_list_head = NULL;
      record_arch_list_tail = NULL;
      if (record_arch_list_add_mem (offset, len))
	{
	  record_list_release (record_arch_list_tail);
	  fprintf_unfiltered (gdb_stdlog, _("Record: record message error."));
	  return -1;
	}
      if (record_arch_list_add_end (0))
	{
	  record_list_release (record_arch_list_tail);
	  fprintf_unfiltered (gdb_stdlog, _("Record: record message error."));
	  return -1;
	}
      record_list->next = record_arch_list_head;
      record_arch_list_head->prev = record_list;
      record_list = record_arch_list_tail;

      if (record_insn_num == record_insn_max_num && record_insn_max_num)
	{
	  record_list_release_first ();
	}
      else
	{
	  record_insn_num++;
	}
    }

  return record_beneath_to_xfer_partial (ops, object, annex, readbuf,
					 writebuf, offset, len);
}

/* record_insert_breakpoint
   record_remove_breakpoint
   Behavior is conditional on RECORD_IS_REPLAY.
   We will not actually insert or remove breakpoints when replaying.  */

static int
record_insert_breakpoint (struct bp_target_info *bp_tgt)
{
  if (!RECORD_IS_REPLAY)
    {
      return record_beneath_to_insert_breakpoint (bp_tgt);
    }

  return 0;
}

static int
record_remove_breakpoint (struct bp_target_info *bp_tgt)
{
  if (!RECORD_IS_REPLAY)
    {
      return record_beneath_to_remove_breakpoint (bp_tgt);
    }

  return 0;
}

static enum exec_direction_kind
record_get_execdir (void)
{
  if (record_debug > 1)
    printf_filtered ("Record: execdir is %s\n",
		     record_execdir == EXEC_FORWARD ? "forward" :
		     record_execdir == EXEC_REVERSE ? "reverse" : "unknown");
  return record_execdir;
}

static int
record_set_execdir (enum exec_direction_kind dir)
{
  if (record_debug)
    printf_filtered ("Record: set execdir: %s\n",
		     dir == EXEC_FORWARD ? "forward" :
		     dir == EXEC_REVERSE ? "reverse" : "bad direction");

  /* FIXME: check target for capability.  */
  if (dir == EXEC_FORWARD || dir == EXEC_REVERSE)
    return (record_execdir = dir);
  else
    return EXEC_ERROR;
}

static void
init_record_ops (void)
{
  record_ops.to_shortname = "record";
  record_ops.to_longname = "Record and reverse target";
  record_ops.to_doc =
    "Log program while executing and replay execution from log.";
  record_ops.to_open = record_open;
  record_ops.to_close = record_close;
  record_ops.to_resume = record_resume;
  record_ops.to_wait = record_wait;
  record_ops.to_disconnect = record_disconnect;
  record_ops.to_detach = record_detach;
  record_ops.to_mourn_inferior = record_mourn_inferior;
  record_ops.to_kill = record_kill;
  record_ops.to_create_inferior = find_default_create_inferior;	/* Make record suppport command "run".  */
  record_ops.to_prepare_to_store = record_prepare_to_store;
  record_ops.to_xfer_partial = record_xfer_partial;
  record_ops.to_insert_breakpoint = record_insert_breakpoint;
  record_ops.to_remove_breakpoint = record_remove_breakpoint;
  record_ops.to_get_execdir = record_get_execdir;
  record_ops.to_set_execdir = record_set_execdir;
  record_ops.to_stratum = record_stratum;
  record_ops.to_magic = OPS_MAGIC;
}

static void
show_record_debug (struct ui_file *file, int from_tty,
		   struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Debugging of record target is %s.\n"), value);
}

/* cmd_record_start -- alias for "target record".  */

static void
cmd_record_start (char *args, int from_tty)
{
  execute_command ("target record", from_tty);
}

/* cmd_record_delete -- truncate the record log from the present point
   of replay until the end.  */

static void
cmd_record_delete (char *args, int from_tty)
{
  if (RECORD_IS_USED)
    {
      if (RECORD_IS_REPLAY)
	{
	  if (!from_tty || query (_("Record: delete the log from this point forward and begin to record the running message at current PC?")))
	    {
	      record_list_release_next ();
	    }
	}
      else
	{
	  printf_unfiltered (_("Record: already at end of record list.\n"));
	}

    }
  else
    {
      printf_unfiltered (_("Record: record target is not started.\n"));
    }
}

/* cmd_record_stop -- implement the "stoprecord" command.  */

static void
cmd_record_stop (char *args, int from_tty)
{
  if (RECORD_IS_USED)
    {
      if (!record_list || !from_tty || query (_("Record: delete recorded log and stop recording?")))
	{
	  unpush_target (&record_ops);
	}
    }
  else
    {
      printf_unfiltered (_("Record: record target is not started.\n"));
    }
}

/* set_record_insn_max_num -- set upper limit of record log size.  */

static void
set_record_insn_max_num (char *args, int from_tty, struct cmd_list_element *c)
{
  if (record_insn_num > record_insn_max_num && record_insn_max_num)
    {
      printf_unfiltered (_("Record: record instructions number is bigger than record instructions max number.  Auto delete the first ones.\n"));

      while (record_insn_num > record_insn_max_num)
	{
	  record_list_release_first ();
	}
    }
}

/* show_record_insn_number -- print the current index
   into the record log (number of insns recorded so far).  */

static void
show_record_insn_number (char *ignore, int from_tty)
{
  printf_unfiltered (_("Record instruction number is %d.\n"),
		     record_insn_num);
}

void
_initialize_record (void)
{
  /* Init record_maskall.  */
  if (sigfillset (&record_maskall) == -1)
    {
      perror_with_name (_("Record: sigfillset"));
    }

  /* Init record_first.  */
  record_first.prev = NULL;
  record_first.next = NULL;
  record_first.type = record_end;
  record_first.u.need_dasm = 0;

  init_record_ops ();
  add_target (&record_ops);

  add_setshow_zinteger_cmd ("record", no_class, &record_debug,
			    _("Set debugging of record/replay feature."),
			    _("Show debugging of record/replay feature."),
			    _
			    ("When enabled, debugging output for record/replay feature is displayed."),
			    NULL, show_record_debug, &setdebuglist,
			    &showdebuglist);

  add_com ("record", class_obscure, cmd_record_start,
	   _("Abbreviated form of \"target record\" command."));

  add_com_alias ("rec", "record", class_obscure, 1);

  /* XXX: I try to use some simple commands such as "disconnect" and
     "detach" to support this functions.  But these commands all have
     other affect to GDB such as call function "no_shared_libraries".
     So I add special commands to GDB.  */
  add_com ("delrecord", class_obscure, cmd_record_delete,
	   _("When record target running in replay mode, delete the next running messages and begin to record the running message at current address."));
  add_com_alias ("dr", "delrecord", class_obscure, 1);
  add_com ("stoprecord", class_obscure, cmd_record_stop,
	   _("Stop the record/replay target."));
  add_com_alias ("sr", "stoprecord", class_obscure, 1);

  /* Record instructions number limit command.  */
  add_setshow_zinteger_cmd ("record-auto-delete", no_class,
			    &record_insn_max_mode,
			    _("Set record/replay auto delete mode."),
			    _("Show record/replay auto delete mode."), _("\
When enabled, if the record/replay buffer becomes full,\n\
delete it and start new recording."), NULL, NULL, &setlist, &showlist);
  add_setshow_zinteger_cmd ("record-insn-number-max", no_class,
			    &record_insn_max_num,
			    _("Set record/replay buffer limit."),
			    _("Show record/replay buffer limit."), _("\
Set the maximum number of instructions to be stored in the\n\
record/replay buffer.  Zero means unlimited (default 200000)."), 
			    set_record_insn_max_num, 
			    NULL, &setlist, &showlist);
  add_info ("record-insn-number", show_record_insn_number, _("\
Show the current number of instructions in the record/replay buffer."));
}
@


1.1.4.2
log
@2008-10-02  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_open): Call target_can_async_p() instead
	of relying on a global variable.
	* record.h (record_linux_async_permitted): Delete.
	* linux-nat.h (record_linux_async_permitted): Delete reference.
@
text
@d48 1
d398 1
a398 1
  if (target_async_permitted)
@


1.1.4.3
log
@2008-10-04  Michael Snyder  <msnyder@@vmware.com>

	* target.c, target.h: Rename execdir to exec_direction.
	* record.c, record.h: Ditto.
	* reverse.c: Ditto.
	* remote.c: Ditto.

	* reverse.c (show_exec_direction_func): Don't error, just inform.
@
text
@d47 1
a47 1
enum exec_direction_kind record_exec_direction = EXEC_FORWARD;
d419 1
a419 1
  record_exec_direction = EXEC_FORWARD;
d462 1
a462 1
  if (record_exec_direction == EXEC_REVERSE)
d520 1
a520 1
      if (record_exec_direction == EXEC_FORWARD && record_list->next)
d531 1
a531 1
	  if (record_exec_direction == EXEC_REVERSE 
d538 1
a538 1
	  if (record_exec_direction != EXEC_REVERSE && !record_list->next)
d606 1
a606 1
	      if (record_exec_direction == EXEC_FORWARD)
d615 1
a615 1
	      if (first_record_end && record_exec_direction == EXEC_REVERSE)
d669 1
a669 1
	      if (record_exec_direction == EXEC_REVERSE)
d678 1
a678 1
	      if (record_exec_direction == EXEC_REVERSE)
d927 1
a927 1
record_get_exec_direction (void)
d930 4
a933 5
    printf_filtered ("Record: exec direction is %s\n",
		     record_exec_direction == EXEC_FORWARD ? "forward" :
		     record_exec_direction == EXEC_REVERSE ? "reverse" : 
		     "unknown");
  return record_exec_direction;
d937 1
a937 1
record_set_exec_direction (enum exec_direction_kind dir)
d940 1
a940 1
    printf_filtered ("Record: set exec direction: %s\n",
d942 1
a942 2
		     dir == EXEC_REVERSE ? "reverse" : 
		     "bad direction");
d946 1
a946 1
    return (record_exec_direction = dir);
d971 2
a972 2
  record_ops.to_get_exec_direction = record_get_exec_direction;
  record_ops.to_set_exec_direction = record_set_exec_direction;
@


1.1.4.4
log
@2008-10-04  Hui Zhu  <teawater@@gmail.com>

	Change from "to_prepare_to_store" to "to_store_registers".
	* record.c (record_beneath_to_prepare_to_store): Removed.
	(record_beneath_to_store_registers): New function pointer.
	Instead "record_beneath_to_prepare_to_store". Will point
	to the low strata target "to_store_registers" function.
	(record_prepare_to_store): Removed.
	(record_store_registers): New function.
	Instead "record_prepare_to_store". Record the change of
	registers from GDB.
	(init_record_ops): Change record_prepare_to_store to
	record_store_registers.
	* record.h (record_beneath_to_prepare_to_store): Removed.
	(record_beneath_to_store_registers): New extern.
	(record_regcache_raw_write_regnum): Remove.
	* target.c (update_current_target): Change
	record_beneath_to_prepare_to_store to
	record_beneath_to_store_registers.
@
text
@d51 1
d59 1
a59 1
void (*record_beneath_to_store_registers) (struct regcache *, int regno);
d808 3
d812 1
a812 1
record_store_registers (struct regcache *regcache, int regno)
a817 1
	  int n;
a818 1

d820 4
a823 16
	  if (regno < 0)
	    {
	      n =
		nquery (_
			("Becuse GDB is in replay mode, changing the value of a register will destroy the record from this point forward. Change all register?"));
	    }
	  else
	    {
	      n =
		nquery (_
			("Becuse GDB is in replay mode, changing the value of a register will destroy the record from this point forward. Change register %s?"),
			gdbarch_register_name (get_regcache_arch (regcache),
					       regno));
	    }

	  if (!n)
a824 17
	      /* Invalidate the value of regcache that set in function
	         "regcache_raw_write". */
	      if (regno < 0)
		{
		  int i;
		  for (i = 0;
		       i < gdbarch_num_regs (get_regcache_arch (regcache));
		       i++)
		    {
		      regcache_invalidate (regcache, i);
		    }
		}
	      else
		{
		  regcache_invalidate (regcache, regno);
		}

d832 1
a832 1
      record_registers_change (regcache, regno);
d834 1
a834 1
  record_beneath_to_store_registers (regcache, regno);
d969 1
a969 1
  record_ops.to_store_registers = record_store_registers;
@


1.1.4.5
log
@2008-10-07  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c, infrun.c, linux-record.c, linux-record.h,
	record.c, record.h: Change name from
	"record and reverse target" to
	"process record and replay target".
@
text
@d1 1
a1 1
/* Process record and replay target for GDB, the GNU debugger.
d198 1
a198 1
			  "Process record: add register num = %d to record list.\n", 
d227 1
a227 1
			  "Process record: add mem addr = 0x%s len = %d to record list.\n",
d247 1
a247 1
			  "Process record: read memory addr = 0x%s len = %d error.\n",
d268 1
a268 1
			  "Process record: add end need_dasm = %d to arch list.\n",
d307 1
a307 1
		  error (_("Process record: record stop the program."));
d344 1
a344 1
    error (_("Process record pause the program."));
d346 1
a346 1
    error (_("Process record record message error."));
d384 1
a384 1
      fprintf_unfiltered (gdb_stdlog, "Process record: record_open\n");
d390 1
a390 1
      error (_("Process record: the program is not being run."));
d394 1
a394 1
      error (_("Process record target can't debug inferior in non-stop mode (non-stop)."));
d398 1
a398 1
      error (_("Process record target can't debug the GNU/Linux inferior in asynchronous mode (linux-async)."));
d403 1
a403 1
      error (_("Process record: the current architecture doesn't support record function."));
d410 1
a410 1
	  (_("Process record target already running, do you want delete the old record log?")))
d430 1
a430 1
      fprintf_unfiltered (gdb_stdlog, "Process record: record_close\n");
d452 1
a452 1
      fprintf_unfiltered (gdb_stdlog, "Process record: get a signal\n");
d486 1
a486 1
			  "Process record: record_wait record_resume_step = %d\n",
d509 1
a509 1
	  perror_with_name (_("Process record: sigaction"));
d552 1
a552 1
				      "Process record: record_reg 0x%s to inferior num = %d.\n",
d568 1
a568 1
				      "Process record: record_mem 0x%s to inferior addr = 0x%s len = %d.\n",
d576 1
a576 1
		  error (_("Process record: read memory addr = 0x%s len = %d error."),
d585 1
a585 1
			 ("Process record: write memory addr = 0x%s len = %d error."),
d600 1
a600 1
				      "Process record: record_end 0x%s to inferior need_dasm = %d.\n",
d631 1
a631 1
			  fprintf_unfiltered (gdb_stdlog, "Process record: step.\n");
d660 1
a660 1
						  "Process record: break at 0x%s.\n",
d693 1
a693 1
	  perror_with_name (_("Process record: sigaction"));
d716 1
a716 1
      fprintf_unfiltered (gdb_stdlog, "Process record: record_disconnect\n");
d727 1
a727 1
      fprintf_unfiltered (gdb_stdlog, "Process record: record_detach\n");
d738 1
a738 1
      fprintf_unfiltered (gdb_stdlog, "Process record: record_mourn_inferior\n");
d744 1
a744 1
/* Close process record target before kill the inferior process.  */
d750 1
a750 1
      fprintf_unfiltered (gdb_stdlog, "Process record: record_kill\n");
d776 1
a776 1
	      error (_("Process record: record message error."));
d785 1
a785 1
	  error (_("Process record: record message error."));
d791 1
a791 1
      error (_("Process record: record message error."));
d852 1
a852 1
	      error (_("Process record cancel the operation."));
d899 1
a899 1
	  fprintf_unfiltered (gdb_stdlog, _("Process record: record message error."));
d905 1
a905 1
	  fprintf_unfiltered (gdb_stdlog, _("Process record: record message error."));
d957 1
a957 1
    printf_filtered ("Process record: exec direction is %s\n",
d968 1
a968 1
    printf_filtered ("Process record: set exec direction: %s\n",
d984 1
a984 1
  record_ops.to_longname = "Process record and replay target";
d1010 1
a1010 1
  fprintf_filtered (file, _("Debugging of process record target is %s.\n"), value);
d1031 1
a1031 1
	  if (!from_tty || query (_("Process record: delete the log from this point forward and begin to record the running message at current PC?")))
d1038 1
a1038 1
	  printf_unfiltered (_("Process record: already at end of record list.\n"));
d1044 1
a1044 1
      printf_unfiltered (_("Process record is not started.\n"));
d1055 1
a1055 1
      if (!record_list || !from_tty || query (_("Process record: delete recorded log and stop recording?")))
d1062 1
a1062 1
      printf_unfiltered (_("Process record is not started.\n"));
d1073 1
a1073 1
      printf_unfiltered (_("Process record: record instructions number is bigger than record instructions max number.  Auto delete the first ones.\n"));
d1098 1
a1098 1
      perror_with_name (_("Process record: sigfillset"));
d1128 1
a1128 1
	   _("When process record target running in replay mode, delete the next running messages and begin to record the running message at current address."));
@


1.1.4.6
log
@2008-10-07  Michael Snyder  <msnyder@@vmware.com>

	* target.h (to_set_exec_direction, to_get_exec_direction): Remove.
	(to_can_execute_reverse): New method.
	(enum exec_direction_kind): Move to inferior.h.
	* target.c (update_current_target): Inherit to_can_execute_reverse.
	Remove to_set_exec_direction, to_get_exec_direction.
	* inferior.h (enum exec_direction_kind): Move from target.h.

	* infrun.c (set_exec_direction_func): Move here from reverse.c.
	(show_exec_direction_func): Ditto.
	(proceed): Consult global execution_direction instead of
	target method.
	(handle_inferior_event): Ditto.

	* reverse.c (set_exec_direction_func): Move to infrun.c
	(show_exec_direction_func): Ditto.
	(exec_direction_default): Set infrun global variable.
	(exec_reverse_once): Consult infrun global direction variable.

	* infcmd.c (step_1): Consult infrun global direction variable.
	(step_once): Ditto.
	(until_next_command): Ditto.
	(finish_command): Ditto.

	* record.h (record_exec_direction): Delete.
	(RECORD_IS_REPLAY): Consult infrun global direction variable.

	* record.c: (record_wait_cleanups): Use infrun state variable.
	(record_wait): Ditto.
	(record_get_exec_direction, record_set_exec_direction): Remove.
	(record_can_execute_reverse): New target method.

	* remote.c (remote_resume): Use infrun state variable.
	(remote_get_exec_direction, remote_set_exec_direction): Remove.
	(remote_can_execute_reverse): New target method.
@
text
@d47 1
d418 1
d461 1
a461 1
  if (execution_direction == EXEC_REVERSE)
d519 1
a519 1
      if (execution_direction == EXEC_FORWARD && record_list->next)
d530 1
a530 1
	  if (execution_direction == EXEC_REVERSE 
d537 1
a537 1
	  if (execution_direction != EXEC_REVERSE && !record_list->next)
d605 1
a605 1
	      if (execution_direction == EXEC_FORWARD)
d614 1
a614 1
	      if (first_record_end && execution_direction == EXEC_REVERSE)
d668 1
a668 1
	      if (execution_direction == EXEC_REVERSE)
d677 1
a677 1
	      if (execution_direction == EXEC_REVERSE)
d953 11
d965 1
a965 1
record_can_execute_reverse (void)
d967 11
a977 1
  return 1;
d1000 2
a1001 1
  record_ops.to_can_execute_reverse = record_can_execute_reverse;
@


1.1.4.7
log
@2008-10-08  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_open): Reset after push_target.
@
text
@a414 2
  push_target (&record_ops);

d419 2
@


1.1.4.8
log
@2008-10-15  Hui Zhu  <teawater@@gmail.com>

	Change "record-auto-delete" to "record-stop-at-limit".

	* record.c (record_insn_max_mode): Change to
	"record_stop_at_limit".
	(record_check_insn_num): Ditto.
	(_initialize_record): Ditto.
@
text
@d40 2
a41 2
/* 1 ask user. 0 auto delete the last record_t.  */
static int record_stop_at_limit = 1;
d292 1
a292 1
	  if (record_stop_at_limit)
d297 1
a297 1
	      q = yquery (_("The record instruction number (record-insn-number) is equal to record-insn-number-max.  Do you want to close record/replay stop when record/replay buffer becomes full(record-stop-at-limit) then auto delete first record_t?"));
d302 1
a302 1
		  record_stop_at_limit = 0;
d1111 5
a1115 8
  add_setshow_boolean_cmd ("record-stop-at-limit", no_class,
			    &record_stop_at_limit,
			    _("Set record/replay stop when record/replay buffer becomes full."),
			    _("Show record/replay stop when record/replay buffer becomes full."), _("\
Enable is default value.\n\
When enable, if the record/replay buffer becomes full,\n\
ask user how to do.\n\
When disable, if the record/replay buffer becomes full,\n\
@


1.1.4.9
log
@2008-11-05  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_wait): Check breakpint before forward
	execute in replay mode.
	Check breakpoint use function "breakpoint_inserted_here_p"
	in replay mode.
@
text
@a499 19
      CORE_ADDR tmp_pc;

      status->kind = TARGET_WAITKIND_STOPPED;

      /* Check breakpoint when forward execute.  */
      if (execution_direction == EXEC_FORWARD)
	{
	  tmp_pc = regcache_read_pc (regcache);
	  if (breakpoint_inserted_here_p (tmp_pc))
	    {
	      if (record_debug)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Process record: break at 0x%s.\n",
				      paddr_nz (tmp_pc));
		}
	      goto replay_out;
	    }
	}
d524 1
d591 4
d635 2
a636 2
		  tmp_pc = regcache_read_pc (regcache);
		  if (breakpoint_inserted_here_p (tmp_pc))
d638 12
a649 1
		      if (record_debug)
d651 12
a662 3
			  fprintf_unfiltered (gdb_stdlog,
					      "Process record: break at 0x%s.\n",
					      paddr_nz (tmp_pc));
a663 1
		      continue_flag = 0;
a693 1
replay_out:
@


1.1.4.10
log
@2008-11-06  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_wait): Set pc if forward execute,
	gdbarch_decr_pc_after_break is not 0 and this is not single
	step in replay mode.
	* linux-nat.c (my_waitpid_record): Add
	gdbarch_decr_pc_after_break to pc if need.
@
text
@a515 8
	      if (gdbarch_decr_pc_after_break (get_regcache_arch (regcache))
		  && !record_resume_step)
		{
		  regcache_write_pc (regcache,
				     tmp_pc +
				     gdbarch_decr_pc_after_break
				     (get_regcache_arch (regcache)));
		}
a657 9
		      if (gdbarch_decr_pc_after_break (get_regcache_arch (regcache))
			  && execution_direction == EXEC_FORWARD
			  && !record_resume_step)
 			{
			  regcache_write_pc (regcache,
					     tmp_pc +
					     gdbarch_decr_pc_after_break
					     (get_regcache_arch (regcache)));
 			}
@


1.1.2.1
log
@Add record target to GDB.
@
text
@a0 891
/* Record and reverse target for GDB, the GNU debugger.

   Copyright (C) 2008 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "target.h"
#include "gdbcmd.h"
#include "regcache.h"
#include "inferior.h"
#include "gdbthread.h"
#include "record.h"

#include <signal.h>

int record_debug = 0;
record_t record_first;
record_t *record_list = &record_first;
int record_list_status = 1;	/* 0 normal 1 to the begin 2 to the end */
record_t *record_arch_list_head = NULL;
record_t *record_arch_list_tail = NULL;
struct regcache *record_regcache = NULL;

struct target_ops record_ops;
int record_resume_step = 0;
enum exec_direction_kind record_execdir = EXEC_FORWARD;
static int record_get_sig = 0;
static sigset_t record_maskall;
static int record_not_record = 0;
int record_regcache_raw_write_regnum = 0;
int record_will_store_registers = 0;

extern struct bp_location *bp_location_chain;
extern ptid_t displaced_step_ptid;
extern CORE_ADDR displaced_step_original, displaced_step_copy;

static void
record_list_release (record_t * rec)
{
  record_t *tmp;

  if (!rec)
    return;

  while (rec->next)
    {
      rec = rec->next;
    }

  while (rec->prev)
    {
      tmp = rec;
      rec = rec->prev;
      if (tmp->type == record_reg)
	{
	  xfree (tmp->u.reg.val);
	}
      else if (tmp->type == record_mem)
	{
	  xfree (tmp->u.mem.val);
	}
      xfree (tmp);
    }

  if (rec != &record_first)
    {
      xfree (rec);
    }
}

static void
record_list_release_next (record_t * rec)
{
  record_t *tmp = rec->next;
  rec->next = NULL;
  while (tmp)
    {
      rec = tmp->next;
      if (tmp->type == record_reg)
	{
	  xfree (tmp->u.reg.val);
	}
      else if (tmp->type == record_mem)
	{
	  xfree (tmp->u.mem.val);
	}
      xfree (tmp);
      tmp = rec;
    }
}

/* Add a record_t to "record_arch_list". */
static void
record_arch_list_add (record_t * rec)
{
  if (record_arch_list_tail)
    {
      record_arch_list_tail->next = rec;
      rec->prev = record_arch_list_tail;
      record_arch_list_tail = rec;
    }
  else
    {
      record_arch_list_head = rec;
      record_arch_list_tail = rec;
    }
}

/* Record the value of a register("num") to "record_arch_list". */
int
record_arch_list_add_reg (int num)
{
  record_t *rec;

  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Record: add reg num = %d to record list.\n", num);
    }

  rec = (record_t *) xmalloc (sizeof (record_t));
  rec->u.reg.val = (gdb_byte *) xmalloc (MAX_REGISTER_SIZE);
  rec->prev = NULL;
  rec->next = NULL;
  rec->type = record_reg;
  rec->u.reg.num = num;

  regcache_raw_read (record_regcache, num, rec->u.reg.val);

  record_arch_list_add (rec);

  return (0);
}

/* Record the value of a part of memroy that address is "addr" and length is
   "len" to "record_arch_list". */
int
record_arch_list_add_mem (CORE_ADDR addr, int len)
{
  record_t *rec;

  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Record: add mem addr = 0x%s len = %d to record list.\n",
			  paddr_nz (addr), len);
    }

  if (!addr)
    {
      return (0);
    }

  rec = (record_t *) xmalloc (sizeof (record_t));
  rec->u.mem.val = (gdb_byte *) xmalloc (len);
  rec->prev = NULL;
  rec->next = NULL;
  rec->type = record_mem;
  rec->u.mem.addr = addr;
  rec->u.mem.len = len;

  if (target_read_memory (addr, rec->u.mem.val, len))
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Record: read memory addr = 0x%s len = %d error.\n",
			  paddr_nz (addr), len);
      xfree (rec->u.mem.val);
      xfree (rec);
      return (-1);
    }

  record_arch_list_add (rec);

  return (0);
}

/* Add a "record_end" type record_t to "record_arch_list". */
int
record_arch_list_add_end (int need_dasm)
{
  record_t *rec;

  if (record_debug > 1)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Record: add end need_dasm = %d to arch list.\n",
			  need_dasm);
    }

  rec = (record_t *) xmalloc (sizeof (record_t));
  rec->prev = NULL;
  rec->next = NULL;
  rec->type = record_end;

  rec->u.need_dasm = need_dasm;

  record_arch_list_add (rec);

  return (0);
}

/* Before inferior step (When GDB record the running message, inferior only can
   step.), GDB will call this function to record the values to "record_list".
   This function will call "gdbarch_record" to record the running message of
   inferior and set them to "record_arch_list". And add it to "record_list". */
void
record_message (struct gdbarch *gdbarch)
{
  int ret;

  record_arch_list_head = NULL;
  record_arch_list_tail = NULL;
  record_regcache = get_current_regcache ();

  /* Deal with displaced stepping */
  if (!ptid_equal (displaced_step_ptid, null_ptid))
    {
      if (record_debug)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "Record: this stepping is displaced stepping. Change PC register to original address 0x%s before call gdbarch_record. After that, change it back to 0x%s.\n",
			      paddr_nz (displaced_step_original),
			      paddr_nz (displaced_step_copy));
	}
      regcache_write_pc (record_regcache, displaced_step_original);
      ret = gdbarch_record (gdbarch, displaced_step_copy);
      regcache_write_pc (record_regcache, displaced_step_copy);
    }
  else
    {
      ret = gdbarch_record (gdbarch, regcache_read_pc (record_regcache));
    }

  if (ret > 0)
    {
      record_list_release (record_arch_list_tail);
      set_executing (inferior_ptid, 0);
      normal_stop ();
      error (_("Record: record pause the program."));
    }
  if (ret < 0)
    {
      record_list_release (record_arch_list_tail);
      set_executing (inferior_ptid, 0);
      normal_stop ();
      error (_("Record: record message error."));
    }

  record_list->next = record_arch_list_head;
  record_arch_list_head->prev = record_list;
  record_list = record_arch_list_tail;
}

/* Things to clean up if we QUIT out of function that set record_not_record.  */
static void
record_not_record_cleanups (void *ignore)
{
  record_not_record = 0;
}

void
record_not_record_set (void)
{
  struct cleanup *old_cleanups = make_cleanup (record_not_record_cleanups, 0);
  record_not_record = 1;
}

static void
record_open (char *name, int from_tty)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: record_open\n");
    }

  /* check exec */
  if (!target_has_execution)
    {
      error (_("Record: the program is not being run."));
    }

  if (!gdbarch_record_p (current_gdbarch))
    {
      error (_
	     ("Record: the current architecture don't support record function."));
    }

  /* Check if record target is already running */
  if (RECORD_IS_USED)
    {
      if (!nquery
	  (_
	   ("Record target already running, do you want delete the old running message?")))
	{
	  return;
	}
    }

  push_target (&record_ops);
}

static void
record_close (int quitting)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: record_close\n");
    }
  record_list_release (record_list);
  record_list_status = 1;
  record_execdir = EXEC_FORWARD;
}

static void
record_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  record_resume_step = step;

  if (!RECORD_IS_REPLAY)
    {
      record_message (current_gdbarch);
      return record_ops.beneath->to_resume (ptid, 1, siggnal);
    }
}

static void
record_sig_handler (int signo)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: get a signal\n");
    }
  record_resume_step = 1;
  record_get_sig = 1;
}

static ptid_t
record_wait (ptid_t ptid, struct target_waitstatus *status)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Record: record_wait record_resume_step = %d\n",
			  record_resume_step);
    }

  if (!RECORD_IS_REPLAY)
    {
      return record_ops.beneath->to_wait (ptid, status);
    }
  else
    {
      struct sigaction act, old_act;
      int need_dasm = 0;
      struct regcache *regcache = get_current_regcache ();
      int con = 1;
      int first_record_end = 1;

      record_get_sig = 0;
      act.sa_handler = record_sig_handler;
      act.sa_mask = record_maskall;
      act.sa_flags = SA_RESTART;
      if (sigaction (SIGINT, &act, &old_act))
	{
	  perror_with_name (_("Record: sigaction"));
	}
      /* If GDB is in terminal_inferior, it will not get the signal.
         And in GDB replay mode, GDB don't need to in terminal_inferior
         because inferior will not executed.
         Then set it to terminal_ours to make GDB get the signal. */
      target_terminal_ours ();

      do
	{

	  /* check state */
	  if ((record_execdir == EXEC_REVERSE && !record_list->prev
	       && record_list_status == 1) || (record_execdir != EXEC_REVERSE
					       && !record_list->next
					       && record_list_status == 2))
	    {
	      if (record_list_status == 2)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Record: running to the end of record list.\n");
		}
	      else if (record_list_status == 1)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Record: running to the begin of record list.\n");
		}
	      stop_soon = STOP_QUIETLY;
	      break;
	    }
	  record_list_status = 0;

	  /* set register and memory according to record_list */
	  if (record_list->type == record_reg)
	    {
	      /* reg */
	      gdb_byte reg[MAX_REGISTER_SIZE];
	      if (record_debug > 1)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Record: record_reg to inferior num = %d.\n",
				      record_list->u.reg.num);
		}
	      regcache_cooked_read (regcache, record_list->u.reg.num, reg);
	      regcache_cooked_write (regcache, record_list->u.reg.num,
				     record_list->u.reg.val);
	      memcpy (record_list->u.reg.val, reg, MAX_REGISTER_SIZE);
	    }
	  else if (record_list->type == record_mem)
	    {
	      /* mem */
	      gdb_byte *mem = alloca (record_list->u.mem.len);
	      if (record_debug > 1)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Record: record_mem to inferior addr = 0x%s len = %d.\n",
				      paddr_nz (record_list->u.mem.addr),
				      record_list->u.mem.len);
		}
	      if (target_read_memory
		  (record_list->u.mem.addr, mem, record_list->u.mem.len))
		{
		  error (_("Record: read memory addr = 0x%s len = %d error."),
			 paddr_nz (record_list->u.mem.addr),
			 record_list->u.mem.len);
		}
	      if (target_write_memory
		  (record_list->u.mem.addr, record_list->u.mem.val,
		   record_list->u.mem.len))
		{
		  error (_
			 ("Record: write memory addr = 0x%s len = %d error."),
			 paddr_nz (record_list->u.mem.addr),
			 record_list->u.mem.len);
		}
	      memcpy (record_list->u.mem.val, mem, record_list->u.mem.len);
	    }
	  else
	    {
	      CORE_ADDR tmp_pc;
	      struct bp_location *bl;
	      struct breakpoint *b;

	      if (record_debug > 1)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Record: record_end to inferior need_dasm = %d.\n",
				      record_list->u.need_dasm);
		}

	      if (record_execdir == EXEC_FORWARD)
		{
		  need_dasm = record_list->u.need_dasm;
		}
	      if (need_dasm)
		{
		  gdbarch_record_dasm (current_gdbarch);
		}

	      if (first_record_end && record_execdir == EXEC_REVERSE)
		{
		  /* When reverse excute, the first record_end is the part of current instruction */
		  first_record_end = 0;
		}
	      else
		{
		  /* In EXEC_REVERSE mode, this is the record_end of prev
		     instruction.
		     In EXEC_FORWARD mode, this is the record_end of current
		     instruction. */
		  /* step */
		  if (record_resume_step)
		    {
		      if (record_debug > 1)
			{
			  fprintf_unfiltered (gdb_stdlog, "Record: step.\n");
			}
		      con = 0;
		    }

		  /* check breakpoint */
		  tmp_pc = read_pc ();
		  for (bl = bp_location_chain; bl; bl = bl->global_next)
		    {
		      b = bl->owner;
		      gdb_assert (b);
		      if (b->enable_state != bp_enabled
			  && b->enable_state != bp_permanent)
			continue;

		      if (b->type == bp_watchpoint || b->type == bp_catch_fork
			  || b->type == bp_catch_vfork
			  || b->type == bp_catch_exec
			  || b->type == bp_hardware_watchpoint
			  || b->type == bp_read_watchpoint
			  || b->type == bp_access_watchpoint)
			{
			  continue;
			}
		      if (bl->address == tmp_pc)
			{
			  if (record_debug)
			    {
			      fprintf_unfiltered (gdb_stdlog,
						  "Record: break at 0x%s.\n",
						  paddr_nz (tmp_pc));
			    }
			  con = 0;
			  break;
			}
		    }
		}
	      if (record_execdir == EXEC_REVERSE)
		{
		  need_dasm = record_list->u.need_dasm;
		}
	    }

	  if (record_execdir == EXEC_REVERSE)
	    {
	      if (record_list->prev && con)
		record_list = record_list->prev;
	      else
		record_list_status = 1;
	    }
	  else
	    {
	      if (record_list->next)
		record_list = record_list->next;
	      else
		record_list_status = 2;
	    }

	}
      while (con);

      if (sigaction (SIGALRM, &old_act, NULL))
	{
	  perror_with_name (_("Record: sigaction"));
	}

      status->kind = TARGET_WAITKIND_STOPPED;
      if (record_get_sig)
	{
	  status->value.sig = TARGET_SIGNAL_INT;
	}
      else
	{
	  status->value.sig = TARGET_SIGNAL_TRAP;
	}
    }

  return inferior_ptid;
}

static void
record_disconnect (struct target_ops *target, char *args, int from_tty)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: record_disconnect\n");
    }
  unpush_target (&record_ops);
  target_disconnect (args, from_tty);
}

static void
record_detach (char *args, int from_tty)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: record_detach\n");
    }
  unpush_target (&record_ops);
  target_detach (args, from_tty);
}

/* Close record target before kill the inferior process. */
static void
record_kill (void)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: record_kill\n");
    }
  unpush_target (&record_ops);
  target_kill ();
}

/* Record registers change to list as an instruction */
static void
record_registers_change (struct regcache *regcache, int regnum)
{
  record_arch_list_head = NULL;
  record_arch_list_tail = NULL;
  record_regcache = get_current_regcache ();
  if (regnum < 0)
    {
      int i;
      for (i = 0; i < gdbarch_num_regs (get_regcache_arch (regcache)); i++)
	{
	  if (record_arch_list_add_reg (i))
	    {
	      record_list_release (record_arch_list_tail);
	      error (_("Record: record message error."));
	    }
	}
    }
  else
    {
      if (record_arch_list_add_reg (regnum))
	{
	  record_list_release (record_arch_list_tail);
	  error (_("Record: record message error."));
	}
    }
  if (record_arch_list_add_end (0))
    {
      record_list_release (record_arch_list_tail);
      error (_("Record: record message error."));
    }
  record_list->next = record_arch_list_head;
  record_arch_list_head->prev = record_list;
  record_list = record_arch_list_tail;
}

/* XXX: I don't know how to do if GDB call function target_store_registers
   without call function target_prepare_to_store. */
static void
record_prepare_to_store (struct regcache *regcache)
{
  if (!record_not_record)
    {
      if (RECORD_IS_REPLAY)
	{
	  struct cleanup *old_cleanups;
	  /* Let user choice if he want to write register or not. */
	  if (!nquery (_
		       ("Becuse GDB is in replay mode, this operation will destory the record in the next if set the value of register %s. Do you want GDB do it?"),
		       gdbarch_register_name (get_regcache_arch
					      (regcache),
					      record_regcache_raw_write_regnum)))
	    {
	      error (_("Record: record cancel the operation."));
	    }

	  /* Destory the record in the next */
	  record_list_release_next (record_list);
	}

      record_registers_change (regcache, record_regcache_raw_write_regnum);
    }
  record_ops.beneath->to_prepare_to_store (regcache);
}

static LONGEST
record_xfer_partial (struct target_ops *ops, enum target_object object,
		     const char *annex, gdb_byte * readbuf,
		     const gdb_byte * writebuf, ULONGEST offset, LONGEST len)
{
  if (!record_not_record
      && (object == TARGET_OBJECT_MEMORY
	  || object == TARGET_OBJECT_RAW_MEMORY) && writebuf)
    {
      if (RECORD_IS_REPLAY)
	{
	  /* Let user choice if he want to write memory or not. */
	  if (!nquery (_
		       ("Becuse GDB is in replay mode, this operation will destory the record in the next if write memory that addr is 0x%s and size is %lld. Do you want GDB do it?"),
		       paddr_nz (offset), len))
	    {
	      return -1;
	    }

	  /* Destory the record in the next */
	  record_list_release_next (record_list);
	}

      /* Record registers change to list as an instruction */
      record_arch_list_head = NULL;
      record_arch_list_tail = NULL;
      record_regcache = get_current_regcache ();
      if (record_arch_list_add_mem (offset, len))
	{
	  record_list_release (record_arch_list_tail);
	  fprintf_unfiltered (gdb_stdlog, _("Record: record message error."));
	  return -1;
	}
      if (record_arch_list_add_end (0))
	{
	  record_list_release (record_arch_list_tail);
	  fprintf_unfiltered (gdb_stdlog, _("Record: record message error."));
	  return -1;
	}
      record_list->next = record_arch_list_head;
      record_arch_list_head->prev = record_list;
      record_list = record_arch_list_tail;
    }

  return record_ops.beneath->to_xfer_partial (ops, object, annex, readbuf,
					      writebuf, offset, len);
}

static int
record_insert_breakpoint (struct bp_target_info *bp_tgt)
{
  if (!RECORD_IS_REPLAY)
    {
      return record_ops.beneath->to_insert_breakpoint (bp_tgt);
    }

  return 0;
}

static int
record_remove_breakpoint (struct bp_target_info *bp_tgt)
{
  if (!RECORD_IS_REPLAY)
    {
      return record_ops.beneath->to_remove_breakpoint (bp_tgt);
    }

  return 0;
}

static enum exec_direction_kind
record_get_execdir (void)
{
  if (record_debug > 1)
    printf_filtered ("Record: execdir is %s\n",
		     record_execdir == EXEC_FORWARD ? "forward" :
		     record_execdir == EXEC_REVERSE ? "reverse" : "unknown");
  return record_execdir;
}

static int
record_set_execdir (enum exec_direction_kind dir)
{
  if (record_debug)
    printf_filtered ("Record: set execdir: %s\n",
		     dir == EXEC_FORWARD ? "forward" :
		     dir == EXEC_REVERSE ? "reverse" : "bad direction");

  /* FIXME: check target for capability.  */
  if (dir == EXEC_FORWARD || dir == EXEC_REVERSE)
    return (record_execdir = dir);
  else
    return EXEC_ERROR;
}

static void
init_record_ops (void)
{
  record_ops.to_shortname = "record";
  record_ops.to_longname = "Record and reverse target";
  record_ops.to_doc =
    "Record the program running message and replay this message.";
  record_ops.to_open = record_open;
  record_ops.to_close = record_close;
  record_ops.to_resume = record_resume;
  record_ops.to_wait = record_wait;
  record_ops.to_disconnect = record_disconnect;
  record_ops.to_detach = record_detach;
  record_ops.to_kill = record_kill;
  record_ops.to_create_inferior = find_default_create_inferior;	/* Make record suppport command "run". */
  record_ops.to_prepare_to_store = record_prepare_to_store;
  record_ops.to_xfer_partial = record_xfer_partial;
  record_ops.to_insert_breakpoint = record_insert_breakpoint;
  record_ops.to_remove_breakpoint = record_remove_breakpoint;
  record_ops.to_get_execdir = record_get_execdir;
  record_ops.to_set_execdir = record_set_execdir;
  record_ops.to_stratum = record_stratum;
  record_ops.to_magic = OPS_MAGIC;
}

static void
show_record_debug (struct ui_file *file, int from_tty,
		   struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Debugging of record target is %s.\n"), value);
}

static void
cmd_record_start (char *args, int from_tty)
{
  execute_command ("target record", from_tty);
}

static void
cmd_record_delete (char *args, int from_tty)
{
  if (RECORD_IS_USED)
    {
      if (RECORD_IS_REPLAY)
	{
	  if (!from_tty || query (_
				  ("Record: delete the next running messages and begin to record the running message at current address?")))
	    {
	      record_list_release_next (record_list);
	    }
	}
      else
	{
	  printf_unfiltered (_
			     ("Record: GDB already at the end of record list.\n"));
	}

    }
  else
    {
      printf_unfiltered (_("Record: record target is not started.\n"));
    }
}

static void
cmd_record_stop (char *args, int from_tty)
{
  if (RECORD_IS_USED)
    {
      if (!record_list || !from_tty || query (_
					      ("Record: delete all the record messages and stop record target?")))
	{
	  unpush_target (&record_ops);
	}
    }
  else
    {
      printf_unfiltered (_("Record: record target is not started.\n"));
    }
}

void
_initialize_record (void)
{
  /* init record_maskall */
  if (sigfillset (&record_maskall) == -1)
    {
      perror_with_name (_("Record: sigfillset"));
    }

  /* init record_first */
  record_first.prev = NULL;
  record_first.next = NULL;
  record_first.type = record_end;
  record_first.u.need_dasm = 0;

  init_record_ops ();
  add_target (&record_ops);

  add_setshow_zinteger_cmd ("record", no_class, &record_debug,
			    _("Set record debugging."),
			    _("Show record debugging."),
			    _
			    ("When non-zero, record specific debugging is enabled."),
			    NULL, show_record_debug, &setdebuglist,
			    &showdebuglist);

  add_com ("record", class_obscure, cmd_record_start,
	   _("Same with command \"target record\"."));
  add_com_alias ("rec", "record", class_obscure, 1);

  /* XXX: I try to use some simple commands such as "disconnect" and "detach"
     to support this functions. But these commands all have other affect to
     GDB such as call function "no_shared_libraries". So I add special commands
     to GDB. */
  add_com ("delrecord", class_obscure, cmd_record_delete,
	   _
	   ("When record target running in replay mode, delete the next running messages and begin to record the running message at current address."));
  add_com_alias ("dr", "delrecord", class_obscure, 1);
  add_com ("stoprecord", class_obscure, cmd_record_stop,
	   _("Stop the record target."));
  add_com_alias ("sr", "stoprecord", class_obscure, 1);
}
@


1.1.2.2
log
@Add a cleanup in function "record_message".
@
text
@a215 8
static void
record_message_cleanups (void *ignore)
{
  record_list_release (record_arch_list_tail);
  set_executing (inferior_ptid, 0);
  normal_stop ();
}

a219 1

a223 1
  struct cleanup *old_cleanups = make_cleanup (record_message_cleanups, 0);
d249 6
a254 1
    error (_("Record: record pause the program."));
d256 6
a261 3
    error (_("Record: record message error."));

  discard_cleanups (old_cleanups);
@


1.1.2.3
log
@Change record.c (record_list_release_next) just release "record_list".
Add record instructions limit.
Add a cleanup for displaced stepping in function "record_message_cleanups".
@
text
@a29 2
#define DEFAULT_RECORD_INSN_MAX_NUM	200000

a30 1

a37 8
extern void displaced_step_fixup (ptid_t event_ptid,
				  enum target_signal signal);

/* 0 ask user. 1 auto delete the last record_t. */
static int record_insn_max_mode = 0;
static int record_insn_max_num = DEFAULT_RECORD_INSN_MAX_NUM;
static int record_insn_num = 0;

d86 1
a86 1
record_list_release_next (void)
a87 1
  record_t *rec = record_list;
a94 4
	  record_insn_num--;
	}
      else if (tmp->type == record_reg)
	{
a105 44
static void
record_list_release_first (void)
{
  record_t *tmp = NULL;
  enum record_type type;

  if (!record_first.next)
    {
      return;
    }

  while (1)
    {
      type = record_first.next->type;

      if (type == record_reg)
	{
	  xfree (record_first.next->u.reg.val);
	}
      else if (type == record_mem)
	{
	  xfree (record_first.next->u.mem.val);
	}
      tmp = record_first.next;
      record_first.next = tmp->next;
      xfree (tmp);

      if (!record_first.next)
	{
	  gdb_assert (record_insn_num == 1);
	  break;
	}

      record_first.next->prev = &record_first;

      if (type == record_end)
	{
	  break;
	}
    }

  record_insn_num--;
}

a219 5

  /* Clean for displaced stepping */
  if (!ptid_equal (displaced_step_ptid, null_ptid))
    displaced_step_fixup (displaced_step_ptid, TARGET_SIGNAL_TRAP);

a238 27
  /* Check record_insn_num */
  if (record_insn_max_num)
    {
      gdb_assert (record_insn_num <= record_insn_max_num);
      if (record_insn_num == record_insn_max_num)
	{
	  /* Ask user how to do */
	  if (!record_insn_max_mode)
	    {
	      int q;
	      target_terminal_ours ();
	      q =
		yquery (_
			("The record instructions number (record-insn-number) is same with the record instructions max number (record-insn-number-max). Do you want to open auto delete first record_t function (record-auto-delete)?"));
	      target_terminal_inferior ();
	      if (q)
		{
		  record_insn_max_mode = 1;
		}
	      else
		{
		  error (_("Record: record pause the program."));
		}
	    }
	}
    }

a267 9

  if (record_insn_num == record_insn_max_num && record_insn_max_num)
    {
      record_list_release_first ();
    }
  else
    {
      record_insn_num++;
    }
a314 1
  record_insn_num = 0;
d668 1
a668 1
	  record_list_release_next ();
d696 1
a696 1
	  record_list_release_next ();
d819 1
a819 1
	      record_list_release_next ();
a851 22
static void
set_record_insn_max_num (char *args, int from_tty, struct cmd_list_element *c)
{
  if (record_insn_num > record_insn_max_num && record_insn_max_num)
    {
      printf_unfiltered (_
			 ("Record: record instructions number is bigger than record instructions max number. Auto delete the first ones.\n"));

      while (record_insn_num > record_insn_max_num)
	{
	  record_list_release_first ();
	}
    }
}

static void
show_record_insn_number (char *ignore, int from_tty)
{
  printf_unfiltered (_("Record instructions number is %d.\n"),
		     record_insn_num);
}

a892 19

  /* Record instructions number limit command. */
  add_setshow_zinteger_cmd ("record-auto-delete", no_class,
			    &record_insn_max_mode,
			    _("Set record auto delete mode."),
			    _("Show record auto delete mode."),
			    _
			    ("When number of instructions that record target record is same with record-insn-max, if 0 will ask user howto do, if no 0 will auto delete the first record_t."),
			    NULL, NULL, &setlist, &showlist);
  add_setshow_zinteger_cmd ("record-insn-number-max", no_class,
			    &record_insn_max_num,
			    _("Set record instructions max number."),
			    _("Show record instructions max number."),
			    _
			    ("The max instructions number that record target can record. When 0, record target will not limit it."),
			    set_record_insn_max_num, NULL, &setlist,
			    &showlist);
  add_info ("record-insn-number", show_record_insn_number,
	    _("Show the record instructions number."));
@


1.1.2.4
log
@

chael Snyder  <msnyder@@specifix.com>

        * record.c (_initialize_record): Clarify language in help strings.
        Fix up comment format (period must be followed by two spaces).

2008-08-01  Michael Snyder  <msnyder@@specifix.com>

        * i386-tdep.c (i386_record_lea_modrm): Spelling fix.
:wq
@
text
@d995 4
a998 3
			    _("Set debugging of record/replay feature."),
			    _("Show debugging of record/replay feature."),
			    _("When enabled, debugging output for record/replay feature is displayed."),
d1003 1
a1003 2
	   _("Abbreviated form of \"target record\" command."));

d1006 4
a1009 4
  /* XXX: I try to use some simple commands such as "disconnect" and
     "detach" to support this functions.  But these commands all have
     other affect to GDB such as call function "no_shared_libraries".
     So I add special commands to GDB.  */
d1011 2
a1012 1
	   _("When record target running in replay mode, delete the next running messages and begin to record the running message at current address."));
d1015 1
a1015 1
	   _("Stop the record/replay target."));
a1018 1
  /* Teawater -- tell me if I got this one wrong.  MVS  */
d1021 4
a1024 5
			    _("Set record/replay auto delete mode."),
			    _("Show record/replay auto delete mode."),
			    _("\
When enabled, if the record/replay buffer becomes full,\n\
delete it and start new recording."),
d1028 4
a1031 5
			    _("Set record/replay buffer limit."),
			    _("Show record/replay buffer limit."),
			    _("\
Set the maximum number of instructions to be stored in the\n\
record/replay buffer.  Zero means unlimited (default 200000).",
d1035 1
a1035 2
	    _("\
Show the current number of instructions in the record/replay buffer."));
@


1.1.2.5
log
@	Support more ioctl requests in record target.

	* i386-linux-tdep.c (I386_RECORD_SIZE_termios,
	I386_RECORD_SIZE_termios2, I386_RECORD_SIZE_pid_t,
	I386_RECORD_SIZE_winsize, I386_RECORD_SIZE_char,
	I386_RECORD_SIZE_serial_struct,
	I386_RECORD_SIZE_serial_icounter_struct,
	I386_RECORD_SIZE_hayes_esp_config): New macros. Sizes of some types in
	I386.
	(I386_RECORD_IOCTL_TCGETS,
	I386_RECORD_IOCTL_TCSETS,
	I386_RECORD_IOCTL_TCSETSW,
	I386_RECORD_IOCTL_TCSETSF,
	I386_RECORD_IOCTL_TCGETA,
	I386_RECORD_IOCTL_TCSETA,
	I386_RECORD_IOCTL_TCSETAW,
	I386_RECORD_IOCTL_TCSETAF,
	I386_RECORD_IOCTL_TCSBRK,
	I386_RECORD_IOCTL_TCXONC,
	I386_RECORD_IOCTL_TCFLSH,
	I386_RECORD_IOCTL_TIOCEXCL,
	I386_RECORD_IOCTL_TIOCNXCL,
	I386_RECORD_IOCTL_TIOCSCTTY,
	I386_RECORD_IOCTL_TIOCGPGRP,
	I386_RECORD_IOCTL_TIOCSPGRP,
	I386_RECORD_IOCTL_TIOCOUTQ,
	I386_RECORD_IOCTL_TIOCSTI,
	I386_RECORD_IOCTL_TIOCGWINSZ,
	I386_RECORD_IOCTL_TIOCSWINSZ,
	I386_RECORD_IOCTL_TIOCMGET,
	I386_RECORD_IOCTL_TIOCMBIS,
	I386_RECORD_IOCTL_TIOCMBIC,
	I386_RECORD_IOCTL_TIOCMSET,
	I386_RECORD_IOCTL_TIOCGSOFTCAR,
	I386_RECORD_IOCTL_TIOCSSOFTCAR,
	I386_RECORD_IOCTL_FIONREAD,
	I386_RECORD_IOCTL_TIOCINQ,
	I386_RECORD_IOCTL_TIOCLINUX,
	I386_RECORD_IOCTL_TIOCCONS,
	I386_RECORD_IOCTL_TIOCGSERIAL,
	I386_RECORD_IOCTL_TIOCSSERIAL,
	I386_RECORD_IOCTL_TIOCPKT,
	I386_RECORD_IOCTL_FIONBIO,
	I386_RECORD_IOCTL_TIOCNOTTY,
	I386_RECORD_IOCTL_TIOCSETD,
	I386_RECORD_IOCTL_TIOCGETD,
	I386_RECORD_IOCTL_TCSBRKP,
	I386_RECORD_IOCTL_TIOCTTYGSTRUCT,
	I386_RECORD_IOCTL_TIOCSBRK,
	I386_RECORD_IOCTL_TIOCCBRK,
	I386_RECORD_IOCTL_TIOCGSID,
	I386_RECORD_IOCTL_TCGETS2,
	I386_RECORD_IOCTL_TCSETS2,
	I386_RECORD_IOCTL_TCSETSW2,
	I386_RECORD_IOCTL_TCSETSF2,
	I386_RECORD_IOCTL_TIOCGPTN,
	I386_RECORD_IOCTL_TIOCSPTLCK,
	I386_RECORD_IOCTL_FIONCLEX,
	I386_RECORD_IOCTL_FIOCLEX,
	I386_RECORD_IOCTL_FIOASYNC,
	I386_RECORD_IOCTL_TIOCSERCONFIG,
	I386_RECORD_IOCTL_TIOCSERGWILD,
	I386_RECORD_IOCTL_TIOCSERSWILD,
	I386_RECORD_IOCTL_TIOCGLCKTRMIOS,
	I386_RECORD_IOCTL_TIOCSLCKTRMIOS,
	I386_RECORD_IOCTL_TIOCSERGSTRUCT,
	I386_RECORD_IOCTL_TIOCSERGETLSR,
	I386_RECORD_IOCTL_TIOCSERGETMULTI,
	I386_RECORD_IOCTL_TIOCSERSETMULTI,
	I386_RECORD_IOCTL_TIOCMIWAIT,
	I386_RECORD_IOCTL_TIOCGICOUNT,
	I386_RECORD_IOCTL_TIOCGHAYESESP,
	I386_RECORD_IOCTL_TIOCSHAYESESP,
	I386_RECORD_IOCTL_FIOQSIZE): New macros. Ioctl request numbers in I386.
	(i386_linux_init_abi): Initialize the size of some types and ioctl
	request numbers in linux_record_tdep.
	linux-record.c (record_linux_system_call): Record more ioctl requests.
	linux-record.h (linux_record_tdep_s): Add size of some types and ioctl
	request numbers.

	Add a cleanup in function "record_wait".

	* record.c (record_wait_cleanups): New function. Clean for function
	"record_wait".
	(record_wait): Add a cleanup to call function "record_wait_cleanups".

	i386-tdep.c (i386_record_lea_modrm): If this is not a error, output
	warning message of "can't get the value of the segment register" just
	when record_debug is set.

	record.c (record_message): Change output message from "pause" to
	"stop".

	linux-record.c (record_linux_system_call): Change output message from
	"pause" to "stop".

	linux-record.c (record_linux_system_call): Make query message for
	syscall munmap more clear.

	record.c (_initialize_record): Fix a little bug.
@
text
@d325 1
a325 1
		  error (_("Record: record stop the program."));
a454 18
static void
record_wait_cleanups (void *ignore)
{
  if (record_execdir == EXEC_REVERSE)
    {
      if (record_list->next)
	{
	  record_list = record_list->next;
	}
    }
  else
    {
      record_list = record_list->prev;
    }
  set_executing (inferior_ptid, 0);
  normal_stop ();
}

a475 1
      struct cleanup *old_cleanups = make_cleanup (record_wait_cleanups, 0);
a672 2

      discard_cleanups (old_cleanups);
d1033 1
a1033 1
record/replay buffer.  Zero means unlimited (default 200000)."),
@


1.1.2.6
log
@2008-08-10  Hui Zhu  <teawater@@gmail.com>

	Add the real beneath function pointers for record target.

	* Makefile.in: Add record.h to depend of target.c.
	* record.c (record_beneath_to_resume, record_beneath_to_wait,
	record_beneath_to_prepare_to_store, record_beneath_to_xfer_partial,
	record_beneath_to_insert_breakpoint,
	record_beneath_to_remove_breakpoint): New function pointers. The real
	beneath function pointers.
	(record_resume): Change "record_ops.beneath->to_resume" to
	"record_beneath_to_resume".
	(record_wait): Change "record_ops.beneath->to_wait" to
	"record_beneath_to_wait".
	(record_prepare_to_store): Change
	"record_ops.beneath->to_prepare_to_store" to
	"record_beneath_to_prepare_to_store".
	(record_xfer_partial): Change "record_ops.beneath->to_xfer_partial" to
	"record_beneath_to_xfer_partial".
	(record_insert_breakpoint): Change
	"record_ops.beneath->to_insert_breakpoint" to
	"record_beneath_to_insert_breakpoint".
	(record_remove_breakpoint): Change
	"record_ops.beneath->to_remove_breakpoint" to
	"record_beneath_to_remove_breakpoint".
	* record.h (record_beneath_to_resume, record_beneath_to_wait,
	record_beneath_to_prepare_to_store, record_beneath_to_xfer_partial,
	record_beneath_to_insert_breakpoint,
	record_beneath_to_remove_breakpoint): Extern.
	* target.c: Add include of "record.h".
	(update_current_target): Set the real beneath function pointers.
@
text
@a61 13
/* The real beneath function pointers. */
void (*record_beneath_to_resume) (ptid_t, int, enum target_signal);
ptid_t (*record_beneath_to_wait) (ptid_t, struct target_waitstatus *);
void (*record_beneath_to_prepare_to_store) (struct regcache *);
LONGEST (*record_beneath_to_xfer_partial) (struct target_ops * ops,
					   enum target_object object,
					   const char *annex,
					   gdb_byte * readbuf,
					   const gdb_byte * writebuf,
					   ULONGEST offset, LONGEST len);
int (*record_beneath_to_insert_breakpoint) (struct bp_target_info *);
int (*record_beneath_to_remove_breakpoint) (struct bp_target_info *);

d440 1
a440 1
      record_beneath_to_resume (ptid, 1, siggnal);
d485 1
a485 1
      return record_beneath_to_wait (ptid, status);
d796 1
a796 1
  record_beneath_to_prepare_to_store (regcache);
d843 1
a843 1
  return record_beneath_to_xfer_partial (ops, object, annex, readbuf,
d852 1
a852 1
      return record_beneath_to_insert_breakpoint (bp_tgt);
d863 1
a863 1
      return record_beneath_to_remove_breakpoint (bp_tgt);
d1018 1
a1018 2
			    _
			    ("When enabled, debugging output for record/replay feature is displayed."),
d1032 1
a1032 2
	   _
	   ("When record target running in replay mode, delete the next running messages and begin to record the running message at current address."));
d1043 2
a1044 1
			    _("Show record/replay auto delete mode."), _("\
d1046 2
a1047 1
delete it and start new recording."), NULL, NULL, &setlist, &showlist);
d1051 2
a1052 1
			    _("Show record/replay buffer limit."), _("\
d1054 5
a1058 2
record/replay buffer.  Zero means unlimited (default 200000)."), set_record_insn_max_num, NULL, &setlist, &showlist);
  add_info ("record-insn-number", show_record_insn_number, _("\
@


1.1.2.7
log
@
	the insn number.
	(record_registers_change): Call function
	"record_check_insn_num" check the insn number. Increase
	"record_insn_num" if need.
	(record_xfer_partial): Call function "record_check_insn_num"
	check the insn number. Increase "record_insn_num" if need.

2008-08-10  Hui Zhu  <teawater@@gmail.com>

	Add the real beneath function pointers for record target.

	* Makefile.in: Add record.h to depend of target.c.
	* record.c (record_beneath_to_resume, record_beneath_to_wait,
	record_beneath_to_prepare_to_store,
	record_beneath_to_xfer_partial,
	record_beneath_to_insert_breakpoint,
	record_beneath_to_remove_breakpoint): New function pointers.
	The real beneath function pointers.
	(record_resume): Change "record_ops.beneath->to_resume" to
	"record_beneath_to_resume".
	(record_wait): Change "record_ops.beneath->to_wait" to
	"record_beneath_to_wait".
	(record_prepare_to_store): Change
	"record_ops.beneath->to_prepare_to_store" to
	"record_beneath_to_prepare_to_store".
	(record_xfer_partial): Change
	"record_ops.beneath->to_xfer_partial" to
	"record_beneath_to_xfer_partial".
	(record_insert_breakpoint): Change
	"record_ops.beneath->to_insert_breakpoint" to
	"record_beneath_to_insert_breakpoint".
	(record_remove_breakpoint): Change
	"record_ops.beneath->to_remove_breakpoint" to
	"record_beneath_to_remove_breakpoint".
	* record.h (record_beneath_to_resume,
	record_beneath_to_wait,
	record_beneath_to_prepare_to_store,
	record_beneath_to_xfer_partial,
	record_beneath_to_insert_breakpoint,
	record_beneath_to_remove_breakpoint): Extern.
	* target.c: Add include of "record.h".
	(update_current_target): Set the real beneath function
	pointers.
@
text
@a51 1
int record_linux_async_permitted = 0;
d290 19
a308 1
record_check_insn_num (int set_terminal)
d310 8
d327 1
a327 2
	      if (set_terminal)
		target_terminal_ours ();
d329 3
a331 3
		yquery (_("The record instructions number (record-insn-number) is same with the record instructions max number (record-insn-number-max). Do you want to open auto delete first record_t function (record-auto-delete)?"));
	      if (set_terminal)
		target_terminal_inferior ();
a342 33
}

/* Before inferior step (When GDB record the running message, inferior only can
   step.), GDB will call this function to record the values to "record_list".
   This function will call "gdbarch_record" to record the running message of
   inferior and set them to "record_arch_list". And add it to "record_list". */

static void
record_message_cleanups (void *ignore)
{
  record_list_release (record_arch_list_tail);

  /* Clean for displaced stepping */
  if (!ptid_equal (displaced_step_ptid, null_ptid))
    displaced_step_fixup (displaced_step_ptid, TARGET_SIGNAL_TRAP);

  set_executing (inferior_ptid, 0);
  normal_stop ();
}

void
record_message (struct gdbarch *gdbarch)
{
  int ret;
  struct cleanup *old_cleanups = make_cleanup (record_message_cleanups, 0);

  /* Check record_insn_num. */
  record_check_insn_num (1);

  record_arch_list_head = NULL;
  record_arch_list_tail = NULL;

  record_regcache = get_current_regcache ();
d344 1
a346 1
      /* Deal with displaced stepping. */
a410 8
  if (non_stop)
    {
      error (_("Record: record target can't debug inferior in non-stop mode (non-stop)."));
    }
  if (record_linux_async_permitted)
    {
      error (_("Record: record target can't debug the GNU/Linux inferior in asynchronous mode (linux-async)."));
    }
d414 2
a415 1
      error (_("Record: the current architecture don't support record function."));
d422 2
a423 1
	  (_("Record target already running, do you want delete the old running message?")))
a428 1
  /* Reset */
a429 5
  record_list_status = 1;
  record_execdir = EXEC_FORWARD;
  record_list = &record_first;
  record_list->next = NULL;

d441 2
d453 1
a453 1
      record_ops.beneath->to_resume (ptid, 1, siggnal);
d547 1
a547 1
	  /* set ptid, register and memory according to record_list */
a733 11
static void
record_mourn_inferior (void)
{
  if (record_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Record: record_mourn_inferior\n");
    }
  unpush_target (&record_ops);
  target_mourn_inferior ();
}

a749 3
  /* Check record_insn_num. */
  record_check_insn_num (0);

a751 1

a752 1

a780 9

  if (record_insn_num == record_insn_max_num && record_insn_max_num)
    {
      record_list_release_first ();
    }
  else
    {
      record_insn_num++;
    }
d794 2
a795 1
	  if (!nquery (_("Becuse GDB is in replay mode, this operation will destory the record in the next if set the value of register %s. Do you want GDB do it?"),
d803 1
a803 1
	  /* Destory the record in the next. */
d824 2
a825 1
	  if (!nquery (_("Becuse GDB is in replay mode, this operation will destory the record in the next if write memory that addr is 0x%s and size is %lld. Do you want GDB do it?"),
d831 1
a831 1
	  /* Destory the record in the next. */
d835 1
a835 4
      /* Check record_insn_num */
      record_check_insn_num (0);

      /* Record registers change to list as an instruction. */
d838 1
a853 9

      if (record_insn_num == record_insn_max_num && record_insn_max_num)
	{
	  record_list_release_first ();
	}
      else
	{
	  record_insn_num++;
	}
d857 1
a857 1
					 writebuf, offset, len);
a919 1
  record_ops.to_mourn_inferior = record_mourn_inferior;
d952 2
a953 1
	  if (!from_tty || query (_("Record: delete the next running messages and begin to record the running message at current address?")))
d960 2
a961 1
	  printf_unfiltered (_("Record: GDB already at the end of record list.\n"));
d976 2
a977 1
      if (!record_list || !from_tty || query (_("Record: delete all the record messages and stop record target?")))
d993 2
a994 1
      printf_unfiltered (_("Record: record instructions number is bigger than record instructions max number. Auto delete the first ones.\n"));
d1013 1
a1013 1
  /* init record_maskall. */
d1019 1
a1019 1
  /* init record_first. */
d1046 2
a1047 1
	   _("When record target running in replay mode, delete the next running messages and begin to record the running message at current address."));
@


1.1.2.8
log
@2008-09-06  Michael Snyder  <msnyder@@vmware.com>

	* record.c: Comment and message string cleanup.
@
text
@d44 1
a44 1
/* 0 ask user. 1 auto delete the last record_t.  */
d63 1
a63 1
/* The real beneath function pointers.  */
d180 1
a180 1
/* Add a record_t to record_arch_list.  */
d197 1
a197 1
/* Record the value of a register ("num") to record_arch_list.  */
d206 1
a206 2
			  "Record: add register num = %d to record list.\n", 
			  num);
d223 2
a224 3
/* Record the value of a region of memory whose address is "addr" and
   length is "len" to record_arch_list.  */

d265 1
a265 1
/* Add a record_end type record_t to record_arch_list.  */
d304 2
a305 1
	      q = yquery (_("The record instruction number (record-insn-number) is equal to record-insn-number-max.  Do you want to open auto delete first record_t function (record-auto-delete)?"));
d321 4
a324 5
/* Before inferior step (when GDB record the running message, inferior
   only can step), GDB will call this function to record the values to
   record_list.  This function will call gdbarch_record to record the
   running message of inferior and set them to record_arch_list, and
   add it to record_list.  */
d345 1
a345 1
  /* Check record_insn_num.  */
d355 1
a355 1
      /* Deal with displaced stepping.  */
d359 1
a359 1
			      "Record: this stepping is displaced stepping.  Change PC register to original address 0x%s before call gdbarch_record.  After that, change it back to 0x%s.\n",
d393 1
a393 2
/* Things to clean up if we QUIT out of function that set
   record_not_record.  */
d431 1
a431 1
      error (_("Record: the current architecture doesn't support record function."));
d438 1
a438 1
	  (_("Record target already running, do you want delete the old record log?")))
d539 1
a539 1
         Then set it to terminal_ours to make GDB get the signal.  */
d547 3
a549 4
	       && record_list_status == 1) 
	      || (record_execdir != EXEC_REVERSE
		  && !record_list->next
		  && record_list_status == 2))
d643 1
a643 1
		     instruction.  */
d764 1
a764 1
/* Close record target before kill the inferior process.  */
d776 1
a776 1
/* Record registers change to list as an instruction.  */
d780 1
a780 1
  /* Check record_insn_num.  */
d828 1
a828 1
   without call function target_prepare_to_store.  */
d837 2
a838 2
	  /* Let user choice if he want to write register or not.  */
	  if (!nquery (_("Becuse GDB is in replay mode, changing the value of a register will destroy the record from this point forward.  Change register %s?"),
d846 1
a846 1
	  /* Destory the record from here forward.  */
d866 3
a868 3
	  /* Let user choice if he want to write memory or not.  */
	  if (!nquery (_("Because GDB is in replay mode, writing to memory will destroy the record from this point forward.  Write memory at address 0x%s?"),
		       paddr_nz (offset)))
d873 1
a873 1
	  /* Destory the record from here forward.  */
d880 1
a880 1
      /* Record registers change to list as an instruction.  */
d966 1
a966 1
    "Log program while executing and replay execution from log.";
d975 1
a975 1
  record_ops.to_create_inferior = find_default_create_inferior;	/* Make record suppport command "run".  */
d1006 1
a1006 1
	  if (!from_tty || query (_("Record: delete the log from this point forward and begin to record the running message at current PC?")))
d1013 1
a1013 1
	  printf_unfiltered (_("Record: already at end of record list.\n"));
d1028 1
a1028 1
      if (!record_list || !from_tty || query (_("Record: delete recorded log and stop recording?")))
d1044 1
a1044 1
      printf_unfiltered (_("Record: record instructions number is bigger than record instructions max number.  Auto delete the first ones.\n"));
d1056 1
a1056 1
  printf_unfiltered (_("Record instruction number is %d.\n"),
d1063 1
a1063 1
  /* Init record_maskall.  */
d1069 1
a1069 1
  /* Init record_first.  */
d1102 1
a1102 1
  /* Record instructions number limit command.  */
d1115 1
a1115 3
record/replay buffer.  Zero means unlimited (default 200000)."), 
			    set_record_insn_max_num, 
			    NULL, &setlist, &showlist);
@


1.1.2.9
log
@2008-09-06  Michael Snyder  <msnyder@@vmware.com>

	* record.c: Add some function header comments.
@
text
@a507 4
/* record_wait
   In replay mode, this function examines the recorded log and
   determines where to stop.  */

d527 1
a527 1
      int continue_flag = 1;
a544 1
      /* Loop over the record log, looking for the next place to stop.  */
d547 1
d655 1
a655 1
		      continue_flag = 0;
d685 1
a685 1
			  continue_flag = 0;
d698 1
a698 1
	      if (record_list->prev && continue_flag)
d712 1
a712 1
      while (continue_flag);
d780 1
a780 1
/* Record registers change (by user or by GDB) to list as an instruction.  */
a832 1

d850 1
a850 1
	  /* Destroy the record from here forward.  */
a858 4
/* record_xfer_partial -- behavior is conditional on RECORD_IS_REPLAY.
   In replay mode, we cannot write memory unles we are willing to 
   invalidate the record/replay log from this point forward.  */

d877 1
a877 1
	  /* Destroy the record from here forward.  */
a916 5
/* record_insert_breakpoint
   record_remove_breakpoint
   Behavior is conditional on RECORD_IS_REPLAY.
   We will not actually insert or remove breakpoints when replaying.  */

a996 2
/* cmd_record_start -- alias for "target record".  */

a1002 3
/* cmd_record_delete -- truncate the record log from the present point
   of replay until the end.  */

a1026 2
/* cmd_record_stop -- implement the "stoprecord" command.  */

a1042 2
/* set_record_insn_max_num -- set upper limit of record log size.  */

a1056 3
/* show_record_insn_number -- print the current index
   into the record log (number of insns recorded so far).  */

@


1.1.2.10
log
@2008-09-07  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_wait): Add code to deal with record_first.
@
text
@a633 7
		  if (record_list == &record_first)
		    {
		      /* The first record_t, not a really record_t.
		         Goto next record_t. */
		      goto next;
		    }

d643 1
a643 2
		  /* When reverse excute, the first record_end is the part of
		     current instruction. */
a699 1
next:
@


1.1.2.11
log
@2008-09-11  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_resume): Change
	"record_ops.beneath->to_resume" to "record_beneath_to_resume".
@
text
@d475 1
a475 1
      record_beneath_to_resume (ptid, 1, siggnal);
@


1.1.2.12
log
@2008-09-19  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_wait): Fix the bug of forware step after
	reverse step.
	Make debug message more clean.
	Remove variable record_list_status.

	* i386-tdep.c (i386_record): Fix the bug of "0x80 ... 0x83".
@
text
@d36 1
d449 1
d549 1
a549 8
      /* In EXEC_FORWARD mode,, record_list point to the tail of prev
         instruction. */
      if (record_execdir == EXEC_FORWARD && record_list->next)
        {
	  record_list = record_list->next;
	}

      /* Loop over the record_list, looking for the next place to stop.  */
d553 5
a557 1
	  if (record_execdir == EXEC_REVERSE && record_list == &record_first)
d559 10
a568 9
	      fprintf_unfiltered (gdb_stdlog,
				  "Record: running to the begin of record list.\n");
	      stop_soon = STOP_QUIETLY;
	      break;
	    }
	  if (record_execdir != EXEC_REVERSE && !record_list->next)
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  "Record: running to the end of record list.\n");
d572 1
d582 1
a582 2
				      "Record: record_reg 0x%s to inferior num = %d.\n",
				      paddr_nz ((CORE_ADDR)record_list),
d597 1
a597 2
				      "Record: record_mem 0x%s to inferior addr = 0x%s len = %d.\n",
				      paddr_nz ((CORE_ADDR)record_list),
d628 1
a628 2
				      "Record: record_end 0x%s to inferior need_dasm = %d.\n",
				      paddr_nz ((CORE_ADDR)record_list),
d634 7
d709 8
a716 1
	  if (continue_flag)
d718 2
a719 5
	      if (record_execdir == EXEC_REVERSE)
		{
		  if (record_list->prev)
		    record_list = record_list->prev;
		}
d721 1
a721 4
		{
		  if (record_list->next)
		    record_list = record_list->next;
		}
d723 1
@


1.1.2.13
log
@2008-09-19  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_wait): On end of record log, return
	TARGET_WAITKIND_NO_HISTORY and let infrun decide what to do.
@
text
@d554 1
a554 3
      /* Loop over the record_list, looking for the next place to
	 stop.  */
      status->kind = TARGET_WAITKIND_STOPPED;
d557 2
a558 3
	  /* Check for beginning and end of log.  */
	  if (record_execdir == EXEC_REVERSE 
	      && record_list == &record_first)
d560 3
a562 2
	      /* Hit beginning of record log in reverse.  */
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
d567 3
a569 2
	      /* Hit end of record log going forward.  */
	      status->kind = TARGET_WAITKIND_NO_HISTORY;
d725 1
@


1.1.2.14
log
@2008-09-19  Michael Snyder  <msnyder@@vmware.com>

	* record.c (trivial): Fix two commas in a comment.
@
text
@d547 2
a548 2
      /* In EXEC_FORWARD mode, record_list point to the tail of prev
         instruction.  */
@


1.1.2.15
log
@2008-10-02  Michael Snyder  <msnyder@@vmware.com>

	* record.c (record_open): Call target_can_async_p() instead
	of relying on a global variable.
	* record.h (record_linux_async_permitted): Delete.
	* linux-nat.c (record_linux_async_permitted): Delete reference.
@
text
@d51 1
d426 1
a426 1
  if (target_can_async_p ())
@


1.1.2.16
log
@2008-10-05  Michael Snyder  <msnyder@@vmware.com>

	* target.c, target.h: Rename execdir to exec_direction.
	* record.c, record.h: Ditto.
	* reverse.c: Ditto.
	* remote.c: Ditto.
@
text
@d50 1
a50 1
enum exec_direction_kind record_exec_direction = EXEC_FORWARD;
d447 1
a447 1
  record_exec_direction = EXEC_FORWARD;
d490 1
a490 1
  if (record_exec_direction == EXEC_REVERSE)
d548 1
a548 1
      if (record_exec_direction == EXEC_FORWARD && record_list->next)
d559 1
a559 1
	  if (record_exec_direction == EXEC_REVERSE 
d566 1
a566 1
	  if (record_exec_direction != EXEC_REVERSE && !record_list->next)
d634 1
a634 1
	      if (record_exec_direction == EXEC_FORWARD)
d643 1
a643 1
	      if (first_record_end && record_exec_direction == EXEC_REVERSE)
d697 1
a697 1
	      if (record_exec_direction == EXEC_REVERSE)
d706 1
a706 1
	      if (record_exec_direction == EXEC_REVERSE)
d955 1
a955 1
record_get_exec_direction (void)
d958 4
a961 4
    printf_filtered ("Record: exec_direction is %s\n",
		     record_exec_direction == EXEC_FORWARD ? "forward" :
		     record_exec_direction == EXEC_REVERSE ? "reverse" : "unknown");
  return record_exec_direction;
d965 1
a965 1
record_set_exec_direction (enum exec_direction_kind dir)
d968 1
a968 1
    printf_filtered ("Record: set exec_direction: %s\n",
d974 1
a974 1
    return (record_exec_direction = dir);
d999 2
a1000 2
  record_ops.to_get_exec_direction = record_get_exec_direction;
  record_ops.to_set_exec_direction = record_set_exec_direction;
@


1.1.2.17
log
@2008-10-04  Hui Zhu  <teawater@@gmail.com>

	Change from "to_prepare_to_store" to "to_store_registers".
	* record.c (record_beneath_to_prepare_to_store): Removed.
	(record_beneath_to_store_registers): New function pointer.
	Instead "record_beneath_to_prepare_to_store". Will point
	to the low strata target "to_store_registers" function.
	(record_prepare_to_store): Removed.
	(record_store_registers): New function.
	Instead "record_prepare_to_store". Record the change of
	registers from GDB.
	(init_record_ops): Change record_prepare_to_store to
	record_store_registers.
	* record.h (record_beneath_to_prepare_to_store): Removed.
	(record_beneath_to_store_registers): New extern.
	(record_regcache_raw_write_regnum): Remove.
	* target.c (update_current_target): Change
	record_beneath_to_prepare_to_store to
	record_beneath_to_store_registers.

2008-10-06  Michael Snyder  <msnyder@@promb-2s-dhcp59.eng.vmware.com>

	* regcache.c (regcache_raw_write): Remove global variable.
	No need to include "record.h" now.
	* record.c (record_regcache_raw_write_regnum): Remove.
@
text
@d54 1
d64 1
a64 1
void (*record_beneath_to_store_registers) (struct regcache *, int regno);
d836 3
d840 1
a840 1
record_store_registers (struct regcache *regcache, int regno)
a845 1
	  int n;
a846 1

d848 4
a851 16
	  if (regno < 0)
	    {
	      n =
		nquery (_
			("Becuse GDB is in replay mode, changing the value of a register will destroy the record from this point forward. Change all register?"));
	    }
	  else
	    {
	      n =
		nquery (_
			("Becuse GDB is in replay mode, changing the value of a register will destroy the record from this point forward. Change register %s?"),
			gdbarch_register_name (get_regcache_arch (regcache),
					       regno));
	    }

	  if (!n)
a852 17
	      /* Invalidate the value of regcache that set in function
	         "regcache_raw_write". */
	      if (regno < 0)
		{
		  int i;
		  for (i = 0;
		       i < gdbarch_num_regs (get_regcache_arch (regcache));
		       i++)
		    {
		      regcache_invalidate (regcache, i);
		    }
		}
	      else
		{
		  regcache_invalidate (regcache, regno);
		}

d860 1
a860 1
      record_registers_change (regcache, regno);
d862 1
a862 1
  record_beneath_to_store_registers (regcache, regno);
d995 1
a995 1
  record_ops.to_store_registers = record_store_registers;
@


1.1.2.18
log
@2008-10-06  Michael Snyder  <msnyder@@vmware.com>

	* record.c (displaced_step_fixup): Remove.
	(record_message_cleanups): Remove displaced step handling.
	(record_message): Remove displaced step handling.
	* infrun.c (displaced_step_ptid): Back to being static.
	(displaced_step_original, displaced_step_copy): Ditto.
@
text
@d40 3
d57 2
d329 5
d352 18
a369 1
  ret = gdbarch_record (gdbarch, regcache_read_pc (record_regcache));
@


1.1.2.19
log
@2008-10-07  Hui Zhu  <teawater@@gmail.com>

	* i386-tdep.c, inflow.c, infrun.c, linux-record.c,
	linux-record.h, record.c, record.h: Change name from
	"record and reverse target" to
	"process record and replay target".
@
text
@d1 1
a1 1
/* Process record and replay target for GDB, the GNU debugger.
d198 1
a198 1
			  "Process record: add register num = %d to record list.\n", 
d227 1
a227 1
			  "Process record: add mem addr = 0x%s len = %d to record list.\n",
d247 1
a247 1
			  "Process record: read memory addr = 0x%s len = %d error.\n",
d268 1
a268 1
			  "Process record: add end need_dasm = %d to arch list.\n",
d307 1
a307 1
		  error (_("Process record: record stop the program."));
d345 1
a345 1
    error (_("Process record pause the program."));
d347 1
a347 1
    error (_("Process record record message error."));
d385 1
a385 1
      fprintf_unfiltered (gdb_stdlog, "Process record: record_open\n");
d391 1
a391 1
      error (_("Process record: the program is not being run."));
d395 1
a395 1
      error (_("Process record can't debug inferior in non-stop mode (non-stop)."));
d399 1
a399 1
      error (_("Process record can't debug the GNU/Linux inferior in asynchronous mode (linux-async)."));
d404 1
a404 1
      error (_("Process record: the current architecture doesn't support record function."));
d407 1
a407 1
  /* Check if process record target is already running */
d411 1
a411 1
	  (_("Process record target already running, do you want delete the old record log?")))
d431 1
a431 1
      fprintf_unfiltered (gdb_stdlog, "Process record: record_close\n");
d453 1
a453 1
      fprintf_unfiltered (gdb_stdlog, "Process record: get a signal\n");
d487 1
a487 1
			  "Process record: record_wait record_resume_step = %d\n",
d510 1
a510 1
	  perror_with_name (_("Process record: sigaction"));
d553 1
a553 1
				      "Process record: record_reg 0x%s to inferior num = %d.\n",
d569 1
a569 1
				      "Process record: record_mem 0x%s to inferior addr = 0x%s len = %d.\n",
d577 1
a577 1
		  error (_("Process record: read memory addr = 0x%s len = %d error."),
d586 1
a586 1
			 ("Process record: write memory addr = 0x%s len = %d error."),
d601 1
a601 1
				      "Process record: record_end 0x%s to inferior need_dasm = %d.\n",
d632 1
a632 1
			  fprintf_unfiltered (gdb_stdlog, "Process record: step.\n");
d661 1
a661 1
						  "Process record: break at 0x%s.\n",
d694 1
a694 1
	  perror_with_name (_("Process record: sigaction"));
d717 1
a717 1
      fprintf_unfiltered (gdb_stdlog, "Process record: record_disconnect\n");
d728 1
a728 1
      fprintf_unfiltered (gdb_stdlog, "Process record: record_detach\n");
d739 1
a739 1
      fprintf_unfiltered (gdb_stdlog, "Process record: record_mourn_inferior\n");
d745 1
a745 1
/* Close process record target before kill the inferior process.  */
d751 1
a751 1
      fprintf_unfiltered (gdb_stdlog, "Process record: record_kill\n");
d777 1
a777 1
	      error (_("Process record: record message error."));
d786 1
a786 1
	  error (_("Process record: record message error."));
d792 1
a792 1
      error (_("Process record: record message error."));
d853 1
a853 1
	      error (_("Process record cancel the operation."));
d900 1
a900 1
	  fprintf_unfiltered (gdb_stdlog, _("Process record: record message error."));
d906 1
a906 1
	  fprintf_unfiltered (gdb_stdlog, _("Process record: record message error."));
d958 1
a958 1
    printf_filtered ("Process record: exec_direction is %s\n",
d968 1
a968 1
    printf_filtered ("Process record: set exec_direction: %s\n",
d983 1
a983 1
  record_ops.to_longname = "Process record and replay target";
d1009 1
a1009 1
  fprintf_filtered (file, _("Debugging of process record target is %s.\n"), value);
d1030 1
a1030 1
	  if (!from_tty || query (_("Process record: delete the log from this point forward and begin to record the running message at current PC?")))
d1037 1
a1037 1
	  printf_unfiltered (_("Process record: already at end of record list.\n"));
d1043 1
a1043 1
      printf_unfiltered (_("Process record is not started.\n"));
d1054 1
a1054 1
      if (!record_list || !from_tty || query (_("Process record: delete recorded log and stop recording?")))
d1061 1
a1061 1
      printf_unfiltered (_("Process record is not started.\n"));
d1072 1
a1072 1
      printf_unfiltered (_("Process record: record instructions number is bigger than record instructions max number.  Auto delete the first ones.\n"));
d1097 1
a1097 1
      perror_with_name (_("Process record: sigfillset"));
d1127 1
a1127 1
	   _("When process record target running in replay mode, delete the next running messages and begin to record the running message at current address."));
@


1.1.2.20
log
@2008-10-07  Michael Snyder  <msnyder@@vmware.com>

	* target.h (to_set_exec_direction, to_get_exec_direction): Remove.
	(to_can_execute_reverse): New method.
	(enum exec_direction_kind): Move to inferior.h.
	* target.c (update_current_target): Inherit to_can_execute_reverse.
	Remove to_set_exec_direction, to_get_exec_direction.
	* inferior.h (enum exec_direction_kind): Move from target.h.

	* infrun.c (set_exec_direction_func): Move here from reverse.c.
	(show_exec_direction_func): Ditto.
	(proceed): Consult global execution_direction instead of
	target method.
	(handle_inferior_event): Ditto.

	* reverse.c (set_exec_direction_func): Move to infrun.c
	(show_exec_direction_func): Ditto.
	(exec_direction_default): Set infrun global variable.
	(exec_reverse_once): Consult infrun global direction variable.

	* infcmd.c (step_1): Consult infrun global direction variable.
	(step_once): Ditto.
	(until_next_command): Ditto.
	(finish_command): Ditto.

	* record.h (record_exec_direction): Delete.
	(RECORD_IS_REPLAY): Consult infrun global direction variable.

	* record.c: (record_wait_cleanups): Use infrun state variable.
	(record_wait): Ditto.
	(record_get_exec_direction, record_set_exec_direction): Remove.
	(record_can_execute_reverse): New target method.

	* remote.c (remote_resume): Use infrun state variable.
	(remote_get_exec_direction, remote_set_exec_direction): Remove.
	(remote_can_execute_reverse): New target method.
@
text
@d47 1
d419 1
d462 1
a462 1
  if (execution_direction == EXEC_REVERSE)
d520 1
a520 1
      if (execution_direction == EXEC_FORWARD && record_list->next)
d531 1
a531 1
	  if (execution_direction == EXEC_REVERSE 
d538 1
a538 1
	  if (execution_direction != EXEC_REVERSE && !record_list->next)
d606 1
a606 1
	      if (execution_direction == EXEC_FORWARD)
d615 1
a615 1
	      if (first_record_end && execution_direction == EXEC_REVERSE)
d669 1
a669 1
	      if (execution_direction == EXEC_REVERSE)
d678 1
a678 1
	      if (execution_direction == EXEC_REVERSE)
d954 10
d965 1
a965 1
record_can_execute_reverse (void)
d967 10
a976 1
  return 1;
d999 2
a1000 1
  record_ops.to_can_execute_reverse = record_can_execute_reverse;
d1134 1
@


1.1.2.21
log
@2008-10-08  Hui Zhu  <teawater@@gmail.com>

	* record.c (record_open): Reset after push_target.
@
text
@a415 2
  push_target (&record_ops);

d420 2
@


