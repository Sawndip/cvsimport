head	1.320;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.315
	gdb_7_6-2013-04-26-release:1.315
	gdb_7_6-branch:1.315.0.2
	gdb_7_6-2013-03-12-branchpoint:1.315
	gdb_7_5_1-2012-11-29-release:1.306.2.1
	gdb_7_5-2012-08-17-release:1.306
	gdb_7_5-branch:1.306.0.2
	gdb_7_5-2012-07-18-branchpoint:1.306
	gdb_7_4_1-2012-04-26-release:1.303.2.1
	gdb_7_4-2012-01-24-release:1.303.2.1
	gdb_7_4-branch:1.303.0.2
	gdb_7_4-2011-12-13-branchpoint:1.303
	gdb_7_3_1-2011-09-04-release:1.299
	gdb_7_3-2011-07-26-release:1.299
	gdb_7_3-branch:1.299.0.2
	gdb_7_3-2011-04-01-branchpoint:1.299
	gdb_7_2-2010-09-02-release:1.285
	gdb_7_2-branch:1.285.0.2
	gdb_7_2-2010-07-07-branchpoint:1.285
	gdb_7_1-2010-03-18-release:1.279
	gdb_7_1-branch:1.279.0.2
	gdb_7_1-2010-02-18-branchpoint:1.279
	gdb_7_0_1-2009-12-22-release:1.274
	gdb_7_0-2009-10-06-release:1.274
	gdb_7_0-branch:1.274.0.2
	gdb_7_0-2009-09-16-branchpoint:1.274
	arc-sim-20090309:1.236.2.1
	msnyder-checkpoint-072509-branch:1.271.0.2
	msnyder-checkpoint-072509-branchpoint:1.271
	arc-insight_6_8-branch:1.236.2.1.0.4
	arc-insight_6_8-branchpoint:1.236.2.1
	insight_6_8-branch:1.236.2.1.0.2
	insight_6_8-branchpoint:1.236.2.1
	reverse-20081226-branch:1.256.0.2
	reverse-20081226-branchpoint:1.256
	multiprocess-20081120-branch:1.255.0.4
	multiprocess-20081120-branchpoint:1.255
	reverse-20080930-branch:1.255.0.2
	reverse-20080930-branchpoint:1.255
	reverse-20080717-branch:1.249.0.2
	reverse-20080717-branchpoint:1.249
	msnyder-reverse-20080609-branch:1.242.0.2
	msnyder-reverse-20080609-branchpoint:1.242
	drow-reverse-20070409-branch:1.224.0.2
	drow-reverse-20070409-branchpoint:1.224
	gdb_6_8-2008-03-27-release:1.236.2.1
	gdb_6_8-branch:1.236.0.2
	gdb_6_8-2008-02-26-branchpoint:1.236
	gdb_6_7_1-2007-10-29-release:1.231
	gdb_6_7-2007-10-10-release:1.231
	gdb_6_7-branch:1.231.0.2
	gdb_6_7-2007-09-07-branchpoint:1.231
	insight_6_6-20070208-release:1.215
	gdb_6_6-2006-12-18-release:1.215
	gdb_6_6-branch:1.215.0.2
	gdb_6_6-2006-11-15-branchpoint:1.215
	insight_6_5-20061003-release:1.211
	gdb-csl-symbian-6_4_50_20060226-12:1.211.2.1.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.210
	nickrob-async-20060828-mergepoint:1.213
	gdb-csl-symbian-6_4_50_20060226-11:1.211.2.1.2.1
	gdb-csl-sourcerygxx-4_1-17:1.211.2.1
	gdb-csl-20060226-branch-local-2:1.211.2.1
	gdb-csl-sourcerygxx-4_1-14:1.211.2.1
	gdb-csl-sourcerygxx-4_1-13:1.211.2.1
	gdb-csl-sourcerygxx-4_1-12:1.211.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.211.2.1
	gdb_6_5-20060621-release:1.211
	gdb-csl-sourcerygxx-4_1-9:1.211.2.1
	gdb-csl-sourcerygxx-4_1-8:1.211.2.1
	gdb-csl-sourcerygxx-4_1-7:1.211.2.1
	gdb-csl-arm-2006q1-6:1.211.2.1
	gdb-csl-sourcerygxx-4_1-6:1.211.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.211.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.211.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.211.2.1.2.1
	gdb-csl-coldfire-4_1-11:1.211.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.211.2.1
	gdb-csl-coldfire-4_1-10:1.211.2.1
	gdb_6_5-branch:1.211.0.14
	gdb_6_5-2006-05-14-branchpoint:1.211
	gdb-csl-sourcerygxx-4_1-5:1.211.2.1
	nickrob-async-20060513-branch:1.211.0.12
	nickrob-async-20060513-branchpoint:1.211
	gdb-csl-sourcerygxx-4_1-4:1.211.2.1
	msnyder-reverse-20060502-branch:1.211.0.10
	msnyder-reverse-20060502-branchpoint:1.211
	gdb-csl-morpho-4_1-4:1.211.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.211.2.1
	readline_5_1-import-branch:1.211.0.8
	readline_5_1-import-branchpoint:1.211
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.211.2.1
	gdb-csl-symbian-20060226-branch:1.211.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.211.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.211.2.1
	msnyder-reverse-20060331-branch:1.211.0.6
	msnyder-reverse-20060331-branchpoint:1.211
	gdb-csl-available-20060303-branch:1.211.0.4
	gdb-csl-available-20060303-branchpoint:1.211
	gdb-csl-20060226-branch:1.211.0.2
	gdb-csl-20060226-branchpoint:1.211
	gdb_6_4-20051202-release:1.210
	msnyder-fork-checkpoint-branch:1.210.0.10
	msnyder-fork-checkpoint-branchpoint:1.210
	gdb-csl-gxxpro-6_3-branch:1.210.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.210
	gdb_6_4-branch:1.210.0.6
	gdb_6_4-2005-11-01-branchpoint:1.210
	gdb-csl-arm-20051020-branch:1.210.0.4
	gdb-csl-arm-20051020-branchpoint:1.210
	msnyder-tracepoint-checkpoint-branch:1.210.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.210
	gdb-csl-arm-20050325-2005-q1b:1.207
	gdb-csl-arm-20050325-2005-q1a:1.207
	csl-arm-20050325-branch:1.207.0.2
	csl-arm-20050325-branchpoint:1.207
	gdb-post-i18n-errorwarning-20050211:1.201
	gdb-pre-i18n-errorwarning-20050211:1.200
	gdb_6_3-20041109-release:1.191
	gdb_6_3-branch:1.191.0.2
	gdb_6_3-20041019-branchpoint:1.191
	drow_intercu-merge-20040921:1.191
	drow_intercu-merge-20040915:1.191
	jimb-gdb_6_2-e500-branch:1.183.2.1.0.4
	jimb-gdb_6_2-e500-branchpoint:1.183.2.1
	gdb_6_2-20040730-release:1.183.2.1
	gdb_6_2-branch:1.183.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.183
	gdb_6_1_1-20040616-release:1.162
	gdb_6_1-2004-04-05-release:1.162
	drow_intercu-merge-20040402:1.167
	drow_intercu-merge-20040327:1.166
	ezannoni_pie-20040323-branch:1.166.0.2
	ezannoni_pie-20040323-branchpoint:1.166
	cagney_tramp-20040321-mergepoint:1.164
	cagney_tramp-20040309-branch:1.162.0.6
	cagney_tramp-20040309-branchpoint:1.162
	gdb_6_1-branch:1.162.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.162
	drow_intercu-20040221-branch:1.162.0.2
	drow_intercu-20040221-branchpoint:1.162
	cagney_bfdfile-20040213-branch:1.160.0.2
	cagney_bfdfile-20040213-branchpoint:1.160
	drow-cplus-merge-20040208:1.156
	carlton_dictionary-20040126-merge:1.155
	cagney_bigcore-20040122-branch:1.155.0.2
	cagney_bigcore-20040122-branchpoint:1.155
	drow-cplus-merge-20040113:1.155
	drow-cplus-merge-20031224:1.153
	drow-cplus-merge-20031220:1.153
	carlton_dictionary-20031215-merge:1.153
	drow-cplus-merge-20031214:1.153
	carlton-dictionary-20031111-merge:1.147
	gdb_6_0-2003-10-04-release:1.127.2.10
	kettenis_sparc-20030918-branch:1.141.0.2
	kettenis_sparc-20030918-branchpoint:1.141
	carlton_dictionary-20030917-merge:1.141
	ezannoni_pie-20030916-branchpoint:1.140
	ezannoni_pie-20030916-branch:1.140.0.2
	cagney_x86i386-20030821-branch:1.137.0.2
	cagney_x86i386-20030821-branchpoint:1.137
	carlton_dictionary-20030805-merge:1.134
	carlton_dictionary-20030627-merge:1.127
	gdb_6_0-branch:1.127.0.2
	gdb_6_0-2003-06-23-branchpoint:1.127
	jimb-ppc64-linux-20030613-branch:1.122.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.122
	cagney_convert-20030606-branch:1.117.0.2
	cagney_convert-20030606-branchpoint:1.117
	cagney_writestrings-20030508-branch:1.113.0.4
	cagney_writestrings-20030508-branchpoint:1.113
	jimb-ppc64-linux-20030528-branch:1.116.0.2
	jimb-ppc64-linux-20030528-branchpoint:1.116
	carlton_dictionary-20030523-merge:1.116
	cagney_fileio-20030521-branch:1.115.0.2
	cagney_fileio-20030521-branchpoint:1.115
	kettenis_i386newframe-20030517-mergepoint:1.115
	jimb-ppc64-linux-20030509-branch:1.113.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.113
	kettenis_i386newframe-20030504-mergepoint:1.110
	carlton_dictionary-20030430-merge:1.110
	kettenis_i386newframe-20030419-branch:1.108.0.2
	kettenis_i386newframe-20030419-branchpoint:1.108
	carlton_dictionary-20030416-merge:1.108
	cagney_frameaddr-20030409-mergepoint:1.105
	kettenis_i386newframe-20030406-branch:1.100.0.2
	kettenis_i386newframe-20030406-branchpoint:1.100
	cagney_frameaddr-20030403-branchpoint:1.93
	cagney_frameaddr-20030403-branch:1.93.0.2
	cagney_framebase-20030330-mergepoint:1.89
	cagney_framebase-20030326-branch:1.89.0.2
	cagney_framebase-20030326-branchpoint:1.89
	cagney_lazyid-20030317-branch:1.87.0.2
	cagney_lazyid-20030317-branchpoint:1.87
	kettenis-i386newframe-20030316-mergepoint:1.85
	offbyone-20030313-branch:1.80.0.2
	offbyone-20030313-branchpoint:1.80
	kettenis-i386newframe-20030308-branch:1.74.0.2
	kettenis-i386newframe-20030308-branchpoint:1.74
	carlton_dictionary-20030305-merge:1.73
	cagney_offbyone-20030303-branch:1.71.0.2
	cagney_offbyone-20030303-branchpoint:1.71
	carlton_dictionary-20030207-merge:1.66
	interps-20030203-mergepoint:1.66
	interps-20030202-branch:1.66.0.2
	interps-20030202-branchpoint:1.66
	cagney-unwind-20030108-branch:1.56.0.2
	cagney-unwind-20030108-branchpoint:1.56
	carlton_dictionary-20021223-merge:1.48
	gdb_5_3-2002-12-12-release:1.15.6.1
	carlton_dictionary-20021115-merge:1.25
	kseitz_interps-20021105-merge:1.20
	kseitz_interps-20021103-merge:1.20
	drow-cplus-merge-20021020:1.18
	drow-cplus-merge-20021025:1.18
	carlton_dictionary-20021025-merge:1.18
	carlton_dictionary-20021011-merge:1.18
	drow-cplus-branch:1.18.0.2
	drow-cplus-branchpoint:1.18
	kseitz_interps-20020930-merge:1.18
	carlton_dictionary-20020927-merge:1.18
	carlton_dictionary-branch:1.17.0.2
	carlton_dictionary-20020920-branchpoint:1.17
	gdb_5_3-branch:1.15.0.6
	gdb_5_3-2002-09-04-branchpoint:1.15
	kseitz_interps-20020829-merge:1.15
	cagney_sysregs-20020825-branch:1.15.0.4
	cagney_sysregs-20020825-branchpoint:1.15
	readline_4_3-import-branch:1.15.0.2
	readline_4_3-import-branchpoint:1.15
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.10.0.4
	kseitz_interps-20020528-branchpoint:1.10
	cagney_regbuf-20020515-branch:1.10.0.2
	cagney_regbuf-20020515-branchpoint:1.10
	jimb-macro-020506-branch:1.9.0.2
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.10
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.8
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.6
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.4
	gdb_5_1-2001-07-29-branchpoint:1.4
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	gdb-post-ptid_t-2001-05-03:1.4
	gdb-pre-ptid_t-2001-05-03:1.3;
locks; strict;
comment	@ * @;


1.320
date	2013.10.02.16.15.44;	author palves;	state Exp;
branches;
next	1.319;

1.319
date	2013.09.26.20.01.25;	author jkratoch;	state Exp;
branches;
next	1.318;

1.318
date	2013.05.17.08.34.18;	author pmuldoon;	state Exp;
branches;
next	1.317;

1.317
date	2013.04.10.15.11.11;	author palves;	state Exp;
branches;
next	1.316;

1.316
date	2013.04.08.19.59.08;	author tromey;	state Exp;
branches;
next	1.315;

1.315
date	2013.02.16.08.57.48;	author qiyao;	state Exp;
branches;
next	1.314;

1.314
date	2013.01.01.06.32.42;	author brobecke;	state Exp;
branches;
next	1.313;

1.313
date	2012.11.12.21.59.06;	author brobecke;	state Exp;
branches;
next	1.312;

1.312
date	2012.11.12.21.28.50;	author brobecke;	state Exp;
branches;
next	1.311;

1.311
date	2012.11.05.21.43.12;	author tromey;	state Exp;
branches;
next	1.310;

1.310
date	2012.09.17.07.15.48;	author jkratoch;	state Exp;
branches;
next	1.309;

1.309
date	2012.09.17.07.03.14;	author jkratoch;	state Exp;
branches;
next	1.308;

1.308
date	2012.08.28.14.08.41;	author qiyao;	state Exp;
branches;
next	1.307;

1.307
date	2012.08.02.09.36.38;	author qiyao;	state Exp;
branches;
next	1.306;

1.306
date	2012.03.01.20.48.56;	author palves;	state Exp;
branches
	1.306.2.1;
next	1.305;

1.305
date	2012.02.15.19.27.58;	author aristovski;	state Exp;
branches;
next	1.304;

1.304
date	2012.01.04.08.17.02;	author brobecke;	state Exp;
branches;
next	1.303;

1.303
date	2011.10.27.11.04.25;	author kpouget;	state Exp;
branches
	1.303.2.1;
next	1.302;

1.302
date	2011.10.09.19.26.42;	author jkratoch;	state Exp;
branches;
next	1.301;

1.301
date	2011.09.07.02.33.58;	author luisgpm;	state Exp;
branches;
next	1.300;

1.300
date	2011.08.04.19.10.11;	author palves;	state Exp;
branches;
next	1.299;

1.299
date	2011.03.18.18.52.30;	author palves;	state Exp;
branches;
next	1.298;

1.298
date	2011.03.18.18.45.30;	author palves;	state Exp;
branches;
next	1.297;

1.297
date	2011.03.18.18.44.33;	author palves;	state Exp;
branches;
next	1.296;

1.296
date	2011.03.18.18.42.41;	author palves;	state Exp;
branches;
next	1.295;

1.295
date	2011.03.18.18.41.36;	author palves;	state Exp;
branches;
next	1.294;

1.294
date	2011.03.18.18.38.42;	author palves;	state Exp;
branches;
next	1.293;

1.293
date	2011.03.15.19.28.59;	author msnyder;	state Exp;
branches;
next	1.292;

1.292
date	2011.03.09.14.22.09;	author tromey;	state Exp;
branches;
next	1.291;

1.291
date	2011.01.07.19.36.17;	author msnyder;	state Exp;
branches;
next	1.290;

1.290
date	2011.01.05.22.22.48;	author msnyder;	state Exp;
branches;
next	1.289;

1.289
date	2011.01.03.13.11.03;	author jkratoch;	state Exp;
branches;
next	1.288;

1.288
date	2011.01.01.15.33.04;	author brobecke;	state Exp;
branches;
next	1.287;

1.287
date	2010.08.11.13.24.32;	author jkratoch;	state Exp;
branches;
next	1.286;

1.286
date	2010.08.11.13.22.57;	author jkratoch;	state Exp;
branches;
next	1.285;

1.285
date	2010.07.01.15.36.15;	author palves;	state Exp;
branches;
next	1.284;

1.284
date	2010.06.14.12.10.56;	author uweigand;	state Exp;
branches;
next	1.283;

1.283
date	2010.05.14.19.27.05;	author msnyder;	state Exp;
branches;
next	1.282;

1.282
date	2010.05.13.21.36.08;	author msnyder;	state Exp;
branches;
next	1.281;

1.281
date	2010.05.07.00.47.37;	author msnyder;	state Exp;
branches;
next	1.280;

1.280
date	2010.04.16.01.12.07;	author shebs;	state Exp;
branches;
next	1.279;

1.279
date	2010.01.28.22.07.58;	author drow;	state Exp;
branches;
next	1.278;

1.278
date	2010.01.01.07.31.31;	author brobecke;	state Exp;
branches;
next	1.277;

1.277
date	2009.11.02.14.50.27;	author jkratoch;	state Exp;
branches;
next	1.276;

1.276
date	2009.10.23.14.31.33;	author gingold;	state Exp;
branches;
next	1.275;

1.275
date	2009.10.19.09.51.40;	author palves;	state Exp;
branches;
next	1.274;

1.274
date	2009.09.13.16.28.28;	author brobecke;	state Exp;
branches;
next	1.273;

1.273
date	2009.09.09.17.39.20;	author brobecke;	state Exp;
branches;
next	1.272;

1.272
date	2009.09.02.14.53.55;	author tromey;	state Exp;
branches;
next	1.271;

1.271
date	2009.07.02.17.25.53;	author uweigand;	state Exp;
branches;
next	1.270;

1.270
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.269;

1.269
date	2009.07.02.17.09.28;	author uweigand;	state Exp;
branches;
next	1.268;

1.268
date	2009.06.28.00.20.22;	author drow;	state Exp;
branches;
next	1.267;

1.267
date	2009.06.28.00.05.14;	author drow;	state Exp;
branches;
next	1.266;

1.266
date	2009.05.28.00.53.51;	author tromey;	state Exp;
branches;
next	1.265;

1.265
date	2009.03.25.21.42.34;	author palves;	state Exp;
branches;
next	1.264;

1.264
date	2009.03.17.17.26.52;	author brobecke;	state Exp;
branches;
next	1.263;

1.263
date	2009.02.21.16.14.47;	author palves;	state Exp;
branches;
next	1.262;

1.262
date	2009.02.05.17.28.20;	author palves;	state Exp;
branches;
next	1.261;

1.261
date	2009.01.26.19.09.58;	author palves;	state Exp;
branches;
next	1.260;

1.260
date	2009.01.24.19.17.24;	author palves;	state Exp;
branches;
next	1.259;

1.259
date	2009.01.19.19.05.00;	author devans;	state Exp;
branches;
next	1.258;

1.258
date	2009.01.15.15.38.57;	author uweigand;	state Exp;
branches;
next	1.257;

1.257
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.256;

1.256
date	2008.11.20.22.16.16;	author devans;	state Exp;
branches;
next	1.255;

1.255
date	2008.09.24.12.59.49;	author schwab;	state Exp;
branches
	1.255.4.1;
next	1.254;

1.254
date	2008.09.24.12.17.20;	author schwab;	state Exp;
branches;
next	1.253;

1.253
date	2008.09.22.13.36.29;	author ams;	state Exp;
branches;
next	1.252;

1.252
date	2008.09.19.18.12.17;	author ams;	state Exp;
branches;
next	1.251;

1.251
date	2008.08.26.17.40.24;	author uweigand;	state Exp;
branches;
next	1.250;

1.250
date	2008.08.21.20.13.08;	author uweigand;	state Exp;
branches;
next	1.249;

1.249
date	2008.07.15.23.29.24;	author drow;	state Exp;
branches;
next	1.248;

1.248
date	2008.07.15.18.58.32;	author drow;	state Exp;
branches;
next	1.247;

1.247
date	2008.07.15.18.50.15;	author drow;	state Exp;
branches;
next	1.246;

1.246
date	2008.07.15.18.40.03;	author drow;	state Exp;
branches;
next	1.245;

1.245
date	2008.07.15.18.32.05;	author drow;	state Exp;
branches;
next	1.244;

1.244
date	2008.07.09.22.16.14;	author palves;	state Exp;
branches;
next	1.243;

1.243
date	2008.06.30.17.59.03;	author drow;	state Exp;
branches;
next	1.242;

1.242
date	2008.05.20.22.21.19;	author palves;	state Exp;
branches;
next	1.241;

1.241
date	2008.05.09.03.52.11;	author brobecke;	state Exp;
branches;
next	1.240;

1.240
date	2008.05.03.23.24.17;	author bauermann;	state Exp;
branches;
next	1.239;

1.239
date	2008.04.30.21.16.45;	author drow;	state Exp;
branches;
next	1.238;

1.238
date	2008.03.13.12.22.12;	author drow;	state Exp;
branches;
next	1.237;

1.237
date	2008.02.28.16.24.24;	author drow;	state Exp;
branches;
next	1.236;

1.236
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches
	1.236.2.1;
next	1.235;

1.235
date	2007.11.02.14.47.27;	author uweigand;	state Exp;
branches;
next	1.234;

1.234
date	2007.10.17.13.36.43;	author drow;	state Exp;
branches;
next	1.233;

1.233
date	2007.10.09.18.14.09;	author uweigand;	state Exp;
branches;
next	1.232;

1.232
date	2007.09.24.21.34.58;	author drow;	state Exp;
branches;
next	1.231;

1.231
date	2007.08.23.18.08.31;	author brobecke;	state Exp;
branches;
next	1.230;

1.230
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.229;

1.229
date	2007.06.16.17.16.25;	author uweigand;	state Exp;
branches;
next	1.228;

1.228
date	2007.06.12.15.21.26;	author schwab;	state Exp;
branches;
next	1.227;

1.227
date	2007.06.06.15.26.28;	author uweigand;	state Exp;
branches;
next	1.226;

1.226
date	2007.05.14.15.16.57;	author uweigand;	state Exp;
branches;
next	1.225;

1.225
date	2007.05.06.19.37.30;	author uweigand;	state Exp;
branches;
next	1.224;

1.224
date	2007.03.13.14.05.25;	author froydnj;	state Exp;
branches;
next	1.223;

1.223
date	2007.02.28.17.34.58;	author drow;	state Exp;
branches;
next	1.222;

1.222
date	2007.02.27.20.17.18;	author drow;	state Exp;
branches;
next	1.221;

1.221
date	2007.02.27.19.46.04;	author drow;	state Exp;
branches;
next	1.220;

1.220
date	2007.01.13.19.44.42;	author kettenis;	state Exp;
branches;
next	1.219;

1.219
date	2007.01.11.17.18.22;	author drow;	state Exp;
branches;
next	1.218;

1.218
date	2007.01.09.20.19.15;	author drow;	state Exp;
branches;
next	1.217;

1.217
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.216;

1.216
date	2007.01.08.17.34.12;	author uweigand;	state Exp;
branches;
next	1.215;

1.215
date	2006.11.10.20.11.35;	author drow;	state Exp;
branches;
next	1.214;

1.214
date	2006.10.18.19.52.05;	author drow;	state Exp;
branches;
next	1.213;

1.213
date	2006.08.08.21.32.37;	author brobecke;	state Exp;
branches;
next	1.212;

1.212
date	2006.07.31.17.33.30;	author fnf;	state Exp;
branches;
next	1.211;

1.211
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches
	1.211.2.1
	1.211.4.1
	1.211.12.1;
next	1.210;

1.210
date	2005.05.28.22.51.37;	author drow;	state Exp;
branches;
next	1.209;

1.209
date	2005.05.22.14.53.33;	author cagney;	state Exp;
branches;
next	1.208;

1.208
date	2005.05.19.16.37.09;	author cagney;	state Exp;
branches;
next	1.207;

1.207
date	2005.02.24.13.51.31;	author cagney;	state Exp;
branches;
next	1.206;

1.206
date	2005.02.18.18.58.55;	author cagney;	state Exp;
branches;
next	1.205;

1.205
date	2005.02.17.13.49.50;	author cagney;	state Exp;
branches;
next	1.204;

1.204
date	2005.02.15.15.49.09;	author cagney;	state Exp;
branches;
next	1.203;

1.203
date	2005.02.14.16.18.40;	author cagney;	state Exp;
branches;
next	1.202;

1.202
date	2005.02.11.18.13.49;	author cagney;	state Exp;
branches;
next	1.201;

1.201
date	2005.02.11.04.05.48;	author cagney;	state Exp;
branches;
next	1.200;

1.200
date	2005.02.10.17.32.48;	author cagney;	state Exp;
branches;
next	1.199;

1.199
date	2005.01.14.23.27.13;	author cagney;	state Exp;
branches;
next	1.198;

1.198
date	2005.01.12.18.31.31;	author cagney;	state Exp;
branches;
next	1.197;

1.197
date	2004.12.12.16.26.17;	author cagney;	state Exp;
branches;
next	1.196;

1.196
date	2004.12.08.01.56.16;	author tausq;	state Exp;
branches;
next	1.195;

1.195
date	2004.11.10.23.26.33;	author tausq;	state Exp;
branches;
next	1.194;

1.194
date	2004.11.10.21.17.56;	author tausq;	state Exp;
branches;
next	1.193;

1.193
date	2004.11.09.01.16.42;	author cagney;	state Exp;
branches;
next	1.192;

1.192
date	2004.10.29.20.23.06;	author cagney;	state Exp;
branches;
next	1.191;

1.191
date	2004.09.01.14.13.33;	author cagney;	state Exp;
branches;
next	1.190;

1.190
date	2004.08.02.03.36.24;	author cagney;	state Exp;
branches;
next	1.189;

1.189
date	2004.08.01.21.47.18;	author cagney;	state Exp;
branches;
next	1.188;

1.188
date	2004.07.31.21.41.50;	author cagney;	state Exp;
branches;
next	1.187;

1.187
date	2004.07.28.17.26.26;	author cagney;	state Exp;
branches;
next	1.186;

1.186
date	2004.07.26.14.52.59;	author cagney;	state Exp;
branches;
next	1.185;

1.185
date	2004.07.20.19.45.05;	author cagney;	state Exp;
branches;
next	1.184;

1.184
date	2004.07.16.19.00.12;	author cagney;	state Exp;
branches;
next	1.183;

1.183
date	2004.06.27.20.45.05;	author uweigand;	state Exp;
branches
	1.183.2.1;
next	1.182;

1.182
date	2004.06.10.13.22.05;	author cagney;	state Exp;
branches;
next	1.181;

1.181
date	2004.05.08.19.03.04;	author cagney;	state Exp;
branches;
next	1.180;

1.180
date	2004.05.08.18.47.20;	author cagney;	state Exp;
branches;
next	1.179;

1.179
date	2004.05.07.23.19.14;	author kettenis;	state Exp;
branches;
next	1.178;

1.178
date	2004.05.01.22.41.34;	author cagney;	state Exp;
branches;
next	1.177;

1.177
date	2004.05.01.19.35.22;	author cagney;	state Exp;
branches;
next	1.176;

1.176
date	2004.05.01.19.02.11;	author cagney;	state Exp;
branches;
next	1.175;

1.175
date	2004.05.01.00.52.36;	author cagney;	state Exp;
branches;
next	1.174;

1.174
date	2004.04.30.20.44.58;	author cagney;	state Exp;
branches;
next	1.173;

1.173
date	2004.04.26.09.49.35;	author orjanf;	state Exp;
branches;
next	1.172;

1.172
date	2004.04.21.23.52.20;	author cagney;	state Exp;
branches;
next	1.171;

1.171
date	2004.04.17.00.48.25;	author jsm;	state Exp;
branches;
next	1.170;

1.170
date	2004.04.02.22.58.56;	author cagney;	state Exp;
branches;
next	1.169;

1.169
date	2004.04.02.20.21.07;	author cagney;	state Exp;
branches;
next	1.168;

1.168
date	2004.04.02.19.44.25;	author cagney;	state Exp;
branches;
next	1.167;

1.167
date	2004.03.31.19.40.27;	author cagney;	state Exp;
branches;
next	1.166;

1.166
date	2004.03.23.14.47.55;	author cagney;	state Exp;
branches;
next	1.165;

1.165
date	2004.03.22.15.36.46;	author cagney;	state Exp;
branches;
next	1.164;

1.164
date	2004.03.21.22.28.52;	author cagney;	state Exp;
branches;
next	1.163;

1.163
date	2004.03.17.23.43.36;	author cagney;	state Exp;
branches;
next	1.162;

1.162
date	2004.02.16.21.49.21;	author cagney;	state Exp;
branches
	1.162.2.1
	1.162.6.1;
next	1.161;

1.161
date	2004.02.14.17.00.59;	author cagney;	state Exp;
branches;
next	1.160;

1.160
date	2004.02.12.00.17.52;	author fnf;	state Exp;
branches;
next	1.159;

1.159
date	2004.02.09.04.10.58;	author cagney;	state Exp;
branches;
next	1.158;

1.158
date	2004.02.08.19.34.17;	author cagney;	state Exp;
branches;
next	1.157;

1.157
date	2004.02.08.18.53.15;	author cagney;	state Exp;
branches;
next	1.156;

1.156
date	2004.02.04.16.34.51;	author drow;	state Exp;
branches;
next	1.155;

1.155
date	2004.01.11.16.52.16;	author kettenis;	state Exp;
branches;
next	1.154;

1.154
date	2004.01.05.20.33.35;	author kettenis;	state Exp;
branches;
next	1.153;

1.153
date	2003.12.10.17.40.42;	author brobecke;	state Exp;
branches;
next	1.152;

1.152
date	2003.11.23.21.49.12;	author cagney;	state Exp;
branches;
next	1.151;

1.151
date	2003.11.23.02.48.40;	author cagney;	state Exp;
branches;
next	1.150;

1.150
date	2003.11.23.00.27.54;	author cagney;	state Exp;
branches;
next	1.149;

1.149
date	2003.11.22.23.00.37;	author cagney;	state Exp;
branches;
next	1.148;

1.148
date	2003.11.19.17.35.46;	author kettenis;	state Exp;
branches;
next	1.147;

1.147
date	2003.10.24.17.37.03;	author cagney;	state Exp;
branches;
next	1.146;

1.146
date	2003.10.17.16.32.17;	author jjohnstn;	state Exp;
branches;
next	1.145;

1.145
date	2003.10.02.20.28.29;	author cagney;	state Exp;
branches;
next	1.144;

1.144
date	2003.09.30.19.12.18;	author cagney;	state Exp;
branches;
next	1.143;

1.143
date	2003.09.28.22.32.19;	author cagney;	state Exp;
branches;
next	1.142;

1.142
date	2003.09.25.20.44.01;	author cagney;	state Exp;
branches;
next	1.141;

1.141
date	2003.09.17.14.24.29;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2003.09.12.18.40.16;	author cagney;	state Exp;
branches;
next	1.138;

1.138
date	2003.09.08.18.56.03;	author drow;	state Exp;
branches;
next	1.137;

1.137
date	2003.08.12.17.45.13;	author cagney;	state Exp;
branches;
next	1.136;

1.136
date	2003.08.10.14.56.23;	author kettenis;	state Exp;
branches;
next	1.135;

1.135
date	2003.08.09.15.10.08;	author cagney;	state Exp;
branches;
next	1.134;

1.134
date	2003.08.04.15.42.43;	author cagney;	state Exp;
branches;
next	1.133;

1.133
date	2003.07.15.17.35.00;	author cagney;	state Exp;
branches;
next	1.132;

1.132
date	2003.07.15.17.23.31;	author cagney;	state Exp;
branches;
next	1.131;

1.131
date	2003.07.11.14.52.17;	author cagney;	state Exp;
branches;
next	1.130;

1.130
date	2003.07.07.20.07.12;	author cagney;	state Exp;
branches;
next	1.129;

1.129
date	2003.07.07.14.36.57;	author cagney;	state Exp;
branches;
next	1.128;

1.128
date	2003.06.29.13.27.26;	author cagney;	state Exp;
branches;
next	1.127;

1.127
date	2003.06.21.16.51.47;	author cagney;	state Exp;
branches
	1.127.2.1;
next	1.126;

1.126
date	2003.06.21.16.26.02;	author cagney;	state Exp;
branches;
next	1.125;

1.125
date	2003.06.16.20.05.55;	author cagney;	state Exp;
branches;
next	1.124;

1.124
date	2003.06.16.16.47.41;	author cagney;	state Exp;
branches;
next	1.123;

1.123
date	2003.06.14.22.35.23;	author cagney;	state Exp;
branches;
next	1.122;

1.122
date	2003.06.13.20.37.27;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2003.06.09.22.20.43;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2003.06.09.02.10.34;	author cagney;	state Exp;
branches;
next	1.119;

1.119
date	2003.06.09.01.02.06;	author cagney;	state Exp;
branches;
next	1.118;

1.118
date	2003.06.08.18.27.13;	author cagney;	state Exp;
branches;
next	1.117;

1.117
date	2003.06.03.18.53.37;	author cagney;	state Exp;
branches
	1.117.2.1;
next	1.116;

1.116
date	2003.05.22.18.37.05;	author cagney;	state Exp;
branches;
next	1.115;

1.115
date	2003.05.15.19.04.29;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2003.05.13.19.27.27;	author cagney;	state Exp;
branches;
next	1.113;

1.113
date	2003.05.08.20.52.47;	author cagney;	state Exp;
branches
	1.113.4.1;
next	1.112;

1.112
date	2003.05.08.15.34.12;	author kevinb;	state Exp;
branches;
next	1.111;

1.111
date	2003.05.05.18.33.10;	author cagney;	state Exp;
branches;
next	1.110;

1.110
date	2003.04.29.01.49.46;	author cagney;	state Exp;
branches;
next	1.109;

1.109
date	2003.04.21.19.34.02;	author cagney;	state Exp;
branches;
next	1.108;

1.108
date	2003.04.16.14.39.47;	author cagney;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2003.04.13.00.10.22;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2003.04.12.04.27.29;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2003.04.10.15.32.27;	author cagney;	state Exp;
branches;
next	1.104;

1.104
date	2003.04.10.03.30.36;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2003.04.09.20.49.22;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2003.04.09.18.24.00;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2003.04.06.18.36.23;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2003.04.06.01.13.58;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2003.04.05.18.54.38;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2003.04.05.15.49.54;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2003.04.05.15.39.33;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2003.04.05.03.55.59;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2003.04.04.21.04.33;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2003.04.04.14.46.00;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2003.04.01.19.11.01;	author cagney;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2003.04.01.15.26.08;	author corinna;	state Exp;
branches;
next	1.91;

1.91
date	2003.03.31.19.01.19;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2003.03.30.16.16.25;	author cagney;	state Exp;
branches;
next	1.89;

1.89
date	2003.03.26.00.00.07;	author cagney;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2003.03.24.03.54.47;	author cagney;	state Exp;
branches;
next	1.87;

1.87
date	2003.03.17.14.23.49;	author cagney;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2003.03.16.20.47.40;	author cagney;	state Exp;
branches;
next	1.85;

1.85
date	2003.03.14.20.34.14;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2003.03.14.17.07.00;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2003.03.14.16.05.35;	author cagney;	state Exp;
branches;
next	1.82;

1.82
date	2003.03.13.21.45.39;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2003.03.13.18.09.29;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2003.03.12.23.55.36;	author cagney;	state Exp;
branches
	1.80.2.1;
next	1.79;

1.79
date	2003.03.12.22.39.16;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2003.03.12.16.50.43;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2003.03.12.15.39.30;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2003.03.11.17.47.13;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2003.03.10.15.28.40;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2003.03.05.23.14.17;	author cagney;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2003.03.05.20.26.46;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2003.03.05.18.51.17;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2003.03.02.04.02.22;	author cagney;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2003.03.02.00.11.42;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2003.02.25.23.52.16;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2003.02.25.23.12.22;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.02.20.16.35.51;	author kevinb;	state Exp;
branches;
next	1.66;

1.66
date	2003.02.02.20.31.43;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2003.02.02.18.53.22;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2003.01.29.18.07.06;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2003.01.27.21.41.40;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2003.01.21.19.32.42;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2003.01.19.23.27.27;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2003.01.19.17.39.16;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2003.01.18.17.25.23;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2003.01.16.16.54.57;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2003.01.13.21.10.29;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2003.01.09.18.53.20;	author cagney;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2003.01.07.22.53.09;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2003.01.07.19.19.00;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2003.01.07.16.29.22;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2003.01.07.16.22.29;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2003.01.06.21.50.25;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2003.01.05.01.39.54;	author drow;	state Exp;
branches;
next	1.49;

1.49
date	2003.01.04.13.55.30;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2002.12.18.18.03.41;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2002.12.13.23.18.56;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2002.12.13.21.57.40;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2002.12.13.16.40.25;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2002.12.13.16.26.02;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2002.12.13.16.11.32;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2002.12.12.00.56.44;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2002.12.11.20.35.42;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2002.12.11.02.26.35;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2002.12.09.02.04.16;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2002.12.06.19.26.03;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.12.04.00.05.53;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2002.12.01.19.07.14;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.29.19.15.14;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.29.01.52.02;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.28.21.38.43;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.24.19.48.12;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.24.15.41.59;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.24.15.06.08;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.19.00.46.00;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.18.22.19.27;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.16.01.00.06;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.15.22.16.25;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.09.18.14.10;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.09.17.45.17;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.08.23.12.52;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.08.20.48.55;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.05.21.44.05;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.31.20.14.33;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.25.20.30.37;	author cagney;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2002.09.17.20.42.01;	author cagney;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2002.09.13.22.53.36;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.21.03.34.22;	author cagney;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	2002.08.06.22.42.56;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.10.23.25.50;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.08.18.57.38;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.01.20.44.21;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.15.01.01.56;	author cagney;	state Exp;
branches
	1.10.2.1
	1.10.4.1;
next	1.9;

1.9
date	2002.04.21.15.52.34;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.20.23.54.28;	author thorpej;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.17.21.55.12;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.12.18.18.57;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.09.22.14.39;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.04.04.15.24;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.06.08.21.07;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.20.22.39.03;	author cagney;	state Exp;
branches;
next	;

1.306.2.1
date	2012.09.17.07.17.27;	author jkratoch;	state Exp;
branches;
next	;

1.303.2.1
date	2012.01.06.04.43.12;	author brobecke;	state Exp;
branches;
next	;

1.255.4.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	1.255.4.2;

1.255.4.2
date	2008.11.25.20.45.08;	author palves;	state Exp;
branches;
next	;

1.236.2.1
date	2008.03.04.20.05.27;	author brobecke;	state Exp;
branches;
next	;

1.211.2.1
date	2006.04.03.00.47.39;	author drow;	state Exp;
branches
	1.211.2.1.2.1;
next	;

1.211.2.1.2.1
date	2006.05.10.18.34.29;	author drow;	state Exp;
branches;
next	;

1.211.4.1
date	2006.04.02.02.35.32;	author drow;	state Exp;
branches;
next	;

1.211.12.1
date	2006.08.28.07.48.49;	author nickrob;	state Exp;
branches;
next	;

1.183.2.1
date	2004.07.16.19.02.45;	author cagney;	state Exp;
branches;
next	;

1.162.2.1
date	2004.03.27.17.37.46;	author drow;	state Exp;
branches;
next	1.162.2.2;

1.162.2.2
date	2004.04.02.16.47.46;	author drow;	state Exp;
branches;
next	1.162.2.3;

1.162.2.3
date	2004.09.16.17.01.03;	author drow;	state Exp;
branches;
next	;

1.162.6.1
date	2004.03.09.22.58.58;	author cagney;	state Exp;
branches;
next	1.162.6.2;

1.162.6.2
date	2004.03.16.16.05.54;	author cagney;	state Exp;
branches;
next	1.162.6.3;

1.162.6.3
date	2004.03.21.23.57.34;	author cagney;	state Exp;
branches;
next	1.162.6.4;

1.162.6.4
date	2004.03.22.03.15.23;	author cagney;	state Exp;
branches;
next	;

1.127.2.1
date	2003.06.29.13.27.56;	author cagney;	state Exp;
branches;
next	1.127.2.2;

1.127.2.2
date	2003.07.07.20.07.44;	author cagney;	state Exp;
branches;
next	1.127.2.3;

1.127.2.3
date	2003.07.11.14.54.14;	author cagney;	state Exp;
branches;
next	1.127.2.4;

1.127.2.4
date	2003.07.15.17.32.14;	author cagney;	state Exp;
branches;
next	1.127.2.5;

1.127.2.5
date	2003.07.15.17.45.29;	author cagney;	state Exp;
branches;
next	1.127.2.6;

1.127.2.6
date	2003.08.04.15.55.07;	author cagney;	state Exp;
branches;
next	1.127.2.7;

1.127.2.7
date	2003.08.09.15.10.35;	author cagney;	state Exp;
branches;
next	1.127.2.8;

1.127.2.8
date	2003.08.10.14.59.28;	author kettenis;	state Exp;
branches;
next	1.127.2.9;

1.127.2.9
date	2003.08.12.17.48.50;	author cagney;	state Exp;
branches;
next	1.127.2.10;

1.127.2.10
date	2003.09.08.18.58.13;	author drow;	state Exp;
branches;
next	;

1.117.2.1
date	2003.06.06.18.02.28;	author cagney;	state Exp;
branches;
next	;

1.113.4.1
date	2003.06.03.20.54.35;	author cagney;	state Exp;
branches;
next	;

1.108.2.1
date	2003.05.04.11.37.41;	author kettenis;	state Exp;
branches;
next	1.108.2.2;

1.108.2.2
date	2003.05.18.09.44.06;	author kettenis;	state Exp;
branches;
next	;

1.93.2.1
date	2003.04.03.17.01.48;	author cagney;	state Exp;
branches;
next	1.93.2.2;

1.93.2.2
date	2003.04.04.04.25.35;	author cagney;	state Exp;
branches;
next	1.93.2.3;

1.93.2.3
date	2003.04.10.21.33.48;	author cagney;	state Exp;
branches;
next	;

1.89.2.1
date	2003.03.26.20.33.47;	author cagney;	state Exp;
branches;
next	;

1.87.2.1
date	2003.03.17.16.17.56;	author cagney;	state Exp;
branches;
next	;

1.80.2.1
date	2003.03.13.17.33.52;	author cagney;	state Exp;
branches;
next	1.80.2.2;

1.80.2.2
date	2003.03.13.21.43.34;	author cagney;	state Exp;
branches;
next	;

1.74.2.1
date	2003.03.16.14.01.48;	author kettenis;	state Exp;
branches;
next	;

1.71.2.1
date	2003.03.03.21.19.03;	author cagney;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2003.03.04.23.15.23;	author cagney;	state Exp;
branches;
next	1.71.2.3;

1.71.2.3
date	2003.03.05.05.00.03;	author cagney;	state Exp;
branches;
next	1.71.2.4;

1.71.2.4
date	2003.03.06.19.21.30;	author cagney;	state Exp;
branches;
next	1.71.2.5;

1.71.2.5
date	2003.03.07.14.24.29;	author cagney;	state Exp;
branches;
next	1.71.2.6;

1.71.2.6
date	2003.03.10.21.00.55;	author cagney;	state Exp;
branches;
next	1.71.2.7;

1.71.2.7
date	2003.03.11.23.00.26;	author cagney;	state Exp;
branches;
next	;

1.56.2.1
date	2003.01.10.15.22.39;	author cagney;	state Exp;
branches;
next	1.56.2.2;

1.56.2.2
date	2003.01.10.21.56.43;	author cagney;	state Exp;
branches;
next	1.56.2.3;

1.56.2.3
date	2003.01.12.00.06.19;	author cagney;	state Exp;
branches;
next	1.56.2.4;

1.56.2.4
date	2003.01.13.17.03.53;	author cagney;	state Exp;
branches;
next	1.56.2.5;

1.56.2.5
date	2003.01.13.21.14.01;	author cagney;	state Exp;
branches;
next	1.56.2.6;

1.56.2.6
date	2003.01.19.18.56.32;	author cagney;	state Exp;
branches;
next	1.56.2.7;

1.56.2.7
date	2003.01.20.00.38.14;	author cagney;	state Exp;
branches;
next	1.56.2.8;

1.56.2.8
date	2003.01.23.20.29.39;	author cagney;	state Exp;
branches;
next	;

1.18.2.1
date	2003.12.14.20.27.14;	author drow;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2004.01.13.16.11.56;	author drow;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2004.02.09.19.43.38;	author drow;	state Exp;
branches;
next	;

1.17.2.1
date	2002.09.27.20.03.06;	author carlton;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.11.15.19.18.43;	author carlton;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2002.12.23.19.38.23;	author carlton;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2003.02.07.19.17.48;	author carlton;	state Exp;
branches;
next	1.17.2.5;

1.17.2.5
date	2003.03.06.00.56.27;	author carlton;	state Exp;
branches;
next	1.17.2.6;

1.17.2.6
date	2003.04.16.19.56.52;	author carlton;	state Exp;
branches;
next	1.17.2.7;

1.17.2.7
date	2003.05.01.00.46.48;	author carlton;	state Exp;
branches;
next	1.17.2.8;

1.17.2.8
date	2003.05.23.18.40.37;	author carlton;	state Exp;
branches;
next	1.17.2.9;

1.17.2.9
date	2003.06.27.21.49.55;	author carlton;	state Exp;
branches;
next	1.17.2.10;

1.17.2.10
date	2003.08.05.17.13.06;	author carlton;	state Exp;
branches;
next	1.17.2.11;

1.17.2.11
date	2003.09.17.21.28.17;	author carlton;	state Exp;
branches;
next	1.17.2.12;

1.17.2.12
date	2003.11.11.23.50.43;	author carlton;	state Exp;
branches;
next	1.17.2.13;

1.17.2.13
date	2003.12.16.00.00.30;	author carlton;	state Exp;
branches;
next	1.17.2.14;

1.17.2.14
date	2004.01.26.19.11.23;	author carlton;	state Exp;
branches;
next	;

1.15.6.1
date	2002.09.25.20.43.21;	author cagney;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.15.16.42.51;	author cagney;	state Exp;
branches;
next	;

1.10.4.1
date	2002.06.20.01.32.25;	author kseitz;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2002.08.09.18.34.24;	author kseitz;	state Exp;
branches;
next	1.10.4.3;

1.10.4.3
date	2002.08.30.22.52.43;	author kseitz;	state Exp;
branches;
next	1.10.4.4;

1.10.4.4
date	2002.10.01.00.46.07;	author kseitz;	state Exp;
branches;
next	1.10.4.5;

1.10.4.5
date	2002.11.04.00.17.30;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.320
log
@Print registers not saved in the frame as "<not saved>" instead of "<optimized out>".

Currently, in some scenarios, GDB prints <optimized out> when printing
outer frame registers.  An <optimized out> register is a confusing
concept.  What this really means is that the register is
call-clobbered, or IOW, not saved by the callee.  This patch makes GDB
say that instead.

Before patch:

 (gdb) p/x $rax $1 = <optimized out>
 (gdb) info registers rax
 rax            <optimized out>

After patch:

 (gdb) p/x $rax
 $1 = <not saved>
 (gdb) info registers rax
 rax            <not saved>

However, if for some reason the debug info describes a variable as
being in such a register (**), we still want to print <optimized out>
when printing the variable.  IOW, <not saved> is reserved for
inspecting registers at the machine level.  The patch uses
lval_register+optimized_out to encode the not saved registers, and
makes it so that optimized out variables always end up in
!lval_register values.

** See <https://sourceware.org/ml/gdb-patches/2012-08/msg00787.html>.
Current/recent enough GCC doesn't mark variables/arguments as being in
call-clobbered registers in the ranges corresponding to function
calls, while older GCCs did.  Newer GCCs will just not say where the
variable is, so GDB will end up realizing the variable is optimized
out.

frame_unwind_got_optimized creates not_lval optimized out registers,
so by default, in most cases, we'll see <optimized out>.

value_of_register is the function eval.c uses for evaluating
OP_REGISTER (again, $pc, etc.), and related bits.  It isn't used for
anything else.  This function makes sure to return lval_register
values.  The patch makes "info registers" and the MI equivalent use it
too.  I think it just makes a lot of sense, as this makes it so that
when printing machine registers ($pc, etc.), we go through a central
function.

We're likely to need a different encoding at some point, if/when we
support partially saved registers.  Even then, I think
value_of_register will still be the spot to tag the intention to print
machine register values differently.

value_from_register however may also return optimized out
lval_register values, so at a couple places where we're computing a
variable's location from a dwarf expression, we convert the resulting
value away from lval_register to a regular optimized out value.

Tested on x86_64 Fedora 17

gdb/
2013-10-02  Pedro Alves  <palves@@redhat.com>

	* cp-valprint.c (cp_print_value_fields): Adjust calls to
	val_print_optimized_out.
	* jv-valprint.c (java_print_value_fields): Likewise.
	* p-valprint.c (pascal_object_print_value_fields): Likewise.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full)
	<DWARF_VALUE_REGISTER>: If the register was not saved, return a
	new optimized out value.
	* findvar.c (address_from_register): Likewise.
	* frame.c (put_frame_register): Tweak error string to say the
	register was not saved, rather than optimized out.
	* infcmd.c (default_print_one_register_info): Adjust call to
	val_print_optimized_out.  Use value_of_register instead of
	get_frame_register_value.
	* mi/mi-main.c (output_register): Use value_of_register instead of
	get_frame_register_value.
	* valprint.c (valprint_check_validity): Likewise.
	(val_print_optimized_out): New value parameter.  If the value is
	lval_register, print <not saved> instead.
	(value_check_printable, val_print_scalar_formatted): Adjust calls
	to val_print_optimized_out.
	* valprint.h (val_print_optimized_out): New value parameter.
	* value.c (struct value) <optimized_out>: Extend comment.
	(error_value_optimized_out): New function.
	(require_not_optimized_out): Use it.  Use a different string for
	lval_register values.
	* value.h (error_value_optimized_out): New declaration.
	* NEWS: Mention <not saved>.

gdb/testsuite/
2013-10-02  Pedro Alves  <palves@@redhat.com>

	* gdb.dwarf2/dw2-reg-undefined.exp <pattern_rax_rbx_rcx_print,
	pattern_rax_rbx_rcx_info>: Set to "<not saved>".
	* gdb.mi/mi-reg-undefined.exp (opt_out_pattern): Delete.
	(not_saved_pattern): New.
	Replace use of the former with the latter.

gdb/doc/
2013-10-02  Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (Registers): Expand description of saved registers
	in frames.  Explain <not saved>.
@
text
@/* Cache and manage frames for GDB, the GNU debugger.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "frame.h"
#include "target.h"
#include "value.h"
#include "inferior.h"	/* for inferior_ptid */
#include "regcache.h"
#include "gdb_assert.h"
#include "gdb_string.h"
#include "user-regs.h"
#include "gdb_obstack.h"
#include "dummy-frame.h"
#include "sentinel-frame.h"
#include "gdbcore.h"
#include "annotate.h"
#include "language.h"
#include "frame-unwind.h"
#include "frame-base.h"
#include "command.h"
#include "gdbcmd.h"
#include "observer.h"
#include "objfiles.h"
#include "exceptions.h"
#include "gdbthread.h"
#include "block.h"
#include "inline-frame.h"
#include "tracepoint.h"
#include "hashtab.h"

static struct frame_info *get_prev_frame_1 (struct frame_info *this_frame);
static struct frame_info *get_prev_frame_raw (struct frame_info *this_frame);

/* We keep a cache of stack frames, each of which is a "struct
   frame_info".  The innermost one gets allocated (in
   wait_for_inferior) each time the inferior stops; current_frame
   points to it.  Additional frames get allocated (in get_prev_frame)
   as needed, and are chained through the next and prev fields.  Any
   time that the frame cache becomes invalid (most notably when we
   execute something, but also if we change how we interpret the
   frames (e.g. "set heuristic-fence-post" in mips-tdep.c, or anything
   which reads new symbols)), we should call reinit_frame_cache.  */

struct frame_info
{
  /* Level of this frame.  The inner-most (youngest) frame is at level
     0.  As you move towards the outer-most (oldest) frame, the level
     increases.  This is a cached value.  It could just as easily be
     computed by counting back from the selected frame to the inner
     most frame.  */
  /* NOTE: cagney/2002-04-05: Perhaps a level of ``-1'' should be
     reserved to indicate a bogus frame - one that has been created
     just to keep GDB happy (GDB always needs a frame).  For the
     moment leave this as speculation.  */
  int level;

  /* The frame's program space.  */
  struct program_space *pspace;

  /* The frame's address space.  */
  struct address_space *aspace;

  /* The frame's low-level unwinder and corresponding cache.  The
     low-level unwinder is responsible for unwinding register values
     for the previous frame.  The low-level unwind methods are
     selected based on the presence, or otherwise, of register unwind
     information such as CFI.  */
  void *prologue_cache;
  const struct frame_unwind *unwind;

  /* Cached copy of the previous frame's architecture.  */
  struct
  {
    int p;
    struct gdbarch *arch;
  } prev_arch;

  /* Cached copy of the previous frame's resume address.  */
  struct {
    int p;
    CORE_ADDR value;
  } prev_pc;
  
  /* Cached copy of the previous frame's function address.  */
  struct
  {
    CORE_ADDR addr;
    int p;
  } prev_func;
  
  /* This frame's ID.  */
  struct
  {
    int p;
    struct frame_id value;
  } this_id;
  
  /* The frame's high-level base methods, and corresponding cache.
     The high level base methods are selected based on the frame's
     debug info.  */
  const struct frame_base *base;
  void *base_cache;

  /* Pointers to the next (down, inner, younger) and previous (up,
     outer, older) frame_info's in the frame cache.  */
  struct frame_info *next; /* down, inner, younger */
  int prev_p;
  struct frame_info *prev; /* up, outer, older */

  /* The reason why we could not set PREV, or UNWIND_NO_REASON if we
     could.  Only valid when PREV_P is set.  */
  enum unwind_stop_reason stop_reason;
};

/* A frame stash used to speed up frame lookups.  Create a hash table
   to stash frames previously accessed from the frame cache for
   quicker subsequent retrieval.  The hash table is emptied whenever
   the frame cache is invalidated.  */

static htab_t frame_stash;

/* Internal function to calculate a hash from the frame_id addresses,
   using as many valid addresses as possible.  Frames below level 0
   are not stored in the hash table.  */

static hashval_t
frame_addr_hash (const void *ap)
{
  const struct frame_info *frame = ap;
  const struct frame_id f_id = frame->this_id.value;
  hashval_t hash = 0;

  gdb_assert (f_id.stack_addr_p || f_id.code_addr_p
	      || f_id.special_addr_p);

  if (f_id.stack_addr_p)
    hash = iterative_hash (&f_id.stack_addr,
			   sizeof (f_id.stack_addr), hash);
  if (f_id.code_addr_p)
    hash = iterative_hash (&f_id.code_addr,
			   sizeof (f_id.code_addr), hash);
  if (f_id.special_addr_p)
    hash = iterative_hash (&f_id.special_addr,
			   sizeof (f_id.special_addr), hash);

  return hash;
}

/* Internal equality function for the hash table.  This function
   defers equality operations to frame_id_eq.  */

static int
frame_addr_hash_eq (const void *a, const void *b)
{
  const struct frame_info *f_entry = a;
  const struct frame_info *f_element = b;

  return frame_id_eq (f_entry->this_id.value,
		      f_element->this_id.value);
}

/* Internal function to create the frame_stash hash table.  100 seems
   to be a good compromise to start the hash table at.  */

static void
frame_stash_create (void)
{
  frame_stash = htab_create (100,
			     frame_addr_hash,
			     frame_addr_hash_eq,
			     NULL);
}

/* Internal function to add a frame to the frame_stash hash table.  Do
   not store frames below 0 as they may not have any addresses to
   calculate a hash.  */

static void
frame_stash_add (struct frame_info *frame)
{
  /* Do not stash frames below level 0.  */
  if (frame->level >= 0)
    {
      struct frame_info **slot;

      slot = (struct frame_info **) htab_find_slot (frame_stash,
						    frame,
						    INSERT);
      *slot = frame;
    }
}

/* Internal function to search the frame stash for an entry with the
   given frame ID.  If found, return that frame.  Otherwise return
   NULL.  */

static struct frame_info *
frame_stash_find (struct frame_id id)
{
  struct frame_info dummy;
  struct frame_info *frame;

  dummy.this_id.value = id;
  frame = htab_find (frame_stash, &dummy);
  return frame;
}

/* Internal function to invalidate the frame stash by removing all
   entries in it.  This only occurs when the frame cache is
   invalidated.  */

static void
frame_stash_invalidate (void)
{
  htab_empty (frame_stash);
}

/* Flag to control debugging.  */

unsigned int frame_debug;
static void
show_frame_debug (struct ui_file *file, int from_tty,
		  struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Frame debugging is %s.\n"), value);
}

/* Flag to indicate whether backtraces should stop at main et.al.  */

static int backtrace_past_main;
static void
show_backtrace_past_main (struct ui_file *file, int from_tty,
			  struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("Whether backtraces should "
		      "continue past \"main\" is %s.\n"),
		    value);
}

static int backtrace_past_entry;
static void
show_backtrace_past_entry (struct ui_file *file, int from_tty,
			   struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Whether backtraces should continue past the "
			    "entry point of a program is %s.\n"),
		    value);
}

static unsigned int backtrace_limit = UINT_MAX;
static void
show_backtrace_limit (struct ui_file *file, int from_tty,
		      struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("An upper bound on the number "
		      "of backtrace levels is %s.\n"),
		    value);
}


static void
fprint_field (struct ui_file *file, const char *name, int p, CORE_ADDR addr)
{
  if (p)
    fprintf_unfiltered (file, "%s=%s", name, hex_string (addr));
  else
    fprintf_unfiltered (file, "!%s", name);
}

void
fprint_frame_id (struct ui_file *file, struct frame_id id)
{
  fprintf_unfiltered (file, "{");
  fprint_field (file, "stack", id.stack_addr_p, id.stack_addr);
  fprintf_unfiltered (file, ",");
  fprint_field (file, "code", id.code_addr_p, id.code_addr);
  fprintf_unfiltered (file, ",");
  fprint_field (file, "special", id.special_addr_p, id.special_addr);
  if (id.artificial_depth)
    fprintf_unfiltered (file, ",artificial=%d", id.artificial_depth);
  fprintf_unfiltered (file, "}");
}

static void
fprint_frame_type (struct ui_file *file, enum frame_type type)
{
  switch (type)
    {
    case NORMAL_FRAME:
      fprintf_unfiltered (file, "NORMAL_FRAME");
      return;
    case DUMMY_FRAME:
      fprintf_unfiltered (file, "DUMMY_FRAME");
      return;
    case INLINE_FRAME:
      fprintf_unfiltered (file, "INLINE_FRAME");
      return;
    case TAILCALL_FRAME:
      fprintf_unfiltered (file, "TAILCALL_FRAME");
      return;
    case SIGTRAMP_FRAME:
      fprintf_unfiltered (file, "SIGTRAMP_FRAME");
      return;
    case ARCH_FRAME:
      fprintf_unfiltered (file, "ARCH_FRAME");
      return;
    case SENTINEL_FRAME:
      fprintf_unfiltered (file, "SENTINEL_FRAME");
      return;
    default:
      fprintf_unfiltered (file, "<unknown type>");
      return;
    };
}

static void
fprint_frame (struct ui_file *file, struct frame_info *fi)
{
  if (fi == NULL)
    {
      fprintf_unfiltered (file, "<NULL frame>");
      return;
    }
  fprintf_unfiltered (file, "{");
  fprintf_unfiltered (file, "level=%d", fi->level);
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "type=");
  if (fi->unwind != NULL)
    fprint_frame_type (file, fi->unwind->type);
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "unwind=");
  if (fi->unwind != NULL)
    gdb_print_host_address (fi->unwind, file);
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "pc=");
  if (fi->next != NULL && fi->next->prev_pc.p)
    fprintf_unfiltered (file, "%s", hex_string (fi->next->prev_pc.value));
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "id=");
  if (fi->this_id.p)
    fprint_frame_id (file, fi->this_id.value);
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "func=");
  if (fi->next != NULL && fi->next->prev_func.p)
    fprintf_unfiltered (file, "%s", hex_string (fi->next->prev_func.addr));
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, "}");
}

/* Given FRAME, return the enclosing frame as found in real frames read-in from
   inferior memory.  Skip any previous frames which were made up by GDB.
   Return the original frame if no immediate previous frames exist.  */

static struct frame_info *
skip_artificial_frames (struct frame_info *frame)
{
  while (get_frame_type (frame) == INLINE_FRAME
	 || get_frame_type (frame) == TAILCALL_FRAME)
    frame = get_prev_frame (frame);

  return frame;
}

/* Return a frame uniq ID that can be used to, later, re-find the
   frame.  */

struct frame_id
get_frame_id (struct frame_info *fi)
{
  if (fi == NULL)
    return null_frame_id;

  if (!fi->this_id.p)
    {
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog, "{ get_frame_id (fi=%d) ",
			    fi->level);
      /* Find the unwinder.  */
      if (fi->unwind == NULL)
	frame_unwind_find_by_frame (fi, &fi->prologue_cache);
      /* Find THIS frame's ID.  */
      /* Default to outermost if no ID is found.  */
      fi->this_id.value = outer_frame_id;
      fi->unwind->this_id (fi, &fi->prologue_cache, &fi->this_id.value);
      gdb_assert (frame_id_p (fi->this_id.value));
      fi->this_id.p = 1;
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame_id (gdb_stdlog, fi->this_id.value);
	  fprintf_unfiltered (gdb_stdlog, " }\n");
	}
      frame_stash_add (fi);
    }

  return fi->this_id.value;
}

struct frame_id
get_stack_frame_id (struct frame_info *next_frame)
{
  return get_frame_id (skip_artificial_frames (next_frame));
}

struct frame_id
frame_unwind_caller_id (struct frame_info *next_frame)
{
  struct frame_info *this_frame;

  /* Use get_prev_frame_1, and not get_prev_frame.  The latter will truncate
     the frame chain, leading to this function unintentionally
     returning a null_frame_id (e.g., when a caller requests the frame
     ID of "main()"s caller.  */

  next_frame = skip_artificial_frames (next_frame);
  this_frame = get_prev_frame_1 (next_frame);
  if (this_frame)
    return get_frame_id (skip_artificial_frames (this_frame));
  else
    return null_frame_id;
}

const struct frame_id null_frame_id; /* All zeros.  */
const struct frame_id outer_frame_id = { 0, 0, 0, 0, 0, 1, 0 };

struct frame_id
frame_id_build_special (CORE_ADDR stack_addr, CORE_ADDR code_addr,
                        CORE_ADDR special_addr)
{
  struct frame_id id = null_frame_id;

  id.stack_addr = stack_addr;
  id.stack_addr_p = 1;
  id.code_addr = code_addr;
  id.code_addr_p = 1;
  id.special_addr = special_addr;
  id.special_addr_p = 1;
  return id;
}

struct frame_id
frame_id_build (CORE_ADDR stack_addr, CORE_ADDR code_addr)
{
  struct frame_id id = null_frame_id;

  id.stack_addr = stack_addr;
  id.stack_addr_p = 1;
  id.code_addr = code_addr;
  id.code_addr_p = 1;
  return id;
}

struct frame_id
frame_id_build_wild (CORE_ADDR stack_addr)
{
  struct frame_id id = null_frame_id;

  id.stack_addr = stack_addr;
  id.stack_addr_p = 1;
  return id;
}

int
frame_id_p (struct frame_id l)
{
  int p;

  /* The frame is valid iff it has a valid stack address.  */
  p = l.stack_addr_p;
  /* outer_frame_id is also valid.  */
  if (!p && memcmp (&l, &outer_frame_id, sizeof (l)) == 0)
    p = 1;
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ frame_id_p (l=");
      fprint_frame_id (gdb_stdlog, l);
      fprintf_unfiltered (gdb_stdlog, ") -> %d }\n", p);
    }
  return p;
}

int
frame_id_artificial_p (struct frame_id l)
{
  if (!frame_id_p (l))
    return 0;

  return (l.artificial_depth != 0);
}

int
frame_id_eq (struct frame_id l, struct frame_id r)
{
  int eq;

  if (!l.stack_addr_p && l.special_addr_p
      && !r.stack_addr_p && r.special_addr_p)
    /* The outermost frame marker is equal to itself.  This is the
       dodgy thing about outer_frame_id, since between execution steps
       we might step into another function - from which we can't
       unwind either.  More thought required to get rid of
       outer_frame_id.  */
    eq = 1;
  else if (!l.stack_addr_p || !r.stack_addr_p)
    /* Like a NaN, if either ID is invalid, the result is false.
       Note that a frame ID is invalid iff it is the null frame ID.  */
    eq = 0;
  else if (l.stack_addr != r.stack_addr)
    /* If .stack addresses are different, the frames are different.  */
    eq = 0;
  else if (l.code_addr_p && r.code_addr_p && l.code_addr != r.code_addr)
    /* An invalid code addr is a wild card.  If .code addresses are
       different, the frames are different.  */
    eq = 0;
  else if (l.special_addr_p && r.special_addr_p
	   && l.special_addr != r.special_addr)
    /* An invalid special addr is a wild card (or unused).  Otherwise
       if special addresses are different, the frames are different.  */
    eq = 0;
  else if (l.artificial_depth != r.artificial_depth)
    /* If artifical depths are different, the frames must be different.  */
    eq = 0;
  else
    /* Frames are equal.  */
    eq = 1;

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ frame_id_eq (l=");
      fprint_frame_id (gdb_stdlog, l);
      fprintf_unfiltered (gdb_stdlog, ",r=");
      fprint_frame_id (gdb_stdlog, r);
      fprintf_unfiltered (gdb_stdlog, ") -> %d }\n", eq);
    }
  return eq;
}

/* Safety net to check whether frame ID L should be inner to
   frame ID R, according to their stack addresses.

   This method cannot be used to compare arbitrary frames, as the
   ranges of valid stack addresses may be discontiguous (e.g. due
   to sigaltstack).

   However, it can be used as safety net to discover invalid frame
   IDs in certain circumstances.  Assuming that NEXT is the immediate
   inner frame to THIS and that NEXT and THIS are both NORMAL frames:

   * The stack address of NEXT must be inner-than-or-equal to the stack
     address of THIS.

     Therefore, if frame_id_inner (THIS, NEXT) holds, some unwind
     error has occurred.

   * If NEXT and THIS have different stack addresses, no other frame
     in the frame chain may have a stack address in between.

     Therefore, if frame_id_inner (TEST, THIS) holds, but
     frame_id_inner (TEST, NEXT) does not hold, TEST cannot refer
     to a valid frame in the frame chain.

   The sanity checks above cannot be performed when a SIGTRAMP frame
   is involved, because signal handlers might be executed on a different
   stack than the stack used by the routine that caused the signal
   to be raised.  This can happen for instance when a thread exceeds
   its maximum stack size.  In this case, certain compilers implement
   a stack overflow strategy that cause the handler to be run on a
   different stack.  */

static int
frame_id_inner (struct gdbarch *gdbarch, struct frame_id l, struct frame_id r)
{
  int inner;

  if (!l.stack_addr_p || !r.stack_addr_p)
    /* Like NaN, any operation involving an invalid ID always fails.  */
    inner = 0;
  else if (l.artificial_depth > r.artificial_depth
	   && l.stack_addr == r.stack_addr
	   && l.code_addr_p == r.code_addr_p
	   && l.special_addr_p == r.special_addr_p
	   && l.special_addr == r.special_addr)
    {
      /* Same function, different inlined functions.  */
      struct block *lb, *rb;

      gdb_assert (l.code_addr_p && r.code_addr_p);

      lb = block_for_pc (l.code_addr);
      rb = block_for_pc (r.code_addr);

      if (lb == NULL || rb == NULL)
	/* Something's gone wrong.  */
	inner = 0;
      else
	/* This will return true if LB and RB are the same block, or
	   if the block with the smaller depth lexically encloses the
	   block with the greater depth.  */
	inner = contained_in (lb, rb);
    }
  else
    /* Only return non-zero when strictly inner than.  Note that, per
       comment in "frame.h", there is some fuzz here.  Frameless
       functions are not strictly inner than (same .stack but
       different .code and/or .special address).  */
    inner = gdbarch_inner_than (gdbarch, l.stack_addr, r.stack_addr);
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ frame_id_inner (l=");
      fprint_frame_id (gdb_stdlog, l);
      fprintf_unfiltered (gdb_stdlog, ",r=");
      fprint_frame_id (gdb_stdlog, r);
      fprintf_unfiltered (gdb_stdlog, ") -> %d }\n", inner);
    }
  return inner;
}

struct frame_info *
frame_find_by_id (struct frame_id id)
{
  struct frame_info *frame, *prev_frame;

  /* ZERO denotes the null frame, let the caller decide what to do
     about it.  Should it instead return get_current_frame()?  */
  if (!frame_id_p (id))
    return NULL;

  /* Try using the frame stash first.  Finding it there removes the need
     to perform the search by looping over all frames, which can be very
     CPU-intensive if the number of frames is very high (the loop is O(n)
     and get_prev_frame performs a series of checks that are relatively
     expensive).  This optimization is particularly useful when this function
     is called from another function (such as value_fetch_lazy, case
     VALUE_LVAL (val) == lval_register) which already loops over all frames,
     making the overall behavior O(n^2).  */
  frame = frame_stash_find (id);
  if (frame)
    return frame;

  for (frame = get_current_frame (); ; frame = prev_frame)
    {
      struct frame_id this = get_frame_id (frame);

      if (frame_id_eq (id, this))
	/* An exact match.  */
	return frame;

      prev_frame = get_prev_frame (frame);
      if (!prev_frame)
	return NULL;

      /* As a safety net to avoid unnecessary backtracing while trying
	 to find an invalid ID, we check for a common situation where
	 we can detect from comparing stack addresses that no other
	 frame in the current frame chain can have this ID.  See the
	 comment at frame_id_inner for details.   */
      if (get_frame_type (frame) == NORMAL_FRAME
	  && !frame_id_inner (get_frame_arch (frame), id, this)
	  && frame_id_inner (get_frame_arch (prev_frame), id,
			     get_frame_id (prev_frame)))
	return NULL;
    }
  return NULL;
}

static int
frame_unwind_pc_if_available (struct frame_info *this_frame, CORE_ADDR *pc)
{
  if (!this_frame->prev_pc.p)
    {
      if (gdbarch_unwind_pc_p (frame_unwind_arch (this_frame)))
	{
	  volatile struct gdb_exception ex;
	  struct gdbarch *prev_gdbarch;
	  CORE_ADDR pc = 0;

	  /* The right way.  The `pure' way.  The one true way.  This
	     method depends solely on the register-unwind code to
	     determine the value of registers in THIS frame, and hence
	     the value of this frame's PC (resume address).  A typical
	     implementation is no more than:
	   
	     frame_unwind_register (this_frame, ISA_PC_REGNUM, buf);
	     return extract_unsigned_integer (buf, size of ISA_PC_REGNUM);

	     Note: this method is very heavily dependent on a correct
	     register-unwind implementation, it pays to fix that
	     method first; this method is frame type agnostic, since
	     it only deals with register values, it works with any
	     frame.  This is all in stark contrast to the old
	     FRAME_SAVED_PC which would try to directly handle all the
	     different ways that a PC could be unwound.  */
	  prev_gdbarch = frame_unwind_arch (this_frame);

	  TRY_CATCH (ex, RETURN_MASK_ERROR)
	    {
	      pc = gdbarch_unwind_pc (prev_gdbarch, this_frame);
	    }
	  if (ex.reason < 0 && ex.error == NOT_AVAILABLE_ERROR)
	    {
	      this_frame->prev_pc.p = -1;

	      if (frame_debug)
		fprintf_unfiltered (gdb_stdlog,
				    "{ frame_unwind_pc (this_frame=%d)"
				    " -> <unavailable> }\n",
				    this_frame->level);
	    }
	  else if (ex.reason < 0)
	    {
	      throw_exception (ex);
	    }
	  else
	    {
	      this_frame->prev_pc.value = pc;
	      this_frame->prev_pc.p = 1;
	      if (frame_debug)
		fprintf_unfiltered (gdb_stdlog,
				    "{ frame_unwind_pc (this_frame=%d) "
				    "-> %s }\n",
				    this_frame->level,
				    hex_string (this_frame->prev_pc.value));
	    }
	}
      else
	internal_error (__FILE__, __LINE__, _("No unwind_pc method"));
    }
  if (this_frame->prev_pc.p < 0)
    {
      *pc = -1;
      return 0;
    }
  else
    {
      *pc = this_frame->prev_pc.value;
      return 1;
    }
}

static CORE_ADDR
frame_unwind_pc (struct frame_info *this_frame)
{
  CORE_ADDR pc;

  if (!frame_unwind_pc_if_available (this_frame, &pc))
    throw_error (NOT_AVAILABLE_ERROR, _("PC not available"));
  else
    return pc;
}

CORE_ADDR
frame_unwind_caller_pc (struct frame_info *this_frame)
{
  return frame_unwind_pc (skip_artificial_frames (this_frame));
}

int
frame_unwind_caller_pc_if_available (struct frame_info *this_frame,
				     CORE_ADDR *pc)
{
  return frame_unwind_pc_if_available (skip_artificial_frames (this_frame), pc);
}

int
get_frame_func_if_available (struct frame_info *this_frame, CORE_ADDR *pc)
{
  struct frame_info *next_frame = this_frame->next;

  if (!next_frame->prev_func.p)
    {
      CORE_ADDR addr_in_block;

      /* Make certain that this, and not the adjacent, function is
         found.  */
      if (!get_frame_address_in_block_if_available (this_frame, &addr_in_block))
	{
	  next_frame->prev_func.p = -1;
	  if (frame_debug)
	    fprintf_unfiltered (gdb_stdlog,
				"{ get_frame_func (this_frame=%d)"
				" -> unavailable }\n",
				this_frame->level);
	}
      else
	{
	  next_frame->prev_func.p = 1;
	  next_frame->prev_func.addr = get_pc_function_start (addr_in_block);
	  if (frame_debug)
	    fprintf_unfiltered (gdb_stdlog,
				"{ get_frame_func (this_frame=%d) -> %s }\n",
				this_frame->level,
				hex_string (next_frame->prev_func.addr));
	}
    }

  if (next_frame->prev_func.p < 0)
    {
      *pc = -1;
      return 0;
    }
  else
    {
      *pc = next_frame->prev_func.addr;
      return 1;
    }
}

CORE_ADDR
get_frame_func (struct frame_info *this_frame)
{
  CORE_ADDR pc;

  if (!get_frame_func_if_available (this_frame, &pc))
    throw_error (NOT_AVAILABLE_ERROR, _("PC not available"));

  return pc;
}

static enum register_status
do_frame_register_read (void *src, int regnum, gdb_byte *buf)
{
  if (!deprecated_frame_register_read (src, regnum, buf))
    return REG_UNAVAILABLE;
  else
    return REG_VALID;
}

struct regcache *
frame_save_as_regcache (struct frame_info *this_frame)
{
  struct address_space *aspace = get_frame_address_space (this_frame);
  struct regcache *regcache = regcache_xmalloc (get_frame_arch (this_frame),
						aspace);
  struct cleanup *cleanups = make_cleanup_regcache_xfree (regcache);

  regcache_save (regcache, do_frame_register_read, this_frame);
  discard_cleanups (cleanups);
  return regcache;
}

void
frame_pop (struct frame_info *this_frame)
{
  struct frame_info *prev_frame;
  struct regcache *scratch;
  struct cleanup *cleanups;

  if (get_frame_type (this_frame) == DUMMY_FRAME)
    {
      /* Popping a dummy frame involves restoring more than just registers.
	 dummy_frame_pop does all the work.  */
      dummy_frame_pop (get_frame_id (this_frame));
      return;
    }

  /* Ensure that we have a frame to pop to.  */
  prev_frame = get_prev_frame_1 (this_frame);

  if (!prev_frame)
    error (_("Cannot pop the initial frame."));

  /* Ignore TAILCALL_FRAME type frames, they were executed already before
     entering THISFRAME.  */
  while (get_frame_type (prev_frame) == TAILCALL_FRAME)
    prev_frame = get_prev_frame (prev_frame);

  /* Make a copy of all the register values unwound from this frame.
     Save them in a scratch buffer so that there isn't a race between
     trying to extract the old values from the current regcache while
     at the same time writing new values into that same cache.  */
  scratch = frame_save_as_regcache (prev_frame);
  cleanups = make_cleanup_regcache_xfree (scratch);

  /* FIXME: cagney/2003-03-16: It should be possible to tell the
     target's register cache that it is about to be hit with a burst
     register transfer and that the sequence of register writes should
     be batched.  The pair target_prepare_to_store() and
     target_store_registers() kind of suggest this functionality.
     Unfortunately, they don't implement it.  Their lack of a formal
     definition can lead to targets writing back bogus values
     (arguably a bug in the target code mind).  */
  /* Now copy those saved registers into the current regcache.
     Here, regcache_cpy() calls regcache_restore().  */
  regcache_cpy (get_current_regcache (), scratch);
  do_cleanups (cleanups);

  /* We've made right mess of GDB's local state, just discard
     everything.  */
  reinit_frame_cache ();
}

void
frame_register_unwind (struct frame_info *frame, int regnum,
		       int *optimizedp, int *unavailablep,
		       enum lval_type *lvalp, CORE_ADDR *addrp,
		       int *realnump, gdb_byte *bufferp)
{
  struct value *value;

  /* Require all but BUFFERP to be valid.  A NULL BUFFERP indicates
     that the value proper does not need to be fetched.  */
  gdb_assert (optimizedp != NULL);
  gdb_assert (lvalp != NULL);
  gdb_assert (addrp != NULL);
  gdb_assert (realnump != NULL);
  /* gdb_assert (bufferp != NULL); */

  value = frame_unwind_register_value (frame, regnum);

  gdb_assert (value != NULL);

  *optimizedp = value_optimized_out (value);
  *unavailablep = !value_entirely_available (value);
  *lvalp = VALUE_LVAL (value);
  *addrp = value_address (value);
  *realnump = VALUE_REGNUM (value);

  if (bufferp)
    {
      if (!*optimizedp && !*unavailablep)
	memcpy (bufferp, value_contents_all (value),
		TYPE_LENGTH (value_type (value)));
      else
	memset (bufferp, 0, TYPE_LENGTH (value_type (value)));
    }

  /* Dispose of the new value.  This prevents watchpoints from
     trying to watch the saved frame pointer.  */
  release_value (value);
  value_free (value);
}

void
frame_register (struct frame_info *frame, int regnum,
		int *optimizedp, int *unavailablep, enum lval_type *lvalp,
		CORE_ADDR *addrp, int *realnump, gdb_byte *bufferp)
{
  /* Require all but BUFFERP to be valid.  A NULL BUFFERP indicates
     that the value proper does not need to be fetched.  */
  gdb_assert (optimizedp != NULL);
  gdb_assert (lvalp != NULL);
  gdb_assert (addrp != NULL);
  gdb_assert (realnump != NULL);
  /* gdb_assert (bufferp != NULL); */

  /* Obtain the register value by unwinding the register from the next
     (more inner frame).  */
  gdb_assert (frame != NULL && frame->next != NULL);
  frame_register_unwind (frame->next, regnum, optimizedp, unavailablep,
			 lvalp, addrp, realnump, bufferp);
}

void
frame_unwind_register (struct frame_info *frame, int regnum, gdb_byte *buf)
{
  int optimized;
  int unavailable;
  CORE_ADDR addr;
  int realnum;
  enum lval_type lval;

  frame_register_unwind (frame, regnum, &optimized, &unavailable,
			 &lval, &addr, &realnum, buf);

  if (optimized)
    error (_("Register %d was optimized out"), regnum);
  if (unavailable)
    throw_error (NOT_AVAILABLE_ERROR,
		 _("Register %d is not available"), regnum);
}

void
get_frame_register (struct frame_info *frame,
		    int regnum, gdb_byte *buf)
{
  frame_unwind_register (frame->next, regnum, buf);
}

struct value *
frame_unwind_register_value (struct frame_info *frame, int regnum)
{
  struct gdbarch *gdbarch;
  struct value *value;

  gdb_assert (frame != NULL);
  gdbarch = frame_unwind_arch (frame);

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "{ frame_unwind_register_value "
			  "(frame=%d,regnum=%d(%s),...) ",
			  frame->level, regnum,
			  user_reg_map_regnum_to_name (gdbarch, regnum));
    }

  /* Find the unwinder.  */
  if (frame->unwind == NULL)
    frame_unwind_find_by_frame (frame, &frame->prologue_cache);

  /* Ask this frame to unwind its register.  */
  value = frame->unwind->prev_register (frame, &frame->prologue_cache, regnum);

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "->");
      if (value_optimized_out (value))
	fprintf_unfiltered (gdb_stdlog, " optimized out");
      else
	{
	  if (VALUE_LVAL (value) == lval_register)
	    fprintf_unfiltered (gdb_stdlog, " register=%d",
				VALUE_REGNUM (value));
	  else if (VALUE_LVAL (value) == lval_memory)
	    fprintf_unfiltered (gdb_stdlog, " address=%s",
				paddress (gdbarch,
					  value_address (value)));
	  else
	    fprintf_unfiltered (gdb_stdlog, " computed");

	  if (value_lazy (value))
	    fprintf_unfiltered (gdb_stdlog, " lazy");
	  else
	    {
	      int i;
	      const gdb_byte *buf = value_contents (value);

	      fprintf_unfiltered (gdb_stdlog, " bytes=");
	      fprintf_unfiltered (gdb_stdlog, "[");
	      for (i = 0; i < register_size (gdbarch, regnum); i++)
		fprintf_unfiltered (gdb_stdlog, "%02x", buf[i]);
	      fprintf_unfiltered (gdb_stdlog, "]");
	    }
	}

      fprintf_unfiltered (gdb_stdlog, " }\n");
    }

  return value;
}

struct value *
get_frame_register_value (struct frame_info *frame, int regnum)
{
  return frame_unwind_register_value (frame->next, regnum);
}

LONGEST
frame_unwind_register_signed (struct frame_info *frame, int regnum)
{
  struct gdbarch *gdbarch = frame_unwind_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int size = register_size (gdbarch, regnum);
  gdb_byte buf[MAX_REGISTER_SIZE];

  frame_unwind_register (frame, regnum, buf);
  return extract_signed_integer (buf, size, byte_order);
}

LONGEST
get_frame_register_signed (struct frame_info *frame, int regnum)
{
  return frame_unwind_register_signed (frame->next, regnum);
}

ULONGEST
frame_unwind_register_unsigned (struct frame_info *frame, int regnum)
{
  struct gdbarch *gdbarch = frame_unwind_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int size = register_size (gdbarch, regnum);
  gdb_byte buf[MAX_REGISTER_SIZE];

  frame_unwind_register (frame, regnum, buf);
  return extract_unsigned_integer (buf, size, byte_order);
}

ULONGEST
get_frame_register_unsigned (struct frame_info *frame, int regnum)
{
  return frame_unwind_register_unsigned (frame->next, regnum);
}

int
read_frame_register_unsigned (struct frame_info *frame, int regnum,
			      ULONGEST *val)
{
  struct value *regval = get_frame_register_value (frame, regnum);

  if (!value_optimized_out (regval)
      && value_entirely_available (regval))
    {
      struct gdbarch *gdbarch = get_frame_arch (frame);
      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
      int size = register_size (gdbarch, VALUE_REGNUM (regval));

      *val = extract_unsigned_integer (value_contents (regval), size, byte_order);
      return 1;
    }

  return 0;
}

void
put_frame_register (struct frame_info *frame, int regnum,
		    const gdb_byte *buf)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int realnum;
  int optim;
  int unavail;
  enum lval_type lval;
  CORE_ADDR addr;

  frame_register (frame, regnum, &optim, &unavail,
		  &lval, &addr, &realnum, NULL);
  if (optim)
    error (_("Attempt to assign to a register that was not saved."));
  switch (lval)
    {
    case lval_memory:
      {
	write_memory (addr, buf, register_size (gdbarch, regnum));
	break;
      }
    case lval_register:
      regcache_cooked_write (get_current_regcache (), realnum, buf);
      break;
    default:
      error (_("Attempt to assign to an unmodifiable value."));
    }
}

/* This function is deprecated.  Use get_frame_register_value instead,
   which provides more accurate information.

   Find and return the value of REGNUM for the specified stack frame.
   The number of bytes copied is REGISTER_SIZE (REGNUM).

   Returns 0 if the register value could not be found.  */

int
deprecated_frame_register_read (struct frame_info *frame, int regnum,
		     gdb_byte *myaddr)
{
  int optimized;
  int unavailable;
  enum lval_type lval;
  CORE_ADDR addr;
  int realnum;

  frame_register (frame, regnum, &optimized, &unavailable,
		  &lval, &addr, &realnum, myaddr);

  return !optimized && !unavailable;
}

int
get_frame_register_bytes (struct frame_info *frame, int regnum,
			  CORE_ADDR offset, int len, gdb_byte *myaddr,
			  int *optimizedp, int *unavailablep)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int i;
  int maxsize;
  int numregs;

  /* Skip registers wholly inside of OFFSET.  */
  while (offset >= register_size (gdbarch, regnum))
    {
      offset -= register_size (gdbarch, regnum);
      regnum++;
    }

  /* Ensure that we will not read beyond the end of the register file.
     This can only ever happen if the debug information is bad.  */
  maxsize = -offset;
  numregs = gdbarch_num_regs (gdbarch) + gdbarch_num_pseudo_regs (gdbarch);
  for (i = regnum; i < numregs; i++)
    {
      int thissize = register_size (gdbarch, i);

      if (thissize == 0)
	break;	/* This register is not available on this architecture.  */
      maxsize += thissize;
    }
  if (len > maxsize)
    error (_("Bad debug information detected: "
	     "Attempt to read %d bytes from registers."), len);

  /* Copy the data.  */
  while (len > 0)
    {
      int curr_len = register_size (gdbarch, regnum) - offset;

      if (curr_len > len)
	curr_len = len;

      if (curr_len == register_size (gdbarch, regnum))
	{
	  enum lval_type lval;
	  CORE_ADDR addr;
	  int realnum;

	  frame_register (frame, regnum, optimizedp, unavailablep,
			  &lval, &addr, &realnum, myaddr);
	  if (*optimizedp || *unavailablep)
	    return 0;
	}
      else
	{
	  gdb_byte buf[MAX_REGISTER_SIZE];
	  enum lval_type lval;
	  CORE_ADDR addr;
	  int realnum;

	  frame_register (frame, regnum, optimizedp, unavailablep,
			  &lval, &addr, &realnum, buf);
	  if (*optimizedp || *unavailablep)
	    return 0;
	  memcpy (myaddr, buf + offset, curr_len);
	}

      myaddr += curr_len;
      len -= curr_len;
      offset = 0;
      regnum++;
    }

  *optimizedp = 0;
  *unavailablep = 0;
  return 1;
}

void
put_frame_register_bytes (struct frame_info *frame, int regnum,
			  CORE_ADDR offset, int len, const gdb_byte *myaddr)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);

  /* Skip registers wholly inside of OFFSET.  */
  while (offset >= register_size (gdbarch, regnum))
    {
      offset -= register_size (gdbarch, regnum);
      regnum++;
    }

  /* Copy the data.  */
  while (len > 0)
    {
      int curr_len = register_size (gdbarch, regnum) - offset;

      if (curr_len > len)
	curr_len = len;

      if (curr_len == register_size (gdbarch, regnum))
	{
	  put_frame_register (frame, regnum, myaddr);
	}
      else
	{
	  gdb_byte buf[MAX_REGISTER_SIZE];

	  deprecated_frame_register_read (frame, regnum, buf);
	  memcpy (buf + offset, myaddr, curr_len);
	  put_frame_register (frame, regnum, buf);
	}

      myaddr += curr_len;
      len -= curr_len;
      offset = 0;
      regnum++;
    }
}

/* Create a sentinel frame.  */

static struct frame_info *
create_sentinel_frame (struct program_space *pspace, struct regcache *regcache)
{
  struct frame_info *frame = FRAME_OBSTACK_ZALLOC (struct frame_info);

  frame->level = -1;
  frame->pspace = pspace;
  frame->aspace = get_regcache_aspace (regcache);
  /* Explicitly initialize the sentinel frame's cache.  Provide it
     with the underlying regcache.  In the future additional
     information, such as the frame's thread will be added.  */
  frame->prologue_cache = sentinel_frame_cache (regcache);
  /* For the moment there is only one sentinel frame implementation.  */
  frame->unwind = &sentinel_frame_unwind;
  /* Link this frame back to itself.  The frame is self referential
     (the unwound PC is the same as the pc), so make it so.  */
  frame->next = frame;
  /* Make the sentinel frame's ID valid, but invalid.  That way all
     comparisons with it should fail.  */
  frame->this_id.p = 1;
  frame->this_id.value = null_frame_id;
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ create_sentinel_frame (...) -> ");
      fprint_frame (gdb_stdlog, frame);
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }
  return frame;
}

/* Info about the innermost stack frame (contents of FP register).  */

static struct frame_info *current_frame;

/* Cache for frame addresses already read by gdb.  Valid only while
   inferior is stopped.  Control variables for the frame cache should
   be local to this module.  */

static struct obstack frame_cache_obstack;

void *
frame_obstack_zalloc (unsigned long size)
{
  void *data = obstack_alloc (&frame_cache_obstack, size);

  memset (data, 0, size);
  return data;
}

/* Return the innermost (currently executing) stack frame.  This is
   split into two functions.  The function unwind_to_current_frame()
   is wrapped in catch exceptions so that, even when the unwind of the
   sentinel frame fails, the function still returns a stack frame.  */

static int
unwind_to_current_frame (struct ui_out *ui_out, void *args)
{
  struct frame_info *frame = get_prev_frame (args);

  /* A sentinel frame can fail to unwind, e.g., because its PC value
     lands in somewhere like start.  */
  if (frame == NULL)
    return 1;
  current_frame = frame;
  return 0;
}

struct frame_info *
get_current_frame (void)
{
  /* First check, and report, the lack of registers.  Having GDB
     report "No stack!" or "No memory" when the target doesn't even
     have registers is very confusing.  Besides, "printcmd.exp"
     explicitly checks that ``print $pc'' with no registers prints "No
     registers".  */
  if (!target_has_registers)
    error (_("No registers."));
  if (!target_has_stack)
    error (_("No stack."));
  if (!target_has_memory)
    error (_("No memory."));
  /* Traceframes are effectively a substitute for the live inferior.  */
  if (get_traceframe_number () < 0)
    {
      if (ptid_equal (inferior_ptid, null_ptid))
	error (_("No selected thread."));
      if (is_exited (inferior_ptid))
	error (_("Invalid selected thread."));
      if (is_executing (inferior_ptid))
	error (_("Target is executing."));
    }

  if (current_frame == NULL)
    {
      struct frame_info *sentinel_frame =
	create_sentinel_frame (current_program_space, get_current_regcache ());
      if (catch_exceptions (current_uiout, unwind_to_current_frame,
			    sentinel_frame, RETURN_MASK_ERROR) != 0)
	{
	  /* Oops! Fake a current frame?  Is this useful?  It has a PC
             of zero, for instance.  */
	  current_frame = sentinel_frame;
	}
    }
  return current_frame;
}

/* The "selected" stack frame is used by default for local and arg
   access.  May be zero, for no selected frame.  */

static struct frame_info *selected_frame;

int
has_stack_frames (void)
{
  if (!target_has_registers || !target_has_stack || !target_has_memory)
    return 0;

  /* Traceframes are effectively a substitute for the live inferior.  */
  if (get_traceframe_number () < 0)
    {
      /* No current inferior, no frame.  */
      if (ptid_equal (inferior_ptid, null_ptid))
	return 0;

      /* Don't try to read from a dead thread.  */
      if (is_exited (inferior_ptid))
	return 0;

      /* ... or from a spinning thread.  */
      if (is_executing (inferior_ptid))
	return 0;
    }

  return 1;
}

/* Return the selected frame.  Always non-NULL (unless there isn't an
   inferior sufficient for creating a frame) in which case an error is
   thrown.  */

struct frame_info *
get_selected_frame (const char *message)
{
  if (selected_frame == NULL)
    {
      if (message != NULL && !has_stack_frames ())
	error (("%s"), message);
      /* Hey!  Don't trust this.  It should really be re-finding the
	 last selected frame of the currently selected thread.  This,
	 though, is better than nothing.  */
      select_frame (get_current_frame ());
    }
  /* There is always a frame.  */
  gdb_assert (selected_frame != NULL);
  return selected_frame;
}

/* If there is a selected frame, return it.  Otherwise, return NULL.  */

struct frame_info *
get_selected_frame_if_set (void)
{
  return selected_frame;
}

/* This is a variant of get_selected_frame() which can be called when
   the inferior does not have a frame; in that case it will return
   NULL instead of calling error().  */

struct frame_info *
deprecated_safe_get_selected_frame (void)
{
  if (!has_stack_frames ())
    return NULL;
  return get_selected_frame (NULL);
}

/* Select frame FI (or NULL - to invalidate the current frame).  */

void
select_frame (struct frame_info *fi)
{
  selected_frame = fi;
  /* NOTE: cagney/2002-05-04: FI can be NULL.  This occurs when the
     frame is being invalidated.  */
  if (deprecated_selected_frame_level_changed_hook)
    deprecated_selected_frame_level_changed_hook (frame_relative_level (fi));

  /* FIXME: kseitz/2002-08-28: It would be nice to call
     selected_frame_level_changed_event() right here, but due to limitations
     in the current interfaces, we would end up flooding UIs with events
     because select_frame() is used extensively internally.

     Once we have frame-parameterized frame (and frame-related) commands,
     the event notification can be moved here, since this function will only
     be called when the user's selected frame is being changed.  */

  /* Ensure that symbols for this frame are read in.  Also, determine the
     source language of this frame, and switch to it if desired.  */
  if (fi)
    {
      CORE_ADDR pc;

      /* We retrieve the frame's symtab by using the frame PC.
	 However we cannot use the frame PC as-is, because it usually
	 points to the instruction following the "call", which is
	 sometimes the first instruction of another function.  So we
	 rely on get_frame_address_in_block() which provides us with a
	 PC which is guaranteed to be inside the frame's code
	 block.  */
      if (get_frame_address_in_block_if_available (fi, &pc))
	{
	  struct symtab *s = find_pc_symtab (pc);

	  if (s
	      && s->language != current_language->la_language
	      && s->language != language_unknown
	      && language_mode == language_mode_auto)
	    set_language (s->language);
	}
    }
}

/* Create an arbitrary (i.e. address specified by user) or innermost frame.
   Always returns a non-NULL value.  */

struct frame_info *
create_new_frame (CORE_ADDR addr, CORE_ADDR pc)
{
  struct frame_info *fi;

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "{ create_new_frame (addr=%s, pc=%s) ",
			  hex_string (addr), hex_string (pc));
    }

  fi = FRAME_OBSTACK_ZALLOC (struct frame_info);

  fi->next = create_sentinel_frame (current_program_space,
				    get_current_regcache ());

  /* Set/update this frame's cached PC value, found in the next frame.
     Do this before looking for this frame's unwinder.  A sniffer is
     very likely to read this, and the corresponding unwinder is
     entitled to rely that the PC doesn't magically change.  */
  fi->next->prev_pc.value = pc;
  fi->next->prev_pc.p = 1;

  /* We currently assume that frame chain's can't cross spaces.  */
  fi->pspace = fi->next->pspace;
  fi->aspace = fi->next->aspace;

  /* Select/initialize both the unwind function and the frame's type
     based on the PC.  */
  frame_unwind_find_by_frame (fi, &fi->prologue_cache);

  fi->this_id.p = 1;
  fi->this_id.value = frame_id_build (addr, pc);

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, fi);
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }

  return fi;
}

/* Return the frame that THIS_FRAME calls (NULL if THIS_FRAME is the
   innermost frame).  Be careful to not fall off the bottom of the
   frame chain and onto the sentinel frame.  */

struct frame_info *
get_next_frame (struct frame_info *this_frame)
{
  if (this_frame->level > 0)
    return this_frame->next;
  else
    return NULL;
}

/* Observer for the target_changed event.  */

static void
frame_observer_target_changed (struct target_ops *target)
{
  reinit_frame_cache ();
}

/* Flush the entire frame cache.  */

void
reinit_frame_cache (void)
{
  struct frame_info *fi;

  /* Tear down all frame caches.  */
  for (fi = current_frame; fi != NULL; fi = fi->prev)
    {
      if (fi->prologue_cache && fi->unwind->dealloc_cache)
	fi->unwind->dealloc_cache (fi, fi->prologue_cache);
      if (fi->base_cache && fi->base->unwind->dealloc_cache)
	fi->base->unwind->dealloc_cache (fi, fi->base_cache);
    }

  /* Since we can't really be sure what the first object allocated was.  */
  obstack_free (&frame_cache_obstack, 0);
  obstack_init (&frame_cache_obstack);

  if (current_frame != NULL)
    annotate_frames_invalid ();

  current_frame = NULL;		/* Invalidate cache */
  select_frame (NULL);
  frame_stash_invalidate ();
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog, "{ reinit_frame_cache () }\n");
}

/* Find where a register is saved (in memory or another register).
   The result of frame_register_unwind is just where it is saved
   relative to this particular frame.  */

static void
frame_register_unwind_location (struct frame_info *this_frame, int regnum,
				int *optimizedp, enum lval_type *lvalp,
				CORE_ADDR *addrp, int *realnump)
{
  gdb_assert (this_frame == NULL || this_frame->level >= 0);

  while (this_frame != NULL)
    {
      int unavailable;

      frame_register_unwind (this_frame, regnum, optimizedp, &unavailable,
			     lvalp, addrp, realnump, NULL);

      if (*optimizedp)
	break;

      if (*lvalp != lval_register)
	break;

      regnum = *realnump;
      this_frame = get_next_frame (this_frame);
    }
}

/* Return a "struct frame_info" corresponding to the frame that called
   THIS_FRAME.  Returns NULL if there is no such frame.

   Unlike get_prev_frame, this function always tries to unwind the
   frame.  */

static struct frame_info *
get_prev_frame_1 (struct frame_info *this_frame)
{
  struct frame_id this_id;
  struct gdbarch *gdbarch;

  gdb_assert (this_frame != NULL);
  gdbarch = get_frame_arch (this_frame);

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ get_prev_frame_1 (this_frame=");
      if (this_frame != NULL)
	fprintf_unfiltered (gdb_stdlog, "%d", this_frame->level);
      else
	fprintf_unfiltered (gdb_stdlog, "<NULL>");
      fprintf_unfiltered (gdb_stdlog, ") ");
    }

  /* Only try to do the unwind once.  */
  if (this_frame->prev_p)
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, this_frame->prev);
	  fprintf_unfiltered (gdb_stdlog, " // cached \n");
	}
      return this_frame->prev;
    }

  /* If the frame unwinder hasn't been selected yet, we must do so
     before setting prev_p; otherwise the check for misbehaved
     sniffers will think that this frame's sniffer tried to unwind
     further (see frame_cleanup_after_sniffer).  */
  if (this_frame->unwind == NULL)
    frame_unwind_find_by_frame (this_frame, &this_frame->prologue_cache);

  this_frame->prev_p = 1;
  this_frame->stop_reason = UNWIND_NO_REASON;

  /* If we are unwinding from an inline frame, all of the below tests
     were already performed when we unwound from the next non-inline
     frame.  We must skip them, since we can not get THIS_FRAME's ID
     until we have unwound all the way down to the previous non-inline
     frame.  */
  if (get_frame_type (this_frame) == INLINE_FRAME)
    return get_prev_frame_raw (this_frame);

  /* Check that this frame is unwindable.  If it isn't, don't try to
     unwind to the prev frame.  */
  this_frame->stop_reason
    = this_frame->unwind->stop_reason (this_frame,
				       &this_frame->prologue_cache);

  if (this_frame->stop_reason != UNWIND_NO_REASON)
    return NULL;

  /* Check that this frame's ID was valid.  If it wasn't, don't try to
     unwind to the prev frame.  Be careful to not apply this test to
     the sentinel frame.  */
  this_id = get_frame_id (this_frame);
  if (this_frame->level >= 0 && frame_id_eq (this_id, outer_frame_id))
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // this ID is NULL }\n");
	}
      this_frame->stop_reason = UNWIND_NULL_ID;
      return NULL;
    }

  /* Check that this frame's ID isn't inner to (younger, below, next)
     the next frame.  This happens when a frame unwind goes backwards.
     This check is valid only if this frame and the next frame are NORMAL.
     See the comment at frame_id_inner for details.  */
  if (get_frame_type (this_frame) == NORMAL_FRAME
      && this_frame->next->unwind->type == NORMAL_FRAME
      && frame_id_inner (get_frame_arch (this_frame->next), this_id,
			 get_frame_id (this_frame->next)))
    {
      CORE_ADDR this_pc_in_block;
      struct minimal_symbol *morestack_msym;
      const char *morestack_name = NULL;
      
      /* gcc -fsplit-stack __morestack can continue the stack anywhere.  */
      this_pc_in_block = get_frame_address_in_block (this_frame);
      morestack_msym = lookup_minimal_symbol_by_pc (this_pc_in_block).minsym;
      if (morestack_msym)
	morestack_name = SYMBOL_LINKAGE_NAME (morestack_msym);
      if (!morestack_name || strcmp (morestack_name, "__morestack") != 0)
	{
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // this frame ID is inner }\n");
	    }
	  this_frame->stop_reason = UNWIND_INNER_ID;
	  return NULL;
	}
    }

  /* Check that this and the next frame are not identical.  If they
     are, there is most likely a stack cycle.  As with the inner-than
     test above, avoid comparing the inner-most and sentinel frames.  */
  if (this_frame->level > 0
      && frame_id_eq (this_id, get_frame_id (this_frame->next)))
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // this frame has same ID }\n");
	}
      this_frame->stop_reason = UNWIND_SAME_ID;
      return NULL;
    }

  /* Check that this and the next frame do not unwind the PC register
     to the same memory location.  If they do, then even though they
     have different frame IDs, the new frame will be bogus; two
     functions can't share a register save slot for the PC.  This can
     happen when the prologue analyzer finds a stack adjustment, but
     no PC save.

     This check does assume that the "PC register" is roughly a
     traditional PC, even if the gdbarch_unwind_pc method adjusts
     it (we do not rely on the value, only on the unwound PC being
     dependent on this value).  A potential improvement would be
     to have the frame prev_pc method and the gdbarch unwind_pc
     method set the same lval and location information as
     frame_register_unwind.  */
  if (this_frame->level > 0
      && gdbarch_pc_regnum (gdbarch) >= 0
      && get_frame_type (this_frame) == NORMAL_FRAME
      && (get_frame_type (this_frame->next) == NORMAL_FRAME
	  || get_frame_type (this_frame->next) == INLINE_FRAME))
    {
      int optimized, realnum, nrealnum;
      enum lval_type lval, nlval;
      CORE_ADDR addr, naddr;

      frame_register_unwind_location (this_frame,
				      gdbarch_pc_regnum (gdbarch),
				      &optimized, &lval, &addr, &realnum);
      frame_register_unwind_location (get_next_frame (this_frame),
				      gdbarch_pc_regnum (gdbarch),
				      &optimized, &nlval, &naddr, &nrealnum);

      if ((lval == lval_memory && lval == nlval && addr == naddr)
	  || (lval == lval_register && lval == nlval && realnum == nrealnum))
	{
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog, " // no saved PC }\n");
	    }

	  this_frame->stop_reason = UNWIND_NO_SAVED_PC;
	  this_frame->prev = NULL;
	  return NULL;
	}
    }

  return get_prev_frame_raw (this_frame);
}

/* Construct a new "struct frame_info" and link it previous to
   this_frame.  */

static struct frame_info *
get_prev_frame_raw (struct frame_info *this_frame)
{
  struct frame_info *prev_frame;

  /* Allocate the new frame but do not wire it in to the frame chain.
     Some (bad) code in INIT_FRAME_EXTRA_INFO tries to look along
     frame->next to pull some fancy tricks (of course such code is, by
     definition, recursive).  Try to prevent it.

     There is no reason to worry about memory leaks, should the
     remainder of the function fail.  The allocated memory will be
     quickly reclaimed when the frame cache is flushed, and the `we've
     been here before' check above will stop repeated memory
     allocation calls.  */
  prev_frame = FRAME_OBSTACK_ZALLOC (struct frame_info);
  prev_frame->level = this_frame->level + 1;

  /* For now, assume we don't have frame chains crossing address
     spaces.  */
  prev_frame->pspace = this_frame->pspace;
  prev_frame->aspace = this_frame->aspace;

  /* Don't yet compute ->unwind (and hence ->type).  It is computed
     on-demand in get_frame_type, frame_register_unwind, and
     get_frame_id.  */

  /* Don't yet compute the frame's ID.  It is computed on-demand by
     get_frame_id().  */

  /* The unwound frame ID is validate at the start of this function,
     as part of the logic to decide if that frame should be further
     unwound, and not here while the prev frame is being created.
     Doing this makes it possible for the user to examine a frame that
     has an invalid frame ID.

     Some very old VAX code noted: [...]  For the sake of argument,
     suppose that the stack is somewhat trashed (which is one reason
     that "info frame" exists).  So, return 0 (indicating we don't
     know the address of the arglist) if we don't know what frame this
     frame calls.  */

  /* Link it in.  */
  this_frame->prev = prev_frame;
  prev_frame->next = this_frame;

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, prev_frame);
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }

  return prev_frame;
}

/* Debug routine to print a NULL frame being returned.  */

static void
frame_debug_got_null_frame (struct frame_info *this_frame,
			    const char *reason)
{
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ get_prev_frame (this_frame=");
      if (this_frame != NULL)
	fprintf_unfiltered (gdb_stdlog, "%d", this_frame->level);
      else
	fprintf_unfiltered (gdb_stdlog, "<NULL>");
      fprintf_unfiltered (gdb_stdlog, ") -> // %s}\n", reason);
    }
}

/* Is this (non-sentinel) frame in the "main"() function?  */

static int
inside_main_func (struct frame_info *this_frame)
{
  struct minimal_symbol *msymbol;
  CORE_ADDR maddr;

  if (symfile_objfile == 0)
    return 0;
  msymbol = lookup_minimal_symbol (main_name (), NULL, symfile_objfile);
  if (msymbol == NULL)
    return 0;
  /* Make certain that the code, and not descriptor, address is
     returned.  */
  maddr = gdbarch_convert_from_func_ptr_addr (get_frame_arch (this_frame),
					      SYMBOL_VALUE_ADDRESS (msymbol),
					      &current_target);
  return maddr == get_frame_func (this_frame);
}

/* Test whether THIS_FRAME is inside the process entry point function.  */

static int
inside_entry_func (struct frame_info *this_frame)
{
  CORE_ADDR entry_point;

  if (!entry_point_address_query (&entry_point))
    return 0;

  return get_frame_func (this_frame) == entry_point;
}

/* Return a structure containing various interesting information about
   the frame that called THIS_FRAME.  Returns NULL if there is entier
   no such frame or the frame fails any of a set of target-independent
   condition that should terminate the frame chain (e.g., as unwinding
   past main()).

   This function should not contain target-dependent tests, such as
   checking whether the program-counter is zero.  */

struct frame_info *
get_prev_frame (struct frame_info *this_frame)
{
  CORE_ADDR frame_pc;
  int frame_pc_p;

  /* There is always a frame.  If this assertion fails, suspect that
     something should be calling get_selected_frame() or
     get_current_frame().  */
  gdb_assert (this_frame != NULL);
  frame_pc_p = get_frame_pc_if_available (this_frame, &frame_pc);

  /* tausq/2004-12-07: Dummy frames are skipped because it doesn't make much
     sense to stop unwinding at a dummy frame.  One place where a dummy
     frame may have an address "inside_main_func" is on HPUX.  On HPUX, the
     pcsqh register (space register for the instruction at the head of the
     instruction queue) cannot be written directly; the only way to set it
     is to branch to code that is in the target space.  In order to implement
     frame dummies on HPUX, the called function is made to jump back to where 
     the inferior was when the user function was called.  If gdb was inside 
     the main function when we created the dummy frame, the dummy frame will 
     point inside the main function.  */
  if (this_frame->level >= 0
      && get_frame_type (this_frame) == NORMAL_FRAME
      && !backtrace_past_main
      && frame_pc_p
      && inside_main_func (this_frame))
    /* Don't unwind past main().  Note, this is done _before_ the
       frame has been marked as previously unwound.  That way if the
       user later decides to enable unwinds past main(), that will
       automatically happen.  */
    {
      frame_debug_got_null_frame (this_frame, "inside main func");
      return NULL;
    }

  /* If the user's backtrace limit has been exceeded, stop.  We must
     add two to the current level; one of those accounts for backtrace_limit
     being 1-based and the level being 0-based, and the other accounts for
     the level of the new frame instead of the level of the current
     frame.  */
  if (this_frame->level + 2 > backtrace_limit)
    {
      frame_debug_got_null_frame (this_frame, "backtrace limit exceeded");
      return NULL;
    }

  /* If we're already inside the entry function for the main objfile,
     then it isn't valid.  Don't apply this test to a dummy frame -
     dummy frame PCs typically land in the entry func.  Don't apply
     this test to the sentinel frame.  Sentinel frames should always
     be allowed to unwind.  */
  /* NOTE: cagney/2003-07-07: Fixed a bug in inside_main_func() -
     wasn't checking for "main" in the minimal symbols.  With that
     fixed asm-source tests now stop in "main" instead of halting the
     backtrace in weird and wonderful ways somewhere inside the entry
     file.  Suspect that tests for inside the entry file/func were
     added to work around that (now fixed) case.  */
  /* NOTE: cagney/2003-07-15: danielj (if I'm reading it right)
     suggested having the inside_entry_func test use the
     inside_main_func() msymbol trick (along with entry_point_address()
     I guess) to determine the address range of the start function.
     That should provide a far better stopper than the current
     heuristics.  */
  /* NOTE: tausq/2004-10-09: this is needed if, for example, the compiler
     applied tail-call optimizations to main so that a function called 
     from main returns directly to the caller of main.  Since we don't
     stop at main, we should at least stop at the entry point of the
     application.  */
  if (this_frame->level >= 0
      && get_frame_type (this_frame) == NORMAL_FRAME
      && !backtrace_past_entry
      && frame_pc_p
      && inside_entry_func (this_frame))
    {
      frame_debug_got_null_frame (this_frame, "inside entry func");
      return NULL;
    }

  /* Assume that the only way to get a zero PC is through something
     like a SIGSEGV or a dummy frame, and hence that NORMAL frames
     will never unwind a zero PC.  */
  if (this_frame->level > 0
      && (get_frame_type (this_frame) == NORMAL_FRAME
	  || get_frame_type (this_frame) == INLINE_FRAME)
      && get_frame_type (get_next_frame (this_frame)) == NORMAL_FRAME
      && frame_pc_p && frame_pc == 0)
    {
      frame_debug_got_null_frame (this_frame, "zero PC");
      return NULL;
    }

  return get_prev_frame_1 (this_frame);
}

CORE_ADDR
get_frame_pc (struct frame_info *frame)
{
  gdb_assert (frame->next != NULL);
  return frame_unwind_pc (frame->next);
}

int
get_frame_pc_if_available (struct frame_info *frame, CORE_ADDR *pc)
{
  volatile struct gdb_exception ex;

  gdb_assert (frame->next != NULL);

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      *pc = frame_unwind_pc (frame->next);
    }
  if (ex.reason < 0)
    {
      if (ex.error == NOT_AVAILABLE_ERROR)
	return 0;
      else
	throw_exception (ex);
    }

  return 1;
}

/* Return an address that falls within THIS_FRAME's code block.  */

CORE_ADDR
get_frame_address_in_block (struct frame_info *this_frame)
{
  /* A draft address.  */
  CORE_ADDR pc = get_frame_pc (this_frame);

  struct frame_info *next_frame = this_frame->next;

  /* Calling get_frame_pc returns the resume address for THIS_FRAME.
     Normally the resume address is inside the body of the function
     associated with THIS_FRAME, but there is a special case: when
     calling a function which the compiler knows will never return
     (for instance abort), the call may be the very last instruction
     in the calling function.  The resume address will point after the
     call and may be at the beginning of a different function
     entirely.

     If THIS_FRAME is a signal frame or dummy frame, then we should
     not adjust the unwound PC.  For a dummy frame, GDB pushed the
     resume address manually onto the stack.  For a signal frame, the
     OS may have pushed the resume address manually and invoked the
     handler (e.g. GNU/Linux), or invoked the trampoline which called
     the signal handler - but in either case the signal handler is
     expected to return to the trampoline.  So in both of these
     cases we know that the resume address is executable and
     related.  So we only need to adjust the PC if THIS_FRAME
     is a normal function.

     If the program has been interrupted while THIS_FRAME is current,
     then clearly the resume address is inside the associated
     function.  There are three kinds of interruption: debugger stop
     (next frame will be SENTINEL_FRAME), operating system
     signal or exception (next frame will be SIGTRAMP_FRAME),
     or debugger-induced function call (next frame will be
     DUMMY_FRAME).  So we only need to adjust the PC if
     NEXT_FRAME is a normal function.

     We check the type of NEXT_FRAME first, since it is already
     known; frame type is determined by the unwinder, and since
     we have THIS_FRAME we've already selected an unwinder for
     NEXT_FRAME.

     If the next frame is inlined, we need to keep going until we find
     the real function - for instance, if a signal handler is invoked
     while in an inlined function, then the code address of the
     "calling" normal function should not be adjusted either.  */

  while (get_frame_type (next_frame) == INLINE_FRAME)
    next_frame = next_frame->next;

  if ((get_frame_type (next_frame) == NORMAL_FRAME
       || get_frame_type (next_frame) == TAILCALL_FRAME)
      && (get_frame_type (this_frame) == NORMAL_FRAME
	  || get_frame_type (this_frame) == TAILCALL_FRAME
	  || get_frame_type (this_frame) == INLINE_FRAME))
    return pc - 1;

  return pc;
}

int
get_frame_address_in_block_if_available (struct frame_info *this_frame,
					 CORE_ADDR *pc)
{
  volatile struct gdb_exception ex;

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      *pc = get_frame_address_in_block (this_frame);
    }
  if (ex.reason < 0 && ex.error == NOT_AVAILABLE_ERROR)
    return 0;
  else if (ex.reason < 0)
    throw_exception (ex);
  else
    return 1;
}

void
find_frame_sal (struct frame_info *frame, struct symtab_and_line *sal)
{
  struct frame_info *next_frame;
  int notcurrent;
  CORE_ADDR pc;

  /* If the next frame represents an inlined function call, this frame's
     sal is the "call site" of that inlined function, which can not
     be inferred from get_frame_pc.  */
  next_frame = get_next_frame (frame);
  if (frame_inlined_callees (frame) > 0)
    {
      struct symbol *sym;

      if (next_frame)
	sym = get_frame_function (next_frame);
      else
	sym = inline_skipped_symbol (inferior_ptid);

      /* If frame is inline, it certainly has symbols.  */
      gdb_assert (sym);
      init_sal (sal);
      if (SYMBOL_LINE (sym) != 0)
	{
	  sal->symtab = SYMBOL_SYMTAB (sym);
	  sal->line = SYMBOL_LINE (sym);
	}
      else
	/* If the symbol does not have a location, we don't know where
	   the call site is.  Do not pretend to.  This is jarring, but
	   we can't do much better.  */
	sal->pc = get_frame_pc (frame);

      sal->pspace = get_frame_program_space (frame);

      return;
    }

  /* If FRAME is not the innermost frame, that normally means that
     FRAME->pc points at the return instruction (which is *after* the
     call instruction), and we want to get the line containing the
     call (because the call is where the user thinks the program is).
     However, if the next frame is either a SIGTRAMP_FRAME or a
     DUMMY_FRAME, then the next frame will contain a saved interrupt
     PC and such a PC indicates the current (rather than next)
     instruction/line, consequently, for such cases, want to get the
     line containing fi->pc.  */
  if (!get_frame_pc_if_available (frame, &pc))
    {
      init_sal (sal);
      return;
    }

  notcurrent = (pc != get_frame_address_in_block (frame));
  (*sal) = find_pc_line (pc, notcurrent);
}

/* Per "frame.h", return the ``address'' of the frame.  Code should
   really be using get_frame_id().  */
CORE_ADDR
get_frame_base (struct frame_info *fi)
{
  return get_frame_id (fi).stack_addr;
}

/* High-level offsets into the frame.  Used by the debug info.  */

CORE_ADDR
get_frame_base_address (struct frame_info *fi)
{
  if (get_frame_type (fi) != NORMAL_FRAME)
    return 0;
  if (fi->base == NULL)
    fi->base = frame_base_find_by_frame (fi);
  /* Sneaky: If the low-level unwind and high-level base code share a
     common unwinder, let them share the prologue cache.  */
  if (fi->base->unwind == fi->unwind)
    return fi->base->this_base (fi, &fi->prologue_cache);
  return fi->base->this_base (fi, &fi->base_cache);
}

CORE_ADDR
get_frame_locals_address (struct frame_info *fi)
{
  if (get_frame_type (fi) != NORMAL_FRAME)
    return 0;
  /* If there isn't a frame address method, find it.  */
  if (fi->base == NULL)
    fi->base = frame_base_find_by_frame (fi);
  /* Sneaky: If the low-level unwind and high-level base code share a
     common unwinder, let them share the prologue cache.  */
  if (fi->base->unwind == fi->unwind)
    return fi->base->this_locals (fi, &fi->prologue_cache);
  return fi->base->this_locals (fi, &fi->base_cache);
}

CORE_ADDR
get_frame_args_address (struct frame_info *fi)
{
  if (get_frame_type (fi) != NORMAL_FRAME)
    return 0;
  /* If there isn't a frame address method, find it.  */
  if (fi->base == NULL)
    fi->base = frame_base_find_by_frame (fi);
  /* Sneaky: If the low-level unwind and high-level base code share a
     common unwinder, let them share the prologue cache.  */
  if (fi->base->unwind == fi->unwind)
    return fi->base->this_args (fi, &fi->prologue_cache);
  return fi->base->this_args (fi, &fi->base_cache);
}

/* Return true if the frame unwinder for frame FI is UNWINDER; false
   otherwise.  */

int
frame_unwinder_is (struct frame_info *fi, const struct frame_unwind *unwinder)
{
  if (fi->unwind == NULL)
    frame_unwind_find_by_frame (fi, &fi->prologue_cache);
  return fi->unwind == unwinder;
}

/* Level of the selected frame: 0 for innermost, 1 for its caller, ...
   or -1 for a NULL frame.  */

int
frame_relative_level (struct frame_info *fi)
{
  if (fi == NULL)
    return -1;
  else
    return fi->level;
}

enum frame_type
get_frame_type (struct frame_info *frame)
{
  if (frame->unwind == NULL)
    /* Initialize the frame's unwinder because that's what
       provides the frame's type.  */
    frame_unwind_find_by_frame (frame, &frame->prologue_cache);
  return frame->unwind->type;
}

struct program_space *
get_frame_program_space (struct frame_info *frame)
{
  return frame->pspace;
}

struct program_space *
frame_unwind_program_space (struct frame_info *this_frame)
{
  gdb_assert (this_frame);

  /* This is really a placeholder to keep the API consistent --- we
     assume for now that we don't have frame chains crossing
     spaces.  */
  return this_frame->pspace;
}

struct address_space *
get_frame_address_space (struct frame_info *frame)
{
  return frame->aspace;
}

/* Memory access methods.  */

void
get_frame_memory (struct frame_info *this_frame, CORE_ADDR addr,
		  gdb_byte *buf, int len)
{
  read_memory (addr, buf, len);
}

LONGEST
get_frame_memory_signed (struct frame_info *this_frame, CORE_ADDR addr,
			 int len)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  return read_memory_integer (addr, len, byte_order);
}

ULONGEST
get_frame_memory_unsigned (struct frame_info *this_frame, CORE_ADDR addr,
			   int len)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  return read_memory_unsigned_integer (addr, len, byte_order);
}

int
safe_frame_unwind_memory (struct frame_info *this_frame,
			  CORE_ADDR addr, gdb_byte *buf, int len)
{
  /* NOTE: target_read_memory returns zero on success!  */
  return !target_read_memory (addr, buf, len);
}

/* Architecture methods.  */

struct gdbarch *
get_frame_arch (struct frame_info *this_frame)
{
  return frame_unwind_arch (this_frame->next);
}

struct gdbarch *
frame_unwind_arch (struct frame_info *next_frame)
{
  if (!next_frame->prev_arch.p)
    {
      struct gdbarch *arch;

      if (next_frame->unwind == NULL)
	frame_unwind_find_by_frame (next_frame, &next_frame->prologue_cache);

      if (next_frame->unwind->prev_arch != NULL)
	arch = next_frame->unwind->prev_arch (next_frame,
					      &next_frame->prologue_cache);
      else
	arch = get_frame_arch (next_frame);

      next_frame->prev_arch.arch = arch;
      next_frame->prev_arch.p = 1;
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "{ frame_unwind_arch (next_frame=%d) -> %s }\n",
			    next_frame->level,
			    gdbarch_bfd_arch_info (arch)->printable_name);
    }

  return next_frame->prev_arch.arch;
}

struct gdbarch *
frame_unwind_caller_arch (struct frame_info *next_frame)
{
  return frame_unwind_arch (skip_artificial_frames (next_frame));
}

/* Stack pointer methods.  */

CORE_ADDR
get_frame_sp (struct frame_info *this_frame)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);

  /* Normality - an architecture that provides a way of obtaining any
     frame inner-most address.  */
  if (gdbarch_unwind_sp_p (gdbarch))
    /* NOTE drow/2008-06-28: gdbarch_unwind_sp could be converted to
       operate on THIS_FRAME now.  */
    return gdbarch_unwind_sp (gdbarch, this_frame->next);
  /* Now things are really are grim.  Hope that the value returned by
     the gdbarch_sp_regnum register is meaningful.  */
  if (gdbarch_sp_regnum (gdbarch) >= 0)
    return get_frame_register_unsigned (this_frame,
					gdbarch_sp_regnum (gdbarch));
  internal_error (__FILE__, __LINE__, _("Missing unwind SP method"));
}

/* Return the reason why we can't unwind past FRAME.  */

enum unwind_stop_reason
get_frame_unwind_stop_reason (struct frame_info *frame)
{
  /* If we haven't tried to unwind past this point yet, then assume
     that unwinding would succeed.  */
  if (frame->prev_p == 0)
    return UNWIND_NO_REASON;

  /* Otherwise, we set a reason when we succeeded (or failed) to
     unwind.  */
  return frame->stop_reason;
}

/* Return a string explaining REASON.  */

const char *
frame_stop_reason_string (enum unwind_stop_reason reason)
{
  switch (reason)
    {
#define SET(name, description) \
    case name: return _(description);
#include "unwind_stop_reasons.def"
#undef SET

    default:
      internal_error (__FILE__, __LINE__,
		      "Invalid frame stop reason");
    }
}

/* Clean up after a failed (wrong unwinder) attempt to unwind past
   FRAME.  */

static void
frame_cleanup_after_sniffer (void *arg)
{
  struct frame_info *frame = arg;

  /* The sniffer should not allocate a prologue cache if it did not
     match this frame.  */
  gdb_assert (frame->prologue_cache == NULL);

  /* No sniffer should extend the frame chain; sniff based on what is
     already certain.  */
  gdb_assert (!frame->prev_p);

  /* The sniffer should not check the frame's ID; that's circular.  */
  gdb_assert (!frame->this_id.p);

  /* Clear cached fields dependent on the unwinder.

     The previous PC is independent of the unwinder, but the previous
     function is not (see get_frame_address_in_block).  */
  frame->prev_func.p = 0;
  frame->prev_func.addr = 0;

  /* Discard the unwinder last, so that we can easily find it if an assertion
     in this function triggers.  */
  frame->unwind = NULL;
}

/* Set FRAME's unwinder temporarily, so that we can call a sniffer.
   Return a cleanup which should be called if unwinding fails, and
   discarded if it succeeds.  */

struct cleanup *
frame_prepare_for_sniffer (struct frame_info *frame,
			   const struct frame_unwind *unwind)
{
  gdb_assert (frame->unwind == NULL);
  frame->unwind = unwind;
  return make_cleanup (frame_cleanup_after_sniffer, frame);
}

extern initialize_file_ftype _initialize_frame; /* -Wmissing-prototypes */

static struct cmd_list_element *set_backtrace_cmdlist;
static struct cmd_list_element *show_backtrace_cmdlist;

static void
set_backtrace_cmd (char *args, int from_tty)
{
  help_list (set_backtrace_cmdlist, "set backtrace ", -1, gdb_stdout);
}

static void
show_backtrace_cmd (char *args, int from_tty)
{
  cmd_show_list (show_backtrace_cmdlist, from_tty, "");
}

void
_initialize_frame (void)
{
  obstack_init (&frame_cache_obstack);

  frame_stash_create ();

  observer_attach_target_changed (frame_observer_target_changed);

  add_prefix_cmd ("backtrace", class_maintenance, set_backtrace_cmd, _("\
Set backtrace specific variables.\n\
Configure backtrace variables such as the backtrace limit"),
		  &set_backtrace_cmdlist, "set backtrace ",
		  0/*allow-unknown*/, &setlist);
  add_prefix_cmd ("backtrace", class_maintenance, show_backtrace_cmd, _("\
Show backtrace specific variables\n\
Show backtrace variables such as the backtrace limit"),
		  &show_backtrace_cmdlist, "show backtrace ",
		  0/*allow-unknown*/, &showlist);

  add_setshow_boolean_cmd ("past-main", class_obscure,
			   &backtrace_past_main, _("\
Set whether backtraces should continue past \"main\"."), _("\
Show whether backtraces should continue past \"main\"."), _("\
Normally the caller of \"main\" is not of interest, so GDB will terminate\n\
the backtrace at \"main\".  Set this variable if you need to see the rest\n\
of the stack trace."),
			   NULL,
			   show_backtrace_past_main,
			   &set_backtrace_cmdlist,
			   &show_backtrace_cmdlist);

  add_setshow_boolean_cmd ("past-entry", class_obscure,
			   &backtrace_past_entry, _("\
Set whether backtraces should continue past the entry point of a program."),
			   _("\
Show whether backtraces should continue past the entry point of a program."),
			   _("\
Normally there are no callers beyond the entry point of a program, so GDB\n\
will terminate the backtrace there.  Set this variable if you need to see\n\
the rest of the stack trace."),
			   NULL,
			   show_backtrace_past_entry,
			   &set_backtrace_cmdlist,
			   &show_backtrace_cmdlist);

  add_setshow_uinteger_cmd ("limit", class_obscure,
			    &backtrace_limit, _("\
Set an upper bound on the number of backtrace levels."), _("\
Show the upper bound on the number of backtrace levels."), _("\
No more than the specified number of frames can be displayed or examined.\n\
Literal \"unlimited\" or zero means no limit."),
			    NULL,
			    show_backtrace_limit,
			    &set_backtrace_cmdlist,
			    &show_backtrace_cmdlist);

  /* Debug this files internals.  */
  add_setshow_zuinteger_cmd ("frame", class_maintenance, &frame_debug,  _("\
Set frame debugging."), _("\
Show frame debugging."), _("\
When non-zero, frame specific internal debugging is enabled."),
			     NULL,
			     show_frame_debug,
			     &setdebuglist, &showdebuglist);
}
@


1.319
log
@Fix set debug frame output

gdb/
2013-09-26  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Fix set debug frame output.
	* frame.c (fprint_frame_type): Add TAILCALL_FRAME entry.  Move
	SENTINEL_FRAME entry lower to match enum frame_type order.
@
text
@d1146 1
a1146 1
    error (_("Attempt to assign to a value that was optimized out."));
@


1.318
log
@2013-05-17  Phil Muldoon  <pmuldoon@@redhat.com>

	* frame.c (frame_stash): Convert to htab.
	(frame_addr_hash): New function.
	(frame_addr_hash_eq): New function.
	(frame_stash_create): Convert function to create
	a hash table.
	(frame_stash_add): Convert function to add an entry to a hash
	table.
	(frame_stash_find): Convert function to search the hash table.
	(frame_stash_invalidate): Convert function to empty the hash
	table.
	(get_frame_id): Only add to stash if a frame_id is created.
	(_initialize_frame): Call frame_stash_create.
@
text
@d317 2
a318 2
    case SENTINEL_FRAME:
      fprintf_unfiltered (file, "SENTINEL_FRAME");
d326 3
@


1.317
log
@Accept "set foo unlimited" in integer/uinteger/zuinteger_unlimited commands.

Currently, several commands take "0" or "-1" to mean "unlimited".

"show" knows when to print "unlimited":

 (gdb) show height
 Number of lines gdb thinks are in a page is 45.
 (gdb) set height 0
 (gdb) show height
 Number of lines gdb thinks are in a page is unlimited.

However, the user can't herself specify "unlimited" directly:

 (gdb) set height unlimited
 No symbol table is loaded.  Use the "file" command.
 (gdb)

This patch addresses that, by adjusting the set handler for all
integer/uinteger/zuinteger_unlimited commands to accept literal
"unlimited".  It also installs a completer.  Presently, we complete on
symbols by default, and at
<http://sourceware.org/ml/gdb-patches/2013-03/msg00864.html> I've
shown a WIP prototype that tried to keep that half working in these
commands.  In the end, it turned out to be more complicated than
justifiable, IMO.  It's super rare to want to pass the value of a
variable/symbol in the program to a GDB set/show knob.  That'll still
work, it's just that we won't assist with completion anymore.  This
patch just sticks with the simple, and completes on "unlimited", and
nothing else.  This simplification means that

  "set he<tab><tab>"

is all it takes to get to:

  "set height unlimited"

The patch then goes through all integer/uinteger/zuinteger_unlimited
commands in the tree, and updates both the online help and the manual
to mention that "unlimited" is accepted in addition to 0/-1.  In the
cases where the command had no online help text at all, this adds it.
I've tried to make the texts read in a way that "unlimited" is
suggested before "0" or "-1" is.

Tested on x86_64 Fedora 17.

gdb/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* cli/cli-decode.c (integer_unlimited_completer): New function.
	(add_setshow_integer_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd): Install the "unlimited"
	completer.
	* cli/cli-setshow.c: Include "cli/cli-utils.h".
	(is_unlimited_literal): New function.
	(do_set_command): Handle literal "unlimited" arguments.
	* frame.c (_initialize_frame) <set backtrace limit>: Document
	"unlimited".
	* printcmd.c (_initialize_printcmd) <set print
	max-symbolic-offset>: Add help text.
	* record-full.c (_initialize_record_full) <set record full
	insn-number-max>: Likewise.
	* record.c (_initialize_record) <set record
	instruction-history-size, set record function-call-history-size>:
	Add help text.
	* ser-tcp.c (_initialize_ser_tcp) <set tcp connect-timeout>: Add
	help text.
	* tracepoint.c (_initialize_tracepoint) <set trace-buffer-size>:
	Likewise.
	* source.c (_initialize_source) <set listsize>: Add help text.
	* utils.c (initialize_utils) <set height, set width>: Likewise.
	<set pagination>: Mention "set height unlimited".
	* valprint.c (_initialize_valprint) <set print elements, set print
	repeats>: Document "unlimited".

gdb/doc/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (Process Record and Replay): Document that "set
	record full insn-number-max", "set record
	instruction-history-size" and "set record
	function-call-history-size" accept "unlimited".
	(Backtrace): Document that "set backtrace limit" accepts
	"unlimited".
	(List): Document that "set listsize" accepts "unlimited".
	(Print Settings)" Document that "set print max-symbolic-offset",
	"set print elements" and "set print repeats" accept "unlimited".
	(Starting and Stopping Trace Experiments): Document that "set
	trace-buffer-size" accepts "unlimited".
	(Remote Configuration): Document that "set tcp connect-timeout"
	accepts "unlimited".
	(Command History): Document that "set history size" accepts
	"unlimited".
	(Screen Size): Document that "set height" and "set width" accepts
	"unlimited".  Adjust "set pagination"'s description to suggest
	"set height unlimited" instead of "set height 0".

gdb/testsuite/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* gdb.base/completion.exp: Test "set height", "set listsize" and
	"set trace-buffer-size" completion.
	* gdb.base/setshow.exp: Test "set height unlimited".
	* gdb.trace/trace-buffer-size.exp: Test "set trace-buffer-size
	unlimited".
@
text
@d46 1
d132 30
a161 1
/* A frame stash used to speed up frame lookups.  */
d163 11
a173 3
/* We currently only stash one frame at a time, as this seems to be
   sufficient for now.  */
static struct frame_info *frame_stash = NULL;
d175 19
a193 1
/* Add the following FRAME to the frame stash.  */
d198 10
a207 1
  frame_stash = frame;
d210 3
a212 2
/* Search the frame stash for an entry with the given frame ID.
   If found, return that frame.  Otherwise return NULL.  */
d217 2
a218 2
  if (frame_stash && frame_id_eq (frame_stash->this_id.value, id))
    return frame_stash;
d220 3
a222 1
  return NULL;
d225 3
a227 1
/* Invalidate the frame stash by removing all entries in it.  */
d232 1
a232 1
  frame_stash = NULL;
d418 1
a420 2
  frame_stash_add (fi);

d2523 2
@


1.316
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d2498 1
a2498 1
Zero is unlimited."),
@


1.315
log
@gdb/
2013-02-16  Yuanhui Zhang  <asmwarrior@@gmail.com>

	* frame.c: Remove one extra white space after #include
	directive.
@
text
@d1681 1
a1681 1
      morestack_msym = lookup_minimal_symbol_by_pc (this_pc_in_block);
@


1.314
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d45 1
a45 1
#include  "tracepoint.h"
@


1.313
log
@rename frame_register_read into deprecated_frame_register_read.

gdb/ChangeLog:

        * frame.h (deprecated_frame_register_read): Renames
        frame_register_read.
        * frame.c (deprecated_frame_register_read): Renames
        frame_register_read.  Update all callers.
        * i386-tdep.c: Update all callers of frame_register_read.
        * infcmd.c: Likewise.
        * jit.c: Likewise.
        * mips-tdep.c: Likewise.
        * mt-tdep.c: Likewise.
        * sh64-tdep.c: Likewise.
@
text
@d3 1
a3 2
   Copyright (C) 1986-1987, 1989, 1991, 1994-1996, 1998, 2000-2004,
   2007-2012 Free Software Foundation, Inc.
@


1.312
log
@Document replacement for frame_register_read (deprecated).

gdb/ChangeLog:

        * frame.h (frame_register_read): Remove FIXME comment.
        * frame.c (frame_register_read): Add suggestion explaining
        which function to use in place of this one.
@
text
@d779 1
a779 1
  if (!frame_register_read (src, regnum, buf))
d1100 1
a1100 1
frame_register_read (struct frame_info *frame, int regnum,
d1221 1
a1221 1
	  frame_register_read (frame, regnum, buf);
@


1.311
log
@	* frame.c (put_frame_register): Don't use temporary buffer.
@
text
@d1091 2
a1092 1
/* frame_register_read ()
@


1.310
log
@gdb/
	PR 14119
	* frame.c (skip_inlined_frames): Skip also TAILCALL_FRAME frames.
	(frame_pop): Drop also TAILCALL_FRAME frames.
	* infcmd.c (finish_command): Ignore also TAILCALL_FRAME frames.

gdb/testsuite/
	PR 14119
	* gdb.arch/amd64-tailcall-ret.S: New file.
	* gdb.arch/amd64-tailcall-ret.c: New file.
	* gdb.arch/amd64-tailcall-ret.exp: New file.
	* gdb.reverse/amd64-tailcall-reverse.S: New file.
	* gdb.reverse/amd64-tailcall-reverse.c: New file.
	* gdb.reverse/amd64-tailcall-reverse.exp: New file.
@
text
@d1080 1
a1080 6
	/* FIXME: write_memory doesn't yet take constant buffers.
           Arrrg!  */
	gdb_byte tmp[MAX_REGISTER_SIZE];

	memcpy (tmp, buf, register_size (gdbarch, regnum));
	write_memory (addr, tmp, register_size (gdbarch, regnum));
@


1.309
log
@gdb/
	Code cleanup - rename 'inline' depth to 'artificial' depth.
	* breakpoint.c (set_momentary_breakpoint): Rename at a caller to
	frame_id_artificial_p, extend the comment.
	* dwarf2-frame-tailcall.c (tailcall_frame_this_id): Rename at a user.
	* frame.c (fprint_frame_id): Rename at a user, change debug output
	text to "artificial=".
	(skip_inlined_frames): Rename to ...
	(skip_artificial_frames): ... here.  Extend the comment.
	(get_stack_frame_id, frame_unwind_caller_id): Rename at a caller.
	(frame_id_inlined_p): Rename to ...
	(frame_id_artificial_p): ... here.  Rename at a user.
	(frame_id_eq, frame_id_inner, frame_unwind_caller_pc)
	(frame_unwind_caller_pc_if_available, frame_unwind_caller_arch): Rename
	at a user.
	* frame.h (struct frame_id): Rename inline_depth to artificial_depth.
	Extend the comment.
	(frame_id_inlined_p): Rename to ...
	(frame_id_artificial_p): ... here.
	* inline-frame.c (inline_frame_this_id): Rename at a user.
@
text
@d313 2
a314 1
  while (get_frame_type (frame) == INLINE_FRAME)
d819 5
@


1.308
log
@gdb/
	* cli/cli-cmds.c (max_user_call_depth): Add 'unsigned'.
	(init_cmds): Call add_setshow_uinteger_cmd for command
	'max-user-call-depth'.
	* cli/cli-script.c (execute_user_command): Add 'unsigned' to the
	declaration of 'max_user_call_depth'.
	* frame.c (backtrace_limit): Add 'unsigned'.
	(_initialize_frame): Call add_setshow_uinteger_cmd for command
	'limit'.
	* remote.c (remoteaddresssize): Add 'unsigned'.
	(remote_address_masked): Change local var 'address_size' to
	'unsigned'.
	(_initialize_remote): Call add_setshow_uinteger_cmd for
	'remoteaddresssize'.
	* top.c (history_size): Add 'unsigned'.
	(show_commands): Change local variables to 'unsigned'.
	(set_history_size_command): Don't check history_size is negative.
	Adjust the condition to call unstifle_history and set history_size
	to UNIT_MAX.
@
text
@d229 2
a230 2
  if (id.inline_depth)
    fprintf_unfiltered (file, ",inlined=%d", id.inline_depth);
d306 3
a308 2
/* Given FRAME, return the enclosing normal frame for inlined
   function frames.  Otherwise return the original frame.  */
d311 1
a311 1
skip_inlined_frames (struct frame_info *frame)
d358 1
a358 1
  return get_frame_id (skip_inlined_frames (next_frame));
d371 1
a371 1
  next_frame = skip_inlined_frames (next_frame);
d374 1
a374 1
    return get_frame_id (skip_inlined_frames (this_frame));
d439 1
a439 1
frame_id_inlined_p (struct frame_id l)
d444 1
a444 1
  return (l.inline_depth != 0);
d476 2
a477 2
  else if (l.inline_depth != r.inline_depth)
    /* If inline depths are different, the frames must be different.  */
d534 1
a534 1
  else if (l.inline_depth > r.inline_depth
d710 1
a710 1
  return frame_unwind_pc (skip_inlined_frames (this_frame));
d717 1
a717 1
  return frame_unwind_pc_if_available (skip_inlined_frames (this_frame), pc);
d2330 1
a2330 1
  return frame_unwind_arch (skip_inlined_frames (next_frame));
@


1.307
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@d199 1
a199 1
static int backtrace_limit = INT_MAX;
d2491 2
a2492 2
  add_setshow_integer_cmd ("limit", class_obscure,
			   &backtrace_limit, _("\
d2497 4
a2500 4
			   NULL,
			   show_backtrace_limit,
			   &set_backtrace_cmdlist,
			   &show_backtrace_cmdlist);
@


1.306
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	PR gdb/13767

	gdb/
	* frame.c (read_frame_register_unsigned): New.
	* frame.h (read_frame_register_unsigned): Declare.
	* i387-tdep.c (print_i387_status_word): New parameter `status_p'.
	Handle it.
	(print_i387_control_word): New parameter `control_p'.  Handle it.
	(i387_print_float_info): Handle unavailable float registers.

	gdb/testsuite/
	* gdb.trace/unavailable.exp (gdb_unavailable_floats): New.
	(gdb_collect_globals_test): Call it.
@
text
@d168 1
a168 1
int frame_debug;
d2503 1
a2503 1
  add_setshow_zinteger_cmd ("frame", class_maintenance, &frame_debug,  _("\
d2507 3
a2509 3
			    NULL,
			    show_frame_debug,
			    &setdebuglist, &showdebuglist);
@


1.306.2.1
log
@gdb/
	PR 14119
	* frame.c (skip_inlined_frames): Skip also TAILCALL_FRAME frames.
	(frame_pop): Drop also TAILCALL_FRAME frames.
	* infcmd.c (finish_command): Ignore also TAILCALL_FRAME frames.

gdb/testsuite/
	PR 14119
	* gdb.arch/amd64-tailcall-ret.S: New file.
	* gdb.arch/amd64-tailcall-ret.c: New file.
	* gdb.arch/amd64-tailcall-ret.exp: New file.
	* gdb.reverse/amd64-tailcall-reverse.S: New file.
	* gdb.reverse/amd64-tailcall-reverse.c: New file.
	* gdb.reverse/amd64-tailcall-reverse.exp: New file.
@
text
@d312 1
a312 2
  while (get_frame_type (frame) == INLINE_FRAME
	 || get_frame_type (frame) == TAILCALL_FRAME)
a816 5
  /* Ignore TAILCALL_FRAME type frames, they were executed already before
     entering THISFRAME.  */
  while (get_frame_type (prev_frame) == TAILCALL_FRAME)
    prev_frame = get_prev_frame (prev_frame);

@


1.305
log
@	* frame.c (find_frame_sal): Initialize sal->pspace field from frame
	data.
	* stack.c (set_last_displayed_sal): Validate that PSPACE is not NULL.

testuite:
	* gdb.base/break-inline.exp: New file.
	* gdb.base/break-inline.c: New file.
@
text
@d1034 20
@


1.304
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2099 2
@


1.303
log
@Move unwind reasons to an external .def file

gdb/
	* frame.c (frame_stop_reason_string): Rewrite using
	unwind_stop_reasons.def.
	* frame.h (enum unwind_stop_reason): Likewise.
	* python/py-frame.c (gdbpy_initialize_frames): Likewise.
	(gdbpy_frame_stop_reason_string): Use new enum unwind_stop_reason
	constants for bound-checking.
	* unwind_stop_reasons.def: New file.
	* stack.c (backtrace_command_1): Handle UNWIND_FIRST_ERROR as an alias
	instead of a distinct value.

doc/
	* gdb.texinfo ((Frames In Python): Document
	gdb.FRAME_UNWIND_FIRST_ERROR contant.
@
text
@d3 2
a4 3
   Copyright (C) 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000, 2001,
   2002, 2003, 2004, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.303.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1986-1987, 1989, 1991, 1994-1996, 1998, 2000-2004,
   2007-2012 Free Software Foundation, Inc.
@


1.302
log
@gdb/
	Recognize virtual tail call frames.
	* Makefile.in (SFILES): Add dwarf2-frame-tailcall.c.
	(HFILES_NO_SRCDIR): Add dwarf2-frame-tailcall.h.
	(COMMON_OBS): Add dwarf2-frame-tailcall.o.
	* dwarf2-frame-tailcall.c: New file.
	* dwarf2-frame-tailcall.h: New file.
	* dwarf2-frame.c: Include dwarf2-frame-tailcall.h.
	(execute_cfa_program): New function comment.  Return INSN_PTR.  Reset
	REGS.PREV only after CIE execution.
	(struct dwarf2_frame_cache): New field tailcall_cache.
	(dwarf2_frame_cache): New variables entry_pc, entry_cfa_sp_offset,
	entry_cfa_sp_offset_p and instr.  Execute FDE instructions in two
	parts, try to find entry_cfa_sp_offset.  Call
	dwarf2_tailcall_sniffer_first.
	(dwarf2_frame_prev_register): Call dwarf2_tailcall_prev_register_first
	when appropriate.
	(dwarf2_frame_dealloc_cache): New function.
	(dwarf2_frame_sniffer): Preinitialize cache by dwarf2_frame_cache.
	(dwarf2_frame_unwind): Install dwarf2_frame_dealloc_cache.
	(dwarf2_signal_frame_unwind): Do not install dwarf2_frame_dealloc_cache.
	(dwarf2_append_unwinders): Add dwarf2_tailcall_frame_unwind.
	(dwarf2_frame_cfa): Support also dwarf2_tailcall_frame_unwind.
	* dwarf2loc.c (func_addr_to_tail_call_list)
	(tailcall_dump, call_sitep, VEC (call_sitep), chain_candidate)
	(call_site_find_chain_1, call_site_find_chain): New.
	* dwarf2loc.h (struct call_site_chain): New.
	(call_site_find_chain): New declaration.
	* frame.c (get_frame_address_in_block): Support also TAILCALL_FRAME.
	* frame.h (enum frame_type): New entry TAILCALL_FRAME.
	* python/py-frame.c (gdbpy_initialize_frames): Add TAILCALL_FRAME.
	* stack.c (frame_info): Support also TAILCALL_FRAME.

gdb/doc/
	Recognize virtual tail call frames.
	* gdb.texinfo (Optimized Code): Add reference to Tail Call Frames.
	(Tail Call Frames): New node.
	(Frames In Python): Add gdb.TAILCALL_FRAME.

gdb/testsuite/
	Recognize virtual tail call frames.
	* gdb.arch/amd64-entry-value.cc (c, a, b, amb_z, amb_y, amb_x, amb)
	(amb_b, amb_a): New.
	(main): Call a and b.
	* gdb.arch/amd64-entry-value.exp (tailcall: breakhere, tailcall: bt)
	(tailcall: p i, tailcall: p j, set $sp0=$sp, up, p $sp0 == $sp, frame 3)
	(p $sp0 + sizeof (void *) == $sp, ambiguous: breakhere, ambiguous: bt):
	New tests.
@
text
@d2354 4
a2357 2
    case UNWIND_NULL_ID:
      return _("unwinder did not report frame ID");
a2358 14
    case UNWIND_UNAVAILABLE:
      return _("Not enough registers or memory available to unwind further");

    case UNWIND_INNER_ID:
      return _("previous frame inner to this frame (corrupt stack?)");

    case UNWIND_SAME_ID:
      return _("previous frame identical to this frame (corrupt stack?)");

    case UNWIND_NO_SAVED_PC:
      return _("frame did not save the PC");

    case UNWIND_NO_REASON:
    case UNWIND_FIRST_ERROR:
@


1.301
log
@2011-09-06  Luis Machado  <lgustavo@@codesourcery.com>

	* frame.c (has_stack_frames): Check for currently selected
	traceframe.
@
text
@d2038 2
a2039 1
  if (get_frame_type (next_frame) == NORMAL_FRAME
d2041 1
@


1.300
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@d1331 6
a1336 3
  /* No current inferior, no frame.  */
  if (ptid_equal (inferior_ptid, null_ptid))
    return 0;
d1338 3
a1340 3
  /* Don't try to read from a dead thread.  */
  if (is_exited (inferior_ptid))
    return 0;
d1342 4
a1345 3
  /* ... or from a spinning thread.  */
  if (is_executing (inferior_ptid))
    return 0;
@


1.299
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d1309 2
a1310 2
      if (catch_exceptions (uiout, unwind_to_current_frame, sentinel_frame,
			    RETURN_MASK_ERROR) != 0)
@


1.298
log
@	gdb/
	* frame.h (frame_unwind_caller_pc_if_available): Declare.
	* frame.c (frame_unwind_caller_pc_if_available): New.
	* stack.c (frame_info): Handle unavailable PC.
@
text
@d915 6
d1616 9
d2351 3
@


1.297
log
@	gdb/
	* frame.c (frame_unwind_pc): Rename to ...
	(frame_unwind_pc_if_available): ... this.  New `pc' output
	parameter.  Change return type to int.  Gracefully handle
	gdbarch_unwind_pc throwing NOT_AVAILABLE_ERROR.  Return 0 if that
	happened, or 1 otherwise.
	(frame_unwind_pc): Reimplement on top of
	frame_unwind_pc_if_available.
	(get_frame_func): Rename to ...
	(get_frame_func_if_available): New `pc' output parameter.  Change
	return type to int.  Gracefully handle the PC not being available.
	(get_frame_func): Reimplement on top of
	get_frame_func_if_available.
	(select_frame): Handle the PC being unavailable.
	(get_prev_frame): Handle the PC being unavailable.
	(get_frame_pc_if_available): New.
	(get_frame_address_in_block_if_available): New.
	(find_frame_sal): Handle the frame PC not being available.
	* frame.h (get_frame_pc_if_available): Declare.
	(get_frame_address_in_block_if_available): Declare.
	(get_frame_func_if_available): Declare.
	* stack.c (print_frame_info): Handle the PC being unavailable.
	(find_frame_funname): Ditto.
	(print_frame): Handle the PC being unavailable.
	(get_frame_language): Ditto.
	* blockframe.c (get_frame_block): Ditto.
	* macroscope.c (default_macro_scope): Ditto.
	* tui/tui-stack.c (tui_show_frame_info): Ditto.
@
text
@d714 7
@


1.296
log
@	gdb/
	* dwarf2loc.c (read_pieced_value): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	(write_pieced_value): Handle get_frame_register_bytes returning
	that the register piece is unavailable/optimized out when doing a
	read-modify write of a bitfield.
	* findvar.c (value_from_register): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	* frame.c (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.  Throw error on bad debug info.  Use
	frame_register instead of frame_register_read, to fill in the new
	arguments.
	* frame.h (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.
	* valops.c: (value_assign): Adjust, and handle
	get_frame_register_bytes failing.
	* spu-tdep.c: Include exceptions.h.
	(spu_software_single_step): Adjust, and handle
	get_frame_register_bytes failing.
	(spu_get_longjmp_target): Ditto.
	* gdbarch.sh (register_to_value): Change to return int.  New
	parameters `optimizedp' and `unavailablep'.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_register_to_value): Adjust to new
	gdbarch_register_to_value interface.
	* i387-tdep.c (i387_register_to_value): Ditto.
	* i387-tdep.h (i387_register_to_value): Ditto.
	* alpha-tdep.c (alpha_register_to_value): Ditto.
	* ia64-tdep.c (ia64_register_to_value): Ditto.
	* m68k-tdep.c (m68k_register_to_value): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* rs6000-tdep.c (rs6000_register_to_value): Ditto.
@
text
@d622 2
a623 2
static CORE_ADDR
frame_unwind_pc (struct frame_info *this_frame)
a626 2
      CORE_ADDR pc;

d629 4
d649 31
a679 1
	  pc = gdbarch_unwind_pc (frame_unwind_arch (this_frame), this_frame);
a682 8
      this_frame->prev_pc.value = pc;
      this_frame->prev_pc.p = 1;
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "{ frame_unwind_caller_pc "
			    "(this_frame=%d) -> %s }\n",
			    this_frame->level,
			    hex_string (this_frame->prev_pc.value));
d684 21
a704 1
  return this_frame->prev_pc.value;
d713 2
a714 2
CORE_ADDR
get_frame_func (struct frame_info *this_frame)
d720 2
d724 30
a753 8
      CORE_ADDR addr_in_block = get_frame_address_in_block (this_frame);
      next_frame->prev_func.p = 1;
      next_frame->prev_func.addr = get_pc_function_start (addr_in_block);
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "{ get_frame_func (this_frame=%d) -> %s }\n",
			    this_frame->level,
			    hex_string (next_frame->prev_func.addr));
d755 11
a765 1
  return next_frame->prev_func.addr;
a1378 2
  struct symtab *s;

d1398 10
a1407 11
      /* We retrieve the frame's symtab by using the frame PC.  However
         we cannot use the frame PC as-is, because it usually points to
         the instruction following the "call", which is sometimes the
         first instruction of another function.  So we rely on
         get_frame_address_in_block() which provides us with a PC which
         is guaranteed to be inside the frame's code block.  */
      s = find_pc_symtab (get_frame_address_in_block (fi));
      if (s
	  && s->language != current_language->la_language
	  && s->language != language_unknown
	  && language_mode == language_mode_auto)
d1409 7
a1415 1
	  set_language (s->language);
d1419 1
a1419 1
	
d1839 3
d1846 1
d1861 1
d1908 1
d1922 1
a1922 1
      && get_frame_pc (this_frame) == 0)
d1938 22
d2020 18
d2043 1
d2084 8
a2091 2
  notcurrent = (get_frame_pc (frame) != get_frame_address_in_block (frame));
  (*sal) = find_pc_line (get_frame_pc (frame), notcurrent);
@


1.295
log
@	gdb/
	* findvar.c (value_of_register): Mark the value as unavailable, if
	the register is unavailable.
	* frame.h (frame_register_unwind): New `unavailablep' parameter.
	(frame_register): New `unavailablep' parameter.
	(frame_register_read): Update comment.
	* frame.c (frame_register_unwind): New `unavailablep' parameter.
	Set it if the register is unavailable.  If the register is
	unavailable, clear the output buffer.
	(frame_register): New `unavailablep' parameter.  Pass it down.
	(frame_unwind_register): Adjust.
	(put_frame_register): Adjust.
	(frame_register_read): Adjust.  Also return false if the register
	is not available.
	(frame_register_unwind_location): Adjust.
	* sentinel-frame.c (sentinel_frame_prev_register): If the register
	is unavailable, mark the value accordingly.
	* stack.c (frame_info): Handle unavailable registers.

	gdb/testsuite/
	* gdb.trace/unavailable.exp (fpreg, spreg, pcreg): Define.
	(test_register, test_register_unavailable): New procedures.
	(gdb_unavailable_registers_test): New procedure.
	(gdb_trace_collection_test): Call it.
@
text
@d1004 2
a1005 1
			  CORE_ADDR offset, int len, gdb_byte *myaddr)
d1032 2
a1033 5
    {
      warning (_("Bad debug information detected: "
		 "Attempt to read %d bytes from registers."), len);
      return 0;
    }
d1045 7
a1051 1
	  if (!frame_register_read (frame, regnum, myaddr))
d1057 7
a1063 2

	  if (!frame_register_read (frame, regnum, buf))
d1074 2
@


1.294
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d760 3
a762 2
		       int *optimizedp, enum lval_type *lvalp,
		       CORE_ADDR *addrp, int *realnump, gdb_byte *bufferp)
d779 1
d784 8
a791 3
  if (bufferp && !*optimizedp)
    memcpy (bufferp, value_contents_all (value),
	    TYPE_LENGTH (value_type (value)));
d801 1
a801 1
		int *optimizedp, enum lval_type *lvalp,
d815 2
a816 2
  frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			 realnump, bufferp);
d823 1
d828 2
a829 2
  frame_register_unwind (frame, regnum, &optimized, &lval, &addr,
			 &realnum, buf);
d951 1
d955 2
a956 1
  frame_register (frame, regnum, &optim, &lval, &addr, &realnum, NULL);
d991 1
d996 2
a997 1
  frame_register (frame, regnum, &optimized, &lval, &addr, &realnum, myaddr);
d999 1
a999 1
  return !optimized;
d1440 4
a1443 2
      frame_register_unwind (this_frame, regnum, optimizedp, lvalp,
			     addrp, realnump, NULL);
@


1.293
log
@2011-03-15  Michael Snyder  <msnyder@@vmware.com>

	* frame.c (find_frame_sal): Assert sym is not null.
@
text
@d690 1
a690 1
static int
d693 4
a696 1
  return frame_register_read (src, regnum, buf);
@


1.292
log
@	* thread.c (restore_selected_frame): Handle frame_level == -1.
	(make_cleanup_restore_current_thread): Use
	get_selected_frame_if_set.
	* frame.h (get_selected_frame_if_set): Declare.
	* frame.c (get_selected_frame_if_set): New function.
@
text
@d1902 2
@


1.291
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d1250 8
@


1.290
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d502 1
a502 1
   IDs in certain circumstances. Assuming that NEXT is the immediate
d522 1
a522 1
   its maximum stack size. In this case, certain compilers implement
d1126 1
a1126 1
/* Info about the innermost stack frame (contents of FP register) */
d1282 1
a1282 1
     be called when the user's selected frame is being changed. */
d1390 1
a1390 1
  /* Since we can't really be sure what the first object allocated was */
d2290 1
a2290 1
  /* Debug this files internals. */
@


1.289
log
@gdb/
	* frame.c (get_prev_frame_1) <UNWIND_INNER_ID>: New variables
	this_pc_in_block, morestack_msym and morestack_name.  Check for
	"__morestack" minimal symbol there.

gdb/testsuite/
	* gdb.base/morestack.exp: New file.
	* gdb.base/morestack.c: New file.
@
text
@d184 3
a186 2
  fprintf_filtered (file, _("\
Whether backtraces should continue past \"main\" is %s.\n"),
d195 2
a196 2
  fprintf_filtered (file, _("\
Whether backtraces should continue past the entry point of a program is %s.\n"),
d205 3
a207 2
  fprintf_filtered (file, _("\
An upper bound on the number of backtrace levels is %s.\n"),
d452 2
a453 1
  if (!l.stack_addr_p && l.special_addr_p && !r.stack_addr_p && r.special_addr_p)
d655 2
a656 1
			    "{ frame_unwind_caller_pc (this_frame=%d) -> %s }\n",
d839 3
a841 2
      fprintf_unfiltered (gdb_stdlog, "\
{ frame_unwind_register_value (frame=%d,regnum=%d(%s),...) ",
d1322 2
a1323 1
  fi->next = create_sentinel_frame (current_program_space, get_current_regcache ());
d1526 2
a1527 1
	      fprintf_unfiltered (gdb_stdlog, " // this frame ID is inner }\n");
@


1.288
log
@run copyright.sh for 2011.
@
text
@d1505 10
a1514 1
      if (frame_debug)
d1516 8
a1523 3
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // this frame ID is inner }\n");
a1524 2
      this_frame->stop_reason = UNWIND_INNER_ID;
      return NULL;
@


1.287
log
@gdb/
	Code cleanup.
	* dummy-frame.c (dummy_frame_unwinder): Remove its static qualifier.
	Rename to dummy_frame_unwind.
	(dummy_frame_unwind): Remove.
	* dummy-frame.h (dummy_frame_unwind): Reference directly the struct.
	* frame-unwind.c (frame_unwind_init): Use address of
	dummy_frame_unwind and inline_frame_unwind.
	* frame.c (create_sentinel_frame): Use address of
	sentinel_frame_unwind.
	* inline-frame.c (inline_frame_unwinder): Rename to
	inline_frame_unwind.
	(inline_frame_unwind): Remove.
	* inline-frame.h (inline_frame_unwind): Reference directly the struct.
	* sentinel-frame.c (sentinel_frame_unwinder): Rename to
	sentinel_frame_unwind.
	(sentinel_frame_unwind): Remove.
	* sentinel-frame.h (sentinel_frame_unwind): Reference directly the
	struct.
@
text
@d4 2
a5 1
   2002, 2003, 2004, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.286
log
@gdb/
	Code cleanup.
	* frame-unwind.c (frame_unwind_find_by_frame): Remove the return type
	and returned value.  New comment from frame-unwind.h.
	* frame-unwind.h (frame_unwind_find_by_frame): Remove the return type.
	Extend the comment.
	* frame.c (get_frame_id, frame_unwind_register_value)
	(create_new_frame, get_prev_frame_1, frame_unwinder_is)
	(get_frame_type, frame_unwind_arch): Do not use the return value of
	frame_unwind_find_by_frame.
@
text
@d1103 1
a1103 1
  frame->unwind = sentinel_frame_unwind;
@


1.285
log
@	* breakpoint.c (update_watchpoint, _initialize_breakpoint): Remove
	unnecessary space in string.
	* filesystem.c (_initialize_filesystem): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* infcmd.c (step_once): Ditto.
	* infrun.c (_initialize_infrun): Ditto.
	* linux-nat.c (linux_child_follow_fork): Ditto.
	* maint.c (maintenance_deprecate): Ditto.
	* memattr.c (_initialize_mem): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* monitor.c (monitor_open): Ditto.
	* procfs.c (procfs_xfer_memory): Ditto.
	* reverse.c (bookmarks_info): Ditto.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Ditto.
	* stack.c (_initialize_stack): Ditto.
	* tracepoint.c (_initialize_tracepoint): Ditto.
	* xtensa-tdep.c (xtensa_supply_gregset,
	xtensa_regset_from_core_section): Ditto.
@
text
@d332 1
a332 1
	fi->unwind = frame_unwind_find_by_frame (fi, &fi->prologue_cache);
d842 1
a842 1
    frame->unwind = frame_unwind_find_by_frame (frame, &frame->prologue_cache);
d1331 1
a1331 1
  fi->unwind = frame_unwind_find_by_frame (fi, &fi->prologue_cache);
d1466 1
a1466 2
    this_frame->unwind
      = frame_unwind_find_by_frame (this_frame, &this_frame->prologue_cache);
d1963 1
a1963 1
    fi->unwind = frame_unwind_find_by_frame (fi, &fi->prologue_cache);
d1985 1
a1985 1
    frame->unwind = frame_unwind_find_by_frame (frame, &frame->prologue_cache);
d2065 1
a2065 3
	next_frame->unwind
	  = frame_unwind_find_by_frame (next_frame,
					&next_frame->prologue_cache);
@


1.284
log
@	* frame.c (frame_register_unwind): Do not access contents
	of "optimized out" unwound register value.
@
text
@d2255 1
a2255 1
will terminate the backtrace there.  Set this variable if you need to see \n\
@


1.283
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* findcmd.c: White space.
	* findvar.c: White space.
	* fork-child.c: White space.
	* frame-base.c: White space.
	* frame.c: White space.
	* frame-unwind.c: White space.
	* f-valprint.c: White space.
@
text
@d774 1
a774 1
  if (bufferp)
@


1.282
log
@2010-05-13  Michael Snyder  <msnyder@@vmware.com>

	* frame.c: White space, add blank lines.
@
text
@d595 1
d624 1
d947 1
d1004 1
d1020 1
d1032 1
d1064 1
d1075 1
@


1.281
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* serial.c (serial_for_fd): Delete unused variable.
	* mdebugread.c (psymtab_to_symtab_1): Delete unused variable.
	* top.c (execute_command): Delete unused variable.
	(init_main): Delete unused variable.
	* utils.c (do_fclose_cleanup): Delete unused variable.
	(do_all_inferior_continuations): Delete unused variable.
	(initialize_utils): Delete unused variable.
	(internal_problem_mode): Delete unused global.
	* frame.c (get_prev_frame): Delete unused global.
	(get_frame_locals_address): Delete unused global.
	(get_frame_args_address): Delete unused global.
@
text
@d384 1
d398 1
d410 1
d420 1
d448 1
d526 1
d696 1
d809 1
d896 1
d914 1
d934 1
d972 1
d1086 1
d1126 1
d1140 1
d2020 1
d2030 1
d2092 1
@


1.280
log
@2010-04-15  Stan Shebs  <stan@@codesourcery.com>

	* frame.c: Include tracepoint.h.
	(get_current_frame): Allow a trace frame to be an alternate source
	of stack frame data.
	* tracepoint.c (tfind_1): Don't try to get current stack frame if
	it won't succeed.
@
text
@a1679 2
  struct frame_info *prev_frame;

a1906 1
  void **cache;
a1921 1
  void **cache;
@


1.279
log
@	* regcache.c (regcache_xmalloc): Add aspace argument.  Use it
	for the new regcache.  All callers updated.
	(regcache_cpy, regcache_cpy_no_passthrough): Do not set aspace here.
	(get_thread_arch_regcache): Do not set aspace here.
	* regcache.h (regcache_xmalloc): Update declaration.

	* frame.c, infcall.c, ppc-linux-tdep.c: Calls to
	regcache_xmalloc updated.
@
text
@d46 1
d1148 10
a1157 6
  if (ptid_equal (inferior_ptid, null_ptid))
    error (_("No selected thread."));
  if (is_exited (inferior_ptid))
    error (_("Invalid selected thread."));
  if (is_executing (inferior_ptid))
    error (_("Target is executing."));
@


1.278
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d685 3
a687 1
  struct regcache *regcache = regcache_xmalloc (get_frame_arch (this_frame));
@


1.277
log
@gdb/
	Remove INVALID_ENTRY_POINT.
	* frame.c (inside_entry_func): New variable entry_point.  Return 0 if
	the entry point is not known.
	* solib-irix.c (enable_break): Likewise.
	* objfiles.c (init_entry_point_info): Stop using INVALID_ENTRY_POINT.
	Initialize EI.ENTRY_POINT_P.
	(entry_point_address): Rename to ...
	(entry_point_address_query): ... a new function.  Use EI.ENTRY_POINT_P.
	(entry_point_address): New function.
	(objfile_relocate): Use EI.ENTRY_POINT_P.
	* objfiles.h (struct entry_info): Simplify entry_point comment.  New
	field entry_point_p.
	(INVALID_ENTRY_POINT): Remove.
	(entry_point_address_query): New prototype.
	* solib-frv.c (enable_break): Check for NULL SYMFILE_OBJFILE and its
	EI.ENTRY_POINT_P.  Return 0 if ".interp" is not found.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.276
log
@2009-10-23  Tristan Gingold  <gingold@@adacore.com>

	* frame.c (frame_unwind_pc): Fix typo: remove duplicate 0x.
@
text
@d1653 6
a1658 1
  return (get_frame_func (this_frame) == entry_point_address ());
@


1.275
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d642 1
a642 1
			    "{ frame_unwind_caller_pc (this_frame=%d) -> 0x%s }\n",
@


1.274
log
@        gdb/
        * frame.c (get_frame_id): Default to outer_frame_id if the this_id
        method does not supply an ID.  Assert that the result is not
        null_frame_id.
        (outer_frame_id): New.
        (frame_id_p): Accept outer_frame_id.
        (frame_id_eq): Allow outer_frame_id to be equal to itself.
        (frame_find_by_id): Revert previous local workarounds.
        (get_prev_frame_1): Adjust end-of-stack check to test outer_frame_id.
        * frame.h (null_frame_id, frame_id_p): Update comments.
        (outer_frame_id): Declare.
        * infrun.c (handle_inferior_event): Do not treat all steps from the
        outermost frame as subroutine calls.

        * libunwind-frame.c (libunwind_frame_this_id): Do not clear THIS_ID.
        * hppa-tdep.c (hppa_stub_frame_this_id): Likewise.
        * ia64-tdep.c (ia64_frame_this_id): Likewise.
        (ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id):
        Use outer_frame_id instead of null_frame_id.
        * amd64obsd-tdep.c (amd64obsd_trapframe_cache): Use outer_frame_id.
        * i386obsd-tdep.c (i386obsd_trapframe_cache): Likewise.
        * inline-frame.c (inline_frame_this_id): Refuse outer_frame_id.
        * thread.c (restore_selected_frame): Update comment and remove
        frame_id_p check.

        gdb/doc/
        * gdbint.texinfo (Unwinding the Frame ID): Reference outer_frame_id.
@
text
@d73 6
d1068 1
a1068 1
create_sentinel_frame (struct regcache *regcache)
d1072 2
d1155 1
a1155 1
	create_sentinel_frame (get_current_regcache ());
d1286 1
a1286 1
  fi->next = create_sentinel_frame (get_current_regcache ());
d1295 4
d1572 5
d1959 23
@


1.273
log
@        Avoid quadratic behavior when computing the value of a register.
        * frame.c (frame_stash): New static constant.
        (frame_stash_add, frame_stash_find, frame_stash_invalidate):
        New functions.
        (get_frame_id): Minor reformatting. Add the frame to the frame stash.
        (frame_find_by_id): Search the frame stash first before walking all
        frames starting from te current_frame.
        (reinit_frame_stash): Add call to frame_stash_invalidate ();
@
text
@d327 2
d330 1
d370 1
d412 3
d437 8
a444 1
  if (!l.stack_addr_p || !r.stack_addr_p)
d1442 1
a1442 1
  if (this_frame->level >= 0 && !frame_id_p (this_id))
@


1.272
log
@gdb
	* frame.h (frame_unwinder_is): Declare.
	* frame.c (frame_unwinder_is): New function.
	* dwarf2loc.c: Include dwarf2-frame.h.
	(dwarf_expr_frame_cfa): New function.
	(dwarf2_evaluate_loc_desc): Use it.
	(needs_frame_frame_cfa): New function.
	(dwarf2_loc_desc_needs_frame): Use it.
	* dwarf2expr.h (struct dwarf_expr_context) <get_frame_cfa>: New
	field.
	* dwarf2expr.c (execute_stack_op) <DW_OP_call_frame_cfa>: New
	case.
	* dwarf2-frame.h (dwarf2_frame_cfa): Declare.
	* dwarf2-frame.c (no_get_frame_cfa): New function.
	(execute_stack_op): Use it.
	(dwarf2_frame_cfa): New function.
gdb/testsuite
	* gdb.dwarf2/callframecfa.exp: New file.
	* gdb.dwarf2/callframecfa.S: New file.
@
text
@d125 34
d316 2
a317 3
    {
      return null_frame_id;
    }
d336 3
d553 12
d1336 1
@


1.271
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d1846 11
@


1.270
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d813 3
d818 1
a818 2
  return extract_signed_integer (buf, register_size (frame_unwind_arch (frame),
						     regnum));
d830 3
d835 1
a835 2
  return extract_unsigned_integer (buf, register_size (frame_unwind_arch (frame),
						       regnum));
d1881 3
a1883 1
  return read_memory_integer (addr, len);
d1890 3
a1892 1
  return read_memory_unsigned_integer (addr, len);
@


1.269
log
@	* frame.h (frame_unwind_arch): New.
	(frame_unwind_caller_arch): Likewise.
	* frame-unwind.h (frame_prev_arch_ftype): New type.
	(struct frame_unwind): New member prev_arch.
	* frame.c (struct frame_info): New member prev_arch.
	(frame_unwind_arch): New function.
	(frame_unwind_caller_arch): Likewise..
	(get_frame_arch): Reimplement in terms of frame_unwind_arch.
	* sentinel-frame.c (sentinel_frame_prev_arch): New function.
	(sentinel_frame_unwinder): Install it.

	* frame.c (frame_pc_unwind): Use frame_unwind_arch instead
	of get_frame_arch.
	(frame_unwind_register_value): Likewise.
	(frame_unwind_register_signed): Likewise.
	(frame_unwind_register_unsigned): Likewise.
	* frame-unwind.c (frame_unwind_got_optimized): Likewise.
	(frame_unwind_got_register): Likewise.
	(frame_unwind_got_constant): Likewise.
	(frame_unwind_got_bytes): Likewise.
	(frame_unwind_got_address): Likewise.

	* frame.h (enum frame_type): New value ARCH_FRAME.
	* frame.c (fprint_frame_type): Handle ARCH_FRAME.
	* stack.c (print_frame_info): Likewise.
@
text
@d172 1
a172 1
    fprintf_unfiltered (file, "%s=0x%s", name, paddr_nz (addr));
d245 1
a245 1
    fprintf_unfiltered (file, "0x%s", paddr_nz (fi->next->prev_pc.value));
d257 1
a257 1
    fprintf_unfiltered (file, "0x%s", paddr_nz (fi->next->prev_func.addr));
d576 1
a576 1
			    paddr_nz (this_frame->prev_pc.value));
d601 1
a601 1
			    "{ get_frame_func (this_frame=%d) -> 0x%s }\n",
d603 1
a603 1
			    paddr_nz (next_frame->prev_func.addr));
d777 3
a779 2
	    fprintf_unfiltered (gdb_stdlog, " address=0x%s",
				paddr_nz (value_address (value)));
d1206 2
a1207 2
			  "{ create_new_frame (addr=0x%s, pc=0x%s) ",
			  paddr_nz (addr), paddr_nz (pc));
@


1.268
log
@	gdb/
	* NEWS: Document inlined function support.
	* Makefile.in (SFILES): Add inline-frame.c.
	(COMMON_OBS): Add inline-frame.o.
	* block.c (contained_in): Rewrite to use lexical nesting.
	(block_linkage_function): Skip inlined function blocks.
	(block_inlined_p): New.
	* block.h (struct block): Update comment.
	(block_inlined_p): New prototype.
	* blockframe.c (get_frame_block): Handle inlined functions.
	(get_frame_function): Do not use block_linkage_function.
	(block_innermost_frame): Use get_frame_block and contained_in.
	* breakpoint.c (watchpoint_check): Remove extra reinit_frame_cache.
	Skip over inlined functions.  Simplify epilogue check.
	(bpstat_check_breakpoint_conditions): Use get_stack_frame_id.
	Update comments.
	(set_momentary_breakpoint): Only accept non-inlined frames.
	(watch_command_1): Use frame_unwind_caller_pc and
	frame_unwind_caller_id instead of get_prev_frame.
	(until_break_command): Likewise.  Use get_stack_frame_id.
	* buildsym.c (end_symtab): Set SYMBOL_SYMTAB for block functions.
	* dwarf2loc.c (dwarf_expr_frame_base): Use block_linkage_function.
	* dwarf2read.c (process_die): Handle DW_TAG_inlined_subroutine.
	(read_func_scope, new_symbol): Likewise.  Handle arguments specially
	for inlined functions without call site information.
	(inherit_abstract_dies): Allow tag mismatch for inlined subroutines.
	(die_specification): Treat DW_AT_abstract_origin as a specification.
	(read_type_die): Handle DW_TAG_inlined_subroutine.
	* frame-unwind.c (frame_unwind_init): Add inline_frame_unwind.
	* frame.c (fprint_frame_id): Print inline depth.
	(fprint_frame_type): Handle INLINE_FRAME and SENTINEL_FRAME.
	(skip_inlined_frames, get_stack_frame_id): New.
	(frame_unwind_caller_id): Use skip_inlined_frames.
	(frame_id_inlined_p): New.
	(frame_id_eq): Make the logic match the comments.  Add inline_depth
	check.
	(frame_id_inner): Handle inlined functions.
	(frame_unwind_pc): New function, copied from frame_unwind_caller_pc.
	(frame_unwind_caller_pc): Use skip_inlined_frames and frame_unwind_pc.
	(get_prev_frame_1): Check for inline frames.  Split out frame
	allocation to get_prev_frame_raw.
	(get_prev_frame_raw): New function.
	(get_prev_frame): Handle inline frames.
	(get_frame_pc): Use frame_unwind_pc.
	(get_frame_address_in_block): Skip inlined frames on both sides.
	(pc_notcurrent): Delete.
	(find_frame_sal): Rewrite to handle inline call sites.  Use
	get_frame_address_in_block.
	(deprecated_update_frame_pc_hack): Make static.
	* frame.h: Update comments.
	(struct frame_id): Add inline_depth.
	(enum frame_type): Add INLINE_FRAME.
	(frame_id_inlined_p, get_stack_frame_id): New prototypes.
	* gdbthread.h (struct thread_info): Add step_stack_frame_id field.
	* infcmd.c (set_step_frame): New function.
	(step_once): Use set_step_frame.  Handle inlined functions.
	(until_next_command): Use set_step_frame.
	(finish_backward), finish_forward): Use get_stack_frame_id.
	(finish_command): Support inlined functions.
	* inferior.h (set_step_info): New prototype.
	* infrun.c (RESUME_ALL): Use minus_one_ptid.
	(clear_proceed_status): Clear step_stack_frame_id.
	(init_wait_for_inferior): Call clear_inline_frame_state.
	(init_execution_control_state): Make static.
	(set_step_info): New function.
	(init_thread_stepping_state): Do not set the symtab or line here.
	(stepped_in_from): New function.
	(handle_inferior_event): Handle inlined functions.  Use set_step_info.
	(insert_step_resume_breakpoint_at_frame): Use get_stack_frame_id.
	(struct inferior_status): Add step_stack_frame_id.
	(save_inferior_status, restore_inferior_status): Save and restore
	step_stack_frame_id.
	* inline-frame.c, inline-frame.h: New files.
	* minsyms.c (prim_record_minimal_symbol_and_info): Use XCALLOC.
	* regcache.c (regcache_write_pc): Call reinit_frame_cache.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Handle INLINE_FRAME.
	* stack.c (frame_show_address): New.
	(print_frame_info, print_frame): Use it.
	(find_frame_funname): Use get_frame_function.  Handle inlined blocks.
	(frame_info): Mark inlined functions.
	(backtrace_command_1): Use get_current_user_frame.
	(print_frame_local_vars, print_frame_label_vars): Update comments.
	(return_command): Refuse inlined functions.
	* symtab.c (lookup_symbol_aux_local): Stop at inlined function
	boundaries.
	(find_function_start_sal): Avoid inlined functions.
	(completion_list_add_fields): New function.
	(default_make_symbol_completion_list): Use it.  Use block_static_block
	and block_global_block.  Check for inlined functions.
	(skip_prologue_using_sal): Avoid line number comparison across
	inlining.
	* symtab.h (struct symbol): Add is_inlined.
	(SYMBOL_INLINED): New.
	* target.c (target_resume): Call clear_inline_frame_state.
	* valops.c (value_of_variable): Check block_inlined_p.

	gdb/doc/
	* gdb.texinfo (Debugging Optimized Code): New chapter.
	(Compiling for Debugging): Reference it.  Move some
	text to the new section.

	gdb/testsuite/
	* gdb.base/break.exp: Add an XFAIL for gcc/36748.
	* gdb.cp/annota2.exp: Accept frames-invalid in more places.
	* gdb.opt/Makefile.in (EXECUTABLES): Update.
	* gdb.opt/clobbered-registers-O2.exp: Update to GPL v3.
	* gdb.opt/inline-bt.c, gdb.opt/inline-bt.exp,
	gdb.opt/inline-cmds.c, gdb.opt/inline-cmds.exp,
	gdb.opt/inline-locals.c, gdb.opt/inline-locals.exp,
	gdb.opt/inline-markers.c: New files.
	* lib/gdb.exp (skip_inline_frame_tests): New function.
	(skip_inline_var_tests): New function.
@
text
@d81 7
d211 3
d548 1
a548 1
      if (gdbarch_unwind_pc_p (get_frame_arch (this_frame)))
d566 1
a566 1
	  pc = gdbarch_unwind_pc (get_frame_arch (this_frame), this_frame);
d745 1
d749 1
d756 1
a756 2
			  user_reg_map_regnum_to_name
			    (get_frame_arch (frame), regnum));
d791 1
a791 1
	      for (i = 0; i < register_size (get_frame_arch (frame), regnum); i++)
d814 1
a814 1
  return extract_signed_integer (buf, register_size (get_frame_arch (frame),
d829 1
a829 1
  return extract_unsigned_integer (buf, register_size (get_frame_arch (frame),
d1894 1
a1894 1
/* Architecture method.  */
d1899 9
a1907 4
  /* In the future, this function will return a per-frame
     architecture instead of current_gdbarch.  Calling the
     routine with a NULL value of this_frame is a bug!  */
  gdb_assert (this_frame);
d1909 27
a1935 1
  return current_gdbarch;
@


1.267
log
@	* frame.c (frame_unwind_id): Renamed to ...
	(frame_unwind_caller_id): ... this.  All callers updated.
	(frame_pc_unwind): Renamed to ...
	(frame_unwind_caller_pc): ... this.  All callers updated.
	* frame.h: Document frame_unwind_caller_WHAT functions.
	(frame_unwind_id): Renamed to ...
	(frame_unwind_caller_id): ... this.
	(frame_pc_unwind): Renamed to ...
	(frame_unwind_caller_pc): ... this.
	* hppa-tdep.c (hppa_find_unwind_entry_in_block): Correct comment.
	* stack.c (parse_frame_specification_1): Do not rely on
	frame_unwind_id.
@
text
@d44 2
d48 1
d179 2
d195 6
d253 12
d297 6
d305 3
a307 1
  /* Use prev_frame, and not get_prev_frame.  The latter will truncate
d311 7
a317 1
  return get_frame_id (get_prev_frame_1 (next_frame));
d372 9
d391 11
a401 5
  else if (!l.code_addr_p || !r.code_addr_p)
    /* An invalid code addr is a wild card, always succeed.  */
    eq = 1;
  else if (l.code_addr != r.code_addr)
    /* If .code addresses are different, the frames are different.  */
d403 1
a403 4
  else if (!l.special_addr_p || !r.special_addr_p)
    /* An invalid special addr is a wild card (or unused), always succeed.  */
    eq = 1;
  else if (l.special_addr == r.special_addr)
d406 1
a406 3
  else
    /* No luck.  */
    eq = 0;
d457 23
d532 2
a533 2
CORE_ADDR
frame_unwind_caller_pc (struct frame_info *this_frame)
d572 6
a1311 1
  struct frame_info *prev_frame;
d1351 8
d1427 2
a1428 1
      && get_frame_type (this_frame->next) == NORMAL_FRAME)
d1457 11
d1590 1
a1590 1
      && get_frame_type (this_frame) != DUMMY_FRAME
d1635 3
a1637 2
  if (!backtrace_past_entry
      && get_frame_type (this_frame) != DUMMY_FRAME && this_frame->level >= 0
d1648 2
a1649 1
      && get_frame_type (this_frame) == NORMAL_FRAME
d1664 1
a1664 1
  return frame_unwind_caller_pc (frame->next);
d1709 10
a1718 1
     NEXT_FRAME.  */
d1720 2
a1721 1
      && get_frame_type (this_frame) == NORMAL_FRAME)
d1727 2
a1728 2
static int
pc_notcurrent (struct frame_info *frame)
d1730 31
d1770 2
a1771 9
  struct frame_info *next = get_next_frame (frame);
  int notcurrent = (next != NULL && get_frame_type (next) == NORMAL_FRAME);
  return notcurrent;
}

void
find_frame_sal (struct frame_info *frame, struct symtab_and_line *sal)
{
  (*sal) = find_pc_line (get_frame_pc (frame), pc_notcurrent (frame));
@


1.266
log
@2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* mi/mi-main.c (mi_cmd_data_evaluate_expression): Use
	value_address.
	* cli/cli-dump.c (dump_value_to_file): Use value_address.
	* valprint.c (common_val_print): Likewise.
	* v850-tdep.c (v850_push_dummy_call): Use value_address.
	* tracepoint.c (encode_actions): Use value_address.
	* printcmd.c (print_formatted): Use value_address.
	(x_command): Likewise.
	* p-valprint.c (pascal_object_print_static_field): Use
	value_address.
	* mn10300-tdep.c (mn10300_push_dummy_call): Use value_address.
	* mips-tdep.c (mips_eabi_push_dummy_call): Use value_address.
	* m32r-tdep.c (m32r_push_dummy_call): Use value_address.
	* jv-valprint.c (java_value_print): Use value_address.
	* infcall.c (find_function_addr): Use value_address.
	* gnu-v3-abi.c (gnuv3_rtti_type): Use value_address.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Use value_address.
	* frv-tdep.c (frv_push_dummy_call): Use value_address.
	* frame.c (frame_register_unwind): Use value_address.
	(frame_unwind_register_value): Likewise.
	* darwin-nat-info.c (info_mach_region_command): Use
	value_address.
	* cp-valprint.c (cp_print_static_field): Use value_address.
	* c-valprint.c (c_value_print): Use value_address.
	* breakpoint.c (update_watchpoint): Use value_address.
	(can_use_hardware_watchpoint): Likewise.
	* ada-valprint.c (ada_val_print_1): Use value_address.
	(ada_value_print): Likewise.
	* ada-tasks.c (read_fat_string_value): Use value_address.
	* jv-lang.c (java_link_class_type): Use set_value_address.
	(java_link_class_type): Likewise.
	(get_java_utf8_name): Use value_address.
	(type_from_class): Likewise.
	(java_link_class_type): Likewise.
	* findvar.c (value_of_register): Use set_value_address.
	(read_var_value): Likewise.
	(read_var_value): Likewise.
	* eval.c (evaluate_subexp_standard): Use set_value_address.
	(evaluate_subexp_standard): Use value_address.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Use set_value_address.
	* ada-lang.c (coerce_unspec_val_to_type): Use set_value_address.
	(ada_value_primitive_packed_val): Likewise.
	(ensure_lval): Likewise.
	(thin_data_pntr): Use value_address.
	(desc_bounds): Likewise.
	(ada_value_primitive_packed_val): Likewise.
	(value_assign_to_component): Likewise.
	(ensure_lval): Likewise.
	(make_array_descriptor): Likewise.
	(ada_to_fixed_value): Likewise.
	(unwrap_value): Likewise.
	* value.c (deprecated_value_address_hack): Remove.
	(value_address): New function.
	(value_raw_address): Likewise.
	(set_value_address): Likewise.
	(value_fn_field): Use set_value_address.
	(value_from_contents_and_address): Likewise.
	(value_fn_field): Likewise.
	(allocate_value_lazy): Don't use VALUE_ADDRESS.
	(value_as_address): Use value_address.
	(value_static_field): Likewise.
	* valops.c (search_struct_field): Use set_value_address.
	(value_at): Likewise.
	(value_at_lazy): Likewise.
	(value_repeat): Likewise.
	(value_cast_structs): Use value_address.
	(value_cast): Likewise.
	(value_fetch_lazy): Likewise.
	(value_assign): Likewise.
	(value_repeat): Likewise.
	(address_of_variable): Likewise.
	(value_coerce_array): Likewise.
	(value_coerce_function): Likewise.
	(value_addr): Likewise.
	(search_struct_field): Likewise.
	(search_struct_method): Likewise.
	(find_method_list): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(value_full_object): Likewise.
	* jv-valprint.c (java_value_print): Use set_value_address.
	* value.h (deprecated_value_address_hack): Remove.
	(VALUE_ADDRESS): Remove.
	(value_address): Declare.
	(value_raw_address): Declare.
	(set_value_address): Declare.
@
text
@d274 1
a274 1
frame_unwind_id (struct frame_info *next_frame)
d463 1
a463 1
frame_pc_unwind (struct frame_info *this_frame)
d494 1
a494 1
			    "{ frame_pc_unwind (this_frame=%d) -> 0x%s }\n",
d1567 1
a1567 1
  return frame_pc_unwind (frame->next);
@


1.265
log
@	* infrun.c (normal_stop): Use has_stack_frames instead of
	target_has_stack.
	* mi/mi-main.c (mi_execute_command): Avoid calling inferior_thread
	when there is no thread selected.
	(mi_cmd_execute): Don't special case commands that can run without
	a valid selected thread.
	* top.c (execute_command): Don't special case commands that can
	run without a valid selected thread.  Use has_stack_frames.
	* infcmd.c (ensure_valid_thread): New.
	(continue_1, step_1, jump_command, signal_command): Use it.
	(detach_command): Error out if there's no selected thread/inferior.
	* thread.c (print_thread_info): Allow having no thread selected.
	(switch_to_thread): Don't read the PC if there is no current thread.
	(do_restore_current_thread_cleanup): Don't record the current
	frame if there is no current thread.
	(make_cleanup_restore_current_thread): Don't read frame info if
	there is no selected thread.
	(_initialize_thread): Don't mark commands as
	"no_selected_thread_ok".
	* frame.c (get_current_frame): Error out if there is no valid
	selected thread.
	(has_stack_frames): Return false if there is no valid
	selected thread.
	* cli/cli-cmds.c (init_cli_cmds): Don't mark commands as
	"no_selected_thread_ok".
	* cli/cli-decode.c (set_cmd_no_selected_thread_ok)
	(get_cmd_no_selected_thread_ok): Delete.
	* cli/cli-decode.h (CMD_NO_SELECTED_THREAD_OK): Delete.
	(set_cmd_no_selected_thread_ok, get_cmd_no_selected_thread_ok):
	Delete declaration.
	* stack.c (get_selected_block): Use has_stack_frames.
@
text
@d605 1
a605 1
  *addrp = VALUE_ADDRESS (value);
d691 1
a691 1
				paddr_nz (VALUE_ADDRESS (value)));
@


1.264
log
@        * frame.c (get_prev_frame_1): Do not perform the inner_frame
        sanity check if this_frame is not NORMAL.
        (frame_id_inner): Update the description of this function.
@
text
@d983 4
d1016 9
a1024 2
  /* If the current thread is executing, don't try to read from
     it.  */
@


1.263
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d379 2
a380 1
   IDs in certain circumstances.
d382 2
a383 3
   * If frame NEXT is the immediate inner frame to THIS, and NEXT
     is a NORMAL frame, then the stack address of NEXT must be
     inner-than-or-equal to the stack address of THIS.
d388 2
a389 4
   * If frame NEXT is the immediate inner frame to THIS, and NEXT
     is a NORMAL frame, and NEXT and THIS have different stack
     addresses, no other frame in the frame chain may have a stack
     address in between.
d393 9
a401 1
     to a valid frame in the frame chain.   */
d1283 4
a1286 3
     This check is valid only if the next frame is NORMAL.  See the
     comment at frame_id_inner for details.  */
  if (this_frame->next->unwind->type == NORMAL_FRAME
@


1.262
log
@	* frame.c (has_stack_frames): Make public.
	(get_prev_frame): Don't allow a NULL this_frame anymore.
	* frame.h (has_stack_frames): Declare.
	* varobj.c (find_frame_addr_in_frame_chain): Don't ever pass NULL
	to get_prev_frame, instead start at get_current_frame.
	(varobj_create): Check has_stack_frames before getting any frame;
	eliminate one usage of deprecated_safe_get_selected_frame.
@
text
@d1148 1
a1148 1
void
@


1.261
log
@	* frame.c (create_new_frame): Update the frame's cached PC before
	finding its unwinder.  Use frame_id_build to build the new frame's
	id.
	* stack.c (parse_frame_specification_1): Correct setting ``addrs''
	array values from the ``args'' array values.
@
text
@d1000 1
a1000 1
static int
a1460 36
  /* Return the inner-most frame, when the caller passes in NULL.  */
  /* NOTE: cagney/2002-11-09: Not sure how this would happen.  The
     caller should have previously obtained a valid frame using
     get_selected_frame() and then called this code - only possibility
     I can think of is code behaving badly.

     NOTE: cagney/2003-01-10: Talk about code behaving badly.  Check
     block_innermost_frame().  It does the sequence: frame = NULL;
     while (1) { frame = get_prev_frame (frame); .... }.  Ulgh!  Why
     it couldn't be written better, I don't know.

     NOTE: cagney/2003-01-11: I suspect what is happening in
     block_innermost_frame() is, when the target has no state
     (registers, memory, ...), it is still calling this function.  The
     assumption being that this function will return NULL indicating
     that a frame isn't possible, rather than checking that the target
     has state and then calling get_current_frame() and
     get_prev_frame().  This is a guess mind.  */
  if (this_frame == NULL)
    {
      /* NOTE: cagney/2002-11-09: There was a code segment here that
	 would error out when CURRENT_FRAME was NULL.  The comment
	 that went with it made the claim ...

	 ``This screws value_of_variable, which just wants a nice
	 clean NULL return from block_innermost_frame if there are no
	 frames.  I don't think I've ever seen this message happen
	 otherwise.  And returning NULL here is a perfectly legitimate
	 thing to do.''

         Per the above, this code shouldn't even be called with a NULL
         THIS_FRAME.  */
      frame_debug_got_null_frame (this_frame, "this_frame NULL");
      return current_frame;
    }

@


1.260
log
@	* infrun.c (normal_stop): Don't call
	deprecated_update_frame_pc_hack.
	* frame.c (deprecated_update_frame_pc_hack)
	(deprecated_update_frame_base_hack): Delete, and ...
	(create_new_frame): ... inline here.
	* frame.h (deprecated_update_frame_pc_hack)
	(deprecated_update_frame_base_hack): Delete declarations.
@
text
@d1109 7
d1121 1
a1121 6
  fi->this_id.value.stack_addr = addr;
  /* While we're at it, update this frame's cached PC value, found
     in the next frame.  Oh for the day when "struct frame_info"
     is opaque and this hack on hack can just go away.  */
  fi->next->prev_pc.value = pc;
  fi->next->prev_pc.p = 1;
@


1.259
log
@	* dummy-frame.c (dummy_frame): Replace regcache member with
	caller_state.
	(dummy_frame_push): Replace caller_regcache arg with caller_state.
	All callers updated.
	(remove_dummy_frame,pop_dummy_frame,lookup_dummy_frame): New fns.
	(dummy_frame_pop): Rewrite.  Verify requested frame is in the
	dummy frame stack.  Restore program state.
	(cleanup_dummy_frames): Rewrite.
	(dummy_frame_sniffer): Update.  Make static.
	* dummy-frame.h (regcache,frame_info): Delete forward decls.
	(inferior_thread_state): New forward decl.
	(dummy_frame_push): Update prototype.
	* frame.c (frame_pop): dummy_frame_pop now does all the work for
	DUMMY_FRAMEs.
	* infcall.c (breakpoint_auto_delete_contents): Delete.
	(get_function_name,run_inferior_call): New fns.
	(call_function_by_hand): Simplify by moving some code to
	get_function_name, run_inferior_call.  Inferior function call wrapped
	in TRY_CATCH so there's less need for cleanups and all exits from
	proceed are handled similarily.  Detect program exit.
	Detect program stopping in a different thread.
	Make error messages more consistent.
	* inferior.h (inferior_thread_state): Declare (opaque type).
	(save_inferior_thread_state,restore_inferior_thread_state,
	make_cleanup_restore_inferior_thread_state,
	discard_inferior_thread_state, get_inferior_thread_state_regcache):
	Declare.
	(save_inferior_status): Update prototype.
	* infrun.c: (normal_stop): When stopped for the completion of an
	inferior function call, verify the expected stack frame kind.
	(inferior_thread_state): New struct.
	(save_inferior_thread_state,restore_inferior_thread_state,
	do_restore_inferior_thread_state_cleanup,
	make_cleanup_restore_inferior_thread_state,
	discard_inferior_thread_state,
	get_inferior_thread_state_regcache): New functions.
	(inferior_status): Move stop_signal, stop_pc, registers to
	inferior_thread_state.  Remove restore_stack_info.
	(save_inferior_status): Remove arg restore_stack_info.
	All callers updated.  Remove saving of state now saved by
	save_inferior_thread_state.
	(restore_inferior_status): Remove restoration of state now done by
	restore_inferior_thread_state.
	(discard_inferior_status): Remove freeing of registers, now done by
	discard_inferior_thread_state.

	* gdb.base/break.exp: Update expected gdb output.
	* gdb.base/sepdebug.exp: Ditto.
	* gdb.mi/mi-syn-frame.exp: Ditto.
	* gdb.mi/mi2-syn-frame.exp: Ditto.

	* gdb.base/call-signal-resume.exp: New file.
	* gdb.base/call-signals.c: New file.
	* gdb.base/unwindonsignal.exp: New file.
	* gdb.base/unwindonsignal.c: New file.
	* gdb.threads/interrupted-hand-call.exp: New file.
	* gdb.threads/interrupted-hand-call.c: New file.
	* gdb.threads/thread-unwindonsignal.exp: New file.
@
text
@d1114 6
a1119 2
  deprecated_update_frame_base_hack (fi, addr);
  deprecated_update_frame_pc_hack (fi, pc);
a1736 32
void
deprecated_update_frame_pc_hack (struct frame_info *frame, CORE_ADDR pc)
{
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog,
			"{ deprecated_update_frame_pc_hack (frame=%d,pc=0x%s) }\n",
			frame->level, paddr_nz (pc));
  /* NOTE: cagney/2003-03-11: Some architectures (e.g., Arm) are
     maintaining a locally allocated frame object.  Since such frames
     are not in the frame chain, it isn't possible to assume that the
     frame has a next.  Sigh.  */
  if (frame->next != NULL)
    {
      /* While we're at it, update this frame's cached PC value, found
	 in the next frame.  Oh for the day when "struct frame_info"
	 is opaque and this hack on hack can just go away.  */
      frame->next->prev_pc.value = pc;
      frame->next->prev_pc.p = 1;
    }
}

void
deprecated_update_frame_base_hack (struct frame_info *frame, CORE_ADDR base)
{
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog,
			"{ deprecated_update_frame_base_hack (frame=%d,base=0x%s) }\n",
			frame->level, paddr_nz (base));
  /* See comment in "frame.h".  */
  frame->this_id.value.stack_addr = base;
}

@


1.258
log
@	* frame.c (get_frame_arch): Abort if called with NULL this_frame.
@
text
@d539 8
a559 5
  /* If we are popping a dummy frame, clean up the associated
     data as well.  */
  if (get_frame_type (this_frame) == DUMMY_FRAME)
    dummy_frame_pop (get_frame_id (this_frame));

@


1.257
log
@        Updated copyright notices for most files.
@
text
@d1798 5
@


1.256
log
@	* frame.c (frame_debug_got_null_frame): Remove file arg.
	All callers updated.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.
@


1.255
log
@* frame.c (get_frame_register_bytes): Avoid excessive function calls.
@
text
@d1395 1
a1395 2
frame_debug_got_null_frame (struct ui_file *file,
			    struct frame_info *this_frame,
d1484 1
a1484 1
      frame_debug_got_null_frame (gdb_stdlog, this_frame, "this_frame NULL");
d1512 1
a1512 1
      frame_debug_got_null_frame (gdb_stdlog, this_frame, "inside main func");
d1523 1
a1523 2
      frame_debug_got_null_frame (gdb_stdlog, this_frame,
				  "backtrace limit exceeded");
d1553 1
a1553 1
      frame_debug_got_null_frame (gdb_stdlog, this_frame, "inside entry func");
d1565 1
a1565 1
      frame_debug_got_null_frame (gdb_stdlog, this_frame, "zero PC");
@


1.255.4.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a69 2
  struct inferior *inferior;

a175 1
  fprintf_unfiltered (file, ",inf=%d", id.inferior_num);
a261 2
      if (fi->inferior)
	fi->this_id.value.inferior_num = fi->inferior->num;
a356 3
  else if (l.inferior_num != r.inferior_num)
    /* If the inferiors are different, the frames are different.  */
    eq = 0;
a902 3
  /* Frame inferiors will all inherit from the sentinel's inferior.
     In future we may want to set this from a parameter.  */
  frame->inferior = current_inferior ();
a1105 2
  fi->inferior = fi->next->inferior;

a1358 2
  prev_frame->inferior = this_frame->inferior;

d1651 1
a1651 1
  (*sal) = find_pc_inf_line (get_frame_pc (frame), get_frame_inferior (frame), pc_notcurrent (frame));
a1763 6
struct inferior *
get_frame_inferior (struct frame_info *frame)
{
  return frame->inferior;
}

@


1.255.4.2
log
@2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	* linux-fork.c (detach_fork): Delete declaration.
	(_initialize_linux_fork): Move "set detach-on-fork"
	command to ...
	* infrun.c (_initialize_infrun): ... here.
	* inferior.h (detach_fork): Declare.

	2008-11-10  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (read_ptid): If we don't know about any inferior yet,
	use the pid of magic_null_ptid.
	(remote_start_remote): Don't set inferior_ptid to magic_null_ptid
	here.

	2008-10-14  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (remote_start_remote): Mask async mode while collecting
	the initial event, use notice_new_inferior.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* infcmd.c (attach_command_post_wait): Set the inferior exec here.
	(attach_command): Don't set the inferior exec here.
	(notice_new_inferior): New.
	* inferior.h (notice_new_inferior): Declare.
	* remote.c (notice_new_inferiors): Add `stopping' argument.  Add
	the inferior before adding the threads.  Call notice_new_inferior.
	(record_currthread): Adjust.
	(remote_threads_info): Add the inferior before adding the thread.
	Call notice_new_inferior.

	2008-10-09  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (notice_new_inferiors): If there's only one exec, set
	it in the new inferior.
	(set_thread): If setting the thread failed, assume the thread has
	terminated.

	2008-09-17  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (delete_inferior_1): Free the inferior after freeing
	its threads.

	2008-09-16  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.h (discard_all_inferiors): Declare.
	* inferior.c (delete_inferior): Rename to...
	(delete_inferior_1): ...this.  Add 'silent' argument.  If this
	inferior is has pid not zero, delete its threads.
	(delete_inferior): New, as wrapper around delete_inferior_1.
	(delete_inferior_by_pid_1): Reimplement.
	(discard_all_inferiors): New.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (extended_remote_attach_1): Don't set target_attach_no_wait.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* frame.c (get_current_frame, has_stack_frames): Check for
	null_ptid.
	* top.c (execute_command): Likewise.

	2008-08-29  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (have_real_inferiors): New.
	* inferior.h (have_real_inferiors): Declare.
	* remote.c (extended_remote_mourn_1): Use it.
	* top.c (quit_target): Use it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (parse_stop_reply): Handle Y;exec.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* infcmd.c (struct exec_file_attach_wrapper_args): New.
	(exec_file_attach_wrapper): New.
	(attach_command_post_wait): If there's a sysroot, prepend it to
	the target reported exec file path.  Continue attaching to the
	inferior event if attaching to the exec file fails.

	* remote.c (remote_pid_to_exec_file): Rebustify.  Expect
	"QExecFile:PID;" in the reply.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (record_currthread): If setting the current thread to
	minus_one_ptid, don't pass that to the stub.
	(remote_parse_stop_reply): Handle 'Y' stop reply.
	(remote_wait_as): Likewise.  If remote process exited, invalidate
	the current thread.
	(remote_detach_pid): New.
	(remote_follow_fork): New.
	(init_remote_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (remote_pid_to_exec_file): New.
	(init_remote_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* infcmd.c (kill_if_already_running): If target supports
	multi-process, allow multi-runs.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (extended_remote_create_inferior_1): Don't clear the
	thread list.
@
text
@a984 2
  if (ptid_equal (inferior_ptid, null_ptid))
    error (_("No current inferior."));
a1013 3
  if (ptid_equal (inferior_ptid, null_ptid))
    return 0;

@


1.254
log
@* frame.c (get_frame_register_bytes): Take pseudo registers into
account.
@
text
@d801 1
d813 2
a814 2
  for (i = regnum;
       i < gdbarch_num_regs (gdbarch) + gdbarch_num_pseudo_regs (gdbarch); i++)
@


1.253
log
@2008-09-22  Andrew Stubbs  <ams@@codesourcery.com>

	* frame.c (get_frame_register_bytes): Comment improvments.
@
text
@d812 2
a813 1
  for (i = regnum; i < gdbarch_num_regs (gdbarch); i++)
@


1.252
log
@2008-09-19  Andrew Stubbs  <ams@@codesourcery.com>

	* frame.c (get_frame_register_bytes): Detect bad debug info.
@
text
@d809 2
a810 1
  /* Detect bad debug info.  */
d816 1
a816 1
	break;
@


1.251
log
@	* dummy-frame.h (dummy_frame_pop): Add prototype.
	* dummy-frame.c: Include "observer.h".
	(dummy_frame_push): Do not check for stale frames.
	(dummy_frame_pop): New function.
	(cleanup_dummy_frames): New function.
	(_initialize_dummy_frame): Install it as inferior_created observer.

	* frame.h (struct frame_id): Update comments.
	(frame_id_inner): Remove prototype.
	* frame.c (frame_id_inner): Make static.  Add comments.
	(frame_find_by_id): Update frame_id_inner safety net check to avoid
	false positives for targets using non-contiguous stack ranges.
	(get_prev_frame_1): Update frame_id_inner safety net check.
	(frame_pop): Call dummy_frame_pop when popping a dummy frame.

	* stack.c (return_command): Directly pop the selected frame.
	* infrun.c (handle_inferior_event): Remove dead code.
	* i386-tdep.c (i386_push_dummy_call): Update comment.
@
text
@d799 2
d809 16
@


1.250
log
@	* frame.h (frame_map_regnum_to_name): Remove prototype.
	(frame_map_name_to_regnum): Remove prototype.
	* frame.c (frame_map_regnum_to_name): Remove.
	(frame_map_name_to_regnum): Remove.
	(frame_unwind_register_value): Use user_reg_map_regnum_to_name
	instead of frame_map_regnum_to_name.
	* ax-gdb.c: Include "user-regs.h".
	(gen_expr): Use user_reg_map_name_to_regnum instead of
	frame_map_name_to_regnum.
	* eval.c:  Include "user-regs.h".
	(evaluate_subexp_standard): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* infcmd.c (registers_info): Likewise.
	* parse.c: Include "user-regs.h".
	(write_dollar_variable): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* tracepoint.c: Include "user-regs.h".
	(encode_actions): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* valops.c: Include "user-regs.h".
	(value_fetch_lazy): Use user_reg_map_regnum_to_name instead
	of frame_map_regnum_to_name.
@
text
@d371 27
a397 1
int
d424 1
a424 1
  struct frame_info *frame;
d431 1
a431 3
  for (frame = get_current_frame ();
       frame != NULL;
       frame = get_prev_frame (frame))
d437 14
a450 2
      if (frame_id_inner (get_frame_arch (frame), id, this))
	/* Gone to far.  */
a451 4
      /* Either we're not yet gone far enough out along the frame
         chain (inner(this,id)), or we're comparing frameless functions
         (same .base, different .func, no test available).  Struggle
         on until we've definitly gone to far.  */
d552 5
d1247 4
a1250 5
     Exclude signal trampolines (due to sigaltstack the frame ID can
     go backwards) and sentinel frames (the test is meaningless).  */
  if (this_frame->next->level >= 0
      && this_frame->next->unwind->type != SIGTRAMP_FRAME
      && frame_id_inner (get_frame_arch (this_frame), this_id,
@


1.249
log
@Revert frame_unwind_caller_pc / frame_unwind_caller_id.
@
text
@d622 2
a623 1
			  frame_map_regnum_to_name (frame, regnum));
a837 16
/* Map between a frame register number and its name.  A frame register
   space is a superset of the cooked register space --- it also
   includes builtin registers.  */

int
frame_map_name_to_regnum (struct frame_info *frame, const char *name, int len)
{
  return user_reg_map_name_to_regnum (get_frame_arch (frame), name, len);
}

const char *
frame_map_regnum_to_name (struct frame_info *frame, int regnum)
{
  return user_reg_map_regnum_to_name (get_frame_arch (frame), regnum);
}

@


1.248
log
@	* frame.c (frame_unwind_id): Renamed to ...
	(frame_unwind_caller_id): ... this.  All callers updated.
	(frame_pc_unwind): Renamed to ...
	(frame_unwind_caller_pc): ... this.  All callers updated.
	* frame.h: Document frame_unwind_caller_WHAT functions.
	(frame_unwind_id): Renamed to ...
	(frame_unwind_caller_id): ... this.
	(frame_pc_unwind): Renamed to ...
	(frame_unwind_caller_pc): ... this.
	* hppa-tdep.c (hppa_find_unwind_entry_in_block): Correct comment.
	* stack.c (parse_frame_specification_1): Do not rely on
	frame_unwind_id.
@
text
@d274 1
a274 1
frame_unwind_caller_id (struct frame_info *next_frame)
d425 1
a425 1
frame_unwind_caller_pc (struct frame_info *this_frame)
d456 1
a456 1
			    "{ frame_unwind_caller_pc (this_frame=%d) -> 0x%s }\n",
d1536 1
a1536 1
  return frame_unwind_caller_pc (frame->next);
@


1.247
log
@	* frame.c (frame_sp_unwind): Delete.
	(get_frame_sp): Do not use it.
	* frame.h (frame_sp_unwind): Delete prototype.
@
text
@d274 1
a274 1
frame_unwind_id (struct frame_info *next_frame)
d425 1
a425 1
frame_pc_unwind (struct frame_info *this_frame)
d456 1
a456 1
			    "{ frame_pc_unwind (this_frame=%d) -> 0x%s }\n",
d1536 1
a1536 1
  return frame_pc_unwind (frame->next);
@


1.246
log
@* dwarf2-frame.c (dwarf2_frame_cache): Update comment.

* frame.c (frame_unwind_address_in_block): Delete.
(get_frame_address_in_block): Do not use it.  Check the type
of the next frame first.
(frame_cleanup_after_sniffer): Update comment.
* frame.h (frame_unwind_address_in_block): Delete prototype.
* hppa-tdep.c (hppa_find_unwind_entry_in_block): Update comment.
@
text
@d1766 1
a1766 7
  return frame_sp_unwind (this_frame->next);
}

CORE_ADDR
frame_sp_unwind (struct frame_info *next_frame)
{
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d1770 3
a1772 1
    return gdbarch_unwind_sp (gdbarch, next_frame);
d1776 2
a1777 2
    return frame_unwind_register_unsigned (next_frame,
					   gdbarch_sp_regnum (gdbarch));
@


1.245
log
@* frame.c (frame_func_unwind): Delete.

(get_frame_func): Do not use it.
* frame.h (frame_func_unwind): Delete prototype.
* hppa-tdep.c (hppa_frame_cache): Update comment.
* rs6000-tdep.c (rs6000_frame_cache): Update comment.
@
text
@d1539 1
a1539 2
/* Return an address that falls within NEXT_FRAME's caller's code
   block, assuming that the caller is a THIS_TYPE frame.  */
d1542 1
a1542 2
frame_unwind_address_in_block (struct frame_info *next_frame,
			       enum frame_type this_type)
d1545 40
a1584 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
a1585 19
  /* If NEXT_FRAME was called by a signal frame or dummy frame, then
     we shold not adjust the unwound PC.  These frames may not call
     their next frame in the normal way; the operating system or GDB
     may have pushed their resume address manually onto the stack, so
     it may be the very first instruction.  Even if the resume address
     was not manually pushed, they expect to be returned to.  */
  if (this_type != NORMAL_FRAME)
    return pc;

  /* If THIS frame is not inner most (i.e., NEXT isn't the sentinel),
     and NEXT is `normal' (i.e., not a sigtramp, dummy, ....) THIS
     frame's PC ends up pointing at the instruction following the
     "call".  Adjust that PC value so that it falls on the call
     instruction (which, hopefully, falls within THIS frame's code
     block).  So far it's proved to be a very good approximation.  See
     get_frame_type() for why ->type can't be used.  */
  if (next_frame->level >= 0
      && get_frame_type (next_frame) == NORMAL_FRAME)
    --pc;
a1588 7
CORE_ADDR
get_frame_address_in_block (struct frame_info *this_frame)
{
  return frame_unwind_address_in_block (this_frame->next,
					get_frame_type (this_frame));
}

d1849 1
a1849 1
     function is not (see frame_unwind_address_in_block).  */
@


1.244
log
@	Add "executing" property to threads.

	* inferior.h (target_executing): Delete.
	* gdbthread.h (struct thread_info): Add executing_ field.
	(set_executing, is_executing): New.
	* thread.c (main_thread_executing): New.
	(init_thread_list): Clear it and also main_thread_running.
	(is_running): Return false if target has no execution.
	(any_running, is_executing, set_executing): New.

	* top.c: Include "gdbthread.h".
	(target_executing): Delete.
	(execute_command): Replace target_executing check by any_running.
	* event-top.c: Include "gdbthread.h".
	(display_gdb_prompt, command_handler): Replace target_executing by
	is_running.
	* inf-loop.c: Include "gdbthread.h".  Don't mark as not executing
	here.  Replace target_executing by is_running.
	* infrun.c (handle_inferior_event): Mark all threads as
	not-executing.
	* linux-nat.c (linux_nat_resume): Don't mark thread as executing
	here.
	* stack.c (get_selected_block): Return null if inferior is
	executing.
	* target.c (target_resume): Mark resumed ptid as executing.
	* breakpoint.c (until_break_command): Replace target_executing
	check by is_executing.
	* remote.c (remote_async_resume): Don't mark inferior as executing
	here.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Replace target_executing
	by any_running.

	* mi/mi-main.c (mi_cmd_exec_interrupt, mi_cmd_execute)
	(mi_execute_async_cli_command): Replace target_executing by
	is_running.

	* frame.c (get_current_frame): Error out if the current thread is
	executing.
	(has_stack_frames): New.
	(get_selected_frame, deprecated_safe_get_selected_frame): Check
	has_stack_frames.

	* Makefile.in (event-top.o, frame.o, inf-loop.o, top.o): Depend on
	$(gdbthread_h).
@
text
@d464 1
a464 1
frame_func_unwind (struct frame_info *fi, enum frame_type this_type)
d466 3
a468 1
  if (!fi->prev_func.p)
d472 3
a474 3
      CORE_ADDR addr_in_block = frame_unwind_address_in_block (fi, this_type);
      fi->prev_func.p = 1;
      fi->prev_func.addr = get_pc_function_start (addr_in_block);
d477 3
a479 2
			    "{ frame_func_unwind (fi=%d) -> 0x%s }\n",
			    fi->level, paddr_nz (fi->prev_func.addr));
d481 1
a481 7
  return fi->prev_func.addr;
}

CORE_ADDR
get_frame_func (struct frame_info *fi)
{
  return frame_func_unwind (fi->next, get_frame_type (fi));
@


1.243
log
@	* frame.c (get_prev_frame_1): Call frame_unwind_find_by_frame
	directly instead of get_frame_id.
@
text
@d43 1
d934 3
d957 14
d980 1
a980 3
      if (message != NULL && (!target_has_registers
			      || !target_has_stack
			      || !target_has_memory))
d999 1
a999 1
  if (!target_has_registers || !target_has_stack || !target_has_memory)
@


1.242
log
@	* frame.c (get_prev_frame_1): Build frame id before setting
	this_frame->prev_p, not after.
@
text
@d1183 7
a1189 3
  /* If the frame id hasn't been built yet, it must be done before
     setting a stop reason.  */
  this_id = get_frame_id (this_frame);
d1197 1
@


1.241
log
@        * frame.c (get_frame_base_address, get_frame_locals_address)
        (get_frame_args_address): Pass the correct frame when calling
        frame_base_find_by_frame.
@
text
@d1182 5
a1192 1
  this_id = get_frame_id (this_frame);
@


1.240
log
@2008-05-03  Luis Machado  <luisgpm@@br.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* cli/cli-decode.c (lookup_cmd_1): Fix indentation.
	* doublest.c (convert_typed_floating): Fix typo in comment.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame-unwind.h (frame_sniffer_ftype): Likewise.
	* frame.c (frame_unwind_address_in_block): Likewise.
	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): Likewise.
	* symtab.h (struct symbol): Likewise.
	* tramp-frame.h (struct trad_frame_cache): Likewise.
	* value.c (allocate_repeat_value): Likewise.
@
text
@d1595 1
a1595 1
    fi->base = frame_base_find_by_frame (fi->next);
d1611 1
a1611 1
    fi->base = frame_base_find_by_frame (fi->next);
d1627 1
a1627 1
    fi->base = frame_base_find_by_frame (fi->next);
@


1.239
log
@	Convert frame unwinders to use the current frame and
	"struct value".

	* frame.c (frame_debug): Make global.
	(get_frame_id): Pass this frame to unwinder routines.
	(frame_pc_unwind): Remove unused unwind->prev_pc support.
	(do_frame_register_read): Do not discard the return value of
	frame_register_read.
	(frame_register_unwind): Remove debug messages.  Use
	frame_unwind_register_value.
	(frame_unwind_register_value, get_frame_register_value): New
	functions.
	(create_new_frame, get_frame_base_address, get_frame_locals_address)
	(get_frame_args_address, get_frame_type): Pass this frame to
	unwinder routines.
	(frame_cleanup_after_sniffer, frame_prepare_for_sniffer): New
	functions.
	* frame.h: Update comments.
	(frame_debug, frame_unwind_register_value, get_frame_register_value)
	(frame_prepare_for_sniffer): Declare.
	* frame-unwind.h: Update comments and parameter names.
	(default_frame_sniffer): Declare.
	(frame_prev_register_ftype): Return a struct value *.
	(struct frame_unwind): Remove prev_pc member.
	(frame_unwind_sniffer_ftype, frame_unwind_append_sniffer): Delete.
	(frame_unwind_append_unwinder, frame_unwind_got_optimized)
	(frame_unwind_got_register, frame_unwind_got_memory)
	(frame_unwind_got_constant, frame_unwind_got_address): Declare.
	* frame-base.h: Update comments and parameter names.
	* valops.c (value_fetch_lazy): Use get_frame_register_value.  Iterate
	if necessary.  Add debugging output.
	* sentinel-frame.c (sentinel_frame_prev_register)
	(sentinel_frame_this_id): Update for new signature.
	(sentinel_frame_prev_pc): Delete.
	(sentinel_frame_unwinder): Remove prev_pc.
	* ia64-tdep.c (ia64_libunwind_frame_unwind): Do not initialize
	prev_pc.
	* libunwind-frame.c (libunwind_frame_unwind): Likewise.
	* frame-unwind.c (struct frame_unwind_table_entry): Remove sniffer.
	(frame_unwind_append_sniffer): Delete.
	(frame_unwind_append_unwinder): New function.
	(frame_unwind_find_by_frame): Take this frame.  Only use sniffers
	from unwinders.  Use frame_prepare_for_sniffer.
	(default_frame_sniffer, frame_unwind_got_optimized)
	(frame_unwind_got_register, frame_unwind_got_memory)
	(frame_unwind_got_constant, frame_unwind_got_address): New functions.
	* dummy-frame.c (dummy_frame_sniffer): Use gdbarch_dummy_id.
	(dummy_frame_prev_register, dummy_frame_this_id): Update for new
	signature.
	* gdbarch.sh: Replace unwind_dummy_id with dummy_id.
	* gdbarch.c, gdbarch.c: Regenerated.
	* frame-base.c (default_frame_base_address)
	(default_frame_locals_address, default_frame_args_address): Update
	for new signature.
	(frame_base_find_by_frame): Pass this frame to unwinder routines.
	* infcall.c (call_function_by_hand): Update comments.
	* Makefile.in (frame-unwind.o): Update dependencies.

	* gdbint.texinfo (Stack Frames): New chapter.
	(Algorithms): Move Frames text to the new chapter.
	(Target Conditionals): Delete SAVE_DUMMY_FRAME_TOS.  Document
	gdbarch_dummy_id instead of gdbarch_unwind_dummy_id.
@
text
@d1538 1
a1538 1
     frame's PC ends up pointing at the instruction fallowing the
@


1.238
log
@	* breakpoint.h (breakpoint_restore_shadows): New
	declaration.
	* breakpoint.c (breakpoint_restore_shadows): New.
	(read_memory_nobpt): Delete.
	* gdbcore.h (read_memory_nobpt): Delete declaration.
	* target.c (memory_xfer_partial): Call
	breakpoint_restore_shadows.
	(restore_show_memory_breakpoints)
	(make_show_memory_beakpoints_cleanup): New.
	(show_memory_breakpoints): New.
	* target.h (make_show_memory_beakpoints_cleanup): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint):
	Make sure we see memory breakpoints when checking if
	breakpoint is still there.
	* alpha-tdep.c, alphanbsd-tdep.c, frame.c, frv-tdep.c,
	hppa-linux-tdep.c, hppa-tdep.c, i386-linux-nat.c, i386-tdep.c,
	m68klinux-tdep.c, mips-tdep.c, mn10300-tdep.c, s390-tdep.c,
	sparc-tdep.c: Use target_read_memory instead of read_memory_nobpt.
@
text
@d116 1
a116 1
static int frame_debug;
d258 1
a258 2
	fi->unwind = frame_unwind_find_by_frame (fi->next,
						 &fi->prologue_cache);
d260 1
a260 1
      fi->unwind->this_id (fi->next, &fi->prologue_cache, &fi->this_id.value);
d429 1
a429 9
      if (this_frame->unwind == NULL)
	this_frame->unwind
	  = frame_unwind_find_by_frame (this_frame->next,
					&this_frame->prologue_cache);
      if (this_frame->unwind->prev_pc != NULL)
	/* A per-frame unwinder, prefer it.  */
	pc = this_frame->unwind->prev_pc (this_frame->next,
					  &this_frame->prologue_cache);
      else if (gdbarch_unwind_pc_p (get_frame_arch (this_frame)))
d489 1
a489 2
  frame_register_read (src, regnum, buf);
  return 1;
d545 1
a545 9
  struct frame_unwind_cache *cache;

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "\
{ frame_register_unwind (frame=%d,regnum=%d(%s),...) ",
			  frame->level, regnum,
			  frame_map_regnum_to_name (frame, regnum));
    }
d555 1
a555 10
  /* NOTE: cagney/2002-11-27: A program trying to unwind a NULL frame
     is broken.  There is always a frame.  If there, for some reason,
     isn't a frame, there is some pretty busted code as it should have
     detected the problem before calling here.  */
  gdb_assert (frame != NULL);

  /* Find the unwinder.  */
  if (frame->unwind == NULL)
    frame->unwind = frame_unwind_find_by_frame (frame->next,
						&frame->prologue_cache);
d557 1
a557 5
  /* Ask this frame to unwind its register.  See comment in
     "frame-unwind.h" for why NEXT frame and this unwind cache are
     passed in.  */
  frame->unwind->prev_register (frame->next, &frame->prologue_cache, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);
d559 13
a571 20
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "->");
      fprintf_unfiltered (gdb_stdlog, " *optimizedp=%d", (*optimizedp));
      fprintf_unfiltered (gdb_stdlog, " *lvalp=%d", (int) (*lvalp));
      fprintf_unfiltered (gdb_stdlog, " *addrp=0x%s", paddr_nz ((*addrp)));
      fprintf_unfiltered (gdb_stdlog, " *bufferp=");
      if (bufferp == NULL)
	fprintf_unfiltered (gdb_stdlog, "<NULL>");
      else
	{
	  int i;
	  const unsigned char *buf = bufferp;
	  fprintf_unfiltered (gdb_stdlog, "[");
	  for (i = 0; i < register_size (get_frame_arch (frame), regnum); i++)
	    fprintf_unfiltered (gdb_stdlog, "%02x", buf[i]);
	  fprintf_unfiltered (gdb_stdlog, "]");
	}
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }
d612 65
d1052 1
a1052 1
  fi->unwind = frame_unwind_find_by_frame (fi->next, &fi->prologue_cache);
d1599 2
a1600 2
    return fi->base->this_base (fi->next, &fi->prologue_cache);
  return fi->base->this_base (fi->next, &fi->base_cache);
d1615 2
a1616 4
    cache = &fi->prologue_cache;
  else
    cache = &fi->base_cache;
  return fi->base->this_locals (fi->next, cache);
d1631 2
a1632 4
    cache = &fi->prologue_cache;
  else
    cache = &fi->base_cache;
  return fi->base->this_args (fi->next, cache);
d1653 1
a1653 2
    frame->unwind = frame_unwind_find_by_frame (frame->next, 
						&frame->prologue_cache);
d1794 44
@


1.237
log
@	* frame.c (reinit_frame_cache): Only annotate if frames were
	previously valid.

	* gdb.base/annota1.exp, gdb.cp/annota2.exp: Update for fewer
	frames-invalid annotations.
@
text
@d1694 2
a1695 2
  /* NOTE: read_memory_nobpt returns zero on success!  */
  return !read_memory_nobpt (addr, buf, len);
@


1.236
log
@	Updated copyright notices for most files.
@
text
@d1082 3
a1086 1
  annotate_frames_invalid ();
@


1.236.2.1
log
@        * frame.c (reinit_frame_cache): Only annotate if frames were
        previously valid.
@
text
@a1081 3
  if (current_frame != NULL)
    annotate_frames_invalid ();

d1084 1
@


1.235
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* frame.c (frame_id_inner): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(frame_find_by_id, get_prev_frame_1): Use get_frame_arch to get at the
	current architecture by frame_info.
	* frame.h (frame_id_inner): Add gdbarch parameter.
	* stack.c (return_command): Use get_frame_arch to get at the current
	architecture by frame_info. Update call of frame_id_inner.
	* infrun.c (handle_inferior_event): Likewise.
	* dummy-frame.c (dummy_frame_push):  Use get_regcache_arch to get at the
	current architecture by regcache. Update call of frame_id_inner.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2007 Free Software Foundation, Inc.
@


1.234
log
@	* frame.c (frame_unwind_unsigned_register): Delete.
	(frame_sp_unwind): Use frame_unwind_register_unsigned instead.
	* frame.h (frame_unwind_unsigned_register): Delete prototype.

	* alpha-linux-tdep.c, alpha-mdebug-tdep.c, alpha-tdep.c,
	avr-tdep.c, cris-tdep.c, frv-tdep.c, m68hc11-tdep.c, mn10300-tdep.c,
	mt-tdep.c: Replace frame_unwind_unsigned_register with
	frame_unwind_register_unsigned.

	* gdbint.texinfo (Target Conditionals): Use
	frame_unwind_register_unsigned in examples instead of
	frame_unwind_unsigned_register.
@
text
@d372 1
a372 1
frame_id_inner (struct frame_id l, struct frame_id r)
d383 1
a383 1
    inner = gdbarch_inner_than (current_gdbarch, l.stack_addr, r.stack_addr);
d413 1
a413 1
      if (frame_id_inner (id, this))
d1178 2
a1179 1
      && frame_id_inner (this_id, get_frame_id (this_frame->next)))
@


1.233
log
@2007-10-09  Markus Deuling  <deuling@@de.ibm.com>

	* frame.c (frame_pc_unwind): Use get_frame_arch to get at the current
	architecture by frame.
	(frame_save_as_regcache, frame_register_unwind, get_prev_frame_1)
	(inside_main_func, frame_sp_unwind): Likewise.
@
text
@a680 11
frame_unwind_unsigned_register (struct frame_info *frame, int regnum,
				ULONGEST *val)
{
  gdb_byte buf[MAX_REGISTER_SIZE];
  frame_unwind_register (frame, regnum, buf);
  (*val) = extract_unsigned_integer (buf,
				     register_size (get_frame_arch (frame),
						    regnum));
}

void
d1722 2
a1723 6
    {
      ULONGEST sp;
      frame_unwind_unsigned_register (next_frame,
				      gdbarch_sp_regnum (gdbarch), &sp);
      return sp;
    }
@


1.232
log
@	* frame.c (get_prev_frame_1): Also check for PC in the same register.
@
text
@d438 1
a438 1
      else if (gdbarch_unwind_pc_p (current_gdbarch))
d456 1
a456 1
	  pc = gdbarch_unwind_pc (current_gdbarch, this_frame);
d505 1
a505 1
  struct regcache *regcache = regcache_xmalloc (current_gdbarch);
d604 1
a604 1
	  for (i = 0; i < register_size (current_gdbarch, regnum); i++)
d1138 1
d1141 1
d1232 1
a1232 1
      && gdbarch_pc_regnum (current_gdbarch) >= 0
d1241 1
a1241 1
				      gdbarch_pc_regnum (current_gdbarch),
d1244 1
a1244 1
				      gdbarch_pc_regnum (current_gdbarch),
d1342 1
a1342 1
  maddr = gdbarch_convert_from_func_ptr_addr (current_gdbarch,
d1725 1
d1728 2
a1729 2
  if (gdbarch_unwind_sp_p (current_gdbarch))
    return gdbarch_unwind_sp (current_gdbarch, next_frame);
d1732 1
a1732 1
  if (gdbarch_sp_regnum (current_gdbarch) >= 0)
d1736 1
a1736 1
				      gdbarch_sp_regnum (current_gdbarch), &sp);
@


1.231
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d1234 1
a1234 1
      int optimized, realnum;
d1243 1
a1243 1
				      &optimized, &nlval, &naddr, &realnum);
d1245 2
a1246 1
      if (lval == lval_memory && lval == nlval && addr == naddr)
@


1.230
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.229
log
@	* regcache.c (struct regcache): Add ptid_t member.
	(regcache_xmalloc): Initialize it.
	(regcache_cpy_no_passthrough): Do not refer to current_regcache.
	(regcache_dup): Likewise.
	(regcache_dup_no_passthrough): Likewise.
	(current_regcache): Make static.
	(registers_ptid): Remove variable.
	(get_thread_regcache): New function.
	(get_current_regcache): New function.
	(registers_changed): Implement by freeing current regcache.
	(regcache_raw_read): Do not refer to current_regcache.  Set
	inferior_ptid to regcache->ptid while calling target routines.
	(regcache_raw_write): Likewise.
	(regcache_raw_supply): Do not refer to current_regcache.
	(read_pc_pid): Use thread regcache.  Do not modify inferior_ptid.
	(write_pc_pid): Likewise.
	(build_regcache): Remove.
	(_initialize_regcache): Do not call DEPRECATED_REGISTER_GDBARCH_SWAP
	or deprecated_register_gdbarch_swap.  Do not initialize
	registers_ptid.
	* regcache.h (get_current_regcache): Add prototype.
	(get_thread_regcache): Likewise.
	(current_regcache): Remove declaration.

	* corelow.c (core_open): Replace current_regcache by
	get_current_regcache ().
	* frame.c (frame_pop): Likewise.
	(put_frame_register): Likewise.
	(get_current_frame, create_new_frame): Likewise.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Likewise.
	* stack.c (return_command): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infrun.c (resume): Likewise.
	(save_inferior_status, restore_inferior_status): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	(fork_save_infrun_state): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* i386fbsd-nat.c (i386fbsd_resume): Likewise.
	* monitor.c (monitor_wait): Likewise.
	* remote.c (remote_wait): Likewise.
	* remote-mips.c (mips_wait): Likewise.

	* bsd-kvm.c (bsd_kvm_open): Likewise
	(bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Likewise.
	* fbsd-nat.c (fbsd_make_corefile_notes): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint): Likewise.
	(ia64_linux_stopped_data_address): Likewise.

	* frv-tdep.c (frv_fdpic_loadmap_addresses): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mep-tdep.c (current_me_module, current_options): Likewise.
	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Likewise.

	* linux-nat.c (linux_nat_do_thread_registers): Use thread
	regcache instead of current_regcache.  Call target_fetch_registers.
	(linux_nat_corefile_thread_callback): Update call site.
	(linux_nat_do_registers): Likewise.
	* procfs.c (procfs_do_thread_registers): Use thread regcache instead
	of current_regcache.
	(procfs_make_note_section): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
@
text
@d1232 1
a1232 1
      && PC_REGNUM >= 0
d1240 5
a1244 3
      frame_register_unwind_location (this_frame, PC_REGNUM, &optimized,
				      &lval, &addr, &realnum);
      frame_register_unwind_location (get_next_frame (this_frame), PC_REGNUM,
d1729 2
a1730 2
     the SP_REGNUM register is meaningful.  */
  if (SP_REGNUM >= 0)
d1733 2
a1734 1
      frame_unwind_unsigned_register (next_frame, SP_REGNUM, &sp);
@


1.228
log
@	* frame-unwind.h (frame_dealloc_cache_ftype): Define.
	(struct frame_unwind): Add dealloc_cache.
	* frame.c (reinit_frame_cache): Call dealloc_cache on all caches.

	* libunwind-frame.h (libunwind_frame_dealloc_cache): Declare.
	* libunwind-frame.c (libunwind_frame_dealloc_cache): Define.
	(libunwind_frame_unwind): Set dealloc_cache.
	* ia64-tdep.c (ia64_libunwind_frame_unwind): Set dealloc_cache.
@
text
@d529 1
a529 1
     trying to extract the old values from the current_regcache while
d544 1
a544 1
  regcache_cpy (current_regcache, scratch);
d717 1
a717 1
      regcache_cooked_write (current_regcache, realnum, buf);
d922 1
a922 1
	create_sentinel_frame (current_regcache);
d1034 1
a1034 1
  fi->next = create_sentinel_frame (current_regcache);
@


1.227
log
@2007-06-06  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (INNER_THAN): Replace by gdbarch_inner_than.
	* infcall.c (call_function_by_hand): Likewise.
	* gcore.c (derive_stack_segment): Likewise.
	* frame.c (frame_id_inner): Likewise.
	* arch-utils.c (core_addr_lessthan): Likewise (comment).
	* ada-lang.c (ensure_lval): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1080 11
@


1.226
log
@	* gdbarch.sh (read_sp): Remove.
	* gdbarch.c, gdbarch.h: Regenerate.
	* frame.c (frame_sp_unwind): Do not call TARGET_READ_SP.

	* avr-tdep.c (avr_read_sp): Remove.
	(avr_unwind_sp): New function.
	(avr_gdbarch_init): Install unwind_sp instead of read_sp callback.
	* mips-tdep.c (mips_read_sp): Remove.
	(mips_unwind_sp): New function.
	(mips_gdbarch_init): Install unwind_sp instead of read_sp callback.
	* score-tdep.c (score_read_unsigned_register): Remove.
	(score_read_sp): Remove.
	(score_unwind_sp): New function.
	(score_gdbarch_init): Install unwind_sp instead of read_sp callback.
@
text
@d385 1
a385 1
    inner = INNER_THAN (l.stack_addr, r.stack_addr);
@


1.225
log
@	* regcache.c (regcache_invalidate): New function.
	(register_cached): Remove.
	(set_register_cached): Remove.
	(deprecated_registers_fetched): Remove.
	(registers_changed): Use regcache_invalidate instead
	of set_register_cached.
	(regcache_raw_read): Update comment.

	* regcache.h (regcache_invalidate): Add prototype.
	(register_cached): Remove.
	(set_register_cached): Remove.
	(deprecated_registers_fetched): Remove.

	* findvar.c (value_of_register): Do not call register_cached.
	* frame.c (frame_register): Likewise.
	* tui/tui-regs.c (tui_get_register): Likewise.

	* remote.c (fetch_register_using_p): Do not call set_register_cached.
	(process_g_packet): Likewise.
	(remote_fetch_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* mt-tdep.c (mt_select_coprocessor): Replace set_register_cached call
	by regcache_invalidate.
	(mt_pseudo_register_write): Likewise.
	* sh-tdep.c (sh_pseudo_register_write): Likewise.

	* corelow.c (get_core_registers): Replace deprecated_registers_fetched
	call by loop over regcache_raw_supply (..., NULL).
@
text
@a1714 4
  /* Things are looking grim.  If it's the inner-most frame and there
     is a TARGET_READ_SP, then that can be used.  */
  if (next_frame->level < 0 && TARGET_READ_SP_P ())
    return TARGET_READ_SP ();
@


1.224
log
@	* frame.c (frame_pop): Check to see whether there's a frame to
	which we can pop first.
@
text
@a740 10
  /* FIXME: cagney/2002-05-15: This test is just bogus.

     It indicates that the target failed to supply a value for a
     register because it was "not available" at this time.  Problem
     is, the target still has the register and so get saved_register()
     may be returning a value saved on the stack.  */

  if (register_cached (regnum) < 0)
    return 0;			/* register value not available */

@


1.223
log
@	* frame.c (frame_pop, frame_observer_target_changed): Call
	reinit_frame_cache.
	(flush_cached_frames): Rename to reinit_frame_cache and delete
	old implementation.
	* frame.h (flush_cached_frames): Delete prototype and update comment.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Call
	reinit_frame_cache instead of flush_cached_frames.  Do not call
	select_frame after reinit_frame_cache.
	* corelow.c (core_open): Likewise.
	* gdbarch.sh (deprecated_current_gdbarch_select_hack): Likewise.
	* infrun.c (prepare_to_proceed, context_switch)
	(handle_inferior_event): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* ocd.c (ocd_start_remote): Likewise.
	* remote-e7000.c (e7000_start_remote): Likewise.
	* remote-mips.c (device): Likewise.
	* thread.c (switch_to_thread): Likewise.
	* tracepoint.c (finish_tfind_command): Likewise.
	* gdbarch.c: Regenerated.
@
text
@d517 10
d531 2
a532 3
  struct regcache *scratch
    = frame_save_as_regcache (get_prev_frame_1 (this_frame));
  struct cleanup *cleanups = make_cleanup_regcache_xfree (scratch);
@


1.222
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d540 1
a540 1
  flush_cached_frames ();
d1073 1
a1073 1
  flush_cached_frames ();
d1079 1
a1079 1
flush_cached_frames (void)
d1089 1
a1089 15
    fprintf_unfiltered (gdb_stdlog, "{ flush_cached_frames () }\n");
}

/* Flush the frame cache, and start a new one if necessary.  */

void
reinit_frame_cache (void)
{
  flush_cached_frames ();

  /* FIXME: The inferior_ptid test is wrong if there is a corefile.  */
  if (PIDGET (inferior_ptid) != 0)
    {
      select_frame (get_current_frame ());
    }
@


1.221
log
@	* frame.c (deprecated_selected_frame): Rename to...
	(selected_frame): ...this.  Make static.
	(get_selected_frame, select_frame): Update.
	* frame.h (deprected_select_frame): Delete.
	(deprecated_safe_get_selected_frame): Update comments.

	* breakpoint.c, cli/cli-cmds.c, f-valprint.c, infcmd.c, inflow.c,
	infrun.c, stack.c, tui/tui-disasm.c, tui/tui-source.c,
	tui/tui-winsource.c, valops.c, varobj.c, findvar.c, macroscope.c,
	parse.c, regcache.h, sh64-tdep.c, tui/tui-hooks.c, tui/tui-win.c,
	tui/tui.c: Replace references to deprecated_selected_frame.
@
text
@d474 1
a474 1
frame_func_unwind (struct frame_info *fi)
d480 1
a480 1
      CORE_ADDR addr_in_block = frame_unwind_address_in_block (fi);
d494 1
a494 1
  return frame_func_unwind (fi->next);
d1499 2
a1500 1
/* Return an address of that falls within the frame's code block.  */
d1503 2
a1504 1
frame_unwind_address_in_block (struct frame_info *next_frame)
d1509 9
d1523 1
a1523 1
     block.  So far it's proved to be a very good approximation.  See
d1534 2
a1535 1
  return frame_unwind_address_in_block (this_frame->next);
@


1.220
log
@* frame.c (get_frame_register_bytes, put_frame_register_bytes):
Don't forget to move destination pointer.
@
text
@d938 1
a938 1
struct frame_info *deprecated_selected_frame;
d947 1
a947 1
  if (deprecated_selected_frame == NULL)
d959 2
a960 2
  gdb_assert (deprecated_selected_frame != NULL);
  return deprecated_selected_frame;
d982 1
a982 1
  deprecated_selected_frame = fi;
@


1.219
log
@	* frame.c (get_prev_frame_1): Check PC_REGNUM before using it.
@
text
@d778 1
d819 1
@


1.218
log
@	* alpha-mdebug-tdep.c (alpha_mdebug_frame_prev_register): Use
	frame_unwind_register to recurse.
	* alpha-tdep.c (alpha_sigtramp_frame_prev_register): Likewise.
	(alpha_heuristic_frame_prev_register): Likewise.
	* h8300-tdep.c (h8300_frame_prev_register): Likewise.
	* m32c-tdep.c (m32c_prev_register): Likewise.
	* frame.c (frame_register_unwind_location): Remove FIXME.
@
text
@d1224 9
a1232 3
     no PC save.  This check does assume that the "PC register" is
     roughly a traditional PC, even if the gdbarch_unwind_pc method
     frobs it.  */
d1234 1
@


1.217
log
@Copyright updates for 2007.
@
text
@d1106 1
a1106 4
   relative to this particular frame.

   FIXME: alpha, m32c, and h8300 actually do the transitive operation
   themselves.  */
@


1.216
log
@	* frame.c (get_frame_register_bytes): New function.
	(put_frame_register_bytes): Likewise.
	* frame.h (get_frame_register_bytes): Declare.
	(put_frame_register_bytes): Likewise.
	* findvar.c (value_from_register): Always construct lval_register
	values.  Use get_frame_register_bytes.
	* valops.c (value_assign): Use get_frame_register_bytes and
	put_frame_register_bytes.
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000,
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
@


1.215
log
@	* frame.c (frame_register_unwind_location): New function.
	(get_prev_frame_1): Check for UNWIND_NO_SAVED_PC.
	(frame_stop_reason_string): Handle UNWIND_NO_SAVED_PC.
	* frame.h (enum unwind_stop_reason): Add UNWIND_NO_SAVED_PC.
@
text
@d745 78
@


1.214
log
@	* frame.c (struct frame_info): Add stop_reason.
	(get_prev_frame_1): Set stop_reason.  Don't call error for
	stop reasons.
	(get_frame_unwind_stop_reason, frame_stop_reason_string): New.
	* frame.h (enum unwind_stop_reason): New.
	(get_frame_unwind_stop_reason, frame_stop_reason_string): New
	prototypes.
	* stack.c (frame_info): Print the stop reason.
	(backtrace_command_1): Print the stop reason for errors.
@
text
@d1026 30
d1144 36
d1680 3
@


1.213
log
@        * gdbcore.h (read_memory_nobpt): New function name instead of
        deprecated_read_memory_nobpt.
        * breakpoint.c (read_memory_nobpt): New function name instead
        of deprecated_read_memory_nobpt.
        Adjust calls to old deprecated_read_memory_nobpt accordingly.
        * alpha-tdep.c: Adjust calls to deprecated_read_memory_nobpt
        accordingly.
        * alphanbsd-tdep.c: Likewise.
        * frame.c: Likewise.
        * frv-tdep.c: Likewise.
        * hppa-linux-tdep.c: Likewise.
        * hppa-tdep.c: Likewise.
        * i386-linux-nat.c: Likewise.
        * m68klinux-tdep.c: Likewise.
        * mips-tdep.c: Likewise.
        * s390-tdep.c: Likewise.
@
text
@d110 4
d1062 1
d1076 1
d1087 10
a1096 1
    error (_("Previous frame inner to this frame (corrupt stack?)"));
d1103 10
a1112 1
    error (_("Previous frame identical to this frame (corrupt stack?)"));
d1583 39
@


1.212
log
@Reviewed by Daniel Jacobowitz <drow@@false.org>

	2006-07-31  Fred Fish  <fnf@@specifix.com>
	* arm-tdep.c (arm_make_prologue_cache): Use FRAME_OBSTACK_ZALLOC
	instead of calling frame_obstack_zalloc directly.
	(arm_make_stub_cache): Ditto.
	* frame-unwind.h: Ditto.
	* frame.c (create_new_frame): Ditto.
@
text
@d1517 2
a1518 2
  /* NOTE: deprecated_read_memory_nobpt returns zero on success!  */
  return !deprecated_read_memory_nobpt (addr, buf, len);
@


1.211
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d949 1
a949 1
  fi = frame_obstack_zalloc (sizeof (struct frame_info));
@


1.211.12.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d949 1
a949 1
  fi = FRAME_OBSTACK_ZALLOC (struct frame_info);
d1517 2
a1518 2
  /* NOTE: read_memory_nobpt returns zero on success!  */
  return !read_memory_nobpt (addr, buf, len);
@


1.211.2.1
log
@Merge XML and VFP support to this branch.
@
text
@a397 1
#if 0
a401 1
#endif
a407 8
#if 1
      /* We use an invalid frame id to mean "could not unwind from
	 here"!  This hack fixes the "value being assigned to is
	 no longer active" problem.  This strongly suggests that
	 we need to change the representation.  */
      if (!frame_id_p (id) && !frame_id_p (this))
	return frame;
#endif
@


1.211.2.1.2.1
log
@	* gdb/frame.c (get_prev_frame): Move check for pc == 0 ...
	(get_prev_frame_1): ... to here.
@
text
@a1135 20
  /* Now that the frame chain is in a consistant state, check whether
     this frame is useful.  If it is not, unlink it.  Its storage will
     be reclaimed the next time the frame cache is flushed, and we
     will not try to unwind THIS_FRAME again.  */

  /* Assume that the only way to get a zero PC is through something
     like a SIGSEGV or a dummy frame, and hence that NORMAL frames
     will never unwind a zero PC.  This will look up the unwinder
     for the newly created frame, to determine its type.  */
  if (prev_frame->level > 0
      && get_frame_type (prev_frame) == NORMAL_FRAME
      && get_frame_type (this_frame) == NORMAL_FRAME
      && get_frame_pc (prev_frame) == 0)
    {
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog, "-> // zero PC}\n");
      this_frame->prev = NULL;
      return NULL;
    }

d1313 12
@


1.211.4.1
log
@Add support for VFP DWARF information and VFP single-precision
pseudo-registers.
@
text
@a397 1
#if 0
a401 1
#endif
a407 8
#if 1
      /* We use an invalid frame id to mean "could not unwind from
	 here"!  This hack fixes the "value being assigned to is
	 no longer active" problem.  This strongly suggests that
	 we need to change the representation.  */
      if (!frame_id_p (id) && !frame_id_p (this))
	return frame;
#endif
@


1.210
log
@	PR backtrace/1760
	* frame.c (backtrace_limit): Change type to int.
	(get_prev_frame): Update backtrace limit support.
	(_initialize_frame): Use add_setshow_integer_cmd for backtrace_limit.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.209
log
@2005-05-22  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (frame_register_unwind, frame_unwind_register)
	(get_frame_register, frame_register, put_frame_register)
	(get_frame_memory, safe_frame_unwind_memory)
	(frame_register_read): Use gdb_byte for byte buffer parameters.
	* trad-frame.h (trad_frame_get_register)
	(frame_get_prev_register): Ditto.
	* frame-unwind.h (frame_prev_register_ftype): Ditto.
	* frame.c (frame_pop, frame_register, frame_unwind_register)
	(get_frame_register, frame_unwind_register_signed)
	(frame_unwind_register_unsigned, frame_unwind_unsigned_register)
	(frame_register_read, get_frame_memory): Update.
	* trad-frame.c (trad_frame_get_prev_register): Update.
	(trad_frame_get_register): Update.
	* gdbcore.h (deprecated_read_memory_nobpt, read_memory): Ditto.
	* breakpoint.c (deprecated_read_memory_nobpt): Update.
	* corefile.c (read_memory): Update.
	* tramp-frame.c (tramp_frame_prev_register): Update.
	* valops.c (value_assign): Update.
	* sentinel-frame.c (sentinel_frame_prev_register): Update.
	* std-regs.c (value_of_builtin_frame_fp_reg)
	(value_of_builtin_frame_pc_reg): Update.
	* infcmd.c (default_print_registers_info): Update
	* dummy-frame.c (dummy_frame_prev_register): Update.
	* findvar.c (value_of_register, value_from_register): Update.
	* tui/tui-regs.c (tui_register_format, tui_get_register): Update.
	* mi/mi-main.c (register_changed_p, get_register): Update.
@
text
@d144 1
a144 1
static unsigned int backtrace_limit = UINT_MAX;
d1261 6
a1266 1
  if (this_frame->level > backtrace_limit)
d1268 3
a1270 1
      error (_("Backtrace limit of %d exceeded"), backtrace_limit);
d1620 2
a1621 2
  add_setshow_uinteger_cmd ("limit", class_obscure,
			    &backtrace_limit, _("\
d1626 4
a1629 4
			    NULL,
			    show_backtrace_limit,
			    &set_backtrace_cmdlist,
			    &show_backtrace_cmdlist);
@


1.208
log
@2005-05-19  Andrew Cagney  <cagney@@gnu.org>

	* regcache.h (regcache_raw_read, regcache_raw_write)
	(regcache_raw_read_part, regcache_raw_write_part)
	(regcache_cooked_read_part, regcache_cooked_write_part)
	(regcache_cooked_read, regcache_cooked_write)
	(regcache_raw_supply, regcache_raw_collect)
	(regcache_cooked_read_ftype, regcache_save, regcache_restore)
	(deprecated_read_register_gen, deprecated_write_register_gen)
	(deprecated_read_register_bytes, deprecated_write_register_bytes)
	(deprecated_grub_regcache_for_registers): Use gdb_byte for byte
	buffer parameters.
	* ia64-tdep.c (ia64_extract_return_value): Update.
	* frame.c (do_frame_register_read): Update.
	* regcache.c (deprecated_grub_regcache_for_registers)
	(struct regcache, regcache_save, regcache_restore, regcache_cpy)
	(do_cooked_read, regcache_xmalloc, register_buffer)
	(deprecated_read_register_bytes, regcache_raw_read)
	(regcache_raw_read_signed, regcache_raw_read_unsigned)
	(deprecated_read_register_gen, regcache_cooked_read)
	(regcache_cooked_read_signed, regcache_cooked_read_unsigned)
	(deprecated_write_register_gen, regcache_cooked_write)
	(deprecated_write_register_bytes, regcache_raw_read_part)
	(regcache_raw_write_part, regcache_cooked_read_part)
	(regcache_cooked_write_part, read_register, regcache_raw_supply):
@
text
@d542 1
a542 1
		       CORE_ADDR *addrp, int *realnump, void *bufferp)
d604 1
a604 1
		CORE_ADDR *addrp, int *realnump, void *bufferp)
d622 1
a622 1
frame_unwind_register (struct frame_info *frame, int regnum, void *buf)
d634 1
a634 1
		    int regnum, void *buf)
d642 1
a642 1
  char buf[MAX_REGISTER_SIZE];
d657 1
a657 1
  char buf[MAX_REGISTER_SIZE];
d673 1
a673 1
  char buf[MAX_REGISTER_SIZE];
d681 2
a682 1
put_frame_register (struct frame_info *frame, int regnum, const void *buf)
d698 1
a698 1
	char tmp[MAX_REGISTER_SIZE];
d719 2
a720 1
frame_register_read (struct frame_info *frame, int regnum, void *myaddr)
d1486 2
a1487 2
get_frame_memory (struct frame_info *this_frame, CORE_ADDR addr, void *buf,
		  int len)
d1508 1
a1508 1
			  CORE_ADDR addr, void *buf, int len)
@


1.207
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d494 1
a494 1
do_frame_register_read (void *src, int regnum, void *buf)
@


1.206
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_zinteger_cmd through out.  Re-sync gdbarch.sh
	and gdbarch.c.
	* breakpoint.c, frame.c, gdb-events.sh, gdbarch.sh: Update.
	* gdbtypes.c, infrun.c, linux-nat.c, maint.c, monitor.c: Update.
	* pa64solib.c, parse.c, remote-mips.c, ser-go32.c: Update.
	* serial.c, solib-frv.c, somsolib.c, target.c, top.c: Update.
	* varobj.c, cli/cli-cmds.c: Update.
	* gdbarch.c, gdb-events.c: Regenerate.
@
text
@d115 6
d125 9
d135 9
d145 9
d1593 1
a1593 1
			   NULL, /* FIXME: i18n: Whether backtraces should continue past \"main\" is %s.  */
d1607 1
a1607 1
			   NULL, /* FIXME: i18n: Whether backtraces should continue past the entry point is %s.  */
d1618 1
a1618 1
			    NULL, /* FIXME: i18n: An upper bound on the number of backtrace levels is %s.  */
d1628 1
a1628 1
			    NULL, /* FIXME: i18n: */
@


1.205
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d1590 7
a1596 5
  deprecated_add_show_from_set
    (add_set_cmd ("frame", class_maintenance, var_zinteger,
		  &frame_debug, "Set frame debugging.\n\
When non-zero, frame specific internal debugging is enabled.", &setdebuglist),
     &showdebuglist);
@


1.204
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d1559 1
d1561 1
a1561 1
			   NULL, NULL, &set_backtrace_cmdlist,
d1573 1
d1575 1
a1575 1
			   NULL, NULL, &set_backtrace_cmdlist,
d1584 1
d1586 1
a1586 1
			    NULL, NULL, &set_backtrace_cmdlist,
@


1.203
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_setshow functions, replace "PRINT:" comment prefix
	with "FIXME: i18n:".
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* cris-tdep.c, dwarf2read.c, frame.c, hppa-tdep.c: Update.
	* infcall.c, m32r-rom.c, maint.c, mips-tdep.c: Update.
	* nto-tdep.c, observer.c, remote-rdi.c, remote.c: Update.
	* target.c, cli/cli-logging.c: Update.
@
text
@d1541 1
a1541 1
  add_prefix_cmd ("backtrace", class_maintenance, set_backtrace_cmd, "\
d1543 1
a1543 1
Configure backtrace variables such as the backtrace limit",
d1546 1
a1546 1
  add_prefix_cmd ("backtrace", class_maintenance, show_backtrace_cmd, "\
d1548 1
a1548 1
Show backtrace variables such as the backtrace limit",
@


1.202
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d1553 3
a1555 3
			   &backtrace_past_main, "\
Set whether backtraces should continue past \"main\".", "\
Show whether backtraces should continue past \"main\".", "\
d1558 2
a1559 2
of the stack trace.",
			   NULL, /* PRINT: Whether backtraces should continue past \"main\" is %s.  */
d1564 5
a1568 3
			   &backtrace_past_entry, "\
Set whether backtraces should continue past the entry point of a program.", "\
Show whether backtraces should continue past the entry point of a program.", "\
d1571 2
a1572 2
the rest of the stack trace.",
			   NULL, /* PRINT: Whether backtraces should continue past the entry point is %s.  */
d1577 3
a1579 3
			    &backtrace_limit, "\
Set an upper bound on the number of backtrace levels.", "\
Show the upper bound on the number of backtrace levels.", "\
d1581 2
a1582 2
Zero is unlimited.",
			    NULL, /* PRINT: An upper bound on the number of backtrace levels is %s.  */
@


1.201
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d424 1
a424 1
	internal_error (__FILE__, __LINE__, "No unwind_pc method");
d1514 1
a1514 1
  internal_error (__FILE__, __LINE__, "Missing unwind SP method");
@


1.200
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd, add_setshow_cmd_full)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Replace
	print string parameter with fprint_setshow function.
	* command.h (fprint_setshow_ftype): Define.  Update declarations.
	* cli/cli-setshow.c (do_setshow_command): When fprint_setshow is
	available, use that.
	* cli/cli-decode.h (struct cmd_list_element): Add field
	fprint_setshow.
	* complaints.c (fprint_setshow_complaints): New function.
	(_initialize_complaints): Pass to add_setshow_zinteger_cmd.
	* hppa-tdep.c (_initialize_hppa_tdep): Replace "print" parameter
	with NULL.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* cris-tdep.c (_initialize_cris_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* target.c (initialize_targets): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* breakpoint.c (_initialize_breakpoint): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
@
text
@d657 1
a657 1
    error ("Attempt to assign to a value that was optimized out.");
d673 1
a673 1
      error ("Attempt to assign to an unmodifiable value.");
d796 1
a796 1
    error ("No registers.");
d798 1
a798 1
    error ("No stack.");
d800 1
a800 1
    error ("No memory.");
d833 1
a833 1
	error ("%s", message);
d1046 1
a1046 1
    error ("Previous frame inner to this frame (corrupt stack?)");
d1053 1
a1053 1
    error ("Previous frame identical to this frame (corrupt stack?)");
d1228 1
a1228 1
      error ("Backtrace limit of %d exceeded", backtrace_limit);
@


1.199
log
@2005-01-14  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (catch_exceptions): Delete errstring parameter.
	(catch_exceptions_with_msg): Ditto.
	* exceptions.c (catch_exceptions_with_msg): Update.
	(catch_exceptions): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* frame.c (get_current_frame): Update.
	* wrapper.c (gdb_value_struct_elt): Update.
	* exceptions.c (catch_exceptions): Update.
	* thread.c (gdb_list_thread_ids, gdb_thread_select): Update.
	* breakpoint.c (gdb_breakpoint_query, gdb_breakpoint): Update.
	* remote-fileio.c (remote_fileio_request): Update.
@
text
@d1558 2
a1559 2
of the stack trace.", "\
Whether backtraces should continue past \"main\" is %s.",
d1569 2
a1570 2
the rest of the stack trace.", "\
Whether backtraces should continue past the entry point is %s.",
d1579 2
a1580 2
Zero is unlimited.", "\
An upper bound on the number of backtrace levels is %s.",
@


1.198
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d806 1
a806 1
			    NULL, RETURN_MASK_ERROR) != 0)
@


1.197
log
@2004-12-12  Andrew Cagney  <cagney@@gnu.org>

	* frame.c (get_prev_frame): When unwinding normal frames, check
	that the PC isn't zero.
	* hppa-tdep.c (hppa_stub_frame_unwind_cache): Delete check for a
	zero PC.
@
text
@d44 1
@


1.196
log
@2004-12-07  Randolph Chung  <tausq@@debian.org>

	* frame.c (get_prev_frame): Don't terminate unwinding at main if we
	are unwinding through a dummy frame.
@
text
@d1260 12
@


1.195
log
@2004-11-10  Randolph Chung  <tausq@@debian.org>

	* frame.c (get_prev_frame): Use get_frame_type to retrieve the
    frame's type.
@
text
@d1202 10
d1213 1
@


1.194
log
@2004-11-10  Randolph Chung  <tausq@@debian.org>

	* blockframe.c (inside_entry_func): Move to .....
	* frame.c (inside_entry_func): ... here, and make static.
	(backtrace_past_entry): New flag.
	(get_prev_frame): Stop backtrace at the entry function if enabled
	by flag.  Update comments.
	(_initialize_frame): Add command to set backtrace_past_entry flag.
	* defs.h (inside_entry_func): Remove prototype.

    doc/
	* gdb.texinfo: Document set/show backtrace past-entry commands.
	Rearrange index entries for set/show backtrace past-main.
@
text
@d1242 1
a1242 1
      && this_frame->unwind->type != DUMMY_FRAME && this_frame->level >= 0
@


1.193
log
@2004-11-08  Andrew Cagney  <cagney@@gnu.org>

	* sentinel-frame.c (sentinel_frame_prev_pc): New function.
	(sentinel_frame_unwinder): Add the prev_pc method.
	* frame.c (frame_pc_unwind): Use the per-frame pc unwinder when
	available.  Do not handle the sentinel-frame case.
	* frame-unwind.h (frame_prev_register_ftype): Define.
	(struct frame_unwind): Add prev_pc;
@
text
@d118 1
d1139 8
a1223 2
  /* NOTE: cagney/2003-02-25: Don't enable until someone has found
     hard evidence that this is needed.  */
d1236 6
a1241 7
  /* NOTE: cagney/2003-07-15: Need to add a "set backtrace
     beyond-entry-func" command so that this can be selectively
     disabled.  */
  if (0
#if 0
      && backtrace_beyond_entry_func
#endif
d1539 11
@


1.192
log
@2004-10-29  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (get_selected_frame): Add message parameter.
	* frame.c (get_selected_frame): Add and use message parameter.
	* stack.c (current_frame_command, return_command, locals_info)
	(catch_info, args_info, up_silently_base, down_silently_base): Use
	get_selected_frame with an explicit message.
	* thread.c, stack.c, sh-tdep.c, sh64-tdep.c: Update.
	* remote-rdp.c, remote-mips.c, remote-e7000.c: Update.
	* ocd.c, mi/mi-main.c, mi/mi-cmd-stack.c: Update.
	* infrun.c, inflow.c, infcmd.c, frame.c: Update.
	* findvar.c, eval.c, corelow.c, bsd-kvm.c: Update.
	* breakpoint.c: Update.
@
text
@d393 9
a401 1
      if (gdbarch_unwind_pc_p (current_gdbarch))
a420 9
      else if (this_frame->level < 0)
	{
	  /* FIXME: cagney/2003-03-06: Old code and a sentinel
             frame.  Do like was always done.  Fetch the PC's value
             directly from the global registers array (via read_pc).
             This assumes that this frame belongs to the current
             global register cache.  The assumption is dangerous.  */
	  pc = read_pc ();
	}
d422 1
a422 1
	internal_error (__FILE__, __LINE__, "No gdbarch_unwind_pc method");
@


1.191
log
@2004-08-31  Andrew Cagney  <cagney@@gnu.org>

	* frame.c: Include "objfiles.h".
	(inside_main_func): New function.
	(get_prev_frame): Use new inside_main_func.
	* Makefile.in (frame.o): Update dependencies.
	* defs.h (inside_main_func): Delete declaration.
	* blockframe.c (inside_main_func): Delete function.
@
text
@d825 1
a825 1
get_selected_frame (void)
d828 10
a837 4
    /* Hey!  Don't trust this.  It should really be re-finding the
       last selected frame of the currently selected thread.  This,
       though, is better than nothing.  */
    select_frame (get_current_frame ());
d852 1
a852 1
  return get_selected_frame ();
@


1.190
log
@2004-08-01  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (frame_save_as_regcache): Declare.
	* frame.c (frame_save_as_regcache): New function.
	(do_frame_read_register): Replace do_frame_unwind_register.
	(frame_pop): Use frame_save_as_regcache.
	* dummy-frame.c (generic_push_dummy_frame): Use
	frame_save_as_regcache.
@
text
@d43 1
d1112 21
a1187 4
  /* Make sure we pass an address within THIS_FRAME's code block to
     inside_main_func().  Otherwise, we might stop unwinding at a
     function which has a call instruction as its last instruction if
     that function immediately precedes main().  */
d1190 5
a1194 5
      && inside_main_func (get_frame_address_in_block (this_frame)))
    /* Don't unwind past main(), but always unwind the sentinel frame.
       Note, this is done _before_ the frame has been marked as
       previously unwound.  That way if the user later decides to
       allow unwinds past main(), that just happens.  */
@


1.189
log
@2004-08-01  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (deprecated_frame_xmalloc_with_cleanup)
	(frame_saved_regs_zalloc, frame_extra_info_zalloc)
	(get_frame_extra_info, deprecated_get_frame_saved_regs): Delete.
	* stack.c (frame_info): Delete references to
	DEPRECATED_FRAME_INIT_SAVED_REGS and
	deprecated_get_frame_saved_regs.
	* frame.c (struct frame_info): Delete saved_regs and extra_info.
	(frame_pc_unwind): Do not use DEPRECATED_FRAME_SAVED_PC.
	(frame_register): Do not use DEPRECATED_GET_SAVED_REGISTER.
	(frame_unwind_register_signed)
	(frame_unwind_register_unsigned)
	(frame_unwind_unsigned_register): Use register_size.
	(create_new_frame): Do not use DEPRECATED_INIT_EXTRA_FRAME_INFO.
	(deprecated_frame_xmalloc_with_cleanup)
	(frame_saved_regs_zalloc, frame_extra_info_zalloc)
	(get_frame_extra_info, deprecated_get_frame_saved_regs): Delete.
@
text
@d459 1
a459 1
do_frame_unwind_register (void *src, int regnum, void *buf)
d461 1
a461 1
  frame_unwind_register (src, regnum, buf);
d465 10
d482 2
a483 1
  struct regcache *scratch = regcache_xmalloc (current_gdbarch);
a484 1
  regcache_save (scratch, do_frame_unwind_register, this_frame);
@


1.188
log
@2004-07-31  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (legacy_saved_regs_unwind)
	(legacy_frame_chain_valid, legacy_frame_p)
	(enum frame_type): Delete UNKNOWN_FRAME.
	* dummy-frame.c (dummy_frame_this_id):
	* frame-unwind.c (frame_unwind_find_by_frame):
	* frame.c (struct frame_info): Delete the field "type".
	(legacy_saved_regs_prev_register, legacy_get_prev_frame)
	(legacy_saved_regs_this_id, legacy_saved_regs_unwinder)
	(legacy_saved_regs_unwind, legacy_frame_p)
	(frame_type_from_pc): Delete.
	(get_frame_id, frame_pop, frame_register_unwind, get_prev_frame_1)
	(fprint_frame, create_new_frame, fprint_frame_type): Simplify.
@
text
@a68 16
  /* For each register, address of where it was saved on entry to the
     frame, or zero if it was not saved on entry to this frame.  This
     includes special registers such as pc and fp saved in special
     ways in the stack frame.  The SP_REGNUM is even more special, the
     address here is the sp for the previous frame, not the address
     where the sp was saved.  */
  /* Allocated by frame_saved_regs_zalloc () which is called /
     initialized by DEPRECATED_FRAME_INIT_SAVED_REGS(). */
  CORE_ADDR *saved_regs;	/*NUM_REGS + NUM_PSEUDO_REGS*/

  /* Anything extra for this structure that may have been defined in
     the machine dependent files. */
  /* Allocated by frame_extra_info_zalloc () which is called /
     initialized by DEPRECATED_INIT_EXTRA_FRAME_INFO */
  struct frame_extra_info *extra_info;

a420 8
      else if (DEPRECATED_FRAME_SAVED_PC_P ())
	{
	  /* FIXME: cagney/2003-03-06: Old code, but not a sentinel
             frame.  Do like was always done.  Note that this method,
             unlike unwind_pc(), tries to handle all the different
             frame cases directly.  It fails.  */
	  pc = DEPRECATED_FRAME_SAVED_PC (this_frame);
	}
a568 27
  /* Ulgh!  Old code that, for lval_register, sets ADDRP to the offset
     of the register in the register cache.  It should instead return
     the REGNUM corresponding to that register.  Translate the .  */
  if (DEPRECATED_GET_SAVED_REGISTER_P ())
    {
      DEPRECATED_GET_SAVED_REGISTER (bufferp, optimizedp, addrp, frame,
				     regnum, lvalp);
      /* Compute the REALNUM if the caller wants it.  */
      if (*lvalp == lval_register)
	{
	  int regnum;
	  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
	    {
	      if (*addrp == register_offset_hack (current_gdbarch, regnum))
		{
		  *realnump = regnum;
		  return;
		}
	    }
	  internal_error (__FILE__, __LINE__,
			  "Failed to compute the register number corresponding"
			  " to 0x%s", paddr_d (*addrp));
	}
      *realnump = -1;
      return;
    }

d599 2
a600 1
  return extract_signed_integer (buf, DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
d614 2
a615 1
  return extract_unsigned_integer (buf, DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
d630 3
a632 1
  (*val) = extract_unsigned_integer (buf, DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
d668 1
a668 2
   The number of bytes copied is DEPRECATED_REGISTER_RAW_SIZE
   (REGNUM).
a757 14
CORE_ADDR *
frame_saved_regs_zalloc (struct frame_info *fi)
{
  fi->saved_regs = (CORE_ADDR *)
    frame_obstack_zalloc (SIZEOF_FRAME_SAVED_REGS);
  return fi->saved_regs;
}

CORE_ADDR *
deprecated_get_frame_saved_regs (struct frame_info *fi)
{
  return fi->saved_regs;
}

a907 3
  if (DEPRECATED_INIT_EXTRA_FRAME_INFO_P ())
    DEPRECATED_INIT_EXTRA_FRAME_INFO (0, fi);

a1352 13
struct frame_extra_info *
get_frame_extra_info (struct frame_info *fi)
{
  return fi->extra_info;
}

struct frame_extra_info *
frame_extra_info_zalloc (struct frame_info *fi, long size)
{
  fi->extra_info = frame_obstack_zalloc (size);
  return fi->extra_info;
}

a1384 21
struct frame_info *
deprecated_frame_xmalloc_with_cleanup (long sizeof_saved_regs,
				       long sizeof_extra_info)
{
  struct frame_info *frame = XMALLOC (struct frame_info);
  memset (frame, 0, sizeof (*frame));
  frame->this_id.p = 1;
  make_cleanup (xfree, frame);
  if (sizeof_saved_regs > 0)
    {
      frame->saved_regs = xcalloc (1, sizeof_saved_regs);
      make_cleanup (xfree, frame->saved_regs);
    }
  if (sizeof_extra_info > 0)
    {
      frame->extra_info = xcalloc (1, sizeof_extra_info);
      make_cleanup (xfree, frame->extra_info);
    }
  return frame;
}

@


1.187
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_zinteger_cmd)
	(add_setshow_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_cmd_full): Add help_doc and
	print parameters.  Make string parameters constant.
	* command.h: Update.  Update copyright.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* complaints.c (_initialize_complaints): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* target.c (initialize_targets): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* d10v-tdep.c (_initialize_d10v_tdep): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
@
text
@a68 7
  /* The frame's type.  */
  /* FIXME: cagney/2004-05-01: Should instead just use ->unwind->type.
     Unfortunately, legacy_get_prev_frame is still explicitly setting
     the type.  Eliminate that method and this field can be
     eliminated.  */
  enum frame_type type;

a160 3
    case UNKNOWN_FRAME:
      fprintf_unfiltered (file, "UNKNOWN_FRAME");
      return;
d188 4
a191 1
  fprint_frame_type (file, fi->type);
a230 1
      gdb_assert (!legacy_frame_p (current_gdbarch));
d236 2
a237 9
	{
	  fi->unwind = frame_unwind_find_by_frame (fi->next,
						   &fi->prologue_cache);
	  /* FIXME: cagney/2004-05-01: Should instead just use
	     ->unwind->type.  Unfortunately, legacy_get_prev_frame is
	     still explicitly setting the type.  Eliminate that method
	     and this field can be eliminated.  */
	  fi->type = fi->unwind->type;
	}
d492 20
a511 2
  struct regcache *scratch_regcache;
  struct cleanup *cleanups;
a512 30
  if (DEPRECATED_POP_FRAME_P ())
    {
      /* A legacy architecture that has implemented a custom pop
	 function.  All new architectures should instead be using the
	 generic code below.  */
      DEPRECATED_POP_FRAME;
    }
  else
    {
      /* Make a copy of all the register values unwound from this
	 frame.  Save them in a scratch buffer so that there isn't a
	 race between trying to extract the old values from the
	 current_regcache while at the same time writing new values
	 into that same cache.  */
      struct regcache *scratch = regcache_xmalloc (current_gdbarch);
      struct cleanup *cleanups = make_cleanup_regcache_xfree (scratch);
      regcache_save (scratch, do_frame_unwind_register, this_frame);
      /* FIXME: cagney/2003-03-16: It should be possible to tell the
         target's register cache that it is about to be hit with a
         burst register transfer and that the sequence of register
         writes should be batched.  The pair target_prepare_to_store()
         and target_store_registers() kind of suggest this
         functionality.  Unfortunately, they don't implement it.  Their
         lack of a formal definition can lead to targets writing back
         bogus values (arguably a bug in the target code mind).  */
      /* Now copy those saved registers into the current regcache.
         Here, regcache_cpy() calls regcache_restore().  */
      regcache_cpy (current_regcache, scratch);
      do_cleanups (cleanups);
    }
d549 2
a550 9
    {
      frame->unwind = frame_unwind_find_by_frame (frame->next,
						  &frame->prologue_cache);
      /* FIXME: cagney/2004-05-01: Should instead just use ->unwind->type.
	 Unfortunately, legacy_get_prev_frame is still explicitly setting
	 the type.  Eliminate that method and this field can be
	 eliminated.  */
      frame->type = frame->unwind->type;
    }
a764 1
  frame->type = SENTINEL_FRAME;
a941 103

/* Return the register saved in the simplistic ``saved_regs'' cache.
   If the value isn't here AND a value is needed, try the next inner
   most frame.  */

static void
legacy_saved_regs_prev_register (struct frame_info *next_frame,
				 void **this_prologue_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *bufferp)
{
  /* HACK: New code is passed the next frame and this cache.
     Unfortunately, old code expects this frame.  Since this is a
     backward compatibility hack, cheat by walking one level along the
     prologue chain to the frame the old code expects.

     Do not try this at home.  Professional driver, closed course.  */
  struct frame_info *frame = next_frame->prev;
  gdb_assert (frame != NULL);

  if (deprecated_get_frame_saved_regs (frame) == NULL)
    {
      /* If nothing has initialized the saved regs, do it now.  */
      gdb_assert (DEPRECATED_FRAME_INIT_SAVED_REGS_P ());
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
      gdb_assert (deprecated_get_frame_saved_regs (frame) != NULL);
    }

  if (deprecated_get_frame_saved_regs (frame) != NULL
      && deprecated_get_frame_saved_regs (frame)[regnum] != 0)
    {
      if (regnum == SP_REGNUM)
	{
	  /* SP register treated specially.  */
	  *optimizedp = 0;
	  *lvalp = not_lval;
	  *addrp = 0;
	  *realnump = -1;
	  if (bufferp != NULL)
	    /* NOTE: cagney/2003-05-09: In-lined store_address() with
               it's body - store_unsigned_integer().  */
	    store_unsigned_integer (bufferp, DEPRECATED_REGISTER_RAW_SIZE (regnum),
				    deprecated_get_frame_saved_regs (frame)[regnum]);
	}
      else
	{
	  /* Any other register is saved in memory, fetch it but cache
             a local copy of its value.  */
	  *optimizedp = 0;
	  *lvalp = lval_memory;
	  *addrp = deprecated_get_frame_saved_regs (frame)[regnum];
	  *realnump = -1;
	  if (bufferp != NULL)
	    {
#if 1
	      /* Save each register value, as it is read in, in a
                 frame based cache.  */
	      void **regs = (*this_prologue_cache);
	      if (regs == NULL)
		{
		  int sizeof_cache = ((NUM_REGS + NUM_PSEUDO_REGS)
				      * sizeof (void *));
		  regs = frame_obstack_zalloc (sizeof_cache);
		  (*this_prologue_cache) = regs;
		}
	      if (regs[regnum] == NULL)
		{
		  regs[regnum]
		    = frame_obstack_zalloc (DEPRECATED_REGISTER_RAW_SIZE (regnum));
		  read_memory (deprecated_get_frame_saved_regs (frame)[regnum], regs[regnum],
			       DEPRECATED_REGISTER_RAW_SIZE (regnum));
		}
	      memcpy (bufferp, regs[regnum], DEPRECATED_REGISTER_RAW_SIZE (regnum));
#else
	      /* Read the value in from memory.  */
	      read_memory (deprecated_get_frame_saved_regs (frame)[regnum], bufferp,
			   DEPRECATED_REGISTER_RAW_SIZE (regnum));
#endif
	    }
	}
      return;
    }

  /* No luck.  Assume this and the next frame have the same register
     value.  Pass the unwind request down the frame chain to the next
     frame.  Hopefully that frame will find the register's location.  */
  frame_register_unwind (next_frame, regnum, optimizedp, lvalp, addrp,
			 realnump, bufferp);
}

static void
legacy_saved_regs_this_id (struct frame_info *next_frame,
			   void **this_prologue_cache,
			   struct frame_id *id)
{
  /* A developer is trying to bring up a new architecture, help them
     by providing a default unwinder that refuses to unwind anything
     (the ID is always NULL).  In the case of legacy code,
     legacy_get_prev_frame() will have previously set ->this_id.p, so
     this code won't be called.  */
  (*id) = null_frame_id;
}
a942 21
const struct frame_unwind legacy_saved_regs_unwinder = {
  /* Not really.  It gets overridden by legacy_get_prev_frame().  */
  UNKNOWN_FRAME,
  legacy_saved_regs_this_id,
  legacy_saved_regs_prev_register
};
const struct frame_unwind *legacy_saved_regs_unwind = &legacy_saved_regs_unwinder;

/* Determine the frame's type based on its PC.  */

static enum frame_type
frame_type_from_pc (CORE_ADDR pc)
{
  /* NOTE: cagney/2004-05-08: Eliminating this function depends on all
     architectures being forced to use the frame-unwind code.  */
  if (deprecated_pc_in_call_dummy (pc))
    return DUMMY_FRAME;
  else
    return NORMAL_FRAME;
}

a964 4
  if (fi->unwind->type != UNKNOWN_FRAME)
    fi->type = fi->unwind->type;
  else
    fi->type = frame_type_from_pc (pc);
a1033 434
/* Create the previous frame using the deprecated methods
   INIT_EXTRA_INFO, and INIT_FRAME_PC.  */

static struct frame_info *
legacy_get_prev_frame (struct frame_info *this_frame)
{
  CORE_ADDR address = 0;
  struct frame_info *prev;
  int fromleaf;

  /* Don't frame_debug print legacy_get_prev_frame() here, just
     confuses the output.  */

  /* Allocate the new frame.

     There is no reason to worry about memory leaks, should the
     remainder of the function fail.  The allocated memory will be
     quickly reclaimed when the frame cache is flushed, and the `we've
     been here before' check, in get_prev_frame() will stop repeated
     memory allocation calls.  */
  prev = FRAME_OBSTACK_ZALLOC (struct frame_info);
  prev->level = this_frame->level + 1;

  /* Do not completely wire it in to the frame chain.  Some (bad) code
     in INIT_FRAME_EXTRA_INFO tries to look along frame->prev to pull
     some fancy tricks (of course such code is, by definition,
     recursive).
  
     On the other hand, methods, such as get_frame_pc() and
     get_frame_base() rely on being able to walk along the frame
     chain.  Make certain that at least they work by providing that
     link.  Of course things manipulating prev can't go back.  */
  prev->next = this_frame;

  /* NOTE: cagney/2002-11-18: Should have been correctly setting the
     frame's type here, before anything else, and not last, at the
     bottom of this function.  The various
     DEPRECATED_INIT_EXTRA_FRAME_INFO, DEPRECATED_INIT_FRAME_PC, and
     DEPRECATED_FRAME_INIT_SAVED_REGS methods are full of work-arounds
     that handle the frame not being correctly set from the start.
     Unfortunately those same work-arounds rely on the type defaulting
     to NORMAL_FRAME.  Ulgh!  The new frame code does not have this
     problem.  */
  prev->type = UNKNOWN_FRAME;

  /* A legacy frame's ID is always computed here.  Mark it as valid.  */
  prev->this_id.p = 1;

  /* Handle sentinel frame unwind as a special case.  */
  if (this_frame->level < 0)
    {
      /* Try to unwind the PC.  If that doesn't work, assume we've reached
	 the oldest frame and simply return.  Is there a better sentinal
	 value?  The unwound PC value is then used to initialize the new
	 previous frame's type.

	 Note that the pc-unwind is intentionally performed before the
	 frame chain.  This is ok since, for old targets, both
	 frame_pc_unwind() (nee, DEPRECATED_FRAME_SAVED_PC) and
	 DEPRECATED_FRAME_CHAIN()) assume THIS_FRAME's data structures
	 have already been initialized (using
	 DEPRECATED_INIT_EXTRA_FRAME_INFO) and hence the call order
	 doesn't matter.
	 
	 By unwinding the PC first, it becomes possible to, in the case of
	 a dummy frame, avoid also unwinding the frame ID.  This is
	 because (well ignoring the PPC) a dummy frame can be located
	 using THIS_FRAME's frame ID.  */
      
      deprecated_update_frame_pc_hack (prev, frame_pc_unwind (this_frame));
      if (get_frame_pc (prev) == 0)
	{
	  /* The allocated PREV_FRAME will be reclaimed when the frame
	     obstack is next purged.  */
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // unwound legacy PC zero }\n");
	    }
	  return NULL;
	}

      /* Set the unwind functions based on that identified PC.  Ditto
         for the "type" but strongly prefer the unwinder's frame type.  */
      prev->unwind = frame_unwind_find_by_frame (prev->next,
						 &prev->prologue_cache);
      if (prev->unwind->type == UNKNOWN_FRAME)
	prev->type = frame_type_from_pc (get_frame_pc (prev));
      else
	prev->type = prev->unwind->type;

      /* Find the prev's frame's ID.  */
      if (prev->type == DUMMY_FRAME
	  && gdbarch_unwind_dummy_id_p (current_gdbarch))
	{
	  /* When unwinding a normal frame, the stack structure is
	     determined by analyzing the frame's function's code (be
	     it using brute force prologue analysis, or the dwarf2
	     CFI).  In the case of a dummy frame, that simply isn't
	     possible.  The The PC is either the program entry point,
	     or some random address on the stack.  Trying to use that
	     PC to apply standard frame ID unwind techniques is just
	     asking for trouble.  */
	  /* Use an architecture specific method to extract the prev's
	     dummy ID from the next frame.  Note that this method uses
	     frame_register_unwind to obtain the register values
	     needed to determine the dummy frame's ID.  */
	  prev->this_id.value = gdbarch_unwind_dummy_id (current_gdbarch,
							 this_frame);
	}
      else
	{
	  /* We're unwinding a sentinel frame, the PC of which is
	     pointing at a stack dummy.  Fake up the dummy frame's ID
	     using the same sequence as is found a traditional
	     unwinder.  Once all architectures supply the
	     unwind_dummy_id method, this code can go away.  */
	  prev->this_id.value = frame_id_build (deprecated_read_fp (),
						read_pc ());
	}

      /* Check that the unwound ID is valid.  */
      if (!frame_id_p (prev->this_id.value))
	{
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // unwound legacy ID invalid }\n");
	    }
	  return NULL;
	}

      /* Check that the new frame isn't inner to (younger, below,
	 next) the old frame.  If that happens the frame unwind is
	 going backwards.  */
      /* FIXME: cagney/2003-02-25: Ignore the sentinel frame since
	 that doesn't have a valid frame ID.  Should instead set the
	 sentinel frame's frame ID to a `sentinel'.  Leave it until
	 after the switch to storing the frame ID, instead of the
	 frame base, in the frame object.  */

      /* Link it in.  */
      this_frame->prev = prev;

      /* FIXME: cagney/2002-01-19: This call will go away.  Instead of
	 initializing extra info, all frames will use the frame_cache
	 (passed to the unwind functions) to store additional frame
	 info.  Unfortunately legacy targets can't use
	 legacy_get_prev_frame() to unwind the sentinel frame and,
	 consequently, are forced to take this code path and rely on
	 the below call to DEPRECATED_INIT_EXTRA_FRAME_INFO to
	 initialize the inner-most frame.  */
      if (DEPRECATED_INIT_EXTRA_FRAME_INFO_P ())
	{
	  DEPRECATED_INIT_EXTRA_FRAME_INFO (0, prev);
	}

      if (prev->type == NORMAL_FRAME)
	prev->this_id.value.code_addr
	  = get_pc_function_start (prev->this_id.value.code_addr);

      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, prev);
	  fprintf_unfiltered (gdb_stdlog, " } // legacy innermost frame\n");
	}
      return prev;
    }

  /* This code only works on normal frames.  A sentinel frame, where
     the level is -1, should never reach this code.  */
  gdb_assert (this_frame->level >= 0);

  /* On some machines it is possible to call a function without
     setting up a stack frame for it.  On these machines, we
     define this macro to take two args; a frameinfo pointer
     identifying a frame and a variable to set or clear if it is
     or isn't leafless.  */

  /* Still don't want to worry about this except on the innermost
     frame.  This macro will set FROMLEAF if THIS_FRAME is a frameless
     function invocation.  */
  if (this_frame->level == 0)
    /* FIXME: 2002-11-09: Frameless functions can occur anywhere in
       the frame chain, not just the inner most frame!  The generic,
       per-architecture, frame code should handle this and the below
       should simply be removed.  */
    fromleaf = (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION_P ()
		&& DEPRECATED_FRAMELESS_FUNCTION_INVOCATION (this_frame));
  else
    fromleaf = 0;

  if (fromleaf)
    /* A frameless inner-most frame.  The `FP' (which isn't an
       architecture frame-pointer register!) of the caller is the same
       as the callee.  */
    /* FIXME: 2002-11-09: There isn't any reason to special case this
       edge condition.  Instead the per-architecture code should handle
       it locally.  */
    /* FIXME: cagney/2003-06-16: This returns the inner most stack
       address for the previous frame, that, however, is wrong.  It
       should be the inner most stack address for the previous to
       previous frame.  This is because it is the previous to previous
       frame's innermost stack address that is constant through out
       the lifetime of the previous frame (trust me :-).  */
    address = get_frame_base (this_frame);
  else
    {
      /* Two macros defined in tm.h specify the machine-dependent
         actions to be performed here.

         First, get the frame's chain-pointer.

         If that is zero, the frame is the outermost frame or a leaf
         called by the outermost frame.  This means that if start
         calls main without a frame, we'll return 0 (which is fine
         anyway).

         Nope; there's a problem.  This also returns when the current
         routine is a leaf of main.  This is unacceptable.  We move
         this to after the ffi test; I'd rather have backtraces from
         start go curfluy than have an abort called from main not show
         main.  */
      if (DEPRECATED_FRAME_CHAIN_P ())
	address = DEPRECATED_FRAME_CHAIN (this_frame);
      else
	{
	  /* Someone is part way through coverting an old architecture
             to the new frame code.  Implement FRAME_CHAIN the way the
             new frame will.  */
	  /* Find PREV frame's unwinder.  */
	  prev->unwind = frame_unwind_find_by_frame (this_frame,
						     &prev->prologue_cache);
	  /* FIXME: cagney/2004-05-01: Should instead just use
	     ->unwind->type.  Unfortunately, legacy_get_prev_frame is
	     still explicitly setting the type.  Eliminate that method
	     and this field can be eliminated.  */
	  prev->type = prev->unwind->type;
	  /* Find PREV frame's ID.  */
	  prev->unwind->this_id (this_frame,
				 &prev->prologue_cache,
				 &prev->this_id.value);
	  prev->this_id.p = 1;
	  address = prev->this_id.value.stack_addr;
	}

      if (!legacy_frame_chain_valid (address, this_frame))
	{
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // legacy frame chain invalid }\n");
	    }
	  return NULL;
	}
    }
  if (address == 0)
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog,
			      " // legacy frame chain NULL }\n");
	}
      return NULL;
    }

  /* Link in the already allocated prev frame.  */
  this_frame->prev = prev;
  deprecated_update_frame_base_hack (prev, address);

  /* This change should not be needed, FIXME!  We should determine
     whether any targets *need* DEPRECATED_INIT_FRAME_PC to happen
     after DEPRECATED_INIT_EXTRA_FRAME_INFO and come up with a simple
     way to express what goes on here.

     DEPRECATED_INIT_EXTRA_FRAME_INFO is called from two places:
     create_new_frame (where the PC is already set up) and here (where
     it isn't).  DEPRECATED_INIT_FRAME_PC is only called from here,
     always after DEPRECATED_INIT_EXTRA_FRAME_INFO.

     The catch is the MIPS, where DEPRECATED_INIT_EXTRA_FRAME_INFO
     requires the PC value (which hasn't been set yet).  Some other
     machines appear to require DEPRECATED_INIT_EXTRA_FRAME_INFO
     before they can do DEPRECATED_INIT_FRAME_PC.  Phoo.

     Assuming that some machines need DEPRECATED_INIT_FRAME_PC after
     DEPRECATED_INIT_EXTRA_FRAME_INFO, one possible scheme:

     SETUP_INNERMOST_FRAME(): Default version is just create_new_frame
     (deprecated_read_fp ()), read_pc ()).  Machines with extra frame
     info would do that (or the local equivalent) and then set the
     extra fields.

     SETUP_ARBITRARY_FRAME(argc, argv): Only change here is that
     create_new_frame would no longer init extra frame info;
     SETUP_ARBITRARY_FRAME would have to do that.

     INIT_PREV_FRAME(fromleaf, prev) Replace
     DEPRECATED_INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC.
     This should also return a flag saying whether to keep the new
     frame, or whether to discard it, because on some machines (e.g.
     mips) it is really awkward to have DEPRECATED_FRAME_CHAIN_VALID
     called BEFORE DEPRECATED_INIT_EXTRA_FRAME_INFO (there is no good
     way to get information deduced in DEPRECATED_FRAME_CHAIN_VALID
     into the extra fields of the new frame).  std_frame_pc(fromleaf,
     prev)

     This is the default setting for INIT_PREV_FRAME.  It just does
     what the default DEPRECATED_INIT_FRAME_PC does.  Some machines
     will call it from INIT_PREV_FRAME (either at the beginning, the
     end, or in the middle).  Some machines won't use it.

     kingdon@@cygnus.com, 13Apr93, 31Jan94, 14Dec94.  */

  /* NOTE: cagney/2002-11-09: Just ignore the above!  There is no
     reason for things to be this complicated.

     The trick is to assume that there is always a frame.  Instead of
     special casing the inner-most frame, create a fake frame
     (containing the hardware registers) that is inner to the
     user-visible inner-most frame (...) and then unwind from that.
     That way architecture code can use the standard
     frame_XX_unwind() functions and not differentiate between the
     inner most and any other case.

     Since there is always a frame to unwind from, there is always
     somewhere (THIS_FRAME) to store all the info needed to construct
     a new (previous) frame without having to first create it.  This
     means that the convolution below - needing to carefully order a
     frame's initialization - isn't needed.

     The irony here though, is that DEPRECATED_FRAME_CHAIN(), at least
     for a more up-to-date architecture, always calls
     FRAME_SAVED_PC(), and FRAME_SAVED_PC() computes the PC but
     without first needing the frame!  Instead of the convolution
     below, we could have simply called FRAME_SAVED_PC() and been done
     with it!  Note that FRAME_SAVED_PC() is being superseded by
     frame_pc_unwind() and that function does have somewhere to cache
     that PC value.  */

  if (DEPRECATED_INIT_EXTRA_FRAME_INFO_P ())
    DEPRECATED_INIT_EXTRA_FRAME_INFO (fromleaf, prev);

  /* This entry is in the frame queue now, which is good since
     FRAME_SAVED_PC may use that queue to figure out its value (see
     tm-sparc.h).  We want the PC saved in the inferior frame. */
  if (DEPRECATED_INIT_FRAME_PC_P ())
    deprecated_update_frame_pc_hack (prev,
				     DEPRECATED_INIT_FRAME_PC (fromleaf,
							       prev));

  /* If ->frame and ->pc are unchanged, we are in the process of
     getting ourselves into an infinite backtrace.  Some architectures
     check this in DEPRECATED_FRAME_CHAIN or thereabouts, but it seems
     like there is no reason this can't be an architecture-independent
     check.  */
  if (get_frame_base (prev) == get_frame_base (this_frame)
      && get_frame_pc (prev) == get_frame_pc (this_frame))
    {
      this_frame->prev = NULL;
      obstack_free (&frame_cache_obstack, prev);
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog,
			      " // legacy this.id == prev.id }\n");
	}
      return NULL;
    }

  /* Initialize the code used to unwind the frame PREV based on the PC
     (and probably other architectural information).  The PC lets you
     check things like the debug info at that point (dwarf2cfi?) and
     use that to decide how the frame should be unwound.

     If there isn't a FRAME_CHAIN, the code above will have already
     done this.  */
  if (prev->unwind == NULL)
    prev->unwind = frame_unwind_find_by_frame (prev->next,
					       &prev->prologue_cache);

  /* If the unwinder provides a frame type, use it.  Otherwise
     continue on to that heuristic mess.  */
  if (prev->unwind->type != UNKNOWN_FRAME)
    {
      prev->type = prev->unwind->type;
      if (prev->type == NORMAL_FRAME)
	/* FIXME: cagney/2003-06-16: would get_frame_pc() be better?  */
	prev->this_id.value.code_addr
	  = get_pc_function_start (prev->this_id.value.code_addr);
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, prev);
	  fprintf_unfiltered (gdb_stdlog, " } // legacy with unwound type\n");
	}
      return prev;
    }

  /* NOTE: cagney/2002-11-18: The code segments, found in
     create_new_frame() and get_prev_frame(), that initialize the
     frame's type is subtly different.  The latter only updates ->type
     when it encounters a SIGTRAMP_FRAME or DUMMY_FRAME.  This stops
     get_prev_frame() overriding the frame's type when the INIT code
     has previously set it.  This is really somewhat bogus.  The
     initialization, as seen in create_new_frame(), should occur
     before the INIT function has been called.  */
  if (deprecated_pc_in_call_dummy (get_frame_pc (prev)))
    prev->type = DUMMY_FRAME;

  if (prev->type == NORMAL_FRAME)
    prev->this_id.value.code_addr
      = get_pc_function_start (prev->this_id.value.code_addr);

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, prev);
      fprintf_unfiltered (gdb_stdlog, " } // legacy with confused type\n");
    }

  return prev;
}

a1070 8
  /* If any of the old frame initialization methods are around, use
     the legacy get_prev_frame() method.  */
  if (legacy_frame_p (current_gdbarch))
    {
      prev_frame = legacy_get_prev_frame (this_frame);
      return prev_frame;
    }

d1091 1
a1091 1
      && this_frame->next->type != SIGTRAMP_FRAME
d1268 1
a1268 1
      && this_frame->type != DUMMY_FRAME && this_frame->level >= 0
d1410 6
a1415 20
  /* Some legacy code, e.g, mips_init_extra_frame_info() wants
     to determine the frame's type prior to it being completely
     initialized.  Don't attempt to lazily initialize ->unwind for
     legacy code.  It will be initialized in legacy_get_prev_frame().  */
  if (frame->unwind == NULL && !legacy_frame_p (current_gdbarch))
    {
      /* Initialize the frame's unwinder because that's what
         provides the frame's type.  */
      frame->unwind = frame_unwind_find_by_frame (frame->next, 
						  &frame->prologue_cache);
      /* FIXME: cagney/2004-05-01: Should instead just use
	 ->unwind->type.  Unfortunately, legacy_get_prev_frame is
	 still explicitly setting the type.  Eliminate that method and
	 this field can be eliminated.  */
      frame->type = frame->unwind->type;
    }
  if (frame->type == UNKNOWN_FRAME)
    return NORMAL_FRAME;
  else
    return frame->type;
a1552 27

int
legacy_frame_p (struct gdbarch *current_gdbarch)
{
  if (DEPRECATED_INIT_FRAME_PC_P ()
      || DEPRECATED_INIT_EXTRA_FRAME_INFO_P ()
      || DEPRECATED_FRAME_CHAIN_P ())
    /* No question, it's a legacy frame.  */
    return 1;
  if (gdbarch_unwind_dummy_id_p (current_gdbarch))
    /* No question, it's not a legacy frame (provided none of the
       deprecated methods checked above are present that is).  */
    return 0;
  if (DEPRECATED_TARGET_READ_FP_P ()
      || DEPRECATED_FP_REGNUM >= 0)
    /* Assume it's legacy.  If you're trying to convert a legacy frame
       target to the new mechanism, get rid of these.  legacy
       get_prev_frame() requires these when unwind_frame_id() isn't
       available.  */
    return 1;
  /* Default to assuming that it's brand new code, and hence not
     legacy.  Force it down the non-legacy path so that the new code
     uses the new frame mechanism from day one.  Dummy frames won't
     work very well but we can live with that.  */
  return 0;
}

@


1.186
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d2236 2
a2237 1
Set whether backtraces should continue past \"main\".\n\
d2241 1
a2241 4
Show whether backtraces should continue past \"main\".\n\
Normally the caller of \"main\" is not of interest, so GDB will terminate\n\
the backtrace at \"main\".  Set this variable if you need to see the rest\n\
of the stack trace.",
d2247 2
a2248 1
Set an upper bound on the number of backtrace levels.\n\
d2251 1
a2251 1
Show the upper bound on the number of backtrace levels.",
@


1.185
log
@2004-07-20  Andrew Cagney  <cagney@@gnu.org>

	* breakpoint.c (deprecated_read_memory_nobpt): Rename
	read_memory_nobpt.
	* sparc-linux-tdep.c (sparc_linux_sigtramp_start): Update.
	* s390-tdep.c (s390_readinstruction, s390_in_function_epilogue_p)
	(s390_sigtramp_frame_sniffer): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue): Update.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Update.
	* mips-tdep.c (mips_fetch_instruction, mips16_fetch_instruction)
	(mips32_fetch_instruction): Update.
	* mcore-tdep.c (get_insn): Update.
	* m68klinux-tdep.c (m68k_linux_pc_in_sigtramp): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_offset): Update.
	* i386ly-tdep.c (i386lynx_saved_pc_after_call): Update.
	* i386-linux-tdep.c (i386_linux_sigtramp_start)
	(i386_linux_rt_sigtramp_start): Update.
	* i386-linux-nat.c (child_resume): Update.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Update.
	* hppa-linux-tdep.c (insns_match_pattern): Update.
	* gdbcore.h: Update.
	* frv-tdep.c (frv_gdbarch_adjust_breakpoint_address): Update.
	* frame.c (safe_frame_unwind_memory): Update.
	* amd64-linux-tdep.c (amd64_linux_sigtramp_start): Update.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Update.
	* alpha-tdep.c (alpha_read_insn): Update.
@
text
@d2257 3
a2259 2
  add_show_from_set (add_set_cmd ("frame", class_maintenance, var_zinteger,
				  &frame_debug, "Set frame debugging.\n\
d2261 1
a2261 1
		     &showdebuglist);
@


1.184
log
@2004-07-16  Andrew Cagney  <cagney@@gnu.org>

	* frame.c (fprint_field): New function.
	(fprint_frame_id): Use fprint_field.
@
text
@d2130 2
a2131 2
  /* NOTE: read_memory_nobpt returns zero on success!  */
  return !read_memory_nobpt (addr, buf, len);
@


1.183
log
@	* frame.h (struct frame_id): New fields stack_addr_p, code_addr_p
	and special_addr_p.
	(frame_id_build, frame_id_build_special): Update comments.
	(frame_id_build_wild): New prototype.
	* frame.c (frame_id_build, frame_id_build_special): Fill in new
	struct frame_id fields.
	(frame_id_build_wild): New function.
	(frame_id_eq, frame_id_inner): Use new struct frame_id fields.
@
text
@d142 8
d154 7
a160 4
  fprintf_unfiltered (file, "{stack=0x%s,code=0x%s,special=0x%s}",
		      paddr_nz (id.stack_addr),
		      paddr_nz (id.code_addr),
		      paddr_nz (id.special_addr));
@


1.183.2.1
log
@2004-07-16  Andrew Cagney  <cagney@@gnu.org>

	* frame.c (fprint_field): New function.
	(fprint_frame_id): Use fprint_field.
@
text
@a141 8
static void
fprint_field (struct ui_file *file, const char *name, int p, CORE_ADDR addr)
{
  if (p)
    fprintf_unfiltered (file, "%s=0x%s", name, paddr_nz (addr));
  else
    fprintf_unfiltered (file, "!%s", name);
}
d146 4
a149 7
  fprintf_unfiltered (file, "{");
  fprint_field (file, "stack", id.stack_addr_p, id.stack_addr);
  fprintf_unfiltered (file, ",");
  fprint_field (file, "code", id.code_addr_p, id.code_addr);
  fprintf_unfiltered (file, ",");
  fprint_field (file, "special", id.special_addr_p, id.special_addr);
  fprintf_unfiltered (file, "}");
@


1.182
log
@2004-06-10  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h (deprecated_pc_in_call_dummy): Delete "sp" and "fp"
	parameters.
	* dummy-frame.c (deprecated_pc_in_call_dummy): Update.
	* arm-tdep.c (arm_pc_is_thumb_dummy): Call
	deprecated_pc_in_call_dummy instead of
	DEPRECATED_PC_IN_CALL_DUMMY.
	(arm_skip_prologue): Ditto.
	* xstormy16-tdep.c (xstormy16_pop_frame, xstormy16_scan_prologue)
	(xstormy16_frame_saved_pc, xstormy16_frame_chain): Ditto.
	* v850-tdep.c (v850_find_callers_reg, v850_frame_chain)
	(v850_pop_frame, v850_frame_saved_pc, v850_frame_init_saved_regs):
	Ditto.
	* sh64-tdep.c (sh64_frame_chain, sh64_get_saved_pr)
	(sh64_init_extra_frame_info, sh64_get_saved_register)
	(sh64_pop_frame): Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* mcore-tdep.c (mcore_find_callers_reg, mcore_frame_saved_pc)
	(mcore_pop_frame, mcore_init_extra_frame_info): Ditto.
	* h8300-tdep.c (h8300_frame_chain, h8300_frame_saved_pc)
	(h8300_pop_frame): Ditto.
	* blockframe.c (legacy_inside_entry_func)
	(legacy_frame_chain_valid): Ditto.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update call
	to deprecated_pc_in_call_dummy.
@
text
@d271 1
a271 1
  struct frame_id id;
d273 1
d275 1
d277 1
d284 15
a298 1
  return frame_id_build_special (stack_addr, code_addr, 0);
d305 2
a306 2
  /* The .code can be NULL but the .stack cannot.  */
  p = (l.stack_addr != 0);
d320 3
a322 2
  if (l.stack_addr == 0 || r.stack_addr == 0)
    /* Like a NaN, if either ID is invalid, the result is false.  */
d327 2
a328 2
  else if (l.code_addr == 0 || r.code_addr == 0)
    /* A zero code addr is a wild card, always succeed.  */
d333 2
a334 2
  else if (l.special_addr == 0 || r.special_addr == 0)
    /* A zero special addr is a wild card (or unused), always succeed.  */
d357 1
a357 1
  if (l.stack_addr == 0 || r.stack_addr == 0)
@


1.181
log
@2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_USE_GENERIC_DUMMY_FRAMES): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* blockframe.c (legacy_frame_chain_valid): Simplify by eliminating
	DEPRECATED_USE_GENERIC_DUMMY_FRAMES.
	* infcall.c (legacy_push_dummy_code, call_function_by_hand): Ditto.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Ditto.
@
text
@d1067 1
a1067 1
  if (deprecated_pc_in_call_dummy (pc, 0, 0))
d1585 1
a1585 1
  if (deprecated_pc_in_call_dummy (get_frame_pc (prev), 0, 0))
@


1.180
log
@2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.h (deprecated_frame_in_dummy): Delete declaration.
	(struct frame_info): Delete opaque declaration.
	* breakpoint.c (deprecated_frame_in_dummy): Delete function.
	* frame.c (get_frame_type): Delete call.
@
text
@d1065 3
a1067 2
  if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES
      && deprecated_pc_in_call_dummy (pc, 0, 0))
d1585 1
a1585 2
  if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES
      && deprecated_pc_in_call_dummy (get_frame_pc (prev), 0, 0))
@


1.179
log
@* frame.c (get_prev_frame_1): Work around GCC bug.
* frame.h: Add comment about GCC bug.
@
text
@a1985 6
  /* Some targets still don't use [generic] dummy frames.  Catch them
     here.  */
  if (!DEPRECATED_USE_GENERIC_DUMMY_FRAMES
      && deprecated_frame_in_dummy (frame))
    return DUMMY_FRAME;

@


1.178
log
@2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_generic_get_saved_register): Delete
	function, moved to "xstormy16-tdep.c".
	* xstormy16-tdep.c (xstormy16_get_saved_register): Inline
	deprecated_generic_get_saved_register from "frame.c".
	(xstormy16_frame_saved_register): Call
	xstormy16_get_saved_register.
	* dummy-frame.c (deprecated_find_dummy_frame_regcache): Make
	static.
	* dummy-frame.h (deprecated_find_dummy_frame_regcache): Delete.
	* frame.h (deprecated_generic_get_saved_register): Delete.
@
text
@d1612 1
d1650 2
a1651 1
  if (this_frame->level >= 0 && !frame_id_p (get_frame_id (this_frame)))
d1668 1
a1668 2
      && frame_id_inner (get_frame_id (this_frame),
			 get_frame_id (this_frame->next)))
d1675 1
a1675 2
      && frame_id_eq (get_frame_id (this_frame),
		      get_frame_id (this_frame->next)))
@


1.177
log
@2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (create_sentinel_frame): Set type to SENTINEL_FRAME.
	* dummy-frame.c (dummy_frame_this_id): Use get_frame_type, instead
	of frame_relative_level.
	* sentinel-frame.c (sentinel_frame_unwinder): Set unwinder's type
	to SENTINEL_FRAME.
	* frame.h (enum frame_type): Add SENTINEL_FRAME.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Delete calls to
	frame_relative_level.
@
text
@a1059 103

/* Function: deprecated_generic_get_saved_register
   Find register number REGNUM relative to FRAME and put its (raw,
   target format) contents in *RAW_BUFFER.

   Set *OPTIMIZED if the variable was optimized out (and thus can't be
   fetched).  Note that this is never set to anything other than zero
   in this implementation.

   Set *LVAL to lval_memory, lval_register, or not_lval, depending on
   whether the value was fetched from memory, from a register, or in a
   strange and non-modifiable way (e.g. a frame pointer which was
   calculated rather than fetched).  We will use not_lval for values
   fetched from generic dummy frames.

   Set *ADDRP to the address, either in memory or as a
   DEPRECATED_REGISTER_BYTE offset into the registers array.  If the
   value is stored in a dummy frame, set *ADDRP to zero.

   The argument RAW_BUFFER must point to aligned memory.  */

void
deprecated_generic_get_saved_register (char *raw_buffer, int *optimized,
				       CORE_ADDR *addrp,
				       struct frame_info *frame, int regnum,
				       enum lval_type *lval)
{
  if (!target_has_registers)
    error ("No registers.");

  /* Normal systems don't optimize out things with register numbers.  */
  if (optimized != NULL)
    *optimized = 0;

  if (addrp)			/* default assumption: not found in memory */
    *addrp = 0;

  /* Note: since the current frame's registers could only have been
     saved by frames INTERIOR TO the current frame, we skip examining
     the current frame itself: otherwise, we would be getting the
     previous frame's registers which were saved by the current frame.  */

  if (frame != NULL)
    {
      for (frame = get_next_frame (frame);
	   frame_relative_level (frame) >= 0;
	   frame = get_next_frame (frame))
	{
	  if (get_frame_type (frame) == DUMMY_FRAME)
	    {
	      if (lval)		/* found it in a CALL_DUMMY frame */
		*lval = not_lval;
	      if (raw_buffer)
		/* FIXME: cagney/2002-06-26: This should be via the
		   gdbarch_register_read() method so that it, on the
		   fly, constructs either a raw or pseudo register
		   from the raw register cache.  */
		regcache_raw_read
		  (deprecated_find_dummy_frame_regcache (get_frame_pc (frame),
							 get_frame_base (frame)),
		   regnum, raw_buffer);
	      return;
	    }

	  DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
	  if (deprecated_get_frame_saved_regs (frame) != NULL
	      && deprecated_get_frame_saved_regs (frame)[regnum] != 0)
	    {
	      if (lval)		/* found it saved on the stack */
		*lval = lval_memory;
	      if (regnum == SP_REGNUM)
		{
		  if (raw_buffer)	/* SP register treated specially */
		    /* NOTE: cagney/2003-05-09: In-line store_address()
                       with it's body - store_unsigned_integer().  */
		    store_unsigned_integer (raw_buffer,
					    DEPRECATED_REGISTER_RAW_SIZE (regnum),
					    deprecated_get_frame_saved_regs (frame)[regnum]);
		}
	      else
		{
		  if (addrp)	/* any other register */
		    *addrp = deprecated_get_frame_saved_regs (frame)[regnum];
		  if (raw_buffer)
		    read_memory (deprecated_get_frame_saved_regs (frame)[regnum], raw_buffer,
				 DEPRECATED_REGISTER_RAW_SIZE (regnum));
		}
	      return;
	    }
	}
    }

  /* If we get thru the loop to this point, it means the register was
     not saved in any frame.  Return the actual live-register value.  */

  if (lval)			/* found it in a live register */
    *lval = lval_register;
  if (addrp)
    *addrp = DEPRECATED_REGISTER_BYTE (regnum);
  if (raw_buffer)
    deprecated_read_register_gen (regnum, raw_buffer);
}

@


1.176
log
@2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_set_frame_type): Delete declaration.
	* frame.c (deprecated_set_frame_type): Delete function, update
	comments.
@
text
@d770 1
a770 1
  frame->type = NORMAL_FRAME;
@


1.175
log
@2004-04-30  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_type_from_pc): Delete call to PC_IN_SIGTRAMP.
	(legacy_get_prev_frame): Ditto.
@
text
@d70 4
a73 4
  /* FIXME: cagney/2003-04-02: Should instead be returning
     ->unwind->type.  Unfortunately, legacy code is still explicitly
     setting the type using the method deprecated_set_frame_type.
     Eliminate that method and this field can be eliminated.  */
d236 4
a239 5
	  /* FIXME: cagney/2003-04-02: Rather than storing the frame's
	     type in the frame, the unwinder's type should be returned
	     directly.  Unfortunately legacy code, called by
	     legacy_get_prev_frame(), explicitly sets the frame's type
	     using the method deprecated_set_frame_type().  */
d550 4
a553 5
      /* FIXME: cagney/2003-04-02: Rather than storing the frame's
	 type in the frame, the unwinder's type should be returned
	 directly.  Unfortunately, legacy code, called by
	 legacy_get_prev_frame(), explicitly set the frames type using
	 the method deprecated_set_frame_type().  */
d1508 4
a1511 5
	  /* FIXME: cagney/2003-04-02: Rather than storing the frame's
	     type in the frame, the unwinder's type should be returned
	     directly.  Unfortunately, legacy code, called by
	     legacy_get_prev_frame(), explicitly set the frames type
	     using the method deprecated_set_frame_type().  */
d2105 4
a2108 5
      /* FIXME: cagney/2003-04-02: Rather than storing the frame's
	 type in the frame, the unwinder's type should be returned
	 directly.  Unfortunately, legacy code, called by
	 legacy_get_prev_frame(), explicitly set the frames type using
	 the method deprecated_set_frame_type().  */
a2114 7
}

void
deprecated_set_frame_type (struct frame_info *frame, enum frame_type type)
{
  /* Arrrg!  See comment in "frame.h".  */
  frame->type = type;
@


1.174
log
@2004-04-30  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (deprecated_inside_entry_file): Delete declaration.
	* blockframe.c (deprecated_inside_entry_file): Delete function.
	(legacy_frame_chain_valid): Delete call.
	* sh64-tdep.c (sh64_frame_chain): Delete call.
	* objfiles.h: Update comments.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Delete
	call.
	* frame.c (get_prev_frame): Delete call, update comments.
@
text
@d1174 1
a1174 8
    {
      char *name;
      find_pc_partial_function (pc, &name, NULL, NULL);
      if (DEPRECATED_PC_IN_SIGTRAMP (pc, name))
	return SIGTRAMP_FRAME;
      else
	return NORMAL_FRAME;
    }
a1692 19
  else
    {
      /* FIXME: cagney/2002-11-10: This should be moved to before the
	 INIT code above so that the INIT code knows what the frame's
	 type is (in fact, for a [generic] dummy-frame, the type can
	 be set and then the entire initialization can be skipped).
	 Unfortunately, it's the INIT code that sets the PC (Hmm, catch
	 22).  */
      char *name;
      find_pc_partial_function (get_frame_pc (prev), &name, NULL, NULL);
      if (DEPRECATED_PC_IN_SIGTRAMP (get_frame_pc (prev), name))
	prev->type = SIGTRAMP_FRAME;
      /* FIXME: cagney/2002-11-11: Leave prev->type alone.  Some
         architectures are forcing the frame's type in INIT so we
         don't want to override it here.  Remember, NORMAL_FRAME == 0,
         so it all works (just :-/).  Once this initialization is
         moved to the start of this function, all this nastness will
         go away.  */
    }
@


1.173
log
@2004-04-26  Orjan Friberg <orjanf@@axis.com>

	* frame.c: Include "observer.h".
	(frame_observer_target_changed): New function.
	(_initialize_frame): Attach target_changed observer.
	* regcache.c: Include "observer.h".
	(regcache_observer_target_changed): New function.
	(_initialize_regcache): Attach target_changed observer.
	* valops.c: Include "observer.h".
	(value_assign): Notify target_changed event when modifying register.
	* Makefile.in (frame.o, regcache.o, valops.o): Add $(observer_h).
@
text
@d1957 3
a1959 3
  /* NOTE: cagney/2003-07-07: Fixed a bug in inside_main_func() - wasn't
     checking for "main" in the minimal symbols.  With that fixed
     asm-source tests now stop in "main" instead of halting the
d1961 2
a1962 3
     file.  Suspect that deprecated_inside_entry_file() and
     inside_entry_func() tests were added to work around that (now
     fixed) case.  */
a1979 29
      return NULL;
    }

  /* If we're inside the entry file, it isn't valid.  Don't apply this
     test to a dummy frame - dummy frame PCs typically land in the
     entry file.  Don't apply this test to the sentinel frame.
     Sentinel frames should always be allowed to unwind.  */
  /* NOTE: drow/2002-12-25: should there be a way to disable this
     check?  It assumes a single small entry file, and the way some
     debug readers (e.g. dbxread) figure out which object is the
     entry file is somewhat hokey.  */
  /* NOTE: cagney/2003-01-10: If there is a way of disabling this test
     then it should probably be moved to before the ->prev_p test,
     above.  */
  /* NOTE: vinschen/2003-04-01: Disabled.  It turns out that the call
     to deprecated_inside_entry_file() destroys a meaningful backtrace
     under some conditions, e.g. the backtrace tests in the
     asm-source testcase are broken for some targets.  In this test
     the functions are all implemented as part of one file and the
     testcase is not necessarily linked with a start file (depending
     on the target).  What happens is that the first frame is printed
     normally and following frames are treated as being inside the
     entry file then.  This way, only the #0 frame is printed in the
     backtrace output.  */
  if (0
      && this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && deprecated_inside_entry_file (get_frame_pc (this_frame)))
    {
      frame_debug_got_null_frame (gdb_stdlog, this_frame, "inside entry file");
@


1.172
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d42 1
d1241 8
d2367 2
@


1.171
log
@2004-04-16  Jason Molenda  (jmolenda@@apple.com)

        * frame.c: Minor typeo corrections in comments.
@
text
@d917 2
a918 2
  if (selected_frame_level_changed_hook)
    selected_frame_level_changed_hook (frame_relative_level (fi));
@


1.170
log
@2004-04-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC_FIRST): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (legacy_get_prev_frame): Delete references to
	DEPRECATED_INIT_FRAME_PC_FIRST.
@
text
@d62 1
a62 1
  /* NOTE: cagney/2002-04-05: Perhaphs a level of ``-1'' should be
d94 1
a94 1
     selected based on the presence, or otherwize, of register unwind
d237 2
a238 2
	     directly.  Unfortunately, legacy code, called by
	     legacy_get_prev_frame, explicitly set the frames type
d380 2
a381 2
      /* Either, we're not yet gone far enough out along the frame
         chain (inner(this,id), or we're comparing frameless functions
d416 1
a416 1
	  /* FIXME: cagney/2003-03-06: Old code and and a sentinel
d418 1
a418 1
             direct from the global registers array (via read_pc).
d492 2
a493 2
	 race betweening trying to extract the old values from the
	 current_regcache while, at the same time writing new values
d541 1
a541 1
     isn't, there is some pretty busted code as it should have
d553 1
a553 1
	 legacy_get_prev_frame, explicitly set the frames type using
d559 1
a559 1
     "frame-unwind.h" for why NEXT frame and this unwind cace are
d735 1
a735 1
  /* FIXME: cagney/2002-05-15: This test, is just bogus.
d836 1
a836 1
  /* A sentinel frame can fail to unwind, eg, because it's PC value
d878 1
a878 1
/* Return the selected frame.  Always non-null (unless there isn't an
d895 1
a895 1
/* This is a variant of get_selected_frame which can be called when
d897 1
a897 1
   NULL instead of calling error ().  */
d915 1
a915 1
  /* NOTE: cagney/2002-05-04: FI can be NULL.  This occures when the
d921 1
a921 1
     selected_frame_level_changed_event right here, but due to limitations
d923 1
a923 1
     because select_frame is used extensively internally.
d927 1
a927 1
     be called when the users selected frame is being changed. */
d934 1
a934 1
         we cannot use the frame pc as is, because it usually points to
d972 1
a972 1
      /* If nothing's initialized the saved regs, do it now.  */
d989 2
a990 2
	    /* NOTE: cagney/2003-05-09: In-lined store_address with
               it's body - store_unsigned_integer.  */
d1054 1
a1054 1
  /* Not really.  It gets overridden by legacy_get_prev_frame.  */
d1134 2
a1135 2
		    /* NOTE: cagney/2003-05-09: In-line store_address
                       with it's body - store_unsigned_integer.  */
d1288 1
a1288 1
     been here before' check, in get_prev_frame will stop repeated
d1328 1
a1328 1
	 frame_pc_unwind (nee, DEPRECATED_FRAME_SAVED_PC) and
d1458 1
a1458 1
    /* FIXME: 2002-11-09: Frameless functions can occure anywhere in
d1472 1
a1472 1
       edge condition.  Instead the per-architecture code should hande
d1511 1
a1511 1
	     legacy_get_prev_frame, explicitly set the frames type
d1598 1
a1598 1
     special casing the inner-most frame, create fake frame
d1601 1
a1601 1
     That way architecture code can use use the standard
d1616 1
a1616 1
     with it!  Note that FRAME_SAVED_PC() is being superseed by
d1625 1
a1625 1
     tm-sparc.h).  We want the pc saved in the inferior frame. */
d1662 1
a1662 1
  /* If the unwinder provides a frame type, use it.  Otherwize
d1681 2
a1682 2
     create_new_frame and get_prev_frame(), that initializes the
     frames type is subtly different.  The latter only updates ->type
d1696 2
a1697 2
	 be set and then the entire initialization can be skipped.
	 Unforunatly, its the INIT code that sets the PC (Hmm, catch
d1762 1
a1762 1
     the legacy get_prev_frame method.  */
d1890 1
a1890 1
     NOTE: cagney/2003-01-11: I suspect what is happening is
d1892 1
a1892 1
     (registers, memory, ...), still calling this function.  The
d1921 1
a1921 1
     inside_main_func.  Otherwise, we might stop unwinding at a
d1927 1
a1927 1
    /* Don't unwind past main(), bug always unwind the sentinel frame.
d1943 1
a1943 1
     dummy frame PC's typically land in the entry func.  Don't apply
d1948 1
a1948 1
  /* NOTE: cagney/2003-07-07: Fixed a bug in inside_main_func - wasn't
d1951 3
a1953 3
     backtrace in wierd and wonderful ways somewhere inside the entry
     file.  Suspect that deprecated_inside_entry_file and
     inside_entry_func tests were added to work around that (now
d1957 2
a1958 2
     inside_main_func msymbol trick (along with entry_point_address I
     guess) to determine the address range of the start function.
d1976 1
a1976 1
     test to a dummy frame - dummy frame PC's typically land in the
d1981 1
a1981 1
     debug readers (e.g.  dbxread) figure out which object is the
d1987 2
a1988 2
     to deprecated_inside_entry_file destroys a meaningful backtrace
     under some conditions.  E. g. the backtrace tests in the
d1992 3
a1994 3
     on the target).  What happens is, that the first frame is printed
     normaly and following frames are treated as being inside the
     enttry file then.  This way, only the #0 frame is printed in the
d2028 1
a2028 1
     get_frame_type for why ->type can't be used.  */
d2151 1
a2151 1
      /* Initialize the frame's unwinder because it is that which
d2158 1
a2158 1
	 legacy_get_prev_frame, explicitly set the frames type using
d2196 1
a2196 1
     maintaining a locally allocated frame object.  Since such frame's
d2291 1
a2291 1
  /* Normality, an architecture that provides a way of obtaining any
d2296 1
a2296 1
     is a TARGET_READ_SP then that can be used.  */
d2327 1
a2327 1
       get_prev_frame requires these when unwind_frame_id isn't
d2332 1
a2332 1
     uses the new frame mechanism from day one.  Dummy frame's won't
@


1.169
log
@2004-04-02  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame_1): Exclude signal trampolines from the
	"previous frame inner to this frame" test.
@
text
@d1271 1
a1271 1
   INIT_EXTRA_INFO, INIT_FRAME_PC and INIT_FRAME_PC_FIRST.  */
d1307 1
a1307 2
     DEPRECATED_INIT_EXTRA_FRAME_INFO, DEPRECATED_INIT_FRAME_PC,
     DEPRECATED_INIT_FRAME_PC_FIRST and
a1564 4
     We shouldn't need DEPRECATED_INIT_FRAME_PC_FIRST to add more
     complication to an already overcomplicated part of GDB.
     gnu@@cygnus.com, 15Sep92.

a1619 5
  if (DEPRECATED_INIT_FRAME_PC_FIRST_P ())
    deprecated_update_frame_pc_hack (prev,
				     DEPRECATED_INIT_FRAME_PC_FIRST (fromleaf,
								     prev));

a2314 1
      || DEPRECATED_INIT_FRAME_PC_FIRST_P ()
@


1.168
log
@2004-04-02  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (safe_frame_unwind_memory): New function.
	* frame.h (safe_frame_unwind_memory): Declare.  Update description
	of /safe_/ methods.
	* tramp-frame.c (tramp_frame_start): Re-order parmeters, add
	"next_frame".  Use safe_frame_unwind_memory.
	(tramp_frame_sniffer): Update call to tramp_frame_start.
@
text
@d1795 4
a1798 3
     Since the sentinel frame doesn't really exist, don't compare the
     inner-most against that sentinel.  */
  if (this_frame->level > 0
@


1.167
log
@2004-03-31  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (frame_unwind_id): Declare.
	* frame.c (frame_unwind_id): New function.
	(get_prev_frame_1): New function.
	(frame_debug_got_null_frame): New function.
	(get_prev_frame): Use frame_debug_got_null_frame.  Move unwind
	code proper to prev_frame, update description.
	* infrun.c (step_over_function): Use frame_unwind_id.
@
text
@d2273 8
@


1.166
log
@2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PC_IN_SIGTRAMP): Change to a function with
	predicate, deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-linux-tdep.c (alpha_linux_init_abi): Update.
	* alpha-osf1-tdep.c (alpha_osf1_init_abi): Update.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Update.
	* alphafbsd-tdep.c (alphafbsd_init_abi): Update.
	* alphanbsd-tdep.c (alphanbsd_init_abi): Update.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Update.
	* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Update.
	* amd64nbsd-tdep.c (amd64nbsd_init_abi): Update.
	* amd64obsd-tdep.c (amd64obsd_init_abi): Update.
	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Update.
	* blockframe.c (find_pc_partial_function): Update.
	* breakpoint.c (bpstat_what): Update.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update.
	* frv-linux-tdep.c (frv_linux_init_abi): Update.
	* frv-tdep.c (frv_sigtramp_frame_sniffer): Update.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* i386-nto-tdep.c (i386nto_init_abi): Update.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Update.
	* i386-tdep.c (i386_sigtramp_frame_sniffer)
	(i386_svr4_init_abi, i386_go32_init_abi, i386_gdbarch_init): Update.
	* i386bsd-tdep.c (i386bsd_init_abi): Update.
	* i386nbsd-tdep.c (i386nbsd_init_abi): Update.
	* i386obsd-tdep.c (i386obsd_init_abi): Update.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Update.
	* infrun.c (pc_in_sigtramp): Update.
	* m68k-tdep.c (m68k_sigtramp_frame_sniffer): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mipsnbsd-tdep.c (mipsnbsd_init_abi): Update.
	* ppc-linux-tdep.c: Update comment.
	* ppcnbsd-tdep.c (ppcnbsd_init_abi): Update.
	* shnbsd-tdep.c (shnbsd_init_abi): Update.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Update.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Update.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Update.
	* sparcobsd-tdep.c (sparc32obsd_init_abi): Update.

Index: doc/ChangeLog
2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	references to PC_IN_SIGTRAMP.
@
text
@d43 2
d255 10
d1735 5
a1739 8
/* Return a structure containing various interesting information
   about the frame that called THIS_FRAME.  Returns NULL
   if there is no such frame.

   This function tests some target-independent conditions that should
   terminate the frame chain, such as unwinding past main().  It
   should not contain any target-dependent tests, such as checking
   whether the program-counter is zero.  */
d1741 2
a1742 2
struct frame_info *
get_prev_frame (struct frame_info *this_frame)
d1746 117
d1870 1
a1870 1
      fprintf_unfiltered (gdb_stdlog, ") ");
d1872 15
d1920 1
d1941 1
a1941 2
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog, "-> NULL // inside main func }\n");
d1980 1
a1980 6
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, "// inside entry func }\n");
	}
a1983 13
  /* Only try to do the unwind once.  */
  if (this_frame->prev_p)
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, this_frame->prev);
	  fprintf_unfiltered (gdb_stdlog, " // cached \n");
	}
      return this_frame->prev;
    }
  this_frame->prev_p = 1;

d2009 1
a2009 28
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // inside entry file }\n");
	}
      return NULL;
    }

  /* If any of the old frame initialization methods are around, use
     the legacy get_prev_frame method.  */
  if (legacy_frame_p (current_gdbarch))
    {
      prev_frame = legacy_get_prev_frame (this_frame);
      return prev_frame;
    }

  /* Check that this frame's ID was valid.  If it wasn't, don't try to
     unwind to the prev frame.  Be careful to not apply this test to
     the sentinel frame.  */
  if (this_frame->level >= 0 && !frame_id_p (get_frame_id (this_frame)))
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // this ID is NULL }\n");
	}
d2013 1
a2013 61
  /* Check that this frame's ID isn't inner to (younger, below, next)
     the next frame.  This happens when a frame unwind goes backwards.
     Since the sentinel frame doesn't really exist, don't compare the
     inner-most against that sentinel.  */
  if (this_frame->level > 0
      && frame_id_inner (get_frame_id (this_frame),
			 get_frame_id (this_frame->next)))
    error ("Previous frame inner to this frame (corrupt stack?)");

  /* Check that this and the next frame are not identical.  If they
     are, there is most likely a stack cycle.  As with the inner-than
     test above, avoid comparing the inner-most and sentinel frames.  */
  if (this_frame->level > 0
      && frame_id_eq (get_frame_id (this_frame),
		      get_frame_id (this_frame->next)))
    error ("Previous frame identical to this frame (corrupt stack?)");

  /* Allocate the new frame but do not wire it in to the frame chain.
     Some (bad) code in INIT_FRAME_EXTRA_INFO tries to look along
     frame->next to pull some fancy tricks (of course such code is, by
     definition, recursive).  Try to prevent it.

     There is no reason to worry about memory leaks, should the
     remainder of the function fail.  The allocated memory will be
     quickly reclaimed when the frame cache is flushed, and the `we've
     been here before' check above will stop repeated memory
     allocation calls.  */
  prev_frame = FRAME_OBSTACK_ZALLOC (struct frame_info);
  prev_frame->level = this_frame->level + 1;

  /* Don't yet compute ->unwind (and hence ->type).  It is computed
     on-demand in get_frame_type, frame_register_unwind, and
     get_frame_id.  */

  /* Don't yet compute the frame's ID.  It is computed on-demand by
     get_frame_id().  */

  /* The unwound frame ID is validate at the start of this function,
     as part of the logic to decide if that frame should be further
     unwound, and not here while the prev frame is being created.
     Doing this makes it possible for the user to examine a frame that
     has an invalid frame ID.

     Some very old VAX code noted: [...]  For the sake of argument,
     suppose that the stack is somewhat trashed (which is one reason
     that "info frame" exists).  So, return 0 (indicating we don't
     know the address of the arglist) if we don't know what frame this
     frame calls.  */

  /* Link it in.  */
  this_frame->prev = prev_frame;
  prev_frame->next = this_frame;

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, prev_frame);
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }

  return prev_frame;
@


1.165
log
@2004-03-22  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_pc_in_call_dummy): Rename
	generic_pc_in_call_dummy.
	* dummy-frame.h (pc_in_dummy_frame): Delete declaration.
	* dummy-frame.c (deprecated_pc_in_call_dummy): Rename
	generic_pc_in_call_dummy.
	(pc_in_dummy_frame): Make static.
	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Update.
	* gdbarch.h, gdbarch.c: Re-generate.
	* dummy-frame.c (dummy_frame_sniffer): Simplify.
	* frame.c (frame_type_from_pc): Call deprecated_pc_in_call_dummy.
	(legacy_get_prev_frame): Ditto.
	* inferior.h: Delete reference to generic_pc_in_call_dummy in
	comment.
@
text
@d1164 1
a1164 1
      if (PC_IN_SIGTRAMP (pc, name))
d1699 1
a1699 1
      if (PC_IN_SIGTRAMP (get_frame_pc (prev), name))
@


1.164
log
@2004-03-21  Andrew Cagney  <cagney@@redhat.com>

	* frame-unwind.h: Update copyright.
	(struct frame_data): Add opaque declaration.
	(frame_sniffer_ftype): Declare.
	(struct frame_unwind): Add "unwind_data" and "sniffer".
	(frame_unwind_register_unwinder): Declare.
	(frame_unwind_find_by_frame): Add parameter "this_cache".
	* frame.c (get_frame_id, create_new_frame, legacy_get_prev_frame)
	(legacy_get_prev_frame, legacy_get_prev_frame)
	(get_frame_type): Pass the prologue_cache to
	frame_unwind_find_by_frame.
	* frame-unwind.c (struct frame_unwind_table_entry): Add field
	"unwinder".
	(frame_unwind_register_unwinder): New function.
	(frame_unwind_find_by_frame): Handle an unwind sniffer.
@
text
@a1156 4
  /* FIXME: cagney/2002-11-24: Can't yet directly call
     pc_in_dummy_frame() as some architectures don't set
     PC_IN_CALL_DUMMY() to generic_pc_in_call_dummy() (remember the
     latter is implemented by simply calling pc_in_dummy_frame).  */
d1158 1
a1158 1
      && DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0))
d1687 1
a1687 3
      && (DEPRECATED_PC_IN_CALL_DUMMY_P ()
	  ? DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (prev), 0, 0)
	  : pc_in_dummy_frame (get_frame_pc (prev))))
@


1.163
log
@2004-03-17  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (legacy_get_prev_frame): Pass correct frame to
	frame_unwind_find_by_frame.
@
text
@d231 2
a232 1
	  fi->unwind = frame_unwind_find_by_frame (fi->next);
d536 2
a537 1
      frame->unwind = frame_unwind_find_by_frame (frame->next);
d1196 1
a1196 1
  fi->unwind = frame_unwind_find_by_frame (fi->next);
d1349 2
a1350 1
      prev->unwind = frame_unwind_find_by_frame (prev->next);
d1499 2
a1500 1
	  prev->unwind = frame_unwind_find_by_frame (this_frame);
d1661 2
a1662 1
    prev->unwind = frame_unwind_find_by_frame (prev->next);
d2132 2
a2133 1
      frame->unwind = frame_unwind_find_by_frame (frame->next);
@


1.162
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION): Predicate
	and function replacing FRAMELESS_FUNCTION_INVOCATION.
	* blockframe.c (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* frame.h (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	(delta68_frame_args_address): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	(frv_frameless_function_invocation): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	(cris_frameless_function_invocation): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* stack.c (frame_info): Update, call predicate.
	* rs6000-tdep.c (rs6000_frame_chain): Update, call predicate..
	* frame.c (legacy_get_prev_frame): Update, call predicate..
	* arch-utils.c (generic_frameless_function_invocation_not): Delete.
	* arch-utils.h (generic_frameless_function_invocation_not): Delete.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set frameless function
	invocation.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
@
text
@d1496 1
a1496 1
	  prev->unwind = frame_unwind_find_by_frame (this_frame->next);
@


1.162.2.1
log
@Merge mainline to intercu branch.
@
text
@d231 1
a231 2
	  fi->unwind = frame_unwind_find_by_frame (fi->next,
						   &fi->prologue_cache);
d535 1
a535 2
      frame->unwind = frame_unwind_find_by_frame (frame->next,
						  &frame->prologue_cache);
d1155 4
d1160 1
a1160 1
      && deprecated_pc_in_call_dummy (pc, 0, 0))
d1166 1
a1166 1
      if (DEPRECATED_PC_IN_SIGTRAMP (pc, name))
d1194 1
a1194 1
  fi->unwind = frame_unwind_find_by_frame (fi->next, &fi->prologue_cache);
d1347 1
a1347 2
      prev->unwind = frame_unwind_find_by_frame (prev->next,
						 &prev->prologue_cache);
d1496 1
a1496 2
	  prev->unwind = frame_unwind_find_by_frame (this_frame,
						     &prev->prologue_cache);
d1657 1
a1657 2
    prev->unwind = frame_unwind_find_by_frame (prev->next,
					       &prev->prologue_cache);
d1686 3
a1688 1
      && deprecated_pc_in_call_dummy (get_frame_pc (prev), 0, 0))
d1700 1
a1700 1
      if (DEPRECATED_PC_IN_SIGTRAMP (get_frame_pc (prev), name))
d2127 1
a2127 2
      frame->unwind = frame_unwind_find_by_frame (frame->next, 
						  &frame->prologue_cache);
@


1.162.2.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@a42 2
static struct frame_info *get_prev_frame_1 (struct frame_info *this_frame);

a252 10
struct frame_id
frame_unwind_id (struct frame_info *next_frame)
{
  /* Use prev_frame, and not get_prev_frame.  The latter will truncate
     the frame chain, leading to this function unintentionally
     returning a null_frame_id (e.g., when a caller requests the frame
     ID of "main()"s caller.  */
  return get_frame_id (get_prev_frame_1 (next_frame));
}

d1723 8
a1730 2
/* Return a "struct frame_info" corresponding to the frame that called
   THIS_FRAME.  Returns NULL if there is no such frame.
d1732 2
a1733 5
   Unlike get_prev_frame, this function always tries to unwind the
   frame.  */

static struct frame_info *
get_prev_frame_1 (struct frame_info *this_frame)
a1736 2
  gdb_assert (this_frame != NULL);

d1739 1
a1739 1
      fprintf_unfiltered (gdb_stdlog, "{ get_prev_frame_1 (this_frame=");
a1746 130
  /* Only try to do the unwind once.  */
  if (this_frame->prev_p)
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, this_frame->prev);
	  fprintf_unfiltered (gdb_stdlog, " // cached \n");
	}
      return this_frame->prev;
    }
  this_frame->prev_p = 1;

  /* If any of the old frame initialization methods are around, use
     the legacy get_prev_frame method.  */
  if (legacy_frame_p (current_gdbarch))
    {
      prev_frame = legacy_get_prev_frame (this_frame);
      return prev_frame;
    }

  /* Check that this frame's ID was valid.  If it wasn't, don't try to
     unwind to the prev frame.  Be careful to not apply this test to
     the sentinel frame.  */
  if (this_frame->level >= 0 && !frame_id_p (get_frame_id (this_frame)))
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // this ID is NULL }\n");
	}
      return NULL;
    }

  /* Check that this frame's ID isn't inner to (younger, below, next)
     the next frame.  This happens when a frame unwind goes backwards.
     Since the sentinel frame doesn't really exist, don't compare the
     inner-most against that sentinel.  */
  if (this_frame->level > 0
      && frame_id_inner (get_frame_id (this_frame),
			 get_frame_id (this_frame->next)))
    error ("Previous frame inner to this frame (corrupt stack?)");

  /* Check that this and the next frame are not identical.  If they
     are, there is most likely a stack cycle.  As with the inner-than
     test above, avoid comparing the inner-most and sentinel frames.  */
  if (this_frame->level > 0
      && frame_id_eq (get_frame_id (this_frame),
		      get_frame_id (this_frame->next)))
    error ("Previous frame identical to this frame (corrupt stack?)");

  /* Allocate the new frame but do not wire it in to the frame chain.
     Some (bad) code in INIT_FRAME_EXTRA_INFO tries to look along
     frame->next to pull some fancy tricks (of course such code is, by
     definition, recursive).  Try to prevent it.

     There is no reason to worry about memory leaks, should the
     remainder of the function fail.  The allocated memory will be
     quickly reclaimed when the frame cache is flushed, and the `we've
     been here before' check above will stop repeated memory
     allocation calls.  */
  prev_frame = FRAME_OBSTACK_ZALLOC (struct frame_info);
  prev_frame->level = this_frame->level + 1;

  /* Don't yet compute ->unwind (and hence ->type).  It is computed
     on-demand in get_frame_type, frame_register_unwind, and
     get_frame_id.  */

  /* Don't yet compute the frame's ID.  It is computed on-demand by
     get_frame_id().  */

  /* The unwound frame ID is validate at the start of this function,
     as part of the logic to decide if that frame should be further
     unwound, and not here while the prev frame is being created.
     Doing this makes it possible for the user to examine a frame that
     has an invalid frame ID.

     Some very old VAX code noted: [...]  For the sake of argument,
     suppose that the stack is somewhat trashed (which is one reason
     that "info frame" exists).  So, return 0 (indicating we don't
     know the address of the arglist) if we don't know what frame this
     frame calls.  */

  /* Link it in.  */
  this_frame->prev = prev_frame;
  prev_frame->next = this_frame;

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, prev_frame);
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }

  return prev_frame;
}

/* Debug routine to print a NULL frame being returned.  */

static void
frame_debug_got_null_frame (struct ui_file *file,
			    struct frame_info *this_frame,
			    const char *reason)
{
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ get_prev_frame (this_frame=");
      if (this_frame != NULL)
	fprintf_unfiltered (gdb_stdlog, "%d", this_frame->level);
      else
	fprintf_unfiltered (gdb_stdlog, "<NULL>");
      fprintf_unfiltered (gdb_stdlog, ") -> // %s}\n", reason);
    }
}

/* Return a structure containing various interesting information about
   the frame that called THIS_FRAME.  Returns NULL if there is entier
   no such frame or the frame fails any of a set of target-independent
   condition that should terminate the frame chain (e.g., as unwinding
   past main()).

   This function should not contain target-dependent tests, such as
   checking whether the program-counter is zero.  */

struct frame_info *
get_prev_frame (struct frame_info *this_frame)
{
  struct frame_info *prev_frame;

a1778 1
      frame_debug_got_null_frame (gdb_stdlog, this_frame, "this_frame NULL");
d1799 2
a1800 1
      frame_debug_got_null_frame (gdb_stdlog, this_frame, "inside main func");
d1839 6
a1844 1
      frame_debug_got_null_frame (gdb_stdlog, this_frame, "inside entry func");
d1848 13
d1886 28
a1913 1
      frame_debug_got_null_frame (gdb_stdlog, this_frame, "inside entry file");
d1917 61
a1977 1
  return get_prev_frame_1 (this_frame);
@


1.162.2.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a41 2
#include "observer.h"
#include "objfiles.h"
d62 1
a62 1
  /* NOTE: cagney/2002-04-05: Perhaps a level of ``-1'' should be
d68 23
d94 1
a94 1
     selected based on the presence, or otherwise, of register unwind
a140 8
static void
fprint_field (struct ui_file *file, const char *name, int p, CORE_ADDR addr)
{
  if (p)
    fprintf_unfiltered (file, "%s=0x%s", name, paddr_nz (addr));
  else
    fprintf_unfiltered (file, "!%s", name);
}
d145 4
a148 7
  fprintf_unfiltered (file, "{");
  fprint_field (file, "stack", id.stack_addr_p, id.stack_addr);
  fprintf_unfiltered (file, ",");
  fprint_field (file, "code", id.code_addr_p, id.code_addr);
  fprintf_unfiltered (file, ",");
  fprint_field (file, "special", id.special_addr_p, id.special_addr);
  fprintf_unfiltered (file, "}");
d156 3
d186 1
a186 4
  if (fi->unwind != NULL)
    fprint_frame_type (file, fi->unwind->type);
  else
    fprintf_unfiltered (file, "<unknown>");
d226 1
d232 10
a241 2
	fi->unwind = frame_unwind_find_by_frame (fi->next,
						 &fi->prologue_cache);
d271 1
a271 1
  struct frame_id id = null_frame_id;
a272 1
  id.stack_addr_p = 1;
a273 1
  id.code_addr_p = 1;
a274 1
  id.special_addr_p = 1;
d281 1
a281 15
  struct frame_id id = null_frame_id;
  id.stack_addr = stack_addr;
  id.stack_addr_p = 1;
  id.code_addr = code_addr;
  id.code_addr_p = 1;
  return id;
}

struct frame_id
frame_id_build_wild (CORE_ADDR stack_addr)
{
  struct frame_id id = null_frame_id;
  id.stack_addr = stack_addr;
  id.stack_addr_p = 1;
  return id;
d288 2
a289 2
  /* The frame is valid iff it has a valid stack address.  */
  p = l.stack_addr_p;
d303 2
a304 3
  if (!l.stack_addr_p || !r.stack_addr_p)
    /* Like a NaN, if either ID is invalid, the result is false.
       Note that a frame ID is invalid iff it is the null frame ID.  */
d309 2
a310 2
  else if (!l.code_addr_p || !r.code_addr_p)
    /* An invalid code addr is a wild card, always succeed.  */
d315 2
a316 2
  else if (!l.special_addr_p || !r.special_addr_p)
    /* An invalid special addr is a wild card (or unused), always succeed.  */
d339 1
a339 1
  if (!l.stack_addr_p || !r.stack_addr_p)
d380 2
a381 2
      /* Either we're not yet gone far enough out along the frame
         chain (inner(this,id)), or we're comparing frameless functions
d416 1
a416 1
	  /* FIXME: cagney/2003-03-06: Old code and a sentinel
d418 1
a418 1
             directly from the global registers array (via read_pc).
d423 8
d469 1
a469 1
do_frame_register_read (void *src, int regnum, void *buf)
d471 1
a471 1
  frame_register_read (src, regnum, buf);
a474 10
struct regcache *
frame_save_as_regcache (struct frame_info *this_frame)
{
  struct regcache *regcache = regcache_xmalloc (current_gdbarch);
  struct cleanup *cleanups = make_cleanup_regcache_xfree (regcache);
  regcache_save (regcache, do_frame_register_read, this_frame);
  discard_cleanups (cleanups);
  return regcache;
}

d478 2
a479 20
  /* Make a copy of all the register values unwound from this frame.
     Save them in a scratch buffer so that there isn't a race between
     trying to extract the old values from the current_regcache while
     at the same time writing new values into that same cache.  */
  struct regcache *scratch
    = frame_save_as_regcache (get_prev_frame_1 (this_frame));
  struct cleanup *cleanups = make_cleanup_regcache_xfree (scratch);

  /* FIXME: cagney/2003-03-16: It should be possible to tell the
     target's register cache that it is about to be hit with a burst
     register transfer and that the sequence of register writes should
     be batched.  The pair target_prepare_to_store() and
     target_store_registers() kind of suggest this functionality.
     Unfortunately, they don't implement it.  Their lack of a formal
     definition can lead to targets writing back bogus values
     (arguably a bug in the target code mind).  */
  /* Now copy those saved registers into the current regcache.
     Here, regcache_cpy() calls regcache_restore().  */
  regcache_cpy (current_regcache, scratch);
  do_cleanups (cleanups);
d481 30
d541 1
a541 1
     isn't a frame, there is some pretty busted code as it should have
d547 10
a556 2
    frame->unwind = frame_unwind_find_by_frame (frame->next,
						&frame->prologue_cache);
d559 1
a559 1
     "frame-unwind.h" for why NEXT frame and this unwind cache are
d599 27
d656 1
a656 2
  return extract_signed_integer (buf, register_size (get_frame_arch (frame),
						     regnum));
d670 1
a670 2
  return extract_unsigned_integer (buf, register_size (get_frame_arch (frame),
						       regnum));
d685 1
a685 3
  (*val) = extract_unsigned_integer (buf,
				     register_size (get_frame_arch (frame),
						    regnum));
d721 2
a722 1
   The number of bytes copied is REGISTER_SIZE (REGNUM).
d735 1
a735 1
  /* FIXME: cagney/2002-05-15: This test is just bogus.
d771 1
d813 14
d836 1
a836 1
  /* A sentinel frame can fail to unwind, e.g., because its PC value
d878 1
a878 1
/* Return the selected frame.  Always non-NULL (unless there isn't an
d895 1
a895 1
/* This is a variant of get_selected_frame() which can be called when
d897 1
a897 1
   NULL instead of calling error().  */
d915 1
a915 1
  /* NOTE: cagney/2002-05-04: FI can be NULL.  This occurs when the
d917 2
a918 2
  if (deprecated_selected_frame_level_changed_hook)
    deprecated_selected_frame_level_changed_hook (frame_relative_level (fi));
d921 1
a921 1
     selected_frame_level_changed_event() right here, but due to limitations
d923 1
a923 1
     because select_frame() is used extensively internally.
d927 1
a927 1
     be called when the user's selected frame is being changed. */
d934 1
a934 1
         we cannot use the frame PC as-is, because it usually points to
d949 103
d1053 130
d1205 4
d1214 3
a1239 8
/* Observer for the target_changed event.  */

void
frame_observer_target_changed (struct target_ops *target)
{
  flush_cached_frames ();
}

d1270 465
a1744 1
  struct frame_id this_id;
d1771 8
d1782 1
a1782 2
  this_id = get_frame_id (this_frame);
  if (this_frame->level >= 0 && !frame_id_p (this_id))
d1795 5
a1799 5
     Exclude signal trampolines (due to sigaltstack the frame ID can
     go backwards) and sentinel frames (the test is meaningless).  */
  if (this_frame->next->level >= 0
      && this_frame->next->unwind->type != SIGTRAMP_FRAME
      && frame_id_inner (this_id, get_frame_id (this_frame->next)))
d1806 2
a1807 1
      && frame_id_eq (this_id, get_frame_id (this_frame->next)))
a1873 21
/* Is this (non-sentinel) frame in the "main"() function?  */

static int
inside_main_func (struct frame_info *this_frame)
{
  struct minimal_symbol *msymbol;
  CORE_ADDR maddr;

  if (symfile_objfile == 0)
    return 0;
  msymbol = lookup_minimal_symbol (main_name (), NULL, symfile_objfile);
  if (msymbol == NULL)
    return 0;
  /* Make certain that the code, and not descriptor, address is
     returned.  */
  maddr = gdbarch_convert_from_func_ptr_addr (current_gdbarch,
					      SYMBOL_VALUE_ADDRESS (msymbol),
					      &current_target);
  return maddr == get_frame_func (this_frame);
}

d1899 1
a1899 1
     NOTE: cagney/2003-01-11: I suspect what is happening in
d1901 1
a1901 1
     (registers, memory, ...), it is still calling this function.  The
d1929 4
d1935 5
a1939 5
      && inside_main_func (this_frame))
    /* Don't unwind past main().  Note, this is done _before_ the
       frame has been marked as previously unwound.  That way if the
       user later decides to enable unwinds past main(), that will
       automatically happen.  */
d1952 1
a1952 1
     dummy frame PCs typically land in the entry func.  Don't apply
d1957 7
a1963 6
  /* NOTE: cagney/2003-07-07: Fixed a bug in inside_main_func() -
     wasn't checking for "main" in the minimal symbols.  With that
     fixed asm-source tests now stop in "main" instead of halting the
     backtrace in weird and wonderful ways somewhere inside the entry
     file.  Suspect that tests for inside the entry file/func were
     added to work around that (now fixed) case.  */
d1966 2
a1967 2
     inside_main_func() msymbol trick (along with entry_point_address()
     I guess) to determine the address range of the start function.
d1977 1
a1977 1
      && this_frame->unwind->type != DUMMY_FRAME && this_frame->level >= 0
d1984 29
d2037 1
a2037 1
     get_frame_type() for why ->type can't be used.  */
d2148 47
a2194 6
  if (frame->unwind == NULL)
    /* Initialize the frame's unwinder because that's what
       provides the frame's type.  */
    frame->unwind = frame_unwind_find_by_frame (frame->next, 
						&frame->prologue_cache);
  return frame->unwind->type;
d2205 1
a2205 1
     maintaining a locally allocated frame object.  Since such frames
d2229 21
a2272 8
int
safe_frame_unwind_memory (struct frame_info *this_frame,
			  CORE_ADDR addr, void *buf, int len)
{
  /* NOTE: deprecated_read_memory_nobpt returns zero on success!  */
  return !deprecated_read_memory_nobpt (addr, buf, len);
}

d2292 1
a2292 1
  /* Normality - an architecture that provides a way of obtaining any
d2297 1
a2297 1
     is a TARGET_READ_SP, then that can be used.  */
d2311 28
a2360 2
  observer_attach_target_changed (frame_observer_target_changed);

d2374 1
a2374 2
Set whether backtraces should continue past \"main\".", "\
Show whether backtraces should continue past \"main\".", "\
d2378 4
a2381 1
Whether backtraces should continue past \"main\" is %s.",
d2387 1
a2387 2
Set an upper bound on the number of backtrace levels.", "\
Show the upper bound on the number of backtrace levels.", "\
d2390 1
a2390 1
An upper bound on the number of backtrace levels is %s.",
d2395 2
a2396 3
  deprecated_add_show_from_set
    (add_set_cmd ("frame", class_maintenance, var_zinteger,
		  &frame_debug, "Set frame debugging.\n\
d2398 1
a2398 1
     &showdebuglist);
@


1.162.6.1
log
@Jumbo patch.  Experiments with tramp-frame.
@
text
@d240 1
a240 2
      fi->unwind->this_id (fi->unwind, fi->next, &fi->prologue_cache,
			   &fi->this_id.value);
d432 1
a432 1
frame_unwind_func_by_symtab (struct frame_info *fi)
a449 6
frame_func_unwind (struct frame_info *fi)
{
  return frame_unwind_func_by_symtab (fi);
}

CORE_ADDR
d547 1
a547 2
  frame->unwind->prev_register (frame->unwind, frame->next,
				&frame->prologue_cache, regnum,
d941 1
a941 2
legacy_saved_regs_prev_register (const struct frame_unwind *self,
				 struct frame_info *next_frame,
d1027 1
a1027 2
legacy_saved_regs_this_id (const struct frame_unwind *self,
			   struct frame_info *next_frame,
d1447 1
a1447 2
  if (this_frame->level == 0
      && this_frame->unwind->type == UNKNOWN_FRAME)
d1488 1
a1488 2
      if (DEPRECATED_FRAME_CHAIN_P ()
	  && this_frame->unwind->type == UNKNOWN_FRAME)
d1504 1
a1504 1
	  prev->unwind->this_id (prev->unwind, this_frame,
d1659 3
a1661 4
  /* If the unwinder provides a frame type (i.e., is a new style
     unwinder), use it.  Otherwize continue on to that heuristic
     mess.  */
  switch (prev->unwind->type)
a1662 14
    case SIGTRAMP_FRAME:
      prev->type = prev->unwind->type;
      prev->unwind->this_id (prev->unwind, prev->next,
			     &prev->prologue_cache,
			     &prev->this_id.value);
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, prev);
	  fprintf_unfiltered (gdb_stdlog, " } // legacy with sigtramp type\n");
	}
      return prev;
    case DUMMY_FRAME:
    case NORMAL_FRAME:
a1674 4
    case UNKNOWN_FRAME:
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
d2058 2
a2059 2
    return fi->base->this_base (fi->base, fi->next, &fi->prologue_cache);
  return fi->base->this_base (fi->base, fi->next, &fi->base_cache);
d2077 1
a2077 1
  return fi->base->this_locals (fi->base, fi->next, cache);
d2095 1
a2095 1
  return fi->base->this_args (fi->base, fi->next, cache);
@


1.162.6.2
log
@Dump of tramp-frame stuff.
@
text
@d231 1
a231 2
	  fi->unwind = frame_unwind_find_by_frame (fi->next,
						   &fi->prologue_cache);
d433 1
a433 1
frame_func_unwind (struct frame_info *fi)
d451 6
d542 1
a542 2
      frame->unwind = frame_unwind_find_by_frame (frame->next,
						  &frame->prologue_cache);
d1204 1
a1204 1
  fi->unwind = frame_unwind_find_by_frame (fi->next, &fi->prologue_cache);
d1357 1
a1357 2
      prev->unwind = frame_unwind_find_by_frame (prev->next,
						 &prev->prologue_cache);
d1457 2
a1458 1
  if (this_frame->level == 0)
d1499 2
a1500 1
      if (DEPRECATED_FRAME_CHAIN_P ())
d1508 1
a1508 2
	  prev->unwind = frame_unwind_find_by_frame (this_frame->next,
						     &prev->prologue_cache);
d1669 1
a1669 2
    prev->unwind = frame_unwind_find_by_frame (prev->next,
					       &prev->prologue_cache);
d1671 4
a1674 3
  /* If the unwinder provides a frame type, use it.  Otherwize
     continue on to that heuristic mess.  */
  if (prev->unwind->type != UNKNOWN_FRAME)
d1676 14
d1702 4
d2158 1
a2158 2
      frame->unwind = frame_unwind_find_by_frame (frame->next,
						  &frame->prologue_cache);
@


1.162.6.3
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d241 2
a242 1
      fi->unwind->this_id (fi->next, &fi->prologue_cache, &fi->this_id.value);
d550 2
a551 1
  frame->unwind->prev_register (frame->next, &frame->prologue_cache, regnum,
d945 2
a946 1
legacy_saved_regs_prev_register (struct frame_info *next_frame,
d1032 2
a1033 1
legacy_saved_regs_this_id (struct frame_info *next_frame,
d1503 1
a1503 1
	  prev->unwind = frame_unwind_find_by_frame (this_frame,
d1512 1
a1512 1
	  prev->unwind->this_id (this_frame,
d2063 1
a2063 2
    fi->base = frame_base_find_by_frame (fi->next, &fi->base_cache,
					 fi->unwind, &fi->prologue_cache);
d2067 2
a2068 2
    return fi->base->this_base (fi->next, &fi->prologue_cache);
  return fi->base->this_base (fi->next, &fi->base_cache);
d2079 1
a2079 2
    fi->base = frame_base_find_by_frame (fi->next, &fi->base_cache,
					 fi->unwind, &fi->prologue_cache);
d2086 1
a2086 1
  return fi->base->this_locals (fi->next, cache);
d2097 1
a2097 2
    fi->base = frame_base_find_by_frame (fi->next, &fi->base_cache,
					 fi->unwind, &fi->prologue_cache);
d2104 1
a2104 1
  return fi->base->this_args (fi->next, cache);
d2136 1
a2136 1
      frame->unwind = frame_unwind_find_by_frame (frame->next, 
@


1.162.6.4
log
@Final tramp-frame code.
@
text
@d2059 2
a2060 1
    fi->base = frame_base_find_by_frame (fi->next);
d2076 2
a2077 1
    fi->base = frame_base_find_by_frame (fi->next);
d2095 2
a2096 1
    fi->base = frame_base_find_by_frame (fi->next);
@


1.161
log
@2004-02-14  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED): Delete.
	(DEPRECATED_CALL_DUMMY_STACK_ADJUST): Delete.
	(DEPRECATED_CALL_DUMMY_ADDRESS): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (deprecated_get_next_frame_hack): Delete function.
	* frame.h (deprecated_get_next_frame_hack): Delete declaration.
	* blockframe.c (deprecated_pc_in_call_dummy_at_entry_point):
	Update.
	* infcall.c (call_function_by_hand): Update.

Index: doc/ChangeLog
2004-02-14  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	description of DEPRECATED_CALL_DUMMY_STACK_ADJUST.
@
text
@d1452 2
a1453 1
    fromleaf = FRAMELESS_FUNCTION_INVOCATION (this_frame);
@


1.160
log
@Fix obvious typo (completly -> completely) and update copyrights as needed
@
text
@a1229 6
struct frame_info *
deprecated_get_next_frame_hack (struct frame_info *this_frame)
{
  return this_frame->next;
}

@


1.159
log
@2004-02-08  Andrew Cagney  <cagney@@redhat.com>

	* frame.c: Print both the register number and name.
@
text
@d1289 1
a1289 1
  /* Do not completly wire it in to the frame chain.  Some (bad) code
@


1.158
log
@2004-02-08  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (legacy_saved_regs_this_id): Return a null frame ID.
	(get_frame_id): Allow the UNKNOWN_FRAME.
	(frame_register_unwind, get_frame_type): Ditto.
@
text
@d512 4
a515 3
      fprintf_unfiltered (gdb_stdlog,
			  "{ frame_register_unwind (frame=%d,regnum=\"%s\",...) ",
			  frame->level, frame_map_regnum_to_name (frame, regnum));
@


1.157
log
@2004-02-08  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (legacy_frame_p): Check for DEPRECATED_TARGET_READ_FP_P
	and DEPRECATED_FP_REGNUM.  Don't assume that the lack of
	unwind_dummy_id indicates a legacy frame.
@
text
@a236 1
	  gdb_assert (fi->unwind->type != UNKNOWN_FRAME);
a539 1
      gdb_assert (frame->unwind->type != UNKNOWN_FRAME);
d1030 6
a1035 3
  /* legacy_get_prev_frame() always sets ->this_id.p, hence this is
     never needed.  */
  internal_error (__FILE__, __LINE__, "legacy_saved_regs_this_id() called");
a2136 1
      gdb_assert (frame->unwind->type != UNKNOWN_FRAME);
@


1.156
log
@	* objfiles.h: Delete comments refering to inside_entry_func and
	DEPRECATED_FRAME_CHAIN_VALID.
	* defs.h (inside_entry_func): Update prototype..
	* blockframe.c (inside_entry_func): Rename to
	legacy_inside_entry_func.  Add new inside_entry_func taking a frame.
	* frame.c (get_prev_frame): Pass the frame to inside_entry_func.
@
text
@d2283 22
a2304 5
  return (DEPRECATED_INIT_FRAME_PC_P ()
	  || DEPRECATED_INIT_FRAME_PC_FIRST_P ()
	  || DEPRECATED_INIT_EXTRA_FRAME_INFO_P ()
	  || DEPRECATED_FRAME_CHAIN_P ()
	  || !gdbarch_unwind_dummy_id_p (current_gdbarch));
@


1.155
log
@* frame.c: Update copyright year.
(get_prev_frame): Improve comment.
@
text
@d1841 1
a1841 1
      && inside_entry_func (get_frame_pc (this_frame)))
@


1.154
log
@* frame.c (get_prev_frame): Don't try to unwind the PC.  This
fixes PR backtrace/1476.
@
text
@d4 1
a4 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d1729 6
a1734 1
   if there is no such frame.  */
@


1.153
log
@        * frame.c (select_frame): Get the current frame PC using
        get_frame_address_in_block() instead of get_frame_pc().
        * stack.c (get_frame_language): Likewise.
@
text
@a1945 31
  /* Try to unwind the PC.  If that doesn't work, assume we've reached
     the oldest frame and simply return.  Is there a better sentinal
     value?  The unwound PC value is then used to initialize the new
     previous frame's type.

     Note that the pc-unwind is intentionally performed before the
     frame chain.  This is ok since, for old targets, both
     frame_pc_unwind (nee, FRAME_SAVED_PC) and
     DEPRECATED_FRAME_CHAIN()) assume THIS_FRAME's data structures
     have already been initialized (using
     DEPRECATED_INIT_EXTRA_FRAME_INFO) and hence the call order
     doesn't matter.

     By unwinding the PC first, it becomes possible to, in the case of
     a dummy frame, avoid also unwinding the frame ID.  This is
     because (well ignoring the PPC) a dummy frame can be located
     using THIS_FRAME's frame ID.  */

  if (frame_pc_unwind (this_frame) == 0)
    {
      /* The allocated PREV_FRAME will be reclaimed when the frame
	 obstack is next purged.  */
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // unwound PC zero }\n");
	}
      return NULL;
    }

@


1.152
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_unwind_signed_register): Delete function.
	* frame.h (frame_unwind_register_signed): Delete declaration.
	* mips-tdep.c (mips_frame_saved_pc): Use frame_unwind_register_signed.
@
text
@d920 7
a926 1
      s = find_pc_symtab (get_frame_pc (fi));
@


1.151
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_frame_xmalloc): Delete function.
	(deprecated_set_frame_extra_info_hack): Delete function.
	(deprecated_set_frame_saved_regs_hack): Delete function.
	* frame.h (deprecated_frame_xmalloc): Delete declaration.
	(deprecated_set_frame_extra_info_hack): Delete declaration.
	(deprecated_set_frame_saved_regs_hack): Delete declaration.
	* mcore-tdep.c (analyze_dummy_frame): Instead of
	deprecated_frame_xmalloc, deprecated_set_frame_saved_regs_hack,
	and deprecated_set_frame_extra_info_hack use
	deprecated_frame_xmalloc_with_cleanup.
	* mn10300-tdep.c (analyze_dummy_frame): Ditto.
	* mips-tdep.c (mips_init_extra_frame_info): Delete call to
	deprecated_set_frame_saved_regs_hack.
@
text
@a666 9
frame_unwind_signed_register (struct frame_info *frame, int regnum,
			      LONGEST *val)
{
  char buf[MAX_REGISTER_SIZE];
  frame_unwind_register (frame, regnum, buf);
  (*val) = extract_signed_integer (buf, DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
}

void
@


1.150
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_set_frame_next_hack): Delete declaration.
	(deprecated_set_frame_prev_hack): Delete declaration.
	* frame.c (deprecated_set_frame_next_hack): Delete function.
	(deprecated_set_frame_prev_hack): Delete function.
	* mcore-tdep.c (analyze_dummy_frame): Delete calls to
	"deprecated_set_frame_next_hack" and
	"deprecated_set_frame_prev_hack".
	* mn10300-tdep.c (analyze_dummy_frame): Ditto.
@
text
@a2225 14
void
deprecated_set_frame_saved_regs_hack (struct frame_info *frame,
				      CORE_ADDR *saved_regs)
{
  frame->saved_regs = saved_regs;
}

void
deprecated_set_frame_extra_info_hack (struct frame_info *frame,
				      struct frame_extra_info *extra_info)
{
  frame->extra_info = extra_info;
}

d2227 2
a2228 1
deprecated_frame_xmalloc (void)
a2232 8
  return frame;
}

struct frame_info *
deprecated_frame_xmalloc_with_cleanup (long sizeof_saved_regs,
				       long sizeof_extra_info)
{
  struct frame_info *frame = deprecated_frame_xmalloc ();
@


1.149
log
@2003-11-22  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_get_frame_context): Delete function.
	(deprecated_set_frame_prev_hack): Delete function.
	(struct frame_info): Delete member "context".
	* frame.h (deprecated_get_frame_context): Delete declaration.
	(deprecated_set_frame_context): Delete declaration.
@
text
@a2239 7
void
deprecated_set_frame_next_hack (struct frame_info *fi,
				struct frame_info *next)
{
  fi->next = next;
}

@


1.148
log
@* frame.c (get_prev_frame): Use result from
get_frame_address_in_block instead of get_frame_pc as argument to
inside_main_func.  Fixes PR backtrace/1435.
@
text
@a88 4
  /* If dwarf2 unwind frame informations is used, this structure holds
     all related unwind data.  */
  struct context *context;

a2244 20
}

void
deprecated_set_frame_prev_hack (struct frame_info *fi,
				struct frame_info *prev)
{
  fi->prev = prev;
}

struct context *
deprecated_get_frame_context (struct frame_info *fi)
{
  return fi->context;
}

void
deprecated_set_frame_context (struct frame_info *fi,
			      struct context *context)
{
  fi->context = context;
@


1.147
log
@Index: mi/ChangeLog
2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* tui-out.c: Fix "fortunatly"[sic].

Index: doc/ChangeLog
2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* annotate.texinfo: Fix "fortunatly"[sic].

2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* osabi.c (gdbarch_init_osabi): Fix typos, and "fortunatly"[sic].
	* PROBLEMS, arch-utils.c, cli-out.c, command.h: Ditto.
	* complaints.c, cris-tdep.c, disasm.c, dwarf2-frame.c: Ditto.
	* frame.c, frame.h, infcall.c, infcmd.c, infrun.c: Ditto.
	* kod.c, mips-tdep.c, regcache.c, regcache.h, remote.c: Ditto.
@
text
@d1793 4
d1799 1
a1799 1
      && inside_main_func (get_frame_pc (this_frame)))
@


1.146
log
@
2003-10-17  Jeff Johnston  <jjohnstn@@redhat.com>

        * frame.h (struct frame_id): Add new field: special_addr.
        (frame_id_build_special): New prototype.
        * frame.c (frame_id_build_special): New function.
        (frame_id_build): Change to call frame_id_build_special().
        (frame_id_eq): Change to also test special_addr field.
        (frame_id_inner): Update comment.
@
text
@d68 1
a68 1
     ->unwind->type.  Unfortunatly, legacy code is still explicitly
d238 1
a238 1
	     directly.  Unfortunatly, legacy code, called by
d495 1
a495 1
         functionality.  Unfortunatly, they don't implement it.  Their
d542 1
a542 1
	 directly.  Unfortunatly, legacy code, called by
d956 1
a956 1
     Unfortunatly, old code expects this frame.  Since this is a
d1312 1
a1312 1
     Unfortunatly those same work-arounds rely on the type defaulting
d1422 1
a1422 1
	 info.  Unfortunatly legacy targets can't use
d1509 1
a1509 1
	     directly.  Unfortunatly, legacy code, called by
d2162 1
a2162 1
	 directly.  Unfortunatly, legacy code, called by
@


1.145
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d147 1
a147 1
  fprintf_unfiltered (file, "{stack=0x%s,code=0x%s}",
d149 2
a150 1
		      paddr_nz (id.code_addr));
d260 2
a261 1
frame_id_build (CORE_ADDR stack_addr, CORE_ADDR code_addr)
d266 1
d270 6
d304 8
a311 2
  else if (l.code_addr == r.code_addr)
    /* The .stack and .code are identical, the ID's are identical.  */
d338 1
a338 1
       different .code).  */
@


1.144
log
@2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_VIRTUAL_SIZE to
	DEPRECATED_REGISTER_VIRTUAL_SIZE.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_VIRTUAL_SIZE): Rename
	REGISTER_VIRTUAL_SIZE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* vax-tdep.h, sparc-tdep.c, regcache.h: Update.
	* regcache.c, mn10300-tdep.c, mips-tdep.c: Update.
	* infcmd.c, frame.c, findvar.c, cris-tdep.c: Update.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_VIRTUAL_SIZE to DEPRECATED_REGISTER_VIRTUAL_SIZE.
	(Target Architecture Definition):
@
text
@d706 2
a707 1
   The number of bytes copied is REGISTER_RAW_SIZE (REGNUM).
d970 1
a970 1
	    store_unsigned_integer (bufferp, REGISTER_RAW_SIZE (regnum),
d997 1
a997 1
		    = frame_obstack_zalloc (REGISTER_RAW_SIZE (regnum));
d999 1
a999 1
			       REGISTER_RAW_SIZE (regnum));
d1001 1
a1001 1
	      memcpy (bufferp, regs[regnum], REGISTER_RAW_SIZE (regnum));
d1005 1
a1005 1
			   REGISTER_RAW_SIZE (regnum));
d1113 1
a1113 1
					    REGISTER_RAW_SIZE (regnum),
d1122 1
a1122 1
				 REGISTER_RAW_SIZE (regnum));
@


1.143
log
@2003-09-28  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_read_unsigned_register): Delete function.
	* frame.h (frame_read_unsigned_register): Delete declaration.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	get_frame_register_unsigned.
	(sparc_frame_saved_pc, sparc_pop_frame): Ditto.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.h (frame_read_register): Delete declaration.
	* frame.c (frame_read_register): Delete function.
	* arch-utils.c (legacy_register_to_value): Use get_frame_register.
	* sparc-tdep.c (sparc_fetch_pointer_argument): Ditto.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* hppa-tdep.c (hppa_fetch_pointer_argument): Ditto.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.

	* frame.c (frame_read_signed_register): Delete function.
	(frame_read_unsigned_register): Update comments.
	* frame.h (frame_read_signed_register): Delete declaration.
	* h8300-tdep.c (h8300_print_register): Use
	get_frame_register_signed.
	* m68hc11-tdep.c (m68hc11_print_register): Ditto.
@
text
@d632 1
a632 1
  return extract_signed_integer (buf, REGISTER_VIRTUAL_SIZE (regnum));
d646 1
a646 1
  return extract_unsigned_integer (buf, REGISTER_VIRTUAL_SIZE (regnum));
d661 1
a661 1
  (*val) = extract_signed_integer (buf, REGISTER_VIRTUAL_SIZE (regnum));
d670 1
a670 1
  (*val) = extract_unsigned_integer (buf, REGISTER_VIRTUAL_SIZE (regnum));
@


1.142
log
@2003-09-25  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_frame_saved_regs): Rename
	get_frame_saved_regs.
	* cris-tdep.c, frame.c, h8300-tdep.c, hppa-tdep.c: Update.
	* mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, ppc-linux-tdep.c, rs6000-tdep.c: Update.
	* s390-tdep.c, sh64-tdep.c, stack.c: Update.
	* v850-tdep.c, vax-tdep.c, xstormy16-tdep.c: Update.
@
text
@a673 41
frame_read_register (struct frame_info *frame, int regnum, void *buf)
{
  gdb_assert (frame != NULL && frame->next != NULL);
  frame_unwind_register (frame->next, regnum, buf);
}

void
frame_read_unsigned_register (struct frame_info *frame, int regnum,
			      ULONGEST *val)
{
  /* NOTE: cagney/2002-10-31: There is a bit of dogma here - there is
     always a frame.  Both this, and the equivalent
     frame_read_signed_register() function, can only be called with a
     valid frame.  If, for some reason, this function is called
     without a frame then the problem isn't here, but rather in the
     caller.  It should of first created a frame and then passed that
     in.  */
  /* NOTE: cagney/2002-10-31: As a side bar, keep in mind that the
     ``current_frame'' should not be treated as a special case.  While
     ``get_next_frame (current_frame) == NULL'' currently holds, it
     should, as far as possible, not be relied upon.  In the future,
     ``get_next_frame (current_frame)'' may instead simply return a
     normal frame object that simply always gets register values from
     the register cache.  Consequently, frame code should try to avoid
     tests like ``if get_next_frame() == NULL'' and instead just rely
     on recursive frame calls (like the below code) when manipulating
     a frame chain.  */
  gdb_assert (frame != NULL && frame->next != NULL);
  frame_unwind_unsigned_register (frame->next, regnum, val);
}

void
frame_read_signed_register (struct frame_info *frame, int regnum,
			    LONGEST *val)
{
  /* See note above in frame_read_unsigned_register().  */
  gdb_assert (frame != NULL && frame->next != NULL);
  frame_unwind_signed_register (frame->next, regnum, val);
}

void
@


1.141
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@d847 1
a847 1
get_frame_saved_regs (struct frame_info *fi)
d989 1
a989 1
  if (get_frame_saved_regs (frame) == NULL)
d994 1
a994 1
      gdb_assert (get_frame_saved_regs (frame) != NULL);
d997 2
a998 2
  if (get_frame_saved_regs (frame) != NULL
      && get_frame_saved_regs (frame)[regnum] != 0)
d1011 1
a1011 1
				    get_frame_saved_regs (frame)[regnum]);
d1019 1
a1019 1
	  *addrp = get_frame_saved_regs (frame)[regnum];
d1038 1
a1038 1
		  read_memory (get_frame_saved_regs (frame)[regnum], regs[regnum],
d1044 1
a1044 1
	      read_memory (get_frame_saved_regs (frame)[regnum], bufferp,
d1142 2
a1143 2
	  if (get_frame_saved_regs (frame) != NULL
	      && get_frame_saved_regs (frame)[regnum] != 0)
d1154 1
a1154 1
					    get_frame_saved_regs (frame)[regnum]);
d1159 1
a1159 1
		    *addrp = get_frame_saved_regs (frame)[regnum];
d1161 1
a1161 1
		    read_memory (get_frame_saved_regs (frame)[regnum], raw_buffer,
@


1.140
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d1092 3
a1094 3
   Set *ADDRP to the address, either in memory or as a REGISTER_BYTE
   offset into the registers array.  If the value is stored in a dummy
   frame, set *ADDRP to zero.
d1175 1
a1175 1
    *addrp = REGISTER_BYTE (regnum);
@


1.139
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d937 1
a937 1
  register struct symtab *s;
@


1.138
log
@	* frame.c (deprecated_safe_get_selected_frame): New function.
	* frame.h (deprecated_safe_get_selected_frame): Add prototype.
	* findvar.c (read_var_value): Call it.
@
text
@d1847 3
a1849 2
     file.  Suspect that inside_entry_file and inside_entry_func tests
     were added to work around that (now fixed) case.  */
a1887 1
#if 0
d1899 13
a1911 11
  /* NOTE: vinschen/2003-04-01: Disabled.  It turns out that the call to
     inside_entry_file destroys a meaningful backtrace under some
     conditions.  E. g. the backtrace tests in the asm-source testcase
     are broken for some targets.  In this test the functions are all
     implemented as part of one file and the testcase is not necessarily
     linked with a start file (depending on the target).  What happens is,
     that the first frame is printed normaly and following frames are
     treated as being inside the enttry file then.  This way, only the
     #0 frame is printed in the backtrace output.  */
  if (this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && inside_entry_file (get_frame_pc (this_frame)))
a1920 1
#endif
@


1.137
log
@2003-08-12  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_frame_xmalloc): Use XMALLOC, instead of
	FRAME_OBSTACK_ZALLOC.
@
text
@d920 12
@


1.136
log
@* frame.c (_initialize_frame): Add missing backslash.
@
text
@d2282 2
a2283 1
  struct frame_info *frame = FRAME_OBSTACK_ZALLOC (struct frame_info);
@


1.135
log
@2003-08-09  Andrew Cagney  <cagney@@redhat.com>

	Fix GDB PR cli/926.
	* cli/cli-decode.c (add_setshow_uinteger_cmd): New function.
	* command.h (add_setshow_uinteger_cmd): Declare.
	* frame.c (set_backtrace_cmd): New function.
	(show_backtrace_cmd): New function.
	* frame.c (_initialize_frame): Replace "set/show
	backtrace-below-main" with "set/show backtrace past-main".  Add
	command "set/show backtrace limit".
	(backtrace_past_main): Rename "backtrace_below_main".
	(backtrace_limit): New variable.
	(get_prev_frame): Update.  Check the backtrace_limit.

2003-08-09  Andrew Cagney  <cagney@@redhat.com>

	* gdb.texinfo (Backtrace): Replace "set/show backtrace-below-main"
	with "set/show backtrace past-main" and "set/show backtrace
	limit".

Index: doc/gdb.texinfo
===================================================================
RCS file: /cvs/src/src/gdb/doc/gdb.texinfo,v
retrieving revision 1.174
diff -u -r1.174 gdb.texinfo
--- doc/gdb.texinfo	8 Aug 2003 01:58:00 -0000	1.174
+++ doc/gdb.texinfo	9 Aug 2003 14:57:10 -0000
@@@@ -3922,27 +3922,40 @@@@
 value, indicating that your program has stopped at the beginning of the
 code for line @@code{993} of @@code{builtin.c}.

-@@kindex set backtrace-below-main
-@@kindex show backtrace-below-main
+@@kindex set backtrace past-main
+@@kindex show backtrace past-main
+@@kindex set backtrace limit
+@@kindex show backtrace limit

-Most programs have a standard entry point---a place where system libraries
-and startup code transition into user code.  For C this is @@code{main}.
-When @@value{GDBN} finds the entry function in a backtrace it will terminate
-the backtrace, to avoid tracing into highly system-specific (and generally
-uninteresting) code.  If you need to examine the startup code, then you can
-change this behavior.
+Most programs have a standard user entry point---a place where system
+libraries and startup code transition into user code.  For C this is
+@@code{main}.  When @@value{GDBN} finds the entry function in a backtrace
+it will terminate the backtrace, to avoid tracing into highly
+system-specific (and generally uninteresting) code.
+
+If you need to examine the startup code, or limit the number of levels
+in a backtrace, you can change this behavior:

 @@table @@code
-@@item set backtrace-below-main off
+@@item set backtrace past-main
+@@itemx set backtrace past-main on
+Backtraces will continue past the user entry point.
+
+@@item set backtrace past-main off
 Backtraces will stop when they encounter the user entry point.  This is the
 default.

-@@item set backtrace-below-main
-@@itemx set backtrace-below-main on
-Backtraces will continue past the user entry point to the top of the stack.
+@@item show backtrace past-main
+Display the current user entry point backtrace policy.
+
+@@item set backtrace limit @@var{n}
+@@itemx set backtrace limit 0
+@@cindex backtrace limit
+Limit the backtrace to @@var{n} levels.  A value of zero means
+unlimited.

-@@item show backtrace-below-main
-Display the current backtrace policy.
+@@item show backtrace limit
+Display the current limit on backtrace levels.
 @@end table

 @@node Selection
@
text
@d2427 1
a2427 1
No more than the specified number of frames can be displayed or examined.\n
@


1.134
log
@2003-08-04  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_func_unwind): Use frame_unwind_address_in_block.
@
text
@d138 4
a141 1
/* Flag to indicate whether backtraces should stop at main.  */
a142 1
static int backtrace_below_main;
d1807 1
a1807 1
      && !backtrace_below_main
d1819 5
d2380 15
d2400 10
a2409 4
  /* FIXME: cagney/2003-01-19: This command needs a rename.  Suggest
     `set backtrace {past,beyond,...}-main'.  Also suggest adding `set
     backtrace ...-start' to control backtraces past start.  The
     problem with `below' is that it stops the `up' command.  */
d2411 2
a2412 2
  add_setshow_boolean_cmd ("backtrace-below-main", class_obscure,
			   &backtrace_below_main, "\
d2421 2
a2422 1
			   NULL, NULL, &setlist, &showlist);
d2424 8
@


1.133
log
@2003-07-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_frame_id): Use frame_unwind_find_by_frame.
	(frame_register_unwind, create_new_frame): Ditto.
	(legacy_get_prev_frame, get_frame_type): Ditto.
	(get_frame_base_address): Use frame_base_find_by_frame.
	(get_frame_locals_address): Use frame_base_find_by_frame.
	(get_frame_args_address): Use frame_base_find_by_frame.
	* frame-base.h (frame_base_sniffer_ftype): Declare.
	(frame_base_append_sniffer): Declare.
	(frame_base_find_by_frame): Replace frame_base_find_by_pc.
	* frame-base.c (append_predicate): Add a "sniffer" parameter.
	(frame_base_append_sniffer): New function.
	(frame_base_append_predicate): Add a NULL sniffer.
	(frame_base_find_by_frame): Replace "frame_base_find_by_pc".
	(struct frame_base_table): Add "sniffer".
	(frame_base_free): Free the "sniffer" table.
	* frame-unwind.h (frame_unwind_sniffer_ftype): Define.
	(frame_unwind_append_sniffer): Declare.
	(frame_unwind_find_by_frame): Replace frame_unwind_find_by_pc.
	* frame-unwind.c (frame_unwind_free): Free the "sniffer" table.
	(struct frame_unwind_table): Add "sniffer", delete "middle".
	(append_predicate): Add "sniffer" parameter, append the sniffer.
	(frame_unwind_init): Update append_predicate call.
	(frame_unwind_append_sniffer): New function.
	(frame_unwind_append_predicate): Update append_predicate call.
	(frame_unwind_find_by_frame): Replace frame_unwind_find_by_pc.
@
text
@d424 3
d428 1
a428 1
      fi->prev_func.addr = get_pc_function_start (frame_pc_unwind (fi));
@


1.132
log
@2003-07-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Move disabled inside_entry_func to
	before code inhibiting repeated unwind attempts.  Add to
	commentary on that test's problems.
	* blockframe.c (inside_main_func): Look for "main" in the minimal
	symbol table.
	* d10v-tdep.c (d10v_frame_this_id): Delete check that frames are
	identical.

Index: testsuite/ChangeLog
2003-07-15  Andrew Cagney  <cagney@@redhat.com>

	* gdb.asm/asm-source.exp: Do not allow "start" in the backtrace.
@
text
@d232 1
a232 2
	  fi->unwind = frame_unwind_find_by_pc (current_gdbarch,
						get_frame_pc (fi));
d519 1
a519 2
      frame->unwind = frame_unwind_find_by_pc (current_gdbarch,
					       get_frame_pc (frame));
d1207 1
a1207 1
  fi->unwind = frame_unwind_find_by_pc (current_gdbarch, pc);
d1366 1
a1366 2
      prev->unwind = frame_unwind_find_by_pc (current_gdbarch,
					      get_frame_pc (prev));
d1514 1
a1514 2
	  prev->unwind = frame_unwind_find_by_pc (current_gdbarch,
						  frame_pc_unwind (this_frame));
d1675 1
a1675 2
    prev->unwind = frame_unwind_find_by_pc (current_gdbarch,
					    get_frame_pc (prev));
d2088 1
a2088 1
    fi->base = frame_base_find_by_pc (current_gdbarch, get_frame_pc (fi));
d2104 1
a2104 1
    fi->base = frame_base_find_by_pc (current_gdbarch, get_frame_pc (fi));
d2122 1
a2122 1
    fi->base = frame_base_find_by_pc (current_gdbarch, get_frame_pc (fi));
d2161 1
a2161 2
      frame->unwind = frame_unwind_find_by_pc (current_gdbarch,
					       get_frame_pc (frame));
@


1.131
log
@2003-07-11  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (get_frame_address_in_block): Declare.
	(frame_unwind_address_in_block): Declare.
	* frame.c (frame_unwind_address_in_block): New function.
	(get_frame_address_in_block): New function.
@
text
@d1819 38
a1902 20

  /* If we're already inside the entry function for the main objfile,
     then it isn't valid.  Don't apply this test to a dummy frame -
     dummy frame PC's typically land in the entry func.  Don't apply
     this test to the sentinel frame.  Sentinel frames should always
     be allowed to unwind.  */
  /* NOTE: cagney/2003-02-25: Don't enable until someone has found
     hard evidence that this is needed.  */
  if (0
      && this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && inside_entry_func (get_frame_pc (this_frame)))
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, "// inside entry func }\n");
	}
      return NULL;
    }
@


1.130
log
@2003-07-07  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Enable check for identical frames.
	Update comments.  Update error messages.
@
text
@d2009 27
@


1.129
log
@2003-07-07  Andrew Cagney  <cagney@@redhat.com>

	* expprint.c: Include "user-regs.h" instead of "frame.h".
	(print_subexp): Use user_reg_map_regnum_to_name, instead of
	frame_map_regnum_to_name.
	* frame.c: Include "user-regs.h" instead of "builtin-regs.h".
	(frame_map_name_to_regnum): Simplify, call
	user_reg_map_name_to_regnum.
	(frame_map_regnum_to_name): Simplify, call
	user_reg_map_regnum_to_name.
	(frame_register_unwind): Update.
	* std-regs.c: Include "user-regs.h" instead of "builtin-regs.h".
	(_initialize_frame_reg): Call user_reg_add_builtin.
	* findvar.c: Include "user-regs.h" instead of "builtin-regs.h".
	(value_of_register): Use value_of_user_reg.
	* eval.c (evaluate_subexp_standard): Update.
	* parse.c (write_dollar_variable): Update.
	* d10v-tdep.c (d10v_print_registers_info): Update.
	* infcmd.c (registers_info): Update.
	* Makefile.in (SFILES): Delete "builtin-regs.c", add "user-regs.c".
	(builtin_regs_h): Delete macro.
	(user_regs_h): Define.
	(COMMON_OBS): Delete "builtin-regs.o", add "user-regs.o".
	(builtin-regs.o): Delete target.
	(user-regs.o): Specify dependencies.
	(expprint.o): Update dependencies.
	(findvar.o): Update dependencies.
	(frame.o): Update dependencies.
	(std-regs.o): Update dependencies.
@
text
@d1909 3
a1911 3
     the next frame.  This happens when frame unwind goes backwards.
     Since the sentinel frame isn't valid, don't apply this if this
     frame is entier the inner-most or sentinel frame.  */
d1915 1
a1915 1
    error ("This frame inner-to next frame (corrupt stack?)");
d1917 4
a1920 8
  /* Check that this and the next frame are different.  If they are
     not, there is most likely a stack cycle.  As with the inner-than
     test, avoid the inner-most and sentinel frames.  */
  /* FIXME: cagney/2003-03-17: Can't yet enable this this check. The
     frame_id_eq() method doesn't yet use function addresses when
     comparing frame IDs.  */
  if (0
      && this_frame->level > 0
d1923 1
a1923 1
    error ("This frame identical to next frame (corrupt stack?)");
@


1.128
log
@2003-06-29  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_register_unwind): Use unsigned char when dumping
	the buffer contents.
@
text
@d31 1
a31 1
#include "builtin-regs.h"
d500 1
a500 1
			  frame->level, frame_map_regnum_to_name (regnum));
d776 1
a776 1
frame_map_name_to_regnum (const char *name, int len)
d778 1
a778 24
  int i;

  if (len < 0)
    len = strlen (name);

  /* Search register name space. */
  for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
    if (REGISTER_NAME (i) && len == strlen (REGISTER_NAME (i))
	&& strncmp (name, REGISTER_NAME (i), len) == 0)
      {
	return i;
      }

  /* Try builtin registers.  */
  i = builtin_reg_map_name_to_regnum (name, len);
  if (i >= 0)
    {
      /* A builtin register doesn't fall into the architecture's
         register range.  */
      gdb_assert (i >= NUM_REGS + NUM_PSEUDO_REGS);
      return i;
    }

  return -1;
d782 1
a782 1
frame_map_regnum_to_name (int regnum)
d784 1
a784 5
  if (regnum < 0)
    return NULL;
  if (regnum < NUM_REGS + NUM_PSEUDO_REGS)
    return REGISTER_NAME (regnum);
  return builtin_reg_map_regnum_to_name (regnum);
@


1.127
log
@2003-06-21  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_unwind_get_saved_register): Delete.
	* frame.c (deprecated_unwind_get_saved_register): Delete function.
	* mips-tdep.c (mips_get_saved_register): Use frame_register_unwind
	and deprecated_get_next_frame_hack instead of
	deprecated_unwind_get_saved_register.
@
text
@d549 1
a549 1
	  const char *buf = bufferp;
@


1.127.2.1
log
@2003-06-29  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_register_unwind): Use unsigned char when dumping
	the buffer contents.
@
text
@d549 1
a549 1
	  const unsigned char *buf = bufferp;
@


1.127.2.2
log
@2003-07-07  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Enable check for identical frames.
	Update comments.  Update error messages.
@
text
@d1936 3
a1938 3
     the next frame.  This happens when a frame unwind goes backwards.
     Since the sentinel frame doesn't really exist, don't compare the
     inner-most against that sentinel.  */
d1942 1
a1942 1
    error ("Previous frame inner to this frame (corrupt stack?)");
d1944 8
a1951 4
  /* Check that this and the next frame are not identical.  If they
     are, there is most likely a stack cycle.  As with the inner-than
     test above, avoid comparing the inner-most and sentinel frames.  */
  if (this_frame->level > 0
d1954 1
a1954 1
    error ("Previous frame identical to this frame (corrupt stack?)");
@


1.127.2.3
log
@2003-07-11  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (get_frame_address_in_block): Declare.
	(frame_unwind_address_in_block): Declare.
	* frame.c (frame_unwind_address_in_block): New function.
	(get_frame_address_in_block): New function.
@
text
@a2035 27
/* Return an address of that falls within the frame's code block.  */

CORE_ADDR
frame_unwind_address_in_block (struct frame_info *next_frame)
{
  /* A draft address.  */
  CORE_ADDR pc = frame_pc_unwind (next_frame);

  /* If THIS frame is not inner most (i.e., NEXT isn't the sentinel),
     and NEXT is `normal' (i.e., not a sigtramp, dummy, ....) THIS
     frame's PC ends up pointing at the instruction fallowing the
     "call".  Adjust that PC value so that it falls on the call
     instruction (which, hopefully, falls within THIS frame's code
     block.  So far it's proved to be a very good approximation.  See
     get_frame_type for why ->type can't be used.  */
  if (next_frame->level >= 0
      && get_frame_type (next_frame) == NORMAL_FRAME)
    --pc;
  return pc;
}

CORE_ADDR
get_frame_address_in_block (struct frame_info *this_frame)
{
  return frame_unwind_address_in_block (this_frame->next);
}

@


1.127.2.4
log
@2003-07-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Move disabled inside_entry_func to
	before code inhibiting repeated unwind attempts.  Add to
	commentary on that test's problems.
	* blockframe.c (inside_main_func): Look for "main" in the minimal
	symbol table.
	* d10v-tdep.c (d10v_frame_this_id): Delete check that frames are
	identical.

Index: testsuite/ChangeLog
2003-07-15  Andrew Cagney  <cagney@@redhat.com>

	* gdb.asm/asm-source.exp: Do not allow "start" in the backtrace.
@
text
@a1845 38
  /* If we're already inside the entry function for the main objfile,
     then it isn't valid.  Don't apply this test to a dummy frame -
     dummy frame PC's typically land in the entry func.  Don't apply
     this test to the sentinel frame.  Sentinel frames should always
     be allowed to unwind.  */
  /* NOTE: cagney/2003-02-25: Don't enable until someone has found
     hard evidence that this is needed.  */
  /* NOTE: cagney/2003-07-07: Fixed a bug in inside_main_func - wasn't
     checking for "main" in the minimal symbols.  With that fixed
     asm-source tests now stop in "main" instead of halting the
     backtrace in wierd and wonderful ways somewhere inside the entry
     file.  Suspect that inside_entry_file and inside_entry_func tests
     were added to work around that (now fixed) case.  */
  /* NOTE: cagney/2003-07-15: danielj (if I'm reading it right)
     suggested having the inside_entry_func test use the
     inside_main_func msymbol trick (along with entry_point_address I
     guess) to determine the address range of the start function.
     That should provide a far better stopper than the current
     heuristics.  */
  /* NOTE: cagney/2003-07-15: Need to add a "set backtrace
     beyond-entry-func" command so that this can be selectively
     disabled.  */
  if (0
#if 0
      && backtrace_beyond_entry_func
#endif
      && this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && inside_entry_func (get_frame_pc (this_frame)))
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, "// inside entry func }\n");
	}
      return NULL;
    }

d1892 20
@


1.127.2.5
log
@2003-07-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_frame_id): Use frame_unwind_find_by_frame.
	(frame_register_unwind, create_new_frame): Ditto.
	(legacy_get_prev_frame, get_frame_type): Ditto.
	(get_frame_base_address): Use frame_base_find_by_frame.
	(get_frame_locals_address): Use frame_base_find_by_frame.
	(get_frame_args_address): Use frame_base_find_by_frame.
	* frame-base.h (frame_base_sniffer_ftype): Declare.
	(frame_base_append_sniffer): Declare.
	(frame_base_find_by_frame): Replace frame_base_find_by_pc.
	* frame-base.c (append_predicate): Add a "sniffer" parameter.
	(frame_base_append_sniffer): New function.
	(frame_base_append_predicate): Add a NULL sniffer.
	(frame_base_find_by_frame): Replace "frame_base_find_by_pc".
	(struct frame_base_table): Add "sniffer".
	(frame_base_free): Free the "sniffer" table.
	* frame-unwind.h (frame_unwind_sniffer_ftype): Define.
	(frame_unwind_append_sniffer): Declare.
	(frame_unwind_find_by_frame): Replace frame_unwind_find_by_pc.
	* frame-unwind.c (frame_unwind_free): Free the "sniffer" table.
	(struct frame_unwind_table): Add "sniffer", delete "middle".
	(append_predicate): Add "sniffer" parameter, append the sniffer.
	(frame_unwind_init): Update append_predicate call.
	(frame_unwind_append_sniffer): New function.
	(frame_unwind_append_predicate): Update append_predicate call.
	(frame_unwind_find_by_frame): Replace frame_unwind_find_by_pc.
@
text
@d232 2
a233 1
	  fi->unwind = frame_unwind_find_by_frame (fi->next);
d520 2
a521 1
      frame->unwind = frame_unwind_find_by_frame (frame->next);
d1236 1
a1236 1
  fi->unwind = frame_unwind_find_by_frame (fi->next);
d1395 2
a1396 1
      prev->unwind = frame_unwind_find_by_frame (prev->next);
d1544 2
a1545 1
	  prev->unwind = frame_unwind_find_by_frame (this_frame->next);
d1706 2
a1707 1
    prev->unwind = frame_unwind_find_by_frame (prev->next);
d2120 1
a2120 1
    fi->base = frame_base_find_by_frame (fi->next);
d2136 1
a2136 1
    fi->base = frame_base_find_by_frame (fi->next);
d2154 1
a2154 1
    fi->base = frame_base_find_by_frame (fi->next);
d2193 2
a2194 1
      frame->unwind = frame_unwind_find_by_frame (frame->next);
@


1.127.2.6
log
@2003-08-04  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_func_unwind): Use frame_unwind_address_in_block.
@
text
@a423 3
      /* Make certain that this, and not the adjacent, function is
         found.  */
      CORE_ADDR addr_in_block = frame_unwind_address_in_block (fi);
d425 1
a425 1
      fi->prev_func.addr = get_pc_function_start (addr_in_block);
@


1.127.2.7
log
@2003-08-09  Andrew Cagney  <cagney@@redhat.com>

	Fix GDB PR cli/926.
	* cli/cli-decode.c (add_setshow_uinteger_cmd): New function.
	* command.h (add_setshow_uinteger_cmd): Declare.
	* frame.c (set_backtrace_cmd): New function.
	(show_backtrace_cmd): New function.
	* frame.c (_initialize_frame): Replace "set/show
	backtrace-below-main" with "set/show backtrace past-main".  Add
	command "set/show backtrace limit".
	(backtrace_past_main): Rename "backtrace_below_main".
	(backtrace_limit): New variable.
	(get_prev_frame): Update.  Check the backtrace_limit.

2003-08-09  Andrew Cagney  <cagney@@redhat.com>

	* gdb.texinfo (Backtrace): Replace "set/show backtrace-below-main"
	with "set/show backtrace past-main" and "set/show backtrace
	limit".

Index: doc/gdb.texinfo
===================================================================
RCS file: /cvs/src/src/gdb/doc/gdb.texinfo,v
retrieving revision 1.174
diff -u -r1.174 gdb.texinfo
--- doc/gdb.texinfo	8 Aug 2003 01:58:00 -0000	1.174
+++ doc/gdb.texinfo	9 Aug 2003 14:57:10 -0000
@@@@ -3922,27 +3922,40 @@@@
 value, indicating that your program has stopped at the beginning of the
 code for line @@code{993} of @@code{builtin.c}.

-@@kindex set backtrace-below-main
-@@kindex show backtrace-below-main
+@@kindex set backtrace past-main
+@@kindex show backtrace past-main
+@@kindex set backtrace limit
+@@kindex show backtrace limit

-Most programs have a standard entry point---a place where system libraries
-and startup code transition into user code.  For C this is @@code{main}.
-When @@value{GDBN} finds the entry function in a backtrace it will terminate
-the backtrace, to avoid tracing into highly system-specific (and generally
-uninteresting) code.  If you need to examine the startup code, then you can
-change this behavior.
+Most programs have a standard user entry point---a place where system
+libraries and startup code transition into user code.  For C this is
+@@code{main}.  When @@value{GDBN} finds the entry function in a backtrace
+it will terminate the backtrace, to avoid tracing into highly
+system-specific (and generally uninteresting) code.
+
+If you need to examine the startup code, or limit the number of levels
+in a backtrace, you can change this behavior:

 @@table @@code
-@@item set backtrace-below-main off
+@@item set backtrace past-main
+@@itemx set backtrace past-main on
+Backtraces will continue past the user entry point.
+
+@@item set backtrace past-main off
 Backtraces will stop when they encounter the user entry point.  This is the
 default.

-@@item set backtrace-below-main
-@@itemx set backtrace-below-main on
-Backtraces will continue past the user entry point to the top of the stack.
+@@item show backtrace past-main
+Display the current user entry point backtrace policy.
+
+@@item set backtrace limit @@var{n}
+@@itemx set backtrace limit 0
+@@cindex backtrace limit
+Limit the backtrace to @@var{n} levels.  A value of zero means
+unlimited.

-@@item show backtrace-below-main
-Display the current backtrace policy.
+@@item show backtrace limit
+Display the current limit on backtrace levels.
 @@end table

 @@node Selection
@
text
@d138 1
a138 4
/* Flag to indicate whether backtraces should stop at main et.al.  */

static int backtrace_past_main;
static unsigned int backtrace_limit = UINT_MAX;
d140 1
d1832 1
a1832 1
      && !backtrace_past_main
a1843 5
  if (this_frame->level > backtrace_limit)
    {
      error ("Backtrace limit of %d exceeded", backtrace_limit);
    }

a2399 15
static struct cmd_list_element *set_backtrace_cmdlist;
static struct cmd_list_element *show_backtrace_cmdlist;

static void
set_backtrace_cmd (char *args, int from_tty)
{
  help_list (set_backtrace_cmdlist, "set backtrace ", -1, gdb_stdout);
}

static void
show_backtrace_cmd (char *args, int from_tty)
{
  cmd_show_list (show_backtrace_cmdlist, from_tty, "");
}

d2405 4
a2408 10
  add_prefix_cmd ("backtrace", class_maintenance, set_backtrace_cmd, "\
Set backtrace specific variables.\n\
Configure backtrace variables such as the backtrace limit",
		  &set_backtrace_cmdlist, "set backtrace ",
		  0/*allow-unknown*/, &setlist);
  add_prefix_cmd ("backtrace", class_maintenance, show_backtrace_cmd, "\
Show backtrace specific variables\n\
Show backtrace variables such as the backtrace limit",
		  &show_backtrace_cmdlist, "show backtrace ",
		  0/*allow-unknown*/, &showlist);
d2410 2
a2411 2
  add_setshow_boolean_cmd ("past-main", class_obscure,
			   &backtrace_past_main, "\
d2420 1
a2420 2
			   NULL, NULL, &set_backtrace_cmdlist,
			   &show_backtrace_cmdlist);
a2421 8
  add_setshow_uinteger_cmd ("limit", class_obscure,
			    &backtrace_limit, "\
Set an upper bound on the number of backtrace levels.\n\
No more than the specified number of frames can be displayed or examined.\n
Zero is unlimited.", "\
Show the upper bound on the number of backtrace levels.",
			    NULL, NULL, &set_backtrace_cmdlist,
			    &show_backtrace_cmdlist);
@


1.127.2.8
log
@* frame.c (_initialize_frame): Add missing backslash.
@
text
@d2454 1
a2454 1
No more than the specified number of frames can be displayed or examined.\n\
@


1.127.2.9
log
@2003-08-12  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_frame_xmalloc): Use XMALLOC, instead of
	FRAME_OBSTACK_ZALLOC.
@
text
@d2309 1
a2309 2
  struct frame_info *frame = XMALLOC (struct frame_info);
  memset (frame, 0, sizeof (*frame));
@


1.127.2.10
log
@	* frame.c (deprecated_safe_get_selected_frame): New function.
	* frame.h (deprecated_safe_get_selected_frame): Add prototype.
	* findvar.c (read_var_value): Call it.
@
text
@a946 12
/* This is a variant of get_selected_frame which can be called when
   the inferior does not have a frame; in that case it will return
   NULL instead of calling error ().  */

struct frame_info *
deprecated_safe_get_selected_frame (void)
{
  if (!target_has_registers || !target_has_stack || !target_has_memory)
    return NULL;
  return get_selected_frame ();
}

@


1.126
log
@2003-06-21  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_frame_register): New function.
	(frame_unwind_register_signed): New function.
	(get_frame_register_signed): New function.
	(frame_unwind_register_unsigned): New function.
	(get_frame_register_unsigned): New function.
	* frame.h: Add comments on naming schema.
	(get_frame_register, frame_unwind_register_signed): Declare.
	(get_frame_register_signed, get_frame_register_signed): Declare.
	(frame_unwind_register_unsigned): Declare.
	(get_frame_register_unsigned): Declare.
@
text
@a740 30
void
deprecated_unwind_get_saved_register (char *raw_buffer,
				      int *optimizedp,
				      CORE_ADDR *addrp,
				      struct frame_info *frame,
				      int regnum,
				      enum lval_type *lvalp)
{
  int optimizedx;
  CORE_ADDR addrx;
  int realnumx;
  enum lval_type lvalx;

  if (!target_has_registers)
    error ("No registers.");

  /* Keep things simple, ensure that all the pointers (except valuep)
     are non NULL.  */
  if (optimizedp == NULL)
    optimizedp = &optimizedx;
  if (lvalp == NULL)
    lvalp = &lvalx;
  if (addrp == NULL)
    addrp = &addrx;

  gdb_assert (frame != NULL && frame->next != NULL);
  frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			 &realnumx, raw_buffer);
}

@


1.125
log
@2003-06-16  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_get_next_frame_hack): Declare.
	* frame.c (legacy_saved_regs_prev_register): Only require
	DEPRECATED_FRAME_INIT_SAVED_REGS when it is needed.  Assert that
	there are always saved regs.
	(deprecated_generic_get_saved_register): Do not require
	DEPRECATED_FRAME_INIT_SAVED_REGS.
	(legacy_get_prev_frame): Do not require DEPRECATED_FRAME_CHAIN,
	use frame ID unwind instead.
	(deprecated_get_next_frame_hack): New function.
@
text
@d618 35
@


1.124
log
@2003-06-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (SAVE_DUMMY_FRAME_TOS): Deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* infcall.c (call_function_by_hand): Update.
	* ia64-tdep.c (ia64_push_arguments): Update comment.
	* frame.c (legacy_get_prev_frame): Do not assume
	SAVE_DUMMY_FRAME_TOS_P.
	* dummy-frame.c (find_dummy_frame): Update comment.
@
text
@a995 6
  /* Only (older) architectures that implement the
     DEPRECATED_FRAME_INIT_SAVED_REGS method should be using this
     function.  */
  gdb_assert (DEPRECATED_FRAME_INIT_SAVED_REGS_P ());

  /* Load the saved_regs register cache.  */
d997 6
a1002 1
    DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
a1113 2
  gdb_assert (DEPRECATED_FRAME_INIT_SAVED_REGS_P ());

d1267 6
d1507 6
d1531 23
a1553 2
      gdb_assert (DEPRECATED_FRAME_CHAIN_P ());
      address = DEPRECATED_FRAME_CHAIN (this_frame);
d1696 7
a1702 3
     use that to decide how the frame should be unwound.  */
  prev->unwind = frame_unwind_find_by_pc (current_gdbarch,
					  get_frame_pc (prev));
d1710 1
@


1.123
log
@2003-06-14  Andrew Cagney  <cagney@@redhat.com>
            Mark Kettenis  <kettenis@@gnu.org>

	* gdbarch.sh (CONVERT_REGISTER_P): Add "type" parameter.
	(REGISTER_TO_VALUE, VALUE_TO_REGISTER): Replace raw buffer
	parameter with "frame".
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h (put_frame_register): Declare.
	* frame.c (put_frame_register): New function.
	* arch-utils.c (legacy_convert_register_p): Add "type" parameter.
	(legacy_register_to_value): Rewrite, use "frame" to get the
	register value.
	(legacy_value_to_register): Rewrite, use "frame" to find the
	register's location before storing.
	* arch-utils.h (legacy_convert_register_p): Update.
	(legacy_register_to_value, legacy_value_to_register): Update.
	* findvar.c (value_from_register): Rewrite, eliminate use of
	REGISTER_CONVERT_TO_TYPE, pass "type" to CONVERT_REGISTER_P, pass
	"frame" to REGISTER_TO_VALUE.
	* valops.c (value_assign): Move the CONVERT_REGISTER code to the
	lval_reg_frame_relative + lval_register branch of the switch.  Do
	not use REGISTER_CONVERT_FROM_TYPE.  Use put_frame_register.
	* i386-tdep.c (I386_EBX_REGNUM, I386_ECX_REGNUM, I386_ESI_REGNUM,
	I386_EDI_REGNUM): New defines.
	(i386_next_regnum, i386_convert_register_p,
	i386_register_to_value, i386_value_to_register): New functions.
	(i386_register_convertible, i386_register_convert_to_virtual,
	i386_convert_to_raw): Remove functions.
	(i386_gdbarch_init): Set convert_register_p, register_to_value and
	value_to_register instead of register_convertible,
	register_convert_to_virtual and register_convert_to_raw.
	* mips-tdep.c (mips_convert_register_p): New function.
	(mips_value_to_register): Replace mips_register_convert_from_type.
	(mips_register_to_value): Replace mips_register_convert_to_type.
	(mips_gdbarch_init): Set conver_register_p, value_to_register and
	register_to_value.
	* alpha-tdep.c (alpha_convert_register_p): Update.
	(alpha_value_to_register): Update, store the register.
	(alpha_register_to_value): Update, fetch the register.
@
text
@a1405 4
	  /* Assume call_function_by_hand(), via SAVE_DUMMY_FRAME_TOS,
	     previously saved the dummy frame's ID.  Things only work
	     if the two return the same value.  */
	  gdb_assert (SAVE_DUMMY_FRAME_TOS_P ());
@


1.122
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c (call_function_by_hand): When UNWIND_DUMMY_ID is
	available, do not use the FP register, and always save the TOS.
	* dummy-frame.c (dummy_frame_this_id): Do not assert
	SAVE_DUMMY_FRAME_TOS.
	* i386-tdep.c (i386_save_dummy_frame_tos): Delete function.
	(i386_gdbarch_init): Do not set save_dummy_frame_tos.
	(i386_push_dummy_call): Add 8 to the returned SP.
	* frame.c (legacy_frame_p): Do not require SAVE_DUMMY_FRAME_TOS.
	* d10v-tdep.c (d10v_unwind_dummy_id): Use d10v_unwind_sp.
	(d10v_gdbarch_init): Do not set save_dummy_frame_tos.
	* x86-64-tdep.c (x86_64_save_dummy_frame_tos): Delete function.
	(x86_64_push_dummy_call): Return "sp + 16".
	(x86_64_init_abi): Do not set save_dummy_frame_tos.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	save_dummy_frame_tos.
@
text
@d677 30
@


1.121
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_unwind_get_saved_register): Rename
	generic_unwind_get_saved_register, update comments.
	* mips-tdep.c (mips_get_saved_register): Update.
	* frame.c (deprecated_unwind_get_saved_register): Update.
@
text
@d2291 1
a2291 2
	  || !gdbarch_unwind_dummy_id_p (current_gdbarch)
	  || !SAVE_DUMMY_FRAME_TOS_P ());
@


1.120
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Remove reference to
	frame_args_address_correct in comments.
	* frame-base.c (default_frame_args_address): Delete code
	conditional on FRAME_ARGS_ADDRESS_CORRECT.
	* vax-tdep.c (vax_frame_args_address_correct): Delete.
	(vax_frame_args_address): Merge in vax_frame_args_address_correct.
	* config/vax/tm-vax.h (FRAME_ARGS_ADDRESS_CORRECT): Delete
	(vax_frame_args_address_correct): Delete declaration.

Index: doc/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	documentation on FRAME_ARGS_ADDRESS_CORRECT.
@
text
@d677 6
a682 6
generic_unwind_get_saved_register (char *raw_buffer,
				   int *optimizedp,
				   CORE_ADDR *addrp,
				   struct frame_info *frame,
				   int regnum,
				   enum lval_type *lvalp)
@


1.119
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (UNWIND_SP): Add.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (frame_sp_unwind): New function.
	(get_frame_sp): New function.
	* frame.h (get_frame_sp, frame_sp_unwind): Declare.
	* regcache.c (read_sp): Rewrite, try each of TARGET_READ_SP,
	gdbarch_unwind_sp and SP_REGNUM when looking for the SP register
	value.
	* d10v-tdep.c (d10v_unwind_sp): Replace d10v_read_sp.
	(d10v_gdbarch_init): Set unwind_sp instead of read_sp.

2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	"unwind_sp".  Cross reference "unwind_sp" and TARGET_READ_SP.
@
text
@d1947 5
a1951 5
     The very old VAX frame_args_address_correct() method noted: [...]
     For the sake of argument, suppose that the stack is somewhat
     trashed (which is one reason that "info frame" exists).  So,
     return 0 (indicating we don't know the address of the arglist) if
     we don't know what frame this frame calls.  */
@


1.118
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d2253 31
@


1.117
log
@2003-06-03  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_frame_memory_signed): New function.
	(get_frame_memory, get_frame_memory_unsigned): New function.
	(get_frame_arch): New function.
	* frame.h (get_frame_signed_memory, get_frame_arch): Declare.
	(get_frame_memory, get_frame_unsigned_memory): Declare.
	* d10v-tdep.c (d10v_frame_unwind_cache): Use
	get_frame_memory_unsigned and get_frame_arch.
	(d10v_frame_unwind_cache, saved_regs_unwinder): Ditto.
@
text
@d781 1
a781 1
struct frame_info *
d2263 2
@


1.117.2.1
log
@2003-06-06  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (put_frame_register): Declare.
	* frame.c (put_frame_register): New function.

	* arch-utils.c: Include "gdbcore.h".
	(legacy_convert_register_p): Add "type" parameter.
	(legacy_register_to_value): Rewrite, use "frame" to get the
	register value.
	(legacy_value_to_register): Rewrite, use "frame" to find the
	register's location before storing.
	* arch-utils.h (legacy_convert_register_p): Update.
	(legacy_register_to_value, legacy_value_to_register): Update.

	* Makefile.in (arch-utils.o): Update dependencies.

	* findvar.c (value_from_register): Rewrite, eliminate use of
	REGISTER_CONVERT_TO_TYPE, pass "type" to CONVERT_REGISTER_P, pass
	"frame" to REGISTER_TO_VALUE.

	* gdbarch.sh (CONVERT_REGISTER_P): Add "type" parameter.
	(REGISTER_TO_VALUE, VALUE_TO_REGISTER): Replace "type", "from" and
	"to" parameters with "frame" and "value".
	* gdbarch.h, gdbarch.c: Re-generate.

	* mips-tdep.c (mips_convert_register_p): New function.
	(mips_value_to_register): Replace mips_register_convert_from_type.
	(mips_register_to_value): Replace mips_register_convert_to_type.
	(mips_gdbarch_init): Set conver_register_p, value_to_register and
	register_to_value.

	* valops.c (value_assign): Move the CONVERT_REGISTER code to the
	lval_reg_frame_relative + lval_register branch of the switch.  Do
	not use REGISTER_CONVERT_FROM_TYPE.  Use put_frame_register.
@
text
@a676 30
put_frame_register (struct frame_info *frame, int regnum, const void *buf)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int realnum;
  int optim;
  enum lval_type lval;
  CORE_ADDR addr;
  frame_register (frame, regnum, &optim, &lval, &addr, &realnum, NULL);
  if (optim)
    error ("Attempt to assign to a value that was optimized out.");
  switch (lval)
    {
    case lval_memory:
      {
	/* FIXME: write_memory doesn't yet take constant buffers.
           Arrrg!  */
	char tmp[MAX_REGISTER_SIZE];
	memcpy (tmp, buf, register_size (gdbarch, regnum));
	write_memory (addr, tmp, register_size (gdbarch, regnum));
	break;
      }
    case lval_register:
      regcache_cooked_write (current_regcache, realnum, buf);
      break;
    default:
      error ("Attempt to assign to an unmodifiable value.");
    }
}

void
@


1.116
log
@2003-05-22  Andrew Cagney  <cagney@@redhat.com>

	* stack.c (frame_info): Inline extract_address, replacing it with
	extract_unsigned_integer.
	* findvar.c (unsigned_pointer_to_address): Ditto.
	* dwarf2loc.c (dwarf_expr_read_reg): Ditto.
	* dwarf2expr.c (dwarf2_read_address): Ditto.
	* frame.c (frame_pc_unwind): Update comment.
	* dummy-frame.c (deprecated_read_register_dummy): Update comment.
@
text
@d2222 31
@


1.115
log
@2003-05-15  Andrew Cagney  <cagney@@redhat.com>

	* dummy-frame.h (deprecated_find_dummy_frame_regcache): Rename
	generic_find_dummy_frame.
	* dummy-frame.c (deprecated_find_dummy_frame_regcache): Update.
	(deprecated_generic_find_dummy_frame): Update.
	(deprecated_read_register_dummy): Update.
	* frame.c (deprecated_generic_get_saved_register): Update.
@
text
@d379 1
a379 1
	     return extract_address (buf, size of ISA_PC_REGNUM);
@


1.114
log
@2003-05-13  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (store_address): Delete declaration.
	findvar.c (store_address): Delete function.
	* arm-tdep.c (arm_push_dummy_call): Replace store_address with
	store_unsigned_integer.
	* xstormy16-tdep.c (xstormy16_address_to_pointer): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	* sparc-tdep.c (sparc_get_saved_register): Ditto.
	* sh-tdep.c (sh64_get_saved_register): Ditto.
	* rs6000-tdep.c (rs6000_push_arguments): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Ditto.
	* mips-tdep.c (mips_eabi_push_arguments): Ditto.
	(mips_get_saved_register): Ditto.
	* ia64-tdep.c (ia64_get_saved_register): Ditto.
	(find_func_descr, ia64_push_arguments): Ditto.
	* i386-tdep.c (i386_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	* frv-tdep.c (frv_push_arguments): Ditto.
	* frame.c (legacy_saved_regs_prev_register): Ditto.
	(deprecated_generic_get_saved_register): Ditto.
	* findvar.c (unsigned_address_to_pointer): Ditto.
	* dwarf2read.c (dwarf2_const_value): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_push_arguments): Ditto.
@
text
@d1115 2
a1116 2
		  (generic_find_dummy_frame (get_frame_pc (frame),
					     get_frame_base (frame)),
@


1.113
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d986 4
a989 2
	    store_address (bufferp, REGISTER_RAW_SIZE (regnum),
			   get_frame_saved_regs (frame)[regnum]);
d1130 5
a1134 2
		    store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
				   get_frame_saved_regs (frame)[regnum]);
@


1.113.4.1
log
@Snap const char * mess.
@
text
@d986 2
a987 4
	    /* NOTE: cagney/2003-05-09: In-lined store_address with
               it's body - store_unsigned_integer.  */
	    store_unsigned_integer (bufferp, REGISTER_RAW_SIZE (regnum),
				    get_frame_saved_regs (frame)[regnum]);
d1128 2
a1129 5
		    /* NOTE: cagney/2003-05-09: In-line store_address
                       with it's body - store_unsigned_integer.  */
		    store_unsigned_integer (raw_buffer,
					    REGISTER_RAW_SIZE (regnum),
					    get_frame_saved_regs (frame)[regnum]);
d1169 1
a1169 1
      const char *name;
d1677 1
a1677 1
      const char *name;
@


1.112
log
@	* frame.c (get_frame_type): Don't attempt to lazily initialize
	frame's unwinder for legacy frames.
@
text
@d621 1
a621 1
  void *buf = alloca (MAX_REGISTER_RAW_SIZE);
d630 1
a630 1
  void *buf = alloca (MAX_REGISTER_RAW_SIZE);
@


1.111
log
@Index: testsuite/ChangeLog
2003-05-05  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/maint.exp: Add tests for "maint print dummy-frames".

Index: doc/ChangeLog
2003-05-05  Andrew Cagney  <cagney@@redhat.com>

	* gdb.texinfo (Maintenance Commands): Document "maint print
	dummy-frames".

2003-05-05  Andrew Cagney  <cagney@@redhat.com>

	* dummy-frame.c: Include "command.h" and "gdbcmd.h".
	(fprint_dummy_frames): New function.
	(maintenance_print_dummy_frames): New function.
	(_initialize_dummy_frame): Add command "maint print dummy-frames".
	* frame.c (fprint_frame_id): Make global.
	* frame.h (fprint_frame_id): Declare.
	* Makefile.in (dummy-frame.o): Update dependencies.
@
text
@d2072 6
a2077 1
  if (frame->unwind == NULL)
@


1.110
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d142 1
a142 1
static void
@


1.109
log
@2003-04-21  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_id_eq): Fail when the code_addr's do not match.
@
text
@d1389 2
a1390 1
	  prev->this_id.value = frame_id_build (read_fp (), read_pc ());
d1545 3
a1547 2
     (read_fp ()), read_pc ()).  Machines with extra frame info would
     do that (or the local equivalent) and then set the extra fields.
@


1.108
log
@2003-04-16  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Do not initialize "unwind" or "type",
	update comments.
	(get_frame_type): Initialize unwind and type when needed.
	(get_frame_id, frame_register_unwind): Ditto.
@
text
@d298 2
a299 4
    /* FIXME: cagney/2003-04-06: This should be zero.  Can't yet do
       this because most frame ID's are not being initialized
       correctly.  */
    eq = 1;
@


1.108.2.1
log
@Merge from mainline.
@
text
@d298 4
a301 2
    /* No luck.  */
    eq = 0;
d1391 1
a1391 2
	  prev->this_id.value = frame_id_build (deprecated_read_fp (),
						read_pc ());
d1546 2
a1547 3
     (deprecated_read_fp ()), read_pc ()).  Machines with extra frame
     info would do that (or the local equivalent) and then set the
     extra fields.
@


1.108.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d142 1
a142 1
void
d621 1
a621 1
  char buf[MAX_REGISTER_SIZE];
d630 1
a630 1
  char buf[MAX_REGISTER_SIZE];
d986 2
a987 4
	    /* NOTE: cagney/2003-05-09: In-lined store_address with
               it's body - store_unsigned_integer.  */
	    store_unsigned_integer (bufferp, REGISTER_RAW_SIZE (regnum),
				    get_frame_saved_regs (frame)[regnum]);
d1113 2
a1114 2
		  (deprecated_find_dummy_frame_regcache (get_frame_pc (frame),
							 get_frame_base (frame)),
d1128 2
a1129 5
		    /* NOTE: cagney/2003-05-09: In-line store_address
                       with it's body - store_unsigned_integer.  */
		    store_unsigned_integer (raw_buffer,
					    REGISTER_RAW_SIZE (regnum),
					    get_frame_saved_regs (frame)[regnum]);
d2072 1
a2072 6

  /* Some legacy code, e.g, mips_init_extra_frame_info() wants
     to determine the frame's type prior to it being completely
     initialized.  Don't attempt to lazily initialize ->unwind for
     legacy code.  It will be initialized in legacy_get_prev_frame().  */
  if (frame->unwind == NULL && !legacy_frame_p (current_gdbarch))
@


1.107
log
@2003-04-12  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (struct frame_info): Move definition from here ...
	* frame.c (struct frame_info): ... to here.
@
text
@d229 13
d519 14
d1929 3
a1931 14
  /* Set the unwind functions based on that identified PC.  */
  prev_frame->unwind = frame_unwind_find_by_pc (current_gdbarch,
						frame_pc_unwind (this_frame));

  /* FIXME: cagney/2003-04-02: Rather than storing the frame's type in
     the frame, the unwinder's type should be returned directly.
     Unfortunatly, legacy code, called by legacy_get_prev_frame,
     explicitly set the frames type using the method
     deprecated_set_frame_type().  */
  gdb_assert (prev_frame->unwind->type != UNKNOWN_FRAME);
  prev_frame->type = prev_frame->unwind->type;

  /* Can the frame's type and unwinder be computed on demand?  That
     would make a frame's creation really really lite!  */
d1933 2
a1934 1
  /* The prev's frame's ID is computed by demand in get_frame_id().  */
d2072 14
@


1.106
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_frame_id): Return this frame's "id".
	(legacy_get_prev_frame): Set prev's frame ID code_addr to the
	function start.
	(legacy_saved_regs_this_id): Replace function body with
	internal-error.
	(deprecated_frame_xmalloc): Mark the frame ID as valid, use
	FRAME_OBSTACK_ZALLOC.
	(create_new_frame): Mark the frame ID as valid.
@
text
@d43 91
@


1.105
log
@2003-04-10  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (fprint_frame_id): New function.
	(fprint_frame_type, fprint_frame): New function.
	(frame_pc_unwind, frame_func_unwind): Add/update trace code.
	(create_sentinel_frame, get_frame_id): Ditto.
	(frame_id_p, frame_id_eq): Ditto.
	(frame_id_inner, create_new_frame): Ditto.
	(legacy_get_prev_frame, get_prev_frame): Ditto.
	(deprecated_update_frame_pc_hack): Ditto.
	(frame_register_unwind): Ditto.
	(deprecated_update_frame_base_hack): Ditto.
@
text
@d148 1
a148 1
  return frame_id_build (fi->this_id.value.stack_addr, get_frame_pc (fi));
d924 3
a926 64
  int fromleaf;
  CORE_ADDR base;
  CORE_ADDR pc;

  if (frame_relative_level (next_frame) < 0)
    {
      /* FIXME: cagney/2003-03-14: We've got the extra special case of
	 unwinding a sentinel frame, the PC of which is pointing at a
	 stack dummy.  Fake up the dummy frame's ID using the same
	 sequence as is found a traditional unwinder.  */
      (*id) = frame_id_build (read_fp (), read_pc ());
      return;
    }

  /* Start out by assuming it's NULL.  */
  (*id) = null_frame_id;

  if (frame_relative_level (next_frame) <= 0)
    /* FIXME: 2002-11-09: Frameless functions can occure anywhere in
       the frame chain, not just the inner most frame!  The generic,
       per-architecture, frame code should handle this and the below
       should simply be removed.  */
    fromleaf = FRAMELESS_FUNCTION_INVOCATION (next_frame);
  else
    fromleaf = 0;

  if (fromleaf)
    /* A frameless inner-most frame.  The `FP' (which isn't an
       architecture frame-pointer register!) of the caller is the same
       as the callee.  */
    /* FIXME: 2002-11-09: There isn't any reason to special case this
       edge condition.  Instead the per-architecture code should hande
       it locally.  */
    base = get_frame_base (next_frame);
  else
    {
      /* Two macros defined in tm.h specify the machine-dependent
         actions to be performed here.

         First, get the frame's chain-pointer.

         If that is zero, the frame is the outermost frame or a leaf
         called by the outermost frame.  This means that if start
         calls main without a frame, we'll return 0 (which is fine
         anyway).

         Nope; there's a problem.  This also returns when the current
         routine is a leaf of main.  This is unacceptable.  We move
         this to after the ffi test; I'd rather have backtraces from
         start go curfluy than have an abort called from main not show
         main.  */
      gdb_assert (DEPRECATED_FRAME_CHAIN_P ());
      base = DEPRECATED_FRAME_CHAIN (next_frame);

      if (!legacy_frame_chain_valid (base, next_frame))
	return;
    }
  if (base == 0)
    return;

  /* FIXME: cagney/2002-06-08: This should probably return the frame's
     function and not the PC (a.k.a. resume address).  */
  pc = frame_pc_unwind (next_frame);
  (*id) = frame_id_build (base, pc);
d1089 1
d1313 5
d1526 3
d1571 4
d2066 2
a2067 2
  struct frame_info *frame = XMALLOC (struct frame_info);
  memset (frame, 0, sizeof (struct frame_info));
@


1.104
log
@2003-04-09  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (struct frame_id): Replace "pc" and "base" with
	"stack_addr" and "code_addr".  Update comments.
	(frame_id_build): Update parameter names and comment.
	(struct frame_info): Replace "id_p" and "id" with "this_id".
	* dummy-frame.c (dummy_frame_this_id): Update.
	* breakpoint.c (print_one_breakpoint): Update.
	* frame.c (get_frame_id): Update.
	(get_frame_base, frame_id_build): Update.
	(create_sentinel_frame, legacy_get_prev_frame): Update.
	(deprecated_update_frame_base_hack): Update.
	(frame_id_p, frame_id_eq): Rework, return 0 when an invalid ID.
	(frame_id_inner): Ditto.
@
text
@d51 71
d135 3
d141 6
d168 6
d198 8
d222 8
d309 5
d325 4
d394 7
d421 20
d684 6
d1131 7
d1156 7
d1191 2
d1219 3
d1285 6
a1290 2
	    fprintf_unfiltered (gdb_stdlog,
				"Outermost frame - unwound PC zero\n");
d1340 6
a1345 2
	    fprintf_unfiltered (gdb_stdlog,
				"Outermost legacy sentinel frame - unwound frame ID invalid\n");
d1373 6
d1433 10
a1442 1
	return 0;
d1445 10
a1454 1
    return 0;
d1559 7
d1581 6
d1623 7
d1642 10
d1701 1
a1701 2
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - inside main func.\n");
d1707 9
a1715 1
    return this_frame->prev;
d1743 5
a1747 2
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - inside entry file\n");
d1764 5
a1768 2
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - inside entry func\n");
a1776 3
      if (frame_debug && prev_frame == NULL)
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - legacy_get_prev_frame NULL.\n");
d1786 5
a1790 2
 	fprintf_filtered (gdb_stdlog,
 			  "Outermost frame - this ID is NULL\n");
d1851 5
a1855 2
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - unwound PC zero\n");
d1892 7
d2041 4
d2062 4
@


1.103
log
@2003-04-09  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (struct frame_info): Delete field "pc".  Replace
	"pc_unwind_cache" and "pc_unwind_cache_p" with "prev_pc"
	structure.
	* frame.c (frame_pc_unwind): Update.
	(create_sentinel_frame): Do not set "pc".
	(get_prev_frame): Do not set "pc".  Use frame_pc_unwind.
	(get_frame_pc): Call frame_pc_unwind.
	(deprecated_update_frame_pc_hack): Update.
	(create_new_frame): Use "pc" not "->pc".
@
text
@d61 1
a61 1
  if (!fi->id_p)
d65 2
a66 2
      fi->unwind->this_id (fi->next, &fi->prologue_cache, &fi->id);
      fi->id_p = 1;
d68 1
a68 1
  return frame_id_build (fi->id.base, get_frame_pc (fi));
d74 1
a74 1
frame_id_build (CORE_ADDR base, CORE_ADDR func_or_pc)
d77 2
a78 2
  id.base = base;
  id.pc = func_or_pc;
d85 4
a88 2
  /* The .func can be NULL but the .base cannot.  */
  return (l.base != 0);
d94 19
a112 6
  /* If .base is different, the frames are different.  */
  if (l.base != r.base)
    return 0;
  /* Add a test to check that the frame ID's are for the same function
     here.  */
  return 1;
d118 11
a128 5
  /* Only return non-zero when strictly inner than.  Note that, per
     comment in "frame.h", there is some fuzz here.  Frameless
     functions are not strictly inner than (same .base but different
     .func).  */
  return INNER_THAN (l.base, r.base);
d544 2
a545 2
  frame->id_p = 1;
  frame->id = null_frame_id;
d1093 1
a1093 1
  prev->id_p = 1;
d1156 2
a1157 1
	  prev->id = gdbarch_unwind_dummy_id (current_gdbarch, this_frame);
d1166 1
a1166 1
	  prev->id = frame_id_build (read_fp (), read_pc ());
d1170 1
a1170 1
      if (!frame_id_p (prev->id))
d1689 1
a1689 1
  return get_frame_id (fi).base;
d1811 1
a1811 1
  frame->id.base = base;
@


1.102
log
@2003-04-09  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_frame_id): Eliminate code updating "frame".
	(legacy_get_prev_frame): Ditto.
	(get_frame_base): Return id.base directly.
	(deprecated_update_frame_base_hack): Update "id.base".
	* frame.h (struct frame_info): Delete field "frame".
@
text
@d142 1
a142 1
  if (!this_frame->pc_unwind_cache_p)
d184 2
a185 2
      this_frame->pc_unwind_cache = pc;
      this_frame->pc_unwind_cache_p = 1;
d187 1
a187 1
  return this_frame->pc_unwind_cache;
a520 8
  /* Always unwind the PC as part of creating this frame.  This
     ensures that the frame's PC points at something valid.  */
  /* FIXME: cagney/2003-01-10: Problem here.  Unwinding a sentinel
     frame's PC may require information such as the frame's thread's
     stop reason.  Is it possible to get to that?  */
  /* FIXME: cagney/2003-04-04: Once ->pc is eliminated, this
     assignment can go away.  */
  frame->pc = frame_pc_unwind (frame);
d972 1
a972 1
  fi->unwind = frame_unwind_find_by_pc (current_gdbarch, fi->pc);
d1108 2
a1109 1
      prev->unwind = frame_unwind_find_by_pc (current_gdbarch, prev->pc);
d1111 1
a1111 1
	prev->type = frame_type_from_pc (prev->pc);
d1586 1
a1586 4
  /* FIXME: cagney/2003-04-04: Once ->pc is eliminated, this
     assignment can go away.  */
  prev_frame->pc = frame_pc_unwind (this_frame);
  if (prev_frame->pc == 0)
d1598 1
a1598 1
						prev_frame->pc);
d1635 2
a1636 1
  return frame->pc;
a1770 2
  /* See comment in "frame.h".  */
  frame->pc = pc;
d1780 2
a1781 2
      frame->next->pc_unwind_cache = pc;
      frame->next->pc_unwind_cache_p = 1;
@


1.101
log
@2003-04-06  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (legacy_frame_chain_valid): Rename frame_chain_valid.
	Update comment.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame): Update.
	* xstormy16-tdep.c: Update comment.
	* sparc-tdep.c (sparc_frame_chain): Update comment.
	* blockframe.c (legacy_frame_chain_valid): Update.
@
text
@a66 3
      /* FIXME: cagney/2002-12-18: Instead of this hack, should only
	 store the frame ID in PREV_FRAME.  */
      fi->frame = fi->id.base;
d68 1
a68 1
  return frame_id_build (fi->frame, get_frame_pc (fi));
a1171 6
      /* FIXME: cagney/2002-12-18: Instead of this hack, should only
	 store the frame ID in PREV_FRAME.  */
      /* FIXME: cagney/2003-04-04: Once ->frame is eliminated, this
         assignment can go.  */
      prev->frame = prev->id.base;

d1676 1
a1676 7
  if (!fi->id_p)
    {
      /* HACK: Force the ID code to (indirectly) initialize the
         ->frame pointer.  */
      get_frame_id (fi);
    }
  return fi->frame;
d1800 1
a1800 1
  frame->frame = base;
@


1.100
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	Eliminate FRAME_FIND_SAVED_REGS.
	* config/pa/tm-hppah.h (hppa_hpux_frame_find_saved_regs_in_sigtramp):
	Change FSR parameter to a pointer.
	* config/pa/tm-hppa64.h (FRAME_FIND_SAVED_REGS_IN_SIGTRAMP):
	Assume FSR parameter is a pointer.
	* hppa-hpux-tdep.c (hppa_hpux_frame_find_saved_regs_in_sigtramp):
	Make fsr a pointer.
	* hppa-tdep.c (hppa_frame_find_saved_regs): New function.
	(hppa_frame_saved_pc): Call hppa_frame_init_saved_regs.  Make
	saved_regs a pointer.
	(hppa_frame_saved_pc): Ditto.
	(find_dummy_frame_regs): Make frame_saved_regs a pointer
	(hppa_pop_frame): Call hppa_frame_init_saved_regs.  Make fsr a
	pointer.
	(restore_pc_queue): Make fsr a pointer.
	(hppa_frame_find_saved_regs): Make frame_saved_regs a pointer.
	(hppa_frame_chain): Make saved_regs a pointer, call
	hppa_frame_init_saved_regs.
	* sparc-tdep.c: Include "gdb_assert.h".
	(sparc_frame_find_saved_regs): Replace internal_error with
	gdb_assert.
	* remote-vxsparc.c (vx_read_register): Delete reference to
	FRAME_FIND_SAVED_REGS.
	* gdbarch.sh: Delete check for FRAME_FIND_SAVED_REGS.
	* gdbarch.h: Regenerate.
	* frame.h (DEPRECATED_FRAME_INIT_SAVED_REGS): Delete macro.
	(deprecated_get_frame_saved_regs): Delete declaration.
	(struct frame_saved_regs): Delete definition.
	* frame.c (deprecated_get_frame_saved_regs): Delete function.
	* config/pa/tm-hppa.h (hppa_frame_init_saved_regs): Declare.
	(hppa_frame_find_saved_regs): Delete declaration.
	(FRAME_FIND_SAVED_REGS): Delete macro.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Define.
	* config/i386/tm-ptx.h (FRAME_FIND_SAVED_REGS): Delete
	FRAME_FIND_SAVED_REGS in comment.
@
text
@d824 1
a824 1
      if (!frame_chain_valid (base, next_frame))
d1249 1
a1249 1
      if (!frame_chain_valid (address, this_frame))
@


1.99
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_func_unwind, get_frame_func): New functions.
	* frame.h (get_frame_func, frame_func_unwind): Declare.
	(struct frame_info): Add field "prev_func" for caching the
	previous frame's function address.
	* arm-tdep.c (arm_frameless_function_invocation): Combine
	get_pc_function_start and get_frame_pc into get_frame_func.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	* s390-tdep.c (s390_function_start): Ditto.
	* rs6000-tdep.c (rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc): Ditto.
	* m68k-tdep.c (m68k_frame_init_saved_regs): Ditto.
	* ia64-tdep.c (ia64_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frameless_signal_p): Ditto.
	(i386_frame_init_saved_regs): Ditto.
	* hppa-tdep.c (hppa_frame_find_saved_regs): Ditto.
	* d10v-tdep.c (d10v_frame_unwind_cache): Combine
	get_pc_function_start and frame_pc_unwind into frame_func_unwind.
	* cris-tdep.c (cris_frame_init_saved_regs): Ditto.
	* blockframe.c (frameless_look_for_prologue): Ditto.
@
text
@a1778 28
#ifdef FRAME_FIND_SAVED_REGS
/* XXX - deprecated.  This is a compatibility function for targets
   that do not yet implement DEPRECATED_FRAME_INIT_SAVED_REGS.  */
/* Find the addresses in which registers are saved in FRAME.  */

void
deprecated_get_frame_saved_regs (struct frame_info *frame,
				 struct frame_saved_regs *saved_regs_addr)
{
  if (frame->saved_regs == NULL)
    {
      frame->saved_regs = (CORE_ADDR *)
	frame_obstack_zalloc (SIZEOF_FRAME_SAVED_REGS);
    }
  if (saved_regs_addr == NULL)
    {
      struct frame_saved_regs saved_regs;
      FRAME_FIND_SAVED_REGS (frame, saved_regs);
      memcpy (frame->saved_regs, &saved_regs, SIZEOF_FRAME_SAVED_REGS);
    }
  else
    {
      FRAME_FIND_SAVED_REGS (frame, *saved_regs_addr);
      memcpy (frame->saved_regs, saved_regs_addr, SIZEOF_FRAME_SAVED_REGS);
    }
}
#endif

@


1.98
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (legacy_get_prev_frame): Link prev to next at the
	function start.  Update comments.
@
text
@d193 17
@


1.97
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_frame_id): Update comment.
	(legacy_get_prev_frame): Update comment.
	* gdbarch.sh: Delete check for EXTRA_FRAME_INFO.
	* gdbarch.h: Regenerate.
	* config/sparc/tm-sparc.h (EXTRA_FRAME_INFO): Delete.
	* frame.h: Delete #ifdef EXTRA_FRAME_INFO code.
@
text
@d1032 1
a1032 4
  /* Allocate the new frame but do not wire it in to the frame chain.
     Some (bad) code in INIT_FRAME_EXTRA_INFO tries to look along
     frame->next to pull some fancy tricks (of course such code is, by
     definition, recursive).  Try to prevent it.
d1042 11
a1165 1
      prev->next = this_frame;
a1239 1
  prev->next = this_frame;
@


1.96
log
@2003-04-04  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Do not call frame_type_from_pc.  Set
	the frame's type from the unwinder.
	(get_frame_type): Map UNKNOWN_FRAME onto NORMAL_FRAME.
	(create_new_frame, legacy_get_prev_frame): When the unwinder's
	type isn't UNKNOWN_FRAME, initalize "type" from the unwinder.
	(get_frame_base_address): Use get_frame_type.
	(get_frame_locals_address, get_frame_args_address): Ditto.
	(legacy_saved_regs_unwinder): Set the type to UNKNOWN_TYPE.
	* frame.h (enum frame_type): Add UNKNOWN_FRAME.
	(struct frame_info): Add comment explaining why the frame contains
	a "type" field.
	* dummy-frame.c (dummy_frame_unwind): Set the type to DUMMY_FRAME.
	* d10v-tdep.c (d10v_frame_unwind): Set the type to NORMAL_FRAME.
	* sentinel-frame.c (sentinel_frame_unwinder): Set the type to
	NORMAL_FRAME.
	* frame-unwind.h: Include "frame.h".
	(struct frame_unwind): Add "type" field.
	* Makefile.in (frame_unwind_h): Add $(frame_h).
@
text
@d68 1
a68 3
	 store the frame ID in PREV_FRAME.  Unfortunatly, some
	 architectures (HP/UX) still reply on EXTRA_FRAME_INFO and,
	 hence, still poke at the "struct frame_info" object directly.  */
d1151 1
a1151 3
	 store the frame ID in PREV_FRAME.  Unfortunatly, some
	 architectures (HP/UX) still reply on EXTRA_FRAME_INFO and,
	 hence, still poke at the "struct frame_info" object directly.  */
@


1.95
log
@2003-04-04  Andrew Cagney  <cagney@@redhat.com>

	* x86-64-tdep.c (x86_64_unwind_dummy_id): Use frame_id_build.
	* dummy-frame.c (dummy_frame_this_id): Use frame_id_build.
	* d10v-tdep.c (d10v_frame_this_id): Use get_frame_pc and
	get_frame_base.
	(d10v_unwind_dummy_id): Use frame_id_build.
	* frame.c (find_frame_sal): Use get_frame_pc.
	(create_new_frame): Use deprecated_update_frame_pc_hack and
	deprecated_update_frame_base_hack.
	(create_sentinel_frame): Add comment about ->pc going away.
	(get_prev_frame): Add comment about ->pc going away.
	(legacy_get_prev_frame): Use get_frame_base, get_frame_pc,
	frame_id_build, deprecated_update_frame_pc_hack and
	deprecated_update_frame_base_hack.
	(select_frame): Use get_frame_pc.
	(legacy_saved_regs_this_id): Use frame_id_build.
@
text
@d822 2
d965 9
a973 1
  fi->type = frame_type_from_pc (pc);
a979 3
  /* Select/initialize an unwind function.  */
  fi->unwind = frame_unwind_find_by_pc (current_gdbarch, get_frame_pc (fi));

d1057 1
a1057 1
  prev->type = NORMAL_FRAME;
a1092 1
      prev->type = frame_type_from_pc (get_frame_pc (prev));
d1094 7
a1100 3
      /* Set the unwind functions based on that identified PC.  */
      prev->unwind = frame_unwind_find_by_pc (current_gdbarch,
					      get_frame_pc (prev));
d1349 8
a1594 1
  prev_frame->type = frame_type_from_pc (prev_frame->pc);
d1600 11
d1680 1
a1680 1
  if (fi->type != NORMAL_FRAME)
d1695 1
a1695 1
  if (fi->type != NORMAL_FRAME)
d1713 1
a1713 1
  if (fi->type != NORMAL_FRAME)
d1747 4
a1750 1
  return frame->type;
@


1.94
log
@2003-04-04  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (create_sentinel_frame): Initialize the sentinel frame's
	ID to NULL.
@
text
@d73 1
a73 1
  return frame_id_build (fi->frame, fi->pc);
d514 2
d650 1
a650 1
      s = find_pc_symtab (fi->pc);
d765 1
a765 2
      (*id).base = read_fp ();
      (*id).pc = read_pc ();
d818 1
a818 2
  id->pc = pc;
  id->base = base;
a961 2
  fi->frame = addr;
  fi->pc = pc;
d964 2
d971 1
a971 1
  fi->unwind = frame_unwind_find_by_pc (current_gdbarch, fi->pc);
d1076 2
a1077 2
      prev->pc = frame_pc_unwind (this_frame);
      if (prev->pc == 0)
d1086 1
a1086 1
      prev->type = frame_type_from_pc (prev->pc);
d1089 2
a1090 1
      prev->unwind = frame_unwind_find_by_pc (current_gdbarch, prev->pc);
d1121 1
a1121 2
	  prev->id.base = read_fp ();
	  prev->id.pc = read_pc ();
d1146 2
d1228 1
a1228 1
  prev->frame = address;
d1304 3
a1306 1
    prev->pc = (DEPRECATED_INIT_FRAME_PC_FIRST (fromleaf, prev));
d1315 3
a1317 1
    prev->pc = DEPRECATED_INIT_FRAME_PC (fromleaf, prev);
d1324 2
a1325 2
  if (prev->frame == this_frame->frame
      && prev->pc == this_frame->pc)
d1336 2
a1337 1
  prev->unwind = frame_unwind_find_by_pc (current_gdbarch, prev->pc);
d1349 2
a1350 2
	  ? DEPRECATED_PC_IN_CALL_DUMMY (prev->pc, 0, 0)
	  : pc_in_dummy_frame (prev->pc)))
d1361 2
a1362 2
      find_pc_partial_function (prev->pc, &name, NULL, NULL);
      if (PC_IN_SIGTRAMP (prev->pc, name))
d1565 2
d1630 1
a1630 1
  (*sal) = find_pc_line (frame->pc, pc_notcurrent (frame));
@


1.93
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	Add frame debug info addresses:
	* frame-base.c: New file.
	* frame-base.h: New file.
	* frame.h (struct frame_base): Add opaque declaration.
	(get_frame_base): Update comment.
	(get_frame_base_address): Declare.
	(get_frame_locals_address): Declare.
	(get_frame_args_address): Declare.
	(struct frame_info): Add "base" and "base_cache".  Update
	comments on the unwinder.
	* frame.c: Include "frame-base.h".
	(get_frame_locals_address): New function.
	(get_frame_base_address): New function.
	(get_frame_args_address): New function.
	* findvar.c (read_var_value): Use get_frame_locals_address and
	get_frame_args_address.
	* stack.c (frame_info): Use get_frame_locals_address and
	get_frame_args_address.
	(FRAME_ARGS_ADDRESS_CORRECT): Delete conditionally defined macro,
	moved to "frame-base.c".
	* printcmd.c (print_frame_nameless_args): Ditto.
	* symtab.h (address_class): Update comments.
	* dwarf2loc.c (dwarf_expr_frame_base): Add note about
	get_frame_base_address.
	* dwarf2expr.c (execute_stack_op): Ditto.
	* Makefile.in (frame_base_h): Define.
	(frame.o): Update dependencies.
	(frame-base.o): Add dependencies.
	(SFILES): Add frame-base.c.
	(COMMON_OBS): Add frame-base.o.
@
text
@d515 4
@


1.93.2.1
log
@2003-04-03  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_id_eq): Update.  Compare function addresses.
	(get_frame_func): New function.
	(frame_func_unwind): New function.
	(legacy_get_prev_frame): Move linking of prev to next to the start
	of the function.
	(frame_id_p): Update.
	(get_frame_id): Return the frame's "id".  Do not set "frame".
	(frame_id_build): Update.
	(frame_id_inner): Update.
	(create_sentinel_frame): Do not set the "pc".
	(select_frame): Use get_frame_pc.
	(legacy_saved_regs_this_id): Use frame_id_build.
	(create_new_frame): Set the frame's ID.  Store the PC in the
	sentinel frame's PC unwind cache.
	(legacy_get_prev_frame): Do not set "pc" or "frame".  Instead use
	frame_pc_unwind, frame_id_build, deprecated_update_frame_pc_hack,
	and deprecated_update_frame_base_hack.
	(get_prev_frame): Do not set "pc" or "frame", instead use
	frame_pc_unwind.
	(get_frame_pc): Use frame_pc_unwind.
	(find_frame_sal): Use get_frame_pc.
	(get_frame_base): Return the frame ID's stack address.
	(deprecated_update_frame_base_hack): Set the frame ID's stack
	address.
	(frame_id_eq, frame_id_p, frame_id_inner, get_frame_id): Add debug
	print statements.

	* d10v-tdep.c (d10v_frame_unwind_cache): Use frame_func_unwind.
	(d10v_frame_this_id): Get the frame's function.
	(d10v_frame_this_id): Use frame_id_eq.
	(d10v_unwind_dummy_id): Use frame_id_build.

	* stack.c (print_frame_info): Use get_frame_pc.

	* dummy-frame.c (dummy_frame_this_id): Use frame_id_build.  Update
	parameter to find_dummy_frame.

	* breakpoint.c (print_one_breakpoint): Update.

	* frame.h (struct frame_id): Rename "base" to "stack_addr",
	replace "pc" with "func_addr".
	(frame_id_build): Update parameter names and comment.
	(struct frame_info): Delete "frame" and "pc" fields.
	(frame_func_unwind): Declare.
	(get_frame_func): Declare.
	(struct frame_info): Add field "func".
@
text
@a50 17
/* Utility to print a frame ID.  */
static void
fprint_frame_id (struct ui_file *file, struct frame_id id)
{
  fprintf_unfiltered (file, "stack=0x%s func=0x%s",
		      paddr (id.stack_addr),
		      paddr (id.func_addr));
}

static void
fprint_frame (struct ui_file *file, struct frame_info *fi)
{
  fprintf_unfiltered (gdb_stdlog, "frame %d @@0x%s: ID ",
		      fi->level, paddr (get_frame_pc (fi)));
  fprint_frame_id (gdb_stdlog, fi->id);
}

d67 5
a71 5
      if (frame_debug)
	{
	  fprint_frame (gdb_stdlog, fi);
	  fprintf_unfiltered (gdb_stdlog, "\n");
	}
d73 1
a73 1
  return fi->id;
d79 1
a79 1
frame_id_build (CORE_ADDR stack_addr, CORE_ADDR func_addr)
d82 2
a83 2
  id.stack_addr = stack_addr;
  id.func_addr = func_addr;
a89 1
  int p;
d91 1
a91 12
  p = (l.stack_addr != 0);
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "ID ");
      fprint_frame_id (gdb_stdlog, l);
      if (p)
	fprintf_unfiltered (gdb_stdlog, " .OK");
      else
	fprintf_unfiltered (gdb_stdlog, " !OK");
      fprintf_unfiltered (gdb_stdlog, "\n");
    }
  return p;
d97 6
a102 29
  int eq;
  /* Compare stacks.  The stack addresses must always match and can
     never be zero.  */
  if (l.stack_addr == 0 || r.stack_addr == 0)
    eq = 0;
  else if (l.stack_addr != r.stack_addr)
    eq = 0;
  /* Compare functions.  A zero function address acts like a wild
     card, otherwize a perfect match is expected.  */
  else if (l.func_addr == 0 || r.func_addr == 0)
    eq = 1;
  else if (l.func_addr == r.func_addr)
    eq = 1;
  else
    /* No luck.  */
    eq = 0;
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "ID ");
      fprint_frame_id (gdb_stdlog, l);
      if (eq)
	fprintf_unfiltered (gdb_stdlog, " .EQ ");
      else
	fprintf_unfiltered (gdb_stdlog, " !EQ ");
      fprintf_unfiltered (gdb_stdlog, "ID ");
      fprint_frame_id (gdb_stdlog, r) ;
      fprintf_unfiltered (gdb_stdlog, "\n");
   }
  return eq;
a107 1
  int inner;
d112 1
a112 12
  inner = gdbarch_inner_than (current_gdbarch, l.stack_addr, r.stack_addr);
  if (frame_debug)
    {
      fprint_frame_id (gdb_stdlog, l);
      if (inner)
	fprintf_unfiltered (gdb_stdlog, " .INNER ");
      else
	fprintf_unfiltered (gdb_stdlog, " !INNER ");
      fprint_frame_id (gdb_stdlog, r);
      fprintf_unfiltered (gdb_stdlog, "\n");
    }
  return inner;
a194 18
CORE_ADDR
frame_func_unwind (struct frame_info *this_frame)
{
  if (!this_frame->func.p)
    {
      CORE_ADDR pc = frame_pc_unwind (this_frame);
      this_frame->func.cache = get_pc_function_start (pc);
    }
  return this_frame->func.cache;
}

CORE_ADDR
get_frame_func (struct frame_info *this_frame)
{
  return frame_func_unwind (this_frame->next);
}


a505 6
  /* Give it a really large frame ID.  */
  frame->id_p = 1;
  if (INNER_THAN (1, 2))
    frame->id = frame_id_build (0, 0);
  else
    frame->id = frame_id_build (-1, 0);
d509 6
a587 4
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "Oops!\n");
	    }
d644 1
a644 1
      s = find_pc_symtab (get_frame_pc (fi));
d759 2
a760 1
      (*id) = frame_id_build (read_fp (), 0 /*read_pc ()*/);
d813 2
a814 1
  (*id) = frame_id_build (base, 0 /*pc*/);
d958 2
a959 8
  /* FIXME: cagney/2003-04-02: Should this instead try to map that pc
     onto a function.  */
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog, "create new frame\n");

  fi->id = frame_id_build (addr, pc);
  fi->id_p = 1;

a960 3
  fi->next->pc_unwind_cache = pc;
  fi->next->pc_unwind_cache_p = 1;

d967 1
a967 1
  fi->unwind = frame_unwind_find_by_pc (current_gdbarch, get_frame_pc (fi));
a1035 7
  /* Link prev to this.  This ensures that functions such as
     get_frame_pc(), called by all the deprecated init functions
     below, and implemented using frame_pc_unwind (prev->next) work.
     Don't link this to prev as this stops functions walking up the
     frame chain to this partially initialized method.  */
  prev->next = this_frame;

d1072 2
a1073 1
      if (frame_pc_unwind (this_frame) == 0)
d1082 1
a1082 1
      prev->type = frame_type_from_pc (frame_pc_unwind (this_frame));
d1085 1
a1085 2
      prev->unwind = frame_unwind_find_by_pc (current_gdbarch,
					      frame_pc_unwind (this_frame));
d1116 2
a1117 1
	  prev->id = frame_id_build (read_fp (), read_pc ());
d1138 6
d1146 1
a1159 10

      if (prev->type == NORMAL_FRAME)
	prev->id.func_addr = get_pc_function_start (prev->id.func_addr);

      if (frame_debug)
	{
	  fprint_frame (gdb_stdlog, prev);
	  fprintf_unfiltered (gdb_stdlog, "\n");
	}

d1222 1
a1222 1
  deprecated_update_frame_base_hack (prev, address);
d1298 1
a1298 2
    deprecated_update_frame_pc_hack
      (prev, DEPRECATED_INIT_FRAME_PC_FIRST (fromleaf, prev));
d1307 1
a1307 2
    deprecated_update_frame_pc_hack
      (prev, DEPRECATED_INIT_FRAME_PC (fromleaf, prev));
d1314 2
a1315 2
  if (this_frame->level > 0
      && frame_id_eq (get_frame_id (prev), get_frame_id (this_frame)))
d1326 1
a1326 2
  prev->unwind = frame_unwind_find_by_pc (current_gdbarch,
					  get_frame_pc (prev));
d1338 2
a1339 2
	  ? DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (prev), 0, 0)
	  : pc_in_dummy_frame (get_frame_pc (prev))))
d1350 2
a1351 3
      find_pc_partial_function (get_frame_pc (prev),
				&name, NULL, NULL);
      if (PC_IN_SIGTRAMP (get_frame_pc (prev), name))
a1360 11
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "frame %d @@0x%s: ID ",
			  prev->level, paddr (get_frame_pc (prev)));
      fprint_frame_id (gdb_stdlog, prev->id);
      fprintf_unfiltered (gdb_stdlog, "\n");
    }

  if (prev->type == NORMAL_FRAME)
    prev->id.func_addr = get_pc_function_start (prev->id.func_addr);

d1554 2
a1555 1
  if (frame_pc_unwind (this_frame) == 0)
d1564 1
a1564 1
  prev_frame->type = frame_type_from_pc (frame_pc_unwind (this_frame));
d1568 1
a1568 1
						frame_pc_unwind (this_frame));
d1594 1
a1594 1
  return frame_pc_unwind (frame->next);
d1617 1
a1617 1
  (*sal) = find_pc_line (get_frame_pc (frame), pc_notcurrent (frame));
d1625 7
a1631 1
  return get_frame_id (fi).stack_addr;
d1760 2
d1779 2
a1780 2
  frame->id_p = 1;
  frame->id.stack_addr = base;
@


1.93.2.2
log
@2003-04-03  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (legacy_get_prev_frame): Revert a frame_id_eq test,
	instead comparing the frame PCs.
@
text
@d1418 2
a1419 4
  /* NOTE: cagney/2003-04-04: Don't convert this to frame_id_eq.  At
     this stage the ID's address is not valid, so need to use the pc.  */
  if (prev->id.stack_addr == this_frame->id.stack_addr
      && get_frame_pc (prev) == get_frame_pc (this_frame))
@


1.93.2.3
log
@Merge with mainline.
@
text
@d51 1
d55 3
a57 26
  fprintf_unfiltered (file, "{stack=0x%s,code=0x%s}",
		      paddr_nz (id.stack_addr),
		      paddr_nz (id.code_addr));
}

static void
fprint_frame_type (struct ui_file *file, enum frame_type type)
{
  switch (type)
    {
    case UNKNOWN_FRAME:
      fprintf_unfiltered (file, "UNKNOWN_FRAME");
      return;
    case NORMAL_FRAME:
      fprintf_unfiltered (file, "NORMAL_FRAME");
      return;
    case DUMMY_FRAME:
      fprintf_unfiltered (file, "DUMMY_FRAME");
      return;
    case SIGTRAMP_FRAME:
      fprintf_unfiltered (file, "SIGTRAMP_FRAME");
      return;
    default:
      fprintf_unfiltered (file, "<unknown type>");
      return;
    };
d63 3
a65 35
  if (fi == NULL)
    {
      fprintf_unfiltered (file, "<NULL frame>");
      return;
    }
  fprintf_unfiltered (file, "{");
  fprintf_unfiltered (file, "level=%d", fi->level);
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "type=");
  fprint_frame_type (file, fi->type);
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "unwind=");
  if (fi->unwind != NULL)
    gdb_print_host_address (fi->unwind, file);
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "pc=");
  if (fi->next != NULL && fi->next->prev_pc.p)
    fprintf_unfiltered (file, "0x%s", paddr_nz (fi->next->prev_pc.value));
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "id=");
  if (fi->this_id.p)
    fprint_frame_id (file, fi->this_id.value);
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "func=");
  if (fi->next != NULL && fi->next->prev_func.p)
    fprintf_unfiltered (file, "0x%s", paddr_nz (fi->next->prev_func.addr));
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, "}");
d78 1
a78 1
  if (!fi->this_id.p)
a80 3
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog, "{ get_frame_id (fi=%d) ",
			    fi->level);
d82 2
a83 2
      fi->unwind->this_id (fi->next, &fi->prologue_cache, &fi->this_id.value);
      fi->this_id.p = 1;
d86 2
a87 3
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame_id (gdb_stdlog, fi->this_id.value);
	  fprintf_unfiltered (gdb_stdlog, " }\n");
d90 1
a90 1
  return fi->this_id.value;
d96 1
a96 1
frame_id_build (CORE_ADDR stack_addr, CORE_ADDR code_addr)
d100 1
a100 1
  id.code_addr = code_addr;
d108 1
a108 1
  /* The .code can be NULL but the .stack cannot.  */
d112 1
a112 1
      fprintf_unfiltered (gdb_stdlog, "{ frame_id_p (l=");
d114 5
a118 1
      fprintf_unfiltered (gdb_stdlog, ") -> %d }\n", p);
d127 2
a129 1
    /* Like a NaN, if either ID is invalid, the result is false.  */
a131 1
    /* If .stack addresses are different, the frames are different.  */
d133 3
a135 2
  else if (l.code_addr == 0 || r.code_addr == 0)
    /* A zero code addr is a wild card, always succeed.  */
d137 1
a137 2
  else if (l.code_addr == r.code_addr)
    /* The .stack and .code are identical, the ID's are identical.  */
d144 1
a144 1
      fprintf_unfiltered (gdb_stdlog, "{ frame_id_eq (l=");
d146 8
a153 4
      fprintf_unfiltered (gdb_stdlog, ",r=");
      fprint_frame_id (gdb_stdlog, r);
      fprintf_unfiltered (gdb_stdlog, ") -> %d }\n", eq);
    }
d161 5
a165 9
  if (l.stack_addr == 0 || r.stack_addr == 0)
    /* Like NaN, any operation involving an invalid ID always fails.  */
    inner = 0;
  else
    /* Only return non-zero when strictly inner than.  Note that, per
       comment in "frame.h", there is some fuzz here.  Frameless
       functions are not strictly inner than (same .stack but
       different .code).  */
    inner = INNER_THAN (l.stack_addr, r.stack_addr);
a167 1
      fprintf_unfiltered (gdb_stdlog, "{ frame_id_inner (l=");
d169 4
a172 1
      fprintf_unfiltered (gdb_stdlog, ",r=");
d174 1
a174 1
      fprintf_unfiltered (gdb_stdlog, ") -> %d }\n", inner);
d211 1
a211 1
  if (!this_frame->prev_pc.p)
d253 2
a254 7
      this_frame->prev_pc.value = pc;
      this_frame->prev_pc.p = 1;
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "{ frame_pc_unwind (this_frame=%d) -> 0x%s }\n",
			    this_frame->level,
			    paddr_nz (this_frame->prev_pc.value));
d256 1
a256 1
  return this_frame->prev_pc.value;
d260 1
a260 1
frame_func_unwind (struct frame_info *fi)
d262 1
a262 1
  if (!fi->prev_func.p)
d264 2
a265 6
      fi->prev_func.p = 1;
      fi->prev_func.addr = get_pc_function_start (frame_pc_unwind (fi));
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "{ frame_func_unwind (fi=%d) -> 0x%s }\n",
			    fi->level, paddr_nz (fi->prev_func.addr));
d267 1
a267 1
  return fi->prev_func.addr;
d271 1
a271 1
get_frame_func (struct frame_info *fi)
d273 1
a273 1
  return frame_func_unwind (fi->next);
d276 1
a331 7
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "{ frame_register_unwind (frame=%d,regnum=\"%s\",...) ",
			  frame->level, frame_map_regnum_to_name (regnum));
    }

a351 20
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "->");
      fprintf_unfiltered (gdb_stdlog, " *optimizedp=%d", (*optimizedp));
      fprintf_unfiltered (gdb_stdlog, " *lvalp=%d", (int) (*lvalp));
      fprintf_unfiltered (gdb_stdlog, " *addrp=0x%s", paddr_nz ((*addrp)));
      fprintf_unfiltered (gdb_stdlog, " *bufferp=");
      if (bufferp == NULL)
	fprintf_unfiltered (gdb_stdlog, "<NULL>");
      else
	{
	  int i;
	  const char *buf = bufferp;
	  fprintf_unfiltered (gdb_stdlog, "[");
	  for (i = 0; i < register_size (current_gdbarch, regnum); i++)
	    fprintf_unfiltered (gdb_stdlog, "%02x", buf[i]);
	  fprintf_unfiltered (gdb_stdlog, "]");
	}
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }
d588 6
a596 10
  /* Make the sentinel frame's ID valid, but invalid.  That way all
     comparisons with it should fail.  */
  frame->this_id.p = 1;
  frame->this_id.value = null_frame_id;
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ create_sentinel_frame (...) -> ");
      fprint_frame (gdb_stdlog, frame);
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }
d670 4
d845 1
a845 1
      (*id) = frame_id_build (read_fp (), 0);
d889 1
a889 1
      if (!legacy_frame_chain_valid (base, next_frame))
a901 2
  /* Not really.  It gets overridden by legacy_get_prev_frame.  */
  UNKNOWN_FRAME,
a1039 7
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "{ create_new_frame (addr=0x%s, pc=0x%s) ",
			  paddr_nz (addr), paddr_nz (pc));
    }

d1044 5
a1048 2
  fi->this_id.p = 1;
  fi->this_id.value = frame_id_build (addr, pc);
d1051 2
d1054 1
a1054 10
  /* Select/initialize both the unwind function and the frame's type
     based on the PC.  */
  fi->unwind = frame_unwind_find_by_pc (current_gdbarch, pc);
  if (fi->unwind->type != UNKNOWN_FRAME)
    fi->type = fi->unwind->type;
  else
    fi->type = frame_type_from_pc (pc);

  deprecated_update_frame_base_hack (fi, addr);
  deprecated_update_frame_pc_hack (fi, pc);
d1059 2
a1060 6
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, fi);
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }
a1089 2
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog, "{ flush_cached_frames () }\n");
d1116 4
a1119 4
  /* Don't frame_debug print legacy_get_prev_frame() here, just
     confuses the output.  */

  /* Allocate the new frame.
d1129 5
a1133 9
  /* Do not completly wire it in to the frame chain.  Some (bad) code
     in INIT_FRAME_EXTRA_INFO tries to look along frame->prev to pull
     some fancy tricks (of course such code is, by definition,
     recursive).
  
     On the other hand, methods, such as get_frame_pc() and
     get_frame_base() rely on being able to walk along the frame
     chain.  Make certain that at least they work by providing that
     link.  Of course things manipulating prev can't go back.  */
d1146 1
a1146 1
  prev->type = UNKNOWN_FRAME;
d1149 1
a1149 1
  prev->this_id.p = 1;
d1172 1
a1172 2
      deprecated_update_frame_pc_hack (prev, frame_pc_unwind (this_frame));
      if (get_frame_pc (prev) == 0)
d1177 2
a1178 6
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // unwound legacy PC zero }\n");
	    }
d1181 1
d1183 1
a1183 2
      /* Set the unwind functions based on that identified PC.  Ditto
         for the "type" but strongly prefer the unwinder's frame type.  */
d1185 1
a1185 5
					      get_frame_pc (prev));
      if (prev->unwind->type == UNKNOWN_FRAME)
	prev->type = frame_type_from_pc (get_frame_pc (prev));
      else
	prev->type = prev->unwind->type;
d1207 1
a1207 2
	  prev->this_id.value = gdbarch_unwind_dummy_id (current_gdbarch,
							 this_frame);
d1216 1
a1216 1
	  prev->this_id.value = frame_id_build (read_fp (), read_pc ());
d1220 1
a1220 1
      if (!frame_id_p (prev->this_id.value))
d1223 2
a1224 6
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // unwound legacy ID invalid }\n");
	    }
d1254 1
a1254 2
	prev->this_id.value.code_addr
	  = get_pc_function_start (prev->this_id.value.code_addr);
a1257 1
	  fprintf_unfiltered (gdb_stdlog, "-> ");
d1259 1
a1259 1
	  fprintf_unfiltered (gdb_stdlog, " } // legacy innermost frame\n");
d1261 1
d1315 2
a1316 11
      if (!legacy_frame_chain_valid (address, this_frame))
	{
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // legacy frame chain invalid }\n");
	    }
	  return NULL;
	}
d1319 1
a1319 10
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog,
			      " // legacy frame chain NULL }\n");
	}
      return NULL;
    }
d1323 1
d1400 2
a1401 3
    deprecated_update_frame_pc_hack (prev,
				     DEPRECATED_INIT_FRAME_PC_FIRST (fromleaf,
								     prev));
d1410 2
a1411 3
    deprecated_update_frame_pc_hack (prev,
				     DEPRECATED_INIT_FRAME_PC (fromleaf,
							       prev));
d1418 3
a1420 1
  if (get_frame_base (prev) == get_frame_base (this_frame)
a1424 7
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog,
			      " // legacy this.id == prev.id }\n");
	}
a1434 17
  /* If the unwinder provides a frame type, use it.  Otherwize
     continue on to that heuristic mess.  */
  if (prev->unwind->type != UNKNOWN_FRAME)
    {
      prev->type = prev->unwind->type;
      if (prev->type == NORMAL_FRAME)
	prev->this_id.value.code_addr
	  = get_pc_function_start (prev->this_id.value.code_addr);
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, prev);
	  fprintf_unfiltered (gdb_stdlog, " } // legacy with unwound type\n");
	}
      return prev;
    }

d1457 2
a1458 1
      find_pc_partial_function (get_frame_pc (prev), &name, NULL, NULL);
a1468 4
  if (prev->type == NORMAL_FRAME)
    prev->this_id.value.code_addr
      = get_pc_function_start (prev->this_id.value.code_addr);

d1471 4
a1474 3
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, prev);
      fprintf_unfiltered (gdb_stdlog, " } // legacy with confused type\n");
d1477 3
a1491 10
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ get_prev_frame (this_frame=");
      if (this_frame != NULL)
	fprintf_unfiltered (gdb_stdlog, "%d", this_frame->level);
      else
	fprintf_unfiltered (gdb_stdlog, "<NULL>");
      fprintf_unfiltered (gdb_stdlog, ") ");
    }

d1541 2
a1542 1
	fprintf_unfiltered (gdb_stdlog, "-> NULL // inside main func }\n");
d1548 1
a1548 9
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, this_frame->prev);
	  fprintf_unfiltered (gdb_stdlog, " // cached \n");
	}
      return this_frame->prev;
    }
d1576 2
a1577 5
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // inside entry file }\n");
	}
d1594 2
a1595 5
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, "// inside entry func }\n");
	}
d1604 3
d1616 2
a1617 5
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // this ID is NULL }\n");
	}
d1678 2
a1679 5
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // unwound PC zero }\n");
	}
d1682 1
a1687 11
  /* FIXME: cagney/2003-04-02: Rather than storing the frame's type in
     the frame, the unwinder's type should be returned directly.
     Unfortunatly, legacy code, called by legacy_get_prev_frame,
     explicitly set the frames type using the method
     deprecated_set_frame_type().  */
  gdb_assert (prev_frame->unwind->type != UNKNOWN_FRAME);
  prev_frame->type = prev_frame->unwind->type;

  /* Can the frame's type and unwinder be computed on demand?  That
     would make a frame's creation really really lite!  */

a1705 7
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, prev_frame);
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }

a1711 1
  gdb_assert (frame->next != NULL);
d1751 1
a1751 1
  if (get_frame_type (fi) != NORMAL_FRAME)
d1766 1
a1766 1
  if (get_frame_type (fi) != NORMAL_FRAME)
d1784 1
a1784 1
  if (get_frame_type (fi) != NORMAL_FRAME)
d1818 1
a1818 4
  if (frame->type == UNKNOWN_FRAME)
    return NORMAL_FRAME;
  else
    return frame->type;
d1828 28
a1871 4
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog,
			"{ deprecated_update_frame_pc_hack (frame=%d,pc=0x%s) }\n",
			frame->level, paddr_nz (pc));
d1881 2
a1882 2
      frame->next->prev_pc.value = pc;
      frame->next->prev_pc.p = 1;
d1889 2
a1890 6
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog,
			"{ deprecated_update_frame_base_hack (frame=%d,base=0x%s) }\n",
			frame->level, paddr_nz (base));
  /* See comment in "frame.h".  */
  frame->this_id.value.stack_addr = base;
@


1.92
log
@	* frame.c (get_prev_frame): Disable call to inside_entry_file().
@
text
@d39 1
d1632 52
@


1.91
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@d1431 1
d1443 9
d1460 1
@


1.90
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_frame_base): Force ID initialization.
	(get_prev_frame): Move computation of the frame ID from here ...
	(get_frame_id): ... to here.
	(legacy_get_prev_frame): Mark the frame ID as valid.
	* frame.h (struct frame_info): Add field "id_p".
@
text
@d1098 1
a1098 1
	  /* Assume hand_function_call(), via SAVE_DUMMY_FRAME_TOS,
@


1.89
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Delay validating a frame's ID -
	non-NULL, didn't go backwards - until an attempt to unwind it to
	the previous frame.
@
text
@d60 1
a60 1
  else
d62 9
a70 4
      struct frame_id id;
      id.base = fi->frame;
      id.pc = fi->pc;
      return id;
d72 1
d1047 3
d1558 1
a1558 18
  /* Find the prev's frame's ID.  */

  /* The callee expects to be invoked with:

     this->unwind->this_id (this->next, &this->cache, &this->id);

     The below is carefully shifted one frame `to the left' so that
     both the unwind->this_id and unwind->prev_register methods are
     consistently invoked with NEXT_FRAME and THIS_PROLOGUE_CACHE.
       
     Also note that, while the PC for this new previous frame was
     unwound first (see above), the below is the first call that
     [potentially] requires analysis of the new previous frame's
     prologue.  Consequently, it is this call, that typically ends up
     initializing the previous frame's prologue cache.  */
  prev_frame->unwind->this_id (this_frame,
			       &prev_frame->prologue_cache,
			       &prev_frame->id);
a1571 6
  /* FIXME: cagney/2002-12-18: Instead of this hack, should only store
     the frame ID in PREV_FRAME.  Unfortunatly, some architectures
     (HP/UX) still reply on EXTRA_FRAME_INFO and, hence, still poke at
     the "struct frame_info" object directly.  */
  prev_frame->frame = prev_frame->id.base;

d1613 6
@


1.89.2.1
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	Add frame debug info addresses:
	* frame-base.c: New file.
	* frame-base.h: New file.
	* frame.h (struct frame_base): Add opaque declaration.
	(get_frame_base): Update comment.
	(get_frame_base_address): Declare.
	(get_frame_locals_address): Declare.
	(get_frame_args_address): Declare.
	(struct frame_info): Add "base" and "base_cache".  Update
	comments on the unwinder.
	* frame.c: Include "frame-base.h".
	(get_frame_locals_address): New function.
	(get_frame_base_address): New function.
	(get_frame_args_address): New function.
	* findvar.c (read_var_value): Use get_frame_locals_address.
	* stack.c (frame_info): Use get_frame_locals_address and
	get_frame_args_address.
	(FRAME_ARGS_ADDRESS_CORRECT): Delete conditionally defined macro,
	moved to "frame-base.c".
	* Makefile.in (frame_base_h): Define.
	(frame.o): Update dependencies.
	(d10v-tdep.o): Update dependencies.
	(frame-base.o): Add dependencies.
	(SFILES): Add frame-base.c.
	(COMMON_OBS): Add frame-base.o.
	* printcmd.c (print_frame_nameless_args): Ditto.
	* symtab.h (address_class): Update comments.
	* dwarf2loc.c (dwarf_expr_frame_base): Add note about
	get_frame_base_address.
	* dwarf2expr.c (execute_stack_op): Ditto.
	* d10v-tdep.c: Include "frame-base.h".
	(d10v_frame_unwind): Make constant.
	(d10v_frame_base_address): New function.
	(d10v_frame_base): New variable.
	(d10v_gdbarch_init): Set frame_base default.
@
text
@a38 1
#include "frame-base.h"
a1627 52
}

/* High-level offsets into the frame.  Used by the debug info.  */

CORE_ADDR
get_frame_base_address (struct frame_info *fi)
{
  if (fi->type != NORMAL_FRAME)
    return 0;
  if (fi->base == NULL)
    fi->base = frame_base_find_by_pc (current_gdbarch, get_frame_pc (fi));
  /* Sneaky: If the low-level unwind and high-level base code share a
     common unwinder, let them share the prologue cache.  */
  if (fi->base->unwind == fi->unwind)
    return fi->base->this_base (fi->next, &fi->prologue_cache);
  return fi->base->this_base (fi->next, &fi->base_cache);
}

CORE_ADDR
get_frame_locals_address (struct frame_info *fi)
{
  void **cache;
  if (fi->type != NORMAL_FRAME)
    return 0;
  /* If there isn't a frame address method, find it.  */
  if (fi->base == NULL)
    fi->base = frame_base_find_by_pc (current_gdbarch, get_frame_pc (fi));
  /* Sneaky: If the low-level unwind and high-level base code share a
     common unwinder, let them share the prologue cache.  */
  if (fi->base->unwind == fi->unwind)
    cache = &fi->prologue_cache;
  else
    cache = &fi->base_cache;
  return fi->base->this_locals (fi->next, cache);
}

CORE_ADDR
get_frame_args_address (struct frame_info *fi)
{
  void **cache;
  if (fi->type != NORMAL_FRAME)
    return 0;
  /* If there isn't a frame address method, find it.  */
  if (fi->base == NULL)
    fi->base = frame_base_find_by_pc (current_gdbarch, get_frame_pc (fi));
  /* Sneaky: If the low-level unwind and high-level base code share a
     common unwinder, let them share the prologue cache.  */
  if (fi->base->unwind == fi->unwind)
    cache = &fi->prologue_cache;
  else
    cache = &fi->base_cache;
  return fi->base->this_args (fi->next, cache);
@


1.88
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@d1470 32
d1568 11
a1578 32
  /* Check that the unwound ID is valid.  */
  if (!frame_id_p (prev_frame->id))
    {
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - unwound frame ID invalid\n");
      return NULL;
    }

  /* Check that the new frame isn't inner to (younger, below, next)
     the old frame.  If that happens the frame unwind is going
     backwards.  */
  /* FIXME: cagney/2003-02-25: Ignore the sentinel frame since that
     doesn't have a valid frame ID.  Should instead set the sentinel
     frame's frame ID to a true `sentinel'.  Leave it until after the
     switch to storing the frame ID, instead of the frame base, in the
     frame object.  */
  if (this_frame->level >= 0
      && frame_id_inner (prev_frame->id, get_frame_id (this_frame)))
    error ("Unwound frame inner-to selected frame (corrupt stack?)");

  /* FIXME: cagney/2003-03-14: Should check that this and next frame's
     IDs are different (i.e., !frame_id_eq()).  Can't yet do that as
     the EQ function doesn't yet compare PC values.  */

  /* FIXME: cagney/2003-03-14: Should delay the evaluation of the
     frame ID until when it is needed.  That way the inner most frame
     can be created without needing to do prologue analysis.  */

  /* Note that, due to frameless functions, the stronger test of the
     new frame being outer to the old frame can't be used - frameless
     functions differ by only their PC value.  */
@


1.87
log
@2003-03-17  Andrew Cagney  <cagney@@redhat.com>

	Fix frame off-by-one bug.
	* frame-unwind.h (frame_this_id_ftype): Replace
	frame_unwind_id_ftype.
	(frame_prev_register_ftype): Replace frame_unwind_reg_ftype.
	(struct frame_unwind): Replace "id" with "this_id".  Replace "reg"
	with "prev_register".
	* frame-unwind.c (frame_unwind_find_by_pc): Return
	legacy_saved_regs_unwind instead of trad_frame_unwind.  Update
	comment.
	* dummy-frame.c (cached_find_dummy_frame): Delete function.
	(dummy_frame_this_id): Replace dummy_frame_id_unwind.
	(dummy_frame_prev_register): Replace dummy_frame_register_unwind.
	(dummy_frame_unwind): Update.
	* sentinel-frame.c (sentinel_frame_prev_register): Replace
	sentinel_frame_register_unwind.
	(sentinel_frame_this_id): Replace sentinel_frame_id_unwind.
	(sentinel_frame_unwinder): Update.
	* frame.h (legacy_saved_regs_unwind): Replace trad_frame_unwind.
	(struct frame_info): Rename "unwind_cache" to "prologue_cache".
	* frame.c (create_sentinel_frame): Update. Initialize
	"prologue_cache" instead of "unwind_cache".
	(frame_register_unwind): Call this frame's prev_register with the
	next frame and this frame's prologue cache.
	(get_prev_frame): Simplify.  Always call prev frame's this_id with
	this frame and prev frame's prologue cache.  Document that this
	call is shifted one to the left when compared to the
	frame_register_unwind call.
	(legacy_saved_regs_prev_register): Replace
	frame_saved_regs_register_unwind.
	(legacy_saved_regs_this_id): Replace frame_saved_regs_id_unwind.
	(legacy_saved_regs_unwinder): Replace trad_frame_unwinder.
	(legacy_saved_regs_unwind): Replace trad_frame_unwind.
	* d10v-tdep.c (d10v_frame_this_id): Replace d10v_frame_id_unwind.
	(d10v_frame_unwind): Update.
	(d10v_frame_prev_register): Replace d10v_frame_register_unwind.
	(d10v_frame_unwind_cache): Replace this "fi" with "next_frame".
	(saved_regs_unwinder): Replace this "frame" with "next_frame", and
	"saved_regs" with "this_saved_regs".
@
text
@d794 2
a795 2
      gdb_assert (FRAME_CHAIN_P ());
      base = FRAME_CHAIN (next_frame);
d1051 3
a1053 2
	 frame_pc_unwind (nee, FRAME_SAVED_PC) and FRAME_CHAIN()) assume
	 THIS_FRAME's data structures have already been initialized (using
d1200 2
a1201 2
      gdb_assert (FRAME_CHAIN_P ());
      address = FRAME_CHAIN (this_frame);
d1248 5
a1252 4
     mips) it is really awkward to have FRAME_CHAIN_VALID called
     BEFORE DEPRECATED_INIT_EXTRA_FRAME_INFO (there is no good way to
     get information deduced in FRAME_CHAIN_VALID into the extra
     fields of the new frame).  std_frame_pc(fromleaf, prev)
d1278 8
a1285 7
     The irony here though, is that FRAME_CHAIN(), at least for a more
     up-to-date architecture, always calls FRAME_SAVED_PC(), and
     FRAME_SAVED_PC() computes the PC but without first needing the
     frame!  Instead of the convolution below, we could have simply
     called FRAME_SAVED_PC() and been done with it!  Note that
     FRAME_SAVED_PC() is being superseed by frame_pc_unwind() and that
     function does have somewhere to cache that PC value.  */
d1301 3
a1303 2
     check this in FRAME_CHAIN or thereabouts, but it seems like there
     is no reason this can't be an architecture-independent check.  */
d1490 3
a1492 2
     frame_pc_unwind (nee, FRAME_SAVED_PC) and FRAME_CHAIN()) assume
     THIS_FRAME's data structures have already been initialized (using
d1790 1
a1790 1
	  || FRAME_CHAIN_P ()
@


1.87.2.1
log
@2003-03-17  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_frame_id): If the frame's ID isn't valid, get it.
	(get_prev_frame): Validate THIS frame's ID before trying to unwind
	to prev frame.  Don't compute PREV's frame's ID.
	(get_frame_base): Force the update of frame ID before returning
	the frame.
	* frame.h (struct frame_info): Add "id_p".
@
text
@a55 1
  struct frame_id id;
a57 1
      /* Should never happen!  */
d60 1
a60 1
  if (!fi->id_p)
d62 4
a65 32
      gdb_assert (!legacy_frame_p (current_gdbarch));

      /* Find THIS frame's ID.  */
      fi->unwind->this_id (fi->next, &fi->prologue_cache, &fi->id);
      fi->id_p = 1;

      /* Check that the unwound ID is valid.  */
      if (!frame_id_p (fi->id) && frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Unwound frame ID invalid\n");

      /* Check that the new frame isn't inner to (younger, below, next)
	 the old frame.  If that happens the frame unwind is going
	 backwards.  */
      /* FIXME: cagney/2003-02-25: Ignore the sentinel frame since
	 that doesn't have a valid frame ID.  Should instead set the
	 sentinel frame's frame ID to a true `sentinel'.  Leave it
	 until after the switch to storing the frame ID, instead of
	 the frame base, in the frame object.  */
      if (fi->level >= 0 && frame_id_p (fi->id) && fi->next->id_p
	  && frame_id_inner (fi->id, get_frame_id (fi->next)))
	error ("Unwound frame inner-to selected frame (corrupt stack?)");

      /* Note that, due to frameless functions, the stronger test of
	 the new frame being outer to the old frame can't be used -
	 frameless functions differ by only their PC value.  */

      /* FIXME: cagney/2002-12-18: Instead of this hack, should only
	 store the frame ID in PREV_FRAME.  Unfortunatly, some
	 architectures (HP/UX) still reply on EXTRA_FRAME_INFO and,
	 hence, still poke at the "struct frame_info" object directly.  */
      fi->frame = fi->id.base;
a66 3
  id.base = fi->frame;
  id.pc = fi->pc;
  return id;
a1454 33
  /* If THIS frame ended up with a NULL frame ID, don't bother trying
     to unwind it.  */
  if (this_frame->level >= 0 && !frame_id_p (get_frame_id (this_frame)))
    {
      if (frame_debug)
 	fprintf_filtered (gdb_stdlog,
 			  "Outermost frame - next ID is NULL\n");
      return NULL;
    }

  /* Check that THIS frame isn't inner to (younger, below, next) the
     NEXT frame.  If that happens the frame unwind went backwards.  */
  /* FIXME: cagney/2003-02-25: Instead of ignoring the sentinel frame
     (since that doesn't have a valid frame ID), the code should set
     the sentinel frame's frame ID to a true `sentinel'.  Leave it
     until after the switch to storing the frame ID, instead of the
     frame base, in the frame object.  */
  if (this_frame->level > 0
      && frame_id_inner (get_frame_id (this_frame),
			 get_frame_id (this_frame->next)))
    error ("This frame inner-to next frame (corrupt stack?)");

  /* Check that THIS and NEXT frame are different.  If they are not,
     there is most likely a stack cycle.  */
  /* FIXME: cagney/2003-03-17: Can't yet do this check. The
     frame_id_eq() method doesn't yet use function addresses when
     comparing IDs.  */
  if (0
      && this_frame->level > 0
      && frame_id_eq (get_frame_id (this_frame),
		      get_frame_id (this_frame->next)))
    error ("This frame identical to next frame (corrupt stack?)");

d1512 57
a1568 1
  /* The PREV's frame ID is computed on-demand in get_frame_id().  */
a1610 6
  if (!fi->id_p)
    {
      /* Force the ID code to (indirectly) initialize the ->frame
         pointer.  */
      get_frame_id (fi);
    }
@


1.86
log
@2003-03-16  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_pop): Don't call target_store_registers.  Fix
	problem reported by Mark Kettenis.
@
text
@d257 6
a262 3
  /* Ask this frame to unwind its register.  */
  frame->unwind->reg (frame, &frame->unwind_cache, regnum,
		      optimizedp, lvalp, addrp, realnump, bufferp);
d496 1
a496 1
  frame->unwind_cache = sentinel_frame_cache (regcache);
d653 13
a665 7
frame_saved_regs_register_unwind (struct frame_info *frame, void **cache,
				  int regnum, int *optimizedp,
				  enum lval_type *lvalp, CORE_ADDR *addrp,
				  int *realnump, void *bufferp)
{
  /* There is always a frame at this point.  And THIS is the frame
     we're interested in.  */
a666 5
  /* If we're using generic dummy frames, we'd better not be in a call
     dummy.  (generic_call_dummy_register_unwind ought to have been called
     instead.)  */
  gdb_assert (!(DEPRECATED_USE_GENERIC_DUMMY_FRAMES
		&& (get_frame_type (frame) == DUMMY_FRAME)));
d704 1
a704 1
	      void **regs = (*cache);
d710 1
a710 1
		  (*cache) = regs;
d730 5
a734 6
  /* No luck, assume this and the next frame have the same register
     value.  Pass the request down the frame chain to the next frame.
     Hopefully that will find the register's location, either in a
     register or in memory.  */
  frame_register (frame, regnum, optimizedp, lvalp, addrp, realnump,
		  bufferp);
d738 3
a740 2
frame_saved_regs_id_unwind (struct frame_info *next_frame, void **cache,
			    struct frame_id *id)
d746 11
d810 3
a812 3
const struct frame_unwind trad_frame_unwinder = {
  frame_saved_regs_id_unwind,
  frame_saved_regs_register_unwind
d814 1
a814 1
const struct frame_unwind *trad_frame_unwind = &trad_frame_unwinder;
a817 1

d1513 20
a1532 1
  switch (prev_frame->type)
d1534 4
a1537 53
    case DUMMY_FRAME:
      /* When unwinding a normal frame, the stack structure is
	 determined by analyzing the frame's function's code (be it
	 using brute force prologue analysis, or the dwarf2 CFI).  In
	 the case of a dummy frame, that simply isn't possible.  The
	 The PC is either the program entry point, or some random
	 address on the stack.  Trying to use that PC to apply
	 standard frame ID unwind techniques is just asking for
	 trouble.  */
      gdb_assert (gdbarch_unwind_dummy_id_p (current_gdbarch));
	/* Assume hand_function_call(), via SAVE_DUMMY_FRAME_TOS,
	   previously saved the dummy frame's ID.  Things only work if
	   the two return the same value.  */
      gdb_assert (SAVE_DUMMY_FRAME_TOS_P ());
      /* Use an architecture specific method to extract the prev's
	 dummy ID from the next frame.  Note that this method uses
	 frame_register_unwind to obtain the register values needed to
	 determine the dummy frame's ID.  */
      prev_frame->id = gdbarch_unwind_dummy_id (current_gdbarch, this_frame);
      break;
    case NORMAL_FRAME:
    case SIGTRAMP_FRAME:
      /* FIXME: cagney/2003-03-04: The below call isn't right.  It
	 should instead be doing something like "prev_frame -> unwind
	 -> id (this_frame, & prev_frame -> unwind_cache, & prev_frame
	 -> id)" but that requires more extensive (pending) changes.  */
      this_frame->unwind->id (this_frame, &this_frame->unwind_cache,
			      &prev_frame->id);
      /* Check that the unwound ID is valid.  */
      if (!frame_id_p (prev_frame->id))
	{
	  if (frame_debug)
	    fprintf_unfiltered (gdb_stdlog,
				"Outermost frame - unwound frame ID invalid\n");
	  return NULL;
	}
      /* Check that the new frame isn't inner to (younger, below,
	 next) the old frame.  If that happens the frame unwind is
	 going backwards.  */
      /* FIXME: cagney/2003-02-25: Ignore the sentinel frame since
	 that doesn't have a valid frame ID.  Should instead set the
	 sentinel frame's frame ID to a `sentinel'.  Leave it until
	 after the switch to storing the frame ID, instead of the
	 frame base, in the frame object.  */
      if (this_frame->level >= 0
	  && frame_id_inner (prev_frame->id, get_frame_id (this_frame)))
	error ("Unwound frame inner-to selected frame (corrupt stack?)");
      /* Note that, due to frameless functions, the stronger test of
	 the new frame being outer to the old frame can't be used -
	 frameless functions differ by only their PC value.  */
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
d1539 24
@


1.85
log
@2003-03-14  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): When a legacy frame, always call
	legacy_get_prev_frame.  Simplify unwind code using assumption that
	the unwinder is new.
	(legacy_get_prev_frame): Handle legacy sentinel frame unwind here.
	(legacy_frame_p): When no gdbarch_unwind_dummy_id, or
	SAVED_DUMMY_FRAME_TOS, assume a legacy frame.
@
text
@d218 8
a232 1
  target_store_registers (-1);
@


1.84
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_saved_register): Delete function.
	* xstormy16-tdep.c: Update comment.
	* regcache.h: Update comments.
	* sparc-tdep.c (sparc_init_extra_frame_info): Instead of
	get_saved_register and extract_address, use
	frame_read_unsigned_register.
	(sparc_frame_saved_pc): Ditto.
	(sparc_get_saved_register): Instead of get_saved_register, use
	frame_register.
	(sparc_pop_frame): Ditto.
	* frame.h (get_saved_register): Delete declaration.
	* findvar.c: Update comments.
	(value_of_register): Call frame_register instead of
	get_saved_register.
	(value_from_register): Ditto.
	* config/sparc/tm-sparc.h: Update comment.
	* breakpoint.c: Update comment.

Index: doc/ChangeLog
2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to get_saved_register.
@
text
@d995 136
d1187 1
a1187 4
  /* Create an initially zero previous frame.  */
  prev = frame_obstack_zalloc (sizeof (struct frame_info));

  /* Link it in.  */
a1190 6
  prev->level = this_frame->level + 1;
  /* FIXME: cagney/2002-11-18: Should be setting the frame's type
     here, before anything else, and not last.  Various INIT functions
     are full of work-arounds for the frames type not being set
     correctly from the word go.  Ulgh!  */
  prev->type = NORMAL_FRAME;
d1435 2
a1436 5
     the legacy get_prev_frame method.  Just don't try to unwind a
     sentinel frame using that method - it doesn't work.  All sentinal
     frames use the new unwind code.  */
  if (legacy_frame_p (current_gdbarch)
      && this_frame->level >= 0)
d1503 10
a1512 33
      if (gdbarch_unwind_dummy_id_p (current_gdbarch))
	{
	  /* Assume hand_function_call(), via SAVE_DUMMY_FRAME_TOS,
	     previously saved the dummy frame's ID.  Things only work
	     if the two return the same value.  */
	  gdb_assert (SAVE_DUMMY_FRAME_TOS_P ());
	  /* Use an architecture specific method to extract the prev's
	     dummy ID from the next frame.  Note that this method uses
	     frame_register_unwind to obtain the register values
	     needed to determine the dummy frame's ID.  */
	  prev_frame->id = gdbarch_unwind_dummy_id (current_gdbarch,
						    this_frame);
	}
      else if (this_frame->level < 0)
	{
	  /* We're unwinding a sentinel frame, the PC of which is
	     pointing at a stack dummy.  Fake up the dummy frame's ID
	     using the same sequence as is found a traditional
	     unwinder.  Once all architectures supply the
	     unwind_dummy_id method, this code can go away.  */
	  prev_frame->id.base = read_fp ();
	  prev_frame->id.pc = read_pc ();
	}
      else
	{
	  /* Outch!  We're not on the innermost frame yet we're trying
	     to unwind to a dummy.  The architecture must provide the
	     unwind_dummy_id() method.  Abandon the unwind process but
	     only after first warning the user.  */
	  internal_warning (__FILE__, __LINE__,
			    "Missing unwind_dummy_id architecture method");
	  return NULL;
	}
a1558 14
  /* FIXME: cagney/2002-01-19: This call will go away.  Instead of
     initializing extra info, all frames will use the frame_cache
     (passed to the unwind functions) to store additional frame info.
     Unfortunatly legacy targets can't use legacy_get_prev_frame() to
     unwind the sentinel frame and, consequently, are forced to take
     this code path and rely on the below call to
     DEPRECATED_INIT_EXTRA_FRAME_INFO to initialize the inner-most
     frame.  */
  if (DEPRECATED_INIT_EXTRA_FRAME_INFO_P ())
    {
      gdb_assert (prev_frame->level == 0);
      DEPRECATED_INIT_EXTRA_FRAME_INFO (0, prev_frame);
    }

d1770 3
a1772 1
	  || FRAME_CHAIN_P ());
@


1.83
log
@2003-03-14  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_GET_SAVED_REGISTER): Replace
	GET_SAVED_REGISTER.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h: Update comments.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frame.c (frame_register): Update.
	(get_saved_register): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_GET_SAVED_REGISTER): Update.
@
text
@a401 18
void
get_saved_register (char *raw_buffer,
		    int *optimized,
		    CORE_ADDR *addrp,
		    struct frame_info *frame,
		    int regnum,
		    enum lval_type *lval)
{
  if (DEPRECATED_GET_SAVED_REGISTER_P ())
    {
      DEPRECATED_GET_SAVED_REGISTER (raw_buffer, optimized, addrp, frame,
				     regnum, lval);
      return;
    }
  generic_unwind_get_saved_register (raw_buffer, optimized, addrp, frame,
				     regnum, lval);
}

d795 2
a796 1
/* Function: get_saved_register
d798 1
a798 1
   target format) contents in *RAW_BUFFER.  
a812 4

   To use this implementation, define a function called
   "get_saved_register" in your target code, which simply passes all
   of its arguments to this function.
@


1.82
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@d271 1
a271 1
  if (GET_SAVED_REGISTER_P ())
d273 2
a274 1
      GET_SAVED_REGISTER (bufferp, optimizedp, addrp, frame, regnum, lvalp);
d410 1
a410 1
  if (GET_SAVED_REGISTER_P ())
d412 2
a413 1
      GET_SAVED_REGISTER (raw_buffer, optimized, addrp, frame, regnum, lval);
@


1.81
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (legacy_frame_p): New function.
	(get_prev_frame): Use legacy_frame_p.
	* frame.h (legacy_frame_p): Declare.
@
text
@d201 1
a201 1
  if (POP_FRAME_P ())
d206 1
a206 1
      POP_FRAME;
@


1.80
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Rename the frame parameter to
	"this_frame".
	(get_next_frame, legacy_get_prev_frame): Ditto.
@
text
@d1330 1
a1330 4
  if ((DEPRECATED_INIT_FRAME_PC_P ()
       || DEPRECATED_INIT_FRAME_PC_FIRST_P ()
       || DEPRECATED_INIT_EXTRA_FRAME_INFO_P ()
       || FRAME_CHAIN_P ())
d1694 9
@


1.80.2.1
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_this_id): Replace d10v_frame_id_unwind.
	(d10v_frame_unwind): Update.
	(d10v_frame_prev_register): Replace d10v_frame_register_unwind.
	(d10v_frame_unwind_cache): Replace this "fi" with "next_frame".
	(saved_regs_unwinder): Replace this "frame" with "next_frame", and
	"saved_regs" with "this_saved_regs".

	* dummy-frame.c (dummy_frame_unwind): Update.
	(cached_find_dummy_frame): Delete.

	* frame.c (legacy_frame_p): New function.
	(get_prev_frame): Call legacy_frame_p.
	* frame.h (legacy_frame_p): Declare.

	* dummy-frame.c (dummy_frame_prev_register): Rename
	dummy_frame_register_unwind.
	(dummy_frame_this_id): Replace dummy_frame_id_unwind.


	* sentinel-frame.c (sentinel_frame_prev_register): Replace
	sentinel_frame_register_unwind.
	(sentinel_frame_this_id): Replace sentinel_frame_id_unwind.
	(sentinel_frame_unwinder): Update.

	* frame-unwind.c (frame_unwind_find_by_pc): Return
	legacy_saved_regs_unwind instead of trad_frame_unwind.  Update
	comment.

	* frame.c (create_sentinel_frame): Initialize prologue_cache.
	(frame_register_unwind): Call this frame's prev_register with the
	next frame and this frame's prologue cache.  Add commented out
	code to cache the value.
	(get_prev_frame): Call prev frame's this_id with this frame and
	prev frame's prologue cache.  Document that this call is shifted
	one to the left when compared to the frame_register_unwind call.
	(legacy_saved_regs_prev_register): Replace
	frame_saved_regs_register_unwind.
	(legacy_saved_regs_this_id): Replace frame_saved_regs_id_unwind.
	(legacy_saved_regs_unwinder): Replace trad_frame_unwinder.
	(legacy_saved_regs_unwind): Replace trad_frame_unwind.

	* frame.h (legacy_saved_regs_unwind): Replace trad_frame_unwind.
	(struct frame_info): Rename "unwind_cache" to "prolog_cache".

	* frame-unwind.h (frame_this_id_ftype): Replace
	frame_unwind_id_ftype.
	(frame_prev_register_ftype): Replace frame_unwind_reg_ftype.
	(struct frame_unwind): Update.  Rename "id" to "this_id".  Rename
	"reg" to "prev_register".
@
text
@d250 3
a252 26
#if 0
  /* Save each register's value and location, as it is read in, in a
     frame based cache.  For moment leave this disabled.  Plenty of
     other things to worry about first.  */
  if (regs == NULL)
    {
      int sizeof_cache = ((NUM_REGS + NUM_PSEUDO_REGS)
			  * sizeof (void *));
      regs = frame_obstack_zalloc (sizeof_cache);
      (*this_prologue_cache) = regs;
    }
  if (regs[regnum] == NULL)
    {
      regs[regnum]
	= frame_obstack_zalloc (REGISTER_RAW_SIZE (regnum));
      read_memory (get_frame_saved_regs (frame)[regnum], regs[regnum],
		   REGISTER_RAW_SIZE (regnum));
    }
#endif

  /* Ask this frame to unwind its register.  See comment in
     "frame-unwind.h" for why NEXT frame and this unwind cace are
     passed in.  */
  frame->unwind->prev_register (frame->next, &frame->prologue_cache, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);

d502 1
a502 1
  frame->prologue_cache = sentinel_frame_cache (regcache);
d659 7
a665 15
legacy_saved_regs_prev_register (struct frame_info *next_frame,
				 void **this_prologue_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *bufferp)
{
  /* HACK: New code is passed the next frame and this cache.
     Unfortunatly, old code expects this frame.  Since this is a
     backward compatibility hack, cheat by walking one level along the
     prologue chain to the frame the old code expects.

     Do not try this at home.  Professional driver, closed course.  */
  struct frame_info *frame = next_frame->prev;

  /* There is always a frame.  */
d667 10
d679 1
a679 2
  if (get_frame_saved_regs (frame) == NULL
      && DEPRECATED_FRAME_INIT_SAVED_REGS_P ())
d706 20
d729 1
d735 6
a740 5
  /* No luck.  Assume this and the next frame have the same register
     value.  Pass the unwind request down the frame chain to the next
     frame.  Hopefully that frame will find the register's location.  */
  frame_register_unwind (next_frame, regnum, optimizedp, lvalp, addrp,
			 realnump, bufferp);
d744 2
a745 3
legacy_saved_regs_this_id (struct frame_info *next_frame,
			   void **this_prologue_cache,
			   struct frame_id *id)
d804 3
a806 3
const struct frame_unwind legacy_saved_regs_unwinder = {
  legacy_saved_regs_this_id,
  legacy_saved_regs_prev_register
d808 1
a808 1
const struct frame_unwind *legacy_saved_regs_unwind = &legacy_saved_regs_unwinder;
d1330 4
a1333 1
  if (legacy_frame_p (current_gdbarch)
d1437 6
a1442 17
      /* The callee expects to be invoked with:

	 this->unwind->this_id (this->next, &this->cache, &this->id);

	 The below is carefully shifted one frame `to the left' so
	 that both the unwind->this_id and unwind->prev_register
	 methods are consistently invoked with NEXT_FRAME and
	 THIS_PROLOGUE_CACHE.
       
	 Also note that, while the PC for this new previous frame was
	 unwound first (see above), the below is the first call that
	 [potentially] requires analysis of the new previous frame's
	 prologue.  Consequently, it is this call, that typically ends
	 up initializing the previous frame's prologue cache.  */
      prev_frame->unwind->this_id (this_frame,
				   &prev_frame->prologue_cache,
				   &prev_frame->id);
a1696 9
}

int
legacy_frame_p (struct gdbarch *current_gdbarch)
{
  return (DEPRECATED_INIT_FRAME_PC_P ()
	  || DEPRECATED_INIT_FRAME_PC_FIRST_P ()
	  || DEPRECATED_INIT_EXTRA_FRAME_INFO_P ()
	  || FRAME_CHAIN_P ());
@


1.80.2.2
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (legacy_saved_regs_this_id): Handle a sentinel frame.
	(get_prev_frame): Simplify.  Frame ID logic moved to
	dummy_frame_this_id and legacy_saved_regs_this_id.
@
text
@d748 1
d755 17
a771 28
  if (frame_relative_level (next_frame) < 0)
    {
      /* We're unwinding a sentinel frame, the PC of which is pointing
	 at a stack dummy.  Fake up the dummy frame's ID using the
	 same sequence as is found a traditional unwinder.  Once all
	 architectures supply the unwind_dummy_id method, this code
	 can go away.  */
      base = read_fp ();
      pc = read_pc ();
    }
  else if (frame_relative_level (next_frame) == 0
	   && FRAMELESS_FUNCTION_INVOCATION (next_frame))
    {
      /* FIXME: 2002-11-09: Frameless functions can occure anywhere in
	 the frame chain, not just the inner most frame!  The generic,
	 per-architecture, frame code should handle this and the below
	 should simply be removed.  */
      /* A frameless inner-most frame.  The `FP' (which isn't an
	 architecture frame-pointer register!) of the caller is the
	 same as the callee.  */
      /* FIXME: 2002-11-09: There isn't any reason to special case
	 this edge condition.  Instead the per-architecture code
	 should hande it locally.  */
      base = get_frame_base (next_frame);
      /* FIXME: cagney/2002-06-08: This should probably return the frame's
	 function and not the PC (a.k.a. resume address).  */
      pc = frame_pc_unwind (next_frame);
    }
d791 1
a793 3
      /* FIXME: cagney/2002-06-08: This should probably return the
	 frame's function and not the PC (a.k.a. resume address).  */
      pc = frame_pc_unwind (next_frame);
d795 6
d1388 55
a1442 8

  /* The callee expects to be invoked with:

     this->unwind->this_id (this->next, &this->cache, &this->id);

     The below is carefully shifted one frame `to the left' so that
     both the unwind->this_id and unwind->prev_register methods are
     consistently invoked with NEXT_FRAME and THIS_PROLOGUE_CACHE.
d1444 33
a1476 16
     Also note that, while the PC for this new previous frame was
     unwound first (see above), the below is the first call that
     [potentially] requires analysis of the new previous frame's
     prologue.  Consequently, it is this call, that typically ends up
     initializing the previous frame's prologue cache.  */
  prev_frame->unwind->this_id (this_frame,
			       &prev_frame->prologue_cache,
			       &prev_frame->id);

  /* Check that the unwound ID is valid.  */
  if (!frame_id_p (prev_frame->id))
    {
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - unwound frame ID invalid\n");
      return NULL;
a1477 16

  /* Check that the new frame isn't inner to (younger, below, next)
     the old frame.  If that happens the frame unwind is going
     backwards.  */
  /* FIXME: cagney/2003-02-25: Ignore the sentinel frame since that
     doesn't have a valid frame ID.  Should instead set the sentinel
     frame's frame ID to a true `sentinel'.  Leave it until after the
     switch to storing the frame ID, instead of the frame base, in the
     frame object.  */
  if (this_frame->level >= 0
      && frame_id_inner (prev_frame->id, get_frame_id (this_frame)))
    error ("Unwound frame inner-to selected frame (corrupt stack?)");

  /* Note that, due to frameless functions, the stronger test of the
     new frame being outer to the old frame can't be used - frameless
     functions differ by only their PC value.  */
@


1.79
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_current_frame): Check target_has_registers before
	checking target_has_stack.
	* eval.c (evaluate_subexp_standard): Use get_selected_frame,
	instead of deprecated_selected_frame.
	* findvar.c (value_of_register): Pass "frame", not
	deprecated_selected_frame, to value_of_builtin_reg.
@
text
@d963 3
a965 3
/* Return the frame that FRAME calls (NULL if FRAME is the innermost
   frame).  Be careful to not fall off the bottom of the frame chain
   and onto the sentinel frame.  */
d968 1
a968 1
get_next_frame (struct frame_info *frame)
d970 2
a971 2
  if (frame->level > 0)
    return frame->next;
d1008 1
a1008 1
legacy_get_prev_frame (struct frame_info *next_frame)
d1016 1
a1016 1
  gdb_assert (next_frame->level >= 0);
d1025 1
a1025 1
     frame.  This macro will set FROMLEAF if NEXT_FRAME is a frameless
d1027 1
a1027 1
  if (next_frame->level == 0)
d1032 1
a1032 1
    fromleaf = FRAMELESS_FUNCTION_INVOCATION (next_frame);
d1043 1
a1043 1
    address = get_frame_base (next_frame);
d1062 1
a1062 1
      address = FRAME_CHAIN (next_frame);
d1064 1
a1064 1
      if (!frame_chain_valid (address, next_frame))
d1074 2
a1075 2
  next_frame->prev = prev;
  prev->next = next_frame;
d1077 1
a1077 1
  prev->level = next_frame->level + 1;
d1142 1
a1142 1
     somewhere (NEXT_FRAME) to store all the info needed to construct
d1171 2
a1172 2
  if (prev->frame == next_frame->frame
      && prev->pc == next_frame->pc)
d1174 1
a1174 1
      next_frame->prev = NULL;
d1222 1
a1222 1
   about the frame that called NEXT_FRAME.  Returns NULL
d1226 1
a1226 1
get_prev_frame (struct frame_info *next_frame)
d1248 1
a1248 1
  if (next_frame == NULL)
d1261 1
a1261 1
         NEXT_FRAME.  */
d1268 1
a1268 1
  gdb_assert (next_frame != NULL);
d1270 1
a1270 1
  if (next_frame->level >= 0
d1272 1
a1272 1
      && inside_main_func (get_frame_pc (next_frame)))
d1285 3
a1287 3
  if (next_frame->prev_p)
    return next_frame->prev;
  next_frame->prev_p = 1;
d1300 2
a1301 2
  if (next_frame->type != DUMMY_FRAME && next_frame->level >= 0
      && inside_entry_file (get_frame_pc (next_frame)))
d1317 2
a1318 2
      && next_frame->type != DUMMY_FRAME && next_frame->level >= 0
      && inside_entry_func (get_frame_pc (next_frame)))
d1334 1
a1334 1
      && next_frame->level >= 0)
d1336 1
a1336 1
      prev_frame = legacy_get_prev_frame (next_frame);
d1354 1
a1354 1
  prev_frame->level = next_frame->level + 1;
d1364 1
a1364 1
     NEXT_FRAME's data structures have already been initialized (using
d1371 1
a1371 1
     using NEXT_FRAME's frame ID.  */
d1373 1
a1373 1
  prev_frame->pc = frame_pc_unwind (next_frame);
d1412 1
a1412 1
						    next_frame);
d1414 1
a1414 1
      else if (next_frame->level < 0)
d1439 1
a1439 1
	 -> id (next_frame, & prev_frame -> unwind_cache, & prev_frame
d1441 1
a1441 1
      next_frame->unwind->id (next_frame, &next_frame->unwind_cache,
d1459 2
a1460 2
      if (next_frame->level >= 0
	  && frame_id_inner (prev_frame->id, get_frame_id (next_frame)))
d1477 2
a1478 2
  next_frame->prev = prev_frame;
  prev_frame->next = next_frame;
@


1.78
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@d569 7
a577 2
  if (!target_has_registers)
    error ("No registers.");
@


1.77
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	Eliminate the need for POP_FRAME.
	* frame.c (do_frame_unwind_register): New function.
	(frame_pop): When no POP_FRAME, pop the frame using register
	unwind and a scratch regcache.
	(frame_saved_regs_pop): Delete function.
	(trad_frame_unwinder): Update.
	* d10v-tdep.c (d10v_frame_pop): Delete function.
	(d10v_frame_unwind): Update.
	* sentinel-frame.c (sentinel_frame_pop): Delete function.
	(sentinel_frame_unwinder): Update.
	* dummy-frame.c (dummy_frame_pop): Delete function.
	(dummy_frame_unwind): Update.
	* frame-unwind.h (frame_unwind_pop_ftype): Delete definition.
	(struct frame_unwind): Update.
@
text
@d172 1
a172 1
      else if (FRAME_SAVED_PC_P ())
d178 1
a178 1
	  pc = FRAME_SAVED_PC (this_frame);
@


1.76
log
@2003-03-11  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_update_frame_pc_hack): Don't assume a next
	frame.  Problem found by Corinna Vinschen.
@
text
@d188 7
d196 1
a196 1
frame_pop (struct frame_info *frame)
d198 28
a225 7
  /* FIXME: cagney/2003-01-18: There is probably a chicken-egg problem
     with passing in current_regcache.  The pop function needs to be
     written carefully so as to not overwrite registers whose [old]
     values are needed to restore other registers.  Instead, this code
     should pass in a scratch cache and, as a second step, restore the
     registers using that.  */
  frame->unwind->pop (frame, &frame->unwind_cache, current_regcache);
a798 8
static void
frame_saved_regs_pop (struct frame_info *fi, void **cache,
		      struct regcache *regcache)
{
  gdb_assert (POP_FRAME_P ());
  POP_FRAME;
}

a799 1
  frame_saved_regs_pop,
@


1.75
log
@2003-03-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_unwind_pc): New method.
	* gdbarch.h, gdbarch.c: Regenerate.
	* frame.c (frame_pc_unwind): Rewrite.  Prefer gdbarch_unwind_pc,
	but use read_pc and FRAME_SAVED_PC as fall backs.
	(frame_saved_regs_pc_unwind): Delete function.
	(trad_frame_unwinder): Update.
	* frame-unwind.h (frame_unwind_pc_ftype): Delete declaration.
	(struct frame_unwind): Update.
	* dummy-frame.c (dummy_frame_pc_unwind): Delete function.
	(dummy_frame_unwind): Update.
	* sentinel-frame.c (sentinel_frame_pc_unwind): Delete function.
	(sentinel_frame_unwinder): Update.
	* d10v-tdep.c (d10v_frame_pc_unwind): Delete function.
	(d10v_frame_unwind): Update.
	(d10v_unwind_pc): New function.
	(d10v_gdbarch_init): Set unwind_pc.

Index: doc/ChangeLog
2003-03-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Cross reference
	FRAME_SAVED_PC to unwind_pc.  Document unwind_pc.
@
text
@d1586 12
a1597 6
  /* While we're at it, update this frame's cached PC value, found in
     the next frame.  Oh, for the day when "struct frame_info" is
     opaque and this hack on hack can go.  */
  gdb_assert (frame->next != NULL);
  frame->next->pc_unwind_cache = pc;
  frame->next->pc_unwind_cache_p = 1;
@


1.74
log
@2003-03-05  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_unwind_dummy_id): New function.
	(d10v_gdbarch_init): Set unwind_dummy_id and save_dummy_frame_tos.
	* frame.c (get_prev_frame): Restructure the frame ID unwind code
	to use unwind_dummy_id when a dummy frame.
	* gdbarch.sh (unwind_dummy_id): New multi-arch method with
	predicate.
	* gdbarch.h, gdbarch.c: Regneerate.

Index: doc/ChangeLog
2003-03-05  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	unwind_dummy_id.  Cross reference unwind_dummy_id and
	SAVE_DUMMY_FRAME_TOS.
@
text
@d138 1
a138 1
frame_pc_unwind (struct frame_info *frame)
d140 1
a140 1
  if (!frame->pc_unwind_cache_p)
d142 42
a183 2
      frame->pc_unwind_cache = frame->unwind->pc (frame, &frame->unwind_cache);
      frame->pc_unwind_cache_p = 1;
d185 1
a185 1
  return frame->pc_unwind_cache;
a709 7
static CORE_ADDR
frame_saved_regs_pc_unwind (struct frame_info *frame, void **cache)
{
  gdb_assert (FRAME_SAVED_PC_P ());
  return FRAME_SAVED_PC (frame);
}
	
a780 1
  frame_saved_regs_pc_unwind,
@


1.74.2.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d138 1
a138 1
frame_pc_unwind (struct frame_info *this_frame)
d140 1
a140 1
  if (!this_frame->pc_unwind_cache_p)
d142 2
a143 42
      CORE_ADDR pc;
      if (gdbarch_unwind_pc_p (current_gdbarch))
	{
	  /* The right way.  The `pure' way.  The one true way.  This
	     method depends solely on the register-unwind code to
	     determine the value of registers in THIS frame, and hence
	     the value of this frame's PC (resume address).  A typical
	     implementation is no more than:
	   
	     frame_unwind_register (this_frame, ISA_PC_REGNUM, buf);
	     return extract_address (buf, size of ISA_PC_REGNUM);

	     Note: this method is very heavily dependent on a correct
	     register-unwind implementation, it pays to fix that
	     method first; this method is frame type agnostic, since
	     it only deals with register values, it works with any
	     frame.  This is all in stark contrast to the old
	     FRAME_SAVED_PC which would try to directly handle all the
	     different ways that a PC could be unwound.  */
	  pc = gdbarch_unwind_pc (current_gdbarch, this_frame);
	}
      else if (this_frame->level < 0)
	{
	  /* FIXME: cagney/2003-03-06: Old code and and a sentinel
             frame.  Do like was always done.  Fetch the PC's value
             direct from the global registers array (via read_pc).
             This assumes that this frame belongs to the current
             global register cache.  The assumption is dangerous.  */
	  pc = read_pc ();
	}
      else if (DEPRECATED_FRAME_SAVED_PC_P ())
	{
	  /* FIXME: cagney/2003-03-06: Old code, but not a sentinel
             frame.  Do like was always done.  Note that this method,
             unlike unwind_pc(), tries to handle all the different
             frame cases directly.  It fails.  */
	  pc = DEPRECATED_FRAME_SAVED_PC (this_frame);
	}
      else
	internal_error (__FILE__, __LINE__, "No gdbarch_unwind_pc method");
      this_frame->pc_unwind_cache = pc;
      this_frame->pc_unwind_cache_p = 1;
d145 1
a145 8
  return this_frame->pc_unwind_cache;
}

static int
do_frame_unwind_register (void *src, int regnum, void *buf)
{
  frame_unwind_register (src, regnum, buf);
  return 1;
d149 1
a149 1
frame_pop (struct frame_info *this_frame)
d151 7
a157 28
  struct regcache *scratch_regcache;
  struct cleanup *cleanups;

  if (DEPRECATED_POP_FRAME_P ())
    {
      /* A legacy architecture that has implemented a custom pop
	 function.  All new architectures should instead be using the
	 generic code below.  */
      DEPRECATED_POP_FRAME;
    }
  else
    {
      /* Make a copy of all the register values unwound from this
	 frame.  Save them in a scratch buffer so that there isn't a
	 race betweening trying to extract the old values from the
	 current_regcache while, at the same time writing new values
	 into that same cache.  */
      struct regcache *scratch = regcache_xmalloc (current_gdbarch);
      struct cleanup *cleanups = make_cleanup_regcache_xfree (scratch);
      regcache_save (scratch, do_frame_unwind_register, this_frame);
      /* Now copy those saved registers into the current regcache.
         Here, regcache_cpy() calls regcache_restore().  */
      regcache_cpy (current_regcache, scratch);
      do_cleanups (cleanups);
    }
  /* We've made right mess of GDB's local state, just discard
     everything.  */
  target_store_registers (-1);
d203 1
a203 1
  if (DEPRECATED_GET_SAVED_REGISTER_P ())
d205 1
a205 2
      DEPRECATED_GET_SAVED_REGISTER (bufferp, optimizedp, addrp, frame,
				     regnum, lvalp);
d333 17
d501 2
a502 5
  /* First check, and report, the lack of registers.  Having GDB
     report "No stack!" or "No memory" when the target doesn't even
     have registers is very confusing.  Besides, "printcmd.exp"
     explicitly checks that ``print $pc'' with no registers prints "No
     registers".  */
a504 2
  if (!target_has_stack)
    error ("No stack.");
d670 7
d738 8
d747 2
d755 1
a755 2
/* Function: deprecated_generic_get_saved_register

d757 1
a757 1
   target format) contents in *RAW_BUFFER.
d773 4
d907 3
a909 3
/* Return the frame that THIS_FRAME calls (NULL if THIS_FRAME is the
   innermost frame).  Be careful to not fall off the bottom of the
   frame chain and onto the sentinel frame.  */
d912 1
a912 1
get_next_frame (struct frame_info *this_frame)
d914 2
a915 2
  if (this_frame->level > 0)
    return this_frame->next;
d952 1
a952 1
legacy_get_prev_frame (struct frame_info *this_frame)
a957 136
  /* Allocate the new frame but do not wire it in to the frame chain.
     Some (bad) code in INIT_FRAME_EXTRA_INFO tries to look along
     frame->next to pull some fancy tricks (of course such code is, by
     definition, recursive).  Try to prevent it.

     There is no reason to worry about memory leaks, should the
     remainder of the function fail.  The allocated memory will be
     quickly reclaimed when the frame cache is flushed, and the `we've
     been here before' check, in get_prev_frame will stop repeated
     memory allocation calls.  */
  prev = FRAME_OBSTACK_ZALLOC (struct frame_info);
  prev->level = this_frame->level + 1;

  /* NOTE: cagney/2002-11-18: Should have been correctly setting the
     frame's type here, before anything else, and not last, at the
     bottom of this function.  The various
     DEPRECATED_INIT_EXTRA_FRAME_INFO, DEPRECATED_INIT_FRAME_PC,
     DEPRECATED_INIT_FRAME_PC_FIRST and
     DEPRECATED_FRAME_INIT_SAVED_REGS methods are full of work-arounds
     that handle the frame not being correctly set from the start.
     Unfortunatly those same work-arounds rely on the type defaulting
     to NORMAL_FRAME.  Ulgh!  The new frame code does not have this
     problem.  */
  prev->type = NORMAL_FRAME;

  /* Handle sentinel frame unwind as a special case.  */
  if (this_frame->level < 0)
    {
      /* Try to unwind the PC.  If that doesn't work, assume we've reached
	 the oldest frame and simply return.  Is there a better sentinal
	 value?  The unwound PC value is then used to initialize the new
	 previous frame's type.

	 Note that the pc-unwind is intentionally performed before the
	 frame chain.  This is ok since, for old targets, both
	 frame_pc_unwind (nee, FRAME_SAVED_PC) and FRAME_CHAIN()) assume
	 THIS_FRAME's data structures have already been initialized (using
	 DEPRECATED_INIT_EXTRA_FRAME_INFO) and hence the call order
	 doesn't matter.
	 
	 By unwinding the PC first, it becomes possible to, in the case of
	 a dummy frame, avoid also unwinding the frame ID.  This is
	 because (well ignoring the PPC) a dummy frame can be located
	 using THIS_FRAME's frame ID.  */
      
      prev->pc = frame_pc_unwind (this_frame);
      if (prev->pc == 0)
	{
	  /* The allocated PREV_FRAME will be reclaimed when the frame
	     obstack is next purged.  */
	  if (frame_debug)
	    fprintf_unfiltered (gdb_stdlog,
				"Outermost frame - unwound PC zero\n");
	  return NULL;
	}
      prev->type = frame_type_from_pc (prev->pc);

      /* Set the unwind functions based on that identified PC.  */
      prev->unwind = frame_unwind_find_by_pc (current_gdbarch, prev->pc);

      /* Find the prev's frame's ID.  */
      if (prev->type == DUMMY_FRAME
	  && gdbarch_unwind_dummy_id_p (current_gdbarch))
	{
	  /* When unwinding a normal frame, the stack structure is
	     determined by analyzing the frame's function's code (be
	     it using brute force prologue analysis, or the dwarf2
	     CFI).  In the case of a dummy frame, that simply isn't
	     possible.  The The PC is either the program entry point,
	     or some random address on the stack.  Trying to use that
	     PC to apply standard frame ID unwind techniques is just
	     asking for trouble.  */
	  /* Assume hand_function_call(), via SAVE_DUMMY_FRAME_TOS,
	     previously saved the dummy frame's ID.  Things only work
	     if the two return the same value.  */
	  gdb_assert (SAVE_DUMMY_FRAME_TOS_P ());
	  /* Use an architecture specific method to extract the prev's
	     dummy ID from the next frame.  Note that this method uses
	     frame_register_unwind to obtain the register values
	     needed to determine the dummy frame's ID.  */
	  prev->id = gdbarch_unwind_dummy_id (current_gdbarch, this_frame);
	}
      else
	{
	  /* We're unwinding a sentinel frame, the PC of which is
	     pointing at a stack dummy.  Fake up the dummy frame's ID
	     using the same sequence as is found a traditional
	     unwinder.  Once all architectures supply the
	     unwind_dummy_id method, this code can go away.  */
	  prev->id.base = read_fp ();
	  prev->id.pc = read_pc ();
	}

      /* Check that the unwound ID is valid.  */
      if (!frame_id_p (prev->id))
	{
	  if (frame_debug)
	    fprintf_unfiltered (gdb_stdlog,
				"Outermost legacy sentinel frame - unwound frame ID invalid\n");
	  return NULL;
	}

      /* Check that the new frame isn't inner to (younger, below,
	 next) the old frame.  If that happens the frame unwind is
	 going backwards.  */
      /* FIXME: cagney/2003-02-25: Ignore the sentinel frame since
	 that doesn't have a valid frame ID.  Should instead set the
	 sentinel frame's frame ID to a `sentinel'.  Leave it until
	 after the switch to storing the frame ID, instead of the
	 frame base, in the frame object.  */

      /* FIXME: cagney/2002-12-18: Instead of this hack, should only
	 store the frame ID in PREV_FRAME.  Unfortunatly, some
	 architectures (HP/UX) still reply on EXTRA_FRAME_INFO and,
	 hence, still poke at the "struct frame_info" object directly.  */
      prev->frame = prev->id.base;

      /* Link it in.  */
      this_frame->prev = prev;
      prev->next = this_frame;

      /* FIXME: cagney/2002-01-19: This call will go away.  Instead of
	 initializing extra info, all frames will use the frame_cache
	 (passed to the unwind functions) to store additional frame
	 info.  Unfortunatly legacy targets can't use
	 legacy_get_prev_frame() to unwind the sentinel frame and,
	 consequently, are forced to take this code path and rely on
	 the below call to DEPRECATED_INIT_EXTRA_FRAME_INFO to
	 initialize the inner-most frame.  */
      if (DEPRECATED_INIT_EXTRA_FRAME_INFO_P ())
	{
	  DEPRECATED_INIT_EXTRA_FRAME_INFO (0, prev);
	}
      return prev;
    }

d960 1
a960 1
  gdb_assert (this_frame->level >= 0);
d969 1
a969 1
     frame.  This macro will set FROMLEAF if THIS_FRAME is a frameless
d971 1
a971 1
  if (this_frame->level == 0)
d976 1
a976 1
    fromleaf = FRAMELESS_FUNCTION_INVOCATION (this_frame);
d987 1
a987 1
    address = get_frame_base (this_frame);
d1006 1
a1006 1
      address = FRAME_CHAIN (this_frame);
d1008 1
a1008 1
      if (!frame_chain_valid (address, this_frame))
d1014 6
a1019 3
  /* Link in the already allocated prev frame.  */
  this_frame->prev = prev;
  prev->next = this_frame;
d1021 6
d1086 1
a1086 1
     somewhere (THIS_FRAME) to store all the info needed to construct
d1115 2
a1116 2
  if (prev->frame == this_frame->frame
      && prev->pc == this_frame->pc)
d1118 1
a1118 1
      this_frame->prev = NULL;
d1166 1
a1166 1
   about the frame that called THIS_FRAME.  Returns NULL
d1170 1
a1170 1
get_prev_frame (struct frame_info *this_frame)
d1192 1
a1192 1
  if (this_frame == NULL)
d1205 1
a1205 1
         THIS_FRAME.  */
d1212 1
a1212 1
  gdb_assert (this_frame != NULL);
d1214 1
a1214 1
  if (this_frame->level >= 0
d1216 1
a1216 1
      && inside_main_func (get_frame_pc (this_frame)))
d1229 3
a1231 3
  if (this_frame->prev_p)
    return this_frame->prev;
  this_frame->prev_p = 1;
d1244 2
a1245 2
  if (this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && inside_entry_file (get_frame_pc (this_frame)))
d1261 2
a1262 2
      && this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && inside_entry_func (get_frame_pc (this_frame)))
d1271 8
a1278 2
     the legacy get_prev_frame method.  */
  if (legacy_frame_p (current_gdbarch))
d1280 1
a1280 1
      prev_frame = legacy_get_prev_frame (this_frame);
d1298 1
a1298 1
  prev_frame->level = this_frame->level + 1;
d1308 1
a1308 1
     THIS_FRAME's data structures have already been initialized (using
d1315 1
a1315 1
     using THIS_FRAME's frame ID.  */
d1317 1
a1317 1
  prev_frame->pc = frame_pc_unwind (this_frame);
d1345 33
a1377 10
      gdb_assert (gdbarch_unwind_dummy_id_p (current_gdbarch));
	/* Assume hand_function_call(), via SAVE_DUMMY_FRAME_TOS,
	   previously saved the dummy frame's ID.  Things only work if
	   the two return the same value.  */
      gdb_assert (SAVE_DUMMY_FRAME_TOS_P ());
      /* Use an architecture specific method to extract the prev's
	 dummy ID from the next frame.  Note that this method uses
	 frame_register_unwind to obtain the register values needed to
	 determine the dummy frame's ID.  */
      prev_frame->id = gdbarch_unwind_dummy_id (current_gdbarch, this_frame);
d1383 1
a1383 1
	 -> id (this_frame, & prev_frame -> unwind_cache, & prev_frame
d1385 1
a1385 1
      this_frame->unwind->id (this_frame, &this_frame->unwind_cache,
d1403 2
a1404 2
      if (this_frame->level >= 0
	  && frame_id_inner (prev_frame->id, get_frame_id (this_frame)))
d1421 16
a1436 2
  this_frame->prev = prev_frame;
  prev_frame->next = this_frame;
d1554 6
a1559 12
  /* NOTE: cagney/2003-03-11: Some architectures (e.g., Arm) are
     maintaining a locally allocated frame object.  Since such frame's
     are not in the frame chain, it isn't possible to assume that the
     frame has a next.  Sigh.  */
  if (frame->next != NULL)
    {
      /* While we're at it, update this frame's cached PC value, found
	 in the next frame.  Oh for the day when "struct frame_info"
	 is opaque and this hack on hack can just go away.  */
      frame->next->pc_unwind_cache = pc;
      frame->next->pc_unwind_cache_p = 1;
    }
a1634 11
}

int
legacy_frame_p (struct gdbarch *current_gdbarch)
{
  return (DEPRECATED_INIT_FRAME_PC_P ()
	  || DEPRECATED_INIT_FRAME_PC_FIRST_P ()
	  || DEPRECATED_INIT_EXTRA_FRAME_INFO_P ()
	  || FRAME_CHAIN_P ()
	  || !gdbarch_unwind_dummy_id_p (current_gdbarch)
	  || !SAVE_DUMMY_FRAME_TOS_P ());
@


1.73
log
@2003-03-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_update_frame_pc_hack): Also update the the
	cached PC value in the next frame.
@
text
@d1333 2
a1334 13
  /* FIXME: cagney/2003-01-13: A dummy frame doesn't need to unwind
     the frame ID because the frame ID comes from the previous frame.
     The other frames do though.  True?  */
  /* FIXME: cagney/2003-03-04: The below call isn't right.  It should
     instead be doing something like "prev_frame -> unwind -> id
     (next_frame, & prev_frame -> unwind_cache, & prev_frame -> id)"
     but that requires more extensive (pending) changes.  */
  next_frame->unwind->id (next_frame, &next_frame->unwind_cache,
			  &prev_frame->id);
  /* Check that the unwound ID is valid.  As of 2003-02-24 the x86-64
     was returning an invalid frame ID when trying to do an unwind a
     sentinel frame that belonged to a frame dummy.  */
  if (!frame_id_p (prev_frame->id))
d1336 76
a1411 4
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - unwound frame ID invalid\n");
      return NULL;
a1412 14
  /* Check that the new frame isn't inner to (younger, below, next)
     the old frame.  If that happens the frame unwind is going
     backwards.  */
  /* FIXME: cagney/2003-02-25: Ignore the sentinel frame since that
     doesn't have a valid frame ID.  Should instead set the sentinel
     frame's frame ID to a `sentinel'.  Leave it until after the
     switch to storing the frame ID, instead of the frame base, in the
     frame object.  */
  if (next_frame->level >= 0
      && frame_id_inner (prev_frame->id, get_frame_id (next_frame)))
    error ("Unwound frame inner-to selected frame (corrupt stack?)");
  /* Note that, due to frameless functions, the stronger test of the
     new frame being outer to the old frame can't be used - frameless
     functions differ by only their PC value.  */
@


1.72
log
@2003-03-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (struct frame_info): Replace "id_unwind_cache_p" and
	"id_unwind_cache" with "id".
	(frame_id_unwind): Delete declaration.
	* frame.c (frame_id_unwind): Delete function.
	(get_prev_frame): Call the frame id unwind method directly.  Store
	the returned next frame's ID value in NEXT_FRAME.  Note that there
	is a problem with the wrong unwind ID being called with the wrong
	unwind cache.
@
text
@d1506 4
d1511 2
a1512 1
  frame->pc = pc;
@


1.71
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_INIT_SAVED_REGS): Rename
	FRAME_INIT_SAVED_REGS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Update.
	* sh-tdep.c (sh_find_callers_reg, sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info, sh64_init_extra_frame_info): Update.
	(sh64_get_saved_register, sh_pop_frame, sh64_pop_frame): Update.
	* ns32k-tdep.c (ns32k_pop_frame): Update.
	* mips-tdep.c (mips_pop_frame): Update.
	* m68hc11-tdep.c (m68hc11_pop_frame): Update.
	* ia64-tdep.c (ia64_frame_chain): Update.
	(ia64_frame_saved_pc, ia64_get_saved_register): Update.
	(ia64_frameless_function_invocation): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_pop_frame_regular): Update.
	* frame.h (struct frame_info): Update comment.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Rename macro.
	* frame.c (frame_saved_regs_register_unwind): Update.
	(frame_saved_regs_register_unwind): Update.
	(deprecated_generic_get_saved_register): Update.
	* cris-tdep.c: Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_INIT_SAVED_REGS):
	Rename macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_INIT_SAVED_REGS to DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@a147 11
struct frame_id
frame_id_unwind (struct frame_info *frame)
{
  if (!frame->id_unwind_cache_p)
    {
      frame->unwind->id (frame, &frame->unwind_cache, &frame->id_unwind_cache);
      frame->id_unwind_cache_p = 1;
    }
  return frame->id_unwind_cache;
}

d1336 36
a1371 30
  {
    /* FIXME: cagney/2002-12-18: Instead of this hack, should just
       save the frame ID directly.  */
    struct frame_id id = frame_id_unwind (next_frame);
    /* Check that the unwound ID is valid.  As of 2003-02-24 the
       x86-64 was returning an invalid frame ID when trying to do an
       unwind a sentinel frame that belonged to a frame dummy.  */
    if (!frame_id_p (id))
      {
	if (frame_debug)
	  fprintf_unfiltered (gdb_stdlog,
			      "Outermost frame - unwound frame ID invalid\n");
	return NULL;
      }
    /* Check that the new frame isn't inner to (younger, below, next)
       the old frame.  If that happens the frame unwind is going
       backwards.  */
    /* FIXME: cagney/2003-02-25: Ignore the sentinel frame since that
       doesn't have a valid frame ID.  Should instead set the sentinel
       frame's frame ID to a `sentinel'.  Leave it until after the
       switch to storing the frame ID, instead of the frame base, in
       the frame object.  */
    if (next_frame->level >= 0
	&& frame_id_inner (id, get_frame_id (next_frame)))
      error ("Unwound frame inner-to selected frame (corrupt stack?)");
    /* Note that, due to frameless functions, the stronger test of the
       new frame being outer to the old frame can't be used -
       frameless functions differ by only their PC value.  */
    prev_frame->frame = id.base;
  }
@


1.71.2.1
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_id_unwind): Delete function.
	(get_prev_frame): Use prev's unwinder to unwind the frame ID.
	* frame.h (frame_id_unwind): Delete declaration.
@
text
@d148 11
d1350 1
a1350 2
    struct frame_id id = prev_frame->unwind->id (next_frame,
						 &prev_frame->unwind_cache);
@


1.71.2.2
log
@2003-03-04  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_unwind_cache): Update to work with
	NEXT_FRAME and THIS_CACHE.
	(d10v_frame_pc_unwind): Ditto.
	(d10v_frame_id_unwind): Ditto.
	(saved_regs_unwinder): Ditto.
	(d10v_frame_register_unwind): Ditto.
	* dummy-frame.c (dummy_frame_register_unwind): Ditto.
	(dummy_frame_pc_unwind): Ditto.
	(cached_find_dummy_frame): Ditto.
	(dummy_frame_id_unwind): Ditto.
	(dummy_frame_pop): Ditto.
	* sentinel-frame.c (sentinel_frame_register_unwind): Ditto.
	(sentinel_frame_pc_unwind): Ditto.
	(sentinel_frame_id_unwind): Ditto.
	(sentinel_frame_pop): Ditto.
	* frame.c (frame_id_unwind): Reinstate function.
	* frame.h (frame_id_unwind): Reinstate declaration.
	* frame.c (frame_pc_unwind): Pass frame->next to the PC's unwind
	method.
	(frame_pop, frame_register_unwind): Ditto.
	* frame-unwind.h (frame_unwind_id_ftype, frame_unwind_reg_ftype)
	(frame_unwind_pc_ftype, frame_unwind_pop_ftype): Re-specify
	behavior in terms of PREV_REGNUM, THIS_CACHE and NEXT_FRAME.
@
text
@d138 1
a138 1
frame_pc_unwind (struct frame_info *this_frame)
d140 1
a140 1
  if (!this_frame->pc_unwind_cache_p)
d142 2
a143 3
      this_frame->pc_unwind_cache
	= this_frame->unwind->pc (this_frame->next, &this_frame->unwind_cache);
      this_frame->pc_unwind_cache_p = 1;
d145 1
a145 13
  return this_frame->pc_unwind_cache;
}

struct frame_id
frame_id_unwind (struct frame_info *this_frame)
{
  if (!this_frame->id_unwind_cache_p)
    {
      this_frame->unwind->id (this_frame->next, &this_frame->unwind_cache,
			      &this_frame->id_unwind_cache);
      this_frame->id_unwind_cache_p = 1;
    }
  return this_frame->id_unwind_cache;
d157 1
a157 1
  frame->unwind->pop (frame->next, &frame->unwind_cache, current_regcache);
d162 1
a162 1
frame_register_unwind (struct frame_info *this_frame, int prev_regnum,
d180 1
a180 1
  gdb_assert (this_frame != NULL && this_frame->next != NULL);
d182 3
a184 5
  /* Ask this frame's register unwinder to return the value of
     PREV_REGNUM using register values unwound from the NEXT frame.  */
  this_frame->unwind->reg (this_frame->next, &this_frame->unwind_cache,
			   prev_regnum, optimizedp, lvalp, addrp, realnump,
			   bufferp);
d1339 2
a1340 2
    struct frame_id id;
    prev_frame->unwind->id (next_frame, &prev_frame->unwind_cache, &id);
@


1.71.2.3
log
@2003-03-04  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (struct d10v_unwind_cache): Add field "r11_addr",
	change type of "next_addr" to LONGEST.  Delete member "frameless".
	(prologue_find_regs): Parse "st rn, @@r11", save r11's offset.
	(d10v_frame_unwind_cache): Compute both the frame base and the
	previous stack pointer.  Store the previous SP's value in the
	saved_regs array.
	(d10v_frame_id_unwind): Remove commented out code.  Check for
	circular stack.
	(saved_regs_unwinder): When SP_REGNUM, extract the value from the
	saved_regs array.
	(d10v_unwind_dummy_id): New function.
	(d10v_gdbarch_init): Initialize d10v_unwind_dummy_id and
	save_dummy_frame_tos.
	(struct frame_extra_info): Delete.
	(saved_regs_unwind): New function.
	(d10v_frame_pop): Update to match current code.
	(d10v_frame_register_unwind): Don't unwind LR_REGNUM.  Unwind the
	PC_REGNUM by returning the saved LR_REGNUM.
	* frame.c (get_prev_frame): Store this frame's ID in the next
	frame's unwound ID cache.
	(deprecated_update_frame_pc_hack): Update the cached value in NEXT
	as well.

	2003-02-27  Andrew Cagney  <cagney@@redhat.com>
	* frame.c (get_prev_frame): Rewrite the frame ID unwind code to
	use unwind_dummy_id when available.
	* gdbarch.sh (get_dummy_frame_id): New multi-arch method with
	predicate.
	* gdbarch.h, gdbarch.c: Regneerate.
@
text
@d1348 3
a1350 1
  /* Find the prev's frame's ID.  */
d1352 8
a1359 1
    switch (prev_frame->type)
d1361 4
a1364 66
      case DUMMY_FRAME:
	/* A dummy doesn't have anything resembling either a sane
	   frame or PC.  The PC is sitting in the entry code and the
	   stack, which has nothing to do with that entry address, is
	   a down right mess.  Trying to use the standard frame ID
	   unwind code to get the previous frame ID is just asking for
	   trouble.  */
	if (gdbarch_unwind_dummy_id_p (current_gdbarch))
	  {
	    /* Assume hand_function_call(), via SAVE_DUMMY_FRAME_TOS,
               previously saved the dummy ID that is being obtained
               here.  Things only work if the two match.  */
	    gdb_assert (SAVE_DUMMY_FRAME_TOS_P ());
	    /* Use an architecture specific method to extract the
	       prev's dummy ID from the next frame.  Note that this
	       method typically uses frame_register_unwind to obtain
	       register values needed to determine the dummy ID.  */
	    next_frame->id_unwind_cache =
	      gdbarch_unwind_dummy_id (current_gdbarch, next_frame);
	  }
	else if (next_frame->level == 0)
	  {
	    /* We're `unwinding' the sentinel frame.  Just fake up the
               ID the same way that the traditional hacks did it.  */
	    next_frame->id_unwind_cache.pc = read_pc ();
	    next_frame->id_unwind_cache.pc = read_fp ();
	  }
	else
	  {
	    /* Outch!  We're not on the innermost frame yet we're
               trying to unwind to a dummy.  The architecture must
               provide the unwind_dummy_id() method.  */
	    internal_error (__FILE__, __LINE__,
			    "Missing unwind_dummy_id architecture method");
	  }
	break;
      case NORMAL_FRAME:
      case SIGTRAMP_FRAME:
	prev_frame->unwind->id (next_frame, &prev_frame->unwind_cache,
				&next_frame->id_unwind_cache);
	/* Check that the unwound ID is valid.  */
	if (!frame_id_p (next_frame->id_unwind_cache))
	  {
	    if (frame_debug)
	      fprintf_unfiltered (gdb_stdlog,
				  "Outermost frame - unwound frame ID invalid\n");
	    return NULL;
	  }
	/* Check that the new frame isn't inner to (younger, below,
	   next) the old frame.  If that happens the frame unwind is
	   going backwards.  */
	/* FIXME: cagney/2003-02-25: Ignore the sentinel frame since
	   that doesn't have a valid frame ID.  Should instead set the
	   sentinel frame's frame ID to a `sentinel'.  Leave it until
	   after the switch to storing the frame ID, instead of the
	   frame base, in the frame object.  */
	if (next_frame->level >= 0
	    && frame_id_inner (next_frame->id_unwind_cache,
			       get_frame_id (next_frame)))
	  error ("Unwound frame inner-to selected frame (corrupt stack?)");
	/* Note that, due to frameless functions, the stronger test of
	   the new frame being outer to the old frame can't be used -
	   frameless functions differ by only their PC value.  */
	break;
      default:
	internal_error (__FILE__, __LINE__, "bad switch");
d1366 15
a1380 6
    /* FIXME: cagney/2002-12-18: Instead of this hack, the frame ID
       should be directly stored in the `struct frame_info'.
       Unfortunatly, GDB isn't quite ready for this, need to get HP/UX
       multi-arch and make 'struct frame_info' opaque.  */
    next_frame->id_unwind_cache_p = 1;
    prev_frame->frame = next_frame->id_unwind_cache.base;
a1516 1
  /* Fix up this PC's value.  */
a1517 4
  /* While we're at it, also update the cache, in NEXT, that also
     contains that value.  */
  frame->next->pc_unwind_cache = pc;
  frame->next->pc_unwind_cache_p = 1;
@


1.71.2.4
log
@2003-03-06  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_unwind_pc): New method.
	* gdbarch.h, gdbarch.c: Regenerate.
	* frame.c (frame_pc_unwind): Rewrite.  Prefer gdbarch_unwind_pc,
	but use read_pc and FRAME_SAVED_PC as fall backs.
	(frame_saved_regs_pc_unwind): Delete function.
	(trad_frame_unwinder): Update.
	* frame-unwind.h (frame_unwind_pc_ftype): Delete declaration.
	(struct frame_unwind): Update.
	* dummy-frame.c (dummy_frame_pc_unwind): Delete function.
	(dummy_frame_unwind): Update.
	* sentinel-frame.c (sentinel_frame_pc_unwind): Delete function.
	(sentinel_frame_unwinder): Update.
	* d10v-tdep.c (d10v_frame_pc_unwind): Delete function.
	(d10v_frame_unwind): Update.
	(d10v_unwind_pc): New function.
	(d10v_gdbarch_init): Set unwind_pc.

2003-03-05  Andrew Cagney  <cagney@@redhat.com>

	* dummy-frame.c (dummy_frame_id_unwind): Abort if called.
	(cached_find_dummy_frame): Add hack to obtain this thread's id
	without calling id unwind.
	* frame.h: Merge with mainline.
	* d10v-tdep.c: Merge with mainline.
	* frame.c: Merge with mainline.
@
text
@d138 1
a138 1
frame_pc_unwind (struct frame_info *next_frame)
d140 1
a140 1
  if (!next_frame->pc_unwind_cache_p)
d142 15
a156 42
      CORE_ADDR pc;
      if (gdbarch_unwind_pc_p (current_gdbarch))
	{
	  /* The right way.  The `pure' way.  The one true way.  This
	     method depends solely on the register-unwind code to
	     determine the value of registers in THIS frame, and hence
	     the value of this frame's PC (resume address).  A typical
	     implementation is no more than:
	   
	     frame_unwind_register (next_frame, ISA_PC_REGNUM, buf);
	     return extract_address (buf, size of ISA_PC_REGNUM);

	     Note: this method is very heavily dependent on a correct
	     register-unwind implementation, it pays to fix that
	     method first; this method is frame type agnostic, since
	     it only deals with register values, it works with any
	     frame.  This is all in stark contrast to the old
	     FRAME_SAVED_PC which would try to directly handle all the
	     different ways that a PC could be unwound.  */
	  pc = gdbarch_unwind_pc (current_gdbarch, next_frame);
	}
      else if (next_frame->level < 0)
	{
	  /* FIXME: cagney/2003-03-06: Old code and and a sentinel
             frame.  Do like was always done.  Fetch the PC's value
             direct from the global registers array (via read_pc).
             This assumes that this frame belongs to the current
             global register cache.  The assumption is dangerous.  */
	  pc = read_pc ();
	}
      else if (FRAME_SAVED_PC_P ())
	{
	  /* FIXME: cagney/2003-03-06: Old code, but not a sentinel
             frame.  Do like was always done.  Note that this method,
             unlike unwind_pc(), tries to handle all the different
             frame cases directly.  It fails.  */
	  pc = FRAME_SAVED_PC (next_frame);
	}
      else
	internal_error (__FILE__, __LINE__, "No gdbarch_unwind_pc method");
      next_frame->pc_unwind_cache = pc;
      next_frame->pc_unwind_cache_p = 1;
d158 1
a158 1
  return next_frame->pc_unwind_cache;
d685 7
d763 1
d1349 36
a1384 41
  switch (prev_frame->type)
    {
    case DUMMY_FRAME:
      /* When unwinding a normal frame, the stack structure is
	 determined by analyzing the frame's function's code (be it
	 using brute force prologue analysis, or the dwarf2 CFI).  In
	 the case of a dummy frame, that simply isn't possible.  The
	 The PC is either the program entry point, or some random
	 address on the stack.  Trying to use that PC to apply
	 standard frame ID unwind techniques is just asking for
	 trouble.  */
      if (gdbarch_unwind_dummy_id_p (current_gdbarch))
	{
	  /* Assume hand_function_call(), via SAVE_DUMMY_FRAME_TOS,
	     previously saved the dummy frame's ID.  Things only work
	     if the two return the same value.  */
	  gdb_assert (SAVE_DUMMY_FRAME_TOS_P ());
	  /* Use an architecture specific method to extract the prev's
	     dummy ID from the next frame.  Note that this method uses
	     frame_register_unwind to obtain the register values
	     needed to determine the dummy frame's ID.  */
	  prev_frame->id = gdbarch_unwind_dummy_id (current_gdbarch,
						    next_frame);
	}
      else if (next_frame->level < 0)
	{
	  /* We're unwinding a sentinel frame, the PC of which is
	     pointing at a stack dummy.  Fake up the dummy frame's ID
	     using the same sequence as is found a traditional
	     unwinder.  Once all architectures supply the
	     unwind_dummy_id method, this code can go away.  */
	  prev_frame->id.base = read_fp ();
	  prev_frame->id.pc = read_pc ();
	}
      else
	{
	  /* Outch!  We're not on the innermost frame yet we're trying
	     to unwind to a dummy.  The architecture must provide the
	     unwind_dummy_id() method.  Abandon the unwind process but
	     only after first warning the user.  */
	  internal_warning (__FILE__, __LINE__,
d1386 40
a1425 39
	  return NULL;
	}
      break;
    case NORMAL_FRAME:
    case SIGTRAMP_FRAME:
      prev_frame->unwind->id (next_frame, &prev_frame->unwind_cache,
			      &prev_frame->id);
      /* Check that the unwound ID is valid.  */
      if (!frame_id_p (prev_frame->id))
	{
	  if (frame_debug)
	    fprintf_unfiltered (gdb_stdlog,
				"Outermost frame - unwound frame ID invalid\n");
	  return NULL;
	}
      /* Check that the new frame isn't inner to (younger, below,
	 next) the old frame.  If that happens the frame unwind is
	 going backwards.  */
      /* FIXME: cagney/2003-02-25: Ignore the sentinel frame since
	 that doesn't have a valid frame ID.  Should instead set the
	 sentinel frame's frame ID to a `sentinel'.  Leave it until
	 after the switch to storing the frame ID, instead of the
	 frame base, in the frame object.  */
      if (next_frame->level >= 0
	  && frame_id_inner (prev_frame->id, get_frame_id (next_frame)))
	error ("Unwound frame inner-to selected frame (corrupt stack?)");
      /* Note that, due to frameless functions, the stronger test of
	 the new frame being outer to the old frame can't be used -
	 frameless functions differ by only their PC value.  */
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
    }

  /* FIXME: cagney/2002-12-18: Instead of this hack, should only store
     the frame ID in PREV_FRAME.  Unfortunatly, some architectures
     (HP/UX) still reply on EXTRA_FRAME_INFO and, hence, still poke at
     the "struct frame_info" object directly.  */
  prev_frame->frame = prev_frame->id.base;
d1560 2
d1563 2
a1564 4
  /* While we're at it, update this frame's cached PC value, found in
     the next frame.  Oh, for the day when "struct frame_info" is
     opaque and this hack on hack can go.  */
  gdb_assert (frame->next != NULL);
@


1.71.2.5
log
@2003-03-06  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_pop): Delete function.
	(d10v_frame_unwind): Update.
	* frame.c: Include "reggroups.h".
	* regcache.c (regcache_raw_write): Allow writes to a readonly
	regcache.
	* frame.c (frame_saved_regs_pop): Delete function.
	(trad_frame_unwinder): Update
	(frame_pop): Rewrite.
	* sentinel-frame.c (sentinel_frame_pop): Delete function.
	(sentinel_frame_unwinder): Update.
	* dummy-frame.c (dummy_frame_pop): Delete function.
	(dummy_frame_unwind): Update.
	* frame-unwind.h (frame_unwind_pop_ftype): Delete definition.
	(struct frame_unwind): Update.
@
text
@a40 1
#include "reggroups.h"
d138 1
a138 1
frame_pc_unwind (struct frame_info *this_frame)
d140 1
a140 1
  if (!this_frame->pc_unwind_cache_p)
d151 1
a151 1
	     frame_unwind_register (this_frame, ISA_PC_REGNUM, buf);
d161 1
a161 1
	  pc = gdbarch_unwind_pc (current_gdbarch, this_frame);
d163 1
a163 1
      else if (this_frame->level < 0)
d178 1
a178 1
	  pc = FRAME_SAVED_PC (this_frame);
d182 2
a183 2
      this_frame->pc_unwind_cache = pc;
      this_frame->pc_unwind_cache_p = 1;
d185 1
a185 1
  return this_frame->pc_unwind_cache;
d189 1
a189 1
frame_pop (struct frame_info *this_frame)
d191 7
a197 33
  if (POP_FRAME_P ())
    {
      POP_FRAME;
    }
  else
    {
      /* Note, the dummy-frame code does something very similar to
         this.  Perhaphs a common routine is in order.  */
      struct regcache *scratch_regcache = regcache_xmalloc (current_gdbarch);
      struct cleanup *cleanups = make_cleanup_regcache_xfree (scratch_regcache);
      void *buf = alloca (max_register_size (current_gdbarch));
      int regnum;

      /* Copy over any registers (identified by their membership in
	 the save_reggroup) and mark them as valid.  The full [0
	 .. NUM_REGS+NUM_PSEUDO_REGS) range is checked since some
	 architectures need to save/restore `cooked' registers that
	 live in memory.  */
      for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
	{
	  if (gdbarch_register_reggroup_p (current_gdbarch, regnum,
					   save_reggroup))
	    {
	      frame_unwind_register (this_frame, regnum, buf);
	      regcache_cooked_write (scratch_regcache, regnum, buf);
	    }
	}

      /* Now write the unwound registers, en-mass, back into the
         regcache.  */
      regcache_cpy (current_regcache, scratch_regcache);
      do_cleanups (cleanups);
    }
d773 8
d782 1
@


1.71.2.6
log
@2003-03-10  Andrew Cagney  <cagney@@redhat.com>

	* frame.c: Merge in posted frame_pop patch.
	* regcache.h, regcache.c: Merge with mainline.
@
text
@d41 1
a188 7
static int
do_frame_unwind_register (void *src, int regnum, void *buf)
{
  frame_unwind_register (src, regnum, buf);
  return 1;
}

a191 3
  struct regcache *scratch_regcache;
  struct cleanup *cleanups;

a193 3
      /* A legacy architecture that has implemented a custom pop
	 function.  All new architectures should instead be using the
	 generic code below.  */
d198 25
a222 11
      /* Make a copy of all the register values unwound from this
	 frame.  Save them in a scratch buffer so that there isn't a
	 race betweening trying to extract the old values from the
	 current_regcache while, at the same time writing new values
	 into that same cache.  */
      struct regcache *scratch = regcache_xmalloc (current_gdbarch);
      struct cleanup *cleanups = make_cleanup_regcache_xfree (scratch);
      regcache_save (scratch, do_frame_unwind_register, this_frame);
      /* Now copy those saved registers into the current regcache.
         Here, regcache_cpy() calls regcache_restore().  */
      regcache_cpy (current_regcache, scratch);
a224 3
  /* We've made right mess of GDB's local state, just discard
     everything.  */
  target_store_registers (-1);
@


1.71.2.7
log
@2003-03-11  Andrew Cagney  <cagney@@redhat.com>

	* frame-unwind.h (frame_this_id_ftype): Rename
	frame_unwind_id_ftype.
	(frame_prev_register_ftype): Rename frame_unwind_reg_ftype.
	(struct frame_unwind): Update.  Rename "id" to "this_id", and
	"reg" to "prev_register".
	* frame.c (get_prev_frame): Update.  Rename parameter next_frame
	to this frame.
	(frame_register_unwind): Update.
@
text
@d252 3
a254 4
  this_frame->unwind->prev_register (this_frame->next,
				     &this_frame->unwind_cache,
				     prev_regnum, optimizedp, lvalp, addrp,
				     realnump, bufferp);
d1223 1
a1223 1
get_prev_frame (struct frame_info *this_frame)
d1245 1
a1245 1
  if (this_frame == NULL)
d1258 1
a1258 1
         THIS_FRAME.  */
d1265 1
a1265 1
  gdb_assert (this_frame != NULL);
d1267 1
a1267 1
  if (this_frame->level >= 0
d1269 1
a1269 1
      && inside_main_func (get_frame_pc (this_frame)))
d1282 3
a1284 3
  if (this_frame->prev_p)
    return this_frame->prev;
  this_frame->prev_p = 1;
d1297 2
a1298 2
  if (this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && inside_entry_file (get_frame_pc (this_frame)))
d1314 2
a1315 2
      && this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && inside_entry_func (get_frame_pc (this_frame)))
d1331 1
a1331 1
      && this_frame->level >= 0)
d1333 1
a1333 1
      prev_frame = legacy_get_prev_frame (this_frame);
d1351 1
a1351 1
  prev_frame->level = this_frame->level + 1;
d1361 1
a1361 1
     THIS_FRAME's data structures have already been initialized (using
d1368 1
a1368 1
     using THIS_FRAME's frame ID.  */
d1370 1
a1370 1
  prev_frame->pc = frame_pc_unwind (this_frame);
d1409 1
a1409 1
						    this_frame);
d1411 1
a1411 1
      else if (this_frame->level < 0)
d1434 2
a1435 2
      prev_frame->unwind->this_id (this_frame, &prev_frame->unwind_cache,
				   &prev_frame->id);
d1452 2
a1453 2
      if (this_frame->level >= 0
	  && frame_id_inner (prev_frame->id, get_frame_id (this_frame)))
d1470 2
a1471 2
  this_frame->prev = prev_frame;
  prev_frame->next = this_frame;
@


1.70
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename
	INIT_EXTRA_FRAME_INFO.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-tdep.c: Update comments.
	* sh-tdep.c, mcore-tdep.c, m68hc11-tdep.c: Ditto.
	* i386-interix-tdep.c, hppa-tdep.c, h8300-tdep.c: Ditto.
	* frame.h, avr-tdep.c: Ditto.
	* frame.c (get_prev_frame): DEPRECATED_INIT_EXTRA_FRAME_INFO.
	(create_new_frame, legacy_get_prev_frame): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Initialize
	deprecated_init_extra_frame_info instead of init_extra_frame_info.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

Index: doc/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo: Rename INIT_EXTRA_FRAME_INFO to
	DEPRECATED_INIT_EXTRA_FRAME_INFO.
@
text
@d612 3
a614 2
     FRAME_INIT_SAVED_REGS method should be using this function.  */
  gdb_assert (FRAME_INIT_SAVED_REGS_P ());
d618 1
a618 1
    FRAME_INIT_SAVED_REGS (frame);
d799 1
a799 1
  gdb_assert (FRAME_INIT_SAVED_REGS_P ());
d835 1
a835 1
	  FRAME_INIT_SAVED_REGS (frame);
d1468 1
a1468 1
   that do not yet implement FRAME_INIT_SAVED_REGS.  */
@


1.69
log
@2003-02-25  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Add comment on check for
	inside_entry_func. Only check for inside_entry_file when not a
	dummy and not a sentinel.  Check that the new frame is not inner
	to the old frame.
@
text
@d908 2
a909 2
  if (INIT_EXTRA_FRAME_INFO_P ())
    INIT_EXTRA_FRAME_INFO (0, fi);
d1040 2
a1041 2
     after INIT_EXTRA_FRAME_INFO and come up with a simple way to
     express what goes on here.
d1043 9
a1051 9
     INIT_EXTRA_FRAME_INFO is called from two places: create_new_frame
     (where the PC is already set up) and here (where it isn't).
     DEPRECATED_INIT_FRAME_PC is only called from here, always after
     INIT_EXTRA_FRAME_INFO.

     The catch is the MIPS, where INIT_EXTRA_FRAME_INFO requires the
     PC value (which hasn't been set yet).  Some other machines appear
     to require INIT_EXTRA_FRAME_INFO before they can do
     DEPRECATED_INIT_FRAME_PC.  Phoo.
d1058 1
a1058 1
     INIT_EXTRA_FRAME_INFO, one possible scheme:
d1068 8
a1075 7
     INIT_PREV_FRAME(fromleaf, prev) Replace INIT_EXTRA_FRAME_INFO and
     DEPRECATED_INIT_FRAME_PC.  This should also return a flag saying
     whether to keep the new frame, or whether to discard it, because
     on some machines (e.g.  mips) it is really awkward to have
     FRAME_CHAIN_VALID called *before* INIT_EXTRA_FRAME_INFO (there is
     no good way to get information deduced in FRAME_CHAIN_VALID into
     the extra fields of the new frame).  std_frame_pc(fromleaf, prev)
d1112 2
a1113 2
  if (INIT_EXTRA_FRAME_INFO_P ())
    INIT_EXTRA_FRAME_INFO (fromleaf, prev);
d1286 1
a1286 1
       || INIT_EXTRA_FRAME_INFO_P ()
d1319 2
a1320 1
     INIT_EXTRA_FRAME_INFO) and hence the call order doesn't matter.
d1386 4
a1389 3
     this code path and rely on the below call to INIT_EXTR_FRAME_INFO
     to initialize the inner-most frame.  */
  if (INIT_EXTRA_FRAME_INFO_P ())
d1392 1
a1392 1
      INIT_EXTRA_FRAME_INFO (0, prev_frame);
@


1.68
log
@2003-02-25  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_debug): New variable.
	(_initialize_frame): Add "set/show debug frame" command.
	(get_prev_frame): When frame_debug, print reason why unwind
	failed.
@
text
@d1242 4
a1245 1
  /* If we're inside the entry file, it isn't valid.  */
d1253 2
a1254 1
  if (inside_entry_file (get_frame_pc (next_frame)))
d1262 17
d1348 3
d1358 14
@


1.67
log
@	* frame.c (generic_unwind_get_saved_register): Make non-static.
	* frame.h (generic_unwind_get_saved_register): Declare.
	* mips-tdep.c (read_next_frame_reg): Fetch register from
	current regcache when frame is NULL.
	(mips_init_extra_frame_info): Pass NULL explicitly for parameter
	that must be NULL.
	(mips_get_saved_register): Call generic_unwind_get_saved_register()
	instead of frame_register_unwind().
@
text
@d42 4
d1230 6
a1235 1
    return NULL;
d1251 4
d1256 1
d1267 7
a1273 1
    return legacy_get_prev_frame (next_frame);
d1306 8
a1313 3
    /* The allocated PREV_FRAME will be reclaimed when the frame
       obstack is next purged.  */
    return NULL;
d1328 6
a1333 1
      return NULL;
d1569 7
@


1.66
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (frame_unwind_register): New function.
	(frame_unwind_unsigned_register): Use.
	(frame_unwind_signed_register): Use.
	(frame_read_register): New function.
	* frame.h (frame_unwind_register): Declare.
	(frame_read_register): Declare.

	* d10v-tdep.c (d10v_frame_pop): Rewrite. Use regcache_cooked_write
	and frame_unwind_register instead of read_memory, write_register and
	deprecated_write_register_bytes.
@
text
@d310 1
a310 1
static void
@


1.65
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h: Note that namelen can be negative.
	* frame.c (frame_map_name_to_regnum): When LEN is negative, use
	NAME's length.

	* NEWS: Mention that the d10v's `regs' command is deprecated.
	* d10v-tdep.c (d10v_gdbarch_init): Set print_registers_info.
	(d10v_print_registers_info): New function.
	(show_regs): Call d10v_print_registers_info.
	(_initialize_d10v_tdep): Mark "show regs" command as deprecated.
@
text
@d241 1
a241 2
frame_unwind_signed_register (struct frame_info *frame, int regnum,
			      LONGEST *val)
a246 1
  void *buf = alloca (MAX_REGISTER_RAW_SIZE);
d249 8
a263 4
  int optimized;
  CORE_ADDR addr;
  int realnum;
  enum lval_type lval;
d265 1
a265 2
  frame_register_unwind (frame, regnum, &optimized, &lval, &addr,
			 &realnum, buf);
d267 7
@


1.64
log
@2003-01-29  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (frame_saved_regs_id_unwind): Assert FRAME_CHAIN_P.
	(legacy_get_prev_frame): Assert FRAME_CHAIN_P.
	(get_prev_frame): When FRAME_CHAIN_P, call legacy_get_prev_frame.
	(frame_saved_regs_pc_unwind): Assert FRAME_SAVED_PC_P.
	* gdbarch.sh (FRAME_CHAIN): Change to a function with predicate.
	(FRAME_SAVED_PC): Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d388 3
@


1.63
log
@2003-01-27  Andrew Cagney  <ac131313@@redhat.com>

	* sentinel-frame.h, sentinel-frame.c: New files.
	* Makefile.in (frame.o): Update dependencies.
	(SFILES): Add sentinel-frame.c.
	(sentinel_frame_h): Define.
	(COMMON_OBS): Add sentinel-frame.o.
	(sentinel-frame.o): Specify dependencies.
	* frame.c: Include "sentinel-frame.h".
	(frame_register_unwind): Rewrite assuming that there is always a a
	->next frame.
	(frame_register, generic_unwind_get_saved_register): Ditto.
	(frame_read_unsigned_register, frame_read_signed_register): Ditto.
	(create_sentinel_frame, unwind_to_current_frame): New functions.
	(get_current_frame): Rewrite using create_sentinel_frame and
	unwind_to_current_frame.  When possible, always create a frame.
	(create_new_frame): Set next to the sentinel frame.
	(get_next_frame): Rewrite.  Don't go below the level 0 frame.
	(deprecated_update_frame_pc_hack): Update the next frame's PC and
	ID cache when necessary.
	(frame_saved_regs_id_unwind): Use frame_relative_level.
	(deprecated_generic_get_saved_register): Use frame_relative_level,
	get_frame_saved_regs, get_frame_pc, get_frame_base and
	get_next_frame.
	(frame_saved_regs_register_unwind): Use get_frame_saved_regs and
	frame_register.
@
text
@d668 1
d717 1
d1000 1
d1239 2
a1240 1
       || INIT_EXTRA_FRAME_INFO_P ())
@


1.62
log
@2003-01-21  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_OBSTACK_ZALLOC): Define.
	* blockframe.c (backtrace_below_main): Move to "frame.c".
	(frame_chain_valid): Delete check for backtrace_below_main.
	(_initialize_blockframe): Delete initialization, move ``set
	backtrace-below-main'' command to "frame.c".
	(do_flush_frames_sfunc): Delete function.
	* frame.c: Include "command.h" and "gdbcmd.h".
	(frame_type_from_pc): New function.
	(create_new_frame): Use frame_type_from_pc.
	(legacy_get_prev_frame): New function.
	(get_prev_frame): Rewrite.  When an old style frame, call
	legacy_get_prev_frame.  Otherwize, unwind the PC first.
	(_initialize_frame): Add ``set backtrace-below-main'' command.
	* Makefile.in (frame.o): Update dependencies.
@
text
@d34 1
d183 5
a187 23
  /* NOTE: cagney/2002-04-14: It would be nice if, instead of a
     special case, there was always an inner frame dedicated to the
     hardware registers.  Unfortunatly, there is too much unwind code
     around that looks up/down the frame chain while making the
     assumption that each frame level is using the same unwind code.  */

  if (frame == NULL)
    {
      /* We're in the inner-most frame, get the value direct from the
	 register cache.  */
      *optimizedp = 0;
      *lvalp = lval_register;
      /* ULGH!  Code uses the offset into the raw register byte array
         as a way of identifying a register.  */
      *addrp = REGISTER_BYTE (regnum);
      /* Should this code test ``register_cached (regnum) < 0'' and do
         something like set realnum to -1 when the register isn't
         available?  */
      *realnump = regnum;
      if (bufferp)
	deprecated_read_register_gen (regnum, bufferp);
      return;
    }
d233 5
a237 19
  /* Reached the the bottom (youngest, inner most) of the frame chain
     (youngest, inner most) frame, go direct to the hardware register
     cache (do not pass go, do not try to cache the value, ...).  The
     unwound value would have been cached in frame->next but that
     doesn't exist.  This doesn't matter as the hardware register
     cache is stopping any unnecessary accesses to the target.  */

  /* NOTE: cagney/2002-04-14: It would be nice if, instead of a
     special case, there was always an inner frame dedicated to the
     hardware registers.  Unfortunatly, there is too much unwind code
     around that looks up/down the frame chain while making the
     assumption that each frame level is using the same unwind code.  */

  if (frame == NULL)
    frame_register_unwind (NULL, regnum, optimizedp, lvalp, addrp, realnump,
			   bufferp);
  else
    frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			   realnump, bufferp);
d289 2
a290 2
  gdb_assert (frame != NULL);
  frame_unwind_unsigned_register (get_next_frame (frame), regnum, val);
d297 3
a299 3
  /* See note in frame_read_unsigned_register().  */
  gdb_assert (frame != NULL);
  frame_unwind_signed_register (get_next_frame (frame), regnum, val);
d327 3
a329 19
  /* Reached the the bottom (youngest, inner most) of the frame chain
     (youngest, inner most) frame, go direct to the hardware register
     cache (do not pass go, do not try to cache the value, ...).  The
     unwound value would have been cached in frame->next but that
     doesn't exist.  This doesn't matter as the hardware register
     cache is stopping any unnecessary accesses to the target.  */

  /* NOTE: cagney/2002-04-14: It would be nice if, instead of a
     special case, there was always an inner frame dedicated to the
     hardware registers.  Unfortunatly, there is too much unwind code
     around that looks up/down the frame chain while making the
     assumption that each frame level is using the same unwind code.  */

  if (frame == NULL)
    frame_register_unwind (NULL, regnum, optimizedp, lvalp, addrp, &realnumx,
			   raw_buffer);
  else
    frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			   &realnumx, raw_buffer);
d419 26
d477 16
a492 1
/* Return the innermost (currently executing) stack frame.  */
d497 6
d505 9
a513 4
      if (target_has_stack)
	current_frame = create_new_frame (read_fp (), read_pc ());
      else
	error ("No stack.");
d601 1
a601 1
  if (frame->saved_regs == NULL)
d604 2
a605 2
  if (frame->saved_regs != NULL
      && frame->saved_regs[regnum] != 0)
d616 1
a616 1
			   frame->saved_regs[regnum]);
d624 1
a624 1
	  *addrp = frame->saved_regs[regnum];
d643 1
a643 1
		  read_memory (frame->saved_regs[regnum], regs[regnum],
d649 1
a649 1
	      read_memory (frame->saved_regs[regnum], bufferp,
d658 5
a662 15
     value.  If a value is needed, pass the request on down the chain;
     otherwise just return an indication that the value is in the same
     register as the next frame.  */
  if (bufferp == NULL)
    {
      *optimizedp = 0;
      *lvalp = lval_register;
      *addrp = 0;
      *realnump = regnum;
    }
  else
    {
      frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			     realnump, bufferp);
    }
d682 1
a682 1
  if (next_frame->next == NULL)
d795 1
a795 1
  while (frame && ((frame = frame->next) != NULL))
d797 3
a799 1
      if (get_frame_type (frame) == DUMMY_FRAME)
d801 1
a801 20
	  if (lval)		/* found it in a CALL_DUMMY frame */
	    *lval = not_lval;
	  if (raw_buffer)
	    /* FIXME: cagney/2002-06-26: This should be via the
	       gdbarch_register_read() method so that it, on the fly,
	       constructs either a raw or pseudo register from the raw
	       register cache.  */
	    regcache_raw_read (generic_find_dummy_frame (frame->pc,
							 frame->frame),
			       regnum, raw_buffer);
	  return;
	}

      FRAME_INIT_SAVED_REGS (frame);
      if (frame->saved_regs != NULL
	  && frame->saved_regs[regnum] != 0)
	{
	  if (lval)		/* found it saved on the stack */
	    *lval = lval_memory;
	  if (regnum == SP_REGNUM)
d803 12
a814 3
	      if (raw_buffer)	/* SP register treated specially */
		store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
			       frame->saved_regs[regnum]);
d816 4
a819 1
	  else
d821 17
a837 5
	      if (addrp)	/* any other register */
		*addrp = frame->saved_regs[regnum];
	      if (raw_buffer)
		read_memory (frame->saved_regs[regnum], raw_buffer,
			     REGISTER_RAW_SIZE (regnum));
a838 1
	  return;
d888 1
d901 2
a902 1
   frame).  */
d907 4
a910 1
  return frame->next;
d1424 1
@


1.61
log
@2003-01-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (frame_saved_regs_pop): Assert POP_FRAME_P.
	* gdbarch.sh (POP_FRAME): Change to function with predicate.
	Suppress actual parameters when `-'.
	* gdbarch.h, gdbarch.c: Regenerate.
@
text
@d38 6
d852 23
a881 1
  enum frame_type type;
d887 1
a887 24
  /* NOTE: cagney/2002-11-18: The code segments, found in
     create_new_frame and get_prev_frame(), that initializes the
     frames type is subtly different.  The latter only updates ->type
     when it encounters a SIGTRAMP_FRAME or DUMMY_FRAME.  This stops
     get_prev_frame() overriding the frame's type when the INIT code
     has previously set it.  This is really somewhat bogus.  The
     initialization, as seen in create_new_frame(), should occur
     before the INIT function has been called.  */
  if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES
      && (DEPRECATED_PC_IN_CALL_DUMMY_P ()
	  ? DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0)
	  : pc_in_dummy_frame (pc)))
    /* NOTE: cagney/2002-11-11: Does this even occure?  */
    type = DUMMY_FRAME;
  else
    {
      char *name;
      find_pc_partial_function (pc, &name, NULL, NULL);
      if (PC_IN_SIGTRAMP (fi->pc, name))
	type = SIGTRAMP_FRAME;
      else
	type = NORMAL_FRAME;
    }
  fi->type = type;
d935 2
a936 3
/* Return a structure containing various interesting information
   about the frame that called NEXT_FRAME.  Returns NULL
   if there is no such frame.  */
d938 2
a939 2
struct frame_info *
get_prev_frame (struct frame_info *next_frame)
d945 3
a947 26
  /* Return the inner-most frame, when the caller passes in NULL.  */
  /* NOTE: cagney/2002-11-09: Not sure how this would happen.  The
     caller should have previously obtained a valid frame using
     get_selected_frame() and then called this code - only possibility
     I can think of is code behaving badly.  */
  if (next_frame == NULL)
    {
      /* NOTE: cagney/2002-11-09: There was a code segment here that
	 would error out when CURRENT_FRAME was NULL.  The comment
	 that went with it made the claim ...

	 ``This screws value_of_variable, which just wants a nice
	 clean NULL return from block_innermost_frame if there are no
	 frames.  I don't think I've ever seen this message happen
	 otherwise.  And returning NULL here is a perfectly legitimate
	 thing to do.''

         Per the above, this code shouldn't even be called with a NULL
         NEXT_FRAME.  */
      return current_frame;
    }

  /* Only try to do the unwind once.  */
  if (next_frame->prev_p)
    return next_frame->prev;
  next_frame->prev_p = 1;
d958 1
a958 1
  if (next_frame->next == NULL)
d1150 156
d1500 17
@


1.60
log
@2003-01-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame-unwind.h (frame_unwind_pop_ftype): Declare.
	(struct frame_unwind): Add field pop.
	* frame.h (frame_pop): Declare.
	* frame.c (frame_saved_regs_pop): New function.
	(trad_frame_unwinder): Add frame_saved_regs_pop.
	(frame_pop): New function.
	* dummy-frame.c (dummy_frame_pop): New function.
	(discard_innermost_dummy): New function.
	(generic_pop_dummy_frame): Use discard_innermost_dummy.
	(dummy_frame_unwind): Add dummy_frame_pop.
	* infrun.c (normal_stop): Call frame_pop instead of POP_FRAME.
	* valops.c (hand_function_call): Ditto.
	* stack.c (return_command): Ditto.
@
text
@d734 1
@


1.59
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* dummy-frame.h (dummy_frame_id_unwind): Delete declaration.
	(dummy_frame_pc_unwind, dummy_frame_register_unwind): Ditto.
	(struct frame_unwind): Declare opaque.
	(dummy_frame_p): Declare function.
	* dummy-frame.c (dummy_frame_id_unwind): Make static.
	(dummy_frame_pc_unwind, dummy_frame_register_unwind): Ditto.
	* dummy-frame.c: Include "frame-unwind.h".
	(dummy_frame_p): New function.
	(dummy_frame_unwind): New variable.
	* frame.c: Include "frame-unwind.h".
	(frame_pc_unwind, frame_id_unwind, frame_register_unwind): Update
	to use the new unwind field.
	(set_unwind_by_pc): Delete function.
	(create_new_frame, get_prev_frame): Set unwind field using
	frame_unwind_find_by_pc.
	(trad_frame_unwind, trad_frame_unwinder): New variables.
	* frame.h (trad_frame_unwind): Declare variable.
	(frame_id_unwind_ftype): Delete declaration.
	(frame_pc_unwind_ftype, frame_register_unwind_ftype): Ditto.
	(struct frame_unwind): Declare opaque.
	(struct frame_info): Replace the fields id_unwind, pc_unwind and
	register_unwind with a single unwind pointer.
	* frame-unwind.h, frame-unwind.c: New files.
	* Makefile.in (SFILES): Add frame-unwind.c.
	(frame_unwind_h): Define.
	(COMMON_OBS): Add frame-unwind.o.
	(frame-unwind.o): Specify dependencies.
	(frame.o, dummy-frame.o): Update dependencies.
@
text
@d148 12
d730 7
d738 1
@


1.58
log
@2003-01-16  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (frame_id_unwind_ftype): Change type so that the frame's
	ID back using a parameter.
	* frame.c (frame_id_unwind): Update call.
	(frame_saved_regs_id_unwind): Update.
	* dummy-frame.c (dummy_frame_id_unwind): Update function.
	* dummy-frame.h (struct frame_id): Add opaque declaration.
	(dummy_frame_id_unwind): Update declaration.
@
text
@d37 1
d131 1
a131 1
      frame->pc_unwind_cache = frame->pc_unwind (frame, &frame->unwind_cache);
d142 1
a142 1
      frame->id_unwind (frame, &frame->unwind_cache, &frame->id_unwind_cache);
d189 2
a190 2
  frame->register_unwind (frame, &frame->unwind_cache, regnum,
			  optimizedp, lvalp, addrp, realnump, bufferp);
d718 8
a824 36
/* Using the PC, select a mechanism for unwinding a frame returning
   the previous frame.  The register unwind function should, on
   demand, initialize the ->context object.  */

static void
set_unwind_by_pc (CORE_ADDR pc, CORE_ADDR fp,
		  frame_register_unwind_ftype **unwind_register,
		  frame_pc_unwind_ftype **unwind_pc,
		  frame_id_unwind_ftype **unwind_id)
{
  if (!DEPRECATED_USE_GENERIC_DUMMY_FRAMES)
    {
      /* Still need to set this to something.  The ``info frame'' code
	 calls this function to find out where the saved registers are.
	 Hopefully this is robust enough to stop any core dumps and
	 return vaguely correct values..  */
      *unwind_register = frame_saved_regs_register_unwind;
      *unwind_pc = frame_saved_regs_pc_unwind;
      *unwind_id = frame_saved_regs_id_unwind;
    }
  else if (DEPRECATED_PC_IN_CALL_DUMMY_P ()
	   ? DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0)
	   : pc_in_dummy_frame (pc))
    {
      *unwind_register = dummy_frame_register_unwind;
      *unwind_pc = dummy_frame_pc_unwind;
      *unwind_id = dummy_frame_id_unwind;
    }
  else
    {
      *unwind_register = frame_saved_regs_register_unwind;
      *unwind_pc = frame_saved_regs_pc_unwind;
      *unwind_id = frame_saved_regs_id_unwind;
    }
}

d867 1
a867 2
  set_unwind_by_pc (fi->pc, fi->frame, &fi->register_unwind,
		    &fi->pc_unwind, &fi->id_unwind);
d1110 1
a1110 2
  set_unwind_by_pc (prev->pc, prev->frame, &prev->register_unwind,
		    &prev->pc_unwind, &prev->id_unwind);
@


1.57
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (FRAME_INIT_SAVED_REGS): Change to function with
	predicate.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Only initialize the saved registers when
	FRAME_INIT_SAVED_REGS_P.
	* frame.c (frame_saved_regs_register_unwind): Assert
	FRAME_INIT_SAVED_REGS_P.
	(deprecated_generic_get_saved_register): Ditto.
@
text
@d141 1
a141 2
      frame->id_unwind_cache =
	frame->id_unwind (frame, &frame->unwind_cache);
d657 3
a659 2
static struct frame_id
frame_saved_regs_id_unwind (struct frame_info *next_frame, void **cache)
d662 5
a666 1
  struct frame_id id;
d684 1
a684 1
    id.base = get_frame_base (next_frame);
d702 1
a702 1
      id.base = FRAME_CHAIN (next_frame);
d704 2
a705 2
      if (!frame_chain_valid (id.base, next_frame))
	return null_frame_id;
d707 2
a708 2
  if (id.base == 0)
    return null_frame_id;
d712 3
a714 2
  id.pc = frame_pc_unwind (next_frame);
  return id;
@


1.56
log
@2003-01-09  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (frame_obstack_zalloc): Replace frame_obstack_alloc.
	Update comments.
	* frame.c (frame_obstack_zalloc): Replace frame_obstack_alloc.
	(frame_saved_regs_zalloc): Update.
	(frame_saved_regs_register_unwind): Update.
	(create_new_frame): Update.
	(get_prev_frame): Update.
	(frame_extra_info_zalloc): Update.
	(deprecated_get_frame_saved_regs): Update.
	* dwarf2cfi.c (cfi_init_extra_frame_info): Update.
	* cris-tdep.c: Update comment.
@
text
@d573 4
d744 2
@


1.56.2.1
log
@2003-01-10  Andrew Cagney  <ac131313@@redhat.com>

	* sentinel-frame.c (sentinel_frame_register_unwind): Correctly set
	LVALP and ADDRP.

	* frame.c: Include "ui-out.h".

	* frame.c (frame_type_from_pc): New function.
	(create_new_frame): Use.
	(set_unwind_by_pc): Drop unused frame parameter.
	(deprecated_get_prev_frame): Rename old get_prev_frame.
	(get_prev_frame): Rewrite.  Unwind the PC first.  Use
	frame_id_unwind.

	* dummy-frame.h (dummy_frame_id_unwind): Update.
	(dummy_frame_pc_unwind): Update.
	(dummy_frame_register_unwind): Update.
	* dummy-frame.c: Update.

	* frame.c (create_new_frame): Set next to a sentinal frame.
	(create_sentinel_frame): New function.
	(frame_id_unwind): Update id_unwind call.
	(frame_saved_regs_register_unwind): Update cache parameter.
	(frame_saved_regs_pc_unwind): Update cache parameter.
	(frame_saved_regs_id_unwind): Update cache and id parameters.

	* frame.h (frame_id_unwind_ftype): Return the frame ID using a
	reference parameter.
	(struct frame_unwind_cache): Declare.
	(frame_id_unwind_ftype, frame_pc_unwind_ftype,
	frame_register_unwind_ftype): Change the unwind cache_type to
	`struct frame_unwind_cache'.
	(struct frame_info): Change type of unwind_cache to `struct
	frame_unwind_cache'.

	* frame.c (get_next_frame): Don't go beyond the inner-most frame.
	(frame_register_unwind): Assume that there is always a next frame.
	(frame_register): Ditto.
	(generic_unwind_get_saved_register): Ditto.

	* frame.h (frame_type): Add SENTINEL_FRAME.

	* Makefile.in (frame.o): Update dependencies.

	* frame.h (FRAME_OBSTACK_ZALLOC): Define.

	* Makefile.in (sentinel-frame.o): Specify dependencies.
	(sentinel_frame_h): Define.
	(SFILES): Add sentinel-frame.c.
	(COMMON_OBS): Add sentinel-frame.o.
	* sentinel-frame.c: New file.
	* sentinel-frame.h: New file.
@
text
@a33 1
#include "sentinel-frame.h"
a36 1
#include "ui-out.h"
d141 2
a142 1
      frame->id_unwind (frame, &frame->unwind_cache, &frame->id_unwind_cache);
d164 23
a186 5
  /* NOTE: cagney/2002-11-27: A program trying to unwind a NULL frame
     is broken.  There is always a frame.  If there, for some reason,
     isn't, there is some pretty busted code as it should have
     detected the problem before calling here.  */
  gdb_assert (frame != NULL);
d232 19
a250 5
  /* Obtain the register value by unwinding the register from the next
     (more inner frame).  */
  gdb_assert (frame != NULL && frame->next != NULL);
  frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			 realnump, bufferp);
d340 19
a358 3
  gdb_assert (frame != NULL && frame->next != NULL);
  frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
                        &realnumx, raw_buffer);
a447 15
/* Create the sentinel frame.  */

struct frame_info *
create_sentinel_frame (struct regcache *regcache)
{
  struct frame_info *frame = FRAME_OBSTACK_ZALLOC (struct frame_info);
  frame->type = SENTINEL_FRAME;
  frame->level = -1;
  frame->unwind_cache = sentinel_frame_cache (regcache);
  frame->pc_unwind = sentinel_frame_pc_unwind;
  frame->id_unwind = sentinel_frame_id_unwind;
  frame->register_unwind = sentinel_frame_register_unwind;
  return frame;
}

a481 7
static int
unwind_to_current_frame (struct ui_out *ui_out, void *args)
{
  current_frame = get_prev_frame (args);
  return 0;
}

a484 6
  if (!target_has_stack)
    error ("No stack.");
  if (!target_has_registers)
    error ("No registers.");
  if (!target_has_memory)
    error ("No memory.");
d487 4
a490 9
      struct frame_info *sentinel_frame =
	create_sentinel_frame (current_regcache);
      if (catch_exceptions (uiout, unwind_to_current_frame, sentinel_frame,
			    NULL, RETURN_MASK_ERROR) < 0)
	{
	  /* Oops! Fake a current frame?  Is this useful?  It has a PC
             of zero, for instance.  */
	  current_frame = sentinel_frame;
	}
a557 5
struct frame_unwind_cache
{
  void *regs[1];
};

d559 1
a559 2
frame_saved_regs_register_unwind (struct frame_info *frame,
				  struct frame_unwind_cache **cache,
d604 2
a605 1
	      if ((*cache) == NULL)
d609 2
a610 1
		  (*cache) = frame_obstack_zalloc (sizeof_cache);
d612 1
a612 1
	      if ((*cache)->regs[regnum] == NULL)
d614 1
a614 1
		  (*cache)->regs[regnum]
d616 1
a616 2
		  read_memory (frame->saved_regs[regnum],
			       (*cache)->regs[regnum],
d619 1
a619 2
	      memcpy (bufferp, (*cache)->regs[regnum],
		      REGISTER_RAW_SIZE (regnum));
d649 1
a649 2
frame_saved_regs_pc_unwind (struct frame_info *frame,
			    struct frame_unwind_cache **cache)
d654 2
a655 4
static void
frame_saved_regs_id_unwind (struct frame_info *next_frame,
			    struct frame_unwind_cache **cache,
			    struct frame_id *id)
d658 1
d676 1
a676 1
    id->base = get_frame_base (next_frame);
d694 1
a694 1
      id->base = FRAME_CHAIN (next_frame);
d696 2
a697 10
      if (!frame_chain_valid (id->base, next_frame))
	{
	  *id = null_frame_id;
	  return;
	}
    }
  if (id->base == 0)
    {
      *id = null_frame_id;
      return;
d699 2
d704 2
a705 2
  id->pc = frame_pc_unwind (next_frame);
  return;
d810 1
a810 1
set_unwind_by_pc (CORE_ADDR pc,
a840 23
/* Determine the frame's type based on its PC.  */

static enum frame_type
frame_type_from_pc (CORE_ADDR pc)
{
  /* FIXME: cagney/2002-11-24: Can't yet directly call
     pc_in_dummy_frame() as some architectures don't set
     PC_IN_CALL_DUMMY() to generic_pc_in_call_dummy() (remember the
     latter is implemented by simply calling pc_in_dummy_frame).  */
  if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES
      && DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0))
    return DUMMY_FRAME;
  else
    {
      char *name;
      find_pc_partial_function (pc, &name, NULL, NULL);
      if (PC_IN_SIGTRAMP (pc, name))
	return SIGTRAMP_FRAME;
      else
	return NORMAL_FRAME;
    }
}

d854 24
a877 2
  fi->next = create_sentinel_frame (current_regcache);
  fi->type = frame_type_from_pc (pc);
d883 2
a884 2
  set_unwind_by_pc (fi->pc, &fi->register_unwind, &fi->pc_unwind,
		    &fi->id_unwind);
d895 1
a895 6
  /* Don't fall off the bottom of the frame chain.  This code has an
     extra magic frame, don't expose that externally.  */
  if (frame->level > 0)
    return frame->next;
  else
    return NULL;
d926 3
a928 2
/* Create the previous frame using the original INIT_EXTRA_INFO
   method.  */
d930 2
a931 2
static struct frame_info *
deprecated_get_prev_frame (struct frame_info *next_frame)
d937 22
d1127 2
a1128 2
  set_unwind_by_pc (prev->pc, &prev->register_unwind, &prev->pc_unwind,
		    &prev->id_unwind);
a1163 130
}

/* Return a structure containing various interesting information
   about the frame that called NEXT_FRAME.  Returns NULL
   if there is no such frame.  */

struct frame_info *
get_prev_frame (struct frame_info *next_frame)
{
  struct frame_info *prev_frame;

  /* Return the inner-most frame, when the caller passes in NULL.  */
  /* NOTE: cagney/2002-11-09: Not sure how this would happen.  The
     caller should have previously obtained a valid frame using
     get_selected_frame() and then called this code - only possibility
     I can think of is code behaving badly.

     NOTE: cagney/2003-01-10: Talk about code behaving badly.  Check
     block_innermost_frame().  It does the sequence: frame = NULL;
     while (1) { frame = get_prev_frame (frame); .... }.  Ulgh!  Why
     it couldn't be written better, I don't know.  */
  if (next_frame == NULL)
    {
      /* NOTE: cagney/2002-11-09: There was a code segment here that
	 would error out when CURRENT_FRAME was NULL.  The comment
	 that went with it made the claim ...

	 ``This screws value_of_variable, which just wants a nice
	 clean NULL return from block_innermost_frame if there are no
	 frames.  I don't think I've ever seen this message happen
	 otherwise.  And returning NULL here is a perfectly legitimate
	 thing to do.''

         Per the above, this code shouldn't even be called with a NULL
         NEXT_FRAME.  */
      return current_frame;
    }

  if ((DEPRECATED_INIT_FRAME_PC_P ()
       || DEPRECATED_INIT_FRAME_PC_FIRST_P ())
      && next_frame->level >= 0)
    /* Don't try to unwind the sentinal frame using the old code.  */
    return deprecated_get_prev_frame (next_frame);

  /* There is always a frame.  If this assertion fails, suspect that
     something should be calling get_selected_frame() or
     get_current_frame().  */
  gdb_assert (next_frame != NULL);

  /* Only try to do the unwind once.  */
  if (next_frame->prev_p)
    return next_frame->prev;
  next_frame->prev_p = 1;

  if (next_frame->level >= 0
      /* && !backtrace_below_main */
      && inside_main_func (next_frame->pc))
    /* Don't unwind past main(), always unwind the sentinel frame.  */
    return 0;

  /* Allocate the new frame but do not wire it in.  Some (bad) code in
     INIT_EXTRA_FRAME_INFO tries to look along frame->next to pull
     some fancy tricks (of course such code is, by definition,
     recursive).  Try to prevent it.  */
  prev_frame = FRAME_OBSTACK_ZALLOC (struct frame_info);
  prev_frame->level = next_frame->level + 1;

  /* Try to unwind the PC.  If that doesn't work, assume we've reached
     the oldest frame and simply return.  Is there a better sentinal
     value?  The unwound PC value is then used to initialize the new
     previous frame's type.

     Note that the pc-unwind is intentionally performed before the
     frame chain.  This is ok since, for old targets, both
     frame_pc_unwind (nee, FRAME_SAVED_PC) and FRAME_CHAIN()) assume
     NEXT_FRAME's data structures have already been initialized (using
     INIT_EXTRA_FRAME_INFO) and hence the call order doesn't matter.

     By unwinding the PC first, it becomes possible to, in the case of
     a dummy frame, avoid also unwinding the frame ID.  This is
     because (well ignoring the PPC) a dummy frame can be located
     using NEXT_FRAME's frame ID.  */

  prev_frame->pc = frame_pc_unwind (next_frame);
  if (prev_frame->pc == 0)
    /* The allocated PREV_FRAME will be reclaimed when the frame
       obstack is next purged.  */
    return NULL;
  prev_frame->type = frame_type_from_pc (prev_frame->pc);

  /* Set the unwind functions based on that identified PC.  */
  set_unwind_by_pc (prev_frame->pc, &prev_frame->register_unwind,
		    &prev_frame->pc_unwind, &prev_frame->id_unwind);

  /* Now figure out how to initialize this new frame.  Perhaphs one
     day, this will too, be selected by set_unwind_by_pc().  */
  if (prev_frame->type != DUMMY_FRAME)
    {
      /* A dummy frame doesn't need to unwind the frame ID because the
	 frame ID comes from the previous frame.  The other frames do
	 though.  True?  */
#if 0
      /* Oops, the frame doesn't chain.  Treat this as the last frame.  */
      prev_frame->id = frame_id_unwind (next_frame);
      if (!frame_id_p (prev_frame->id))
	return NULL;
#else      
      /* FIXME: cagney/2002-12-18: Instead of this hack, should just
	 save the frame ID directly.  */
      struct frame_id id = frame_id_unwind (next_frame);
      if (!frame_id_p (id))
	return NULL;
      prev_frame->frame = id.base;
#endif
    }

  /* Link it in.  */
  next_frame->prev = prev_frame;
  prev_frame->next = next_frame;

  /* NOTE: cagney/2002-12-18: Eventually this call will go away.
     Instead of initializing extra info, all frames will use the
     frame_cache (passed to the unwind functions) to store extra frame
     info.  */
  if (INIT_EXTRA_FRAME_INFO_P ())
    /* NOTE: This code doesn't bother trying to sort out frameless
       functions.  That is left to the target.  */
    INIT_EXTRA_FRAME_INFO (0, prev_frame);

  return prev_frame;
@


1.56.2.2
log
@Move legacy frame code to legacy-frame.[hc].
@
text
@a34 1
#include "legacy-frame.h"
a412 6
  /* Always unwind the PC as part of creating this frame.  This
     ensures that the frame's PC points into something valid.  */
  /* FIXME: cagney/2003-01-10: Problem here.  Unwinding a sentinel
     frame's PC may require information such as the frame thread's
     stop reason.  Is it possible to get to that?  */
  frame->pc = frame_pc_unwind (frame);
d453 1
a453 6
  struct frame_info *frame = get_prev_frame (args);
  /* A sentinel frame can fail to unwind, eg, because it's PC value
     lands in somewhere like start.  */
  if (frame == NULL)
    return 1;
  current_frame = frame;
d471 1
a471 1
			    NULL, RETURN_MASK_ERROR) != 0)
d540 265
d821 3
a823 3
      *unwind_register = legacy_frame_register_unwind;
      *unwind_pc = legacy_frame_pc_unwind;
      *unwind_id = legacy_frame_id_unwind;
d835 3
a837 3
      *unwind_register = legacy_frame_register_unwind;
      *unwind_pc = legacy_frame_pc_unwind;
      *unwind_id = legacy_frame_id_unwind;
d936 1
a936 1
legacy_get_prev_frame (struct frame_info *next_frame)
d942 5
d1083 1
a1083 1
    deprecated_update_frame_pc_hack (prev, DEPRECATED_INIT_FRAME_PC_FIRST (fromleaf, prev));
d1092 1
a1092 1
    deprecated_update_frame_pc_hack (prev, DEPRECATED_INIT_FRAME_PC (fromleaf, prev));
d1098 2
a1099 2
  if (get_frame_base (prev) == get_frame_base (next_frame)
      && get_frame_pc (prev) == get_frame_pc (next_frame))
d1110 2
a1111 2
  set_unwind_by_pc (get_frame_pc (prev), &prev->register_unwind,
		    &prev->pc_unwind, &prev->id_unwind);
d1123 2
a1124 2
	  ? DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (prev), 0, 0)
	  : pc_in_dummy_frame (get_frame_pc (prev))))
d1135 2
a1136 2
      find_pc_partial_function (get_frame_pc (prev), &name, NULL, NULL);
      if (PC_IN_SIGTRAMP (get_frame_pc (prev), name))
d1185 6
a1195 9
  if (next_frame->level >= 0
      /* && !backtrace_below_main */
      && inside_main_func (get_frame_pc (next_frame)))
    /* Don't unwind past main(), always unwind the sentinel frame.
       Note, this is done _before_ the frame has been marked as
       previously unwound.  That way if the user later decides to
       allow unwinds past main(), they can just happen.  */
    return 0;

d1201 5
a1205 16
  /* If we're inside the entry file, it isn't valid.  */
  /* NOTE: drow/2002-12-25: should there be a way to disable this
     check?  It assumes a single small entry file, and the way some
     debug readers (e.g.  dbxread) figure out which object is the
     entry file is somewhat hokey.  */
  /* NOTE: cagney/2003-01-10: If there is a way of disabling this test
     then it should probably be moved to before the ->prev_p test,
     above.  */
  if (inside_entry_file (get_frame_pc (next_frame)))
      return NULL;

  if ((DEPRECATED_INIT_FRAME_PC_P ()
       || DEPRECATED_INIT_FRAME_PC_FIRST_P ())
      && next_frame->level >= 0)
    /* Don't try to unwind the sentinal frame using the old code.  */
    return legacy_get_prev_frame (next_frame);
@


1.56.2.3
log
@2003-01-11  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (deprecated_update_frame_pc_hack)
	(deprecated_update_frame_base_hack): Also update the next frame's
	ID/PC cache.
	(create_sentinel_frame): Link the sentinel frame to itself.
	* frame.h: Expand comments describing update PC and FP hacks.
	* frame.c (get_prev_frame): Add comment explaining why
	INIT_EXTRA_FRAME_INFO call is needed.
	(legacy_get_prev_frame): Use get_next_frame.
@
text
@a59 23
struct frame_id
frame_id_unwind (struct frame_info *frame)
{
  if (!frame->id_unwind_cache_p)
    {
      frame->id_unwind (frame, &frame->unwind_cache, &frame->id_unwind_cache);
      frame->id_unwind_cache_p = 1;
    }
  return frame->id_unwind_cache;
}

void
deprecated_update_frame_base_hack (struct frame_info *frame, CORE_ADDR base)
{
  /* See comment in "frame.h".  */
  frame->frame = base;
  gdb_assert (frame->next != NULL);
  gdb_assert (frame->next->id_unwind_cache_p);
  gdb_assert (frame->next->pc_unwind_cache_p);
  frame->next->id_unwind_cache.base = base;
  frame->next->id_unwind_cache.pc = frame->next->pc_unwind_cache;
}

d128 22
a413 4
  /* Link this frame back to itself.  The frame is self referential
     (the unwound PC is the same as the pc for instance, so make it
     so.  */
  frame->next = frame;
a688 3
  /* This code doesn't work with the sentinal frame.  */
  gdb_assert (next_frame->level >= 0);

d698 1
a698 1
  if (get_next_frame (next_frame) == NULL)
d909 1
a909 9
     it couldn't be written better, I don't know.

     NOTE: cagney/2003-01-11: I suspect what is happening is
     block_innermost_frame() is, when the target has no state
     (registers, memory, ...), still calling this function.  The
     assumption being that this function will return NULL indicating
     that a frame isn't possible, rather than checking that the target
     has state and then calling get_current_frame() and
     get_prev_frame().  This is a guess mind.  */
d960 1
a960 1
     /* Don't try to unwind the sentinal frame using the old code.  */
a1026 2
  /* NOTE: cagney/2003-01-11: Legacy targets, when having the sentinel
     frame unwound, rely on this call.  */
a1037 1
  /* This should just call frame_pc_unwind().  */
a1040 29
CORE_ADDR
frame_pc_unwind (struct frame_info *frame)
{
  if (!frame->pc_unwind_cache_p)
    {
      frame->pc_unwind_cache = frame->pc_unwind (frame, &frame->unwind_cache);
      frame->pc_unwind_cache_p = 1;
    }
  return frame->pc_unwind_cache;
}

void
deprecated_update_frame_pc_hack (struct frame_info *frame, CORE_ADDR pc)
{
  /* See comment in "frame.h".  */
  frame->pc = pc;
  gdb_assert (frame->next != NULL);
  /* Got a bucket?  Legacy code that handles dummy frames directly
     doesn't always use the unwind function to determine the dummy
     frame's PC.  Consequently, it is possible for this function to be
     called when the next frame's pc unwind cache isn't valid.  */
  if (frame->next->pc_unwind_cache_p)
    frame->next->pc_unwind_cache = pc;
  /* Since the PC is unwound before the frame ID, only need to update
     the frame ID's PC when it has been unwound.  */
  if (frame->next->id_unwind_cache_p)
    frame->next->id_unwind_cache.pc = pc;
}

d1141 14
@


1.56.2.4
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* d10v-tdep.c: Include "d10v-tdep.h".  Update to use D10V_
	prefixed enums.
	(do_d10v_pop_frame): Delete.  Use version in d10v-frame.c.

	* frame.c (frame_read_unsigned_register): Do not use
	get_next_frame.
	(frame_read_signed_register): Do not use get_next_frame.
	(get_frame_base): Use frame_id_unwind.

	* d10v-tdep.h: New file.
	* d10v-frame.h: New file.
	* d10v-frame.c: New file.

	* frame.c (frame_id_unwind): Update.
	(create_sentinel_frame): Update.
	(legacy_get_prev_frame): Use frame_unwind_find_by_pc.
	(get_prev_frame): Ditto.

	* frame.h (struct frame_info): Replace pc_unwind, id_unwind and
	register_unwind with unwind structure.

	* frame.c (set_unwind_by_pc): Delete function.
	(create_new_frame): Use frame_unwind_find_by_pc;

	* Makefile.in (frame_h): Add $(frame_unwind_h).
	* frame.h: Include "frame-unwind.h".
	(frame_register_unwind_ftype): Delete.
	(frame_id_unwind_ftype): Delete.
	(frame_pc_unwind_ftype): Delete.

	* Makefile.in (dummy-frame.o): Update dependencies.
	(legacy-frame.o): Update dependencies.

	* dummy-frame.c: Include "frame-unwind.h".
	(dummy_frame_unwind): New static variable.
	(dummy_frame_p): New function.
	* legacy-frame.c: Include "frame-unwind.h".
	(legacy_frame_unwind): New static variable.
	(legacy_frame_p): New function.
	* legacy-frame.h (legacy_frame_p): Declare.
	* dummy-frame.h (dummy_frame_p): Declare.

	* Makefile.in (frame_unwind_h): Define.
	* frame-unwind.h: New file.
	* frame-unwind.c: New file.
@
text
@d65 1
a65 1
      frame->unwind->id (frame, &frame->unwind_cache, &frame->id_unwind_cache);
d174 2
a175 2
  frame->unwind->reg (frame, &frame->unwind_cache, regnum,
		      optimizedp, lvalp, addrp, realnump, bufferp);
d274 1
a274 1
  frame_unwind_unsigned_register (frame->next, regnum, val);
d283 1
a283 1
  frame_unwind_signed_register (frame->next, regnum, val);
d412 3
a414 1
  frame->unwind = sentinel_frame_unwind_p (0/* dummy value*/);
d557 36
d636 2
a637 1
  fi->unwind = frame_unwind_find_by_pc (current_gdbarch, fi->pc);
d860 2
a861 2
  prev->unwind = frame_unwind_find_by_pc (current_gdbarch,
					  get_frame_pc (prev));
d1010 2
a1011 2
  prev_frame->unwind = frame_unwind_find_by_pc (current_gdbarch,
						prev_frame->pc);
d1065 1
a1065 1
      frame->pc_unwind_cache = frame->unwind->pc (frame, &frame->unwind_cache);
d1117 1
a1117 2
  struct frame_id id = frame_id_unwind (fi->next);
  return id.base;
@


1.56.2.5
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (FRAME_INIT_SAVED_REGS): Change to function with
	predicate.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Only initialize the saved registers when
	FRAME_INIT_SAVED_REGS_P.
	* frame.c (frame_saved_regs_register_unwind): Assert
	FRAME_INIT_SAVED_REGS_P.
	(deprecated_generic_get_saved_register): Ditto.
@
text
@a301 2
  gdb_assert (FRAME_INIT_SAVED_REGS_P ());

@


1.56.2.6
log
@2003-01-19  Andrew Cagney  <ac131313@@redhat.com>

	* d10v-frame.c: Use D10V_RET1_REGNUM.
	(saved_regs_unwinder): Don't use get_frame_saved_regs.
	* frame.c (get_prev_frame): Always initialize frame.frame.
	(get_frame_base): Return frame.frame.
@
text
@d976 21
a996 11
  /* FIXME: cagney/2003-01-13: A dummy frame doesn't need to unwind
     the frame ID because the frame ID comes from the previous frame.
     The other frames do though.  True?  */
  {
    /* FIXME: cagney/2002-12-18: Instead of this hack, should just
       save the frame ID directly.  */
    struct frame_id id = frame_id_unwind (next_frame);
    if (!frame_id_p (id))
      return NULL;
    prev_frame->frame = id.base;
  }
a1079 5
#if 1
  /* FIXME: cagney/2003-01-13: Should be using the frame base obtained
     by unwinding the previous frame.  */
  return fi->frame;
#else
a1081 1
#endif
@


1.56.2.7
log
@Merge branch with mainline:
POP_FRAME_P;
frame-unwind.h.
@
text
@d39 1
a39 7
#include "frame-unwind.h"
#include "command.h"
#include "gdbcmd.h"

/* Flag to indicate whether backtraces should stop at main.  */

static int backtrace_below_main;
d60 23
a150 34
CORE_ADDR
frame_pc_unwind (struct frame_info *frame)
{
  if (!frame->pc_unwind_cache_p)
    {
      frame->pc_unwind_cache = frame->unwind->pc (frame, &frame->unwind_cache);
      frame->pc_unwind_cache_p = 1;
    }
  return frame->pc_unwind_cache;
}

struct frame_id
frame_id_unwind (struct frame_info *frame)
{
  if (!frame->id_unwind_cache_p)
    {
      frame->unwind->id (frame, &frame->unwind_cache, &frame->id_unwind_cache);
      frame->id_unwind_cache_p = 1;
    }
  return frame->id_unwind_cache;
}

void
frame_pop (struct frame_info *frame)
{
  /* FIXME: cagney/2003-01-18: There is probably a chicken-egg problem
     with passing in current_regcache.  The pop function needs to be
     written carefully so as to not overwrite registers whose [old]
     values are needed to restore other registers.  Instead, this code
     should pass in a scratch cache and, as a second step, restore the
     registers using that.  */
  frame->unwind->pop (frame, &frame->unwind_cache, current_regcache);
  flush_cached_frames ();
}
d647 2
a648 2
/* Create the previous frame using the deprecated methods
   INIT_EXTRA_INFO, INIT_FRAME_PC and INIT_FRAME_PC_FIRST.  */
d657 1
a657 2
  /* This code only works on normal frames.  A sentinel frame, where
     the level is -1, should never reach this code.  */
d669 1
a669 1
  if (next_frame->level == 0)
d912 1
a912 1
      && !backtrace_below_main
d914 1
a914 1
    /* Don't unwind past main(), bug always unwind the sentinel frame.
d917 2
a918 2
       allow unwinds past main(), that just happens.  */
    return NULL;
a935 4
  /* If any of the old frame initialization methods are around, use
     the legacy get_prev_frame method.  Just don't try to unwind a
     sentinel frame using that method - it doesn't work.  All sentinal
     frames use the new unwind code.  */
d937 1
a937 2
       || DEPRECATED_INIT_FRAME_PC_FIRST_P ()
       || INIT_EXTRA_FRAME_INFO_P ())
d939 1
d942 4
a945 10
  /* Allocate the new frame but do not wire it in to the frame chain.
     Some (bad) code in INIT_FRAME_EXTRA_INFO tries to look along
     frame->next to pull some fancy tricks (of course such code is, by
     definition, recursive).  Try to prevent it.

     There is no reason to worry about memory leaks, should the
     remainder of the function fail.  The allocated memory will be
     quickly reclaimed when the frame cache is flushed, and the `we've
     been here before' check above will stop repeated memory
     allocation calls.  */
d992 6
a997 7
  /* FIXME: cagney/2002-01-19: This call will go away.  Instead of
     initializing extra info, all frames will use the frame_cache
     (passed to the unwind functions) to store additional frame info.
     Unfortunatly legacy targets can't use legacy_get_prev_frame() to
     unwind the sentinel frame and, consequently, are forced to take
     this code path and rely on the below call to INIT_EXTR_FRAME_INFO
     to initialize the inner-most frame.  */
d999 3
a1001 4
    {
      gdb_assert (prev_frame->level == 0);
      INIT_EXTRA_FRAME_INFO (0, prev_frame);
    }
d1013 29
a1151 25
deprecated_update_frame_pc_hack (struct frame_info *frame, CORE_ADDR pc)
{
  /* See comment in "frame.h".  */
  frame->pc = pc;
  gdb_assert (frame->next != NULL);
  /* Got a bucket?  Legacy code that handles dummy frames directly
     doesn't always use the unwind function to determine the dummy
     frame's PC.  Consequently, it is possible for this function to be
     called when the next frame's pc unwind cache isn't valid.  */
  if (frame->next->pc_unwind_cache_p)
    frame->next->pc_unwind_cache = pc;
  /* Since the PC is unwound before the frame ID, only need to update
     the frame ID's PC when it has been unwound.  */
  if (frame->next->id_unwind_cache_p)
    frame->next->id_unwind_cache.pc = pc;
}

void
deprecated_update_frame_base_hack (struct frame_info *frame, CORE_ADDR base)
{
  /* See comment in "frame.h".  */
  frame->frame = base;
}

void
a1222 17

  /* FIXME: cagney/2003-01-19: This command needs a rename.  Suggest
     `set backtrace {past,beyond,...}-main'.  Also suggest adding `set
     backtrace ...-start' to control backtraces past start.  The
     problem with `below' is that it stops the `up' command.  */

  add_setshow_boolean_cmd ("backtrace-below-main", class_obscure,
                          &backtrace_below_main, "\
Set whether backtraces should continue past \"main\".\n\
Normally the caller of \"main\" is not of interest, so GDB will terminate\n\
the backtrace at \"main\".  Set this variable if you need to see the rest\n\
of the stack trace.", "\
Show whether backtraces should continue past \"main\".\n\
Normally the caller of \"main\" is not of interest, so GDB will terminate\n\
the backtrace at \"main\".  Set this variable if you need to see the rest\n\
of the stack trace.",
			   NULL, NULL, &setlist, &showlist);
@


1.56.2.8
log
@merge with mainline
@
text
@d290 1
a290 1
  gdb_assert (frame != NULL && frame->next != NULL);
d298 2
a299 2
  /* See note above in frame_read_unsigned_register().  */
  gdb_assert (frame != NULL && frame->next != NULL);
d332 1
a332 1
			 &realnumx, raw_buffer);
d422 1
a422 1
/* Create a sentinel frame.  */
a429 3
  /* Explicitly initialize the sentinel frame's cache.  Provide it
     with the underlying regcache.  In the future additional
     information, such as the frame's thread will be added.  */
d431 1
a431 2
  /* For the moment there is only one sentinel frame implementation.  */
  frame->unwind = sentinel_frame_unwind;
d433 2
a434 1
     (the unwound PC is the same as the pc), so make it so.  */
d437 1
a437 1
     ensures that the frame's PC points at something valid.  */
d439 1
a439 1
     frame's PC may require information such as the frame's thread's
d477 1
a477 4
/* Return the innermost (currently executing) stack frame.  This is
   split into two functions.  The function unwind_to_current_frame()
   is wrapped in catch exceptions so that, even when the unwind of the
   sentinel frame fails, the function still returns a stack frame.  */
d604 1
d623 1
a623 2
   frame).  Be careful to not fall off the bottom of the frame chain
   and onto the sentinel frame.  */
d628 2
d814 1
a814 5
#if 1
    prev->pc = DEPRECATED_INIT_FRAME_PC_FIRST (fromleaf, prev);
#else
  deprecated_update_frame_pc_hack (prev, DEPRECATED_INIT_FRAME_PC_FIRST (fromleaf, prev));
#endif
d823 1
a823 5
#if 1
    prev->pc = DEPRECATED_INIT_FRAME_PC (fromleaf, prev);
#else
  deprecated_update_frame_pc_hack (prev, DEPRECATED_INIT_FRAME_PC (fromleaf, prev));
#endif
d829 2
a830 2
  if (prev->frame == next_frame->frame
      && prev->pc == next_frame->pc)
d841 2
a842 1
  prev->unwind = frame_unwind_find_by_pc (current_gdbarch, prev->pc);
d854 2
a855 2
	  ? DEPRECATED_PC_IN_CALL_DUMMY (prev->pc, 0, 0)
	  : pc_in_dummy_frame (prev->pc)))
d866 2
a867 2
      find_pc_partial_function (prev->pc, &name, NULL, NULL);
      if (PC_IN_SIGTRAMP (prev->pc, name))
d1039 1
d1071 3
d1075 4
d1156 1
a1157 2
  frame->pc = pc;
#if 0
a1167 1
#endif
d1256 1
a1256 1
			   &backtrace_below_main, "\
@


1.55
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_get_frame_context): New function.
	(deprecated_set_frame_context): New function.
	* frame.h (deprecated_get_frame_context): Declare.
	(deprecated_set_frame_context): Declare.
	* dwarf2cfi.c (UNWIND_CONTEXT): Use deprecated_get_frame_context.
	(cfi_init_extra_frame_info): Use deprecated_set_frame_context.
@
text
@d459 1
a459 1
frame_obstack_alloc (unsigned long size)
d461 3
a463 1
  return obstack_alloc (&frame_cache_obstack, size);
d470 1
a470 2
    frame_obstack_alloc (SIZEOF_FRAME_SAVED_REGS);
  memset (fi->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);
d609 1
a609 2
		  regs = frame_obstack_alloc (sizeof_cache);
		  memset (regs, 0, sizeof_cache);
d615 1
a615 1
		    = frame_obstack_alloc (REGISTER_RAW_SIZE (regnum));
d850 1
a850 6
  fi = (struct frame_info *)
    obstack_alloc (&frame_cache_obstack,
		   sizeof (struct frame_info));

  /* Zero all fields by default.  */
  memset (fi, 0, sizeof (struct frame_info));
d1016 1
a1016 4
  prev = (struct frame_info *)
    obstack_alloc (&frame_cache_obstack,
		   sizeof (struct frame_info));
  memset (prev, 0, sizeof (struct frame_info));
d1245 1
a1245 1
	frame_obstack_alloc (SIZEOF_FRAME_SAVED_REGS);
d1270 1
a1270 2
  fi->extra_info = frame_obstack_alloc (size);
  memset (fi->extra_info, 0, size);
@


1.54
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_set_frame_next_hack): New function.
	(deprecated_set_frame_prev_hack): New function.
	* frame.h (deprecated_set_frame_next_hack): Declare.
	(deprecated_set_frame_prev_hack): Declare.
	* mcore-tdep.c (analyze_dummy_frame): Use
	deprecated_set_frame_next_hack and deprecated_set_frame_prev_hack.
	* mn10300-tdep.c (analyze_dummy_frame): Ditto.
@
text
@d1325 13
@


1.53
log
@zap #define FRAME_C.
@
text
@d1311 14
@


1.52
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* arm-tdep.c (arm_init_extra_frame_info): Use
	deprecated_update_frame_base_hack.
	* xstormy16-tdep.c (xstormy16_scan_prologue): Ditto.
	* mn10300-tdep.c (analyze_dummy_frame): Ditto.
	(fix_frame_pointer): Ditto.
	(mn10300_analyze_prologue): Ditto.
@
text
@a0 1
#define FRAME_C
@


1.51
log
@2003-01-06  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (deprecated_frame_xmalloc_with_cleanup): Declare.
	* frame.c (deprecated_frame_xmalloc_with_cleanup): New function.
	* arm-tdep.c (arm_frame_chain): Allocate caller_fi using
	deprecated_frame_xmalloc_with_cleanup.
	* m32r-tdep.c (m32r_virtual_frame_pointer): Allocate `fi' using
	deprecated_frame_xmalloc.
	* mcore-tdep.c (analyze_dummy_frame): Ditto for dummy.
	* mn10200-tdep.c (mn10200_frame_chain): Ditto for dummy_frame.
@
text
@d1 1
@


1.50
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@d1319 18
@


1.49
log
@2003-01-04  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (deprecated_frame_xmalloc): New function.
	(deprecated_set_frame_saved_regs_hack): New function.
	(deprecated_set_frame_extra_info_hack): New function.
	* frame.h (deprecated_frame_xmalloc): Declare.
	(deprecated_set_frame_saved_regs_hack): Declare.
	(deprecated_set_frame_extra_info_hack): Declare.
@
text
@d4 1
a4 1
   2001, 2002 Free Software Foundation, Inc.
d696 1
a696 9
      /* FIXME: cagney/2002-06-08: There should be two tests here.
         The first would check for a valid frame chain based on a user
         selectable policy.  The default being ``stop at main'' (as
         implemented by generic_func_frame_chain_valid()).  Other
         policies would be available - stop at NULL, ....  The second
         test, if provided by the target architecture, would check for
         more exotic cases - most target architectures wouldn't bother
         with this second case.  */
      if (!FRAME_CHAIN_VALID (id.base, next_frame))
d1014 1
a1014 9
      /* FIXME: cagney/2002-06-08: There should be two tests here.
         The first would check for a valid frame chain based on a user
         selectable policy.  The default being ``stop at main'' (as
         implemented by generic_func_frame_chain_valid()).  Other
         policies would be available - stop at NULL, ....  The second
         test, if provided by the target architecture, would check for
         more exotic cases - most target architectures wouldn't bother
         with this second case.  */
      if (!FRAME_CHAIN_VALID (address, next_frame))
@


1.48
log
@2002-12-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (deprecated_update_current_frame_pc_hack): Replace
	deprecated_update_current_frame_pc_hack.
	(deprecated_update_frame_base_hack): New function.
	* frame.h (deprecated_update_frame_pc_hack): Replace
	(deprecated_update_frame_base_hack): Declare.
	* infrun.c (normal_stop): Update.
@
text
@d1314 23
@


1.47
log
@2002-12-13  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (get_frame_saved_regs): Declare.
	(frame_saved_regs_zalloc): Change return type to CORE_ADDR
	pointer.
	* frame.c (get_frame_saved_regs): New function.
	(frame_saved_regs_zalloc): Return the allocated saved_regs.
@
text
@d1300 1
a1300 1
deprecated_update_current_frame_pc_hack (CORE_ADDR pc)
d1302 9
a1310 6
  /* FIXME: cagney/2002-12-06: Has the PC in the current frame
     changed?  "infrun.c", Thanks to DECR_PC_AFTER_BREAK, can change
     the PC after the initial frame create.  This puts things back in
     sync.  */
  if (current_frame != NULL)
    current_frame->pc = pc;
@


1.46
log
@2002-12-13  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (deprecated_update_current_frame_pc_hack): New
	function.
	* frame.h (deprecated_update_current_frame_pc_hack): Declare.
	* infrun.c (normal_stop): Use said function instead of directly
	modifying the frame's PC.
@
text
@d464 1
a464 1
void
d470 1
d473 5
@


1.45
log
@2002-12-13  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (frame_id_unwind): Declare.
	(struct frame_info): Add fields id_unwind, id_unwind_cache_p and
	id_unwind_cache.
	(frame_id_unwind_ftype): Declare.
	* frame.c (frame_id_unwind): New function.
	(set_unwind_by_pc): Add unwind_id parameter.  Initialized.
	(create_new_frame, get_prev_frame): Pass id_unwind to
	set_unwind_by_pc.
	(frame_saved_regs_id_unwind): New function.
	(frame_saved_regs_id_unwind): New function.
	* dummy-frame.c (dummy_frame_id_unwind): New function.
	(struct dummy_frame): Add field id.
	(generic_push_dummy_frame): Initialize `id'.
	* dummy-frame.h (dummy_frame_id_unwind): Declare.
@
text
@d1294 11
@


1.44
log
@2002-12-13  Andrew Cagney  <ac131313@@redhat.com>

	* infcmd.c (run_stack_dummy): Create a frame ID directly and then
	pass that to set_momentary_breakpoint.  Move comments to where they
	belong.
	* frame.h (set_current_frame): Delete declaration.
	* frame.c (set_current_frame): Delete function.
@
text
@d136 13
d648 62
d814 2
a815 1
		  frame_pc_unwind_ftype **unwind_pc)
d825 1
d833 1
d839 1
d891 1
a891 1
		    &fi->pc_unwind);
d1146 1
a1146 1
		    &prev->pc_unwind);
@


1.43
log
@2002-12-13  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (frame_extra_info_zalloc): New function.
	* frame.h (frame_extra_info_zalloc): Declare.
@
text
@a474 6
void
set_current_frame (struct frame_info *frame)
{
  current_frame = frame;
}

@


1.42
log
@2002-12-11  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (get_frame_extra_info): New function.
	* frame.h (get_frame_extra_info): Declare.
@
text
@d1212 8
@


1.41
log
@2002-12-11  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_get_frame_saved_regs): Rename
	get_frame_saved_regs.
	* frame.h (deprecated_get_frame_saved_regs): Update declaration.
	* sparc-tdep.c: Update.
	* hppa-tdep.c: Update.
	* h8500-tdep.c: Update.
@
text
@d1206 6
@


1.40
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@d1184 2
a1185 2
get_frame_saved_regs (struct frame_info *frame,
		      struct frame_saved_regs *saved_regs_addr)
@


1.39
log
@2002-12-08  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (INIT_FRAME_PC_FIRST, INIT_FRAME_PC_DEFAULT): Convert
	to pure functions.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Explictly assign prev's pc with value
	returned by INIT_FRAME_PC_FIRST and INIT_EXTRA_FRAME_INFO.

	* arch-utils.h (init_frame_pc_default, init_frame_pc_noop): Change
	declaration to a function returning a CORE_ADDR.
	* x86-64-tdep.h (x86_64_init_frame_pc): Ditto.
	* arch-utils.c (init_frame_pc_noop): Return the PC value.
	(init_frame_pc_default): Ditto.
	* x86-64-linux-tdep.c (x86_64_init_frame_pc): Ditto.
	* s390-tdep.c (s390_init_frame_pc_first): Ditto.
	* mips-tdep.c (mips_init_frame_pc_first): Ditto.
	* dwarf2cfi.h (cfi_init_frame_pc): Ditto.
	* dwarf2cfi.c (cfi_init_frame_pc): Ditto.
	* alpha-tdep.c (alpha_init_frame_pc_first): Ditto.

	* i386-interix-tdep.c (i386_interix_init_abi): Set init_frame_pc
	to init_frame_pc_noop.
	(i386_interix_init_frame_pc): Delete function.
	* z8k-tdep.c (init_frame_pc): Delete function.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC): Define as init_frame_pc_noop.
	(INIT_FRAME_PC_FIRST): Ditto.
	* config/mn10200/tm-mn10200.h (INIT_FRAME_PC): Ditto.
	(INIT_FRAME_PC_FIRST): Ditto.
	* config/sparc/tm-sparc.h (INIT_FRAME_PC): Ditto.
	* config/rs6000/tm-rs6000.h (INIT_FRAME_PC): Redefine as
	init_frame_pc_noop.
	(INIT_FRAME_PC_FIRST): Convert to an expression.
	* config/sparc/tm-sparc.h (INIT_FRAME_PC_FIRST): Ditto.
@
text
@d975 3
a977 3
     whether any targets *need* INIT_FRAME_PC to happen after
     INIT_EXTRA_FRAME_INFO and come up with a simple way to express
     what goes on here.
d981 1
a981 1
     INIT_FRAME_PC is only called from here, always after
d987 1
a987 1
     INIT_FRAME_PC.  Phoo.
d993 1
a993 1
     Assuming that some machines need INIT_FRAME_PC after
d1005 3
a1007 3
     INIT_FRAME_PC.  This should also return a flag saying whether to
     keep the new frame, or whether to discard it, because on some
     machines (e.g.  mips) it is really awkward to have
d1013 3
a1015 3
     what the default INIT_FRAME_PC does.  Some machines will call it
     from INIT_PREV_FRAME (either at the beginning, the end, or in the
     middle).  Some machines won't use it.
d1053 2
a1054 1
  prev->pc = (INIT_FRAME_PC (fromleaf, prev));
@


1.38
log
@2002-12-06  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC_FIRST): Rename
	INIT_FRAME_PC_FIRST.  Change to a function with predicate.  Do not
	provide a default value.
	* gdbarch.h, gdbarch.c: Regenerate.
	* frame.c (get_prev_frame): Update.  Check
	DEPRECATED_INIT_FRAME_PC_FIRST_P.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d1045 1
a1045 1
    DEPRECATED_INIT_FRAME_PC_FIRST (fromleaf, prev);
d1053 1
a1053 1
  INIT_FRAME_PC (fromleaf, prev);
@


1.37
log
@2002-12-03  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (get_frame_id): Convert to a function.
	(null_frame_id, frame_id_p): Declare.
	(frame_id_eq, frame_id_inner): Declare.
	(frame_id_build): New function.
	* frame.c (get_frame_id): Update.  Use null_frame_id.
	(frame_find_by_id): Rewrite using frame_id_p, frame_id_eq and
	frame_id_inner.
	(null_frame_id, frame_id_p): Define.
	(frame_id_eq, frame_id_inner): Define.
	(frame_id_build): New function.
	* varobj.c (varobj_create): Update.
	(varobj_update): Update.
	* valops.c (value_assign): Update.
	(new_root_variable): Update.
	* infrun.c (save_inferior_status): Update.
	* breakpoint.c (watch_command_1): Update.
@
text
@d989 3
a991 2
     We shouldn't need INIT_FRAME_PC_FIRST to add more complication to
     an already overcomplicated part of GDB.  gnu@@cygnus.com, 15Sep92.
d1044 2
a1045 1
  INIT_FRAME_PC_FIRST (fromleaf, prev);
@


1.36
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d38 1
a38 1
/* Return a frame uniq ID that can be used to, later re-find the
d41 2
a42 2
void
get_frame_id (struct frame_info *fi, struct frame_id *id)
d46 1
a46 2
      id->base = 0;
      id->pc = 0;
d50 4
a53 2
      id->base = fi->frame;
      id->pc = fi->pc;
d57 39
d103 1
a103 1
  if (id.base == 0 && id.pc == 0)
d110 6
a115 9
      struct frame_id this;
      get_frame_id (frame, &this);
      if (INNER_THAN (this.base, id.base))
	/* ``inner/current < frame < id.base''.  Keep looking along
           the frame chain.  */
	continue;
      if (INNER_THAN (id.base, this.base))
	/* ``inner/current < id.base < frame''.  Oops, gone past it.
           Just give up.  */
d117 4
a120 6
      /* FIXME: cagney/2002-04-21: This isn't sufficient.  It should
	 use id.pc / this.pc to check that the two frames belong to
	 the same function.  Otherwise we'll do things like match
	 dummy frames or mis-match frameless functions.  However,
	 until someone notices, stick with the existing behavour.  */
      return frame;
@


1.35
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d721 3
a723 5
  /* FIXME: cagney/2002-11-24: Can't yet directly call
     pc_in_dummy_frame() as some architectures don't set
     PC_IN_CALL_DUMMY() to generic_pc_in_call_dummy() (remember the
     latter is implemented by simply calling pc_in_dummy_frame).  */
  else if (PC_IN_CALL_DUMMY (pc, 0, 0))
d761 4
a764 5
  /* FIXME: cagney/2002-11-24: Can't yet directly call
     pc_in_dummy_frame() as some architectures don't set
     PC_IN_CALL_DUMMY() to generic_pc_in_call_dummy() (remember the
     latter is implemented by simply calling pc_in_dummy_frame).  */
  if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES && PC_IN_CALL_DUMMY (pc, 0, 0))
a1044 4
  /* FIXME: cagney/2002-11-24: Can't yet directly call
     pc_in_dummy_frame() as some architectures don't set
     PC_IN_CALL_DUMMY() to generic_pc_in_call_dummy() (remember the
     latter is implemented by simply calling pc_in_dummy_frame).  */
d1046 3
a1048 1
      && PC_IN_CALL_DUMMY (prev->pc, 0, 0))
@


1.34
log
@2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (pc_notcurrent): New function.
	(find_frame_sal): New function.
	* frame.h (find_frame_sal): Declare.
	(struct symtab_and_line): Add opaque declaration.
	* stack.c (print_frame_info_base): Use find_pc_line instead of
	find_frame_sal.
	(frame_info): Ditto.
	* ada-lang.c (find_printable_frame): Ditto.

Index: tui/ChangeLog
2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use find_frame_sal instead of
	find_pc_line.
@
text
@d36 1
d444 59
@


1.33
log
@2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_USE_GENERIC_DUMMY_FRAMES): Rename
	USE_GENERIC_DUMMY_FRAMES.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c, frame.c: Update.
	* config/z8k/tm-z8k.h, config/mn10200/tm-mn10200.h: Update.
	* config/m32r/tm-m32r.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, blockframe.c: Update.
	* vax-tdep.c, sparc-tdep.c, ns32k-tdep.c: Ditto.
	* m68k-tdep.c, alpha-tdep.c: Ditto.

	* arm-tdep.c: Eliminate USE_GENERIC_DUMMY_FRAMES as always 1.
	* mips-tdep.c: Ditto.

Index: doc/ChangeLog
2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Host Definition): Delete documentation on
	USE_GENERIC_DUMMY_FRAMES.
@
text
@d1024 23
@


1.32
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@d461 1
a461 1
  gdb_assert (!(USE_GENERIC_DUMMY_FRAMES
d652 1
a652 1
  if (!USE_GENERIC_DUMMY_FRAMES)
d707 1
a707 1
  if (USE_GENERIC_DUMMY_FRAMES && PC_IN_CALL_DUMMY (pc, 0, 0))
d992 2
a993 1
  if (USE_GENERIC_DUMMY_FRAMES && PC_IN_CALL_DUMMY (prev->pc, 0, 0))
d1049 1
a1049 1
  if (!USE_GENERIC_DUMMY_FRAMES
@


1.31
log
@2002-11-24  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (set_unwind_by_pc): Revert change below, use
	PC_IN_CALL_DUMMY.
	(get_prev_frame): Ditto.
@
text
@d50 1
a50 1
      id->base = FRAME_FP (fi);
d69 3
a71 1
      if (INNER_THAN (FRAME_FP (frame), id.base))
d75 1
a75 1
      if (INNER_THAN (id.base, FRAME_FP (frame)))
d80 4
a83 4
	 use id.pc to check that the two frames belong to the same
	 function.  Otherwise we'll do things like match dummy frames
	 or mis-match frameless functions.  However, until someone
	 notices, stick with the existing behavour.  */
d831 1
a831 1
    address = FRAME_FP (next_frame);
d1021 8
@


1.30
log
@2002-11-24  Andrew Cagney  <ac131313@@redhat.com>

	* dummy-frame.c (pc_in_dummy_frame): New function.
	(generic_pc_in_call_dummy): Call pc_in_dummy_frame.
	(find_dummy_frame): Update comment.
	(generic_pop_current_frame): Use get_frame_type.
	* dummy-frame.h (pc_in_dummy_frame): Declare.
	* frame.c (set_unwind_by_pc): Use pc_in_dummy_frame.
	(create_new_frame): Use pc_in_dummy_frame.
	(get_prev_frame): Use pc_in_dummy_frame.
	(frame_saved_regs_register_unwind): Use get_prev_frame.
	(deprecated_generic_get_saved_register): Use get_prev_frame.
@
text
@d659 5
a663 1
  else if (pc_in_dummy_frame (pc))
d701 5
a705 1
  if (USE_GENERIC_DUMMY_FRAMES && pc_in_dummy_frame (pc))
d986 5
a990 2
  if (USE_GENERIC_DUMMY_FRAMES
      && pc_in_dummy_frame (prev->pc))
@


1.29
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (frame_relative_level): Copy function from here ...
	* frame.c (frame_relative_level): ...to here.
@
text
@d460 1
a460 1
                && PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame)));
d591 1
a591 1
      if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d659 1
a659 1
  else if (PC_IN_CALL_DUMMY (pc, fp, fp))
d697 1
a697 1
  if (USE_GENERIC_DUMMY_FRAMES && PC_IN_CALL_DUMMY (fi->pc, 0, 0))
d979 1
a979 1
      && PC_IN_CALL_DUMMY (prev->pc, 0, 0))
@


1.28
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@d1010 12
@


1.27
log
@2002-11-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (generic_unwind_get_saved_register): Make static.
	* frame.h (generic_unwind_get_saved_register): Delete declaration.
	* avr-tdep.c (avr_gdbarch_init): Do not set get_saved_register,
	defaults to generic_unwind_get_saved_register.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* config/mn10200/tm-mn10200.h (GET_SAVED_REGISTER): Delete macro.
@
text
@d678 1
a678 1
  char *name;
d689 21
a709 2
  find_pc_partial_function (pc, &name, (CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
  fi->signal_handler_caller = PC_IN_SIGTRAMP (fi->pc, name);
a767 1
  char *name;
d866 5
d970 30
a999 4
  find_pc_partial_function (prev->pc, &name,
			    (CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
  if (PC_IN_SIGTRAMP (prev->pc, name))
    prev->signal_handler_caller = 1;
d1008 18
@


1.26
log
@2002-11-15  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (frame_pc_unwind): New function.
	(frame_saved_regs_pc_unwind): New function.
	(frame_register_unwind): Pass unwind_cache instead of
	register_unwind_cache.
	(set_unwind_by_pc): Add unwind_pc parameter, set.
	(create_new_frame): Pass frame->pc_unwind to set_unwind_by_pc.
	(get_prev_frame): Ditto.
	* frame.h (frame_pc_unwind_ftype): Declare.
	(struct frame_info): Add pc_unwind, pc_unwind_cache_p and
	pc_unwind_cache.  Rename register_unwind_cache to unwind_cache.
	(frame_pc_unwind): Declare.
	* dummy-frame.c (dummy_frame_pc_unwind): New function.
	(struct dummy_frame): Add comment mentioning that values are for
	previous frame.
	* dummy-frame.h (dummy_frame_pc_unwind): Declare.
	* blockframe.c (file_frame_chain_valid): Use frame_pc_unwind.
	(generic_file_frame_chain_valid): Ditto.
	* stack.c (frame_info): Ditto.
@
text
@d264 1
a264 1
void
@


1.25
log
@2002-11-09  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (get_prev_frame): Test prev_p to identify a previously
	unwound frame.  Initialize prev_p.
	* frame.h (struct frame_info): Add field prev_p.  Expand prev/next
	comment.
@
text
@d87 11
d138 1
a138 1
  frame->register_unwind (frame, &frame->register_unwind_cache, regnum,
d538 6
d647 2
a648 1
		  frame_register_unwind_ftype **unwind)
d651 8
a658 5
    /* Still need to set this to something.  The ``info frame'' code
       calls this function to find out where the saved registers are.
       Hopefully this is robust enough to stop any core dumps and
       return vaguely correct values..  */
    *unwind = frame_saved_regs_register_unwind;
d660 4
a663 1
    *unwind = dummy_frame_register_unwind;
d665 4
a668 1
    *unwind = frame_saved_regs_register_unwind;
d696 2
a697 1
  set_unwind_by_pc (fi->pc, fi->frame, &fi->register_unwind);
d944 2
a945 1
  set_unwind_by_pc (prev->pc, prev->frame, &prev->register_unwind);
@


1.24
log
@2002-11-09  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (get_prev_frame): Cleanups.  Eliminate redundant tests
	for a NULL NEXT_FRAME.  Simplify fromleaf initialization.  Add
	more comments.  Zap dead code.
@
text
@d745 2
a746 6
  /* If we have the prev one, return it.  */
  if (next_frame->prev)
    /* FIXME: cagney/2002-11-09: Rather than relying on ->PREV being
       non-NULL, there should be a predicate (->prev_p?).  That would
       stop this function constantly trying to chain beyond the
       outermost frame.  */
d748 1
@


1.23
log
@2002-11-08  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (set_unwind_by_pc): Use dummy_frame_register_unwind.
	* dummy-frame.c (find_dummy_frame): Rename
	generic_find_dummy_frame, make static.  Return the dummy frame
	instead of the regcache.
	(generic_find_dummy_frame): Re-implement using find_dummy_frame,
	(cached_find_dummy_frame): New function.  Use find_dummy_frame.
	(dummy_frame_register_unwind): Rename
	generic_call_dummy_register_unwind.  Use cached_find_dummy_frame.
	* dummy-frame.h (dummy_frame_register_unwind): Rename
	generic_call_dummy_register_unwind.
@
text
@d720 1
a720 1
  int fromleaf = 0;
d723 6
a728 5
  /* If the requested entry is in the cache, return it.
     Otherwise, figure out what the address should be for the entry
     we're about to add to the cache. */

  if (!next_frame)
d730 9
a738 10
#if 0
      /* This screws value_of_variable, which just wants a nice clean
         NULL return from block_innermost_frame if there are no frames.
         I don't think I've ever seen this message happen otherwise.
         And returning NULL here is a perfectly legitimate thing to do.  */
      if (!current_frame)
	{
	  error ("You haven't set up a process's stack to examine.");
	}
#endif
d740 2
d745 1
a745 1
  /* If we have the prev one, return it */
d747 4
d760 20
a779 10
     frame.  This macro will set FROMLEAF if NEXT_FRAME is a
     frameless function invocation.  */
  if (!(next_frame->next))
    {
      fromleaf = FRAMELESS_FUNCTION_INVOCATION (next_frame);
      if (fromleaf)
	address = FRAME_FP (next_frame);
    }

  if (!fromleaf)
d783 1
d785 1
d812 1
a815 2

  /* Zero all fields by default.  */
d818 2
a819 2
  if (next_frame)
    next_frame->prev = prev;
d824 68
a891 40
/* This change should not be needed, FIXME!  We should
   determine whether any targets *need* INIT_FRAME_PC to happen
   after INIT_EXTRA_FRAME_INFO and come up with a simple way to
   express what goes on here.

   INIT_EXTRA_FRAME_INFO is called from two places: create_new_frame
   (where the PC is already set up) and here (where it isn't).
   INIT_FRAME_PC is only called from here, always after
   INIT_EXTRA_FRAME_INFO.

   The catch is the MIPS, where INIT_EXTRA_FRAME_INFO requires the PC
   value (which hasn't been set yet).  Some other machines appear to
   require INIT_EXTRA_FRAME_INFO before they can do INIT_FRAME_PC.  Phoo.

   We shouldn't need INIT_FRAME_PC_FIRST to add more complication to
   an already overcomplicated part of GDB.   gnu@@cygnus.com, 15Sep92.

   Assuming that some machines need INIT_FRAME_PC after
   INIT_EXTRA_FRAME_INFO, one possible scheme:

   SETUP_INNERMOST_FRAME()
   Default version is just create_new_frame (read_fp ()),
   read_pc ()).  Machines with extra frame info would do that (or the
   local equivalent) and then set the extra fields.
   SETUP_ARBITRARY_FRAME(argc, argv)
   Only change here is that create_new_frame would no longer init extra
   frame info; SETUP_ARBITRARY_FRAME would have to do that.
   INIT_PREV_FRAME(fromleaf, prev)
   Replace INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC.  This should
   also return a flag saying whether to keep the new frame, or
   whether to discard it, because on some machines (e.g.  mips) it
   is really awkward to have FRAME_CHAIN_VALID called *before*
   INIT_EXTRA_FRAME_INFO (there is no good way to get information
   deduced in FRAME_CHAIN_VALID into the extra fields of the new frame).
   std_frame_pc(fromleaf, prev)
   This is the default setting for INIT_PREV_FRAME.  It just does what
   the default INIT_FRAME_PC does.  Some machines will call it from
   INIT_PREV_FRAME (either at the beginning, the end, or in the middle).
   Some machines won't use it.
   kingdon@@cygnus.com, 13Apr93, 31Jan94, 14Dec94.  */
d899 2
a900 2
     FRAME_SAVED_PC may use that queue to figure out its value
     (see tm-sparc.h).  We want the pc saved in the inferior frame. */
d903 6
a908 5
  /* If ->frame and ->pc are unchanged, we are in the process of getting
     ourselves into an infinite backtrace.  Some architectures check this
     in FRAME_CHAIN or thereabouts, but it seems like there is no reason
     this can't be an architecture-independent check.  */
  if (next_frame != NULL)
d910 3
a912 7
      if (prev->frame == next_frame->frame
	  && prev->pc == next_frame->pc)
	{
	  next_frame->prev = NULL;
	  obstack_free (&frame_cache_obstack, prev);
	  return NULL;
	}
@


1.22
log
@2002-11-08  Andrew Cagney  <ac131313@@redhat.com>

	* Makefile.in (frame.o): Update dependencies.
	* blockframe.c (current_frame, frame_obstack_alloc)
	(frame_saved_regs_zalloc, get_current_frame)
	(set_current_frame, create_new_frame)
	(set_unwind_by_pc, get_next_frame)
	(flush_cached_frames, reinit_frame_cache)
	(frame_saved_regs_register_unwind)
	(deprecated_generic_get_saved_register)
	(get_prev_frame, get_frame_pc, get_frame_saved_regs)
	(_initialize_blockframe): Move frame code from
	here...
	* frame.c: ...to here.  Include "gdb_obstack.h", "gdbcore.h",
	"annotate.h" and "dummy-frame.h".
	(_initialize_frame): New function.
@
text
@d639 1
a639 1
    *unwind = generic_call_dummy_register_unwind;
@


1.21
log
@2002-11-05  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (GET_SAVED_REGISTER): Change to a predicate function.
	* gdbarch.h, gdbarch.c: Regnerate.
	* frame.h (frame_register): Declare.
	* frame.c (frame_register): New function.
	(get_saved_register): Test GET_SAVED_REGISTER_P before calling
	GET_SAVED_REGISTER, otherwize call
	generic_unwind_get_saved_register.
	(frame_register_read): Use frame_register instead of
	get_saved_register.
@
text
@d32 4
d384 541
@


1.20
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d128 60
d303 7
a309 1
  GET_SAVED_REGISTER (raw_buffer, optimized, addrp, frame, regnum, lval);
d322 5
a326 3
  int optim;
  get_saved_register (myaddr, &optim, (CORE_ADDR *) NULL, frame,
		      regnum, (enum lval_type *) NULL);
d338 1
a338 1
  return !optim;
@


1.19
log
@2002-10-31  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_read_unsigned_register): New function.
	(frame_read_signed_register): New function.
	* frame.h (frame_read_unsigned_register): Declare.
	(frame_read_signed_register): Declare.
@
text
@d118 1
a118 1
	read_register_gen (regnum, bufferp);
@


1.18
log
@2002-09-25  Andrew Cagney  <cagney@@redhat.com>

	* frame.c: Include "gdb_string.h" and "builtin-regs.h".
	(frame_map_regnum_to_name): New function.
	(frame_map_name_to_regnum): New function.
	* frame.h (frame_map_name_to_regnum): Declare.
	(frame_map_regnum_to_name): Declare.
	* builtin-regs.c (builtin_reg_map_regnum_to_name): New function.
	* builtin-regs.h (builtin_reg_map_regnum_to_name): Declare.
	* parse.c: Do not include "builtin-regs.h".
	(target_map_name_to_register): Delete function.
	(write_dollar_variable): Use frame_map_name_to_regnum.
	* parser-defs.h (target_map_name_to_register): Delete declaration.
	* expprint.c: Include "frame.h".
	(print_subexp): Use frame_map_regnum_to_name.
	* eval.c (evaluate_subexp_standard): Use frame_map_regnum_to_name.
	* infcmd.c (registers_info): Use frame_map_name_to_regnum.

2002-09-25  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/pc-fp.exp, gdb.base/pc-fp.c: New test.
@
text
@d156 34
@


1.18.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d31 1
a31 107
#include "user-regs.h"
#include "gdb_obstack.h"
#include "dummy-frame.h"
#include "sentinel-frame.h"
#include "gdbcore.h"
#include "annotate.h"
#include "language.h"
#include "frame-unwind.h"
#include "frame-base.h"
#include "command.h"
#include "gdbcmd.h"

/* We keep a cache of stack frames, each of which is a "struct
   frame_info".  The innermost one gets allocated (in
   wait_for_inferior) each time the inferior stops; current_frame
   points to it.  Additional frames get allocated (in get_prev_frame)
   as needed, and are chained through the next and prev fields.  Any
   time that the frame cache becomes invalid (most notably when we
   execute something, but also if we change how we interpret the
   frames (e.g. "set heuristic-fence-post" in mips-tdep.c, or anything
   which reads new symbols)), we should call reinit_frame_cache.  */

struct frame_info
{
  /* Level of this frame.  The inner-most (youngest) frame is at level
     0.  As you move towards the outer-most (oldest) frame, the level
     increases.  This is a cached value.  It could just as easily be
     computed by counting back from the selected frame to the inner
     most frame.  */
  /* NOTE: cagney/2002-04-05: Perhaphs a level of ``-1'' should be
     reserved to indicate a bogus frame - one that has been created
     just to keep GDB happy (GDB always needs a frame).  For the
     moment leave this as speculation.  */
  int level;

  /* The frame's type.  */
  /* FIXME: cagney/2003-04-02: Should instead be returning
     ->unwind->type.  Unfortunately, legacy code is still explicitly
     setting the type using the method deprecated_set_frame_type.
     Eliminate that method and this field can be eliminated.  */
  enum frame_type type;

  /* For each register, address of where it was saved on entry to the
     frame, or zero if it was not saved on entry to this frame.  This
     includes special registers such as pc and fp saved in special
     ways in the stack frame.  The SP_REGNUM is even more special, the
     address here is the sp for the previous frame, not the address
     where the sp was saved.  */
  /* Allocated by frame_saved_regs_zalloc () which is called /
     initialized by DEPRECATED_FRAME_INIT_SAVED_REGS(). */
  CORE_ADDR *saved_regs;	/*NUM_REGS + NUM_PSEUDO_REGS*/

  /* Anything extra for this structure that may have been defined in
     the machine dependent files. */
  /* Allocated by frame_extra_info_zalloc () which is called /
     initialized by DEPRECATED_INIT_EXTRA_FRAME_INFO */
  struct frame_extra_info *extra_info;

  /* The frame's low-level unwinder and corresponding cache.  The
     low-level unwinder is responsible for unwinding register values
     for the previous frame.  The low-level unwind methods are
     selected based on the presence, or otherwize, of register unwind
     information such as CFI.  */
  void *prologue_cache;
  const struct frame_unwind *unwind;

  /* Cached copy of the previous frame's resume address.  */
  struct {
    int p;
    CORE_ADDR value;
  } prev_pc;
  
  /* Cached copy of the previous frame's function address.  */
  struct
  {
    CORE_ADDR addr;
    int p;
  } prev_func;
  
  /* This frame's ID.  */
  struct
  {
    int p;
    struct frame_id value;
  } this_id;
  
  /* The frame's high-level base methods, and corresponding cache.
     The high level base methods are selected based on the frame's
     debug info.  */
  const struct frame_base *base;
  void *base_cache;

  /* Pointers to the next (down, inner, younger) and previous (up,
     outer, older) frame_info's in the frame cache.  */
  struct frame_info *next; /* down, inner, younger */
  int prev_p;
  struct frame_info *prev; /* up, outer, older */
};

/* Flag to control debugging.  */

static int frame_debug;

/* Flag to indicate whether backtraces should stop at main et.al.  */

static int backtrace_past_main;
static unsigned int backtrace_limit = UINT_MAX;
d33 2
d37 1
a37 76
fprint_frame_id (struct ui_file *file, struct frame_id id)
{
  fprintf_unfiltered (file, "{stack=0x%s,code=0x%s,special=0x%s}",
		      paddr_nz (id.stack_addr),
		      paddr_nz (id.code_addr),
		      paddr_nz (id.special_addr));
}

static void
fprint_frame_type (struct ui_file *file, enum frame_type type)
{
  switch (type)
    {
    case UNKNOWN_FRAME:
      fprintf_unfiltered (file, "UNKNOWN_FRAME");
      return;
    case NORMAL_FRAME:
      fprintf_unfiltered (file, "NORMAL_FRAME");
      return;
    case DUMMY_FRAME:
      fprintf_unfiltered (file, "DUMMY_FRAME");
      return;
    case SIGTRAMP_FRAME:
      fprintf_unfiltered (file, "SIGTRAMP_FRAME");
      return;
    default:
      fprintf_unfiltered (file, "<unknown type>");
      return;
    };
}

static void
fprint_frame (struct ui_file *file, struct frame_info *fi)
{
  if (fi == NULL)
    {
      fprintf_unfiltered (file, "<NULL frame>");
      return;
    }
  fprintf_unfiltered (file, "{");
  fprintf_unfiltered (file, "level=%d", fi->level);
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "type=");
  fprint_frame_type (file, fi->type);
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "unwind=");
  if (fi->unwind != NULL)
    gdb_print_host_address (fi->unwind, file);
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "pc=");
  if (fi->next != NULL && fi->next->prev_pc.p)
    fprintf_unfiltered (file, "0x%s", paddr_nz (fi->next->prev_pc.value));
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "id=");
  if (fi->this_id.p)
    fprint_frame_id (file, fi->this_id.value);
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "func=");
  if (fi->next != NULL && fi->next->prev_func.p)
    fprintf_unfiltered (file, "0x%s", paddr_nz (fi->next->prev_func.addr));
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, "}");
}

/* Return a frame uniq ID that can be used to, later, re-find the
   frame.  */

struct frame_id
get_frame_id (struct frame_info *fi)
d41 2
a42 29
      return null_frame_id;
    }
  if (!fi->this_id.p)
    {
      gdb_assert (!legacy_frame_p (current_gdbarch));
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog, "{ get_frame_id (fi=%d) ",
			    fi->level);
      /* Find the unwinder.  */
      if (fi->unwind == NULL)
	{
	  fi->unwind = frame_unwind_find_by_frame (fi->next);
	  /* FIXME: cagney/2003-04-02: Rather than storing the frame's
	     type in the frame, the unwinder's type should be returned
	     directly.  Unfortunately, legacy code, called by
	     legacy_get_prev_frame, explicitly set the frames type
	     using the method deprecated_set_frame_type().  */
	  gdb_assert (fi->unwind->type != UNKNOWN_FRAME);
	  fi->type = fi->unwind->type;
	}
      /* Find THIS frame's ID.  */
      fi->unwind->this_id (fi->next, &fi->prologue_cache, &fi->this_id.value);
      fi->this_id.p = 1;
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame_id (gdb_stdlog, fi->this_id.value);
	  fprintf_unfiltered (gdb_stdlog, " }\n");
	}
a43 80
  return fi->this_id.value;
}

const struct frame_id null_frame_id; /* All zeros.  */

struct frame_id
frame_id_build_special (CORE_ADDR stack_addr, CORE_ADDR code_addr,
                        CORE_ADDR special_addr)
{
  struct frame_id id;
  id.stack_addr = stack_addr;
  id.code_addr = code_addr;
  id.special_addr = special_addr;
  return id;
}

struct frame_id
frame_id_build (CORE_ADDR stack_addr, CORE_ADDR code_addr)
{
  return frame_id_build_special (stack_addr, code_addr, 0);
}

int
frame_id_p (struct frame_id l)
{
  int p;
  /* The .code can be NULL but the .stack cannot.  */
  p = (l.stack_addr != 0);
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ frame_id_p (l=");
      fprint_frame_id (gdb_stdlog, l);
      fprintf_unfiltered (gdb_stdlog, ") -> %d }\n", p);
    }
  return p;
}

int
frame_id_eq (struct frame_id l, struct frame_id r)
{
  int eq;
  if (l.stack_addr == 0 || r.stack_addr == 0)
    /* Like a NaN, if either ID is invalid, the result is false.  */
    eq = 0;
  else if (l.stack_addr != r.stack_addr)
    /* If .stack addresses are different, the frames are different.  */
    eq = 0;
  else if (l.code_addr == 0 || r.code_addr == 0)
    /* A zero code addr is a wild card, always succeed.  */
    eq = 1;
  else if (l.code_addr != r.code_addr)
    /* If .code addresses are different, the frames are different.  */
    eq = 0;
  else if (l.special_addr == 0 || r.special_addr == 0)
    /* A zero special addr is a wild card (or unused), always succeed.  */
    eq = 1;
  else if (l.special_addr == r.special_addr)
    /* Frames are equal.  */
    eq = 1;
  else
    /* No luck.  */
    eq = 0;
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ frame_id_eq (l=");
      fprint_frame_id (gdb_stdlog, l);
      fprintf_unfiltered (gdb_stdlog, ",r=");
      fprint_frame_id (gdb_stdlog, r);
      fprintf_unfiltered (gdb_stdlog, ") -> %d }\n", eq);
    }
  return eq;
}

int
frame_id_inner (struct frame_id l, struct frame_id r)
{
  int inner;
  if (l.stack_addr == 0 || r.stack_addr == 0)
    /* Like NaN, any operation involving an invalid ID always fails.  */
    inner = 0;
a44 6
    /* Only return non-zero when strictly inner than.  Note that, per
       comment in "frame.h", there is some fuzz here.  Frameless
       functions are not strictly inner than (same .stack but
       different .code and/or .special address).  */
    inner = INNER_THAN (l.stack_addr, r.stack_addr);
  if (frame_debug)
d46 2
a47 5
      fprintf_unfiltered (gdb_stdlog, "{ frame_id_inner (l=");
      fprint_frame_id (gdb_stdlog, l);
      fprintf_unfiltered (gdb_stdlog, ",r=");
      fprint_frame_id (gdb_stdlog, r);
      fprintf_unfiltered (gdb_stdlog, ") -> %d }\n", inner);
a48 1
  return inner;
d58 1
a58 1
  if (!frame_id_p (id))
d65 7
a71 6
      struct frame_id this = get_frame_id (frame);
      if (frame_id_eq (id, this))
	/* An exact match.  */
	return frame;
      if (frame_id_inner (id, this))
	/* Gone to far.  */
d73 6
a78 4
      /* Either, we're not yet gone far enough out along the frame
         chain (inner(this,id), or we're comparing frameless functions
         (same .base, different .func, no test available).  Struggle
         on until we've definitly gone to far.  */
a82 128
CORE_ADDR
frame_pc_unwind (struct frame_info *this_frame)
{
  if (!this_frame->prev_pc.p)
    {
      CORE_ADDR pc;
      if (gdbarch_unwind_pc_p (current_gdbarch))
	{
	  /* The right way.  The `pure' way.  The one true way.  This
	     method depends solely on the register-unwind code to
	     determine the value of registers in THIS frame, and hence
	     the value of this frame's PC (resume address).  A typical
	     implementation is no more than:
	   
	     frame_unwind_register (this_frame, ISA_PC_REGNUM, buf);
	     return extract_unsigned_integer (buf, size of ISA_PC_REGNUM);

	     Note: this method is very heavily dependent on a correct
	     register-unwind implementation, it pays to fix that
	     method first; this method is frame type agnostic, since
	     it only deals with register values, it works with any
	     frame.  This is all in stark contrast to the old
	     FRAME_SAVED_PC which would try to directly handle all the
	     different ways that a PC could be unwound.  */
	  pc = gdbarch_unwind_pc (current_gdbarch, this_frame);
	}
      else if (this_frame->level < 0)
	{
	  /* FIXME: cagney/2003-03-06: Old code and and a sentinel
             frame.  Do like was always done.  Fetch the PC's value
             direct from the global registers array (via read_pc).
             This assumes that this frame belongs to the current
             global register cache.  The assumption is dangerous.  */
	  pc = read_pc ();
	}
      else if (DEPRECATED_FRAME_SAVED_PC_P ())
	{
	  /* FIXME: cagney/2003-03-06: Old code, but not a sentinel
             frame.  Do like was always done.  Note that this method,
             unlike unwind_pc(), tries to handle all the different
             frame cases directly.  It fails.  */
	  pc = DEPRECATED_FRAME_SAVED_PC (this_frame);
	}
      else
	internal_error (__FILE__, __LINE__, "No gdbarch_unwind_pc method");
      this_frame->prev_pc.value = pc;
      this_frame->prev_pc.p = 1;
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "{ frame_pc_unwind (this_frame=%d) -> 0x%s }\n",
			    this_frame->level,
			    paddr_nz (this_frame->prev_pc.value));
    }
  return this_frame->prev_pc.value;
}

CORE_ADDR
frame_func_unwind (struct frame_info *fi)
{
  if (!fi->prev_func.p)
    {
      /* Make certain that this, and not the adjacent, function is
         found.  */
      CORE_ADDR addr_in_block = frame_unwind_address_in_block (fi);
      fi->prev_func.p = 1;
      fi->prev_func.addr = get_pc_function_start (addr_in_block);
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "{ frame_func_unwind (fi=%d) -> 0x%s }\n",
			    fi->level, paddr_nz (fi->prev_func.addr));
    }
  return fi->prev_func.addr;
}

CORE_ADDR
get_frame_func (struct frame_info *fi)
{
  return frame_func_unwind (fi->next);
}

static int
do_frame_unwind_register (void *src, int regnum, void *buf)
{
  frame_unwind_register (src, regnum, buf);
  return 1;
}

void
frame_pop (struct frame_info *this_frame)
{
  struct regcache *scratch_regcache;
  struct cleanup *cleanups;

  if (DEPRECATED_POP_FRAME_P ())
    {
      /* A legacy architecture that has implemented a custom pop
	 function.  All new architectures should instead be using the
	 generic code below.  */
      DEPRECATED_POP_FRAME;
    }
  else
    {
      /* Make a copy of all the register values unwound from this
	 frame.  Save them in a scratch buffer so that there isn't a
	 race betweening trying to extract the old values from the
	 current_regcache while, at the same time writing new values
	 into that same cache.  */
      struct regcache *scratch = regcache_xmalloc (current_gdbarch);
      struct cleanup *cleanups = make_cleanup_regcache_xfree (scratch);
      regcache_save (scratch, do_frame_unwind_register, this_frame);
      /* FIXME: cagney/2003-03-16: It should be possible to tell the
         target's register cache that it is about to be hit with a
         burst register transfer and that the sequence of register
         writes should be batched.  The pair target_prepare_to_store()
         and target_store_registers() kind of suggest this
         functionality.  Unfortunately, they don't implement it.  Their
         lack of a formal definition can lead to targets writing back
         bogus values (arguably a bug in the target code mind).  */
      /* Now copy those saved registers into the current regcache.
         Here, regcache_cpy() calls regcache_restore().  */
      regcache_cpy (current_regcache, scratch);
      do_cleanups (cleanups);
    }
  /* We've made right mess of GDB's local state, just discard
     everything.  */
  flush_cached_frames ();
}

a89 7
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "{ frame_register_unwind (frame=%d,regnum=\"%s\",...) ",
			  frame->level, frame_map_regnum_to_name (frame, regnum));
    }

d98 5
a102 5
  /* NOTE: cagney/2002-11-27: A program trying to unwind a NULL frame
     is broken.  There is always a frame.  If there, for some reason,
     isn't, there is some pretty busted code as it should have
     detected the problem before calling here.  */
  gdb_assert (frame != NULL);
d104 1
a104 2
  /* Find the unwinder.  */
  if (frame->unwind == NULL)
d106 14
a119 8
      frame->unwind = frame_unwind_find_by_frame (frame->next);
      /* FIXME: cagney/2003-04-02: Rather than storing the frame's
	 type in the frame, the unwinder's type should be returned
	 directly.  Unfortunately, legacy code, called by
	 legacy_get_prev_frame, explicitly set the frames type using
	 the method deprecated_set_frame_type().  */
      gdb_assert (frame->unwind->type != UNKNOWN_FRAME);
      frame->type = frame->unwind->type;
d122 3
a124 26
  /* Ask this frame to unwind its register.  See comment in
     "frame-unwind.h" for why NEXT frame and this unwind cace are
     passed in.  */
  frame->unwind->prev_register (frame->next, &frame->prologue_cache, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "->");
      fprintf_unfiltered (gdb_stdlog, " *optimizedp=%d", (*optimizedp));
      fprintf_unfiltered (gdb_stdlog, " *lvalp=%d", (int) (*lvalp));
      fprintf_unfiltered (gdb_stdlog, " *addrp=0x%s", paddr_nz ((*addrp)));
      fprintf_unfiltered (gdb_stdlog, " *bufferp=");
      if (bufferp == NULL)
	fprintf_unfiltered (gdb_stdlog, "<NULL>");
      else
	{
	  int i;
	  const unsigned char *buf = bufferp;
	  fprintf_unfiltered (gdb_stdlog, "[");
	  for (i = 0; i < register_size (current_gdbarch, regnum); i++)
	    fprintf_unfiltered (gdb_stdlog, "%02x", buf[i]);
	  fprintf_unfiltered (gdb_stdlog, "]");
	}
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }
d128 2
a129 3
frame_register (struct frame_info *frame, int regnum,
		int *optimizedp, enum lval_type *lvalp,
		CORE_ADDR *addrp, int *realnump, void *bufferp)
d131 8
a138 40
  /* Require all but BUFFERP to be valid.  A NULL BUFFERP indicates
     that the value proper does not need to be fetched.  */
  gdb_assert (optimizedp != NULL);
  gdb_assert (lvalp != NULL);
  gdb_assert (addrp != NULL);
  gdb_assert (realnump != NULL);
  /* gdb_assert (bufferp != NULL); */

  /* Ulgh!  Old code that, for lval_register, sets ADDRP to the offset
     of the register in the register cache.  It should instead return
     the REGNUM corresponding to that register.  Translate the .  */
  if (DEPRECATED_GET_SAVED_REGISTER_P ())
    {
      DEPRECATED_GET_SAVED_REGISTER (bufferp, optimizedp, addrp, frame,
				     regnum, lvalp);
      /* Compute the REALNUM if the caller wants it.  */
      if (*lvalp == lval_register)
	{
	  int regnum;
	  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
	    {
	      if (*addrp == register_offset_hack (current_gdbarch, regnum))
		{
		  *realnump = regnum;
		  return;
		}
	    }
	  internal_error (__FILE__, __LINE__,
			  "Failed to compute the register number corresponding"
			  " to 0x%s", paddr_d (*addrp));
	}
      *realnump = -1;
      return;
    }

  /* Obtain the register value by unwinding the register from the next
     (more inner frame).  */
  gdb_assert (frame != NULL && frame->next != NULL);
  frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			 realnump, bufferp);
d142 2
a143 1
frame_unwind_register (struct frame_info *frame, int regnum, void *buf)
d149 1
d152 1
d156 6
a161 2
get_frame_register (struct frame_info *frame,
		    int regnum, void *buf)
d163 4
a166 2
  frame_unwind_register (frame->next, regnum, buf);
}
d168 2
a169 7
LONGEST
frame_unwind_register_signed (struct frame_info *frame, int regnum)
{
  char buf[MAX_REGISTER_SIZE];
  frame_unwind_register (frame, regnum, buf);
  return extract_signed_integer (buf, DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
}
d171 21
a191 5
LONGEST
get_frame_register_signed (struct frame_info *frame, int regnum)
{
  return frame_unwind_register_signed (frame->next, regnum);
}
d193 6
a198 12
ULONGEST
frame_unwind_register_unsigned (struct frame_info *frame, int regnum)
{
  char buf[MAX_REGISTER_SIZE];
  frame_unwind_register (frame, regnum, buf);
  return extract_unsigned_integer (buf, DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
}

ULONGEST
get_frame_register_unsigned (struct frame_info *frame, int regnum)
{
  return frame_unwind_register_unsigned (frame->next, regnum);
d202 6
a207 2
frame_unwind_unsigned_register (struct frame_info *frame, int regnum,
				ULONGEST *val)
d209 1
a209 33
  char buf[MAX_REGISTER_SIZE];
  frame_unwind_register (frame, regnum, buf);
  (*val) = extract_unsigned_integer (buf, DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
}

void
put_frame_register (struct frame_info *frame, int regnum, const void *buf)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int realnum;
  int optim;
  enum lval_type lval;
  CORE_ADDR addr;
  frame_register (frame, regnum, &optim, &lval, &addr, &realnum, NULL);
  if (optim)
    error ("Attempt to assign to a value that was optimized out.");
  switch (lval)
    {
    case lval_memory:
      {
	/* FIXME: write_memory doesn't yet take constant buffers.
           Arrrg!  */
	char tmp[MAX_REGISTER_SIZE];
	memcpy (tmp, buf, register_size (gdbarch, regnum));
	write_memory (addr, tmp, register_size (gdbarch, regnum));
	break;
      }
    case lval_register:
      regcache_cooked_write (current_regcache, realnum, buf);
      break;
    default:
      error ("Attempt to assign to an unmodifiable value.");
    }
d215 1
a215 2
   The number of bytes copied is DEPRECATED_REGISTER_RAW_SIZE
   (REGNUM).
d222 3
a224 5
  int optimized;
  enum lval_type lval;
  CORE_ADDR addr;
  int realnum;
  frame_register (frame, regnum, &optimized, &lval, &addr, &realnum, myaddr);
d236 1
a236 1
  return !optimized;
d245 1
a245 7
frame_map_name_to_regnum (struct frame_info *frame, const char *name, int len)
{
  return user_reg_map_name_to_regnum (get_frame_arch (frame), name, len);
}

const char *
frame_map_regnum_to_name (struct frame_info *frame, int regnum)
d247 1
a247 2
  return user_reg_map_regnum_to_name (get_frame_arch (frame), regnum);
}
d249 7
a255 1
/* Create a sentinel frame.  */
d257 3
a259 20
static struct frame_info *
create_sentinel_frame (struct regcache *regcache)
{
  struct frame_info *frame = FRAME_OBSTACK_ZALLOC (struct frame_info);
  frame->type = NORMAL_FRAME;
  frame->level = -1;
  /* Explicitly initialize the sentinel frame's cache.  Provide it
     with the underlying regcache.  In the future additional
     information, such as the frame's thread will be added.  */
  frame->prologue_cache = sentinel_frame_cache (regcache);
  /* For the moment there is only one sentinel frame implementation.  */
  frame->unwind = sentinel_frame_unwind;
  /* Link this frame back to itself.  The frame is self referential
     (the unwound PC is the same as the pc), so make it so.  */
  frame->next = frame;
  /* Make the sentinel frame's ID valid, but invalid.  That way all
     comparisons with it should fail.  */
  frame->this_id.p = 1;
  frame->this_id.value = null_frame_id;
  if (frame_debug)
d261 4
a264 3
      fprintf_unfiltered (gdb_stdlog, "{ create_sentinel_frame (...) -> ");
      fprint_frame (gdb_stdlog, frame);
      fprintf_unfiltered (gdb_stdlog, " }\n");
a265 2
  return frame;
}
d267 1
a267 16
/* Info about the innermost stack frame (contents of FP register) */

static struct frame_info *current_frame;

/* Cache for frame addresses already read by gdb.  Valid only while
   inferior is stopped.  Control variables for the frame cache should
   be local to this module.  */

static struct obstack frame_cache_obstack;

void *
frame_obstack_zalloc (unsigned long size)
{
  void *data = obstack_alloc (&frame_cache_obstack, size);
  memset (data, 0, size);
  return data;
d270 2
a271 2
CORE_ADDR *
frame_saved_regs_zalloc (struct frame_info *fi)
d273 1
a273 87
  fi->saved_regs = (CORE_ADDR *)
    frame_obstack_zalloc (SIZEOF_FRAME_SAVED_REGS);
  return fi->saved_regs;
}

CORE_ADDR *
deprecated_get_frame_saved_regs (struct frame_info *fi)
{
  return fi->saved_regs;
}

/* Return the innermost (currently executing) stack frame.  This is
   split into two functions.  The function unwind_to_current_frame()
   is wrapped in catch exceptions so that, even when the unwind of the
   sentinel frame fails, the function still returns a stack frame.  */

static int
unwind_to_current_frame (struct ui_out *ui_out, void *args)
{
  struct frame_info *frame = get_prev_frame (args);
  /* A sentinel frame can fail to unwind, eg, because it's PC value
     lands in somewhere like start.  */
  if (frame == NULL)
    return 1;
  current_frame = frame;
  return 0;
}

struct frame_info *
get_current_frame (void)
{
  /* First check, and report, the lack of registers.  Having GDB
     report "No stack!" or "No memory" when the target doesn't even
     have registers is very confusing.  Besides, "printcmd.exp"
     explicitly checks that ``print $pc'' with no registers prints "No
     registers".  */
  if (!target_has_registers)
    error ("No registers.");
  if (!target_has_stack)
    error ("No stack.");
  if (!target_has_memory)
    error ("No memory.");
  if (current_frame == NULL)
    {
      struct frame_info *sentinel_frame =
	create_sentinel_frame (current_regcache);
      if (catch_exceptions (uiout, unwind_to_current_frame, sentinel_frame,
			    NULL, RETURN_MASK_ERROR) != 0)
	{
	  /* Oops! Fake a current frame?  Is this useful?  It has a PC
             of zero, for instance.  */
	  current_frame = sentinel_frame;
	}
    }
  return current_frame;
}

/* The "selected" stack frame is used by default for local and arg
   access.  May be zero, for no selected frame.  */

struct frame_info *deprecated_selected_frame;

/* Return the selected frame.  Always non-null (unless there isn't an
   inferior sufficient for creating a frame) in which case an error is
   thrown.  */

struct frame_info *
get_selected_frame (void)
{
  if (deprecated_selected_frame == NULL)
    /* Hey!  Don't trust this.  It should really be re-finding the
       last selected frame of the currently selected thread.  This,
       though, is better than nothing.  */
    select_frame (get_current_frame ());
  /* There is always a frame.  */
  gdb_assert (deprecated_selected_frame != NULL);
  return deprecated_selected_frame;
}

/* This is a variant of get_selected_frame which can be called when
   the inferior does not have a frame; in that case it will return
   NULL instead of calling error ().  */

struct frame_info *
deprecated_safe_get_selected_frame (void)
{
  if (!target_has_registers || !target_has_stack || !target_has_memory)
d275 3
a277 1485
  return get_selected_frame ();
}

/* Select frame FI (or NULL - to invalidate the current frame).  */

void
select_frame (struct frame_info *fi)
{
  struct symtab *s;

  deprecated_selected_frame = fi;
  /* NOTE: cagney/2002-05-04: FI can be NULL.  This occures when the
     frame is being invalidated.  */
  if (selected_frame_level_changed_hook)
    selected_frame_level_changed_hook (frame_relative_level (fi));

  /* FIXME: kseitz/2002-08-28: It would be nice to call
     selected_frame_level_changed_event right here, but due to limitations
     in the current interfaces, we would end up flooding UIs with events
     because select_frame is used extensively internally.

     Once we have frame-parameterized frame (and frame-related) commands,
     the event notification can be moved here, since this function will only
     be called when the users selected frame is being changed. */

  /* Ensure that symbols for this frame are read in.  Also, determine the
     source language of this frame, and switch to it if desired.  */
  if (fi)
    {
      /* We retrieve the frame's symtab by using the frame PC.  However
         we cannot use the frame pc as is, because it usually points to
         the instruction following the "call", which is sometimes the
         first instruction of another function.  So we rely on
         get_frame_address_in_block() which provides us with a PC which
         is guaranteed to be inside the frame's code block.  */
      s = find_pc_symtab (get_frame_address_in_block (fi));
      if (s
	  && s->language != current_language->la_language
	  && s->language != language_unknown
	  && language_mode == language_mode_auto)
	{
	  set_language (s->language);
	}
    }
}

/* Return the register saved in the simplistic ``saved_regs'' cache.
   If the value isn't here AND a value is needed, try the next inner
   most frame.  */

static void
legacy_saved_regs_prev_register (struct frame_info *next_frame,
				 void **this_prologue_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *bufferp)
{
  /* HACK: New code is passed the next frame and this cache.
     Unfortunately, old code expects this frame.  Since this is a
     backward compatibility hack, cheat by walking one level along the
     prologue chain to the frame the old code expects.

     Do not try this at home.  Professional driver, closed course.  */
  struct frame_info *frame = next_frame->prev;
  gdb_assert (frame != NULL);

  if (deprecated_get_frame_saved_regs (frame) == NULL)
    {
      /* If nothing's initialized the saved regs, do it now.  */
      gdb_assert (DEPRECATED_FRAME_INIT_SAVED_REGS_P ());
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
      gdb_assert (deprecated_get_frame_saved_regs (frame) != NULL);
    }

  if (deprecated_get_frame_saved_regs (frame) != NULL
      && deprecated_get_frame_saved_regs (frame)[regnum] != 0)
    {
      if (regnum == SP_REGNUM)
	{
	  /* SP register treated specially.  */
	  *optimizedp = 0;
	  *lvalp = not_lval;
	  *addrp = 0;
	  *realnump = -1;
	  if (bufferp != NULL)
	    /* NOTE: cagney/2003-05-09: In-lined store_address with
               it's body - store_unsigned_integer.  */
	    store_unsigned_integer (bufferp, DEPRECATED_REGISTER_RAW_SIZE (regnum),
				    deprecated_get_frame_saved_regs (frame)[regnum]);
	}
      else
	{
	  /* Any other register is saved in memory, fetch it but cache
             a local copy of its value.  */
	  *optimizedp = 0;
	  *lvalp = lval_memory;
	  *addrp = deprecated_get_frame_saved_regs (frame)[regnum];
	  *realnump = -1;
	  if (bufferp != NULL)
	    {
#if 1
	      /* Save each register value, as it is read in, in a
                 frame based cache.  */
	      void **regs = (*this_prologue_cache);
	      if (regs == NULL)
		{
		  int sizeof_cache = ((NUM_REGS + NUM_PSEUDO_REGS)
				      * sizeof (void *));
		  regs = frame_obstack_zalloc (sizeof_cache);
		  (*this_prologue_cache) = regs;
		}
	      if (regs[regnum] == NULL)
		{
		  regs[regnum]
		    = frame_obstack_zalloc (DEPRECATED_REGISTER_RAW_SIZE (regnum));
		  read_memory (deprecated_get_frame_saved_regs (frame)[regnum], regs[regnum],
			       DEPRECATED_REGISTER_RAW_SIZE (regnum));
		}
	      memcpy (bufferp, regs[regnum], DEPRECATED_REGISTER_RAW_SIZE (regnum));
#else
	      /* Read the value in from memory.  */
	      read_memory (deprecated_get_frame_saved_regs (frame)[regnum], bufferp,
			   DEPRECATED_REGISTER_RAW_SIZE (regnum));
#endif
	    }
	}
      return;
    }

  /* No luck.  Assume this and the next frame have the same register
     value.  Pass the unwind request down the frame chain to the next
     frame.  Hopefully that frame will find the register's location.  */
  frame_register_unwind (next_frame, regnum, optimizedp, lvalp, addrp,
			 realnump, bufferp);
}

static void
legacy_saved_regs_this_id (struct frame_info *next_frame,
			   void **this_prologue_cache,
			   struct frame_id *id)
{
  /* legacy_get_prev_frame() always sets ->this_id.p, hence this is
     never needed.  */
  internal_error (__FILE__, __LINE__, "legacy_saved_regs_this_id() called");
}
	
const struct frame_unwind legacy_saved_regs_unwinder = {
  /* Not really.  It gets overridden by legacy_get_prev_frame.  */
  UNKNOWN_FRAME,
  legacy_saved_regs_this_id,
  legacy_saved_regs_prev_register
};
const struct frame_unwind *legacy_saved_regs_unwind = &legacy_saved_regs_unwinder;


/* Function: deprecated_generic_get_saved_register
   Find register number REGNUM relative to FRAME and put its (raw,
   target format) contents in *RAW_BUFFER.

   Set *OPTIMIZED if the variable was optimized out (and thus can't be
   fetched).  Note that this is never set to anything other than zero
   in this implementation.

   Set *LVAL to lval_memory, lval_register, or not_lval, depending on
   whether the value was fetched from memory, from a register, or in a
   strange and non-modifiable way (e.g. a frame pointer which was
   calculated rather than fetched).  We will use not_lval for values
   fetched from generic dummy frames.

   Set *ADDRP to the address, either in memory or as a
   DEPRECATED_REGISTER_BYTE offset into the registers array.  If the
   value is stored in a dummy frame, set *ADDRP to zero.

   The argument RAW_BUFFER must point to aligned memory.  */

void
deprecated_generic_get_saved_register (char *raw_buffer, int *optimized,
				       CORE_ADDR *addrp,
				       struct frame_info *frame, int regnum,
				       enum lval_type *lval)
{
  if (!target_has_registers)
    error ("No registers.");

  /* Normal systems don't optimize out things with register numbers.  */
  if (optimized != NULL)
    *optimized = 0;

  if (addrp)			/* default assumption: not found in memory */
    *addrp = 0;

  /* Note: since the current frame's registers could only have been
     saved by frames INTERIOR TO the current frame, we skip examining
     the current frame itself: otherwise, we would be getting the
     previous frame's registers which were saved by the current frame.  */

  if (frame != NULL)
    {
      for (frame = get_next_frame (frame);
	   frame_relative_level (frame) >= 0;
	   frame = get_next_frame (frame))
	{
	  if (get_frame_type (frame) == DUMMY_FRAME)
	    {
	      if (lval)		/* found it in a CALL_DUMMY frame */
		*lval = not_lval;
	      if (raw_buffer)
		/* FIXME: cagney/2002-06-26: This should be via the
		   gdbarch_register_read() method so that it, on the
		   fly, constructs either a raw or pseudo register
		   from the raw register cache.  */
		regcache_raw_read
		  (deprecated_find_dummy_frame_regcache (get_frame_pc (frame),
							 get_frame_base (frame)),
		   regnum, raw_buffer);
	      return;
	    }

	  DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
	  if (deprecated_get_frame_saved_regs (frame) != NULL
	      && deprecated_get_frame_saved_regs (frame)[regnum] != 0)
	    {
	      if (lval)		/* found it saved on the stack */
		*lval = lval_memory;
	      if (regnum == SP_REGNUM)
		{
		  if (raw_buffer)	/* SP register treated specially */
		    /* NOTE: cagney/2003-05-09: In-line store_address
                       with it's body - store_unsigned_integer.  */
		    store_unsigned_integer (raw_buffer,
					    DEPRECATED_REGISTER_RAW_SIZE (regnum),
					    deprecated_get_frame_saved_regs (frame)[regnum]);
		}
	      else
		{
		  if (addrp)	/* any other register */
		    *addrp = deprecated_get_frame_saved_regs (frame)[regnum];
		  if (raw_buffer)
		    read_memory (deprecated_get_frame_saved_regs (frame)[regnum], raw_buffer,
				 DEPRECATED_REGISTER_RAW_SIZE (regnum));
		}
	      return;
	    }
	}
    }

  /* If we get thru the loop to this point, it means the register was
     not saved in any frame.  Return the actual live-register value.  */

  if (lval)			/* found it in a live register */
    *lval = lval_register;
  if (addrp)
    *addrp = DEPRECATED_REGISTER_BYTE (regnum);
  if (raw_buffer)
    deprecated_read_register_gen (regnum, raw_buffer);
}

/* Determine the frame's type based on its PC.  */

static enum frame_type
frame_type_from_pc (CORE_ADDR pc)
{
  /* FIXME: cagney/2002-11-24: Can't yet directly call
     pc_in_dummy_frame() as some architectures don't set
     PC_IN_CALL_DUMMY() to generic_pc_in_call_dummy() (remember the
     latter is implemented by simply calling pc_in_dummy_frame).  */
  if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES
      && DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0))
    return DUMMY_FRAME;
  else
    {
      char *name;
      find_pc_partial_function (pc, &name, NULL, NULL);
      if (PC_IN_SIGTRAMP (pc, name))
	return SIGTRAMP_FRAME;
      else
	return NORMAL_FRAME;
    }
}

/* Create an arbitrary (i.e. address specified by user) or innermost frame.
   Always returns a non-NULL value.  */

struct frame_info *
create_new_frame (CORE_ADDR addr, CORE_ADDR pc)
{
  struct frame_info *fi;

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "{ create_new_frame (addr=0x%s, pc=0x%s) ",
			  paddr_nz (addr), paddr_nz (pc));
    }

  fi = frame_obstack_zalloc (sizeof (struct frame_info));

  fi->next = create_sentinel_frame (current_regcache);

  /* Select/initialize both the unwind function and the frame's type
     based on the PC.  */
  fi->unwind = frame_unwind_find_by_frame (fi->next);
  if (fi->unwind->type != UNKNOWN_FRAME)
    fi->type = fi->unwind->type;
  else
    fi->type = frame_type_from_pc (pc);

  fi->this_id.p = 1;
  deprecated_update_frame_base_hack (fi, addr);
  deprecated_update_frame_pc_hack (fi, pc);

  if (DEPRECATED_INIT_EXTRA_FRAME_INFO_P ())
    DEPRECATED_INIT_EXTRA_FRAME_INFO (0, fi);

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, fi);
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }

  return fi;
}

/* Return the frame that THIS_FRAME calls (NULL if THIS_FRAME is the
   innermost frame).  Be careful to not fall off the bottom of the
   frame chain and onto the sentinel frame.  */

struct frame_info *
get_next_frame (struct frame_info *this_frame)
{
  if (this_frame->level > 0)
    return this_frame->next;
  else
    return NULL;
}

struct frame_info *
deprecated_get_next_frame_hack (struct frame_info *this_frame)
{
  return this_frame->next;
}

/* Flush the entire frame cache.  */

void
flush_cached_frames (void)
{
  /* Since we can't really be sure what the first object allocated was */
  obstack_free (&frame_cache_obstack, 0);
  obstack_init (&frame_cache_obstack);

  current_frame = NULL;		/* Invalidate cache */
  select_frame (NULL);
  annotate_frames_invalid ();
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog, "{ flush_cached_frames () }\n");
}

/* Flush the frame cache, and start a new one if necessary.  */

void
reinit_frame_cache (void)
{
  flush_cached_frames ();

  /* FIXME: The inferior_ptid test is wrong if there is a corefile.  */
  if (PIDGET (inferior_ptid) != 0)
    {
      select_frame (get_current_frame ());
    }
}

/* Create the previous frame using the deprecated methods
   INIT_EXTRA_INFO, INIT_FRAME_PC and INIT_FRAME_PC_FIRST.  */

static struct frame_info *
legacy_get_prev_frame (struct frame_info *this_frame)
{
  CORE_ADDR address = 0;
  struct frame_info *prev;
  int fromleaf;

  /* Don't frame_debug print legacy_get_prev_frame() here, just
     confuses the output.  */

  /* Allocate the new frame.

     There is no reason to worry about memory leaks, should the
     remainder of the function fail.  The allocated memory will be
     quickly reclaimed when the frame cache is flushed, and the `we've
     been here before' check, in get_prev_frame will stop repeated
     memory allocation calls.  */
  prev = FRAME_OBSTACK_ZALLOC (struct frame_info);
  prev->level = this_frame->level + 1;

  /* Do not completly wire it in to the frame chain.  Some (bad) code
     in INIT_FRAME_EXTRA_INFO tries to look along frame->prev to pull
     some fancy tricks (of course such code is, by definition,
     recursive).
  
     On the other hand, methods, such as get_frame_pc() and
     get_frame_base() rely on being able to walk along the frame
     chain.  Make certain that at least they work by providing that
     link.  Of course things manipulating prev can't go back.  */
  prev->next = this_frame;

  /* NOTE: cagney/2002-11-18: Should have been correctly setting the
     frame's type here, before anything else, and not last, at the
     bottom of this function.  The various
     DEPRECATED_INIT_EXTRA_FRAME_INFO, DEPRECATED_INIT_FRAME_PC,
     DEPRECATED_INIT_FRAME_PC_FIRST and
     DEPRECATED_FRAME_INIT_SAVED_REGS methods are full of work-arounds
     that handle the frame not being correctly set from the start.
     Unfortunately those same work-arounds rely on the type defaulting
     to NORMAL_FRAME.  Ulgh!  The new frame code does not have this
     problem.  */
  prev->type = UNKNOWN_FRAME;

  /* A legacy frame's ID is always computed here.  Mark it as valid.  */
  prev->this_id.p = 1;

  /* Handle sentinel frame unwind as a special case.  */
  if (this_frame->level < 0)
    {
      /* Try to unwind the PC.  If that doesn't work, assume we've reached
	 the oldest frame and simply return.  Is there a better sentinal
	 value?  The unwound PC value is then used to initialize the new
	 previous frame's type.

	 Note that the pc-unwind is intentionally performed before the
	 frame chain.  This is ok since, for old targets, both
	 frame_pc_unwind (nee, DEPRECATED_FRAME_SAVED_PC) and
	 DEPRECATED_FRAME_CHAIN()) assume THIS_FRAME's data structures
	 have already been initialized (using
	 DEPRECATED_INIT_EXTRA_FRAME_INFO) and hence the call order
	 doesn't matter.
	 
	 By unwinding the PC first, it becomes possible to, in the case of
	 a dummy frame, avoid also unwinding the frame ID.  This is
	 because (well ignoring the PPC) a dummy frame can be located
	 using THIS_FRAME's frame ID.  */
      
      deprecated_update_frame_pc_hack (prev, frame_pc_unwind (this_frame));
      if (get_frame_pc (prev) == 0)
	{
	  /* The allocated PREV_FRAME will be reclaimed when the frame
	     obstack is next purged.  */
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // unwound legacy PC zero }\n");
	    }
	  return NULL;
	}

      /* Set the unwind functions based on that identified PC.  Ditto
         for the "type" but strongly prefer the unwinder's frame type.  */
      prev->unwind = frame_unwind_find_by_frame (prev->next);
      if (prev->unwind->type == UNKNOWN_FRAME)
	prev->type = frame_type_from_pc (get_frame_pc (prev));
      else
	prev->type = prev->unwind->type;

      /* Find the prev's frame's ID.  */
      if (prev->type == DUMMY_FRAME
	  && gdbarch_unwind_dummy_id_p (current_gdbarch))
	{
	  /* When unwinding a normal frame, the stack structure is
	     determined by analyzing the frame's function's code (be
	     it using brute force prologue analysis, or the dwarf2
	     CFI).  In the case of a dummy frame, that simply isn't
	     possible.  The The PC is either the program entry point,
	     or some random address on the stack.  Trying to use that
	     PC to apply standard frame ID unwind techniques is just
	     asking for trouble.  */
	  /* Use an architecture specific method to extract the prev's
	     dummy ID from the next frame.  Note that this method uses
	     frame_register_unwind to obtain the register values
	     needed to determine the dummy frame's ID.  */
	  prev->this_id.value = gdbarch_unwind_dummy_id (current_gdbarch,
							 this_frame);
	}
      else
	{
	  /* We're unwinding a sentinel frame, the PC of which is
	     pointing at a stack dummy.  Fake up the dummy frame's ID
	     using the same sequence as is found a traditional
	     unwinder.  Once all architectures supply the
	     unwind_dummy_id method, this code can go away.  */
	  prev->this_id.value = frame_id_build (deprecated_read_fp (),
						read_pc ());
	}

      /* Check that the unwound ID is valid.  */
      if (!frame_id_p (prev->this_id.value))
	{
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // unwound legacy ID invalid }\n");
	    }
	  return NULL;
	}

      /* Check that the new frame isn't inner to (younger, below,
	 next) the old frame.  If that happens the frame unwind is
	 going backwards.  */
      /* FIXME: cagney/2003-02-25: Ignore the sentinel frame since
	 that doesn't have a valid frame ID.  Should instead set the
	 sentinel frame's frame ID to a `sentinel'.  Leave it until
	 after the switch to storing the frame ID, instead of the
	 frame base, in the frame object.  */

      /* Link it in.  */
      this_frame->prev = prev;

      /* FIXME: cagney/2002-01-19: This call will go away.  Instead of
	 initializing extra info, all frames will use the frame_cache
	 (passed to the unwind functions) to store additional frame
	 info.  Unfortunately legacy targets can't use
	 legacy_get_prev_frame() to unwind the sentinel frame and,
	 consequently, are forced to take this code path and rely on
	 the below call to DEPRECATED_INIT_EXTRA_FRAME_INFO to
	 initialize the inner-most frame.  */
      if (DEPRECATED_INIT_EXTRA_FRAME_INFO_P ())
	{
	  DEPRECATED_INIT_EXTRA_FRAME_INFO (0, prev);
	}

      if (prev->type == NORMAL_FRAME)
	prev->this_id.value.code_addr
	  = get_pc_function_start (prev->this_id.value.code_addr);

      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, prev);
	  fprintf_unfiltered (gdb_stdlog, " } // legacy innermost frame\n");
	}
      return prev;
    }

  /* This code only works on normal frames.  A sentinel frame, where
     the level is -1, should never reach this code.  */
  gdb_assert (this_frame->level >= 0);

  /* On some machines it is possible to call a function without
     setting up a stack frame for it.  On these machines, we
     define this macro to take two args; a frameinfo pointer
     identifying a frame and a variable to set or clear if it is
     or isn't leafless.  */

  /* Still don't want to worry about this except on the innermost
     frame.  This macro will set FROMLEAF if THIS_FRAME is a frameless
     function invocation.  */
  if (this_frame->level == 0)
    /* FIXME: 2002-11-09: Frameless functions can occure anywhere in
       the frame chain, not just the inner most frame!  The generic,
       per-architecture, frame code should handle this and the below
       should simply be removed.  */
    fromleaf = FRAMELESS_FUNCTION_INVOCATION (this_frame);
  else
    fromleaf = 0;

  if (fromleaf)
    /* A frameless inner-most frame.  The `FP' (which isn't an
       architecture frame-pointer register!) of the caller is the same
       as the callee.  */
    /* FIXME: 2002-11-09: There isn't any reason to special case this
       edge condition.  Instead the per-architecture code should hande
       it locally.  */
    /* FIXME: cagney/2003-06-16: This returns the inner most stack
       address for the previous frame, that, however, is wrong.  It
       should be the inner most stack address for the previous to
       previous frame.  This is because it is the previous to previous
       frame's innermost stack address that is constant through out
       the lifetime of the previous frame (trust me :-).  */
    address = get_frame_base (this_frame);
  else
    {
      /* Two macros defined in tm.h specify the machine-dependent
         actions to be performed here.

         First, get the frame's chain-pointer.

         If that is zero, the frame is the outermost frame or a leaf
         called by the outermost frame.  This means that if start
         calls main without a frame, we'll return 0 (which is fine
         anyway).

         Nope; there's a problem.  This also returns when the current
         routine is a leaf of main.  This is unacceptable.  We move
         this to after the ffi test; I'd rather have backtraces from
         start go curfluy than have an abort called from main not show
         main.  */
      if (DEPRECATED_FRAME_CHAIN_P ())
	address = DEPRECATED_FRAME_CHAIN (this_frame);
      else
	{
	  /* Someone is part way through coverting an old architecture
             to the new frame code.  Implement FRAME_CHAIN the way the
             new frame will.  */
	  /* Find PREV frame's unwinder.  */
	  prev->unwind = frame_unwind_find_by_frame (this_frame->next);
	  /* FIXME: cagney/2003-04-02: Rather than storing the frame's
	     type in the frame, the unwinder's type should be returned
	     directly.  Unfortunately, legacy code, called by
	     legacy_get_prev_frame, explicitly set the frames type
	     using the method deprecated_set_frame_type().  */
	  prev->type = prev->unwind->type;
	  /* Find PREV frame's ID.  */
	  prev->unwind->this_id (this_frame,
				 &prev->prologue_cache,
				 &prev->this_id.value);
	  prev->this_id.p = 1;
	  address = prev->this_id.value.stack_addr;
	}

      if (!legacy_frame_chain_valid (address, this_frame))
	{
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // legacy frame chain invalid }\n");
	    }
	  return NULL;
	}
    }
  if (address == 0)
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog,
			      " // legacy frame chain NULL }\n");
	}
      return NULL;
    }

  /* Link in the already allocated prev frame.  */
  this_frame->prev = prev;
  deprecated_update_frame_base_hack (prev, address);

  /* This change should not be needed, FIXME!  We should determine
     whether any targets *need* DEPRECATED_INIT_FRAME_PC to happen
     after DEPRECATED_INIT_EXTRA_FRAME_INFO and come up with a simple
     way to express what goes on here.

     DEPRECATED_INIT_EXTRA_FRAME_INFO is called from two places:
     create_new_frame (where the PC is already set up) and here (where
     it isn't).  DEPRECATED_INIT_FRAME_PC is only called from here,
     always after DEPRECATED_INIT_EXTRA_FRAME_INFO.

     The catch is the MIPS, where DEPRECATED_INIT_EXTRA_FRAME_INFO
     requires the PC value (which hasn't been set yet).  Some other
     machines appear to require DEPRECATED_INIT_EXTRA_FRAME_INFO
     before they can do DEPRECATED_INIT_FRAME_PC.  Phoo.

     We shouldn't need DEPRECATED_INIT_FRAME_PC_FIRST to add more
     complication to an already overcomplicated part of GDB.
     gnu@@cygnus.com, 15Sep92.

     Assuming that some machines need DEPRECATED_INIT_FRAME_PC after
     DEPRECATED_INIT_EXTRA_FRAME_INFO, one possible scheme:

     SETUP_INNERMOST_FRAME(): Default version is just create_new_frame
     (deprecated_read_fp ()), read_pc ()).  Machines with extra frame
     info would do that (or the local equivalent) and then set the
     extra fields.

     SETUP_ARBITRARY_FRAME(argc, argv): Only change here is that
     create_new_frame would no longer init extra frame info;
     SETUP_ARBITRARY_FRAME would have to do that.

     INIT_PREV_FRAME(fromleaf, prev) Replace
     DEPRECATED_INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC.
     This should also return a flag saying whether to keep the new
     frame, or whether to discard it, because on some machines (e.g.
     mips) it is really awkward to have DEPRECATED_FRAME_CHAIN_VALID
     called BEFORE DEPRECATED_INIT_EXTRA_FRAME_INFO (there is no good
     way to get information deduced in DEPRECATED_FRAME_CHAIN_VALID
     into the extra fields of the new frame).  std_frame_pc(fromleaf,
     prev)

     This is the default setting for INIT_PREV_FRAME.  It just does
     what the default DEPRECATED_INIT_FRAME_PC does.  Some machines
     will call it from INIT_PREV_FRAME (either at the beginning, the
     end, or in the middle).  Some machines won't use it.

     kingdon@@cygnus.com, 13Apr93, 31Jan94, 14Dec94.  */

  /* NOTE: cagney/2002-11-09: Just ignore the above!  There is no
     reason for things to be this complicated.

     The trick is to assume that there is always a frame.  Instead of
     special casing the inner-most frame, create fake frame
     (containing the hardware registers) that is inner to the
     user-visible inner-most frame (...) and then unwind from that.
     That way architecture code can use use the standard
     frame_XX_unwind() functions and not differentiate between the
     inner most and any other case.

     Since there is always a frame to unwind from, there is always
     somewhere (THIS_FRAME) to store all the info needed to construct
     a new (previous) frame without having to first create it.  This
     means that the convolution below - needing to carefully order a
     frame's initialization - isn't needed.

     The irony here though, is that DEPRECATED_FRAME_CHAIN(), at least
     for a more up-to-date architecture, always calls
     FRAME_SAVED_PC(), and FRAME_SAVED_PC() computes the PC but
     without first needing the frame!  Instead of the convolution
     below, we could have simply called FRAME_SAVED_PC() and been done
     with it!  Note that FRAME_SAVED_PC() is being superseed by
     frame_pc_unwind() and that function does have somewhere to cache
     that PC value.  */

  if (DEPRECATED_INIT_FRAME_PC_FIRST_P ())
    deprecated_update_frame_pc_hack (prev,
				     DEPRECATED_INIT_FRAME_PC_FIRST (fromleaf,
								     prev));

  if (DEPRECATED_INIT_EXTRA_FRAME_INFO_P ())
    DEPRECATED_INIT_EXTRA_FRAME_INFO (fromleaf, prev);

  /* This entry is in the frame queue now, which is good since
     FRAME_SAVED_PC may use that queue to figure out its value (see
     tm-sparc.h).  We want the pc saved in the inferior frame. */
  if (DEPRECATED_INIT_FRAME_PC_P ())
    deprecated_update_frame_pc_hack (prev,
				     DEPRECATED_INIT_FRAME_PC (fromleaf,
							       prev));

  /* If ->frame and ->pc are unchanged, we are in the process of
     getting ourselves into an infinite backtrace.  Some architectures
     check this in DEPRECATED_FRAME_CHAIN or thereabouts, but it seems
     like there is no reason this can't be an architecture-independent
     check.  */
  if (get_frame_base (prev) == get_frame_base (this_frame)
      && get_frame_pc (prev) == get_frame_pc (this_frame))
    {
      this_frame->prev = NULL;
      obstack_free (&frame_cache_obstack, prev);
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog,
			      " // legacy this.id == prev.id }\n");
	}
      return NULL;
    }

  /* Initialize the code used to unwind the frame PREV based on the PC
     (and probably other architectural information).  The PC lets you
     check things like the debug info at that point (dwarf2cfi?) and
     use that to decide how the frame should be unwound.

     If there isn't a FRAME_CHAIN, the code above will have already
     done this.  */
  if (prev->unwind == NULL)
    prev->unwind = frame_unwind_find_by_frame (prev->next);

  /* If the unwinder provides a frame type, use it.  Otherwize
     continue on to that heuristic mess.  */
  if (prev->unwind->type != UNKNOWN_FRAME)
    {
      prev->type = prev->unwind->type;
      if (prev->type == NORMAL_FRAME)
	/* FIXME: cagney/2003-06-16: would get_frame_pc() be better?  */
	prev->this_id.value.code_addr
	  = get_pc_function_start (prev->this_id.value.code_addr);
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, prev);
	  fprintf_unfiltered (gdb_stdlog, " } // legacy with unwound type\n");
	}
      return prev;
    }

  /* NOTE: cagney/2002-11-18: The code segments, found in
     create_new_frame and get_prev_frame(), that initializes the
     frames type is subtly different.  The latter only updates ->type
     when it encounters a SIGTRAMP_FRAME or DUMMY_FRAME.  This stops
     get_prev_frame() overriding the frame's type when the INIT code
     has previously set it.  This is really somewhat bogus.  The
     initialization, as seen in create_new_frame(), should occur
     before the INIT function has been called.  */
  if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES
      && (DEPRECATED_PC_IN_CALL_DUMMY_P ()
	  ? DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (prev), 0, 0)
	  : pc_in_dummy_frame (get_frame_pc (prev))))
    prev->type = DUMMY_FRAME;
  else
    {
      /* FIXME: cagney/2002-11-10: This should be moved to before the
	 INIT code above so that the INIT code knows what the frame's
	 type is (in fact, for a [generic] dummy-frame, the type can
	 be set and then the entire initialization can be skipped.
	 Unforunatly, its the INIT code that sets the PC (Hmm, catch
	 22).  */
      char *name;
      find_pc_partial_function (get_frame_pc (prev), &name, NULL, NULL);
      if (PC_IN_SIGTRAMP (get_frame_pc (prev), name))
	prev->type = SIGTRAMP_FRAME;
      /* FIXME: cagney/2002-11-11: Leave prev->type alone.  Some
         architectures are forcing the frame's type in INIT so we
         don't want to override it here.  Remember, NORMAL_FRAME == 0,
         so it all works (just :-/).  Once this initialization is
         moved to the start of this function, all this nastness will
         go away.  */
    }

  if (prev->type == NORMAL_FRAME)
    prev->this_id.value.code_addr
      = get_pc_function_start (prev->this_id.value.code_addr);

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, prev);
      fprintf_unfiltered (gdb_stdlog, " } // legacy with confused type\n");
    }

  return prev;
}

/* Return a structure containing various interesting information
   about the frame that called THIS_FRAME.  Returns NULL
   if there is no such frame.  */

struct frame_info *
get_prev_frame (struct frame_info *this_frame)
{
  struct frame_info *prev_frame;

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ get_prev_frame (this_frame=");
      if (this_frame != NULL)
	fprintf_unfiltered (gdb_stdlog, "%d", this_frame->level);
      else
	fprintf_unfiltered (gdb_stdlog, "<NULL>");
      fprintf_unfiltered (gdb_stdlog, ") ");
    }

  /* Return the inner-most frame, when the caller passes in NULL.  */
  /* NOTE: cagney/2002-11-09: Not sure how this would happen.  The
     caller should have previously obtained a valid frame using
     get_selected_frame() and then called this code - only possibility
     I can think of is code behaving badly.

     NOTE: cagney/2003-01-10: Talk about code behaving badly.  Check
     block_innermost_frame().  It does the sequence: frame = NULL;
     while (1) { frame = get_prev_frame (frame); .... }.  Ulgh!  Why
     it couldn't be written better, I don't know.

     NOTE: cagney/2003-01-11: I suspect what is happening is
     block_innermost_frame() is, when the target has no state
     (registers, memory, ...), still calling this function.  The
     assumption being that this function will return NULL indicating
     that a frame isn't possible, rather than checking that the target
     has state and then calling get_current_frame() and
     get_prev_frame().  This is a guess mind.  */
  if (this_frame == NULL)
    {
      /* NOTE: cagney/2002-11-09: There was a code segment here that
	 would error out when CURRENT_FRAME was NULL.  The comment
	 that went with it made the claim ...

	 ``This screws value_of_variable, which just wants a nice
	 clean NULL return from block_innermost_frame if there are no
	 frames.  I don't think I've ever seen this message happen
	 otherwise.  And returning NULL here is a perfectly legitimate
	 thing to do.''

         Per the above, this code shouldn't even be called with a NULL
         THIS_FRAME.  */
      return current_frame;
    }

  /* There is always a frame.  If this assertion fails, suspect that
     something should be calling get_selected_frame() or
     get_current_frame().  */
  gdb_assert (this_frame != NULL);

  /* Make sure we pass an address within THIS_FRAME's code block to
     inside_main_func.  Otherwise, we might stop unwinding at a
     function which has a call instruction as its last instruction if
     that function immediately precedes main().  */
  if (this_frame->level >= 0
      && !backtrace_past_main
      && inside_main_func (get_frame_address_in_block (this_frame)))
    /* Don't unwind past main(), bug always unwind the sentinel frame.
       Note, this is done _before_ the frame has been marked as
       previously unwound.  That way if the user later decides to
       allow unwinds past main(), that just happens.  */
    {
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog, "-> NULL // inside main func }\n");
      return NULL;
    }

  if (this_frame->level > backtrace_limit)
    {
      error ("Backtrace limit of %d exceeded", backtrace_limit);
    }

  /* If we're already inside the entry function for the main objfile,
     then it isn't valid.  Don't apply this test to a dummy frame -
     dummy frame PC's typically land in the entry func.  Don't apply
     this test to the sentinel frame.  Sentinel frames should always
     be allowed to unwind.  */
  /* NOTE: cagney/2003-02-25: Don't enable until someone has found
     hard evidence that this is needed.  */
  /* NOTE: cagney/2003-07-07: Fixed a bug in inside_main_func - wasn't
     checking for "main" in the minimal symbols.  With that fixed
     asm-source tests now stop in "main" instead of halting the
     backtrace in wierd and wonderful ways somewhere inside the entry
     file.  Suspect that deprecated_inside_entry_file and
     inside_entry_func tests were added to work around that (now
     fixed) case.  */
  /* NOTE: cagney/2003-07-15: danielj (if I'm reading it right)
     suggested having the inside_entry_func test use the
     inside_main_func msymbol trick (along with entry_point_address I
     guess) to determine the address range of the start function.
     That should provide a far better stopper than the current
     heuristics.  */
  /* NOTE: cagney/2003-07-15: Need to add a "set backtrace
     beyond-entry-func" command so that this can be selectively
     disabled.  */
  if (0
#if 0
      && backtrace_beyond_entry_func
#endif
      && this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && inside_entry_func (get_frame_pc (this_frame)))
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, "// inside entry func }\n");
	}
      return NULL;
    }

  /* Only try to do the unwind once.  */
  if (this_frame->prev_p)
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, this_frame->prev);
	  fprintf_unfiltered (gdb_stdlog, " // cached \n");
	}
      return this_frame->prev;
    }
  this_frame->prev_p = 1;

  /* If we're inside the entry file, it isn't valid.  Don't apply this
     test to a dummy frame - dummy frame PC's typically land in the
     entry file.  Don't apply this test to the sentinel frame.
     Sentinel frames should always be allowed to unwind.  */
  /* NOTE: drow/2002-12-25: should there be a way to disable this
     check?  It assumes a single small entry file, and the way some
     debug readers (e.g.  dbxread) figure out which object is the
     entry file is somewhat hokey.  */
  /* NOTE: cagney/2003-01-10: If there is a way of disabling this test
     then it should probably be moved to before the ->prev_p test,
     above.  */
  /* NOTE: vinschen/2003-04-01: Disabled.  It turns out that the call
     to deprecated_inside_entry_file destroys a meaningful backtrace
     under some conditions.  E. g. the backtrace tests in the
     asm-source testcase are broken for some targets.  In this test
     the functions are all implemented as part of one file and the
     testcase is not necessarily linked with a start file (depending
     on the target).  What happens is, that the first frame is printed
     normaly and following frames are treated as being inside the
     enttry file then.  This way, only the #0 frame is printed in the
     backtrace output.  */
  if (0
      && this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && deprecated_inside_entry_file (get_frame_pc (this_frame)))
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // inside entry file }\n");
	}
      return NULL;
    }

  /* If any of the old frame initialization methods are around, use
     the legacy get_prev_frame method.  */
  if (legacy_frame_p (current_gdbarch))
    {
      prev_frame = legacy_get_prev_frame (this_frame);
      return prev_frame;
    }

  /* Check that this frame's ID was valid.  If it wasn't, don't try to
     unwind to the prev frame.  Be careful to not apply this test to
     the sentinel frame.  */
  if (this_frame->level >= 0 && !frame_id_p (get_frame_id (this_frame)))
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // this ID is NULL }\n");
	}
      return NULL;
    }

  /* Check that this frame's ID isn't inner to (younger, below, next)
     the next frame.  This happens when a frame unwind goes backwards.
     Since the sentinel frame doesn't really exist, don't compare the
     inner-most against that sentinel.  */
  if (this_frame->level > 0
      && frame_id_inner (get_frame_id (this_frame),
			 get_frame_id (this_frame->next)))
    error ("Previous frame inner to this frame (corrupt stack?)");

  /* Check that this and the next frame are not identical.  If they
     are, there is most likely a stack cycle.  As with the inner-than
     test above, avoid comparing the inner-most and sentinel frames.  */
  if (this_frame->level > 0
      && frame_id_eq (get_frame_id (this_frame),
		      get_frame_id (this_frame->next)))
    error ("Previous frame identical to this frame (corrupt stack?)");

  /* Allocate the new frame but do not wire it in to the frame chain.
     Some (bad) code in INIT_FRAME_EXTRA_INFO tries to look along
     frame->next to pull some fancy tricks (of course such code is, by
     definition, recursive).  Try to prevent it.

     There is no reason to worry about memory leaks, should the
     remainder of the function fail.  The allocated memory will be
     quickly reclaimed when the frame cache is flushed, and the `we've
     been here before' check above will stop repeated memory
     allocation calls.  */
  prev_frame = FRAME_OBSTACK_ZALLOC (struct frame_info);
  prev_frame->level = this_frame->level + 1;

  /* Try to unwind the PC.  If that doesn't work, assume we've reached
     the oldest frame and simply return.  Is there a better sentinal
     value?  The unwound PC value is then used to initialize the new
     previous frame's type.

     Note that the pc-unwind is intentionally performed before the
     frame chain.  This is ok since, for old targets, both
     frame_pc_unwind (nee, FRAME_SAVED_PC) and
     DEPRECATED_FRAME_CHAIN()) assume THIS_FRAME's data structures
     have already been initialized (using
     DEPRECATED_INIT_EXTRA_FRAME_INFO) and hence the call order
     doesn't matter.

     By unwinding the PC first, it becomes possible to, in the case of
     a dummy frame, avoid also unwinding the frame ID.  This is
     because (well ignoring the PPC) a dummy frame can be located
     using THIS_FRAME's frame ID.  */

  if (frame_pc_unwind (this_frame) == 0)
    {
      /* The allocated PREV_FRAME will be reclaimed when the frame
	 obstack is next purged.  */
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // unwound PC zero }\n");
	}
      return NULL;
    }

  /* Don't yet compute ->unwind (and hence ->type).  It is computed
     on-demand in get_frame_type, frame_register_unwind, and
     get_frame_id.  */

  /* Don't yet compute the frame's ID.  It is computed on-demand by
     get_frame_id().  */

  /* The unwound frame ID is validate at the start of this function,
     as part of the logic to decide if that frame should be further
     unwound, and not here while the prev frame is being created.
     Doing this makes it possible for the user to examine a frame that
     has an invalid frame ID.

     Some very old VAX code noted: [...]  For the sake of argument,
     suppose that the stack is somewhat trashed (which is one reason
     that "info frame" exists).  So, return 0 (indicating we don't
     know the address of the arglist) if we don't know what frame this
     frame calls.  */

  /* Link it in.  */
  this_frame->prev = prev_frame;
  prev_frame->next = this_frame;

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, prev_frame);
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }

  return prev_frame;
}

CORE_ADDR
get_frame_pc (struct frame_info *frame)
{
  gdb_assert (frame->next != NULL);
  return frame_pc_unwind (frame->next);
}

/* Return an address of that falls within the frame's code block.  */

CORE_ADDR
frame_unwind_address_in_block (struct frame_info *next_frame)
{
  /* A draft address.  */
  CORE_ADDR pc = frame_pc_unwind (next_frame);

  /* If THIS frame is not inner most (i.e., NEXT isn't the sentinel),
     and NEXT is `normal' (i.e., not a sigtramp, dummy, ....) THIS
     frame's PC ends up pointing at the instruction fallowing the
     "call".  Adjust that PC value so that it falls on the call
     instruction (which, hopefully, falls within THIS frame's code
     block.  So far it's proved to be a very good approximation.  See
     get_frame_type for why ->type can't be used.  */
  if (next_frame->level >= 0
      && get_frame_type (next_frame) == NORMAL_FRAME)
    --pc;
  return pc;
}

CORE_ADDR
get_frame_address_in_block (struct frame_info *this_frame)
{
  return frame_unwind_address_in_block (this_frame->next);
}

static int
pc_notcurrent (struct frame_info *frame)
{
  /* If FRAME is not the innermost frame, that normally means that
     FRAME->pc points at the return instruction (which is *after* the
     call instruction), and we want to get the line containing the
     call (because the call is where the user thinks the program is).
     However, if the next frame is either a SIGTRAMP_FRAME or a
     DUMMY_FRAME, then the next frame will contain a saved interrupt
     PC and such a PC indicates the current (rather than next)
     instruction/line, consequently, for such cases, want to get the
     line containing fi->pc.  */
  struct frame_info *next = get_next_frame (frame);
  int notcurrent = (next != NULL && get_frame_type (next) == NORMAL_FRAME);
  return notcurrent;
}

void
find_frame_sal (struct frame_info *frame, struct symtab_and_line *sal)
{
  (*sal) = find_pc_line (get_frame_pc (frame), pc_notcurrent (frame));
}

/* Per "frame.h", return the ``address'' of the frame.  Code should
   really be using get_frame_id().  */
CORE_ADDR
get_frame_base (struct frame_info *fi)
{
  return get_frame_id (fi).stack_addr;
}

/* High-level offsets into the frame.  Used by the debug info.  */

CORE_ADDR
get_frame_base_address (struct frame_info *fi)
{
  if (get_frame_type (fi) != NORMAL_FRAME)
    return 0;
  if (fi->base == NULL)
    fi->base = frame_base_find_by_frame (fi->next);
  /* Sneaky: If the low-level unwind and high-level base code share a
     common unwinder, let them share the prologue cache.  */
  if (fi->base->unwind == fi->unwind)
    return fi->base->this_base (fi->next, &fi->prologue_cache);
  return fi->base->this_base (fi->next, &fi->base_cache);
}

CORE_ADDR
get_frame_locals_address (struct frame_info *fi)
{
  void **cache;
  if (get_frame_type (fi) != NORMAL_FRAME)
    return 0;
  /* If there isn't a frame address method, find it.  */
  if (fi->base == NULL)
    fi->base = frame_base_find_by_frame (fi->next);
  /* Sneaky: If the low-level unwind and high-level base code share a
     common unwinder, let them share the prologue cache.  */
  if (fi->base->unwind == fi->unwind)
    cache = &fi->prologue_cache;
  else
    cache = &fi->base_cache;
  return fi->base->this_locals (fi->next, cache);
}

CORE_ADDR
get_frame_args_address (struct frame_info *fi)
{
  void **cache;
  if (get_frame_type (fi) != NORMAL_FRAME)
    return 0;
  /* If there isn't a frame address method, find it.  */
  if (fi->base == NULL)
    fi->base = frame_base_find_by_frame (fi->next);
  /* Sneaky: If the low-level unwind and high-level base code share a
     common unwinder, let them share the prologue cache.  */
  if (fi->base->unwind == fi->unwind)
    cache = &fi->prologue_cache;
  else
    cache = &fi->base_cache;
  return fi->base->this_args (fi->next, cache);
}

/* Level of the selected frame: 0 for innermost, 1 for its caller, ...
   or -1 for a NULL frame.  */

int
frame_relative_level (struct frame_info *fi)
{
  if (fi == NULL)
    return -1;
  else
    return fi->level;
}

enum frame_type
get_frame_type (struct frame_info *frame)
{
  /* Some targets still don't use [generic] dummy frames.  Catch them
     here.  */
  if (!DEPRECATED_USE_GENERIC_DUMMY_FRAMES
      && deprecated_frame_in_dummy (frame))
    return DUMMY_FRAME;

  /* Some legacy code, e.g, mips_init_extra_frame_info() wants
     to determine the frame's type prior to it being completely
     initialized.  Don't attempt to lazily initialize ->unwind for
     legacy code.  It will be initialized in legacy_get_prev_frame().  */
  if (frame->unwind == NULL && !legacy_frame_p (current_gdbarch))
    {
      /* Initialize the frame's unwinder because it is that which
         provides the frame's type.  */
      frame->unwind = frame_unwind_find_by_frame (frame->next);
      /* FIXME: cagney/2003-04-02: Rather than storing the frame's
	 type in the frame, the unwinder's type should be returned
	 directly.  Unfortunately, legacy code, called by
	 legacy_get_prev_frame, explicitly set the frames type using
	 the method deprecated_set_frame_type().  */
      gdb_assert (frame->unwind->type != UNKNOWN_FRAME);
      frame->type = frame->unwind->type;
    }
  if (frame->type == UNKNOWN_FRAME)
    return NORMAL_FRAME;
  else
    return frame->type;
}

void
deprecated_set_frame_type (struct frame_info *frame, enum frame_type type)
{
  /* Arrrg!  See comment in "frame.h".  */
  frame->type = type;
}

struct frame_extra_info *
get_frame_extra_info (struct frame_info *fi)
{
  return fi->extra_info;
}

struct frame_extra_info *
frame_extra_info_zalloc (struct frame_info *fi, long size)
{
  fi->extra_info = frame_obstack_zalloc (size);
  return fi->extra_info;
}

void
deprecated_update_frame_pc_hack (struct frame_info *frame, CORE_ADDR pc)
{
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog,
			"{ deprecated_update_frame_pc_hack (frame=%d,pc=0x%s) }\n",
			frame->level, paddr_nz (pc));
  /* NOTE: cagney/2003-03-11: Some architectures (e.g., Arm) are
     maintaining a locally allocated frame object.  Since such frame's
     are not in the frame chain, it isn't possible to assume that the
     frame has a next.  Sigh.  */
  if (frame->next != NULL)
    {
      /* While we're at it, update this frame's cached PC value, found
	 in the next frame.  Oh for the day when "struct frame_info"
	 is opaque and this hack on hack can just go away.  */
      frame->next->prev_pc.value = pc;
      frame->next->prev_pc.p = 1;
    }
}

void
deprecated_update_frame_base_hack (struct frame_info *frame, CORE_ADDR base)
{
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog,
			"{ deprecated_update_frame_base_hack (frame=%d,base=0x%s) }\n",
			frame->level, paddr_nz (base));
  /* See comment in "frame.h".  */
  frame->this_id.value.stack_addr = base;
}

struct frame_info *
deprecated_frame_xmalloc_with_cleanup (long sizeof_saved_regs,
				       long sizeof_extra_info)
{
  struct frame_info *frame = XMALLOC (struct frame_info);
  memset (frame, 0, sizeof (*frame));
  frame->this_id.p = 1;
  make_cleanup (xfree, frame);
  if (sizeof_saved_regs > 0)
    {
      frame->saved_regs = xcalloc (1, sizeof_saved_regs);
      make_cleanup (xfree, frame->saved_regs);
    }
  if (sizeof_extra_info > 0)
    {
      frame->extra_info = xcalloc (1, sizeof_extra_info);
      make_cleanup (xfree, frame->extra_info);
    }
  return frame;
}

/* Memory access methods.  */

void
get_frame_memory (struct frame_info *this_frame, CORE_ADDR addr, void *buf,
		  int len)
{
  read_memory (addr, buf, len);
}

LONGEST
get_frame_memory_signed (struct frame_info *this_frame, CORE_ADDR addr,
			 int len)
{
  return read_memory_integer (addr, len);
}

ULONGEST
get_frame_memory_unsigned (struct frame_info *this_frame, CORE_ADDR addr,
			   int len)
{
  return read_memory_unsigned_integer (addr, len);
}

/* Architecture method.  */

struct gdbarch *
get_frame_arch (struct frame_info *this_frame)
{
  return current_gdbarch;
}

/* Stack pointer methods.  */

CORE_ADDR
get_frame_sp (struct frame_info *this_frame)
{
  return frame_sp_unwind (this_frame->next);
}

CORE_ADDR
frame_sp_unwind (struct frame_info *next_frame)
{
  /* Normality, an architecture that provides a way of obtaining any
     frame inner-most address.  */
  if (gdbarch_unwind_sp_p (current_gdbarch))
    return gdbarch_unwind_sp (current_gdbarch, next_frame);
  /* Things are looking grim.  If it's the inner-most frame and there
     is a TARGET_READ_SP then that can be used.  */
  if (next_frame->level < 0 && TARGET_READ_SP_P ())
    return TARGET_READ_SP ();
  /* Now things are really are grim.  Hope that the value returned by
     the SP_REGNUM register is meaningful.  */
  if (SP_REGNUM >= 0)
    {
      ULONGEST sp;
      frame_unwind_unsigned_register (next_frame, SP_REGNUM, &sp);
      return sp;
    }
  internal_error (__FILE__, __LINE__, "Missing unwind SP method");
}


int
legacy_frame_p (struct gdbarch *current_gdbarch)
{
  return (DEPRECATED_INIT_FRAME_PC_P ()
	  || DEPRECATED_INIT_FRAME_PC_FIRST_P ()
	  || DEPRECATED_INIT_EXTRA_FRAME_INFO_P ()
	  || DEPRECATED_FRAME_CHAIN_P ()
	  || !gdbarch_unwind_dummy_id_p (current_gdbarch));
}

extern initialize_file_ftype _initialize_frame; /* -Wmissing-prototypes */

static struct cmd_list_element *set_backtrace_cmdlist;
static struct cmd_list_element *show_backtrace_cmdlist;

static void
set_backtrace_cmd (char *args, int from_tty)
{
  help_list (set_backtrace_cmdlist, "set backtrace ", -1, gdb_stdout);
}

static void
show_backtrace_cmd (char *args, int from_tty)
{
  cmd_show_list (show_backtrace_cmdlist, from_tty, "");
}

void
_initialize_frame (void)
{
  obstack_init (&frame_cache_obstack);

  add_prefix_cmd ("backtrace", class_maintenance, set_backtrace_cmd, "\
Set backtrace specific variables.\n\
Configure backtrace variables such as the backtrace limit",
		  &set_backtrace_cmdlist, "set backtrace ",
		  0/*allow-unknown*/, &setlist);
  add_prefix_cmd ("backtrace", class_maintenance, show_backtrace_cmd, "\
Show backtrace specific variables\n\
Show backtrace variables such as the backtrace limit",
		  &show_backtrace_cmdlist, "show backtrace ",
		  0/*allow-unknown*/, &showlist);

  add_setshow_boolean_cmd ("past-main", class_obscure,
			   &backtrace_past_main, "\
Set whether backtraces should continue past \"main\".\n\
Normally the caller of \"main\" is not of interest, so GDB will terminate\n\
the backtrace at \"main\".  Set this variable if you need to see the rest\n\
of the stack trace.", "\
Show whether backtraces should continue past \"main\".\n\
Normally the caller of \"main\" is not of interest, so GDB will terminate\n\
the backtrace at \"main\".  Set this variable if you need to see the rest\n\
of the stack trace.",
			   NULL, NULL, &set_backtrace_cmdlist,
			   &show_backtrace_cmdlist);

  add_setshow_uinteger_cmd ("limit", class_obscure,
			    &backtrace_limit, "\
Set an upper bound on the number of backtrace levels.\n\
No more than the specified number of frames can be displayed or examined.\n\
Zero is unlimited.", "\
Show the upper bound on the number of backtrace levels.",
			    NULL, NULL, &set_backtrace_cmdlist,
			    &show_backtrace_cmdlist);

  /* Debug this files internals. */
  add_show_from_set (add_set_cmd ("frame", class_maintenance, var_zinteger,
				  &frame_debug, "Set frame debugging.\n\
When non-zero, frame specific internal debugging is enabled.", &setdebuglist),
		     &showdebuglist);
@


1.18.2.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1729 1
a1729 6
   if there is no such frame.

   This function tests some target-independent conditions that should
   terminate the frame chain, such as unwinding past main().  It
   should not contain any target-dependent tests, such as checking
   whether the program-counter is zero.  */
d1945 31
@


1.18.2.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d1841 1
a1841 1
      && inside_entry_func (this_frame))
@


1.17
log
@2002-09-17  Andrew Cagney  <cagney@@redhat.com>

	* h8300-tdep.c (h8300_frame_chain):
	(h8300_frame_saved_pc):

	* blockframe.c (deprecated_read_register_dummy): Rename
	generic_read_register_dummy.
	* frame.c (frame_unwind_signed_register): New function.
	(frame_unwind_unsigned_register): New function.
	* frame.h (frame_unwind_signed_register): Declare.
	(frame_unwind_unsigned_register): Declare.
	(deprecated_read_register_dummy): Rename
	generic_read_register_dummy.

	* xstormy16-tdep.c (xstormy16_frame_saved_pc): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	* s390-tdep.c (s390_frame_saved_pc_nofix): Update.
	(s390_frame_chain): Update.
	* v850-tdep.c (v850_find_callers_reg): Update.
	(v850_frame_saved_pc): Update.
	* m32r-tdep.c (m32r_init_extra_frame_info): Update.
	(m32r_find_callers_reg): Update.
	(m32r_frame_saved_pc): Update.
	* sh-tdep.c (sh_find_callers_reg): Update.
	(sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info): Update.
	(sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* mcore-tdep.c (mcore_find_callers_reg): Update.
	(mcore_frame_saved_pc): Update.
	(mcore_init_extra_frame_info): Update.
	* i386-tdep.c (i386_frame_saved_pc): Update.
	* ia64-tdep.c (ia64_frame_saved_pc): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_init_extra_frame_info): Update.
	* d10v-tdep.c (d10v_frame_saved_pc): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_frame_chain): Update.
	(avr_init_extra_frame_info): Update.
	(avr_frame_saved_pc): Update.
	* arm-tdep.c (arm_find_callers_reg): Update.
	(arm_init_extra_frame_info): Update.
	(arm_frame_saved_pc): Update.
@
text
@d30 2
d237 41
@


1.17.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@a29 2
#include "gdb_string.h"
#include "builtin-regs.h"
a234 41
}


/* Map between a frame register number and its name.  A frame register
   space is a superset of the cooked register space --- it also
   includes builtin registers.  */

int
frame_map_name_to_regnum (const char *name, int len)
{
  int i;

  /* Search register name space. */
  for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
    if (REGISTER_NAME (i) && len == strlen (REGISTER_NAME (i))
	&& strncmp (name, REGISTER_NAME (i), len) == 0)
      {
	return i;
      }

  /* Try builtin registers.  */
  i = builtin_reg_map_name_to_regnum (name, len);
  if (i >= 0)
    {
      /* A builtin register doesn't fall into the architecture's
         register range.  */
      gdb_assert (i >= NUM_REGS + NUM_PSEUDO_REGS);
      return i;
    }

  return -1;
}

const char *
frame_map_regnum_to_name (int regnum)
{
  if (regnum < 0)
    return NULL;
  if (regnum < NUM_REGS + NUM_PSEUDO_REGS)
    return REGISTER_NAME (regnum);
  return builtin_reg_map_regnum_to_name (regnum);
@


1.17.2.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a31 4
#include "gdb_obstack.h"
#include "dummy-frame.h"
#include "gdbcore.h"
#include "annotate.h"
d118 1
a118 1
	deprecated_read_register_gen (regnum, bufferp);
a127 60
frame_register (struct frame_info *frame, int regnum,
		int *optimizedp, enum lval_type *lvalp,
		CORE_ADDR *addrp, int *realnump, void *bufferp)
{
  /* Require all but BUFFERP to be valid.  A NULL BUFFERP indicates
     that the value proper does not need to be fetched.  */
  gdb_assert (optimizedp != NULL);
  gdb_assert (lvalp != NULL);
  gdb_assert (addrp != NULL);
  gdb_assert (realnump != NULL);
  /* gdb_assert (bufferp != NULL); */

  /* Ulgh!  Old code that, for lval_register, sets ADDRP to the offset
     of the register in the register cache.  It should instead return
     the REGNUM corresponding to that register.  Translate the .  */
  if (GET_SAVED_REGISTER_P ())
    {
      GET_SAVED_REGISTER (bufferp, optimizedp, addrp, frame, regnum, lvalp);
      /* Compute the REALNUM if the caller wants it.  */
      if (*lvalp == lval_register)
	{
	  int regnum;
	  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
	    {
	      if (*addrp == register_offset_hack (current_gdbarch, regnum))
		{
		  *realnump = regnum;
		  return;
		}
	    }
	  internal_error (__FILE__, __LINE__,
			  "Failed to compute the register number corresponding"
			  " to 0x%s", paddr_d (*addrp));
	}
      *realnump = -1;
      return;
    }

  /* Reached the the bottom (youngest, inner most) of the frame chain
     (youngest, inner most) frame, go direct to the hardware register
     cache (do not pass go, do not try to cache the value, ...).  The
     unwound value would have been cached in frame->next but that
     doesn't exist.  This doesn't matter as the hardware register
     cache is stopping any unnecessary accesses to the target.  */

  /* NOTE: cagney/2002-04-14: It would be nice if, instead of a
     special case, there was always an inner frame dedicated to the
     hardware registers.  Unfortunatly, there is too much unwind code
     around that looks up/down the frame chain while making the
     assumption that each frame level is using the same unwind code.  */

  if (frame == NULL)
    frame_register_unwind (NULL, regnum, optimizedp, lvalp, addrp, realnump,
			   bufferp);
  else
    frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			   realnump, bufferp);
}

void
a155 34
frame_read_unsigned_register (struct frame_info *frame, int regnum,
			      ULONGEST *val)
{
  /* NOTE: cagney/2002-10-31: There is a bit of dogma here - there is
     always a frame.  Both this, and the equivalent
     frame_read_signed_register() function, can only be called with a
     valid frame.  If, for some reason, this function is called
     without a frame then the problem isn't here, but rather in the
     caller.  It should of first created a frame and then passed that
     in.  */
  /* NOTE: cagney/2002-10-31: As a side bar, keep in mind that the
     ``current_frame'' should not be treated as a special case.  While
     ``get_next_frame (current_frame) == NULL'' currently holds, it
     should, as far as possible, not be relied upon.  In the future,
     ``get_next_frame (current_frame)'' may instead simply return a
     normal frame object that simply always gets register values from
     the register cache.  Consequently, frame code should try to avoid
     tests like ``if get_next_frame() == NULL'' and instead just rely
     on recursive frame calls (like the below code) when manipulating
     a frame chain.  */
  gdb_assert (frame != NULL);
  frame_unwind_unsigned_register (get_next_frame (frame), regnum, val);
}

void
frame_read_signed_register (struct frame_info *frame, int regnum,
			    LONGEST *val)
{
  /* See note in frame_read_unsigned_register().  */
  gdb_assert (frame != NULL);
  frame_unwind_signed_register (get_next_frame (frame), regnum, val);
}

void
d209 1
a209 7
  if (GET_SAVED_REGISTER_P ())
    {
      GET_SAVED_REGISTER (raw_buffer, optimized, addrp, frame, regnum, lval);
      return;
    }
  generic_unwind_get_saved_register (raw_buffer, optimized, addrp, frame,
				     regnum, lval);
d222 3
a224 5
  int optimized;
  enum lval_type lval;
  CORE_ADDR addr;
  int realnum;
  frame_register (frame, regnum, &optimized, &lval, &addr, &realnum, myaddr);
d236 1
a236 1
  return !optimized;
a277 580
}

/* Info about the innermost stack frame (contents of FP register) */

static struct frame_info *current_frame;

/* Cache for frame addresses already read by gdb.  Valid only while
   inferior is stopped.  Control variables for the frame cache should
   be local to this module.  */

static struct obstack frame_cache_obstack;

void *
frame_obstack_alloc (unsigned long size)
{
  return obstack_alloc (&frame_cache_obstack, size);
}

void
frame_saved_regs_zalloc (struct frame_info *fi)
{
  fi->saved_regs = (CORE_ADDR *)
    frame_obstack_alloc (SIZEOF_FRAME_SAVED_REGS);
  memset (fi->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);
}


/* Return the innermost (currently executing) stack frame.  */

struct frame_info *
get_current_frame (void)
{
  if (current_frame == NULL)
    {
      if (target_has_stack)
	current_frame = create_new_frame (read_fp (), read_pc ());
      else
	error ("No stack.");
    }
  return current_frame;
}

void
set_current_frame (struct frame_info *frame)
{
  current_frame = frame;
}

/* Return the register saved in the simplistic ``saved_regs'' cache.
   If the value isn't here AND a value is needed, try the next inner
   most frame.  */

static void
frame_saved_regs_register_unwind (struct frame_info *frame, void **cache,
				  int regnum, int *optimizedp,
				  enum lval_type *lvalp, CORE_ADDR *addrp,
				  int *realnump, void *bufferp)
{
  /* There is always a frame at this point.  And THIS is the frame
     we're interested in.  */
  gdb_assert (frame != NULL);
  /* If we're using generic dummy frames, we'd better not be in a call
     dummy.  (generic_call_dummy_register_unwind ought to have been called
     instead.)  */
  gdb_assert (!(USE_GENERIC_DUMMY_FRAMES
                && PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame)));

  /* Load the saved_regs register cache.  */
  if (frame->saved_regs == NULL)
    FRAME_INIT_SAVED_REGS (frame);

  if (frame->saved_regs != NULL
      && frame->saved_regs[regnum] != 0)
    {
      if (regnum == SP_REGNUM)
	{
	  /* SP register treated specially.  */
	  *optimizedp = 0;
	  *lvalp = not_lval;
	  *addrp = 0;
	  *realnump = -1;
	  if (bufferp != NULL)
	    store_address (bufferp, REGISTER_RAW_SIZE (regnum),
			   frame->saved_regs[regnum]);
	}
      else
	{
	  /* Any other register is saved in memory, fetch it but cache
             a local copy of its value.  */
	  *optimizedp = 0;
	  *lvalp = lval_memory;
	  *addrp = frame->saved_regs[regnum];
	  *realnump = -1;
	  if (bufferp != NULL)
	    {
#if 1
	      /* Save each register value, as it is read in, in a
                 frame based cache.  */
	      void **regs = (*cache);
	      if (regs == NULL)
		{
		  int sizeof_cache = ((NUM_REGS + NUM_PSEUDO_REGS)
				      * sizeof (void *));
		  regs = frame_obstack_alloc (sizeof_cache);
		  memset (regs, 0, sizeof_cache);
		  (*cache) = regs;
		}
	      if (regs[regnum] == NULL)
		{
		  regs[regnum]
		    = frame_obstack_alloc (REGISTER_RAW_SIZE (regnum));
		  read_memory (frame->saved_regs[regnum], regs[regnum],
			       REGISTER_RAW_SIZE (regnum));
		}
	      memcpy (bufferp, regs[regnum], REGISTER_RAW_SIZE (regnum));
#else
	      /* Read the value in from memory.  */
	      read_memory (frame->saved_regs[regnum], bufferp,
			   REGISTER_RAW_SIZE (regnum));
#endif
	    }
	}
      return;
    }

  /* No luck, assume this and the next frame have the same register
     value.  If a value is needed, pass the request on down the chain;
     otherwise just return an indication that the value is in the same
     register as the next frame.  */
  if (bufferp == NULL)
    {
      *optimizedp = 0;
      *lvalp = lval_register;
      *addrp = 0;
      *realnump = regnum;
    }
  else
    {
      frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			     realnump, bufferp);
    }
}

/* Function: get_saved_register
   Find register number REGNUM relative to FRAME and put its (raw,
   target format) contents in *RAW_BUFFER.  

   Set *OPTIMIZED if the variable was optimized out (and thus can't be
   fetched).  Note that this is never set to anything other than zero
   in this implementation.

   Set *LVAL to lval_memory, lval_register, or not_lval, depending on
   whether the value was fetched from memory, from a register, or in a
   strange and non-modifiable way (e.g. a frame pointer which was
   calculated rather than fetched).  We will use not_lval for values
   fetched from generic dummy frames.

   Set *ADDRP to the address, either in memory or as a REGISTER_BYTE
   offset into the registers array.  If the value is stored in a dummy
   frame, set *ADDRP to zero.

   To use this implementation, define a function called
   "get_saved_register" in your target code, which simply passes all
   of its arguments to this function.

   The argument RAW_BUFFER must point to aligned memory.  */

void
deprecated_generic_get_saved_register (char *raw_buffer, int *optimized,
				       CORE_ADDR *addrp,
				       struct frame_info *frame, int regnum,
				       enum lval_type *lval)
{
  if (!target_has_registers)
    error ("No registers.");

  /* Normal systems don't optimize out things with register numbers.  */
  if (optimized != NULL)
    *optimized = 0;

  if (addrp)			/* default assumption: not found in memory */
    *addrp = 0;

  /* Note: since the current frame's registers could only have been
     saved by frames INTERIOR TO the current frame, we skip examining
     the current frame itself: otherwise, we would be getting the
     previous frame's registers which were saved by the current frame.  */

  while (frame && ((frame = frame->next) != NULL))
    {
      if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
	{
	  if (lval)		/* found it in a CALL_DUMMY frame */
	    *lval = not_lval;
	  if (raw_buffer)
	    /* FIXME: cagney/2002-06-26: This should be via the
	       gdbarch_register_read() method so that it, on the fly,
	       constructs either a raw or pseudo register from the raw
	       register cache.  */
	    regcache_raw_read (generic_find_dummy_frame (frame->pc,
							 frame->frame),
			       regnum, raw_buffer);
	  return;
	}

      FRAME_INIT_SAVED_REGS (frame);
      if (frame->saved_regs != NULL
	  && frame->saved_regs[regnum] != 0)
	{
	  if (lval)		/* found it saved on the stack */
	    *lval = lval_memory;
	  if (regnum == SP_REGNUM)
	    {
	      if (raw_buffer)	/* SP register treated specially */
		store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
			       frame->saved_regs[regnum]);
	    }
	  else
	    {
	      if (addrp)	/* any other register */
		*addrp = frame->saved_regs[regnum];
	      if (raw_buffer)
		read_memory (frame->saved_regs[regnum], raw_buffer,
			     REGISTER_RAW_SIZE (regnum));
	    }
	  return;
	}
    }

  /* If we get thru the loop to this point, it means the register was
     not saved in any frame.  Return the actual live-register value.  */

  if (lval)			/* found it in a live register */
    *lval = lval_register;
  if (addrp)
    *addrp = REGISTER_BYTE (regnum);
  if (raw_buffer)
    deprecated_read_register_gen (regnum, raw_buffer);
}

/* Using the PC, select a mechanism for unwinding a frame returning
   the previous frame.  The register unwind function should, on
   demand, initialize the ->context object.  */

static void
set_unwind_by_pc (CORE_ADDR pc, CORE_ADDR fp,
		  frame_register_unwind_ftype **unwind)
{
  if (!USE_GENERIC_DUMMY_FRAMES)
    /* Still need to set this to something.  The ``info frame'' code
       calls this function to find out where the saved registers are.
       Hopefully this is robust enough to stop any core dumps and
       return vaguely correct values..  */
    *unwind = frame_saved_regs_register_unwind;
  else if (PC_IN_CALL_DUMMY (pc, fp, fp))
    *unwind = dummy_frame_register_unwind;
  else
    *unwind = frame_saved_regs_register_unwind;
}

/* Create an arbitrary (i.e. address specified by user) or innermost frame.
   Always returns a non-NULL value.  */

struct frame_info *
create_new_frame (CORE_ADDR addr, CORE_ADDR pc)
{
  struct frame_info *fi;
  char *name;

  fi = (struct frame_info *)
    obstack_alloc (&frame_cache_obstack,
		   sizeof (struct frame_info));

  /* Zero all fields by default.  */
  memset (fi, 0, sizeof (struct frame_info));

  fi->frame = addr;
  fi->pc = pc;
  find_pc_partial_function (pc, &name, (CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
  fi->signal_handler_caller = PC_IN_SIGTRAMP (fi->pc, name);

  if (INIT_EXTRA_FRAME_INFO_P ())
    INIT_EXTRA_FRAME_INFO (0, fi);

  /* Select/initialize an unwind function.  */
  set_unwind_by_pc (fi->pc, fi->frame, &fi->register_unwind);

  return fi;
}

/* Return the frame that FRAME calls (NULL if FRAME is the innermost
   frame).  */

struct frame_info *
get_next_frame (struct frame_info *frame)
{
  return frame->next;
}

/* Flush the entire frame cache.  */

void
flush_cached_frames (void)
{
  /* Since we can't really be sure what the first object allocated was */
  obstack_free (&frame_cache_obstack, 0);
  obstack_init (&frame_cache_obstack);

  current_frame = NULL;		/* Invalidate cache */
  select_frame (NULL);
  annotate_frames_invalid ();
}

/* Flush the frame cache, and start a new one if necessary.  */

void
reinit_frame_cache (void)
{
  flush_cached_frames ();

  /* FIXME: The inferior_ptid test is wrong if there is a corefile.  */
  if (PIDGET (inferior_ptid) != 0)
    {
      select_frame (get_current_frame ());
    }
}

/* Return a structure containing various interesting information
   about the frame that called NEXT_FRAME.  Returns NULL
   if there is no such frame.  */

struct frame_info *
get_prev_frame (struct frame_info *next_frame)
{
  CORE_ADDR address = 0;
  struct frame_info *prev;
  int fromleaf;
  char *name;

  /* Return the inner-most frame, when the caller passes in NULL.  */
  /* NOTE: cagney/2002-11-09: Not sure how this would happen.  The
     caller should have previously obtained a valid frame using
     get_selected_frame() and then called this code - only possibility
     I can think of is code behaving badly.  */
  if (next_frame == NULL)
    {
      /* NOTE: cagney/2002-11-09: There was a code segment here that
	 would error out when CURRENT_FRAME was NULL.  The comment
	 that went with it made the claim ...

	 ``This screws value_of_variable, which just wants a nice
	 clean NULL return from block_innermost_frame if there are no
	 frames.  I don't think I've ever seen this message happen
	 otherwise.  And returning NULL here is a perfectly legitimate
	 thing to do.''

         Per the above, this code shouldn't even be called with a NULL
         NEXT_FRAME.  */
      return current_frame;
    }

  /* Only try to do the unwind once.  */
  if (next_frame->prev_p)
    return next_frame->prev;
  next_frame->prev_p = 1;

  /* On some machines it is possible to call a function without
     setting up a stack frame for it.  On these machines, we
     define this macro to take two args; a frameinfo pointer
     identifying a frame and a variable to set or clear if it is
     or isn't leafless.  */

  /* Still don't want to worry about this except on the innermost
     frame.  This macro will set FROMLEAF if NEXT_FRAME is a frameless
     function invocation.  */
  if (next_frame->next == NULL)
    /* FIXME: 2002-11-09: Frameless functions can occure anywhere in
       the frame chain, not just the inner most frame!  The generic,
       per-architecture, frame code should handle this and the below
       should simply be removed.  */
    fromleaf = FRAMELESS_FUNCTION_INVOCATION (next_frame);
  else
    fromleaf = 0;

  if (fromleaf)
    /* A frameless inner-most frame.  The `FP' (which isn't an
       architecture frame-pointer register!) of the caller is the same
       as the callee.  */
    /* FIXME: 2002-11-09: There isn't any reason to special case this
       edge condition.  Instead the per-architecture code should hande
       it locally.  */
    address = FRAME_FP (next_frame);
  else
    {
      /* Two macros defined in tm.h specify the machine-dependent
         actions to be performed here.

         First, get the frame's chain-pointer.

         If that is zero, the frame is the outermost frame or a leaf
         called by the outermost frame.  This means that if start
         calls main without a frame, we'll return 0 (which is fine
         anyway).

         Nope; there's a problem.  This also returns when the current
         routine is a leaf of main.  This is unacceptable.  We move
         this to after the ffi test; I'd rather have backtraces from
         start go curfluy than have an abort called from main not show
         main.  */
      address = FRAME_CHAIN (next_frame);

      /* FIXME: cagney/2002-06-08: There should be two tests here.
         The first would check for a valid frame chain based on a user
         selectable policy.  The default being ``stop at main'' (as
         implemented by generic_func_frame_chain_valid()).  Other
         policies would be available - stop at NULL, ....  The second
         test, if provided by the target architecture, would check for
         more exotic cases - most target architectures wouldn't bother
         with this second case.  */
      if (!FRAME_CHAIN_VALID (address, next_frame))
	return 0;
    }
  if (address == 0)
    return 0;

  /* Create an initially zero previous frame.  */
  prev = (struct frame_info *)
    obstack_alloc (&frame_cache_obstack,
		   sizeof (struct frame_info));
  memset (prev, 0, sizeof (struct frame_info));

  /* Link it in.  */
  next_frame->prev = prev;
  prev->next = next_frame;
  prev->frame = address;
  prev->level = next_frame->level + 1;

  /* This change should not be needed, FIXME!  We should determine
     whether any targets *need* INIT_FRAME_PC to happen after
     INIT_EXTRA_FRAME_INFO and come up with a simple way to express
     what goes on here.

     INIT_EXTRA_FRAME_INFO is called from two places: create_new_frame
     (where the PC is already set up) and here (where it isn't).
     INIT_FRAME_PC is only called from here, always after
     INIT_EXTRA_FRAME_INFO.

     The catch is the MIPS, where INIT_EXTRA_FRAME_INFO requires the
     PC value (which hasn't been set yet).  Some other machines appear
     to require INIT_EXTRA_FRAME_INFO before they can do
     INIT_FRAME_PC.  Phoo.

     We shouldn't need INIT_FRAME_PC_FIRST to add more complication to
     an already overcomplicated part of GDB.  gnu@@cygnus.com, 15Sep92.

     Assuming that some machines need INIT_FRAME_PC after
     INIT_EXTRA_FRAME_INFO, one possible scheme:

     SETUP_INNERMOST_FRAME(): Default version is just create_new_frame
     (read_fp ()), read_pc ()).  Machines with extra frame info would
     do that (or the local equivalent) and then set the extra fields.

     SETUP_ARBITRARY_FRAME(argc, argv): Only change here is that
     create_new_frame would no longer init extra frame info;
     SETUP_ARBITRARY_FRAME would have to do that.

     INIT_PREV_FRAME(fromleaf, prev) Replace INIT_EXTRA_FRAME_INFO and
     INIT_FRAME_PC.  This should also return a flag saying whether to
     keep the new frame, or whether to discard it, because on some
     machines (e.g.  mips) it is really awkward to have
     FRAME_CHAIN_VALID called *before* INIT_EXTRA_FRAME_INFO (there is
     no good way to get information deduced in FRAME_CHAIN_VALID into
     the extra fields of the new frame).  std_frame_pc(fromleaf, prev)

     This is the default setting for INIT_PREV_FRAME.  It just does
     what the default INIT_FRAME_PC does.  Some machines will call it
     from INIT_PREV_FRAME (either at the beginning, the end, or in the
     middle).  Some machines won't use it.

     kingdon@@cygnus.com, 13Apr93, 31Jan94, 14Dec94.  */

  /* NOTE: cagney/2002-11-09: Just ignore the above!  There is no
     reason for things to be this complicated.

     The trick is to assume that there is always a frame.  Instead of
     special casing the inner-most frame, create fake frame
     (containing the hardware registers) that is inner to the
     user-visible inner-most frame (...) and then unwind from that.
     That way architecture code can use use the standard
     frame_XX_unwind() functions and not differentiate between the
     inner most and any other case.

     Since there is always a frame to unwind from, there is always
     somewhere (NEXT_FRAME) to store all the info needed to construct
     a new (previous) frame without having to first create it.  This
     means that the convolution below - needing to carefully order a
     frame's initialization - isn't needed.

     The irony here though, is that FRAME_CHAIN(), at least for a more
     up-to-date architecture, always calls FRAME_SAVED_PC(), and
     FRAME_SAVED_PC() computes the PC but without first needing the
     frame!  Instead of the convolution below, we could have simply
     called FRAME_SAVED_PC() and been done with it!  Note that
     FRAME_SAVED_PC() is being superseed by frame_pc_unwind() and that
     function does have somewhere to cache that PC value.  */

  INIT_FRAME_PC_FIRST (fromleaf, prev);

  if (INIT_EXTRA_FRAME_INFO_P ())
    INIT_EXTRA_FRAME_INFO (fromleaf, prev);

  /* This entry is in the frame queue now, which is good since
     FRAME_SAVED_PC may use that queue to figure out its value (see
     tm-sparc.h).  We want the pc saved in the inferior frame. */
  INIT_FRAME_PC (fromleaf, prev);

  /* If ->frame and ->pc are unchanged, we are in the process of
     getting ourselves into an infinite backtrace.  Some architectures
     check this in FRAME_CHAIN or thereabouts, but it seems like there
     is no reason this can't be an architecture-independent check.  */
  if (prev->frame == next_frame->frame
      && prev->pc == next_frame->pc)
    {
      next_frame->prev = NULL;
      obstack_free (&frame_cache_obstack, prev);
      return NULL;
    }

  /* Initialize the code used to unwind the frame PREV based on the PC
     (and probably other architectural information).  The PC lets you
     check things like the debug info at that point (dwarf2cfi?) and
     use that to decide how the frame should be unwound.  */
  set_unwind_by_pc (prev->pc, prev->frame, &prev->register_unwind);

  find_pc_partial_function (prev->pc, &name,
			    (CORE_ADDR *) NULL, (CORE_ADDR *) NULL);
  if (PC_IN_SIGTRAMP (prev->pc, name))
    prev->signal_handler_caller = 1;

  return prev;
}

CORE_ADDR
get_frame_pc (struct frame_info *frame)
{
  return frame->pc;
}

#ifdef FRAME_FIND_SAVED_REGS
/* XXX - deprecated.  This is a compatibility function for targets
   that do not yet implement FRAME_INIT_SAVED_REGS.  */
/* Find the addresses in which registers are saved in FRAME.  */

void
get_frame_saved_regs (struct frame_info *frame,
		      struct frame_saved_regs *saved_regs_addr)
{
  if (frame->saved_regs == NULL)
    {
      frame->saved_regs = (CORE_ADDR *)
	frame_obstack_alloc (SIZEOF_FRAME_SAVED_REGS);
    }
  if (saved_regs_addr == NULL)
    {
      struct frame_saved_regs saved_regs;
      FRAME_FIND_SAVED_REGS (frame, saved_regs);
      memcpy (frame->saved_regs, &saved_regs, SIZEOF_FRAME_SAVED_REGS);
    }
  else
    {
      FRAME_FIND_SAVED_REGS (frame, *saved_regs_addr);
      memcpy (frame->saved_regs, saved_regs_addr, SIZEOF_FRAME_SAVED_REGS);
    }
}
#endif

void
_initialize_frame (void)
{
  obstack_init (&frame_cache_obstack);
@


1.17.2.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a35 1
#include "language.h"
d37 1
a37 1
/* Return a frame uniq ID that can be used to, later, re-find the
d40 2
a41 2
struct frame_id
get_frame_id (struct frame_info *fi)
d45 2
a46 1
      return null_frame_id;
d50 2
a51 4
      struct frame_id id;
      id.base = fi->frame;
      id.pc = fi->pc;
      return id;
a54 39
const struct frame_id null_frame_id; /* All zeros.  */

struct frame_id
frame_id_build (CORE_ADDR base, CORE_ADDR func_or_pc)
{
  struct frame_id id;
  id.base = base;
  id.pc = func_or_pc;
  return id;
}

int
frame_id_p (struct frame_id l)
{
  /* The .func can be NULL but the .base cannot.  */
  return (l.base != 0);
}

int
frame_id_eq (struct frame_id l, struct frame_id r)
{
  /* If .base is different, the frames are different.  */
  if (l.base != r.base)
    return 0;
  /* Add a test to check that the frame ID's are for the same function
     here.  */
  return 1;
}

int
frame_id_inner (struct frame_id l, struct frame_id r)
{
  /* Only return non-zero when strictly inner than.  Note that, per
     comment in "frame.h", there is some fuzz here.  Frameless
     functions are not strictly inner than (same .base but different
     .func).  */
  return INNER_THAN (l.base, r.base);
}

d62 1
a62 1
  if (!frame_id_p (id))
d69 7
a75 6
      struct frame_id this = get_frame_id (frame);
      if (frame_id_eq (id, this))
	/* An exact match.  */
	return frame;
      if (frame_id_inner (id, this))
	/* Gone to far.  */
d77 6
a82 4
      /* Either, we're not yet gone far enough out along the frame
         chain (inner(this,id), or we're comparing frameless functions
         (same .base, different .func, no test available).  Struggle
         on until we've definitly gone to far.  */
a86 24
CORE_ADDR
frame_pc_unwind (struct frame_info *frame)
{
  if (!frame->pc_unwind_cache_p)
    {
      frame->pc_unwind_cache = frame->pc_unwind (frame, &frame->unwind_cache);
      frame->pc_unwind_cache_p = 1;
    }
  return frame->pc_unwind_cache;
}

struct frame_id
frame_id_unwind (struct frame_info *frame)
{
  if (!frame->id_unwind_cache_p)
    {
      frame->id_unwind_cache =
	frame->id_unwind (frame, &frame->unwind_cache);
      frame->id_unwind_cache_p = 1;
    }
  return frame->id_unwind_cache;
}


d127 1
a127 1
  frame->register_unwind (frame, &frame->unwind_cache, regnum,
d253 1
a253 1
static void
d402 1
a402 1
CORE_ADDR *
a407 1
  return fi->saved_regs;
a409 5
CORE_ADDR *
get_frame_saved_regs (struct frame_info *fi)
{
  return fi->saved_regs;
}
a425 24
/* The "selected" stack frame is used by default for local and arg
   access.  May be zero, for no selected frame.  */

struct frame_info *deprecated_selected_frame;

/* Return the selected frame.  Always non-null (unless there isn't an
   inferior sufficient for creating a frame) in which case an error is
   thrown.  */

struct frame_info *
get_selected_frame (void)
{
  if (deprecated_selected_frame == NULL)
    /* Hey!  Don't trust this.  It should really be re-finding the
       last selected frame of the currently selected thread.  This,
       though, is better than nothing.  */
    select_frame (get_current_frame ());
  /* There is always a frame.  */
  gdb_assert (deprecated_selected_frame != NULL);
  return deprecated_selected_frame;
}

/* Select frame FI (or NULL - to invalidate the current frame).  */

d427 1
a427 1
select_frame (struct frame_info *fi)
d429 1
a429 30
  register struct symtab *s;

  deprecated_selected_frame = fi;
  /* NOTE: cagney/2002-05-04: FI can be NULL.  This occures when the
     frame is being invalidated.  */
  if (selected_frame_level_changed_hook)
    selected_frame_level_changed_hook (frame_relative_level (fi));

  /* FIXME: kseitz/2002-08-28: It would be nice to call
     selected_frame_level_changed_event right here, but due to limitations
     in the current interfaces, we would end up flooding UIs with events
     because select_frame is used extensively internally.

     Once we have frame-parameterized frame (and frame-related) commands,
     the event notification can be moved here, since this function will only
     be called when the users selected frame is being changed. */

  /* Ensure that symbols for this frame are read in.  Also, determine the
     source language of this frame, and switch to it if desired.  */
  if (fi)
    {
      s = find_pc_symtab (fi->pc);
      if (s
	  && s->language != current_language->la_language
	  && s->language != language_unknown
	  && language_mode == language_mode_auto)
	{
	  set_language (s->language);
	}
    }
d448 2
a449 2
  gdb_assert (!(DEPRECATED_USE_GENERIC_DUMMY_FRAMES
		&& (get_frame_type (frame) == DUMMY_FRAME)));
a526 68
static CORE_ADDR
frame_saved_regs_pc_unwind (struct frame_info *frame, void **cache)
{
  return FRAME_SAVED_PC (frame);
}
	
static struct frame_id
frame_saved_regs_id_unwind (struct frame_info *next_frame, void **cache)
{
  int fromleaf;
  struct frame_id id;

  if (next_frame->next == NULL)
    /* FIXME: 2002-11-09: Frameless functions can occure anywhere in
       the frame chain, not just the inner most frame!  The generic,
       per-architecture, frame code should handle this and the below
       should simply be removed.  */
    fromleaf = FRAMELESS_FUNCTION_INVOCATION (next_frame);
  else
    fromleaf = 0;

  if (fromleaf)
    /* A frameless inner-most frame.  The `FP' (which isn't an
       architecture frame-pointer register!) of the caller is the same
       as the callee.  */
    /* FIXME: 2002-11-09: There isn't any reason to special case this
       edge condition.  Instead the per-architecture code should hande
       it locally.  */
    id.base = get_frame_base (next_frame);
  else
    {
      /* Two macros defined in tm.h specify the machine-dependent
         actions to be performed here.

         First, get the frame's chain-pointer.

         If that is zero, the frame is the outermost frame or a leaf
         called by the outermost frame.  This means that if start
         calls main without a frame, we'll return 0 (which is fine
         anyway).

         Nope; there's a problem.  This also returns when the current
         routine is a leaf of main.  This is unacceptable.  We move
         this to after the ffi test; I'd rather have backtraces from
         start go curfluy than have an abort called from main not show
         main.  */
      id.base = FRAME_CHAIN (next_frame);

      /* FIXME: cagney/2002-06-08: There should be two tests here.
         The first would check for a valid frame chain based on a user
         selectable policy.  The default being ``stop at main'' (as
         implemented by generic_func_frame_chain_valid()).  Other
         policies would be available - stop at NULL, ....  The second
         test, if provided by the target architecture, would check for
         more exotic cases - most target architectures wouldn't bother
         with this second case.  */
      if (!FRAME_CHAIN_VALID (id.base, next_frame))
	return null_frame_id;
    }
  if (id.base == 0)
    return null_frame_id;

  /* FIXME: cagney/2002-06-08: This should probably return the frame's
     function and not the PC (a.k.a. resume address).  */
  id.pc = frame_pc_unwind (next_frame);
  return id;
}
	
d574 1
a574 1
      if (get_frame_type (frame) == DUMMY_FRAME)
d630 1
a630 3
		  frame_register_unwind_ftype **unwind_register,
		  frame_pc_unwind_ftype **unwind_pc,
		  frame_id_unwind_ftype **unwind_id)
d632 8
a639 18
  if (!DEPRECATED_USE_GENERIC_DUMMY_FRAMES)
    {
      /* Still need to set this to something.  The ``info frame'' code
	 calls this function to find out where the saved registers are.
	 Hopefully this is robust enough to stop any core dumps and
	 return vaguely correct values..  */
      *unwind_register = frame_saved_regs_register_unwind;
      *unwind_pc = frame_saved_regs_pc_unwind;
      *unwind_id = frame_saved_regs_id_unwind;
    }
  else if (DEPRECATED_PC_IN_CALL_DUMMY_P ()
	   ? DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0)
	   : pc_in_dummy_frame (pc))
    {
      *unwind_register = dummy_frame_register_unwind;
      *unwind_pc = dummy_frame_pc_unwind;
      *unwind_id = dummy_frame_id_unwind;
    }
d641 1
a641 5
    {
      *unwind_register = frame_saved_regs_register_unwind;
      *unwind_pc = frame_saved_regs_pc_unwind;
      *unwind_id = frame_saved_regs_id_unwind;
    }
d651 1
a651 1
  enum frame_type type;
d662 2
a663 24
  /* NOTE: cagney/2002-11-18: The code segments, found in
     create_new_frame and get_prev_frame(), that initializes the
     frames type is subtly different.  The latter only updates ->type
     when it encounters a SIGTRAMP_FRAME or DUMMY_FRAME.  This stops
     get_prev_frame() overriding the frame's type when the INIT code
     has previously set it.  This is really somewhat bogus.  The
     initialization, as seen in create_new_frame(), should occur
     before the INIT function has been called.  */
  if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES
      && (DEPRECATED_PC_IN_CALL_DUMMY_P ()
	  ? DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0)
	  : pc_in_dummy_frame (pc)))
    /* NOTE: cagney/2002-11-11: Does this even occure?  */
    type = DUMMY_FRAME;
  else
    {
      char *name;
      find_pc_partial_function (pc, &name, NULL, NULL);
      if (PC_IN_SIGTRAMP (fi->pc, name))
	type = SIGTRAMP_FRAME;
      else
	type = NORMAL_FRAME;
    }
  fi->type = type;
d669 1
a669 2
  set_unwind_by_pc (fi->pc, fi->frame, &fi->register_unwind,
		    &fi->pc_unwind, &fi->id_unwind);
d721 1
d775 1
a775 1
    address = get_frame_base (next_frame);
a819 5
  /* FIXME: cagney/2002-11-18: Should be setting the frame's type
     here, before anything else, and not last.  Various INIT functions
     are full of work-arounds for the frames type not being set
     correctly from the word go.  Ulgh!  */
  prev->type = NORMAL_FRAME;
d822 3
a824 3
     whether any targets *need* DEPRECATED_INIT_FRAME_PC to happen
     after INIT_EXTRA_FRAME_INFO and come up with a simple way to
     express what goes on here.
d828 1
a828 1
     DEPRECATED_INIT_FRAME_PC is only called from here, always after
d834 1
a834 1
     DEPRECATED_INIT_FRAME_PC.  Phoo.
d836 2
a837 3
     We shouldn't need DEPRECATED_INIT_FRAME_PC_FIRST to add more
     complication to an already overcomplicated part of GDB.
     gnu@@cygnus.com, 15Sep92.
d839 1
a839 1
     Assuming that some machines need DEPRECATED_INIT_FRAME_PC after
d851 3
a853 3
     DEPRECATED_INIT_FRAME_PC.  This should also return a flag saying
     whether to keep the new frame, or whether to discard it, because
     on some machines (e.g.  mips) it is really awkward to have
d859 3
a861 3
     what the default DEPRECATED_INIT_FRAME_PC does.  Some machines
     will call it from INIT_PREV_FRAME (either at the beginning, the
     end, or in the middle).  Some machines won't use it.
d890 1
a890 2
  if (DEPRECATED_INIT_FRAME_PC_FIRST_P ())
    prev->pc = (DEPRECATED_INIT_FRAME_PC_FIRST (fromleaf, prev));
d898 1
a898 2
  if (DEPRECATED_INIT_FRAME_PC_P ())
    prev->pc = DEPRECATED_INIT_FRAME_PC (fromleaf, prev);
d916 1
a916 2
  set_unwind_by_pc (prev->pc, prev->frame, &prev->register_unwind,
		    &prev->pc_unwind, &prev->id_unwind);
d918 4
a921 32
  /* NOTE: cagney/2002-11-18: The code segments, found in
     create_new_frame and get_prev_frame(), that initializes the
     frames type is subtly different.  The latter only updates ->type
     when it encounters a SIGTRAMP_FRAME or DUMMY_FRAME.  This stops
     get_prev_frame() overriding the frame's type when the INIT code
     has previously set it.  This is really somewhat bogus.  The
     initialization, as seen in create_new_frame(), should occur
     before the INIT function has been called.  */
  if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES
      && (DEPRECATED_PC_IN_CALL_DUMMY_P ()
	  ? DEPRECATED_PC_IN_CALL_DUMMY (prev->pc, 0, 0)
	  : pc_in_dummy_frame (prev->pc)))
    prev->type = DUMMY_FRAME;
  else
    {
      /* FIXME: cagney/2002-11-10: This should be moved to before the
	 INIT code above so that the INIT code knows what the frame's
	 type is (in fact, for a [generic] dummy-frame, the type can
	 be set and then the entire initialization can be skipped.
	 Unforunatly, its the INIT code that sets the PC (Hmm, catch
	 22).  */
      char *name;
      find_pc_partial_function (prev->pc, &name, NULL, NULL);
      if (PC_IN_SIGTRAMP (prev->pc, name))
	prev->type = SIGTRAMP_FRAME;
      /* FIXME: cagney/2002-11-11: Leave prev->type alone.  Some
         architectures are forcing the frame's type in INIT so we
         don't want to override it here.  Remember, NORMAL_FRAME == 0,
         so it all works (just :-/).  Once this initialization is
         moved to the start of this function, all this nastness will
         go away.  */
    }
a931 61
static int
pc_notcurrent (struct frame_info *frame)
{
  /* If FRAME is not the innermost frame, that normally means that
     FRAME->pc points at the return instruction (which is *after* the
     call instruction), and we want to get the line containing the
     call (because the call is where the user thinks the program is).
     However, if the next frame is either a SIGTRAMP_FRAME or a
     DUMMY_FRAME, then the next frame will contain a saved interrupt
     PC and such a PC indicates the current (rather than next)
     instruction/line, consequently, for such cases, want to get the
     line containing fi->pc.  */
  struct frame_info *next = get_next_frame (frame);
  int notcurrent = (next != NULL && get_frame_type (next) == NORMAL_FRAME);
  return notcurrent;
}

void
find_frame_sal (struct frame_info *frame, struct symtab_and_line *sal)
{
  (*sal) = find_pc_line (frame->pc, pc_notcurrent (frame));
}

/* Per "frame.h", return the ``address'' of the frame.  Code should
   really be using get_frame_id().  */
CORE_ADDR
get_frame_base (struct frame_info *fi)
{
  return fi->frame;
}

/* Level of the selected frame: 0 for innermost, 1 for its caller, ...
   or -1 for a NULL frame.  */

int
frame_relative_level (struct frame_info *fi)
{
  if (fi == NULL)
    return -1;
  else
    return fi->level;
}

enum frame_type
get_frame_type (struct frame_info *frame)
{
  /* Some targets still don't use [generic] dummy frames.  Catch them
     here.  */
  if (!DEPRECATED_USE_GENERIC_DUMMY_FRAMES
      && deprecated_frame_in_dummy (frame))
    return DUMMY_FRAME;
  return frame->type;
}

void
deprecated_set_frame_type (struct frame_info *frame, enum frame_type type)
{
  /* Arrrg!  See comment in "frame.h".  */
  frame->type = type;
}

d938 2
a939 2
deprecated_get_frame_saved_regs (struct frame_info *frame,
				 struct frame_saved_regs *saved_regs_addr)
a958 28

struct frame_extra_info *
get_frame_extra_info (struct frame_info *fi)
{
  return fi->extra_info;
}

struct frame_extra_info *
frame_extra_info_zalloc (struct frame_info *fi, long size)
{
  fi->extra_info = frame_obstack_alloc (size);
  memset (fi->extra_info, 0, size);
  return fi->extra_info;
}

void
deprecated_update_frame_pc_hack (struct frame_info *frame, CORE_ADDR pc)
{
  /* See comment in "frame.h".  */
  frame->pc = pc;
}

void
deprecated_update_frame_base_hack (struct frame_info *frame, CORE_ADDR base)
{
  /* See comment in "frame.h".  */
  frame->frame = base;
}
@


1.17.2.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 1
a4 1
   2001, 2002, 2003 Free Software Foundation, Inc.
a33 1
#include "sentinel-frame.h"
a36 7
#include "frame-unwind.h"
#include "command.h"
#include "gdbcmd.h"

/* Flag to indicate whether backtraces should stop at main.  */

static int backtrace_below_main;
d130 1
a130 1
      frame->pc_unwind_cache = frame->unwind->pc (frame, &frame->unwind_cache);
d141 2
a142 1
      frame->unwind->id (frame, &frame->unwind_cache, &frame->id_unwind_cache);
a147 12
void
frame_pop (struct frame_info *frame)
{
  /* FIXME: cagney/2003-01-18: There is probably a chicken-egg problem
     with passing in current_regcache.  The pop function needs to be
     written carefully so as to not overwrite registers whose [old]
     values are needed to restore other registers.  Instead, this code
     should pass in a scratch cache and, as a second step, restore the
     registers using that.  */
  frame->unwind->pop (frame, &frame->unwind_cache, current_regcache);
  flush_cached_frames ();
}
d164 23
a186 5
  /* NOTE: cagney/2002-11-27: A program trying to unwind a NULL frame
     is broken.  There is always a frame.  If there, for some reason,
     isn't, there is some pretty busted code as it should have
     detected the problem before calling here.  */
  gdb_assert (frame != NULL);
d189 2
a190 2
  frame->unwind->reg (frame, &frame->unwind_cache, regnum,
		      optimizedp, lvalp, addrp, realnump, bufferp);
d232 19
a250 5
  /* Obtain the register value by unwinding the register from the next
     (more inner frame).  */
  gdb_assert (frame != NULL && frame->next != NULL);
  frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			 realnump, bufferp);
d254 2
a255 1
frame_unwind_register (struct frame_info *frame, int regnum, void *buf)
d261 1
a263 8
}

void
frame_unwind_signed_register (struct frame_info *frame, int regnum,
			      LONGEST *val)
{
  void *buf = alloca (MAX_REGISTER_RAW_SIZE);
  frame_unwind_register (frame, regnum, buf);
d271 4
d276 2
a277 1
  frame_unwind_register (frame, regnum, buf);
a281 7
frame_read_register (struct frame_info *frame, int regnum, void *buf)
{
  gdb_assert (frame != NULL && frame->next != NULL);
  frame_unwind_register (frame->next, regnum, buf);
}

void
d302 2
a303 2
  gdb_assert (frame != NULL && frame->next != NULL);
  frame_unwind_unsigned_register (frame->next, regnum, val);
d310 3
a312 3
  /* See note above in frame_read_unsigned_register().  */
  gdb_assert (frame != NULL && frame->next != NULL);
  frame_unwind_signed_register (frame->next, regnum, val);
d340 19
a358 3
  gdb_assert (frame != NULL && frame->next != NULL);
  frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			 &realnumx, raw_buffer);
a416 3
  if (len < 0)
    len = strlen (name);

a447 26
/* Create a sentinel frame.  */

struct frame_info *
create_sentinel_frame (struct regcache *regcache)
{
  struct frame_info *frame = FRAME_OBSTACK_ZALLOC (struct frame_info);
  frame->type = NORMAL_FRAME;
  frame->level = -1;
  /* Explicitly initialize the sentinel frame's cache.  Provide it
     with the underlying regcache.  In the future additional
     information, such as the frame's thread will be added.  */
  frame->unwind_cache = sentinel_frame_cache (regcache);
  /* For the moment there is only one sentinel frame implementation.  */
  frame->unwind = sentinel_frame_unwind;
  /* Link this frame back to itself.  The frame is self referential
     (the unwound PC is the same as the pc), so make it so.  */
  frame->next = frame;
  /* Always unwind the PC as part of creating this frame.  This
     ensures that the frame's PC points at something valid.  */
  /* FIXME: cagney/2003-01-10: Problem here.  Unwinding a sentinel
     frame's PC may require information such as the frame's thread's
     stop reason.  Is it possible to get to that?  */
  frame->pc = frame_pc_unwind (frame);
  return frame;
}

d459 1
a459 1
frame_obstack_zalloc (unsigned long size)
d461 1
a461 3
  void *data = obstack_alloc (&frame_cache_obstack, size);
  memset (data, 0, size);
  return data;
d468 2
a469 1
    frame_obstack_zalloc (SIZEOF_FRAME_SAVED_REGS);
d479 1
a479 16
/* Return the innermost (currently executing) stack frame.  This is
   split into two functions.  The function unwind_to_current_frame()
   is wrapped in catch exceptions so that, even when the unwind of the
   sentinel frame fails, the function still returns a stack frame.  */

static int
unwind_to_current_frame (struct ui_out *ui_out, void *args)
{
  struct frame_info *frame = get_prev_frame (args);
  /* A sentinel frame can fail to unwind, eg, because it's PC value
     lands in somewhere like start.  */
  if (frame == NULL)
    return 1;
  current_frame = frame;
  return 0;
}
a483 6
  if (!target_has_stack)
    error ("No stack.");
  if (!target_has_registers)
    error ("No registers.");
  if (!target_has_memory)
    error ("No memory.");
d486 4
a489 9
      struct frame_info *sentinel_frame =
	create_sentinel_frame (current_regcache);
      if (catch_exceptions (uiout, unwind_to_current_frame, sentinel_frame,
			    NULL, RETURN_MASK_ERROR) != 0)
	{
	  /* Oops! Fake a current frame?  Is this useful?  It has a PC
             of zero, for instance.  */
	  current_frame = sentinel_frame;
	}
a571 4
  /* Only (older) architectures that implement the
     FRAME_INIT_SAVED_REGS method should be using this function.  */
  gdb_assert (FRAME_INIT_SAVED_REGS_P ());

d573 1
a573 1
  if (get_frame_saved_regs (frame) == NULL)
d576 2
a577 2
  if (get_frame_saved_regs (frame) != NULL
      && get_frame_saved_regs (frame)[regnum] != 0)
d588 1
a588 1
			   get_frame_saved_regs (frame)[regnum]);
d596 1
a596 1
	  *addrp = get_frame_saved_regs (frame)[regnum];
d608 2
a609 1
		  regs = frame_obstack_zalloc (sizeof_cache);
d615 2
a616 2
		    = frame_obstack_zalloc (REGISTER_RAW_SIZE (regnum));
		  read_memory (get_frame_saved_regs (frame)[regnum], regs[regnum],
d622 1
a622 1
	      read_memory (get_frame_saved_regs (frame)[regnum], bufferp,
d631 15
a645 5
     value.  Pass the request down the frame chain to the next frame.
     Hopefully that will find the register's location, either in a
     register or in memory.  */
  frame_register (frame, regnum, optimizedp, lvalp, addrp, realnump,
		  bufferp);
a650 1
  gdb_assert (FRAME_SAVED_PC_P ());
d654 2
a655 3
static void
frame_saved_regs_id_unwind (struct frame_info *next_frame, void **cache,
			    struct frame_id *id)
d658 1
a658 5
  CORE_ADDR base;
  CORE_ADDR pc;

  /* Start out by assuming it's NULL.  */
  (*id) = null_frame_id;
d660 1
a660 1
  if (frame_relative_level (next_frame) <= 0)
d676 1
a676 1
    base = get_frame_base (next_frame);
d694 1
a694 2
      gdb_assert (FRAME_CHAIN_P ());
      base = FRAME_CHAIN (next_frame);
d696 10
a705 2
      if (!frame_chain_valid (base, next_frame))
	return;
d707 2
a708 2
  if (base == 0)
    return;
d712 2
a713 3
  pc = frame_pc_unwind (next_frame);
  id->pc = pc;
  id->base = base;
a715 17
static void
frame_saved_regs_pop (struct frame_info *fi, void **cache,
		      struct regcache *regcache)
{
  gdb_assert (POP_FRAME_P ());
  POP_FRAME;
}

const struct frame_unwind trad_frame_unwinder = {
  frame_saved_regs_pop,
  frame_saved_regs_pc_unwind,
  frame_saved_regs_id_unwind,
  frame_saved_regs_register_unwind
};
const struct frame_unwind *trad_frame_unwind = &trad_frame_unwinder;


a748 2
  gdb_assert (FRAME_INIT_SAVED_REGS_P ());

d761 1
a761 1
  if (frame != NULL)
d763 18
a780 3
      for (frame = get_next_frame (frame);
	   frame_relative_level (frame) >= 0;
	   frame = get_next_frame (frame))
d782 3
a784 1
	  if (get_frame_type (frame) == DUMMY_FRAME)
d786 3
a788 12
	      if (lval)		/* found it in a CALL_DUMMY frame */
		*lval = not_lval;
	      if (raw_buffer)
		/* FIXME: cagney/2002-06-26: This should be via the
		   gdbarch_register_read() method so that it, on the
		   fly, constructs either a raw or pseudo register
		   from the raw register cache.  */
		regcache_raw_read
		  (generic_find_dummy_frame (get_frame_pc (frame),
					     get_frame_base (frame)),
		   regnum, raw_buffer);
	      return;
d790 1
a790 4

	  FRAME_INIT_SAVED_REGS (frame);
	  if (get_frame_saved_regs (frame) != NULL
	      && get_frame_saved_regs (frame)[regnum] != 0)
d792 5
a796 17
	      if (lval)		/* found it saved on the stack */
		*lval = lval_memory;
	      if (regnum == SP_REGNUM)
		{
		  if (raw_buffer)	/* SP register treated specially */
		    store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
				   get_frame_saved_regs (frame)[regnum]);
		}
	      else
		{
		  if (addrp)	/* any other register */
		    *addrp = get_frame_saved_regs (frame)[regnum];
		  if (raw_buffer)
		    read_memory (get_frame_saved_regs (frame)[regnum], raw_buffer,
				 REGISTER_RAW_SIZE (regnum));
		}
	      return;
d798 1
d813 3
a815 1
/* Determine the frame's type based on its PC.  */
d817 24
a840 10
static enum frame_type
frame_type_from_pc (CORE_ADDR pc)
{
  /* FIXME: cagney/2002-11-24: Can't yet directly call
     pc_in_dummy_frame() as some architectures don't set
     PC_IN_CALL_DUMMY() to generic_pc_in_call_dummy() (remember the
     latter is implemented by simply calling pc_in_dummy_frame).  */
  if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES
      && DEPRECATED_PC_IN_CALL_DUMMY (pc, 0, 0))
    return DUMMY_FRAME;
d843 3
a845 6
      char *name;
      find_pc_partial_function (pc, &name, NULL, NULL);
      if (PC_IN_SIGTRAMP (pc, name))
	return SIGTRAMP_FRAME;
      else
	return NORMAL_FRAME;
d856 5
d862 2
a863 1
  fi = frame_obstack_zalloc (sizeof (struct frame_info));
d867 24
a890 2
  fi->next = create_sentinel_frame (current_regcache);
  fi->type = frame_type_from_pc (pc);
d896 2
a897 1
  fi->unwind = frame_unwind_find_by_pc (current_gdbarch, fi->pc);
d903 1
a903 2
   frame).  Be careful to not fall off the bottom of the frame chain
   and onto the sentinel frame.  */
d908 1
a908 4
  if (frame->level > 0)
    return frame->next;
  else
    return NULL;
d939 3
a941 2
/* Create the previous frame using the deprecated methods
   INIT_EXTRA_INFO, INIT_FRAME_PC and INIT_FRAME_PC_FIRST.  */
d943 2
a944 2
static struct frame_info *
legacy_get_prev_frame (struct frame_info *next_frame)
d950 26
a975 3
  /* This code only works on normal frames.  A sentinel frame, where
     the level is -1, should never reach this code.  */
  gdb_assert (next_frame->level >= 0);
d986 1
a986 1
  if (next_frame->level == 0)
a1019 1
      gdb_assert (FRAME_CHAIN_P ());
d1022 9
a1030 1
      if (!frame_chain_valid (address, next_frame))
d1037 4
a1040 1
  prev = frame_obstack_zalloc (sizeof (struct frame_info));
d1151 2
a1152 1
  prev->unwind = frame_unwind_find_by_pc (current_gdbarch, prev->pc);
a1189 157
/* Return a structure containing various interesting information
   about the frame that called NEXT_FRAME.  Returns NULL
   if there is no such frame.  */

struct frame_info *
get_prev_frame (struct frame_info *next_frame)
{
  struct frame_info *prev_frame;

  /* Return the inner-most frame, when the caller passes in NULL.  */
  /* NOTE: cagney/2002-11-09: Not sure how this would happen.  The
     caller should have previously obtained a valid frame using
     get_selected_frame() and then called this code - only possibility
     I can think of is code behaving badly.

     NOTE: cagney/2003-01-10: Talk about code behaving badly.  Check
     block_innermost_frame().  It does the sequence: frame = NULL;
     while (1) { frame = get_prev_frame (frame); .... }.  Ulgh!  Why
     it couldn't be written better, I don't know.

     NOTE: cagney/2003-01-11: I suspect what is happening is
     block_innermost_frame() is, when the target has no state
     (registers, memory, ...), still calling this function.  The
     assumption being that this function will return NULL indicating
     that a frame isn't possible, rather than checking that the target
     has state and then calling get_current_frame() and
     get_prev_frame().  This is a guess mind.  */
  if (next_frame == NULL)
    {
      /* NOTE: cagney/2002-11-09: There was a code segment here that
	 would error out when CURRENT_FRAME was NULL.  The comment
	 that went with it made the claim ...

	 ``This screws value_of_variable, which just wants a nice
	 clean NULL return from block_innermost_frame if there are no
	 frames.  I don't think I've ever seen this message happen
	 otherwise.  And returning NULL here is a perfectly legitimate
	 thing to do.''

         Per the above, this code shouldn't even be called with a NULL
         NEXT_FRAME.  */
      return current_frame;
    }

  /* There is always a frame.  If this assertion fails, suspect that
     something should be calling get_selected_frame() or
     get_current_frame().  */
  gdb_assert (next_frame != NULL);

  if (next_frame->level >= 0
      && !backtrace_below_main
      && inside_main_func (get_frame_pc (next_frame)))
    /* Don't unwind past main(), bug always unwind the sentinel frame.
       Note, this is done _before_ the frame has been marked as
       previously unwound.  That way if the user later decides to
       allow unwinds past main(), that just happens.  */
    return NULL;

  /* Only try to do the unwind once.  */
  if (next_frame->prev_p)
    return next_frame->prev;
  next_frame->prev_p = 1;

  /* If we're inside the entry file, it isn't valid.  */
  /* NOTE: drow/2002-12-25: should there be a way to disable this
     check?  It assumes a single small entry file, and the way some
     debug readers (e.g.  dbxread) figure out which object is the
     entry file is somewhat hokey.  */
  /* NOTE: cagney/2003-01-10: If there is a way of disabling this test
     then it should probably be moved to before the ->prev_p test,
     above.  */
  if (inside_entry_file (get_frame_pc (next_frame)))
      return NULL;

  /* If any of the old frame initialization methods are around, use
     the legacy get_prev_frame method.  Just don't try to unwind a
     sentinel frame using that method - it doesn't work.  All sentinal
     frames use the new unwind code.  */
  if ((DEPRECATED_INIT_FRAME_PC_P ()
       || DEPRECATED_INIT_FRAME_PC_FIRST_P ()
       || INIT_EXTRA_FRAME_INFO_P ()
       || FRAME_CHAIN_P ())
      && next_frame->level >= 0)
    return legacy_get_prev_frame (next_frame);

  /* Allocate the new frame but do not wire it in to the frame chain.
     Some (bad) code in INIT_FRAME_EXTRA_INFO tries to look along
     frame->next to pull some fancy tricks (of course such code is, by
     definition, recursive).  Try to prevent it.

     There is no reason to worry about memory leaks, should the
     remainder of the function fail.  The allocated memory will be
     quickly reclaimed when the frame cache is flushed, and the `we've
     been here before' check above will stop repeated memory
     allocation calls.  */
  prev_frame = FRAME_OBSTACK_ZALLOC (struct frame_info);
  prev_frame->level = next_frame->level + 1;

  /* Try to unwind the PC.  If that doesn't work, assume we've reached
     the oldest frame and simply return.  Is there a better sentinal
     value?  The unwound PC value is then used to initialize the new
     previous frame's type.

     Note that the pc-unwind is intentionally performed before the
     frame chain.  This is ok since, for old targets, both
     frame_pc_unwind (nee, FRAME_SAVED_PC) and FRAME_CHAIN()) assume
     NEXT_FRAME's data structures have already been initialized (using
     INIT_EXTRA_FRAME_INFO) and hence the call order doesn't matter.

     By unwinding the PC first, it becomes possible to, in the case of
     a dummy frame, avoid also unwinding the frame ID.  This is
     because (well ignoring the PPC) a dummy frame can be located
     using NEXT_FRAME's frame ID.  */

  prev_frame->pc = frame_pc_unwind (next_frame);
  if (prev_frame->pc == 0)
    /* The allocated PREV_FRAME will be reclaimed when the frame
       obstack is next purged.  */
    return NULL;
  prev_frame->type = frame_type_from_pc (prev_frame->pc);

  /* Set the unwind functions based on that identified PC.  */
  prev_frame->unwind = frame_unwind_find_by_pc (current_gdbarch,
						prev_frame->pc);

  /* FIXME: cagney/2003-01-13: A dummy frame doesn't need to unwind
     the frame ID because the frame ID comes from the previous frame.
     The other frames do though.  True?  */
  {
    /* FIXME: cagney/2002-12-18: Instead of this hack, should just
       save the frame ID directly.  */
    struct frame_id id = frame_id_unwind (next_frame);
    if (!frame_id_p (id))
      return NULL;
    prev_frame->frame = id.base;
  }

  /* Link it in.  */
  next_frame->prev = prev_frame;
  prev_frame->next = next_frame;

  /* FIXME: cagney/2002-01-19: This call will go away.  Instead of
     initializing extra info, all frames will use the frame_cache
     (passed to the unwind functions) to store additional frame info.
     Unfortunatly legacy targets can't use legacy_get_prev_frame() to
     unwind the sentinel frame and, consequently, are forced to take
     this code path and rely on the below call to INIT_EXTR_FRAME_INFO
     to initialize the inner-most frame.  */
  if (INIT_EXTRA_FRAME_INFO_P ())
    {
      gdb_assert (prev_frame->level == 0);
      INIT_EXTRA_FRAME_INFO (0, prev_frame);
    }

  return prev_frame;
}

d1269 1
a1269 1
	frame_obstack_zalloc (SIZEOF_FRAME_SAVED_REGS);
d1294 2
a1295 1
  fi->extra_info = frame_obstack_zalloc (size);
a1302 1
  gdb_assert (frame->next != NULL);
a1313 68
deprecated_set_frame_saved_regs_hack (struct frame_info *frame,
				      CORE_ADDR *saved_regs)
{
  frame->saved_regs = saved_regs;
}

void
deprecated_set_frame_extra_info_hack (struct frame_info *frame,
				      struct frame_extra_info *extra_info)
{
  frame->extra_info = extra_info;
}

void
deprecated_set_frame_next_hack (struct frame_info *fi,
				struct frame_info *next)
{
  fi->next = next;
}

void
deprecated_set_frame_prev_hack (struct frame_info *fi,
				struct frame_info *prev)
{
  fi->prev = prev;
}

struct context *
deprecated_get_frame_context (struct frame_info *fi)
{
  return fi->context;
}

void
deprecated_set_frame_context (struct frame_info *fi,
			      struct context *context)
{
  fi->context = context;
}

struct frame_info *
deprecated_frame_xmalloc (void)
{
  struct frame_info *frame = XMALLOC (struct frame_info);
  memset (frame, 0, sizeof (struct frame_info));
  return frame;
}

struct frame_info *
deprecated_frame_xmalloc_with_cleanup (long sizeof_saved_regs,
				       long sizeof_extra_info)
{
  struct frame_info *frame = deprecated_frame_xmalloc ();
  make_cleanup (xfree, frame);
  if (sizeof_saved_regs > 0)
    {
      frame->saved_regs = xcalloc (1, sizeof_saved_regs);
      make_cleanup (xfree, frame->saved_regs);
    }
  if (sizeof_extra_info > 0)
    {
      frame->extra_info = xcalloc (1, sizeof_extra_info);
      make_cleanup (xfree, frame->extra_info);
    }
  return frame;
}

void
a1316 17

  /* FIXME: cagney/2003-01-19: This command needs a rename.  Suggest
     `set backtrace {past,beyond,...}-main'.  Also suggest adding `set
     backtrace ...-start' to control backtraces past start.  The
     problem with `below' is that it stops the `up' command.  */

  add_setshow_boolean_cmd ("backtrace-below-main", class_obscure,
			   &backtrace_below_main, "\
Set whether backtraces should continue past \"main\".\n\
Normally the caller of \"main\" is not of interest, so GDB will terminate\n\
the backtrace at \"main\".  Set this variable if you need to see the rest\n\
of the stack trace.", "\
Show whether backtraces should continue past \"main\".\n\
Normally the caller of \"main\" is not of interest, so GDB will terminate\n\
the backtrace at \"main\".  Set this variable if you need to see the rest\n\
of the stack trace.",
			   NULL, NULL, &setlist, &showlist);
@


1.17.2.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@a41 4
/* Flag to control debugging.  */

static int frame_debug;

d144 11
d310 1
a310 1
void
d608 2
a609 3
     DEPRECATED_FRAME_INIT_SAVED_REGS method should be using this
     function.  */
  gdb_assert (DEPRECATED_FRAME_INIT_SAVED_REGS_P ());
d613 1
a613 1
    DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d794 1
a794 1
  gdb_assert (DEPRECATED_FRAME_INIT_SAVED_REGS_P ());
d830 1
a830 1
	  DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d904 2
a905 2
  if (DEPRECATED_INIT_EXTRA_FRAME_INFO_P ())
    DEPRECATED_INIT_EXTRA_FRAME_INFO (0, fi);
d1036 2
a1037 2
     after DEPRECATED_INIT_EXTRA_FRAME_INFO and come up with a simple
     way to express what goes on here.
d1039 9
a1047 9
     DEPRECATED_INIT_EXTRA_FRAME_INFO is called from two places:
     create_new_frame (where the PC is already set up) and here (where
     it isn't).  DEPRECATED_INIT_FRAME_PC is only called from here,
     always after DEPRECATED_INIT_EXTRA_FRAME_INFO.

     The catch is the MIPS, where DEPRECATED_INIT_EXTRA_FRAME_INFO
     requires the PC value (which hasn't been set yet).  Some other
     machines appear to require DEPRECATED_INIT_EXTRA_FRAME_INFO
     before they can do DEPRECATED_INIT_FRAME_PC.  Phoo.
d1054 1
a1054 1
     DEPRECATED_INIT_EXTRA_FRAME_INFO, one possible scheme:
d1064 7
a1070 8
     INIT_PREV_FRAME(fromleaf, prev) Replace
     DEPRECATED_INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC.
     This should also return a flag saying whether to keep the new
     frame, or whether to discard it, because on some machines (e.g.
     mips) it is really awkward to have FRAME_CHAIN_VALID called
     BEFORE DEPRECATED_INIT_EXTRA_FRAME_INFO (there is no good way to
     get information deduced in FRAME_CHAIN_VALID into the extra
     fields of the new frame).  std_frame_pc(fromleaf, prev)
d1107 2
a1108 2
  if (DEPRECATED_INIT_EXTRA_FRAME_INFO_P ())
    DEPRECATED_INIT_EXTRA_FRAME_INFO (fromleaf, prev);
d1226 1
a1226 6
    {
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - inside main func.\n");
      return NULL;
    }
d1233 1
a1233 4
  /* If we're inside the entry file, it isn't valid.  Don't apply this
     test to a dummy frame - dummy frame PC's typically land in the
     entry file.  Don't apply this test to the sentinel frame.
     Sentinel frames should always be allowed to unwind.  */
d1241 1
a1241 6
  if (next_frame->type != DUMMY_FRAME && next_frame->level >= 0
      && inside_entry_file (get_frame_pc (next_frame)))
    {
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - inside entry file\n");
a1242 18
    }

  /* If we're already inside the entry function for the main objfile,
     then it isn't valid.  Don't apply this test to a dummy frame -
     dummy frame PC's typically land in the entry func.  Don't apply
     this test to the sentinel frame.  Sentinel frames should always
     be allowed to unwind.  */
  /* NOTE: cagney/2003-02-25: Don't enable until someone has found
     hard evidence that this is needed.  */
  if (0
      && next_frame->type != DUMMY_FRAME && next_frame->level >= 0
      && inside_entry_func (get_frame_pc (next_frame)))
    {
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - inside entry func\n");
      return NULL;
    }
d1250 1
a1250 1
       || DEPRECATED_INIT_EXTRA_FRAME_INFO_P ()
d1253 1
a1253 7
    {
      prev_frame = legacy_get_prev_frame (next_frame);
      if (frame_debug && prev_frame == NULL)
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - legacy_get_prev_frame NULL.\n");
      return prev_frame;
    }
d1277 1
a1277 2
     DEPRECATED_INIT_EXTRA_FRAME_INFO) and hence the call order
     doesn't matter.
d1286 3
a1288 8
    {
      /* The allocated PREV_FRAME will be reclaimed when the frame
	 obstack is next purged.  */
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - unwound PC zero\n");
      return NULL;
    }
d1298 5
a1302 14
  /* FIXME: cagney/2003-03-04: The below call isn't right.  It should
     instead be doing something like "prev_frame -> unwind -> id
     (next_frame, & prev_frame -> unwind_cache, & prev_frame -> id)"
     but that requires more extensive (pending) changes.  */
  next_frame->unwind->id (next_frame, &next_frame->unwind_cache,
			  &prev_frame->id);
  /* Check that the unwound ID is valid.  As of 2003-02-24 the x86-64
     was returning an invalid frame ID when trying to do an unwind a
     sentinel frame that belonged to a frame dummy.  */
  if (!frame_id_p (prev_frame->id))
    {
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "Outermost frame - unwound frame ID invalid\n");
d1304 2
a1305 21
    }
  /* Check that the new frame isn't inner to (younger, below, next)
     the old frame.  If that happens the frame unwind is going
     backwards.  */
  /* FIXME: cagney/2003-02-25: Ignore the sentinel frame since that
     doesn't have a valid frame ID.  Should instead set the sentinel
     frame's frame ID to a `sentinel'.  Leave it until after the
     switch to storing the frame ID, instead of the frame base, in the
     frame object.  */
  if (next_frame->level >= 0
      && frame_id_inner (prev_frame->id, get_frame_id (next_frame)))
    error ("Unwound frame inner-to selected frame (corrupt stack?)");
  /* Note that, due to frameless functions, the stronger test of the
     new frame being outer to the old frame can't be used - frameless
     functions differ by only their PC value.  */

  /* FIXME: cagney/2002-12-18: Instead of this hack, should only store
     the frame ID in PREV_FRAME.  Unfortunatly, some architectures
     (HP/UX) still reply on EXTRA_FRAME_INFO and, hence, still poke at
     the "struct frame_info" object directly.  */
  prev_frame->frame = prev_frame->id.base;
d1316 3
a1318 4
     this code path and rely on the below call to
     DEPRECATED_INIT_EXTRA_FRAME_INFO to initialize the inner-most
     frame.  */
  if (DEPRECATED_INIT_EXTRA_FRAME_INFO_P ())
d1321 1
a1321 1
      DEPRECATED_INIT_EXTRA_FRAME_INFO (0, prev_frame);
d1396 1
a1396 1
   that do not yet implement DEPRECATED_FRAME_INIT_SAVED_REGS.  */
d1439 1
a1440 6
  /* While we're at it, update this frame's cached PC value, found in
     the next frame.  Oh, for the day when "struct frame_info" is
     opaque and this hack on hack can go.  */
  gdb_assert (frame->next != NULL);
  frame->next->pc_unwind_cache = pc;
  frame->next->pc_unwind_cache_p = 1;
a1538 7


  /* Debug this files internals. */
  add_show_from_set (add_set_cmd ("frame", class_maintenance, var_zinteger,
				  &frame_debug, "Set frame debugging.\n\
When non-zero, frame specific internal debugging is enabled.", &setdebuglist),
		     &showdebuglist);
@


1.17.2.6
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a38 1
#include "frame-base.h"
a41 91
/* We keep a cache of stack frames, each of which is a "struct
   frame_info".  The innermost one gets allocated (in
   wait_for_inferior) each time the inferior stops; current_frame
   points to it.  Additional frames get allocated (in get_prev_frame)
   as needed, and are chained through the next and prev fields.  Any
   time that the frame cache becomes invalid (most notably when we
   execute something, but also if we change how we interpret the
   frames (e.g. "set heuristic-fence-post" in mips-tdep.c, or anything
   which reads new symbols)), we should call reinit_frame_cache.  */

struct frame_info
{
  /* Level of this frame.  The inner-most (youngest) frame is at level
     0.  As you move towards the outer-most (oldest) frame, the level
     increases.  This is a cached value.  It could just as easily be
     computed by counting back from the selected frame to the inner
     most frame.  */
  /* NOTE: cagney/2002-04-05: Perhaphs a level of ``-1'' should be
     reserved to indicate a bogus frame - one that has been created
     just to keep GDB happy (GDB always needs a frame).  For the
     moment leave this as speculation.  */
  int level;

  /* The frame's type.  */
  /* FIXME: cagney/2003-04-02: Should instead be returning
     ->unwind->type.  Unfortunatly, legacy code is still explicitly
     setting the type using the method deprecated_set_frame_type.
     Eliminate that method and this field can be eliminated.  */
  enum frame_type type;

  /* For each register, address of where it was saved on entry to the
     frame, or zero if it was not saved on entry to this frame.  This
     includes special registers such as pc and fp saved in special
     ways in the stack frame.  The SP_REGNUM is even more special, the
     address here is the sp for the previous frame, not the address
     where the sp was saved.  */
  /* Allocated by frame_saved_regs_zalloc () which is called /
     initialized by DEPRECATED_FRAME_INIT_SAVED_REGS(). */
  CORE_ADDR *saved_regs;	/*NUM_REGS + NUM_PSEUDO_REGS*/

  /* Anything extra for this structure that may have been defined in
     the machine dependent files. */
  /* Allocated by frame_extra_info_zalloc () which is called /
     initialized by DEPRECATED_INIT_EXTRA_FRAME_INFO */
  struct frame_extra_info *extra_info;

  /* If dwarf2 unwind frame informations is used, this structure holds
     all related unwind data.  */
  struct context *context;

  /* The frame's low-level unwinder and corresponding cache.  The
     low-level unwinder is responsible for unwinding register values
     for the previous frame.  The low-level unwind methods are
     selected based on the presence, or otherwize, of register unwind
     information such as CFI.  */
  void *prologue_cache;
  const struct frame_unwind *unwind;

  /* Cached copy of the previous frame's resume address.  */
  struct {
    int p;
    CORE_ADDR value;
  } prev_pc;
  
  /* Cached copy of the previous frame's function address.  */
  struct
  {
    CORE_ADDR addr;
    int p;
  } prev_func;
  
  /* This frame's ID.  */
  struct
  {
    int p;
    struct frame_id value;
  } this_id;
  
  /* The frame's high-level base methods, and corresponding cache.
     The high level base methods are selected based on the frame's
     debug info.  */
  const struct frame_base *base;
  void *base_cache;

  /* Pointers to the next (down, inner, younger) and previous (up,
     outer, older) frame_info's in the frame cache.  */
  struct frame_info *next; /* down, inner, younger */
  int prev_p;
  struct frame_info *prev; /* up, outer, older */
};

a49 71
static void
fprint_frame_id (struct ui_file *file, struct frame_id id)
{
  fprintf_unfiltered (file, "{stack=0x%s,code=0x%s}",
		      paddr_nz (id.stack_addr),
		      paddr_nz (id.code_addr));
}

static void
fprint_frame_type (struct ui_file *file, enum frame_type type)
{
  switch (type)
    {
    case UNKNOWN_FRAME:
      fprintf_unfiltered (file, "UNKNOWN_FRAME");
      return;
    case NORMAL_FRAME:
      fprintf_unfiltered (file, "NORMAL_FRAME");
      return;
    case DUMMY_FRAME:
      fprintf_unfiltered (file, "DUMMY_FRAME");
      return;
    case SIGTRAMP_FRAME:
      fprintf_unfiltered (file, "SIGTRAMP_FRAME");
      return;
    default:
      fprintf_unfiltered (file, "<unknown type>");
      return;
    };
}

static void
fprint_frame (struct ui_file *file, struct frame_info *fi)
{
  if (fi == NULL)
    {
      fprintf_unfiltered (file, "<NULL frame>");
      return;
    }
  fprintf_unfiltered (file, "{");
  fprintf_unfiltered (file, "level=%d", fi->level);
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "type=");
  fprint_frame_type (file, fi->type);
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "unwind=");
  if (fi->unwind != NULL)
    gdb_print_host_address (fi->unwind, file);
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "pc=");
  if (fi->next != NULL && fi->next->prev_pc.p)
    fprintf_unfiltered (file, "0x%s", paddr_nz (fi->next->prev_pc.value));
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "id=");
  if (fi->this_id.p)
    fprint_frame_id (file, fi->this_id.value);
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, ",");
  fprintf_unfiltered (file, "func=");
  if (fi->next != NULL && fi->next->prev_func.p)
    fprintf_unfiltered (file, "0x%s", paddr_nz (fi->next->prev_func.addr));
  else
    fprintf_unfiltered (file, "<unknown>");
  fprintf_unfiltered (file, "}");
}

d60 1
a60 1
  if (!fi->this_id.p)
d62 4
a65 26
      gdb_assert (!legacy_frame_p (current_gdbarch));
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog, "{ get_frame_id (fi=%d) ",
			    fi->level);
      /* Find the unwinder.  */
      if (fi->unwind == NULL)
	{
	  fi->unwind = frame_unwind_find_by_pc (current_gdbarch,
						get_frame_pc (fi));
	  /* FIXME: cagney/2003-04-02: Rather than storing the frame's
	     type in the frame, the unwinder's type should be returned
	     directly.  Unfortunatly, legacy code, called by
	     legacy_get_prev_frame, explicitly set the frames type
	     using the method deprecated_set_frame_type().  */
	  gdb_assert (fi->unwind->type != UNKNOWN_FRAME);
	  fi->type = fi->unwind->type;
	}
      /* Find THIS frame's ID.  */
      fi->unwind->this_id (fi->next, &fi->prologue_cache, &fi->this_id.value);
      fi->this_id.p = 1;
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame_id (gdb_stdlog, fi->this_id.value);
	  fprintf_unfiltered (gdb_stdlog, " }\n");
	}
a66 1
  return fi->this_id.value;
d72 1
a72 1
frame_id_build (CORE_ADDR stack_addr, CORE_ADDR code_addr)
d75 2
a76 2
  id.stack_addr = stack_addr;
  id.code_addr = code_addr;
d83 2
a84 10
  int p;
  /* The .code can be NULL but the .stack cannot.  */
  p = (l.stack_addr != 0);
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ frame_id_p (l=");
      fprint_frame_id (gdb_stdlog, l);
      fprintf_unfiltered (gdb_stdlog, ") -> %d }\n", p);
    }
  return p;
d90 6
a95 27
  int eq;
  if (l.stack_addr == 0 || r.stack_addr == 0)
    /* Like a NaN, if either ID is invalid, the result is false.  */
    eq = 0;
  else if (l.stack_addr != r.stack_addr)
    /* If .stack addresses are different, the frames are different.  */
    eq = 0;
  else if (l.code_addr == 0 || r.code_addr == 0)
    /* A zero code addr is a wild card, always succeed.  */
    eq = 1;
  else if (l.code_addr == r.code_addr)
    /* The .stack and .code are identical, the ID's are identical.  */
    eq = 1;
  else
    /* FIXME: cagney/2003-04-06: This should be zero.  Can't yet do
       this because most frame ID's are not being initialized
       correctly.  */
    eq = 1;
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ frame_id_eq (l=");
      fprint_frame_id (gdb_stdlog, l);
      fprintf_unfiltered (gdb_stdlog, ",r=");
      fprint_frame_id (gdb_stdlog, r);
      fprintf_unfiltered (gdb_stdlog, ") -> %d }\n", eq);
    }
  return eq;
d101 5
a105 19
  int inner;
  if (l.stack_addr == 0 || r.stack_addr == 0)
    /* Like NaN, any operation involving an invalid ID always fails.  */
    inner = 0;
  else
    /* Only return non-zero when strictly inner than.  Note that, per
       comment in "frame.h", there is some fuzz here.  Frameless
       functions are not strictly inner than (same .stack but
       different .code).  */
    inner = INNER_THAN (l.stack_addr, r.stack_addr);
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ frame_id_inner (l=");
      fprint_frame_id (gdb_stdlog, l);
      fprintf_unfiltered (gdb_stdlog, ",r=");
      fprint_frame_id (gdb_stdlog, r);
      fprintf_unfiltered (gdb_stdlog, ") -> %d }\n", inner);
    }
  return inner;
d138 1
a138 57
frame_pc_unwind (struct frame_info *this_frame)
{
  if (!this_frame->prev_pc.p)
    {
      CORE_ADDR pc;
      if (gdbarch_unwind_pc_p (current_gdbarch))
	{
	  /* The right way.  The `pure' way.  The one true way.  This
	     method depends solely on the register-unwind code to
	     determine the value of registers in THIS frame, and hence
	     the value of this frame's PC (resume address).  A typical
	     implementation is no more than:
	   
	     frame_unwind_register (this_frame, ISA_PC_REGNUM, buf);
	     return extract_address (buf, size of ISA_PC_REGNUM);

	     Note: this method is very heavily dependent on a correct
	     register-unwind implementation, it pays to fix that
	     method first; this method is frame type agnostic, since
	     it only deals with register values, it works with any
	     frame.  This is all in stark contrast to the old
	     FRAME_SAVED_PC which would try to directly handle all the
	     different ways that a PC could be unwound.  */
	  pc = gdbarch_unwind_pc (current_gdbarch, this_frame);
	}
      else if (this_frame->level < 0)
	{
	  /* FIXME: cagney/2003-03-06: Old code and and a sentinel
             frame.  Do like was always done.  Fetch the PC's value
             direct from the global registers array (via read_pc).
             This assumes that this frame belongs to the current
             global register cache.  The assumption is dangerous.  */
	  pc = read_pc ();
	}
      else if (DEPRECATED_FRAME_SAVED_PC_P ())
	{
	  /* FIXME: cagney/2003-03-06: Old code, but not a sentinel
             frame.  Do like was always done.  Note that this method,
             unlike unwind_pc(), tries to handle all the different
             frame cases directly.  It fails.  */
	  pc = DEPRECATED_FRAME_SAVED_PC (this_frame);
	}
      else
	internal_error (__FILE__, __LINE__, "No gdbarch_unwind_pc method");
      this_frame->prev_pc.value = pc;
      this_frame->prev_pc.p = 1;
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "{ frame_pc_unwind (this_frame=%d) -> 0x%s }\n",
			    this_frame->level,
			    paddr_nz (this_frame->prev_pc.value));
    }
  return this_frame->prev_pc.value;
}

CORE_ADDR
frame_func_unwind (struct frame_info *fi)
d140 1
a140 1
  if (!fi->prev_func.p)
d142 2
a143 6
      fi->prev_func.p = 1;
      fi->prev_func.addr = get_pc_function_start (frame_pc_unwind (fi));
      if (frame_debug)
	fprintf_unfiltered (gdb_stdlog,
			    "{ frame_func_unwind (fi=%d) -> 0x%s }\n",
			    fi->level, paddr_nz (fi->prev_func.addr));
d145 1
a145 14
  return fi->prev_func.addr;
}

CORE_ADDR
get_frame_func (struct frame_info *fi)
{
  return frame_func_unwind (fi->next);
}

static int
do_frame_unwind_register (void *src, int regnum, void *buf)
{
  frame_unwind_register (src, regnum, buf);
  return 1;
d149 1
a149 1
frame_pop (struct frame_info *this_frame)
d151 7
a157 35
  struct regcache *scratch_regcache;
  struct cleanup *cleanups;

  if (DEPRECATED_POP_FRAME_P ())
    {
      /* A legacy architecture that has implemented a custom pop
	 function.  All new architectures should instead be using the
	 generic code below.  */
      DEPRECATED_POP_FRAME;
    }
  else
    {
      /* Make a copy of all the register values unwound from this
	 frame.  Save them in a scratch buffer so that there isn't a
	 race betweening trying to extract the old values from the
	 current_regcache while, at the same time writing new values
	 into that same cache.  */
      struct regcache *scratch = regcache_xmalloc (current_gdbarch);
      struct cleanup *cleanups = make_cleanup_regcache_xfree (scratch);
      regcache_save (scratch, do_frame_unwind_register, this_frame);
      /* FIXME: cagney/2003-03-16: It should be possible to tell the
         target's register cache that it is about to be hit with a
         burst register transfer and that the sequence of register
         writes should be batched.  The pair target_prepare_to_store()
         and target_store_registers() kind of suggest this
         functionality.  Unfortunatly, they don't implement it.  Their
         lack of a formal definition can lead to targets writing back
         bogus values (arguably a bug in the target code mind).  */
      /* Now copy those saved registers into the current regcache.
         Here, regcache_cpy() calls regcache_restore().  */
      regcache_cpy (current_regcache, scratch);
      do_cleanups (cleanups);
    }
  /* We've made right mess of GDB's local state, just discard
     everything.  */
a167 7
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "{ frame_register_unwind (frame=%d,regnum=\"%s\",...) ",
			  frame->level, frame_map_regnum_to_name (regnum));
    }

d182 3
a184 40
  /* Find the unwinder.  */
  if (frame->unwind == NULL)
    {
      frame->unwind = frame_unwind_find_by_pc (current_gdbarch,
					       get_frame_pc (frame));
      /* FIXME: cagney/2003-04-02: Rather than storing the frame's
	 type in the frame, the unwinder's type should be returned
	 directly.  Unfortunatly, legacy code, called by
	 legacy_get_prev_frame, explicitly set the frames type using
	 the method deprecated_set_frame_type().  */
      gdb_assert (frame->unwind->type != UNKNOWN_FRAME);
      frame->type = frame->unwind->type;
    }

  /* Ask this frame to unwind its register.  See comment in
     "frame-unwind.h" for why NEXT frame and this unwind cace are
     passed in.  */
  frame->unwind->prev_register (frame->next, &frame->prologue_cache, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "->");
      fprintf_unfiltered (gdb_stdlog, " *optimizedp=%d", (*optimizedp));
      fprintf_unfiltered (gdb_stdlog, " *lvalp=%d", (int) (*lvalp));
      fprintf_unfiltered (gdb_stdlog, " *addrp=0x%s", paddr_nz ((*addrp)));
      fprintf_unfiltered (gdb_stdlog, " *bufferp=");
      if (bufferp == NULL)
	fprintf_unfiltered (gdb_stdlog, "<NULL>");
      else
	{
	  int i;
	  const char *buf = bufferp;
	  fprintf_unfiltered (gdb_stdlog, "[");
	  for (i = 0; i < register_size (current_gdbarch, regnum); i++)
	    fprintf_unfiltered (gdb_stdlog, "%02x", buf[i]);
	  fprintf_unfiltered (gdb_stdlog, "]");
	}
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }
d203 1
a203 1
  if (DEPRECATED_GET_SAVED_REGISTER_P ())
d205 1
a205 2
      DEPRECATED_GET_SAVED_REGISTER (bufferp, optimizedp, addrp, frame,
				     regnum, lvalp);
d333 17
d434 1
a434 1
  frame->prologue_cache = sentinel_frame_cache (regcache);
d440 6
a445 10
  /* Make the sentinel frame's ID valid, but invalid.  That way all
     comparisons with it should fail.  */
  frame->this_id.p = 1;
  frame->this_id.value = null_frame_id;
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ create_sentinel_frame (...) -> ");
      fprint_frame (gdb_stdlog, frame);
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }
d501 2
a502 5
  /* First check, and report, the lack of registers.  Having GDB
     report "No stack!" or "No memory" when the target doesn't even
     have registers is very confusing.  Besides, "printcmd.exp"
     explicitly checks that ``print $pc'' with no registers prints "No
     registers".  */
a504 2
  if (!target_has_stack)
    error ("No stack.");
d570 1
a570 1
      s = find_pc_symtab (get_frame_pc (fi));
d586 7
a592 13
legacy_saved_regs_prev_register (struct frame_info *next_frame,
				 void **this_prologue_cache,
				 int regnum, int *optimizedp,
				 enum lval_type *lvalp, CORE_ADDR *addrp,
				 int *realnump, void *bufferp)
{
  /* HACK: New code is passed the next frame and this cache.
     Unfortunatly, old code expects this frame.  Since this is a
     backward compatibility hack, cheat by walking one level along the
     prologue chain to the frame the old code expects.

     Do not try this at home.  Professional driver, closed course.  */
  struct frame_info *frame = next_frame->prev;
d594 5
d636 1
a636 1
	      void **regs = (*this_prologue_cache);
d642 1
a642 1
		  (*this_prologue_cache) = regs;
d662 6
a667 5
  /* No luck.  Assume this and the next frame have the same register
     value.  Pass the unwind request down the frame chain to the next
     frame.  Hopefully that frame will find the register's location.  */
  frame_register_unwind (next_frame, regnum, optimizedp, lvalp, addrp,
			 realnump, bufferp);
d670 7
d678 58
a735 7
legacy_saved_regs_this_id (struct frame_info *next_frame,
			   void **this_prologue_cache,
			   struct frame_id *id)
{
  /* legacy_get_prev_frame() always sets ->this_id.p, hence this is
     never needed.  */
  internal_error (__FILE__, __LINE__, "legacy_saved_regs_this_id() called");
d738 13
a750 5
const struct frame_unwind legacy_saved_regs_unwinder = {
  /* Not really.  It gets overridden by legacy_get_prev_frame.  */
  UNKNOWN_FRAME,
  legacy_saved_regs_this_id,
  legacy_saved_regs_prev_register
d752 1
a752 1
const struct frame_unwind *legacy_saved_regs_unwind = &legacy_saved_regs_unwinder;
d755 1
a755 1
/* Function: deprecated_generic_get_saved_register
d757 1
a757 1
   target format) contents in *RAW_BUFFER.
d773 4
a890 7
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "{ create_new_frame (addr=0x%s, pc=0x%s) ",
			  paddr_nz (addr), paddr_nz (pc));
    }

d893 2
d896 1
a896 12

  /* Select/initialize both the unwind function and the frame's type
     based on the PC.  */
  fi->unwind = frame_unwind_find_by_pc (current_gdbarch, pc);
  if (fi->unwind->type != UNKNOWN_FRAME)
    fi->type = fi->unwind->type;
  else
    fi->type = frame_type_from_pc (pc);

  fi->this_id.p = 1;
  deprecated_update_frame_base_hack (fi, addr);
  deprecated_update_frame_pc_hack (fi, pc);
d901 2
a902 6
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, fi);
      fprintf_unfiltered (gdb_stdlog, " }\n");
    }
d907 3
a909 3
/* Return the frame that THIS_FRAME calls (NULL if THIS_FRAME is the
   innermost frame).  Be careful to not fall off the bottom of the
   frame chain and onto the sentinel frame.  */
d912 1
a912 1
get_next_frame (struct frame_info *this_frame)
d914 2
a915 2
  if (this_frame->level > 0)
    return this_frame->next;
a931 2
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog, "{ flush_cached_frames () }\n");
d952 1
a952 1
legacy_get_prev_frame (struct frame_info *this_frame)
a957 168
  /* Don't frame_debug print legacy_get_prev_frame() here, just
     confuses the output.  */

  /* Allocate the new frame.

     There is no reason to worry about memory leaks, should the
     remainder of the function fail.  The allocated memory will be
     quickly reclaimed when the frame cache is flushed, and the `we've
     been here before' check, in get_prev_frame will stop repeated
     memory allocation calls.  */
  prev = FRAME_OBSTACK_ZALLOC (struct frame_info);
  prev->level = this_frame->level + 1;

  /* Do not completly wire it in to the frame chain.  Some (bad) code
     in INIT_FRAME_EXTRA_INFO tries to look along frame->prev to pull
     some fancy tricks (of course such code is, by definition,
     recursive).
  
     On the other hand, methods, such as get_frame_pc() and
     get_frame_base() rely on being able to walk along the frame
     chain.  Make certain that at least they work by providing that
     link.  Of course things manipulating prev can't go back.  */
  prev->next = this_frame;

  /* NOTE: cagney/2002-11-18: Should have been correctly setting the
     frame's type here, before anything else, and not last, at the
     bottom of this function.  The various
     DEPRECATED_INIT_EXTRA_FRAME_INFO, DEPRECATED_INIT_FRAME_PC,
     DEPRECATED_INIT_FRAME_PC_FIRST and
     DEPRECATED_FRAME_INIT_SAVED_REGS methods are full of work-arounds
     that handle the frame not being correctly set from the start.
     Unfortunatly those same work-arounds rely on the type defaulting
     to NORMAL_FRAME.  Ulgh!  The new frame code does not have this
     problem.  */
  prev->type = UNKNOWN_FRAME;

  /* A legacy frame's ID is always computed here.  Mark it as valid.  */
  prev->this_id.p = 1;

  /* Handle sentinel frame unwind as a special case.  */
  if (this_frame->level < 0)
    {
      /* Try to unwind the PC.  If that doesn't work, assume we've reached
	 the oldest frame and simply return.  Is there a better sentinal
	 value?  The unwound PC value is then used to initialize the new
	 previous frame's type.

	 Note that the pc-unwind is intentionally performed before the
	 frame chain.  This is ok since, for old targets, both
	 frame_pc_unwind (nee, DEPRECATED_FRAME_SAVED_PC) and
	 DEPRECATED_FRAME_CHAIN()) assume THIS_FRAME's data structures
	 have already been initialized (using
	 DEPRECATED_INIT_EXTRA_FRAME_INFO) and hence the call order
	 doesn't matter.
	 
	 By unwinding the PC first, it becomes possible to, in the case of
	 a dummy frame, avoid also unwinding the frame ID.  This is
	 because (well ignoring the PPC) a dummy frame can be located
	 using THIS_FRAME's frame ID.  */
      
      deprecated_update_frame_pc_hack (prev, frame_pc_unwind (this_frame));
      if (get_frame_pc (prev) == 0)
	{
	  /* The allocated PREV_FRAME will be reclaimed when the frame
	     obstack is next purged.  */
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // unwound legacy PC zero }\n");
	    }
	  return NULL;
	}

      /* Set the unwind functions based on that identified PC.  Ditto
         for the "type" but strongly prefer the unwinder's frame type.  */
      prev->unwind = frame_unwind_find_by_pc (current_gdbarch,
					      get_frame_pc (prev));
      if (prev->unwind->type == UNKNOWN_FRAME)
	prev->type = frame_type_from_pc (get_frame_pc (prev));
      else
	prev->type = prev->unwind->type;

      /* Find the prev's frame's ID.  */
      if (prev->type == DUMMY_FRAME
	  && gdbarch_unwind_dummy_id_p (current_gdbarch))
	{
	  /* When unwinding a normal frame, the stack structure is
	     determined by analyzing the frame's function's code (be
	     it using brute force prologue analysis, or the dwarf2
	     CFI).  In the case of a dummy frame, that simply isn't
	     possible.  The The PC is either the program entry point,
	     or some random address on the stack.  Trying to use that
	     PC to apply standard frame ID unwind techniques is just
	     asking for trouble.  */
	  /* Assume call_function_by_hand(), via SAVE_DUMMY_FRAME_TOS,
	     previously saved the dummy frame's ID.  Things only work
	     if the two return the same value.  */
	  gdb_assert (SAVE_DUMMY_FRAME_TOS_P ());
	  /* Use an architecture specific method to extract the prev's
	     dummy ID from the next frame.  Note that this method uses
	     frame_register_unwind to obtain the register values
	     needed to determine the dummy frame's ID.  */
	  prev->this_id.value = gdbarch_unwind_dummy_id (current_gdbarch,
							 this_frame);
	}
      else
	{
	  /* We're unwinding a sentinel frame, the PC of which is
	     pointing at a stack dummy.  Fake up the dummy frame's ID
	     using the same sequence as is found a traditional
	     unwinder.  Once all architectures supply the
	     unwind_dummy_id method, this code can go away.  */
	  prev->this_id.value = frame_id_build (read_fp (), read_pc ());
	}

      /* Check that the unwound ID is valid.  */
      if (!frame_id_p (prev->this_id.value))
	{
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // unwound legacy ID invalid }\n");
	    }
	  return NULL;
	}

      /* Check that the new frame isn't inner to (younger, below,
	 next) the old frame.  If that happens the frame unwind is
	 going backwards.  */
      /* FIXME: cagney/2003-02-25: Ignore the sentinel frame since
	 that doesn't have a valid frame ID.  Should instead set the
	 sentinel frame's frame ID to a `sentinel'.  Leave it until
	 after the switch to storing the frame ID, instead of the
	 frame base, in the frame object.  */

      /* Link it in.  */
      this_frame->prev = prev;

      /* FIXME: cagney/2002-01-19: This call will go away.  Instead of
	 initializing extra info, all frames will use the frame_cache
	 (passed to the unwind functions) to store additional frame
	 info.  Unfortunatly legacy targets can't use
	 legacy_get_prev_frame() to unwind the sentinel frame and,
	 consequently, are forced to take this code path and rely on
	 the below call to DEPRECATED_INIT_EXTRA_FRAME_INFO to
	 initialize the inner-most frame.  */
      if (DEPRECATED_INIT_EXTRA_FRAME_INFO_P ())
	{
	  DEPRECATED_INIT_EXTRA_FRAME_INFO (0, prev);
	}

      if (prev->type == NORMAL_FRAME)
	prev->this_id.value.code_addr
	  = get_pc_function_start (prev->this_id.value.code_addr);

      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, prev);
	  fprintf_unfiltered (gdb_stdlog, " } // legacy innermost frame\n");
	}
      return prev;
    }

d960 1
a960 1
  gdb_assert (this_frame->level >= 0);
d969 1
a969 1
     frame.  This macro will set FROMLEAF if THIS_FRAME is a frameless
d971 1
a971 1
  if (this_frame->level == 0)
d976 1
a976 1
    fromleaf = FRAMELESS_FUNCTION_INVOCATION (this_frame);
d987 1
a987 1
    address = get_frame_base (this_frame);
d1005 2
a1006 2
      gdb_assert (DEPRECATED_FRAME_CHAIN_P ());
      address = DEPRECATED_FRAME_CHAIN (this_frame);
d1008 2
a1009 11
      if (!legacy_frame_chain_valid (address, this_frame))
	{
	  if (frame_debug)
	    {
	      fprintf_unfiltered (gdb_stdlog, "-> ");
	      fprint_frame (gdb_stdlog, NULL);
	      fprintf_unfiltered (gdb_stdlog,
				  " // legacy frame chain invalid }\n");
	    }
	  return NULL;
	}
d1012 4
a1015 10
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog,
			      " // legacy frame chain NULL }\n");
	}
      return NULL;
    }
d1017 10
a1026 3
  /* Link in the already allocated prev frame.  */
  this_frame->prev = prev;
  deprecated_update_frame_base_hack (prev, address);
d1062 4
a1065 5
     mips) it is really awkward to have DEPRECATED_FRAME_CHAIN_VALID
     called BEFORE DEPRECATED_INIT_EXTRA_FRAME_INFO (there is no good
     way to get information deduced in DEPRECATED_FRAME_CHAIN_VALID
     into the extra fields of the new frame).  std_frame_pc(fromleaf,
     prev)
d1086 1
a1086 1
     somewhere (THIS_FRAME) to store all the info needed to construct
d1091 7
a1097 8
     The irony here though, is that DEPRECATED_FRAME_CHAIN(), at least
     for a more up-to-date architecture, always calls
     FRAME_SAVED_PC(), and FRAME_SAVED_PC() computes the PC but
     without first needing the frame!  Instead of the convolution
     below, we could have simply called FRAME_SAVED_PC() and been done
     with it!  Note that FRAME_SAVED_PC() is being superseed by
     frame_pc_unwind() and that function does have somewhere to cache
     that PC value.  */
d1100 1
a1100 3
    deprecated_update_frame_pc_hack (prev,
				     DEPRECATED_INIT_FRAME_PC_FIRST (fromleaf,
								     prev));
d1109 1
a1109 3
    deprecated_update_frame_pc_hack (prev,
				     DEPRECATED_INIT_FRAME_PC (fromleaf,
							       prev));
d1113 4
a1116 5
     check this in DEPRECATED_FRAME_CHAIN or thereabouts, but it seems
     like there is no reason this can't be an architecture-independent
     check.  */
  if (get_frame_base (prev) == get_frame_base (this_frame)
      && get_frame_pc (prev) == get_frame_pc (this_frame))
d1118 1
a1118 1
      this_frame->prev = NULL;
a1119 7
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog,
			      " // legacy this.id == prev.id }\n");
	}
d1127 1
a1127 19
  prev->unwind = frame_unwind_find_by_pc (current_gdbarch,
					  get_frame_pc (prev));

  /* If the unwinder provides a frame type, use it.  Otherwize
     continue on to that heuristic mess.  */
  if (prev->unwind->type != UNKNOWN_FRAME)
    {
      prev->type = prev->unwind->type;
      if (prev->type == NORMAL_FRAME)
	prev->this_id.value.code_addr
	  = get_pc_function_start (prev->this_id.value.code_addr);
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, prev);
	  fprintf_unfiltered (gdb_stdlog, " } // legacy with unwound type\n");
	}
      return prev;
    }
d1139 2
a1140 2
	  ? DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (prev), 0, 0)
	  : pc_in_dummy_frame (get_frame_pc (prev))))
d1151 2
a1152 2
      find_pc_partial_function (get_frame_pc (prev), &name, NULL, NULL);
      if (PC_IN_SIGTRAMP (get_frame_pc (prev), name))
a1161 11
  if (prev->type == NORMAL_FRAME)
    prev->this_id.value.code_addr
      = get_pc_function_start (prev->this_id.value.code_addr);

  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, prev);
      fprintf_unfiltered (gdb_stdlog, " } // legacy with confused type\n");
    }

d1166 1
a1166 1
   about the frame that called THIS_FRAME.  Returns NULL
d1170 1
a1170 1
get_prev_frame (struct frame_info *this_frame)
a1173 10
  if (frame_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "{ get_prev_frame (this_frame=");
      if (this_frame != NULL)
	fprintf_unfiltered (gdb_stdlog, "%d", this_frame->level);
      else
	fprintf_unfiltered (gdb_stdlog, "<NULL>");
      fprintf_unfiltered (gdb_stdlog, ") ");
    }

d1192 1
a1192 1
  if (this_frame == NULL)
d1205 1
a1205 1
         THIS_FRAME.  */
d1212 1
a1212 1
  gdb_assert (this_frame != NULL);
d1214 1
a1214 1
  if (this_frame->level >= 0
d1216 1
a1216 1
      && inside_main_func (get_frame_pc (this_frame)))
d1223 2
a1224 1
	fprintf_unfiltered (gdb_stdlog, "-> NULL // inside main func }\n");
d1229 3
a1231 11
  if (this_frame->prev_p)
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, this_frame->prev);
	  fprintf_unfiltered (gdb_stdlog, " // cached \n");
	}
      return this_frame->prev;
    }
  this_frame->prev_p = 1;
a1232 1
#if 0
d1244 2
a1245 11
  /* NOTE: vinschen/2003-04-01: Disabled.  It turns out that the call to
     inside_entry_file destroys a meaningful backtrace under some
     conditions.  E. g. the backtrace tests in the asm-source testcase
     are broken for some targets.  In this test the functions are all
     implemented as part of one file and the testcase is not necessarily
     linked with a start file (depending on the target).  What happens is,
     that the first frame is printed normaly and following frames are
     treated as being inside the enttry file then.  This way, only the
     #0 frame is printed in the backtrace output.  */
  if (this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && inside_entry_file (get_frame_pc (this_frame)))
d1248 2
a1249 5
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // inside entry file }\n");
	}
a1251 1
#endif
d1261 2
a1262 2
      && this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && inside_entry_func (get_frame_pc (this_frame)))
d1265 2
a1266 5
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, "// inside entry func }\n");
	}
d1271 8
a1278 2
     the legacy get_prev_frame method.  */
  if (legacy_frame_p (current_gdbarch))
d1280 4
a1283 1
      prev_frame = legacy_get_prev_frame (this_frame);
a1286 35
  /* Check that this frame's ID was valid.  If it wasn't, don't try to
     unwind to the prev frame.  Be careful to not apply this test to
     the sentinel frame.  */
  if (this_frame->level >= 0 && !frame_id_p (get_frame_id (this_frame)))
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // this ID is NULL }\n");
	}
      return NULL;
    }

  /* Check that this frame's ID isn't inner to (younger, below, next)
     the next frame.  This happens when frame unwind goes backwards.
     Since the sentinel frame isn't valid, don't apply this if this
     frame is entier the inner-most or sentinel frame.  */
  if (this_frame->level > 0
      && frame_id_inner (get_frame_id (this_frame),
			 get_frame_id (this_frame->next)))
    error ("This frame inner-to next frame (corrupt stack?)");

  /* Check that this and the next frame are different.  If they are
     not, there is most likely a stack cycle.  As with the inner-than
     test, avoid the inner-most and sentinel frames.  */
  /* FIXME: cagney/2003-03-17: Can't yet enable this this check. The
     frame_id_eq() method doesn't yet use function addresses when
     comparing frame IDs.  */
  if (0
      && this_frame->level > 0
      && frame_id_eq (get_frame_id (this_frame),
		      get_frame_id (this_frame->next)))
    error ("This frame identical to next frame (corrupt stack?)");

d1298 1
a1298 1
  prev_frame->level = this_frame->level + 1;
d1307 2
a1308 3
     frame_pc_unwind (nee, FRAME_SAVED_PC) and
     DEPRECATED_FRAME_CHAIN()) assume THIS_FRAME's data structures
     have already been initialized (using
d1315 1
a1315 1
     using THIS_FRAME's frame ID.  */
d1317 2
a1318 1
  if (frame_pc_unwind (this_frame) == 0)
d1323 2
a1324 5
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, " // unwound PC zero }\n");
	}
d1327 1
d1329 43
a1371 18
  /* Don't yet compute ->unwind (and hence ->type).  It is computed
     on-demand in get_frame_type, frame_register_unwind, and
     get_frame_id.  */

  /* Don't yet compute the frame's ID.  It is computed on-demand by
     get_frame_id().  */

  /* The unwound frame ID is validate at the start of this function,
     as part of the logic to decide if that frame should be further
     unwound, and not here while the prev frame is being created.
     Doing this makes it possible for the user to examine a frame that
     has an invalid frame ID.

     The very old VAX frame_args_address_correct() method noted: [...]
     For the sake of argument, suppose that the stack is somewhat
     trashed (which is one reason that "info frame" exists).  So,
     return 0 (indicating we don't know the address of the arglist) if
     we don't know what frame this frame calls.  */
d1374 2
a1375 2
  this_frame->prev = prev_frame;
  prev_frame->next = this_frame;
d1377 9
a1385 1
  if (frame_debug)
d1387 2
a1388 3
      fprintf_unfiltered (gdb_stdlog, "-> ");
      fprint_frame (gdb_stdlog, prev_frame);
      fprintf_unfiltered (gdb_stdlog, " }\n");
d1397 1
a1397 2
  gdb_assert (frame->next != NULL);
  return frame_pc_unwind (frame->next);
d1420 1
a1420 1
  (*sal) = find_pc_line (get_frame_pc (frame), pc_notcurrent (frame));
d1428 1
a1428 53
  return get_frame_id (fi).stack_addr;
}

/* High-level offsets into the frame.  Used by the debug info.  */

CORE_ADDR
get_frame_base_address (struct frame_info *fi)
{
  if (get_frame_type (fi) != NORMAL_FRAME)
    return 0;
  if (fi->base == NULL)
    fi->base = frame_base_find_by_pc (current_gdbarch, get_frame_pc (fi));
  /* Sneaky: If the low-level unwind and high-level base code share a
     common unwinder, let them share the prologue cache.  */
  if (fi->base->unwind == fi->unwind)
    return fi->base->this_base (fi->next, &fi->prologue_cache);
  return fi->base->this_base (fi->next, &fi->base_cache);
}

CORE_ADDR
get_frame_locals_address (struct frame_info *fi)
{
  void **cache;
  if (get_frame_type (fi) != NORMAL_FRAME)
    return 0;
  /* If there isn't a frame address method, find it.  */
  if (fi->base == NULL)
    fi->base = frame_base_find_by_pc (current_gdbarch, get_frame_pc (fi));
  /* Sneaky: If the low-level unwind and high-level base code share a
     common unwinder, let them share the prologue cache.  */
  if (fi->base->unwind == fi->unwind)
    cache = &fi->prologue_cache;
  else
    cache = &fi->base_cache;
  return fi->base->this_locals (fi->next, cache);
}

CORE_ADDR
get_frame_args_address (struct frame_info *fi)
{
  void **cache;
  if (get_frame_type (fi) != NORMAL_FRAME)
    return 0;
  /* If there isn't a frame address method, find it.  */
  if (fi->base == NULL)
    fi->base = frame_base_find_by_pc (current_gdbarch, get_frame_pc (fi));
  /* Sneaky: If the low-level unwind and high-level base code share a
     common unwinder, let them share the prologue cache.  */
  if (fi->base->unwind == fi->unwind)
    cache = &fi->prologue_cache;
  else
    cache = &fi->base_cache;
  return fi->base->this_args (fi->next, cache);
d1451 1
a1451 18
  if (frame->unwind == NULL)
    {
      /* Initialize the frame's unwinder because it is that which
         provides the frame's type.  */
      frame->unwind = frame_unwind_find_by_pc (current_gdbarch,
					       get_frame_pc (frame));
      /* FIXME: cagney/2003-04-02: Rather than storing the frame's
	 type in the frame, the unwinder's type should be returned
	 directly.  Unfortunatly, legacy code, called by
	 legacy_get_prev_frame, explicitly set the frames type using
	 the method deprecated_set_frame_type().  */
      gdb_assert (frame->unwind->type != UNKNOWN_FRAME);
      frame->type = frame->unwind->type;
    }
  if (frame->type == UNKNOWN_FRAME)
    return NORMAL_FRAME;
  else
    return frame->type;
d1461 28
d1505 8
a1512 16
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog,
			"{ deprecated_update_frame_pc_hack (frame=%d,pc=0x%s) }\n",
			frame->level, paddr_nz (pc));
  /* NOTE: cagney/2003-03-11: Some architectures (e.g., Arm) are
     maintaining a locally allocated frame object.  Since such frame's
     are not in the frame chain, it isn't possible to assume that the
     frame has a next.  Sigh.  */
  if (frame->next != NULL)
    {
      /* While we're at it, update this frame's cached PC value, found
	 in the next frame.  Oh for the day when "struct frame_info"
	 is opaque and this hack on hack can just go away.  */
      frame->next->prev_pc.value = pc;
      frame->next->prev_pc.p = 1;
    }
a1517 4
  if (frame_debug)
    fprintf_unfiltered (gdb_stdlog,
			"{ deprecated_update_frame_base_hack (frame=%d,base=0x%s) }\n",
			frame->level, paddr_nz (base));
d1519 1
a1519 1
  frame->this_id.value.stack_addr = base;
d1566 2
a1567 2
  struct frame_info *frame = FRAME_OBSTACK_ZALLOC (struct frame_info);
  frame->this_id.p = 1;
a1587 11
}

int
legacy_frame_p (struct gdbarch *current_gdbarch)
{
  return (DEPRECATED_INIT_FRAME_PC_P ()
	  || DEPRECATED_INIT_FRAME_PC_FIRST_P ()
	  || DEPRECATED_INIT_EXTRA_FRAME_INFO_P ()
	  || DEPRECATED_FRAME_CHAIN_P ()
	  || !gdbarch_unwind_dummy_id_p (current_gdbarch)
	  || !SAVE_DUMMY_FRAME_TOS_P ());
@


1.17.2.7
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d298 4
a301 2
    /* No luck.  */
    eq = 0;
d1391 1
a1391 2
	  prev->this_id.value = frame_id_build (deprecated_read_fp (),
						read_pc ());
d1546 2
a1547 3
     (deprecated_read_fp ()), read_pc ()).  Machines with extra frame
     info would do that (or the local equivalent) and then set the
     extra fields.
@


1.17.2.8
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d142 1
a142 1
void
d379 1
a379 1
	     return extract_unsigned_integer (buf, size of ISA_PC_REGNUM);
d621 1
a621 1
  char buf[MAX_REGISTER_SIZE];
d630 1
a630 1
  char buf[MAX_REGISTER_SIZE];
d986 2
a987 4
	    /* NOTE: cagney/2003-05-09: In-lined store_address with
               it's body - store_unsigned_integer.  */
	    store_unsigned_integer (bufferp, REGISTER_RAW_SIZE (regnum),
				    get_frame_saved_regs (frame)[regnum]);
d1113 2
a1114 2
		  (deprecated_find_dummy_frame_regcache (get_frame_pc (frame),
							 get_frame_base (frame)),
d1128 2
a1129 5
		    /* NOTE: cagney/2003-05-09: In-line store_address
                       with it's body - store_unsigned_integer.  */
		    store_unsigned_integer (raw_buffer,
					    REGISTER_RAW_SIZE (regnum),
					    get_frame_saved_regs (frame)[regnum]);
d2072 1
a2072 6

  /* Some legacy code, e.g, mips_init_extra_frame_info() wants
     to determine the frame's type prior to it being completely
     initialized.  Don't attempt to lazily initialize ->unwind for
     legacy code.  It will be initialized in legacy_get_prev_frame().  */
  if (frame->unwind == NULL && !legacy_frame_p (current_gdbarch))
@


1.17.2.9
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a617 35
get_frame_register (struct frame_info *frame,
		    int regnum, void *buf)
{
  frame_unwind_register (frame->next, regnum, buf);
}

LONGEST
frame_unwind_register_signed (struct frame_info *frame, int regnum)
{
  char buf[MAX_REGISTER_SIZE];
  frame_unwind_register (frame, regnum, buf);
  return extract_signed_integer (buf, REGISTER_VIRTUAL_SIZE (regnum));
}

LONGEST
get_frame_register_signed (struct frame_info *frame, int regnum)
{
  return frame_unwind_register_signed (frame->next, regnum);
}

ULONGEST
frame_unwind_register_unsigned (struct frame_info *frame, int regnum)
{
  char buf[MAX_REGISTER_SIZE];
  frame_unwind_register (frame, regnum, buf);
  return extract_unsigned_integer (buf, REGISTER_VIRTUAL_SIZE (regnum));
}

ULONGEST
get_frame_register_unsigned (struct frame_info *frame, int regnum)
{
  return frame_unwind_register_unsigned (frame->next, regnum);
}

void
d677 27
a703 27
put_frame_register (struct frame_info *frame, int regnum, const void *buf)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int realnum;
  int optim;
  enum lval_type lval;
  CORE_ADDR addr;
  frame_register (frame, regnum, &optim, &lval, &addr, &realnum, NULL);
  if (optim)
    error ("Attempt to assign to a value that was optimized out.");
  switch (lval)
    {
    case lval_memory:
      {
	/* FIXME: write_memory doesn't yet take constant buffers.
           Arrrg!  */
	char tmp[MAX_REGISTER_SIZE];
	memcpy (tmp, buf, register_size (gdbarch, regnum));
	write_memory (addr, tmp, register_size (gdbarch, regnum));
	break;
      }
    case lval_register:
      regcache_cooked_write (current_regcache, realnum, buf);
      break;
    default:
      error ("Attempt to assign to an unmodifiable value.");
    }
d781 1
a781 1
static struct frame_info *
d966 6
d973 1
a973 6
    {
      /* If nothing's initialized the saved regs, do it now.  */
      gdb_assert (DEPRECATED_FRAME_INIT_SAVED_REGS_P ());
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
      gdb_assert (get_frame_saved_regs (frame) != NULL);
    }
d1085 2
a1239 6
struct frame_info *
deprecated_get_next_frame_hack (struct frame_info *this_frame)
{
  return this_frame->next;
}

d1376 4
a1477 6
    /* FIXME: cagney/2003-06-16: This returns the inner most stack
       address for the previous frame, that, however, is wrong.  It
       should be the inner most stack address for the previous to
       previous frame.  This is because it is the previous to previous
       frame's innermost stack address that is constant through out
       the lifetime of the previous frame (trust me :-).  */
d1496 2
a1497 23
      if (DEPRECATED_FRAME_CHAIN_P ())
	address = DEPRECATED_FRAME_CHAIN (this_frame);
      else
	{
	  /* Someone is part way through coverting an old architecture
             to the new frame code.  Implement FRAME_CHAIN the way the
             new frame will.  */
	  /* Find PREV frame's unwinder.  */
	  prev->unwind = frame_unwind_find_by_pc (current_gdbarch,
						  frame_pc_unwind (this_frame));
	  /* FIXME: cagney/2003-04-02: Rather than storing the frame's
	     type in the frame, the unwinder's type should be returned
	     directly.  Unfortunatly, legacy code, called by
	     legacy_get_prev_frame, explicitly set the frames type
	     using the method deprecated_set_frame_type().  */
	  prev->type = prev->unwind->type;
	  /* Find PREV frame's ID.  */
	  prev->unwind->this_id (this_frame,
				 &prev->prologue_cache,
				 &prev->this_id.value);
	  prev->this_id.p = 1;
	  address = prev->this_id.value.stack_addr;
	}
d1640 3
a1642 7
     use that to decide how the frame should be unwound.

     If there isn't a FRAME_CHAIN, the code above will have already
     done this.  */
  if (prev->unwind == NULL)
    prev->unwind = frame_unwind_find_by_pc (current_gdbarch,
					    get_frame_pc (prev));
a1649 1
	/* FIXME: cagney/2003-06-16: would get_frame_pc() be better?  */
d1947 5
a1951 5
     Some very old VAX code noted: [...]  For the sake of argument,
     suppose that the stack is somewhat trashed (which is one reason
     that "info frame" exists).  So, return 0 (indicating we don't
     know the address of the arglist) if we don't know what frame this
     frame calls.  */
a2221 62
/* Memory access methods.  */

void
get_frame_memory (struct frame_info *this_frame, CORE_ADDR addr, void *buf,
		  int len)
{
  read_memory (addr, buf, len);
}

LONGEST
get_frame_memory_signed (struct frame_info *this_frame, CORE_ADDR addr,
			 int len)
{
  return read_memory_integer (addr, len);
}

ULONGEST
get_frame_memory_unsigned (struct frame_info *this_frame, CORE_ADDR addr,
			   int len)
{
  return read_memory_unsigned_integer (addr, len);
}

/* Architecture method.  */

struct gdbarch *
get_frame_arch (struct frame_info *this_frame)
{
  return current_gdbarch;
}

/* Stack pointer methods.  */

CORE_ADDR
get_frame_sp (struct frame_info *this_frame)
{
  return frame_sp_unwind (this_frame->next);
}

CORE_ADDR
frame_sp_unwind (struct frame_info *next_frame)
{
  /* Normality, an architecture that provides a way of obtaining any
     frame inner-most address.  */
  if (gdbarch_unwind_sp_p (current_gdbarch))
    return gdbarch_unwind_sp (current_gdbarch, next_frame);
  /* Things are looking grim.  If it's the inner-most frame and there
     is a TARGET_READ_SP then that can be used.  */
  if (next_frame->level < 0 && TARGET_READ_SP_P ())
    return TARGET_READ_SP ();
  /* Now things are really are grim.  Hope that the value returned by
     the SP_REGNUM register is meaningful.  */
  if (SP_REGNUM >= 0)
    {
      ULONGEST sp;
      frame_unwind_unsigned_register (next_frame, SP_REGNUM, &sp);
      return sp;
    }
  internal_error (__FILE__, __LINE__, "Missing unwind SP method");
}


d2229 2
a2230 1
	  || !gdbarch_unwind_dummy_id_p (current_gdbarch));
a2231 2

extern initialize_file_ftype _initialize_frame; /* -Wmissing-prototypes */
@


1.17.2.10
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d31 1
a31 1
#include "user-regs.h"
d232 2
a233 1
	  fi->unwind = frame_unwind_find_by_frame (fi->next);
a424 3
      /* Make certain that this, and not the adjacent, function is
         found.  */
      CORE_ADDR addr_in_block = frame_unwind_address_in_block (fi);
d426 1
a426 1
      fi->prev_func.addr = get_pc_function_start (addr_in_block);
d500 1
a500 1
			  frame->level, frame_map_regnum_to_name (frame, regnum));
d520 2
a521 1
      frame->unwind = frame_unwind_find_by_frame (frame->next);
d549 1
a549 1
	  const unsigned char *buf = bufferp;
d776 1
a776 1
frame_map_name_to_regnum (struct frame_info *frame, const char *name, int len)
d778 24
a801 1
  return user_reg_map_name_to_regnum (get_frame_arch (frame), name, len);
d805 1
a805 1
frame_map_regnum_to_name (struct frame_info *frame, int regnum)
d807 5
a811 1
  return user_reg_map_regnum_to_name (get_frame_arch (frame), regnum);
d1236 1
a1236 1
  fi->unwind = frame_unwind_find_by_frame (fi->next);
d1395 2
a1396 1
      prev->unwind = frame_unwind_find_by_frame (prev->next);
d1544 2
a1545 1
	  prev->unwind = frame_unwind_find_by_frame (this_frame->next);
d1706 2
a1707 1
    prev->unwind = frame_unwind_find_by_frame (prev->next);
a1845 38
  /* If we're already inside the entry function for the main objfile,
     then it isn't valid.  Don't apply this test to a dummy frame -
     dummy frame PC's typically land in the entry func.  Don't apply
     this test to the sentinel frame.  Sentinel frames should always
     be allowed to unwind.  */
  /* NOTE: cagney/2003-02-25: Don't enable until someone has found
     hard evidence that this is needed.  */
  /* NOTE: cagney/2003-07-07: Fixed a bug in inside_main_func - wasn't
     checking for "main" in the minimal symbols.  With that fixed
     asm-source tests now stop in "main" instead of halting the
     backtrace in wierd and wonderful ways somewhere inside the entry
     file.  Suspect that inside_entry_file and inside_entry_func tests
     were added to work around that (now fixed) case.  */
  /* NOTE: cagney/2003-07-15: danielj (if I'm reading it right)
     suggested having the inside_entry_func test use the
     inside_main_func msymbol trick (along with entry_point_address I
     guess) to determine the address range of the start function.
     That should provide a far better stopper than the current
     heuristics.  */
  /* NOTE: cagney/2003-07-15: Need to add a "set backtrace
     beyond-entry-func" command so that this can be selectively
     disabled.  */
  if (0
#if 0
      && backtrace_beyond_entry_func
#endif
      && this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && inside_entry_func (get_frame_pc (this_frame)))
    {
      if (frame_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "-> ");
	  fprint_frame (gdb_stdlog, NULL);
	  fprintf_unfiltered (gdb_stdlog, "// inside entry func }\n");
	}
      return NULL;
    }

d1893 20
d1936 3
a1938 3
     the next frame.  This happens when a frame unwind goes backwards.
     Since the sentinel frame doesn't really exist, don't compare the
     inner-most against that sentinel.  */
d1942 1
a1942 1
    error ("Previous frame inner to this frame (corrupt stack?)");
d1944 8
a1951 4
  /* Check that this and the next frame are not identical.  If they
     are, there is most likely a stack cycle.  As with the inner-than
     test above, avoid comparing the inner-most and sentinel frames.  */
  if (this_frame->level > 0
d1954 1
a1954 1
    error ("Previous frame identical to this frame (corrupt stack?)");
a2039 27
/* Return an address of that falls within the frame's code block.  */

CORE_ADDR
frame_unwind_address_in_block (struct frame_info *next_frame)
{
  /* A draft address.  */
  CORE_ADDR pc = frame_pc_unwind (next_frame);

  /* If THIS frame is not inner most (i.e., NEXT isn't the sentinel),
     and NEXT is `normal' (i.e., not a sigtramp, dummy, ....) THIS
     frame's PC ends up pointing at the instruction fallowing the
     "call".  Adjust that PC value so that it falls on the call
     instruction (which, hopefully, falls within THIS frame's code
     block.  So far it's proved to be a very good approximation.  See
     get_frame_type for why ->type can't be used.  */
  if (next_frame->level >= 0
      && get_frame_type (next_frame) == NORMAL_FRAME)
    --pc;
  return pc;
}

CORE_ADDR
get_frame_address_in_block (struct frame_info *this_frame)
{
  return frame_unwind_address_in_block (this_frame->next);
}

d2079 1
a2079 1
    fi->base = frame_base_find_by_frame (fi->next);
d2095 1
a2095 1
    fi->base = frame_base_find_by_frame (fi->next);
d2113 1
a2113 1
    fi->base = frame_base_find_by_frame (fi->next);
d2152 2
a2153 1
      frame->unwind = frame_unwind_find_by_frame (frame->next);
@


1.17.2.11
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d138 1
a138 4
/* Flag to indicate whether backtraces should stop at main et.al.  */

static int backtrace_past_main;
static unsigned int backtrace_limit = UINT_MAX;
d140 1
a917 12
/* This is a variant of get_selected_frame which can be called when
   the inferior does not have a frame; in that case it will return
   NULL instead of calling error ().  */

struct frame_info *
deprecated_safe_get_selected_frame (void)
{
  if (!target_has_registers || !target_has_stack || !target_has_memory)
    return NULL;
  return get_selected_frame ();
}

d923 1
a923 1
  struct symtab *s;
d1078 3
a1080 3
   Set *ADDRP to the address, either in memory or as a
   DEPRECATED_REGISTER_BYTE offset into the registers array.  If the
   value is stored in a dummy frame, set *ADDRP to zero.
d1161 1
a1161 1
    *addrp = DEPRECATED_REGISTER_BYTE (regnum);
d1805 1
a1805 1
      && !backtrace_past_main
a1816 5
  if (this_frame->level > backtrace_limit)
    {
      error ("Backtrace limit of %d exceeded", backtrace_limit);
    }

d1828 2
a1829 3
     file.  Suspect that deprecated_inside_entry_file and
     inside_entry_func tests were added to work around that (now
     fixed) case.  */
d1868 1
d1880 11
a1890 13
  /* NOTE: vinschen/2003-04-01: Disabled.  It turns out that the call
     to deprecated_inside_entry_file destroys a meaningful backtrace
     under some conditions.  E. g. the backtrace tests in the
     asm-source testcase are broken for some targets.  In this test
     the functions are all implemented as part of one file and the
     testcase is not necessarily linked with a start file (depending
     on the target).  What happens is, that the first frame is printed
     normaly and following frames are treated as being inside the
     enttry file then.  This way, only the #0 frame is printed in the
     backtrace output.  */
  if (0
      && this_frame->type != DUMMY_FRAME && this_frame->level >= 0
      && deprecated_inside_entry_file (get_frame_pc (this_frame)))
d1900 1
d2275 1
a2275 2
  struct frame_info *frame = XMALLOC (struct frame_info);
  memset (frame, 0, sizeof (*frame));
a2372 15
static struct cmd_list_element *set_backtrace_cmdlist;
static struct cmd_list_element *show_backtrace_cmdlist;

static void
set_backtrace_cmd (char *args, int from_tty)
{
  help_list (set_backtrace_cmdlist, "set backtrace ", -1, gdb_stdout);
}

static void
show_backtrace_cmd (char *args, int from_tty)
{
  cmd_show_list (show_backtrace_cmdlist, from_tty, "");
}

d2378 4
a2381 10
  add_prefix_cmd ("backtrace", class_maintenance, set_backtrace_cmd, "\
Set backtrace specific variables.\n\
Configure backtrace variables such as the backtrace limit",
		  &set_backtrace_cmdlist, "set backtrace ",
		  0/*allow-unknown*/, &setlist);
  add_prefix_cmd ("backtrace", class_maintenance, show_backtrace_cmd, "\
Show backtrace specific variables\n\
Show backtrace variables such as the backtrace limit",
		  &show_backtrace_cmdlist, "show backtrace ",
		  0/*allow-unknown*/, &showlist);
d2383 2
a2384 2
  add_setshow_boolean_cmd ("past-main", class_obscure,
			   &backtrace_past_main, "\
d2393 1
a2393 2
			   NULL, NULL, &set_backtrace_cmdlist,
			   &show_backtrace_cmdlist);
a2394 8
  add_setshow_uinteger_cmd ("limit", class_obscure,
			    &backtrace_limit, "\
Set an upper bound on the number of backtrace levels.\n\
No more than the specified number of frames can be displayed or examined.\n\
Zero is unlimited.", "\
Show the upper bound on the number of backtrace levels.",
			    NULL, NULL, &set_backtrace_cmdlist,
			    &show_backtrace_cmdlist);
@


1.17.2.12
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d68 1
a68 1
     ->unwind->type.  Unfortunately, legacy code is still explicitly
d147 1
a147 1
  fprintf_unfiltered (file, "{stack=0x%s,code=0x%s,special=0x%s}",
d149 1
a149 2
		      paddr_nz (id.code_addr),
		      paddr_nz (id.special_addr));
d237 1
a237 1
	     directly.  Unfortunately, legacy code, called by
d259 1
a259 2
frame_id_build_special (CORE_ADDR stack_addr, CORE_ADDR code_addr,
                        CORE_ADDR special_addr)
a263 1
  id.special_addr = special_addr;
a266 6
struct frame_id
frame_id_build (CORE_ADDR stack_addr, CORE_ADDR code_addr)
{
  return frame_id_build_special (stack_addr, code_addr, 0);
}

d295 2
a296 8
  else if (l.code_addr != r.code_addr)
    /* If .code addresses are different, the frames are different.  */
    eq = 0;
  else if (l.special_addr == 0 || r.special_addr == 0)
    /* A zero special addr is a wild card (or unused), always succeed.  */
    eq = 1;
  else if (l.special_addr == r.special_addr)
    /* Frames are equal.  */
d323 1
a323 1
       different .code and/or .special address).  */
d480 1
a480 1
         functionality.  Unfortunately, they don't implement it.  Their
d527 1
a527 1
	 directly.  Unfortunately, legacy code, called by
d632 1
a632 1
  return extract_signed_integer (buf, DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
d646 1
a646 1
  return extract_unsigned_integer (buf, DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
d661 1
a661 1
  (*val) = extract_signed_integer (buf, DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
d670 42
a711 1
  (*val) = extract_unsigned_integer (buf, DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
d747 1
a747 2
   The number of bytes copied is DEPRECATED_REGISTER_RAW_SIZE
   (REGNUM).
d847 1
a847 1
deprecated_get_frame_saved_regs (struct frame_info *fi)
d981 1
a981 1
     Unfortunately, old code expects this frame.  Since this is a
d989 1
a989 1
  if (deprecated_get_frame_saved_regs (frame) == NULL)
d994 1
a994 1
      gdb_assert (deprecated_get_frame_saved_regs (frame) != NULL);
d997 2
a998 2
  if (deprecated_get_frame_saved_regs (frame) != NULL
      && deprecated_get_frame_saved_regs (frame)[regnum] != 0)
d1010 2
a1011 2
	    store_unsigned_integer (bufferp, DEPRECATED_REGISTER_RAW_SIZE (regnum),
				    deprecated_get_frame_saved_regs (frame)[regnum]);
d1019 1
a1019 1
	  *addrp = deprecated_get_frame_saved_regs (frame)[regnum];
d1037 3
a1039 3
		    = frame_obstack_zalloc (DEPRECATED_REGISTER_RAW_SIZE (regnum));
		  read_memory (deprecated_get_frame_saved_regs (frame)[regnum], regs[regnum],
			       DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1041 1
a1041 1
	      memcpy (bufferp, regs[regnum], DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1044 2
a1045 2
	      read_memory (deprecated_get_frame_saved_regs (frame)[regnum], bufferp,
			   DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1142 2
a1143 2
	  if (deprecated_get_frame_saved_regs (frame) != NULL
	      && deprecated_get_frame_saved_regs (frame)[regnum] != 0)
d1153 2
a1154 2
					    DEPRECATED_REGISTER_RAW_SIZE (regnum),
					    deprecated_get_frame_saved_regs (frame)[regnum]);
d1159 1
a1159 1
		    *addrp = deprecated_get_frame_saved_regs (frame)[regnum];
d1161 2
a1162 2
		    read_memory (deprecated_get_frame_saved_regs (frame)[regnum], raw_buffer,
				 DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1337 1
a1337 1
     Unfortunately those same work-arounds rely on the type defaulting
d1447 1
a1447 1
	 info.  Unfortunately legacy targets can't use
d1534 1
a1534 1
	     directly.  Unfortunately, legacy code, called by
d2187 1
a2187 1
	 directly.  Unfortunately, legacy code, called by
@


1.17.2.13
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d89 4
d671 9
d933 1
a933 7
      /* We retrieve the frame's symtab by using the frame PC.  However
         we cannot use the frame pc as is, because it usually points to
         the instruction following the "call", which is sometimes the
         first instruction of another function.  So we rely on
         get_frame_address_in_block() which provides us with a PC which
         is guaranteed to be inside the frame's code block.  */
      s = find_pc_symtab (get_frame_address_in_block (fi));
a1792 4
  /* Make sure we pass an address within THIS_FRAME's code block to
     inside_main_func.  Otherwise, we might stop unwinding at a
     function which has a call instruction as its last instruction if
     that function immediately precedes main().  */
d1795 1
a1795 1
      && inside_main_func (get_frame_address_in_block (this_frame)))
d2226 41
d2268 1
a2268 2
deprecated_frame_xmalloc_with_cleanup (long sizeof_saved_regs,
				       long sizeof_extra_info)
d2273 8
@


1.17.2.14
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1729 1
a1729 6
   if there is no such frame.

   This function tests some target-independent conditions that should
   terminate the frame chain, such as unwinding past main().  It
   should not contain any target-dependent tests, such as checking
   whether the program-counter is zero.  */
d1945 31
@


1.16
log
@2002-09-13  Andrew Cagney  <ac131313@@redhat.com>

	* frame.c (find_saved_register): Delete function.
	* frame.h (find_saved_register): Delete declaration.
	Fix PR gdb/631.
@
text
@d125 27
@


1.15
log
@2002-08-19  Andrew Cagney  <ac131313@@redhat.com>
* frame.c (frame_register_unwind): When a register, set addrp to
the register's byte.
@
text
@a80 37
/* FIND_SAVED_REGISTER ()

   Return the address in which frame FRAME's value of register REGNUM
   has been saved in memory.  Or return zero if it has not been saved.
   If REGNUM specifies the SP, the value we return is actually
   the SP value, not an address where it was saved.  */

CORE_ADDR
find_saved_register (struct frame_info *frame, int regnum)
{
  register struct frame_info *frame1 = NULL;
  register CORE_ADDR addr = 0;

  if (frame == NULL)		/* No regs saved if want current frame */
    return 0;

  /* Note that the following loop assumes that registers used in
     frame x will be saved only in the frame that x calls and frames
     interior to it.  */
  while (1)
    {
      QUIT;
      frame1 = get_next_frame (frame);
      if (frame1 == 0)
	break;
      frame = frame1;
      FRAME_INIT_SAVED_REGS (frame1);
      if (frame1->saved_regs[regnum])
	{
	  addr = frame1->saved_regs[regnum];
	  break;
	}
    }

  return addr;
}

@


1.15.6.1
log
@* frame.c: Include "gdb_string.h" and "builtin-regs.h".
(frame_map_regnum_to_name): New function.
(frame_map_name_to_regnum): New function.
* frame.h (frame_map_name_to_regnum): Declare.
(frame_map_regnum_to_name): Declare.
* builtin-regs.c (builtin_reg_map_regnum_to_name): New function.
* builtin-regs.h (builtin_reg_map_regnum_to_name): Declare.
* parse.c: Do not include "builtin-regs.h".
(target_map_name_to_register): Delete function.
(write_dollar_variable): Use frame_map_name_to_regnum.
* parser-defs.h (target_map_name_to_register): Delete declaration.
* expprint.c: Include "frame.h".
(print_subexp): Use frame_map_regnum_to_name.
* eval.c (evaluate_subexp_standard): Use frame_map_regnum_to_name.
* infcmd.c (registers_info): Use frame_map_name_to_regnum.

Testsuite:

* gdb.base/pc-fp.exp, gdb.base/pc-fp.c: New test.
@
text
@a29 2
#include "gdb_string.h"
#include "builtin-regs.h"
a244 41
}


/* Map between a frame register number and its name.  A frame register
   space is a superset of the cooked register space --- it also
   includes builtin registers.  */

int
frame_map_name_to_regnum (const char *name, int len)
{
  int i;

  /* Search register name space. */
  for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
    if (REGISTER_NAME (i) && len == strlen (REGISTER_NAME (i))
	&& strncmp (name, REGISTER_NAME (i), len) == 0)
      {
	return i;
      }

  /* Try builtin registers.  */
  i = builtin_reg_map_name_to_regnum (name, len);
  if (i >= 0)
    {
      /* A builtin register doesn't fall into the architecture's
         register range.  */
      gdb_assert (i >= NUM_REGS + NUM_PSEUDO_REGS);
      return i;
    }

  return -1;
}

const char *
frame_map_regnum_to_name (int regnum)
{
  if (regnum < 0)
    return NULL;
  if (regnum < NUM_REGS + NUM_PSEUDO_REGS)
    return REGISTER_NAME (regnum);
  return builtin_reg_map_regnum_to_name (regnum);
@


1.14
log
@	* frame.c (find_saved_register): Break out of loop once saved
	register address is found.  Don't mention sparc in loop comment
	anymore.
@
text
@d145 3
a147 1
      *addrp = 0;
@


1.13
log
@* infrun.c (struct inferior_status): Replace fields
selected_frame_address and selected_level with field
selected_frame_id.
(save_inferior_status): Update.  Use get_frame_id.
(struct restore_selected_frame_args): Delete.
(restore_selected_frame): Update.  Use frame_find_by_id.
(restore_inferior_status): Update.

* breakpoint.h (struct breakpoint): Change type of
watchpoint_frame to frame_id.
* breakpoint.c (insert_breakpoints): Use frame_find_by_id.  Remove
call to get_current_frame.
(do_enable_breakpoint): Use frame_find_by_id.  Remove call to
get_current_frame.
(watchpoint_check): Use frame_find_by_id.

* frame.h (record_selected_frame): Delete declaration.
* stack.c (record_selected_frame): Delete function.

* frame.h (struct frame_id): Define.
(get_frame_id): Declare.
(frame_find_by_id): Declare.
* frame.c (frame_find_by_id): New function.
(get_frame_id): New function.
@
text
@d97 3
a99 4
  /* Note that this next routine assumes that registers used in
     frame x will be saved only in the frame that x calls and
     frames interior to it.  This is not true on the sparc, but the
     above macro takes care of it, so we should be all right. */
d109 4
a112 1
	addr = frame1->saved_regs[regnum];
@


1.12
log
@* frame.c (GET_SAVED_REGISTER): Delete macro definition.
(default_get_saved_register): Delete function.
* gdbarch.sh (GET_SAVED_REGISTER): Set default to
generic_unwind_get_saved_register.
* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d31 50
@


1.11
log
@* stack.c (frame_info): Use frame_register_unwind instead of
saved_regs.  Mention when the SP is on the stack or in a register.
* frame.h (frame_register_unwind_ftype): Define.  Document.
(struct frame_info): Add field register_unwind and
register_unwind_cache.
(frame_register_unwind): Declare.
(generic_unwind_get_saved_register): Declare.
* frame.c (frame_register_unwind): New function.
(generic_unwind_get_saved_register): New function.
* blockframe.c (generic_call_dummy_register_unwind): New function.
(frame_saved_regs_register_unwind): New function.
(set_unwind_by_pc): New function.
(create_new_frame): New function.
(get_prev_frame): New function.
@
text
@a65 65
/* DEFAULT_GET_SAVED_REGISTER ()

   Find register number REGNUM relative to FRAME and put its (raw,
   target format) contents in *RAW_BUFFER.  Set *OPTIMIZED if the
   variable was optimized out (and thus can't be fetched).  Set *LVAL
   to lval_memory, lval_register, or not_lval, depending on whether
   the value was fetched from memory, from a register, or in a strange
   and non-modifiable way (e.g. a frame pointer which was calculated
   rather than fetched).  Set *ADDRP to the address, either in memory
   on as a REGISTER_BYTE offset into the registers array.

   Note that this implementation never sets *LVAL to not_lval.  But
   it can be replaced by defining GET_SAVED_REGISTER and supplying
   your own.

   The argument RAW_BUFFER must point to aligned memory.  */

static void
default_get_saved_register (char *raw_buffer,
			    int *optimized,
			    CORE_ADDR *addrp,
			    struct frame_info *frame,
			    int regnum,
			    enum lval_type *lval)
{
  CORE_ADDR addr;

  if (!target_has_registers)
    error ("No registers.");

  /* Normal systems don't optimize out things with register numbers.  */
  if (optimized != NULL)
    *optimized = 0;
  addr = find_saved_register (frame, regnum);
  if (addr != 0)
    {
      if (lval != NULL)
	*lval = lval_memory;
      if (regnum == SP_REGNUM)
	{
	  if (raw_buffer != NULL)
	    {
	      /* Put it back in target format.  */
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
			     (LONGEST) addr);
	    }
	  if (addrp != NULL)
	    *addrp = 0;
	  return;
	}
      if (raw_buffer != NULL)
	target_read_memory (addr, raw_buffer, REGISTER_RAW_SIZE (regnum));
    }
  else
    {
      if (lval != NULL)
	*lval = lval_register;
      addr = REGISTER_BYTE (regnum);
      if (raw_buffer != NULL)
	read_register_gen (regnum, raw_buffer);
    }
  if (addrp != NULL)
    *addrp = addr;
}

a153 5

#if !defined (GET_SAVED_REGISTER)
#define GET_SAVED_REGISTER(raw_buffer, optimized, addrp, frame, regnum, lval) \
  default_get_saved_register(raw_buffer, optimized, addrp, frame, regnum, lval)
#endif
@


1.10
log
@* regcache.c (register_valid): Revise comments refering to "Not
available" and "unavailable".
* frame.c (frame_register_read): Ditto.
* findvar.c (value_of_register): Ditto.
@
text
@d1 1
a1 1
/* Cache and manage the values of registers for GDB, the GNU debugger.
d29 1
d129 89
@


1.10.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1 1
a1 1
/* Cache and manage frames for GDB, the GNU debugger.
a28 51
#include "gdb_assert.h"

/* Return a frame uniq ID that can be used to, later re-find the
   frame.  */

void
get_frame_id (struct frame_info *fi, struct frame_id *id)
{
  if (fi == NULL)
    {
      id->base = 0;
      id->pc = 0;
    }
  else
    {
      id->base = FRAME_FP (fi);
      id->pc = fi->pc;
    }
}

struct frame_info *
frame_find_by_id (struct frame_id id)
{
  struct frame_info *frame;

  /* ZERO denotes the null frame, let the caller decide what to do
     about it.  Should it instead return get_current_frame()?  */
  if (id.base == 0 && id.pc == 0)
    return NULL;

  for (frame = get_current_frame ();
       frame != NULL;
       frame = get_prev_frame (frame))
    {
      if (INNER_THAN (FRAME_FP (frame), id.base))
	/* ``inner/current < frame < id.base''.  Keep looking along
           the frame chain.  */
	continue;
      if (INNER_THAN (id.base, FRAME_FP (frame)))
	/* ``inner/current < id.base < frame''.  Oops, gone past it.
           Just give up.  */
	return NULL;
      /* FIXME: cagney/2002-04-21: This isn't sufficient.  It should
	 use id.pc to check that the two frames belong to the same
	 function.  Otherwise we'll do things like match dummy frames
	 or mis-match frameless functions.  However, until someone
	 notices, stick with the existing behavour.  */
      return frame;
    }
  return NULL;
}
d65 1
a65 42
void
frame_register_unwind (struct frame_info *frame, int regnum,
		       int *optimizedp, enum lval_type *lvalp,
		       CORE_ADDR *addrp, int *realnump, void *bufferp)
{
  struct frame_unwind_cache *cache;

  /* Require all but BUFFERP to be valid.  A NULL BUFFERP indicates
     that the value proper does not need to be fetched.  */
  gdb_assert (optimizedp != NULL);
  gdb_assert (lvalp != NULL);
  gdb_assert (addrp != NULL);
  gdb_assert (realnump != NULL);
  /* gdb_assert (bufferp != NULL); */

  /* NOTE: cagney/2002-04-14: It would be nice if, instead of a
     special case, there was always an inner frame dedicated to the
     hardware registers.  Unfortunatly, there is too much unwind code
     around that looks up/down the frame chain while making the
     assumption that each frame level is using the same unwind code.  */

  if (frame == NULL)
    {
      /* We're in the inner-most frame, get the value direct from the
	 register cache.  */
      *optimizedp = 0;
      *lvalp = lval_register;
      *addrp = 0;
      /* Should this code test ``register_cached (regnum) < 0'' and do
         something like set realnum to -1 when the register isn't
         available?  */
      *realnump = regnum;
      if (bufferp)
	read_register_gen (regnum, bufferp);
      return;
    }

  /* Ask this frame to unwind its register.  */
  frame->register_unwind (frame, &frame->register_unwind_cache, regnum,
			  optimizedp, lvalp, addrp, realnump, bufferp);
}

d67 22
a88 7
void
generic_unwind_get_saved_register (char *raw_buffer,
				   int *optimizedp,
				   CORE_ADDR *addrp,
				   struct frame_info *frame,
				   int regnum,
				   enum lval_type *lvalp)
d90 1
a90 4
  int optimizedx;
  CORE_ADDR addrx;
  int realnumx;
  enum lval_type lvalx;
d95 23
a117 25
  /* Keep things simple, ensure that all the pointers (except valuep)
     are non NULL.  */
  if (optimizedp == NULL)
    optimizedp = &optimizedx;
  if (lvalp == NULL)
    lvalp = &lvalx;
  if (addrp == NULL)
    addrp = &addrx;

  /* Reached the the bottom (youngest, inner most) of the frame chain
     (youngest, inner most) frame, go direct to the hardware register
     cache (do not pass go, do not try to cache the value, ...).  The
     unwound value would have been cached in frame->next but that
     doesn't exist.  This doesn't matter as the hardware register
     cache is stopping any unnecessary accesses to the target.  */

  /* NOTE: cagney/2002-04-14: It would be nice if, instead of a
     special case, there was always an inner frame dedicated to the
     hardware registers.  Unfortunatly, there is too much unwind code
     around that looks up/down the frame chain while making the
     assumption that each frame level is using the same unwind code.  */

  if (frame == NULL)
    frame_register_unwind (NULL, regnum, optimizedp, lvalp, addrp, &realnumx,
			   raw_buffer);
d119 9
a127 2
    frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			   &realnumx, raw_buffer);
d129 5
@


1.10.4.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d97 4
a100 3
  /* Note that the following loop assumes that registers used in
     frame x will be saved only in the frame that x calls and frames
     interior to it.  */
d110 1
a110 4
	{
	  addr = frame1->saved_regs[regnum];
	  break;
	}
@


1.10.4.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d145 1
a145 3
      /* ULGH!  Code uses the offset into the raw register byte array
         as a way of identifying a register.  */
      *addrp = REGISTER_BYTE (regnum);
@


1.10.4.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a29 2
#include "gdb_string.h"
#include "builtin-regs.h"
d81 37
a161 27
void
frame_unwind_signed_register (struct frame_info *frame, int regnum,
			      LONGEST *val)
{
  int optimized;
  CORE_ADDR addr;
  int realnum;
  enum lval_type lval;
  void *buf = alloca (MAX_REGISTER_RAW_SIZE);
  frame_register_unwind (frame, regnum, &optimized, &lval, &addr,
			 &realnum, buf);
  (*val) = extract_signed_integer (buf, REGISTER_VIRTUAL_SIZE (regnum));
}

void
frame_unwind_unsigned_register (struct frame_info *frame, int regnum,
				ULONGEST *val)
{
  int optimized;
  CORE_ADDR addr;
  int realnum;
  enum lval_type lval;
  void *buf = alloca (MAX_REGISTER_RAW_SIZE);
  frame_register_unwind (frame, regnum, &optimized, &lval, &addr,
			 &realnum, buf);
  (*val) = extract_unsigned_integer (buf, REGISTER_VIRTUAL_SIZE (regnum));
}
a244 41
}


/* Map between a frame register number and its name.  A frame register
   space is a superset of the cooked register space --- it also
   includes builtin registers.  */

int
frame_map_name_to_regnum (const char *name, int len)
{
  int i;

  /* Search register name space. */
  for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
    if (REGISTER_NAME (i) && len == strlen (REGISTER_NAME (i))
	&& strncmp (name, REGISTER_NAME (i), len) == 0)
      {
	return i;
      }

  /* Try builtin registers.  */
  i = builtin_reg_map_name_to_regnum (name, len);
  if (i >= 0)
    {
      /* A builtin register doesn't fall into the architecture's
         register range.  */
      gdb_assert (i >= NUM_REGS + NUM_PSEUDO_REGS);
      return i;
    }

  return -1;
}

const char *
frame_map_regnum_to_name (int regnum)
{
  if (regnum < 0)
    return NULL;
  if (regnum < NUM_REGS + NUM_PSEUDO_REGS)
    return REGISTER_NAME (regnum);
  return builtin_reg_map_regnum_to_name (regnum);
@


1.10.4.5
log
@merge from mainline
@
text
@d118 1
a118 1
	deprecated_read_register_gen (regnum, bufferp);
a152 34
}

void
frame_read_unsigned_register (struct frame_info *frame, int regnum,
			      ULONGEST *val)
{
  /* NOTE: cagney/2002-10-31: There is a bit of dogma here - there is
     always a frame.  Both this, and the equivalent
     frame_read_signed_register() function, can only be called with a
     valid frame.  If, for some reason, this function is called
     without a frame then the problem isn't here, but rather in the
     caller.  It should of first created a frame and then passed that
     in.  */
  /* NOTE: cagney/2002-10-31: As a side bar, keep in mind that the
     ``current_frame'' should not be treated as a special case.  While
     ``get_next_frame (current_frame) == NULL'' currently holds, it
     should, as far as possible, not be relied upon.  In the future,
     ``get_next_frame (current_frame)'' may instead simply return a
     normal frame object that simply always gets register values from
     the register cache.  Consequently, frame code should try to avoid
     tests like ``if get_next_frame() == NULL'' and instead just rely
     on recursive frame calls (like the below code) when manipulating
     a frame chain.  */
  gdb_assert (frame != NULL);
  frame_unwind_unsigned_register (get_next_frame (frame), regnum, val);
}

void
frame_read_signed_register (struct frame_info *frame, int regnum,
			    LONGEST *val)
{
  /* See note in frame_read_unsigned_register().  */
  gdb_assert (frame != NULL);
  frame_unwind_signed_register (get_next_frame (frame), regnum, val);
@


1.10.2.1
log
@merge from trunk
@
text
@d1 1
a1 1
/* Cache and manage frames for GDB, the GNU debugger.
a28 51
#include "gdb_assert.h"

/* Return a frame uniq ID that can be used to, later re-find the
   frame.  */

void
get_frame_id (struct frame_info *fi, struct frame_id *id)
{
  if (fi == NULL)
    {
      id->base = 0;
      id->pc = 0;
    }
  else
    {
      id->base = FRAME_FP (fi);
      id->pc = fi->pc;
    }
}

struct frame_info *
frame_find_by_id (struct frame_id id)
{
  struct frame_info *frame;

  /* ZERO denotes the null frame, let the caller decide what to do
     about it.  Should it instead return get_current_frame()?  */
  if (id.base == 0 && id.pc == 0)
    return NULL;

  for (frame = get_current_frame ();
       frame != NULL;
       frame = get_prev_frame (frame))
    {
      if (INNER_THAN (FRAME_FP (frame), id.base))
	/* ``inner/current < frame < id.base''.  Keep looking along
           the frame chain.  */
	continue;
      if (INNER_THAN (id.base, FRAME_FP (frame)))
	/* ``inner/current < id.base < frame''.  Oops, gone past it.
           Just give up.  */
	return NULL;
      /* FIXME: cagney/2002-04-21: This isn't sufficient.  It should
	 use id.pc to check that the two frames belong to the same
	 function.  Otherwise we'll do things like match dummy frames
	 or mis-match frameless functions.  However, until someone
	 notices, stick with the existing behavour.  */
      return frame;
    }
  return NULL;
}
d65 1
a65 42
void
frame_register_unwind (struct frame_info *frame, int regnum,
		       int *optimizedp, enum lval_type *lvalp,
		       CORE_ADDR *addrp, int *realnump, void *bufferp)
{
  struct frame_unwind_cache *cache;

  /* Require all but BUFFERP to be valid.  A NULL BUFFERP indicates
     that the value proper does not need to be fetched.  */
  gdb_assert (optimizedp != NULL);
  gdb_assert (lvalp != NULL);
  gdb_assert (addrp != NULL);
  gdb_assert (realnump != NULL);
  /* gdb_assert (bufferp != NULL); */

  /* NOTE: cagney/2002-04-14: It would be nice if, instead of a
     special case, there was always an inner frame dedicated to the
     hardware registers.  Unfortunatly, there is too much unwind code
     around that looks up/down the frame chain while making the
     assumption that each frame level is using the same unwind code.  */

  if (frame == NULL)
    {
      /* We're in the inner-most frame, get the value direct from the
	 register cache.  */
      *optimizedp = 0;
      *lvalp = lval_register;
      *addrp = 0;
      /* Should this code test ``register_cached (regnum) < 0'' and do
         something like set realnum to -1 when the register isn't
         available?  */
      *realnump = regnum;
      if (bufferp)
	read_register_gen (regnum, bufferp);
      return;
    }

  /* Ask this frame to unwind its register.  */
  frame->register_unwind (frame, &frame->register_unwind_cache, regnum,
			  optimizedp, lvalp, addrp, realnump, bufferp);
}

d67 22
a88 7
void
generic_unwind_get_saved_register (char *raw_buffer,
				   int *optimizedp,
				   CORE_ADDR *addrp,
				   struct frame_info *frame,
				   int regnum,
				   enum lval_type *lvalp)
d90 1
a90 4
  int optimizedx;
  CORE_ADDR addrx;
  int realnumx;
  enum lval_type lvalx;
d95 23
a117 25
  /* Keep things simple, ensure that all the pointers (except valuep)
     are non NULL.  */
  if (optimizedp == NULL)
    optimizedp = &optimizedx;
  if (lvalp == NULL)
    lvalp = &lvalx;
  if (addrp == NULL)
    addrp = &addrx;

  /* Reached the the bottom (youngest, inner most) of the frame chain
     (youngest, inner most) frame, go direct to the hardware register
     cache (do not pass go, do not try to cache the value, ...).  The
     unwound value would have been cached in frame->next but that
     doesn't exist.  This doesn't matter as the hardware register
     cache is stopping any unnecessary accesses to the target.  */

  /* NOTE: cagney/2002-04-14: It would be nice if, instead of a
     special case, there was always an inner frame dedicated to the
     hardware registers.  Unfortunatly, there is too much unwind code
     around that looks up/down the frame chain while making the
     assumption that each frame level is using the same unwind code.  */

  if (frame == NULL)
    frame_register_unwind (NULL, regnum, optimizedp, lvalp, addrp, &realnumx,
			   raw_buffer);
d119 9
a127 2
    frame_register_unwind (frame->next, regnum, optimizedp, lvalp, addrp,
			   &realnumx, raw_buffer);
d129 5
@


1.9
log
@* frame.c (find_saved_register): Delete #ifdef
HAVE_REGISTER_WINDOWS code.
* config/sparc/tm-sparc.h: Update comments.
* config/i960/tm-i960.h (HAVE_REGISTER_WINDOWS): Delete macro.
* gdbint.texinfo (Target Architecture Definition): Delete
definition of HAVE_REGISTER_WINDOWS.
@
text
@d160 7
a166 4
  /* FIXME: cagney/2002-04-10: This test is just bogus.  It is no
     indication of the validity of the register.  The value could
     easily be found (on the stack) even though the corresponding
     register isn't available.  */
@


1.8
log
@* frame.c (find_saved_register): Avoid a NULL pointer
dereference and actually walk the frame list.
@
text
@a45 33
#ifdef HAVE_REGISTER_WINDOWS
  /* We assume that a register in a register window will only be saved
     in one place (since the name changes and/or disappears as you go
     towards inner frames), so we only call get_frame_saved_regs on
     the current frame.  This is directly in contradiction to the
     usage below, which assumes that registers used in a frame must be
     saved in a lower (more interior) frame.  This change is a result
     of working on a register window machine; get_frame_saved_regs
     always returns the registers saved within a frame, within the
     context (register namespace) of that frame. */

  /* However, note that we don't want this to return anything if
     nothing is saved (if there's a frame inside of this one).  Also,
     callers to this routine asking for the stack pointer want the
     stack pointer saved for *this* frame; this is returned from the
     next frame.  */

  if (REGISTER_IN_WINDOW_P (regnum))
    {
      frame1 = get_next_frame (frame);
      if (!frame1)
	return 0;		/* Registers of this frame are active.  */

      /* Get the SP from the next frame in; it will be this
         current frame.  */
      if (regnum != SP_REGNUM)
	frame1 = frame;

      FRAME_INIT_SAVED_REGS (frame1);
      return frame1->saved_regs[regnum];	/* ... which might be zero */
    }
#endif /* HAVE_REGISTER_WINDOWS */

@


1.7
log
@* frame.c (find_saved_register): Find saved registers in the next
not prev frame.
Fix PR gdb/365.
@
text
@d86 2
a87 2
      frame1 = get_next_frame (frame1);
      if (frame1 == 0 || frame1 == frame)
d89 1
@


1.6
log
@* defs.h (read_relative_register_raw_bytes): Delete declaration.
* frame.c (frame_register_read): New function.  Return non-zero on
success.
(read_relative_register_raw_bytes_for_frame): Delete.
(read_relative_register_raw_bytes): Delete.
* frame.h (frame_register_read): Declare.
* d30v-tdep.c: Update Copyright.  Use frame_register_read.
* sh-tdep.c: Ditto.
* infcmd.c (do_registers_info): Ditto.
* hppa-tdep.c: Ditto.
* rs6000-tdep.c: Ditto.
* h8500-tdep.c: Ditto.
* mips-tdep.c: Ditto.
* h8300-tdep.c: Ditto.
* z8k-tdep.c: Ditto.
@
text
@d86 1
a86 1
      frame1 = get_prev_frame (frame1);
@


1.5
log
@* frame.c (read_relative_register_raw_bytes_for_frame): Do not
override FP_REGNUM with frame->fp.  Update copyright.
* parse.c (num_std_regs, std_regs): Delete.
(target_map_name_to_register): Do not search std_regs.  Update
function description.
* parser-defs.h (num_std_regs, std_regs, struct std_regs): Delete
declarations.  Update copyright.
Fix PR gdb/251.
@
text
@d178 1
a178 1
/* READ_RELATIVE_REGISTER_RAW_BYTES_FOR_FRAME
d180 1
a180 2
   Copy the bytes of register REGNUM, relative to the input stack frame,
   into our memory at MYADDR, in target byte order.
d183 1
a183 1
   Returns 1 if could not be read, 0 if could.  */
d185 2
a186 4
static int
read_relative_register_raw_bytes_for_frame (int regnum,
					    char *myaddr,
					    struct frame_info *frame)
d192 4
d197 1
a197 12
    return 1;			/* register value not available */

  return optim;
}

/* READ_RELATIVE_REGISTER_RAW_BYTES

   Copy the bytes of register REGNUM, relative to the current stack
   frame, into our memory at MYADDR, in target byte order.  
   The number of bytes copied is REGISTER_RAW_SIZE (REGNUM).

   Returns 1 if could not be read, 0 if could.  */
d199 1
a199 5
int
read_relative_register_raw_bytes (int regnum, char *myaddr)
{
  return read_relative_register_raw_bytes_for_frame (regnum, myaddr,
						     selected_frame);
@


1.4
log
@Phase 1 of the ptid_t changes.
@
text
@d2 3
a4 2
   Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000, 2001
   Free Software Foundation, Inc.
a185 3
/* FIXME: This function increases the confusion between FP_REGNUM
   and the virtual/pseudo-frame pointer.  */

a191 9
  if (regnum == FP_REGNUM && frame)
    {
      /* Put it back in target format. */
      store_address (myaddr, REGISTER_RAW_SIZE (FP_REGNUM),
		     (LONGEST) FRAME_FP (frame));

      return 0;
    }

@


1.3
log
@Update/correct copyright notices.
@
text
@d26 1
a26 1
#include "inferior.h"	/* for inferior_pid */
@


1.2
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000,
   2001 Free Software Foundation, Inc.
@


1.1
log
@Move frame specific register code to the new file frame.c.
@
text
@d27 1
@

