head	1.226;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.223
	gdb_7_6-2013-04-26-release:1.223
	gdb_7_6-branch:1.223.0.2
	gdb_7_6-2013-03-12-branchpoint:1.223
	gdb_7_5_1-2012-11-29-release:1.221
	gdb_7_5-2012-08-17-release:1.221
	gdb_7_5-branch:1.221.0.2
	gdb_7_5-2012-07-18-branchpoint:1.221
	gdb_7_4_1-2012-04-26-release:1.214.4.2
	gdb_7_4-2012-01-24-release:1.214.4.2
	gdb_7_4-branch:1.214.0.4
	gdb_7_4-2011-12-13-branchpoint:1.214
	gdb_7_3_1-2011-09-04-release:1.214
	gdb_7_3-2011-07-26-release:1.214
	gdb_7_3-branch:1.214.0.2
	gdb_7_3-2011-04-01-branchpoint:1.214
	gdb_7_2-2010-09-02-release:1.205
	gdb_7_2-branch:1.205.0.4
	gdb_7_2-2010-07-07-branchpoint:1.205
	gdb_7_1-2010-03-18-release:1.205
	gdb_7_1-branch:1.205.0.2
	gdb_7_1-2010-02-18-branchpoint:1.205
	gdb_7_0_1-2009-12-22-release:1.200.2.4
	gdb_7_0-2009-10-06-release:1.200.2.4
	gdb_7_0-branch:1.200.0.2
	gdb_7_0-2009-09-16-branchpoint:1.200
	arc-sim-20090309:1.172
	msnyder-checkpoint-072509-branch:1.194.0.2
	msnyder-checkpoint-072509-branchpoint:1.194
	arc-insight_6_8-branch:1.172.0.6
	arc-insight_6_8-branchpoint:1.172
	insight_6_8-branch:1.172.0.4
	insight_6_8-branchpoint:1.172
	reverse-20081226-branch:1.187.0.2
	reverse-20081226-branchpoint:1.187
	multiprocess-20081120-branch:1.185.0.2
	multiprocess-20081120-branchpoint:1.185
	reverse-20080930-branch:1.184.0.2
	reverse-20080930-branchpoint:1.184
	reverse-20080717-branch:1.180.0.2
	reverse-20080717-branchpoint:1.180
	msnyder-reverse-20080609-branch:1.179.0.2
	msnyder-reverse-20080609-branchpoint:1.179
	drow-reverse-20070409-branch:1.148.0.2
	drow-reverse-20070409-branchpoint:1.148
	gdb_6_8-2008-03-27-release:1.172
	gdb_6_8-branch:1.172.0.2
	gdb_6_8-2008-02-26-branchpoint:1.172
	gdb_6_7_1-2007-10-29-release:1.159.2.1
	gdb_6_7-2007-10-10-release:1.159.2.1
	gdb_6_7-branch:1.159.0.2
	gdb_6_7-2007-09-07-branchpoint:1.159
	insight_6_6-20070208-release:1.140
	gdb_6_6-2006-12-18-release:1.140
	gdb_6_6-branch:1.140.0.2
	gdb_6_6-2006-11-15-branchpoint:1.140
	insight_6_5-20061003-release:1.139
	gdb-csl-symbian-6_4_50_20060226-12:1.137.2.1.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.136
	nickrob-async-20060828-mergepoint:1.140
	gdb-csl-symbian-6_4_50_20060226-11:1.137.2.1.2.1
	gdb-csl-sourcerygxx-4_1-17:1.137.2.1
	gdb-csl-20060226-branch-local-2:1.137.2.1
	gdb-csl-sourcerygxx-4_1-14:1.137.2.1
	gdb-csl-sourcerygxx-4_1-13:1.137.2.1
	gdb-csl-sourcerygxx-4_1-12:1.137.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.137.2.1
	gdb_6_5-20060621-release:1.139
	gdb-csl-sourcerygxx-4_1-9:1.137.2.1
	gdb-csl-sourcerygxx-4_1-8:1.137.2.1
	gdb-csl-sourcerygxx-4_1-7:1.137.2.1
	gdb-csl-arm-2006q1-6:1.137.2.1
	gdb-csl-sourcerygxx-4_1-6:1.137.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.137.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.137.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.137.2.1.2.1
	gdb-csl-coldfire-4_1-11:1.137.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.137.2.1
	gdb-csl-coldfire-4_1-10:1.137.2.1
	gdb_6_5-branch:1.139.0.8
	gdb_6_5-2006-05-14-branchpoint:1.139
	gdb-csl-sourcerygxx-4_1-5:1.137.2.1
	nickrob-async-20060513-branch:1.139.0.6
	nickrob-async-20060513-branchpoint:1.139
	gdb-csl-sourcerygxx-4_1-4:1.137.2.1
	msnyder-reverse-20060502-branch:1.139.0.4
	msnyder-reverse-20060502-branchpoint:1.139
	gdb-csl-morpho-4_1-4:1.137.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.137.2.1
	readline_5_1-import-branch:1.139.0.2
	readline_5_1-import-branchpoint:1.139
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.137.2.1
	gdb-csl-symbian-20060226-branch:1.137.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.137.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.137.2.1
	msnyder-reverse-20060331-branch:1.138.0.2
	msnyder-reverse-20060331-branchpoint:1.138
	gdb-csl-available-20060303-branch:1.137.0.4
	gdb-csl-available-20060303-branchpoint:1.137
	gdb-csl-20060226-branch:1.137.0.2
	gdb-csl-20060226-branchpoint:1.137
	gdb_6_4-20051202-release:1.135
	msnyder-fork-checkpoint-branch:1.136.0.4
	msnyder-fork-checkpoint-branchpoint:1.136
	gdb-csl-gxxpro-6_3-branch:1.136.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.136
	gdb_6_4-branch:1.135.0.4
	gdb_6_4-2005-11-01-branchpoint:1.135
	gdb-csl-arm-20051020-branch:1.135.0.2
	gdb-csl-arm-20051020-branchpoint:1.135
	msnyder-tracepoint-checkpoint-branch:1.132.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.132
	gdb-csl-arm-20050325-2005-q1b:1.129
	gdb-csl-arm-20050325-2005-q1a:1.129
	csl-arm-20050325-branch:1.129.0.2
	csl-arm-20050325-branchpoint:1.129
	gdb-post-i18n-errorwarning-20050211:1.129
	gdb-pre-i18n-errorwarning-20050211:1.128
	gdb_6_3-20041109-release:1.124
	gdb_6_3-branch:1.124.0.4
	gdb_6_3-20041019-branchpoint:1.124
	drow_intercu-merge-20040921:1.124
	drow_intercu-merge-20040915:1.124
	jimb-gdb_6_2-e500-branch:1.124.0.6
	jimb-gdb_6_2-e500-branchpoint:1.124
	gdb_6_2-20040730-release:1.124
	gdb_6_2-branch:1.124.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.124
	gdb_6_1_1-20040616-release:1.117
	gdb_6_1-2004-04-05-release:1.117
	drow_intercu-merge-20040402:1.118
	drow_intercu-merge-20040327:1.118
	ezannoni_pie-20040323-branch:1.118.0.2
	ezannoni_pie-20040323-branchpoint:1.118
	cagney_tramp-20040321-mergepoint:1.117
	cagney_tramp-20040309-branch:1.117.0.4
	cagney_tramp-20040309-branchpoint:1.117
	gdb_6_1-branch:1.117.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.117
	drow_intercu-20040221-branch:1.116.0.2
	drow_intercu-20040221-branchpoint:1.116
	cagney_bfdfile-20040213-branch:1.113.0.2
	cagney_bfdfile-20040213-branchpoint:1.113
	drow-cplus-merge-20040208:1.111
	carlton_dictionary-20040126-merge:1.109
	cagney_bigcore-20040122-branch:1.109.0.2
	cagney_bigcore-20040122-branchpoint:1.109
	drow-cplus-merge-20040113:1.107
	drow-cplus-merge-20031224:1.106
	drow-cplus-merge-20031220:1.106
	carlton_dictionary-20031215-merge:1.106
	drow-cplus-merge-20031214:1.106
	carlton-dictionary-20031111-merge:1.103
	gdb_6_0-2003-10-04-release:1.89.2.4
	kettenis_sparc-20030918-branch:1.97.0.4
	kettenis_sparc-20030918-branchpoint:1.97
	carlton_dictionary-20030917-merge:1.97
	ezannoni_pie-20030916-branchpoint:1.97
	ezannoni_pie-20030916-branch:1.97.0.2
	cagney_x86i386-20030821-branch:1.92.0.2
	cagney_x86i386-20030821-branchpoint:1.92
	carlton_dictionary-20030805-merge:1.92
	carlton_dictionary-20030627-merge:1.90
	gdb_6_0-branch:1.89.0.2
	gdb_6_0-2003-06-23-branchpoint:1.89
	jimb-ppc64-linux-20030613-branch:1.87.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.87
	cagney_convert-20030606-branch:1.80.0.2
	cagney_convert-20030606-branchpoint:1.80
	cagney_writestrings-20030508-branch:1.75.0.4
	cagney_writestrings-20030508-branchpoint:1.75
	jimb-ppc64-linux-20030528-branch:1.79.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.79
	carlton_dictionary-20030523-merge:1.79
	cagney_fileio-20030521-branch:1.79.0.2
	cagney_fileio-20030521-branchpoint:1.79
	kettenis_i386newframe-20030517-mergepoint:1.79
	jimb-ppc64-linux-20030509-branch:1.75.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.75
	kettenis_i386newframe-20030504-mergepoint:1.72
	carlton_dictionary-20030430-merge:1.72
	kettenis_i386newframe-20030419-branch:1.69.0.2
	kettenis_i386newframe-20030419-branchpoint:1.69
	carlton_dictionary-20030416-merge:1.69
	cagney_frameaddr-20030409-mergepoint:1.68
	kettenis_i386newframe-20030406-branch:1.67.0.2
	kettenis_i386newframe-20030406-branchpoint:1.67
	cagney_frameaddr-20030403-branchpoint:1.66
	cagney_frameaddr-20030403-branch:1.66.0.2
	cagney_framebase-20030330-mergepoint:1.61
	cagney_framebase-20030326-branch:1.58.0.2
	cagney_framebase-20030326-branchpoint:1.58
	cagney_lazyid-20030317-branch:1.55.0.2
	cagney_lazyid-20030317-branchpoint:1.55
	kettenis-i386newframe-20030316-mergepoint:1.55
	offbyone-20030313-branch:1.53.0.2
	offbyone-20030313-branchpoint:1.53
	kettenis-i386newframe-20030308-branch:1.52.0.4
	kettenis-i386newframe-20030308-branchpoint:1.52
	carlton_dictionary-20030305-merge:1.52
	cagney_offbyone-20030303-branch:1.52.0.2
	cagney_offbyone-20030303-branchpoint:1.52
	carlton_dictionary-20030207-merge:1.48
	interps-20030203-mergepoint:1.48
	interps-20030202-branch:1.48.0.4
	interps-20030202-branchpoint:1.48
	cagney-unwind-20030108-branch:1.48.0.2
	cagney-unwind-20030108-branchpoint:1.48
	carlton_dictionary-20021223-merge:1.41
	gdb_5_3-2002-12-12-release:1.33
	carlton_dictionary-20021115-merge:1.37
	kseitz_interps-20021105-merge:1.35
	kseitz_interps-20021103-merge:1.35
	drow-cplus-merge-20021020:1.34
	drow-cplus-merge-20021025:1.34
	carlton_dictionary-20021025-merge:1.34
	carlton_dictionary-20021011-merge:1.34
	drow-cplus-branch:1.34.0.4
	drow-cplus-branchpoint:1.34
	kseitz_interps-20020930-merge:1.34
	carlton_dictionary-20020927-merge:1.34
	carlton_dictionary-branch:1.34.0.2
	carlton_dictionary-20020920-branchpoint:1.34
	gdb_5_3-branch:1.33.0.6
	gdb_5_3-2002-09-04-branchpoint:1.33
	kseitz_interps-20020829-merge:1.33
	cagney_sysregs-20020825-branch:1.33.0.4
	cagney_sysregs-20020825-branchpoint:1.33
	readline_4_3-import-branch:1.33.0.2
	readline_4_3-import-branchpoint:1.33
	gdb_5_2_1-2002-07-23-release:1.26
	kseitz_interps-20020528-branch:1.30.0.4
	kseitz_interps-20020528-branchpoint:1.30
	cagney_regbuf-20020515-branch:1.30.0.2
	cagney_regbuf-20020515-branchpoint:1.30
	jimb-macro-020506-branch:1.29.0.2
	jimb-macro-020506-branchpoint:1.29
	gdb_5_2-2002-04-29-release:1.26
	gdb_5_2-branch:1.26.0.2
	gdb_5_2-2002-03-03-branchpoint:1.26
	gdb_5_1_1-2002-01-24-release:1.21
	gdb_5_1_0_1-2002-01-03-release:1.21
	cygnus_cvs_20020108_pre:1.24
	gdb_5_1_0_1-2002-01-03-branchpoint:1.21
	gdb_5_1_0_1-2002-01-03-branch:1.21.0.6
	gdb_5_1-2001-11-21-release:1.21
	gdb_s390-2001-09-26-branch:1.21.0.4
	gdb_s390-2001-09-26-branchpoint:1.21
	gdb_5_1-2001-07-29-branch:1.21.0.2
	gdb_5_1-2001-07-29-branchpoint:1.21
	dberlin-typesystem-branch:1.20.0.2
	dberlin-typesystem-branchpoint:1.20
	gdb-post-ptid_t-2001-05-03:1.18
	gdb-pre-ptid_t-2001-05-03:1.17
	insight-precleanup-2001-01-01:1.11
	gdb-post-protoization-2000-07-29:1.8
	gdb-pre-protoization-2000-07-29:1.7
	gdb-premipsmulti-2000-06-06-branch:1.7.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.7
	gdb-post-params-removal-2000-06-04:1.7
	gdb-pre-params-removal-2000-06-04:1.7
	gdb-post-params-removal-2000-05-28:1.7
	gdb-pre-params-removal-2000-05-28:1.7
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.226
date	2013.05.01.14.31.55;	author brobecke;	state Exp;
branches;
next	1.225;

1.225
date	2013.04.19.15.09.46;	author palves;	state Exp;
branches;
next	1.224;

1.224
date	2013.04.08.19.59.09;	author tromey;	state Exp;
branches;
next	1.223;

1.223
date	2013.03.01.15.38.25;	author palves;	state Exp;
branches;
next	1.222;

1.222
date	2013.01.01.06.32.45;	author brobecke;	state Exp;
branches;
next	1.221;

1.221
date	2012.05.18.21.02.48;	author sergiodj;	state Exp;
branches;
next	1.220;

1.220
date	2012.05.16.14.35.04;	author macro;	state Exp;
branches;
next	1.219;

1.219
date	2012.03.08.19.08.11;	author jkratoch;	state Exp;
branches;
next	1.218;

1.218
date	2012.03.05.11.41.51;	author gingold;	state Exp;
branches;
next	1.217;

1.217
date	2012.02.21.19.39.32;	author palves;	state Exp;
branches;
next	1.216;

1.216
date	2012.01.04.08.17.04;	author brobecke;	state Exp;
branches;
next	1.215;

1.215
date	2011.12.14.14.55.27;	author palves;	state Exp;
branches;
next	1.214;

1.214
date	2011.03.18.18.52.30;	author palves;	state Exp;
branches
	1.214.4.1;
next	1.213;

1.213
date	2011.03.18.18.42.41;	author palves;	state Exp;
branches;
next	1.212;

1.212
date	2011.03.18.18.38.43;	author palves;	state Exp;
branches;
next	1.211;

1.211
date	2011.01.13.16.24.42;	author brobecke;	state Exp;
branches;
next	1.210;

1.210
date	2011.01.13.16.24.27;	author brobecke;	state Exp;
branches;
next	1.209;

1.209
date	2011.01.13.16.23.00;	author brobecke;	state Exp;
branches;
next	1.208;

1.208
date	2011.01.13.16.22.48;	author brobecke;	state Exp;
branches;
next	1.207;

1.207
date	2011.01.09.03.08.56;	author msnyder;	state Exp;
branches;
next	1.206;

1.206
date	2011.01.01.15.33.08;	author brobecke;	state Exp;
branches;
next	1.205;

1.205
date	2010.01.01.07.31.36;	author brobecke;	state Exp;
branches;
next	1.204;

1.204
date	2009.09.29.16.27.05;	author jkratoch;	state Exp;
branches;
next	1.203;

1.203
date	2009.09.29.01.25.37;	author brobecke;	state Exp;
branches;
next	1.202;

1.202
date	2009.09.28.23.54.01;	author brobecke;	state Exp;
branches;
next	1.201;

1.201
date	2009.09.28.23.47.02;	author brobecke;	state Exp;
branches;
next	1.200;

1.200
date	2009.09.13.16.28.28;	author brobecke;	state Exp;
branches
	1.200.2.1;
next	1.199;

1.199
date	2009.09.08.18.07.23;	author jkratoch;	state Exp;
branches;
next	1.198;

1.198
date	2009.09.08.17.52.27;	author jkratoch;	state Exp;
branches;
next	1.197;

1.197
date	2009.09.08.17.39.21;	author jkratoch;	state Exp;
branches;
next	1.196;

1.196
date	2009.08.25.14.06.47;	author jkratoch;	state Exp;
branches;
next	1.195;

1.195
date	2009.07.30.16.29.53;	author hjl;	state Exp;
branches;
next	1.194;

1.194
date	2009.07.02.17.25.55;	author uweigand;	state Exp;
branches;
next	1.193;

1.193
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.192;

1.192
date	2009.07.02.12.55.30;	author uweigand;	state Exp;
branches;
next	1.191;

1.191
date	2009.07.02.12.48.54;	author uweigand;	state Exp;
branches;
next	1.190;

1.190
date	2009.04.21.11.38.38;	author muller;	state Exp;
branches;
next	1.189;

1.189
date	2009.02.22.01.02.17;	author palves;	state Exp;
branches;
next	1.188;

1.188
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.187;

1.187
date	2008.12.05.18.25.01;	author jkratoch;	state Exp;
branches;
next	1.186;

1.186
date	2008.11.26.05.27.48;	author jkratoch;	state Exp;
branches;
next	1.185;

1.185
date	2008.11.13.05.05.07;	author brobecke;	state Exp;
branches;
next	1.184;

1.184
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.183;

1.183
date	2008.09.04.22.49.28;	author devans;	state Exp;
branches;
next	1.182;

1.182
date	2008.09.02.09.32.56;	author schwab;	state Exp;
branches;
next	1.181;

1.181
date	2008.08.21.13.19.18;	author palves;	state Exp;
branches;
next	1.180;

1.180
date	2008.07.15.18.45.42;	author drow;	state Exp;
branches;
next	1.179;

1.179
date	2008.05.29.00.19.33;	author brobecke;	state Exp;
branches;
next	1.178;

1.178
date	2008.05.06.20.03.03;	author brobecke;	state Exp;
branches;
next	1.177;

1.177
date	2008.05.06.18.37.46;	author brobecke;	state Exp;
branches;
next	1.176;

1.176
date	2008.04.30.21.16.45;	author drow;	state Exp;
branches;
next	1.175;

1.175
date	2008.04.29.21.14.06;	author brobecke;	state Exp;
branches;
next	1.174;

1.174
date	2008.04.22.11.03.41;	author corinna;	state Exp;
branches;
next	1.173;

1.173
date	2008.03.31.03.38.48;	author drow;	state Exp;
branches;
next	1.172;

1.172
date	2008.02.20.14.31.40;	author deuling;	state Exp;
branches
	1.172.2.1;
next	1.171;

1.171
date	2008.01.11.13.20.00;	author deuling;	state Exp;
branches;
next	1.170;

1.170
date	2008.01.01.22.53.11;	author drow;	state Exp;
branches;
next	1.169;

1.169
date	2007.12.06.16.32.59;	author deuling;	state Exp;
branches;
next	1.168;

1.168
date	2007.11.09.05.32.19;	author deuling;	state Exp;
branches;
next	1.167;

1.167
date	2007.11.08.00.08.46;	author jsm28;	state Exp;
branches;
next	1.166;

1.166
date	2007.11.07.06.32.59;	author deuling;	state Exp;
branches;
next	1.165;

1.165
date	2007.11.02.14.27.14;	author uweigand;	state Exp;
branches;
next	1.164;

1.164
date	2007.10.24.20.29.14;	author drow;	state Exp;
branches;
next	1.163;

1.163
date	2007.10.13.00.49.15;	author uweigand;	state Exp;
branches;
next	1.162;

1.162
date	2007.10.13.00.05.07;	author uweigand;	state Exp;
branches;
next	1.161;

1.161
date	2007.10.08.12.51.54;	author uweigand;	state Exp;
branches;
next	1.160;

1.160
date	2007.09.18.23.46.04;	author brobecke;	state Exp;
branches;
next	1.159;

1.159
date	2007.08.23.18.08.35;	author brobecke;	state Exp;
branches
	1.159.2.1;
next	1.158;

1.158
date	2007.06.18.18.58.13;	author uweigand;	state Exp;
branches;
next	1.157;

1.157
date	2007.06.18.18.28.29;	author uweigand;	state Exp;
branches;
next	1.156;

1.156
date	2007.06.18.17.56.32;	author uweigand;	state Exp;
branches;
next	1.155;

1.155
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.154;

1.154
date	2007.06.15.22.44.55;	author uweigand;	state Exp;
branches;
next	1.153;

1.153
date	2007.06.15.22.34.13;	author uweigand;	state Exp;
branches;
next	1.152;

1.152
date	2007.06.12.15.21.27;	author schwab;	state Exp;
branches;
next	1.151;

1.151
date	2007.05.12.00.07.45;	author uweigand;	state Exp;
branches;
next	1.150;

1.150
date	2007.05.11.19.16.04;	author uweigand;	state Exp;
branches;
next	1.149;

1.149
date	2007.05.06.14.34.37;	author uweigand;	state Exp;
branches;
next	1.148;

1.148
date	2007.03.28.18.56.06;	author uweigand;	state Exp;
branches;
next	1.147;

1.147
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.146;

1.146
date	2007.02.16.21.49.59;	author drow;	state Exp;
branches;
next	1.145;

1.145
date	2007.01.29.17.31.06;	author drow;	state Exp;
branches;
next	1.144;

1.144
date	2007.01.21.17.37.51;	author drow;	state Exp;
branches;
next	1.143;

1.143
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.142;

1.142
date	2007.01.03.18.05.43;	author drow;	state Exp;
branches;
next	1.141;

1.141
date	2006.12.28.23.48.51;	author drow;	state Exp;
branches;
next	1.140;

1.140
date	2006.07.12.18.13.45;	author drow;	state Exp;
branches;
next	1.139;

1.139
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches
	1.139.6.1;
next	1.138;

1.138
date	2006.03.08.15.28.17;	author schwab;	state Exp;
branches;
next	1.137;

1.137
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches
	1.137.2.1
	1.137.4.1;
next	1.136;

1.136
date	2005.11.08.01.42.53;	author kevinb;	state Exp;
branches;
next	1.135;

1.135
date	2005.09.10.18.11.02;	author drow;	state Exp;
branches;
next	1.134;

1.134
date	2005.06.10.01.09.18;	author jjohnstn;	state Exp;
branches;
next	1.133;

1.133
date	2005.06.08.21.54.22;	author jjohnstn;	state Exp;
branches;
next	1.132;

1.132
date	2005.05.19.16.37.09;	author cagney;	state Exp;
branches;
next	1.131;

1.131
date	2005.05.01.19.58.54;	author cagney;	state Exp;
branches;
next	1.130;

1.130
date	2005.04.18.19.34.19;	author msnyder;	state Exp;
branches;
next	1.129;

1.129
date	2005.02.11.04.05.51;	author cagney;	state Exp;
branches;
next	1.128;

1.128
date	2005.02.07.00.09.53;	author cagney;	state Exp;
branches;
next	1.127;

1.127
date	2005.01.05.22.51.47;	author schwab;	state Exp;
branches;
next	1.126;

1.126
date	2005.01.05.17.01.58;	author kevinb;	state Exp;
branches;
next	1.125;

1.125
date	2004.11.13.02.15.32;	author cagney;	state Exp;
branches;
next	1.124;

1.124
date	2004.06.20.17.18.05;	author cagney;	state Exp;
branches;
next	1.123;

1.123
date	2004.06.07.02.02.50;	author tausq;	state Exp;
branches;
next	1.122;

1.122
date	2004.05.18.21.20.26;	author drow;	state Exp;
branches;
next	1.121;

1.121
date	2004.04.30.23.47.56;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2004.04.14.15.18.05;	author schwab;	state Exp;
branches;
next	1.119;

1.119
date	2004.04.07.22.35.21;	author kevinb;	state Exp;
branches;
next	1.118;

1.118
date	2004.03.23.14.47.56;	author cagney;	state Exp;
branches;
next	1.117;

1.117
date	2004.02.24.22.35.01;	author kevinb;	state Exp;
branches;
next	1.116;

1.116
date	2004.02.17.16.23.23;	author cagney;	state Exp;
branches
	1.116.2.1;
next	1.115;

1.115
date	2004.02.17.15.21.21;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2004.02.14.15.46.33;	author ezannoni;	state Exp;
branches;
next	1.113;

1.113
date	2004.02.11.15.40.27;	author cagney;	state Exp;
branches;
next	1.112;

1.112
date	2004.02.10.19.35.59;	author jjohnstn;	state Exp;
branches;
next	1.111;

1.111
date	2004.02.03.22.21.36;	author cagney;	state Exp;
branches;
next	1.110;

1.110
date	2004.01.26.20.52.10;	author cagney;	state Exp;
branches;
next	1.109;

1.109
date	2004.01.17.15.34.11;	author cagney;	state Exp;
branches;
next	1.108;

1.108
date	2004.01.13.21.38.46;	author cagney;	state Exp;
branches;
next	1.107;

1.107
date	2004.01.05.19.53.06;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2003.12.13.03.51.56;	author kevinb;	state Exp;
branches;
next	1.105;

1.105
date	2003.12.06.00.17.04;	author jjohnstn;	state Exp;
branches;
next	1.104;

1.104
date	2003.11.17.21.38.36;	author jjohnstn;	state Exp;
branches;
next	1.103;

1.103
date	2003.11.06.02.52.27;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2003.11.05.20.32.42;	author jjohnstn;	state Exp;
branches;
next	1.101;

1.101
date	2003.10.23.22.06.37;	author jjohnstn;	state Exp;
branches;
next	1.100;

1.100
date	2003.10.22.23.54.11;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2003.10.20.20.38.07;	author jjohnstn;	state Exp;
branches;
next	1.98;

1.98
date	2003.10.02.20.28.29;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2003.09.09.23.29.52;	author jjohnstn;	state Exp;
branches;
next	1.96;

1.96
date	2003.09.09.04.41.32;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2003.08.26.22.24.40;	author jjohnstn;	state Exp;
branches;
next	1.94;

1.94
date	2003.08.26.17.33.22;	author jjohnstn;	state Exp;
branches;
next	1.93;

1.93
date	2003.08.25.23.27.48;	author jjohnstn;	state Exp;
branches;
next	1.92;

1.92
date	2003.07.23.18.32.19;	author schwab;	state Exp;
branches;
next	1.91;

1.91
date	2003.07.01.22.32.36;	author schwab;	state Exp;
branches;
next	1.90;

1.90
date	2003.06.26.17.18.42;	author cagney;	state Exp;
branches;
next	1.89;

1.89
date	2003.06.16.16.47.42;	author cagney;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2003.06.15.00.27.54;	author cagney;	state Exp;
branches;
next	1.87;

1.87
date	2003.06.13.04.40.32;	author cagney;	state Exp;
branches;
next	1.86;

1.86
date	2003.06.11.22.03.16;	author jjohnstn;	state Exp;
branches;
next	1.85;

1.85
date	2003.06.11.19.38.26;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2003.06.11.13.16.27;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2003.06.09.17.35.57;	author cagney;	state Exp;
branches;
next	1.82;

1.82
date	2003.06.07.22.38.55;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2003.06.07.18.08.24;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.02.02.09.39;	author cagney;	state Exp;
branches;
next	1.79;

1.79
date	2003.05.17.05.59.58;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2003.05.15.22.58.38;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2003.05.15.21.38.37;	author jjohnstn;	state Exp;
branches;
next	1.76;

1.76
date	2003.05.13.19.27.28;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2003.05.08.20.52.47;	author cagney;	state Exp;
branches
	1.75.4.1;
next	1.74;

1.74
date	2003.05.08.03.48.03;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2003.05.05.17.56.55;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2003.04.30.22.01.37;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2003.04.28.16.17.28;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2003.04.11.18.15.38;	author cagney;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2003.04.09.15.08.26;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.04.05.18.54.38;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2003.04.01.17.17.29;	author cagney;	state Exp;
branches
	1.66.2.1;
next	1.65;

1.65
date	2003.04.01.14.38.49;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2003.03.31.23.52.38;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2003.03.31.21.58.21;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2003.03.31.19.01.20;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2003.03.30.14.59.00;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2003.03.30.14.32.09;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2003.03.26.22.39.52;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2003.03.25.20.38.46;	author cagney;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2003.03.25.18.54.15;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2003.03.24.03.54.48;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2003.03.14.16.05.35;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2003.03.13.21.45.40;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2003.03.12.16.50.44;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2003.03.03.20.50.19;	author cagney;	state Exp;
branches
	1.52.4.1;
next	1.51;

1.51
date	2003.03.02.04.02.23;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2003.03.02.00.11.42;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2003.02.27.17.48.47;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2003.01.08.17.21.28;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2003.01.08.15.56.37;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2003.01.08.01.53.37;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2003.01.07.14.51.10;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2003.01.05.01.39.54;	author drow;	state Exp;
branches;
next	1.43;

1.43
date	2003.01.03.23.53.48;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.02.22.20.46;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2002.12.11.02.26.36;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2002.12.01.19.07.15;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.28.18.15.58;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.18.22.19.28;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.14.20.37.28;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.14.00.25.03;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.01.21.21.49;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2002.09.17.20.42.01;	author cagney;	state Exp;
branches
	1.34.2.1
	1.34.4.1;
next	1.33;

1.33
date	2002.08.24.00.21.34;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.17.23.32.31;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.14.22.55.40;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.10.16.08.24;	author petrs;	state Exp;
branches
	1.30.2.1
	1.30.4.1;
next	1.29;

1.29
date	2002.04.18.18.09.01;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.06.00.02.50;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.16.21.09.33;	author schauer;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.24.22.31.19;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.18.05.53.04;	author kevinb;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.21.17.19.37;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.31.19.58.40;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.01.18.39.23;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.02.01.37.20;	author kevinb;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.06.01.02.39.51;	author kevinb;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.27.02.45.54;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.22.02.11.11;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.22.03.01.27;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.21.05.20.35;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.20.23.46.36;	author hjl;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.08.04.12.40;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.06.07.43.37;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.02.17.57.02;	author hjl;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.26.07.16.15;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.25.23.18.35;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.25.06.36.51;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.03.18.58.48;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.23.04.27.26;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.21.00.11.10;	author kevinb;	state Exp;
branches;
next	;

1.214.4.1
date	2011.12.14.14.56.23;	author palves;	state Exp;
branches;
next	1.214.4.2;

1.214.4.2
date	2012.01.06.04.43.16;	author brobecke;	state Exp;
branches;
next	;

1.200.2.1
date	2009.09.28.23.56.52;	author brobecke;	state Exp;
branches;
next	1.200.2.2;

1.200.2.2
date	2009.09.28.23.59.23;	author brobecke;	state Exp;
branches;
next	1.200.2.3;

1.200.2.3
date	2009.09.29.01.29.10;	author brobecke;	state Exp;
branches;
next	1.200.2.4;

1.200.2.4
date	2009.09.29.19.09.39;	author jkratoch;	state Exp;
branches;
next	;

1.172.2.1
date	2008.03.31.03.40.42;	author drow;	state Exp;
branches;
next	;

1.159.2.1
date	2007.09.18.23.53.07;	author brobecke;	state Exp;
branches;
next	;

1.139.6.1
date	2006.08.28.07.48.48;	author nickrob;	state Exp;
branches;
next	;

1.137.2.1
date	2006.04.03.00.47.39;	author drow;	state Exp;
branches
	1.137.2.1.2.1;
next	;

1.137.2.1.2.1
date	2006.04.11.21.58.23;	author drow;	state Exp;
branches;
next	;

1.137.4.1
date	2006.03.03.20.46.37;	author drow;	state Exp;
branches;
next	;

1.116.2.1
date	2004.03.27.17.37.49;	author drow;	state Exp;
branches;
next	1.116.2.2;

1.116.2.2
date	2004.09.16.17.01.08;	author drow;	state Exp;
branches;
next	;

1.89.2.1
date	2003.07.01.22.35.46;	author schwab;	state Exp;
branches;
next	1.89.2.2;

1.89.2.2
date	2003.07.23.18.33.22;	author schwab;	state Exp;
branches;
next	1.89.2.3;

1.89.2.3
date	2003.08.27.18.25.20;	author jjohnstn;	state Exp;
branches;
next	1.89.2.4;

1.89.2.4
date	2003.09.10.00.06.20;	author jjohnstn;	state Exp;
branches;
next	;

1.75.4.1
date	2003.06.03.20.54.37;	author cagney;	state Exp;
branches;
next	;

1.69.2.1
date	2003.05.04.11.37.42;	author kettenis;	state Exp;
branches;
next	1.69.2.2;

1.69.2.2
date	2003.05.18.09.44.12;	author kettenis;	state Exp;
branches;
next	;

1.66.2.1
date	2003.04.10.21.33.48;	author cagney;	state Exp;
branches;
next	;

1.58.2.1
date	2003.03.30.16.35.21;	author cagney;	state Exp;
branches;
next	;

1.52.4.1
date	2003.03.16.14.01.49;	author kettenis;	state Exp;
branches;
next	;

1.34.2.1
date	2002.11.15.19.18.49;	author carlton;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2002.12.23.19.38.30;	author carlton;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2003.02.07.19.17.49;	author carlton;	state Exp;
branches;
next	1.34.2.4;

1.34.2.4
date	2003.03.06.00.56.29;	author carlton;	state Exp;
branches;
next	1.34.2.5;

1.34.2.5
date	2003.04.16.19.56.52;	author carlton;	state Exp;
branches;
next	1.34.2.6;

1.34.2.6
date	2003.05.01.00.46.50;	author carlton;	state Exp;
branches;
next	1.34.2.7;

1.34.2.7
date	2003.05.23.18.40.40;	author carlton;	state Exp;
branches;
next	1.34.2.8;

1.34.2.8
date	2003.06.27.21.49.58;	author carlton;	state Exp;
branches;
next	1.34.2.9;

1.34.2.9
date	2003.08.05.17.13.10;	author carlton;	state Exp;
branches;
next	1.34.2.10;

1.34.2.10
date	2003.09.17.21.28.22;	author carlton;	state Exp;
branches;
next	1.34.2.11;

1.34.2.11
date	2003.11.11.23.50.46;	author carlton;	state Exp;
branches;
next	1.34.2.12;

1.34.2.12
date	2003.12.16.00.00.37;	author carlton;	state Exp;
branches;
next	1.34.2.13;

1.34.2.13
date	2004.01.26.19.11.26;	author carlton;	state Exp;
branches;
next	;

1.34.4.1
date	2003.12.14.20.27.19;	author drow;	state Exp;
branches;
next	1.34.4.2;

1.34.4.2
date	2004.01.13.16.11.57;	author drow;	state Exp;
branches;
next	1.34.4.3;

1.34.4.3
date	2004.02.09.19.43.41;	author drow;	state Exp;
branches;
next	;

1.30.2.1
date	2002.06.15.16.42.52;	author cagney;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2002.06.21.16.19.26;	author cagney;	state Exp;
branches;
next	;

1.30.4.1
date	2002.06.20.01.32.36;	author kseitz;	state Exp;
branches;
next	1.30.4.2;

1.30.4.2
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	1.30.4.3;

1.30.4.3
date	2002.10.01.00.46.09;	author kseitz;	state Exp;
branches;
next	1.30.4.4;

1.30.4.4
date	2002.11.04.00.17.31;	author ezannoni;	state Exp;
branches;
next	;

1.20.2.1
date	2001.07.06.19.17.00;	author dberlin;	state Exp;
branches;
next	;


desc
@@


1.226
log
@Fix -Wpointer-sign errors in ia64-tdep.c

gdb/ChangeLog:

        * ia64-tdep.c (ia64_access_fpreg): Change cast of val
        from "char *" to "gdb_byte *".
        (ia64_access_rse_fpreg, ia64_access_mem): Likewise.
@
text
@/* Target-dependent code for the IA-64 for GDB, the GNU debugger.

   Copyright (C) 1999-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "inferior.h"
#include "gdbcore.h"
#include "arch-utils.h"
#include "floatformat.h"
#include "gdbtypes.h"
#include "regcache.h"
#include "reggroups.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "doublest.h"
#include "value.h"
#include "gdb_assert.h"
#include "objfiles.h"
#include "elf/common.h"		/* for DT_PLTGOT value */
#include "elf-bfd.h"
#include "dis-asm.h"
#include "infcall.h"
#include "osabi.h"
#include "ia64-tdep.h"
#include "cp-abi.h"

#ifdef HAVE_LIBUNWIND_IA64_H
#include "elf/ia64.h"           /* for PT_IA_64_UNWIND value */
#include "ia64-libunwind-tdep.h"

/* Note: KERNEL_START is supposed to be an address which is not going
         to ever contain any valid unwind info.  For ia64 linux, the choice
         of 0xc000000000000000 is fairly safe since that's uncached space.
 
         We use KERNEL_START as follows: after obtaining the kernel's
         unwind table via getunwind(), we project its unwind data into
         address-range KERNEL_START-(KERNEL_START+ktab_size) and then
         when ia64_access_mem() sees a memory access to this
         address-range, we redirect it to ktab instead.

         None of this hackery is needed with a modern kernel/libcs
         which uses the kernel virtual DSO to provide access to the
         kernel's unwind info.  In that case, ktab_size remains 0 and
         hence the value of KERNEL_START doesn't matter.  */

#define KERNEL_START 0xc000000000000000ULL

static size_t ktab_size = 0;
struct ia64_table_entry
  {
    uint64_t start_offset;
    uint64_t end_offset;
    uint64_t info_offset;
  };

static struct ia64_table_entry *ktab = NULL;

#endif

/* An enumeration of the different IA-64 instruction types.  */

typedef enum instruction_type
{
  A,			/* Integer ALU ;    I-unit or M-unit */
  I,			/* Non-ALU integer; I-unit */
  M,			/* Memory ;         M-unit */
  F,			/* Floating-point ; F-unit */
  B,			/* Branch ;         B-unit */
  L,			/* Extended (L+X) ; I-unit */
  X,			/* Extended (L+X) ; I-unit */
  undefined		/* undefined or reserved */
} instruction_type;

/* We represent IA-64 PC addresses as the value of the instruction
   pointer or'd with some bit combination in the low nibble which
   represents the slot number in the bundle addressed by the
   instruction pointer.  The problem is that the Linux kernel
   multiplies its slot numbers (for exceptions) by one while the
   disassembler multiplies its slot numbers by 6.  In addition, I've
   heard it said that the simulator uses 1 as the multiplier.
   
   I've fixed the disassembler so that the bytes_per_line field will
   be the slot multiplier.  If bytes_per_line comes in as zero, it
   is set to six (which is how it was set up initially). -- objdump
   displays pretty disassembly dumps with this value.  For our purposes,
   we'll set bytes_per_line to SLOT_MULTIPLIER. This is okay since we
   never want to also display the raw bytes the way objdump does.  */

#define SLOT_MULTIPLIER 1

/* Length in bytes of an instruction bundle.  */

#define BUNDLE_LEN 16

/* See the saved memory layout comment for ia64_memory_insert_breakpoint.  */

#if BREAKPOINT_MAX < BUNDLE_LEN - 2
# error "BREAKPOINT_MAX < BUNDLE_LEN - 2"
#endif

static gdbarch_init_ftype ia64_gdbarch_init;

static gdbarch_register_name_ftype ia64_register_name;
static gdbarch_register_type_ftype ia64_register_type;
static gdbarch_breakpoint_from_pc_ftype ia64_breakpoint_from_pc;
static gdbarch_skip_prologue_ftype ia64_skip_prologue;
static struct type *is_float_or_hfa_type (struct type *t);
static CORE_ADDR ia64_find_global_pointer (struct gdbarch *gdbarch,
					   CORE_ADDR faddr);

#define NUM_IA64_RAW_REGS 462

static int sp_regnum = IA64_GR12_REGNUM;
static int fp_regnum = IA64_VFP_REGNUM;
static int lr_regnum = IA64_VRAP_REGNUM;

/* NOTE: we treat the register stack registers r32-r127 as
   pseudo-registers because they may not be accessible via the ptrace
   register get/set interfaces.  */

enum pseudo_regs { FIRST_PSEUDO_REGNUM = NUM_IA64_RAW_REGS,
		   VBOF_REGNUM = IA64_NAT127_REGNUM + 1, V32_REGNUM, 
		   V127_REGNUM = V32_REGNUM + 95, 
		   VP0_REGNUM, VP16_REGNUM = VP0_REGNUM + 16,
		   VP63_REGNUM = VP0_REGNUM + 63, LAST_PSEUDO_REGNUM };

/* Array of register names; There should be ia64_num_regs strings in
   the initializer.  */

static char *ia64_register_names[] = 
{ "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
  "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",
  "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",

  "f0",   "f1",   "f2",   "f3",   "f4",   "f5",   "f6",   "f7",
  "f8",   "f9",   "f10",  "f11",  "f12",  "f13",  "f14",  "f15",
  "f16",  "f17",  "f18",  "f19",  "f20",  "f21",  "f22",  "f23",
  "f24",  "f25",  "f26",  "f27",  "f28",  "f29",  "f30",  "f31",
  "f32",  "f33",  "f34",  "f35",  "f36",  "f37",  "f38",  "f39",
  "f40",  "f41",  "f42",  "f43",  "f44",  "f45",  "f46",  "f47",
  "f48",  "f49",  "f50",  "f51",  "f52",  "f53",  "f54",  "f55",
  "f56",  "f57",  "f58",  "f59",  "f60",  "f61",  "f62",  "f63",
  "f64",  "f65",  "f66",  "f67",  "f68",  "f69",  "f70",  "f71",
  "f72",  "f73",  "f74",  "f75",  "f76",  "f77",  "f78",  "f79",
  "f80",  "f81",  "f82",  "f83",  "f84",  "f85",  "f86",  "f87",
  "f88",  "f89",  "f90",  "f91",  "f92",  "f93",  "f94",  "f95",
  "f96",  "f97",  "f98",  "f99",  "f100", "f101", "f102", "f103",
  "f104", "f105", "f106", "f107", "f108", "f109", "f110", "f111",
  "f112", "f113", "f114", "f115", "f116", "f117", "f118", "f119",
  "f120", "f121", "f122", "f123", "f124", "f125", "f126", "f127",

  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",

  "b0",   "b1",   "b2",   "b3",   "b4",   "b5",   "b6",   "b7",

  "vfp", "vrap",

  "pr", "ip", "psr", "cfm",

  "kr0",   "kr1",   "kr2",   "kr3",   "kr4",   "kr5",   "kr6",   "kr7",
  "", "", "", "", "", "", "", "",
  "rsc", "bsp", "bspstore", "rnat",
  "", "fcr", "", "",
  "eflag", "csd", "ssd", "cflg", "fsr", "fir", "fdr",  "",
  "ccv", "", "", "", "unat", "", "", "",
  "fpsr", "", "", "", "itc",
  "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "",
  "pfs", "lc", "ec",
  "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "",
  "",
  "nat0",  "nat1",  "nat2",  "nat3",  "nat4",  "nat5",  "nat6",  "nat7",
  "nat8",  "nat9",  "nat10", "nat11", "nat12", "nat13", "nat14", "nat15",
  "nat16", "nat17", "nat18", "nat19", "nat20", "nat21", "nat22", "nat23",
  "nat24", "nat25", "nat26", "nat27", "nat28", "nat29", "nat30", "nat31",
  "nat32", "nat33", "nat34", "nat35", "nat36", "nat37", "nat38", "nat39",
  "nat40", "nat41", "nat42", "nat43", "nat44", "nat45", "nat46", "nat47",
  "nat48", "nat49", "nat50", "nat51", "nat52", "nat53", "nat54", "nat55",
  "nat56", "nat57", "nat58", "nat59", "nat60", "nat61", "nat62", "nat63",
  "nat64", "nat65", "nat66", "nat67", "nat68", "nat69", "nat70", "nat71",
  "nat72", "nat73", "nat74", "nat75", "nat76", "nat77", "nat78", "nat79",
  "nat80", "nat81", "nat82", "nat83", "nat84", "nat85", "nat86", "nat87",
  "nat88", "nat89", "nat90", "nat91", "nat92", "nat93", "nat94", "nat95",
  "nat96", "nat97", "nat98", "nat99", "nat100","nat101","nat102","nat103",
  "nat104","nat105","nat106","nat107","nat108","nat109","nat110","nat111",
  "nat112","nat113","nat114","nat115","nat116","nat117","nat118","nat119",
  "nat120","nat121","nat122","nat123","nat124","nat125","nat126","nat127",

  "bof",
  
  "r32",  "r33",  "r34",  "r35",  "r36",  "r37",  "r38",  "r39",   
  "r40",  "r41",  "r42",  "r43",  "r44",  "r45",  "r46",  "r47",
  "r48",  "r49",  "r50",  "r51",  "r52",  "r53",  "r54",  "r55",
  "r56",  "r57",  "r58",  "r59",  "r60",  "r61",  "r62",  "r63",
  "r64",  "r65",  "r66",  "r67",  "r68",  "r69",  "r70",  "r71",
  "r72",  "r73",  "r74",  "r75",  "r76",  "r77",  "r78",  "r79",
  "r80",  "r81",  "r82",  "r83",  "r84",  "r85",  "r86",  "r87",
  "r88",  "r89",  "r90",  "r91",  "r92",  "r93",  "r94",  "r95",
  "r96",  "r97",  "r98",  "r99",  "r100", "r101", "r102", "r103",
  "r104", "r105", "r106", "r107", "r108", "r109", "r110", "r111",
  "r112", "r113", "r114", "r115", "r116", "r117", "r118", "r119",
  "r120", "r121", "r122", "r123", "r124", "r125", "r126", "r127",

  "p0",   "p1",   "p2",   "p3",   "p4",   "p5",   "p6",   "p7",
  "p8",   "p9",   "p10",  "p11",  "p12",  "p13",  "p14",  "p15",
  "p16",  "p17",  "p18",  "p19",  "p20",  "p21",  "p22",  "p23",
  "p24",  "p25",  "p26",  "p27",  "p28",  "p29",  "p30",  "p31",
  "p32",  "p33",  "p34",  "p35",  "p36",  "p37",  "p38",  "p39",
  "p40",  "p41",  "p42",  "p43",  "p44",  "p45",  "p46",  "p47",
  "p48",  "p49",  "p50",  "p51",  "p52",  "p53",  "p54",  "p55",
  "p56",  "p57",  "p58",  "p59",  "p60",  "p61",  "p62",  "p63",
};

struct ia64_frame_cache
{
  CORE_ADDR base;       /* frame pointer base for frame */
  CORE_ADDR pc;		/* function start pc for frame */
  CORE_ADDR saved_sp;	/* stack pointer for frame */
  CORE_ADDR bsp;	/* points at r32 for the current frame */
  CORE_ADDR cfm;	/* cfm value for current frame */
  CORE_ADDR prev_cfm;   /* cfm value for previous frame */
  int   frameless;
  int   sof;		/* Size of frame  (decoded from cfm value).  */
  int	sol;		/* Size of locals (decoded from cfm value).  */
  int	sor;		/* Number of rotating registers (decoded from
			   cfm value).  */
  CORE_ADDR after_prologue;
  /* Address of first instruction after the last
     prologue instruction;  Note that there may
     be instructions from the function's body
     intermingled with the prologue.  */
  int mem_stack_frame_size;
  /* Size of the memory stack frame (may be zero),
     or -1 if it has not been determined yet.  */
  int	fp_reg;		/* Register number (if any) used a frame pointer
			   for this frame.  0 if no register is being used
			   as the frame pointer.  */
  
  /* Saved registers.  */
  CORE_ADDR saved_regs[NUM_IA64_RAW_REGS];

};

static int
floatformat_valid (const struct floatformat *fmt, const void *from)
{
  return 1;
}

static const struct floatformat floatformat_ia64_ext_little =
{
  floatformat_little, 82, 0, 1, 17, 65535, 0x1ffff, 18, 64,
  floatformat_intbit_yes, "floatformat_ia64_ext_little", floatformat_valid, NULL
};

static const struct floatformat floatformat_ia64_ext_big =
{
  floatformat_big, 82, 46, 47, 17, 65535, 0x1ffff, 64, 64,
  floatformat_intbit_yes, "floatformat_ia64_ext_big", floatformat_valid
};

static const struct floatformat *floatformats_ia64_ext[2] =
{
  &floatformat_ia64_ext_big,
  &floatformat_ia64_ext_little
};

static struct type *
ia64_ext_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->ia64_ext_type)
    tdep->ia64_ext_type
      = arch_float_type (gdbarch, 128, "builtin_type_ia64_ext",
			 floatformats_ia64_ext);

  return tdep->ia64_ext_type;
}

static int
ia64_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *group)
{
  int vector_p;
  int float_p;
  int raw_p;
  if (group == all_reggroup)
    return 1;
  vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));
  float_p = TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT;
  raw_p = regnum < NUM_IA64_RAW_REGS;
  if (group == float_reggroup)
    return float_p;
  if (group == vector_reggroup)
    return vector_p;
  if (group == general_reggroup)
    return (!vector_p && !float_p);
  if (group == save_reggroup || group == restore_reggroup)
    return raw_p; 
  return 0;
}

static const char *
ia64_register_name (struct gdbarch *gdbarch, int reg)
{
  return ia64_register_names[reg];
}

struct type *
ia64_register_type (struct gdbarch *arch, int reg)
{
  if (reg >= IA64_FR0_REGNUM && reg <= IA64_FR127_REGNUM)
    return ia64_ext_type (arch);
  else
    return builtin_type (arch)->builtin_long;
}

static int
ia64_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)
{
  if (reg >= IA64_GR32_REGNUM && reg <= IA64_GR127_REGNUM)
    return V32_REGNUM + (reg - IA64_GR32_REGNUM);
  return reg;
}


/* Extract ``len'' bits from an instruction bundle starting at
   bit ``from''.  */

static long long
extract_bit_field (const gdb_byte *bundle, int from, int len)
{
  long long result = 0LL;
  int to = from + len;
  int from_byte = from / 8;
  int to_byte = to / 8;
  unsigned char *b = (unsigned char *) bundle;
  unsigned char c;
  int lshift;
  int i;

  c = b[from_byte];
  if (from_byte == to_byte)
    c = ((unsigned char) (c << (8 - to % 8))) >> (8 - to % 8);
  result = c >> (from % 8);
  lshift = 8 - (from % 8);

  for (i = from_byte+1; i < to_byte; i++)
    {
      result |= ((long long) b[i]) << lshift;
      lshift += 8;
    }

  if (from_byte < to_byte && (to % 8 != 0))
    {
      c = b[to_byte];
      c = ((unsigned char) (c << (8 - to % 8))) >> (8 - to % 8);
      result |= ((long long) c) << lshift;
    }

  return result;
}

/* Replace the specified bits in an instruction bundle.  */

static void
replace_bit_field (gdb_byte *bundle, long long val, int from, int len)
{
  int to = from + len;
  int from_byte = from / 8;
  int to_byte = to / 8;
  unsigned char *b = (unsigned char *) bundle;
  unsigned char c;

  if (from_byte == to_byte)
    {
      unsigned char left, right;
      c = b[from_byte];
      left = (c >> (to % 8)) << (to % 8);
      right = ((unsigned char) (c << (8 - from % 8))) >> (8 - from % 8);
      c = (unsigned char) (val & 0xff);
      c = (unsigned char) (c << (from % 8 + 8 - to % 8)) >> (8 - to % 8);
      c |= right | left;
      b[from_byte] = c;
    }
  else
    {
      int i;
      c = b[from_byte];
      c = ((unsigned char) (c << (8 - from % 8))) >> (8 - from % 8);
      c = c | (val << (from % 8));
      b[from_byte] = c;
      val >>= 8 - from % 8;

      for (i = from_byte+1; i < to_byte; i++)
	{
	  c = val & 0xff;
	  val >>= 8;
	  b[i] = c;
	}

      if (to % 8 != 0)
	{
	  unsigned char cv = (unsigned char) val;
	  c = b[to_byte];
	  c = c >> (to % 8) << (to % 8);
	  c |= ((unsigned char) (cv << (8 - to % 8))) >> (8 - to % 8);
	  b[to_byte] = c;
	}
    }
}

/* Return the contents of slot N (for N = 0, 1, or 2) in
   and instruction bundle.  */

static long long
slotN_contents (gdb_byte *bundle, int slotnum)
{
  return extract_bit_field (bundle, 5+41*slotnum, 41);
}

/* Store an instruction in an instruction bundle.  */

static void
replace_slotN_contents (gdb_byte *bundle, long long instr, int slotnum)
{
  replace_bit_field (bundle, instr, 5+41*slotnum, 41);
}

static const enum instruction_type template_encoding_table[32][3] =
{
  { M, I, I },				/* 00 */
  { M, I, I },				/* 01 */
  { M, I, I },				/* 02 */
  { M, I, I },				/* 03 */
  { M, L, X },				/* 04 */
  { M, L, X },				/* 05 */
  { undefined, undefined, undefined },  /* 06 */
  { undefined, undefined, undefined },  /* 07 */
  { M, M, I },				/* 08 */
  { M, M, I },				/* 09 */
  { M, M, I },				/* 0A */
  { M, M, I },				/* 0B */
  { M, F, I },				/* 0C */
  { M, F, I },				/* 0D */
  { M, M, F },				/* 0E */
  { M, M, F },				/* 0F */
  { M, I, B },				/* 10 */
  { M, I, B },				/* 11 */
  { M, B, B },				/* 12 */
  { M, B, B },				/* 13 */
  { undefined, undefined, undefined },  /* 14 */
  { undefined, undefined, undefined },  /* 15 */
  { B, B, B },				/* 16 */
  { B, B, B },				/* 17 */
  { M, M, B },				/* 18 */
  { M, M, B },				/* 19 */
  { undefined, undefined, undefined },  /* 1A */
  { undefined, undefined, undefined },  /* 1B */
  { M, F, B },				/* 1C */
  { M, F, B },				/* 1D */
  { undefined, undefined, undefined },  /* 1E */
  { undefined, undefined, undefined },  /* 1F */
};

/* Fetch and (partially) decode an instruction at ADDR and return the
   address of the next instruction to fetch.  */

static CORE_ADDR
fetch_instruction (CORE_ADDR addr, instruction_type *it, long long *instr)
{
  gdb_byte bundle[BUNDLE_LEN];
  int slotnum = (int) (addr & 0x0f) / SLOT_MULTIPLIER;
  long long template;
  int val;

  /* Warn about slot numbers greater than 2.  We used to generate
     an error here on the assumption that the user entered an invalid
     address.  But, sometimes GDB itself requests an invalid address.
     This can (easily) happen when execution stops in a function for
     which there are no symbols.  The prologue scanner will attempt to
     find the beginning of the function - if the nearest symbol
     happens to not be aligned on a bundle boundary (16 bytes), the
     resulting starting address will cause GDB to think that the slot
     number is too large.

     So we warn about it and set the slot number to zero.  It is
     not necessarily a fatal condition, particularly if debugging
     at the assembly language level.  */
  if (slotnum > 2)
    {
      warning (_("Can't fetch instructions for slot numbers greater than 2.\n"
	       "Using slot 0 instead"));
      slotnum = 0;
    }

  addr &= ~0x0f;

  val = target_read_memory (addr, bundle, BUNDLE_LEN);

  if (val != 0)
    return 0;

  *instr = slotN_contents (bundle, slotnum);
  template = extract_bit_field (bundle, 0, 5);
  *it = template_encoding_table[(int)template][slotnum];

  if (slotnum == 2 || (slotnum == 1 && *it == L))
    addr += 16;
  else
    addr += (slotnum + 1) * SLOT_MULTIPLIER;

  return addr;
}

/* There are 5 different break instructions (break.i, break.b,
   break.m, break.f, and break.x), but they all have the same
   encoding.  (The five bit template in the low five bits of the
   instruction bundle distinguishes one from another.)
   
   The runtime architecture manual specifies that break instructions
   used for debugging purposes must have the upper two bits of the 21
   bit immediate set to a 0 and a 1 respectively.  A breakpoint
   instruction encodes the most significant bit of its 21 bit
   immediate at bit 36 of the 41 bit instruction.  The penultimate msb
   is at bit 25 which leads to the pattern below.  
   
   Originally, I had this set up to do, e.g, a "break.i 0x80000"  But
   it turns out that 0x80000 was used as the syscall break in the early
   simulators.  So I changed the pattern slightly to do "break.i 0x080001"
   instead.  But that didn't work either (I later found out that this
   pattern was used by the simulator that I was using.)  So I ended up
   using the pattern seen below.

   SHADOW_CONTENTS has byte-based addressing (PLACED_ADDRESS and SHADOW_LEN)
   while we need bit-based addressing as the instructions length is 41 bits and
   we must not modify/corrupt the adjacent slots in the same bundle.
   Fortunately we may store larger memory incl. the adjacent bits with the
   original memory content (not the possibly already stored breakpoints there).
   We need to be careful in ia64_memory_remove_breakpoint to always restore
   only the specific bits of this instruction ignoring any adjacent stored
   bits.

   We use the original addressing with the low nibble in the range <0..2> which
   gets incorrectly interpreted by generic non-ia64 breakpoint_restore_shadows
   as the direct byte offset of SHADOW_CONTENTS.  We store whole BUNDLE_LEN
   bytes just without these two possibly skipped bytes to not to exceed to the
   next bundle.

   If we would like to store the whole bundle to SHADOW_CONTENTS we would have
   to store already the base address (`address & ~0x0f') into PLACED_ADDRESS.
   In such case there is no other place where to store
   SLOTNUM (`adress & 0x0f', value in the range <0..2>).  We need to know
   SLOTNUM in ia64_memory_remove_breakpoint.

   There is one special case where we need to be extra careful:
   L-X instructions, which are instructions that occupy 2 slots
   (The L part is always in slot 1, and the X part is always in
   slot 2).  We must refuse to insert breakpoints for an address
   that points at slot 2 of a bundle where an L-X instruction is
   present, since there is logically no instruction at that address.
   However, to make things more interesting, the opcode of L-X
   instructions is located in slot 2.  This means that, to insert
   a breakpoint at an address that points to slot 1, we actually
   need to write the breakpoint in slot 2!  Slot 1 is actually
   the extended operand, so writing the breakpoint there would not
   have the desired effect.  Another side-effect of this issue
   is that we need to make sure that the shadow contents buffer
   does save byte 15 of our instruction bundle (this is the tail
   end of slot 2, which wouldn't be saved if we were to insert
   the breakpoint in slot 1).
   
   ia64 16-byte bundle layout:
   | 5 bits | slot 0 with 41 bits | slot 1 with 41 bits | slot 2 with 41 bits |
   
   The current addressing used by the code below:
   original PC   placed_address   placed_size             required    covered
                                  == bp_tgt->shadow_len   reqd \subset covered
   0xABCDE0      0xABCDE0         0x10                    <0x0...0x5> <0x0..0xF>
   0xABCDE1      0xABCDE1         0xF                     <0x5...0xA> <0x1..0xF>
   0xABCDE2      0xABCDE2         0xE                     <0xA...0xF> <0x2..0xF>

   L-X instructions are treated a little specially, as explained above:
   0xABCDE1      0xABCDE1         0xF                     <0xA...0xF> <0x1..0xF>

   `objdump -d' and some other tools show a bit unjustified offsets:
   original PC   byte where starts the instruction   objdump offset
   0xABCDE0      0xABCDE0                            0xABCDE0
   0xABCDE1      0xABCDE5                            0xABCDE6
   0xABCDE2      0xABCDEA                            0xABCDEC
   */

#define IA64_BREAKPOINT 0x00003333300LL

static int
ia64_memory_insert_breakpoint (struct gdbarch *gdbarch,
			       struct bp_target_info *bp_tgt)
{
  CORE_ADDR addr = bp_tgt->placed_address;
  gdb_byte bundle[BUNDLE_LEN];
  int slotnum = (int) (addr & 0x0f) / SLOT_MULTIPLIER, shadow_slotnum;
  long long instr_breakpoint;
  int val;
  int template;
  struct cleanup *cleanup;

  if (slotnum > 2)
    error (_("Can't insert breakpoint for slot numbers greater than 2."));

  addr &= ~0x0f;

  /* Enable the automatic memory restoration from breakpoints while
     we read our instruction bundle for the purpose of SHADOW_CONTENTS.
     Otherwise, we could possibly store into the shadow parts of the adjacent
     placed breakpoints.  It is due to our SHADOW_CONTENTS overlapping the real
     breakpoint instruction bits region.  */
  cleanup = make_show_memory_breakpoints_cleanup (0);
  val = target_read_memory (addr, bundle, BUNDLE_LEN);
  if (val != 0)
    {
      do_cleanups (cleanup);
      return val;
    }

  /* SHADOW_SLOTNUM saves the original slot number as expected by the caller
     for addressing the SHADOW_CONTENTS placement.  */
  shadow_slotnum = slotnum;

  /* Always cover the last byte of the bundle in case we are inserting
     a breakpoint on an L-X instruction.  */
  bp_tgt->shadow_len = BUNDLE_LEN - shadow_slotnum;

  template = extract_bit_field (bundle, 0, 5);
  if (template_encoding_table[template][slotnum] == X)
    {
      /* X unit types can only be used in slot 2, and are actually
	 part of a 2-slot L-X instruction.  We cannot break at this
	 address, as this is the second half of an instruction that
	 lives in slot 1 of that bundle.  */
      gdb_assert (slotnum == 2);
      error (_("Can't insert breakpoint for non-existing slot X"));
    }
  if (template_encoding_table[template][slotnum] == L)
    {
      /* L unit types can only be used in slot 1.  But the associated
	 opcode for that instruction is in slot 2, so bump the slot number
	 accordingly.  */
      gdb_assert (slotnum == 1);
      slotnum = 2;
    }

  /* Store the whole bundle, except for the initial skipped bytes by the slot
     number interpreted as bytes offset in PLACED_ADDRESS.  */
  memcpy (bp_tgt->shadow_contents, bundle + shadow_slotnum,
	  bp_tgt->shadow_len);

  /* Re-read the same bundle as above except that, this time, read it in order
     to compute the new bundle inside which we will be inserting the
     breakpoint.  Therefore, disable the automatic memory restoration from
     breakpoints while we read our instruction bundle.  Otherwise, the general
     restoration mechanism kicks in and we would possibly remove parts of the
     adjacent placed breakpoints.  It is due to our SHADOW_CONTENTS overlapping
     the real breakpoint instruction bits region.  */
  make_show_memory_breakpoints_cleanup (1);
  val = target_read_memory (addr, bundle, BUNDLE_LEN);
  if (val != 0)
    {
      do_cleanups (cleanup);
      return val;
    }

  /* Breakpoints already present in the code will get deteacted and not get
     reinserted by bp_loc_is_permanent.  Multiple breakpoints at the same
     location cannot induce the internal error as they are optimized into
     a single instance by update_global_location_list.  */
  instr_breakpoint = slotN_contents (bundle, slotnum);
  if (instr_breakpoint == IA64_BREAKPOINT)
    internal_error (__FILE__, __LINE__,
		    _("Address %s already contains a breakpoint."),
		    paddress (gdbarch, bp_tgt->placed_address));
  replace_slotN_contents (bundle, IA64_BREAKPOINT, slotnum);

  bp_tgt->placed_size = bp_tgt->shadow_len;

  val = target_write_memory (addr + shadow_slotnum, bundle + shadow_slotnum,
			     bp_tgt->shadow_len);

  do_cleanups (cleanup);
  return val;
}

static int
ia64_memory_remove_breakpoint (struct gdbarch *gdbarch,
			       struct bp_target_info *bp_tgt)
{
  CORE_ADDR addr = bp_tgt->placed_address;
  gdb_byte bundle_mem[BUNDLE_LEN], bundle_saved[BUNDLE_LEN];
  int slotnum = (addr & 0x0f) / SLOT_MULTIPLIER, shadow_slotnum;
  long long instr_breakpoint, instr_saved;
  int val;
  int template;
  struct cleanup *cleanup;

  addr &= ~0x0f;

  /* Disable the automatic memory restoration from breakpoints while
     we read our instruction bundle.  Otherwise, the general restoration
     mechanism kicks in and we would possibly remove parts of the adjacent
     placed breakpoints.  It is due to our SHADOW_CONTENTS overlapping the real
     breakpoint instruction bits region.  */
  cleanup = make_show_memory_breakpoints_cleanup (1);
  val = target_read_memory (addr, bundle_mem, BUNDLE_LEN);
  if (val != 0)
    {
      do_cleanups (cleanup);
      return val;
    }

  /* SHADOW_SLOTNUM saves the original slot number as expected by the caller
     for addressing the SHADOW_CONTENTS placement.  */
  shadow_slotnum = slotnum;

  template = extract_bit_field (bundle_mem, 0, 5);
  if (template_encoding_table[template][slotnum] == X)
    {
      /* X unit types can only be used in slot 2, and are actually
	 part of a 2-slot L-X instruction.  We refuse to insert
	 breakpoints at this address, so there should be no reason
	 for us attempting to remove one there, except if the program's
	 code somehow got modified in memory.  */
      gdb_assert (slotnum == 2);
      warning (_("Cannot remove breakpoint at address %s from non-existing "
		 "X-type slot, memory has changed underneath"),
	       paddress (gdbarch, bp_tgt->placed_address));
      do_cleanups (cleanup);
      return -1;
    }
  if (template_encoding_table[template][slotnum] == L)
    {
      /* L unit types can only be used in slot 1.  But the breakpoint
	 was actually saved using slot 2, so update the slot number
	 accordingly.  */
      gdb_assert (slotnum == 1);
      slotnum = 2;
    }

  gdb_assert (bp_tgt->placed_size == BUNDLE_LEN - shadow_slotnum);
  gdb_assert (bp_tgt->placed_size == bp_tgt->shadow_len);

  instr_breakpoint = slotN_contents (bundle_mem, slotnum);
  if (instr_breakpoint != IA64_BREAKPOINT)
    {
      warning (_("Cannot remove breakpoint at address %s, "
		 "no break instruction at such address."),
	       paddress (gdbarch, bp_tgt->placed_address));
      do_cleanups (cleanup);
      return -1;
    }

  /* Extract the original saved instruction from SLOTNUM normalizing its
     bit-shift for INSTR_SAVED.  */
  memcpy (bundle_saved, bundle_mem, BUNDLE_LEN);
  memcpy (bundle_saved + shadow_slotnum, bp_tgt->shadow_contents,
	  bp_tgt->shadow_len);
  instr_saved = slotN_contents (bundle_saved, slotnum);

  /* In BUNDLE_MEM, be careful to modify only the bits belonging to SLOTNUM
     and not any of the other ones that are stored in SHADOW_CONTENTS.  */
  replace_slotN_contents (bundle_mem, instr_saved, slotnum);
  val = target_write_raw_memory (addr, bundle_mem, BUNDLE_LEN);

  do_cleanups (cleanup);
  return val;
}

/* As gdbarch_breakpoint_from_pc ranges have byte granularity and ia64
   instruction slots ranges are bit-granular (41 bits) we have to provide an
   extended range as described for ia64_memory_insert_breakpoint.  We also take
   care of preserving the `break' instruction 21-bit (or 62-bit) parameter to
   make a match for permanent breakpoints.  */

static const gdb_byte *
ia64_breakpoint_from_pc (struct gdbarch *gdbarch,
			 CORE_ADDR *pcptr, int *lenptr)
{
  CORE_ADDR addr = *pcptr;
  static gdb_byte bundle[BUNDLE_LEN];
  int slotnum = (int) (*pcptr & 0x0f) / SLOT_MULTIPLIER, shadow_slotnum;
  long long instr_fetched;
  int val;
  int template;
  struct cleanup *cleanup;

  if (slotnum > 2)
    error (_("Can't insert breakpoint for slot numbers greater than 2."));

  addr &= ~0x0f;

  /* Enable the automatic memory restoration from breakpoints while
     we read our instruction bundle to match bp_loc_is_permanent.  */
  cleanup = make_show_memory_breakpoints_cleanup (0);
  val = target_read_memory (addr, bundle, BUNDLE_LEN);
  do_cleanups (cleanup);

  /* The memory might be unreachable.  This can happen, for instance,
     when the user inserts a breakpoint at an invalid address.  */
  if (val != 0)
    return NULL;

  /* SHADOW_SLOTNUM saves the original slot number as expected by the caller
     for addressing the SHADOW_CONTENTS placement.  */
  shadow_slotnum = slotnum;

  /* Cover always the last byte of the bundle for the L-X slot case.  */
  *lenptr = BUNDLE_LEN - shadow_slotnum;

  /* Check for L type instruction in slot 1, if present then bump up the slot
     number to the slot 2.  */
  template = extract_bit_field (bundle, 0, 5);
  if (template_encoding_table[template][slotnum] == X)
    {
      gdb_assert (slotnum == 2);
      error (_("Can't insert breakpoint for non-existing slot X"));
    }
  if (template_encoding_table[template][slotnum] == L)
    {
      gdb_assert (slotnum == 1);
      slotnum = 2;
    }

  /* A break instruction has its all its opcode bits cleared except for
     the parameter value.  For L+X slot pair we are at the X slot (slot 2) so
     we should not touch the L slot - the upper 41 bits of the parameter.  */
  instr_fetched = slotN_contents (bundle, slotnum);
  instr_fetched &= 0x1003ffffc0LL;
  replace_slotN_contents (bundle, instr_fetched, slotnum);

  return bundle + shadow_slotnum;
}

static CORE_ADDR
ia64_read_pc (struct regcache *regcache)
{
  ULONGEST psr_value, pc_value;
  int slot_num;

  regcache_cooked_read_unsigned (regcache, IA64_PSR_REGNUM, &psr_value);
  regcache_cooked_read_unsigned (regcache, IA64_IP_REGNUM, &pc_value);
  slot_num = (psr_value >> 41) & 3;

  return pc_value | (slot_num * SLOT_MULTIPLIER);
}

void
ia64_write_pc (struct regcache *regcache, CORE_ADDR new_pc)
{
  int slot_num = (int) (new_pc & 0xf) / SLOT_MULTIPLIER;
  ULONGEST psr_value;

  regcache_cooked_read_unsigned (regcache, IA64_PSR_REGNUM, &psr_value);
  psr_value &= ~(3LL << 41);
  psr_value |= (ULONGEST)(slot_num & 0x3) << 41;

  new_pc &= ~0xfLL;

  regcache_cooked_write_unsigned (regcache, IA64_PSR_REGNUM, psr_value);
  regcache_cooked_write_unsigned (regcache, IA64_IP_REGNUM, new_pc);
}

#define IS_NaT_COLLECTION_ADDR(addr) ((((addr) >> 3) & 0x3f) == 0x3f)

/* Returns the address of the slot that's NSLOTS slots away from
   the address ADDR.  NSLOTS may be positive or negative.  */
static CORE_ADDR
rse_address_add(CORE_ADDR addr, int nslots)
{
  CORE_ADDR new_addr;
  int mandatory_nat_slots = nslots / 63;
  int direction = nslots < 0 ? -1 : 1;

  new_addr = addr + 8 * (nslots + mandatory_nat_slots);

  if ((new_addr >> 9)  != ((addr + 8 * 64 * mandatory_nat_slots) >> 9))
    new_addr += 8 * direction;

  if (IS_NaT_COLLECTION_ADDR(new_addr))
    new_addr += 8 * direction;

  return new_addr;
}

static enum register_status
ia64_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
                           int regnum, gdb_byte *buf)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  enum register_status status;

  if (regnum >= V32_REGNUM && regnum <= V127_REGNUM)
    {
#ifdef HAVE_LIBUNWIND_IA64_H
      /* First try and use the libunwind special reg accessor,
	 otherwise fallback to standard logic.  */
      if (!libunwind_is_initialized ()
	  || libunwind_get_reg_special (gdbarch, regcache, regnum, buf) != 0)
#endif
	{
	  /* The fallback position is to assume that r32-r127 are
	     found sequentially in memory starting at $bof.  This
	     isn't always true, but without libunwind, this is the
	     best we can do.  */
	  enum register_status status;
	  ULONGEST cfm;
	  ULONGEST bsp;
	  CORE_ADDR reg;

	  status = regcache_cooked_read_unsigned (regcache,
						  IA64_BSP_REGNUM, &bsp);
	  if (status != REG_VALID)
	    return status;

	  status = regcache_cooked_read_unsigned (regcache,
						  IA64_CFM_REGNUM, &cfm);
	  if (status != REG_VALID)
	    return status;

	  /* The bsp points at the end of the register frame so we
	     subtract the size of frame from it to get start of
	     register frame.  */
	  bsp = rse_address_add (bsp, -(cfm & 0x7f));
	  
	  if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	    {
	      ULONGEST reg_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
	      reg = read_memory_integer ((CORE_ADDR)reg_addr, 8, byte_order);
	      store_unsigned_integer (buf, register_size (gdbarch, regnum),
				      byte_order, reg);
	    }
	  else
	    store_unsigned_integer (buf, register_size (gdbarch, regnum),
				    byte_order, 0);
	}
    }
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT31_REGNUM)
    {
      ULONGEST unatN_val;
      ULONGEST unat;
      status = regcache_cooked_read_unsigned (regcache, IA64_UNAT_REGNUM, &unat);
      if (status != REG_VALID)
	return status;
      unatN_val = (unat & (1LL << (regnum - IA64_NAT0_REGNUM))) != 0;
      store_unsigned_integer (buf, register_size (gdbarch, regnum),
			      byte_order, unatN_val);
    }
  else if (IA64_NAT32_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      ULONGEST natN_val = 0;
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR gr_addr = 0;
      status = regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      if (status != REG_VALID)
	return status;
      status = regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);
      if (status != REG_VALID)
	return status;

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get start of register frame.  */
      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	gr_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
      
      if (gr_addr != 0)
	{
	  /* Compute address of nat collection bits.  */
	  CORE_ADDR nat_addr = gr_addr | 0x1f8;
	  CORE_ADDR nat_collection;
	  int nat_bit;
	  /* If our nat collection address is bigger than bsp, we have to get
	     the nat collection from rnat.  Otherwise, we fetch the nat
	     collection from the computed address.  */
	  if (nat_addr >= bsp)
	    regcache_cooked_read_unsigned (regcache, IA64_RNAT_REGNUM,
					   &nat_collection);
	  else
	    nat_collection = read_memory_integer (nat_addr, 8, byte_order);
	  nat_bit = (gr_addr >> 3) & 0x3f;
	  natN_val = (nat_collection >> nat_bit) & 1;
	}
      
      store_unsigned_integer (buf, register_size (gdbarch, regnum),
			      byte_order, natN_val);
    }
  else if (regnum == VBOF_REGNUM)
    {
      /* A virtual register frame start is provided for user convenience.
         It can be calculated as the bsp - sof (sizeof frame).  */
      ULONGEST bsp, vbsp;
      ULONGEST cfm;
      status = regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      if (status != REG_VALID)
	return status;
      status = regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);
      if (status != REG_VALID)
	return status;

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get beginning of frame.  */
      vbsp = rse_address_add (bsp, -(cfm & 0x7f));
      store_unsigned_integer (buf, register_size (gdbarch, regnum),
			      byte_order, vbsp);
    }
  else if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    {
      ULONGEST pr;
      ULONGEST cfm;
      ULONGEST prN_val;
      status = regcache_cooked_read_unsigned (regcache, IA64_PR_REGNUM, &pr);
      if (status != REG_VALID)
	return status;
      status = regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);
      if (status != REG_VALID)
	return status;

      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  /* Fetch predicate register rename base from current frame
	     marker for this frame.  */
	  int rrb_pr = (cfm >> 32) & 0x3f;

	  /* Adjust the register number to account for register rotation.  */
	  regnum = VP16_REGNUM 
	         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = (pr & (1LL << (regnum - VP0_REGNUM))) != 0;
      store_unsigned_integer (buf, register_size (gdbarch, regnum),
			      byte_order, prN_val);
    }
  else
    memset (buf, 0, register_size (gdbarch, regnum));

  return REG_VALID;
}

static void
ia64_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int regnum, const gdb_byte *buf)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  if (regnum >= V32_REGNUM && regnum <= V127_REGNUM)
    {
      ULONGEST bsp;
      ULONGEST cfm;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	{
	  ULONGEST reg_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
	  write_memory (reg_addr, (void *) buf, 8);
	}
    }
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT31_REGNUM)
    {
      ULONGEST unatN_val, unat, unatN_mask;
      regcache_cooked_read_unsigned (regcache, IA64_UNAT_REGNUM, &unat);
      unatN_val = extract_unsigned_integer (buf, register_size (gdbarch,
								regnum),
					    byte_order);
      unatN_mask = (1LL << (regnum - IA64_NAT0_REGNUM));
      if (unatN_val == 0)
	unat &= ~unatN_mask;
      else if (unatN_val == 1)
	unat |= unatN_mask;
      regcache_cooked_write_unsigned (regcache, IA64_UNAT_REGNUM, unat);
    }
  else if (IA64_NAT32_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      ULONGEST natN_val;
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR gr_addr = 0;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get start of register frame.  */
      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	gr_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
      
      natN_val = extract_unsigned_integer (buf, register_size (gdbarch,
							       regnum),
					   byte_order);

      if (gr_addr != 0 && (natN_val == 0 || natN_val == 1))
	{
	  /* Compute address of nat collection bits.  */
	  CORE_ADDR nat_addr = gr_addr | 0x1f8;
	  CORE_ADDR nat_collection;
	  int natN_bit = (gr_addr >> 3) & 0x3f;
	  ULONGEST natN_mask = (1LL << natN_bit);
	  /* If our nat collection address is bigger than bsp, we have to get
	     the nat collection from rnat.  Otherwise, we fetch the nat
	     collection from the computed address.  */
	  if (nat_addr >= bsp)
	    {
	      regcache_cooked_read_unsigned (regcache,
					     IA64_RNAT_REGNUM,
					     &nat_collection);
	      if (natN_val)
		nat_collection |= natN_mask;
	      else
		nat_collection &= ~natN_mask;
	      regcache_cooked_write_unsigned (regcache, IA64_RNAT_REGNUM,
					      nat_collection);
	    }
	  else
	    {
	      gdb_byte nat_buf[8];
	      nat_collection = read_memory_integer (nat_addr, 8, byte_order);
	      if (natN_val)
		nat_collection |= natN_mask;
	      else
		nat_collection &= ~natN_mask;
	      store_unsigned_integer (nat_buf, register_size (gdbarch, regnum),
				      byte_order, nat_collection);
	      write_memory (nat_addr, nat_buf, 8);
	    }
	}
    }
  else if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    {
      ULONGEST pr;
      ULONGEST cfm;
      ULONGEST prN_val;
      ULONGEST prN_mask;

      regcache_cooked_read_unsigned (regcache, IA64_PR_REGNUM, &pr);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  /* Fetch predicate register rename base from current frame
	     marker for this frame.  */
	  int rrb_pr = (cfm >> 32) & 0x3f;

	  /* Adjust the register number to account for register rotation.  */
	  regnum = VP16_REGNUM 
	         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = extract_unsigned_integer (buf, register_size (gdbarch, regnum),
					  byte_order);
      prN_mask = (1LL << (regnum - VP0_REGNUM));
      if (prN_val == 0)
	pr &= ~prN_mask;
      else if (prN_val == 1)
	pr |= prN_mask;
      regcache_cooked_write_unsigned (regcache, IA64_PR_REGNUM, pr);
    }
}

/* The ia64 needs to convert between various ieee floating-point formats
   and the special ia64 floating point register format.  */

static int
ia64_convert_register_p (struct gdbarch *gdbarch, int regno, struct type *type)
{
  return (regno >= IA64_FR0_REGNUM && regno <= IA64_FR127_REGNUM
	  && type != ia64_ext_type (gdbarch));
}

static int
ia64_register_to_value (struct frame_info *frame, int regnum,
			struct type *valtype, gdb_byte *out,
			int *optimizedp, int *unavailablep)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  gdb_byte in[MAX_REGISTER_SIZE];

  /* Convert to TYPE.  */
  if (!get_frame_register_bytes (frame, regnum, 0,
				 register_size (gdbarch, regnum),
				 in, optimizedp, unavailablep))
    return 0;

  convert_typed_floating (in, ia64_ext_type (gdbarch), out, valtype);
  *optimizedp = *unavailablep = 0;
  return 1;
}

static void
ia64_value_to_register (struct frame_info *frame, int regnum,
                         struct type *valtype, const gdb_byte *in)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  gdb_byte out[MAX_REGISTER_SIZE];
  convert_typed_floating (in, valtype, out, ia64_ext_type (gdbarch));
  put_frame_register (frame, regnum, out);
}


/* Limit the number of skipped non-prologue instructions since examining
   of the prologue is expensive.  */
static int max_skip_non_prologue_insns = 40;

/* Given PC representing the starting address of a function, and
   LIM_PC which is the (sloppy) limit to which to scan when looking
   for a prologue, attempt to further refine this limit by using
   the line data in the symbol table.  If successful, a better guess
   on where the prologue ends is returned, otherwise the previous
   value of lim_pc is returned.  TRUST_LIMIT is a pointer to a flag
   which will be set to indicate whether the returned limit may be
   used with no further scanning in the event that the function is
   frameless.  */

/* FIXME: cagney/2004-02-14: This function and logic have largely been
   superseded by skip_prologue_using_sal.  */

static CORE_ADDR
refine_prologue_limit (CORE_ADDR pc, CORE_ADDR lim_pc, int *trust_limit)
{
  struct symtab_and_line prologue_sal;
  CORE_ADDR start_pc = pc;
  CORE_ADDR end_pc;

  /* The prologue can not possibly go past the function end itself,
     so we can already adjust LIM_PC accordingly.  */
  if (find_pc_partial_function (pc, NULL, NULL, &end_pc) && end_pc < lim_pc)
    lim_pc = end_pc;

  /* Start off not trusting the limit.  */
  *trust_limit = 0;

  prologue_sal = find_pc_line (pc, 0);
  if (prologue_sal.line != 0)
    {
      int i;
      CORE_ADDR addr = prologue_sal.end;

      /* Handle the case in which compiler's optimizer/scheduler
         has moved instructions into the prologue.  We scan ahead
	 in the function looking for address ranges whose corresponding
	 line number is less than or equal to the first one that we
	 found for the function.  (It can be less than when the
	 scheduler puts a body instruction before the first prologue
	 instruction.)  */
      for (i = 2 * max_skip_non_prologue_insns; 
           i > 0 && (lim_pc == 0 || addr < lim_pc);
	   i--)
        {
	  struct symtab_and_line sal;

	  sal = find_pc_line (addr, 0);
	  if (sal.line == 0)
	    break;
	  if (sal.line <= prologue_sal.line 
	      && sal.symtab == prologue_sal.symtab)
	    {
	      prologue_sal = sal;
	    }
	  addr = sal.end;
	}

      if (lim_pc == 0 || prologue_sal.end < lim_pc)
	{
	  lim_pc = prologue_sal.end;
	  if (start_pc == get_pc_function_start (lim_pc))
	    *trust_limit = 1;
	}
    }
  return lim_pc;
}

#define isScratch(_regnum_) ((_regnum_) == 2 || (_regnum_) == 3 \
  || (8 <= (_regnum_) && (_regnum_) <= 11) \
  || (14 <= (_regnum_) && (_regnum_) <= 31))
#define imm9(_instr_) \
  ( ((((_instr_) & 0x01000000000LL) ? -1 : 0) << 8) \
   | (((_instr_) & 0x00008000000LL) >> 20) \
   | (((_instr_) & 0x00000001fc0LL) >> 6))

/* Allocate and initialize a frame cache.  */

static struct ia64_frame_cache *
ia64_alloc_frame_cache (void)
{
  struct ia64_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct ia64_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->pc = 0;
  cache->cfm = 0;
  cache->prev_cfm = 0;
  cache->sof = 0;
  cache->sol = 0;
  cache->sor = 0;
  cache->bsp = 0;
  cache->fp_reg = 0;
  cache->frameless = 1;

  for (i = 0; i < NUM_IA64_RAW_REGS; i++)
    cache->saved_regs[i] = 0;

  return cache;
}

static CORE_ADDR
examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,
                  struct frame_info *this_frame,
                  struct ia64_frame_cache *cache)
{
  CORE_ADDR next_pc;
  CORE_ADDR last_prologue_pc = pc;
  instruction_type it;
  long long instr;
  int cfm_reg  = 0;
  int ret_reg  = 0;
  int fp_reg   = 0;
  int unat_save_reg = 0;
  int pr_save_reg = 0;
  int mem_stack_frame_size = 0;
  int spill_reg   = 0;
  CORE_ADDR spill_addr = 0;
  char instores[8];
  char infpstores[8];
  char reg_contents[256];
  int trust_limit;
  int frameless = 1;
  int i;
  CORE_ADDR addr;
  gdb_byte buf[8];
  CORE_ADDR bof, sor, sol, sof, cfm, rrb_gr;

  memset (instores, 0, sizeof instores);
  memset (infpstores, 0, sizeof infpstores);
  memset (reg_contents, 0, sizeof reg_contents);

  if (cache->after_prologue != 0
      && cache->after_prologue <= lim_pc)
    return cache->after_prologue;

  lim_pc = refine_prologue_limit (pc, lim_pc, &trust_limit);
  next_pc = fetch_instruction (pc, &it, &instr);

  /* We want to check if we have a recognizable function start before we
     look ahead for a prologue.  */
  if (pc < lim_pc && next_pc 
      && it == M && ((instr & 0x1ee0000003fLL) == 0x02c00000000LL))
    {
      /* alloc - start of a regular function.  */
      int sor = (int) ((instr & 0x00078000000LL) >> 27);
      int sol = (int) ((instr & 0x00007f00000LL) >> 20);
      int sof = (int) ((instr & 0x000000fe000LL) >> 13);
      int rN = (int) ((instr & 0x00000001fc0LL) >> 6);

      /* Verify that the current cfm matches what we think is the
	 function start.  If we have somehow jumped within a function,
	 we do not want to interpret the prologue and calculate the
	 addresses of various registers such as the return address.
	 We will instead treat the frame as frameless.  */
      if (!this_frame ||
	  (sof == (cache->cfm & 0x7f) &&
	   sol == ((cache->cfm >> 7) & 0x7f)))
	frameless = 0;

      cfm_reg = rN;
      last_prologue_pc = next_pc;
      pc = next_pc;
    }
  else
    {
      /* Look for a leaf routine.  */
      if (pc < lim_pc && next_pc
	  && (it == I || it == M) 
          && ((instr & 0x1ee00000000LL) == 0x10800000000LL))
	{
	  /* adds rN = imm14, rM   (or mov rN, rM  when imm14 is 0) */
	  int imm = (int) ((((instr & 0x01000000000LL) ? -1 : 0) << 13) 
	                   | ((instr & 0x001f8000000LL) >> 20)
		           | ((instr & 0x000000fe000LL) >> 13));
	  int rM = (int) ((instr & 0x00007f00000LL) >> 20);
	  int rN = (int) ((instr & 0x00000001fc0LL) >> 6);
	  int qp = (int) (instr & 0x0000000003fLL);
	  if (qp == 0 && rN == 2 && imm == 0 && rM == 12 && fp_reg == 0)
	    {
	      /* mov r2, r12 - beginning of leaf routine.  */
	      fp_reg = rN;
	      last_prologue_pc = next_pc;
	    }
	} 

      /* If we don't recognize a regular function or leaf routine, we are
	 done.  */
      if (!fp_reg)
	{
	  pc = lim_pc;	
	  if (trust_limit)
	    last_prologue_pc = lim_pc;
	}
    }

  /* Loop, looking for prologue instructions, keeping track of
     where preserved registers were spilled.  */
  while (pc < lim_pc)
    {
      next_pc = fetch_instruction (pc, &it, &instr);
      if (next_pc == 0)
	break;

      if (it == B && ((instr & 0x1e1f800003fLL) != 0x04000000000LL))
	{
	  /* Exit loop upon hitting a non-nop branch instruction.  */ 
	  if (trust_limit)
	    lim_pc = pc;
	  break;
	}
      else if (((instr & 0x3fLL) != 0LL) && 
	       (frameless || ret_reg != 0))
	{
	  /* Exit loop upon hitting a predicated instruction if
	     we already have the return register or if we are frameless.  */ 
	  if (trust_limit)
	    lim_pc = pc;
	  break;
	}
      else if (it == I && ((instr & 0x1eff8000000LL) == 0x00188000000LL))
        {
	  /* Move from BR */
	  int b2 = (int) ((instr & 0x0000000e000LL) >> 13);
	  int rN = (int) ((instr & 0x00000001fc0LL) >> 6);
	  int qp = (int) (instr & 0x0000000003f);

	  if (qp == 0 && b2 == 0 && rN >= 32 && ret_reg == 0)
	    {
	      ret_reg = rN;
	      last_prologue_pc = next_pc;
	    }
	}
      else if ((it == I || it == M) 
          && ((instr & 0x1ee00000000LL) == 0x10800000000LL))
	{
	  /* adds rN = imm14, rM   (or mov rN, rM  when imm14 is 0) */
	  int imm = (int) ((((instr & 0x01000000000LL) ? -1 : 0) << 13) 
	                   | ((instr & 0x001f8000000LL) >> 20)
		           | ((instr & 0x000000fe000LL) >> 13));
	  int rM = (int) ((instr & 0x00007f00000LL) >> 20);
	  int rN = (int) ((instr & 0x00000001fc0LL) >> 6);
	  int qp = (int) (instr & 0x0000000003fLL);

	  if (qp == 0 && rN >= 32 && imm == 0 && rM == 12 && fp_reg == 0)
	    {
	      /* mov rN, r12 */
	      fp_reg = rN;
	      last_prologue_pc = next_pc;
	    }
	  else if (qp == 0 && rN == 12 && rM == 12)
	    {
	      /* adds r12, -mem_stack_frame_size, r12 */
	      mem_stack_frame_size -= imm;
	      last_prologue_pc = next_pc;
	    }
	  else if (qp == 0 && rN == 2 
	        && ((rM == fp_reg && fp_reg != 0) || rM == 12))
	    {
	      gdb_byte buf[MAX_REGISTER_SIZE];
	      CORE_ADDR saved_sp = 0;
	      /* adds r2, spilloffset, rFramePointer 
	           or
		 adds r2, spilloffset, r12

	         Get ready for stf.spill or st8.spill instructions.
		 The address to start spilling at is loaded into r2.
		 FIXME:  Why r2?  That's what gcc currently uses; it
		 could well be different for other compilers.  */

	      /* Hmm...  whether or not this will work will depend on
	         where the pc is.  If it's still early in the prologue
		 this'll be wrong.  FIXME */
	      if (this_frame)
		{
		  struct gdbarch *gdbarch = get_frame_arch (this_frame);
		  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
		  get_frame_register (this_frame, sp_regnum, buf);
		  saved_sp = extract_unsigned_integer (buf, 8, byte_order);
		}
	      spill_addr  = saved_sp
	                  + (rM == 12 ? 0 : mem_stack_frame_size) 
			  + imm;
	      spill_reg   = rN;
	      last_prologue_pc = next_pc;
	    }
	  else if (qp == 0 && rM >= 32 && rM < 40 && !instores[rM-32] && 
		   rN < 256 && imm == 0)
	    {
	      /* mov rN, rM where rM is an input register.  */
	      reg_contents[rN] = rM;
	      last_prologue_pc = next_pc;
	    }
	  else if (frameless && qp == 0 && rN == fp_reg && imm == 0 && 
		   rM == 2)
	    {
	      /* mov r12, r2 */
	      last_prologue_pc = next_pc;
	      break;
	    }
	}
      else if (it == M 
            && (   ((instr & 0x1efc0000000LL) == 0x0eec0000000LL)
                || ((instr & 0x1ffc8000000LL) == 0x0cec0000000LL) ))
	{
	  /* stf.spill [rN] = fM, imm9
	     or
	     stf.spill [rN] = fM  */

	  int imm = imm9(instr);
	  int rN = (int) ((instr & 0x00007f00000LL) >> 20);
	  int fM = (int) ((instr & 0x000000fe000LL) >> 13);
	  int qp = (int) (instr & 0x0000000003fLL);
	  if (qp == 0 && rN == spill_reg && spill_addr != 0
	      && ((2 <= fM && fM <= 5) || (16 <= fM && fM <= 31)))
	    {
	      cache->saved_regs[IA64_FR0_REGNUM + fM] = spill_addr;

              if ((instr & 0x1efc0000000LL) == 0x0eec0000000LL)
		spill_addr += imm;
	      else
		spill_addr = 0;		/* last one; must be done.  */
	      last_prologue_pc = next_pc;
	    }
	}
      else if ((it == M && ((instr & 0x1eff8000000LL) == 0x02110000000LL))
            || (it == I && ((instr & 0x1eff8000000LL) == 0x00050000000LL)) )
	{
	  /* mov.m rN = arM   
	       or 
	     mov.i rN = arM */

	  int arM = (int) ((instr & 0x00007f00000LL) >> 20);
	  int rN  = (int) ((instr & 0x00000001fc0LL) >> 6);
	  int qp  = (int) (instr & 0x0000000003fLL);
	  if (qp == 0 && isScratch (rN) && arM == 36 /* ar.unat */)
	    {
	      /* We have something like "mov.m r3 = ar.unat".  Remember the
		 r3 (or whatever) and watch for a store of this register...  */
	      unat_save_reg = rN;
	      last_prologue_pc = next_pc;
	    }
	}
      else if (it == I && ((instr & 0x1eff8000000LL) == 0x00198000000LL))
	{
	  /* mov rN = pr */
	  int rN  = (int) ((instr & 0x00000001fc0LL) >> 6);
	  int qp  = (int) (instr & 0x0000000003fLL);
	  if (qp == 0 && isScratch (rN))
	    {
	      pr_save_reg = rN;
	      last_prologue_pc = next_pc;
	    }
	}
      else if (it == M 
            && (   ((instr & 0x1ffc8000000LL) == 0x08cc0000000LL)
	        || ((instr & 0x1efc0000000LL) == 0x0acc0000000LL)))
	{
	  /* st8 [rN] = rM 
	      or
	     st8 [rN] = rM, imm9 */
	  int rN = (int) ((instr & 0x00007f00000LL) >> 20);
	  int rM = (int) ((instr & 0x000000fe000LL) >> 13);
	  int qp = (int) (instr & 0x0000000003fLL);
	  int indirect = rM < 256 ? reg_contents[rM] : 0;
	  if (qp == 0 && rN == spill_reg && spill_addr != 0
	      && (rM == unat_save_reg || rM == pr_save_reg))
	    {
	      /* We've found a spill of either the UNAT register or the PR
	         register.  (Well, not exactly; what we've actually found is
		 a spill of the register that UNAT or PR was moved to).
		 Record that fact and move on...  */
	      if (rM == unat_save_reg)
		{
		  /* Track UNAT register.  */
		  cache->saved_regs[IA64_UNAT_REGNUM] = spill_addr;
		  unat_save_reg = 0;
		}
	      else
	        {
		  /* Track PR register.  */
		  cache->saved_regs[IA64_PR_REGNUM] = spill_addr;
		  pr_save_reg = 0;
		}
	      if ((instr & 0x1efc0000000LL) == 0x0acc0000000LL)
		/* st8 [rN] = rM, imm9 */
		spill_addr += imm9(instr);
	      else
		spill_addr = 0;		/* Must be done spilling.  */
	      last_prologue_pc = next_pc;
	    }
	  else if (qp == 0 && 32 <= rM && rM < 40 && !instores[rM-32])
	    {
	      /* Allow up to one store of each input register.  */
	      instores[rM-32] = 1;
	      last_prologue_pc = next_pc;
	    }
	  else if (qp == 0 && 32 <= indirect && indirect < 40 && 
		   !instores[indirect-32])
	    {
	      /* Allow an indirect store of an input register.  */
	      instores[indirect-32] = 1;
	      last_prologue_pc = next_pc;
	    }
	}
      else if (it == M && ((instr & 0x1ff08000000LL) == 0x08c00000000LL))
	{
	  /* One of
	       st1 [rN] = rM
	       st2 [rN] = rM
	       st4 [rN] = rM
	       st8 [rN] = rM
	     Note that the st8 case is handled in the clause above.
	     
	     Advance over stores of input registers.  One store per input
	     register is permitted.  */
	  int rM = (int) ((instr & 0x000000fe000LL) >> 13);
	  int qp = (int) (instr & 0x0000000003fLL);
	  int indirect = rM < 256 ? reg_contents[rM] : 0;
	  if (qp == 0 && 32 <= rM && rM < 40 && !instores[rM-32])
	    {
	      instores[rM-32] = 1;
	      last_prologue_pc = next_pc;
	    }
	  else if (qp == 0 && 32 <= indirect && indirect < 40 && 
		   !instores[indirect-32])
	    {
	      /* Allow an indirect store of an input register.  */
	      instores[indirect-32] = 1;
	      last_prologue_pc = next_pc;
	    }
	}
      else if (it == M && ((instr & 0x1ff88000000LL) == 0x0cc80000000LL))
        {
	  /* Either
	       stfs [rN] = fM
	     or
	       stfd [rN] = fM

	     Advance over stores of floating point input registers.  Again
	     one store per register is permitted.  */
	  int fM = (int) ((instr & 0x000000fe000LL) >> 13);
	  int qp = (int) (instr & 0x0000000003fLL);
	  if (qp == 0 && 8 <= fM && fM < 16 && !infpstores[fM - 8])
	    {
	      infpstores[fM-8] = 1;
	      last_prologue_pc = next_pc;
	    }
	}
      else if (it == M
            && (   ((instr & 0x1ffc8000000LL) == 0x08ec0000000LL)
	        || ((instr & 0x1efc0000000LL) == 0x0aec0000000LL)))
	{
	  /* st8.spill [rN] = rM
	       or
	     st8.spill [rN] = rM, imm9 */
	  int rN = (int) ((instr & 0x00007f00000LL) >> 20);
	  int rM = (int) ((instr & 0x000000fe000LL) >> 13);
	  int qp = (int) (instr & 0x0000000003fLL);
	  if (qp == 0 && rN == spill_reg && 4 <= rM && rM <= 7)
	    {
	      /* We've found a spill of one of the preserved general purpose
	         regs.  Record the spill address and advance the spill
		 register if appropriate.  */
	      cache->saved_regs[IA64_GR0_REGNUM + rM] = spill_addr;
	      if ((instr & 0x1efc0000000LL) == 0x0aec0000000LL)
	        /* st8.spill [rN] = rM, imm9 */
		spill_addr += imm9(instr);
	      else
		spill_addr = 0;		/* Done spilling.  */
	      last_prologue_pc = next_pc;
	    }
	}

      pc = next_pc;
    }

  /* If not frameless and we aren't called by skip_prologue, then we need
     to calculate registers for the previous frame which will be needed
     later.  */

  if (!frameless && this_frame)
    {
      struct gdbarch *gdbarch = get_frame_arch (this_frame);
      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

      /* Extract the size of the rotating portion of the stack
	 frame and the register rename base from the current
	 frame marker.  */
      cfm = cache->cfm;
      sor = cache->sor;
      sof = cache->sof;
      sol = cache->sol;
      rrb_gr = (cfm >> 18) & 0x7f;

      /* Find the bof (beginning of frame).  */
      bof = rse_address_add (cache->bsp, -sof);
      
      for (i = 0, addr = bof;
	   i < sof;
	   i++, addr += 8)
	{
	  if (IS_NaT_COLLECTION_ADDR (addr))
	    {
	      addr += 8;
	    }
	  if (i+32 == cfm_reg)
	    cache->saved_regs[IA64_CFM_REGNUM] = addr;
	  if (i+32 == ret_reg)
	    cache->saved_regs[IA64_VRAP_REGNUM] = addr;
	  if (i+32 == fp_reg)
	    cache->saved_regs[IA64_VFP_REGNUM] = addr;
	}

      /* For the previous argument registers we require the previous bof.
	 If we can't find the previous cfm, then we can do nothing.  */
      cfm = 0;
      if (cache->saved_regs[IA64_CFM_REGNUM] != 0)
	{
	  cfm = read_memory_integer (cache->saved_regs[IA64_CFM_REGNUM],
				     8, byte_order);
	}
      else if (cfm_reg != 0)
	{
	  get_frame_register (this_frame, cfm_reg, buf);
	  cfm = extract_unsigned_integer (buf, 8, byte_order);
	}
      cache->prev_cfm = cfm;
      
      if (cfm != 0)
	{
	  sor = ((cfm >> 14) & 0xf) * 8;
	  sof = (cfm & 0x7f);
	  sol = (cfm >> 7) & 0x7f;
	  rrb_gr = (cfm >> 18) & 0x7f;

	  /* The previous bof only requires subtraction of the sol (size of
             locals) due to the overlap between output and input of
             subsequent frames.  */
	  bof = rse_address_add (bof, -sol);
	  
	  for (i = 0, addr = bof;
	       i < sof;
	       i++, addr += 8)
	    {
	      if (IS_NaT_COLLECTION_ADDR (addr))
		{
		  addr += 8;
		}
	      if (i < sor)
		cache->saved_regs[IA64_GR32_REGNUM
				  + ((i + (sor - rrb_gr)) % sor)] 
		  = addr;
	      else
		cache->saved_regs[IA64_GR32_REGNUM + i] = addr;
	    }
	  
	}
    }
      
  /* Try and trust the lim_pc value whenever possible.  */
  if (trust_limit && lim_pc >= last_prologue_pc)
    last_prologue_pc = lim_pc;

  cache->frameless = frameless;
  cache->after_prologue = last_prologue_pc;
  cache->mem_stack_frame_size = mem_stack_frame_size;
  cache->fp_reg = fp_reg;

  return last_prologue_pc;
}

CORE_ADDR
ia64_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  struct ia64_frame_cache cache;
  cache.base = 0;
  cache.after_prologue = 0;
  cache.cfm = 0;
  cache.bsp = 0;

  /* Call examine_prologue with - as third argument since we don't
     have a next frame pointer to send.  */
  return examine_prologue (pc, pc+1024, 0, &cache);
}


/* Normal frames.  */

static struct ia64_frame_cache *
ia64_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct ia64_frame_cache *cache;
  gdb_byte buf[8];
  CORE_ADDR cfm, psr;

  if (*this_cache)
    return *this_cache;

  cache = ia64_alloc_frame_cache ();
  *this_cache = cache;

  get_frame_register (this_frame, sp_regnum, buf);
  cache->saved_sp = extract_unsigned_integer (buf, 8, byte_order);

  /* We always want the bsp to point to the end of frame.
     This way, we can always get the beginning of frame (bof)
     by subtracting frame size.  */
  get_frame_register (this_frame, IA64_BSP_REGNUM, buf);
  cache->bsp = extract_unsigned_integer (buf, 8, byte_order);
  
  get_frame_register (this_frame, IA64_PSR_REGNUM, buf);
  psr = extract_unsigned_integer (buf, 8, byte_order);

  get_frame_register (this_frame, IA64_CFM_REGNUM, buf);
  cfm = extract_unsigned_integer (buf, 8, byte_order);

  cache->sof = (cfm & 0x7f);
  cache->sol = (cfm >> 7) & 0x7f;
  cache->sor = ((cfm >> 14) & 0xf) * 8;

  cache->cfm = cfm;

  cache->pc = get_frame_func (this_frame);

  if (cache->pc != 0)
    examine_prologue (cache->pc, get_frame_pc (this_frame), this_frame, cache);
  
  cache->base = cache->saved_sp + cache->mem_stack_frame_size;

  return cache;
}

static void
ia64_frame_this_id (struct frame_info *this_frame, void **this_cache,
		    struct frame_id *this_id)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct ia64_frame_cache *cache =
    ia64_frame_cache (this_frame, this_cache);

  /* If outermost frame, mark with null frame id.  */
  if (cache->base != 0)
    (*this_id) = frame_id_build_special (cache->base, cache->pc, cache->bsp);
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"regular frame id: code %s, stack %s, "
			"special %s, this_frame %s\n",
			paddress (gdbarch, this_id->code_addr),
			paddress (gdbarch, this_id->stack_addr),
			paddress (gdbarch, cache->bsp),
			host_address_to_string (this_frame));
}

static struct value *
ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,
			  int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct ia64_frame_cache *cache = ia64_frame_cache (this_frame, this_cache);
  gdb_byte buf[8];

  gdb_assert (regnum >= 0);

  if (!target_has_registers)
    error (_("No registers."));

  if (regnum == gdbarch_sp_regnum (gdbarch))
    return frame_unwind_got_constant (this_frame, regnum, cache->base);

  else if (regnum == IA64_BSP_REGNUM)
    {
      struct value *val;
      CORE_ADDR prev_cfm, bsp, prev_bsp;

      /* We want to calculate the previous bsp as the end of the previous
         register stack frame.  This corresponds to what the hardware bsp
         register will be if we pop the frame back which is why we might
         have been called.  We know the beginning of the current frame is
         cache->bsp - cache->sof.  This value in the previous frame points
         to the start of the output registers.  We can calculate the end of
         that frame by adding the size of output:
            (sof (size of frame) - sol (size of locals)).  */
      val = ia64_frame_prev_register (this_frame, this_cache, IA64_CFM_REGNUM);
      prev_cfm = extract_unsigned_integer (value_contents_all (val),
					   8, byte_order);
      bsp = rse_address_add (cache->bsp, -(cache->sof));
      prev_bsp =
        rse_address_add (bsp, (prev_cfm & 0x7f) - ((prev_cfm >> 7) & 0x7f));

      return frame_unwind_got_constant (this_frame, regnum, prev_bsp);
    }

  else if (regnum == IA64_CFM_REGNUM)
    {
      CORE_ADDR addr = cache->saved_regs[IA64_CFM_REGNUM];
      
      if (addr != 0)
        return frame_unwind_got_memory (this_frame, regnum, addr);

      if (cache->prev_cfm)
        return frame_unwind_got_constant (this_frame, regnum, cache->prev_cfm);

      if (cache->frameless)
        return frame_unwind_got_register (this_frame, IA64_PFS_REGNUM,
                                          IA64_PFS_REGNUM);
      return frame_unwind_got_register (this_frame, regnum, 0);
    }

  else if (regnum == IA64_VFP_REGNUM)
    {
      /* If the function in question uses an automatic register (r32-r127)
         for the frame pointer, it'll be found by ia64_find_saved_register()
	 above.  If the function lacks one of these frame pointers, we can
	 still provide a value since we know the size of the frame.  */
      return frame_unwind_got_constant (this_frame, regnum, cache->base);
    }

  else if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    {
      struct value *pr_val;
      ULONGEST prN;
      
      pr_val = ia64_frame_prev_register (this_frame, this_cache,
                                         IA64_PR_REGNUM);
      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  /* Fetch predicate register rename base from current frame
	     marker for this frame.  */
	  int rrb_pr = (cache->cfm >> 32) & 0x3f;

	  /* Adjust the register number to account for register rotation.  */
	  regnum = VP16_REGNUM + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN = extract_bit_field (value_contents_all (pr_val),
                               regnum - VP0_REGNUM, 1);
      return frame_unwind_got_constant (this_frame, regnum, prN);
    }

  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT31_REGNUM)
    {
      struct value *unat_val;
      ULONGEST unatN;
      unat_val = ia64_frame_prev_register (this_frame, this_cache,
                                           IA64_UNAT_REGNUM);
      unatN = extract_bit_field (value_contents_all (unat_val),
                                 regnum - IA64_NAT0_REGNUM, 1);
      return frame_unwind_got_constant (this_frame, regnum, unatN);
    }

  else if (IA64_NAT32_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      int natval = 0;
      /* Find address of general register corresponding to nat bit we're
         interested in.  */
      CORE_ADDR gr_addr;

      gr_addr = cache->saved_regs[regnum - IA64_NAT0_REGNUM + IA64_GR0_REGNUM];

      if (gr_addr != 0)
	{
	  /* Compute address of nat collection bits.  */
	  CORE_ADDR nat_addr = gr_addr | 0x1f8;
	  CORE_ADDR bsp;
	  CORE_ADDR nat_collection;
	  int nat_bit;

	  /* If our nat collection address is bigger than bsp, we have to get
	     the nat collection from rnat.  Otherwise, we fetch the nat
	     collection from the computed address.  */
	  get_frame_register (this_frame, IA64_BSP_REGNUM, buf);
	  bsp = extract_unsigned_integer (buf, 8, byte_order);
	  if (nat_addr >= bsp)
	    {
	      get_frame_register (this_frame, IA64_RNAT_REGNUM, buf);
	      nat_collection = extract_unsigned_integer (buf, 8, byte_order);
	    }
	  else
	    nat_collection = read_memory_integer (nat_addr, 8, byte_order);
	  nat_bit = (gr_addr >> 3) & 0x3f;
	  natval = (nat_collection >> nat_bit) & 1;
	}

      return frame_unwind_got_constant (this_frame, regnum, natval);
    }

  else if (regnum == IA64_IP_REGNUM)
    {
      CORE_ADDR pc = 0;
      CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];

      if (addr != 0)
        {
          read_memory (addr, buf, register_size (gdbarch, IA64_IP_REGNUM));
          pc = extract_unsigned_integer (buf, 8, byte_order);
        }
      else if (cache->frameless)
	{
	  get_frame_register (this_frame, IA64_BR0_REGNUM, buf);
	  pc = extract_unsigned_integer (buf, 8, byte_order);
	}
      pc &= ~0xf;
      return frame_unwind_got_constant (this_frame, regnum, pc);
    }

  else if (regnum == IA64_PSR_REGNUM)
    {
      /* We don't know how to get the complete previous PSR, but we need it
         for the slot information when we unwind the pc (pc is formed of IP
         register plus slot information from PSR).  To get the previous
         slot information, we mask it off the return address.  */
      ULONGEST slot_num = 0;
      CORE_ADDR pc = 0;
      CORE_ADDR psr = 0;
      CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];

      get_frame_register (this_frame, IA64_PSR_REGNUM, buf);
      psr = extract_unsigned_integer (buf, 8, byte_order);

      if (addr != 0)
	{
	  read_memory (addr, buf, register_size (gdbarch, IA64_IP_REGNUM));
	  pc = extract_unsigned_integer (buf, 8, byte_order);
	}
      else if (cache->frameless)
	{
	  get_frame_register (this_frame, IA64_BR0_REGNUM, buf);
	  pc = extract_unsigned_integer (buf, 8, byte_order);
	}
      psr &= ~(3LL << 41);
      slot_num = pc & 0x3LL;
      psr |= (CORE_ADDR)slot_num << 41;
      return frame_unwind_got_constant (this_frame, regnum, psr);
    }

  else if (regnum == IA64_BR0_REGNUM)
    {
      CORE_ADDR addr = cache->saved_regs[IA64_BR0_REGNUM];

      if (addr != 0)
        return frame_unwind_got_memory (this_frame, regnum, addr);

      return frame_unwind_got_constant (this_frame, regnum, 0);
    }

  else if ((regnum >= IA64_GR32_REGNUM && regnum <= IA64_GR127_REGNUM)
           || (regnum >= V32_REGNUM && regnum <= V127_REGNUM))
    {
      CORE_ADDR addr = 0;

      if (regnum >= V32_REGNUM)
	regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);
      addr = cache->saved_regs[regnum];
      if (addr != 0)
        return frame_unwind_got_memory (this_frame, regnum, addr);

      if (cache->frameless)
        {
          struct value *reg_val;
          CORE_ADDR prev_cfm, prev_bsp, prev_bof;

          /* FIXME: brobecker/2008-05-01: Doesn't this seem redundant
             with the same code above?  */
	  if (regnum >= V32_REGNUM)
	    regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);
          reg_val = ia64_frame_prev_register (this_frame, this_cache,
                                              IA64_CFM_REGNUM);
	  prev_cfm = extract_unsigned_integer (value_contents_all (reg_val),
                                               8, byte_order);
	  reg_val = ia64_frame_prev_register (this_frame, this_cache,
                                              IA64_BSP_REGNUM);
	  prev_bsp = extract_unsigned_integer (value_contents_all (reg_val),
                                               8, byte_order);
	  prev_bof = rse_address_add (prev_bsp, -(prev_cfm & 0x7f));

	  addr = rse_address_add (prev_bof, (regnum - IA64_GR32_REGNUM));
          return frame_unwind_got_memory (this_frame, regnum, addr);
        }
      
      return frame_unwind_got_constant (this_frame, regnum, 0);
    }

  else /* All other registers.  */
    {
      CORE_ADDR addr = 0;

      if (IA64_FR32_REGNUM <= regnum && regnum <= IA64_FR127_REGNUM)
	{
	  /* Fetch floating point register rename base from current
	     frame marker for this frame.  */
	  int rrb_fr = (cache->cfm >> 25) & 0x7f;

	  /* Adjust the floating point register number to account for
	     register rotation.  */
	  regnum = IA64_FR32_REGNUM
	         + ((regnum - IA64_FR32_REGNUM) + rrb_fr) % 96;
	}

      /* If we have stored a memory address, access the register.  */
      addr = cache->saved_regs[regnum];
      if (addr != 0)
        return frame_unwind_got_memory (this_frame, regnum, addr);
      /* Otherwise, punt and get the current value of the register.  */
      else 
        return frame_unwind_got_register (this_frame, regnum, regnum);
    }
}
 
static const struct frame_unwind ia64_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  &ia64_frame_this_id,
  &ia64_frame_prev_register,
  NULL,
  default_frame_sniffer
};

/* Signal trampolines.  */

static void
ia64_sigtramp_frame_init_saved_regs (struct frame_info *this_frame,
				     struct ia64_frame_cache *cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (tdep->sigcontext_register_address)
    {
      int regno;

      cache->saved_regs[IA64_VRAP_REGNUM]
	= tdep->sigcontext_register_address (gdbarch, cache->base,
					     IA64_IP_REGNUM);
      cache->saved_regs[IA64_CFM_REGNUM]
	= tdep->sigcontext_register_address (gdbarch, cache->base,
					     IA64_CFM_REGNUM);
      cache->saved_regs[IA64_PSR_REGNUM]
	= tdep->sigcontext_register_address (gdbarch, cache->base,
					     IA64_PSR_REGNUM);
      cache->saved_regs[IA64_BSP_REGNUM]
	= tdep->sigcontext_register_address (gdbarch, cache->base,
					     IA64_BSP_REGNUM);
      cache->saved_regs[IA64_RNAT_REGNUM]
	= tdep->sigcontext_register_address (gdbarch, cache->base,
					     IA64_RNAT_REGNUM);
      cache->saved_regs[IA64_CCV_REGNUM]
	= tdep->sigcontext_register_address (gdbarch, cache->base,
					     IA64_CCV_REGNUM);
      cache->saved_regs[IA64_UNAT_REGNUM]
	= tdep->sigcontext_register_address (gdbarch, cache->base,
					     IA64_UNAT_REGNUM);
      cache->saved_regs[IA64_FPSR_REGNUM]
	= tdep->sigcontext_register_address (gdbarch, cache->base,
					     IA64_FPSR_REGNUM);
      cache->saved_regs[IA64_PFS_REGNUM]
	= tdep->sigcontext_register_address (gdbarch, cache->base,
					     IA64_PFS_REGNUM);
      cache->saved_regs[IA64_LC_REGNUM]
	= tdep->sigcontext_register_address (gdbarch, cache->base,
					     IA64_LC_REGNUM);

      for (regno = IA64_GR1_REGNUM; regno <= IA64_GR31_REGNUM; regno++)
	cache->saved_regs[regno] =
	  tdep->sigcontext_register_address (gdbarch, cache->base, regno);
      for (regno = IA64_BR0_REGNUM; regno <= IA64_BR7_REGNUM; regno++)
	cache->saved_regs[regno] =
	  tdep->sigcontext_register_address (gdbarch, cache->base, regno);
      for (regno = IA64_FR2_REGNUM; regno <= IA64_FR31_REGNUM; regno++)
	cache->saved_regs[regno] =
	  tdep->sigcontext_register_address (gdbarch, cache->base, regno);
    }
}

static struct ia64_frame_cache *
ia64_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct ia64_frame_cache *cache;
  gdb_byte buf[8];

  if (*this_cache)
    return *this_cache;

  cache = ia64_alloc_frame_cache ();

  get_frame_register (this_frame, sp_regnum, buf);
  /* Note that frame size is hard-coded below.  We cannot calculate it
     via prologue examination.  */
  cache->base = extract_unsigned_integer (buf, 8, byte_order) + 16;

  get_frame_register (this_frame, IA64_BSP_REGNUM, buf);
  cache->bsp = extract_unsigned_integer (buf, 8, byte_order);

  get_frame_register (this_frame, IA64_CFM_REGNUM, buf);
  cache->cfm = extract_unsigned_integer (buf, 8, byte_order);
  cache->sof = cache->cfm & 0x7f;

  ia64_sigtramp_frame_init_saved_regs (this_frame, cache);

  *this_cache = cache;
  return cache;
}

static void
ia64_sigtramp_frame_this_id (struct frame_info *this_frame,
			     void **this_cache, struct frame_id *this_id)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct ia64_frame_cache *cache =
    ia64_sigtramp_frame_cache (this_frame, this_cache);

  (*this_id) = frame_id_build_special (cache->base,
                                       get_frame_pc (this_frame),
                                       cache->bsp);
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"sigtramp frame id: code %s, stack %s, "
			"special %s, this_frame %s\n",
			paddress (gdbarch, this_id->code_addr),
			paddress (gdbarch, this_id->stack_addr),
			paddress (gdbarch, cache->bsp),
			host_address_to_string (this_frame));
}

static struct value *
ia64_sigtramp_frame_prev_register (struct frame_info *this_frame,
				   void **this_cache, int regnum)
{
  gdb_byte buf[MAX_REGISTER_SIZE];

  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct ia64_frame_cache *cache =
    ia64_sigtramp_frame_cache (this_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (!target_has_registers)
    error (_("No registers."));

  if (regnum == IA64_IP_REGNUM)
    {
      CORE_ADDR pc = 0;
      CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];

      if (addr != 0)
	{
	  read_memory (addr, buf, register_size (gdbarch, IA64_IP_REGNUM));
	  pc = extract_unsigned_integer (buf, 8, byte_order);
	}
      pc &= ~0xf;
      return frame_unwind_got_constant (this_frame, regnum, pc);
    }

  else if ((regnum >= IA64_GR32_REGNUM && regnum <= IA64_GR127_REGNUM)
           || (regnum >= V32_REGNUM && regnum <= V127_REGNUM))
    {
      CORE_ADDR addr = 0;

      if (regnum >= V32_REGNUM)
	regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);
      addr = cache->saved_regs[regnum];
      if (addr != 0)
        return frame_unwind_got_memory (this_frame, regnum, addr);

      return frame_unwind_got_constant (this_frame, regnum, 0);
    }

  else  /* All other registers not listed above.  */
    {
      CORE_ADDR addr = cache->saved_regs[regnum];

      if (addr != 0)
        return frame_unwind_got_memory (this_frame, regnum, addr);

      return frame_unwind_got_constant (this_frame, regnum, 0);
    }
}

static int
ia64_sigtramp_frame_sniffer (const struct frame_unwind *self,
                             struct frame_info *this_frame,
                             void **this_cache)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));
  if (tdep->pc_in_sigtramp)
    {
      CORE_ADDR pc = get_frame_pc (this_frame);

      if (tdep->pc_in_sigtramp (pc))
	return 1;
    }

  return 0;
}

static const struct frame_unwind ia64_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  default_frame_unwind_stop_reason,
  ia64_sigtramp_frame_this_id,
  ia64_sigtramp_frame_prev_register,
  NULL,
  ia64_sigtramp_frame_sniffer
};



static CORE_ADDR
ia64_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct ia64_frame_cache *cache = ia64_frame_cache (this_frame, this_cache);

  return cache->base;
}

static const struct frame_base ia64_frame_base =
{
  &ia64_frame_unwind,
  ia64_frame_base_address,
  ia64_frame_base_address,
  ia64_frame_base_address
};

#ifdef HAVE_LIBUNWIND_IA64_H

struct ia64_unwind_table_entry
  {
    unw_word_t start_offset;
    unw_word_t end_offset;
    unw_word_t info_offset;
  };

static __inline__ uint64_t
ia64_rse_slot_num (uint64_t addr)
{
  return (addr >> 3) & 0x3f;
}

/* Skip over a designated number of registers in the backing
   store, remembering every 64th position is for NAT.  */
static __inline__ uint64_t
ia64_rse_skip_regs (uint64_t addr, long num_regs)
{
  long delta = ia64_rse_slot_num(addr) + num_regs;

  if (num_regs < 0)
    delta -= 0x3e;
  return addr + ((num_regs + delta/0x3f) << 3);
}
  
/* Gdb ia64-libunwind-tdep callback function to convert from an ia64 gdb
   register number to a libunwind register number.  */
static int
ia64_gdb2uw_regnum (int regnum)
{
  if (regnum == sp_regnum)
    return UNW_IA64_SP;
  else if (regnum == IA64_BSP_REGNUM)
    return UNW_IA64_BSP;
  else if ((unsigned) (regnum - IA64_GR0_REGNUM) < 128)
    return UNW_IA64_GR + (regnum - IA64_GR0_REGNUM);
  else if ((unsigned) (regnum - V32_REGNUM) < 95)
    return UNW_IA64_GR + 32 + (regnum - V32_REGNUM);
  else if ((unsigned) (regnum - IA64_FR0_REGNUM) < 128)
    return UNW_IA64_FR + (regnum - IA64_FR0_REGNUM);
  else if ((unsigned) (regnum - IA64_PR0_REGNUM) < 64)
    return -1;
  else if ((unsigned) (regnum - IA64_BR0_REGNUM) < 8)
    return UNW_IA64_BR + (regnum - IA64_BR0_REGNUM);
  else if (regnum == IA64_PR_REGNUM)
    return UNW_IA64_PR;
  else if (regnum == IA64_IP_REGNUM)
    return UNW_REG_IP;
  else if (regnum == IA64_CFM_REGNUM)
    return UNW_IA64_CFM;
  else if ((unsigned) (regnum - IA64_AR0_REGNUM) < 128)
    return UNW_IA64_AR + (regnum - IA64_AR0_REGNUM);
  else if ((unsigned) (regnum - IA64_NAT0_REGNUM) < 128)
    return UNW_IA64_NAT + (regnum - IA64_NAT0_REGNUM);
  else
    return -1;
}
  
/* Gdb ia64-libunwind-tdep callback function to convert from a libunwind
   register number to a ia64 gdb register number.  */
static int
ia64_uw2gdb_regnum (int uw_regnum)
{
  if (uw_regnum == UNW_IA64_SP)
    return sp_regnum;
  else if (uw_regnum == UNW_IA64_BSP)
    return IA64_BSP_REGNUM;
  else if ((unsigned) (uw_regnum - UNW_IA64_GR) < 32)
    return IA64_GR0_REGNUM + (uw_regnum - UNW_IA64_GR);
  else if ((unsigned) (uw_regnum - UNW_IA64_GR) < 128)
    return V32_REGNUM + (uw_regnum - (IA64_GR0_REGNUM + 32));
  else if ((unsigned) (uw_regnum - UNW_IA64_FR) < 128)
    return IA64_FR0_REGNUM + (uw_regnum - UNW_IA64_FR);
  else if ((unsigned) (uw_regnum - UNW_IA64_BR) < 8)
    return IA64_BR0_REGNUM + (uw_regnum - UNW_IA64_BR);
  else if (uw_regnum == UNW_IA64_PR)
    return IA64_PR_REGNUM;
  else if (uw_regnum == UNW_REG_IP)
    return IA64_IP_REGNUM;
  else if (uw_regnum == UNW_IA64_CFM)
    return IA64_CFM_REGNUM;
  else if ((unsigned) (uw_regnum - UNW_IA64_AR) < 128)
    return IA64_AR0_REGNUM + (uw_regnum - UNW_IA64_AR);
  else if ((unsigned) (uw_regnum - UNW_IA64_NAT) < 128)
    return IA64_NAT0_REGNUM + (uw_regnum - UNW_IA64_NAT);
  else
    return -1;
}

/* Gdb ia64-libunwind-tdep callback function to reveal if register is
   a float register or not.  */
static int
ia64_is_fpreg (int uw_regnum)
{
  return unw_is_fpreg (uw_regnum);
}

/* Libunwind callback accessor function for general registers.  */
static int
ia64_access_reg (unw_addr_space_t as, unw_regnum_t uw_regnum, unw_word_t *val, 
		 int write, void *arg)
{
  int regnum = ia64_uw2gdb_regnum (uw_regnum);
  unw_word_t bsp, sof, sol, cfm, psr, ip;
  struct frame_info *this_frame = arg;
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  long new_sof, old_sof;
  gdb_byte buf[MAX_REGISTER_SIZE];
  
  /* We never call any libunwind routines that need to write registers.  */
  gdb_assert (!write);

  switch (uw_regnum)
    {
      case UNW_REG_IP:
	/* Libunwind expects to see the pc value which means the slot number
	   from the psr must be merged with the ip word address.  */
	get_frame_register (this_frame, IA64_IP_REGNUM, buf);
	ip = extract_unsigned_integer (buf, 8, byte_order);
	get_frame_register (this_frame, IA64_PSR_REGNUM, buf);
	psr = extract_unsigned_integer (buf, 8, byte_order);
	*val = ip | ((psr >> 41) & 0x3);
	break;
 
      case UNW_IA64_AR_BSP:
	/* Libunwind expects to see the beginning of the current
	   register frame so we must account for the fact that
	   ptrace() will return a value for bsp that points *after*
	   the current register frame.  */
	get_frame_register (this_frame, IA64_BSP_REGNUM, buf);
	bsp = extract_unsigned_integer (buf, 8, byte_order);
	get_frame_register (this_frame, IA64_CFM_REGNUM, buf);
	cfm = extract_unsigned_integer (buf, 8, byte_order);
	sof = gdbarch_tdep (gdbarch)->size_of_register_frame (this_frame, cfm);
	*val = ia64_rse_skip_regs (bsp, -sof);
	break;

      case UNW_IA64_AR_BSPSTORE:
	/* Libunwind wants bspstore to be after the current register frame.
	   This is what ptrace() and gdb treats as the regular bsp value.  */
	get_frame_register (this_frame, IA64_BSP_REGNUM, buf);
	*val = extract_unsigned_integer (buf, 8, byte_order);
	break;

      default:
	/* For all other registers, just unwind the value directly.  */
	get_frame_register (this_frame, regnum, buf);
	*val = extract_unsigned_integer (buf, 8, byte_order);
	break;
    }
      
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog, 
			"  access_reg: from cache: %4s=%s\n",
			(((unsigned) regnum <= IA64_NAT127_REGNUM)
			? ia64_register_names[regnum] : "r??"), 
			paddress (gdbarch, *val));
  return 0;
}

/* Libunwind callback accessor function for floating-point registers.  */
static int
ia64_access_fpreg (unw_addr_space_t as, unw_regnum_t uw_regnum,
		   unw_fpreg_t *val, int write, void *arg)
{
  int regnum = ia64_uw2gdb_regnum (uw_regnum);
  struct frame_info *this_frame = arg;
  
  /* We never call any libunwind routines that need to write registers.  */
  gdb_assert (!write);

  get_frame_register (this_frame, regnum, (gdb_byte *) val);

  return 0;
}

/* Libunwind callback accessor function for top-level rse registers.  */
static int
ia64_access_rse_reg (unw_addr_space_t as, unw_regnum_t uw_regnum,
		     unw_word_t *val, int write, void *arg)
{
  int regnum = ia64_uw2gdb_regnum (uw_regnum);
  unw_word_t bsp, sof, sol, cfm, psr, ip;
  struct regcache *regcache = arg;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  long new_sof, old_sof;
  gdb_byte buf[MAX_REGISTER_SIZE];
  
  /* We never call any libunwind routines that need to write registers.  */
  gdb_assert (!write);

  switch (uw_regnum)
    {
      case UNW_REG_IP:
	/* Libunwind expects to see the pc value which means the slot number
	   from the psr must be merged with the ip word address.  */
	regcache_cooked_read (regcache, IA64_IP_REGNUM, buf);
	ip = extract_unsigned_integer (buf, 8, byte_order);
	regcache_cooked_read (regcache, IA64_PSR_REGNUM, buf);
	psr = extract_unsigned_integer (buf, 8, byte_order);
	*val = ip | ((psr >> 41) & 0x3);
	break;
	  
      case UNW_IA64_AR_BSP:
	/* Libunwind expects to see the beginning of the current
	   register frame so we must account for the fact that
	   ptrace() will return a value for bsp that points *after*
	   the current register frame.  */
	regcache_cooked_read (regcache, IA64_BSP_REGNUM, buf);
	bsp = extract_unsigned_integer (buf, 8, byte_order);
	regcache_cooked_read (regcache, IA64_CFM_REGNUM, buf);
	cfm = extract_unsigned_integer (buf, 8, byte_order);
	sof = (cfm & 0x7f);
	*val = ia64_rse_skip_regs (bsp, -sof);
	break;
	  
      case UNW_IA64_AR_BSPSTORE:
	/* Libunwind wants bspstore to be after the current register frame.
	   This is what ptrace() and gdb treats as the regular bsp value.  */
	regcache_cooked_read (regcache, IA64_BSP_REGNUM, buf);
	*val = extract_unsigned_integer (buf, 8, byte_order);
	break;

      default:
        /* For all other registers, just unwind the value directly.  */
	regcache_cooked_read (regcache, regnum, buf);
	*val = extract_unsigned_integer (buf, 8, byte_order);
	break;
    }
      
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog, 
			"  access_rse_reg: from cache: %4s=%s\n",
			(((unsigned) regnum <= IA64_NAT127_REGNUM)
			 ? ia64_register_names[regnum] : "r??"), 
			paddress (gdbarch, *val));

  return 0;
}

/* Libunwind callback accessor function for top-level fp registers.  */
static int
ia64_access_rse_fpreg (unw_addr_space_t as, unw_regnum_t uw_regnum,
		       unw_fpreg_t *val, int write, void *arg)
{
  int regnum = ia64_uw2gdb_regnum (uw_regnum);
  struct regcache *regcache = arg;
  
  /* We never call any libunwind routines that need to write registers.  */
  gdb_assert (!write);

  regcache_cooked_read (regcache, regnum, (gdb_byte *) val);

  return 0;
}

/* Libunwind callback accessor function for accessing memory.  */
static int
ia64_access_mem (unw_addr_space_t as,
		 unw_word_t addr, unw_word_t *val,
		 int write, void *arg)
{
  if (addr - KERNEL_START < ktab_size)
    {
      unw_word_t *laddr = (unw_word_t*) ((char *) ktab
                          + (addr - KERNEL_START));
		
      if (write)
        *laddr = *val; 
      else 
        *val = *laddr;
      return 0;
    }

  /* XXX do we need to normalize byte-order here?  */
  if (write)
    return target_write_memory (addr, (gdb_byte *) val, sizeof (unw_word_t));
  else
    return target_read_memory (addr, (gdb_byte *) val, sizeof (unw_word_t));
}

/* Call low-level function to access the kernel unwind table.  */
static LONGEST
getunwind_table (gdb_byte **buf_p)
{
  LONGEST x;

  /* FIXME drow/2005-09-10: This code used to call
     ia64_linux_xfer_unwind_table directly to fetch the unwind table
     for the currently running ia64-linux kernel.  That data should
     come from the core file and be accessed via the auxv vector; if
     we want to preserve fall back to the running kernel's table, then
     we should find a way to override the corefile layer's
     xfer_partial method.  */

  x = target_read_alloc (&current_target, TARGET_OBJECT_UNWIND_TABLE,
			 NULL, buf_p);

  return x;
}

/* Get the kernel unwind table.  */				 
static int
get_kernel_table (unw_word_t ip, unw_dyn_info_t *di)
{
  static struct ia64_table_entry *etab;

  if (!ktab) 
    {
      gdb_byte *ktab_buf;
      LONGEST size;

      size = getunwind_table (&ktab_buf);
      if (size <= 0)
	return -UNW_ENOINFO;

      ktab = (struct ia64_table_entry *) ktab_buf;
      ktab_size = size;

      for (etab = ktab; etab->start_offset; ++etab)
        etab->info_offset += KERNEL_START;
    }
  
  if (ip < ktab[0].start_offset || ip >= etab[-1].end_offset)
    return -UNW_ENOINFO;
  
  di->format = UNW_INFO_FORMAT_TABLE;
  di->gp = 0;
  di->start_ip = ktab[0].start_offset;
  di->end_ip = etab[-1].end_offset;
  di->u.ti.name_ptr = (unw_word_t) "<kernel>";
  di->u.ti.segbase = 0;
  di->u.ti.table_len = ((char *) etab - (char *) ktab) / sizeof (unw_word_t);
  di->u.ti.table_data = (unw_word_t *) ktab;
  
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog, "get_kernel_table: found table `%s': "
			"segbase=%s, length=%s, gp=%s\n",
			(char *) di->u.ti.name_ptr, 
			hex_string (di->u.ti.segbase),
			pulongest (di->u.ti.table_len), 
			hex_string (di->gp));
  return 0;
}

/* Find the unwind table entry for a specified address.  */
static int
ia64_find_unwind_table (struct objfile *objfile, unw_word_t ip,
			unw_dyn_info_t *dip, void **buf)
{
  Elf_Internal_Phdr *phdr, *p_text = NULL, *p_unwind = NULL;
  Elf_Internal_Ehdr *ehdr;
  unw_word_t segbase = 0;
  CORE_ADDR load_base;
  bfd *bfd;
  int i;

  bfd = objfile->obfd;
  
  ehdr = elf_tdata (bfd)->elf_header;
  phdr = elf_tdata (bfd)->phdr;

  load_base = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  for (i = 0; i < ehdr->e_phnum; ++i)
    {
      switch (phdr[i].p_type)
	{
	case PT_LOAD:
	  if ((unw_word_t) (ip - load_base - phdr[i].p_vaddr)
	      < phdr[i].p_memsz)
	    p_text = phdr + i;
	  break;

	case PT_IA_64_UNWIND:
	  p_unwind = phdr + i;
	  break;

	default:
	  break;
	}
    }

  if (!p_text || !p_unwind)
    return -UNW_ENOINFO;

  /* Verify that the segment that contains the IP also contains
     the static unwind table.  If not, we may be in the Linux kernel's
     DSO gate page in which case the unwind table is another segment.
     Otherwise, we are dealing with runtime-generated code, for which we 
     have no info here.  */
  segbase = p_text->p_vaddr + load_base;

  if ((p_unwind->p_vaddr - p_text->p_vaddr) >= p_text->p_memsz)
    {
      int ok = 0;
      for (i = 0; i < ehdr->e_phnum; ++i)
        {
          if (phdr[i].p_type == PT_LOAD
	      && (p_unwind->p_vaddr - phdr[i].p_vaddr) < phdr[i].p_memsz)
	    {
              ok = 1;
	      /* Get the segbase from the section containing the
		 libunwind table.  */
	      segbase = phdr[i].p_vaddr + load_base;
	    }
	}
      if (!ok)
        return -UNW_ENOINFO;
    }

  dip->start_ip = p_text->p_vaddr + load_base;
  dip->end_ip = dip->start_ip + p_text->p_memsz;
  dip->gp = ia64_find_global_pointer (get_objfile_arch (objfile), ip);
  dip->format = UNW_INFO_FORMAT_REMOTE_TABLE;
  dip->u.rti.name_ptr = (unw_word_t) bfd_get_filename (bfd);
  dip->u.rti.segbase = segbase;
  dip->u.rti.table_len = p_unwind->p_memsz / sizeof (unw_word_t);
  dip->u.rti.table_data = p_unwind->p_vaddr + load_base;

  return 0;
}

/* Libunwind callback accessor function to acquire procedure unwind-info.  */
static int
ia64_find_proc_info_x (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
		       int need_unwind_info, void *arg)
{
  struct obj_section *sec = find_pc_section (ip);
  unw_dyn_info_t di;
  int ret;
  void *buf = NULL;

  if (!sec)
    {
      /* XXX This only works if the host and the target architecture are
	 both ia64 and if the have (more or less) the same kernel
	 version.  */
      if (get_kernel_table (ip, &di) < 0)
	return -UNW_ENOINFO;

      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, "ia64_find_proc_info_x: %s -> "
			    "(name=`%s',segbase=%s,start=%s,end=%s,gp=%s,"
			    "length=%s,data=%s)\n",
			    hex_string (ip), (char *)di.u.ti.name_ptr,
			    hex_string (di.u.ti.segbase),
			    hex_string (di.start_ip), hex_string (di.end_ip),
			    hex_string (di.gp),
			    pulongest (di.u.ti.table_len), 
			    hex_string ((CORE_ADDR)di.u.ti.table_data));
    }
  else
    {
      ret = ia64_find_unwind_table (sec->objfile, ip, &di, &buf);
      if (ret < 0)
	return ret;

      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, "ia64_find_proc_info_x: %s -> "
			    "(name=`%s',segbase=%s,start=%s,end=%s,gp=%s,"
			    "length=%s,data=%s)\n",
			    hex_string (ip), (char *)di.u.rti.name_ptr,
			    hex_string (di.u.rti.segbase),
			    hex_string (di.start_ip), hex_string (di.end_ip),
			    hex_string (di.gp),
			    pulongest (di.u.rti.table_len), 
			    hex_string (di.u.rti.table_data));
    }

  ret = libunwind_search_unwind_table (&as, ip, &di, pi, need_unwind_info,
				       arg);

  /* We no longer need the dyn info storage so free it.  */
  xfree (buf);

  return ret;
}

/* Libunwind callback accessor function for cleanup.  */
static void
ia64_put_unwind_info (unw_addr_space_t as,
		      unw_proc_info_t *pip, void *arg)
{
  /* Nothing required for now.  */
}

/* Libunwind callback accessor function to get head of the dynamic 
   unwind-info registration list.  */ 
static int
ia64_get_dyn_info_list (unw_addr_space_t as,
			unw_word_t *dilap, void *arg)
{
  struct obj_section *text_sec;
  struct objfile *objfile;
  unw_word_t ip, addr;
  unw_dyn_info_t di;
  int ret;

  if (!libunwind_is_initialized ())
    return -UNW_ENOINFO;

  for (objfile = object_files; objfile; objfile = objfile->next)
    {
      void *buf = NULL;

      text_sec = objfile->sections + SECT_OFF_TEXT (objfile);
      ip = obj_section_addr (text_sec);
      ret = ia64_find_unwind_table (objfile, ip, &di, &buf);
      if (ret >= 0)
	{
	  addr = libunwind_find_dyn_list (as, &di, arg);
	  /* We no longer need the dyn info storage so free it.  */
	  xfree (buf);

	  if (addr)
	    {
	      if (gdbarch_debug >= 1)
		fprintf_unfiltered (gdb_stdlog,
				    "dynamic unwind table in objfile %s "
				    "at %s (gp=%s)\n",
				    bfd_get_filename (objfile->obfd),
				    hex_string (addr), hex_string (di.gp));
	      *dilap = addr;
	      return 0;
	    }
	}
    }
  return -UNW_ENOINFO;
}


/* Frame interface functions for libunwind.  */

static void
ia64_libunwind_frame_this_id (struct frame_info *this_frame, void **this_cache,
			      struct frame_id *this_id)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct frame_id id = outer_frame_id;
  gdb_byte buf[8];
  CORE_ADDR bsp;

  libunwind_frame_this_id (this_frame, this_cache, &id);
  if (frame_id_eq (id, outer_frame_id))
    {
      (*this_id) = outer_frame_id;
      return;
    }

  /* We must add the bsp as the special address for frame comparison 
     purposes.  */
  get_frame_register (this_frame, IA64_BSP_REGNUM, buf);
  bsp = extract_unsigned_integer (buf, 8, byte_order);

  (*this_id) = frame_id_build_special (id.stack_addr, id.code_addr, bsp);

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"libunwind frame id: code %s, stack %s, "
			"special %s, this_frame %s\n",
			paddress (gdbarch, id.code_addr),
			paddress (gdbarch, id.stack_addr),
			paddress (gdbarch, bsp),
			host_address_to_string (this_frame));
}

static struct value *
ia64_libunwind_frame_prev_register (struct frame_info *this_frame,
				    void **this_cache, int regnum)
{
  int reg = regnum;
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct value *val;

  if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    reg = IA64_PR_REGNUM;
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    reg = IA64_UNAT_REGNUM;

  /* Let libunwind do most of the work.  */
  val = libunwind_frame_prev_register (this_frame, this_cache, reg);

  if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    {
      ULONGEST prN_val;

      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  int rrb_pr = 0;
	  ULONGEST cfm;
	  gdb_byte buf[MAX_REGISTER_SIZE];

	  /* Fetch predicate register rename base from current frame
	     marker for this frame.  */
	  get_frame_register (this_frame, IA64_CFM_REGNUM, buf);
	  cfm = extract_unsigned_integer (buf, 8, byte_order);
	  rrb_pr = (cfm >> 32) & 0x3f;
	  
	  /* Adjust the register number to account for register rotation.  */
	  regnum = VP16_REGNUM + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = extract_bit_field (value_contents_all (val),
				   regnum - VP0_REGNUM, 1);
      return frame_unwind_got_constant (this_frame, regnum, prN_val);
    }

  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      ULONGEST unatN_val;

      unatN_val = extract_bit_field (value_contents_all (val),
                                     regnum - IA64_NAT0_REGNUM, 1);
      return frame_unwind_got_constant (this_frame, regnum, unatN_val);
    }

  else if (regnum == IA64_BSP_REGNUM)
    {
      struct value *cfm_val;
      CORE_ADDR prev_bsp, prev_cfm;

      /* We want to calculate the previous bsp as the end of the previous
         register stack frame.  This corresponds to what the hardware bsp
         register will be if we pop the frame back which is why we might
         have been called.  We know that libunwind will pass us back the
         beginning of the current frame so we should just add sof to it.  */
      prev_bsp = extract_unsigned_integer (value_contents_all (val),
					   8, byte_order);
      cfm_val = libunwind_frame_prev_register (this_frame, this_cache,
                                               IA64_CFM_REGNUM);
      prev_cfm = extract_unsigned_integer (value_contents_all (cfm_val),
					   8, byte_order);
      prev_bsp = rse_address_add (prev_bsp, (prev_cfm & 0x7f));

      return frame_unwind_got_constant (this_frame, regnum, prev_bsp);
    }
  else
    return val;
}

static int
ia64_libunwind_frame_sniffer (const struct frame_unwind *self,
                              struct frame_info *this_frame,
                              void **this_cache)
{
  if (libunwind_is_initialized ()
      && libunwind_frame_sniffer (self, this_frame, this_cache))
    return 1;

  return 0;
}

static const struct frame_unwind ia64_libunwind_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  ia64_libunwind_frame_this_id,
  ia64_libunwind_frame_prev_register,
  NULL,
  ia64_libunwind_frame_sniffer,
  libunwind_frame_dealloc_cache
};

static void
ia64_libunwind_sigtramp_frame_this_id (struct frame_info *this_frame,
                                       void **this_cache,
				       struct frame_id *this_id)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[8];
  CORE_ADDR bsp;
  struct frame_id id = outer_frame_id;
  CORE_ADDR prev_ip;

  libunwind_frame_this_id (this_frame, this_cache, &id);
  if (frame_id_eq (id, outer_frame_id))
    {
      (*this_id) = outer_frame_id;
      return;
    }

  /* We must add the bsp as the special address for frame comparison 
     purposes.  */
  get_frame_register (this_frame, IA64_BSP_REGNUM, buf);
  bsp = extract_unsigned_integer (buf, 8, byte_order);

  /* For a sigtramp frame, we don't make the check for previous ip being 0.  */
  (*this_id) = frame_id_build_special (id.stack_addr, id.code_addr, bsp);

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"libunwind sigtramp frame id: code %s, "
			"stack %s, special %s, this_frame %s\n",
			paddress (gdbarch, id.code_addr),
			paddress (gdbarch, id.stack_addr),
			paddress (gdbarch, bsp),
			host_address_to_string (this_frame));
}

static struct value *
ia64_libunwind_sigtramp_frame_prev_register (struct frame_info *this_frame,
					     void **this_cache, int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct value *prev_ip_val;
  CORE_ADDR prev_ip;

  /* If the previous frame pc value is 0, then we want to use the SIGCONTEXT
     method of getting previous registers.  */
  prev_ip_val = libunwind_frame_prev_register (this_frame, this_cache,
                                               IA64_IP_REGNUM);
  prev_ip = extract_unsigned_integer (value_contents_all (prev_ip_val),
				      8, byte_order);

  if (prev_ip == 0)
    {
      void *tmp_cache = NULL;
      return ia64_sigtramp_frame_prev_register (this_frame, &tmp_cache,
                                                regnum);
    }
  else
    return ia64_libunwind_frame_prev_register (this_frame, this_cache, regnum);
}

static int
ia64_libunwind_sigtramp_frame_sniffer (const struct frame_unwind *self,
                                       struct frame_info *this_frame,
                                       void **this_cache)
{
  if (libunwind_is_initialized ())
    {
      if (libunwind_sigtramp_frame_sniffer (self, this_frame, this_cache))
        return 1;
      return 0;
    }
  else
    return ia64_sigtramp_frame_sniffer (self, this_frame, this_cache);
}

static const struct frame_unwind ia64_libunwind_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  default_frame_unwind_stop_reason,
  ia64_libunwind_sigtramp_frame_this_id,
  ia64_libunwind_sigtramp_frame_prev_register,
  NULL,
  ia64_libunwind_sigtramp_frame_sniffer
};

/* Set of libunwind callback acccessor functions.  */
unw_accessors_t ia64_unw_accessors =
{
  ia64_find_proc_info_x,
  ia64_put_unwind_info,
  ia64_get_dyn_info_list,
  ia64_access_mem,
  ia64_access_reg,
  ia64_access_fpreg,
  /* resume */
  /* get_proc_name */
};

/* Set of special libunwind callback acccessor functions specific for accessing
   the rse registers.  At the top of the stack, we want libunwind to figure out
   how to read r32 - r127.  Though usually they are found sequentially in
   memory starting from $bof, this is not always true.  */
unw_accessors_t ia64_unw_rse_accessors =
{
  ia64_find_proc_info_x,
  ia64_put_unwind_info,
  ia64_get_dyn_info_list,
  ia64_access_mem,
  ia64_access_rse_reg,
  ia64_access_rse_fpreg,
  /* resume */
  /* get_proc_name */
};

/* Set of ia64-libunwind-tdep gdb callbacks and data for generic
   ia64-libunwind-tdep code to use.  */
struct libunwind_descr ia64_libunwind_descr =
{
  ia64_gdb2uw_regnum, 
  ia64_uw2gdb_regnum, 
  ia64_is_fpreg, 
  &ia64_unw_accessors,
  &ia64_unw_rse_accessors,
};

#endif /* HAVE_LIBUNWIND_IA64_H  */

static int
ia64_use_struct_convention (struct type *type)
{
  struct type *float_elt_type;

  /* Don't use the struct convention for anything but structure,
     union, or array types.  */
  if (!(TYPE_CODE (type) == TYPE_CODE_STRUCT
	|| TYPE_CODE (type) == TYPE_CODE_UNION
	|| TYPE_CODE (type) == TYPE_CODE_ARRAY))
    return 0;

  /* HFAs are structures (or arrays) consisting entirely of floating
     point values of the same length.  Up to 8 of these are returned
     in registers.  Don't use the struct convention when this is the
     case.  */
  float_elt_type = is_float_or_hfa_type (type);
  if (float_elt_type != NULL
      && TYPE_LENGTH (type) / TYPE_LENGTH (float_elt_type) <= 8)
    return 0;

  /* Other structs of length 32 or less are returned in r8-r11.
     Don't use the struct convention for those either.  */
  return TYPE_LENGTH (type) > 32;
}

/* Return non-zero if TYPE is a structure or union type.  */

static int
ia64_struct_type_p (const struct type *type)
{
  return (TYPE_CODE (type) == TYPE_CODE_STRUCT
          || TYPE_CODE (type) == TYPE_CODE_UNION);
}

static void
ia64_extract_return_value (struct type *type, struct regcache *regcache,
			   gdb_byte *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct type *float_elt_type;

  float_elt_type = is_float_or_hfa_type (type);
  if (float_elt_type != NULL)
    {
      gdb_byte from[MAX_REGISTER_SIZE];
      int offset = 0;
      int regnum = IA64_FR8_REGNUM;
      int n = TYPE_LENGTH (type) / TYPE_LENGTH (float_elt_type);

      while (n-- > 0)
	{
	  regcache_cooked_read (regcache, regnum, from);
	  convert_typed_floating (from, ia64_ext_type (gdbarch),
				  (char *)valbuf + offset, float_elt_type);
	  offset += TYPE_LENGTH (float_elt_type);
	  regnum++;
	}
    }
  else if (!ia64_struct_type_p (type) && TYPE_LENGTH (type) < 8)
    {
      /* This is an integral value, and its size is less than 8 bytes.
         These values are LSB-aligned, so extract the relevant bytes,
         and copy them into VALBUF.  */
      /* brobecker/2005-12-30: Actually, all integral values are LSB aligned,
	 so I suppose we should also add handling here for integral values
	 whose size is greater than 8.  But I wasn't able to create such
	 a type, neither in C nor in Ada, so not worrying about these yet.  */
      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
      ULONGEST val;

      regcache_cooked_read_unsigned (regcache, IA64_GR8_REGNUM, &val);
      store_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order, val);
    }
  else
    {
      ULONGEST val;
      int offset = 0;
      int regnum = IA64_GR8_REGNUM;
      int reglen = TYPE_LENGTH (register_type (gdbarch, IA64_GR8_REGNUM));
      int n = TYPE_LENGTH (type) / reglen;
      int m = TYPE_LENGTH (type) % reglen;

      while (n-- > 0)
	{
	  ULONGEST val;
	  regcache_cooked_read_unsigned (regcache, regnum, &val);
	  memcpy ((char *)valbuf + offset, &val, reglen);
	  offset += reglen;
	  regnum++;
	}

      if (m)
	{
          regcache_cooked_read_unsigned (regcache, regnum, &val);
	  memcpy ((char *)valbuf + offset, &val, m);
	}
    }
}

static void
ia64_store_return_value (struct type *type, struct regcache *regcache, 
			 const gdb_byte *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct type *float_elt_type;

  float_elt_type = is_float_or_hfa_type (type);
  if (float_elt_type != NULL)
    {
      gdb_byte to[MAX_REGISTER_SIZE];
      int offset = 0;
      int regnum = IA64_FR8_REGNUM;
      int n = TYPE_LENGTH (type) / TYPE_LENGTH (float_elt_type);

      while (n-- > 0)
	{
	  convert_typed_floating ((char *)valbuf + offset, float_elt_type,
				  to, ia64_ext_type (gdbarch));
	  regcache_cooked_write (regcache, regnum, to);
	  offset += TYPE_LENGTH (float_elt_type);
	  regnum++;
	}
    }
  else
    {
      ULONGEST val;
      int offset = 0;
      int regnum = IA64_GR8_REGNUM;
      int reglen = TYPE_LENGTH (register_type (gdbarch, IA64_GR8_REGNUM));
      int n = TYPE_LENGTH (type) / reglen;
      int m = TYPE_LENGTH (type) % reglen;

      while (n-- > 0)
	{
	  ULONGEST val;
	  memcpy (&val, (char *)valbuf + offset, reglen);
	  regcache_cooked_write_unsigned (regcache, regnum, val);
	  offset += reglen;
	  regnum++;
	}

      if (m)
	{
	  memcpy (&val, (char *)valbuf + offset, m);
          regcache_cooked_write_unsigned (regcache, regnum, val);
	}
    }
}
  
static enum return_value_convention
ia64_return_value (struct gdbarch *gdbarch, struct value *function,
		   struct type *valtype, struct regcache *regcache,
		   gdb_byte *readbuf, const gdb_byte *writebuf)
{
  int struct_return = ia64_use_struct_convention (valtype);

  if (writebuf != NULL)
    {
      gdb_assert (!struct_return);
      ia64_store_return_value (valtype, regcache, writebuf);
    }

  if (readbuf != NULL)
    {
      gdb_assert (!struct_return);
      ia64_extract_return_value (valtype, regcache, readbuf);
    }

  if (struct_return)
    return RETURN_VALUE_STRUCT_CONVENTION;
  else
    return RETURN_VALUE_REGISTER_CONVENTION;
}

static int
is_float_or_hfa_type_recurse (struct type *t, struct type **etp)
{
  switch (TYPE_CODE (t))
    {
    case TYPE_CODE_FLT:
      if (*etp)
	return TYPE_LENGTH (*etp) == TYPE_LENGTH (t);
      else
	{
	  *etp = t;
	  return 1;
	}
      break;
    case TYPE_CODE_ARRAY:
      return
	is_float_or_hfa_type_recurse (check_typedef (TYPE_TARGET_TYPE (t)),
				      etp);
      break;
    case TYPE_CODE_STRUCT:
      {
	int i;

	for (i = 0; i < TYPE_NFIELDS (t); i++)
	  if (!is_float_or_hfa_type_recurse
	      (check_typedef (TYPE_FIELD_TYPE (t, i)), etp))
	    return 0;
	return 1;
      }
      break;
    default:
      return 0;
      break;
    }
}

/* Determine if the given type is one of the floating point types or
   and HFA (which is a struct, array, or combination thereof whose
   bottom-most elements are all of the same floating point type).  */

static struct type *
is_float_or_hfa_type (struct type *t)
{
  struct type *et = 0;

  return is_float_or_hfa_type_recurse (t, &et) ? et : 0;
}


/* Return 1 if the alignment of T is such that the next even slot
   should be used.  Return 0, if the next available slot should
   be used.  (See section 8.5.1 of the IA-64 Software Conventions
   and Runtime manual).  */

static int
slot_alignment_is_next_even (struct type *t)
{
  switch (TYPE_CODE (t))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_FLT:
      if (TYPE_LENGTH (t) > 8)
	return 1;
      else
	return 0;
    case TYPE_CODE_ARRAY:
      return
	slot_alignment_is_next_even (check_typedef (TYPE_TARGET_TYPE (t)));
    case TYPE_CODE_STRUCT:
      {
	int i;

	for (i = 0; i < TYPE_NFIELDS (t); i++)
	  if (slot_alignment_is_next_even
	      (check_typedef (TYPE_FIELD_TYPE (t, i))))
	    return 1;
	return 0;
      }
    default:
      return 0;
    }
}

/* Attempt to find (and return) the global pointer for the given
   function.

   This is a rather nasty bit of code searchs for the .dynamic section
   in the objfile corresponding to the pc of the function we're trying
   to call.  Once it finds the addresses at which the .dynamic section
   lives in the child process, it scans the Elf64_Dyn entries for a
   DT_PLTGOT tag.  If it finds one of these, the corresponding
   d_un.d_ptr value is the global pointer.  */

static CORE_ADDR
ia64_find_global_pointer_from_dynamic_section (struct gdbarch *gdbarch,
					       CORE_ADDR faddr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct obj_section *faddr_sect;
     
  faddr_sect = find_pc_section (faddr);
  if (faddr_sect != NULL)
    {
      struct obj_section *osect;

      ALL_OBJFILE_OSECTIONS (faddr_sect->objfile, osect)
	{
	  if (strcmp (osect->the_bfd_section->name, ".dynamic") == 0)
	    break;
	}

      if (osect < faddr_sect->objfile->sections_end)
	{
	  CORE_ADDR addr, endaddr;

	  addr = obj_section_addr (osect);
	  endaddr = obj_section_endaddr (osect);

	  while (addr < endaddr)
	    {
	      int status;
	      LONGEST tag;
	      gdb_byte buf[8];

	      status = target_read_memory (addr, buf, sizeof (buf));
	      if (status != 0)
		break;
	      tag = extract_signed_integer (buf, sizeof (buf), byte_order);

	      if (tag == DT_PLTGOT)
		{
		  CORE_ADDR global_pointer;

		  status = target_read_memory (addr + 8, buf, sizeof (buf));
		  if (status != 0)
		    break;
		  global_pointer = extract_unsigned_integer (buf, sizeof (buf),
							     byte_order);

		  /* The payoff...  */
		  return global_pointer;
		}

	      if (tag == DT_NULL)
		break;

	      addr += 16;
	    }
	}
    }
  return 0;
}

/* Attempt to find (and return) the global pointer for the given
   function.  We first try the find_global_pointer_from_solib routine
   from the gdbarch tdep vector, if provided.  And if that does not
   work, then we try ia64_find_global_pointer_from_dynamic_section.  */

static CORE_ADDR
ia64_find_global_pointer (struct gdbarch *gdbarch, CORE_ADDR faddr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  CORE_ADDR addr = 0;

  if (tdep->find_global_pointer_from_solib)
    addr = tdep->find_global_pointer_from_solib (gdbarch, faddr);
  if (addr == 0)
    addr = ia64_find_global_pointer_from_dynamic_section (gdbarch, faddr);
  return addr;
}

/* Given a function's address, attempt to find (and return) the
   corresponding (canonical) function descriptor.  Return 0 if
   not found.  */
static CORE_ADDR
find_extant_func_descr (struct gdbarch *gdbarch, CORE_ADDR faddr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct obj_section *faddr_sect;

  /* Return early if faddr is already a function descriptor.  */
  faddr_sect = find_pc_section (faddr);
  if (faddr_sect && strcmp (faddr_sect->the_bfd_section->name, ".opd") == 0)
    return faddr;

  if (faddr_sect != NULL)
    {
      struct obj_section *osect;
      ALL_OBJFILE_OSECTIONS (faddr_sect->objfile, osect)
	{
	  if (strcmp (osect->the_bfd_section->name, ".opd") == 0)
	    break;
	}

      if (osect < faddr_sect->objfile->sections_end)
	{
	  CORE_ADDR addr, endaddr;

	  addr = obj_section_addr (osect);
	  endaddr = obj_section_endaddr (osect);

	  while (addr < endaddr)
	    {
	      int status;
	      LONGEST faddr2;
	      gdb_byte buf[8];

	      status = target_read_memory (addr, buf, sizeof (buf));
	      if (status != 0)
		break;
	      faddr2 = extract_signed_integer (buf, sizeof (buf), byte_order);

	      if (faddr == faddr2)
		return addr;

	      addr += 16;
	    }
	}
    }
  return 0;
}

/* Attempt to find a function descriptor corresponding to the
   given address.  If none is found, construct one on the
   stack using the address at fdaptr.  */

static CORE_ADDR
find_func_descr (struct regcache *regcache, CORE_ADDR faddr, CORE_ADDR *fdaptr)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR fdesc;

  fdesc = find_extant_func_descr (gdbarch, faddr);

  if (fdesc == 0)
    {
      ULONGEST global_pointer;
      gdb_byte buf[16];

      fdesc = *fdaptr;
      *fdaptr += 16;

      global_pointer = ia64_find_global_pointer (gdbarch, faddr);

      if (global_pointer == 0)
	regcache_cooked_read_unsigned (regcache,
				       IA64_GR1_REGNUM, &global_pointer);

      store_unsigned_integer (buf, 8, byte_order, faddr);
      store_unsigned_integer (buf + 8, 8, byte_order, global_pointer);

      write_memory (fdesc, buf, 16);
    }

  return fdesc; 
}

/* Use the following routine when printing out function pointers
   so the user can see the function address rather than just the
   function descriptor.  */
static CORE_ADDR
ia64_convert_from_func_ptr_addr (struct gdbarch *gdbarch, CORE_ADDR addr,
				 struct target_ops *targ)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct obj_section *s;
  gdb_byte buf[8];

  s = find_pc_section (addr);

  /* check if ADDR points to a function descriptor.  */
  if (s && strcmp (s->the_bfd_section->name, ".opd") == 0)
    return read_memory_unsigned_integer (addr, 8, byte_order);

  /* Normally, functions live inside a section that is executable.
     So, if ADDR points to a non-executable section, then treat it
     as a function descriptor and return the target address iff
     the target address itself points to a section that is executable.
     Check first the memory of the whole length of 8 bytes is readable.  */
  if (s && (s->the_bfd_section->flags & SEC_CODE) == 0
      && target_read_memory (addr, buf, 8) == 0)
    {
      CORE_ADDR pc = extract_unsigned_integer (buf, 8, byte_order);
      struct obj_section *pc_section = find_pc_section (pc);

      if (pc_section && (pc_section->the_bfd_section->flags & SEC_CODE))
        return pc;
    }

  /* There are also descriptors embedded in vtables.  */
  if (s)
    {
      struct bound_minimal_symbol minsym;

      minsym = lookup_minimal_symbol_by_pc (addr);

      if (minsym.minsym && is_vtable_name (SYMBOL_LINKAGE_NAME (minsym.minsym)))
	return read_memory_unsigned_integer (addr, 8, byte_order);
    }

  return addr;
}

static CORE_ADDR
ia64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  return sp & ~0xfLL;
}

/* The default "allocate_new_rse_frame" ia64_infcall_ops routine for ia64.  */

static void
ia64_allocate_new_rse_frame (struct regcache *regcache, ULONGEST bsp, int sof)
{
  ULONGEST cfm, pfs, new_bsp;

  regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

  new_bsp = rse_address_add (bsp, sof);
  regcache_cooked_write_unsigned (regcache, IA64_BSP_REGNUM, new_bsp);

  regcache_cooked_read_unsigned (regcache, IA64_PFS_REGNUM, &pfs);
  pfs &= 0xc000000000000000LL;
  pfs |= (cfm & 0xffffffffffffLL);
  regcache_cooked_write_unsigned (regcache, IA64_PFS_REGNUM, pfs);

  cfm &= 0xc000000000000000LL;
  cfm |= sof;
  regcache_cooked_write_unsigned (regcache, IA64_CFM_REGNUM, cfm);
}

/* The default "store_argument_in_slot" ia64_infcall_ops routine for
   ia64.  */

static void
ia64_store_argument_in_slot (struct regcache *regcache, CORE_ADDR bsp,
			     int slotnum, gdb_byte *buf)
{
  write_memory (rse_address_add (bsp, slotnum), buf, 8);
}

/* The default "set_function_addr" ia64_infcall_ops routine for ia64.  */

static void
ia64_set_function_addr (struct regcache *regcache, CORE_ADDR func_addr)
{
  /* Nothing needed.  */
}

static CORE_ADDR
ia64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
		      struct regcache *regcache, CORE_ADDR bp_addr,
		      int nargs, struct value **args, CORE_ADDR sp,
		      int struct_return, CORE_ADDR struct_addr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int argno;
  struct value *arg;
  struct type *type;
  int len, argoffset;
  int nslots, rseslots, memslots, slotnum, nfuncargs;
  int floatreg;
  ULONGEST bsp;
  CORE_ADDR funcdescaddr, pc, global_pointer;
  CORE_ADDR func_addr = find_function_addr (function, NULL);

  nslots = 0;
  nfuncargs = 0;
  /* Count the number of slots needed for the arguments.  */
  for (argno = 0; argno < nargs; argno++)
    {
      arg = args[argno];
      type = check_typedef (value_type (arg));
      len = TYPE_LENGTH (type);

      if ((nslots & 1) && slot_alignment_is_next_even (type))
	nslots++;

      if (TYPE_CODE (type) == TYPE_CODE_FUNC)
	nfuncargs++;

      nslots += (len + 7) / 8;
    }

  /* Divvy up the slots between the RSE and the memory stack.  */
  rseslots = (nslots > 8) ? 8 : nslots;
  memslots = nslots - rseslots;

  /* Allocate a new RSE frame.  */
  regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
  tdep->infcall_ops.allocate_new_rse_frame (regcache, bsp, rseslots);
  
  /* We will attempt to find function descriptors in the .opd segment,
     but if we can't we'll construct them ourselves.  That being the
     case, we'll need to reserve space on the stack for them.  */
  funcdescaddr = sp - nfuncargs * 16;
  funcdescaddr &= ~0xfLL;

  /* Adjust the stack pointer to it's new value.  The calling conventions
     require us to have 16 bytes of scratch, plus whatever space is
     necessary for the memory slots and our function descriptors.  */
  sp = sp - 16 - (memslots + nfuncargs) * 8;
  sp &= ~0xfLL;				/* Maintain 16 byte alignment.  */

  /* Place the arguments where they belong.  The arguments will be
     either placed in the RSE backing store or on the memory stack.
     In addition, floating point arguments or HFAs are placed in
     floating point registers.  */
  slotnum = 0;
  floatreg = IA64_FR8_REGNUM;
  for (argno = 0; argno < nargs; argno++)
    {
      struct type *float_elt_type;

      arg = args[argno];
      type = check_typedef (value_type (arg));
      len = TYPE_LENGTH (type);

      /* Special handling for function parameters.  */
      if (len == 8 
          && TYPE_CODE (type) == TYPE_CODE_PTR 
	  && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC)
	{
	  gdb_byte val_buf[8];
	  ULONGEST faddr = extract_unsigned_integer (value_contents (arg),
						     8, byte_order);
	  store_unsigned_integer (val_buf, 8, byte_order,
				  find_func_descr (regcache, faddr,
						   &funcdescaddr));
	  if (slotnum < rseslots)
	    tdep->infcall_ops.store_argument_in_slot (regcache, bsp,
						      slotnum, val_buf);
	  else
	    write_memory (sp + 16 + 8 * (slotnum - rseslots), val_buf, 8);
	  slotnum++;
	  continue;
	}

      /* Normal slots.  */

      /* Skip odd slot if necessary...  */
      if ((slotnum & 1) && slot_alignment_is_next_even (type))
	slotnum++;

      argoffset = 0;
      while (len > 0)
	{
	  gdb_byte val_buf[8];

	  memset (val_buf, 0, 8);
          if (!ia64_struct_type_p (type) && len < 8)
            {
              /* Integral types are LSB-aligned, so we have to be careful
                 to insert the argument on the correct side of the buffer.
                 This is why we use store_unsigned_integer.  */
              store_unsigned_integer
                (val_buf, 8, byte_order,
                 extract_unsigned_integer (value_contents (arg), len,
					   byte_order));
            }
          else
            {
              /* This is either an 8bit integral type, or an aggregate.
                 For 8bit integral type, there is no problem, we just
                 copy the value over.

                 For aggregates, the only potentially tricky portion
                 is to write the last one if it is less than 8 bytes.
                 In this case, the data is Byte0-aligned.  Happy news,
                 this means that we don't need to differentiate the
                 handling of 8byte blocks and less-than-8bytes blocks.  */
              memcpy (val_buf, value_contents (arg) + argoffset,
                      (len > 8) ? 8 : len);
            }

	  if (slotnum < rseslots)
	    tdep->infcall_ops.store_argument_in_slot (regcache, bsp,
						      slotnum, val_buf);
	  else
	    write_memory (sp + 16 + 8 * (slotnum - rseslots), val_buf, 8);

	  argoffset += 8;
	  len -= 8;
	  slotnum++;
	}

      /* Handle floating point types (including HFAs).  */
      float_elt_type = is_float_or_hfa_type (type);
      if (float_elt_type != NULL)
	{
	  argoffset = 0;
	  len = TYPE_LENGTH (type);
	  while (len > 0 && floatreg < IA64_FR16_REGNUM)
	    {
	      char to[MAX_REGISTER_SIZE];
	      convert_typed_floating (value_contents (arg) + argoffset,
				      float_elt_type, to,
				      ia64_ext_type (gdbarch));
	      regcache_cooked_write (regcache, floatreg, (void *)to);
	      floatreg++;
	      argoffset += TYPE_LENGTH (float_elt_type);
	      len -= TYPE_LENGTH (float_elt_type);
	    }
	}
    }

  /* Store the struct return value in r8 if necessary.  */
  if (struct_return)
    {
      regcache_cooked_write_unsigned (regcache, IA64_GR8_REGNUM,
				      (ULONGEST) struct_addr);
    }

  global_pointer = ia64_find_global_pointer (gdbarch, func_addr);

  if (global_pointer != 0)
    regcache_cooked_write_unsigned (regcache, IA64_GR1_REGNUM, global_pointer);

  /* The following is not necessary on HP-UX, because we're using
     a dummy code sequence pushed on the stack to make the call, and
     this sequence doesn't need b0 to be set in order for our dummy
     breakpoint to be hit.  Nonetheless, this doesn't interfere, and
     it's needed for other OSes, so we do this unconditionaly.  */
  regcache_cooked_write_unsigned (regcache, IA64_BR0_REGNUM, bp_addr);

  regcache_cooked_write_unsigned (regcache, sp_regnum, sp);

  tdep->infcall_ops.set_function_addr (regcache, func_addr);

  return sp;
}

static const struct ia64_infcall_ops ia64_infcall_ops =
{
  ia64_allocate_new_rse_frame,
  ia64_store_argument_in_slot,
  ia64_set_function_addr
};

static struct frame_id
ia64_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[8];
  CORE_ADDR sp, bsp;

  get_frame_register (this_frame, sp_regnum, buf);
  sp = extract_unsigned_integer (buf, 8, byte_order);

  get_frame_register (this_frame, IA64_BSP_REGNUM, buf);
  bsp = extract_unsigned_integer (buf, 8, byte_order);

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"dummy frame id: code %s, stack %s, special %s\n",
			paddress (gdbarch, get_frame_pc (this_frame)),
			paddress (gdbarch, sp), paddress (gdbarch, bsp));

  return frame_id_build_special (sp, get_frame_pc (this_frame), bsp);
}

static CORE_ADDR 
ia64_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[8];
  CORE_ADDR ip, psr, pc;

  frame_unwind_register (next_frame, IA64_IP_REGNUM, buf);
  ip = extract_unsigned_integer (buf, 8, byte_order);
  frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
  psr = extract_unsigned_integer (buf, 8, byte_order);
 
  pc = (ip & ~0xf) | ((psr >> 41) & 3);
  return pc;
}

static int
ia64_print_insn (bfd_vma memaddr, struct disassemble_info *info)
{
  info->bytes_per_line = SLOT_MULTIPLIER;
  return print_insn_ia64 (memaddr, info);
}

/* The default "size_of_register_frame" gdbarch_tdep routine for ia64.  */

static int
ia64_size_of_register_frame (struct frame_info *this_frame, ULONGEST cfm)
{
  return (cfm & 0x7f);
}

static struct gdbarch *
ia64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  tdep = xzalloc (sizeof (struct gdbarch_tdep));
  gdbarch = gdbarch_alloc (&info, tdep);

  tdep->size_of_register_frame = ia64_size_of_register_frame;

  /* According to the ia64 specs, instructions that store long double
     floats in memory use a long-double format different than that
     used in the floating registers.  The memory format matches the
     x86 extended float format which is 80 bits.  An OS may choose to
     use this format (e.g. GNU/Linux) or choose to use a different
     format for storing long doubles (e.g. HPUX).  In the latter case,
     the setting of the format may be moved/overridden in an
     OS-specific tdep file.  */
  set_gdbarch_long_double_format (gdbarch, floatformats_i387_ext);

  set_gdbarch_short_bit (gdbarch, 16);
  set_gdbarch_int_bit (gdbarch, 32);
  set_gdbarch_long_bit (gdbarch, 64);
  set_gdbarch_long_long_bit (gdbarch, 64);
  set_gdbarch_float_bit (gdbarch, 32);
  set_gdbarch_double_bit (gdbarch, 64);
  set_gdbarch_long_double_bit (gdbarch, 128);
  set_gdbarch_ptr_bit (gdbarch, 64);

  set_gdbarch_num_regs (gdbarch, NUM_IA64_RAW_REGS);
  set_gdbarch_num_pseudo_regs (gdbarch,
			       LAST_PSEUDO_REGNUM - FIRST_PSEUDO_REGNUM);
  set_gdbarch_sp_regnum (gdbarch, sp_regnum);
  set_gdbarch_fp0_regnum (gdbarch, IA64_FR0_REGNUM);

  set_gdbarch_register_name (gdbarch, ia64_register_name);
  set_gdbarch_register_type (gdbarch, ia64_register_type);

  set_gdbarch_pseudo_register_read (gdbarch, ia64_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, ia64_pseudo_register_write);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, ia64_dwarf_reg_to_regnum);
  set_gdbarch_register_reggroup_p (gdbarch, ia64_register_reggroup_p);
  set_gdbarch_convert_register_p (gdbarch, ia64_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, ia64_register_to_value);
  set_gdbarch_value_to_register (gdbarch, ia64_value_to_register);

  set_gdbarch_skip_prologue (gdbarch, ia64_skip_prologue);

  set_gdbarch_return_value (gdbarch, ia64_return_value);

  set_gdbarch_memory_insert_breakpoint (gdbarch,
					ia64_memory_insert_breakpoint);
  set_gdbarch_memory_remove_breakpoint (gdbarch,
					ia64_memory_remove_breakpoint);
  set_gdbarch_breakpoint_from_pc (gdbarch, ia64_breakpoint_from_pc);
  set_gdbarch_read_pc (gdbarch, ia64_read_pc);
  set_gdbarch_write_pc (gdbarch, ia64_write_pc);

  /* Settings for calling functions in the inferior.  */
  set_gdbarch_push_dummy_call (gdbarch, ia64_push_dummy_call);
  tdep->infcall_ops = ia64_infcall_ops;
  set_gdbarch_frame_align (gdbarch, ia64_frame_align);
  set_gdbarch_dummy_id (gdbarch, ia64_dummy_id);

  set_gdbarch_unwind_pc (gdbarch, ia64_unwind_pc);
#ifdef HAVE_LIBUNWIND_IA64_H
  frame_unwind_append_unwinder (gdbarch,
                                &ia64_libunwind_sigtramp_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &ia64_libunwind_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &ia64_sigtramp_frame_unwind);
  libunwind_frame_set_descr (gdbarch, &ia64_libunwind_descr);
#else
  frame_unwind_append_unwinder (gdbarch, &ia64_sigtramp_frame_unwind);
#endif
  frame_unwind_append_unwinder (gdbarch, &ia64_frame_unwind);
  frame_base_set_default (gdbarch, &ia64_frame_base);

  /* Settings that should be unnecessary.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  set_gdbarch_print_insn (gdbarch, ia64_print_insn);
  set_gdbarch_convert_from_func_ptr_addr (gdbarch,
					  ia64_convert_from_func_ptr_addr);

  /* The virtual table contains 16-byte descriptors, not pointers to
     descriptors.  */
  set_gdbarch_vtable_function_descriptors (gdbarch, 1);

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  return gdbarch;
}

extern initialize_file_ftype _initialize_ia64_tdep; /* -Wmissing-prototypes */

void
_initialize_ia64_tdep (void)
{
  gdbarch_register (bfd_arch_ia64, ia64_gdbarch_init, NULL);
}
@


1.225
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d2561 1
a2561 1
  get_frame_register (this_frame, regnum, (char *) val);
d2642 1
a2642 1
  regcache_cooked_read (regcache, regnum, (char *) val);
d2667 1
a2667 1
    return target_write_memory (addr, (char *) val, sizeof (unw_word_t));
d2669 1
a2669 1
    return target_read_memory (addr, (char *) val, sizeof (unw_word_t));
@


1.224
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d373 1
a373 1
extract_bit_field (const char *bundle, int from, int len)
d409 1
a409 1
replace_bit_field (char *bundle, long long val, int from, int len)
d459 1
a459 1
slotN_contents (char *bundle, int slotnum)
d467 1
a467 1
replace_slotN_contents (char *bundle, long long instr, int slotnum)
d514 1
a514 1
  char bundle[BUNDLE_LEN];
d1168 1
a1168 1
	      char nat_buf[8];
d1227 1
a1227 1
  char in[MAX_REGISTER_SIZE];
d1245 1
a1245 1
  char out[MAX_REGISTER_SIZE];
d3231 1
a3231 1
      char from[MAX_REGISTER_SIZE];
d3296 1
a3296 1
      char to[MAX_REGISTER_SIZE];
d3786 1
a3786 1
	  char val_buf[8];
d3810 1
a3810 1
	  char val_buf[8];
@


1.223
log
@Use gdb_byte for bytes from the program being debugged.

gdb_byte should be used for bytes from the program being debugged.  We
have many places using char or unsigned char instead all over the
existing ports, and more ends up added over time due to copy/paste as
new code is based on old code.

I've greped the tree for "char buf[", and fixed all I found.

Tested by building with --enable-targets=all.

2013-03-01  Pedro Alves  <palves@@redhat.com>

	Use gdb_byte for bytes from the program being debugged.

	* arm-tdep.c (arm_store_return_value, arm_get_longjmp_target):
	Change type of local 'buf' to gdb_byte.
	* avr-tdep.c (avr_frame_prev_register, avr_push_dummy_call): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* cris-tdep.c (cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache): Likewise.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp)
	(frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Likewise.
	* frv-tdep.c (frv_pseudo_register_write, frv_analyze_prologue): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_find_global_pointer)
	(hppa32_hpux_search_dummy_call_sequence)
	(hppa_hpux_supply_save_state): Likewise.
	* hppa-linux-tdep.c (insns_match_pattern)
	(hppa_linux_find_global_pointer): Likewise.
	* hppa-tdep.c (hppa_in_function_epilogue_p)
	(skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Likewise.
	* i386fbsd-tdep.c (i386fbsd_supply_uthread)
	(i386fbsd_collect_uthread): Likewise.
	* ia64-hpux-tdep.c (ia64_hpux_push_dummy_code): Likewise.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Likewise.
	* ia64-tdep.c (examine_prologue, ia64_frame_cache)
	(ia64_frame_prev_register, ia64_sigtramp_frame_cache)
	(ia64_sigtramp_frame_prev_register, ia64_access_reg)
	(ia64_access_rse_reg, ia64_libunwind_frame_this_id)
	(ia64_libunwind_frame_prev_register)
	(ia64_libunwind_sigtramp_frame_this_id)
	(ia64_find_global_pointer_from_dynamic_section)
	(find_extant_func_descr, find_func_descr, ia64_dummy_id)
	(ia64_unwind_pc): Likewise.
	* iq2000-tdep.c (iq2000_store_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call)
	(m68hc11_extract_return_value): Likewise.
	* m68klinux-nat.c (fetch_register, store_register): Likewise.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_cr32_write)
	(mep_get_insn, mep_push_dummy_call): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips_linux_in_dynsym_stub): Likewise.
	* mn10300-tdep.c (mep_pseudo_cr32_write): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* regcache.c (dump_endian_bytes): Change type of parameter 'buf'
	to gdb_byte.
	* remote-mips.c (mips_set_register): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* score-tdep.c (score7_fetch_inst): Change type of parameter
	'memblock' and local 'buf' to gdb_byte.
	(score7_malloc_and_get_memblock): Change return type to gdb_byte.
	Change type of local 'buf' to gdb_byte.  Adjust.
	(score7_adjust_memblock_ptr): Change type of parameter 'memblock'
	to gdb_byte**.
	(score7_analyze_prologue): Change type of 'memblock' and
	'memblock_ptr' locals to gdb_byte*.
	* sh64-tdep.c (sh64_extract_return_value)
	(sh64_store_return_value): Change type of local 'buf' to gdb_byte.
	* solib-darwin.c (darwin_current_sos, darwin_read_exec_load_addr):
	* solib-pa64.c (pa64_solib_create_inferior_hook)
	(pa64_open_symbol_file_object): Remove local 'buf'.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start)
	(som_open_symbol_file_object): Likewise.
	* solib-spu.c (spu_current_sos): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	* spu-multiarch.c (parse_spufs_run, spu_fetch_registers)
	(spu_store_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	* tic6x-tdep.c (tic6x_get_longjmp_target): Likewise.
	* xstormy16-tdep.c (xstormy16_store_return_value)
	(xstormy16_push_dummy_call, xstormy16_resolve_jmp_table_entry)
	(xstormy16_find_jmp_table_entry): Likewise.
@
text
@d3654 1
a3654 1
      struct minimal_symbol *minsym;
d3658 1
a3658 1
      if (minsym && is_vtable_name (SYMBOL_LINKAGE_NAME (minsym)))
@


1.222
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1383 1
a1383 1
  char buf[8];
d1517 1
a1517 1
	      char buf[MAX_REGISTER_SIZE];
d1853 1
a1853 1
  char buf[8];
d1921 1
a1921 1
  char buf[8];
d2241 1
a2241 1
  char buf[8];
d2291 1
a2291 1
  char buf[MAX_REGISTER_SIZE];
d2497 1
a2497 1
  char buf[MAX_REGISTER_SIZE];
d2577 1
a2577 1
  char buf[MAX_REGISTER_SIZE];
d2932 1
a2932 1
  char buf[8];
d2984 1
a2984 1
	  unsigned char buf[MAX_REGISTER_SIZE];
d3063 1
a3063 1
  char buf[8];
d3483 1
a3483 1
	      char buf[8];
d3566 1
a3566 1
	      char buf[8];
d3599 1
a3599 1
      char buf[16];
d3906 1
a3906 1
  char buf[8];
d3928 1
a3928 1
  char buf[8];
@


1.221
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d3 1
a3 1
   Copyright (C) 1999-2012 Free Software Foundation, Inc.
@


1.220
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a1043 1
      CORE_ADDR reg;
a1061 1
      CORE_ADDR reg;
a1098 1
      CORE_ADDR reg;
d1854 1
a1854 2
  CORE_ADDR cfm, sof, sol, bsp, psr;
  int i;
a2240 1
  CORE_ADDR addr;
a2241 1
  int i;
@


1.219
log
@gdb/
	* libunwind-frame.c: Rename to ...
	* ia64-libunwind-tdep.c: ... here.
	* libunwind-frame.h: Rename to ...
	* ia64-libunwind-tdep.h: ... here.
	* Makefile.in (HFILES_NO_SRCDIR): Rename libunwind-frame.h to
	ia64-libunwind-tdep.h.
	(ALLDEPFILES): Rename libunwind-frame.c to ia64-libunwind-tdep.c.
	* README (--with-libunwind): Rename to ...
	(--with-libunwind-ia64): ... here, note it is ia64 specific now.
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac: New option --with-libunwind-ia64, make the
	AS_HELP_STRING ia64 specific.  Deprecate option --with-libunwind.
	Remove AC_DEFINE for HAVE_LIBUNWIND.
	* ia64-libunwind-tdep.c: Make the file top comment ia64 specific.
	Rename libunwind-frame.h #include to ia64-libunwind-tdep.h.
	Rename libunwind-frame in the general comment.
	* ia64-libunwind-tdep.h: Make the file top comment ia64 specific.
	Rename symbol LIBUNWIND_FRAME_H to IA64_TDEP_LIBUNWIND_FRAME_H.
	Move forward declarations inside #ifndef.  Rename libunwind-frame in
	the general comment.
	* ia64-tdep.c: Rename libunwind-frame.h #include to
	ia64-libunwind-tdep.h.
	(ia64_gdb2uw_regnum, ia64_uw2gdb_regnum, ia64_is_fpreg)
	(ia64_libunwind_descr): Rename libunwind-frame to
	ia64-libunwind-tdep in these function comments.
	* ia64-tdep.h: Rename libunwind-frame.h #include to
	ia64-libunwind-tdep.h.
	* ia64-vms-tdep.c (ia64_vms_libunwind_descr): Rename libunwind-frame to
	ia64-libunwind-tdep in that data comment.
@
text
@d3343 1
a3343 1
ia64_return_value (struct gdbarch *gdbarch, struct type *func_type,
@


1.218
log
@2012-03-05  Tristan Gingold  <gingold@@adacore.com>

	* ia64-tdep.h: Include libunwind-frame.h and libunwind-ia64.h.
	(ia64_unw_accessors, ia64_unw_rse_accessors)
	(ia64_libunwind_descr): Declare.
	* ia64-vms-tdep.c: New file.
	* ia64-tdep.c (ia64_unw_accessors, ia64_unw_rse_accessors)
	(ia64_libunwind_descr): Make them public.
	* configure.tgt: Add ia64-*-*vms*.
	* Makefile.in (ALL_64_TARGET_OBS): Add ia64-vms-tdep.o
	(ALLDEPFILES): Add ia64-vms-tdep.c
@
text
@d45 1
a45 1
#include "libunwind-frame.h"
d2420 2
a2421 2
/* Gdb libunwind-frame callback function to convert from an ia64 gdb register 
   number to a libunwind register number.  */
d2453 2
a2454 2
/* Gdb libunwind-frame callback function to convert from a libunwind register 
   number to a ia64 gdb register number.  */
d2484 2
a2485 2
/* Gdb libunwind-frame callback function to reveal if register is a float 
   register or not.  */
d3179 2
a3180 2
/* Set of ia64 gdb libunwind-frame callbacks and data for generic
   libunwind-frame code to use.  */
@


1.217
log
@2012-02-21  Tristan Gingold  <gingold@@adacore.com>
	    Pedro Alves  <palves@@redhat.com>

	* ia64-tdep.c: Do not include libunwind-ia64.h.
	* libunwind-frame.h: Remove #ifdef HAVE_LIBUNWIND_H guard.
	Include libunwind-ia64.h instead of libunwind.h.
	* configure.ac (--with-libunwind, $enable_libunwind): Don't check
	for libunwind.h existence.
	* configure, config.in: Regenerate.
@
text
@d3151 1
a3151 1
static unw_accessors_t ia64_unw_accessors =
d3167 1
a3167 1
static unw_accessors_t ia64_unw_rse_accessors =
d3181 1
a3181 1
static struct libunwind_descr ia64_libunwind_descr =
@


1.216
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a45 1
#include "libunwind-ia64.h"
@


1.215
log
@2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	* ia64-tdep.c (ia64_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* m32r-tdep.c (m32r_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* microblaze-linux-tdep.c
	(microblaze_linux_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Use
	target_write_raw_memory.
@
text
@d3 1
a3 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011 Free Software Foundation, Inc.
@


1.214
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d814 1
a814 1
  val = target_write_memory (addr, bundle_mem, BUNDLE_LEN);
@


1.214.4.1
log
@2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	* ia64-tdep.c (ia64_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* m32r-tdep.c (m32r_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* microblaze-linux-tdep.c
	(microblaze_linux_memory_remove_breakpoint): Use
	target_write_raw_memory.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Use
	target_write_raw_memory.
@
text
@d814 1
a814 1
  val = target_write_raw_memory (addr, bundle_mem, BUNDLE_LEN);
@


1.214.4.2
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 1999-2012 Free Software Foundation, Inc.
@


1.213
log
@	gdb/
	* dwarf2loc.c (read_pieced_value): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	(write_pieced_value): Handle get_frame_register_bytes returning
	that the register piece is unavailable/optimized out when doing a
	read-modify write of a bitfield.
	* findvar.c (value_from_register): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	* frame.c (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.  Throw error on bad debug info.  Use
	frame_register instead of frame_register_read, to fill in the new
	arguments.
	* frame.h (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.
	* valops.c: (value_assign): Adjust, and handle
	get_frame_register_bytes failing.
	* spu-tdep.c: Include exceptions.h.
	(spu_software_single_step): Adjust, and handle
	get_frame_register_bytes failing.
	(spu_get_longjmp_target): Ditto.
	* gdbarch.sh (register_to_value): Change to return int.  New
	parameters `optimizedp' and `unavailablep'.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_register_to_value): Adjust to new
	gdbarch_register_to_value interface.
	* i387-tdep.c (i387_register_to_value): Ditto.
	* i387-tdep.h (i387_register_to_value): Ditto.
	* alpha-tdep.c (alpha_register_to_value): Ditto.
	* ia64-tdep.c (ia64_register_to_value): Ditto.
	* m68k-tdep.c (m68k_register_to_value): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* rs6000-tdep.c (rs6000_register_to_value): Ditto.
@
text
@d2178 1
d2370 1
d3056 1
d3145 1
@


1.212
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d1226 1
a1226 1
static void
d1228 2
a1229 1
                         struct type *valtype, gdb_byte *out)
d1233 7
a1239 1
  frame_register_read (frame, regnum, in);
d1241 2
@


1.211
log
@[ia64-hpux] inferior function call support

We have two stacks to deal with on ia64, when making a function call.
The first is the usual stack frame, and the second is the register
stack frame.  On ia64-linux, the register frame is setup by adjusting
the BSP register.  Unfortunately for us, the HP-UX kernel does not allow
the debugger to change the value of the BSP.

To work around that limitation, the method I am using here is to push
some assembly code on the stack. This assembly code contains, among
other things, a call to the alloc insn, which sets up our frame for us.
An extensive comment in ia64-hpux-tdep.c explains the entire procedure.

Despite this approach, most of the code in ia64-tdep.c which sets up
the function call is still applicable - and only a few things need
to be done differently:  For instance, instead of changing the BSP,
we do nothing.  We store the parameters at a different location, etc.
So this patch also adjusts the inf-call code in ia64-tdep.c to make it
a little more extensible: I create a new ia64_infcall_ops structure
which allows an ABI to define how the few things that need to be
differentiated.

Another element that turned out to be necessary but is more of a detail
is that the computation of the linkage pointer needs to be handled
specially for symbols inside shared libraries.  This is especially
visible when calling malloc, which happens everytime memory needs to
be allocated in inferior memory...  The special treatment included
again the necessity to use some routines only available on the host.
So another target object TARGET_OBJECT_HPUX_SOLIB_GOT was created for
that purpose.

gdb/ChangeLog:

        * ia64-tdep.h (struct regcache): Forward declare.
        (struct ia64_infcall_ops): New struct type.
        (struct gdbarch_tdep): New fields "find_global_pointer_from_solib"
        and "infcall_ops".
        * ia64-tdep.c (ia64_find_global_pointer_from_dynamic_section):
        Renames ia64_find_global_pointer.
        (ia64_find_global_pointer, ia64_allocate_new_rse_frame)
        (ia64_store_argument_in_slot, ia64_set_function_addr: New function.
        (ia64_push_dummy_call): Adjust to use the new tdep ia64_infocall_ops
        methods.
        (ia64_infcall_ops): New static global constant.
        (ia64_gdbarch_init): Set tdep->infcall_ops.
        * ia64-hpux-nat.c (ia64_hpux_xfer_solib_got): New function.
        (ia64_hpux_xfer_partial): Add TARGET_OBJECT_HPUX_SOLIB_GOT handing.
        * ia64-hpux-tdep.c: Include "regcache.h", "gdbcore.h" and "inferior.h".
        (ia64_hpux_dummy_code): New static global constant.
        (ia64_hpux_push_dummy_code, ia64_hpux_allocate_new_rse_frame)
        (ia64_hpux_store_argument_in_slot, ia64_hpux_set_function_addr)
        (ia64_hpux_dummy_id, ia64_hpux_find_global_pointer_from_solib):
        New function.
        (ia64_hpux_infcall_ops): New static global constant.
        (ia64_hpux_init_abi): Install gdbarch and tdep methods needed
        for inferior function calls to work properly on ia64-hpux.
@
text
@d936 1
a936 1
static void
d941 1
d956 1
d960 11
a970 3
	  regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
	  regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);
	  
d992 3
a994 1
      regcache_cooked_read_unsigned (regcache, IA64_UNAT_REGNUM, &unat);
d1005 6
a1010 2
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);
d1047 6
a1052 2
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);
d1066 6
a1071 2
      regcache_cooked_read_unsigned (regcache, IA64_PR_REGNUM, &pr);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);
d1089 2
d1161 2
a1162 1
	      regcache_cooked_read_unsigned (regcache, IA64_RNAT_REGNUM,
@


1.210
log
@[ia64-hpux] unwinding bsp value from system call

This fixes unwinding from a thread that is stopped inside a system call.
This can be seen when switching to a thread that is stopped doing a
pthread_cond_wait, for instance...

The comments inside the code should explain what is happening in our
case (the HP-UX exception in the case of system calls): Under certain
circumstances (program stopped inside syscall), the offset to apply to
the current BSP in order to compute the previous BSP is not the usual
CFM & 0x7f.

We parts in this patch:

  1. Figuring out that we are stopped inside a syscal: This requires
     a TT_LWP_RUREGS ttrace call, which is not directly possible from
     ia64-tdep.c.  So use defined a new TARGET_OBJECT_HPUX_UREGS object
     to request it from the -nat side.

  2. Add a gdbarch_tdep method that allows us to change the default
     behavior on ia64-hpux, permitting us to have a different "size of
     register frame" in that one particular case.

gdb/ChangeLog:

        * target.h (enum target_object): Add TARGET_OBJECT_HPUX_UREGS.
        * ia64-tdep.h (struct frame_info): forward declaration.
        (struct gdbarch_tdep): Add field size_of_register_frame.
        * ia64-tdep.c (ia64_access_reg): Use tdep->size_of_register_frame
        to determine the size of the register frame.
        (ia64_size_of_register_frame): New function.
        (ia64_gdbarch_init): Set tdep->size_of_register_frame.
        * ia64-hpux-tdep.c: Include "target.h" and "frame.h".
        (IA64_HPUX_UREG_REASON): New macro.
        (ia64_hpux_stopped_in_syscall, ia64_hpux_size_of_register_frame):
        New functions.
        (ia64_hpux_init_abi): Set tdep->size_of_register_frame.
        * ia64-hpux-nat.c (ia64_hpux_xfer_uregs): New function.
        (ia64_hpux_xfer_partial): Add handling of TARGET_OBJECT_HPUX_UREGS
        objects.
@
text
@d3423 2
a3424 1
ia64_find_global_pointer (struct gdbarch *gdbarch, CORE_ADDR faddr)
d3482 18
d3639 40
d3685 1
d3693 1
a3693 1
  ULONGEST bsp, cfm, pfs, new_bsp;
a3719 2
  regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

d3721 1
a3721 11
  new_bsp = rse_address_add (bsp, rseslots);
  regcache_cooked_write_unsigned (regcache, IA64_BSP_REGNUM, new_bsp);

  regcache_cooked_read_unsigned (regcache, IA64_PFS_REGNUM, &pfs);
  pfs &= 0xc000000000000000LL;
  pfs |= (cfm & 0xffffffffffffLL);
  regcache_cooked_write_unsigned (regcache, IA64_PFS_REGNUM, pfs);

  cfm &= 0xc000000000000000LL;
  cfm |= rseslots;
  regcache_cooked_write_unsigned (regcache, IA64_CFM_REGNUM, cfm);
d3761 2
a3762 1
	    write_memory (rse_address_add (bsp, slotnum), val_buf, 8);
d3807 2
a3808 1
	    write_memory (rse_address_add (bsp, slotnum), val_buf, 8);
d3849 5
d3858 2
d3863 7
d3989 1
@


1.209
log
@[ia64] small integral parameters and return values

This patch fixes a small problem on ia64-hpux when calling functions
whose parameter are small integral values (less than 8 bytes).  In
that case, the parameter value was stored on the wrong side of the
register.  Same problem for return values.

With this patch, the results for gdb.base/callfuncs.exp improve from

        # of expected passes            41
        # of unexpected failures        78

To:

        # of expected passes            95
        # of unexpected failures        24

gdb/ChangeLog:

        * ia64-tdep.c (ia64_struct_type_p): New function.
        (ia64_extract_return_value): Handle integral values that are
        less than 8 bytes long.
        (ia64_push_dummy_call): Likewise.
@
text
@d2455 1
a2455 1
  
d2493 1
a2493 1
	sof = (cfm & 0x7f);
d3851 8
d3873 2
@


1.208
log
@[ia64] Add a big-endian version of the ia64-ext floatformat

ia64-tdep.c defines a floatformats_ia64_ext that should contain
both the little-endian and the big-endian version of the float
format used in the ia64 registers (an 82bit float format).
Right now, both entries point to the same little-endian definition.

A big-endian definition is now necessary for the ia64-hpux port.

gdb/ChangeLog:

        * ia64-tdep.c (floatformat_ia64_ext_little): Renames
        floatformat_ia64_ext.
        (floatformat_ia64_ext_big): New static const.
        (floatformats_ia64_ext): Set first entry to &floatformat_ia64_ext_big.
@
text
@d3180 9
d3213 15
d3732 24
a3755 2
	  memcpy (val_buf, value_contents (arg) + argoffset,
		  (len > 8) ? 8 : len);
@


1.207
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* h8300-tdep.c: Comment cleanup, mostly periods and spaces.
	* hppa-hpux-tdep.c: Ditto.
	* hppa-linux-nat.c: Ditto.
	* hppa-linux-tdep.c: Ditto.
	* hppanbsd-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* hppa-tdep.h: Ditto.
	* hpux-thread.c: Ditto.
	* i386-cygwin-tdep.c: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386gnu-nat.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* i386-linux-tdep.c: Ditto.
	* i386-nat.c: Ditto.
	* i386-nat.h: Ditto.
	* i386nbsd-tdep.c: Ditto.
	* i386-sol2-nat.c: Ditto.
	* i386-stub.c: Ditto.
	* i386-tdep.c: Ditto.
	* i386-tdep.h: Ditto.
	* i387-tdep.c: Ditto.
	* ia64-linux-nat.c: Ditto.
	* ia64-linux-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* infcall.c: Ditto.
	* infcall.h: Ditto.
	* infcmd.c: Ditto.
	* inferior.c: Ditto.
	* inferior.h: Ditto.
	* infloop.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* interps.c: Ditto.
	* interps.h: Ditto.
	* iq2000-tdep.c: Ditto.
	* irix5-nat.c: Ditto.
	* jit.c: Ditto.
	* jit.h: Ditto.
	* jv-exp.y: Ditto.
	* jv-lang.c: Ditto.
	* jv-lang.h: Ditto.
	* jv-typeprint.c: Ditto.
	* jv-valprint.c: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* linespec.c: Ditto.
	* linux-fork.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-thread-db.c: Ditto.
	* lm32-tdep.c: Ditto.
@
text
@d293 1
a293 1
static const struct floatformat floatformat_ia64_ext =
d296 7
a302 1
  floatformat_intbit_yes, "floatformat_ia64_ext", floatformat_valid, NULL
d307 2
a308 2
  &floatformat_ia64_ext,
  &floatformat_ia64_ext
@


1.206
log
@run copyright.sh for 2011.
@
text
@d105 1
a105 1
   never want to also display the raw bytes the way objdump does. */
d109 1
a109 1
/* Length in bytes of an instruction bundle */
d135 6
a140 3
/* NOTE: we treat the register stack registers r32-r127 as pseudo-registers because
   they may not be accessible via the ptrace register get/set interfaces.  */
enum pseudo_regs { FIRST_PSEUDO_REGNUM = NUM_IA64_RAW_REGS, VBOF_REGNUM = IA64_NAT127_REGNUM + 1, V32_REGNUM, 
d142 2
a143 1
		   VP0_REGNUM, VP16_REGNUM = VP0_REGNUM + 16, VP63_REGNUM = VP0_REGNUM + 63, LAST_PSEUDO_REGNUM };
d266 4
a269 3
  int   sof;		/* Size of frame  (decoded from cfm value) */
  int	sol;		/* Size of locals (decoded from cfm value) */
  int	sor;		/* Number of rotating registers. (decoded from cfm value) */
d274 1
a274 1
     intermingled with the prologue. */
d277 1
a277 1
     or -1 if it has not been determined yet. */
d280 1
a280 1
			   as the frame pointer. */
d402 1
a402 1
/* Replace the specified bits in an instruction bundle */
d452 1
a452 1
   and instruction bundle */
d460 1
a460 1
/* Store an instruction in an instruction bundle */
d692 2
a693 1
  memcpy (bp_tgt->shadow_contents, bundle + shadow_slotnum, bp_tgt->shadow_len);
d821 2
a822 1
ia64_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
d911 1
a911 1
   the address ADDR. NSLOTS may be positive or negative. */
d939 2
a940 2
      /* First try and use the libunwind special reg accessor, otherwise fallback to
	 standard logic.  */
d945 4
a948 3
	  /* The fallback position is to assume that r32-r127 are found sequentially
	     in memory starting at $bof.  This isn't always true, but without libunwind,
	     this is the best we can do.  */
d956 2
a957 1
	     subtract the size of frame from it to get start of register frame.  */
d1007 2
a1008 1
	    regcache_cooked_read_unsigned (regcache, IA64_RNAT_REGNUM, &nat_collection);
d1021 1
a1021 1
         It can be calculated as the bsp - sof (sizeof frame). */
d1046 1
a1046 1
	     marker for this frame. */
d1049 1
a1049 1
	  /* Adjust the register number to account for register rotation. */
d1080 1
a1080 1
	  write_memory (reg_addr, (void *)buf, 8);
d1087 2
a1088 1
      unatN_val = extract_unsigned_integer (buf, register_size (gdbarch, regnum),
d1113 2
a1114 1
      natN_val = extract_unsigned_integer (buf, register_size (gdbarch, regnum),
d1129 2
a1130 1
	      regcache_cooked_read_unsigned (regcache, IA64_RNAT_REGNUM, &nat_collection);
d1135 2
a1136 1
	      regcache_cooked_write_unsigned (regcache, IA64_RNAT_REGNUM, nat_collection);
d1165 1
a1165 1
	     marker for this frame. */
d1168 1
a1168 1
	  /* Adjust the register number to account for register rotation. */
d1374 2
a1375 2
	 addresses of various registers such as the return address.  
	 We will instead treat the frame as frameless. */
d1401 1
a1401 1
	      /* mov r2, r12 - beginning of leaf routine */
d1418 1
a1418 1
     where preserved registers were spilled. */
d1427 1
a1427 1
	  /* Exit loop upon hitting a non-nop branch instruction. */ 
d1487 1
a1487 1
		 The address to start spilling at is loaded into r2. 
d1491 1
a1491 1
	      /* Hmm... whether or not this will work will depend on
d1510 1
a1510 1
	      /* mov rN, rM where rM is an input register */
d1542 1
a1542 1
		spill_addr = 0;		/* last one; must be done */
d1559 1
a1559 1
		 r3 (or whatever) and watch for a store of this register... */
d1592 1
a1592 1
		 Record that fact and move on... */
d1595 1
a1595 1
		  /* Track UNAT register */
d1601 1
a1601 1
		  /* Track PR register */
d1609 1
a1609 1
		spill_addr = 0;		/* must be done spilling */
d1614 1
a1614 1
	      /* Allow up to one store of each input register. */
d1635 2
a1636 2
	     Advance over stores of input registers. One store per input
	     register is permitted. */
d1661 1
a1661 1
	     one store per register is permitted */
d1684 1
a1684 1
		 register if appropriate. */
d1690 1
a1690 1
		spill_addr = 0;		/* Done spilling */
d1709 1
a1709 1
	 frame marker. */
d1735 1
a1735 1
      /* For the previous argument registers we require the previous bof.  
d1771 2
a1772 1
		cache->saved_regs[IA64_GR32_REGNUM + ((i + (sor - rrb_gr)) % sor)] 
d1802 2
a1803 1
  /* Call examine_prologue with - as third argument since we don't have a next frame pointer to send.  */
d1870 2
a1871 1
			"regular frame id: code %s, stack %s, special %s, this_frame %s\n",
d2155 31
a2185 20
      cache->saved_regs[IA64_VRAP_REGNUM] = 
	tdep->sigcontext_register_address (gdbarch, cache->base, IA64_IP_REGNUM);
      cache->saved_regs[IA64_CFM_REGNUM] = 
	tdep->sigcontext_register_address (gdbarch, cache->base, IA64_CFM_REGNUM);
      cache->saved_regs[IA64_PSR_REGNUM] = 
	tdep->sigcontext_register_address (gdbarch, cache->base, IA64_PSR_REGNUM);
      cache->saved_regs[IA64_BSP_REGNUM] = 
	tdep->sigcontext_register_address (gdbarch, cache->base, IA64_BSP_REGNUM);
      cache->saved_regs[IA64_RNAT_REGNUM] = 
	tdep->sigcontext_register_address (gdbarch, cache->base, IA64_RNAT_REGNUM);
      cache->saved_regs[IA64_CCV_REGNUM] = 
	tdep->sigcontext_register_address (gdbarch, cache->base, IA64_CCV_REGNUM);
      cache->saved_regs[IA64_UNAT_REGNUM] = 
	tdep->sigcontext_register_address (gdbarch, cache->base, IA64_UNAT_REGNUM);
      cache->saved_regs[IA64_FPSR_REGNUM] = 
	tdep->sigcontext_register_address (gdbarch, cache->base, IA64_FPSR_REGNUM);
      cache->saved_regs[IA64_PFS_REGNUM] = 
	tdep->sigcontext_register_address (gdbarch, cache->base, IA64_PFS_REGNUM);
      cache->saved_regs[IA64_LC_REGNUM] = 
	tdep->sigcontext_register_address (gdbarch, cache->base, IA64_LC_REGNUM);
d2244 2
a2245 1
			"sigtramp frame id: code %s, stack %s, special %s, this_frame %s\n",
d2479 4
a2482 3
	/* Libunwind expects to see the beginning of the current register
	   frame so we must account for the fact that ptrace() will return a value
	   for bsp that points *after* the current register frame.  */
d2516 2
a2517 2
ia64_access_fpreg (unw_addr_space_t as, unw_regnum_t uw_regnum, unw_fpreg_t *val, 
		   int write, void *arg)
d2532 2
a2533 2
ia64_access_rse_reg (unw_addr_space_t as, unw_regnum_t uw_regnum, unw_word_t *val, 
		     int write, void *arg)
d2559 4
a2562 3
	/* Libunwind expects to see the beginning of the current register
	   frame so we must account for the fact that ptrace() will return a value
	   for bsp that points *after* the current register frame.  */
d2743 1
a2743 1
     DSO gate page in which case the unwind table is another segment. 
d2915 2
a2916 1
			"libunwind frame id: code %s, stack %s, special %s, this_frame %s\n",
d2982 1
a2982 1
         beginning of the current frame so we should just add sof to it. */
d3048 2
a3049 1
			"libunwind sigtramp frame id: code %s, stack %s, special %s, this_frame %s\n",
d3121 2
a3122 2
   how to read r32 - r127.  Though usually they are found sequentially in memory
   starting from $bof, this is not always true.  */
d3135 2
a3136 1
/* Set of ia64 gdb libunwind-frame callbacks and data for generic libunwind-frame code to use.  */
d3193 1
a3193 1
				  (char *)valbuf + offset, float_elt_type);	  
d3437 1
a3437 1
		  /* The payoff... */
d3702 2
a3703 1
	  memcpy (val_buf, value_contents (arg) + argoffset, (len > 8) ? 8 : len);
d3724 3
a3726 2
	      convert_typed_floating (value_contents (arg) + argoffset, float_elt_type,
				      to, ia64_ext_type (gdbarch));
d3738 2
a3739 1
      regcache_cooked_write_unsigned (regcache, IA64_GR8_REGNUM, (ULONGEST)struct_addr);
d3833 2
a3834 1
  set_gdbarch_num_pseudo_regs (gdbarch, LAST_PSEUDO_REGNUM - FIRST_PSEUDO_REGNUM);
d3853 4
a3856 2
  set_gdbarch_memory_insert_breakpoint (gdbarch, ia64_memory_insert_breakpoint);
  set_gdbarch_memory_remove_breakpoint (gdbarch, ia64_memory_remove_breakpoint);
d3883 2
a3884 1
  set_gdbarch_convert_from_func_ptr_addr (gdbarch, ia64_convert_from_func_ptr_addr);
@


1.205
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d4 1
a4 1
   2009, 2010 Free Software Foundation, Inc.
@


1.204
log
@gdb/
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): New variable buf.
	Check first the descriptor memory is readable.
@
text
@d4 1
a4 1
   2009 Free Software Foundation, Inc.
@


1.203
log
@        * ia64-tdep.c: Update the comments on how we insert/remove
        breakpoints for L-X instructions.
        (ia64_memory_insert_breakpoint, ia64_memory_remove_breakpoint):
        Update the comments inside these functions.
@
text
@d3513 1
d3524 4
a3527 2
     the target address itself points to a section that is executable.  */
  if (s && (s->the_bfd_section->flags & SEC_CODE) == 0)
d3529 1
a3529 1
      CORE_ADDR pc = read_memory_unsigned_integer (addr, 8, byte_order);
@


1.202
log
@        Fix ia64 breakpoints in the L-X slot.
        * ia64-tdep.c (ia64_memory_insert_breakpoint): Extend the comment.
        New variable shadow_slotnum, use it appropriately instead of slotnum.
        Move shadow_len initialization before SLOTNUM adjustment, cover now the
        whole remaining bundle.  Error now on breakpoints requested for the
        slot 2 of L-X bundles.  Better sanity check the requested slot 1 of L-X
        bundles.
        (ia64_memory_remove_breakpoint): New variable shadow_slotnum, use it
        appropriately instead of slotnum.  Warn now on breakpoints requested
        for the slot 2 of L-X bundles.  Better sanity check the requested slot
        1 of L-X bundles.  Update the assertio check of PLACED_SIZE.
        (ia64_breakpoint_from_pc): New variable shadow_slotnum, use it
        appropriately instead of slotnum.  Move *lenptr initialization before
        SLOTNUM adjustment, cover now the whole remaining bundle.  Error now
        on breakpoints requested for the slot 2 of L-X bundles.  Better sanity
        check the requested slot 1 of L-X bundles.  Simplify the returned
        expression.
@
text
@d589 17
a613 4
   0xABCDE1 L-X  0xABCDE1 L-X     0xF                     <0xA...0xF> <0x1..0xF>
     L is always in slot 1 and X is always in slot 2, while the address is
     using slot 1 the breakpoint instruction must be placed
     to the slot 2 (requiring to shadow that last byte at 0xF).
d615 4
a618 1
   
d662 2
a663 1
  /* Cover always the last byte of the bundle for the L-X slot case.  */
a665 2
  /* Check for L type instruction in slot 1, if present then bump up the slot
     number to the slot 2.  */
d669 4
d678 3
a754 2
  /* Check for L type instruction in slot 1, if present then bump up the slot
     number to the slot 2.  */
d758 5
d764 2
a765 2
      warning (_("Cannot remove breakpoint at address %s "
		 "from non-existing slot X, memory has changed underneath"),
d772 3
d799 2
a800 2
  /* In BUNDLE_MEM be careful to modify only the bits belonging to SLOTNUM and
     never any other possibly also stored in SHADOW_CONTENTS.  */
@


1.201
log
@        * ia64-tdep.c (ia64_memory_insert_breakpoint): Check the slotnum
        and the type of instruction before deciding which slot to save
        in the breakpoint shadown contents.
@
text
@d595 6
a600 2
   0xABCDE0      0xABCDE0         0xE                     <0x0...0x5> <0x0..0xD>
   0xABCDE1      0xABCDE1         0xE                     <0x5...0xA> <0x1..0xE>
d618 1
a618 1
  int slotnum = (int) (addr & 0x0f) / SLOT_MULTIPLIER;
d642 7
d652 10
a661 5
  if (slotnum == 1 && template_encoding_table[template][slotnum] == L)
    slotnum = 2;

  /* Slot number 2 may skip at most 2 bytes at the beginning.  */
  bp_tgt->shadow_len = BUNDLE_LEN - 2;
d665 1
a665 1
  memcpy (bp_tgt->shadow_contents, bundle + slotnum, bp_tgt->shadow_len);
d695 1
a695 1
  val = target_write_memory (addr + slotnum, bundle + slotnum,
d708 1
a708 1
  int slotnum = (addr & 0x0f) / SLOT_MULTIPLIER;
d729 4
d736 14
a749 2
  if (slotnum == 1 && template_encoding_table[template][slotnum] == L)
    slotnum = 2;
d751 1
a751 1
  gdb_assert (bp_tgt->placed_size == BUNDLE_LEN - 2);
d767 2
a768 1
  memcpy (bundle_saved + slotnum, bp_tgt->shadow_contents, bp_tgt->shadow_len);
d791 1
a791 1
  int slotnum = (int) (*pcptr & 0x0f) / SLOT_MULTIPLIER;
d813 7
d823 10
a832 2
  if (slotnum == 1 && template_encoding_table[template][slotnum] == L)
    slotnum = 2;
d841 1
a841 4
  *lenptr = BUNDLE_LEN - 2;

  /* SLOTNUM is possibly already locally modified - use caller's *PCPTR.  */
  return bundle + (*pcptr & 0x0f);
@


1.200
log
@        gdb/
        * frame.c (get_frame_id): Default to outer_frame_id if the this_id
        method does not supply an ID.  Assert that the result is not
        null_frame_id.
        (outer_frame_id): New.
        (frame_id_p): Accept outer_frame_id.
        (frame_id_eq): Allow outer_frame_id to be equal to itself.
        (frame_find_by_id): Revert previous local workarounds.
        (get_prev_frame_1): Adjust end-of-stack check to test outer_frame_id.
        * frame.h (null_frame_id, frame_id_p): Update comments.
        (outer_frame_id): Declare.
        * infrun.c (handle_inferior_event): Do not treat all steps from the
        outermost frame as subroutine calls.

        * libunwind-frame.c (libunwind_frame_this_id): Do not clear THIS_ID.
        * hppa-tdep.c (hppa_stub_frame_this_id): Likewise.
        * ia64-tdep.c (ia64_frame_this_id): Likewise.
        (ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id):
        Use outer_frame_id instead of null_frame_id.
        * amd64obsd-tdep.c (amd64obsd_trapframe_cache): Use outer_frame_id.
        * i386obsd-tdep.c (i386obsd_trapframe_cache): Likewise.
        * inline-frame.c (inline_frame_this_id): Refuse outer_frame_id.
        * thread.c (restore_selected_frame): Update comment and remove
        frame_id_p check.

        gdb/doc/
        * gdbint.texinfo (Unwinding the Frame ID): Reference outer_frame_id.
@
text
@d638 6
a665 6
  /* Check for L type instruction in slot 1, if present then bump up the slot
     number to the slot 2.  */
  template = extract_bit_field (bundle, 0, 5);
  if (slotnum == 1 && template_encoding_table[template][slotnum] == L)
    slotnum = 2;

@


1.200.2.1
log
@        * ia64-tdep.c (ia64_memory_insert_breakpoint): Check the slotnum
        and the type of instruction before deciding which slot to save
        in the breakpoint shadown contents.
@
text
@a637 6
  /* Check for L type instruction in slot 1, if present then bump up the slot
     number to the slot 2.  */
  template = extract_bit_field (bundle, 0, 5);
  if (slotnum == 1 && template_encoding_table[template][slotnum] == L)
    slotnum = 2;

d660 6
@


1.200.2.2
log
@        Fix ia64 breakpoints in the L-X slot.
        * ia64-tdep.c (ia64_memory_insert_breakpoint): Extend the comment.
        New variable shadow_slotnum, use it appropriately instead of slotnum.
        Move shadow_len initialization before SLOTNUM adjustment, cover now the
        whole remaining bundle.  Error now on breakpoints requested for the
        slot 2 of L-X bundles.  Better sanity check the requested slot 1 of L-X
        bundles.
        (ia64_memory_remove_breakpoint): New variable shadow_slotnum, use it
        appropriately instead of slotnum.  Warn now on breakpoints requested
        for the slot 2 of L-X bundles.  Better sanity check the requested slot
        1 of L-X bundles.  Update the assertio check of PLACED_SIZE.
        (ia64_breakpoint_from_pc): New variable shadow_slotnum, use it
        appropriately instead of slotnum.  Move *lenptr initialization before
        SLOTNUM adjustment, cover now the whole remaining bundle.  Error now
        on breakpoints requested for the slot 2 of L-X bundles.  Better sanity
        check the requested slot 1 of L-X bundles.  Simplify the returned
        expression.
@
text
@d595 2
a596 6
   0xABCDE0      0xABCDE0         0x10                    <0x0...0x5> <0x0..0xF>
   0xABCDE1      0xABCDE1         0xF                     <0x5...0xA> <0x1..0xF>
   0xABCDE1 L-X  0xABCDE1 L-X     0xF                     <0xA...0xF> <0x1..0xF>
     L is always in slot 1 and X is always in slot 2, while the address is
     using slot 1 the breakpoint instruction must be placed
     to the slot 2 (requiring to shadow tha last byte 0xF).
d614 1
a614 1
  int slotnum = (int) (addr & 0x0f) / SLOT_MULTIPLIER, shadow_slotnum;
a637 7
  /* SHADOW_SLOTNUM saves the original slot number as expected by the caller
     for addressing the SHADOW_CONTENTS placement.  */
  shadow_slotnum = slotnum;

  /* Cover always the last byte of the bundle for the L-X slot case.  */
  bp_tgt->shadow_len = BUNDLE_LEN - shadow_slotnum;

d641 5
a645 10
  if (template_encoding_table[template][slotnum] == X)
    {
      gdb_assert (slotnum == 2);
      error (_("Can't insert breakpoint for non-existing slot X"));
    }
  if (template_encoding_table[template][slotnum] == L)
    {
      gdb_assert (slotnum == 1);
      slotnum = 2;
    }
d649 1
a649 1
  memcpy (bp_tgt->shadow_contents, bundle + shadow_slotnum, bp_tgt->shadow_len);
d679 1
a679 1
  val = target_write_memory (addr + shadow_slotnum, bundle + shadow_slotnum,
d692 1
a692 1
  int slotnum = (addr & 0x0f) / SLOT_MULTIPLIER, shadow_slotnum;
a712 4
  /* SHADOW_SLOTNUM saves the original slot number as expected by the caller
     for addressing the SHADOW_CONTENTS placement.  */
  shadow_slotnum = slotnum;

d716 2
a717 14
  if (template_encoding_table[template][slotnum] == X)
    {
      gdb_assert (slotnum == 2);
      warning (_("Cannot remove breakpoint at address %s "
		 "from non-existing slot X, memory has changed underneath"),
	       paddress (gdbarch, bp_tgt->placed_address));
      do_cleanups (cleanup);
      return -1;
    }
  if (template_encoding_table[template][slotnum] == L)
    {
      gdb_assert (slotnum == 1);
      slotnum = 2;
    }
d719 1
a719 1
  gdb_assert (bp_tgt->placed_size == BUNDLE_LEN - shadow_slotnum);
d735 1
a735 2
  memcpy (bundle_saved + shadow_slotnum, bp_tgt->shadow_contents,
	  bp_tgt->shadow_len);
d758 1
a758 1
  int slotnum = (int) (*pcptr & 0x0f) / SLOT_MULTIPLIER, shadow_slotnum;
a779 7
  /* SHADOW_SLOTNUM saves the original slot number as expected by the caller
     for addressing the SHADOW_CONTENTS placement.  */
  shadow_slotnum = slotnum;

  /* Cover always the last byte of the bundle for the L-X slot case.  */
  *lenptr = BUNDLE_LEN - shadow_slotnum;

d783 2
a784 10
  if (template_encoding_table[template][slotnum] == X)
    {
      gdb_assert (slotnum == 2);
      error (_("Can't insert breakpoint for non-existing slot X"));
    }
  if (template_encoding_table[template][slotnum] == L)
    {
      gdb_assert (slotnum == 1);
      slotnum = 2;
    }
d793 4
a796 1
  return bundle + shadow_slotnum;
@


1.200.2.3
log
@        * ia64-tdep.c: Update the comments on how we insert/remove
        breakpoints for L-X instructions.
        (ia64_memory_insert_breakpoint, ia64_memory_remove_breakpoint):
        Update the comments inside these functions.
@
text
@a588 17
   There is one special case where we need to be extra careful:
   L-X instructions, which are instructions that occupy 2 slots
   (The L part is always in slot 1, and the X part is always in
   slot 2).  We must refuse to insert breakpoints for an address
   that points at slot 2 of a bundle where an L-X instruction is
   present, since there is logically no instruction at that address.
   However, to make things more interesting, the opcode of L-X
   instructions is located in slot 2.  This means that, to insert
   a breakpoint at an address that points to slot 1, we actually
   need to write the breakpoint in slot 2!  Slot 1 is actually
   the extended operand, so writing the breakpoint there would not
   have the desired effect.  Another side-effect of this issue
   is that we need to make sure that the shadow contents buffer
   does save byte 15 of our instruction bundle (this is the tail
   end of slot 2, which wouldn't be saved if we were to insert
   the breakpoint in slot 1).
   
d597 4
d602 1
a602 4

   L-X instructions are treated a little specially, as explained above:
   0xABCDE1      0xABCDE1         0xF                     <0xA...0xF> <0x1..0xF>

d646 1
a646 2
  /* Always cover the last byte of the bundle in case we are inserting
     a breakpoint on an L-X instruction.  */
d649 2
a653 4
      /* X unit types can only be used in slot 2, and are actually
	 part of a 2-slot L-X instruction.  We cannot break at this
	 address, as this is the second half of an instruction that
	 lives in slot 1 of that bundle.  */
a658 3
      /* L unit types can only be used in slot 1.  But the associated
	 opcode for that instruction is in slot 2, so bump the slot number
	 accordingly.  */
d733 2
a737 5
      /* X unit types can only be used in slot 2, and are actually
	 part of a 2-slot L-X instruction.  We refuse to insert
	 breakpoints at this address, so there should be no reason
	 for us attempting to remove one there, except if the program's
	 code somehow got modified in memory.  */
d739 2
a740 2
      warning (_("Cannot remove breakpoint at address %s from non-existing "
		 "X-type slot, memory has changed underneath"),
a746 3
      /* L unit types can only be used in slot 1.  But the breakpoint
	 was actually saved using slot 2, so update the slot number
	 accordingly.  */
d771 2
a772 2
  /* In BUNDLE_MEM, be careful to modify only the bits belonging to SLOTNUM
     and not any of the other ones that are stored in SHADOW_CONTENTS.  */
@


1.200.2.4
log
@gdb/
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): New variable buf.
	Check first the descriptor memory is readable.
@
text
@a3512 1
  gdb_byte buf[8];
d3523 2
a3524 4
     the target address itself points to a section that is executable.
     Check first the memory of the whole length of 8 bytes is readable.  */
  if (s && (s->the_bfd_section->flags & SEC_CODE) == 0
      && target_read_memory (addr, buf, 8) == 0)
d3526 1
a3526 1
      CORE_ADDR pc = extract_unsigned_integer (buf, 8, byte_order);
@


1.199
log
@gdb/
	* ia64-tdep.c (ia64_memory_remove_breakpoint): Call do_cleanups
	before a return.
@
text
@d1777 1
a1777 3
  if (cache->base == 0)
    (*this_id) = null_frame_id;
  else
d2791 1
a2791 1
  struct frame_id id;
a2794 1

d2796 1
a2796 1
  if (frame_id_eq (id, null_frame_id))
d2798 1
a2798 1
      (*this_id) = null_frame_id;
d2923 1
a2923 1
  struct frame_id id;
d2927 1
a2927 1
  if (frame_id_eq (id, null_frame_id))
d2929 1
a2929 1
      (*this_id) = null_frame_id;
@


1.198
log
@gdb/
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Return immediately if any of memory
	reads fail.  Do not combine the VAL values.
@
text
@d728 1
@


1.197
log
@gdb/
	Fix ia64 shadowing of breakpoints in multiple slots of a single bundle.
	* ia64-tdep.c (ia64_memory_insert_breakpoint): New call
	of make_show_memory_breakpoints_cleanup with parameter 0.  Move the
	reading of SHADOW_CONTENTS to this memory state point of code.  Update
	comment for the memory re-read.

gdb/testsuite/
	* gdb.base/breakpoint-shadow.exp (Second breakpoint placed): Initialize
	$bpt2address.
	(Second breakpoint address is valid on ia64)
	(Third breakpoint on ia64 in the Second breakpoint's bundle): New.
@
text
@d632 5
d653 6
a658 1
  val |= target_read_memory (addr, bundle, BUNDLE_LEN);
d679 2
a680 3
  if (val == 0)
    val = target_write_memory (addr + slotnum, bundle + slotnum,
			       bp_tgt->shadow_len);
d707 5
d740 1
a740 2
  if (val == 0)
    val = target_write_memory (addr, bundle_mem, BUNDLE_LEN);
@


1.196
log
@gdb/
	Fix ia64 start crash when GDB built with -lmcheck.
	* ia64-tdep.c (ia64_gdbarch_init): Allocate TDEP as cleared.  Remove
	specific clearing of TDEP SIGCONTEXT_REGISTER_ADDRESS and
	PC_IN_SIGTRAMP.
@
text
@d625 3
a627 3
  /* Disable the automatic memory restoration from breakpoints while
     we read our instruction bundle.  Otherwise, the general restoration
     mechanism kicks in and we would possibly remove parts of the adjacent
d630 1
a630 1
  cleanup = make_show_memory_breakpoints_cleanup (1);
d633 17
a655 7
  /* Slot number 2 may skip at most 2 bytes at the beginning.  */
  bp_tgt->placed_size = bp_tgt->shadow_len = BUNDLE_LEN - 2;

  /* Store the whole bundle, except for the initial skipped bytes by the slot
     number interpreted as bytes offset in PLACED_ADDRESS.  */
  memcpy (bp_tgt->shadow_contents, bundle + slotnum, bp_tgt->shadow_len);

d667 2
@


1.195
log
@2009-07-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ia64-tdep.c (ia64_access_reg): Correct paddress.
@
text
@d3674 1
a3674 1
  tdep = xmalloc (sizeof (struct gdbarch_tdep));
a3676 3
  tdep->sigcontext_register_address = 0;
  tdep->pc_in_sigtramp = 0;

@


1.194
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d2383 1
a2383 1
			paddress (*val));
@


1.193
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d126 2
a127 1
static CORE_ADDR ia64_find_global_pointer (CORE_ADDR faddr);
d828 2
d855 3
a857 2
	      reg = read_memory_integer ((CORE_ADDR)reg_addr, 8);
	      store_unsigned_integer (buf, register_size (gdbarch, regnum), reg);
d860 2
a861 1
	    store_unsigned_integer (buf, register_size (gdbarch, regnum), 0);
d870 2
a871 1
      store_unsigned_integer (buf, register_size (gdbarch, regnum), unatN_val);
d901 1
a901 1
	    nat_collection = read_memory_integer (nat_addr, 8);
d906 2
a907 1
      store_unsigned_integer (buf, register_size (gdbarch, regnum), natN_val);
d922 2
a923 1
      store_unsigned_integer (buf, register_size (gdbarch, regnum), vbsp);
d945 2
a946 1
      store_unsigned_integer (buf, register_size (gdbarch, regnum), prN_val);
d956 2
d978 2
a979 1
      unatN_val = extract_unsigned_integer (buf, register_size (gdbarch, regnum)); 
d1003 2
a1004 1
      natN_val = extract_unsigned_integer (buf, register_size (gdbarch, regnum)); 
d1028 1
a1028 1
	      nat_collection = read_memory_integer (nat_addr, 8);
d1033 2
a1034 1
	      store_unsigned_integer (nat_buf, register_size (gdbarch, regnum), nat_collection);
d1059 2
a1060 1
      prN_val = extract_unsigned_integer (buf, register_size (gdbarch, regnum)); 
d1383 2
d1386 1
a1386 1
		  saved_sp = extract_unsigned_integer (buf, 8);
d1591 3
d1627 2
a1628 1
	  cfm = read_memory_integer (cache->saved_regs[IA64_CFM_REGNUM], 8);
d1633 1
a1633 1
	  cfm = extract_unsigned_integer (buf, 8);
d1698 2
d1712 1
a1712 1
  cache->saved_sp = extract_unsigned_integer (buf, 8);
d1718 1
a1718 1
  cache->bsp = extract_unsigned_integer (buf, 8);
d1721 1
a1721 1
  psr = extract_unsigned_integer (buf, 8);
d1724 1
a1724 1
  cfm = extract_unsigned_integer (buf, 8);
d1769 1
d1795 2
a1796 1
      prev_cfm = extract_unsigned_integer (value_contents_all (val), 8);
d1882 1
a1882 1
	  bsp = extract_unsigned_integer (buf, 8); 
d1886 1
a1886 1
	      nat_collection = extract_unsigned_integer (buf, 8);
d1889 1
a1889 1
	    nat_collection = read_memory_integer (nat_addr, 8);
d1905 1
a1905 1
          pc = extract_unsigned_integer (buf, 8);
d1910 1
a1910 1
	  pc = extract_unsigned_integer (buf, 8);
d1928 1
a1928 1
      psr = extract_unsigned_integer (buf, 8);
d1933 1
a1933 1
	  pc = extract_unsigned_integer (buf, 8);
d1938 1
a1938 1
	  pc = extract_unsigned_integer (buf, 8);
d1979 1
a1979 1
                                               8);
d1983 1
a1983 1
                                               8);
d2034 2
a2035 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));
d2042 1
a2042 1
	tdep->sigcontext_register_address (cache->base, IA64_IP_REGNUM);
d2044 1
a2044 1
	tdep->sigcontext_register_address (cache->base, IA64_CFM_REGNUM);
d2046 1
a2046 1
	tdep->sigcontext_register_address (cache->base, IA64_PSR_REGNUM);
d2048 1
a2048 1
	tdep->sigcontext_register_address (cache->base, IA64_BSP_REGNUM);
d2050 1
a2050 1
	tdep->sigcontext_register_address (cache->base, IA64_RNAT_REGNUM);
d2052 1
a2052 1
	tdep->sigcontext_register_address (cache->base, IA64_CCV_REGNUM);
d2054 1
a2054 1
	tdep->sigcontext_register_address (cache->base, IA64_UNAT_REGNUM);
d2056 1
a2056 1
	tdep->sigcontext_register_address (cache->base, IA64_FPSR_REGNUM);
d2058 1
a2058 1
	tdep->sigcontext_register_address (cache->base, IA64_PFS_REGNUM);
d2060 1
a2060 1
	tdep->sigcontext_register_address (cache->base, IA64_LC_REGNUM);
d2063 1
a2063 1
	  tdep->sigcontext_register_address (cache->base, regno);
d2066 1
a2066 1
	  tdep->sigcontext_register_address (cache->base, regno);
d2069 1
a2069 1
	  tdep->sigcontext_register_address (cache->base, regno);
d2076 2
d2091 1
a2091 1
  cache->base = extract_unsigned_integer (buf, 8) + 16;
d2094 1
a2094 1
  cache->bsp = extract_unsigned_integer (buf, 8);
d2097 1
a2097 1
  cache->cfm = extract_unsigned_integer (buf, 8);
d2133 1
d2150 1
a2150 1
	  pc = extract_unsigned_integer (buf, 8);
d2333 1
d2346 1
a2346 1
	ip = extract_unsigned_integer (buf, 8); 
d2348 1
a2348 1
	psr = extract_unsigned_integer (buf, 8); 
d2357 1
a2357 1
	bsp = extract_unsigned_integer (buf, 8);
d2359 1
a2359 1
	cfm = extract_unsigned_integer (buf, 8); 
d2368 1
a2368 1
	*val = extract_unsigned_integer (buf, 8);
d2374 1
a2374 1
	*val = extract_unsigned_integer (buf, 8); 
d2412 1
d2425 1
a2425 1
	ip = extract_unsigned_integer (buf, 8); 
d2427 1
a2427 1
	psr = extract_unsigned_integer (buf, 8); 
d2436 1
a2436 1
	bsp = extract_unsigned_integer (buf, 8);
d2438 1
a2438 1
	cfm = extract_unsigned_integer (buf, 8); 
d2447 1
a2447 1
	*val = extract_unsigned_integer (buf, 8);
d2453 1
a2453 1
	*val = extract_unsigned_integer (buf, 8); 
d2640 1
a2640 1
  dip->gp = ia64_find_global_pointer (ip);
d2766 1
d2782 1
a2782 1
  bsp = extract_unsigned_integer (buf, 8);
d2801 1
d2825 1
a2825 1
	  cfm = extract_unsigned_integer (buf, 8); 
d2855 2
a2856 1
      prev_bsp = extract_unsigned_integer (value_contents_all (val), 8);
d2859 2
a2860 1
      prev_cfm = extract_unsigned_integer (value_contents_all (cfm_val), 8);
d2897 1
d2913 1
a2913 1
  bsp = extract_unsigned_integer (buf, 8);
d2931 2
d2940 2
a2941 1
  prev_ip = extract_unsigned_integer (value_contents_all (prev_ip_val), 8);
d3263 1
a3263 1
ia64_find_global_pointer (CORE_ADDR faddr)
d3265 1
d3295 1
a3295 1
	      tag = extract_signed_integer (buf, sizeof (buf));
d3304 2
a3305 1
		  global_pointer = extract_unsigned_integer (buf, sizeof (buf));
d3325 1
a3325 1
find_extant_func_descr (CORE_ADDR faddr)
d3327 1
d3360 1
a3360 1
	      faddr2 = extract_signed_integer (buf, sizeof (buf));
d3379 2
d3383 1
a3383 1
  fdesc = find_extant_func_descr (faddr);
d3393 1
a3393 1
      global_pointer = ia64_find_global_pointer (faddr);
d3399 2
a3400 2
      store_unsigned_integer (buf, 8, faddr);
      store_unsigned_integer (buf + 8, 8, global_pointer);
d3415 1
d3422 1
a3422 1
    return read_memory_unsigned_integer (addr, 8);
d3430 1
a3430 1
      CORE_ADDR pc = read_memory_unsigned_integer (addr, 8);
d3445 1
a3445 1
	return read_memory_unsigned_integer (addr, 8);
d3463 1
d3544 3
a3546 2
	  ULONGEST faddr = extract_unsigned_integer (value_contents (arg), 8);
	  store_unsigned_integer (val_buf, 8,
d3606 1
a3606 1
  global_pointer = ia64_find_global_pointer (func_addr);
d3621 1
d3626 1
a3626 1
  sp = extract_unsigned_integer (buf, 8);
d3629 1
a3629 1
  bsp = extract_unsigned_integer (buf, 8);
d3643 1
d3648 1
a3648 1
  ip = extract_unsigned_integer (buf, 8);
d3650 1
a3650 1
  psr = extract_unsigned_integer (buf, 8);
@


1.192
log
@	* gdbtypes.h (TYPE_OBJFILE_OWNED, TYPE_OWNER): New macros.
	(TYPE_OBJFILE, TYPE_ALLOC, TYPE_ZALLOC): Reimplement.
	(alloc_type_arch): Add prototype.
	(alloc_type_copy): Likewise.
	(get_type_arch): Likewise.
	(arch_type): Likewise.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.

	* gdbtypes.c (alloc_type): No longer support NULL objfile.
	(init_type): Likewise.
	(alloc_type_arch): New function.
	(alloc_type_copy): New function.
	(get_type_arch): New function.

	(smash_type): Preserve type ownership information.
	(make_pointer_type, make_reference_type, make_function_type,
	smash_to_memberptr_type, smash_to_method_type): No longer
	preserve OBJFILE across smash_type calls.
	(make_pointer_type, make_reference_type, make_function_type,
	lookup_memberptr_type, lookup_methodptr_type, allocate_stub_method,
	create_range_type, create_array_type, create_set_type, copy_type):
	Use alloc_type_copy when allocating types.
	(check_typedef): Use alloc_type_arch.
	(copy_type_recursive): Likewise.  Preserve type ownership data
	after copying type.
	(recursive_dump_type): Dump type ownership data.
	(alloc_type_instance): Update type ownership check.
	(copy_type, copy_type_recursive): Likewise.

	(arch_type): New function.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(append_flags_type_flag): Move down.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.
	(append_composite_type_field_aligned,
	append_composite_type_field): Move down.

	* gdbarch.c (gdbtypes_post_init): Allocate all types
	using per-architecture routines.
	* ada-lang.c (ada_language_arch_info): Likewise.
	* f-lang.c (build_fortran_types): Likewise.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* scm-lang.c (build_scm_types): Likewise.

	* ada-lang.c (ada_type_of_array): Use alloc_type_copy.
	(packed_array_type): Likewise.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_variant_branch_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_fixed_range_type): Likewise.
	(empty_record): Use type instead of objfile argument.
	Use alloc_type_copy.
	(to_fixed_variant_branch_type): Update call to empty_record.
	* jv-lang.c (type_from_class): Use alloc_type_arch.

	* arm-tdep.c (arm_ext_type): Allocate per-architecture type.
	* i386-tdep.c (i386_eflags_type, i386_mxcsr_type, i387_ext_type,
	i386_mmx_type, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_ext_type): Likewise.
	* m32c-tdep.c (make_types): Likewise.
	* m68k-tdep.c (m68k_ps_type, m68881_ext_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* sparc-tdep.c (sparc_psr_type, sparc_fsr_type): Likewise.
	* sparc64-tdep.c (sparc64_pstate_type, sparc64_fsr_type,
	sparc64_fprs_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* target-descriptions.c (tdesc_gdb_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
@
text
@d653 1
a653 1
		    paddr_nz (bp_tgt->placed_address));
d700 1
a700 1
	       paddr_nz (bp_tgt->placed_address));
d1723 1
d1734 4
a1737 4
			"regular frame id: code 0x%s, stack 0x%s, special 0x%s, this_frame %s\n",
			paddr_nz (this_id->code_addr), 
			paddr_nz (this_id->stack_addr), 
			paddr_nz (cache->bsp),
d2082 1
d2091 4
a2094 4
			"sigtramp frame id: code 0x%s, stack 0x%s, special 0x%s, this_frame %s\n",
			paddr_nz (this_id->code_addr), 
			paddr_nz (this_id->stack_addr), 
			paddr_nz (cache->bsp),
d2303 1
d2350 1
a2350 1
			"  access_reg: from cache: %4s=0x%s\n",
d2353 1
a2353 1
			paddr_nz (*val));
d2381 1
d2428 1
a2428 1
			"  access_rse_reg: from cache: %4s=0x%s\n",
d2431 1
a2431 1
			paddr_nz (*val));
d2533 1
a2533 1
			"segbase=0x%s, length=%s, gp=0x%s\n",
d2535 1
a2535 1
			paddr_nz (di->u.ti.segbase), 
d2537 1
a2537 1
			paddr_nz (di->gp));
d2638 7
a2644 7
	fprintf_unfiltered (gdb_stdlog, "ia64_find_proc_info_x: 0x%s -> "
			    "(name=`%s',segbase=0x%s,start=0x%s,end=0x%s,gp=0x%s,"
			    "length=%s,data=0x%s)\n",
			    paddr_nz (ip), (char *)di.u.ti.name_ptr,
			    paddr_nz (di.u.ti.segbase), 
			    paddr_nz (di.start_ip), paddr_nz (di.end_ip),
			    paddr_nz (di.gp), 
d2646 1
a2646 1
			    paddr_nz ((CORE_ADDR)di.u.ti.table_data));
d2655 7
a2661 7
	fprintf_unfiltered (gdb_stdlog, "ia64_find_proc_info_x: 0x%s -> "
			    "(name=`%s',segbase=0x%s,start=0x%s,end=0x%s,gp=0x%s,"
			    "length=%s,data=0x%s)\n",
			    paddr_nz (ip), (char *)di.u.rti.name_ptr,
			    paddr_nz (di.u.rti.segbase), 
			    paddr_nz (di.start_ip), paddr_nz (di.end_ip),
			    paddr_nz (di.gp), 
d2663 1
a2663 1
			    paddr_nz (di.u.rti.table_data));
d2716 1
a2716 1
				    "at 0x%s (gp=0x%s)\n",
d2718 1
a2718 1
				    paddr_nz (addr), paddr_nz (di.gp));
d2734 1
d2756 4
a2759 3
			"libunwind frame id: code 0x%s, stack 0x%s, special 0x%s, this_frame %s\n",
			paddr_nz (id.code_addr), paddr_nz (id.stack_addr), 
			paddr_nz (bsp),
d2861 1
d2884 4
a2887 3
			"libunwind sigtramp frame id: code 0x%s, stack 0x%s, special 0x%s, this_frame %s\n",
			paddr_nz (id.code_addr), paddr_nz (id.stack_addr), 
			paddr_nz (bsp),
d3585 3
a3587 3
			"dummy frame id: code 0x%s, stack 0x%s, special 0x%s\n",
			paddr_nz (get_frame_pc (this_frame)),
			paddr_nz (sp), paddr_nz (bsp));
@


1.191
log
@	* gdbtypes.h (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(init_float_type, init_complex_type): Add prototypes.
	* gdbtypes.c (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(build_flt): Rename to ...
	(init_float_type): ... this.  Make global.
	(build_complex): Rename to ...
	(init_complex_type): ... this.  Make global.  Remove BIT argument.
	(gdbtypes_post_init): Update calls.

	* ada-lang.c (ada_language_arch_info): Use init_float_type.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* f-lang.c (build_fortran_types): Use init_float_type and
	init_complex_type.

	* target-descriptions.c (tdesc_gdb_type): Call init_float_type instead
	of using builtin_type_ieee_single, builtin_type_ieee_double, or
	builtin_type_arm_ext.

	* ia64-tdep.h (struct gdbarch_tdep): Add ia64_ext_type member.
	* ia64-tdep.c (builtin_type_ia64_ext): Remove.
	(_initialize_ia64_tdep): Do not initialize it.
	(floatformat_valid, floatformat_ia64_ext, floatformats_ia64_ext):
	Move up.
	(ia64_ext_type): New function.
	(ia64_register_reggroup_p, ia64_convert_register_p,
	ia64_register_to_value, ia64_value_to_register,
	ia64_extract_return_value, ia64_store_return_value): Use ia64_ext_type
	instead of builtin_type_ia64_ext.

	* i386-tdep.h (struct gdbarch_tdep): Add i387_ext_type member.
	(i387_ext_type): Add prototype.
	* i386-tdep.c (i387_ext_type): New function.
	(i386_extract_return_value, i386_store_return_value,
	i386_register_type): Use it instead of builtin_type_i387_ext.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* i387-tdep.c (print_i387_value, i387_register_to_value,
	i387_value_to_register): Likewise.
	(print_i387_value, print_i387_ext): Add GDBARCH argument.
	(print_i387_ext, i387_print_float_info): Pass to subroutines.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68881_ext_type member.
	* m68k-tdep.c (m68881_ext_type): New function.
	(m68k_register_type, m68k_convert_register_p): Use it instead
	of builtin_type_m68881_ext.

	* arm-tdep.h (struct gdbarch_tdep): Add arm_ext_type member.
	* arm-tdep.c (arm_ext_type): New function.
	(arm_register_type): Use it instead of builtin_type_arm_ext.

	* alpha-tdep.c (alpha_register_type): Use builtin types
	instead of builtin_type_ieee_double.

	* mips-tdep.c (mips_float_register_type, mips_double_register_type):
	Remove.
	(mips_register_type): Use builtin types instead of
	builtin_type_ieee_single and builtin_type_ieee_double.
	(mips_print_fp_register): Use builtin types instead of
	mips_float_register_type and mips_double_register_type.

	* hppa-tdep.c (hppa32_register_type, hppa64_register_type):
	Use builtin types instead of builtin_type_ieee_single and
	builtin_type_ieee_double.
@
text
@d306 1
a306 1
      = init_float_type (128, "builtin_type_ia64_ext",
@


1.190
log
@	ARI fix: remove "%p".
	* ia64-tdep.c (ia64_frame_this_id): Use host_address_to_string function.
	(ia64_sigtramp_frame_this_id): Ditto.
	(ia64_libunwind_frame_this_id): Ditto.
	(ia64_libunwind_sigtramp_frame_this_id): Ditto.
	* symmisc.c (maintenance_info_psymtabs): Ditto.
@
text
@a127 2
static struct type *builtin_type_ia64_ext;

d282 31
d345 1
a345 1
    return builtin_type_ia64_ext;
a357 18
static int
floatformat_valid (const struct floatformat *fmt, const void *from)
{
  return 1;
}

const struct floatformat floatformat_ia64_ext =
{
  floatformat_little, 82, 0, 1, 17, 65535, 0x1ffff, 18, 64,
  floatformat_intbit_yes, "floatformat_ia64_ext", floatformat_valid, NULL
};

const struct floatformat *floatformats_ia64_ext[2] =
{
  &floatformat_ia64_ext,
  &floatformat_ia64_ext
};

d1062 1
a1062 1
	  && type != builtin_type_ia64_ext);
d1069 1
d1072 1
a1072 1
  convert_typed_floating (in, builtin_type_ia64_ext, out, valtype);
d1079 1
d1081 1
a1081 1
  convert_typed_floating (in, valtype, out, builtin_type_ia64_ext);
d3001 1
d3015 1
a3015 1
	  convert_typed_floating (from, builtin_type_ia64_ext,
d3026 1
a3026 2
      int reglen = TYPE_LENGTH (register_type (get_regcache_arch (regcache),
					       IA64_GR8_REGNUM));
d3051 1
d3065 1
a3065 1
				  to, builtin_type_ia64_ext);
d3076 1
a3076 2
      int reglen = TYPE_LENGTH (register_type (get_regcache_arch (regcache),
					       IA64_GR8_REGNUM));
d3536 1
a3536 1
				      to, builtin_type_ia64_ext);
a3706 6
  /* Define the ia64 floating-point format to gdb.  */
  builtin_type_ia64_ext =
    init_type (TYPE_CODE_FLT, 128 / 8,
               0, "builtin_type_ia64_ext", NULL);
  TYPE_FLOATFORMAT (builtin_type_ia64_ext) = floatformats_ia64_ext;

@


1.189
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d1720 1
a1720 1
			"regular frame id: code 0x%s, stack 0x%s, special 0x%s, this_frame %p\n",
d1723 2
a1724 1
			paddr_nz (cache->bsp), this_frame);
d2076 1
a2076 1
			"sigtramp frame id: code 0x%s, stack 0x%s, special 0x%s, this_frame %p\n",
d2079 2
a2080 1
			paddr_nz (cache->bsp), this_frame);
d2738 1
a2738 1
			"libunwind frame id: code 0x%s, stack 0x%s, special 0x%s, this_frame %p\n",
d2740 2
a2741 1
			paddr_nz (bsp), this_frame);
d2864 1
a2864 1
			"libunwind sigtramp frame id: code 0x%s, stack 0x%s, special 0x%s, this_frame %p\n",
d2866 2
a2867 1
			paddr_nz (bsp), this_frame);
@


1.188
log
@        Updated copyright notices for most files.
@
text
@d283 1
a283 1
int
@


1.187
log
@	Fix compilation on 32-bit host configurations.
	* ia64-tdep.c (ia64_breakpoint_from_pc): Suffix a constant by `LL'.
@
text
@d3 2
a4 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
@


1.186
log
@	Fix automatic restoration of breakpoints memory for ia64.
	* ia64-tdep.c: New #if check on BREAKPOINT_MAX vs. BUNDLE_LEN.
	(ia64_memory_insert_breakpoint): New comment part for SHADOW_CONTENTS
	content.  Remove variable instr.  New variable cleanup.  Force
	automatic breakpoints restoration.  PLACED_SIZE and SHADOW_LEN are now
	set larger, to BUNDLE_LEN - 2.  Variable `bundle' type update.  Return
	error if even just final target_write_memory has failed.
	(ia64_memory_remove_breakpoint): Rename variables bundle to bundle_mem
	and instr to instr_saved.  New variables bundle_saved and
	instr_breakpoint.  Comment new reasons why we need to disable automatic
	restoration of breakpoints.  Assert PLACED_SIZE and SHADOW_LEN.  New
	check of the original memory content.  Return error if even just final
	target_write_memory has failed.
	(ia64_breakpoint_from_pc): Implement the emulation of permanent
	breakpoints compatible with current bp_loc_is_permanent.
	(template_encoding_table): Make it `const'.
	* breakpoint.c (bp_loc_is_permanent): Support unsupported software
	breakpoints.  New variables `cleanup' and `retval'.
	* monitor.c (monitor_insert_breakpoint): Remove unused variable `bp'.
@
text
@d752 1
a752 1
  instr_fetched &= 0x1003ffffc0;
@


1.185
log
@        * ia64-tdep.c: Remove commented out #define.
@
text
@d113 6
d451 1
a451 1
static enum instruction_type template_encoding_table[32][3] =
d554 39
a592 1
   using the pattern seen below. */
d601 1
a601 1
  char bundle[BUNDLE_LEN];
d603 1
a603 1
  long long instr;
d606 1
d613 6
d621 2
a622 2
  /* Check for L type instruction in 2nd slot, if present then
     bump up the slot number to the 3rd slot */
d624 5
a628 4
  if (slotnum == 1 && template_encoding_table[template][1] == L)
    {
      slotnum = 2;
    }
d630 13
a642 3
  instr = slotN_contents (bundle, slotnum);
  memcpy (bp_tgt->shadow_contents, &instr, sizeof (instr));
  bp_tgt->placed_size = bp_tgt->shadow_len = sizeof (instr);
d644 1
d646 2
a647 1
    target_write_memory (addr, bundle, BUNDLE_LEN);
d649 1
d658 1
a658 1
  char bundle[BUNDLE_LEN];
d660 1
a660 1
  long long instr;
d669 3
a671 2
     mechanism kicks in and ends up corrupting our bundle, because it
     is not aware of the concept of instruction bundles.  */
d673 1
a673 1
  val = target_read_memory (addr, bundle, BUNDLE_LEN);
d675 27
a701 10
  /* Check for L type instruction in 2nd slot, if present then
     bump up the slot number to the 3rd slot */
  template = extract_bit_field (bundle, 0, 5);
  if (slotnum == 1 && template_encoding_table[template][1] == L)
    {
      slotnum = 2;
    }

  memcpy (&instr, bp_tgt->shadow_contents, sizeof instr);
  replace_slotN_contents (bundle, instr, slotnum);
d703 1
a703 1
    target_write_memory (addr, bundle, BUNDLE_LEN);
d709 7
a715 3
/* We don't really want to use this, but remote.c needs to call it in order
   to figure out if Z-packets are supported or not.  Oh, well. */
const unsigned char *
d718 41
a758 7
  static unsigned char breakpoint[] =
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
  *lenptr = sizeof (breakpoint);
#if 0
  *pcptr &= ~0x0f;
#endif
  return breakpoint;
@


1.184
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@a549 3
#if 0
#define IA64_BREAKPOINT 0x00002000040LL
#endif
@


1.183
log
@	* defs.h (plongest,pulongest): Renamed from paddr_u,paddr_d.
	Change argument of pulongest from CORE_ADDR to ULONGEST.
	All callers updated.
	* utils.c (plongest): Renamed from paddr_d.
	(pulongest): Renamed from paddr_u, change arg type to ULONGEST.
	* remote-mips.c (send_srec): Use paddr_nz instead of paddr_u in
	`CORE_ADDR addr' arg of error message.
@
text
@d312 1
a312 1
    return builtin_type_long;
@


1.182
log
@(ia64_get_dyn_info_list): Use obj_section_addr.
@
text
@d2399 1
a2399 1
			paddr_u (di->u.ti.table_len), 
d2508 1
a2508 1
			    paddr_u (di.u.ti.table_len), 
d2525 1
a2525 1
			    paddr_u (di.u.rti.table_len), 
@


1.181
log
@	* arm-tdep.c (arm_pc_is_thumb): Use obj_section_addr.
	* hppa-hpux-tdep.c (hppa_hpux_find_dummy_bpaddr): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Use
	obj_section_addr and obj_section_endaddr.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* ia64-tdep.c (ia64_find_global_pointer): Likewise.
	(find_extant_func_descr): Likewise.
	* solib-frv.c (frv_relocate_main_executable): Use
	obj_section_addr.
	* xstormy16-tdep.c (xstormy16_find_jmp_table_entry): Use
	obj_section_addr and obj_section_endaddr.
@
text
@d2566 1
a2566 1
      ip = text_sec->addr;
@


1.180
log
@	* ia64-tdep.c (ia64_dummy_id): Use get_frame_pc.
@
text
@d3098 1
a3098 1
	  CORE_ADDR addr;
d3100 4
a3103 2
	  addr = osect->addr;
	  while (addr < osect->endaddr)
d3161 4
a3164 1
	  CORE_ADDR addr;
d3166 1
a3166 2
	  addr = osect->addr;
	  while (addr < osect->endaddr)
@


1.179
log
@        * ia64-tdep.c (ia64_convert_from_func_ptr_addr): Improve the heuristic
        that identifies function descriptors outside of the .opd section.
@
text
@d3439 1
a3439 1
			paddr_nz (frame_pc_unwind (this_frame)), 
@


1.178
log
@        * ia64-tdep.c (ia64_convert_from_func_ptr_addr): Treat addresses
        pointing inside a non-executable section as function descriptors.
@
text
@d3232 4
a3235 3
  /* If ADDR points to a section that is not executable, then it cannot
     be pointing to a function.  So it must be pointing to a function
     descriptor.  */
d3237 7
a3243 1
    return read_memory_unsigned_integer (addr, 8);
@


1.177
log
@        * frame-unwind.c (frame_unwind_got_bytes): New function.
        * frame-unwind.h (frame_unwind_got_bytes): Add declaration.
        * libunwind-frame.h, libunwind-frame.c, ia64-tdep.c: Update
        for unwinder changes.
@
text
@d3232 6
@


1.176
log
@	Convert frame unwinders to use the current frame and
	"struct value".

	* frame.c (frame_debug): Make global.
	(get_frame_id): Pass this frame to unwinder routines.
	(frame_pc_unwind): Remove unused unwind->prev_pc support.
	(do_frame_register_read): Do not discard the return value of
	frame_register_read.
	(frame_register_unwind): Remove debug messages.  Use
	frame_unwind_register_value.
	(frame_unwind_register_value, get_frame_register_value): New
	functions.
	(create_new_frame, get_frame_base_address, get_frame_locals_address)
	(get_frame_args_address, get_frame_type): Pass this frame to
	unwinder routines.
	(frame_cleanup_after_sniffer, frame_prepare_for_sniffer): New
	functions.
	* frame.h: Update comments.
	(frame_debug, frame_unwind_register_value, get_frame_register_value)
	(frame_prepare_for_sniffer): Declare.
	* frame-unwind.h: Update comments and parameter names.
	(default_frame_sniffer): Declare.
	(frame_prev_register_ftype): Return a struct value *.
	(struct frame_unwind): Remove prev_pc member.
	(frame_unwind_sniffer_ftype, frame_unwind_append_sniffer): Delete.
	(frame_unwind_append_unwinder, frame_unwind_got_optimized)
	(frame_unwind_got_register, frame_unwind_got_memory)
	(frame_unwind_got_constant, frame_unwind_got_address): Declare.
	* frame-base.h: Update comments and parameter names.
	* valops.c (value_fetch_lazy): Use get_frame_register_value.  Iterate
	if necessary.  Add debugging output.
	* sentinel-frame.c (sentinel_frame_prev_register)
	(sentinel_frame_this_id): Update for new signature.
	(sentinel_frame_prev_pc): Delete.
	(sentinel_frame_unwinder): Remove prev_pc.
	* ia64-tdep.c (ia64_libunwind_frame_unwind): Do not initialize
	prev_pc.
	* libunwind-frame.c (libunwind_frame_unwind): Likewise.
	* frame-unwind.c (struct frame_unwind_table_entry): Remove sniffer.
	(frame_unwind_append_sniffer): Delete.
	(frame_unwind_append_unwinder): New function.
	(frame_unwind_find_by_frame): Take this frame.  Only use sniffers
	from unwinders.  Use frame_prepare_for_sniffer.
	(default_frame_sniffer, frame_unwind_got_optimized)
	(frame_unwind_got_register, frame_unwind_got_memory)
	(frame_unwind_got_constant, frame_unwind_got_address): New functions.
	* dummy-frame.c (dummy_frame_sniffer): Use gdbarch_dummy_id.
	(dummy_frame_prev_register, dummy_frame_this_id): Update for new
	signature.
	* gdbarch.sh: Replace unwind_dummy_id with dummy_id.
	* gdbarch.c, gdbarch.c: Regenerated.
	* frame-base.c (default_frame_base_address)
	(default_frame_locals_address, default_frame_args_address): Update
	for new signature.
	(frame_base_find_by_frame): Pass this frame to unwinder routines.
	* infcall.c (call_function_by_hand): Update comments.
	* Makefile.in (frame-unwind.o): Update dependencies.

	* gdbint.texinfo (Stack Frames): New chapter.
	(Algorithms): Move Frames text to the new chapter.
	(Target Conditionals): Delete SAVE_DUMMY_FRAME_TOS.  Document
	gdbarch_dummy_id instead of gdbarch_unwind_dummy_id.
@
text
@d346 1
a346 1
extract_bit_field (char *bundle, int from, int len)
d1064 3
a1066 1
examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc, struct frame_info *next_frame, struct ia64_frame_cache *cache)
d1117 1
a1117 1
      if (!next_frame ||
d1235 1
a1235 1
	      if (next_frame)
d1237 1
a1237 1
		  frame_unwind_register (next_frame, sp_regnum, buf);
d1437 3
a1439 2
  /* If not frameless and we aren't called by skip_prologue, then we need to calculate
     registers for the previous frame which will be needed later.  */
d1441 1
a1441 1
  if (!frameless && next_frame)
d1480 1
a1480 1
	  frame_unwind_register (next_frame, cfm_reg, buf);
d1492 3
a1494 2
	  /* The previous bof only requires subtraction of the sol (size of locals)
	     due to the overlap between output and input of subsequent frames.  */
d1544 1
a1544 1
ia64_frame_cache (struct frame_info *next_frame, void **this_cache)
d1557 1
a1557 1
  frame_unwind_register (next_frame, sp_regnum, buf);
d1563 1
a1563 1
  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
d1566 1
a1566 1
  frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
d1569 1
a1569 1
  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
d1578 1
a1578 1
  cache->pc = frame_func_unwind (next_frame, NORMAL_FRAME);
d1581 1
a1581 1
    examine_prologue (cache->pc, frame_pc_unwind (next_frame), next_frame, cache);
d1589 1
a1589 1
ia64_frame_this_id (struct frame_info *next_frame, void **this_cache,
d1593 1
a1593 1
    ia64_frame_cache (next_frame, this_cache);
d1602 1
a1602 1
			"regular frame id: code 0x%s, stack 0x%s, special 0x%s, next_frame %p\n",
d1605 1
a1605 1
			paddr_nz (cache->bsp), next_frame);
d1608 3
a1610 5
static void
ia64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, gdb_byte *valuep)
d1612 2
a1613 4
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct ia64_frame_cache *cache =
    ia64_frame_cache (next_frame, this_cache);
  char dummy_valp[MAX_REGISTER_SIZE];
a1620 12
  *optimizedp = 0;
  *addrp = 0;
  *lvalp = not_lval;
  *realnump = -1;

  /* Rather than check each time if valuep is non-null, supply a dummy buffer
     when valuep is not supplied.  */
  if (!valuep)
    valuep = dummy_valp;
  
  memset (valuep, 0, register_size (gdbarch, regnum));
 
d1622 2
a1623 5
    {
      /* Handle SP values for all frames but the topmost. */
      store_unsigned_integer (valuep, register_size (gdbarch, regnum),
			      cache->base);
    }
d1626 2
a1627 16
      char cfm_valuep[MAX_REGISTER_SIZE];
      int  cfm_optim;
      int  cfm_realnum;
      enum lval_type cfm_lval;
      CORE_ADDR cfm_addr;
      CORE_ADDR bsp, prev_cfm, prev_bsp;

      /* We want to calculate the previous bsp as the end of the previous register stack frame.
	 This corresponds to what the hardware bsp register will be if we pop the frame
	 back which is why we might have been called.  We know the beginning of the current
	 frame is cache->bsp - cache->sof.  This value in the previous frame points to
	 the start of the output registers.  We can calculate the end of that frame by adding
	 the size of output (sof (size of frame) - sol (size of locals)).  */
      ia64_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
				&cfm_optim, &cfm_lval, &cfm_addr, &cfm_realnum, cfm_valuep);
      prev_cfm = extract_unsigned_integer (cfm_valuep, 8);
d1629 10
d1640 2
a1641 1
      prev_bsp = rse_address_add (bsp, (prev_cfm & 0x7f) - ((prev_cfm >> 7) & 0x7f));
d1643 1
a1643 2
      store_unsigned_integer (valuep, register_size (gdbarch, regnum), 
			      prev_bsp);
d1645 1
d1651 9
a1659 12
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (gdbarch, regnum));
	}
      else if (cache->prev_cfm)
	store_unsigned_integer (valuep, register_size (gdbarch, regnum), cache->prev_cfm);
      else if (cache->frameless)
	{
	  CORE_ADDR cfm = 0;
	  frame_unwind_register (next_frame, IA64_PFS_REGNUM, valuep);
	}
d1661 1
d1668 1
a1668 2
      CORE_ADDR vfp = cache->base;
      store_unsigned_integer (valuep, register_size (gdbarch, IA64_VFP_REGNUM), vfp);
d1670 1
d1673 5
a1677 8
      char pr_valuep[MAX_REGISTER_SIZE];
      int  pr_optim;
      int  pr_realnum;
      enum lval_type pr_lval;
      CORE_ADDR pr_addr;
      ULONGEST prN_val;
      ia64_frame_prev_register (next_frame, this_cache, IA64_PR_REGNUM,
				&pr_optim, &pr_lval, &pr_addr, &pr_realnum, pr_valuep);
d1685 1
a1685 2
	  regnum = VP16_REGNUM 
	         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
d1687 3
a1689 3
      prN_val = extract_bit_field ((unsigned char *) pr_valuep,
                                   regnum - VP0_REGNUM, 1);
      store_unsigned_integer (valuep, register_size (gdbarch, regnum), prN_val);
d1691 1
d1694 7
a1700 12
      char unat_valuep[MAX_REGISTER_SIZE];
      int  unat_optim;
      int  unat_realnum;
      enum lval_type unat_lval;
      CORE_ADDR unat_addr;
      ULONGEST unatN_val;
      ia64_frame_prev_register (next_frame, this_cache, IA64_UNAT_REGNUM,
				&unat_optim, &unat_lval, &unat_addr, &unat_realnum, unat_valuep);
      unatN_val = extract_bit_field ((unsigned char *) unat_valuep,
                                   regnum - IA64_NAT0_REGNUM, 1);
      store_unsigned_integer (valuep, register_size (gdbarch, regnum), 
                              unatN_val);
d1702 1
d1710 2
a1711 2
      gr_addr = cache->saved_regs[regnum - IA64_NAT0_REGNUM 
				  + IA64_GR0_REGNUM];
d1719 1
d1723 1
a1723 1
	  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
d1727 1
a1727 1
	      frame_unwind_register (next_frame, IA64_RNAT_REGNUM, buf);
d1736 1
a1736 1
      store_unsigned_integer (valuep, register_size (gdbarch, regnum), natval);
d1738 1
d1745 4
a1748 6
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, buf, register_size (gdbarch, IA64_IP_REGNUM));
	  pc = extract_unsigned_integer (buf, 8);
	}
d1751 1
a1751 1
	  frame_unwind_register (next_frame, IA64_BR0_REGNUM, buf);
d1755 1
a1755 1
      store_unsigned_integer (valuep, 8, pc);
d1757 1
d1760 4
a1763 4
      /* We don't know how to get the complete previous PSR, but we need it for
	 the slot information when we unwind the pc (pc is formed of IP register
	 plus slot information from PSR).  To get the previous slot information, 
	 we mask it off the return address.  */
d1765 1
a1765 1
      CORE_ADDR pc= 0;
d1769 1
a1769 1
      frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
a1773 2
	  *lvalp = lval_memory;
	  *addrp = addr;
d1779 1
a1779 2
	  CORE_ADDR pc;
	  frame_unwind_register (next_frame, IA64_BR0_REGNUM, buf);
d1785 1
a1785 1
      store_unsigned_integer (valuep, 8, psr);
d1787 1
a1789 1
      CORE_ADDR br0 = 0;
d1791 1
d1793 3
a1795 7
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, buf, register_size (gdbarch, IA64_BR0_REGNUM));
	  br0 = extract_unsigned_integer (buf, 8);
	}
      store_unsigned_integer (valuep, 8, br0);
d1797 3
a1799 2
 else if ((regnum >= IA64_GR32_REGNUM && regnum <= IA64_GR127_REGNUM) ||
	   (regnum >= V32_REGNUM && regnum <= V127_REGNUM))
d1802 1
d1807 3
a1809 6
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (gdbarch, regnum));
	}
      else if (cache->frameless)
d1811 5
a1815 7
	  char r_valuep[MAX_REGISTER_SIZE];
	  int  r_optim;
	  int  r_realnum;
	  enum lval_type r_lval;
	  CORE_ADDR r_addr;
	  CORE_ADDR prev_cfm, prev_bsp, prev_bof;
	  CORE_ADDR addr = 0;
d1818 8
a1825 6
	  ia64_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
				    &r_optim, &r_lval, &r_addr, &r_realnum, r_valuep); 
	  prev_cfm = extract_unsigned_integer (r_valuep, 8);
	  ia64_frame_prev_register (next_frame, this_cache, IA64_BSP_REGNUM,
				    &r_optim, &r_lval, &r_addr, &r_realnum, r_valuep);
	  prev_bsp = extract_unsigned_integer (r_valuep, 8);
d1829 1
a1829 3
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (gdbarch, regnum));
d1831 2
d1834 2
a1835 1
  else
d1838 1
d1854 1
a1854 5
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (gdbarch, regnum));
	}
d1857 1
a1857 1
	frame_unwind_register (next_frame, regnum, valuep);
a1858 7

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"regular prev register <%d> <%s> is 0x%s\n", regnum, 
			(((unsigned) regnum <= IA64_NAT127_REGNUM)
			 ? ia64_register_names[regnum] : "r??"), 
			paddr_nz (extract_unsigned_integer (valuep, 8)));
d1865 3
a1867 1
  &ia64_frame_prev_register
a1869 6
static const struct frame_unwind *
ia64_frame_sniffer (struct frame_info *next_frame)
{
  return &ia64_frame_unwind;
}

d1873 1
a1873 1
ia64_sigtramp_frame_init_saved_regs (struct frame_info *next_frame,
d1876 1
a1876 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (next_frame));
d1915 1
a1915 1
ia64_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
d1927 1
a1927 1
  frame_unwind_register (next_frame, sp_regnum, buf);
d1932 1
a1932 1
  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
d1935 1
a1935 1
  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
d1939 1
a1939 1
  ia64_sigtramp_frame_init_saved_regs (next_frame, cache);
d1946 2
a1947 2
ia64_sigtramp_frame_this_id (struct frame_info *next_frame,
			       void **this_cache, struct frame_id *this_id)
d1950 1
a1950 1
    ia64_sigtramp_frame_cache (next_frame, this_cache);
d1952 3
a1954 1
  (*this_id) = frame_id_build_special (cache->base, frame_pc_unwind (next_frame), cache->bsp);
d1957 1
a1957 1
			"sigtramp frame id: code 0x%s, stack 0x%s, special 0x%s, next_frame %p\n",
d1960 1
a1960 1
			paddr_nz (cache->bsp), next_frame);
d1963 3
a1965 6
static void
ia64_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, gdb_byte *valuep)
a1966 1
  char dummy_valp[MAX_REGISTER_SIZE];
d1969 1
a1969 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d1971 1
a1971 1
    ia64_sigtramp_frame_cache (next_frame, this_cache);
a1977 12
  *optimizedp = 0;
  *addrp = 0;
  *lvalp = not_lval;
  *realnump = -1;

  /* Rather than check each time if valuep is non-null, supply a dummy buffer
     when valuep is not supplied.  */
  if (!valuep)
    valuep = dummy_valp;
  
  memset (valuep, 0, register_size (gdbarch, regnum));
 
a1984 2
	  *lvalp = lval_memory;
	  *addrp = addr;
d1989 1
a1989 1
      store_unsigned_integer (valuep, 8, pc);
d1991 3
a1993 2
 else if ((regnum >= IA64_GR32_REGNUM && regnum <= IA64_GR127_REGNUM) ||
	   (regnum >= V32_REGNUM && regnum <= V127_REGNUM))
d1996 1
d2001 3
a2003 5
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (gdbarch, regnum));
	}
d2005 2
a2006 1
  else
a2007 1
      /* All other registers not listed above.  */
d2009 1
d2011 3
a2013 5
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (gdbarch, regnum));
	}
a2014 12

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"sigtramp prev register <%s> is 0x%s\n",
			(regnum < IA64_GR32_REGNUM
			 || (regnum > IA64_GR127_REGNUM
			     && regnum < LAST_PSEUDO_REGNUM))
			 ? ia64_register_names[regnum]
			 : (regnum < LAST_PSEUDO_REGNUM
			    ? ia64_register_names[regnum-IA64_GR32_REGNUM+V32_REGNUM]
			    : "OUT_OF_RANGE"),
			paddr_nz (extract_unsigned_integer (valuep, 8)));
d2017 4
a2020 1
static const struct frame_unwind ia64_sigtramp_frame_unwind =
d2022 1
a2022 9
  SIGTRAMP_FRAME,
  ia64_sigtramp_frame_this_id,
  ia64_sigtramp_frame_prev_register
};

static const struct frame_unwind *
ia64_sigtramp_frame_sniffer (struct frame_info *next_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (next_frame));
d2025 1
a2025 1
      CORE_ADDR pc = frame_pc_unwind (next_frame);
d2028 1
a2028 1
	return &ia64_sigtramp_frame_unwind;
d2031 1
a2031 1
  return NULL;
d2033 10
d2046 1
a2046 1
ia64_frame_base_address (struct frame_info *next_frame, void **this_cache)
d2048 1
a2048 2
  struct ia64_frame_cache *cache =
    ia64_frame_cache (next_frame, this_cache);
d2167 1
a2167 1
  struct frame_info *next_frame = arg;
d2179 1
a2179 1
	frame_unwind_register (next_frame, IA64_IP_REGNUM, buf);
d2181 1
a2181 1
	frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
d2190 1
a2190 1
	frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
d2192 1
a2192 1
	frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
d2201 1
a2201 1
	frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
d2207 1
a2207 1
	frame_unwind_register (next_frame, regnum, buf);
d2227 1
a2227 1
  struct frame_info *next_frame = arg;
d2232 1
a2232 1
  frame_unwind_register (next_frame, regnum, (char *) val);
d2594 1
a2594 1
ia64_libunwind_frame_this_id (struct frame_info *next_frame, void **this_cache,
d2597 1
a2599 4
  struct frame_id id;
  CORE_ADDR prev_ip, addr;
  int realnum, optimized;
  enum lval_type lval;
d2602 1
a2602 1
  libunwind_frame_this_id (next_frame, this_cache, &id);
d2611 1
a2611 1
  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
d2614 1
a2614 11
  /* If the previous frame pc value is 0, then we are at the end of the stack
     and don't want to unwind past this frame.  We return a null frame_id to
     indicate this.  */
  libunwind_frame_prev_register (next_frame, this_cache, IA64_IP_REGNUM, 
		  		 &optimized, &lval, &addr, &realnum, buf);
  prev_ip = extract_unsigned_integer (buf, 8);

  if (prev_ip != 0)
    (*this_id) = frame_id_build_special (id.stack_addr, id.code_addr, bsp);
  else
    (*this_id) = null_frame_id;
d2618 1
a2618 1
			"libunwind frame id: code 0x%s, stack 0x%s, special 0x%s, next_frame %p\n",
d2620 1
a2620 1
			paddr_nz (bsp), next_frame);
d2623 3
a2625 6
static void
ia64_libunwind_frame_prev_register (struct frame_info *next_frame,
				    void **this_cache,
				    int regnum, int *optimizedp,
				    enum lval_type *lvalp, CORE_ADDR *addrp,
				    int *realnump, gdb_byte *valuep)
d2628 2
a2630 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d2637 1
a2637 6
  libunwind_frame_prev_register (next_frame, this_cache, reg,
				 optimizedp, lvalp, addrp, realnump, valuep);

  /* No more to do if the value is not supposed to be supplied.  */
  if (!valuep)
    return;
d2651 1
a2651 1
	  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
d2656 1
a2656 2
	  regnum = VP16_REGNUM 
	    + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
d2658 1
a2658 1
      prN_val = extract_bit_field ((unsigned char *) valuep,
d2660 1
a2660 1
      store_unsigned_integer (valuep, register_size (gdbarch, regnum), prN_val);
d2662 1
d2667 3
a2669 4
      unatN_val = extract_bit_field ((unsigned char *) valuep,
                                   regnum - IA64_NAT0_REGNUM, 1);
      store_unsigned_integer (valuep, register_size (gdbarch, regnum), 
                              unatN_val);
d2671 1
d2674 12
a2685 15
      char cfm_valuep[MAX_REGISTER_SIZE];
      int  cfm_optim;
      int  cfm_realnum;
      enum lval_type cfm_lval;
      CORE_ADDR cfm_addr;
      CORE_ADDR bsp, prev_cfm, prev_bsp;

      /* We want to calculate the previous bsp as the end of the previous register stack frame.
	 This corresponds to what the hardware bsp register will be if we pop the frame
	 back which is why we might have been called.  We know that libunwind will pass us back
	 the beginning of the current frame so we should just add sof to it. */
      prev_bsp = extract_unsigned_integer (valuep, 8);
      libunwind_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
				     &cfm_optim, &cfm_lval, &cfm_addr, &cfm_realnum, cfm_valuep);
      prev_cfm = extract_unsigned_integer (cfm_valuep, 8);
d2688 1
a2688 2
      store_unsigned_integer (valuep, register_size (gdbarch, regnum), 
			      prev_bsp);
d2690 12
d2703 1
a2703 11
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"libunwind prev register <%s> is 0x%s\n",
			(regnum < IA64_GR32_REGNUM
			 || (regnum > IA64_GR127_REGNUM
			     && regnum < LAST_PSEUDO_REGNUM))
			 ? ia64_register_names[regnum]
			 : (regnum < LAST_PSEUDO_REGNUM
			    ? ia64_register_names[regnum-IA64_GR32_REGNUM+V32_REGNUM]
			    : "OUT_OF_RANGE"),
			paddr_nz (extract_unsigned_integer (valuep, 8)));
d2712 1
a2712 1
  NULL,
a2715 9
static const struct frame_unwind *
ia64_libunwind_frame_sniffer (struct frame_info *next_frame)
{
  if (libunwind_is_initialized () && libunwind_frame_sniffer (next_frame))
    return &ia64_libunwind_frame_unwind;

  return NULL;
}

d2717 2
a2718 1
ia64_libunwind_sigtramp_frame_this_id (struct frame_info *next_frame, void **this_cache,
d2726 1
a2726 1
  libunwind_frame_this_id (next_frame, this_cache, &id);
d2735 1
a2735 1
  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
d2743 1
a2743 1
			"libunwind sigtramp frame id: code 0x%s, stack 0x%s, special 0x%s, next_frame %p\n",
d2745 1
a2745 1
			paddr_nz (bsp), next_frame);
d2748 3
a2750 7
static void
ia64_libunwind_sigtramp_frame_prev_register (struct frame_info *next_frame,
					     void **this_cache,
					     int regnum, int *optimizedp,
					     enum lval_type *lvalp, CORE_ADDR *addrp,
					     int *realnump, gdb_byte *valuep)

d2752 2
a2753 5
  gdb_byte buf[8];
  CORE_ADDR prev_ip, addr;
  int realnum, optimized;
  enum lval_type lval;

d2757 3
a2759 3
  libunwind_frame_prev_register (next_frame, this_cache, IA64_IP_REGNUM, 
		  		 &optimized, &lval, &addr, &realnum, buf);
  prev_ip = extract_unsigned_integer (buf, 8);
d2764 2
a2765 2
      ia64_sigtramp_frame_prev_register (next_frame, &tmp_cache, regnum, optimizedp, lvalp,
					 addrp, realnump, valuep);
d2768 1
a2768 2
    ia64_libunwind_frame_prev_register (next_frame, this_cache, regnum, optimizedp, lvalp,
					addrp, realnump, valuep);
d2771 4
a2774 9
static const struct frame_unwind ia64_libunwind_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  ia64_libunwind_sigtramp_frame_this_id,
  ia64_libunwind_sigtramp_frame_prev_register
};

static const struct frame_unwind *
ia64_libunwind_sigtramp_frame_sniffer (struct frame_info *next_frame)
d2778 3
a2780 3
      if (libunwind_sigtramp_frame_sniffer (next_frame))
        return &ia64_libunwind_sigtramp_frame_unwind;
      return NULL;
d2783 1
a2783 1
    return ia64_sigtramp_frame_sniffer (next_frame);
d2786 9
d3412 1
a3412 1
ia64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d3417 1
a3417 1
  frame_unwind_register (next_frame, sp_regnum, buf);
d3420 1
a3420 1
  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
d3426 1
a3426 1
			paddr_nz (frame_pc_unwind (next_frame)), 
d3429 1
a3429 1
  return frame_id_build_special (sp, frame_pc_unwind (next_frame), bsp);
d3519 1
a3519 1
  set_gdbarch_unwind_dummy_id (gdbarch, ia64_unwind_dummy_id);
d3523 4
a3526 2
  frame_unwind_append_sniffer (gdbarch, ia64_libunwind_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, ia64_libunwind_frame_sniffer);
d3529 1
a3529 1
  frame_unwind_append_sniffer (gdbarch, ia64_sigtramp_frame_sniffer);
d3531 1
a3531 1
  frame_unwind_append_sniffer (gdbarch, ia64_frame_sniffer);
@


1.175
log
@        * ia64-tdep.c (ia64_memory_remove_breakpoint): Set
        show_memory_breakpoints to 1 while reading the instruction bundle.
@
text
@a2805 1
  NULL,
@


1.174
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d601 1
d605 5
d625 1
@


1.173
log
@	* ia64-tdep.c (examine_prologue): Correct array access.
@
text
@d3062 3
a3064 3
ia64_return_value (struct gdbarch *gdbarch, struct type *valtype,
		   struct regcache *regcache, gdb_byte *readbuf,
		   const gdb_byte *writebuf)
@


1.172
log
@
	* gdbarch.sh (memory_insert_breakpoint, memory_remove_breakpoint): Add
	gdbarch as parameter.

	* gdbarch.{c,h}: Regenerate.

	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Add gdbarch as
	parameter.
	* mem-break.c (default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Likewise.
	* target.h (default_memory_remove_breakpoint)
	(default_memory_insert_breakpoint): Likewise.

	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Add gdbarch as
	parameter. Replace current_gdbarch by gdbarch.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
@
text
@d1237 1
a1237 1
	  else if (qp == 0 && rM >= 32 && rM < 40 && !instores[rM] && 
@


1.172.2.1
log
@	* ia64-tdep.c (examine_prologue): Correct array access.
@
text
@d1237 1
a1237 1
	  else if (qp == 0 && rM >= 32 && rM < 40 && !instores[rM-32] && 
@


1.171
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d556 2
a557 1
ia64_memory_insert_breakpoint (struct bp_target_info *bp_tgt)
d592 2
a593 1
ia64_memory_remove_breakpoint (struct bp_target_info *bp_tgt)
@


1.170
log
@	Updated copyright notices for most files.
@
text
@d1515 1
a1515 1
ia64_skip_prologue (CORE_ADDR pc)
@


1.169
log
@	* gdbarch.sh (stab_reg_to_regnum, dwarf_reg_to_regnum)
	( dwarf2_reg_to_regnum, sdb_reg_to_regnum, ecoff_reg_to_regnum): Add
	gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* xtensa-tdep.c (xtensa_reg_to_regnum): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* s390-tdep.c (s390_dwarf_reg_to_regnum): Likewise.
	* rs6000-tdep.c (rs6000_stab_reg_to_regnum)
	(rs6000_dwarf2_reg_to_regnum): Likewise.
	* mips-tdep.c (mips_stab_reg_to_regnum)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	* mep-tdep.c (mep_debug_reg_to_regnum): Likewise.
	* m32c-tdep.c (m32c_debug_info_reg_to_regnum): Likewise.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise
	* h8300-tdep.c (h8300s_dbg_reg_to_regnum)
	(h8300_dbg_reg_to_regnum): Likewise.
	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Likewise.
	* arch-utils.c (no_op_reg_to_regnum): Likewise.
	* arch-utils.h (no_op_reg_to_regnum): Likewise.
	* arm-tdep.c (arm_dwarf_reg_to_regnum): Likewise.
	* cris-tdep.c (cris_dwarf2_reg_to_regnum): Likewise.
	* hppa-tdep.c (hppa64_dwarf_reg_to_regnum): Likewise.
	* ia64-tdep.c (ia64_dwarf_reg_to_regnum): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.168
log
@	* gdbarch.sh (convert_register_p): Add gdbarch as parameter.
	* ia64-tdep.c (ia64_convert_register_p): Likewise.
	* i387-tdep.c (i387_convert_register_p): Likewise.
	* i387-tdep.h (i387_convert_register_p): Likewise.
	* alpha-tdep.c (alpha_convert_register_p): Likewise.
	* gdbarch.{c,h}: Regenerate.

	* rs6000-tdep.c (rs6000_convert_register_p): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* mips-tdep.c (mips_convert_register_p): Likewise.
	* m68k-tdep.c (m68k_convert_register_p): Likewise.
	* i386-tdep.c (i386_convert_register_p): Likewise.
@
text
@d316 1
a316 1
ia64_dwarf_reg_to_regnum (int reg)
@


1.167
log
@include:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* floatformat.h (struct floatformat): Add split_half field.
	(floatformat_ibm_long_double): New.

libiberty:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* floatformat.c (mant_bits_set): New.
	(floatformat_to_double): Use it.  Note no special handling of
	split formats.
	(floatformat_from_double): Note no special handing of split
	formats.
	(floatformat_ibm_long_double_is_valid,
	floatformat_ibm_long_double): New.
	(floatformat_ieee_single_big, floatformat_ieee_single_little,
	floatformat_ieee_double_big, floatformat_ieee_double_little,
	floatformat_ieee_double_littlebyte_bigword, floatformat_vax_f,
	floatformat_vax_d, floatformat_vax_g, floatformat_i387_ext,
	floatformat_m68881_ext, floatformat_i960_ext,
	floatformat_m88110_ext, floatformat_m88110_harris_ext,
	floatformat_arm_ext_big, floatformat_arm_ext_littlebyte_bigword,
	floatformat_ia64_spill_big, floatformat_ia64_spill_little,
	floatformat_ia64_quad_big, floatformat_ia64_quad_little): Update
	for addition of split_half field.

gdb:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdbtypes.c (floatformats_ibm_long_double): New.
	* gdbtypes.h (floatformats_ibm_long_double): Declare.
	* ia64-tdep.c (floatformat_ia64_ext): Update for addition of
	split_half field.
	* mips-tdep.c (n32n64_floatformat_always_valid,
	floatformat_n32n64_long_double_big, floatformats_n32n64_long):
	Remove.
	(mips_gdbarch_init): Use floatformats_ibm_long_double instead of
	floatformats_n32n64_long.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Use 128-bit IBM long
	double.
	* doublest.c (convert_floatformat_to_doublest,
	convert_doublest_to_floatformat): Handle split floating-point
	formats.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Handle IBM long
	double arguments.
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	(do_ppc_sysv_return_value): Handle IBM long double return.
@
text
@d921 1
a921 1
ia64_convert_register_p (int regno, struct type *type)
@


1.166
log
@*** empty log message ***
@
text
@d332 1
a332 1
  floatformat_intbit_yes, "floatformat_ia64_ext", floatformat_valid
@


1.165
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d623 1
a623 1
ia64_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
@


1.164
log
@	* amd64-tdep.c (amd64_convert_register_p): Delete.
	(amd64_init_abi): Use i387_convert_register_p.
	* alpha-tdep.c (alpha_convert_register_p): Return zero for
	eight byte types.
	(alpha_register_to_value, alpha_value_to_register): Do not handle
	eight byte types.
	* i386-tdep.c (i386_convert_register_p): Use i387_convert_register_p.
	* i387-tdep.c (i387_convert_register_p): New.
	(i387_register_to_value, i387_value_to_register): Update comments.
	* i387-tdep.h (i387_convert_register_p): Declare.
	* ia64-tdep.c (ia64_convert_register_p): Return zero for
	builtin_type_ia64_ext.
	(ia64_gdbarch_init): Do not initialize builtin_type_ia64_ext here.
	(_initialize_ia64_tdep): Initialize builtin_type_ia64_ext here.
	* m68k-tdep.c (m68k_convert_register_p): Return zero for
	builtin_type_m68881_ext.
	(m68k_register_to_value, m68k_value_to_register): Update comments.

	* gdbint.texinfo (Register and Memory Data, Target Conditionals):
	Document that gdbarch_convert_register_p should return zero for no-op
	conversions.
@
text
@d301 1
a301 1
ia64_register_name (int reg)
@


1.163
log
@	* ia64-linux-nat.c (ia64_register_addr): Add gdbarch parameter,
	replacing use of global current_gdbarch.
	(ia64_cannot_fetch_register, ia64_cannot_store_register): Likewise.
	(ia64_linux_fetch_register, ia64_linux_store_register): Update callers.

	* ia64-tdep.c (SIGCONTEXT_REGISTER_ADDRESS): Remove macro.
	(ia64_sigtramp_frame_init_saved_regs): Add next_frame parameter,
	replace uses of SIGCONTEXT_REGISTER_ADDRESS.
	(ia64_sigtramp_frame_cache): Update caller.
@
text
@d923 2
a924 1
  return (regno >= IA64_FR0_REGNUM && regno <= IA64_FR127_REGNUM);
a3567 6
  /* Define the ia64 floating-point format to gdb.  */
  builtin_type_ia64_ext =
    init_type (TYPE_CODE_FLT, 128 / 8,
               0, "builtin_type_ia64_ext", NULL);
  TYPE_FLOATFORMAT (builtin_type_ia64_ext) = floatformats_ia64_ext;

d3650 6
@


1.162
log
@	* avr-tdep.c (avr_return_value): New function.
	(avr_gdbarch_init): Call set_gdbarch_return_value instead of
	set_gdbarch_extract_return_value.

	* fvr-tdep.c (frv_return_value): New function.
	(frv_gdbarch_init): Call set_gdbarch_return_value instead of
	set_gdbarch_extract_return_value, set_gdbarch_store_return_value,
	and set_gdbarch_deprecated_use_struct_convention.

	* ia64-tdep.c (ia64_use_struct_convention): Make static.
	Add check for structure, union, or array types.
	(ia64_extract_return_value): Make static.
	(ia64_store_return_value): Make static.  Support multi-word values.
	(ia64_return_value): New function.
	(ia64_gdbarch_init): Call set_gdbarch_return_value instead of
	set_gdbarch_extract_return_value, set_gdbarch_store_return_value,
	and set_gdbarch_deprecated_use_struct_convention.
@
text
@a276 3
#define SIGCONTEXT_REGISTER_ADDRESS \
  (gdbarch_tdep (current_gdbarch)->sigcontext_register_address)

d1909 2
a1910 1
ia64_sigtramp_frame_init_saved_regs (struct ia64_frame_cache *cache)
d1912 3
a1914 1
  if (SIGCONTEXT_REGISTER_ADDRESS)
d1919 1
a1919 1
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_IP_REGNUM);
d1921 1
a1921 1
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_CFM_REGNUM);
d1923 1
a1923 1
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_PSR_REGNUM);
d1925 1
a1925 1
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_BSP_REGNUM);
d1927 1
a1927 1
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_RNAT_REGNUM);
d1929 1
a1929 1
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_CCV_REGNUM);
d1931 1
a1931 1
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_UNAT_REGNUM);
d1933 1
a1933 1
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_FPSR_REGNUM);
d1935 1
a1935 1
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_PFS_REGNUM);
d1937 1
a1937 1
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_LC_REGNUM);
d1940 1
a1940 1
	  SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
d1943 1
a1943 1
	  SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
d1946 1
a1946 1
	  SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
d1975 1
a1975 1
  ia64_sigtramp_frame_init_saved_regs (cache);
@


1.161
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write):
	Replace current_gdbarch by gdbarch.
	* ia64-tdep.c (ia64_frame_prev_register
	(ia64_sigtramp_frame_prev_register)
	(ia64_libunwind_frame_prev_register): Use get_regcache_arch or
	get_frame_arch to get at the current architecture by regcache or by
	frame, respectively.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_fetch_registers, ia64_linux_store_register)
	(ia64_linux_store_registers): Likewise.
@
text
@d2932 2
a2933 5
/* Should we use DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS instead of
   gdbarch_extract_return_value?  GCC_P is true if compiled with gcc and TYPE
   is the type (which is known to be struct, union or array).  */
int
ia64_use_struct_convention (int gcc_p, struct type *type)
d2937 7
d2958 1
a2958 1
void
d3008 74
a3542 15
static void
ia64_store_return_value (struct type *type, struct regcache *regcache, 
			const gdb_byte *valbuf)
{
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      char to[MAX_REGISTER_SIZE];
      convert_typed_floating (valbuf, type, to, builtin_type_ia64_ext);
      regcache_cooked_write (regcache, IA64_FR8_REGNUM, (void *)to);
      target_store_registers (regcache, IA64_FR8_REGNUM);
    }
  else
    regcache_cooked_write (regcache, IA64_GR8_REGNUM, valbuf);
}

d3610 1
a3610 4
  set_gdbarch_deprecated_use_struct_convention (gdbarch, ia64_use_struct_convention);
  set_gdbarch_extract_return_value (gdbarch, ia64_extract_return_value);

  set_gdbarch_store_return_value (gdbarch, ia64_store_return_value);
@


1.160
log
@        * ia64-tdep.c (refine_prologue_limit): Make sure we don't scan
        the linetable past the function end.
@
text
@d718 1
a718 1
	      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), reg);
d721 1
a721 1
	    store_unsigned_integer (buf, register_size (current_gdbarch, regnum), 0);
d730 1
a730 1
      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), unatN_val);
d765 1
a765 1
      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), natN_val);
d780 1
a780 1
      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), vbsp);
d802 1
a802 1
      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), prN_val);
d805 1
a805 1
    memset (buf, 0, register_size (current_gdbarch, regnum));
d832 1
a832 1
      unatN_val = extract_unsigned_integer (buf, register_size (current_gdbarch, regnum)); 
d856 1
a856 1
      natN_val = extract_unsigned_integer (buf, register_size (current_gdbarch, regnum)); 
d885 1
a885 1
	      store_unsigned_integer (nat_buf, register_size (current_gdbarch, regnum), nat_collection);
d910 1
a910 1
      prN_val = extract_unsigned_integer (buf, register_size (current_gdbarch, regnum)); 
d1603 1
d1624 1
a1624 1
  memset (valuep, 0, register_size (current_gdbarch, regnum));
d1626 1
a1626 1
  if (regnum == gdbarch_sp_regnum (current_gdbarch))
d1629 1
a1629 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum),
d1654 1
a1654 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
d1665 1
a1665 1
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
d1668 1
a1668 1
	store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), cache->prev_cfm);
d1682 1
a1682 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, IA64_VFP_REGNUM), vfp);
d1706 1
a1706 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), prN_val);
d1720 1
a1720 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
d1755 1
a1755 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), natval);
d1766 1
a1766 1
	  read_memory (addr, buf, register_size (current_gdbarch, IA64_IP_REGNUM));
d1795 1
a1795 1
	  read_memory (addr, buf, register_size (current_gdbarch, IA64_IP_REGNUM));
d1817 1
a1817 1
	  read_memory (addr, buf, register_size (current_gdbarch, IA64_BR0_REGNUM));
d1833 1
a1833 1
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
d1857 1
a1857 1
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
d1881 1
a1881 1
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
d2007 1
d2026 1
a2026 1
  memset (valuep, 0, register_size (current_gdbarch, regnum));
d2037 1
a2037 1
	  read_memory (addr, buf, register_size (current_gdbarch, IA64_IP_REGNUM));
d2054 1
a2054 1
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
d2065 1
a2065 1
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
d2706 1
d2742 1
a2742 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), prN_val);
d2750 1
a2750 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
d2772 1
a2772 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
@


1.159
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d970 6
@


1.159.2.1
log
@        * ia64-tdep.c (refine_prologue_limit): Make sure we don't scan
        the linetable past the function end.
@
text
@a969 6
  CORE_ADDR end_pc;

  /* The prologue can not possibly go past the function end itself,
     so we can already adjust LIM_PC accordingly.  */
  if (find_pc_partial_function (pc, NULL, NULL, &end_pc) && end_pc < lim_pc)
    lim_pc = end_pc;
@


1.158
log
@	* gdbarch.sh (deprecated_register_size): Remove.
	* gdbarch.h, gdbarch.c: Regenerate.

	* arm-tdep.c (arm_push_dummy_call): Replace DEPRECATED_REGISTER_SIZE
	by INT_REGISTER_SIZE.
	(thumb_get_next_pc, arm_return_in_memory): Likewise.
	(arm_gdbarch_init): Do not call set_gdbarch_deprecated_register_size.
	* ia64-tdep.c (ia64_gdbarch_init): Do not call
	set_gdbarch_deprecated_register_size.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.157
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (EXTRACT_RETURN_VALUE): Replace with
	gdbarch_extract_return_value.
	* value.c (generic_use_struct_convention): Likewise (comment).
	* ia64-tdep.c (ia64_use_struct_convention): Likewise (comment).
	* arch-utils.c (legacy_return_value): Likewise.
	* arch-utils.h (legacy_return_value): Likewise (comment).
	* gdbarch.sh (STORE_RETURN_VALUE): Replace by
	gdbarch_store_return_value.
	* stack.c (return_command): Likewise (comment).
	* arch-utils.h (legacy_return_value): Likewise (comment).
	* arch-utils.c (legacy_return_value): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@a3527 3
  /* FIXME:  Following interface should not be needed, however, without it recurse.exp
     gets a number of extra failures.  */
  set_gdbarch_deprecated_register_size (gdbarch, 8);
@


1.156
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Remove.
	* sh-tdep.c (sh_extract_struct_value_address): Remove.
	(sh_gdbarch_init): Remove
	set_gdbarch_deprecated_extract_struct_value_address.
	* sh64-tdep.c (sh64_extract_struct_value_address): Remove.
	(sh64_gdbarch_init): Remove
	set_gdbarch_deprecated_extract_struct_value_address.
	* ia64-tdep.c (ia64_extract_struct_value_address): Remove.
	(ia64_gdbarch_init): Remove
	set_gdbarch_deprecated_extract_struct_value_address.
	* frv-tdep.c (frv_extract_struct_value_address): Remove.
	(frv_gdbarch_init): Remove
	set_gdbarch_deprecated_extract_struct_value_address.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d2926 1
a2926 1
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc and TYPE
@


1.155
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@a2996 7
CORE_ADDR
ia64_extract_struct_value_address (struct regcache *regcache)
{
  error (_("ia64_extract_struct_value_address called and cannot get struct value address"));
  return 0;
}

a3546 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, ia64_extract_struct_value_address);
@


1.154
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@d1621 1
a1621 1
  if (regnum == SP_REGNUM)
@


1.153
log
@	* arm-tdep.c (arm_print_float_info): Use register value from FRAME
	instead of calling read_register.

	* avr-tdep.c (avr_push_dummy_call): Write to REGCACHE instead of
	calling write_register.

	* hppa-tdep.c (hppa32_push_dummy_call): Write to REGCACHE instead of
	calling write_register.

	* ia64-tdep.c (find_func_descr): Add REGCACHE parameter.  Use it
	instead of calling read_register.
	(ia64_push_dummy_call): Update call to find_func_descr.  Use REGCACHE
	instead of calling read_register and write_register.

	* m32r-tdep.c (m32r_linux_supply_gregset): Use REGCACHE parameter
	instead of current_regcache.

	* mn10300-tdep.c (mn10300_push_dummy_call): Write to REGCACHE instead
	of calling write_register.
	* mn10300-linux-tdep.c (am33_supply_fpregset_method): Use REGCACHE
	parameter instead of current_regcache.

	* mips-tdep.c (mips2_fp_compat): Add FRAME parameter.  Use it
	instead of calling read_register.
	(mips_read_fp_register_double, mips_print_fp_register): Update calls.
	(mips_eabi_push_dummy_call): Use REGCACHE instead of write_register.
	(mips_n32n64_push_dummy_call): Likewise.
	(mips_o32_push_dummy_call): Likewise.
	(mips_o64_push_dummy_call): Likewise.

	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Use REGCACHE
	parameter instead of current_regcache.

	* xtensa-tdep.c (xtensa_register_write_masked): Add REGCACHE parameter.
	Use it instead of read_register and write_register.
	(xtensa_register_read_masked): Likewise.
	(xtensa_pseudo_register_read): Update call.
	(xtensa_pseudo_register_write): Likewise.
	(xtensa_frame_cache): Use register values unwound from NEXT_FRAME
	instead of calling read_register.
	(xtensa_push_dummy_call): Update comment.
@
text
@d640 1
a640 1
ia64_read_pc (ptid_t ptid)
d642 6
a647 3
  CORE_ADDR psr_value = read_register_pid (IA64_PSR_REGNUM, ptid);
  CORE_ADDR pc_value   = read_register_pid (IA64_IP_REGNUM, ptid);
  int slot_num = (psr_value >> 41) & 3;
d653 1
a653 1
ia64_write_pc (CORE_ADDR new_pc, ptid_t ptid)
d656 3
a658 1
  CORE_ADDR psr_value = read_register_pid (IA64_PSR_REGNUM, ptid);
d660 1
a660 1
  psr_value |= (CORE_ADDR)(slot_num & 0x3) << 41;
d664 2
a665 2
  write_register_pid (IA64_PSR_REGNUM, psr_value, ptid);
  write_register_pid (IA64_IP_REGNUM, new_pc, ptid);
@


1.152
log
@	* frame-unwind.h (frame_dealloc_cache_ftype): Define.
	(struct frame_unwind): Add dealloc_cache.
	* frame.c (reinit_frame_cache): Call dealloc_cache on all caches.

	* libunwind-frame.h (libunwind_frame_dealloc_cache): Declare.
	* libunwind-frame.c (libunwind_frame_dealloc_cache): Define.
	(libunwind_frame_unwind): Set dealloc_cache.
	* ia64-tdep.c (ia64_libunwind_frame_unwind): Set dealloc_cache.
@
text
@d3201 1
a3201 1
find_func_descr (CORE_ADDR faddr, CORE_ADDR *fdaptr)
d3209 1
a3209 1
      CORE_ADDR global_pointer;
d3218 2
a3219 1
	global_pointer = read_register (IA64_GR1_REGNUM);
d3277 2
a3278 1
  CORE_ADDR bsp, cfm, pfs, new_bsp, funcdescaddr, pc, global_pointer;
d3304 1
a3304 1
  cfm = read_register (IA64_CFM_REGNUM);
d3306 1
a3306 1
  bsp = read_register (IA64_BSP_REGNUM);
d3308 1
a3308 1
  write_register (IA64_BSP_REGNUM, new_bsp);
d3310 1
a3310 1
  pfs = read_register (IA64_PFS_REGNUM);
d3313 1
a3313 1
  write_register (IA64_PFS_REGNUM, pfs);
d3317 1
a3317 1
  write_register (IA64_CFM_REGNUM, cfm);
d3351 1
a3351 1

d3353 1
a3353 1
				  find_func_descr (extract_unsigned_integer (value_contents (arg), 8),
d3415 1
a3415 1
    write_register (IA64_GR1_REGNUM, global_pointer);
d3417 1
a3417 1
  write_register (IA64_BR0_REGNUM, bp_addr);
d3419 1
a3419 1
  write_register (sp_regnum, sp);
@


1.151
log
@	* libunwind-frame.h (struct regcache): Add forward declaration.
	(libunwind_get_reg_special): Add REGCACHE argument.
	* libunwind-frame.c (libunwind_get_reg_special): Add REGCACHE
	argument.  Pass it to unw_init_remote_p.

	* ia64-tdep.c (ia64_pseudo_register_read): Pass regcache to
	libunwind_get_reg_special.
	(ia64_access_reg): Remove "write" case.
	(ia64_access_fpreg): Likewise.  Read from next_frame passed
	as callback argument instead of from current_regcache.
	(ia64_access_rse_reg): Remove "write" case.  Read from regcache
	passed as callback argument instead of from current_regcache.
	(ia64_access_rse_fpreg): New function.
	(ia64_unw_rse_acce): Use it instead of ia64_access_fpreg.
@
text
@d2781 5
a2785 1
  ia64_libunwind_frame_prev_register
@


1.150
log
@	* gdbarch.sh (remote_translate_xfer_address): Remove.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arch-utils.c (generic_remote_translate_xfer_address): Remove.
	* arch-utils.h (generic_remote_translate_xfer_address): Remove.
	* remote.c (remote_write_bytes_aux, remote_read_bytes): Do not
	call gdbarch_remote_translate_xfer_address.
	* frv-tdep.c (frv_gdbarch_init): Do not call
	set_gdbarch_remote_translate_xfer_address.
	* ia64-tdep.c (ia64_remote_translate_xfer_address): Remove.
	(ia64_gdbarch_init): Do not install it.
@
text
@d695 1
a695 1
	  || libunwind_get_reg_special (gdbarch, regnum, buf) != 0)
d2221 4
a2224 1
  if (write)
d2226 28
a2253 9
      if (regnum < 0)
	/* ignore writes to pseudo-registers such as UNW_IA64_PROC_STARTI.  */
	return 0;
  
      switch (uw_regnum)
	{
	case UNW_REG_IP:
	  ia64_write_pc (*val, inferior_ptid);
	  break;
d2255 5
a2259 40
	case UNW_IA64_AR_BSPSTORE:
	  write_register (IA64_BSP_REGNUM, *val);
	  break;
	  
	case UNW_IA64_AR_BSP:
	case UNW_IA64_BSP:
	  /* Account for the fact that ptrace() expects bsp to point
	     after the current register frame.  */
	  cfm = read_register (IA64_CFM_REGNUM);
	  sof = (cfm & 0x7f);
	  bsp = ia64_rse_skip_regs (*val, sof);
	  write_register (IA64_BSP_REGNUM, bsp);
	  break;
	  
	case UNW_IA64_CFM:
	  /* If we change CFM, we need to adjust ptrace's notion of
	     bsp accordingly, so that the real bsp remains
	     unchanged.  */
	  bsp = read_register (IA64_BSP_REGNUM);
	  cfm = read_register (IA64_CFM_REGNUM);
	  old_sof = (cfm & 0x7f);
	  new_sof = (*val & 0x7f);
	  if (old_sof != new_sof)
	    {
	      bsp = ia64_rse_skip_regs (bsp, -old_sof + new_sof);
	      write_register (IA64_BSP_REGNUM, bsp);
	    }
	  write_register (IA64_CFM_REGNUM, *val);
	  break;
	  
	default:
	  write_register (regnum, *val);
	  break;
	}
      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, 
			    "  access_reg: to cache: %4s=0x%s\n",
			    (((unsigned) regnum <= IA64_NAT127_REGNUM)
			     ? ia64_register_names[regnum] : "r??"), 
			    paddr_nz (*val));
a2260 39
  else
    {
      switch (uw_regnum)
	{
	case UNW_REG_IP:
	  /* Libunwind expects to see the pc value which means the slot number
	     from the psr must be merged with the ip word address.  */
	  frame_unwind_register (next_frame, IA64_IP_REGNUM, buf);
	  ip = extract_unsigned_integer (buf, 8); 
	  frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
	  psr = extract_unsigned_integer (buf, 8); 
	  *val = ip | ((psr >> 41) & 0x3);
	  break;
	  
	case UNW_IA64_AR_BSP:
	  /* Libunwind expects to see the beginning of the current register
	     frame so we must account for the fact that ptrace() will return a value
	     for bsp that points *after* the current register frame.  */
	  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
	  bsp = extract_unsigned_integer (buf, 8);
	  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
	  cfm = extract_unsigned_integer (buf, 8); 
	  sof = (cfm & 0x7f);
	  *val = ia64_rse_skip_regs (bsp, -sof);
	  break;
	  
	case UNW_IA64_AR_BSPSTORE:
	  /* Libunwind wants bspstore to be after the current register frame.
	     This is what ptrace() and gdb treats as the regular bsp value.  */
	  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
	  *val = extract_unsigned_integer (buf, 8);
	  break;

	default:
	  /* For all other registers, just unwind the value directly.  */
	  frame_unwind_register (next_frame, regnum, buf);
	  *val = extract_unsigned_integer (buf, 8); 
	  break;
	}
d2262 6
a2267 7
      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, 
			    "  access_reg: from cache: %4s=0x%s\n",
			    (((unsigned) regnum <= IA64_NAT127_REGNUM)
			     ? ia64_register_names[regnum] : "r??"), 
			    paddr_nz (*val));
    }
d2277 1
d2279 5
a2283 4
  if (write)
    regcache_cooked_write (current_regcache, regnum, (char *) val);
  else
    regcache_cooked_read (current_regcache, regnum, (char *) val);
d2294 1
d2296 1
d2298 2
a2299 11
  if (write)
    {
      if (regnum < 0)
	/* ignore writes to pseudo-registers such as UNW_IA64_PROC_STARTI.  */
	return 0;
  
      switch (uw_regnum)
	{
	case UNW_REG_IP:
	  ia64_write_pc (*val, inferior_ptid);
	  break;
d2301 1
a2301 42
	case UNW_IA64_AR_BSPSTORE:
	  write_register (IA64_BSP_REGNUM, *val);
	  break;
	  
	case UNW_IA64_AR_BSP:
	case UNW_IA64_BSP:
	  /* Account for the fact that ptrace() expects bsp to point
	     after the current register frame.  */
	  cfm = read_register (IA64_CFM_REGNUM);
	  sof = (cfm & 0x7f);
	  bsp = ia64_rse_skip_regs (*val, sof);
	  write_register (IA64_BSP_REGNUM, bsp);
	  break;
	  
	case UNW_IA64_CFM:
	  /* If we change CFM, we need to adjust ptrace's notion of
	     bsp accordingly, so that the real bsp remains
	     unchanged.  */
	  bsp = read_register (IA64_BSP_REGNUM);
	  cfm = read_register (IA64_CFM_REGNUM);
	  old_sof = (cfm & 0x7f);
	  new_sof = (*val & 0x7f);
	  if (old_sof != new_sof)
	    {
	      bsp = ia64_rse_skip_regs (bsp, -old_sof + new_sof);
	      write_register (IA64_BSP_REGNUM, bsp);
	    }
	  write_register (IA64_CFM_REGNUM, *val);
	  break;
	  
	default:
	  write_register (regnum, *val);
	  break;
	}
      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, 
			    "  access_rse_reg: to cache: %4s=0x%s\n",
			    (((unsigned) regnum <= IA64_NAT127_REGNUM)
			     ? ia64_register_names[regnum] : "r??"), 
			    paddr_nz (*val));
    }
  else
d2303 9
a2311 9
      switch (uw_regnum)
	{
	case UNW_REG_IP:
	  /* Libunwind expects to see the pc value which means the slot number
	     from the psr must be merged with the ip word address.  */
	  ip = read_register (IA64_IP_REGNUM); 
	  psr = read_register (IA64_PSR_REGNUM);
	  *val = ip | ((psr >> 41) & 0x3);
	  break;
d2313 11
a2323 9
	case UNW_IA64_AR_BSP:
	  /* Libunwind expects to see the beginning of the current register
	     frame so we must account for the fact that ptrace() will return a value
	     for bsp that points *after* the current register frame.  */
	  bsp = read_register (IA64_BSP_REGNUM);
	  cfm = read_register (IA64_CFM_REGNUM);
	  sof = (cfm & 0x7f);
	  *val = ia64_rse_skip_regs (bsp, -sof);
	  break;
d2325 6
a2330 5
	case UNW_IA64_AR_BSPSTORE:
	  /* Libunwind wants bspstore to be after the current register frame.
	     This is what ptrace() and gdb treats as the regular bsp value.  */
	  *val = read_register (IA64_BSP_REGNUM);
	  break;
d2332 5
a2336 5
	default:
	  /* For all other registers, just read the value directly.  */
	  *val = read_register (regnum);
	  break;
	}
d2349 16
d2899 1
a2899 1
  ia64_access_fpreg,
@


1.149
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@a3548 10
static void
ia64_remote_translate_xfer_address (struct gdbarch *gdbarch,
				    struct regcache *regcache,
				    CORE_ADDR memaddr, int nr_bytes,
				    CORE_ADDR *targ_addr, int *targ_len)
{
  *targ_addr = memaddr;
  *targ_len  = nr_bytes;
}

a3649 3
  set_gdbarch_remote_translate_xfer_address (
    gdbarch, ia64_remote_translate_xfer_address);

@


1.148
log
@	* arch-utils.c (legacy_pc_in_sigtramp): Remove.
	* arch-utils.h (legacy_pc_in_sigtramp): Remove.

	* config/ia64/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/ia64/tm-linux.h: Remove file.
	* ia64-tdep.h (struct gdbarch_tdep): Add pc_in_sigtramp callback.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Use it instead of
	legacy_pc_in_sigtramp.
	(ia64_gdbarch_init): Initialize tdep->pc_in_sigtramp.
	* ia64-linux-tdep.c (ia64_linux_pc_in_sigtramp): Make static.
	Remove func_name argument.
	(ia64_linux_init_abi): Install it as tdep->pc_in_sigtramp.

	* infrun.c (HAVE_STEPPABLE_WATCHPOINT): Do not redefine.
	* target.c (update_current_target): Add to_have_steppable_watchpoint.
	* target.h (struct target_ops):  Add to_have_steppable_watchpoint.
	(HAVE_STEPPABLE_WATCHPOINT): Define.

	* config/ia64/linux.mh (NATDEPFILES): Remove core-aout.o.
	* config/ia64/nm-linux.h (KERNEL_U_ADDR, U_REGS_OFFSET,
	CANNOT_FETCH_REGISTER, CANNOT_STORE_REGISTER,
	TARGET_CAN_USE_HARDWARE_WATCHPOINT, HAVE_STEPPABLE_WATCHPOINT,
	STOPPED_BY_WATCHPOINT, target_stopped_data_address,
	target_insert_watchpoint, target_remove_watchpoint): Remove.
	(FETCH_INFERIOR_REGISTERS): Define.
	* ia64-linux-nat.c (ia64_register_addr): Make static.
	(ia64_cannot_fetch_register, ia64_cannot_store_register): Likewise.
	(ia64_linux_insert_watchpoint): Make static.  Remove ptid_p argument.
	(ia64_linux_remove_watchpoint): Likewise.  Add type argument.
	(ia64_linux_stopped_data_address): Make static.  Add target_ops.
	(ia64_linux_stopped_by_watchpoint): Make static.
	(ia64_linux_can_use_hw_breakpoint): New function.
	(ia64_linux_fetch_register, ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register, ia64_linux_store_registers): Likewise.
	(_initialize_ia64_linux_nat): Install register and watchpoint ops.
@
text
@d3543 1
a3543 1
      target_store_registers (IA64_FR8_REGNUM);
@


1.147
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d2081 4
a2084 2
  char *name;
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d2086 3
a2088 3
  find_pc_partial_function (pc, &name, NULL, NULL);
  if (legacy_pc_in_sigtramp (pc, name))
    return &ia64_sigtramp_frame_unwind;
d3581 1
@


1.146
log
@	* avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c, m68k-tdep.c, mips-linux-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c: Include "gdbtypes.h" instead of "floatformat.h".
	* Makefile.in (avr-tdep.o, hppabsd-tdep.o, hppa-tdep.o, i386-tdep.o)
	(ia64-tdep.o, m68k-tdep.o, mips-linux-tdep.o, ppcobsd-tdep.o)
	(sparc-linux-tdep.o): Update.
@
text
@d1558 1
a1558 1
  cache->pc = frame_func_unwind (next_frame);
@


1.145
log
@	* doublest.c (floatformat_from_length): Use the right element from
	gdbarch floatformats.
	(floatformat_from_type, extract_typed_floating)
	(store_typed_floating): Likewise.
	* doublest.h: Remove declarations for undefined floatformat arrays.
	* gdbarch.sh (float_format, double_format, long_double_format): Change
	to pairs.
	(pformat): Update for pairs.
	* gdbarch.c, gdbarch.h: Regenerated.
	* gdbtypes.c (floatformats_ieee_single, floatformats_ieee_double)
	(floatformats_ieee_double_littlebyte_bigword)
	(floatformats_i387_ext, floatformats_m68881_ext, floatformats_arm_ext)
	(floatformats_ia64_spill, floatformats_ia64_quad, floatformats_vax_f)
	(floatformats_vax_d): New variables.
	(builtin_type_ieee_single, builtin_type_ieee_double)
	(builtin_type_arm_ext, builtin_type_ia64_spill)
	(builtin_type_ia64_quad): Replace arrays with individual types.
	(builtin_type_ieee_single_big, builtin_type_ieee_single_little)
	(builtin_type_ieee_double_big, builtin_type_ieee_double_little)
	(builtin_type_ieee_double_littlebyte_bigword, builtin_type_i960_ext)
	(builtin_type_m88110_ext, builtin_type_m88110_harris_ext)
	(builtin_type_arm_ext_big, builtin_type_arm_ext_littlebyte_bigword)
	(builtin_type_ia64_spill_big, builtin_type_ia64_spill_little)
	(builtin_type_ia64_quad_big, builtin_type_ia64_quad_little): Delete
	unused and endian-specific types.
	(recursive_dump_type): Update for floatformat pairs.
	(build_flt): Move higher.  Handle bit == -1.  Take a floatformat pair.
	(build_gdbtypes): Use build_flt.
	(_initialize_gdbtypes): Update set of initialized types.
	* gdbtypes.h: Update declarations to match gdbtypes.c.
	(struct main_type): Store a pointer to two floatformats.
	* arch-utils.c (default_float_format, default_double_format): Delete.
	* arch-utils.h (default_float_format, default_double_format): Delete.

	* arm-tdep.c, avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c,  iq2000-tdep.c, m68k-tdep.c, m88k-tdep.c,
	mips-linux-tdep.c, mips-tdep.c, mt-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c, sparc-tdep.c, sparcnbsd-tdep.c, spu-tdep.c,
	vax-tdep.c, alpha-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d28 1
@


1.144
log
@	* gdbarch.sh (register_type): Update comment.
	* gdbarch.h: Regenerated.
	* arch-utils.c (generic_register_size): Call register_type.
	* ia64-tdep.c (ia64_extract_return_value): Likewise.
	* m32c-tdep.c (check_for_saved): Likewise.
	* mips-tdep.c (mips_print_register, print_gp_register_row)
	(mips_print_registers_info): Likewise.
	* sh-tdep.c (sh_pseudo_register_read, sh_pseudo_register_write):
	Likewise.
	* sh64-tdep.c (sh64_pseudo_register_read, sh64_pseudo_register_write)
	(sh64_do_register, sh64_print_register)
	(sh64_media_print_registers_info): Likewise.
	* tui/tui-regs.c (tui_register_format): Likewise.
@
text
@d339 6
d3583 1
a3583 1
  TYPE_FLOATFORMAT (builtin_type_ia64_ext) = &floatformat_ia64_ext;
d3593 1
a3593 1
  set_gdbarch_long_double_format (gdbarch, &floatformat_i387_ext);
@


1.143
log
@Copyright updates for 2007.
@
text
@d3037 2
a3038 1
      int reglen = TYPE_LENGTH (ia64_register_type (NULL, IA64_GR8_REGNUM));
@


1.142
log
@	* NEWS: Mention pointer to member improvements.
	* Makefile.in (gnu-v3-abi.o): Delete special rule.
	(eval.o, gnu-v3-abi.o, ia64-tdep.o): Update.
	* ada-valprint.c (ada_print_scalar): Update for new type codes.
	* c-typeprint.c (c_print_type): Update for new type codes.
	(c_type_print_varspec_prefix, c_type_print_varspec_suffix)
	(c_type_print_base): Likewise.
	(c_type_print_args): Rewrite.
	* c-valprint.c (c_val_print): Update for new type codes.  Remove
	support for references to members.  Treat methods like functions.
	* cp-abi.c (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New.
	* cp-abi.h (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New prototypes.
	(struct cp_abi_ops): Add corresponding members.
	* cp-valprint.c (cp_print_class_method): Delete.
	(cp_find_class_member): New function.
	(cp_print_class_member): Use it.  Simplify support for bogus
	member pointers.
	* dwarf2read.c (quirk_gcc_member_function_pointer): Use
	lookup_methodptr_type.
	(read_tag_ptr_to_member_type): Likewise, and lookup_memberptr_type.
	* eval.c (evaluate_subexp_standard): Implement EVAL_SKIP for
	OP_SCOPE.  Update call to value_aggregate_elt.  Rewrite member
	pointer support.
	(evaluate_subexp_for_address): Handle OP_SCOPE explicitly.  Handle
	references returned by user defined operators.
	* f-typeprint.c (f_print_type, f_type_print_varspec_prefix)
	(f_type_print_varspec_suffix): Remove support for member pointers.
	* gdbtypes.c (lookup_memberptr_type): Renamed from lookup_member_type
	and adjusted.
	(smash_to_memberptr_type): Likewise, from smash_to_member_type.
	(lookup_methodptr_type): New.
	(rank_one_type): Adjust for TYPE_CODE_MEMBERPTR.
	(recursive_dump_type): Update for new types.
	* gdbtypes.h (enum type_code): Replace TYPE_CODE_MEMBER with
	TYPE_CODE_MEMBERPTR and TYPE_CODE_METHODPTR.
	(lookup_memberptr_type, lookup_methodptr_type)
	(smash_to_memberptr_type): New prototypes.
	(smash_to_method_type): Formatting fix.
	(lookup_member_type, smash_to_member_type): Delete prototypes.
	* gnu-v3-abi.c (gnuv3_get_vtable, gnuv3_get_virtual_fn): New.
	Do not rely on debug information for the vptr or the method's
	enclosing type.  Handle function descriptors for IA64.
	(gnuv3_virtual_fn_field): Rewrite using the new functions.
	(gnuv3_find_method_in, gnuv3_print_method_ptr)
	(gnuv3_method_ptr_size, gnuv3_make_method_ptr)
	(gnuv3_method_ptr_to_value): New.
	(init_gnuv3_ops): Set new members of gnu_v3_abi_ops.
	* hpread.c (hpread_type_lookup): Update for new types.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-typeprint.c (m2_print_type): Remove explicit support
	for member pointers.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix)
	(pascal_type_print_varspec_suffix, pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_object_print_class_method, pascal_object_print_class_member):
	Delete.
	* p-lang.h (pascal_object_print_class_method)
	(pascal_object_print_class_member): Delete prototypes.
	* stabsread.c (read_type): Update for new types.
	* typeprint.c (print_type_scalar): Likewise.
	* valops.c (value_struct_elt_for_reference, value_namespace_elt)
	(value_maybe_namespace_elt, value_aggregate_elt): Add want_address
	argument.  Construct a pointer to member if the address of a
	function or data member is requested.
	(value_cast_pointers): Don't modify the input value.
	(value_cast): Adjust pointer to member handling for new types.
	Allow null pointer to member constants.  Don't modify the input
	value.
	(value_ind): Remove pointer to member check.  Handle function
	descriptors for function pointers.
	(value_struct_elt, value_find_oload_method_list, check_field):
	Remove pointer to member checks.
	* value.c (unpack_long): Allow pointers to data members.
	(value_from_longest): Allow member pointers.
	* value.h (value_aggregate_elt): Add want_address.
	* varobj.c (c_variable_editable): Remove check for members.
	* gdbarch.sh: Add vtable_function_descriptors and vbit_in_delta.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Handle descriptors
	in virtual tables.
	(ia64_gdbarch_init): Call set_gdbarch_vtable_function_descriptors.
	* c-lang.h (cp_print_class_method): Delete prototype.
	* arm-tdep.c (arm_gdbarch_init): Call set_gdbarch_vbit_in_delta.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	* gdbarch.c, gdbarch.h: Regenerated.

	* gdb.cp/classes.exp (test_pointers_to_class_members): Update expected
	output.  Test the types of members and member pointers.
	* gdb.cp/inherit.exp (test_print_mi_member_types): Remove KFAILs for
	gdb/2092.
	* gdb.cp/member-ptr.exp: Search for a comment instead of a
	statement.  Enable for GCC.  Update expected output for some tests
	and add new tests.  Remove obsolete GCC KFAILs.  Allow GCC's class
	layout.
	* gdb.cp/member-ptr.cc (Padding, Padding::vspacer, Base, Base::get_x)
	(Base::vget_base, Left, Left::vget, Right, Right::vget, Diamond)
	(Diamond::vget_base): New.
	(main): Add new tests.
	* gdb.cp/printmethod.exp: Update expected output for member functions.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Add a KFAIL for
	print pEe->D::vg().
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
@


1.141
log
@	* ia64-tdep.c (get_kernel_table): Correct signedness in check
	for a negative return value.
@
text
@d43 1
d3310 11
d3655 4
@


1.140
log
@	* target.c (target_read): Stop if target_read_partial returns 0
	when some bytes have already been read.
	(target_write): Likewise for target_write_partial.
	(target_read_partial, target_write_partial): Make static.
	(target_read_alloc): New.
	* target.h: Doc fixes.
	(target_read_partial, target_write_partial): Delete prototypes.
	(target_read_alloc): New prototype.

	* auxv.c (target_auxv_read): Delete.
	(target_auxv_search, fprint_target_auxv): Use target_read_alloc.
	* auxv.h (target_auxv_read): Delete prototype.
	* avr-tdep.c (avr_io_reg_read_command): Use target_read_alloc.
	* ia64-tdep.c (getunwind_table, get_kernel_table): Likewise.
	* linux-nat.c (linux_nat_make_corefile_notes): Likewise.
	* procfs.c (procfs_make_note_section): Likewise.
	* remote.c (remote_xfer_partial): Don't loop here.
	* sparc-tdep.c (sparc_fetch_wcookie): Use target_read.
@
text
@d2489 1
a2489 1
      size_t size;
d2491 2
a2492 2
      ktab_size = getunwind_table (&ktab_buf);
      if (ktab_size <= 0)
d2494 3
a2496 2
      else
	ktab = (struct ia64_table_entry *) ktab_buf;
@


1.139
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@d3 2
a4 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software
   Foundation, Inc.
d2461 2
a2462 2
static int
getunwind_table (void *buf, size_t len)
a2472 2
  x = target_read_partial (&current_target, TARGET_OBJECT_UNWIND_TABLE, NULL,
			   buf, 0, len);
d2474 4
a2477 1
  return (int)x;
d2488 1
d2490 7
a2496 7
      size = getunwind_table (NULL, 0);
      if ((int)size < 0)
        return -UNW_ENOINFO;
      ktab_size = size;
      ktab = xmalloc (ktab_size);
      getunwind_table (ktab, ktab_size);
		          
@


1.139.6.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d3 2
a4 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
   Free Software Foundation, Inc.
d2461 2
a2462 2
static LONGEST
getunwind_table (gdb_byte **buf_p)
d2473 2
d2476 1
a2476 4
  x = target_read_alloc (&current_target, TARGET_OBJECT_UNWIND_TABLE,
			 NULL, buf_p);

  return x;
a2486 1
      gdb_byte *ktab_buf;
d2488 7
a2494 7

      ktab_size = getunwind_table (&ktab_buf);
      if (ktab_size <= 0)
	return -UNW_ENOINFO;
      else
	ktab = (struct ia64_table_entry *) ktab_buf;

@


1.138
log
@	* ia64-tdep.c (ia64_libunwind_frame_this_id): Adapt uses of
	libunwind_frame_prev_register to use a gdb_byte buffer and
	extract_unsigned_integer.
	(ia64_libunwind_sigtramp_frame_prev_register): Likewise.

	* libunwind-frame.c (libunwind_frame_prev_register): Change type
	of last argument to `gdb_byte *'
	* libunwind-frame.h: Adjust declaration.
@
text
@d553 1
a553 1
ia64_memory_insert_breakpoint (CORE_ADDR addr, bfd_byte *contents_cache)
d555 1
d578 2
a579 1
  memcpy(contents_cache, &instr, sizeof(instr));
d588 1
a588 1
ia64_memory_remove_breakpoint (CORE_ADDR addr, bfd_byte *contents_cache)
d590 1
d609 1
a609 1
  memcpy (&instr, contents_cache, sizeof instr);
@


1.137
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d2735 2
a2736 1
		  		 &optimized, &lval, &addr, &realnum, &prev_ip);
d2896 1
d2905 2
a2906 1
		  		 &optimized, &lval, &addr, &realnum, &prev_ip);
@


1.137.2.1
log
@Merge XML and VFP support to this branch.
@
text
@d2458 2
a2459 2
static LONGEST
getunwind_table (gdb_byte **buf_p)
d2470 2
d2473 1
a2473 4
  x = target_read_whole (&current_target, TARGET_OBJECT_UNWIND_TABLE,
			 NULL, buf_p);

  return x;
a2483 1
      gdb_byte *ktab_buf;
d2485 7
a2491 7

      ktab_size = getunwind_table (&ktab_buf);
      if (ktab_size <= 0)
	return -UNW_ENOINFO;
      else
	ktab = (struct ia64_table_entry *) ktab_buf;

@


1.137.2.1.2.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d553 1
a553 1
ia64_memory_insert_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d577 1
a577 1
  memcpy (bpt->shadow_contents, &instr, sizeof (instr));
d586 1
a586 1
ia64_memory_remove_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d606 1
a606 1
  memcpy (&instr, bpt->shadow_contents, sizeof instr);
@


1.137.4.1
log
@Initial version of available features support.
@
text
@d2458 2
a2459 2
static LONGEST
getunwind_table (gdb_byte **buf_p)
d2470 2
d2473 1
a2473 4
  x = target_read_whole (&current_target, TARGET_OBJECT_UNWIND_TABLE,
			 NULL, buf_p);

  return x;
a2483 1
      gdb_byte *ktab_buf;
d2485 7
a2491 7

      ktab_size = getunwind_table (&ktab_buf);
      if (ktab_size <= 0)
	return -UNW_ENOINFO;
      else
	ktab = (struct ia64_table_entry *) ktab_buf;

@


1.136
log
@	* ia64-tdep.c (floatformat_valid): Change type of `from' from
	`const char *' to `const void *'.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.135
log
@	* Makefile.in (ALLDEPFILES): Update.
	(alpha-linux-nat.o, sparc-linux-nat.o): New rules.
	(amd64-linux-nat.o, arm-linux-nat.o, hppa-linux-nat.o)
	(i386-linux-nat.o, ia64-linux-nat.o, linux-nat.o, m32r-linux-nat.o)
	(m68klinux-nat.o, mips-linux-nat.o, ppc-linux-nat.o, s390-nat.o)
	(sparc64-linux-nat.o): Update dependencies.
	* alpha-linux-nat.c, sparc-linux-nat.c: New files.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(amd64_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(amd64_linux_child_post_start_inferior): Renamed from
	child_post_startup_inferior and made static.  Call
	super_post_startup_inferior.
	(super_post_startup_inferior): New.
	(_initialize_amd64_linux_nat): Set it.  Call linux_target and
	add_target.
	* arm-linux-nat.c (arm_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(arm_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_arm_linux_nat): Add a prototype.  Use linux_target and
	add_target.
	* hppa-linux-nat.c (hppa_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(hppa_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_hppa_linux_nat): New function.
	* i386-linux-nat.c (i386_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(i386_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(i386_linux_resume): Renamed from child_resume and made static.
	(i386_linux_child_post_start_inferior): Renamed from
	child_post_startup_inferior and made static.  Call
	super_post_startup_inferior.
	(super_post_startup_inferior): New.
	(_initialize_i386_linux_nat): New function.
	* i386-nat.c: Remove LINUX_CHILD_POST_STARTUP_INFERIOR #ifndef.
	* ia64-linux-nat.c (ia64_linux_xfer_unwind_table): Remove.
	(super_xfer_partial): New.
	(ia64_linux_xfer_partial): New function.  Use it.
	(_initialize_ia64_linux_nat): New function.
	* ia64-tdep.c (getunwind_table): Revert 2005-06-08 change; use
	target_read_partial and document the problem.
	* inf-ptrace.c (inf_ptrace_fetch_register): Use
	CANNOT_FETCH_REGISTER.  Fix some comments.
	(inf_ptrace_store_register): Use CANNOT_STORE_REGISTER.  Fix some
	comments.
	* linux-nat.c: Include "inf-ptrace.h" and "auxv.h".
	(linux_ops, super_xfer_partial): New variables.
	(linux_child_post_startup_inferior): Make static.
	(child_post_startup_inferior): Delete.
	(linux_nat_attach, linux_nat_detach, resume_callback)
	(linux_nat_resume, linux_nat_wait, linux_nat_create_inferior)
	(linux_nat_mourn_inferior): Use linux_ops instead of
	deprecated_child_ops.
	(child_wait): Do not depend on CHILD_WAIT.
	(linux_nat_xfer_memory): Remove, replace by ...
	(linux_nat_xfer_partial): ... this.  Use linux_ops->to_xfer_partial
	instead of linux_proc_xfer_memory and child_xfer_memory.
	(linux_nat_fetch_registers, linux_nat_store_registers)
	(linux_nat_child_post_startup_inferior): New functions.
	(init_linux_nat_ops): Use the new functions.
	(linux_proc_xfer_memory): Remove, replace by ...
	(linux_proc_xfer_partial): ... this.  Make static.
	(linux_xfer_partial, linux_register_u_offset, linux_target): New
	functions.
	(_initialize_linux_nat): Do not modify deprecated_child_ops.
	* linux-nat.h (linux_proc_xfer_memory): Remove prototype.
	(struct mem_attrib, struct target_ops): Remove forward declarations.
	(linux_child_post_startup_inferior): Remove prototype.
	(linux_target): Add prototype.
	* linux-thread-db.c (thread_db_xfer_memory): Remove, replace by ...
	(thread_db_xfer_partial): ... this.
	(init_thread_db_ops): Set to_xfer_partial instead of
	deprecated_xfer_memory.
	* m32r-linux-nat.c (m32r_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(m32r_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_m32r_linux_nat): New function.
	* m68klinux-nat.c (m68k_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(m68k_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(old_fetch_inferior_registers, old_store_inferior_registers): Made
	static.
	(_initialize_m68k_linux_nat): Use linux_target and add_target.
	* mips-linux-nat.c (_initialize_mips_linux_nat): New function.
	* ppc-linux-nat.c (ppc_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(ppc_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_ppc_linux_nat): New function.
	* s390-nat.c (s390_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(s390_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_s390_nat): New function.
	* sparc64-linux-nat.c (_initialize_sparc64_linux_nat): Use
	linux_target and add_target.
	* config/nm-linux.h: Don't include "auxv.h".
	(struct target_waitstatus, child_wait, CHILD_WAIT)
	(CHILD_PID_TO_EXEC_FILE, CHILD_INSERT_FORK_CATCHPOINT)
	(CHILD_INSERT_VFORK_CATCHPOINT, CHILD_INSERT_EXEC_CATCHPOINT)
	(CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH, CHILD_FOLLOW_FORK)
	(DEPRECATED_KILL_INFERIOR, NATIVE_XFER_AUXV): Delete.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Replace infptrace.o
	and inftarg.o with inf-ptrace.o and alpha-linux-nat.o.
	* config/sparc/linux.mh (NATDEPFILES): Replace infptrace.o and
	inftarg.o with sparc-linux-nat.o.
	* config/sparc/linux64.mh (NATDEPFILES): Remove infptrace.o and
	inftarg.o.
	* config/arm/linux.mh (NATDEPFILES): Replace infptrace.o and
	inftarg.o with inf-ptrace.o.
	* config/i386/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux64.mh (NATDEPFILES): Likewise.
	* config/ia64/linux.mh (NATDEPFILES): Likewise.
	* config/m32r/linux.mh (NATDEPFILES): Likewise.
	* config/m68k/linux.mh (NATDEPFILES): Likewise.
	* config/mips/linux.mh (NATDEPFILES): Likewise.
	* config/pa/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Likewise.
	* config/s390/s390.mh (NATDEPFILES): Likewise.
	* config/i386/nm-linux.h (DEPRECATED_CHILD_RESUME): Don't define.
	(LINUX_CHILD_POST_STARTUP_INFERIOR): Don't define.
	* config/i386/nm-linux64.h (LINUX_CHILD_POST_STARTUP_INFERIOR):
	Don't define.
	* config/ia64/nm-linux.h: Don't include "target.h".
	(NATIVE_XFER_UNWIND_TABLE, ia64_linux_xfer_unwind_table): Remove.
	* config/djgpp/fnchange.lst: Add alpha-linux-tdep.c,
	alpha-linux-nat.c, sparc-linux-tdep.c, and sparc-linux-nat.c.
@
text
@d327 1
a327 1
floatformat_valid (const struct floatformat *fmt, const char *from)
@


1.134
log
@
2005-06-09  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c (ia64_pseudo_register_read): Use gdb_byte and
        protect libunwind references with HAVE_LIBUNWIND_IA64_H flag.
        * (ia64_pseudo_register_write): Use gdb_byte to remove warning.
        * (ia64_register_to_value, ia64_value_to_register): Ditto.
        * (ia64_frame_prev_register): Ditto.
        * (ia64_libunwind_frame_prev_register): Ditto.
        * (ia64_sigtramp_frame_prev_register): Ditto.
        * (ia64_libunwind_sigtramp_frame_prev_register): Ditto.
        * (ia64_store_return_value): Ditto.

2
@
text
@d2463 9
a2471 7
  /* FIXME: This is a temporary solution to backtracing syscalls in corefiles.
            To do this properly, the AUXV section should be used.  This
	    fix will work as long as the kernel used to generate the corefile
	    is equivalent to the kernel used to debug the corefile.  */
  x = ia64_linux_xfer_unwind_table (&current_target, 
		  		    TARGET_OBJECT_UNWIND_TABLE, NULL,
			   	    buf, NULL, 0, len);
d2475 1
a2475 1
	
@


1.133
log
@
2005-06-08  Jeff Johnston  <jjohnstn@@redhat.com>
            David Mosberger <davidm@@hpl.hp.com>

        * ia64-tdep.c (KERNEL_START): New macro.
        (ia64_pseudo_register_read): Fix code to use libunwind to properly
        get the rse registers.
        (ia64_frame_this_id): Mark outermost frame with null frame id.
        (ia64_sigtramp_frame_prev_register): Fix up debug output.
        (ia64_access_rse_reg): New accessor function.
        (ia64_access_mem): Add special logic for accessing the
        kernel's unwind table.
        (getunwind_table): Fix for corefiles.
        (get_kernel_table): Fix to handle vDSO.
        (ia64_libunwind_frame_this_id): Check for null frame id and
        don't unwind past pc value of 0.  Fix debugging output.
        (ia64_libunwind_sigtramp_frame_this_id): New function.
        (ia64_libunwind_sigtramp_frame_prev_register): Ditto.
        (ia64_libunwind_sigtramp_frame_sniffer): Ditto.
        (ia64_libunwind_sigtramp_frame_unwind): New unwinder.
        (ia64_unw_rse_accessors): New libunwind accessors.
        (ia64_libunwind_descr): Add ia64_unw_rse_accessors.
        (ia64_gdbarch_init)[HAVE_LIBUNWIND_IA64_H]: Use
        ia64_libunwind_sigtramp_frame_sniffer instead of
        ia64_sigtramp_frame_sniffer.
        * libunwind-frame.c (libunwind_frame_set_descr): Add
        special register accessors.
        (libunwind_frame_cache): Add special logic to check for
        0 pc value.  Check for a signal trampoline frame.
        (libunwind_frame_this_id): Check if libunwind_frame_cache
        returns NULL.
        (libunwind_frame_prev_register): Check for NULL cache.
        (libunwind_frame_base_address): Ditto.
        (libunwind_sigtramp_frame_sniffer): New function.
        (libunwind_get_reg_special): Ditto.
        (libunwind_load): Add unw_is_signal_frame support.
        * libunwind-frame.h (struct libunwind_descr): Add special_accessors
        field.
        (libunwind_sigtramp_frame_sniffer): New prototype.
        (libunwind_get_reg_special): Ditto.
@
text
@d676 1
a676 1
                           int regnum, void *buf)
d680 1
d685 1
d796 1
a796 1
			    int regnum, const void *buf)
d917 1
a917 1
                         struct type *valtype, void *out)
d926 1
a926 1
                         struct type *valtype, const void *in)
d1581 1
a1581 1
			  int *realnump, void *valuep)
d1981 1
a1981 1
				   int *realnump, void *valuep)
d2752 1
a2752 1
				    int *realnump, void *valuep)
d2890 1
a2890 1
					     int *realnump, void *valuep)
d3502 2
a3503 1
ia64_store_return_value (struct type *type, struct regcache *regcache, const void *valbuf)
@


1.132
log
@2005-05-19  Andrew Cagney  <cagney@@gnu.org>

	* regcache.h (regcache_raw_read, regcache_raw_write)
	(regcache_raw_read_part, regcache_raw_write_part)
	(regcache_cooked_read_part, regcache_cooked_write_part)
	(regcache_cooked_read, regcache_cooked_write)
	(regcache_raw_supply, regcache_raw_collect)
	(regcache_cooked_read_ftype, regcache_save, regcache_restore)
	(deprecated_read_register_gen, deprecated_write_register_gen)
	(deprecated_read_register_bytes, deprecated_write_register_bytes)
	(deprecated_grub_regcache_for_registers): Use gdb_byte for byte
	buffer parameters.
	* ia64-tdep.c (ia64_extract_return_value): Update.
	* frame.c (do_frame_register_read): Update.
	* regcache.c (deprecated_grub_regcache_for_registers)
	(struct regcache, regcache_save, regcache_restore, regcache_cpy)
	(do_cooked_read, regcache_xmalloc, register_buffer)
	(deprecated_read_register_bytes, regcache_raw_read)
	(regcache_raw_read_signed, regcache_raw_read_unsigned)
	(deprecated_read_register_gen, regcache_cooked_read)
	(regcache_cooked_read_signed, regcache_cooked_read_unsigned)
	(deprecated_write_register_gen, regcache_cooked_write)
	(deprecated_write_register_bytes, regcache_raw_read_part)
	(regcache_raw_write_part, regcache_cooked_read_part)
	(regcache_cooked_write_part, read_register, regcache_raw_supply):
@
text
@d48 28
d680 26
a705 15
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get start of register frame.  */
      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	{
	  ULONGEST reg_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
	  reg = read_memory_integer ((CORE_ADDR)reg_addr, 8);
	  store_unsigned_integer (buf, register_size (current_gdbarch, regnum), reg);
a706 2
      else
	store_unsigned_integer (buf, register_size (current_gdbarch, regnum), 0);
d1562 1
a1562 1
  /* This marks the outermost frame.  */
d1564 3
a1566 3
    return;

  (*this_id) = frame_id_build_special (cache->base, cache->pc, cache->bsp);
d2048 7
a2054 2
			(((unsigned) regnum <= IA64_NAT127_REGNUM)
			 ? ia64_register_names[regnum] : "r??"), 
d2323 107
d2436 12
d2460 8
a2467 2
  x = target_read_partial (&current_target, TARGET_OBJECT_UNWIND_TABLE, NULL,
			   buf, 0, len);
d2476 1
a2476 8
  size_t size;
  struct ia64_table_entry
  {
    uint64_t start_offset;
    uint64_t end_offset;
    uint64_t info_offset;
  };
  static struct ia64_table_entry *ktab = NULL, *etab;
d2478 1
a2478 1
  if (!ktab)
d2480 1
d2483 5
a2487 6
	return -UNW_ENOINFO;
      ktab = xmalloc (size);
      getunwind_table (ktab, size);
  
      /* Determine length of kernel's unwind table and relocate
	 it's entries.  */
d2489 1
a2489 1
	etab->info_offset += (uint64_t) ktab;
d2552 1
a2552 5
  if (!p_text || !p_unwind
      /* Verify that the segment that contains the IP also contains
	 the static unwind table.  If not, we are dealing with
	 runtime-generated code, for which we have no info here.  */
      || (p_unwind->p_vaddr - p_text->p_vaddr) >= p_text->p_memsz)
d2555 5
d2562 19
a2580 1
  dip->start_ip = segbase;
d2710 4
d2716 5
d2722 2
a2723 1
  /* We must add the bsp as the special address for frame comparison purposes.  */
d2727 10
a2736 1
  (*this_id) = frame_id_build_special (id.stack_addr, id.code_addr, bsp);
d2826 7
a2832 2
			(((unsigned) regnum <= IA64_NAT127_REGNUM)
			 ? ia64_register_names[regnum] : "r??"), 
d2852 80
d2945 16
d2968 1
a3609 1
  frame_unwind_append_sniffer (gdbarch, ia64_sigtramp_frame_sniffer);
d3611 1
d3614 2
@


1.131
log
@2005-05-01  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_extract_return_value)
	(breakpoint_from_pc, deprecated_store_return_value)
	(memory_insert_breakpoint, memory_remove_breakpoint): Change type
	of buffer to a bfd_byte pointer.
	* gdbarch.h, gdbarch.c: Re-generate.
	* mem-break.c (memory_insert_breakpoint)
	(memory_remove_breakpoint, default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Update.
	* target.h (memory_insert_breakpoint)
	(memory_remove_breakpoint, default_memory_insert_breakpoint)
	(default_memory_remove_breakpoint): Update declarations.
	(struct target_ops): Update to_insert_breakpoint and
	to_remove_breakpoint.
	* target.c (debug_to_remove_breakpoint)
	(debug_to_insert_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_remove_breakpoint)
	(m32r_insert_breakpoint): Update.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Update.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Update.
	* remote-rdi.c (arm_rdi_insert_breakpoint)
	(arm_rdi_remove_breakpoint): Update.
	* remote-sim.c (gdbsim_insert_breakpoint)
	(gdbsim_remove_breakpoint): Update.
	* exec.c (ignore): Update.
	* rs6000-tdep.c (rs6000_extract_return_value): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Update.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Update.
@
text
@a90 1
static gdbarch_extract_return_value_ftype ia64_extract_return_value;
d2696 2
a2697 1
ia64_extract_return_value (struct type *type, struct regcache *regcache, void *valbuf)
@


1.130
log
@2005-04-18  Michael Snyder  <msnyder@@redhat.com>

	* ia64-tdep.c (ia64_get_dyn_info_list): Fix indent.
@
text
@d526 1
a526 1
ia64_memory_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
d559 1
a559 1
ia64_memory_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
@


1.129
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d2527 1
a2527 1
		      struct frame_id *this_id)
@


1.128
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d477 2
a478 2
      warning ("Can't fetch instructions for slot numbers greater than 2.\n"
	       "Using slot 0 instead");
d535 1
a535 1
    error("Can't insert breakpoint for slot numbers greater than 2.");
d1553 1
a1553 1
    error ("No registers.");
d1954 1
a1954 1
    error ("No registers.");
d2747 1
a2747 1
  error ("ia64_extract_struct_value_address called and cannot get struct value address");
@


1.127
log
@	* ia64-tdep.c: Include "osabi.h".
	(native_find_global_pointer): Delete.
	(ia64_find_global_pointer): Renamed from
	generic_elf_find_global_pointer.
	(FIND_GLOBAL_POINTER): Delete.  Change all users to call
	ia64_find_global_pointer instead.
	(ia64_gdbarch_init): Call gdbarch_init_osabi.  Remove references
	to ia64_linux_sigcontext_register_address and
	ia64_linux_write_pc.  Don't set tdep->find_global_pointer.
	(_initialize_ia64_tdep): Call gdbarch_register instead of
	deprecated register_gdbarch_init.
	(struct gdbarch_tdep): Remove find_global_pointer field and move
	to ...
	* ia64-tdep.h (struct gdbarch_tdep): ... here.
	(ia64_linux_sigcontext_register_address): Remove declaration.
	(ia64_linux_getunwind_table): Likewise.
	(ia64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c: Include "osabi.h".
	(ia64_linux_sigcontext_register_address): Make static.
	(ia64_linux_write_pc): Likewise.
	(ia64_linux_init_abi): New.
	(_initialize_ia64_linux_tdep): New.
	* Makefile.in (ia64-tdep.o, ia64-linux-tdep.o): Depend on
	$(osabi_h).
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software
d3092 1
a3092 1
				  find_func_descr (extract_unsigned_integer (VALUE_CONTENTS (arg), 8),
d3114 1
a3114 1
	  memcpy (val_buf, VALUE_CONTENTS (arg) + argoffset, (len > 8) ? 8 : len);
d3135 1
a3135 1
	      convert_typed_floating (VALUE_CONTENTS (arg) + argoffset, float_elt_type,
@


1.126
log
@Eliminate ia64-aix-tdep.c.
@
text
@d41 1
a49 11
/* Hook for determining the global pointer when calling functions in
   the inferior under AIX.  The initialization code in ia64-aix-nat.c
   sets this hook to the address of a function which will find the
   global pointer for a given address.  
   
   The generic code which uses the dynamic section in the inferior for
   finding the global pointer is not of much use on AIX since the
   values obtained from the inferior have not been relocated.  */

CORE_ADDR (*native_find_global_pointer) (CORE_ADDR) = 0;

d93 1
a249 9
struct gdbarch_tdep
  {
    CORE_ADDR (*sigcontext_register_address) (CORE_ADDR, int);
    			/* OS specific function which, given a frame address
			   and register number, returns the offset to the
			   given register from the start of the frame. */
    CORE_ADDR (*find_global_pointer) (CORE_ADDR);
  };

a251 2
#define FIND_GLOBAL_POINTER \
  (gdbarch_tdep (current_gdbarch)->find_global_pointer)
d2404 1
a2404 1
  dip->gp = FIND_GLOBAL_POINTER (ip);
d2846 1
a2846 1
generic_elf_find_global_pointer (CORE_ADDR faddr)
d2967 1
a2967 1
      global_pointer = FIND_GLOBAL_POINTER (faddr);
d3151 1
a3151 1
  global_pointer = FIND_GLOBAL_POINTER (func_addr);
d3244 1
a3244 23
  /* Set the method of obtaining the sigcontext addresses at which
     registers are saved.  The method of checking to see if
     native_find_global_pointer is nonzero to indicate that we're
     on AIX is kind of hokey, but I can't think of a better way
     to do it.  */
  if (info.osabi == GDB_OSABI_LINUX)
    tdep->sigcontext_register_address = ia64_linux_sigcontext_register_address;
  else
    tdep->sigcontext_register_address = 0;

  /* We know that GNU/Linux won't have to resort to the
     native_find_global_pointer hackery.  But that's the only one we
     know about so far, so if native_find_global_pointer is set to
     something non-zero, then use it.  Otherwise fall back to using
     generic_elf_find_global_pointer.  This arrangement should (in
     theory) allow us to cross debug GNU/Linux binaries from an AIX
     machine.  */
  if (info.osabi == GDB_OSABI_LINUX)
    tdep->find_global_pointer = generic_elf_find_global_pointer;
  else if (native_find_global_pointer != 0)
    tdep->find_global_pointer = native_find_global_pointer;
  else
    tdep->find_global_pointer = generic_elf_find_global_pointer;
d3302 1
a3302 4
  if (info.osabi == GDB_OSABI_LINUX)
    set_gdbarch_write_pc (gdbarch, ia64_linux_write_pc);
  else
    set_gdbarch_write_pc (gdbarch, ia64_write_pc);
d3327 3
d3338 1
a3338 1
  register_gdbarch_init (bfd_arch_ia64, ia64_gdbarch_init);
@


1.125
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* sparc-tdep.c: Replace VALUE_TYPE with value_type.
	* v850-tdep.c, sparc64-tdep.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, s390-tdep.c, mcore-tdep.c: Ditto.
	* h8300-tdep.c, arm-linux-tdep.c, amd64-tdep.c: Ditto.
	* hppa-tdep.c, mips-tdep.c, m88k-tdep.c: Ditto.
	* m68hc11-tdep.c, m32r-tdep.c, ia64-tdep.c: Ditto.
	* frv-tdep.c, cris-tdep.c, avr-tdep.c, alpha-tdep.c: Ditto.
@
text
@a3270 2
  else if (native_find_global_pointer != 0)
    tdep->sigcontext_register_address = ia64_aix_sigcontext_register_address;
@


1.124
log
@2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_USE_STRUCT_CONVENTION): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* values.c (using_struct_return): Update call.
	* mcore-tdep.c: Update comment.
	* infcall.c (call_function_by_hand): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* arch-utils.h (always_use_struct_convention): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	USE_STRUCT_CONVENTION.
@
text
@d3046 1
a3046 1
      type = check_typedef (VALUE_TYPE (arg));
d3101 1
a3101 1
      type = check_typedef (VALUE_TYPE (arg));
@


1.123
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@a101 1
static gdbarch_use_struct_convention_ftype ia64_use_struct_convention;
d3336 1
a3336 1
  set_gdbarch_use_struct_convention (gdbarch, ia64_use_struct_convention);
@


1.122
log
@	* alpha-tdep.c (alpha_gdbarch_init): Use LL suffix for large
	constants.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* ia64-tdep.c (examine_prologue): Likewise.
	* ns32k-tdep.c (ns32k_fix_call_dummy): Remove unused function.
	* v850-tdep.c (v850_fix_call_dummy): Likewise.
@
text
@d40 1
d3027 1
a3027 1
ia64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr, 
d3039 1
@


1.121
log
@2004-04-30  Andrew Cagney  <cagney@@redhat.com>

	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Call legacy_pc_in_sigtramp.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Ditto.
@
text
@d1119 1
a1119 1
      if (it == B && ((instr & 0x1e1f800003f) != 0x04000000000))
d1231 1
a1231 1
              if ((instr & 0x1efc0000000) == 0x0eec0000000)
@


1.120
log
@	* ia64-tdep.c (ia64_libunwind_frame_prev_register): Handle null
	value buffer.
	* libunwind-frame.c (libunwind_frame_prev_register): Likewise.
@
text
@d2051 1
a2051 1
  if (DEPRECATED_PC_IN_SIGTRAMP (pc, name))
@


1.119
log
@Fix cross build problems for --target=ia64-linux-gnu.
@
text
@d2586 4
@


1.118
log
@2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PC_IN_SIGTRAMP): Change to a function with
	predicate, deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-linux-tdep.c (alpha_linux_init_abi): Update.
	* alpha-osf1-tdep.c (alpha_osf1_init_abi): Update.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Update.
	* alphafbsd-tdep.c (alphafbsd_init_abi): Update.
	* alphanbsd-tdep.c (alphanbsd_init_abi): Update.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Update.
	* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Update.
	* amd64nbsd-tdep.c (amd64nbsd_init_abi): Update.
	* amd64obsd-tdep.c (amd64obsd_init_abi): Update.
	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Update.
	* blockframe.c (find_pc_partial_function): Update.
	* breakpoint.c (bpstat_what): Update.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update.
	* frv-linux-tdep.c (frv_linux_init_abi): Update.
	* frv-tdep.c (frv_sigtramp_frame_sniffer): Update.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* i386-nto-tdep.c (i386nto_init_abi): Update.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Update.
	* i386-tdep.c (i386_sigtramp_frame_sniffer)
	(i386_svr4_init_abi, i386_go32_init_abi, i386_gdbarch_init): Update.
	* i386bsd-tdep.c (i386bsd_init_abi): Update.
	* i386nbsd-tdep.c (i386nbsd_init_abi): Update.
	* i386obsd-tdep.c (i386obsd_init_abi): Update.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Update.
	* infrun.c (pc_in_sigtramp): Update.
	* m68k-tdep.c (m68k_sigtramp_frame_sniffer): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mipsnbsd-tdep.c (mipsnbsd_init_abi): Update.
	* ppc-linux-tdep.c: Update comment.
	* ppcnbsd-tdep.c (ppcnbsd_init_abi): Update.
	* shnbsd-tdep.c (shnbsd_init_abi): Update.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Update.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Update.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Update.
	* sparcobsd-tdep.c (sparc32obsd_init_abi): Update.

Index: doc/ChangeLog
2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	references to PC_IN_SIGTRAMP.
@
text
@a38 1
#include "elf.h"                /* for PT_IA64_UNWIND value */
d43 1
@


1.117
log
@2004-02-23  David Mosberger  <davidm@@hpl.hp.com>

	Committed by Kevin Buettner <kevinb@@redhat.com>.

	* ia64-tdep.h (ia64_write_pc, ia64_linux_write_pc): Declare.
	* ia64-tdep.c (ia64_write_pc): Make it a global function.
	(ia64_gdbarch_init): For Linux targets, use ia64_linux_write_pc()
	instead of ia64_write_pc().
	* ia64-linux-tdep.c (regcache.h): Include.
	(ia64_linux_write_pc): New function.
@
text
@d2051 1
a2051 1
  if (PC_IN_SIGTRAMP (pc, name))
@


1.116
log
@2004-02-17  David Mosberger  <davidm@@hpl.hp.com>

	Committed by Andrew Cagney.
	* Makefile.in (ia64_tdep_h): New macro.
	(ia64-linux-tdep.o): Mention $(ia64_tdep_h).
	(ia64-tdep.o): Likewise.
	* ia64-tdep.h: New file.
	* ia64-tdep.c: Update copyright notice.  Include "ia64-tdep.h".
	(ia64_linux_sigcontext_register_address): Move decl to ia64-tdep.h.
	(ia64_aix_sigcontext_register_address): Likewise.
	(ia64_linux_getunwind_table): Delete declaration.
	* ia64-linux-tdep.c: Likewise.
@
text
@d631 1
a631 1
static void
d3341 4
a3344 1
  set_gdbarch_write_pc (gdbarch, ia64_write_pc);
@


1.116.2.1
log
@Merge mainline to intercu branch.
@
text
@d631 1
a631 1
void
d2051 1
a2051 1
  if (DEPRECATED_PC_IN_SIGTRAMP (pc, name))
d3341 1
a3341 4
  if (info.osabi == GDB_OSABI_LINUX)
    set_gdbarch_write_pc (gdbarch, ia64_linux_write_pc);
  else
    set_gdbarch_write_pc (gdbarch, ia64_write_pc);
@


1.116.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d39 1
a40 1
#include "infcall.h"
a43 1
#include "elf/ia64.h"           /* for PT_IA_64_UNWIND value */
d101 1
d1119 1
a1119 1
      if (it == B && ((instr & 0x1e1f800003fLL) != 0x04000000000LL))
d1231 1
a1231 1
              if ((instr & 0x1efc0000000LL) == 0x0eec0000000LL)
d2051 1
a2051 1
  if (legacy_pc_in_sigtramp (pc, name))
a2585 4
  /* No more to do if the value is not supposed to be supplied.  */
  if (!valuep)
    return;

d3022 1
a3022 1
ia64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
a3033 1
  CORE_ADDR func_addr = find_function_addr (function, NULL);
d3331 1
a3331 1
  set_gdbarch_deprecated_use_struct_convention (gdbarch, ia64_use_struct_convention);
@


1.115
log
@2004-02-17  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c (skip_prologue_using_sal): New function.
	* symtab.h (skip_prologue_using_sal): Declare.
	* frv-tdep.c: Include "symtab.h".
	(skip_prologue_using_sal): Delete function.
	* mips-tdep.c (skip_prologue_using_sal): Delete function.
	* rs6000-tdep.c (refine_prologue_limit): Mention
	skip_prologue_using_sal.
	* ia64-tdep.c (refine_prologue_limit): Ditto.
	* Makefile.in: Update dependencies.
@
text
@d3 2
a4 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d41 1
a92 5

/* FIXME: These extern declarations should go in ia64-tdep.h.  */
extern CORE_ADDR ia64_linux_sigcontext_register_address (CORE_ADDR, int);
extern CORE_ADDR ia64_aix_sigcontext_register_address (CORE_ADDR, int);
extern unsigned long ia64_linux_getunwind_table (void *, size_t);
@


1.114
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@d933 3
@


1.113
log
@2004-02-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_SKIP): Default to 0.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@a23 1
#include "symfile.h"		/* for entry_point_address */
@


1.112
log
@
2004-02-10  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c (ia64_frame_this_id): Fix tracing print statement
        to use paddr functions to format ia64 addresses and long values.
        (ia64_frame_prev_register, ia64_sigtramp_frame_this_id): Ditto.
        (ia64_sigtramp_frame_prev_register, ia64_access_reg): Ditto.
        (get_kernel_table, ia64_find_proc_info_x): Ditto.
        (ia64_get_dyn_info_list, ia64_libunwind_this_frame_id): Ditto.
        (ia64_libunwind_frame_prev_register, ia64_unwind_dummy_id): Ditto.
@
text
@a3360 2
  set_gdbarch_frame_args_skip (gdbarch, 0);

@


1.111
log
@2004-02-03  Andrew Cagney  <cagney@@redhat.com>

	* ia64-tdep.c (read_sigcontext_register): Delete unused function.
	(process_note_abi_tag_sections): Delete unused function.
	(ia64_read_fp): Delete unused function.
	(gdbarch_extract_struct_value_address): Delete declaration.
@
text
@d1554 4
a1557 2
			"regular frame id: code %lx, stack %lx, special %lx, next_frame %p\n",
			this_id->code_addr, this_id->stack_addr, cache->bsp, next_frame);
d1852 1
a1852 1
			"regular prev register <%d> <%s> is %lx\n", regnum, 
d1854 2
a1855 1
			 ? ia64_register_names[regnum] : "r??"), extract_unsigned_integer (valuep, 8));
d1953 4
a1956 2
			"sigtramp frame id: code %lx, stack %lx, special %lx, next_frame %p\n",
			this_id->code_addr, this_id->stack_addr, cache->bsp, next_frame);
d2032 1
a2032 1
			"sigtramp prev register <%s> is %lx\n",
d2034 2
a2035 1
			 ? ia64_register_names[regnum] : "r??"), extract_unsigned_integer (valuep, 8));
d2234 1
a2234 1
			    "  access_reg: to cache: %4s=%016lx\n",
d2236 2
a2237 1
			     ? ia64_register_names[regnum] : "r??"), *val);
d2281 1
a2281 1
			    "  access_reg: from cache: %4s=%016lx\n",
d2283 2
a2284 1
			     ? ia64_register_names[regnum] : "r??"), *val);
d2368 5
a2372 3
			"segbase=%lx, length=%lu, gp=%lx\n",
			(char *) di->u.ti.name_ptr, di->u.ti.segbase, 
			di->u.ti.table_len, di->gp);
d2454 9
a2462 6
	fprintf_unfiltered (gdb_stdlog, "ia64_find_proc_info_x: %lx -> "
			    "(name=`%s',segbase=%lx,start=%lx,end=%lx,gp=%lx,"
			    "length=%lu,data=%p)\n",
			    ip, (char *)di.u.ti.name_ptr,
			    di.u.ti.segbase, di.start_ip, di.end_ip,
			    di.gp, di.u.ti.table_len, di.u.ti.table_data);
d2471 9
a2479 6
	fprintf_unfiltered (gdb_stdlog, "ia64_find_proc_info_x: %lx -> "
			    "(name=`%s',segbase=%lx,start=%lx,end=%lx,gp=%lx,"
			    "length=%lu,data=%lx)\n",
			    ip, (char *)di.u.rti.name_ptr,
			    di.u.rti.segbase, di.start_ip, di.end_ip,
			    di.gp, di.u.rti.table_len, di.u.rti.table_data);
d2532 1
a2532 1
				    "at %lx (gp=%lx)\n",
d2534 1
a2534 1
				    addr, di.gp);
d2564 3
a2566 2
			"libunwind frame id: code %lx, stack %lx, special %lx, next_frame %p\n",
			id.code_addr, id.stack_addr, bsp, next_frame);
d2645 1
a2645 1
			"libunwind prev register <%s> is %lx\n",
d2647 2
a2648 1
			 ? ia64_register_names[regnum] : "r??"), extract_unsigned_integer (valuep, 8));
d3193 3
a3195 2
			"dummy frame id: code %lx, stack %lx, special %lx\n",
			frame_pc_unwind (next_frame), sp, bsp);
@


1.110
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (EXTRACT_STRUCT_VALUE_ADDRESS): Deprecate.  Add
	comments mentioning extract_returned_value_address.
	* infcmd.c (print_return_value): Update.  Add comments on
	extract_returned_value_address.
	* stack.c (return_command): Add comments on
	extract_returned_value_address.
	* values.c: Update comment.
	* m32r-tdep.c: Update comment.
	* sparc-tdep.c: Update comment.
	* ia64-tdep.c (ia64_use_struct_convention): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	EXTRACT_STRUCT_VALUE_ADDRESS to
	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
@
text
@a104 1
static gdbarch_extract_struct_value_address_ftype ia64_extract_struct_value_address;
a335 26
/* Read the given register from a sigcontext structure in the
   specified frame.  */

static CORE_ADDR
read_sigcontext_register (struct frame_info *frame, int regnum)
{
  CORE_ADDR regaddr;

  if (frame == NULL)
    internal_error (__FILE__, __LINE__,
		    "read_sigcontext_register: NULL frame");
  if (!(get_frame_type (frame) == SIGTRAMP_FRAME))
    internal_error (__FILE__, __LINE__,
		    "read_sigcontext_register: frame not a signal trampoline");
  if (SIGCONTEXT_REGISTER_ADDRESS == 0)
    internal_error (__FILE__, __LINE__,
		    "read_sigcontext_register: SIGCONTEXT_REGISTER_ADDRESS is 0");

  regaddr = SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), regnum);
  if (regaddr)
    return read_memory_integer (regaddr, register_size (current_gdbarch, regnum));
  else
    internal_error (__FILE__, __LINE__,
		    "read_sigcontext_register: Register %d not in struct sigcontext", regnum);
}

a625 12
ia64_read_fp (void)
{
  /* We won't necessarily have a frame pointer and even if we do, it
     winds up being extraordinarly messy when attempting to find the
     frame chain.  So for the purposes of creating frames (which is
     all deprecated_read_fp() is used for), simply use the stack
     pointer value instead.  */
  gdb_assert (SP_REGNUM >= 0);
  return read_register (SP_REGNUM);
}

static CORE_ADDR
a3217 47
}

static void
process_note_abi_tag_sections (bfd *abfd, asection *sect, void *obj)
{
  int *os_ident_ptr = obj;
  const char *name;
  unsigned int sectsize;

  name = bfd_get_section_name (abfd, sect);
  sectsize = bfd_section_size (abfd, sect);
  if (strcmp (name, ".note.ABI-tag") == 0 && sectsize > 0)
    {
      unsigned int name_length, data_length, note_type;
      char *note = alloca (sectsize);

      bfd_get_section_contents (abfd, sect, note,
                                (file_ptr) 0, (bfd_size_type) sectsize);

      name_length = bfd_h_get_32 (abfd, note);
      data_length = bfd_h_get_32 (abfd, note + 4);
      note_type   = bfd_h_get_32 (abfd, note + 8);

      if (name_length == 4 && data_length == 16 && note_type == 1
          && strcmp (note + 12, "GNU") == 0)
	{
	  int os_number = bfd_h_get_32 (abfd, note + 16);

	  /* The case numbers are from abi-tags in glibc.  */
	  switch (os_number)
	    {
	    case 0 :
	      *os_ident_ptr = ELFOSABI_LINUX;
	      break;
	    case 1 :
	      *os_ident_ptr = ELFOSABI_HURD;
	      break;
	    case 2 :
	      *os_ident_ptr = ELFOSABI_SOLARIS;
	      break;
	    default :
	      internal_error (__FILE__, __LINE__,
			      "process_note_abi_sections: unknown OS number %d", os_number);
	      break;
	    }
	}
    }
@


1.109
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	DECR_PC_AFTER_BREAK to zero.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Add comment.
@
text
@d2712 3
a2714 3
/* Should we use EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc
   and TYPE is the type (which is known to be struct, union or array).  */
d3403 1
a3403 1
  set_gdbarch_extract_struct_value_address (gdbarch, ia64_extract_struct_value_address);
@


1.108
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@a3427 1
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
@


1.107
log
@2004-01-05  Andrew Cagney  <cagney@@redhat.com>

	* libunwind-frame.h (struct frame_id): Add opaque declaration,
	move to start of file.
	* i386-tdep.h (struct regcache): Add opaque declaration.
	* config/ia64/nm-linux.h (struct target_ops): Add opaque
	declaration.
	* ia64-tdep.c (ia64_find_proc_info_x): Do not use __FUNCTION__.
	(ia64_gdbarch_init): Use "GNU/Linux" in comment.
	* win32-nat.c (fake_create_process): Use ISO C style definition.
	* stabsread.c (define_symbol): Delete #ifndef
	DEPRECATED_USE_REGISTER_NOT_ARG wrapper around
	stabs_argument_has_addr call, macro never defined.
@
text
@a3428 1
  set_gdbarch_function_start_offset (gdbarch, 0);
@


1.106
log
@	From David Mosberger  <davidm@@hpl.hp.com>:
	* libunwind-frame.c (unw_find_dyn_list_p): Replace most arguments
	with a single unw_dyn_info_t pointer.
	(libunwind_find_dyn_list): Likewise.
	* libunwind-frame.h: Likewise.
	* ia64-tdep.c (ia64_find_unwind_table): Switch to using
	UNW_INFO_FORMAT_REMOTE_TABLE so we can avoid having to read in the
	entire unwind-table at once.  Support for this table format has
	been added to libunwind v0.95.
	(ia64_find_proc_info_x): Adjust for remote-unwind-table changes.
	(ia64_get_dyn_info_list): Adjust for interface change for
	libunwind_find_dyn_list().
@
text
@d2483 1
a2483 1
	fprintf_unfiltered (gdb_stdlog, "%s: %lx -> "
d2485 1
a2485 1
			    "length=%lu,data=%p)\n", __FUNCTION__,
d2497 1
a2497 1
	fprintf_unfiltered (gdb_stdlog, "%s: %lx -> "
d2499 1
a2499 1
			    "length=%lu,data=%lx)\n", __FUNCTION__,
d3359 8
a3366 6
  /* According to the ia64 specs, instructions that store long double floats 
     in memory use a long-double format different than that used in the floating
     registers.  The memory format matches the x86 extended float format which is
     80 bits.  An OS may choose to use this format (e.g. Linux) or choose to use
     a different format for storing long doubles (e.g. HPUX).  In the latter case,
     the setting of the format may be moved/overridden in an OS-specific tdep file.  */
@


1.105
log
@
2003-12-05  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c (ia64_gdbarch_init): Set up the gdbarch long double
        format to be the i387 extended float format which is used for
        long doubles stored in memory.
@
text
@d2455 5
a2459 17
  dip->format = UNW_INFO_FORMAT_TABLE;
  dip->u.ti.name_ptr = (unw_word_t) bfd_get_filename (bfd);
  dip->u.ti.segbase = segbase;
  dip->u.ti.table_len = p_unwind->p_memsz / sizeof (unw_word_t);

  /* The following can happen in corner cases where dynamically
     generated code falls into the same page that contains the
     data-segment and the page-offset of the code is within the first
     page of the executable.  */
  if (ip < dip->start_ip || ip >= dip->end_ip)
    return -UNW_ENOINFO;

  /* Read in the libunwind table.  */
  *buf = xmalloc (p_unwind->p_memsz);
  target_read_memory (p_unwind->p_vaddr + load_base, (char *)(*buf), p_unwind->p_memsz);

  dip->u.ti.table_data = (unw_word_t *)(*buf);
d2481 8
d2495 8
d2505 2
a2506 8
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog, "acquire_unwind_info: %lx -> "
			"(name=`%s',segbase=%lx,start=%lx,end=%lx,gp=%lx,"
			"length=%lu,data=%p)\n", ip, (char *)di.u.ti.name_ptr,
			di.u.ti.segbase, di.start_ip, di.end_ip,
			di.gp, di.u.ti.table_len, di.u.ti.table_data);

  ret = libunwind_search_unwind_table (&as, ip, &di, pi, need_unwind_info, arg);
d2546 1
a2546 4
	  addr = libunwind_find_dyn_list (as, di.u.ti.table_data,
					  (di.u.ti.table_len
					   * sizeof (di.u.ti.table_data[0])),
					  di.u.ti.segbase, di.gp, arg);
@


1.104
log
@
2003-11-17  Jeff Johnston  <jjohnstn@@redhat.com>
            David Mosberger  <davidm@@hpl.hp.com>

        * ia64-tdep.c: Include elf.h.
        [HAVE_LIBUNWIND_IA64_H]: Include libunwind-frame.h and
        libunwind-ia64.h.
        (ia64_rse_slot_num, ia64_rse_skip_regs): New for libunwind support.
        (ia64_gdb2uw_regnum, ia64_uw2gdb_regnum): Ditto.
        (ia64_is_fpreg, ia64_access_reg): Ditto.
        (ia64_access_fpreg, ia64_access_mem): Ditto.
        (get_kernel_table): Ditto.
        (ia64_find_unwind_table): Ditto.
        (ia64_find_proc_info_x, ia64_put_unwind_info): Ditto.
        (ia64_get_dyn_info_list, ia64_libunwind_frame_this_id): Ditto.
        (ia64_libunwind_frame_prev_register): Ditto.
        (ia64_libunwind_frame_sniffer): Ditto.
        (ia64_gdbarch_init)[HAVE_LIBUNWIND_IA64_H]: Add libunwind frame
        sniffer.  Register libunwind functions needed by generic
        libunwind frame code using libunwind_frame_set_descr().
@
text
@d3364 8
@


1.103
log
@2003-11-05  Andrew Cagney  <cagney@@redhat.com>

	* xcoffread.c (find_linenos): Replace "sec_ptr" and "bfd" with
	"struct bfd_section" and "struct bfd".
	* target.h (struct section_table): Ditto.
	* rs6000-nat.c (xcoff_relocate_core): Ditto.
	* solib-svr4.c (elf_locate_base): Ditto.
	* pa64solib.c (dld_cache_t): Ditto.
	* objfiles.h (struct obj_section): Ditto.
	* objfiles.c (add_to_objfile_sections): Ditto.
	* exec.c (bfdsec_to_vmap): Ditto.
	(add_to_section_table): Ditto.
	(build_section_table): Ditto.
	* corelow.c (get_core_register_section): Ditto.
	* coffread.c (find_linenos): Ditto.
	* elfread.c (elf_interpreter): Delete #if0'd function.

	* mips-tdep.c (mips_dump_tdep): Delete code prinint VX_NUM_REGS.
	* config/sparc/tm-vxsparc.h (VX_NUM_REGS): Delete macro.
	* config/mips/tm-vxmips.h (VX_NUM_REGS): Delete macro.
	* config/m68k/tm-vx68.h (VX_NUM_REGS): Delete macro.

	* arch-utils.h (generic_cannot_extract_struct_value_address):
	Delete declaration.
	* wince.c (_initialize_wince): Fix multi-line string.
	* ia64-tdep.c (floatformat_valid): Convert to ISO C.
@
text
@d39 1
d42 5
d96 1
d2109 608
d3413 4
@


1.102
log
@
2003-11-05  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c (struct gdbarch_tdep): Remove os_ident field.
        (ia64_gdbarch_init): Don't bother calculating the os.
        Instead use the gdbarch_info struct and look at the osabi field.
        Also use gdbarch_list_lookup_by_info() to look for a
        candidate gdbarch.
@
text
@d318 1
a318 3
floatformat_valid (fmt, from)
     const struct floatformat *fmt;
     const char *from;
@


1.101
log
@
2003-10-23  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c: (ia64_frame_cache): Add new prev_cfm field.
        (pseudo_regs): Add comment regarding register stack registers.
        (ia64_alloc_frame_cache):  Initialize new prev_cfm field to 0.
        (floatformat_valid): New static routine.
        (floatformat_ia64_ext): Add name field and set up is_valid routine
        to floatformat_valid().
        (examine_prologue):  For the previous cfm, use
        frame_unwind_register()
        if the cfm is not stored in a register-stack register.  Save the
        previous cfm value in the prev_cfm field.  Add debug output.
        (ia64_frame_this_id): Use frame_id_build_special() to also register
        the bsp.  Add debug output.
        (ia64_sigtramp_frame_this_id): Ditto.
        (ia64_frame_prev_register):  Look at cache saved_regs for a few more
        registers and also add some checks for framelessness before accepting
        current register values for fields such as return address.  For cfm,
        use the cached prev_cfm field if available.  Add comment to explain
        PSR logic.  Add debug output.
        (ia64_sigtramp_frame_init_saved_regs): Save the bsp and sp addresses
        as part of initialization.
        (ia64_sigtramp_frame_cache): Hard-code stack size as it can't be
        calculated.  Cache the bsp and cfm values.
        (ia64_sigtramp_frame_prev_register): Add logic to this routine out
        instead of using ia64_frame_prev_register() which doesn't expect most
        registers to be saved.  The saved values for bsp and sp
        can be taken from the cache.  Add debug output.
        (ia64_push_dummy_call): Use frame_id_build_special() to also register
        the bsp.
@
text
@a258 3
    int os_ident;	/* From the ELF header, one of the ELFOSABI_
                           constants: ELFOSABI_LINUX, ELFOSABI_AIX,
			   etc. */
a2709 1
  int os_ident;
d2711 4
a2714 28
  if (info.abfd != NULL
      && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
    {
      os_ident = elf_elfheader (info.abfd)->e_ident[EI_OSABI];

      /* If os_ident is 0, it is not necessarily the case that we're
         on a SYSV system.  (ELFOSABI_NONE is defined to be 0.)
         GNU/Linux uses a note section to record OS/ABI info, but
         leaves e_ident[EI_OSABI] zero.  So we have to check for note
         sections too.  */
      if (os_ident == 0)
	{
	  bfd_map_over_sections (info.abfd,
	                         process_note_abi_tag_sections,
				 &os_ident);
	}
    }
  else
    os_ident = -1;

  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep &&tdep->os_ident == os_ident)
	return arches->gdbarch;
    }
a2717 1
  tdep->os_ident = os_ident;
d2724 1
a2724 1
  if (os_ident == ELFOSABI_LINUX)
d2738 1
a2738 1
  if (os_ident == ELFOSABI_LINUX)
@


1.100
log
@2003-10-22  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (convert_from_func_ptr_addr): Convert to a pure
	multi-arch method, add "targ" parameter.
	(struct target_ops): Declare.
	* gdbarch.h, gdbarch.c: Re-generate.
	* Makefile.in (c-valprint.o): Update dependencies.
	* arch-utils.h: Update copyright.
	(convert_from_func_ptr_addr_identity): Declare.
	* arch-utils.c (convert_from_func_ptr_addr_identity): New function.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Update.
	* rs6000-tdep.c (rs6000_convert_from_func_ptr_addr): Upate.
	* ppc-linux-tdep.c (ppc64_linux_convert_from_func_ptr_addr): Update.
	* infcall.c (find_function_addr, call_function_by_hand): Update.
	* c-valprint.c: Include "target.h".
	(print_function_pointer_address): Update.
@
text
@d111 1
a111 1
   they are in memory and must be calculated via the bsp register.  */
d235 1
d320 8
d331 1
a331 1
  floatformat_intbit_yes
d1042 1
d1463 1
d1467 10
d1588 5
a1592 1
  (*this_id) = frame_id_build (cache->base, cache->pc);
d1656 11
a1666 3
      CORE_ADDR addr = 0;

      if (cache->frameless)
a1670 6
      else
	{
	  addr = cache->saved_regs[IA64_CFM_REGNUM];
	  if (addr != 0)
	    read_memory (addr, valuep, register_size (current_gdbarch, regnum));
	}
d1757 1
d1759 1
a1759 1
      if (cache->frameless)
d1761 3
a1763 1
	  frame_unwind_register (next_frame, IA64_BR0_REGNUM, buf);
d1766 1
a1766 1
      else
d1768 2
a1769 6
	  CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];
	  if (addr != 0)
	    {
	      read_memory (addr, buf, register_size (current_gdbarch, IA64_IP_REGNUM));
	      pc = extract_unsigned_integer (buf, 8);
	    }
d1776 4
d1783 1
d1788 8
a1795 1
      if (cache->frameless)
a1800 9
      else
	{
	  CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];
	  if (addr != 0)
	    {
	      read_memory (addr, buf, register_size (current_gdbarch, IA64_IP_REGNUM));
	      pc = extract_unsigned_integer (buf, 8);
	    }
	}
d1806 13
d1884 6
a1919 1
#if 0
d1921 1
a1921 2
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_BSP_REGNUM);
#endif
d1935 2
a1936 3
	if (regno != sp_regnum)
	  cache->saved_regs[regno] =
	    SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
d1960 10
a1969 1
  cache->base = extract_unsigned_integer (buf, 8) + cache->mem_stack_frame_size;
d1984 5
a1988 1
  (*this_id) = frame_id_build (cache->base, frame_pc_unwind (next_frame));
d1998 63
a2060 2
  /* Make sure we've initialized the cache.  */
  ia64_sigtramp_frame_cache (next_frame, this_cache);
d2062 5
a2066 2
  ia64_frame_prev_register (next_frame, this_cache, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
d2599 1
a2599 1
  CORE_ADDR sp;
d2604 9
a2612 1
  return frame_id_build (sp, frame_pc_unwind (next_frame));
@


1.99
log
@
2003-10-20  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c: Change all occurrences of
        DEPRECATED_REGISTER_RAW_SIZE to use register_size() instead.
        (ia64_frame_prev_register): Minor whitespace change.
@
text
@d2296 2
a2297 1
ia64_convert_from_func_ptr_addr (CORE_ADDR addr)
@


1.98
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d346 1
a346 1
    return read_memory_integer (regaddr, DEPRECATED_REGISTER_RAW_SIZE (regnum));
d719 1
a719 1
	  store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum), reg);
d722 1
a722 1
	store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum), 0);
d730 1
a730 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum), unatN_val);
d765 1
a765 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum), natN_val);
d780 1
a780 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum), vbsp);
d802 1
a802 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum), prN_val);
d805 1
a805 1
    memset (buf, 0, DEPRECATED_REGISTER_RAW_SIZE (regnum));
d832 1
a832 1
      unatN_val = extract_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum)); 
d856 1
a856 1
      natN_val = extract_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum)); 
d885 1
a885 1
	      store_unsigned_integer (nat_buf, DEPRECATED_REGISTER_RAW_SIZE (regnum), nat_collection);
d910 1
a910 1
      prN_val = extract_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum)); 
d1596 1
a1596 1
  memset (valuep, 0, DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1601 1
a1601 1
      store_unsigned_integer (valuep, DEPRECATED_REGISTER_RAW_SIZE (regnum),
d1616 1
a1616 1
         frame is cache->bsp - cache->sof.  This value in the previous frame points to
d1626 1
a1626 1
      store_unsigned_integer (valuep, DEPRECATED_REGISTER_RAW_SIZE (regnum), 
d1642 1
a1642 1
	    read_memory (addr, valuep, DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1652 1
a1652 1
      store_unsigned_integer (valuep, DEPRECATED_REGISTER_RAW_SIZE (IA64_VFP_REGNUM), vfp);
d1676 1
a1676 1
      store_unsigned_integer (valuep, DEPRECATED_REGISTER_RAW_SIZE (regnum), prN_val);
d1690 1
a1690 1
      store_unsigned_integer (valuep, DEPRECATED_REGISTER_RAW_SIZE (regnum), 
d1725 1
a1725 1
      store_unsigned_integer (valuep, DEPRECATED_REGISTER_RAW_SIZE (regnum), natval);
d1741 1
a1741 1
	      read_memory (addr, buf, DEPRECATED_REGISTER_RAW_SIZE (IA64_IP_REGNUM));
d1768 1
a1768 1
	      read_memory (addr, buf, DEPRECATED_REGISTER_RAW_SIZE (IA64_IP_REGNUM));
d1788 1
a1788 1
	  read_memory (addr, valuep, DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1812 1
a1812 1
	  read_memory (addr, valuep, DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1836 1
a1836 1
	  read_memory (addr, valuep, DEPRECATED_REGISTER_RAW_SIZE (regnum));
@


1.97
log
@
2003-09-09  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c (ia64_sigtramp_frame_init_saved_regs):
        Fix typo for high range of floating registers.
@
text
@d346 1
a346 1
    return read_memory_integer (regaddr, REGISTER_RAW_SIZE (regnum));
d719 1
a719 1
	  store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), reg);
d722 1
a722 1
	store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), 0);
d730 1
a730 1
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), unatN_val);
d765 1
a765 1
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), natN_val);
d780 1
a780 1
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), vbsp);
d802 1
a802 1
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), prN_val);
d805 1
a805 1
    memset (buf, 0, REGISTER_RAW_SIZE (regnum));
d832 1
a832 1
      unatN_val = extract_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum)); 
d856 1
a856 1
      natN_val = extract_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum)); 
d885 1
a885 1
	      store_unsigned_integer (nat_buf, REGISTER_RAW_SIZE (regnum), nat_collection);
d910 1
a910 1
      prN_val = extract_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum)); 
d1596 1
a1596 1
  memset (valuep, 0, REGISTER_RAW_SIZE (regnum));
d1601 1
a1601 1
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum),
d1626 1
a1626 1
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum), 
d1642 1
a1642 1
	    read_memory (addr, valuep, REGISTER_RAW_SIZE (regnum));
d1652 1
a1652 1
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (IA64_VFP_REGNUM), vfp);
d1676 1
a1676 1
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum), prN_val);
d1690 1
a1690 1
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum), 
d1725 1
a1725 1
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum), natval);
d1741 1
a1741 1
	      read_memory (addr, buf, REGISTER_RAW_SIZE (IA64_IP_REGNUM));
d1768 1
a1768 1
	      read_memory (addr, buf, REGISTER_RAW_SIZE (IA64_IP_REGNUM));
d1788 1
a1788 1
	  read_memory (addr, valuep, REGISTER_RAW_SIZE (regnum));
d1812 1
a1812 1
	  read_memory (addr, valuep, REGISTER_RAW_SIZE (regnum));
d1836 1
a1836 1
	  read_memory (addr, valuep, REGISTER_RAW_SIZE (regnum));
@


1.96
log
@2003-09-04  Andrew Cagney  <cagney@@redhat.com>

	* avr-tdep.c: Include "dis-asm.h".
	* cris-tdep.c: Include "dis-asm.h".
	(cris_delayed_get_disassembler): Use "struct disassemble_info"
	instead of corresponding typedef.
	* h8300-tdep.c: Include "dis-asm.h".
	* ia64-tdep.c: Include "dis-asm.h".
	* i386-tdep.c: Include "dis-asm.h".
	(i386_print_insn): Use "struct disassemble_info" instead of
	corresponding typedef.
	* m68k-tdep.c: Include "dis-asm.h".
	* mcore-tdep.c: Include "dis-asm.h".
	* mips-tdep.c: Include "dis-asm.h".
	(gdb_print_insn_mips): Make static, use "struct disassemble_info"
	instead of corresponding typedef.
	* ns32k-tdep.c: Include "dis-asm.h".
	* s390-tdep.c: Include "dis-asm.h".
	* sparc-tdep.c: Include "dis-asm.h".
	* vax-tdep.c: Include "dis-asm.h".
	* v850-tdep.c: Include "dis-asm.h".
	* mn10300-tdep.c: Include "dis-asm.h".
	* rs6000-tdep.c: Include "dis-asm.h".
	* xstormy16-tdep.c: Include "dis-asm.h".
	(_initialize_xstormy16_tdep): Delete "extern" declaration of
	print_insn_xstormy16.
	* Makefile.in (v850-tdep.o): Update dependencies.
	(vax-tdep.o, sparc-tdep.o, s390-tdep.o): Ditto.
	(ns32k-tdep.o, mips-tdep.o, mcore-tdep.o): Ditto.
	(m68k-tdep.o, ia64-tdep.o, i386-tdep.o): Ditto.
	(h8300-tdep.o, cris-tdep.o, avr-tdep.o): Ditto.
	(mn10300-tdep.o, xstormy16-tdep.o, disasm.o): Ditto.
	(gdbarch_h): Remove $(dis_asm_h).
	* disasm.c: Include "dis-asm.h".
	(dis_asm_read_memory): Use "struct disassemble_info" instead of
	corresponding typedef.
	(dis_asm_memory_error, dump_insns, do_assembly_only): Ditto.
	(gdb_disassemble_info, gdb_disassembly, gdb_print_insn): Ditto.
	* gdbarch.sh: Do not include "dis-asm.h".
	(struct disassemble_info): Declare opaque.
	(TARGET_PRINT_INSN): Update declaration.
	* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d1895 1
a1895 1
      for (regno = IA64_FR2_REGNUM; regno <= IA64_BR7_REGNUM; regno++)
@


1.95
log
@
2003-08-26  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c (examine_prologue): Only stop at predicated insns if
        we are frameless or the return address register is already known.
@
text
@d39 1
@


1.94
log
@
2003-08-26  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c (ia64_convert_from_func_addr): New function.
        (ia64_gdbarch_init): Call set_gdbarch_convert_from_func_addr().
@
text
@d1146 1
a1146 2
      if ((it == B && ((instr & 0x1e1f800003f) != 0x04000000000))
          || ((instr & 0x3fLL) != 0LL))
d1148 10
a1157 2
	  /* Exit loop upon hitting a non-nop branch instruction 
	     or a predicated instruction. */
@


1.93
log
@
2003-08-25  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c (pseudo_regs): New enum that lists gr32-gr127, p0-p63,
        bof, and nat0-nat127 as pseudo-registers.
        (ia64_frame_cache): New struct used to cache frame info.
        (ia64_register_reggroup_p): New routine used to override default
        register grouping so registers without names are still saved and
        restored.
        (ia64_dwarf_reg_to_regnum): New routine to map gr32-gr127 to their
        pseudo values.
        (ia64_pseudo_register_read): New routine to read pseudo-registers.
        (ia64_pseudo_register_write): New routine to write pseudo-registers.
        (ia64_alloc_frame_cache): New routine to create a new
        ia64_frame_cache.
        (examine_prologue): Change prototype to add next_frame pointer.
        Assume frameless until otherwise proven.  Verify that the cfm for
        current frame matches the cfm that should occur for the prologues
        alloc insn and if equal, mark as not frameless.  At end of routine,
        if not frameless, calculate registers for the previous frame and store
        in the cache, if a cache is provided.
        (ia64_skip_prologue):  Use new prototype when calling examine_prologue
        and pass 0 for next_frame.
        (ia64_store_return_value): Change to use convert_typed_floating()
        instead of calling ia64_convert_to_raw().
        (ia64_extract_return_value): Change to use convert_typed_floating()
        instead of calling ia64_convert_to_virtual().
        (ia64_frame_cache): New routine to support new frame model.
        (ia64_frame_this_id, ia64_frame_prev_register): Ditto.
        (ia64_frame_sniffer): Ditto.
        (ia64_sigtramp_frame_init_saved_regs): Ditto.
        (ia64_sigtramp_frame_cache, ia64_sigtramp_frame_this_id): Ditto.
        (ia64_sigtramp_frame_prev_register): Ditto.
        (ia64_sigtramp_frame_sniffer): Ditto.
        (ia64_frame_base_address): Ditto.
        (ia64_extract_struct_value_address): Change to issue error message.
        (ia64_frame_align): New routine to align sp.
        (ia64_push_dummy_call): New routine based on ia64_push_arguments().
        (ia64_push_arguments): Removed.  Logic moved to
        ia64_push_dummy_call().
        (ia64_push_return_address): Ditto.
        (ia64_unwind_dummy_id): New function.
        (ia64_unwind_pc): Ditto.
        (ia64_convert_register_p): Ditto.
        (ia64_register_to_value): Ditto.
        (ia64_value_to_register): Ditto.
        (ia64_pop_frame, ia64_pop_frame_regular): Removed.
        (ia64_register_byte, ia64_register_raw_size): Ditto.
        (ia64_register_virtual_size, ia64_register_virtual_byte): Ditto.
        (ia64_saved_pc_after_call): Ditto.
        (ia64_frame_chain, ia64_frame_saved_pc): Ditto.
        (ia64_frame_init_saved_regs, ia64_get_saved_register): Ditto.
        (ia64_register_convertible, ia64_register_convert_to_virtual): Ditto.
        (ia64_register_convert_to_raw): Ditto.
        (ia64_store_struct_return, ia64_call_dummy_words): Ditto.
        (ia64_init_extra_frame_info): Ditto.
        (ia64_frame_args_address, ia64_frame_locals_address): Ditto.
        (ia64_gdbarch_init): Remove registering of deprecated functions that
        are no longer used.  Add registration of new gdbarch functions.
        Remove registering deprecated_write_sp.  Replace
        set_gdbarch_register_virtual_type() with set_gdbarch_register_type().
        Delete set_gdbarch_deprecated_register_convertible(),
        set_gdbarch_deprecated_register_convert_to_virtual(), and
        set_gdbarch_deprecated_register_convert_to_raw() calls.  Remove
        set_gdbarch_deprecated_register_size(),
        set_gdbarch_deprecated_register_bytes(),
        set_gdbarch_pcregnum(),
        set_gdbarch_deprecated_register_byte(),
        set_gdbarch_deprecated_register_raw_size(),
        set_gdbarch_deprecated_max_register_raw_size(),
        set_gdbarch_deprecated_register_virtual_size(),
        and set_gdbarch_deprecated_max_register_virtual_size() calls.
        Replace set_gdbarch_deprecated_extract_return_value() with
        set_gdbarch_extract_return_value().  Remove calls to:
        set_gdbarch_deprecated_saved_pc_after_call();
        set_gdbarch_deprecated_frame_chain(),
        set_gdbarch_deprecated_frame_saved_pc(),
        set_gdbarch_deprecated_frame_init_saved_regs(),
        set_gdbarch_deprecated_get_saved_register(),
        set_gdbarch_deprecated_call_dummy_words(),
        set_gdbarch_deprecated_sizeof_call_dummy_words(),
        set_gdbarch_deprecated_init_extra_frame_info(),
        set_gdbarch_deprecated_frame_args_address(),
        set_gdbarch_deprecated_frame_locals_address(),
        and set_gdbarch_deprecated_dummy_write_sp().
        Add set_gdbarch_convert_register_p(),
        set_gdbarch_register_to_value(),
        set_gdbarch_value_to_register(),
        set_gdbarch_push_dummy_call(),
        set_gdbarch_frame_align(),
        set_gdbarch_unwind_dummy_id(),
        set_gdbarch_unwind_pc(),
        frame_unwind_append_sniffer(),
        frame_unwind_append_sniffer(),
        and frame_base_set_default().
@
text
@d2284 17
d2704 1
@


1.92
log
@	* ia64-tdep.c (ia64_print_insn): New function.
	(ia64_gdbarch_init): Set print_insn to it.
	(_initialize_ia64_tdep): Don't set deprecated_tm_print_insn and
	deprecated_tm_print_insn_info.
@
text
@d29 4
d93 1
d96 2
a97 2
static gdbarch_deprecated_extract_return_value_ftype ia64_extract_return_value;
static gdbarch_deprecated_extract_struct_value_address_ftype ia64_extract_struct_value_address;
a98 3
static gdbarch_frameless_function_invocation_ftype ia64_frameless_function_invocation;
static gdbarch_deprecated_saved_pc_after_call_ftype ia64_saved_pc_after_call;
static void ia64_pop_frame_regular (struct frame_info *frame);
d101 3
a103 1
static int ia64_num_regs = 590;
a104 1
static int pc_regnum = IA64_IP_REGNUM;
d109 5
a113 1
static LONGEST ia64_call_dummy_words[] = {0};
d123 12
a134 12
  "r32",  "r33",  "r34",  "r35",  "r36",  "r37",  "r38",  "r39",
  "r40",  "r41",  "r42",  "r43",  "r44",  "r45",  "r46",  "r47",
  "r48",  "r49",  "r50",  "r51",  "r52",  "r53",  "r54",  "r55",
  "r56",  "r57",  "r58",  "r59",  "r60",  "r61",  "r62",  "r63",
  "r64",  "r65",  "r66",  "r67",  "r68",  "r69",  "r70",  "r71",
  "r72",  "r73",  "r74",  "r75",  "r76",  "r77",  "r78",  "r79",
  "r80",  "r81",  "r82",  "r83",  "r84",  "r85",  "r86",  "r87",
  "r88",  "r89",  "r90",  "r91",  "r92",  "r93",  "r94",  "r95",
  "r96",  "r97",  "r98",  "r99",  "r100", "r101", "r102", "r103",
  "r104", "r105", "r106", "r107", "r108", "r109", "r110", "r111",
  "r112", "r113", "r114", "r115", "r116", "r117", "r118", "r119",
  "r120", "r121", "r122", "r123", "r124", "r125", "r126", "r127",
d153 8
a160 8
  "p0",   "p1",   "p2",   "p3",   "p4",   "p5",   "p6",   "p7",
  "p8",   "p9",   "p10",  "p11",  "p12",  "p13",  "p14",  "p15",
  "p16",  "p17",  "p18",  "p19",  "p20",  "p21",  "p22",  "p23",
  "p24",  "p25",  "p26",  "p27",  "p28",  "p29",  "p30",  "p31",
  "p32",  "p33",  "p34",  "p35",  "p36",  "p37",  "p38",  "p39",
  "p40",  "p41",  "p42",  "p43",  "p44",  "p45",  "p46",  "p47",
  "p48",  "p49",  "p50",  "p51",  "p52",  "p53",  "p54",  "p55",
  "p56",  "p57",  "p58",  "p59",  "p60",  "p61",  "p62",  "p63",
d201 24
d227 20
a246 15
struct frame_extra_info
  {
    CORE_ADDR bsp;	/* points at r32 for the current frame */
    CORE_ADDR cfm;	/* cfm value for current frame */
    int sof;		/* Size of frame  (decoded from cfm value) */
    int	sol;		/* Size of locals (decoded from cfm value) */
    CORE_ADDR after_prologue;
			/* Address of first instruction after the last
			   prologue instruction;  Note that there may
			   be instructions from the function's body
			   intermingled with the prologue. */
    int mem_stack_frame_size;
			/* Size of the memory stack frame (may be zero),
			   or -1 if it has not been determined yet. */
    int	fp_reg;		/* Register number (if any) used a frame pointer
d249 5
a253 1
  };
d272 23
d301 2
a302 2
static int
ia64_register_raw_size (int reg)
d304 4
a307 7
  return (IA64_FR0_REGNUM <= reg && reg <= IA64_FR127_REGNUM) ? 16 : 8;
}

static int
ia64_register_virtual_size (int reg)
{
  return (IA64_FR0_REGNUM <= reg && reg <= IA64_FR127_REGNUM) ? 16 : 8;
a309 2
/* Return true iff register N's virtual format is different from
   its raw format. */
d311 1
a311 1
ia64_register_convertible (int nr)
d313 3
a315 1
  return (IA64_FR0_REGNUM <= nr && nr <= IA64_FR127_REGNUM);
a323 42
static void
ia64_register_convert_to_virtual (int regnum, struct type *type,
                                  char *from, char *to)
{
  if (regnum >= IA64_FR0_REGNUM && regnum <= IA64_FR127_REGNUM)
    {
      DOUBLEST val;
      floatformat_to_doublest (&floatformat_ia64_ext, from, &val);
      deprecated_store_floating (to, TYPE_LENGTH(type), val);
    }
  else
    error("ia64_register_convert_to_virtual called with non floating point register number");
}

static void
ia64_register_convert_to_raw (struct type *type, int regnum,
                              const char *from, char *to)
{
  if (regnum >= IA64_FR0_REGNUM && regnum <= IA64_FR127_REGNUM)
    {
      DOUBLEST val = deprecated_extract_floating (from, TYPE_LENGTH(type));
      floatformat_from_doublest (&floatformat_ia64_ext, &val, to);
    }
  else
    error("ia64_register_convert_to_raw called with non floating point register number");
}

struct type *
ia64_register_virtual_type (int reg)
{
  if (reg >= IA64_FR0_REGNUM && reg <= IA64_FR127_REGNUM)
    return builtin_type_long_double;
  else
    return builtin_type_long;
}

static int
ia64_register_byte (int reg)
{
  return (8 * reg) +
   (reg <= IA64_FR0_REGNUM ? 0 : 8 * ((reg > IA64_FR127_REGNUM) ? 128 : reg - IA64_FR0_REGNUM));
}
d698 3
a700 24
/* The IA-64 frame chain is a bit odd.  We won't always have a frame
   pointer, so we use the SP value as the FP for the purpose of
   creating a frame.  There is sometimes a register (not fixed) which
   is used as a frame pointer.  When this register exists, it is not
   especially hard to determine which one is being used.  It isn't
   even really hard to compute the frame chain, but it can be
   computationally expensive.  So, instead of making life difficult
   (and slow), we pick a more convenient representation of the frame
   chain, knowing that we'll have to make some small adjustments in
   other places.  (E.g, note that deprecated_read_fp() is actually
   read_sp() in ia64_gdbarch_init() below.)

   Okay, so what is the frame chain exactly?  It'll be the SP value
   at the time that the function in question was entered.

   Note that this *should* actually the frame pointer for the current
   function!  But as I note above, if we were to attempt to find the
   address of the beginning of the previous frame, we'd waste a lot
   of cycles for no good reason.  So instead, we simply choose to
   represent the frame chain as the end of the previous frame instead
   of the beginning.  */

static CORE_ADDR
ia64_frame_chain (struct frame_info *frame)
d702 1
a702 7
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
    return read_sigcontext_register (frame, sp_regnum);
  else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
					get_frame_base (frame),
					get_frame_base (frame)))
    return get_frame_base (frame);
  else
d704 16
a719 3
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
      if (get_frame_saved_regs (frame)[IA64_VFP_REGNUM])
	return read_memory_integer (get_frame_saved_regs (frame)[IA64_VFP_REGNUM], 8);
d721 44
a764 2
	return (get_frame_base (frame)
		+ get_frame_extra_info (frame)->mem_stack_frame_size);
d766 39
d807 3
a809 2
static CORE_ADDR
ia64_frame_saved_pc (struct frame_info *frame)
d811 79
a889 8
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
    return read_sigcontext_register (frame, pc_regnum);
  else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
					get_frame_base (frame),
					get_frame_base (frame)))
    return deprecated_read_register_dummy (get_frame_pc (frame),
					   get_frame_base (frame), pc_regnum);
  else
d891 7
a897 1
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d899 17
a915 7
      if (get_frame_saved_regs (frame)[IA64_VRAP_REGNUM])
	return read_memory_integer (get_frame_saved_regs (frame)[IA64_VRAP_REGNUM], 8);
      else if (get_next_frame (frame)
	       && (get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME))
	return read_sigcontext_register (get_next_frame (frame), IA64_BR0_REGNUM);
      else	/* either frameless, or not far enough along in the prologue... */
	return ia64_saved_pc_after_call (frame);
d919 28
d1018 27
d1046 1
a1046 1
examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc, struct frame_info *frame)
a1051 2
  int do_fsr_stuff = 0;

d1064 5
a1068 1
  int frameless = 0;
d1074 3
a1076 11
  if (frame && !get_frame_saved_regs (frame))
    {
      frame_saved_regs_zalloc (frame);
      do_fsr_stuff = 1;
    }

  if (frame 
      && !do_fsr_stuff
      && get_frame_extra_info (frame)->after_prologue != 0
      && get_frame_extra_info (frame)->after_prologue <= lim_pc)
    return get_frame_extra_info (frame)->after_prologue;
a1089 4
      /* Okay, so sor, sol, and sof aren't used right now; but perhaps
         we could compare against the size given to us via the cfm as
	 either a sanity check or possibly to see if the frame has been
	 changed by a later alloc instruction... */
d1091 11
a1123 1
	      frameless = 1;
d1194 2
d1208 6
a1213 1
	      spill_addr  = (frame ? get_frame_base (frame) : 0)
d1249 1
a1249 2
	      if (do_fsr_stuff)
	        get_frame_saved_regs (frame)[IA64_FR0_REGNUM + fM] = spill_addr;
d1308 1
a1308 2
		  if (do_fsr_stuff)
		    get_frame_saved_regs (frame)[IA64_UNAT_REGNUM] = spill_addr;
d1314 1
a1314 2
		  if (do_fsr_stuff)
		    get_frame_saved_regs (frame)[IA64_PR_REGNUM] = spill_addr;
d1397 1
a1397 2
	      if (do_fsr_stuff)
		get_frame_saved_regs (frame)[IA64_GR0_REGNUM + rM] = spill_addr;
d1410 2
a1411 33
  if (do_fsr_stuff) {
    int i;
    CORE_ADDR addr;
    int sor, rrb_gr;
    
    /* Extract the size of the rotating portion of the stack
       frame and the register rename base from the current
       frame marker. */
    sor = ((get_frame_extra_info (frame)->cfm >> 14) & 0xf) * 8;
    rrb_gr = (get_frame_extra_info (frame)->cfm >> 18) & 0x7f;

    for (i = 0, addr = get_frame_extra_info (frame)->bsp;
	 i < get_frame_extra_info (frame)->sof;
	 i++, addr += 8)
      {
	if (IS_NaT_COLLECTION_ADDR (addr))
	  {
	    addr += 8;
	  }
	if (i < sor)
	  get_frame_saved_regs (frame)[IA64_GR32_REGNUM + ((i + (sor - rrb_gr)) % sor)] 
	    = addr;
	else
	  get_frame_saved_regs (frame)[IA64_GR32_REGNUM + i] = addr;

	if (i+32 == cfm_reg)
	  get_frame_saved_regs (frame)[IA64_CFM_REGNUM] = addr;
	if (i+32 == ret_reg)
	  get_frame_saved_regs (frame)[IA64_VRAP_REGNUM] = addr;
	if (i+32 == fp_reg)
	  get_frame_saved_regs (frame)[IA64_VFP_REGNUM] = addr;
      }
  }
d1413 1
a1413 1
  if (frame && get_frame_extra_info (frame))
d1415 58
a1472 3
      get_frame_extra_info (frame)->after_prologue = last_prologue_pc;
      get_frame_extra_info (frame)->mem_stack_frame_size = mem_stack_frame_size;
      get_frame_extra_info (frame)->fp_reg = fp_reg;
d1474 1
a1474 1

d1477 6
a1482 1
    return lim_pc;
d1490 8
a1497 1
  return examine_prologue (pc, pc+1024, 0);
d1500 5
a1504 2
static void
ia64_frame_init_saved_regs (struct frame_info *frame)
d1506 29
a1534 2
  if (get_frame_saved_regs (frame))
    return;
d1536 1
a1536 3
  if ((get_frame_type (frame) == SIGTRAMP_FRAME) && SIGCONTEXT_REGISTER_ADDRESS)
    {
      int regno;
d1538 1
a1538 1
      frame_saved_regs_zalloc (frame);
d1540 4
a1543 36
      get_frame_saved_regs (frame)[IA64_VRAP_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_IP_REGNUM);
      get_frame_saved_regs (frame)[IA64_CFM_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_CFM_REGNUM);
      get_frame_saved_regs (frame)[IA64_PSR_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_PSR_REGNUM);
#if 0
      get_frame_saved_regs (frame)[IA64_BSP_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_BSP_REGNUM);
#endif
      get_frame_saved_regs (frame)[IA64_RNAT_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_RNAT_REGNUM);
      get_frame_saved_regs (frame)[IA64_CCV_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_CCV_REGNUM);
      get_frame_saved_regs (frame)[IA64_UNAT_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_UNAT_REGNUM);
      get_frame_saved_regs (frame)[IA64_FPSR_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_FPSR_REGNUM);
      get_frame_saved_regs (frame)[IA64_PFS_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_PFS_REGNUM);
      get_frame_saved_regs (frame)[IA64_LC_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_LC_REGNUM);
      for (regno = IA64_GR1_REGNUM; regno <= IA64_GR31_REGNUM; regno++)
	if (regno != sp_regnum)
	  get_frame_saved_regs (frame)[regno] =
	    SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), regno);
      for (regno = IA64_BR0_REGNUM; regno <= IA64_BR7_REGNUM; regno++)
	get_frame_saved_regs (frame)[regno] =
	  SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), regno);
      for (regno = IA64_FR2_REGNUM; regno <= IA64_BR7_REGNUM; regno++)
	get_frame_saved_regs (frame)[regno] =
	  SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), regno);
    }
  else
    {
      CORE_ADDR func_start;
d1545 1
a1545 3
      func_start = get_frame_func (frame);
      examine_prologue (func_start, get_frame_pc (frame), frame);
    }
d1549 2
a1550 6
ia64_get_saved_register (char *raw_buffer, 
                         int *optimized, 
			 CORE_ADDR *addrp,
			 struct frame_info *frame,
			 int regnum,
			 enum lval_type *lval)
d1552 2
a1553 1
  int is_dummy_frame;
d1555 3
a1557 2
  if (!target_has_registers)
    error ("No registers.");
d1559 2
a1560 2
  if (optimized != NULL)
    *optimized = 0;
d1562 10
a1571 2
  if (addrp != NULL)
    *addrp = 0;
d1573 1
a1573 2
  if (lval != NULL)
    *lval = not_lval;
d1575 2
a1576 3
  is_dummy_frame = DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
						get_frame_base (frame),
						get_frame_base (frame));
d1578 13
a1590 1
  if (regnum == SP_REGNUM && get_next_frame (frame))
d1593 2
a1594 2
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum),
			      get_frame_base (frame));
d1598 38
a1635 2
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), 
			      get_frame_extra_info (frame)->bsp);
d1642 3
a1644 4
	 still provide a value since we know the size of the frame */
      CORE_ADDR vfp = (get_frame_base (frame)
		       + get_frame_extra_info (frame)->mem_stack_frame_size);
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (IA64_VFP_REGNUM), vfp);
d1646 1
a1646 1
  else if (IA64_PR0_REGNUM <= regnum && regnum <= IA64_PR63_REGNUM)
d1648 1
a1648 1
      char pr_raw_buffer[MAX_REGISTER_SIZE];
d1650 1
d1653 4
a1656 4
      int prN_val;
      ia64_get_saved_register (pr_raw_buffer, &pr_optim, &pr_addr,
                               frame, IA64_PR_REGNUM, &pr_lval);
      if (IA64_PR16_REGNUM <= regnum && regnum <= IA64_PR63_REGNUM)
d1659 2
a1660 2
	     marker for this frame. */
	  int rrb_pr = (get_frame_extra_info (frame)->cfm >> 32) & 0x3f;
d1662 7
a1668 7
	  /* Adjust the register number to account for register rotation. */
	  regnum = IA64_PR16_REGNUM 
	         + ((regnum - IA64_PR16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = extract_bit_field ((unsigned char *) pr_raw_buffer,
                                   regnum - IA64_PR0_REGNUM, 1);
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), prN_val);
d1672 1
a1672 1
      char unat_raw_buffer[MAX_REGISTER_SIZE];
d1674 1
d1677 4
a1680 4
      int unatN_val;
      ia64_get_saved_register (unat_raw_buffer, &unat_optim, &unat_addr,
                               frame, IA64_UNAT_REGNUM, &unat_lval);
      unatN_val = extract_bit_field ((unsigned char *) unat_raw_buffer,
d1682 1
a1682 1
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), 
d1689 2
a1690 2
         interested in. */
      CORE_ADDR gr_addr = 0;
d1692 3
a1694 7
      if (!is_dummy_frame)
	{
	  DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
	  gr_addr = get_frame_saved_regs (frame)[ regnum - IA64_NAT0_REGNUM 
						+ IA64_GR0_REGNUM];
	}
      if (gr_addr)
d1696 1
a1696 1
	  /* Compute address of nat collection bits */
d1698 1
a1698 1
	  CORE_ADDR bsp = read_register (IA64_BSP_REGNUM);
d1703 3
a1705 1
	     collection from the computed address. */
d1707 4
a1710 1
	    nat_collection = read_register (IA64_RNAT_REGNUM);
d1716 2
a1717 1
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), natval);
d1721 7
a1727 6
      CORE_ADDR pc;
      if (get_next_frame (frame))
        {
	  /* FIXME: Set *addrp, *lval when possible. */
	  pc = ia64_frame_saved_pc (get_next_frame (frame));
        }
d1729 7
a1735 2
        {
	  pc = read_pc ();
d1737 2
a1738 1
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (IA64_IP_REGNUM), pc);
d1740 1
a1740 1
  else if (IA64_GR32_REGNUM <= regnum && regnum <= IA64_GR127_REGNUM)
d1742 14
a1755 2
      CORE_ADDR addr = 0;
      if (!is_dummy_frame)
d1757 6
a1762 2
	  DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
	  addr = get_frame_saved_regs (frame)[regnum];
d1764 12
a1775 1

d1778 3
a1780 5
	  if (lval != NULL)
	    *lval = lval_memory;
	  if (addrp != NULL)
	    *addrp = addr;
	  read_memory (addr, raw_buffer, REGISTER_RAW_SIZE (regnum));
d1782 1
a1782 1
      else
d1784 21
a1804 3
	  /* r32 - r127 must be fetchable via memory.  If they aren't,
	     then the register is unavailable */
	  memset (raw_buffer, 0, REGISTER_RAW_SIZE (regnum));
d1809 1
d1813 2
a1814 2
	     frame marker for this frame. */
	  int rrb_fr = (get_frame_extra_info (frame)->cfm >> 25) & 0x7f;
d1817 1
a1817 1
	     register rotation. */
d1822 68
a1889 2
      deprecated_generic_get_saved_register (raw_buffer, optimized, addrp,
					     frame, regnum, lval);
d1893 84
d1988 1
a1988 1
     case. */
d1995 1
a1995 1
     Don't use the struct convention for those either. */
d2000 1
a2000 1
ia64_extract_return_value (struct type *type, char *regbuf, char *valbuf)
d2007 1
d2014 3
a2016 2
	  ia64_register_convert_to_virtual (regnum, float_elt_type,
	    &regbuf[REGISTER_BYTE (regnum)], valbuf + offset);
d2022 7
a2028 3
    memcpy (valbuf, &regbuf[REGISTER_BYTE (IA64_GR8_REGNUM)],
	    TYPE_LENGTH (type));
}
d2030 8
a2037 4
/* FIXME: Turn this into a stack of some sort.  Unfortunately, something
   like this is necessary though since the IA-64 calling conventions specify
   that r8 is not preserved. */
static CORE_ADDR struct_return_address;
d2039 6
a2044 20
CORE_ADDR
ia64_extract_struct_value_address (char *regbuf)
{
  /* FIXME: See above. */
  return struct_return_address;
}

static void
ia64_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  /* FIXME: See above. */
  /* Note that most of the work was done in ia64_push_dummy_call() */
  struct_return_address = addr;
}

int
ia64_frameless_function_invocation (struct frame_info *frame)
{
  DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
  return (get_frame_extra_info (frame)->mem_stack_frame_size == 0);
d2048 1
a2048 1
ia64_saved_pc_after_call (struct frame_info *frame)
d2050 2
a2051 1
  return read_register (IA64_BR0_REGNUM);
a2053 85
static CORE_ADDR
ia64_frame_args_address (struct frame_info *frame)
{
  /* frame->frame points at the SP for this frame; But we want the start
     of the frame, not the end.  Calling frame chain will get his for us. */
  return ia64_frame_chain (frame);
}

static CORE_ADDR
ia64_frame_locals_address (struct frame_info *frame)
{
  /* frame->frame points at the SP for this frame; But we want the start
     of the frame, not the end.  Calling frame chain will get his for us. */
  return ia64_frame_chain (frame);
}

static void
ia64_init_extra_frame_info (int fromleaf, struct frame_info *frame)
{
  CORE_ADDR bsp, cfm;
  int next_frame_is_call_dummy = ((get_next_frame (frame) != NULL)
    && DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (get_next_frame (frame)),
				    get_frame_base (get_next_frame (frame)),
				    get_frame_base (get_next_frame (frame))));

  frame_extra_info_zalloc (frame, sizeof (struct frame_extra_info));

  if (get_next_frame (frame) == 0)
    {
      bsp = read_register (IA64_BSP_REGNUM);
      cfm = read_register (IA64_CFM_REGNUM);

    }
  else if ((get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME))
    {
      bsp = read_sigcontext_register (get_next_frame (frame), IA64_BSP_REGNUM);
      cfm = read_sigcontext_register (get_next_frame (frame), IA64_CFM_REGNUM);
    }
  else if (next_frame_is_call_dummy)
    {
      bsp = deprecated_read_register_dummy (get_frame_pc (get_next_frame (frame)),
					    get_frame_base (get_next_frame (frame)),
					    IA64_BSP_REGNUM);
      cfm = deprecated_read_register_dummy (get_frame_pc (get_next_frame (frame)),
					    get_frame_base (get_next_frame (frame)),
					    IA64_CFM_REGNUM);
    }
  else
    {
      struct frame_info *frn = get_next_frame (frame);

      DEPRECATED_FRAME_INIT_SAVED_REGS (frn);

      if (get_frame_saved_regs (frn)[IA64_CFM_REGNUM] != 0)
	cfm = read_memory_integer (get_frame_saved_regs (frn)[IA64_CFM_REGNUM], 8);
      else if (get_next_frame (frn) && (get_frame_type (get_next_frame (frn)) == SIGTRAMP_FRAME))
	cfm = read_sigcontext_register (get_next_frame (frn), IA64_PFS_REGNUM);
      else if (get_next_frame (frn)
               && DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (get_next_frame (frn)),
					       get_frame_base (get_next_frame (frn)),
					       get_frame_base (get_next_frame (frn))))
	cfm = deprecated_read_register_dummy (get_frame_pc (get_next_frame (frn)),
					      get_frame_base (get_next_frame (frn)),
					      IA64_PFS_REGNUM);
      else
	cfm = read_register (IA64_PFS_REGNUM);

      bsp = get_frame_extra_info (frn)->bsp;
    }
  get_frame_extra_info (frame)->cfm = cfm;
  get_frame_extra_info (frame)->sof = cfm & 0x7f;
  get_frame_extra_info (frame)->sol = (cfm >> 7) & 0x7f;
  if (get_next_frame (frame) == 0 
      || (get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME) 
      || next_frame_is_call_dummy)
    get_frame_extra_info (frame)->bsp =
      rse_address_add (bsp, -get_frame_extra_info (frame)->sof);
  else
    get_frame_extra_info (frame)->bsp =
      rse_address_add (bsp, -get_frame_extra_info (frame)->sol);

  get_frame_extra_info (frame)->after_prologue = 0;
  get_frame_extra_info (frame)->mem_stack_frame_size = -1;		/* Not yet determined */
  get_frame_extra_info (frame)->fp_reg = 0;
}
d2093 1
a2093 1
   bottom-most elements are all of the same floating point type.) */
d2107 1
a2107 1
   and Runtime manual.)  */
d2205 1
a2205 1
   not found. */
d2211 1
a2211 1
  /* Return early if faddr is already a function descriptor */
d2253 1
a2253 1
   stack using the address at fdaptr */
d2285 7
a2291 1
ia64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
d2302 1
a2302 3
  ULONGEST bsp, cfm, pfs, new_bsp;
  CORE_ADDR funcdescaddr;
  ULONGEST global_pointer = FIND_GLOBAL_POINTER (func_addr);
d2306 1
a2306 1
  /* Count the number of slots needed for the arguments */
d2322 1
a2322 1
  /* Divvy up the slots between the RSE and the memory stack */
d2326 2
a2327 2
  /* Allocate a new RSE frame */
  regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);
d2329 1
a2329 2
  regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
  bsp = rse_address_add (bsp, cfm & 0x7f);
d2331 1
a2331 1
  regcache_cooked_write_unsigned (regcache, IA64_BSP_REGNUM, new_bsp);
d2333 1
a2333 1
  regcache_cooked_read_unsigned (regcache, IA64_PFS_REGNUM, &pfs);
d2336 1
a2336 1
  regcache_cooked_write_unsigned (regcache, IA64_PFS_REGNUM, pfs);
d2340 1
a2340 1
  regcache_cooked_write_unsigned (regcache, IA64_CFM_REGNUM, cfm);
d2344 1
a2344 1
     case, we'll need to reserve space on the stack for them. */
d2350 1
a2350 1
     necessary for the memory slots and our function descriptors */
d2352 1
a2352 1
  sp &= ~0xfLL;				/* Maintain 16 byte alignment */
d2357 1
a2357 1
     floating point registers. */
d2368 1
a2368 1
      /* Special handling for function parameters */
d2386 1
a2386 1
      /* Normal slots */
d2410 1
a2410 1
      /* Handle floating point types (including HFAs) */
d2418 4
a2421 6
	      char buf[MAX_REGISTER_SIZE];
	      ia64_register_convert_to_raw (float_elt_type,
					    floatreg,
					    VALUE_CONTENTS (arg) + argoffset,
					    buf);
	      regcache_raw_write (regcache, floatreg, buf);
d2429 1
a2429 1
  /* Store the struct return value in r8 if necessary. */
d2432 1
a2432 1
      regcache_cooked_write_unsigned (regcache, IA64_GR8_REGNUM, struct_addr);
d2435 2
d2438 1
a2438 1
    regcache_cooked_write_unsigned (regcache, IA64_GR1_REGNUM, global_pointer);
d2440 1
a2440 1
  regcache_cooked_write_unsigned (regcache, IA64_BR0_REGNUM, bp_addr);
d2442 1
a2442 2
  /* Sync gdb's idea of what the registers are with the target. */
  target_store_registers (-1);
d2444 2
a2445 7
  /* FIXME: This doesn't belong here!  Instead,
     DEPRECATED_SAVE_DUMMY_FRAME_TOS needs to be defined to call
     generic_save_dummy_frame_tos().  But at the time of this writing,
     DEPRECATED_SAVE_DUMMY_FRAME_TOS wasn't gdbarch'd, so I chose to
     put this call here instead of using the old mechanisms.  Once
     DEPRECATED_SAVE_DUMMY_FRAME_TOS is gdbarch'd, all we need to do
     is add the line
d2447 5
a2451 1
	set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
d2453 2
a2454 2
     to ia64_gdbarch_init() and remove the line below. */
  generic_save_dummy_frame_tos (sp);
d2456 1
a2456 1
  return sp;
d2459 2
a2460 2
static void
ia64_store_return_value (struct type *type, char *valbuf)
d2462 2
a2463 10
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      ia64_register_convert_to_raw (type, IA64_FR8_REGNUM, valbuf,
				    &deprecated_registers[REGISTER_BYTE (IA64_FR8_REGNUM)]);
      target_store_registers (IA64_FR8_REGNUM);
    }
  else
    deprecated_write_register_bytes (REGISTER_BYTE (IA64_GR8_REGNUM),
				     valbuf, TYPE_LENGTH (type));
}
d2465 7
a2471 4
static void
ia64_pop_frame (void)
{
  generic_pop_current_frame (ia64_pop_frame_regular);
d2475 1
a2475 1
ia64_pop_frame_regular (struct frame_info *frame)
d2477 1
a2477 6
  int regno;
  CORE_ADDR bsp, cfm, pfs;

  DEPRECATED_FRAME_INIT_SAVED_REGS (frame);

  for (regno = 0; regno < ia64_num_regs; regno++)
d2479 4
a2482 24
      if (get_frame_saved_regs (frame)[regno]
	  && (!(IA64_GR32_REGNUM <= regno && regno <= IA64_GR127_REGNUM))
	  && regno != pc_regnum
	  && regno != sp_regnum
	  && regno != IA64_PFS_REGNUM
	  && regno != IA64_CFM_REGNUM
	  && regno != IA64_BSP_REGNUM
	  && regno != IA64_BSPSTORE_REGNUM)
	{
	  write_register (regno, 
			  read_memory_integer (get_frame_saved_regs (frame)[regno],
					       REGISTER_RAW_SIZE (regno)));
	}
    }

  write_register (sp_regnum, DEPRECATED_FRAME_CHAIN (frame));
  write_pc (DEPRECATED_FRAME_SAVED_PC (frame));

  cfm = read_register (IA64_CFM_REGNUM);

  if (get_frame_saved_regs (frame)[IA64_PFS_REGNUM])
    {
      pfs = read_memory_integer (get_frame_saved_regs (frame)[IA64_PFS_REGNUM],
				 REGISTER_RAW_SIZE (IA64_PFS_REGNUM));
d2485 1
a2485 19
    pfs = read_register (IA64_PFS_REGNUM);

  /* Compute the new bsp by *adding* the difference between the
     size of the frame and the size of the locals (both wrt the
     frame that we're going back to).  This seems kind of strange,
     especially since it seems like we ought to be subtracting the
     size of the locals... and we should; but the Linux kernel
     wants bsp to be set at the end of all used registers.  It's
     likely that this code will need to be revised to accomodate
     other operating systems. */
  bsp = rse_address_add (get_frame_extra_info (frame)->bsp,
                         (pfs & 0x7f) - ((pfs >> 7) & 0x7f));
  write_register (IA64_BSP_REGNUM, bsp);

  /* FIXME: What becomes of the epilog count in the PFS? */
  cfm = (cfm & ~0xffffffffffffLL) | (pfs & 0xffffffffffffLL);
  write_register (IA64_CFM_REGNUM, cfm);

  flush_cached_frames ();
d2524 1
a2524 1
	  /* The case numbers are from abi-tags in glibc */
d2568 1
a2568 1
         sections too. */
a2591 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);

d2618 6
d2633 2
a2634 1
  set_gdbarch_num_regs (gdbarch, ia64_num_regs);
a2635 2
  set_gdbarch_deprecated_fp_regnum (gdbarch, fp_regnum);
  set_gdbarch_pc_regnum (gdbarch, pc_regnum);
d2639 2
d2642 9
a2650 7
  set_gdbarch_deprecated_register_bytes (gdbarch, ia64_num_regs * 8 + 128*8);
  set_gdbarch_deprecated_register_byte (gdbarch, ia64_register_byte);
  set_gdbarch_deprecated_register_raw_size (gdbarch, ia64_register_raw_size);
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 16);
  set_gdbarch_deprecated_register_virtual_size (gdbarch, ia64_register_virtual_size);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 16);
  set_gdbarch_deprecated_register_virtual_type (gdbarch, ia64_register_virtual_type);
a2653 14
  set_gdbarch_frameless_function_invocation (gdbarch, ia64_frameless_function_invocation);

  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, ia64_saved_pc_after_call);

  set_gdbarch_deprecated_frame_chain (gdbarch, ia64_frame_chain);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, ia64_frame_saved_pc);

  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, ia64_frame_init_saved_regs);
  set_gdbarch_deprecated_get_saved_register (gdbarch, ia64_get_saved_register);

  set_gdbarch_deprecated_register_convertible (gdbarch, ia64_register_convertible);
  set_gdbarch_deprecated_register_convert_to_virtual (gdbarch, ia64_register_convert_to_virtual);
  set_gdbarch_deprecated_register_convert_to_raw (gdbarch, ia64_register_convert_to_raw);

d2655 1
a2655 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, ia64_extract_return_value);
d2657 2
a2658 3
  set_gdbarch_deprecated_store_struct_return (gdbarch, ia64_store_struct_return);
  set_gdbarch_deprecated_store_return_value (gdbarch, ia64_store_return_value);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, ia64_extract_struct_value_address);
d2668 2
a2669 1
  set_gdbarch_deprecated_pop_frame (gdbarch, ia64_pop_frame);
d2671 4
a2674 12
  set_gdbarch_deprecated_call_dummy_words (gdbarch, ia64_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (ia64_call_dummy_words));
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, ia64_init_extra_frame_info);
  set_gdbarch_deprecated_frame_args_address (gdbarch, ia64_frame_args_address);
  set_gdbarch_deprecated_frame_locals_address (gdbarch, ia64_frame_locals_address);

  /* We won't necessarily have a frame pointer and even if we do, it
     winds up being extraordinarly messy when attempting to find the
     frame chain.  So for the purposes of creating frames (which is
     all deprecated_read_fp() is used for), simply use the stack
     pointer value instead.  */
  set_gdbarch_deprecated_target_read_fp (gdbarch, ia64_read_fp);
a2677 2

  set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
@


1.91
log
@	* ia64-tdep.c (ia64_push_dummy_call): Define as combination of
	former ia64_push_arguments and ia64_push_return_address, and use
	regcache functions instead of read/write_register.
	(ia64_gdbarch_init): Set push_dummy_call instead of
	deprecated_push_arguments and deprecated_push_return_address.
@
text
@d2163 7
d2323 2
a2333 3

  deprecated_tm_print_insn = print_insn_ia64;
  deprecated_tm_print_insn_info.bytes_per_line = SLOT_MULTIPLIER;
@


1.90
log
@2003-06-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_ADDRESS): Add predicate.  Deprecate.
	(FRAME_LOCALS_ADDRESS): Add predicate.  Deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame-base.c (default_frame_args_address): Update.  Use
	default_frame_base_address when DEPRECATED_FRAME_ARGS_ADDRESS is
	not available.
	(default_frame_locals_address): Ditto for
	DEPRECATED_FRAME_LOCALS_ADDRESS.
	* vax-tdep.c (vax_sigtramp_saved_pc): Update.
	(vax_frame_num_args): Update.
	(vax_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* symtab.h (address_class): Update comments.
	* ns32k-tdep.c (ns32k_sigtramp_saved_pc): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_ARGS_ADDRESS): Update.
	(DEPRECATED_FRAME_LOCALS_ADDRESS): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_FRAME_ARGS_ADDRESS): Update.
	(DEPRECATED_FRAME_LOCALS_ADDRESS): Update.
	(DEPRECATED_FRAME_LOCALS_ADDRESS): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_ARGS_ADDRESS): Update.
	* alpha-mdebug-tdep.c: Update.
	* ada-lang.c (add_symbols_from_enclosing_procs): Update.
@
text
@d1523 1
a1523 1
  /* Note that most of the work was done in ia64_push_arguments() */
d1856 4
a1859 2
ia64_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		    int struct_return, CORE_ADDR struct_addr)
d1867 3
a1869 1
  CORE_ADDR bsp, cfm, pfs, new_bsp, funcdescaddr;
d1894 1
a1894 1
  cfm = read_register (IA64_CFM_REGNUM);
d1896 1
a1896 1
  bsp = read_register (IA64_BSP_REGNUM);
d1899 1
a1899 1
  write_register (IA64_BSP_REGNUM, new_bsp);
d1901 1
a1901 1
  pfs = read_register (IA64_PFS_REGNUM);
d1904 1
a1904 1
  write_register (IA64_PFS_REGNUM, pfs);
d1908 1
a1908 1
  write_register (IA64_CFM_REGNUM, cfm);
d1986 6
a1991 5
	      ia64_register_convert_to_raw (
		float_elt_type,
		floatreg,
	        VALUE_CONTENTS (arg) + argoffset,
		&deprecated_registers[REGISTER_BYTE (floatreg)]);
d2002 1
a2002 3
      store_unsigned_integer (&deprecated_registers[REGISTER_BYTE (IA64_GR8_REGNUM)],
			      REGISTER_RAW_SIZE (IA64_GR8_REGNUM),
			      struct_addr);
d2005 5
a2028 12
static CORE_ADDR
ia64_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  CORE_ADDR global_pointer = FIND_GLOBAL_POINTER (pc);

  if (global_pointer != 0)
    write_register (IA64_GR1_REGNUM, global_pointer);

  write_register (IA64_BR0_REGNUM, CALL_DUMMY_ADDRESS ());
  return sp;
}

d2288 1
a2288 2
  set_gdbarch_deprecated_push_arguments (gdbarch, ia64_push_arguments);
  set_gdbarch_deprecated_push_return_address (gdbarch, ia64_push_return_address);
@


1.89
log
@2003-06-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (SAVE_DUMMY_FRAME_TOS): Deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* infcall.c (call_function_by_hand): Update.
	* ia64-tdep.c (ia64_push_arguments): Update comment.
	* frame.c (legacy_get_prev_frame): Do not assume
	SAVE_DUMMY_FRAME_TOS_P.
	* dummy-frame.c (find_dummy_frame): Update comment.
@
text
@d2299 2
a2300 2
  set_gdbarch_frame_args_address (gdbarch, ia64_frame_args_address);
  set_gdbarch_frame_locals_address (gdbarch, ia64_frame_locals_address);
@


1.89.2.1
log
@	* ia64-tdep.c (ia64_push_dummy_call): Define as combination of
	former ia64_push_arguments and ia64_push_return_address, and use
	regcache functions instead of read/write_register.
	(ia64_gdbarch_init): Set push_dummy_call instead of
	deprecated_push_arguments and deprecated_push_return_address.
@
text
@d1523 1
a1523 1
  /* Note that most of the work was done in ia64_push_dummy_call() */
d1856 2
a1857 4
ia64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr,
		      int nargs, struct value **args, CORE_ADDR sp,
		      int struct_return, CORE_ADDR struct_addr)
d1865 1
a1865 3
  ULONGEST bsp, cfm, pfs, new_bsp;
  CORE_ADDR funcdescaddr;
  ULONGEST global_pointer = FIND_GLOBAL_POINTER (func_addr);
d1890 1
a1890 1
  regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);
d1892 1
a1892 1
  regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
d1895 1
a1895 1
  regcache_cooked_write_unsigned (regcache, IA64_BSP_REGNUM, new_bsp);
d1897 1
a1897 1
  regcache_cooked_read_unsigned (regcache, IA64_PFS_REGNUM, &pfs);
d1900 1
a1900 1
  regcache_cooked_write_unsigned (regcache, IA64_PFS_REGNUM, pfs);
d1904 1
a1904 1
  regcache_cooked_write_unsigned (regcache, IA64_CFM_REGNUM, cfm);
d1982 5
a1986 6
	      char buf[MAX_REGISTER_SIZE];
	      ia64_register_convert_to_raw (float_elt_type,
					    floatreg,
					    VALUE_CONTENTS (arg) + argoffset,
					    buf);
	      regcache_raw_write (regcache, floatreg, buf);
d1997 3
a1999 1
      regcache_cooked_write_unsigned (regcache, IA64_GR8_REGNUM, struct_addr);
a2001 5
  if (global_pointer != 0)
    regcache_cooked_write_unsigned (regcache, IA64_GR1_REGNUM, global_pointer);

  regcache_cooked_write_unsigned (regcache, IA64_BR0_REGNUM, bp_addr);

d2021 12
d2292 2
a2293 1
  set_gdbarch_push_dummy_call (gdbarch, ia64_push_dummy_call);
@


1.89.2.2
log
@	* ia64-tdep.c (ia64_print_insn): New function.
	(ia64_gdbarch_init): Set print_insn to it.
	(_initialize_ia64_tdep): Don't set deprecated_tm_print_insn and
	deprecated_tm_print_insn_info.
@
text
@a2162 7
static int
ia64_print_insn (bfd_vma memaddr, struct disassemble_info *info)
{
  info->bytes_per_line = SLOT_MULTIPLIER;
  return print_insn_ia64 (memaddr, info);
}

a2315 2
  set_gdbarch_print_insn (gdbarch, ia64_print_insn);

d2325 3
@


1.89.2.3
log
@
2003-08-27  Jeff Johnston  <jjohnstn@@redhat.com>

	Sync ia64-tdep.c with mainline.

	2003-08-26  Jeff Johnston  <jjohnstn@@redhat.com>
	* ia64-tdep.c (examine_prologue): Only stop at predicated insns if
	we are frameless or the return address register is already known.

	2003-08-26  Jeff Johnston  <jjohnstn@@redhat.com>
	* ia64-tdep.c (ia64_convert_from_func_addr): New function.
	(ia64_gdbarch_init): Call set_gdbarch_convert_from_func_addr().

	2003-08-25  Jeff Johnston  <jjohnstn@@redhat.com>
	* ia64-tdep.c (pseudo_regs): New enum that lists gr32-gr127, p0-p63,
	bof, and nat0-nat127 as pseudo-registers.
	(ia64_frame_cache): New struct used to cache frame info.
	(ia64_register_reggroup_p): New routine used to override default
	register grouping so registers without names are still saved and
	restored.
	(ia64_dwarf_reg_to_regnum): New routine to map gr32-gr127 to their
	pseudo values.
	(ia64_pseudo_register_read): New routine to read pseudo-registers.
	(ia64_pseudo_register_write): New routine to write pseudo-registers.
	(ia64_alloc_frame_cache): New routine to create a new
	ia64_frame_cache.
	(examine_prologue): Change prototype to add next_frame pointer.
	Assume frameless until otherwise proven.  Verify that the cfm for
	current frame matches the cfm that should occur for the prologues
	alloc insn and if equal, mark as not frameless.  At end of routine,
	if not frameless, calculate registers for the previous frame and store
	in the cache, if a cache is provided.
	(ia64_skip_prologue):  Use new prototype when calling examine_prologue
	and pass 0 for next_frame.
	(ia64_store_return_value): Change to use convert_typed_floating()
	instead of calling ia64_convert_to_raw().
	(ia64_extract_return_value): Change to use convert_typed_floating()
	instead of calling ia64_convert_to_virtual().
	(ia64_frame_cache): New routine to support new frame model.
	(ia64_frame_this_id, ia64_frame_prev_register): Ditto.
	(ia64_frame_sniffer): Ditto.
	(ia64_sigtramp_frame_init_saved_regs): Ditto.
	(ia64_sigtramp_frame_cache, ia64_sigtramp_frame_this_id): Ditto.
	(ia64_sigtramp_frame_prev_register): Ditto.
	(ia64_sigtramp_frame_sniffer): Ditto.
	(ia64_frame_base_address): Ditto.
	(ia64_extract_struct_value_address): Change to issue error message.
	(ia64_frame_align): New routine to align sp.
	(ia64_push_dummy_call): New routine based on ia64_push_arguments().
	(ia64_push_arguments): Removed.  Logic moved to
	ia64_push_dummy_call().
	(ia64_push_return_address): Ditto.
	(ia64_unwind_dummy_id): New function.
	(ia64_unwind_pc): Ditto.
	(ia64_convert_register_p): Ditto.
	(ia64_register_to_value): Ditto.
	(ia64_value_to_register): Ditto.
	(ia64_pop_frame, ia64_pop_frame_regular): Removed.
	(ia64_register_byte, ia64_register_raw_size): Ditto.
	(ia64_register_virtual_size, ia64_register_virtual_byte): Ditto.
	(ia64_saved_pc_after_call): Ditto.
	(ia64_frame_chain, ia64_frame_saved_pc): Ditto.
	(ia64_frame_init_saved_regs, ia64_get_saved_register): Ditto.
	(ia64_register_convertible, ia64_register_convert_to_virtual): Ditto.
	(ia64_register_convert_to_raw): Ditto.
	(ia64_store_struct_return, ia64_call_dummy_words): Ditto.
	(ia64_init_extra_frame_info): Ditto.
	(ia64_frame_args_address, ia64_frame_locals_address): Ditto.
	(ia64_gdbarch_init): Remove registering of deprecated functions that
	are no longer used.  Add registration of new gdbarch functions.
	Remove registering deprecated_write_sp.  Replace
	set_gdbarch_register_virtual_type() with set_gdbarch_register_type().
	Delete set_gdbarch_deprecated_register_convertible(),
	set_gdbarch_deprecated_register_convert_to_virtual(), and
	set_gdbarch_deprecated_register_convert_to_raw() calls.  Remove
	set_gdbarch_deprecated_register_size(),
	set_gdbarch_deprecated_register_bytes(),
	set_gdbarch_pcregnum(),
	set_gdbarch_deprecated_register_byte(),
	set_gdbarch_deprecated_register_raw_size(),
	set_gdbarch_deprecated_max_register_raw_size(),
	set_gdbarch_deprecated_register_virtual_size(),
	and set_gdbarch_deprecated_max_register_virtual_size() calls.
	Replace set_gdbarch_deprecated_extract_return_value() with
	set_gdbarch_extract_return_value().  Remove calls to:
	set_gdbarch_deprecated_saved_pc_after_call();
	set_gdbarch_deprecated_frame_chain(),
	set_gdbarch_deprecated_frame_saved_pc(),
	set_gdbarch_deprecated_frame_init_saved_regs(),
	set_gdbarch_deprecated_get_saved_register(),
	set_gdbarch_deprecated_call_dummy_words(),
	set_gdbarch_deprecated_sizeof_call_dummy_words(),
	set_gdbarch_deprecated_init_extra_frame_info(),
	set_gdbarch_deprecated_frame_args_address(),
	set_gdbarch_deprecated_frame_locals_address(),
	and set_gdbarch_deprecated_dummy_write_sp().
	Add set_gdbarch_convert_register_p(),
	set_gdbarch_register_to_value(),
	set_gdbarch_value_to_register(),
	set_gdbarch_push_dummy_call(),
	set_gdbarch_frame_align(),
	set_gdbarch_unwind_dummy_id(),
	set_gdbarch_unwind_pc(),
	frame_unwind_append_sniffer(),
	frame_unwind_append_sniffer(),
	and frame_base_set_default().
@
text
@a28 4
#include "reggroups.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
a88 1
static gdbarch_register_type_ftype ia64_register_type;
d91 2
a92 2
static gdbarch_extract_return_value_ftype ia64_extract_return_value;
static gdbarch_extract_struct_value_address_ftype ia64_extract_struct_value_address;
d94 3
d99 1
a99 3
static struct type *builtin_type_ia64_ext;

#define NUM_IA64_RAW_REGS 462
d101 1
d106 1
a106 5
/* NOTE: we treat the register stack registers r32-r127 as pseudo-registers because
   they are in memory and must be calculated via the bsp register.  */
enum pseudo_regs { FIRST_PSEUDO_REGNUM = NUM_IA64_RAW_REGS, VBOF_REGNUM = IA64_NAT127_REGNUM + 1, V32_REGNUM, 
		   V127_REGNUM = V32_REGNUM + 95, 
		   VP0_REGNUM, VP16_REGNUM = VP0_REGNUM + 16, VP63_REGNUM = VP0_REGNUM + 63, LAST_PSEUDO_REGNUM };
d116 12
a127 12
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
d146 8
a153 8
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
a193 24

  "bof",
  
  "r32",  "r33",  "r34",  "r35",  "r36",  "r37",  "r38",  "r39",   
  "r40",  "r41",  "r42",  "r43",  "r44",  "r45",  "r46",  "r47",
  "r48",  "r49",  "r50",  "r51",  "r52",  "r53",  "r54",  "r55",
  "r56",  "r57",  "r58",  "r59",  "r60",  "r61",  "r62",  "r63",
  "r64",  "r65",  "r66",  "r67",  "r68",  "r69",  "r70",  "r71",
  "r72",  "r73",  "r74",  "r75",  "r76",  "r77",  "r78",  "r79",
  "r80",  "r81",  "r82",  "r83",  "r84",  "r85",  "r86",  "r87",
  "r88",  "r89",  "r90",  "r91",  "r92",  "r93",  "r94",  "r95",
  "r96",  "r97",  "r98",  "r99",  "r100", "r101", "r102", "r103",
  "r104", "r105", "r106", "r107", "r108", "r109", "r110", "r111",
  "r112", "r113", "r114", "r115", "r116", "r117", "r118", "r119",
  "r120", "r121", "r122", "r123", "r124", "r125", "r126", "r127",

  "p0",   "p1",   "p2",   "p3",   "p4",   "p5",   "p6",   "p7",
  "p8",   "p9",   "p10",  "p11",  "p12",  "p13",  "p14",  "p15",
  "p16",  "p17",  "p18",  "p19",  "p20",  "p21",  "p22",  "p23",
  "p24",  "p25",  "p26",  "p27",  "p28",  "p29",  "p30",  "p31",
  "p32",  "p33",  "p34",  "p35",  "p36",  "p37",  "p38",  "p39",
  "p40",  "p41",  "p42",  "p43",  "p44",  "p45",  "p46",  "p47",
  "p48",  "p49",  "p50",  "p51",  "p52",  "p53",  "p54",  "p55",
  "p56",  "p57",  "p58",  "p59",  "p60",  "p61",  "p62",  "p63",
d196 15
a210 20
struct ia64_frame_cache
{
  CORE_ADDR base;       /* frame pointer base for frame */
  CORE_ADDR pc;		/* function start pc for frame */
  CORE_ADDR saved_sp;	/* stack pointer for frame */
  CORE_ADDR bsp;	/* points at r32 for the current frame */
  CORE_ADDR cfm;	/* cfm value for current frame */
  int   frameless;
  int   sof;		/* Size of frame  (decoded from cfm value) */
  int	sol;		/* Size of locals (decoded from cfm value) */
  int	sor;		/* Number of rotating registers. (decoded from cfm value) */
  CORE_ADDR after_prologue;
  /* Address of first instruction after the last
     prologue instruction;  Note that there may
     be instructions from the function's body
     intermingled with the prologue. */
  int mem_stack_frame_size;
  /* Size of the memory stack frame (may be zero),
     or -1 if it has not been determined yet. */
  int	fp_reg;		/* Register number (if any) used a frame pointer
d213 1
a213 5
  
  /* Saved registers.  */
  CORE_ADDR saved_regs[NUM_IA64_RAW_REGS];

};
d232 2
a233 3
int
ia64_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *group)
d235 1
a235 17
  int vector_p;
  int float_p;
  int raw_p;
  if (group == all_reggroup)
    return 1;
  vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));
  float_p = TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT;
  raw_p = regnum < NUM_IA64_RAW_REGS;
  if (group == float_reggroup)
    return float_p;
  if (group == vector_reggroup)
    return vector_p;
  if (group == general_reggroup)
    return (!vector_p && !float_p);
  if (group == save_reggroup || group == restore_reggroup)
    return raw_p; 
  return 0;
d238 2
a239 2
static const char *
ia64_register_name (int reg)
d241 1
a241 1
  return ia64_register_names[reg];
d244 2
a245 2
struct type *
ia64_register_type (struct gdbarch *arch, int reg)
d247 1
a247 4
  if (reg >= IA64_FR0_REGNUM && reg <= IA64_FR127_REGNUM)
    return builtin_type_ia64_ext;
  else
    return builtin_type_long;
d250 2
d253 1
a253 1
ia64_dwarf_reg_to_regnum (int reg)
d255 1
a255 3
  if (reg >= IA64_GR32_REGNUM && reg <= IA64_GR127_REGNUM)
    return V32_REGNUM + (reg - IA64_GR32_REGNUM);
  return reg;
d264 42
d680 24
a703 3
static void
ia64_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
                           int regnum, void *buf)
d705 7
a711 1
  if (regnum >= V32_REGNUM && regnum <= V127_REGNUM)
d713 3
a715 16
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get start of register frame.  */
      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	{
	  ULONGEST reg_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
	  reg = read_memory_integer ((CORE_ADDR)reg_addr, 8);
	  store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), reg);
	}
d717 2
a718 81
	store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), 0);
    }
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT31_REGNUM)
    {
      ULONGEST unatN_val;
      ULONGEST unat;
      regcache_cooked_read_unsigned (regcache, IA64_UNAT_REGNUM, &unat);
      unatN_val = (unat & (1LL << (regnum - IA64_NAT0_REGNUM))) != 0;
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), unatN_val);
    }
  else if (IA64_NAT32_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      ULONGEST natN_val = 0;
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR gr_addr = 0;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get start of register frame.  */
      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	gr_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
      
      if (gr_addr != 0)
	{
	  /* Compute address of nat collection bits.  */
	  CORE_ADDR nat_addr = gr_addr | 0x1f8;
	  CORE_ADDR nat_collection;
	  int nat_bit;
	  /* If our nat collection address is bigger than bsp, we have to get
	     the nat collection from rnat.  Otherwise, we fetch the nat
	     collection from the computed address.  */
	  if (nat_addr >= bsp)
	    regcache_cooked_read_unsigned (regcache, IA64_RNAT_REGNUM, &nat_collection);
	  else
	    nat_collection = read_memory_integer (nat_addr, 8);
	  nat_bit = (gr_addr >> 3) & 0x3f;
	  natN_val = (nat_collection >> nat_bit) & 1;
	}
      
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), natN_val);
    }
  else if (regnum == VBOF_REGNUM)
    {
      /* A virtual register frame start is provided for user convenience.
         It can be calculated as the bsp - sof (sizeof frame). */
      ULONGEST bsp, vbsp;
      ULONGEST cfm;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get beginning of frame.  */
      vbsp = rse_address_add (bsp, -(cfm & 0x7f));
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), vbsp);
    }
  else if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    {
      ULONGEST pr;
      ULONGEST cfm;
      ULONGEST prN_val;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_PR_REGNUM, &pr);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  /* Fetch predicate register rename base from current frame
	     marker for this frame. */
	  int rrb_pr = (cfm >> 32) & 0x3f;

	  /* Adjust the register number to account for register rotation. */
	  regnum = VP16_REGNUM 
	         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = (pr & (1LL << (regnum - VP0_REGNUM))) != 0;
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), prN_val);
a719 2
  else
    memset (buf, 0, REGISTER_RAW_SIZE (regnum));
d722 2
a723 3
static void
ia64_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int regnum, const void *buf)
d725 8
a732 17
  if (regnum >= V32_REGNUM && regnum <= V127_REGNUM)
    {
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	{
	  ULONGEST reg_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
	  write_memory (reg_addr, (void *)buf, 8);
	}
    }
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT31_REGNUM)
d734 1
a734 18
      ULONGEST unatN_val, unat, unatN_mask;
      regcache_cooked_read_unsigned (regcache, IA64_UNAT_REGNUM, &unat);
      unatN_val = extract_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum)); 
      unatN_mask = (1LL << (regnum - IA64_NAT0_REGNUM));
      if (unatN_val == 0)
	unat &= ~unatN_mask;
      else if (unatN_val == 1)
	unat |= unatN_mask;
      regcache_cooked_write_unsigned (regcache, IA64_UNAT_REGNUM, unat);
    }
  else if (IA64_NAT32_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      ULONGEST natN_val;
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR gr_addr = 0;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);
d736 7
a742 68
      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get start of register frame.  */
      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	gr_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
      
      natN_val = extract_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum)); 

      if (gr_addr != 0 && (natN_val == 0 || natN_val == 1))
	{
	  /* Compute address of nat collection bits.  */
	  CORE_ADDR nat_addr = gr_addr | 0x1f8;
	  CORE_ADDR nat_collection;
	  int natN_bit = (gr_addr >> 3) & 0x3f;
	  ULONGEST natN_mask = (1LL << natN_bit);
	  /* If our nat collection address is bigger than bsp, we have to get
	     the nat collection from rnat.  Otherwise, we fetch the nat
	     collection from the computed address.  */
	  if (nat_addr >= bsp)
	    {
	      regcache_cooked_read_unsigned (regcache, IA64_RNAT_REGNUM, &nat_collection);
	      if (natN_val)
		nat_collection |= natN_mask;
	      else
		nat_collection &= ~natN_mask;
	      regcache_cooked_write_unsigned (regcache, IA64_RNAT_REGNUM, nat_collection);
	    }
	  else
	    {
	      char nat_buf[8];
	      nat_collection = read_memory_integer (nat_addr, 8);
	      if (natN_val)
		nat_collection |= natN_mask;
	      else
		nat_collection &= ~natN_mask;
	      store_unsigned_integer (nat_buf, REGISTER_RAW_SIZE (regnum), nat_collection);
	      write_memory (nat_addr, nat_buf, 8);
	    }
	}
    }
  else if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    {
      ULONGEST pr;
      ULONGEST cfm;
      ULONGEST prN_val;
      ULONGEST prN_mask;

      regcache_cooked_read_unsigned (regcache, IA64_PR_REGNUM, &pr);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  /* Fetch predicate register rename base from current frame
	     marker for this frame. */
	  int rrb_pr = (cfm >> 32) & 0x3f;

	  /* Adjust the register number to account for register rotation. */
	  regnum = VP16_REGNUM 
	         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = extract_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum)); 
      prN_mask = (1LL << (regnum - VP0_REGNUM));
      if (prN_val == 0)
	pr &= ~prN_mask;
      else if (prN_val == 1)
	pr |= prN_mask;
      regcache_cooked_write_unsigned (regcache, IA64_PR_REGNUM, pr);
a745 28
/* The ia64 needs to convert between various ieee floating-point formats
   and the special ia64 floating point register format.  */

static int
ia64_convert_register_p (int regno, struct type *type)
{
  return (regno >= IA64_FR0_REGNUM && regno <= IA64_FR127_REGNUM);
}

static void
ia64_register_to_value (struct frame_info *frame, int regnum,
                         struct type *valtype, void *out)
{
  char in[MAX_REGISTER_SIZE];
  frame_register_read (frame, regnum, in);
  convert_typed_floating (in, builtin_type_ia64_ext, out, valtype);
}

static void
ia64_value_to_register (struct frame_info *frame, int regnum,
                         struct type *valtype, const void *in)
{
  char out[MAX_REGISTER_SIZE];
  convert_typed_floating (in, valtype, out, builtin_type_ia64_ext);
  put_frame_register (frame, regnum, out);
}


a816 27
/* Allocate and initialize a frame cache.  */

static struct ia64_frame_cache *
ia64_alloc_frame_cache (void)
{
  struct ia64_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct ia64_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->pc = 0;
  cache->cfm = 0;
  cache->sof = 0;
  cache->sol = 0;
  cache->sor = 0;
  cache->bsp = 0;
  cache->fp_reg = 0;
  cache->frameless = 1;

  for (i = 0; i < NUM_IA64_RAW_REGS; i++)
    cache->saved_regs[i] = 0;

  return cache;
}

d818 1
a818 1
examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc, struct frame_info *next_frame, struct ia64_frame_cache *cache)
d824 2
d838 1
a838 5
  int frameless = 1;
  int i;
  CORE_ADDR addr;
  char buf[8];
  CORE_ADDR bof, sor, sol, sof, cfm, rrb_gr;
d844 11
a854 3
  if (cache->after_prologue != 0
      && cache->after_prologue <= lim_pc)
    return cache->after_prologue;
d868 4
a872 11

      /* Verify that the current cfm matches what we think is the
	 function start.  If we have somehow jumped within a function,
	 we do not want to interpret the prologue and calculate the
	 addresses of various registers such as the return address.  
	 We will instead treat the frame as frameless. */
      if (!next_frame ||
	  (sof == (cache->cfm & 0x7f) &&
	   sol == ((cache->cfm >> 7) & 0x7f)))
	frameless = 0;

d895 1
d918 2
a919 9
      if (it == B && ((instr & 0x1e1f800003f) != 0x04000000000))
	{
	  /* Exit loop upon hitting a non-nop branch instruction. */ 
	  if (trust_limit)
	    lim_pc = pc;
	  break;
	}
      else if (((instr & 0x3fLL) != 0LL) && 
	       (frameless || ret_reg != 0))
d921 2
a922 2
	  /* Exit loop upon hitting a predicated instruction if
	     we already have the return register or if we are frameless.  */ 
a965 2
	      char buf[MAX_REGISTER_SIZE];
	      CORE_ADDR saved_sp = 0;
d978 1
a978 6
	      if (next_frame)
		{
		  frame_unwind_register (next_frame, sp_regnum, buf);
		  saved_sp = extract_unsigned_integer (buf, 8);
		}
	      spill_addr  = saved_sp
d1014 2
a1015 1
	      cache->saved_regs[IA64_FR0_REGNUM + fM] = spill_addr;
d1074 2
a1075 1
		  cache->saved_regs[IA64_UNAT_REGNUM] = spill_addr;
d1081 2
a1082 1
		  cache->saved_regs[IA64_PR_REGNUM] = spill_addr;
d1165 2
a1166 1
	      cache->saved_regs[IA64_GR0_REGNUM + rM] = spill_addr;
d1179 33
a1211 2
  /* If not frameless and we aren't called by skip_prologue, then we need to calculate
     registers for the previous frame which will be needed later.  */
d1213 1
a1213 1
  if (!frameless && next_frame)
d1215 3
a1217 58
      /* Extract the size of the rotating portion of the stack
	 frame and the register rename base from the current
	 frame marker. */
      cfm = cache->cfm;
      sor = cache->sor;
      sof = cache->sof;
      sol = cache->sol;
      rrb_gr = (cfm >> 18) & 0x7f;

      /* Find the bof (beginning of frame).  */
      bof = rse_address_add (cache->bsp, -sof);
      
      for (i = 0, addr = bof;
	   i < sof;
	   i++, addr += 8)
	{
	  if (IS_NaT_COLLECTION_ADDR (addr))
	    {
	      addr += 8;
	    }
	  if (i+32 == cfm_reg)
	    cache->saved_regs[IA64_CFM_REGNUM] = addr;
	  if (i+32 == ret_reg)
	    cache->saved_regs[IA64_VRAP_REGNUM] = addr;
	  if (i+32 == fp_reg)
	    cache->saved_regs[IA64_VFP_REGNUM] = addr;
	}

      /* For the previous argument registers we require the previous bof.  
	 If we can't find the previous cfm, then we can do nothing.  */
      if (cache->saved_regs[IA64_CFM_REGNUM] != 0)
	{
	  cfm = read_memory_integer (cache->saved_regs[IA64_CFM_REGNUM], 8);
	  sor = ((cfm >> 14) & 0xf) * 8;
	  sof = (cfm & 0x7f);
	  sol = (cfm >> 7) & 0x7f;
	  rrb_gr = (cfm >> 18) & 0x7f;

	  /* The previous bof only requires subtraction of the sol (size of locals)
	     due to the overlap between output and input of subsequent frames.  */
	  bof = rse_address_add (bof, -sol);
	  
	  for (i = 0, addr = bof;
	       i < sof;
	       i++, addr += 8)
	    {
	      if (IS_NaT_COLLECTION_ADDR (addr))
		{
		  addr += 8;
		}
	      if (i < sor)
		cache->saved_regs[IA64_GR32_REGNUM + ((i + (sor - rrb_gr)) % sor)] 
		  = addr;
	      else
		cache->saved_regs[IA64_GR32_REGNUM + i] = addr;
	    }
	  
	}
d1219 1
a1219 1
      
d1222 1
a1222 6
    last_prologue_pc = lim_pc;

  cache->frameless = frameless;
  cache->after_prologue = last_prologue_pc;
  cache->mem_stack_frame_size = mem_stack_frame_size;
  cache->fp_reg = fp_reg;
d1230 1
a1230 8
  struct ia64_frame_cache cache;
  cache.base = 0;
  cache.after_prologue = 0;
  cache.cfm = 0;
  cache.bsp = 0;

  /* Call examine_prologue with - as third argument since we don't have a next frame pointer to send.  */
  return examine_prologue (pc, pc+1024, 0, &cache);
d1233 2
a1234 5

/* Normal frames.  */

static struct ia64_frame_cache *
ia64_frame_cache (struct frame_info *next_frame, void **this_cache)
d1236 2
a1237 4
  struct ia64_frame_cache *cache;
  char buf[8];
  CORE_ADDR cfm, sof, sol, bsp, psr;
  int i;
d1239 3
a1241 2
  if (*this_cache)
    return *this_cache;
d1243 1
a1243 2
  cache = ia64_alloc_frame_cache ();
  *this_cache = cache;
d1245 36
a1280 2
  frame_unwind_register (next_frame, sp_regnum, buf);
  cache->saved_sp = extract_unsigned_integer (buf, 8);
d1282 3
a1284 26
  /* We always want the bsp to point to the end of frame.
     This way, we can always get the beginning of frame (bof)
     by subtracting frame size.  */
  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
  cache->bsp = extract_unsigned_integer (buf, 8);
  
  frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
  psr = extract_unsigned_integer (buf, 8);

  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
  cfm = extract_unsigned_integer (buf, 8);

  cache->sof = (cfm & 0x7f);
  cache->sol = (cfm >> 7) & 0x7f;
  cache->sor = ((cfm >> 14) & 0xf) * 8;

  cache->cfm = cfm;

  cache->pc = frame_func_unwind (next_frame);

  if (cache->pc != 0)
    examine_prologue (cache->pc, frame_pc_unwind (next_frame), next_frame, cache);
  
  cache->base = cache->saved_sp + cache->mem_stack_frame_size;

  return cache;
d1288 6
a1293 2
ia64_frame_this_id (struct frame_info *next_frame, void **this_cache,
		    struct frame_id *this_id)
d1295 1
a1295 2
  struct ia64_frame_cache *cache =
    ia64_frame_cache (next_frame, this_cache);
d1297 2
a1298 3
  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d1300 2
a1301 2
  (*this_id) = frame_id_build (cache->base, cache->pc);
}
d1303 2
a1304 10
static void
ia64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *valuep)
{
  struct ia64_frame_cache *cache =
    ia64_frame_cache (next_frame, this_cache);
  char dummy_valp[MAX_REGISTER_SIZE];
  char buf[8];
d1306 2
a1307 1
  gdb_assert (regnum >= 0);
d1309 3
a1311 2
  if (!target_has_registers)
    error ("No registers.");
d1313 1
a1313 13
  *optimizedp = 0;
  *addrp = 0;
  *lvalp = not_lval;
  *realnump = -1;

  /* Rather than check each time if valuep is non-null, supply a dummy buffer
     when valuep is not supplied.  */
  if (!valuep)
    valuep = dummy_valp;
  
  memset (valuep, 0, REGISTER_RAW_SIZE (regnum));
 
  if (regnum == SP_REGNUM)
d1316 2
a1317 2
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum),
			      cache->base);
d1321 2
a1322 38
      char cfm_valuep[MAX_REGISTER_SIZE];
      int  cfm_optim;
      int  cfm_realnum;
      enum lval_type cfm_lval;
      CORE_ADDR cfm_addr;
      CORE_ADDR bsp, prev_cfm, prev_bsp;

      /* We want to calculate the previous bsp as the end of the previous register stack frame.
	 This corresponds to what the hardware bsp register will be if we pop the frame
	 back which is why we might have been called.  We know the beginning of the current
         frame is cache->bsp - cache->sof.  This value in the previous frame points to
	 the start of the output registers.  We can calculate the end of that frame by adding
	 the size of output (sof (size of frame) - sol (size of locals)).  */
      ia64_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
				&cfm_optim, &cfm_lval, &cfm_addr, &cfm_realnum, cfm_valuep);
      prev_cfm = extract_unsigned_integer (cfm_valuep, 8);

      bsp = rse_address_add (cache->bsp, -(cache->sof));
      prev_bsp = rse_address_add (bsp, (prev_cfm & 0x7f) - ((prev_cfm >> 7) & 0x7f));

      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum), 
			      prev_bsp);
    }
  else if (regnum == IA64_CFM_REGNUM)
    {
      CORE_ADDR addr = 0;

      if (cache->frameless)
	{
	  CORE_ADDR cfm = 0;
	  frame_unwind_register (next_frame, IA64_PFS_REGNUM, valuep);
	}
      else
	{
	  addr = cache->saved_regs[IA64_CFM_REGNUM];
	  if (addr != 0)
	    read_memory (addr, valuep, REGISTER_RAW_SIZE (regnum));
	}
d1329 4
a1332 3
	 still provide a value since we know the size of the frame.  */
      CORE_ADDR vfp = cache->base;
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (IA64_VFP_REGNUM), vfp);
d1334 1
a1334 1
  else if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
d1336 1
a1336 1
      char pr_valuep[MAX_REGISTER_SIZE];
a1337 1
      int  pr_realnum;
d1340 4
a1343 4
      ULONGEST prN_val;
      ia64_frame_prev_register (next_frame, this_cache, IA64_PR_REGNUM,
				&pr_optim, &pr_lval, &pr_addr, &pr_realnum, pr_valuep);
      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
d1346 2
a1347 2
	     marker for this frame.  */
	  int rrb_pr = (cache->cfm >> 32) & 0x3f;
d1349 7
a1355 7
	  /* Adjust the register number to account for register rotation.  */
	  regnum = VP16_REGNUM 
	         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = extract_bit_field ((unsigned char *) pr_valuep,
                                   regnum - VP0_REGNUM, 1);
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum), prN_val);
d1359 1
a1359 1
      char unat_valuep[MAX_REGISTER_SIZE];
a1360 1
      int  unat_realnum;
d1363 4
a1366 4
      ULONGEST unatN_val;
      ia64_frame_prev_register (next_frame, this_cache, IA64_UNAT_REGNUM,
				&unat_optim, &unat_lval, &unat_addr, &unat_realnum, unat_valuep);
      unatN_val = extract_bit_field ((unsigned char *) unat_valuep,
d1368 1
a1368 1
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum), 
d1375 2
a1376 2
         interested in.  */
      CORE_ADDR gr_addr;
d1378 1
a1378 3
      gr_addr = cache->saved_regs[regnum - IA64_NAT0_REGNUM 
				  + IA64_GR0_REGNUM];
      if (gr_addr != 0)
d1380 7
a1386 1
	  /* Compute address of nat collection bits.  */
d1388 1
a1388 1
	  CORE_ADDR bsp;
d1393 1
a1393 3
	     collection from the computed address.  */
	  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
	  bsp = extract_unsigned_integer (buf, 8); 
d1395 1
a1395 4
	    {
	      frame_unwind_register (next_frame, IA64_RNAT_REGNUM, buf);
	      nat_collection = extract_unsigned_integer (buf, 8);
	    }
d1401 1
a1401 2

      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum), natval);
d1405 6
a1410 7
      CORE_ADDR pc = 0;

      if (cache->frameless)
	{
	  frame_unwind_register (next_frame, IA64_BR0_REGNUM, buf);
	  pc = extract_unsigned_integer (buf, 8);
	}
d1412 2
a1413 7
	{
	  CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];
	  if (addr != 0)
	    {
	      read_memory (addr, buf, REGISTER_RAW_SIZE (IA64_IP_REGNUM));
	      pc = extract_unsigned_integer (buf, 8);
	    }
d1415 1
a1415 2
      pc &= ~0xf;
      store_unsigned_integer (valuep, 8, pc);
d1417 1
a1417 1
  else if (regnum == IA64_PSR_REGNUM)
d1419 2
a1420 8
      ULONGEST slot_num = 0;
      CORE_ADDR pc= 0;
      CORE_ADDR psr = 0;

      frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
      psr = extract_unsigned_integer (buf, 8);

      if (cache->frameless)
d1422 2
a1423 3
	  CORE_ADDR pc;
	  frame_unwind_register (next_frame, IA64_BR0_REGNUM, buf);
	  pc = extract_unsigned_integer (buf, 8);
d1425 1
a1425 21
      else
	{
	  CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];
	  if (addr != 0)
	    {
	      read_memory (addr, buf, REGISTER_RAW_SIZE (IA64_IP_REGNUM));
	      pc = extract_unsigned_integer (buf, 8);
	    }
	}
      psr &= ~(3LL << 41);
      slot_num = pc & 0x3LL;
      psr |= (CORE_ADDR)slot_num << 41;
      store_unsigned_integer (valuep, 8, psr);
    }
 else if ((regnum >= IA64_GR32_REGNUM && regnum <= IA64_GR127_REGNUM) ||
	   (regnum >= V32_REGNUM && regnum <= V127_REGNUM))
    {
      CORE_ADDR addr = 0;
      if (regnum >= V32_REGNUM)
	regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);
      addr = cache->saved_regs[regnum];
d1428 5
a1432 3
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, REGISTER_RAW_SIZE (regnum));
d1434 1
a1434 1
      else if (cache->frameless)
d1436 3
a1438 21
	  char r_valuep[MAX_REGISTER_SIZE];
	  int  r_optim;
	  int  r_realnum;
	  enum lval_type r_lval;
	  CORE_ADDR r_addr;
	  CORE_ADDR prev_cfm, prev_bsp, prev_bof;
	  CORE_ADDR addr = 0;
	  if (regnum >= V32_REGNUM)
	    regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);
	  ia64_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
				    &r_optim, &r_lval, &r_addr, &r_realnum, r_valuep); 
	  prev_cfm = extract_unsigned_integer (r_valuep, 8);
	  ia64_frame_prev_register (next_frame, this_cache, IA64_BSP_REGNUM,
				    &r_optim, &r_lval, &r_addr, &r_realnum, r_valuep);
	  prev_bsp = extract_unsigned_integer (r_valuep, 8);
	  prev_bof = rse_address_add (prev_bsp, -(prev_cfm & 0x7f));

	  addr = rse_address_add (prev_bof, (regnum - IA64_GR32_REGNUM));
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, REGISTER_RAW_SIZE (regnum));
a1442 1
      CORE_ADDR addr = 0;
d1446 2
a1447 2
	     frame marker for this frame.  */
	  int rrb_fr = (cache->cfm >> 25) & 0x7f;
d1450 1
a1450 1
	     register rotation.  */
d1455 2
a1456 68
      /* If we have stored a memory address, access the register.  */
      addr = cache->saved_regs[regnum];
      if (addr != 0)
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, REGISTER_RAW_SIZE (regnum));
	}
      /* Otherwise, punt and get the current value of the register.  */
      else 
	frame_unwind_register (next_frame, regnum, valuep);
    }
}
 
static const struct frame_unwind ia64_frame_unwind =
{
  NORMAL_FRAME,
  &ia64_frame_this_id,
  &ia64_frame_prev_register
};

static const struct frame_unwind *
ia64_frame_sniffer (struct frame_info *next_frame)
{
  return &ia64_frame_unwind;
}

/* Signal trampolines.  */

static void
ia64_sigtramp_frame_init_saved_regs (struct ia64_frame_cache *cache)
{
  if (SIGCONTEXT_REGISTER_ADDRESS)
    {
      int regno;

      cache->saved_regs[IA64_VRAP_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_IP_REGNUM);
      cache->saved_regs[IA64_CFM_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_CFM_REGNUM);
      cache->saved_regs[IA64_PSR_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_PSR_REGNUM);
#if 0
      cache->saved_regs[IA64_BSP_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_BSP_REGNUM);
#endif
      cache->saved_regs[IA64_RNAT_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_RNAT_REGNUM);
      cache->saved_regs[IA64_CCV_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_CCV_REGNUM);
      cache->saved_regs[IA64_UNAT_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_UNAT_REGNUM);
      cache->saved_regs[IA64_FPSR_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_FPSR_REGNUM);
      cache->saved_regs[IA64_PFS_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_PFS_REGNUM);
      cache->saved_regs[IA64_LC_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_LC_REGNUM);
      for (regno = IA64_GR1_REGNUM; regno <= IA64_GR31_REGNUM; regno++)
	if (regno != sp_regnum)
	  cache->saved_regs[regno] =
	    SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
      for (regno = IA64_BR0_REGNUM; regno <= IA64_BR7_REGNUM; regno++)
	cache->saved_regs[regno] =
	  SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
      for (regno = IA64_FR2_REGNUM; regno <= IA64_BR7_REGNUM; regno++)
	cache->saved_regs[regno] =
	  SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
a1459 84
static struct ia64_frame_cache *
ia64_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct ia64_frame_cache *cache;
  CORE_ADDR addr;
  char buf[8];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = ia64_alloc_frame_cache ();

  frame_unwind_register (next_frame, sp_regnum, buf);
  cache->base = extract_unsigned_integer (buf, 8) + cache->mem_stack_frame_size;

  ia64_sigtramp_frame_init_saved_regs (cache);

  *this_cache = cache;
  return cache;
}

static void
ia64_sigtramp_frame_this_id (struct frame_info *next_frame,
			       void **this_cache, struct frame_id *this_id)
{
  struct ia64_frame_cache *cache =
    ia64_sigtramp_frame_cache (next_frame, this_cache);

  (*this_id) = frame_id_build (cache->base, frame_pc_unwind (next_frame));
}

static void
ia64_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, void *valuep)
{
  /* Make sure we've initialized the cache.  */
  ia64_sigtramp_frame_cache (next_frame, this_cache);

  ia64_frame_prev_register (next_frame, this_cache, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind ia64_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  ia64_sigtramp_frame_this_id,
  ia64_sigtramp_frame_prev_register
};

static const struct frame_unwind *
ia64_sigtramp_frame_sniffer (struct frame_info *next_frame)
{
  char *name;
  CORE_ADDR pc = frame_pc_unwind (next_frame);

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    return &ia64_sigtramp_frame_unwind;

  return NULL;
}


static CORE_ADDR
ia64_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct ia64_frame_cache *cache =
    ia64_frame_cache (next_frame, this_cache);

  return cache->base;
}

static const struct frame_base ia64_frame_base =
{
  &ia64_frame_unwind,
  ia64_frame_base_address,
  ia64_frame_base_address,
  ia64_frame_base_address
};

d1471 1
a1471 1
     case.  */
d1478 1
a1478 1
     Don't use the struct convention for those either.  */
d1483 1
a1483 1
ia64_extract_return_value (struct type *type, struct regcache *regcache, void *valbuf)
a1489 1
      char from[MAX_REGISTER_SIZE];
d1496 2
a1497 3
	  regcache_cooked_read (regcache, regnum, from);
	  convert_typed_floating (from, builtin_type_ia64_ext,
				  (char *)valbuf + offset, float_elt_type);	  
d1503 15
a1517 7
    {
      ULONGEST val;
      int offset = 0;
      int regnum = IA64_GR8_REGNUM;
      int reglen = TYPE_LENGTH (ia64_register_type (NULL, IA64_GR8_REGNUM));
      int n = TYPE_LENGTH (type) / reglen;
      int m = TYPE_LENGTH (type) % reglen;
d1519 7
a1525 8
      while (n-- > 0)
	{
	  ULONGEST val;
	  regcache_cooked_read_unsigned (regcache, regnum, &val);
	  memcpy ((char *)valbuf + offset, &val, reglen);
	  offset += reglen;
	  regnum++;
	}
d1527 5
a1531 6
      if (m)
	{
          regcache_cooked_read_unsigned (regcache, regnum, &val);
	  memcpy ((char *)valbuf + offset, &val, m);
	}
    }
d1535 1
a1535 1
ia64_extract_struct_value_address (struct regcache *regcache)
d1537 17
a1553 2
  error ("ia64_extract_struct_value_address called and cannot get struct value address");
  return 0;
d1556 69
d1664 1
a1664 1
   bottom-most elements are all of the same floating point type).  */
d1678 1
a1678 1
   and Runtime manual).  */
d1776 1
a1776 1
   not found.  */
d1782 1
a1782 1
  /* Return early if faddr is already a function descriptor.  */
d1824 1
a1824 1
   stack using the address at fdaptr.  */
a1854 3
/* Use the following routine when printing out function pointers
   so the user can see the function address rather than just the
   function descriptor.  */
d1856 1
a1856 21
ia64_convert_from_func_ptr_addr (CORE_ADDR addr)
{
  struct obj_section *s;

  s = find_pc_section (addr);

  /* check if ADDR points to a function descriptor.  */
  if (s && strcmp (s->the_bfd_section->name, ".opd") == 0)
    return read_memory_unsigned_integer (addr, 8);

  return addr;
}

static CORE_ADDR
ia64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  return sp & ~0xfLL;
}

static CORE_ADDR
ia64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr, 
d1867 3
a1869 1
  CORE_ADDR bsp, cfm, pfs, new_bsp, funcdescaddr, pc, global_pointer;
d1873 1
a1873 1
  /* Count the number of slots needed for the arguments.  */
d1889 1
a1889 1
  /* Divvy up the slots between the RSE and the memory stack.  */
d1893 2
a1894 2
  /* Allocate a new RSE frame.  */
  cfm = read_register (IA64_CFM_REGNUM);
d1896 2
a1897 1
  bsp = read_register (IA64_BSP_REGNUM);
d1899 1
a1899 1
  write_register (IA64_BSP_REGNUM, new_bsp);
d1901 1
a1901 1
  pfs = read_register (IA64_PFS_REGNUM);
d1904 1
a1904 1
  write_register (IA64_PFS_REGNUM, pfs);
d1908 1
a1908 1
  write_register (IA64_CFM_REGNUM, cfm);
d1912 1
a1912 1
     case, we'll need to reserve space on the stack for them.  */
d1918 1
a1918 1
     necessary for the memory slots and our function descriptors.  */
d1920 1
a1920 1
  sp &= ~0xfLL;				/* Maintain 16 byte alignment.  */
d1925 1
a1925 1
     floating point registers.  */
d1936 1
a1936 1
      /* Special handling for function parameters.  */
d1954 1
a1954 1
      /* Normal slots.  */
d1978 1
a1978 1
      /* Handle floating point types (including HFAs).  */
d1986 6
a1991 4
	      char to[MAX_REGISTER_SIZE];
	      convert_typed_floating (VALUE_CONTENTS (arg) + argoffset, float_elt_type,
				      to, builtin_type_ia64_ext);
	      regcache_cooked_write (regcache, floatreg, (void *)to);
d1999 1
a1999 1
  /* Store the struct return value in r8 if necessary.  */
d2002 1
a2002 1
      regcache_cooked_write_unsigned (regcache, IA64_GR8_REGNUM, (ULONGEST)struct_addr);
d2005 7
a2011 1
  global_pointer = FIND_GLOBAL_POINTER (func_addr);
d2013 7
a2019 2
  if (global_pointer != 0)
    write_register (IA64_GR1_REGNUM, global_pointer);
d2021 1
a2021 1
  write_register (IA64_BR0_REGNUM, bp_addr);
d2023 2
a2024 1
  write_register (sp_regnum, sp);
d2029 2
a2030 2
static struct frame_id
ia64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d2032 9
a2040 7
  char buf[8];
  CORE_ADDR sp;

  frame_unwind_register (next_frame, sp_regnum, buf);
  sp = extract_unsigned_integer (buf, 8);

  return frame_id_build (sp, frame_pc_unwind (next_frame));
d2043 2
a2044 2
static CORE_ADDR 
ia64_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d2046 1
a2046 10
  char buf[8];
  CORE_ADDR ip, psr, pc;

  frame_unwind_register (next_frame, IA64_IP_REGNUM, buf);
  ip = extract_unsigned_integer (buf, 8);
  frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
  psr = extract_unsigned_integer (buf, 8);
 
  pc = (ip & ~0xf) | ((psr >> 41) & 3);
  return pc;
d2050 1
a2050 1
ia64_store_return_value (struct type *type, struct regcache *regcache, const void *valbuf)
d2052 28
a2079 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d2081 2
a2082 4
      char to[MAX_REGISTER_SIZE];
      convert_typed_floating (valbuf, type, to, builtin_type_ia64_ext);
      regcache_cooked_write (regcache, IA64_FR8_REGNUM, (void *)to);
      target_store_registers (IA64_FR8_REGNUM);
d2085 19
a2103 1
    regcache_cooked_write (regcache, IA64_GR8_REGNUM, valbuf);
d2142 1
a2142 1
	  /* The case numbers are from abi-tags in glibc.  */
d2186 1
a2186 1
         sections too.  */
d2210 4
a2239 6
  /* Define the ia64 floating-point format to gdb.  */
  builtin_type_ia64_ext =
    init_type (TYPE_CODE_FLT, 128 / 8,
               0, "builtin_type_ia64_ext", NULL);
  TYPE_FLOATFORMAT (builtin_type_ia64_ext) = &floatformat_ia64_ext;

d2249 1
a2249 2
  set_gdbarch_num_regs (gdbarch, NUM_IA64_RAW_REGS);
  set_gdbarch_num_pseudo_regs (gdbarch, LAST_PSEUDO_REGNUM - FIRST_PSEUDO_REGNUM);
d2251 2
a2255 2
  /* FIXME:  Following interface should not be needed, however, without it recurse.exp
     gets a number of extra failures.  */
d2257 11
a2267 1
  set_gdbarch_register_type (gdbarch, ia64_register_type);
d2269 1
a2269 7
  set_gdbarch_pseudo_register_read (gdbarch, ia64_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, ia64_pseudo_register_write);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, ia64_dwarf_reg_to_regnum);
  set_gdbarch_register_reggroup_p (gdbarch, ia64_register_reggroup_p);
  set_gdbarch_convert_register_p (gdbarch, ia64_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, ia64_register_to_value);
  set_gdbarch_value_to_register (gdbarch, ia64_value_to_register);
d2271 9
a2279 1
  set_gdbarch_skip_prologue (gdbarch, ia64_skip_prologue);
d2282 1
a2282 1
  set_gdbarch_extract_return_value (gdbarch, ia64_extract_return_value);
d2284 3
a2286 2
  set_gdbarch_store_return_value (gdbarch, ia64_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch, ia64_extract_struct_value_address);
d2296 1
a2296 2
  set_gdbarch_frame_align (gdbarch, ia64_frame_align);
  set_gdbarch_unwind_dummy_id (gdbarch, ia64_unwind_dummy_id);
d2298 12
a2309 4
  set_gdbarch_unwind_pc (gdbarch, ia64_unwind_pc);
  frame_unwind_append_sniffer (gdbarch, ia64_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, ia64_frame_sniffer);
  frame_base_set_default (gdbarch, &ia64_frame_base);
d2314 2
a2323 1
  set_gdbarch_convert_from_func_ptr_addr (gdbarch, ia64_convert_from_func_ptr_addr);
@


1.89.2.4
log
@
2003-09-09  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c (ia64_sigtramp_frame_init_saved_regs):
        Fix typo for high range of floating registers.
@
text
@d1894 1
a1894 1
      for (regno = IA64_FR2_REGNUM; regno <= IA64_FR31_REGNUM; regno++)
@


1.88
log
@2003-06-14  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_register_to_value): Make static.
	(mips_value_to_register): Make static.
	* i386-tdep.c (i386_fetch_pointer_argument): Make static.
	* ia64-tdep.c (ia64_register_raw_size): Make static.
	(ia64_register_virtual_size): Make static.
	(ia64_register_byte): Make static.
	* i387-tdep.c: Include "i387-tdep.h".
	(print_387_control_word): Delete function.
	(print_387_status_word): Delete function.
	(print_387_status_bits): Delete function.
	(print_387_control_bits): Delete function.
	* Makefile.in (i387-tdep.o): Update dependencies.
	* rdi-share/host.h (Fail): Declare.
	* remote-rdi.c (Fail): Update to match declaration.
@
text
@d2005 7
a2011 6
  /* FIXME: This doesn't belong here!  Instead, SAVE_DUMMY_FRAME_TOS needs
     to be defined to call generic_save_dummy_frame_tos().  But at the
     time of this writing, SAVE_DUMMY_FRAME_TOS wasn't gdbarch'd, so
     I chose to put this call here instead of using the old mechanisms. 
     Once SAVE_DUMMY_FRAME_TOS is gdbarch'd, all we need to do is add the
     line
d2013 1
a2013 1
	set_gdbarch_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
@


1.87
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Update comments on registers, re-order.
	(deprecated_register_byte): Rename register_byte.
	(deprecated_register_raw_size): Rename register_raw_size.
	(deprecated_register_virtual_size): Rename register_virtual_size.
	(deprecated_register_virtual_type): Rename register_virtual_type.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c: Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
@
text
@d238 1
a238 1
int
d244 1
a244 1
int
d300 1
a300 1
int
@


1.86
log
@
2003-06-11  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c (ia64_gdbarch_init): Set number of long double
        bits to 128.
@
text
@a88 4
static gdbarch_register_raw_size_ftype ia64_register_raw_size;
static gdbarch_register_virtual_size_ftype ia64_register_virtual_size;
static gdbarch_register_virtual_type_ftype ia64_register_virtual_type;
static gdbarch_register_byte_ftype ia64_register_byte;
d2254 2
a2255 2
  set_gdbarch_register_byte (gdbarch, ia64_register_byte);
  set_gdbarch_register_raw_size (gdbarch, ia64_register_raw_size);
d2257 1
a2257 1
  set_gdbarch_register_virtual_size (gdbarch, ia64_register_virtual_size);
d2259 1
a2259 1
  set_gdbarch_register_virtual_type (gdbarch, ia64_register_virtual_type);
@


1.85
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_CONVERTIBLE): Deprecate
	REGISTER_CONVERTIBLE.
	(DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL): Same.
	(DEPRECATED_REGISTER_CONVERT_TO_RAW): Same, make "from" constant.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (deprecated_register_convertible_not): Rename
	generic_register_convertible_not.
	* arch-utils.c (deprecated_register_convertible_not): Rename
	generic_register_convertible.
	(legacy_convert_register_p, legacy_register_to_value): Update.
	* sh-tdep.c (sh64_push_arguments): Update.
	* m68klinux-tdep.c (m68k_linux_extract_return_value): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_EXTRACT_RETURN_VALUE): Update.
	* m68klinux-tdep.c (m68k_linux_store_return_value): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Update.
	* arch-utils.c (legacy_value_to_register): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	(rs6000_register_convert_to_raw): Make parameter "from" const.
	* mips-tdep.c (mips_gdbarch_init): Update.
	(mips_register_convert_to_raw): Make  parameter"virt_buf" const.
	* infcmd.c (default_print_registers_info): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_register_convert_to_raw): Make parameter "from" const.
	* i386-tdep.c (i386_gdbarch_init): Update.
	(i386_register_convert_to_raw): Update.
@
text
@d2246 1
a2246 1
  set_gdbarch_long_double_bit (gdbarch, 64);
@


1.84
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@d284 1
a284 1
                              char *from, char *to)
d2277 3
a2279 3
  set_gdbarch_register_convertible (gdbarch, ia64_register_convertible);
  set_gdbarch_register_convert_to_virtual (gdbarch, ia64_register_convert_to_virtual);
  set_gdbarch_register_convert_to_raw (gdbarch, ia64_register_convert_to_raw);
@


1.83
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_NUM_ARGS): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (frame_num_args_unknown): Delete both declarations.
	* arch-utils.c (frame_num_args_unknown): Delete function.
	* stack.c (print_args_stub): Use FRAME_NUM_ARGS_P.
	(frame_info): Use FRAME_NUM_ARGS_P.
	* arm-tdep.c (arm_frame_num_args): Delete function.
	(arm_gdbarch_init): Do not set frame_num_args.
	* config/pa/tm-hppa64.h (FRAME_NUM_ARGS): Delete.
	* hppa-tdep.c (hppa_frame_num_args): Delete function.
	(hppa_gdbarch_init): Do not set frame_num_args.
	* config/sparc/tm-sparc.h (FRAME_NUM_ARGS): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	frame_num_args to default frame_num_args_unknown.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d256 1
a256 1
int
d268 1
a268 1
void
d282 1
a282 1
void
d638 1
a638 1
CORE_ADDR
d648 1
a648 1
void
d706 1
a706 1
CORE_ADDR
d726 1
a726 1
CORE_ADDR
d1237 1
a1237 1
void
d1291 1
a1291 1
void
d1523 1
a1523 1
void
d1544 1
a1544 1
CORE_ADDR
d1552 1
a1552 1
CORE_ADDR
d1560 1
a1560 1
void
d1859 1
a1859 1
CORE_ADDR
d2024 1
a2024 1
CORE_ADDR
d2036 1
a2036 1
void
d2050 1
a2050 1
void
d2326 2
@


1.82
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* inferior.h (deprecated_write_sp): Replace
	generic_target_write_sp.
	* regcache.c (deprecated_write_sp): Replace
	generic_target_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Update.
@
text
@a2266 1
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
@


1.81
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (TARGET_READ_SP): Add predicate, delete default.
	* gdbarch.h, gdbarch.c: Regenerate.
	* mn10300-tdep.c: Include "gdb_assert.h".
	(mn10300_read_fp): New function.
	(mn10300_gdbarch_init): Set deprecated_target_read_fp to
	mn10300_read_fp.  Do not set read_sp to generic_target_read_sp.
	* ia64-tdep.c: Include "gdb_assert.h".
	(ia64_read_fp): New function.
	(ia64_gdbarch_init): Set deprecated_target_read_fp to
	ia64_read_sp.  Do not set read_sp to generic_target_read_sp.
	* regcache.c (generic_target_read_sp): Delete function.
	(read_sp): Try TARGET_READ_SP and SP_REGNUM for the SP register.
	* inferior.h (generic_target_read_sp): Delete declaration.
	* frv-tdep.c (frv_gdbarch_init): Do not set read_sp to
	generic_target_read_sp.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* Makefile.in (mn10300-tdep.o, ia64-tdep.o): Update dependencies.
@
text
@d2316 1
a2316 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.80
log
@2003-06-01  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (extract_address): Delete declaration.
	* findvar.c (extract_address): Delete function.
	* xstormy16-tdep.c (xstormy16_extract_return_value): Replace
	extract_address with the inline equivalent,
	extract_unsigned_integer.
	(xstormy16_extract_struct_value_address): Ditto.
	(xstormy16_pointer_to_address): Ditto.
	* vax-tdep.c (vax_extract_struct_value_address): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	(v850_extract_return_value): Ditto.
	(v850_extract_struct_value_address): Ditto.
	* sparcnbsd-tdep.c (sparcnbsd_get_longjmp_target_32): Ditto.
	(sparcnbsd_get_longjmp_target_64): Ditto.
	* sparc-tdep.c (sparc_frame_saved_pc): Ditto.
	(get_longjmp_target): Ditto.
	* sh-tdep.c (sh_extract_struct_value_address): Ditto.
	(sh64_extract_struct_value_address): Ditto.
	(sh_push_arguments): Ditto.
	(sh64_push_arguments): Ditto.
	* remote-vxsparc.c (vx_read_register): Ditto.
	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Ditto.
	* ns32k-tdep.c (ns32k_extract_struct_value_address): Ditto.
	* mn10300-tdep.c (mn10300_extract_struct_value_address): Ditto.
	* mipsv4-nat.c (get_longjmp_target): Ditto.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Ditto.
	* mips-nat.c (get_longjmp_target): Ditto.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target): Ditto.
	* mcore-tdep.c (mcore_extract_struct_value_address): Ditto.
	* m68k-tdep.c (m68k_get_longjmp_target): Ditto.
	* m68hc11-tdep.c (m68hc11_extract_struct_value_address): Ditto.
	* irix5-nat.c (get_longjmp_target): Ditto.
	* irix4-nat.c (get_longjmp_target): Ditto.
	* ia64-tdep.c (generic_elf_find_global_pointer): Ditto.
	(ia64_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_store_registers): Ditto.
	* h8300-tdep.c (h8300_push_arguments): Ditto.
	(h8300_store_return_value): Ditto.
	(h8300_extract_struct_value_address): Ditto.
	* frv-tdep.c (frv_extract_struct_value_address): Ditto.
	(frv_push_arguments): Ditto.
	* avr-tdep.c (avr_pointer_to_address): Ditto.
	(avr_push_arguments): Ditto.
	* arm-tdep.c (arm_push_dummy_call): Ditto.
	(arm_get_longjmp_target): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_extract_struct_value_address): Ditto.
	(alpha_get_longjmp_target): Ditto.
@
text
@d31 1
a31 1

d626 12
d2311 1
a2311 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, generic_target_read_sp);
a2315 1
  set_gdbarch_read_sp (gdbarch, generic_target_read_sp);
@


1.79
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d1750 1
a1750 1
		  global_pointer = extract_address (buf, sizeof (buf));
d1932 1
a1932 1
				  find_func_descr (extract_address (VALUE_CONTENTS (arg), 8),
@


1.78
log
@2003-05-15  Andrew Cagney  <cagney@@redhat.com>

	* arch-utils.h (legacy_breakpoint_from_pc): Delete declaration.
	* target.h (memory_breakpoint_from_pc): Delete declaration.
	* mem-break.c (memory_breakpoint_from_pc): Delete function.
	* arch-utils.c (legacy_breakpoint_from_pc): Delete function.
	* monitor.c (monitor_insert_breakpoint): Use
	gdbarch_breakpoint_from_pc instead of memory_breakpoint_from_pc.
	* gdbarch.sh (BREAKPOINT_FROM_PC): Do not provide a default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sparc-tdep.c (sparc_breakpoint_from_pc): New function.
	(sparc_gdbarch_init): Set breakpoint_from_pc to
	sparc_breakpoint_from_pc.
	* config/sparc/tm-sparc.h (BREAKPOINT): Delete macro.
	(BREAKPOINT_FROM_PC): Define.
	(sparc_breakpoint_from_pc): Declare.
	* hppa-tdep.c (hppa_breakpoint_from_pc): New function.
	* config/pa/tm-hppa.h (hppa_breakpoint_from_pc): Declare.
	(BREAKPOINT_FROM_PC): Define.
	(BREAKPOINT): Delete macro.
	* target.h: Update comment.
	* s390-tdep.c (s390_gdbarch_init): Update comments.
	* remote.c: Update comments.
	* remote-mips.c: Update comments.
	* proc-api.c (write_with_trace): Do not check for a breakpoint.
	* mem-break.c: Update comment.
	* ia64-tdep.c (IA64_BREAKPOINT): Rename BREAKPOINT.
	(ia64_memory_insert_breakpoint): Update.
	* config/sparc/tm-sparc.h: Update comment.
	* config/pa/tm-hppa64.h: Update comment.
	* rs6000-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(rs6000_breakpoint_from_pc): Update.
	* mips-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(PMON_BIG_BREAKPOINT, PMON_LITTLE_BREAKPOINT): Delete macro.
	(IDT_LITTLE_BREAKPOINT, IDT_LITTLE_BREAKPOINT): Delete macro.
	(MIPS16_LITTLE_BREAKPOINT, MIPS16_BIG_BREAKPOINT): Delete macro.
	(mips_breakpoint_from_pc): Update.
	(mips_dump_tdep): Update.
@
text
@d2245 1
a2245 1
  set_gdbarch_register_bytes (gdbarch, ia64_num_regs * 8 + 128*8);
@


1.77
log
@
2003-05-15  Jeff Johnston  <jjohnstn@@redhat.com>

        * ia64-tdep.c: Increase max_skip_non_prologue_insns to 40.
        (examine_prologue): Support looking through leaf functions, knowing
        they start with mov r2,r12.  Support skipping over indirect stores
        of the input registers.  Upon hitting a non-nop branch instruction
        or predicated instruction, bail out by setting lim_pc to the current
        pc value in the loop.  At the end, if the lim_pc value is still
        beyond our calculated value and we have trust_limit set,
        use the lim_pc value.
@
text
@d546 1
a546 1
#define BREAKPOINT 0x00002000040LL
d548 1
a548 1
#define BREAKPOINT 0x00003333300LL
d576 1
a576 1
  replace_slotN_contents (bundle, BREAKPOINT, slotnum);
@


1.76
log
@2003-05-13  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (store_address): Delete declaration.
	findvar.c (store_address): Delete function.
	* arm-tdep.c (arm_push_dummy_call): Replace store_address with
	store_unsigned_integer.
	* xstormy16-tdep.c (xstormy16_address_to_pointer): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	* sparc-tdep.c (sparc_get_saved_register): Ditto.
	* sh-tdep.c (sh64_get_saved_register): Ditto.
	* rs6000-tdep.c (rs6000_push_arguments): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Ditto.
	* mips-tdep.c (mips_eabi_push_arguments): Ditto.
	(mips_get_saved_register): Ditto.
	* ia64-tdep.c (ia64_get_saved_register): Ditto.
	(find_func_descr, ia64_push_arguments): Ditto.
	* i386-tdep.c (i386_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	* frv-tdep.c (frv_push_arguments): Ditto.
	* frame.c (legacy_saved_regs_prev_register): Ditto.
	(deprecated_generic_get_saved_register): Ditto.
	* findvar.c (unsigned_address_to_pointer): Ditto.
	* dwarf2read.c (dwarf2_const_value): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_push_arguments): Ditto.
@
text
@d740 1
a740 1
static int max_skip_non_prologue_insns = 10;
d828 1
d830 1
d834 1
d849 1
d851 2
a852 2
  /* Must start with an alloc instruction */
  next_pc = fetch_instruction (pc, &it, &instr);
d856 1
a856 1
      /* alloc */
d871 29
a899 3
      pc = lim_pc;	/* Frameless: We're done early.  */
      if (trust_limit)
	last_prologue_pc = lim_pc;
d915 2
d976 14
d1055 1
d1090 7
d1111 1
d1117 7
d1211 4
@


1.75
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d1242 2
a1243 2
      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
		     get_frame_base (frame));
d1247 2
a1248 2
      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), 
                     get_frame_extra_info (frame)->bsp);
d1258 1
a1258 1
      store_address (raw_buffer, REGISTER_RAW_SIZE (IA64_VFP_REGNUM), vfp);
d1341 1
a1341 1
      store_address (raw_buffer, REGISTER_RAW_SIZE (IA64_IP_REGNUM), pc);
d1772 2
a1773 2
      store_address (buf, 8, faddr);
      store_address (buf + 8, 8, global_pointer);
d1865 3
a1867 3
	  store_address (val_buf, 8,
	    find_func_descr (extract_address (VALUE_CONTENTS (arg), 8),
	                     &funcdescaddr));
d1923 3
a1925 3
      store_address (&deprecated_registers[REGISTER_BYTE (IA64_GR8_REGNUM)],
                     REGISTER_RAW_SIZE (IA64_GR8_REGNUM),
		     struct_addr);
@


1.75.4.1
log
@Snap const char * mess.
@
text
@d1242 2
a1243 2
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum),
			      get_frame_base (frame));
d1247 2
a1248 2
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), 
			      get_frame_extra_info (frame)->bsp);
d1258 1
a1258 1
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (IA64_VFP_REGNUM), vfp);
d1341 1
a1341 1
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (IA64_IP_REGNUM), pc);
d1772 2
a1773 2
      store_unsigned_integer (buf, 8, faddr);
      store_unsigned_integer (buf + 8, 8, global_pointer);
d1865 3
a1867 3
	  store_unsigned_integer (val_buf, 8,
				  find_func_descr (extract_address (VALUE_CONTENTS (arg), 8),
						   &funcdescaddr));
d1923 3
a1925 3
      store_unsigned_integer (&deprecated_registers[REGISTER_BYTE (IA64_GR8_REGNUM)],
			      REGISTER_RAW_SIZE (IA64_GR8_REGNUM),
			      struct_addr);
@


1.74
log
@2003-05-07  Andrew Cagney  <cagney@@redhat.com>

	* ia64-tdep.c (ia64_remote_translate_xfer_address): Add "gdbarch"
	and "regcache" parameters.
	* avr-tdep.c (avr_remote_translate_xfer_address): Ditto.
@
text
@d1262 1
a1262 1
      char *pr_raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
d1285 1
a1285 1
      char *unat_raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
@


1.73
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d2036 3
a2038 1
ia64_remote_translate_xfer_address (CORE_ADDR memaddr, int nr_bytes,
@


1.72
log
@2003-04-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn_info): Rename
	"tm_print_insn_info".
	(TARGET_PRINT_INSN_INFO): Delete macro.
	(dis_asm_read_memory): Delete function declaration.
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	(tm_print_insn_info): Delete variable definition.
	(_initialize_gdbarch): Do not initialize "tm_print_insn_info".
	* gdbarch.h, gdbarch.c: Re-generate.
	* d10v-tdep.c (display_trace): Replace "tm_print_insn_info" with
	"deprecated_tm_print_insn_info".
	* mcore-tdep.c (mcore_dump_insn): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* sparc-tdep.c (_initialize_sparc_tdep): Ditto.
	* v850-tdep.c (v850_scan_prologue, v850_gdbarch_init): Ditto.
	* ia64-tdep.c (_initialize_ia64_tdep): Ditto.
	* printcmd.c (print_insn): Use "deprecated_tm_print_insn_info"
	instead of TARGET_PRINT_INSN_INFO, add comment.
	* s390-tdep.c (s390_get_frame_info): Instead of
	"dis_asm_read_memory", use "deprecated_tm_print_insn_info".
	(s390_check_function_end, s390_is_sigreturn): Ditto.
	* corefile.c (dis_asm_read_memory): Move to "disasm.c".
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	* disasm.c: Include "gdbcore.h".
	(_initialize_disasm): New function, initialize
	"deprecated_tm_print_insn_info".
	(deprecated_tm_print_insn_info): New variable.
	(dis_asm_read_memory): Moved from "corefile.c", made static.
	(dis_asm_print_address, dis_asm_memory_error): Ditto.
	* Makefile.in (disasm.o): Update dependencies.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d2176 1
a2176 1
  set_gdbarch_register_size (gdbarch, 8);
d2220 2
a2221 2
  set_gdbarch_call_dummy_words (gdbarch, ia64_call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, sizeof (ia64_call_dummy_words));
@


1.71
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d2255 1
a2255 1
  tm_print_insn_info.bytes_per_line = SLOT_MULTIPLIER;
@


1.70
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn): Rename tm_print_insn.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (_initialize_xstormy16_tdep): Update.
	* vax-tdep.c (_initialize_vax_tdep): Update.
	* v850-tdep.c (_initialize_v850_tdep): Update.
	* sparc-tdep.c (_initialize_sparc_tdep): Update.
	* s390-tdep.c (_initialize_s390_tdep): Update.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Update.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* m68k-tdep.c (_initialize_m68k_tdep): Update.
	* ia64-tdep.c (_initialize_ia64_tdep): Update.
	* hppa-tdep.c (_initialize_hppa_tdep): Update.
	* h8300-tdep.c (_initialize_h8300_tdep): Update.
	* frv-tdep.c (_initialize_frv_tdep): Update.
	* cris-tdep.c (cris_delayed_get_disassembler): Update.
	(_initialize_cris_tdep): Update.
	* arch-utils.c (legacy_print_insn): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	"tm_print_insn" to "deprecated_tm_print_insn".
@
text
@d681 2
a682 2
   other places.  (E.g, note that read_fp() is actually read_sp() in
   ia64_gdbarch_init() below.)
d2171 1
a2171 1
  set_gdbarch_fp_regnum (gdbarch, fp_regnum);
d2226 6
a2231 6
  /* We won't necessarily have a frame pointer and even if we do,
     it winds up being extraordinarly messy when attempting to find
     the frame chain.  So for the purposes of creating frames (which
     is all read_fp() is used for), simply use the stack pointer value
     instead.  */
  set_gdbarch_read_fp (gdbarch, generic_target_read_sp);
@


1.69
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_SAVED_PC_AFTER_CALL): Deprecate
	SAVED_PC_AFTER_CALL.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_saved_pc_after_call): Update declaration.
	* i386ly-tdep.c (i386lynx_init_abi): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	* infrun.c (step_over_function): Update.
	* i386-linux-tdep.c (skip_hurd_resolver): Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	* arm-linux-tdep.c (skip_hurd_resolver): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	* x86-64-tdep.h (x86_64_linux_saved_pc_after_call): Update
	declaration.
@
text
@d2254 1
a2254 1
  tm_print_insn = print_insn_ia64;
@


1.69.2.1
log
@Merge from mainline.
@
text
@d681 2
a682 2
   other places.  (E.g, note that deprecated_read_fp() is actually
   read_sp() in ia64_gdbarch_init() below.)
d2171 1
a2171 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, fp_regnum);
d2226 6
a2231 6
  /* We won't necessarily have a frame pointer and even if we do, it
     winds up being extraordinarly messy when attempting to find the
     frame chain.  So for the purposes of creating frames (which is
     all deprecated_read_fp() is used for), simply use the stack
     pointer value instead.  */
  set_gdbarch_deprecated_target_read_fp (gdbarch, generic_target_read_sp);
d2254 2
a2255 2
  deprecated_tm_print_insn = print_insn_ia64;
  deprecated_tm_print_insn_info.bytes_per_line = SLOT_MULTIPLIER;
@


1.69.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d546 1
a546 1
#define IA64_BREAKPOINT 0x00002000040LL
d548 1
a548 1
#define IA64_BREAKPOINT 0x00003333300LL
d576 1
a576 1
  replace_slotN_contents (bundle, IA64_BREAKPOINT, slotnum);
d740 1
a740 1
static int max_skip_non_prologue_insns = 40;
a827 1
  char reg_contents[256];
a828 1
  int frameless = 0;
a831 1
  memset (reg_contents, 0, sizeof reg_contents);
d846 2
a848 3

  /* We want to check if we have a recognizable function start before we
     look ahead for a prologue.  */
d852 1
a852 1
      /* alloc - start of a regular function.  */
d867 3
a869 29
      /* Look for a leaf routine.  */
      if (pc < lim_pc && next_pc
	  && (it == I || it == M) 
          && ((instr & 0x1ee00000000LL) == 0x10800000000LL))
	{
	  /* adds rN = imm14, rM   (or mov rN, rM  when imm14 is 0) */
	  int imm = (int) ((((instr & 0x01000000000LL) ? -1 : 0) << 13) 
	                   | ((instr & 0x001f8000000LL) >> 20)
		           | ((instr & 0x000000fe000LL) >> 13));
	  int rM = (int) ((instr & 0x00007f00000LL) >> 20);
	  int rN = (int) ((instr & 0x00000001fc0LL) >> 6);
	  int qp = (int) (instr & 0x0000000003fLL);
	  if (qp == 0 && rN == 2 && imm == 0 && rM == 12 && fp_reg == 0)
	    {
	      /* mov r2, r12 - beginning of leaf routine */
	      fp_reg = rN;
	      frameless = 1;
	      last_prologue_pc = next_pc;
	    }
	} 

      /* If we don't recognize a regular function or leaf routine, we are
	 done.  */
      if (!fp_reg)
	{
	  pc = lim_pc;	
	  if (trust_limit)
	    last_prologue_pc = lim_pc;
	}
a884 2
	  if (trust_limit)
	    lim_pc = pc;
a943 14
	  else if (qp == 0 && rM >= 32 && rM < 40 && !instores[rM] && 
		   rN < 256 && imm == 0)
	    {
	      /* mov rN, rM where rM is an input register */
	      reg_contents[rN] = rM;
	      last_prologue_pc = next_pc;
	    }
	  else if (frameless && qp == 0 && rN == fp_reg && imm == 0 && 
		   rM == 2)
	    {
	      /* mov r12, r2 */
	      last_prologue_pc = next_pc;
	      break;
	    }
a1008 1
	  int indirect = rM < 256 ? reg_contents[rM] : 0;
a1042 7
	  else if (qp == 0 && 32 <= indirect && indirect < 40 && 
		   !instores[indirect-32])
	    {
	      /* Allow an indirect store of an input register.  */
	      instores[indirect-32] = 1;
	      last_prologue_pc = next_pc;
	    }
a1056 1
	  int indirect = rM < 256 ? reg_contents[rM] : 0;
a1061 7
	  else if (qp == 0 && 32 <= indirect && indirect < 40 && 
		   !instores[indirect-32])
	    {
	      /* Allow an indirect store of an input register.  */
	      instores[indirect-32] = 1;
	      last_prologue_pc = next_pc;
	    }
a1149 4
  /* Try and trust the lim_pc value whenever possible.  */
  if (trust_limit && lim_pc >= last_prologue_pc)
    return lim_pc;

d1242 2
a1243 2
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum),
			      get_frame_base (frame));
d1247 2
a1248 2
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), 
			      get_frame_extra_info (frame)->bsp);
d1258 1
a1258 1
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (IA64_VFP_REGNUM), vfp);
d1262 1
a1262 1
      char pr_raw_buffer[MAX_REGISTER_SIZE];
d1285 1
a1285 1
      char unat_raw_buffer[MAX_REGISTER_SIZE];
d1341 1
a1341 1
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (IA64_IP_REGNUM), pc);
d1772 2
a1773 2
      store_unsigned_integer (buf, 8, faddr);
      store_unsigned_integer (buf + 8, 8, global_pointer);
d1865 3
a1867 3
	  store_unsigned_integer (val_buf, 8,
				  find_func_descr (extract_address (VALUE_CONTENTS (arg), 8),
						   &funcdescaddr));
d1923 3
a1925 3
      store_unsigned_integer (&deprecated_registers[REGISTER_BYTE (IA64_GR8_REGNUM)],
			      REGISTER_RAW_SIZE (IA64_GR8_REGNUM),
			      struct_addr);
d2036 1
a2036 3
ia64_remote_translate_xfer_address (struct gdbarch *gdbarch,
				    struct regcache *regcache,
				    CORE_ADDR memaddr, int nr_bytes,
d2176 2
a2177 2
  set_gdbarch_deprecated_register_size (gdbarch, 8);
  set_gdbarch_deprecated_register_bytes (gdbarch, ia64_num_regs * 8 + 128*8);
d2220 2
a2221 2
  set_gdbarch_deprecated_call_dummy_words (gdbarch, ia64_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (ia64_call_dummy_words));
@


1.68
log
@2003-04-09  Andrew Cagney  <cagney@@redhat.com>

	* doublest.h: Update copyright.
	(deprecated_store_floating, deprecated_extract_floating): Rename
	store_floating and extract_floating.  Update comments.
	* doublest.c: Update copyright.
	(extract_floating_by_length): Replace extract_floating.
	(store_floating_by_length): Replace store_floating.
	(deprecated_extract_floating): New function.
	(deprecated_store_floating): New function.
	(extract_typed_floating): Call extract_floating_by_length.
	(store_typed_floating): Call store_floating_by_length.
	* x86-64-tdep.c (x86_64_store_return_value): Update.
	* sh-tdep.c (sh3e_sh4_extract_return_value): Update.
	(sh64_extract_return_value): Update.
	(sh_sh4_register_convert_to_virtual): Update.
	(sh_sh64_register_convert_to_virtual): Update.
	(sh_sh4_register_convert_to_raw): Update.
	(sh_sh64_register_convert_to_raw): Update.
	* rs6000-tdep.c (rs6000_register_convert_to_virtual): Update.
	(rs6000_register_convert_to_raw): Update.
	* ia64-tdep.c (ia64_register_convert_to_virtual): Update.
	(ia64_register_convert_to_raw): Update.
	* config/i386/tm-symmetry.h (REGISTER_CONVERT_TO_RAW): Update.
	(REGISTER_CONVERT_TO_VIRTUAL): Update.
	* arm-linux-tdep.c (arm_linux_push_arguments): Update.
	* alpha-tdep.c (alpha_register_convert_to_virtual): Update.
	(alpha_register_convert_to_raw): Update.
@
text
@d99 1
a99 1
static gdbarch_saved_pc_after_call_ftype ia64_saved_pc_after_call;
d2190 1
a2190 1
  set_gdbarch_saved_pc_after_call (gdbarch, ia64_saved_pc_after_call);
@


1.67
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_func_unwind, get_frame_func): New functions.
	* frame.h (get_frame_func, frame_func_unwind): Declare.
	(struct frame_info): Add field "prev_func" for caching the
	previous frame's function address.
	* arm-tdep.c (arm_frameless_function_invocation): Combine
	get_pc_function_start and get_frame_pc into get_frame_func.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	* s390-tdep.c (s390_function_start): Ditto.
	* rs6000-tdep.c (rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc): Ditto.
	* m68k-tdep.c (m68k_frame_init_saved_regs): Ditto.
	* ia64-tdep.c (ia64_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frameless_signal_p): Ditto.
	(i386_frame_init_saved_regs): Ditto.
	* hppa-tdep.c (hppa_frame_find_saved_regs): Ditto.
	* d10v-tdep.c (d10v_frame_unwind_cache): Combine
	get_pc_function_start and frame_pc_unwind into frame_func_unwind.
	* cris-tdep.c (cris_frame_init_saved_regs): Ditto.
	* blockframe.c (frameless_look_for_prologue): Ditto.
@
text
@d276 1
a276 1
      store_floating(to, TYPE_LENGTH(type), val);
d288 1
a288 1
      DOUBLEST val = extract_floating (from, TYPE_LENGTH(type));
@


1.66
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_START_OFFSET): Default to zero.
	CALL_DUMMY_LENGTH): Ditto.
	* gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_START_OFFSET): Delete macro.
	(CALL_DUMMY_LENGTH): Delete macro.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set above when zero.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@d1208 1
a1208 1
      func_start = get_pc_function_start (get_frame_pc (frame));
@


1.66.2.1
log
@Merge with mainline.
@
text
@d276 1
a276 1
      deprecated_store_floating (to, TYPE_LENGTH(type), val);
d288 1
a288 1
      DOUBLEST val = deprecated_extract_floating (from, TYPE_LENGTH(type));
d1208 1
a1208 1
      func_start = get_frame_func (frame);
@


1.65
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_BREAKPOINT_OFFSET): Default to zero.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sp64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* config/pa/tm-hppa64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* inferior.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET): Delete.
	* infcmd.c (run_stack_dummy): Simplify assuming
	CALL_DUMMY_BREAKPOINT_OFFSET_P.
	* infrun.c (handle_inferior_event): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	call_dummy_breakpoint_offset or call_dummy_breakpoint_offset_p.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@a2215 1
  set_gdbarch_call_dummy_length (gdbarch, 0);
a2237 2

  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
@


1.64
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FIX_CALL_DUMMY): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Regenerate.
	* inferior.h (FIX_CALL_DUMMY): Delete macro.
	* valops.c (hand_function_call): Only call FIX_CALL_DUMMY when
	available.
	* frame.h (generic_fix_call_dummy): Delete declaration.
	* dummy-frame.h: Update comment.
	* dummy-frame.c (generic_fix_call_dummy): Delete function.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	fix_call_dummy.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a2222 1
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
a2239 1
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
@


1.63
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Include "symfile.h".
	(CALL_DUMMY_ADDRESS): Default to entry_point_address.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_ADDRESS): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_address, the default is at entry_point_address.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a2242 1
  set_gdbarch_fix_call_dummy (gdbarch, generic_fix_call_dummy);
@


1.62
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@a2240 1
  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
@


1.61
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_DUMMY_WRITE_SP): Replace TARGET_WRITE_SP.
	* gdbarch.h, gdbarch.c: Regenerate.
	* v850-tdep.c (v850_gdbarch_init): Set deprecated_dummy_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_push_dummy_frame, sparc_pop_frame): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_DUMMY_WRITE_SP): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* valops.c (hand_function_call): Replace TARGET_WRITE_SP with
	DEPRECATED_DUMMY_WRITE_SP.  Call when the method is available,
	instead of when push_dummy_call is not available.

2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	reference to TARGET_WRITE_SP.
@
text
@a2220 1
  set_gdbarch_call_dummy_p (gdbarch, 1);
@


1.60
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_RETURN_ADDRESS): Replace
	PUSH_RETURN_ADDRESS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* valops.c (hand_function_call): Update.
@
text
@d2240 1
a2240 1
  set_gdbarch_write_sp (gdbarch, generic_target_write_sp);
@


1.59
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_ARGUMENTS): Rename PUSH_ARGUMENTS.
	(push_dummy_call): New pure multi-arch replacement with gdbarch,
	regcache and dummy_addr parameters.
	* gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (hand_function_call): Use gdbarch_push_dummy_call when
	available; assume it will handle stack alignment and return
	address issues.  Fall back to DEPRECATED_PUSH_ARGUMENTS and
	legacy_push_arguments.
	(legacy_push_arguments): Rename default_push_arguments.
	* value.h (legacy_push_arguments): Rename default_push_arguments.
	* i386-tdep.c (i386_push_arguments): Call legacy_push_arguments.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/i386/tm-symmetry.h: Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* arm-linux-tdep.c (arm_linux_init_abi): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	PUSH_ARGUMENTS with push_dummy_call, add gdbarch, regcache and
	dummy_addr parameters.
@
text
@a98 1
static gdbarch_push_return_address_ftype ia64_push_return_address;
d2218 1
a2218 1
  set_gdbarch_push_return_address (gdbarch, ia64_push_return_address);
@


1.58
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@a98 1
static gdbarch_push_arguments_ftype ia64_push_arguments;
d2218 1
a2218 1
  set_gdbarch_push_arguments (gdbarch, ia64_push_arguments);
@


1.58.2.1
log
@Merge with mainline.
@
text
@d99 2
d2219 2
a2220 2
  set_gdbarch_deprecated_push_arguments (gdbarch, ia64_push_arguments);
  set_gdbarch_deprecated_push_return_address (gdbarch, ia64_push_return_address);
d2242 1
a2242 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.57
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_STACK_ADJUST_P): Delete.
	(DEPRECATED_CALL_DUMMY_STACK_ADJUST): Replace
	CALL_DUMMY_STACK_ADJUST with a predicate variable.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_stack_adjust_p.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sparc.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.  Do not set
	call_dummy_stack_adjust_p.
	* inferior.h (CALL_DUMMY_STACK_ADJUST_P): Delete macro.
	(CALL_DUMMY_STACK_ADJUST): Delete macro.
	* sparc-tdep.c (sparc32_push_arguments): Update.
	* valops.c (hand_function_call): Update.

2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to CALL_DUMMY_STACK_ADJUST_P.  Rename
	CALL_DUMMY_STACK_ADJUST to DEPRECATED_CALL_DUMMY_STACK_ADJUST.
	Add reference to PUSH_ARGUMENTS.
@
text
@a98 1
static gdbarch_store_struct_return_ftype ia64_store_struct_return;
d2207 1
a2207 1
  set_gdbarch_store_struct_return (gdbarch, ia64_store_struct_return);
@


1.56
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@a2247 1
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
@


1.55
log
@2003-03-14  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_GET_SAVED_REGISTER): Replace
	GET_SAVED_REGISTER.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h: Update comments.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frame.c (frame_register): Update.
	(get_saved_register): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_GET_SAVED_REGISTER): Update.
@
text
@a93 1
static gdbarch_frame_chain_ftype ia64_frame_chain;
d2006 1
a2006 1
  write_register (sp_regnum, FRAME_CHAIN (frame));
d2195 1
a2195 1
  set_gdbarch_frame_chain (gdbarch, ia64_frame_chain);
@


1.54
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@a95 1
static gdbarch_get_saved_register_ftype ia64_get_saved_register;
d2200 1
a2200 1
  set_gdbarch_get_saved_register (gdbarch, ia64_get_saved_register);
@


1.53
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@a103 1
static gdbarch_pop_frame_ftype ia64_pop_frame;
d2224 1
a2224 1
  set_gdbarch_pop_frame (gdbarch, ia64_pop_frame);
@


1.52
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	Make MAX_REGISTER_RAW_SIZE and MAX_REGISTER_VIRTUAL_SIZE optional.
	* gdbarch.sh (DEPRECATED_MAX_REGISTER_RAW_SIZE): Variable with
	predicate.  Replace MAX_REGISTER_RAW_SIZE.
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto for
	MAX_REGISTER_VIRTUAL_SIZE.
	* regcache.c (legacy_max_register_raw_size): New function.
	(legacy_max_register_virtual_size): New function.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Define.
	(MAX_REGISTER_RAW_SIZE): Define.
	(legacy_max_register_raw_size): Declare.
	(legacy_max_register_virtual_size): Declare.
	* config/sparc/tm-sparc.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/i386/tm-ptx.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set
	max_register_raw_size or max_register_virtual_size.
@
text
@a94 1
static gdbarch_frame_saved_pc_ftype ia64_frame_saved_pc;
d2010 1
a2010 1
  write_pc (FRAME_SAVED_PC (frame));
d2199 1
a2199 1
  set_gdbarch_frame_saved_pc (gdbarch, ia64_frame_saved_pc);
@


1.52.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d95 1
d97 1
d105 1
d2011 1
a2011 1
  write_pc (DEPRECATED_FRAME_SAVED_PC (frame));
d2200 1
a2200 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, ia64_frame_saved_pc);
d2203 1
a2203 1
  set_gdbarch_deprecated_get_saved_register (gdbarch, ia64_get_saved_register);
d2226 1
a2226 1
  set_gdbarch_deprecated_pop_frame (gdbarch, ia64_pop_frame);
@


1.51
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_INIT_SAVED_REGS): Rename
	FRAME_INIT_SAVED_REGS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Update.
	* sh-tdep.c (sh_find_callers_reg, sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info, sh64_init_extra_frame_info): Update.
	(sh64_get_saved_register, sh_pop_frame, sh64_pop_frame): Update.
	* ns32k-tdep.c (ns32k_pop_frame): Update.
	* mips-tdep.c (mips_pop_frame): Update.
	* m68hc11-tdep.c (m68hc11_pop_frame): Update.
	* ia64-tdep.c (ia64_frame_chain): Update.
	(ia64_frame_saved_pc, ia64_get_saved_register): Update.
	(ia64_frameless_function_invocation): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_pop_frame_regular): Update.
	* frame.h (struct frame_info): Update comment.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Rename macro.
	* frame.c (frame_saved_regs_register_unwind): Update.
	(frame_saved_regs_register_unwind): Update.
	(deprecated_generic_get_saved_register): Update.
	* cris-tdep.c: Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_INIT_SAVED_REGS):
	Rename macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_INIT_SAVED_REGS to DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@d2187 1
a2187 1
  set_gdbarch_max_register_raw_size (gdbarch, 16);
d2189 1
a2189 1
  set_gdbarch_max_register_virtual_size (gdbarch, 16);
@


1.50
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename
	INIT_EXTRA_FRAME_INFO.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-tdep.c: Update comments.
	* sh-tdep.c, mcore-tdep.c, m68hc11-tdep.c: Ditto.
	* i386-interix-tdep.c, hppa-tdep.c, h8300-tdep.c: Ditto.
	* frame.h, avr-tdep.c: Ditto.
	* frame.c (get_prev_frame): DEPRECATED_INIT_EXTRA_FRAME_INFO.
	(create_new_frame, legacy_get_prev_frame): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Initialize
	deprecated_init_extra_frame_info instead of init_extra_frame_info.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

Index: doc/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo: Rename INIT_EXTRA_FRAME_INFO to
	DEPRECATED_INIT_EXTRA_FRAME_INFO.
@
text
@a96 1
static gdbarch_frame_init_saved_regs_ftype ia64_frame_init_saved_regs;
d712 1
a712 1
      FRAME_INIT_SAVED_REGS (frame);
d733 1
a733 1
      FRAME_INIT_SAVED_REGS (frame);
d1313 1
a1313 1
	  FRAME_INIT_SAVED_REGS (frame);
d1355 1
a1355 1
	  FRAME_INIT_SAVED_REGS (frame);
d1463 1
a1463 1
  FRAME_INIT_SAVED_REGS (frame);
d1524 1
a1524 1
      FRAME_INIT_SAVED_REGS (frn);
d1991 1
a1991 1
  FRAME_INIT_SAVED_REGS (frame);
d2202 1
a2202 1
  set_gdbarch_frame_init_saved_regs (gdbarch, ia64_frame_init_saved_regs);
@


1.49
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_DUMMY_FRAME): Procedure with
	predicate.  Replaces PUSH_DUMMY_FRAME.
	* gdbarch.h, gdbarch.c: Regnerate.
	* valops.c (hand_function_call): Update.  Call
	generic_push_dummy_frame directly.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* inferior.h (PUSH_DUMMY_FRAME): Delete definition.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Don't set
	push_dummy_frame to generic_push_dummy_frame.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a102 1
static gdbarch_init_extra_frame_info_ftype ia64_init_extra_frame_info;
d2233 1
a2233 1
  set_gdbarch_init_extra_frame_info (gdbarch, ia64_init_extra_frame_info);
@


1.48
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_extra_info.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, ia64-tdep.c, m68hc11-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10300-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@a2254 1
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
@


1.47
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_next_frame.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10200-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, sparc-tdep.c: Ditto.
	* v850-tdep.c, vax-tdep.c, x86-64-linux-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
@
text
@d719 1
a719 1
		+ frame->extra_info->mem_stack_frame_size);
d850 3
a852 3
      && frame->extra_info->after_prologue != 0
      && frame->extra_info->after_prologue <= lim_pc)
    return frame->extra_info->after_prologue;
d1126 2
a1127 2
    sor = ((frame->extra_info->cfm >> 14) & 0xf) * 8;
    rrb_gr = (frame->extra_info->cfm >> 18) & 0x7f;
d1129 2
a1130 2
    for (i = 0, addr = frame->extra_info->bsp;
	 i < frame->extra_info->sof;
d1152 6
a1157 5
  if (frame && frame->extra_info) {
    frame->extra_info->after_prologue = last_prologue_pc;
    frame->extra_info->mem_stack_frame_size = mem_stack_frame_size;
    frame->extra_info->fp_reg = fp_reg;
  }
d1257 1
a1257 1
                     frame->extra_info->bsp);
d1266 1
a1266 1
		       + frame->extra_info->mem_stack_frame_size);
d1282 1
a1282 1
	  int rrb_pr = (frame->extra_info->cfm >> 32) & 0x3f;
d1382 1
a1382 1
	  int rrb_fr = (frame->extra_info->cfm >> 25) & 0x7f;
d1466 1
a1466 1
  return (frame->extra_info->mem_stack_frame_size == 0);
d1542 1
a1542 1
      bsp = frn->extra_info->bsp;
d1544 3
a1546 3
  frame->extra_info->cfm = cfm;
  frame->extra_info->sof = cfm & 0x7f;
  frame->extra_info->sol = (cfm >> 7) & 0x7f;
d1550 2
a1551 1
    frame->extra_info->bsp = rse_address_add (bsp, -frame->extra_info->sof);
d1553 2
a1554 1
    frame->extra_info->bsp = rse_address_add (bsp, -frame->extra_info->sol);
d1556 3
a1558 3
  frame->extra_info->after_prologue = 0;
  frame->extra_info->mem_stack_frame_size = -1;		/* Not yet determined */
  frame->extra_info->fp_reg = 0;
d2033 1
a2033 1
  bsp = rse_address_add (frame->extra_info->bsp,
@


1.46
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_base.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* mn10300-tdep.c, ns32k-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c: Ditto.
	* x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* config/h8500/tm-h8500.h, config/mn10200/tm-mn10200.h: Ditto.
	* config/sparc/tm-sparc.h: Ditto.
@
text
@d739 3
a741 2
      else if (frame->next && (get_frame_type (frame->next) == SIGTRAMP_FRAME))
	return read_sigcontext_register (frame->next, IA64_BR0_REGNUM);
d1247 1
a1247 1
  if (regnum == SP_REGNUM && frame->next)
d1340 1
a1340 1
      if (frame->next)
d1343 1
a1343 1
	  pc = ia64_frame_saved_pc (frame->next);
d1494 4
a1497 4
  int next_frame_is_call_dummy = ((frame->next != NULL)
    && DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame->next),
				    get_frame_base (frame->next),
				    get_frame_base (frame->next)));
d1501 1
a1501 1
  if (frame->next == 0)
d1507 1
a1507 1
  else if ((get_frame_type (frame->next) == SIGTRAMP_FRAME))
d1509 2
a1510 2
      bsp = read_sigcontext_register (frame->next, IA64_BSP_REGNUM);
      cfm = read_sigcontext_register (frame->next, IA64_CFM_REGNUM);
d1514 2
a1515 2
      bsp = deprecated_read_register_dummy (get_frame_pc (frame->next),
					    get_frame_base (frame->next),
d1517 2
a1518 2
      cfm = deprecated_read_register_dummy (get_frame_pc (frame->next),
					    get_frame_base (frame->next),
d1523 1
a1523 1
      struct frame_info *frn = frame->next;
d1529 8
a1536 8
      else if (frn->next && (get_frame_type (frn->next) == SIGTRAMP_FRAME))
	cfm = read_sigcontext_register (frn->next, IA64_PFS_REGNUM);
      else if (frn->next
               && DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frn->next),
					       get_frame_base (frn->next),
					       get_frame_base (frn->next)))
	cfm = deprecated_read_register_dummy (get_frame_pc (frn->next),
					      get_frame_base (frn->next),
d1546 2
a1547 2
  if (frame->next == 0 
      || (get_frame_type (frame->next) == SIGTRAMP_FRAME) 
@


1.45
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_init_extra_frame_info): Allocate
	extra_info using frame_extra_info_zalloc.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	* sh-tdep.c (sh_init_extra_frame_info): Ditto.
	(sh64_init_extra_frame_info): Ditto.
	* mn10300-tdep.c (mn10300_init_extra_frame_info): Ditto.
	* s390-tdep.c (s390_init_extra_frame_info): Ditto.
	* mips-tdep.c (mips_init_extra_frame_info): Ditto.
	* mcore-tdep.c (mcore_init_extra_frame_info): Ditto.
	* frv-tdep.c (frv_init_extra_frame_info): Ditto.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Ditto.
	* ia64-tdep.c (ia64_init_extra_frame_info): Ditto.
	* h8300-tdep.c (h8300_init_extra_frame_info): Ditto.
	* d10v-tdep.c (d10v_init_extra_frame_info): Ditto.
	* cris-tdep.c (cris_init_extra_frame_info): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.
	* alpha-tdep.c (alpha_init_extra_frame_info): Ditto.

	* mn10300-tdep.c (analyze_dummy_frame): Use
	deprecated_set_frame_extra_info_hack.
	* mcore-tdep.c (analyze_dummy_frame): Ditto.
@
text
@d338 1
a338 1
  regaddr = SIGCONTEXT_REGISTER_ADDRESS (frame->frame, regnum);
d708 4
a711 2
  else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), frame->frame, frame->frame))
    return frame->frame;
d718 2
a719 1
	return frame->frame + frame->extra_info->mem_stack_frame_size;
d728 5
a732 2
  else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), frame->frame, frame->frame))
    return deprecated_read_register_dummy (get_frame_pc (frame), frame->frame, pc_regnum);
d946 1
a946 1
	      spill_addr  = (frame ? frame->frame : 0)
d1179 1
a1179 1
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_IP_REGNUM);
d1181 1
a1181 1
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_CFM_REGNUM);
d1183 1
a1183 1
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_PSR_REGNUM);
d1189 1
a1189 1
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_RNAT_REGNUM);
d1191 1
a1191 1
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_CCV_REGNUM);
d1193 1
a1193 1
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_UNAT_REGNUM);
d1195 1
a1195 1
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_FPSR_REGNUM);
d1197 1
a1197 1
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_PFS_REGNUM);
d1199 1
a1199 1
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_LC_REGNUM);
d1203 1
a1203 1
	    SIGCONTEXT_REGISTER_ADDRESS (frame->frame, regno);
d1206 1
a1206 1
	  SIGCONTEXT_REGISTER_ADDRESS (frame->frame, regno);
d1209 1
a1209 1
	  SIGCONTEXT_REGISTER_ADDRESS (frame->frame, regno);
d1242 3
a1244 1
  is_dummy_frame = DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), frame->frame, frame->frame);
d1249 2
a1250 1
      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), frame->frame);
d1263 2
a1264 1
      CORE_ADDR vfp = frame->frame + frame->extra_info->mem_stack_frame_size;
d1494 3
a1496 2
    && DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame->next), frame->next->frame,
                                          frame->next->frame));
d1514 1
a1514 1
					    frame->next->frame,
d1517 1
a1517 1
					    frame->next->frame,
d1531 5
a1535 3
               && DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frn->next), frn->next->frame,
	                                           frn->next->frame))
	cfm = deprecated_read_register_dummy (get_frame_pc (frn->next), frn->next->frame,
@


1.44
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@d1487 1
a1487 2
  frame->extra_info = (struct frame_extra_info *)
    frame_obstack_alloc (sizeof (struct frame_extra_info));
@


1.43
log
@2003-01-03  Andrew Cagney  <ac131313@@redhat.com>

	* alpha-tdep.c: Use get_frame_saved_regs.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
a2185 1
  set_gdbarch_frame_chain_valid (gdbarch, generic_func_frame_chain_valid);
@


1.42
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d713 2
a714 2
      if (frame->saved_regs[IA64_VFP_REGNUM])
	return read_memory_integer (frame->saved_regs[IA64_VFP_REGNUM], 8);
d731 2
a732 2
      if (frame->saved_regs[IA64_VRAP_REGNUM])
	return read_memory_integer (frame->saved_regs[IA64_VRAP_REGNUM], 8);
d835 1
a835 1
  if (frame && !frame->saved_regs)
d963 1
a963 1
	        frame->saved_regs[IA64_FR0_REGNUM + fM] = spill_addr;
d1022 1
a1022 1
		    frame->saved_regs[IA64_UNAT_REGNUM] = spill_addr;
d1029 1
a1029 1
		    frame->saved_regs[IA64_PR_REGNUM] = spill_addr;
d1098 1
a1098 1
		frame->saved_regs[IA64_GR0_REGNUM + rM] = spill_addr;
d1131 1
a1131 1
	  frame->saved_regs[IA64_GR32_REGNUM + ((i + (sor - rrb_gr)) % sor)] 
d1134 1
a1134 1
	  frame->saved_regs[IA64_GR32_REGNUM + i] = addr;
d1137 1
a1137 1
	  frame->saved_regs[IA64_CFM_REGNUM] = addr;
d1139 1
a1139 1
	  frame->saved_regs[IA64_VRAP_REGNUM] = addr;
d1141 1
a1141 1
	  frame->saved_regs[IA64_VFP_REGNUM] = addr;
d1163 1
a1163 1
  if (frame->saved_regs)
d1172 1
a1172 1
      frame->saved_regs[IA64_VRAP_REGNUM] = 
d1174 1
a1174 1
      frame->saved_regs[IA64_CFM_REGNUM] = 
d1176 1
a1176 1
      frame->saved_regs[IA64_PSR_REGNUM] = 
d1179 1
a1179 1
      frame->saved_regs[IA64_BSP_REGNUM] = 
d1182 1
a1182 1
      frame->saved_regs[IA64_RNAT_REGNUM] = 
d1184 1
a1184 1
      frame->saved_regs[IA64_CCV_REGNUM] = 
d1186 1
a1186 1
      frame->saved_regs[IA64_UNAT_REGNUM] = 
d1188 1
a1188 1
      frame->saved_regs[IA64_FPSR_REGNUM] = 
d1190 1
a1190 1
      frame->saved_regs[IA64_PFS_REGNUM] = 
d1192 1
a1192 1
      frame->saved_regs[IA64_LC_REGNUM] = 
d1196 1
a1196 1
	  frame->saved_regs[regno] =
d1199 1
a1199 1
	frame->saved_regs[regno] =
d1202 1
a1202 1
	frame->saved_regs[regno] =
d1304 2
a1305 2
	  gr_addr = frame->saved_regs[ regnum - IA64_NAT0_REGNUM 
	                                      + IA64_GR0_REGNUM];
d1346 1
a1346 1
	  addr = frame->saved_regs[regnum];
d1516 2
a1517 2
      if (frn->saved_regs[IA64_CFM_REGNUM] != 0)
	cfm = read_memory_integer (frn->saved_regs[IA64_CFM_REGNUM], 8);
d1981 1
a1981 1
      if (frame->saved_regs[regno]
d1991 1
a1991 1
			  read_memory_integer (frame->saved_regs[regno],
d2001 1
a2001 1
  if (frame->saved_regs[IA64_PFS_REGNUM])
d2003 1
a2003 1
      pfs = read_memory_integer (frame->saved_regs[IA64_PFS_REGNUM],
@


1.41
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@d708 1
a708 1
  else if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d725 2
a726 2
  else if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
    return deprecated_read_register_dummy (frame->pc, frame->frame, pc_regnum);
d1209 2
a1210 2
      func_start = get_pc_function_start (frame->pc);
      examine_prologue (func_start, frame->pc, frame);
d1236 1
a1236 1
  is_dummy_frame = DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame);
d1484 1
a1484 1
    && DEPRECATED_PC_IN_CALL_DUMMY (frame->next->pc, frame->next->frame,
d1503 1
a1503 1
      bsp = deprecated_read_register_dummy (frame->next->pc,
d1506 1
a1506 1
      cfm = deprecated_read_register_dummy (frame->next->pc,
d1521 1
a1521 1
               && DEPRECATED_PC_IN_CALL_DUMMY (frn->next->pc, frn->next->frame,
d1523 1
a1523 1
	cfm = deprecated_read_register_dummy (frn->next->pc, frn->next->frame,
@


1.40
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d2123 3
@


1.39
log
@2002-11-27  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_LOCATION): Default to AT_ENTRY_POINT.
	(USE_GENERIC_DUMMY_FRAMES): Default to true.
	(PC_IN_CALL_DUMMY): Default to generic_pc_in_call_dummy.
	* gdbarch.c, gdbarch.h: Re-generate.
	* inferior.h (USE_GENERIC_DUMMY_FRAMES): Delete macro definition.
	(CALL_DUMMY_LOCATION): Delete macro definition.
	(PC_IN_CALL_DUMMY): Delete macro definitions.

	* arm-tdep.c (arm_gdbarch_init): Do not set pc_in_call_dummy,
	default is already generic_pc_in_call_dummy.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* arm-tdep.c (arm_gdbarch_init): Do not set
	use_generic_dummy_frames, default is already 1.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_location, default is already AT_ENTRY_POINT.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d708 1
a708 1
  else if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d725 1
a725 1
  else if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d1236 1
a1236 1
  is_dummy_frame = PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame);
d1484 1
a1484 1
    && PC_IN_CALL_DUMMY (frame->next->pc, frame->next->frame,
d1521 1
a1521 1
               && PC_IN_CALL_DUMMY (frn->next->pc, frn->next->frame,
@


1.38
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@a2206 1
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
a2232 1
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
a2235 1
  set_gdbarch_pc_in_call_dummy (gdbarch, generic_pc_in_call_dummy);
@


1.37
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@d331 1
a331 1
  if (!frame->signal_handler_caller)
d333 1
a333 1
		    "read_sigcontext_register: frame not a signal_handler_caller");
d706 1
a706 1
  if (frame->signal_handler_caller)
d723 1
a723 1
  if (frame->signal_handler_caller)
d733 1
a733 1
      else if (frame->next && frame->next->signal_handler_caller)
d1166 1
a1166 1
  if (frame->signal_handler_caller && SIGCONTEXT_REGISTER_ADDRESS)
d1496 1
a1496 1
  else if (frame->next->signal_handler_caller)
d1518 1
a1518 1
      else if (frn->next && frn->next->signal_handler_caller)
d1534 1
a1534 1
      || frame->next->signal_handler_caller 
@


1.36
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@d1905 1
a1905 1
		&registers[REGISTER_BYTE (floatreg)]);
d1916 1
a1916 1
      store_address (&registers[REGISTER_BYTE (IA64_GR8_REGNUM)],
d1957 1
a1957 1
				  &registers[REGISTER_BYTE (IA64_FR8_REGNUM)]);
@


1.35
log
@2002-11-01  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_generic_get_saved_register): Rename
	generic_get_saved_register.
	* blockframe.c (deprecated_generic_get_saved_register): Update.
	* xstormy16-tdep.c (xstormy16_get_saved_register): Update.
	(xstormy16_frame_saved_register): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_get_saved_register): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/m32r/tm-m32r.h (GET_SAVED_REGISTER): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
@
text
@d1961 2
a1962 2
    write_register_bytes (REGISTER_BYTE (IA64_GR8_REGNUM),
			  valbuf, TYPE_LENGTH (type));
@


1.34
log
@2002-09-17  Andrew Cagney  <cagney@@redhat.com>

	* h8300-tdep.c (h8300_frame_chain):
	(h8300_frame_saved_pc):

	* blockframe.c (deprecated_read_register_dummy): Rename
	generic_read_register_dummy.
	* frame.c (frame_unwind_signed_register): New function.
	(frame_unwind_unsigned_register): New function.
	* frame.h (frame_unwind_signed_register): Declare.
	(frame_unwind_unsigned_register): Declare.
	(deprecated_read_register_dummy): Rename
	generic_read_register_dummy.

	* xstormy16-tdep.c (xstormy16_frame_saved_pc): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	* s390-tdep.c (s390_frame_saved_pc_nofix): Update.
	(s390_frame_chain): Update.
	* v850-tdep.c (v850_find_callers_reg): Update.
	(v850_frame_saved_pc): Update.
	* m32r-tdep.c (m32r_init_extra_frame_info): Update.
	(m32r_find_callers_reg): Update.
	(m32r_frame_saved_pc): Update.
	* sh-tdep.c (sh_find_callers_reg): Update.
	(sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info): Update.
	(sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* mcore-tdep.c (mcore_find_callers_reg): Update.
	(mcore_frame_saved_pc): Update.
	(mcore_init_extra_frame_info): Update.
	* i386-tdep.c (i386_frame_saved_pc): Update.
	* ia64-tdep.c (ia64_frame_saved_pc): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_init_extra_frame_info): Update.
	* d10v-tdep.c (d10v_frame_saved_pc): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_frame_chain): Update.
	(avr_init_extra_frame_info): Update.
	(avr_frame_saved_pc): Update.
	* arm-tdep.c (arm_find_callers_reg): Update.
	(arm_init_extra_frame_info): Update.
	(arm_frame_saved_pc): Update.
@
text
@d1378 2
a1379 2
      generic_get_saved_register (raw_buffer, optimized, addrp, frame,
                                  regnum, lval);
@


1.34.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a28 4
#include "reggroups.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
d31 1
a31 1
#include "gdb_assert.h"
a34 7
#include "elf.h"                /* for PT_IA64_UNWIND value */
#include "dis-asm.h"

#ifdef HAVE_LIBUNWIND_IA64_H
#include "libunwind-frame.h"
#include "libunwind-ia64.h"
#endif
a84 1
extern unsigned long ia64_linux_getunwind_table (void *, size_t);
d89 4
a92 1
static gdbarch_register_type_ftype ia64_register_type;
d94 2
d97 4
a100 2
static gdbarch_extract_return_value_ftype ia64_extract_return_value;
static gdbarch_extract_struct_value_address_ftype ia64_extract_struct_value_address;
d102 8
d112 1
a112 3
static struct type *builtin_type_ia64_ext;

#define NUM_IA64_RAW_REGS 462
d114 1
d119 1
a119 5
/* NOTE: we treat the register stack registers r32-r127 as pseudo-registers because
   they may not be accessible via the ptrace register get/set interfaces.  */
enum pseudo_regs { FIRST_PSEUDO_REGNUM = NUM_IA64_RAW_REGS, VBOF_REGNUM = IA64_NAT127_REGNUM + 1, V32_REGNUM, 
		   V127_REGNUM = V32_REGNUM + 95, 
		   VP0_REGNUM, VP16_REGNUM = VP0_REGNUM + 16, VP63_REGNUM = VP0_REGNUM + 63, LAST_PSEUDO_REGNUM };
d129 12
a140 12
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
d159 8
a166 8
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
a206 24

  "bof",
  
  "r32",  "r33",  "r34",  "r35",  "r36",  "r37",  "r38",  "r39",   
  "r40",  "r41",  "r42",  "r43",  "r44",  "r45",  "r46",  "r47",
  "r48",  "r49",  "r50",  "r51",  "r52",  "r53",  "r54",  "r55",
  "r56",  "r57",  "r58",  "r59",  "r60",  "r61",  "r62",  "r63",
  "r64",  "r65",  "r66",  "r67",  "r68",  "r69",  "r70",  "r71",
  "r72",  "r73",  "r74",  "r75",  "r76",  "r77",  "r78",  "r79",
  "r80",  "r81",  "r82",  "r83",  "r84",  "r85",  "r86",  "r87",
  "r88",  "r89",  "r90",  "r91",  "r92",  "r93",  "r94",  "r95",
  "r96",  "r97",  "r98",  "r99",  "r100", "r101", "r102", "r103",
  "r104", "r105", "r106", "r107", "r108", "r109", "r110", "r111",
  "r112", "r113", "r114", "r115", "r116", "r117", "r118", "r119",
  "r120", "r121", "r122", "r123", "r124", "r125", "r126", "r127",

  "p0",   "p1",   "p2",   "p3",   "p4",   "p5",   "p6",   "p7",
  "p8",   "p9",   "p10",  "p11",  "p12",  "p13",  "p14",  "p15",
  "p16",  "p17",  "p18",  "p19",  "p20",  "p21",  "p22",  "p23",
  "p24",  "p25",  "p26",  "p27",  "p28",  "p29",  "p30",  "p31",
  "p32",  "p33",  "p34",  "p35",  "p36",  "p37",  "p38",  "p39",
  "p40",  "p41",  "p42",  "p43",  "p44",  "p45",  "p46",  "p47",
  "p48",  "p49",  "p50",  "p51",  "p52",  "p53",  "p54",  "p55",
  "p56",  "p57",  "p58",  "p59",  "p60",  "p61",  "p62",  "p63",
d209 15
a223 21
struct ia64_frame_cache
{
  CORE_ADDR base;       /* frame pointer base for frame */
  CORE_ADDR pc;		/* function start pc for frame */
  CORE_ADDR saved_sp;	/* stack pointer for frame */
  CORE_ADDR bsp;	/* points at r32 for the current frame */
  CORE_ADDR cfm;	/* cfm value for current frame */
  CORE_ADDR prev_cfm;   /* cfm value for previous frame */
  int   frameless;
  int   sof;		/* Size of frame  (decoded from cfm value) */
  int	sol;		/* Size of locals (decoded from cfm value) */
  int	sor;		/* Number of rotating registers. (decoded from cfm value) */
  CORE_ADDR after_prologue;
  /* Address of first instruction after the last
     prologue instruction;  Note that there may
     be instructions from the function's body
     intermingled with the prologue. */
  int mem_stack_frame_size;
  /* Size of the memory stack frame (may be zero),
     or -1 if it has not been determined yet. */
  int	fp_reg;		/* Register number (if any) used a frame pointer
d226 1
a226 5
  
  /* Saved registers.  */
  CORE_ADDR saved_regs[NUM_IA64_RAW_REGS];

};
d230 3
a244 23
int
ia64_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *group)
{
  int vector_p;
  int float_p;
  int raw_p;
  if (group == all_reggroup)
    return 1;
  vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));
  float_p = TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT;
  raw_p = regnum < NUM_IA64_RAW_REGS;
  if (group == float_reggroup)
    return float_p;
  if (group == vector_reggroup)
    return vector_p;
  if (group == general_reggroup)
    return (!vector_p && !float_p);
  if (group == save_reggroup || group == restore_reggroup)
    return raw_p; 
  return 0;
}

d251 2
a252 2
struct type *
ia64_register_type (struct gdbarch *arch, int reg)
d254 1
a254 4
  if (reg >= IA64_FR0_REGNUM && reg <= IA64_FR127_REGNUM)
    return builtin_type_ia64_ext;
  else
    return builtin_type_long;
d257 2
a258 2
static int
ia64_dwarf_reg_to_regnum (int reg)
d260 1
a260 3
  if (reg >= IA64_GR32_REGNUM && reg <= IA64_GR127_REGNUM)
    return V32_REGNUM + (reg - IA64_GR32_REGNUM);
  return reg;
d263 4
a266 2
static int
floatformat_valid (const struct floatformat *fmt, const char *from)
d268 1
a268 1
  return 1;
d274 1
a274 1
  floatformat_intbit_yes, "floatformat_ia64_ext", floatformat_valid
d277 42
d331 1
a331 1
  if (!(get_frame_type (frame) == SIGTRAMP_FRAME))
d333 1
a333 1
		    "read_sigcontext_register: frame not a signal trampoline");
d338 1
a338 1
  regaddr = SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), regnum);
d340 1
a340 1
    return read_memory_integer (regaddr, register_size (current_gdbarch, regnum));
d555 1
a555 1
#define IA64_BREAKPOINT 0x00002000040LL
d557 1
a557 1
#define IA64_BREAKPOINT 0x00003333300LL
d585 1
a585 1
  replace_slotN_contents (bundle, IA64_BREAKPOINT, slotnum);
d635 1
a635 13
static CORE_ADDR
ia64_read_fp (void)
{
  /* We won't necessarily have a frame pointer and even if we do, it
     winds up being extraordinarly messy when attempting to find the
     frame chain.  So for the purposes of creating frames (which is
     all deprecated_read_fp() is used for), simply use the stack
     pointer value instead.  */
  gdb_assert (SP_REGNUM >= 0);
  return read_register (SP_REGNUM);
}

static CORE_ADDR
d645 1
a645 1
static void
d681 24
a704 3
static void
ia64_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
                           int regnum, void *buf)
d706 5
a710 1
  if (regnum >= V32_REGNUM && regnum <= V127_REGNUM)
d712 3
a714 16
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get start of register frame.  */
      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	{
	  ULONGEST reg_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
	  reg = read_memory_integer ((CORE_ADDR)reg_addr, 8);
	  store_unsigned_integer (buf, register_size (current_gdbarch, regnum), reg);
	}
d716 1
a716 81
	store_unsigned_integer (buf, register_size (current_gdbarch, regnum), 0);
    }
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT31_REGNUM)
    {
      ULONGEST unatN_val;
      ULONGEST unat;
      regcache_cooked_read_unsigned (regcache, IA64_UNAT_REGNUM, &unat);
      unatN_val = (unat & (1LL << (regnum - IA64_NAT0_REGNUM))) != 0;
      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), unatN_val);
    }
  else if (IA64_NAT32_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      ULONGEST natN_val = 0;
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR gr_addr = 0;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get start of register frame.  */
      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	gr_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
      
      if (gr_addr != 0)
	{
	  /* Compute address of nat collection bits.  */
	  CORE_ADDR nat_addr = gr_addr | 0x1f8;
	  CORE_ADDR nat_collection;
	  int nat_bit;
	  /* If our nat collection address is bigger than bsp, we have to get
	     the nat collection from rnat.  Otherwise, we fetch the nat
	     collection from the computed address.  */
	  if (nat_addr >= bsp)
	    regcache_cooked_read_unsigned (regcache, IA64_RNAT_REGNUM, &nat_collection);
	  else
	    nat_collection = read_memory_integer (nat_addr, 8);
	  nat_bit = (gr_addr >> 3) & 0x3f;
	  natN_val = (nat_collection >> nat_bit) & 1;
	}
      
      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), natN_val);
    }
  else if (regnum == VBOF_REGNUM)
    {
      /* A virtual register frame start is provided for user convenience.
         It can be calculated as the bsp - sof (sizeof frame). */
      ULONGEST bsp, vbsp;
      ULONGEST cfm;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get beginning of frame.  */
      vbsp = rse_address_add (bsp, -(cfm & 0x7f));
      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), vbsp);
    }
  else if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    {
      ULONGEST pr;
      ULONGEST cfm;
      ULONGEST prN_val;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_PR_REGNUM, &pr);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  /* Fetch predicate register rename base from current frame
	     marker for this frame. */
	  int rrb_pr = (cfm >> 32) & 0x3f;

	  /* Adjust the register number to account for register rotation. */
	  regnum = VP16_REGNUM 
	         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = (pr & (1LL << (regnum - VP0_REGNUM))) != 0;
      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), prN_val);
a717 2
  else
    memset (buf, 0, register_size (current_gdbarch, regnum));
d720 2
a721 3
static void
ia64_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int regnum, const void *buf)
d723 5
a727 79
  if (regnum >= V32_REGNUM && regnum <= V127_REGNUM)
    {
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	{
	  ULONGEST reg_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
	  write_memory (reg_addr, (void *)buf, 8);
	}
    }
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT31_REGNUM)
    {
      ULONGEST unatN_val, unat, unatN_mask;
      regcache_cooked_read_unsigned (regcache, IA64_UNAT_REGNUM, &unat);
      unatN_val = extract_unsigned_integer (buf, register_size (current_gdbarch, regnum)); 
      unatN_mask = (1LL << (regnum - IA64_NAT0_REGNUM));
      if (unatN_val == 0)
	unat &= ~unatN_mask;
      else if (unatN_val == 1)
	unat |= unatN_mask;
      regcache_cooked_write_unsigned (regcache, IA64_UNAT_REGNUM, unat);
    }
  else if (IA64_NAT32_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      ULONGEST natN_val;
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR gr_addr = 0;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get start of register frame.  */
      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	gr_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
      
      natN_val = extract_unsigned_integer (buf, register_size (current_gdbarch, regnum)); 

      if (gr_addr != 0 && (natN_val == 0 || natN_val == 1))
	{
	  /* Compute address of nat collection bits.  */
	  CORE_ADDR nat_addr = gr_addr | 0x1f8;
	  CORE_ADDR nat_collection;
	  int natN_bit = (gr_addr >> 3) & 0x3f;
	  ULONGEST natN_mask = (1LL << natN_bit);
	  /* If our nat collection address is bigger than bsp, we have to get
	     the nat collection from rnat.  Otherwise, we fetch the nat
	     collection from the computed address.  */
	  if (nat_addr >= bsp)
	    {
	      regcache_cooked_read_unsigned (regcache, IA64_RNAT_REGNUM, &nat_collection);
	      if (natN_val)
		nat_collection |= natN_mask;
	      else
		nat_collection &= ~natN_mask;
	      regcache_cooked_write_unsigned (regcache, IA64_RNAT_REGNUM, nat_collection);
	    }
	  else
	    {
	      char nat_buf[8];
	      nat_collection = read_memory_integer (nat_addr, 8);
	      if (natN_val)
		nat_collection |= natN_mask;
	      else
		nat_collection &= ~natN_mask;
	      store_unsigned_integer (nat_buf, register_size (current_gdbarch, regnum), nat_collection);
	      write_memory (nat_addr, nat_buf, 8);
	    }
	}
    }
  else if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
d729 1
a729 13
      ULONGEST pr;
      ULONGEST cfm;
      ULONGEST prN_val;
      ULONGEST prN_mask;

      regcache_cooked_read_unsigned (regcache, IA64_PR_REGNUM, &pr);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  /* Fetch predicate register rename base from current frame
	     marker for this frame. */
	  int rrb_pr = (cfm >> 32) & 0x3f;
d731 6
a736 11
	  /* Adjust the register number to account for register rotation. */
	  regnum = VP16_REGNUM 
	         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = extract_unsigned_integer (buf, register_size (current_gdbarch, regnum)); 
      prN_mask = (1LL << (regnum - VP0_REGNUM));
      if (prN_val == 0)
	pr &= ~prN_mask;
      else if (prN_val == 1)
	pr |= prN_mask;
      regcache_cooked_write_unsigned (regcache, IA64_PR_REGNUM, pr);
a739 28
/* The ia64 needs to convert between various ieee floating-point formats
   and the special ia64 floating point register format.  */

static int
ia64_convert_register_p (int regno, struct type *type)
{
  return (regno >= IA64_FR0_REGNUM && regno <= IA64_FR127_REGNUM);
}

static void
ia64_register_to_value (struct frame_info *frame, int regnum,
                         struct type *valtype, void *out)
{
  char in[MAX_REGISTER_SIZE];
  frame_register_read (frame, regnum, in);
  convert_typed_floating (in, builtin_type_ia64_ext, out, valtype);
}

static void
ia64_value_to_register (struct frame_info *frame, int regnum,
                         struct type *valtype, const void *in)
{
  char out[MAX_REGISTER_SIZE];
  convert_typed_floating (in, valtype, out, builtin_type_ia64_ext);
  put_frame_register (frame, regnum, out);
}


d742 1
a742 1
static int max_skip_non_prologue_insns = 40;
a810 28
/* Allocate and initialize a frame cache.  */

static struct ia64_frame_cache *
ia64_alloc_frame_cache (void)
{
  struct ia64_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct ia64_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->pc = 0;
  cache->cfm = 0;
  cache->prev_cfm = 0;
  cache->sof = 0;
  cache->sol = 0;
  cache->sor = 0;
  cache->bsp = 0;
  cache->fp_reg = 0;
  cache->frameless = 1;

  for (i = 0; i < NUM_IA64_RAW_REGS; i++)
    cache->saved_regs[i] = 0;

  return cache;
}

d812 1
a812 1
examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc, struct frame_info *next_frame, struct ia64_frame_cache *cache)
d818 2
a829 1
  char reg_contents[256];
a830 5
  int frameless = 1;
  int i;
  CORE_ADDR addr;
  char buf[8];
  CORE_ADDR bof, sor, sol, sof, cfm, rrb_gr;
a833 1
  memset (reg_contents, 0, sizeof reg_contents);
d835 11
a845 3
  if (cache->after_prologue != 0
      && cache->after_prologue <= lim_pc)
    return cache->after_prologue;
d848 2
a850 3

  /* We want to check if we have a recognizable function start before we
     look ahead for a prologue.  */
d854 1
a854 1
      /* alloc - start of a regular function.  */
d858 4
a862 11

      /* Verify that the current cfm matches what we think is the
	 function start.  If we have somehow jumped within a function,
	 we do not want to interpret the prologue and calculate the
	 addresses of various registers such as the return address.  
	 We will instead treat the frame as frameless. */
      if (!next_frame ||
	  (sof == (cache->cfm & 0x7f) &&
	   sol == ((cache->cfm >> 7) & 0x7f)))
	frameless = 0;

d869 3
a871 28
      /* Look for a leaf routine.  */
      if (pc < lim_pc && next_pc
	  && (it == I || it == M) 
          && ((instr & 0x1ee00000000LL) == 0x10800000000LL))
	{
	  /* adds rN = imm14, rM   (or mov rN, rM  when imm14 is 0) */
	  int imm = (int) ((((instr & 0x01000000000LL) ? -1 : 0) << 13) 
	                   | ((instr & 0x001f8000000LL) >> 20)
		           | ((instr & 0x000000fe000LL) >> 13));
	  int rM = (int) ((instr & 0x00007f00000LL) >> 20);
	  int rN = (int) ((instr & 0x00000001fc0LL) >> 6);
	  int qp = (int) (instr & 0x0000000003fLL);
	  if (qp == 0 && rN == 2 && imm == 0 && rM == 12 && fp_reg == 0)
	    {
	      /* mov r2, r12 - beginning of leaf routine */
	      fp_reg = rN;
	      last_prologue_pc = next_pc;
	    }
	} 

      /* If we don't recognize a regular function or leaf routine, we are
	 done.  */
      if (!fp_reg)
	{
	  pc = lim_pc;	
	  if (trust_limit)
	    last_prologue_pc = lim_pc;
	}
d882 2
a883 9
      if (it == B && ((instr & 0x1e1f800003f) != 0x04000000000))
	{
	  /* Exit loop upon hitting a non-nop branch instruction. */ 
	  if (trust_limit)
	    lim_pc = pc;
	  break;
	}
      else if (((instr & 0x3fLL) != 0LL) && 
	       (frameless || ret_reg != 0))
d885 2
a886 4
	  /* Exit loop upon hitting a predicated instruction if
	     we already have the return register or if we are frameless.  */ 
	  if (trust_limit)
	    lim_pc = pc;
a927 2
	      char buf[MAX_REGISTER_SIZE];
	      CORE_ADDR saved_sp = 0;
d940 1
a940 6
	      if (next_frame)
		{
		  frame_unwind_register (next_frame, sp_regnum, buf);
		  saved_sp = extract_unsigned_integer (buf, 8);
		}
	      spill_addr  = saved_sp
a945 14
	  else if (qp == 0 && rM >= 32 && rM < 40 && !instores[rM] && 
		   rN < 256 && imm == 0)
	    {
	      /* mov rN, rM where rM is an input register */
	      reg_contents[rN] = rM;
	      last_prologue_pc = next_pc;
	    }
	  else if (frameless && qp == 0 && rN == fp_reg && imm == 0 && 
		   rM == 2)
	    {
	      /* mov r12, r2 */
	      last_prologue_pc = next_pc;
	      break;
	    }
d962 2
a963 1
	      cache->saved_regs[IA64_FR0_REGNUM + fM] = spill_addr;
a1010 1
	  int indirect = rM < 256 ? reg_contents[rM] : 0;
d1021 2
a1022 1
		  cache->saved_regs[IA64_UNAT_REGNUM] = spill_addr;
d1028 2
a1029 1
		  cache->saved_regs[IA64_PR_REGNUM] = spill_addr;
a1044 7
	  else if (qp == 0 && 32 <= indirect && indirect < 40 && 
		   !instores[indirect-32])
	    {
	      /* Allow an indirect store of an input register.  */
	      instores[indirect-32] = 1;
	      last_prologue_pc = next_pc;
	    }
a1058 1
	  int indirect = rM < 256 ? reg_contents[rM] : 0;
a1063 7
	  else if (qp == 0 && 32 <= indirect && indirect < 40 && 
		   !instores[indirect-32])
	    {
	      /* Allow an indirect store of an input register.  */
	      instores[indirect-32] = 1;
	      last_prologue_pc = next_pc;
	    }
d1097 2
a1098 1
	      cache->saved_regs[IA64_GR0_REGNUM + rM] = spill_addr;
d1111 33
a1143 2
  /* If not frameless and we aren't called by skip_prologue, then we need to calculate
     registers for the previous frame which will be needed later.  */
d1145 5
a1149 81
  if (!frameless && next_frame)
    {
      /* Extract the size of the rotating portion of the stack
	 frame and the register rename base from the current
	 frame marker. */
      cfm = cache->cfm;
      sor = cache->sor;
      sof = cache->sof;
      sol = cache->sol;
      rrb_gr = (cfm >> 18) & 0x7f;

      /* Find the bof (beginning of frame).  */
      bof = rse_address_add (cache->bsp, -sof);
      
      for (i = 0, addr = bof;
	   i < sof;
	   i++, addr += 8)
	{
	  if (IS_NaT_COLLECTION_ADDR (addr))
	    {
	      addr += 8;
	    }
	  if (i+32 == cfm_reg)
	    cache->saved_regs[IA64_CFM_REGNUM] = addr;
	  if (i+32 == ret_reg)
	    cache->saved_regs[IA64_VRAP_REGNUM] = addr;
	  if (i+32 == fp_reg)
	    cache->saved_regs[IA64_VFP_REGNUM] = addr;
	}

      /* For the previous argument registers we require the previous bof.  
	 If we can't find the previous cfm, then we can do nothing.  */
      cfm = 0;
      if (cache->saved_regs[IA64_CFM_REGNUM] != 0)
	{
	  cfm = read_memory_integer (cache->saved_regs[IA64_CFM_REGNUM], 8);
	}
      else if (cfm_reg != 0)
	{
	  frame_unwind_register (next_frame, cfm_reg, buf);
	  cfm = extract_unsigned_integer (buf, 8);
	}
      cache->prev_cfm = cfm;
      
      if (cfm != 0)
	{
	  sor = ((cfm >> 14) & 0xf) * 8;
	  sof = (cfm & 0x7f);
	  sol = (cfm >> 7) & 0x7f;
	  rrb_gr = (cfm >> 18) & 0x7f;

	  /* The previous bof only requires subtraction of the sol (size of locals)
	     due to the overlap between output and input of subsequent frames.  */
	  bof = rse_address_add (bof, -sol);
	  
	  for (i = 0, addr = bof;
	       i < sof;
	       i++, addr += 8)
	    {
	      if (IS_NaT_COLLECTION_ADDR (addr))
		{
		  addr += 8;
		}
	      if (i < sor)
		cache->saved_regs[IA64_GR32_REGNUM + ((i + (sor - rrb_gr)) % sor)] 
		  = addr;
	      else
		cache->saved_regs[IA64_GR32_REGNUM + i] = addr;
	    }
	  
	}
    }
      
  /* Try and trust the lim_pc value whenever possible.  */
  if (trust_limit && lim_pc >= last_prologue_pc)
    last_prologue_pc = lim_pc;

  cache->frameless = frameless;
  cache->after_prologue = last_prologue_pc;
  cache->mem_stack_frame_size = mem_stack_frame_size;
  cache->fp_reg = fp_reg;
d1157 1
a1157 8
  struct ia64_frame_cache cache;
  cache.base = 0;
  cache.after_prologue = 0;
  cache.cfm = 0;
  cache.bsp = 0;

  /* Call examine_prologue with - as third argument since we don't have a next frame pointer to send.  */
  return examine_prologue (pc, pc+1024, 0, &cache);
d1160 2
a1161 5

/* Normal frames.  */

static struct ia64_frame_cache *
ia64_frame_cache (struct frame_info *next_frame, void **this_cache)
d1163 2
a1164 4
  struct ia64_frame_cache *cache;
  char buf[8];
  CORE_ADDR cfm, sof, sol, bsp, psr;
  int i;
d1166 3
a1168 2
  if (*this_cache)
    return *this_cache;
d1170 1
a1170 2
  cache = ia64_alloc_frame_cache ();
  *this_cache = cache;
d1172 36
a1207 2
  frame_unwind_register (next_frame, sp_regnum, buf);
  cache->saved_sp = extract_unsigned_integer (buf, 8);
d1209 3
a1211 26
  /* We always want the bsp to point to the end of frame.
     This way, we can always get the beginning of frame (bof)
     by subtracting frame size.  */
  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
  cache->bsp = extract_unsigned_integer (buf, 8);
  
  frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
  psr = extract_unsigned_integer (buf, 8);

  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
  cfm = extract_unsigned_integer (buf, 8);

  cache->sof = (cfm & 0x7f);
  cache->sol = (cfm >> 7) & 0x7f;
  cache->sor = ((cfm >> 14) & 0xf) * 8;

  cache->cfm = cfm;

  cache->pc = frame_func_unwind (next_frame);

  if (cache->pc != 0)
    examine_prologue (cache->pc, frame_pc_unwind (next_frame), next_frame, cache);
  
  cache->base = cache->saved_sp + cache->mem_stack_frame_size;

  return cache;
d1214 7
a1220 3
static void
ia64_frame_this_id (struct frame_info *next_frame, void **this_cache,
		    struct frame_id *this_id)
d1222 1
a1222 2
  struct ia64_frame_cache *cache =
    ia64_frame_cache (next_frame, this_cache);
d1224 2
a1225 3
  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d1227 2
a1228 6
  (*this_id) = frame_id_build_special (cache->base, cache->pc, cache->bsp);
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"regular frame id: code %lx, stack %lx, special %lx, next_frame %p\n",
			this_id->code_addr, this_id->stack_addr, cache->bsp, next_frame);
}
d1230 2
a1231 10
static void
ia64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *valuep)
{
  struct ia64_frame_cache *cache =
    ia64_frame_cache (next_frame, this_cache);
  char dummy_valp[MAX_REGISTER_SIZE];
  char buf[8];
d1233 2
a1234 1
  gdb_assert (regnum >= 0);
d1236 1
a1236 2
  if (!target_has_registers)
    error ("No registers.");
d1238 1
a1238 13
  *optimizedp = 0;
  *addrp = 0;
  *lvalp = not_lval;
  *realnump = -1;

  /* Rather than check each time if valuep is non-null, supply a dummy buffer
     when valuep is not supplied.  */
  if (!valuep)
    valuep = dummy_valp;
  
  memset (valuep, 0, register_size (current_gdbarch, regnum));
 
  if (regnum == SP_REGNUM)
d1241 1
a1241 2
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum),
			      cache->base);
d1245 2
a1246 40
      char cfm_valuep[MAX_REGISTER_SIZE];
      int  cfm_optim;
      int  cfm_realnum;
      enum lval_type cfm_lval;
      CORE_ADDR cfm_addr;
      CORE_ADDR bsp, prev_cfm, prev_bsp;

      /* We want to calculate the previous bsp as the end of the previous register stack frame.
	 This corresponds to what the hardware bsp register will be if we pop the frame
	 back which is why we might have been called.  We know the beginning of the current
	 frame is cache->bsp - cache->sof.  This value in the previous frame points to
	 the start of the output registers.  We can calculate the end of that frame by adding
	 the size of output (sof (size of frame) - sol (size of locals)).  */
      ia64_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
				&cfm_optim, &cfm_lval, &cfm_addr, &cfm_realnum, cfm_valuep);
      prev_cfm = extract_unsigned_integer (cfm_valuep, 8);

      bsp = rse_address_add (cache->bsp, -(cache->sof));
      prev_bsp = rse_address_add (bsp, (prev_cfm & 0x7f) - ((prev_cfm >> 7) & 0x7f));

      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
			      prev_bsp);
    }
  else if (regnum == IA64_CFM_REGNUM)
    {
      CORE_ADDR addr = cache->saved_regs[IA64_CFM_REGNUM];
      
      if (addr != 0)
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
	}
      else if (cache->prev_cfm)
	store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), cache->prev_cfm);
      else if (cache->frameless)
	{
	  CORE_ADDR cfm = 0;
	  frame_unwind_register (next_frame, IA64_PFS_REGNUM, valuep);
	}
d1253 3
a1255 3
	 still provide a value since we know the size of the frame.  */
      CORE_ADDR vfp = cache->base;
      store_unsigned_integer (valuep, register_size (current_gdbarch, IA64_VFP_REGNUM), vfp);
d1257 1
a1257 1
  else if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
d1259 1
a1259 1
      char pr_valuep[MAX_REGISTER_SIZE];
a1260 1
      int  pr_realnum;
d1263 4
a1266 4
      ULONGEST prN_val;
      ia64_frame_prev_register (next_frame, this_cache, IA64_PR_REGNUM,
				&pr_optim, &pr_lval, &pr_addr, &pr_realnum, pr_valuep);
      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
d1269 2
a1270 2
	     marker for this frame.  */
	  int rrb_pr = (cache->cfm >> 32) & 0x3f;
d1272 7
a1278 7
	  /* Adjust the register number to account for register rotation.  */
	  regnum = VP16_REGNUM 
	         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = extract_bit_field ((unsigned char *) pr_valuep,
                                   regnum - VP0_REGNUM, 1);
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), prN_val);
d1282 1
a1282 1
      char unat_valuep[MAX_REGISTER_SIZE];
a1283 1
      int  unat_realnum;
d1286 4
a1289 4
      ULONGEST unatN_val;
      ia64_frame_prev_register (next_frame, this_cache, IA64_UNAT_REGNUM,
				&unat_optim, &unat_lval, &unat_addr, &unat_realnum, unat_valuep);
      unatN_val = extract_bit_field ((unsigned char *) unat_valuep,
d1291 1
a1291 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
d1298 2
a1299 2
         interested in.  */
      CORE_ADDR gr_addr;
d1301 7
a1307 3
      gr_addr = cache->saved_regs[regnum - IA64_NAT0_REGNUM 
				  + IA64_GR0_REGNUM];
      if (gr_addr != 0)
d1309 1
a1309 1
	  /* Compute address of nat collection bits.  */
d1311 1
a1311 1
	  CORE_ADDR bsp;
d1316 1
a1316 3
	     collection from the computed address.  */
	  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
	  bsp = extract_unsigned_integer (buf, 8); 
d1318 1
a1318 4
	    {
	      frame_unwind_register (next_frame, IA64_RNAT_REGNUM, buf);
	      nat_collection = extract_unsigned_integer (buf, 8);
	    }
d1324 1
a1324 2

      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), natval);
d1328 11
a1338 49
      CORE_ADDR pc = 0;
      CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];

      if (addr != 0)
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, buf, register_size (current_gdbarch, IA64_IP_REGNUM));
	  pc = extract_unsigned_integer (buf, 8);
	}
      else if (cache->frameless)
	{
	  frame_unwind_register (next_frame, IA64_BR0_REGNUM, buf);
	  pc = extract_unsigned_integer (buf, 8);
	}
      pc &= ~0xf;
      store_unsigned_integer (valuep, 8, pc);
    }
  else if (regnum == IA64_PSR_REGNUM)
    {
      /* We don't know how to get the complete previous PSR, but we need it for
	 the slot information when we unwind the pc (pc is formed of IP register
	 plus slot information from PSR).  To get the previous slot information, 
	 we mask it off the return address.  */
      ULONGEST slot_num = 0;
      CORE_ADDR pc= 0;
      CORE_ADDR psr = 0;
      CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];

      frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
      psr = extract_unsigned_integer (buf, 8);

      if (addr != 0)
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, buf, register_size (current_gdbarch, IA64_IP_REGNUM));
	  pc = extract_unsigned_integer (buf, 8);
	}
      else if (cache->frameless)
	{
	  CORE_ADDR pc;
	  frame_unwind_register (next_frame, IA64_BR0_REGNUM, buf);
	  pc = extract_unsigned_integer (buf, 8);
	}
      psr &= ~(3LL << 41);
      slot_num = pc & 0x3LL;
      psr |= (CORE_ADDR)slot_num << 41;
      store_unsigned_integer (valuep, 8, psr);
d1340 1
a1340 1
  else if (regnum == IA64_BR0_REGNUM)
d1342 2
a1343 3
      CORE_ADDR br0 = 0;
      CORE_ADDR addr = cache->saved_regs[IA64_BR0_REGNUM];
      if (addr != 0)
d1345 2
a1346 4
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, buf, register_size (current_gdbarch, IA64_BR0_REGNUM));
	  br0 = extract_unsigned_integer (buf, 8);
d1348 1
a1348 9
      store_unsigned_integer (valuep, 8, br0);
    }
 else if ((regnum >= IA64_GR32_REGNUM && regnum <= IA64_GR127_REGNUM) ||
	   (regnum >= V32_REGNUM && regnum <= V127_REGNUM))
    {
      CORE_ADDR addr = 0;
      if (regnum >= V32_REGNUM)
	regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);
      addr = cache->saved_regs[regnum];
d1351 5
a1355 3
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
d1357 1
a1357 1
      else if (cache->frameless)
d1359 3
a1361 21
	  char r_valuep[MAX_REGISTER_SIZE];
	  int  r_optim;
	  int  r_realnum;
	  enum lval_type r_lval;
	  CORE_ADDR r_addr;
	  CORE_ADDR prev_cfm, prev_bsp, prev_bof;
	  CORE_ADDR addr = 0;
	  if (regnum >= V32_REGNUM)
	    regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);
	  ia64_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
				    &r_optim, &r_lval, &r_addr, &r_realnum, r_valuep); 
	  prev_cfm = extract_unsigned_integer (r_valuep, 8);
	  ia64_frame_prev_register (next_frame, this_cache, IA64_BSP_REGNUM,
				    &r_optim, &r_lval, &r_addr, &r_realnum, r_valuep);
	  prev_bsp = extract_unsigned_integer (r_valuep, 8);
	  prev_bof = rse_address_add (prev_bsp, -(prev_cfm & 0x7f));

	  addr = rse_address_add (prev_bof, (regnum - IA64_GR32_REGNUM));
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
a1365 1
      CORE_ADDR addr = 0;
d1369 2
a1370 2
	     frame marker for this frame.  */
	  int rrb_fr = (cache->cfm >> 25) & 0x7f;
d1373 1
a1373 1
	     register rotation.  */
d1378 2
a1379 71
      /* If we have stored a memory address, access the register.  */
      addr = cache->saved_regs[regnum];
      if (addr != 0)
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
	}
      /* Otherwise, punt and get the current value of the register.  */
      else 
	frame_unwind_register (next_frame, regnum, valuep);
    }

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"regular prev register <%d> <%s> is %lx\n", regnum, 
			(((unsigned) regnum <= IA64_NAT127_REGNUM)
			 ? ia64_register_names[regnum] : "r??"), extract_unsigned_integer (valuep, 8));
}
 
static const struct frame_unwind ia64_frame_unwind =
{
  NORMAL_FRAME,
  &ia64_frame_this_id,
  &ia64_frame_prev_register
};

static const struct frame_unwind *
ia64_frame_sniffer (struct frame_info *next_frame)
{
  return &ia64_frame_unwind;
}

/* Signal trampolines.  */

static void
ia64_sigtramp_frame_init_saved_regs (struct ia64_frame_cache *cache)
{
  if (SIGCONTEXT_REGISTER_ADDRESS)
    {
      int regno;

      cache->saved_regs[IA64_VRAP_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_IP_REGNUM);
      cache->saved_regs[IA64_CFM_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_CFM_REGNUM);
      cache->saved_regs[IA64_PSR_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_PSR_REGNUM);
      cache->saved_regs[IA64_BSP_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_BSP_REGNUM);
      cache->saved_regs[IA64_RNAT_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_RNAT_REGNUM);
      cache->saved_regs[IA64_CCV_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_CCV_REGNUM);
      cache->saved_regs[IA64_UNAT_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_UNAT_REGNUM);
      cache->saved_regs[IA64_FPSR_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_FPSR_REGNUM);
      cache->saved_regs[IA64_PFS_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_PFS_REGNUM);
      cache->saved_regs[IA64_LC_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_LC_REGNUM);
      for (regno = IA64_GR1_REGNUM; regno <= IA64_GR31_REGNUM; regno++)
	cache->saved_regs[regno] =
	  SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
      for (regno = IA64_BR0_REGNUM; regno <= IA64_BR7_REGNUM; regno++)
	cache->saved_regs[regno] =
	  SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
      for (regno = IA64_FR2_REGNUM; regno <= IA64_FR31_REGNUM; regno++)
	cache->saved_regs[regno] =
	  SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
d1383 5
a1387 2
static struct ia64_frame_cache *
ia64_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
d1389 1
a1389 4
  struct ia64_frame_cache *cache;
  CORE_ADDR addr;
  char buf[8];
  int i;
d1391 8
a1398 2
  if (*this_cache)
    return *this_cache;
d1400 3
a1402 18
  cache = ia64_alloc_frame_cache ();

  frame_unwind_register (next_frame, sp_regnum, buf);
  /* Note that frame size is hard-coded below.  We cannot calculate it
     via prologue examination.  */
  cache->base = extract_unsigned_integer (buf, 8) + 16;

  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
  cache->bsp = extract_unsigned_integer (buf, 8);

  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
  cache->cfm = extract_unsigned_integer (buf, 8);
  cache->sof = cache->cfm & 0x7f;

  ia64_sigtramp_frame_init_saved_regs (cache);

  *this_cache = cache;
  return cache;
d1405 2
a1406 3
static void
ia64_sigtramp_frame_this_id (struct frame_info *next_frame,
			       void **this_cache, struct frame_id *this_id)
d1408 1
a1408 2
  struct ia64_frame_cache *cache =
    ia64_sigtramp_frame_cache (next_frame, this_cache);
d1410 2
a1411 38
  (*this_id) = frame_id_build_special (cache->base, frame_pc_unwind (next_frame), cache->bsp);
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"sigtramp frame id: code %lx, stack %lx, special %lx, next_frame %p\n",
			this_id->code_addr, this_id->stack_addr, cache->bsp, next_frame);
}

static void
ia64_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, void *valuep)
{
  char dummy_valp[MAX_REGISTER_SIZE];
  char buf[MAX_REGISTER_SIZE];

  struct ia64_frame_cache *cache =
    ia64_sigtramp_frame_cache (next_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (!target_has_registers)
    error ("No registers.");

  *optimizedp = 0;
  *addrp = 0;
  *lvalp = not_lval;
  *realnump = -1;

  /* Rather than check each time if valuep is non-null, supply a dummy buffer
     when valuep is not supplied.  */
  if (!valuep)
    valuep = dummy_valp;
  
  memset (valuep, 0, register_size (current_gdbarch, regnum));
 
  if (regnum == IA64_IP_REGNUM)
d1413 3
a1415 2
      CORE_ADDR pc = 0;
      CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];
d1417 1
a1417 1
      if (addr != 0)
d1419 4
a1422 20
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, buf, register_size (current_gdbarch, IA64_IP_REGNUM));
	  pc = extract_unsigned_integer (buf, 8);
	}
      pc &= ~0xf;
      store_unsigned_integer (valuep, 8, pc);
    }
 else if ((regnum >= IA64_GR32_REGNUM && regnum <= IA64_GR127_REGNUM) ||
	   (regnum >= V32_REGNUM && regnum <= V127_REGNUM))
    {
      CORE_ADDR addr = 0;
      if (regnum >= V32_REGNUM)
	regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);
      addr = cache->saved_regs[regnum];
      if (addr != 0)
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
d1426 2
a1427 16
    {
      /* All other registers not listed above.  */
      CORE_ADDR addr = cache->saved_regs[regnum];
      if (addr != 0)
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
	}
    }

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"sigtramp prev register <%s> is %lx\n",
			(((unsigned) regnum <= IA64_NAT127_REGNUM)
			 ? ia64_register_names[regnum] : "r??"), extract_unsigned_integer (valuep, 8));
d1430 4
a1433 6
static const struct frame_unwind ia64_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  ia64_sigtramp_frame_this_id,
  ia64_sigtramp_frame_prev_register
};
d1435 2
a1436 2
static const struct frame_unwind *
ia64_sigtramp_frame_sniffer (struct frame_info *next_frame)
d1438 2
a1439 8
  char *name;
  CORE_ADDR pc = frame_pc_unwind (next_frame);

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    return &ia64_sigtramp_frame_unwind;

  return NULL;
a1440 1

d1442 2
a1443 2
static CORE_ADDR
ia64_frame_base_address (struct frame_info *next_frame, void **this_cache)
d1445 3
a1447 4
  struct ia64_frame_cache *cache =
    ia64_frame_cache (next_frame, this_cache);

  return cache->base;
d1450 2
a1451 19
static const struct frame_base ia64_frame_base =
{
  &ia64_frame_unwind,
  ia64_frame_base_address,
  ia64_frame_base_address,
  ia64_frame_base_address
};

#ifdef HAVE_LIBUNWIND_IA64_H

struct ia64_unwind_table_entry
  {
    unw_word_t start_offset;
    unw_word_t end_offset;
    unw_word_t info_offset;
  };

static __inline__ uint64_t
ia64_rse_slot_num (uint64_t addr)
d1453 2
a1454 1
  return (addr >> 3) & 0x3f;
d1457 2
a1458 49
/* Skip over a designated number of registers in the backing
   store, remembering every 64th position is for NAT.  */
static __inline__ uint64_t
ia64_rse_skip_regs (uint64_t addr, long num_regs)
{
  long delta = ia64_rse_slot_num(addr) + num_regs;

  if (num_regs < 0)
    delta -= 0x3e;
  return addr + ((num_regs + delta/0x3f) << 3);
}
  
/* Gdb libunwind-frame callback function to convert from an ia64 gdb register 
   number to a libunwind register number.  */
static int
ia64_gdb2uw_regnum (int regnum)
{
  if (regnum == sp_regnum)
    return UNW_IA64_SP;
  else if (regnum == IA64_BSP_REGNUM)
    return UNW_IA64_BSP;
  else if ((unsigned) (regnum - IA64_GR0_REGNUM) < 128)
    return UNW_IA64_GR + (regnum - IA64_GR0_REGNUM);
  else if ((unsigned) (regnum - V32_REGNUM) < 95)
    return UNW_IA64_GR + 32 + (regnum - V32_REGNUM);
  else if ((unsigned) (regnum - IA64_FR0_REGNUM) < 128)
    return UNW_IA64_FR + (regnum - IA64_FR0_REGNUM);
  else if ((unsigned) (regnum - IA64_PR0_REGNUM) < 64)
    return -1;
  else if ((unsigned) (regnum - IA64_BR0_REGNUM) < 8)
    return UNW_IA64_BR + (regnum - IA64_BR0_REGNUM);
  else if (regnum == IA64_PR_REGNUM)
    return UNW_IA64_PR;
  else if (regnum == IA64_IP_REGNUM)
    return UNW_REG_IP;
  else if (regnum == IA64_CFM_REGNUM)
    return UNW_IA64_CFM;
  else if ((unsigned) (regnum - IA64_AR0_REGNUM) < 128)
    return UNW_IA64_AR + (regnum - IA64_AR0_REGNUM);
  else if ((unsigned) (regnum - IA64_NAT0_REGNUM) < 128)
    return UNW_IA64_NAT + (regnum - IA64_NAT0_REGNUM);
  else
    return -1;
}
  
/* Gdb libunwind-frame callback function to convert from a libunwind register 
   number to a ia64 gdb register number.  */
static int
ia64_uw2gdb_regnum (int uw_regnum)
d1460 1
a1460 24
  if (uw_regnum == UNW_IA64_SP)
    return sp_regnum;
  else if (uw_regnum == UNW_IA64_BSP)
    return IA64_BSP_REGNUM;
  else if ((unsigned) (uw_regnum - UNW_IA64_GR) < 32)
    return IA64_GR0_REGNUM + (uw_regnum - UNW_IA64_GR);
  else if ((unsigned) (uw_regnum - UNW_IA64_GR) < 128)
    return V32_REGNUM + (uw_regnum - (IA64_GR0_REGNUM + 32));
  else if ((unsigned) (uw_regnum - UNW_IA64_FR) < 128)
    return IA64_FR0_REGNUM + (uw_regnum - UNW_IA64_FR);
  else if ((unsigned) (uw_regnum - UNW_IA64_BR) < 8)
    return IA64_BR0_REGNUM + (uw_regnum - UNW_IA64_BR);
  else if (uw_regnum == UNW_IA64_PR)
    return IA64_PR_REGNUM;
  else if (uw_regnum == UNW_REG_IP)
    return IA64_IP_REGNUM;
  else if (uw_regnum == UNW_IA64_CFM)
    return IA64_CFM_REGNUM;
  else if ((unsigned) (uw_regnum - UNW_IA64_AR) < 128)
    return IA64_AR0_REGNUM + (uw_regnum - UNW_IA64_AR);
  else if ((unsigned) (uw_regnum - UNW_IA64_NAT) < 128)
    return IA64_NAT0_REGNUM + (uw_regnum - UNW_IA64_NAT);
  else
    return -1;
d1463 2
a1464 4
/* Gdb libunwind-frame callback function to reveal if register is a float 
   register or not.  */
static int
ia64_is_fpreg (int uw_regnum)
d1466 3
a1468 1
  return unw_is_fpreg (uw_regnum);
a1469 23
  
/* Libunwind callback accessor function for general registers.  */
static int
ia64_access_reg (unw_addr_space_t as, unw_regnum_t uw_regnum, unw_word_t *val, 
		 int write, void *arg)
{
  int regnum = ia64_uw2gdb_regnum (uw_regnum);
  unw_word_t bsp, sof, sol, cfm, psr, ip;
  struct frame_info *next_frame = arg;
  long new_sof, old_sof;
  char buf[MAX_REGISTER_SIZE];
  
  if (write)
    {
      if (regnum < 0)
	/* ignore writes to pseudo-registers such as UNW_IA64_PROC_STARTI.  */
	return 0;
  
      switch (uw_regnum)
	{
	case UNW_REG_IP:
	  ia64_write_pc (*val, inferior_ptid);
	  break;
d1471 2
a1472 93
	case UNW_IA64_AR_BSPSTORE:
	  write_register (IA64_BSP_REGNUM, *val);
	  break;
	  
	case UNW_IA64_AR_BSP:
	case UNW_IA64_BSP:
	  /* Account for the fact that ptrace() expects bsp to point
	     after the current register frame.  */
	  cfm = read_register (IA64_CFM_REGNUM);
	  sof = (cfm & 0x7f);
	  bsp = ia64_rse_skip_regs (*val, sof);
	  write_register (IA64_BSP_REGNUM, bsp);
	  break;
	  
	case UNW_IA64_CFM:
	  /* If we change CFM, we need to adjust ptrace's notion of
	     bsp accordingly, so that the real bsp remains
	     unchanged.  */
	  bsp = read_register (IA64_BSP_REGNUM);
	  cfm = read_register (IA64_CFM_REGNUM);
	  old_sof = (cfm & 0x7f);
	  new_sof = (*val & 0x7f);
	  if (old_sof != new_sof)
	    {
	      bsp = ia64_rse_skip_regs (bsp, -old_sof + new_sof);
	      write_register (IA64_BSP_REGNUM, bsp);
	    }
	  write_register (IA64_CFM_REGNUM, *val);
	  break;
	  
	default:
	  write_register (regnum, *val);
	  break;
	}
      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, 
			    "  access_reg: to cache: %4s=%016lx\n",
			    (((unsigned) regnum <= IA64_NAT127_REGNUM)
			     ? ia64_register_names[regnum] : "r??"), *val);
    }
  else
    {
      switch (uw_regnum)
	{
	case UNW_REG_IP:
	  /* Libunwind expects to see the pc value which means the slot number
	     from the psr must be merged with the ip word address.  */
	  frame_unwind_register (next_frame, IA64_IP_REGNUM, buf);
	  ip = extract_unsigned_integer (buf, 8); 
	  frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
	  psr = extract_unsigned_integer (buf, 8); 
	  *val = ip | ((psr >> 41) & 0x3);
	  break;
	  
	case UNW_IA64_AR_BSP:
	  /* Libunwind expects to see the beginning of the current register
	     frame so we must account for the fact that ptrace() will return a value
	     for bsp that points *after* the current register frame.  */
	  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
	  bsp = extract_unsigned_integer (buf, 8);
	  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
	  cfm = extract_unsigned_integer (buf, 8); 
	  sof = (cfm & 0x7f);
	  *val = ia64_rse_skip_regs (bsp, -sof);
	  break;
	  
	case UNW_IA64_AR_BSPSTORE:
	  /* Libunwind wants bspstore to be after the current register frame.
	     This is what ptrace() and gdb treats as the regular bsp value.  */
	  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
	  *val = extract_unsigned_integer (buf, 8);
	  break;

	default:
	  /* For all other registers, just unwind the value directly.  */
	  frame_unwind_register (next_frame, regnum, buf);
	  *val = extract_unsigned_integer (buf, 8); 
	  break;
	}
      
      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, 
			    "  access_reg: from cache: %4s=%016lx\n",
			    (((unsigned) regnum <= IA64_NAT127_REGNUM)
			     ? ia64_register_names[regnum] : "r??"), *val);
    }
  return 0;
}

/* Libunwind callback accessor function for floating-point registers.  */
static int
ia64_access_fpreg (unw_addr_space_t as, unw_regnum_t uw_regnum, unw_fpreg_t *val, 
		   int write, void *arg)
d1474 3
a1476 7
  int regnum = ia64_uw2gdb_regnum (uw_regnum);
  
  if (write)
    regcache_cooked_write (current_regcache, regnum, (char *) val);
  else
    regcache_cooked_read (current_regcache, regnum, (char *) val);
  return 0;
d1479 2
a1480 16
/* Libunwind callback accessor function for accessing memory.  */
static int
ia64_access_mem (unw_addr_space_t as,
		 unw_word_t addr, unw_word_t *val,
		 int write, void *arg)
{
  /* XXX do we need to normalize byte-order here?  */
  if (write)
    return target_write_memory (addr, (char *) val, sizeof (unw_word_t));
  else
    return target_read_memory (addr, (char *) val, sizeof (unw_word_t));
}

/* Call low-level function to access the kernel unwind table.  */
static int
getunwind_table (void *buf, size_t len)
d1482 4
a1485 3
  LONGEST x;
  x = target_read_partial (&current_target, TARGET_OBJECT_UNWIND_TABLE, NULL,
			   buf, 0, len);
d1487 2
a1488 15
  return (int)x;
}
	
/* Get the kernel unwind table.  */				 
static int
get_kernel_table (unw_word_t ip, unw_dyn_info_t *di)
{
  size_t size;
  struct ia64_table_entry
  {
    uint64_t start_offset;
    uint64_t end_offset;
    uint64_t info_offset;
  };
  static struct ia64_table_entry *ktab = NULL, *etab;
d1490 1
a1490 1
  if (!ktab)
d1492 2
a1493 50
      size = getunwind_table (NULL, 0);
      if ((int)size < 0)
	return -UNW_ENOINFO;
      ktab = xmalloc (size);
      getunwind_table (ktab, size);
  
      /* Determine length of kernel's unwind table and relocate
	 it's entries.  */
      for (etab = ktab; etab->start_offset; ++etab)
	etab->info_offset += (uint64_t) ktab;
    }
  
  if (ip < ktab[0].start_offset || ip >= etab[-1].end_offset)
    return -UNW_ENOINFO;
  
  di->format = UNW_INFO_FORMAT_TABLE;
  di->gp = 0;
  di->start_ip = ktab[0].start_offset;
  di->end_ip = etab[-1].end_offset;
  di->u.ti.name_ptr = (unw_word_t) "<kernel>";
  di->u.ti.segbase = 0;
  di->u.ti.table_len = ((char *) etab - (char *) ktab) / sizeof (unw_word_t);
  di->u.ti.table_data = (unw_word_t *) ktab;
  
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog, "get_kernel_table: found table `%s': "
			"segbase=%lx, length=%lu, gp=%lx\n",
			(char *) di->u.ti.name_ptr, di->u.ti.segbase, 
			di->u.ti.table_len, di->gp);
  return 0;
}

/* Find the unwind table entry for a specified address.  */
static int
ia64_find_unwind_table (struct objfile *objfile, unw_word_t ip,
			unw_dyn_info_t *dip, void **buf)
{
  Elf_Internal_Phdr *phdr, *p_text = NULL, *p_unwind = NULL;
  Elf_Internal_Ehdr *ehdr;
  unw_word_t segbase = 0;
  CORE_ADDR load_base;
  bfd *bfd;
  int i;

  bfd = objfile->obfd;
  
  ehdr = elf_tdata (bfd)->elf_header;
  phdr = elf_tdata (bfd)->phdr;

  load_base = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
a1494 65
  for (i = 0; i < ehdr->e_phnum; ++i)
    {
      switch (phdr[i].p_type)
	{
	case PT_LOAD:
	  if ((unw_word_t) (ip - load_base - phdr[i].p_vaddr)
	      < phdr[i].p_memsz)
	    p_text = phdr + i;
	  break;

	case PT_IA_64_UNWIND:
	  p_unwind = phdr + i;
	  break;

	default:
	  break;
	}
    }

  if (!p_text || !p_unwind
      /* Verify that the segment that contains the IP also contains
	 the static unwind table.  If not, we are dealing with
	 runtime-generated code, for which we have no info here.  */
      || (p_unwind->p_vaddr - p_text->p_vaddr) >= p_text->p_memsz)
    return -UNW_ENOINFO;

  segbase = p_text->p_vaddr + load_base;

  dip->start_ip = segbase;
  dip->end_ip = dip->start_ip + p_text->p_memsz;
  dip->gp = FIND_GLOBAL_POINTER (ip);
  dip->format = UNW_INFO_FORMAT_REMOTE_TABLE;
  dip->u.rti.name_ptr = (unw_word_t) bfd_get_filename (bfd);
  dip->u.rti.segbase = segbase;
  dip->u.rti.table_len = p_unwind->p_memsz / sizeof (unw_word_t);
  dip->u.rti.table_data = p_unwind->p_vaddr + load_base;

  return 0;
}

/* Libunwind callback accessor function to acquire procedure unwind-info.  */
static int
ia64_find_proc_info_x (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
		       int need_unwind_info, void *arg)
{
  struct obj_section *sec = find_pc_section (ip);
  unw_dyn_info_t di;
  int ret;
  void *buf = NULL;

  if (!sec)
    {
      /* XXX This only works if the host and the target architecture are
	 both ia64 and if the have (more or less) the same kernel
	 version.  */
      if (get_kernel_table (ip, &di) < 0)
	return -UNW_ENOINFO;

      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, "%s: %lx -> "
			    "(name=`%s',segbase=%lx,start=%lx,end=%lx,gp=%lx,"
			    "length=%lu,data=%p)\n", __FUNCTION__,
			    ip, (char *)di.u.ti.name_ptr,
			    di.u.ti.segbase, di.start_ip, di.end_ip,
			    di.gp, di.u.ti.table_len, di.u.ti.table_data);
d1496 1
a1496 1
  else
d1498 2
a1499 11
      ret = ia64_find_unwind_table (sec->objfile, ip, &di, &buf);
      if (ret < 0)
	return ret;

      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, "%s: %lx -> "
			    "(name=`%s',segbase=%lx,start=%lx,end=%lx,gp=%lx,"
			    "length=%lu,data=%lx)\n", __FUNCTION__,
			    ip, (char *)di.u.rti.name_ptr,
			    di.u.rti.segbase, di.start_ip, di.end_ip,
			    di.gp, di.u.rti.table_len, di.u.rti.table_data);
d1501 1
a1501 34

  ret = libunwind_search_unwind_table (&as, ip, &di, pi, need_unwind_info,
				       arg);

  /* We no longer need the dyn info storage so free it.  */
  xfree (buf);

  return ret;
}

/* Libunwind callback accessor function for cleanup.  */
static void
ia64_put_unwind_info (unw_addr_space_t as,
		      unw_proc_info_t *pip, void *arg)
{
  /* Nothing required for now.  */
}

/* Libunwind callback accessor function to get head of the dynamic 
   unwind-info registration list.  */ 
static int
ia64_get_dyn_info_list (unw_addr_space_t as,
			unw_word_t *dilap, void *arg)
{
  struct obj_section *text_sec;
  struct objfile *objfile;
  unw_word_t ip, addr;
  unw_dyn_info_t di;
  int ret;

  if (!libunwind_is_initialized ())
    return -UNW_ENOINFO;

  for (objfile = object_files; objfile; objfile = objfile->next)
d1503 6
a1508 23
      void *buf = NULL;

      text_sec = objfile->sections + SECT_OFF_TEXT (objfile);
      ip = text_sec->addr;
      ret = ia64_find_unwind_table (objfile, ip, &di, &buf);
      if (ret >= 0)
	{
	  addr = libunwind_find_dyn_list (as, &di, arg);
	  /* We no longer need the dyn info storage so free it.  */
	  xfree (buf);

	  if (addr)
	    {
	      if (gdbarch_debug >= 1)
		fprintf_unfiltered (gdb_stdlog,
				    "dynamic unwind table in objfile %s "
				    "at %lx (gp=%lx)\n",
				    bfd_get_filename (objfile->obfd),
				    addr, di.gp);
	      *dilap = addr;
	      return 0;
	    }
	}
d1510 1
a1510 47
  return -UNW_ENOINFO;
}


/* Frame interface functions for libunwind.  */

static void
ia64_libunwind_frame_this_id (struct frame_info *next_frame, void **this_cache,
		      struct frame_id *this_id)
{
  char buf[8];
  CORE_ADDR bsp;
  struct frame_id id;

  libunwind_frame_this_id (next_frame, this_cache, &id);

  /* We must add the bsp as the special address for frame comparison purposes.  */
  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
  bsp = extract_unsigned_integer (buf, 8);

  (*this_id) = frame_id_build_special (id.stack_addr, id.code_addr, bsp);

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"libunwind frame id: code %lx, stack %lx, special %lx, next_frame %p\n",
			id.code_addr, id.stack_addr, bsp, next_frame);
}

static void
ia64_libunwind_frame_prev_register (struct frame_info *next_frame,
				    void **this_cache,
				    int regnum, int *optimizedp,
				    enum lval_type *lvalp, CORE_ADDR *addrp,
				    int *realnump, void *valuep)
{
  int reg = regnum;

  if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    reg = IA64_PR_REGNUM;
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    reg = IA64_UNAT_REGNUM;

  /* Let libunwind do most of the work.  */
  libunwind_frame_prev_register (next_frame, this_cache, reg,
				 optimizedp, lvalp, addrp, realnump, valuep);

  if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
d1512 1
a1512 1
      ULONGEST prN_val;
d1514 1
a1514 5
      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  int rrb_pr = 0;
	  ULONGEST cfm;
	  unsigned char buf[MAX_REGISTER_SIZE];
d1516 11
a1526 17
	  /* Fetch predicate register rename base from current frame
	     marker for this frame.  */
	  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
	  cfm = extract_unsigned_integer (buf, 8); 
	  rrb_pr = (cfm >> 32) & 0x3f;
	  
	  /* Adjust the register number to account for register rotation.  */
	  regnum = VP16_REGNUM 
	    + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = extract_bit_field ((unsigned char *) valuep,
				   regnum - VP0_REGNUM, 1);
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), prN_val);
    }
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      ULONGEST unatN_val;
d1528 1
a1528 118
      unatN_val = extract_bit_field ((unsigned char *) valuep,
                                   regnum - IA64_NAT0_REGNUM, 1);
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
                              unatN_val);
    }
  else if (regnum == IA64_BSP_REGNUM)
    {
      char cfm_valuep[MAX_REGISTER_SIZE];
      int  cfm_optim;
      int  cfm_realnum;
      enum lval_type cfm_lval;
      CORE_ADDR cfm_addr;
      CORE_ADDR bsp, prev_cfm, prev_bsp;

      /* We want to calculate the previous bsp as the end of the previous register stack frame.
	 This corresponds to what the hardware bsp register will be if we pop the frame
	 back which is why we might have been called.  We know that libunwind will pass us back
	 the beginning of the current frame so we should just add sof to it. */
      prev_bsp = extract_unsigned_integer (valuep, 8);
      libunwind_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
				     &cfm_optim, &cfm_lval, &cfm_addr, &cfm_realnum, cfm_valuep);
      prev_cfm = extract_unsigned_integer (cfm_valuep, 8);
      prev_bsp = rse_address_add (prev_bsp, (prev_cfm & 0x7f));

      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
			      prev_bsp);
    }

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"libunwind prev register <%s> is %lx\n",
			(((unsigned) regnum <= IA64_NAT127_REGNUM)
			 ? ia64_register_names[regnum] : "r??"), extract_unsigned_integer (valuep, 8));
}

static const struct frame_unwind ia64_libunwind_frame_unwind =
{
  NORMAL_FRAME,
  ia64_libunwind_frame_this_id,
  ia64_libunwind_frame_prev_register
};

static const struct frame_unwind *
ia64_libunwind_frame_sniffer (struct frame_info *next_frame)
{
  if (libunwind_is_initialized () && libunwind_frame_sniffer (next_frame))
    return &ia64_libunwind_frame_unwind;

  return NULL;
}

/* Set of libunwind callback acccessor functions.  */
static unw_accessors_t ia64_unw_accessors =
{
  ia64_find_proc_info_x,
  ia64_put_unwind_info,
  ia64_get_dyn_info_list,
  ia64_access_mem,
  ia64_access_reg,
  ia64_access_fpreg,
  /* resume */
  /* get_proc_name */
};

/* Set of ia64 gdb libunwind-frame callbacks and data for generic libunwind-frame code to use.  */
static struct libunwind_descr ia64_libunwind_descr =
{
  ia64_gdb2uw_regnum, 
  ia64_uw2gdb_regnum, 
  ia64_is_fpreg, 
  &ia64_unw_accessors,
};

#endif /* HAVE_LIBUNWIND_IA64_H  */

/* Should we use EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc
   and TYPE is the type (which is known to be struct, union or array).  */
int
ia64_use_struct_convention (int gcc_p, struct type *type)
{
  struct type *float_elt_type;

  /* HFAs are structures (or arrays) consisting entirely of floating
     point values of the same length.  Up to 8 of these are returned
     in registers.  Don't use the struct convention when this is the
     case.  */
  float_elt_type = is_float_or_hfa_type (type);
  if (float_elt_type != NULL
      && TYPE_LENGTH (type) / TYPE_LENGTH (float_elt_type) <= 8)
    return 0;

  /* Other structs of length 32 or less are returned in r8-r11.
     Don't use the struct convention for those either.  */
  return TYPE_LENGTH (type) > 32;
}

void
ia64_extract_return_value (struct type *type, struct regcache *regcache, void *valbuf)
{
  struct type *float_elt_type;

  float_elt_type = is_float_or_hfa_type (type);
  if (float_elt_type != NULL)
    {
      char from[MAX_REGISTER_SIZE];
      int offset = 0;
      int regnum = IA64_FR8_REGNUM;
      int n = TYPE_LENGTH (type) / TYPE_LENGTH (float_elt_type);

      while (n-- > 0)
	{
	  regcache_cooked_read (regcache, regnum, from);
	  convert_typed_floating (from, builtin_type_ia64_ext,
				  (char *)valbuf + offset, float_elt_type);	  
	  offset += TYPE_LENGTH (float_elt_type);
	  regnum++;
	}
d1530 7
d1538 1
a1538 7
    {
      ULONGEST val;
      int offset = 0;
      int regnum = IA64_GR8_REGNUM;
      int reglen = TYPE_LENGTH (ia64_register_type (NULL, IA64_GR8_REGNUM));
      int n = TYPE_LENGTH (type) / reglen;
      int m = TYPE_LENGTH (type) % reglen;
d1540 3
a1542 15
      while (n-- > 0)
	{
	  ULONGEST val;
	  regcache_cooked_read_unsigned (regcache, regnum, &val);
	  memcpy ((char *)valbuf + offset, &val, reglen);
	  offset += reglen;
	  regnum++;
	}

      if (m)
	{
          regcache_cooked_read_unsigned (regcache, regnum, &val);
	  memcpy ((char *)valbuf + offset, &val, m);
	}
    }
a1544 8
CORE_ADDR
ia64_extract_struct_value_address (struct regcache *regcache)
{
  error ("ia64_extract_struct_value_address called and cannot get struct value address");
  return 0;
}


d1583 1
a1583 1
   bottom-most elements are all of the same floating point type).  */
d1597 1
a1597 1
   and Runtime manual).  */
d1677 1
a1677 1
		  global_pointer = extract_unsigned_integer (buf, sizeof (buf));
d1695 1
a1695 1
   not found.  */
d1701 1
a1701 1
  /* Return early if faddr is already a function descriptor.  */
d1743 1
a1743 1
   stack using the address at fdaptr.  */
d1765 2
a1766 2
      store_unsigned_integer (buf, 8, faddr);
      store_unsigned_integer (buf + 8, 8, global_pointer);
d1774 3
a1776 29
/* Use the following routine when printing out function pointers
   so the user can see the function address rather than just the
   function descriptor.  */
static CORE_ADDR
ia64_convert_from_func_ptr_addr (struct gdbarch *gdbarch, CORE_ADDR addr,
				 struct target_ops *targ)
{
  struct obj_section *s;

  s = find_pc_section (addr);

  /* check if ADDR points to a function descriptor.  */
  if (s && strcmp (s->the_bfd_section->name, ".opd") == 0)
    return read_memory_unsigned_integer (addr, 8);

  return addr;
}

static CORE_ADDR
ia64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  return sp & ~0xfLL;
}

static CORE_ADDR
ia64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr, 
		      struct regcache *regcache, CORE_ADDR bp_addr,
		      int nargs, struct value **args, CORE_ADDR sp,
		      int struct_return, CORE_ADDR struct_addr)
d1784 1
a1784 1
  CORE_ADDR bsp, cfm, pfs, new_bsp, funcdescaddr, pc, global_pointer;
d1788 1
a1788 1
  /* Count the number of slots needed for the arguments.  */
d1804 1
a1804 1
  /* Divvy up the slots between the RSE and the memory stack.  */
d1808 1
a1808 1
  /* Allocate a new RSE frame.  */
d1812 1
d1827 1
a1827 1
     case, we'll need to reserve space on the stack for them.  */
d1833 1
a1833 1
     necessary for the memory slots and our function descriptors.  */
d1835 1
a1835 1
  sp &= ~0xfLL;				/* Maintain 16 byte alignment.  */
d1840 1
a1840 1
     floating point registers.  */
d1851 1
a1851 1
      /* Special handling for function parameters.  */
d1858 3
a1860 3
	  store_unsigned_integer (val_buf, 8,
				  find_func_descr (extract_unsigned_integer (VALUE_CONTENTS (arg), 8),
						   &funcdescaddr));
d1869 1
a1869 1
      /* Normal slots.  */
d1893 1
a1893 1
      /* Handle floating point types (including HFAs).  */
d1901 5
a1905 4
	      char to[MAX_REGISTER_SIZE];
	      convert_typed_floating (VALUE_CONTENTS (arg) + argoffset, float_elt_type,
				      to, builtin_type_ia64_ext);
	      regcache_cooked_write (regcache, floatreg, (void *)to);
d1913 1
a1913 1
  /* Store the struct return value in r8 if necessary.  */
d1916 3
a1918 1
      regcache_cooked_write_unsigned (regcache, IA64_GR8_REGNUM, (ULONGEST)struct_addr);
d1921 2
a1922 1
  global_pointer = FIND_GLOBAL_POINTER (func_addr);
d1924 6
a1929 2
  if (global_pointer != 0)
    write_register (IA64_GR1_REGNUM, global_pointer);
d1931 1
a1931 1
  write_register (IA64_BR0_REGNUM, bp_addr);
d1933 2
a1934 1
  write_register (sp_regnum, sp);
d1939 2
a1940 2
static struct frame_id
ia64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d1942 1
a1942 2
  char buf[8];
  CORE_ADDR sp, bsp;
d1944 2
a1945 2
  frame_unwind_register (next_frame, sp_regnum, buf);
  sp = extract_unsigned_integer (buf, 8);
d1947 3
a1949 2
  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
  bsp = extract_unsigned_integer (buf, 8);
d1951 12
a1962 6
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"dummy frame id: code %lx, stack %lx, special %lx\n",
			frame_pc_unwind (next_frame), sp, bsp);

  return frame_id_build_special (sp, frame_pc_unwind (next_frame), bsp);
d1965 2
a1966 2
static CORE_ADDR 
ia64_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d1968 1
a1968 10
  char buf[8];
  CORE_ADDR ip, psr, pc;

  frame_unwind_register (next_frame, IA64_IP_REGNUM, buf);
  ip = extract_unsigned_integer (buf, 8);
  frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
  psr = extract_unsigned_integer (buf, 8);
 
  pc = (ip & ~0xf) | ((psr >> 41) & 3);
  return pc;
d1972 1
a1972 1
ia64_store_return_value (struct type *type, struct regcache *regcache, const void *valbuf)
d1974 28
a2001 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d2003 2
a2004 4
      char to[MAX_REGISTER_SIZE];
      convert_typed_floating (valbuf, type, to, builtin_type_ia64_ext);
      regcache_cooked_write (regcache, IA64_FR8_REGNUM, (void *)to);
      target_store_registers (IA64_FR8_REGNUM);
d2007 19
a2025 1
    regcache_cooked_write (regcache, IA64_GR8_REGNUM, valbuf);
d2029 1
a2029 3
ia64_remote_translate_xfer_address (struct gdbarch *gdbarch,
				    struct regcache *regcache,
				    CORE_ADDR memaddr, int nr_bytes,
d2062 1
a2062 1
	  /* The case numbers are from abi-tags in glibc.  */
a2082 7
static int
ia64_print_insn (bfd_vma memaddr, struct disassemble_info *info)
{
  info->bytes_per_line = SLOT_MULTIPLIER;
  return print_insn_ia64 (memaddr, info);
}

d2088 1
d2090 28
a2117 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d2121 2
d2129 1
a2129 1
  if (info.osabi == GDB_OSABI_LINUX)
d2143 1
a2143 1
  if (info.osabi == GDB_OSABI_LINUX)
a2149 14
  /* Define the ia64 floating-point format to gdb.  */
  builtin_type_ia64_ext =
    init_type (TYPE_CODE_FLT, 128 / 8,
               0, "builtin_type_ia64_ext", NULL);
  TYPE_FLOATFORMAT (builtin_type_ia64_ext) = &floatformat_ia64_ext;

  /* According to the ia64 specs, instructions that store long double floats 
     in memory use a long-double format different than that used in the floating
     registers.  The memory format matches the x86 extended float format which is
     80 bits.  An OS may choose to use this format (e.g. Linux) or choose to use
     a different format for storing long doubles (e.g. HPUX).  In the latter case,
     the setting of the format may be moved/overridden in an OS-specific tdep file.  */
  set_gdbarch_long_double_format (gdbarch, &floatformat_i387_ext);

d2156 1
a2156 1
  set_gdbarch_long_double_bit (gdbarch, 128);
d2159 1
a2159 2
  set_gdbarch_num_regs (gdbarch, NUM_IA64_RAW_REGS);
  set_gdbarch_num_pseudo_regs (gdbarch, LAST_PSEUDO_REGNUM - FIRST_PSEUDO_REGNUM);
d2161 2
d2166 8
a2173 12
  /* FIXME:  Following interface should not be needed, however, without it recurse.exp
     gets a number of extra failures.  */
  set_gdbarch_deprecated_register_size (gdbarch, 8);
  set_gdbarch_register_type (gdbarch, ia64_register_type);

  set_gdbarch_pseudo_register_read (gdbarch, ia64_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, ia64_pseudo_register_write);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, ia64_dwarf_reg_to_regnum);
  set_gdbarch_register_reggroup_p (gdbarch, ia64_register_reggroup_p);
  set_gdbarch_convert_register_p (gdbarch, ia64_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, ia64_register_to_value);
  set_gdbarch_value_to_register (gdbarch, ia64_value_to_register);
d2177 16
d2194 1
a2194 1
  set_gdbarch_extract_return_value (gdbarch, ia64_extract_return_value);
d2196 3
a2198 2
  set_gdbarch_store_return_value (gdbarch, ia64_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch, ia64_extract_struct_value_address);
d2207 20
a2226 12
  set_gdbarch_push_dummy_call (gdbarch, ia64_push_dummy_call);
  set_gdbarch_frame_align (gdbarch, ia64_frame_align);
  set_gdbarch_unwind_dummy_id (gdbarch, ia64_unwind_dummy_id);

  set_gdbarch_unwind_pc (gdbarch, ia64_unwind_pc);
  frame_unwind_append_sniffer (gdbarch, ia64_sigtramp_frame_sniffer);
#ifdef HAVE_LIBUNWIND_IA64_H
  frame_unwind_append_sniffer (gdbarch, ia64_libunwind_frame_sniffer);
  libunwind_frame_set_descr (gdbarch, &ia64_libunwind_descr);
#endif
  frame_unwind_append_sniffer (gdbarch, ia64_frame_sniffer);
  frame_base_set_default (gdbarch, &ia64_frame_base);
d2231 12
a2249 3
  set_gdbarch_print_insn (gdbarch, ia64_print_insn);
  set_gdbarch_convert_from_func_ptr_addr (gdbarch, ia64_convert_from_func_ptr_addr);

a2252 2
extern initialize_file_ftype _initialize_ia64_tdep; /* -Wmissing-prototypes */

d2257 3
@


1.34.4.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d2483 1
a2483 1
	fprintf_unfiltered (gdb_stdlog, "ia64_find_proc_info_x: %lx -> "
d2485 1
a2485 1
			    "length=%lu,data=%p)\n",
d2497 1
a2497 1
	fprintf_unfiltered (gdb_stdlog, "ia64_find_proc_info_x: %lx -> "
d2499 1
a2499 1
			    "length=%lu,data=%lx)\n",
d3359 6
a3364 8
  /* According to the ia64 specs, instructions that store long double
     floats in memory use a long-double format different than that
     used in the floating registers.  The memory format matches the
     x86 extended float format which is 80 bits.  An OS may choose to
     use this format (e.g. GNU/Linux) or choose to use a different
     format for storing long doubles (e.g. HPUX).  In the latter case,
     the setting of the format may be moved/overridden in an
     OS-specific tdep file.  */
@


1.34.4.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d105 1
d337 26
d653 12
d2712 3
a2714 3
/* Should we use DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc and TYPE
   is the type (which is known to be struct, union or array).  */
d3259 47
d3403 1
a3403 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, ia64_extract_struct_value_address);
d3428 2
@


1.34.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d1378 2
a1379 2
      deprecated_generic_get_saved_register (raw_buffer, optimized, addrp,
					     frame, regnum, lval);
d1905 1
a1905 1
		&deprecated_registers[REGISTER_BYTE (floatreg)]);
d1916 1
a1916 1
      store_address (&deprecated_registers[REGISTER_BYTE (IA64_GR8_REGNUM)],
d1957 1
a1957 1
				    &deprecated_registers[REGISTER_BYTE (IA64_FR8_REGNUM)]);
d1961 2
a1962 2
    deprecated_write_register_bytes (REGISTER_BYTE (IA64_GR8_REGNUM),
				     valbuf, TYPE_LENGTH (type));
@


1.34.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d331 1
a331 1
  if (!(get_frame_type (frame) == SIGTRAMP_FRAME))
d333 1
a333 1
		    "read_sigcontext_register: frame not a signal trampoline");
d706 1
a706 1
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
d708 1
a708 1
  else if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d723 1
a723 1
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
d725 1
a725 1
  else if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d733 1
a733 1
      else if (frame->next && (get_frame_type (frame->next) == SIGTRAMP_FRAME))
d1166 1
a1166 1
  if ((get_frame_type (frame) == SIGTRAMP_FRAME) && SIGCONTEXT_REGISTER_ADDRESS)
d1236 1
a1236 1
  is_dummy_frame = DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame);
d1484 1
a1484 1
    && DEPRECATED_PC_IN_CALL_DUMMY (frame->next->pc, frame->next->frame,
d1496 1
a1496 1
  else if ((get_frame_type (frame->next) == SIGTRAMP_FRAME))
d1518 1
a1518 1
      else if (frn->next && (get_frame_type (frn->next) == SIGTRAMP_FRAME))
d1521 1
a1521 1
               && DEPRECATED_PC_IN_CALL_DUMMY (frn->next->pc, frn->next->frame,
d1534 1
a1534 1
      || (get_frame_type (frame->next) == SIGTRAMP_FRAME) 
a2122 3
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);
d2207 1
d2234 1
d2238 1
@


1.34.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d338 1
a338 1
  regaddr = SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), regnum);
d708 2
a709 4
  else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
					get_frame_base (frame),
					get_frame_base (frame)))
    return get_frame_base (frame);
d713 2
a714 2
      if (get_frame_saved_regs (frame)[IA64_VFP_REGNUM])
	return read_memory_integer (get_frame_saved_regs (frame)[IA64_VFP_REGNUM], 8);
d716 1
a716 2
	return (get_frame_base (frame)
		+ get_frame_extra_info (frame)->mem_stack_frame_size);
d725 2
a726 5
  else if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
					get_frame_base (frame),
					get_frame_base (frame)))
    return deprecated_read_register_dummy (get_frame_pc (frame),
					   get_frame_base (frame), pc_regnum);
d731 4
a734 5
      if (get_frame_saved_regs (frame)[IA64_VRAP_REGNUM])
	return read_memory_integer (get_frame_saved_regs (frame)[IA64_VRAP_REGNUM], 8);
      else if (get_next_frame (frame)
	       && (get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME))
	return read_sigcontext_register (get_next_frame (frame), IA64_BR0_REGNUM);
d835 1
a835 1
  if (frame && !get_frame_saved_regs (frame))
d843 3
a845 3
      && get_frame_extra_info (frame)->after_prologue != 0
      && get_frame_extra_info (frame)->after_prologue <= lim_pc)
    return get_frame_extra_info (frame)->after_prologue;
d940 1
a940 1
	      spill_addr  = (frame ? get_frame_base (frame) : 0)
d963 1
a963 1
	        get_frame_saved_regs (frame)[IA64_FR0_REGNUM + fM] = spill_addr;
d1022 1
a1022 1
		    get_frame_saved_regs (frame)[IA64_UNAT_REGNUM] = spill_addr;
d1029 1
a1029 1
		    get_frame_saved_regs (frame)[IA64_PR_REGNUM] = spill_addr;
d1098 1
a1098 1
		get_frame_saved_regs (frame)[IA64_GR0_REGNUM + rM] = spill_addr;
d1119 2
a1120 2
    sor = ((get_frame_extra_info (frame)->cfm >> 14) & 0xf) * 8;
    rrb_gr = (get_frame_extra_info (frame)->cfm >> 18) & 0x7f;
d1122 2
a1123 2
    for (i = 0, addr = get_frame_extra_info (frame)->bsp;
	 i < get_frame_extra_info (frame)->sof;
d1131 1
a1131 1
	  get_frame_saved_regs (frame)[IA64_GR32_REGNUM + ((i + (sor - rrb_gr)) % sor)] 
d1134 1
a1134 1
	  get_frame_saved_regs (frame)[IA64_GR32_REGNUM + i] = addr;
d1137 1
a1137 1
	  get_frame_saved_regs (frame)[IA64_CFM_REGNUM] = addr;
d1139 1
a1139 1
	  get_frame_saved_regs (frame)[IA64_VRAP_REGNUM] = addr;
d1141 1
a1141 1
	  get_frame_saved_regs (frame)[IA64_VFP_REGNUM] = addr;
d1145 5
a1149 6
  if (frame && get_frame_extra_info (frame))
    {
      get_frame_extra_info (frame)->after_prologue = last_prologue_pc;
      get_frame_extra_info (frame)->mem_stack_frame_size = mem_stack_frame_size;
      get_frame_extra_info (frame)->fp_reg = fp_reg;
    }
d1163 1
a1163 1
  if (get_frame_saved_regs (frame))
d1172 6
a1177 6
      get_frame_saved_regs (frame)[IA64_VRAP_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_IP_REGNUM);
      get_frame_saved_regs (frame)[IA64_CFM_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_CFM_REGNUM);
      get_frame_saved_regs (frame)[IA64_PSR_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_PSR_REGNUM);
d1179 1
a1179 1
      get_frame_saved_regs (frame)[IA64_BSP_REGNUM] = 
d1182 12
a1193 12
      get_frame_saved_regs (frame)[IA64_RNAT_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_RNAT_REGNUM);
      get_frame_saved_regs (frame)[IA64_CCV_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_CCV_REGNUM);
      get_frame_saved_regs (frame)[IA64_UNAT_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_UNAT_REGNUM);
      get_frame_saved_regs (frame)[IA64_FPSR_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_FPSR_REGNUM);
      get_frame_saved_regs (frame)[IA64_PFS_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_PFS_REGNUM);
      get_frame_saved_regs (frame)[IA64_LC_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), IA64_LC_REGNUM);
d1196 2
a1197 2
	  get_frame_saved_regs (frame)[regno] =
	    SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), regno);
d1199 2
a1200 2
	get_frame_saved_regs (frame)[regno] =
	  SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), regno);
d1202 2
a1203 2
	get_frame_saved_regs (frame)[regno] =
	  SIGCONTEXT_REGISTER_ADDRESS (get_frame_base (frame), regno);
d1209 2
a1210 2
      func_start = get_pc_function_start (get_frame_pc (frame));
      examine_prologue (func_start, get_frame_pc (frame), frame);
d1236 1
a1236 3
  is_dummy_frame = DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
						get_frame_base (frame),
						get_frame_base (frame));
d1238 1
a1238 1
  if (regnum == SP_REGNUM && get_next_frame (frame))
d1241 1
a1241 2
      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
		     get_frame_base (frame));
d1246 1
a1246 1
                     get_frame_extra_info (frame)->bsp);
d1254 1
a1254 2
      CORE_ADDR vfp = (get_frame_base (frame)
		       + get_frame_extra_info (frame)->mem_stack_frame_size);
d1270 1
a1270 1
	  int rrb_pr = (get_frame_extra_info (frame)->cfm >> 32) & 0x3f;
d1304 2
a1305 2
	  gr_addr = get_frame_saved_regs (frame)[ regnum - IA64_NAT0_REGNUM 
						+ IA64_GR0_REGNUM];
d1329 1
a1329 1
      if (get_next_frame (frame))
d1332 1
a1332 1
	  pc = ia64_frame_saved_pc (get_next_frame (frame));
d1346 1
a1346 1
	  addr = get_frame_saved_regs (frame)[regnum];
d1370 1
a1370 1
	  int rrb_fr = (get_frame_extra_info (frame)->cfm >> 25) & 0x7f;
d1454 1
a1454 1
  return (get_frame_extra_info (frame)->mem_stack_frame_size == 0);
d1483 3
a1485 4
  int next_frame_is_call_dummy = ((get_next_frame (frame) != NULL)
    && DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (get_next_frame (frame)),
				    get_frame_base (get_next_frame (frame)),
				    get_frame_base (get_next_frame (frame))));
d1487 2
a1488 1
  frame_extra_info_zalloc (frame, sizeof (struct frame_extra_info));
d1490 1
a1490 1
  if (get_next_frame (frame) == 0)
d1496 1
a1496 1
  else if ((get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME))
d1498 2
a1499 2
      bsp = read_sigcontext_register (get_next_frame (frame), IA64_BSP_REGNUM);
      cfm = read_sigcontext_register (get_next_frame (frame), IA64_CFM_REGNUM);
d1503 2
a1504 2
      bsp = deprecated_read_register_dummy (get_frame_pc (get_next_frame (frame)),
					    get_frame_base (get_next_frame (frame)),
d1506 2
a1507 2
      cfm = deprecated_read_register_dummy (get_frame_pc (get_next_frame (frame)),
					    get_frame_base (get_next_frame (frame)),
d1512 1
a1512 1
      struct frame_info *frn = get_next_frame (frame);
d1516 8
a1523 10
      if (get_frame_saved_regs (frn)[IA64_CFM_REGNUM] != 0)
	cfm = read_memory_integer (get_frame_saved_regs (frn)[IA64_CFM_REGNUM], 8);
      else if (get_next_frame (frn) && (get_frame_type (get_next_frame (frn)) == SIGTRAMP_FRAME))
	cfm = read_sigcontext_register (get_next_frame (frn), IA64_PFS_REGNUM);
      else if (get_next_frame (frn)
               && DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (get_next_frame (frn)),
					       get_frame_base (get_next_frame (frn)),
					       get_frame_base (get_next_frame (frn))))
	cfm = deprecated_read_register_dummy (get_frame_pc (get_next_frame (frn)),
					      get_frame_base (get_next_frame (frn)),
d1528 1
a1528 1
      bsp = get_frame_extra_info (frn)->bsp;
d1530 5
a1534 5
  get_frame_extra_info (frame)->cfm = cfm;
  get_frame_extra_info (frame)->sof = cfm & 0x7f;
  get_frame_extra_info (frame)->sol = (cfm >> 7) & 0x7f;
  if (get_next_frame (frame) == 0 
      || (get_frame_type (get_next_frame (frame)) == SIGTRAMP_FRAME) 
d1536 1
a1536 2
    get_frame_extra_info (frame)->bsp =
      rse_address_add (bsp, -get_frame_extra_info (frame)->sof);
d1538 1
a1538 2
    get_frame_extra_info (frame)->bsp =
      rse_address_add (bsp, -get_frame_extra_info (frame)->sol);
d1540 3
a1542 3
  get_frame_extra_info (frame)->after_prologue = 0;
  get_frame_extra_info (frame)->mem_stack_frame_size = -1;		/* Not yet determined */
  get_frame_extra_info (frame)->fp_reg = 0;
d1981 1
a1981 1
      if (get_frame_saved_regs (frame)[regno]
d1991 1
a1991 1
			  read_memory_integer (get_frame_saved_regs (frame)[regno],
d2001 1
a2001 1
  if (get_frame_saved_regs (frame)[IA64_PFS_REGNUM])
d2003 1
a2003 1
      pfs = read_memory_integer (get_frame_saved_regs (frame)[IA64_PFS_REGNUM],
d2017 1
a2017 1
  bsp = rse_address_add (get_frame_extra_info (frame)->bsp,
d2186 1
@


1.34.2.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d97 1
d103 1
d714 1
a714 1
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d735 1
a735 1
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d1315 1
a1315 1
	  DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d1357 1
a1357 1
	  DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d1465 1
a1465 1
  DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d1526 1
a1526 1
      DEPRECATED_FRAME_INIT_SAVED_REGS (frn);
d1993 1
a1993 1
  DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d2189 1
a2189 1
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 16);
d2191 1
a2191 1
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 16);
d2204 1
a2204 1
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, ia64_frame_init_saved_regs);
d2234 1
a2234 1
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, ia64_init_extra_frame_info);
d2255 1
@


1.34.2.5
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d94 2
d97 1
d102 5
a106 1
static gdbarch_deprecated_saved_pc_after_call_ftype ia64_saved_pc_after_call;
d283 1
a283 1
      deprecated_store_floating (to, TYPE_LENGTH(type), val);
d295 1
a295 1
      DOUBLEST val = deprecated_extract_floating (from, TYPE_LENGTH(type));
d1215 1
a1215 1
      func_start = get_frame_func (frame);
d2010 2
a2011 2
  write_register (sp_regnum, DEPRECATED_FRAME_CHAIN (frame));
  write_pc (DEPRECATED_FRAME_SAVED_PC (frame));
d2197 1
a2197 1
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, ia64_saved_pc_after_call);
d2199 2
a2200 2
  set_gdbarch_deprecated_frame_chain (gdbarch, ia64_frame_chain);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, ia64_frame_saved_pc);
d2203 1
a2203 1
  set_gdbarch_deprecated_get_saved_register (gdbarch, ia64_get_saved_register);
d2212 1
a2212 1
  set_gdbarch_deprecated_store_struct_return (gdbarch, ia64_store_struct_return);
d2223 4
a2226 3
  set_gdbarch_deprecated_push_arguments (gdbarch, ia64_push_arguments);
  set_gdbarch_deprecated_push_return_address (gdbarch, ia64_push_return_address);
  set_gdbarch_deprecated_pop_frame (gdbarch, ia64_pop_frame);
d2228 1
d2231 1
d2247 7
a2253 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.34.2.6
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d681 2
a682 2
   other places.  (E.g, note that deprecated_read_fp() is actually
   read_sp() in ia64_gdbarch_init() below.)
d2171 1
a2171 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, fp_regnum);
d2226 6
a2231 6
  /* We won't necessarily have a frame pointer and even if we do, it
     winds up being extraordinarly messy when attempting to find the
     frame chain.  So for the purposes of creating frames (which is
     all deprecated_read_fp() is used for), simply use the stack
     pointer value instead.  */
  set_gdbarch_deprecated_target_read_fp (gdbarch, generic_target_read_sp);
d2254 2
a2255 2
  deprecated_tm_print_insn = print_insn_ia64;
  deprecated_tm_print_insn_info.bytes_per_line = SLOT_MULTIPLIER;
@


1.34.2.7
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d546 1
a546 1
#define IA64_BREAKPOINT 0x00002000040LL
d548 1
a548 1
#define IA64_BREAKPOINT 0x00003333300LL
d576 1
a576 1
  replace_slotN_contents (bundle, IA64_BREAKPOINT, slotnum);
d740 1
a740 1
static int max_skip_non_prologue_insns = 40;
a827 1
  char reg_contents[256];
a828 1
  int frameless = 0;
a831 1
  memset (reg_contents, 0, sizeof reg_contents);
d846 2
a848 3

  /* We want to check if we have a recognizable function start before we
     look ahead for a prologue.  */
d852 1
a852 1
      /* alloc - start of a regular function.  */
d867 3
a869 29
      /* Look for a leaf routine.  */
      if (pc < lim_pc && next_pc
	  && (it == I || it == M) 
          && ((instr & 0x1ee00000000LL) == 0x10800000000LL))
	{
	  /* adds rN = imm14, rM   (or mov rN, rM  when imm14 is 0) */
	  int imm = (int) ((((instr & 0x01000000000LL) ? -1 : 0) << 13) 
	                   | ((instr & 0x001f8000000LL) >> 20)
		           | ((instr & 0x000000fe000LL) >> 13));
	  int rM = (int) ((instr & 0x00007f00000LL) >> 20);
	  int rN = (int) ((instr & 0x00000001fc0LL) >> 6);
	  int qp = (int) (instr & 0x0000000003fLL);
	  if (qp == 0 && rN == 2 && imm == 0 && rM == 12 && fp_reg == 0)
	    {
	      /* mov r2, r12 - beginning of leaf routine */
	      fp_reg = rN;
	      frameless = 1;
	      last_prologue_pc = next_pc;
	    }
	} 

      /* If we don't recognize a regular function or leaf routine, we are
	 done.  */
      if (!fp_reg)
	{
	  pc = lim_pc;	
	  if (trust_limit)
	    last_prologue_pc = lim_pc;
	}
a884 2
	  if (trust_limit)
	    lim_pc = pc;
a943 14
	  else if (qp == 0 && rM >= 32 && rM < 40 && !instores[rM] && 
		   rN < 256 && imm == 0)
	    {
	      /* mov rN, rM where rM is an input register */
	      reg_contents[rN] = rM;
	      last_prologue_pc = next_pc;
	    }
	  else if (frameless && qp == 0 && rN == fp_reg && imm == 0 && 
		   rM == 2)
	    {
	      /* mov r12, r2 */
	      last_prologue_pc = next_pc;
	      break;
	    }
a1008 1
	  int indirect = rM < 256 ? reg_contents[rM] : 0;
a1042 7
	  else if (qp == 0 && 32 <= indirect && indirect < 40 && 
		   !instores[indirect-32])
	    {
	      /* Allow an indirect store of an input register.  */
	      instores[indirect-32] = 1;
	      last_prologue_pc = next_pc;
	    }
a1056 1
	  int indirect = rM < 256 ? reg_contents[rM] : 0;
a1061 7
	  else if (qp == 0 && 32 <= indirect && indirect < 40 && 
		   !instores[indirect-32])
	    {
	      /* Allow an indirect store of an input register.  */
	      instores[indirect-32] = 1;
	      last_prologue_pc = next_pc;
	    }
a1149 4
  /* Try and trust the lim_pc value whenever possible.  */
  if (trust_limit && lim_pc >= last_prologue_pc)
    return lim_pc;

d1242 2
a1243 2
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum),
			      get_frame_base (frame));
d1247 2
a1248 2
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum), 
			      get_frame_extra_info (frame)->bsp);
d1258 1
a1258 1
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (IA64_VFP_REGNUM), vfp);
d1262 1
a1262 1
      char pr_raw_buffer[MAX_REGISTER_SIZE];
d1285 1
a1285 1
      char unat_raw_buffer[MAX_REGISTER_SIZE];
d1341 1
a1341 1
      store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (IA64_IP_REGNUM), pc);
d1772 2
a1773 2
      store_unsigned_integer (buf, 8, faddr);
      store_unsigned_integer (buf + 8, 8, global_pointer);
d1865 3
a1867 3
	  store_unsigned_integer (val_buf, 8,
				  find_func_descr (extract_address (VALUE_CONTENTS (arg), 8),
						   &funcdescaddr));
d1923 3
a1925 3
      store_unsigned_integer (&deprecated_registers[REGISTER_BYTE (IA64_GR8_REGNUM)],
			      REGISTER_RAW_SIZE (IA64_GR8_REGNUM),
			      struct_addr);
d2036 1
a2036 3
ia64_remote_translate_xfer_address (struct gdbarch *gdbarch,
				    struct regcache *regcache,
				    CORE_ADDR memaddr, int nr_bytes,
d2176 2
a2177 2
  set_gdbarch_deprecated_register_size (gdbarch, 8);
  set_gdbarch_deprecated_register_bytes (gdbarch, ia64_num_regs * 8 + 128*8);
d2220 2
a2221 2
  set_gdbarch_deprecated_call_dummy_words (gdbarch, ia64_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (ia64_call_dummy_words));
@


1.34.2.8
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d31 1
a31 1
#include "gdb_assert.h"
d89 4
d242 1
a242 1
static int
d248 1
a248 1
static int
d256 1
a256 1
static int
d268 1
a268 1
static void
d282 1
a282 1
static void
d284 1
a284 1
                              const char *from, char *to)
d304 1
a304 1
static int
d626 1
a626 13
static CORE_ADDR
ia64_read_fp (void)
{
  /* We won't necessarily have a frame pointer and even if we do, it
     winds up being extraordinarly messy when attempting to find the
     frame chain.  So for the purposes of creating frames (which is
     all deprecated_read_fp() is used for), simply use the stack
     pointer value instead.  */
  gdb_assert (SP_REGNUM >= 0);
  return read_register (SP_REGNUM);
}

static CORE_ADDR
d636 1
a636 1
static void
d694 1
a694 1
static CORE_ADDR
d714 1
a714 1
static CORE_ADDR
d1225 1
a1225 1
static void
d1279 1
a1279 1
static void
d1511 1
a1511 1
static void
d1532 1
a1532 1
static CORE_ADDR
d1540 1
a1540 1
static CORE_ADDR
d1548 1
a1548 1
static void
d1750 1
a1750 1
		  global_pointer = extract_unsigned_integer (buf, sizeof (buf));
d1847 1
a1847 1
static CORE_ADDR
d1932 1
a1932 1
				  find_func_descr (extract_unsigned_integer (VALUE_CONTENTS (arg), 8),
d1997 6
a2002 7
  /* FIXME: This doesn't belong here!  Instead,
     DEPRECATED_SAVE_DUMMY_FRAME_TOS needs to be defined to call
     generic_save_dummy_frame_tos().  But at the time of this writing,
     DEPRECATED_SAVE_DUMMY_FRAME_TOS wasn't gdbarch'd, so I chose to
     put this call here instead of using the old mechanisms.  Once
     DEPRECATED_SAVE_DUMMY_FRAME_TOS is gdbarch'd, all we need to do
     is add the line
d2004 1
a2004 1
	set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
d2012 1
a2012 1
static CORE_ADDR
d2024 1
a2024 1
static void
d2038 1
a2038 1
static void
d2234 1
a2234 1
  set_gdbarch_long_double_bit (gdbarch, 128);
d2246 2
a2247 2
  set_gdbarch_deprecated_register_byte (gdbarch, ia64_register_byte);
  set_gdbarch_deprecated_register_raw_size (gdbarch, ia64_register_raw_size);
d2249 1
a2249 1
  set_gdbarch_deprecated_register_virtual_size (gdbarch, ia64_register_virtual_size);
d2251 1
a2251 1
  set_gdbarch_deprecated_register_virtual_type (gdbarch, ia64_register_virtual_type);
d2255 1
d2266 3
a2268 3
  set_gdbarch_deprecated_register_convertible (gdbarch, ia64_register_convertible);
  set_gdbarch_deprecated_register_convert_to_virtual (gdbarch, ia64_register_convert_to_virtual);
  set_gdbarch_deprecated_register_convert_to_raw (gdbarch, ia64_register_convert_to_raw);
d2291 2
a2292 2
  set_gdbarch_deprecated_frame_args_address (gdbarch, ia64_frame_args_address);
  set_gdbarch_deprecated_frame_locals_address (gdbarch, ia64_frame_locals_address);
d2299 1
a2299 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, ia64_read_fp);
d2304 2
a2305 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
a2315 2

extern initialize_file_ftype _initialize_ia64_tdep; /* -Wmissing-prototypes */
@


1.34.2.9
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d1523 1
a1523 1
  /* Note that most of the work was done in ia64_push_dummy_call() */
d1856 2
a1857 4
ia64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr,
		      int nargs, struct value **args, CORE_ADDR sp,
		      int struct_return, CORE_ADDR struct_addr)
d1865 1
a1865 3
  ULONGEST bsp, cfm, pfs, new_bsp;
  CORE_ADDR funcdescaddr;
  ULONGEST global_pointer = FIND_GLOBAL_POINTER (func_addr);
d1890 1
a1890 1
  regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);
d1892 1
a1892 1
  regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
d1895 1
a1895 1
  regcache_cooked_write_unsigned (regcache, IA64_BSP_REGNUM, new_bsp);
d1897 1
a1897 1
  regcache_cooked_read_unsigned (regcache, IA64_PFS_REGNUM, &pfs);
d1900 1
a1900 1
  regcache_cooked_write_unsigned (regcache, IA64_PFS_REGNUM, pfs);
d1904 1
a1904 1
  regcache_cooked_write_unsigned (regcache, IA64_CFM_REGNUM, cfm);
d1982 5
a1986 6
	      char buf[MAX_REGISTER_SIZE];
	      ia64_register_convert_to_raw (float_elt_type,
					    floatreg,
					    VALUE_CONTENTS (arg) + argoffset,
					    buf);
	      regcache_raw_write (regcache, floatreg, buf);
d1997 3
a1999 1
      regcache_cooked_write_unsigned (regcache, IA64_GR8_REGNUM, struct_addr);
a2001 5
  if (global_pointer != 0)
    regcache_cooked_write_unsigned (regcache, IA64_GR1_REGNUM, global_pointer);

  regcache_cooked_write_unsigned (regcache, IA64_BR0_REGNUM, bp_addr);

d2021 12
a2166 7
static int
ia64_print_insn (bfd_vma memaddr, struct disassemble_info *info)
{
  info->bytes_per_line = SLOT_MULTIPLIER;
  return print_insn_ia64 (memaddr, info);
}

d2292 2
a2293 1
  set_gdbarch_push_dummy_call (gdbarch, ia64_push_dummy_call);
a2320 2
  set_gdbarch_print_insn (gdbarch, ia64_print_insn);

d2330 3
@


1.34.2.10
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a28 4
#include "reggroups.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
a34 1
#include "dis-asm.h"
a88 1
static gdbarch_register_type_ftype ia64_register_type;
d91 2
a92 2
static gdbarch_extract_return_value_ftype ia64_extract_return_value;
static gdbarch_extract_struct_value_address_ftype ia64_extract_struct_value_address;
d94 3
d99 1
a99 3
static struct type *builtin_type_ia64_ext;

#define NUM_IA64_RAW_REGS 462
d101 1
d106 1
a106 5
/* NOTE: we treat the register stack registers r32-r127 as pseudo-registers because
   they are in memory and must be calculated via the bsp register.  */
enum pseudo_regs { FIRST_PSEUDO_REGNUM = NUM_IA64_RAW_REGS, VBOF_REGNUM = IA64_NAT127_REGNUM + 1, V32_REGNUM, 
		   V127_REGNUM = V32_REGNUM + 95, 
		   VP0_REGNUM, VP16_REGNUM = VP0_REGNUM + 16, VP63_REGNUM = VP0_REGNUM + 63, LAST_PSEUDO_REGNUM };
d116 12
a127 12
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
d146 8
a153 8
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
a193 24

  "bof",
  
  "r32",  "r33",  "r34",  "r35",  "r36",  "r37",  "r38",  "r39",   
  "r40",  "r41",  "r42",  "r43",  "r44",  "r45",  "r46",  "r47",
  "r48",  "r49",  "r50",  "r51",  "r52",  "r53",  "r54",  "r55",
  "r56",  "r57",  "r58",  "r59",  "r60",  "r61",  "r62",  "r63",
  "r64",  "r65",  "r66",  "r67",  "r68",  "r69",  "r70",  "r71",
  "r72",  "r73",  "r74",  "r75",  "r76",  "r77",  "r78",  "r79",
  "r80",  "r81",  "r82",  "r83",  "r84",  "r85",  "r86",  "r87",
  "r88",  "r89",  "r90",  "r91",  "r92",  "r93",  "r94",  "r95",
  "r96",  "r97",  "r98",  "r99",  "r100", "r101", "r102", "r103",
  "r104", "r105", "r106", "r107", "r108", "r109", "r110", "r111",
  "r112", "r113", "r114", "r115", "r116", "r117", "r118", "r119",
  "r120", "r121", "r122", "r123", "r124", "r125", "r126", "r127",

  "p0",   "p1",   "p2",   "p3",   "p4",   "p5",   "p6",   "p7",
  "p8",   "p9",   "p10",  "p11",  "p12",  "p13",  "p14",  "p15",
  "p16",  "p17",  "p18",  "p19",  "p20",  "p21",  "p22",  "p23",
  "p24",  "p25",  "p26",  "p27",  "p28",  "p29",  "p30",  "p31",
  "p32",  "p33",  "p34",  "p35",  "p36",  "p37",  "p38",  "p39",
  "p40",  "p41",  "p42",  "p43",  "p44",  "p45",  "p46",  "p47",
  "p48",  "p49",  "p50",  "p51",  "p52",  "p53",  "p54",  "p55",
  "p56",  "p57",  "p58",  "p59",  "p60",  "p61",  "p62",  "p63",
d196 15
a210 20
struct ia64_frame_cache
{
  CORE_ADDR base;       /* frame pointer base for frame */
  CORE_ADDR pc;		/* function start pc for frame */
  CORE_ADDR saved_sp;	/* stack pointer for frame */
  CORE_ADDR bsp;	/* points at r32 for the current frame */
  CORE_ADDR cfm;	/* cfm value for current frame */
  int   frameless;
  int   sof;		/* Size of frame  (decoded from cfm value) */
  int	sol;		/* Size of locals (decoded from cfm value) */
  int	sor;		/* Number of rotating registers. (decoded from cfm value) */
  CORE_ADDR after_prologue;
  /* Address of first instruction after the last
     prologue instruction;  Note that there may
     be instructions from the function's body
     intermingled with the prologue. */
  int mem_stack_frame_size;
  /* Size of the memory stack frame (may be zero),
     or -1 if it has not been determined yet. */
  int	fp_reg;		/* Register number (if any) used a frame pointer
d213 1
a213 5
  
  /* Saved registers.  */
  CORE_ADDR saved_regs[NUM_IA64_RAW_REGS];

};
d232 2
a233 3
int
ia64_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *group)
d235 1
a235 17
  int vector_p;
  int float_p;
  int raw_p;
  if (group == all_reggroup)
    return 1;
  vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));
  float_p = TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT;
  raw_p = regnum < NUM_IA64_RAW_REGS;
  if (group == float_reggroup)
    return float_p;
  if (group == vector_reggroup)
    return vector_p;
  if (group == general_reggroup)
    return (!vector_p && !float_p);
  if (group == save_reggroup || group == restore_reggroup)
    return raw_p; 
  return 0;
d238 2
a239 2
static const char *
ia64_register_name (int reg)
d241 1
a241 1
  return ia64_register_names[reg];
d244 2
a245 2
struct type *
ia64_register_type (struct gdbarch *arch, int reg)
d247 1
a247 4
  if (reg >= IA64_FR0_REGNUM && reg <= IA64_FR127_REGNUM)
    return builtin_type_ia64_ext;
  else
    return builtin_type_long;
d250 2
d253 1
a253 1
ia64_dwarf_reg_to_regnum (int reg)
d255 1
a255 3
  if (reg >= IA64_GR32_REGNUM && reg <= IA64_GR127_REGNUM)
    return V32_REGNUM + (reg - IA64_GR32_REGNUM);
  return reg;
d264 42
d680 24
a703 3
static void
ia64_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
                           int regnum, void *buf)
d705 7
a711 1
  if (regnum >= V32_REGNUM && regnum <= V127_REGNUM)
d713 3
a715 16
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get start of register frame.  */
      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	{
	  ULONGEST reg_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
	  reg = read_memory_integer ((CORE_ADDR)reg_addr, 8);
	  store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), reg);
	}
d717 2
a718 44
	store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), 0);
    }
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT31_REGNUM)
    {
      ULONGEST unatN_val;
      ULONGEST unat;
      regcache_cooked_read_unsigned (regcache, IA64_UNAT_REGNUM, &unat);
      unatN_val = (unat & (1LL << (regnum - IA64_NAT0_REGNUM))) != 0;
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), unatN_val);
    }
  else if (IA64_NAT32_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      ULONGEST natN_val = 0;
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR gr_addr = 0;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get start of register frame.  */
      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	gr_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
      
      if (gr_addr != 0)
	{
	  /* Compute address of nat collection bits.  */
	  CORE_ADDR nat_addr = gr_addr | 0x1f8;
	  CORE_ADDR nat_collection;
	  int nat_bit;
	  /* If our nat collection address is bigger than bsp, we have to get
	     the nat collection from rnat.  Otherwise, we fetch the nat
	     collection from the computed address.  */
	  if (nat_addr >= bsp)
	    regcache_cooked_read_unsigned (regcache, IA64_RNAT_REGNUM, &nat_collection);
	  else
	    nat_collection = read_memory_integer (nat_addr, 8);
	  nat_bit = (gr_addr >> 3) & 0x3f;
	  natN_val = (nat_collection >> nat_bit) & 1;
	}
      
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), natN_val);
a719 39
  else if (regnum == VBOF_REGNUM)
    {
      /* A virtual register frame start is provided for user convenience.
         It can be calculated as the bsp - sof (sizeof frame). */
      ULONGEST bsp, vbsp;
      ULONGEST cfm;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get beginning of frame.  */
      vbsp = rse_address_add (bsp, -(cfm & 0x7f));
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), vbsp);
    }
  else if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    {
      ULONGEST pr;
      ULONGEST cfm;
      ULONGEST prN_val;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_PR_REGNUM, &pr);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  /* Fetch predicate register rename base from current frame
	     marker for this frame. */
	  int rrb_pr = (cfm >> 32) & 0x3f;

	  /* Adjust the register number to account for register rotation. */
	  regnum = VP16_REGNUM 
	         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = (pr & (1LL << (regnum - VP0_REGNUM))) != 0;
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum), prN_val);
    }
  else
    memset (buf, 0, REGISTER_RAW_SIZE (regnum));
d722 2
a723 3
static void
ia64_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int regnum, const void *buf)
d725 8
a732 79
  if (regnum >= V32_REGNUM && regnum <= V127_REGNUM)
    {
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR reg;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	{
	  ULONGEST reg_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
	  write_memory (reg_addr, (void *)buf, 8);
	}
    }
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT31_REGNUM)
    {
      ULONGEST unatN_val, unat, unatN_mask;
      regcache_cooked_read_unsigned (regcache, IA64_UNAT_REGNUM, &unat);
      unatN_val = extract_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum)); 
      unatN_mask = (1LL << (regnum - IA64_NAT0_REGNUM));
      if (unatN_val == 0)
	unat &= ~unatN_mask;
      else if (unatN_val == 1)
	unat |= unatN_mask;
      regcache_cooked_write_unsigned (regcache, IA64_UNAT_REGNUM, unat);
    }
  else if (IA64_NAT32_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      ULONGEST natN_val;
      ULONGEST bsp;
      ULONGEST cfm;
      CORE_ADDR gr_addr = 0;
      regcache_cooked_read_unsigned (regcache, IA64_BSP_REGNUM, &bsp);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      /* The bsp points at the end of the register frame so we
	 subtract the size of frame from it to get start of register frame.  */
      bsp = rse_address_add (bsp, -(cfm & 0x7f));
 
      if ((cfm & 0x7f) > regnum - V32_REGNUM) 
	gr_addr = rse_address_add (bsp, (regnum - V32_REGNUM));
      
      natN_val = extract_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum)); 

      if (gr_addr != 0 && (natN_val == 0 || natN_val == 1))
	{
	  /* Compute address of nat collection bits.  */
	  CORE_ADDR nat_addr = gr_addr | 0x1f8;
	  CORE_ADDR nat_collection;
	  int natN_bit = (gr_addr >> 3) & 0x3f;
	  ULONGEST natN_mask = (1LL << natN_bit);
	  /* If our nat collection address is bigger than bsp, we have to get
	     the nat collection from rnat.  Otherwise, we fetch the nat
	     collection from the computed address.  */
	  if (nat_addr >= bsp)
	    {
	      regcache_cooked_read_unsigned (regcache, IA64_RNAT_REGNUM, &nat_collection);
	      if (natN_val)
		nat_collection |= natN_mask;
	      else
		nat_collection &= ~natN_mask;
	      regcache_cooked_write_unsigned (regcache, IA64_RNAT_REGNUM, nat_collection);
	    }
	  else
	    {
	      char nat_buf[8];
	      nat_collection = read_memory_integer (nat_addr, 8);
	      if (natN_val)
		nat_collection |= natN_mask;
	      else
		nat_collection &= ~natN_mask;
	      store_unsigned_integer (nat_buf, REGISTER_RAW_SIZE (regnum), nat_collection);
	      write_memory (nat_addr, nat_buf, 8);
	    }
	}
    }
  else if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
d734 1
a734 13
      ULONGEST pr;
      ULONGEST cfm;
      ULONGEST prN_val;
      ULONGEST prN_mask;

      regcache_cooked_read_unsigned (regcache, IA64_PR_REGNUM, &pr);
      regcache_cooked_read_unsigned (regcache, IA64_CFM_REGNUM, &cfm);

      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  /* Fetch predicate register rename base from current frame
	     marker for this frame. */
	  int rrb_pr = (cfm >> 32) & 0x3f;
d736 7
a742 11
	  /* Adjust the register number to account for register rotation. */
	  regnum = VP16_REGNUM 
	         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = extract_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum)); 
      prN_mask = (1LL << (regnum - VP0_REGNUM));
      if (prN_val == 0)
	pr &= ~prN_mask;
      else if (prN_val == 1)
	pr |= prN_mask;
      regcache_cooked_write_unsigned (regcache, IA64_PR_REGNUM, pr);
a745 28
/* The ia64 needs to convert between various ieee floating-point formats
   and the special ia64 floating point register format.  */

static int
ia64_convert_register_p (int regno, struct type *type)
{
  return (regno >= IA64_FR0_REGNUM && regno <= IA64_FR127_REGNUM);
}

static void
ia64_register_to_value (struct frame_info *frame, int regnum,
                         struct type *valtype, void *out)
{
  char in[MAX_REGISTER_SIZE];
  frame_register_read (frame, regnum, in);
  convert_typed_floating (in, builtin_type_ia64_ext, out, valtype);
}

static void
ia64_value_to_register (struct frame_info *frame, int regnum,
                         struct type *valtype, const void *in)
{
  char out[MAX_REGISTER_SIZE];
  convert_typed_floating (in, valtype, out, builtin_type_ia64_ext);
  put_frame_register (frame, regnum, out);
}


a816 27
/* Allocate and initialize a frame cache.  */

static struct ia64_frame_cache *
ia64_alloc_frame_cache (void)
{
  struct ia64_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct ia64_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->pc = 0;
  cache->cfm = 0;
  cache->sof = 0;
  cache->sol = 0;
  cache->sor = 0;
  cache->bsp = 0;
  cache->fp_reg = 0;
  cache->frameless = 1;

  for (i = 0; i < NUM_IA64_RAW_REGS; i++)
    cache->saved_regs[i] = 0;

  return cache;
}

d818 1
a818 1
examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc, struct frame_info *next_frame, struct ia64_frame_cache *cache)
d824 2
d838 1
a838 5
  int frameless = 1;
  int i;
  CORE_ADDR addr;
  char buf[8];
  CORE_ADDR bof, sor, sol, sof, cfm, rrb_gr;
d844 11
a854 3
  if (cache->after_prologue != 0
      && cache->after_prologue <= lim_pc)
    return cache->after_prologue;
d868 4
a872 11

      /* Verify that the current cfm matches what we think is the
	 function start.  If we have somehow jumped within a function,
	 we do not want to interpret the prologue and calculate the
	 addresses of various registers such as the return address.  
	 We will instead treat the frame as frameless. */
      if (!next_frame ||
	  (sof == (cache->cfm & 0x7f) &&
	   sol == ((cache->cfm >> 7) & 0x7f)))
	frameless = 0;

d895 1
d918 2
a919 9
      if (it == B && ((instr & 0x1e1f800003f) != 0x04000000000))
	{
	  /* Exit loop upon hitting a non-nop branch instruction. */ 
	  if (trust_limit)
	    lim_pc = pc;
	  break;
	}
      else if (((instr & 0x3fLL) != 0LL) && 
	       (frameless || ret_reg != 0))
d921 2
a922 2
	  /* Exit loop upon hitting a predicated instruction if
	     we already have the return register or if we are frameless.  */ 
a965 2
	      char buf[MAX_REGISTER_SIZE];
	      CORE_ADDR saved_sp = 0;
d978 1
a978 6
	      if (next_frame)
		{
		  frame_unwind_register (next_frame, sp_regnum, buf);
		  saved_sp = extract_unsigned_integer (buf, 8);
		}
	      spill_addr  = saved_sp
d1014 2
a1015 1
	      cache->saved_regs[IA64_FR0_REGNUM + fM] = spill_addr;
d1074 2
a1075 1
		  cache->saved_regs[IA64_UNAT_REGNUM] = spill_addr;
d1081 2
a1082 1
		  cache->saved_regs[IA64_PR_REGNUM] = spill_addr;
d1165 2
a1166 1
	      cache->saved_regs[IA64_GR0_REGNUM + rM] = spill_addr;
d1179 33
a1211 2
  /* If not frameless and we aren't called by skip_prologue, then we need to calculate
     registers for the previous frame which will be needed later.  */
d1213 1
a1213 1
  if (!frameless && next_frame)
d1215 3
a1217 58
      /* Extract the size of the rotating portion of the stack
	 frame and the register rename base from the current
	 frame marker. */
      cfm = cache->cfm;
      sor = cache->sor;
      sof = cache->sof;
      sol = cache->sol;
      rrb_gr = (cfm >> 18) & 0x7f;

      /* Find the bof (beginning of frame).  */
      bof = rse_address_add (cache->bsp, -sof);
      
      for (i = 0, addr = bof;
	   i < sof;
	   i++, addr += 8)
	{
	  if (IS_NaT_COLLECTION_ADDR (addr))
	    {
	      addr += 8;
	    }
	  if (i+32 == cfm_reg)
	    cache->saved_regs[IA64_CFM_REGNUM] = addr;
	  if (i+32 == ret_reg)
	    cache->saved_regs[IA64_VRAP_REGNUM] = addr;
	  if (i+32 == fp_reg)
	    cache->saved_regs[IA64_VFP_REGNUM] = addr;
	}

      /* For the previous argument registers we require the previous bof.  
	 If we can't find the previous cfm, then we can do nothing.  */
      if (cache->saved_regs[IA64_CFM_REGNUM] != 0)
	{
	  cfm = read_memory_integer (cache->saved_regs[IA64_CFM_REGNUM], 8);
	  sor = ((cfm >> 14) & 0xf) * 8;
	  sof = (cfm & 0x7f);
	  sol = (cfm >> 7) & 0x7f;
	  rrb_gr = (cfm >> 18) & 0x7f;

	  /* The previous bof only requires subtraction of the sol (size of locals)
	     due to the overlap between output and input of subsequent frames.  */
	  bof = rse_address_add (bof, -sol);
	  
	  for (i = 0, addr = bof;
	       i < sof;
	       i++, addr += 8)
	    {
	      if (IS_NaT_COLLECTION_ADDR (addr))
		{
		  addr += 8;
		}
	      if (i < sor)
		cache->saved_regs[IA64_GR32_REGNUM + ((i + (sor - rrb_gr)) % sor)] 
		  = addr;
	      else
		cache->saved_regs[IA64_GR32_REGNUM + i] = addr;
	    }
	  
	}
d1219 1
a1219 1
      
d1222 1
a1222 6
    last_prologue_pc = lim_pc;

  cache->frameless = frameless;
  cache->after_prologue = last_prologue_pc;
  cache->mem_stack_frame_size = mem_stack_frame_size;
  cache->fp_reg = fp_reg;
d1230 1
a1230 8
  struct ia64_frame_cache cache;
  cache.base = 0;
  cache.after_prologue = 0;
  cache.cfm = 0;
  cache.bsp = 0;

  /* Call examine_prologue with - as third argument since we don't have a next frame pointer to send.  */
  return examine_prologue (pc, pc+1024, 0, &cache);
d1233 2
a1234 5

/* Normal frames.  */

static struct ia64_frame_cache *
ia64_frame_cache (struct frame_info *next_frame, void **this_cache)
d1236 2
a1237 4
  struct ia64_frame_cache *cache;
  char buf[8];
  CORE_ADDR cfm, sof, sol, bsp, psr;
  int i;
d1239 3
a1241 2
  if (*this_cache)
    return *this_cache;
d1243 1
a1243 2
  cache = ia64_alloc_frame_cache ();
  *this_cache = cache;
d1245 36
a1280 2
  frame_unwind_register (next_frame, sp_regnum, buf);
  cache->saved_sp = extract_unsigned_integer (buf, 8);
d1282 3
a1284 26
  /* We always want the bsp to point to the end of frame.
     This way, we can always get the beginning of frame (bof)
     by subtracting frame size.  */
  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
  cache->bsp = extract_unsigned_integer (buf, 8);
  
  frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
  psr = extract_unsigned_integer (buf, 8);

  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
  cfm = extract_unsigned_integer (buf, 8);

  cache->sof = (cfm & 0x7f);
  cache->sol = (cfm >> 7) & 0x7f;
  cache->sor = ((cfm >> 14) & 0xf) * 8;

  cache->cfm = cfm;

  cache->pc = frame_func_unwind (next_frame);

  if (cache->pc != 0)
    examine_prologue (cache->pc, frame_pc_unwind (next_frame), next_frame, cache);
  
  cache->base = cache->saved_sp + cache->mem_stack_frame_size;

  return cache;
d1288 6
a1293 2
ia64_frame_this_id (struct frame_info *next_frame, void **this_cache,
		    struct frame_id *this_id)
d1295 1
a1295 2
  struct ia64_frame_cache *cache =
    ia64_frame_cache (next_frame, this_cache);
d1297 2
a1298 3
  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d1300 2
a1301 2
  (*this_id) = frame_id_build (cache->base, cache->pc);
}
d1303 2
a1304 10
static void
ia64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *valuep)
{
  struct ia64_frame_cache *cache =
    ia64_frame_cache (next_frame, this_cache);
  char dummy_valp[MAX_REGISTER_SIZE];
  char buf[8];
d1306 2
a1307 1
  gdb_assert (regnum >= 0);
d1309 3
a1311 2
  if (!target_has_registers)
    error ("No registers.");
d1313 1
a1313 13
  *optimizedp = 0;
  *addrp = 0;
  *lvalp = not_lval;
  *realnump = -1;

  /* Rather than check each time if valuep is non-null, supply a dummy buffer
     when valuep is not supplied.  */
  if (!valuep)
    valuep = dummy_valp;
  
  memset (valuep, 0, REGISTER_RAW_SIZE (regnum));
 
  if (regnum == SP_REGNUM)
d1316 2
a1317 2
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum),
			      cache->base);
d1321 2
a1322 38
      char cfm_valuep[MAX_REGISTER_SIZE];
      int  cfm_optim;
      int  cfm_realnum;
      enum lval_type cfm_lval;
      CORE_ADDR cfm_addr;
      CORE_ADDR bsp, prev_cfm, prev_bsp;

      /* We want to calculate the previous bsp as the end of the previous register stack frame.
	 This corresponds to what the hardware bsp register will be if we pop the frame
	 back which is why we might have been called.  We know the beginning of the current
         frame is cache->bsp - cache->sof.  This value in the previous frame points to
	 the start of the output registers.  We can calculate the end of that frame by adding
	 the size of output (sof (size of frame) - sol (size of locals)).  */
      ia64_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
				&cfm_optim, &cfm_lval, &cfm_addr, &cfm_realnum, cfm_valuep);
      prev_cfm = extract_unsigned_integer (cfm_valuep, 8);

      bsp = rse_address_add (cache->bsp, -(cache->sof));
      prev_bsp = rse_address_add (bsp, (prev_cfm & 0x7f) - ((prev_cfm >> 7) & 0x7f));

      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum), 
			      prev_bsp);
    }
  else if (regnum == IA64_CFM_REGNUM)
    {
      CORE_ADDR addr = 0;

      if (cache->frameless)
	{
	  CORE_ADDR cfm = 0;
	  frame_unwind_register (next_frame, IA64_PFS_REGNUM, valuep);
	}
      else
	{
	  addr = cache->saved_regs[IA64_CFM_REGNUM];
	  if (addr != 0)
	    read_memory (addr, valuep, REGISTER_RAW_SIZE (regnum));
	}
d1329 4
a1332 3
	 still provide a value since we know the size of the frame.  */
      CORE_ADDR vfp = cache->base;
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (IA64_VFP_REGNUM), vfp);
d1334 1
a1334 1
  else if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
d1336 1
a1336 1
      char pr_valuep[MAX_REGISTER_SIZE];
a1337 1
      int  pr_realnum;
d1340 4
a1343 4
      ULONGEST prN_val;
      ia64_frame_prev_register (next_frame, this_cache, IA64_PR_REGNUM,
				&pr_optim, &pr_lval, &pr_addr, &pr_realnum, pr_valuep);
      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
d1346 2
a1347 2
	     marker for this frame.  */
	  int rrb_pr = (cache->cfm >> 32) & 0x3f;
d1349 7
a1355 7
	  /* Adjust the register number to account for register rotation.  */
	  regnum = VP16_REGNUM 
	         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = extract_bit_field ((unsigned char *) pr_valuep,
                                   regnum - VP0_REGNUM, 1);
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum), prN_val);
d1359 1
a1359 1
      char unat_valuep[MAX_REGISTER_SIZE];
a1360 1
      int  unat_realnum;
d1363 4
a1366 4
      ULONGEST unatN_val;
      ia64_frame_prev_register (next_frame, this_cache, IA64_UNAT_REGNUM,
				&unat_optim, &unat_lval, &unat_addr, &unat_realnum, unat_valuep);
      unatN_val = extract_bit_field ((unsigned char *) unat_valuep,
d1368 1
a1368 1
      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum), 
d1375 2
a1376 2
         interested in.  */
      CORE_ADDR gr_addr;
d1378 1
a1378 3
      gr_addr = cache->saved_regs[regnum - IA64_NAT0_REGNUM 
				  + IA64_GR0_REGNUM];
      if (gr_addr != 0)
d1380 7
a1386 1
	  /* Compute address of nat collection bits.  */
d1388 1
a1388 1
	  CORE_ADDR bsp;
d1393 1
a1393 3
	     collection from the computed address.  */
	  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
	  bsp = extract_unsigned_integer (buf, 8); 
d1395 1
a1395 4
	    {
	      frame_unwind_register (next_frame, IA64_RNAT_REGNUM, buf);
	      nat_collection = extract_unsigned_integer (buf, 8);
	    }
d1401 1
a1401 2

      store_unsigned_integer (valuep, REGISTER_RAW_SIZE (regnum), natval);
d1405 6
a1410 7
      CORE_ADDR pc = 0;

      if (cache->frameless)
	{
	  frame_unwind_register (next_frame, IA64_BR0_REGNUM, buf);
	  pc = extract_unsigned_integer (buf, 8);
	}
d1412 2
a1413 7
	{
	  CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];
	  if (addr != 0)
	    {
	      read_memory (addr, buf, REGISTER_RAW_SIZE (IA64_IP_REGNUM));
	      pc = extract_unsigned_integer (buf, 8);
	    }
d1415 1
a1415 2
      pc &= ~0xf;
      store_unsigned_integer (valuep, 8, pc);
d1417 1
a1417 1
  else if (regnum == IA64_PSR_REGNUM)
d1419 2
a1420 8
      ULONGEST slot_num = 0;
      CORE_ADDR pc= 0;
      CORE_ADDR psr = 0;

      frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
      psr = extract_unsigned_integer (buf, 8);

      if (cache->frameless)
d1422 2
a1423 3
	  CORE_ADDR pc;
	  frame_unwind_register (next_frame, IA64_BR0_REGNUM, buf);
	  pc = extract_unsigned_integer (buf, 8);
d1425 1
a1425 21
      else
	{
	  CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];
	  if (addr != 0)
	    {
	      read_memory (addr, buf, REGISTER_RAW_SIZE (IA64_IP_REGNUM));
	      pc = extract_unsigned_integer (buf, 8);
	    }
	}
      psr &= ~(3LL << 41);
      slot_num = pc & 0x3LL;
      psr |= (CORE_ADDR)slot_num << 41;
      store_unsigned_integer (valuep, 8, psr);
    }
 else if ((regnum >= IA64_GR32_REGNUM && regnum <= IA64_GR127_REGNUM) ||
	   (regnum >= V32_REGNUM && regnum <= V127_REGNUM))
    {
      CORE_ADDR addr = 0;
      if (regnum >= V32_REGNUM)
	regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);
      addr = cache->saved_regs[regnum];
d1428 5
a1432 3
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, REGISTER_RAW_SIZE (regnum));
d1434 1
a1434 1
      else if (cache->frameless)
d1436 3
a1438 21
	  char r_valuep[MAX_REGISTER_SIZE];
	  int  r_optim;
	  int  r_realnum;
	  enum lval_type r_lval;
	  CORE_ADDR r_addr;
	  CORE_ADDR prev_cfm, prev_bsp, prev_bof;
	  CORE_ADDR addr = 0;
	  if (regnum >= V32_REGNUM)
	    regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);
	  ia64_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
				    &r_optim, &r_lval, &r_addr, &r_realnum, r_valuep); 
	  prev_cfm = extract_unsigned_integer (r_valuep, 8);
	  ia64_frame_prev_register (next_frame, this_cache, IA64_BSP_REGNUM,
				    &r_optim, &r_lval, &r_addr, &r_realnum, r_valuep);
	  prev_bsp = extract_unsigned_integer (r_valuep, 8);
	  prev_bof = rse_address_add (prev_bsp, -(prev_cfm & 0x7f));

	  addr = rse_address_add (prev_bof, (regnum - IA64_GR32_REGNUM));
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, REGISTER_RAW_SIZE (regnum));
a1442 1
      CORE_ADDR addr = 0;
d1446 2
a1447 2
	     frame marker for this frame.  */
	  int rrb_fr = (cache->cfm >> 25) & 0x7f;
d1450 1
a1450 1
	     register rotation.  */
d1455 2
a1456 68
      /* If we have stored a memory address, access the register.  */
      addr = cache->saved_regs[regnum];
      if (addr != 0)
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, REGISTER_RAW_SIZE (regnum));
	}
      /* Otherwise, punt and get the current value of the register.  */
      else 
	frame_unwind_register (next_frame, regnum, valuep);
    }
}
 
static const struct frame_unwind ia64_frame_unwind =
{
  NORMAL_FRAME,
  &ia64_frame_this_id,
  &ia64_frame_prev_register
};

static const struct frame_unwind *
ia64_frame_sniffer (struct frame_info *next_frame)
{
  return &ia64_frame_unwind;
}

/* Signal trampolines.  */

static void
ia64_sigtramp_frame_init_saved_regs (struct ia64_frame_cache *cache)
{
  if (SIGCONTEXT_REGISTER_ADDRESS)
    {
      int regno;

      cache->saved_regs[IA64_VRAP_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_IP_REGNUM);
      cache->saved_regs[IA64_CFM_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_CFM_REGNUM);
      cache->saved_regs[IA64_PSR_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_PSR_REGNUM);
#if 0
      cache->saved_regs[IA64_BSP_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (frame->frame, IA64_BSP_REGNUM);
#endif
      cache->saved_regs[IA64_RNAT_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_RNAT_REGNUM);
      cache->saved_regs[IA64_CCV_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_CCV_REGNUM);
      cache->saved_regs[IA64_UNAT_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_UNAT_REGNUM);
      cache->saved_regs[IA64_FPSR_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_FPSR_REGNUM);
      cache->saved_regs[IA64_PFS_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_PFS_REGNUM);
      cache->saved_regs[IA64_LC_REGNUM] = 
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_LC_REGNUM);
      for (regno = IA64_GR1_REGNUM; regno <= IA64_GR31_REGNUM; regno++)
	if (regno != sp_regnum)
	  cache->saved_regs[regno] =
	    SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
      for (regno = IA64_BR0_REGNUM; regno <= IA64_BR7_REGNUM; regno++)
	cache->saved_regs[regno] =
	  SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
      for (regno = IA64_FR2_REGNUM; regno <= IA64_FR31_REGNUM; regno++)
	cache->saved_regs[regno] =
	  SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
a1459 84
static struct ia64_frame_cache *
ia64_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct ia64_frame_cache *cache;
  CORE_ADDR addr;
  char buf[8];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = ia64_alloc_frame_cache ();

  frame_unwind_register (next_frame, sp_regnum, buf);
  cache->base = extract_unsigned_integer (buf, 8) + cache->mem_stack_frame_size;

  ia64_sigtramp_frame_init_saved_regs (cache);

  *this_cache = cache;
  return cache;
}

static void
ia64_sigtramp_frame_this_id (struct frame_info *next_frame,
			       void **this_cache, struct frame_id *this_id)
{
  struct ia64_frame_cache *cache =
    ia64_sigtramp_frame_cache (next_frame, this_cache);

  (*this_id) = frame_id_build (cache->base, frame_pc_unwind (next_frame));
}

static void
ia64_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, void *valuep)
{
  /* Make sure we've initialized the cache.  */
  ia64_sigtramp_frame_cache (next_frame, this_cache);

  ia64_frame_prev_register (next_frame, this_cache, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind ia64_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  ia64_sigtramp_frame_this_id,
  ia64_sigtramp_frame_prev_register
};

static const struct frame_unwind *
ia64_sigtramp_frame_sniffer (struct frame_info *next_frame)
{
  char *name;
  CORE_ADDR pc = frame_pc_unwind (next_frame);

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    return &ia64_sigtramp_frame_unwind;

  return NULL;
}


static CORE_ADDR
ia64_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct ia64_frame_cache *cache =
    ia64_frame_cache (next_frame, this_cache);

  return cache->base;
}

static const struct frame_base ia64_frame_base =
{
  &ia64_frame_unwind,
  ia64_frame_base_address,
  ia64_frame_base_address,
  ia64_frame_base_address
};

d1471 1
a1471 1
     case.  */
d1478 1
a1478 1
     Don't use the struct convention for those either.  */
d1483 1
a1483 1
ia64_extract_return_value (struct type *type, struct regcache *regcache, void *valbuf)
a1489 1
      char from[MAX_REGISTER_SIZE];
d1496 2
a1497 3
	  regcache_cooked_read (regcache, regnum, from);
	  convert_typed_floating (from, builtin_type_ia64_ext,
				  (char *)valbuf + offset, float_elt_type);	  
d1503 15
a1517 7
    {
      ULONGEST val;
      int offset = 0;
      int regnum = IA64_GR8_REGNUM;
      int reglen = TYPE_LENGTH (ia64_register_type (NULL, IA64_GR8_REGNUM));
      int n = TYPE_LENGTH (type) / reglen;
      int m = TYPE_LENGTH (type) % reglen;
d1519 7
a1525 8
      while (n-- > 0)
	{
	  ULONGEST val;
	  regcache_cooked_read_unsigned (regcache, regnum, &val);
	  memcpy ((char *)valbuf + offset, &val, reglen);
	  offset += reglen;
	  regnum++;
	}
d1527 5
a1531 6
      if (m)
	{
          regcache_cooked_read_unsigned (regcache, regnum, &val);
	  memcpy ((char *)valbuf + offset, &val, m);
	}
    }
d1535 15
a1549 1
ia64_extract_struct_value_address (struct regcache *regcache)
d1551 3
a1553 2
  error ("ia64_extract_struct_value_address called and cannot get struct value address");
  return 0;
d1556 69
d1664 1
a1664 1
   bottom-most elements are all of the same floating point type).  */
d1678 1
a1678 1
   and Runtime manual).  */
d1776 1
a1776 1
   not found.  */
d1782 1
a1782 1
  /* Return early if faddr is already a function descriptor.  */
d1824 1
a1824 1
   stack using the address at fdaptr.  */
a1854 23
/* Use the following routine when printing out function pointers
   so the user can see the function address rather than just the
   function descriptor.  */
static CORE_ADDR
ia64_convert_from_func_ptr_addr (CORE_ADDR addr)
{
  struct obj_section *s;

  s = find_pc_section (addr);

  /* check if ADDR points to a function descriptor.  */
  if (s && strcmp (s->the_bfd_section->name, ".opd") == 0)
    return read_memory_unsigned_integer (addr, 8);

  return addr;
}

static CORE_ADDR
ia64_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  return sp & ~0xfLL;
}

d1856 1
a1856 1
ia64_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr, 
d1867 3
a1869 1
  CORE_ADDR bsp, cfm, pfs, new_bsp, funcdescaddr, pc, global_pointer;
d1873 1
a1873 1
  /* Count the number of slots needed for the arguments.  */
d1889 1
a1889 1
  /* Divvy up the slots between the RSE and the memory stack.  */
d1893 2
a1894 2
  /* Allocate a new RSE frame.  */
  cfm = read_register (IA64_CFM_REGNUM);
d1896 2
a1897 1
  bsp = read_register (IA64_BSP_REGNUM);
d1899 1
a1899 1
  write_register (IA64_BSP_REGNUM, new_bsp);
d1901 1
a1901 1
  pfs = read_register (IA64_PFS_REGNUM);
d1904 1
a1904 1
  write_register (IA64_PFS_REGNUM, pfs);
d1908 1
a1908 1
  write_register (IA64_CFM_REGNUM, cfm);
d1912 1
a1912 1
     case, we'll need to reserve space on the stack for them.  */
d1918 1
a1918 1
     necessary for the memory slots and our function descriptors.  */
d1920 1
a1920 1
  sp &= ~0xfLL;				/* Maintain 16 byte alignment.  */
d1925 1
a1925 1
     floating point registers.  */
d1936 1
a1936 1
      /* Special handling for function parameters.  */
d1954 1
a1954 1
      /* Normal slots.  */
d1978 1
a1978 1
      /* Handle floating point types (including HFAs).  */
d1986 6
a1991 4
	      char to[MAX_REGISTER_SIZE];
	      convert_typed_floating (VALUE_CONTENTS (arg) + argoffset, float_elt_type,
				      to, builtin_type_ia64_ext);
	      regcache_cooked_write (regcache, floatreg, (void *)to);
d1999 1
a1999 1
  /* Store the struct return value in r8 if necessary.  */
d2002 1
a2002 1
      regcache_cooked_write_unsigned (regcache, IA64_GR8_REGNUM, (ULONGEST)struct_addr);
d2005 7
a2011 1
  global_pointer = FIND_GLOBAL_POINTER (func_addr);
d2013 7
a2019 2
  if (global_pointer != 0)
    write_register (IA64_GR1_REGNUM, global_pointer);
d2021 1
a2021 1
  write_register (IA64_BR0_REGNUM, bp_addr);
d2023 2
a2024 1
  write_register (sp_regnum, sp);
d2029 2
a2030 2
static struct frame_id
ia64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d2032 9
a2040 7
  char buf[8];
  CORE_ADDR sp;

  frame_unwind_register (next_frame, sp_regnum, buf);
  sp = extract_unsigned_integer (buf, 8);

  return frame_id_build (sp, frame_pc_unwind (next_frame));
d2043 2
a2044 2
static CORE_ADDR 
ia64_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
d2046 1
a2046 10
  char buf[8];
  CORE_ADDR ip, psr, pc;

  frame_unwind_register (next_frame, IA64_IP_REGNUM, buf);
  ip = extract_unsigned_integer (buf, 8);
  frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
  psr = extract_unsigned_integer (buf, 8);
 
  pc = (ip & ~0xf) | ((psr >> 41) & 3);
  return pc;
d2050 1
a2050 1
ia64_store_return_value (struct type *type, struct regcache *regcache, const void *valbuf)
d2052 28
a2079 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d2081 2
a2082 4
      char to[MAX_REGISTER_SIZE];
      convert_typed_floating (valbuf, type, to, builtin_type_ia64_ext);
      regcache_cooked_write (regcache, IA64_FR8_REGNUM, (void *)to);
      target_store_registers (IA64_FR8_REGNUM);
d2085 19
a2103 1
    regcache_cooked_write (regcache, IA64_GR8_REGNUM, valbuf);
d2142 1
a2142 1
	  /* The case numbers are from abi-tags in glibc.  */
d2186 1
a2186 1
         sections too.  */
d2210 4
a2239 6
  /* Define the ia64 floating-point format to gdb.  */
  builtin_type_ia64_ext =
    init_type (TYPE_CODE_FLT, 128 / 8,
               0, "builtin_type_ia64_ext", NULL);
  TYPE_FLOATFORMAT (builtin_type_ia64_ext) = &floatformat_ia64_ext;

d2249 1
a2249 2
  set_gdbarch_num_regs (gdbarch, NUM_IA64_RAW_REGS);
  set_gdbarch_num_pseudo_regs (gdbarch, LAST_PSEUDO_REGNUM - FIRST_PSEUDO_REGNUM);
d2251 2
a2255 2
  /* FIXME:  Following interface should not be needed, however, without it recurse.exp
     gets a number of extra failures.  */
d2257 11
a2267 1
  set_gdbarch_register_type (gdbarch, ia64_register_type);
d2269 1
a2269 7
  set_gdbarch_pseudo_register_read (gdbarch, ia64_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, ia64_pseudo_register_write);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, ia64_dwarf_reg_to_regnum);
  set_gdbarch_register_reggroup_p (gdbarch, ia64_register_reggroup_p);
  set_gdbarch_convert_register_p (gdbarch, ia64_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, ia64_register_to_value);
  set_gdbarch_value_to_register (gdbarch, ia64_value_to_register);
d2271 9
a2279 1
  set_gdbarch_skip_prologue (gdbarch, ia64_skip_prologue);
d2282 1
a2282 1
  set_gdbarch_extract_return_value (gdbarch, ia64_extract_return_value);
d2284 3
a2286 2
  set_gdbarch_store_return_value (gdbarch, ia64_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch, ia64_extract_struct_value_address);
d2296 1
a2296 2
  set_gdbarch_frame_align (gdbarch, ia64_frame_align);
  set_gdbarch_unwind_dummy_id (gdbarch, ia64_unwind_dummy_id);
d2298 12
a2309 4
  set_gdbarch_unwind_pc (gdbarch, ia64_unwind_pc);
  frame_unwind_append_sniffer (gdbarch, ia64_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, ia64_frame_sniffer);
  frame_base_set_default (gdbarch, &ia64_frame_base);
d2314 2
a2323 1
  set_gdbarch_convert_from_func_ptr_addr (gdbarch, ia64_convert_from_func_ptr_addr);
@


1.34.2.11
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d111 1
a111 1
   they may not be accessible via the ptrace register get/set interfaces.  */
a234 1
  CORE_ADDR prev_cfm;   /* cfm value for previous frame */
d258 3
a318 6
static int
floatformat_valid (const struct floatformat *fmt, const char *from)
{
  return 1;
}

d322 1
a322 1
  floatformat_intbit_yes, "floatformat_ia64_ext", floatformat_valid
d346 1
a346 1
    return read_memory_integer (regaddr, register_size (current_gdbarch, regnum));
d719 1
a719 1
	  store_unsigned_integer (buf, register_size (current_gdbarch, regnum), reg);
d722 1
a722 1
	store_unsigned_integer (buf, register_size (current_gdbarch, regnum), 0);
d730 1
a730 1
      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), unatN_val);
d765 1
a765 1
      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), natN_val);
d780 1
a780 1
      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), vbsp);
d802 1
a802 1
      store_unsigned_integer (buf, register_size (current_gdbarch, regnum), prN_val);
d805 1
a805 1
    memset (buf, 0, register_size (current_gdbarch, regnum));
d832 1
a832 1
      unatN_val = extract_unsigned_integer (buf, register_size (current_gdbarch, regnum)); 
d856 1
a856 1
      natN_val = extract_unsigned_integer (buf, register_size (current_gdbarch, regnum)); 
d885 1
a885 1
	      store_unsigned_integer (nat_buf, register_size (current_gdbarch, regnum), nat_collection);
d910 1
a910 1
      prN_val = extract_unsigned_integer (buf, register_size (current_gdbarch, regnum)); 
a1032 1
  cache->prev_cfm = 0;
a1452 1
      cfm = 0;
a1455 10
	}
      else if (cfm_reg != 0)
	{
	  frame_unwind_register (next_frame, cfm_reg, buf);
	  cfm = extract_unsigned_integer (buf, 8);
	}
      cache->prev_cfm = cfm;
      
      if (cfm != 0)
	{
d1567 1
a1567 5
  (*this_id) = frame_id_build_special (cache->base, cache->pc, cache->bsp);
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"regular frame id: code %lx, stack %lx, special %lx, next_frame %p\n",
			this_id->code_addr, this_id->stack_addr, cache->bsp, next_frame);
d1596 1
a1596 1
  memset (valuep, 0, register_size (current_gdbarch, regnum));
d1601 1
a1601 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum),
d1616 1
a1616 1
	 frame is cache->bsp - cache->sof.  This value in the previous frame points to
d1626 1
a1626 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
d1631 3
a1633 3
      CORE_ADDR addr = cache->saved_regs[IA64_CFM_REGNUM];
      
      if (addr != 0)
d1635 2
a1636 3
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
d1638 1
a1638 3
      else if (cache->prev_cfm)
	store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), cache->prev_cfm);
      else if (cache->frameless)
d1640 3
a1642 2
	  CORE_ADDR cfm = 0;
	  frame_unwind_register (next_frame, IA64_PFS_REGNUM, valuep);
d1652 1
a1652 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, IA64_VFP_REGNUM), vfp);
d1676 1
a1676 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), prN_val);
d1690 1
a1690 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
d1725 1
a1725 1
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), natval);
a1729 1
      CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];
d1731 1
a1731 1
      if (addr != 0)
d1733 1
a1733 3
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, buf, register_size (current_gdbarch, IA64_IP_REGNUM));
d1736 1
a1736 1
      else if (cache->frameless)
d1738 6
a1743 2
	  frame_unwind_register (next_frame, IA64_BR0_REGNUM, buf);
	  pc = extract_unsigned_integer (buf, 8);
a1749 4
      /* We don't know how to get the complete previous PSR, but we need it for
	 the slot information when we unwind the pc (pc is formed of IP register
	 plus slot information from PSR).  To get the previous slot information, 
	 we mask it off the return address.  */
a1752 1
      CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];
d1757 1
a1757 1
      if (addr != 0)
d1759 2
a1760 3
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, buf, register_size (current_gdbarch, IA64_IP_REGNUM));
d1763 1
a1763 1
      else if (cache->frameless)
d1765 6
a1770 3
	  CORE_ADDR pc;
	  frame_unwind_register (next_frame, IA64_BR0_REGNUM, buf);
	  pc = extract_unsigned_integer (buf, 8);
a1776 13
  else if (regnum == IA64_BR0_REGNUM)
    {
      CORE_ADDR br0 = 0;
      CORE_ADDR addr = cache->saved_regs[IA64_BR0_REGNUM];
      if (addr != 0)
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, buf, register_size (current_gdbarch, IA64_BR0_REGNUM));
	  br0 = extract_unsigned_integer (buf, 8);
	}
      store_unsigned_integer (valuep, 8, br0);
    }
d1788 1
a1788 1
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
d1812 1
a1812 1
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
d1836 1
a1836 1
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
a1841 6

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"regular prev register <%d> <%s> is %lx\n", regnum, 
			(((unsigned) regnum <= IA64_NAT127_REGNUM)
			 ? ia64_register_names[regnum] : "r??"), extract_unsigned_integer (valuep, 8));
d1872 1
d1874 2
a1875 1
	SIGCONTEXT_REGISTER_ADDRESS (cache->base, IA64_BSP_REGNUM);
d1889 3
a1891 2
	cache->saved_regs[regno] =
	  SIGCONTEXT_REGISTER_ADDRESS (cache->base, regno);
d1915 1
a1915 10
  /* Note that frame size is hard-coded below.  We cannot calculate it
     via prologue examination.  */
  cache->base = extract_unsigned_integer (buf, 8) + 16;

  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
  cache->bsp = extract_unsigned_integer (buf, 8);

  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
  cache->cfm = extract_unsigned_integer (buf, 8);
  cache->sof = cache->cfm & 0x7f;
d1930 1
a1930 5
  (*this_id) = frame_id_build_special (cache->base, frame_pc_unwind (next_frame), cache->bsp);
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"sigtramp frame id: code %lx, stack %lx, special %lx, next_frame %p\n",
			this_id->code_addr, this_id->stack_addr, cache->bsp, next_frame);
d1940 2
a1941 63
  char dummy_valp[MAX_REGISTER_SIZE];
  char buf[MAX_REGISTER_SIZE];

  struct ia64_frame_cache *cache =
    ia64_sigtramp_frame_cache (next_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (!target_has_registers)
    error ("No registers.");

  *optimizedp = 0;
  *addrp = 0;
  *lvalp = not_lval;
  *realnump = -1;

  /* Rather than check each time if valuep is non-null, supply a dummy buffer
     when valuep is not supplied.  */
  if (!valuep)
    valuep = dummy_valp;
  
  memset (valuep, 0, register_size (current_gdbarch, regnum));
 
  if (regnum == IA64_IP_REGNUM)
    {
      CORE_ADDR pc = 0;
      CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];

      if (addr != 0)
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, buf, register_size (current_gdbarch, IA64_IP_REGNUM));
	  pc = extract_unsigned_integer (buf, 8);
	}
      pc &= ~0xf;
      store_unsigned_integer (valuep, 8, pc);
    }
 else if ((regnum >= IA64_GR32_REGNUM && regnum <= IA64_GR127_REGNUM) ||
	   (regnum >= V32_REGNUM && regnum <= V127_REGNUM))
    {
      CORE_ADDR addr = 0;
      if (regnum >= V32_REGNUM)
	regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);
      addr = cache->saved_regs[regnum];
      if (addr != 0)
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
	}
    }
  else
    {
      /* All other registers not listed above.  */
      CORE_ADDR addr = cache->saved_regs[regnum];
      if (addr != 0)
	{
	  *lvalp = lval_memory;
	  *addrp = addr;
	  read_memory (addr, valuep, register_size (current_gdbarch, regnum));
	}
    }
d1943 2
a1944 5
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"sigtramp prev register <%s> is %lx\n",
			(((unsigned) regnum <= IA64_NAT127_REGNUM)
			 ? ia64_register_names[regnum] : "r??"), extract_unsigned_integer (valuep, 8));
d2296 1
a2296 2
ia64_convert_from_func_ptr_addr (struct gdbarch *gdbarch, CORE_ADDR addr,
				 struct target_ops *targ)
d2476 1
a2476 1
  CORE_ADDR sp, bsp;
d2481 1
a2481 9
  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
  bsp = extract_unsigned_integer (buf, 8);

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"dummy frame id: code %lx, stack %lx, special %lx\n",
			frame_pc_unwind (next_frame), sp, bsp);

  return frame_id_build_special (sp, frame_pc_unwind (next_frame), bsp);
d2582 1
d2584 28
a2611 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d2615 1
d2622 1
a2622 1
  if (info.osabi == GDB_OSABI_LINUX)
d2636 1
a2636 1
  if (info.osabi == GDB_OSABI_LINUX)
@


1.34.2.12
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a38 1
#include "elf.h"                /* for PT_IA64_UNWIND value */
a40 5
#ifdef HAVE_LIBUNWIND_IA64_H
#include "libunwind-frame.h"
#include "libunwind-ia64.h"
#endif

a89 1
extern unsigned long ia64_linux_getunwind_table (void *, size_t);
a2101 603
#ifdef HAVE_LIBUNWIND_IA64_H

struct ia64_unwind_table_entry
  {
    unw_word_t start_offset;
    unw_word_t end_offset;
    unw_word_t info_offset;
  };

static __inline__ uint64_t
ia64_rse_slot_num (uint64_t addr)
{
  return (addr >> 3) & 0x3f;
}

/* Skip over a designated number of registers in the backing
   store, remembering every 64th position is for NAT.  */
static __inline__ uint64_t
ia64_rse_skip_regs (uint64_t addr, long num_regs)
{
  long delta = ia64_rse_slot_num(addr) + num_regs;

  if (num_regs < 0)
    delta -= 0x3e;
  return addr + ((num_regs + delta/0x3f) << 3);
}
  
/* Gdb libunwind-frame callback function to convert from an ia64 gdb register 
   number to a libunwind register number.  */
static int
ia64_gdb2uw_regnum (int regnum)
{
  if (regnum == sp_regnum)
    return UNW_IA64_SP;
  else if (regnum == IA64_BSP_REGNUM)
    return UNW_IA64_BSP;
  else if ((unsigned) (regnum - IA64_GR0_REGNUM) < 128)
    return UNW_IA64_GR + (regnum - IA64_GR0_REGNUM);
  else if ((unsigned) (regnum - V32_REGNUM) < 95)
    return UNW_IA64_GR + 32 + (regnum - V32_REGNUM);
  else if ((unsigned) (regnum - IA64_FR0_REGNUM) < 128)
    return UNW_IA64_FR + (regnum - IA64_FR0_REGNUM);
  else if ((unsigned) (regnum - IA64_PR0_REGNUM) < 64)
    return -1;
  else if ((unsigned) (regnum - IA64_BR0_REGNUM) < 8)
    return UNW_IA64_BR + (regnum - IA64_BR0_REGNUM);
  else if (regnum == IA64_PR_REGNUM)
    return UNW_IA64_PR;
  else if (regnum == IA64_IP_REGNUM)
    return UNW_REG_IP;
  else if (regnum == IA64_CFM_REGNUM)
    return UNW_IA64_CFM;
  else if ((unsigned) (regnum - IA64_AR0_REGNUM) < 128)
    return UNW_IA64_AR + (regnum - IA64_AR0_REGNUM);
  else if ((unsigned) (regnum - IA64_NAT0_REGNUM) < 128)
    return UNW_IA64_NAT + (regnum - IA64_NAT0_REGNUM);
  else
    return -1;
}
  
/* Gdb libunwind-frame callback function to convert from a libunwind register 
   number to a ia64 gdb register number.  */
static int
ia64_uw2gdb_regnum (int uw_regnum)
{
  if (uw_regnum == UNW_IA64_SP)
    return sp_regnum;
  else if (uw_regnum == UNW_IA64_BSP)
    return IA64_BSP_REGNUM;
  else if ((unsigned) (uw_regnum - UNW_IA64_GR) < 32)
    return IA64_GR0_REGNUM + (uw_regnum - UNW_IA64_GR);
  else if ((unsigned) (uw_regnum - UNW_IA64_GR) < 128)
    return V32_REGNUM + (uw_regnum - (IA64_GR0_REGNUM + 32));
  else if ((unsigned) (uw_regnum - UNW_IA64_FR) < 128)
    return IA64_FR0_REGNUM + (uw_regnum - UNW_IA64_FR);
  else if ((unsigned) (uw_regnum - UNW_IA64_BR) < 8)
    return IA64_BR0_REGNUM + (uw_regnum - UNW_IA64_BR);
  else if (uw_regnum == UNW_IA64_PR)
    return IA64_PR_REGNUM;
  else if (uw_regnum == UNW_REG_IP)
    return IA64_IP_REGNUM;
  else if (uw_regnum == UNW_IA64_CFM)
    return IA64_CFM_REGNUM;
  else if ((unsigned) (uw_regnum - UNW_IA64_AR) < 128)
    return IA64_AR0_REGNUM + (uw_regnum - UNW_IA64_AR);
  else if ((unsigned) (uw_regnum - UNW_IA64_NAT) < 128)
    return IA64_NAT0_REGNUM + (uw_regnum - UNW_IA64_NAT);
  else
    return -1;
}

/* Gdb libunwind-frame callback function to reveal if register is a float 
   register or not.  */
static int
ia64_is_fpreg (int uw_regnum)
{
  return unw_is_fpreg (uw_regnum);
}
  
/* Libunwind callback accessor function for general registers.  */
static int
ia64_access_reg (unw_addr_space_t as, unw_regnum_t uw_regnum, unw_word_t *val, 
		 int write, void *arg)
{
  int regnum = ia64_uw2gdb_regnum (uw_regnum);
  unw_word_t bsp, sof, sol, cfm, psr, ip;
  struct frame_info *next_frame = arg;
  long new_sof, old_sof;
  char buf[MAX_REGISTER_SIZE];
  
  if (write)
    {
      if (regnum < 0)
	/* ignore writes to pseudo-registers such as UNW_IA64_PROC_STARTI.  */
	return 0;
  
      switch (uw_regnum)
	{
	case UNW_REG_IP:
	  ia64_write_pc (*val, inferior_ptid);
	  break;

	case UNW_IA64_AR_BSPSTORE:
	  write_register (IA64_BSP_REGNUM, *val);
	  break;
	  
	case UNW_IA64_AR_BSP:
	case UNW_IA64_BSP:
	  /* Account for the fact that ptrace() expects bsp to point
	     after the current register frame.  */
	  cfm = read_register (IA64_CFM_REGNUM);
	  sof = (cfm & 0x7f);
	  bsp = ia64_rse_skip_regs (*val, sof);
	  write_register (IA64_BSP_REGNUM, bsp);
	  break;
	  
	case UNW_IA64_CFM:
	  /* If we change CFM, we need to adjust ptrace's notion of
	     bsp accordingly, so that the real bsp remains
	     unchanged.  */
	  bsp = read_register (IA64_BSP_REGNUM);
	  cfm = read_register (IA64_CFM_REGNUM);
	  old_sof = (cfm & 0x7f);
	  new_sof = (*val & 0x7f);
	  if (old_sof != new_sof)
	    {
	      bsp = ia64_rse_skip_regs (bsp, -old_sof + new_sof);
	      write_register (IA64_BSP_REGNUM, bsp);
	    }
	  write_register (IA64_CFM_REGNUM, *val);
	  break;
	  
	default:
	  write_register (regnum, *val);
	  break;
	}
      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, 
			    "  access_reg: to cache: %4s=%016lx\n",
			    (((unsigned) regnum <= IA64_NAT127_REGNUM)
			     ? ia64_register_names[regnum] : "r??"), *val);
    }
  else
    {
      switch (uw_regnum)
	{
	case UNW_REG_IP:
	  /* Libunwind expects to see the pc value which means the slot number
	     from the psr must be merged with the ip word address.  */
	  frame_unwind_register (next_frame, IA64_IP_REGNUM, buf);
	  ip = extract_unsigned_integer (buf, 8); 
	  frame_unwind_register (next_frame, IA64_PSR_REGNUM, buf);
	  psr = extract_unsigned_integer (buf, 8); 
	  *val = ip | ((psr >> 41) & 0x3);
	  break;
	  
	case UNW_IA64_AR_BSP:
	  /* Libunwind expects to see the beginning of the current register
	     frame so we must account for the fact that ptrace() will return a value
	     for bsp that points *after* the current register frame.  */
	  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
	  bsp = extract_unsigned_integer (buf, 8);
	  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
	  cfm = extract_unsigned_integer (buf, 8); 
	  sof = (cfm & 0x7f);
	  *val = ia64_rse_skip_regs (bsp, -sof);
	  break;
	  
	case UNW_IA64_AR_BSPSTORE:
	  /* Libunwind wants bspstore to be after the current register frame.
	     This is what ptrace() and gdb treats as the regular bsp value.  */
	  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
	  *val = extract_unsigned_integer (buf, 8);
	  break;

	default:
	  /* For all other registers, just unwind the value directly.  */
	  frame_unwind_register (next_frame, regnum, buf);
	  *val = extract_unsigned_integer (buf, 8); 
	  break;
	}
      
      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, 
			    "  access_reg: from cache: %4s=%016lx\n",
			    (((unsigned) regnum <= IA64_NAT127_REGNUM)
			     ? ia64_register_names[regnum] : "r??"), *val);
    }
  return 0;
}

/* Libunwind callback accessor function for floating-point registers.  */
static int
ia64_access_fpreg (unw_addr_space_t as, unw_regnum_t uw_regnum, unw_fpreg_t *val, 
		   int write, void *arg)
{
  int regnum = ia64_uw2gdb_regnum (uw_regnum);
  
  if (write)
    regcache_cooked_write (current_regcache, regnum, (char *) val);
  else
    regcache_cooked_read (current_regcache, regnum, (char *) val);
  return 0;
}

/* Libunwind callback accessor function for accessing memory.  */
static int
ia64_access_mem (unw_addr_space_t as,
		 unw_word_t addr, unw_word_t *val,
		 int write, void *arg)
{
  /* XXX do we need to normalize byte-order here?  */
  if (write)
    return target_write_memory (addr, (char *) val, sizeof (unw_word_t));
  else
    return target_read_memory (addr, (char *) val, sizeof (unw_word_t));
}

/* Call low-level function to access the kernel unwind table.  */
static int
getunwind_table (void *buf, size_t len)
{
  LONGEST x;
  x = target_read_partial (&current_target, TARGET_OBJECT_UNWIND_TABLE, NULL,
			   buf, 0, len);

  return (int)x;
}
	
/* Get the kernel unwind table.  */				 
static int
get_kernel_table (unw_word_t ip, unw_dyn_info_t *di)
{
  size_t size;
  struct ia64_table_entry
  {
    uint64_t start_offset;
    uint64_t end_offset;
    uint64_t info_offset;
  };
  static struct ia64_table_entry *ktab = NULL, *etab;

  if (!ktab)
    {
      size = getunwind_table (NULL, 0);
      if ((int)size < 0)
	return -UNW_ENOINFO;
      ktab = xmalloc (size);
      getunwind_table (ktab, size);
  
      /* Determine length of kernel's unwind table and relocate
	 it's entries.  */
      for (etab = ktab; etab->start_offset; ++etab)
	etab->info_offset += (uint64_t) ktab;
    }
  
  if (ip < ktab[0].start_offset || ip >= etab[-1].end_offset)
    return -UNW_ENOINFO;
  
  di->format = UNW_INFO_FORMAT_TABLE;
  di->gp = 0;
  di->start_ip = ktab[0].start_offset;
  di->end_ip = etab[-1].end_offset;
  di->u.ti.name_ptr = (unw_word_t) "<kernel>";
  di->u.ti.segbase = 0;
  di->u.ti.table_len = ((char *) etab - (char *) ktab) / sizeof (unw_word_t);
  di->u.ti.table_data = (unw_word_t *) ktab;
  
  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog, "get_kernel_table: found table `%s': "
			"segbase=%lx, length=%lu, gp=%lx\n",
			(char *) di->u.ti.name_ptr, di->u.ti.segbase, 
			di->u.ti.table_len, di->gp);
  return 0;
}

/* Find the unwind table entry for a specified address.  */
static int
ia64_find_unwind_table (struct objfile *objfile, unw_word_t ip,
			unw_dyn_info_t *dip, void **buf)
{
  Elf_Internal_Phdr *phdr, *p_text = NULL, *p_unwind = NULL;
  Elf_Internal_Ehdr *ehdr;
  unw_word_t segbase = 0;
  CORE_ADDR load_base;
  bfd *bfd;
  int i;

  bfd = objfile->obfd;
  
  ehdr = elf_tdata (bfd)->elf_header;
  phdr = elf_tdata (bfd)->phdr;

  load_base = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  for (i = 0; i < ehdr->e_phnum; ++i)
    {
      switch (phdr[i].p_type)
	{
	case PT_LOAD:
	  if ((unw_word_t) (ip - load_base - phdr[i].p_vaddr)
	      < phdr[i].p_memsz)
	    p_text = phdr + i;
	  break;

	case PT_IA_64_UNWIND:
	  p_unwind = phdr + i;
	  break;

	default:
	  break;
	}
    }

  if (!p_text || !p_unwind
      /* Verify that the segment that contains the IP also contains
	 the static unwind table.  If not, we are dealing with
	 runtime-generated code, for which we have no info here.  */
      || (p_unwind->p_vaddr - p_text->p_vaddr) >= p_text->p_memsz)
    return -UNW_ENOINFO;

  segbase = p_text->p_vaddr + load_base;

  dip->start_ip = segbase;
  dip->end_ip = dip->start_ip + p_text->p_memsz;
  dip->gp = FIND_GLOBAL_POINTER (ip);
  dip->format = UNW_INFO_FORMAT_REMOTE_TABLE;
  dip->u.rti.name_ptr = (unw_word_t) bfd_get_filename (bfd);
  dip->u.rti.segbase = segbase;
  dip->u.rti.table_len = p_unwind->p_memsz / sizeof (unw_word_t);
  dip->u.rti.table_data = p_unwind->p_vaddr + load_base;

  return 0;
}

/* Libunwind callback accessor function to acquire procedure unwind-info.  */
static int
ia64_find_proc_info_x (unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,
		       int need_unwind_info, void *arg)
{
  struct obj_section *sec = find_pc_section (ip);
  unw_dyn_info_t di;
  int ret;
  void *buf = NULL;

  if (!sec)
    {
      /* XXX This only works if the host and the target architecture are
	 both ia64 and if the have (more or less) the same kernel
	 version.  */
      if (get_kernel_table (ip, &di) < 0)
	return -UNW_ENOINFO;

      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, "%s: %lx -> "
			    "(name=`%s',segbase=%lx,start=%lx,end=%lx,gp=%lx,"
			    "length=%lu,data=%p)\n", __FUNCTION__,
			    ip, (char *)di.u.ti.name_ptr,
			    di.u.ti.segbase, di.start_ip, di.end_ip,
			    di.gp, di.u.ti.table_len, di.u.ti.table_data);
    }
  else
    {
      ret = ia64_find_unwind_table (sec->objfile, ip, &di, &buf);
      if (ret < 0)
	return ret;

      if (gdbarch_debug >= 1)
	fprintf_unfiltered (gdb_stdlog, "%s: %lx -> "
			    "(name=`%s',segbase=%lx,start=%lx,end=%lx,gp=%lx,"
			    "length=%lu,data=%lx)\n", __FUNCTION__,
			    ip, (char *)di.u.rti.name_ptr,
			    di.u.rti.segbase, di.start_ip, di.end_ip,
			    di.gp, di.u.rti.table_len, di.u.rti.table_data);
    }

  ret = libunwind_search_unwind_table (&as, ip, &di, pi, need_unwind_info,
				       arg);

  /* We no longer need the dyn info storage so free it.  */
  xfree (buf);

  return ret;
}

/* Libunwind callback accessor function for cleanup.  */
static void
ia64_put_unwind_info (unw_addr_space_t as,
		      unw_proc_info_t *pip, void *arg)
{
  /* Nothing required for now.  */
}

/* Libunwind callback accessor function to get head of the dynamic 
   unwind-info registration list.  */ 
static int
ia64_get_dyn_info_list (unw_addr_space_t as,
			unw_word_t *dilap, void *arg)
{
  struct obj_section *text_sec;
  struct objfile *objfile;
  unw_word_t ip, addr;
  unw_dyn_info_t di;
  int ret;

  if (!libunwind_is_initialized ())
    return -UNW_ENOINFO;

  for (objfile = object_files; objfile; objfile = objfile->next)
    {
      void *buf = NULL;

      text_sec = objfile->sections + SECT_OFF_TEXT (objfile);
      ip = text_sec->addr;
      ret = ia64_find_unwind_table (objfile, ip, &di, &buf);
      if (ret >= 0)
	{
	  addr = libunwind_find_dyn_list (as, &di, arg);
	  /* We no longer need the dyn info storage so free it.  */
	  xfree (buf);

	  if (addr)
	    {
	      if (gdbarch_debug >= 1)
		fprintf_unfiltered (gdb_stdlog,
				    "dynamic unwind table in objfile %s "
				    "at %lx (gp=%lx)\n",
				    bfd_get_filename (objfile->obfd),
				    addr, di.gp);
	      *dilap = addr;
	      return 0;
	    }
	}
    }
  return -UNW_ENOINFO;
}


/* Frame interface functions for libunwind.  */

static void
ia64_libunwind_frame_this_id (struct frame_info *next_frame, void **this_cache,
		      struct frame_id *this_id)
{
  char buf[8];
  CORE_ADDR bsp;
  struct frame_id id;

  libunwind_frame_this_id (next_frame, this_cache, &id);

  /* We must add the bsp as the special address for frame comparison purposes.  */
  frame_unwind_register (next_frame, IA64_BSP_REGNUM, buf);
  bsp = extract_unsigned_integer (buf, 8);

  (*this_id) = frame_id_build_special (id.stack_addr, id.code_addr, bsp);

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"libunwind frame id: code %lx, stack %lx, special %lx, next_frame %p\n",
			id.code_addr, id.stack_addr, bsp, next_frame);
}

static void
ia64_libunwind_frame_prev_register (struct frame_info *next_frame,
				    void **this_cache,
				    int regnum, int *optimizedp,
				    enum lval_type *lvalp, CORE_ADDR *addrp,
				    int *realnump, void *valuep)
{
  int reg = regnum;

  if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    reg = IA64_PR_REGNUM;
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    reg = IA64_UNAT_REGNUM;

  /* Let libunwind do most of the work.  */
  libunwind_frame_prev_register (next_frame, this_cache, reg,
				 optimizedp, lvalp, addrp, realnump, valuep);

  if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    {
      ULONGEST prN_val;

      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  int rrb_pr = 0;
	  ULONGEST cfm;
	  unsigned char buf[MAX_REGISTER_SIZE];

	  /* Fetch predicate register rename base from current frame
	     marker for this frame.  */
	  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
	  cfm = extract_unsigned_integer (buf, 8); 
	  rrb_pr = (cfm >> 32) & 0x3f;
	  
	  /* Adjust the register number to account for register rotation.  */
	  regnum = VP16_REGNUM 
	    + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = extract_bit_field ((unsigned char *) valuep,
				   regnum - VP0_REGNUM, 1);
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), prN_val);
    }
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      ULONGEST unatN_val;

      unatN_val = extract_bit_field ((unsigned char *) valuep,
                                   regnum - IA64_NAT0_REGNUM, 1);
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
                              unatN_val);
    }
  else if (regnum == IA64_BSP_REGNUM)
    {
      char cfm_valuep[MAX_REGISTER_SIZE];
      int  cfm_optim;
      int  cfm_realnum;
      enum lval_type cfm_lval;
      CORE_ADDR cfm_addr;
      CORE_ADDR bsp, prev_cfm, prev_bsp;

      /* We want to calculate the previous bsp as the end of the previous register stack frame.
	 This corresponds to what the hardware bsp register will be if we pop the frame
	 back which is why we might have been called.  We know that libunwind will pass us back
	 the beginning of the current frame so we should just add sof to it. */
      prev_bsp = extract_unsigned_integer (valuep, 8);
      libunwind_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
				     &cfm_optim, &cfm_lval, &cfm_addr, &cfm_realnum, cfm_valuep);
      prev_cfm = extract_unsigned_integer (cfm_valuep, 8);
      prev_bsp = rse_address_add (prev_bsp, (prev_cfm & 0x7f));

      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
			      prev_bsp);
    }

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"libunwind prev register <%s> is %lx\n",
			(((unsigned) regnum <= IA64_NAT127_REGNUM)
			 ? ia64_register_names[regnum] : "r??"), extract_unsigned_integer (valuep, 8));
}

static const struct frame_unwind ia64_libunwind_frame_unwind =
{
  NORMAL_FRAME,
  ia64_libunwind_frame_this_id,
  ia64_libunwind_frame_prev_register
};

static const struct frame_unwind *
ia64_libunwind_frame_sniffer (struct frame_info *next_frame)
{
  if (libunwind_is_initialized () && libunwind_frame_sniffer (next_frame))
    return &ia64_libunwind_frame_unwind;

  return NULL;
}

/* Set of libunwind callback acccessor functions.  */
static unw_accessors_t ia64_unw_accessors =
{
  ia64_find_proc_info_x,
  ia64_put_unwind_info,
  ia64_get_dyn_info_list,
  ia64_access_mem,
  ia64_access_reg,
  ia64_access_fpreg,
  /* resume */
  /* get_proc_name */
};

/* Set of ia64 gdb libunwind-frame callbacks and data for generic libunwind-frame code to use.  */
static struct libunwind_descr ia64_libunwind_descr =
{
  ia64_gdb2uw_regnum, 
  ia64_uw2gdb_regnum, 
  ia64_is_fpreg, 
  &ia64_unw_accessors,
};

#endif /* HAVE_LIBUNWIND_IA64_H  */

a2748 8
  /* According to the ia64 specs, instructions that store long double floats 
     in memory use a long-double format different than that used in the floating
     registers.  The memory format matches the x86 extended float format which is
     80 bits.  An OS may choose to use this format (e.g. Linux) or choose to use
     a different format for storing long doubles (e.g. HPUX).  In the latter case,
     the setting of the format may be moved/overridden in an OS-specific tdep file.  */
  set_gdbarch_long_double_format (gdbarch, &floatformat_i387_ext);

a2797 4
#ifdef HAVE_LIBUNWIND_IA64_H
  frame_unwind_append_sniffer (gdbarch, ia64_libunwind_frame_sniffer);
  libunwind_frame_set_descr (gdbarch, &ia64_libunwind_descr);
#endif
@


1.34.2.13
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2483 1
a2483 1
	fprintf_unfiltered (gdb_stdlog, "ia64_find_proc_info_x: %lx -> "
d2485 1
a2485 1
			    "length=%lu,data=%p)\n",
d2497 1
a2497 1
	fprintf_unfiltered (gdb_stdlog, "ia64_find_proc_info_x: %lx -> "
d2499 1
a2499 1
			    "length=%lu,data=%lx)\n",
d3359 6
a3364 8
  /* According to the ia64 specs, instructions that store long double
     floats in memory use a long-double format different than that
     used in the floating registers.  The memory format matches the
     x86 extended float format which is 80 bits.  An OS may choose to
     use this format (e.g. GNU/Linux) or choose to use a different
     format for storing long doubles (e.g. HPUX).  In the latter case,
     the setting of the format may be moved/overridden in an
     OS-specific tdep file.  */
d3426 2
@


1.33
log
@Index: ChangeLog
===================================================================
RCS file: /cvs/src/src/gdb/ChangeLog,v
retrieving revision 1.3144
diff -u -r1.3144 ChangeLog
--- ChangeLog	23 Aug 2002 23:05:38 -0000	1.3144
+++ ChangeLog	23 Aug 2002 23:14:45 -0000
@@@@ -1,3 +1,53 @@@@
2002-08-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (STORE_RETURN_VALUE): Add regcache parameter.
	(DEPRECATED_STORE_RETURN_VALUE): New method.
	(EXTRACT_RETURN_VALUE): Make buffer parameter a void pointer.
	* gdbarch.h, gdbarch.c: Re-generate.

	* values.c (set_return_value): Pass current_regcache to
	STORE_RETURN_VALUE.
	* arch-utils.h (legacy_store_return_value): Declare.
	* arch-utils.c (legacy_store_return_value): New function.
	(legacy_extract_return_value): Update parameters.

	* config/pa/tm-hppa.h (DEPRECATED_STORE_RETURN_VALUE): Rename
	STORE_RETURN_VALUE.
	* config/pa/tm-hppa64.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/z8k/tm-z8k.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparclet.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/mn10200/tm-mn10200.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-linux.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m32r/tm-m32r.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8500/tm-h8500.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8300/tm-h8300.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.

	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* i386-tdep.c (i386_extract_return_value): Update.
	* arch-utils.c (legacy_extract_return_value): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.

Index: doc/ChangeLog
2002-08-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Update
	STORE_RETURN_VALUE, mention regcache.
@
text
@d726 1
a726 1
    return generic_read_register_dummy (frame->pc, frame->frame, pc_regnum);
d1503 6
a1508 4
      bsp = generic_read_register_dummy (frame->next->pc, frame->next->frame,
                                         IA64_BSP_REGNUM);
      cfm = generic_read_register_dummy (frame->next->pc, frame->next->frame,
                                         IA64_CFM_REGNUM);
d1523 2
a1524 2
	cfm = generic_read_register_dummy (frn->next->pc, frn->next->frame,
	                                   IA64_PFS_REGNUM);
@


1.32
log
@* gdbarch.sh (REGISTER_NAME): Change return type a constant string
pointer.
* gdbarch.h, gdbarch.c: Regenerate.
* config/mips/tm-mips.h (mips_register_name): Update.
* i386-tdep.h (i386_register_name): Update.
* mips-tdep.c (mips_register_name): Update
* alpha-tdep.c (alpha_register_name): Update.
* arch-utils.c (legacy_register_name): Update.
* arch-utils.h (legacy_register_name): Update.
* avr-tdep.c (avr_register_name): Update.
* ia64-tdep.c (ia64_register_name): Update.
* i386-tdep.c (i386_register_name): Update.
* sparc-tdep.c (sparc32_register_name): Update.
(sparc64_register_name): Update.
(sparclite_register_name): Update.
(sparclet_register_name):
* sh-tdep.c (sh_generic_register_name): Update.
(sh_sh_register_name): Update.
(sh_sh3_register_name): Update.
(sh_sh3e_register_name): Update.
(sh_sh_dsp_register_name): Update.
(sh_sh3_dsp_register_name): Update.
(sh_sh4_register_name): Update.
(sh_sh64_register_name): Update.
* s390-tdep.c (s390_register_name): Update.
* rs6000-tdep.c (rs6000_register_name): Update.
* ns32k-tdep.c (ns32k_register_name_32082): Update.
(ns32k_register_name_32382): Update.
* d10v-tdep.c (d10v_ts2_register_name): Update.
(d10v_ts3_register_name): Update.
* xstormy16-tdep.c (xstormy16_register_name): Update.
* vax-tdep.c (vax_register_name): Update.
* v850-tdep.c (v850_register_name): Update.
* m68hc11-tdep.c (m68hc11_register_name): Update.
* mn10300-tdep.c (mn10300_generic_register_name): Update.
(am33_register_name): Update.
@
text
@a103 1
static gdbarch_store_return_value_ftype ia64_store_return_value;
d2195 1
a2195 1
  set_gdbarch_store_return_value (gdbarch, ia64_store_return_value);
@


1.31
log
@+	* gdbarch.sh (DEPRECATED_EXTRACT_RETURN_VALUE): Rename
+	EXTRACT_RETURN_VALUE.
+	(DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Rename
+	EXTRACT_STRUCT_VALUE_ADDRESS.
+	* gdbarch.h, gdbarch.c: Regenerate.
+
+	* values.c (value_being_returned): Handle
+	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
+	(EXTRACT_RETURN_VALUE): Define as DEPRECATED_EXTRACT_RETURN_VALUE.
+
+	* arm-linux-tdep.c (arm_linux_init_abi): Update.
+	* arm-tdep.c (arm_gdbarch_init): Update.
+	* avr-tdep.c (avr_gdbarch_init): Update.
+	* cris-tdep.c (cris_gdbarch_init): Update.
+	* d10v-tdep.c (d10v_gdbarch_init): Update.
+	* ia64-tdep.c (ia64_gdbarch_init): Update.
+	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
+	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sh-tdep.c (sh_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sparc-tdep.c (sparc_gdbarch_init): Update.
+	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
+	* v850-tdep.c (v850_gdbarch_init): Update.
+	* vax-tdep.c (vax_gdbarch_init): Update.
+	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
+	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
+
+	* config/arc/tm-arc.h: Update.
+	* config/d30v/tm-d30v.h: Update.
+	* config/fr30/tm-fr30.h: Update.
+	* config/h8300/tm-h8300.h: Update.
* config/h8500/tm-h8500.h: Update.
* config/i386/tm-i386.h: Update.
* config/i386/tm-ptx.h: Update.
* config/i386/tm-symmetry.h: Update.
* config/i960/tm-i960.h: Update.
* config/m32r/tm-m32r.h: Update.
* config/m68k/tm-delta68.h: Update.
* config/m68k/tm-linux.h: Update.
* config/m68k/tm-m68k.h: Update.
* config/m88k/tm-m88k.h: Update.
* config/mcore/tm-mcore.h: Update.
* config/mips/tm-mips.h: Update.
* config/mn10200/tm-mn10200.h: Update.
* config/pa/tm-hppa.h: Update.
* config/pa/tm-hppa64.h: Update.
* config/sparc/tm-sp64.h: Update.
* config/sparc/tm-sparc.h: Update.
* config/sparc/tm-sparclet.h: Update.
* config/z8k/tm-z8k.h: Update.
@
text
@d246 1
a246 1
static char *
@


1.30
log
@Handle breakpoints on L instruction type in MLX instruction bundle by
moving the breakpoint to the third slot (X instruction type) as L holds
only data.
@
text
@d99 2
a100 2
static gdbarch_extract_return_value_ftype ia64_extract_return_value;
static gdbarch_extract_struct_value_address_ftype ia64_extract_struct_value_address;
d2193 1
a2193 1
  set_gdbarch_extract_return_value (gdbarch, ia64_extract_return_value);
d2197 1
a2197 1
  set_gdbarch_extract_struct_value_address (gdbarch, ia64_extract_struct_value_address);
@


1.30.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d99 2
a100 2
static gdbarch_deprecated_extract_return_value_ftype ia64_extract_return_value;
static gdbarch_deprecated_extract_struct_value_address_ftype ia64_extract_struct_value_address;
d246 1
a246 1
static const char *
d2193 1
a2193 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, ia64_extract_return_value);
d2197 1
a2197 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, ia64_extract_struct_value_address);
@


1.30.4.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d104 1
d2196 1
a2196 1
  set_gdbarch_deprecated_store_return_value (gdbarch, ia64_store_return_value);
@


1.30.4.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d726 1
a726 1
    return deprecated_read_register_dummy (frame->pc, frame->frame, pc_regnum);
d1503 4
a1506 6
      bsp = deprecated_read_register_dummy (frame->next->pc,
					    frame->next->frame,
					    IA64_BSP_REGNUM);
      cfm = deprecated_read_register_dummy (frame->next->pc,
					    frame->next->frame,
					    IA64_CFM_REGNUM);
d1521 2
a1522 2
	cfm = deprecated_read_register_dummy (frn->next->pc, frn->next->frame,
					      IA64_PFS_REGNUM);
@


1.30.4.4
log
@merge from mainline
@
text
@d1378 2
a1379 2
      deprecated_generic_get_saved_register (raw_buffer, optimized, addrp,
					     frame, regnum, lval);
@


1.30.2.1
log
@merge from trunk
@
text
@d99 2
a100 2
static gdbarch_deprecated_extract_return_value_ftype ia64_extract_return_value;
static gdbarch_deprecated_extract_struct_value_address_ftype ia64_extract_struct_value_address;
d2193 1
a2193 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, ia64_extract_return_value);
d2197 1
a2197 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, ia64_extract_struct_value_address);
@


1.30.2.2
log
@Merge with trunk.
@
text
@d246 1
a246 1
static const char *
@


1.29
log
@* gdbarch.sh (BREAKPOINT_FROM_PC): Return a const buffer.
* gdbarch.h, gdbarch.c: Regenerate.

* defs.h (breakpoint_from_pc_fn): Delete type definition.
* target.h (memory_breakpoint_from_pc): Update declaration.
* config/mcore/tm-mcore.h (mcore_breakpoint_from_p): Ditto.

* arch-utils.c (legacy_breakpoint_from_pc): Update return type.
* mcore-tdep.c (mcore_breakpoint_from_pc): Ditto.
* mem-break.c (memory_breakpoint_from_pc): Ditto.
* rs6000-tdep.c (rs6000_breakpoint_from_pc): Ditto.
* s390-tdep.c (s390_breakpoint_from_pc): Ditto
* xstormy16-tdep.c (xstormy16_breakpoint_from_pc): Ditto.
* mn10300-tdep.c (mn10300_breakpoint_from_pc): Ditto.
* mips-tdep.c (mips_breakpoint_from_pc): Ditto.
* m68hc11-tdep.c (m68hc11_breakpoint_from_pc): Ditto.
* ia64-tdep.c (ia64_breakpoint_from_pc): Ditto.
* d10v-tdep.c (d10v_breakpoint_from_pc): Ditto.
* arch-utils.c (legacy_breakpoint_from_pc): Ditto..

* mem-break.c (default_memory_insert_breakpoint): Make `bp' a
const pointer.
* monitor.c (monitor_insert_breakpoint): Ditto.
* rs6000-tdep.c (rs6000_software_single_step): Ditto for `breakp'.

* config/mcore/tm-mcore.h: Update copyright.
* mem-break.c: Ditto.
* xstormy16-tdep.c: Ditto.
@
text
@d567 1
d575 9
d600 1
d605 9
@


1.28
log
@* h8500-tdep.c (h8500_write_fp): Delete function.
* dwarf2cfi.c (cfi_write_fp): Document as not used.
* mips-tdep.c (mips_gdbarch_init): Do not set write_fp.
* ia64-tdep.c (ia64_gdbarch_init): Do not set write_fp.
* m68hc11-tdep.c (m68hc11_gdbarch_init): Do not set write_fp.
* rs6000-tdep.c (rs6000_gdbarch_init): Do not set write_fp.
* s390-tdep.c (s390_gdbarch_init): Do not set write_fp.
(s390_write_fp):
* sh-tdep.c (sh_gdbarch_init): Do not set write_fp.
* x86-64-tdep.c (i386_gdbarch_init): Do not set write_fp.
* d10v-tdep.c (d10v_gdbarch_init): Do not set write_fp.
(d10v_write_fp): Delete function.
* inferior.h (write_fp, generic_target_write_fp): Delete
declarations.
* regcache.c (generic_target_write_fp): Delete function.
(write_fp): Delete function.
* gdbarch.sh (TARGET_WRITE_FP): Delete.
* gdbarch.h, gdbarch.c: Regenerate.
* config/v850/tm-v850.h (TARGET_WRITE_FP): Delete macro.
* config/sparc/tm-sp64.h (TARGET_WRITE_FP): Delete macro.
(sparc64_write_fp): Delete declaration.
* config/h8500/tm-h8500.h (TARGET_WRITE_FP): Delete macro.
(h8500_write_fp): Delete declaration.
@
text
@d604 1
a604 1
unsigned char *
@


1.27
log
@	* ia64-tdep.c (ia64_gdbarch_init): Call set_gdbarch_frame_args_skip,
	to fix internal_error from ``maintenance print architecture''.
@
text
@d670 3
a672 4
   chain, knowing that we'll have to make some small adjustments
   in other places.  (E.g, note that read_fp() and write_fp() are
   actually read_sp() and write_sp() below in ia64_gdbarch_init()
   below.) 
a2205 1
  set_gdbarch_write_fp (gdbarch, generic_target_write_sp);
@


1.26
log
@s/Linux/.../
Fix PR gdb/378.
@
text
@d2226 1
@


1.25
log
@	From Peter Schauer  <pes@@regent.e-technik.tu-muenchen.de>:
	* ia64-tdep.c (ia64_gdbarch_init): Eliminate incorrect use
	of ``current_gdbarch''.
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2001
   Free Software Foundation, Inc.
d1993 1
a1993 1
     size of the locals... and we should; but the linux kernel
d2075 5
a2079 4
      /* If os_ident is 0, it is not necessarily the case that we're on a
         SYSV system.  (ELFOSABI_NONE is defined to be 0.) GNU/Linux uses
	 a note section to record OS/ABI info, but leaves e_ident[EI_OSABI]
	 zero.  So we have to check for note sections too. */
d2116 7
a2122 6
  /* We know that Linux won't have to resort to the native_find_global_pointer
     hackery.  But that's the only one we know about so far, so if
     native_find_global_pointer is set to something non-zero, then use
     it.  Otherwise fall back to using generic_elf_find_global_pointer.  
     This arrangement should (in theory) allow us to cross debug Linux
     binaries from an AIX machine.  */
@


1.24
log
@Add explicit #include of "value.h".
@
text
@d2093 3
a2095 3
      if (gdbarch_tdep (current_gdbarch)->os_ident != os_ident)
	continue;
      return arches->gdbarch;
@


1.23
log
@Don't let a branch unit nop terminate the prologue scan.
@
text
@d30 1
@


1.22
log
@* defs.h (HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_LONG_DOUBLE_FORMAT, DOUBLEST)
(floatformat_to_doublest, floatformat_from_doublest)
(floatformat_is_negative, floatformat_is_nan)
(floatformat_mantissa, store_floating)
(extract_floating): Move declaration from here.
* doublest.h: To here.  New file.
* utils.c (get_field, floatformat_to_doublest, put_field)
(ldfrexp, floatformat_from_doublest, floatformat_is_negative)
(floatformat_is_nan, floatformat_mantissa)
(FLOATFORMAT_CHAR_BIT): Move from here.
* doublest.c: To here.  New file.
* findvar.c (store_floating, extract_floating): Move from here.
* doublest.c: To here.
* Makefile.in (SFILES): Add doublest.c.
(COMMON_OBS): Add doublest.o.
(doublest.o): Specify dependencies.
(doublest_h): Define.

* config/m88k/tm-m88k.h: Include "doublest.h".
* config/i960/tm-i960.h: Ditto.
* config/i386/tm-symmetry.h: Ditto.
* rs6000-tdep.c, valarith.c: Ditto.
* valprint.c, stabsread.c, sh-tdep.c: Ditto.
* ia64-tdep.c, i387-tdep.c, i386-tdep.c: Ditto.
* values.c, arm-tdep.c, arm-linux-tdep.c: Ditto.
* alpha-tdep.c, ax.h, expression.h: Ditto.
* sh-tdep.c, parse.c, top.c, value.h: Ditto.

* Makefile.in (arm-tdep.o): Add $(doublest_h).
(i386-tdep.o, i387-tdep.o, ia64-tdep.o): Ditto.
(rs6000-tdep.o, stabsread.o, valarith.o): Ditto.
(values.o, valprint.o, arm-linux-tdep.o): Ditto.
(alpha-tdep.o, ax_h, parse.o, top.o, value_h): Ditto.
(parser_defs_h): Ditto.
(expression_h): Add $(doublest_h) and $(symtab_h).
@
text
@d863 2
a864 1
      if (it == B || ((instr & 0x3fLL) != 0LL))
d866 2
a867 2
	  /* Exit loop upon hitting a branch instruction or a predicated
	     instruction. */
@


1.21
log
@s/value_ptr/struct value */
@
text
@d29 1
@


1.20
log
@Make alignment of struct arguments in inferior function calls comply with
the IA-64 Software Conventions and Runtime manual.
@
text
@d1752 1
a1752 1
ia64_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
d1756 1
a1756 1
  value_ptr arg;
@


1.20.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d1831 1
a1831 1
	  && TYPE_CODE (POINTER_TARGET_TYPE (type)) == TYPE_CODE_FUNC)
@


1.19
log
@Prologue scanner modifications.
@
text
@d1537 3
a1539 1
      return is_float_or_hfa_type_recurse (TYPE_TARGET_TYPE (t), etp);
d1546 2
a1547 1
	  if (!is_float_or_hfa_type_recurse (TYPE_FIELD_TYPE (t, i), etp))
d1571 34
d1772 1
a1772 3
      /* FIXME: This is crude and it is wrong (IMO), but it matches
         what gcc does, I think. */
      if (len > 8 && (nslots & 1))
d1847 3
a1849 1
      if (len > 8 && (slotnum & 1))
d1851 1
@


1.18
log
@Phase 1 of the ptid_t changes.
@
text
@d720 63
d810 1
d827 2
d848 5
a852 1
    pc = lim_pc;	/* We're done early */
@


1.17
log
@Fix problems encountered in compiling ia64-tdep.c with IBM's compiler.
@
text
@d615 1
a615 1
ia64_read_pc (int pid)
d617 2
a618 2
  CORE_ADDR psr_value = read_register_pid (IA64_PSR_REGNUM, pid);
  CORE_ADDR pc_value   = read_register_pid (IA64_IP_REGNUM, pid);
d625 1
a625 1
ia64_write_pc (CORE_ADDR new_pc, int pid)
d628 1
a628 1
  CORE_ADDR psr_value = read_register_pid (IA64_PSR_REGNUM, pid);
d634 2
a635 2
  write_register_pid (IA64_PSR_REGNUM, psr_value, pid);
  write_register_pid (IA64_IP_REGNUM, new_pc, pid);
@


1.16
log
@	* ia64-tdep.c (fetch_instruction): Warn about slot numbers greater
	than two instead of generating an error.
@
text
@d435 1
a435 1
slotN_contents (unsigned char *bundle, int slotnum)
d443 1
a443 1
replace_slotN_contents (unsigned char *bundle, long long instr, int slotnum)
d1168 1
a1168 1
      char pr_raw_buffer[MAX_REGISTER_RAW_SIZE];
d1191 1
a1191 1
      char unat_raw_buffer[MAX_REGISTER_RAW_SIZE];
@


1.15
log
@Create new file regcache.h.  Update all uses.
@
text
@d495 13
d509 5
a513 1
    error("Can't fetch instructions for slot numbers greater than 2.");
@


1.14
log
@Made changes to shared library support and added more of the support needed
for AIX/IA-64.
@
text
@d28 1
@


1.13
log
@Enable new thread support for Linux/IA-64.
@
text
@d79 1
a79 2
extern void _initialize_ia64_tdep (void);

d81 1
d1973 6
d1981 2
@


1.12
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d1344 2
a1345 2
  /* FIXME: Implement */
  return 0;
@


1.11
log
@2000-11-20  H.J. Lu  <hjl@@gnu.org>

	* ia64-tdep.c (gdbarch_tdep): Change reference from
	ELFOSABI_MONTEREY to ELFOSABI_AIX.
@
text
@d2 1
a2 1
   Copyright 1999, 2000
d327 2
a328 1
    internal_error ("read_sigcontext_register: NULL frame");
d330 2
a331 2
    internal_error (
      "read_sigcontext_register: frame not a signal_handler_caller");
d333 2
a334 2
    internal_error (
      "read_sigcontext_register: SIGCONTEXT_REGISTER_ADDRESS is 0");
d340 2
a341 2
    internal_error (
      "read_sigcontext_register: Register %d not in struct sigcontext", regnum);
d1926 2
a1927 2
	      internal_error (
		"process_note_abi_sections: unknown OS number %d", os_number);
@


1.10
log
@AIX5 changes.
@
text
@d229 1
a229 1
                           constants: ELFOSABI_LINUX, ELFOSABI_MONTEREY,
@


1.9
log
@Add rotating register rename support.
@
text
@d33 13
d235 1
d238 4
a241 1
#define SIGCONTEXT_REGISTER_ADDRESS (gdbarch_tdep (current_gdbarch)->sigcontext_register_address)
d1490 1
a1490 1
find_global_pointer (CORE_ADDR faddr)
d1611 1
a1611 1
      global_pointer = find_global_pointer (faddr);
d1792 1
a1792 1
  CORE_ADDR global_pointer = find_global_pointer (pc);
a1917 1
#if 0	/* FIXME: Enable after internal repository is synced with sourceware */
a1923 1
#endif
d1977 13
d2003 1
@


1.8
log
@Protoization.
@
text
@d987 7
d1003 5
a1007 1
	frame->saved_regs[IA64_GR32_REGNUM + i] = addr;
d1139 10
d1239 12
@


1.7
log
@2000-05-02  H.J. Lu  <hjl@@gnu.org>

	* ia64-tdep.c (ia64_gdbarch_init): Reference to ELFOSABI_NONE
	instead of ELFOSABI_SYSV.
@
text
@d567 1
a567 3
ia64_breakpoint_from_pc (pcptr, lenptr)
     CORE_ADDR *pcptr;
     int *lenptr;
@


1.6
log
@Add arch-utils.h to IA-64 *-tdep.c files.
@
text
@d1900 1
a1900 1
         SYSV system.  (ELFOSABI_SYSV is defined to be 0.) GNU/Linux uses
@


1.5
log
@Recognize store instructions in examine_prologue().
@
text
@d26 1
@


1.4
log
@Handle signal handler frames and call dummy frames.
@
text
@d710 5
d757 7
a763 1
      if (it == I && ((instr & 0x1eff8000000LL) == 0x00188000000LL))
d913 42
a980 2
      else if (it == B || ((instr & 0x3fLL) != 0LL))
	break;
@


1.3
log
@IA-64 changes
@
text
@d30 1
d67 2
d194 7
a200 7
{
  CORE_ADDR bsp;	/* points at r32 for the current frame */
  CORE_ADDR cfm;	/* cfm value for current frame */
  int       sof;	/* Size of frame  (decoded from cfm value) */
  int	    sol;	/* Size of locals (decoded from cfm value) */
  CORE_ADDR after_prologue;
  			/* Address of first instruction after the last
d204 2
a205 2
  int       mem_stack_frame_size;
  			/* Size of the memory stack frame (may be zero),
d207 2
a208 2
  int	    fp_reg;	/* Register number (if any) used a frame pointer
                           for this frame.  0 if no register is being used
d210 14
a223 1
};
d300 25
d328 1
a328 1
long long
d364 1
a364 1
void
d414 1
a414 1
long long
d422 1
a422 1
void
d651 4
a654 4
  FRAME_INIT_SAVED_REGS (frame);

  if (frame->saved_regs[IA64_VFP_REGNUM])
    return read_memory_integer (frame->saved_regs[IA64_VFP_REGNUM], 8);
d656 7
a662 1
    return frame->frame + frame->extra_info->mem_stack_frame_size;
d668 7
a674 1
  FRAME_INIT_SAVED_REGS (frame);
d676 7
a682 4
  if (frame->saved_regs[IA64_VRAP_REGNUM])
    return read_memory_integer (frame->saved_regs[IA64_VRAP_REGNUM], 8);
  else	/* either frameless, or not far enough along in the prologue... */
    return ia64_saved_pc_after_call (frame);
a974 2
  CORE_ADDR func_start;

d978 5
a982 3
  func_start = get_pc_function_start (frame->pc);
  examine_prologue (func_start, frame->pc, frame);
}
d984 32
a1015 18
static CORE_ADDR
ia64_find_saved_register (frame, regnum)
     struct frame_info *frame;
     int regnum;
{
  register CORE_ADDR addr = 0;

  if ((IA64_GR32_REGNUM <= regnum && regnum <= IA64_GR127_REGNUM)
      || regnum == IA64_VFP_REGNUM
      || regnum == IA64_VRAP_REGNUM)
    {
      FRAME_INIT_SAVED_REGS (frame);
      return frame->saved_regs[regnum];
    }
  else if (regnum == IA64_IP_REGNUM && frame->next)
    {
      FRAME_INIT_SAVED_REGS (frame->next);
      return frame->next->saved_regs[IA64_VRAP_REGNUM];
d1019 4
a1022 11
      struct frame_info *frame1 = NULL;
      while (1)
	{
	  QUIT;
	  frame1 = get_prev_frame (frame1);
	  if (frame1 == 0 || frame1 == frame)
	    break;
	  FRAME_INIT_SAVED_REGS (frame1);
	  if (frame1->saved_regs[regnum])
	    addr = frame1->saved_regs[regnum];
	}
a1023 2

  return addr;
d1034 1
a1034 1
  CORE_ADDR addr;
d1041 10
a1050 51
  addr = ia64_find_saved_register (frame, regnum);
  if (addr != 0)
    {
      if (lval != NULL)
	*lval = lval_memory;
      if (regnum == SP_REGNUM)
	{
	  if (raw_buffer != NULL)
	    {
	      /* Put it back in target format.  */
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum), (LONGEST) addr);
	    }
	  if (addrp != NULL)
	    *addrp = 0;
	  return;
	}
      if (raw_buffer != NULL)
	read_memory (addr, raw_buffer, REGISTER_RAW_SIZE (regnum));
    }
  else if (IA64_GR32_REGNUM <= regnum && regnum <= IA64_GR127_REGNUM)
    {
      /* r32 - r127 must be fetchable via memory.  If they aren't,
         then the register is unavailable */
      addr = 0;
      if (lval != NULL)
	*lval = not_lval;
      memset (raw_buffer, 0, REGISTER_RAW_SIZE (regnum));
    }
  else if (regnum == IA64_IP_REGNUM)
    {
      CORE_ADDR pc;
      if (frame->next)
        {
	  /* This case will normally be handled above, except when it's
	     frameless or we haven't advanced far enough into the prologue
	     of the top frame to save the register. */
	  addr = REGISTER_BYTE (regnum);
	  if (lval != NULL)
	    *lval = lval_register;
	  pc = ia64_saved_pc_after_call (frame);
        }
      else
        {
	  addr = 0;
	  if (lval != NULL)
	    *lval = not_lval;
	  pc = read_pc ();
	}
      store_address (raw_buffer, REGISTER_RAW_SIZE (IA64_IP_REGNUM), pc);
    }
  else if (regnum == SP_REGNUM && frame->next)
a1052 3
      addr = 0;
      if (lval != NULL)
        *lval = not_lval;
a1056 3
      addr = 0;
      if (lval != NULL)
        *lval = not_lval;
a1066 3
      addr = 0;
      if (lval != NULL)
	*lval = not_lval;
a1080 3
      addr = 0;
      if (lval != NULL)
	*lval = not_lval;
a1094 3
      addr = 0;
      if (lval != NULL)
	*lval = not_lval;
d1101 8
a1108 3
      CORE_ADDR gr_addr = 
	ia64_find_saved_register (frame, 
	                          regnum - IA64_NAT0_REGNUM + IA64_GR0_REGNUM);
d1127 38
a1164 3
      addr = 0;
      if (lval != NULL)
	*lval = not_lval;
d1168 2
a1169 5
      if (lval != NULL)
	*lval = lval_register;
      addr = REGISTER_BYTE (regnum);
      if (raw_buffer != NULL)
	read_register_gen (regnum, raw_buffer);
a1170 2
  if (addrp != NULL)
    *addrp = addr;
d1273 3
d1286 12
d1306 7
d1321 3
a1323 1
  if (frame->next == 0)
d1786 49
d1839 7
d1847 22
a1868 3
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d1870 8
a1877 1
  gdbarch = gdbarch_alloc (&info, NULL);
d1911 1
a1911 1
  set_gdbarch_frame_chain_valid (gdbarch, func_frame_chain_valid);
@


1.2
log
@HFA, function descriptor handling for IA-64.
@
text
@d1252 1
a1252 1
	cfm = read_register (IA64_CFM_REGNUM);
d1328 1
a1328 1
  struct partial_symtab *pst;
d1330 2
a1331 2
  pst = find_pc_psymtab (faddr);
  if (pst != NULL)
d1335 1
a1335 1
      ALL_OBJFILE_OSECTIONS (pst->objfile, osect)
d1341 1
a1341 1
      if (osect < pst->objfile->sections_end)
d1386 1
a1386 2
  struct partial_symtab *pst;
  struct obj_section *osect;
d1389 2
a1390 2
  osect = find_pc_section (faddr);
  if (osect && strcmp (osect->the_bfd_section->name, ".opd") == 0)
d1393 1
a1393 2
  pst = find_pc_psymtab (faddr);
  if (pst != NULL)
d1395 2
a1396 1
      ALL_OBJFILE_OSECTIONS (pst->objfile, osect)
d1402 1
a1402 1
      if (osect < pst->objfile->sections_end)
@


1.1
log
@New files for IA-64 port.
@
text
@a89 1

d91 1
d387 1
a387 1
static template_encoding_table[32][3] =
d448 1
a448 1
  if (slotnum == 2 || slotnum == 1 && *it == L)
a641 1
  int done = 0;
d1139 13
a1151 3
  /* FIXME: Need to check for HFAs; structures containing (only) up to 8
     floating point values of the same size are returned in floating point
     registers. */
d1158 17
a1174 3
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    ia64_register_convert_to_virtual (IA64_FR8_REGNUM, type,
      &regbuf[REGISTER_BYTE (IA64_FR8_REGNUM)], valbuf);
d1176 2
a1177 1
    memcpy (valbuf, &regbuf[REGISTER_BYTE (IA64_GR8_REGNUM)], TYPE_LENGTH (type));
a1245 1
      CORE_ADDR cfm_addr;
d1269 192
a1460 1
#define ROUND_UP(n,a) (((n)+(a)-1) & ~((a)-1))
d1470 1
a1470 1
  int nslots, rseslots, memslots, slotnum;
d1472 1
a1472 1
  CORE_ADDR bsp, cfm, pfs, new_bsp;
d1475 1
d1488 3
d1494 1
d1498 1
d1515 10
a1524 3

  
  sp = sp - 16 - memslots * 8;
d1527 4
d1535 2
d1540 20
d1579 18
a1596 5
      if (TYPE_CODE (type) == TYPE_CODE_FLT && floatreg < IA64_FR16_REGNUM)
        {
	  ia64_register_convert_to_raw (type, floatreg, VALUE_CONTENTS (arg),
	    &registers[REGISTER_BYTE (floatreg)]);
	  floatreg++;
d1600 1
d1608 1
a1608 1

d1629 1
a1629 31
  struct partial_symtab *pst;

  /* Attempt to determine and set global pointer (r1) for this pc.
     
     This rather nasty bit of code searchs for the .dynamic section
     in the objfile corresponding to the pc of the function we're
     trying to call.  Once it finds the addresses at which the .dynamic
     section lives in the child process, it scans the Elf64_Dyn entries
     for a DT_PLTGOT tag.  If it finds one of these, the corresponding
     d_un.d_ptr value is the global pointer. */
  pst = find_pc_psymtab (pc);
  if (pst != NULL)
    {
      struct obj_section *osect;

      ALL_OBJFILE_OSECTIONS (pst->objfile, osect)
	{
	  if (strcmp (osect->the_bfd_section->name, ".dynamic") == 0)
	    break;
	}

      if (osect < pst->objfile->sections_end)
	{
	  CORE_ADDR addr;

	  addr = osect->addr;
	  while (addr < osect->endaddr)
	    {
	      int status;
	      LONGEST tag;
	      char buf[8];
d1631 2
a1632 26
	      status = target_read_memory (addr, buf, sizeof (buf));
	      if (status != 0)
		break;
	      tag = extract_signed_integer (buf, sizeof (buf));

	      if (tag == DT_PLTGOT)
		{
		  CORE_ADDR global_pointer;

		  status = target_read_memory (addr + 8, buf, sizeof (buf));
		  if (status != 0)
		    break;
		  global_pointer = extract_address (buf, sizeof (buf));

		  /* The payoff... */
		  write_register (IA64_GR1_REGNUM, global_pointer);
		  break;
		}

	      if (tag == DT_NULL)
		break;

	      addr += 16;
	    }
	}
    }
@

