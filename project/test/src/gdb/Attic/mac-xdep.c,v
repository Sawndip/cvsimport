head	1.7;
access;
symbols
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.8
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.6
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.4
	gdb_5_1-2001-07-29-branchpoint:1.6
	dberlin-typesystem-branch:1.6.0.2
	dberlin-typesystem-branchpoint:1.6
	gdb-post-ptid_t-2001-05-03:1.6
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb-post-params-removal-2000-06-04:1.1.1.2
	gdb-pre-params-removal-2000-06-04:1.1.1.2
	gdb-post-params-removal-2000-05-28:1.1.1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.7
date	2002.01.05.05.54.29;	author cagney;	state dead;
branches;
next	1.6;

1.6
date	2001.04.19.23.56.13;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.21.10;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.06.04.17.03;	author jtc;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.31.01.24.01;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.07.57;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Remove obsolete MacOS support.
@
text
@/* OBSOLETE /* Top level support for Mac interface to GDB, the GNU debugger. */
/* OBSOLETE    Copyright 1994, 1995, 1998, 2000, 2001 Free Software Foundation, Inc. */
/* OBSOLETE    Contributed by Cygnus Support.  Written by Stan Shebs. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE  */
/* OBSOLETE #include <readline/readline.h> */
/* OBSOLETE #include <readline/history.h> */
/* OBSOLETE  */
/* OBSOLETE #include <Types.h> */
/* OBSOLETE #include <Resources.h> */
/* OBSOLETE #include <QuickDraw.h> */
/* OBSOLETE #include <Fonts.h> */
/* OBSOLETE #include <Events.h> */
/* OBSOLETE #include <Windows.h> */
/* OBSOLETE #include <Menus.h> */
/* OBSOLETE #include <TextEdit.h> */
/* OBSOLETE #include <Dialogs.h> */
/* OBSOLETE #include <Desk.h> */
/* OBSOLETE #include <ToolUtils.h> */
/* OBSOLETE #include <Memory.h> */
/* OBSOLETE #include <SegLoad.h> */
/* OBSOLETE #include <Files.h> */
/* OBSOLETE #include <Folders.h> */
/* OBSOLETE #include <OSUtils.h> */
/* OBSOLETE #include <OSEvents.h> */
/* OBSOLETE #include <DiskInit.h> */
/* OBSOLETE #include <Packages.h> */
/* OBSOLETE #include <Traps.h> */
/* OBSOLETE #include <Lists.h> */
/* OBSOLETE #include <Gestalt.h> */
/* OBSOLETE #include <PPCToolbox.h> */
/* OBSOLETE #include <AppleEvents.h> */
/* OBSOLETE #include <StandardFile.h> */
/* OBSOLETE #include <Sound.h> */
/* OBSOLETE  */
/* OBSOLETE #ifdef MPW */
/* OBSOLETE #define QD(whatever) (qd.##whatever) */
/* OBSOLETE #define QDPat(whatever) (&(qd.##whatever)) */
/* OBSOLETE #endif /* MPW */ */
/* OBSOLETE  */
/* OBSOLETE #ifdef THINK_C */
/* OBSOLETE #define QD(whatever) (whatever) */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE #define p2c(pstr,cbuf)  \ */
/* OBSOLETE   strncpy(cbuf, ((char *) (pstr) + 1), pstr[0]);  \ */
/* OBSOLETE   cbuf[pstr[0]] = '\0'; */
/* OBSOLETE  */
/* OBSOLETE #define pascalify(STR) \ */
/* OBSOLETE   sprintf(tmpbuf, " %s", STR);  \ */
/* OBSOLETE   tmpbuf[0] = strlen(STR); */
/* OBSOLETE  */
/* OBSOLETE #include "gdbcmd.h" */
/* OBSOLETE #include "call-cmds.h" */
/* OBSOLETE #include "symtab.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include <signal.h> */
/* OBSOLETE #include "target.h" */
/* OBSOLETE #include "breakpoint.h" */
/* OBSOLETE #include "gdbtypes.h" */
/* OBSOLETE #include "expression.h" */
/* OBSOLETE #include "language.h" */
/* OBSOLETE  */
/* OBSOLETE #include "mac-defs.h" */
/* OBSOLETE  */
/* OBSOLETE int debug_openp = 0; */
/* OBSOLETE  */
/* OBSOLETE /* This is true if we are running as a standalone application.  */ */
/* OBSOLETE  */
/* OBSOLETE int mac_app; */
/* OBSOLETE  */
/* OBSOLETE /* This is true if we are using WaitNextEvent.  */ */
/* OBSOLETE  */
/* OBSOLETE int use_wne; */
/* OBSOLETE  */
/* OBSOLETE /* This is true if we have Color Quickdraw.  */ */
/* OBSOLETE  */
/* OBSOLETE int has_color_qd; */
/* OBSOLETE  */
/* OBSOLETE /* This is true if we are using Color Quickdraw. */ */
/* OBSOLETE  */
/* OBSOLETE int use_color_qd; */
/* OBSOLETE  */
/* OBSOLETE int inbackground; */
/* OBSOLETE  */
/* OBSOLETE Rect dragrect = */
/* OBSOLETE {-32000, -32000, 32000, 32000}; */
/* OBSOLETE Rect sizerect; */
/* OBSOLETE  */
/* OBSOLETE int sbarwid = 15; */
/* OBSOLETE  */
/* OBSOLETE /* Globals for the console window. */ */
/* OBSOLETE  */
/* OBSOLETE WindowPtr console_window; */
/* OBSOLETE  */
/* OBSOLETE ControlHandle console_v_scrollbar; */
/* OBSOLETE  */
/* OBSOLETE Rect console_v_scroll_rect; */
/* OBSOLETE  */
/* OBSOLETE TEHandle console_text; */
/* OBSOLETE  */
/* OBSOLETE Rect console_text_rect; */
/* OBSOLETE  */
/* OBSOLETE /* This will go away eventually. */ */
/* OBSOLETE gdb_has_a_terminal (void) */
/* OBSOLETE { */
/* OBSOLETE   return 1; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE mac_init (void) */
/* OBSOLETE { */
/* OBSOLETE   SysEnvRec se; */
/* OBSOLETE   int eventloopdone = 0; */
/* OBSOLETE   char *str; */
/* OBSOLETE   Boolean gotevent; */
/* OBSOLETE   Point mouse; */
/* OBSOLETE   EventRecord event; */
/* OBSOLETE   WindowPtr win; */
/* OBSOLETE   RgnHandle cursorRgn; */
/* OBSOLETE   int i; */
/* OBSOLETE   Handle menubar; */
/* OBSOLETE   MenuHandle menu; */
/* OBSOLETE   Handle siow_resource; */
/* OBSOLETE  */
/* OBSOLETE   mac_app = 0; */
/* OBSOLETE  */
/* OBSOLETE   str = getenv ("DEBUG_GDB"); */
/* OBSOLETE   if (str != NULL && str[0] != '\0') */
/* OBSOLETE     { */
/* OBSOLETE       if (strcmp (str, "openp") == 0) */
/* OBSOLETE 	debug_openp = 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Don't do anything if we`re running under MPW. */ */
/* OBSOLETE   if (!StandAlone) */
/* OBSOLETE     return; */
/* OBSOLETE  */
/* OBSOLETE   /* Don't do anything if we're using SIOW. */ */
/* OBSOLETE   /* This test requires that the siow 0 resource, as defined in */
/* OBSOLETE      {RIncludes}siow.r, not be messed with.  If it is, then the */
/* OBSOLETE      standard Mac setup below will step on SIOW's Mac setup and */
/* OBSOLETE      most likely crash the machine. */ */
/* OBSOLETE   siow_resource = GetResource ('siow', 0); */
/* OBSOLETE   if (siow_resource != nil) */
/* OBSOLETE     return; */
/* OBSOLETE  */
/* OBSOLETE   mac_app = 1; */
/* OBSOLETE  */
/* OBSOLETE   /* Do the standard Mac environment setup. */ */
/* OBSOLETE   InitGraf (&QD (thePort)); */
/* OBSOLETE   InitFonts (); */
/* OBSOLETE   FlushEvents (everyEvent, 0); */
/* OBSOLETE   InitWindows (); */
/* OBSOLETE   InitMenus (); */
/* OBSOLETE   TEInit (); */
/* OBSOLETE   InitDialogs (NULL); */
/* OBSOLETE   InitCursor (); */
/* OBSOLETE  */
/* OBSOLETE   /* Color Quickdraw is different from Classic QD. */ */
/* OBSOLETE   SysEnvirons (2, &se); */
/* OBSOLETE   has_color_qd = se.hasColorQD; */
/* OBSOLETE   /* Use it if we got it. */ */
/* OBSOLETE   use_color_qd = has_color_qd; */
/* OBSOLETE  */
/* OBSOLETE   sizerect.top = 50; */
/* OBSOLETE   sizerect.left = 50; */
/* OBSOLETE   sizerect.bottom = 1000; */
/* OBSOLETE   sizerect.right = 1000; */
/* OBSOLETE #if 0 */
/* OBSOLETE   sizerect.bottom = screenBits.bounds.bottom - screenBits.bounds.top; */
/* OBSOLETE   sizerect.right = screenBits.bounds.right - screenBits.bounds.left; */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE   /* Set up the menus. */ */
/* OBSOLETE   menubar = GetNewMBar (mbMain); */
/* OBSOLETE   SetMenuBar (menubar); */
/* OBSOLETE   /* Add the DAs etc as usual. */ */
/* OBSOLETE   menu = GetMHandle (mApple); */
/* OBSOLETE   if (menu != nil) */
/* OBSOLETE     { */
/* OBSOLETE       AddResMenu (menu, 'DRVR'); */
/* OBSOLETE     } */
/* OBSOLETE   DrawMenuBar (); */
/* OBSOLETE  */
/* OBSOLETE   new_console_window (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE new_console_window (void) */
/* OBSOLETE { */
/* OBSOLETE   /* Create the main window we're going to play in. */ */
/* OBSOLETE   if (has_color_qd) */
/* OBSOLETE     console_window = GetNewCWindow (wConsole, NULL, (WindowPtr) - 1L); */
/* OBSOLETE   else */
/* OBSOLETE     console_window = GetNewWindow (wConsole, NULL, (WindowPtr) - 1L); */
/* OBSOLETE  */
/* OBSOLETE   SetPort (console_window); */
/* OBSOLETE   console_text_rect = console_window->portRect; */
/* OBSOLETE   /* Leave 8 pixels of blank space, for aesthetic reasons and to */
/* OBSOLETE      make it easier to select from the beginning of a line. */ */
/* OBSOLETE   console_text_rect.left += 8; */
/* OBSOLETE   console_text_rect.bottom -= sbarwid - 1; */
/* OBSOLETE   console_text_rect.right -= sbarwid - 1; */
/* OBSOLETE   console_text = TENew (&console_text_rect, &console_text_rect); */
/* OBSOLETE   TESetSelect (0, 40000, console_text); */
/* OBSOLETE   TEDelete (console_text); */
/* OBSOLETE   TEAutoView (1, console_text); */
/* OBSOLETE  */
/* OBSOLETE   console_v_scroll_rect = console_window->portRect; */
/* OBSOLETE   console_v_scroll_rect.bottom -= sbarwid - 1; */
/* OBSOLETE   console_v_scroll_rect.left = console_v_scroll_rect.right - sbarwid; */
/* OBSOLETE   console_v_scrollbar = */
/* OBSOLETE     NewControl (console_window, &console_v_scroll_rect, */
/* OBSOLETE 		"\p", 1, 0, 0, 0, scrollBarProc, 0L); */
/* OBSOLETE  */
/* OBSOLETE   ShowWindow (console_window); */
/* OBSOLETE   SelectWindow (console_window); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE mac_command_loop (void) */
/* OBSOLETE { */
/* OBSOLETE   SysEnvRec se; */
/* OBSOLETE   int eventloopdone = 0; */
/* OBSOLETE   Boolean gotevent; */
/* OBSOLETE   Point mouse; */
/* OBSOLETE   EventRecord event; */
/* OBSOLETE   WindowPtr win; */
/* OBSOLETE   RgnHandle cursorRgn; */
/* OBSOLETE   int i, tm; */
/* OBSOLETE   Handle menubar; */
/* OBSOLETE   MenuHandle menu; */
/* OBSOLETE  */
/* OBSOLETE   /* Figure out if the WaitNextEvent Trap is available.  */ */
/* OBSOLETE   use_wne = */
/* OBSOLETE     (NGetTrapAddress (0x60, ToolTrap) != NGetTrapAddress (0x9f, ToolTrap)); */
/* OBSOLETE   /* Pass WaitNextEvent an empty region the first time through.  */ */
/* OBSOLETE   cursorRgn = NewRgn (); */
/* OBSOLETE   /* Go into the main event-handling loop.  */ */
/* OBSOLETE   while (!eventloopdone) */
/* OBSOLETE     { */
/* OBSOLETE       /* Use WaitNextEvent if it is available, otherwise GetNextEvent.  */ */
/* OBSOLETE       if (use_wne) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  get_global_mouse (&mouse); */
/* OBSOLETE 	  adjust_cursor (mouse, cursorRgn); */
/* OBSOLETE 	  tm = GetCaretTime (); */
/* OBSOLETE 	  gotevent = WaitNextEvent (everyEvent, &event, tm, cursorRgn); */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  SystemTask (); */
/* OBSOLETE 	  gotevent = GetNextEvent (everyEvent, &event); */
/* OBSOLETE 	} */
/* OBSOLETE       /* First decide if the event is for a dialog or is just any old event. */ */
/* OBSOLETE       if (FrontWindow () != nil && IsDialogEvent (&event)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  short itemhit; */
/* OBSOLETE 	  DialogPtr dialog; */
/* OBSOLETE  */
/* OBSOLETE 	  /* Handle all the modeless dialogs here. */ */
/* OBSOLETE 	  if (DialogSelect (&event, &dialog, &itemhit)) */
/* OBSOLETE 	    { */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       else if (gotevent) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* Make sure we have the right cursor before handling the event. */ */
/* OBSOLETE 	  adjust_cursor (event.where, cursorRgn); */
/* OBSOLETE 	  do_event (&event); */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  do_idle (); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Collect the global coordinates of the mouse pointer.  */ */
/* OBSOLETE  */
/* OBSOLETE get_global_mouse (Point *mouse) */
/* OBSOLETE { */
/* OBSOLETE   EventRecord evt; */
/* OBSOLETE  */
/* OBSOLETE   OSEventAvail (0, &evt); */
/* OBSOLETE   *mouse = evt.where; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Change the cursor's appearance to be appropriate for the given mouse */
/* OBSOLETE    location.  */ */
/* OBSOLETE  */
/* OBSOLETE adjust_cursor (Point mouse, RgnHandle region) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Decipher an event, maybe do something with it.  */ */
/* OBSOLETE  */
/* OBSOLETE do_event (EventRecord *evt) */
/* OBSOLETE { */
/* OBSOLETE   short part, err, rslt = 0; */
/* OBSOLETE   WindowPtr win; */
/* OBSOLETE   Boolean hit; */
/* OBSOLETE   char key; */
/* OBSOLETE   Point pnt; */
/* OBSOLETE  */
/* OBSOLETE   switch (evt->what) */
/* OBSOLETE     { */
/* OBSOLETE     case mouseDown: */
/* OBSOLETE       /* See if the click happened in a special part of the screen. */ */
/* OBSOLETE       part = FindWindow (evt->where, &win); */
/* OBSOLETE       switch (part) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case inMenuBar: */
/* OBSOLETE 	  adjust_menus (); */
/* OBSOLETE 	  do_menu_command (MenuSelect (evt->where)); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case inSysWindow: */
/* OBSOLETE 	  SystemClick (evt, win); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case inContent: */
/* OBSOLETE 	  if (win != FrontWindow ()) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* Bring the clicked-on window to the front. */ */
/* OBSOLETE 	      SelectWindow (win); */
/* OBSOLETE 	      /* Fix the menu to match the new front window. */ */
/* OBSOLETE 	      adjust_menus (); */
/* OBSOLETE 	      /* We always want to discard the event now, since clicks in a */
/* OBSOLETE 	         windows are often irreversible actions. */ */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    /* Mouse clicks in the front window do something useful. */ */
/* OBSOLETE 	    do_mouse_down (win, evt); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case inDrag: */
/* OBSOLETE 	  /* Standard drag behavior, no tricks necessary. */ */
/* OBSOLETE 	  DragWindow (win, evt->where, &dragrect); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case inGrow: */
/* OBSOLETE 	  grow_window (win, evt->where); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case inZoomIn: */
/* OBSOLETE 	case inZoomOut: */
/* OBSOLETE 	  zoom_window (win, evt->where, part); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case inGoAway: */
/* OBSOLETE 	  close_window (win); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE       break; */
/* OBSOLETE     case keyDown: */
/* OBSOLETE     case autoKey: */
/* OBSOLETE       key = evt->message & charCodeMask; */
/* OBSOLETE       /* Check for menukey equivalents. */ */
/* OBSOLETE       if (evt->modifiers & cmdKey) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (evt->what == keyDown) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      adjust_menus (); */
/* OBSOLETE 	      do_menu_command (MenuKey (key)); */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (evt->what == keyDown) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* Random keypress, interpret it. */ */
/* OBSOLETE 	      do_keyboard_command (key); */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       break; */
/* OBSOLETE     case activateEvt: */
/* OBSOLETE       activate_window ((WindowPtr) evt->message, evt->modifiers & activeFlag); */
/* OBSOLETE       break; */
/* OBSOLETE     case updateEvt: */
/* OBSOLETE       update_window ((WindowPtr) evt->message); */
/* OBSOLETE       break; */
/* OBSOLETE     case diskEvt: */
/* OBSOLETE       /* Call DIBadMount in response to a diskEvt, so that the user can format */
/* OBSOLETE          a floppy. (from DTS Sample) */ */
/* OBSOLETE       if (HiWord (evt->message) != noErr) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  SetPt (&pnt, 50, 50); */
/* OBSOLETE 	  err = DIBadMount (pnt, evt->message); */
/* OBSOLETE 	} */
/* OBSOLETE       break; */
/* OBSOLETE     case app4Evt: */
/* OBSOLETE       /* Grab only a single byte. */ */
/* OBSOLETE       switch ((evt->message >> 24) & 0xFF) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case 0xfa: */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case 1: */
/* OBSOLETE 	  inbackground = !(evt->message & 1); */
/* OBSOLETE 	  activate_window (FrontWindow (), !inbackground); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE       break; */
/* OBSOLETE     case kHighLevelEvent: */
/* OBSOLETE       AEProcessAppleEvent (evt); */
/* OBSOLETE       break; */
/* OBSOLETE     case nullEvent: */
/* OBSOLETE       do_idle (); */
/* OBSOLETE       rslt = 1; */
/* OBSOLETE       break; */
/* OBSOLETE     default: */
/* OBSOLETE       break; */
/* OBSOLETE     } */
/* OBSOLETE   return rslt; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Do any idle-time activities. */ */
/* OBSOLETE  */
/* OBSOLETE do_idle (void) */
/* OBSOLETE { */
/* OBSOLETE   TEIdle (console_text); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE grow_window (WindowPtr win, Point where) */
/* OBSOLETE { */
/* OBSOLETE   long winsize; */
/* OBSOLETE   int h, v; */
/* OBSOLETE   GrafPtr oldport; */
/* OBSOLETE  */
/* OBSOLETE   winsize = GrowWindow (win, where, &sizerect); */
/* OBSOLETE   /* Only do anything if it actually changed size. */ */
/* OBSOLETE   if (winsize != 0) */
/* OBSOLETE     { */
/* OBSOLETE       GetPort (&oldport); */
/* OBSOLETE       SetPort (win); */
/* OBSOLETE       if (win == console_window) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  EraseRect (&win->portRect); */
/* OBSOLETE 	  h = LoWord (winsize); */
/* OBSOLETE 	  v = HiWord (winsize); */
/* OBSOLETE 	  SizeWindow (win, h, v, 1); */
/* OBSOLETE 	  resize_console_window (); */
/* OBSOLETE 	} */
/* OBSOLETE       SetPort (oldport); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE zoom_window (WindowPtr win, Point where, short part) */
/* OBSOLETE { */
/* OBSOLETE   ZoomWindow (win, part, (win == FrontWindow ())); */
/* OBSOLETE   if (win == console_window) */
/* OBSOLETE     { */
/* OBSOLETE       resize_console_window (); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE resize_console_window (void) */
/* OBSOLETE { */
/* OBSOLETE   adjust_console_sizes (); */
/* OBSOLETE   adjust_console_scrollbars (); */
/* OBSOLETE   adjust_console_text (); */
/* OBSOLETE   InvalRect (&console_window->portRect); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE close_window (WindowPtr win) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE pascal void */
/* OBSOLETE v_scroll_proc (ControlHandle control, short part) */
/* OBSOLETE { */
/* OBSOLETE   int oldval, amount = 0, newval; */
/* OBSOLETE   int pagesize = ((*console_text)->viewRect.bottom - (*console_text)->viewRect.top) / (*console_text)->lineHeight; */
/* OBSOLETE   if (part) */
/* OBSOLETE     { */
/* OBSOLETE       oldval = GetCtlValue (control); */
/* OBSOLETE       switch (part) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case inUpButton: */
/* OBSOLETE 	  amount = 1; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case inDownButton: */
/* OBSOLETE 	  amount = -1; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case inPageUp: */
/* OBSOLETE 	  amount = pagesize; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case inPageDown: */
/* OBSOLETE 	  amount = -pagesize; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	default: */
/* OBSOLETE 	  /* (should freak out) */ */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE       SetCtlValue (control, oldval - amount); */
/* OBSOLETE       newval = GetCtlValue (control); */
/* OBSOLETE       amount = oldval - newval; */
/* OBSOLETE       if (amount) */
/* OBSOLETE 	TEScroll (0, amount * (*console_text)->lineHeight, console_text); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE do_mouse_down (WindowPtr win, EventRecord * event) */
/* OBSOLETE { */
/* OBSOLETE   short part, value; */
/* OBSOLETE   Point mouse; */
/* OBSOLETE   ControlHandle control; */
/* OBSOLETE  */
/* OBSOLETE   if (1 /*is_app_window(win) */ ) */
/* OBSOLETE     { */
/* OBSOLETE       SetPort (win); */
/* OBSOLETE       mouse = event->where; */
/* OBSOLETE       GlobalToLocal (&mouse); */
/* OBSOLETE       part = FindControl (mouse, win, &control); */
/* OBSOLETE       if (control == console_v_scrollbar) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  switch (part) */
/* OBSOLETE 	    { */
/* OBSOLETE 	    case inThumb: */
/* OBSOLETE 	      value = GetCtlValue (control); */
/* OBSOLETE 	      part = TrackControl (control, mouse, nil); */
/* OBSOLETE 	      if (part) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  value -= GetCtlValue (control); */
/* OBSOLETE 		  if (value) */
/* OBSOLETE 		    TEScroll (0, value * (*console_text)->lineHeight, */
/* OBSOLETE 			      console_text); */
/* OBSOLETE 		} */
/* OBSOLETE 	      break; */
/* OBSOLETE 	    default: */
/* OBSOLETE #if 0				/* don't deal with right now */ */
/* OBSOLETE #if 1				/* universal headers */ */
/* OBSOLETE 	      value = TrackControl (control, mouse, (ControlActionUPP) v_scroll_proc); */
/* OBSOLETE #else */
/* OBSOLETE 	      value = TrackControl (control, mouse, (ProcPtr) v_scroll_proc); */
/* OBSOLETE #endif */
/* OBSOLETE #endif */
/* OBSOLETE 	      break; */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  TEClick (mouse, 0, console_text); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE scroll_text (int hlines, int vlines) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE activate_window (WindowPtr win, int activate) */
/* OBSOLETE { */
/* OBSOLETE   Rect grow_rect; */
/* OBSOLETE  */
/* OBSOLETE   if (win == nil) */
/* OBSOLETE     return; */
/* OBSOLETE   /* It's convenient to make the activated window also be the */
/* OBSOLETE      current GrafPort. */ */
/* OBSOLETE   if (activate) */
/* OBSOLETE     SetPort (win); */
/* OBSOLETE   /* Activate the console window's scrollbar. */ */
/* OBSOLETE   if (win == console_window) */
/* OBSOLETE     { */
/* OBSOLETE       if (activate) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  TEActivate (console_text); */
/* OBSOLETE 	  /* Cause the grow icon to be redrawn at the next update. */ */
/* OBSOLETE 	  grow_rect = console_window->portRect; */
/* OBSOLETE 	  grow_rect.top = grow_rect.bottom - sbarwid; */
/* OBSOLETE 	  grow_rect.left = grow_rect.right - sbarwid; */
/* OBSOLETE 	  InvalRect (&grow_rect); */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  TEDeactivate (console_text); */
/* OBSOLETE 	  DrawGrowIcon (console_window); */
/* OBSOLETE 	} */
/* OBSOLETE       HiliteControl (console_v_scrollbar, (activate ? 0 : 255)); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE update_window (WindowPtr win) */
/* OBSOLETE { */
/* OBSOLETE   int controls = 1, growbox = 0; */
/* OBSOLETE   GrafPtr oldport; */
/* OBSOLETE  */
/* OBSOLETE   /* Set the updating window to be the current grafport. */ */
/* OBSOLETE   GetPort (&oldport); */
/* OBSOLETE   SetPort (win); */
/* OBSOLETE /*  recalc_depths();  */ */
/* OBSOLETE   BeginUpdate (win); */
/* OBSOLETE   if (win == console_window) */
/* OBSOLETE     { */
/* OBSOLETE       draw_console (); */
/* OBSOLETE       controls = 1; */
/* OBSOLETE       growbox = 1; */
/* OBSOLETE     } */
/* OBSOLETE   if (controls) */
/* OBSOLETE     UpdateControls (win, win->visRgn); */
/* OBSOLETE   if (growbox) */
/* OBSOLETE     DrawGrowIcon (win); */
/* OBSOLETE   EndUpdate (win); */
/* OBSOLETE   SetPort (oldport); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE adjust_menus (void) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE do_menu_command (long which) */
/* OBSOLETE { */
/* OBSOLETE   short menuid, menuitem; */
/* OBSOLETE   short itemHit; */
/* OBSOLETE   Str255 daname; */
/* OBSOLETE   short daRefNum; */
/* OBSOLETE   Boolean handledbyda; */
/* OBSOLETE   WindowPtr win; */
/* OBSOLETE   short ditem; */
/* OBSOLETE   int i; */
/* OBSOLETE   char cmdbuf[300]; */
/* OBSOLETE  */
/* OBSOLETE   cmdbuf[0] = '\0'; */
/* OBSOLETE   menuid = HiWord (which); */
/* OBSOLETE   menuitem = LoWord (which); */
/* OBSOLETE   switch (menuid) */
/* OBSOLETE     { */
/* OBSOLETE     case mApple: */
/* OBSOLETE       switch (menuitem) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case miAbout: */
/* OBSOLETE 	  Alert (128, nil); */
/* OBSOLETE 	  break; */
/* OBSOLETE #if 0 */
/* OBSOLETE 	case miHelp: */
/* OBSOLETE 	  /* (should pop up help info) */ */
/* OBSOLETE 	  break; */
/* OBSOLETE #endif */
/* OBSOLETE 	default: */
/* OBSOLETE 	  GetItem (GetMHandle (mApple), menuitem, daname); */
/* OBSOLETE 	  daRefNum = OpenDeskAcc (daname); */
/* OBSOLETE 	} */
/* OBSOLETE       break; */
/* OBSOLETE     case mFile: */
/* OBSOLETE       switch (menuitem) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case miFileNew: */
/* OBSOLETE 	  if (console_window == FrontWindow ()) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      close_window (console_window); */
/* OBSOLETE 	    } */
/* OBSOLETE 	  new_console_window (); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case miFileOpen: */
/* OBSOLETE 	  SysBeep (20); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case miFileQuit: */
/* OBSOLETE 	  ExitToShell (); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE       break; */
/* OBSOLETE     case mEdit: */
/* OBSOLETE       /* handledbyda = SystemEdit(menuitem-1); */ */
/* OBSOLETE       switch (menuitem) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case miEditCut: */
/* OBSOLETE 	  TECut (console_text); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case miEditCopy: */
/* OBSOLETE 	  TECopy (console_text); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case miEditPaste: */
/* OBSOLETE 	  TEPaste (console_text); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case miEditClear: */
/* OBSOLETE 	  TEDelete (console_text); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE       /* All of these operations need the same postprocessing. */ */
/* OBSOLETE       adjust_console_sizes (); */
/* OBSOLETE       adjust_console_scrollbars (); */
/* OBSOLETE       adjust_console_text (); */
/* OBSOLETE       break; */
/* OBSOLETE     case mDebug: */
/* OBSOLETE       switch (menuitem) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case miDebugTarget: */
/* OBSOLETE 	  sprintf (cmdbuf, "target %s", "remote"); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case miDebugRun: */
/* OBSOLETE 	  sprintf (cmdbuf, "run"); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case miDebugContinue: */
/* OBSOLETE 	  sprintf (cmdbuf, "continue"); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case miDebugStep: */
/* OBSOLETE 	  sprintf (cmdbuf, "step"); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case miDebugNext: */
/* OBSOLETE 	  sprintf (cmdbuf, "next"); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE       break; */
/* OBSOLETE     } */
/* OBSOLETE   HiliteMenu (0); */
/* OBSOLETE   /* Execute a command if one had been given.  Do here because a command */
/* OBSOLETE      may longjmp before we get a chance to unhilite the menu. */ */
/* OBSOLETE   if (strlen (cmdbuf) > 0) */
/* OBSOLETE     execute_command (cmdbuf, 0); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE char commandbuf[1000]; */
/* OBSOLETE  */
/* OBSOLETE do_keyboard_command (int key) */
/* OBSOLETE { */
/* OBSOLETE   int startpos, endpos, i, len; */
/* OBSOLETE   char *last_newline; */
/* OBSOLETE   char buf[10], *text_str, *command, *cmd_start; */
/* OBSOLETE   CharsHandle text; */
/* OBSOLETE  */
/* OBSOLETE   if (key == '\015' || key == '\003') */
/* OBSOLETE     { */
/* OBSOLETE       text = TEGetText (console_text); */
/* OBSOLETE       HLock ((Handle) text); */
/* OBSOLETE       text_str = *text; */
/* OBSOLETE       startpos = (*console_text)->selStart; */
/* OBSOLETE       endpos = (*console_text)->selEnd; */
/* OBSOLETE       if (startpos != endpos) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  len = endpos - startpos; */
/* OBSOLETE 	  cmd_start = text_str + startpos; */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  for (i = startpos - 1; i >= 0; --i) */
/* OBSOLETE 	    if (text_str[i] == '\015') */
/* OBSOLETE 	      break; */
/* OBSOLETE 	  last_newline = text_str + i; */
/* OBSOLETE 	  len = (text_str + startpos) - 1 - last_newline; */
/* OBSOLETE 	  cmd_start = last_newline + 1; */
/* OBSOLETE 	} */
/* OBSOLETE       if (len > 1000) */
/* OBSOLETE 	len = 999; */
/* OBSOLETE       if (len < 0) */
/* OBSOLETE 	len = 0; */
/* OBSOLETE       strncpy (commandbuf + 1, cmd_start, len); */
/* OBSOLETE       commandbuf[1 + len] = 0; */
/* OBSOLETE       command = commandbuf + 1; */
/* OBSOLETE       HUnlock ((Handle) text); */
/* OBSOLETE       commandbuf[0] = strlen (command); */
/* OBSOLETE  */
/* OBSOLETE       /* Insert a newline and recalculate before doing any command. */ */
/* OBSOLETE       key = '\015'; */
/* OBSOLETE       TEKey (key, console_text); */
/* OBSOLETE       TEInsert (buf, 1, console_text); */
/* OBSOLETE       adjust_console_sizes (); */
/* OBSOLETE       adjust_console_scrollbars (); */
/* OBSOLETE       adjust_console_text (); */
/* OBSOLETE  */
/* OBSOLETE       if (strlen (command) > 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  execute_command (command, 0); */
/* OBSOLETE 	  bpstat_do_actions (&stop_bpstat); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       /* A self-inserting character.  This includes delete.  */ */
/* OBSOLETE       TEKey (key, console_text); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Draw all graphical stuff in the console window.  */ */
/* OBSOLETE  */
/* OBSOLETE draw_console (void) */
/* OBSOLETE { */
/* OBSOLETE   SetPort (console_window); */
/* OBSOLETE   TEUpdate (&(console_window->portRect), console_text); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Cause an update of a given window's entire contents.  */ */
/* OBSOLETE  */
/* OBSOLETE force_update (WindowPtr win) */
/* OBSOLETE { */
/* OBSOLETE   GrafPtr oldport; */
/* OBSOLETE  */
/* OBSOLETE   if (win == nil) */
/* OBSOLETE     return; */
/* OBSOLETE   GetPort (&oldport); */
/* OBSOLETE   SetPort (win); */
/* OBSOLETE   EraseRect (&win->portRect); */
/* OBSOLETE   InvalRect (&win->portRect); */
/* OBSOLETE   SetPort (oldport); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE adjust_console_sizes (void) */
/* OBSOLETE { */
/* OBSOLETE   Rect tmprect; */
/* OBSOLETE  */
/* OBSOLETE   tmprect = console_window->portRect; */
/* OBSOLETE   /* Move and size the scrollbar. */ */
/* OBSOLETE   MoveControl (console_v_scrollbar, tmprect.right - sbarwid, 0); */
/* OBSOLETE   SizeControl (console_v_scrollbar, sbarwid + 1, tmprect.bottom - sbarwid + 1); */
/* OBSOLETE   /* Move and size the text. */ */
/* OBSOLETE   tmprect.left += 7; */
/* OBSOLETE   tmprect.right -= sbarwid; */
/* OBSOLETE   tmprect.bottom -= sbarwid; */
/* OBSOLETE   InsetRect (&tmprect, 1, 1); */
/* OBSOLETE   (*console_text)->destRect = tmprect; */
/* OBSOLETE   /* Fiddle bottom of viewrect to be even multiple of text lines. */ */
/* OBSOLETE   tmprect.bottom = tmprect.top */
/* OBSOLETE     + ((tmprect.bottom - tmprect.top) / (*console_text)->lineHeight) */
/* OBSOLETE     * (*console_text)->lineHeight; */
/* OBSOLETE   (*console_text)->viewRect = tmprect; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE adjust_console_scrollbars (void) */
/* OBSOLETE { */
/* OBSOLETE   int lines, newmax, value; */
/* OBSOLETE  */
/* OBSOLETE   (*console_v_scrollbar)->contrlVis = 0; */
/* OBSOLETE   lines = (*console_text)->nLines; */
/* OBSOLETE   newmax = lines - (((*console_text)->viewRect.bottom */
/* OBSOLETE 		     - (*console_text)->viewRect.top) */
/* OBSOLETE 		    / (*console_text)->lineHeight); */
/* OBSOLETE   if (newmax < 0) */
/* OBSOLETE     newmax = 0; */
/* OBSOLETE   SetCtlMax (console_v_scrollbar, newmax); */
/* OBSOLETE   value = ((*console_text)->viewRect.top - (*console_text)->destRect.top) */
/* OBSOLETE     / (*console_text)->lineHeight; */
/* OBSOLETE   SetCtlValue (console_v_scrollbar, value); */
/* OBSOLETE   (*console_v_scrollbar)->contrlVis = 0xff; */
/* OBSOLETE   ShowControl (console_v_scrollbar); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Scroll the TE record so that it is consistent with the scrollbar(s). */ */
/* OBSOLETE  */
/* OBSOLETE adjust_console_text (void) */
/* OBSOLETE { */
/* OBSOLETE   TEScroll (((*console_text)->viewRect.left */
/* OBSOLETE 	     - (*console_text)->destRect.left) */
/* OBSOLETE 	    - 0 /* get h scroll value */ , */
/* OBSOLETE 	    ((((*console_text)->viewRect.top - (*console_text)->destRect.top) */
/* OBSOLETE 	      / (*console_text)->lineHeight) */
/* OBSOLETE 	     - GetCtlValue (console_v_scrollbar)) */
/* OBSOLETE 	    * (*console_text)->lineHeight, */
/* OBSOLETE 	    console_text); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Readline substitute. */ */
/* OBSOLETE  */
/* OBSOLETE char * */
/* OBSOLETE readline (char *prrompt) */
/* OBSOLETE { */
/* OBSOLETE   return gdb_readline (prrompt); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE char *rl_completer_word_break_characters; */
/* OBSOLETE  */
/* OBSOLETE char *rl_completer_quote_characters; */
/* OBSOLETE  */
/* OBSOLETE int (*rl_completion_entry_function) (); */
/* OBSOLETE  */
/* OBSOLETE int rl_point; */
/* OBSOLETE  */
/* OBSOLETE char *rl_line_buffer; */
/* OBSOLETE  */
/* OBSOLETE char *rl_readline_name; */
/* OBSOLETE  */
/* OBSOLETE /* History substitute. */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE add_history (char *buf) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE stifle_history (int n) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE unstifle_history (void) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE read_history (char *name) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE write_history (char *name) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE history_expand (char *x, char **y) */
/* OBSOLETE { */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE extern HIST_ENTRY * */
/* OBSOLETE history_get (int xxx) */
/* OBSOLETE { */
/* OBSOLETE   return NULL; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int history_base; */
/* OBSOLETE  */
/* OBSOLETE char * */
/* OBSOLETE filename_completion_function (char *text, char *name) */
/* OBSOLETE { */
/* OBSOLETE   return "?"; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE char * */
/* OBSOLETE tilde_expand (char *str) */
/* OBSOLETE { */
/* OBSOLETE   return xstrdup (str); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Modified versions of standard I/O. */ */
/* OBSOLETE  */
/* OBSOLETE #undef fprintf */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE hacked_fprintf (FILE * fp, const char *fmt,...) */
/* OBSOLETE { */
/* OBSOLETE   int ret; */
/* OBSOLETE   va_list ap; */
/* OBSOLETE  */
/* OBSOLETE   va_start (ap, fmt); */
/* OBSOLETE   if (mac_app && (fp == stdout || fp == stderr)) */
/* OBSOLETE     { */
/* OBSOLETE       char buf[1000]; */
/* OBSOLETE  */
/* OBSOLETE       ret = vsprintf (buf, fmt, ap); */
/* OBSOLETE       TEInsert (buf, strlen (buf), console_text); */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     ret = vfprintf (fp, fmt, ap); */
/* OBSOLETE   va_end (ap); */
/* OBSOLETE   return ret; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #undef printf */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE hacked_printf (const char *fmt,...) */
/* OBSOLETE { */
/* OBSOLETE   int ret; */
/* OBSOLETE   va_list ap; */
/* OBSOLETE  */
/* OBSOLETE   va_start (ap, fmt); */
/* OBSOLETE   ret = hacked_vfprintf (stdout, fmt, ap); */
/* OBSOLETE   va_end (ap); */
/* OBSOLETE   return ret; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #undef vfprintf */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE hacked_vfprintf (FILE * fp, const char *format, va_list args) */
/* OBSOLETE { */
/* OBSOLETE   if (mac_app && (fp == stdout || fp == stderr)) */
/* OBSOLETE     { */
/* OBSOLETE       char buf[1000]; */
/* OBSOLETE       int ret; */
/* OBSOLETE  */
/* OBSOLETE       ret = vsprintf (buf, format, args); */
/* OBSOLETE       TEInsert (buf, strlen (buf), console_text); */
/* OBSOLETE       if (strchr (buf, '\n')) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  adjust_console_sizes (); */
/* OBSOLETE 	  adjust_console_scrollbars (); */
/* OBSOLETE 	  adjust_console_text (); */
/* OBSOLETE 	} */
/* OBSOLETE       return ret; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     return vfprintf (fp, format, args); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #undef fputs */
/* OBSOLETE  */
/* OBSOLETE hacked_fputs (const char *s, FILE * fp) */
/* OBSOLETE { */
/* OBSOLETE   if (mac_app && (fp == stdout || fp == stderr)) */
/* OBSOLETE     { */
/* OBSOLETE       TEInsert (s, strlen (s), console_text); */
/* OBSOLETE       if (strchr (s, '\n')) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  adjust_console_sizes (); */
/* OBSOLETE 	  adjust_console_scrollbars (); */
/* OBSOLETE 	  adjust_console_text (); */
/* OBSOLETE 	} */
/* OBSOLETE       return 0; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     return fputs (s, fp); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #undef fputc */
/* OBSOLETE  */
/* OBSOLETE hacked_fputc (const char c, FILE * fp) */
/* OBSOLETE { */
/* OBSOLETE   if (mac_app && (fp == stdout || fp == stderr)) */
/* OBSOLETE     { */
/* OBSOLETE       char buf[1]; */
/* OBSOLETE  */
/* OBSOLETE       buf[0] = c; */
/* OBSOLETE       TEInsert (buf, 1, console_text); */
/* OBSOLETE       if (c == '\n') */
/* OBSOLETE 	{ */
/* OBSOLETE 	  adjust_console_sizes (); */
/* OBSOLETE 	  adjust_console_scrollbars (); */
/* OBSOLETE 	  adjust_console_text (); */
/* OBSOLETE 	} */
/* OBSOLETE       return c; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     return fputc (c, fp); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #undef putc */
/* OBSOLETE  */
/* OBSOLETE hacked_putc (const char c, FILE * fp) */
/* OBSOLETE { */
/* OBSOLETE   if (mac_app && (fp == stdout || fp == stderr)) */
/* OBSOLETE     { */
/* OBSOLETE       char buf[1]; */
/* OBSOLETE  */
/* OBSOLETE       buf[0] = c; */
/* OBSOLETE       TEInsert (buf, 1, console_text); */
/* OBSOLETE       if (c == '\n') */
/* OBSOLETE 	{ */
/* OBSOLETE 	  adjust_console_sizes (); */
/* OBSOLETE 	  adjust_console_scrollbars (); */
/* OBSOLETE 	  adjust_console_text (); */
/* OBSOLETE 	} */
/* OBSOLETE       return c; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     return fputc (c, fp); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #undef fflush */
/* OBSOLETE  */
/* OBSOLETE hacked_fflush (FILE * fp) */
/* OBSOLETE { */
/* OBSOLETE   if (mac_app && (fp == stdout || fp == stderr)) */
/* OBSOLETE     { */
/* OBSOLETE       adjust_console_sizes (); */
/* OBSOLETE       adjust_console_scrollbars (); */
/* OBSOLETE       adjust_console_text (); */
/* OBSOLETE       return 0; */
/* OBSOLETE     } */
/* OBSOLETE   return fflush (fp); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #undef fgetc */
/* OBSOLETE  */
/* OBSOLETE hacked_fgetc (FILE * fp) */
/* OBSOLETE { */
/* OBSOLETE   if (mac_app && (fp == stdin)) */
/* OBSOLETE     { */
/* OBSOLETE       /* Catch any attempts to use this.  */ */
/* OBSOLETE       DebugStr ("\pShould not be reading from stdin!"); */
/* OBSOLETE       return '\n'; */
/* OBSOLETE     } */
/* OBSOLETE   return fgetc (fp); */
/* OBSOLETE } */
@


1.6
log
@Obsolete MPW as host.
@
text
@@


1.5
log
@Update/correct copyright notices.
@
text
@d1 1082
a1082 1082
/* Top level support for Mac interface to GDB, the GNU debugger.
   Copyright 1994, 1995, 1998, 2000, 2001 Free Software Foundation, Inc.
   Contributed by Cygnus Support.  Written by Stan Shebs.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"

#include <readline/readline.h>
#include <readline/history.h>

#include <Types.h>
#include <Resources.h>
#include <QuickDraw.h>
#include <Fonts.h>
#include <Events.h>
#include <Windows.h>
#include <Menus.h>
#include <TextEdit.h>
#include <Dialogs.h>
#include <Desk.h>
#include <ToolUtils.h>
#include <Memory.h>
#include <SegLoad.h>
#include <Files.h>
#include <Folders.h>
#include <OSUtils.h>
#include <OSEvents.h>
#include <DiskInit.h>
#include <Packages.h>
#include <Traps.h>
#include <Lists.h>
#include <Gestalt.h>
#include <PPCToolbox.h>
#include <AppleEvents.h>
#include <StandardFile.h>
#include <Sound.h>

#ifdef MPW
#define QD(whatever) (qd.##whatever)
#define QDPat(whatever) (&(qd.##whatever))
#endif /* MPW */

#ifdef THINK_C
#define QD(whatever) (whatever)
#endif

#define p2c(pstr,cbuf)  \
  strncpy(cbuf, ((char *) (pstr) + 1), pstr[0]);  \
  cbuf[pstr[0]] = '\0';

#define pascalify(STR) \
  sprintf(tmpbuf, " %s", STR);  \
  tmpbuf[0] = strlen(STR);

#include "gdbcmd.h"
#include "call-cmds.h"
#include "symtab.h"
#include "inferior.h"
#include <signal.h>
#include "target.h"
#include "breakpoint.h"
#include "gdbtypes.h"
#include "expression.h"
#include "language.h"

#include "mac-defs.h"

int debug_openp = 0;

/* This is true if we are running as a standalone application.  */

int mac_app;

/* This is true if we are using WaitNextEvent.  */

int use_wne;

/* This is true if we have Color Quickdraw.  */

int has_color_qd;

/* This is true if we are using Color Quickdraw. */

int use_color_qd;

int inbackground;

Rect dragrect =
{-32000, -32000, 32000, 32000};
Rect sizerect;

int sbarwid = 15;

/* Globals for the console window. */

WindowPtr console_window;

ControlHandle console_v_scrollbar;

Rect console_v_scroll_rect;

TEHandle console_text;

Rect console_text_rect;

/* This will go away eventually. */
gdb_has_a_terminal (void)
{
  return 1;
}

mac_init (void)
{
  SysEnvRec se;
  int eventloopdone = 0;
  char *str;
  Boolean gotevent;
  Point mouse;
  EventRecord event;
  WindowPtr win;
  RgnHandle cursorRgn;
  int i;
  Handle menubar;
  MenuHandle menu;
  Handle siow_resource;

  mac_app = 0;

  str = getenv ("DEBUG_GDB");
  if (str != NULL && str[0] != '\0')
    {
      if (strcmp (str, "openp") == 0)
	debug_openp = 1;
    }

  /* Don't do anything if we`re running under MPW. */
  if (!StandAlone)
    return;

  /* Don't do anything if we're using SIOW. */
  /* This test requires that the siow 0 resource, as defined in
     {RIncludes}siow.r, not be messed with.  If it is, then the
     standard Mac setup below will step on SIOW's Mac setup and
     most likely crash the machine. */
  siow_resource = GetResource ('siow', 0);
  if (siow_resource != nil)
    return;

  mac_app = 1;

  /* Do the standard Mac environment setup. */
  InitGraf (&QD (thePort));
  InitFonts ();
  FlushEvents (everyEvent, 0);
  InitWindows ();
  InitMenus ();
  TEInit ();
  InitDialogs (NULL);
  InitCursor ();

  /* Color Quickdraw is different from Classic QD. */
  SysEnvirons (2, &se);
  has_color_qd = se.hasColorQD;
  /* Use it if we got it. */
  use_color_qd = has_color_qd;

  sizerect.top = 50;
  sizerect.left = 50;
  sizerect.bottom = 1000;
  sizerect.right = 1000;
#if 0
  sizerect.bottom = screenBits.bounds.bottom - screenBits.bounds.top;
  sizerect.right = screenBits.bounds.right - screenBits.bounds.left;
#endif

  /* Set up the menus. */
  menubar = GetNewMBar (mbMain);
  SetMenuBar (menubar);
  /* Add the DAs etc as usual. */
  menu = GetMHandle (mApple);
  if (menu != nil)
    {
      AddResMenu (menu, 'DRVR');
    }
  DrawMenuBar ();

  new_console_window ();
}

new_console_window (void)
{
  /* Create the main window we're going to play in. */
  if (has_color_qd)
    console_window = GetNewCWindow (wConsole, NULL, (WindowPtr) - 1L);
  else
    console_window = GetNewWindow (wConsole, NULL, (WindowPtr) - 1L);

  SetPort (console_window);
  console_text_rect = console_window->portRect;
  /* Leave 8 pixels of blank space, for aesthetic reasons and to
     make it easier to select from the beginning of a line. */
  console_text_rect.left += 8;
  console_text_rect.bottom -= sbarwid - 1;
  console_text_rect.right -= sbarwid - 1;
  console_text = TENew (&console_text_rect, &console_text_rect);
  TESetSelect (0, 40000, console_text);
  TEDelete (console_text);
  TEAutoView (1, console_text);

  console_v_scroll_rect = console_window->portRect;
  console_v_scroll_rect.bottom -= sbarwid - 1;
  console_v_scroll_rect.left = console_v_scroll_rect.right - sbarwid;
  console_v_scrollbar =
    NewControl (console_window, &console_v_scroll_rect,
		"\p", 1, 0, 0, 0, scrollBarProc, 0L);

  ShowWindow (console_window);
  SelectWindow (console_window);
}

mac_command_loop (void)
{
  SysEnvRec se;
  int eventloopdone = 0;
  Boolean gotevent;
  Point mouse;
  EventRecord event;
  WindowPtr win;
  RgnHandle cursorRgn;
  int i, tm;
  Handle menubar;
  MenuHandle menu;

  /* Figure out if the WaitNextEvent Trap is available.  */
  use_wne =
    (NGetTrapAddress (0x60, ToolTrap) != NGetTrapAddress (0x9f, ToolTrap));
  /* Pass WaitNextEvent an empty region the first time through.  */
  cursorRgn = NewRgn ();
  /* Go into the main event-handling loop.  */
  while (!eventloopdone)
    {
      /* Use WaitNextEvent if it is available, otherwise GetNextEvent.  */
      if (use_wne)
	{
	  get_global_mouse (&mouse);
	  adjust_cursor (mouse, cursorRgn);
	  tm = GetCaretTime ();
	  gotevent = WaitNextEvent (everyEvent, &event, tm, cursorRgn);
	}
      else
	{
	  SystemTask ();
	  gotevent = GetNextEvent (everyEvent, &event);
	}
      /* First decide if the event is for a dialog or is just any old event. */
      if (FrontWindow () != nil && IsDialogEvent (&event))
	{
	  short itemhit;
	  DialogPtr dialog;

	  /* Handle all the modeless dialogs here. */
	  if (DialogSelect (&event, &dialog, &itemhit))
	    {
	    }
	}
      else if (gotevent)
	{
	  /* Make sure we have the right cursor before handling the event. */
	  adjust_cursor (event.where, cursorRgn);
	  do_event (&event);
	}
      else
	{
	  do_idle ();
	}
    }
}

/* Collect the global coordinates of the mouse pointer.  */

get_global_mouse (Point *mouse)
{
  EventRecord evt;

  OSEventAvail (0, &evt);
  *mouse = evt.where;
}

/* Change the cursor's appearance to be appropriate for the given mouse
   location.  */

adjust_cursor (Point mouse, RgnHandle region)
{
}

/* Decipher an event, maybe do something with it.  */

do_event (EventRecord *evt)
{
  short part, err, rslt = 0;
  WindowPtr win;
  Boolean hit;
  char key;
  Point pnt;

  switch (evt->what)
    {
    case mouseDown:
      /* See if the click happened in a special part of the screen. */
      part = FindWindow (evt->where, &win);
      switch (part)
	{
	case inMenuBar:
	  adjust_menus ();
	  do_menu_command (MenuSelect (evt->where));
	  break;
	case inSysWindow:
	  SystemClick (evt, win);
	  break;
	case inContent:
	  if (win != FrontWindow ())
	    {
	      /* Bring the clicked-on window to the front. */
	      SelectWindow (win);
	      /* Fix the menu to match the new front window. */
	      adjust_menus ();
	      /* We always want to discard the event now, since clicks in a
	         windows are often irreversible actions. */
	    }
	  else
	    /* Mouse clicks in the front window do something useful. */
	    do_mouse_down (win, evt);
	  break;
	case inDrag:
	  /* Standard drag behavior, no tricks necessary. */
	  DragWindow (win, evt->where, &dragrect);
	  break;
	case inGrow:
	  grow_window (win, evt->where);
	  break;
	case inZoomIn:
	case inZoomOut:
	  zoom_window (win, evt->where, part);
	  break;
	case inGoAway:
	  close_window (win);
	  break;
	}
      break;
    case keyDown:
    case autoKey:
      key = evt->message & charCodeMask;
      /* Check for menukey equivalents. */
      if (evt->modifiers & cmdKey)
	{
	  if (evt->what == keyDown)
	    {
	      adjust_menus ();
	      do_menu_command (MenuKey (key));
	    }
	}
      else
	{
	  if (evt->what == keyDown)
	    {
	      /* Random keypress, interpret it. */
	      do_keyboard_command (key);
	    }
	}
      break;
    case activateEvt:
      activate_window ((WindowPtr) evt->message, evt->modifiers & activeFlag);
      break;
    case updateEvt:
      update_window ((WindowPtr) evt->message);
      break;
    case diskEvt:
      /* Call DIBadMount in response to a diskEvt, so that the user can format
         a floppy. (from DTS Sample) */
      if (HiWord (evt->message) != noErr)
	{
	  SetPt (&pnt, 50, 50);
	  err = DIBadMount (pnt, evt->message);
	}
      break;
    case app4Evt:
      /* Grab only a single byte. */
      switch ((evt->message >> 24) & 0xFF)
	{
	case 0xfa:
	  break;
	case 1:
	  inbackground = !(evt->message & 1);
	  activate_window (FrontWindow (), !inbackground);
	  break;
	}
      break;
    case kHighLevelEvent:
      AEProcessAppleEvent (evt);
      break;
    case nullEvent:
      do_idle ();
      rslt = 1;
      break;
    default:
      break;
    }
  return rslt;
}

/* Do any idle-time activities. */

do_idle (void)
{
  TEIdle (console_text);
}

grow_window (WindowPtr win, Point where)
{
  long winsize;
  int h, v;
  GrafPtr oldport;

  winsize = GrowWindow (win, where, &sizerect);
  /* Only do anything if it actually changed size. */
  if (winsize != 0)
    {
      GetPort (&oldport);
      SetPort (win);
      if (win == console_window)
	{
	  EraseRect (&win->portRect);
	  h = LoWord (winsize);
	  v = HiWord (winsize);
	  SizeWindow (win, h, v, 1);
	  resize_console_window ();
	}
      SetPort (oldport);
    }
}

zoom_window (WindowPtr win, Point where, short part)
{
  ZoomWindow (win, part, (win == FrontWindow ()));
  if (win == console_window)
    {
      resize_console_window ();
    }
}

resize_console_window (void)
{
  adjust_console_sizes ();
  adjust_console_scrollbars ();
  adjust_console_text ();
  InvalRect (&console_window->portRect);
}

close_window (WindowPtr win)
{
}

pascal void
v_scroll_proc (ControlHandle control, short part)
{
  int oldval, amount = 0, newval;
  int pagesize = ((*console_text)->viewRect.bottom - (*console_text)->viewRect.top) / (*console_text)->lineHeight;
  if (part)
    {
      oldval = GetCtlValue (control);
      switch (part)
	{
	case inUpButton:
	  amount = 1;
	  break;
	case inDownButton:
	  amount = -1;
	  break;
	case inPageUp:
	  amount = pagesize;
	  break;
	case inPageDown:
	  amount = -pagesize;
	  break;
	default:
	  /* (should freak out) */
	  break;
	}
      SetCtlValue (control, oldval - amount);
      newval = GetCtlValue (control);
      amount = oldval - newval;
      if (amount)
	TEScroll (0, amount * (*console_text)->lineHeight, console_text);
    }
}

do_mouse_down (WindowPtr win, EventRecord * event)
{
  short part, value;
  Point mouse;
  ControlHandle control;

  if (1 /*is_app_window(win) */ )
    {
      SetPort (win);
      mouse = event->where;
      GlobalToLocal (&mouse);
      part = FindControl (mouse, win, &control);
      if (control == console_v_scrollbar)
	{
	  switch (part)
	    {
	    case inThumb:
	      value = GetCtlValue (control);
	      part = TrackControl (control, mouse, nil);
	      if (part)
		{
		  value -= GetCtlValue (control);
		  if (value)
		    TEScroll (0, value * (*console_text)->lineHeight,
			      console_text);
		}
	      break;
	    default:
#if 0				/* don't deal with right now */
#if 1				/* universal headers */
	      value = TrackControl (control, mouse, (ControlActionUPP) v_scroll_proc);
#else
	      value = TrackControl (control, mouse, (ProcPtr) v_scroll_proc);
#endif
#endif
	      break;
	    }
	}
      else
	{
	  TEClick (mouse, 0, console_text);
	}
    }
}

scroll_text (int hlines, int vlines)
{
}

activate_window (WindowPtr win, int activate)
{
  Rect grow_rect;

  if (win == nil)
    return;
  /* It's convenient to make the activated window also be the
     current GrafPort. */
  if (activate)
    SetPort (win);
  /* Activate the console window's scrollbar. */
  if (win == console_window)
    {
      if (activate)
	{
	  TEActivate (console_text);
	  /* Cause the grow icon to be redrawn at the next update. */
	  grow_rect = console_window->portRect;
	  grow_rect.top = grow_rect.bottom - sbarwid;
	  grow_rect.left = grow_rect.right - sbarwid;
	  InvalRect (&grow_rect);
	}
      else
	{
	  TEDeactivate (console_text);
	  DrawGrowIcon (console_window);
	}
      HiliteControl (console_v_scrollbar, (activate ? 0 : 255));
    }
}

update_window (WindowPtr win)
{
  int controls = 1, growbox = 0;
  GrafPtr oldport;

  /* Set the updating window to be the current grafport. */
  GetPort (&oldport);
  SetPort (win);
/*  recalc_depths();  */
  BeginUpdate (win);
  if (win == console_window)
    {
      draw_console ();
      controls = 1;
      growbox = 1;
    }
  if (controls)
    UpdateControls (win, win->visRgn);
  if (growbox)
    DrawGrowIcon (win);
  EndUpdate (win);
  SetPort (oldport);
}

adjust_menus (void)
{
}

do_menu_command (long which)
{
  short menuid, menuitem;
  short itemHit;
  Str255 daname;
  short daRefNum;
  Boolean handledbyda;
  WindowPtr win;
  short ditem;
  int i;
  char cmdbuf[300];

  cmdbuf[0] = '\0';
  menuid = HiWord (which);
  menuitem = LoWord (which);
  switch (menuid)
    {
    case mApple:
      switch (menuitem)
	{
	case miAbout:
	  Alert (128, nil);
	  break;
#if 0
	case miHelp:
	  /* (should pop up help info) */
	  break;
#endif
	default:
	  GetItem (GetMHandle (mApple), menuitem, daname);
	  daRefNum = OpenDeskAcc (daname);
	}
      break;
    case mFile:
      switch (menuitem)
	{
	case miFileNew:
	  if (console_window == FrontWindow ())
	    {
	      close_window (console_window);
	    }
	  new_console_window ();
	  break;
	case miFileOpen:
	  SysBeep (20);
	  break;
	case miFileQuit:
	  ExitToShell ();
	  break;
	}
      break;
    case mEdit:
      /* handledbyda = SystemEdit(menuitem-1); */
      switch (menuitem)
	{
	case miEditCut:
	  TECut (console_text);
	  break;
	case miEditCopy:
	  TECopy (console_text);
	  break;
	case miEditPaste:
	  TEPaste (console_text);
	  break;
	case miEditClear:
	  TEDelete (console_text);
	  break;
	}
      /* All of these operations need the same postprocessing. */
      adjust_console_sizes ();
      adjust_console_scrollbars ();
      adjust_console_text ();
      break;
    case mDebug:
      switch (menuitem)
	{
	case miDebugTarget:
	  sprintf (cmdbuf, "target %s", "remote");
	  break;
	case miDebugRun:
	  sprintf (cmdbuf, "run");
	  break;
	case miDebugContinue:
	  sprintf (cmdbuf, "continue");
	  break;
	case miDebugStep:
	  sprintf (cmdbuf, "step");
	  break;
	case miDebugNext:
	  sprintf (cmdbuf, "next");
	  break;
	}
      break;
    }
  HiliteMenu (0);
  /* Execute a command if one had been given.  Do here because a command
     may longjmp before we get a chance to unhilite the menu. */
  if (strlen (cmdbuf) > 0)
    execute_command (cmdbuf, 0);
}

char commandbuf[1000];

do_keyboard_command (int key)
{
  int startpos, endpos, i, len;
  char *last_newline;
  char buf[10], *text_str, *command, *cmd_start;
  CharsHandle text;

  if (key == '\015' || key == '\003')
    {
      text = TEGetText (console_text);
      HLock ((Handle) text);
      text_str = *text;
      startpos = (*console_text)->selStart;
      endpos = (*console_text)->selEnd;
      if (startpos != endpos)
	{
	  len = endpos - startpos;
	  cmd_start = text_str + startpos;
	}
      else
	{
	  for (i = startpos - 1; i >= 0; --i)
	    if (text_str[i] == '\015')
	      break;
	  last_newline = text_str + i;
	  len = (text_str + startpos) - 1 - last_newline;
	  cmd_start = last_newline + 1;
	}
      if (len > 1000)
	len = 999;
      if (len < 0)
	len = 0;
      strncpy (commandbuf + 1, cmd_start, len);
      commandbuf[1 + len] = 0;
      command = commandbuf + 1;
      HUnlock ((Handle) text);
      commandbuf[0] = strlen (command);

      /* Insert a newline and recalculate before doing any command. */
      key = '\015';
      TEKey (key, console_text);
      TEInsert (buf, 1, console_text);
      adjust_console_sizes ();
      adjust_console_scrollbars ();
      adjust_console_text ();

      if (strlen (command) > 0)
	{
	  execute_command (command, 0);
	  bpstat_do_actions (&stop_bpstat);
	}
    }
  else
    {
      /* A self-inserting character.  This includes delete.  */
      TEKey (key, console_text);
    }
}

/* Draw all graphical stuff in the console window.  */

draw_console (void)
{
  SetPort (console_window);
  TEUpdate (&(console_window->portRect), console_text);
}

/* Cause an update of a given window's entire contents.  */

force_update (WindowPtr win)
{
  GrafPtr oldport;

  if (win == nil)
    return;
  GetPort (&oldport);
  SetPort (win);
  EraseRect (&win->portRect);
  InvalRect (&win->portRect);
  SetPort (oldport);
}

adjust_console_sizes (void)
{
  Rect tmprect;

  tmprect = console_window->portRect;
  /* Move and size the scrollbar. */
  MoveControl (console_v_scrollbar, tmprect.right - sbarwid, 0);
  SizeControl (console_v_scrollbar, sbarwid + 1, tmprect.bottom - sbarwid + 1);
  /* Move and size the text. */
  tmprect.left += 7;
  tmprect.right -= sbarwid;
  tmprect.bottom -= sbarwid;
  InsetRect (&tmprect, 1, 1);
  (*console_text)->destRect = tmprect;
  /* Fiddle bottom of viewrect to be even multiple of text lines. */
  tmprect.bottom = tmprect.top
    + ((tmprect.bottom - tmprect.top) / (*console_text)->lineHeight)
    * (*console_text)->lineHeight;
  (*console_text)->viewRect = tmprect;
}

adjust_console_scrollbars (void)
{
  int lines, newmax, value;

  (*console_v_scrollbar)->contrlVis = 0;
  lines = (*console_text)->nLines;
  newmax = lines - (((*console_text)->viewRect.bottom
		     - (*console_text)->viewRect.top)
		    / (*console_text)->lineHeight);
  if (newmax < 0)
    newmax = 0;
  SetCtlMax (console_v_scrollbar, newmax);
  value = ((*console_text)->viewRect.top - (*console_text)->destRect.top)
    / (*console_text)->lineHeight;
  SetCtlValue (console_v_scrollbar, value);
  (*console_v_scrollbar)->contrlVis = 0xff;
  ShowControl (console_v_scrollbar);
}

/* Scroll the TE record so that it is consistent with the scrollbar(s). */

adjust_console_text (void)
{
  TEScroll (((*console_text)->viewRect.left
	     - (*console_text)->destRect.left)
	    - 0 /* get h scroll value */ ,
	    ((((*console_text)->viewRect.top - (*console_text)->destRect.top)
	      / (*console_text)->lineHeight)
	     - GetCtlValue (console_v_scrollbar))
	    * (*console_text)->lineHeight,
	    console_text);
}

/* Readline substitute. */

char *
readline (char *prrompt)
{
  return gdb_readline (prrompt);
}

char *rl_completer_word_break_characters;

char *rl_completer_quote_characters;

int (*rl_completion_entry_function) ();

int rl_point;

char *rl_line_buffer;

char *rl_readline_name;

/* History substitute. */

void
add_history (char *buf)
{
}

void
stifle_history (int n)
{
}

int
unstifle_history (void)
{
}

int
read_history (char *name)
{
}

int
write_history (char *name)
{
}

int
history_expand (char *x, char **y)
{
}

extern HIST_ENTRY *
history_get (int xxx)
{
  return NULL;
}

int history_base;

char *
filename_completion_function (char *text, char *name)
{
  return "?";
}

char *
tilde_expand (char *str)
{
  return xstrdup (str);
}

/* Modified versions of standard I/O. */

#undef fprintf

int
hacked_fprintf (FILE * fp, const char *fmt,...)
{
  int ret;
  va_list ap;

  va_start (ap, fmt);
  if (mac_app && (fp == stdout || fp == stderr))
    {
      char buf[1000];

      ret = vsprintf (buf, fmt, ap);
      TEInsert (buf, strlen (buf), console_text);
    }
  else
    ret = vfprintf (fp, fmt, ap);
  va_end (ap);
  return ret;
}

#undef printf

int
hacked_printf (const char *fmt,...)
{
  int ret;
  va_list ap;

  va_start (ap, fmt);
  ret = hacked_vfprintf (stdout, fmt, ap);
  va_end (ap);
  return ret;
}

#undef vfprintf

int
hacked_vfprintf (FILE * fp, const char *format, va_list args)
{
  if (mac_app && (fp == stdout || fp == stderr))
    {
      char buf[1000];
      int ret;

      ret = vsprintf (buf, format, args);
      TEInsert (buf, strlen (buf), console_text);
      if (strchr (buf, '\n'))
	{
	  adjust_console_sizes ();
	  adjust_console_scrollbars ();
	  adjust_console_text ();
	}
      return ret;
    }
  else
    return vfprintf (fp, format, args);
}

#undef fputs

hacked_fputs (const char *s, FILE * fp)
{
  if (mac_app && (fp == stdout || fp == stderr))
    {
      TEInsert (s, strlen (s), console_text);
      if (strchr (s, '\n'))
	{
	  adjust_console_sizes ();
	  adjust_console_scrollbars ();
	  adjust_console_text ();
	}
      return 0;
    }
  else
    return fputs (s, fp);
}

#undef fputc

hacked_fputc (const char c, FILE * fp)
{
  if (mac_app && (fp == stdout || fp == stderr))
    {
      char buf[1];

      buf[0] = c;
      TEInsert (buf, 1, console_text);
      if (c == '\n')
	{
	  adjust_console_sizes ();
	  adjust_console_scrollbars ();
	  adjust_console_text ();
	}
      return c;
    }
  else
    return fputc (c, fp);
}

#undef putc

hacked_putc (const char c, FILE * fp)
{
  if (mac_app && (fp == stdout || fp == stderr))
    {
      char buf[1];

      buf[0] = c;
      TEInsert (buf, 1, console_text);
      if (c == '\n')
	{
	  adjust_console_sizes ();
	  adjust_console_scrollbars ();
	  adjust_console_text ();
	}
      return c;
    }
  else
    return fputc (c, fp);
}

#undef fflush

hacked_fflush (FILE * fp)
{
  if (mac_app && (fp == stdout || fp == stderr))
    {
      adjust_console_sizes ();
      adjust_console_scrollbars ();
      adjust_console_text ();
      return 0;
    }
  return fflush (fp);
}

#undef fgetc

hacked_fgetc (FILE * fp)
{
  if (mac_app && (fp == stdin))
    {
      /* Catch any attempts to use this.  */
      DebugStr ("\pShould not be reading from stdin!");
      return '\n';
    }
  return fgetc (fp);
}
@


1.4
log
@* signals.h: Removed.
* event-top.c (#include <signal.h>): Changed from signals.h.
* inflow.c: Likewise.
* mac-xdep.c: Likewise.
* ser-pipe.c: Likewise.
* ser-tcp.c: Likewise.
* standalone.c: Likewise.
* top.c: Likewise.
* utils.c: Likewise.
* Makefile.in: Removed signals.h from dependencies.
@
text
@d2 1
a2 1
   Copyright 1994, 2001 Free Software Foundation, Inc.
@


1.3
log
@Replace strsave() with xstrdup().
@
text
@d75 1
a75 1
#include "signals.h"
@


1.2
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 1994 Free Software Foundation, Inc.
d929 1
a929 1
  return strsave (str);
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d104 2
a105 1
Rect dragrect = { -32000, -32000, 32000, 32000 };
d123 4
a126 1
gdb_has_a_terminal () { return 1; }
d128 1
a128 1
mac_init ()
d145 1
a145 1
  str = getenv("DEBUG_GDB");
d148 1
a148 1
      if (strcmp(str, "openp") == 0)
d151 1
a151 1
  
d161 1
a161 1
  siow_resource = GetResource('siow', 0);
d178 1
a178 1
  SysEnvirons(2, &se);
d186 1
a186 1
  sizerect.right  = 1000;
d189 1
a189 1
  sizerect.right  = screenBits.bounds.right  - screenBits.bounds.left;
d197 4
a200 3
  if (menu != nil) {
    AddResMenu (menu, 'DRVR');
  }
d206 1
a206 1
new_console_window ()
d210 1
a210 1
    console_window = GetNewCWindow (wConsole, NULL, (WindowPtr) -1L);
d212 1
a212 1
    console_window = GetNewWindow (wConsole, NULL, (WindowPtr) -1L);
d237 1
a237 1
mac_command_loop()
d263 1
a263 1
	  tm = GetCaretTime();
d276 1
a276 1
      
d297 1
a297 2
get_global_mouse (mouse)
Point *mouse;
d300 1
a300 1
	
d308 1
a308 3
adjust_cursor (mouse, region)
Point mouse;
RgnHandle region;
d314 1
a314 2
do_event (evt)
EventRecord *evt;
d344 5
a348 4
		 windows are often irreversible actions. */
	    } else
	      /* Mouse clicks in the front window do something useful. */
	      do_mouse_down (win, evt);
d395 1
a395 1
	 a floppy. (from DTS Sample) */
d429 1
a429 1
do_idle ()
d434 1
a434 3
grow_window (win, where)
WindowPtr win;
Point where;
d458 1
a458 4
zoom_window (win, where, part)
WindowPtr win;
Point where;
short part;
d467 1
a467 1
resize_console_window ()
d475 1
a475 2
close_window (win)
WindowPtr win;
d499 1
a499 1
	  amount = - pagesize;
d505 1
a505 1
      SetCtlValue(control, oldval - amount);
d513 1
a513 1
do_mouse_down (WindowPtr win, EventRecord *event)
d519 1
a519 1
  if (1 /*is_app_window(win)*/)
d524 1
a524 1
      part = FindControl(mouse, win, &control);
d536 2
a537 2
		    TEScroll(0, value * (*console_text)->lineHeight,
			     console_text);
d541 2
a542 2
#if 0 /* don't deal with right now */
#if 1 /* universal headers */
d558 1
a558 2
scroll_text (hlines, vlines)
int hlines, vlines;
d562 1
a562 3
activate_window (win, activate)
WindowPtr win;
int activate;
d566 2
a567 1
  if (win == nil) return;
d571 1
a571 1
    SetPort(win);
d593 1
a593 2
update_window (win)
WindowPtr win;
d617 1
a617 1
adjust_menus ()
d621 1
a621 2
do_menu_command (which)
long which;
d724 1
a724 2
do_keyboard_command (key)
int key;
d752 4
a755 2
      if (len > 1000) len = 999;
      if (len < 0) len = 0;
d760 1
a760 1
      commandbuf[0] = strlen(command);
d785 1
a785 1
draw_console ()
d793 1
a793 2
force_update (win)
WindowPtr win;
d797 2
a798 1
  if (win == nil) return;
d806 1
a806 1
adjust_console_sizes ()
d818 1
a818 1
  InsetRect(&tmprect, 1, 1);
d823 1
a823 1
      * (*console_text)->lineHeight;
d827 1
a827 1
adjust_console_scrollbars ()
d836 2
a837 1
  if (newmax < 0) newmax = 0;
d848 1
a848 1
adjust_console_text ()
d852 1
a852 1
	    - 0 /* get h scroll value */,
d893 1
a893 1
unstifle_history ()
d937 1
a937 1
hacked_fprintf (FILE *fp, const char *fmt, ...)
d947 2
a948 2
      ret = vsprintf(buf, fmt, ap);
      TEInsert (buf, strlen(buf), console_text);
d959 1
a959 1
hacked_printf (const char *fmt, ...)
d965 1
a965 1
  ret = hacked_vfprintf(stdout, fmt, ap);
d972 2
a973 2
int 
hacked_vfprintf (FILE *fp, const char *format, va_list args)
d980 3
a982 3
      ret = vsprintf(buf, format, args);
      TEInsert (buf, strlen(buf), console_text);
      if (strchr(buf, '\n'))
d996 1
a996 1
hacked_fputs (const char *s, FILE *fp)
d1000 2
a1001 2
      TEInsert (s, strlen(s), console_text);
      if (strchr(s, '\n'))
d1015 1
a1015 1
hacked_fputc (const char c, FILE *fp)
d1037 1
a1037 1
hacked_putc (const char c, FILE *fp)
d1059 1
a1059 1
hacked_fflush (FILE *fp)
d1073 1
a1073 1
hacked_fgetc (FILE *fp)
d1078 1
a1078 1
      DebugStr("\pShould not be reading from stdin!");
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d103 1
a103 2
Rect dragrect =
{-32000, -32000, 32000, 32000};
d121 1
a121 4
gdb_has_a_terminal ()
{
  return 1;
}
d140 1
a140 1
  str = getenv ("DEBUG_GDB");
d143 1
a143 1
      if (strcmp (str, "openp") == 0)
d146 1
a146 1

d156 1
a156 1
  siow_resource = GetResource ('siow', 0);
d173 1
a173 1
  SysEnvirons (2, &se);
d181 1
a181 1
  sizerect.right = 1000;
d184 1
a184 1
  sizerect.right = screenBits.bounds.right - screenBits.bounds.left;
d192 3
a194 4
  if (menu != nil)
    {
      AddResMenu (menu, 'DRVR');
    }
d204 1
a204 1
    console_window = GetNewCWindow (wConsole, NULL, (WindowPtr) - 1L);
d206 1
a206 1
    console_window = GetNewWindow (wConsole, NULL, (WindowPtr) - 1L);
d231 1
a231 1
mac_command_loop ()
d257 1
a257 1
	  tm = GetCaretTime ();
d270 1
a270 1

d292 1
a292 1
     Point *mouse;
d295 1
a295 1

d304 2
a305 2
     Point mouse;
     RgnHandle region;
d312 1
a312 1
     EventRecord *evt;
d342 4
a345 5
	         windows are often irreversible actions. */
	    }
	  else
	    /* Mouse clicks in the front window do something useful. */
	    do_mouse_down (win, evt);
d392 1
a392 1
         a floppy. (from DTS Sample) */
d432 2
a433 2
     WindowPtr win;
     Point where;
d458 3
a460 3
     WindowPtr win;
     Point where;
     short part;
d478 1
a478 1
     WindowPtr win;
d502 1
a502 1
	  amount = -pagesize;
d508 1
a508 1
      SetCtlValue (control, oldval - amount);
d516 1
a516 1
do_mouse_down (WindowPtr win, EventRecord * event)
d522 1
a522 1
  if (1 /*is_app_window(win) */ )
d527 1
a527 1
      part = FindControl (mouse, win, &control);
d539 2
a540 2
		    TEScroll (0, value * (*console_text)->lineHeight,
			      console_text);
d544 2
a545 2
#if 0				/* don't deal with right now */
#if 1				/* universal headers */
d562 1
a562 1
     int hlines, vlines;
d567 2
a568 2
     WindowPtr win;
     int activate;
d572 1
a572 2
  if (win == nil)
    return;
d576 1
a576 1
    SetPort (win);
d599 1
a599 1
     WindowPtr win;
d628 1
a628 1
     long which;
d732 1
a732 1
     int key;
d760 2
a761 4
      if (len > 1000)
	len = 999;
      if (len < 0)
	len = 0;
d766 1
a766 1
      commandbuf[0] = strlen (command);
d800 1
a800 1
     WindowPtr win;
d804 1
a804 2
  if (win == nil)
    return;
d824 1
a824 1
  InsetRect (&tmprect, 1, 1);
d829 1
a829 1
    * (*console_text)->lineHeight;
d842 1
a842 2
  if (newmax < 0)
    newmax = 0;
d857 1
a857 1
	    - 0 /* get h scroll value */ ,
d942 1
a942 1
hacked_fprintf (FILE * fp, const char *fmt,...)
d952 2
a953 2
      ret = vsprintf (buf, fmt, ap);
      TEInsert (buf, strlen (buf), console_text);
d964 1
a964 1
hacked_printf (const char *fmt,...)
d970 1
a970 1
  ret = hacked_vfprintf (stdout, fmt, ap);
d977 2
a978 2
int
hacked_vfprintf (FILE * fp, const char *format, va_list args)
d985 3
a987 3
      ret = vsprintf (buf, format, args);
      TEInsert (buf, strlen (buf), console_text);
      if (strchr (buf, '\n'))
d1001 1
a1001 1
hacked_fputs (const char *s, FILE * fp)
d1005 2
a1006 2
      TEInsert (s, strlen (s), console_text);
      if (strchr (s, '\n'))
d1020 1
a1020 1
hacked_fputc (const char c, FILE * fp)
d1042 1
a1042 1
hacked_putc (const char c, FILE * fp)
d1064 1
a1064 1
hacked_fflush (FILE * fp)
d1078 1
a1078 1
hacked_fgetc (FILE * fp)
d1083 1
a1083 1
      DebugStr ("\pShould not be reading from stdin!");
@

