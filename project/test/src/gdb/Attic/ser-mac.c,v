head	1.6;
access;
symbols
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	gdb-post-ptid_t-2001-05-03:1.4
	gdb-pre-ptid_t-2001-05-03:1.4
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2002.01.05.05.54.29;	author cagney;	state dead;
branches;
next	1.5;

1.5
date	2001.07.08.20.11.12;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.06.08.21.16;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.09.46;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.22.03.24.59;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.02.02.00.21.10;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Remove obsolete MacOS support.
@
text
@/* OBSOLETE /* Remote serial interface for local (hardwired) serial ports for Macintosh. */
/* OBSOLETE    Copyright 1994, 1995, 1996, 1998, 2000 Free Software Foundation, Inc. */
/* OBSOLETE    Contributed by Cygnus Support.  Written by Stan Shebs. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "serial.h" */
/* OBSOLETE  */
/* OBSOLETE #include <Types.h> */
/* OBSOLETE #include <Devices.h> */
/* OBSOLETE /* This is the regular Mac Serial.h, but copied to a different name */
/* OBSOLETE    so as not to get confused with the GDB serial.h above.  */ */
/* OBSOLETE #include "MacSerial.h" */
/* OBSOLETE  */
/* OBSOLETE /* This is unused for now.  We just return a placeholder. */ */
/* OBSOLETE  */
/* OBSOLETE struct mac_ttystate */
/* OBSOLETE   { */
/* OBSOLETE     int bogus; */
/* OBSOLETE   }; */
/* OBSOLETE  */
/* OBSOLETE static int mac_open (serial_t scb, const char *name); */
/* OBSOLETE static void mac_raw (serial_t scb); */
/* OBSOLETE static int mac_readchar (serial_t scb, int timeout); */
/* OBSOLETE static int mac_setbaudrate (serial_t scb, int rate); */
/* OBSOLETE static int mac_write (serial_t scb, const char *str, int len); */
/* OBSOLETE static void mac_close (serial_t scb); */
/* OBSOLETE static serial_ttystate mac_get_tty_state (serial_t scb); */
/* OBSOLETE static int mac_set_tty_state (serial_t scb, serial_ttystate state); */
/* OBSOLETE static char *aptr (short p); */
/* OBSOLETE  */
/* OBSOLETE short input_refnum; */
/* OBSOLETE short output_refnum; */
/* OBSOLETE  */
/* OBSOLETE char *mac_input_buffer; */
/* OBSOLETE char *mac_output_buffer; */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE mac_open (serial_t scb, const char *name) */
/* OBSOLETE { */
/* OBSOLETE   OSErr err; */
/* OBSOLETE  */
/* OBSOLETE   /* Alloc buffer space first - that way any allocation failures are */
/* OBSOLETE      intercepted before the serial driver gets involved. */ */
/* OBSOLETE   if (mac_input_buffer == NULL) */
/* OBSOLETE     mac_input_buffer = (char *) xmalloc (4096); */
/* OBSOLETE   /* Match on a name and open a port. */ */
/* OBSOLETE   if (strcmp (name, "modem") == 0) */
/* OBSOLETE     { */
/* OBSOLETE       err = OpenDriver ("\p.AIn", &input_refnum); */
/* OBSOLETE       if (err != 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  return (-1); */
/* OBSOLETE 	} */
/* OBSOLETE       err = OpenDriver ("\p.AOut", &output_refnum); */
/* OBSOLETE       if (err != 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  CloseDriver (input_refnum); */
/* OBSOLETE 	  return (-1); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   else if (strcmp (name, "printer") == 0) */
/* OBSOLETE     { */
/* OBSOLETE       err = OpenDriver ("\p.BIn", &input_refnum); */
/* OBSOLETE       if (err != 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  return (-1); */
/* OBSOLETE 	} */
/* OBSOLETE       err = OpenDriver ("\p.BOut", &output_refnum); */
/* OBSOLETE       if (err != 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  CloseDriver (input_refnum); */
/* OBSOLETE 	  return (-1); */
/* OBSOLETE 	} */
/* OBSOLETE       /* fake */ */
/* OBSOLETE       scb->fd = 1; */
/* OBSOLETE       return 0; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       error ("You must specify a valid serial port name; your choices are `modem' or `printer'."); */
/* OBSOLETE       errno = ENOENT; */
/* OBSOLETE       return (-1); */
/* OBSOLETE     } */
/* OBSOLETE   /* We got something open. */ */
/* OBSOLETE   if (1 /* using custom buffer */ ) */
/* OBSOLETE     SerSetBuf (input_refnum, mac_input_buffer, 4096); */
/* OBSOLETE   /* Set to a GDB-preferred state. */ */
/* OBSOLETE   SerReset (input_refnum, stop10 | noParity | data8 | baud9600); */
/* OBSOLETE   SerReset (output_refnum, stop10 | noParity | data8 | baud9600); */
/* OBSOLETE   { */
/* OBSOLETE     CntrlParam cb; */
/* OBSOLETE     struct SerShk *handshake; */
/* OBSOLETE  */
/* OBSOLETE     cb.ioCRefNum = output_refnum; */
/* OBSOLETE     cb.csCode = 14; */
/* OBSOLETE     handshake = (struct SerShk *) &cb.csParam[0]; */
/* OBSOLETE     handshake->fXOn = 0; */
/* OBSOLETE     handshake->fCTS = 0; */
/* OBSOLETE     handshake->xOn = 0; */
/* OBSOLETE     handshake->xOff = 0; */
/* OBSOLETE     handshake->errs = 0; */
/* OBSOLETE     handshake->evts = 0; */
/* OBSOLETE     handshake->fInX = 0; */
/* OBSOLETE     handshake->fDTR = 0; */
/* OBSOLETE     err = PBControl ((ParmBlkPtr) & cb, 0); */
/* OBSOLETE     if (err < 0) */
/* OBSOLETE       return (-1); */
/* OBSOLETE   } */
/* OBSOLETE   /* fake */ */
/* OBSOLETE   scb->fd = 1; */
/* OBSOLETE   return 0; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE mac_noop (serial_t scb) */
/* OBSOLETE { */
/* OBSOLETE   return 0; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE mac_raw (serial_t scb) */
/* OBSOLETE { */
/* OBSOLETE   /* Always effectively in raw mode. */ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Read a character with user-specified timeout.  TIMEOUT is number of seconds */
/* OBSOLETE    to wait, or -1 to wait forever.  Use timeout of 0 to effect a poll.  Returns */
/* OBSOLETE    char if successful.  Returns -2 if timeout expired, EOF if line dropped */
/* OBSOLETE    dead, or -3 for any other error (see errno in that case). */ */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE mac_readchar (serial_t scb, int timeout) */
/* OBSOLETE { */
/* OBSOLETE   int status, n; */
/* OBSOLETE   /* time_t */ unsigned long start_time, now; */
/* OBSOLETE   OSErr err; */
/* OBSOLETE   CntrlParam cb; */
/* OBSOLETE   IOParam pb; */
/* OBSOLETE  */
/* OBSOLETE   if (scb->bufcnt-- > 0) */
/* OBSOLETE     return *scb->bufp++; */
/* OBSOLETE  */
/* OBSOLETE   time (&start_time); */
/* OBSOLETE  */
/* OBSOLETE   while (1) */
/* OBSOLETE     { */
/* OBSOLETE       cb.ioCRefNum = input_refnum; */
/* OBSOLETE       cb.csCode = 2; */
/* OBSOLETE       err = PBStatus ((ParmBlkPtr) & cb, 0); */
/* OBSOLETE       if (err < 0) */
/* OBSOLETE 	return SERIAL_ERROR; */
/* OBSOLETE       n = *((long *) &cb.csParam[0]); */
/* OBSOLETE       if (n > 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  pb.ioRefNum = input_refnum; */
/* OBSOLETE 	  pb.ioBuffer = (Ptr) (scb->buf); */
/* OBSOLETE 	  pb.ioReqCount = (n > 64 ? 64 : n); */
/* OBSOLETE 	  err = PBRead ((ParmBlkPtr) & pb, 0); */
/* OBSOLETE 	  if (err < 0) */
/* OBSOLETE 	    return SERIAL_ERROR; */
/* OBSOLETE 	  scb->bufcnt = pb.ioReqCount; */
/* OBSOLETE 	  scb->bufcnt--; */
/* OBSOLETE 	  scb->bufp = scb->buf; */
/* OBSOLETE 	  return *scb->bufp++; */
/* OBSOLETE 	} */
/* OBSOLETE       else if (timeout == 0) */
/* OBSOLETE 	return SERIAL_TIMEOUT; */
/* OBSOLETE       else if (timeout == -1) */
/* OBSOLETE 	; */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  time (&now); */
/* OBSOLETE 	  if (now > start_time + timeout) */
/* OBSOLETE 	    return SERIAL_TIMEOUT; */
/* OBSOLETE 	} */
/* OBSOLETE       PROGRESS (1); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* mac_{get set}_tty_state() are both dummys to fill out the function */
/* OBSOLETE    vector.  Someday, they may do something real... */ */
/* OBSOLETE  */
/* OBSOLETE static serial_ttystate */
/* OBSOLETE mac_get_tty_state (serial_t scb) */
/* OBSOLETE { */
/* OBSOLETE   struct mac_ttystate *state; */
/* OBSOLETE  */
/* OBSOLETE   state = (struct mac_ttystate *) xmalloc (sizeof *state); */
/* OBSOLETE  */
/* OBSOLETE   return (serial_ttystate) state; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE mac_set_tty_state (serial_t scb, serial_ttystate ttystate) */
/* OBSOLETE { */
/* OBSOLETE   return 0; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE mac_noflush_set_tty_state (serial_t scb, serial_ttystate new_ttystate, */
/* OBSOLETE 			   serial_ttystate old_ttystate) */
/* OBSOLETE { */
/* OBSOLETE   return 0; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE mac_print_tty_state (serial_t scb, */
/* OBSOLETE 		     serial_ttystate ttystate, */
/* OBSOLETE 		     struct ui_file *stream) */
/* OBSOLETE { */
/* OBSOLETE   /* Nothing to print.  */ */
/* OBSOLETE   return; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* If there is a tricky formula to relate real baud rates */
/* OBSOLETE    to what the serial driver wants, we should use it.  Until */
/* OBSOLETE    we get one, this table will have to do.  */ */
/* OBSOLETE  */
/* OBSOLETE static struct */
/* OBSOLETE { */
/* OBSOLETE   int real_rate; */
/* OBSOLETE   int bits; */
/* OBSOLETE } */
/* OBSOLETE mac_baud_rate_table[] = */
/* OBSOLETE { */
/* OBSOLETE   { */
/* OBSOLETE     57600, baud57600 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     38400, 1 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     19200, baud19200 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     9600, baud9600 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     7200, baud7200 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     4800, baud4800 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     3600, baud3600 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     2400, baud2400 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     1800, baud1800 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     1200, baud1200 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     600, baud600 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     300, baud300 */
/* OBSOLETE   } */
/* OBSOLETE   , */
/* OBSOLETE   { */
/* OBSOLETE     0, 0 */
/* OBSOLETE   } */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE mac_set_baud_rate (serial_t scb, int rate) */
/* OBSOLETE { */
/* OBSOLETE   int i, bits; */
/* OBSOLETE  */
/* OBSOLETE   for (i = 0; mac_baud_rate_table[i].real_rate != 0; ++i) */
/* OBSOLETE     { */
/* OBSOLETE       if (mac_baud_rate_table[i].real_rate == rate) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  bits = mac_baud_rate_table[i].bits; */
/* OBSOLETE 	  break; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   SerReset (input_refnum, stop10 | noParity | data8 | bits); */
/* OBSOLETE   SerReset (output_refnum, stop10 | noParity | data8 | bits); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE mac_set_stop_bits (serial_t scb, int num) */
/* OBSOLETE { */
/* OBSOLETE   return 0; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int first_mac_write = 0; */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE mac_write (serial_t scb, const char *str, int len) */
/* OBSOLETE { */
/* OBSOLETE   OSErr err; */
/* OBSOLETE   IOParam pb; */
/* OBSOLETE  */
/* OBSOLETE   if (first_mac_write++ < 4) */
/* OBSOLETE     { */
/* OBSOLETE       sleep (1); */
/* OBSOLETE     } */
/* OBSOLETE   pb.ioRefNum = output_refnum; */
/* OBSOLETE   pb.ioBuffer = (Ptr) str; */
/* OBSOLETE   pb.ioReqCount = len; */
/* OBSOLETE   err = PBWrite ((ParmBlkPtr) & pb, 0); */
/* OBSOLETE   if (err < 0) */
/* OBSOLETE     { */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE   return 0; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE mac_close (serial_t scb) */
/* OBSOLETE { */
/* OBSOLETE   if (input_refnum) */
/* OBSOLETE     { */
/* OBSOLETE       if (1 /* custom buffer */ ) */
/* OBSOLETE 	SerSetBuf (input_refnum, mac_input_buffer, 0); */
/* OBSOLETE       CloseDriver (input_refnum); */
/* OBSOLETE       input_refnum = 0; */
/* OBSOLETE     } */
/* OBSOLETE   if (output_refnum) */
/* OBSOLETE     { */
/* OBSOLETE       if (0 /* custom buffer */ ) */
/* OBSOLETE 	SerSetBuf (input_refnum, mac_output_buffer, 0); */
/* OBSOLETE       CloseDriver (output_refnum); */
/* OBSOLETE       output_refnum = 0; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static struct serial_ops mac_ops = */
/* OBSOLETE { */
/* OBSOLETE   "hardwire", */
/* OBSOLETE   0, */
/* OBSOLETE   mac_open, */
/* OBSOLETE   mac_close, */
/* OBSOLETE   mac_readchar, */
/* OBSOLETE   mac_write, */
/* OBSOLETE   mac_noop,			/* flush output */ */
/* OBSOLETE   mac_noop,			/* flush input */ */
/* OBSOLETE   mac_noop,			/* send break -- currently only for nindy */ */
/* OBSOLETE   mac_raw, */
/* OBSOLETE   mac_get_tty_state, */
/* OBSOLETE   mac_set_tty_state, */
/* OBSOLETE   mac_print_tty_state, */
/* OBSOLETE   mac_noflush_set_tty_state, */
/* OBSOLETE   mac_set_baud_rate, */
/* OBSOLETE   mac_set_stop_bits, */
/* OBSOLETE   mac_noop,			/* wait for output to drain */ */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE _initialize_ser_mac (void) */
/* OBSOLETE { */
/* OBSOLETE   serial_add_interface (&mac_ops); */
/* OBSOLETE } */
@


1.5
log
@* ser-mac.c: Make obsolete.
* Makefile.in (ser-mac.o): Ditto.
@
text
@@


1.4
log
@Update/correct copyright notices.
@
text
@d1 386
a386 386
/* Remote serial interface for local (hardwired) serial ports for Macintosh.
   Copyright 1994, 1995, 1996, 1998, 2000 Free Software Foundation, Inc.
   Contributed by Cygnus Support.  Written by Stan Shebs.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "serial.h"

#include <Types.h>
#include <Devices.h>
/* This is the regular Mac Serial.h, but copied to a different name
   so as not to get confused with the GDB serial.h above.  */
#include "MacSerial.h"

/* This is unused for now.  We just return a placeholder. */

struct mac_ttystate
  {
    int bogus;
  };

static int mac_open (serial_t scb, const char *name);
static void mac_raw (serial_t scb);
static int mac_readchar (serial_t scb, int timeout);
static int mac_setbaudrate (serial_t scb, int rate);
static int mac_write (serial_t scb, const char *str, int len);
static void mac_close (serial_t scb);
static serial_ttystate mac_get_tty_state (serial_t scb);
static int mac_set_tty_state (serial_t scb, serial_ttystate state);
static char *aptr (short p);

short input_refnum;
short output_refnum;

char *mac_input_buffer;
char *mac_output_buffer;

static int
mac_open (serial_t scb, const char *name)
{
  OSErr err;

  /* Alloc buffer space first - that way any allocation failures are
     intercepted before the serial driver gets involved. */
  if (mac_input_buffer == NULL)
    mac_input_buffer = (char *) xmalloc (4096);
  /* Match on a name and open a port. */
  if (strcmp (name, "modem") == 0)
    {
      err = OpenDriver ("\p.AIn", &input_refnum);
      if (err != 0)
	{
	  return (-1);
	}
      err = OpenDriver ("\p.AOut", &output_refnum);
      if (err != 0)
	{
	  CloseDriver (input_refnum);
	  return (-1);
	}
    }
  else if (strcmp (name, "printer") == 0)
    {
      err = OpenDriver ("\p.BIn", &input_refnum);
      if (err != 0)
	{
	  return (-1);
	}
      err = OpenDriver ("\p.BOut", &output_refnum);
      if (err != 0)
	{
	  CloseDriver (input_refnum);
	  return (-1);
	}
      /* fake */
      scb->fd = 1;
      return 0;
    }
  else
    {
      error ("You must specify a valid serial port name; your choices are `modem' or `printer'.");
      errno = ENOENT;
      return (-1);
    }
  /* We got something open. */
  if (1 /* using custom buffer */ )
    SerSetBuf (input_refnum, mac_input_buffer, 4096);
  /* Set to a GDB-preferred state. */
  SerReset (input_refnum, stop10 | noParity | data8 | baud9600);
  SerReset (output_refnum, stop10 | noParity | data8 | baud9600);
  {
    CntrlParam cb;
    struct SerShk *handshake;

    cb.ioCRefNum = output_refnum;
    cb.csCode = 14;
    handshake = (struct SerShk *) &cb.csParam[0];
    handshake->fXOn = 0;
    handshake->fCTS = 0;
    handshake->xOn = 0;
    handshake->xOff = 0;
    handshake->errs = 0;
    handshake->evts = 0;
    handshake->fInX = 0;
    handshake->fDTR = 0;
    err = PBControl ((ParmBlkPtr) & cb, 0);
    if (err < 0)
      return (-1);
  }
  /* fake */
  scb->fd = 1;
  return 0;
}

static int
mac_noop (serial_t scb)
{
  return 0;
}

static void
mac_raw (serial_t scb)
{
  /* Always effectively in raw mode. */
}

/* Read a character with user-specified timeout.  TIMEOUT is number of seconds
   to wait, or -1 to wait forever.  Use timeout of 0 to effect a poll.  Returns
   char if successful.  Returns -2 if timeout expired, EOF if line dropped
   dead, or -3 for any other error (see errno in that case). */

static int
mac_readchar (serial_t scb, int timeout)
{
  int status, n;
  /* time_t */ unsigned long start_time, now;
  OSErr err;
  CntrlParam cb;
  IOParam pb;

  if (scb->bufcnt-- > 0)
    return *scb->bufp++;

  time (&start_time);

  while (1)
    {
      cb.ioCRefNum = input_refnum;
      cb.csCode = 2;
      err = PBStatus ((ParmBlkPtr) & cb, 0);
      if (err < 0)
	return SERIAL_ERROR;
      n = *((long *) &cb.csParam[0]);
      if (n > 0)
	{
	  pb.ioRefNum = input_refnum;
	  pb.ioBuffer = (Ptr) (scb->buf);
	  pb.ioReqCount = (n > 64 ? 64 : n);
	  err = PBRead ((ParmBlkPtr) & pb, 0);
	  if (err < 0)
	    return SERIAL_ERROR;
	  scb->bufcnt = pb.ioReqCount;
	  scb->bufcnt--;
	  scb->bufp = scb->buf;
	  return *scb->bufp++;
	}
      else if (timeout == 0)
	return SERIAL_TIMEOUT;
      else if (timeout == -1)
	;
      else
	{
	  time (&now);
	  if (now > start_time + timeout)
	    return SERIAL_TIMEOUT;
	}
      PROGRESS (1);
    }
}

/* mac_{get set}_tty_state() are both dummys to fill out the function
   vector.  Someday, they may do something real... */

static serial_ttystate
mac_get_tty_state (serial_t scb)
{
  struct mac_ttystate *state;

  state = (struct mac_ttystate *) xmalloc (sizeof *state);

  return (serial_ttystate) state;
}

static int
mac_set_tty_state (serial_t scb, serial_ttystate ttystate)
{
  return 0;
}

static int
mac_noflush_set_tty_state (serial_t scb, serial_ttystate new_ttystate,
			   serial_ttystate old_ttystate)
{
  return 0;
}

static void
mac_print_tty_state (serial_t scb,
		     serial_ttystate ttystate,
		     struct ui_file *stream)
{
  /* Nothing to print.  */
  return;
}

/* If there is a tricky formula to relate real baud rates
   to what the serial driver wants, we should use it.  Until
   we get one, this table will have to do.  */

static struct
{
  int real_rate;
  int bits;
}
mac_baud_rate_table[] =
{
  {
    57600, baud57600
  }
  ,
  {
    38400, 1
  }
  ,
  {
    19200, baud19200
  }
  ,
  {
    9600, baud9600
  }
  ,
  {
    7200, baud7200
  }
  ,
  {
    4800, baud4800
  }
  ,
  {
    3600, baud3600
  }
  ,
  {
    2400, baud2400
  }
  ,
  {
    1800, baud1800
  }
  ,
  {
    1200, baud1200
  }
  ,
  {
    600, baud600
  }
  ,
  {
    300, baud300
  }
  ,
  {
    0, 0
  }
};

static int
mac_set_baud_rate (serial_t scb, int rate)
{
  int i, bits;

  for (i = 0; mac_baud_rate_table[i].real_rate != 0; ++i)
    {
      if (mac_baud_rate_table[i].real_rate == rate)
	{
	  bits = mac_baud_rate_table[i].bits;
	  break;
	}
    }
  SerReset (input_refnum, stop10 | noParity | data8 | bits);
  SerReset (output_refnum, stop10 | noParity | data8 | bits);
}

static int
mac_set_stop_bits (serial_t scb, int num)
{
  return 0;
}

int first_mac_write = 0;

static int
mac_write (serial_t scb, const char *str, int len)
{
  OSErr err;
  IOParam pb;

  if (first_mac_write++ < 4)
    {
      sleep (1);
    }
  pb.ioRefNum = output_refnum;
  pb.ioBuffer = (Ptr) str;
  pb.ioReqCount = len;
  err = PBWrite ((ParmBlkPtr) & pb, 0);
  if (err < 0)
    {
      return 1;
    }
  return 0;
}

static void
mac_close (serial_t scb)
{
  if (input_refnum)
    {
      if (1 /* custom buffer */ )
	SerSetBuf (input_refnum, mac_input_buffer, 0);
      CloseDriver (input_refnum);
      input_refnum = 0;
    }
  if (output_refnum)
    {
      if (0 /* custom buffer */ )
	SerSetBuf (input_refnum, mac_output_buffer, 0);
      CloseDriver (output_refnum);
      output_refnum = 0;
    }
}

static struct serial_ops mac_ops =
{
  "hardwire",
  0,
  mac_open,
  mac_close,
  mac_readchar,
  mac_write,
  mac_noop,			/* flush output */
  mac_noop,			/* flush input */
  mac_noop,			/* send break -- currently only for nindy */
  mac_raw,
  mac_get_tty_state,
  mac_set_tty_state,
  mac_print_tty_state,
  mac_noflush_set_tty_state,
  mac_set_baud_rate,
  mac_set_stop_bits,
  mac_noop,			/* wait for output to drain */
};

void
_initialize_ser_mac (void)
{
  serial_add_interface (&mac_ops);
}
@


1.3
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 1994, 2000 Free Software Foundation, Inc.
@


1.2
log
@PARAMS removal.
@
text
@d55 1
a55 3
mac_open (scb, name)
     serial_t scb;
     const char *name;
d132 1
a132 2
mac_noop (scb)
     serial_t scb;
d138 1
a138 2
mac_raw (scb)
     serial_t scb;
d149 1
a149 3
mac_readchar (scb, timeout)
     serial_t scb;
     int timeout;
d201 1
a201 2
mac_get_tty_state (scb)
     serial_t scb;
d211 1
a211 3
mac_set_tty_state (scb, ttystate)
     serial_t scb;
     serial_ttystate ttystate;
d217 2
a218 4
mac_noflush_set_tty_state (scb, new_ttystate, old_ttystate)
     serial_t scb;
     serial_ttystate new_ttystate;
     serial_ttystate old_ttystate;
d297 1
a297 3
mac_set_baud_rate (scb, rate)
     serial_t scb;
     int rate;
d314 1
a314 3
mac_set_stop_bits (scb, num)
     serial_t scb;
     int num;
d322 1
a322 4
mac_write (scb, str, len)
     serial_t scb;
     const char *str;
     int len;
d383 1
a383 1
_initialize_ser_mac ()
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1994 Free Software Foundation, Inc.
d19 2
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d38 9
a46 9
static int mac_open PARAMS ((serial_t scb, const char *name));
static void mac_raw PARAMS ((serial_t scb));
static int mac_readchar PARAMS ((serial_t scb, int timeout));
static int mac_setbaudrate PARAMS ((serial_t scb, int rate));
static int mac_write PARAMS ((serial_t scb, const char *str, int len));
static void mac_close PARAMS ((serial_t scb));
static serial_ttystate mac_get_tty_state PARAMS ((serial_t scb));
static int mac_set_tty_state PARAMS ((serial_t scb, serial_ttystate state));
static char *aptr PARAMS ((short p));
d104 1
a104 1
  if (1 /* using custom buffer */)
d107 2
a108 2
  SerReset (input_refnum,  stop10|noParity|data8|baud9600);
  SerReset (output_refnum, stop10|noParity|data8|baud9600);
d124 1
a124 1
    err = PBControl ((ParmBlkPtr) &cb, 0);
d172 1
a172 1
      err = PBStatus ((ParmBlkPtr) &cb, 0);
d181 1
a181 1
	  err = PBRead ((ParmBlkPtr) &pb, 0);
d235 3
a237 3
mac_print_tty_state (scb, ttystate)
     serial_t scb;
     serial_ttystate ttystate;
d247 2
a248 1
static struct {
d251 54
a304 14
} mac_baud_rate_table[] = {
  { 57600, baud57600 },
  { 38400, 1 },
  { 19200, baud19200 },
  { 9600, baud9600 },
  { 7200, baud7200 },
  { 4800, baud4800 },
  { 3600, baud3600 },
  { 2400, baud2400 },
  { 1800, baud1800 },
  { 1200, baud1200 },
  { 600, baud600 },
  { 300, baud300 },
  { 0, 0 }
d322 2
a323 2
  SerReset (input_refnum,  stop10|noParity|data8|bits);
  SerReset (output_refnum, stop10|noParity|data8|bits);
d352 1
a352 1
  err = PBWrite ((ParmBlkPtr) &pb, 0);
d365 1
a365 1
      if (1 /* custom buffer */)
d372 1
a372 1
      if (0 /* custom buffer */)
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d19 1
a19 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d103 1
a103 1
  if (1 /* using custom buffer */ )
d106 2
a107 2
  SerReset (input_refnum, stop10 | noParity | data8 | baud9600);
  SerReset (output_refnum, stop10 | noParity | data8 | baud9600);
d123 1
a123 1
    err = PBControl ((ParmBlkPtr) & cb, 0);
d171 1
a171 1
      err = PBStatus ((ParmBlkPtr) & cb, 0);
d180 1
a180 1
	  err = PBRead ((ParmBlkPtr) & pb, 0);
d246 1
a246 2
static struct
{
d249 14
a262 54
}
mac_baud_rate_table[] =
{
  {
    57600, baud57600
  }
  ,
  {
    38400, 1
  }
  ,
  {
    19200, baud19200
  }
  ,
  {
    9600, baud9600
  }
  ,
  {
    7200, baud7200
  }
  ,
  {
    4800, baud4800
  }
  ,
  {
    3600, baud3600
  }
  ,
  {
    2400, baud2400
  }
  ,
  {
    1800, baud1800
  }
  ,
  {
    1200, baud1200
  }
  ,
  {
    600, baud600
  }
  ,
  {
    300, baud300
  }
  ,
  {
    0, 0
  }
d280 2
a281 2
  SerReset (input_refnum, stop10 | noParity | data8 | bits);
  SerReset (output_refnum, stop10 | noParity | data8 | bits);
d310 1
a310 1
  err = PBWrite ((ParmBlkPtr) & pb, 0);
d323 1
a323 1
      if (1 /* custom buffer */ )
d330 1
a330 1
      if (0 /* custom buffer */ )
@


1.1.1.3
log
@import gdb-1999-09-21
@
text
@d235 3
a237 3
mac_print_tty_state (serial_t scb,
		     serial_ttystate ttystate,
		     struct gdb_file *stream)
@


1.1.1.4
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1994, 2000 Free Software Foundation, Inc.
d237 1
a237 1
		     struct ui_file *stream)
@


