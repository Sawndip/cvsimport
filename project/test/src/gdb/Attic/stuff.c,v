head	1.5;
access;
symbols
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.8
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.6
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.4
	gdb_5_1-2001-07-29-branchpoint:1.4
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	gdb-post-ptid_t-2001-05-03:1.4
	gdb-pre-ptid_t-2001-05-03:1.4
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb-post-params-removal-2000-06-04:1.1.1.2
	gdb-pre-params-removal-2000-06-04:1.1.1.2
	gdb-post-params-removal-2000-05-28:1.1.1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2001.12.01.22.49.21;	author cagney;	state dead;
branches;
next	1.4;

1.4
date	2001.03.23.00.58.48;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.10.22;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Zap zap.
@
text
@/* OBSOLETE /* Program to stuff files into a specially prepared space in kdb. */
/* OBSOLETE    Copyright 1986, 1989, 1991, 1992, 1995, 2000 */
/* OBSOLETE    Free Software Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE /* Written 13-Mar-86 by David Bridgham. */ */
/* OBSOLETE  */
/* OBSOLETE #include <stdio.h> */
/* OBSOLETE #include <a.out.h> */
/* OBSOLETE #include <sys/types.h> */
/* OBSOLETE #include "gdb_stat.h" */
/* OBSOLETE #include <sys/file.h> */
/* OBSOLETE #include <varargs.h> */
/* OBSOLETE  */
/* OBSOLETE main (argc, argv) */
/* OBSOLETE      int argc; */
/* OBSOLETE      char *argv[]; */
/* OBSOLETE { */
/* OBSOLETE   register char *cp; */
/* OBSOLETE   char *outfile; */
/* OBSOLETE   register int i; */
/* OBSOLETE   int offset; */
/* OBSOLETE   int out_fd, in_fd; */
/* OBSOLETE   struct stat stat_buf; */
/* OBSOLETE   int size, pad; */
/* OBSOLETE   char buf[1024]; */
/* OBSOLETE   static char zeros[4] = */
/* OBSOLETE   {0}; */
/* OBSOLETE  */
/* OBSOLETE   if (argc < 4) */
/* OBSOLETE     err ("Not enough arguments\nUsage: %s -o kdb file1 file2 ...\n", */
/* OBSOLETE 	 argv[0]); */
/* OBSOLETE  */
/* OBSOLETE   outfile = 0; */
/* OBSOLETE   for (i = 1; i < argc; i++) */
/* OBSOLETE     { */
/* OBSOLETE       if (STREQ (argv[i], "-o")) */
/* OBSOLETE 	outfile = argv[++i]; */
/* OBSOLETE     } */
/* OBSOLETE   if (outfile == 0) */
/* OBSOLETE     err ("Output file not specified\n"); */
/* OBSOLETE  */
/* OBSOLETE   offset = get_offset (outfile, "_heap"); */
/* OBSOLETE  */
/* OBSOLETE   out_fd = open (outfile, O_WRONLY); */
/* OBSOLETE   if (out_fd < 0) */
/* OBSOLETE     err ("Error opening %s for write: %s\n", outfile, strerror (errno)); */
/* OBSOLETE   if (lseek (out_fd, offset, 0) < 0) */
/* OBSOLETE     err ("Error seeking to heap in %s: %s\n", outfile, strerror (errno)); */
/* OBSOLETE  */
/* OBSOLETE   /* For each file listed on the command line, write it into the */
/* OBSOLETE    * 'heap' of the output file.  Make sure to skip the arguments */
/* OBSOLETE    * that name the output file. */ */
/* OBSOLETE   for (i = 1; i < argc; i++) */
/* OBSOLETE     { */
/* OBSOLETE       if (STREQ (argv[i], "-o")) */
/* OBSOLETE 	continue; */
/* OBSOLETE       if ((in_fd = open (argv[i], O_RDONLY)) < 0) */
/* OBSOLETE 	err ("Error opening %s for read: %s\n", argv[i], */
/* OBSOLETE 	     strerror (errno)); */
/* OBSOLETE       if (fstat (in_fd, &stat_buf) < 0) */
/* OBSOLETE 	err ("Error stat'ing %s: %s\n", argv[i], strerror (errno)); */
/* OBSOLETE       size = strlen (argv[i]); */
/* OBSOLETE       pad = 4 - (size & 3); */
/* OBSOLETE       size += pad + stat_buf.st_size + sizeof (int); */
/* OBSOLETE       write (out_fd, &size, sizeof (int)); */
/* OBSOLETE       write (out_fd, argv[i], strlen (argv[i])); */
/* OBSOLETE       write (out_fd, zeros, pad); */
/* OBSOLETE       while ((size = read (in_fd, buf, sizeof (buf))) > 0) */
/* OBSOLETE 	write (out_fd, buf, size); */
/* OBSOLETE       close (in_fd); */
/* OBSOLETE     } */
/* OBSOLETE   size = 0; */
/* OBSOLETE   write (out_fd, &size, sizeof (int)); */
/* OBSOLETE   close (out_fd); */
/* OBSOLETE   return (0); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Read symbol table from file and returns the offset into the file */
/* OBSOLETE  * where symbol sym_name is located.  If error, print message and */
/* OBSOLETE  * exit. */ */
/* OBSOLETE get_offset (char *file, char *sym_name) */
/* OBSOLETE { */
/* OBSOLETE   int f; */
/* OBSOLETE   struct exec file_hdr; */
/* OBSOLETE   struct nlist *symbol_table; */
/* OBSOLETE   int size; */
/* OBSOLETE   char *strings; */
/* OBSOLETE  */
/* OBSOLETE   f = open (file, O_RDONLY); */
/* OBSOLETE   if (f < 0) */
/* OBSOLETE     err ("Error opening %s: %s\n", file, strerror (errno)); */
/* OBSOLETE   if (read (f, &file_hdr, sizeof (file_hdr)) < 0) */
/* OBSOLETE     err ("Error reading exec structure: %s\n", strerror (errno)); */
/* OBSOLETE   if (N_BADMAG (file_hdr)) */
/* OBSOLETE     err ("File %s not an a.out file\n", file); */
/* OBSOLETE  */
/* OBSOLETE   /* read in symbol table */ */
/* OBSOLETE   if ((symbol_table = (struct nlist *) malloc (file_hdr.a_syms)) == 0) */
/* OBSOLETE     err ("Couldn't allocate space for symbol table\n"); */
/* OBSOLETE   if (lseek (f, N_SYMOFF (file_hdr), 0) == -1) */
/* OBSOLETE     err ("lseek error: %s\n", strerror (errno)); */
/* OBSOLETE   if (read (f, symbol_table, file_hdr.a_syms) == -1) */
/* OBSOLETE     err ("Error reading symbol table from %s: %s\n", file, */
/* OBSOLETE 	 strerror (errno)); */
/* OBSOLETE  */
/* OBSOLETE   /* read in string table */ */
/* OBSOLETE   if (read (f, &size, 4) == -1) */
/* OBSOLETE     err ("reading string table size: %s\n", strerror (errno)); */
/* OBSOLETE   if ((strings = (char *) malloc (size)) == 0) */
/* OBSOLETE     err ("Couldn't allocate memory for string table\n"); */
/* OBSOLETE   if (read (f, strings, size - 4) == -1) */
/* OBSOLETE     err ("reading string table: %s\n", strerror (errno)); */
/* OBSOLETE  */
/* OBSOLETE   /* Find the core address at which the first byte of kdb text segment */
/* OBSOLETE      should be loaded into core when kdb is run.  */ */
/* OBSOLETE   origin = find_symbol ("_etext", symbol_table, file_hdr.a_syms, strings) */
/* OBSOLETE     - file_hdr.a_text; */
/* OBSOLETE   /* Find the core address at which the heap will appear.  */ */
/* OBSOLETE   coreaddr = find_symbol (sym_name, symbol_table, file_hdr.a_syms, strings); */
/* OBSOLETE   /* Return address in file of the heap data space.  */ */
/* OBSOLETE   return (N_TXTOFF (file_hdr) + core_addr - origin); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE find_symbol (char *sym_name, struct nlist *symbol_table, int length, */
/* OBSOLETE 	     char *strings) */
/* OBSOLETE { */
/* OBSOLETE   register struct nlist *sym; */
/* OBSOLETE  */
/* OBSOLETE   /* Find symbol in question */ */
/* OBSOLETE   for (sym = symbol_table; */
/* OBSOLETE        sym != (struct nlist *) ((char *) symbol_table + length); */
/* OBSOLETE        sym++) */
/* OBSOLETE     { */
/* OBSOLETE       if ((sym->n_type & N_TYPE) != N_DATA) */
/* OBSOLETE 	continue; */
/* OBSOLETE       if (sym->n_un.n_strx == 0) */
/* OBSOLETE 	continue; */
/* OBSOLETE       if (STREQ (sym_name, strings + sym->n_un.n_strx - 4)) */
/* OBSOLETE 	return sym->n_value; */
/* OBSOLETE     } */
/* OBSOLETE   err ("Data symbol %s not found in %s\n", sym_name, file); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* VARARGS */ */
/* OBSOLETE void */
/* OBSOLETE err (va_alist) */
/* OBSOLETE      va_dcl */
/* OBSOLETE { */
/* OBSOLETE   va_list args; */
/* OBSOLETE   char *string; */
/* OBSOLETE  */
/* OBSOLETE   va_start (args); */
/* OBSOLETE   string = va_arg (args, char *); */
/* OBSOLETE   vfprintf (gdb_stderr, string, args); */
/* OBSOLETE   va_end (args); */
/* OBSOLETE   exit (-1); */
/* OBSOLETE } */
@


1.4
log
@Obsolete stuff.c and kdb-start.c.
@
text
@@


1.3
log
@Update/correct copyright notices.
@
text
@d1 174
a174 174
/* Program to stuff files into a specially prepared space in kdb.
   Copyright 1986, 1989, 1991, 1992, 1995, 2000
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* Written 13-Mar-86 by David Bridgham. */

#include <stdio.h>
#include <a.out.h>
#include <sys/types.h>
#include "gdb_stat.h"
#include <sys/file.h>
#include <varargs.h>

main (argc, argv)
     int argc;
     char *argv[];
{
  register char *cp;
  char *outfile;
  register int i;
  int offset;
  int out_fd, in_fd;
  struct stat stat_buf;
  int size, pad;
  char buf[1024];
  static char zeros[4] =
  {0};

  if (argc < 4)
    err ("Not enough arguments\nUsage: %s -o kdb file1 file2 ...\n",
	 argv[0]);

  outfile = 0;
  for (i = 1; i < argc; i++)
    {
      if (STREQ (argv[i], "-o"))
	outfile = argv[++i];
    }
  if (outfile == 0)
    err ("Output file not specified\n");

  offset = get_offset (outfile, "_heap");

  out_fd = open (outfile, O_WRONLY);
  if (out_fd < 0)
    err ("Error opening %s for write: %s\n", outfile, strerror (errno));
  if (lseek (out_fd, offset, 0) < 0)
    err ("Error seeking to heap in %s: %s\n", outfile, strerror (errno));

  /* For each file listed on the command line, write it into the
   * 'heap' of the output file.  Make sure to skip the arguments
   * that name the output file. */
  for (i = 1; i < argc; i++)
    {
      if (STREQ (argv[i], "-o"))
	continue;
      if ((in_fd = open (argv[i], O_RDONLY)) < 0)
	err ("Error opening %s for read: %s\n", argv[i],
	     strerror (errno));
      if (fstat (in_fd, &stat_buf) < 0)
	err ("Error stat'ing %s: %s\n", argv[i], strerror (errno));
      size = strlen (argv[i]);
      pad = 4 - (size & 3);
      size += pad + stat_buf.st_size + sizeof (int);
      write (out_fd, &size, sizeof (int));
      write (out_fd, argv[i], strlen (argv[i]));
      write (out_fd, zeros, pad);
      while ((size = read (in_fd, buf, sizeof (buf))) > 0)
	write (out_fd, buf, size);
      close (in_fd);
    }
  size = 0;
  write (out_fd, &size, sizeof (int));
  close (out_fd);
  return (0);
}

/* Read symbol table from file and returns the offset into the file
 * where symbol sym_name is located.  If error, print message and
 * exit. */
get_offset (char *file, char *sym_name)
{
  int f;
  struct exec file_hdr;
  struct nlist *symbol_table;
  int size;
  char *strings;

  f = open (file, O_RDONLY);
  if (f < 0)
    err ("Error opening %s: %s\n", file, strerror (errno));
  if (read (f, &file_hdr, sizeof (file_hdr)) < 0)
    err ("Error reading exec structure: %s\n", strerror (errno));
  if (N_BADMAG (file_hdr))
    err ("File %s not an a.out file\n", file);

  /* read in symbol table */
  if ((symbol_table = (struct nlist *) malloc (file_hdr.a_syms)) == 0)
    err ("Couldn't allocate space for symbol table\n");
  if (lseek (f, N_SYMOFF (file_hdr), 0) == -1)
    err ("lseek error: %s\n", strerror (errno));
  if (read (f, symbol_table, file_hdr.a_syms) == -1)
    err ("Error reading symbol table from %s: %s\n", file,
	 strerror (errno));

  /* read in string table */
  if (read (f, &size, 4) == -1)
    err ("reading string table size: %s\n", strerror (errno));
  if ((strings = (char *) malloc (size)) == 0)
    err ("Couldn't allocate memory for string table\n");
  if (read (f, strings, size - 4) == -1)
    err ("reading string table: %s\n", strerror (errno));

  /* Find the core address at which the first byte of kdb text segment
     should be loaded into core when kdb is run.  */
  origin = find_symbol ("_etext", symbol_table, file_hdr.a_syms, strings)
    - file_hdr.a_text;
  /* Find the core address at which the heap will appear.  */
  coreaddr = find_symbol (sym_name, symbol_table, file_hdr.a_syms, strings);
  /* Return address in file of the heap data space.  */
  return (N_TXTOFF (file_hdr) + core_addr - origin);
}

find_symbol (char *sym_name, struct nlist *symbol_table, int length,
	     char *strings)
{
  register struct nlist *sym;

  /* Find symbol in question */
  for (sym = symbol_table;
       sym != (struct nlist *) ((char *) symbol_table + length);
       sym++)
    {
      if ((sym->n_type & N_TYPE) != N_DATA)
	continue;
      if (sym->n_un.n_strx == 0)
	continue;
      if (STREQ (sym_name, strings + sym->n_un.n_strx - 4))
	return sym->n_value;
    }
  err ("Data symbol %s not found in %s\n", sym_name, file);
}

/* VARARGS */
void
err (va_alist)
     va_dcl
{
  va_list args;
  char *string;

  va_start (args);
  string = va_arg (args, char *);
  vfprintf (gdb_stderr, string, args);
  va_end (args);
  exit (-1);
}
@


1.2
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright (C) 1986, 1989, 1991 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d42 2
a43 1
  static char zeros[4] = {0};
d46 2
a47 2
    err("Not enough arguments\nUsage: %s -o kdb file1 file2 ...\n",
	argv[0]);
d56 1
a56 1
    err("Output file not specified\n");
d97 1
a97 3
get_offset (file, sym_name)
     char *file;
     char *sym_name;
d114 1
a114 1
  if ((symbol_table = (struct nlist *)malloc (file_hdr.a_syms)) == 0)
d125 1
a125 1
  if ((strings = (char *)malloc (size)) == 0)
d140 2
a141 5
find_symbol (sym_name, symbol_table, length, strings)
     char *sym_name;
     struct nlist *symbol_table;
     int length;
     char *strings;
d147 1
a147 1
       sym != (struct nlist *)((char *)symbol_table + length);
d149 9
a157 7
      {
	if ((sym->n_type & N_TYPE) != N_DATA) continue;
	if (sym->n_un.n_strx == 0) continue;
	if (STREQ (sym_name, strings + sym->n_un.n_strx - 4))
	  return sym->n_value;
      }
    err ("Data symbol %s not found in %s\n", sym_name, file);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d41 1
a41 2
  static char zeros[4] =
  {0};
d44 2
a45 2
    err ("Not enough arguments\nUsage: %s -o kdb file1 file2 ...\n",
	 argv[0]);
d54 1
a54 1
    err ("Output file not specified\n");
d114 1
a114 1
  if ((symbol_table = (struct nlist *) malloc (file_hdr.a_syms)) == 0)
d125 1
a125 1
  if ((strings = (char *) malloc (size)) == 0)
d150 1
a150 1
       sym != (struct nlist *) ((char *) symbol_table + length);
d152 7
a158 9
    {
      if ((sym->n_type & N_TYPE) != N_DATA)
	continue;
      if (sym->n_un.n_strx == 0)
	continue;
      if (STREQ (sym_name, strings + sym->n_un.n_strx - 4))
	return sym->n_value;
    }
  err ("Data symbol %s not found in %s\n", sym_name, file);
@

