head	1.19;
access;
symbols
	gdb_6_0-2003-10-04-release:1.18
	kettenis_sparc-20030918-branch:1.18.0.36
	kettenis_sparc-20030918-branchpoint:1.18
	carlton_dictionary-20030917-merge:1.18
	ezannoni_pie-20030916-branchpoint:1.18
	ezannoni_pie-20030916-branch:1.18.0.34
	cagney_x86i386-20030821-branch:1.18.0.32
	cagney_x86i386-20030821-branchpoint:1.18
	carlton_dictionary-20030805-merge:1.18
	carlton_dictionary-20030627-merge:1.18
	gdb_6_0-branch:1.18.0.30
	gdb_6_0-2003-06-23-branchpoint:1.18
	jimb-ppc64-linux-20030613-branch:1.18.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.18
	cagney_convert-20030606-branch:1.18.0.26
	cagney_convert-20030606-branchpoint:1.18
	cagney_writestrings-20030508-branch:1.18.0.24
	cagney_writestrings-20030508-branchpoint:1.18
	jimb-ppc64-linux-20030528-branch:1.18.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.18
	carlton_dictionary-20030523-merge:1.18
	cagney_fileio-20030521-branch:1.18.0.20
	cagney_fileio-20030521-branchpoint:1.18
	kettenis_i386newframe-20030517-mergepoint:1.18
	jimb-ppc64-linux-20030509-branch:1.18.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.18
	kettenis_i386newframe-20030504-mergepoint:1.18
	carlton_dictionary-20030430-merge:1.18
	kettenis_i386newframe-20030419-branch:1.18.0.16
	kettenis_i386newframe-20030419-branchpoint:1.18
	carlton_dictionary-20030416-merge:1.18
	cagney_frameaddr-20030409-mergepoint:1.18
	kettenis_i386newframe-20030406-branch:1.18.0.14
	kettenis_i386newframe-20030406-branchpoint:1.18
	cagney_frameaddr-20030403-branchpoint:1.18
	cagney_frameaddr-20030403-branch:1.18.0.12
	cagney_framebase-20030330-mergepoint:1.18
	cagney_framebase-20030326-branch:1.18.0.10
	cagney_framebase-20030326-branchpoint:1.18
	cagney_lazyid-20030317-branch:1.18.0.8
	cagney_lazyid-20030317-branchpoint:1.18
	kettenis-i386newframe-20030316-mergepoint:1.18
	offbyone-20030313-branch:1.18.0.6
	offbyone-20030313-branchpoint:1.18
	kettenis-i386newframe-20030308-branch:1.18.0.4
	kettenis-i386newframe-20030308-branchpoint:1.18
	carlton_dictionary-20030305-merge:1.18
	cagney_offbyone-20030303-branch:1.18.0.2
	cagney_offbyone-20030303-branchpoint:1.18
	carlton_dictionary-20030207-merge:1.18
	interps-20030203-mergepoint:1.17
	interps-20030202-branch:1.17.0.4
	interps-20030202-branchpoint:1.17
	cagney-unwind-20030108-branch:1.17.0.2
	cagney-unwind-20030108-branchpoint:1.17
	carlton_dictionary-20021223-merge:1.17
	gdb_5_3-2002-12-12-release:1.12
	carlton_dictionary-20021115-merge:1.13
	kseitz_interps-20021105-merge:1.13
	kseitz_interps-20021103-merge:1.13
	drow-cplus-merge-20021020:1.12
	drow-cplus-merge-20021025:1.12
	carlton_dictionary-20021025-merge:1.12
	carlton_dictionary-20021011-merge:1.12
	drow-cplus-branch:1.12.0.10
	drow-cplus-branchpoint:1.12
	kseitz_interps-20020930-merge:1.12
	carlton_dictionary-20020927-merge:1.12
	carlton_dictionary-branch:1.12.0.8
	carlton_dictionary-20020920-branchpoint:1.12
	gdb_5_3-branch:1.12.0.6
	gdb_5_3-2002-09-04-branchpoint:1.12
	kseitz_interps-20020829-merge:1.12
	cagney_sysregs-20020825-branch:1.12.0.4
	cagney_sysregs-20020825-branchpoint:1.12
	readline_4_3-import-branch:1.12.0.2
	readline_4_3-import-branchpoint:1.12
	gdb_5_2_1-2002-07-23-release:1.9
	kseitz_interps-20020528-branch:1.11.0.6
	kseitz_interps-20020528-branchpoint:1.11
	cagney_regbuf-20020515-branch:1.11.0.4
	cagney_regbuf-20020515-branchpoint:1.11
	jimb-macro-020506-branch:1.11.0.2
	jimb-macro-020506-branchpoint:1.11
	gdb_5_2-2002-04-29-release:1.9
	gdb_5_2-branch:1.9.0.8
	gdb_5_2-2002-03-03-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.6
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.4
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.2
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.8.0.2
	dberlin-typesystem-branchpoint:1.8
	gdb-post-ptid_t-2001-05-03:1.8
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb-post-params-removal-2000-06-04:1.1.1.2
	gdb-pre-params-removal-2000-06-04:1.1.1.2
	gdb-post-params-removal-2000-05-28:1.1.1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.19
date	2003.10.06.19.10.44;	author cagney;	state dead;
branches;
next	1.18;

1.18
date	2003.02.04.22.04.08;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.11.20.35.43;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.11.02.26.35;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.29.19.15.14;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.24.19.48.12;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.31.19.49.33;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.29.16.34.06;	author cagney;	state Exp;
branches
	1.12.8.1
	1.12.10.1;
next	1.11;

1.11
date	2002.04.12.18.18.57;	author cagney;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	2002.04.06.00.02.50;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.04.04.15.24;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.06.08.21.08;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.01.01.47;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.02.11.37.15;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.01;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.01;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.06.38;	author jsm;	state Exp;
branches;
next	;

1.11.6.1
date	2002.08.09.18.34.24;	author kseitz;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2002.11.04.00.17.31;	author ezannoni;	state Exp;
branches;
next	;

1.12.8.1
date	2002.11.15.19.18.45;	author carlton;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2002.12.23.19.38.26;	author carlton;	state Exp;
branches;
next	1.12.8.3;

1.12.8.3
date	2003.02.07.19.17.49;	author carlton;	state Exp;
branches;
next	1.12.8.4;

1.12.8.4
date	2003.11.11.23.50.44;	author carlton;	state dead;
branches;
next	;

1.12.10.1
date	2003.12.14.20.27.16;	author drow;	state dead;
branches;
next	;


desc
@@


1.19
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* z8k-tdep.c, symm-tdep.c, symm-nat.c: Delete obsolete file.
	* sparclet-stub.c, sparclet-rom.c: Delete obsolete file.
	* sparcl-tdep.c, sparcl-stub.c, h8500-tdep.c: Delete obsolete file.
	* m3-nat.c, mipsm3-nat.c, mn10200-tdep.c: Delete obsolete file.
@
text
@// OBSOLETE /* Target-dependent code for Hitachi H8/500, for GDB.
// OBSOLETE 
// OBSOLETE    Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002 Free Software
// OBSOLETE    Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE    Contributed by Steve Chamberlain
// OBSOLETE    sac@@cygnus.com
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "gdbtypes.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "dis-asm.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #define UNSIGNED_SHORT(X) ((X) & 0xffff)
// OBSOLETE 
// OBSOLETE static int code_size = 2;
// OBSOLETE 
// OBSOLETE static int data_size = 2;
// OBSOLETE 
// OBSOLETE /* Shape of an H8/500 frame :
// OBSOLETE 
// OBSOLETE    arg-n
// OBSOLETE    ..
// OBSOLETE    arg-2
// OBSOLETE    arg-1
// OBSOLETE    return address <2 or 4 bytes>
// OBSOLETE    old fp         <2 bytes>
// OBSOLETE    auto-n
// OBSOLETE    ..
// OBSOLETE    auto-1
// OBSOLETE    saved registers
// OBSOLETE 
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /* an easy to debug H8 stack frame looks like:
// OBSOLETE    0x6df6               push    r6
// OBSOLETE    0x0d76       mov.w   r7,r6
// OBSOLETE    0x6dfn          push    reg
// OBSOLETE    0x7905 nnnn          mov.w  #n,r5    or   0x1b87  subs #2,sp
// OBSOLETE    0x1957               sub.w  r5,sp
// OBSOLETE 
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #define IS_PUSH(x) (((x) & 0xff00)==0x6d00)
// OBSOLETE #define IS_LINK_8(x) ((x) == 0x17)
// OBSOLETE #define IS_LINK_16(x) ((x) == 0x1f)
// OBSOLETE #define IS_MOVE_FP(x) ((x) == 0x0d76)
// OBSOLETE #define IS_MOV_SP_FP(x) ((x) == 0x0d76)
// OBSOLETE #define IS_SUB2_SP(x) ((x) == 0x1b87)
// OBSOLETE #define IS_MOVK_R5(x) ((x) == 0x7905)
// OBSOLETE #define IS_SUB_R5SP(x) ((x) == 0x1957)
// OBSOLETE 
// OBSOLETE #define LINK_8 0x17
// OBSOLETE #define LINK_16 0x1f
// OBSOLETE 
// OBSOLETE int minimum_mode = 1;
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE h8500_skip_prologue (CORE_ADDR start_pc)
// OBSOLETE {
// OBSOLETE   short int w;
// OBSOLETE 
// OBSOLETE   w = read_memory_integer (start_pc, 1);
// OBSOLETE   if (w == LINK_8)
// OBSOLETE     {
// OBSOLETE       start_pc += 2;
// OBSOLETE       w = read_memory_integer (start_pc, 1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (w == LINK_16)
// OBSOLETE     {
// OBSOLETE       start_pc += 3;
// OBSOLETE       w = read_memory_integer (start_pc, 2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return start_pc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE h8500_addr_bits_remove (CORE_ADDR addr)
// OBSOLETE {
// OBSOLETE   return ((addr) & 0xffffff);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Given a GDB frame, determine the address of the calling function's
// OBSOLETE    frame.  This will be used to create a new GDB frame struct, and
// OBSOLETE    then INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC will be
// OBSOLETE    called for the new frame.
// OBSOLETE 
// OBSOLETE    For us, the frame address is its stack pointer value, so we look up
// OBSOLETE    the function prologue to determine the caller's sp value, and return it.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE h8500_frame_chain (struct frame_info *thisframe)
// OBSOLETE {
// OBSOLETE   if (!inside_entry_file (thisframe->pc))
// OBSOLETE     return (read_memory_integer (get_frame_base (thisframe), PTR_SIZE));
// OBSOLETE   else
// OBSOLETE     return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
// OBSOLETE    is not the address of a valid instruction, the address of the next
// OBSOLETE    instruction beyond ADDR otherwise.  *PWORD1 receives the first word
// OBSOLETE    of the instruction. */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE NEXT_PROLOGUE_INSN (CORE_ADDR addr, CORE_ADDR lim, char *pword1)
// OBSOLETE {
// OBSOLETE   if (addr < lim + 8)
// OBSOLETE     {
// OBSOLETE       read_memory (addr, pword1, 1);
// OBSOLETE       read_memory (addr, pword1 + 1, 1);
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Examine the prologue of a function.  `ip' points to the first
// OBSOLETE    instruction.  `limit' is the limit of the prologue (e.g. the addr
// OBSOLETE    of the first linenumber, or perhaps the program counter if we're
// OBSOLETE    stepping through).  `frame_sp' is the stack pointer value in use in
// OBSOLETE    this frame.  `fsr' is a pointer to a frame_saved_regs structure
// OBSOLETE    into which we put info about the registers saved by this frame.
// OBSOLETE    `fi' is a struct frame_info pointer; we fill in various fields in
// OBSOLETE    it to reflect the offsets of the arg pointer and the locals
// OBSOLETE    pointer.  */
// OBSOLETE 
// OBSOLETE /* Return the saved PC from this frame. */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_saved_pc (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   return read_memory_integer (get_frame_base (frame) + 2, PTR_SIZE);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE h8500_pop_frame (void)
// OBSOLETE {
// OBSOLETE   unsigned regnum;
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE   struct frame_info *frame = get_current_frame ();
// OBSOLETE 
// OBSOLETE   deprecated_get_frame_saved_regs (frame, &fsr);
// OBSOLETE 
// OBSOLETE   for (regnum = 0; regnum < 8; regnum++)
// OBSOLETE     {
// OBSOLETE       if (fsr.regs[regnum])
// OBSOLETE 	write_register (regnum, read_memory_short (fsr.regs[regnum]));
// OBSOLETE 
// OBSOLETE       flush_cached_frames ();
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE h8500_print_register_hook (int regno)
// OBSOLETE {
// OBSOLETE   if (regno == CCR_REGNUM)
// OBSOLETE     {
// OBSOLETE       /* CCR register */
// OBSOLETE 
// OBSOLETE       int C, Z, N, V;
// OBSOLETE       unsigned char b[2];
// OBSOLETE       unsigned char l;
// OBSOLETE 
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno, b);
// OBSOLETE       l = b[1];
// OBSOLETE       printf_unfiltered ("\t");
// OBSOLETE       printf_unfiltered ("I-%d - ", (l & 0x80) != 0);
// OBSOLETE       N = (l & 0x8) != 0;
// OBSOLETE       Z = (l & 0x4) != 0;
// OBSOLETE       V = (l & 0x2) != 0;
// OBSOLETE       C = (l & 0x1) != 0;
// OBSOLETE       printf_unfiltered ("N-%d ", N);
// OBSOLETE       printf_unfiltered ("Z-%d ", Z);
// OBSOLETE       printf_unfiltered ("V-%d ", V);
// OBSOLETE       printf_unfiltered ("C-%d ", C);
// OBSOLETE       if ((C | Z) == 0)
// OBSOLETE 	printf_unfiltered ("u> ");
// OBSOLETE       if ((C | Z) == 1)
// OBSOLETE 	printf_unfiltered ("u<= ");
// OBSOLETE       if ((C == 0))
// OBSOLETE 	printf_unfiltered ("u>= ");
// OBSOLETE       if (C == 1)
// OBSOLETE 	printf_unfiltered ("u< ");
// OBSOLETE       if (Z == 0)
// OBSOLETE 	printf_unfiltered ("!= ");
// OBSOLETE       if (Z == 1)
// OBSOLETE 	printf_unfiltered ("== ");
// OBSOLETE       if ((N ^ V) == 0)
// OBSOLETE 	printf_unfiltered (">= ");
// OBSOLETE       if ((N ^ V) == 1)
// OBSOLETE 	printf_unfiltered ("< ");
// OBSOLETE       if ((Z | (N ^ V)) == 0)
// OBSOLETE 	printf_unfiltered ("> ");
// OBSOLETE       if ((Z | (N ^ V)) == 1)
// OBSOLETE 	printf_unfiltered ("<= ");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE h8500_print_registers_info (struct gdbarch *gdbarch,
// OBSOLETE 			    struct ui_file *file,
// OBSOLETE 			    struct frame_info *frame,
// OBSOLETE 			    int regnum, int print_all)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
// OBSOLETE   char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
// OBSOLETE   char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);
// OBSOLETE 
// OBSOLETE   for (i = 0; i < numregs; i++)
// OBSOLETE     {
// OBSOLETE       /* Decide between printing all regs, non-float / vector regs, or
// OBSOLETE          specific reg.  */
// OBSOLETE       if (regnum == -1)
// OBSOLETE 	{
// OBSOLETE 	  if (!print_all)
// OBSOLETE 	    {
// OBSOLETE 	      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
// OBSOLETE 		continue;
// OBSOLETE 	      if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)))
// OBSOLETE 		continue;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (i != regnum)
// OBSOLETE 	    continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* If the register name is empty, it is undefined for this
// OBSOLETE          processor, so don't display anything.  */
// OBSOLETE       if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
// OBSOLETE 	continue;
// OBSOLETE 
// OBSOLETE       fputs_filtered (REGISTER_NAME (i), file);
// OBSOLETE       print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);
// OBSOLETE 
// OBSOLETE       /* Get the data in raw format.  */
// OBSOLETE       if (! frame_register_read (frame, i, raw_buffer))
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (file, "*value not available*\n");
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* FIXME: cagney/2002-08-03: This code shouldn't be necessary.
// OBSOLETE          The function frame_register_read() should have returned the
// OBSOLETE          pre-cooked register so no conversion is necessary.  */
// OBSOLETE       /* Convert raw data to virtual format if necessary.  */
// OBSOLETE       if (REGISTER_CONVERTIBLE (i))
// OBSOLETE 	{
// OBSOLETE 	  REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
// OBSOLETE 				       raw_buffer, virtual_buffer);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  memcpy (virtual_buffer, raw_buffer,
// OBSOLETE 		  REGISTER_VIRTUAL_SIZE (i));
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* If virtual format is floating, print it that way, and in raw
// OBSOLETE          hex.  */
// OBSOLETE       if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
// OBSOLETE 	{
// OBSOLETE 	  int j;
// OBSOLETE 
// OBSOLETE 	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
// OBSOLETE 		     file, 0, 1, 0, Val_pretty_default);
// OBSOLETE 
// OBSOLETE 	  fprintf_filtered (file, "\t(raw 0x");
// OBSOLETE 	  for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
// OBSOLETE 	    {
// OBSOLETE 	      int idx;
// OBSOLETE 	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
// OBSOLETE 		idx = j;
// OBSOLETE 	      else
// OBSOLETE 		idx = REGISTER_RAW_SIZE (i) - 1 - j;
// OBSOLETE 	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
// OBSOLETE 	    }
// OBSOLETE 	  fprintf_filtered (file, ")");
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* Print the register in hex.  */
// OBSOLETE 	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
// OBSOLETE 		     file, 'x', 1, 0, Val_pretty_default);
// OBSOLETE           /* If not a vector register, print it also according to its
// OBSOLETE              natural format.  */
// OBSOLETE 	  if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)) == 0)
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (file, "\t");
// OBSOLETE 	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
// OBSOLETE 			 file, 0, 1, 0, Val_pretty_default);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Some h8500 specific info.  */
// OBSOLETE       h8500_print_register_hook (i);
// OBSOLETE 
// OBSOLETE       fprintf_filtered (file, "\n");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE h8500_do_registers_info (int regnum, int all)
// OBSOLETE {
// OBSOLETE   h8500_print_registers_info (current_gdbarch, gdb_stdout, deprecated_selected_frame,
// OBSOLETE 			      regnum, all);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE h8500_register_size (int regno)
// OBSOLETE {
// OBSOLETE   switch (regno)
// OBSOLETE     {
// OBSOLETE     case SEG_C_REGNUM:
// OBSOLETE     case SEG_D_REGNUM:
// OBSOLETE     case SEG_E_REGNUM:
// OBSOLETE     case SEG_T_REGNUM:
// OBSOLETE       return 1;
// OBSOLETE     case R0_REGNUM:
// OBSOLETE     case R1_REGNUM:
// OBSOLETE     case R2_REGNUM:
// OBSOLETE     case R3_REGNUM:
// OBSOLETE     case R4_REGNUM:
// OBSOLETE     case R5_REGNUM:
// OBSOLETE     case R6_REGNUM:
// OBSOLETE     case R7_REGNUM:
// OBSOLETE     case CCR_REGNUM:
// OBSOLETE       return 2;
// OBSOLETE 
// OBSOLETE     case PR0_REGNUM:
// OBSOLETE     case PR1_REGNUM:
// OBSOLETE     case PR2_REGNUM:
// OBSOLETE     case PR3_REGNUM:
// OBSOLETE     case PR4_REGNUM:
// OBSOLETE     case PR5_REGNUM:
// OBSOLETE     case PR6_REGNUM:
// OBSOLETE     case PR7_REGNUM:
// OBSOLETE     case PC_REGNUM:
// OBSOLETE       return 4;
// OBSOLETE     default:
// OBSOLETE       internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct type *
// OBSOLETE h8500_register_virtual_type (int regno)
// OBSOLETE {
// OBSOLETE   switch (regno)
// OBSOLETE     {
// OBSOLETE     case SEG_C_REGNUM:
// OBSOLETE     case SEG_E_REGNUM:
// OBSOLETE     case SEG_D_REGNUM:
// OBSOLETE     case SEG_T_REGNUM:
// OBSOLETE       return builtin_type_unsigned_char;
// OBSOLETE     case R0_REGNUM:
// OBSOLETE     case R1_REGNUM:
// OBSOLETE     case R2_REGNUM:
// OBSOLETE     case R3_REGNUM:
// OBSOLETE     case R4_REGNUM:
// OBSOLETE     case R5_REGNUM:
// OBSOLETE     case R6_REGNUM:
// OBSOLETE     case R7_REGNUM:
// OBSOLETE     case CCR_REGNUM:
// OBSOLETE       return builtin_type_unsigned_short;
// OBSOLETE     case PR0_REGNUM:
// OBSOLETE     case PR1_REGNUM:
// OBSOLETE     case PR2_REGNUM:
// OBSOLETE     case PR3_REGNUM:
// OBSOLETE     case PR4_REGNUM:
// OBSOLETE     case PR5_REGNUM:
// OBSOLETE     case PR6_REGNUM:
// OBSOLETE     case PR7_REGNUM:
// OBSOLETE     case PC_REGNUM:
// OBSOLETE       return builtin_type_unsigned_long;
// OBSOLETE     default:
// OBSOLETE       internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Put here the code to store, into a struct frame_saved_regs,
// OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO.
// OBSOLETE    This includes special registers such as pc and fp saved in special
// OBSOLETE    ways in the stack frame.  sp is even more special:
// OBSOLETE    the address we return for it IS the sp for the next frame.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE frame_find_saved_regs (struct frame_info *frame_info,
// OBSOLETE 		       struct frame_saved_regs *frame_saved_regs)
// OBSOLETE {
// OBSOLETE   register int regnum;
// OBSOLETE   register int regmask;
// OBSOLETE   register CORE_ADDR next_addr;
// OBSOLETE   register CORE_ADDR pc;
// OBSOLETE   unsigned char thebyte;
// OBSOLETE 
// OBSOLETE   memset (frame_saved_regs, '\0', sizeof *frame_saved_regs);
// OBSOLETE 
// OBSOLETE   if ((frame_info)->pc >= (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 4
// OBSOLETE       && (frame_info)->pc <= (frame_info)->frame)
// OBSOLETE     {
// OBSOLETE       next_addr = (frame_info)->frame;
// OBSOLETE       pc = (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 4;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       pc = get_pc_function_start ((frame_info)->pc);
// OBSOLETE       /* Verify we have a link a6 instruction next;
// OBSOLETE          if not we lose.  If we win, find the address above the saved
// OBSOLETE          regs using the amount of storage from the link instruction.
// OBSOLETE        */
// OBSOLETE 
// OBSOLETE       thebyte = read_memory_integer (pc, 1);
// OBSOLETE       if (0x1f == thebyte)
// OBSOLETE 	next_addr = (frame_info)->frame + read_memory_integer (pc += 1, 2), pc += 2;
// OBSOLETE       else if (0x17 == thebyte)
// OBSOLETE 	next_addr = (frame_info)->frame + read_memory_integer (pc += 1, 1), pc += 1;
// OBSOLETE       else
// OBSOLETE 	goto lose;
// OBSOLETE #if 0
// OBSOLETE       /* FIXME steve */
// OBSOLETE       /* If have an add:g.waddal #-n, sp next, adjust next_addr.  */
// OBSOLETE       if ((0x0c0177777 & read_memory_integer (pc, 2)) == 0157774)
// OBSOLETE 	next_addr += read_memory_integer (pc += 2, 4), pc += 4;
// OBSOLETE #endif
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   thebyte = read_memory_integer (pc, 1);
// OBSOLETE   if (thebyte == 0x12)
// OBSOLETE     {
// OBSOLETE       /* Got stm */
// OBSOLETE       pc++;
// OBSOLETE       regmask = read_memory_integer (pc, 1);
// OBSOLETE       pc++;
// OBSOLETE       for (regnum = 0; regnum < 8; regnum++, regmask >>= 1)
// OBSOLETE 	{
// OBSOLETE 	  if (regmask & 1)
// OBSOLETE 	    {
// OBSOLETE 	      (frame_saved_regs)->regs[regnum] = (next_addr += 2) - 2;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       thebyte = read_memory_integer (pc, 1);
// OBSOLETE     }
// OBSOLETE   /* Maybe got a load of pushes */
// OBSOLETE   while (thebyte == 0xbf)
// OBSOLETE     {
// OBSOLETE       pc++;
// OBSOLETE       regnum = read_memory_integer (pc, 1) & 0x7;
// OBSOLETE       pc++;
// OBSOLETE       (frame_saved_regs)->regs[regnum] = (next_addr += 2) - 2;
// OBSOLETE       thebyte = read_memory_integer (pc, 1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE lose:;
// OBSOLETE 
// OBSOLETE   /* Remember the address of the frame pointer */
// OBSOLETE   (frame_saved_regs)->regs[FP_REGNUM] = (frame_info)->frame;
// OBSOLETE 
// OBSOLETE   /* This is where the old sp is hidden */
// OBSOLETE   (frame_saved_regs)->regs[SP_REGNUM] = (frame_info)->frame;
// OBSOLETE 
// OBSOLETE   /* And the PC - remember the pushed FP is always two bytes long */
// OBSOLETE   (frame_saved_regs)->regs[PC_REGNUM] = (frame_info)->frame + 2;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE saved_pc_after_call (void)
// OBSOLETE {
// OBSOLETE   int x;
// OBSOLETE   int a = read_register (SP_REGNUM);
// OBSOLETE 
// OBSOLETE   x = read_memory_integer (a, code_size);
// OBSOLETE   if (code_size == 2)
// OBSOLETE     {
// OBSOLETE       /* Stick current code segement onto top */
// OBSOLETE       x &= 0xffff;
// OBSOLETE       x |= read_register (SEG_C_REGNUM) << 16;
// OBSOLETE     }
// OBSOLETE   x &= 0xffffff;
// OBSOLETE   return x;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE h8500_set_pointer_size (int newsize)
// OBSOLETE {
// OBSOLETE   static int oldsize = 0;
// OBSOLETE 
// OBSOLETE   if (oldsize != newsize)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("pointer size set to %d bits\n", newsize);
// OBSOLETE       oldsize = newsize;
// OBSOLETE       if (newsize == 32)
// OBSOLETE 	{
// OBSOLETE 	  minimum_mode = 0;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  minimum_mode = 1;
// OBSOLETE 	}
// OBSOLETE       _initialize_gdbtypes ();
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE big_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   h8500_set_pointer_size (32);
// OBSOLETE   code_size = 4;
// OBSOLETE   data_size = 4;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE medium_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   h8500_set_pointer_size (32);
// OBSOLETE   code_size = 4;
// OBSOLETE   data_size = 2;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE compact_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   h8500_set_pointer_size (32);
// OBSOLETE   code_size = 2;
// OBSOLETE   data_size = 4;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE small_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   h8500_set_pointer_size (16);
// OBSOLETE   code_size = 2;
// OBSOLETE   data_size = 2;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct cmd_list_element *setmemorylist;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE set_memory (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   printf_unfiltered ("\"set memory\" must be followed by the name of a memory subcommand.\n");
// OBSOLETE   help_list (setmemorylist, "set memory ", -1, gdb_stdout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* See if variable name is ppc or pr[0-7] */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE h8500_is_trapped_internalvar (char *name)
// OBSOLETE {
// OBSOLETE   if (name[0] != 'p')
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   if (strcmp (name + 1, "pc") == 0)
// OBSOLETE     return 1;
// OBSOLETE 
// OBSOLETE   if (name[1] == 'r'
// OBSOLETE       && name[2] >= '0'
// OBSOLETE       && name[2] <= '7'
// OBSOLETE       && name[3] == '\000')
// OBSOLETE     return 1;
// OBSOLETE   else
// OBSOLETE     return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct value *
// OBSOLETE h8500_value_of_trapped_internalvar (struct internalvar *var)
// OBSOLETE {
// OBSOLETE   LONGEST regval;
// OBSOLETE   unsigned char regbuf[4];
// OBSOLETE   int page_regnum, regnum;
// OBSOLETE 
// OBSOLETE   regnum = var->name[2] == 'c' ? PC_REGNUM : var->name[2] - '0';
// OBSOLETE 
// OBSOLETE   switch (var->name[2])
// OBSOLETE     {
// OBSOLETE     case 'c':
// OBSOLETE       page_regnum = SEG_C_REGNUM;
// OBSOLETE       break;
// OBSOLETE     case '0':
// OBSOLETE     case '1':
// OBSOLETE     case '2':
// OBSOLETE     case '3':
// OBSOLETE       page_regnum = SEG_D_REGNUM;
// OBSOLETE       break;
// OBSOLETE     case '4':
// OBSOLETE     case '5':
// OBSOLETE       page_regnum = SEG_E_REGNUM;
// OBSOLETE       break;
// OBSOLETE     case '6':
// OBSOLETE     case '7':
// OBSOLETE       page_regnum = SEG_T_REGNUM;
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   get_saved_register (regbuf, NULL, NULL, deprecated_selected_frame, page_regnum, NULL);
// OBSOLETE   regval = regbuf[0] << 16;
// OBSOLETE 
// OBSOLETE   get_saved_register (regbuf, NULL, NULL, deprecated_selected_frame, regnum, NULL);
// OBSOLETE   regval |= regbuf[0] << 8 | regbuf[1];		/* XXX host/target byte order */
// OBSOLETE 
// OBSOLETE   xfree (var->value);		/* Free up old value */
// OBSOLETE 
// OBSOLETE   var->value = value_from_longest (builtin_type_unsigned_long, regval);
// OBSOLETE   release_value (var->value);	/* Unchain new value */
// OBSOLETE 
// OBSOLETE   VALUE_LVAL (var->value) = lval_internalvar;
// OBSOLETE   VALUE_INTERNALVAR (var->value) = var;
// OBSOLETE   return var->value;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE h8500_set_trapped_internalvar (struct internalvar *var, struct value *newval,
// OBSOLETE 			       int bitpos, int bitsize, int offset)
// OBSOLETE {
// OBSOLETE   char *page_regnum, *regnum;
// OBSOLETE   char expression[100];
// OBSOLETE   unsigned new_regval;
// OBSOLETE   struct type *type;
// OBSOLETE   enum type_code newval_type_code;
// OBSOLETE 
// OBSOLETE   type = check_typedef (VALUE_TYPE (newval));
// OBSOLETE   newval_type_code = TYPE_CODE (type);
// OBSOLETE 
// OBSOLETE   if ((newval_type_code != TYPE_CODE_INT
// OBSOLETE        && newval_type_code != TYPE_CODE_PTR)
// OBSOLETE       || TYPE_LENGTH (type) != sizeof (new_regval))
// OBSOLETE     error ("Illegal type (%s) for assignment to $%s\n",
// OBSOLETE 	   TYPE_NAME (VALUE_TYPE (newval)), var->name);
// OBSOLETE 
// OBSOLETE   new_regval = *(long *) VALUE_CONTENTS_RAW (newval);
// OBSOLETE 
// OBSOLETE   regnum = var->name + 1;
// OBSOLETE 
// OBSOLETE   switch (var->name[2])
// OBSOLETE     {
// OBSOLETE     case 'c':
// OBSOLETE       page_regnum = "cp";
// OBSOLETE       break;
// OBSOLETE     case '0':
// OBSOLETE     case '1':
// OBSOLETE     case '2':
// OBSOLETE     case '3':
// OBSOLETE       page_regnum = "dp";
// OBSOLETE       break;
// OBSOLETE     case '4':
// OBSOLETE     case '5':
// OBSOLETE       page_regnum = "ep";
// OBSOLETE       break;
// OBSOLETE     case '6':
// OBSOLETE     case '7':
// OBSOLETE       page_regnum = "tp";
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   sprintf (expression, "$%s=%d", page_regnum, new_regval >> 16);
// OBSOLETE   parse_and_eval (expression);
// OBSOLETE 
// OBSOLETE   sprintf (expression, "$%s=%d", regnum, new_regval & 0xffff);
// OBSOLETE   parse_and_eval (expression);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE h8500_read_sp (void)
// OBSOLETE {
// OBSOLETE   return read_register (PR7_REGNUM);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE h8500_write_sp (CORE_ADDR v)
// OBSOLETE {
// OBSOLETE   write_register (PR7_REGNUM, v);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE h8500_read_pc (ptid_t ptid)
// OBSOLETE {
// OBSOLETE   return read_register (PC_REGNUM);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE h8500_write_pc (CORE_ADDR v, ptid_t ptid)
// OBSOLETE {
// OBSOLETE   write_register (PC_REGNUM, v);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE h8500_read_fp (void)
// OBSOLETE {
// OBSOLETE   return read_register (PR6_REGNUM);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_h8500_tdep (void)
// OBSOLETE {
// OBSOLETE   tm_print_insn = print_insn_h8500;
// OBSOLETE 
// OBSOLETE   add_prefix_cmd ("memory", no_class, set_memory,
// OBSOLETE 		  "set the memory model", &setmemorylist, "set memory ", 0,
// OBSOLETE 		  &setlist);
// OBSOLETE 
// OBSOLETE   add_cmd ("small", class_support, small_command,
// OBSOLETE       "Set small memory model. (16 bit code, 16 bit data)", &setmemorylist);
// OBSOLETE 
// OBSOLETE   add_cmd ("big", class_support, big_command,
// OBSOLETE 	"Set big memory model. (32 bit code, 32 bit data)", &setmemorylist);
// OBSOLETE 
// OBSOLETE   add_cmd ("medium", class_support, medium_command,
// OBSOLETE      "Set medium memory model. (32 bit code, 16 bit data)", &setmemorylist);
// OBSOLETE 
// OBSOLETE   add_cmd ("compact", class_support, compact_command,
// OBSOLETE     "Set compact memory model. (16 bit code, 32 bit data)", &setmemorylist);
// OBSOLETE 
// OBSOLETE }
@


1.18
log
@2003-02-04  Andrew Cagney  <ac131313@@redhat.com>

	* MAINTAINERS: Mark h8500 as obsolete.
	* configure.tgt (h8500-*-*): Mark h8500 code as obsolete.
	* findvar.c (value_from_register): Ditto.
	* h8500-tdep.c: Mark file as obsolete.
	* config/h8500/h8500.mt: Ditto.
	* config/h8500/tm-h8500.h: Ditto.
	* NEWS: Mention that h8500 is obsolete.
@
text
@@


1.17
log
@2002-12-11  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (deprecated_get_frame_saved_regs): Rename
	get_frame_saved_regs.
	* frame.h (deprecated_get_frame_saved_regs): Update declaration.
	* sparc-tdep.c: Update.
	* hppa-tdep.c: Update.
	* h8500-tdep.c: Update.
@
text
@d1 739
a739 739
/* Target-dependent code for Hitachi H8/500, for GDB.

   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002 Free Software
   Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/*
   Contributed by Steve Chamberlain
   sac@@cygnus.com
 */

#include "defs.h"
#include "frame.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "value.h"
#include "dis-asm.h"
#include "gdbcore.h"
#include "regcache.h"

#define UNSIGNED_SHORT(X) ((X) & 0xffff)

static int code_size = 2;

static int data_size = 2;

/* Shape of an H8/500 frame :

   arg-n
   ..
   arg-2
   arg-1
   return address <2 or 4 bytes>
   old fp         <2 bytes>
   auto-n
   ..
   auto-1
   saved registers

 */

/* an easy to debug H8 stack frame looks like:
   0x6df6               push    r6
   0x0d76       mov.w   r7,r6
   0x6dfn          push    reg
   0x7905 nnnn          mov.w  #n,r5    or   0x1b87  subs #2,sp
   0x1957               sub.w  r5,sp

 */

#define IS_PUSH(x) (((x) & 0xff00)==0x6d00)
#define IS_LINK_8(x) ((x) == 0x17)
#define IS_LINK_16(x) ((x) == 0x1f)
#define IS_MOVE_FP(x) ((x) == 0x0d76)
#define IS_MOV_SP_FP(x) ((x) == 0x0d76)
#define IS_SUB2_SP(x) ((x) == 0x1b87)
#define IS_MOVK_R5(x) ((x) == 0x7905)
#define IS_SUB_R5SP(x) ((x) == 0x1957)

#define LINK_8 0x17
#define LINK_16 0x1f

int minimum_mode = 1;

CORE_ADDR
h8500_skip_prologue (CORE_ADDR start_pc)
{
  short int w;

  w = read_memory_integer (start_pc, 1);
  if (w == LINK_8)
    {
      start_pc += 2;
      w = read_memory_integer (start_pc, 1);
    }

  if (w == LINK_16)
    {
      start_pc += 3;
      w = read_memory_integer (start_pc, 2);
    }

  return start_pc;
}

CORE_ADDR
h8500_addr_bits_remove (CORE_ADDR addr)
{
  return ((addr) & 0xffffff);
}

/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct, and
   then INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC will be
   called for the new frame.

   For us, the frame address is its stack pointer value, so we look up
   the function prologue to determine the caller's sp value, and return it.  */

CORE_ADDR
h8500_frame_chain (struct frame_info *thisframe)
{
  if (!inside_entry_file (thisframe->pc))
    return (read_memory_integer (get_frame_base (thisframe), PTR_SIZE));
  else
    return 0;
}

/* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
   is not the address of a valid instruction, the address of the next
   instruction beyond ADDR otherwise.  *PWORD1 receives the first word
   of the instruction. */

CORE_ADDR
NEXT_PROLOGUE_INSN (CORE_ADDR addr, CORE_ADDR lim, char *pword1)
{
  if (addr < lim + 8)
    {
      read_memory (addr, pword1, 1);
      read_memory (addr, pword1 + 1, 1);
      return 1;
    }
  return 0;
}

/* Examine the prologue of a function.  `ip' points to the first
   instruction.  `limit' is the limit of the prologue (e.g. the addr
   of the first linenumber, or perhaps the program counter if we're
   stepping through).  `frame_sp' is the stack pointer value in use in
   this frame.  `fsr' is a pointer to a frame_saved_regs structure
   into which we put info about the registers saved by this frame.
   `fi' is a struct frame_info pointer; we fill in various fields in
   it to reflect the offsets of the arg pointer and the locals
   pointer.  */

/* Return the saved PC from this frame. */

CORE_ADDR
frame_saved_pc (struct frame_info *frame)
{
  return read_memory_integer (get_frame_base (frame) + 2, PTR_SIZE);
}

void
h8500_pop_frame (void)
{
  unsigned regnum;
  struct frame_saved_regs fsr;
  struct frame_info *frame = get_current_frame ();

  deprecated_get_frame_saved_regs (frame, &fsr);

  for (regnum = 0; regnum < 8; regnum++)
    {
      if (fsr.regs[regnum])
	write_register (regnum, read_memory_short (fsr.regs[regnum]));

      flush_cached_frames ();
    }
}

static void
h8500_print_register_hook (int regno)
{
  if (regno == CCR_REGNUM)
    {
      /* CCR register */

      int C, Z, N, V;
      unsigned char b[2];
      unsigned char l;

      frame_register_read (deprecated_selected_frame, regno, b);
      l = b[1];
      printf_unfiltered ("\t");
      printf_unfiltered ("I-%d - ", (l & 0x80) != 0);
      N = (l & 0x8) != 0;
      Z = (l & 0x4) != 0;
      V = (l & 0x2) != 0;
      C = (l & 0x1) != 0;
      printf_unfiltered ("N-%d ", N);
      printf_unfiltered ("Z-%d ", Z);
      printf_unfiltered ("V-%d ", V);
      printf_unfiltered ("C-%d ", C);
      if ((C | Z) == 0)
	printf_unfiltered ("u> ");
      if ((C | Z) == 1)
	printf_unfiltered ("u<= ");
      if ((C == 0))
	printf_unfiltered ("u>= ");
      if (C == 1)
	printf_unfiltered ("u< ");
      if (Z == 0)
	printf_unfiltered ("!= ");
      if (Z == 1)
	printf_unfiltered ("== ");
      if ((N ^ V) == 0)
	printf_unfiltered (">= ");
      if ((N ^ V) == 1)
	printf_unfiltered ("< ");
      if ((Z | (N ^ V)) == 0)
	printf_unfiltered ("> ");
      if ((Z | (N ^ V)) == 1)
	printf_unfiltered ("<= ");
    }
}

static void
h8500_print_registers_info (struct gdbarch *gdbarch,
			    struct ui_file *file,
			    struct frame_info *frame,
			    int regnum, int print_all)
{
  int i;
  const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);

  for (i = 0; i < numregs; i++)
    {
      /* Decide between printing all regs, non-float / vector regs, or
         specific reg.  */
      if (regnum == -1)
	{
	  if (!print_all)
	    {
	      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
		continue;
	      if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)))
		continue;
	    }
	}
      else
	{
	  if (i != regnum)
	    continue;
	}

      /* If the register name is empty, it is undefined for this
         processor, so don't display anything.  */
      if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
	continue;

      fputs_filtered (REGISTER_NAME (i), file);
      print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);

      /* Get the data in raw format.  */
      if (! frame_register_read (frame, i, raw_buffer))
	{
	  fprintf_filtered (file, "*value not available*\n");
	  continue;
	}

      /* FIXME: cagney/2002-08-03: This code shouldn't be necessary.
         The function frame_register_read() should have returned the
         pre-cooked register so no conversion is necessary.  */
      /* Convert raw data to virtual format if necessary.  */
      if (REGISTER_CONVERTIBLE (i))
	{
	  REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
				       raw_buffer, virtual_buffer);
	}
      else
	{
	  memcpy (virtual_buffer, raw_buffer,
		  REGISTER_VIRTUAL_SIZE (i));
	}

      /* If virtual format is floating, print it that way, and in raw
         hex.  */
      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
	{
	  int j;

	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 0, 1, 0, Val_pretty_default);

	  fprintf_filtered (file, "\t(raw 0x");
	  for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
	    {
	      int idx;
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		idx = j;
	      else
		idx = REGISTER_RAW_SIZE (i) - 1 - j;
	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
	    }
	  fprintf_filtered (file, ")");
	}
      else
	{
	  /* Print the register in hex.  */
	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 'x', 1, 0, Val_pretty_default);
          /* If not a vector register, print it also according to its
             natural format.  */
	  if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)) == 0)
	    {
	      fprintf_filtered (file, "\t");
	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
			 file, 0, 1, 0, Val_pretty_default);
	    }
	}

      /* Some h8500 specific info.  */
      h8500_print_register_hook (i);

      fprintf_filtered (file, "\n");
    }
}

void
h8500_do_registers_info (int regnum, int all)
{
  h8500_print_registers_info (current_gdbarch, gdb_stdout, deprecated_selected_frame,
			      regnum, all);
}

int
h8500_register_size (int regno)
{
  switch (regno)
    {
    case SEG_C_REGNUM:
    case SEG_D_REGNUM:
    case SEG_E_REGNUM:
    case SEG_T_REGNUM:
      return 1;
    case R0_REGNUM:
    case R1_REGNUM:
    case R2_REGNUM:
    case R3_REGNUM:
    case R4_REGNUM:
    case R5_REGNUM:
    case R6_REGNUM:
    case R7_REGNUM:
    case CCR_REGNUM:
      return 2;

    case PR0_REGNUM:
    case PR1_REGNUM:
    case PR2_REGNUM:
    case PR3_REGNUM:
    case PR4_REGNUM:
    case PR5_REGNUM:
    case PR6_REGNUM:
    case PR7_REGNUM:
    case PC_REGNUM:
      return 4;
    default:
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }
}

struct type *
h8500_register_virtual_type (int regno)
{
  switch (regno)
    {
    case SEG_C_REGNUM:
    case SEG_E_REGNUM:
    case SEG_D_REGNUM:
    case SEG_T_REGNUM:
      return builtin_type_unsigned_char;
    case R0_REGNUM:
    case R1_REGNUM:
    case R2_REGNUM:
    case R3_REGNUM:
    case R4_REGNUM:
    case R5_REGNUM:
    case R6_REGNUM:
    case R7_REGNUM:
    case CCR_REGNUM:
      return builtin_type_unsigned_short;
    case PR0_REGNUM:
    case PR1_REGNUM:
    case PR2_REGNUM:
    case PR3_REGNUM:
    case PR4_REGNUM:
    case PR5_REGNUM:
    case PR6_REGNUM:
    case PR7_REGNUM:
    case PC_REGNUM:
      return builtin_type_unsigned_long;
    default:
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }
}

/* Put here the code to store, into a struct frame_saved_regs,
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.  */

void
frame_find_saved_regs (struct frame_info *frame_info,
		       struct frame_saved_regs *frame_saved_regs)
{
  register int regnum;
  register int regmask;
  register CORE_ADDR next_addr;
  register CORE_ADDR pc;
  unsigned char thebyte;

  memset (frame_saved_regs, '\0', sizeof *frame_saved_regs);

  if ((frame_info)->pc >= (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 4
      && (frame_info)->pc <= (frame_info)->frame)
    {
      next_addr = (frame_info)->frame;
      pc = (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 4;
    }
  else
    {
      pc = get_pc_function_start ((frame_info)->pc);
      /* Verify we have a link a6 instruction next;
         if not we lose.  If we win, find the address above the saved
         regs using the amount of storage from the link instruction.
       */

      thebyte = read_memory_integer (pc, 1);
      if (0x1f == thebyte)
	next_addr = (frame_info)->frame + read_memory_integer (pc += 1, 2), pc += 2;
      else if (0x17 == thebyte)
	next_addr = (frame_info)->frame + read_memory_integer (pc += 1, 1), pc += 1;
      else
	goto lose;
#if 0
      /* FIXME steve */
      /* If have an add:g.waddal #-n, sp next, adjust next_addr.  */
      if ((0x0c0177777 & read_memory_integer (pc, 2)) == 0157774)
	next_addr += read_memory_integer (pc += 2, 4), pc += 4;
#endif
    }

  thebyte = read_memory_integer (pc, 1);
  if (thebyte == 0x12)
    {
      /* Got stm */
      pc++;
      regmask = read_memory_integer (pc, 1);
      pc++;
      for (regnum = 0; regnum < 8; regnum++, regmask >>= 1)
	{
	  if (regmask & 1)
	    {
	      (frame_saved_regs)->regs[regnum] = (next_addr += 2) - 2;
	    }
	}
      thebyte = read_memory_integer (pc, 1);
    }
  /* Maybe got a load of pushes */
  while (thebyte == 0xbf)
    {
      pc++;
      regnum = read_memory_integer (pc, 1) & 0x7;
      pc++;
      (frame_saved_regs)->regs[regnum] = (next_addr += 2) - 2;
      thebyte = read_memory_integer (pc, 1);
    }

lose:;

  /* Remember the address of the frame pointer */
  (frame_saved_regs)->regs[FP_REGNUM] = (frame_info)->frame;

  /* This is where the old sp is hidden */
  (frame_saved_regs)->regs[SP_REGNUM] = (frame_info)->frame;

  /* And the PC - remember the pushed FP is always two bytes long */
  (frame_saved_regs)->regs[PC_REGNUM] = (frame_info)->frame + 2;
}

CORE_ADDR
saved_pc_after_call (void)
{
  int x;
  int a = read_register (SP_REGNUM);

  x = read_memory_integer (a, code_size);
  if (code_size == 2)
    {
      /* Stick current code segement onto top */
      x &= 0xffff;
      x |= read_register (SEG_C_REGNUM) << 16;
    }
  x &= 0xffffff;
  return x;
}

void
h8500_set_pointer_size (int newsize)
{
  static int oldsize = 0;

  if (oldsize != newsize)
    {
      printf_unfiltered ("pointer size set to %d bits\n", newsize);
      oldsize = newsize;
      if (newsize == 32)
	{
	  minimum_mode = 0;
	}
      else
	{
	  minimum_mode = 1;
	}
      _initialize_gdbtypes ();
    }
}

static void
big_command (char *arg, int from_tty)
{
  h8500_set_pointer_size (32);
  code_size = 4;
  data_size = 4;
}

static void
medium_command (char *arg, int from_tty)
{
  h8500_set_pointer_size (32);
  code_size = 4;
  data_size = 2;
}

static void
compact_command (char *arg, int from_tty)
{
  h8500_set_pointer_size (32);
  code_size = 2;
  data_size = 4;
}

static void
small_command (char *arg, int from_tty)
{
  h8500_set_pointer_size (16);
  code_size = 2;
  data_size = 2;
}

static struct cmd_list_element *setmemorylist;

static void
set_memory (char *args, int from_tty)
{
  printf_unfiltered ("\"set memory\" must be followed by the name of a memory subcommand.\n");
  help_list (setmemorylist, "set memory ", -1, gdb_stdout);
}

/* See if variable name is ppc or pr[0-7] */

int
h8500_is_trapped_internalvar (char *name)
{
  if (name[0] != 'p')
    return 0;

  if (strcmp (name + 1, "pc") == 0)
    return 1;

  if (name[1] == 'r'
      && name[2] >= '0'
      && name[2] <= '7'
      && name[3] == '\000')
    return 1;
  else
    return 0;
}

struct value *
h8500_value_of_trapped_internalvar (struct internalvar *var)
{
  LONGEST regval;
  unsigned char regbuf[4];
  int page_regnum, regnum;

  regnum = var->name[2] == 'c' ? PC_REGNUM : var->name[2] - '0';

  switch (var->name[2])
    {
    case 'c':
      page_regnum = SEG_C_REGNUM;
      break;
    case '0':
    case '1':
    case '2':
    case '3':
      page_regnum = SEG_D_REGNUM;
      break;
    case '4':
    case '5':
      page_regnum = SEG_E_REGNUM;
      break;
    case '6':
    case '7':
      page_regnum = SEG_T_REGNUM;
      break;
    }

  get_saved_register (regbuf, NULL, NULL, deprecated_selected_frame, page_regnum, NULL);
  regval = regbuf[0] << 16;

  get_saved_register (regbuf, NULL, NULL, deprecated_selected_frame, regnum, NULL);
  regval |= regbuf[0] << 8 | regbuf[1];		/* XXX host/target byte order */

  xfree (var->value);		/* Free up old value */

  var->value = value_from_longest (builtin_type_unsigned_long, regval);
  release_value (var->value);	/* Unchain new value */

  VALUE_LVAL (var->value) = lval_internalvar;
  VALUE_INTERNALVAR (var->value) = var;
  return var->value;
}

void
h8500_set_trapped_internalvar (struct internalvar *var, struct value *newval,
			       int bitpos, int bitsize, int offset)
{
  char *page_regnum, *regnum;
  char expression[100];
  unsigned new_regval;
  struct type *type;
  enum type_code newval_type_code;

  type = check_typedef (VALUE_TYPE (newval));
  newval_type_code = TYPE_CODE (type);

  if ((newval_type_code != TYPE_CODE_INT
       && newval_type_code != TYPE_CODE_PTR)
      || TYPE_LENGTH (type) != sizeof (new_regval))
    error ("Illegal type (%s) for assignment to $%s\n",
	   TYPE_NAME (VALUE_TYPE (newval)), var->name);

  new_regval = *(long *) VALUE_CONTENTS_RAW (newval);

  regnum = var->name + 1;

  switch (var->name[2])
    {
    case 'c':
      page_regnum = "cp";
      break;
    case '0':
    case '1':
    case '2':
    case '3':
      page_regnum = "dp";
      break;
    case '4':
    case '5':
      page_regnum = "ep";
      break;
    case '6':
    case '7':
      page_regnum = "tp";
      break;
    }

  sprintf (expression, "$%s=%d", page_regnum, new_regval >> 16);
  parse_and_eval (expression);

  sprintf (expression, "$%s=%d", regnum, new_regval & 0xffff);
  parse_and_eval (expression);
}

CORE_ADDR
h8500_read_sp (void)
{
  return read_register (PR7_REGNUM);
}

void
h8500_write_sp (CORE_ADDR v)
{
  write_register (PR7_REGNUM, v);
}

CORE_ADDR
h8500_read_pc (ptid_t ptid)
{
  return read_register (PC_REGNUM);
}

void
h8500_write_pc (CORE_ADDR v, ptid_t ptid)
{
  write_register (PC_REGNUM, v);
}

CORE_ADDR
h8500_read_fp (void)
{
  return read_register (PR6_REGNUM);
}

void
_initialize_h8500_tdep (void)
{
  tm_print_insn = print_insn_h8500;

  add_prefix_cmd ("memory", no_class, set_memory,
		  "set the memory model", &setmemorylist, "set memory ", 0,
		  &setlist);

  add_cmd ("small", class_support, small_command,
      "Set small memory model. (16 bit code, 16 bit data)", &setmemorylist);

  add_cmd ("big", class_support, big_command,
	"Set big memory model. (32 bit code, 32 bit data)", &setmemorylist);

  add_cmd ("medium", class_support, medium_command,
     "Set medium memory model. (32 bit code, 16 bit data)", &setmemorylist);

  add_cmd ("compact", class_support, compact_command,
    "Set compact memory model. (16 bit code, 32 bit data)", &setmemorylist);

}
@


1.16
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@d168 1
a168 1
  get_frame_saved_regs (frame, &fsr);
@


1.15
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d109 4
a112 3
/* Given a GDB frame, determine the address of the calling function's frame.
   This will be used to create a new GDB frame struct, and then
   INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.
@


1.14
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@d189 1
a189 1
      frame_register_read (selected_frame, regno, b);
d331 1
a331 1
  h8500_print_registers_info (current_gdbarch, gdb_stdout, selected_frame,
d620 1
a620 1
  get_saved_register (regbuf, NULL, NULL, selected_frame, page_regnum, NULL);
d623 1
a623 1
  get_saved_register (regbuf, NULL, NULL, selected_frame, regnum, NULL);
@


1.13
log
@2002-10-31  Andrew Cagney  <cagney@@redhat.com>

	* h8500-tdep.c (h8500_print_registers_info): New static function,
	clone of infcmd.c's default_print_registers_info.
	(h8500_do_registers_info): New funtion.
	(h8500_print_register_hook): Rename print_register_hook, make
	static.

	* config/h8500/tm-h8500.h: Update copyright.
	(DEPRECATED_DO_REGISTERS_INFO): Define.
	(h8500_do_registers_info: Declare.
	(PRINT_REGISTER_HOOK): Delete macro.
	(print_register_hook): Delete function.
@
text
@d120 1
a120 1
    return (read_memory_integer (FRAME_FP (thisframe), PTR_SIZE));
d157 1
a157 1
  return read_memory_integer (FRAME_FP (frame) + 2, PTR_SIZE);
@


1.12
log
@2002-07-26  Andrew Cagney  <ac131313@@redhat.com>

* z8k-tdep.c: Do not include "obstack.h".
* h8300-tdep.c, h8500-tdep.c: Ditto.
* m68hc11-tdep.c, sh-tdep.c: Ditto.
* valprint.c, v850-tdep.c: Ditto.
* d10v-tdep.c, mn10300-tdep.c: Ditto.
* mn10200-tdep.c: Ditto.

* Makefile.in (z8k-tdep.o): Update dependencies.
(m68hc11-tdep.o, valprint.o): Ditto.
(v850-tdep.o, d10v-tdep.o): Ditto.
(mn10300-tdep.o, sparc-tdep.o): Ditto.
(sh-tdep.o, h8500-tdep.o, h8300-tdep.o): Ditto.
(m32r-tdep.o, mn10200-tdep.o): Specify dependencies.
(sh_opc_h, gdb_sim_sh_h): Define.
(elf_sh_h, elf_bfd_h): Define.
(opcode_m68hc11_h): Define.
(OPCODES_SRC, OPCODES_DIR): define.
(OPCODES): Use $(OPCODES_DIR).
(gdb_sim_d10v_h): Rename sim_d10v_h.
(gdb_sim_arm_h): Rename sim_arm_h.
@
text
@d178 2
a179 2
void
print_register_hook (int regno)
d222 111
@


1.12.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.12.8.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d178 2
a179 2
static void
h8500_print_register_hook (int regno)
a221 111
}

static void
h8500_print_registers_info (struct gdbarch *gdbarch,
			    struct ui_file *file,
			    struct frame_info *frame,
			    int regnum, int print_all)
{
  int i;
  const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);

  for (i = 0; i < numregs; i++)
    {
      /* Decide between printing all regs, non-float / vector regs, or
         specific reg.  */
      if (regnum == -1)
	{
	  if (!print_all)
	    {
	      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
		continue;
	      if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)))
		continue;
	    }
	}
      else
	{
	  if (i != regnum)
	    continue;
	}

      /* If the register name is empty, it is undefined for this
         processor, so don't display anything.  */
      if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
	continue;

      fputs_filtered (REGISTER_NAME (i), file);
      print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);

      /* Get the data in raw format.  */
      if (! frame_register_read (frame, i, raw_buffer))
	{
	  fprintf_filtered (file, "*value not available*\n");
	  continue;
	}

      /* FIXME: cagney/2002-08-03: This code shouldn't be necessary.
         The function frame_register_read() should have returned the
         pre-cooked register so no conversion is necessary.  */
      /* Convert raw data to virtual format if necessary.  */
      if (REGISTER_CONVERTIBLE (i))
	{
	  REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
				       raw_buffer, virtual_buffer);
	}
      else
	{
	  memcpy (virtual_buffer, raw_buffer,
		  REGISTER_VIRTUAL_SIZE (i));
	}

      /* If virtual format is floating, print it that way, and in raw
         hex.  */
      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
	{
	  int j;

	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 0, 1, 0, Val_pretty_default);

	  fprintf_filtered (file, "\t(raw 0x");
	  for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
	    {
	      int idx;
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		idx = j;
	      else
		idx = REGISTER_RAW_SIZE (i) - 1 - j;
	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
	    }
	  fprintf_filtered (file, ")");
	}
      else
	{
	  /* Print the register in hex.  */
	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 'x', 1, 0, Val_pretty_default);
          /* If not a vector register, print it also according to its
             natural format.  */
	  if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)) == 0)
	    {
	      fprintf_filtered (file, "\t");
	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
			 file, 0, 1, 0, Val_pretty_default);
	    }
	}

      /* Some h8500 specific info.  */
      h8500_print_register_hook (i);

      fprintf_filtered (file, "\n");
    }
}

void
h8500_do_registers_info (int regnum, int all)
{
  h8500_print_registers_info (current_gdbarch, gdb_stdout, selected_frame,
			      regnum, all);
@


1.12.8.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d109 3
a111 4
/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct, and
   then INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC will be
   called for the new frame.
d120 1
a120 1
    return (read_memory_integer (get_frame_base (thisframe), PTR_SIZE));
d157 1
a157 1
  return read_memory_integer (get_frame_base (frame) + 2, PTR_SIZE);
d167 1
a167 1
  deprecated_get_frame_saved_regs (frame, &fsr);
d189 1
a189 1
      frame_register_read (deprecated_selected_frame, regno, b);
d331 1
a331 1
  h8500_print_registers_info (current_gdbarch, gdb_stdout, deprecated_selected_frame,
d620 1
a620 1
  get_saved_register (regbuf, NULL, NULL, deprecated_selected_frame, page_regnum, NULL);
d623 1
a623 1
  get_saved_register (regbuf, NULL, NULL, deprecated_selected_frame, regnum, NULL);
@


1.12.8.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d1 739
a739 739
// OBSOLETE /* Target-dependent code for Hitachi H8/500, for GDB.
// OBSOLETE 
// OBSOLETE    Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002 Free Software
// OBSOLETE    Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE    Contributed by Steve Chamberlain
// OBSOLETE    sac@@cygnus.com
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "gdbtypes.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "dis-asm.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #define UNSIGNED_SHORT(X) ((X) & 0xffff)
// OBSOLETE 
// OBSOLETE static int code_size = 2;
// OBSOLETE 
// OBSOLETE static int data_size = 2;
// OBSOLETE 
// OBSOLETE /* Shape of an H8/500 frame :
// OBSOLETE 
// OBSOLETE    arg-n
// OBSOLETE    ..
// OBSOLETE    arg-2
// OBSOLETE    arg-1
// OBSOLETE    return address <2 or 4 bytes>
// OBSOLETE    old fp         <2 bytes>
// OBSOLETE    auto-n
// OBSOLETE    ..
// OBSOLETE    auto-1
// OBSOLETE    saved registers
// OBSOLETE 
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /* an easy to debug H8 stack frame looks like:
// OBSOLETE    0x6df6               push    r6
// OBSOLETE    0x0d76       mov.w   r7,r6
// OBSOLETE    0x6dfn          push    reg
// OBSOLETE    0x7905 nnnn          mov.w  #n,r5    or   0x1b87  subs #2,sp
// OBSOLETE    0x1957               sub.w  r5,sp
// OBSOLETE 
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE #define IS_PUSH(x) (((x) & 0xff00)==0x6d00)
// OBSOLETE #define IS_LINK_8(x) ((x) == 0x17)
// OBSOLETE #define IS_LINK_16(x) ((x) == 0x1f)
// OBSOLETE #define IS_MOVE_FP(x) ((x) == 0x0d76)
// OBSOLETE #define IS_MOV_SP_FP(x) ((x) == 0x0d76)
// OBSOLETE #define IS_SUB2_SP(x) ((x) == 0x1b87)
// OBSOLETE #define IS_MOVK_R5(x) ((x) == 0x7905)
// OBSOLETE #define IS_SUB_R5SP(x) ((x) == 0x1957)
// OBSOLETE 
// OBSOLETE #define LINK_8 0x17
// OBSOLETE #define LINK_16 0x1f
// OBSOLETE 
// OBSOLETE int minimum_mode = 1;
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE h8500_skip_prologue (CORE_ADDR start_pc)
// OBSOLETE {
// OBSOLETE   short int w;
// OBSOLETE 
// OBSOLETE   w = read_memory_integer (start_pc, 1);
// OBSOLETE   if (w == LINK_8)
// OBSOLETE     {
// OBSOLETE       start_pc += 2;
// OBSOLETE       w = read_memory_integer (start_pc, 1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (w == LINK_16)
// OBSOLETE     {
// OBSOLETE       start_pc += 3;
// OBSOLETE       w = read_memory_integer (start_pc, 2);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   return start_pc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE h8500_addr_bits_remove (CORE_ADDR addr)
// OBSOLETE {
// OBSOLETE   return ((addr) & 0xffffff);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Given a GDB frame, determine the address of the calling function's
// OBSOLETE    frame.  This will be used to create a new GDB frame struct, and
// OBSOLETE    then INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC will be
// OBSOLETE    called for the new frame.
// OBSOLETE 
// OBSOLETE    For us, the frame address is its stack pointer value, so we look up
// OBSOLETE    the function prologue to determine the caller's sp value, and return it.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE h8500_frame_chain (struct frame_info *thisframe)
// OBSOLETE {
// OBSOLETE   if (!inside_entry_file (thisframe->pc))
// OBSOLETE     return (read_memory_integer (get_frame_base (thisframe), PTR_SIZE));
// OBSOLETE   else
// OBSOLETE     return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
// OBSOLETE    is not the address of a valid instruction, the address of the next
// OBSOLETE    instruction beyond ADDR otherwise.  *PWORD1 receives the first word
// OBSOLETE    of the instruction. */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE NEXT_PROLOGUE_INSN (CORE_ADDR addr, CORE_ADDR lim, char *pword1)
// OBSOLETE {
// OBSOLETE   if (addr < lim + 8)
// OBSOLETE     {
// OBSOLETE       read_memory (addr, pword1, 1);
// OBSOLETE       read_memory (addr, pword1 + 1, 1);
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Examine the prologue of a function.  `ip' points to the first
// OBSOLETE    instruction.  `limit' is the limit of the prologue (e.g. the addr
// OBSOLETE    of the first linenumber, or perhaps the program counter if we're
// OBSOLETE    stepping through).  `frame_sp' is the stack pointer value in use in
// OBSOLETE    this frame.  `fsr' is a pointer to a frame_saved_regs structure
// OBSOLETE    into which we put info about the registers saved by this frame.
// OBSOLETE    `fi' is a struct frame_info pointer; we fill in various fields in
// OBSOLETE    it to reflect the offsets of the arg pointer and the locals
// OBSOLETE    pointer.  */
// OBSOLETE 
// OBSOLETE /* Return the saved PC from this frame. */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_saved_pc (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   return read_memory_integer (get_frame_base (frame) + 2, PTR_SIZE);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE h8500_pop_frame (void)
// OBSOLETE {
// OBSOLETE   unsigned regnum;
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE   struct frame_info *frame = get_current_frame ();
// OBSOLETE 
// OBSOLETE   deprecated_get_frame_saved_regs (frame, &fsr);
// OBSOLETE 
// OBSOLETE   for (regnum = 0; regnum < 8; regnum++)
// OBSOLETE     {
// OBSOLETE       if (fsr.regs[regnum])
// OBSOLETE 	write_register (regnum, read_memory_short (fsr.regs[regnum]));
// OBSOLETE 
// OBSOLETE       flush_cached_frames ();
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE h8500_print_register_hook (int regno)
// OBSOLETE {
// OBSOLETE   if (regno == CCR_REGNUM)
// OBSOLETE     {
// OBSOLETE       /* CCR register */
// OBSOLETE 
// OBSOLETE       int C, Z, N, V;
// OBSOLETE       unsigned char b[2];
// OBSOLETE       unsigned char l;
// OBSOLETE 
// OBSOLETE       frame_register_read (deprecated_selected_frame, regno, b);
// OBSOLETE       l = b[1];
// OBSOLETE       printf_unfiltered ("\t");
// OBSOLETE       printf_unfiltered ("I-%d - ", (l & 0x80) != 0);
// OBSOLETE       N = (l & 0x8) != 0;
// OBSOLETE       Z = (l & 0x4) != 0;
// OBSOLETE       V = (l & 0x2) != 0;
// OBSOLETE       C = (l & 0x1) != 0;
// OBSOLETE       printf_unfiltered ("N-%d ", N);
// OBSOLETE       printf_unfiltered ("Z-%d ", Z);
// OBSOLETE       printf_unfiltered ("V-%d ", V);
// OBSOLETE       printf_unfiltered ("C-%d ", C);
// OBSOLETE       if ((C | Z) == 0)
// OBSOLETE 	printf_unfiltered ("u> ");
// OBSOLETE       if ((C | Z) == 1)
// OBSOLETE 	printf_unfiltered ("u<= ");
// OBSOLETE       if ((C == 0))
// OBSOLETE 	printf_unfiltered ("u>= ");
// OBSOLETE       if (C == 1)
// OBSOLETE 	printf_unfiltered ("u< ");
// OBSOLETE       if (Z == 0)
// OBSOLETE 	printf_unfiltered ("!= ");
// OBSOLETE       if (Z == 1)
// OBSOLETE 	printf_unfiltered ("== ");
// OBSOLETE       if ((N ^ V) == 0)
// OBSOLETE 	printf_unfiltered (">= ");
// OBSOLETE       if ((N ^ V) == 1)
// OBSOLETE 	printf_unfiltered ("< ");
// OBSOLETE       if ((Z | (N ^ V)) == 0)
// OBSOLETE 	printf_unfiltered ("> ");
// OBSOLETE       if ((Z | (N ^ V)) == 1)
// OBSOLETE 	printf_unfiltered ("<= ");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE h8500_print_registers_info (struct gdbarch *gdbarch,
// OBSOLETE 			    struct ui_file *file,
// OBSOLETE 			    struct frame_info *frame,
// OBSOLETE 			    int regnum, int print_all)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE   const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
// OBSOLETE   char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
// OBSOLETE   char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);
// OBSOLETE 
// OBSOLETE   for (i = 0; i < numregs; i++)
// OBSOLETE     {
// OBSOLETE       /* Decide between printing all regs, non-float / vector regs, or
// OBSOLETE          specific reg.  */
// OBSOLETE       if (regnum == -1)
// OBSOLETE 	{
// OBSOLETE 	  if (!print_all)
// OBSOLETE 	    {
// OBSOLETE 	      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
// OBSOLETE 		continue;
// OBSOLETE 	      if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)))
// OBSOLETE 		continue;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  if (i != regnum)
// OBSOLETE 	    continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* If the register name is empty, it is undefined for this
// OBSOLETE          processor, so don't display anything.  */
// OBSOLETE       if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
// OBSOLETE 	continue;
// OBSOLETE 
// OBSOLETE       fputs_filtered (REGISTER_NAME (i), file);
// OBSOLETE       print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);
// OBSOLETE 
// OBSOLETE       /* Get the data in raw format.  */
// OBSOLETE       if (! frame_register_read (frame, i, raw_buffer))
// OBSOLETE 	{
// OBSOLETE 	  fprintf_filtered (file, "*value not available*\n");
// OBSOLETE 	  continue;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* FIXME: cagney/2002-08-03: This code shouldn't be necessary.
// OBSOLETE          The function frame_register_read() should have returned the
// OBSOLETE          pre-cooked register so no conversion is necessary.  */
// OBSOLETE       /* Convert raw data to virtual format if necessary.  */
// OBSOLETE       if (REGISTER_CONVERTIBLE (i))
// OBSOLETE 	{
// OBSOLETE 	  REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
// OBSOLETE 				       raw_buffer, virtual_buffer);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  memcpy (virtual_buffer, raw_buffer,
// OBSOLETE 		  REGISTER_VIRTUAL_SIZE (i));
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* If virtual format is floating, print it that way, and in raw
// OBSOLETE          hex.  */
// OBSOLETE       if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
// OBSOLETE 	{
// OBSOLETE 	  int j;
// OBSOLETE 
// OBSOLETE 	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
// OBSOLETE 		     file, 0, 1, 0, Val_pretty_default);
// OBSOLETE 
// OBSOLETE 	  fprintf_filtered (file, "\t(raw 0x");
// OBSOLETE 	  for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
// OBSOLETE 	    {
// OBSOLETE 	      int idx;
// OBSOLETE 	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
// OBSOLETE 		idx = j;
// OBSOLETE 	      else
// OBSOLETE 		idx = REGISTER_RAW_SIZE (i) - 1 - j;
// OBSOLETE 	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
// OBSOLETE 	    }
// OBSOLETE 	  fprintf_filtered (file, ")");
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* Print the register in hex.  */
// OBSOLETE 	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
// OBSOLETE 		     file, 'x', 1, 0, Val_pretty_default);
// OBSOLETE           /* If not a vector register, print it also according to its
// OBSOLETE              natural format.  */
// OBSOLETE 	  if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)) == 0)
// OBSOLETE 	    {
// OBSOLETE 	      fprintf_filtered (file, "\t");
// OBSOLETE 	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
// OBSOLETE 			 file, 0, 1, 0, Val_pretty_default);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       /* Some h8500 specific info.  */
// OBSOLETE       h8500_print_register_hook (i);
// OBSOLETE 
// OBSOLETE       fprintf_filtered (file, "\n");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE h8500_do_registers_info (int regnum, int all)
// OBSOLETE {
// OBSOLETE   h8500_print_registers_info (current_gdbarch, gdb_stdout, deprecated_selected_frame,
// OBSOLETE 			      regnum, all);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE h8500_register_size (int regno)
// OBSOLETE {
// OBSOLETE   switch (regno)
// OBSOLETE     {
// OBSOLETE     case SEG_C_REGNUM:
// OBSOLETE     case SEG_D_REGNUM:
// OBSOLETE     case SEG_E_REGNUM:
// OBSOLETE     case SEG_T_REGNUM:
// OBSOLETE       return 1;
// OBSOLETE     case R0_REGNUM:
// OBSOLETE     case R1_REGNUM:
// OBSOLETE     case R2_REGNUM:
// OBSOLETE     case R3_REGNUM:
// OBSOLETE     case R4_REGNUM:
// OBSOLETE     case R5_REGNUM:
// OBSOLETE     case R6_REGNUM:
// OBSOLETE     case R7_REGNUM:
// OBSOLETE     case CCR_REGNUM:
// OBSOLETE       return 2;
// OBSOLETE 
// OBSOLETE     case PR0_REGNUM:
// OBSOLETE     case PR1_REGNUM:
// OBSOLETE     case PR2_REGNUM:
// OBSOLETE     case PR3_REGNUM:
// OBSOLETE     case PR4_REGNUM:
// OBSOLETE     case PR5_REGNUM:
// OBSOLETE     case PR6_REGNUM:
// OBSOLETE     case PR7_REGNUM:
// OBSOLETE     case PC_REGNUM:
// OBSOLETE       return 4;
// OBSOLETE     default:
// OBSOLETE       internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct type *
// OBSOLETE h8500_register_virtual_type (int regno)
// OBSOLETE {
// OBSOLETE   switch (regno)
// OBSOLETE     {
// OBSOLETE     case SEG_C_REGNUM:
// OBSOLETE     case SEG_E_REGNUM:
// OBSOLETE     case SEG_D_REGNUM:
// OBSOLETE     case SEG_T_REGNUM:
// OBSOLETE       return builtin_type_unsigned_char;
// OBSOLETE     case R0_REGNUM:
// OBSOLETE     case R1_REGNUM:
// OBSOLETE     case R2_REGNUM:
// OBSOLETE     case R3_REGNUM:
// OBSOLETE     case R4_REGNUM:
// OBSOLETE     case R5_REGNUM:
// OBSOLETE     case R6_REGNUM:
// OBSOLETE     case R7_REGNUM:
// OBSOLETE     case CCR_REGNUM:
// OBSOLETE       return builtin_type_unsigned_short;
// OBSOLETE     case PR0_REGNUM:
// OBSOLETE     case PR1_REGNUM:
// OBSOLETE     case PR2_REGNUM:
// OBSOLETE     case PR3_REGNUM:
// OBSOLETE     case PR4_REGNUM:
// OBSOLETE     case PR5_REGNUM:
// OBSOLETE     case PR6_REGNUM:
// OBSOLETE     case PR7_REGNUM:
// OBSOLETE     case PC_REGNUM:
// OBSOLETE       return builtin_type_unsigned_long;
// OBSOLETE     default:
// OBSOLETE       internal_error (__FILE__, __LINE__, "failed internal consistency check");
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Put here the code to store, into a struct frame_saved_regs,
// OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO.
// OBSOLETE    This includes special registers such as pc and fp saved in special
// OBSOLETE    ways in the stack frame.  sp is even more special:
// OBSOLETE    the address we return for it IS the sp for the next frame.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE frame_find_saved_regs (struct frame_info *frame_info,
// OBSOLETE 		       struct frame_saved_regs *frame_saved_regs)
// OBSOLETE {
// OBSOLETE   register int regnum;
// OBSOLETE   register int regmask;
// OBSOLETE   register CORE_ADDR next_addr;
// OBSOLETE   register CORE_ADDR pc;
// OBSOLETE   unsigned char thebyte;
// OBSOLETE 
// OBSOLETE   memset (frame_saved_regs, '\0', sizeof *frame_saved_regs);
// OBSOLETE 
// OBSOLETE   if ((frame_info)->pc >= (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 4
// OBSOLETE       && (frame_info)->pc <= (frame_info)->frame)
// OBSOLETE     {
// OBSOLETE       next_addr = (frame_info)->frame;
// OBSOLETE       pc = (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 4;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       pc = get_pc_function_start ((frame_info)->pc);
// OBSOLETE       /* Verify we have a link a6 instruction next;
// OBSOLETE          if not we lose.  If we win, find the address above the saved
// OBSOLETE          regs using the amount of storage from the link instruction.
// OBSOLETE        */
// OBSOLETE 
// OBSOLETE       thebyte = read_memory_integer (pc, 1);
// OBSOLETE       if (0x1f == thebyte)
// OBSOLETE 	next_addr = (frame_info)->frame + read_memory_integer (pc += 1, 2), pc += 2;
// OBSOLETE       else if (0x17 == thebyte)
// OBSOLETE 	next_addr = (frame_info)->frame + read_memory_integer (pc += 1, 1), pc += 1;
// OBSOLETE       else
// OBSOLETE 	goto lose;
// OBSOLETE #if 0
// OBSOLETE       /* FIXME steve */
// OBSOLETE       /* If have an add:g.waddal #-n, sp next, adjust next_addr.  */
// OBSOLETE       if ((0x0c0177777 & read_memory_integer (pc, 2)) == 0157774)
// OBSOLETE 	next_addr += read_memory_integer (pc += 2, 4), pc += 4;
// OBSOLETE #endif
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   thebyte = read_memory_integer (pc, 1);
// OBSOLETE   if (thebyte == 0x12)
// OBSOLETE     {
// OBSOLETE       /* Got stm */
// OBSOLETE       pc++;
// OBSOLETE       regmask = read_memory_integer (pc, 1);
// OBSOLETE       pc++;
// OBSOLETE       for (regnum = 0; regnum < 8; regnum++, regmask >>= 1)
// OBSOLETE 	{
// OBSOLETE 	  if (regmask & 1)
// OBSOLETE 	    {
// OBSOLETE 	      (frame_saved_regs)->regs[regnum] = (next_addr += 2) - 2;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE       thebyte = read_memory_integer (pc, 1);
// OBSOLETE     }
// OBSOLETE   /* Maybe got a load of pushes */
// OBSOLETE   while (thebyte == 0xbf)
// OBSOLETE     {
// OBSOLETE       pc++;
// OBSOLETE       regnum = read_memory_integer (pc, 1) & 0x7;
// OBSOLETE       pc++;
// OBSOLETE       (frame_saved_regs)->regs[regnum] = (next_addr += 2) - 2;
// OBSOLETE       thebyte = read_memory_integer (pc, 1);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE lose:;
// OBSOLETE 
// OBSOLETE   /* Remember the address of the frame pointer */
// OBSOLETE   (frame_saved_regs)->regs[FP_REGNUM] = (frame_info)->frame;
// OBSOLETE 
// OBSOLETE   /* This is where the old sp is hidden */
// OBSOLETE   (frame_saved_regs)->regs[SP_REGNUM] = (frame_info)->frame;
// OBSOLETE 
// OBSOLETE   /* And the PC - remember the pushed FP is always two bytes long */
// OBSOLETE   (frame_saved_regs)->regs[PC_REGNUM] = (frame_info)->frame + 2;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE saved_pc_after_call (void)
// OBSOLETE {
// OBSOLETE   int x;
// OBSOLETE   int a = read_register (SP_REGNUM);
// OBSOLETE 
// OBSOLETE   x = read_memory_integer (a, code_size);
// OBSOLETE   if (code_size == 2)
// OBSOLETE     {
// OBSOLETE       /* Stick current code segement onto top */
// OBSOLETE       x &= 0xffff;
// OBSOLETE       x |= read_register (SEG_C_REGNUM) << 16;
// OBSOLETE     }
// OBSOLETE   x &= 0xffffff;
// OBSOLETE   return x;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE h8500_set_pointer_size (int newsize)
// OBSOLETE {
// OBSOLETE   static int oldsize = 0;
// OBSOLETE 
// OBSOLETE   if (oldsize != newsize)
// OBSOLETE     {
// OBSOLETE       printf_unfiltered ("pointer size set to %d bits\n", newsize);
// OBSOLETE       oldsize = newsize;
// OBSOLETE       if (newsize == 32)
// OBSOLETE 	{
// OBSOLETE 	  minimum_mode = 0;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  minimum_mode = 1;
// OBSOLETE 	}
// OBSOLETE       _initialize_gdbtypes ();
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE big_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   h8500_set_pointer_size (32);
// OBSOLETE   code_size = 4;
// OBSOLETE   data_size = 4;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE medium_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   h8500_set_pointer_size (32);
// OBSOLETE   code_size = 4;
// OBSOLETE   data_size = 2;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE compact_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   h8500_set_pointer_size (32);
// OBSOLETE   code_size = 2;
// OBSOLETE   data_size = 4;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE small_command (char *arg, int from_tty)
// OBSOLETE {
// OBSOLETE   h8500_set_pointer_size (16);
// OBSOLETE   code_size = 2;
// OBSOLETE   data_size = 2;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static struct cmd_list_element *setmemorylist;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE set_memory (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   printf_unfiltered ("\"set memory\" must be followed by the name of a memory subcommand.\n");
// OBSOLETE   help_list (setmemorylist, "set memory ", -1, gdb_stdout);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* See if variable name is ppc or pr[0-7] */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE h8500_is_trapped_internalvar (char *name)
// OBSOLETE {
// OBSOLETE   if (name[0] != 'p')
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   if (strcmp (name + 1, "pc") == 0)
// OBSOLETE     return 1;
// OBSOLETE 
// OBSOLETE   if (name[1] == 'r'
// OBSOLETE       && name[2] >= '0'
// OBSOLETE       && name[2] <= '7'
// OBSOLETE       && name[3] == '\000')
// OBSOLETE     return 1;
// OBSOLETE   else
// OBSOLETE     return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE struct value *
// OBSOLETE h8500_value_of_trapped_internalvar (struct internalvar *var)
// OBSOLETE {
// OBSOLETE   LONGEST regval;
// OBSOLETE   unsigned char regbuf[4];
// OBSOLETE   int page_regnum, regnum;
// OBSOLETE 
// OBSOLETE   regnum = var->name[2] == 'c' ? PC_REGNUM : var->name[2] - '0';
// OBSOLETE 
// OBSOLETE   switch (var->name[2])
// OBSOLETE     {
// OBSOLETE     case 'c':
// OBSOLETE       page_regnum = SEG_C_REGNUM;
// OBSOLETE       break;
// OBSOLETE     case '0':
// OBSOLETE     case '1':
// OBSOLETE     case '2':
// OBSOLETE     case '3':
// OBSOLETE       page_regnum = SEG_D_REGNUM;
// OBSOLETE       break;
// OBSOLETE     case '4':
// OBSOLETE     case '5':
// OBSOLETE       page_regnum = SEG_E_REGNUM;
// OBSOLETE       break;
// OBSOLETE     case '6':
// OBSOLETE     case '7':
// OBSOLETE       page_regnum = SEG_T_REGNUM;
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   get_saved_register (regbuf, NULL, NULL, deprecated_selected_frame, page_regnum, NULL);
// OBSOLETE   regval = regbuf[0] << 16;
// OBSOLETE 
// OBSOLETE   get_saved_register (regbuf, NULL, NULL, deprecated_selected_frame, regnum, NULL);
// OBSOLETE   regval |= regbuf[0] << 8 | regbuf[1];		/* XXX host/target byte order */
// OBSOLETE 
// OBSOLETE   xfree (var->value);		/* Free up old value */
// OBSOLETE 
// OBSOLETE   var->value = value_from_longest (builtin_type_unsigned_long, regval);
// OBSOLETE   release_value (var->value);	/* Unchain new value */
// OBSOLETE 
// OBSOLETE   VALUE_LVAL (var->value) = lval_internalvar;
// OBSOLETE   VALUE_INTERNALVAR (var->value) = var;
// OBSOLETE   return var->value;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE h8500_set_trapped_internalvar (struct internalvar *var, struct value *newval,
// OBSOLETE 			       int bitpos, int bitsize, int offset)
// OBSOLETE {
// OBSOLETE   char *page_regnum, *regnum;
// OBSOLETE   char expression[100];
// OBSOLETE   unsigned new_regval;
// OBSOLETE   struct type *type;
// OBSOLETE   enum type_code newval_type_code;
// OBSOLETE 
// OBSOLETE   type = check_typedef (VALUE_TYPE (newval));
// OBSOLETE   newval_type_code = TYPE_CODE (type);
// OBSOLETE 
// OBSOLETE   if ((newval_type_code != TYPE_CODE_INT
// OBSOLETE        && newval_type_code != TYPE_CODE_PTR)
// OBSOLETE       || TYPE_LENGTH (type) != sizeof (new_regval))
// OBSOLETE     error ("Illegal type (%s) for assignment to $%s\n",
// OBSOLETE 	   TYPE_NAME (VALUE_TYPE (newval)), var->name);
// OBSOLETE 
// OBSOLETE   new_regval = *(long *) VALUE_CONTENTS_RAW (newval);
// OBSOLETE 
// OBSOLETE   regnum = var->name + 1;
// OBSOLETE 
// OBSOLETE   switch (var->name[2])
// OBSOLETE     {
// OBSOLETE     case 'c':
// OBSOLETE       page_regnum = "cp";
// OBSOLETE       break;
// OBSOLETE     case '0':
// OBSOLETE     case '1':
// OBSOLETE     case '2':
// OBSOLETE     case '3':
// OBSOLETE       page_regnum = "dp";
// OBSOLETE       break;
// OBSOLETE     case '4':
// OBSOLETE     case '5':
// OBSOLETE       page_regnum = "ep";
// OBSOLETE       break;
// OBSOLETE     case '6':
// OBSOLETE     case '7':
// OBSOLETE       page_regnum = "tp";
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   sprintf (expression, "$%s=%d", page_regnum, new_regval >> 16);
// OBSOLETE   parse_and_eval (expression);
// OBSOLETE 
// OBSOLETE   sprintf (expression, "$%s=%d", regnum, new_regval & 0xffff);
// OBSOLETE   parse_and_eval (expression);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE h8500_read_sp (void)
// OBSOLETE {
// OBSOLETE   return read_register (PR7_REGNUM);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE h8500_write_sp (CORE_ADDR v)
// OBSOLETE {
// OBSOLETE   write_register (PR7_REGNUM, v);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE h8500_read_pc (ptid_t ptid)
// OBSOLETE {
// OBSOLETE   return read_register (PC_REGNUM);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE h8500_write_pc (CORE_ADDR v, ptid_t ptid)
// OBSOLETE {
// OBSOLETE   write_register (PC_REGNUM, v);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE h8500_read_fp (void)
// OBSOLETE {
// OBSOLETE   return read_register (PR6_REGNUM);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_h8500_tdep (void)
// OBSOLETE {
// OBSOLETE   tm_print_insn = print_insn_h8500;
// OBSOLETE 
// OBSOLETE   add_prefix_cmd ("memory", no_class, set_memory,
// OBSOLETE 		  "set the memory model", &setmemorylist, "set memory ", 0,
// OBSOLETE 		  &setlist);
// OBSOLETE 
// OBSOLETE   add_cmd ("small", class_support, small_command,
// OBSOLETE       "Set small memory model. (16 bit code, 16 bit data)", &setmemorylist);
// OBSOLETE 
// OBSOLETE   add_cmd ("big", class_support, big_command,
// OBSOLETE 	"Set big memory model. (32 bit code, 32 bit data)", &setmemorylist);
// OBSOLETE 
// OBSOLETE   add_cmd ("medium", class_support, medium_command,
// OBSOLETE      "Set medium memory model. (32 bit code, 16 bit data)", &setmemorylist);
// OBSOLETE 
// OBSOLETE   add_cmd ("compact", class_support, compact_command,
// OBSOLETE     "Set compact memory model. (16 bit code, 32 bit data)", &setmemorylist);
// OBSOLETE 
// OBSOLETE }
@


1.12.8.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@@


1.11
log
@* defs.h (read_relative_register_raw_bytes): Delete declaration.
* frame.c (frame_register_read): New function.  Return non-zero on
success.
(read_relative_register_raw_bytes_for_frame): Delete.
(read_relative_register_raw_bytes): Delete.
* frame.h (frame_register_read): Declare.
* d30v-tdep.c: Update Copyright.  Use frame_register_read.
* sh-tdep.c: Ditto.
* infcmd.c (do_registers_info): Ditto.
* hppa-tdep.c: Ditto.
* rs6000-tdep.c: Ditto.
* h8500-tdep.c: Ditto.
* mips-tdep.c: Ditto.
* h8300-tdep.c: Ditto.
* z8k-tdep.c: Ditto.
@
text
@a29 1
#include "obstack.h"
@


1.11.6.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d30 1
@


1.11.6.2
log
@merge from mainline
@
text
@d178 2
a179 2
static void
h8500_print_register_hook (int regno)
a221 111
}

static void
h8500_print_registers_info (struct gdbarch *gdbarch,
			    struct ui_file *file,
			    struct frame_info *frame,
			    int regnum, int print_all)
{
  int i;
  const int numregs = NUM_REGS + NUM_PSEUDO_REGS;
  char *raw_buffer = alloca (MAX_REGISTER_RAW_SIZE);
  char *virtual_buffer = alloca (MAX_REGISTER_VIRTUAL_SIZE);

  for (i = 0; i < numregs; i++)
    {
      /* Decide between printing all regs, non-float / vector regs, or
         specific reg.  */
      if (regnum == -1)
	{
	  if (!print_all)
	    {
	      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
		continue;
	      if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)))
		continue;
	    }
	}
      else
	{
	  if (i != regnum)
	    continue;
	}

      /* If the register name is empty, it is undefined for this
         processor, so don't display anything.  */
      if (REGISTER_NAME (i) == NULL || *(REGISTER_NAME (i)) == '\0')
	continue;

      fputs_filtered (REGISTER_NAME (i), file);
      print_spaces_filtered (15 - strlen (REGISTER_NAME (i)), file);

      /* Get the data in raw format.  */
      if (! frame_register_read (frame, i, raw_buffer))
	{
	  fprintf_filtered (file, "*value not available*\n");
	  continue;
	}

      /* FIXME: cagney/2002-08-03: This code shouldn't be necessary.
         The function frame_register_read() should have returned the
         pre-cooked register so no conversion is necessary.  */
      /* Convert raw data to virtual format if necessary.  */
      if (REGISTER_CONVERTIBLE (i))
	{
	  REGISTER_CONVERT_TO_VIRTUAL (i, REGISTER_VIRTUAL_TYPE (i),
				       raw_buffer, virtual_buffer);
	}
      else
	{
	  memcpy (virtual_buffer, raw_buffer,
		  REGISTER_VIRTUAL_SIZE (i));
	}

      /* If virtual format is floating, print it that way, and in raw
         hex.  */
      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (i)) == TYPE_CODE_FLT)
	{
	  int j;

	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 0, 1, 0, Val_pretty_default);

	  fprintf_filtered (file, "\t(raw 0x");
	  for (j = 0; j < REGISTER_RAW_SIZE (i); j++)
	    {
	      int idx;
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		idx = j;
	      else
		idx = REGISTER_RAW_SIZE (i) - 1 - j;
	      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
	    }
	  fprintf_filtered (file, ")");
	}
      else
	{
	  /* Print the register in hex.  */
	  val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
		     file, 'x', 1, 0, Val_pretty_default);
          /* If not a vector register, print it also according to its
             natural format.  */
	  if (TYPE_VECTOR (REGISTER_VIRTUAL_TYPE (i)) == 0)
	    {
	      fprintf_filtered (file, "\t");
	      val_print (REGISTER_VIRTUAL_TYPE (i), virtual_buffer, 0, 0,
			 file, 0, 1, 0, Val_pretty_default);
	    }
	}

      /* Some h8500 specific info.  */
      h8500_print_register_hook (i);

      fprintf_filtered (file, "\n");
    }
}

void
h8500_do_registers_info (int regnum, int all)
{
  h8500_print_registers_info (current_gdbarch, gdb_stdout, selected_frame,
			      regnum, all);
@


1.10
log
@* h8500-tdep.c (h8500_write_fp): Delete function.
* dwarf2cfi.c (cfi_write_fp): Document as not used.
* mips-tdep.c (mips_gdbarch_init): Do not set write_fp.
* ia64-tdep.c (ia64_gdbarch_init): Do not set write_fp.
* m68hc11-tdep.c (m68hc11_gdbarch_init): Do not set write_fp.
* rs6000-tdep.c (rs6000_gdbarch_init): Do not set write_fp.
* s390-tdep.c (s390_gdbarch_init): Do not set write_fp.
(s390_write_fp):
* sh-tdep.c (sh_gdbarch_init): Do not set write_fp.
* x86-64-tdep.c (i386_gdbarch_init): Do not set write_fp.
* d10v-tdep.c (d10v_gdbarch_init): Do not set write_fp.
(d10v_write_fp): Delete function.
* inferior.h (write_fp, generic_target_write_fp): Delete
declarations.
* regcache.c (generic_target_write_fp): Delete function.
(write_fp): Delete function.
* gdbarch.sh (TARGET_WRITE_FP): Delete.
* gdbarch.h, gdbarch.c: Regenerate.
* config/v850/tm-v850.h (TARGET_WRITE_FP): Delete macro.
* config/sparc/tm-sp64.h (TARGET_WRITE_FP): Delete macro.
(sparc64_write_fp): Delete declaration.
* config/h8500/tm-h8500.h (TARGET_WRITE_FP): Delete macro.
(h8500_write_fp): Delete declaration.
@
text
@d2 3
a4 2
   Copyright 1993, 1994, 1995, 1998, 2000, 2001
   Free Software Foundation, Inc.
d190 1
a190 1
      read_relative_register_raw_bytes (regno, b);
@


1.9
log
@s/value_ptr/struct value */
@
text
@a606 6
h8500_write_fp (CORE_ADDR v)
{
  write_register (PR6_REGNUM, v);
}

void
@


1.8
log
@Phase 1 of the ptid_t changes.
@
text
@d479 1
a479 1
value_ptr
d526 1
a526 1
h8500_set_trapped_internalvar (struct internalvar *var, value_ptr newval,
@


1.7
log
@Update/correct copyright notices.
@
text
@d589 1
a589 1
h8500_read_pc (int pid)
d595 1
a595 1
h8500_write_pc (CORE_ADDR v, int pid)
@


1.6
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1993, 1994, 1995, 2001 Free Software Foundation, Inc.
@


1.5
log
@Replace calls to abort() with calls to internal_error().
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995 Free Software Foundation, Inc.
d35 1
@


1.4
log
@Replace free() with xfree().
@
text
@d254 1
a254 1
      abort ();
d289 1
a289 1
      abort ();
@


1.3
log
@* ser-e7kpc.c (e7000pc_setstopbits): New function.
(e7000pc_ops): Add e7000pc_setstopbits.

* remote-e7000.c (e7000_detach, e7000_resume,
e7000_xfer_inferior_memory, e7000_files_info, e7000_files_info,
e7000_insert_breakpoint, e7000_remove_breakpoint, e7000_kill):
Update function signature to match target vector.

* h8300-tdep.c (h8300_command, h8300h_command, h8300s_command):
h8500-tdep.c (small_command, big_command, medium_command,
compact_command): Update function signature to match add_cmd.
@
text
@d513 1
a513 1
  free (var->value);		/* Free up old value */
@


1.2
log
@Protoization.
@
text
@d417 1
a417 1
big_command (void)
d425 1
a425 1
medium_command (void)
d433 1
a433 1
compact_command (void)
d441 1
a441 1
small_command (void)
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 2
a23 2
 Contributed by Steve Chamberlain
                sac@@cygnus.com
d49 1
a49 1
   old fp	  <2 bytes>
d55 1
a55 1
*/
d58 5
a62 5
0x6df6		push	r6
0x0d76  	mov.w   r7,r6
0x6dfn          push    reg
0x7905 nnnn  	mov.w  #n,r5    or   0x1b87  subs #2,sp
0x1957       	sub.w  r5,sp
d81 1
a81 2
h8500_skip_prologue (start_pc)
     CORE_ADDR start_pc;
d102 1
a102 2
h8500_addr_bits_remove (addr)
     CORE_ADDR addr;
d115 1
a115 2
h8500_frame_chain (thisframe)
     struct frame_info *thisframe;
d126 1
a126 1
   of the instruction.*/
d129 1
a129 4
NEXT_PROLOGUE_INSN (addr, lim, pword1)
     CORE_ADDR addr;
     CORE_ADDR lim;
     char *pword1;
d153 1
a153 2
frame_saved_pc (frame)
     struct frame_info *frame;
d158 2
a159 2
void 
h8500_pop_frame ()
d177 1
a177 2
print_register_hook (regno)
     int regno;
d223 1
a223 2
h8500_register_size (regno)
     int regno;
d259 1
a259 2
h8500_register_virtual_type (regno)
     int regno;
d300 2
a301 3
frame_find_saved_regs (frame_info, frame_saved_regs)
     struct frame_info *frame_info;
     struct frame_saved_regs *frame_saved_regs;
d321 3
a323 3
	 if not we lose.  If we win, find the address above the saved
	 regs using the amount of storage from the link instruction.
	 */
d379 1
a379 1
saved_pc_after_call ()
d396 1
a396 2
h8500_set_pointer_size (newsize)
     int newsize;
d417 1
a417 1
big_command ()
d425 1
a425 1
medium_command ()
d433 1
a433 1
compact_command ()
d441 1
a441 1
small_command ()
d451 1
a451 3
set_memory (args, from_tty)
     char *args;
     int from_tty;
d460 1
a460 2
h8500_is_trapped_internalvar (name)
     char *name;
d478 1
a478 2
h8500_value_of_trapped_internalvar (var)
     struct internalvar *var;
d511 1
a511 1
  regval |= regbuf[0] << 8 | regbuf[1];	/* XXX host/target byte order */
d524 2
a525 4
h8500_set_trapped_internalvar (var, newval, bitpos, bitsize, offset)
     struct internalvar *var;
     int offset, bitpos, bitsize;
     value_ptr newval;
d575 1
a575 1
h8500_read_sp ()
d581 1
a581 2
h8500_write_sp (v)
     CORE_ADDR v;
d587 1
a587 2
h8500_read_pc (pid)
     int pid;
d593 1
a593 3
h8500_write_pc (v, pid)
     CORE_ADDR v;
     int pid;
d599 1
a599 1
h8500_read_fp ()
d605 1
a605 2
h8500_write_fp (v)
     CORE_ADDR v;
d611 1
a611 1
_initialize_h8500_tdep ()
d620 1
a620 1
	   "Set small memory model. (16 bit code, 16 bit data)", &setmemorylist);
d623 1
a623 1
	   "Set big memory model. (32 bit code, 32 bit data)", &setmemorylist);
d626 1
a626 1
	   "Set medium memory model. (32 bit code, 16 bit data)", &setmemorylist);
d629 1
a629 1
	   "Set compact memory model. (16 bit code, 32 bit data)", &setmemorylist);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d21 2
a22 2
   Contributed by Steve Chamberlain
   sac@@cygnus.com
d48 1
a48 1
   old fp         <2 bytes>
d54 1
a54 1
 */
d57 5
a61 5
   0x6df6               push    r6
   0x0d76       mov.w   r7,r6
   0x6dfn          push    reg
   0x7905 nnnn          mov.w  #n,r5    or   0x1b87  subs #2,sp
   0x1957               sub.w  r5,sp
d128 1
a128 1
   of the instruction. */
d164 1
a164 1
void
d331 3
a333 3
         if not we lose.  If we win, find the address above the saved
         regs using the amount of storage from the link instruction.
       */
d526 1
a526 1
  regval |= regbuf[0] << 8 | regbuf[1];		/* XXX host/target byte order */
d642 1
a642 1
      "Set small memory model. (16 bit code, 16 bit data)", &setmemorylist);
d645 1
a645 1
	"Set big memory model. (32 bit code, 32 bit data)", &setmemorylist);
d648 1
a648 1
     "Set medium memory model. (32 bit code, 16 bit data)", &setmemorylist);
d651 1
a651 1
    "Set compact memory model. (16 bit code, 32 bit data)", &setmemorylist);
@

