head	1.26;
access;
symbols
	cagney-unwind-20030108-branch:1.24.0.2
	cagney-unwind-20030108-branchpoint:1.24
	carlton_dictionary-20021223-merge:1.24
	gdb_5_3-2002-12-12-release:1.22
	carlton_dictionary-20021115-merge:1.24
	kseitz_interps-20021105-merge:1.22
	kseitz_interps-20021103-merge:1.22
	drow-cplus-merge-20021020:1.22
	drow-cplus-merge-20021025:1.22
	carlton_dictionary-20021025-merge:1.22
	carlton_dictionary-20021011-merge:1.22
	drow-cplus-branch:1.22.0.10
	drow-cplus-branchpoint:1.22
	kseitz_interps-20020930-merge:1.22
	carlton_dictionary-20020927-merge:1.22
	carlton_dictionary-branch:1.22.0.8
	carlton_dictionary-20020920-branchpoint:1.22
	gdb_5_3-branch:1.22.0.6
	gdb_5_3-2002-09-04-branchpoint:1.22
	kseitz_interps-20020829-merge:1.22
	cagney_sysregs-20020825-branch:1.22.0.4
	cagney_sysregs-20020825-branchpoint:1.22
	readline_4_3-import-branch:1.22.0.2
	readline_4_3-import-branchpoint:1.22
	gdb_5_2_1-2002-07-23-release:1.20
	kseitz_interps-20020528-branch:1.21.0.6
	kseitz_interps-20020528-branchpoint:1.21
	cagney_regbuf-20020515-branch:1.21.0.4
	cagney_regbuf-20020515-branchpoint:1.21
	jimb-macro-020506-branch:1.21.0.2
	jimb-macro-020506-branchpoint:1.21
	gdb_5_2-2002-04-29-release:1.20
	gdb_5_2-branch:1.20.0.2
	gdb_5_2-2002-03-03-branchpoint:1.20
	gdb_5_1_1-2002-01-24-release:1.18
	gdb_5_1_0_1-2002-01-03-release:1.18
	cygnus_cvs_20020108_pre:1.19
	gdb_5_1_0_1-2002-01-03-branchpoint:1.18
	gdb_5_1_0_1-2002-01-03-branch:1.18.0.6
	gdb_5_1-2001-11-21-release:1.18
	gdb_s390-2001-09-26-branch:1.18.0.4
	gdb_s390-2001-09-26-branchpoint:1.18
	gdb_5_1-2001-07-29-branch:1.18.0.2
	gdb_5_1-2001-07-29-branchpoint:1.18
	dberlin-typesystem-branch:1.16.0.2
	dberlin-typesystem-branchpoint:1.16
	gdb-post-ptid_t-2001-05-03:1.16
	gdb-pre-ptid_t-2001-05-03:1.15
	insight-precleanup-2001-01-01:1.7
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.26
date	2003.01.31.16.32.44;	author cagney;	state dead;
branches;
next	1.25;

1.25
date	2003.01.18.15.55.52;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.14.20.37.29;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.12.21.43.55;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.11.13.50.49;	author cagney;	state Exp;
branches
	1.22.8.1
	1.22.10.1;
next	1.21;

1.21
date	2002.04.29.11.01.13;	author muller;	state Exp;
branches
	1.21.6.1;
next	1.20;

1.20
date	2002.01.19.03.32.37;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.21.17.19.37;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.15.20.34.13;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.11.17.52.32;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.14.19.23.02;	author jtc;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.06.08.21.12;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.02.19.14.33;	author jtc;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.27.00.43.25;	author fnasser;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.23.22.48.55;	author jtc;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.19.08.01.46;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.30.21.50.57;	author jtc;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.06.21.50.56;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.46;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.09.02;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.22.03.24.54;	author jsm;	state Exp;
branches;
next	;

1.21.6.1
date	2002.07.22.21.47.01;	author kseitz;	state Exp;
branches;
next	;

1.22.8.1
date	2002.11.15.19.18.53;	author carlton;	state Exp;
branches;
next	1.22.8.2;

1.22.8.2
date	2003.02.07.19.17.52;	author carlton;	state dead;
branches;
next	;

1.22.10.1
date	2003.12.14.20.27.28;	author drow;	state dead;
branches;
next	;


desc
@@


1.26
log
@2003-01-31  Andrew Cagney  <ac131313@@redhat.com>

	* README: Remove reference to Ericsson 1800 monitor.
	* Makefile.in (remote-es.o): Delete rule.
	(ALLDEPFILES): Delete remote-es.c.
	* remote-es.c: Delete file.
	* config/m68k/es1800.mt: Delete file.
	* config/djgpp/fnchange.lst: Update.
	* configure.tgt: Delete m68*-ericsson-* target.
@
text
@/* Memory-access and commands for remote es1800 processes, for GDB.

   Copyright 1988, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001, 2002 Free Software Foundation, Inc.

   This file is added to GDB to make it possible to do debugging via an
   ES-1800 emulator. The code was originally written by Johan Holmberg
   TT/SJ Ericsson Telecom AB and later modified by Johan Henriksson
   TT/SJ. It was modified for gdb 4.0 by TX/DK Jan Nordenand by TX/DKG
   Harald Johansen.

   This file is part of GDB.

   GDB is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   GDB is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */


/* Emulator communication protocol.
   All values are encoded in ascii hex digits.

   Request
   Command
   Reply
   read registers:
   DR<cr>
   - 0 -    - 1 -    - 2 -    - 3 -      - 4 -    - 5 -    -- 6 -   - 7 - 
   D = XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX   XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
   A = XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX   XXXXXXXX XXXXXXXX XXXXXXXX 
   PC = XXXXXX       SSP = XXXXXX    USP = XXXXXX     SR = XXXXXXXX
   >
   Each byte of register data is described by two hex digits.

   write regs
   D0=XXXXXXXX<cr>
   >D1=XXXXXXXX<cr>
   >D2=XXXXXXXX<cr>
   >D3=XXXXXXXX<cr>
   >D4=XXXXXXXX<cr>
   >D5=XXXXXXXX<cr>
   >D6=XXXXXXXX<cr>
   >D7=XXXXXXXX<cr>
   >A0=XXXXXXXX<cr>
   >A1=XXXXXXXX<cr>
   >A2=XXXXXXXX<cr>
   >A3=XXXXXXXX<cr>
   >A4=XXXXXXXX<cr>
   >A5=XXXXXXXX<cr>
   >A6=XXXXXXXX<cr>
   >A7=XXXXXXXX<cr>
   >SR=XXXXXXXX<cr>
   >PC=XXXXXX<cr>
   >
   Each byte of register data is described by two hex digits.

   read mem
   @@.BAA..AA
   $FFFFFFXX
   >
   AA..AA is address, XXXXXXX is the contents

   write mem
   @@.BAA..AA=$XXXXXXXX
   >
   AA..AA is address, XXXXXXXX is data

   cont
   PC=$AA..AA
   >RBK
   R>
   AA..AA is address to resume. If AA..AA is omitted, resume at same address.

   step
   PC=$AA..AA
   >STP
   R>
   AA..AA is address to resume. If AA..AA is omitted, resume at same address.

   kill req
   STP
   >
 */


#include <stdio.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <errno.h>
#include <ctype.h>
#include <setjmp.h>
#include <fcntl.h>
#include "defs.h"
#include "gdb_string.h"
#include "frame.h"
#include "inferior.h"
#include "target.h"
#include "command.h"
#include "symfile.h"
#include "remote-utils.h"
#include "gdbcore.h"
#include "serial.h"
#include "regcache.h"
#include "value.h"

/* Prototypes for local functions */

static void es1800_child_detach (char *, int);

static void es1800_child_open (char *, int);

static void es1800_transparent (char *, int);

static void es1800_create_inferior (char *, char *, char **);

static void es1800_load (char *, int);

static void es1800_kill (void);

static int verify_break (int);

static int es1800_remove_breakpoint (CORE_ADDR, char *);

static int es1800_insert_breakpoint (CORE_ADDR, char *);

static void es1800_files_info (struct target_ops *);

static int es1800_xfer_inferior_memory (CORE_ADDR, char *, int, int,
					struct mem_attrib *,
					struct target_ops *);

static void es1800_prepare_to_store (void);

static ptid_t es1800_wait (ptid_t, struct target_waitstatus *);

static void es1800_resume (ptid_t, int, enum target_signal);

static void es1800_detach (char *, int);

static void es1800_attach (char *, int);

static int damn_b (char *);

static void es1800_open (char *, int);

static void es1800_timer (void);

static void es1800_reset (char *);

static void es1800_request_quit (void);

static int readchar (void);

static void expect (char *, int);

static void expect_prompt (void);

static void download (FILE *, int, int);

#if 0
static void bfd_copy (bfd *, bfd *);
#endif

static void get_break_addr (int, CORE_ADDR *);

static int fromhex (int);

static int tohex (int);

static void es1800_close (int);

static void es1800_fetch_registers (void);

static void es1800_fetch_register (int);

static void es1800_store_register (int);

static void es1800_read_bytes (CORE_ADDR, char *, int);

static void es1800_write_bytes (CORE_ADDR, char *, int);

static void send_with_reply (char *, char *, int);

static void send_command (char *);

static void send (char *);

static void getmessage (char *, int);

static void es1800_mourn_inferior (void);

static void es1800_create_break_insn (char *, int);

static void es1800_init_break (char *, int);

/* Local variables */

/* FIXME: Convert this to use "set remotedebug" instead.  */
#define LOG_FILE "es1800.log"
#if defined (LOG_FILE)
static FILE *log_file;
#endif

extern struct target_ops es1800_ops;	/* Forward decl */
extern struct target_ops es1800_child_ops;	/* Forward decl */

static int kiodebug;
static int timeout = 100;
static char *savename;		/* Name of i/o device used */
static serial_ttystate es1800_saved_ttystate;
static int es1800_fc_save;	/* Save fcntl state */

/* indicates that the emulator uses 32-bit data-adress (68020-mode) 
   instead of 24-bit (68000 -mode) */

static int m68020;

#define MODE (m68020 ? "M68020" : "M68000" )
#define ES1800_BREAK_VEC (0xf)

/* Descriptor for I/O to remote machine.  Initialize it to NULL so that
   es1800_open knows that we don't have a file open when the program
   starts.  */

static struct serial *es1800_desc = NULL;

#define	PBUFSIZ	1000
#define HDRLEN sizeof("@@.BAAAAAAAA=$VV\r")

/* Maximum number of bytes to read/write at once.  The value here
   is chosen to fill up a packet.  */

#define MAXBUFBYTES ((PBUFSIZ-150)*16/75 )

static int es1800_break_vec = 0;
static char es1800_break_insn[2];
static long es1800_break_address;
static void (*old_sigint) ();	/* Old signal-handler for sigint */
static jmp_buf interrupt;

/* Local signalhandler to allow breaking tranfers or program run.
   Rely on global variables: old_sigint(), interrupt */

static void
es1800_request_quit (void)
{
  /* restore original signalhandler */
  signal (SIGINT, old_sigint);
  longjmp (interrupt, 1);
}


/* Reset emulator.
   Sending reset character(octal 32) to emulator.
   quit - return to '(esgdb)' prompt or continue        */

static void
es1800_reset (char *quit)
{
  char buf[80];

  if (quit)
    {
      printf ("\nResetting emulator...  ");
    }
  strcpy (buf, "\032");
  send (buf);
  expect_prompt ();
  if (quit)
    {
      error ("done\n");
    }
}


/* Open a connection to a remote debugger and push the new target
   onto the stack. Check if the emulator is responding and find out
   what kind of processor the emulator is connected to.
   Initiate the breakpoint handling in the emulator.

   name     - the filename used for communication (ex. '/dev/tta')
   from_tty - says whether to be verbose or not */

static void
es1800_open (char *name, int from_tty)
{
  char buf[PBUFSIZ];
  char *p;
  int i, fcflag;

  m68020 = 0;

  if (!name)			/* no device name given in target command */
    {
      error_no_arg ("serial port device name");
    }

  target_preopen (from_tty);
  es1800_close (0);

  /* open the device and configure it for communication */

#ifndef DEBUG_STDIN

  es1800_desc = serial_open (name);
  if (es1800_desc == NULL)
    {
      perror_with_name (name);
    }
  savename = savestring (name, strlen (name));

  es1800_saved_ttystate = serial_get_tty_state (es1800_desc);

  if ((fcflag = fcntl (deprecated_serial_fd (es1800_desc), F_GETFL, 0)) == -1)
    {
      perror_with_name ("fcntl serial");
    }
  es1800_fc_save = fcflag;

  fcflag = (fcflag & (FREAD | FWRITE));		/* mask out any funny stuff */
  if (fcntl (deprecated_serial_fd (es1800_desc), F_SETFL, fcflag) == -1)
    {
      perror_with_name ("fcntl serial");
    }

  if (baud_rate != -1)
    {
      if (serial_setbaudrate (es1800_desc, baud_rate))
	{
	  serial_close (es1800_desc);
	  perror_with_name (name);
	}
    }

  serial_raw (es1800_desc);

  /* If there is something sitting in the buffer we might take it as a
     response to a command, which would be bad.  */
  serial_flush_input (es1800_desc);

#endif /* DEBUG_STDIN */

  push_target (&es1800_ops);	/* Switch to using remote target now */
  if (from_tty)
    {
      printf ("Remote ES1800 debugging using %s\n", name);
    }

#if defined (LOG_FILE)

  log_file = fopen (LOG_FILE, "w");
  if (log_file == NULL)
    {
      perror_with_name (LOG_FILE);
    }

#endif /* LOG_FILE */

  /* Hello?  Are you there?, also check mode  */

  /*  send_with_reply( "DB 0 TO 1", buf, sizeof(buf)); */
  /*  for (p = buf, i = 0; *p++ =='0';)  *//* count the number of zeros */
  /*      i++; */

  send ("\032");
  getmessage (buf, sizeof (buf));	/* send reset character */

  if (from_tty)
    {
      printf ("Checking mode.... ");
    }
  /*  m68020 = (i==8); *//* if eight zeros then we are in m68020 mode */

  /* What kind of processor am i talking to ? */
  p = buf;
  while (*p++ != '\n')
    {;
    }
  while (*p++ != '\n')
    {;
    }
  while (*p++ != '\n')
    {;
    }
  for (i = 0; i < 20; i++, p++)
    {;
    }
  m68020 = !strncmp (p, "68020", 5);
  if (from_tty)
    {
      printf ("You are in %s(%c%c%c%c%c)-mode\n", MODE, p[0], p[1], p[2],
	      p[3], p[4]);
    }

  /* if no init_break statement is present in .gdb file we have to check 
     whether to download a breakpoint routine or not */

#if 0
  if ((es1800_break_vec == 0) || (verify_break (es1800_break_vec) != 0)
      && query ("No breakpoint routine in ES 1800 emulator!\nDownload a breakpoint routine to the emulator? "))
    {
      CORE_ADDR memaddress;
      printf ("Give the start address of the breakpoint routine: ");
      scanf ("%li", &memaddress);
      es1800_init_break ((es1800_break_vec ? es1800_break_vec :
			  ES1800_BREAK_VEC), memaddress);
    }
#endif

}

/*  Close out all files and local state before this target loses control.
   quitting - are we quitting gdb now? */

static void
es1800_close (int quitting)
{
  if (es1800_desc != NULL)
    {
      printf ("\nClosing connection to emulator...\n");
      if (serial_set_tty_state (es1800_desc, es1800_saved_ttystate) < 0)
	print_sys_errmsg ("warning: unable to restore tty state", errno);
      fcntl (deprecated_serial_fd (es1800_desc), F_SETFL, es1800_fc_save);
      serial_close (es1800_desc);
      es1800_desc = NULL;
    }
  if (savename != NULL)
    {
      xfree (savename);
    }
  savename = NULL;

#if defined (LOG_FILE)

  if (log_file != NULL)
    {
      if (ferror (log_file))
	{
	  printf ("Error writing log file.\n");
	}
      if (fclose (log_file) != 0)
	{
	  printf ("Error closing log file.\n");
	}
      log_file = NULL;
    }

#endif /* LOG_FILE */

}

/*  Attaches to a process on the target side
   proc_id  - the id of the process to be attached.
   from_tty - says whether to be verbose or not */

static void
es1800_attach (char *args, int from_tty)
{
  error ("Cannot attach to pid %s, this feature is not implemented yet.",
	 args);
}


/* Takes a program previously attached to and detaches it.
   We better not have left any breakpoints
   in the program or it'll die when it hits one.
   Close the open connection to the remote debugger.
   Use this when you want to detach and do something else
   with your gdb.

   args     - arguments given to the 'detach' command
   from_tty - says whether to be verbose or not */

static void
es1800_detach (char *args, int from_tty)
{
  if (args)
    {
      error ("Argument given to \"detach\" when remotely debugging.");
    }
  pop_target ();
  if (from_tty)
    {
      printf ("Ending es1800 remote debugging.\n");
    }
}


/* Tell the remote machine to resume.
   step    - single-step or run free
   siggnal - the signal value to be given to the target (0 = no signal) */

static void
es1800_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  char buf[PBUFSIZ];

  if (siggnal)
    {
      error ("Can't send signals to a remote system.");
    }
  if (step)
    {
      strcpy (buf, "STP\r");
      send (buf);
    }
  else
    {
      send_command ("RBK");
    }
}

/* Wait until the remote machine stops, then return,
   storing status in STATUS just as `wait' would.
   status -  */

static ptid_t
es1800_wait (ptid_t ptid, struct target_waitstatus *status)
{
  unsigned char buf[PBUFSIZ];
  int old_timeout = timeout;

  status->kind = TARGET_WAITKIND_EXITED;
  status->value.integer = 0;

  timeout = 0;			/* Don't time out -- user program is running. */
  if (!setjmp (interrupt))
    {
      old_sigint = signal (SIGINT, es1800_request_quit);
      while (1)
	{
	  getmessage (buf, sizeof (buf));
	  if (strncmp (buf, "\r\n* BREAK *", 11) == 0)
	    {
	      status->kind = TARGET_WAITKIND_STOPPED;
	      status->value.sig = TARGET_SIGNAL_TRAP;
	      send_command ("STP");	/* Restore stack and PC and such */
	      if (m68020)
		{
		  send_command ("STP");
		}
	      break;
	    }
	  if (strncmp (buf, "STP\r\n ", 6) == 0)
	    {
	      status->kind = TARGET_WAITKIND_STOPPED;
	      status->value.sig = TARGET_SIGNAL_TRAP;
	      break;
	    }
	  if (buf[strlen (buf) - 2] == 'R')
	    {
	      printf ("Unexpected emulator reply: \n%s\n", buf);
	    }
	  else
	    {
	      printf ("Unexpected stop: \n%s\n", buf);
	      status->kind = TARGET_WAITKIND_STOPPED;
	      status->value.sig = TARGET_SIGNAL_QUIT;
	      break;
	    }
	}
    }
  else
    {
      fflush (stdin);
      printf ("\nStopping emulator...");
      if (!setjmp (interrupt))
	{
	  old_sigint = signal (SIGINT, es1800_request_quit);
	  send_command ("STP");
	  printf (" emulator stopped\n");
	  status->kind = TARGET_WAITKIND_STOPPED;
	  status->value.sig = TARGET_SIGNAL_INT;
	}
      else
	{
	  fflush (stdin);
	  es1800_reset ((char *) 1);
	}
    }
  signal (SIGINT, old_sigint);
  timeout = old_timeout;
  return inferior_ptid;
}


/* Fetch register values from remote machine.
   regno - the register to be fetched (fetch all registers if -1) */

static void
es1800_fetch_register (int regno)
{
  char buf[PBUFSIZ];
  int k;
  int r;
  char *p;
  static char regtab[18][4] =
  {
    "D0 ", "D1 ", "D2 ", "D3 ", "D4 ", "D5 ", "D6 ", "D7 ",
    "A0 ", "A1 ", "A2 ", "A3 ", "A4 ", "A5 ", "A6 ", "SSP",
    "SR ", "PC "
  };

  if ((regno < 15) || (regno == 16) || (regno == 17))
    {
      r = regno * 4;
      send_with_reply (regtab[regno], buf, sizeof (buf));
      p = buf;
      for (k = 0; k < 4; k++)
	{
	  if ((p[k * 2 + 1] == 0) || (p[k * 2 + 2] == 0))
	    {
	      error ("Emulator reply is too short: %s", buf);
	    }
	  deprecated_registers[r++] = (fromhex (p[k * 2 + 1]) * 16) + fromhex (p[k * 2 + 2]);
	}
    }
  else
    {
      es1800_fetch_registers ();
    }
}

/* Read the remote registers into REGISTERS.
   Always fetches all registers. */

static void
es1800_fetch_registers (void)
{
  char buf[PBUFSIZ];
  char SR_buf[PBUFSIZ];
  int i;
  int k;
  int r;
  char *p;

  send_with_reply ("DR", buf, sizeof (buf));

  /* Reply is edited to a string that describes registers byte by byte,
     each byte encoded as two hex characters.  */

  p = buf;
  r = 0;

  /*  parsing row one - D0-D7-registers  */

  while (*p++ != '\n')
    {;
    }
  for (i = 4; i < 70; i += (i == 39 ? 3 : 1))
    {
      for (k = 0; k < 4; k++)
	{
	  if (p[i + 0] == 0 || p[i + 1] == 0)
	    {
	      error ("Emulator reply is too short: %s", buf);
	    }
	  deprecated_registers[r++] = (fromhex (p[i + 0]) * 16) + fromhex (p[i + 1]);
	  i += 2;
	}
    }
  p += i;

  /*  parsing row two - A0-A6-registers  */

  while (*p++ != '\n')
    {;
    }
  for (i = 4; i < 61; i += (i == 39 ? 3 : 1))
    {
      for (k = 0; k < 4; k++)
	{
	  if (p[i + 0] == 0 || p[i + 1] == 0)
	    {
	      error ("Emulator reply is too short: %s", buf);
	    }
	  deprecated_registers[r++] = (fromhex (p[i + 0])) * 16 + fromhex (p[i + 1]);
	  i += 2;
	}
    }
  p += i;

  while (*p++ != '\n')
    {;
    }

  /* fetch SSP-, SR- and PC-registers  */

  /* first - check STATUS-word and decide which stackpointer to use */

  send_with_reply ("SR", SR_buf, sizeof (SR_buf));
  p = SR_buf;
  p += 5;

  if (m68020)
    {
      if (*p == '3')		/* use masterstackpointer MSP */
	{
	  send_with_reply ("MSP", buf, sizeof (buf));
	}
      else if (*p == '2')	/* use interruptstackpointer ISP  */
	{
	  send_with_reply ("ISP", buf, sizeof (buf));
	}
      else
	/* use userstackpointer USP  */
	{
	  send_with_reply ("USP", buf, sizeof (buf));
	}
      p = buf;
      for (k = 0; k < 4; k++)
	{
	  if (p[k * 2 + 1] == 0 || p[k * 2 + 2] == 0)
	    {
	      error ("Emulator reply is too short: %s", buf);
	    }
	  deprecated_registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
	}

      p = SR_buf;
      for (k = 0; k < 4; k++)
	{
	  if (p[k * 2 + 1] == 0 || p[k * 2 + 2] == 0)
	    {
	      error ("Emulator reply is too short: %s", buf);
	    }
	  deprecated_registers[r++] =
	    fromhex (SR_buf[k * 2 + 1]) * 16 + fromhex (SR_buf[k * 2 + 2]);
	}
      send_with_reply ("PC", buf, sizeof (buf));
      p = buf;
      for (k = 0; k < 4; k++)
	{
	  if (p[k * 2 + 1] == 0 || p[k * 2 + 2] == 0)
	    {
	      error ("Emulator reply is too short: %s", buf);
	    }
	  deprecated_registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
	}
    }
  else
    /* 68000-mode */
    {
      if (*p == '2')		/* use supervisorstackpointer SSP  */
	{
	  send_with_reply ("SSP", buf, sizeof (buf));
	}
      else
	/* use userstackpointer USP  */
	{
	  send_with_reply ("USP", buf, sizeof (buf));
	}

      /* fetch STACKPOINTER */

      p = buf;
      for (k = 0; k < 4; k++)
	{
	  if (p[k * 2 + 1] == 0 || p[k * 2 + 2] == 0)
	    {
	      error ("Emulator reply is too short: %s", buf);
	    }
	  deprecated_registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
	}

      /* fetch STATUS */

      p = SR_buf;
      for (k = 0; k < 4; k++)
	{
	  if (p[k * 2 + 1] == 0 || p[k * 2 + 2] == 0)
	    {
	      error ("Emulator reply is too short: %s", buf);
	    }
	  deprecated_registers[r++] =
	    fromhex (SR_buf[k * 2 + 1]) * 16 + fromhex (SR_buf[k * 2 + 2]);
	}

      /* fetch PC */

      send_with_reply ("PC", buf, sizeof (buf));
      p = buf;
      for (k = 0; k < 4; k++)
	{
	  if (p[k * 2 + 1] == 0 || p[k * 2 + 2] == 0)
	    {
	      error ("Emulator reply is too short: %s", buf);
	    }
	  deprecated_registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
	}
    }
}

/* Store register value, located in REGISTER, on the target processor.
   regno - the register-number of the register to store
   (-1 means store them all)
   FIXME: Return errno value.  */

static void
es1800_store_register (int regno)
{

  static char regtab[18][4] =
  {
    "D0 ", "D1 ", "D2 ", "D3 ", "D4 ", "D5 ", "D6 ", "D7 ",
    "A0 ", "A1 ", "A2 ", "A3 ", "A4 ", "A5 ", "A6 ", "SSP",
    "SR ", "PC "
  };

  char buf[PBUFSIZ];
  char SR_buf[PBUFSIZ];
  char stack_pointer[4];
  char *p;
  int i;
  int j;
  int k;
  unsigned char *r;

  r = (unsigned char *) deprecated_registers;

  if (regno == -1)		/* write all registers */
    {
      j = 0;
      k = 18;
    }
  else
    /* write one register */
    {
      j = regno;
      k = regno + 1;
      r += regno * 4;
    }

  if ((regno == -1) || (regno == 15))
    {
      /* fetch current status */
      send_with_reply ("SR", SR_buf, sizeof (SR_buf));
      p = SR_buf;
      p += 5;
      if (m68020)
	{
	  if (*p == '3')	/* use masterstackpointer MSP */
	    {
	      strcpy (stack_pointer, "MSP");
	    }
	  else
	    {
	      if (*p == '2')	/* use interruptstackpointer ISP  */
		{
		  strcpy (stack_pointer, "ISP");
		}
	      else
		{
		  strcpy (stack_pointer, "USP");	/* use userstackpointer USP  */
		}
	    }
	}
      else
	/* 68000-mode */
	{
	  if (*p == '2')	/* use supervisorstackpointer SSP  */
	    {
	      strcpy (stack_pointer, "SSP");
	    }
	  else
	    {
	      strcpy (stack_pointer, "USP");	/* use userstackpointer USP  */
	    }
	}
      strcpy (regtab[15], stack_pointer);
    }

  for (i = j; i < k; i++)
    {
      buf[0] = regtab[i][0];
      buf[1] = regtab[i][1];
      buf[2] = regtab[i][2];
      buf[3] = '=';
      buf[4] = '$';
      buf[5] = tohex ((*r >> 4) & 0x0f);
      buf[6] = tohex (*r++ & 0x0f);
      buf[7] = tohex ((*r >> 4) & 0x0f);
      buf[8] = tohex (*r++ & 0x0f);
      buf[9] = tohex ((*r >> 4) & 0x0f);
      buf[10] = tohex (*r++ & 0x0f);
      buf[11] = tohex ((*r >> 4) & 0x0f);
      buf[12] = tohex (*r++ & 0x0f);
      buf[13] = 0;

      send_with_reply (buf, buf, sizeof (buf));		/* FIXME, reply not used? */
    }
}


/* Prepare to store registers.  */

static void
es1800_prepare_to_store (void)
{
  /* Do nothing, since we can store individual regs */
}

/* Convert hex digit A to a number.  */

static int
fromhex (int a)
{
  if (a >= '0' && a <= '9')
    {
      return a - '0';
    }
  else if (a >= 'a' && a <= 'f')
    {
      return a - 'a' + 10;
    }
  else if (a >= 'A' && a <= 'F')
    {
      return a - 'A' + 10;
    }
  else
    {
      error ("Reply contains invalid hex digit");
    }
  return (-1);
}


/* Convert number NIB to a hex digit.  */

static int
tohex (int nib)
{
  if (nib < 10)
    {
      return ('0' + nib);
    }
  else
    {
      return ('A' + nib - 10);
    }
}

/* Read or write LEN bytes from inferior memory at MEMADDR, transferring
   to or from debugger address MYADDR.  Write to inferior if WRITE is
   nonzero.  Returns length of data written or read; 0 for error. 

   memaddr - the target's address
   myaddr  - gdb's address
   len     - number of bytes 
   write   - write if != 0 otherwise read
   tops    - unused */

static int
es1800_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len,
			     int write, struct mem_attrib *attrib,
			     struct target_ops *target)
{
  int origlen = len;
  int xfersize;

  while (len > 0)
    {
      xfersize = len > MAXBUFBYTES ? MAXBUFBYTES : len;
      if (write)
	{
	  es1800_write_bytes (memaddr, myaddr, xfersize);
	}
      else
	{
	  es1800_read_bytes (memaddr, myaddr, xfersize);
	}
      memaddr += xfersize;
      myaddr += xfersize;
      len -= xfersize;
    }
  return (origlen);		/* no error possible */
}


/* Write memory data directly to the emulator.
   This does not inform the data cache; the data cache uses this.
   MEMADDR is the address in the remote memory space.
   MYADDR is the address of the buffer in our space.
   LEN is the number of bytes.

   memaddr - the target's address
   myaddr  - gdb's address
   len     - number of bytes   */

static void
es1800_write_bytes (CORE_ADDR memaddr, char *myaddr, int len)
{
  char buf[PBUFSIZ];
  int i;
  char *p;

  p = myaddr;
  for (i = 0; i < len; i++)
    {
      sprintf (buf, "@@.B$%x=$%x", memaddr + i, (*p++) & 0xff);
      send_with_reply (buf, buf, sizeof (buf));		/* FIXME send_command? */
    }
}


/* Read memory data directly from the emulator.
   This does not use the data cache; the data cache uses this.

   memaddr - the target's address
   myaddr  - gdb's address
   len     - number of bytes   */

static void
es1800_read_bytes (CORE_ADDR memaddr, char *myaddr, int len)
{
  static int DB_tab[16] =
  {8, 11, 14, 17, 20, 23, 26, 29, 34, 37, 40, 43, 46, 49, 52, 55};
  char buf[PBUFSIZ];
  int i;
  int low_addr;
  char *p;
  char *b;

  if (len > PBUFSIZ / 2 - 1)
    {
      internal_error (__FILE__, __LINE__, "failed internal consistency check");
    }

  if (len == 1)			/* The emulator does not like expressions like:  */
    {
      len = 2;			/* DB.B $20018 TO $20018                       */
    }

  /* Reply describes registers byte by byte, each byte encoded as two hex
     characters.  */

  sprintf (buf, "DB.B $%x TO $%x", memaddr, memaddr + len - 1);
  send_with_reply (buf, buf, sizeof (buf));
  b = buf;
  low_addr = memaddr & 0x0f;
  for (i = low_addr; i < low_addr + len; i++)
    {
      if ((!(i % 16)) && i)
	{			/* if (i = 16,32,48)  */
	  while (*p++ != '\n')
	    {;
	    }
	  b = p;
	}
      p = b + DB_tab[i % 16] + (m68020 ? 2 : 0);
      if (p[0] == 32 || p[1] == 32)
	{
	  error ("Emulator reply is too short: %s", buf);
	}
      myaddr[i - low_addr] = fromhex (p[0]) * 16 + fromhex (p[1]);
    }
}

/* Display information about the current target.  TOPS is unused.  */

static void
es1800_files_info (struct target_ops *tops)
{
  printf ("ES1800 Attached to %s at %d baud in %s mode\n", savename, 19200,
	  MODE);
}


/* We read the contents of the target location and stash it,
   then overwrite it with a breakpoint instruction.

   addr           - is the target location in the target machine.
   contents_cache - is a pointer to memory allocated for saving the target contents.
   It is guaranteed by the caller to be long enough to save sizeof 
   BREAKPOINT bytes.

   FIXME: This size is target_arch dependent and should be available in
   the target_arch transfer vector, if we ever have one...  */

static int
es1800_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  int val;

  val = target_read_memory (addr, contents_cache, sizeof (es1800_break_insn));

  if (val == 0)
    {
      val = target_write_memory (addr, es1800_break_insn,
				 sizeof (es1800_break_insn));
    }

  return (val);
}


/* Write back the stashed instruction

   addr           - is the target location in the target machine.
   contents_cache - is a pointer to memory allocated for saving the target contents.
   It is guaranteed by the caller to be long enough to save sizeof 
   BREAKPOINT bytes.    */

static int
es1800_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
{

  return (target_write_memory (addr, contents_cache,
			       sizeof (es1800_break_insn)));
}

/* create_break_insn ()
   Primitive datastructures containing the es1800 breakpoint instruction  */

static void
es1800_create_break_insn (char *ins, int vec)
{
  if (vec == 15)
    {
      ins[0] = 0x4e;
      ins[1] = 0x4f;
    }
}


/* verify_break ()
   Seach for breakpoint routine in emulator memory.
   returns non-zero on failure
   vec - trap vector used for breakpoints  */

static int
verify_break (int vec)
{
  CORE_ADDR memaddress;
  char buf[8];
  char *instr = "NqNqNqNs";	/* breakpoint routine */
  int status;

  get_break_addr (vec, &memaddress);

  if (memaddress)
    {
      status = target_read_memory (memaddress, buf, 8);
      if (status != 0)
	{
	  memory_error (status, memaddress);
	}
      return (strcmp (instr, buf));
    }
  return (-1);
}


/* get_break_addr ()
   find address of breakpoint routine
   vec - trap vector used for breakpoints
   addrp - store the address here       */

static void
get_break_addr (int vec, CORE_ADDR *addrp)
{
  CORE_ADDR memaddress = 0;
  int status;
  int k;
  char buf[PBUFSIZ];
  char base_addr[4];
  char *p;

  if (m68020)
    {
      send_with_reply ("VBR ", buf, sizeof (buf));
      p = buf;
      for (k = 0; k < 4; k++)
	{
	  if ((p[k * 2 + 1] == 0) || (p[k * 2 + 2] == 0))
	    {
	      error ("Emulator reply is too short: %s", buf);
	    }
	  base_addr[k] = (fromhex (p[k * 2 + 1]) * 16) + fromhex (p[k * 2 + 2]);
	}
      /* base addr of exception vector table */
      memaddress = *((CORE_ADDR *) base_addr);
    }

  memaddress += (vec + 32) * 4;	/* address of trap vector */
  status = target_read_memory (memaddress, (char *) addrp, 4);
  if (status != 0)
    {
      memory_error (status, memaddress);
    }
}


/* Kill an inferior process */

static void
es1800_kill (void)
{
  if (!ptid_equal (inferior_ptid, null_ptid))
    {
      inferior_ptid = null_ptid;
      es1800_mourn_inferior ();
    }
}


/* Load a file to the ES1800 emulator. 
   Converts the file from a.out format into Extended Tekhex format
   before the file is loaded.
   Also loads the trap routine, and sets the ES1800 breakpoint on it
   filename - the a.out to be loaded
   from_tty - says whether to be verbose or not
   FIXME Uses emulator overlay memory for trap routine  */

static void
es1800_load (char *filename, int from_tty)
{

  FILE *instream;
  char loadname[15];
  char buf[160];
  struct cleanup *old_chain;
  int es1800_load_format = 5;

  if (es1800_desc == NULL)
    {
      printf ("No emulator attached, type emulator-command first\n");
      return;
    }

  filename = tilde_expand (filename);
  make_cleanup (xfree, filename);

  switch (es1800_load_format)
    {
    case 2:			/* Extended Tekhex  */
      if (from_tty)
	{
	  printf ("Converting \"%s\" to Extended Tekhex Format\n", filename);
	}
      sprintf (buf, "tekhex %s", filename);
      system (buf);
      sprintf (loadname, "out.hex");
      break;

    case 5:			/* Motorola S-rec  */
      if (from_tty)
	{
	  printf ("Converting \"%s\" to Motorola S-record format\n",
		  filename);
	}
      /* in the future the source code in copy (part of binutils-1.93) will
         be included in this file */
      sprintf (buf,
	       "copy -s \"a.out-sunos-big\" -d \"srec\" %s /tmp/out.hex",
	       filename);
      system (buf);
      sprintf (loadname, "/tmp/out.hex");
      break;

    default:
      error ("Downloading format not defined\n");
    }

  breakpoint_init_inferior ();
  inferior_ptid = null_ptid;
  if (from_tty)
    {
      printf ("Downloading \"%s\" to the ES 1800\n", filename);
    }
  if ((instream = fopen (loadname, "r")) == NULL)
    {
      perror_with_name ("fopen:");
    }

  old_chain = make_cleanup (fclose, instream);
  immediate_quit++;

  es1800_reset (0);

  download (instream, from_tty, es1800_load_format);

  /* if breakpoint routine is not present anymore we have to check 
     whether to download a new breakpoint routine or not */

  if ((verify_break (es1800_break_vec) != 0)
      && query ("No breakpoint routine in ES 1800 emulator!\nDownload a breakpoint routine to the emulator? "))
    {
      char buf[128];
      printf ("Using break vector 0x%x\n", es1800_break_vec);
      sprintf (buf, "0x%x ", es1800_break_vec);
      printf ("Give the start address of the breakpoint routine: ");
      fgets (buf + strlen (buf), sizeof (buf) - strlen (buf), stdin);
      es1800_init_break (buf, 0);
    }

  do_cleanups (old_chain);
  expect_prompt ();
  readchar ();			/* FIXME I am getting a ^G = 7 after the prompt  */
  printf ("\n");

  if (fclose (instream) == EOF)
    {
      ;
    }

  if (es1800_load_format != 2)
    {
      sprintf (buf, "/usr/bin/rm %s", loadname);
      system (buf);
    }

  symbol_file_add_main (filename, from_tty);	/* reading symbol table */
  immediate_quit--;
}

#if 0

#define NUMCPYBYTES 20

static void
bfd_copy (bfd *from_bfd, bfd *to_bfd)
{
  asection *p, *new;
  int i;
  char buf[NUMCPYBYTES];

  for (p = from_bfd->sections; p != NULL; p = p->next)
    {
      printf ("  Copying section %s. Size = %x.\n", p->name, p->_cooked_size);
      printf ("    vma = %x,  offset = %x,  output_sec = %x\n",
	      p->vma, p->output_offset, p->output_section);
      new = bfd_make_section (to_bfd, p->name);
      if (p->_cooked_size &&
	  !bfd_set_section_size (to_bfd, new, p->_cooked_size))
	{
	  error ("Wrong BFD size!\n");
	}
      if (!bfd_set_section_flags (to_bfd, new, p->flags))
	{
	  error ("bfd_set_section_flags");
	}
      new->vma = p->vma;

      for (i = 0; (i + NUMCPYBYTES) < p->_cooked_size; i += NUMCPYBYTES)
	{
	  if (!bfd_get_section_contents (from_bfd, p, buf, (file_ptr) i,
					 (bfd_size_type) NUMCPYBYTES))
	    {
	      error ("bfd_get_section_contents\n");
	    }
	  if (!bfd_set_section_contents (to_bfd, new, buf, (file_ptr) i,
					 (bfd_size_type) NUMCPYBYTES))
	    {
	      error ("bfd_set_section_contents\n");
	    }
	}
      bfd_get_section_contents (from_bfd, p, buf, (file_ptr) i,
				(bfd_size_type) (p->_cooked_size - i));
      bfd_set_section_contents (to_bfd, new, buf, (file_ptr) i,
				(bfd_size_type) (p->_cooked_size - i));
    }
}

#endif

/* Start an process on the es1800 and set inferior_ptid to the new
   process' pid.
   execfile - the file to run
   args     - arguments passed to the program
   env      - the environment vector to pass    */

static void
es1800_create_inferior (char *execfile, char *args, char **env)
{
  int entry_pt;
  int pid;
#if 0
  struct expression *expr;
  register struct cleanup *old_chain = 0;
  register value val;
#endif

  if (args && *args)
    {
      error ("Can't pass arguments to remote ES1800 process");
    }

#if 0
  if (query ("Use 'start' as entry point? "))
    {
      expr = parse_c_expression ("start");
      old_chain = make_cleanup (free_current_contents, &expr);
      val = evaluate_expression (expr);
      entry_pt = (val->location).address;
    }
  else
    {
      printf ("Enter the program's entry point (in hexadecimal): ");
      scanf ("%x", &entry_pt);
    }
#endif

  if (execfile == 0 || exec_bfd == 0)
    {
      error ("No executable file specified");
    }

  entry_pt = (int) bfd_get_start_address (exec_bfd);

  pid = 42;

  /* Now that we have a child process, make it our target.  */

  push_target (&es1800_child_ops);

  /* The "process" (board) is already stopped awaiting our commands, and
     the program is already downloaded.  We just set its PC and go.  */

  inferior_ptid = pid_to_ptid (pid);	/* Needed for wait_for_inferior below */

  clear_proceed_status ();

  /* Tell wait_for_inferior that we've started a new process.  */

  init_wait_for_inferior ();

  /* Set up the "saved terminal modes" of the inferior
     based on what modes we are starting it with.  */

  target_terminal_init ();

  /* Install inferior's terminal modes.  */

  target_terminal_inferior ();

  /* remote_start (args); */
  /* trap_expected = 0; */
  /* insert_step_breakpoint ();  FIXME, do we need this?  */

  /* Let 'er rip... */
  proceed ((CORE_ADDR) entry_pt, TARGET_SIGNAL_DEFAULT, 0);

}


/* The process has died, clean up.  */

static void
es1800_mourn_inferior (void)
{
  remove_breakpoints ();
  unpush_target (&es1800_child_ops);
  generic_mourn_inferior ();	/* Do all the proper things now */
}

/* ES1800-protocol specific routines */

/* Keep discarding input from the remote system, until STRING is found. 
   Let the user break out immediately. 
   string - the string to expect
   nowait - break out if string not the emulator's first respond otherwise
   read until string is found (== 0)   */

static void
expect (char *string, int nowait)
{
  char c;
  char *p = string;

  immediate_quit++;
  while (1)
    {
      c = readchar ();
      if (isalpha (c))
	{
	  c = toupper (c);
	}
      if (c == toupper (*p))
	{
	  p++;
	  if (*p == '\0')
	    {
	      immediate_quit--;
	      return;
	    }
	}
      else if (!nowait)
	{
	  p = string;
	}
      else
	{
	  printf ("\'%s\' expected\n", string);
	  printf ("char %d is %d", p - string, c);
	  error ("\n");
	}
    }
}

/* Keep discarding input until we see the prompt.  */

static void
expect_prompt (void)
{
  expect (">", 0);
}


/* Read one character */

#ifdef DEBUG_STDIN

/* read from stdin */

static int
readchar (void)
{
  char buf[1];

  buf[0] = '\0';
  printf ("readchar, give one character\n");
  read (0, buf, 1);

#if defined (LOG_FILE)
  putc (buf[0] & 0x7f, log_file);
#endif

  return (buf[0] & 0x7f);
}

#else /* !DEBUG_STDIN */

/* Read a character from the remote system, doing all the fancy
   timeout stuff.  */

static int
readchar (void)
{
  int ch;

  ch = serial_readchar (es1800_desc, timeout);

  /* FIXME: doing an error() here will probably cause trouble, at least if from
     es1800_wait.  */
  if (ch == SERIAL_TIMEOUT)
    error ("Timeout reading from remote system.");
  else if (ch == SERIAL_ERROR)
    perror_with_name ("remote read");

#if defined (LOG_FILE)
  putc (ch & 0x7f, log_file);
  fflush (log_file);
#endif

  return (ch);
}

#endif /* DEBUG_STDIN */


/* Send a command to the emulator and save the reply.
   Report an error if we get an error reply.
   string - the es1800 command
   buf    - containing the emulator reply on return
   len    - size of buf  */

static void
send_with_reply (char *string, char *buf, int len)
{
  send (string);
  serial_write (es1800_desc, "\r", 1);

#ifndef DEBUG_STDIN
  expect (string, 1);
  expect ("\r\n", 0);
#endif

  getmessage (buf, len);
}


/* Send the command in STR to the emulator adding \r. check
   the echo for consistency. 
   string - the es1800 command  */

static void
send_command (char *string)
{
  send (string);
  serial_write (es1800_desc, "\r", 1);

#ifndef DEBUG_STDIN
  expect (string, 0);
  expect_prompt ();
#endif

}

/* Send a string
   string - the es1800 command  */

static void
send (char *string)
{
  if (kiodebug)
    {
      fprintf_unfiltered (gdb_stderr, "Sending: %s\n", string);
    }
  serial_write (es1800_desc, string, strlen (string));
}


/* Read a message from the emulator and store it in BUF. 
   buf    - containing the emulator reply on return
   len    - size of buf  */

static void
getmessage (char *buf, int len)
{
  char *bp;
  int c;
  int prompt_found = 0;
  extern kiodebug;

#if defined (LOG_FILE)
  /* This is a convenient place to do this.  The idea is to do it often
     enough that we never lose much data if we terminate abnormally.  */
  fflush (log_file);
#endif

  bp = buf;
  c = readchar ();
  do
    {
      if (c)
	{
	  if (len-- < 2)	/* char and terminaling NULL */
	    {
	      error ("input buffer overrun\n");
	    }
	  *bp++ = c;
	}
      c = readchar ();
      if ((c == '>') && (*(bp - 1) == ' '))
	{
	  prompt_found = 1;
	}
    }
  while (!prompt_found);
  *bp = 0;

  if (kiodebug)
    {
      fprintf_unfiltered (gdb_stderr, "message received :%s\n", buf);
    }
}

static void
download (FILE *instream, int from_tty, int format)
{
  char c;
  char buf[160];
  int i = 0;

  send_command ("SET #2,$1A");	/* reset char = ^Z */
  send_command ("SET #3,$11,$13");	/* XON  XOFF */
  if (format == 2)
    {
      send_command ("SET #26,#2");
    }
  else
    {
      send_command ("SET #26,#5");	/* Format=Extended Tekhex */
    }
  send_command ("DFB = $10");
  send_command ("PUR");
  send_command ("CES");
  send ("DNL\r");
  expect ("DNL", 1);
  if (from_tty)
    {
      printf ("    0 records loaded...\r");
    }
  while (fgets (buf, 160, instream))
    {
      send (buf);
      if (from_tty)
	{
	  printf ("%5d\b\b\b\b\b", ++i);
	  fflush (stdout);
	}
      if ((c = readchar ()) != 006)
	{
	  error ("expected ACK");
	}
    }
  if (from_tty)
    {
      printf ("- All");
    }
}

/* Additional commands */

#if defined (TIOCGETP) && defined (FNDELAY) && defined (EWOULDBLOCK)
#define PROVIDE_TRANSPARENT
#endif

#ifdef PROVIDE_TRANSPARENT
/* Talk directly to the emulator
   FIXME, uses busy wait, and is SUNOS (or at least BSD) specific  */

/*ARGSUSED */
static void
es1800_transparent (char *args, int from_tty)
{
  int console;
  struct sgttyb modebl;
  int fcflag;
  int cc;
  struct sgttyb console_mode_save;
  int console_fc_save;
  int es1800_fc_save;
  int inputcnt = 80;
  char inputbuf[80];
  int consolecnt = 0;
  char consolebuf[80];
  int es1800_cnt = 0;
  char es1800_buf[80];
  int i;

  dont_repeat ();
  if (es1800_desc == NULL)
    {
      printf ("No emulator attached, type emulator-command first\n");
      return;
    }

  printf ("\n");
  printf ("You are now communicating directly with the ES 1800 emulator.\n");
  printf ("To leave this mode (transparent mode), press ^E.\n");
  printf ("\n");
  printf (" >");
  fflush (stdout);

  if ((console = open ("/dev/tty", O_RDWR)) == -1)
    {
      perror_with_name ("/dev/tty:");
    }

  if ((fcflag = fcntl (console, F_GETFL, 0)) == -1)
    {
      perror_with_name ("fcntl console");
    }

  console_fc_save = fcflag;
  fcflag = fcflag | FNDELAY;

  if (fcntl (console, F_SETFL, fcflag) == -1)
    {
      perror_with_name ("fcntl console");
    }

  if (ioctl (console, TIOCGETP, &modebl))
    {
      perror_with_name ("ioctl console");
    }

  console_mode_save = modebl;
  modebl.sg_flags = RAW;

  if (ioctl (console, TIOCSETP, &modebl))
    {
      perror_with_name ("ioctl console");
    }

  if ((fcflag = fcntl (deprecated_serial_fd (es1800_desc), F_GETFL, 0)) == -1)
    {
      perror_with_name ("fcntl serial");
    }

  es1800_fc_save = fcflag;
  fcflag = fcflag | FNDELAY;

  if (fcntl (deprecated_serial_fd (es1800_desc), F_SETFL, fcflag) == -1)
    {
      perror_with_name ("fcntl serial");
    }

  while (1)
    {
      cc = read (console, inputbuf, inputcnt);
      if (cc != -1)
	{
	  if ((*inputbuf & 0x7f) == 0x05)
	    {
	      break;
	    }
	  for (i = 0; i < cc;)
	    {
	      es1800_buf[es1800_cnt++] = inputbuf[i++];
	    }
	  if ((cc = serial_write (es1800_desc, es1800_buf, es1800_cnt)) == -1)
	    {
	      perror_with_name ("FEL! write:");
	    }
	  es1800_cnt -= cc;
	  if (es1800_cnt && cc)
	    {
	      for (i = 0; i < es1800_cnt; i++)
		{
		  es1800_buf[i] = es1800_buf[cc + i];
		}
	    }
	}
      else if (errno != EWOULDBLOCK)
	{
	  perror_with_name ("FEL! read:");
	}

      cc = read (deprecated_serial_fd (es1800_desc), inputbuf, inputcnt);
      if (cc != -1)
	{
	  for (i = 0; i < cc;)
	    {
	      consolebuf[consolecnt++] = inputbuf[i++];
	    }
	  if ((cc = write (console, consolebuf, consolecnt)) == -1)
	    {
	      perror_with_name ("FEL! write:");
	    }
	  consolecnt -= cc;
	  if (consolecnt && cc)
	    {
	      for (i = 0; i < consolecnt; i++)
		{
		  consolebuf[i] = consolebuf[cc + i];
		}
	    }
	}
      else if (errno != EWOULDBLOCK)
	{
	  perror_with_name ("FEL! read:");
	}
    }

  console_fc_save = console_fc_save & !FNDELAY;
  if (fcntl (console, F_SETFL, console_fc_save) == -1)
    {
      perror_with_name ("FEL! fcntl");
    }

  if (ioctl (console, TIOCSETP, &console_mode_save))
    {
      perror_with_name ("FEL! ioctl");
    }

  close (console);

  if (fcntl (deprecated_serial_fd (es1800_desc), F_SETFL, es1800_fc_save) == -1)
    {
      perror_with_name ("FEL! fcntl");
    }

  printf ("\n");

}
#endif /* PROVIDE_TRANSPARENT */

static void
es1800_init_break (char *args, int from_tty)
{
  CORE_ADDR memaddress = 0;
  char buf[PBUFSIZ];
  char base_addr[4];
  char *space_index;
  char *p;
  int k;

  if (args == NULL)
    {
      error_no_arg ("a trap vector");
    }

  if (!(space_index = strchr (args, ' ')))
    {
      error ("Two arguments needed (trap vector and address of break routine).\n");
    }

  *space_index = '\0';

  es1800_break_vec = strtol (args, (char **) NULL, 0);
  es1800_break_address = parse_and_eval_address (space_index + 1);

  es1800_create_break_insn (es1800_break_insn, es1800_break_vec);

  if (m68020)
    {
      send_with_reply ("VBR ", buf, sizeof (buf));
      p = buf;
      for (k = 0; k < 4; k++)
	{
	  if ((p[k * 2 + 1] == 0) || (p[k * 2 + 2] == 0))
	    {
	      error ("Emulator reply is too short: %s", buf);
	    }
	  base_addr[k] = (fromhex (p[k * 2 + 1]) * 16) + fromhex (p[k * 2 + 2]);
	}
      /* base addr of exception vector table */
      memaddress = *((CORE_ADDR *) base_addr);
    }

  memaddress += (es1800_break_vec + 32) * 4;	/* address of trap vector */

  sprintf (buf, "@@.L%lx=$%lx", memaddress, es1800_break_address);
  send_command (buf);		/* set the address of the break routine in the */
  /* trap vector */

  sprintf (buf, "@@.L%lx=$4E714E71", es1800_break_address);	/* NOP; NOP */
  send_command (buf);
  sprintf (buf, "@@.L%lx=$4E714E73", es1800_break_address + 4);	/* NOP; RTE */
  send_command (buf);

  sprintf (buf, "AC2=$%lx", es1800_break_address + 4);
  /* breakpoint at es1800-break_address */
  send_command (buf);
  send_command ("WHEN AC2 THEN BRK");	/* ie in exception routine */

  if (from_tty)
    {
      printf ("Breakpoint (trap $%x) routine at address: %lx\n",
	      es1800_break_vec, es1800_break_address);
    }
}

static void
es1800_child_open (char *arg, int from_tty)
{
  error ("Use the \"run\" command to start a child process.");
}

static void
es1800_child_detach (char *args, int from_tty)
{
  if (args)
    {
      error ("Argument given to \"detach\" when remotely debugging.");
    }

  pop_target ();
  if (from_tty)
    {
      printf ("Ending debugging the process %d.\n", PIDGET (inferior_ptid));
    }
}


/* Define the target subroutine names  */

struct target_ops es1800_ops;

static void
init_es1800_ops (void)
{
  es1800_ops.to_shortname = "es1800";
  es1800_ops.to_longname = "Remote serial target in ES1800-emulator protocol";
  es1800_ops.to_doc = "Remote debugging on the es1800 emulator via a serial line.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  es1800_ops.to_open = es1800_open;
  es1800_ops.to_close = es1800_close;
  es1800_ops.to_attach = es1800_attach;
  es1800_ops.to_detach = es1800_detach;
  es1800_ops.to_resume = es1800_resume;
  es1800_ops.to_prepare_to_store = es1800_prepare_to_store;
  es1800_ops.to_xfer_memory = es1800_xfer_inferior_memory;
  es1800_ops.to_files_info = es1800_files_info;
  es1800_ops.to_insert_breakpoint = es1800_insert_breakpoint;
  es1800_ops.to_remove_breakpoint = es1800_remove_breakpoint;
  es1800_ops.to_load = es1800_load;
  es1800_ops.to_create_inferior = es1800_create_inferior;
  es1800_ops.to_stratum = core_stratum;
  es1800_ops.to_has_memory = 1;
  es1800_ops.to_magic = OPS_MAGIC;
}

/* Define the target subroutine names  */

struct target_ops es1800_child_ops;

static void
init_es1800_child_ops (void)
{
  es1800_child_ops.to_shortname = "es1800_process";
  es1800_child_ops.to_longname = "Remote serial target in ES1800-emulator protocol";
  es1800_child_ops.to_doc = "Remote debugging on the es1800 emulator via a serial line.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  es1800_child_ops.to_open = es1800_child_open;
  es1800_child_ops.to_attach = es1800_attach;
  es1800_child_ops.to_detach = es1800_child_detach;
  es1800_child_ops.to_resume = es1800_resume;
  es1800_child_ops.to_wait = es1800_wait;
  es1800_child_ops.to_fetch_registers = es1800_fetch_register;
  es1800_child_ops.to_store_registers = es1800_store_register;
  es1800_child_ops.to_prepare_to_store = es1800_prepare_to_store;
  es1800_child_ops.to_xfer_memory = es1800_xfer_inferior_memory;
  es1800_child_ops.to_files_info = es1800_files_info;
  es1800_child_ops.to_insert_breakpoint = es1800_insert_breakpoint;
  es1800_child_ops.to_remove_breakpoint = es1800_remove_breakpoint;
  es1800_child_ops.to_kill = es1800_kill;
  es1800_child_ops.to_load = es1800_load;
  es1800_child_ops.to_create_inferior = es1800_create_inferior;
  es1800_child_ops.to_mourn_inferior = es1800_mourn_inferior;
  es1800_child_ops.to_stratum = process_stratum;
  es1800_child_ops.to_has_all_memory = 1;
  es1800_child_ops.to_has_memory = 1;
  es1800_child_ops.to_has_stack = 1;
  es1800_child_ops.to_has_registers = 1;
  es1800_child_ops.to_has_execution = 1;
  es1800_child_ops.to_magic = OPS_MAGIC;
}

void
_initialize_es1800 (void)
{
  init_es1800_ops ();
  init_es1800_child_ops ();
  add_target (&es1800_ops);
  add_target (&es1800_child_ops);
#ifdef PROVIDE_TRANSPARENT
  add_com ("transparent", class_support, es1800_transparent,
	   "Start transparent communication with the ES 1800 emulator.");
#endif /* PROVIDE_TRANSPARENT */
  add_com ("init_break", class_support, es1800_init_break,
	 "Download break routine and initialize break facility on ES 1800");
}
@


1.25
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@@


1.24
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@d1358 1
a1358 1
	  if (!bfd_get_section_contents (from_bfd, p, (PTR) buf, (file_ptr) i,
d1363 1
a1363 1
	  if (!bfd_set_section_contents (to_bfd, new, (PTR) buf, (file_ptr) i,
d1369 1
a1369 1
      bfd_get_section_contents (from_bfd, p, (PTR) buf, (file_ptr) i,
d1371 1
a1371 1
      bfd_set_section_contents (to_bfd, new, (PTR) buf, (file_ptr) i,
@


1.23
log
@	* gnu-nat.c (init_gnu_ops): Remove NULL initializations.
	* monitor.c (init_base_monitor_ops): Likewise.
	* ppc-bdm.c (init_bdm_ppc_ops): Likewise.
	* remote-array.c (init_array_ops): Likewise.
	* remote-e7000.c (init_e7000_ops): Likewise.
	* remote-es.c (init_es1800_ops): Likewise.
	(init_es1800_child_ops): Likewise.
	* remote-rdp.c (init_remote_rdp_ops): Likewise.
	* remote-sim.c (init_gdbsim_ops): Likewise.
	* remote-st.c (init_st2000_ops): Likewise.
	* sol-thread.c (init_sol_core_ops): Likewise.
	(init_sol_thread_ops): Likewise.
	* v850ice.c (init_850ice_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
@
text
@d626 1
a626 1
	  registers[r++] = (fromhex (p[k * 2 + 1]) * 16) + fromhex (p[k * 2 + 2]);
d669 1
a669 1
	  registers[r++] = (fromhex (p[i + 0]) * 16) + fromhex (p[i + 1]);
d688 1
a688 1
	  registers[r++] = (fromhex (p[i + 0])) * 16 + fromhex (p[i + 1]);
d728 1
a728 1
	  registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
d738 1
a738 1
	  registers[r++] =
d749 1
a749 1
	  registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
d774 1
a774 1
	  registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
d786 1
a786 1
	  registers[r++] =
d800 1
a800 1
	  registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
d830 1
a830 1
  r = (unsigned char *) registers;
@


1.22
log
@Fix some K&R isms.
@
text
@a1983 2
  es1800_ops.to_post_attach = NULL;
  es1800_ops.to_require_attach = NULL;
a1984 1
  es1800_ops.to_require_detach = NULL;
a1985 4
  es1800_ops.to_wait = NULL;
  es1800_ops.to_post_wait = NULL;
  es1800_ops.to_fetch_registers = NULL;
  es1800_ops.to_store_registers = NULL;
a1990 6
  es1800_ops.to_terminal_init = NULL;
  es1800_ops.to_terminal_inferior = NULL;
  es1800_ops.to_terminal_ours_for_output = NULL;
  es1800_ops.to_terminal_ours = NULL;
  es1800_ops.to_terminal_info = NULL;
  es1800_ops.to_kill = NULL;
a1991 1
  es1800_ops.to_lookup_symbol = NULL;
a1992 23
  es1800_ops.to_post_startup_inferior = NULL;
  es1800_ops.to_acknowledge_created_inferior = NULL;
  es1800_ops.to_clone_and_follow_inferior = NULL;
  es1800_ops.to_post_follow_inferior_by_clone = NULL;
  es1800_ops.to_insert_fork_catchpoint = NULL;
  es1800_ops.to_remove_fork_catchpoint = NULL;
  es1800_ops.to_insert_vfork_catchpoint = NULL;
  es1800_ops.to_remove_vfork_catchpoint = NULL;
  es1800_ops.to_has_forked = NULL;
  es1800_ops.to_has_vforked = NULL;
  es1800_ops.to_can_follow_vfork_prior_to_exec = NULL;
  es1800_ops.to_post_follow_vfork = NULL;
  es1800_ops.to_insert_exec_catchpoint = NULL;
  es1800_ops.to_remove_exec_catchpoint = NULL;
  es1800_ops.to_has_execd = NULL;
  es1800_ops.to_reported_exec_events_per_exec_call = NULL;
  es1800_ops.to_has_exited = NULL;
  es1800_ops.to_mourn_inferior = NULL;
  es1800_ops.to_can_run = 0;
  es1800_ops.to_notice_signals = 0;
  es1800_ops.to_thread_alive = 0;
  es1800_ops.to_stop = 0;
  es1800_ops.to_pid_to_exec_file = NULL;
a1993 2
  es1800_ops.DONT_USE = 0;
  es1800_ops.to_has_all_memory = 0;
a1994 5
  es1800_ops.to_has_stack = 0;
  es1800_ops.to_has_registers = 0;
  es1800_ops.to_has_execution = 0;
  es1800_ops.to_sections = NULL;
  es1800_ops.to_sections_end = NULL;
a2009 1
  es1800_child_ops.to_close = NULL;
a2010 2
  es1800_child_ops.to_post_attach = NULL;
  es1800_child_ops.to_require_attach = NULL;
a2011 1
  es1800_child_ops.to_require_detach = NULL;
a2013 1
  es1800_child_ops.to_post_wait = NULL;
a2020 5
  es1800_child_ops.to_terminal_init = NULL;
  es1800_child_ops.to_terminal_inferior = NULL;
  es1800_child_ops.to_terminal_ours_for_output = NULL;
  es1800_child_ops.to_terminal_ours = NULL;
  es1800_child_ops.to_terminal_info = NULL;
a2022 1
  es1800_child_ops.to_lookup_symbol = NULL;
a2023 17
  es1800_child_ops.to_post_startup_inferior = NULL;
  es1800_child_ops.to_acknowledge_created_inferior = NULL;
  es1800_child_ops.to_clone_and_follow_inferior = NULL;
  es1800_child_ops.to_post_follow_inferior_by_clone = NULL;
  es1800_child_ops.to_insert_fork_catchpoint = NULL;
  es1800_child_ops.to_remove_fork_catchpoint = NULL;
  es1800_child_ops.to_insert_vfork_catchpoint = NULL;
  es1800_child_ops.to_remove_vfork_catchpoint = NULL;
  es1800_child_ops.to_has_forked = NULL;
  es1800_child_ops.to_has_vforked = NULL;
  es1800_child_ops.to_can_follow_vfork_prior_to_exec = NULL;
  es1800_child_ops.to_post_follow_vfork = NULL;
  es1800_child_ops.to_insert_exec_catchpoint = NULL;
  es1800_child_ops.to_remove_exec_catchpoint = NULL;
  es1800_child_ops.to_has_execd = NULL;
  es1800_child_ops.to_reported_exec_events_per_exec_call = NULL;
  es1800_child_ops.to_has_exited = NULL;
a2024 5
  es1800_child_ops.to_can_run = 0;
  es1800_child_ops.to_notice_signals = 0;
  es1800_child_ops.to_thread_alive = 0;
  es1800_child_ops.to_stop = 0;
  es1800_child_ops.to_pid_to_exec_file = NULL;
a2025 1
  es1800_child_ops.DONT_USE = 0;
a2030 2
  es1800_child_ops.to_sections = NULL;
  es1800_child_ops.to_sections_end = NULL;
@


1.22.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.22.8.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d626 1
a626 1
	  deprecated_registers[r++] = (fromhex (p[k * 2 + 1]) * 16) + fromhex (p[k * 2 + 2]);
d669 1
a669 1
	  deprecated_registers[r++] = (fromhex (p[i + 0]) * 16) + fromhex (p[i + 1]);
d688 1
a688 1
	  deprecated_registers[r++] = (fromhex (p[i + 0])) * 16 + fromhex (p[i + 1]);
d728 1
a728 1
	  deprecated_registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
d738 1
a738 1
	  deprecated_registers[r++] =
d749 1
a749 1
	  deprecated_registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
d774 1
a774 1
	  deprecated_registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
d786 1
a786 1
	  deprecated_registers[r++] =
d800 1
a800 1
	  deprecated_registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
d830 1
a830 1
  r = (unsigned char *) deprecated_registers;
d1984 2
d1987 1
d1989 4
d1998 6
d2005 1
d2007 23
d2031 2
d2034 5
d2054 1
d2056 2
d2059 1
d2062 1
d2070 5
d2077 1
d2079 17
d2097 5
d2103 1
d2109 2
@


1.22.8.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@@


1.21
log
@2002-04-24  Pierre Muller  <ics.u-strasbg.fr>

	* remote-array.c (printf_monitor, write_monitor,
	array_insert_breakpoint, array_remove_breakpoint ):
	Replace fprintf (stderr,...
	with fprintf_unfiltered (gdb_stderr,....
	* remote-es.c: Likewise.
	* remote-os9k.c: Likewise.
	* remote-st.c: Likewise.
@
text
@d139 3
a141 3
static int
es1800_xfer_inferior_memory (CORE_ADDR, char *, int, int,
			     struct mem_attrib *, struct target_ops *);
@


1.21.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d139 3
a141 3
static int es1800_xfer_inferior_memory (CORE_ADDR, char *, int, int,
					struct mem_attrib *,
					struct target_ops *);
@


1.20
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d1619 1
a1619 1
      fprintf (stderr, "Sending: %s\n", string);
d1666 1
a1666 1
      fprintf (stderr, "message received :%s\n", buf);
@


1.19
log
@Add explicit #include of "value.h".
@
text
@d2 3
a4 2
   Copyright 1988, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d966 2
a967 3
			     int write, 
			     struct mem_attrib *attrib ATTRIBUTE_UNUSED,
			     struct target_ops *target ATTRIBUTE_UNUSED)
@


1.18
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d114 1
@


1.17
log
@s/typedef serial_t/struct serial */
@
text
@d314 1
a314 1
  es1800_desc = SERIAL_OPEN (name);
d321 1
a321 1
  es1800_saved_ttystate = SERIAL_GET_TTY_STATE (es1800_desc);
d323 1
a323 1
  if ((fcflag = fcntl (DEPRECATED_SERIAL_FD (es1800_desc), F_GETFL, 0)) == -1)
d330 1
a330 1
  if (fcntl (DEPRECATED_SERIAL_FD (es1800_desc), F_SETFL, fcflag) == -1)
d337 1
a337 1
      if (SERIAL_SETBAUDRATE (es1800_desc, baud_rate))
d339 1
a339 1
	  SERIAL_CLOSE (es1800_desc);
d344 1
a344 1
  SERIAL_RAW (es1800_desc);
d348 1
a348 1
  SERIAL_FLUSH_INPUT (es1800_desc);
d430 1
a430 1
      if (SERIAL_SET_TTY_STATE (es1800_desc, es1800_saved_ttystate) < 0)
d432 2
a433 2
      fcntl (DEPRECATED_SERIAL_FD (es1800_desc), F_SETFL, es1800_fc_save);
      SERIAL_CLOSE (es1800_desc);
d1552 1
a1552 1
  ch = SERIAL_READCHAR (es1800_desc, timeout);
d1582 1
a1582 1
  SERIAL_WRITE (es1800_desc, "\r", 1);
d1601 1
a1601 1
  SERIAL_WRITE (es1800_desc, "\r", 1);
d1620 1
a1620 1
  SERIAL_WRITE (es1800_desc, string, strlen (string));
d1788 1
a1788 1
  if ((fcflag = fcntl (DEPRECATED_SERIAL_FD (es1800_desc), F_GETFL, 0)) == -1)
d1796 1
a1796 1
  if (fcntl (DEPRECATED_SERIAL_FD (es1800_desc), F_SETFL, fcflag) == -1)
d1814 1
a1814 1
	  if ((cc = SERIAL_WRITE (es1800_desc, es1800_buf, es1800_cnt)) == -1)
d1832 1
a1832 1
      cc = read (DEPRECATED_SERIAL_FD (es1800_desc), inputbuf, inputcnt);
d1871 1
a1871 1
  if (fcntl (DEPRECATED_SERIAL_FD (es1800_desc), F_SETFL, es1800_fc_save) == -1)
@


1.16
log
@Phase 1 of the ptid_t changes.
@
text
@d234 1
a234 1
static serial_t es1800_desc = NULL;
@


1.15
log
@* target.h (target_ops): Removed to_core_file_to_sym_file vector
function.
* corelow.c (core_ops): Updated for above change.
* gnu-nat.c (core_ops): Likewise.
* inftarg.c (child_ops): Likewise.
* monitor.c (monitor_ops): Likewise.
* ppc-bdm.c (bdm_ppc_ops): Likewise.
* remote-adapt.c (adapt_ops): Likewise.
* remote-bug.c (bug_ops): Likewise.
* remote-e7000.c (e7000_ops): Likewise.
* remote-eb.c (eb_ops): Likewise.
* remote-es.c (es1800_ops, es1800_child_ops): Likewise.
* remote-mm.c (mm_ops): Likewise.
* remote-nindy.c (nindy_ops): Likewise.
* remote-nrom.c (nrom_ops): Likewise.
* remote-os9k.c (rombug_ops): Likewise.
* remote-rdp.c (remote_rdp_ops): Likewise.
* remote-sim.c (gdbsim_ops): Likewise.
* remote-st.c (st2000_ops): Likewise.
* v850ice.c (v850ice_ops): Likewise.
* target.c (cleanup_target): Likewise
(update_current_target): Likewise.
(setup_target_debug): Likewise
(debug_to_core_file_to_sym_file): Removed.

* corefile.c (core_file_command) [HPUXHPPA]: Removed code that
sets symbol file from information obtained from the core file.
* corelow.c (core_file_to_sym_file): Removed.
@
text
@d143 1
a143 1
static int es1800_wait (int, struct target_waitstatus *);
d145 1
a145 1
static void es1800_resume (int, int, enum target_signal);
d503 1
a503 1
es1800_resume (int pid, int step, enum target_signal siggnal)
d526 2
a527 2
static int
es1800_wait (int pid, struct target_waitstatus *status)
d592 1
a592 1
  return (0);
d1209 1
a1209 1
  if (inferior_pid != 0)
d1211 1
a1211 1
      inferior_pid = 0;
d1276 1
a1276 1
  inferior_pid = 0;
d1377 1
a1377 1
/* Start an process on the es1800 and set inferior_pid to the new
d1430 1
a1430 1
  inferior_pid = pid;		/* Needed for wait_for_inferior below */
d1964 1
a1964 1
      printf ("Ending debugging the process %d.\n", inferior_pid);
@


1.14
log
@Update/correct copyright notices.
@
text
@a2028 1
  es1800_ops.to_core_file_to_sym_file = NULL;
a2100 1
  es1800_child_ops.to_core_file_to_sym_file = NULL;
@


1.13
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright (C) 1988, 1992, 2001 Free Software Foundation, Inc.
@


1.12
log
@Replace calls to abort() with calls to internal_error().
@
text
@d112 1
@


1.11
log
@* monitor.c (#include "gdb_wait.h"): Removed.
* ocd.c: Likewise.
* ppc-bdm.c: Likewise.
* remote-adapt.c: Likewise.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-eb.c: Likewise.
* remote-es.c: Likewise.
* remote-mips.c: Likewise.
* remote-mm.c: Likewise.
* remote-nindy.c: Likewise.
* remote-os9k.c: Likewise.
* remote-rdi.c: Likewise.
* remote-rdp.c: Likewise.
* remote-sds.c: Likewise.
* remote-sim.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
* remote.c: Likewise.
* ser-pipe.c: Likewise.
* ser-unix.c: Likewise.
* Makefile.in: Updated dependencies.
-------------------------------------------------------------------
@
text
@d1034 1
a1034 1
      abort ();
@


1.10
log
@2001-01-26  Fernando Nasser  <fnasser@@redhat.com>

        Fix double parsing of filenames passed as command line arguments
        to GDB (causes weird handling of escape characters).
        Also, remove dependencies on the CLI from libgdb.
        * call-cmds.h: Remove declaration of exec_file_command().
        * gdbcore.h: Remove declaration of exec_file_command().
        Add declarations for exec_open() and exec_file_clear().
        * symfile.h: Add declarations for symbol_file_add_main() and
        symbol_file_clear().
        * exec.c (exec_open): New function. Implements to_open for exec
        targets.
        (exec_file_clear): New function. Makes GDB forget about a previously
        specified executable file.
        (exec_file_attach): Move parsing of arguments from here ...
        (exec_file_command): ... to here.
        (init_exec_ops): Use exec_open(), not exec_file_command() to
        implement to_open for exec targets.
        * symfile.c (symbol_file_add_main): New function. Call symbol_file_add()        with default values.  Used when the file name has already been parsed.
        (symbol_file_clear): New function. Makes GDB forget about previously
        read symbols.
        (symbol_file_command): Call the above function instead of inline code.
        * main.c: Include "symfile.h" and "gdbcore.h" instead of the deprecated
        "call-cmds.h".
        (captured_main): Call exec_file_attach() and symbol_file_add_main()
        instead of exec_file_command() and symbol_file_command().
        (captured_main): Add comment.
        * corefile.c: Include "symfile.h".
        (core_file_command): Call symbol_file_add_main() instead of
        symbol_file_command().
        (reopen_exec_file): Call exec_open() instead of exec_file_command().
        * infcmd.c: Include "symfile.h".
        (attach_command): Call symbol_file_add_main() instead of
        symbol_file_command().
        * infrun.c: Remove comment about the inclusion of "symfile.h",
        not any longer appropriate.
        (follow_exec): Call symbol_file_add_main() instead of
        symbol_file_command().
        * remote-es.c: Include "symfile.h".
        (es1800_load): Call symbol_file_add_main() instead of
        symbol_file_command().
        * remote-vx.c: Remove comment about the inclusion of "symfile.h",
        not any longer appropriate.
        (vx-wait): Call symbol_file_add_main() instead of
        symbol_file_command().
        * solib-svr4.c (open_symbol_file_object): Call symbol_file_add_main()
        instead of symbol_file_command().
        * v850ice.c (ice_file): Call exec_open(), exec_file_attach() and
        symbol_file_add_main() instead of exec_file_command() and
        symbol_file_command().
        * Makefile.in: Update dependencies.
@
text
@a106 1
#include "gdb_wait.h"
@


1.9
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@d109 1
d1322 1
a1322 1
  symbol_file_command (filename, from_tty);	/* reading symbol table */
@


1.8
log
@Replace STRCMP with strcmp()
@
text
@d2 1
a2 1
   Copyright (C) 1988, 1992 Free Software Foundation, Inc.
d137 1
a137 1
			     struct target_ops *);
d962 3
a964 1
			     int write, struct target_ops *tops)
@


1.7
log
@Replace free() with xfree().
@
text
@d1154 1
a1154 1
      return (STRCMP (instr, buf));
@


1.6
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@d436 1
a436 1
      free (savename);
d1238 1
a1238 1
  make_cleanup (free, filename);
@


1.5
log
@Protoization.
@
text
@d1161 1
a1161 1
   find address of breakpint routine
@


1.4
log
@Protoization.
@
text
@d957 2
a958 1
   write   - write if != 0 otherwise read       */
d961 2
a962 6
es1800_xfer_inferior_memory (memaddr, myaddr, len, write, tops)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *tops;	/* Unused */
d1065 1
a1065 1
/* Information about the current target  */
d1068 1
a1068 2
es1800_files_info (tops)
     struct target_ops *tops;	/* Unused */
@


1.3
log
@PARAMS removal.
@
text
@d252 1
a252 1
es1800_request_quit ()
d265 1
a265 2
es1800_reset (quit)
     char *quit;
d292 1
a292 3
es1800_open (name, from_tty)
     char *name;
     int from_tty;
d423 1
a423 2
es1800_close (quitting)
     int quitting;
d464 1
a464 3
es1800_attach (args, from_tty)
     char *args;
     int from_tty;
d482 1
a482 3
es1800_detach (args, from_tty)
     char *args;
     int from_tty;
d501 1
a501 4
es1800_resume (pid, step, siggnal)
     int pid;
     int step;
     enum target_signal siggnal;
d525 1
a525 3
es1800_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d598 1
a598 2
es1800_fetch_register (regno)
     int regno;
d635 1
a635 1
es1800_fetch_registers ()
d807 1
a807 2
es1800_store_register (regno)
     int regno;
d905 1
a905 1
es1800_prepare_to_store ()
d913 1
a913 2
fromhex (a)
     int a;
d938 1
a938 2
tohex (nib)
     int nib;
d1000 1
a1000 4
es1800_write_bytes (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d1023 1
a1023 4
es1800_read_bytes (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d1091 1
a1091 3
es1800_insert_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d1115 1
a1115 3
es1800_remove_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d1126 1
a1126 3
es1800_create_break_insn (ins, vec)
     char *ins;
     int vec;
d1142 1
a1142 2
verify_break (vec)
     int vec;
d1170 1
a1170 3
get_break_addr (vec, addrp)
     int vec;
     CORE_ADDR *addrp;
d1207 1
a1207 1
es1800_kill ()
d1226 1
a1226 3
es1800_load (filename, from_tty)
     char *filename;
     int from_tty;
d1332 1
a1332 3
bfd_copy (from_bfd, to_bfd)
     bfd *from_bfd;
     bfd *to_bfd;
d1384 1
a1384 4
es1800_create_inferior (execfile, args, env)
     char *execfile;
     char *args;
     char **env;
d1460 1
a1460 1
es1800_mourn_inferior ()
d1476 1
a1476 3
expect (string, nowait)
     char *string;
     int nowait;
d1514 1
a1514 1
expect_prompt ()
d1527 1
a1527 1
readchar ()
d1548 1
a1548 1
readchar ()
d1579 1
a1579 3
send_with_reply (string, buf, len)
     char *string, *buf;
     int len;
d1598 1
a1598 2
send_command (string)
     char *string;
d1614 1
a1614 2
send (string)
     char *string;
d1629 1
a1629 3
getmessage (buf, len)
     char *buf;
     int len;
d1670 1
a1670 4
download (instream, from_tty, format)
     FILE *instream;
     int from_tty;
     int format;
d1726 1
a1726 3
es1800_transparent (args, from_tty)
     char *args;
     int from_tty;
d1882 1
a1882 3
es1800_init_break (args, from_tty)
     char *args;
     int from_tty;
d1948 1
a1948 3
es1800_child_open (arg, from_tty)
     char *arg;
     int from_tty;
d1954 1
a1954 3
es1800_child_detach (args, from_tty)
     char *args;
     int from_tty;
d2116 1
a2116 1
_initialize_es1800 ()
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d115 1
a115 2
static void
es1800_child_detach PARAMS ((char *, int));
d117 1
a117 2
static void
es1800_child_open PARAMS ((char *, int));
d119 1
a119 2
static void
es1800_transparent PARAMS ((char *, int));
d121 1
a121 2
static void
es1800_create_inferior PARAMS ((char *, char *, char **));
d123 1
a123 2
static void
es1800_load PARAMS ((char *, int));
d125 1
a125 2
static void
es1800_kill PARAMS ((void));
d127 1
a127 2
static int
verify_break PARAMS ((int));
d129 1
a129 2
static int
es1800_remove_breakpoint PARAMS ((CORE_ADDR, char *));
d131 1
a131 2
static int
es1800_insert_breakpoint PARAMS ((CORE_ADDR, char *));
d133 1
a133 2
static void
es1800_files_info PARAMS ((struct target_ops *));
d136 2
a137 2
es1800_xfer_inferior_memory PARAMS ((CORE_ADDR, char *, int, int,
				     struct target_ops *));
d139 1
a139 2
static void
es1800_prepare_to_store PARAMS ((void));
d141 1
a141 1
static int es1800_wait PARAMS ((int, struct target_waitstatus *));
d143 1
a143 1
static void es1800_resume PARAMS ((int, int, enum target_signal));
d145 1
a145 2
static void
es1800_detach PARAMS ((char *, int));
d147 1
a147 2
static void
es1800_attach PARAMS ((char *, int));
d149 1
a149 2
static int
damn_b PARAMS ((char *));
d151 1
a151 2
static void
es1800_open PARAMS ((char *, int));
d153 1
a153 2
static void
es1800_timer PARAMS ((void));
d155 1
a155 2
static void
es1800_reset PARAMS ((char *));
d157 1
a157 2
static void
es1800_request_quit PARAMS ((void));
d159 1
a159 2
static int
readchar PARAMS ((void));
d161 1
a161 2
static void
expect PARAMS ((char *, int));
d163 1
a163 2
static void
expect_prompt PARAMS ((void));
d165 1
a165 2
static void
download PARAMS ((FILE *, int, int));
d168 1
a168 2
static void
bfd_copy PARAMS ((bfd *, bfd *));
d171 1
a171 2
static void
get_break_addr PARAMS ((int, CORE_ADDR *));
d173 1
a173 2
static int
fromhex PARAMS ((int));
d175 1
a175 2
static int
tohex PARAMS ((int));
d177 1
a177 2
static void
es1800_close PARAMS ((int));
d179 1
a179 2
static void
es1800_fetch_registers PARAMS ((void));
d181 1
a181 2
static void
es1800_fetch_register PARAMS ((int));
d183 1
a183 2
static void
es1800_store_register PARAMS ((int));
d185 1
a185 2
static void
es1800_read_bytes PARAMS ((CORE_ADDR, char *, int));
d187 1
a187 2
static void
es1800_write_bytes PARAMS ((CORE_ADDR, char *, int));
d189 1
a189 2
static void
send_with_reply PARAMS ((char *, char *, int));
d191 1
a191 2
static void
send_command PARAMS ((char *));
d193 1
a193 2
static void
send PARAMS ((char *));
d195 1
a195 2
static void
getmessage PARAMS ((char *, int));
d197 1
a197 2
static void
es1800_mourn_inferior PARAMS ((void));
d199 1
a199 2
static void
es1800_create_break_insn PARAMS ((char *, int));
d201 1
a201 2
static void
es1800_init_break PARAMS ((char *, int));
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
This file is part of GDB.
d12 14
a25 13
GDB is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.

GDB is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 61
a91 61
        Request
Command
Reply
	read registers:
DR<cr>
     - 0 -    - 1 -    - 2 -    - 3 -      - 4 -    - 5 -    -- 6 -   - 7 - 
D = XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX   XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
A = XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX   XXXXXXXX XXXXXXXX XXXXXXXX 
    PC = XXXXXX       SSP = XXXXXX    USP = XXXXXX     SR = XXXXXXXX
 >
Each byte of register data is described by two hex digits.

	write regs
D0=XXXXXXXX<cr>
 >D1=XXXXXXXX<cr>
 >D2=XXXXXXXX<cr>
 >D3=XXXXXXXX<cr>
 >D4=XXXXXXXX<cr>
 >D5=XXXXXXXX<cr>
 >D6=XXXXXXXX<cr>
 >D7=XXXXXXXX<cr>
 >A0=XXXXXXXX<cr>
 >A1=XXXXXXXX<cr>
 >A2=XXXXXXXX<cr>
 >A3=XXXXXXXX<cr>
 >A4=XXXXXXXX<cr>
 >A5=XXXXXXXX<cr>
 >A6=XXXXXXXX<cr>
 >A7=XXXXXXXX<cr>
 >SR=XXXXXXXX<cr>
 >PC=XXXXXX<cr>
 >
Each byte of register data is described by two hex digits.

	read mem
@@.BAA..AA
$FFFFFFXX
 >
AA..AA is address, XXXXXXX is the contents

	write mem
	@@.BAA..AA=$XXXXXXXX
 >
AA..AA is address, XXXXXXXX is data

	cont
PC=$AA..AA
 >RBK
R>
AA..AA is address to resume. If AA..AA is omitted, resume at same address.

	step
PC=$AA..AA
 >STP
R>
AA..AA is address to resume. If AA..AA is omitted, resume at same address.

	kill req
STP
 >
*/
d107 1
a107 1
#include "wait.h"
d121 1
a121 1
static void 
d149 1
a149 1
static void 
d250 1
a250 1
extern struct target_ops es1800_ops;		/* Forward decl */
d254 2
a255 2
static int timeout = 100; 
static char *savename;				/* Name of i/o device used */
d257 1
a257 1
static int es1800_fc_save;			/* Save fcntl state */
d284 1
a284 1
static void (*old_sigint)();		/* Old signal-handler for sigint */
d301 1
a301 1
   quit - return to '(esgdb)' prompt or continue	*/
d342 1
a342 1
  if (!name)           /* no device name given in target command */
d363 1
a363 1
  if ((fcflag = fcntl (es1800_desc->fd, F_GETFL, 0)) == -1)
d369 2
a370 2
  fcflag = (fcflag & (FREAD | FWRITE)); /* mask out any funny stuff */
  if (fcntl (es1800_desc->fd, F_SETFL, fcflag) == -1)
d390 1
a390 1
#endif	/* DEBUG_STDIN */
d406 1
a406 1
#endif	/* LOG_FILE */
d411 1
a411 1
  /*  for (p = buf, i = 0; *p++ =='0';)  */   /* count the number of zeros */
d415 1
a415 1
  getmessage (buf, sizeof (buf));  /* send reset character */
d421 1
a421 1
  /*  m68020 = (i==8); */   /* if eight zeros then we are in m68020 mode */
d423 1
a423 1
  /* What kind of processor am i talking to ?*/
d425 12
a436 4
  while (*p++ != '\n') {;}
  while (*p++ != '\n') {;}
  while (*p++ != '\n') {;}
  for (i = 0; i < 20; i++, p++) {;}
d462 1
a462 1
    quitting - are we quitting gdb now? */
d473 1
a473 1
      fcntl (es1800_desc->fd, F_SETFL, es1800_fc_save);
d498 1
a498 1
#endif	/* LOG_FILE */
d503 2
a504 2
    proc_id  - the id of the process to be attached.
    from_tty - says whether to be verbose or not */
d508 2
a509 2
    char *args;
    int from_tty;
d522 1
a522 1
 
d561 1
a561 1
      strcpy (buf,"STP\r");
d573 1
a573 1
 
d585 1
a585 1
  timeout = 0;		/* Don't time out -- user program is running. */
d590 3
a592 3
        {
	  getmessage (buf, sizeof(buf));
	  if (strncmp ( buf, "\r\n* BREAK *", 11) == 0) 
d620 1
a620 1
        }
d633 1
a633 1
        }
d637 1
a637 1
	  es1800_reset ((char*) 1);
d657 6
a662 6
  static char regtab[18][4] = 
    {
      "D0 ", "D1 ", "D2 ", "D3 ", "D4 ", "D5 ", "D6 ", "D7 ",
      "A0 ", "A1 ", "A2 ", "A3 ", "A4 ", "A5 ", "A6 ", "SSP",
      "SR ", "PC "
    };
d671 1
a671 1
	  if ((p[k*2 + 1] == 0) || (p[k*2 + 2] == 0))
d675 1
a675 1
	  registers[r++] = (fromhex (p[k*2 + 1]) * 16) + fromhex (p[k*2 + 2]);
d707 3
a709 1
  while (*p++ != '\n') {;}
d714 1
a714 1
	  if (p[i+0] == 0 || p[i+1] == 0)
d718 1
a718 1
	  registers[r++] = (fromhex (p[i+0]) * 16) + fromhex (p[i+1]);
d726 3
a728 1
  while (*p++ != '\n') {;}
d733 1
a733 1
	  if (p[i+0] == 0 || p[i+1] == 0)
d737 1
a737 1
	  registers[r++] = (fromhex (p[i+0])) * 16 + fromhex (p[i+1]);
d743 3
a745 1
  while (*p++ != '\n') {;}
d757 1
a757 1
      if (*p == '3')		 /* use masterstackpointer MSP */
d765 2
a766 1
      else			/* use userstackpointer USP  */
d768 1
a768 1
	  send_with_reply ("USP", buf, sizeof (buf)); 
d771 1
a771 1
      for (k = 0; k<4; k++)
d773 1
a773 1
	  if (p[k*2+1] == 0 || p[k*2+2] == 0)
d777 1
a777 1
	  registers[r++] = fromhex (buf[k*2+1]) * 16 + fromhex (buf[k*2+2]);
d783 1
a783 1
	  if (p[k*2+1] == 0 || p[k*2+2] == 0)
d788 1
a788 1
	    fromhex (SR_buf[k*2+1]) * 16 + fromhex (SR_buf[k*2+2]);
d792 1
a792 1
      for (k = 0; k<4; k++)
d794 1
a794 1
	  if (p[k*2+1] == 0 || p[k*2+2] == 0)
d798 1
a798 1
	  registers[r++] = fromhex (buf[k*2+1]) * 16 + fromhex (buf[k*2+2]);
d801 4
a804 3
  else    /* 68000-mode */
    {                       
      if (*p == '2') /* use supervisorstackpointer SSP  */
d806 1
a806 1
	  send_with_reply ("SSP", buf, sizeof (buf)); 
d808 2
a809 1
      else  /* use userstackpointer USP  */
d811 1
a811 1
	  send_with_reply ("USP", buf, sizeof (buf)); 
d819 1
a819 1
	  if (p[k*2 + 1] == 0 || p[k*2 + 2] == 0)
d823 1
a823 1
	  registers[r++] = fromhex (buf[k*2+1]) * 16 + fromhex (buf[k*2+2]);
d831 1
a831 1
	  if (p[k*2+1] == 0 || p[k*2+2] == 0)
d836 1
a836 1
	    fromhex (SR_buf[k*2+1]) * 16 + fromhex (SR_buf[k*2+2]);
d841 1
a841 1
      send_with_reply ("PC", buf, sizeof (buf)); 
d845 1
a845 1
	  if (p[k*2+1] == 0 || p[k*2+2] == 0)
d849 2
a850 2
	  registers[r++] = fromhex (buf[k*2+1]) * 16 + fromhex (buf[k*2+2]);
	}    
d856 1
a856 1
           (-1 means store them all)
d860 1
a860 1
es1800_store_register(regno)
d865 5
a869 5
    {
      "D0 ", "D1 ", "D2 ", "D3 ", "D4 ", "D5 ", "D6 ", "D7 ",
      "A0 ", "A1 ", "A2 ", "A3 ", "A4 ", "A5 ", "A6 ", "SSP",
      "SR ", "PC "
    };
d882 1
a882 1
  if (regno == -1)  /* write all registers */
d887 2
a888 1
  else              /* write one register */
d891 3
a893 3
      k = regno+1;
      r += regno * 4; 
    }    
d903 1
a903 1
	  if (*p == '3') /* use masterstackpointer MSP */
d905 1
a905 1
	      strcpy (stack_pointer,"MSP");  
d909 1
a909 1
	      if (*p == '2') /* use interruptstackpointer ISP  */
d911 1
a911 1
		  strcpy (stack_pointer,"ISP");  
d915 1
a915 1
		  strcpy (stack_pointer,"USP");  /* use userstackpointer USP  */
d919 2
a920 1
      else  /* 68000-mode */
d922 1
a922 1
	  if (*p == '2') /* use supervisorstackpointer SSP  */
d924 1
a924 1
	      strcpy (stack_pointer,"SSP");  
d928 1
a928 1
	      strcpy (stack_pointer,"USP");/* use userstackpointer USP  */  
d931 1
a931 1
      strcpy (regtab[15],stack_pointer);
d934 1
a934 1
  for (i = j; i<k; i++)
d951 1
a951 1
      send_with_reply (buf, buf, sizeof (buf)); /* FIXME, reply not used? */
d958 1
a958 1
static void 
d1009 1
a1009 1
 
d1013 1
a1013 1
   write   - write if != 0 otherwise read	*/
d1041 1
a1041 1
  return (origlen); /* no error possible */
d1050 1
a1050 1
 
d1068 2
a1069 2
      sprintf (buf, "@@.B$%x=$%x", memaddr+i, (*p++) & 0xff);
      send_with_reply (buf, buf, sizeof (buf));      /* FIXME send_command? */
d1076 1
a1076 1
 
d1087 2
a1088 1
  static int DB_tab[16] = {8,11,14,17,20,23,26,29,34,37,40,43,46,49,52,55};
d1100 1
a1100 1
  if (len == 1)	/* The emulator does not like expressions like:  */
d1102 1
a1102 1
      len = 2;	/* DB.B $20018 TO $20018                       */
d1108 1
a1108 1
  sprintf (buf, "DB.B $%x TO $%x", memaddr, memaddr+len-1);
d1111 1
a1111 1
  low_addr = memaddr&0x0f;
d1115 4
a1118 2
	{   /* if (i = 16,32,48)  */
	  while (*p++!='\n') {;}
d1121 1
a1121 1
      p = b + DB_tab[i%16] + (m68020 ? 2 : 0);
d1126 1
a1126 1
      myaddr[i-low_addr] = fromhex (p[0]) * 16 + fromhex (p[1]);
d1143 1
a1143 1
 
d1146 3
a1148 3
                    It is guaranteed by the caller to be long enough to save sizeof 
                    BREAKPOINT bytes.
 
d1157 1
a1157 1
  int val; 
d1172 1
a1172 1
 
d1175 3
a1177 3
                    It is guaranteed by the caller to be long enough to save sizeof 
                    BREAKPOINT bytes.	*/
 
d1215 1
a1215 1
  char *instr = "NqNqNqNs";      /* breakpoint routine */
d1222 1
a1222 1
      status = target_read_memory (memaddress, buf, 8); 
d1229 1
a1229 1
    return (-1);
d1236 1
a1236 1
   addrp - store the address here	*/
d1256 1
a1256 1
	  if ((p[k*2 + 1] == 0) || (p[k*2 + 2] == 0))
d1260 1
a1260 1
	  base_addr[k] = (fromhex (p[k*2 + 1]) * 16) + fromhex (p[k*2 + 2]);
d1266 6
a1271 6
    memaddress += (vec + 32) * 4;     /* address of trap vector */
    status = target_read_memory (memaddress, (char *) addrp, 4); 
    if (status != 0)                                                   
      {
	memory_error (status, memaddress);
      }
d1294 2
a1295 2
   FIXME Uses emulator overlay memory for trap routine	*/
 
d1308 1
a1308 1
  if (es1800_desc == NULL) 
d1319 24
a1342 24
      case 2:   /* Extended Tekhex  */
        if (from_tty)
	  {
	    printf ("Converting \"%s\" to Extended Tekhex Format\n", filename);
	  }
	sprintf (buf, "tekhex %s", filename);
	system (buf);
	sprintf (loadname, "out.hex");
	break;

      case 5:   /* Motorola S-rec  */
	if (from_tty)
	  {
	    printf ("Converting \"%s\" to Motorola S-record format\n",
		    filename);
	  }
	/* in the future the source code in copy (part of binutils-1.93) will
	   be included in this file */
	sprintf (buf,
		 "copy -s \"a.out-sunos-big\" -d \"srec\" %s /tmp/out.hex",
		 filename);
	system (buf);
	sprintf (loadname, "/tmp/out.hex");
	break;
d1344 2
a1345 2
      default:
	error ("Downloading format not defined\n");
d1347 1
a1347 1
 
d1352 1
a1352 1
      printf ("Downloading \"%s\" to the ES 1800\n",filename);
d1382 1
a1382 1
  readchar ();  /* FIXME I am getting a ^G = 7 after the prompt  */
d1396 1
a1396 1
  symbol_file_command (filename, from_tty);   /* reading symbol table */
d1429 2
a1430 2
      
      for (i = 0; (i + NUMCPYBYTES) < p->_cooked_size ; i += NUMCPYBYTES)
d1433 1
a1433 1
					(bfd_size_type) NUMCPYBYTES))
d1437 6
a1442 6
	if (!bfd_set_section_contents (to_bfd, new, (PTR) buf, (file_ptr) i,
				      (bfd_size_type) NUMCPYBYTES))
	  {
	    error ("bfd_set_section_contents\n");
	  }
      }
d1445 1
a1445 1
      bfd_set_section_contents (to_bfd, new, (PTR) buf,(file_ptr) i,
d1456 1
a1456 1
   env      - the environment vector to pass	*/
d1551 2
a1552 2
            read until string is found (== 0)   */
 
d1556 1
a1556 1
    int nowait;
d1584 1
a1584 1
	  printf ("\'%s\' expected\n" , string);
d1586 1
a1586 1
	  error ("\n" );
d1622 1
a1622 1
#else	/* !DEBUG_STDIN */
d1649 1
a1649 1
#endif	/* DEBUG_STDIN */
d1660 2
a1661 2
    char *string, *buf;
    int len;
d1678 1
a1678 1
 
d1700 1
a1700 1
  if (kiodebug) 
d1711 1
a1711 1
 
d1732 1
a1732 1
      if (c) 
d1734 1
a1734 1
	  if (len-- < 2) /* char and terminaling NULL */
d1748 1
a1748 1
  
d1751 1
a1751 1
      fprintf (stderr,"message received :%s\n", buf);
d1757 1
a1757 1
FILE *instream;
d1765 2
a1766 2
  send_command ("SET #2,$1A");                  /* reset char = ^Z */
  send_command ("SET #3,$11,$13");              /* XON  XOFF */
d1773 1
a1773 1
      send_command ("SET #26,#5");		/* Format=Extended Tekhex */
d1785 12
a1796 12
      {
	send (buf);
	if (from_tty)
	  {
	    printf ("%5d\b\b\b\b\b",++i);
	    fflush (stdout);
	  }
	if ((c = readchar ()) != 006) 
	  {
	    error ("expected ACK");
	  }
      }
d1813 2
a1814 2
/*ARGSUSED*/
static void 
d1835 1
a1835 1
  if (es1800_desc == NULL) 
d1848 1
a1848 1
  if ((console = open ("/dev/tty", O_RDWR)) == -1) 
d1872 1
a1872 1
  modebl.sg_flags = RAW; 
d1879 1
a1879 1
  if ((fcflag = fcntl (es1800_desc->fd, F_GETFL, 0)) == -1)
d1887 1
a1887 1
  if (fcntl (es1800_desc->fd, F_SETFL, fcflag) == -1)
d1893 1
a1893 1
    { 
d1901 1
a1901 1
	  for (i = 0; i < cc; )
d1910 1
a1910 1
	  if (es1800_cnt && cc) 
d1914 1
a1914 1
		  es1800_buf[i] = es1800_buf[cc+i];
d1922 2
a1923 2
      
      cc = read (es1800_desc->fd,inputbuf,inputcnt);
d1926 1
a1926 1
	  for (i = 0; i < cc; )
d1930 1
a1930 1
	  if ((cc = write (console,consolebuf,consolecnt)) == -1)
d1935 1
a1935 1
	  if (consolecnt && cc) 
d1939 1
a1939 1
		  consolebuf[i] = consolebuf[cc+i];
d1962 1
a1962 1
  if (fcntl (es1800_desc->fd, F_SETFL, es1800_fc_save) == -1)
d2007 1
a2007 1
	  if ((p[k*2 + 1] == 0) || (p[k*2 + 2] == 0))
d2011 1
a2011 1
	  base_addr[k] = (fromhex (p[k*2 + 1]) * 16) + fromhex (p[k*2 + 2]);
d2014 1
a2014 1
      memaddress =  *((CORE_ADDR *) base_addr);
d2017 1
a2017 1
  memaddress += (es1800_break_vec + 32) * 4;     /* address of trap vector */
d2020 4
a2023 4
  send_command (buf);   /* set the address of the break routine in the */
  		       /* trap vector */
  
  sprintf (buf, "@@.L%lx=$4E714E71", es1800_break_address);      /* NOP; NOP */
d2025 1
a2025 1
  sprintf (buf, "@@.L%lx=$4E714E73", es1800_break_address + 4);  /* NOP; RTE */
d2027 1
a2027 1
  
d2031 1
a2031 1
  send_command ("WHEN AC2 THEN BRK");          /* ie in exception routine */
d2038 1
a2038 1
}	  
d2057 1
a2057 1
  
d2068 1
a2068 1
struct target_ops es1800_ops ;
d2070 2
a2071 2
static void 
init_es1800_ops(void)
d2073 8
a2080 8
  es1800_ops.to_shortname =   "es1800";		
  es1800_ops.to_longname =   "Remote serial target in ES1800-emulator protocol";
  es1800_ops.to_doc =   "Remote debugging on the es1800 emulator via a serial line.\n\
Specify the serial device it is connected to (e.g. /dev/ttya)." ;
  es1800_ops.to_open =   es1800_open;		
  es1800_ops.to_close =   es1800_close;		
  es1800_ops.to_attach =   es1800_attach;
  es1800_ops.to_post_attach = NULL;	
d2082 1
a2082 1
  es1800_ops.to_detach =   es1800_detach;	
d2084 19
a2102 19
  es1800_ops.to_resume =   es1800_resume;	
  es1800_ops.to_wait  =   NULL;
  es1800_ops.to_post_wait = NULL;	
  es1800_ops.to_fetch_registers  =   NULL;	
  es1800_ops.to_store_registers  =   NULL;	
  es1800_ops.to_prepare_to_store =   es1800_prepare_to_store;
  es1800_ops.to_xfer_memory  =   es1800_xfer_inferior_memory;
  es1800_ops.to_files_info  =   es1800_files_info;		
  es1800_ops.to_insert_breakpoint =   es1800_insert_breakpoint;	
  es1800_ops.to_remove_breakpoint =   es1800_remove_breakpoint;	
  es1800_ops.to_terminal_init  =   NULL;			
  es1800_ops.to_terminal_inferior =   NULL;			
  es1800_ops.to_terminal_ours_for_output =   NULL;		
  es1800_ops.to_terminal_ours  =   NULL;			
  es1800_ops.to_terminal_info  =   NULL;			
  es1800_ops.to_kill  =   NULL;			
  es1800_ops.to_load  =   es1800_load;		
  es1800_ops.to_lookup_symbol =   NULL;		
  es1800_ops.to_create_inferior =   es1800_create_inferior;
d2105 1
a2105 1
  es1800_ops.to_clone_and_follow_inferior = NULL;  
d2110 1
a2110 1
  es1800_ops.to_remove_vfork_catchpoint = NULL;              
d2112 2
a2113 2
  es1800_ops.to_has_vforked = NULL;            
  es1800_ops.to_can_follow_vfork_prior_to_exec = NULL;    
d2120 5
a2124 5
  es1800_ops.to_mourn_inferior =   NULL;			
  es1800_ops.to_can_run  =   0;			
  es1800_ops.to_notice_signals =   0;		
  es1800_ops.to_thread_alive  =   0;		
  es1800_ops.to_stop  =   0;
d2126 11
a2136 11
  es1800_ops.to_core_file_to_sym_file = NULL;	
  es1800_ops.to_stratum =   core_stratum;	
  es1800_ops.DONT_USE =   0;			
  es1800_ops.to_has_all_memory =   0;		
  es1800_ops.to_has_memory =   1;		
  es1800_ops.to_has_stack =   0;		
  es1800_ops.to_has_registers =   0;		
  es1800_ops.to_has_execution =   0;		
  es1800_ops.to_sections =   NULL;		
  es1800_ops.to_sections_end =   NULL;		
  es1800_ops.to_magic =   OPS_MAGIC ;		
d2141 1
a2141 1
struct target_ops es1800_child_ops ;
d2143 2
a2144 2
static void 
init_es1800_child_ops(void)
d2146 3
a2148 3
  es1800_child_ops.to_shortname =   "es1800_process";	
  es1800_child_ops.to_longname =   "Remote serial target in ES1800-emulator protocol";
  es1800_child_ops.to_doc =   "Remote debugging on the es1800 emulator via a serial line.\n\
d2150 3
a2152 3
  es1800_child_ops.to_open =   es1800_child_open;	
  es1800_child_ops.to_close =   NULL;			
  es1800_child_ops.to_attach =   es1800_attach;
d2154 22
a2175 22
  es1800_child_ops.to_require_attach = NULL;	
  es1800_child_ops.to_detach =   es1800_child_detach;
  es1800_child_ops.to_require_detach = NULL;	
  es1800_child_ops.to_resume =   es1800_resume;	
  es1800_child_ops.to_wait  =   es1800_wait;
  es1800_child_ops.to_post_wait = NULL;	
  es1800_child_ops.to_fetch_registers  =   es1800_fetch_register;
  es1800_child_ops.to_store_registers  =   es1800_store_register;
  es1800_child_ops.to_prepare_to_store =   es1800_prepare_to_store;
  es1800_child_ops.to_xfer_memory  =   es1800_xfer_inferior_memory;
  es1800_child_ops.to_files_info  =   es1800_files_info;		
  es1800_child_ops.to_insert_breakpoint =   es1800_insert_breakpoint;	
  es1800_child_ops.to_remove_breakpoint =   es1800_remove_breakpoint;	
  es1800_child_ops.to_terminal_init  =   NULL;			
  es1800_child_ops.to_terminal_inferior =   NULL;			
  es1800_child_ops.to_terminal_ours_for_output =   NULL;		
  es1800_child_ops.to_terminal_ours  =   NULL;			
  es1800_child_ops.to_terminal_info  =   NULL;			
  es1800_child_ops.to_kill  =   es1800_kill;			
  es1800_child_ops.to_load  =   es1800_load;			
  es1800_child_ops.to_lookup_symbol =   NULL;			
  es1800_child_ops.to_create_inferior =   es1800_create_inferior;
d2183 1
a2183 1
  es1800_child_ops.to_remove_vfork_catchpoint = NULL;        
d2185 1
a2185 1
  es1800_child_ops.to_has_vforked = NULL;          
d2193 5
a2197 5
  es1800_child_ops.to_mourn_inferior =   es1800_mourn_inferior;	
  es1800_child_ops.to_can_run  =   0;				
  es1800_child_ops.to_notice_signals =   0;			
  es1800_child_ops.to_thread_alive  =   0;			
  es1800_child_ops.to_stop  =   0;
d2200 10
a2209 10
  es1800_child_ops.to_stratum =   process_stratum;		
  es1800_child_ops.DONT_USE =   0;				
  es1800_child_ops.to_has_all_memory =   1;			
  es1800_child_ops.to_has_memory =   1;			
  es1800_child_ops.to_has_stack =   1;			
  es1800_child_ops.to_has_registers =   1;			
  es1800_child_ops.to_has_execution =   1;			
  es1800_child_ops.to_sections =   NULL;			
  es1800_child_ops.to_sections_end =   NULL;			
  es1800_child_ops.to_magic =   OPS_MAGIC;			
d2215 2
a2216 2
  init_es1800_ops() ;
  init_es1800_child_ops() ;
d2224 1
a2224 1
	   "Download break routine and initialize break facility on ES 1800");
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d10 1
a10 1
   This file is part of GDB.
d12 13
a24 14
   GDB is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   GDB is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d30 61
a90 61
   Request
   Command
   Reply
   read registers:
   DR<cr>
   - 0 -    - 1 -    - 2 -    - 3 -      - 4 -    - 5 -    -- 6 -   - 7 - 
   D = XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX   XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
   A = XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX   XXXXXXXX XXXXXXXX XXXXXXXX 
   PC = XXXXXX       SSP = XXXXXX    USP = XXXXXX     SR = XXXXXXXX
   >
   Each byte of register data is described by two hex digits.

   write regs
   D0=XXXXXXXX<cr>
   >D1=XXXXXXXX<cr>
   >D2=XXXXXXXX<cr>
   >D3=XXXXXXXX<cr>
   >D4=XXXXXXXX<cr>
   >D5=XXXXXXXX<cr>
   >D6=XXXXXXXX<cr>
   >D7=XXXXXXXX<cr>
   >A0=XXXXXXXX<cr>
   >A1=XXXXXXXX<cr>
   >A2=XXXXXXXX<cr>
   >A3=XXXXXXXX<cr>
   >A4=XXXXXXXX<cr>
   >A5=XXXXXXXX<cr>
   >A6=XXXXXXXX<cr>
   >A7=XXXXXXXX<cr>
   >SR=XXXXXXXX<cr>
   >PC=XXXXXX<cr>
   >
   Each byte of register data is described by two hex digits.

   read mem
   @@.BAA..AA
   $FFFFFFXX
   >
   AA..AA is address, XXXXXXX is the contents

   write mem
   @@.BAA..AA=$XXXXXXXX
   >
   AA..AA is address, XXXXXXXX is data

   cont
   PC=$AA..AA
   >RBK
   R>
   AA..AA is address to resume. If AA..AA is omitted, resume at same address.

   step
   PC=$AA..AA
   >STP
   R>
   AA..AA is address to resume. If AA..AA is omitted, resume at same address.

   kill req
   STP
   >
 */
d120 1
a120 1
static void
d148 1
a148 1
static void
d249 1
a249 1
extern struct target_ops es1800_ops;	/* Forward decl */
d253 2
a254 2
static int timeout = 100;
static char *savename;		/* Name of i/o device used */
d256 1
a256 1
static int es1800_fc_save;	/* Save fcntl state */
d283 1
a283 1
static void (*old_sigint) ();	/* Old signal-handler for sigint */
d300 1
a300 1
   quit - return to '(esgdb)' prompt or continue        */
d341 1
a341 1
  if (!name)			/* no device name given in target command */
d368 1
a368 1
  fcflag = (fcflag & (FREAD | FWRITE));		/* mask out any funny stuff */
d389 1
a389 1
#endif /* DEBUG_STDIN */
d405 1
a405 1
#endif /* LOG_FILE */
d410 1
a410 1
  /*  for (p = buf, i = 0; *p++ =='0';)  *//* count the number of zeros */
d414 1
a414 1
  getmessage (buf, sizeof (buf));	/* send reset character */
d420 1
a420 1
  /*  m68020 = (i==8); *//* if eight zeros then we are in m68020 mode */
d422 1
a422 1
  /* What kind of processor am i talking to ? */
d424 4
a427 12
  while (*p++ != '\n')
    {;
    }
  while (*p++ != '\n')
    {;
    }
  while (*p++ != '\n')
    {;
    }
  for (i = 0; i < 20; i++, p++)
    {;
    }
d453 1
a453 1
   quitting - are we quitting gdb now? */
d489 1
a489 1
#endif /* LOG_FILE */
d494 2
a495 2
   proc_id  - the id of the process to be attached.
   from_tty - says whether to be verbose or not */
d499 2
a500 2
     char *args;
     int from_tty;
d513 1
a513 1

d552 1
a552 1
      strcpy (buf, "STP\r");
d564 1
a564 1

d576 1
a576 1
  timeout = 0;			/* Don't time out -- user program is running. */
d581 3
a583 3
	{
	  getmessage (buf, sizeof (buf));
	  if (strncmp (buf, "\r\n* BREAK *", 11) == 0)
d611 1
a611 1
	}
d624 1
a624 1
	}
d628 1
a628 1
	  es1800_reset ((char *) 1);
d648 6
a653 6
  static char regtab[18][4] =
  {
    "D0 ", "D1 ", "D2 ", "D3 ", "D4 ", "D5 ", "D6 ", "D7 ",
    "A0 ", "A1 ", "A2 ", "A3 ", "A4 ", "A5 ", "A6 ", "SSP",
    "SR ", "PC "
  };
d662 1
a662 1
	  if ((p[k * 2 + 1] == 0) || (p[k * 2 + 2] == 0))
d666 1
a666 1
	  registers[r++] = (fromhex (p[k * 2 + 1]) * 16) + fromhex (p[k * 2 + 2]);
d698 1
a698 3
  while (*p++ != '\n')
    {;
    }
d703 1
a703 1
	  if (p[i + 0] == 0 || p[i + 1] == 0)
d707 1
a707 1
	  registers[r++] = (fromhex (p[i + 0]) * 16) + fromhex (p[i + 1]);
d715 1
a715 3
  while (*p++ != '\n')
    {;
    }
d720 1
a720 1
	  if (p[i + 0] == 0 || p[i + 1] == 0)
d724 1
a724 1
	  registers[r++] = (fromhex (p[i + 0])) * 16 + fromhex (p[i + 1]);
d730 1
a730 3
  while (*p++ != '\n')
    {;
    }
d742 1
a742 1
      if (*p == '3')		/* use masterstackpointer MSP */
d750 1
a750 2
      else
	/* use userstackpointer USP  */
d752 1
a752 1
	  send_with_reply ("USP", buf, sizeof (buf));
d755 1
a755 1
      for (k = 0; k < 4; k++)
d757 1
a757 1
	  if (p[k * 2 + 1] == 0 || p[k * 2 + 2] == 0)
d761 1
a761 1
	  registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
d767 1
a767 1
	  if (p[k * 2 + 1] == 0 || p[k * 2 + 2] == 0)
d772 1
a772 1
	    fromhex (SR_buf[k * 2 + 1]) * 16 + fromhex (SR_buf[k * 2 + 2]);
d776 1
a776 1
      for (k = 0; k < 4; k++)
d778 1
a778 1
	  if (p[k * 2 + 1] == 0 || p[k * 2 + 2] == 0)
d782 1
a782 1
	  registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
d785 3
a787 4
  else
    /* 68000-mode */
    {
      if (*p == '2')		/* use supervisorstackpointer SSP  */
d789 1
a789 1
	  send_with_reply ("SSP", buf, sizeof (buf));
d791 1
a791 2
      else
	/* use userstackpointer USP  */
d793 1
a793 1
	  send_with_reply ("USP", buf, sizeof (buf));
d801 1
a801 1
	  if (p[k * 2 + 1] == 0 || p[k * 2 + 2] == 0)
d805 1
a805 1
	  registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
d813 1
a813 1
	  if (p[k * 2 + 1] == 0 || p[k * 2 + 2] == 0)
d818 1
a818 1
	    fromhex (SR_buf[k * 2 + 1]) * 16 + fromhex (SR_buf[k * 2 + 2]);
d823 1
a823 1
      send_with_reply ("PC", buf, sizeof (buf));
d827 1
a827 1
	  if (p[k * 2 + 1] == 0 || p[k * 2 + 2] == 0)
d831 2
a832 2
	  registers[r++] = fromhex (buf[k * 2 + 1]) * 16 + fromhex (buf[k * 2 + 2]);
	}
d838 1
a838 1
   (-1 means store them all)
d842 1
a842 1
es1800_store_register (regno)
d847 5
a851 5
  {
    "D0 ", "D1 ", "D2 ", "D3 ", "D4 ", "D5 ", "D6 ", "D7 ",
    "A0 ", "A1 ", "A2 ", "A3 ", "A4 ", "A5 ", "A6 ", "SSP",
    "SR ", "PC "
  };
d864 1
a864 1
  if (regno == -1)		/* write all registers */
d869 1
a869 2
  else
    /* write one register */
d872 3
a874 3
      k = regno + 1;
      r += regno * 4;
    }
d884 1
a884 1
	  if (*p == '3')	/* use masterstackpointer MSP */
d886 1
a886 1
	      strcpy (stack_pointer, "MSP");
d890 1
a890 1
	      if (*p == '2')	/* use interruptstackpointer ISP  */
d892 1
a892 1
		  strcpy (stack_pointer, "ISP");
d896 1
a896 1
		  strcpy (stack_pointer, "USP");	/* use userstackpointer USP  */
d900 1
a900 2
      else
	/* 68000-mode */
d902 1
a902 1
	  if (*p == '2')	/* use supervisorstackpointer SSP  */
d904 1
a904 1
	      strcpy (stack_pointer, "SSP");
d908 1
a908 1
	      strcpy (stack_pointer, "USP");	/* use userstackpointer USP  */
d911 1
a911 1
      strcpy (regtab[15], stack_pointer);
d914 1
a914 1
  for (i = j; i < k; i++)
d931 1
a931 1
      send_with_reply (buf, buf, sizeof (buf));		/* FIXME, reply not used? */
d938 1
a938 1
static void
d989 1
a989 1

d993 1
a993 1
   write   - write if != 0 otherwise read       */
d1021 1
a1021 1
  return (origlen);		/* no error possible */
d1030 1
a1030 1

d1048 2
a1049 2
      sprintf (buf, "@@.B$%x=$%x", memaddr + i, (*p++) & 0xff);
      send_with_reply (buf, buf, sizeof (buf));		/* FIXME send_command? */
d1056 1
a1056 1

d1067 1
a1067 2
  static int DB_tab[16] =
  {8, 11, 14, 17, 20, 23, 26, 29, 34, 37, 40, 43, 46, 49, 52, 55};
d1079 1
a1079 1
  if (len == 1)			/* The emulator does not like expressions like:  */
d1081 1
a1081 1
      len = 2;			/* DB.B $20018 TO $20018                       */
d1087 1
a1087 1
  sprintf (buf, "DB.B $%x TO $%x", memaddr, memaddr + len - 1);
d1090 1
a1090 1
  low_addr = memaddr & 0x0f;
d1094 2
a1095 4
	{			/* if (i = 16,32,48)  */
	  while (*p++ != '\n')
	    {;
	    }
d1098 1
a1098 1
      p = b + DB_tab[i % 16] + (m68020 ? 2 : 0);
d1103 1
a1103 1
      myaddr[i - low_addr] = fromhex (p[0]) * 16 + fromhex (p[1]);
d1120 1
a1120 1

d1123 3
a1125 3
   It is guaranteed by the caller to be long enough to save sizeof 
   BREAKPOINT bytes.

d1134 1
a1134 1
  int val;
d1149 1
a1149 1

d1152 3
a1154 3
   It is guaranteed by the caller to be long enough to save sizeof 
   BREAKPOINT bytes.    */

d1192 1
a1192 1
  char *instr = "NqNqNqNs";	/* breakpoint routine */
d1199 1
a1199 1
      status = target_read_memory (memaddress, buf, 8);
d1206 1
a1206 1
  return (-1);
d1213 1
a1213 1
   addrp - store the address here       */
d1233 1
a1233 1
	  if ((p[k * 2 + 1] == 0) || (p[k * 2 + 2] == 0))
d1237 1
a1237 1
	  base_addr[k] = (fromhex (p[k * 2 + 1]) * 16) + fromhex (p[k * 2 + 2]);
d1243 6
a1248 6
  memaddress += (vec + 32) * 4;	/* address of trap vector */
  status = target_read_memory (memaddress, (char *) addrp, 4);
  if (status != 0)
    {
      memory_error (status, memaddress);
    }
d1271 2
a1272 2
   FIXME Uses emulator overlay memory for trap routine  */

d1285 1
a1285 1
  if (es1800_desc == NULL)
d1296 24
a1319 24
    case 2:			/* Extended Tekhex  */
      if (from_tty)
	{
	  printf ("Converting \"%s\" to Extended Tekhex Format\n", filename);
	}
      sprintf (buf, "tekhex %s", filename);
      system (buf);
      sprintf (loadname, "out.hex");
      break;

    case 5:			/* Motorola S-rec  */
      if (from_tty)
	{
	  printf ("Converting \"%s\" to Motorola S-record format\n",
		  filename);
	}
      /* in the future the source code in copy (part of binutils-1.93) will
         be included in this file */
      sprintf (buf,
	       "copy -s \"a.out-sunos-big\" -d \"srec\" %s /tmp/out.hex",
	       filename);
      system (buf);
      sprintf (loadname, "/tmp/out.hex");
      break;
d1321 2
a1322 2
    default:
      error ("Downloading format not defined\n");
d1324 1
a1324 1

d1329 1
a1329 1
      printf ("Downloading \"%s\" to the ES 1800\n", filename);
d1359 1
a1359 1
  readchar ();			/* FIXME I am getting a ^G = 7 after the prompt  */
d1373 1
a1373 1
  symbol_file_command (filename, from_tty);	/* reading symbol table */
d1406 2
a1407 2

      for (i = 0; (i + NUMCPYBYTES) < p->_cooked_size; i += NUMCPYBYTES)
d1410 1
a1410 1
					 (bfd_size_type) NUMCPYBYTES))
d1414 6
a1419 6
	  if (!bfd_set_section_contents (to_bfd, new, (PTR) buf, (file_ptr) i,
					 (bfd_size_type) NUMCPYBYTES))
	    {
	      error ("bfd_set_section_contents\n");
	    }
	}
d1422 1
a1422 1
      bfd_set_section_contents (to_bfd, new, (PTR) buf, (file_ptr) i,
d1433 1
a1433 1
   env      - the environment vector to pass    */
d1528 2
a1529 2
   read until string is found (== 0)   */

d1533 1
a1533 1
     int nowait;
d1561 1
a1561 1
	  printf ("\'%s\' expected\n", string);
d1563 1
a1563 1
	  error ("\n");
d1599 1
a1599 1
#else /* !DEBUG_STDIN */
d1626 1
a1626 1
#endif /* DEBUG_STDIN */
d1637 2
a1638 2
     char *string, *buf;
     int len;
d1655 1
a1655 1

d1677 1
a1677 1
  if (kiodebug)
d1688 1
a1688 1

d1709 1
a1709 1
      if (c)
d1711 1
a1711 1
	  if (len-- < 2)	/* char and terminaling NULL */
d1725 1
a1725 1

d1728 1
a1728 1
      fprintf (stderr, "message received :%s\n", buf);
d1734 1
a1734 1
     FILE *instream;
d1742 2
a1743 2
  send_command ("SET #2,$1A");	/* reset char = ^Z */
  send_command ("SET #3,$11,$13");	/* XON  XOFF */
d1750 1
a1750 1
      send_command ("SET #26,#5");	/* Format=Extended Tekhex */
d1762 12
a1773 12
    {
      send (buf);
      if (from_tty)
	{
	  printf ("%5d\b\b\b\b\b", ++i);
	  fflush (stdout);
	}
      if ((c = readchar ()) != 006)
	{
	  error ("expected ACK");
	}
    }
d1790 2
a1791 2
/*ARGSUSED */
static void
d1812 1
a1812 1
  if (es1800_desc == NULL)
d1825 1
a1825 1
  if ((console = open ("/dev/tty", O_RDWR)) == -1)
d1849 1
a1849 1
  modebl.sg_flags = RAW;
d1870 1
a1870 1
    {
d1878 1
a1878 1
	  for (i = 0; i < cc;)
d1887 1
a1887 1
	  if (es1800_cnt && cc)
d1891 1
a1891 1
		  es1800_buf[i] = es1800_buf[cc + i];
d1899 2
a1900 2

      cc = read (es1800_desc->fd, inputbuf, inputcnt);
d1903 1
a1903 1
	  for (i = 0; i < cc;)
d1907 1
a1907 1
	  if ((cc = write (console, consolebuf, consolecnt)) == -1)
d1912 1
a1912 1
	  if (consolecnt && cc)
d1916 1
a1916 1
		  consolebuf[i] = consolebuf[cc + i];
d1984 1
a1984 1
	  if ((p[k * 2 + 1] == 0) || (p[k * 2 + 2] == 0))
d1988 1
a1988 1
	  base_addr[k] = (fromhex (p[k * 2 + 1]) * 16) + fromhex (p[k * 2 + 2]);
d1991 1
a1991 1
      memaddress = *((CORE_ADDR *) base_addr);
d1994 1
a1994 1
  memaddress += (es1800_break_vec + 32) * 4;	/* address of trap vector */
d1997 4
a2000 4
  send_command (buf);		/* set the address of the break routine in the */
  /* trap vector */

  sprintf (buf, "@@.L%lx=$4E714E71", es1800_break_address);	/* NOP; NOP */
d2002 1
a2002 1
  sprintf (buf, "@@.L%lx=$4E714E73", es1800_break_address + 4);	/* NOP; RTE */
d2004 1
a2004 1

d2008 1
a2008 1
  send_command ("WHEN AC2 THEN BRK");	/* ie in exception routine */
d2015 1
a2015 1
}
d2034 1
a2034 1

d2045 1
a2045 1
struct target_ops es1800_ops;
d2047 2
a2048 2
static void
init_es1800_ops (void)
d2050 8
a2057 8
  es1800_ops.to_shortname = "es1800";
  es1800_ops.to_longname = "Remote serial target in ES1800-emulator protocol";
  es1800_ops.to_doc = "Remote debugging on the es1800 emulator via a serial line.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  es1800_ops.to_open = es1800_open;
  es1800_ops.to_close = es1800_close;
  es1800_ops.to_attach = es1800_attach;
  es1800_ops.to_post_attach = NULL;
d2059 1
a2059 1
  es1800_ops.to_detach = es1800_detach;
d2061 19
a2079 19
  es1800_ops.to_resume = es1800_resume;
  es1800_ops.to_wait = NULL;
  es1800_ops.to_post_wait = NULL;
  es1800_ops.to_fetch_registers = NULL;
  es1800_ops.to_store_registers = NULL;
  es1800_ops.to_prepare_to_store = es1800_prepare_to_store;
  es1800_ops.to_xfer_memory = es1800_xfer_inferior_memory;
  es1800_ops.to_files_info = es1800_files_info;
  es1800_ops.to_insert_breakpoint = es1800_insert_breakpoint;
  es1800_ops.to_remove_breakpoint = es1800_remove_breakpoint;
  es1800_ops.to_terminal_init = NULL;
  es1800_ops.to_terminal_inferior = NULL;
  es1800_ops.to_terminal_ours_for_output = NULL;
  es1800_ops.to_terminal_ours = NULL;
  es1800_ops.to_terminal_info = NULL;
  es1800_ops.to_kill = NULL;
  es1800_ops.to_load = es1800_load;
  es1800_ops.to_lookup_symbol = NULL;
  es1800_ops.to_create_inferior = es1800_create_inferior;
d2082 1
a2082 1
  es1800_ops.to_clone_and_follow_inferior = NULL;
d2087 1
a2087 1
  es1800_ops.to_remove_vfork_catchpoint = NULL;
d2089 2
a2090 2
  es1800_ops.to_has_vforked = NULL;
  es1800_ops.to_can_follow_vfork_prior_to_exec = NULL;
d2097 5
a2101 5
  es1800_ops.to_mourn_inferior = NULL;
  es1800_ops.to_can_run = 0;
  es1800_ops.to_notice_signals = 0;
  es1800_ops.to_thread_alive = 0;
  es1800_ops.to_stop = 0;
d2103 11
a2113 11
  es1800_ops.to_core_file_to_sym_file = NULL;
  es1800_ops.to_stratum = core_stratum;
  es1800_ops.DONT_USE = 0;
  es1800_ops.to_has_all_memory = 0;
  es1800_ops.to_has_memory = 1;
  es1800_ops.to_has_stack = 0;
  es1800_ops.to_has_registers = 0;
  es1800_ops.to_has_execution = 0;
  es1800_ops.to_sections = NULL;
  es1800_ops.to_sections_end = NULL;
  es1800_ops.to_magic = OPS_MAGIC;
d2118 1
a2118 1
struct target_ops es1800_child_ops;
d2120 2
a2121 2
static void
init_es1800_child_ops (void)
d2123 3
a2125 3
  es1800_child_ops.to_shortname = "es1800_process";
  es1800_child_ops.to_longname = "Remote serial target in ES1800-emulator protocol";
  es1800_child_ops.to_doc = "Remote debugging on the es1800 emulator via a serial line.\n\
d2127 3
a2129 3
  es1800_child_ops.to_open = es1800_child_open;
  es1800_child_ops.to_close = NULL;
  es1800_child_ops.to_attach = es1800_attach;
d2131 22
a2152 22
  es1800_child_ops.to_require_attach = NULL;
  es1800_child_ops.to_detach = es1800_child_detach;
  es1800_child_ops.to_require_detach = NULL;
  es1800_child_ops.to_resume = es1800_resume;
  es1800_child_ops.to_wait = es1800_wait;
  es1800_child_ops.to_post_wait = NULL;
  es1800_child_ops.to_fetch_registers = es1800_fetch_register;
  es1800_child_ops.to_store_registers = es1800_store_register;
  es1800_child_ops.to_prepare_to_store = es1800_prepare_to_store;
  es1800_child_ops.to_xfer_memory = es1800_xfer_inferior_memory;
  es1800_child_ops.to_files_info = es1800_files_info;
  es1800_child_ops.to_insert_breakpoint = es1800_insert_breakpoint;
  es1800_child_ops.to_remove_breakpoint = es1800_remove_breakpoint;
  es1800_child_ops.to_terminal_init = NULL;
  es1800_child_ops.to_terminal_inferior = NULL;
  es1800_child_ops.to_terminal_ours_for_output = NULL;
  es1800_child_ops.to_terminal_ours = NULL;
  es1800_child_ops.to_terminal_info = NULL;
  es1800_child_ops.to_kill = es1800_kill;
  es1800_child_ops.to_load = es1800_load;
  es1800_child_ops.to_lookup_symbol = NULL;
  es1800_child_ops.to_create_inferior = es1800_create_inferior;
d2160 1
a2160 1
  es1800_child_ops.to_remove_vfork_catchpoint = NULL;
d2162 1
a2162 1
  es1800_child_ops.to_has_vforked = NULL;
d2170 5
a2174 5
  es1800_child_ops.to_mourn_inferior = es1800_mourn_inferior;
  es1800_child_ops.to_can_run = 0;
  es1800_child_ops.to_notice_signals = 0;
  es1800_child_ops.to_thread_alive = 0;
  es1800_child_ops.to_stop = 0;
d2177 10
a2186 10
  es1800_child_ops.to_stratum = process_stratum;
  es1800_child_ops.DONT_USE = 0;
  es1800_child_ops.to_has_all_memory = 1;
  es1800_child_ops.to_has_memory = 1;
  es1800_child_ops.to_has_stack = 1;
  es1800_child_ops.to_has_registers = 1;
  es1800_child_ops.to_has_execution = 1;
  es1800_child_ops.to_sections = NULL;
  es1800_child_ops.to_sections_end = NULL;
  es1800_child_ops.to_magic = OPS_MAGIC;
d2192 2
a2193 2
  init_es1800_ops ();
  init_es1800_child_ops ();
d2201 1
a2201 1
	 "Download break routine and initialize break facility on ES 1800");
@


1.1.1.3
log
@import gdb-1999-09-21
@
text
@d363 1
a363 1
  if ((fcflag = fcntl (DEPRECATED_SERIAL_FD (es1800_desc), F_GETFL, 0)) == -1)
d370 1
a370 1
  if (fcntl (DEPRECATED_SERIAL_FD (es1800_desc), F_SETFL, fcflag) == -1)
d473 1
a473 1
      fcntl (DEPRECATED_SERIAL_FD (es1800_desc), F_SETFL, es1800_fc_save);
d1879 1
a1879 1
  if ((fcflag = fcntl (DEPRECATED_SERIAL_FD (es1800_desc), F_GETFL, 0)) == -1)
d1887 1
a1887 1
  if (fcntl (DEPRECATED_SERIAL_FD (es1800_desc), F_SETFL, fcflag) == -1)
d1923 1
a1923 1
      cc = read (DEPRECATED_SERIAL_FD (es1800_desc), inputbuf, inputcnt);
d1962 1
a1962 1
  if (fcntl (DEPRECATED_SERIAL_FD (es1800_desc), F_SETFL, es1800_fc_save) == -1)
@


