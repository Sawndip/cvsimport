head	1.60;
access;
symbols
	drow-reverse-20070409-branch:1.58.0.2
	drow-reverse-20070409-branchpoint:1.58
	insight_6_6-20070208-release:1.56
	gdb_6_6-2006-12-18-release:1.56
	gdb_6_6-branch:1.56.0.18
	gdb_6_6-2006-11-15-branchpoint:1.56
	insight_6_5-20061003-release:1.56
	gdb-csl-symbian-6_4_50_20060226-12:1.56
	gdb-csl-sourcerygxx-3_4_4-25:1.55
	nickrob-async-20060828-mergepoint:1.56
	gdb-csl-symbian-6_4_50_20060226-11:1.56
	gdb-csl-sourcerygxx-4_1-17:1.56
	gdb-csl-20060226-branch-local-2:1.56
	gdb-csl-sourcerygxx-4_1-14:1.56
	gdb-csl-sourcerygxx-4_1-13:1.56
	gdb-csl-sourcerygxx-4_1-12:1.56
	gdb-csl-sourcerygxx-3_4_4-21:1.56
	gdb_6_5-20060621-release:1.56
	gdb-csl-sourcerygxx-4_1-9:1.56
	gdb-csl-sourcerygxx-4_1-8:1.56
	gdb-csl-sourcerygxx-4_1-7:1.56
	gdb-csl-arm-2006q1-6:1.56
	gdb-csl-sourcerygxx-4_1-6:1.56
	gdb-csl-symbian-6_4_50_20060226-10:1.56
	gdb-csl-symbian-6_4_50_20060226-9:1.56
	gdb-csl-symbian-6_4_50_20060226-8:1.56
	gdb-csl-coldfire-4_1-11:1.56
	gdb-csl-sourcerygxx-3_4_4-19:1.56
	gdb-csl-coldfire-4_1-10:1.56
	gdb_6_5-branch:1.56.0.16
	gdb_6_5-2006-05-14-branchpoint:1.56
	gdb-csl-sourcerygxx-4_1-5:1.56
	nickrob-async-20060513-branch:1.56.0.14
	nickrob-async-20060513-branchpoint:1.56
	gdb-csl-sourcerygxx-4_1-4:1.56
	msnyder-reverse-20060502-branch:1.56.0.12
	msnyder-reverse-20060502-branchpoint:1.56
	gdb-csl-morpho-4_1-4:1.56
	gdb-csl-sourcerygxx-3_4_4-17:1.56
	readline_5_1-import-branch:1.56.0.10
	readline_5_1-import-branchpoint:1.56
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.56
	gdb-csl-symbian-20060226-branch:1.56.0.8
	gdb-csl-symbian-20060226-branchpoint:1.56
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.56
	msnyder-reverse-20060331-branch:1.56.0.6
	msnyder-reverse-20060331-branchpoint:1.56
	gdb-csl-available-20060303-branch:1.56.0.4
	gdb-csl-available-20060303-branchpoint:1.56
	gdb-csl-20060226-branch:1.56.0.2
	gdb-csl-20060226-branchpoint:1.56
	gdb_6_4-20051202-release:1.55
	msnyder-fork-checkpoint-branch:1.55.0.10
	msnyder-fork-checkpoint-branchpoint:1.55
	gdb-csl-gxxpro-6_3-branch:1.55.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.55
	gdb_6_4-branch:1.55.0.6
	gdb_6_4-2005-11-01-branchpoint:1.55
	gdb-csl-arm-20051020-branch:1.55.0.4
	gdb-csl-arm-20051020-branchpoint:1.55
	msnyder-tracepoint-checkpoint-branch:1.55.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.55
	gdb-csl-arm-20050325-2005-q1b:1.54
	gdb-csl-arm-20050325-2005-q1a:1.54
	csl-arm-20050325-branch:1.54.0.2
	csl-arm-20050325-branchpoint:1.54
	gdb-post-i18n-errorwarning-20050211:1.51
	gdb-pre-i18n-errorwarning-20050211:1.50
	gdb_6_3-20041109-release:1.49
	gdb_6_3-branch:1.49.0.2
	gdb_6_3-20041019-branchpoint:1.49
	drow_intercu-merge-20040921:1.45
	drow_intercu-merge-20040915:1.44
	jimb-gdb_6_2-e500-branch:1.31.0.6
	jimb-gdb_6_2-e500-branchpoint:1.31
	gdb_6_2-20040730-release:1.31
	gdb_6_2-branch:1.31.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.31
	gdb_6_1_1-20040616-release:1.29
	gdb_6_1-2004-04-05-release:1.29
	drow_intercu-merge-20040402:1.29
	drow_intercu-merge-20040327:1.29
	ezannoni_pie-20040323-branch:1.29.0.12
	ezannoni_pie-20040323-branchpoint:1.29
	cagney_tramp-20040321-mergepoint:1.29
	cagney_tramp-20040309-branch:1.29.0.10
	cagney_tramp-20040309-branchpoint:1.29
	gdb_6_1-branch:1.29.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.29
	drow_intercu-20040221-branch:1.29.0.6
	drow_intercu-20040221-branchpoint:1.29
	cagney_bfdfile-20040213-branch:1.29.0.4
	cagney_bfdfile-20040213-branchpoint:1.29
	drow-cplus-merge-20040208:1.29
	carlton_dictionary-20040126-merge:1.29
	cagney_bigcore-20040122-branch:1.29.0.2
	cagney_bigcore-20040122-branchpoint:1.29
	drow-cplus-merge-20040113:1.29
	drow-cplus-merge-20031224:1.29
	drow-cplus-merge-20031220:1.29
	carlton_dictionary-20031215-merge:1.29
	drow-cplus-merge-20031214:1.29
	carlton-dictionary-20031111-merge:1.29
	gdb_6_0-2003-10-04-release:1.26.8.1
	kettenis_sparc-20030918-branch:1.28.0.4
	kettenis_sparc-20030918-branchpoint:1.28
	carlton_dictionary-20030917-merge:1.28
	ezannoni_pie-20030916-branchpoint:1.28
	ezannoni_pie-20030916-branch:1.28.0.2
	cagney_x86i386-20030821-branch:1.27.0.2
	cagney_x86i386-20030821-branchpoint:1.27
	carlton_dictionary-20030805-merge:1.26
	carlton_dictionary-20030627-merge:1.26
	gdb_6_0-branch:1.26.0.8
	gdb_6_0-2003-06-23-branchpoint:1.26
	jimb-ppc64-linux-20030613-branch:1.26.0.6
	jimb-ppc64-linux-20030613-branchpoint:1.26
	cagney_convert-20030606-branch:1.26.0.4
	cagney_convert-20030606-branchpoint:1.26
	cagney_writestrings-20030508-branch:1.25.0.6
	cagney_writestrings-20030508-branchpoint:1.25
	jimb-ppc64-linux-20030528-branch:1.26.0.2
	jimb-ppc64-linux-20030528-branchpoint:1.26
	carlton_dictionary-20030523-merge:1.26
	cagney_fileio-20030521-branch:1.25.0.4
	cagney_fileio-20030521-branchpoint:1.25
	kettenis_i386newframe-20030517-mergepoint:1.25
	jimb-ppc64-linux-20030509-branch:1.25.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.25
	kettenis_i386newframe-20030504-mergepoint:1.24
	carlton_dictionary-20030430-merge:1.24
	kettenis_i386newframe-20030419-branch:1.24.0.16
	kettenis_i386newframe-20030419-branchpoint:1.24
	carlton_dictionary-20030416-merge:1.24
	cagney_frameaddr-20030409-mergepoint:1.24
	kettenis_i386newframe-20030406-branch:1.24.0.14
	kettenis_i386newframe-20030406-branchpoint:1.24
	cagney_frameaddr-20030403-branchpoint:1.24
	cagney_frameaddr-20030403-branch:1.24.0.12
	cagney_framebase-20030330-mergepoint:1.24
	cagney_framebase-20030326-branch:1.24.0.10
	cagney_framebase-20030326-branchpoint:1.24
	cagney_lazyid-20030317-branch:1.24.0.8
	cagney_lazyid-20030317-branchpoint:1.24
	kettenis-i386newframe-20030316-mergepoint:1.24
	offbyone-20030313-branch:1.24.0.6
	offbyone-20030313-branchpoint:1.24
	kettenis-i386newframe-20030308-branch:1.24.0.4
	kettenis-i386newframe-20030308-branchpoint:1.24
	carlton_dictionary-20030305-merge:1.24
	cagney_offbyone-20030303-branch:1.24.0.2
	cagney_offbyone-20030303-branchpoint:1.24
	carlton_dictionary-20030207-merge:1.22
	interps-20030203-mergepoint:1.22
	interps-20030202-branch:1.22.0.4
	interps-20030202-branchpoint:1.22
	cagney-unwind-20030108-branch:1.22.0.2
	cagney-unwind-20030108-branchpoint:1.22
	carlton_dictionary-20021223-merge:1.22
	gdb_5_3-2002-12-12-release:1.21
	carlton_dictionary-20021115-merge:1.22
	kseitz_interps-20021105-merge:1.21
	kseitz_interps-20021103-merge:1.21
	drow-cplus-merge-20021020:1.21
	drow-cplus-merge-20021025:1.21
	carlton_dictionary-20021025-merge:1.21
	carlton_dictionary-20021011-merge:1.21
	drow-cplus-branch:1.21.0.18
	drow-cplus-branchpoint:1.21
	kseitz_interps-20020930-merge:1.21
	carlton_dictionary-20020927-merge:1.21
	carlton_dictionary-branch:1.21.0.16
	carlton_dictionary-20020920-branchpoint:1.21
	gdb_5_3-branch:1.21.0.14
	gdb_5_3-2002-09-04-branchpoint:1.21
	kseitz_interps-20020829-merge:1.21
	cagney_sysregs-20020825-branch:1.21.0.12
	cagney_sysregs-20020825-branchpoint:1.21
	readline_4_3-import-branch:1.21.0.10
	readline_4_3-import-branchpoint:1.21
	gdb_5_2_1-2002-07-23-release:1.21
	kseitz_interps-20020528-branch:1.21.0.8
	kseitz_interps-20020528-branchpoint:1.21
	cagney_regbuf-20020515-branch:1.21.0.6
	cagney_regbuf-20020515-branchpoint:1.21
	jimb-macro-020506-branch:1.21.0.4
	jimb-macro-020506-branchpoint:1.21
	gdb_5_2-2002-04-29-release:1.21
	gdb_5_2-branch:1.21.0.2
	gdb_5_2-2002-03-03-branchpoint:1.21
	gdb_5_1_1-2002-01-24-release:1.17
	gdb_5_1_0_1-2002-01-03-release:1.17
	cygnus_cvs_20020108_pre:1.19
	gdb_5_1_0_1-2002-01-03-branchpoint:1.17
	gdb_5_1_0_1-2002-01-03-branch:1.17.0.6
	gdb_5_1-2001-11-21-release:1.17
	gdb_s390-2001-09-26-branch:1.17.0.4
	gdb_s390-2001-09-26-branchpoint:1.17
	gdb_5_1-2001-07-29-branch:1.17.0.2
	gdb_5_1-2001-07-29-branchpoint:1.17
	dberlin-typesystem-branch:1.16.0.2
	dberlin-typesystem-branchpoint:1.16
	gdb-post-ptid_t-2001-05-03:1.14
	gdb-pre-ptid_t-2001-05-03:1.13
	insight-precleanup-2001-01-01:1.6
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb-post-params-removal-2000-06-04:1.4
	gdb-pre-params-removal-2000-06-04:1.4
	gdb-post-params-removal-2000-05-28:1.4
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.5
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.60
date	2007.05.07.00.21.04;	author uweigand;	state dead;
branches;
next	1.59;

1.59
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.58;

1.58
date	2007.03.30.01.18.16;	author uweigand;	state Exp;
branches;
next	1.57;

1.57
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.23.19.32.27;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2005.02.21.17.22.43;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.15.15.49.11;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.11.18.13.50;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.11.04.05.55;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2004.11.20.16.52.22;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2004.10.05.21.53.33;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2004.09.29.19.03.44;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2004.09.29.15.55.55;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2004.09.29.15.33.02;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2004.09.20.16.39.33;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2004.09.07.21.55.10;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2004.08.22.19.03.41;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.22.15.35.02;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.21.08.56.38;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.16.15.27.54;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.15.15.33.21;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.14.23.14.34;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.11.09.17.39;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2004.08.06.20.47.25;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2004.08.03.00.57.26;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.31.05.05.05;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.24.01.00.19;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.22.01.31.48;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.09.20.09.42;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2004.06.08.19.58.11;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.02.20.28.29;	author cagney;	state Exp;
branches
	1.29.6.1;
next	1.28;

1.28
date	2003.09.14.16.32.13;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2003.08.17.18.22.25;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.22.15.46.20;	author jjohnstn;	state Exp;
branches
	1.26.8.1;
next	1.25;

1.25
date	2003.05.08.20.52.47;	author cagney;	state Exp;
branches
	1.25.6.1;
next	1.24;

1.24
date	2003.02.25.19.38.21;	author jjohnstn;	state Exp;
branches
	1.24.16.1;
next	1.23;

1.23
date	2003.02.24.23.58.32;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.08.23.48.38;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.19.03.32.36;	author cagney;	state Exp;
branches
	1.21.16.1
	1.21.18.1;
next	1.20;

1.20
date	2002.01.08.00.59.29;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.19.23.59.55;	author ezannoni;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.21.14.53.46;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.26.02.23.57;	author drow;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.15.23.50.46;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.15.00.03.36;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.20.18.16.10;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.13.23.31.13;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.06.08.21.08;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.23.22.48.55;	author jtc;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.09.01.38.49;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.28.01.12.28;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.25.06.49.01;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.45;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.07.14;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.09.21.33.34;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.12.07.03.56.02;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.12.14.01.05.32;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.12.22.21.45.07;	author jsm;	state Exp;
branches;
next	;

1.21.16.1
date	2002.11.15.19.18.49;	author carlton;	state Exp;
branches;
next	1.21.16.2;

1.21.16.2
date	2003.03.06.00.56.29;	author carlton;	state Exp;
branches;
next	1.21.16.3;

1.21.16.3
date	2003.05.23.18.40.40;	author carlton;	state Exp;
branches;
next	1.21.16.4;

1.21.16.4
date	2003.09.17.21.28.22;	author carlton;	state Exp;
branches;
next	1.21.16.5;

1.21.16.5
date	2003.11.11.23.50.47;	author carlton;	state Exp;
branches;
next	;

1.21.18.1
date	2003.12.14.20.27.19;	author drow;	state Exp;
branches;
next	;

1.24.16.1
date	2003.05.18.09.44.13;	author kettenis;	state Exp;
branches;
next	;

1.25.6.1
date	2003.06.03.20.54.37;	author cagney;	state Exp;
branches;
next	;

1.26.8.1
date	2003.08.17.18.22.33;	author drow;	state Exp;
branches;
next	;

1.29.6.1
date	2004.09.16.17.01.09;	author drow;	state Exp;
branches;
next	1.29.6.2;

1.29.6.2
date	2004.09.21.20.44.16;	author drow;	state Exp;
branches;
next	;


desc
@@


1.60
log
@	* inftarg.c, infptrace.c: Remove files.
	* Makefile.in (ALLDEPFILES): Remove inftarg.c and infptrace.c
	(inftarg.o, infptrace.o): Remove rules.
	* gdbcore.h (register_addr): Remove prototype.
	* inferior.h (kill_inferior, store_inferior_registers,
	fetch_inferior_registers, attach, detach, ptrace_wait, child_resume,
	call_ptrace, pre_fork_inferior): Remove prototypes.
	* target.h (child_xfer_memory, child_pid_to_exec_file,
	child_core_file_to_sym_file, child_post_attach,
	child_post_startup_inferior, child_acknowledge_created_inferior,
	child_insert_fork_catchpoint, child_remove_fork_catchpoint,
	child_insert_vfork_catchpoint, child_remove_vfork_catchpoint,
	child_insert_exec_catchpoint, child_remove_exec_catchpoint,
	child_follow_fork, child_reported_exec_events_per_exec_call,
	child_has_exited, child_thread_alive): Remove prototypes.
@
text
@/* Low level Unix child interface to ptrace, for GDB when running under Unix.
   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998,
   1999, 2000, 2001, 2002, 2004, 2007 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "command.h"
#include "frame.h"
#include "gdbcore.h"
#include "inferior.h"
#include "regcache.h"
#include "target.h"

#include "gdb_assert.h"
#include "gdb_wait.h"
#include "gdb_string.h"

#include <sys/param.h>
#include "gdb_dirent.h"
#include <signal.h>
#include <sys/ioctl.h>

#include "gdb_ptrace.h"

#ifdef HAVE_SYS_FILE_H
#include <sys/file.h>
#endif

#if !defined (FETCH_INFERIOR_REGISTERS)
#include <sys/user.h>		/* Probably need to poke the user structure */
#endif /* !FETCH_INFERIOR_REGISTERS */

#if !defined (CHILD_XFER_MEMORY)
static void udot_info (char *, int);
#endif

void _initialize_infptrace (void);


int
call_ptrace (int request, int pid, PTRACE_TYPE_ARG3 addr, int data)
{
  return ptrace (request, pid, addr, data);
}

/* Wait for a process to finish, possibly running a target-specific
   hook before returning.  */

/* NOTE: cagney: 2004-09-29: Dependant on the native configuration,
   "hppah-nat.c" may either call this or infttrace.c's implementation
   of ptrace_wait.  See "hppahpux.mh".  */

int
ptrace_wait (ptid_t ptid, int *status)
{
  int wstate;

  wstate = wait (status);
  return wstate;
}

#ifndef DEPRECATED_KILL_INFERIOR
/* NOTE: cagney/2004-09-12: Instead of definining this macro, code
   should call inf_ptrace_target to get a basic ptrace target and then
   locally update any necessary methods.  See ppcnbsd-nat.c.  */

void
kill_inferior (void)
{
  int status;
  int pid =  PIDGET (inferior_ptid);

  if (pid == 0)
    return;

  /* This once used to call "kill" to kill the inferior just in case
     the inferior was still running.  As others have noted in the past
     (kingdon) there shouldn't be any way to get here if the inferior
     is still running -- else there's a major problem elsewere in gdb
     and it needs to be fixed.

     The kill call causes problems under hpux10, so it's been removed;
     if this causes problems we'll deal with them as they arise.  */
  ptrace (PT_KILL, pid, (PTRACE_TYPE_ARG3) 0, 0);
  wait (&status);
  target_mourn_inferior ();
}
#endif /* DEPRECATED_KILL_INFERIOR */

#ifndef DEPRECATED_CHILD_RESUME
/* NOTE: cagney/2004-09-12: Instead of definining this macro, code
   should call inf_ptrace_target to get a basic ptrace target and then
   locally update any necessary methods.  See ppcnbsd-nat.c.  */

/* Resume execution of the inferior process.
   If STEP is nonzero, single-step it.
   If SIGNAL is nonzero, give it that signal.  */

void
child_resume (ptid_t ptid, int step, enum target_signal signal)
{
  int request = PT_CONTINUE;
  int pid = PIDGET (ptid);

  if (pid == -1)
    /* Resume all threads.  */
    /* I think this only gets used in the non-threaded case, where "resume
       all threads" and "resume inferior_ptid" are the same.  */
    pid = PIDGET (inferior_ptid);

  if (step)
    {
      /* If this system does not support PT_STEP, a higher level
	 function will have called single_step() to transmute the step
	 request into a continue request (by setting breakpoints on
	 all possible successor instructions), so we don't have to
	 worry about that here.  */

      gdb_assert (!SOFTWARE_SINGLE_STEP_P ());
      request = PT_STEP;
    }

  /* An address of (PTRACE_TYPE_ARG3)1 tells ptrace to continue from
     where it was.  If GDB wanted it to start some other way, we have
     already written a new PC value to the child.  */

  errno = 0;
  ptrace (request, pid, (PTRACE_TYPE_ARG3)1, target_signal_to_host (signal));
  if (errno != 0)
    perror_with_name (("ptrace"));
}
#endif /* DEPRECATED_CHILD_RESUME */


/* Start debugging the process whose number is PID.  */

int
attach (int pid)
{
#ifdef PT_ATTACH
  errno = 0;
  ptrace (PT_ATTACH, pid, (PTRACE_TYPE_ARG3) 0, 0);
  if (errno != 0)
    perror_with_name (("ptrace"));
  attach_flag = 1;
  return pid;
#else
  error (_("This system does not support attaching to a process"));
#endif
}

/* Stop debugging the process whose number is PID and continue it with
   signal number SIGNAL.  SIGNAL = 0 means just continue it.  */

void
detach (int signal)
{
#ifdef PT_DETACH
  int pid = PIDGET (inferior_ptid);

  errno = 0;
  ptrace (PT_DETACH, pid, (PTRACE_TYPE_ARG3) 1, signal);
  if (errno != 0)
    perror_with_name (("ptrace"));
  attach_flag = 0;
#else
  error (_("This system does not support detaching from a process"));
#endif
}


#ifndef FETCH_INFERIOR_REGISTERS

/* U_REGS_OFFSET is the offset of the registers within the u area.  */
#ifndef U_REGS_OFFSET

#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif

#define U_REGS_OFFSET \
  ptrace (PT_READ_U, PIDGET (inferior_ptid), \
	  (PTRACE_TYPE_ARG3) (offsetof (struct user, u_ar0)), 0) \
    - KERNEL_U_ADDR
#endif

/* Fetch register REGNUM from the inferior.  */

static void
fetch_register (struct regcache *regcache, int regnum)
{
  CORE_ADDR addr;
  size_t size;
  PTRACE_TYPE_RET *buf;
  int tid, i;

  if (CANNOT_FETCH_REGISTER (regnum))
    {
      regcache_raw_supply (regcache, regnum, NULL);
      return;
    }

  /* GNU/Linux LWP ID's are process ID's.  */
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */

  /* This isn't really an address.  But ptrace thinks of it as one.  */
  addr = register_addr (regnum, U_REGS_OFFSET);
  size = register_size (current_gdbarch, regnum);

  gdb_assert ((size % sizeof (PTRACE_TYPE_RET)) == 0);
  buf = alloca (size);

  /* Read the register contents from the inferior a chuck at the time.  */
  for (i = 0; i < size / sizeof (PTRACE_TYPE_RET); i++)
    {
      errno = 0;
      buf[i] = ptrace (PT_READ_U, tid, (PTRACE_TYPE_ARG3) addr, 0);
      if (errno != 0)
	error (_("Couldn't read register %s (#%d): %s."), REGISTER_NAME (regnum),
	       regnum, safe_strerror (errno));

      addr += sizeof (PTRACE_TYPE_RET);
    }
  regcache_raw_supply (regcache, regnum, buf);
}

/* Fetch register REGNUM from the inferior.  If REGNUM is -1, do this
   for all registers.  */

void
fetch_inferior_registers (struct regcache *regcache, int regnum)
{
  if (regnum == -1)
    for (regnum = 0; regnum < NUM_REGS; regnum++)
      fetch_register (regcache, regnum);
  else
    fetch_register (regcache, regnum);
}

/* Store register REGNUM into the inferior.  */

static void
store_register (const struct regcache *regcache, int regnum)
{
  CORE_ADDR addr;
  size_t size;
  PTRACE_TYPE_RET *buf;
  int tid, i;

  if (CANNOT_STORE_REGISTER (regnum))
    return;

  /* GNU/Linux LWP ID's are process ID's.  */
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */

  /* This isn't really an address.  But ptrace thinks of it as one.  */
  addr = register_addr (regnum, U_REGS_OFFSET);
  size = register_size (current_gdbarch, regnum);

  gdb_assert ((size % sizeof (PTRACE_TYPE_RET)) == 0);
  buf = alloca (size);

  /* Write the register contents into the inferior a chunk at the time.  */
  regcache_raw_collect (regcache, regnum, buf);
  for (i = 0; i < size / sizeof (PTRACE_TYPE_RET); i++)
    {
      errno = 0;
      ptrace (PT_WRITE_U, tid, (PTRACE_TYPE_ARG3) addr, buf[i]);
      if (errno != 0)
	error (_("Couldn't write register %s (#%d): %s."),
	       REGISTER_NAME (regnum), regnum, safe_strerror (errno));

      addr += sizeof (PTRACE_TYPE_RET);
    }
}

/* Store register REGNUM back into the inferior.  If REGNUM is -1, do
   this for all registers (including the floating point registers).  */

void
store_inferior_registers (struct regcache *regcache, int regnum)
{
  if (regnum == -1)
    for (regnum = 0; regnum < NUM_REGS; regnum++)
      store_register (regcache, regnum);
  else
    store_register (regcache, regnum);
}

#endif /* not FETCH_INFERIOR_REGISTERS.  */


/* Set an upper limit on alloca.  */
#ifndef GDB_MAX_ALLOCA
#define GDB_MAX_ALLOCA 0x1000
#endif

#if !defined (CHILD_XFER_MEMORY)
/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory
   in the NEW_SUN_PTRACE case.  It ought to be straightforward.  But
   it appears that writing did not write the data that I specified.  I
   cannot understand where it got the data that it actually did write.  */

/* Copy LEN bytes to or from inferior's memory starting at MEMADDR to
   debugger memory starting at MYADDR.  Copy to inferior if WRITE is
   nonzero.  TARGET is ignored.

   Returns the length copied, which is either the LEN argument or
   zero.  This xfer function does not do partial moves, since
   deprecated_child_ops doesn't allow memory operations to cross below
   us in the target stack anyway.  */

int
child_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len, int write,
		   struct mem_attrib *attrib, struct target_ops *target)
{
  int i;
  /* Round starting address down to longword boundary.  */
  CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_TYPE_RET);
  /* Round ending address up; get number of longwords that makes.  */
  int count = ((((memaddr + len) - addr) + sizeof (PTRACE_TYPE_RET) - 1)
	       / sizeof (PTRACE_TYPE_RET));
  int alloc = count * sizeof (PTRACE_TYPE_RET);
  PTRACE_TYPE_RET *buffer;
  struct cleanup *old_chain = NULL;

#ifdef PT_IO
  /* OpenBSD 3.1, NetBSD 1.6 and FreeBSD 5.0 have a new PT_IO request
     that promises to be much more efficient in reading and writing
     data in the traced process's address space.  */

  {
    struct ptrace_io_desc piod;

    /* NOTE: We assume that there are no distinct address spaces for
       instruction and data.  */
    piod.piod_op = write ? PIOD_WRITE_D : PIOD_READ_D;
    piod.piod_offs = (void *) memaddr;
    piod.piod_addr = myaddr;
    piod.piod_len = len;

    if (ptrace (PT_IO, PIDGET (inferior_ptid), (caddr_t) &piod, 0) == -1)
      {
	/* If the PT_IO request is somehow not supported, fallback on
           using PT_WRITE_D/PT_READ_D.  Otherwise we will return zero
           to indicate failure.  */
	if (errno != EINVAL)
	  return 0;
      }
    else
      {
	/* Return the actual number of bytes read or written.  */
	return piod.piod_len;
      }
  }
#endif

  /* Allocate buffer of that many longwords.  */
  if (len < GDB_MAX_ALLOCA)
    {
      buffer = (PTRACE_TYPE_RET *) alloca (alloc);
    }
  else
    {
      buffer = (PTRACE_TYPE_RET *) xmalloc (alloc);
      old_chain = make_cleanup (xfree, buffer);
    }

  if (write)
    {
      /* Fill start and end extra bytes of buffer with existing memory
         data.  */
      if (addr != memaddr || len < (int) sizeof (PTRACE_TYPE_RET))
	{
	  /* Need part of initial word -- fetch it.  */
	  buffer[0] = ptrace (PT_READ_I, PIDGET (inferior_ptid), 
			      (PTRACE_TYPE_ARG3) addr, 0);
	}

      if (count > 1)		/* FIXME, avoid if even boundary.  */
	{
	  buffer[count - 1] =
	    ptrace (PT_READ_I, PIDGET (inferior_ptid),
		    ((PTRACE_TYPE_ARG3)
		     (addr + (count - 1) * sizeof (PTRACE_TYPE_RET))), 0);
	}

      /* Copy data to be written over corresponding part of buffer.  */
      memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_TYPE_RET) - 1)),
	      myaddr, len);

      /* Write the entire buffer.  */
      for (i = 0; i < count; i++, addr += sizeof (PTRACE_TYPE_RET))
	{
	  errno = 0;
	  ptrace (PT_WRITE_D, PIDGET (inferior_ptid), 
		  (PTRACE_TYPE_ARG3) addr, buffer[i]);
	  if (errno)
	    {
	      /* Using the appropriate one (I or D) is necessary for
	         Gould NP1, at least.  */
	      errno = 0;
	      ptrace (PT_WRITE_I, PIDGET (inferior_ptid), 
		      (PTRACE_TYPE_ARG3) addr, buffer[i]);
	    }
	  if (errno)
	    return 0;
	}
    }
  else
    {
      /* Read all the longwords.  */
      for (i = 0; i < count; i++, addr += sizeof (PTRACE_TYPE_RET))
	{
	  errno = 0;
	  buffer[i] = ptrace (PT_READ_I, PIDGET (inferior_ptid),
			      (PTRACE_TYPE_ARG3) addr, 0);
	  if (errno)
	    return 0;
	  QUIT;
	}

      /* Copy appropriate bytes out of the buffer.  */
      memcpy (myaddr,
	      (char *) buffer + (memaddr & (sizeof (PTRACE_TYPE_RET) - 1)),
	      len);
    }

  if (old_chain != NULL)
    do_cleanups (old_chain);
  return len;
}


static void
udot_info (char *dummy1, int dummy2)
{
#if defined (KERNEL_U_SIZE)
  long udot_off;			/* Offset into user struct */
  int udot_val;			/* Value from user struct at udot_off */
  char mess[128];		/* For messages */
#endif

  if (!target_has_execution)
    {
      error (_("The program is not being run."));
    }

#if !defined (KERNEL_U_SIZE)

  /* Adding support for this command is easy.  Typically you just add a
     routine, called "kernel_u_size" that returns the size of the user
     struct, to the appropriate *-nat.c file and then add to the native
     config file "#define KERNEL_U_SIZE kernel_u_size()" */
  error (_("Don't know how large ``struct user'' is in this version of gdb."));

#else

  for (udot_off = 0; udot_off < KERNEL_U_SIZE; udot_off += sizeof (udot_val))
    {
      if ((udot_off % 24) == 0)
	{
	  if (udot_off > 0)
	    {
	      printf_filtered ("\n");
	    }
	  printf_filtered ("%s:", paddr (udot_off));
	}
      udot_val = ptrace (PT_READ_U, PIDGET (inferior_ptid), (PTRACE_TYPE_ARG3) udot_off, 0);
      if (errno != 0)
	{
	  sprintf (mess, "\nreading user struct at offset 0x%s",
		   paddr_nz (udot_off));
	  perror_with_name (mess);
	}
      /* Avoid using nonportable (?) "*" in print specs */
      printf_filtered (sizeof (int) == 4 ? " 0x%08x" : " 0x%16x", udot_val);
    }
  printf_filtered ("\n");

#endif
}
#endif /* !defined (CHILD_XFER_MEMORY).  */


void
_initialize_infptrace (void)
{
#if !defined (CHILD_XFER_MEMORY)
  add_info ("udot", udot_info,
	    _("Print contents of kernel ``struct user'' for current child."));
#endif
}
@


1.59
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@@


1.58
log
@gdb/ChangeLog:

	* config/alpha/nm-osf.h (PTRACE_XFER_TYPE): Remove.
	* config/mips/nm-linux.h (PTRACE_ARG3_TYPE, PTRACE_XFER_TYPE): Remove.
	* config/sparc/nm-linux.h (PTRACE_ARG3_TYPE, PTRACE_XFER_TYPE): Remove.
	* config/powerpc/nm-ppc64-linux.h: Remove file.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Set to nm-linux.h.
	* inferior.h (PTRACE_ARG3_TYPE): Do not define.
	(call_ptrace): Change type of third argument to PTRACE_TYPE_ARG3.
	* infptrace.c (call_ptrace): Likewise.
	* m68klinux-nat.c (PTRACE_XFER_TYPE): Do not define.
	(fetch_register): Replace PTRACE_ARG3_TYPE by PTRACE_TYPE_ARG3
	and PTRACE_XFER_TYPE by PTRACE_TYPE_RET.
	(store_register): Likewise.

gdb/doc/ChangeLog:

	* gdbint.texi (Native Conditionals): Remove PTRACE_ARG3_TYPE.
@
text
@d206 1
a206 1
fetch_register (int regnum)
d215 1
a215 1
      regcache_raw_supply (current_regcache, regnum, NULL);
d242 1
a242 1
  regcache_raw_supply (current_regcache, regnum, buf);
d249 1
a249 1
fetch_inferior_registers (int regnum)
d253 1
a253 1
      fetch_register (regnum);
d255 1
a255 1
    fetch_register (regnum);
d261 1
a261 1
store_register (int regnum)
d284 1
a284 1
  regcache_raw_collect (current_regcache, regnum, buf);
d301 1
a301 1
store_inferior_registers (int regnum)
d305 1
a305 1
      store_register (regnum);
d307 1
a307 1
    store_register (regnum);
@


1.57
log
@Copyright updates for 2007.
@
text
@d57 1
a57 1
call_ptrace (int request, int pid, PTRACE_ARG3_TYPE addr, int data)
@


1.56
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d2 2
a3 3
   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1998, 1999, 2000, 2001, 2002, 2004
   Free Software Foundation, Inc.
@


1.55
log
@2005-05-23  Andrew Cagney  <cagney@@gnu.org>

	* target.h (child_xfer_memory): Use gdb_byte for byte buffer
	parameters.
	* inftarg.c (child_xfer_partial): Update.
	* wince.c (child_xfer_memory): Update.
	* win32-nat.c (child_xfer_memory): Update.
	* rs6000-nat.c (child_xfer_memory): Update.
	* infptrace.c (child_xfer_memory): Update.
	* dcache.c (struct dcache_block): Use gdb_byte for the byte
	buffers.
	(dcache_read_line, dcache_xfer_memory, dcache_poke_byte)
	(dcache_peek_byte, dcache_write_line): Ditto.
@
text
@d2 1
a2 1
   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.54
log
@2005-02-21  Thiemo Seufer  <seufer@@csv.ica.uni-stuttgart.de>

	* infptrace.c (store_register): Fix typo.
@
text
@d335 1
a335 1
child_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
@


1.53
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d291 2
a292 2
	error (_("Couldn't write register %s (#%d): %s.")e, REGISTER_NAME (regnum),
	       regnum, safe_strerror (errno));
@


1.52
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d512 1
a512 1
	    "Print contents of kernel ``struct user'' for current child.");
@


1.51
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d147 1
a147 1
    perror_with_name ("ptrace");
d161 1
a161 1
    perror_with_name ("ptrace");
d181 1
a181 1
    perror_with_name ("ptrace");
@


1.50
log
@* gdb_ptrace.h [PTRACE_TYPE_ARG5] (ptrace): New macro.
* infptrace.c (call_ptrace): Simply call ptrace with four
arguments.
@
text
@d165 1
a165 1
  error ("This system does not support attaching to a process");
d184 1
a184 1
  error ("This system does not support detaching from a process");
d238 1
a238 1
	error ("Couldn't read register %s (#%d): %s.", REGISTER_NAME (regnum),
d291 1
a291 1
	error ("Couldn't write register %s (#%d): %s.", REGISTER_NAME (regnum),
d467 1
a467 1
      error ("The program is not being run.");
d476 1
a476 1
  error ("Don't know how large ``struct user'' is in this version of gdb.");
@


1.49
log
@2004-10-05  Andrew Cagney  <cagney@@gnu.org>

	* target.h (deprecated_child_ops): Rename child_ops.
	* wince.c: Update copyright.  Rename child_ops.
	* win32-nat.c: Rename child_ops.
	* target.c: Rename child_ops.
	* rs6000-nat.c: Rename child_ops.
	* linux-nat.c: Rename child_ops.
	* infttrace.c: Rename child_ops.
	* inftarg.c: Rename child_ops.
	* infptrace.c: Rename child_ops.
	* hppah-nat.c: Update copyright.  Rename child_ops.
	* hpux-thread.c: Update copyright.  Rename child_ops.
@
text
@a56 3
/* This function simply calls ptrace with the given arguments.  
   It exists so that all calls to ptrace are isolated in this 
   machine-dependent file. */
d60 1
a60 66
  int pt_status = 0;

#if 0
  int saved_errno;

  printf ("call_ptrace(request=%d, pid=%d, addr=0x%x, data=0x%x)",
	  request, pid, addr, data);
#endif
#if defined(PT_SETTRC)
  /* If the parent can be told to attach to us, try to do it.  */
  if (request == PT_SETTRC)
    {
      errno = 0;
#ifndef PTRACE_TYPE_ARG5
      pt_status = ptrace (PT_SETTRC, pid, addr, data);
#else
      /* Deal with HPUX 8.0 braindamage.  We never use the
         calls which require the fifth argument.  */
      pt_status = ptrace (PT_SETTRC, pid, addr, data, 0);
#endif
      if (errno)
	perror_with_name ("ptrace");
#if 0
      printf (" = %d\n", pt_status);
#endif
      if (pt_status < 0)
	return pt_status;
      else
	return parent_attach_all (pid, addr, data);
    }
#endif

#if defined(PT_CONTIN1)
  /* On HPUX, PT_CONTIN1 is a form of continue that preserves pending
     signals.  If it's available, use it.  */
  if (request == PT_CONTINUE)
    request = PT_CONTIN1;
#endif

#if defined(PT_SINGLE1)
  /* On HPUX, PT_SINGLE1 is a form of step that preserves pending
     signals.  If it's available, use it.  */
  if (request == PT_STEP)
    request = PT_SINGLE1;
#endif

#if 0
  saved_errno = errno;
  errno = 0;
#endif
#ifndef PTRACE_TYPE_ARG5
  pt_status = ptrace (request, pid, addr, data);
#else
  /* Deal with HPUX 8.0 braindamage.  We never use the
     calls which require the fifth argument.  */
  pt_status = ptrace (request, pid, addr, data, 0);
#endif

#if 0
  if (errno)
    printf (" [errno = %d]", errno);

  errno = saved_errno;
  printf (" = 0x%x\n", pt_status);
#endif
  return pt_status;
a62 7

#if defined (DEBUG_PTRACE) || defined (PTRACE_TYPE_ARG5)
/* For the rest of the file, use an extra level of indirection */
/* This lets us breakpoint usefully on call_ptrace. */
#define ptrace call_ptrace
#endif

@


1.48
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* infptrace.c (kill_inferior): Fix typo, in previous inline.  Pass
	the address of status.
@
text
@d406 2
a407 2
   child_ops doesn't allow memory operations to cross below us in the
   target stack anyway.  */
@


1.47
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* infptrace.c (ptrace_wait): Mention problem with HPUX.
	(kill_inferior): Inline ptrace_wait call.
	* linux-nat.c (kill_inferior): Inline ptrace_wait call.
	* inftarg.c (child_wait): Inline ptrace_wait call.
@
text
@d177 1
a177 1
  wait (status);
@


1.46
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Delete field to_post_wait.
	(target_post_wait): Delete macro.
	(child_post_wait): Delete declaration.
	* target.c (update_current_target, update_current_target)
	(debug_to_post_wait, setup_target_debug): Delete functions and
	references.
	* infttrace.c (ptrace_wait): Delete call to target_post_wait.
	* inftarg.c (child_post_wait): Delete.
	(init_child_ops): Do not set to_post_wait.
	* infptrace.c (ptrace_wait): Delete call to target_post_wait.
	* inf-ptrace.c (inf_ptrace_wait): Delete call to target_post_wait.
	* inf-child.c (inf_child_post_wait): Delete.
	(inf_child_target): Do not set to_post_wait.
	* inf-ptrace.c (inf_ptrace_post_wait): Delete.
	(inf_ptrace_target): Do not set to_post_wait.
@
text
@d141 4
d177 1
a177 1
  ptrace_wait (null_ptid, &status);
@


1.45
log
@2004-09-20  Andrew Cagney  <cagney@@gnu.org>

	* config/nm-lynx.h (DEPRECATED_CHILD_RESUME): Deprecate
	CHILD_RESUME.
	* config/i386/nm-linux.h (DEPRECATED_CHILD_RESUME): Ditto.
	* config/nm-linux.h (DEPRECATED_KILL_INFERIOR): Deprecate
	KILL_INFERIOR.
	* infptrace.c: Update.
@
text
@a146 1
  target_post_wait (pid_to_ptid (wstate), *status);
@


1.44
log
@2004-09-07  Andrew Cagney  <cagney@@gnu.org>

	* vx-share/wait.h: Delete #ifdef USG.
	* utils.c (request_quit): Ditto.
	* tui/tui.c (tui_reset): Ditto.
	* remote.c: Ditto.
	* remote-sds.c: Ditto.
	* remote-rdi.c: Ditto.
	* mdebugread.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* infttrace.c: Ditto.
	* infptrace.c: Ditto.
	* i386v-nat.c: Ditto.
	* exec.c: Ditto.
	* dbxread.c: Ditto.
	* core-aout.c: Ditto.
@
text
@d151 5
a155 1
#ifndef KILL_INFERIOR
d177 1
a177 1
#endif /* KILL_INFERIOR */
d179 4
a182 1
#ifndef CHILD_RESUME
d221 1
a221 1
#endif /* CHILD_RESUME */
@


1.43
log
@* infptrace.c: Remove #ifdef'ed out inclusion of gdb_stat.h.
Reorder includes.
(fetch_register, store_register): Remove prototypes.
(child_resume): Reorganize code and comments such that it is
grouped a bit more logically.
(attach): Explicitly compare errno against 0.
(detach): Likewise.  Use perror_with_name instead of
print_sys_errmsg.
* Makefile.in (infptrace.o): Update dependencies.
@
text
@a34 4
#ifdef USG
#include <sys/types.h>
#endif

@


1.42
log
@* infptrace.c: Include "gdb_assert.h".
(PTRACE_XFER_TYPE): Remove define.
(offsetof): Only define if U_REGS_OFFSET isn't defined.
(fetch_register, store_register): Rewrite to use PTRACE_TYPE_RET.
Tweak comment.
(fetch_inferior_registers, store_inferior_registers): Remove
redundant culry braces.  Tweak comment.  s/regno/regnum.
* Makefile.in (infptrace.o): Update dependencies.
@
text
@d24 1
d26 1
d28 1
a29 2
#include "gdb_string.h"
#include "regcache.h"
d31 1
d33 1
a33 2

#include "command.h"
a45 1
#include "gdbcore.h"
a48 8
#if 0
/* Don't think this is used anymore.  On the sequent (not sure whether it's
   dynix or ptx or both), it is included unconditionally by sys/user.h and
   not protected against multiple inclusion.  */
#include "gdb_stat.h"
#endif

#include "gdb_assert.h"
a57 5
#if !defined (FETCH_INFERIOR_REGISTERS)
static void fetch_register (int);
static void store_register (int);
#endif

d188 1
a190 2
  errno = 0;

a196 9
  /* An address of (PTRACE_TYPE_ARG3)1 tells ptrace to continue from where
     it was.  (If GDB wanted it to start some other way, we have already
     written a new PC value to the child.)

     If this system does not support PT_STEP, a higher level function will
     have called single_step() to transmute the step request into a
     continue request (by setting breakpoints on all possible successor
     instructions), so we don't have to worry about that here.  */

d199 8
a206 5
      if (SOFTWARE_SINGLE_STEP_P ())
	internal_error (__FILE__, __LINE__, "failed internal consistency check");		/* Make sure this doesn't happen. */
      else
	ptrace (PT_STEP, pid, (PTRACE_TYPE_ARG3) 1,
		target_signal_to_host (signal));
a207 3
  else
    ptrace (PT_CONTINUE, pid, (PTRACE_TYPE_ARG3) 1,
	    target_signal_to_host (signal));
d209 8
a216 4
  if (errno)
    {
      perror_with_name ("ptrace");
    }
d220 1
d222 1
d229 1
a229 1
  if (errno)
d238 2
a239 3
/* Stop debugging the process whose number is PID
   and continue it with signal number SIGNAL.
   SIGNAL = 0 means just continue it.  */
d245 2
d248 3
a250 4
  ptrace (PT_DETACH, PIDGET (inferior_ptid), (PTRACE_TYPE_ARG3) 1,
          signal);
  if (errno)
    print_sys_errmsg ("ptrace", errno);
@


1.41
log
@* gdb_ptrace.h: New file.
* infptrace.c: Include "gdb_ptrace.h" instead of <ptrace.h> or
<sys/ptrace.h>.
(PT_READ_I, PT_READ_D, PT_READ_U, PT_WRITE_I, PT_WRITE_D)
(PT_WRITE_U, PT_CONTINUE, PT_STEP, PT_KILL): Remove defines.
(attach): Don't define PT_ATTACH.
(detach): Don't define PT_DETACH.
* Makefile.in (gdb_ptrace_h): New variable.
(infptrace.o): Update dependencies.
@
text
@d56 2
a273 4
/* Default the type of the ptrace transfer to int.  */
#ifndef PTRACE_XFER_TYPE
#define PTRACE_XFER_TYPE int
#endif
d275 4
a278 1
#if !defined (FETCH_INFERIOR_REGISTERS)
d280 1
a280 1
#if !defined (offsetof)
a283 2
/* U_REGS_OFFSET is the offset of the registers within the u area.  */
#if !defined (U_REGS_OFFSET)
d290 1
a290 1
/* Fetch one register.  */
d293 1
a293 1
fetch_register (int regno)
d295 4
a298 7
  /* This isn't really an address.  But ptrace thinks of it as one.  */
  CORE_ADDR regaddr;
  char mess[128];		/* For messages */
  int i;
  unsigned int offset;		/* Offset of registers within the u area.  */
  char buf[MAX_REGISTER_SIZE];
  int tid;
d300 1
a300 1
  if (CANNOT_FETCH_REGISTER (regno))
d302 1
a302 1
      regcache_raw_supply (current_regcache, regno, NULL);
d306 8
a313 3
  /* Overload thread id onto process id */
  if ((tid = TIDGET (inferior_ptid)) == 0)
    tid = PIDGET (inferior_ptid);	/* no thread id, just use process id */
d315 2
a316 1
  offset = U_REGS_OFFSET;
d318 2
a319 2
  regaddr = register_addr (regno, offset);
  for (i = 0; i < register_size (current_gdbarch, regno); i += sizeof (PTRACE_XFER_TYPE))
d322 1
a322 3
      *(PTRACE_XFER_TYPE *) & buf[i] = ptrace (PT_READ_U, tid,
					       (PTRACE_TYPE_ARG3) regaddr, 0);
      regaddr += sizeof (PTRACE_XFER_TYPE);
d324 4
a327 5
	{
	  sprintf (mess, "reading register %s (#%d)", 
		   REGISTER_NAME (regno), regno);
	  perror_with_name (mess);
	}
d329 1
a329 1
  regcache_raw_supply (current_regcache, regno, buf);
d332 2
a333 4

/* Fetch register values from the inferior.
   If REGNO is negative, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time). */
d336 1
a336 1
fetch_inferior_registers (int regno)
d338 3
a340 4
  if (regno >= 0)
    {
      fetch_register (regno);
    }
d342 1
a342 6
    {
      for (regno = 0; regno < NUM_REGS; regno++)
	{
	  fetch_register (regno);
	}
    }
d345 1
a345 1
/* Store one register. */
d348 1
a348 1
store_register (int regno)
d350 4
a353 7
  /* This isn't really an address.  But ptrace thinks of it as one.  */
  CORE_ADDR regaddr;
  char mess[128];		/* For messages */
  int i;
  unsigned int offset;		/* Offset of registers within the u area.  */
  int tid;
  char buf[MAX_REGISTER_SIZE];
d355 2
a356 4
  if (CANNOT_STORE_REGISTER (regno))
    {
      return;
    }
d358 4
a361 3
  /* Overload thread id onto process id */
  if ((tid = TIDGET (inferior_ptid)) == 0)
    tid = PIDGET (inferior_ptid);	/* no thread id, just use process id */
d363 3
a365 1
  offset = U_REGS_OFFSET;
d367 2
a368 1
  regaddr = register_addr (regno, offset);
d370 3
a372 5
  /* Put the contents of regno into a local buffer */
  regcache_raw_collect (current_regcache, regno, buf);

  /* Store the local buffer into the inferior a chunk at the time. */
  for (i = 0; i < register_size (current_gdbarch, regno); i += sizeof (PTRACE_XFER_TYPE))
d375 1
a375 3
      ptrace (PT_WRITE_U, tid, (PTRACE_TYPE_ARG3) regaddr,
	      *(PTRACE_XFER_TYPE *) (buf + i));
      regaddr += sizeof (PTRACE_XFER_TYPE);
d377 4
a380 5
	{
	  sprintf (mess, "writing register %s (#%d)", 
		   REGISTER_NAME (regno), regno);
	  perror_with_name (mess);
	}
d384 2
a385 3
/* Store our register values back into the inferior.
   If REGNO is negative, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */
d388 1
a388 1
store_inferior_registers (int regno)
d390 3
a392 4
  if (regno >= 0)
    {
      store_register (regno);
    }
d394 1
a394 6
    {
      for (regno = 0; regno < NUM_REGS; regno++)
	{
	  store_register (regno);
	}
    }
d396 2
a397 1
#endif /* !defined (FETCH_INFERIOR_REGISTERS).  */
@


1.40
log
@* inferior.h (PTRACE_ARG3_TYPE): Define as PTRACE_TYPE_ARG3
instead of `int' if not already defined.
(call_ptrace): Revert change that replaced PTRACE_ARG3_TYPE with
PTRACE_TYPE_ARG3.
* infptrace.c (call_ptrace): Revert change that replaced
PTRACE_ARG3_TYPE with PTRACE_TYPE_ARG3.
@
text
@d43 1
a43 35
#ifdef HAVE_PTRACE_H
#include <ptrace.h>
#else
#ifdef HAVE_SYS_PTRACE_H
#include <sys/ptrace.h>
#endif
#endif

#if !defined (PT_READ_I)
#define PT_READ_I	1	/* Read word from text space */
#endif
#if !defined (PT_READ_D)
#define	PT_READ_D	2	/* Read word from data space */
#endif
#if !defined (PT_READ_U)
#define PT_READ_U	3	/* Read word from kernel user struct */
#endif
#if !defined (PT_WRITE_I)
#define PT_WRITE_I	4	/* Write word to text space */
#endif
#if !defined (PT_WRITE_D)
#define PT_WRITE_D	5	/* Write word to data space */
#endif
#if !defined (PT_WRITE_U)
#define PT_WRITE_U	6	/* Write word to kernel user struct */
#endif
#if !defined (PT_CONTINUE)
#define PT_CONTINUE	7	/* Continue after signal */
#endif
#if !defined (PT_STEP)
#define PT_STEP		9	/* Set flag for single stepping */
#endif
#if !defined (PT_KILL)
#define PT_KILL		8	/* Send child a SIGKILL signal */
#endif
d241 1
a242 6
#ifndef PT_ATTACH
#ifdef PTRACE_ATTACH
#define PT_ATTACH PTRACE_ATTACH
#endif
#endif
#ifdef PT_ATTACH
d260 1
a261 6
#ifndef PT_DETACH
#ifdef PTRACE_DETACH
#define PT_DETACH PTRACE_DETACH
#endif
#endif
#ifdef PT_DETACH
@


1.39
log
@* infptrace.c (child_xfer_memory): Replace PTRACE_XFER_TYPE with
PTRACE_TYPE_RET.
@
text
@d110 1
a110 1
call_ptrace (int request, int pid, PTRACE_TYPE_ARG3 addr, int data)
@


1.38
log
@* inferior.h (call_ptrace): Replace PTRACE_ARG3_TYPE with
PTRACE_TYPE_ARG3.
* infptrace.c (call_ptrace, child_resume, attach, detach)
(U_REGS_OFFSET, fetch_register, store_register, child_xfer_memory)
(udot_info): Replace PTRACE_ARG3_TYPE with PTRACE_TYPE_ARG3.
* inftarg.c (ptrace_me): Replace PTRACE_ARG3_TYPE with
PTRACE_TYPE_ARG3.
@
text
@d491 1
a491 1
  CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_XFER_TYPE);
d493 4
a496 4
  int count = ((((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
	       / sizeof (PTRACE_XFER_TYPE));
  int alloc = count * sizeof (PTRACE_XFER_TYPE);
  PTRACE_XFER_TYPE *buffer;
d533 1
a533 1
      buffer = (PTRACE_XFER_TYPE *) alloca (alloc);
d537 1
a537 1
      buffer = (PTRACE_XFER_TYPE *) xmalloc (alloc);
d545 1
a545 1
      if (addr != memaddr || len < (int) sizeof (PTRACE_XFER_TYPE))
d557 1
a557 1
		     (addr + (count - 1) * sizeof (PTRACE_XFER_TYPE))), 0);
d561 1
a561 1
      memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
d565 1
a565 1
      for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
d585 1
a585 1
      for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
d597 1
a597 1
	      (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
@


1.37
log
@* infptrace.c (call_ptrace): Select code based on PTRACE_TYPE_ARG5
instead of FIVE_ARG_PTRACE.
@
text
@d110 1
a110 1
call_ptrace (int request, int pid, PTRACE_ARG3_TYPE addr, int data)
d218 1
a218 1
  ptrace (PT_KILL, pid, (PTRACE_ARG3_TYPE) 0, 0);
d243 1
a243 1
  /* An address of (PTRACE_ARG3_TYPE)1 tells ptrace to continue from where
d257 1
a257 1
	ptrace (PT_STEP, pid, (PTRACE_ARG3_TYPE) 1,
d261 1
a261 1
    ptrace (PT_CONTINUE, pid, (PTRACE_ARG3_TYPE) 1,
d282 1
a282 1
  ptrace (PT_ATTACH, pid, (PTRACE_ARG3_TYPE) 0, 0);
d306 1
a306 1
  ptrace (PT_DETACH, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) 1,
d331 1
a331 1
	  (PTRACE_ARG3_TYPE) (offsetof (struct user, u_ar0)), 0) \
d365 1
a365 1
					       (PTRACE_ARG3_TYPE) regaddr, 0);
d431 1
a431 1
      ptrace (PT_WRITE_U, tid, (PTRACE_ARG3_TYPE) regaddr,
d549 1
a549 1
			      (PTRACE_ARG3_TYPE) addr, 0);
d556 1
a556 1
		    ((PTRACE_ARG3_TYPE)
d569 1
a569 1
		  (PTRACE_ARG3_TYPE) addr, buffer[i]);
d576 1
a576 1
		      (PTRACE_ARG3_TYPE) addr, buffer[i]);
d589 1
a589 1
			      (PTRACE_ARG3_TYPE) addr, 0);
d641 1
a641 1
      udot_val = ptrace (PT_READ_U, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) udot_off, 0);
@


1.36
log
@* infptrace.c: Include <sys/file.h> if HAVE_SYS_FILE_H instead of
!NO_SYS_FILE.
[KERNEL_U_ADDR_BSD]: Don't include <a.out.h>.
[KERNEL_U_ADDR_BSD] (kernel_u_addr): Remove variable.
(_initialize_kernel_u_addr): Remove prototype and function.
* infttrace.c: Include <sys/file.h> if HAVE_SYS_FILE_H instead of
!NO_SYS_FILE.
* xcoffread.c: Likewise.
@
text
@d125 1
a125 1
#if !defined (FIVE_ARG_PTRACE)
d162 1
a162 1
#if !defined (FIVE_ARG_PTRACE)
d181 1
a181 1
#if defined (DEBUG_PTRACE) || defined (FIVE_ARG_PTRACE)
@


1.35
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d80 1
a80 1
#ifndef	NO_SYS_FILE
a91 3
#if defined (KERNEL_U_ADDR_BSD)
#include <a.out.h>		/* For struct nlist */
#endif /* KERNEL_U_ADDR_BSD.  */
a102 1
void _initialize_kernel_u_addr (void);
a320 23
/* KERNEL_U_ADDR is the amount to subtract from u.u_ar0
   to get the offset in the core file of the register values.  */
#if defined (KERNEL_U_ADDR_BSD) && !defined (FETCH_INFERIOR_REGISTERS)
/* Get kernel_u_addr using BSD-style nlist().  */
CORE_ADDR kernel_u_addr;
#endif /* KERNEL_U_ADDR_BSD.  */

void
_initialize_kernel_u_addr (void)
{
#if defined (KERNEL_U_ADDR_BSD) && !defined (FETCH_INFERIOR_REGISTERS)
  struct nlist names[2];

  names[0].n_un.n_name = "_u";
  names[1].n_un.n_name = NULL;
  if (nlist ("/vmunix", names) == 0)
    kernel_u_addr = names[0].n_value;
  else
    internal_error (__FILE__, __LINE__,
		    "Unable to get kernel u area address.");
#endif /* KERNEL_U_ADDR_BSD.  */
}

@


1.34
log
@* infptrace.c: Update copyright year.
(fetch_register): Pass NULL in regcache_raw_supply call instead of
explicitly setting the buffer to all zeroes.
@
text
@d388 1
a388 1
  for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d455 1
a455 1
  for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
@


1.33
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_collect instead of regcache_collect.
	* regcache.h (regcache_collect): Delete declaration.
	* regcache.c (regcache_colect): Delete function.
	* win32-nat.c (do_child_store_inferior_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_fill_reg): Update.
	* rs6000-nat.c (store_register): Update.
	* remote.c (store_register_using_P, remote_store_registers): Update.
	* ppcnbsd-tdep.c (ppcnbsd_fill_reg): Update.
	* ppc-linux-nat.c (store_altivec_register, store_spe_register)
	(fill_vrregset, store_spe_registers, fill_gregset)
	(fill_gregset): Update.
	* nto-procfs.c (procfs_store_registers): Update.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg): Update.
	* mips-linux-tdep.c (fill_gregset, mips64_fill_gregset): Update.
	* m68klinux-nat.c (store_register, fill_gregset): Update.
	* m68k-tdep.c (fill_gregset): Update.
	* infptrace.c (store_register): Update.
	* i386-nto-tdep.c (i386nto_regset_fill): Update.
	* i386-linux-nat.c (store_register, fill_gregset): Update.
	* hppa-linux-nat.c (fill_gregset): Update.
	* go32-nat.c (store_register): Update.
	* armnbsd-nat.c (store_register, store_regs, store_fp_register)
	(store_fp_regs): Update.
	* arm-linux-nat.c (store_nwfpe_single, store_nwfpe_double)
	(store_nwfpe_extended, store_fpregister, store_fpregs)
	(store_register, store_regs, fill_gregset, fill_fpregset): Update.
	* alpha-tdep.c (alpha_fill_int_regs, alpha_fill_fp_regs): Update.
	* aix-thread.c (fill_gprs64, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Update.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002
d377 1
a377 2
      memset (buf, '\0', DEPRECATED_REGISTER_RAW_SIZE (regno));	/* Supply zeroes */
      regcache_raw_supply (current_regcache, regno, buf);
@


1.32
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d453 1
a453 1
  regcache_collect (regno, buf);
@


1.31
log
@2004-06-09  Andrew Cagney  <cagney@@gnu.org>

	* infptrace.c (child_xfer_memory) [CLEAR_INSN_CACHE]: Delete
	#ifdef CLEAR_INSN_CACHE code.
	* target.c (generic_mourn_inferior) [CLEAR_DEFERRED_STORES]:
	Delete #ifdef CLEAR_DEFERRED_STORES code.
@
text
@d378 1
a378 1
      supply_register (regno, buf);
d402 1
a402 1
  supply_register (regno, buf);
@


1.30
log
@2004-06-08  Andrew Cagney  <cagney@@gnu.org>

	* infptrace.c [ATTACH_DETACH]: Remove #ifdef wrappers.
	(attach, detach): When neither PT_ATTACH / PT_DETACH nor
	PTRACE_ATTACH / PTRACE_DETACH available call error.
	(PT_ATTACH, PT_DETACH): Move definition to attach / detach.
	* infttrace.c (update_thread_state_after_attach, attach, detach):
	Remove #ifdef wrappers.
	* inftarg.c (child_attach, child_detach): Remove #ifdef wrappers.
	* gnu-nat.c [ATTACH_DETACH]: Remove #ifdef wrappers.
	* config/nm-bsd.h (ATTACH_DETACH): Delete.
	* config/nm-sysv4.h (ATTACH_DETACH): Delete.
	* config/nm-nbsd.h (ATTACH_DETACH): Delete.
	* config/nm-linux.h (ATTACH_DETACH): Delete.
	* config/rs6000/nm-rs6000.h (ATTACH_DETACH): Delete.
	* config/pa/nm-hppah.h (ATTACH_DETACH): Delete.
	* config/i386/nm-i386sco5.h (ATTACH_DETACH): Delete.
	* config/i386/nm-i386sco4.h (ATTACH_DETACH): Delete.
	* config/i386/nm-i386gnu.h (ATTACH_DETACH): Delete.

Index: doc/ChangeLog
2004-06-08  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Native Debugging): Delete documentation on
	ATTACH_DETACH.
@
text
@a608 3
#ifdef CLEAR_INSN_CACHE
      CLEAR_INSN_CACHE ();
#endif
@


1.29
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@a78 7
#ifndef PT_ATTACH
#define PT_ATTACH PTRACE_ATTACH
#endif
#ifndef PT_DETACH
#define PT_DETACH PTRACE_DETACH
#endif

a274 2

#ifdef ATTACH_DETACH
d280 6
d291 3
d304 6
d315 3
a318 1
#endif /* ATTACH_DETACH */
@


1.29.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2004
a23 1
#include "command.h"
a24 1
#include "gdbcore.h"
d26 2
a28 1
#include "target.h"
a29 1
#include "gdb_assert.h"
d31 6
a36 1
#include "gdb_string.h"
d43 42
a84 1
#include "gdb_ptrace.h"
d86 2
a87 1
#ifdef HAVE_SYS_FILE_H
d90 6
d99 3
d108 6
d136 1
a136 1
#ifndef PTRACE_TYPE_ARG5
d173 1
a173 1
#ifndef PTRACE_TYPE_ARG5
d192 1
a192 1
#if defined (DEBUG_PTRACE) || defined (PTRACE_TYPE_ARG5)
d229 1
a229 1
  ptrace (PT_KILL, pid, (PTRACE_TYPE_ARG3) 0, 0);
a243 1
  int request = PT_CONTINUE;
d246 2
d254 9
d265 5
a269 8
      /* If this system does not support PT_STEP, a higher level
	 function will have called single_step() to transmute the step
	 request into a continue request (by setting breakpoints on
	 all possible successor instructions), so we don't have to
	 worry about that here.  */

      gdb_assert (!SOFTWARE_SINGLE_STEP_P ());
      request = PT_STEP;
d271 3
d275 4
a278 8
  /* An address of (PTRACE_TYPE_ARG3)1 tells ptrace to continue from
     where it was.  If GDB wanted it to start some other way, we have
     already written a new PC value to the child.  */

  errno = 0;
  ptrace (request, pid, (PTRACE_TYPE_ARG3)1, target_signal_to_host (signal));
  if (errno != 0)
    perror_with_name ("ptrace");
d283 1
a284 1

a287 1
#ifdef PT_ATTACH
d289 2
a290 2
  ptrace (PT_ATTACH, pid, (PTRACE_TYPE_ARG3) 0, 0);
  if (errno != 0)
a293 3
#else
  error ("This system does not support attaching to a process");
#endif
d296 3
a298 2
/* Stop debugging the process whose number is PID and continue it with
   signal number SIGNAL.  SIGNAL = 0 means just continue it.  */
a302 3
#ifdef PT_DETACH
  int pid = PIDGET (inferior_ptid);

d304 4
a307 3
  ptrace (PT_DETACH, pid, (PTRACE_TYPE_ARG3) 1, signal);
  if (errno != 0)
    perror_with_name ("ptrace");
a308 3
#else
  error ("This system does not support detaching from a process");
#endif
d310 1
d312 4
d317 6
a322 1
#ifndef FETCH_INFERIOR_REGISTERS
d324 17
a340 2
/* U_REGS_OFFSET is the offset of the registers within the u area.  */
#ifndef U_REGS_OFFSET
d342 1
a342 1
#ifndef offsetof
d346 2
d350 1
a350 1
	  (PTRACE_TYPE_ARG3) (offsetof (struct user, u_ar0)), 0) \
d354 1
a354 1
/* Fetch register REGNUM from the inferior.  */
d357 1
a357 1
fetch_register (int regnum)
d359 7
a365 4
  CORE_ADDR addr;
  size_t size;
  PTRACE_TYPE_RET *buf;
  int tid, i;
d367 1
a367 1
  if (CANNOT_FETCH_REGISTER (regnum))
d369 2
a370 1
      regcache_raw_supply (current_regcache, regnum, NULL);
d374 3
a376 8
  /* GNU/Linux LWP ID's are process ID's.  */
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */

  /* This isn't really an address.  But ptrace thinks of it as one.  */
  addr = register_addr (regnum, U_REGS_OFFSET);
  size = register_size (current_gdbarch, regnum);
d378 1
a378 2
  gdb_assert ((size % sizeof (PTRACE_TYPE_RET)) == 0);
  buf = alloca (size);
d380 2
a381 2
  /* Read the register contents from the inferior a chuck at the time.  */
  for (i = 0; i < size / sizeof (PTRACE_TYPE_RET); i++)
d384 3
a386 1
      buf[i] = ptrace (PT_READ_U, tid, (PTRACE_TYPE_ARG3) addr, 0);
d388 5
a392 4
	error ("Couldn't read register %s (#%d): %s.", REGISTER_NAME (regnum),
	       regnum, safe_strerror (errno));

      addr += sizeof (PTRACE_TYPE_RET);
d394 1
a394 1
  regcache_raw_supply (current_regcache, regnum, buf);
d397 4
a400 2
/* Fetch register REGNUM from the inferior.  If REGNUM is -1, do this
   for all registers.  */
d403 1
a403 1
fetch_inferior_registers (int regnum)
d405 4
a408 3
  if (regnum == -1)
    for (regnum = 0; regnum < NUM_REGS; regnum++)
      fetch_register (regnum);
d410 6
a415 1
    fetch_register (regnum);
d418 1
a418 1
/* Store register REGNUM into the inferior.  */
d421 1
a421 1
store_register (int regnum)
d423 7
a429 4
  CORE_ADDR addr;
  size_t size;
  PTRACE_TYPE_RET *buf;
  int tid, i;
d431 8
a438 2
  if (CANNOT_STORE_REGISTER (regnum))
    return;
d440 1
a440 4
  /* GNU/Linux LWP ID's are process ID's.  */
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d442 1
a442 3
  /* This isn't really an address.  But ptrace thinks of it as one.  */
  addr = register_addr (regnum, U_REGS_OFFSET);
  size = register_size (current_gdbarch, regnum);
d444 2
a445 2
  gdb_assert ((size % sizeof (PTRACE_TYPE_RET)) == 0);
  buf = alloca (size);
d447 2
a448 3
  /* Write the register contents into the inferior a chunk at the time.  */
  regcache_raw_collect (current_regcache, regnum, buf);
  for (i = 0; i < size / sizeof (PTRACE_TYPE_RET); i++)
d451 3
a453 1
      ptrace (PT_WRITE_U, tid, (PTRACE_TYPE_ARG3) addr, buf[i]);
d455 5
a459 4
	error ("Couldn't write register %s (#%d): %s.", REGISTER_NAME (regnum),
	       regnum, safe_strerror (errno));

      addr += sizeof (PTRACE_TYPE_RET);
d463 3
a465 2
/* Store register REGNUM back into the inferior.  If REGNUM is -1, do
   this for all registers (including the floating point registers).  */
d468 1
a468 1
store_inferior_registers (int regnum)
d470 4
a473 3
  if (regnum == -1)
    for (regnum = 0; regnum < NUM_REGS; regnum++)
      store_register (regnum);
d475 6
a480 1
    store_register (regnum);
d482 1
a482 2

#endif /* not FETCH_INFERIOR_REGISTERS.  */
d511 1
a511 1
  CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_TYPE_RET);
d513 4
a516 4
  int count = ((((memaddr + len) - addr) + sizeof (PTRACE_TYPE_RET) - 1)
	       / sizeof (PTRACE_TYPE_RET));
  int alloc = count * sizeof (PTRACE_TYPE_RET);
  PTRACE_TYPE_RET *buffer;
d553 1
a553 1
      buffer = (PTRACE_TYPE_RET *) alloca (alloc);
d557 1
a557 1
      buffer = (PTRACE_TYPE_RET *) xmalloc (alloc);
d565 1
a565 1
      if (addr != memaddr || len < (int) sizeof (PTRACE_TYPE_RET))
d569 1
a569 1
			      (PTRACE_TYPE_ARG3) addr, 0);
d576 2
a577 2
		    ((PTRACE_TYPE_ARG3)
		     (addr + (count - 1) * sizeof (PTRACE_TYPE_RET))), 0);
d581 1
a581 1
      memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_TYPE_RET) - 1)),
d585 1
a585 1
      for (i = 0; i < count; i++, addr += sizeof (PTRACE_TYPE_RET))
d589 1
a589 1
		  (PTRACE_TYPE_ARG3) addr, buffer[i]);
d596 1
a596 1
		      (PTRACE_TYPE_ARG3) addr, buffer[i]);
d601 3
d608 1
a608 1
      for (i = 0; i < count; i++, addr += sizeof (PTRACE_TYPE_RET))
d612 1
a612 1
			      (PTRACE_TYPE_ARG3) addr, 0);
d620 1
a620 1
	      (char *) buffer + (memaddr & (sizeof (PTRACE_TYPE_RET) - 1)),
d664 1
a664 1
      udot_val = ptrace (PT_READ_U, PIDGET (inferior_ptid), (PTRACE_TYPE_ARG3) udot_off, 0);
@


1.29.6.2
log
@Merge from mainline.
@
text
@d151 1
a151 5
#ifndef DEPRECATED_KILL_INFERIOR
/* NOTE: cagney/2004-09-12: Instead of definining this macro, code
   should call inf_ptrace_target to get a basic ptrace target and then
   locally update any necessary methods.  See ppcnbsd-nat.c.  */

d173 1
a173 1
#endif /* DEPRECATED_KILL_INFERIOR */
d175 1
a175 4
#ifndef DEPRECATED_CHILD_RESUME
/* NOTE: cagney/2004-09-12: Instead of definining this macro, code
   should call inf_ptrace_target to get a basic ptrace target and then
   locally update any necessary methods.  See ppcnbsd-nat.c.  */
d214 1
a214 1
#endif /* DEPRECATED_CHILD_RESUME */
@


1.28
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d369 1
a369 1
      memset (buf, '\0', REGISTER_RAW_SIZE (regno));	/* Supply zeroes */
d381 1
a381 1
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d448 1
a448 1
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
@


1.27
log
@	* Makefile.in (i386-linux-nat.o): Update dependencies.
	* config/i386/nm-linux.h (LINUX_CHILD_POST_STARTUP_INFERIOR): Define.
	* config/nm-linux.h (CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH)
	(CHILD_FOLLOW_FORK, KILL_INFERIOR): Define.
	* i386-linux-nat.c: Include "linux-nat.h".
	(child_post_startup_inferior): New function.
	* i386-nat.c (child_post_startup_inferior): Wrap in #ifdef.
	* infptrace.c (kill_inferior): Wrap in #ifdef.
	* lin-lwp.c (lin_lwp_attach_lwp): Call child_post_attach after
	attaching to each LWP.
	(child_wait, lin_lwp_wait): Call linux_handle_extended_wait.
	(init_lin_lwp_ops): Fill in some more operations.
	* linux-nat.h (linux_enable_event_reporting)
	(linux_handle_extended_wait, linux_child_post_startup_inferior): New
	prototypes.
	* linux-nat.c (linux_enable_event_reporting): New function.
	(child_post_attach, linux_child_post_startup_inferior)
	(child_post_startup_inferior, child_follow_fork)
	(linux_handle_extended_wait, kill_inferior): New functions.
@
text
@d362 1
a362 1
  register int i;
d426 1
a426 1
  register int i;
@


1.26
log
@
2003-05-22  Jeff Johnston  <jjohnstn@@redhat.com>

        * infptrace.c (detach): Call print_sys_errmsg rather than
        perror_with_name to issue warning message when errno is non-zero
        after calling ptrace detach.
@
text
@d211 1
d233 1
@


1.26.8.1
log
@	* Makefile.in (i386-linux-nat.o): Update dependencies.
	* config/i386/nm-linux.h (LINUX_CHILD_POST_STARTUP_INFERIOR): Define.
	* config/nm-linux.h (CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH)
	(CHILD_FOLLOW_FORK, KILL_INFERIOR): Define.
	* i386-linux-nat.c: Include "linux-nat.h".
	(child_post_startup_inferior): New function.
	* i386-nat.c (child_post_startup_inferior): Wrap in #ifdef.
	* infptrace.c (kill_inferior): Wrap in #ifdef.
	* lin-lwp.c (lin_lwp_attach_lwp): Call child_post_attach after
	attaching to each LWP.
	(child_wait, lin_lwp_wait): Call linux_handle_extended_wait.
	(init_lin_lwp_ops): Fill in some more operations.
	* linux-nat.h (linux_enable_event_reporting)
	(linux_handle_extended_wait, linux_child_post_startup_inferior): New
	prototypes.
	* linux-nat.c (linux_enable_event_reporting): New function.
	(child_post_attach, linux_child_post_startup_inferior)
	(child_post_startup_inferior, child_follow_fork)
	(linux_handle_extended_wait, kill_inferior): New functions.
@
text
@a210 1
#ifndef KILL_INFERIOR
a231 1
#endif /* KILL_INFERIOR */
@


1.25
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d304 2
a305 2
  if (errno && errno != ESRCH)
    perror_with_name ("ptrace");
@


1.25.6.1
log
@Snap const char * mess.
@
text
@d105 1
a105 1
static void udot_info (const char *, int);
d629 1
a629 1
udot_info (const char *dummy1, int dummy2)
@


1.24
log
@
2003-02-25  Jeff Johnston  <jjohnstn@@redhat.com>

        * infptrace.c (detach): Do not flag error if ptrace detach fails
        and errno is set to ESRCH.
@
text
@d362 1
a362 1
  char *buf = alloca (MAX_REGISTER_RAW_SIZE);
d427 1
a427 1
  char *buf = alloca (MAX_REGISTER_RAW_SIZE);
@


1.24.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d362 1
a362 1
  char buf[MAX_REGISTER_SIZE];
d427 1
a427 1
  char buf[MAX_REGISTER_SIZE];
@


1.23
log
@2003-02-24  Andrew Cagney  <cagney@@redhat.com>

	* infptrace.c (udot_info): Change type of udot_off to long.  Use
	paddr when printing udot_off's value.
@
text
@d304 1
a304 1
  if (errno)
@


1.22
log
@* infptrace.c (child_xfer_memory): Make use of the new PT_IO
request that's available in *BSD.
@
text
@d632 1
a632 1
  int udot_off;			/* Offset into user struct */
d660 1
a660 1
	  printf_filtered ("%04x:", udot_off);
d665 2
a666 1
	  sprintf (mess, "\nreading user struct at offset 0x%x", udot_off);
@


1.21
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d517 31
@


1.21.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a210 1
#ifndef KILL_INFERIOR
a231 1
#endif /* KILL_INFERIOR */
d305 1
a305 1
    print_sys_errmsg ("ptrace", errno);
d360 1
a360 1
  int i;
d362 1
a362 1
  char buf[MAX_REGISTER_SIZE];
d367 1
a367 1
      memset (buf, '\0', DEPRECATED_REGISTER_RAW_SIZE (regno));	/* Supply zeroes */
d379 1
a379 1
  for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d424 1
a424 1
  int i;
d427 1
a427 1
  char buf[MAX_REGISTER_SIZE];
d446 1
a446 1
  for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
a516 31
#ifdef PT_IO
  /* OpenBSD 3.1, NetBSD 1.6 and FreeBSD 5.0 have a new PT_IO request
     that promises to be much more efficient in reading and writing
     data in the traced process's address space.  */

  {
    struct ptrace_io_desc piod;

    /* NOTE: We assume that there are no distinct address spaces for
       instruction and data.  */
    piod.piod_op = write ? PIOD_WRITE_D : PIOD_READ_D;
    piod.piod_offs = (void *) memaddr;
    piod.piod_addr = myaddr;
    piod.piod_len = len;

    if (ptrace (PT_IO, PIDGET (inferior_ptid), (caddr_t) &piod, 0) == -1)
      {
	/* If the PT_IO request is somehow not supported, fallback on
           using PT_WRITE_D/PT_READ_D.  Otherwise we will return zero
           to indicate failure.  */
	if (errno != EINVAL)
	  return 0;
      }
    else
      {
	/* Return the actual number of bytes read or written.  */
	return piod.piod_len;
      }
  }
#endif

d601 1
a601 1
  long udot_off;			/* Offset into user struct */
d629 1
a629 1
	  printf_filtered ("%s:", paddr (udot_off));
d634 1
a634 2
	  sprintf (mess, "\nreading user struct at offset 0x%s",
		   paddr_nz (udot_off));
@


1.21.16.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a516 31
#ifdef PT_IO
  /* OpenBSD 3.1, NetBSD 1.6 and FreeBSD 5.0 have a new PT_IO request
     that promises to be much more efficient in reading and writing
     data in the traced process's address space.  */

  {
    struct ptrace_io_desc piod;

    /* NOTE: We assume that there are no distinct address spaces for
       instruction and data.  */
    piod.piod_op = write ? PIOD_WRITE_D : PIOD_READ_D;
    piod.piod_offs = (void *) memaddr;
    piod.piod_addr = myaddr;
    piod.piod_len = len;

    if (ptrace (PT_IO, PIDGET (inferior_ptid), (caddr_t) &piod, 0) == -1)
      {
	/* If the PT_IO request is somehow not supported, fallback on
           using PT_WRITE_D/PT_READ_D.  Otherwise we will return zero
           to indicate failure.  */
	if (errno != EINVAL)
	  return 0;
      }
    else
      {
	/* Return the actual number of bytes read or written.  */
	return piod.piod_len;
      }
  }
#endif

@


1.21.16.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d304 1
a304 1
  if (errno && errno != ESRCH)
d632 1
a632 1
  long udot_off;			/* Offset into user struct */
d660 1
a660 1
	  printf_filtered ("%s:", paddr (udot_off));
d665 1
a665 2
	  sprintf (mess, "\nreading user struct at offset 0x%s",
		   paddr_nz (udot_off));
@


1.21.16.3
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d304 2
a305 2
  if (errno)
    print_sys_errmsg ("ptrace", errno);
d362 1
a362 1
  char buf[MAX_REGISTER_SIZE];
d427 1
a427 1
  char buf[MAX_REGISTER_SIZE];
@


1.21.16.4
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a210 1
#ifndef KILL_INFERIOR
a231 1
#endif /* KILL_INFERIOR */
d360 1
a360 1
  int i;
d424 1
a424 1
  int i;
@


1.21.16.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d369 1
a369 1
      memset (buf, '\0', DEPRECATED_REGISTER_RAW_SIZE (regno));	/* Supply zeroes */
d381 1
a381 1
  for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d448 1
a448 1
  for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
@


1.20
log
@2002-01-07  Michael Snyder  <msnyder@@redhat.com>

	* infptrace.c (GDB_MAX_ALLOCA): New define.
	(child_xfer_memory): Use xmalloc/xfree instead of alloca if the
	size of the buffer exceeds GDB_MAX_ALLOCA (default 1 megabyte,
	can be overridden with whatever value is appropriate to the host).
	* infttrace.c (child_xfer_memory): Add FIXME warning about use of
	alloca to allocate potentially large buffer.
	* rs6000-nat.c (child_xfer_memory): Ditto.
	* symm-nat.c (child_xfer_memory): Ditto.
	* x86-64-linux-nat.c (child_xfer_memory): Ditto.
@
text
@d2 2
a3 2
   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998,
   1999, 2000, 2001
d505 1
a505 2
		   struct mem_attrib *attrib ATTRIBUTE_UNUSED,
		   struct target_ops *target)
@


1.19
log
@2001-11-19  Elena Zannoni  <ezannoni@@redhat.com>

	* infptrace.c (fetch_register): Dynamically allocate buffer for
	register.
	(store_register): Use regcache_collect, instead of accessing the
	register buffer directly.
@
text
@d483 5
d514 4
d519 9
a527 2
  PTRACE_XFER_TYPE *buffer =
    (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
d592 2
@


1.18
log
@* infptrace.c (child_xfer_memory): Fix a few coding standards
violations.
@
text
@d362 1
a362 1
  char buf[MAX_REGISTER_RAW_SIZE];
d427 1
d441 5
d450 1
a450 1
	      *(PTRACE_XFER_TYPE *) & registers[REGISTER_BYTE (regno) + i]);
@


1.17
log
@        * infptrace.c (child_xfer_memory): Add cast to CORE_ADDR.
        * infttrace.c (child_xfer_memory): Likewise.
        * symm-nat.c (child_xfer_memory): Likewise.
        * gdbserver/low-hppabsd.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-linux.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-lynx.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-nbsd.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-sparc.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-sun3.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
@
text
@d479 12
a490 13
   in the NEW_SUN_PTRACE case.
   It ought to be straightforward.  But it appears that writing did
   not write the data that I specified.  I cannot understand where
   it got the data that it actually did write.  */

/* Copy LEN bytes to or from inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR.   Copy to inferior if
   WRITE is nonzero.  TARGET is ignored.

   Returns the length copied, which is either the LEN argument or zero.
   This xfer function does not do partial moves, since child_ops
   doesn't allow memory operations to cross below us in the target stack
   anyway.  */
d497 1
a497 1
  register int i;
d499 1
a499 1
  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_XFER_TYPE);
d501 2
a502 3
  register int count
  = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
  / sizeof (PTRACE_XFER_TYPE);
d504 2
a505 2
  register PTRACE_XFER_TYPE *buffer
  = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
d509 2
a510 2
      /* Fill start and end extra bytes of buffer with existing memory data.  */

d518 1
a518 1
      if (count > 1)		/* FIXME, avoid if even boundary */
d520 4
a523 5
	  buffer[count - 1] 
	    = ptrace (PT_READ_I, PIDGET (inferior_ptid),
		      ((PTRACE_ARG3_TYPE)
		       (addr + (count - 1) * sizeof (PTRACE_XFER_TYPE))),
		      0);
d526 1
a526 2
      /* Copy data to be written over corresponding part of buffer */

d528 1
a528 2
	      myaddr,
	      len);
a530 1

d553 1
a553 1
      /* Read all the longwords */
d569 1
@


1.16
log
@Multi-arch CANNOT_FETCH_REGISTER() and CANNOT_STORE_REGISTER().
@
text
@d500 1
a500 1
  register CORE_ADDR addr = memaddr & -sizeof (PTRACE_XFER_TYPE);
@


1.15
log
@Redefine ptid_t to be a struct rather than an int.
@
text
@a351 5
/* Registers we shouldn't try to fetch.  */
#if !defined (CANNOT_FETCH_REGISTER)
#define CANNOT_FETCH_REGISTER(regno) 0
#endif

a414 5

/* Registers we shouldn't try to store.  */
#if !defined (CANNOT_STORE_REGISTER)
#define CANNOT_STORE_REGISTER(regno) 0
#endif
@


1.14
log
@Phase 1 of the ptid_t changes.
@
text
@a112 16
/*
 * Some systems (Linux) may have threads implemented as pseudo-processes, 
 * in which case we may be tracing more than one process at a time.
 * In that case, inferior_pid will contain the main process ID and the 
 * individual thread (process) id mashed together.  These macros are 
 * used to separate them out.  The definitions may be overridden in tm.h
 *
 * NOTE: default definitions here are for systems with no threads.
 * Useful definitions MUST be provided in tm.h
 */

#if !defined (PIDGET)	/* Default definition for PIDGET/TIDGET.  */
#define PIDGET(PID)	PID
#define TIDGET(PID)	0
#endif

@


1.13
log
@Change SOFTWARE_SINGLE_STEP_P into SOFTWARE_SINGLE_STEP_P().
@
text
@d218 1
a218 1
ptrace_wait (int pid, int *status)
d223 1
a223 1
  target_post_wait (wstate, *status);
d231 1
d233 1
a233 1
  if (inferior_pid == 0)
d244 2
a245 2
  ptrace (PT_KILL, inferior_pid, (PTRACE_ARG3_TYPE) 0, 0);
  ptrace_wait (0, &status);
d256 1
a256 1
child_resume (int pid, int step, enum target_signal signal)
d258 2
d265 2
a266 2
       all threads" and "resume inferior_pid" are the same.  */
    pid = inferior_pid;
d318 2
a319 1
  ptrace (PT_DETACH, inferior_pid, (PTRACE_ARG3_TYPE) 1, signal);
d363 1
a363 1
  ptrace (PT_READ_U, inferior_pid, \
d394 2
a395 2
  if ((tid = TIDGET (inferior_pid)) == 0)
    tid = inferior_pid;		/* no thread id, just use process id */
d460 2
a461 2
  if ((tid = TIDGET (inferior_pid)) == 0)
    tid = inferior_pid;		/* no thread id, just use process id */
d542 1
a542 1
	  buffer[0] = ptrace (PT_READ_I, PIDGET (inferior_pid), 
d549 1
a549 1
	    = ptrace (PT_READ_I, PIDGET (inferior_pid),
d566 1
a566 1
	  ptrace (PT_WRITE_D, PIDGET (inferior_pid), 
d573 1
a573 1
	      ptrace (PT_WRITE_I, PIDGET (inferior_pid), 
d589 1
a589 1
	  buffer[i] = ptrace (PT_READ_I, PIDGET (inferior_pid),
d639 1
a639 1
      udot_val = ptrace (PT_READ_U, inferior_pid, (PTRACE_ARG3_TYPE) udot_off, 0);
@


1.12
log
@Eliminate ARCH_NUM_REGS.
@
text
@d276 1
a276 1
      if (SOFTWARE_SINGLE_STEP_P)
@


1.11
log
@Update/correct copyright notices.
@
text
@d426 1
a426 1
      for (regno = 0; regno < ARCH_NUM_REGS; regno++)
d490 1
a490 1
      for (regno = 0; regno < ARCH_NUM_REGS; regno++)
@


1.10
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1988, 89, 90, 91, 92, 93, 94, 95, 96, 1998, 2001 
@


1.9
log
@Replace calls to abort() with calls to internal_error().
@
text
@d27 1
@


1.8
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d275 1
a275 1
	abort ();		/* Make sure this doesn't happen. */
@


1.7
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@d343 2
a344 1
    internal_error ("Unable to get kernel u area address.");
@


1.6
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright 1988, 89, 90, 91, 92, 93, 94, 95, 96, 1998 
d514 1
@


1.5
log
@Protoization.
@
text
@d505 1
a505 1
   WRITE is nonzero.
d513 2
a514 6
child_xfer_memory (memaddr, myaddr, len, write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *target;	/* ignored */
@


1.4
log
@PARAMS removal.
@
text
@d135 1
a135 4
call_ptrace (request, pid, addr, data)
     int request, pid;
     PTRACE_ARG3_TYPE addr;
     int data;
d216 1
a216 3
ptrace_wait (pid, status)
     int pid;
     int *status;
d226 1
a226 1
kill_inferior ()
d253 1
a253 4
child_resume (pid, step, signal)
     int pid;
     int step;
     enum target_signal signal;
d295 1
a295 2
attach (pid)
     int pid;
d310 1
a310 2
detach (signal)
     int signal;
d333 1
a333 1
_initialize_kernel_u_addr ()
d369 1
a369 2
fetch_register (regno)
     int regno;
d415 1
a415 2
fetch_inferior_registers (regno)
     int regno;
d438 1
a438 2
store_register (regno)
     int regno;
d479 1
a479 2
store_inferior_registers (regno)
     int regno;
d602 1
a602 3
udot_info (dummy1, dummy2)
     char *dummy1;
     int dummy2;
d652 1
a652 1
_initialize_infptrace ()
@


1.3
log
@Replace <sys/dir.h> (and <dirent.h>) with "gdb_dirent.h".
@
text
@d103 1
a103 1
static void udot_info PARAMS ((char *, int));
d107 2
a108 2
static void fetch_register PARAMS ((int));
static void store_register PARAMS ((int));
d127 2
a128 2
void _initialize_kernel_u_addr PARAMS ((void));
void _initialize_infptrace PARAMS ((void));
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d37 1
a37 1
#include <sys/dir.h>
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 3
a29 1
#include "wait.h"
d42 1
a42 1
# include <ptrace.h>
d44 3
a46 3
# ifdef HAVE_SYS_PTRACE_H
#  include <sys/ptrace.h>
# endif
d111 16
d129 1
a130 1

d150 9
a158 7
  if (request == PT_SETTRC) {
    errno = 0;
    pt_status = ptrace (PT_SETTRC, pid, addr, data
#if defined (FIVE_ARG_PTRACE)
                       /* Deal with HPUX 8.0 braindamage.  We never use the
                          calls which require the fifth argument.  */
                       , 0
d160 2
a161 3
                       );

     if (errno) perror_with_name ("ptrace");
d163 1
a163 1
     printf (" = %d\n", pt_status);
d165 5
a169 5
     if (pt_status < 0)
         return pt_status;
     else
         return parent_attach_all (pid, addr, data);
  }
d190 6
a195 5
  pt_status = ptrace (request, pid, addr, data
#if defined (FIVE_ARG_PTRACE)
		 /* Deal with HPUX 8.0 braindamage.  We never use the
		    calls which require the fifth argument.  */
		 , 0
d197 1
a197 1
		 );
d220 2
a221 2
    int pid;
    int *status;
d283 1
a283 1
	abort();  /* Make sure this doesn't happen. */
d285 1
a285 1
	ptrace (PT_STEP,     pid, (PTRACE_ARG3_TYPE) 1,
d293 3
a295 1
    perror_with_name ("ptrace");
d298 1
a299 1

d353 1
a353 1
    fatal ("Unable to get kernel u area address.");
d384 1
a384 1
  char mess[128];				/* For messages */
d386 1
a386 1
  unsigned int offset;  /* Offset of registers within the u area.  */
d388 1
d397 4
d407 2
a408 2
      *(PTRACE_XFER_TYPE *) &buf[i] = ptrace (PT_READ_U, inferior_pid,
					      (PTRACE_ARG3_TYPE) regaddr, 0);
d412 2
a413 1
	  sprintf (mess, "reading register %s (#%d)", REGISTER_NAME (regno), regno);
d455 1
a455 1
  char mess[128];				/* For messages */
d457 2
a458 1
  unsigned int offset;  /* Offset of registers within the u area.  */
d465 4
d472 1
a472 1
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof(PTRACE_XFER_TYPE))
d475 2
a476 2
      ptrace (PT_WRITE_U, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
	      *(PTRACE_XFER_TYPE *) &registers[REGISTER_BYTE (regno) + i]);
d480 2
a481 1
	  sprintf (mess, "writing register %s (#%d)", REGISTER_NAME (regno), regno);
d520 1
a520 1
  
d532 1
a532 1
     struct target_ops *target;		/* ignored */
d536 1
a536 1
  register CORE_ADDR addr = memaddr & - sizeof (PTRACE_XFER_TYPE);
d539 2
a540 2
    = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
      / sizeof (PTRACE_XFER_TYPE);
d543 1
a543 1
    = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
d549 6
a554 5
      if (addr != memaddr || len < (int) sizeof (PTRACE_XFER_TYPE)) {
	/* Need part of initial word -- fetch it.  */
        buffer[0] = ptrace (PT_READ_I, inferior_pid, (PTRACE_ARG3_TYPE) addr,
			    0);
      }
d558 2
a559 2
	  buffer[count - 1]
	    = ptrace (PT_READ_I, inferior_pid,
d576 2
a577 2
	  ptrace (PT_WRITE_D, inferior_pid, (PTRACE_ARG3_TYPE) addr,
		  buffer[i]);
d579 1
a579 1
            {
d581 1
a581 1
		 Gould NP1, at least.  */
d583 2
a584 2
	      ptrace (PT_WRITE_I, inferior_pid, (PTRACE_ARG3_TYPE) addr,
		      buffer[i]);
d590 1
a590 1
      CLEAR_INSN_CACHE();
d599 1
a599 1
	  buffer[i] = ptrace (PT_READ_I, inferior_pid,
d613 1
a614 1

d621 3
a623 3
  int udot_off;		/* Offset into user struct */
  int udot_val;		/* Value from user struct at udot_off */
  char mess[128];	/* For messages */
d626 4
a629 4
   if (!target_has_execution)
     {
       error ("The program is not being run.");
     }
d665 1
a666 1

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d39 1
a39 1
#include <ptrace.h>
d41 3
a43 3
#ifdef HAVE_SYS_PTRACE_H
#include <sys/ptrace.h>
#endif
d110 1
a111 1

d131 3
a133 4
  if (request == PT_SETTRC)
    {
      errno = 0;
      pt_status = ptrace (PT_SETTRC, pid, addr, data
d135 3
a137 3
      /* Deal with HPUX 8.0 braindamage.  We never use the
         calls which require the fifth argument.  */
			  ,0
d139 1
a139 1
	);
d141 1
a141 2
      if (errno)
	perror_with_name ("ptrace");
d143 1
a143 1
      printf (" = %d\n", pt_status);
d145 5
a149 5
      if (pt_status < 0)
	return pt_status;
      else
	return parent_attach_all (pid, addr, data);
    }
d172 3
a174 3
  /* Deal with HPUX 8.0 braindamage.  We never use the
     calls which require the fifth argument.  */
		      ,0
d176 1
a176 1
    );
d199 2
a200 2
     int pid;
     int *status;
d262 1
a262 1
	abort ();		/* Make sure this doesn't happen. */
d264 1
a264 1
	ptrace (PT_STEP, pid, (PTRACE_ARG3_TYPE) 1,
d275 1
a276 1

d361 1
a361 1
  char mess[128];		/* For messages */
d363 1
a363 1
  unsigned int offset;		/* Offset of registers within the u area.  */
d379 2
a380 2
      *(PTRACE_XFER_TYPE *) & buf[i] = ptrace (PT_READ_U, inferior_pid,
					     (PTRACE_ARG3_TYPE) regaddr, 0);
d426 1
a426 1
  char mess[128];		/* For messages */
d428 1
a428 1
  unsigned int offset;		/* Offset of registers within the u area.  */
d438 1
a438 1
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d442 1
a442 1
	      *(PTRACE_XFER_TYPE *) & registers[REGISTER_BYTE (regno) + i]);
d485 1
a485 1

d497 1
a497 1
     struct target_ops *target;	/* ignored */
d501 1
a501 1
  register CORE_ADDR addr = memaddr & -sizeof (PTRACE_XFER_TYPE);
d504 2
a505 2
  = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
  / sizeof (PTRACE_XFER_TYPE);
d508 1
a508 1
  = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
d514 5
a518 6
      if (addr != memaddr || len < (int) sizeof (PTRACE_XFER_TYPE))
	{
	  /* Need part of initial word -- fetch it.  */
	  buffer[0] = ptrace (PT_READ_I, inferior_pid, (PTRACE_ARG3_TYPE) addr,
			      0);
	}
d543 1
a543 1
	    {
d545 1
a545 1
	         Gould NP1, at least.  */
d554 1
a554 1
      CLEAR_INSN_CACHE ();
d577 1
a578 1

d585 3
a587 3
  int udot_off;			/* Offset into user struct */
  int udot_val;			/* Value from user struct at udot_off */
  char mess[128];		/* For messages */
d590 4
a593 4
  if (!target_has_execution)
    {
      error ("The program is not being run.");
    }
d629 1
a630 1

@


1.1.1.3
log
@import gdb-1999-08-09 snapshot
@
text
@d333 1
a333 1
    internal_error ("Unable to get kernel u area address.");
@


1.1.1.4
log
@import gdb-1999-12-06 snapshot
@
text
@d27 1
a27 7
#ifdef HAVE_WAIT_H
#include <wait.h>
#else
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
#endif
@


1.1.1.5
log
@import gdb-1999-12-13 snapshot
@
text
@d27 3
d33 1
a33 1
#include "wait.h" /* NOTE: This is ../include/wait.h */
@


1.1.1.6
log
@import gdb-1999-12-21 snapshot
@
text
@a26 4

#ifdef HAVE_WAIT_H
#include <wait.h>
#else
d30 1
a30 5
#endif

/* "wait.h" fills in the gaps left by <wait.h> */
#include "wait.h"	/* NOTE: This is ../include/wait.h */

a111 16
/*
 * Some systems (Linux) may have threads implemented as pseudo-processes, 
 * in which case we may be tracing more than one process at a time.
 * In that case, inferior_pid will contain the main process ID and the 
 * individual thread (process) id mashed together.  These macros are 
 * used to separate them out.  The definitions may be overridden in tm.h
 *
 * NOTE: default definitions here are for systems with no threads.
 * Useful definitions MUST be provided in tm.h
 */

#if !defined (PIDGET)	/* Default definition for PIDGET/TIDGET.  */
#define PIDGET(PID)	PID
#define TIDGET(PID)	0
#endif

d138 2
a139 3
#if !defined (FIVE_ARG_PTRACE)
      pt_status = ptrace (PT_SETTRC, pid, addr, data);
#else
d142 1
a142 1
      pt_status = ptrace (PT_SETTRC, pid, addr, data, 0);
d144 2
d176 2
a177 3
#if !defined (FIVE_ARG_PTRACE)
  pt_status = ptrace (request, pid, addr, data);
#else
d180 1
a180 1
  pt_status = ptrace (request, pid, addr, data, 0);
d182 1
a182 1

d278 1
a278 3
    {
      perror_with_name ("ptrace");
    }
a370 1
  int tid;
a378 4
  /* Overload thread id onto process id */
  if ((tid = TIDGET (inferior_pid)) == 0)
    tid = inferior_pid;		/* no thread id, just use process id */

d385 2
a386 2
      *(PTRACE_XFER_TYPE *) & buf[i] = ptrace (PT_READ_U, tid,
					       (PTRACE_ARG3_TYPE) regaddr, 0);
d390 1
a390 2
	  sprintf (mess, "reading register %s (#%d)", 
		   REGISTER_NAME (regno), regno);
a434 1
  int tid;
a440 4
  /* Overload thread id onto process id */
  if ((tid = TIDGET (inferior_pid)) == 0)
    tid = inferior_pid;		/* no thread id, just use process id */

d447 1
a447 1
      ptrace (PT_WRITE_U, tid, (PTRACE_ARG3_TYPE) regaddr,
d452 1
a452 2
	  sprintf (mess, "writing register %s (#%d)", 
		   REGISTER_NAME (regno), regno);
d523 2
a524 2
	  buffer[0] = ptrace (PT_READ_I, PIDGET (inferior_pid), 
			      (PTRACE_ARG3_TYPE) addr, 0);
d529 2
a530 2
	  buffer[count - 1] 
	    = ptrace (PT_READ_I, PIDGET (inferior_pid),
d547 2
a548 2
	  ptrace (PT_WRITE_D, PIDGET (inferior_pid), 
		  (PTRACE_ARG3_TYPE) addr, buffer[i]);
d554 2
a555 2
	      ptrace (PT_WRITE_I, PIDGET (inferior_pid), 
		      (PTRACE_ARG3_TYPE) addr, buffer[i]);
d570 1
a570 1
	  buffer[i] = ptrace (PT_READ_I, PIDGET (inferior_pid),
@


