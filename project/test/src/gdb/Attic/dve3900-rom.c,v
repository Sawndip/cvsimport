head	1.21;
access;
symbols
	insight_6_6-20070208-release:1.20
	gdb_6_6-2006-12-18-release:1.20
	gdb_6_6-branch:1.20.0.18
	gdb_6_6-2006-11-15-branchpoint:1.20
	insight_6_5-20061003-release:1.20
	gdb-csl-symbian-6_4_50_20060226-12:1.20
	gdb-csl-sourcerygxx-3_4_4-25:1.19
	nickrob-async-20060828-mergepoint:1.20
	gdb-csl-symbian-6_4_50_20060226-11:1.20
	gdb-csl-sourcerygxx-4_1-17:1.20
	gdb-csl-20060226-branch-local-2:1.20
	gdb-csl-sourcerygxx-4_1-14:1.20
	gdb-csl-sourcerygxx-4_1-13:1.20
	gdb-csl-sourcerygxx-4_1-12:1.20
	gdb-csl-sourcerygxx-3_4_4-21:1.20
	gdb_6_5-20060621-release:1.20
	gdb-csl-sourcerygxx-4_1-9:1.20
	gdb-csl-sourcerygxx-4_1-8:1.20
	gdb-csl-sourcerygxx-4_1-7:1.20
	gdb-csl-arm-2006q1-6:1.20
	gdb-csl-sourcerygxx-4_1-6:1.20
	gdb-csl-symbian-6_4_50_20060226-10:1.20
	gdb-csl-symbian-6_4_50_20060226-9:1.20
	gdb-csl-symbian-6_4_50_20060226-8:1.20
	gdb-csl-coldfire-4_1-11:1.20
	gdb-csl-sourcerygxx-3_4_4-19:1.20
	gdb-csl-coldfire-4_1-10:1.20
	gdb_6_5-branch:1.20.0.16
	gdb_6_5-2006-05-14-branchpoint:1.20
	gdb-csl-sourcerygxx-4_1-5:1.20
	nickrob-async-20060513-branch:1.20.0.14
	nickrob-async-20060513-branchpoint:1.20
	gdb-csl-sourcerygxx-4_1-4:1.20
	msnyder-reverse-20060502-branch:1.20.0.12
	msnyder-reverse-20060502-branchpoint:1.20
	gdb-csl-morpho-4_1-4:1.20
	gdb-csl-sourcerygxx-3_4_4-17:1.20
	readline_5_1-import-branch:1.20.0.10
	readline_5_1-import-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.20
	gdb-csl-symbian-20060226-branch:1.20.0.8
	gdb-csl-symbian-20060226-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.20
	msnyder-reverse-20060331-branch:1.20.0.6
	msnyder-reverse-20060331-branchpoint:1.20
	gdb-csl-available-20060303-branch:1.20.0.4
	gdb-csl-available-20060303-branchpoint:1.20
	gdb-csl-20060226-branch:1.20.0.2
	gdb-csl-20060226-branchpoint:1.20
	gdb_6_4-20051202-release:1.19
	msnyder-fork-checkpoint-branch:1.19.0.12
	msnyder-fork-checkpoint-branchpoint:1.19
	gdb-csl-gxxpro-6_3-branch:1.19.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.19
	gdb_6_4-branch:1.19.0.8
	gdb_6_4-2005-11-01-branchpoint:1.19
	gdb-csl-arm-20051020-branch:1.19.0.6
	gdb-csl-arm-20051020-branchpoint:1.19
	msnyder-tracepoint-checkpoint-branch:1.19.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.19
	gdb-csl-arm-20050325-2005-q1b:1.19
	gdb-csl-arm-20050325-2005-q1a:1.19
	csl-arm-20050325-branch:1.19.0.2
	csl-arm-20050325-branchpoint:1.19
	gdb-post-i18n-errorwarning-20050211:1.17
	gdb-pre-i18n-errorwarning-20050211:1.16
	gdb_6_3-20041109-release:1.16
	gdb_6_3-branch:1.16.0.2
	gdb_6_3-20041019-branchpoint:1.16
	drow_intercu-merge-20040921:1.16
	drow_intercu-merge-20040915:1.16
	jimb-gdb_6_2-e500-branch:1.14.0.18
	jimb-gdb_6_2-e500-branchpoint:1.14
	gdb_6_2-20040730-release:1.14
	gdb_6_2-branch:1.14.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.14
	gdb_6_1_1-20040616-release:1.14
	gdb_6_1-2004-04-05-release:1.14
	drow_intercu-merge-20040402:1.14
	drow_intercu-merge-20040327:1.14
	ezannoni_pie-20040323-branch:1.14.0.12
	ezannoni_pie-20040323-branchpoint:1.14
	cagney_tramp-20040321-mergepoint:1.14
	cagney_tramp-20040309-branch:1.14.0.10
	cagney_tramp-20040309-branchpoint:1.14
	gdb_6_1-branch:1.14.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.14
	drow_intercu-20040221-branch:1.14.0.6
	drow_intercu-20040221-branchpoint:1.14
	cagney_bfdfile-20040213-branch:1.14.0.4
	cagney_bfdfile-20040213-branchpoint:1.14
	drow-cplus-merge-20040208:1.14
	carlton_dictionary-20040126-merge:1.14
	cagney_bigcore-20040122-branch:1.14.0.2
	cagney_bigcore-20040122-branchpoint:1.14
	drow-cplus-merge-20040113:1.14
	drow-cplus-merge-20031224:1.14
	drow-cplus-merge-20031220:1.14
	carlton_dictionary-20031215-merge:1.14
	drow-cplus-merge-20031214:1.14
	carlton-dictionary-20031111-merge:1.13
	gdb_6_0-2003-10-04-release:1.12
	kettenis_sparc-20030918-branch:1.12.0.20
	kettenis_sparc-20030918-branchpoint:1.12
	carlton_dictionary-20030917-merge:1.12
	ezannoni_pie-20030916-branchpoint:1.12
	ezannoni_pie-20030916-branch:1.12.0.18
	cagney_x86i386-20030821-branch:1.12.0.16
	cagney_x86i386-20030821-branchpoint:1.12
	carlton_dictionary-20030805-merge:1.12
	carlton_dictionary-20030627-merge:1.12
	gdb_6_0-branch:1.12.0.14
	gdb_6_0-2003-06-23-branchpoint:1.12
	jimb-ppc64-linux-20030613-branch:1.12.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.12
	cagney_convert-20030606-branch:1.12.0.10
	cagney_convert-20030606-branchpoint:1.12
	cagney_writestrings-20030508-branch:1.12.0.8
	cagney_writestrings-20030508-branchpoint:1.12
	jimb-ppc64-linux-20030528-branch:1.12.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.12
	carlton_dictionary-20030523-merge:1.12
	cagney_fileio-20030521-branch:1.12.0.4
	cagney_fileio-20030521-branchpoint:1.12
	kettenis_i386newframe-20030517-mergepoint:1.12
	jimb-ppc64-linux-20030509-branch:1.12.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.12
	kettenis_i386newframe-20030504-mergepoint:1.11
	carlton_dictionary-20030430-merge:1.11
	kettenis_i386newframe-20030419-branch:1.11.0.18
	kettenis_i386newframe-20030419-branchpoint:1.11
	carlton_dictionary-20030416-merge:1.11
	cagney_frameaddr-20030409-mergepoint:1.11
	kettenis_i386newframe-20030406-branch:1.11.0.16
	kettenis_i386newframe-20030406-branchpoint:1.11
	cagney_frameaddr-20030403-branchpoint:1.11
	cagney_frameaddr-20030403-branch:1.11.0.14
	cagney_framebase-20030330-mergepoint:1.11
	cagney_framebase-20030326-branch:1.11.0.12
	cagney_framebase-20030326-branchpoint:1.11
	cagney_lazyid-20030317-branch:1.11.0.10
	cagney_lazyid-20030317-branchpoint:1.11
	kettenis-i386newframe-20030316-mergepoint:1.11
	offbyone-20030313-branch:1.11.0.8
	offbyone-20030313-branchpoint:1.11
	kettenis-i386newframe-20030308-branch:1.11.0.6
	kettenis-i386newframe-20030308-branchpoint:1.11
	carlton_dictionary-20030305-merge:1.11
	cagney_offbyone-20030303-branch:1.11.0.4
	cagney_offbyone-20030303-branchpoint:1.11
	carlton_dictionary-20030207-merge:1.11
	interps-20030203-mergepoint:1.11
	interps-20030202-branch:1.11.0.2
	interps-20030202-branchpoint:1.11
	cagney-unwind-20030108-branch:1.9.0.2
	cagney-unwind-20030108-branchpoint:1.9
	carlton_dictionary-20021223-merge:1.9
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.26
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.24
	carlton_dictionary-20020920-branchpoint:1.8
	gdb_5_3-branch:1.8.0.22
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.20
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.18
	readline_4_3-import-branchpoint:1.8
	gdb_5_2_1-2002-07-23-release:1.8
	kseitz_interps-20020528-branch:1.8.0.16
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.8.0.14
	cagney_regbuf-20020515-branchpoint:1.8
	jimb-macro-020506-branch:1.8.0.12
	jimb-macro-020506-branchpoint:1.8
	gdb_5_2-2002-04-29-release:1.8
	gdb_5_2-branch:1.8.0.10
	gdb_5_2-2002-03-03-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.8
	gdb_5_1_0_1-2002-01-03-release:1.8
	cygnus_cvs_20020108_pre:1.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8
	gdb_5_1_0_1-2002-01-03-branch:1.8.0.8
	gdb_5_1-2001-11-21-release:1.8
	gdb_s390-2001-09-26-branch:1.8.0.6
	gdb_s390-2001-09-26-branchpoint:1.8
	gdb_5_1-2001-07-29-branch:1.8.0.4
	gdb_5_1-2001-07-29-branchpoint:1.8
	dberlin-typesystem-branch:1.8.0.2
	dberlin-typesystem-branchpoint:1.8
	gdb-post-ptid_t-2001-05-03:1.8
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.5
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.21
date	2006.12.16.19.18.37;	author drow;	state dead;
branches;
next	1.20;

1.20
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.14.14.37.37;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.11.18.13.49;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.11.04.05.46;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.03.00.57.25;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.22.01.31.48;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.16.19.24.04;	author cagney;	state Exp;
branches
	1.14.6.1;
next	1.13;

1.13
date	2003.10.02.20.28.29;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.08.22.33.13;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.02.05.46.14;	author cagney;	state Exp;
branches
	1.11.18.1;
next	1.10;

1.10
date	2003.01.18.15.55.51;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.17.23.13.31;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.04.04.15.24;	author kevinb;	state Exp;
branches
	1.8.24.1
	1.8.26.1;
next	1.7;

1.7
date	2001.03.06.08.21.07;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.26;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.05.42;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.08.23.59.07;	author shebs;	state Exp;
branches;
next	;

1.8.24.1
date	2002.12.23.19.38.20;	author carlton;	state Exp;
branches;
next	1.8.24.2;

1.8.24.2
date	2003.02.07.19.17.48;	author carlton;	state Exp;
branches;
next	1.8.24.3;

1.8.24.3
date	2003.05.23.18.40.36;	author carlton;	state Exp;
branches;
next	1.8.24.4;

1.8.24.4
date	2003.11.11.23.50.41;	author carlton;	state Exp;
branches;
next	1.8.24.5;

1.8.24.5
date	2003.12.16.00.00.26;	author carlton;	state Exp;
branches;
next	;

1.8.26.1
date	2003.12.14.20.27.11;	author drow;	state Exp;
branches;
next	;

1.11.18.1
date	2003.05.18.09.44.04;	author kettenis;	state Exp;
branches;
next	;

1.14.6.1
date	2004.09.16.17.01.02;	author drow;	state Exp;
branches;
next	;


desc
@@


1.21
log
@	* dve3900-rom.c: Delete file.
	* Makefile.in (dve3900-rom.o): Delete.
@
text
@/* Remote debugging interface for Densan DVE-R3900 ROM monitor for
   GDB, the GNU debugger.
   Copyright (C) 1997, 1998, 2000, 2001 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "gdbcore.h"
#include "target.h"
#include "monitor.h"
#include "serial.h"
#include "inferior.h"
#include "command.h"
#include "gdb_string.h"
#include <time.h>
#include "regcache.h"
#include "mips-tdep.h"

/* Type of function passed to bfd_map_over_sections.  */

typedef void (*section_map_func) (bfd * abfd, asection * sect, void *obj);

/* Packet escape character used by Densan monitor.  */

#define PESC 0xdc

/* Maximum packet size.  This is actually smaller than necessary
   just to be safe.  */

#define MAXPSIZE 1024

/* External functions.  */

extern void report_transfer_performance (unsigned long, time_t, time_t);

/* Certain registers are "bitmapped", in that the monitor can only display
   them or let the user modify them as a series of named bitfields.
   This structure describes a field in a bitmapped register.  */

struct bit_field
  {
    char *prefix;		/* string appearing before the value */
    char *suffix;		/* string appearing after the value */
    char *user_name;		/* name used by human when entering field value */
    int length;			/* number of bits in the field */
    int start;			/* starting (least significant) bit number of field */
  };

/* Local functions for register manipulation.  */

static void r3900_supply_register (char *regname, int regnamelen,
				   char *val, int vallen);
static void fetch_bad_vaddr (void);
static unsigned long fetch_fields (struct bit_field *bf);
static void fetch_bitmapped_register (int regno, struct bit_field *bf);
static void r3900_fetch_registers (int regno);
static void store_bitmapped_register (int regno, struct bit_field *bf);
static void r3900_store_registers (int regno);

/* Local functions for fast binary loading.  */

static void write_long (char *buf, long n);
static void write_long_le (char *buf, long n);
static int debug_readchar (int hex);
static void debug_write (unsigned char *buf, int buflen);
static void ignore_packet (void);
static void send_packet (char type, unsigned char *buf, int buflen, int seq);
static void process_read_request (unsigned char *buf, int buflen);
static void count_section (bfd * abfd, asection * s,
			   unsigned int *section_count);
static void load_section (bfd * abfd, asection * s, unsigned int *data_count);
static void r3900_load (char *filename, int from_tty);

/* Miscellaneous local functions.  */

static void r3900_open (char *args, int from_tty);


/* Pointers to static functions in monitor.c for fetching and storing
   registers.  We can't use these function in certain cases where the Densan
   monitor acts perversely: for registers that it displays in bit-map
   format, and those that can't be modified at all.  In those cases
   we have to use our own functions to fetch and store their values.  */

static void (*orig_monitor_fetch_registers) (int regno);
static void (*orig_monitor_store_registers) (int regno);

/* Pointer to static function in monitor. for loading programs.
   We use this function for loading S-records via the serial link.  */

static void (*orig_monitor_load) (char *file, int from_tty);

/* This flag is set if a fast ethernet download should be used.  */

static int ethernet = 0;

/* This array of registers needs to match the indexes used by GDB. The
   whole reason this exists is because the various ROM monitors use
   different names than GDB does, and don't support all the registers
   either.  */

static char *r3900_regnames[] =
{
  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
  "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
  "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",

  "S",				/* PS_REGNUM */
  "l",				/* MIPS_EMBED_LO_REGNUM */
  "h",				/* MIPS_EMBED_HI_REGNUM */
  "B",				/* MIPS_EMBED_BADVADDR_REGNUM */
  "Pcause",			/* MIPS_EMBED_CAUSE_REGNUM */
  "p"				/* MIPS_EMBED_PC_REGNUM */
};


/* Table of register names produced by monitor's register dump command.  */

static struct reg_entry
  {
    char *name;
    int regno;
  }
reg_table[] =
{
  {
    "r0_zero", 0
  }
  ,
  {
    "r1_at", 1
  }
  ,
  {
    "r2_v0", 2
  }
  ,
  {
    "r3_v1", 3
  }
  ,
  {
    "r4_a0", 4
  }
  ,
  {
    "r5_a1", 5
  }
  ,
  {
    "r6_a2", 6
  }
  ,
  {
    "r7_a3", 7
  }
  ,
  {
    "r8_t0", 8
  }
  ,
  {
    "r9_t1", 9
  }
  ,
  {
    "r10_t2", 10
  }
  ,
  {
    "r11_t3", 11
  }
  ,
  {
    "r12_t4", 12
  }
  ,
  {
    "r13_t5", 13
  }
  ,
  {
    "r14_t6", 14
  }
  ,
  {
    "r15_t7", 15
  }
  ,
  {
    "r16_s0", 16
  }
  ,
  {
    "r17_s1", 17
  }
  ,
  {
    "r18_s2", 18
  }
  ,
  {
    "r19_s3", 19
  }
  ,
  {
    "r20_s4", 20
  }
  ,
  {
    "r21_s5", 21
  }
  ,
  {
    "r22_s6", 22
  }
  ,
  {
    "r23_s7", 23
  }
  ,
  {
    "r24_t8", 24
  }
  ,
  {
    "r25_t9", 25
  }
  ,
  {
    "r26_k0", 26
  }
  ,
  {
    "r27_k1", 27
  }
  ,
  {
    "r28_gp", 28
  }
  ,
  {
    "r29_sp", 29
  }
  ,
  {
    "r30_fp", 30
  }
  ,
  {
    "r31_ra", 31
  }
  ,
  {
    "HI", MIPS_EMBED_HI_REGNUM
  }
  ,
  {
    "LO", MIPS_EMBED_LO_REGNUM
  }
  ,
  {
    "PC", MIPS_EMBED_PC_REGNUM
  }
  ,
  {
    "BadV", MIPS_EMBED_BADVADDR_REGNUM
  }
  ,
  {
    NULL, 0
  }
};


/* The monitor displays the cache register along with the status register,
   as if they were a single register.  So when we want to fetch the
   status register, parse but otherwise ignore the fields of the
   cache register that the monitor displays.  Register fields that should
   be ignored have a length of zero in the tables below.  */

static struct bit_field status_fields[] =
{
  /* Status register portion */
  {"SR[<CU=", " ", "cu", 4, 28},
  {"RE=", " ", "re", 1, 25},
  {"BEV=", " ", "bev", 1, 22},
  {"TS=", " ", "ts", 1, 21},
  {"Nmi=", " ", "nmi", 1, 20},
  {"INT=", " ", "int", 6, 10},
  {"SW=", ">]", "sw", 2, 8},
  {"[<KUO=", " ", "kuo", 1, 5},
  {"IEO=", " ", "ieo", 1, 4},
  {"KUP=", " ", "kup", 1, 3},
  {"IEP=", " ", "iep", 1, 2},
  {"KUC=", " ", "kuc", 1, 1},
  {"IEC=", ">]", "iec", 1, 0},

  /* Cache register portion (dummy for parsing only) */
  {"CR[<IalO=", " ", "ialo", 0, 13},
  {"DalO=", " ", "dalo", 0, 12},
  {"IalP=", " ", "ialp", 0, 11},
  {"DalP=", " ", "dalp", 0, 10},
  {"IalC=", " ", "ialc", 0, 9},
  {"DalC=", ">] ", "dalc", 0, 8},

  {NULL, NULL, 0, 0}		/* end of table marker */
};


#if 0				/* FIXME: Enable when we add support for modifying cache register.  */
static struct bit_field cache_fields[] =
{
  /* Status register portion (dummy for parsing only) */
  {"SR[<CU=", " ", "cu", 0, 28},
  {"RE=", " ", "re", 0, 25},
  {"BEV=", " ", "bev", 0, 22},
  {"TS=", " ", "ts", 0, 21},
  {"Nmi=", " ", "nmi", 0, 20},
  {"INT=", " ", "int", 0, 10},
  {"SW=", ">]", "sw", 0, 8},
  {"[<KUO=", " ", "kuo", 0, 5},
  {"IEO=", " ", "ieo", 0, 4},
  {"KUP=", " ", "kup", 0, 3},
  {"IEP=", " ", "iep", 0, 2},
  {"KUC=", " ", "kuc", 0, 1},
  {"IEC=", ">]", "iec", 0, 0},

  /* Cache register portion  */
  {"CR[<IalO=", " ", "ialo", 1, 13},
  {"DalO=", " ", "dalo", 1, 12},
  {"IalP=", " ", "ialp", 1, 11},
  {"DalP=", " ", "dalp", 1, 10},
  {"IalC=", " ", "ialc", 1, 9},
  {"DalC=", ">] ", "dalc", 1, 8},

  {NULL, NULL, NULL, 0, 0}	/* end of table marker */
};
#endif


static struct bit_field cause_fields[] =
{
  {"<BD=", " ", "bd", 1, 31},
  {"CE=", " ", "ce", 2, 28},
  {"IP=", " ", "ip", 6, 10},
  {"SW=", " ", "sw", 2, 8},
  {"EC=", ">]", "ec", 5, 2},

  {NULL, NULL, NULL, 0, 0}	/* end of table marker */
};


/* The monitor prints register values in the form

   regname = xxxx xxxx

   We look up the register name in a table, and remove the embedded space in
   the hex value before passing it to monitor_supply_register.  */

static void
r3900_supply_register (char *regname, int regnamelen, char *val, int vallen)
{
  int regno = -1;
  int i;
  char valbuf[10];
  char *p;

  /* Perform some sanity checks on the register name and value.  */
  if (regnamelen < 2 || regnamelen > 7 || vallen != 9)
    return;

  /* Look up the register name.  */
  for (i = 0; reg_table[i].name != NULL; i++)
    {
      int rlen = strlen (reg_table[i].name);
      if (rlen == regnamelen && strncmp (regname, reg_table[i].name, rlen) == 0)
	{
	  regno = reg_table[i].regno;
	  break;
	}
    }
  if (regno == -1)
    return;

  /* Copy the hex value to a buffer and eliminate the embedded space. */
  for (i = 0, p = valbuf; i < vallen; i++)
    if (val[i] != ' ')
      *p++ = val[i];
  *p = '\0';

  monitor_supply_register (regno, valbuf);
}


/* Fetch the BadVaddr register.  Unlike the other registers, this
   one can't be modified, and the monitor won't even prompt to let
   you modify it.  */

static void
fetch_bad_vaddr (void)
{
  char buf[20];

  monitor_printf ("xB\r");
  monitor_expect ("BadV=", NULL, 0);
  monitor_expect_prompt (buf, sizeof (buf));
  monitor_supply_register (mips_regnum (current_gdbarch)->badvaddr, buf);
}


/* Read a series of bit fields from the monitor, and return their
   combined binary value.  */

static unsigned long
fetch_fields (struct bit_field *bf)
{
  char buf[20];
  unsigned long val = 0;
  unsigned long bits;

  for (; bf->prefix != NULL; bf++)
    {
      monitor_expect (bf->prefix, NULL, 0);	/* get prefix */
      monitor_expect (bf->suffix, buf, sizeof (buf));	/* hex value, suffix */
      if (bf->length != 0)
	{
	  bits = strtoul (buf, NULL, 16);	/* get field value */
	  bits &= ((1 << bf->length) - 1);	/* mask out useless bits */
	  val |= bits << bf->start;	/* insert into register */
	}

    }

  return val;
}


static void
fetch_bitmapped_register (int regno, struct bit_field *bf)
{
  unsigned long val;
  unsigned char regbuf[MAX_REGISTER_SIZE];
  char *regname = NULL;

  if (regno >= sizeof (r3900_regnames) / sizeof (r3900_regnames[0]))
    internal_error (__FILE__, __LINE__,
                    _("fetch_bitmapped_register: regno out of bounds"));
  else
    regname = r3900_regnames[regno];

  monitor_printf ("x%s\r", regname);
  val = fetch_fields (bf);
  monitor_printf (".\r");
  monitor_expect_prompt (NULL, 0);

  /* supply register stores in target byte order, so swap here */

  store_unsigned_integer (regbuf, register_size (current_gdbarch, regno), val);
  regcache_raw_supply (current_regcache, regno, regbuf);

}


/* Fetch all registers (if regno is -1), or one register from the
   monitor.  For most registers, we can use the generic monitor_
   monitor_fetch_registers function.  But others are displayed in
   a very unusual fashion by the monitor, and must be handled specially.  */

static void
r3900_fetch_registers (int regno)
{
  if (regno == mips_regnum (current_gdbarch)->badvaddr)
    fetch_bad_vaddr ();
  else if (regno == PS_REGNUM)
    fetch_bitmapped_register (PS_REGNUM, status_fields);
  else if (regno == mips_regnum (current_gdbarch)->cause)
    fetch_bitmapped_register (mips_regnum (current_gdbarch)->cause,
			      cause_fields);
  else
    orig_monitor_fetch_registers (regno);
}


/* Write the new value of the bitmapped register to the monitor.  */

static void
store_bitmapped_register (int regno, struct bit_field *bf)
{
  unsigned long oldval, newval;
  char *regname = NULL;

  if (regno >= sizeof (r3900_regnames) / sizeof (r3900_regnames[0]))
    internal_error (__FILE__, __LINE__,
                    _("fetch_bitmapped_register: regno out of bounds"));
  else
    regname = r3900_regnames[regno];

  /* Fetch the current value of the register.  */
  monitor_printf ("x%s\r", regname);
  oldval = fetch_fields (bf);
  newval = read_register (regno);

  /* To save time, write just the fields that have changed.  */
  for (; bf->prefix != NULL; bf++)
    {
      if (bf->length != 0)
	{
	  unsigned long oldbits, newbits, mask;

	  mask = (1 << bf->length) - 1;
	  oldbits = (oldval >> bf->start) & mask;
	  newbits = (newval >> bf->start) & mask;
	  if (oldbits != newbits)
	    monitor_printf ("%s %lx ", bf->user_name, newbits);
	}
    }

  monitor_printf (".\r");
  monitor_expect_prompt (NULL, 0);
}


static void
r3900_store_registers (int regno)
{
  if (regno == PS_REGNUM)
    store_bitmapped_register (PS_REGNUM, status_fields);
  else if (regno == mips_regnum (current_gdbarch)->cause)
    store_bitmapped_register (mips_regnum (current_gdbarch)->cause,
			      cause_fields);
  else
    orig_monitor_store_registers (regno);
}


/* Write a 4-byte integer to the buffer in big-endian order.  */

static void
write_long (char *buf, long n)
{
  buf[0] = (n >> 24) & 0xff;
  buf[1] = (n >> 16) & 0xff;
  buf[2] = (n >> 8) & 0xff;
  buf[3] = n & 0xff;
}


/* Write a 4-byte integer to the buffer in little-endian order.  */

static void
write_long_le (char *buf, long n)
{
  buf[0] = n & 0xff;
  buf[1] = (n >> 8) & 0xff;
  buf[2] = (n >> 16) & 0xff;
  buf[3] = (n >> 24) & 0xff;
}


/* Read a character from the monitor.  If remote debugging is on,
   print the received character.  If HEX is non-zero, print the
   character in hexadecimal; otherwise, print it in ASCII.  */

static int
debug_readchar (int hex)
{
  char buf[10];
  int c = monitor_readchar ();

  if (remote_debug > 0)
    {
      if (hex)
	sprintf (buf, "[%02x]", c & 0xff);
      else if (c == '\0')
	strcpy (buf, "\\0");
      else
	{
	  buf[0] = c;
	  buf[1] = '\0';
	}
      puts_debug ("Read -->", buf, "<--");
    }
  return c;
}


/* Send a buffer of characters to the monitor.  If remote debugging is on,
   print the sent buffer in hex.  */

static void
debug_write (unsigned char *buf, int buflen)
{
  char s[10];

  monitor_write (buf, buflen);

  if (remote_debug > 0)
    {
      while (buflen-- > 0)
	{
	  sprintf (s, "[%02x]", *buf & 0xff);
	  puts_debug ("Sent -->", s, "<--");
	  buf++;
	}
    }
}


/* Ignore a packet sent to us by the monitor.  It send packets
   when its console is in "communications interface" mode.   A packet
   is of this form:

   start of packet flag (one byte: 0xdc)
   packet type (one byte)
   length (low byte)
   length (high byte)
   data (length bytes)

   The last two bytes of the data field are a checksum, but we don't
   bother to verify it.
 */

static void
ignore_packet (void)
{
  int c = -1;
  int len;

  /* Ignore lots of trash (messages about section addresses, for example)
     until we see the start of a packet.  */
  for (len = 0; len < 256; len++)
    {
      c = debug_readchar (0);
      if (c == PESC)
	break;
    }
  if (len == 8)
    error (_("Packet header byte not found; %02x seen instead."), c);

  /* Read the packet type and length.  */
  c = debug_readchar (1);	/* type */

  c = debug_readchar (1);	/* low byte of length */
  len = c & 0xff;

  c = debug_readchar (1);	/* high byte of length */
  len += (c & 0xff) << 8;

  /* Ignore the rest of the packet.  */
  while (len-- > 0)
    c = debug_readchar (1);
}


/* Encapsulate some data into a packet and send it to the monitor.

   The 'p' packet is a special case.  This is a packet we send
   in response to a read ('r') packet from the monitor.  This function
   appends a one-byte sequence number to the data field of such a packet.
 */

static void
send_packet (char type, unsigned char *buf, int buflen, int seq)
{
  unsigned char hdr[4];
  int len = buflen;
  int sum, i;

  /* If this is a 'p' packet, add one byte for a sequence number.  */
  if (type == 'p')
    len++;

  /* If the buffer has a non-zero length, add two bytes for a checksum.  */
  if (len > 0)
    len += 2;

  /* Write the packet header.  */
  hdr[0] = PESC;
  hdr[1] = type;
  hdr[2] = len & 0xff;
  hdr[3] = (len >> 8) & 0xff;
  debug_write (hdr, sizeof (hdr));

  if (len)
    {
      /* Write the packet data.  */
      debug_write (buf, buflen);

      /* Write the sequence number if this is a 'p' packet.  */
      if (type == 'p')
	{
	  hdr[0] = seq;
	  debug_write (hdr, 1);
	}

      /* Write the checksum.  */
      sum = 0;
      for (i = 0; i < buflen; i++)
	{
	  int tmp = (buf[i] & 0xff);
	  if (i & 1)
	    sum += tmp;
	  else
	    sum += tmp << 8;
	}
      if (type == 'p')
	{
	  if (buflen & 1)
	    sum += (seq & 0xff);
	  else
	    sum += (seq & 0xff) << 8;
	}
      sum = (sum & 0xffff) + ((sum >> 16) & 0xffff);
      sum += (sum >> 16) & 1;
      sum = ~sum;

      hdr[0] = (sum >> 8) & 0xff;
      hdr[1] = sum & 0xff;
      debug_write (hdr, 2);
    }
}


/* Respond to an expected read request from the monitor by sending
   data in chunks.  Handle all acknowledgements and handshaking packets.

   The monitor expects a response consisting of a one or more 'p' packets,
   each followed by a portion of the data requested.  The 'p' packet
   contains only a four-byte integer, the value of which is the number
   of bytes of data we are about to send.  Following the 'p' packet,
   the monitor expects the data bytes themselves in raw, unpacketized,
   form, without even a checksum.
 */

static void
process_read_request (unsigned char *buf, int buflen)
{
  unsigned char len[4];
  int i, chunk;
  unsigned char seq;

  /* Discard the read request.  FIXME: we have to hope it's for
     the exact number of bytes we want to send; should check for this.  */
  ignore_packet ();

  for (i = chunk = 0, seq = 0; i < buflen; i += chunk, seq++)
    {
      /* Don't send more than MAXPSIZE bytes at a time.  */
      chunk = buflen - i;
      if (chunk > MAXPSIZE)
	chunk = MAXPSIZE;

      /* Write a packet containing the number of bytes we are sending.  */
      write_long_le (len, chunk);
      send_packet ('p', len, sizeof (len), seq);

      /* Write the data in raw form following the packet.  */
      debug_write (&buf[i], chunk);

      /* Discard the ACK packet.  */
      ignore_packet ();
    }

  /* Send an "end of data" packet.  */
  send_packet ('e', "", 0, 0);
}


/* Count loadable sections (helper function for r3900_load).  */

static void
count_section (bfd *abfd, asection *s, unsigned int *section_count)
{
  if (s->flags & SEC_LOAD && bfd_section_size (abfd, s) != 0)
    (*section_count)++;
}


/* Load a single BFD section (helper function for r3900_load).

   WARNING: this code is filled with assumptions about how
   the Densan monitor loads programs.  The monitor issues
   packets containing read requests, but rather than respond
   to them in an general way, we expect them to following
   a certain pattern.

   For example, we know that the monitor will start loading by
   issuing an 8-byte read request for the binary file header.
   We know this is coming and ignore the actual contents
   of the read request packet.
 */

static void
load_section (bfd *abfd, asection *s, unsigned int *data_count)
{
  if (s->flags & SEC_LOAD)
    {
      bfd_size_type section_size = bfd_section_size (abfd, s);
      bfd_vma section_base = bfd_section_lma (abfd, s);
      unsigned char *buffer;
      unsigned char header[8];

      /* Don't output zero-length sections.  */
      if (section_size == 0)
	return;
      if (data_count)
	*data_count += section_size;

      /* Print some fluff about the section being loaded.  */
      printf_filtered ("Loading section %s, size 0x%lx lma ",
		       bfd_section_name (abfd, s), (long) section_size);
      deprecated_print_address_numeric (section_base, 1, gdb_stdout);
      printf_filtered ("\n");
      gdb_flush (gdb_stdout);

      /* Write the section header (location and size).  */
      write_long (&header[0], (long) section_base);
      write_long (&header[4], (long) section_size);
      process_read_request (header, sizeof (header));

      /* Read the section contents into a buffer, write it out,
         then free the buffer.  */
      buffer = (unsigned char *) xmalloc (section_size);
      bfd_get_section_contents (abfd, s, buffer, 0, section_size);
      process_read_request (buffer, section_size);
      xfree (buffer);
    }
}


/* When the ethernet is used as the console port on the Densan board,
   we can use the "Rm" command to do a fast binary load.  The format
   of the download data is:

   number of sections (4 bytes)
   starting address (4 bytes)
   repeat for each section:
   location address (4 bytes)
   section size (4 bytes)
   binary data

   The 4-byte fields are all in big-endian order.

   Using this command is tricky because we have to put the monitor
   into a special funky "communications interface" mode, in which
   it sends and receives packets of data along with the normal prompt.
 */

static void
r3900_load (char *filename, int from_tty)
{
  bfd *abfd;
  unsigned int data_count = 0;
  time_t start_time, end_time;	/* for timing of download */
  int section_count = 0;
  unsigned char buffer[8];

  /* If we are not using the ethernet, use the normal monitor load,
     which sends S-records over the serial link.  */
  if (!ethernet)
    {
      orig_monitor_load (filename, from_tty);
      return;
    }

  /* Open the file.  */
  if (filename == NULL || filename[0] == 0)
    filename = get_exec_file (1);
  abfd = bfd_openr (filename, 0);
  if (!abfd)
    error (_("Unable to open file %s."), filename);
  if (bfd_check_format (abfd, bfd_object) == 0)
    error (_("File is not an object file."));

  /* Output the "vconsi" command to get the monitor in the communication
     state where it will accept a load command.  This will cause
     the monitor to emit a packet before each prompt, so ignore the packet.  */
  monitor_printf ("vconsi\r");
  ignore_packet ();
  monitor_expect_prompt (NULL, 0);

  /* Output the "Rm" (load) command and respond to the subsequent "open"
     packet by sending an ACK packet.  */
  monitor_printf ("Rm\r");
  ignore_packet ();
  send_packet ('a', "", 0, 0);

  /* Output the fast load header (number of sections and starting address).  */
  bfd_map_over_sections ((bfd *) abfd, (section_map_func) count_section,
			 &section_count);
  write_long (&buffer[0], (long) section_count);
  if (exec_bfd)
    write_long (&buffer[4], (long) bfd_get_start_address (exec_bfd));
  else
    write_long (&buffer[4], 0);
  process_read_request (buffer, sizeof (buffer));

  /* Output the section data.  */
  start_time = time (NULL);
  bfd_map_over_sections (abfd, (section_map_func) load_section, &data_count);
  end_time = time (NULL);

  /* Acknowledge the close packet and put the monitor back into
     "normal" mode so it won't send packets any more.  */
  ignore_packet ();
  send_packet ('a', "", 0, 0);
  monitor_expect_prompt (NULL, 0);
  monitor_printf ("vconsx\r");
  monitor_expect_prompt (NULL, 0);

  /* Print start address and download performance information.  */
  printf_filtered ("Start address 0x%lx\n", (long) bfd_get_start_address (abfd));
  report_transfer_performance (data_count, start_time, end_time);

  /* Finally, make the PC point at the start address */
  if (exec_bfd)
    write_pc (bfd_get_start_address (exec_bfd));

  inferior_ptid = null_ptid;		/* No process now */

  /* This is necessary because many things were based on the PC at the
     time that we attached to the monitor, which is no longer valid
     now that we have loaded new code (and just changed the PC).
     Another way to do this might be to call normal_stop, except that
     the stack may not be valid, and things would get horribly
     confused... */
  clear_symtab_users ();
}


/* Commands to send to the monitor when first connecting:
   * The bare carriage return forces a prompt from the monitor
   (monitor doesn't prompt immediately after a reset).
   * The "vconsx" switches the monitor back to interactive mode
   in case an aborted download had left it in packet mode.
   * The "Xtr" command causes subsequent "t" (trace) commands to display
   the general registers only.
   * The "Xxr" command does the same thing for the "x" (examine
   registers) command.
   * The "bx" command clears all breakpoints.
 */

static char *r3900_inits[] =
{"\r", "vconsx\r", "Xtr\r", "Xxr\r", "bx\r", NULL};
static char *dummy_inits[] =
{NULL};

static struct target_ops r3900_ops;
static struct monitor_ops r3900_cmds;

static void
r3900_open (char *args, int from_tty)
{
  char buf[64];
  int i;

  monitor_open (args, &r3900_cmds, from_tty);

  /* We have to handle sending the init strings ourselves, because
     the first two strings we send (carriage returns) may not be echoed
     by the monitor, but the rest will be.  */
  monitor_printf_noecho ("\r\r");
  for (i = 0; r3900_inits[i] != NULL; i++)
    {
      monitor_printf (r3900_inits[i]);
      monitor_expect_prompt (NULL, 0);
    }

  /* Attempt to determine whether the console device is ethernet or serial.
     This will tell us which kind of load to use (S-records over a serial
     link, or the Densan fast binary multi-section format over the net).  */

  ethernet = 0;
  monitor_printf ("v\r");
  if (monitor_expect ("console device :", NULL, 0) != -1)
    if (monitor_expect ("\n", buf, sizeof (buf)) != -1)
      if (strstr (buf, "ethernet") != NULL)
	ethernet = 1;
  monitor_expect_prompt (NULL, 0);
}

void
_initialize_r3900_rom (void)
{
  r3900_cmds.flags = MO_NO_ECHO_ON_OPEN |
    MO_ADDR_BITS_REMOVE |
    MO_CLR_BREAK_USES_ADDR |
    MO_GETMEM_READ_SINGLE |
    MO_PRINT_PROGRAM_OUTPUT;

  r3900_cmds.init = dummy_inits;
  r3900_cmds.cont = "g\r";
  r3900_cmds.step = "t\r";
  r3900_cmds.set_break = "b %A\r";	/* COREADDR */
  r3900_cmds.clr_break = "b %A,0\r";	/* COREADDR */
  r3900_cmds.fill = "fx %A s %x %x\r";	/* COREADDR, len, val */

  r3900_cmds.setmem.cmdb = "sx %A %x\r";	/* COREADDR, val */
  r3900_cmds.setmem.cmdw = "sh %A %x\r";	/* COREADDR, val */
  r3900_cmds.setmem.cmdl = "sw %A %x\r";	/* COREADDR, val */

  r3900_cmds.getmem.cmdb = "sx %A\r";	/* COREADDR */
  r3900_cmds.getmem.cmdw = "sh %A\r";	/* COREADDR */
  r3900_cmds.getmem.cmdl = "sw %A\r";	/* COREADDR */
  r3900_cmds.getmem.resp_delim = " : ";
  r3900_cmds.getmem.term = " ";
  r3900_cmds.getmem.term_cmd = ".\r";

  r3900_cmds.setreg.cmd = "x%s %x\r";	/* regname, val */

  r3900_cmds.getreg.cmd = "x%s\r";	/* regname */
  r3900_cmds.getreg.resp_delim = "=";
  r3900_cmds.getreg.term = " ";
  r3900_cmds.getreg.term_cmd = ".\r";

  r3900_cmds.dump_registers = "x\r";
  r3900_cmds.register_pattern =
    "\\([a-zA-Z0-9_]+\\) *=\\([0-9a-f]+ [0-9a-f]+\\b\\)";
  r3900_cmds.supply_register = r3900_supply_register;
  /* S-record download, via "keyboard port".  */
  r3900_cmds.load = "r0\r";
  r3900_cmds.prompt = "#";
  r3900_cmds.line_term = "\r";
  r3900_cmds.target = &r3900_ops;
  r3900_cmds.stopbits = SERIAL_1_STOPBITS;
  r3900_cmds.regnames = r3900_regnames;
  r3900_cmds.magic = MONITOR_OPS_MAGIC;

  init_monitor_ops (&r3900_ops);

  r3900_ops.to_shortname = "r3900";
  r3900_ops.to_longname = "R3900 monitor";
  r3900_ops.to_doc = "Debug using the DVE R3900 monitor.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  r3900_ops.to_open = r3900_open;

  /* Override the functions to fetch and store registers.  But save the
     addresses of the default functions, because we will use those functions
     for "normal" registers.  */

  orig_monitor_fetch_registers = r3900_ops.to_fetch_registers;
  orig_monitor_store_registers = r3900_ops.to_store_registers;
  r3900_ops.to_fetch_registers = r3900_fetch_registers;
  r3900_ops.to_store_registers = r3900_store_registers;

  /* Override the load function, but save the address of the default
     function to use when loading S-records over a serial link.  */
  orig_monitor_load = r3900_ops.to_load;
  r3900_ops.to_load = r3900_load;

  add_target (&r3900_ops);
}
@


1.20
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@@


1.19
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	* utils.c (paddress): New function.
	* defs.h (paddress): Declare.
	* printcmd.c (deprecated_print_address_numeric): Rename
	print_address_numeric, call paddress.
	* valprint.c, ui-out.c, tui/tui-stack.c, tracepoint.c: Update.
	* symmisc.c, symfile.c stack.c, p-valprint.c, printcmd.c: Update.
	* maint.c, m32r-rom.c, infcmd.c, f-valprint.c, exec.c: Update.
	* dwarf2read.c, dve3900-rom.c, defs.h, c-valprint.c: Update.
	* corefile.c, cli/cli-cmds.c, breakpoint.c, annotate.c: Update.
	* ada-valprint.c: Update.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.18
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d829 1
a829 1
      print_address_numeric (section_base, 1, gdb_stdout);
@


1.17
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d464 1
a464 1
                    "fetch_bitmapped_register: regno out of bounds");
d511 1
a511 1
                    "fetch_bitmapped_register: regno out of bounds");
@


1.16
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d655 1
a655 1
    error ("Packet header byte not found; %02x seen instead.", c);
d888 1
a888 1
    error ("Unable to open file %s\n", filename);
d890 1
a890 1
    error ("File is not an object file\n");
@


1.15
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d475 1
a475 1
  store_unsigned_integer (regbuf, DEPRECATED_REGISTER_RAW_SIZE (regno), val);
@


1.14
log
@2003-11-16  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (struct gdbarch_tdep): Add field "regnum".
	(mips_fpa0_regnum, mips_regnum): New function.
	(mips_gdbarch_init): Fill in the "regnum" fields.
	* mips-tdep.h (struct mips_regnum): Define.
	(mips_regnum): Declare.
	* config/mips/tm-mips.h (BADVADDR_REGNUM): Delete macro.
	(LO_REGNUM, HI_REGNUM, BADVADDR_REGNUM): Ditto.
	(CAUSE_REGNUM, PC_REGNUM, FP0_REGNUM): Ditto.
	(FCRCS_REGNUM, FCRIR_REGNUM, FPA0_REGNUM): Ditto.
	* config/mips/tm-irix6.h (FP0_REGNUM): Delete macro.
	(PC_REGNUM, CAUSE_REGNUM, BADVADDR_REGNUM): Ditto.
	(HI_REGNUM, LO_REGNUM, FCRCS_REGNUM, FCRIR_REGNUM): Ditto.
	* config/mips/tm-irix5.h (FP0_REGNUM): Delete macro.
	(PC_REGNUM, CAUSE_REGNUM, BADVADDR_REGNUM): Ditto.
	(HI_REGNUM, LO_REGNUM, FCRCS_REGNUM, FCRIR_REGNUM): Ditto.
	* remote-mips.c: Include "mips-tdep.h".  Update.
	* mipsnbsd-tdep.c: Update.
	* mipsv4-nat.c: Update.
	* mips-tdep.c: Update.
	* mips-nat.c: Update.
	* mips-linux-tdep.c: Update.
	* mips-linux-nat.c: Update.
	* irix5-nat.c: Update.
	* dve3900-rom.c: Include "mips-tdep.h".  Update.
	(ignore_packet): Supress GCC warning.
	* config/mips/nm-riscos.h: Update.
	* Makefile.in (dve3900-rom.o, remote-mips.o): Update dependencies.
@
text
@d476 1
a476 1
  supply_register (regno, regbuf);
@


1.14.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d475 2
a476 2
  store_unsigned_integer (regbuf, register_size (current_gdbarch, regno), val);
  regcache_raw_supply (current_regcache, regno, regbuf);
@


1.13
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d32 1
d125 5
a129 5
  "l",				/* LO_REGNUM */
  "h",				/* HI_REGNUM */
  "B",				/* BADVADDR_REGNUM */
  "Pcause",			/* CAUSE_REGNUM */
  "p"				/* PC_REGNUM */
d271 1
a271 1
    "HI", HI_REGNUM
d275 1
a275 1
    "LO", LO_REGNUM
d279 1
a279 1
    "PC", PC_REGNUM
d283 1
a283 1
    "BadV", BADVADDR_REGNUM
d424 1
a424 1
  monitor_supply_register (BADVADDR_REGNUM, buf);
d489 9
a497 14
  switch (regno)
    {
    case BADVADDR_REGNUM:
      fetch_bad_vaddr ();
      return;
    case PS_REGNUM:
      fetch_bitmapped_register (PS_REGNUM, status_fields);
      return;
    case CAUSE_REGNUM:
      fetch_bitmapped_register (CAUSE_REGNUM, cause_fields);
      return;
    default:
      orig_monitor_fetch_registers (regno);
    }
d543 7
a549 11
  switch (regno)
    {
    case PS_REGNUM:
      store_bitmapped_register (PS_REGNUM, status_fields);
      return;
    case CAUSE_REGNUM:
      store_bitmapped_register (CAUSE_REGNUM, cause_fields);
      return;
    default:
      orig_monitor_store_registers (regno);
    }
d643 1
a643 1
  int c;
@


1.12
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (max_register_size): Delete declaration.
	* regcache.c (max_register_size): Delete function.
	(struct regcache_descr): Delete field "max_register_size".
	(init_regcache_descr, init_legacy_regcache_descr): Assert that all
	registers fit in MAX_REGISTER_SIZE.
	(regcache_save): Replace max_register_size with MAX_REGISTER_SIZE.
	(regcache_restore, regcache_xfer_part, regcache_dump): Ditto.
	* thread-db.c: Replace max_register_size with MAX_REGISTER_SIZE.
	* sh-tdep.c, rom68k-rom.c, remote-sim.c, remote-mips.c: Ditto.
	* remote-e7000.c, monitor.c, mipsv4-nat.c, mips-nat.c: Ditto.
	* m68klinux-nat.c, lynx-nat.c, irix4-nat.c: Ditto.
	* hpux-thread.c, hppah-nat.c, hppab-nat.c, hppa-tdep.c: Ditto.
	* dve3900-rom.c, hppa-tdep.c: Ditto.
@
text
@d474 1
a474 1
  store_unsigned_integer (regbuf, REGISTER_RAW_SIZE (regno), val);
@


1.11
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* mips-nat.c (zerobuf): Delete.
	(fetch_inferior_registers): Alloc local zerobuf.
	(fetch_core_registers): Alloc local zerobuf.
	* d10v-tdep.c (show_regs): Don't allocate a dynamic array using
	MAX_REGISTER_RAW_SIZE or MAX_REGISTER_VIRTUAL_SIZE.
	* thread-db.c (thread_db_store_registers): Ditto.
	* sh-tdep.c (sh_do_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote-sim.c (gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* monitor.c (monitor_supply_register): Ditto.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	* m68klinux-nat.c (fetch_register): Ditto.
	* lynx-nat.c (fetch_inferior_registers): Ditto.
	(fetch_inferior_registers): Ditto.
	* irix4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (fetch_register): Ditto.
	* hppab-nat.c (fetch_register): Ditto.
	* hppa-tdep.c (pa_register_look_aside): Ditto.
	(pa_print_fp_reg, pa_strcat_fp_reg): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register): Ditto.
@
text
@d458 1
a458 1
  unsigned char *regbuf = alloca (max_register_size (current_gdbarch));
@


1.11.18.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d458 1
a458 1
  unsigned char regbuf[MAX_REGISTER_SIZE];
@


1.10
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d458 1
a458 1
  unsigned char regbuf[MAX_REGISTER_RAW_SIZE];
@


1.9
log
@Don't use NUM_REGS to determine array size.
@
text
@d35 1
a35 1
typedef void (*section_map_func) (bfd * abfd, asection * sect, PTR obj);
@


1.8
log
@Phase 1 of the ptid_t changes.
@
text
@d116 1
a116 1
static char *r3900_regnames[NUM_REGS] =
d459 1
d461 7
a467 1
  monitor_printf ("x%s\r", r3900_regnames[regno]);
d511 7
d520 1
a520 1
  monitor_printf ("x%s\r", r3900_regnames[regno]);
@


1.8.26.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a31 1
#include "mips-tdep.h"
d35 1
a35 1
typedef void (*section_map_func) (bfd * abfd, asection * sect, void *obj);
d116 1
a116 1
static char *r3900_regnames[] =
d124 5
a128 5
  "l",				/* MIPS_EMBED_LO_REGNUM */
  "h",				/* MIPS_EMBED_HI_REGNUM */
  "B",				/* MIPS_EMBED_BADVADDR_REGNUM */
  "Pcause",			/* MIPS_EMBED_CAUSE_REGNUM */
  "p"				/* MIPS_EMBED_PC_REGNUM */
d270 1
a270 1
    "HI", MIPS_EMBED_HI_REGNUM
d274 1
a274 1
    "LO", MIPS_EMBED_LO_REGNUM
d278 1
a278 1
    "PC", MIPS_EMBED_PC_REGNUM
d282 1
a282 1
    "BadV", MIPS_EMBED_BADVADDR_REGNUM
d423 1
a423 1
  monitor_supply_register (mips_regnum (current_gdbarch)->badvaddr, buf);
d458 1
a458 2
  unsigned char regbuf[MAX_REGISTER_SIZE];
  char *regname = NULL;
d460 1
a460 7
  if (regno >= sizeof (r3900_regnames) / sizeof (r3900_regnames[0]))
    internal_error (__FILE__, __LINE__,
                    "fetch_bitmapped_register: regno out of bounds");
  else
    regname = r3900_regnames[regno];

  monitor_printf ("x%s\r", regname);
d467 1
a467 1
  store_unsigned_integer (regbuf, DEPRECATED_REGISTER_RAW_SIZE (regno), val);
d481 14
a494 9
  if (regno == mips_regnum (current_gdbarch)->badvaddr)
    fetch_bad_vaddr ();
  else if (regno == PS_REGNUM)
    fetch_bitmapped_register (PS_REGNUM, status_fields);
  else if (regno == mips_regnum (current_gdbarch)->cause)
    fetch_bitmapped_register (mips_regnum (current_gdbarch)->cause,
			      cause_fields);
  else
    orig_monitor_fetch_registers (regno);
a503 7
  char *regname = NULL;

  if (regno >= sizeof (r3900_regnames) / sizeof (r3900_regnames[0]))
    internal_error (__FILE__, __LINE__,
                    "fetch_bitmapped_register: regno out of bounds");
  else
    regname = r3900_regnames[regno];
d506 1
a506 1
  monitor_printf ("x%s\r", regname);
d533 11
a543 7
  if (regno == PS_REGNUM)
    store_bitmapped_register (PS_REGNUM, status_fields);
  else if (regno == mips_regnum (current_gdbarch)->cause)
    store_bitmapped_register (mips_regnum (current_gdbarch)->cause,
			      cause_fields);
  else
    orig_monitor_store_registers (regno);
d637 1
a637 1
  int c = -1;
@


1.8.24.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d116 1
a116 1
static char *r3900_regnames[] =
a458 1
  char *regname = NULL;
d460 1
a460 7
  if (regno >= sizeof (r3900_regnames) / sizeof (r3900_regnames[0]))
    internal_error (__FILE__, __LINE__,
                    "fetch_bitmapped_register: regno out of bounds");
  else
    regname = r3900_regnames[regno];

  monitor_printf ("x%s\r", regname);
a503 7
  char *regname = NULL;

  if (regno >= sizeof (r3900_regnames) / sizeof (r3900_regnames[0]))
    internal_error (__FILE__, __LINE__,
                    "fetch_bitmapped_register: regno out of bounds");
  else
    regname = r3900_regnames[regno];
d506 1
a506 1
  monitor_printf ("x%s\r", regname);
@


1.8.24.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d35 1
a35 1
typedef void (*section_map_func) (bfd * abfd, asection * sect, void *obj);
d458 1
a458 1
  unsigned char *regbuf = alloca (max_register_size (current_gdbarch));
@


1.8.24.3
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d458 1
a458 1
  unsigned char regbuf[MAX_REGISTER_SIZE];
@


1.8.24.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d474 1
a474 1
  store_unsigned_integer (regbuf, DEPRECATED_REGISTER_RAW_SIZE (regno), val);
@


1.8.24.5
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a31 1
#include "mips-tdep.h"
d124 5
a128 5
  "l",				/* MIPS_EMBED_LO_REGNUM */
  "h",				/* MIPS_EMBED_HI_REGNUM */
  "B",				/* MIPS_EMBED_BADVADDR_REGNUM */
  "Pcause",			/* MIPS_EMBED_CAUSE_REGNUM */
  "p"				/* MIPS_EMBED_PC_REGNUM */
d270 1
a270 1
    "HI", MIPS_EMBED_HI_REGNUM
d274 1
a274 1
    "LO", MIPS_EMBED_LO_REGNUM
d278 1
a278 1
    "PC", MIPS_EMBED_PC_REGNUM
d282 1
a282 1
    "BadV", MIPS_EMBED_BADVADDR_REGNUM
d423 1
a423 1
  monitor_supply_register (mips_regnum (current_gdbarch)->badvaddr, buf);
d488 14
a501 9
  if (regno == mips_regnum (current_gdbarch)->badvaddr)
    fetch_bad_vaddr ();
  else if (regno == PS_REGNUM)
    fetch_bitmapped_register (PS_REGNUM, status_fields);
  else if (regno == mips_regnum (current_gdbarch)->cause)
    fetch_bitmapped_register (mips_regnum (current_gdbarch)->cause,
			      cause_fields);
  else
    orig_monitor_fetch_registers (regno);
d547 11
a557 7
  if (regno == PS_REGNUM)
    store_bitmapped_register (PS_REGNUM, status_fields);
  else if (regno == mips_regnum (current_gdbarch)->cause)
    store_bitmapped_register (mips_regnum (current_gdbarch)->cause,
			      cause_fields);
  else
    orig_monitor_store_registers (regno);
d651 1
a651 1
  int c = -1;
@


1.7
log
@Update/correct copyright notices.
@
text
@d930 1
a930 1
  inferior_pid = 0;		/* No process now */
@


1.6
log
@Create new file regcache.h.  Update all uses.
@
text
@d3 1
a3 1
   Copyright 1997, 2001 Free Software Foundation, Inc.
@


1.5
log
@Replace free() with xfree().
@
text
@d3 1
a3 1
   Copyright 1997 Free Software Foundation, Inc.
d31 1
@


1.4
log
@Protoization.
@
text
@d836 1
a836 1
      free (buffer);
@


1.3
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d376 1
a376 5
r3900_supply_register (regname, regnamelen, val, vallen)
     char *regname;
     int regnamelen;
     char *val;
     int vallen;
d415 1
a415 1
fetch_bad_vaddr ()
d430 1
a430 2
fetch_fields (bf)
     struct bit_field *bf;
d454 1
a454 3
fetch_bitmapped_register (regno, bf)
     int regno;
     struct bit_field *bf;
d478 1
a478 2
r3900_fetch_registers (regno)
     int regno;
d500 1
a500 3
store_bitmapped_register (regno, bf)
     int regno;
     struct bit_field *bf;
d530 1
a530 2
r3900_store_registers (regno)
     int regno;
d549 1
a549 3
write_long (buf, n)
     char *buf;
     long n;
d561 1
a561 3
write_long_le (buf, n)
     char *buf;
     long n;
d575 1
a575 2
debug_readchar (hex)
     int hex;
d601 1
a601 3
debug_write (buf, buflen)
     unsigned char *buf;
     int buflen;
d634 1
a634 1
ignore_packet ()
d673 1
a673 4
send_packet (type, buf, buflen, seq)
     char type;
     unsigned char *buf;
     int buflen, seq;
d746 1
a746 3
process_read_request (buf, buflen)
     unsigned char *buf;
     int buflen;
d782 1
a782 4
count_section (abfd, s, section_count)
     bfd *abfd;
     asection *s;
     unsigned int *section_count;
d804 1
a804 4
load_section (abfd, s, data_count)
     bfd *abfd;
     asection *s;
     unsigned int *data_count;
d860 1
a860 3
r3900_load (filename, from_tty)
     char *filename;
     int from_tty;
d962 1
a962 3
r3900_open (args, from_tty)
     char *args;
     int from_tty;
d993 1
a993 1
_initialize_r3900_rom ()
@


1.2
log
@PARAMS removal.
@
text
@d34 1
a34 1
typedef void (*section_map_func) PARAMS ((bfd * abfd, asection * sect, PTR obj));
d98 2
a99 2
static void (*orig_monitor_fetch_registers) PARAMS ((int regno));
static void (*orig_monitor_store_registers) PARAMS ((int regno));
d104 1
a104 1
static void (*orig_monitor_load) PARAMS ((char *file, int from_tty));
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d34 1
a34 1
typedef void (*section_map_func) PARAMS ((bfd *abfd, asection *sect, PTR obj));
d47 1
a47 2
extern void report_transfer_performance PARAMS ((unsigned long,
						 time_t, time_t));
d54 8
a61 8
{
  char *prefix;		/* string appearing before the value */
  char *suffix;		/* string appearing after the value */
  char *user_name;	/* name used by human when entering field value */
  int  length;		/* number of bits in the field */
  int  start;		/* starting (least significant) bit number of field */
};
        
d64 8
a71 10
static void r3900_supply_register PARAMS ((char *regname, int regnamelen,
					   char *val, int vallen));
static void fetch_bad_vaddr PARAMS ((void));
static unsigned long fetch_fields PARAMS ((struct bit_field *bf));
static void fetch_bitmapped_register PARAMS ((int regno,
						   struct bit_field *bf));
static void r3900_fetch_registers PARAMS ((int regno));
static void store_bitmapped_register PARAMS ((int regno,
						    struct bit_field *bf));
static void r3900_store_registers PARAMS ((int regno));
d75 11
a85 13
static void write_long PARAMS ((char *buf, long n));
static void write_long_le PARAMS ((char *buf, long n));
static int  debug_readchar PARAMS ((int hex));
static void debug_write PARAMS ((unsigned char *buf, int buflen));
static void ignore_packet PARAMS ((void));
static void send_packet PARAMS ((char type, unsigned char *buf, int buflen,
				 int seq));
static void process_read_request PARAMS ((unsigned char *buf, int buflen));
static void count_section PARAMS ((bfd *abfd, asection *s,
				   unsigned int *section_count));
static void load_section PARAMS ((bfd *abfd, asection *s,
				  unsigned int *data_count));
static void r3900_load PARAMS ((char *filename, int from_tty));
d89 1
a89 1
static void r3900_open PARAMS ((char *args, int from_tty));
d117 11
a127 11
  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
  "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",
  "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",

  "S", 		/* PS_REGNUM */
  "l",		/* LO_REGNUM */
  "h",		/* HI_REGNUM */
  "B",		/* BADVADDR_REGNUM */
  "Pcause",	/* CAUSE_REGNUM */
  "p"		/* PC_REGNUM */
d134 5
d140 147
a286 17
  char *name;
  int regno;
} reg_table[] =
{
  { "r0_zero", 0 },  { "r1_at",   1 },  { "r2_v0",   2 },  { "r3_v1",   3 },
  { "r4_a0",   4 },  { "r5_a1",   5 },  { "r6_a2",   6 },  { "r7_a3",   7 },
  { "r8_t0",   8 },  { "r9_t1",   9 },  { "r10_t2", 10 },  { "r11_t3", 11 },
  { "r12_t4", 12 },  { "r13_t5", 13 },  { "r14_t6", 14 },  { "r15_t7", 15 },
  { "r16_s0", 16 },  { "r17_s1", 17 },  { "r18_s2", 18 },  { "r19_s3", 19 },
  { "r20_s4", 20 },  { "r21_s5", 21 },  { "r22_s6", 22 },  { "r23_s7", 23 },
  { "r24_t8", 24 },  { "r25_t9", 25 },  { "r26_k0", 26 },  { "r27_k1", 27 },
  { "r28_gp", 28 },  { "r29_sp", 29 },  { "r30_fp", 30 },  { "r31_ra", 31 },
  { "HI",     HI_REGNUM },
  { "LO",     LO_REGNUM },
  { "PC",     PC_REGNUM },
  { "BadV",   BADVADDR_REGNUM },
  { NULL,     0 }
d296 1
a296 1
static struct bit_field status_fields [] =
d299 13
a311 13
  { "SR[<CU=",	" ",	"cu",	4, 28 },
  { "RE=",	" ",	"re",	1, 25 },
  { "BEV=",	" ",	"bev",	1, 22 },
  { "TS=",	" ",	"ts",	1, 21 },
  { "Nmi=",	" ",	"nmi",	1, 20 },
  { "INT=",	" ",	"int",  6, 10 },
  { "SW=",	">]",	"sw",   2,  8 },
  { "[<KUO=",	" ",	"kuo",  1,  5 },
  { "IEO=",	" ",	"ieo",  1,  4 },
  { "KUP=",	" ",	"kup",  1,  3 },
  { "IEP=",	" ",	"iep",  1,  2 },
  { "KUC=",	" ",	"kuc",  1,  1 },
  { "IEC=",	">]",	"iec",  1,  0 },
d314 6
a319 6
  { "CR[<IalO="," ",	"ialo",	0, 13 },
  { "DalO=",	" ",	"dalo",	0, 12 },
  { "IalP=",	" ",	"ialp",	0, 11 },
  { "DalP=",	" ",	"dalp",	0, 10 },
  { "IalC=",	" ",	"ialc",	0,  9 },
  { "DalC=",	">] ",	"dalc",	0,  8 },
d321 1
a321 1
  { NULL,	NULL,	0,  0 }		/* end of table marker */
d325 2
a326 2
#if 0	/* FIXME: Enable when we add support for modifying cache register.  */
static struct bit_field cache_fields [] =
d329 13
a341 13
  { "SR[<CU=",	" ",	"cu",	0, 28 },
  { "RE=",	" ",	"re",	0, 25 },
  { "BEV=",	" ",	"bev",	0, 22 },
  { "TS=",	" ",	"ts",	0, 21 },
  { "Nmi=",	" ",	"nmi",	0, 20 },
  { "INT=",	" ",	"int",  0, 10 },
  { "SW=",	">]",	"sw",   0,  8 },
  { "[<KUO=",	" ",	"kuo",  0,  5 },
  { "IEO=",	" ",	"ieo",  0,  4 },
  { "KUP=",	" ",	"kup",  0,  3 },
  { "IEP=",	" ",	"iep",  0,  2 },
  { "KUC=",	" ",	"kuc",  0,  1 },
  { "IEC=",	">]",	"iec",  0,  0 },
d344 6
a349 6
  { "CR[<IalO="," ",	"ialo",	1, 13 },
  { "DalO=",	" ",	"dalo",	1, 12 },
  { "IalP=",	" ",	"ialp",	1, 11 },
  { "DalP=",	" ",	"dalp",	1, 10 },
  { "IalC=",	" ",	"ialc",	1,  9 },
  { "DalC=",	">] ",	"dalc",	1,  8 },
d351 1
a351 1
  { NULL,	NULL,	NULL,	0,  0 }		/* end of table marker */
d356 1
a356 1
static struct bit_field cause_fields[] = 
d358 5
a362 5
  { "<BD=",	" ",	"bd",   1, 31 },
  { "CE=",	" ",	"ce",   2, 28 },
  { "IP=",	" ",	"ip",   6, 10 },
  { "SW=", 	" ",	"sw",   2,  8 },
  { "EC=", 	">]" ,	"ec",   5,  2 },
d364 1
a364 1
  { NULL,	NULL,	NULL,	0,  0 }		/* end of table marker */
d370 1
a370 1
	regname = xxxx xxxx
d419 1
a419 1
fetch_bad_vaddr()
d425 1
a425 1
  monitor_expect_prompt (buf, sizeof(buf));
d429 1
a429 1
    
d441 1
a441 1
  for ( ; bf->prefix != NULL; bf++)
d443 1
a443 1
      monitor_expect (bf->prefix, NULL, 0);		/* get prefix */
d446 1
a446 1
        {
d449 1
a449 1
	  val |= bits << bf->start;		/* insert into register */
d451 1
a451 1
	  
d520 1
a520 1
  for ( ; bf->prefix != NULL; bf++)
d523 1
a523 1
        {
d530 1
a530 1
	    monitor_printf ("%s %x ", bf->user_name, newbits);
d593 1
a593 1
  char buf [10];
d602 1
a602 1
      else 
d641 5
a645 5
      start of packet flag (one byte: 0xdc)
      packet type (one byte)
      length (low byte)
      length (high byte)
      data (length bytes)
d649 1
a649 1
*/
d655 1
a655 1
  int len;  
d669 1
a669 1
  c = debug_readchar (1);			/* type */
d671 1
a671 1
  c = debug_readchar (1);			/* low byte of length */
d674 1
a674 1
  c = debug_readchar (1);			/* high byte of length */
d688 1
a688 1
*/
d738 1
a738 1
        {
d746 1
a746 1
      sum = ~sum;  
d806 1
a806 1
     bfd      *abfd;
d822 1
a822 1
   
d827 1
a827 1
*/
d831 1
a831 1
     bfd      *abfd;
d838 1
a838 1
      bfd_vma       section_base = bfd_section_lma  (abfd, s);
d844 1
a844 1
        return;
d850 1
a850 1
		       bfd_section_name (abfd, s), (long)section_size);
d856 2
a857 2
      write_long (&header[0], (long)section_base);
      write_long (&header[4], (long)section_size);
d866 1
a866 1
  }
d874 6
a879 6
	number of sections (4 bytes)
	starting address (4 bytes)
	repeat for each section:
	    location address (4 bytes)
	    section size (4 bytes)
	    binary data
d889 3
a891 3
r3900_load (filename, from_tty) 
    char *filename;
    int from_tty;
d928 1
a928 1
  
d932 1
a932 1
  write_long (&buffer[0], (long)section_count);
d934 1
a934 1
    write_long (&buffer[4], (long)bfd_get_start_address (exec_bfd));
d953 1
a953 1
  printf_filtered ("Start address 0x%lx\n", (long)bfd_get_start_address (abfd));
d960 1
a960 1
  inferior_pid = 0;             /* No process now */
d973 10
a982 10
    * The bare carriage return forces a prompt from the monitor
      (monitor doesn't prompt immediately after a reset).
    * The "vconsx" switches the monitor back to interactive mode
      in case an aborted download had left it in packet mode.
    * The "Xtr" command causes subsequent "t" (trace) commands to display
      the general registers only.
    * The "Xxr" command does the same thing for the "x" (examine
      registers) command.
    * The "bx" command clears all breakpoints.
*/
d984 4
a987 2
static char *r3900_inits[] = {"\r", "vconsx\r", "Xtr\r", "Xxr\r", "bx\r", NULL};
static char *dummy_inits[] = { NULL };
d1019 3
a1021 3
      if (monitor_expect ("\n", buf, sizeof (buf)) != -1)
	if (strstr (buf, "ethernet") != NULL)
	  ethernet = 1;
d1029 4
a1032 4
		     MO_ADDR_BITS_REMOVE |
		     MO_CLR_BREAK_USES_ADDR |
		     MO_GETMEM_READ_SINGLE |
		     MO_PRINT_PROGRAM_OUTPUT;
d1037 3
a1039 3
  r3900_cmds.set_break = "b %A\r";		/* COREADDR */
  r3900_cmds.clr_break = "b %A,0\r";		/* COREADDR */
  r3900_cmds.fill = "fx %A s %x %x\r";		/* COREADDR, len, val */
d1045 3
a1047 3
  r3900_cmds.getmem.cmdb = "sx %A\r";		/* COREADDR */
  r3900_cmds.getmem.cmdw = "sh %A\r";		/* COREADDR */
  r3900_cmds.getmem.cmdl = "sw %A\r";		/* COREADDR */
d1052 1
a1052 1
  r3900_cmds.setreg.cmd = "x%s %x\r";		/* regname, val */
d1054 1
a1054 1
  r3900_cmds.getreg.cmd = "x%s\r";		/* regname */
d1061 1
a1061 1
	"\\([a-zA-Z0-9_]+\\) *=\\([0-9a-f]+ [0-9a-f]+\\b\\)";
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d33 1
a33 1
typedef void (*section_map_func) PARAMS ((bfd * abfd, asection * sect, PTR obj));
d54 8
a61 8
  {
    char *prefix;		/* string appearing before the value */
    char *suffix;		/* string appearing after the value */
    char *user_name;		/* name used by human when entering field value */
    int length;			/* number of bits in the field */
    int start;			/* starting (least significant) bit number of field */
  };

d67 1
a67 1
static unsigned long fetch_fields PARAMS ((struct bit_field * bf));
d69 1
a69 1
					      struct bit_field * bf));
d72 1
a72 1
					      struct bit_field * bf));
d79 1
a79 1
static int debug_readchar PARAMS ((int hex));
d85 1
a85 1
static void count_section PARAMS ((bfd * abfd, asection * s,
d87 1
a87 1
static void load_section PARAMS ((bfd * abfd, asection * s,
d121 11
a131 11
  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
  "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
  "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",

  "S",				/* PS_REGNUM */
  "l",				/* LO_REGNUM */
  "h",				/* HI_REGNUM */
  "B",				/* BADVADDR_REGNUM */
  "Pcause",			/* CAUSE_REGNUM */
  "p"				/* PC_REGNUM */
a137 5
  {
    char *name;
    int regno;
  }
reg_table[] =
d139 17
a155 147
  {
    "r0_zero", 0
  }
  ,
  {
    "r1_at", 1
  }
  ,
  {
    "r2_v0", 2
  }
  ,
  {
    "r3_v1", 3
  }
  ,
  {
    "r4_a0", 4
  }
  ,
  {
    "r5_a1", 5
  }
  ,
  {
    "r6_a2", 6
  }
  ,
  {
    "r7_a3", 7
  }
  ,
  {
    "r8_t0", 8
  }
  ,
  {
    "r9_t1", 9
  }
  ,
  {
    "r10_t2", 10
  }
  ,
  {
    "r11_t3", 11
  }
  ,
  {
    "r12_t4", 12
  }
  ,
  {
    "r13_t5", 13
  }
  ,
  {
    "r14_t6", 14
  }
  ,
  {
    "r15_t7", 15
  }
  ,
  {
    "r16_s0", 16
  }
  ,
  {
    "r17_s1", 17
  }
  ,
  {
    "r18_s2", 18
  }
  ,
  {
    "r19_s3", 19
  }
  ,
  {
    "r20_s4", 20
  }
  ,
  {
    "r21_s5", 21
  }
  ,
  {
    "r22_s6", 22
  }
  ,
  {
    "r23_s7", 23
  }
  ,
  {
    "r24_t8", 24
  }
  ,
  {
    "r25_t9", 25
  }
  ,
  {
    "r26_k0", 26
  }
  ,
  {
    "r27_k1", 27
  }
  ,
  {
    "r28_gp", 28
  }
  ,
  {
    "r29_sp", 29
  }
  ,
  {
    "r30_fp", 30
  }
  ,
  {
    "r31_ra", 31
  }
  ,
  {
    "HI", HI_REGNUM
  }
  ,
  {
    "LO", LO_REGNUM
  }
  ,
  {
    "PC", PC_REGNUM
  }
  ,
  {
    "BadV", BADVADDR_REGNUM
  }
  ,
  {
    NULL, 0
  }
d165 1
a165 1
static struct bit_field status_fields[] =
d168 13
a180 13
  {"SR[<CU=", " ", "cu", 4, 28},
  {"RE=", " ", "re", 1, 25},
  {"BEV=", " ", "bev", 1, 22},
  {"TS=", " ", "ts", 1, 21},
  {"Nmi=", " ", "nmi", 1, 20},
  {"INT=", " ", "int", 6, 10},
  {"SW=", ">]", "sw", 2, 8},
  {"[<KUO=", " ", "kuo", 1, 5},
  {"IEO=", " ", "ieo", 1, 4},
  {"KUP=", " ", "kup", 1, 3},
  {"IEP=", " ", "iep", 1, 2},
  {"KUC=", " ", "kuc", 1, 1},
  {"IEC=", ">]", "iec", 1, 0},
d183 6
a188 6
  {"CR[<IalO=", " ", "ialo", 0, 13},
  {"DalO=", " ", "dalo", 0, 12},
  {"IalP=", " ", "ialp", 0, 11},
  {"DalP=", " ", "dalp", 0, 10},
  {"IalC=", " ", "ialc", 0, 9},
  {"DalC=", ">] ", "dalc", 0, 8},
d190 1
a190 1
  {NULL, NULL, 0, 0}		/* end of table marker */
d194 2
a195 2
#if 0				/* FIXME: Enable when we add support for modifying cache register.  */
static struct bit_field cache_fields[] =
d198 13
a210 13
  {"SR[<CU=", " ", "cu", 0, 28},
  {"RE=", " ", "re", 0, 25},
  {"BEV=", " ", "bev", 0, 22},
  {"TS=", " ", "ts", 0, 21},
  {"Nmi=", " ", "nmi", 0, 20},
  {"INT=", " ", "int", 0, 10},
  {"SW=", ">]", "sw", 0, 8},
  {"[<KUO=", " ", "kuo", 0, 5},
  {"IEO=", " ", "ieo", 0, 4},
  {"KUP=", " ", "kup", 0, 3},
  {"IEP=", " ", "iep", 0, 2},
  {"KUC=", " ", "kuc", 0, 1},
  {"IEC=", ">]", "iec", 0, 0},
d213 6
a218 6
  {"CR[<IalO=", " ", "ialo", 1, 13},
  {"DalO=", " ", "dalo", 1, 12},
  {"IalP=", " ", "ialp", 1, 11},
  {"DalP=", " ", "dalp", 1, 10},
  {"IalC=", " ", "ialc", 1, 9},
  {"DalC=", ">] ", "dalc", 1, 8},
d220 1
a220 1
  {NULL, NULL, NULL, 0, 0}	/* end of table marker */
d225 1
a225 1
static struct bit_field cause_fields[] =
d227 5
a231 5
  {"<BD=", " ", "bd", 1, 31},
  {"CE=", " ", "ce", 2, 28},
  {"IP=", " ", "ip", 6, 10},
  {"SW=", " ", "sw", 2, 8},
  {"EC=", ">]", "ec", 5, 2},
d233 1
a233 1
  {NULL, NULL, NULL, 0, 0}	/* end of table marker */
d239 1
a239 1
   regname = xxxx xxxx
d288 1
a288 1
fetch_bad_vaddr ()
d294 1
a294 1
  monitor_expect_prompt (buf, sizeof (buf));
d298 1
a298 1

d310 1
a310 1
  for (; bf->prefix != NULL; bf++)
d312 1
a312 1
      monitor_expect (bf->prefix, NULL, 0);	/* get prefix */
d315 1
a315 1
	{
d318 1
a318 1
	  val |= bits << bf->start;	/* insert into register */
d320 1
a320 1

d389 1
a389 1
  for (; bf->prefix != NULL; bf++)
d392 1
a392 1
	{
d462 1
a462 1
  char buf[10];
d471 1
a471 1
      else
d510 5
a514 5
   start of packet flag (one byte: 0xdc)
   packet type (one byte)
   length (low byte)
   length (high byte)
   data (length bytes)
d518 1
a518 1
 */
d524 1
a524 1
  int len;
d538 1
a538 1
  c = debug_readchar (1);	/* type */
d540 1
a540 1
  c = debug_readchar (1);	/* low byte of length */
d543 1
a543 1
  c = debug_readchar (1);	/* high byte of length */
d557 1
a557 1
 */
d607 1
a607 1
	{
d615 1
a615 1
      sum = ~sum;
d675 1
a675 1
     bfd *abfd;
d691 1
a691 1

d696 1
a696 1
 */
d700 1
a700 1
     bfd *abfd;
d707 1
a707 1
      bfd_vma section_base = bfd_section_lma (abfd, s);
d713 1
a713 1
	return;
d719 1
a719 1
		       bfd_section_name (abfd, s), (long) section_size);
d725 2
a726 2
      write_long (&header[0], (long) section_base);
      write_long (&header[4], (long) section_size);
d735 1
a735 1
    }
d743 6
a748 6
   number of sections (4 bytes)
   starting address (4 bytes)
   repeat for each section:
   location address (4 bytes)
   section size (4 bytes)
   binary data
d758 3
a760 3
r3900_load (filename, from_tty)
     char *filename;
     int from_tty;
d797 1
a797 1

d801 1
a801 1
  write_long (&buffer[0], (long) section_count);
d803 1
a803 1
    write_long (&buffer[4], (long) bfd_get_start_address (exec_bfd));
d822 1
a822 1
  printf_filtered ("Start address 0x%lx\n", (long) bfd_get_start_address (abfd));
d829 1
a829 1
  inferior_pid = 0;		/* No process now */
d842 10
a851 10
   * The bare carriage return forces a prompt from the monitor
   (monitor doesn't prompt immediately after a reset).
   * The "vconsx" switches the monitor back to interactive mode
   in case an aborted download had left it in packet mode.
   * The "Xtr" command causes subsequent "t" (trace) commands to display
   the general registers only.
   * The "Xxr" command does the same thing for the "x" (examine
   registers) command.
   * The "bx" command clears all breakpoints.
 */
d853 2
a854 4
static char *r3900_inits[] =
{"\r", "vconsx\r", "Xtr\r", "Xxr\r", "bx\r", NULL};
static char *dummy_inits[] =
{NULL};
d886 3
a888 3
    if (monitor_expect ("\n", buf, sizeof (buf)) != -1)
      if (strstr (buf, "ethernet") != NULL)
	ethernet = 1;
d896 4
a899 4
    MO_ADDR_BITS_REMOVE |
    MO_CLR_BREAK_USES_ADDR |
    MO_GETMEM_READ_SINGLE |
    MO_PRINT_PROGRAM_OUTPUT;
d904 3
a906 3
  r3900_cmds.set_break = "b %A\r";	/* COREADDR */
  r3900_cmds.clr_break = "b %A,0\r";	/* COREADDR */
  r3900_cmds.fill = "fx %A s %x %x\r";	/* COREADDR, len, val */
d912 3
a914 3
  r3900_cmds.getmem.cmdb = "sx %A\r";	/* COREADDR */
  r3900_cmds.getmem.cmdw = "sh %A\r";	/* COREADDR */
  r3900_cmds.getmem.cmdl = "sw %A\r";	/* COREADDR */
d919 1
a919 1
  r3900_cmds.setreg.cmd = "x%s %x\r";	/* regname, val */
d921 1
a921 1
  r3900_cmds.getreg.cmd = "x%s\r";	/* regname */
d928 1
a928 1
    "\\([a-zA-Z0-9_]+\\) *=\\([0-9a-f]+ [0-9a-f]+\\b\\)";
@


1.1.1.3
log
@import gdb-1999-09-08 snapshot
@
text
@d535 1
a535 1
	    monitor_printf ("%s %lx ", bf->user_name, newbits);
@


