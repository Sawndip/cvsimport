head	1.16;
access;
symbols
	insight_6_6-20070208-release:1.14
	gdb_6_6-2006-12-18-release:1.14
	gdb_6_6-branch:1.14.0.18
	gdb_6_6-2006-11-15-branchpoint:1.14
	insight_6_5-20061003-release:1.14
	gdb-csl-symbian-6_4_50_20060226-12:1.14
	gdb-csl-sourcerygxx-3_4_4-25:1.13
	nickrob-async-20060828-mergepoint:1.14
	gdb-csl-symbian-6_4_50_20060226-11:1.14
	gdb-csl-sourcerygxx-4_1-17:1.14
	gdb-csl-20060226-branch-local-2:1.14
	gdb-csl-sourcerygxx-4_1-14:1.14
	gdb-csl-sourcerygxx-4_1-13:1.14
	gdb-csl-sourcerygxx-4_1-12:1.14
	gdb-csl-sourcerygxx-3_4_4-21:1.14
	gdb_6_5-20060621-release:1.14
	gdb-csl-sourcerygxx-4_1-9:1.14
	gdb-csl-sourcerygxx-4_1-8:1.14
	gdb-csl-sourcerygxx-4_1-7:1.14
	gdb-csl-arm-2006q1-6:1.14
	gdb-csl-sourcerygxx-4_1-6:1.14
	gdb-csl-symbian-6_4_50_20060226-10:1.14
	gdb-csl-symbian-6_4_50_20060226-9:1.14
	gdb-csl-symbian-6_4_50_20060226-8:1.14
	gdb-csl-coldfire-4_1-11:1.14
	gdb-csl-sourcerygxx-3_4_4-19:1.14
	gdb-csl-coldfire-4_1-10:1.14
	gdb_6_5-branch:1.14.0.16
	gdb_6_5-2006-05-14-branchpoint:1.14
	gdb-csl-sourcerygxx-4_1-5:1.14
	nickrob-async-20060513-branch:1.14.0.14
	nickrob-async-20060513-branchpoint:1.14
	gdb-csl-sourcerygxx-4_1-4:1.14
	msnyder-reverse-20060502-branch:1.14.0.12
	msnyder-reverse-20060502-branchpoint:1.14
	gdb-csl-morpho-4_1-4:1.14
	gdb-csl-sourcerygxx-3_4_4-17:1.14
	readline_5_1-import-branch:1.14.0.10
	readline_5_1-import-branchpoint:1.14
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.14
	gdb-csl-symbian-20060226-branch:1.14.0.8
	gdb-csl-symbian-20060226-branchpoint:1.14
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.14
	msnyder-reverse-20060331-branch:1.14.0.6
	msnyder-reverse-20060331-branchpoint:1.14
	gdb-csl-available-20060303-branch:1.14.0.4
	gdb-csl-available-20060303-branchpoint:1.14
	gdb-csl-20060226-branch:1.14.0.2
	gdb-csl-20060226-branchpoint:1.14
	gdb_6_4-20051202-release:1.13
	msnyder-fork-checkpoint-branch:1.13.0.12
	msnyder-fork-checkpoint-branchpoint:1.13
	gdb-csl-gxxpro-6_3-branch:1.13.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.13
	gdb_6_4-branch:1.13.0.8
	gdb_6_4-2005-11-01-branchpoint:1.13
	gdb-csl-arm-20051020-branch:1.13.0.6
	gdb-csl-arm-20051020-branchpoint:1.13
	msnyder-tracepoint-checkpoint-branch:1.13.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.13
	gdb-csl-arm-20050325-2005-q1b:1.13
	gdb-csl-arm-20050325-2005-q1a:1.13
	csl-arm-20050325-branch:1.13.0.2
	csl-arm-20050325-branchpoint:1.13
	gdb-post-i18n-errorwarning-20050211:1.13
	gdb-pre-i18n-errorwarning-20050211:1.12
	gdb_6_3-20041109-release:1.11
	gdb_6_3-branch:1.11.0.2
	gdb_6_3-20041019-branchpoint:1.11
	drow_intercu-merge-20040921:1.10
	drow_intercu-merge-20040915:1.10
	jimb-gdb_6_2-e500-branch:1.10.0.6
	jimb-gdb_6_2-e500-branchpoint:1.10
	gdb_6_2-20040730-release:1.10
	gdb_6_2-branch:1.10.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.10
	gdb_6_1_1-20040616-release:1.8
	gdb_6_1-2004-04-05-release:1.8
	drow_intercu-merge-20040402:1.8
	drow_intercu-merge-20040327:1.8
	ezannoni_pie-20040323-branch:1.8.0.62
	ezannoni_pie-20040323-branchpoint:1.8
	cagney_tramp-20040321-mergepoint:1.8
	cagney_tramp-20040309-branch:1.8.0.60
	cagney_tramp-20040309-branchpoint:1.8
	gdb_6_1-branch:1.8.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.8
	drow_intercu-20040221-branch:1.8.0.56
	drow_intercu-20040221-branchpoint:1.8
	cagney_bfdfile-20040213-branch:1.8.0.54
	cagney_bfdfile-20040213-branchpoint:1.8
	drow-cplus-merge-20040208:1.8
	carlton_dictionary-20040126-merge:1.8
	cagney_bigcore-20040122-branch:1.8.0.52
	cagney_bigcore-20040122-branchpoint:1.8
	drow-cplus-merge-20040113:1.8
	drow-cplus-merge-20031224:1.8
	drow-cplus-merge-20031220:1.8
	carlton_dictionary-20031215-merge:1.8
	drow-cplus-merge-20031214:1.8
	carlton-dictionary-20031111-merge:1.8
	gdb_6_0-2003-10-04-release:1.8
	kettenis_sparc-20030918-branch:1.8.0.50
	kettenis_sparc-20030918-branchpoint:1.8
	carlton_dictionary-20030917-merge:1.8
	ezannoni_pie-20030916-branchpoint:1.8
	ezannoni_pie-20030916-branch:1.8.0.48
	cagney_x86i386-20030821-branch:1.8.0.46
	cagney_x86i386-20030821-branchpoint:1.8
	carlton_dictionary-20030805-merge:1.8
	carlton_dictionary-20030627-merge:1.8
	gdb_6_0-branch:1.8.0.44
	gdb_6_0-2003-06-23-branchpoint:1.8
	jimb-ppc64-linux-20030613-branch:1.8.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.8
	cagney_convert-20030606-branch:1.8.0.40
	cagney_convert-20030606-branchpoint:1.8
	cagney_writestrings-20030508-branch:1.8.0.38
	cagney_writestrings-20030508-branchpoint:1.8
	jimb-ppc64-linux-20030528-branch:1.8.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.8
	carlton_dictionary-20030523-merge:1.8
	cagney_fileio-20030521-branch:1.8.0.34
	cagney_fileio-20030521-branchpoint:1.8
	kettenis_i386newframe-20030517-mergepoint:1.8
	jimb-ppc64-linux-20030509-branch:1.8.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.8
	kettenis_i386newframe-20030504-mergepoint:1.8
	carlton_dictionary-20030430-merge:1.8
	kettenis_i386newframe-20030419-branch:1.8.0.30
	kettenis_i386newframe-20030419-branchpoint:1.8
	carlton_dictionary-20030416-merge:1.8
	cagney_frameaddr-20030409-mergepoint:1.8
	kettenis_i386newframe-20030406-branch:1.8.0.28
	kettenis_i386newframe-20030406-branchpoint:1.8
	cagney_frameaddr-20030403-branchpoint:1.8
	cagney_frameaddr-20030403-branch:1.8.0.26
	cagney_framebase-20030330-mergepoint:1.8
	cagney_framebase-20030326-branch:1.8.0.24
	cagney_framebase-20030326-branchpoint:1.8
	cagney_lazyid-20030317-branch:1.8.0.22
	cagney_lazyid-20030317-branchpoint:1.8
	kettenis-i386newframe-20030316-mergepoint:1.8
	offbyone-20030313-branch:1.8.0.20
	offbyone-20030313-branchpoint:1.8
	kettenis-i386newframe-20030308-branch:1.8.0.18
	kettenis-i386newframe-20030308-branchpoint:1.8
	carlton_dictionary-20030305-merge:1.8
	cagney_offbyone-20030303-branch:1.8.0.16
	cagney_offbyone-20030303-branchpoint:1.8
	carlton_dictionary-20030207-merge:1.8
	interps-20030203-mergepoint:1.8
	interps-20030202-branch:1.8.0.14
	interps-20030202-branchpoint:1.8
	cagney-unwind-20030108-branch:1.8.0.12
	cagney-unwind-20030108-branchpoint:1.8
	carlton_dictionary-20021223-merge:1.8
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.10
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.8
	carlton_dictionary-20020920-branchpoint:1.8
	gdb_5_3-branch:1.8.0.6
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.4
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.2
	readline_4_3-import-branchpoint:1.8
	gdb_5_2_1-2002-07-23-release:1.7
	kseitz_interps-20020528-branch:1.7.0.16
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.14
	cagney_regbuf-20020515-branchpoint:1.7
	jimb-macro-020506-branch:1.7.0.12
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.10
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.8
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.6
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.4
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	gdb-post-ptid_t-2001-05-03:1.7
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb-post-params-removal-2000-06-04:1.4
	gdb-pre-params-removal-2000-06-04:1.4
	gdb-post-params-removal-2000-05-28:1.4
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.16
date	2007.03.29.19.58.29;	author drow;	state dead;
branches;
next	1.15;

1.15
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.11.04.06.08;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.14.04.03.02;	author msnyder;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.08.20.29.56;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.25.14.58.31;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.21.23.52.21;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.15.19.00.46;	author kettenis;	state Exp;
branches
	1.8.56.1;
next	1.7;

1.7
date	2001.05.04.04.15.28;	author kevinb;	state Exp;
branches
	1.7.16.1;
next	1.6;

1.6
date	2001.03.15.17.42.00;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.01.01.39.22;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.26.23.22.41;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.02.06.05.03;	author nsd;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.12.06.08.10;	author nsd;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.18.00.54.24;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.01.18.00.54.24;	author jsm;	state Exp;
branches;
next	;

1.7.16.1
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	;

1.8.56.1
date	2004.09.16.17.01.26;	author drow;	state Exp;
branches;
next	;


desc
@@


1.16
log
@	* Makefile.in (coff_solib_h, coff-solib.o, i386v-nat.o, lynx-nat.o)
	(remote-st.o, uw-thread.o): Delete.
	(HFILES_NO_SRCDIR, ALLDEPFILES): Update.
	* configure.host: Move hppa*-*-hiux*, i[34567]86-ncr-*,
	i[34567]86-*-dgux*, i[34567]86-*-lynxos*, i[34567]86-*-sco3.2v5*,
	i[34567]86-*-sco3.2v4*, i[34567]86-*-sco*, i[34567]86-*-sysv4.2*,
	i[34567]86-*-sysv4*, i[34567]86-*-sysv5*, i[34567]86-*-unixware2*,
	i[34567]86-*-unixware*, i[34567]86-*-sysv*, i[34567]86-*-isc*, and
	rs6000-*-lynxos* to an obsoletion stanza.
	* configure.tgt: Move hppa*-*-hiux*, i[34567]86-ncr-*,
	i[34567]86-*-lynxos*, m68*-cisco*-*, m68*-tandem-*, m68*-*-os68k*,
	and rs6000-*-lynxos* to an obsoletion stanza.  Do not mention
	i[34567]86-*-netware*.
	* NEWS: Mention deleted targets.

	* coff-solib.c, coff-solib.h, i386v-nat.c, lynx-nat.c, remote-st.c,
	uw-thread.c, config/nm-lynx.h, config/i386/i386sco.mh,
	config/i386/i386sco4.mh, config/i386/i386sco5.mh, config/i386/i386v.mh,
	config/i386/i386v4.mh, config/i386/i386v42mp.mh,
	config/i386/ncr3000.mh, config/i386/ncr3000.mt,
	config/i386/nm-i386sco.h, config/i386/nm-i386sco4.h,
	config/i386/nm-i386sco5.h, config/i386/nm-i386v.h,
	config/i386/nm-i386v4.h, config/i386/nm-i386v42mp.h,
	config/m68k/cisco.mt, config/m68k/os68k.mt, config/m68k/st2000.mt,
	config/m68k/tm-cisco.h, config/m68k/tm-os68k.h,
	config/rs6000/rs6000lynx.mh, config/rs6000/rs6000lynx.mt,
	config/rs6000/tm-rs6000ly.h: Delete files.
@
text
@/* Low level interface for debugging UnixWare user-mode threads for
   GDB, the GNU debugger.

   Copyright (C) 1999, 2000, 2001, 2007 Free Software Foundation, Inc.
   Written by Nick Duffek <nsd@@cygnus.com>.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */


/* Like many systems, UnixWare implements two classes of threads:
   kernel-mode threads, which are scheduled by the kernel; and
   user-mode threads, which are scheduled by a library.  UnixWare
   calls these two classes lightweight processes (LWPs) and threads,
   respectively.

   This module deals with user-mode threads.  It calls procfs_ops
   functions to deal with LWPs and processes and core_ops functions to
   deal with core files.

   As of this writing, the user-mode thread debugging interface is not
   documented beyond the comments in <thread.h>.  The following
   description has been gleaned from experience and from information
   provided by SCO.

   libthread.so, against which all UnixWare user-mode thread programs
   link, provides a global thread_debug structure named _thr_debug.
   It has three fields:

     (1) thr_map is a pointer to a pointer to an element of a
	 thread_map ring.  A thread_map contains a single thread's id
	 number, state, LWP pointer, recent register state, and other
	 useful information.

     (2) thr_brk is a pointer to a stub function that libthread.so
	 calls when it changes a thread's state, e.g. by creating it,
	 switching it to an LWP, or causing it to exit.

     (3) thr_debug_on controls whether libthread.so calls thr_brk().

   Debuggers are able to track thread activity by setting a private
   breakpoint on thr_brk() and setting thr_debug_on to 1.

   thr_brk() receives two arguments:

     (1) a pointer to a thread_map describing the thread being
	 changed; and

     (2) an enum thread_change specifying one of the following
	 changes:

	 invalid		 unknown
	 thread_create		 thread has just been created
	 thread_exit		 thread has just exited
	 switch_begin		 thread will be switched to an LWP
	 switch_complete	 thread has been switched to an LWP
	 cancel_complete	 thread wasn't switched to an LWP
	 thread_suspend		 thread has been thr_suspend()ed
	 thread_suspend_pending	 thread will be thr_suspend()ed
	 thread_continue	 thread has been thr_continue()d

   The thread_map argument to thr_brk() is NULL under the following
   circumstances:

     - The main thread is being acted upon.  The main thread always
       has id 1, so its thread_map is easy to find by scanning through
       _thr_debug.thr_map.

     - A "switch_complete" change is occurring, which means that the
       thread specified in the most recent "switch_begin" change has
       moved to an LWP.

     - A "cancel_complete" change is occurring, which means that the
       thread specified in the most recent "switch_begin" change has
       not moved to an LWP after all.

     - A spurious "switch_begin" change is occurring after a
       "thread_exit" change.

   Between switch_begin and switch_complete or cancel_complete, the
   affected thread's LWP pointer is not reliable.  It is possible that
   other parts of the thread's thread_map are also unreliable during
   that time.  */


#include "defs.h"
#include "gdbthread.h"
#include "target.h"
#include "inferior.h"
#include "regcache.h"
#include <fcntl.h>

/* <thread.h> includes <sys/priocntl.h>, which requires boolean_t from
   <sys/types.h>, which doesn't typedef boolean_t with gcc.  */

#define boolean_t int
#include <thread.h>
#undef boolean_t

#include <synch.h>		/* for UnixWare 2.x */

/* Prototypes for supply_gregset etc.  */
#include "gregset.h"

/* Offset from SP to first arg on stack at first instruction of a
   function.  We provide a default here that's right for most, if not
   all, targets that use this file.  */

#ifndef SP_ARG0
#define SP_ARG0 (1 * 4)
#endif

/* Whether to emit debugging output.  */

#define DEBUG 0

/* Default debugging output file, overridden by envvar UWTHR_DEBUG.  */

#define DEBUG_FILE "/dev/tty"

/* #if DEBUG, write string S to the debugging output channel.  */

#if !DEBUG
# define DBG(fmt_and_args)
# define DBG2(fmt_and_args)
#else
# define DBG(fmt_and_args) dbg fmt_and_args
# define DBG2(fmt_and_args)
#endif

/* Back end to CALL_BASE() and TRY_BASE(): evaluate CALL, then convert
   inferior_ptid to a composite thread/process id.  */

#define CALL_BASE_1(call)		\
do {					\
  DBG2(("CALL_BASE(" #call ")"));	\
  call;					\
  do_cleanups (infpid_cleanup);		\
} while (0)

/* If inferior_ptid can be converted to a composite lwp/process id, do so,
   evaluate base_ops function CALL, and then convert inferior_ptid back to a
   composite thread/process id.

   Otherwise, issue an error message and return nonlocally.  */

#define CALL_BASE(call)			\
do {					\
  if (!lwp_infpid ())			\
    error (_("uw-thread: no lwp"));	\
  CALL_BASE_1 (call);			\
} while (0)

/* Like CALL_BASE(), but instead of returning nonlocally on error, set
   *CALLED to whether the inferior_ptid conversion was successful.  */

#define TRY_BASE(call, called)		\
do {					\
  if ((*(called) = lwp_infpid ()))	\
    CALL_BASE_1 (call);			\
} while (0)

/* Information passed by thread_iter() to its callback parameter.  */

typedef struct {
  struct thread_map map;
  __lwp_desc_t lwp;
  CORE_ADDR mapp;
} iter_t;

/* Private thread data for the thread_info struct.  */

struct private_thread_info {
  int stable;		/* 0 if libthread.so is modifying thread map */
  int thrid;		/* thread id assigned by libthread.so */
  int lwpid;		/* thread's lwp if .stable, 0 means no lwp */
  CORE_ADDR mapp;	/* address of thread's map structure */
};


/* procfs.c's target-specific operations.  */
extern struct target_ops procfs_ops;

/* Flag to prevent procfs.c from starting inferior processes.  */
extern int procfs_suppress_run;

/* This module's target-specific operations.  */
static struct target_ops uw_thread_ops;

/* Copy of the target over which uw_thread_ops is pushed.  This is
   more convenient than a pointer to procfs_ops or core_ops, because
   they lack current_target's default callbacks.  */
static struct target_ops base_ops;

/* Saved pointer to previous owner of
   deprecated_target_new_objfile_hook.  */
static void (*target_new_objfile_chain)(struct objfile *);

/* Whether we are debugging a user-space thread program.  This isn't
   set until after libthread.so is loaded by the program being
   debugged.

   Except for module one-time intialization and where otherwise
   documented, no functions in this module get called when
   !uw_thread_active.  */
static int uw_thread_active;

/* For efficiency, cache the addresses of libthread.so's _thr_debug
   structure, its thr_brk stub function, and the main thread's map.  */
static CORE_ADDR thr_debug_addr;
static CORE_ADDR thr_brk_addr;
static CORE_ADDR thr_map_main;

/* Remember the thread most recently marked as switching.  Necessary because
   libthread.so passes null map when calling stub with tc_*_complete.  */
static struct thread_info *switchto_thread;

/* Cleanup chain for safely restoring inferior_ptid after CALL_BASE.  */
static struct cleanup *infpid_cleanup;


#if DEBUG
/* Helper function for DBG() macro: if printf-style FMT is non-null, format it
   with args and display the result on the debugging output channel.  */

static void
dbg (char *fmt, ...)
{
  static int fd = -1, len;
  va_list args;
  char buf[1024];
  char *path;

  if (!fmt)
    return;

  if (fd < 0)
    {
      path = getenv ("UWTHR_DEBUG");
      if (!path)
	path = DEBUG_FILE;
      if ((fd = open (path, O_WRONLY | O_CREAT | O_TRUNC, 0664)) < 0)
	error (_("can't open %s."), path);
    }

  va_start (args, fmt);
  vsprintf (buf, fmt, args);
  va_end (args);

  len = strlen (buf);
  buf[len] = '\n';
  (void)write (fd, buf, len + 1);
}

#if 0
/* Return a string representing composite PID's components.  */

static char *
dbgpid (ptid_t ptid)
{
  static char *buf, buf1[80], buf2[80];
  if (!buf || buf == buf2)
    buf = buf1;
  else
    buf = buf2;

  if (PIDGET (ptid) <= 0)
    sprintf (buf, "%d", PIDGET (ptid));
  else
    sprintf (buf, "%s %ld/%d", ISTID (pid) ? "thr" : "lwp",
	     TIDGET (pid), PIDGET (pid));

  return buf;
}

/* Return a string representing thread state CHANGE.  */

static char *
dbgchange (enum thread_change change)
{
  switch (change) {
  case tc_invalid:			return "invalid";
  case tc_thread_create:		return "thread_create";
  case tc_thread_exit:			return "thread_exit";
  case tc_switch_begin:			return "switch_begin";
  case tc_switch_complete:		return "switch_complete";
  case tc_cancel_complete:		return "cancel_complete";
  case tc_thread_suspend:		return "thread_suspend";
  case tc_thread_suspend_pending:	return "thread_suspend_pending";
  case tc_thread_continue:		return "thread_continue";
  default:				return "unknown";
  }
}

/* Return a string representing thread STATE.  */

static char *
dbgstate (int state)
{
  switch (state) {
  case TS_ONPROC:	return "running";
  case TS_SLEEP:	return "sleeping";
  case TS_RUNNABLE:	return "runnable";
  case TS_ZOMBIE:	return "zombie";
  case TS_SUSPENDED:	return "suspended";
#ifdef TS_FORK
  case TS_FORK:		return "forking";
#endif
  default:		return "confused";
  }
}
#endif  /* 0 */
#endif  /* DEBUG */


/* Read the contents of _thr_debug into *DEBUGP.  Return success.  */

static int
read_thr_debug (struct thread_debug *debugp)
{
  return base_ops.deprecated_xfer_memory (thr_debug_addr, (char *)debugp,
					  sizeof (*debugp), 0, NULL,
					  &base_ops);
}

/* Read into MAP the contents of the thread map at inferior process address
   MAPP.  Return success.  */

static int
read_map (CORE_ADDR mapp, struct thread_map *map)
{
  return base_ops.deprecated_xfer_memory ((CORE_ADDR)THR_MAP (mapp),
					  (char *)map, sizeof (*map),
					  0, NULL, &base_ops);
}

/* Read into LWP the contents of the lwp decriptor at inferior process address
   LWPP.  Return success.  */

static int
read_lwp (CORE_ADDR lwpp, __lwp_desc_t *lwp)
{
  return base_ops.deprecated_xfer_memory (lwpp, (char *)lwp,
					  sizeof (*lwp), 0, NULL, &base_ops);
}

/* Iterate through all user threads, applying FUNC(<map>, <lwp>, DATA) until
     (a) FUNC returns nonzero,
     (b) FUNC has been applied to all threads, or
     (c) an error occurs,
   where <map> is the thread's struct thread_map and <lwp> if non-null is the
   thread's current __lwp_desc_t.

   If a call to FUNC returns nonzero, return that value; otherwise, return 0.  */

static int
thread_iter (int (*func)(iter_t *, void *), void *data)
{
  struct thread_debug debug;
  CORE_ADDR first, mapp;
  iter_t iter;
  int ret;

  if (!read_thr_debug (&debug))
    return 0;
  if (!base_ops.deprecated_xfer_memory ((CORE_ADDR)debug.thr_map,
					(char *)&mapp, sizeof (mapp), 0, NULL,
					&base_ops))
    return 0;
  if (!mapp)
    return 0;

  for (first = mapp;;)
    {
      if (!read_map (mapp, &iter.map))
	return 0;

      if (iter.map.thr_lwpp)
	if (!read_lwp ((CORE_ADDR)iter.map.thr_lwpp, &iter.lwp))
	  return 0;

      iter.mapp = mapp;
      if ((ret = func (&iter, data)))
	return ret;

      mapp = (CORE_ADDR)iter.map.thr_next;
      if (mapp == first)
	return 0;
    }
}

/* Deactivate user-mode thread support.  */

static void
deactivate_uw_thread (void)
{
  remove_thread_event_breakpoints ();
  uw_thread_active = 0;
  unpush_target (&uw_thread_ops);
}

/* Return the composite lwp/process id corresponding to composite
   id PID.  If PID is a thread with no lwp, return 0.  */

static ptid_t
thr_to_lwp (ptid_t ptid)
{
  struct thread_info *info;
  ptid_t lid;

  if (!ISTID (ptid))
    lid = ptid;
  else if (!(info = find_thread_pid (ptid)))
    lid = null_ptid;
  else if (!info->private->lwpid)
    lid = null_ptid;
  else
    lid = MKLID (PIDGET (ptid), info->private->lwpid);

  DBG2(("  thr_to_lwp(%s) = %s", dbgpid (pid), dbgpid (lid)));
  return lid;
}

/* find_thread_lwp() callback: return whether TP describes a thread
   associated with lwp id DATA.  */

static int
find_thread_lwp_callback (struct thread_info *tp, void *data)
{
  int lwpid = (int)data;

  if (!ISTID (tp->ptid))
    return 0;
  if (!tp->private->stable)
    return 0;
  if (lwpid != tp->private->lwpid)
    return 0;

  /* match */
  return 1;
}

/* If a thread is associated with lwp id LWPID, return the corresponding
   member of the global thread list; otherwise, return null.  */

static struct thread_info *
find_thread_lwp (int lwpid)
{
  return iterate_over_threads (find_thread_lwp_callback, (void *)lwpid);
}

/* Return the composite thread/process id corresponding to composite
   id PID.  If PID is an lwp with no thread, return PID.  */

static ptid_t
lwp_to_thr (ptid_t ptid)
{
  struct thread_info *info;
  int lwpid;
  ptid_t tid = ptid;

  if (ISTID (ptid))
    goto done;
  if (!(lwpid = LIDGET (ptid)))
    goto done;
  if (!(info = find_thread_lwp (lwpid)))
    goto done;
  tid = MKTID (PIDGET (ptid), info->private->thrid);

 done:
  DBG2((ISTID (tid) ? NULL : "lwp_to_thr: no thr for %s", dbgpid (ptid)));
  return tid;
}

/* do_cleanups() callback: convert inferior_ptid to a composite
   thread/process id after having made a procfs call.  */

static void
thr_infpid (void *unused)
{
  ptid_t ptid = lwp_to_thr (inferior_ptid);
  DBG2((" inferior_ptid from procfs: %s => %s",
	dbgpid (inferior_ptid), dbgpid (ptid)));
  inferior_ptid = ptid;
}

/* If possible, convert inferior_ptid to a composite lwp/process id in
   preparation for making a procfs call.  Return success.  */

static int
lwp_infpid (void)
{
  ptid_t ptid = thr_to_lwp (inferior_ptid);
  DBG2((" inferior_ptid to procfs: %s => %s",
	dbgpid (inferior_ptid), dbgpid (ptid)));

  if (ptid_equal (ptid, null_ptid))
    return 0;

  inferior_ptid = ptid;
  infpid_cleanup = make_cleanup (thr_infpid, NULL);
  return 1;
}

/* Add to the global thread list a new user-mode thread with system id THRID,
   lwp id LWPID, map address MAPP, and composite thread/process PID.  */

static void
add_thread_uw (int thrid, int lwpid, CORE_ADDR mapp, ptid_t ptid)
{
  struct thread_info *newthread;

  if ((newthread = add_thread (ptid)) == NULL)
    error (_("failed to create new thread structure"));

  newthread->private = xmalloc (sizeof (struct private_thread_info));
  newthread->private->stable = 1;
  newthread->private->thrid = thrid;
  newthread->private->lwpid = lwpid;
  newthread->private->mapp = mapp;

  if (target_has_execution)
    printf_unfiltered ("[New %s]\n", target_pid_to_str (ptid));
}

/* notice_threads() and find_main() callback: if the thread list doesn't
   already contain the thread described by ITER, add it if it's the main
   thread or if !DATA.  */

static int
notice_thread (iter_t *iter, void *data)
{
  int thrid = iter->map.thr_tid;
  int lwpid = !iter->map.thr_lwpp ? 0 : iter->lwp.lwp_id;
  ptid_t ptid = MKTID (PIDGET (inferior_ptid), thrid);

  if (!find_thread_pid (ptid) && (!data || thrid == 1))
    add_thread_uw (thrid, lwpid, iter->mapp, ptid);

  return 0;
}

/* Add to the thread list any threads it doesn't already contain.  */

static void
notice_threads (void)
{
  thread_iter (notice_thread, NULL);
}

/* Return the address of the main thread's map.  On error, return 0.  */

static CORE_ADDR
find_main (void)
{
  if (!thr_map_main)
    {
      struct thread_info *info;
      thread_iter (notice_thread, (void *)1);
      if ((info = find_thread_pid (MKTID (PIDGET (inferior_ptid), 1))))
	thr_map_main = info->private->mapp;
    }
  return thr_map_main;
}

/* Attach to process specified by ARGS, then initialize for debugging it
   and wait for the trace-trap that results from attaching.

   This function only gets called with uw_thread_active == 0.  */

static void
uw_thread_attach (char *args, int from_tty)
{
  procfs_ops.to_attach (args, from_tty);
  if (uw_thread_active)
    thr_infpid (NULL);
}

/* Detach from the process attached to by uw_thread_attach().  */

static void
uw_thread_detach (char *args, int from_tty)
{
  deactivate_uw_thread ();
  base_ops.to_detach (args, from_tty);
}

/* Tell the inferior process to continue running thread PID if >= 0
   and all threads otherwise.  */

static void
uw_thread_resume (ptid_t ptid, int step, enum target_signal signo)
{
  if (PIDGET (ptid) > 0)
    {
      ptid = thr_to_lwp (ptid);
      if (ptid_equal (ptid, null_ptid))
	ptid = pid_to_ptid (-1);
    }

  CALL_BASE (base_ops.to_resume (ptid, step, signo));
}

/* If the trap we just received from lwp PID was due to a breakpoint
   on the libthread.so debugging stub, update this module's state
   accordingly.  */

static void
libthread_stub (ptid_t ptid)
{
  CORE_ADDR sp, mapp, mapp_main;
  enum thread_change change;
  struct thread_map map;
  __lwp_desc_t lwp;
  int lwpid;
  ptid_t tid = null_ptid;
  struct thread_info *info;

  /* Check for stub breakpoint.  */
  if (read_pc_pid (ptid) - DECR_PC_AFTER_BREAK != thr_brk_addr)
    return;

  /* Retrieve stub args.  */
  sp = read_register_pid (SP_REGNUM, ptid);
  if (!base_ops.deprecated_xfer_memory (sp + SP_ARG0, (char *)&mapp,
					sizeof (mapp), 0, NULL, &base_ops))
    goto err;
  if (!base_ops.deprecated_xfer_memory (sp + SP_ARG0 + sizeof (mapp),
					(char *)&change, sizeof (change), 0,
					NULL, &base_ops))
    goto err;

  /* create_inferior() may not have finished yet, so notice the main
     thread to ensure that it's displayed first by add_thread().  */
  mapp_main = find_main ();

  /* Notice thread creation, deletion, or stability change.  */
  switch (change) {
  case tc_switch_begin:
    if (!mapp)				/* usually means main thread */
      mapp = mapp_main;
    /* fall through */

  case tc_thread_create:
  case tc_thread_exit:
    if (!mapp)
      break;
    if (!read_map (mapp, &map))
      goto err;
    tid = MKTID (PIDGET (ptid), map.thr_tid);

    switch (change) {
    case tc_thread_create:		/* new thread */
      if (!map.thr_lwpp)
	lwpid = 0;
      else if (!read_lwp ((CORE_ADDR)map.thr_lwpp, &lwp))
	goto err;
      else
	lwpid = lwp.lwp_id;
      add_thread_uw (map.thr_tid, lwpid, mapp, tid);
      break;

    case tc_thread_exit:		/* thread has exited */
      printf_unfiltered ("[Exited %s]\n", target_pid_to_str (tid));
      delete_thread (tid);
      if (ptid_equal (tid, inferior_ptid))
	inferior_ptid = ptid;
      break;

    case tc_switch_begin:		/* lwp is switching threads */
      if (switchto_thread)
	goto err;
      if (!(switchto_thread = find_thread_pid (tid)))
	goto err;
      switchto_thread->private->stable = 0;
      break;

    default:
      break;
    }
    break;

  case tc_switch_complete:		/* lwp has switched threads */
  case tc_cancel_complete:		/* lwp didn't switch threads */
    if (!switchto_thread)
      goto err;

    if (change == tc_switch_complete)
      {
	/* If switchto_thread is the main thread, then (a) the corresponding
	   tc_switch_begin probably received a null map argument and therefore
	   (b) it may have been a spurious switch following a tc_thread_exit.

	   Therefore, explicitly query the thread's lwp before caching it in
	   its thread list entry.  */

	if (!read_map (switchto_thread->private->mapp, &map))
	  goto err;
	if (map.thr_lwpp)
	  {
	    if (!read_lwp ((CORE_ADDR)map.thr_lwpp, &lwp))
	      goto err;
	    if ((info = find_thread_lwp (lwp.lwp_id)))
	      info->private->lwpid = 0;
	    switchto_thread->private->lwpid = lwp.lwp_id;
	  }
      }

    switchto_thread->private->stable = 1;
    switchto_thread = NULL;
    break;

  case tc_invalid:
  case tc_thread_suspend:
  case tc_thread_suspend_pending:
  case tc_thread_continue:
  err:
    DBG(("unexpected condition in libthread_stub()"));
    break;
  }

  DBG2(("libthread_stub(%s): %s %s %s", dbgpid (pid), dbgpid (tid),
	dbgchange (change), tid ? dbgstate (map.thr_state) : ""));
}

/* Wait for thread/lwp/process ID if >= 0 or for any thread otherwise.  */

static ptid_t
uw_thread_wait (ptid_t ptid, struct target_waitstatus *status)
{
  if (PIDGET (ptid) > 0)
    ptid = thr_to_lwp (ptid);
  if (PIDGET (ptid) <= 0)
    ptid = pid_to_ptid (-1);

  CALL_BASE (ptid = base_ops.to_wait (ptid, status));

  if (status->kind == TARGET_WAITKIND_STOPPED &&
      status->value.sig == TARGET_SIGNAL_TRAP)
    libthread_stub (ptid);

  return lwp_to_thr (ptid);
}

/* Tell gdb about the registers in the thread/lwp/process specified by
   inferior_ptid.  */

static void
uw_thread_fetch_registers (int regno)
{
  int called;
  struct thread_info *info;
  struct thread_map map;

  TRY_BASE (base_ops.to_fetch_registers (regno), &called);
  if (called)
    return;

  if (!(info = find_thread_pid (inferior_ptid)))
    return;
  if (!read_map (info->private->mapp, &map))
    return;

  supply_gregset (&map.thr_ucontext.uc_mcontext.gregs);
  supply_fpregset (&map.thr_ucontext.uc_mcontext.fpregs);
}

/* Store gdb's current view of the register set into the thread/lwp/process
   specified by inferior_ptid.  */

static void
uw_thread_store_registers (int regno)
{
  CALL_BASE (base_ops.to_store_registers (regno));
}

/* Prepare to modify the registers array.  */

static void
uw_thread_prepare_to_store (void)
{
  CALL_BASE (base_ops.to_prepare_to_store ());
}

/* Fork an inferior process and start debugging it.

   This function only gets called with uw_thread_active == 0.  */

static void
uw_thread_create_inferior (char *exec_file, char *allargs, char **env,
			   int from_tty)
{
  if (uw_thread_active)
    deactivate_uw_thread ();

  procfs_ops.to_create_inferior (exec_file, allargs, env, from_tty);
  if (uw_thread_active)
    {
      find_main ();
      thr_infpid (NULL);
    }
}

/* Kill and forget about the inferior process.  */

static void
uw_thread_kill (void)
{
  base_ops.to_kill ();
}

/* Clean up after the inferior exits.  */

static void
uw_thread_mourn_inferior (void)
{
  deactivate_uw_thread ();
  base_ops.to_mourn_inferior ();
}

/* Return whether this module can attach to and run processes.

   This function only gets called with uw_thread_active == 0.  */

static int
uw_thread_can_run (void)
{
  return procfs_suppress_run;
}

/* Return whether thread PID is still valid.  */

static int
uw_thread_alive (ptid_t ptid)
{
  if (!ISTID (ptid))
    return base_ops.to_thread_alive (ptid);

  /* If it's in the thread list, it's valid, because otherwise
     libthread_stub() would have deleted it.  */
  return in_thread_list (ptid);
}

/* Add to the thread list any threads and lwps it doesn't already contain.  */

static void
uw_thread_find_new_threads (void)
{
  CALL_BASE (if (base_ops.to_find_new_threads)
	       base_ops.to_find_new_threads ());
  notice_threads ();
}

/* Return a string for pretty-printing PID in "info threads" output.
   This may be called by either procfs.c or by generic gdb.  */

static char *
uw_thread_pid_to_str (ptid_t ptid)
{
#define FMT "Thread %ld"
  static char buf[sizeof (FMT) + 3 * sizeof (long)];

  if (!ISTID (ptid))
    /* core_ops says "process foo", so call procfs_ops explicitly.  */
    return procfs_ops.to_pid_to_str (ptid);

  sprintf (buf, FMT, TIDGET (ptid));
#undef FMT
  return buf;
}

/* Return a string displaying INFO state information in "info threads"
   output.  */

static char *
uw_extra_thread_info (struct thread_info *info)
{
  static char buf[80];
  struct thread_map map;
  __lwp_desc_t lwp;
  int lwpid;
  char *name;

  if (!ISTID (info->ptid))
    return NULL;

  if (!info->private->stable)
    return "switching";

  if (!read_map (info->private->mapp, &map))
    return NULL;

  if (!map.thr_lwpp || !read_lwp ((CORE_ADDR)map.thr_lwpp, &lwp))
    lwpid = 0;
  else
    lwpid = lwp.lwp_id;

  switch (map.thr_state) {
  case TS_ONPROC:	name = "running";	break;
  case TS_SLEEP:	name = "sleeping";	break;
  case TS_RUNNABLE:	name = "runnable";	break;
  case TS_ZOMBIE:	name = "zombie";	break;
  case TS_SUSPENDED:	name = "suspended";	break;
#ifdef TS_FORK
  case TS_FORK:		name = "forking";	break;
#endif
  default:		name = "confused";	break;
  }

  if (!lwpid)
    return name;

  sprintf (buf, "%s, LWP %d", name, lwpid);
  return buf;
}

/* Check whether libthread.so has just been loaded, and if so, try to
   initialize user-space thread debugging support.

   libthread.so loading happens while (a) an inferior process is being
   started by procfs and (b) a core image is being loaded.

   This function often gets called with uw_thread_active == 0.  */

static void
libthread_init (void)
{
  struct minimal_symbol *ms;
  struct thread_debug debug;
  CORE_ADDR onp;
  struct breakpoint *b;
  int one = 1;

  /* Don't initialize twice.  */
  if (uw_thread_active)
    return;

  /* Check whether libthread.so has been loaded.  */
  if (!(ms = lookup_minimal_symbol ("_thr_debug", NULL, NULL)))
    return;

  /* Cache _thr_debug's address.  */
  if (!(thr_debug_addr = SYMBOL_VALUE_ADDRESS (ms)))
    return;

  /* Initialize base_ops.deprecated_xfer_memory().  */
  base_ops = current_target;

  /* Load _thr_debug's current contents.  */
  if (!read_thr_debug (&debug))
    return;

  /* User code (e.g. my test programs) may dereference _thr_debug,
     making it availble to GDB before shared libs are loaded.  */
  if (!debug.thr_map)
    return;

  /* libthread.so has been loaded, and the current_target should now
     reflect core_ops or procfs_ops.  */
  push_target (&uw_thread_ops);		/* must precede notice_threads() */
  uw_thread_active = 1;

  if (!target_has_execution)

    /* Locate threads in core file.  */
    notice_threads ();

  else
    {
      /* Set a breakpoint on the stub function provided by libthread.so.  */
      thr_brk_addr = (CORE_ADDR)debug.thr_brk;
      if (!(b = create_thread_event_breakpoint (thr_brk_addr)))
	goto err;

      /* Activate the stub function.  */
      onp = (CORE_ADDR)&((struct thread_debug *)thr_debug_addr)->thr_debug_on;
      if (!base_ops.deprecated_xfer_memory ((CORE_ADDR)onp, (char *)&one,
					    sizeof (one), 1, NULL, &base_ops))
	{
	  delete_breakpoint (b);
	  goto err;
	}

      /* Prepare for finding the main thread, which doesn't yet exist.  */
      thr_map_main = 0;
    }

  return;

 err:
  warning (_("uw-thread: unable to initialize user-mode thread debugging."));
  deactivate_uw_thread ();
}

/* deprecated_target_new_objfile_hook callback.

   If OBJFILE is non-null, check whether libthread.so was just loaded,
   and if so, prepare for user-mode thread debugging.

   If OBJFILE is null, libthread.so has gone away, so stop debugging
   user-mode threads.

   This function often gets called with uw_thread_active == 0.  */

static void
uw_thread_new_objfile (struct objfile *objfile)
{
  if (objfile)
    libthread_init ();

  else if (uw_thread_active)
    deactivate_uw_thread ();

  if (target_new_objfile_chain)
    target_new_objfile_chain (objfile);
}

/* Initialize uw_thread_ops.  */

static void
init_uw_thread_ops (void)
{
  uw_thread_ops.to_shortname          = "unixware-threads";
  uw_thread_ops.to_longname           = "UnixWare threads and pthread.";
  uw_thread_ops.to_doc        = "UnixWare threads and pthread support.";
  uw_thread_ops.to_attach             = uw_thread_attach;
  uw_thread_ops.to_detach             = uw_thread_detach;
  uw_thread_ops.to_resume             = uw_thread_resume;
  uw_thread_ops.to_wait               = uw_thread_wait;
  uw_thread_ops.to_fetch_registers    = uw_thread_fetch_registers;
  uw_thread_ops.to_store_registers    = uw_thread_store_registers;
  uw_thread_ops.to_prepare_to_store   = uw_thread_prepare_to_store;
  uw_thread_ops.to_create_inferior    = uw_thread_create_inferior;
  uw_thread_ops.to_kill               = uw_thread_kill;
  uw_thread_ops.to_mourn_inferior     = uw_thread_mourn_inferior;
  uw_thread_ops.to_can_run            = uw_thread_can_run;
  uw_thread_ops.to_thread_alive       = uw_thread_alive;
  uw_thread_ops.to_find_new_threads   = uw_thread_find_new_threads;
  uw_thread_ops.to_pid_to_str         = uw_thread_pid_to_str;
  uw_thread_ops.to_extra_thread_info  = uw_extra_thread_info;
  uw_thread_ops.to_stratum            = thread_stratum;
  uw_thread_ops.to_magic              = OPS_MAGIC;
}

/* Module startup initialization function, automagically called by
   init.c.  */

void
_initialize_uw_thread (void)
{
  init_uw_thread_ops ();
  add_target (&uw_thread_ops);

  procfs_suppress_run = 1;

  /* Notice when libthread.so gets loaded.  */
  target_new_objfile_chain = deprecated_target_new_objfile_hook;
  deprecated_target_new_objfile_hook = uw_thread_new_objfile;
}
@


1.15
log
@Copyright updates for 2007.
@
text
@@


1.14
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 1
a4 1
   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.13
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d4 1
a4 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.12
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* uw-thread.c: Whitespace tweaks.
@
text
@d164 1
a164 1
    error ("uw-thread: no lwp");	\
d257 1
a257 1
	error ("can't open %s\n", path);
d528 1
a528 1
    error ("failed to create new thread structure");
d1005 1
a1005 1
  warning ("uw-thread: unable to initialize user-mode thread debugging\n");
@


1.11
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d97 1
a97 1
   that time. */
d108 1
a108 1
   <sys/types.h>, which doesn't typedef boolean_t with gcc. */
d116 1
a116 1
/* Prototypes for supply_gregset etc. */
d127 1
a127 1
/* Whether to emit debugging output. */
d131 1
a131 1
/* Default debugging output file, overridden by envvar UWTHR_DEBUG. */
d135 1
a135 1
/* #if DEBUG, write string S to the debugging output channel. */
d146 1
a146 1
   inferior_ptid to a composite thread/process id. */
d159 1
a159 1
   Otherwise, issue an error message and return nonlocally. */
d169 1
a169 1
   *CALLED to whether the inferior_ptid conversion was successful. */
d177 1
a177 1
/* Information passed by thread_iter() to its callback parameter. */
d185 1
a185 1
/* Private thread data for the thread_info struct. */
d195 1
a195 1
/* procfs.c's target-specific operations. */
d198 1
a198 1
/* Flag to prevent procfs.c from starting inferior processes. */
d201 1
a201 1
/* This module's target-specific operations. */
d206 1
a206 1
   they lack current_target's default callbacks. */
d219 1
a219 1
   !uw_thread_active. */
d223 1
a223 1
   structure, its thr_brk stub function, and the main thread's map. */
d229 1
a229 1
   libthread.so passes null map when calling stub with tc_*_complete. */
d232 1
a232 1
/* Cleanup chain for safely restoring inferior_ptid after CALL_BASE. */
d238 1
a238 1
   with args and display the result on the debugging output channel. */
d270 1
a270 1
/* Return a string representing composite PID's components. */
d290 1
a290 1
/* Return a string representing thread state CHANGE. */
d309 1
a309 1
/* Return a string representing thread STATE. */
d330 1
a330 1
/* Read the contents of _thr_debug into *DEBUGP.  Return success. */
d341 1
a341 1
   MAPP.  Return success. */
d352 1
a352 1
   LWPP.  Return success. */
d368 1
a368 1
   If a call to FUNC returns nonzero, return that value; otherwise, return 0. */
d406 1
a406 1
/* Deactivate user-mode thread support. */
d417 1
a417 1
   id PID.  If PID is a thread with no lwp, return 0. */
d439 1
a439 1
   associated with lwp id DATA. */
d458 1
a458 1
   member of the global thread list; otherwise, return null. */
d467 1
a467 1
   id PID.  If PID is an lwp with no thread, return PID. */
d490 1
a490 1
   thread/process id after having made a procfs call. */
d502 1
a502 1
   preparation for making a procfs call.  Return success. */
d520 1
a520 1
   lwp id LWPID, map address MAPP, and composite thread/process PID. */
d542 1
a542 1
   thread or if !DATA. */
d557 1
a557 1
/* Add to the thread list any threads it doesn't already contain. */
d565 1
a565 1
/* Return the address of the main thread's map.  On error, return 0. */
d583 1
a583 1
   This function only gets called with uw_thread_active == 0. */
d593 1
a593 1
/* Detach from the process attached to by uw_thread_attach(). */
d603 1
a603 1
   and all threads otherwise. */
d620 1
a620 1
   accordingly. */
d633 1
a633 1
  /* Check for stub breakpoint. */
d637 1
a637 1
  /* Retrieve stub args. */
d648 1
a648 1
     thread to ensure that it's displayed first by add_thread(). */
d651 1
a651 1
  /* Notice thread creation, deletion, or stability change. */
d709 1
a709 1
	   its thread list entry. */
d740 1
a740 1
/* Wait for thread/lwp/process ID if >= 0 or for any thread otherwise. */
d760 1
a760 1
   inferior_ptid. */
d783 1
a783 1
   specified by inferior_ptid. */
d791 1
a791 1
/* Prepare to modify the registers array. */
d801 1
a801 1
   This function only gets called with uw_thread_active == 0. */
d818 1
a818 1
/* Kill and forget about the inferior process. */
d826 1
a826 1
/* Clean up after the inferior exits. */
d837 1
a837 1
   This function only gets called with uw_thread_active == 0. */
d845 1
a845 1
/* Return whether thread PID is still valid. */
d854 1
a854 1
     libthread_stub() would have deleted it. */
d858 1
a858 1
/* Add to the thread list any threads and lwps it doesn't already contain. */
d869 1
a869 1
   This may be called by either procfs.c or by generic gdb. */
d878 1
a878 1
    /* core_ops says "process foo", so call procfs_ops explicitly. */
d887 1
a887 1
   output. */
d937 1
a937 1
   This function often gets called with uw_thread_active == 0. */
d948 1
a948 1
  /* Don't initialize twice. */
d952 1
a952 1
  /* Check whether libthread.so has been loaded. */
d956 1
a956 1
  /* Cache _thr_debug's address. */
d963 1
a963 1
  /* Load _thr_debug's current contents. */
d968 1
a968 1
     making it availble to GDB before shared libs are loaded. */
d973 1
a973 1
     reflect core_ops or procfs_ops. */
d979 1
a979 1
    /* Locate threads in core file. */
d984 1
a984 1
      /* Set a breakpoint on the stub function provided by libthread.so. */
d989 1
a989 1
      /* Activate the stub function. */
d998 1
a998 1
      /* Prepare for finding the main thread, which doesn't yet exist. */
d1017 1
a1017 1
   This function often gets called with uw_thread_active == 0. */
d1032 1
a1032 1
/* Initialize uw_thread_ops. */
d1060 1
a1060 1
   init.c. */
d1070 1
a1070 1
  /* Notice when libthread.so gets loaded. */
@


1.10
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@d335 3
a337 2
  return base_ops.to_xfer_memory (thr_debug_addr, (char *)debugp,
				  sizeof (*debugp), 0, NULL, &base_ops);
d346 3
a348 2
  return base_ops.to_xfer_memory ((CORE_ADDR)THR_MAP (mapp), (char *)map,
				  sizeof (*map), 0, NULL, &base_ops);
d357 2
a358 2
  return base_ops.to_xfer_memory (lwpp, (char *)lwp,
				  sizeof (*lwp), 0, NULL, &base_ops);
d380 3
a382 2
  if (!base_ops.to_xfer_memory ((CORE_ADDR)debug.thr_map, (char *)&mapp,
				sizeof (mapp), 0, NULL, &base_ops))
d639 2
a640 2
  if (!base_ops.to_xfer_memory (sp + SP_ARG0, (char *)&mapp,
				sizeof (mapp), 0, NULL, &base_ops))
d642 3
a644 2
  if (!base_ops.to_xfer_memory (sp + SP_ARG0 + sizeof (mapp), (char *)&change,
				sizeof (change), 0, NULL, &base_ops))
d960 1
a960 1
  /* Initialize base_ops.to_xfer_memory(). */
d991 2
a992 2
      if (!base_ops.to_xfer_memory ((CORE_ADDR)onp, (char *)&one,
				    sizeof (one), 1, NULL, &base_ops))
@


1.9
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d800 2
a801 1
uw_thread_create_inferior (char *exec_file, char *allargs, char **env)
d806 1
a806 1
  procfs_ops.to_create_inferior (exec_file, allargs, env);
@


1.8
log
@* uw-thread.c (SP_ARG0): Define if not already defined.
* config/i386/tm-i386.h (SO_ARG0): Remove define.
@
text
@d209 2
a210 1
/* Saved pointer to previous owner of target_new_objfile_hook. */
d1004 1
a1004 1
/* target_new_objfile_hook callback.
d1066 2
a1067 2
  target_new_objfile_chain = target_new_objfile_hook;
  target_new_objfile_hook = uw_thread_new_objfile;
@


1.8.56.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d209 1
a209 2
/* Saved pointer to previous owner of
   deprecated_target_new_objfile_hook.  */
d799 1
a799 2
uw_thread_create_inferior (char *exec_file, char *allargs, char **env,
			   int from_tty)
d804 1
a804 1
  procfs_ops.to_create_inferior (exec_file, allargs, env, from_tty);
d1003 1
a1003 1
/* deprecated_target_new_objfile_hook callback.
d1065 2
a1066 2
  target_new_objfile_chain = deprecated_target_new_objfile_hook;
  deprecated_target_new_objfile_hook = uw_thread_new_objfile;
@


1.7
log
@Phase 1 of the ptid_t changes.
@
text
@d119 8
@


1.7.16.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a118 8
/* Offset from SP to first arg on stack at first instruction of a
   function.  We provide a default here that's right for most, if not
   all, targets that use this file.  */

#ifndef SP_ARG0
#define SP_ARG0 (1 * 4)
#endif

@


1.6
log
@Pass NULL for the mem_attrib argument in the to_xfer_memory calls.
@
text
@d138 1
a138 1
   inferior_pid to a composite thread/process id. */
d147 2
a148 2
/* If inferior_pid can be converted to a composite lwp/process id, do so,
   evaluate base_ops function CALL, and then convert inferior_pid back to a
d161 1
a161 1
   *CALLED to whether the inferior_pid conversion was successful. */
d223 1
a223 1
/* Cleanup chain for safely restoring inferior_pid after CALL_BASE. */
d264 1
a264 1
dbgpid (int pid)
d272 2
a273 2
  if (pid <= 0)
    sprintf (buf, "%d", pid);
d275 1
a275 1
    sprintf (buf, "%s %d/%d", ISTID (pid) ? "thr" : "lwp",
d407 2
a408 2
static int
thr_to_lwp (int pid)
d411 1
a411 1
  int lid;
d413 4
a416 4
  if (!ISTID (pid))
    lid = pid;
  else if (!(info = find_thread_pid (pid)))
    lid = 0;
d418 1
a418 1
    lid = 0;
d420 1
a420 1
    lid = MKLID (pid, info->private->lwpid);
d434 1
a434 1
  if (!ISTID (tp->pid))
d457 2
a458 2
static int
lwp_to_thr (int pid)
d461 2
a462 1
  int tid = pid, lwpid;
d464 1
a464 1
  if (ISTID (pid))
d466 1
a466 1
  if (!(lwpid = LIDGET (pid)))
d470 1
a470 1
  tid = MKTID (pid, info->private->thrid);
d473 1
a473 1
  DBG2((ISTID (tid) ? NULL : "lwp_to_thr: no thr for %s", dbgpid (pid)));
d477 1
a477 1
/* do_cleanups() callback: convert inferior_pid to a composite
d483 4
a486 4
  int pid = lwp_to_thr (inferior_pid);
  DBG2((" inferior_pid from procfs: %s => %s",
	dbgpid (inferior_pid), dbgpid (pid)));
  inferior_pid = pid;
d489 1
a489 1
/* If possible, convert inferior_pid to a composite lwp/process id in
d495 3
a497 3
  int pid = thr_to_lwp (inferior_pid);
  DBG2((" inferior_pid to procfs: %s => %s",
	dbgpid (inferior_pid), dbgpid (pid)));
d499 1
a499 1
  if (!pid)
d502 1
a502 1
  inferior_pid = pid;
d511 1
a511 1
add_thread_uw (int thrid, int lwpid, CORE_ADDR mapp, int pid)
d515 1
a515 1
  if ((newthread = add_thread (pid)) == NULL)
d525 1
a525 1
    printf_unfiltered ("[New %s]\n", target_pid_to_str (pid));
d537 1
a537 1
  int pid = MKTID (inferior_pid, thrid);
d539 2
a540 2
  if (!find_thread_pid (pid) && (!data || thrid == 1))
    add_thread_uw (thrid, lwpid, iter->mapp, pid);
d562 1
a562 1
      if ((info = find_thread_pid (MKTID (inferior_pid, 1))))
d594 1
a594 1
uw_thread_resume (int pid, int step, enum target_signal signo)
d596 6
a601 2
  if (pid > 0 && !(pid = thr_to_lwp (pid)))
    pid = -1;
d603 1
a603 1
  CALL_BASE (base_ops.to_resume (pid, step, signo));
d611 1
a611 1
libthread_stub (int pid)
d617 2
a618 1
  int tid = 0, lwpid;
d622 1
a622 1
  if (read_pc_pid (pid) - DECR_PC_AFTER_BREAK != thr_brk_addr)
d626 1
a626 1
  sp = read_register_pid (SP_REGNUM, pid);
d651 1
a651 1
    tid = MKTID (pid, map.thr_tid);
d667 2
a668 2
      if (tid == inferior_pid)
	inferior_pid = pid;
d729 2
a730 2
static int
uw_thread_wait (int pid, struct target_waitstatus *status)
d732 6
a737 3
  if (pid > 0)
    pid = thr_to_lwp (pid);
  CALL_BASE (pid = base_ops.to_wait (pid > 0 ? pid : -1, status));
d741 1
a741 1
    libthread_stub (pid);
d743 1
a743 1
  return lwp_to_thr (pid);
d747 1
a747 1
   inferior_pid. */
d760 1
a760 1
  if (!(info = find_thread_pid (inferior_pid)))
d770 1
a770 1
   specified by inferior_pid. */
d834 1
a834 1
uw_thread_alive (int pid)
d836 2
a837 2
  if (!ISTID (pid))
    return base_ops.to_thread_alive (pid);
d841 1
a841 1
  return in_thread_list (pid);
d858 1
a858 1
uw_thread_pid_to_str (int pid)
d860 2
a861 2
#define FMT "Thread %d"
  static char buf[sizeof (FMT) + 3 * sizeof (pid)];
d863 1
a863 1
  if (!ISTID (pid))
d865 1
a865 1
    return procfs_ops.to_pid_to_str (pid);
d867 1
a867 1
  sprintf (buf, FMT, TIDGET (pid));
d884 1
a884 1
  if (!ISTID (info->pid))
@


1.5
log
@Create new file regcache.h.  Update all uses.
@
text
@d327 1
a327 1
				  sizeof (*debugp), 0, &base_ops);
d337 1
a337 1
				  sizeof (*map), 0, &base_ops);
d347 1
a347 1
				  sizeof (*lwp), 0, &base_ops);
d370 1
a370 1
				sizeof (mapp), 0, &base_ops))
d622 1
a622 1
				sizeof (mapp), 0, &base_ops))
d625 1
a625 1
				sizeof (change), 0, &base_ops))
d969 1
a969 1
				    sizeof (one), 1, &base_ops))
@


1.4
log
@2000-05-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gregset.h: New file.  Typedefs for gdb_gregset_t and
        gdb_fpregset_t, prototypes for supply_gregset and friends.
        * procfs.c: Include gregset.h.  Delete local prototypes for
        supply_gregset etc., and local typedef gdb_gregset_t etc.
        * sol-thread.c: Include gregset.h, delete local prototypes,
        add appropriate casts to gdb_gregset_t.
        * uw-thread.c, lin-thread.c, core-sol2.c, core-regset.c,
        sparc-tdep.c, ptx4-nat.c, ppc-linux-nat.c, mipsv4-nat.c,
        m88k-nat.c, m68klinux-nat.c, m68k-tdep.c, irix5-nat.c,
        irix4-nat.c, ia64-linux-nat.c, i386v4-nat.c, cxux-nat.c,
        arm-linux-nat.c, alpha-nat.c: Include gregset.h.
        * config/nm-linux.h: Define GDB_GREGSET_T, GDB_FPREGET_T.
        * config/sparc/tm-sun4sol2.h: Ditto.
@
text
@d4 1
a4 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d104 1
@


1.3
log
@	* uw-thread.c: Apply GNU conventions to comment formatting.
	(deactivate_uw_thread): Call remove_thread_event_breakpoints().
	(uw_thread_mourn_inferior): Move remove_thread_event_breakpoints()
	call to deactivate_uw_thread().
@
text
@d115 2
@


1.2
log
@	* uw-thread.c: Remove __FUNCTION__ GNUism.
@
text
@d106 3
a108 4
/*
 * <thread.h> includes <sys/priocntl.h>, which requires boolean_t from
 * <sys/types.h>, which doesn't typedef boolean_t with gcc.
 */
d116 2
a117 3
/*
 * Whether to emit debugging output.
 */
d120 2
a121 3
/*
 * Default debugging output file, overridden by envvar UWTHR_DEBUG.
 */
d124 2
a125 3
/*
 * #if DEBUG, write string S to the debugging output channel.
 */
d134 3
a136 4
/*
 * Back end to CALL_BASE() and TRY_BASE(): evaluate CALL, then convert
 * inferior_pid to a composite thread/process id.
 */
d144 6
a149 7
/*
 * If inferior_pid can be converted to a composite lwp/process id, do so,
 * evaluate base_ops function CALL, and then convert inferior_pid back to a
 * composite thread/process id.
 *
 * Otherwise, issue an error message and return nonlocally.
 */
d157 3
a159 4
/*
 * Like CALL_BASE(), but instead of returning nonlocally on error, set
 * *CALLED to whether the inferior_pid conversion was successful.
 */
d166 2
a167 3
/*
 * Information passed by thread_iter() to its callback parameter.
 */
d174 2
a175 3
/*
 * Private thread data for the thread_info struct.
 */
d225 3
a227 4
/*
 * Helper function for DBG() macro: if printf-style FMT is non-null, format it
 * with args and display the result on the debugging output channel.
 */
d258 2
a259 3
/*
 * Return a string representing composite PID's components.
 */
d278 2
a279 3
/*
 * Return a string representing thread state CHANGE.
 */
d297 2
a298 3
/*
 * Return a string representing thread STATE.
 */
d318 2
a319 3
/*
 * Read the contents of _thr_debug into *DEBUGP.  Return success.
 */
d327 3
a329 4
/*
 * Read into MAP the contents of the thread map at inferior process address
 * MAPP.  Return success.
 */
d337 3
a339 4
/*
 * Read into LWP the contents of the lwp decriptor at inferior process address
 * LWPP.  Return success.
 */
d347 9
a355 10
/*
 * Iterate through all user threads, applying FUNC(<map>, <lwp>, DATA) until
 *   (a) FUNC returns nonzero,
 *   (b) FUNC has been applied to all threads, or
 *   (c) an error occurs,
 * where <map> is the thread's struct thread_map and <lwp> if non-null is the
 * thread's current __lwp_desc_t.
 *
 * If a call to FUNC returns nonzero, return that value; otherwise, return 0.
 */
d391 2
a392 3
/*
 * Deactivate user-mode thread support.
 */
d396 1
d401 3
a403 4
/*
 * Return the composite lwp/process id corresponding to composite
 * id PID.  If PID is a thread with no lwp, return 0.
 */
d423 3
a425 4
/*
 * find_thread_lwp() callback: return whether TP describes a thread
 * associated with lwp id DATA.
 */
d442 3
a444 4
/*
 * If a thread is associated with lwp id LWPID, return the corresponding
 * member of the global thread list; otherwise, return null.
 */
d451 3
a453 4
/*
 * Return the composite thread/process id corresponding to composite
 * id PID.  If PID is an lwp with no thread, return PID.
 */
d473 3
a475 4
/*
 * do_cleanups() callback: convert inferior_pid to a composite
 * thread/process id after having made a procfs call.
 */
d485 3
a487 4
/*
 * If possible, convert inferior_pid to a composite lwp/process id in
 * preparation for making a procfs call.  Return success.
 */
d503 3
a505 4
/*
 * Add to the global thread list a new user-mode thread with system id THRID,
 * lwp id LWPID, map address MAPP, and composite thread/process PID.
 */
d524 4
a527 5
/*
 * notice_threads() and find_main() callback: if the thread list doesn't
 * already contain the thread described by ITER, add it if it's the main
 * thread or if !DATA.
 */
d541 2
a542 3
/*
 * Add to the thread list any threads it doesn't already contain.
 */
d549 2
a550 3
/*
 * Return the address of the main thread's map.  On error, return 0.
 */
d564 5
a568 6
/*
 * Attach to process specified by ARGS, then initialize for debugging it
 * and wait for the trace-trap that results from attaching.
 *
 * This function only gets called with uw_thread_active == 0.
 */
d577 2
a578 3
/*
 * Detach from the process attached to by uw_thread_attach().
 */
d586 3
a588 4
/*
 * Tell the inferior process to continue running thread PID if >= 0
 * and all threads otherwise.
 */
d598 4
a601 5
/*
 * If the trap we just received from lwp PID was due to a breakpoint
 * on the libthread.so debugging stub, update this module's state
 * accordingly.
 */
d682 7
a688 8
	/*
	 * If switchto_thread is the main thread, then (a) the corresponding
	 * tc_switch_begin probably received a null map argument and therefore
	 * (b) it may have been a spurious switch following a tc_thread_exit.
	 *
	 * Therefore, explicitly query the thread's lwp before caching it in
	 * its thread list entry.
	 */
d718 2
a719 3
/*
 * Wait for thread/lwp/process ID if >= 0 or for any thread otherwise.
 */
d734 3
a736 4
/*
 * Tell gdb about the registers in the thread/lwp/process specified by
 * inferior_pid.
 */
d757 3
a759 4
/*
 * Store gdb's current view of the register set into the thread/lwp/process
 * specified by inferior_pid.
 */
d766 2
a767 3
/*
 * Prepare to modify the registers array.
 */
d774 4
a777 5
/*
 * Fork an inferior process and start debugging it.
 *
 * This function only gets called with uw_thread_active == 0.
 */
d792 2
a793 3
/*
 * Kill and forget about the inferior process.
 */
d800 2
a801 3
/*
 * Clean up after the inferior exits.
 */
a804 1
  remove_thread_event_breakpoints ();
d809 4
a812 5
/*
 * Return whether this module can attach to and run processes.
 *
 * This function only gets called with uw_thread_active == 0.
 */
d819 2
a820 3
/*
 * Return whether thread PID is still valid.
 */
d832 2
a833 3
/*
 * Add to the thread list any threads and lwps it doesn't already contain.
 */
d842 3
a844 4
/*
 * Return a string for pretty-printing PID in "info threads" output.
 * This may be called by either procfs.c or by generic gdb.
 */
d860 3
a862 4
/*
 * Return a string displaying INFO state information in "info threads"
 * output.
 */
d905 8
a912 9
/*
 * Check whether libthread.so has just been loaded, and if so, try to
 * initialize user-space thread debugging support.
 *
 * libthread.so loading happens while (a) an inferior process is being
 * started by procfs and (b) a core image is being loaded.
 *
 * This function often gets called with uw_thread_active == 0.
 */
d983 10
a992 11
/*
 * target_new_objfile_hook callback.
 *
 * If OBJFILE is non-null, check whether libthread.so was just loaded,
 * and if so, prepare for user-mode thread debugging.
 *
 * If OBJFILE is null, libthread.so has gone away, so stop debugging
 * user-mode threads.
 *
 * This function often gets called with uw_thread_active == 0.
 */
d1006 2
a1007 3
/*
 * Initialize uw_thread_ops.
 */
d1033 3
a1035 4
/*
 * Module startup initialization function, automagically called by
 * init.c.
 */
@


1.1
log
@Initial revision
@
text
@d5 1
d156 5
a160 5
#define CALL_BASE(call)					\
do {							\
  if (!lwp_infpid ())					\
    error ("uw-thread: "__FUNCTION__": no lwp");	\
  CALL_BASE_1 (call);					\
@


1.1.1.1
log
@import gdb-2000-01-17 snapshot
@
text
@@
