head	1.74;
access;
symbols
	gdb_6_3-20041109-release:1.71
	gdb_6_3-branch:1.71.0.2
	gdb_6_3-20041019-branchpoint:1.71
	drow_intercu-merge-20040921:1.71
	drow_intercu-merge-20040915:1.71
	jimb-gdb_6_2-e500-branch:1.70.0.6
	jimb-gdb_6_2-e500-branchpoint:1.70
	gdb_6_2-20040730-release:1.70
	gdb_6_2-branch:1.70.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.70
	gdb_6_1_1-20040616-release:1.64
	gdb_6_1-2004-04-05-release:1.64
	drow_intercu-merge-20040402:1.64
	drow_intercu-merge-20040327:1.64
	ezannoni_pie-20040323-branch:1.64.0.10
	ezannoni_pie-20040323-branchpoint:1.64
	cagney_tramp-20040321-mergepoint:1.64
	cagney_tramp-20040309-branch:1.64.0.8
	cagney_tramp-20040309-branchpoint:1.64
	gdb_6_1-branch:1.64.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.64
	drow_intercu-20040221-branch:1.64.0.4
	drow_intercu-20040221-branchpoint:1.64
	cagney_bfdfile-20040213-branch:1.64.0.2
	cagney_bfdfile-20040213-branchpoint:1.64
	drow-cplus-merge-20040208:1.64
	carlton_dictionary-20040126-merge:1.63
	cagney_bigcore-20040122-branch:1.63.0.2
	cagney_bigcore-20040122-branchpoint:1.63
	drow-cplus-merge-20040113:1.63
	drow-cplus-merge-20031224:1.63
	drow-cplus-merge-20031220:1.63
	carlton_dictionary-20031215-merge:1.63
	drow-cplus-merge-20031214:1.63
	carlton-dictionary-20031111-merge:1.62
	gdb_6_0-2003-10-04-release:1.50.6.1
	kettenis_sparc-20030918-branch:1.56.0.4
	kettenis_sparc-20030918-branchpoint:1.56
	carlton_dictionary-20030917-merge:1.56
	ezannoni_pie-20030916-branchpoint:1.56
	ezannoni_pie-20030916-branch:1.56.0.2
	cagney_x86i386-20030821-branch:1.52.0.2
	cagney_x86i386-20030821-branchpoint:1.52
	carlton_dictionary-20030805-merge:1.52
	carlton_dictionary-20030627-merge:1.50
	gdb_6_0-branch:1.50.0.6
	gdb_6_0-2003-06-23-branchpoint:1.50
	jimb-ppc64-linux-20030613-branch:1.50.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.50
	cagney_convert-20030606-branch:1.50.0.2
	cagney_convert-20030606-branchpoint:1.50
	cagney_writestrings-20030508-branch:1.48.0.6
	cagney_writestrings-20030508-branchpoint:1.48
	jimb-ppc64-linux-20030528-branch:1.49.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.49
	carlton_dictionary-20030523-merge:1.49
	cagney_fileio-20030521-branch:1.49.0.2
	cagney_fileio-20030521-branchpoint:1.49
	kettenis_i386newframe-20030517-mergepoint:1.49
	jimb-ppc64-linux-20030509-branch:1.48.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.48
	kettenis_i386newframe-20030504-mergepoint:1.48
	carlton_dictionary-20030430-merge:1.48
	kettenis_i386newframe-20030419-branch:1.48.0.2
	kettenis_i386newframe-20030419-branchpoint:1.48
	carlton_dictionary-20030416-merge:1.47
	cagney_frameaddr-20030409-mergepoint:1.47
	kettenis_i386newframe-20030406-branch:1.47.0.14
	kettenis_i386newframe-20030406-branchpoint:1.47
	cagney_frameaddr-20030403-branchpoint:1.47
	cagney_frameaddr-20030403-branch:1.47.0.12
	cagney_framebase-20030330-mergepoint:1.47
	cagney_framebase-20030326-branch:1.47.0.10
	cagney_framebase-20030326-branchpoint:1.47
	cagney_lazyid-20030317-branch:1.47.0.8
	cagney_lazyid-20030317-branchpoint:1.47
	kettenis-i386newframe-20030316-mergepoint:1.47
	offbyone-20030313-branch:1.47.0.6
	offbyone-20030313-branchpoint:1.47
	kettenis-i386newframe-20030308-branch:1.47.0.4
	kettenis-i386newframe-20030308-branchpoint:1.47
	carlton_dictionary-20030305-merge:1.47
	cagney_offbyone-20030303-branch:1.47.0.2
	cagney_offbyone-20030303-branchpoint:1.47
	carlton_dictionary-20030207-merge:1.46
	interps-20030203-mergepoint:1.44
	interps-20030202-branch:1.44.0.2
	interps-20030202-branchpoint:1.44
	cagney-unwind-20030108-branch:1.43.0.2
	cagney-unwind-20030108-branchpoint:1.43
	carlton_dictionary-20021223-merge:1.42
	gdb_5_3-2002-12-12-release:1.40.6.1
	carlton_dictionary-20021115-merge:1.42
	kseitz_interps-20021105-merge:1.42
	kseitz_interps-20021103-merge:1.41
	drow-cplus-merge-20021020:1.41
	drow-cplus-merge-20021025:1.41
	carlton_dictionary-20021025-merge:1.41
	carlton_dictionary-20021011-merge:1.41
	drow-cplus-branch:1.41.0.4
	drow-cplus-branchpoint:1.41
	kseitz_interps-20020930-merge:1.41
	carlton_dictionary-20020927-merge:1.41
	carlton_dictionary-branch:1.41.0.2
	carlton_dictionary-20020920-branchpoint:1.41
	gdb_5_3-branch:1.40.0.6
	gdb_5_3-2002-09-04-branchpoint:1.40
	kseitz_interps-20020829-merge:1.40
	cagney_sysregs-20020825-branch:1.40.0.4
	cagney_sysregs-20020825-branchpoint:1.40
	readline_4_3-import-branch:1.40.0.2
	readline_4_3-import-branchpoint:1.40
	gdb_5_2_1-2002-07-23-release:1.34
	kseitz_interps-20020528-branch:1.35.0.4
	kseitz_interps-20020528-branchpoint:1.35
	cagney_regbuf-20020515-branch:1.35.0.2
	cagney_regbuf-20020515-branchpoint:1.35
	jimb-macro-020506-branch:1.34.0.4
	jimb-macro-020506-branchpoint:1.34
	gdb_5_2-2002-04-29-release:1.34
	gdb_5_2-branch:1.34.0.2
	gdb_5_2-2002-03-03-branchpoint:1.34
	gdb_5_1_1-2002-01-24-release:1.21
	gdb_5_1_0_1-2002-01-03-release:1.21
	cygnus_cvs_20020108_pre:1.33
	gdb_5_1_0_1-2002-01-03-branchpoint:1.21
	gdb_5_1_0_1-2002-01-03-branch:1.21.0.6
	gdb_5_1-2001-11-21-release:1.21
	gdb_s390-2001-09-26-branch:1.21.0.4
	gdb_s390-2001-09-26-branchpoint:1.21
	gdb_5_1-2001-07-29-branch:1.21.0.2
	gdb_5_1-2001-07-29-branchpoint:1.21
	dberlin-typesystem-branch:1.19.0.2
	dberlin-typesystem-branchpoint:1.19
	gdb-post-ptid_t-2001-05-03:1.15
	gdb-pre-ptid_t-2001-05-03:1.15
	insight-precleanup-2001-01-01:1.12
	gdb-post-protoization-2000-07-29:1.9
	gdb-pre-protoization-2000-07-29:1.8
	gdb-premipsmulti-2000-06-06-branch:1.6.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb-post-params-removal-2000-06-04:1.6
	gdb-pre-params-removal-2000-06-04:1.6
	gdb-post-params-removal-2000-05-28:1.6
	gdb-pre-params-removal-2000-05-28:1.5
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.6
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.6
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.5
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.5
	gdb-pre-reformat-19990707:1.1.1.4
	gdb-1999-07-07:1.1.1.4
	gdb-1999-07-05:1.1.1.4
	gdb-1999-06-28:1.1.1.4
	gdb-1999-06-21:1.1.1.4
	gdb-1999-06-14:1.1.1.4
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.74
date	2004.11.09.20.41.57;	author cagney;	state dead;
branches;
next	1.73;

1.73
date	2004.11.09.14.43.27;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2004.11.01.11.14.38;	author hilfingr;	state Exp;
branches;
next	1.71;

1.71
date	2004.07.28.02.46.24;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2004.06.20.18.10.14;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2004.06.20.17.18.06;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2004.06.13.15.15.59;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2004.06.13.13.42.32;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2004.06.12.18.02.30;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2004.05.08.23.02.10;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.26.20.52.12;	author cagney;	state Exp;
branches
	1.64.4.1;
next	1.63;

1.63
date	2003.11.19.16.27.56;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2003.11.10.22.47.28;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2003.10.23.22.36.14;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2003.10.20.15.38.02;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2003.10.02.04.40.58;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2003.10.01.18.48.12;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2003.09.21.01.26.45;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2003.09.15.20.15.19;	author drow;	state Exp;
branches;
next	1.54;

1.54
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2003.09.13.21.31.33;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2003.07.31.23.41.25;	author msnyder;	state Exp;
branches;
next	1.51;

1.51
date	2003.07.30.20.59.10;	author msnyder;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.05.20.59.16;	author cagney;	state Exp;
branches
	1.50.6.1;
next	1.49;

1.49
date	2003.05.14.17.43.20;	author ezannoni;	state Exp;
branches;
next	1.48;

1.48
date	2003.04.17.20.31.43;	author ezannoni;	state Exp;
branches
	1.48.2.1
	1.48.6.1;
next	1.47;

1.47
date	2003.02.20.00.01.07;	author carlton;	state Exp;
branches;
next	1.46;

1.46
date	2003.02.07.00.27.30;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2003.02.04.23.59.26;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2003.01.06.18.49.09;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2002.11.05.08.25.13;	author muller;	state Exp;
branches;
next	1.41;

1.41
date	2002.09.18.15.43.47;	author drow;	state Exp;
branches
	1.41.2.1
	1.41.4.1;
next	1.40;

1.40
date	2002.08.24.00.21.35;	author cagney;	state Exp;
branches
	1.40.6.1;
next	1.39;

1.39
date	2002.08.19.23.19.53;	author carlton;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.03.21.27.55;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.03.20.36.54;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.14.22.55.41;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.11.23.48.23;	author drow;	state Exp;
branches
	1.35.2.1
	1.35.4.1;
next	1.34;

1.34
date	2002.01.29.03.08.26;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2002.01.04.18.20.19;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.04.05.20.08;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.11.18.35.38;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.10.23.05.00;	author fnf;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.30.17.47.51;	author drow;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.29.17.37.38;	author jimb;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.09.16.41.50;	author jimb;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.07.22.42.29;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.16.01.58.07;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.15.18.18.29;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.24.17.16.53;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.01.18.39.24;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.10.21.24.48;	author jimb;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.08.20.42.15;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.15.19.19.23;	author cagney;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.06.10.16.25.51;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.21.20.08.59;	author jimb;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.19.15.20.14;	author dberlin;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.27.00.19.09;	author jimb;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.27.20.36.24;	author jtc;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.06.08.21.18;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.15.01.01.50;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.10.01.19.47;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.30.15.32.51;	author taylor;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.17.03.39.34;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.09.00.51.55;	author fnasser;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.28.01.12.33;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.19.23.22.14;	author jimb;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.14.18.43.41;	author jimb;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.04.04.53.49;	author dberlin;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.21.01.27.34;	author msnyder;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.50;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.06.01.15.41.00;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.06.14.18.08.11;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.07.20.11.09;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.08.23.59.39;	author shebs;	state Exp;
branches;
next	;

1.19.2.1
date	2001.07.06.19.17.04;	author dberlin;	state Exp;
branches;
next	;

1.35.2.1
date	2002.05.16.00.54.56;	author cagney;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2002.05.16.19.08.01;	author cagney;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2002.06.15.16.42.55;	author cagney;	state Exp;
branches;
next	1.35.2.4;

1.35.2.4
date	2002.06.15.19.32.43;	author cagney;	state Exp;
branches;
next	1.35.2.5;

1.35.2.5
date	2002.06.21.16.19.33;	author cagney;	state Exp;
branches;
next	1.35.2.6;

1.35.2.6
date	2002.06.21.19.35.25;	author cagney;	state Exp;
branches;
next	1.35.2.7;

1.35.2.7
date	2002.06.25.20.02.42;	author cagney;	state Exp;
branches;
next	;

1.35.4.1
date	2002.06.20.01.33.20;	author kseitz;	state Exp;
branches;
next	1.35.4.2;

1.35.4.2
date	2002.07.22.21.47.04;	author kseitz;	state Exp;
branches;
next	1.35.4.3;

1.35.4.3
date	2002.08.30.22.52.46;	author kseitz;	state Exp;
branches;
next	1.35.4.4;

1.35.4.4
date	2002.10.01.00.46.15;	author kseitz;	state Exp;
branches;
next	1.35.4.5;

1.35.4.5
date	2002.11.05.20.31.21;	author ezannoni;	state Exp;
branches;
next	;

1.40.6.1
date	2002.09.18.17.54.56;	author drow;	state Exp;
branches;
next	;

1.41.2.1
date	2002.10.18.23.42.59;	author carlton;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.11.15.19.19.00;	author carlton;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.12.21.00.17.44;	author carlton;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2003.02.07.19.17.54;	author carlton;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2003.03.06.00.56.33;	author carlton;	state Exp;
branches;
next	1.41.2.6;

1.41.2.6
date	2003.05.01.00.46.53;	author carlton;	state Exp;
branches;
next	1.41.2.7;

1.41.2.7
date	2003.06.27.21.50.13;	author carlton;	state Exp;
branches;
next	1.41.2.8;

1.41.2.8
date	2003.09.17.21.28.36;	author carlton;	state Exp;
branches;
next	1.41.2.9;

1.41.2.9
date	2003.11.11.23.50.59;	author carlton;	state Exp;
branches;
next	1.41.2.10;

1.41.2.10
date	2003.12.16.00.00.51;	author carlton;	state Exp;
branches;
next	;

1.41.4.1
date	2003.12.14.20.27.33;	author drow;	state Exp;
branches;
next	1.41.4.2;

1.41.4.2
date	2004.02.09.19.43.49;	author drow;	state Exp;
branches;
next	;

1.48.2.1
date	2003.05.18.09.44.26;	author kettenis;	state Exp;
branches;
next	;

1.48.6.1
date	2003.06.03.20.54.41;	author cagney;	state Exp;
branches;
next	;

1.50.6.1
date	2003.09.21.19.11.46;	author drow;	state Exp;
branches;
next	;

1.64.4.1
date	2004.09.16.17.01.26;	author drow;	state Exp;
branches;
next	;


desc
@@


1.74
log
@2004-11-09  Andrew Cagney  <cagney@@gnu.org>

	* values.c: Rename to ...
	* value.c: ..., new file.
	* Makefile.in: Update.
@
text
@/* Low level packing and unpacking of values for GDB, the GNU Debugger.

   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003 Free Software
   Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "gdb_string.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "value.h"
#include "gdbcore.h"
#include "command.h"
#include "gdbcmd.h"
#include "target.h"
#include "language.h"
#include "scm-lang.h"
#include "demangle.h"
#include "doublest.h"
#include "gdb_assert.h"
#include "regcache.h"
#include "block.h"

/* Prototypes for exported functions. */

void _initialize_values (void);

/* Prototypes for local functions. */

static void show_values (char *, int);

static void show_convenience (char *, int);


/* The value-history records all the values printed
   by print commands during this session.  Each chunk
   records 60 consecutive values.  The first chunk on
   the chain records the most recent values.
   The total number of values is in value_history_count.  */

#define VALUE_HISTORY_CHUNK 60

struct value_history_chunk
  {
    struct value_history_chunk *next;
    struct value *values[VALUE_HISTORY_CHUNK];
  };

/* Chain of chunks now in use.  */

static struct value_history_chunk *value_history_chain;

static int value_history_count;	/* Abs number of last entry stored */

/* List of all value objects currently allocated
   (except for those released by calls to release_value)
   This is so they can be freed after each command.  */

static struct value *all_values;

/* Allocate a  value  that has the correct length for type TYPE.  */

struct value *
allocate_value (struct type *type)
{
  struct value *val;
  struct type *atype = check_typedef (type);

  val = (struct value *) xmalloc (sizeof (struct value) + TYPE_LENGTH (atype));
  VALUE_NEXT (val) = all_values;
  all_values = val;
  VALUE_TYPE (val) = type;
  VALUE_ENCLOSING_TYPE (val) = type;
  VALUE_LVAL (val) = not_lval;
  VALUE_ADDRESS (val) = 0;
  VALUE_FRAME_ID (val) = null_frame_id;
  VALUE_OFFSET (val) = 0;
  VALUE_BITPOS (val) = 0;
  VALUE_BITSIZE (val) = 0;
  VALUE_REGNO (val) = -1;
  VALUE_LAZY (val) = 0;
  VALUE_OPTIMIZED_OUT (val) = 0;
  VALUE_EMBEDDED_OFFSET (val) = 0;
  VALUE_POINTED_TO_OFFSET (val) = 0;
  val->modifiable = 1;
  return val;
}

/* Allocate a  value  that has the correct length
   for COUNT repetitions type TYPE.  */

struct value *
allocate_repeat_value (struct type *type, int count)
{
  int low_bound = current_language->string_lower_bound;		/* ??? */
  /* FIXME-type-allocation: need a way to free this type when we are
     done with it.  */
  struct type *range_type
  = create_range_type ((struct type *) NULL, builtin_type_int,
		       low_bound, count + low_bound - 1);
  /* FIXME-type-allocation: need a way to free this type when we are
     done with it.  */
  return allocate_value (create_array_type ((struct type *) NULL,
					    type, range_type));
}

/* Return a mark in the value chain.  All values allocated after the
   mark is obtained (except for those released) are subject to being freed
   if a subsequent value_free_to_mark is passed the mark.  */
struct value *
value_mark (void)
{
  return all_values;
}

/* Free all values allocated since MARK was obtained by value_mark
   (except for those released).  */
void
value_free_to_mark (struct value *mark)
{
  struct value *val;
  struct value *next;

  for (val = all_values; val && val != mark; val = next)
    {
      next = VALUE_NEXT (val);
      value_free (val);
    }
  all_values = val;
}

/* Free all the values that have been allocated (except for those released).
   Called after each command, successful or not.  */

void
free_all_values (void)
{
  struct value *val;
  struct value *next;

  for (val = all_values; val; val = next)
    {
      next = VALUE_NEXT (val);
      value_free (val);
    }

  all_values = 0;
}

/* Remove VAL from the chain all_values
   so it will not be freed automatically.  */

void
release_value (struct value *val)
{
  struct value *v;

  if (all_values == val)
    {
      all_values = val->next;
      return;
    }

  for (v = all_values; v; v = v->next)
    {
      if (v->next == val)
	{
	  v->next = val->next;
	  break;
	}
    }
}

/* Release all values up to mark  */
struct value *
value_release_to_mark (struct value *mark)
{
  struct value *val;
  struct value *next;

  for (val = next = all_values; next; next = VALUE_NEXT (next))
    if (VALUE_NEXT (next) == mark)
      {
	all_values = VALUE_NEXT (next);
	VALUE_NEXT (next) = 0;
	return val;
      }
  all_values = 0;
  return val;
}

/* Return a copy of the value ARG.
   It contains the same contents, for same memory address,
   but it's a different block of storage.  */

struct value *
value_copy (struct value *arg)
{
  struct type *encl_type = VALUE_ENCLOSING_TYPE (arg);
  struct value *val = allocate_value (encl_type);
  VALUE_TYPE (val) = VALUE_TYPE (arg);
  VALUE_LVAL (val) = VALUE_LVAL (arg);
  VALUE_ADDRESS (val) = VALUE_ADDRESS (arg);
  VALUE_OFFSET (val) = VALUE_OFFSET (arg);
  VALUE_BITPOS (val) = VALUE_BITPOS (arg);
  VALUE_BITSIZE (val) = VALUE_BITSIZE (arg);
  VALUE_FRAME_ID (val) = VALUE_FRAME_ID (arg);
  VALUE_REGNO (val) = VALUE_REGNO (arg);
  VALUE_LAZY (val) = VALUE_LAZY (arg);
  VALUE_OPTIMIZED_OUT (val) = VALUE_OPTIMIZED_OUT (arg);
  VALUE_EMBEDDED_OFFSET (val) = VALUE_EMBEDDED_OFFSET (arg);
  VALUE_POINTED_TO_OFFSET (val) = VALUE_POINTED_TO_OFFSET (arg);
  val->modifiable = arg->modifiable;
  if (!VALUE_LAZY (val))
    {
      memcpy (VALUE_CONTENTS_ALL_RAW (val), VALUE_CONTENTS_ALL_RAW (arg),
	      TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg)));

    }
  return val;
}

/* Access to the value history.  */

/* Record a new value in the value history.
   Returns the absolute history index of the entry.
   Result of -1 indicates the value was not saved; otherwise it is the
   value history index of this new item.  */

int
record_latest_value (struct value *val)
{
  int i;

  /* We don't want this value to have anything to do with the inferior anymore.
     In particular, "set $1 = 50" should not affect the variable from which
     the value was taken, and fast watchpoints should be able to assume that
     a value on the value history never changes.  */
  if (VALUE_LAZY (val))
    value_fetch_lazy (val);
  /* We preserve VALUE_LVAL so that the user can find out where it was fetched
     from.  This is a bit dubious, because then *&$1 does not just return $1
     but the current contents of that location.  c'est la vie...  */
  val->modifiable = 0;
  release_value (val);

  /* Here we treat value_history_count as origin-zero
     and applying to the value being stored now.  */

  i = value_history_count % VALUE_HISTORY_CHUNK;
  if (i == 0)
    {
      struct value_history_chunk *new
      = (struct value_history_chunk *)
      xmalloc (sizeof (struct value_history_chunk));
      memset (new->values, 0, sizeof new->values);
      new->next = value_history_chain;
      value_history_chain = new;
    }

  value_history_chain->values[i] = val;

  /* Now we regard value_history_count as origin-one
     and applying to the value just stored.  */

  return ++value_history_count;
}

/* Return a copy of the value in the history with sequence number NUM.  */

struct value *
access_value_history (int num)
{
  struct value_history_chunk *chunk;
  int i;
  int absnum = num;

  if (absnum <= 0)
    absnum += value_history_count;

  if (absnum <= 0)
    {
      if (num == 0)
	error ("The history is empty.");
      else if (num == 1)
	error ("There is only one value in the history.");
      else
	error ("History does not go back to $$%d.", -num);
    }
  if (absnum > value_history_count)
    error ("History has not yet reached $%d.", absnum);

  absnum--;

  /* Now absnum is always absolute and origin zero.  */

  chunk = value_history_chain;
  for (i = (value_history_count - 1) / VALUE_HISTORY_CHUNK - absnum / VALUE_HISTORY_CHUNK;
       i > 0; i--)
    chunk = chunk->next;

  return value_copy (chunk->values[absnum % VALUE_HISTORY_CHUNK]);
}

/* Clear the value history entirely.
   Must be done when new symbol tables are loaded,
   because the type pointers become invalid.  */

void
clear_value_history (void)
{
  struct value_history_chunk *next;
  int i;
  struct value *val;

  while (value_history_chain)
    {
      for (i = 0; i < VALUE_HISTORY_CHUNK; i++)
	if ((val = value_history_chain->values[i]) != NULL)
	  xfree (val);
      next = value_history_chain->next;
      xfree (value_history_chain);
      value_history_chain = next;
    }
  value_history_count = 0;
}

static void
show_values (char *num_exp, int from_tty)
{
  int i;
  struct value *val;
  static int num = 1;

  if (num_exp)
    {
      /* "info history +" should print from the stored position.
         "info history <exp>" should print around value number <exp>.  */
      if (num_exp[0] != '+' || num_exp[1] != '\0')
	num = parse_and_eval_long (num_exp) - 5;
    }
  else
    {
      /* "info history" means print the last 10 values.  */
      num = value_history_count - 9;
    }

  if (num <= 0)
    num = 1;

  for (i = num; i < num + 10 && i <= value_history_count; i++)
    {
      val = access_value_history (i);
      printf_filtered ("$%d = ", i);
      value_print (val, gdb_stdout, 0, Val_pretty_default);
      printf_filtered ("\n");
    }

  /* The next "info history +" should start after what we just printed.  */
  num += 10;

  /* Hitting just return after this command should do the same thing as
     "info history +".  If num_exp is null, this is unnecessary, since
     "info history +" is not useful after "info history".  */
  if (from_tty && num_exp)
    {
      num_exp[0] = '+';
      num_exp[1] = '\0';
    }
}

/* Internal variables.  These are variables within the debugger
   that hold values assigned by debugger commands.
   The user refers to them with a '$' prefix
   that does not appear in the variable names stored internally.  */

static struct internalvar *internalvars;

/* Look up an internal variable with name NAME.  NAME should not
   normally include a dollar sign.

   If the specified internal variable does not exist,
   one is created, with a void value.  */

struct internalvar *
lookup_internalvar (char *name)
{
  struct internalvar *var;

  for (var = internalvars; var; var = var->next)
    if (strcmp (var->name, name) == 0)
      return var;

  var = (struct internalvar *) xmalloc (sizeof (struct internalvar));
  var->name = concat (name, NULL);
  var->value = allocate_value (builtin_type_void);
  release_value (var->value);
  var->next = internalvars;
  internalvars = var;
  return var;
}

struct value *
value_of_internalvar (struct internalvar *var)
{
  struct value *val;

  val = value_copy (var->value);
  if (VALUE_LAZY (val))
    value_fetch_lazy (val);
  VALUE_LVAL (val) = lval_internalvar;
  VALUE_INTERNALVAR (val) = var;
  return val;
}

void
set_internalvar_component (struct internalvar *var, int offset, int bitpos,
			   int bitsize, struct value *newval)
{
  char *addr = VALUE_CONTENTS (var->value) + offset;

  if (bitsize)
    modify_field (addr, value_as_long (newval),
		  bitpos, bitsize);
  else
    memcpy (addr, VALUE_CONTENTS (newval), TYPE_LENGTH (VALUE_TYPE (newval)));
}

void
set_internalvar (struct internalvar *var, struct value *val)
{
  struct value *newval;

  newval = value_copy (val);
  newval->modifiable = 1;

  /* Force the value to be fetched from the target now, to avoid problems
     later when this internalvar is referenced and the target is gone or
     has changed.  */
  if (VALUE_LAZY (newval))
    value_fetch_lazy (newval);

  /* Begin code which must not call error().  If var->value points to
     something free'd, an error() obviously leaves a dangling pointer.
     But we also get a danling pointer if var->value points to
     something in the value chain (i.e., before release_value is
     called), because after the error free_all_values will get called before
     long.  */
  xfree (var->value);
  var->value = newval;
  release_value (newval);
  /* End code which must not call error().  */
}

char *
internalvar_name (struct internalvar *var)
{
  return var->name;
}

/* Free all internalvars.  Done when new symtabs are loaded,
   because that makes the values invalid.  */

void
clear_internalvars (void)
{
  struct internalvar *var;

  while (internalvars)
    {
      var = internalvars;
      internalvars = var->next;
      xfree (var->name);
      xfree (var->value);
      xfree (var);
    }
}

static void
show_convenience (char *ignore, int from_tty)
{
  struct internalvar *var;
  int varseen = 0;

  for (var = internalvars; var; var = var->next)
    {
      if (!varseen)
	{
	  varseen = 1;
	}
      printf_filtered ("$%s = ", var->name);
      value_print (var->value, gdb_stdout, 0, Val_pretty_default);
      printf_filtered ("\n");
    }
  if (!varseen)
    printf_unfiltered ("No debugger convenience variables now defined.\n\
Convenience variables have names starting with \"$\";\n\
use \"set\" as in \"set $foo = 5\" to define them.\n");
}

/* Extract a value as a C number (either long or double).
   Knows how to convert fixed values to double, or
   floating values to long.
   Does not deallocate the value.  */

LONGEST
value_as_long (struct value *val)
{
  /* This coerces arrays and functions, which is necessary (e.g.
     in disassemble_command).  It also dereferences references, which
     I suspect is the most logical thing to do.  */
  COERCE_ARRAY (val);
  return unpack_long (VALUE_TYPE (val), VALUE_CONTENTS (val));
}

DOUBLEST
value_as_double (struct value *val)
{
  DOUBLEST foo;
  int inv;

  foo = unpack_double (VALUE_TYPE (val), VALUE_CONTENTS (val), &inv);
  if (inv)
    error ("Invalid floating value found in program.");
  return foo;
}
/* Extract a value as a C pointer. Does not deallocate the value.  
   Note that val's type may not actually be a pointer; value_as_long
   handles all the cases.  */
CORE_ADDR
value_as_address (struct value *val)
{
  /* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure
     whether we want this to be true eventually.  */
#if 0
  /* ADDR_BITS_REMOVE is wrong if we are being called for a
     non-address (e.g. argument to "signal", "info break", etc.), or
     for pointers to char, in which the low bits *are* significant.  */
  return ADDR_BITS_REMOVE (value_as_long (val));
#else

  /* There are several targets (IA-64, PowerPC, and others) which
     don't represent pointers to functions as simply the address of
     the function's entry point.  For example, on the IA-64, a
     function pointer points to a two-word descriptor, generated by
     the linker, which contains the function's entry point, and the
     value the IA-64 "global pointer" register should have --- to
     support position-independent code.  The linker generates
     descriptors only for those functions whose addresses are taken.

     On such targets, it's difficult for GDB to convert an arbitrary
     function address into a function pointer; it has to either find
     an existing descriptor for that function, or call malloc and
     build its own.  On some targets, it is impossible for GDB to
     build a descriptor at all: the descriptor must contain a jump
     instruction; data memory cannot be executed; and code memory
     cannot be modified.

     Upon entry to this function, if VAL is a value of type `function'
     (that is, TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_FUNC), then
     VALUE_ADDRESS (val) is the address of the function.  This is what
     you'll get if you evaluate an expression like `main'.  The call
     to COERCE_ARRAY below actually does all the usual unary
     conversions, which includes converting values of type `function'
     to `pointer to function'.  This is the challenging conversion
     discussed above.  Then, `unpack_long' will convert that pointer
     back into an address.

     So, suppose the user types `disassemble foo' on an architecture
     with a strange function pointer representation, on which GDB
     cannot build its own descriptors, and suppose further that `foo'
     has no linker-built descriptor.  The address->pointer conversion
     will signal an error and prevent the command from running, even
     though the next step would have been to convert the pointer
     directly back into the same address.

     The following shortcut avoids this whole mess.  If VAL is a
     function, just return its address directly.  */
  if (TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_FUNC
      || TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_METHOD)
    return VALUE_ADDRESS (val);

  COERCE_ARRAY (val);

  /* Some architectures (e.g. Harvard), map instruction and data
     addresses onto a single large unified address space.  For
     instance: An architecture may consider a large integer in the
     range 0x10000000 .. 0x1000ffff to already represent a data
     addresses (hence not need a pointer to address conversion) while
     a small integer would still need to be converted integer to
     pointer to address.  Just assume such architectures handle all
     integer conversions in a single function.  */

  /* JimB writes:

     I think INTEGER_TO_ADDRESS is a good idea as proposed --- but we
     must admonish GDB hackers to make sure its behavior matches the
     compiler's, whenever possible.

     In general, I think GDB should evaluate expressions the same way
     the compiler does.  When the user copies an expression out of
     their source code and hands it to a `print' command, they should
     get the same value the compiler would have computed.  Any
     deviation from this rule can cause major confusion and annoyance,
     and needs to be justified carefully.  In other words, GDB doesn't
     really have the freedom to do these conversions in clever and
     useful ways.

     AndrewC pointed out that users aren't complaining about how GDB
     casts integers to pointers; they are complaining that they can't
     take an address from a disassembly listing and give it to `x/i'.
     This is certainly important.

     Adding an architecture method like INTEGER_TO_ADDRESS certainly
     makes it possible for GDB to "get it right" in all circumstances
     --- the target has complete control over how things get done, so
     people can Do The Right Thing for their target without breaking
     anyone else.  The standard doesn't specify how integers get
     converted to pointers; usually, the ABI doesn't either, but
     ABI-specific code is a more reasonable place to handle it.  */

  if (TYPE_CODE (VALUE_TYPE (val)) != TYPE_CODE_PTR
      && TYPE_CODE (VALUE_TYPE (val)) != TYPE_CODE_REF
      && INTEGER_TO_ADDRESS_P ())
    return INTEGER_TO_ADDRESS (VALUE_TYPE (val), VALUE_CONTENTS (val));

  return unpack_long (VALUE_TYPE (val), VALUE_CONTENTS (val));
#endif
}

/* Unpack raw data (copied from debugee, target byte order) at VALADDR
   as a long, or as a double, assuming the raw data is described
   by type TYPE.  Knows how to convert different sizes of values
   and can convert between fixed and floating point.  We don't assume
   any alignment for the raw data.  Return value is in host byte order.

   If you want functions and arrays to be coerced to pointers, and
   references to be dereferenced, call value_as_long() instead.

   C++: It is assumed that the front-end has taken care of
   all matters concerning pointers to members.  A pointer
   to member which reaches here is considered to be equivalent
   to an INT (or some size).  After all, it is only an offset.  */

LONGEST
unpack_long (struct type *type, const char *valaddr)
{
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);
  int nosign = TYPE_UNSIGNED (type);

  if (current_language->la_language == language_scm
      && is_scmvalue_type (type))
    return scm_unpack (type, valaddr, TYPE_CODE_INT);

  switch (code)
    {
    case TYPE_CODE_TYPEDEF:
      return unpack_long (check_typedef (type), valaddr);
    case TYPE_CODE_ENUM:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_RANGE:
      if (nosign)
	return extract_unsigned_integer (valaddr, len);
      else
	return extract_signed_integer (valaddr, len);

    case TYPE_CODE_FLT:
      return extract_typed_floating (valaddr, type);

    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
      /* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure
         whether we want this to be true eventually.  */
      return extract_typed_address (valaddr, type);

    case TYPE_CODE_MEMBER:
      error ("not implemented: member types in unpack_long");

    default:
      error ("Value can't be converted to integer.");
    }
  return 0;			/* Placate lint.  */
}

/* Return a double value from the specified type and address.
   INVP points to an int which is set to 0 for valid value,
   1 for invalid value (bad float format).  In either case,
   the returned double is OK to use.  Argument is in target
   format, result is in host format.  */

DOUBLEST
unpack_double (struct type *type, const char *valaddr, int *invp)
{
  enum type_code code;
  int len;
  int nosign;

  *invp = 0;			/* Assume valid.   */
  CHECK_TYPEDEF (type);
  code = TYPE_CODE (type);
  len = TYPE_LENGTH (type);
  nosign = TYPE_UNSIGNED (type);
  if (code == TYPE_CODE_FLT)
    {
      /* NOTE: cagney/2002-02-19: There was a test here to see if the
	 floating-point value was valid (using the macro
	 INVALID_FLOAT).  That test/macro have been removed.

	 It turns out that only the VAX defined this macro and then
	 only in a non-portable way.  Fixing the portability problem
	 wouldn't help since the VAX floating-point code is also badly
	 bit-rotten.  The target needs to add definitions for the
	 methods TARGET_FLOAT_FORMAT and TARGET_DOUBLE_FORMAT - these
	 exactly describe the target floating-point format.  The
	 problem here is that the corresponding floatformat_vax_f and
	 floatformat_vax_d values these methods should be set to are
	 also not defined either.  Oops!

         Hopefully someone will add both the missing floatformat
         definitions and the new cases for floatformat_is_valid ().  */

      if (!floatformat_is_valid (floatformat_from_type (type), valaddr))
	{
	  *invp = 1;
	  return 0.0;
	}

      return extract_typed_floating (valaddr, type);
    }
  else if (nosign)
    {
      /* Unsigned -- be sure we compensate for signed LONGEST.  */
      return (ULONGEST) unpack_long (type, valaddr);
    }
  else
    {
      /* Signed -- we are OK with unpack_long.  */
      return unpack_long (type, valaddr);
    }
}

/* Unpack raw data (copied from debugee, target byte order) at VALADDR
   as a CORE_ADDR, assuming the raw data is described by type TYPE.
   We don't assume any alignment for the raw data.  Return value is in
   host byte order.

   If you want functions and arrays to be coerced to pointers, and
   references to be dereferenced, call value_as_address() instead.

   C++: It is assumed that the front-end has taken care of
   all matters concerning pointers to members.  A pointer
   to member which reaches here is considered to be equivalent
   to an INT (or some size).  After all, it is only an offset.  */

CORE_ADDR
unpack_pointer (struct type *type, const char *valaddr)
{
  /* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure
     whether we want this to be true eventually.  */
  return unpack_long (type, valaddr);
}


/* Get the value of the FIELDN'th field (which must be static) of
   TYPE.  Return NULL if the field doesn't exist or has been
   optimized out. */

struct value *
value_static_field (struct type *type, int fieldno)
{
  struct value *retval;

  if (TYPE_FIELD_STATIC_HAS_ADDR (type, fieldno))
    {
      retval = value_at (TYPE_FIELD_TYPE (type, fieldno),
			 TYPE_FIELD_STATIC_PHYSADDR (type, fieldno));
    }
  else
    {
      char *phys_name = TYPE_FIELD_STATIC_PHYSNAME (type, fieldno);
      struct symbol *sym = lookup_symbol (phys_name, 0, VAR_DOMAIN, 0, NULL);
      if (sym == NULL)
	{
	  /* With some compilers, e.g. HP aCC, static data members are reported
	     as non-debuggable symbols */
	  struct minimal_symbol *msym = lookup_minimal_symbol (phys_name, NULL, NULL);
	  if (!msym)
	    return NULL;
	  else
	    {
	      retval = value_at (TYPE_FIELD_TYPE (type, fieldno),
				 SYMBOL_VALUE_ADDRESS (msym));
	    }
	}
      else
	{
	  /* SYM should never have a SYMBOL_CLASS which will require
	     read_var_value to use the FRAME parameter.  */
	  if (symbol_read_needs_frame (sym))
	    warning ("static field's value depends on the current "
		     "frame - bad debug info?");
	  retval = read_var_value (sym, NULL);
 	}
      if (retval && VALUE_LVAL (retval) == lval_memory)
	SET_FIELD_PHYSADDR (TYPE_FIELD (type, fieldno),
			    VALUE_ADDRESS (retval));
    }
  return retval;
}

/* Change the enclosing type of a value object VAL to NEW_ENCL_TYPE.  
   You have to be careful here, since the size of the data area for the value 
   is set by the length of the enclosing type.  So if NEW_ENCL_TYPE is bigger 
   than the old enclosing type, you have to allocate more space for the data.  
   The return value is a pointer to the new version of this value structure. */

struct value *
value_change_enclosing_type (struct value *val, struct type *new_encl_type)
{
  if (TYPE_LENGTH (new_encl_type) <= TYPE_LENGTH (VALUE_ENCLOSING_TYPE (val))) 
    {
      VALUE_ENCLOSING_TYPE (val) = new_encl_type;
      return val;
    }
  else
    {
      struct value *new_val;
      struct value *prev;
      
      new_val = (struct value *) xrealloc (val, sizeof (struct value) + TYPE_LENGTH (new_encl_type));

      VALUE_ENCLOSING_TYPE (new_val) = new_encl_type;
 
      /* We have to make sure this ends up in the same place in the value
	 chain as the original copy, so it's clean-up behavior is the same. 
	 If the value has been released, this is a waste of time, but there
	 is no way to tell that in advance, so... */
      
      if (val != all_values) 
	{
	  for (prev = all_values; prev != NULL; prev = prev->next)
	    {
	      if (prev->next == val) 
		{
		  prev->next = new_val;
		  break;
		}
	    }
	}
      
      return new_val;
    }
}

/* Given a value ARG1 (offset by OFFSET bytes)
   of a struct or union type ARG_TYPE,
   extract and return the value of one of its (non-static) fields.
   FIELDNO says which field. */

struct value *
value_primitive_field (struct value *arg1, int offset,
		       int fieldno, struct type *arg_type)
{
  struct value *v;
  struct type *type;

  CHECK_TYPEDEF (arg_type);
  type = TYPE_FIELD_TYPE (arg_type, fieldno);

  /* Handle packed fields */

  if (TYPE_FIELD_BITSIZE (arg_type, fieldno))
    {
      v = value_from_longest (type,
			      unpack_field_as_long (arg_type,
						    VALUE_CONTENTS (arg1)
						    + offset,
						    fieldno));
      VALUE_BITPOS (v) = TYPE_FIELD_BITPOS (arg_type, fieldno) % 8;
      VALUE_BITSIZE (v) = TYPE_FIELD_BITSIZE (arg_type, fieldno);
      VALUE_OFFSET (v) = VALUE_OFFSET (arg1) + offset
	+ TYPE_FIELD_BITPOS (arg_type, fieldno) / 8;
    }
  else if (fieldno < TYPE_N_BASECLASSES (arg_type))
    {
      /* This field is actually a base subobject, so preserve the
         entire object's contents for later references to virtual
         bases, etc.  */
      v = allocate_value (VALUE_ENCLOSING_TYPE (arg1));
      VALUE_TYPE (v) = type;
      if (VALUE_LAZY (arg1))
	VALUE_LAZY (v) = 1;
      else
	memcpy (VALUE_CONTENTS_ALL_RAW (v), VALUE_CONTENTS_ALL_RAW (arg1),
		TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg1)));
      VALUE_OFFSET (v) = VALUE_OFFSET (arg1);
      VALUE_EMBEDDED_OFFSET (v)
	= offset +
	VALUE_EMBEDDED_OFFSET (arg1) +
	TYPE_FIELD_BITPOS (arg_type, fieldno) / 8;
    }
  else
    {
      /* Plain old data member */
      offset += TYPE_FIELD_BITPOS (arg_type, fieldno) / 8;
      v = allocate_value (type);
      if (VALUE_LAZY (arg1))
	VALUE_LAZY (v) = 1;
      else
	memcpy (VALUE_CONTENTS_RAW (v),
		VALUE_CONTENTS_RAW (arg1) + offset,
		TYPE_LENGTH (type));
      VALUE_OFFSET (v) = VALUE_OFFSET (arg1) + offset
			 + VALUE_EMBEDDED_OFFSET (arg1);
    }
  VALUE_LVAL (v) = VALUE_LVAL (arg1);
  if (VALUE_LVAL (arg1) == lval_internalvar)
    VALUE_LVAL (v) = lval_internalvar_component;
  VALUE_ADDRESS (v) = VALUE_ADDRESS (arg1);
  VALUE_REGNO (v) = VALUE_REGNO (arg1);
/*  VALUE_OFFSET (v) = VALUE_OFFSET (arg1) + offset
   + TYPE_FIELD_BITPOS (arg_type, fieldno) / 8; */
  return v;
}

/* Given a value ARG1 of a struct or union type,
   extract and return the value of one of its (non-static) fields.
   FIELDNO says which field. */

struct value *
value_field (struct value *arg1, int fieldno)
{
  return value_primitive_field (arg1, 0, fieldno, VALUE_TYPE (arg1));
}

/* Return a non-virtual function as a value.
   F is the list of member functions which contains the desired method.
   J is an index into F which provides the desired method.

   We only use the symbol for its address, so be happy with either a
   full symbol or a minimal symbol.
 */

struct value *
value_fn_field (struct value **arg1p, struct fn_field *f, int j, struct type *type,
		int offset)
{
  struct value *v;
  struct type *ftype = TYPE_FN_FIELD_TYPE (f, j);
  char *physname = TYPE_FN_FIELD_PHYSNAME (f, j);
  struct symbol *sym;
  struct minimal_symbol *msym;

  sym = lookup_symbol (physname, 0, VAR_DOMAIN, 0, NULL);
  if (sym != NULL)
    {
      msym = NULL;
    }
  else
    {
      gdb_assert (sym == NULL);
      msym = lookup_minimal_symbol (physname, NULL, NULL);
      if (msym == NULL)
	return NULL;
    }

  v = allocate_value (ftype);
  if (sym)
    {
      VALUE_ADDRESS (v) = BLOCK_START (SYMBOL_BLOCK_VALUE (sym));
    }
  else
    {
      VALUE_ADDRESS (v) = SYMBOL_VALUE_ADDRESS (msym);
    }

  if (arg1p)
    {
      if (type != VALUE_TYPE (*arg1p))
	*arg1p = value_ind (value_cast (lookup_pointer_type (type),
					value_addr (*arg1p)));

      /* Move the `this' pointer according to the offset.
         VALUE_OFFSET (*arg1p) += offset;
       */
    }

  return v;
}


/* Unpack a field FIELDNO of the specified TYPE, from the anonymous object at
   VALADDR.

   Extracting bits depends on endianness of the machine.  Compute the
   number of least significant bits to discard.  For big endian machines,
   we compute the total number of bits in the anonymous object, subtract
   off the bit count from the MSB of the object to the MSB of the
   bitfield, then the size of the bitfield, which leaves the LSB discard
   count.  For little endian machines, the discard count is simply the
   number of bits from the LSB of the anonymous object to the LSB of the
   bitfield.

   If the field is signed, we also do sign extension. */

LONGEST
unpack_field_as_long (struct type *type, const char *valaddr, int fieldno)
{
  ULONGEST val;
  ULONGEST valmask;
  int bitpos = TYPE_FIELD_BITPOS (type, fieldno);
  int bitsize = TYPE_FIELD_BITSIZE (type, fieldno);
  int lsbcount;
  struct type *field_type;

  val = extract_unsigned_integer (valaddr + bitpos / 8, sizeof (val));
  field_type = TYPE_FIELD_TYPE (type, fieldno);
  CHECK_TYPEDEF (field_type);

  /* Extract bits.  See comment above. */

  if (BITS_BIG_ENDIAN)
    lsbcount = (sizeof val * 8 - bitpos % 8 - bitsize);
  else
    lsbcount = (bitpos % 8);
  val >>= lsbcount;

  /* If the field does not entirely fill a LONGEST, then zero the sign bits.
     If the field is signed, and is negative, then sign extend. */

  if ((bitsize > 0) && (bitsize < 8 * (int) sizeof (val)))
    {
      valmask = (((ULONGEST) 1) << bitsize) - 1;
      val &= valmask;
      if (!TYPE_UNSIGNED (field_type))
	{
	  if (val & (valmask ^ (valmask >> 1)))
	    {
	      val |= ~valmask;
	    }
	}
    }
  return (val);
}

/* Modify the value of a bitfield.  ADDR points to a block of memory in
   target byte order; the bitfield starts in the byte pointed to.  FIELDVAL
   is the desired value of the field, in host byte order.  BITPOS and BITSIZE
   indicate which bits (in target bit order) comprise the bitfield.  
   Requires 0 < BITSIZE <= lbits, 0 <= BITPOS+BITSIZE <= lbits, and
   0 <= BITPOS, where lbits is the size of a LONGEST in bits.  */

void
modify_field (char *addr, LONGEST fieldval, int bitpos, int bitsize)
{
  ULONGEST oword;
  ULONGEST mask = (ULONGEST) -1 >> (8 * sizeof (ULONGEST) - bitsize);

  /* If a negative fieldval fits in the field in question, chop
     off the sign extension bits.  */
  if ((~fieldval & ~(mask >> 1)) == 0)
    fieldval &= mask;

  /* Warn if value is too big to fit in the field in question.  */
  if (0 != (fieldval & ~mask))
    {
      /* FIXME: would like to include fieldval in the message, but
         we don't have a sprintf_longest.  */
      warning ("Value does not fit in %d bits.", bitsize);

      /* Truncate it, otherwise adjoining fields may be corrupted.  */
      fieldval &= mask;
    }

  oword = extract_unsigned_integer (addr, sizeof oword);

  /* Shifting for bit field depends on endianness of the target machine.  */
  if (BITS_BIG_ENDIAN)
    bitpos = sizeof (oword) * 8 - bitpos - bitsize;

  oword &= ~(mask << bitpos);
  oword |= fieldval << bitpos;

  store_unsigned_integer (addr, sizeof oword, oword);
}

/* Convert C numbers into newly allocated values */

struct value *
value_from_longest (struct type *type, LONGEST num)
{
  struct value *val = allocate_value (type);
  enum type_code code;
  int len;
retry:
  code = TYPE_CODE (type);
  len = TYPE_LENGTH (type);

  switch (code)
    {
    case TYPE_CODE_TYPEDEF:
      type = check_typedef (type);
      goto retry;
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_RANGE:
      store_signed_integer (VALUE_CONTENTS_RAW (val), len, num);
      break;

    case TYPE_CODE_REF:
    case TYPE_CODE_PTR:
      store_typed_address (VALUE_CONTENTS_RAW (val), type, (CORE_ADDR) num);
      break;

    default:
      error ("Unexpected type (%d) encountered for integer constant.", code);
    }
  return val;
}


/* Create a value representing a pointer of type TYPE to the address
   ADDR.  */
struct value *
value_from_pointer (struct type *type, CORE_ADDR addr)
{
  struct value *val = allocate_value (type);
  store_typed_address (VALUE_CONTENTS_RAW (val), type, addr);
  return val;
}


/* Create a value for a string constant to be stored locally
   (not in the inferior's memory space, but in GDB memory).
   This is analogous to value_from_longest, which also does not
   use inferior memory.  String shall NOT contain embedded nulls.  */

struct value *
value_from_string (char *ptr)
{
  struct value *val;
  int len = strlen (ptr);
  int lowbound = current_language->string_lower_bound;
  struct type *string_char_type;
  struct type *rangetype;
  struct type *stringtype;

  rangetype = create_range_type ((struct type *) NULL,
				 builtin_type_int,
				 lowbound, len + lowbound - 1);
  string_char_type = language_string_char_type (current_language,
						current_gdbarch);
  stringtype = create_array_type ((struct type *) NULL,
				  string_char_type,
				  rangetype);
  val = allocate_value (stringtype);
  memcpy (VALUE_CONTENTS_RAW (val), ptr, len);
  return val;
}

struct value *
value_from_double (struct type *type, DOUBLEST num)
{
  struct value *val = allocate_value (type);
  struct type *base_type = check_typedef (type);
  enum type_code code = TYPE_CODE (base_type);
  int len = TYPE_LENGTH (base_type);

  if (code == TYPE_CODE_FLT)
    {
      store_typed_floating (VALUE_CONTENTS_RAW (val), base_type, num);
    }
  else
    error ("Unexpected type encountered for floating constant.");

  return val;
}


/* Should we use DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc and TYPE
   is the type (which is known to be struct, union or array).

   On most machines, the struct convention is used unless we are
   using gcc and the type is of a special size.  */
/* As of about 31 Mar 93, GCC was changed to be compatible with the
   native compiler.  GCC 2.3.3 was the last release that did it the
   old way.  Since gcc2_compiled was not changed, we have no
   way to correctly win in all cases, so we just do the right thing
   for gcc1 and for gcc2 after this change.  Thus it loses for gcc
   2.0-2.3.3.  This is somewhat unfortunate, but changing gcc2_compiled
   would cause more chaos than dealing with some struct returns being
   handled wrong.  */
/* NOTE: cagney/2004-06-13: Deleted check for "gcc_p".  GCC 1.x is
   dead.  */

int
generic_use_struct_convention (int gcc_p, struct type *value_type)
{
  return !(TYPE_LENGTH (value_type) == 1
	   || TYPE_LENGTH (value_type) == 2
	   || TYPE_LENGTH (value_type) == 4
	   || TYPE_LENGTH (value_type) == 8);
}

/* Return true if the function returning the specified type is using
   the convention of returning structures in memory (passing in the
   address as a hidden first parameter).  GCC_P is nonzero if compiled
   with GCC.  */

int
using_struct_return (struct type *value_type, int gcc_p)
{
  enum type_code code = TYPE_CODE (value_type);

  if (code == TYPE_CODE_ERROR)
    error ("Function return type unknown.");

  if (code == TYPE_CODE_VOID)
    /* A void return value is never in memory.  See also corresponding
       code in "print_return_value".  */
    return 0;

  /* Probe the architecture for the return-value convention.  */
  return (gdbarch_return_value (current_gdbarch, value_type,
				NULL, NULL, NULL)
	  != RETURN_VALUE_REGISTER_CONVENTION);
}

void
_initialize_values (void)
{
  add_cmd ("convenience", no_class, show_convenience,
	   "Debugger convenience (\"$foo\") variables.\n\
These variables are created when you assign them values;\n\
thus, \"print $foo=1\" gives \"$foo\" the value 1.  Values may be any type.\n\n\
A few convenience variables are given values automatically:\n\
\"$_\"holds the last address examined with \"x\" or \"info lines\",\n\
\"$__\" holds the contents of the last address examined with \"x\".",
	   &showlist);

  add_cmd ("values", no_class, show_values,
	   "Elements of value history around item number IDX (or last ten).",
	   &showlist);
}
@


1.73
log
@2004-11-09  Andrew Cagney  <cagney@@gnu.org>

	* value.h (struct value): Delete field bfd_section.
	(VALUE_BFD_SECTION): Delete macro.
	(COERCE_REF): Update.
	(value_at, value_at_lazy): Delete asection parameter.
	* printcmd.c (print_formatted, x_command): Update.
	(do_examine): Delete asection parameter.
	(next_section): Delete variable.
	* valops.c (value_cast, value_at, value_at_lazy)
	(value_coerce_function, value_addr, value_ind, value_string)
	(find_rt_vbase_offset, value_full_object): Update.
	* hpacc-abi.c (hpacc_virtual_fn_field)
	(hpacc_value_rtti_type): Update.
	* gnu-v3-abi.c (gnuv3_rtti_type, gnuv3_virtual_fn_field)
	(gnuv3_baseclass_offset): Update.
	* f-valprint.c (f_val_print): Update.
	* c-valprint.c (c_val_print): Update.
	* p-valprint.c (pascal_val_print): Update.
	* jv-valprint.c (java_value_print): Update.
	* jv-lang.c (java_class_from_object, evaluate_subexp_java): Update.
	* ada-lang.c (ada_value_primitive_packed_val)
	(ada_evaluate_subexp): Update.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Update.
	* expprint.c (print_subexp_standard): Update.
	* infcall.c (call_function_by_hand): Update.
	* valarith.c (value_add): Update.
	* eval.c (evaluate_subexp_standard): Update.
	* values.c (allocate_value, value_copy, value_static_field): Update.
	* findvar.c (read_var_value, locate_var_value): Update.
@
text
@@


1.72
log
@* values.c (modify_field): Correct handling of bit-fields that
don't fit in 32 bits.  Use unsigned operations throughout and
simplify the code a bit.  Document preconditions.
@
text
@a99 1
  VALUE_BFD_SECTION (val) = NULL;
a229 1
  VALUE_BFD_SECTION (val) = VALUE_BFD_SECTION (arg);
d796 1
a796 2
			 TYPE_FIELD_STATIC_PHYSADDR (type, fieldno),
			 NULL);
d812 1
a812 2
				 SYMBOL_VALUE_ADDRESS (msym),
				 SYMBOL_BFD_SECTION (msym));
@


1.71
log
@2004-07-27  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (enum language): Add nr_languages.
	* language.h (struct language_arch_info): Define.
	(struct language_defn): Add la_language_arch_info.
	(language_lookup_primative_type_by_name): Declare.
	(language_string_char_type): Declare.
	* language.c (_initialize_language, language_gdbarch_post_init)
	(struct language_gdbarch, language_gdbarch_data): Implement
	per-architecture language information.
	(unknown_language_arch_info, language_string_char_type)
	(language_lookup_primative_type_by_name): New functions.
	(unknown_language_defn, auto_language_defn)
	(local_language_defn): Set la_language_arch_info to
	unknown_language_arch_info.
	(unknown_builtin_types): Delete.
	* gdbtypes.c (lookup_primitive_typename): Use
	language_lookup_primative_type_by_name.
	(create_string_type): Use language_string_char_type.
	* values.c (value_from_string): Use language_string_char_type.
	* scm-lang.c (scm_language_defn): Add NULL la_language_arch_info.
	* p-lang.c (pascal_language_defn): Ditto.
	* m2-lang.c (m2_language_defn): Ditto.
	* jv-lang.c (java_language_defn): Ditto.
	* objc-lang.c (objc_language_defn): Ditto.
	* f-lang.c (f_language_defn): Ditto.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Ditto.
@
text
@d1073 3
a1075 1
   indicate which bits (in target bit order) comprise the bitfield.  */
d1080 2
a1081 1
  LONGEST oword;
d1085 2
a1086 3
  if (bitsize < (8 * (int) sizeof (fieldval))
      && (~fieldval & ~((1 << (bitsize - 1)) - 1)) == 0)
    fieldval = fieldval & ((1 << bitsize) - 1);
d1089 1
a1089 2
  if (bitsize < (8 * (int) sizeof (fieldval))
      && 0 != (fieldval & ~((1 << bitsize) - 1)))
d1096 1
a1096 1
      fieldval = fieldval & ((1 << bitsize) - 1);
d1099 1
a1099 1
  oword = extract_signed_integer (addr, sizeof oword);
d1105 1
a1105 5
  /* Mask out old value, while avoiding shifts >= size of oword */
  if (bitsize < 8 * (int) sizeof (oword))
    oword &= ~(((((ULONGEST) 1) << bitsize) - 1) << bitpos);
  else
    oword &= ~((~(ULONGEST) 0) << bitpos);
d1108 1
a1108 1
  store_signed_integer (addr, sizeof oword, oword);
@


1.70
log
@2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (RETURN_VALUE): Default to legacy_return_value.
	* gdbarch.h, gdbarch.c: Re-generate.
	* Makefile.in (arch-utils.o): Update dependencies.
	* values.c (using_struct_return): Move code calling
	USE_STRUCT_CONVENTION to legacy_return_value, simplify.
	* stack.c (return_command): Move code calling STORE_RETURN_VALUE
	to legacy_return_value, simplify.
	* infcmd.c (print_return_value): Move code calling
	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS and EXTRACT_RETURN_VALUE
	to legacy_return_value, simplify.
	* infcall.c (call_function_by_hand): Move code calling
	EXTRACT_RETURN_VALUE to legacy_return_value, simplify.
	* arch-utils.c: Update copyright.  Include "gdbcore.h".
	(legacy_return_value): New function.
	* arch-utils.h: Update copyright.
	(legacy_return_value): Declare.
@
text
@d1173 12
a1184 9
  struct type *rangetype =
  create_range_type ((struct type *) NULL,
		     builtin_type_int,
		     lowbound, len + lowbound - 1);
  struct type *stringtype =
  create_array_type ((struct type *) NULL,
		     *current_language->string_char_type,
		     rangetype);

@


1.69
log
@2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_USE_STRUCT_CONVENTION): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* values.c (using_struct_return): Update call.
	* mcore-tdep.c: Update comment.
	* infcall.c (call_function_by_hand): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* arch-utils.h (always_use_struct_convention): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	USE_STRUCT_CONVENTION.
@
text
@a1249 14
  if (!gdbarch_return_value_p (current_gdbarch))
    {
      /* FIXME: cagney/2003-10-01: The below is dead.  Instead an
	 architecture should implement "gdbarch_return_value".  Using
	 that new function it is possible to exactly specify the ABIs
	 "struct return" vs "register return" conventions.  */
      if (code == TYPE_CODE_STRUCT
	  || code == TYPE_CODE_UNION
	  || code == TYPE_CODE_ARRAY)
	return DEPRECATED_USE_STRUCT_CONVENTION (gcc_p, value_type);
      else
	return 0;
    }

@


1.68
log
@2004-06-13  Andrew Cagney  <cagney@@gnu.org>

	* values.c (generic_use_struct_convention): Don't check gcc_p.
@
text
@d1259 1
a1259 1
	return USE_STRUCT_CONVENTION (gcc_p, value_type);
@


1.67
log
@Index: ChangeLog
2004-06-13  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (RETURN_VALUE_ON_STACK): Delete method.
	* gdbarch.h, gdbarch.c: Re-generate.
	* m68hc11-tdep.c (m68hc11_return_value_on_stack): Delete function.
	(m68hc11_use_struct_convention): Delete function.
	(m68hc11_extract_struct_value_address): Delete function.
	(m68hc11_return_value): New function.
	(m68hc11_gdbarch_init): Instead of store_return_value,
	extract_return_value, return_value_on_stack,
	deprecated_extract_struct_value_address and use_struct_convention,
	set return_value.
	* values.c (using_struct_return): Do not call
	RETURN_VALUE_ON_STACK.
	* arch-utils.h (generic_return_value_on_stack_not): Delete
	declaration.
	* arch-utils.c (generic_return_value_on_stack_not): Delete
	function.

Index: doc/ChangeLog
2004-06-13  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Delete
	description of RETURN_VALUE_ON_STACK.
@
text
@d1220 2
d1226 4
a1229 5
  return !((gcc_p == 1)
	   && (TYPE_LENGTH (value_type) == 1
	       || TYPE_LENGTH (value_type) == 2
	       || TYPE_LENGTH (value_type) == 4
	       || TYPE_LENGTH (value_type) == 8));
@


1.66
log
@2004-06-12  Andrew Cagney  <cagney@@gnu.org>

	* values.c (register_value_being_returned): Delete function.
	* infcmd.c (legacy_return_value): Delete function.
	* infcall.c (call_function_by_hand): Inline
	"register_value_being_returned", simplify.
	* values.c (using_struct_return): Update comment, refer to
	print_return_value instead of register_value_being_returned.
	* infcmd.c (print_return_value): Inline calls to
	register_value_being_returned and legacy_return_value.  Simplify.
@
text
@d1257 1
a1257 2
	  || code == TYPE_CODE_ARRAY
	  || RETURN_VALUE_ON_STACK (value_type))
@


1.65
log
@* defs.h (enum return_value_convention): Add
RETURN_VALUE_ABI_RETURNS_ADDRESS and
RETURN_VALUE_ABI_PRESERVES_ADDRESS.
* infcmd.c (legacy_return_value): New function.
(print_return_value): Rwerite to implement
RETURN_VALUE_ABI_RETURNS_ADDRESS.
* values.c (using_struct_return): Check for inequality to
RETURN_VALUE_REGISTER_CONVENTION instead of equality to
RETURN_VALUE_STRUCT_CONVENTION.
* i386-tdep.c (i386_return_value): Implement
RETURN_VALUE_ABI_RETURNS_ADDRESS.
@
text
@a1204 44
/* Deal with the return-value of a function that has "just returned".

   Extract the return-value (as a "struct value") that a function,
   using register convention, has just returned to its caller.  Assume
   that the type of the function is VALTYPE, and that the "just
   returned" register state is found in RETBUF.

   The function has "just returned" because GDB halts a returning
   function by setting a breakpoint at the return address (in the
   caller), and not the return instruction (in the callee).

   Because, in the case of a return from an inferior function call,
   GDB needs to restore the inferiors registers, RETBUF is normally a
   copy of the inferior's registers.  */

struct value *
register_value_being_returned (struct type *valtype, struct regcache *retbuf)
{
  struct value *val = allocate_value (valtype);

  /* If the function returns void, don't bother fetching the return
     value.  See also "using_struct_return".  */
  if (TYPE_CODE (valtype) == TYPE_CODE_VOID)
    return val;

  if (!gdbarch_return_value_p (current_gdbarch))
    {
      /* NOTE: cagney/2003-10-20: Unlike "gdbarch_return_value", the
         EXTRACT_RETURN_VALUE and USE_STRUCT_CONVENTION methods do not
         handle the edge case of a function returning a small
         structure / union in registers.  */
      CHECK_TYPEDEF (valtype);
      EXTRACT_RETURN_VALUE (valtype, retbuf, VALUE_CONTENTS_RAW (val));
      return val;
    }

  /* This function only handles "register convention".  */
  gdb_assert (gdbarch_return_value (current_gdbarch, valtype,
				    NULL, NULL, NULL)
	      == RETURN_VALUE_REGISTER_CONVENTION);
  gdbarch_return_value (current_gdbarch, valtype, retbuf,
			VALUE_CONTENTS_RAW (val) /*read*/, NULL /*write*/);
  return val;
}
d1246 1
a1246 1
       code in "register_value_being_returned".  */
@


1.64
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (EXTRACT_STRUCT_VALUE_ADDRESS): Deprecate.  Add
	comments mentioning extract_returned_value_address.
	* infcmd.c (print_return_value): Update.  Add comments on
	extract_returned_value_address.
	* stack.c (return_command): Add comments on
	extract_returned_value_address.
	* values.c: Update comment.
	* m32r-tdep.c: Update comment.
	* sparc-tdep.c: Update comment.
	* ia64-tdep.c (ia64_use_struct_convention): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	EXTRACT_STRUCT_VALUE_ADDRESS to
	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
@
text
@d1311 1
a1311 1
	  == RETURN_VALUE_STRUCT_CONVENTION);
@


1.64.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1173 9
a1181 12
  struct type *string_char_type;
  struct type *rangetype;
  struct type *stringtype;

  rangetype = create_range_type ((struct type *) NULL,
				 builtin_type_int,
				 lowbound, len + lowbound - 1);
  string_char_type = language_string_char_type (current_language,
						current_gdbarch);
  stringtype = create_array_type ((struct type *) NULL,
				  string_char_type,
				  rangetype);
d1205 44
a1263 2
/* NOTE: cagney/2004-06-13: Deleted check for "gcc_p".  GCC 1.x is
   dead.  */
d1268 5
a1272 4
  return !(TYPE_LENGTH (value_type) == 1
	   || TYPE_LENGTH (value_type) == 2
	   || TYPE_LENGTH (value_type) == 4
	   || TYPE_LENGTH (value_type) == 8);
d1290 1
a1290 1
       code in "print_return_value".  */
d1293 15
d1311 1
a1311 1
	  != RETURN_VALUE_REGISTER_CONVENTION);
@


1.63
log
@2003-11-19  Andrew Cagney  <cagney@@redhat.com>

	* stack.c (return_command): Handle "void", "legacy" and "unknown
	location" return values separatly.
	* values.c (using_struct_return): Return 0 for a "void" return
	type.  Mention "register_value_being_returned".
	(register_value_being_returned): Mention "using_struct_return".
@
text
@d1250 3
a1252 3
/* Should we use EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc
   and TYPE is the type (which is known to be struct, union or array).
@


1.62
log
@2003-11-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (return_value): Replace "inval" and "outval" with
	"readbuf" and "writebuf".
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* d10v-tdep.c (d10v_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-sysv-tdep.c (do_ppc_sysv_return_value): Ditto.
	(ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* values.c (register_value_being_returned): Update call.
	* stack.c (return_command): Update call.
	* gdbarch.h, gdbarch.c: Re-generate.

Index: gdb/doc/ChangeLog
2003-11-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace the
	return_value method's "inval" and "outval" parameters with
	"readbuf" and "writebuf".
@
text
@d1226 1
a1226 1
     value.  */
d1287 5
@


1.61
log
@2003-10-23  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (stack.o): Add $(regcache_h).
	* stack.c: Include "regcache.h"
	(return_command): Rewrite.  Use get_frame_id and
	get_selected_frame.  Eliminate "deprecated_selected_frame".  Warn
	about unhandled return-values.
	* value.h (set_return_value): Delete declaration.
	* values.c (set_return_value): Delete function.
@
text
@d1246 1
a1246 1
			NULL, VALUE_CONTENTS_RAW (val));
@


1.60
log
@2003-10-20  Andrew Cagney  <cagney@@redhat.com>

	* values.c (register_value_being_returned): Update comments.  Use
	"gdbarch_return_value" when available.
	(using_struct_return): Ditto.
	(set_return_value): Ditto.  Use "gdbarch_return_value" when
	available..  Print a warning, and not an error, when an unhandled
	return type is encountered.
	* infcmd.c: Include "gdb_assert.h".
	(print_return_value): When gdbarch_return_value_p, and using
	struct return, assume that the value is not available.
	* defs.h (return_value_convention): Define.
	* gdbarch.sh (gdbarch_return_value): New predicate method.
	* gdbarch.h, gdbarch.c: Re-generate
	* ppc-sysv-tdep.c (return_value_convention): Delete definition.

Index: doc/ChangeLog
2003-10-20  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	gdbarch_return_value.  Add cross references from
	USE_STRUCT_CONVENTION, EXTRACT_RETURN_VALUE, and
	STORE_RETURN_VALUE, and from/to EXTRACT_STRUCT_VALUE_ADDRESS.
@
text
@a1308 52
/* Store VAL so it will be returned if a function returns now.
   Does not verify that VAL's type matches what the current
   function wants to return.  */

void
set_return_value (struct value *val)
{
  struct type *type = check_typedef (VALUE_TYPE (val));
  enum type_code code = TYPE_CODE (type);

  if (code == TYPE_CODE_ERROR)
    error ("Function return type unknown.");

  if (gdbarch_return_value_p (current_gdbarch))
    {
      switch (gdbarch_return_value (current_gdbarch, type, NULL, NULL, NULL))
	{
	case RETURN_VALUE_REGISTER_CONVENTION:
	  /* Success.  The architecture can deal with it, write it to
             the regcache.  */
	  gdbarch_return_value (current_gdbarch, type, current_regcache,
				VALUE_CONTENTS (val), NULL);
	  return;
	case RETURN_VALUE_STRUCT_CONVENTION:
	  /* Failure.  For the moment, assume that it is not possible
             to find the location, on the stack, at which the "struct
             return" value should be stored.  Only a warning because
             an error aborts the "return" command leaving GDB in a
             weird state.  */
	  warning ("Location of return value unknown");
	  return;
	}
    }


  if (code == TYPE_CODE_STRUCT
      || code == TYPE_CODE_UNION)	/* FIXME, implement struct return.  */
    /* FIXME: cagney/2003-10-20: This should be an internal-warning.
       The problem is that while GDB's core supports "struct return"
       using "register convention", many architectures haven't been
       updated to implement the mechanisms needed to make it work.
       It's a warning, and not an error, as otherwize it will jump out
       of the "return" command leaving both GDB and the user in a very
       confused state.  */
    {
      warning ("This architecture does not support specifying a struct or union return-value.");
      return;
    }

  STORE_RETURN_VALUE (type, current_regcache, VALUE_CONTENTS (val));
}

@


1.59
log
@2003-10-01  Andrew Cagney  <cagney@@redhat.com>

	* value.h (register_value_being_returned): Declare.  Replace
	"value_being_returned".
	* infcall.c (call_function_by_hand): Use
	register_value_being_returned.
	* infcmd.c (print_return_value): Call
	"register_value_being_returned", handle struct return locally.
	* values.c (register_value_being_returned): New function.  Replace
	"value_being_returned".
@
text
@d1205 1
a1205 1
/* Deal with the value that is "about to be returned".
d1207 12
a1218 7
   Return the value that a function, using the register convention,
   returning now would be returning to its caller, assuming its type
   is VALTYPE.  RETBUF is where we look for what ought to be the
   contents of the registers (in raw form).  This is because it is
   often desirable to restore old values to those registers after
   saving the contents of interest, and then call this function using
   the saved values.  */
d1224 1
a1224 1
  CHECK_TYPEDEF (valtype);
d1227 20
a1246 2
  if (TYPE_CODE (valtype) != TYPE_CODE_VOID)
    EXTRACT_RETURN_VALUE (valtype, retbuf, VALUE_CONTENTS_RAW (val));
d1288 19
a1306 7
  if (code == TYPE_CODE_STRUCT
      || code == TYPE_CODE_UNION
      || code == TYPE_CODE_ARRAY
      || RETURN_VALUE_ON_STACK (value_type))
    return USE_STRUCT_CONVENTION (gcc_p, value_type);

  return 0;
d1322 22
d1346 11
a1356 1
    error ("GDB does not support specifying a struct or union return value.");
@


1.58
log
@2003-10-01  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c (call_function_by_hand): When STRUCT_RETURN, always
	use STRUCT_ADDR.  When not using "struct return convention", pass
	"0" to "value_being_returned".  Add FIXMEs.
	* infcmd.c (print_return_value): Pass an explicit 0/1 to
	value_being_returned.  Add comments.
	* values.c (value_being_returned): Add fixme.
	* hppa-tdep.c (hppa_extract_struct_value_address): Add FIXME.
	(hppa_value_returned_from_stack): Add FIXME.
@
text
@d1205 1
a1205 1
/* Deal with the value that is "about to be returned".  */
d1207 7
a1213 17
/* Return the value that a function returning now
   would be returning to its caller, assuming its type is VALTYPE.
   RETBUF is where we look for what ought to be the contents
   of the registers (in raw form).  This is because it is often
   desirable to restore old values to those registers
   after saving the contents of interest, and then call
   this function using the saved values.
   struct_return is non-zero when the function in question is
   using the structure return conventions on the machine in question;
   0 when it is using the value returning conventions (this often
   means returning pointer to where structure is vs. returning value). */

/* FIXME: cagney/2003-09-27: Should move the "struct return
   convention" code to the only call site in print_return_value that
   needs it.  This function can then be renamed to
   "register_value_being_returned" and with the "struct_return"
   parameter dropped.  */
d1216 1
a1216 2
value_being_returned (struct type *valtype, struct regcache *retbuf,
		      int struct_return)
d1218 1
a1218 25
  struct value *val;
  CORE_ADDR addr;

  /* If this is not defined, just use EXTRACT_RETURN_VALUE instead.  */
  if (EXTRACT_STRUCT_VALUE_ADDRESS_P ())
    if (struct_return)
      {
	addr = EXTRACT_STRUCT_VALUE_ADDRESS (retbuf);
	if (!addr)
	  error ("Function return value unknown.");
	return value_at (valtype, addr, NULL);
      }

  /* If this is not defined, just use EXTRACT_RETURN_VALUE instead.  */
  if (DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS_P ())
    if (struct_return)
      {
	char *buf = deprecated_grub_regcache_for_registers (retbuf);
	addr = DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS (buf);
	if (!addr)
	  error ("Function return value unknown.");
	return value_at (valtype, addr, NULL);
      }

  val = allocate_value (valtype);
d1220 2
a1221 1
  /* If the function returns void, don't bother fetching the return value.  */
a1223 1

@


1.57
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d1219 6
@


1.56
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@a1218 1
/* ARGSUSED */
@


1.55
log
@	* values.c (unpack_double): Call floatformat_is_valid.
@
text
@d886 1
a886 1
		       register int fieldno, register struct type *arg_type)
d955 1
a955 1
value_field (struct value *arg1, register int fieldno)
d1117 1
a1117 1
value_from_longest (struct type *type, register LONGEST num)
@


1.54
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d742 8
a749 1
         definitions and floatformat_is_invalid() function.  */
@


1.53
log
@2003-09-13  Andrew Cagney  <cagney@@redhat.com>

	* values.c (using_struct_return): Delete "function" and "funcaddr"
	parameters.
	* value.h (using_struct_return): Update declaration.
	* infcmd.c (finish_command_continuation): Update.
	(finish_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* eval.c (evaluate_subexp_standard): Update.
@
text
@d217 1
a217 1
  register struct type *encl_type = VALUE_ENCLOSING_TYPE (arg);
d294 2
a295 2
  register int i;
  register int absnum = num;
d332 1
a332 1
  register int i;
d350 1
a350 1
  register int i;
d407 1
a407 1
  register struct internalvar *var;
d439 1
a439 1
  register char *addr = VALUE_CONTENTS (var->value) + offset;
d486 1
a486 1
  register struct internalvar *var;
d501 1
a501 1
  register struct internalvar *var;
d667 3
a669 3
  register enum type_code code = TYPE_CODE (type);
  register int len = TYPE_LENGTH (type);
  register int nosign = TYPE_UNSIGNED (type);
d882 1
a882 1
  register struct type *type;
d966 1
a966 1
  register struct type *ftype = TYPE_FN_FIELD_TYPE (f, j);
d1113 2
a1114 2
  register enum type_code code;
  register int len;
d1185 2
a1186 2
  register enum type_code code = TYPE_CODE (base_type);
  register int len = TYPE_LENGTH (base_type);
d1283 1
a1283 1
  register enum type_code code = TYPE_CODE (value_type);
d1305 1
a1305 1
  register enum type_code code = TYPE_CODE (type);
@


1.52
log
@2003-07-31  Michael Snyder  <msnyder@@redhat.com>

        * value.h, values.c, infcall.c,	infcmd.c: Revert 07-30	change,
        which is already covered by the	new frames infrastructure.
@
text
@d1275 3
a1277 5
/* Return true if the function specified is using the structure returning
   convention on this machine to return arguments, or 0 if it is using
   the value returning convention.  FUNCTION is the value representing
   the function, FUNCADDR is the address of the function, and VALUE_TYPE
   is the type returned by the function.  GCC_P is nonzero if compiled
a1279 1
/* ARGSUSED */
d1281 1
a1281 2
using_struct_return (struct value *function, CORE_ADDR funcaddr,
		     struct type *value_type, int gcc_p)
@


1.51
log
@2003-07-30  Michael Snyder  <msnyder@@redhat.com>

	* structs.h (value_being_returned): Add a struct_addr argument.
	* infcall.c (call_function_by_hand): Pass struct_addr to
	value_being_returned.
	* infcmd.c (print_return_value): Pass zero as struct_addr.
	* values.c (value_being_returned): If struct_addr is passed,
	use it instead of trying to recover it from the inferior.
@
text
@d1215 1
a1215 1
		      int struct_return, CORE_ADDR struct_addr)
d1220 20
a1239 25
  if (struct_return)
    {
      if (struct_addr != 0)
	{
	  /* Struct return addr supplied by hand_function_call.  */
	  return value_at (valtype, struct_addr, NULL);
	}
      /* If one of these is not defined, just use EXTRACT_RETURN_VALUE
	 instead.  */
      else if (EXTRACT_STRUCT_VALUE_ADDRESS_P ())
	{
	  addr = EXTRACT_STRUCT_VALUE_ADDRESS (retbuf);
	  if (!addr)
	    error ("Function return value unknown.");
	  return value_at (valtype, addr, NULL);
	}
      else if (DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS_P ())
	{
	  char *buf = deprecated_grub_regcache_for_registers (retbuf);
	  addr = DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS (buf);
	  if (!addr)
	    error ("Function return value unknown.");
	  return value_at (valtype, addr, NULL);
	}
    }
@


1.50
log
@2003-06-05  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (value_h): Add $(frame_h).
	* value.h: Include "frame.h".
	(struct value): Replace "frame_addr" with "frame_id".
	(VALUE_FRAME_ID): Replace VALUE_FRAME.
	* values.c (allocate_value): Use VALUE_FRAME_ID.
	(value_copy): Use VALUE_FRAME_ID.
	* findvar.c (value_from_register): Use VALUE_FRAME_ID.
	* valops.c (value_assign): Update.  Use frame_find_by_id.
@
text
@d1215 1
a1215 1
		      int struct_return)
d1220 25
a1244 20
  /* If this is not defined, just use EXTRACT_RETURN_VALUE instead.  */
  if (EXTRACT_STRUCT_VALUE_ADDRESS_P ())
    if (struct_return)
      {
	addr = EXTRACT_STRUCT_VALUE_ADDRESS (retbuf);
	if (!addr)
	  error ("Function return value unknown.");
	return value_at (valtype, addr, NULL);
      }

  /* If this is not defined, just use EXTRACT_RETURN_VALUE instead.  */
  if (DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS_P ())
    if (struct_return)
      {
	char *buf = deprecated_grub_regcache_for_registers (retbuf);
	addr = DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS (buf);
	if (!addr)
	  error ("Function return value unknown.");
	return value_at (valtype, addr, NULL);
      }
@


1.50.6.1
log
@gdb
2003-09-19  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2003-09-15  Daniel Jacobowitz  <drow@@mvista.com>

	* values.c (unpack_double): Call floatformat_is_valid.

include
2003-09-15  Andrew Cagney  <cagney@@redhat.com>

	* floatformat.h (floatformat_to_double): Make input buffer constant.
	(floatformat_from_double, floatformat_is_valid): Ditto.

2003-09-15  Daniel Jacobowitz  <drow@@mvista.com>

	* floatformat.h (floatformat_is_valid): Add prototype.

libiberty
2003-09-15  Andrew Cagney  <cagney@@redhat.com>

	* floatformat.c (get_field): Make "data" constant.
	(floatformat_is_valid, floatformat_to_double): Make "from"
	constant, fix casts.
	(floatformat_from_double): Make "from" constant.

2003-09-15  Daniel Jacobowitz  <drow@@mvista.com>

	* floatformat.c (floatformat_is_valid): New function.
	(get_field, put_field): Correct comments.
@
text
@d742 1
a742 8
         definitions and the new cases for floatformat_is_valid ().  */

      if (!floatformat_is_valid (floatformat_from_type (type), valaddr))
	{
	  *invp = 1;
	  return 0.0;
	}

@


1.49
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d93 1
a93 1
  VALUE_FRAME (val) = 0;
d225 1
a225 1
  VALUE_FRAME (val) = VALUE_FRAME (arg);
@


1.48
log
@2003-04-17  Elena Zannoni  <ezannoni@@redhat.com>

	* values.c (value_being_returned): Don't fetch the return
        value if the return type is void.
@
text
@d797 1
a797 1
      struct symbol *sym = lookup_symbol (phys_name, 0, VAR_NAMESPACE, 0, NULL);
d971 1
a971 1
  sym = lookup_symbol (physname, 0, VAR_NAMESPACE, 0, NULL);
@


1.48.6.1
log
@Snap const char * mess.
@
text
@d47 1
a47 1
static void show_values (const char *, int);
d49 1
a49 1
static void show_convenience (const char *, int);
d348 1
a348 1
show_values (const char *num_exp, int from_tty)
d405 1
a405 1
lookup_internalvar (const char *name)
d499 1
a499 1
show_convenience (const char *ignore, int from_tty)
@


1.48.2.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d797 1
a797 1
      struct symbol *sym = lookup_symbol (phys_name, 0, VAR_DOMAIN, 0, NULL);
d971 1
a971 1
  sym = lookup_symbol (physname, 0, VAR_DOMAIN, 0, NULL);
@


1.47
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d1243 3
a1245 1
  EXTRACT_RETURN_VALUE (valtype, retbuf, VALUE_CONTENTS_RAW (val));
@


1.46
log
@2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* linux-proc.c: Include "gdb_stat.h" instead of <sys/stat.h>.
	* cp-valprint.c (cp_print_value_fields): Eliminate STREQN.
	* jv-typeprint.c (java_type_print_base): Ditto.
	* typeprint.c (typedef_print): Eliminate STREQ.
	* cli/cli-script.c (define_command, define_command): Ditto.
	* main.c (captured_main): Ditto.
	* values.c (lookup_internalvar): Ditto.
	* utils.c (safe_strerror, parse_escape): Eliminate assignment
	within `if' conditional.
	* linespec.c (decode_line_2): Ditto.
	* cli/cli-dump.c (bfd_openr_with_cleanup): Ditto.
	(bfd_openw_with_cleanup): Ditto.

Index: mi/ChangeLog
2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Include "gdb_stat.h" instead of <sys/stat.h>.
@
text
@d39 1
@


1.45
log
@2003-02-04  Andrew Cagney  <ac131313@@redhat.com>

	* values.c: Delete code conditional on IS_TRAPPED_INTERNALVAR.
	* TODO: Delete reference to IS_TRAPPED_INTERNALVAR.
	* utils.c (init_page_info): Delete reference to MPW in comments.
	* main.c (captured_main): Delete #ifdef MPW.

Index: doc/ChangeLog
2003-02-04  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	descrption of IS_TRAPPED_INTERNALVAR.
@
text
@d409 1
a409 1
    if (STREQ (var->name, name))
@


1.44
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@a425 5
#ifdef IS_TRAPPED_INTERNALVAR
  if (IS_TRAPPED_INTERNALVAR (var->name))
    return VALUE_OF_TRAPPED_INTERNALVAR (var);
#endif

a439 5
#ifdef IS_TRAPPED_INTERNALVAR
  if (IS_TRAPPED_INTERNALVAR (var->name))
    SET_TRAPPED_INTERNALVAR (var, newval, bitpos, bitsize, offset);
#endif

a451 5
#ifdef IS_TRAPPED_INTERNALVAR
  if (IS_TRAPPED_INTERNALVAR (var->name))
    SET_TRAPPED_INTERNALVAR (var, val, 0, 0, 0);
#endif

a504 4
#ifdef IS_TRAPPED_INTERNALVAR
      if (IS_TRAPPED_INTERNALVAR (var->name))
	continue;
#endif
@


1.43
log
@2003-01-06  Andrew Cagney  <cagney@@redhat.com>

	* MAINTAINERS (Target Instruction Set Architectures): Update
	arm-elf.  Can be built with -Werror, has been multiarched.

	* value.h (unpack_long): Make buffer parameter constant.
	(unpack_double, unpack_pointer, unpack_field_as_long): Ditto.
	* scm-lang.h (scm_parse): Ditto.
	* defs.h (extract_typed_address, extract_address): Ditto.
	(extract_long_unsigned_integer): Ditto.
	* inferior.h (unsigned_pointer_to_address): Ditto.
	(signed_pointer_to_address): Ditto.
	* gdbarch.sh (POINTER_TO_ADDRESS): Ditto.
	* gdbarch.h, gdbarch.c: Regenerate.
	* findvar.c (extract_long_unsigned_integer): Update.
	(extract_address): Update.
	(extract_typed_address): Update.
	(unsigned_pointer_to_address): Update.
	* values.c (unpack_long): Update.
	(unpack_double): Update.
	(unpack_pointer): Update.
	(unpack_field_as_long): Update.
	* d10v-tdep.c (d10v_pointer_to_address): Update.
	* avr-tdep.c (avr_pointer_to_address): Update.
	* scm-lang.c (scm_unpack): Update.
	* findvar.c (signed_pointer_to_address): Update.
@
text
@d2 1
d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2002.
   Free Software Foundation, Inc.
@


1.42
log
@2002-10-07  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* values.c (value_change_enclosing_type): Set
	enclosing_type field correctly also for the case where
	more memory needs to be allocated.
@
text
@d682 1
a682 1
unpack_long (struct type *type, char *valaddr)
d731 1
a731 1
unpack_double (struct type *type, char *valaddr, int *invp)
d788 1
a788 1
unpack_pointer (struct type *type, char *valaddr)
d1041 1
a1041 1
unpack_field_as_long (struct type *type, char *valaddr, int fieldno)
@


1.41
log
@        Fix PR gdb/709
        * values.c (value_static_field): Call read_var_value.
@
text
@d865 3
a867 1
      
@


1.41.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a1 1

d3 2
a4 2
   1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003 Free Software
   Foundation, Inc.
a37 1
#include "block.h"
d91 1
a91 1
  VALUE_FRAME_ID (val) = null_frame_id;
d215 1
a215 1
  struct type *encl_type = VALUE_ENCLOSING_TYPE (arg);
d223 1
a223 1
  VALUE_FRAME_ID (val) = VALUE_FRAME_ID (arg);
d292 2
a293 2
  int i;
  int absnum = num;
d330 1
a330 1
  int i;
d348 1
a348 1
  int i;
d405 1
a405 1
  struct internalvar *var;
d408 1
a408 1
    if (strcmp (var->name, name) == 0)
d425 5
d442 6
a447 1
  char *addr = VALUE_CONTENTS (var->value) + offset;
d461 5
d499 1
a499 1
  struct internalvar *var;
d514 1
a514 1
  struct internalvar *var;
d519 4
d682 1
a682 1
unpack_long (struct type *type, const char *valaddr)
d684 3
a686 3
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);
  int nosign = TYPE_UNSIGNED (type);
d731 1
a731 1
unpack_double (struct type *type, const char *valaddr, int *invp)
d759 1
a759 8
         definitions and the new cases for floatformat_is_valid ().  */

      if (!floatformat_is_valid (floatformat_from_type (type), valaddr))
	{
	  *invp = 1;
	  return 0.0;
	}

d788 1
a788 1
unpack_pointer (struct type *type, const char *valaddr)
d814 1
a814 1
      struct symbol *sym = lookup_symbol (phys_name, 0, VAR_DOMAIN, 0, NULL);
d865 1
a865 3

      VALUE_ENCLOSING_TYPE (new_val) = new_encl_type;
 
d894 1
a894 1
		       int fieldno, struct type *arg_type)
d897 1
a897 1
  struct type *type;
d963 1
a963 1
value_field (struct value *arg1, int fieldno)
d981 1
a981 1
  struct type *ftype = TYPE_FN_FIELD_TYPE (f, j);
d986 1
a986 1
  sym = lookup_symbol (physname, 0, VAR_DOMAIN, 0, NULL);
d1039 1
a1039 1
unpack_field_as_long (struct type *type, const char *valaddr, int fieldno)
d1125 1
a1125 1
value_from_longest (struct type *type, LONGEST num)
d1128 2
a1129 2
  enum type_code code;
  int len;
d1200 2
a1201 2
  enum type_code code = TYPE_CODE (base_type);
  int len = TYPE_LENGTH (base_type);
d1213 1
a1213 1
/* Deal with the return-value of a function that has "just returned".
d1215 11
a1225 12
   Extract the return-value (as a "struct value") that a function,
   using register convention, has just returned to its caller.  Assume
   that the type of the function is VALTYPE, and that the "just
   returned" register state is found in RETBUF.

   The function has "just returned" because GDB halts a returning
   function by setting a breakpoint at the return address (in the
   caller), and not the return instruction (in the callee).

   Because, in the case of a return from an inferior function call,
   GDB needs to restore the inferiors registers, RETBUF is normally a
   copy of the inferior's registers.  */
d1227 1
d1229 2
a1230 1
register_value_being_returned (struct type *valtype, struct regcache *retbuf)
d1232 2
a1233 1
  struct value *val = allocate_value (valtype);
d1235 24
a1258 15
  /* If the function returns void, don't bother fetching the return
     value.  See also "using_struct_return".  */
  if (TYPE_CODE (valtype) == TYPE_CODE_VOID)
    return val;

  if (!gdbarch_return_value_p (current_gdbarch))
    {
      /* NOTE: cagney/2003-10-20: Unlike "gdbarch_return_value", the
         EXTRACT_RETURN_VALUE and USE_STRUCT_CONVENTION methods do not
         handle the edge case of a function returning a small
         structure / union in registers.  */
      CHECK_TYPEDEF (valtype);
      EXTRACT_RETURN_VALUE (valtype, retbuf, VALUE_CONTENTS_RAW (val));
      return val;
    }
a1259 6
  /* This function only handles "register convention".  */
  gdb_assert (gdbarch_return_value (current_gdbarch, valtype,
				    NULL, NULL, NULL)
	      == RETURN_VALUE_REGISTER_CONVENTION);
  gdbarch_return_value (current_gdbarch, valtype, retbuf,
			VALUE_CONTENTS_RAW (val) /*read*/, NULL /*write*/);
d1288 5
a1292 3
/* Return true if the function returning the specified type is using
   the convention of returning structures in memory (passing in the
   address as a hidden first parameter).  GCC_P is nonzero if compiled
d1295 1
d1297 23
a1319 1
using_struct_return (struct type *value_type, int gcc_p)
d1321 2
a1322 1
  enum type_code code = TYPE_CODE (value_type);
d1327 3
a1329 19
  if (code == TYPE_CODE_VOID)
    /* A void return value is never in memory.  See also corresponding
       code in "register_value_being_returned".  */
    return 0;

  if (!gdbarch_return_value_p (current_gdbarch))
    {
      /* FIXME: cagney/2003-10-01: The below is dead.  Instead an
	 architecture should implement "gdbarch_return_value".  Using
	 that new function it is possible to exactly specify the ABIs
	 "struct return" vs "register return" conventions.  */
      if (code == TYPE_CODE_STRUCT
	  || code == TYPE_CODE_UNION
	  || code == TYPE_CODE_ARRAY
	  || RETURN_VALUE_ON_STACK (value_type))
	return USE_STRUCT_CONVENTION (gcc_p, value_type);
      else
	return 0;
    }
d1331 1
a1331 4
  /* Probe the architecture for the return-value convention.  */
  return (gdbarch_return_value (current_gdbarch, value_type,
				NULL, NULL, NULL)
	  == RETURN_VALUE_STRUCT_CONVENTION);
d1333 1
a1333 1

@


1.41.4.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d1250 3
a1252 3
/* Should we use DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS instead of
   EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc and TYPE
   is the type (which is known to be struct, union or array).
@


1.41.2.1
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a25 1
#include "block.h"
@


1.41.2.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d866 1
a866 3

      VALUE_ENCLOSING_TYPE (new_val) = new_encl_type;
 
@


1.41.2.3
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d815 1
a815 1
      struct symbol *sym = lookup_symbol_linkage (phys_name);
d989 1
a989 1
  sym = lookup_symbol_linkage (physname);
@


1.41.2.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a1 1

d3 2
a4 2
   1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003 Free Software
   Foundation, Inc.
d409 1
a409 1
    if (strcmp (var->name, name) == 0)
d426 5
d445 5
d462 5
d520 4
d683 1
a683 1
unpack_long (struct type *type, const char *valaddr)
d732 1
a732 1
unpack_double (struct type *type, const char *valaddr, int *invp)
d789 1
a789 1
unpack_pointer (struct type *type, const char *valaddr)
d1042 1
a1042 1
unpack_field_as_long (struct type *type, const char *valaddr, int fieldno)
@


1.41.2.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d27 1
a39 1
#include "block.h"
@


1.41.2.6
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d1243 1
a1243 3
  /* If the function returns void, don't bother fetching the return value.  */
  if (TYPE_CODE (valtype) != TYPE_CODE_VOID)
    EXTRACT_RETURN_VALUE (valtype, retbuf, VALUE_CONTENTS_RAW (val));
@


1.41.2.7
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d93 1
a93 1
  VALUE_FRAME_ID (val) = null_frame_id;
d225 1
a225 1
  VALUE_FRAME_ID (val) = VALUE_FRAME_ID (arg);
@


1.41.2.8
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d217 1
a217 1
  struct type *encl_type = VALUE_ENCLOSING_TYPE (arg);
d294 2
a295 2
  int i;
  int absnum = num;
d332 1
a332 1
  int i;
d350 1
a350 1
  int i;
d407 1
a407 1
  struct internalvar *var;
d439 1
a439 1
  char *addr = VALUE_CONTENTS (var->value) + offset;
d486 1
a486 1
  struct internalvar *var;
d501 1
a501 1
  struct internalvar *var;
d667 3
a669 3
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);
  int nosign = TYPE_UNSIGNED (type);
d742 1
a742 8
         definitions and the new cases for floatformat_is_valid ().  */

      if (!floatformat_is_valid (floatformat_from_type (type), valaddr))
	{
	  *invp = 1;
	  return 0.0;
	}

d879 1
a879 1
		       int fieldno, struct type *arg_type)
d882 1
a882 1
  struct type *type;
d948 1
a948 1
value_field (struct value *arg1, int fieldno)
d966 1
a966 1
  struct type *ftype = TYPE_FN_FIELD_TYPE (f, j);
d1110 1
a1110 1
value_from_longest (struct type *type, LONGEST num)
d1113 2
a1114 2
  enum type_code code;
  int len;
d1185 2
a1186 2
  enum type_code code = TYPE_CODE (base_type);
  int len = TYPE_LENGTH (base_type);
d1275 5
a1279 3
/* Return true if the function returning the specified type is using
   the convention of returning structures in memory (passing in the
   address as a hidden first parameter).  GCC_P is nonzero if compiled
d1282 1
d1284 2
a1285 1
using_struct_return (struct type *value_type, int gcc_p)
d1287 1
a1287 1
  enum type_code code = TYPE_CODE (value_type);
d1309 1
a1309 1
  enum type_code code = TYPE_CODE (type);
@


1.41.2.9
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1205 1
a1205 1
/* Deal with the return-value of a function that has "just returned".
d1207 11
a1217 12
   Extract the return-value (as a "struct value") that a function,
   using register convention, has just returned to its caller.  Assume
   that the type of the function is VALTYPE, and that the "just
   returned" register state is found in RETBUF.

   The function has "just returned" because GDB halts a returning
   function by setting a breakpoint at the return address (in the
   caller), and not the return instruction (in the callee).

   Because, in the case of a return from an inferior function call,
   GDB needs to restore the inferiors registers, RETBUF is normally a
   copy of the inferior's registers.  */
d1219 1
d1221 2
a1222 1
register_value_being_returned (struct type *valtype, struct regcache *retbuf)
d1224 29
a1252 1
  struct value *val = allocate_value (valtype);
a1253 22
  /* If the function returns void, don't bother fetching the return
     value.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_VOID)
    return val;

  if (!gdbarch_return_value_p (current_gdbarch))
    {
      /* NOTE: cagney/2003-10-20: Unlike "gdbarch_return_value", the
         EXTRACT_RETURN_VALUE and USE_STRUCT_CONVENTION methods do not
         handle the edge case of a function returning a small
         structure / union in registers.  */
      CHECK_TYPEDEF (valtype);
      EXTRACT_RETURN_VALUE (valtype, retbuf, VALUE_CONTENTS_RAW (val));
      return val;
    }

  /* This function only handles "register convention".  */
  gdb_assert (gdbarch_return_value (current_gdbarch, valtype,
				    NULL, NULL, NULL)
	      == RETURN_VALUE_REGISTER_CONVENTION);
  gdbarch_return_value (current_gdbarch, valtype, retbuf,
			VALUE_CONTENTS_RAW (val) /*read*/, NULL /*write*/);
d1295 7
a1301 19
  if (!gdbarch_return_value_p (current_gdbarch))
    {
      /* FIXME: cagney/2003-10-01: The below is dead.  Instead an
	 architecture should implement "gdbarch_return_value".  Using
	 that new function it is possible to exactly specify the ABIs
	 "struct return" vs "register return" conventions.  */
      if (code == TYPE_CODE_STRUCT
	  || code == TYPE_CODE_UNION
	  || code == TYPE_CODE_ARRAY
	  || RETURN_VALUE_ON_STACK (value_type))
	return USE_STRUCT_CONVENTION (gcc_p, value_type);
      else
	return 0;
    }

  /* Probe the architecture for the return-value convention.  */
  return (gdbarch_return_value (current_gdbarch, value_type,
				NULL, NULL, NULL)
	  == RETURN_VALUE_STRUCT_CONVENTION);
d1304 20
@


1.41.2.10
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1226 1
a1226 1
     value.  See also "using_struct_return".  */
a1286 5

  if (code == TYPE_CODE_VOID)
    /* A void return value is never in memory.  See also corresponding
       code in "register_value_being_returned".  */
    return 0;
@


1.40
log
@Index: ChangeLog
===================================================================
RCS file: /cvs/src/src/gdb/ChangeLog,v
retrieving revision 1.3144
diff -u -r1.3144 ChangeLog
--- ChangeLog	23 Aug 2002 23:05:38 -0000	1.3144
+++ ChangeLog	23 Aug 2002 23:14:45 -0000
@@@@ -1,3 +1,53 @@@@
2002-08-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (STORE_RETURN_VALUE): Add regcache parameter.
	(DEPRECATED_STORE_RETURN_VALUE): New method.
	(EXTRACT_RETURN_VALUE): Make buffer parameter a void pointer.
	* gdbarch.h, gdbarch.c: Re-generate.

	* values.c (set_return_value): Pass current_regcache to
	STORE_RETURN_VALUE.
	* arch-utils.h (legacy_store_return_value): Declare.
	* arch-utils.c (legacy_store_return_value): New function.
	(legacy_extract_return_value): Update parameters.

	* config/pa/tm-hppa.h (DEPRECATED_STORE_RETURN_VALUE): Rename
	STORE_RETURN_VALUE.
	* config/pa/tm-hppa64.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/z8k/tm-z8k.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparclet.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/mn10200/tm-mn10200.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-linux.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m32r/tm-m32r.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8500/tm-h8500.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8300/tm-h8300.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.

	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* i386-tdep.c (i386_extract_return_value): Update.
	* arch-utils.c (legacy_extract_return_value): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.

Index: doc/ChangeLog
2002-08-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Update
	STORE_RETURN_VALUE, mention regcache.
@
text
@d803 2
a804 2
  CORE_ADDR addr;
  asection *sect;
d807 3
a809 2
      addr = TYPE_FIELD_STATIC_PHYSADDR (type, fieldno);
      sect = NULL;
d815 1
a815 8
      /* In some cases (involving uninitalized, unreferenced static
	 const integral members), g++ -gdwarf-2 can emit debugging
	 information giving rise to symbols whose SYMBOL_CLASS is
	 LOC_UNRESOLVED.  In that case, do a minimal symbol lookup.
	 If it returns a useful value, then the symbol was defined
	 elsewhere, so we use that information.  Otherwise, return
	 NULL. */
      if (sym == NULL || SYMBOL_CLASS (sym) == LOC_UNRESOLVED)
d824 3
a826 2
	      addr = SYMBOL_VALUE_ADDRESS (msym);
	      sect = SYMBOL_BFD_SECTION (msym);
d831 6
a836 11
 	  /* Anything static that isn't a constant, has an address */
 	  if (SYMBOL_CLASS (sym) != LOC_CONST)
 	    {
	      addr = SYMBOL_VALUE_ADDRESS (sym);
	      sect = SYMBOL_BFD_SECTION (sym);
	    }
 	  /* However, static const's do not, the value is already known.  */
 	  else
 	    {
 	      return value_from_longest (TYPE_FIELD_TYPE (type, fieldno), SYMBOL_VALUE (sym));
 	    }
d838 3
a840 1
      SET_FIELD_PHYSADDR (TYPE_FIELD (type, fieldno), addr);
d842 1
a842 1
  return value_at (TYPE_FIELD_TYPE (type, fieldno), addr, sect);
@


1.40.6.1
log
@        Fix PR gdb/709
        * values.c (value_static_field): Call read_var_value.
@
text
@d803 2
a804 2
  struct value *retval;

d807 2
a808 3
      retval = value_at (TYPE_FIELD_TYPE (type, fieldno),
			 TYPE_FIELD_STATIC_PHYSADDR (type, fieldno),
			 NULL);
d814 8
a821 1
      if (sym == NULL)
d830 2
a831 3
	      retval = value_at (TYPE_FIELD_TYPE (type, fieldno),
				 SYMBOL_VALUE_ADDRESS (msym),
				 SYMBOL_BFD_SECTION (msym));
d836 11
a846 6
	  /* SYM should never have a SYMBOL_CLASS which will require
	     read_var_value to use the FRAME parameter.  */
	  if (symbol_read_needs_frame (sym))
	    warning ("static field's value depends on the current "
		     "frame - bad debug info?");
	  retval = read_var_value (sym, NULL);
d848 1
a848 3
      if (retval && VALUE_LVAL (retval) == lval_memory)
	SET_FIELD_PHYSADDR (TYPE_FIELD (type, fieldno),
			    VALUE_ADDRESS (retval));
d850 1
a850 1
  return retval;
@


1.39
log
@2002-08-19  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (search_struct_field): Change error message to treat
	return value of 0 from value_static_field as meaning that field is
	optimized out.
	(value_struct_elt_for_reference): Ditto.
	* values.c (value_static_field): Treat an unresolved location the
	same as a nonexistent symbol.  Fix PR gdb/635.
@
text
@d1339 1
a1339 1
  STORE_RETURN_VALUE (type, VALUE_CONTENTS (val));
@


1.38
log
@* gdbarch.sh (struct regcache): Add opaque declaration.
(EXTRACT_RETURN_VALUE): New architecture method.
(EXTRACT_STRUCT_VALUE_ADDRESS): Ditto.
* gdbarch.h, gdbarch.c: Regenerate.
* arch-utils.c (legacy_extract_return_value): New function.
* arch-utils.h (legacy_extract_return_value): Declare.
* values.c (value_being_returned): Re-enable code handling
EXTRACT_STRUCT_VALUE_ADDRESS.  Move
deprecated_grub_regcache_for_registers call to block handling
DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
(EXTRACT_RETURN_VALUE): Do not define.
@
text
@d796 3
a798 1
/* Get the value of the FIELDN'th field (which must be static) of TYPE. */
d814 8
a821 1
      if (sym == NULL)
@


1.37
log
@* infcmd.c (print_return_value): Remove compatibility code calling
deprecated_grub_regcache_for_registers.

* values.c: Include "regcache.h".
(value_being_returned): Update.  Use
deprecated_grub_regcache_for_registers to extract the register
buffer address.
* value.h (value_being_returned): Change ``retbuf'' parameter to a
``struct regcache''.
* Makefile.in (values.o): Add dependency on $(regcache_h).

* inferior.h (run_stack_dummy): Change type of second parameter to
a ``struct regcache''.
* valops.c (hand_function_call): Change type of retbuf to ``struct
regcache''.  Allocate using regcache_xmalloc, clean using
make_cleanup_regcache_xfree.
* infcmd.c (run_stack_dummy): Update.  Use
regcache_cpu_no_passthrough instead of memcpy to copy the buffer.

* regcache.c (do_regcache_xfree): New function.
(make_cleanup_regcache_xfree): New function.
* regcache.h (make_cleanup_regcache_xfree): Declare.
@
text
@d1228 1
a1228 1
value_being_returned (struct type *valtype, struct regcache *buf,
a1230 1
  char *retbuf = deprecated_grub_regcache_for_registers (buf);
a1233 1
#if 0
a1242 1
#endif
d1248 2
a1249 1
	addr = DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS (retbuf);
a1256 1
#define EXTRACT_RETURN_VALUE DEPRECATED_EXTRACT_RETURN_VALUE
@


1.36
log
@+	* gdbarch.sh (DEPRECATED_EXTRACT_RETURN_VALUE): Rename
+	EXTRACT_RETURN_VALUE.
+	(DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Rename
+	EXTRACT_STRUCT_VALUE_ADDRESS.
+	* gdbarch.h, gdbarch.c: Regenerate.
+
+	* values.c (value_being_returned): Handle
+	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
+	(EXTRACT_RETURN_VALUE): Define as DEPRECATED_EXTRACT_RETURN_VALUE.
+
+	* arm-linux-tdep.c (arm_linux_init_abi): Update.
+	* arm-tdep.c (arm_gdbarch_init): Update.
+	* avr-tdep.c (avr_gdbarch_init): Update.
+	* cris-tdep.c (cris_gdbarch_init): Update.
+	* d10v-tdep.c (d10v_gdbarch_init): Update.
+	* ia64-tdep.c (ia64_gdbarch_init): Update.
+	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
+	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sh-tdep.c (sh_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sparc-tdep.c (sparc_gdbarch_init): Update.
+	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
+	* v850-tdep.c (v850_gdbarch_init): Update.
+	* vax-tdep.c (vax_gdbarch_init): Update.
+	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
+	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
+
+	* config/arc/tm-arc.h: Update.
+	* config/d30v/tm-d30v.h: Update.
+	* config/fr30/tm-fr30.h: Update.
+	* config/h8300/tm-h8300.h: Update.
* config/h8500/tm-h8500.h: Update.
* config/i386/tm-i386.h: Update.
* config/i386/tm-ptx.h: Update.
* config/i386/tm-symmetry.h: Update.
* config/i960/tm-i960.h: Update.
* config/m32r/tm-m32r.h: Update.
* config/m68k/tm-delta68.h: Update.
* config/m68k/tm-linux.h: Update.
* config/m68k/tm-m68k.h: Update.
* config/m88k/tm-m88k.h: Update.
* config/mcore/tm-mcore.h: Update.
* config/mips/tm-mips.h: Update.
* config/mn10200/tm-mn10200.h: Update.
* config/pa/tm-hppa.h: Update.
* config/pa/tm-hppa64.h: Update.
* config/sparc/tm-sp64.h: Update.
* config/sparc/tm-sparc.h: Update.
* config/sparc/tm-sparclet.h: Update.
* config/z8k/tm-z8k.h: Update.
@
text
@d37 1
d1228 2
a1229 1
value_being_returned (struct type *valtype, char *retbuf, int struct_return)
d1231 1
@


1.35
log
@2002-05-11  Daniel Jacobowitz  <drow@@mvista.com>

        * TODO: Remove value_headof/value_from_vtable_info comment.
        * printcmd.c (print_command_1): Don't call value_from_vtable_info.
        * values.c (value_headof, value_from_vtable_info): Delete.
        * value.h (value_from_vtable_info): Delete prototype.
@
text
@d1232 1
d1242 11
d1256 1
@


1.35.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a1231 1
#if 0
a1240 11
#endif

  /* If this is not defined, just use EXTRACT_RETURN_VALUE instead.  */
  if (DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS_P ())
    if (struct_return)
      {
	addr = DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS (retbuf);
	if (!addr)
	  error ("Function return value unknown.");
	return value_at (valtype, addr, NULL);
      }
a1243 1
#define EXTRACT_RETURN_VALUE DEPRECATED_EXTRACT_RETURN_VALUE
@


1.35.4.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a36 1
#include "regcache.h"
d1227 1
a1227 2
value_being_returned (struct type *valtype, struct regcache *retbuf,
		      int struct_return)
d1232 1
d1242 1
d1248 1
a1248 2
	char *buf = deprecated_grub_regcache_for_registers (retbuf);
	addr = DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS (buf);
d1256 1
@


1.35.4.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d796 1
a796 3
/* Get the value of the FIELDN'th field (which must be static) of
   TYPE.  Return NULL if the field doesn't exist or has been
   optimized out. */
d812 1
a812 8
      /* In some cases (involving uninitalized, unreferenced static
	 const integral members), g++ -gdwarf-2 can emit debugging
	 information giving rise to symbols whose SYMBOL_CLASS is
	 LOC_UNRESOLVED.  In that case, do a minimal symbol lookup.
	 If it returns a useful value, then the symbol was defined
	 elsewhere, so we use that information.  Otherwise, return
	 NULL. */
      if (sym == NULL || SYMBOL_CLASS (sym) == LOC_UNRESOLVED)
d1330 1
a1330 1
  STORE_RETURN_VALUE (type, current_regcache, VALUE_CONTENTS (val));
@


1.35.4.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d803 2
a804 2
  struct value *retval;

d807 2
a808 3
      retval = value_at (TYPE_FIELD_TYPE (type, fieldno),
			 TYPE_FIELD_STATIC_PHYSADDR (type, fieldno),
			 NULL);
d814 8
a821 1
      if (sym == NULL)
d830 2
a831 3
	      retval = value_at (TYPE_FIELD_TYPE (type, fieldno),
				 SYMBOL_VALUE_ADDRESS (msym),
				 SYMBOL_BFD_SECTION (msym));
d836 11
a846 6
	  /* SYM should never have a SYMBOL_CLASS which will require
	     read_var_value to use the FRAME parameter.  */
	  if (symbol_read_needs_frame (sym))
	    warning ("static field's value depends on the current "
		     "frame - bad debug info?");
	  retval = read_var_value (sym, NULL);
d848 1
a848 3
      if (retval && VALUE_LVAL (retval) == lval_memory)
	SET_FIELD_PHYSADDR (TYPE_FIELD (type, fieldno),
			    VALUE_ADDRESS (retval));
d850 1
a850 1
  return retval;
@


1.35.4.5
log
@merge from mainline
@
text
@d865 1
a865 3

      VALUE_ENCLOSING_TYPE (new_val) = new_encl_type;
 
@


1.35.2.1
log
@regbuf
@
text
@d1227 1
a1227 2
value_being_returned (struct type *valtype, struct regbuf *retbuf,
		      int struct_return)
@


1.35.2.2
log
@regbuf->regcache
@
text
@d1227 1
a1227 1
value_being_returned (struct type *valtype, struct regcache *retbuf,
@


1.35.2.3
log
@merge from trunk
@
text
@a1232 1
#if 0
a1241 11
#endif

  /* If this is not defined, just use EXTRACT_RETURN_VALUE instead.  */
  if (DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS_P ())
    if (struct_return)
      {
	addr = DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS (retbuf);
	if (!addr)
	  error ("Function return value unknown.");
	return value_at (valtype, addr, NULL);
      }
a1244 1
#define EXTRACT_RETURN_VALUE DEPRECATED_EXTRACT_RETURN_VALUE
@


1.35.2.4
log
@fixes for HEAD->branch merge.
@
text
@a36 1
#include "regcache.h"
d1233 1
d1243 1
d1249 1
a1249 2
	char *registers = deprecated_grub_regcache_for_registers (retbuf);
	addr = DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS (registers);
d1257 1
@


1.35.2.5
log
@Merge with trunk.
@
text
@a1233 1
#if 0
a1242 11
#endif

  /* If this is not defined, just use EXTRACT_RETURN_VALUE instead.  */
  if (DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS_P ())
    if (struct_return)
      {
	addr = DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS (retbuf);
	if (!addr)
	  error ("Function return value unknown.");
	return value_at (valtype, addr, NULL);
      }
a1256 1
#define EXTRACT_RETURN_VALUE DEPRECATED_EXTRACT_RETURN_VALUE
@


1.35.2.6
log
@(more) Merge with trunk.
@
text
@d1234 1
d1244 1
d1250 1
a1250 2
	void *regs = deprecated_grub_regcache_for_registers (retbuf);
	addr = DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS (regs);
d1269 1
@


1.35.2.7
log
@merge with trunk
@
text
@d1248 11
@


1.34
log
@* config/vax/tm-vax.h (INVALID_FLOAT): Move macro from here...
* vax-tdep.c (INVALID_FLOAT): To here.  Document why it is broken.

* rs6000-tdep.c (rs6000_do_registers_info): Delete code wrapped in
#ifdef INVALID_FLOAT.
* infcmd.c (do_registers_info): Ditto.
* values.c (unpack_double): Ditto.  Add comment.

* config/ns32k/tm-umax.h (INVALID_FLOAT): Delete macro that was
already commented out.
@
text
@a43 2
static struct value *value_headof (struct value *, struct type *, struct type *);

a1020 87
/* ARG is a pointer to an object we know to be at least
   a DTYPE.  BTYPE is the most derived basetype that has
   already been searched (and need not be searched again).
   After looking at the vtables between BTYPE and DTYPE,
   return the most derived type we find.  The caller must
   be satisfied when the return value == DTYPE.

   FIXME-tiemann: should work with dossier entries as well.
   NOTICE - djb: I see no good reason at all to keep this function now that
   we have RTTI support. It's used in literally one place, and it's
   hard to keep this function up to date when it's purpose is served
   by value_rtti_type efficiently.
   Consider it gone for 5.1. */

static struct value *
value_headof (struct value *in_arg, struct type *btype, struct type *dtype)
{
  /* First collect the vtables we must look at for this object.  */
  struct value *arg;
  struct value *vtbl;
  struct symbol *sym;
  char *demangled_name;
  struct minimal_symbol *msymbol;

  btype = TYPE_VPTR_BASETYPE (dtype);
  CHECK_TYPEDEF (btype);
  arg = in_arg;
  if (btype != dtype)
      arg = value_cast (lookup_pointer_type (btype), arg);
  if (TYPE_CODE (VALUE_TYPE (arg)) == TYPE_CODE_REF)
      {
	  /*
	   * Copy the value, but change the type from (T&) to (T*).
	   * We keep the same location information, which is efficient,
	   * and allows &(&X) to get the location containing the reference.
	   */
	  arg = value_copy (arg);
	  VALUE_TYPE (arg) = lookup_pointer_type (TYPE_TARGET_TYPE (VALUE_TYPE (arg)));
      }
  if (VALUE_ADDRESS(value_field (value_ind(arg), TYPE_VPTR_FIELDNO (btype)))==0)
      return arg;

  vtbl = value_ind (value_field (value_ind (arg), TYPE_VPTR_FIELDNO (btype)));
  /* Turn vtable into typeinfo function */
  VALUE_OFFSET(vtbl)+=4;

  msymbol = lookup_minimal_symbol_by_pc ( value_as_address(value_ind(vtbl)) );
  if (msymbol == NULL
      || (demangled_name = SYMBOL_NAME (msymbol)) == NULL)
      {
	  /* If we expected to find a vtable, but did not, let the user
	     know that we aren't happy, but don't throw an error.
	     FIXME: there has to be a better way to do this.  */
	  struct type *error_type = (struct type *) xmalloc (sizeof (struct type));
	  memcpy (error_type, VALUE_TYPE (in_arg), sizeof (struct type));
	  TYPE_NAME (error_type) = savestring ("suspicious *", sizeof ("suspicious *"));
	  VALUE_TYPE (in_arg) = error_type;
	  return in_arg;
      }
  demangled_name = cplus_demangle(demangled_name,DMGL_ANSI);
  *(strchr (demangled_name, ' ')) = '\0';

  sym = lookup_symbol (demangled_name, 0, VAR_NAMESPACE, 0, 0);
  if (sym == NULL)
      error ("could not find type declaration for `%s'", demangled_name);

  arg = in_arg;
  VALUE_TYPE (arg) = lookup_pointer_type (SYMBOL_TYPE (sym));
  return arg;
}

/* ARG is a pointer object of type TYPE.  If TYPE has virtual
   function tables, probe ARG's tables (including the vtables
   of its baseclasses) to figure out the most derived type that ARG
   could actually be a pointer to.  */

struct value *
value_from_vtable_info (struct value *arg, struct type *type)
{
  /* Take care of preliminaries.  */
  if (TYPE_VPTR_FIELDNO (type) < 0)
    fill_in_vptr_fieldno (type);
  if (TYPE_VPTR_FIELDNO (type) < 0)
    return 0;

  return value_headof (arg, 0, type);
}
@


1.33
log
@2002-01-04  Daniel Jacobowitz  <drow@@mvista.com>

        * cp-abi.c: Fix whitespace.
        (baseclass_offset): New wrapper function.
        * cp-abi.h (baseclass_offset): Add prototype.
        (struct cp_abi_ops): Add baseclass_offset pointer.

        * valops.c (vb_match): Move to...
        * gnu-v2-abi.c (vb_match): here.
        * valops.c (baseclass_offset): Move to...
        * gnu-v2-abi.c (gnuv2_baseclass_offset): here, and rename.

        * gnu-v3-abi.c (gnuv3_baseclass_offset): New function.

        * gnu-v2-abi.c (init_gnuv2_ops): Initialize baseclass_offset.
        * gnu-v3-abi.c (init_gnuv3_ops): Likewise.
        * hpacc-abi.c (init_hpacc_ops): Likewise.
@
text
@d745 16
a760 7
#ifdef INVALID_FLOAT
      if (INVALID_FLOAT (valaddr, len))
	{
	  *invp = 1;
	  return 1.234567891011121314;
	}
#endif
@


1.32
log
@s/value_ptr/struct value */
@
text
@a1100 95

/* Return true if the INDEXth field of TYPE is a virtual baseclass
   pointer which is for the base class whose type is BASECLASS.  */

static int
vb_match (struct type *type, int index, struct type *basetype)
{
  struct type *fieldtype;
  char *name = TYPE_FIELD_NAME (type, index);
  char *field_class_name = NULL;

  if (*name != '_')
    return 0;
  /* gcc 2.4 uses _vb$.  */
  if (name[1] == 'v' && name[2] == 'b' && is_cplus_marker (name[3]))
    field_class_name = name + 4;
  /* gcc 2.5 will use __vb_.  */
  if (name[1] == '_' && name[2] == 'v' && name[3] == 'b' && name[4] == '_')
    field_class_name = name + 5;

  if (field_class_name == NULL)
    /* This field is not a virtual base class pointer.  */
    return 0;

  /* It's a virtual baseclass pointer, now we just need to find out whether
     it is for this baseclass.  */
  fieldtype = TYPE_FIELD_TYPE (type, index);
  if (fieldtype == NULL
      || TYPE_CODE (fieldtype) != TYPE_CODE_PTR)
    /* "Can't happen".  */
    return 0;

  /* What we check for is that either the types are equal (needed for
     nameless types) or have the same name.  This is ugly, and a more
     elegant solution should be devised (which would probably just push
     the ugliness into symbol reading unless we change the stabs format).  */
  if (TYPE_TARGET_TYPE (fieldtype) == basetype)
    return 1;

  if (TYPE_NAME (basetype) != NULL
      && TYPE_NAME (TYPE_TARGET_TYPE (fieldtype)) != NULL
      && STREQ (TYPE_NAME (basetype),
		TYPE_NAME (TYPE_TARGET_TYPE (fieldtype))))
    return 1;
  return 0;
}

/* Compute the offset of the baseclass which is
   the INDEXth baseclass of class TYPE,
   for value at VALADDR (in host) at ADDRESS (in target).
   The result is the offset of the baseclass value relative
   to (the address of)(ARG) + OFFSET.

   -1 is returned on error. */

int
baseclass_offset (struct type *type, int index, char *valaddr,
		  CORE_ADDR address)
{
  struct type *basetype = TYPE_BASECLASS (type, index);

  if (BASETYPE_VIA_VIRTUAL (type, index))
    {
      /* Must hunt for the pointer to this virtual baseclass.  */
      register int i, len = TYPE_NFIELDS (type);
      register int n_baseclasses = TYPE_N_BASECLASSES (type);

      /* First look for the virtual baseclass pointer
         in the fields.  */
      for (i = n_baseclasses; i < len; i++)
	{
	  if (vb_match (type, i, basetype))
	    {
	      CORE_ADDR addr
	      = unpack_pointer (TYPE_FIELD_TYPE (type, i),
				valaddr + (TYPE_FIELD_BITPOS (type, i) / 8));

	      return addr - (LONGEST) address;
	    }
	}
      /* Not in the fields, so try looking through the baseclasses.  */
      for (i = index + 1; i < n_baseclasses; i++)
	{
	  int boffset =
	  baseclass_offset (type, i, valaddr, address);
	  if (boffset)
	    return boffset;
	}
      /* Not found.  */
      return -1;
    }

  /* Baseclass is easily computed.  */
  return TYPE_BASECLASS_BITPOS (type, index) / 8;
}
@


1.31
log
@Rearange code to supress -Wuninitialized error.
@
text
@d2 2
a3 2
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000
d44 1
a44 1
static value_ptr value_headof (value_ptr, struct type *, struct type *);
d62 1
a62 1
    value_ptr values[VALUE_HISTORY_CHUNK];
d75 1
a75 1
static value_ptr all_values;
d79 1
a79 1
value_ptr
d82 1
a82 1
  register value_ptr val;
d109 1
a109 1
value_ptr
d127 1
a127 1
value_ptr
d136 1
a136 1
value_free_to_mark (value_ptr mark)
d138 2
a139 1
  value_ptr val, next;
d155 2
a156 1
  register value_ptr val, next;
d171 1
a171 1
release_value (register value_ptr val)
d173 1
a173 1
  register value_ptr v;
d192 2
a193 2
value_ptr
value_release_to_mark (value_ptr mark)
d195 2
a196 1
  value_ptr val, next;
d213 2
a214 2
value_ptr
value_copy (value_ptr arg)
d217 1
a217 1
  register value_ptr val = allocate_value (encl_type);
d249 1
a249 1
record_latest_value (value_ptr val)
d271 1
a271 1
      register struct value_history_chunk *new
d289 1
a289 1
value_ptr
d292 1
a292 1
  register struct value_history_chunk *chunk;
d330 1
a330 1
  register struct value_history_chunk *next;
d332 1
a332 1
  register value_ptr val;
d350 1
a350 1
  register value_ptr val;
d421 1
a421 1
value_ptr
d424 1
a424 1
  register value_ptr val;
d441 1
a441 1
			   int bitsize, value_ptr newval)
d458 1
a458 1
set_internalvar (struct internalvar *var, value_ptr val)
d460 1
a460 1
  value_ptr newval;
d544 1
a544 1
value_as_long (register value_ptr val)
d554 1
a554 1
value_as_double (register value_ptr val)
d568 1
a568 1
value_as_address (value_ptr val)
d790 1
a790 1
value_ptr
d842 2
a843 2
value_ptr
value_change_enclosing_type (value_ptr val, struct type *new_encl_type)
d852 2
a853 2
      value_ptr new_val;
      register value_ptr prev;
d855 1
a855 1
      new_val = (value_ptr) xrealloc (val, sizeof (struct value) + TYPE_LENGTH (new_encl_type));
d883 2
a884 2
value_ptr
value_primitive_field (register value_ptr arg1, int offset,
d887 1
a887 1
  register value_ptr v;
d953 2
a954 2
value_ptr
value_field (register value_ptr arg1, register int fieldno)
d967 2
a968 2
value_ptr
value_fn_field (value_ptr *arg1p, struct fn_field *f, int j, struct type *type,
d971 1
a971 1
  register value_ptr v;
d1028 2
a1029 2
static value_ptr
value_headof (value_ptr in_arg, struct type *btype, struct type *dtype)
d1032 2
a1033 1
  value_ptr arg, vtbl;
d1090 2
a1091 2
value_ptr
value_from_vtable_info (value_ptr arg, struct type *type)
d1297 1
a1297 1
value_ptr
d1300 1
a1300 1
  register value_ptr val = allocate_value (type);
d1334 1
a1334 1
value_ptr
d1337 1
a1337 1
  value_ptr val = allocate_value (type);
d1348 1
a1348 1
value_ptr
d1351 1
a1351 1
  value_ptr val;
d1368 1
a1368 1
value_ptr
d1371 1
a1371 1
  register value_ptr val = allocate_value (type);
d1401 1
a1401 1
value_ptr
d1404 1
a1404 1
  register value_ptr val;
d1458 1
a1458 1
using_struct_return (value_ptr function, CORE_ADDR funcaddr,
d1480 1
a1480 1
set_return_value (value_ptr val)
@


1.30
log
@Approved by Jim Blandy:

	2001-12-10  Fred Fish  <fnf@@redhat.com>
	* values.c (value_fn_field): Add physname variable.  Use a minimal
	symbol if we don't find a full symbol.  Remove setting of the new
	value's type since that was already done by allocate_value().
	Remove obsolete commented out error call since callees need to
	handle a NULL return, which is possible result not an error.
	* eval.c (evaluate_subexp_standard): Move check for inlined
	functions to precede attempt to dereference a NULL argvec[0].
@
text
@d36 1
d975 1
a975 1
  if (!sym)
d977 5
d983 2
a985 3

  if (!sym && !msym)
    return NULL;
@


1.29
log
@        * values.c (value_primitive_field): Add embedded_offset to the
        address of structure members.
        * gnu-v3-abi.c (gnuv3_rtti_type): Cast to base type before
        attempting to access vtable pointer.  Set using_enc_p if we cast.
        (gnuv3_virtual_fn_field): Call value_cast with structure rather than
        structure pointer.  Cast to base type before attempting to access
        vtable pointer.
@
text
@d957 5
a961 1
   J is an index into F which provides the desired method. */
d969 1
d971 1
d973 1
a973 2
  sym = lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, j),
		       0, VAR_NAMESPACE, 0, NULL);
d975 5
a980 4
/*
   error ("Internal error: could not find physical method named %s",
   TYPE_FN_FIELD_PHYSNAME (f, j));
 */
d983 8
a990 2
  VALUE_ADDRESS (v) = BLOCK_START (SYMBOL_BLOCK_VALUE (sym));
  VALUE_TYPE (v) = ftype;
@


1.28
log
@* values.c (value_being_returned): Make error message a proper
sentence.
@
text
@d932 2
a933 1
      VALUE_OFFSET (v) = VALUE_OFFSET (arg1) + offset;
@


1.27
log
@* values.c (value_as_address): If VAL is a function or method,
just return its address; don't let COERCE_ARRAY convert its
address to a pointer, and then have unpack_long convert it back to
an address.
@
text
@d1391 1
a1391 1
	  error ("Function return value unknown");
@


1.26
log
@gdbarch.sh provides default for USE_STRUCT_CONVENTION.
@
text
@d574 42
@


1.25
log
@* value.h (value_as_address): Rename value_as_pointer.
* eval.c, findvar.c, gnu-v2-abi.c, gnu-v3-abi.c, jv-lang.c,
jv-valprint.c, printcmd.c, stack.c, top.c, valarith.c, valops.c,
values.c: Update.
@
text
@a1384 5
#ifndef USE_STRUCT_CONVENTION
#define USE_STRUCT_CONVENTION(gcc_p,type) generic_use_struct_convention (gcc_p, type)
#endif


@


1.24
log
@Add INTEGER_TO_ADDRESS to hadle nasty harvard architectures that do
funnies to integer to address conversions.
@
text
@d564 1
a564 1
value_as_pointer (value_ptr val)
d726 1
a726 1
   references to be dereferenced, call value_as_pointer() instead.
d996 1
a996 1
  msymbol = lookup_minimal_symbol_by_pc ( value_as_pointer(value_ind(vtbl)) );
@


1.23
log
@* doublest.h (store_floating, extract_floating): Add comment
indicating these functions are deprecated.
(extract_typed_floating, store_typed_floating): Declare.
* doublest.c: Include "gdbtypes.h".
(extract_typed_floating, store_typed_floating): Define.

* stabsread.c (define_symbol): Use store_typed_floating.
* valarith.c (value_binop): Ditto.
* values.c (unpack_long): Use extract_typed_floating.
(unpack_double): Ditto.
@
text
@d575 43
a617 29
  /* In converting VAL to an address (CORE_ADDR), any small integers
     are first cast to a generic pointer.  The function unpack_long
     will then correctly convert that pointer into a canonical address
     (using POINTER_TO_ADDRESS).

     Without the cast, the MIPS gets: 0xa0000000 -> (unsigned int)
     0xa0000000 -> (LONGEST) 0x00000000a0000000

     With the cast, the MIPS gets: 0xa0000000 -> (unsigned int)
     0xa0000000 -> (void*) 0xa0000000 -> (LONGEST) 0xffffffffa0000000.

     If the user specifies an integer that is larger than the target
     pointer type, it is assumed that it was intentional and the value
     is converted directly into an ADDRESS.  This ensures that no
     information is discarded.

     NOTE: The cast operation may eventualy be converted into a TARGET
     method (see POINTER_TO_ADDRESS() and ADDRESS_TO_POINTER()) so
     that the TARGET ISA/ABI can apply an arbitrary conversion.

     NOTE: In pure harvard architectures function and data pointers
     can be different and may require different integer to pointer
     conversions. */
  if (TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_INT
      && (TYPE_LENGTH (VALUE_TYPE (val))
	  <= TYPE_LENGTH (builtin_type_void_data_ptr)))
    {
      val = value_cast (builtin_type_void_data_ptr, val);
    }
@


1.22
log
@* defs.h (HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_LONG_DOUBLE_FORMAT, DOUBLEST)
(floatformat_to_doublest, floatformat_from_doublest)
(floatformat_is_negative, floatformat_is_nan)
(floatformat_mantissa, store_floating)
(extract_floating): Move declaration from here.
* doublest.h: To here.  New file.
* utils.c (get_field, floatformat_to_doublest, put_field)
(ldfrexp, floatformat_from_doublest, floatformat_is_negative)
(floatformat_is_nan, floatformat_mantissa)
(FLOATFORMAT_CHAR_BIT): Move from here.
* doublest.c: To here.  New file.
* findvar.c (store_floating, extract_floating): Move from here.
* doublest.c: To here.
* Makefile.in (SFILES): Add doublest.c.
(COMMON_OBS): Add doublest.o.
(doublest.o): Specify dependencies.
(doublest_h): Define.

* config/m88k/tm-m88k.h: Include "doublest.h".
* config/i960/tm-i960.h: Ditto.
* config/i386/tm-symmetry.h: Ditto.
* rs6000-tdep.c, valarith.c: Ditto.
* valprint.c, stabsread.c, sh-tdep.c: Ditto.
* ia64-tdep.c, i387-tdep.c, i386-tdep.c: Ditto.
* values.c, arm-tdep.c, arm-linux-tdep.c: Ditto.
* alpha-tdep.c, ax.h, expression.h: Ditto.
* sh-tdep.c, parse.c, top.c, value.h: Ditto.

* Makefile.in (arm-tdep.o): Add $(doublest_h).
(i386-tdep.o, i387-tdep.o, ia64-tdep.o): Ditto.
(rs6000-tdep.o, stabsread.o, valarith.o): Ditto.
(values.o, valprint.o, arm-linux-tdep.o): Ditto.
(alpha-tdep.o, ax_h, parse.o, top.o, value_h): Ditto.
(parser_defs_h): Ditto.
(expression_h): Add $(doublest_h) and $(symtab_h).
@
text
@d648 1
a648 1
      return extract_floating (valaddr, len);
d692 1
a692 1
      return extract_floating (valaddr, len);
d1300 1
a1300 1
      store_floating (VALUE_CONTENTS_RAW (val), len, num);
@


1.21
log
@Clean up the D10V port so that GDB and the target program no
longer disagree on how big pointers are.
* findvar.c (value_from_register): Remove special case code for D10V.
* printcmd.c (print_frame_args): Same.
* valops.c (value_at, value_fetch_lazy): Same.
* values.c (unpack_long): Same.
* gdbarch.sh: Changes to effect the following:
* gdbarch.h (GDB_TARGET_IS_D10V, D10V_MAKE_DADDR,
gdbarch_d10v_make_daddr_ftype, gdbarch_d10v_make_daddr,
set_gdbarch_d10v_make_daddr, D10V_MAKE_IADDR,
gdbarch_d10v_make_iaddr_ftype, gdbarch_d10v_make_iaddr,
set_gdbarch_d10v_make_iaddr, D10V_DADDR_P,
gdbarch_d10v_daddr_p_ftype, gdbarch_d10v_daddr_p,
set_gdbarch_d10v_daddr_p, D10V_IADDR_P,
gdbarch_d10v_iaddr_p_ftype, gdbarch_d10v_iaddr_p,
set_gdbarch_d10v_iaddr_p, D10V_CONVERT_DADDR_TO_RAW,
gdbarch_d10v_convert_daddr_to_raw_ftype,
gdbarch_d10v_convert_daddr_to_raw,
set_gdbarch_d10v_convert_daddr_to_raw, D10V_CONVERT_IADDR_TO_RAW,
gdbarch_d10v_convert_iaddr_to_raw_ftype,
gdbarch_d10v_convert_iaddr_to_raw,
set_gdbarch_d10v_convert_iaddr_to_raw): Delete declarations.
* gdbarch.c: Delete the corresponding definitions.
(struct gdbarch): Delete members d10v_make_daddr,
d10v_make_iaddr, d10v_daddr_p, d10v_iaddr_p,
d10v_convert_daddr_to_raw, and d10v_convert_iaddr_to_raw.
(startup_gdbarch): Remove initializers for the above.
(verify_gdbarch, gdbarch_dump): Don't verify or dump them any
more.
* d10v-tdep.c (d10v_register_virtual_type): Rather that
claiming the stack pointer and PC are 32 bits long (which they
aren't), say that the stack pointer is an int16_t, and the
program counter is a function pointer.  This allows the rest
of GDB to make the appropriate conversions between the code
pointer format and real addresses.
(d10v_register_convertible, d10v_register_convert_to_virtual,
d10v_register_convert_to_raw): Delete function; no registers
are convertible now, so we use
generic_register_convertible_not instead.
(d10v_address_to_pointer, d10v_pointer_to_address): New gdbarch
methods.
(d10v_push_arguments, d10v_extract_return_value): Remove special
cases for code and data pointers.
(d10v_gdbarch_init): Set gdbarch_ptr_bit to 16, so that GDB and
the target agree on how large pointers are.  Say that addresses
are 32 bits long.  Register the address_to_pointer and
pointer_to_address conversion functions.  Since no registers are
convertible now, register generic_register_convertible_not as the
gdbarch_register_convertible method instead of
d10v_register_convertible.  Remove registrations for
d10v_register_convert_to_virtual,
d10v_register_convert_to_raw, gdbarch_d10v_make_daddr,
gdbarch_d10v_make_iaddr, gdbarch_d10v_daddr_p,
gdbarch_d10v_iaddr_p, gdbarch_d10v_convert_daddr_to_raw, and
gdbarch_d10v_convert_iaddr_to_raw.
@
text
@d35 1
@


1.20
log
@* gdbtypes.h (builtin_type_void_data_ptr): Rename
builtin_type_ptr.
* gdbtypes.c (builtin_type_void_data_ptr): Update.
(build_gdbtypes): Update.
(_initialize_gdbtypes): Update.
* values.c (value_as_pointer): Update.
* utils.c (host_pointer_to_address): Update.
(address_to_host_pointer): Update.
@
text
@a652 3
      if (GDB_TARGET_IS_D10V
	  && len == 2)
	return D10V_MAKE_DADDR (extract_address (valaddr, len));
@


1.19
log
@* gdbarch.sh (EXTRACT_STRUCT_VALUE_ADDRESS_P): Delete definition.
(EXTRACT_STRUCT_VALUE_ADDRESS): Change to a function with
predicate.
* gdbarch.h, gdbarch.c: Regenerate.
* values.c (value_being_returned): Change the reference to
EXTRACT_STRUCT_VALUE_ADDRESS_P to a function call.
@
text
@d598 2
a599 1
      && TYPE_LENGTH (VALUE_TYPE (val)) <= TYPE_LENGTH (builtin_type_ptr))
d601 1
a601 1
      val = value_cast (builtin_type_ptr, val);
@


1.19.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d111 1
a111 1
  /* TYPEFIX-type-allocation: need a way to free this type when we are
d113 2
a114 2
  struct range_type *range_type
  = make_range_type (NULL, builtin_type_int,
d116 1
a116 1
  /* TYPEFIX-type-allocation: need a way to free this type when we are
d118 1
a118 1
  return allocate_value ((struct type *)make_array_type (NULL, 
d760 3
a762 3
	  /* Anything static that isn't a constant, has an address */
	  if (SYMBOL_CLASS (sym) != LOC_CONST)
	    {
a764 5
	    }	 
	  /* However, static const's do not, the value is already known.  */
	  else
	    {
	      return value_from_longest (TYPE_FIELD_TYPE (type, fieldno), SYMBOL_VALUE (sym));
d766 6
a771 1
	}
d782 1
a782 1
   
d793 23
a815 23
       value_ptr new_val;
       register value_ptr prev;

       new_val = (value_ptr) xrealloc (val, sizeof (struct value) + TYPE_LENGTH (new_encl_type));
       
       /* We have to make sure this ends up in the same place in the value
          chain as the original copy, so it's clean-up behavior is the same. 
          If the value has been released, this is a waste of time, but there
          is no way to tell that in advance, so... */

       if (val != all_values) 
         {
           for (prev = all_values; prev != NULL; prev = prev->next)
             {
               if (prev->next == val) 
                 {
                   prev->next = new_val;
                   break;
                 }
             }
          }
          
       return new_val;
d818 1
d981 1
a981 1
  VALUE_OFFSET (vtbl) += 4;
d1025 94
d1277 2
a1278 2
  struct range_type *rangetype =
  make_range_type (NULL, 
d1281 2
a1282 2
  struct type *stringtype = (struct type *)
  make_array_type ( NULL, 
@


1.18
log
@* gnu-regex.c: Eliminate obsolete check for _MSC_VER.
* utils.c (notice_quit): Remove dummy function only used for _MSC_VER.
* values.c (unpack_double): Remove obsolete check for _MSC_VER.
* defs.h: Ditto.
* m32r-rom.c: Ditto.
* p-exp.y: Ditto.
* ser-e7kpc.c: Ditto.  Define WIN32_LEAN_AND_MEAN under _WIN32, for faster
compilation.
(get_ds_base): Remove _MSC_VER version of this function.
* nindy-share/ttyflush.c: Ditto.  X
* rdi-share/host.h: Ditto.  X
* ser-go32.c (dos_readchar): Remove call to obsolete function.
* remote-sim.c (gdb_os_poll_quit): Ditto.
* remote-e7000.c (expect): Remove obsolete #if 0'ed code.
* main.c (captured_main): Eliminate special Cygwin checks.
* ser-tcp.c: Remove unneeded __CYGWIN__ guard against system include.
@
text
@d1331 1
a1331 1
  if (EXTRACT_STRUCT_VALUE_ADDRESS_P)
@


1.17
log
@* values.c (value_primitive_field): If we're extracting a base
class, then the type of the result should be the base class being
extracted, not the type of which it is a base class.
@
text
@a697 1
#if !defined (_MSC_VER) || (_MSC_VER > 900)
a698 4
#else
      /* FIXME!!! msvc22 doesn't support unsigned __int64 -> double */
      return (LONGEST) unpack_long (type, valaddr);
#endif /* _MSC_VER */
@


1.16
log
@2001-05-07  Daniel Berlin  <dan@@cgsoftware.com>

	Changes by Jim Ingham:

	* values.c (value_change_enclosing_type): New function.  If the
	new enclosing type is larger than the old one, we need to allocate
	more space.
	* value.h: Add value_change_enclosing_type prototype.
	* valops.c (value_cast): Use it.
	(value_assign): Use it.
	(value_addr): Use it.
	(value_ind): Use it.
	(value_full_object): Use it.

2001-05-07  Daniel Berlin  <dan@@cgsoftware.com>

	* values.c (value_static_field): Handle static fields that have a constant value.
@
text
@d859 1
a859 1
      VALUE_TYPE (v) = arg_type;
@


1.15
log
@(Changes from Daniel Berlin, with revisions by Jim Blandy.)

Abstract out operations specific to particular C++ ABI's, and
invoke them through a function table.  This removes the C++ ABI
dependencies scattered throughout the code, and allows us to
cleanly add support for new C++ ABI's.
* cp-abi.h, cp-abi.h, gnu-v2-abi.c, hpacc-abi.c: New files.
* c-typeprint.c, c-valprint.c, dbxread.c, eval.c, gdbtypes.c,
jv-typeprint.c, linespec.c, symtab.c, typeprint.c, valops.c:
#include "cp-abi.h".  These files all use functions now declared
there.
* symtab.h (OPNAME_PREFIX_P, VTBL_PREFIX_P, DESTRUCTOR_PREFIX_P):
Deleted.  These services are now provided by functions declared in
cp-abi.h.
* value.h (value_rtti_type, value_virtual_fn_field): Same.
* values.c (value_virtual_fn_field): Same, for this definition.
* valops.c (value_rtti_type): Same.
* c-typeprint.c (c_type_print_base): Use the functions from
"cp-abi.h", instead of the old macros, or hard-coded ABI-specific
tests.
* dbxread.c (record_minimal_symbol): Same.
* gdbtypes.c (get_destructor_fn_field, virtual_base_index,
virtual_base_index_skip_primaries): Same.
* jv-typeprint.c (java_type_print_base): Same.
* linespec.c (find_methods, decode_line_1): Same.
* symtab.c (gdb_mangle_name): Same.
* Makefile.in (SFILES): Add the new .c files mentioned above.
(cp_abi_h): New variable.
(COMMON_OBS): Add gnu-v2-abi.o, hpacc-abi.o, and cp-abi.o.
(cp-abi.o, gnu-v2-abi.o, hpacc-abi.o): New targets.
(c-typeprint.o, c-valprint.o, dbxread.o, eval.o, gdbtypes.o,
jv-typeprint.o, symtab.o, linespec.o, typeprint.o, valops.o): Add
dependency on $(cp_abi_h).
@
text
@d765 12
a776 3
	  addr = SYMBOL_VALUE_ADDRESS (sym);
	  sect = SYMBOL_BFD_SECTION (sym);
	}
d780 42
@


1.14
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@a47 1
static int vb_match (struct type *, int, struct type *);
a889 191
}

/* Return a virtual function as a value.
   ARG1 is the object which provides the virtual function
   table pointer.  *ARG1P is side-effected in calling this function.
   F is the list of member functions which contains the desired virtual
   function.
   J is an index into F which provides the desired virtual function.

   TYPE is the type in which F is located.  */
value_ptr
value_virtual_fn_field (value_ptr *arg1p, struct fn_field *f, int j,
			struct type *type, int offset)
{
  value_ptr arg1 = *arg1p;
  struct type *type1 = check_typedef (VALUE_TYPE (arg1));

  if (TYPE_HAS_VTABLE (type))
    {
      /* Deal with HP/Taligent runtime model for virtual functions */
      value_ptr vp;
      value_ptr argp;		/* arg1 cast to base */
      CORE_ADDR coreptr;	/* pointer to target address */
      int class_index;		/* which class segment pointer to use */
      struct type *ftype = TYPE_FN_FIELD_TYPE (f, j);	/* method type */

      argp = value_cast (type, *arg1p);

      if (VALUE_ADDRESS (argp) == 0)
	error ("Address of object is null; object may not have been created.");

      /* pai: FIXME -- 32x64 possible problem? */
      /* First word (4 bytes) in object layout is the vtable pointer */
      coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (argp));		/* pai: (temp)  */
      /* + offset + VALUE_EMBEDDED_OFFSET (argp)); */

      if (!coreptr)
	error ("Virtual table pointer is null for object; object may not have been created.");

      /* pai/1997-05-09
       * FIXME: The code here currently handles only
       * the non-RRBC case of the Taligent/HP runtime spec; when RRBC
       * is introduced, the condition for the "if" below will have to
       * be changed to be a test for the RRBC case.  */

      if (1)
	{
	  /* Non-RRBC case; the virtual function pointers are stored at fixed
	   * offsets in the virtual table. */

	  /* Retrieve the offset in the virtual table from the debug
	   * info.  The offset of the vfunc's entry is in words from
	   * the beginning of the vtable; but first we have to adjust
	   * by HP_ACC_VFUNC_START to account for other entries */

	  /* pai: FIXME: 32x64 problem here, a word may be 8 bytes in
	   * which case the multiplier should be 8 and values should be long */
	  vp = value_at (builtin_type_int,
			 coreptr + 4 * (TYPE_FN_FIELD_VOFFSET (f, j) + HP_ACC_VFUNC_START), NULL);

	  coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (vp));
	  /* coreptr now contains the address of the virtual function */
	  /* (Actually, it contains the pointer to the plabel for the function. */
	}
      else
	{
	  /* RRBC case; the virtual function pointers are found by double
	   * indirection through the class segment tables. */

	  /* Choose class segment depending on type we were passed */
	  class_index = class_index_in_primary_list (type);

	  /* Find class segment pointer.  These are in the vtable slots after
	   * some other entries, so adjust by HP_ACC_VFUNC_START for that. */
	  /* pai: FIXME 32x64 problem here, if words are 8 bytes long
	   * the multiplier below has to be 8 and value should be long. */
	  vp = value_at (builtin_type_int,
		    coreptr + 4 * (HP_ACC_VFUNC_START + class_index), NULL);
	  /* Indirect once more, offset by function index */
	  /* pai: FIXME 32x64 problem here, again multiplier could be 8 and value long */
	  coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (vp) + 4 * TYPE_FN_FIELD_VOFFSET (f, j));
	  vp = value_at (builtin_type_int, coreptr, NULL);
	  coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (vp));

	  /* coreptr now contains the address of the virtual function */
	  /* (Actually, it contains the pointer to the plabel for the function.) */

	}

      if (!coreptr)
	error ("Address of virtual function is null; error in virtual table?");

      /* Wrap this addr in a value and return pointer */
      vp = allocate_value (ftype);
      VALUE_TYPE (vp) = ftype;
      VALUE_ADDRESS (vp) = coreptr;

      /* pai: (temp) do we need the value_ind stuff in value_fn_field? */
      return vp;
    }
  else
    {				/* Not using HP/Taligent runtime conventions; so try to
				 * use g++ conventions for virtual table */

      struct type *entry_type;
      /* First, get the virtual function table pointer.  That comes
         with a strange type, so cast it to type `pointer to long' (which
         should serve just fine as a function type).  Then, index into
         the table, and convert final value to appropriate function type.  */
      value_ptr entry, vfn, vtbl;
      value_ptr vi = value_from_longest (builtin_type_int,
				    (LONGEST) TYPE_FN_FIELD_VOFFSET (f, j));
      struct type *fcontext = TYPE_FN_FIELD_FCONTEXT (f, j);
      struct type *context;
      if (fcontext == NULL)
	/* We don't have an fcontext (e.g. the program was compiled with
	   g++ version 1).  Try to get the vtbl from the TYPE_VPTR_BASETYPE.
	   This won't work right for multiple inheritance, but at least we
	   should do as well as GDB 3.x did.  */
	fcontext = TYPE_VPTR_BASETYPE (type);
      context = lookup_pointer_type (fcontext);
      /* Now context is a pointer to the basetype containing the vtbl.  */
      if (TYPE_TARGET_TYPE (context) != type1)
	{
	  value_ptr tmp = value_cast (context, value_addr (arg1));
	  VALUE_POINTED_TO_OFFSET (tmp) = 0;
	  arg1 = value_ind (tmp);
	  type1 = check_typedef (VALUE_TYPE (arg1));
	}

      context = type1;
      /* Now context is the basetype containing the vtbl.  */

      /* This type may have been defined before its virtual function table
         was.  If so, fill in the virtual function table entry for the
         type now.  */
      if (TYPE_VPTR_FIELDNO (context) < 0)
	fill_in_vptr_fieldno (context);

      /* The virtual function table is now an array of structures
         which have the form { int16 offset, delta; void *pfn; }.  */
      vtbl = value_primitive_field (arg1, 0, TYPE_VPTR_FIELDNO (context),
				    TYPE_VPTR_BASETYPE (context));

      /* With older versions of g++, the vtbl field pointed to an array
         of structures.  Nowadays it points directly to the structure. */
      if (TYPE_CODE (VALUE_TYPE (vtbl)) == TYPE_CODE_PTR
      && TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (vtbl))) == TYPE_CODE_ARRAY)
	{
	  /* Handle the case where the vtbl field points to an
	     array of structures. */
	  vtbl = value_ind (vtbl);

	  /* Index into the virtual function table.  This is hard-coded because
	     looking up a field is not cheap, and it may be important to save
	     time, e.g. if the user has set a conditional breakpoint calling
	     a virtual function.  */
	  entry = value_subscript (vtbl, vi);
	}
      else
	{
	  /* Handle the case where the vtbl field points directly to a structure. */
	  vtbl = value_add (vtbl, vi);
	  entry = value_ind (vtbl);
	}

      entry_type = check_typedef (VALUE_TYPE (entry));

      if (TYPE_CODE (entry_type) == TYPE_CODE_STRUCT)
	{
	  /* Move the `this' pointer according to the virtual function table. */
	  VALUE_OFFSET (arg1) += value_as_long (value_field (entry, 0));

	  if (!VALUE_LAZY (arg1))
	    {
	      VALUE_LAZY (arg1) = 1;
	      value_fetch_lazy (arg1);
	    }

	  vfn = value_field (entry, 2);
	}
      else if (TYPE_CODE (entry_type) == TYPE_CODE_PTR)
	vfn = entry;
      else
	error ("I'm confused:  virtual function table has bad type");
      /* Reinstantiate the function pointer with the correct type.  */
      VALUE_TYPE (vfn) = lookup_pointer_type (TYPE_FN_FIELD_TYPE (f, j));

      *arg1p = arg1;
      return vfn;
    }
@


1.13
log
@Update/correct copyright notices.
@
text
@a28 1
#include "frame.h"
@


1.12
log
@Replace free() with xfree().
@
text
@d2 2
a3 1
   Copyright 1986, 87, 89, 91, 93, 94, 95, 96, 97, 1998
@


1.11
log
@Protoization.
@
text
@d334 1
a334 1
	  free ((PTR) val);
d336 1
a336 1
      free ((PTR) value_history_chain);
d478 1
a478 1
  free ((PTR) var->value);
d502 3
a504 3
      free ((PTR) var->name);
      free ((PTR) var->value);
      free ((PTR) var);
@


1.10
log
@	* eval.c (parse_and_eval_long): New function.
	* value.h: Declare it.

	* breakpoint.c (breakpoints_info, maintenance_info_breakpoints):
	Call parse_and_eval_long, not parse_and_eval_address.
	* command.c (do_setshow_command): Ditto.
	* infcmd.c (step_1, signal_command, continue_command): Ditto.
	* infrun.c (signals_info): Ditto.
	* stack.c (set_backtrace_limit_command, backtrace_command_1,
	up_silently_base, down_silently_base): Ditto.
	* tracepoints.c (tracepoints_info, trace_find_command,
 	trace_find_tracepoint_command): Ditto.
	* valprint.c (set_radix): Ditto.
	* values.c (show_values): Ditto.
@
text
@d1469 1
d1471 1
a1471 5
value_being_returned (valtype, retbuf, struct_return)
     register struct type *valtype;
     char *retbuf;
     int struct_return;
     /*ARGSUSED */
d1530 1
d1532 2
a1533 6
using_struct_return (function, funcaddr, value_type, gcc_p)
     value_ptr function;
     CORE_ADDR funcaddr;
     struct type *value_type;
     int gcc_p;
     /*ARGSUSED */
@


1.9
log
@Protoization.
@
text
@d354 1
a354 1
	num = parse_and_eval_address (num_exp) - 5;
@


1.8
log
@Cast integers into pointers before converting them into canonical
addresses.
@
text
@d79 1
a79 2
allocate_value (type)
     struct type *type;
d109 1
a109 3
allocate_repeat_value (type, count)
     struct type *type;
     int count;
d127 1
a127 1
value_mark ()
d135 1
a135 2
value_free_to_mark (mark)
     value_ptr mark;
d151 1
a151 1
free_all_values ()
d168 1
a168 2
release_value (val)
     register value_ptr val;
d190 1
a190 2
value_release_to_mark (mark)
     value_ptr mark;
d210 1
a210 2
value_copy (arg)
     value_ptr arg;
d245 1
a245 2
record_latest_value (val)
     value_ptr val;
d286 1
a286 2
access_value_history (num)
     int num;
d324 1
a324 1
clear_value_history ()
d343 1
a343 3
show_values (num_exp, from_tty)
     char *num_exp;
     int from_tty;
d400 1
a400 2
lookup_internalvar (name)
     char *name;
d418 1
a418 2
value_of_internalvar (var)
     struct internalvar *var;
d436 2
a437 4
set_internalvar_component (var, offset, bitpos, bitsize, newval)
     struct internalvar *var;
     int offset, bitpos, bitsize;
     value_ptr newval;
d454 1
a454 3
set_internalvar (var, val)
     struct internalvar *var;
     value_ptr val;
d485 1
a485 2
internalvar_name (var)
     struct internalvar *var;
d494 1
a494 1
clear_internalvars ()
d509 1
a509 3
show_convenience (ignore, from_tty)
     char *ignore;
     int from_tty;
d540 1
a540 2
value_as_long (val)
     register value_ptr val;
d550 1
a550 2
value_as_double (val)
     register value_ptr val;
d564 1
a564 2
value_as_pointer (val)
     value_ptr val;
d622 1
a622 3
unpack_long (type, valaddr)
     struct type *type;
     char *valaddr;
d674 1
a674 4
unpack_double (type, valaddr, invp)
     struct type *type;
     char *valaddr;
     int *invp;
d727 1
a727 3
unpack_pointer (type, valaddr)
     struct type *type;
     char *valaddr;
d738 1
a738 3
value_static_field (type, fieldno)
     struct type *type;
     int fieldno;
d780 2
a781 5
value_primitive_field (arg1, offset, fieldno, arg_type)
     register value_ptr arg1;
     int offset;
     register int fieldno;
     register struct type *arg_type;
d849 1
a849 3
value_field (arg1, fieldno)
     register value_ptr arg1;
     register int fieldno;
d859 2
a860 6
value_fn_field (arg1p, f, j, type, offset)
     value_ptr *arg1p;
     struct fn_field *f;
     int j;
     struct type *type;
     int offset;
d902 2
a903 6
value_virtual_fn_field (arg1p, f, j, type, offset)
     value_ptr *arg1p;
     struct fn_field *f;
     int j;
     struct type *type;
     int offset;
d1099 1
a1099 3
value_headof (in_arg, btype, dtype)
     value_ptr in_arg;
     struct type *btype, *dtype;
d1160 1
a1160 3
value_from_vtable_info (arg, type)
     value_ptr arg;
     struct type *type;
d1175 1
a1175 4
vb_match (type, index, basetype)
     struct type *type;
     int index;
     struct type *basetype;
d1226 2
a1227 5
baseclass_offset (type, index, valaddr, address)
     struct type *type;
     int index;
     char *valaddr;
     CORE_ADDR address;
d1281 1
a1281 4
unpack_field_as_long (type, valaddr, fieldno)
     struct type *type;
     char *valaddr;
     int fieldno;
d1326 1
a1326 4
modify_field (addr, fieldval, bitpos, bitsize)
     char *addr;
     LONGEST fieldval;
     int bitpos, bitsize;
d1367 1
a1367 3
value_from_longest (type, num)
     struct type *type;
     register LONGEST num;
d1418 1
a1418 2
value_from_string (ptr)
     char *ptr;
d1438 1
a1438 3
value_from_double (type, num)
     struct type *type;
     DOUBLEST num;
d1512 1
a1512 3
generic_use_struct_convention (gcc_p, value_type)
     int gcc_p;
     struct type *value_type;
d1560 1
a1560 2
set_return_value (val)
     value_ptr val;
d1576 1
a1576 1
_initialize_values ()
@


1.7
log
@2000-06-08  Fernando Nasser  <fnasser@@cygnus.com>

        * values.c (value_primitive_field): Copy VALUE_REGNO as well.
        With typed registers we may have the location information in this field,
        in addition to VALUE_ADDRESS (which was already being copied).
@
text
@d597 30
a626 1
  return value_as_long (val);
@


1.6
log
@PARAMS removal.
@
text
@d844 1
@


1.5
log
@Bring RETURN_VALUE_ON_STACK under gdbarch's control.
* gdbarch.sh (RETURN_VALUE_ON_STACK): New entry.
* gdbarch.c, gdbarch.h: Regenerated.
* arch-utils.c (default_return_value_on_stack): New function.
* arch-utils.h (default_return_value_on_stack): New declaration.
* values.c (RETURN_VALUE_ON_STACK): Delete default definition.
@
text
@d38 1
a38 1
void _initialize_values PARAMS ((void));
d42 1
a42 2
static value_ptr value_headof PARAMS ((value_ptr, struct type *,
				       struct type *));
d44 1
a44 1
static void show_values PARAMS ((char *, int));
d46 1
a46 1
static void show_convenience PARAMS ((char *, int));
d48 1
a48 1
static int vb_match PARAMS ((struct type *, int, struct type *));
@


1.4
log
@* gdbarch.sh (POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Two new
functions which architectures can redefine, defaulting to
generic_pointer_to_address and generic_address_to_pointer.
* findvar.c (extract_typed_address, store_typed_address,
generic_pointer_to_address, generic_address_to_pointer): New
functions.
(POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Provide default
definitions.
(extract_address, store_address): Doc fixes.
* values.c (value_as_pointer): Doc fix.
(value_from_pointer): New function.
* defs.h (extract_typed_address, store_typed_address): New
declarations.
* inferior.h (generic_address_to_pointer,
generic_pointer_to_address): New declarations.
* value.h (value_from_pointer): New declaration.

* ax-gdb.c (const_var_ref): Use value_from_pointer, not
value_from_longest.
* blockframe.c (generic_push_dummy_frame): Use read_pc and
read_sp, not read_register.
* c-valprint.c (c_val_print): Use extract_typed_address instead of
extract_address to extract vtable entries and references.
* cp-valprint.c (cp_print_value_fields): Use value_from_pointer
instead of value_from_longest to extract the vtable's address.
* eval.c (evaluate_subexp_standard): Use value_from_pointer
instead of value_from_longest to compute `this', and for doing
pointer-to-member dereferencing.
* findvar.c (read_register): Use extract_unsigned_integer, not
extract_address.
(read_var_value): Use store_typed_address instead of store_address
for building label values.
(locate_var_value): Use value_from_pointer instead of
value_from_longest.
* hppa-tdep.c (find_stub_with_shl_get): Use value_from_pointer,
instead of value_from_longest, to build arguments to __d_shl_get.
* printcmd.c (set_next_address): Use value_from_pointer, not
value_from_longest.
(x_command): Use value_from_pointer, not value_from_longest.
* tracepoint.c (set_traceframe_context): Use value_from_pointer,
not value_from_longest.
* valarith.c (value_add, value_sub): Use value_from_pointer, not
value_from_longest.
* valops.c (find_function_in_inferior, value_coerce_array,
value_coerce_function, value_addr, hand_function_call): Same.
* value.h (COERCE_REF): Use unpack_pointer, not unpack_long.
* values.c (unpack_long): Use extract_typed_address to produce
addresses from pointers and references, not extract_address.
(value_from_longest): Use store_typed_address instead of
store_address to produce pointer and reference values.
@
text
@a1563 7
/* Some fundamental types (such as long double) are returned on the stack for
   certain architectures.  This macro should return true for any type besides
   struct, union or array that gets returned on the stack.  */

#ifndef RETURN_VALUE_ON_STACK
#define RETURN_VALUE_ON_STACK(TYPE) 0
#endif
@


1.3
log
@C++ changes for 5.0, finally committed.
@
text
@d583 3
a585 2
/* Extract a value as a C pointer.
   Does not deallocate the value.  */
d653 1
a653 1
      return extract_address (valaddr, len);
d735 1
d1425 1
a1425 3
      /* This assumes that all pointers of a given length
         have the same form.  */
      store_address (VALUE_CONTENTS_RAW (val), len, (CORE_ADDR) num);
d1433 12
@


1.2
log
@2000-03-20  Eli Zaretskii  <eliz@@is.elta.co.il>

        * breakpoint.c (insert_breakpoints, remove_breakpoint)
        (bpstat_stop_status, can_use_hardware_watchpoint): Don't insert,
        remove, or check status of hardware watchpoints for entire structs
        and arrays unless the user explicitly asked to watch that struct
        or array.
        (insert_breakpoints): Try to insert watchpoints for all the values
        on the value chain, even if some of them fail to insert.

        * values.c (value_primitive_field): Set the offset in struct value
        we return when the field is a packed bitfield.
@
text
@d895 1
a895 1
      /* Move the `this' pointer according to the offset. 
d1105 6
a1110 1
   FIXME-tiemann: should work with dossier entries as well.  */
d1118 1
a1118 4
  /* FIXME-tiemann: right now, just look at top-most vtable.  */
  value_ptr arg, vtbl, entry, best_entry = 0;
  int i, nelems;
  int offset, best_offset = 0;
a1119 1
  CORE_ADDR pc_for_sym;
d1127 14
a1140 1
    arg = value_cast (lookup_pointer_type (btype), arg);
d1142 2
d1145 1
a1145 2
  /* Check that VTBL looks like it points to a virtual function table.  */
  msymbol = lookup_minimal_symbol_by_pc (VALUE_ADDRESS (vtbl));
d1147 13
a1159 12
      || (demangled_name = SYMBOL_NAME (msymbol)) == NULL
      || !VTBL_PREFIX_P (demangled_name))
    {
      /* If we expected to find a vtable, but did not, let the user
         know that we aren't happy, but don't throw an error.
         FIXME: there has to be a better way to do this.  */
      struct type *error_type = (struct type *) xmalloc (sizeof (struct type));
      memcpy (error_type, VALUE_TYPE (in_arg), sizeof (struct type));
      TYPE_NAME (error_type) = savestring ("suspicious *", sizeof ("suspicious *"));
      VALUE_TYPE (in_arg) = error_type;
      return in_arg;
    }
a1160 36
  /* Now search through the virtual function table.  */
  entry = value_ind (vtbl);
  nelems = longest_to_int (value_as_long (value_field (entry, 2)));
  for (i = 1; i <= nelems; i++)
    {
      entry = value_subscript (vtbl, value_from_longest (builtin_type_int,
							 (LONGEST) i));
      /* This won't work if we're using thunks. */
      if (TYPE_CODE (check_typedef (VALUE_TYPE (entry))) != TYPE_CODE_STRUCT)
	break;
      offset = longest_to_int (value_as_long (value_field (entry, 0)));
      /* If we use '<=' we can handle single inheritance
       * where all offsets are zero - just use the first entry found. */
      if (offset <= best_offset)
	{
	  best_offset = offset;
	  best_entry = entry;
	}
    }
  /* Move the pointer according to BEST_ENTRY's offset, and figure
     out what type we should return as the new pointer.  */
  if (best_entry == 0)
    {
      /* An alternative method (which should no longer be necessary).
       * But we leave it in for future use, when we will hopefully
       * have optimizes the vtable to use thunks instead of offsets. */
      /* Use the name of vtable itself to extract a base type. */
      demangled_name += 4;	/* Skip _vt$ prefix. */
    }
  else
    {
      pc_for_sym = value_as_pointer (value_field (best_entry, 2));
      sym = find_pc_function (pc_for_sym);
      demangled_name = cplus_demangle (SYMBOL_NAME (sym), DMGL_ANSI);
      *(strchr (demangled_name, ':')) = '\0';
    }
d1163 3
a1165 9
    error ("could not find type declaration for `%s'", demangled_name);
  if (best_entry)
    {
      free (demangled_name);
      arg = value_add (value_cast (builtin_type_int, arg),
		       value_field (best_entry, 0));
    }
  else
    arg = in_arg;
d1435 1
a1435 1
   (not in the inferior's memory space, but in GDB memory).  
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d60 4
a63 4
{
  struct value_history_chunk *next;
  value_ptr values[VALUE_HISTORY_CHUNK];
};
d115 1
a115 1
  int low_bound = current_language->string_lower_bound; /* ??? */
d119 2
a120 2
    = create_range_type ((struct type *) NULL, builtin_type_int,
			 low_bound, count + low_bound - 1);
d277 2
a278 2
	= (struct value_history_chunk *)
	  xmalloc (sizeof (struct value_history_chunk));
d344 1
a344 1
	  free ((PTR)val);
d346 1
a346 1
      free ((PTR)value_history_chain);
d363 2
a364 2
	/* "info history +" should print from the stored position.
	   "info history <exp>" should print around value number <exp>.  */
d439 1
a439 1
#endif 
d496 1
a496 1
  free ((PTR)var->value);
d521 3
a523 3
      free ((PTR)var->name);
      free ((PTR)var->value);
      free ((PTR)var);
d577 1
a577 1
  
d595 1
a595 1
  return ADDR_BITS_REMOVE(value_as_long (val));
d648 4
a651 5
	 whether we want this to be true eventually.  */
#ifdef GDB_TARGET_IS_D10V
      if (len == 2)
	  return D10V_MAKE_DADDR(extract_address (valaddr, len));
#endif
d660 1
a660 1
  return 0; /* Placate lint.  */
d756 2
a757 2
	     as non-debuggable symbols */ 
	  struct minimal_symbol * msym = lookup_minimal_symbol (phys_name, NULL, NULL);
d761 1
a761 1
	    {     
d801 1
a801 1
						      + offset,
d805 2
d822 3
a824 3
        = offset + 
          VALUE_EMBEDDED_OFFSET (arg1) + 
          TYPE_FIELD_BITPOS (arg_type, fieldno) / 8;
d844 1
a844 1
		     + TYPE_FIELD_BITPOS (arg_type, fieldno) / 8; */
d878 2
a879 2
  if (! sym) 
	return NULL;
d881 4
a884 4
	error ("Internal error: could not find physical method named %s",
		    TYPE_FN_FIELD_PHYSNAME (f, j));
*/
  
d890 8
a897 8
   {
    if (type != VALUE_TYPE (*arg1p))
      *arg1p = value_ind (value_cast (lookup_pointer_type (type),
				      value_addr (*arg1p)));

    /* Move the `this' pointer according to the offset. 
    VALUE_OFFSET (*arg1p) += offset;
    */
d926 4
a929 5
      value_ptr argp;        /* arg1 cast to base */
      CORE_ADDR vfunc_addr;  /* address of virtual method */
      CORE_ADDR coreptr;     /* pointer to target address */ 
      int class_index;       /* which class segment pointer to use */
      struct type * ftype = TYPE_FN_FIELD_TYPE (f, j);   /* method type */
d934 2
a935 2
        error ("Address of object is null; object may not have been created.");
      
d938 2
a939 2
      coreptr = * (CORE_ADDR *) (VALUE_CONTENTS (argp)); /* pai: (temp)  */
                                 /* + offset + VALUE_EMBEDDED_OFFSET (argp)); */ 
d942 2
a943 2
        error ("Virtual table pointer is null for object; object may not have been created.");
      
d949 1
a949 1
       
d951 18
a968 18
        {
          /* Non-RRBC case; the virtual function pointers are stored at fixed
           * offsets in the virtual table. */

          /* Retrieve the offset in the virtual table from the debug
           * info.  The offset of the vfunc's entry is in words from
           * the beginning of the vtable; but first we have to adjust
           * by HP_ACC_VFUNC_START to account for other entries */
          
          /* pai: FIXME: 32x64 problem here, a word may be 8 bytes in
           * which case the multiplier should be 8 and values should be long */
          vp = value_at (builtin_type_int,
                         coreptr + 4 * (TYPE_FN_FIELD_VOFFSET (f, j) + HP_ACC_VFUNC_START), NULL);
          
          coreptr = * (CORE_ADDR *) (VALUE_CONTENTS (vp));
          /* coreptr now contains the address of the virtual function */
          /* (Actually, it contains the pointer to the plabel for the function. */
        }
d970 23
a992 23
        {
          /* RRBC case; the virtual function pointers are found by double
           * indirection through the class segment tables. */
          
          /* Choose class segment depending on type we were passed */ 
          class_index = class_index_in_primary_list (type);
      
          /* Find class segment pointer.  These are in the vtable slots after
           * some other entries, so adjust by HP_ACC_VFUNC_START for that. */
          /* pai: FIXME 32x64 problem here, if words are 8 bytes long
           * the multiplier below has to be 8 and value should be long. */
          vp = value_at (builtin_type_int,
                         coreptr + 4 * (HP_ACC_VFUNC_START + class_index), NULL);
          /* Indirect once more, offset by function index */
          /* pai: FIXME 32x64 problem here, again multiplier could be 8 and value long */
          coreptr = * (CORE_ADDR *) (VALUE_CONTENTS (vp) + 4 * TYPE_FN_FIELD_VOFFSET (f, j));
          vp = value_at (builtin_type_int, coreptr, NULL);
          coreptr = * (CORE_ADDR *) (VALUE_CONTENTS (vp));
          
          /* coreptr now contains the address of the virtual function */
          /* (Actually, it contains the pointer to the plabel for the function.) */
          
        }
d995 1
a995 1
        error ("Address of virtual function is null; error in virtual table?");
d997 1
a997 1
      /* Wrap this addr in a value and return pointer */ 
d1001 1
a1001 1
      
d1005 4
a1008 4
  else  
    { /* Not using HP/Taligent runtime conventions; so try to
       * use g++ conventions for virtual table */
      
d1015 2
a1016 2
      value_ptr vi = value_from_longest (builtin_type_int, 
                                         (LONGEST) TYPE_FN_FIELD_VOFFSET (f, j));
d1020 5
a1024 5
       /* We don't have an fcontext (e.g. the program was compiled with
          g++ version 1).  Try to get the vtbl from the TYPE_VPTR_BASETYPE.
          This won't work right for multiple inheritance, but at least we
          should do as well as GDB 3.x did.  */
        fcontext = TYPE_VPTR_BASETYPE (type);
d1028 1
a1028 1
        {
d1031 3
a1033 3
          arg1 = value_ind (tmp);
          type1 = check_typedef (VALUE_TYPE (arg1));
        }
d1042 1
a1042 1
        fill_in_vptr_fieldno (context);
d1048 1
a1048 1
      
d1050 1
a1050 1
	 of structures.  Nowadays it points directly to the structure. */
d1052 1
a1052 1
	  && TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (vtbl))) == TYPE_CODE_ARRAY)
d1074 9
a1082 9
        {
          /* Move the `this' pointer according to the virtual function table. */
          VALUE_OFFSET (arg1) += value_as_long (value_field (entry, 0));

          if (! VALUE_LAZY (arg1))
            {
              VALUE_LAZY (arg1) = 1;
              value_fetch_lazy (arg1);
            }
d1084 2
a1085 2
          vfn = value_field (entry, 2);
        }
d1087 1
a1087 1
        vfn = entry;
d1089 1
a1089 1
        error ("I'm confused:  virtual function table has bad type");
d1136 3
a1138 3
	 know that we aren't happy, but don't throw an error.
	 FIXME: there has to be a better way to do this.  */
      struct type *error_type = (struct type *)xmalloc (sizeof (struct type));
d1150 2
a1151 2
      entry = value_subscript (vtbl, value_from_longest (builtin_type_int, 
						      (LONGEST) i));
d1172 1
a1172 1
      demangled_name += 4;  /* Skip _vt$ prefix. */
d1190 2
a1191 1
  else arg = in_arg;
d1288 1
a1288 1
	 in the fields.  */
d1294 2
a1295 2
		= unpack_pointer (TYPE_FIELD_TYPE (type, i),
				  valaddr + (TYPE_FIELD_BITPOS (type, i) / 8));
d1301 1
a1301 1
      for (i = index+1; i < n_baseclasses; i++)
d1304 1
a1304 1
	      baseclass_offset (type, i, valaddr, address);
d1394 1
a1394 1
      && 0 != (fieldval & ~((1<<bitsize)-1)))
d1397 1
a1397 1
	 we don't have a sprintf_longest.  */
d1412 1
a1412 1
    oword &= ~(((((ULONGEST)1) << bitsize) - 1) << bitpos);
d1414 1
a1414 1
    oword &= ~((~(ULONGEST)0) << bitpos);
d1430 1
a1430 1
 retry:
d1446 1
a1446 1
      
d1450 1
a1450 1
	 have the same form.  */
d1453 1
a1453 1
      
d1460 26
d1523 1
a1523 1
     char retbuf[REGISTER_BYTES];
d1525 1
a1525 1
     /*ARGSUSED*/
a1529 1
#if defined (EXTRACT_STRUCT_VALUE_ADDRESS)
d1531 8
a1538 7
  if (struct_return) {
    addr = EXTRACT_STRUCT_VALUE_ADDRESS (retbuf);
    if (!addr)
      error ("Function return value unknown");
    return value_at (valtype, addr, NULL);
  }
#endif
d1566 1
a1566 1
{     
d1568 4
a1571 4
	    && (TYPE_LENGTH (value_type) == 1
		|| TYPE_LENGTH (value_type) == 2
		|| TYPE_LENGTH (value_type) == 4
		|| TYPE_LENGTH (value_type) == 8));
d1599 1
a1599 1
     /*ARGSUSED*/
d1629 1
a1629 1
  if (   code == TYPE_CODE_STRUCT
d1640 1
a1640 1
	    "Debugger convenience (\"$foo\") variables.\n\
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d648 4
a651 3
      if (GDB_TARGET_IS_D10V
	  && len == 2)
	  return D10V_MAKE_DADDR (extract_address (valaddr, len));
d1495 1
a1495 1
     char *retbuf;
@


1.1.1.3
log
@import gdb-1999-06-01 snapshot
@
text
@d1501 1
d1503 7
a1509 8
  if (EXTRACT_STRUCT_VALUE_ADDRESS_P)
    if (struct_return)
      {
	addr = EXTRACT_STRUCT_VALUE_ADDRESS (retbuf);
	if (!addr)
	  error ("Function return value unknown");
	return value_at (valtype, addr, NULL);
      }
@


1.1.1.4
log
@import gdb-1999-06-14 snapshot
@
text
@a1456 26
/* Create a value for a string constant to be stored locally
   (not in the inferior's memory space, but in GDB memory).  
   This is analogous to value_from_longest, which also does not
   use inferior memory.  String shall NOT contain embedded nulls.  */

value_ptr
value_from_string (ptr)
     char *ptr;
{
  value_ptr val;
  int   len = strlen (ptr);
  int lowbound = current_language->string_lower_bound;
  struct type *rangetype = 
    create_range_type ((struct type *) NULL, 
		       builtin_type_int,
		       lowbound, len + lowbound - 1);
  struct type *stringtype = 
    create_array_type ((struct type *) NULL, 
		       *current_language->string_char_type, 
		       rangetype);

  val = allocate_value (stringtype);
  memcpy (VALUE_CONTENTS_RAW (val), ptr, len);
  return val;
}

@


1.1.1.5
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d59 4
a62 4
  {
    struct value_history_chunk *next;
    value_ptr values[VALUE_HISTORY_CHUNK];
  };
d114 1
a114 1
  int low_bound = current_language->string_lower_bound;		/* ??? */
d118 2
a119 2
  = create_range_type ((struct type *) NULL, builtin_type_int,
		       low_bound, count + low_bound - 1);
d276 2
a277 2
      = (struct value_history_chunk *)
      xmalloc (sizeof (struct value_history_chunk));
d343 1
a343 1
	  free ((PTR) val);
d345 1
a345 1
      free ((PTR) value_history_chain);
d362 2
a363 2
      /* "info history +" should print from the stored position.
         "info history <exp>" should print around value number <exp>.  */
d438 1
a438 1
#endif
d495 1
a495 1
  free ((PTR) var->value);
d520 3
a522 3
      free ((PTR) var->name);
      free ((PTR) var->value);
      free ((PTR) var);
d576 1
a576 1

d594 1
a594 1
  return ADDR_BITS_REMOVE (value_as_long (val));
d647 1
a647 1
         whether we want this to be true eventually.  */
d650 1
a650 1
	return D10V_MAKE_DADDR (extract_address (valaddr, len));
d659 1
a659 1
  return 0;			/* Placate lint.  */
d755 2
a756 2
	     as non-debuggable symbols */
	  struct minimal_symbol *msym = lookup_minimal_symbol (phys_name, NULL, NULL);
d760 1
a760 1
	    {
d800 1
a800 1
						    + offset,
d819 3
a821 3
	= offset +
	VALUE_EMBEDDED_OFFSET (arg1) +
	TYPE_FIELD_BITPOS (arg_type, fieldno) / 8;
d841 1
a841 1
   + TYPE_FIELD_BITPOS (arg_type, fieldno) / 8; */
d875 2
a876 2
  if (!sym)
    return NULL;
d878 4
a881 4
   error ("Internal error: could not find physical method named %s",
   TYPE_FN_FIELD_PHYSNAME (f, j));
 */

d887 8
a894 8
    {
      if (type != VALUE_TYPE (*arg1p))
	*arg1p = value_ind (value_cast (lookup_pointer_type (type),
					value_addr (*arg1p)));

      /* Move the `this' pointer according to the offset. 
         VALUE_OFFSET (*arg1p) += offset;
       */
d923 5
a927 5
      value_ptr argp;		/* arg1 cast to base */
      CORE_ADDR vfunc_addr;	/* address of virtual method */
      CORE_ADDR coreptr;	/* pointer to target address */
      int class_index;		/* which class segment pointer to use */
      struct type *ftype = TYPE_FN_FIELD_TYPE (f, j);	/* method type */
d932 2
a933 2
	error ("Address of object is null; object may not have been created.");

d936 2
a937 2
      coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (argp));		/* pai: (temp)  */
      /* + offset + VALUE_EMBEDDED_OFFSET (argp)); */
d940 2
a941 2
	error ("Virtual table pointer is null for object; object may not have been created.");

d947 1
a947 1

d949 18
a966 18
	{
	  /* Non-RRBC case; the virtual function pointers are stored at fixed
	   * offsets in the virtual table. */

	  /* Retrieve the offset in the virtual table from the debug
	   * info.  The offset of the vfunc's entry is in words from
	   * the beginning of the vtable; but first we have to adjust
	   * by HP_ACC_VFUNC_START to account for other entries */

	  /* pai: FIXME: 32x64 problem here, a word may be 8 bytes in
	   * which case the multiplier should be 8 and values should be long */
	  vp = value_at (builtin_type_int,
			 coreptr + 4 * (TYPE_FN_FIELD_VOFFSET (f, j) + HP_ACC_VFUNC_START), NULL);

	  coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (vp));
	  /* coreptr now contains the address of the virtual function */
	  /* (Actually, it contains the pointer to the plabel for the function. */
	}
d968 23
a990 23
	{
	  /* RRBC case; the virtual function pointers are found by double
	   * indirection through the class segment tables. */

	  /* Choose class segment depending on type we were passed */
	  class_index = class_index_in_primary_list (type);

	  /* Find class segment pointer.  These are in the vtable slots after
	   * some other entries, so adjust by HP_ACC_VFUNC_START for that. */
	  /* pai: FIXME 32x64 problem here, if words are 8 bytes long
	   * the multiplier below has to be 8 and value should be long. */
	  vp = value_at (builtin_type_int,
		    coreptr + 4 * (HP_ACC_VFUNC_START + class_index), NULL);
	  /* Indirect once more, offset by function index */
	  /* pai: FIXME 32x64 problem here, again multiplier could be 8 and value long */
	  coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (vp) + 4 * TYPE_FN_FIELD_VOFFSET (f, j));
	  vp = value_at (builtin_type_int, coreptr, NULL);
	  coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (vp));

	  /* coreptr now contains the address of the virtual function */
	  /* (Actually, it contains the pointer to the plabel for the function.) */

	}
d993 1
a993 1
	error ("Address of virtual function is null; error in virtual table?");
d995 1
a995 1
      /* Wrap this addr in a value and return pointer */
d999 1
a999 1

d1003 4
a1006 4
  else
    {				/* Not using HP/Taligent runtime conventions; so try to
				 * use g++ conventions for virtual table */

d1013 2
a1014 2
      value_ptr vi = value_from_longest (builtin_type_int,
				    (LONGEST) TYPE_FN_FIELD_VOFFSET (f, j));
d1018 5
a1022 5
	/* We don't have an fcontext (e.g. the program was compiled with
	   g++ version 1).  Try to get the vtbl from the TYPE_VPTR_BASETYPE.
	   This won't work right for multiple inheritance, but at least we
	   should do as well as GDB 3.x did.  */
	fcontext = TYPE_VPTR_BASETYPE (type);
d1026 1
a1026 1
	{
d1029 3
a1031 3
	  arg1 = value_ind (tmp);
	  type1 = check_typedef (VALUE_TYPE (arg1));
	}
d1040 1
a1040 1
	fill_in_vptr_fieldno (context);
d1046 1
a1046 1

d1048 1
a1048 1
         of structures.  Nowadays it points directly to the structure. */
d1050 1
a1050 1
      && TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (vtbl))) == TYPE_CODE_ARRAY)
d1072 9
a1080 3
	{
	  /* Move the `this' pointer according to the virtual function table. */
	  VALUE_OFFSET (arg1) += value_as_long (value_field (entry, 0));
d1082 2
a1083 8
	  if (!VALUE_LAZY (arg1))
	    {
	      VALUE_LAZY (arg1) = 1;
	      value_fetch_lazy (arg1);
	    }

	  vfn = value_field (entry, 2);
	}
d1085 1
a1085 1
	vfn = entry;
d1087 1
a1087 1
	error ("I'm confused:  virtual function table has bad type");
d1134 3
a1136 3
         know that we aren't happy, but don't throw an error.
         FIXME: there has to be a better way to do this.  */
      struct type *error_type = (struct type *) xmalloc (sizeof (struct type));
d1148 2
a1149 2
      entry = value_subscript (vtbl, value_from_longest (builtin_type_int,
							 (LONGEST) i));
d1170 1
a1170 1
      demangled_name += 4;	/* Skip _vt$ prefix. */
d1188 1
a1188 2
  else
    arg = in_arg;
d1285 1
a1285 1
         in the fields.  */
d1291 2
a1292 2
	      = unpack_pointer (TYPE_FIELD_TYPE (type, i),
				valaddr + (TYPE_FIELD_BITPOS (type, i) / 8));
d1298 1
a1298 1
      for (i = index + 1; i < n_baseclasses; i++)
d1301 1
a1301 1
	  baseclass_offset (type, i, valaddr, address);
d1391 1
a1391 1
      && 0 != (fieldval & ~((1 << bitsize) - 1)))
d1394 1
a1394 1
         we don't have a sprintf_longest.  */
d1409 1
a1409 1
    oword &= ~(((((ULONGEST) 1) << bitsize) - 1) << bitpos);
d1411 1
a1411 1
    oword &= ~((~(ULONGEST) 0) << bitpos);
d1427 1
a1427 1
retry:
d1443 1
a1443 1

d1447 1
a1447 1
         have the same form.  */
d1450 1
a1450 1

d1467 1
a1467 1
  int len = strlen (ptr);
d1469 8
a1476 8
  struct type *rangetype =
  create_range_type ((struct type *) NULL,
		     builtin_type_int,
		     lowbound, len + lowbound - 1);
  struct type *stringtype =
  create_array_type ((struct type *) NULL,
		     *current_language->string_char_type,
		     rangetype);
d1522 1
a1522 1
     /*ARGSUSED */
d1563 1
a1563 1
{
d1565 4
a1568 4
	   && (TYPE_LENGTH (value_type) == 1
	       || TYPE_LENGTH (value_type) == 2
	       || TYPE_LENGTH (value_type) == 4
	       || TYPE_LENGTH (value_type) == 8));
d1596 1
a1596 1
     /*ARGSUSED */
d1626 1
a1626 1
  if (code == TYPE_CODE_STRUCT
d1637 1
a1637 1
	   "Debugger convenience (\"$foo\") variables.\n\
@


1.1.1.6
log
@import gdb-1999-09-08 snapshot
@
text
@d925 1
@


