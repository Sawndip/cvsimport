head	1.176;
access;
symbols
	arc-sim-20090309:1.150
	arc-insight_6_8-branch:1.150.0.6
	arc-insight_6_8-branchpoint:1.150
	insight_6_8-branch:1.150.0.4
	insight_6_8-branchpoint:1.150
	reverse-20081226-branch:1.166.0.4
	reverse-20081226-branchpoint:1.166
	multiprocess-20081120-branch:1.166.0.2
	multiprocess-20081120-branchpoint:1.166
	reverse-20080930-branch:1.164.0.2
	reverse-20080930-branchpoint:1.164
	reverse-20080717-branch:1.159.0.2
	reverse-20080717-branchpoint:1.159
	msnyder-reverse-20080609-branch:1.152.0.2
	msnyder-reverse-20080609-branchpoint:1.152
	drow-reverse-20070409-branch:1.126.0.2
	drow-reverse-20070409-branchpoint:1.126
	gdb_6_8-2008-03-27-release:1.150
	gdb_6_8-branch:1.150.0.2
	gdb_6_8-2008-02-26-branchpoint:1.150
	gdb_6_7_1-2007-10-29-release:1.137
	gdb_6_7-2007-10-10-release:1.137
	gdb_6_7-branch:1.137.0.2
	gdb_6_7-2007-09-07-branchpoint:1.137
	insight_6_6-20070208-release:1.123
	gdb_6_6-2006-12-18-release:1.123
	gdb_6_6-branch:1.123.0.2
	gdb_6_6-2006-11-15-branchpoint:1.123
	insight_6_5-20061003-release:1.122
	gdb-csl-symbian-6_4_50_20060226-12:1.120
	gdb-csl-sourcerygxx-3_4_4-25:1.116.4.1
	nickrob-async-20060828-mergepoint:1.123
	gdb-csl-symbian-6_4_50_20060226-11:1.120
	gdb-csl-sourcerygxx-4_1-17:1.120
	gdb-csl-20060226-branch-local-2:1.120
	gdb-csl-sourcerygxx-4_1-14:1.120
	gdb-csl-sourcerygxx-4_1-13:1.120
	gdb-csl-sourcerygxx-4_1-12:1.120
	gdb-csl-sourcerygxx-3_4_4-21:1.120
	gdb_6_5-20060621-release:1.122
	gdb-csl-sourcerygxx-4_1-9:1.120
	gdb-csl-sourcerygxx-4_1-8:1.120
	gdb-csl-sourcerygxx-4_1-7:1.120
	gdb-csl-arm-2006q1-6:1.120
	gdb-csl-sourcerygxx-4_1-6:1.120
	gdb-csl-symbian-6_4_50_20060226-10:1.120
	gdb-csl-symbian-6_4_50_20060226-9:1.120
	gdb-csl-symbian-6_4_50_20060226-8:1.120
	gdb-csl-coldfire-4_1-11:1.120
	gdb-csl-sourcerygxx-3_4_4-19:1.120
	gdb-csl-coldfire-4_1-10:1.120
	gdb_6_5-branch:1.122.0.8
	gdb_6_5-2006-05-14-branchpoint:1.122
	gdb-csl-sourcerygxx-4_1-5:1.120
	nickrob-async-20060513-branch:1.122.0.6
	nickrob-async-20060513-branchpoint:1.122
	gdb-csl-sourcerygxx-4_1-4:1.120
	msnyder-reverse-20060502-branch:1.122.0.4
	msnyder-reverse-20060502-branchpoint:1.122
	gdb-csl-morpho-4_1-4:1.120
	gdb-csl-sourcerygxx-3_4_4-17:1.120
	readline_5_1-import-branch:1.122.0.2
	readline_5_1-import-branchpoint:1.122
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.120
	gdb-csl-symbian-20060226-branch:1.120.0.8
	gdb-csl-symbian-20060226-branchpoint:1.120
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.120
	msnyder-reverse-20060331-branch:1.120.0.6
	msnyder-reverse-20060331-branchpoint:1.120
	gdb-csl-available-20060303-branch:1.120.0.4
	gdb-csl-available-20060303-branchpoint:1.120
	gdb-csl-20060226-branch:1.120.0.2
	gdb-csl-20060226-branchpoint:1.120
	gdb_6_4-20051202-release:1.116
	msnyder-fork-checkpoint-branch:1.116.0.6
	msnyder-fork-checkpoint-branchpoint:1.116
	gdb-csl-gxxpro-6_3-branch:1.116.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.116
	gdb_6_4-branch:1.116.0.2
	gdb_6_4-2005-11-01-branchpoint:1.116
	gdb-csl-arm-20051020-branch:1.112.0.2
	gdb-csl-arm-20051020-branchpoint:1.112
	msnyder-tracepoint-checkpoint-branch:1.111.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.111
	gdb-csl-arm-20050325-2005-q1b:1.109
	gdb-csl-arm-20050325-2005-q1a:1.109
	csl-arm-20050325-branch:1.109.0.2
	csl-arm-20050325-branchpoint:1.109
	gdb-post-i18n-errorwarning-20050211:1.104
	gdb-pre-i18n-errorwarning-20050211:1.103
	gdb_6_3-20041109-release:1.101
	gdb_6_3-branch:1.101.0.2
	gdb_6_3-20041019-branchpoint:1.101
	drow_intercu-merge-20040921:1.97
	drow_intercu-merge-20040915:1.97
	jimb-gdb_6_2-e500-branch:1.94.0.6
	jimb-gdb_6_2-e500-branchpoint:1.94
	gdb_6_2-20040730-release:1.94
	gdb_6_2-branch:1.94.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.94
	gdb_6_1_1-20040616-release:1.87
	gdb_6_1-2004-04-05-release:1.87
	drow_intercu-merge-20040402:1.87
	drow_intercu-merge-20040327:1.87
	ezannoni_pie-20040323-branch:1.87.0.12
	ezannoni_pie-20040323-branchpoint:1.87
	cagney_tramp-20040321-mergepoint:1.87
	cagney_tramp-20040309-branch:1.87.0.10
	cagney_tramp-20040309-branchpoint:1.87
	gdb_6_1-branch:1.87.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.87
	drow_intercu-20040221-branch:1.87.0.6
	drow_intercu-20040221-branchpoint:1.87
	cagney_bfdfile-20040213-branch:1.87.0.4
	cagney_bfdfile-20040213-branchpoint:1.87
	drow-cplus-merge-20040208:1.87
	carlton_dictionary-20040126-merge:1.87
	cagney_bigcore-20040122-branch:1.87.0.2
	cagney_bigcore-20040122-branchpoint:1.87
	drow-cplus-merge-20040113:1.87
	drow-cplus-merge-20031224:1.83
	drow-cplus-merge-20031220:1.83
	carlton_dictionary-20031215-merge:1.83
	drow-cplus-merge-20031214:1.83
	carlton-dictionary-20031111-merge:1.83
	gdb_6_0-2003-10-04-release:1.76.4.4
	kettenis_sparc-20030918-branch:1.79.0.4
	kettenis_sparc-20030918-branchpoint:1.79
	carlton_dictionary-20030917-merge:1.79
	ezannoni_pie-20030916-branchpoint:1.79
	ezannoni_pie-20030916-branch:1.79.0.2
	cagney_x86i386-20030821-branch:1.77.0.2
	cagney_x86i386-20030821-branchpoint:1.77
	carlton_dictionary-20030805-merge:1.77
	carlton_dictionary-20030627-merge:1.76
	gdb_6_0-branch:1.76.0.4
	gdb_6_0-2003-06-23-branchpoint:1.76
	jimb-ppc64-linux-20030613-branch:1.76.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.76
	cagney_convert-20030606-branch:1.74.0.26
	cagney_convert-20030606-branchpoint:1.74
	cagney_writestrings-20030508-branch:1.74.0.24
	cagney_writestrings-20030508-branchpoint:1.74
	jimb-ppc64-linux-20030528-branch:1.74.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.74
	carlton_dictionary-20030523-merge:1.74
	cagney_fileio-20030521-branch:1.74.0.20
	cagney_fileio-20030521-branchpoint:1.74
	kettenis_i386newframe-20030517-mergepoint:1.74
	jimb-ppc64-linux-20030509-branch:1.74.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.74
	kettenis_i386newframe-20030504-mergepoint:1.74
	carlton_dictionary-20030430-merge:1.74
	kettenis_i386newframe-20030419-branch:1.74.0.16
	kettenis_i386newframe-20030419-branchpoint:1.74
	carlton_dictionary-20030416-merge:1.74
	cagney_frameaddr-20030409-mergepoint:1.74
	kettenis_i386newframe-20030406-branch:1.74.0.14
	kettenis_i386newframe-20030406-branchpoint:1.74
	cagney_frameaddr-20030403-branchpoint:1.74
	cagney_frameaddr-20030403-branch:1.74.0.12
	cagney_framebase-20030330-mergepoint:1.74
	cagney_framebase-20030326-branch:1.74.0.10
	cagney_framebase-20030326-branchpoint:1.74
	cagney_lazyid-20030317-branch:1.74.0.8
	cagney_lazyid-20030317-branchpoint:1.74
	kettenis-i386newframe-20030316-mergepoint:1.74
	offbyone-20030313-branch:1.74.0.6
	offbyone-20030313-branchpoint:1.74
	kettenis-i386newframe-20030308-branch:1.74.0.4
	kettenis-i386newframe-20030308-branchpoint:1.74
	carlton_dictionary-20030305-merge:1.74
	cagney_offbyone-20030303-branch:1.74.0.2
	cagney_offbyone-20030303-branchpoint:1.74
	carlton_dictionary-20030207-merge:1.71
	interps-20030203-mergepoint:1.69
	interps-20030202-branch:1.69.0.2
	interps-20030202-branchpoint:1.69
	cagney-unwind-20030108-branch:1.66.0.2
	cagney-unwind-20030108-branchpoint:1.66
	carlton_dictionary-20021223-merge:1.66
	gdb_5_3-2002-12-12-release:1.61.2.1
	carlton_dictionary-20021115-merge:1.64
	kseitz_interps-20021105-merge:1.63
	kseitz_interps-20021103-merge:1.63
	drow-cplus-merge-20021020:1.62
	drow-cplus-merge-20021025:1.62
	carlton_dictionary-20021025-merge:1.62
	carlton_dictionary-20021011-merge:1.62
	drow-cplus-branch:1.62.0.4
	drow-cplus-branchpoint:1.62
	kseitz_interps-20020930-merge:1.62
	carlton_dictionary-20020927-merge:1.62
	carlton_dictionary-branch:1.62.0.2
	carlton_dictionary-20020920-branchpoint:1.62
	gdb_5_3-branch:1.61.0.2
	gdb_5_3-2002-09-04-branchpoint:1.61
	kseitz_interps-20020829-merge:1.61
	cagney_sysregs-20020825-branch:1.60.0.4
	cagney_sysregs-20020825-branchpoint:1.60
	readline_4_3-import-branch:1.60.0.2
	readline_4_3-import-branchpoint:1.60
	gdb_5_2_1-2002-07-23-release:1.56.2.1
	kseitz_interps-20020528-branch:1.58.0.6
	kseitz_interps-20020528-branchpoint:1.58
	cagney_regbuf-20020515-branch:1.58.0.4
	cagney_regbuf-20020515-branchpoint:1.58
	jimb-macro-020506-branch:1.58.0.2
	jimb-macro-020506-branchpoint:1.58
	gdb_5_2-2002-04-29-release:1.56.2.1
	gdb_5_2-branch:1.56.0.2
	gdb_5_2-2002-03-03-branchpoint:1.56
	gdb_5_1_1-2002-01-24-release:1.27.4.5
	gdb_5_1_0_1-2002-01-03-release:1.27.4.5
	cygnus_cvs_20020108_pre:1.41
	gdb_5_1_0_1-2002-01-03-branchpoint:1.27.4.5
	gdb_5_1_0_1-2002-01-03-branch:1.27.4.5.0.2
	gdb_5_1-2001-11-21-release:1.27.4.5
	gdb_s390-2001-09-26-branch:1.27.0.6
	gdb_s390-2001-09-26-branchpoint:1.27
	gdb_5_1-2001-07-29-branch:1.27.0.4
	gdb_5_1-2001-07-29-branchpoint:1.27
	dberlin-typesystem-branch:1.27.0.2
	dberlin-typesystem-branchpoint:1.27
	gdb-post-ptid_t-2001-05-03:1.27
	gdb-pre-ptid_t-2001-05-03:1.26
	insight-precleanup-2001-01-01:1.18
	gdb-post-protoization-2000-07-29:1.13
	gdb-pre-protoization-2000-07-29:1.12
	gdb-premipsmulti-2000-06-06-branch:1.11.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.11
	gdb-post-params-removal-2000-06-04:1.11
	gdb-pre-params-removal-2000-06-04:1.9
	gdb-post-params-removal-2000-05-28:1.8
	gdb-pre-params-removal-2000-05-28:1.7
	gdb_5_0-2000-05-19-release:1.5.2.1
	gdb_4_18_2-2000-05-18-release:1.5.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.5.2.1
	gdb_4_95_0-2000-04-27-snapshot:1.5.2.1
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	repo-unification-2000-02-06:1.1.1.10
	insight-2000-02-04:1.1.1.10
	gdb-2000-02-04:1.1.1.10
	gdb-2000-02-02:1.1.1.10
	gdb-2000-02-01:1.1.1.10
	gdb-2000-01-31:1.1.1.10
	gdb-2000-01-26:1.1.1.10
	gdb-2000-01-24:1.1.1.10
	gdb-2000-01-17:1.1.1.10
	gdb-2000-01-10:1.1.1.10
	gdb-2000-01-05:1.1.1.9
	gdb-1999-12-21:1.1.1.9
	gdb-1999-12-13:1.1.1.8
	gdb-1999-12-07:1.1.1.8
	gdb-1999-12-06:1.1.1.8
	gdb-1999-11-16:1.1.1.7
	gdb-1999-11-08:1.1.1.7
	gdb-1999-11-01:1.1.1.7
	gdb-1999-10-25:1.1.1.7
	gdb-1999-10-18:1.1.1.7
	gdb-1999-10-11:1.1.1.7
	gdb-1999-10-04:1.1.1.6
	gdb-1999-09-28:1.1.1.5
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.176
date	2009.01.12.01.10.27;	author cgf;	state dead;
branches;
next	1.175;

1.175
date	2009.01.11.13.10.44;	author brobecke;	state Exp;
branches;
next	1.174;

1.174
date	2009.01.11.04.13.55;	author brobecke;	state Exp;
branches;
next	1.173;

1.173
date	2009.01.09.10.58.26;	author brobecke;	state Exp;
branches;
next	1.172;

1.172
date	2009.01.09.10.48.36;	author brobecke;	state Exp;
branches;
next	1.171;

1.171
date	2009.01.09.10.45.42;	author brobecke;	state Exp;
branches;
next	1.170;

1.170
date	2009.01.09.10.43.37;	author brobecke;	state Exp;
branches;
next	1.169;

1.169
date	2009.01.09.10.39.15;	author brobecke;	state Exp;
branches;
next	1.168;

1.168
date	2009.01.09.10.36.00;	author brobecke;	state Exp;
branches;
next	1.167;

1.167
date	2009.01.03.05.57.54;	author brobecke;	state Exp;
branches;
next	1.166;

1.166
date	2008.11.09.11.27.18;	author vprus;	state Exp;
branches;
next	1.165;

1.165
date	2008.10.02.14.20.07;	author muller;	state Exp;
branches;
next	1.164;

1.164
date	2008.09.22.15.21.30;	author palves;	state Exp;
branches;
next	1.163;

1.163
date	2008.09.22.15.20.08;	author palves;	state Exp;
branches;
next	1.162;

1.162
date	2008.09.22.15.16.51;	author palves;	state Exp;
branches;
next	1.161;

1.161
date	2008.09.08.21.51.18;	author palves;	state Exp;
branches;
next	1.160;

1.160
date	2008.08.08.13.16.17;	author palves;	state Exp;
branches;
next	1.159;

1.159
date	2008.07.09.22.49.56;	author palves;	state Exp;
branches;
next	1.158;

1.158
date	2008.07.09.22.23.05;	author palves;	state Exp;
branches;
next	1.157;

1.157
date	2008.07.03.17.38.08;	author palves;	state Exp;
branches;
next	1.156;

1.156
date	2008.06.26.15.51.28;	author drow;	state Exp;
branches;
next	1.155;

1.155
date	2008.06.24.02.33.17;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2008.06.19.06.36.45;	author muller;	state Exp;
branches;
next	1.153;

1.153
date	2008.06.18.06.27.34;	author muller;	state Exp;
branches;
next	1.152;

1.152
date	2008.05.20.18.36.36;	author brobecke;	state Exp;
branches;
next	1.151;

1.151
date	2008.03.11.05.21.38;	author deuling;	state Exp;
branches;
next	1.150;

1.150
date	2008.01.29.21.11.24;	author brobecke;	state Exp;
branches;
next	1.149;

1.149
date	2008.01.25.00.09.50;	author msnyder;	state Exp;
branches;
next	1.148;

1.148
date	2008.01.23.11.26.28;	author vprus;	state Exp;
branches;
next	1.147;

1.147
date	2008.01.14.08.01.15;	author muller;	state Exp;
branches;
next	1.146;

1.146
date	2008.01.06.06.59.14;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2008.01.01.18.42.08;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2007.12.22.22.09.56;	author muller;	state Exp;
branches;
next	1.143;

1.143
date	2007.12.06.11.17.03;	author muller;	state Exp;
branches;
next	1.142;

1.142
date	2007.12.02.21.32.46;	author muller;	state Exp;
branches;
next	1.141;

1.141
date	2007.12.02.05.45.08;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2007.11.24.12.13.28;	author palves;	state Exp;
branches;
next	1.139;

1.139
date	2007.11.16.04.53.46;	author deuling;	state Exp;
branches;
next	1.138;

1.138
date	2007.10.16.18.43.24;	author palves;	state Exp;
branches;
next	1.137;

1.137
date	2007.09.04.01.12.18;	author palves;	state Exp;
branches;
next	1.136;

1.136
date	2007.09.03.23.06.35;	author palves;	state Exp;
branches;
next	1.135;

1.135
date	2007.08.23.18.08.47;	author brobecke;	state Exp;
branches;
next	1.134;

1.134
date	2007.08.14.11.09.45;	author vprus;	state Exp;
branches;
next	1.133;

1.133
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.132;

1.132
date	2007.06.16.17.16.25;	author uweigand;	state Exp;
branches;
next	1.131;

1.131
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.130;

1.130
date	2007.05.06.18.55.41;	author uweigand;	state Exp;
branches;
next	1.129;

1.129
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.128;

1.128
date	2007.05.06.14.33.21;	author uweigand;	state Exp;
branches;
next	1.127;

1.127
date	2007.04.19.19.35.24;	author palves;	state Exp;
branches;
next	1.126;

1.126
date	2007.02.12.13.04.36;	author corinna;	state Exp;
branches;
next	1.125;

1.125
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.124;

1.124
date	2006.12.09.09.12.59;	author corinna;	state Exp;
branches;
next	1.123;

1.123
date	2006.05.21.23.04.39;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2006.04.10.21.43.45;	author cgf;	state Exp;
branches
	1.122.6.1;
next	1.121;

1.121
date	2006.04.10.16.13.01;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2006.02.20.05.10.51;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2006.01.24.22.09.28;	author drow;	state Exp;
branches;
next	1.118;

1.118
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches;
next	1.117;

1.117
date	2005.11.28.01.17.59;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2005.11.01.14.07.00;	author cgf;	state Exp;
branches
	1.116.4.1;
next	1.115;

1.115
date	2005.11.01.05.08.28;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2005.11.01.00.40.09;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2005.10.31.22.50.58;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2005.07.06.14.54.34;	author bobbybrasko;	state Exp;
branches
	1.112.2.1;
next	1.111;

1.111
date	2005.05.23.19.32.27;	author cagney;	state Exp;
branches;
next	1.110;

1.110
date	2005.03.27.05.21.12;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2005.03.21.19.54.15;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2005.02.18.15.25.31;	author cagney;	state Exp;
branches;
next	1.107;

1.107
date	2005.02.15.15.49.23;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2005.02.14.18.10.10;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2005.02.11.18.13.54;	author cagney;	state Exp;
branches;
next	1.104;

1.104
date	2005.02.11.04.06.09;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2005.01.23.05.09.46;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2005.01.12.18.31.34;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2004.10.08.20.29.56;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2004.10.05.21.53.33;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2004.09.29.14.26.52;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2004.09.29.13.54.33;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2004.07.26.14.53.06;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2004.07.24.01.00.21;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2004.07.01.21.34.02;	author msnyder;	state Exp;
branches;
next	1.93;

1.93
date	2004.06.29.15.37.31;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2004.06.25.19.46.08;	author cagney;	state Exp;
branches;
next	1.91;

1.91
date	2004.06.24.21.51.49;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2004.06.15.01.04.20;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2004.05.25.14.58.31;	author cagney;	state Exp;
branches;
next	1.88;

1.88
date	2004.04.21.17.47.10;	author cagney;	state Exp;
branches;
next	1.87;

1.87
date	2004.01.05.19.53.08;	author cagney;	state Exp;
branches
	1.87.6.1;
next	1.86;

1.86
date	2003.12.26.14.56.45;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2003.12.26.04.29.22;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2003.12.26.00.39.04;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2003.10.26.15.03.41;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2003.10.23.03.01.55;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2003.09.21.01.26.46;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2003.09.20.02.38.39;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2003.09.13.16.46.21;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2003.09.13.02.26.42;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2003.07.06.19.48.54;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.11.22.36.04;	author brobecke;	state Exp;
branches
	1.76.4.1;
next	1.75;

1.75
date	2003.06.06.23.33.00;	author mmitchel;	state Exp;
branches;
next	1.74;

1.74
date	2003.02.21.02.29.18;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2003.02.15.03.24.54;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2003.02.14.05.15.43;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2003.02.06.20.37.55;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2003.02.06.19.51.25;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2003.01.30.01.39.52;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.01.10.20.14.02;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2002.11.23.02.49.45;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2002.11.22.07.34.54;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2002.11.12.21.43.55;	author drow;	state Exp;
branches;
next	1.63;

1.63
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2002.09.14.03.28.23;	author cgf;	state Exp;
branches
	1.62.2.1
	1.62.4.1;
next	1.61;

1.61
date	2002.08.26.19.18.33;	author ciceron;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2002.07.11.13.50.49;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2002.07.10.22.38.05;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.22.05.03.22;	author cgf;	state Exp;
branches
	1.58.6.1;
next	1.57;

1.57
date	2002.03.06.06.28.34;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.22.17.04.25;	author muller;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2002.02.22.01.35.59;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.21.06.44.05;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2002.02.21.04.59.36;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.19.08.49.41;	author muller;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.16.02.33.24;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.08.23.12.16;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.08.21.22.10;	author hunt;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.08.19.31.38;	author muller;	state Exp;
branches;
next	1.47;

1.47
date	2002.02.06.09.27.29;	author muller;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.06.09.14.50;	author muller;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.05.08.04.22;	author muller;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.04.11.00.05;	author muller;	state Exp;
branches;
next	1.43;

1.43
date	2002.01.19.03.32.41;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2002.01.08.08.26.42;	author muller;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.03.08.19.01;	author muller;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.27.05.16.39;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.27.05.15.56;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.24.19.00.03;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.24.18.21.26;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.01.16.17.08;	author fnf;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.31.19.05.35;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.30.17.34.30;	author fnf;	state Exp;
branches;
next	1.33;

1.33
date	2001.10.26.09.29.31;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2001.10.20.05.11.41;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2001.10.16.04.50.21;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.13.01.20.29;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.12.04.32.15;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2001.10.11.01.55.58;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.04.04.15.28;	author kevinb;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2001.03.18.21.35.58;	author chastain;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.06.08.21.18;	author kevinb;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.01.01.39.22;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.19.11.47.16;	author eliz;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.06.05.04.40;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.06.05.01.04;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.27.19.32.32;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.25.22.35.01;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.15.01.01.51;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.28.17.27.38;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.15.19.58.14;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.27.04.21.35;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.06.23.25.32;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.11.02.34.40;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.04.00.28.17;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.03.05.04.14;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.28.01.12.33;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.21.14.24.45;	author ezannoni;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.21.02.26.14;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.25.02.26.21;	author cgf;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.02.28.06.43.20;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.28.06.31.36;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.47;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.51;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.11.14;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.16.19.54.17;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.31.01.06.22;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.10.05.23.09.03;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.10.12.04.37.25;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.12.07.03.56.07;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.12.22.21.45.11;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2000.01.11.03.07.26;	author jsm;	state Exp;
branches;
next	;

1.5.2.1
date	2000.04.21.04.33.50;	author cgf;	state Exp;
branches;
next	;

1.27.4.1
date	2001.10.11.02.13.08;	author cgf;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2001.10.12.04.32.26;	author cgf;	state Exp;
branches;
next	1.27.4.3;

1.27.4.3
date	2001.10.13.01.21.05;	author cgf;	state Exp;
branches;
next	1.27.4.4;

1.27.4.4
date	2001.10.16.04.50.29;	author cgf;	state Exp;
branches;
next	1.27.4.5;

1.27.4.5
date	2001.10.20.05.13.17;	author cgf;	state Exp;
branches;
next	;

1.56.2.1
date	2002.04.09.08.42.57;	author muller;	state Exp;
branches;
next	;

1.58.6.1
date	2002.07.22.21.47.04;	author kseitz;	state Exp;
branches;
next	1.58.6.2;

1.58.6.2
date	2002.08.30.22.52.46;	author kseitz;	state Exp;
branches;
next	1.58.6.3;

1.58.6.3
date	2002.10.01.00.46.15;	author kseitz;	state Exp;
branches;
next	1.58.6.4;

1.58.6.4
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.61.2.1
date	2002.11.25.22.40.08;	author cgf;	state Exp;
branches;
next	;

1.62.2.1
date	2002.11.15.19.19.01;	author carlton;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2002.12.23.19.38.50;	author carlton;	state Exp;
branches;
next	1.62.2.3;

1.62.2.3
date	2003.02.07.19.17.54;	author carlton;	state Exp;
branches;
next	1.62.2.4;

1.62.2.4
date	2003.03.06.00.56.33;	author carlton;	state Exp;
branches;
next	1.62.2.5;

1.62.2.5
date	2003.06.27.21.50.13;	author carlton;	state Exp;
branches;
next	1.62.2.6;

1.62.2.6
date	2003.08.05.17.13.15;	author carlton;	state Exp;
branches;
next	1.62.2.7;

1.62.2.7
date	2003.09.17.21.28.36;	author carlton;	state Exp;
branches;
next	1.62.2.8;

1.62.2.8
date	2003.11.11.23.50.59;	author carlton;	state Exp;
branches;
next	1.62.2.9;

1.62.2.9
date	2004.01.26.19.11.34;	author carlton;	state Exp;
branches;
next	;

1.62.4.1
date	2003.12.14.20.27.34;	author drow;	state Exp;
branches;
next	1.62.4.2;

1.62.4.2
date	2004.01.13.16.12.03;	author drow;	state Exp;
branches;
next	;

1.76.4.1
date	2003.07.06.19.55.40;	author cgf;	state Exp;
branches;
next	1.76.4.2;

1.76.4.2
date	2003.09.13.02.26.52;	author cgf;	state Exp;
branches;
next	1.76.4.3;

1.76.4.3
date	2003.09.13.16.58.12;	author cgf;	state Exp;
branches;
next	1.76.4.4;

1.76.4.4
date	2003.09.20.02.39.49;	author cgf;	state Exp;
branches;
next	;

1.87.6.1
date	2004.09.16.17.01.27;	author drow;	state Exp;
branches;
next	;

1.112.2.1
date	2006.01.26.18.05.55;	author drow;	state Exp;
branches;
next	;

1.116.4.1
date	2006.01.26.18.10.22;	author drow;	state Exp;
branches;
next	;

1.122.6.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;


desc
@@


1.176
log
@Fix linking with --enable-targets=all:
* Makefile.in (ALL_TARGET_OBS): Add windows-tdep.o.
(HFILES_NO_SRCDIR): Add windows-tdep.h.
(ALLDEPFILES): Add windows-tdep.c.
* win32-tdep.h: Delete.
* windows-tdep.h: Rename from win32-tdep.h.
* win32-nat.h: Delete.
* windows-nat.h: Rename from win32-nat.h.
* win32-nat.c: Delete.
* windows-nat.c: Rename from win32-nat.c.
* win32-termcap.c: Delete.
* windows-termcap.c: Rename from win32-termcap.c.
* amd64-windows-nat.c: Handle rename from win32-nat.h -> windows-nat.h.
* configure.ac: Handle rename from win32-termcap.c -> windows-termcap.c.
* configure: Regenerate.
* gdb_curses.h: Change comment to reflect rename from win32-termcap.c ->
windows-termcap.c.
* i386-cygwin-tdep.c: Handle rename from win32-tdep.h -> windows-tdep.h.
* i386-windows-nat.c: Refect rename from win32-nat.h -> windows-nat.h.
* windows-nat.c: Ditto.  Also reflect rename from from win32-tdep.h ->
windows-tdep.h.
(win32_make_so): Handle cygwin compiler warning due to change of load_addr from
DWORD to LPVOID.
(handle_load_dll): Use %p in format string to properly print address and avoid
a compiler warning.
(DEBUG_EXCEPTION_SIMPLE): Ditto.
(handle_exception): Ditto.
* windows-tdep.c: Handle rename from win32-tdep.h -> windows-tdep.h.
* config/i386/cygwin.mh: Handle rename from win32-nat.o -> windows-nat.o.
* config/i386/mingw.mh: Ditto.
* config/i386/mingw64.mh: Ditto.
@
text
@/* Target-vector operations for controlling win32 child processes, for GDB.

   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.

   Contributed by Cygnus Solutions, A Red Hat Company.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Originally by Steve Chamberlain, sac@@cygnus.com */

#include "defs.h"
#include "frame.h"		/* required by inferior.h */
#include "inferior.h"
#include "target.h"
#include "exceptions.h"
#include "gdbcore.h"
#include "command.h"
#include "completer.h"
#include "regcache.h"
#include "top.h"
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <windows.h>
#include <imagehlp.h>
#ifdef __CYGWIN__
#include <sys/cygwin.h>
#endif
#include <signal.h>

#include "buildsym.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdb_obstack.h"
#include "gdb_string.h"
#include "gdbthread.h"
#include "gdbcmd.h"
#include <sys/param.h>
#include <unistd.h>
#include "exec.h"
#include "solist.h"
#include "solib.h"
#include "xml-support.h"

#include "i386-tdep.h"
#include "i387-tdep.h"

#include "win32-tdep.h"
#include "win32-nat.h"

static struct target_ops win32_ops;

#ifdef __CYGWIN__
/* The starting and ending address of the cygwin1.dll text segment. */
static bfd_vma cygwin_load_start;
static bfd_vma cygwin_load_end;
#endif

static int have_saved_context;	/* True if we've saved context from a cygwin signal. */
static CONTEXT saved_context;	/* Containes the saved context from a cygwin signal. */

/* If we're not using the old Cygwin header file set, define the
   following which never should have been in the generic Win32 API
   headers in the first place since they were our own invention... */
#ifndef _GNU_H_WINDOWS_H
enum
  {
    FLAG_TRACE_BIT = 0x100,
    CONTEXT_DEBUGGER = (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
  };
#endif
#include <psapi.h>

#ifndef CONTEXT_EXTENDED_REGISTERS
/* This macro is only defined on ia32.  It only makes sense on this target,
   so define it as zero if not already defined.  */
#define CONTEXT_EXTENDED_REGISTERS 0
#endif

#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS \
	| CONTEXT_EXTENDED_REGISTERS

static unsigned dr[8];
static int debug_registers_changed;
static int debug_registers_used;
#define DR6_CLEAR_VALUE 0xffff0ff0

/* The string sent by cygwin when it processes a signal.
   FIXME: This should be in a cygwin include file. */
#ifndef _CYGWIN_SIGNAL_STRING
#define _CYGWIN_SIGNAL_STRING "cYgSiGw00f"
#endif

#define CHECK(x)	check (x, __FILE__,__LINE__)
#define DEBUG_EXEC(x)	if (debug_exec)		printf_unfiltered x
#define DEBUG_EVENTS(x)	if (debug_events)	printf_unfiltered x
#define DEBUG_MEM(x)	if (debug_memory)	printf_unfiltered x
#define DEBUG_EXCEPT(x)	if (debug_exceptions)	printf_unfiltered x

static void win32_stop (ptid_t);
static int win32_win32_thread_alive (ptid_t);
static void win32_kill_inferior (void);

static enum target_signal last_sig = TARGET_SIGNAL_0;
/* Set if a signal was received from the debugged process */

/* Thread information structure used to track information that is
   not available in gdb's thread structure.  */
typedef struct thread_info_struct
  {
    struct thread_info_struct *next;
    DWORD id;
    HANDLE h;
    char *name;
    int suspended;
    int reload_context;
    CONTEXT context;
    STACKFRAME sf;
  }
thread_info;

static thread_info thread_head;

/* The process and thread handles for the above context. */

static DEBUG_EVENT current_event;	/* The current debug event from
					   WaitForDebugEvent */
static HANDLE current_process_handle;	/* Currently executing process */
static thread_info *current_thread;	/* Info on currently selected thread */
static DWORD main_thread_id;		/* Thread ID of the main thread */

/* Counts of things. */
static int exception_count = 0;
static int event_count = 0;
static int saw_create;
static int open_process_used = 0;

/* User options. */
static int new_console = 0;
#ifdef __CYGWIN__
static int cygwin_exceptions = 0;
#endif
static int new_group = 1;
static int debug_exec = 0;		/* show execution */
static int debug_events = 0;		/* show events from kernel */
static int debug_memory = 0;		/* show target memory accesses */
static int debug_exceptions = 0;	/* show target exceptions */
static int useshell = 0;		/* use shell for subprocesses */

/* This vector maps GDB's idea of a register's number into an offset
   in the win32 exception context vector.

   It also contains the bit mask needed to load the register in question.

   The contents of this table can only be computed by the units
   that provide CPU-specific support for Windows native debugging.
   These units should set the table by calling
   win32_set_context_register_offsets.

   One day we could read a reg, we could inspect the context we
   already have loaded, if it doesn't have the bit set that we need,
   we read that set of registers in using GetThreadContext.  If the
   context already contains what we need, we just unpack it. Then to
   write a register, first we have to ensure that the context contains
   the other regs of the group, and then we copy the info in and set
   out bit. */

static const int *mappings;

/* This vector maps the target's idea of an exception (extracted
   from the DEBUG_EVENT structure) to GDB's idea. */

struct xlate_exception
  {
    int them;
    enum target_signal us;
  };

static const struct xlate_exception
  xlate[] =
{
  {EXCEPTION_ACCESS_VIOLATION, TARGET_SIGNAL_SEGV},
  {STATUS_STACK_OVERFLOW, TARGET_SIGNAL_SEGV},
  {EXCEPTION_BREAKPOINT, TARGET_SIGNAL_TRAP},
  {DBG_CONTROL_C, TARGET_SIGNAL_INT},
  {EXCEPTION_SINGLE_STEP, TARGET_SIGNAL_TRAP},
  {STATUS_FLOAT_DIVIDE_BY_ZERO, TARGET_SIGNAL_FPE},
  {-1, -1}};

/* Set the MAPPINGS static global to OFFSETS.
   See the description of MAPPINGS for more details.  */

void
win32_set_context_register_offsets (const int *offsets)
{
  mappings = offsets;
}

static void
check (BOOL ok, const char *file, int line)
{
  if (!ok)
    printf_filtered ("error return %s:%d was %lu\n", file, line,
		     GetLastError ());
}

/* Find a thread record given a thread id.  If GET_CONTEXT is not 0,
   then also retrieve the context for this thread.  If GET_CONTEXT is
   negative, then don't suspend the thread.  */
static thread_info *
thread_rec (DWORD id, int get_context)
{
  thread_info *th;

  for (th = &thread_head; (th = th->next) != NULL;)
    if (th->id == id)
      {
	if (!th->suspended && get_context)
	  {
	    if (get_context > 0 && id != current_event.dwThreadId)
	      {
		if (SuspendThread (th->h) == (DWORD) -1)
		  {
		    DWORD err = GetLastError ();
		    warning (_("SuspendThread failed. (winerr %d)"),
			     (int) err);
		    return NULL;
		  }
		th->suspended = 1;
	      }
	    else if (get_context < 0)
	      th->suspended = -1;
	    th->reload_context = 1;
	  }
	return th;
      }

  return NULL;
}

/* Add a thread to the thread list.  */
static thread_info *
win32_add_thread (ptid_t ptid, HANDLE h)
{
  thread_info *th;
  DWORD id;

  gdb_assert (ptid_get_tid (ptid) != 0);

  id = ptid_get_tid (ptid);

  if ((th = thread_rec (id, FALSE)))
    return th;

  th = XZALLOC (thread_info);
  th->id = id;
  th->h = h;
  th->next = thread_head.next;
  thread_head.next = th;
  add_thread (ptid);
  /* Set the debug registers for the new thread if they are used.  */
  if (debug_registers_used)
    {
      /* Only change the value of the debug registers.  */
      th->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
      CHECK (GetThreadContext (th->h, &th->context));
      th->context.Dr0 = dr[0];
      th->context.Dr1 = dr[1];
      th->context.Dr2 = dr[2];
      th->context.Dr3 = dr[3];
      th->context.Dr6 = DR6_CLEAR_VALUE;
      th->context.Dr7 = dr[7];
      CHECK (SetThreadContext (th->h, &th->context));
      th->context.ContextFlags = 0;
    }
  return th;
}

/* Clear out any old thread list and reintialize it to a
   pristine state. */
static void
win32_init_thread_list (void)
{
  thread_info *th = &thread_head;

  DEBUG_EVENTS (("gdb: win32_init_thread_list\n"));
  init_thread_list ();
  while (th->next != NULL)
    {
      thread_info *here = th->next;
      th->next = here->next;
      xfree (here);
    }
  thread_head.next = NULL;
}

/* Delete a thread from the list of threads */
static void
win32_delete_thread (ptid_t ptid)
{
  thread_info *th;
  DWORD id;

  gdb_assert (ptid_get_tid (ptid) != 0);

  id = ptid_get_tid (ptid);

  if (info_verbose)
    printf_unfiltered ("[Deleting %s]\n", target_pid_to_str (ptid));
  delete_thread (ptid);

  for (th = &thread_head;
       th->next != NULL && th->next->id != id;
       th = th->next)
    continue;

  if (th->next != NULL)
    {
      thread_info *here = th->next;
      th->next = here->next;
      xfree (here);
    }
}

static void
do_win32_fetch_inferior_registers (struct regcache *regcache, int r)
{
  char *context_offset = ((char *) &current_thread->context) + mappings[r];
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  long l;

  if (!current_thread)
    return;	/* Windows sometimes uses a non-existent thread id in its
		   events */

  if (current_thread->reload_context)
    {
#ifdef __COPY_CONTEXT_SIZE
      if (have_saved_context)
	{
	  /* Lie about where the program actually is stopped since cygwin has informed us that
	     we should consider the signal to have occurred at another location which is stored
	     in "saved_context. */
	  memcpy (&current_thread->context, &saved_context, __COPY_CONTEXT_SIZE);
	  have_saved_context = 0;
	}
      else
#endif
	{
	  thread_info *th = current_thread;
	  th->context.ContextFlags = CONTEXT_DEBUGGER_DR;
	  GetThreadContext (th->h, &th->context);
	  /* Copy dr values from that thread. 
	     But only if there were not modified since last stop. PR gdb/2388 */
	  if (!debug_registers_changed)
	    {
	      dr[0] = th->context.Dr0;
	      dr[1] = th->context.Dr1;
	      dr[2] = th->context.Dr2;
	      dr[3] = th->context.Dr3;
	      dr[6] = th->context.Dr6;
	      dr[7] = th->context.Dr7;
	    }
	}
      current_thread->reload_context = 0;
    }

  if (r == I387_FISEG_REGNUM (tdep))
    {
      l = *((long *) context_offset) & 0xffff;
      regcache_raw_supply (regcache, r, (char *) &l);
    }
  else if (r == I387_FOP_REGNUM (tdep))
    {
      l = (*((long *) context_offset) >> 16) & ((1 << 11) - 1);
      regcache_raw_supply (regcache, r, (char *) &l);
    }
  else if (r >= 0)
    regcache_raw_supply (regcache, r, context_offset);
  else
    {
      for (r = 0; r < gdbarch_num_regs (gdbarch); r++)
	do_win32_fetch_inferior_registers (regcache, r);
    }
}

static void
win32_fetch_inferior_registers (struct regcache *regcache, int r)
{
  current_thread = thread_rec (ptid_get_tid (inferior_ptid), TRUE);
  /* Check if current_thread exists.  Windows sometimes uses a non-existent
     thread id in its events */
  if (current_thread)
    do_win32_fetch_inferior_registers (regcache, r);
}

static void
do_win32_store_inferior_registers (const struct regcache *regcache, int r)
{
  if (!current_thread)
    /* Windows sometimes uses a non-existent thread id in its events */;
  else if (r >= 0)
    regcache_raw_collect (regcache, r,
			  ((char *) &current_thread->context) + mappings[r]);
  else
    {
      for (r = 0; r < gdbarch_num_regs (get_regcache_arch (regcache)); r++)
	do_win32_store_inferior_registers (regcache, r);
    }
}

/* Store a new register value into the current thread context */
static void
win32_store_inferior_registers (struct regcache *regcache, int r)
{
  current_thread = thread_rec (ptid_get_tid (inferior_ptid), TRUE);
  /* Check if current_thread exists.  Windows sometimes uses a non-existent
     thread id in its events */
  if (current_thread)
    do_win32_store_inferior_registers (regcache, r);
}

static int psapi_loaded = 0;
static BOOL WINAPI (*psapi_EnumProcessModules) (HANDLE, HMODULE *, DWORD,
						LPDWORD);
static BOOL WINAPI (*psapi_GetModuleInformation) (HANDLE, HMODULE, LPMODULEINFO,
						  DWORD);
static DWORD WINAPI (*psapi_GetModuleFileNameExA) (HANDLE, HMODULE, LPSTR,
						   DWORD);

/* Get the name of a given module at at given base address.  If base_address
   is zero return the first loaded module (which is always the name of the
   executable).  */
static int
get_module_name (LPVOID base_address, char *dll_name_ret)
{
  DWORD len;
  MODULEINFO mi;
  int i;
  HMODULE dh_buf[1];
  HMODULE *DllHandle = dh_buf;	/* Set to temporary storage for initial query */
  DWORD cbNeeded;
#ifdef __CYGWIN__
  char pathbuf[PATH_MAX + 1];	/* Temporary storage prior to converting to
				   posix form */
#else
  char *pathbuf = dll_name_ret;	/* Just copy directly to passed-in arg */
#endif

  /* If psapi_loaded < 0 either psapi.dll is not available or it does not contain
     the needed functions. */
  if (psapi_loaded <= 0)
    goto failed;

  cbNeeded = 0;
  /* Find size of buffer needed to handle list of modules loaded in inferior */
  if (!psapi_EnumProcessModules (current_process_handle, DllHandle,
				 sizeof (HMODULE), &cbNeeded) || !cbNeeded)
    goto failed;

  /* Allocate correct amount of space for module list */
  DllHandle = (HMODULE *) alloca (cbNeeded);
  if (!DllHandle)
    goto failed;

  /* Get the list of modules */
  if (!psapi_EnumProcessModules (current_process_handle, DllHandle, cbNeeded,
				 &cbNeeded))
    goto failed;

  for (i = 0; i < (int) (cbNeeded / sizeof (HMODULE)); i++)
    {
      /* Get information on this module */
      if (!psapi_GetModuleInformation (current_process_handle, DllHandle[i],
				       &mi, sizeof (mi)))
	error (_("Can't get module info"));

      if (!base_address || mi.lpBaseOfDll == base_address)
	{
	  /* Try to find the name of the given module */
	  len = psapi_GetModuleFileNameExA (current_process_handle,
					    DllHandle[i], pathbuf, MAX_PATH);
	  if (len == 0)
	    error (_("Error getting dll name: %u."), (unsigned) GetLastError ());
#ifdef __CYGWIN__
	  /* Cygwin prefers that the path be in /x/y/z format */
	  cygwin_conv_to_full_posix_path (pathbuf, dll_name_ret);
#endif
	  return 1;	/* success */
	}
    }

failed:
  dll_name_ret[0] = '\0';
  return 0;		/* failure */
}

/* Encapsulate the information required in a call to
   symbol_file_add_args */
struct safe_symbol_file_add_args
{
  char *name;
  int from_tty;
  struct section_addr_info *addrs;
  int mainline;
  int flags;
  struct ui_file *err, *out;
  struct objfile *ret;
};

/* Maintain a linked list of "so" information. */
struct lm_info
{
  LPVOID load_addr;
};

static struct so_list solib_start, *solib_end;

/* Call symbol_file_add with stderr redirected.  We don't care if there
   are errors. */
static int
safe_symbol_file_add_stub (void *argv)
{
#define p ((struct safe_symbol_file_add_args *) argv)
  p->ret = symbol_file_add (p->name, p->from_tty, p->addrs, p->mainline, p->flags);
  return !!p->ret;
#undef p
}

/* Restore gdb's stderr after calling symbol_file_add */
static void
safe_symbol_file_add_cleanup (void *p)
{
#define sp ((struct safe_symbol_file_add_args *)p)
  gdb_flush (gdb_stderr);
  gdb_flush (gdb_stdout);
  ui_file_delete (gdb_stderr);
  ui_file_delete (gdb_stdout);
  gdb_stderr = sp->err;
  gdb_stdout = sp->out;
#undef sp
}

/* symbol_file_add wrapper that prevents errors from being displayed. */
static struct objfile *
safe_symbol_file_add (char *name, int from_tty,
		      struct section_addr_info *addrs,
		      int mainline, int flags)
{
  struct safe_symbol_file_add_args p;
  struct cleanup *cleanup;

  cleanup = make_cleanup (safe_symbol_file_add_cleanup, &p);

  p.err = gdb_stderr;
  p.out = gdb_stdout;
  gdb_flush (gdb_stderr);
  gdb_flush (gdb_stdout);
  gdb_stderr = ui_file_new ();
  gdb_stdout = ui_file_new ();
  p.name = name;
  p.from_tty = from_tty;
  p.addrs = addrs;
  p.mainline = mainline;
  p.flags = flags;
  catch_errors (safe_symbol_file_add_stub, &p, "", RETURN_MASK_ERROR);

  do_cleanups (cleanup);
  return p.ret;
}

static struct so_list *
win32_make_so (const char *name, LPVOID load_addr)
{
  struct so_list *so;
  char buf[MAX_PATH + 1];
  char cwd[MAX_PATH + 1];
  char *p;
  WIN32_FIND_DATA w32_fd;
  HANDLE h = FindFirstFile(name, &w32_fd);
  MEMORY_BASIC_INFORMATION m;

  if (h == INVALID_HANDLE_VALUE)
    strcpy (buf, name);
  else
    {
      FindClose (h);
      strcpy (buf, name);
      if (GetCurrentDirectory (MAX_PATH + 1, cwd))
	{
	  p = strrchr (buf, '\\');
	  if (p)
	    p[1] = '\0';
	  SetCurrentDirectory (buf);
	  GetFullPathName (w32_fd.cFileName, MAX_PATH, buf, &p);
	  SetCurrentDirectory (cwd);
	}
    }

  if (strcasecmp (buf, "ntdll.dll") == 0)
    {
      GetSystemDirectory (buf, sizeof (buf));
      strcat (buf, "\\ntdll.dll");
    }
  so = XZALLOC (struct so_list);
  so->lm_info = (struct lm_info *) xmalloc (sizeof (struct lm_info));
  so->lm_info->load_addr = load_addr;
  strcpy (so->so_original_name, name);
#ifndef __CYGWIN__
  strcpy (so->so_name, buf);
#else
  cygwin_conv_to_posix_path (buf, so->so_name);
  /* Record cygwin1.dll .text start/end.  */
  p = strchr (so->so_name, '\0') - (sizeof ("/cygwin1.dll") - 1);
  if (p >= so->so_name && strcasecmp (p, "/cygwin1.dll") == 0)
    {
      bfd *abfd;
      asection *text = NULL;
      CORE_ADDR text_vma;

      abfd = bfd_openr (so->so_name, "pei-i386");

      if (!abfd)
	return so;

      if (bfd_check_format (abfd, bfd_object))
	text = bfd_get_section_by_name (abfd, ".text");

      if (!text)
	{
	  bfd_close (abfd);
	  return so;
	}

      /* The symbols in a dll are offset by 0x1000, which is the the
	 offset from 0 of the first byte in an image - because of the
	 file header and the section alignment. */
      cygwin_load_start = load_addr + 0x1000;
      cygwin_load_end = cygwin_load_start + bfd_section_size (abfd, text);

      bfd_close (abfd);
    }
#endif

  return so;
}

static char *
get_image_name (HANDLE h, void *address, int unicode)
{
  static char buf[(2 * MAX_PATH) + 1];
  DWORD size = unicode ? sizeof (WCHAR) : sizeof (char);
  char *address_ptr;
  int len = 0;
  char b[2];
  SIZE_T done;

  /* Attempt to read the name of the dll that was detected.
     This is documented to work only when actively debugging
     a program.  It will not work for attached processes. */
  if (address == NULL)
    return NULL;

  /* See if we could read the address of a string, and that the
     address isn't null. */
  if (!ReadProcessMemory (h, address,  &address_ptr, sizeof (address_ptr), &done)
      || done != sizeof (address_ptr) || !address_ptr)
    return NULL;

  /* Find the length of the string */
  while (ReadProcessMemory (h, address_ptr + len++ * size, &b, size, &done)
	 && (b[0] != 0 || b[size - 1] != 0) && done == size)
    continue;

  if (!unicode)
    ReadProcessMemory (h, address_ptr, buf, len, &done);
  else
    {
      WCHAR *unicode_address = (WCHAR *) alloca (len * sizeof (WCHAR));
      ReadProcessMemory (h, address_ptr, unicode_address, len * sizeof (WCHAR),
			 &done);

      WideCharToMultiByte (CP_ACP, 0, unicode_address, len, buf, len, 0, 0);
    }

  return buf;
}

/* Wait for child to do something.  Return pid of child, or -1 in case
   of error; store status through argument pointer OURSTATUS.  */
static int
handle_load_dll (void *dummy)
{
  LOAD_DLL_DEBUG_INFO *event = &current_event.u.LoadDll;
  char dll_buf[MAX_PATH + 1];
  char *dll_name = NULL;

  dll_buf[0] = dll_buf[sizeof (dll_buf) - 1] = '\0';

  if (!get_module_name (event->lpBaseOfDll, dll_buf))
    dll_buf[0] = dll_buf[sizeof (dll_buf) - 1] = '\0';

  dll_name = dll_buf;

  if (*dll_name == '\0')
    dll_name = get_image_name (current_process_handle,
			       event->lpImageName, event->fUnicode);
  if (!dll_name)
    return 1;

  solib_end->next = win32_make_so (dll_name, event->lpBaseOfDll);
  solib_end = solib_end->next;

  DEBUG_EVENTS (("gdb: Loading dll \"%s\" at 0x%lx.\n", solib_end->so_name,
		 solib_end->lm_info->load_addr));

  return 1;
}

static void
win32_free_so (struct so_list *so)
{
  if (so->lm_info)
    xfree (so->lm_info);
  xfree (so);
}

static int
handle_unload_dll (void *dummy)
{
  LPVOID lpBaseOfDll = current_event.u.UnloadDll.lpBaseOfDll;
  struct so_list *so;

  for (so = &solib_start; so->next != NULL; so = so->next)
    if (so->next->lm_info->load_addr == lpBaseOfDll)
      {
	struct so_list *sodel = so->next;
	so->next = sodel->next;
	if (!so->next)
	  solib_end = so;
	DEBUG_EVENTS (("gdb: Unloading dll \"%s\".\n", sodel->so_name));

	win32_free_so (sodel);
	solib_add (NULL, 0, NULL, auto_solib_add);
	return 1;
      }

  error (_("Error: dll starting at 0x%lx not found."), (DWORD) lpBaseOfDll);

  return 0;
}

/* Clear list of loaded DLLs. */
static void
win32_clear_solib (void)
{
  solib_start.next = NULL;
  solib_end = &solib_start;
}

/* Load DLL symbol info. */
void
dll_symbol_command (char *args, int from_tty)
{
  int n;
  dont_repeat ();

  if (args == NULL)
    error (_("dll-symbols requires a file name"));

  n = strlen (args);
  if (n > 4 && strcasecmp (args + n - 4, ".dll") != 0)
    {
      char *newargs = (char *) alloca (n + 4 + 1);
      strcpy (newargs, args);
      strcat (newargs, ".dll");
      args = newargs;
    }

  safe_symbol_file_add (args, from_tty, NULL, 0, OBJF_SHARED | OBJF_USERLOADED);
}

/* Handle DEBUG_STRING output from child process.
   Cygwin prepends its messages with a "cygwin:".  Interpret this as
   a Cygwin signal.  Otherwise just print the string as a warning. */
static int
handle_output_debug_string (struct target_waitstatus *ourstatus)
{
  char *s = NULL;
  int retval = 0;

  if (!target_read_string
	((CORE_ADDR) (uintptr_t) current_event.u.DebugString.lpDebugStringData,
	&s, 1024, 0)
      || !s || !*s)
    /* nothing to do */;
  else if (strncmp (s, _CYGWIN_SIGNAL_STRING, sizeof (_CYGWIN_SIGNAL_STRING) - 1) != 0)
    {
#ifdef __CYGWIN__
      if (strncmp (s, "cYg", 3) != 0)
#endif
	warning (("%s"), s);
    }
#ifdef __COPY_CONTEXT_SIZE
  else
    {
      /* Got a cygwin signal marker.  A cygwin signal is followed by the signal number
	 itself and then optionally followed by the thread id and address to saved context
	 within the DLL.  If these are supplied, then the given thread is assumed to have
	 issued the signal and the context from the thread is assumed to be stored at the
	 given address in the inferior.  Tell gdb to treat this like a real signal.  */
      char *p;
      int sig = strtol (s + sizeof (_CYGWIN_SIGNAL_STRING) - 1, &p, 0);
      int gotasig = target_signal_from_host (sig);
      ourstatus->value.sig = gotasig;
      if (gotasig)
	{
	  LPCVOID x;
	  DWORD n;
	  ourstatus->kind = TARGET_WAITKIND_STOPPED;
	  retval = strtoul (p, &p, 0);
	  if (!retval)
	    retval = main_thread_id;
	  else if ((x = (LPCVOID) strtoul (p, &p, 0))
		   && ReadProcessMemory (current_process_handle, x,
					 &saved_context, __COPY_CONTEXT_SIZE, &n)
		   && n == __COPY_CONTEXT_SIZE)
	    have_saved_context = 1;
	  current_event.dwThreadId = retval;
	}
    }
#endif

  if (s)
    xfree (s);
  return retval;
}

static int
display_selector (HANDLE thread, DWORD sel)
{
  LDT_ENTRY info;
  if (GetThreadSelectorEntry (thread, sel, &info))
    {
      int base, limit;
      printf_filtered ("0x%03lx: ", sel);
      if (!info.HighWord.Bits.Pres)
	{
	  puts_filtered ("Segment not present\n");
	  return 0;
	}
      base = (info.HighWord.Bits.BaseHi << 24) +
	     (info.HighWord.Bits.BaseMid << 16)
	     + info.BaseLow;
      limit = (info.HighWord.Bits.LimitHi << 16) + info.LimitLow;
      if (info.HighWord.Bits.Granularity)
	limit = (limit << 12) | 0xfff;
      printf_filtered ("base=0x%08x limit=0x%08x", base, limit);
      if (info.HighWord.Bits.Default_Big)
	puts_filtered(" 32-bit ");
      else
	puts_filtered(" 16-bit ");
      switch ((info.HighWord.Bits.Type & 0xf) >> 1)
	{
	case 0:
	  puts_filtered ("Data (Read-Only, Exp-up");
	  break;
	case 1:
	  puts_filtered ("Data (Read/Write, Exp-up");
	  break;
	case 2:
	  puts_filtered ("Unused segment (");
	  break;
	case 3:
	  puts_filtered ("Data (Read/Write, Exp-down");
	  break;
	case 4:
	  puts_filtered ("Code (Exec-Only, N.Conf");
	  break;
	case 5:
	  puts_filtered ("Code (Exec/Read, N.Conf");
	  break;
	case 6:
	  puts_filtered ("Code (Exec-Only, Conf");
	  break;
	case 7:
	  puts_filtered ("Code (Exec/Read, Conf");
	  break;
	default:
	  printf_filtered ("Unknown type 0x%x",info.HighWord.Bits.Type);
	}
      if ((info.HighWord.Bits.Type & 0x1) == 0)
	puts_filtered(", N.Acc");
      puts_filtered (")\n");
      if ((info.HighWord.Bits.Type & 0x10) == 0)
	puts_filtered("System selector ");
      printf_filtered ("Priviledge level = %d. ", info.HighWord.Bits.Dpl);
      if (info.HighWord.Bits.Granularity)
	puts_filtered ("Page granular.\n");
      else
	puts_filtered ("Byte granular.\n");
      return 1;
    }
  else
    {
      printf_filtered ("Invalid selector 0x%lx.\n",sel);
      return 0;
    }
}

static void
display_selectors (char * args, int from_tty)
{
  if (!current_thread)
    {
      puts_filtered ("Impossible to display selectors now.\n");
      return;
    }
  if (!args)
    {

      puts_filtered ("Selector $cs\n");
      display_selector (current_thread->h,
	current_thread->context.SegCs);
      puts_filtered ("Selector $ds\n");
      display_selector (current_thread->h,
	current_thread->context.SegDs);
      puts_filtered ("Selector $es\n");
      display_selector (current_thread->h,
	current_thread->context.SegEs);
      puts_filtered ("Selector $ss\n");
      display_selector (current_thread->h,
	current_thread->context.SegSs);
      puts_filtered ("Selector $fs\n");
      display_selector (current_thread->h,
	current_thread->context.SegFs);
      puts_filtered ("Selector $gs\n");
      display_selector (current_thread->h,
	current_thread->context.SegGs);
    }
  else
    {
      int sel;
      sel = parse_and_eval_long (args);
      printf_filtered ("Selector \"%s\"\n",args);
      display_selector (current_thread->h, sel);
    }
}

static struct cmd_list_element *info_w32_cmdlist = NULL;

static void
info_w32_command (char *args, int from_tty)
{
  help_list (info_w32_cmdlist, "info w32 ", class_info, gdb_stdout);
}


#define DEBUG_EXCEPTION_SIMPLE(x)       if (debug_exceptions) \
  printf_unfiltered ("gdb: Target exception %s at 0x%08lx\n", x, \
          current_event.u.Exception.ExceptionRecord.ExceptionAddress)

static int
handle_exception (struct target_waitstatus *ourstatus)
{
  thread_info *th;
  DWORD code = current_event.u.Exception.ExceptionRecord.ExceptionCode;

  ourstatus->kind = TARGET_WAITKIND_STOPPED;

  /* Record the context of the current thread */
  th = thread_rec (current_event.dwThreadId, -1);

  switch (code)
    {
    case EXCEPTION_ACCESS_VIOLATION:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_ACCESS_VIOLATION");
      ourstatus->value.sig = TARGET_SIGNAL_SEGV;
#ifdef __CYGWIN__
      {
	/* See if the access violation happened within the cygwin DLL itself.  Cygwin uses
	   a kind of exception handling to deal with passed-in invalid addresses. gdb
	   should not treat these as real SEGVs since they will be silently handled by
	   cygwin.  A real SEGV will (theoretically) be caught by cygwin later in the process
	   and will be sent as a cygwin-specific-signal.  So, ignore SEGVs if they show up
	   within the text segment of the DLL itself. */
	char *fn;
	bfd_vma addr = (bfd_vma) (uintptr_t) current_event.u.Exception.
					     ExceptionRecord.ExceptionAddress;
	if ((!cygwin_exceptions && (addr >= cygwin_load_start && addr < cygwin_load_end))
	    || (find_pc_partial_function (addr, &fn, NULL, NULL)
		&& strncmp (fn, "KERNEL32!IsBad", strlen ("KERNEL32!IsBad")) == 0))
	  return 0;
      }
#endif
      break;
    case STATUS_STACK_OVERFLOW:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_STACK_OVERFLOW");
      ourstatus->value.sig = TARGET_SIGNAL_SEGV;
      break;
    case STATUS_FLOAT_DENORMAL_OPERAND:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_DENORMAL_OPERAND");
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_ARRAY_BOUNDS_EXCEEDED");
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_INEXACT_RESULT");
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_INVALID_OPERATION:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_INVALID_OPERATION");
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_OVERFLOW:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_OVERFLOW");
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_STACK_CHECK:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_STACK_CHECK");
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_UNDERFLOW:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_UNDERFLOW");
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_FLOAT_DIVIDE_BY_ZERO");
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_INTEGER_DIVIDE_BY_ZERO");
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_INTEGER_OVERFLOW:
      DEBUG_EXCEPTION_SIMPLE ("STATUS_INTEGER_OVERFLOW");
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case EXCEPTION_BREAKPOINT:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_BREAKPOINT");
      ourstatus->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case DBG_CONTROL_C:
      DEBUG_EXCEPTION_SIMPLE ("DBG_CONTROL_C");
      ourstatus->value.sig = TARGET_SIGNAL_INT;
      break;
    case DBG_CONTROL_BREAK:
      DEBUG_EXCEPTION_SIMPLE ("DBG_CONTROL_BREAK");
      ourstatus->value.sig = TARGET_SIGNAL_INT;
      break;
    case EXCEPTION_SINGLE_STEP:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_SINGLE_STEP");
      ourstatus->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case EXCEPTION_ILLEGAL_INSTRUCTION:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_ILLEGAL_INSTRUCTION");
      ourstatus->value.sig = TARGET_SIGNAL_ILL;
      break;
    case EXCEPTION_PRIV_INSTRUCTION:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_PRIV_INSTRUCTION");
      ourstatus->value.sig = TARGET_SIGNAL_ILL;
      break;
    case EXCEPTION_NONCONTINUABLE_EXCEPTION:
      DEBUG_EXCEPTION_SIMPLE ("EXCEPTION_NONCONTINUABLE_EXCEPTION");
      ourstatus->value.sig = TARGET_SIGNAL_ILL;
      break;
    default:
      /* Treat unhandled first chance exceptions specially. */
      if (current_event.u.Exception.dwFirstChance)
	return -1;
      printf_unfiltered ("gdb: unknown target exception 0x%08lx at 0x%08lx\n",
		    current_event.u.Exception.ExceptionRecord.ExceptionCode,
	        current_event.u.Exception.ExceptionRecord.ExceptionAddress);
      ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
      break;
    }
  exception_count++;
  last_sig = ourstatus->value.sig;
  return 1;
}

/* Resume all artificially suspended threads if we are continuing
   execution */
static BOOL
win32_continue (DWORD continue_status, int id)
{
  int i;
  thread_info *th;
  BOOL res;

  DEBUG_EVENTS (("ContinueDebugEvent (cpid=%ld, ctid=%ld, %s);\n",
		  current_event.dwProcessId, current_event.dwThreadId,
		  continue_status == DBG_CONTINUE ?
		  "DBG_CONTINUE" : "DBG_EXCEPTION_NOT_HANDLED"));

  for (th = &thread_head; (th = th->next) != NULL;)
    if ((id == -1 || id == (int) th->id)
	&& th->suspended)
      {
	if (debug_registers_changed)
	  {
	    th->context.ContextFlags |= CONTEXT_DEBUG_REGISTERS;
	    th->context.Dr0 = dr[0];
	    th->context.Dr1 = dr[1];
	    th->context.Dr2 = dr[2];
	    th->context.Dr3 = dr[3];
	    th->context.Dr6 = DR6_CLEAR_VALUE;
	    th->context.Dr7 = dr[7];
	  }
	if (th->context.ContextFlags)
	  {
	    CHECK (SetThreadContext (th->h, &th->context));
	    th->context.ContextFlags = 0;
	  }
	if (th->suspended > 0)
	  (void) ResumeThread (th->h);
	th->suspended = 0;
      }

  res = ContinueDebugEvent (current_event.dwProcessId,
			    current_event.dwThreadId,
			    continue_status);

  debug_registers_changed = 0;
  return res;
}

/* Called in pathological case where Windows fails to send a
   CREATE_PROCESS_DEBUG_EVENT after an attach.  */
static DWORD
fake_create_process (void)
{
  current_process_handle = OpenProcess (PROCESS_ALL_ACCESS, FALSE,
					current_event.dwProcessId);
  if (current_process_handle != NULL)
    open_process_used = 1;
  else
    {
      error (_("OpenProcess call failed, GetLastError = %lud\n"),
       GetLastError ());
      /*  We can not debug anything in that case.  */
    }
  main_thread_id = current_event.dwThreadId;
  current_thread = win32_add_thread (ptid_build (current_event.dwProcessId, 0,
						 current_event.dwThreadId),
				     current_event.u.CreateThread.hThread);
  return main_thread_id;
}

static void
win32_resume (ptid_t ptid, int step, enum target_signal sig)
{
  thread_info *th;
  DWORD continue_status = DBG_CONTINUE;

  /* A specific PTID means `step only this thread id'.  */
  int resume_all = ptid_equal (ptid, minus_one_ptid);

  /* If we're continuing all threads, it's the current inferior that
     should be handled specially.  */
  if (resume_all)
    ptid = inferior_ptid;

  if (sig != TARGET_SIGNAL_0)
    {
      if (current_event.dwDebugEventCode != EXCEPTION_DEBUG_EVENT)
	{
	  DEBUG_EXCEPT(("Cannot continue with signal %d here.\n",sig));
	}
      else if (sig == last_sig)
	continue_status = DBG_EXCEPTION_NOT_HANDLED;
      else
#if 0
/* This code does not seem to work, because
  the kernel does probably not consider changes in the ExceptionRecord
  structure when passing the exception to the inferior.
  Note that this seems possible in the exception handler itself.  */
	{
	  int i;
	  for (i = 0; xlate[i].them != -1; i++)
	    if (xlate[i].us == sig)
	      {
		current_event.u.Exception.ExceptionRecord.ExceptionCode =
		  xlate[i].them;
		continue_status = DBG_EXCEPTION_NOT_HANDLED;
		break;
	      }
	  if (continue_status == DBG_CONTINUE)
	    {
	      DEBUG_EXCEPT(("Cannot continue with signal %d.\n",sig));
	    }
	}
#endif
	DEBUG_EXCEPT(("Can only continue with recieved signal %d.\n",
	  last_sig));
    }

  last_sig = TARGET_SIGNAL_0;

  DEBUG_EXEC (("gdb: win32_resume (pid=%d, tid=%ld, step=%d, sig=%d);\n",
	       ptid_get_pid (ptid), ptid_get_tid (ptid), step, sig));

  /* Get context for currently selected thread */
  th = thread_rec (ptid_get_tid (inferior_ptid), FALSE);
  if (th)
    {
      if (step)
	{
	  /* Single step by setting t bit */
	  win32_fetch_inferior_registers (get_current_regcache (),
					  gdbarch_ps_regnum (current_gdbarch));
	  th->context.EFlags |= FLAG_TRACE_BIT;
	}

      if (th->context.ContextFlags)
	{
	  if (debug_registers_changed)
	    {
	      th->context.Dr0 = dr[0];
	      th->context.Dr1 = dr[1];
	      th->context.Dr2 = dr[2];
	      th->context.Dr3 = dr[3];
	      th->context.Dr6 = DR6_CLEAR_VALUE;
	      th->context.Dr7 = dr[7];
	    }
	  CHECK (SetThreadContext (th->h, &th->context));
	  th->context.ContextFlags = 0;
	}
    }

  /* Allow continuing with the same signal that interrupted us.
     Otherwise complain. */

  if (resume_all)
    win32_continue (continue_status, -1);
  else
    win32_continue (continue_status, ptid_get_tid (ptid));
}

/* Get the next event from the child.  Return 1 if the event requires
   handling by WFI (or whatever).
 */
static int
get_win32_debug_event (int pid, struct target_waitstatus *ourstatus)
{
  BOOL debug_event;
  DWORD continue_status, event_code;
  thread_info *th;
  static thread_info dummy_thread_info;
  int retval = 0;

  last_sig = TARGET_SIGNAL_0;

  if (!(debug_event = WaitForDebugEvent (&current_event, 1000)))
    goto out;

  event_count++;
  continue_status = DBG_CONTINUE;

  event_code = current_event.dwDebugEventCode;
  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
  th = NULL;
  have_saved_context = 0;

  switch (event_code)
    {
    case CREATE_THREAD_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "CREATE_THREAD_DEBUG_EVENT"));
      if (saw_create != 1)
	{
	  struct inferior *inf;
	  inf = find_inferior_pid (current_event.dwProcessId);
	  if (!saw_create && inf->attach_flag)
	    {
	      /* Kludge around a Windows bug where first event is a create
		 thread event.  Caused when attached process does not have
		 a main thread. */
	      retval = fake_create_process ();
	      if (retval)
		saw_create++;
	    }
	  break;
	}
      /* Record the existence of this thread */
      retval = current_event.dwThreadId;
      th = win32_add_thread (ptid_build (current_event.dwProcessId, 0,
					 current_event.dwThreadId),
			     current_event.u.CreateThread.hThread);
      break;

    case EXIT_THREAD_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXIT_THREAD_DEBUG_EVENT"));
      if (current_event.dwThreadId != main_thread_id)
	{
	  win32_delete_thread (ptid_build (current_event.dwProcessId, 0,
					   current_event.dwThreadId));
	  th = &dummy_thread_info;
	}
      break;

    case CREATE_PROCESS_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "CREATE_PROCESS_DEBUG_EVENT"));
      CloseHandle (current_event.u.CreateProcessInfo.hFile);
      if (++saw_create != 1)
	break;

      current_process_handle = current_event.u.CreateProcessInfo.hProcess;
      if (main_thread_id)
 	win32_delete_thread (ptid_build (current_event.dwProcessId, 0,
					 main_thread_id));
      main_thread_id = current_event.dwThreadId;
      /* Add the main thread */
      th = win32_add_thread (ptid_build (current_event.dwProcessId, 0,
					 current_event.dwThreadId),
			     current_event.u.CreateProcessInfo.hThread);
      retval = current_event.dwThreadId;
      break;

    case EXIT_PROCESS_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXIT_PROCESS_DEBUG_EVENT"));
      if (saw_create != 1)
	break;
      ourstatus->kind = TARGET_WAITKIND_EXITED;
      ourstatus->value.integer = current_event.u.ExitProcess.dwExitCode;
      retval = main_thread_id;
      break;

    case LOAD_DLL_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "LOAD_DLL_DEBUG_EVENT"));
      CloseHandle (current_event.u.LoadDll.hFile);
      if (saw_create != 1)
	break;
      catch_errors (handle_load_dll, NULL, (char *) "", RETURN_MASK_ALL);
      ourstatus->kind = TARGET_WAITKIND_LOADED;
      ourstatus->value.integer = 0;
      retval = main_thread_id;
      break;

    case UNLOAD_DLL_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "UNLOAD_DLL_DEBUG_EVENT"));
      if (saw_create != 1)
	break;
      catch_errors (handle_unload_dll, NULL, (char *) "", RETURN_MASK_ALL);
      ourstatus->kind = TARGET_WAITKIND_LOADED;
      ourstatus->value.integer = 0;
      retval = main_thread_id;
      break;

    case EXCEPTION_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXCEPTION_DEBUG_EVENT"));
      if (saw_create != 1)
	break;
      switch (handle_exception (ourstatus))
	{
	case 0:
	  continue_status = DBG_EXCEPTION_NOT_HANDLED;
	  break;
	case 1:
	  retval = current_event.dwThreadId;
	  break;
	case -1:
	  last_sig = 1;
	  continue_status = -1;
	  break;
	}
      break;

    case OUTPUT_DEBUG_STRING_EVENT:	/* message from the kernel */
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "OUTPUT_DEBUG_STRING_EVENT"));
      if (saw_create != 1)
	break;
      retval = handle_output_debug_string (ourstatus);
      break;

    default:
      if (saw_create != 1)
	break;
      printf_unfiltered ("gdb: kernel event for pid=%ld tid=%ld\n",
			 (DWORD) current_event.dwProcessId,
			 (DWORD) current_event.dwThreadId);
      printf_unfiltered ("                 unknown event code %ld\n",
			 current_event.dwDebugEventCode);
      break;
    }

  if (!retval || saw_create != 1)
    {
      if (continue_status == -1)
	win32_resume (minus_one_ptid, 0, 1);
      else
	CHECK (win32_continue (continue_status, -1));
    }
  else
    {
      inferior_ptid = ptid_build (current_event.dwProcessId, 0,
				  retval);
      current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
    }

out:
  return retval;
}

/* Wait for interesting events to occur in the target process.  */
static ptid_t
win32_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  int pid = -1;

  target_terminal_ours ();

  /* We loop when we get a non-standard exception rather than return
     with a SPURIOUS because resume can try and step or modify things,
     which needs a current_thread->h.  But some of these exceptions mark
     the birth or death of threads, which mean that the current thread
     isn't necessarily what you think it is. */

  while (1)
    {
      int retval;
      
      /* Ignore CTRL+C signals while waiting for a debug event.
         FIXME: brobecker/2008-05-20: When the user presses CTRL+C while
         the inferior is running, both the inferior and GDB receive the
         associated signal.  If the inferior receives the signal first
         and the delay until GDB receives that signal is sufficiently long,
         GDB can sometimes receive the SIGINT after we have unblocked
         the CTRL+C handler.  This would lead to the debugger to stop
         prematurely while handling the new-thread event that comes
         with the handling of the SIGINT inside the inferior, and then
         stop again immediately when the user tries to resume the execution
         in the inferior.  This is a classic race, and it would be nice
         to find a better solution to that problem.  But in the meantime,
         the current approach already greatly mitigate this issue.  */
      SetConsoleCtrlHandler (NULL, TRUE);
      retval = get_win32_debug_event (pid, ourstatus);
      SetConsoleCtrlHandler (NULL, FALSE);

      if (retval)
	return ptid_build (current_event.dwProcessId, 0, retval);
      else
	{
	  int detach = 0;

	  if (deprecated_ui_loop_hook != NULL)
	    detach = deprecated_ui_loop_hook (0);

	  if (detach)
	    win32_kill_inferior ();
	}
    }
}

static void
do_initial_win32_stuff (struct target_ops *ops, DWORD pid, int attaching)
{
  extern int stop_after_trap;
  int i;
  struct inferior *inf;
  struct thread_info *tp;

  last_sig = TARGET_SIGNAL_0;
  event_count = 0;
  exception_count = 0;
  open_process_used = 0;
  debug_registers_changed = 0;
  debug_registers_used = 0;
  for (i = 0; i < sizeof (dr) / sizeof (dr[0]); i++)
    dr[i] = 0;
#ifdef __CYGWIN__
  cygwin_load_start = cygwin_load_end = 0;
#endif
  current_event.dwProcessId = pid;
  memset (&current_event, 0, sizeof (current_event));
  push_target (ops);
  disable_breakpoints_in_shlibs ();
  win32_clear_solib ();
  clear_proceed_status ();
  init_wait_for_inferior ();

  inf = add_inferior (pid);
  inf->attach_flag = attaching;

  /* Make the new process the current inferior, so terminal handling
     can rely on it.  When attaching, we don't know about any thread
     id here, but that's OK --- nothing should be referencing the
     current thread until we report an event out of win32_wait.  */
  inferior_ptid = pid_to_ptid (pid);

  terminal_init_inferior_with_pgrp (pid);
  target_terminal_inferior ();

  inf->stop_soon = STOP_QUIETLY;
  while (1)
    {
      stop_after_trap = 1;
      wait_for_inferior (0);
      tp = inferior_thread ();
      if (tp->stop_signal != TARGET_SIGNAL_TRAP)
	resume (0, tp->stop_signal);
      else
	break;
    }

  inf->stop_soon = NO_STOP_QUIETLY;
  stop_after_trap = 0;
  return;
}

/* Since Windows XP, detaching from a process is supported by Windows.
   The following code tries loading the appropriate functions dynamically.
   If loading these functions succeeds use them to actually detach from
   the inferior process, otherwise behave as usual, pretending that
   detach has worked. */
static BOOL WINAPI (*kernel32_DebugSetProcessKillOnExit)(BOOL);
static BOOL WINAPI (*kernel32_DebugActiveProcessStop)(DWORD);

static int
has_detach_ability (void)
{
  static HMODULE kernel32 = NULL;

  if (!kernel32)
    kernel32 = LoadLibrary ("kernel32.dll");
  if (kernel32)
    {
      if (!kernel32_DebugSetProcessKillOnExit)
	kernel32_DebugSetProcessKillOnExit =
	  (void *) GetProcAddress (kernel32, "DebugSetProcessKillOnExit");
      if (!kernel32_DebugActiveProcessStop)
	kernel32_DebugActiveProcessStop =
	  (void *) GetProcAddress (kernel32, "DebugActiveProcessStop");
      if (kernel32_DebugSetProcessKillOnExit
	  && kernel32_DebugActiveProcessStop)
	return 1;
    }
  return 0;
}

/* Try to set or remove a user privilege to the current process.  Return -1
   if that fails, the previous setting of that privilege otherwise.

   This code is copied from the Cygwin source code and rearranged to allow
   dynamically loading of the needed symbols from advapi32 which is only
   available on NT/2K/XP. */
static int
set_process_privilege (const char *privilege, BOOL enable)
{
  static HMODULE advapi32 = NULL;
  static BOOL WINAPI (*OpenProcessToken)(HANDLE, DWORD, PHANDLE);
  static BOOL WINAPI (*LookupPrivilegeValue)(LPCSTR, LPCSTR, PLUID);
  static BOOL WINAPI (*AdjustTokenPrivileges)(HANDLE, BOOL, PTOKEN_PRIVILEGES,
					      DWORD, PTOKEN_PRIVILEGES, PDWORD);

  HANDLE token_hdl = NULL;
  LUID restore_priv;
  TOKEN_PRIVILEGES new_priv, orig_priv;
  int ret = -1;
  DWORD size;

  if (GetVersion () >= 0x80000000)  /* No security availbale on 9x/Me */
    return 0;

  if (!advapi32)
    {
      if (!(advapi32 = LoadLibrary ("advapi32.dll")))
	goto out;
      if (!OpenProcessToken)
	OpenProcessToken =
          (void *) GetProcAddress (advapi32, "OpenProcessToken");
      if (!LookupPrivilegeValue)
	LookupPrivilegeValue =
          (void *) GetProcAddress (advapi32, "LookupPrivilegeValueA");
      if (!AdjustTokenPrivileges)
	AdjustTokenPrivileges =
          (void *) GetProcAddress (advapi32, "AdjustTokenPrivileges");
      if (!OpenProcessToken || !LookupPrivilegeValue || !AdjustTokenPrivileges)
	{
	  advapi32 = NULL;
	  goto out;
	}
    }

  if (!OpenProcessToken (GetCurrentProcess (),
			 TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			 &token_hdl))
    goto out;

  if (!LookupPrivilegeValue (NULL, privilege, &restore_priv))
    goto out;

  new_priv.PrivilegeCount = 1;
  new_priv.Privileges[0].Luid = restore_priv;
  new_priv.Privileges[0].Attributes = enable ? SE_PRIVILEGE_ENABLED : 0;

  if (!AdjustTokenPrivileges (token_hdl, FALSE, &new_priv,
			      sizeof orig_priv, &orig_priv, &size))
    goto out;
#if 0
  /* Disabled, otherwise every `attach' in an unprivileged user session
     would raise the "Failed to get SE_DEBUG_NAME privilege" warning in
     win32_attach(). */
  /* AdjustTokenPrivileges returns TRUE even if the privilege could not
     be enabled. GetLastError () returns an correct error code, though. */
  if (enable && GetLastError () == ERROR_NOT_ALL_ASSIGNED)
    goto out;
#endif

  ret = orig_priv.Privileges[0].Attributes == SE_PRIVILEGE_ENABLED ? 1 : 0;

out:
  if (token_hdl)
    CloseHandle (token_hdl);

  return ret;
}

/* Attach to process PID, then initialize for debugging it.  */
static void
win32_attach (struct target_ops *ops, char *args, int from_tty)
{
  BOOL ok;
  DWORD pid;

  if (!args)
    error_no_arg (_("process-id to attach"));

  if (set_process_privilege (SE_DEBUG_NAME, TRUE) < 0)
    {
      printf_unfiltered ("Warning: Failed to get SE_DEBUG_NAME privilege\n");
      printf_unfiltered ("This can cause attach to fail on Windows NT/2K/XP\n");
    }

  pid = strtoul (args, 0, 0);		/* Windows pid */

  win32_init_thread_list ();
  ok = DebugActiveProcess (pid);
  saw_create = 0;

#ifdef __CYGWIN__
  if (!ok)
    {
      /* Try fall back to Cygwin pid */
      pid = cygwin_internal (CW_CYGWIN_PID_TO_WINPID, pid);

      if (pid > 0)
	ok = DebugActiveProcess (pid);
  }
#endif

  if (!ok)
    error (_("Can't attach to process."));

  if (has_detach_ability ())
    kernel32_DebugSetProcessKillOnExit (FALSE);

  if (from_tty)
    {
      char *exec_file = (char *) get_exec_file (0);

      if (exec_file)
	printf_unfiltered ("Attaching to program `%s', %s\n", exec_file,
			   target_pid_to_str (pid_to_ptid (pid)));
      else
	printf_unfiltered ("Attaching to %s\n",
			   target_pid_to_str (pid_to_ptid (pid)));

      gdb_flush (gdb_stdout);
    }

  do_initial_win32_stuff (ops, pid, 1);
  target_terminal_ours ();
}

static void
win32_detach (struct target_ops *ops, char *args, int from_tty)
{
  int detached = 1;

  if (has_detach_ability ())
    {
      ptid_t ptid = {-1};
      win32_resume (ptid, 0, TARGET_SIGNAL_0);

      if (!kernel32_DebugActiveProcessStop (current_event.dwProcessId))
	{
	  error (_("Can't detach process %lu (error %lu)"),
		 current_event.dwProcessId, GetLastError ());
	  detached = 0;
	}
      kernel32_DebugSetProcessKillOnExit (FALSE);
    }
  if (detached && from_tty)
    {
      char *exec_file = get_exec_file (0);
      if (exec_file == 0)
	exec_file = "";
      printf_unfiltered ("Detaching from program: %s, Pid %lu\n", exec_file,
			 current_event.dwProcessId);
      gdb_flush (gdb_stdout);
    }

  inferior_ptid = null_ptid;
  detach_inferior (current_event.dwProcessId);

  unpush_target (ops);
}

static char *
win32_pid_to_exec_file (int pid)
{
  static char path[MAX_PATH + 1];

#ifdef __CYGWIN__
  /* Try to find exe name as symlink target of /proc/<pid>/exe */
  int nchars;
  char procexe[sizeof ("/proc/4294967295/exe")];
  sprintf (procexe, "/proc/%u/exe", pid);
  nchars = readlink (procexe, path, sizeof(path));
  if (nchars > 0 && nchars < sizeof (path))
    {
      path[nchars] = '\0';	/* Got it */
      return path;
    }
#endif

  /* If we get here then either Cygwin is hosed, this isn't a Cygwin version
     of gdb, or we're trying to debug a non-Cygwin windows executable. */
  if (!get_module_name (0, path))
    path[0] = '\0';

  return path;
}

/* Print status information about what we're accessing.  */

static void
win32_files_info (struct target_ops *ignore)
{
  struct inferior *inf = current_inferior ();

  printf_unfiltered ("\tUsing the running image of %s %s.\n",
		     inf->attach_flag ? "attached" : "child",
		     target_pid_to_str (inferior_ptid));
}

static void
win32_open (char *arg, int from_tty)
{
  error (_("Use the \"run\" command to start a Unix child process."));
}

/* Start an inferior win32 child process and sets inferior_ptid to its pid.
   EXEC_FILE is the file to run.
   ALLARGS is a string containing the arguments to the program.
   ENV is the environment vector to pass.  Errors reported with error().  */

static void
win32_create_inferior (struct target_ops *ops, char *exec_file,
		       char *allargs, char **in_env, int from_tty)
{
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  BOOL ret;
  DWORD flags;
  char *args;
  char real_path[MAXPATHLEN];
  char *toexec;
  char shell[MAX_PATH + 1]; /* Path to shell */
  const char *sh;
  int tty;
  int ostdin, ostdout, ostderr;
  const char *inferior_io_terminal = get_inferior_io_terminal ();

  if (!exec_file)
    error (_("No executable specified, use `target exec'."));

  memset (&si, 0, sizeof (si));
  si.cb = sizeof (si);

#ifdef __CYGWIN__
  if (!useshell)
    {
      flags = DEBUG_ONLY_THIS_PROCESS;
      cygwin_conv_to_win32_path (exec_file, real_path);
      toexec = real_path;
    }
  else
    {
      char *newallargs;
      sh = getenv ("SHELL");
      if (!sh)
	sh = "/bin/sh";
      cygwin_conv_to_win32_path (sh, shell);
      newallargs = alloca (sizeof (" -c 'exec  '") + strlen (exec_file)
			   + strlen (allargs) + 2);
      sprintf (newallargs, " -c 'exec %s %s'", exec_file, allargs);
      allargs = newallargs;
      toexec = shell;
      flags = DEBUG_PROCESS;
    }
#else
  toexec = exec_file;
  flags = DEBUG_ONLY_THIS_PROCESS;
#endif

  if (new_group)
    flags |= CREATE_NEW_PROCESS_GROUP;

  if (new_console)
    flags |= CREATE_NEW_CONSOLE;

  args = alloca (strlen (toexec) + strlen (allargs) + 2);
  strcpy (args, toexec);
  strcat (args, " ");
  strcat (args, allargs);

#ifdef __CYGWIN__
  /* Prepare the environment vars for CreateProcess.  */
  cygwin_internal (CW_SYNC_WINENV);

  if (!inferior_io_terminal)
    tty = ostdin = ostdout = ostderr = -1;
  else
    {
      tty = open (inferior_io_terminal, O_RDWR | O_NOCTTY);
      if (tty < 0)
	{
	  print_sys_errmsg (inferior_io_terminal, errno);
	  ostdin = ostdout = ostderr = -1;
	}
      else
	{
	  ostdin = dup (0);
	  ostdout = dup (1);
	  ostderr = dup (2);
	  dup2 (tty, 0);
	  dup2 (tty, 1);
	  dup2 (tty, 2);
	}
    }
#endif

  win32_init_thread_list ();
  ret = CreateProcess (0,
		       args,	/* command line */
		       NULL,	/* Security */
		       NULL,	/* thread */
		       TRUE,	/* inherit handles */
		       flags,	/* start flags */
		       NULL,	/* environment */
		       NULL,	/* current directory */
		       &si,
		       &pi);

#ifdef __CYGWIN__
  if (tty >= 0)
    {
      close (tty);
      dup2 (ostdin, 0);
      dup2 (ostdout, 1);
      dup2 (ostderr, 2);
      close (ostdin);
      close (ostdout);
      close (ostderr);
    }
#endif

  if (!ret)
    error (_("Error creating process %s, (error %d)."),
	   exec_file, (unsigned) GetLastError ());

  CloseHandle (pi.hThread);
  CloseHandle (pi.hProcess);

  if (useshell && shell[0] != '\0')
    saw_create = -1;
  else
    saw_create = 0;

  do_initial_win32_stuff (ops, pi.dwProcessId, 0);

  /* win32_continue (DBG_CONTINUE, -1); */
}

static void
win32_mourn_inferior (struct target_ops *ops)
{
  (void) win32_continue (DBG_CONTINUE, -1);
  i386_cleanup_dregs();
  if (open_process_used)
    {
      CHECK (CloseHandle (current_process_handle));
      open_process_used = 0;
    }
  unpush_target (ops);
  generic_mourn_inferior ();
}

/* Send a SIGINT to the process group.  This acts just like the user typed a
   ^C on the controlling terminal. */

static void
win32_stop (ptid_t ptid)
{
  DEBUG_EVENTS (("gdb: GenerateConsoleCtrlEvent (CTRLC_EVENT, 0)\n"));
  CHECK (GenerateConsoleCtrlEvent (CTRL_C_EVENT, current_event.dwProcessId));
  registers_changed ();		/* refresh register state */
}

static int
win32_xfer_memory (CORE_ADDR memaddr, gdb_byte *our, int len,
		   int write, struct mem_attrib *mem,
		   struct target_ops *target)
{
  SIZE_T done = 0;
  if (write)
    {
      DEBUG_MEM (("gdb: write target memory, %d bytes at 0x%08lx\n",
		  len, (DWORD) (uintptr_t) memaddr));
      if (!WriteProcessMemory (current_process_handle, 
			       (LPVOID) (uintptr_t) memaddr, our,
			       len, &done))
	done = 0;
      FlushInstructionCache (current_process_handle, 
			     (LPCVOID) (uintptr_t) memaddr, len);
    }
  else
    {
      DEBUG_MEM (("gdb: read target memory, %d bytes at 0x%08lx\n",
		  len, (DWORD) (uintptr_t) memaddr));
      if (!ReadProcessMemory (current_process_handle, 
			      (LPCVOID) (uintptr_t) memaddr, our,
			      len, &done))
	done = 0;
    }
  return done;
}

static void
win32_kill_inferior (void)
{
  CHECK (TerminateProcess (current_process_handle, 0));

  for (;;)
    {
      if (!win32_continue (DBG_CONTINUE, -1))
	break;
      if (!WaitForDebugEvent (&current_event, INFINITE))
	break;
      if (current_event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)
	break;
    }

  target_mourn_inferior ();	/* or just win32_mourn_inferior? */
}

static void
win32_prepare_to_store (struct regcache *regcache)
{
  /* Do nothing, since we can store individual regs */
}

static int
win32_can_run (void)
{
  return 1;
}

static void
win32_close (int x)
{
  DEBUG_EVENTS (("gdb: win32_close, inferior_ptid=%d\n",
		PIDGET (inferior_ptid)));
}

/* Convert pid to printable format. */
static char *
win32_pid_to_str (ptid_t ptid)
{
  static char buf[80];

  if (ptid_get_tid (ptid) != 0)
    {
      snprintf (buf, sizeof (buf), "Thread %d.0x%lx",
		ptid_get_pid (ptid), ptid_get_tid (ptid));
      return buf;
    }

  return normal_pid_to_str (ptid);
}

static LONGEST
win32_xfer_shared_libraries (struct target_ops *ops,
			     enum target_object object, const char *annex,
			     gdb_byte *readbuf, const gdb_byte *writebuf,
			     ULONGEST offset, LONGEST len)
{
  struct obstack obstack;
  const char *buf;
  LONGEST len_avail;
  struct so_list *so;

  if (writebuf)
    return -1;

  obstack_init (&obstack);
  obstack_grow_str (&obstack, "<library-list>\n");
  for (so = solib_start.next; so; so = so->next)
    win32_xfer_shared_library (so->so_name, (CORE_ADDR) so->lm_info->load_addr,
                               &obstack);
  obstack_grow_str0 (&obstack, "</library-list>\n");

  buf = obstack_finish (&obstack);
  len_avail = strlen (buf);
  if (offset >= len_avail)
    return 0;

  if (len > len_avail - offset)
    len = len_avail - offset;
  memcpy (readbuf, buf + offset, len);

  obstack_free (&obstack, NULL);
  return len;
}

static LONGEST
win32_xfer_partial (struct target_ops *ops, enum target_object object,
		    const char *annex, gdb_byte *readbuf,
		    const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
{
  switch (object)
    {
    case TARGET_OBJECT_MEMORY:
      if (readbuf)
	return (*ops->deprecated_xfer_memory) (offset, readbuf,
					       len, 0/*read*/, NULL, ops);
      if (writebuf)
	return (*ops->deprecated_xfer_memory) (offset, (gdb_byte *) writebuf,
					       len, 1/*write*/, NULL, ops);
      return -1;

    case TARGET_OBJECT_LIBRARIES:
      return win32_xfer_shared_libraries (ops, object, annex, readbuf,
					  writebuf, offset, len);

    default:
      if (ops->beneath != NULL)
	return ops->beneath->to_xfer_partial (ops->beneath, object, annex,
					      readbuf, writebuf, offset, len);
      return -1;
    }
}

static void
init_win32_ops (void)
{
  win32_ops.to_shortname = "child";
  win32_ops.to_longname = "Win32 child process";
  win32_ops.to_doc = "Win32 child process (started by the \"run\" command).";
  win32_ops.to_open = win32_open;
  win32_ops.to_close = win32_close;
  win32_ops.to_attach = win32_attach;
  win32_ops.to_attach_no_wait = 1;
  win32_ops.to_detach = win32_detach;
  win32_ops.to_resume = win32_resume;
  win32_ops.to_wait = win32_wait;
  win32_ops.to_fetch_registers = win32_fetch_inferior_registers;
  win32_ops.to_store_registers = win32_store_inferior_registers;
  win32_ops.to_prepare_to_store = win32_prepare_to_store;
  win32_ops.deprecated_xfer_memory = win32_xfer_memory;
  win32_ops.to_xfer_partial = win32_xfer_partial;
  win32_ops.to_files_info = win32_files_info;
  win32_ops.to_insert_breakpoint = memory_insert_breakpoint;
  win32_ops.to_remove_breakpoint = memory_remove_breakpoint;
  win32_ops.to_terminal_init = terminal_init_inferior;
  win32_ops.to_terminal_inferior = terminal_inferior;
  win32_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  win32_ops.to_terminal_ours = terminal_ours;
  win32_ops.to_terminal_save_ours = terminal_save_ours;
  win32_ops.to_terminal_info = child_terminal_info;
  win32_ops.to_kill = win32_kill_inferior;
  win32_ops.to_create_inferior = win32_create_inferior;
  win32_ops.to_mourn_inferior = win32_mourn_inferior;
  win32_ops.to_can_run = win32_can_run;
  win32_ops.to_thread_alive = win32_win32_thread_alive;
  win32_ops.to_pid_to_str = win32_pid_to_str;
  win32_ops.to_stop = win32_stop;
  win32_ops.to_stratum = process_stratum;
  win32_ops.to_has_all_memory = 1;
  win32_ops.to_has_memory = 1;
  win32_ops.to_has_stack = 1;
  win32_ops.to_has_registers = 1;
  win32_ops.to_has_execution = 1;
  win32_ops.to_pid_to_exec_file = win32_pid_to_exec_file;
  win32_ops.to_magic = OPS_MAGIC;
}

static void
set_win32_aliases (char *argv0)
{
  add_info_alias ("dll", "sharedlibrary", 1);
}

void
_initialize_win32_nat (void)
{
  struct cmd_list_element *c;

  init_win32_ops ();

  c = add_com ("dll-symbols", class_files, dll_symbol_command,
	       _("Load dll library symbols from FILE."));
  set_cmd_completer (c, filename_completer);

  add_com_alias ("sharedlibrary", "dll-symbols", class_alias, 1);

#ifdef __CYGWIN__
  add_setshow_boolean_cmd ("shell", class_support, &useshell, _("\
Set use of shell to start subprocess."), _("\
Show use of shell to start subprocess."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("cygwin-exceptions", class_support, &cygwin_exceptions, _("\
Break when an exception is detected in the Cygwin DLL itself."), _("\
Show whether gdb breaks on exceptions in the Cygwin DLL itself."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);
#endif

  add_setshow_boolean_cmd ("new-console", class_support, &new_console, _("\
Set creation of new console when creating child process."), _("\
Show creation of new console when creating child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("new-group", class_support, &new_group, _("\
Set creation of new group when creating child process."), _("\
Show creation of new group when creating child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("debugexec", class_support, &debug_exec, _("\
Set whether to display execution in child process."), _("\
Show whether to display execution in child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("debugevents", class_support, &debug_events, _("\
Set whether to display kernel events in child process."), _("\
Show whether to display kernel events in child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("debugmemory", class_support, &debug_memory, _("\
Set whether to display memory accesses in child process."), _("\
Show whether to display memory accesses in child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("debugexceptions", class_support,
			   &debug_exceptions, _("\
Set whether to display kernel exceptions in child process."), _("\
Show whether to display kernel exceptions in child process."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

  add_prefix_cmd ("w32", class_info, info_w32_command,
		  _("Print information specific to Win32 debugging."),
		  &info_w32_cmdlist, "info w32 ", 0, &infolist);

  add_cmd ("selector", class_info, display_selectors,
	   _("Display selectors infos."),
	   &info_w32_cmdlist);
  add_target (&win32_ops);
  deprecated_init_ui_hook = set_win32_aliases;
}

/* Hardware watchpoint support, adapted from go32-nat.c code.  */

/* Pass the address ADDR to the inferior in the I'th debug register.
   Here we just store the address in dr array, the registers will be
   actually set up when win32_continue is called.  */
void
cygwin_set_dr (int i, CORE_ADDR addr)
{
  if (i < 0 || i > 3)
    internal_error (__FILE__, __LINE__,
		    _("Invalid register %d in cygwin_set_dr.\n"), i);
  dr[i] = (unsigned) addr;
  debug_registers_changed = 1;
  debug_registers_used = 1;
}

/* Pass the value VAL to the inferior in the DR7 debug control
   register.  Here we just store the address in D_REGS, the watchpoint
   will be actually set up in win32_wait.  */
void
cygwin_set_dr7 (unsigned val)
{
  dr[7] = val;
  debug_registers_changed = 1;
  debug_registers_used = 1;
}

/* Get the value of the DR6 debug status register from the inferior.
   Here we just return the value stored in dr[6]
   by the last call to thread_rec for current_event.dwThreadId id.  */
unsigned
cygwin_get_dr6 (void)
{
  return dr[6];
}

/* Determine if the thread referenced by "ptid" is alive
   by "polling" it.  If WaitForSingleObject returns WAIT_OBJECT_0
   it means that the thread has died.  Otherwise it is assumed to be alive. */
static int
win32_win32_thread_alive (ptid_t ptid)
{
  int tid;

  gdb_assert (ptid_get_tid (ptid) != 0);
  tid = ptid_get_tid (ptid);

  return WaitForSingleObject (thread_rec (tid, FALSE)->h, 0) == WAIT_OBJECT_0 ?
    FALSE : TRUE;
}

void
_initialize_check_for_gdb_ini (void)
{
  char *homedir;
  if (inhibit_gdbinit)
    return;

  homedir = getenv ("HOME");
  if (homedir)
    {
      char *p;
      char *oldini = (char *) alloca (strlen (homedir) +
				      sizeof ("/gdb.ini"));
      strcpy (oldini, homedir);
      p = strchr (oldini, '\0');
      if (p > oldini && p[-1] != '/')
	*p++ = '/';
      strcpy (p, "gdb.ini");
      if (access (oldini, 0) == 0)
	{
	  int len = strlen (oldini);
	  char *newini = alloca (len + 1);
	  sprintf (newini, "%.*s.gdbinit",
	    (int) (len - (sizeof ("gdb.ini") - 1)), oldini);
	  warning (_("obsolete '%s' found. Rename to '%s'."), oldini, newini);
	}
    }
}

void
_initialize_psapi (void)
{
  /* Load optional functions used for retrieving filename information
     associated with the currently debugged process or its dlls. */
  if (!psapi_loaded)
    {
      HMODULE psapi_module_handle;

      psapi_loaded = -1;

      psapi_module_handle = LoadLibrary ("psapi.dll");
      if (psapi_module_handle)
	{
	  psapi_EnumProcessModules = (void *) GetProcAddress (psapi_module_handle, "EnumProcessModules");
	  psapi_GetModuleInformation = (void *) GetProcAddress (psapi_module_handle, "GetModuleInformation");
	  psapi_GetModuleFileNameExA = (void *) GetProcAddress (psapi_module_handle, "GetModuleFileNameExA");

	  if (psapi_EnumProcessModules != NULL
	      && psapi_GetModuleInformation != NULL
	      && psapi_GetModuleFileNameExA != NULL)
	    psapi_loaded = 1;
	}
    }

  /* This will probably fail on Windows 9x/Me.  Let the user know that we're
     missing some functionality. */
  if (psapi_loaded < 0)
    warning(_("cannot automatically find executable file or library to read symbols.  Use \"file\" or \"dll\" command to load executable/libraries directly."));
}
@


1.175
log
@        * win32-tdep.h, win32-tdep.c: New files.
        * i386-cygwin-tdep.h: Delete.
        * i386-cygwin-tdep.c: Include win32-tdep.h instead of
        i386-cygwin-tdep.h.
        (win32_xfer_shared_library): Delete.  Moved to win32-tdep.c.
        * win32-nat.c: Likewise.
        * configure.tgt: Add win32-tdep.o to the list of target object
        files for i386-cygwin and i386-mingw targets.
@
text
@@


1.174
log
@        * win32-nat.h: New file.
        * win32-nat.c (mappings): Initialize to NULL.
        (win32_set_context_register_offsets): New function.
        * i386-windows-nat.c: New file.
        (mappings): Moved here from win32-nat.c.
        (_initialize_i386_windows_nat): New function.
        * config/i386/mingw.mh (NATDEPFILES): Add i386-windows-nat.o.
        * config/i386/cygwin.mh (NATDEPFILES): Likewise.
@
text
@d63 1
a63 1
#include "i386-cygwin-tdep.h"
@


1.173
log
@        * win32-nat.c (get_module_name): Change the type of parameter
        "base_address" to LPVOID.  Remove unnecessary cast.
        (struct lm_info): Change type of load_addr to LPVOID.
        (win32_make_so): Change the type of parameter "load_addr"
        to LPVOID.  Remove some unnecessary casts.
        (handle_unload_dll): Change the type of "lpBaseOfDll" to LPVOID.
        (win32_xfer_shared_libraries): Add missing cast.
@
text
@d64 1
d165 1
a165 1
/* This vector maps GDB's idea of a register's number into an address
d170 5
d183 1
a183 49
#define context_offset(x) ((int)&(((CONTEXT *)NULL)->x))
static const int mappings[] =
{
  context_offset (Eax),
  context_offset (Ecx),
  context_offset (Edx),
  context_offset (Ebx),
  context_offset (Esp),
  context_offset (Ebp),
  context_offset (Esi),
  context_offset (Edi),
  context_offset (Eip),
  context_offset (EFlags),
  context_offset (SegCs),
  context_offset (SegSs),
  context_offset (SegDs),
  context_offset (SegEs),
  context_offset (SegFs),
  context_offset (SegGs),
  context_offset (FloatSave.RegisterArea[0 * 10]),
  context_offset (FloatSave.RegisterArea[1 * 10]),
  context_offset (FloatSave.RegisterArea[2 * 10]),
  context_offset (FloatSave.RegisterArea[3 * 10]),
  context_offset (FloatSave.RegisterArea[4 * 10]),
  context_offset (FloatSave.RegisterArea[5 * 10]),
  context_offset (FloatSave.RegisterArea[6 * 10]),
  context_offset (FloatSave.RegisterArea[7 * 10]),
  context_offset (FloatSave.ControlWord),
  context_offset (FloatSave.StatusWord),
  context_offset (FloatSave.TagWord),
  context_offset (FloatSave.ErrorSelector),
  context_offset (FloatSave.ErrorOffset),
  context_offset (FloatSave.DataSelector),
  context_offset (FloatSave.DataOffset),
  context_offset (FloatSave.ErrorSelector)
  /* XMM0-7 */ ,
  context_offset (ExtendedRegisters[10*16]),
  context_offset (ExtendedRegisters[11*16]),
  context_offset (ExtendedRegisters[12*16]),
  context_offset (ExtendedRegisters[13*16]),
  context_offset (ExtendedRegisters[14*16]),
  context_offset (ExtendedRegisters[15*16]),
  context_offset (ExtendedRegisters[16*16]),
  context_offset (ExtendedRegisters[17*16]),
  /* MXCSR */
  context_offset (ExtendedRegisters[24])
};

#undef context_offset
d205 9
@


1.172
log
@        * win32-nat.c (has_detach_ability, set_process_privilege):
        Cast the result of GetProcAddress to (void *) to avoid
        a compilation warning.
@
text
@d484 1
a484 1
get_module_name (DWORD base_address, char *dll_name_ret)
d527 1
a527 1
      if (!base_address || (DWORD) (mi.lpBaseOfDll) == base_address)
d563 1
a563 1
  DWORD load_addr;
d622 1
a622 1
win32_make_so (const char *name, DWORD load_addr)
d749 1
a749 1
  if (!get_module_name ((DWORD) event->lpBaseOfDll, dll_buf))
d760 1
a760 1
  solib_end->next = win32_make_so (dll_name, (DWORD) event->lpBaseOfDll);
d764 1
a764 1
		 (DWORD) solib_end->lm_info->load_addr));
d780 1
a780 1
  DWORD lpBaseOfDll = (DWORD) current_event.u.UnloadDll.lpBaseOfDll;
d2085 2
a2086 1
    win32_xfer_shared_library (so->so_name, so->lm_info->load_addr, &obstack);
@


1.171
log
@        * win32-nat.c (CONTEXT_EXTENDED_REGISTERS): Define to 0 if not
        already defined.
@
text
@d1603 2
a1604 2
	kernel32_DebugSetProcessKillOnExit = GetProcAddress (kernel32,
						 "DebugSetProcessKillOnExit");
d1606 2
a1607 2
	kernel32_DebugActiveProcessStop = GetProcAddress (kernel32,
						 "DebugActiveProcessStop");
d1644 2
a1645 1
	OpenProcessToken = GetProcAddress (advapi32, "OpenProcessToken");
d1647 2
a1648 2
	LookupPrivilegeValue = GetProcAddress (advapi32,
					       "LookupPrivilegeValueA");
d1650 2
a1651 2
	AdjustTokenPrivileges = GetProcAddress (advapi32,
						"AdjustTokenPrivileges");
@


1.170
log
@        * win32-nat.c (get_image_name, win32_xfer_memory): Fix type
        definition of local variable "done".
        (info_w32_command, handle_exception): Remove unnecessary cast.
@
text
@d88 6
@


1.169
log
@        * win32-nat.c (kernel32_DebugSetProcessKillOnExit): Renames
        DebugSetProcessKillOnExit.  Update all uses in this file.
        (kernel32_DebugActiveProcessStop): Renames DebugActiveProcessStop.
        Update all uses in this file.
@
text
@d699 1
a699 1
  DWORD done;
d1004 1
a1004 1
  (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress)
d1118 1
a1118 1
	(DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress);
d1984 1
a1984 1
  DWORD done = 0;
@


1.168
log
@        * win32-nat.c (do_initial_win32_stuff): Add new ops parameter,
        and use it when pushing the target.
        (win32_attach, win32_create_inferior): Update call to
        do_initial_win32_stuff.
        (win32_detach, win32_mourn_inferior): Use our ops parameter
        instead of the global win32_ops to unpush the target.
@
text
@d1584 2
a1585 2
static BOOL WINAPI (*DebugSetProcessKillOnExit)(BOOL);
static BOOL WINAPI (*DebugActiveProcessStop)(DWORD);
d1596 2
a1597 2
      if (!DebugSetProcessKillOnExit)
	DebugSetProcessKillOnExit = GetProcAddress (kernel32,
d1599 2
a1600 2
      if (!DebugActiveProcessStop)
	DebugActiveProcessStop = GetProcAddress (kernel32,
d1602 2
a1603 1
      if (DebugSetProcessKillOnExit && DebugActiveProcessStop)
d1723 1
a1723 1
    DebugSetProcessKillOnExit (FALSE);
d1753 1
a1753 1
      if (!DebugActiveProcessStop (current_event.dwProcessId))
d1759 1
a1759 1
      DebugSetProcessKillOnExit (FALSE);
@


1.167
log
@        Updated copyright notices for most files.
@
text
@d1524 1
a1524 1
do_initial_win32_stuff (DWORD pid, int attaching)
d1544 1
a1544 1
  push_target (&win32_ops);
d1738 1
a1738 1
  do_initial_win32_stuff (pid, 1);
d1773 1
a1773 1
  unpush_target (&win32_ops);
d1948 1
a1948 1
  do_initial_win32_stuff (pi.dwProcessId, 0);
d1963 1
a1963 1
  unpush_target (&win32_ops);
@


1.166
log
@	Kill pthread_ops_hack

	* target.h (struct target_ops): Make to_attach, to_detach,
	to_create_inferior and to_mourn_inferior accept a pointer
    	to struct target_ops.
	(target_attach, target_create_inferior, target_create_inferior):
	Convert from macros to function.  Find the right target to
	invoke a method of.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.
	* corefile.c (core_file_command): Pass target to to_detach.
	* corelow.c (core_detach): Add 'ops' parameter.
	* fork-child.c (fork_inferior): Return the pid.  Allow
	init_trace_fun to be NULL.
	* inf-ptrace (ptrace_ops_hack): Remove.
	(inf_ptrace_him): Remove, moving all logic into....
	(inf_ptrace_create_inferior): ... here.  Push the target
	passed as parameter.
	(inf_ptrace_mourn_inferior, inf_ptrace_attach, inf_ptrace_detach):
	Push/pop target passed as parameter, no ptrace_ops_hack.
	(inf_ptrace_target): Don't remember result.
	* inferior.h (fork_inferior): Adjust prototype.
	* linux-nat.c (linux_nat_create_inferior, linux_nat_attach)
	(linux_nat_detach, linux_nat_mourn_inferior): New parameter ops.
	Pass it to linux_ops target.
	* linux-thread-db.c (thread_db_detach, thread_db_mourn_inferior):
	New parameter ops. Pass it to the target beneath.
	* remote.c (remote_mourn, extended_remote_mourn, remote_detach)
	(extended_remote_create_inferior): New parameter ops. Pass it
	further.
	* target.c (debug_to_attach, debug_to_detach)
	(debug_to_mourn_inferior): New parameter ops.
	(target_create_inferior): New.
	(update_current_target): Do not inherit to_attach, to_detach,
	to_create_inferiour, to_mourn_inferior.  Do not default
	to_detach and to_mourn_inferior.
	(target_detach): Find the right target to use.
	(target_mourn_inferior): New.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.  Pass the found target when calling its method.
	(init_dummy_target): Provide fallback definition of to_detach.
	(target_attach): New.
	(debug_to_attach, debug_to_detach, debug_to_create_inferior)
	(debug_to_mourn_inferiour): New parameter ops.
        * aix-thread.c: Adjust.
        * bsd-uthread.c: Adjust.
        * gnu-nat.c: Adjust.
        * go32-nat.c: Adjust.
        * hpux-thread.c: Adjust.
        * inf-ttrace.c: Ajust.
        * monitor.c: Adjust.
        * nto-procfs.c: Adjust.
        * procfs.c: Adjust.
        * remote-m32r-sdi.c: Adjust.
        * remote-mips.c: Adjust.
        * remote-sim.c: Adjust.
        * rs6000-nat.c: Adjust.
        * sol-thread.c: Adjust.
        * win32-nat.c: Adjust.
	* dec-thread.c: Adjust.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.165
log
@	* win32-nat.c (do_initial_win32_stuff): Set inferior_ptid.
@
text
@d1687 1
a1687 1
win32_attach (char *args, int from_tty)
d1743 1
a1743 1
win32_detach (char *args, int from_tty)
d1826 2
a1827 2
win32_create_inferior (char *exec_file, char *allargs, char **in_env,
		       int from_tty)
d1954 1
a1954 1
win32_mourn_inferior (void)
@


1.164
log
@	Remove the attach_flag global, and make it per-inferior.

	* inferior.h (attach_flag): Delete.
	(inferior_process): Declare.
	* solib.c (update_solib_list): Adjust.
	* gnu-nat.c (gnu_create_inferior, gnu_attach): Adjust.
	* inf-ptrace.c (inf_ptrace_detach): Adjust.
	(inf_ptrace_files_info): Get it from the current inferior.
	* inf-ttrace.c (inf_ttrace_attach): Adjust.
	(inf_ttrace_files_info): Get it from the current
	inferior.
	* inflow.c (terminal_inferior, terminal_ours_1, set_sigint_trap)
	(clear_sigint_trap): Get it from the current process.
	* remote.c (extended_remote_attach_1)
	(extended_remote_create_inferior_1): Adjust.
	* top.c (quit_confirm, quit_target): Get it from the current inferior.
	* procfs.c (do_detach): Adjust.
	(procfs_wait): Get it from the event inferior.
	(procfs_files_info): Get it from the current inferior.
	* nto-procfs.c (procfs_files_info): Likewise.
	(procfs_attach): Adjust.  Set the attach_flag here.
	(do_attach): Don't set it here.
	(procfs_detach): Don't clear it.
	(procfs_mourn_inferior): Don't clear it.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* target.c (attach_flag): Delete.
	(generic_mourn_inferior): Don't clear it.
	* win32-nat.c (get_win32_debug_event): Get it from the event
	process.
	(do_initial_win32_stuff): Add attaching argument.  Set attach_flag
	in the inferior accordingly.
	(win32_attach): Don't set the attach_flag here.  Pass 1 to
	do_intial_win32_stuff.
	(win32_files_info): Get it from the current inferior.
	(win32_create_inferior): Dont clear attach_flag here.  Pass 0 to
	do_intial_win32_stuff.
@
text
@d1553 6
@


1.163
log
@	Make the stop_soon global be per-inferior instead.

	* infcmd.c (attach_command_post_wait): Adjust.
	(attach_command): Likewise.

	* inferior.h (stop_soon): Delete.
	(struct inferior): Add stop_soon member.

	* infrun.c (stop_soon): Delete.
	(clear_proceed_status, start_remote)
	(fetch_inferior_event, handle_inferior_event): Adjust.
	(signal_stop_state): Don't check stop_soon here.  Check in callers
	instead.
	(save_inferior_status, restore_inferior_status): Adjust.

	* linux-nat.c (linux_nat_resume, linux_nat_wait): Always pass
	signals to common code if starting up the inferior.

	* inferior.h (struct inferior_info): Added stop_soon member.
	* inferior.c (add_inferior) Clear stop_soon.

	* mips-tdep.c (heuristic_proc_start): Adjust.
	* nto-procfs.c (procfs_create_inferior): Adjust.
	* solib-irix.c (irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Adjust.

	* win32-nat.c (do_initial_win32_stuff): Adjust.

	* alpha-tdep.c (alpha_heuristic_proc_start): Adjust.
@
text
@d1319 3
a1321 1
	  if (!saw_create && attach_flag)
d1327 2
a1328 2
	     if (retval)
	       saw_create++;
d1524 1
a1524 1
do_initial_win32_stuff (DWORD pid)
d1551 1
a1717 2
  attach_flag = 1;

d1732 1
a1732 1
  do_initial_win32_stuff (pid);
d1801 2
d1804 2
a1805 1
      attach_flag ? "attached" : "child", target_pid_to_str (inferior_ptid));
a1873 2
  attach_flag = 0;

d1942 1
a1942 1
  do_initial_win32_stuff (pi.dwProcessId);
@


1.162
log
@	* gnu-nat.c (gnu_attach): Add process to inferiors table.
	(gnu_detach): Remove it.
	* go32-nat.c (go32_create_inferior): Add process to gdb's inferior
	table.
	* inf-ptrace.c (inf_ptrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ptrace_attach): Add new process to inferior table.
	(inf_ptrace_detach): Remove it.
	* inf-ttrace.c (inf_ttrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ttrace_attach): Add process to inferior table.
	(inf_ttrace_detach): Remove it.
	* linux-fork.c (init_fork_list): Delete any left over inferior.
	(linux_fork_mourn_inferior, detach_fork_command): Also delete
	processes from inferior list.
	* monitor.c (monitor_open): Add process to inferior list.
	(monitor_close): Remove it.
	* nto-procfs.c (procfs_attach): Add process to inferior list.
	Find threads after pushing the target.
	(procfs_detach): Remove process from inferior list.
	(procfs_create_inferior): Add process to inferior list.
	* procfs.c (procfs_detach): Remove process from inferior list.
	(do_attach): Add process to inferior list.
	* remote-sim.c (sim_create_inferior): Add process to inferior list.
	(gdbsim_close): Remove it.
	* target.c (generic_mourn_inferior): If inferior_ptid is not
	null_ptid, remove the corresponding inferior from inferior list.
	* win32-nat.c (do_initial_win32_stuff): Add process to inferior list.
	(win32_detach): Remove it.
	* linux-nat.c (linux_child_follow_fork): Delete and add inferiors
	to inferior list accordingly.
	* fork-child.c (fork_inferior): Add process to inferior list.
	* corelow.c (CORELOW_PID): Define.
	(core_close): Remove core from inferior list.
	(core_open): Add it.
@
text
@d1526 1
d1548 1
a1548 1
  add_inferior (pid);
d1553 1
a1553 1
  stop_soon = STOP_QUIETLY;
d1565 1
a1565 1
  stop_soon = NO_STOP_QUIETLY;
@


1.161
log
@	Remove the global stop_signal in favour of a per-thread
	stop_signal.

	* inferior.h (stop_signal): Delete.
	* gdbthread.h (save_infrun_state, load_infrun_state): Remove
	stop_signal argument.
	* thread.c (load_infrun_state, save_infrun_state): Remove
	stop_signal argument.  Don't reference it.

	* infcmd.c (stop_signal): Delete.
	(program_info): Adjust.
	* infrun.c (resume): Clear stop_signal.
	(proceed): Adjust.  Pass the last stop_signal to the thread we're
	resuming.
	(context_switch): Don't context-switch stop_signal.
	(handle_inferior_event, keep_going): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* fbsd-nat.c: Include "gdbthread.h".
	(find_signalled_thread, find_stop_signal): New.
	(fbsd_make_corefile_notes): Use it.
	* fork-child.c (startup_inferior): Adjust.

	* linux-nat.c (get_pending_status): Adjust.
	(linux_nat_do_thread_registers): Adjust.
	(find_signalled_thread, find_stop_signal): New.
	(linux_nat_do_thread_registers): Add stop_signal parameter.
	(struct linux_nat_corefile_thread_data): Add stop_signal member.
	(linux_nat_corefile_thread_callback): Pass stop_signal.
	(linux_nat_do_registers): Delete.
	(linux_nat_make_corefile_notes): Use find_stop_signal.  Assume
	there's always a thread.

	* procfs.c (find_signalled_thread, find_stop_signal): New.
	(find_stop_signal): New.
	(procfs_do_thread_registers): Add stop_signal parameter.
	(struct procfs_corefile_thread_data): Add stop_signal member.
	(procfs_corefile_thread_callback): Pass args->stop_signal.
	(procfs_make_note_section): Find the last stop_signal.

	* solib-irix.c: Include gdbthread.h.
	(irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c: Include gdbthread.h.
	(osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c: Include gdbthread.h.
	(sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c: Include gdbthread.h.
	(svr4_solib_create_inferior_hook): Adjust.

	* win32-nat.c (do_initial_win32_stuff): Adjust.
@
text
@d1547 2
d1761 1
d1763 2
@


1.160
log
@	Use ptid_t.tid to store thread ids instead of ptid_t.pid.

	* win32-nat.c (win32_add_thread): Change thread argument type to
	ptid_t.  Adjust.
	(win32_add_thread): Adjust.
	(win32_delete_thread): Change thread argument type to ptid_t.
	Adjust.
	(win32_fetch_inferior_registers, win32_store_inferior_registers)
	(win32_resume, get_win32_debug_event, get_win32_debug_event)
	(win32_wait, win32_pid_to_exec_file, win32_pid_to_str): Adjust.
	(init_win32_ops): Put to_magic last.
	(win32_win32_thread_alive): Adjust.
@
text
@d1526 1
d1555 3
a1557 2
      if (stop_signal != TARGET_SIGNAL_TRAP)
	resume (0, stop_signal);
@


1.159
log
@	Adjust all targets to new target_stop interface.

	* gnu-nat.c (gnu_stop): Add ptid argument.
	* go32-nat.c (go32_stop): Add ptid argument.
	(go32_create_inferior): Pass inferior_ptid to go32_stop.
	* hpux-thread.c (hpux_thread_stop): Add ptid argument.
	* monitor.c (monitor_stop): Add ptid argument.
	(monitor_open): Pass inferior_ptid to monitor_stop.
	(monitor_interrupt): Pass inferior_ptid to target_stop.
	(monitor_stop): Add ptid argument.
	* nto-procfs.c (nto_interrupt): Pass inferior_ptid to target_stop.
	(procfs_create_inferior): Add ptid argument.
	* procfs.c (procfs_stop): Add ptid argument.
	* remote-m32r-sdi.c (m32r_stop): Add ptid argument.
	* remote-sim.c (gdbsim_stop): Add ptid argument.
	* sol-thread.c (sol_thread_stop): Add ptid argument.
	* win32-nat.c (win32_stop): Add ptid argument.
@
text
@d283 1
a283 1
/* Add a thread to the thread list */
d285 1
a285 1
win32_add_thread (DWORD id, HANDLE h)
d288 5
d302 2
a303 2
  add_thread (pid_to_ptid (id));
  /* Set the debug registers for the new thread in they are used.  */
d341 1
a341 1
win32_delete_thread (DWORD id)
d344 5
d351 2
a352 2
    printf_unfiltered ("[Deleting %s]\n", target_pid_to_str (pid_to_ptid (id)));
  delete_thread (pid_to_ptid (id));
d433 1
a433 1
  current_thread = thread_rec (PIDGET (inferior_ptid), TRUE);
d459 1
a459 1
  current_thread = thread_rec (PIDGET (inferior_ptid), TRUE);
d1189 2
a1190 1
  current_thread = win32_add_thread (main_thread_id,
d1201 7
a1207 1
  int pid = PIDGET (ptid);
d1245 2
a1246 2
  DEBUG_EXEC (("gdb: win32_resume (pid=%d, step=%d, sig=%d);\n",
	       pid, step, sig));
d1249 1
a1249 1
  th = thread_rec (PIDGET (inferior_ptid), FALSE);
d1279 4
a1282 1
  win32_continue (continue_status, pid);
a1295 1
  ptid_t ptid = {-1};
d1331 3
a1333 1
      th = win32_add_thread (current_event.dwThreadId,
a1334 1
      retval = current_event.dwThreadId;
d1344 2
a1345 1
	  win32_delete_thread (current_event.dwThreadId);
d1361 2
a1362 1
	win32_delete_thread (main_thread_id);
d1365 2
a1366 1
      th = win32_add_thread (main_thread_id,
d1456 1
a1456 1
	win32_resume (ptid, 0, 1);
d1462 2
a1463 1
      inferior_ptid = pid_to_ptid (retval);
d1471 1
a1471 1
/* Wait for interesting events to occur in the target process. */
d1475 1
a1475 1
  int pid = PIDGET (ptid);
d1507 1
a1507 1
	return pid_to_ptid (retval);
d1770 1
a1770 1
  sprintf (procexe, "/proc/%lu/exe", current_event.dwProcessId);
a2032 1
  int pid = PIDGET (ptid);
d2034 8
a2041 5
  if ((DWORD) pid == current_event.dwProcessId)
    sprintf (buf, "process %d", pid);
  else
    sprintf (buf, "Thread %ld.0x%x", current_event.dwProcessId, pid);
  return buf;
d2145 1
a2146 1
  win32_ops.to_pid_to_exec_file = win32_pid_to_exec_file;
d2274 1
a2274 1
/* Determine if the thread referenced by "pid" is alive
d2276 1
a2276 1
   it means that the pid has died.  Otherwise it is assumed to be alive. */
d2280 4
a2283 1
  int pid = PIDGET (ptid);
d2285 1
a2285 1
  return WaitForSingleObject (thread_rec (pid, FALSE)->h, 0) == WAIT_OBJECT_0 ?
@


1.158
log
@	Adjust fork/vfork/exec to pass ptids around.

	* target.h (struct target_waitstatus): Store related_pid as a ptid.
	(inferior_has_forked, inferior_has_vforked, inferior_has_execd):
	Take a ptid_t.
	* breakpoint.h (struct breakpoint): Change forked_inferior_pid
	type to ptid.
	* breakpoint.c (print_it_typical, bpstat_check_location)
	(print_one_breakpoint_location, set_raw_breakpoint_without_location)
	(create_fork_vfork_event_catchpoint): Adjust.
	* infrun.c (fork_event): Change parent_pid and child_pid types to
	ptid.
	(follow_exec, inferior_has_forked, inferior_has_vforked)
	(inferior_has_execd): Take a ptid_t and don't trim it.
	* linux-thread-db.c (thread_db_wait): Don't trim the returned ptid.
	* linux-nat.c (linux_child_follow_fork): Adjust.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait): Adjust.
	* win32-nat.c (get_win32_debug_event): Don't set related_pid.
@
text
@d108 1
a108 1
static void win32_stop (void);
d1931 1
a1931 1
win32_stop (void)
@


1.157
log
@	* config/i386/nm-cygwin.h (ATTACH_NO_WAIT): Delete.
	* config/i386/nm-i386gnu.h (ATTACH_NO_WAIT): Delete.

	* target.h (struct target_ops): Add to_attach_no_wait member.
	(target_attach_no_wait): New.
	* target.c (update_current_target): Inherit to_attach_no_wait.

	* infcmd.c: Replace ATTACH_NO_WAIT compile time check by
	target_attach_no_wait runtime check.

	* gnu-nat.c (init_gnu_ops): Set to_attach_no_wait in gnu_ops.
	* win32-nat.c (init_win32_ops): Set to_attach_no_wait in
	win32_ops.
@
text
@d1305 1
a1305 1
	      retval = ourstatus->value.related_pid = fake_create_process ();
d1345 1
a1345 1
      retval = ourstatus->value.related_pid = current_event.dwThreadId;
@


1.156
log
@	* Makefile.in (GNULIB_H): Use GNULIB_STDINT_H.
	(gdb_stdint_h, gdb_stdint.h, stamp-int): Delete.  Remove
	all dependencies on $(gdb_stdint_h).
	(distclean): Do not delete gdb_stdint.h.
	* acinclude.m4: Do not use stdint.m4.
	* configure.ac: Set GNULIB_STDINT_H.  Remove tests for stdint.h,
	uintptr_t, and gdb_stdint.h.
	* defs.h: Include <stdint.h>.
	* gdb_thread_db.h: Assume stdint.h is already included.
	* breakpoint.c, findcmd.c, hppa-tdep.c, inf-ptrace.c, proc-service.c,
	rs6000-nat.c, spu-linux-nat.c, target.c, win32-nat.c: Do not
	include gdb_stdint.h.
	* configure, config.in: Regenerate.
@
text
@d2088 1
@


1.155
log
@* win32-nat.c (safe_symbol_file_add_stub): Remove unused variable.
(do_initial_win32_stuff): Fix problem with inability to set breakpoints when
first loading DLL with "dll" command.
@
text
@a50 1
#include "gdb_stdint.h"
@


1.154
log
@	* win32-nat.c (win32_pid_to_str): Use capital T for "Thread".
@
text
@a558 2
  struct so_list *so = &solib_start;

d1526 1
d1536 2
@


1.153
log
@	* win32-nat.c (handle_load_dll): Give dll name and load address
	if debug_events is on.
	(handle_unload_dll): Likewise.
@
text
@d2014 1
a2014 1
    sprintf (buf, "thread %ld.0x%x", current_event.dwProcessId, pid);
@


1.152
log
@        * win32-nat.c (win32_wait): Block the control-c event while
        waiting for a debug event.
@
text
@d750 3
d777 2
@


1.151
log
@
	* win32-nat.c (do_win32_fetch_inferior_registers): Use get_regcache_arch
	to get at the current architecture and at the target specific vector.
	Add target specific vector to I387_FISEG_REGNUM and I387_FOP_REGNUM and
	remove define of I387_ST0_REGNUM.

	* amd64-tdep.c (I387_ST0_REGNUM): Remove define.

	(amd64_supply_fxsave, amd64_collect_fxsave): Use get_regcache_arch to
	get at the current architecture
	(I387_FISEG_REGNUM, I387_FOSEG_REGNUM): Add target specific vector as
	parameter.

	* i386-tdep.c: Remove various define's and undef's of I387_ST0_REGNUM,
	I387_NUM_XMM_REGS and I387_MM0_REGNUM.

	(I387_NUM_XMM_REGS, I387_XMM0_REGNUM, I387_MXCSR_REGNUM,
	I387_ST0_REGNUM, I387_FCTRL_REGNUM, I387_MM0_REGNUM,
	(I387_FSTAT_REGNUM): Add target specific vector as parameter.

	(i386_register_name, i386_dbx_reg_to_regnum): Use gdbarch_tdep to get
	at the target specific vector.

	(i386_get_longjmp_target): Use get_frame_arch to get at the current
	architecture. Use gdbarch_tdep to get at the target specific vector.

	(i386_fp_regnum_p, i386_fpc_regnum_p): Add gdbarch as parameter and
	update caller. Use gdbarch_tdep to get at the target specific vector.

	(i386_register_to_value: Use get_frame_arch to get at the current
	architecture.

	* i386-tdep.h (i386_fp_regnum_p, i386_fpc_regnum_p): Add gdbarch as
	parameter.

	* i387-tdep.c (I387_FCTRL_REGNUM, I387_FSTAT_REGNUM, I387_FTAG_REGNUM,
	I387_FISEG_REGNUM, I387_FIOFF_REGNUM, I387_FOSEG_REGNUM
	I387_FOOFF_REGNUM, I387_FOP_REGNUM, I387_ST0_REGNUM, FSAVE_ADDR,
	FXSAVE_ADDR, I387_XMM0_REGNUM): Add target specific vector as parameter.

	(I387_ST0_REGNUM, I387_NUM_XMM_REGS): Remove various define's and
	undef's.

	(i387_convert_register_p, i387_register_to_value,
	i387_value_to_register): Update call for i386_fp_regnum_p.

	* i387-tdep.h: Remove comment.
	(I387_ST0_REGNUM, I387_NUM_XMM_REGS, I387_MM0_REGNUM): Add define.
	(I387_FCTRL_REGNUM, I387_FSTAT_REGNUM, I387_FTAG_REGNUM,
	I387_FISEG_REGNUM, I387_FIOFF_REGNUM, I387_FOSEG_REGNUM,
	I387_FOOFF_REGNUM, I387_FOP_REGNUM, I387_XMM0_REGNUM,
	I387_MXCSR_REGNUM): Add target specific vector as parameter.
@
text
@d1461 19
a1479 1
      int retval = get_win32_debug_event (pid, ourstatus);
@


1.150
log
@        * infrun.c (wait_for_inferior): Add treat_exec_as_sigtrap parameter
        and use it.
        (proceed, start_remote): Update call to wait_for_inferior.
        * inferior.h (wait_for_inferior): Update declaration.
        * fork-child.c, infcmd.c, solib-irix.c, solib-osf.c, solib-sunos.c,
        solib-svr4.c, win32-nat.c: Update calls to wait_for_inferior.
        * inf-ttrace.c (inf_ttrace_wait): Report TTEVT_EXEC events as
        TARGET_WAITKIND_EXECD instead of TARGET_WAITKIND_STOPPED.
@
text
@d362 2
d402 1
a402 3
#define I387_ST0_REGNUM I386_ST0_REGNUM

  if (r == I387_FISEG_REGNUM)
d407 1
a407 1
  else if (r == I387_FOP_REGNUM)
d416 1
a416 1
      for (r = 0; r < gdbarch_num_regs (get_regcache_arch (regcache)); r++)
a418 2

#undef I387_ST0_REGNUM
@


1.149
log
@2008-01-24  Michael Snyder  <msnyder@@specifix.com>

	* procfs.c (procfs_xfer_partial): Comment, cut/paste error.
	* win32-nat.c (win32_xfer_partial): Ditto.
	* target.c (default_xfer_partial): Minor whitespace adjustment.
@
text
@d1510 1
a1510 1
      wait_for_inferior ();
@


1.148
log
@        Inform about new thread in a single place.

        * thread.c (add_thread_silent): Renamed
        from add_thread.
        (print_thread_events): New variable definition.
        (show_print_thread_events): New function.
        (_initialize_thread): Add "set print thread-events" and
        "show print thread-events" commands.
        (add_thread): Announce new thread.
        * gdbthread.h (add_thread_silent): Declare.
        (print_thread_events): New variable declaration.
        * inf-ttrace.c (inf_ttrace_wait): Don't
        inform about new thread, as add_thread is always
        called too, and will take care of that.
        * infrun.c (handle_inferior_event): Likewise.
        * procfs.c (procfs_wait): Likewise.
        * remote.c (remote_currthread): Likewise.
        * sol-thread.c (sol_thread_wait): Likewise.
        * win32-nat.c (get_win32_debug_event): Likewise.
        * linux-thread-db.c (attach_thread): Likewise.
        Remove the verbose parameter.
        (check_event): Make detach_thread be verbose
        only if print_thread_events is set.
        * linux-nat.c (lin_lwp_attach_lwp): Don't inform
        about new thread.  This is called only from
        linux-thread-db.c:attach_thread, which will take care.
        Remove the verbose parameter.
        * linux-nat.h (lin_lwp_attach_lwp): Adjust prototype.
@
text
@d2040 1
a2040 1
					       len, 0/*write*/, NULL, ops);
@


1.147
log
@	* win32-nat.c (win32_create_inferior): Restore code calling
	CloseHandle on ProcessInformation structure.
@
text
@a1313 4
      if (info_verbose)
	printf_unfiltered ("[New %s]\n",
			   target_pid_to_str (
			     pid_to_ptid (current_event.dwThreadId)));
@


1.146
log
@* win32-nat.c (win32_make_so): Use cygwin-style path to avoid warnings when
using MS-DOS paths.
@
text
@d1883 3
@


1.145
log
@* win32-nat.c (psapi_module_handle): Remove static.
(get_module_name): Rename from psapi_get_dll_name.  Revamp slightly to return
first module found if base_address is zero.  Don't initialize psapi function
pointers here.  Convert to cygwin paths when appropriate.
(win32_pid_to_exec_file): Use Cygwin's /proc interface to determine executable
name.  Use get_module_name when that fails or when !__CYGWIN__.
(_initialize_psapi): New function.  Initialize psapi stuff before it is needed
or issue a warning if it is not found.  Move psapi_module_handle here.
@
text
@d659 1
a659 1
      abfd = bfd_openr (name, "pei-i386");
@


1.144
log
@2007-12-22  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c: Fix PR/2388.
	(do_win32_fetch_inferior_registers): Do not overwrite debug register
	array dr if debug_registers_changed variable is set.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Free Software Foundation, Inc.
d460 10
a469 5
static HMODULE psapi_module_handle = NULL;
static BOOL WINAPI (*psapi_EnumProcessModules) (HANDLE, HMODULE *, DWORD, LPDWORD) = NULL;
static BOOL WINAPI (*psapi_GetModuleInformation) (HANDLE, HMODULE, LPMODULEINFO, DWORD) = NULL;
static DWORD WINAPI (*psapi_GetModuleFileNameExA) (HANDLE, HMODULE, LPSTR, DWORD) = NULL;

d471 1
a471 1
psapi_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
d477 1
a477 1
  HMODULE *DllHandle = dh_buf;
d479 6
a484 1
  BOOL ok;
d486 4
a489 23
  if (!psapi_loaded ||
      psapi_EnumProcessModules == NULL ||
      psapi_GetModuleInformation == NULL ||
      psapi_GetModuleFileNameExA == NULL)
    {
      if (psapi_loaded)
	goto failed;
      psapi_loaded = 1;
      psapi_module_handle = LoadLibrary ("psapi.dll");
      if (!psapi_module_handle)
	{
	  /* printf_unfiltered ("error loading psapi.dll: %u", GetLastError ()); */
	  goto failed;
	}
      psapi_EnumProcessModules = GetProcAddress (psapi_module_handle, "EnumProcessModules");
      psapi_GetModuleInformation = GetProcAddress (psapi_module_handle, "GetModuleInformation");
      psapi_GetModuleFileNameExA = (void *) GetProcAddress (psapi_module_handle,
						    "GetModuleFileNameExA");
      if (psapi_EnumProcessModules == NULL ||
	  psapi_GetModuleInformation == NULL ||
	  psapi_GetModuleFileNameExA == NULL)
	goto failed;
    }
d492 3
a494 6
  ok = (*psapi_EnumProcessModules) (current_process_handle,
				    DllHandle,
				    sizeof (HMODULE),
				    &cbNeeded);

  if (!ok || !cbNeeded)
d497 1
d502 3
a504 5
  ok = (*psapi_EnumProcessModules) (current_process_handle,
				    DllHandle,
				    cbNeeded,
				    &cbNeeded);
  if (!ok)
d509 3
a511 4
      if (!(*psapi_GetModuleInformation) (current_process_handle,
					  DllHandle[i],
					  &mi,
					  sizeof (mi)))
d514 13
a526 9
      len = (*psapi_GetModuleFileNameExA) (current_process_handle,
					   DllHandle[i],
					   dll_name_ret,
					   MAX_PATH);
      if (len == 0)
	error (_("Error getting dll name: %u."), (unsigned) GetLastError ());

      if ((DWORD) (mi.lpBaseOfDll) == BaseAddress)
	return 1;
d531 1
a531 1
  return 0;
d738 1
a738 1
  if (!psapi_get_dll_name ((DWORD) (event->lpBaseOfDll), dll_buf))
a1722 4
  /* Try to find the process path using the Cygwin internal process list
     pid isn't a valid pid, unfortunately.  Use current_event.dwProcessId
     instead.  */

a1723 1
  char *path_ptr = NULL;
d1726 9
a1734 16
  /* TODO: Also find native Windows processes using CW_GETPINFO_FULL.  */
  int cpid;
  struct external_pinfo *pinfo;

  cygwin_internal (CW_LOCK_PINFO, 1000);
  for (cpid = 0;
       (pinfo = (struct external_pinfo *)
	cygwin_internal (CW_GETPINFO, cpid | CW_NEXTPID));
       cpid = pinfo->pid)
    {
      if (pinfo->dwProcessId == current_event.dwProcessId) /* Got it */
       {
	 cygwin_conv_to_full_posix_path (pinfo->progname, path);
	 path_ptr = path;
	 break;
       }
a1735 1
  cygwin_internal (CW_UNLOCK_PINFO);
d1738 6
a1743 1
  return path_ptr;
d2267 31
@


1.143
log
@2007-12-06  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c: Allow compilation if CORE_ADDR is 8 byte long.
	Add "gdb_stdint.h" dependency required for uintptr_t type use.
	(handle_output_debug_string): Use uintptr_t typecast.
	(handle_exception): Ditto.
	(win32_xfer_memory): Ditto.
	* Makefile.in (win32-nat.o): Add dependency to gdb_stdint header.
@
text
@d385 11
a395 7
	  /* Copy dr values from that thread.  */
	  dr[0] = th->context.Dr0;
	  dr[1] = th->context.Dr1;
	  dr[2] = th->context.Dr2;
	  dr[3] = th->context.Dr3;
	  dr[6] = th->context.Dr6;
	  dr[7] = th->context.Dr7;
@


1.142
log
@2007-12-02  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c (win32_resume): Set the trace bit
	in the thread identified by inferior_ptid.
@
text
@d51 1
d832 2
a833 1
    ((CORE_ADDR) current_event.u.DebugString.lpDebugStringData, &s, 1024, 0)
d1027 2
a1028 1
	bfd_vma addr = (bfd_vma) current_event.u.Exception.ExceptionRecord.ExceptionAddress;
d1941 3
a1943 2
		  len, (DWORD) memaddr));
      if (!WriteProcessMemory (current_process_handle, (LPVOID) memaddr, our,
d1946 2
a1947 1
      FlushInstructionCache (current_process_handle, (LPCVOID) memaddr, len);
d1952 3
a1954 2
		  len, (DWORD) memaddr));
      if (!ReadProcessMemory (current_process_handle, (LPCVOID) memaddr, our,
@


1.141
log
@*win32-nat.c (open_process_used): New static variable.
(win32_init_thread_list): Remove call to CloseHandle for thread.
(win32_delete_thread): Ditto.
(fake_create_process): Set open_process_used if OpenProcess call is successful.
(get_win32_debug_event): Do not close process handle.
(do_initial_win32_stuff): Set open_process_used to zero.
(win32_mourn_inferior): Call CloseHandle for current_process_handle if
open_process_used is set.
(win32_kill_inferior): Do not close process and main_thread handles.
@
text
@d1235 1
a1235 1
  th = thread_rec (current_event.dwThreadId, FALSE);
@


1.140
log
@	* win32-nat.c (DR6_CLEAR_VALUE): New define.
	(thread_info_struct): Rename suspend_count to suspended, to be
	used as a flag.
	(thread_rec): Only suspend the thread if it wasn't suspended by
	gdb before.  Warn if suspending failed.
	(win32_add_thread): Set Dr6 to DR6_CLEAR_VALUE.
	(win32_continue): Set Dr6 to DR6_CLEAR_VALUE.  Update usage of the
	`suspended' flag.  Do ContinueDebugEvent after resuming the
	suspended threads, not before.  Set threads' contexts before
	resuming them, not after.
	(win32_resume): Set Dr6 to DR6_CLEAR_VALUE.
@
text
@d144 1
a328 1
      (void) CloseHandle (here->h);
a352 1
      CloseHandle (here->h);
d1173 8
d1309 2
a1310 1
	      saw_create++;
d1343 1
a1343 4
	{
	  CloseHandle (current_event.u.CreateProcessInfo.hProcess);
	  break;
	}
a1363 1
      CloseHandle (current_process_handle);
d1495 1
a1893 3
  CloseHandle (pi.hThread);
  CloseHandle (pi.hProcess);

d1909 5
a1969 5
  CHECK (CloseHandle (current_process_handle));

  /* this may fail in an attached process so don't check. */
  if (current_thread && current_thread->h)
    (void) CloseHandle (current_thread->h);
@


1.139
log
@2007-11-16  Markus Deuling  <deuling@@de.ibm.com>

	* m32r-rom.c (m32r_supply_register): Use get_regcache_arch to get at
	the current architecture by regcache.
	* ppcnbsd-nat.c (ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, fetch_ppc_registers)
	(store_altivec_register, store_spe_register, store_register)
	(fill_vrregset, store_ppc_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Likewise.

	* trad-frame.c (trad_frame_alloc_saved_regs): Replace current_gdbarch by
	gdbarch.
	* user-regs.c (user_reg_map_name_to_regnum): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_return_value): Likewise.
	* m32c-tdep.c (m32c_register_reggroup_p): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.

	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Use get_frame_arch to
	get at the current architecture by frame_info.
	* gcore.c (derive_stack_segment): Likewise.

	* shnbsd-nat.c (GETREGS_SUPPLIES): Add gdbarch parameter.
	(shnbsd_fetch_inferior_registers, shnbsd_store_inferior_registers): Add
	gdbarch to GETREGS_SUPPLIES call.
@
text
@d94 1
d116 1
a116 1
   not available in gdb's thread structure. */
d123 1
a123 1
    int suspend_count;
d248 3
a250 3
/* Find a thread record given a thread id.
   If get_context then also retrieve the context for this
   thread. */
d259 1
a259 1
	if (!th->suspend_count && get_context)
d262 10
a271 1
	      th->suspend_count = SuspendThread (th->h) + 1;
d273 1
a273 1
	      th->suspend_count = -1;
d307 1
a307 2
      /* th->context.Dr6 = dr[6];
      FIXME: should we set dr6 also ?? */
d1134 25
a1161 23
  if (res)
    for (th = &thread_head; (th = th->next) != NULL;)
      if (((id == -1) || (id == (int) th->id)) && th->suspend_count)
	{

	  for (i = 0; i < th->suspend_count; i++)
	    (void) ResumeThread (th->h);
	  th->suspend_count = 0;
	  if (debug_registers_changed)
	    {
	      /* Only change the value of the debug registers */
	      th->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
	      th->context.Dr0 = dr[0];
	      th->context.Dr1 = dr[1];
	      th->context.Dr2 = dr[2];
	      th->context.Dr3 = dr[3];
	      /* th->context.Dr6 = dr[6];
		 FIXME: should we set dr6 also ?? */
	      th->context.Dr7 = dr[7];
	      CHECK (SetThreadContext (th->h, &th->context));
	      th->context.ContextFlags = 0;
	    }
	}
d1247 1
a1247 2
	      /* th->context.Dr6 = dr[6];
	       FIXME: should we set dr6 also ?? */
@


1.138
log
@	* config/i386/mingw.mh, config/i386/mingw.mt: New files.
	* configure.tgt	(i[34567]86-*-mingw32*): Set gdb_target = mingw.
	* win32-nat.c: Only include cygwin.h on Cygwin host.  Don't
	include procfs.h.
	(cygwin_load_start, cygwin_load_end, cygwin_exceptions): Disable
	if not building on Cygwin.
	(win32_make_so, handle_output_debug_string, handle_exception)
	(do_initial_win32_stuff): Wrap Cygwin specific code in __CYGWIN__.
	(win32_attach): Only fallback to Cygwin pids if building on
	Cygwin.
	(win32_pid_to_exec_file): Disable Cygwin specific code, if not
	building on Cygwin.
	(win32_create_inferior): Disable starting the inferior through a
	shell, environment var processing and tty handling if not building
	on Cygwin.
	(cygwin_pid_to_str): Rename to ...
	(win32_pid_to_str): ... this.
	(init_win32_ops): Update use of win32_pid_to_str.  Disable "shell"
	and "cygwin-exceptions" commands if not building on Cygwin.
@
text
@d403 1
a403 1
      for (r = 0; r < gdbarch_num_regs (current_gdbarch); r++)
d430 1
a430 1
      for (r = 0; r < gdbarch_num_regs (current_gdbarch); r++)
@


1.137
log
@	* infcmd.c (post_create_inferior): Update comment.
	(run_command_1): Always call post_create_inferior with 0 as
	from_tty.

	* i386-cygwin-tdep.h: New.
	* i386-cygwin-tdep.c: Include "i386-cygwin-tdep.h".
	(win32_xfer_shared_library): Make it extern.

	* win32-nat.c: Include gdb_obstack.h and xml-support.h and
	i386-cygwin-tdep.h.
	(win32_so_ops): Delete.
	(get_relocated_section_addrs): Delete.
	(solib_symbols_add): Delete.
	(register_loaded_dll): Delete.
	(win32_make_so): New.
	(handle_load_dll): Use win32_make_so.
	(win32_free_so): Free the passed in so.
	(win32_relocate_section_addresses): Delete.
	(win32_solib_create_inferior_hook): Delete.
	(handle_unload_dll): Don't add PE offset here.  Free so with
	win32_free_so instead of free_so.
	(win32_special_symbol_handling): Delete.
	(get_win32_debug_event): Remove unneeded calls.  Set state to
	TARGET_WAITKIND_LOADED on a dll unload.
	(do_initial_win32_stuff): Clear cygwin_load_start and
	cygwin_load_end.
	(map_code_section_args): Delete.
	(dll_code_sections_add): Delete.
	(core_section_load_dll_symbols): Delete.
	(win32_xfer_shared_libraries): New.
	(win32_current_sos): Delete.
	(win32_xfer_partial): New.
	(open_symbol_file_object): Delete.
	(in_dynsym_resolve_code): Delete.
	(init_win32_ops): Set win32_xfer_partial as to_xfer_partial member
	of win32_ops.  Remove win32_so_ops settings.  Don't set
	current_target_so_ops here.

	* Makefile.in (i386_cygwin_tdep_h): New variable.
	(i386-cygwin-tdep.o): Update dependencies.
	(win32-nat.o): Update dependencies.
@
text
@a24 2
/* We assume we're being built with and will be used for cygwin.  */

d41 1
d43 1
d67 1
d71 1
a85 1
#include <sys/procfs.h>
d146 1
d148 1
d643 4
a647 2
  strcpy (so->so_original_name, name);

d678 1
d828 1
d830 1
d1008 1
d1023 1
d1485 1
d1487 1
d1640 1
d1648 2
d1651 2
a1652 3
      if (!ok)
	error (_("Can't attach to process."));
    }
a1713 1
  /* TODO: Also find native Windows processes using CW_GETPINFO_FULL.  */
d1717 3
d1737 2
d1785 1
d1806 4
d1824 1
d1848 1
d1861 2
d1873 1
d1982 1
a1982 1
cygwin_pid_to_str (ptid_t ptid)
d2086 1
a2086 1
  win32_ops.to_pid_to_str = cygwin_pid_to_str;
d2117 1
d2131 1
@


1.136
log
@	* gdbarch.sh (core_xfer_shared_libraries): New.

	* corelow.c (core_xfer_partial): Handle TARGET_OBJECT_LIBRARIES.

	* gdb_obstack.h (obstack_grow_str, obstack_grow_str0): New.

	* xml-support.c (gdb_xml_parse): Debug output tweaks.
	(xml_escape_text): New.
	* xml-support.h (xml_escape_text): Declare.

	* config/i386/cygwin.mh (NATDEPFILES): Move corelow.o to ...
	* config/i386/cygwin.mt (TDEPFILES): ... here.

	* win32-nat.c: (fetch_elf_core_registers): Delete.
	(win32_elf_core_fn): Delete.
	(_initialize_core_win32): Delete.

	* i386-cygwin-tdep.c: Include "regset.h", "gdb_objstack.h",
	"xml-support.h" and "gdbcore.h".
	(i386_win32_gregset_reg_offset): New.
	(I386_WIN32_SIZEOF_GREGSET): New.
	(i386_win32_regset_from_core_section): New.
	(win32_xfer_shared_library): New.
	(struct cpms_data): New.
	(core_process_module_section): New.
	(win32_core_xfer_shared_libraries): New.
	(i386_cygwin_skip_trampoline_code): Register gregset_reg_offset,
	gregset_num_regs, sizeof_gregset members of tdep.  Register
	regset_from_core_section and core_xfer_shared_libraries callbacks.

	* Makefile.in (i386-cygwin-tdep.o): Update dependencies.
	* gdbarch.h, gdbarch.c: Regenerate.
@
text
@d49 1
d58 1
d63 2
a65 1
static struct target_so_ops win32_so_ops;
d604 2
a605 117
/* Get the loaded address of all sections, given that .text was loaded
   at text_load. Assumes that all sections are subject to the same
   relocation offset. Returns NULL if problems occur or if the
   sections were not relocated. */

static struct section_addr_info *
get_relocated_section_addrs (bfd *abfd, CORE_ADDR text_load)
{
  struct section_addr_info *result = NULL;
  int section_count = bfd_count_sections (abfd);
  asection *text_section = bfd_get_section_by_name (abfd, ".text");
  CORE_ADDR text_vma;

  if (!text_section)
    {
      /* Couldn't get the .text section. Weird. */
    }
  else if (text_load == (text_vma = bfd_get_section_vma (abfd, text_section)))
    {
      /* DLL wasn't relocated. */
    }
  else
    {
      /* Figure out all sections' loaded addresses. The offset here is
	 such that taking a bfd_get_section_vma() result and adding
	 offset will give the real load address of the section. */

      CORE_ADDR offset = text_load - text_vma;

      struct section_table *table_start = NULL;
      struct section_table *table_end = NULL;
      struct section_table *iter = NULL;

      build_section_table (abfd, &table_start, &table_end);

      for (iter = table_start; iter < table_end; ++iter)
	{
	  /* Relocated addresses. */
	  iter->addr += offset;
	  iter->endaddr += offset;
	}

      result = build_section_addr_info_from_section_table (table_start,
							   table_end);

      xfree (table_start);
    }

  return result;
}

/* Add DLL symbol information. */
static void
solib_symbols_add (struct so_list *so, CORE_ADDR load_addr)
{
  struct section_addr_info *addrs = NULL;
  static struct objfile *result = NULL;
  char *name = so->so_name;
  bfd *abfd = NULL;
  char *p;

  /* The symbols in a dll are offset by 0x1000, which is the
     the offset from 0 of the first byte in an image - because
     of the file header and the section alignment. */

  if (!name || !name[0])
    return;

  abfd = bfd_openr (name, "pei-i386");

  if (!abfd)
    {
      /* pei failed - try pe */
      abfd = bfd_openr (name, "pe-i386");
    }

  if (abfd)
    {
      if (bfd_check_format (abfd, bfd_object))
	addrs = get_relocated_section_addrs (abfd, load_addr);
    }

  if (addrs)
    {
      result = safe_symbol_file_add (name, 0, addrs, 0, OBJF_SHARED);
      free_section_addr_info (addrs);
    }
  else
    {
      /* Fallback on handling just the .text section. */
      struct cleanup *my_cleanups;

      addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, addrs);
      addrs->other[0].name = ".text";
      addrs->other[0].addr = load_addr;

      result = safe_symbol_file_add (name, 0, addrs, 0, OBJF_SHARED);
      do_cleanups (my_cleanups);
    }

  p = strchr (so->so_name, '\0') - (sizeof ("/cygwin1.dll") - 1);
  if (p >= so->so_name && strcasecmp (p, "/cygwin1.dll") == 0)
    {
      asection *text = bfd_get_section_by_name (abfd, ".text");
      cygwin_load_start = bfd_section_vma (abfd, text);
      cygwin_load_end = cygwin_load_start + bfd_section_size (abfd, text);
    }

  bfd_close (abfd);

  so->symbols_loaded = !!result;
  return;
}

static char *
register_loaded_dll (const char *name, DWORD load_addr, int readsyms)
a613 1
  size_t len;
d641 11
a651 1
  strcpy (so->so_original_name, so->so_name);
d653 2
a654 5
  solib_end->next = so;
  solib_end = so;
  len = strlen (so->so_name);
  if (readsyms)
    solib_symbols_add (so, (CORE_ADDR) load_addr);
d656 19
a674 1
  return so->so_name;
d735 2
a736 1
    dll_name = get_image_name (current_process_handle, event->lpImageName, event->fUnicode);
d740 2
a741 1
  register_loaded_dll (dll_name, (DWORD) event->lpBaseOfDll + 0x1000, auto_solib_add);
d751 1
a751 15
}

static void
win32_relocate_section_addresses (struct so_list *so,
				  struct section_table *sec)
{
  /* FIXME */
  return;
}

static void
win32_solib_create_inferior_hook (void)
{
  solib_add (NULL, 0, NULL, auto_solib_add);
  return;
d757 1
a757 1
  DWORD lpBaseOfDll = (DWORD) current_event.u.UnloadDll.lpBaseOfDll + 0x1000;
d767 1
a767 1
	free_so (sodel);
a784 6
static void
win32_special_symbol_handling (void)
{
  return;
}

a1351 1
      registers_changed ();	/* mark all regs invalid */
a1354 1
      re_enable_breakpoints_in_shlibs ();
d1365 3
a1367 3
      registers_changed ();	/* mark all regs invalid */
      /* ourstatus->kind = TARGET_WAITKIND_UNLOADED;
	 does not exist yet. */
d1475 1
d1966 10
a1975 5
typedef struct
{
  struct target_ops *target;
  bfd_vma addr;
} map_code_section_args;
d1977 2
a1978 6
static void
map_single_dll_code_section (bfd *abfd, asection *sect, void *obj)
{
  int old;
  int update_coreops;
  struct section_table *new_target_sect_ptr;
d1980 9
a1988 49
  map_code_section_args *args = (map_code_section_args *) obj;
  struct target_ops *target = args->target;
  if (sect->flags & SEC_CODE)
    {
      update_coreops = core_ops.to_sections == target->to_sections;

      if (target->to_sections)
	{
	  old = target->to_sections_end - target->to_sections;
	  target->to_sections = (struct section_table *)
	    xrealloc ((char *) target->to_sections,
		      (sizeof (struct section_table)) * (1 + old));
	}
      else
	{
	  old = 0;
	  target->to_sections = (struct section_table *)
	    xmalloc ((sizeof (struct section_table)));
	}
      target->to_sections_end = target->to_sections + (1 + old);

      /* Update the to_sections field in the core_ops structure
	 if needed.  */
      if (update_coreops)
	{
	  core_ops.to_sections = target->to_sections;
	  core_ops.to_sections_end = target->to_sections_end;
	}
      new_target_sect_ptr = target->to_sections + old;
      new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
      new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	bfd_section_size (abfd, sect);;
      new_target_sect_ptr->the_bfd_section = sect;
      new_target_sect_ptr->bfd = abfd;
    }
}

static int
dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
{
  bfd *dll_bfd;
  map_code_section_args map_args;
  asection *lowest_sect;
  char *name;
  if (dll_name == NULL || target == NULL)
    return 0;
  name = xstrdup (dll_name);
  dll_bfd = bfd_openr (name, "pei-i386");
  if (dll_bfd == NULL)
d1991 27
a2017 7
  if (bfd_check_format (dll_bfd, bfd_object))
    {
      lowest_sect = bfd_get_section_by_name (dll_bfd, ".text");
      if (lowest_sect == NULL)
	return 0;
      map_args.target = target;
      map_args.addr = base_addr - bfd_section_vma (dll_bfd, lowest_sect);
d2019 5
a2023 30
      bfd_map_over_sections (dll_bfd, &map_single_dll_code_section, (void *) (&map_args));
    }

  return 1;
}

static void
core_section_load_dll_symbols (bfd *abfd, asection *sect, void *obj)
{
  struct target_ops *target = (struct target_ops *) obj;

  DWORD base_addr;

  int dll_name_size;
  struct win32_pstatus *pstatus;
  struct so_list *so;
  char *dll_name;
  char *buf = NULL;
  char *p;
  struct objfile *objfile;
  const char *dll_basename;

  if (strncmp (sect->name, ".module", 7) != 0)
    return;

  buf = (char *) xmalloc (bfd_get_section_size (sect) + 1);
  if (!buf)
    {
      printf_unfiltered ("memory allocation failed for %s\n", sect->name);
      goto out;
a2024 79
  if (!bfd_get_section_contents (abfd, sect, buf, 0, bfd_get_section_size (sect)))
    goto out;

  pstatus = (struct win32_pstatus *) buf;

  memmove (&base_addr, &(pstatus->data.module_info.base_address), sizeof (base_addr));
  dll_name_size = pstatus->data.module_info.module_name_size;
  if (offsetof (struct win32_pstatus, data.module_info.module_name) + dll_name_size > bfd_get_section_size (sect))
      goto out;

  dll_name = pstatus->data.module_info.module_name;

  if (!(dll_basename = strrchr (dll_name, '/')))
    dll_basename = dll_name;
  else
    dll_basename++;

  ALL_OBJFILES (objfile)
  {
    char *objfile_basename = strrchr (objfile->name, '/');

    if (objfile_basename &&
	strcasecmp (dll_basename, objfile_basename + 1) == 0)
      goto out;
  }

  base_addr += 0x1000;
  dll_name = register_loaded_dll (dll_name, base_addr, 1);

  if (!dll_code_sections_add (dll_name, (DWORD) base_addr, target))
    printf_unfiltered ("%s: Failed to map dll code sections.\n", dll_name);

out:
  if (buf)
    xfree (buf);
  return;
}

static struct so_list *
win32_current_sos (void)
{
  struct so_list *sop;
  struct so_list *start = NULL;
  struct so_list *last = NULL;

  if (!solib_start.next && core_bfd)
    {
      win32_clear_solib ();
      bfd_map_over_sections (core_bfd, &core_section_load_dll_symbols,
			     &win32_ops);
    }

  for (sop = solib_start.next; sop; sop = sop->next)
    {
      struct so_list *new = XZALLOC (struct so_list);
      strcpy (new->so_name, sop->so_name);
      strcpy (new->so_original_name, sop->so_original_name);
      if (!start)
	last = start = new;
      else
	{
	  last->next = new;
	  last = new;
	}
    }

  return start;
}

static int
open_symbol_file_object (void *from_ttyp)
{
  return 0;
}

static int
in_dynsym_resolve_code (CORE_ADDR pc)
{
  return 0;
d2043 1
a2067 12

  win32_so_ops.relocate_section_addresses = win32_relocate_section_addresses;
  win32_so_ops.free_so = win32_free_so;
  win32_so_ops.clear_solib = win32_clear_solib;
  win32_so_ops.solib_create_inferior_hook = win32_solib_create_inferior_hook;
  win32_so_ops.special_symbol_handling = win32_special_symbol_handling;
  win32_so_ops.current_sos = win32_current_sos;
  win32_so_ops.open_symbol_file_object = open_symbol_file_object;
  win32_so_ops.in_dynsym_resolve_code = in_dynsym_resolve_code;

  /* FIXME: Don't do this here.  *_gdbarch_init() should set so_ops. */
  current_target_so_ops = &win32_so_ops;
@


1.135
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a2244 17
static void
fetch_elf_core_registers (struct regcache *regcache,
			  char *core_reg_sect,
			  unsigned core_reg_size,
			  int which,
			  CORE_ADDR reg_addr)
{
  int r;
  if (core_reg_size < sizeof (CONTEXT))
    {
      error (_("Core file register section too small (%u bytes)."), core_reg_size);
      return;
    }
  for (r = 0; r < gdbarch_num_regs (current_gdbarch); r++)
    regcache_raw_supply (regcache, r, core_reg_sect + mappings[r]);
}

a2445 15
static struct core_fns win32_elf_core_fns =
{
  bfd_target_elf_flavour,
  default_check_format,
  default_core_sniffer,
  fetch_elf_core_registers,
  NULL
};

void
_initialize_core_win32 (void)
{
  deprecated_add_core_fns (&win32_elf_core_fns);
}

@


1.134
log
@	gdb/
	* breakpoint.c (disable_breakpoints_in_shlibs): Remove
	the 'silent' parameter and code to implement that.
	* breakpoint.h (disable_breakpoints_in_shlibs): Adjust
	prototype.
	* win32-nat.c: Adjust.
	* solib.c: Adjust.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d16 1
a16 1
   but WITHOUT ANY WARRANTY; without eve nthe implied warranty of
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.133
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1588 1
a1588 1
  disable_breakpoints_in_shlibs (1);
@


1.132
log
@	* regcache.c (struct regcache): Add ptid_t member.
	(regcache_xmalloc): Initialize it.
	(regcache_cpy_no_passthrough): Do not refer to current_regcache.
	(regcache_dup): Likewise.
	(regcache_dup_no_passthrough): Likewise.
	(current_regcache): Make static.
	(registers_ptid): Remove variable.
	(get_thread_regcache): New function.
	(get_current_regcache): New function.
	(registers_changed): Implement by freeing current regcache.
	(regcache_raw_read): Do not refer to current_regcache.  Set
	inferior_ptid to regcache->ptid while calling target routines.
	(regcache_raw_write): Likewise.
	(regcache_raw_supply): Do not refer to current_regcache.
	(read_pc_pid): Use thread regcache.  Do not modify inferior_ptid.
	(write_pc_pid): Likewise.
	(build_regcache): Remove.
	(_initialize_regcache): Do not call DEPRECATED_REGISTER_GDBARCH_SWAP
	or deprecated_register_gdbarch_swap.  Do not initialize
	registers_ptid.
	* regcache.h (get_current_regcache): Add prototype.
	(get_thread_regcache): Likewise.
	(current_regcache): Remove declaration.

	* corelow.c (core_open): Replace current_regcache by
	get_current_regcache ().
	* frame.c (frame_pop): Likewise.
	(put_frame_register): Likewise.
	(get_current_frame, create_new_frame): Likewise.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Likewise.
	* stack.c (return_command): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infrun.c (resume): Likewise.
	(save_inferior_status, restore_inferior_status): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	(fork_save_infrun_state): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* i386fbsd-nat.c (i386fbsd_resume): Likewise.
	* monitor.c (monitor_wait): Likewise.
	* remote.c (remote_wait): Likewise.
	* remote-mips.c (mips_wait): Likewise.

	* bsd-kvm.c (bsd_kvm_open): Likewise
	(bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Likewise.
	* fbsd-nat.c (fbsd_make_corefile_notes): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint): Likewise.
	(ia64_linux_stopped_data_address): Likewise.

	* frv-tdep.c (frv_fdpic_loadmap_addresses): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mep-tdep.c (current_me_module, current_options): Likewise.
	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Likewise.

	* linux-nat.c (linux_nat_do_thread_registers): Use thread
	regcache instead of current_regcache.  Call target_fetch_registers.
	(linux_nat_corefile_thread_callback): Update call site.
	(linux_nat_do_registers): Likewise.
	* procfs.c (procfs_do_thread_registers): Use thread regcache instead
	of current_regcache.
	(procfs_make_note_section): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
@
text
@d1321 2
a1322 1
	  win32_fetch_inferior_registers (get_current_regcache (), PS_REGNUM);
@


1.131
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d1321 1
a1321 1
	  win32_fetch_inferior_registers (current_regcache, PS_REGNUM);
@


1.130
log
@	* target.h (struct target_ops): Add REGCACHE parameter to
	to_prepare_to_store.
	(target_prepare_to_store): Likewise.
	* target.c (debug_to_prepare_to_store): Add REGCACHE parameter.
	(update_current_target): Adapt prepare_to_store de_fault rule.

	* regcache.c (regcache_raw_write): Pass regcache to
	target_prepare_to_store.

	* inftarg.c (child_prepare_to_store): Add REGCACHE parameter.
	Do not call CHILD_PREPARE_TO_STORE.
	* gnu-nat.c (gnu_prepare_to_store): Likewise.
	* procfs.c (procfs_prepare_to_store): Likewise.

	* inf-child.c (inf_child_prepare_to_store): Add REGCACHE parameter.
	* go32-nat.c (go32_prepare_to_store): Likewise.
	* monitor.c (monitor_prepare_to_store): Likewise.
	* nto-procfs.c (procfs_prepare_to_store): Likewise.
	* remote-m32r-sdi.c (m32r_prepare_to_store): Likewise.
	* remote-mips.c (mips_prepare_to_store): Likewise.
	* remote-sim.c (gdbsim_prepare_to_store): Likewise.
	* win32-nat.c (win32_prepare_to_store): Likewise.

	* remote.c (remote_prepare_to_store): Add REGCACHE parameter.
	Use it instead of current_regcache.

	* hpux-thread.c (hpux_thread_prepare_to_store): Add REGCACHE
	parameter.  Pass it on to next target.
	* sol-thread.c (sol_thread_prepare_to_store): Likewise.
@
text
@d399 1
a399 1
      for (r = 0; r < NUM_REGS; r++)
d426 1
a426 1
      for (r = 0; r < NUM_REGS; r++)
d2259 1
a2259 1
  for (r = 0; r < NUM_REGS; r++)
@


1.129
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d2042 1
a2042 1
win32_prepare_to_store (void)
@


1.128
log
@	* gdbcore.h (struct regcache): Add forward declaration.
	(struct core_fns): Add REGCACHE argument to core_read_registers
	callback.
	* corelow.c (get_core_register_section): Add REGCACHE argument,
	use it instead of current_regcache, pass it to core_read_registers
	callback.
	(get_core_registers): Add current_regcache as parameter to
	get_core_register_section calls.

	* alpha-nat.c (fetch_osf_core_registers): Add REGCACHE argument,
	use it instead of current_regcache.
	* armnbsd-nat.c (fetch_core_registers): Likewise.
	(fetch_elfcore_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* cris-tdep.c (fetch_core_registers): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* m68klinux-nat.c (fetch_core_registers): Likewise.
	* mips-linux-tdep.c (fetch_core_registers): Likewise.
	* win32-nat.c (fetch_elf_core_registers): Likewise.
@
text
@d346 1
a346 1
do_win32_fetch_inferior_registers (int r)
d388 1
a388 1
      regcache_raw_supply (current_regcache, r, (char *) &l);
d393 1
a393 1
      regcache_raw_supply (current_regcache, r, (char *) &l);
d396 1
a396 1
    regcache_raw_supply (current_regcache, r, context_offset);
d400 1
a400 1
	do_win32_fetch_inferior_registers (r);
d407 1
a407 1
win32_fetch_inferior_registers (int r)
d413 1
a413 1
    do_win32_fetch_inferior_registers (r);
d417 1
a417 1
do_win32_store_inferior_registers (int r)
d422 1
a422 1
    regcache_raw_collect (current_regcache, r,
d427 1
a427 1
	do_win32_store_inferior_registers (r);
d433 1
a433 1
win32_store_inferior_registers (int r)
d439 1
a439 1
    do_win32_store_inferior_registers (r);
d1321 1
a1321 1
	  win32_fetch_inferior_registers (PS_REGNUM);
@


1.127
log
@	* win32-nat.c (win32_detach): Remove delete_command call.
	Resume inferior with win32_resume instead of win32_continue.
@
text
@d2247 2
a2248 1
fetch_elf_core_registers (char *core_reg_sect,
d2260 1
a2260 1
    regcache_raw_supply (current_regcache, r, core_reg_sect + mappings[r]);
@


1.126
log
@	* win32-nat.c (win32_wait): Reset terminal pgrp to GDB.
	(do_initial_win32_stuff): Call terminal_init_inferior_with_pgrp
	instead of target_terminal_init since inferior_ptid isn't set yet.
@
text
@d1778 3
a1780 2
      delete_command (NULL, 0);
      win32_continue (DBG_CONTINUE, -1);
@


1.125
log
@Copyright updates for 2007.
@
text
@d1545 2
d1592 1
a1592 1
  target_terminal_init ();
@


1.124
log
@	* win32-nat.c (env_sort): Remove.
	(win32_create_inferior): Remove code which creates a Windows
	environment.  Use Cygwin function call instead.  Propagate
	current environment to inferior process.
@
text
@d4 1
a4 2
   2005, 2006
   Free Software Foundation, Inc.
@


1.123
log
@(check in missing file)
* win32-nat.c (cygwin_exceptions): New variable.
(handle_exception): Treat a cygwin exception like a normal exception if
cygwin_exceptions is true.
(_initialize_win32_nat): Add "set cygwin-exceptions" handler.
@
text
@a1844 9
/* Function called by qsort to sort environment strings.  */
static int
env_sort (const void *a, const void *b)
{     
  const char **p = (const char **) a; 
  const char **q = (const char **) b;
  return strcasecmp (*p, *q);
}

a1853 4
  char *winenv;
  char *temp;
  int envlen;
  int i;
d1908 1
a1908 77
  {
    /* This code used to assume all env vars were file names and would
       translate them all to win32 style.  That obviously doesn't work in the
       general case.  The current rule is that we only translate PATH.
       We need to handle PATH because we're about to call CreateProcess and
       it uses PATH to find DLL's.  Fortunately PATH has a well-defined value
       in both posix and win32 environments.  cygwin.dll will change it back
       to posix style if necessary.  */

    static const char *conv_path_names[] =
    {
      "PATH=",
      0
    };

    /* CreateProcess takes the environment list as a null terminated set of
       strings (i.e. two nulls terminate the list).  */

    /* Get total size for env strings.  */
    for (envlen = 0, i = 0; in_env[i] && *in_env[i]; i++)
      {
	int j, len;

	for (j = 0; conv_path_names[j]; j++)
	  {
	    len = strlen (conv_path_names[j]);
	    if (strncmp (conv_path_names[j], in_env[i], len) == 0)
	      {
		if (cygwin_posix_path_list_p (in_env[i] + len))
		  envlen += len
		    + cygwin_posix_to_win32_path_list_buf_size (in_env[i] + len);
		else
		  envlen += strlen (in_env[i]) + 1;
		break;
	      }
	  }
	if (conv_path_names[j] == NULL)
	  envlen += strlen (in_env[i]) + 1;
      }

    size_t envsize = sizeof (in_env[0]) * (i + 1);
    char **env = (char **) alloca (envsize);
    memcpy (env, in_env, envsize);
    /* Windows programs expect the environment block to be sorted.  */
    qsort (env, i, sizeof (char *), env_sort);

    winenv = alloca (envlen + 1);

    /* Copy env strings into new buffer.  */
    for (temp = winenv, i = 0; env[i] && *env[i]; i++)
      {
	int j, len;

	for (j = 0; conv_path_names[j]; j++)
	  {
	    len = strlen (conv_path_names[j]);
	    if (strncmp (conv_path_names[j], env[i], len) == 0)
	      {
		if (cygwin_posix_path_list_p (env[i] + len))
		  {
		    memcpy (temp, env[i], len);
		    cygwin_posix_to_win32_path_list (env[i] + len, temp + len);
		  }
		else
		  strcpy (temp, env[i]);
		break;
	      }
	  }
	if (conv_path_names[j] == NULL)
	  strcpy (temp, env[i]);

	temp += strlen (temp) + 1;
      }

    /* Final nil string to terminate new env.  */
    *temp = 0;
  }
d1938 1
a1938 1
		       winenv,
@


1.122
log
@* win32-nat.c (open_symbol_file_object): New function.
(in_dynsym_resolve_code): Ditto.
(init_win32_ops): Fill in fields which ought not to be NULL.
@
text
@d145 1
d1118 1
a1118 1
	if ((addr >= cygwin_load_start && addr < cygwin_load_end)
d2441 7
@


1.122.6.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a144 1
static int cygwin_exceptions = 0;
d1117 1
a1117 1
	if ((!cygwin_exceptions && (addr >= cygwin_load_start && addr < cygwin_load_end))
a2439 7
  add_setshow_boolean_cmd ("cygwin-exceptions", class_support, &cygwin_exceptions, _("\
Break when an exception is detected in the Cygwin DLL itself."), _("\
Show whether gdb breaks on exceptions in the Cygwin DLL itself."), NULL,
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);

@


1.121
log
@* win32-nat.c (do_win32_fetch_inferior_registers): Don't do anything with saved
context if __COPY_CONTEXT_SIZE is not defined.
(handle_output_debug_string): Ditto.
@
text
@d2348 12
d2407 2
a2408 2
  win32_so_ops.open_symbol_file_object = NULL;
  win32_so_ops.in_dynsym_resolve_code = NULL;
@


1.120
log
@* win32_nat.c (cygwin_load_start): New variable.
(cygwin_load_end): Ditto.
(have_saved_context): Ditto.
(saved_context): Ditto.
(max_dll_name_len): Delete obsolete variable.
(do_win32_fetch_inferior_registers): Use context saved from cygwin1.dll if we
are in a cygwin signal rather than a windows signal.
(solib_symbols_add): Detect and store beginning and end of cygwin DLL if dll
being loaded is the cygwin DLL.
(register_loaded_dll): Remove calculation of max_dll_name_len.
(win32_clear_solib): Ditto.
(handle_load_dll): Delete obsolete variable.  Remove unneeded call to
solib_add.
(handle_output_debug_string): Detect and store signal information sent by
Cygwin here.
(handle_exception): Silently pass on errors in the cygwin DLL.  Return -1 on
first pass exception.
(win32_continue): Remove spurious clearing of continue_status.
(get_win32_debug_event): Deal differently first chance exception.
@
text
@d357 1
d367 1
d933 1
d961 1
@


1.119
log
@	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.

	* gnu-nat.c (gnu_create_inferior): Don't call proceed.
	* go32-nat.c (go32_create_inferior): Likewise.
	* nto-procfs.c (procfs_create_inferior): Likewise.
	* procfs.c (procfs_create_inferior): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Likewise.
	* remote.c (extended_remote_create_inferior)
	(extended_remote_async_create_inferior): Likewise.
	* win32-nat.c (win32_create_inferior): Likewise.
	* wince.c (child_create_inferior): Likewise.

	* monitor.c (monitor_create_inferior): Don't call proceed.
	Set the PC manually.
	* ocd.c (ocd_create_inferior): Likewise.
	* remote-e7000.c (e7000_create_inferior): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior): Likewise.
	* remote-mips.c (mips_create_inferior): Likewise.
	* remote-rdp.c (remote_rdp_create_inferior): Likewise.
	* remote-sds.c (sds_create_inferior): Likewise.
	* remote-st.c (st2000_create_inferior): Likewise.

	* inf-ptrace.c (inf_ptrace_create_inferior): Don't call
	proceed or observer_notify_inferior_created.
	* inf-ttrace.c (inf_ttrace_create_inferior): Likewise.
	* inftarg.c (child_create_inferior): Likewise.
@
text
@d47 1
d67 7
d357 21
a377 10
      thread_info *th = current_thread;
      th->context.ContextFlags = CONTEXT_DEBUGGER_DR;
      GetThreadContext (th->h, &th->context);
      /* Copy dr values from that thread.  */
      dr[0] = th->context.Dr0;
      dr[1] = th->context.Dr1;
      dr[2] = th->context.Dr2;
      dr[3] = th->context.Dr3;
      dr[6] = th->context.Dr6;
      dr[7] = th->context.Dr7;
a617 1

a621 1

d660 1
a680 2

      bfd_close (abfd);
d702 10
a715 3
/* Remember the maximum DLL length for printing in info dll command. */
static int max_dll_name_len;

a758 2
  if (len > max_dll_name_len)
    max_dll_name_len = len;
d761 1
a813 1
  char *p;
a827 1
  solib_add (NULL, 0, NULL, auto_solib_add);
a882 1
  max_dll_name_len = sizeof ("DLL Name") - 1;
d919 2
a920 2
  char *s;
  int gotasig = FALSE;
d925 2
a926 3
    return gotasig;

  if (strncmp (s, _CYGWIN_SIGNAL_STRING, sizeof (_CYGWIN_SIGNAL_STRING) - 1) != 0)
d933 5
d940 1
a940 1
      gotasig = target_signal_from_host (sig);
d943 14
a956 1
	ourstatus->kind = TARGET_WAITKIND_STOPPED;
d959 3
a961 2
  xfree (s);
  return gotasig;
d1105 6
d1112 4
a1115 4
	if (find_pc_partial_function ((CORE_ADDR) current_event.u.Exception
				      .ExceptionRecord.ExceptionAddress,
				      &fn, NULL, NULL)
	    && strncmp (fn, "KERNEL32!IsBad", strlen ("KERNEL32!IsBad")) == 0)
d1192 1
d1194 1
a1194 1
	return 0;
a1221 1
  continue_status = 0;
d1263 81
d1355 1
d1368 1
d1482 13
a1494 4
      if (handle_exception (ourstatus))
	retval = current_event.dwThreadId;
      else
	continue_status = DBG_EXCEPTION_NOT_HANDLED;
d1504 1
a1504 2
      if (handle_output_debug_string (ourstatus))
	retval = main_thread_id;
d1519 6
a1524 1
    CHECK (win32_continue (continue_status, -1));
a2123 81
win32_resume (ptid_t ptid, int step, enum target_signal sig)
{
  thread_info *th;
  DWORD continue_status = DBG_CONTINUE;

  int pid = PIDGET (ptid);

  if (sig != TARGET_SIGNAL_0)
    {
      if (current_event.dwDebugEventCode != EXCEPTION_DEBUG_EVENT)
	{
	  DEBUG_EXCEPT(("Cannot continue with signal %d here.\n",sig));
	}
      else if (sig == last_sig)
	continue_status = DBG_EXCEPTION_NOT_HANDLED;
      else
#if 0
/* This code does not seem to work, because
  the kernel does probably not consider changes in the ExceptionRecord
  structure when passing the exception to the inferior.
  Note that this seems possible in the exception handler itself.  */
	{
	  int i;
	  for (i = 0; xlate[i].them != -1; i++)
	    if (xlate[i].us == sig)
	      {
		current_event.u.Exception.ExceptionRecord.ExceptionCode =
		  xlate[i].them;
		continue_status = DBG_EXCEPTION_NOT_HANDLED;
		break;
	      }
	  if (continue_status == DBG_CONTINUE)
	    {
	      DEBUG_EXCEPT(("Cannot continue with signal %d.\n",sig));
	    }
	}
#endif
	DEBUG_EXCEPT(("Can only continue with recieved signal %d.\n",
	  last_sig));
    }

  last_sig = TARGET_SIGNAL_0;

  DEBUG_EXEC (("gdb: win32_resume (pid=%d, step=%d, sig=%d);\n",
	       pid, step, sig));

  /* Get context for currently selected thread */
  th = thread_rec (current_event.dwThreadId, FALSE);
  if (th)
    {
      if (step)
	{
	  /* Single step by setting t bit */
	  win32_fetch_inferior_registers (PS_REGNUM);
	  th->context.EFlags |= FLAG_TRACE_BIT;
	}

      if (th->context.ContextFlags)
	{
	  if (debug_registers_changed)
	    {
	      th->context.Dr0 = dr[0];
	      th->context.Dr1 = dr[1];
	      th->context.Dr2 = dr[2];
	      th->context.Dr3 = dr[3];
	      /* th->context.Dr6 = dr[6];
	       FIXME: should we set dr6 also ?? */
	      th->context.Dr7 = dr[7];
	    }
	  CHECK (SetThreadContext (th->h, &th->context));
	  th->context.ContextFlags = 0;
	}
    }

  /* Allow continuing with the same signal that interrupted us.
     Otherwise complain. */

  win32_continue (continue_status, pid);
}

static void
@


1.118
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 2
a4 1
   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
a1912 1
  proceed ((CORE_ADDR) - 1, TARGET_SIGNAL_0, 0);
@


1.117
log
@* win32-nat.c (env_sort): New function.
(win32_create_inferior): Rename env to in_env.  Sort environment before handing
it off to CreateProcess.
(win32_current_sos): Quiet a compiler warning.
@
text
@d3 1
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.116
log
@* win32-nat.c (CYGWIN_SIGNAL_STRING): Delete.
(_CYGWIN_SIGNAL_STRING): Define if not already defined in cygwin.h.
(win32_add_thread): Use XZALLOC rather than xmalloc/memset.
(register_loaded_dll): Ditto.
(handle_load_dll): Call solib_add here.
(handle_unload_dll): Ditto.
(info_dll_command): Delete.
(handle_output_debug_string): Use official _CYGWIN_SIGNAL_STRING.
(win32_current_sos): Duplicate table to pass off to caller rather than deleting
our version.
(set_win32_aliases): New function.
(_initialize_win32_nat): Remove local handling of "info shared".  Set
deprecated_init_ui_hook to allow late setting of "info dll" alias.
@
text
@d1700 9
d1715 1
a1715 1
win32_create_inferior (char *exec_file, char *allargs, char **env,
d1795 1
a1795 1
    for (envlen = 0, i = 0; env[i] && *env[i]; i++)
d1802 1
a1802 1
	    if (strncmp (conv_path_names[j], env[i], len) == 0)
d1804 1
a1804 1
		if (cygwin_posix_path_list_p (env[i] + len))
d1806 1
a1806 1
		    + cygwin_posix_to_win32_path_list_buf_size (env[i] + len);
d1808 1
a1808 1
		  envlen += strlen (env[i]) + 1;
d1813 1
a1813 1
	  envlen += strlen (env[i]) + 1;
d1816 6
d2244 1
a2244 1
  struct so_list *last;
@


1.116.4.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d1897 1
@


1.115
log
@* win32-nat.c (get_relocated_section_addrs): Reinstate.
(solib_symbols_add): New function.
(lm_info): Remove end_addr field.
(register_loaded_dll): Don't try to find end_addr since gdb will do this
automatically now.  Make so_original_name == so_name for now.  Eliminate strcpy
by using so_name directly.  Read in symbols if new paramater "readsyms" is
true.
(handle_load_dll): Pass auto_solib_add to register_loaded_dll to control when
symbols should be read.
(win32_free_so): Don't free objfile here.
(win32_create_inferior_hook): New function.
(handle_unload_dll): Remove left-over cruft.
(win32_special_symbol_handling): New (dummy) function.
(map_single_dll_code_section): Reinstate.
(dll_code_sections_add): Reinstate.
(core_section_load_dll_symbols): Reinstate.  Don't issue an error on duplicate
attempts to read same dll.  Make sure that UNIX-like name is used to register
DLL.
(win32_current_sos): Handle core files.  Reset private list before passing
start of list pointer to gdb.
(init_win32_ops): Fill out (currently unused) solib_create_inferior_hook.  Fill
out special_symbol_handling.
* config/i386/tm-cygwin.h: Remove most special solib stuff.
@
text
@d87 3
a89 1
#define CYGWIN_SIGNAL_STRING "cygwin: signal"
d268 1
a268 2
  th = (thread_info *) xmalloc (sizeof (*th));
  memset (th, 0, sizeof (*th));
d726 1
a726 2
  so = (struct so_list *) xmalloc (sizeof (struct so_list));
  memset (so, 0, sizeof (*so));
d806 1
d847 1
d850 1
a892 16
/* List currently loaded DLLs. */
static void
info_dll_command (char *ignore, int from_tty)
{
  struct so_list *so = &solib_start;

  if (!so->next)
    return;

  printf_filtered ("%*s  Load Address\n", -max_dll_name_len, "DLL Name");
  while ((so = so->next) != NULL)
    printf_filtered ("%*s  %08lx\n", -max_dll_name_len, so->so_name, so->lm_info->load_addr);

  return;
}

d907 1
a907 1
  if (strncmp (s, CYGWIN_SIGNAL_STRING, sizeof (CYGWIN_SIGNAL_STRING) - 1) != 0)
d915 1
a915 1
      int sig = strtol (s + sizeof (CYGWIN_SIGNAL_STRING) - 1, &p, 0);
d2227 5
a2231 3
  struct so_list *head = solib_start.next;
  win32_clear_solib ();
  if (!head && core_bfd)
d2233 1
a2235 2
      head = solib_start.next;
      win32_clear_solib ();
d2237 16
a2252 1
  return head;
d2325 6
a2393 3
  add_info ("dll", info_dll_command, _("Status of loaded DLLs."));
  add_info_alias ("sharedlibrary", "dll", 1);

d2402 1
@


1.114
log
@* win32-nat.c: Remove comment intended only for debugging.
@
text
@d57 1
a520 1
  DWORD end_addr;
d580 108
d691 2
a692 2
static void
register_loaded_dll (const char *name, DWORD load_addr)
a694 1
  char ppath[MAX_PATH + 1];
d725 1
a725 2
  cygwin_conv_to_posix_path (buf, ppath);
  so = (struct so_list *) xmalloc (sizeof (struct so_list) + strlen (ppath) + 8 + 1);
d729 2
a730 8
  if (VirtualQueryEx (current_process_handle, (void *) load_addr, &m,
		      sizeof (m)))
    so->lm_info->end_addr = (DWORD) m.AllocationBase + m.RegionSize;
  else
    so->lm_info->end_addr = load_addr + 0x2000;	/* completely arbitrary */

  so->next = NULL;
  strcpy (so->so_name, ppath);
d734 1
a734 1
  len = strlen (ppath);
d737 3
d805 1
a805 1
  register_loaded_dll (dll_name, (DWORD) event->lpBaseOfDll + 0x1000);
a812 2
  if (so->objfile)
    free_objfile (so->objfile);
d817 3
a819 2
static struct so_list *
win32_current_sos (void)
d821 2
a822 1
  return solib_start.next;
d826 1
a826 2
win32_relocate_section_addresses (struct so_list *so,
				  struct section_table *sec)
d828 1
a828 1
  /* FIXME */
a856 2
  struct so_list *so, *so1 = solib_start.next;

d862 6
d1684 1
a1684 1
                       cygwin_internal (CW_GETPINFO, cpid | CW_NEXTPID));
d1689 3
a1691 3
         cygwin_conv_to_full_posix_path (pinfo->progname, path);
         path_ptr = path; 
         break;
d1695 1
a1695 1
  return path_ptr; 
d2096 172
d2312 2
a2313 2
  win32_so_ops.solib_create_inferior_hook = NULL;
  win32_so_ops.special_symbol_handling = NULL;
a2445 16
static void
fetch_elf_core_registers (char *core_reg_sect,
			  unsigned core_reg_size,
			  int which,
			  CORE_ADDR reg_addr)
{
  int r;
  if (core_reg_size < sizeof (CONTEXT))
    {
      error (_("Core file register section too small (%u bytes)."), core_reg_size);
      return;
    }
  for (r = 0; r < NUM_REGS; r++)
    regcache_raw_supply (current_regcache, r, core_reg_sect + mappings[r]);
}

@


1.113
log
@Change child_ to win32_ throughout.
* win32-nat.c (win32_ops): New variable.
(win32_so_ops): Ditto.
(psapi_get_dll_name): Make function static.
(struct so_stuff): Delete.
(struct lm_info): New struct.
(solib_start, solib_end): Redefine as struct so_list.
(safe_symbol_file_add_stub): Use so_list rather than so_stuff.
(register_loaded_dll): Ditto.  Special-case ntdll.dll.  Fill in lm_info field
of so_list with information previously stored in so_stuff.
(get_image_name): Make function static.
(max_dll_name_len): Make variable static.
(win32_free_so): New function.
(win32_current_sos): Ditto.
(win32_relocate_section_addresses): Ditto.
(handle_unload_dll): Use so_list rather than so_stuff.  Call free_so to delete
shared library.
(solib_address): Delete function.
(child_solib_loaded_library_pathname): Ditto.
(win32_clear_solib): Rename from child_clear_solibs.  Use so_list rather than
so_stuff.  Just clear win32-specific stuff.
(get_relocated_section_addrs): Delete.
(solib_symbols_add): Ditto.
(info_dll_command): Make static.  Use lm_info field from so_list to retrieve
load address.
(fake_create_process): Make function static.
(win32_xfer_memory): Ditto.
(win32_kill_inferior): Ditto.
(win32_resume): Ditto.
(cygwin_pid_to_str): Ditto.
(do_initial_win32_stuff): Use win32_ops rather than deprecated_child_ops.
(child_detach): Ditto.
(win32_mourn_inferior): Ditto.
(_initialize_win32_nat): Ditto.
(init_win32_ops): Ditto.  Fill out win32_so_ops and set current_target_so_ops
to win32_so_ops.
(core_dll_symbols_add): Delete.
(map_single_dll_code_section): Ditto.
(dll_code_sections_add): Ditto.
(core_section_load_dll_symbols): Ditto.
(child_solib_add): Ditto.
@
text
@a515 1
/*CGF*/
@


1.112
log
@Index: gdb/ChangeLog
+2005-07-06  Bob Rossi  <bob@@brasko.net>
+
+	* fork-child.c (fork-inferior): Use accessor function for
+	inferior_io_terminal.
+	* infcmd.c (inferior_io_terminal): Make static.
+	(set_inferior_io_terminal): New function.
+	(get_inferior_io_terminal): Ditto.
+	(tty_command): Use accessor function.
+	(_initialize_infcmd): Add inferior_tty setshow variable.
+	(_initialize_infcmd): Remove tty command.
+	(_initialize_infcmd): Add a tty command that is an alias.
+	* inferior.h (set_inferior_io_terminal): New prototype.
+	(get_inferior_io_terminal): Ditto.
+	(new_tty_prefork): Add const qualifier to parameter.
+	* inflow.c (inferior_thisrun_terminal): Add const qualifier.
+	(new_tty_prefork): Add const qualifier to parameter.
+	* nto-procfs (procfs_create_inferior): Use accessor function.
+	(procfs_create_inferior): Add const qualifier to locals.
+	* win32-nat.c (child_create_inferior): Ditto.
+	* mi/mi-cmd-env.c (mi_cmd_inferior_tty_set): New function.
+	(mi_cmd_inferior_tty_set): Ditto.
+	* mi/mi-cmds.c (mi_cmds): Add inferior-tty-set and inferior-tty-show
+	* mi/mi-cmds.h (mi_cmd_inferior_tty_set): Add prototype.
+	(mi_cmd_inferior_tty_show): Ditto.

Index: gdb/doc/ChangeLog
+2005-07-06  Bob Rossi  <bob@@brasko.net>
+
+	* gdb.texinfo (GDB/MI Miscellaneous Commands): Add -inferior-tty-set
+	and -inferior-tty-show.
+	(Input/Output): Document "set/show inferior-tty" and tty alias.

Index: gdb/testsuite/ChangeLog
+2005-07-06  Bob Rossi  <bob@@brasko.net>
+
+	* gdb.mi/mi-basics.exp (test_setshow_inferior_tty): Test MI tty
+	command.
+	(Copyright): Update copyright.
@
text
@d56 1
d61 3
d94 3
a96 3
static void child_stop (void);
static int win32_child_thread_alive (ptid_t);
void child_kill_inferior (void);
d258 1
a258 1
child_add_thread (DWORD id, HANDLE h)
d294 1
a294 1
child_init_thread_list (void)
d298 1
a298 1
  DEBUG_EVENTS (("gdb: child_init_thread_list\n"));
d312 1
a312 1
child_delete_thread (DWORD id)
d335 1
a335 1
do_child_fetch_inferior_registers (int r)
d376 1
a376 1
	do_child_fetch_inferior_registers (r);
d383 1
a383 1
child_fetch_inferior_registers (int r)
d389 1
a389 1
    do_child_fetch_inferior_registers (r);
d393 1
a393 1
do_child_store_inferior_registers (int r)
d403 1
a403 1
	do_child_store_inferior_registers (r);
d409 1
a409 1
child_store_inferior_registers (int r)
d415 1
a415 1
    do_child_store_inferior_registers (r);
d424 1
a424 1
int
d516 1
d518 1
a518 1
struct so_stuff
a519 1
  struct so_stuff *next;
d522 3
a524 4
  int loaded;
  struct objfile *objfile;
  char name[1];
} solib_start, *solib_end;
d531 2
a532 2
#define p ((struct safe_symbol_file_add_args *)argv)
  struct so_stuff *so = &solib_start;
a533 3
  while ((so = so->next))
    if (so->loaded && strcasecmp (so->name, p->name) == 0)
      return 0;
d582 1
a582 1
int max_dll_name_len;
d587 1
a587 1
  struct so_stuff *so;
d614 5
d620 4
a623 3
  so = (struct so_stuff *) xmalloc (sizeof (struct so_stuff) + strlen (ppath) + 8 + 1);
  so->loaded = 0;
  so->load_addr = load_addr;
d626 1
a626 1
    so->end_addr = (DWORD) m.AllocationBase + m.RegionSize;
d628 1
a628 1
    so->end_addr = load_addr + 0x2000;	/* completely arbitrary */
d631 1
a631 2
  so->objfile = NULL;
  strcpy (so->name, ppath);
d640 1
a640 1
char *
d708 23
d735 1
a735 1
  struct so_stuff *so;
d738 1
a738 1
    if (so->next->load_addr == lpBaseOfDll)
d740 1
a740 1
	struct so_stuff *sodel = so->next;
d744 1
a744 3
	if (sodel->objfile)
	  free_objfile (sodel->objfile);
	xfree(sodel);
a751 17
char *
solib_address (CORE_ADDR address)
{
  struct so_stuff *so;
  for (so = &solib_start; so->next != NULL; so = so->next)
    if (address >= so->load_addr && address <= so->end_addr)
      return so->name;
  return NULL;
}

/* Return name of last loaded DLL. */
char *
child_solib_loaded_library_pathname (int pid)
{
  return !solib_end || !solib_end->name[0] ? NULL : solib_end->name;
}

d753 2
a754 2
void
child_clear_solibs (void)
d756 1
a756 7
  struct so_stuff *so, *so1 = solib_start.next;

  while ((so = so1) != NULL)
    {
      so1 = so->next;
      xfree (so);
    }
a758 1
  solib_start.objfile = NULL;
a762 108
/* Get the loaded address of all sections, given that .text was loaded
   at text_load. Assumes that all sections are subject to the same
   relocation offset. Returns NULL if problems occur or if the
   sections were not relocated. */

static struct section_addr_info *
get_relocated_section_addrs (bfd *abfd, CORE_ADDR text_load)
{
  struct section_addr_info *result = NULL;
  int section_count = bfd_count_sections (abfd);
  asection *text_section = bfd_get_section_by_name (abfd, ".text");
  CORE_ADDR text_vma;

  if (!text_section)
    {
      /* Couldn't get the .text section. Weird. */
    }

  else if (text_load == (text_vma = bfd_get_section_vma (abfd, text_section)))
    {
      /* DLL wasn't relocated. */
    }

  else
    {
      /* Figure out all sections' loaded addresses. The offset here is
	 such that taking a bfd_get_section_vma() result and adding
	 offset will give the real load address of the section. */

      CORE_ADDR offset = text_load - text_vma;

      struct section_table *table_start = NULL;
      struct section_table *table_end = NULL;
      struct section_table *iter = NULL;

      build_section_table (abfd, &table_start, &table_end);

      for (iter = table_start; iter < table_end; ++iter)
	{
	  /* Relocated addresses. */
	  iter->addr += offset;
	  iter->endaddr += offset;
	}

      result = build_section_addr_info_from_section_table (table_start,
							   table_end);

      xfree (table_start);
    }

  return result;
}

/* Add DLL symbol information. */
static struct objfile *
solib_symbols_add (char *name, int from_tty, CORE_ADDR load_addr)
{
  struct section_addr_info *addrs = NULL;
  static struct objfile *result = NULL;
  bfd *abfd = NULL;

  /* The symbols in a dll are offset by 0x1000, which is the
     the offset from 0 of the first byte in an image - because
     of the file header and the section alignment. */

  if (!name || !name[0])
    return NULL;

  abfd = bfd_openr (name, "pei-i386");

  if (!abfd)
    {
      /* pei failed - try pe */
      abfd = bfd_openr (name, "pe-i386");
    }

  if (abfd)
    {
      if (bfd_check_format (abfd, bfd_object))
	{
	  addrs = get_relocated_section_addrs (abfd, load_addr);
	}

      bfd_close (abfd);
    }

  if (addrs)
    {
      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
      free_section_addr_info (addrs);
    }
  else
    {
      /* Fallback on handling just the .text section. */
      struct cleanup *my_cleanups;

      addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, addrs);
      addrs->other[0].name = ".text";
      addrs->other[0].addr = load_addr;

      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
      do_cleanups (my_cleanups);
    }

  return result;
}

d786 1
a786 1
void
d789 1
a789 1
  struct so_stuff *so = &solib_start;
d796 1
a796 1
    printf_filtered ("%*s  %08lx\n", -max_dll_name_len, so->name, so->load_addr);
d1072 1
a1072 1
child_continue (DWORD continue_status, int id)
d1116 1
a1116 1
DWORD
d1122 1
a1122 1
  current_thread = child_add_thread (main_thread_id,
d1131 1
a1131 1
get_child_debug_event (int pid, struct target_waitstatus *ourstatus)
d1171 1
a1171 1
      th = child_add_thread (current_event.dwThreadId,
d1187 1
a1187 1
	  child_delete_thread (current_event.dwThreadId);
d1206 1
a1206 1
	child_delete_thread (main_thread_id);
d1209 1
a1209 1
      th = child_add_thread (main_thread_id,
d1292 1
a1292 1
    CHECK (child_continue (continue_status, -1));
d1305 1
a1305 1
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
d1317 1
a1317 1
      int retval = get_child_debug_event (pid, ourstatus);
d1328 1
a1328 1
	    child_kill_inferior ();
d1334 1
a1334 1
do_initial_child_stuff (DWORD pid)
d1348 1
a1348 1
  push_target (&deprecated_child_ops);
d1350 1
a1350 1
  child_clear_solibs ();
d1460 1
a1460 1
     child_attach(). */
d1478 1
a1478 1
child_attach (char *args, int from_tty)
d1494 1
a1494 1
  child_init_thread_list ();
d1529 1
a1529 1
  do_initial_child_stuff (pid);
d1534 1
a1534 1
child_detach (char *args, int from_tty)
d1541 1
a1541 1
      child_continue (DBG_CONTINUE, -1);
d1560 1
a1560 1
  unpush_target (&deprecated_child_ops);
d1563 2
a1564 2
char *
child_pid_to_exec_file (int pid)
d1596 1
a1596 1
child_files_info (struct target_ops *ignore)
d1603 1
a1603 1
child_open (char *arg, int from_tty)
d1614 1
a1614 1
child_create_inferior (char *exec_file, char *allargs, char **env,
d1768 1
a1768 1
  child_init_thread_list ();
d1802 1
a1802 1
  do_initial_child_stuff (pi.dwProcessId);
d1804 1
a1804 1
  /* child_continue (DBG_CONTINUE, -1); */
d1809 1
a1809 1
child_mourn_inferior (void)
d1811 1
a1811 1
  (void) child_continue (DBG_CONTINUE, -1);
d1813 1
a1813 1
  unpush_target (&deprecated_child_ops);
d1821 1
a1821 1
child_stop (void)
d1828 2
a1829 2
int
child_xfer_memory (CORE_ADDR memaddr, gdb_byte *our, int len,
d1854 2
a1855 2
void
child_kill_inferior (void)
d1861 1
a1861 1
      if (!child_continue (DBG_CONTINUE, -1))
d1874 1
a1874 1
  target_mourn_inferior ();	/* or just child_mourn_inferior? */
d1877 2
a1878 2
void
child_resume (ptid_t ptid, int step, enum target_signal sig)
d1921 1
a1921 1
  DEBUG_EXEC (("gdb: child_resume (pid=%d, step=%d, sig=%d);\n",
d1931 1
a1931 1
	  child_fetch_inferior_registers (PS_REGNUM);
d1955 1
a1955 1
  child_continue (continue_status, pid);
d1959 1
a1959 1
child_prepare_to_store (void)
d1965 1
a1965 1
child_can_run (void)
d1971 1
a1971 1
child_close (int x)
d1973 1
a1973 1
  DEBUG_EVENTS (("gdb: child_close, inferior_ptid=%d\n",
d1977 14
d1992 1
a1992 1
init_child_ops (void)
d1994 49
a2042 37
  deprecated_child_ops.to_shortname = "child";
  deprecated_child_ops.to_longname = "Win32 child process";
  deprecated_child_ops.to_doc = "Win32 child process (started by the \"run\" command).";
  deprecated_child_ops.to_open = child_open;
  deprecated_child_ops.to_close = child_close;
  deprecated_child_ops.to_attach = child_attach;
  deprecated_child_ops.to_detach = child_detach;
  deprecated_child_ops.to_resume = child_resume;
  deprecated_child_ops.to_wait = child_wait;
  deprecated_child_ops.to_fetch_registers = child_fetch_inferior_registers;
  deprecated_child_ops.to_store_registers = child_store_inferior_registers;
  deprecated_child_ops.to_prepare_to_store = child_prepare_to_store;
  deprecated_child_ops.deprecated_xfer_memory = child_xfer_memory;
  deprecated_child_ops.to_files_info = child_files_info;
  deprecated_child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  deprecated_child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  deprecated_child_ops.to_terminal_init = terminal_init_inferior;
  deprecated_child_ops.to_terminal_inferior = terminal_inferior;
  deprecated_child_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  deprecated_child_ops.to_terminal_ours = terminal_ours;
  deprecated_child_ops.to_terminal_save_ours = terminal_save_ours;
  deprecated_child_ops.to_terminal_info = child_terminal_info;
  deprecated_child_ops.to_kill = child_kill_inferior;
  deprecated_child_ops.to_create_inferior = child_create_inferior;
  deprecated_child_ops.to_mourn_inferior = child_mourn_inferior;
  deprecated_child_ops.to_can_run = child_can_run;
  deprecated_child_ops.to_thread_alive = win32_child_thread_alive;
  deprecated_child_ops.to_pid_to_str = cygwin_pid_to_str;
  deprecated_child_ops.to_stop = child_stop;
  deprecated_child_ops.to_stratum = process_stratum;
  deprecated_child_ops.to_has_all_memory = 1;
  deprecated_child_ops.to_has_memory = 1;
  deprecated_child_ops.to_has_stack = 1;
  deprecated_child_ops.to_has_registers = 1;
  deprecated_child_ops.to_has_execution = 1;
  deprecated_child_ops.to_magic = OPS_MAGIC;
  deprecated_child_ops.to_pid_to_exec_file = child_pid_to_exec_file;
d2050 1
a2050 1
  init_child_ops ();
d2118 1
a2118 2

  add_target (&deprecated_child_ops);
d2125 1
a2125 1
   actually set up when child_continue is called.  */
d2139 1
a2139 1
   will be actually set up in child_wait.  */
d2161 1
a2161 1
win32_child_thread_alive (ptid_t ptid)
a2168 200
/* Convert pid to printable format. */
char *
cygwin_pid_to_str (ptid_t ptid)
{
  static char buf[80];
  int pid = PIDGET (ptid);

  if ((DWORD) pid == current_event.dwProcessId)
    sprintf (buf, "process %d", pid);
  else
    sprintf (buf, "thread %ld.0x%x", current_event.dwProcessId, pid);
  return buf;
}

static int
core_dll_symbols_add (char *dll_name, DWORD base_addr)
{
  struct objfile *objfile;
  char *objfile_basename;
  const char *dll_basename;

  if (!(dll_basename = strrchr (dll_name, '/')))
    dll_basename = dll_name;
  else
    dll_basename++;

  ALL_OBJFILES (objfile)
  {
    objfile_basename = strrchr (objfile->name, '/');

    if (objfile_basename &&
	strcmp (dll_basename, objfile_basename + 1) == 0)
      {
	printf_unfiltered ("%08lx:%s (symbols previously loaded)\n",
			   base_addr, dll_name);
	goto out;
      }
  }

  register_loaded_dll (dll_name, base_addr + 0x1000);
  solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);

 out:
  return 1;
}

typedef struct
{
  struct target_ops *target;
  bfd_vma addr;
} map_code_section_args;

static void
map_single_dll_code_section (bfd * abfd, asection * sect, void *obj)
{
  int old;
  int update_coreops;
  struct section_table *new_target_sect_ptr;

  map_code_section_args *args = (map_code_section_args *) obj;
  struct target_ops *target = args->target;
  if (sect->flags & SEC_CODE)
    {
      update_coreops = core_ops.to_sections == target->to_sections;

      if (target->to_sections)
	{
	  old = target->to_sections_end - target->to_sections;
	  target->to_sections = (struct section_table *)
	    xrealloc ((char *) target->to_sections,
		      (sizeof (struct section_table)) * (1 + old));
	}
      else
	{
	  old = 0;
	  target->to_sections = (struct section_table *)
	    xmalloc ((sizeof (struct section_table)));
	}
      target->to_sections_end = target->to_sections + (1 + old);

      /* Update the to_sections field in the core_ops structure
	 if needed.  */
      if (update_coreops)
	{
	  core_ops.to_sections = target->to_sections;
	  core_ops.to_sections_end = target->to_sections_end;
	}
      new_target_sect_ptr = target->to_sections + old;
      new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
      new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	bfd_section_size (abfd, sect);;
      new_target_sect_ptr->the_bfd_section = sect;
      new_target_sect_ptr->bfd = abfd;
    }
}

static int
dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
{
  bfd *dll_bfd;
  map_code_section_args map_args;
  asection *lowest_sect;
  char *name;
  if (dll_name == NULL || target == NULL)
    return 0;
  name = xstrdup (dll_name);
  dll_bfd = bfd_openr (name, "pei-i386");
  if (dll_bfd == NULL)
    return 0;

  if (bfd_check_format (dll_bfd, bfd_object))
    {
      lowest_sect = bfd_get_section_by_name (dll_bfd, ".text");
      if (lowest_sect == NULL)
	return 0;
      map_args.target = target;
      map_args.addr = base_addr - bfd_section_vma (dll_bfd, lowest_sect);

      bfd_map_over_sections (dll_bfd, &map_single_dll_code_section, (void *) (&map_args));
    }

  return 1;
}

static void
core_section_load_dll_symbols (bfd * abfd, asection * sect, void *obj)
{
  struct target_ops *target = (struct target_ops *) obj;

  DWORD base_addr;

  int dll_name_size;
  char *dll_name = NULL;
  char *buf = NULL;
  struct win32_pstatus *pstatus;
  char *p;

  if (strncmp (sect->name, ".module", 7))
    return;

  buf = (char *) xmalloc (bfd_get_section_size (sect) + 1);
  if (!buf)
    {
      printf_unfiltered ("memory allocation failed for %s\n", sect->name);
      goto out;
    }
  if (!bfd_get_section_contents (abfd, sect, buf, 0, bfd_get_section_size (sect)))
    goto out;

  pstatus = (struct win32_pstatus *) buf;

  memmove (&base_addr, &(pstatus->data.module_info.base_address), sizeof (base_addr));
  dll_name_size = pstatus->data.module_info.module_name_size;
  if (offsetof (struct win32_pstatus, data.module_info.module_name) + dll_name_size > bfd_get_section_size (sect))
      goto out;

  dll_name = (char *) xmalloc (dll_name_size + 1);
  if (!dll_name)
    {
      printf_unfiltered ("memory allocation failed for %s\n", sect->name);
      goto out;
    }
  strncpy (dll_name, pstatus->data.module_info.module_name, dll_name_size);

  while ((p = strchr (dll_name, '\\')))
    *p = '/';

  if (!core_dll_symbols_add (dll_name, (DWORD) base_addr))
    printf_unfiltered ("%s: Failed to load dll symbols.\n", dll_name);

  if (!dll_code_sections_add (dll_name, (DWORD) base_addr + 0x1000, target))
    printf_unfiltered ("%s: Failed to map dll code sections.\n", dll_name);

out:
  if (buf)
    xfree (buf);
  if (dll_name)
    xfree (dll_name);
  return;
}

void
child_solib_add (char *filename, int from_tty, struct target_ops *target,
		 int readsyms)
{
  if (!readsyms)
    return;
  if (core_bfd)
    {
      child_clear_solibs ();
      bfd_map_over_sections (core_bfd, &core_section_load_dll_symbols, target);
    }
  else
    {
      if (solib_end && solib_end->name)
	     solib_end->objfile = solib_symbols_add (solib_end->name, from_tty,
						solib_end->load_addr);
    }
}

@


1.112.2.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d1911 1
@


1.111
log
@2005-05-23  Andrew Cagney  <cagney@@gnu.org>

	* target.h (child_xfer_memory): Use gdb_byte for byte buffer
	parameters.
	* inftarg.c (child_xfer_partial): Update.
	* wince.c (child_xfer_memory): Update.
	* win32-nat.c (child_xfer_memory): Update.
	* rs6000-nat.c (child_xfer_memory): Update.
	* infptrace.c (child_xfer_memory): Update.
	* dcache.c (struct dcache_block): Use gdb_byte for the byte
	buffers.
	(dcache_read_line, dcache_xfer_memory, dcache_poke_byte)
	(dcache_peek_byte, dcache_write_line): Ditto.
@
text
@d1738 1
@


1.110
log
@* win32-nat.c (handle_exception): Treat win32 routines which check for valid
addresses as "special" and don't stop when a SEGV is detected.
(get_child_debug_event): Properly flag exception as unhandled.
@
text
@d1934 1
a1934 1
child_xfer_memory (CORE_ADDR memaddr, char *our, int len,
@


1.109
log
@* win32-nat.c (do_initial_child_stuff): Don't clear the thread list here.
(do_initial_child_stuff): Move clearing of thread list to a place before a
thread ould be created.
(child_attach): Ditto.
@
text
@d1080 8
d1371 2
@


1.108
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@a1444 1
  child_init_thread_list ();
d1590 1
d1863 1
@


1.107
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d2126 49
a2174 48
  deprecated_add_show_from_set
    (add_set_cmd ("shell", class_support, var_boolean,
		  (char *) &useshell,
		  "Set use of shell to start subprocess.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("new-console", class_support, var_boolean,
		  (char *) &new_console,
		  "Set creation of new console when creating child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("new-group", class_support, var_boolean,
		  (char *) &new_group,
		  "Set creation of new group when creating child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugexec", class_support, var_boolean,
		  (char *) &debug_exec,
		  "Set whether to display execution in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugevents", class_support, var_boolean,
		  (char *) &debug_events,
		  "Set whether to display kernel events in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugmemory", class_support, var_boolean,
		  (char *) &debug_memory,
		  "Set whether to display memory accesses in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugexceptions", class_support, var_boolean,
		  (char *) &debug_exceptions,
		  "Set whether to display kernel exceptions in child process.",
		  &setlist),
     &showlist);
@


1.106
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d2121 1
a2121 1
	       "Load dll library symbols from FILE.");
d2175 1
a2175 1
  add_info ("dll", info_dll_command, "Status of loaded DLLs.");
d2179 1
a2179 1
		  "Print information specific to Win32 debugging.",
@


1.105
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2183 1
a2183 1
	   "Display selectors infos.",
@


1.104
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d1581 1
a1581 1
    error_no_arg ("process-id to attach");
d2199 1
a2199 1
		    "Invalid register %d in cygwin_set_dr.\n", i);
@


1.103
log
@* win32-nat.c: Update copyright year.
(child_init_thread_list): Set thread linked list point to NULL so that it won't
be reused after clearing.
@
text
@d481 1
a481 1
	error ("Can't get module info");
d488 1
a488 1
	error ("Error getting dll name: %u\n", (unsigned) GetLastError ());
d721 1
a721 1
  error ("Error: dll starting at 0x%lx not found.\n", (DWORD) lpBaseOfDll);
d877 1
a877 1
    error ("dll-symbols requires a file name");
d924 1
a924 1
	warning ("%s", s);
d1603 1
a1603 1
	error ("Can't attach to process.");
d1640 1
a1640 1
	  error ("Can't detach process %lu (error %lu)",
d1701 1
a1701 1
  error ("Use the \"run\" command to start a Unix child process.");
d1730 1
a1730 1
    error ("No executable specified, use `target exec'.\n");
d1885 2
a1886 1
    error ("Error creating process %s, (error %d)\n", exec_file, (unsigned) GetLastError ());
d2446 1
a2446 1
      error ("Core file register section too small (%u bytes).", core_reg_size);
d2492 1
a2492 1
	  warning ("obsolete '%s' found. Rename to '%s'.", oldini, newini);
@


1.102
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d3 1
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d303 1
@


1.101
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d33 1
@


1.100
log
@2004-10-05  Andrew Cagney  <cagney@@gnu.org>

	* target.h (deprecated_child_ops): Rename child_ops.
	* wince.c: Update copyright.  Rename child_ops.
	* win32-nat.c: Rename child_ops.
	* target.c: Rename child_ops.
	* rs6000-nat.c: Rename child_ops.
	* linux-nat.c: Rename child_ops.
	* infttrace.c: Rename child_ops.
	* inftarg.c: Rename child_ops.
	* infptrace.c: Rename child_ops.
	* hppah-nat.c: Update copyright.  Rename child_ops.
	* hpux-thread.c: Update copyright.  Rename child_ops.
@
text
@d2083 1
a2083 1
  deprecated_child_ops.to_xfer_memory = child_xfer_memory;
@


1.99
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* wince.c (child_ops): Delete.
	* win32-nat.c (child_ops): Delete.
@
text
@d1442 1
a1442 1
  push_target (&child_ops);
d1654 1
a1654 1
  unpush_target (&child_ops);
d1904 1
a1904 1
  unpush_target (&child_ops);
d2071 37
a2107 37
  child_ops.to_shortname = "child";
  child_ops.to_longname = "Win32 child process";
  child_ops.to_doc = "Win32 child process (started by the \"run\" command).";
  child_ops.to_open = child_open;
  child_ops.to_close = child_close;
  child_ops.to_attach = child_attach;
  child_ops.to_detach = child_detach;
  child_ops.to_resume = child_resume;
  child_ops.to_wait = child_wait;
  child_ops.to_fetch_registers = child_fetch_inferior_registers;
  child_ops.to_store_registers = child_store_inferior_registers;
  child_ops.to_prepare_to_store = child_prepare_to_store;
  child_ops.to_xfer_memory = child_xfer_memory;
  child_ops.to_files_info = child_files_info;
  child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  child_ops.to_terminal_init = terminal_init_inferior;
  child_ops.to_terminal_inferior = terminal_inferior;
  child_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  child_ops.to_terminal_ours = terminal_ours;
  child_ops.to_terminal_save_ours = terminal_save_ours;
  child_ops.to_terminal_info = child_terminal_info;
  child_ops.to_kill = child_kill_inferior;
  child_ops.to_create_inferior = child_create_inferior;
  child_ops.to_mourn_inferior = child_mourn_inferior;
  child_ops.to_can_run = child_can_run;
  child_ops.to_thread_alive = win32_child_thread_alive;
  child_ops.to_pid_to_str = cygwin_pid_to_str;
  child_ops.to_stop = child_stop;
  child_ops.to_stratum = process_stratum;
  child_ops.to_has_all_memory = 1;
  child_ops.to_has_memory = 1;
  child_ops.to_has_stack = 1;
  child_ops.to_has_registers = 1;
  child_ops.to_has_execution = 1;
  child_ops.to_magic = OPS_MAGIC;
  child_ops.to_pid_to_exec_file = child_pid_to_exec_file;
d2183 1
a2183 1
  add_target (&child_ops);
@


1.98
log
@2004-09-29  Andrew Cagney  <cagney@@gnu.org>

	* target.h (child_ops): Declare.
	* inftarg.c (child_ops): Move from here ...
	* target.c (child_ops): ... to here.
	* wince.c (child_ops): Delete extern declaration.
	* win32-nat.c (child_ops): Delete extern declaration.
	* linux-nat.c (child_ops): Delete extern declaration.
	* hpux-thread.c (child_ops): Delete extern declaration.
@
text
@a2067 2
struct target_ops child_ops;

@


1.97
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@a88 3
/* Forward declaration */
extern struct target_ops child_ops;

@


1.96
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_collect instead of regcache_collect.
	* regcache.h (regcache_collect): Delete declaration.
	* regcache.c (regcache_colect): Delete function.
	* win32-nat.c (do_child_store_inferior_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_fill_reg): Update.
	* rs6000-nat.c (store_register): Update.
	* remote.c (store_register_using_P, remote_store_registers): Update.
	* ppcnbsd-tdep.c (ppcnbsd_fill_reg): Update.
	* ppc-linux-nat.c (store_altivec_register, store_spe_register)
	(fill_vrregset, store_spe_registers, fill_gregset)
	(fill_gregset): Update.
	* nto-procfs.c (procfs_store_registers): Update.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg): Update.
	* mips-linux-tdep.c (fill_gregset, mips64_fill_gregset): Update.
	* m68klinux-nat.c (store_register, fill_gregset): Update.
	* m68k-tdep.c (fill_gregset): Update.
	* infptrace.c (store_register): Update.
	* i386-nto-tdep.c (i386nto_regset_fill): Update.
	* i386-linux-nat.c (store_register, fill_gregset): Update.
	* hppa-linux-nat.c (fill_gregset): Update.
	* go32-nat.c (store_register): Update.
	* armnbsd-nat.c (store_register, store_regs, store_fp_register)
	(store_fp_regs): Update.
	* arm-linux-nat.c (store_nwfpe_single, store_nwfpe_double)
	(store_nwfpe_extended, store_fpregister, store_fpregs)
	(store_register, store_regs, fill_gregset, fill_fpregset): Update.
	* alpha-tdep.c (alpha_fill_int_regs, alpha_fill_fp_regs): Update.
	* aix-thread.c (fill_gprs64, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Update.
@
text
@d2128 48
a2175 41
  add_show_from_set (add_set_cmd ("shell", class_support, var_boolean,
				  (char *) &useshell,
		 "Set use of shell to start subprocess.",
				  &setlist),
		     &showlist);

  add_show_from_set (add_set_cmd ("new-console", class_support, var_boolean,
				  (char *) &new_console,
		 "Set creation of new console when creating child process.",
				  &setlist),
		     &showlist);

  add_show_from_set (add_set_cmd ("new-group", class_support, var_boolean,
				  (char *) &new_group,
		   "Set creation of new group when creating child process.",
				  &setlist),
		     &showlist);

  add_show_from_set (add_set_cmd ("debugexec", class_support, var_boolean,
				  (char *) &debug_exec,
		       "Set whether to display execution in child process.",
				  &setlist),
		     &showlist);

  add_show_from_set (add_set_cmd ("debugevents", class_support, var_boolean,
				  (char *) &debug_events,
		   "Set whether to display kernel events in child process.",
				  &setlist),
		     &showlist);

  add_show_from_set (add_set_cmd ("debugmemory", class_support, var_boolean,
				  (char *) &debug_memory,
		 "Set whether to display memory accesses in child process.",
				  &setlist),
		     &showlist);

  add_show_from_set (add_set_cmd ("debugexceptions", class_support, var_boolean,
				  (char *) &debug_exceptions,
	       "Set whether to display kernel exceptions in child process.",
				  &setlist),
		     &showlist);
@


1.95
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d395 2
a396 1
    regcache_collect (r, ((char *) &current_thread->context) + mappings[r]);
@


1.94
log
@2004-07-01  Michael Snyder  <msnyder@@redhat.com>

        * win32-nat.c (core_dll_symbols_add): Re-indent a small section
        that seems to have gotten whacked out of line.
@
text
@d361 1
a361 1
      supply_register (r, (char *) &l);
d366 1
a366 1
      supply_register (r, (char *) &l);
d369 1
a369 1
    supply_register (r, context_offset);
d2444 1
a2444 1
    supply_register (r, core_reg_sect + mappings[r]);
@


1.93
log
@	* win32-nat.c (child_pid_to_exec_file): New function.
	(init_child_ops): Add child_pid_to_exec_file as to_pid_to_exec_file
	functionality.
@
text
@d2270 2
a2271 2
    register_loaded_dll (dll_name, base_addr + 0x1000);
    solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);
d2273 53
a2325 53
  out:
    return 1;
  }

  typedef struct
  {
    struct target_ops *target;
    bfd_vma addr;
  } map_code_section_args;

  static void
  map_single_dll_code_section (bfd * abfd, asection * sect, void *obj)
  {
    int old;
    int update_coreops;
    struct section_table *new_target_sect_ptr;

    map_code_section_args *args = (map_code_section_args *) obj;
    struct target_ops *target = args->target;
    if (sect->flags & SEC_CODE)
      {
	update_coreops = core_ops.to_sections == target->to_sections;

	if (target->to_sections)
	  {
	    old = target->to_sections_end - target->to_sections;
	    target->to_sections = (struct section_table *)
	      xrealloc ((char *) target->to_sections,
			(sizeof (struct section_table)) * (1 + old));
	  }
	else
	  {
	    old = 0;
	    target->to_sections = (struct section_table *)
	      xmalloc ((sizeof (struct section_table)));
	  }
	target->to_sections_end = target->to_sections + (1 + old);

	/* Update the to_sections field in the core_ops structure
	   if needed.  */
	if (update_coreops)
	  {
	    core_ops.to_sections = target->to_sections;
	    core_ops.to_sections_end = target->to_sections_end;
	  }
	new_target_sect_ptr = target->to_sections + old;
	new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
	new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	  bfd_section_size (abfd, sect);;
	new_target_sect_ptr->the_bfd_section = sect;
	new_target_sect_ptr->bfd = abfd;
      }
  }
d2327 2
a2328 2
  static int
  dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
@


1.92
log
@2004-06-25  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (deprecated_ui_loop_hook): Deprecated.
	* wince.c (child_wait): Update.
	* win32-nat.c (child_wait): Update.
	* v850ice.c (v850ice_wait): Update.
	* top.c (deprecated_ui_loop_hook): Update.
	* serial.h: Update.
	* ser-unix.c (do_hardwire_readchar, do_hardwire_readchar)
	(do_unix_readchar): Update.
	* ser-tcp.c (net_open): Update.
	* remote-sim.c (gdb_os_poll_quit): Update.
	* rdi-share/ardi.c (angel_RDI_ExecuteOrStep): Update.
@
text
@d1659 30
d2111 1
@


1.91
log
@2004-06-24  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (post_add_symbol_hook, pre_add_symbol_hook)
	(ui_loop_hook, selected_frame_level_changed_hook): Declare.
	* wince.c (ui_loop_hook): Delete extern declaration.
	* win32-nat.c (ui_loop_hook): Delete extern declaration..
	* v850ice.c (ui_loop_hook): Delete extern declaration..
	* ser-unix.c (ui_loop_hook): Delete extern declaration..
	* ser-tcp.c (ui_loop_hook): Delete extern declaration..
	* remote-sim.c (ui_loop_hook): Delete extern declaration..
	* rdi-share/ardi.c (angel_RDI_ExecuteOrStep): Delete extern.
	ui_loop_hook declaration.
@
text
@d1420 2
a1421 2
	  if (ui_loop_hook != NULL)
	    detach = ui_loop_hook (0);
@


1.90
log
@	* dsrec.c (load_srec, make_srec): Use bfd_get_section_size instead of
	bfd_get_section_size_before_reloc or _raw_size.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2read.c (dwarf2_locate_sections): Likewise.
	(dwarf2_read_section): Likewise.
	* elfread.c (elf_locate_sections): Likewise.
	* gcore.c (derive_heap_segment): Likewise.
	* mipsread.c (read_alphacoff_dynamic_symtab): Likewise.
	* remote-e7000.c (e7000_load): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* remote-mips.c (mips_load_srec): Likewise.
	(pmon_load_fast): Likewise.
	* remote.c (compare_sections_command): Likewise.
	* symfile.c (add_section_size_callback): Likewise.
	(load_section_callback): Likewise.
	(pc_in_unmapped_range): Likewise.
	(pc_in_mapped_range): Likewise.
	(sections_overlap): Likewise.
	(list_overlays_command): Likewise.
	(simple_overlay_update_1): Likewise.
	(simple_overlay_update): Likewise.
	* tracepoint.c (remote_set_transparent_ranges): Likewise.
	* win32-nat.c (core_section_load_dll_symbols): Likewise.
@
text
@a58 3
/* The ui's event loop. */
extern int (*ui_loop_hook) (int signo);

@


1.89
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@d3 2
a4 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free
   Software Foundation, Inc.
d2343 1
a2343 1
  buf = (char *) xmalloc (sect->_raw_size + 1);
d2349 1
a2349 1
  if (!bfd_get_section_contents (abfd, sect, buf, 0, sect->_raw_size))
d2356 1
a2356 1
  if (offsetof (struct win32_pstatus, data.module_info.module_name) + dll_name_size > sect->_raw_size)
@


1.88
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbcore.h: Update copyright.
	(deprecated_add_core_fns): Rename add_core_fns.
	* win32-nat.c (_initialize_core_win32): Update.
	* sun3-nat.c (_initialize_core_sun3): Update.
	* shnbsd-tdep.c (_initialize_shnbsd_tdep): Update.
	* rs6000-nat.c (_initialize_core_rs6000): Update.
	* ppcnbsd-tdep.c (_initialize_ppcnbsd_tdep): Update.
	* nto-tdep.c (_initialize_nto_tdep): Update.
	* ns32knbsd-nat.c (_initialize_ns32knbsd_nat): Update.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Update.
	* mips-nat.c (_initialize_core_mips): Update.
	* mips-linux-tdep.c (_initialize_mips_linux_tdep): Update.
	* m68knbsd-nat.c (_initialize_m68knbsd_nat): Update.
	* m68klinux-nat.c (_initialize_m68k_linux_nat): Update.
	* lynx-nat.c (_initialize_core_lynx): Update.
	* irix5-nat.c (_initialize_core_irix5): Update.
	* i386-interix-nat.c (_initialize_core_interix): Update.
	* cris-tdep.c (_initialize_cris_tdep): Update.
	* corelow.c (deprecated_add_core_fns): Update.
	* core-regset.c (_initialize_core_regset): Update.
	* core-aout.c (_initialize_core_aout): Update.
	* armnbsd-nat.c (_initialize_arm_netbsd_nat): Update.
	* alphanbsd-tdep.c (_initialize_alphanbsd_tdep): Update.
	* alpha-nat.c (_initialize_core_alpha): Update.
@
text
@d1683 2
a1684 1
child_create_inferior (char *exec_file, char *allargs, char **env)
@


1.87
log
@2004-01-05  Andrew Cagney  <cagney@@redhat.com>

	* libunwind-frame.h (struct frame_id): Add opaque declaration,
	move to start of file.
	* i386-tdep.h (struct regcache): Add opaque declaration.
	* config/ia64/nm-linux.h (struct target_ops): Add opaque
	declaration.
	* ia64-tdep.c (ia64_find_proc_info_x): Do not use __FUNCTION__.
	(ia64_gdbarch_init): Use "GNU/Linux" in comment.
	* win32-nat.c (fake_create_process): Use ISO C style definition.
	* stabsread.c (define_symbol): Delete #ifndef
	DEPRECATED_USE_REGISTER_NOT_ARG wrapper around
	stabs_argument_has_addr call, macro never defined.
@
text
@d2430 1
a2430 1
  add_core_fns (&win32_elf_core_fns);
@


1.87.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 2
a4 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d59 3
d364 1
a364 1
      regcache_raw_supply (current_regcache, r, (char *) &l);
d369 1
a369 1
      regcache_raw_supply (current_regcache, r, (char *) &l);
d372 1
a372 1
    regcache_raw_supply (current_regcache, r, context_offset);
d398 1
a398 2
    regcache_raw_collect (current_regcache, r,
			  ((char *) &current_thread->context) + mappings[r]);
d1423 2
a1424 2
	  if (deprecated_ui_loop_hook != NULL)
	    detach = deprecated_ui_loop_hook (0);
a1661 30
char *
child_pid_to_exec_file (int pid)
{
  /* Try to find the process path using the Cygwin internal process list
     pid isn't a valid pid, unfortunately.  Use current_event.dwProcessId
     instead.  */
  /* TODO: Also find native Windows processes using CW_GETPINFO_FULL.  */

  static char path[MAX_PATH + 1];
  char *path_ptr = NULL;
  int cpid;
  struct external_pinfo *pinfo;

  cygwin_internal (CW_LOCK_PINFO, 1000);
  for (cpid = 0;
       (pinfo = (struct external_pinfo *)
                       cygwin_internal (CW_GETPINFO, cpid | CW_NEXTPID));
       cpid = pinfo->pid)
    {
      if (pinfo->dwProcessId == current_event.dwProcessId) /* Got it */
       {
         cygwin_conv_to_full_posix_path (pinfo->progname, path);
         path_ptr = path; 
         break;
       }
    }
  cygwin_internal (CW_UNLOCK_PINFO);
  return path_ptr; 
}

d1683 1
a1683 2
child_create_inferior (char *exec_file, char *allargs, char **env,
		       int from_tty)
a2082 1
  child_ops.to_pid_to_exec_file = child_pid_to_exec_file;
d2098 41
a2138 48
  deprecated_add_show_from_set
    (add_set_cmd ("shell", class_support, var_boolean,
		  (char *) &useshell,
		  "Set use of shell to start subprocess.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("new-console", class_support, var_boolean,
		  (char *) &new_console,
		  "Set creation of new console when creating child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("new-group", class_support, var_boolean,
		  (char *) &new_group,
		  "Set creation of new group when creating child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugexec", class_support, var_boolean,
		  (char *) &debug_exec,
		  "Set whether to display execution in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugevents", class_support, var_boolean,
		  (char *) &debug_events,
		  "Set whether to display kernel events in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugmemory", class_support, var_boolean,
		  (char *) &debug_memory,
		  "Set whether to display memory accesses in child process.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("debugexceptions", class_support, var_boolean,
		  (char *) &debug_exceptions,
		  "Set whether to display kernel exceptions in child process.",
		  &setlist),
     &showlist);
d2241 2
a2242 2
  register_loaded_dll (dll_name, base_addr + 0x1000);
  solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);
d2244 3
a2246 3
 out:
  return 1;
}
d2248 5
a2252 5
typedef struct
{
  struct target_ops *target;
  bfd_vma addr;
} map_code_section_args;
d2254 12
a2265 6
static void
map_single_dll_code_section (bfd * abfd, asection * sect, void *obj)
{
  int old;
  int update_coreops;
  struct section_table *new_target_sect_ptr;
d2267 14
a2280 5
  map_code_section_args *args = (map_code_section_args *) obj;
  struct target_ops *target = args->target;
  if (sect->flags & SEC_CODE)
    {
      update_coreops = core_ops.to_sections == target->to_sections;
d2282 15
a2296 14
      if (target->to_sections)
	{
	  old = target->to_sections_end - target->to_sections;
	  target->to_sections = (struct section_table *)
	    xrealloc ((char *) target->to_sections,
		      (sizeof (struct section_table)) * (1 + old));
	}
      else
	{
	  old = 0;
	  target->to_sections = (struct section_table *)
	    xmalloc ((sizeof (struct section_table)));
	}
      target->to_sections_end = target->to_sections + (1 + old);
d2298 2
a2299 18
      /* Update the to_sections field in the core_ops structure
	 if needed.  */
      if (update_coreops)
	{
	  core_ops.to_sections = target->to_sections;
	  core_ops.to_sections_end = target->to_sections_end;
	}
      new_target_sect_ptr = target->to_sections + old;
      new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
      new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	bfd_section_size (abfd, sect);;
      new_target_sect_ptr->the_bfd_section = sect;
      new_target_sect_ptr->bfd = abfd;
    }
}

static int
dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
d2342 1
a2342 1
  buf = (char *) xmalloc (bfd_get_section_size (sect) + 1);
d2348 1
a2348 1
  if (!bfd_get_section_contents (abfd, sect, buf, 0, bfd_get_section_size (sect)))
d2355 1
a2355 1
  if (offsetof (struct win32_pstatus, data.module_info.module_name) + dll_name_size > bfd_get_section_size (sect))
d2415 1
a2415 1
    regcache_raw_supply (current_regcache, r, core_reg_sect + mappings[r]);
d2430 1
a2430 1
  deprecated_add_core_fns (&win32_elf_core_fns);
@


1.86
log
@* win32-nat.c: Add some comments about below change.
@
text
@d1218 1
a1218 1
fake_create_process ()
@


1.85
log
@Fix for PR threads/1048
* win32-nat.c (thread_info_struct): Add reload_context flag.
(thread_rec): Don't reload thread context here.  Just set a flag.
(do_child_fetch_inferior_registers): Reload thread context here if appropriate.
Avoid doing anything if current_thread is NULL thanks to strange Windows
behavior.
(child_fetch_inferior_registers): Avoid doing anything if current_thread is
NULL.
(do_child_store_inferior_registers): Ditto.
(child_store_inferior_registers): Ditto.
(child_kill_inferior): Ditto.
(fake_create_process): Pretend to create a process for pathological windows
attach situation.
(get_child_debug_event): Call fake_create_process when the first event noticed
is thread creation rather than process creation.
(child_attach): Always set attach_flag when attaching.
(child_create_inferior): Set attach_flag to zero since we're not attaching.
@
text
@d341 2
a342 1
    return;
d386 2
d396 1
a396 1
    /* nothing to do */;
d411 2
d1215 2
d1263 3
@


1.84
log
@* win32-nat.c (get_child_debug_event): Keep main thread id around even after
thread exits since Windows insists on continuing to report events against it.
@
text
@d111 1
a231 1

d249 1
a249 13

	    th->context.ContextFlags = CONTEXT_DEBUGGER_DR;
	    GetThreadContext (th->h, &th->context);
	    if (id == current_event.dwThreadId)
	      {
		/* Copy dr values from that thread.  */
		dr[0] = th->context.Dr0;
		dr[1] = th->context.Dr1;
		dr[2] = th->context.Dr2;
		dr[3] = th->context.Dr3;
		dr[6] = th->context.Dr6;
		dr[7] = th->context.Dr7;
	      }
d340 18
d385 2
a386 1
  do_child_fetch_inferior_registers (r);
d392 3
a394 1
  if (r >= 0)
d408 2
a409 1
  do_child_store_inferior_registers (r);
d1192 1
a1192 1
	      /* Only change the value of the debug reisters */
d1210 11
d1253 8
a1260 1
	break;
a1275 2
      if (saw_create != 1)
	break;
a1383 1
      current_thread = th ? : thread_rec (current_event.dwThreadId, TRUE);
d1385 1
d1600 3
a1602 4
    {
      attach_flag = 1;
      DebugSetProcessKillOnExit (FALSE);
    }
d1724 2
d1927 2
a1928 1
  (void) CloseHandle (current_thread->h);
a2178 1

@


1.83
log
@* i386-tdep.h (FCS_REGNUM, FCOFF_REGNUM, FDS_REGNUM,
FDOFF_REGNUM): Remove defines.
* win32-nat.c (do_child_fetch_inferior_registers): Include
"i387-tdep.h".
(do_child_fetch_inferior_registers): Use I387_FISEG_ST0_REGNUM and
I387_FOP_REGNUM instead of FCS_REGNUM and FOP_REGNUM.  Define and
undefine I387_ST0_REGNUM.
@
text
@d79 2
a80 2
static int debug_registers_changed = 0;
static int debug_registers_used = 0;
d1208 1
a1208 1
  thread_info *th = NULL;
d1222 1
d1250 5
a1254 2
      child_delete_thread (current_event.dwThreadId);
      th = &dummy_thread_info;
d1270 2
a1273 4
#if 0
      th = child_add_thread (current_event.dwProcessId,
			     current_event.u.CreateProcessInfo.hProcess);
#endif
d2204 2
a2205 2
  register_loaded_dll (dll_name, base_addr + 0x1000);
  solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);
d2207 3
a2209 3
out:
  return 1;
}
d2211 5
a2215 5
typedef struct
{
  struct target_ops *target;
  bfd_vma addr;
} map_code_section_args;
d2217 12
a2228 6
static void
map_single_dll_code_section (bfd * abfd, asection * sect, void *obj)
{
  int old;
  int update_coreops;
  struct section_table *new_target_sect_ptr;
d2230 14
a2243 5
  map_code_section_args *args = (map_code_section_args *) obj;
  struct target_ops *target = args->target;
  if (sect->flags & SEC_CODE)
    {
      update_coreops = core_ops.to_sections == target->to_sections;
d2245 15
a2259 14
      if (target->to_sections)
	{
	  old = target->to_sections_end - target->to_sections;
	  target->to_sections = (struct section_table *)
	    xrealloc ((char *) target->to_sections,
		      (sizeof (struct section_table)) * (1 + old));
	}
      else
	{
	  old = 0;
	  target->to_sections = (struct section_table *)
	    xmalloc ((sizeof (struct section_table)));
	}
      target->to_sections_end = target->to_sections + (1 + old);
d2261 2
a2262 18
      /* Update the to_sections field in the core_ops structure
	 if needed.  */
      if (update_coreops)
	{
	  core_ops.to_sections = target->to_sections;
	  core_ops.to_sections_end = target->to_sections_end;
	}
      new_target_sect_ptr = target->to_sections + old;
      new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
      new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	bfd_section_size (abfd, sect);;
      new_target_sect_ptr->the_bfd_section = sect;
      new_target_sect_ptr->bfd = abfd;
    }
}

static int
dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
@


1.82
log
@2003-10-22  Andrew Cagney  <cagney@@redhat.com>

	* exec.h: New file.
	* win32-nat.c: Include "exec.h".
	* solib.c: Include "exec.h".
	* target.h (build_section_table): Delete declaration.
	* somsolib.c: Include "exec.h".
	(exec_ops): Delete extern declaration.
	* rs6000-nat.c: Update copyright.  Include "exec.h".
	(exec_ops): Delete extern declaration.
	* pa64solib.c: Update copyright.  Include "exec.h".
	(exec_ops): Delete extern declaration.
	* exec.c: Update copyright.  Include "exec.h".
	* corelow.c: Update dependencies.  Include "exec.h".
	* Makefile.in (exec_h): Define.
	(exec.o, somsolib.o): Update dependencies.
	(pa64solib.o, corelow.o): Update dependencies.
@
text
@a37 1
#include "i386-tdep.h"
d56 3
d351 4
a354 1
  if (r == FCS_REGNUM)
d359 1
a359 1
  else if (r == FOP_REGNUM)
d371 2
@


1.81
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d55 1
@


1.80
log
@* win32-nat.c (mappings): Remove HAVE_SSE conditional.
@
text
@a1625 1
/* ARGSUSED */
@


1.79
log
@* win32-nat.c: Just rely on CONTEXT_EXTENDED_REGISTER being defined for SSE
registers since gdb will not operate correctly without this.  Restore include
file ordering munged in previous change.
* config/i386/tm-cygwin.h: Remove HAVE_SSE_REGS define.
@
text
@a184 1
#ifdef HAVE_SSE_REGS
a195 1
#endif
@


1.78
log
@* win32-nat.c: Reorganize so that defines used by target headers are actually
defined by the system headers.
* config/i386/tm-cygwin.h: Check for CONTEXT_EXTENDED_REGISTERS rather than
HAVE_CONTEXT_EXTENDED_REGISTERS, since the latter actually exists.
@
text
@a28 7
#include <windows.h>
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <sys/cygwin.h>
a29 1
#include "tm.h"			/* required for SSE registers */
d39 7
a71 1
#ifdef HAVE_SSE_REGS
a73 3
#else
#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS
#endif
@


1.77
log
@* win32-nat.c (solib_symbols_add): Use one variable for all section address
stuff.  Pass variable rather than address of variable to safe_symbol_file_add.
@
text
@d29 7
a46 7
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <windows.h>
#include <imagehlp.h>
#include <sys/cygwin.h>
@


1.76
log
@        * win32-nat.c (solib_symbols_add): Fix a small compilation error.
@
text
@d640 1
a640 1
  if (!ReadProcessMemory (h, address,  &address_ptr, sizeof (address_ptr), &done) 
d805 1
a805 1
  struct section_addr_info *section_addrs_ptr = NULL;
d828 1
a828 1
	  section_addrs_ptr = get_relocated_section_addrs (abfd, load_addr);
d834 1
a834 1
  if (section_addrs_ptr)
d836 2
a837 4
      result = safe_symbol_file_add (name, from_tty, section_addrs_ptr,
				     0, OBJF_SHARED);

      free_section_addr_info (section_addrs_ptr);
a838 1

a841 1
      struct section_addr_info *section_addrs;
d844 4
a847 4
      section_addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, section_addrs);
      section_addrs->other[0].name = ".text";
      section_addrs->other[0].addr = load_addr;
d849 1
a849 2
      result = safe_symbol_file_add (name, from_tty, &section_addrs,
				     0, OBJF_SHARED);
d2213 1
a2213 2
}
map_code_section_args;
@


1.76.4.1
log
@* win32-nat.c (solib_symbols_add): Use one variable for all section address
stuff.  Pass variable rather than address of variable to safe_symbol_file_add.
@
text
@d805 1
a805 1
  struct section_addr_info *addrs = NULL;
d828 1
a828 1
	  addrs = get_relocated_section_addrs (abfd, load_addr);
d834 1
a834 1
  if (addrs)
d836 4
a839 2
      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
      free_section_addr_info (addrs);
d841 1
d845 1
d848 4
a851 4
      addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, addrs);
      addrs->other[0].name = ".text";
      addrs->other[0].addr = load_addr;
d853 2
a854 1
      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
d2218 2
a2219 1
} map_code_section_args;
@


1.76.4.2
log
@* win32-nat.c: Reorganize so that defines used by target headers are actually
defined by the system headers.
* config/i386/tm-cygwin.h: Check for CONTEXT_EXTENDED_REGISTERS rather than
HAVE_CONTEXT_EXTENDED_REGISTERS, since the latter actually exists.
@
text
@a28 7
#include <windows.h>
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <sys/cygwin.h>
d40 7
@


1.76.4.3
log
@* win32-nat.c: Just rely on CONTEXT_EXTENDED_REGISTER being defined for SSE
registers since gdb will not operate correctly without this.  Restore include
file ordering munged in previous change.
* config/i386/tm-cygwin.h: Remove HAVE_SSE_REGS define.
@
text
@d29 7
d37 1
a46 7
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <windows.h>
#include <imagehlp.h>
#include <sys/cygwin.h>
d73 1
d76 3
@


1.76.4.4
log
@* win32-nat.c (mappings): Remove HAVE_SSE conditional.
@
text
@d185 1
d197 1
@


1.75
log
@	* elfread.c (elf_symtab_read): Avoid use of SECT_OFF_MAX.
	(elfstab_offset_sections): Likewise.
	* gdb-stabs.h (stab_section_info): Likewise.
	* i386-interix-tdep.c (pei_adjust_objfile_offsets): Likewise.
	* objfiles.c (objfile_relocate): Likewise.
	* pa64solib.c (pa64_solib_add_solib_objfile): Likewise.
	* remote.c (get_offsets): Likewise.
	(remote_cisco_objfile_relocate): Likewise.
	* somread.c (som_symfile_offsets): Likewise.
	* symfile.c (alloc_section_addr_info): New function.
	(build_section_addr_info_from_section_tab): Use it.
	(free_section_addr_info): Adjust.
	(default_symfile_offsets): Avoid use of SECT_OFF_MAX.
	(syms_from_objfile): Allocate local_addr dynamically.
	(symbol_file_add_with_addrs_or_offsets): Allocate orig_addrs
	dynamically.
	(add_symbol_file_command): Allocate sect_opts dynamically.
	(reread_symbols): Avoid use of SECT_OFF_MAX.
	* symfile.h (section_addr_info): Do not use MAX_SECTIONS.
	(alloc_section_addr_info): Declare it.
	* symtab.h (SIZEOF_SECTION_OFFSETS): Remove.
	* win32-nat.c (solib_symbols_add): Allocate section_addrs
	dynamically.
	* xcoffread.c (xcoff_symfile_offsets): Avoid use of SECT_OFF_MAX.
@
text
@d850 2
a851 2
      section_addrs.other[0].name = ".text";
      section_addrs.other[0].addr = load_addr;
@


1.74
log
@* win32-nat.c (get_image_name): Check return value from ReadProcessMemory.
(child_xfer_memory): Ditto.
@
text
@d845 2
a846 1
      struct section_addr_info section_addrs;
d848 2
a849 1
      memset (&section_addrs, 0, sizeof (section_addrs));
d855 1
@


1.73
log
@white space
@
text
@a637 2
  ReadProcessMemory (h, address,  &address_ptr, sizeof (address_ptr), &done);

d640 2
a641 2

  if (done != sizeof (address_ptr) || !address_ptr)
d645 3
a647 6
  do
    {
      ReadProcessMemory (h, address_ptr + len * size, &b, size, &done);
      len++;
    }
  while ((b[0] != 0 || b[size - 1] != 0) && done == size);
d1861 1
a1861 1
  DWORD done;
d1866 3
a1868 2
      WriteProcessMemory (current_process_handle, (LPVOID) memaddr, our,
			  len, &done);
d1875 3
a1877 2
      ReadProcessMemory (current_process_handle, (LPCVOID) memaddr, our, len,
			 &done);
@


1.72
log
@* win32-nat.cc (register_loaded_dll): Correctly set address range for
just-loaded dll.
@
text
@d952 1
a952 1
       limit = (limit << 12) | 0xfff;
d1574 1
a1574 1
    error ("Can't attach to process.");
d1967 10
a1976 10
     if (debug_registers_changed)
       {
	  th->context.Dr0 = dr[0];
	  th->context.Dr1 = dr[1];
	  th->context.Dr2 = dr[2];
	  th->context.Dr3 = dr[3];
	  /* th->context.Dr6 = dr[6];
	   FIXME: should we set dr6 also ?? */
	  th->context.Dr7 = dr[7];
       }
@


1.71
log
@whitespace cleanup
@
text
@d605 2
a606 2
  if (!VirtualQueryEx (current_process_handle, (void *) load_addr, &m,
		       sizeof (m)))
@


1.70
log
@* win32-nat.c (get_relocated_section_addrs): New function.  Find section load
addresses for symbol handling in relocated DLLs.
(solib_symbols_add): Open a bfd and call get_relocated_section_addrs.
@
text
@d752 1
a752 1

d805 1
a805 1

d1504 1
a1504 1
        {
d1509 1
a1509 1
  
d1523 1
a1523 1
                              sizeof orig_priv, &orig_priv, &size))
@


1.69
log
@* win32-nat.c (cygwin_pid): Removed as unused.
(child_attach): Try fall back to Cygwin pid.
@
text
@d752 5
d758 48
d810 3
a812 1
  struct section_addr_info section_addrs;
d821 40
a860 4
  memset (&section_addrs, 0, sizeof (section_addrs));
  section_addrs.other[0].name = ".text";
  section_addrs.other[0].addr = load_addr;
  return safe_symbol_file_add (name, from_tty, &section_addrs, 0, OBJF_SHARED);
@


1.68
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@a126 1
static pid_t cygwin_pid;		/* pid of cygwin process */
d385 1
a385 1
    deprecated_read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
d852 4
a855 4
        {
          puts_filtered ("Segment not present\n");
          return 0;
        }
d864 1
a864 1
        puts_filtered(" 32-bit ");
d866 1
a866 1
        puts_filtered(" 16-bit ");
d870 2
a871 2
          puts_filtered ("Data (Read-Only, Exp-up");
          break;
d873 2
a874 2
          puts_filtered ("Data (Read/Write, Exp-up");
          break;
d876 2
a877 2
          puts_filtered ("Unused segment (");
          break;
d879 2
a880 2
          puts_filtered ("Data (Read/Write, Exp-down");
          break;
d882 2
a883 2
          puts_filtered ("Code (Exec-Only, N.Conf");
          break;
d885 1
a885 1
          puts_filtered ("Code (Exec/Read, N.Conf");
d888 1
a888 1
          puts_filtered ("Code (Exec-Only, Conf");
d891 1
a891 1
          puts_filtered ("Code (Exec/Read, Conf");
d897 1
a897 1
        puts_filtered(", N.Acc");
d903 1
a903 1
        puts_filtered ("Page granular.\n");
d928 1
a928 1
        current_thread->context.SegCs);
d931 1
a931 1
        current_thread->context.SegDs);
d934 1
a934 1
        current_thread->context.SegEs);
d937 1
a937 1
        current_thread->context.SegSs);
d943 1
a943 1
        current_thread->context.SegGs);
d1469 2
a1470 1
  pid = strtoul (args, 0, 0);
d1475 8
d1484 1
d2018 2
a2019 2
                  "Print information specific to Win32 debugging.",
                  &info_w32_cmdlist, "info w32 ", 0, &infolist);
d2022 1
a2022 1
           "Display selectors infos.",
@


1.67
log
@	* win32-nat.c (set_process_privilege): New function.
	(child_attach): Call set_process_privilege() to enable the
	SE_DEBUG_NAME user privilege if available in process token.
@
text
@d3 1
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free
@


1.66
log
@* win32-nat.c (child_attach): Reset saw_create counter or subsequent attach
will hang.
@
text
@d1377 77
d1463 6
@


1.65
log
@* win32-nat.c (psapi_get_dll_name): Fix a compiler warning.
(struct so_stuff): Add end_addr field.
(register_loaded_dll): Calculate and store end address of loaded dll.
(solib_address): New function.
(child_solib_loaded_library_pathname): Pass carefully constructed section info
to safe_symbol_file_add rather than ignoring it.
(get_child_debug_event): Call re_enable_breakpoints_in_shlibs when a DLL is
loaded.
(do_initial_child_stuff): Call disable_breakpoints_in_shlibs.
(child_create_inferior): Fix a compiler warning.
* config/i386/tm-cygwin.h (PC_SOLIB): Define new macro.
(solib_address): Declare new function.
@
text
@d1389 1
@


1.64
log
@	* gnu-nat.c (init_gnu_ops): Remove NULL initializations.
	* monitor.c (init_base_monitor_ops): Likewise.
	* ppc-bdm.c (init_bdm_ppc_ops): Likewise.
	* remote-array.c (init_array_ops): Likewise.
	* remote-e7000.c (init_e7000_ops): Likewise.
	* remote-es.c (init_es1800_ops): Likewise.
	(init_es1800_child_ops): Likewise.
	* remote-rdp.c (init_remote_rdp_ops): Likewise.
	* remote-sim.c (init_gdbsim_ops): Likewise.
	* remote-st.c (init_st2000_ops): Likewise.
	* sol-thread.c (init_sol_core_ops): Likewise.
	(init_sol_thread_ops): Likewise.
	* v850ice.c (init_850ice_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
@
text
@d476 1
a476 1
	error ("Error getting dll name: %u\n", GetLastError ());
d505 1
d582 1
d606 6
d719 10
d770 1
a770 1
  return safe_symbol_file_add (name, from_tty, NULL, 0, OBJF_SHARED);
d1219 1
d1327 1
d1641 1
a1641 1
    error ("Error creating process %s, (error %d)\n", exec_file, GetLastError ());
@


1.63
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@a1830 2
  child_ops.to_load = 0;
  child_ops.to_lookup_symbol = 0;
a1833 1
  child_ops.to_notice_signals = 0;
a1837 1
  child_ops.DONT_USE = 0;
a1842 2
  child_ops.to_sections = 0;
  child_ops.to_sections_end = 0;
@


1.62
log
@* win32-nat.c (child_create_inferior): Honor 'tty' command.
@
text
@d386 1
a386 1
    read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
@


1.62.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free
d30 1
d39 1
a55 4
#include "exec.h"

#include "i386-tdep.h"
#include "i387-tdep.h"
d73 1
d76 3
d127 1
d191 1
d203 1
d356 1
a356 4

#define I387_ST0_REGNUM I386_ST0_REGNUM

  if (r == I387_FISEG_REGNUM)
d361 1
a361 1
  else if (r == I387_FOP_REGNUM)
a372 2

#undef I387_ST0_REGNUM
d386 1
a386 1
    regcache_collect (r, ((char *) &current_thread->context) + mappings[r]);
d476 1
a476 1
	error ("Error getting dll name: %u\n", (unsigned) GetLastError ());
a504 1
  DWORD end_addr;
a580 1
  MEMORY_BASIC_INFORMATION m;
a603 6
  if (VirtualQueryEx (current_process_handle, (void *) load_addr, &m,
		      sizeof (m)))
    so->end_addr = (DWORD) m.AllocationBase + m.RegionSize;
  else
    so->end_addr = load_addr + 0x2000;	/* completely arbitrary */

d631 2
d635 2
a636 2
  if (!ReadProcessMemory (h, address,  &address_ptr, sizeof (address_ptr), &done)
      || done != sizeof (address_ptr) || !address_ptr)
d640 6
a645 3
  while (ReadProcessMemory (h, address_ptr + len++ * size, &b, size, &done)
	 && (b[0] != 0 || b[size - 1] != 0) && done == size)
    continue;
a710 10
char *
solib_address (CORE_ADDR address)
{
  struct so_stuff *so;
  for (so = &solib_start; so->next != NULL; so = so->next)
    if (address >= so->load_addr && address <= so->end_addr)
      return so->name;
  return NULL;
}

a735 53
/* Get the loaded address of all sections, given that .text was loaded
   at text_load. Assumes that all sections are subject to the same
   relocation offset. Returns NULL if problems occur or if the
   sections were not relocated. */

static struct section_addr_info *
get_relocated_section_addrs (bfd *abfd, CORE_ADDR text_load)
{
  struct section_addr_info *result = NULL;
  int section_count = bfd_count_sections (abfd);
  asection *text_section = bfd_get_section_by_name (abfd, ".text");
  CORE_ADDR text_vma;

  if (!text_section)
    {
      /* Couldn't get the .text section. Weird. */
    }

  else if (text_load == (text_vma = bfd_get_section_vma (abfd, text_section)))
    {
      /* DLL wasn't relocated. */
    }

  else
    {
      /* Figure out all sections' loaded addresses. The offset here is
	 such that taking a bfd_get_section_vma() result and adding
	 offset will give the real load address of the section. */

      CORE_ADDR offset = text_load - text_vma;

      struct section_table *table_start = NULL;
      struct section_table *table_end = NULL;
      struct section_table *iter = NULL;

      build_section_table (abfd, &table_start, &table_end);

      for (iter = table_start; iter < table_end; ++iter)
	{
	  /* Relocated addresses. */
	  iter->addr += offset;
	  iter->endaddr += offset;
	}

      result = build_section_addr_info_from_section_table (table_start,
							   table_end);

      xfree (table_start);
    }

  return result;
}

d740 1
a740 3
  struct section_addr_info *addrs = NULL;
  static struct objfile *result = NULL;
  bfd *abfd = NULL;
d749 4
a752 38
  abfd = bfd_openr (name, "pei-i386");

  if (!abfd)
    {
      /* pei failed - try pe */
      abfd = bfd_openr (name, "pe-i386");
    }

  if (abfd)
    {
      if (bfd_check_format (abfd, bfd_object))
	{
	  addrs = get_relocated_section_addrs (abfd, load_addr);
	}

      bfd_close (abfd);
    }

  if (addrs)
    {
      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
      free_section_addr_info (addrs);
    }
  else
    {
      /* Fallback on handling just the .text section. */
      struct cleanup *my_cleanups;

      addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, addrs);
      addrs->other[0].name = ".text";
      addrs->other[0].addr = load_addr;

      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
      do_cleanups (my_cleanups);
    }

  return result;
d835 4
a838 4
	{
	  puts_filtered ("Segment not present\n");
	  return 0;
	}
d844 1
a844 1
	limit = (limit << 12) | 0xfff;
d847 1
a847 1
	puts_filtered(" 32-bit ");
d849 1
a849 1
	puts_filtered(" 16-bit ");
d853 2
a854 2
	  puts_filtered ("Data (Read-Only, Exp-up");
	  break;
d856 2
a857 2
	  puts_filtered ("Data (Read/Write, Exp-up");
	  break;
d859 2
a860 2
	  puts_filtered ("Unused segment (");
	  break;
d862 2
a863 2
	  puts_filtered ("Data (Read/Write, Exp-down");
	  break;
d865 2
a866 2
	  puts_filtered ("Code (Exec-Only, N.Conf");
	  break;
d868 1
a868 1
	  puts_filtered ("Code (Exec/Read, N.Conf");
d871 1
a871 1
	  puts_filtered ("Code (Exec-Only, Conf");
d874 1
a874 1
	  puts_filtered ("Code (Exec/Read, Conf");
d880 1
a880 1
	puts_filtered(", N.Acc");
d886 1
a886 1
	puts_filtered ("Page granular.\n");
d911 1
a911 1
	current_thread->context.SegCs);
d914 1
a914 1
	current_thread->context.SegDs);
d917 1
a917 1
	current_thread->context.SegEs);
d920 1
a920 1
	current_thread->context.SegSs);
d926 1
a926 1
	current_thread->context.SegGs);
a1200 1
      re_enable_breakpoints_in_shlibs ();
a1307 1
  disable_breakpoints_in_shlibs (1);
a1356 77
/* Try to set or remove a user privilege to the current process.  Return -1
   if that fails, the previous setting of that privilege otherwise.

   This code is copied from the Cygwin source code and rearranged to allow
   dynamically loading of the needed symbols from advapi32 which is only
   available on NT/2K/XP. */
static int
set_process_privilege (const char *privilege, BOOL enable)
{
  static HMODULE advapi32 = NULL;
  static BOOL WINAPI (*OpenProcessToken)(HANDLE, DWORD, PHANDLE);
  static BOOL WINAPI (*LookupPrivilegeValue)(LPCSTR, LPCSTR, PLUID);
  static BOOL WINAPI (*AdjustTokenPrivileges)(HANDLE, BOOL, PTOKEN_PRIVILEGES,
					      DWORD, PTOKEN_PRIVILEGES, PDWORD);

  HANDLE token_hdl = NULL;
  LUID restore_priv;
  TOKEN_PRIVILEGES new_priv, orig_priv;
  int ret = -1;
  DWORD size;

  if (GetVersion () >= 0x80000000)  /* No security availbale on 9x/Me */
    return 0;

  if (!advapi32)
    {
      if (!(advapi32 = LoadLibrary ("advapi32.dll")))
	goto out;
      if (!OpenProcessToken)
	OpenProcessToken = GetProcAddress (advapi32, "OpenProcessToken");
      if (!LookupPrivilegeValue)
	LookupPrivilegeValue = GetProcAddress (advapi32,
					       "LookupPrivilegeValueA");
      if (!AdjustTokenPrivileges)
	AdjustTokenPrivileges = GetProcAddress (advapi32,
						"AdjustTokenPrivileges");
      if (!OpenProcessToken || !LookupPrivilegeValue || !AdjustTokenPrivileges)
	{
	  advapi32 = NULL;
	  goto out;
	}
    }

  if (!OpenProcessToken (GetCurrentProcess (),
			 TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			 &token_hdl))
    goto out;

  if (!LookupPrivilegeValue (NULL, privilege, &restore_priv))
    goto out;

  new_priv.PrivilegeCount = 1;
  new_priv.Privileges[0].Luid = restore_priv;
  new_priv.Privileges[0].Attributes = enable ? SE_PRIVILEGE_ENABLED : 0;

  if (!AdjustTokenPrivileges (token_hdl, FALSE, &new_priv,
			      sizeof orig_priv, &orig_priv, &size))
    goto out;
#if 0
  /* Disabled, otherwise every `attach' in an unprivileged user session
     would raise the "Failed to get SE_DEBUG_NAME privilege" warning in
     child_attach(). */
  /* AdjustTokenPrivileges returns TRUE even if the privilege could not
     be enabled. GetLastError () returns an correct error code, though. */
  if (enable && GetLastError () == ERROR_NOT_ALL_ASSIGNED)
    goto out;
#endif

  ret = orig_priv.Privileges[0].Attributes == SE_PRIVILEGE_ENABLED ? 1 : 0;

out:
  if (token_hdl)
    CloseHandle (token_hdl);

  return ret;
}

d1367 1
a1367 8
  if (set_process_privilege (SE_DEBUG_NAME, TRUE) < 0)
    {
      printf_unfiltered ("Warning: Failed to get SE_DEBUG_NAME privilege\n");
      printf_unfiltered ("This can cause attach to fail on Windows NT/2K/XP\n");
    }

  pid = strtoul (args, 0, 0);		/* Windows pid */

a1368 1
  saw_create = 0;
d1371 1
a1371 10
    {
      /* Try fall back to Cygwin pid */
      pid = cygwin_internal (CW_CYGWIN_PID_TO_WINPID, pid);

      if (pid > 0)
	ok = DebugActiveProcess (pid);

      if (!ok)
	error ("Can't attach to process.");
    }
d1436 1
d1621 1
a1621 1
    error ("Error creating process %s, (error %d)\n", exec_file, (unsigned) GetLastError ());
d1662 1
a1662 1
  DWORD done = 0;
d1667 2
a1668 3
      if (!WriteProcessMemory (current_process_handle, (LPVOID) memaddr, our,
			       len, &done))
	done = 0;
d1675 2
a1676 3
      if (!ReadProcessMemory (current_process_handle, (LPCVOID) memaddr, our,
			      len, &done))
	done = 0;
d1763 10
a1772 10
	  if (debug_registers_changed)
	    {
	      th->context.Dr0 = dr[0];
	      th->context.Dr1 = dr[1];
	      th->context.Dr2 = dr[2];
	      th->context.Dr3 = dr[3];
	      /* th->context.Dr6 = dr[6];
	       FIXME: should we set dr6 also ?? */
	      th->context.Dr7 = dr[7];
	    }
d1831 2
d1836 1
d1841 1
d1847 2
d1911 2
a1912 2
		  "Print information specific to Win32 debugging.",
		  &info_w32_cmdlist, "info w32 ", 0, &infolist);
d1915 1
a1915 1
	   "Display selectors infos.",
d2020 2
a2021 1
} map_code_section_args;
@


1.62.4.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d79 2
a80 2
static int debug_registers_changed;
static int debug_registers_used;
a110 1
    int reload_context;
d231 1
d249 13
a261 1
	    th->reload_context = 1;
a351 19
  if (!current_thread)
    return;	/* Windows sometimes uses a non-existent thread id in its
		   events */

  if (current_thread->reload_context)
    {
      thread_info *th = current_thread;
      th->context.ContextFlags = CONTEXT_DEBUGGER_DR;
      GetThreadContext (th->h, &th->context);
      /* Copy dr values from that thread.  */
      dr[0] = th->context.Dr0;
      dr[1] = th->context.Dr1;
      dr[2] = th->context.Dr2;
      dr[3] = th->context.Dr3;
      dr[6] = th->context.Dr6;
      dr[7] = th->context.Dr7;
      current_thread->reload_context = 0;
    }

d379 1
a379 4
  /* Check if current_thread exists.  Windows sometimes uses a non-existent
     thread id in its events */
  if (current_thread)
    do_child_fetch_inferior_registers (r);
d385 1
a385 3
  if (!current_thread)
    /* Windows sometimes uses a non-existent thread id in its events */;
  else if (r >= 0)
d399 1
a399 4
  /* Check if current_thread exists.  Windows sometimes uses a non-existent
     thread id in its events */
  if (current_thread)
    do_child_store_inferior_registers (r);
d1182 1
a1182 1
	      /* Only change the value of the debug registers */
a1199 13
/* Called in pathological case where Windows fails to send a
   CREATE_PROCESS_DEBUG_EVENT after an attach.  */
DWORD
fake_create_process (void)
{
  current_process_handle = OpenProcess (PROCESS_ALL_ACCESS, FALSE,
					current_event.dwProcessId);
  main_thread_id = current_event.dwThreadId;
  current_thread = child_add_thread (main_thread_id,
				     current_event.u.CreateThread.hThread);
  return main_thread_id;
}

d1208 1
a1208 1
  thread_info *th;
a1221 1
  th = NULL;
d1231 1
a1231 11
	{
	  if (!saw_create && attach_flag)
	    {
	      /* Kludge around a Windows bug where first event is a create
		 thread event.  Caused when attached process does not have
		 a main thread. */
	      retval = ourstatus->value.related_pid = fake_create_process ();
	      saw_create++;
	    }
	  break;
	}
d1247 4
a1250 5
      if (current_event.dwThreadId != main_thread_id)
	{
	  child_delete_thread (current_event.dwThreadId);
	  th = &dummy_thread_info;
	}
a1265 2
      if (main_thread_id)
	child_delete_thread (main_thread_id);
d1268 4
d1356 1
a1357 1
      current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
d1572 4
a1575 3
    DebugSetProcessKillOnExit (FALSE);

  attach_flag = 1;
a1696 2
  attach_flag = 0;

d1898 1
a1898 2
  if (current_thread && current_thread->h)
    (void) CloseHandle (current_thread->h);
d2150 1
d2202 2
a2203 2
    register_loaded_dll (dll_name, base_addr + 0x1000);
    solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);
d2205 9
a2213 3
  out:
    return 1;
  }
d2215 6
a2220 5
  typedef struct
  {
    struct target_ops *target;
    bfd_vma addr;
  } map_code_section_args;
d2222 5
a2226 12
  static void
  map_single_dll_code_section (bfd * abfd, asection * sect, void *obj)
  {
    int old;
    int update_coreops;
    struct section_table *new_target_sect_ptr;

    map_code_section_args *args = (map_code_section_args *) obj;
    struct target_ops *target = args->target;
    if (sect->flags & SEC_CODE)
      {
	update_coreops = core_ops.to_sections == target->to_sections;
d2228 14
a2241 14
	if (target->to_sections)
	  {
	    old = target->to_sections_end - target->to_sections;
	    target->to_sections = (struct section_table *)
	      xrealloc ((char *) target->to_sections,
			(sizeof (struct section_table)) * (1 + old));
	  }
	else
	  {
	    old = 0;
	    target->to_sections = (struct section_table *)
	      xmalloc ((sizeof (struct section_table)));
	  }
	target->to_sections_end = target->to_sections + (1 + old);
d2243 15
a2257 15
	/* Update the to_sections field in the core_ops structure
	   if needed.  */
	if (update_coreops)
	  {
	    core_ops.to_sections = target->to_sections;
	    core_ops.to_sections_end = target->to_sections_end;
	  }
	new_target_sect_ptr = target->to_sections + old;
	new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
	new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	  bfd_section_size (abfd, sect);;
	new_target_sect_ptr->the_bfd_section = sect;
	new_target_sect_ptr->bfd = abfd;
      }
  }
d2259 2
a2260 2
  static int
  dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
@


1.62.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d386 1
a386 1
    deprecated_read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
d1831 2
d1836 1
d1841 1
d1847 2
@


1.62.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d476 1
a476 1
	error ("Error getting dll name: %u\n", (unsigned) GetLastError ());
a504 1
  DWORD end_addr;
a580 1
  MEMORY_BASIC_INFORMATION m;
a603 6
  if (!VirtualQueryEx (current_process_handle, (void *) load_addr, &m,
		       sizeof (m)))
    so->end_addr = (DWORD) m.AllocationBase + m.RegionSize;
  else
    so->end_addr = load_addr + 0x2000;	/* completely arbitrary */

a710 10
char *
solib_address (CORE_ADDR address)
{
  struct so_stuff *so;
  for (so = &solib_start; so->next != NULL; so = so->next)
    if (address >= so->load_addr && address <= so->end_addr)
      return so->name;
  return NULL;
}

d752 1
a752 1
  return safe_symbol_file_add (name, from_tty, &section_addrs, 0, OBJF_SHARED);
a1200 1
      re_enable_breakpoints_in_shlibs ();
a1307 1
  disable_breakpoints_in_shlibs (1);
a1368 1
  saw_create = 0;
d1621 1
a1621 1
    error ("Error creating process %s, (error %d)\n", exec_file, (unsigned) GetLastError ());
@


1.62.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free
d127 1
d386 1
a386 1
    regcache_collect (r, ((char *) &current_thread->context) + mappings[r]);
a753 53
/* Get the loaded address of all sections, given that .text was loaded
   at text_load. Assumes that all sections are subject to the same
   relocation offset. Returns NULL if problems occur or if the
   sections were not relocated. */

static struct section_addr_info *
get_relocated_section_addrs (bfd *abfd, CORE_ADDR text_load)
{
  struct section_addr_info *result = NULL;
  int section_count = bfd_count_sections (abfd);
  asection *text_section = bfd_get_section_by_name (abfd, ".text");
  CORE_ADDR text_vma;

  if (!text_section)
    {
      /* Couldn't get the .text section. Weird. */
    }

  else if (text_load == (text_vma = bfd_get_section_vma (abfd, text_section)))
    {
      /* DLL wasn't relocated. */
    }

  else
    {
      /* Figure out all sections' loaded addresses. The offset here is
	 such that taking a bfd_get_section_vma() result and adding
	 offset will give the real load address of the section. */

      CORE_ADDR offset = text_load - text_vma;

      struct section_table *table_start = NULL;
      struct section_table *table_end = NULL;
      struct section_table *iter = NULL;

      build_section_table (abfd, &table_start, &table_end);

      for (iter = table_start; iter < table_end; ++iter)
	{
	  /* Relocated addresses. */
	  iter->addr += offset;
	  iter->endaddr += offset;
	}

      result = build_section_addr_info_from_section_table (table_start,
							   table_end);

      xfree (table_start);
    }

  return result;
}

d758 1
a758 3
  struct section_addr_info *section_addrs_ptr = NULL;
  static struct objfile *result = NULL;
  bfd *abfd = NULL;
d767 4
a770 40
  abfd = bfd_openr (name, "pei-i386");

  if (!abfd)
    {
      /* pei failed - try pe */
      abfd = bfd_openr (name, "pe-i386");
    }

  if (abfd)
    {
      if (bfd_check_format (abfd, bfd_object))
	{
	  section_addrs_ptr = get_relocated_section_addrs (abfd, load_addr);
	}

      bfd_close (abfd);
    }

  if (section_addrs_ptr)
    {
      result = safe_symbol_file_add (name, from_tty, section_addrs_ptr,
				     0, OBJF_SHARED);

      free_section_addr_info (section_addrs_ptr);
    }

  else
    {
      /* Fallback on handling just the .text section. */
      struct section_addr_info section_addrs;

      memset (&section_addrs, 0, sizeof (section_addrs));
      section_addrs.other[0].name = ".text";
      section_addrs.other[0].addr = load_addr;

      result = safe_symbol_file_add (name, from_tty, &section_addrs,
				     0, OBJF_SHARED);
    }

  return result;
d853 4
a856 4
	{
	  puts_filtered ("Segment not present\n");
	  return 0;
	}
d865 1
a865 1
	puts_filtered(" 32-bit ");
d867 1
a867 1
	puts_filtered(" 16-bit ");
d871 2
a872 2
	  puts_filtered ("Data (Read-Only, Exp-up");
	  break;
d874 2
a875 2
	  puts_filtered ("Data (Read/Write, Exp-up");
	  break;
d877 2
a878 2
	  puts_filtered ("Unused segment (");
	  break;
d880 2
a881 2
	  puts_filtered ("Data (Read/Write, Exp-down");
	  break;
d883 2
a884 2
	  puts_filtered ("Code (Exec-Only, N.Conf");
	  break;
d886 1
a886 1
	  puts_filtered ("Code (Exec/Read, N.Conf");
d889 1
a889 1
	  puts_filtered ("Code (Exec-Only, Conf");
d892 1
a892 1
	  puts_filtered ("Code (Exec/Read, Conf");
d898 1
a898 1
	puts_filtered(", N.Acc");
d904 1
a904 1
	puts_filtered ("Page granular.\n");
d929 1
a929 1
	current_thread->context.SegCs);
d932 1
a932 1
	current_thread->context.SegDs);
d935 1
a935 1
	current_thread->context.SegEs);
d938 1
a938 1
	current_thread->context.SegSs);
d944 1
a944 1
	current_thread->context.SegGs);
a1376 77
/* Try to set or remove a user privilege to the current process.  Return -1
   if that fails, the previous setting of that privilege otherwise.

   This code is copied from the Cygwin source code and rearranged to allow
   dynamically loading of the needed symbols from advapi32 which is only
   available on NT/2K/XP. */
static int
set_process_privilege (const char *privilege, BOOL enable)
{
  static HMODULE advapi32 = NULL;
  static BOOL WINAPI (*OpenProcessToken)(HANDLE, DWORD, PHANDLE);
  static BOOL WINAPI (*LookupPrivilegeValue)(LPCSTR, LPCSTR, PLUID);
  static BOOL WINAPI (*AdjustTokenPrivileges)(HANDLE, BOOL, PTOKEN_PRIVILEGES,
					      DWORD, PTOKEN_PRIVILEGES, PDWORD);

  HANDLE token_hdl = NULL;
  LUID restore_priv;
  TOKEN_PRIVILEGES new_priv, orig_priv;
  int ret = -1;
  DWORD size;

  if (GetVersion () >= 0x80000000)  /* No security availbale on 9x/Me */
    return 0;

  if (!advapi32)
    {
      if (!(advapi32 = LoadLibrary ("advapi32.dll")))
	goto out;
      if (!OpenProcessToken)
	OpenProcessToken = GetProcAddress (advapi32, "OpenProcessToken");
      if (!LookupPrivilegeValue)
	LookupPrivilegeValue = GetProcAddress (advapi32,
					       "LookupPrivilegeValueA");
      if (!AdjustTokenPrivileges)
	AdjustTokenPrivileges = GetProcAddress (advapi32,
						"AdjustTokenPrivileges");
      if (!OpenProcessToken || !LookupPrivilegeValue || !AdjustTokenPrivileges)
	{
	  advapi32 = NULL;
	  goto out;
	}
    }

  if (!OpenProcessToken (GetCurrentProcess (),
			 TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			 &token_hdl))
    goto out;

  if (!LookupPrivilegeValue (NULL, privilege, &restore_priv))
    goto out;

  new_priv.PrivilegeCount = 1;
  new_priv.Privileges[0].Luid = restore_priv;
  new_priv.Privileges[0].Attributes = enable ? SE_PRIVILEGE_ENABLED : 0;

  if (!AdjustTokenPrivileges (token_hdl, FALSE, &new_priv,
			      sizeof orig_priv, &orig_priv, &size))
    goto out;
#if 0
  /* Disabled, otherwise every `attach' in an unprivileged user session
     would raise the "Failed to get SE_DEBUG_NAME privilege" warning in
     child_attach(). */
  /* AdjustTokenPrivileges returns TRUE even if the privilege could not
     be enabled. GetLastError () returns an correct error code, though. */
  if (enable && GetLastError () == ERROR_NOT_ALL_ASSIGNED)
    goto out;
#endif

  ret = orig_priv.Privileges[0].Attributes == SE_PRIVILEGE_ENABLED ? 1 : 0;

out:
  if (token_hdl)
    CloseHandle (token_hdl);

  return ret;
}

d1387 1
a1387 8
  if (set_process_privilege (SE_DEBUG_NAME, TRUE) < 0)
    {
      printf_unfiltered ("Warning: Failed to get SE_DEBUG_NAME privilege\n");
      printf_unfiltered ("This can cause attach to fail on Windows NT/2K/XP\n");
    }

  pid = strtoul (args, 0, 0);		/* Windows pid */

a1391 8
    {
      /* Try fall back to Cygwin pid */
      pid = cygwin_internal (CW_CYGWIN_PID_TO_WINPID, pid);

      if (pid > 0)
	ok = DebugActiveProcess (pid);

      if (!ok)
a1392 1
    }
d1926 2
a1927 2
		  "Print information specific to Win32 debugging.",
		  &info_w32_cmdlist, "info w32 ", 0, &infolist);
d1930 1
a1930 1
	   "Display selectors infos.",
@


1.62.2.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d605 2
a606 2
  if (VirtualQueryEx (current_process_handle, (void *) load_addr, &m,
		      sizeof (m)))
d638 2
d642 2
a643 2
  if (!ReadProcessMemory (h, address,  &address_ptr, sizeof (address_ptr), &done) 
      || done != sizeof (address_ptr) || !address_ptr)
d647 6
a652 3
  while (ReadProcessMemory (h, address_ptr + len++ * size, &b, size, &done)
	 && (b[0] != 0 || b[size - 1] != 0) && done == size)
    continue;
d952 1
a952 1
	limit = (limit << 12) | 0xfff;
d1574 1
a1574 1
	error ("Can't attach to process.");
d1866 1
a1866 1
  DWORD done = 0;
d1871 2
a1872 3
      if (!WriteProcessMemory (current_process_handle, (LPVOID) memaddr, our,
			       len, &done))
	done = 0;
d1879 2
a1880 3
      if (!ReadProcessMemory (current_process_handle, (LPCVOID) memaddr, our,
			      len, &done))
	done = 0;
d1967 10
a1976 10
	  if (debug_registers_changed)
	    {
	      th->context.Dr0 = dr[0];
	      th->context.Dr1 = dr[1];
	      th->context.Dr2 = dr[2];
	      th->context.Dr3 = dr[3];
	      /* th->context.Dr6 = dr[6];
	       FIXME: should we set dr6 also ?? */
	      th->context.Dr7 = dr[7];
	    }
@


1.62.2.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d845 1
a845 2
      struct section_addr_info *section_addrs;
      struct cleanup *my_cleanups;
d847 3
a849 4
      section_addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, section_addrs);
      section_addrs->other[0].name = ".text";
      section_addrs->other[0].addr = load_addr;
a852 1
      do_cleanups (my_cleanups);
@


1.62.2.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d640 1
a640 1
  if (!ReadProcessMemory (h, address,  &address_ptr, sizeof (address_ptr), &done)
d805 1
a805 1
  struct section_addr_info *addrs = NULL;
d828 1
a828 1
	  addrs = get_relocated_section_addrs (abfd, load_addr);
d834 1
a834 1
  if (addrs)
d836 4
a839 2
      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
      free_section_addr_info (addrs);
d841 1
d845 1
d848 4
a851 4
      addrs = alloc_section_addr_info (1);
      my_cleanups = make_cleanup (xfree, addrs);
      addrs->other[0].name = ".text";
      addrs->other[0].addr = load_addr;
d853 2
a854 1
      result = safe_symbol_file_add (name, from_tty, addrs, 0, OBJF_SHARED);
d2218 2
a2219 1
} map_code_section_args;
@


1.62.2.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d30 1
d73 1
d76 3
@


1.62.2.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d38 1
a54 4
#include "exec.h"

#include "i386-tdep.h"
#include "i387-tdep.h"
d185 1
d197 1
d350 1
a350 4

#define I387_ST0_REGNUM I386_ST0_REGNUM

  if (r == I387_FISEG_REGNUM)
d355 1
a355 1
  else if (r == I387_FOP_REGNUM)
a366 2

#undef I387_ST0_REGNUM
d1628 1
@


1.62.2.9
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d79 2
a80 2
static int debug_registers_changed;
static int debug_registers_used;
a110 1
    int reload_context;
d231 1
d249 13
a261 1
	    th->reload_context = 1;
a351 19
  if (!current_thread)
    return;	/* Windows sometimes uses a non-existent thread id in its
		   events */

  if (current_thread->reload_context)
    {
      thread_info *th = current_thread;
      th->context.ContextFlags = CONTEXT_DEBUGGER_DR;
      GetThreadContext (th->h, &th->context);
      /* Copy dr values from that thread.  */
      dr[0] = th->context.Dr0;
      dr[1] = th->context.Dr1;
      dr[2] = th->context.Dr2;
      dr[3] = th->context.Dr3;
      dr[6] = th->context.Dr6;
      dr[7] = th->context.Dr7;
      current_thread->reload_context = 0;
    }

d379 1
a379 4
  /* Check if current_thread exists.  Windows sometimes uses a non-existent
     thread id in its events */
  if (current_thread)
    do_child_fetch_inferior_registers (r);
d385 1
a385 3
  if (!current_thread)
    /* Windows sometimes uses a non-existent thread id in its events */;
  else if (r >= 0)
d399 1
a399 4
  /* Check if current_thread exists.  Windows sometimes uses a non-existent
     thread id in its events */
  if (current_thread)
    do_child_store_inferior_registers (r);
d1182 1
a1182 1
	      /* Only change the value of the debug registers */
a1199 13
/* Called in pathological case where Windows fails to send a
   CREATE_PROCESS_DEBUG_EVENT after an attach.  */
DWORD
fake_create_process (void)
{
  current_process_handle = OpenProcess (PROCESS_ALL_ACCESS, FALSE,
					current_event.dwProcessId);
  main_thread_id = current_event.dwThreadId;
  current_thread = child_add_thread (main_thread_id,
				     current_event.u.CreateThread.hThread);
  return main_thread_id;
}

d1208 1
a1208 1
  thread_info *th;
a1221 1
  th = NULL;
d1231 1
a1231 11
	{
	  if (!saw_create && attach_flag)
	    {
	      /* Kludge around a Windows bug where first event is a create
		 thread event.  Caused when attached process does not have
		 a main thread. */
	      retval = ourstatus->value.related_pid = fake_create_process ();
	      saw_create++;
	    }
	  break;
	}
d1247 4
a1250 5
      if (current_event.dwThreadId != main_thread_id)
	{
	  child_delete_thread (current_event.dwThreadId);
	  th = &dummy_thread_info;
	}
a1265 2
      if (main_thread_id)
	child_delete_thread (main_thread_id);
d1268 4
d1356 1
a1357 1
      current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
d1572 4
a1575 3
    DebugSetProcessKillOnExit (FALSE);

  attach_flag = 1;
a1696 2
  attach_flag = 0;

d1898 1
a1898 2
  if (current_thread && current_thread->h)
    (void) CloseHandle (current_thread->h);
d2150 1
d2202 2
a2203 2
    register_loaded_dll (dll_name, base_addr + 0x1000);
    solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);
d2205 9
a2213 3
  out:
    return 1;
  }
d2215 6
a2220 5
  typedef struct
  {
    struct target_ops *target;
    bfd_vma addr;
  } map_code_section_args;
d2222 5
a2226 12
  static void
  map_single_dll_code_section (bfd * abfd, asection * sect, void *obj)
  {
    int old;
    int update_coreops;
    struct section_table *new_target_sect_ptr;

    map_code_section_args *args = (map_code_section_args *) obj;
    struct target_ops *target = args->target;
    if (sect->flags & SEC_CODE)
      {
	update_coreops = core_ops.to_sections == target->to_sections;
d2228 14
a2241 14
	if (target->to_sections)
	  {
	    old = target->to_sections_end - target->to_sections;
	    target->to_sections = (struct section_table *)
	      xrealloc ((char *) target->to_sections,
			(sizeof (struct section_table)) * (1 + old));
	  }
	else
	  {
	    old = 0;
	    target->to_sections = (struct section_table *)
	      xmalloc ((sizeof (struct section_table)));
	  }
	target->to_sections_end = target->to_sections + (1 + old);
d2243 15
a2257 15
	/* Update the to_sections field in the core_ops structure
	   if needed.  */
	if (update_coreops)
	  {
	    core_ops.to_sections = target->to_sections;
	    core_ops.to_sections_end = target->to_sections_end;
	  }
	new_target_sect_ptr = target->to_sections + old;
	new_target_sect_ptr->addr = args->addr + bfd_section_vma (abfd, sect);
	new_target_sect_ptr->endaddr = args->addr + bfd_section_vma (abfd, sect) +
	  bfd_section_size (abfd, sect);;
	new_target_sect_ptr->the_bfd_section = sect;
	new_target_sect_ptr->bfd = abfd;
      }
  }
d2259 2
a2260 2
  static int
  dll_code_sections_add (const char *dll_name, int base_addr, struct target_ops *target)
@


1.61
log
@	Fix PR gdb/393:
	* inflow.c (terminal_save_ours): New function to save terminal
	settings.
	* inferior.h (terminal_save_ours): Declare.
	* target.c (debug_to_terminal_save_ours): New function.
	(cleanup_target): Defaults to_terminal_save_ours.
	(update_current_target): Inherit to_terminal_save_ours.
	(setup_target_debug): Set to_terminal_save_ours.
	* target.h (target_terminal_save_ours): New to save terminal settings.
	(target_ops): New member to_terminal_save_ours.
	* gnu-nat.c (init_gnu_ops): Set to_terminal_save_ours.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* inftarg.c (init_child_ops): Likewise.
	* m3-nat.c (init_m3_ops): Likewise.
	* procfs.c (init_procfs_ops): Likewise.
	* wince.c (init_child_ops): Likewise.
	* win32-nat.c (init_child_ops): Likewise.
	* sol-thread.c (init_sol_thread_ops): Likewise.
@
text
@d1464 2
d1578 21
d1609 11
@


1.61.2.1
log
@* win32-nat.c (child_attach): Reset saw_create counter or subsequent attach
will hang.
* win32-nat.c (psapi_get_dll_name): Fix a compiler warning.
(struct so_stuff): Add end_addr field.
(register_loaded_dll): Calculate and store end address of loaded dll.
(solib_address): New function.
(child_solib_loaded_library_pathname): Pass carefully constructed section info
to safe_symbol_file_add rather than ignoring it.
(get_child_debug_event): Call re_enable_breakpoints_in_shlibs when a DLL is
loaded.
(do_initial_child_stuff): Call disable_breakpoints_in_shlibs.
(child_create_inferior): Fix a compiler warning.
* config/i386/tm-cygwin.h (PC_SOLIB): Define new macro.
(solib_address): Declare new function.
@
text
@d476 1
a476 1
	error ("Error getting dll name: %u\n", (unsigned) GetLastError ());
a504 1
  DWORD end_addr;
a580 1
  MEMORY_BASIC_INFORMATION m;
a603 6
  if (!VirtualQueryEx (current_process_handle, (void *) load_addr, &m,
		       sizeof (m)))
    so->end_addr = (DWORD) m.AllocationBase + m.RegionSize;
  else
    so->end_addr = load_addr + 0x2000;	/* completely arbitrary */

a710 10
char *
solib_address (CORE_ADDR address)
{
  struct so_stuff *so;
  for (so = &solib_start; so->next != NULL; so = so->next)
    if (address >= so->load_addr && address <= so->end_addr)
      return so->name;
  return NULL;
}

d752 1
a752 1
  return safe_symbol_file_add (name, from_tty, &section_addrs, 0, OBJF_SHARED);
a1200 1
      re_enable_breakpoints_in_shlibs ();
a1307 1
  disable_breakpoints_in_shlibs (1);
a1368 1
  saw_create = 0;
d1587 1
a1587 1
    error ("Error creating process %s, (error %d)\n", exec_file, (unsigned) GetLastError ());
@


1.60
log
@Fix some K&R isms.
@
text
@d1794 1
@


1.59
log
@* wince.c (_initialize_wince): Rename _initialize_inftarg.
* win32-nat.c (_initialize_win32_nat): Rename _initialize_inftarg.
@
text
@d1337 1
a1337 1
has_detach_ability ()
@


1.58
log
@* win32-nat.c (child_create_inferior): Check for proper shell to use here, in
case the user changes it on the fly.
(_initialize_inftarg): Remove shell path considerations.
@
text
@d1818 1
a1818 1
_initialize_inftarg (void)
@


1.58.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1337 1
a1337 1
has_detach_ability (void)
d1818 1
a1818 1
_initialize_win32_nat (void)
@


1.58.6.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a1793 1
  child_ops.to_terminal_save_ours = terminal_save_ours;
@


1.58.6.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a1463 2
  int tty;
  int ostdin, ostdout, ostderr;
a1575 21
  if (!inferior_io_terminal)
    tty = ostdin = ostdout = ostderr = -1;
  else
    {
      tty = open (inferior_io_terminal, O_RDWR | O_NOCTTY);
      if (tty < 0)
	{
	  print_sys_errmsg (inferior_io_terminal, errno);
	  ostdin = ostdout = ostderr = -1;
	}
      else
	{
	  ostdin = dup (0);
	  ostdout = dup (1);
	  ostderr = dup (2);
	  dup2 (tty, 0);
	  dup2 (tty, 1);
	  dup2 (tty, 2);
	}
    }

a1585 11
  if (tty >= 0)
    {
      close (tty);
      dup2 (ostdin, 0);
      dup2 (ostdout, 1);
      dup2 (ostderr, 2);
      close (ostdin);
      close (ostdout);
      close (ostderr);
    }

@


1.58.6.4
log
@merge from mainline
@
text
@d386 1
a386 1
    deprecated_read_register_gen (r, ((char *) &current_thread->context) + mappings[r]);
@


1.57
log
@* cli/cli-decode.c (set_cmd_completer): New function.
* command.h (set_cmd_completer): Declare.
* cli/cli-decode.h (set_cmd_completer): Ditto.

* breakpoint.c (_initialize_breakpoint): Use set_cmd_completer.
* cli/cli-cmds.c (init_cli_cmds): Ditto.
* win32-nat.c (_initialize_inftarg): Ditto.
* remote-rdi.c (_initialize_remote_rdi): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* hppa-tdep.c (_initialize_hppa_tdep): Ditto.
* source.c (_initialize_source): Ditto.
* exec.c (_initialize_exec): Ditto.
* solib.c (_initialize_solib): Ditto.
* top.c (init_main): Ditto.
* tracepoint.c (_initialize_tracepoint): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* printcmd.c (_initialize_printcmd): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
@
text
@d126 2
a127 1
static DWORD main_thread_id;	/* Thread ID of the main thread */
a142 3
/* Path to shell */
static char shell[MAX_PATH + 1];

d1462 2
d1471 1
a1471 1
  if (!useshell || !shell[0])
d1479 7
a1485 2
      char *newallargs = alloca (sizeof (" -c 'exec  '") + strlen (exec_file)
				 + strlen (allargs) + 2);
d1505 1
a1505 1
    /* This code use to assume all env vars were file names and would
a1820 1
  const char *sh;
a1826 14

  sh = getenv ("SHELL");
  if (!sh)
    sh = "/bin/sh";
  if (access (sh, X_OK) != 0)
    {
      shell[0] = '\0';
      useshell = 0;
    }
  else
    {
      cygwin_conv_to_win32_path (sh, shell);
      useshell = 1;
    }
@


1.56
log
@2002-02-22  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c (child_create_inferior): Fix create flags setting bug.
@
text
@d1822 1
a1822 1
  c->completer = filename_completer;
@


1.56.2.1
log
@2002-04-08  Pierre Muller  <muller@@ics.u-strasbg.fr>

	from 2002-03-22  Christopher Faylor  <cgf@@redhat.com> patch
	in main branch.
	* win32-nat.c (child_create_inferior): Check for proper shell to use
	here, in case the user changes it on the fly.
	(_initialize_inftarg): Remove shell path considerations.
@
text
@d126 1
a126 2
static DWORD main_thread_id;		/* Thread ID of the main thread */
static pid_t cygwin_pid;		/* pid of cygwin process */
d142 3
a1463 2
  char shell[MAX_PATH + 1]; /* Path to shell */
  const char *sh;
d1471 1
a1471 1
  if (!useshell)
d1479 2
a1480 7
      char *newallargs;
      sh = getenv ("SHELL");
      if (!sh)
	sh = "/bin/sh";
      cygwin_conv_to_win32_path (sh, shell);
      newallargs = alloca (sizeof (" -c 'exec  '") + strlen (exec_file)
			   + strlen (allargs) + 2);
d1500 1
a1500 1
    /* This code used to assume all env vars were file names and would
d1816 1
d1823 14
@


1.55
log
@* win32-nat.c (register_loaded_dll): Just use raw name when we can't find the
complete path to a loaded DLL.
@
text
@a1470 8
  flags = 0;

  if (new_group)
    flags |= CREATE_NEW_PROCESS_GROUP;

  if (new_console)
    flags |= CREATE_NEW_CONSOLE;

d1479 2
a1480 1
      char *newallargs = alloca (sizeof (" -c 'exec  '") + strlen (exec_file) + strlen (allargs) + 2);
d1486 6
@


1.54
log
@* win32-nat.c (register_loaded_dll): Correctly check for invalid handle value.
@
text
@d585 3
a587 1
  if (h != INVALID_HANDLE_VALUE)
@


1.53
log
@* win32-nat.c (register_loaded_dll): Handle case where FindFirstFile fails.
@
text
@d585 1
a585 1
  if (h)
@


1.52
log
@2002-02-18  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c (display_selector): New function. Displays information
	about the information returned by GetThreadSelectorEntry API function.
	(display_selectors): New function. Displays the infomation of
	the selector given as argument, or of CS, DS ans FS selectors
	if no argument is given.
	( _initialize_inftarg): Add "w32" as info prefix command.
	Add "info w32 selector" as command calling display_selectors.
@
text
@d585 1
a585 3
  FindClose (h);
  strcpy (buf, name);
  if (GetCurrentDirectory (MAX_PATH + 1, cwd))
d587 11
a597 6
      p = strrchr (buf, '\\');
      if (p)
	p[1] = '\0';
      SetCurrentDirectory (buf);
      GetFullPathName (w32_fd.cFileName, MAX_PATH, buf, &p);
      SetCurrentDirectory (cwd);
@


1.51
log
@* win32-nat.c (get_image_name): New function.
(handle_load_dll): Use get_image_name function.
(get_child_debug_event): Avoid registering debug events until possibly execed
process is started.
(child_create_inferior): Allow invocation via shell so that command line
redirection, etc.  works ok.
(_initialize_inftarg): Add new command: "set shell" to control whether a shell
is used to start a process.
@
text
@d823 120
d1880 8
@


1.50
log
@* win32-nat.c (cygwin_pid_to_str): Revert 2002-02-08 change xasprintf changes.
(_initialize_check_for_gdb_ini): Ditto.
@
text
@d25 1
a25 1
/* by Steve Chamberlain, sac@@cygnus.com */
d89 1
a89 1
#define DEBUG_EXEC(x)	if (debug_exec)		printf_unfiltered x 
d131 1
d136 3
a138 3
static int debug_exec = 0;	/* show execution */
static int debug_events = 0;	/* show events from kernel */
static int debug_memory = 0;	/* show target memory accesses */
d140 4
d234 1
a234 1
    printf_filtered ("error return %s:%d was %lu\n", file, line, 
d292 1
a292 1
  /* Set the debug registers for the new thread in they are used.  */ 
d612 46
a663 2
  DWORD dll_name_ptr;
  DWORD done;
d675 2
a676 56
  /* Attempt to read the name of the dll that was detected.
     This is documented to work only when actively debugging
     a program.  It will not work for attached processes. */
  if (dll_name == NULL || *dll_name == '\0')
    {
      DWORD size = event->fUnicode ? sizeof (WCHAR) : sizeof (char);
      int len = 0;
      char b[2];

      ReadProcessMemory (current_process_handle,
			 (LPCVOID) event->lpImageName,
			 (char *) &dll_name_ptr,
			 sizeof (dll_name_ptr), &done);

      /* See if we could read the address of a string, and that the
	 address isn't null. */

      if (done != sizeof (dll_name_ptr) || !dll_name_ptr)
	return 1;

      do
	{
	  ReadProcessMemory (current_process_handle,
			     (LPCVOID) (dll_name_ptr + len * size),
			     &b,
			     size,
			     &done);
	  len++;
	}
      while ((b[0] != 0 || b[size - 1] != 0) && done == size);

      dll_name = alloca (len);

      if (event->fUnicode)
	{
	  WCHAR *unicode_dll_name = (WCHAR *) alloca (len * sizeof (WCHAR));
	  ReadProcessMemory (current_process_handle,
			     (LPCVOID) dll_name_ptr,
			     unicode_dll_name,
			     len * sizeof (WCHAR),
			     &done);

	  WideCharToMultiByte (CP_ACP, 0,
			       unicode_dll_name, len,
			       dll_name, len, 0, 0);
	}
      else
	{
	  ReadProcessMemory (current_process_handle,
			     (LPCVOID) dll_name_ptr,
			     dll_name,
			     len,
			     &done);
	}
    }

d783 1
a783 1
  printf_filtered ("%*s  Load Address\n", -max_dll_name_len, "DLL Name"); 
d941 1
a941 1
		  continue_status == DBG_CONTINUE ? 
d964 1
a964 1
	         FIXME: should we set dr6 also ?? */
d1005 2
d1022 2
d1034 6
a1040 1

d1057 2
d1071 2
d1085 2
d1098 2
d1109 2
d1116 2
d1126 1
a1126 1
  if (!retval)
d1178 1
a1178 1
  debug_registers_used = 0;  
a1327 1
  char real_path[MAXPATHLEN];
d1337 2
d1346 1
a1346 3
  cygwin_conv_to_win32_path (exec_file, real_path);

  flags = DEBUG_ONLY_THIS_PROCESS;
d1354 14
a1367 3
  args = alloca (strlen (real_path) + strlen (allargs) + 2);

  strcpy (args, real_path);
d1369 2
d1462 6
d1560 1
a1560 1
  structure when passing the exception to the inferior. 
d1578 1
a1578 1
	DEBUG_EXCEPT(("Can only continue with recieved signal %d.\n", 
d1602 7
a1608 7
          th->context.Dr0 = dr[0];
          th->context.Dr1 = dr[1];
          th->context.Dr2 = dr[2];
          th->context.Dr3 = dr[3];
          /* th->context.Dr6 = dr[6];
           FIXME: should we set dr6 also ?? */
          th->context.Dr7 = dr[7];
d1692 1
d1700 14
d1716 6
d2067 1
a2067 1
	  sprintf (newini, "%.*s.gdbinit", 
@


1.49
log
@2002-02-08  Martin M. Hunt  <hunt@@redhat.com>

	* win32-nat.c (cygwin_pid_to_str): Fix typo.
	xaprintf -> xasprintf.
@
text
@d1766 1
a1766 1
    xasprintf (buf, "process %d", pid);
d1768 1
a1768 1
    xasprintf (buf, "thread %ld.0x%x", current_event.dwProcessId, pid);
d2012 1
a2012 1
	  xasprintf (newini, "%.*s.gdbinit", 
@


1.48
log
@2002-02-08  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c: Remove use of printf and sprintf functions.
@
text
@d1766 1
a1766 1
    xaprintf (buf, "process %d", pid);
@


1.47
log
@2002-02-06  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c (_initialize_check_for_gdb_ini):
	Add typecast to sprintf argument to suppress a warning.
@
text
@d89 4
a92 4
#define DEBUG_EXEC(x)	if (debug_exec)		printf x
#define DEBUG_EVENTS(x)	if (debug_events)	printf x
#define DEBUG_MEM(x)	if (debug_memory)	printf x
#define DEBUG_EXCEPT(x)	if (debug_exceptions)	printf x
d788 1
a788 1
  printf ("%*s  Load Address\n", -max_dll_name_len, "DLL Name");
d829 1
a829 1
  printf ("gdb: Target exception %s at 0x%08lx\n", x, \
d1766 1
a1766 1
    sprintf (buf, "process %d", pid);
d1768 1
a1768 1
    sprintf (buf, "thread %ld.0x%x", current_event.dwProcessId, pid);
d2012 1
a2012 1
	  sprintf (newini, "%.*s.gdbinit", 
@


1.46
log
@2002-02-05  Pierre Muller  <muller@@ics.u-strasbg.fr>

	win32-nat.c (last_sig): Changed type of variable to target_signal,
	to allow easier handling of pass state.
	(DEBUG_EXCEPTION_SIMPLE): New macro, used in handle_exception,
	that gives exception name and address.
	(handle_exception): Use DEBUG_EXCEPTION_SIMPLE macro
	and set last_sig value to ourstatus->value.sig. Some missing
	exceptions added.
	(child_continue): Correctly report continue_status.
	(get_child_debug_event,do_initial_child_stuff): Set last_sig to
	TARGET_SIGNAL_0 (new default value).
	(child_resume): consider sig argument passed to decide if
	the exception should be passed to debuggee or not.
@
text
@d2012 2
a2013 1
	  sprintf (newini, "%.*s.gdbinit", len - (sizeof ("gdb.ini") - 1), oldini);
@


1.45
log
@2002-02-04  Pierre Muller  <muller@@ics.u-strasbg.fr>
          win32-nat.c (handle_exception): Handle Ctrl-Break exception.
@
text
@d101 3
a103 2
static int last_sig = 0;	/* Set if a signal was received from the
				   debugged process */
d222 1
d828 4
d846 5
a850 2
      DEBUG_EXCEPT (("gdb: Target exception ACCESS_VIOLATION at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d852 24
a875 1
      last_sig = SIGSEGV;
d878 3
d882 3
a884 1
    case STATUS_FLOAT_OVERFLOW:
d886 1
a886 2
      DEBUG_EXCEPT (("gdb: Target exception STACK_OVERFLOW at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
a887 1
      last_sig = SIGFPE;
d889 3
a891 4
    case STATUS_STACK_OVERFLOW:
      DEBUG_EXCEPT (("gdb: Target exception STACK_OVERFLOW at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
      ourstatus->value.sig = TARGET_SIGNAL_SEGV;
d894 1
a894 2
      DEBUG_EXCEPT (("gdb: Target exception BREAKPOINT at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d898 1
a898 2
      DEBUG_EXCEPT (("gdb: Target exception CONTROL_C at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
a899 1
      last_sig = SIGINT;	/* FIXME - should check pass state */
d902 1
a902 2
      DEBUG_EXCEPT (("gdb: Target exception CONTROL_BREAK at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
a903 1
      last_sig = SIGINT;	/* FIXME - should check pass state */
d906 1
a906 2
      DEBUG_EXCEPT (("gdb: Target exception SINGLE_STEP at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d910 9
a918 2
      DEBUG_EXCEPT (("gdb: Target exception SINGLE_ILL at 0x%08lx\n",
       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
a919 1
      last_sig = SIGILL;
d931 1
d944 4
a947 2
  DEBUG_EVENTS (("ContinueDebugEvent (cpid=%ld, ctid=%ld, DBG_CONTINUE);\n",
		 current_event.dwProcessId, current_event.dwThreadId));
d992 1
a992 1
  last_sig = 0;
d1158 1
a1158 1
  last_sig = 0;
d1510 2
a1511 2
  DWORD continue_status = last_sig > 0 && last_sig < NSIG ?
  DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;
d1514 35
a1548 1
  last_sig = 0;
@


1.44
log
@2002-02-04  Pierre Muller  <muller@@ics.u-strasbg.fr>

	Add support for hardware watchpoints on win32 native.
	* win32-nat.c (CONTEXT_DEBUG_DR macro): Add use of
	CONTEXT_DEBUG_REGISTERS.
	(dr variable): New variable. Static array containing a local copy
	of debug registers.
	(debug_registers_changed): New variable.  Reflects when debug registers
	are changed and need to be written to inferior.
	(debug_registers_used): New variable. Reflects when any debug register
	was set, used when new threads are created.
	(cygwin_set_dr, cygwin_set_dr7, cygwin_get_dr6): New functions used by
	i386-nat code.
	(thread_rec): Set dr array if id is the thread of current_event .
	(child_continue, child_resume): Change the debug registers for all
	threads if debug_registers_changed.
	(child_add_thread): Change the debug registers if debug_registers_used.
	* config/i386/cygwin.mh: Add use of i386-nat.o file.
	Link nm.h to new nm-cygwin.h file.
	+ config/i386/nm-cygwin.h: New file. Contains the macros used for use
	of hardware registers.
@
text
@d870 6
@


1.43
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d74 2
a75 1
#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_EXTENDED_REGISTERS
d77 1
a77 1
#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER
d80 3
d223 9
d252 10
d285 16
a346 7
check (BOOL ok, const char *file, int line)
{
  if (!ok)
    printf_filtered ("error return %s:%d was %lu\n", file, line, GetLastError ());
}

static void
d913 1
d917 14
d933 1
d1113 1
d1118 4
d1401 1
d1489 10
d1631 37
@


1.42
log
@2002-01-06  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c: Add i386-tdep.h dependency.
@
text
@d2 4
a5 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d576 1
a576 1
handle_load_dll (void *dummy ATTRIBUTE_UNUSED)
d657 1
a657 1
handle_unload_dll (void *dummy ATTRIBUTE_UNUSED)
d681 1
a681 1
child_solib_loaded_library_pathname (int pid ATTRIBUTE_UNUSED)
d747 1
a747 1
info_dll_command (char *ignore ATTRIBUTE_UNUSED, int from_tty ATTRIBUTE_UNUSED)
d893 1
a893 1
get_child_debug_event (int pid ATTRIBUTE_UNUSED, struct target_waitstatus *ourstatus)
d1163 1
a1163 1
child_detach (char *args ATTRIBUTE_UNUSED, int from_tty)
d1195 1
a1195 1
child_files_info (struct target_ops *ignore ATTRIBUTE_UNUSED)
d1203 1
a1203 1
child_open (char *arg ATTRIBUTE_UNUSED, int from_tty ATTRIBUTE_UNUSED)
d1365 2
a1366 2
		   int write, struct mem_attrib *mem ATTRIBUTE_UNUSED,
		   struct target_ops *target ATTRIBUTE_UNUSED)
d1459 1
a1459 1
child_close (int x ATTRIBUTE_UNUSED)
d1763 2
a1764 1
child_solib_add (char *filename ATTRIBUTE_UNUSED, int from_tty, struct target_ops *target, int readsyms)
@


1.41
log
@2001-11-30  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* win32-nat.c (mappings): Correct position of XMM registers,
	based on FXSAVE instruction structure.
@
text
@d37 1
@


1.40
log
@fix white space.
@
text
@d182 10
a191 10
  context_offset (ExtendedRegisters[0*16]),
  context_offset (ExtendedRegisters[1*16]),
  context_offset (ExtendedRegisters[2*16]),
  context_offset (ExtendedRegisters[3*16]),
  context_offset (ExtendedRegisters[4*16]),
  context_offset (ExtendedRegisters[5*16]),
  context_offset (ExtendedRegisters[6*16]),
  context_offset (ExtendedRegisters[7*16]),
  /* MXCSR untested */
  context_offset (ExtendedRegisters[8*16])
@


1.39
log
@* config/i386/tm-cygwin.h: Define HAVE_SSE_REGS if
HAVE_CONTEXT_EXTENDED_REGISTERS is defined.
* win32-nat.c: Define CONTEXT_DEBUGGER_DR that will also include extended
registers if HAVE_SSE_REGS is defined.
(mappings array): Add offset of extended registers.
(thread_rec): Use new CONTEXT_DEBUGGER_DR macro.
@
text
@d71 1
a71 1
#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_EXTENDED_REGISTERS 
d368 1
a368 1
int 
d604 1
a604 1
         address isn't null. */
d986 1
a986 1
         does not exist yet. */
d1169 1
a1169 1
        {
d1173 1
a1173 1
        }
d1459 1
a1459 1
                PIDGET (inferior_ptid)));
d1659 1
a1659 1
         if needed.  */
d1773 1
a1773 1
                                                solib_end->load_addr);
@


1.38
log
@* win32-nat.c (struct so_stuff): Add objfile *objfile field needed to be able
to remove the DLL when unloaded.  Remove unused last field.
(handle_unload_dll): New function to handle unloading of DLL.
(solib_symbols_add): Change return type to struct objfile *.
(get_child_debug_event): Call handle_unload_dll function.
@
text
@d28 1
d70 7
d180 13
d234 1
a234 1
	    th->context.ContextFlags = CONTEXT_DEBUGGER;
@


1.37
log
@* win32-nat.c (_initialize_check_for_gdb_ini): New function.
* config/i386/xm-cygwin.h: Remove obsolete handling of __CYGWIN32__.
(GDBINIT_FILENAME): Remove.
@
text
@d442 1
a442 1
  struct so_stuff *next, **last;
d445 1
d472 1
a472 1
  /* ui_file_delete (gdb_stderr); */
d474 1
a474 1
  /* gdb_stderr = sp->err; */
d494 1
a494 1
  /* gdb_stderr = ui_file_new (); */
d538 2
a543 1
  so->next = NULL;
d632 23
d675 1
d681 1
a681 1
static void
d691 1
a691 1
    return;
d696 1
a696 3
  safe_symbol_file_add (name, from_tty, NULL, 0, OBJF_SHARED);

  return;
d962 5
a966 1
      break;			/* FIXME: don't know what to do here */
d1751 2
a1752 1
	solib_symbols_add (solib_end->name, from_tty, solib_end->load_addr);
@


1.36
log
@Approved by kev@@cygnus.com
ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* coff-solib.c (coff_solib_add): Add new readsyms arg.
	* irix5-nat.c (solib_add): Ditto.
	* osfsolib.c (solib_add): Ditto.
	* pa64solib.c (pa64_solib_add): Ditto.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* solib.c (solib_add): Ditto.
	* somsolib.c (som_solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* coff-solib.h (coff_solib_add): Add new readsyms arg to prototype.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* pa64solib.h (pa64_solib_add): Ditto.
	* solib.h (solib_add): Ditto.
	* somsolib.h (som_solib_add): Ditto.
	* config/i386/tm-cygwin.h (child_solib_add): Ditto.

	* coff-solib.c (coff_solib_add):  If readsyms is zero don't read
	symbols but do any other needed work for shared libs.
	* irix5-nat.c: Ditto.
	* osfsolib.c (solib_add): Ditto.
	* solib.c (solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* irix5-nat.c (sharedlibrary_command): Pass 1 as readsyms to
	solib_add to force reading of shared library symbols.
	* osfsolib.c (sharedlibrary_command;): Ditto.
	* pa64solib.c (pa64_solib_sharedlibrary_command): Ditto.
	* solib.c (sharedlibrary_command): Ditto.
	* somsolib.c (som_solib_sharedlibrary_command): Ditto.
	* xcoffsolib.c (sharedlibrary_command): Ditto.

	* coff-solib.c (coff_solib_create_inferior_hook): Call solib_add
	unconditionally with auto_solib_add.
	* irix5-nat.c (solib_create_inferior_hook): Ditto.
	* osfsolib.c (solib_create_inferior_hook): Ditto.
	* solib.c (solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-svr4.c (enable_break): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.

	* corelow.c (solib_add_stub): Add auto_solib_add to args passed
	via SOLIB_ADD.
	* sol-thread.c (sol_thread_attach): Ditto.
	* config/rs6000/nm-rs6000.h (SOLIB_ADD): Ditto.

	* infcmd.c (attach_command): Remove auto_solib_add decl.
	Call SOLIB_ADD directly with auto_solib_add.
	* infrun.c (handle_inferior_event): Ditto.

	* coff-solib.h (SOLIB_ADD): Add readsyms arg.
	* pa64solib.h (SOLIB_ADD): Ditto.
	* solib.h (SOLIB_ADD): Ditto.
	* somsolib.h (SOLIB_ADD): Ditto.
	* config/i386/tm-cygwin.h (SOLIB_ADD): Ditto.

	* fork-child.c (clone_and_follow_inferior): Remove unused
	auto_solib_add decl.

	* pa64solib.c (pa64_solib_add): Call add_to_solist with readsyms.
	(read_dld_descriptor): Ditto.
	(pa64_solib_add): Call read_dld_descriptor with	readsyms.
	(pa64_solib_in_dynamic_linker): Ditto.

	* corelow.c (symfile.h): Need this for auto_solib_add declaration.
	* sol-thread.c (symfile.h): Ditto.

Approved by eliz@@is.elta.co.il
doc/ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* gdbint.texinfo (SOLIB_ADD): Document additional new
	"readsyms" arg.
@
text
@d35 1
d1756 28
@


1.35
log
@* win32-nat.c (register_loaded_dll): Attempt to ensure that the case of the
loaded DLL matches the on-disk case since the debugging API does not seem to
ensure this.  Calculate max name length here.
(handle_load_dll): Move max name length calculation to register_loaded_dll.
@
text
@d1710 1
a1710 1
child_solib_add (char *filename ATTRIBUTE_UNUSED, int from_tty, struct target_ops *target)
d1712 2
@


1.34
log
@	2001-10-30  Fred Fish  <fnf@@redhat.com>
	* somsolib.c (som_solib_add): A megabyte is 1024*1024 bytes.
	* pa64solib.c (add_to_solist): Ditto.
	* win32-nat.c (_initialize_inftarg): Remove unnecessary
	initialization of auto_solib_add, it defaults to 1.
@
text
@d513 20
a532 1
  cygwin_conv_to_posix_path (name, ppath);
d541 3
a555 1
  int len;
a623 3
  while ((p = strchr (dll_name, '\\')))
    *p = '/';

a624 3
  len = strlen (dll_name);
  if (len > max_dll_name_len)
    max_dll_name_len = len;
@


1.33
log
@        * win32-nat.c (DebugSetProcessKillOnExit): New static function
        pointer to Windows' DebugSetProcessKillOnExit() function.
        (DebugActiveProcessStop): Ditto for DebugActiveProcessStop().
        (has_detach_ability): New function.
        (child_attach): If system has detach ability, enable it.
        (child_detach): If system has detach ability, actually
        detach from process.
        Change tty output to Linux format.
@
text
@a1455 1
  auto_solib_add = 1;
@


1.32
log
@* win32-nat.c (handle_load_dll): Avoid strlwr'ing loaded DLLs or cygwin may not
be able to read them in certain situations.
@
text
@d1025 29
a1054 1

d1070 6
d1097 15
a1111 1
  if (from_tty)
d1116 2
a1117 2
      printf_unfiltered ("Detaching from program: %s %s\n", exec_file,
			 target_pid_to_str (inferior_ptid));
@


1.31
log
@* win32-nat.c (safe_symbol_file_add_stub): Improve logic for avoiding load of
already loaded DLL.
(register_loaded_dll): Convert loaded DLL name to "posix" format or it will
confuse subsequent opening of the filename due to dos paths.
(dll_symbol_command): Pass from_tty parameter to safe_symbol_file_add.
@
text
@a602 2
  (void) strlwr (dll_name);

@


1.30
log
@* win32-nat.c (safe_symbol_file_add_stub): Properly initialize linked list
pointer to beginning rather than one beyond beginning.
@
text
@d443 3
a445 3
  char name[0];
}
solib_start, *solib_end;
d456 1
a456 1
    if (strcasecmp (so->name, p->name) == 0)
d512 4
a515 1
  so = (struct so_stuff *) xmalloc (sizeof (struct so_stuff) + strlen (name) + 8 + 2);
d517 1
a517 1
  strcpy (so->name, name);
d656 1
a656 1
  safe_symbol_file_add (name, from_tty, 0, 0, OBJF_SHARED);
d663 1
a663 1
dll_symbol_command (char *args, int from_tty ATTRIBUTE_UNUSED)
d680 1
a680 1
  safe_symbol_file_add (args, 0, NULL, 0, OBJF_SHARED | OBJF_USERLOADED);
@


1.29
log
@* config/i386/tm-cygwin.h: include tm-i386.h instead of tm-i386v.h.  This fixes
errors in "long long" handling for 'finish' and 'return' commands.
* win32-nat.c (safe_symbol_file_add_stub): Avoid adding a shared library if it
has already been loaded.
(safe_symbol_file_add_cleanup): Don't mess with stderr or we won't see any
error messages.
(safe_symbol_file_add): Ditto.
(solib_symbols_add): Make static.  Accept 'from_tty' parameter.  Pass it to
safe_symbol_file_add.
(core_dll_symbols_add): Accomodate extra solib_symbols_add parameter.
(child_solib_add): Ditto.
* win32-nat.c (handle_exception): Don't print "first chance" exceptions.
(get_child_debug_event): Continue from exceptions if !handle_exception.
@
text
@d453 1
a453 1
  struct so_stuff *so = solib_start.next;
@


1.28
log
@* win32-nat.c (get_child_debug_event): Close file handles created after process
creation and DLL load.
(child_create_inferior): Close unneeded process/thread handle after thread
creation.
@
text
@d438 9
d453 5
d470 1
a470 1
  ui_file_delete (gdb_stderr);
d472 1
a472 1
  gdb_stderr = sp->err;
d492 1
a492 1
  gdb_stderr = ui_file_new ();
a504 9
/* Maintain a linked list of "so" information. */
struct so_stuff
{
  struct so_stuff *next, **last;
  DWORD load_addr;
  char name[0];
}
solib_start, *solib_end;

d638 2
a639 2
void
solib_symbols_add (char *name, CORE_ADDR load_addr)
d653 1
a653 1
  safe_symbol_file_add (name, 0, &section_addrs, 0, OBJF_SHARED);
d785 2
d928 2
a929 2
      handle_exception (ourstatus);
      retval = current_event.dwThreadId;
d1504 1
a1504 1
  solib_symbols_add (dll_name, (CORE_ADDR) base_addr + 0x1000);
d1647 1
a1647 1
child_solib_add (char *filename ATTRIBUTE_UNUSED, int from_tty ATTRIBUTE_UNUSED, struct target_ops *target)
d1657 1
a1657 1
	solib_symbols_add (solib_end->name, solib_end->load_addr);
@


1.27
log
@Phase 1 of the ptid_t changes.
@
text
@d871 1
d901 1
d1212 2
@


1.27.4.1
log
@* win32-nat.c (get_child_debug_event): Close file handles created after process
creation and DLL load.
(child_create_inferior): Close unneeded process/thread handle after thread
creation.
@
text
@a870 1
      CloseHandle (current_event.u.CreateProcessInfo.hFile);
a899 1
      CloseHandle (current_event.u.LoadDll.hFile);
a1209 2
  CloseHandle (pi.hThread);
  CloseHandle (pi.hProcess);
@


1.27.4.2
log
@* config/i386/tm-cygwin.h: include tm-i386.h instead of tm-i386v.h.  This fixes
errors in "long long" handling for 'finish' and 'return' commands.
* win32-nat.c (safe_symbol_file_add_stub): Avoid adding a shared library if it
has already been loaded.
(safe_symbol_file_add_cleanup): Don't mess with stderr or we won't see any
error messages.
(safe_symbol_file_add): Ditto.
(solib_symbols_add): Make static.  Accept 'from_tty' parameter.  Pass it to
safe_symbol_file_add.
(core_dll_symbols_add): Accomodate extra solib_symbols_add parameter.
(child_solib_add): Ditto.
* win32-nat.c (handle_exception): Don't print "first chance" exceptions.
(get_child_debug_event): Continue from exceptions if !handle_exception.
@
text
@a437 9
/* Maintain a linked list of "so" information. */
struct so_stuff
{
  struct so_stuff *next, **last;
  DWORD load_addr;
  char name[0];
}
solib_start, *solib_end;

a443 5
  struct so_stuff *so = solib_start.next;

  while ((so = so->next))
    if (strcasecmp (so->name, p->name) == 0)
      return 0;
d456 1
a456 1
  /* ui_file_delete (gdb_stderr); */
d458 1
a458 1
  /* gdb_stderr = sp->err; */
d478 1
a478 1
  /* gdb_stderr = ui_file_new (); */
d491 9
d633 2
a634 2
static void
solib_symbols_add (char *name, int from_tty, CORE_ADDR load_addr)
d648 1
a648 1
  safe_symbol_file_add (name, from_tty, 0, 0, OBJF_SHARED);
a779 2
      if (current_event.u.Exception.dwFirstChance)
	return 0;
d921 2
a922 2
      if (handle_exception (ourstatus))
	retval = current_event.dwThreadId;
d1497 1
a1497 1
  solib_symbols_add (dll_name, 0, (CORE_ADDR) base_addr + 0x1000);
d1640 1
a1640 1
child_solib_add (char *filename ATTRIBUTE_UNUSED, int from_tty, struct target_ops *target)
d1650 1
a1650 1
	solib_symbols_add (solib_end->name, from_tty, solib_end->load_addr);
@


1.27.4.3
log
@* win32-nat.c (safe_symbol_file_add_stub): Properly initialize linked list
pointer to beginning rather than one beyond beginning.
@
text
@d453 1
a453 1
  struct so_stuff *so = &solib_start;
@


1.27.4.4
log
@* win32-nat.c (safe_symbol_file_add_stub): Improve logic for avoiding load of
already loaded DLL.
(register_loaded_dll): Convert loaded DLL name to "posix" format or it will
confuse subsequent opening of the filename due to dos paths.
(dll_symbol_command): Pass from_tty parameter to safe_symbol_file_add.
@
text
@d443 3
a445 3
  int loaded;
  char name[1];
} solib_start, *solib_end;
d456 1
a456 1
    if (so->loaded && strcasecmp (so->name, p->name) == 0)
d512 1
a512 4
  char ppath[MAX_PATH + 1];
  cygwin_conv_to_posix_path (name, ppath);
  so = (struct so_stuff *) xmalloc (sizeof (struct so_stuff) + strlen (ppath) + 8 + 1);
  so->loaded = 0;
d514 1
a514 1
  strcpy (so->name, ppath);
d653 1
a653 1
  safe_symbol_file_add (name, from_tty, NULL, 0, OBJF_SHARED);
d660 1
a660 1
dll_symbol_command (char *args, int from_tty)
d677 1
a677 1
  safe_symbol_file_add (args, from_tty, NULL, 0, OBJF_SHARED | OBJF_USERLOADED);
@


1.27.4.5
log
@* win32-nat.c (handle_load_dll): Avoid strlwr'ing loaded DLLs or cygwin may not
be able to read them in certain situations.
@
text
@d603 2
@


1.26
log
@2001-03-17  Michael Chastain  <chastain@@redhat.com>

	* win32-nat.c (child_attach): check args for NULL before passing
	to strtoul.  This fixes PR gdb/43.
@
text
@d82 1
a82 1
static int win32_child_thread_alive (int);
d236 1
a236 1
  add_thread (id);
d265 2
a266 2
    printf_unfiltered ("[Deleting %s]\n", target_pid_to_str (id));
  delete_thread (id);
d316 1
a316 1
  current_thread = thread_rec (inferior_pid, TRUE);
d336 1
a336 1
  current_thread = thread_rec (inferior_pid, TRUE);
d852 2
a853 1
			   target_pid_to_str (current_event.dwThreadId));
d946 1
a946 1
      inferior_pid = retval;
d954 2
a955 2
static int
child_wait (int pid, struct target_waitstatus *ourstatus)
d957 2
d969 1
a969 1
	return retval;
d1038 1
a1038 1
			   target_pid_to_str (pid));
d1041 1
a1041 1
			   target_pid_to_str (pid));
d1059 1
a1059 1
			 target_pid_to_str (inferior_pid));
d1062 1
a1062 1
  inferior_pid = 0;
d1072 1
a1072 1
      attach_flag ? "attached" : "child", target_pid_to_str (inferior_pid));
d1082 1
a1082 1
/* Start an inferior win32 child process and sets inferior_pid to its pid.
d1282 1
a1282 1
child_resume (int pid, int step, enum target_signal sig)
d1287 1
d1333 2
a1334 1
  DEBUG_EVENTS (("gdb: child_close, inferior_pid=%d\n", inferior_pid));
d1445 1
a1445 1
win32_child_thread_alive (int pid)
d1447 2
d1455 1
a1455 1
cygwin_pid_to_str (int pid)
d1458 2
@


1.25
log
@Update/correct copyright notices.
@
text
@d1018 1
a1018 1
  DWORD pid = strtoul (args, 0, 0);
d1023 1
@


1.24
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001 Free Software
   Foundation, Inc.
@


1.23
log
@	* demangle.c (demangling_style_names): New variable.
	(_initialize_demangler): Fill demangling_style_names with the
	names of known demangling styles from libiberty_demanglers[].  Use
	add_set_enum_cmd instead of add_set_cmd, to get completion on
	demangling style names.

	* proc-api.c (_initialize_proc_api): Make `procfs-file' use
	file-name completion.

	* remote-rdi.c (_initialize_remote_rdi): Ditto for `rdilogfile'.

	* solib.c (_initialize_solib): Ditto for `solib-search-path' and
	`solib-absolute-prefix'.

	* tracepoint.c (_initialize_tracepoint): Ditto for
	`save-tracepoints'.

	* win32-nat.c (_initialize_inftarg): Ditto for `dll-symbols'.

	* cli/cli-cmds.c (init_cli_cmds): Make `shell' and `make' use
	file-name completion.

	* infcmd.c (_initialize_infcmd): Make the following commands use
	the file-name completer: `tty', `args', `path', `paths', and
	`run'.
@
text
@d2 2
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d21 1
a21 2
   Boston, MA 02111-1307, USA.
 */
d34 1
@


1.22
log
@Fix spacing.
@
text
@d33 1
d1381 2
d1385 3
a1387 2
  add_com ("dll-symbols", class_files, dll_symbol_command,
	   "Load dll library symbols from FILE.");
@


1.21
log
@* win32-nat.c: Change PTR to void * throughout.
@
text
@d1231 1
a1231 1
		   int write,  struct mem_attrib *mem ATTRIBUTE_UNUSED,
@


1.20
log
@* win32-nat.c (child_xfer_memory): Add missing argument required by 2001-01-23
change.
@
text
@d517 1
a517 1
handle_load_dll (PTR dummy ATTRIBUTE_UNUSED)
d1231 1
a1231 1
		   int write, struct mem_attrib *mem ATTRIBUTE_UNUSED,
d1492 1
a1492 1
map_single_dll_code_section (bfd * abfd, asection * sect, PTR obj)
d1557 1
a1557 1
      bfd_map_over_sections (dll_bfd, &map_single_dll_code_section, (PTR) (&map_args));
d1564 1
a1564 1
core_section_load_dll_symbols (bfd * abfd, asection * sect, PTR obj)
@


1.19
log
@* win32-nat.c (_initialize_core_win32): Prototype correctly.
@
text
@d1231 2
a1232 1
		   int write, struct target_ops *target ATTRIBUTE_UNUSED)
@


1.18
log
@Replace free() with xfree().
@
text
@d1660 1
a1660 1
_initialize_core_win32 ()
@


1.17
log
@* win32-nat.c (dll_code_sections_add): strdup -> xstrdup.
@
text
@d252 1
a252 1
      free (here);
d276 1
a276 1
      free (here);
d622 1
a622 1
      free (so);
d718 1
a718 1
  free (s);
d1613 1
a1613 1
    free (buf);
d1615 1
a1615 1
    free (dll_name);
@


1.16
log
@Protoization.
@
text
@d1543 1
a1543 1
  name = strdup (dll_name);
@


1.15
log
@* win32-nat.c (dll_symbol_command): Tack a .dll on the end of a supplied
argument if it is missing an extension.

* corelow.c: Define O_BINARY if it isn't defined.
(core_open): Open core file in binary mode.
* config/i386/tm-cygwin.h (child_clear_solibs): Rename from child_clear_solib.
* config/i386/cygwin.mh: Add dependency from corelow.o.
* win32-nat.c (register_loaded_dll): New function.  Add dll to the list of
currently loaded dlls.
(handle_load_dll): Use register_loaded_dll.
(child_solib_add): Distinguish between active process and core targets.
(solib_symbols_add): Load symbols from loaded dll.
(core_dll_symbols_add): New function.  Load symbols from dll referenced in
core.
(core_section_load_dll_symbols): New function.
(dll_code_sections_add): New function.
(map_single_dll_code_section): New function.
(fetch_elf_core_registers): New function.
(_initialize_core_win32): New function.
@
text
@a465 1

@


1.14
log
@* win32-nat.c: Perform various gcc warning cleanups.
(safe_symbol_file_add_cleanup): Reset stdout to saved stdout, not stderr.
(dll_symbol_command): Pass OBJF_USERLOADED to safe_symbol_file_add.
(get_child_debug_event): Always reset last_sig.  Always reset inferior pid
appropriately.
(do_initial_child_stuff): New function.  Called when attaching or starting a
new inferior process.
(child_attach): Use do_initial_child_stuff.
(child_create_inferior): Ditto.
* config/i386/cygwin.mh (NAT_FILE): Set to modern location.
* config/i386/tm-cygwin.h: Define ATTACH_NO_WAIT.
@
text
@d58 4
a61 4
{
  FLAG_TRACE_BIT = 0x100,
  CONTEXT_DEBUGGER = (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
};
d63 2
d96 2
a97 1
  } thread_info;
d294 1
a294 1
      l = *((long *)context_offset) & 0xffff;
d299 1
a299 1
      l = (*((long *)context_offset) >> 16) & ((1 << 11) - 1);
a337 1
#include <psapi.h>
d340 3
a342 3
static BOOL  WINAPI (*psapi_EnumProcessModules)(HANDLE, HMODULE*, DWORD, LPDWORD)= NULL;
static BOOL  WINAPI (*psapi_GetModuleInformation) (HANDLE, HMODULE, LPMODULEINFO, DWORD)= NULL;
static DWORD WINAPI (*psapi_GetModuleFileNameExA) (HANDLE, HMODULE, LPSTR, DWORD)= NULL;
d344 2
a345 1
int psapi_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
d350 2
a351 2
  HMODULE dh_buf [ 1 ];
  HMODULE* DllHandle = dh_buf;
d356 3
a358 3
       psapi_EnumProcessModules   == NULL ||
       psapi_GetModuleInformation == NULL ||
       psapi_GetModuleFileNameExA == NULL)
d360 2
a361 1
      if (psapi_loaded)goto failed;
d365 5
a369 5
        {
          /* printf_unfiltered ("error loading psapi.dll: %u", GetLastError ());*/
          goto failed;
        }
      psapi_EnumProcessModules   = GetProcAddress (psapi_module_handle, "EnumProcessModules" );
d372 4
a375 4
							    "GetModuleFileNameExA");
      if (psapi_EnumProcessModules   == NULL ||
           psapi_GetModuleInformation == NULL ||
           psapi_GetModuleFileNameExA == NULL)
d381 3
a383 3
				     DllHandle,
				     sizeof (HMODULE),
				     &cbNeeded);
d388 1
a388 1
  DllHandle = (HMODULE*) alloca (cbNeeded);
d393 3
a395 3
				     DllHandle,
				     cbNeeded,
				     &cbNeeded);
d402 3
a404 3
					     DllHandle [i],
					     &mi,
					     sizeof (mi)))
d408 3
a410 3
					    DllHandle [i],
					    dll_name_ret,
					    MAX_PATH);
d451 1
a451 1
# define sp ((struct safe_symbol_file_add_args *)p)
d458 1
a458 1
# undef sp
d496 2
a497 1
} solib_start, *solib_end;
d502 13
a523 1
  struct so_stuff *so;
d531 1
a531 1
    dll_buf[0] = dll_buf[sizeof(dll_buf) - 1] = '\0';
d599 1
a599 8
  so = (struct so_stuff *) xmalloc (sizeof (struct so_stuff) +  strlen (dll_name) + 8 + 2);
  so->load_addr = (DWORD) event->lpBaseOfDll + 0x1000;
  strcpy (so->name, dll_name);

  solib_end->next = so;
  solib_end = so;
  so->next = NULL;

d611 1
a611 1
  return !solib_end || !solib_end->name[0]? NULL : solib_end->name;
d633 1
a633 1
child_solib_add (char *filename ATTRIBUTE_UNUSED, int from_tty ATTRIBUTE_UNUSED, struct target_ops *t ATTRIBUTE_UNUSED)
d641 1
a641 1
  if (!solib_end || !solib_end->name[0])
d646 2
a647 2
  section_addrs.other[0].addr = solib_end->load_addr;
  safe_symbol_file_add (solib_end->name, 0, &section_addrs, 0, OBJF_SHARED);
d656 1
d658 1
a658 1
  
d662 9
d672 1
a672 1
} 
d738 1
a738 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d747 1
a747 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d753 1
a753 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d758 1
a758 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d763 1
a763 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d769 1
a769 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d774 1
a774 1
	       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d781 1
a781 1
		(DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress);
d926 1
a926 1
      if (handle_output_debug_string ( ourstatus))
d943 1
a943 1
      current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
d1207 1
a1207 1
  /* child_continue (DBG_CONTINUE, -1);*/
d1280 1
a1280 1
			  DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;
d1383 1
a1383 1
           "Load dll library symbols from FILE.");
d1385 1
d1389 4
a1392 4
		  (char *) &new_console,
		  "Set creation of new console when creating child process.",
		  &setlist),
     &showlist);
d1395 4
a1398 4
		  (char *) &new_group,
		  "Set creation of new group when creating child process.",
		  &setlist),
     &showlist);
d1401 4
a1404 4
		  (char *) &debug_exec,
		  "Set whether to display execution in child process.",
		  &setlist),
     &showlist);
d1407 4
a1410 4
		  (char *) &debug_events,
		  "Set whether to display kernel events in child process.",
		  &setlist),
     &showlist);
d1413 4
a1416 4
		  (char *) &debug_memory,
		  "Set whether to display memory accesses in child process.",
		  &setlist),
     &showlist);
d1419 4
a1422 4
		  (char *) &debug_exceptions,
		  "Set whether to display kernel exceptions in child process.",
		  &setlist),
     &showlist);
d1450 214
@


1.13
log
@Protoization.
@
text
@d57 5
a61 2
#define FLAG_TRACE_BIT 0x100
#define CONTEXT_DEBUGGER (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
d447 1
a447 1
#define sp ((struct safe_symbol_file_add_args *)p)
d453 2
a454 1
  gdb_stdout = sp->err;
d506 1
a506 1
  struct so_stuff *so, *solast;
a507 1
  DWORD dll_base = 0;
d599 1
a599 1
child_solib_loaded_library_pathname (int pid)
d623 1
a623 1
child_solib_add (char *filename, int from_tty, struct target_ops *t)
d644 1
a644 1
dll_symbol_command (char *args, int from_tty)
a645 2
  struct section_addr_info section_addrs;

d651 1
a651 1
  safe_symbol_file_add (args, 0, NULL, 0, OBJF_SHARED);
d656 1
a656 1
info_dll_command (char *ignore, int from_tty)
a713 2
  last_sig = 0;

a801 1
  int breakout = 0;
d808 2
d851 1
a851 1
      main_thread_id = inferior_pid = current_event.dwThreadId;
d853 1
d856 2
a857 1
      th = child_add_thread (inferior_pid,
d859 1
a859 1
      retval = ourstatus->value.related_pid = current_event.dwProcessId;
d870 1
a870 1
      retval = current_event.dwProcessId;
d882 1
a882 1
      retval = current_event.dwProcessId;
d907 1
a907 1
	retval = current_event.dwProcessId;
d909 1
d922 4
a925 1
    current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
d959 32
d997 1
d1002 1
a1002 3
  current_event.dwProcessId = strtoul (args, 0, 0);

  ok = DebugActiveProcess (current_event.dwProcessId);
a1006 6
  exception_count = 0;
  event_count = 0;

  child_init_thread_list ();
  child_clear_solibs ();

d1013 1
a1013 1
			   target_pid_to_str (current_event.dwProcessId));
d1016 1
a1016 1
			   target_pid_to_str (current_event.dwProcessId));
d1021 2
a1022 1
  push_target (&child_ops);
a1071 1
  struct target_waitstatus dummy;
a1074 1
  extern int stop_after_trap;
d1185 1
a1185 26
  exception_count = 0;
  event_count = 0;

  current_process_handle = pi.hProcess;
  current_event.dwProcessId = pi.dwProcessId;
  memset (&current_event, 0, sizeof (current_event));
  inferior_pid = current_event.dwThreadId = pi.dwThreadId;
  push_target (&child_ops);
  child_init_thread_list ();
  child_clear_solibs ();
  clear_proceed_status ();
  init_wait_for_inferior ();
  target_terminal_init ();
  target_terminal_inferior ();
  last_sig = 0;

  while (1)
    {
      stop_after_trap = 1;
      wait_for_inferior ();
      if (stop_signal != TARGET_SIGNAL_TRAP)
	resume (0, stop_signal);
      else
	break;
    }
  stop_after_trap = 0;
d1304 1
a1304 1
child_close (void)
@


1.12
log
@* win32-nat.c (safe_symbol_file_add_args): Store old gdb_stderr and gdb_stdout
here.
(safe_symbol_file_add_stub): Redirect gdb_stdout as well as stderr.
(safe_symbol_file_add_cleanup): Restore gdb_stdout.
(info_dll_command): Use the pager for displaying DLLs since there are often
quite a few.
@
text
@d235 1
a235 1
child_init_thread_list ()
d956 1
a956 3
child_attach (args, from_tty)
     char *args;
     int from_tty;
d1031 1
a1031 4
child_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
d1187 1
a1187 1
child_mourn_inferior ()
d1198 1
a1198 1
child_stop ()
d1287 1
a1287 1
child_prepare_to_store ()
d1293 1
a1293 1
child_can_run ()
d1299 1
a1299 1
child_close ()
d1353 1
a1353 1
_initialize_inftarg ()
@


1.11
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d425 1
d442 1
a442 1
safe_symbol_file_add_cleanup (void *gdb_stderrv)
d444 1
d446 1
d448 3
a450 1
  gdb_stderr = (struct ui_file *)gdb_stderrv;
d463 1
a463 1
  cleanup = make_cleanup (safe_symbol_file_add_cleanup, gdb_stderr);
d465 2
d468 1
d470 1
d664 1
a664 1
    printf_unfiltered ("%*s  %08lx\n", -max_dll_name_len, so->name, so->load_addr);
@


1.10
log
@* win32-nat.c (safe_symbol_file_add_cleanup): Ensure that gdb_stderr is flushed
before deleting and restoring it.
(safe_symbol_file_add): Ensure that gdb_stderr is flushed before reassigning
it.
(handle_load_dll): Split into two functions so that WFI can handle shared
library events.
(child_solib_loaded_library_pathname): New function.
(child_clear_solibs): New function.  Clears shared library list.
(child_solib_add): New function.  Adds shared library symbols.
(dll_symbol_command): New function.  Handles "dll-symbol" command.
(info_dll_command): New function.  Handles info "sharedlibrary" command.
(handle_exceptions): Eliminate 'ignore_trap' argument.
(get_child_debug_event): Eliminate two arguments.  Return "pid" when
appropriate.  Break out on most events to allow WFI to handle stuff.
(child_wait): Accomodate get_child_debug_event changes.
(child_attach): Clear thread list and list of loaded dlls.
(child_create_inferior): Clear list of loaded dlls.  Use wait_for_inferior in a
loop to look for first "trap".
(child_resume): Avoid accessing a possibly-freed thread pointer.
(_initialize_inftarg): Add "dll-symbols", "sharedlibrary", and "info
dll", and "info sharedlibrary" commands.
* config/i386/tm-cygwin.h: Add some shared library (aka DLL) hooks.
@
text
@d51 1
a51 1
extern int (*ui_loop_hook) PARAMS ((int signo));
@


1.9
log
@* win32-nat.c: Fix up gcc warnings throughout.
(handle_load_dll): Change DLL name to lower case.
(handle_exception): Add a second argument indicating whether a breakpoint
should be ignored.  Return a 0 if the breakpoint was ignored.
(get_child_debug_event): Pass argument to handle_exception to control whether a
breakpoint should be ignored.
(child_create_inferior): Use modern cygwin API.  Explicitly clear last_sig.
Pass FIRST_EXCEPTION to get_child_debug_event for detection of first
breakpoint.

* configure.in: Eliminate unneeded WINDRES/DLLTOOL tests left over after last change.
* configure: Regenerate.
@
text
@a60 2
#define FIRST_EXCEPTION 0xffffffff

d416 2
d428 2
d439 1
d443 1
d448 1
d460 1
d473 11
a485 1

d493 5
a497 2
  char *p, *dll_name = NULL;
  struct section_addr_info section_addrs;
a498 1
  memset (&section_addrs, 0, sizeof (section_addrs));
d570 45
d619 4
d624 32
a655 3
  section_addrs.other[0].addr = (int) event->lpBaseOfDll + 0x1000;
  safe_symbol_file_add (dll_name, 0, &section_addrs, 0, OBJF_SHARED);
  printf_unfiltered ("%lx:%s\n", (DWORD) event->lpBaseOfDll, dll_name);
d657 1
a657 1
  return 1;
d694 1
a694 1
handle_exception (struct target_waitstatus *ourstatus, int ignore_trap)
a698 3
  if (ignore_trap && code == EXCEPTION_BREAKPOINT)
    return 0;

d792 1
a792 2
get_child_debug_event (int pid ATTRIBUTE_UNUSED, struct target_waitstatus *ourstatus,
		       DWORD target_event_code, int *retval)
d799 1
a800 1
  *retval = 0;
d808 1
a808 1
  breakout = event_code == target_event_code;
d823 1
d844 2
d848 1
d859 1
a859 2
      *retval = current_event.dwProcessId;
      breakout = 1;
d869 3
d886 2
a887 4
      if (handle_exception (ourstatus, target_event_code == FIRST_EXCEPTION))
	*retval = current_event.dwThreadId;
      else
	breakout = -1;
d895 2
a896 1
      handle_output_debug_string ( ourstatus);
d907 3
a909 1
  if (breakout > 0)
a910 2
  else if (!breakout)
    CHECK (child_continue (continue_status, -1));
d913 1
a913 1
  return breakout;
a919 2
  int retval;

d927 7
a933 5
    if (get_child_debug_event (pid, ourstatus, EXCEPTION_DEBUG_EVENT, &retval))
      return retval;
    else
      {
	int detach = 0;
d935 2
a936 2
	if (ui_loop_hook != NULL)
	  detach = ui_loop_hook (0);
d938 4
a941 3
	if (detach)
	  child_kill_inferior ();
      }
d966 3
d1040 1
d1043 1
a1043 3
    {
      error ("No executable specified, use `target exec'.\n");
    }
d1160 2
a1162 1
  clear_proceed_status ();
d1167 10
a1176 4
  /* Run until process and threads are loaded */
  while (!get_child_debug_event (inferior_pid, &dummy,
				 FIRST_EXCEPTION, &ret))
    continue;
d1260 1
a1260 1
  if (step)
d1262 6
a1267 6
#ifdef i386
      /* Single step by setting t bit */
      child_fetch_inferior_registers (PS_REGNUM);
      th->context.EFlags |= FLAG_TRACE_BIT;
#endif
    }
d1269 5
a1273 4
  if (th->context.ContextFlags)
    {
      CHECK (SetThreadContext (th->h, &th->context));
      th->context.ContextFlags = 0;
d1353 6
a1358 2
  add_show_from_set
    (add_set_cmd ("new-console", class_support, var_boolean,
d1364 1
a1364 2
  add_show_from_set
    (add_set_cmd ("new-group", class_support, var_boolean,
d1370 1
a1370 2
  add_show_from_set
    (add_set_cmd ("debugexec", class_support, var_boolean,
d1376 1
a1376 2
  add_show_from_set
    (add_set_cmd ("debugevents", class_support, var_boolean,
d1382 1
a1382 2
  add_show_from_set
    (add_set_cmd ("debugmemory", class_support, var_boolean,
d1388 1
a1388 2
  add_show_from_set
    (add_set_cmd ("debugexceptions", class_support, var_boolean,
d1390 1
a1390 1
	       "Set whether to display kernel exceptions in child process.",
d1393 3
@


1.8
log
@PARAMS removal.
@
text
@a36 4

#ifdef _MSC_VER
#include "windefs.h"
#else /* other WIN32 compiler */
d39 1
a39 1
#endif
d61 2
d67 1
a67 1
#define CHECK(x) 	check (x, __FILE__,__LINE__)
a81 1

d95 1
a95 1
static thread_info thread_head = {NULL};
a103 2
static int ignore_first_first_chance = 0; /* True if we should ignore the
					     first first chance exception that we get. */
d280 1
a280 1
    printf_filtered ("error return %s:%d was %d\n", file, line, GetLastError ());
d394 1
a394 1
  for (i = 0; i < cbNeeded / sizeof (HMODULE); i++)
d407 1
a407 1
	error ("Error getting dll name: %u\n", GetLastError ()); 
d471 1
a471 1
handle_load_dll (PTR dummy)
a477 2
  struct objfile *objfile;
  MEMORY_BASIC_INFORMATION minfo;
d493 1
a493 1
      int size = event->fUnicode ? sizeof (WCHAR) : sizeof (char);
d547 2
d559 1
a559 1
  printf_unfiltered ("%x:%s\n", event->lpBaseOfDll, dll_name);
d581 1
a581 1
	warning (s);
d598 1
a598 1
handle_exception (struct target_waitstatus *ourstatus)
a599 2
  int i;
  int done = 0;
d601 4
a604 1
  int fc = ignore_first_first_chance;
a607 2
  ignore_first_first_chance = 0;

d613 1
a613 1
  switch (current_event.u.Exception.ExceptionRecord.ExceptionCode)
d616 2
a617 2
      DEBUG_EXCEPT (("gdb: Target exception ACCESS_VIOLATION at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d625 2
a626 2
      DEBUG_EXCEPT (("gdb: Target exception STACK_OVERFLOW at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d628 1
d631 2
a632 2
      DEBUG_EXCEPT (("gdb: Target exception STACK_OVERFLOW at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d636 2
a637 8
      if (fc && current_event.u.Exception.dwFirstChance &&
	  ((DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress & 0xc0000000))
	{
	  last_sig = -1;
	  return 0;
	}
      DEBUG_EXCEPT (("gdb: Target exception BREAKPOINT at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d641 2
a642 2
      DEBUG_EXCEPT (("gdb: Target exception CONTROL_C at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d647 2
a648 2
      DEBUG_EXCEPT (("gdb: Target exception SINGLE_STEP at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d652 2
a653 2
      DEBUG_EXCEPT (("gdb: Target exception SINGLE_ILL at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d658 1
a658 1
      printf_unfiltered ("gdb: unknown target exception 0x%08x at 0x%08x\n",
d660 1
a660 1
		current_event.u.Exception.ExceptionRecord.ExceptionAddress);
d677 1
a677 1
  DEBUG_EVENTS (("ContinueDebugEvent (cpid=%d, ctid=%d, DBG_CONTINUE);\n",
d685 1
a685 1
      if (((id == -1) || (id == th->id)) && th->suspend_count)
d699 1
a699 1
get_child_debug_event (int pid, struct target_waitstatus *ourstatus,
d708 1
d710 1
a710 4
    {
      *retval = 0;
      goto out;
    }
a713 1
  *retval = 0;
d788 1
a788 1
      if (handle_exception (ourstatus))
d791 1
a791 5
	{
	  if (last_sig >= 0)
	    continue_status = DBG_EXCEPTION_NOT_HANDLED;
	  breakout = 0;
	}
d802 4
a805 4
      printf_unfiltered ("gdb: kernel event for pid=%d tid=%d\n",
			 current_event.dwProcessId,
			 current_event.dwThreadId);
      printf_unfiltered ("                 unknown event code %d\n",
d810 1
a810 1
  if (breakout)
d812 1
a812 1
  else
a822 1
  DWORD event_code;
d886 1
a886 3
child_detach (args, from_tty)
     char *args;
     int from_tty;
d904 1
a904 2
child_files_info (ignore)
     struct target_ops *ignore;
d912 1
a912 3
child_open (arg, from_tty)
     char *arg;
     int from_tty;
a938 1
  DWORD event_code;
d948 1
a948 1
  cygwin32_conv_to_win32_path (exec_file, real_path);
d994 1
a994 1
		if (cygwin32_posix_path_list_p (env[i] + len))
d996 1
a996 1
		    + cygwin32_posix_to_win32_path_list_buf_size (env[i] + len);
d1018 1
a1018 1
		if (cygwin32_posix_path_list_p (env[i] + len))
d1021 1
a1021 1
		    cygwin32_posix_to_win32_path_list (env[i] + len, temp + len);
d1064 1
a1064 2

  ignore_first_first_chance = 1;
d1068 1
a1068 1
				 CREATE_PROCESS_DEBUG_EVENT, &ret))
d1096 1
a1096 1
		   int write, struct target_ops *target)
d1101 2
a1102 2
      DEBUG_MEM (("gdb: write target memory, %d bytes at 0x%08x\n",
		  len, memaddr));
d1109 2
a1110 2
      DEBUG_MEM (("gdb: read target memory, %d bytes at 0x%08x\n",
		  len, memaddr));
d1305 1
a1305 1
  if (pid == current_event.dwProcessId)
d1308 1
a1308 1
    sprintf (buf, "thread %d.0x%x", current_event.dwProcessId, pid);
@


1.7
log
@2000-04-21  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* win32-nat.c  (handle_load_dll): Don't treat .text as a special
 	section anymore.
	* somread.c (som_symfile_offsets): Ditto.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
@
text
@d78 3
a80 3
static void child_stop PARAMS ((void));
static int win32_child_thread_alive PARAMS ((int));
void child_kill_inferior PARAMS ((void));
@


1.6
log
@* win32-nat.c (thread_rec): Be more defensive about suspending already
suspended threads.
(safe_symbol_file_add_stub): New function.
(safe_symbole_file_add_cleanup): New function.
(safe_symbol_file_add): New function.
(handle_load_dll): Use wrapper to add DLL symbol information to avoid bogus
errors from non-stabs DLLs.
(handle_exception): Add work around for detection of first exception breakpoint
which does not seem to occur on W2K.  Detect more "signals" that can be
effectively passed to the debuggee.  Reorganize to eliminate continue_status
global.
(child_continue): Reorganize to eliminate continue_status global.
(child_wait): Ditto.
(child_resume): Ditto.
(get_child_debug_event): Ditto.  Recognize when an a breakpoint exception
should be ignored.  Change method for signalling when an important event has
occured to the caller.
(child_create_inferior): Use new method for noticing when get_child_debug_event
has found something interesting.
@
text
@d561 2
a562 1
  section_addrs.text_addr = (int) event->lpBaseOfDll + 0x1000;
@


1.5
log
@* win32-nat.c: Back out special frame walking code.  It was broken.
(handle_exception): Correctly identify an illegal instruction.
* config/tm-cygwin.h: Eliminate special frame handling.  Just use normal i386
handling.
@
text
@d82 3
a99 3
/* The saved state for a continue after breaking back to gdb. */
static DWORD continue_status;

d107 2
d206 1
a206 1
	    if (get_context > 0)
d423 49
d559 1
a559 3
     of the file header and the section alignment.

     FIXME: Is this the real reason that we need the 0x1000 ? */
a560 1
  printf_unfiltered ("%x:%s", event->lpBaseOfDll, dll_name);
d562 2
a563 2
  symbol_file_add (dll_name, 0, &section_addrs, 0, OBJF_SHARED);
  printf_unfiltered ("\n");
d607 1
d611 2
d616 2
d624 1
a624 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
a632 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
a637 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
d640 6
d654 1
a654 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
d665 1
a667 8
      /* This may be a structured exception handling exception.  In
         that case, we want to let the program try to handle it, and
         only break if we see the exception a second time.
      if (current_event.u.Exception.dwFirstChance)

	return 0;
*/

a671 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
d681 1
a681 1
child_continue (int id)
d705 3
d710 1
a710 1
		       DWORD *event_code, int *retval)
d712 1
d714 3
a716 1
  int breakout = 1;
d718 1
a718 1
  if (!(debug_event = WaitForDebugEvent (&current_event, 20)))
d720 1
a720 1
      breakout = *retval = *event_code = 0;
d728 4
a731 1
  switch (*event_code = current_event.dwDebugEventCode)
d735 3
a737 3
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "CREATE_THREAD_DEBUG_EVENT"));
d739 2
a740 2
      child_add_thread (current_event.dwThreadId,
			current_event.u.CreateThread.hThread);
d743 1
a743 1
		      target_pid_to_str (current_event.dwThreadId));
d748 3
a750 3
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "EXIT_THREAD_DEBUG_EVENT"));
d752 1
d757 3
a759 3
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "CREATE_PROCESS_DEBUG_EVENT"));
d764 2
a765 2
      current_thread = child_add_thread (inferior_pid,
			 current_event.u.CreateProcessInfo.hThread);
d770 3
a772 3
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "EXIT_PROCESS_DEBUG_EVENT"));
d777 2
a778 1
      goto out;
d782 4
a785 4
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "LOAD_DLL_DEBUG_EVENT"));
      catch_errors (handle_load_dll, NULL, "", RETURN_MASK_ALL);
d791 4
a794 4
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "UNLOAD_DLL_DEBUG_EVENT"));
      break;		/* FIXME: don't know what to do here */
d798 6
a803 4
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "EXCEPTION_DEBUG_EVENT"));
      if (handle_exception (ourstatus))	/* sets continue_status */
d805 3
a807 2
	  *retval = current_event.dwThreadId;
	  goto out;
d811 1
a811 1
    case OUTPUT_DEBUG_STRING_EVENT:
d813 4
a816 8
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "OUTPUT_DEBUG_STRING_EVENT"));
      if (handle_output_debug_string (ourstatus))
	{
	  *retval = main_thread_id;
	  goto out;
	}
d827 4
a830 3
  breakout = 0;
  CHECK (child_continue (-1));
  continue_status = 0;
a835 1

d850 5
a854 8
    {
      if (continue_status != 0)
	CHECK (child_continue (-1));
      if (get_child_debug_event (pid, ourstatus, &event_code, &retval))
	return retval;
      else
	{
	  int detach = 0;
d856 2
a857 2
	  if (ui_loop_hook != NULL)
	    detach = ui_loop_hook (0);
d859 3
a861 4
	  if (detach)
	    child_kill_inferior ();
	}
    }
d1089 2
d1092 3
a1094 6
  do
    get_child_debug_event (inferior_pid, &dummy, &event_code, &ret);
  while (event_code != EXCEPTION_DEBUG_EVENT);

  SymSetOptions (SYMOPT_DEFERRED_LOADS);
  SymInitialize (current_process_handle, NULL, TRUE);
d1096 1
d1103 1
a1103 2
  continue_status = DBG_CONTINUE;
  (void) child_continue (-1);
d1149 1
a1149 2
      continue_status = DBG_CONTINUE;
      if (!child_continue (-1))
a1166 1
  int i;
d1168 4
d1196 1
a1196 1
  child_continue (pid);
a1267 1
  struct cmd_list_element *c;
@


1.5.2.1
log
@* win32-nat.c (thread_rec): Be more defensive about suspending already
suspended threads.
(safe_symbol_file_add_stub): New function.
(safe_symbole_file_add_cleanup): New function.
(safe_symbol_file_add): New function.
(handle_load_dll): Use wrapper to add DLL symbol information to avoid bogus
errors from non-stabs DLLs.
(handle_exception): Add work around for detection of first exception breakpoint
which does not seem to occur on W2K.  Detect more "signals" that can be
effectively passed to the debuggee.  Reorganize to eliminate continue_status
global.
(child_continue): Reorganize to eliminate continue_status global.
(child_wait): Ditto.
(child_resume): Ditto.
(get_child_debug_event): Ditto.  Recognize when an a breakpoint exception
should be ignored.  Change method for signalling when an important event has
occured to the caller.
(child_create_inferior): Use new method for noticing when get_child_debug_event
has found something interesting.
@
text
@a81 3
static int last_sig = 0;	/* Set if a signal was received from the
				   debugged process */

d97 3
a106 2
static int ignore_first_first_chance = 0; /* True if we should ignore the
					     first first chance exception that we get. */
d204 1
a204 1
	    if (get_context > 0 && id != current_event.dwThreadId)
a420 49
struct safe_symbol_file_add_args
{
  char *name;
  int from_tty;
  struct section_addr_info *addrs;
  int mainline;
  int flags;
  struct objfile *ret;
};

static int
safe_symbol_file_add_stub (void *argv)
{
#define p ((struct safe_symbol_file_add_args *)argv)
  p->ret = symbol_file_add (p->name, p->from_tty, p->addrs, p->mainline, p->flags);
  return !!p->ret;
#undef p
}

static void
safe_symbol_file_add_cleanup (void *gdb_stderrv)
{
  ui_file_delete (gdb_stderr);
  gdb_stderr = (struct ui_file *)gdb_stderrv;
}

static struct objfile *
safe_symbol_file_add (char *name, int from_tty,
		      struct section_addr_info *addrs,
		      int mainline, int flags)

{
  struct safe_symbol_file_add_args p;
  struct cleanup *cleanup;

  cleanup = make_cleanup (safe_symbol_file_add_cleanup, gdb_stderr);

  gdb_stderr = ui_file_new ();
  p.name = name;
  p.from_tty = from_tty;
  p.addrs = addrs;
  p.mainline = mainline;
  p.flags = flags;
  catch_errors (safe_symbol_file_add_stub, &p, "", RETURN_MASK_ERROR);

  do_cleanups (cleanup);
  return p.ret;
}

d508 3
a510 1
     of the file header and the section alignment. */
d512 1
d514 2
a515 2
  safe_symbol_file_add (dll_name, 0, &section_addrs, 0, OBJF_SHARED);
  printf_unfiltered ("%x:%s\n", event->lpBaseOfDll, dll_name);
a558 1
  int fc = ignore_first_first_chance;
a561 2
  ignore_first_first_chance = 0;

a564 2
  last_sig = 0;

d571 1
a571 1
      last_sig = SIGSEGV;
d580 1
d586 1
a588 6
      if (fc && current_event.u.Exception.dwFirstChance &&
	  ((DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress & 0xc0000000))
	{
	  last_sig = -1;
	  return 0;
	}
d597 1
a597 1
      last_sig = SIGINT;	/* FIXME - should check pass state */
a607 1
      last_sig = SIGILL;
d610 8
d622 1
d632 1
a632 1
child_continue (DWORD continue_status, int id)
a655 3
/* Get the next event from the child.  Return 1 if the event requires
   handling by WFI (or whatever).
 */
d658 1
a658 1
		       DWORD target_event_code, int *retval)
a659 1
  int breakout = 0;
d661 1
a661 3
  DWORD continue_status, event_code;
  thread_info *th = NULL;
  static thread_info dummy_thread_info;
d663 1
a663 1
  if (!(debug_event = WaitForDebugEvent (&current_event, 1000)))
d665 1
a665 1
      *retval = 0;
d673 1
a673 4
  event_code = current_event.dwDebugEventCode;
  breakout = event_code == target_event_code;

  switch (event_code)
d677 3
a679 3
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "CREATE_THREAD_DEBUG_EVENT"));
d681 2
a682 2
      th = child_add_thread (current_event.dwThreadId,
			     current_event.u.CreateThread.hThread);
d685 1
a685 1
			   target_pid_to_str (current_event.dwThreadId));
d690 3
a692 3
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXIT_THREAD_DEBUG_EVENT"));
a693 1
      th = &dummy_thread_info;
d698 3
a700 3
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "CREATE_PROCESS_DEBUG_EVENT"));
d705 2
a706 2
      th = child_add_thread (inferior_pid,
			     current_event.u.CreateProcessInfo.hThread);
d711 3
a713 3
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXIT_PROCESS_DEBUG_EVENT"));
d718 1
a718 2
      breakout = 1;
      break;
d722 4
a725 4
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "LOAD_DLL_DEBUG_EVENT"));
      catch_errors (handle_load_dll, NULL, (char *) "", RETURN_MASK_ALL);
d731 4
a734 4
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "UNLOAD_DLL_DEBUG_EVENT"));
      break;			/* FIXME: don't know what to do here */
d738 4
a741 6
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "EXCEPTION_DEBUG_EVENT"));
      if (handle_exception (ourstatus))
	*retval = current_event.dwThreadId;
      else
d743 2
a744 3
	  if (last_sig >= 0)
	    continue_status = DBG_EXCEPTION_NOT_HANDLED;
	  breakout = 0;
d748 1
a748 1
    case OUTPUT_DEBUG_STRING_EVENT:	/* message from the kernel */
d750 8
a757 4
		     (unsigned) current_event.dwProcessId,
		     (unsigned) current_event.dwThreadId,
		     "OUTPUT_DEBUG_STRING_EVENT"));
      handle_output_debug_string ( ourstatus);
d768 3
a770 4
  if (breakout)
    current_thread = th ?: thread_rec (current_event.dwThreadId, TRUE);
  else
    CHECK (child_continue (continue_status, -1));
d776 1
d791 8
a798 5
    if (get_child_debug_event (pid, ourstatus, EXCEPTION_DEBUG_EVENT, &retval))
      return retval;
    else
      {
	int detach = 0;
d800 2
a801 2
	if (ui_loop_hook != NULL)
	  detach = ui_loop_hook (0);
d803 4
a806 3
	if (detach)
	  child_kill_inferior ();
      }
d1034 4
a1037 1
  ignore_first_first_chance = 1;
d1039 2
a1040 4
  /* Run until process and threads are loaded */
  while (!get_child_debug_event (inferior_pid, &dummy,
				 CREATE_PROCESS_DEBUG_EVENT, &ret))
    continue;
a1041 1
  /* child_continue (DBG_CONTINUE, -1);*/
d1048 2
a1049 1
  (void) child_continue (DBG_CONTINUE, -1);
d1095 2
a1096 1
      if (!child_continue (DBG_CONTINUE, -1))
d1114 1
a1115 4
  DWORD continue_status = last_sig > 0 && last_sig < NSIG ?
			  DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;

  last_sig = 0;
d1140 1
a1140 1
  child_continue (continue_status, pid);
d1212 1
@


1.4
log
@* win32-nat.c: Remove unneeded header.
* wince.c: Ditto.
@
text
@d604 5
a1279 57
}

static LPVOID __stdcall
sfta(HANDLE h, DWORD d)
{
  return NULL;
}

static DWORD __stdcall
sgmb(HANDLE h, DWORD d)
{
#if 0
  return 4;
#else
  return SymGetModuleBase (h, d) ?: 4;
#endif
}

CORE_ADDR
child_frame_chain(struct frame_info *f)
{
  STACKFRAME *sf = (STACKFRAME *) f->extra_info;
  if (!StackWalk (IMAGE_FILE_MACHINE_I386, current_process_handle,
		  current_thread->h, sf, NULL, NULL, SymFunctionTableAccess, sgmb, NULL) ||
      !sf->AddrReturn.Offset)
    return 0;
  return sf->AddrFrame.Offset;
}

CORE_ADDR
child_frame_saved_pc(struct frame_info *f)
{
  STACKFRAME *sf = (STACKFRAME *) f->extra_info;
  return sf->AddrReturn.Offset;
}

void
child_init_frame(int leaf, struct frame_info *f)
{
  STACKFRAME *sf;

  if (f->next && f->next->extra_info)
    f->extra_info = f->next->extra_info;
  else if (f->prev && f->prev->extra_info)
    f->extra_info = f->prev->extra_info;
  else
    {
      sf = (STACKFRAME *) frame_obstack_alloc (sizeof (*sf));
      f->extra_info = (struct frame_extra_info *) sf;
      memset (sf, 0, sizeof(*sf));
      sf->AddrPC.Offset = f->pc;
      sf->AddrPC.Mode = AddrModeFlat;
      sf->AddrStack.Offset = current_thread->context.Esp;
      sf->AddrStack.Mode = AddrModeFlat;
      sf->AddrFrame.Offset = f->frame;
      sf->AddrFrame.Mode = AddrModeFlat;
    }
@


1.3
log
@Correct copyright.
@
text
@a30 1
#include "gdb_wait.h"
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
   Contributed by Cygnus Support.
@


1.1
log
@Initial revision
@
text
@d19 3
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*/
d31 1
a31 1
#include "wait.h"
d43 1
d55 11
d81 1
a81 3

static int last_sig = 0;	/* Set if a signal was received from the
				   debugged process */
d86 9
a94 8
{
  struct thread_info_struct *next;
  DWORD id;
  HANDLE h;
  char *name;
  int suspend_count;
  CONTEXT context;
} thread_info;
d98 3
d107 1
a107 1
static DWORD main_thread_id;		/* Thread ID of the main thread */
d115 4
a118 4
static int new_group = 0;
static int debug_exec = 0;		/* show execution */
static int debug_events = 0;		/* show events from kernel */
static int debug_memory = 0;		/* show target memory accesses */
d137 32
a168 24
  context_offset(Eax),
  context_offset(Ecx),
  context_offset(Edx),
  context_offset(Ebx),
  context_offset(Esp),
  context_offset(Ebp),
  context_offset(Esi),
  context_offset(Edi),
  context_offset(Eip),
  context_offset(EFlags),
  context_offset(SegCs),
  context_offset(SegSs),
  context_offset(SegDs),
  context_offset(SegEs),
  context_offset(SegFs),
  context_offset(SegGs),
  context_offset(FloatSave.RegisterArea[0 * 10]),
  context_offset(FloatSave.RegisterArea[1 * 10]),
  context_offset(FloatSave.RegisterArea[2 * 10]),
  context_offset(FloatSave.RegisterArea[3 * 10]),
  context_offset(FloatSave.RegisterArea[4 * 10]),
  context_offset(FloatSave.RegisterArea[5 * 10]),
  context_offset(FloatSave.RegisterArea[6 * 10]),
  context_offset(FloatSave.RegisterArea[7 * 10]),
d171 2
d200 1
a200 1
  for (th = &thread_head; (th = th->next) != NULL; )
d221 1
a221 1
child_add_thread(DWORD id, HANDLE h)
d229 1
a229 1
  memset(th, 0, sizeof (*th));
d290 14
a303 2
  if (r >= 0)
    supply_register (r, ((char *) &current_thread->context) + mappings[r]);
d338 84
d428 1
a428 1
  LOAD_DLL_DEBUG_INFO * event = &current_event.u.LoadDll;
d432 1
a432 1
  char *p, *dll_name = NULL, *dll_basename;
d435 1
d437 2
a438 1
  dll_buf[0] = dll_buf[sizeof(dll_buf) - 1] = '\0';
d440 2
a441 10
  /* The following code attempts to find the name of the dll by reading the
     name from the processes memory.  Unfortunately it doesn't work right.
     Doing this the "right way" for Windows is very difficult.  FIXME */
#ifdef DOESNT_WORK
  memset (&minfo, 0, sizeof minfo);
  if (VirtualQueryEx (current_process_handle, (LPCVOID) event->lpBaseOfDll,
		      &minfo, sizeof(minfo)) && minfo.BaseAddress) {
      DWORD len;
      IMAGE_DOS_HEADER *hmm0 = (IMAGE_DOS_HEADER *) minfo.BaseAddress;
      HMODULE hmm = (HMODULE) (((DWORD) hmm0) + hmm0->e_lfanew);
d443 1
a443 7
      if ((len = GetModuleFileName (hmm, dll_buf, MAX_PATH)))
	{
	  dll_name = dll_buf;
	  dll_name[len] = '\0';
	}
  }
#endif
d460 1
a460 1
	 address isn't null. */
a506 22
  /* FIXME!! It would be nice to define one symbol which pointed to the
     front of the dll if we can't find any symbols. */

  if (!(dll_basename = strrchr(dll_name, '/')))
    dll_basename = dll_name;
  else
    dll_basename++;

  ALL_OBJFILES(objfile)
    {
      char *objfile_basename;
      objfile_basename = strrchr(objfile->name, '/');

      if (objfile_basename &&
	  strcmp(dll_basename, objfile_basename + 1) == 0)
	{
	  printf_unfiltered ("%x:%s (symbols previously loaded)\n",
			     event->lpBaseOfDll, dll_name);
	  goto out;
	}
  }

d514 2
a515 1
  symbol_file_add (dll_name, 0, (int) event->lpBaseOfDll + 0x1000, 0, 0, 0, 0, 1);
a517 1
out:
d531 1
a531 1
      ((CORE_ADDR) current_event.u.DebugString.lpDebugStringData, &s, 1024, 0)
d535 1
a535 1
  if (strncmp(s, CYGWIN_SIGNAL_STRING, sizeof(CYGWIN_SIGNAL_STRING) - 1))
d537 2
a538 1
      warning (s);
d543 4
a546 2
      /*last_sig = */strtol(s + sizeof(CYGWIN_SIGNAL_STRING) - 1, &p, 0);
      if (gotasig = (ourstatus->value.sig = target_signal_from_host (last_sig)))
d570 1
a570 1
		     current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d572 10
d585 1
a585 1
		     current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d587 1
d591 1
a591 1
		     current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d596 1
a596 1
		     current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d598 1
a598 2
      /* User typed CTRL-C.  Continue with this status */
      last_sig = SIGINT;	/* FIXME - should check pass state */
d602 1
a602 1
		     current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d607 2
a608 2
	 that case, we want to let the program try to handle it, and
	 only break if we see the exception a second time.  */
d610 1
d612 1
d615 2
a616 2
			 current_event.u.Exception.ExceptionRecord.ExceptionCode,
			 current_event.u.Exception.ExceptionRecord.ExceptionAddress);
d618 1
d628 1
a628 1
child_continue (DWORD continue_status, int id)
d636 6
a641 4
  if (res = ContinueDebugEvent (current_event.dwProcessId,
				current_event.dwThreadId,
			        continue_status))
    for (th = &thread_head; (th = th->next) != NULL; )
d653 122
d777 3
d788 7
a794 7
      DWORD continue_status;
      BOOL t = WaitForDebugEvent (&current_event, INFINITE);
      char *p;
      thread_info *th;
      int sig;

      event_count++;
d796 2
a797 1
      continue_status = DBG_CONTINUE;
d799 2
a800 80
      switch (current_event.dwDebugEventCode)
	{
	case CREATE_THREAD_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"CREATE_THREAD_DEBUG_EVENT"));
	  /* Record the existence of this thread */
	  child_add_thread (current_event.dwThreadId,
			    current_event.u.CreateThread.hThread);
	  if (info_verbose)
	      printf_unfiltered ("[New %s]\n",
			       target_pid_to_str (current_event.dwThreadId));
	  break;

	case EXIT_THREAD_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"EXIT_THREAD_DEBUG_EVENT"));
	  child_delete_thread (current_event.dwThreadId);
	  break;

	case CREATE_PROCESS_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"CREATE_PROCESS_DEBUG_EVENT"));
	  current_process_handle = current_event.u.CreateProcessInfo.hProcess;

	  main_thread_id = inferior_pid = current_event.dwThreadId;
	  /* Add the main thread */
	  current_thread = child_add_thread (inferior_pid,
				current_event.u.CreateProcessInfo.hThread);
	  break;

	case EXIT_PROCESS_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"EXIT_PROCESS_DEBUG_EVENT"));
	  ourstatus->kind = TARGET_WAITKIND_EXITED;
	  ourstatus->value.integer = current_event.u.ExitProcess.dwExitCode;
	  CloseHandle (current_process_handle);
	  return current_event.dwProcessId;
	  break;

	case LOAD_DLL_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"LOAD_DLL_DEBUG_EVENT"));
          catch_errors (handle_load_dll, NULL, "", RETURN_MASK_ALL);
	  registers_changed();          /* mark all regs invalid */
	  break;

	case UNLOAD_DLL_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"UNLOAD_DLL_DEBUG_EVENT"));
	  break;	/* FIXME: don't know what to do here */

	case EXCEPTION_DEBUG_EVENT:
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"EXCEPTION_DEBUG_EVENT"));
	  if (handle_exception (ourstatus))
	    return current_event.dwThreadId;
	  continue_status = DBG_EXCEPTION_NOT_HANDLED;
	  break;

	case OUTPUT_DEBUG_STRING_EVENT: /* message from the kernel */
	  DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			current_event.dwProcessId, current_event.dwThreadId,
			"OUTPUT_DEBUG_STRING_EVENT"));
	  if (handle_output_debug_string (ourstatus))
	    return main_thread_id;
	  break;
	default:
	  printf_unfiltered ("gdb: kernel event for pid=%d tid=%d\n",
			     current_event.dwProcessId,
			     current_event.dwThreadId);
	  printf_unfiltered ("                 unknown event code %d\n",
			     current_event.dwDebugEventCode);
	  break;
a801 2

      CHECK (child_continue (continue_status, -1));
d895 1
a895 1
  int  envlen;
a896 1

d903 1
d941 4
a944 4
      {
	"PATH=",
	0
      };
d1004 1
a1004 1
		       args, 	/* command line */
d1014 1
a1014 1
    error ("Error creating process %s, (error %d)\n", exec_file, GetLastError());
d1030 7
a1036 2
  /* Ignore the first trap */
  child_wait (inferior_pid, &dummy);
d1044 2
a1045 1
  (void) child_continue (DBG_CONTINUE, -1);
d1057 2
a1058 2
  CHECK (GenerateConsoleCtrlEvent (CTRL_C_EVENT, 0));
  registers_changed();		/* refresh register state */
d1091 2
a1092 1
      if (!child_continue (DBG_CONTINUE, -1))
d1104 1
a1104 1
  target_mourn_inferior();	/* or just child_mourn_inferior? */
a1111 2
  DWORD continue_status = last_sig > 0 && last_sig < NSIG ?
			  DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;
a1134 2
  if (sig && sig != last_sig)
    fprintf_unfiltered (gdb_stderr, "Can't send signals to the child.  signal %d\n", sig);
d1136 1
a1136 2
  last_sig = 0;
  child_continue (continue_status, pid);
d1157 1
a1157 1
struct target_ops child_ops ;
d1159 2
a1160 2
static void 
init_child_ops(void)
d1162 41
a1202 40
  child_ops.to_shortname =   "child";
  child_ops.to_longname =   "Win32 child process";
  child_ops.to_doc =   "Win32 child process (started by the \"run\" command).";
  child_ops.to_open =   child_open;
  child_ops.to_close =   child_close;
  child_ops.to_attach =   child_attach;
  child_ops.to_detach =   child_detach;
  child_ops.to_resume =   child_resume;
  child_ops.to_wait  =   child_wait;
  child_ops.to_fetch_registers  =   child_fetch_inferior_registers;
  child_ops.to_store_registers  =   child_store_inferior_registers;
  child_ops.to_prepare_to_store =   child_prepare_to_store;
  child_ops.to_xfer_memory  =   child_xfer_memory;
  child_ops.to_files_info  =   child_files_info;
  child_ops.to_insert_breakpoint =   memory_insert_breakpoint;
  child_ops.to_remove_breakpoint =   memory_remove_breakpoint;
  child_ops.to_terminal_init  =   terminal_init_inferior;
  child_ops.to_terminal_inferior =   terminal_inferior;
  child_ops.to_terminal_ours_for_output =   terminal_ours_for_output;
  child_ops.to_terminal_ours  =   terminal_ours;
  child_ops.to_terminal_info  =   child_terminal_info;
  child_ops.to_kill  =   child_kill_inferior;
  child_ops.to_load  =   0;
  child_ops.to_lookup_symbol =   0;
  child_ops.to_create_inferior =   child_create_inferior;
  child_ops.to_mourn_inferior =   child_mourn_inferior;
  child_ops.to_can_run  =   child_can_run;
  child_ops.to_notice_signals =   0;
  child_ops.to_thread_alive  =   win32_child_thread_alive;
  child_ops.to_stop  =   child_stop;
  child_ops.to_stratum =   process_stratum;
  child_ops.DONT_USE =   0;
  child_ops.to_has_all_memory =   1;
  child_ops.to_has_memory =   1;
  child_ops.to_has_stack =   1;
  child_ops.to_has_registers =   1;
  child_ops.to_has_execution =   1;
  child_ops.to_sections =   0;
  child_ops.to_sections_end =   0;
  child_ops.to_magic =   OPS_MAGIC;
d1209 1
a1209 1
  init_child_ops() ;
d1249 1
a1249 1
		  "Set whether to display kernel exceptions in child process.",
d1262 2
a1263 2
  return WaitForSingleObject(thread_rec (pid, FALSE)->h, 0) == WAIT_OBJECT_0 ?
	 FALSE : TRUE;
d1276 57
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a52 11
/* The ui's event loop. */
extern int (*ui_loop_hook) PARAMS ((int signo));

/* If we're not using the old Cygwin header file set, define the
   following which never should have been in the generic Win32 API
   headers in the first place since they were our own invention... */
#ifndef _GNU_H_WINDOWS_H
#define FLAG_TRACE_BIT 0x100
#define CONTEXT_DEBUGGER (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
#endif

a67 1
void child_kill_inferior PARAMS ((void));
d456 1
a456 3
      gotasig = target_signal_from_host (last_sig);
      ourstatus->value.sig = gotasig;
      if (gotasig)
d533 3
a535 4
  res = ContinueDebugEvent (current_event.dwProcessId,
			    current_event.dwThreadId,
			    continue_status);
  if (res)
d559 1
a559 1
      BOOL debug_event = WaitForDebugEvent (&current_event, 20);
d564 1
a564 3
      if (debug_event)
	{
	  event_count++;
d566 1
a566 1
	  continue_status = DBG_CONTINUE;
d568 80
a647 83
	  switch (current_event.dwDebugEventCode)
	    {
	    case CREATE_THREAD_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "CREATE_THREAD_DEBUG_EVENT"));
	      /* Record the existence of this thread */
	      child_add_thread (current_event.dwThreadId,
				current_event.u.CreateThread.hThread);
	      if (info_verbose)
		printf_unfiltered ("[New %s]\n",
				   target_pid_to_str (current_event.dwThreadId));
	      break;

	    case EXIT_THREAD_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "EXIT_THREAD_DEBUG_EVENT"));
	      child_delete_thread (current_event.dwThreadId);
	      break;

	    case CREATE_PROCESS_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "CREATE_PROCESS_DEBUG_EVENT"));
	      current_process_handle = current_event.u.CreateProcessInfo.hProcess;

	      main_thread_id = inferior_pid = current_event.dwThreadId;
	      /* Add the main thread */
	      current_thread = child_add_thread (inferior_pid,
						 current_event.u.CreateProcessInfo.hThread);
	      break;

	    case EXIT_PROCESS_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "EXIT_PROCESS_DEBUG_EVENT"));
	      ourstatus->kind = TARGET_WAITKIND_EXITED;
	      ourstatus->value.integer = current_event.u.ExitProcess.dwExitCode;
	      CloseHandle (current_process_handle);
	      return current_event.dwProcessId;
	      break;

	    case LOAD_DLL_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "LOAD_DLL_DEBUG_EVENT"));
	      catch_errors (handle_load_dll, NULL, "", RETURN_MASK_ALL);
	      registers_changed();          /* mark all regs invalid */
	      break;

	    case UNLOAD_DLL_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "UNLOAD_DLL_DEBUG_EVENT"));
	      break;	/* FIXME: don't know what to do here */

	    case EXCEPTION_DEBUG_EVENT:
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "EXCEPTION_DEBUG_EVENT"));
	      if (handle_exception (ourstatus))
		return current_event.dwThreadId;
	      continue_status = DBG_EXCEPTION_NOT_HANDLED;
	      break;

	    case OUTPUT_DEBUG_STRING_EVENT: /* message from the kernel */
	      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
			     current_event.dwProcessId, current_event.dwThreadId,
			     "OUTPUT_DEBUG_STRING_EVENT"));
	      if (handle_output_debug_string (ourstatus))
		return main_thread_id;
	      break;
	    default:
	      printf_unfiltered ("gdb: kernel event for pid=%d tid=%d\n",
				 current_event.dwProcessId,
				 current_event.dwThreadId);
	      printf_unfiltered ("                 unknown event code %d\n",
				 current_event.dwDebugEventCode);
	      break;
	    }

	  CHECK (child_continue (continue_status, -1));
a648 3
      else
	{
	  int detach = 0;
d650 1
a650 6
	  if (ui_loop_hook != NULL)
	    detach = ui_loop_hook (0);

	  if (detach)
	    child_kill_inferior ();
	}
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d19 2
a20 3
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.
 */
d87 8
a94 9
  {
    struct thread_info_struct *next;
    DWORD id;
    HANDLE h;
    char *name;
    int suspend_count;
    CONTEXT context;
  }
thread_info;
d96 1
a96 2
static thread_info thread_head =
{NULL};
d104 1
a104 1
static DWORD main_thread_id;	/* Thread ID of the main thread */
d113 3
a115 3
static int debug_exec = 0;	/* show execution */
static int debug_events = 0;	/* show events from kernel */
static int debug_memory = 0;	/* show target memory accesses */
d134 24
a157 24
  context_offset (Eax),
  context_offset (Ecx),
  context_offset (Edx),
  context_offset (Ebx),
  context_offset (Esp),
  context_offset (Ebp),
  context_offset (Esi),
  context_offset (Edi),
  context_offset (Eip),
  context_offset (EFlags),
  context_offset (SegCs),
  context_offset (SegSs),
  context_offset (SegDs),
  context_offset (SegEs),
  context_offset (SegFs),
  context_offset (SegGs),
  context_offset (FloatSave.RegisterArea[0 * 10]),
  context_offset (FloatSave.RegisterArea[1 * 10]),
  context_offset (FloatSave.RegisterArea[2 * 10]),
  context_offset (FloatSave.RegisterArea[3 * 10]),
  context_offset (FloatSave.RegisterArea[4 * 10]),
  context_offset (FloatSave.RegisterArea[5 * 10]),
  context_offset (FloatSave.RegisterArea[6 * 10]),
  context_offset (FloatSave.RegisterArea[7 * 10]),
d187 1
a187 1
  for (th = &thread_head; (th = th->next) != NULL;)
d208 1
a208 1
child_add_thread (DWORD id, HANDLE h)
d216 1
a216 1
  memset (th, 0, sizeof (*th));
d319 1
a319 1
  LOAD_DLL_DEBUG_INFO *event = &current_event.u.LoadDll;
d327 1
a327 1
  dll_buf[0] = dll_buf[sizeof (dll_buf) - 1] = '\0';
d335 1
a335 2
		      &minfo, sizeof (minfo)) && minfo.BaseAddress)
    {
d345 1
a345 1
    }
d363 1
a363 1
         address isn't null. */
d413 1
a413 1
  if (!(dll_basename = strrchr (dll_name, '/')))
d418 4
a421 4
  ALL_OBJFILES (objfile)
  {
    char *objfile_basename;
    objfile_basename = strrchr (objfile->name, '/');
d423 7
a429 7
    if (objfile_basename &&
	strcmp (dll_basename, objfile_basename + 1) == 0)
      {
	printf_unfiltered ("%x:%s (symbols previously loaded)\n",
			   event->lpBaseOfDll, dll_name);
	goto out;
      }
d456 1
a456 1
    ((CORE_ADDR) current_event.u.DebugString.lpDebugStringData, &s, 1024, 0)
d460 1
a460 1
  if (strncmp (s, CYGWIN_SIGNAL_STRING, sizeof (CYGWIN_SIGNAL_STRING) - 1))
d467 1
a467 1
      /*last_sig = */ strtol (s + sizeof (CYGWIN_SIGNAL_STRING) - 1, &p, 0);
d494 1
a494 1
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d499 1
a499 1
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d504 1
a504 1
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d509 1
a509 1
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d516 1
a516 1
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
d521 2
a522 2
         that case, we want to let the program try to handle it, and
         only break if we see the exception a second time.  */
d527 2
a528 2
		    current_event.u.Exception.ExceptionRecord.ExceptionCode,
		current_event.u.Exception.ExceptionRecord.ExceptionAddress);
d551 1
a551 1
    for (th = &thread_head; (th = th->next) != NULL;)
d589 1
a589 1
			current_event.dwProcessId, current_event.dwThreadId,
d596 1
a596 1
			      target_pid_to_str (current_event.dwThreadId));
d601 1
a601 1
			current_event.dwProcessId, current_event.dwThreadId,
d608 1
a608 1
			current_event.dwProcessId, current_event.dwThreadId,
d615 1
a615 1
				 current_event.u.CreateProcessInfo.hThread);
d620 1
a620 1
			current_event.dwProcessId, current_event.dwThreadId,
d630 1
a630 1
			current_event.dwProcessId, current_event.dwThreadId,
d633 1
a633 1
	      registers_changed ();	/* mark all regs invalid */
d638 1
a638 1
			current_event.dwProcessId, current_event.dwThreadId,
d640 1
a640 1
	      break;		/* FIXME: don't know what to do here */
d644 1
a644 1
			current_event.dwProcessId, current_event.dwThreadId,
d651 1
a651 1
	    case OUTPUT_DEBUG_STRING_EVENT:	/* message from the kernel */
d653 1
a653 1
			current_event.dwProcessId, current_event.dwThreadId,
d772 1
a772 1
  int envlen;
d818 4
a821 4
    {
      "PATH=",
      0
    };
d881 1
a881 1
		       args,	/* command line */
d891 1
a891 1
    error ("Error creating process %s, (error %d)\n", exec_file, GetLastError ());
d929 1
a929 1
  registers_changed ();		/* refresh register state */
d974 1
a974 1
  target_mourn_inferior ();	/* or just child_mourn_inferior? */
d983 1
a983 1
  DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;
d1032 1
a1032 1
struct target_ops child_ops;
d1034 2
a1035 2
static void
init_child_ops (void)
d1037 40
a1076 40
  child_ops.to_shortname = "child";
  child_ops.to_longname = "Win32 child process";
  child_ops.to_doc = "Win32 child process (started by the \"run\" command).";
  child_ops.to_open = child_open;
  child_ops.to_close = child_close;
  child_ops.to_attach = child_attach;
  child_ops.to_detach = child_detach;
  child_ops.to_resume = child_resume;
  child_ops.to_wait = child_wait;
  child_ops.to_fetch_registers = child_fetch_inferior_registers;
  child_ops.to_store_registers = child_store_inferior_registers;
  child_ops.to_prepare_to_store = child_prepare_to_store;
  child_ops.to_xfer_memory = child_xfer_memory;
  child_ops.to_files_info = child_files_info;
  child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  child_ops.to_terminal_init = terminal_init_inferior;
  child_ops.to_terminal_inferior = terminal_inferior;
  child_ops.to_terminal_ours_for_output = terminal_ours_for_output;
  child_ops.to_terminal_ours = terminal_ours;
  child_ops.to_terminal_info = child_terminal_info;
  child_ops.to_kill = child_kill_inferior;
  child_ops.to_load = 0;
  child_ops.to_lookup_symbol = 0;
  child_ops.to_create_inferior = child_create_inferior;
  child_ops.to_mourn_inferior = child_mourn_inferior;
  child_ops.to_can_run = child_can_run;
  child_ops.to_notice_signals = 0;
  child_ops.to_thread_alive = win32_child_thread_alive;
  child_ops.to_stop = child_stop;
  child_ops.to_stratum = process_stratum;
  child_ops.DONT_USE = 0;
  child_ops.to_has_all_memory = 1;
  child_ops.to_has_memory = 1;
  child_ops.to_has_stack = 1;
  child_ops.to_has_registers = 1;
  child_ops.to_has_execution = 1;
  child_ops.to_sections = 0;
  child_ops.to_sections_end = 0;
  child_ops.to_magic = OPS_MAGIC;
d1083 1
a1083 1
  init_child_ops ();
d1123 1
a1123 1
	       "Set whether to display kernel exceptions in child process.",
d1136 2
a1137 2
  return WaitForSingleObject (thread_rec (pid, FALSE)->h, 0) == WAIT_OBJECT_0 ?
    FALSE : TRUE;
@


1.1.1.4
log
@import gdb-1999-08-16 snapshot
@
text
@d326 1
a326 1
  char *p, *dll_name = NULL;
d414 22
d446 1
@


1.1.1.5
log
@import gdb-1999-08-30 snapshot
@
text
@d52 1
@


1.1.1.6
log
@import gdb-1999-10-04 snapshot
@
text
@a327 1
  struct section_addr_info section_addrs;
a328 1
  memset (&section_addrs, 0, sizeof (section_addrs));
d420 1
a420 2
  section_addrs.text_addr = (int) event->lpBaseOfDll + 0x1000;
  symbol_file_add (dll_name, 0, &section_addrs, 0, 0, 0, 1);
d890 1
a890 1
  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);
@


1.1.1.7
log
@import gdb-1999-10-11 snapshot
@
text
@d423 1
a423 1
  symbol_file_add (dll_name, 0, &section_addrs, 0, OBJF_SHARED);
@


1.1.1.8
log
@import gdb-1999-12-06 snapshot
@
text
@a42 1
#include <imagehlp.h>
a51 1
#include <unistd.h>
d81 3
d94 2
a95 4
    STACKFRAME sf;
  } thread_info;

static thread_info thread_head = {NULL};
d97 2
a98 2
/* The saved state for a continue after breaking back to gdb. */
static DWORD continue_status;
d114 1
a114 1
static int new_group = 1;
a159 7
  context_offset (FloatSave.ControlWord),
  context_offset (FloatSave.StatusWord),
  context_offset (FloatSave.TagWord),
  context_offset (FloatSave.ErrorSelector),
  context_offset (FloatSave.ErrorOffset),
  context_offset (FloatSave.DataSelector),
  context_offset (FloatSave.DataOffset),
d279 1
a279 13
  char *context_offset = ((char *) &current_thread->context) + mappings[r];
  long l;
  if (r == FCS_REGNUM)
    {
      l = *((long *)context_offset) & 0xffff;
      supply_register (r, (char *) &l);
    }
  else if (r == FOP_REGNUM)
    {
      l = (*((long *)context_offset) >> 16) & ((1 << 11) - 1);
      supply_register (r, (char *) &l);
    }
  else if (r >= 0)
a314 84
#include <psapi.h>
static int psapi_loaded = 0;
static HMODULE psapi_module_handle = NULL;
static BOOL  WINAPI (*psapi_EnumProcessModules)(HANDLE, HMODULE*, DWORD, LPDWORD)= NULL;
static BOOL  WINAPI (*psapi_GetModuleInformation) (HANDLE, HMODULE, LPMODULEINFO, DWORD)= NULL;
static DWORD WINAPI (*psapi_GetModuleFileNameExA) (HANDLE, HMODULE, LPSTR, DWORD)= NULL;

int psapi_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
{
  DWORD len;
  MODULEINFO mi;
  int i;
  HMODULE dh_buf [ 1 ];
  HMODULE* DllHandle = dh_buf;
  DWORD cbNeeded;
  BOOL ok;

  if (!psapi_loaded ||
       psapi_EnumProcessModules   == NULL ||
       psapi_GetModuleInformation == NULL ||
       psapi_GetModuleFileNameExA == NULL)
    {
      if (psapi_loaded)goto failed;
      psapi_loaded = 1;
      psapi_module_handle = LoadLibrary ("psapi.dll");
      if (!psapi_module_handle)
        {
          /* printf_unfiltered ("error loading psapi.dll: %u", GetLastError ());*/
          goto failed;
        }
      psapi_EnumProcessModules   = GetProcAddress (psapi_module_handle, "EnumProcessModules" );
      psapi_GetModuleInformation = GetProcAddress (psapi_module_handle, "GetModuleInformation");
      psapi_GetModuleFileNameExA = (void *) GetProcAddress (psapi_module_handle,
							    "GetModuleFileNameExA");
      if (psapi_EnumProcessModules   == NULL ||
           psapi_GetModuleInformation == NULL ||
           psapi_GetModuleFileNameExA == NULL)
	goto failed;
    }

  cbNeeded = 0;
  ok = (*psapi_EnumProcessModules) (current_process_handle,
				     DllHandle,
				     sizeof (HMODULE),
				     &cbNeeded);

  if (!ok || !cbNeeded)
    goto failed;

  DllHandle = (HMODULE*) alloca (cbNeeded);
  if (!DllHandle)
    goto failed;

  ok = (*psapi_EnumProcessModules) (current_process_handle,
				     DllHandle,
				     cbNeeded,
				     &cbNeeded);
  if (!ok)
    goto failed;

  for (i = 0; i < cbNeeded / sizeof (HMODULE); i++)
    {
      if (!(*psapi_GetModuleInformation) (current_process_handle,
					     DllHandle [i],
					     &mi,
					     sizeof (mi)))
	error ("Can't get module info");

      len = (*psapi_GetModuleFileNameExA) (current_process_handle,
					    DllHandle [i],
					    dll_name_ret,
					    MAX_PATH);
      if (len == 0)
	error ("Error getting dll name: %u\n", GetLastError ()); 

      if ((DWORD) (mi.lpBaseOfDll) == BaseAddress)
	return 1;
    }

failed:
  dll_name_ret[0] = '\0';
  return 0;
}

d333 11
a343 2
  if (!psapi_get_dll_name ((DWORD) (event->lpBaseOfDll), dll_buf))
    dll_buf[0] = dll_buf[sizeof(dll_buf) - 1] = '\0';
d345 7
a351 1
  dll_name = dll_buf;
d445 1
a445 2
      if (strncmp (s, "cYg", 3))
	warning (s);
d447 1
d450 2
a451 2
      int sig = strtol (s + sizeof (CYGWIN_SIGNAL_STRING) - 1, &p, 0);
      gotasig = target_signal_from_host (sig);
a478 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
a483 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
d494 2
a495 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
a512 1
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
d522 1
a522 1
child_continue (int id)
a532 1
  continue_status = 0;
a545 122
get_child_debug_event (int pid, struct target_waitstatus *ourstatus,
		       DWORD *event_code, int *retval)
{
  BOOL debug_event;
  int breakout = 1;

  if (!(debug_event = WaitForDebugEvent (&current_event, 20)))
    {
      breakout = *retval = *event_code = 0;
      goto out;
    }

  event_count++;
  continue_status = DBG_CONTINUE;
  *retval = 0;

  switch (*event_code = current_event.dwDebugEventCode)
    {
    case CREATE_THREAD_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%x code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "CREATE_THREAD_DEBUG_EVENT"));
      /* Record the existence of this thread */
      child_add_thread (current_event.dwThreadId,
			current_event.u.CreateThread.hThread);
      if (info_verbose)
	printf_unfiltered ("[New %s]\n",
		      target_pid_to_str (current_event.dwThreadId));
      break;

    case EXIT_THREAD_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "EXIT_THREAD_DEBUG_EVENT"));
      child_delete_thread (current_event.dwThreadId);
      break;

    case CREATE_PROCESS_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "CREATE_PROCESS_DEBUG_EVENT"));
      current_process_handle = current_event.u.CreateProcessInfo.hProcess;

      main_thread_id = inferior_pid = current_event.dwThreadId;
      /* Add the main thread */
      current_thread = child_add_thread (inferior_pid,
			 current_event.u.CreateProcessInfo.hThread);
      break;

    case EXIT_PROCESS_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "EXIT_PROCESS_DEBUG_EVENT"));
      ourstatus->kind = TARGET_WAITKIND_EXITED;
      ourstatus->value.integer = current_event.u.ExitProcess.dwExitCode;
      CloseHandle (current_process_handle);
      *retval = current_event.dwProcessId;
      goto out;

    case LOAD_DLL_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "LOAD_DLL_DEBUG_EVENT"));
      catch_errors (handle_load_dll, NULL, "", RETURN_MASK_ALL);
      registers_changed ();	/* mark all regs invalid */
      break;

    case UNLOAD_DLL_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "UNLOAD_DLL_DEBUG_EVENT"));
      break;		/* FIXME: don't know what to do here */

    case EXCEPTION_DEBUG_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "EXCEPTION_DEBUG_EVENT"));
      if (handle_exception (ourstatus))	/* sets continue_status */
	{
	  *retval = current_event.dwThreadId;
	  goto out;
	}
      break;

    case OUTPUT_DEBUG_STRING_EVENT:
      DEBUG_EVENTS (("gdb: kernel event for pid=%d tid=%d code=%s)\n",
		    (unsigned) current_event.dwProcessId,
		    (unsigned) current_event.dwThreadId,
		    "OUTPUT_DEBUG_STRING_EVENT"));
      if (handle_output_debug_string (ourstatus))
	{
	  *retval = main_thread_id;
	  goto out;
	}
      break;
    default:
      printf_unfiltered ("gdb: kernel event for pid=%d tid=%d\n",
			 current_event.dwProcessId,
			 current_event.dwThreadId);
      printf_unfiltered ("                 unknown event code %d\n",
			 current_event.dwDebugEventCode);
      break;
    }

  breakout = 0;
  CHECK (child_continue (-1));
  continue_status = 0;

out:
  return breakout;
}


/* Wait for interesting events to occur in the target process. */
static int
a547 3
  DWORD event_code;
  int retval;

d556 96
a651 4
      if (continue_status != 0)
	CHECK (child_continue (-1));
      if (get_child_debug_event (pid, ourstatus, &event_code, &retval))
	return retval;
d757 1
a763 1
  DWORD event_code;
d890 2
a891 4
  /* Run until process and threads are loaded */
  do
    get_child_debug_event (inferior_pid, &dummy, &event_code, &ret);
  while (event_code != EXCEPTION_DEBUG_EVENT);
d893 1
a893 1
  proceed ((CORE_ADDR) - 1, TARGET_SIGNAL_0, 0);
d899 1
a899 2
  continue_status = DBG_CONTINUE;
  (void) child_continue (-1);
d911 1
a911 1
  CHECK (GenerateConsoleCtrlEvent (CTRL_C_EVENT, current_event.dwProcessId));
d945 1
a945 2
      continue_status = DBG_CONTINUE;
      if (!child_continue (-1))
d965 2
d990 2
d993 2
a994 1
  child_continue (pid);
a1133 37
#ifdef NOTYET
CORE_ADDR
win32_read_fp ()
{
  STACKFRAME *sf = current_thread->sf;
  
  memset (&sf, 0, sizeof(sf));
  sf->AddrPC.Offset = current_thread->context.Eip;
  sf->AddrPC.Mode = AddrModeFlat;
  sf->AddrStack.Offset = current_thread->context.Esp;
  sf->AddrStack.Mode = AddrModeFlat;
  sf->AddrFrame.Offset = current_thread->context.Ebp;
  if (!StackWalk (IMAGE_FILE_MACHINE_I386, current_process_handle,
		  current->thread->h, sf, NULL, NULL,
		  SymFunctionTableAccess, SymGetModuleBase, NULL))
    return NULL;
  return (CORE_ADDR) sf.AddrFrame.Offset;
}

CORE_ADDR
child_frame_chain(struct frame_info *thisframe)
{
  STACKFRAME *sf = current->thread->sf;
#if 0
  sf.AddrPC.Offset = thisframe->pc;
  sf.AddrPC.Mode = AddrModeFlat;
  sf.AddrStack.Offset = thisframe->;
  sf.AddrStack.Mode = AddrModeFlat;
  sf.AddrFrame.Offset = cx->Ebp;
#endif
  if (!StackWalk (IMAGE_FILE_MACHINE_I386, current_process_handle,
		  current->thread->h, &sf, NULL, NULL,
		  SymFunctionTableAccess, SymGetModuleBase, NULL))
    return NULL;
  return (CORE_ADDR) sf->AddrFrame.Offset;
}
#endif
@


1.1.1.9
log
@import gdb-1999-12-21 snapshot
@
text
@a167 1
  context_offset (FloatSave.ErrorSelector)
a169 2
#undef context_offset

d300 1
a300 1
    supply_register (r, context_offset);
d532 1
a532 1
  if (strncmp (s, CYGWIN_SIGNAL_STRING, sizeof (CYGWIN_SIGNAL_STRING) - 1) != 0)
d534 1
a534 1
      if (strncmp (s, "cYg", 3) != 0)
a536 1
  else
d595 1
a595 1
         only break if we see the exception a second time.
a596 1

a597 1
*/
a1019 3
  SymSetOptions (SYMOPT_DEFERRED_LOADS);
  SymInitialize (current_process_handle, NULL, TRUE);

a1172 1
  child_ops.to_pid_to_str = cygwin_pid_to_str;
d1258 3
a1260 3

static LPVOID __stdcall
sfta(HANDLE h, DWORD d)
d1262 13
a1274 1
  return NULL;
d1277 2
a1278 2
static DWORD __stdcall
sgmb(HANDLE h, DWORD d)
d1280 1
d1282 5
a1286 3
  return 4;
#else
  return SymGetModuleBase (h, d) ?: 4;
a1287 6
}

CORE_ADDR
child_frame_chain(struct frame_info *f)
{
  STACKFRAME *sf = (STACKFRAME *) f->extra_info;
d1289 4
a1292 34
		  current_thread->h, sf, NULL, NULL, SymFunctionTableAccess, sgmb, NULL) ||
      !sf->AddrReturn.Offset)
    return 0;
  return sf->AddrFrame.Offset;
}

CORE_ADDR
child_frame_saved_pc(struct frame_info *f)
{
  STACKFRAME *sf = (STACKFRAME *) f->extra_info;
  return sf->AddrReturn.Offset;
}

void
child_init_frame(int leaf, struct frame_info *f)
{
  STACKFRAME *sf;

  if (f->next && f->next->extra_info)
    f->extra_info = f->next->extra_info;
  else if (f->prev && f->prev->extra_info)
    f->extra_info = f->prev->extra_info;
  else
    {
      sf = (STACKFRAME *) frame_obstack_alloc (sizeof (*sf));
      f->extra_info = (struct frame_extra_info *) sf;
      memset (sf, 0, sizeof(*sf));
      sf->AddrPC.Offset = f->pc;
      sf->AddrPC.Mode = AddrModeFlat;
      sf->AddrStack.Offset = current_thread->context.Esp;
      sf->AddrStack.Mode = AddrModeFlat;
      sf->AddrFrame.Offset = f->frame;
      sf->AddrFrame.Mode = AddrModeFlat;
    }
d1294 1
@


1.1.1.10
log
@import gdb-2000-01-10 snapshot
@
text
@a573 9
    case STATUS_FLOAT_UNDERFLOW:
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
    case STATUS_FLOAT_OVERFLOW:
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      DEBUG_EXCEPT (("gdb: Target exception STACK_OVERFLOW at 0x%08x\n",
	       current_event.u.Exception.ExceptionRecord.ExceptionAddress));
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      continue_status = DBG_EXCEPTION_NOT_HANDLED;
      break;
@


