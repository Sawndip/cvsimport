head	1.15;
access;
symbols
	gdb_5_3-2002-12-12-release:1.14
	carlton_dictionary-20021115-merge:1.14
	kseitz_interps-20021105-merge:1.14
	kseitz_interps-20021103-merge:1.14
	drow-cplus-merge-20021020:1.14
	drow-cplus-merge-20021025:1.14
	carlton_dictionary-20021025-merge:1.14
	carlton_dictionary-20021011-merge:1.14
	drow-cplus-branch:1.14.0.10
	drow-cplus-branchpoint:1.14
	kseitz_interps-20020930-merge:1.14
	carlton_dictionary-20020927-merge:1.14
	carlton_dictionary-branch:1.14.0.8
	carlton_dictionary-20020920-branchpoint:1.14
	gdb_5_3-branch:1.14.0.6
	gdb_5_3-2002-09-04-branchpoint:1.14
	kseitz_interps-20020829-merge:1.14
	cagney_sysregs-20020825-branch:1.14.0.4
	cagney_sysregs-20020825-branchpoint:1.14
	readline_4_3-import-branch:1.14.0.2
	readline_4_3-import-branchpoint:1.14
	gdb_5_2_1-2002-07-23-release:1.12
	kseitz_interps-20020528-branch:1.13.0.6
	kseitz_interps-20020528-branchpoint:1.13
	cagney_regbuf-20020515-branch:1.13.0.4
	cagney_regbuf-20020515-branchpoint:1.13
	jimb-macro-020506-branch:1.13.0.2
	jimb-macro-020506-branchpoint:1.13
	gdb_5_2-2002-04-29-release:1.12
	gdb_5_2-branch:1.12.0.2
	gdb_5_2-2002-03-03-branchpoint:1.12
	gdb_5_1_1-2002-01-24-release:1.10
	gdb_5_1_0_1-2002-01-03-release:1.10
	cygnus_cvs_20020108_pre:1.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.10.0.6
	gdb_5_1-2001-11-21-release:1.10
	gdb_s390-2001-09-26-branch:1.10.0.4
	gdb_s390-2001-09-26-branchpoint:1.10
	gdb_5_1-2001-07-29-branch:1.10.0.2
	gdb_5_1-2001-07-29-branchpoint:1.10
	dberlin-typesystem-branch:1.9.0.2
	dberlin-typesystem-branchpoint:1.9
	gdb-post-ptid_t-2001-05-03:1.9
	gdb-pre-ptid_t-2001-05-03:1.9
	insight-precleanup-2001-01-01:1.6
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.5
	gdb_5_0-2000-05-19-release:1.1.1.5
	gdb_4_18_2-2000-05-18-release:1.1.1.5
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.5
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.5
	gdb_5_0-2000-04-10-branch:1.1.1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.5
	repo-unification-2000-02-06:1.1.1.5
	insight-2000-02-04:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.5
	gdb-2000-02-01:1.1.1.5
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.15
date	2002.12.16.20.39.02;	author cagney;	state dead;
branches;
next	1.14;

1.14
date	2002.07.14.00.15.19;	author cagney;	state Exp;
branches
	1.14.8.1
	1.14.10.1;
next	1.13;

1.13
date	2002.04.12.18.18.56;	author cagney;	state Exp;
branches
	1.13.6.1;
next	1.12;

1.12
date	2002.01.05.04.30.16;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.05.23.44.43;	author ezannoni;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.06.08.21.06;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.08.06.03.52;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.13.01.22.17;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.26;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.05.26;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.08.23.59.06;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.11.09.01.23.02;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.02.02.00.21.05;	author jsm;	state Exp;
branches;
next	;

1.13.6.1
date	2002.07.22.21.46.57;	author kseitz;	state Exp;
branches;
next	;

1.14.8.1
date	2002.12.23.19.38.18;	author carlton;	state dead;
branches;
next	;

1.14.10.1
date	2003.12.14.20.27.10;	author drow;	state dead;
branches;
next	;


desc
@@


1.15
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@/* OBSOLETE /* Target-dependent code for Mitsubishi D30V, for GDB. */
/* OBSOLETE  */
/* OBSOLETE    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software */
/* OBSOLETE    Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE /*  Contributed by Martin Hunt, hunt@@cygnus.com */ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "obstack.h" */
/* OBSOLETE #include "symtab.h" */
/* OBSOLETE #include "gdbtypes.h" */
/* OBSOLETE #include "gdbcmd.h" */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE #include "gdb_string.h" */
/* OBSOLETE #include "value.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include "dis-asm.h" */
/* OBSOLETE #include "symfile.h" */
/* OBSOLETE #include "objfiles.h" */
/* OBSOLETE #include "regcache.h" */
/* OBSOLETE  */
/* OBSOLETE #include "language.h" /* For local_hex_string() */ */
/* OBSOLETE  */
/* OBSOLETE void d30v_frame_find_saved_regs (struct frame_info *fi, */
/* OBSOLETE 				 struct frame_saved_regs *fsr); */
/* OBSOLETE void d30v_frame_find_saved_regs_offsets (struct frame_info *fi, */
/* OBSOLETE 					 struct frame_saved_regs *fsr); */
/* OBSOLETE static void d30v_pop_dummy_frame (struct frame_info *fi); */
/* OBSOLETE static void d30v_print_flags (void); */
/* OBSOLETE static void print_flags_command (char *, int); */
/* OBSOLETE  */
/* OBSOLETE /* the following defines assume: */
/* OBSOLETE    fp is r61, lr is r62, sp is r63, and ?? is r22 */
/* OBSOLETE    if that changes, they will need to be updated */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_MASK_ALL_BUT_RA	0x0ffc0fff	/* throw away Ra, keep the rest */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_STW_SPM		0x054c0fc0	/* stw Ra, @@(sp-) */ */
/* OBSOLETE #define OP_STW_SP_R0		0x05400fc0	/* stw Ra, @@(sp,r0) */ */
/* OBSOLETE #define OP_STW_SP_IMM0		0x05480fc0	/* st Ra, @@(sp, 0x0) */ */
/* OBSOLETE #define OP_STW_R22P_R0		0x05440580	/* stw Ra, @@(r22+,r0) */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_ST2W_SPM		0x056c0fc0	/* st2w Ra, @@(sp-) */ */
/* OBSOLETE #define OP_ST2W_SP_R0		0x05600fc0	/* st2w Ra, @@(sp, r0) */ */
/* OBSOLETE #define OP_ST2W_SP_IMM0		0x05680fc0	/* st2w Ra, @@(sp, 0x0) */ */
/* OBSOLETE #define OP_ST2W_R22P_R0		0x05640580	/* st2w Ra, @@(r22+, r0) */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_MASK_OPCODE		0x0ffc0000	/* just the opcode, ign operands */ */
/* OBSOLETE #define OP_NOP			0x00f00000	/* nop */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_MASK_ALL_BUT_IMM	0x0fffffc0	/* throw away imm, keep the rest */ */
/* OBSOLETE #define OP_SUB_SP_IMM		0x082bffc0	/* sub sp,sp,imm */ */
/* OBSOLETE #define OP_ADD_SP_IMM		0x080bffc0	/* add sp,sp,imm */ */
/* OBSOLETE #define OP_ADD_R22_SP_IMM	0x08096fc0	/* add r22,sp,imm */ */
/* OBSOLETE #define OP_STW_FP_SP_IMM	0x054bdfc0	/* stw fp,@@(sp,imm) */ */
/* OBSOLETE #define OP_OR_SP_R0_IMM		0x03abf000	/* or sp,r0,imm */ */
/* OBSOLETE  */
/* OBSOLETE /* no mask */ */
/* OBSOLETE #define OP_OR_FP_R0_SP		0x03a3d03f	/* or fp,r0,sp */ */
/* OBSOLETE #define OP_OR_FP_SP_R0		0x03a3dfc0	/* or fp,sp,r0 */ */
/* OBSOLETE #define OP_OR_FP_IMM0_SP	0x03abd03f	/* or fp,0x0,sp */ */
/* OBSOLETE #define OP_STW_FP_R22P_R0	0x0547d580	/* stw fp,@@(r22+,r0) */ */
/* OBSOLETE #define OP_STW_LR_R22P_R0	0x0547e580	/* stw lr,@@(r22+,r0) */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_MASK_OP_AND_RB	0x0ff80fc0	/* keep op and rb,throw away rest */ */
/* OBSOLETE #define OP_STW_SP_IMM		0x05480fc0	/* stw Ra,@@(sp,imm) */ */
/* OBSOLETE #define OP_ST2W_SP_IMM		0x05680fc0	/* st2w Ra,@@(sp,imm) */ */
/* OBSOLETE #define OP_STW_FP_IMM		0x05480f40	/* stw Ra,@@(fp,imm) */ */
/* OBSOLETE #define OP_STW_FP_R0		0x05400f40	/* stw Ra,@@(fp,r0) */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_MASK_FM_BIT		0x80000000 */
/* OBSOLETE #define OP_MASK_CC_BITS		0x70000000 */
/* OBSOLETE #define OP_MASK_SUB_INST	0x0fffffff */
/* OBSOLETE  */
/* OBSOLETE #define EXTRACT_RA(op)		(((op) >> 12) & 0x3f) */
/* OBSOLETE #define EXTRACT_RB(op)		(((op) >> 6) & 0x3f) */
/* OBSOLETE #define EXTRACT_RC(op)		(((op) & 0x3f) */
/* OBSOLETE #define EXTRACT_UIMM6(op)	((op) & 0x3f) */
/* OBSOLETE #define EXTRACT_IMM6(op)	((((int)EXTRACT_UIMM6(op)) << 26) >> 26) */
/* OBSOLETE #define EXTRACT_IMM26(op)	((((op)&0x0ff00000) >> 2) | ((op)&0x0003ffff)) */
/* OBSOLETE #define EXTRACT_IMM32(opl, opr)	((EXTRACT_UIMM6(opl) << 26)|EXTRACT_IMM26(opr)) */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE d30v_frame_chain_valid (CORE_ADDR chain, struct frame_info *fi) */
/* OBSOLETE { */
/* OBSOLETE #if 0 */
/* OBSOLETE   return ((chain) != 0 && (fi) != 0 && (fi)->return_pc != 0); */
/* OBSOLETE #else */
/* OBSOLETE   return ((chain) != 0 && (fi) != 0 && (fi)->frame <= chain); */
/* OBSOLETE #endif */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Discard from the stack the innermost frame, restoring all saved */
/* OBSOLETE    registers.  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_pop_frame (void) */
/* OBSOLETE { */
/* OBSOLETE   struct frame_info *frame = get_current_frame (); */
/* OBSOLETE   CORE_ADDR fp; */
/* OBSOLETE   int regnum; */
/* OBSOLETE   struct frame_saved_regs fsr; */
/* OBSOLETE   char raw_buffer[8]; */
/* OBSOLETE  */
/* OBSOLETE   fp = FRAME_FP (frame); */
/* OBSOLETE   if (frame->dummy) */
/* OBSOLETE     { */
/* OBSOLETE       d30v_pop_dummy_frame (frame); */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* fill out fsr with the address of where each */ */
/* OBSOLETE   /* register was stored in the frame */ */
/* OBSOLETE   get_frame_saved_regs (frame, &fsr); */
/* OBSOLETE  */
/* OBSOLETE   /* now update the current registers with the old values */ */
/* OBSOLETE   for (regnum = A0_REGNUM; regnum < A0_REGNUM + 2; regnum++) */
/* OBSOLETE     { */
/* OBSOLETE       if (fsr.regs[regnum]) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  read_memory (fsr.regs[regnum], raw_buffer, 8); */
/* OBSOLETE 	  write_register_bytes (REGISTER_BYTE (regnum), raw_buffer, 8); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   for (regnum = 0; regnum < SP_REGNUM; regnum++) */
/* OBSOLETE     { */
/* OBSOLETE       if (fsr.regs[regnum]) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  write_register (regnum, read_memory_unsigned_integer (fsr.regs[regnum], 4)); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   if (fsr.regs[PSW_REGNUM]) */
/* OBSOLETE     { */
/* OBSOLETE       write_register (PSW_REGNUM, read_memory_unsigned_integer (fsr.regs[PSW_REGNUM], 4)); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   write_register (PC_REGNUM, read_register (LR_REGNUM)); */
/* OBSOLETE   write_register (SP_REGNUM, fp + frame->size); */
/* OBSOLETE   target_store_registers (-1); */
/* OBSOLETE   flush_cached_frames (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE check_prologue (unsigned long op) */
/* OBSOLETE { */
/* OBSOLETE   /* add sp,sp,imm -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_ADD_SP_IMM) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* add r22,sp,imm -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_ADD_R22_SP_IMM) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* or  fp,r0,sp -- observed */ */
/* OBSOLETE   if (op == OP_OR_FP_R0_SP) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* nop */ */
/* OBSOLETE   if ((op & OP_MASK_OPCODE) == OP_NOP) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw  Ra,@@(sp,r0) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SP_R0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw  Ra,@@(sp,0x0) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SP_IMM0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* st2w  Ra,@@(sp,r0) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_R0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* st2w  Ra,@@(sp,0x0) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_IMM0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw fp, @@(r22+,r0) -- observed */ */
/* OBSOLETE   if (op == OP_STW_FP_R22P_R0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw r62, @@(r22+,r0) -- observed */ */
/* OBSOLETE   if (op == OP_STW_LR_R22P_R0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw Ra, @@(fp,r0) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_FP_R0) */
/* OBSOLETE     return 1;			/* first arg */ */
/* OBSOLETE  */
/* OBSOLETE   /* stw Ra, @@(fp,imm) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_OP_AND_RB) == OP_STW_FP_IMM) */
/* OBSOLETE     return 1;			/* second and subsequent args */ */
/* OBSOLETE  */
/* OBSOLETE   /* stw fp,@@(sp,imm) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_STW_FP_SP_IMM) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* st2w Ra,@@(r22+,r0) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_R22P_R0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw  Ra, @@(sp-) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SPM) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* st2w  Ra, @@(sp-) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SPM) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* sub.?  sp,sp,imm */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_SUB_SP_IMM) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   return 0; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE d30v_skip_prologue (CORE_ADDR pc) */
/* OBSOLETE { */
/* OBSOLETE   unsigned long op[2]; */
/* OBSOLETE   unsigned long opl, opr;	/* left / right sub operations */ */
/* OBSOLETE   unsigned long fm0, fm1;	/* left / right mode bits */ */
/* OBSOLETE   unsigned long cc0, cc1; */
/* OBSOLETE   unsigned long op1, op2; */
/* OBSOLETE   CORE_ADDR func_addr, func_end; */
/* OBSOLETE   struct symtab_and_line sal; */
/* OBSOLETE  */
/* OBSOLETE   /* If we have line debugging information, then the end of the */ */
/* OBSOLETE   /* prologue should the first assembly instruction of  the first source line */ */
/* OBSOLETE   if (find_pc_partial_function (pc, NULL, &func_addr, &func_end)) */
/* OBSOLETE     { */
/* OBSOLETE       sal = find_pc_line (func_addr, 0); */
/* OBSOLETE       if (sal.end && sal.end < func_end) */
/* OBSOLETE 	return sal.end; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (target_read_memory (pc, (char *) &op[0], 8)) */
/* OBSOLETE     return pc;			/* Can't access it -- assume no prologue. */ */
/* OBSOLETE  */
/* OBSOLETE   while (1) */
/* OBSOLETE     { */
/* OBSOLETE       opl = (unsigned long) read_memory_integer (pc, 4); */
/* OBSOLETE       opr = (unsigned long) read_memory_integer (pc + 4, 4); */
/* OBSOLETE  */
/* OBSOLETE       fm0 = (opl & OP_MASK_FM_BIT); */
/* OBSOLETE       fm1 = (opr & OP_MASK_FM_BIT); */
/* OBSOLETE  */
/* OBSOLETE       cc0 = (opl & OP_MASK_CC_BITS); */
/* OBSOLETE       cc1 = (opr & OP_MASK_CC_BITS); */
/* OBSOLETE  */
/* OBSOLETE       opl = (opl & OP_MASK_SUB_INST); */
/* OBSOLETE       opr = (opr & OP_MASK_SUB_INST); */
/* OBSOLETE  */
/* OBSOLETE       if (fm0 && fm1) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* long instruction (opl contains the opcode) */ */
/* OBSOLETE 	  if (((opl & OP_MASK_ALL_BUT_IMM) != OP_ADD_SP_IMM) &&		/* add sp,sp,imm */ */
/* OBSOLETE 	      ((opl & OP_MASK_ALL_BUT_IMM) != OP_ADD_R22_SP_IMM) &&	/* add r22,sp,imm */ */
/* OBSOLETE 	      ((opl & OP_MASK_OP_AND_RB) != OP_STW_SP_IMM) &&	/* stw Ra, @@(sp,imm) */ */
/* OBSOLETE 	      ((opl & OP_MASK_OP_AND_RB) != OP_ST2W_SP_IMM))	/* st2w Ra, @@(sp,imm) */ */
/* OBSOLETE 	    break; */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* short instructions */ */
/* OBSOLETE 	  if (fm0 && !fm1) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      op1 = opr; */
/* OBSOLETE 	      op2 = opl; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    { */
/* OBSOLETE 	      op1 = opl; */
/* OBSOLETE 	      op2 = opr; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  if (check_prologue (op1)) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      if (!check_prologue (op2)) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  /* if the previous opcode was really part of the prologue */ */
/* OBSOLETE 		  /* and not just a NOP, then we want to break after both instructions */ */
/* OBSOLETE 		  if ((op1 & OP_MASK_OPCODE) != OP_NOP) */
/* OBSOLETE 		    pc += 8; */
/* OBSOLETE 		  break; */
/* OBSOLETE 		} */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    break; */
/* OBSOLETE 	} */
/* OBSOLETE       pc += 8; */
/* OBSOLETE     } */
/* OBSOLETE   return pc; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static int end_of_stack; */
/* OBSOLETE  */
/* OBSOLETE /* Given a GDB frame, determine the address of the calling function's frame. */
/* OBSOLETE    This will be used to create a new GDB frame struct, and then */
/* OBSOLETE    INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame. */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE d30v_frame_chain (struct frame_info *frame) */
/* OBSOLETE { */
/* OBSOLETE   struct frame_saved_regs fsr; */
/* OBSOLETE  */
/* OBSOLETE   d30v_frame_find_saved_regs (frame, &fsr); */
/* OBSOLETE  */
/* OBSOLETE   if (end_of_stack) */
/* OBSOLETE     return (CORE_ADDR) 0; */
/* OBSOLETE  */
/* OBSOLETE   if (frame->return_pc == IMEM_START) */
/* OBSOLETE     return (CORE_ADDR) 0; */
/* OBSOLETE  */
/* OBSOLETE   if (!fsr.regs[FP_REGNUM]) */
/* OBSOLETE     { */
/* OBSOLETE       if (!fsr.regs[SP_REGNUM] || fsr.regs[SP_REGNUM] == STACK_START) */
/* OBSOLETE 	return (CORE_ADDR) 0; */
/* OBSOLETE  */
/* OBSOLETE       return fsr.regs[SP_REGNUM]; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (!read_memory_unsigned_integer (fsr.regs[FP_REGNUM], 4)) */
/* OBSOLETE     return (CORE_ADDR) 0; */
/* OBSOLETE  */
/* OBSOLETE   return read_memory_unsigned_integer (fsr.regs[FP_REGNUM], 4); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static int next_addr, uses_frame; */
/* OBSOLETE static int frame_size; */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE prologue_find_regs (unsigned long op, struct frame_saved_regs *fsr, */
/* OBSOLETE 		    CORE_ADDR addr) */
/* OBSOLETE { */
/* OBSOLETE   int n; */
/* OBSOLETE   int offset; */
/* OBSOLETE  */
/* OBSOLETE   /* add sp,sp,imm -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_ADD_SP_IMM) */
/* OBSOLETE     { */
/* OBSOLETE       offset = EXTRACT_IMM6 (op); */
/* OBSOLETE       /*next_addr += offset; */ */
/* OBSOLETE       frame_size += -offset; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* add r22,sp,imm -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_ADD_R22_SP_IMM) */
/* OBSOLETE     { */
/* OBSOLETE       offset = EXTRACT_IMM6 (op); */
/* OBSOLETE       next_addr = (offset - frame_size); */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* stw Ra, @@(fp, offset) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_OP_AND_RB) == OP_STW_FP_IMM) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       offset = EXTRACT_IMM6 (op); */
/* OBSOLETE       fsr->regs[n] = (offset - frame_size); */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* stw Ra, @@(fp, r0) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_FP_R0) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = (-frame_size); */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* or  fp,0,sp -- observed */ */
/* OBSOLETE   if ((op == OP_OR_FP_R0_SP) || */
/* OBSOLETE       (op == OP_OR_FP_SP_R0) || */
/* OBSOLETE       (op == OP_OR_FP_IMM0_SP)) */
/* OBSOLETE     { */
/* OBSOLETE       uses_frame = 1; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* nop */ */
/* OBSOLETE   if ((op & OP_MASK_OPCODE) == OP_NOP) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw Ra,@@(r22+,r0) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_R22P_R0) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = next_addr; */
/* OBSOLETE       next_addr += 4; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE #if 0				/* subsumed in pattern above */ */
/* OBSOLETE   /* stw fp,@@(r22+,r0) -- observed */ */
/* OBSOLETE   if (op == OP_STW_FP_R22P_R0) */
/* OBSOLETE     { */
/* OBSOLETE       fsr->regs[FP_REGNUM] = next_addr;		/* XXX */ */
/* OBSOLETE       next_addr += 4; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* stw r62,@@(r22+,r0) -- observed */ */
/* OBSOLETE   if (op == OP_STW_LR_R22P_R0) */
/* OBSOLETE     { */
/* OBSOLETE       fsr->regs[LR_REGNUM] = next_addr; */
/* OBSOLETE       next_addr += 4; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE #endif */
/* OBSOLETE   /* st2w Ra,@@(r22+,r0) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_R22P_R0) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = next_addr; */
/* OBSOLETE       fsr->regs[n + 1] = next_addr + 4; */
/* OBSOLETE       next_addr += 8; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* stw  rn, @@(sp-) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SPM) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = next_addr; */
/* OBSOLETE       next_addr -= 4; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* st2w  Ra, @@(sp-) */ */
/* OBSOLETE   else if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SPM) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = next_addr; */
/* OBSOLETE       fsr->regs[n + 1] = next_addr + 4; */
/* OBSOLETE       next_addr -= 8; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* sub  sp,sp,imm */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_SUB_SP_IMM) */
/* OBSOLETE     { */
/* OBSOLETE       offset = EXTRACT_IMM6 (op); */
/* OBSOLETE       frame_size += -offset; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* st  rn, @@(sp,0) -- observed */ */
/* OBSOLETE   if (((op & OP_MASK_ALL_BUT_RA) == OP_STW_SP_R0) || */
/* OBSOLETE       ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SP_IMM0)) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = (-frame_size); */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* st2w  rn, @@(sp,0) */ */
/* OBSOLETE   if (((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_R0) || */
/* OBSOLETE       ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_IMM0)) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = (-frame_size); */
/* OBSOLETE       fsr->regs[n + 1] = (-frame_size) + 4; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* stw fp,@@(sp,imm) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_STW_FP_SP_IMM) */
/* OBSOLETE     { */
/* OBSOLETE       offset = EXTRACT_IMM6 (op); */
/* OBSOLETE       fsr->regs[FP_REGNUM] = (offset - frame_size); */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE   return 0; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Put here the code to store, into a struct frame_saved_regs, the */
/* OBSOLETE    addresses of the saved registers of frame described by FRAME_INFO. */
/* OBSOLETE    This includes special registers such as pc and fp saved in special */
/* OBSOLETE    ways in the stack frame.  sp is even more special: the address we */
/* OBSOLETE    return for it IS the sp for the next frame. */ */
/* OBSOLETE void */
/* OBSOLETE d30v_frame_find_saved_regs (struct frame_info *fi, struct frame_saved_regs *fsr) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR fp, pc; */
/* OBSOLETE   unsigned long opl, opr; */
/* OBSOLETE   unsigned long op1, op2; */
/* OBSOLETE   unsigned long fm0, fm1; */
/* OBSOLETE   int i; */
/* OBSOLETE  */
/* OBSOLETE   fp = fi->frame; */
/* OBSOLETE   memset (fsr, 0, sizeof (*fsr)); */
/* OBSOLETE   next_addr = 0; */
/* OBSOLETE   frame_size = 0; */
/* OBSOLETE   end_of_stack = 0; */
/* OBSOLETE  */
/* OBSOLETE   uses_frame = 0; */
/* OBSOLETE  */
/* OBSOLETE   d30v_frame_find_saved_regs_offsets (fi, fsr); */
/* OBSOLETE  */
/* OBSOLETE   fi->size = frame_size; */
/* OBSOLETE  */
/* OBSOLETE   if (!fp) */
/* OBSOLETE     fp = read_register (SP_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   for (i = 0; i < NUM_REGS - 1; i++) */
/* OBSOLETE     if (fsr->regs[i]) */
/* OBSOLETE       { */
/* OBSOLETE 	fsr->regs[i] = fsr->regs[i] + fp + frame_size; */
/* OBSOLETE       } */
/* OBSOLETE  */
/* OBSOLETE   if (fsr->regs[LR_REGNUM]) */
/* OBSOLETE     fi->return_pc = read_memory_unsigned_integer (fsr->regs[LR_REGNUM], 4); */
/* OBSOLETE   else */
/* OBSOLETE     fi->return_pc = read_register (LR_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   /* the SP is not normally (ever?) saved, but check anyway */ */
/* OBSOLETE   if (!fsr->regs[SP_REGNUM]) */
/* OBSOLETE     { */
/* OBSOLETE       /* if the FP was saved, that means the current FP is valid, */ */
/* OBSOLETE       /* otherwise, it isn't being used, so we use the SP instead */ */
/* OBSOLETE       if (uses_frame) */
/* OBSOLETE 	fsr->regs[SP_REGNUM] = read_register (FP_REGNUM) + fi->size; */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  fsr->regs[SP_REGNUM] = fp + fi->size; */
/* OBSOLETE 	  fi->frameless = 1; */
/* OBSOLETE 	  fsr->regs[FP_REGNUM] = 0; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_frame_find_saved_regs_offsets (struct frame_info *fi, */
/* OBSOLETE 				    struct frame_saved_regs *fsr) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR fp, pc; */
/* OBSOLETE   unsigned long opl, opr; */
/* OBSOLETE   unsigned long op1, op2; */
/* OBSOLETE   unsigned long fm0, fm1; */
/* OBSOLETE   int i; */
/* OBSOLETE  */
/* OBSOLETE   fp = fi->frame; */
/* OBSOLETE   memset (fsr, 0, sizeof (*fsr)); */
/* OBSOLETE   next_addr = 0; */
/* OBSOLETE   frame_size = 0; */
/* OBSOLETE   end_of_stack = 0; */
/* OBSOLETE  */
/* OBSOLETE   pc = get_pc_function_start (fi->pc); */
/* OBSOLETE  */
/* OBSOLETE   uses_frame = 0; */
/* OBSOLETE   while (pc < fi->pc) */
/* OBSOLETE     { */
/* OBSOLETE       opl = (unsigned long) read_memory_integer (pc, 4); */
/* OBSOLETE       opr = (unsigned long) read_memory_integer (pc + 4, 4); */
/* OBSOLETE  */
/* OBSOLETE       fm0 = (opl & OP_MASK_FM_BIT); */
/* OBSOLETE       fm1 = (opr & OP_MASK_FM_BIT); */
/* OBSOLETE  */
/* OBSOLETE       opl = (opl & OP_MASK_SUB_INST); */
/* OBSOLETE       opr = (opr & OP_MASK_SUB_INST); */
/* OBSOLETE  */
/* OBSOLETE       if (fm0 && fm1) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* long instruction */ */
/* OBSOLETE 	  if ((opl & OP_MASK_ALL_BUT_IMM) == OP_ADD_SP_IMM) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* add sp,sp,n */ */
/* OBSOLETE 	      long offset = EXTRACT_IMM32 (opl, opr); */
/* OBSOLETE 	      frame_size += -offset; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else if ((opl & OP_MASK_ALL_BUT_IMM) == OP_ADD_R22_SP_IMM) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* add r22,sp,offset */ */
/* OBSOLETE 	      long offset = EXTRACT_IMM32 (opl, opr); */
/* OBSOLETE 	      next_addr = (offset - frame_size); */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else if ((opl & OP_MASK_OP_AND_RB) == OP_STW_SP_IMM) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* st Ra, @@(sp,imm) */ */
/* OBSOLETE 	      long offset = EXTRACT_IMM32 (opl, opr); */
/* OBSOLETE 	      short n = EXTRACT_RA (opl); */
/* OBSOLETE 	      fsr->regs[n] = (offset - frame_size); */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else if ((opl & OP_MASK_OP_AND_RB) == OP_ST2W_SP_IMM) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* st2w Ra, @@(sp,offset) */ */
/* OBSOLETE 	      long offset = EXTRACT_IMM32 (opl, opr); */
/* OBSOLETE 	      short n = EXTRACT_RA (opl); */
/* OBSOLETE 	      fsr->regs[n] = (offset - frame_size); */
/* OBSOLETE 	      fsr->regs[n + 1] = (offset - frame_size) + 4; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else if ((opl & OP_MASK_ALL_BUT_IMM) == OP_OR_SP_R0_IMM) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      end_of_stack = 1; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    break; */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* short instructions */ */
/* OBSOLETE 	  if (fm0 && !fm1) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      op2 = opl; */
/* OBSOLETE 	      op1 = opr; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    { */
/* OBSOLETE 	      op1 = opl; */
/* OBSOLETE 	      op2 = opr; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  if (!prologue_find_regs (op1, fsr, pc) || !prologue_find_regs (op2, fsr, pc)) */
/* OBSOLETE 	    break; */
/* OBSOLETE 	} */
/* OBSOLETE       pc += 8; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE #if 0 */
/* OBSOLETE   fi->size = frame_size; */
/* OBSOLETE  */
/* OBSOLETE   if (!fp) */
/* OBSOLETE     fp = read_register (SP_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   for (i = 0; i < NUM_REGS - 1; i++) */
/* OBSOLETE     if (fsr->regs[i]) */
/* OBSOLETE       { */
/* OBSOLETE 	fsr->regs[i] = fsr->regs[i] + fp + frame_size; */
/* OBSOLETE       } */
/* OBSOLETE  */
/* OBSOLETE   if (fsr->regs[LR_REGNUM]) */
/* OBSOLETE     fi->return_pc = read_memory_unsigned_integer (fsr->regs[LR_REGNUM], 4); */
/* OBSOLETE   else */
/* OBSOLETE     fi->return_pc = read_register (LR_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   /* the SP is not normally (ever?) saved, but check anyway */ */
/* OBSOLETE   if (!fsr->regs[SP_REGNUM]) */
/* OBSOLETE     { */
/* OBSOLETE       /* if the FP was saved, that means the current FP is valid, */ */
/* OBSOLETE       /* otherwise, it isn't being used, so we use the SP instead */ */
/* OBSOLETE       if (uses_frame) */
/* OBSOLETE 	fsr->regs[SP_REGNUM] = read_register (FP_REGNUM) + fi->size; */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  fsr->regs[SP_REGNUM] = fp + fi->size; */
/* OBSOLETE 	  fi->frameless = 1; */
/* OBSOLETE 	  fsr->regs[FP_REGNUM] = 0; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE #endif */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_init_extra_frame_info (int fromleaf, struct frame_info *fi) */
/* OBSOLETE { */
/* OBSOLETE   struct frame_saved_regs dummy; */
/* OBSOLETE  */
/* OBSOLETE   if (fi->next && (fi->pc == 0)) */
/* OBSOLETE     fi->pc = fi->next->return_pc; */
/* OBSOLETE  */
/* OBSOLETE   d30v_frame_find_saved_regs_offsets (fi, &dummy); */
/* OBSOLETE  */
/* OBSOLETE   if (uses_frame == 0) */
/* OBSOLETE     fi->frameless = 1; */
/* OBSOLETE   else */
/* OBSOLETE     fi->frameless = 0; */
/* OBSOLETE  */
/* OBSOLETE   if ((fi->next == 0) && (uses_frame == 0)) */
/* OBSOLETE     /* innermost frame and it's "frameless", */
/* OBSOLETE        so the fi->frame field is wrong, fix it! */ */
/* OBSOLETE     fi->frame = read_sp (); */
/* OBSOLETE  */
/* OBSOLETE   if (dummy.regs[LR_REGNUM]) */
/* OBSOLETE     { */
/* OBSOLETE       /* it was saved, grab it! */ */
/* OBSOLETE       dummy.regs[LR_REGNUM] += (fi->frame + frame_size); */
/* OBSOLETE       fi->return_pc = read_memory_unsigned_integer (dummy.regs[LR_REGNUM], 4); */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     fi->return_pc = read_register (LR_REGNUM); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_init_frame_pc (int fromleaf, struct frame_info *prev) */
/* OBSOLETE { */
/* OBSOLETE   /* default value, put here so we can breakpoint on it and */
/* OBSOLETE      see if the default value is really the right thing to use */ */
/* OBSOLETE   prev->pc = (fromleaf ? SAVED_PC_AFTER_CALL (prev->next) : \ */
/* OBSOLETE 	      prev->next ? FRAME_SAVED_PC (prev->next) : read_pc ()); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void d30v_print_register (int regnum, int tabular); */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE d30v_print_register (int regnum, int tabular) */
/* OBSOLETE { */
/* OBSOLETE   if (regnum < A0_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       if (tabular) */
/* OBSOLETE 	printf_filtered ("%08lx", (long) read_register (regnum)); */
/* OBSOLETE       else */
/* OBSOLETE 	printf_filtered ("0x%lx	%ld", */
/* OBSOLETE 			 (long) read_register (regnum), */
/* OBSOLETE 			 (long) read_register (regnum)); */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       char regbuf[MAX_REGISTER_RAW_SIZE]; */
/* OBSOLETE  */
/* OBSOLETE       frame_register_read (selected_frame, regnum, regbuf); */
/* OBSOLETE  */
/* OBSOLETE       val_print (REGISTER_VIRTUAL_TYPE (regnum), regbuf, 0, 0, */
/* OBSOLETE 		 gdb_stdout, 'x', 1, 0, Val_pretty_default); */
/* OBSOLETE  */
/* OBSOLETE       if (!tabular) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  printf_filtered ("	"); */
/* OBSOLETE 	  val_print (REGISTER_VIRTUAL_TYPE (regnum), regbuf, 0, 0, */
/* OBSOLETE 		     gdb_stdout, 'd', 1, 0, Val_pretty_default); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE d30v_print_flags (void) */
/* OBSOLETE { */
/* OBSOLETE   long psw = read_register (PSW_REGNUM); */
/* OBSOLETE   printf_filtered ("flags #1"); */
/* OBSOLETE   printf_filtered ("   (sm) %d", (psw & PSW_SM) != 0); */
/* OBSOLETE   printf_filtered ("   (ea) %d", (psw & PSW_EA) != 0); */
/* OBSOLETE   printf_filtered ("   (db) %d", (psw & PSW_DB) != 0); */
/* OBSOLETE   printf_filtered ("   (ds) %d", (psw & PSW_DS) != 0); */
/* OBSOLETE   printf_filtered ("   (ie) %d", (psw & PSW_IE) != 0); */
/* OBSOLETE   printf_filtered ("   (rp) %d", (psw & PSW_RP) != 0); */
/* OBSOLETE   printf_filtered ("   (md) %d\n", (psw & PSW_MD) != 0); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("flags #2"); */
/* OBSOLETE   printf_filtered ("   (f0) %d", (psw & PSW_F0) != 0); */
/* OBSOLETE   printf_filtered ("   (f1) %d", (psw & PSW_F1) != 0); */
/* OBSOLETE   printf_filtered ("   (f2) %d", (psw & PSW_F2) != 0); */
/* OBSOLETE   printf_filtered ("   (f3) %d", (psw & PSW_F3) != 0); */
/* OBSOLETE   printf_filtered ("    (s) %d", (psw & PSW_S) != 0); */
/* OBSOLETE   printf_filtered ("    (v) %d", (psw & PSW_V) != 0); */
/* OBSOLETE   printf_filtered ("   (va) %d", (psw & PSW_VA) != 0); */
/* OBSOLETE   printf_filtered ("    (c) %d\n", (psw & PSW_C) != 0); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE print_flags_command (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   d30v_print_flags (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_do_registers_info (int regnum, int fpregs) */
/* OBSOLETE { */
/* OBSOLETE   long long num1, num2; */
/* OBSOLETE   long psw; */
/* OBSOLETE  */
/* OBSOLETE   if (regnum != -1) */
/* OBSOLETE     { */
/* OBSOLETE       if (REGISTER_NAME (0) == NULL || REGISTER_NAME (0)[0] == '\000') */
/* OBSOLETE 	return; */
/* OBSOLETE  */
/* OBSOLETE       printf_filtered ("%s ", REGISTER_NAME (regnum)); */
/* OBSOLETE       d30v_print_register (regnum, 0); */
/* OBSOLETE  */
/* OBSOLETE       printf_filtered ("\n"); */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Have to print all the registers.  Format them nicely.  */ */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("PC="); */
/* OBSOLETE   print_address (read_pc (), gdb_stdout); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" PSW="); */
/* OBSOLETE   d30v_print_register (PSW_REGNUM, 1); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" BPC="); */
/* OBSOLETE   print_address (read_register (BPC_REGNUM), gdb_stdout); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" BPSW="); */
/* OBSOLETE   d30v_print_register (BPSW_REGNUM, 1); */
/* OBSOLETE   printf_filtered ("\n"); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("DPC="); */
/* OBSOLETE   print_address (read_register (DPC_REGNUM), gdb_stdout); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" DPSW="); */
/* OBSOLETE   d30v_print_register (DPSW_REGNUM, 1); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" IBA="); */
/* OBSOLETE   print_address (read_register (IBA_REGNUM), gdb_stdout); */
/* OBSOLETE   printf_filtered ("\n"); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("RPT_C="); */
/* OBSOLETE   d30v_print_register (RPT_C_REGNUM, 1); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" RPT_S="); */
/* OBSOLETE   print_address (read_register (RPT_S_REGNUM), gdb_stdout); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" RPT_E="); */
/* OBSOLETE   print_address (read_register (RPT_E_REGNUM), gdb_stdout); */
/* OBSOLETE   printf_filtered ("\n"); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("MOD_S="); */
/* OBSOLETE   print_address (read_register (MOD_S_REGNUM), gdb_stdout); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" MOD_E="); */
/* OBSOLETE   print_address (read_register (MOD_E_REGNUM), gdb_stdout); */
/* OBSOLETE   printf_filtered ("\n"); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("EIT_VB="); */
/* OBSOLETE   print_address (read_register (EIT_VB_REGNUM), gdb_stdout); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" INT_S="); */
/* OBSOLETE   d30v_print_register (INT_S_REGNUM, 1); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" INT_M="); */
/* OBSOLETE   d30v_print_register (INT_M_REGNUM, 1); */
/* OBSOLETE   printf_filtered ("\n"); */
/* OBSOLETE  */
/* OBSOLETE   d30v_print_flags (); */
/* OBSOLETE   for (regnum = 0; regnum <= 63;) */
/* OBSOLETE     { */
/* OBSOLETE       int i; */
/* OBSOLETE  */
/* OBSOLETE       printf_filtered ("R%d-R%d ", regnum, regnum + 7); */
/* OBSOLETE       if (regnum < 10) */
/* OBSOLETE 	printf_filtered (" "); */
/* OBSOLETE       if (regnum + 7 < 10) */
/* OBSOLETE 	printf_filtered (" "); */
/* OBSOLETE  */
/* OBSOLETE       for (i = 0; i < 8; i++) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  printf_filtered (" "); */
/* OBSOLETE 	  d30v_print_register (regnum++, 1); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       printf_filtered ("\n"); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("A0-A1    "); */
/* OBSOLETE  */
/* OBSOLETE   d30v_print_register (A0_REGNUM, 1); */
/* OBSOLETE   printf_filtered ("    "); */
/* OBSOLETE   d30v_print_register (A1_REGNUM, 1); */
/* OBSOLETE   printf_filtered ("\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE d30v_fix_call_dummy (char *dummyname, CORE_ADDR start_sp, CORE_ADDR fun, */
/* OBSOLETE 		     int nargs, struct value **args, */
/* OBSOLETE 		     struct type *type, int gcc_p) */
/* OBSOLETE { */
/* OBSOLETE   int regnum; */
/* OBSOLETE   CORE_ADDR sp; */
/* OBSOLETE   char buffer[MAX_REGISTER_RAW_SIZE]; */
/* OBSOLETE   struct frame_info *frame = get_current_frame (); */
/* OBSOLETE   frame->dummy = start_sp; */
/* OBSOLETE   /*start_sp |= DMEM_START; */ */
/* OBSOLETE  */
/* OBSOLETE   sp = start_sp; */
/* OBSOLETE   for (regnum = 0; regnum < NUM_REGS; regnum++) */
/* OBSOLETE     { */
/* OBSOLETE       sp -= REGISTER_RAW_SIZE (regnum); */
/* OBSOLETE       store_address (buffer, REGISTER_RAW_SIZE (regnum), read_register (regnum)); */
/* OBSOLETE       write_memory (sp, buffer, REGISTER_RAW_SIZE (regnum)); */
/* OBSOLETE     } */
/* OBSOLETE   write_register (SP_REGNUM, (LONGEST) sp); */
/* OBSOLETE   /* now we need to load LR with the return address */ */
/* OBSOLETE   write_register (LR_REGNUM, (LONGEST) d30v_call_dummy_address ()); */
/* OBSOLETE   return sp; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE d30v_pop_dummy_frame (struct frame_info *fi) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR sp = fi->dummy; */
/* OBSOLETE   int regnum; */
/* OBSOLETE  */
/* OBSOLETE   for (regnum = 0; regnum < NUM_REGS; regnum++) */
/* OBSOLETE     { */
/* OBSOLETE       sp -= REGISTER_RAW_SIZE (regnum); */
/* OBSOLETE       write_register (regnum, read_memory_unsigned_integer (sp, REGISTER_RAW_SIZE (regnum))); */
/* OBSOLETE     } */
/* OBSOLETE   flush_cached_frames ();	/* needed? */ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE d30v_push_arguments (int nargs, struct value **args, CORE_ADDR sp, */
/* OBSOLETE 		     int struct_return, CORE_ADDR struct_addr) */
/* OBSOLETE { */
/* OBSOLETE   int i, len, index = 0, regnum = 2; */
/* OBSOLETE   char buffer[4], *contents; */
/* OBSOLETE   LONGEST val; */
/* OBSOLETE   CORE_ADDR ptrs[10]; */
/* OBSOLETE  */
/* OBSOLETE #if 0 */
/* OBSOLETE   /* Pass 1. Put all large args on stack */ */
/* OBSOLETE   for (i = 0; i < nargs; i++) */
/* OBSOLETE     { */
/* OBSOLETE       struct value *arg = args[i]; */
/* OBSOLETE       struct type *arg_type = check_typedef (VALUE_TYPE (arg)); */
/* OBSOLETE       len = TYPE_LENGTH (arg_type); */
/* OBSOLETE       contents = VALUE_CONTENTS (arg); */
/* OBSOLETE       val = extract_signed_integer (contents, len); */
/* OBSOLETE       if (len > 4) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* put on stack and pass pointers */ */
/* OBSOLETE 	  sp -= len; */
/* OBSOLETE 	  write_memory (sp, contents, len); */
/* OBSOLETE 	  ptrs[index++] = sp; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE #endif */
/* OBSOLETE   index = 0; */
/* OBSOLETE  */
/* OBSOLETE   for (i = 0; i < nargs; i++) */
/* OBSOLETE     { */
/* OBSOLETE       struct value *arg = args[i]; */
/* OBSOLETE       struct type *arg_type = check_typedef (VALUE_TYPE (arg)); */
/* OBSOLETE       len = TYPE_LENGTH (arg_type); */
/* OBSOLETE       contents = VALUE_CONTENTS (arg); */
/* OBSOLETE       if (len > 4) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* we need multiple registers */ */
/* OBSOLETE 	  int ndx; */
/* OBSOLETE  */
/* OBSOLETE 	  for (ndx = 0; len > 0; ndx += 8, len -= 8) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      if (regnum & 1) */
/* OBSOLETE 		regnum++;	/* all args > 4 bytes start in even register */ */
/* OBSOLETE  */
/* OBSOLETE 	      if (regnum < 18) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  val = extract_signed_integer (&contents[ndx], 4); */
/* OBSOLETE 		  write_register (regnum++, val); */
/* OBSOLETE  */
/* OBSOLETE 		  if (len >= 8) */
/* OBSOLETE 		    val = extract_signed_integer (&contents[ndx + 4], 4); */
/* OBSOLETE 		  else */
/* OBSOLETE 		    val = extract_signed_integer (&contents[ndx + 4], len - 4); */
/* OBSOLETE 		  write_register (regnum++, val); */
/* OBSOLETE 		} */
/* OBSOLETE 	      else */
/* OBSOLETE 		{ */
/* OBSOLETE 		  /* no more registers available.  put it on the stack */ */
/* OBSOLETE  */
/* OBSOLETE 		  /* all args > 4 bytes are padded to a multiple of 8 bytes */
/* OBSOLETE 		     and start on an 8 byte boundary */ */
/* OBSOLETE 		  if (sp & 7) */
/* OBSOLETE 		    sp -= (sp & 7);	/* align it */ */
/* OBSOLETE  */
/* OBSOLETE 		  sp -= ((len + 7) & ~7);	/* allocate space */ */
/* OBSOLETE 		  write_memory (sp, &contents[ndx], len); */
/* OBSOLETE 		  break; */
/* OBSOLETE 		} */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (regnum < 18) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      val = extract_signed_integer (contents, len); */
/* OBSOLETE 	      write_register (regnum++, val); */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* all args are padded to a multiple of 4 bytes (at least) */ */
/* OBSOLETE 	      sp -= ((len + 3) & ~3); */
/* OBSOLETE 	      write_memory (sp, contents, len); */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   if (sp & 7) */
/* OBSOLETE     /* stack pointer is not on an 8 byte boundary -- align it */ */
/* OBSOLETE     sp -= (sp & 7); */
/* OBSOLETE   return sp; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* pick an out-of-the-way place to set the return value */ */
/* OBSOLETE /* for an inferior function call.  The link register is set to this  */ */
/* OBSOLETE /* value and a momentary breakpoint is set there.  When the breakpoint */ */
/* OBSOLETE /* is hit, the dummy frame is popped and the previous environment is */ */
/* OBSOLETE /* restored. */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE d30v_call_dummy_address (void) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR entry; */
/* OBSOLETE   struct minimal_symbol *sym; */
/* OBSOLETE  */
/* OBSOLETE   entry = entry_point_address (); */
/* OBSOLETE  */
/* OBSOLETE   if (entry != 0) */
/* OBSOLETE     return entry; */
/* OBSOLETE  */
/* OBSOLETE   sym = lookup_minimal_symbol ("_start", NULL, symfile_objfile); */
/* OBSOLETE  */
/* OBSOLETE   if (!sym || MSYMBOL_TYPE (sym) != mst_text) */
/* OBSOLETE     return 0; */
/* OBSOLETE   else */
/* OBSOLETE     return SYMBOL_VALUE_ADDRESS (sym); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Given a return value in `regbuf' with a type `valtype',  */
/* OBSOLETE    extract and copy its value into `valbuf'.  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_extract_return_value (struct type *valtype, char regbuf[REGISTER_BYTES], */
/* OBSOLETE 			   char *valbuf) */
/* OBSOLETE { */
/* OBSOLETE   memcpy (valbuf, regbuf + REGISTER_BYTE (2), TYPE_LENGTH (valtype)); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* The following code implements access to, and display of, the D30V's */
/* OBSOLETE    instruction trace buffer.  The buffer consists of 64K or more */
/* OBSOLETE    4-byte words of data, of which each words includes an 8-bit count, */
/* OBSOLETE    an 8-bit segment number, and a 16-bit instruction address. */
/* OBSOLETE  */
/* OBSOLETE    In theory, the trace buffer is continuously capturing instruction */
/* OBSOLETE    data that the CPU presents on its "debug bus", but in practice, the */
/* OBSOLETE    ROMified GDB stub only enables tracing when it continues or steps */
/* OBSOLETE    the program, and stops tracing when the program stops; so it */
/* OBSOLETE    actually works for GDB to read the buffer counter out of memory and */
/* OBSOLETE    then read each trace word.  The counter records where the tracing */
/* OBSOLETE    stops, but there is no record of where it started, so we remember */
/* OBSOLETE    the PC when we resumed and then search backwards in the trace */
/* OBSOLETE    buffer for a word that includes that address.  This is not perfect, */
/* OBSOLETE    because you will miss trace data if the resumption PC is the target */
/* OBSOLETE    of a branch.  (The value of the buffer counter is semi-random, any */
/* OBSOLETE    trace data from a previous program stop is gone.)  */ */
/* OBSOLETE  */
/* OBSOLETE /* The address of the last word recorded in the trace buffer.  */ */
/* OBSOLETE  */
/* OBSOLETE #define DBBC_ADDR (0xd80000) */
/* OBSOLETE  */
/* OBSOLETE /* The base of the trace buffer, at least for the "Board_0".  */ */
/* OBSOLETE  */
/* OBSOLETE #define TRACE_BUFFER_BASE (0xf40000) */
/* OBSOLETE  */
/* OBSOLETE static void trace_command (char *, int); */
/* OBSOLETE  */
/* OBSOLETE static void untrace_command (char *, int); */
/* OBSOLETE  */
/* OBSOLETE static void trace_info (char *, int); */
/* OBSOLETE  */
/* OBSOLETE static void tdisassemble_command (char *, int); */
/* OBSOLETE  */
/* OBSOLETE static void display_trace (int, int); */
/* OBSOLETE  */
/* OBSOLETE /* True when instruction traces are being collected.  */ */
/* OBSOLETE  */
/* OBSOLETE static int tracing; */
/* OBSOLETE  */
/* OBSOLETE /* Remembered PC.  */ */
/* OBSOLETE  */
/* OBSOLETE static CORE_ADDR last_pc; */
/* OBSOLETE  */
/* OBSOLETE /* True when trace output should be displayed whenever program stops.  */ */
/* OBSOLETE  */
/* OBSOLETE static int trace_display; */
/* OBSOLETE  */
/* OBSOLETE /* True when trace listing should include source lines.  */ */
/* OBSOLETE  */
/* OBSOLETE static int default_trace_show_source = 1; */
/* OBSOLETE  */
/* OBSOLETE struct trace_buffer */
/* OBSOLETE   { */
/* OBSOLETE     int size; */
/* OBSOLETE     short *counts; */
/* OBSOLETE     CORE_ADDR *addrs; */
/* OBSOLETE   } */
/* OBSOLETE trace_data; */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE trace_command (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   /* Clear the host-side trace buffer, allocating space if needed.  */ */
/* OBSOLETE   trace_data.size = 0; */
/* OBSOLETE   if (trace_data.counts == NULL) */
/* OBSOLETE     trace_data.counts = (short *) xmalloc (65536 * sizeof (short)); */
/* OBSOLETE   if (trace_data.addrs == NULL) */
/* OBSOLETE     trace_data.addrs = (CORE_ADDR *) xmalloc (65536 * sizeof (CORE_ADDR)); */
/* OBSOLETE  */
/* OBSOLETE   tracing = 1; */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("Tracing is now on.\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE untrace_command (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   tracing = 0; */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("Tracing is now off.\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE trace_info (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   int i; */
/* OBSOLETE  */
/* OBSOLETE   if (trace_data.size) */
/* OBSOLETE     { */
/* OBSOLETE       printf_filtered ("%d entries in trace buffer:\n", trace_data.size); */
/* OBSOLETE  */
/* OBSOLETE       for (i = 0; i < trace_data.size; ++i) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  printf_filtered ("%d: %d instruction%s at 0x%s\n", */
/* OBSOLETE 			   i, trace_data.counts[i], */
/* OBSOLETE 			   (trace_data.counts[i] == 1 ? "" : "s"), */
/* OBSOLETE 			   paddr_nz (trace_data.addrs[i])); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     printf_filtered ("No entries in trace buffer.\n"); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("Tracing is currently %s.\n", (tracing ? "on" : "off")); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Print the instruction at address MEMADDR in debugged memory, */
/* OBSOLETE    on STREAM.  Returns length of the instruction, in bytes.  */ */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE print_insn (CORE_ADDR memaddr, struct ui_file *stream) */
/* OBSOLETE { */
/* OBSOLETE   /* If there's no disassembler, something is very wrong.  */ */
/* OBSOLETE   if (tm_print_insn == NULL) */
/* OBSOLETE     internal_error (__FILE__, __LINE__, */
/* OBSOLETE 		    "print_insn: no disassembler"); */
/* OBSOLETE  */
/* OBSOLETE   if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG) */
/* OBSOLETE     tm_print_insn_info.endian = BFD_ENDIAN_BIG; */
/* OBSOLETE   else */
/* OBSOLETE     tm_print_insn_info.endian = BFD_ENDIAN_LITTLE; */
/* OBSOLETE   return TARGET_PRINT_INSN (memaddr, &tm_print_insn_info); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_eva_prepare_to_trace (void) */
/* OBSOLETE { */
/* OBSOLETE   if (!tracing) */
/* OBSOLETE     return; */
/* OBSOLETE  */
/* OBSOLETE   last_pc = read_register (PC_REGNUM); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Collect trace data from the target board and format it into a form */
/* OBSOLETE    more useful for display.  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_eva_get_trace_data (void) */
/* OBSOLETE { */
/* OBSOLETE   int count, i, j, oldsize; */
/* OBSOLETE   int trace_addr, trace_seg, trace_cnt, next_cnt; */
/* OBSOLETE   unsigned int last_trace, trace_word, next_word; */
/* OBSOLETE   unsigned int *tmpspace; */
/* OBSOLETE  */
/* OBSOLETE   if (!tracing) */
/* OBSOLETE     return; */
/* OBSOLETE  */
/* OBSOLETE   tmpspace = xmalloc (65536 * sizeof (unsigned int)); */
/* OBSOLETE  */
/* OBSOLETE   last_trace = read_memory_unsigned_integer (DBBC_ADDR, 2) << 2; */
/* OBSOLETE  */
/* OBSOLETE   /* Collect buffer contents from the target, stopping when we reach */
/* OBSOLETE      the word recorded when execution resumed.  */ */
/* OBSOLETE  */
/* OBSOLETE   count = 0; */
/* OBSOLETE   while (last_trace > 0) */
/* OBSOLETE     { */
/* OBSOLETE       QUIT; */
/* OBSOLETE       trace_word = */
/* OBSOLETE 	read_memory_unsigned_integer (TRACE_BUFFER_BASE + last_trace, 4); */
/* OBSOLETE       trace_addr = trace_word & 0xffff; */
/* OBSOLETE       last_trace -= 4; */
/* OBSOLETE       /* Ignore an apparently nonsensical entry.  */ */
/* OBSOLETE       if (trace_addr == 0xffd5) */
/* OBSOLETE 	continue; */
/* OBSOLETE       tmpspace[count++] = trace_word; */
/* OBSOLETE       if (trace_addr == last_pc) */
/* OBSOLETE 	break; */
/* OBSOLETE       if (count > 65535) */
/* OBSOLETE 	break; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Move the data to the host-side trace buffer, adjusting counts to */
/* OBSOLETE      include the last instruction executed and transforming the address */
/* OBSOLETE      into something that GDB likes.  */ */
/* OBSOLETE  */
/* OBSOLETE   for (i = 0; i < count; ++i) */
/* OBSOLETE     { */
/* OBSOLETE       trace_word = tmpspace[i]; */
/* OBSOLETE       next_word = ((i == 0) ? 0 : tmpspace[i - 1]); */
/* OBSOLETE       trace_addr = trace_word & 0xffff; */
/* OBSOLETE       next_cnt = (next_word >> 24) & 0xff; */
/* OBSOLETE       j = trace_data.size + count - i - 1; */
/* OBSOLETE       trace_data.addrs[j] = (trace_addr << 2) + 0x1000000; */
/* OBSOLETE       trace_data.counts[j] = next_cnt + 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   oldsize = trace_data.size; */
/* OBSOLETE   trace_data.size += count; */
/* OBSOLETE  */
/* OBSOLETE   xfree (tmpspace); */
/* OBSOLETE  */
/* OBSOLETE   if (trace_display) */
/* OBSOLETE     display_trace (oldsize, trace_data.size); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE tdisassemble_command (char *arg, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   int i, count; */
/* OBSOLETE   CORE_ADDR low, high; */
/* OBSOLETE   char *space_index; */
/* OBSOLETE  */
/* OBSOLETE   if (!arg) */
/* OBSOLETE     { */
/* OBSOLETE       low = 0; */
/* OBSOLETE       high = trace_data.size; */
/* OBSOLETE     } */
/* OBSOLETE   else if (!(space_index = (char *) strchr (arg, ' '))) */
/* OBSOLETE     { */
/* OBSOLETE       low = parse_and_eval_address (arg); */
/* OBSOLETE       high = low + 5; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       /* Two arguments.  */ */
/* OBSOLETE       *space_index = '\0'; */
/* OBSOLETE       low = parse_and_eval_address (arg); */
/* OBSOLETE       high = parse_and_eval_address (space_index + 1); */
/* OBSOLETE       if (high < low) */
/* OBSOLETE 	high = low; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("Dump of trace from %s to %s:\n", */
/* OBSOLETE 		   paddr_u (low), */
/* OBSOLETE 		   paddr_u (high)); */
/* OBSOLETE  */
/* OBSOLETE   display_trace (low, high); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("End of trace dump.\n"); */
/* OBSOLETE   gdb_flush (gdb_stdout); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE display_trace (int low, int high) */
/* OBSOLETE { */
/* OBSOLETE   int i, count, trace_show_source, first, suppress; */
/* OBSOLETE   CORE_ADDR next_address; */
/* OBSOLETE  */
/* OBSOLETE   trace_show_source = default_trace_show_source; */
/* OBSOLETE   if (!have_full_symbols () && !have_partial_symbols ()) */
/* OBSOLETE     { */
/* OBSOLETE       trace_show_source = 0; */
/* OBSOLETE       printf_filtered ("No symbol table is loaded.  Use the \"file\" command.\n"); */
/* OBSOLETE       printf_filtered ("Trace will not display any source.\n"); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   first = 1; */
/* OBSOLETE   suppress = 0; */
/* OBSOLETE   for (i = low; i < high; ++i) */
/* OBSOLETE     { */
/* OBSOLETE       next_address = trace_data.addrs[i]; */
/* OBSOLETE       count = trace_data.counts[i]; */
/* OBSOLETE       while (count-- > 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  QUIT; */
/* OBSOLETE 	  if (trace_show_source) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      struct symtab_and_line sal, sal_prev; */
/* OBSOLETE  */
/* OBSOLETE 	      sal_prev = find_pc_line (next_address - 4, 0); */
/* OBSOLETE 	      sal = find_pc_line (next_address, 0); */
/* OBSOLETE  */
/* OBSOLETE 	      if (sal.symtab) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  if (first || sal.line != sal_prev.line) */
/* OBSOLETE 		    print_source_lines (sal.symtab, sal.line, sal.line + 1, 0); */
/* OBSOLETE 		  suppress = 0; */
/* OBSOLETE 		} */
/* OBSOLETE 	      else */
/* OBSOLETE 		{ */
/* OBSOLETE 		  if (!suppress) */
/* OBSOLETE 		    /* FIXME-32x64--assumes sal.pc fits in long.  */ */
/* OBSOLETE 		    printf_filtered ("No source file for address %s.\n", */
/* OBSOLETE 				 local_hex_string ((unsigned long) sal.pc)); */
/* OBSOLETE 		  suppress = 1; */
/* OBSOLETE 		} */
/* OBSOLETE 	    } */
/* OBSOLETE 	  first = 0; */
/* OBSOLETE 	  print_address (next_address, gdb_stdout); */
/* OBSOLETE 	  printf_filtered (":"); */
/* OBSOLETE 	  printf_filtered ("\t"); */
/* OBSOLETE 	  wrap_here ("    "); */
/* OBSOLETE 	  next_address = next_address + print_insn (next_address, gdb_stdout); */
/* OBSOLETE 	  printf_filtered ("\n"); */
/* OBSOLETE 	  gdb_flush (gdb_stdout); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE extern void (*target_resume_hook) (void); */
/* OBSOLETE extern void (*target_wait_loop_hook) (void); */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE _initialize_d30v_tdep (void) */
/* OBSOLETE { */
/* OBSOLETE   tm_print_insn = print_insn_d30v; */
/* OBSOLETE  */
/* OBSOLETE   target_resume_hook = d30v_eva_prepare_to_trace; */
/* OBSOLETE   target_wait_loop_hook = d30v_eva_get_trace_data; */
/* OBSOLETE  */
/* OBSOLETE   add_info ("flags", print_flags_command, "Print d30v flags."); */
/* OBSOLETE  */
/* OBSOLETE   add_com ("trace", class_support, trace_command, */
/* OBSOLETE 	   "Enable tracing of instruction execution."); */
/* OBSOLETE  */
/* OBSOLETE   add_com ("untrace", class_support, untrace_command, */
/* OBSOLETE 	   "Disable tracing of instruction execution."); */
/* OBSOLETE  */
/* OBSOLETE   add_com ("tdisassemble", class_vars, tdisassemble_command, */
/* OBSOLETE 	   "Disassemble the trace buffer.\n\ */
/* OBSOLETE Two optional arguments specify a range of trace buffer entries\n\ */
/* OBSOLETE as reported by info trace (NOT addresses!)."); */
/* OBSOLETE  */
/* OBSOLETE   add_info ("trace", trace_info, */
/* OBSOLETE 	    "Display info about the trace data buffer."); */
/* OBSOLETE  */
/* OBSOLETE   add_show_from_set (add_set_cmd ("tracedisplay", no_class, */
/* OBSOLETE 				  var_integer, (char *) &trace_display, */
/* OBSOLETE 			     "Set automatic display of trace.\n", &setlist), */
/* OBSOLETE 		     &showlist); */
/* OBSOLETE   add_show_from_set (add_set_cmd ("tracesource", no_class, */
/* OBSOLETE 			   var_integer, (char *) &default_trace_show_source, */
/* OBSOLETE 		      "Set display of source code with trace.\n", &setlist), */
/* OBSOLETE 		     &showlist); */
/* OBSOLETE  */
/* OBSOLETE } */
@


1.14
log
@Obsolete the d30v.
@
text
@@


1.14.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.14.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.13
log
@* defs.h (read_relative_register_raw_bytes): Delete declaration.
* frame.c (frame_register_read): New function.  Return non-zero on
success.
(read_relative_register_raw_bytes_for_frame): Delete.
(read_relative_register_raw_bytes): Delete.
* frame.h (frame_register_read): Declare.
* d30v-tdep.c: Update Copyright.  Use frame_register_read.
* sh-tdep.c: Ditto.
* infcmd.c (do_registers_info): Ditto.
* hppa-tdep.c: Ditto.
* rs6000-tdep.c: Ditto.
* h8500-tdep.c: Ditto.
* mips-tdep.c: Ditto.
* h8300-tdep.c: Ditto.
* z8k-tdep.c: Ditto.
@
text
@d1 1365
a1365 1365
/* Target-dependent code for Mitsubishi D30V, for GDB.

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software
   Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/*  Contributed by Martin Hunt, hunt@@cygnus.com */

#include "defs.h"
#include "frame.h"
#include "obstack.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "gdb_string.h"
#include "value.h"
#include "inferior.h"
#include "dis-asm.h"
#include "symfile.h"
#include "objfiles.h"
#include "regcache.h"

#include "language.h" /* For local_hex_string() */

void d30v_frame_find_saved_regs (struct frame_info *fi,
				 struct frame_saved_regs *fsr);
void d30v_frame_find_saved_regs_offsets (struct frame_info *fi,
					 struct frame_saved_regs *fsr);
static void d30v_pop_dummy_frame (struct frame_info *fi);
static void d30v_print_flags (void);
static void print_flags_command (char *, int);

/* the following defines assume:
   fp is r61, lr is r62, sp is r63, and ?? is r22
   if that changes, they will need to be updated */

#define OP_MASK_ALL_BUT_RA	0x0ffc0fff	/* throw away Ra, keep the rest */

#define OP_STW_SPM		0x054c0fc0	/* stw Ra, @@(sp-) */
#define OP_STW_SP_R0		0x05400fc0	/* stw Ra, @@(sp,r0) */
#define OP_STW_SP_IMM0		0x05480fc0	/* st Ra, @@(sp, 0x0) */
#define OP_STW_R22P_R0		0x05440580	/* stw Ra, @@(r22+,r0) */

#define OP_ST2W_SPM		0x056c0fc0	/* st2w Ra, @@(sp-) */
#define OP_ST2W_SP_R0		0x05600fc0	/* st2w Ra, @@(sp, r0) */
#define OP_ST2W_SP_IMM0		0x05680fc0	/* st2w Ra, @@(sp, 0x0) */
#define OP_ST2W_R22P_R0		0x05640580	/* st2w Ra, @@(r22+, r0) */

#define OP_MASK_OPCODE		0x0ffc0000	/* just the opcode, ign operands */
#define OP_NOP			0x00f00000	/* nop */

#define OP_MASK_ALL_BUT_IMM	0x0fffffc0	/* throw away imm, keep the rest */
#define OP_SUB_SP_IMM		0x082bffc0	/* sub sp,sp,imm */
#define OP_ADD_SP_IMM		0x080bffc0	/* add sp,sp,imm */
#define OP_ADD_R22_SP_IMM	0x08096fc0	/* add r22,sp,imm */
#define OP_STW_FP_SP_IMM	0x054bdfc0	/* stw fp,@@(sp,imm) */
#define OP_OR_SP_R0_IMM		0x03abf000	/* or sp,r0,imm */

/* no mask */
#define OP_OR_FP_R0_SP		0x03a3d03f	/* or fp,r0,sp */
#define OP_OR_FP_SP_R0		0x03a3dfc0	/* or fp,sp,r0 */
#define OP_OR_FP_IMM0_SP	0x03abd03f	/* or fp,0x0,sp */
#define OP_STW_FP_R22P_R0	0x0547d580	/* stw fp,@@(r22+,r0) */
#define OP_STW_LR_R22P_R0	0x0547e580	/* stw lr,@@(r22+,r0) */

#define OP_MASK_OP_AND_RB	0x0ff80fc0	/* keep op and rb,throw away rest */
#define OP_STW_SP_IMM		0x05480fc0	/* stw Ra,@@(sp,imm) */
#define OP_ST2W_SP_IMM		0x05680fc0	/* st2w Ra,@@(sp,imm) */
#define OP_STW_FP_IMM		0x05480f40	/* stw Ra,@@(fp,imm) */
#define OP_STW_FP_R0		0x05400f40	/* stw Ra,@@(fp,r0) */

#define OP_MASK_FM_BIT		0x80000000
#define OP_MASK_CC_BITS		0x70000000
#define OP_MASK_SUB_INST	0x0fffffff

#define EXTRACT_RA(op)		(((op) >> 12) & 0x3f)
#define EXTRACT_RB(op)		(((op) >> 6) & 0x3f)
#define EXTRACT_RC(op)		(((op) & 0x3f)
#define EXTRACT_UIMM6(op)	((op) & 0x3f)
#define EXTRACT_IMM6(op)	((((int)EXTRACT_UIMM6(op)) << 26) >> 26)
#define EXTRACT_IMM26(op)	((((op)&0x0ff00000) >> 2) | ((op)&0x0003ffff))
#define EXTRACT_IMM32(opl, opr)	((EXTRACT_UIMM6(opl) << 26)|EXTRACT_IMM26(opr))


int
d30v_frame_chain_valid (CORE_ADDR chain, struct frame_info *fi)
{
#if 0
  return ((chain) != 0 && (fi) != 0 && (fi)->return_pc != 0);
#else
  return ((chain) != 0 && (fi) != 0 && (fi)->frame <= chain);
#endif
}

/* Discard from the stack the innermost frame, restoring all saved
   registers.  */

void
d30v_pop_frame (void)
{
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR fp;
  int regnum;
  struct frame_saved_regs fsr;
  char raw_buffer[8];

  fp = FRAME_FP (frame);
  if (frame->dummy)
    {
      d30v_pop_dummy_frame (frame);
      return;
    }

  /* fill out fsr with the address of where each */
  /* register was stored in the frame */
  get_frame_saved_regs (frame, &fsr);

  /* now update the current registers with the old values */
  for (regnum = A0_REGNUM; regnum < A0_REGNUM + 2; regnum++)
    {
      if (fsr.regs[regnum])
	{
	  read_memory (fsr.regs[regnum], raw_buffer, 8);
	  write_register_bytes (REGISTER_BYTE (regnum), raw_buffer, 8);
	}
    }
  for (regnum = 0; regnum < SP_REGNUM; regnum++)
    {
      if (fsr.regs[regnum])
	{
	  write_register (regnum, read_memory_unsigned_integer (fsr.regs[regnum], 4));
	}
    }
  if (fsr.regs[PSW_REGNUM])
    {
      write_register (PSW_REGNUM, read_memory_unsigned_integer (fsr.regs[PSW_REGNUM], 4));
    }

  write_register (PC_REGNUM, read_register (LR_REGNUM));
  write_register (SP_REGNUM, fp + frame->size);
  target_store_registers (-1);
  flush_cached_frames ();
}

static int
check_prologue (unsigned long op)
{
  /* add sp,sp,imm -- observed */
  if ((op & OP_MASK_ALL_BUT_IMM) == OP_ADD_SP_IMM)
    return 1;

  /* add r22,sp,imm -- observed */
  if ((op & OP_MASK_ALL_BUT_IMM) == OP_ADD_R22_SP_IMM)
    return 1;

  /* or  fp,r0,sp -- observed */
  if (op == OP_OR_FP_R0_SP)
    return 1;

  /* nop */
  if ((op & OP_MASK_OPCODE) == OP_NOP)
    return 1;

  /* stw  Ra,@@(sp,r0) */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SP_R0)
    return 1;

  /* stw  Ra,@@(sp,0x0) */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SP_IMM0)
    return 1;

  /* st2w  Ra,@@(sp,r0) */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_R0)
    return 1;

  /* st2w  Ra,@@(sp,0x0) */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_IMM0)
    return 1;

  /* stw fp, @@(r22+,r0) -- observed */
  if (op == OP_STW_FP_R22P_R0)
    return 1;

  /* stw r62, @@(r22+,r0) -- observed */
  if (op == OP_STW_LR_R22P_R0)
    return 1;

  /* stw Ra, @@(fp,r0) -- observed */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_FP_R0)
    return 1;			/* first arg */

  /* stw Ra, @@(fp,imm) -- observed */
  if ((op & OP_MASK_OP_AND_RB) == OP_STW_FP_IMM)
    return 1;			/* second and subsequent args */

  /* stw fp,@@(sp,imm) -- observed */
  if ((op & OP_MASK_ALL_BUT_IMM) == OP_STW_FP_SP_IMM)
    return 1;

  /* st2w Ra,@@(r22+,r0) */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_R22P_R0)
    return 1;

  /* stw  Ra, @@(sp-) */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SPM)
    return 1;

  /* st2w  Ra, @@(sp-) */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SPM)
    return 1;

  /* sub.?  sp,sp,imm */
  if ((op & OP_MASK_ALL_BUT_IMM) == OP_SUB_SP_IMM)
    return 1;

  return 0;
}

CORE_ADDR
d30v_skip_prologue (CORE_ADDR pc)
{
  unsigned long op[2];
  unsigned long opl, opr;	/* left / right sub operations */
  unsigned long fm0, fm1;	/* left / right mode bits */
  unsigned long cc0, cc1;
  unsigned long op1, op2;
  CORE_ADDR func_addr, func_end;
  struct symtab_and_line sal;

  /* If we have line debugging information, then the end of the */
  /* prologue should the first assembly instruction of  the first source line */
  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      sal = find_pc_line (func_addr, 0);
      if (sal.end && sal.end < func_end)
	return sal.end;
    }

  if (target_read_memory (pc, (char *) &op[0], 8))
    return pc;			/* Can't access it -- assume no prologue. */

  while (1)
    {
      opl = (unsigned long) read_memory_integer (pc, 4);
      opr = (unsigned long) read_memory_integer (pc + 4, 4);

      fm0 = (opl & OP_MASK_FM_BIT);
      fm1 = (opr & OP_MASK_FM_BIT);

      cc0 = (opl & OP_MASK_CC_BITS);
      cc1 = (opr & OP_MASK_CC_BITS);

      opl = (opl & OP_MASK_SUB_INST);
      opr = (opr & OP_MASK_SUB_INST);

      if (fm0 && fm1)
	{
	  /* long instruction (opl contains the opcode) */
	  if (((opl & OP_MASK_ALL_BUT_IMM) != OP_ADD_SP_IMM) &&		/* add sp,sp,imm */
	      ((opl & OP_MASK_ALL_BUT_IMM) != OP_ADD_R22_SP_IMM) &&	/* add r22,sp,imm */
	      ((opl & OP_MASK_OP_AND_RB) != OP_STW_SP_IMM) &&	/* stw Ra, @@(sp,imm) */
	      ((opl & OP_MASK_OP_AND_RB) != OP_ST2W_SP_IMM))	/* st2w Ra, @@(sp,imm) */
	    break;
	}
      else
	{
	  /* short instructions */
	  if (fm0 && !fm1)
	    {
	      op1 = opr;
	      op2 = opl;
	    }
	  else
	    {
	      op1 = opl;
	      op2 = opr;
	    }
	  if (check_prologue (op1))
	    {
	      if (!check_prologue (op2))
		{
		  /* if the previous opcode was really part of the prologue */
		  /* and not just a NOP, then we want to break after both instructions */
		  if ((op1 & OP_MASK_OPCODE) != OP_NOP)
		    pc += 8;
		  break;
		}
	    }
	  else
	    break;
	}
      pc += 8;
    }
  return pc;
}

static int end_of_stack;

/* Given a GDB frame, determine the address of the calling function's frame.
   This will be used to create a new GDB frame struct, and then
   INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.
 */

CORE_ADDR
d30v_frame_chain (struct frame_info *frame)
{
  struct frame_saved_regs fsr;

  d30v_frame_find_saved_regs (frame, &fsr);

  if (end_of_stack)
    return (CORE_ADDR) 0;

  if (frame->return_pc == IMEM_START)
    return (CORE_ADDR) 0;

  if (!fsr.regs[FP_REGNUM])
    {
      if (!fsr.regs[SP_REGNUM] || fsr.regs[SP_REGNUM] == STACK_START)
	return (CORE_ADDR) 0;

      return fsr.regs[SP_REGNUM];
    }

  if (!read_memory_unsigned_integer (fsr.regs[FP_REGNUM], 4))
    return (CORE_ADDR) 0;

  return read_memory_unsigned_integer (fsr.regs[FP_REGNUM], 4);
}

static int next_addr, uses_frame;
static int frame_size;

static int
prologue_find_regs (unsigned long op, struct frame_saved_regs *fsr,
		    CORE_ADDR addr)
{
  int n;
  int offset;

  /* add sp,sp,imm -- observed */
  if ((op & OP_MASK_ALL_BUT_IMM) == OP_ADD_SP_IMM)
    {
      offset = EXTRACT_IMM6 (op);
      /*next_addr += offset; */
      frame_size += -offset;
      return 1;
    }

  /* add r22,sp,imm -- observed */
  if ((op & OP_MASK_ALL_BUT_IMM) == OP_ADD_R22_SP_IMM)
    {
      offset = EXTRACT_IMM6 (op);
      next_addr = (offset - frame_size);
      return 1;
    }

  /* stw Ra, @@(fp, offset) -- observed */
  if ((op & OP_MASK_OP_AND_RB) == OP_STW_FP_IMM)
    {
      n = EXTRACT_RA (op);
      offset = EXTRACT_IMM6 (op);
      fsr->regs[n] = (offset - frame_size);
      return 1;
    }

  /* stw Ra, @@(fp, r0) -- observed */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_FP_R0)
    {
      n = EXTRACT_RA (op);
      fsr->regs[n] = (-frame_size);
      return 1;
    }

  /* or  fp,0,sp -- observed */
  if ((op == OP_OR_FP_R0_SP) ||
      (op == OP_OR_FP_SP_R0) ||
      (op == OP_OR_FP_IMM0_SP))
    {
      uses_frame = 1;
      return 1;
    }

  /* nop */
  if ((op & OP_MASK_OPCODE) == OP_NOP)
    return 1;

  /* stw Ra,@@(r22+,r0) -- observed */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_R22P_R0)
    {
      n = EXTRACT_RA (op);
      fsr->regs[n] = next_addr;
      next_addr += 4;
      return 1;
    }
#if 0				/* subsumed in pattern above */
  /* stw fp,@@(r22+,r0) -- observed */
  if (op == OP_STW_FP_R22P_R0)
    {
      fsr->regs[FP_REGNUM] = next_addr;		/* XXX */
      next_addr += 4;
      return 1;
    }

  /* stw r62,@@(r22+,r0) -- observed */
  if (op == OP_STW_LR_R22P_R0)
    {
      fsr->regs[LR_REGNUM] = next_addr;
      next_addr += 4;
      return 1;
    }
#endif
  /* st2w Ra,@@(r22+,r0) -- observed */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_R22P_R0)
    {
      n = EXTRACT_RA (op);
      fsr->regs[n] = next_addr;
      fsr->regs[n + 1] = next_addr + 4;
      next_addr += 8;
      return 1;
    }

  /* stw  rn, @@(sp-) */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SPM)
    {
      n = EXTRACT_RA (op);
      fsr->regs[n] = next_addr;
      next_addr -= 4;
      return 1;
    }

  /* st2w  Ra, @@(sp-) */
  else if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SPM)
    {
      n = EXTRACT_RA (op);
      fsr->regs[n] = next_addr;
      fsr->regs[n + 1] = next_addr + 4;
      next_addr -= 8;
      return 1;
    }

  /* sub  sp,sp,imm */
  if ((op & OP_MASK_ALL_BUT_IMM) == OP_SUB_SP_IMM)
    {
      offset = EXTRACT_IMM6 (op);
      frame_size += -offset;
      return 1;
    }

  /* st  rn, @@(sp,0) -- observed */
  if (((op & OP_MASK_ALL_BUT_RA) == OP_STW_SP_R0) ||
      ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SP_IMM0))
    {
      n = EXTRACT_RA (op);
      fsr->regs[n] = (-frame_size);
      return 1;
    }

  /* st2w  rn, @@(sp,0) */
  if (((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_R0) ||
      ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_IMM0))
    {
      n = EXTRACT_RA (op);
      fsr->regs[n] = (-frame_size);
      fsr->regs[n + 1] = (-frame_size) + 4;
      return 1;
    }

  /* stw fp,@@(sp,imm) -- observed */
  if ((op & OP_MASK_ALL_BUT_IMM) == OP_STW_FP_SP_IMM)
    {
      offset = EXTRACT_IMM6 (op);
      fsr->regs[FP_REGNUM] = (offset - frame_size);
      return 1;
    }
  return 0;
}

/* Put here the code to store, into a struct frame_saved_regs, the
   addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special: the address we
   return for it IS the sp for the next frame. */
void
d30v_frame_find_saved_regs (struct frame_info *fi, struct frame_saved_regs *fsr)
{
  CORE_ADDR fp, pc;
  unsigned long opl, opr;
  unsigned long op1, op2;
  unsigned long fm0, fm1;
  int i;

  fp = fi->frame;
  memset (fsr, 0, sizeof (*fsr));
  next_addr = 0;
  frame_size = 0;
  end_of_stack = 0;

  uses_frame = 0;

  d30v_frame_find_saved_regs_offsets (fi, fsr);

  fi->size = frame_size;

  if (!fp)
    fp = read_register (SP_REGNUM);

  for (i = 0; i < NUM_REGS - 1; i++)
    if (fsr->regs[i])
      {
	fsr->regs[i] = fsr->regs[i] + fp + frame_size;
      }

  if (fsr->regs[LR_REGNUM])
    fi->return_pc = read_memory_unsigned_integer (fsr->regs[LR_REGNUM], 4);
  else
    fi->return_pc = read_register (LR_REGNUM);

  /* the SP is not normally (ever?) saved, but check anyway */
  if (!fsr->regs[SP_REGNUM])
    {
      /* if the FP was saved, that means the current FP is valid, */
      /* otherwise, it isn't being used, so we use the SP instead */
      if (uses_frame)
	fsr->regs[SP_REGNUM] = read_register (FP_REGNUM) + fi->size;
      else
	{
	  fsr->regs[SP_REGNUM] = fp + fi->size;
	  fi->frameless = 1;
	  fsr->regs[FP_REGNUM] = 0;
	}
    }
}

void
d30v_frame_find_saved_regs_offsets (struct frame_info *fi,
				    struct frame_saved_regs *fsr)
{
  CORE_ADDR fp, pc;
  unsigned long opl, opr;
  unsigned long op1, op2;
  unsigned long fm0, fm1;
  int i;

  fp = fi->frame;
  memset (fsr, 0, sizeof (*fsr));
  next_addr = 0;
  frame_size = 0;
  end_of_stack = 0;

  pc = get_pc_function_start (fi->pc);

  uses_frame = 0;
  while (pc < fi->pc)
    {
      opl = (unsigned long) read_memory_integer (pc, 4);
      opr = (unsigned long) read_memory_integer (pc + 4, 4);

      fm0 = (opl & OP_MASK_FM_BIT);
      fm1 = (opr & OP_MASK_FM_BIT);

      opl = (opl & OP_MASK_SUB_INST);
      opr = (opr & OP_MASK_SUB_INST);

      if (fm0 && fm1)
	{
	  /* long instruction */
	  if ((opl & OP_MASK_ALL_BUT_IMM) == OP_ADD_SP_IMM)
	    {
	      /* add sp,sp,n */
	      long offset = EXTRACT_IMM32 (opl, opr);
	      frame_size += -offset;
	    }
	  else if ((opl & OP_MASK_ALL_BUT_IMM) == OP_ADD_R22_SP_IMM)
	    {
	      /* add r22,sp,offset */
	      long offset = EXTRACT_IMM32 (opl, opr);
	      next_addr = (offset - frame_size);
	    }
	  else if ((opl & OP_MASK_OP_AND_RB) == OP_STW_SP_IMM)
	    {
	      /* st Ra, @@(sp,imm) */
	      long offset = EXTRACT_IMM32 (opl, opr);
	      short n = EXTRACT_RA (opl);
	      fsr->regs[n] = (offset - frame_size);
	    }
	  else if ((opl & OP_MASK_OP_AND_RB) == OP_ST2W_SP_IMM)
	    {
	      /* st2w Ra, @@(sp,offset) */
	      long offset = EXTRACT_IMM32 (opl, opr);
	      short n = EXTRACT_RA (opl);
	      fsr->regs[n] = (offset - frame_size);
	      fsr->regs[n + 1] = (offset - frame_size) + 4;
	    }
	  else if ((opl & OP_MASK_ALL_BUT_IMM) == OP_OR_SP_R0_IMM)
	    {
	      end_of_stack = 1;
	    }
	  else
	    break;
	}
      else
	{
	  /* short instructions */
	  if (fm0 && !fm1)
	    {
	      op2 = opl;
	      op1 = opr;
	    }
	  else
	    {
	      op1 = opl;
	      op2 = opr;
	    }
	  if (!prologue_find_regs (op1, fsr, pc) || !prologue_find_regs (op2, fsr, pc))
	    break;
	}
      pc += 8;
    }

#if 0
  fi->size = frame_size;

  if (!fp)
    fp = read_register (SP_REGNUM);

  for (i = 0; i < NUM_REGS - 1; i++)
    if (fsr->regs[i])
      {
	fsr->regs[i] = fsr->regs[i] + fp + frame_size;
      }

  if (fsr->regs[LR_REGNUM])
    fi->return_pc = read_memory_unsigned_integer (fsr->regs[LR_REGNUM], 4);
  else
    fi->return_pc = read_register (LR_REGNUM);

  /* the SP is not normally (ever?) saved, but check anyway */
  if (!fsr->regs[SP_REGNUM])
    {
      /* if the FP was saved, that means the current FP is valid, */
      /* otherwise, it isn't being used, so we use the SP instead */
      if (uses_frame)
	fsr->regs[SP_REGNUM] = read_register (FP_REGNUM) + fi->size;
      else
	{
	  fsr->regs[SP_REGNUM] = fp + fi->size;
	  fi->frameless = 1;
	  fsr->regs[FP_REGNUM] = 0;
	}
    }
#endif
}

void
d30v_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  struct frame_saved_regs dummy;

  if (fi->next && (fi->pc == 0))
    fi->pc = fi->next->return_pc;

  d30v_frame_find_saved_regs_offsets (fi, &dummy);

  if (uses_frame == 0)
    fi->frameless = 1;
  else
    fi->frameless = 0;

  if ((fi->next == 0) && (uses_frame == 0))
    /* innermost frame and it's "frameless",
       so the fi->frame field is wrong, fix it! */
    fi->frame = read_sp ();

  if (dummy.regs[LR_REGNUM])
    {
      /* it was saved, grab it! */
      dummy.regs[LR_REGNUM] += (fi->frame + frame_size);
      fi->return_pc = read_memory_unsigned_integer (dummy.regs[LR_REGNUM], 4);
    }
  else
    fi->return_pc = read_register (LR_REGNUM);
}

void
d30v_init_frame_pc (int fromleaf, struct frame_info *prev)
{
  /* default value, put here so we can breakpoint on it and
     see if the default value is really the right thing to use */
  prev->pc = (fromleaf ? SAVED_PC_AFTER_CALL (prev->next) : \
	      prev->next ? FRAME_SAVED_PC (prev->next) : read_pc ());
}

static void d30v_print_register (int regnum, int tabular);

static void
d30v_print_register (int regnum, int tabular)
{
  if (regnum < A0_REGNUM)
    {
      if (tabular)
	printf_filtered ("%08lx", (long) read_register (regnum));
      else
	printf_filtered ("0x%lx	%ld",
			 (long) read_register (regnum),
			 (long) read_register (regnum));
    }
  else
    {
      char regbuf[MAX_REGISTER_RAW_SIZE];

      frame_register_read (selected_frame, regnum, regbuf);

      val_print (REGISTER_VIRTUAL_TYPE (regnum), regbuf, 0, 0,
		 gdb_stdout, 'x', 1, 0, Val_pretty_default);

      if (!tabular)
	{
	  printf_filtered ("	");
	  val_print (REGISTER_VIRTUAL_TYPE (regnum), regbuf, 0, 0,
		     gdb_stdout, 'd', 1, 0, Val_pretty_default);
	}
    }
}

static void
d30v_print_flags (void)
{
  long psw = read_register (PSW_REGNUM);
  printf_filtered ("flags #1");
  printf_filtered ("   (sm) %d", (psw & PSW_SM) != 0);
  printf_filtered ("   (ea) %d", (psw & PSW_EA) != 0);
  printf_filtered ("   (db) %d", (psw & PSW_DB) != 0);
  printf_filtered ("   (ds) %d", (psw & PSW_DS) != 0);
  printf_filtered ("   (ie) %d", (psw & PSW_IE) != 0);
  printf_filtered ("   (rp) %d", (psw & PSW_RP) != 0);
  printf_filtered ("   (md) %d\n", (psw & PSW_MD) != 0);

  printf_filtered ("flags #2");
  printf_filtered ("   (f0) %d", (psw & PSW_F0) != 0);
  printf_filtered ("   (f1) %d", (psw & PSW_F1) != 0);
  printf_filtered ("   (f2) %d", (psw & PSW_F2) != 0);
  printf_filtered ("   (f3) %d", (psw & PSW_F3) != 0);
  printf_filtered ("    (s) %d", (psw & PSW_S) != 0);
  printf_filtered ("    (v) %d", (psw & PSW_V) != 0);
  printf_filtered ("   (va) %d", (psw & PSW_VA) != 0);
  printf_filtered ("    (c) %d\n", (psw & PSW_C) != 0);
}

static void
print_flags_command (char *args, int from_tty)
{
  d30v_print_flags ();
}

void
d30v_do_registers_info (int regnum, int fpregs)
{
  long long num1, num2;
  long psw;

  if (regnum != -1)
    {
      if (REGISTER_NAME (0) == NULL || REGISTER_NAME (0)[0] == '\000')
	return;

      printf_filtered ("%s ", REGISTER_NAME (regnum));
      d30v_print_register (regnum, 0);

      printf_filtered ("\n");
      return;
    }

  /* Have to print all the registers.  Format them nicely.  */

  printf_filtered ("PC=");
  print_address (read_pc (), gdb_stdout);

  printf_filtered (" PSW=");
  d30v_print_register (PSW_REGNUM, 1);

  printf_filtered (" BPC=");
  print_address (read_register (BPC_REGNUM), gdb_stdout);

  printf_filtered (" BPSW=");
  d30v_print_register (BPSW_REGNUM, 1);
  printf_filtered ("\n");

  printf_filtered ("DPC=");
  print_address (read_register (DPC_REGNUM), gdb_stdout);

  printf_filtered (" DPSW=");
  d30v_print_register (DPSW_REGNUM, 1);

  printf_filtered (" IBA=");
  print_address (read_register (IBA_REGNUM), gdb_stdout);
  printf_filtered ("\n");

  printf_filtered ("RPT_C=");
  d30v_print_register (RPT_C_REGNUM, 1);

  printf_filtered (" RPT_S=");
  print_address (read_register (RPT_S_REGNUM), gdb_stdout);

  printf_filtered (" RPT_E=");
  print_address (read_register (RPT_E_REGNUM), gdb_stdout);
  printf_filtered ("\n");

  printf_filtered ("MOD_S=");
  print_address (read_register (MOD_S_REGNUM), gdb_stdout);

  printf_filtered (" MOD_E=");
  print_address (read_register (MOD_E_REGNUM), gdb_stdout);
  printf_filtered ("\n");

  printf_filtered ("EIT_VB=");
  print_address (read_register (EIT_VB_REGNUM), gdb_stdout);

  printf_filtered (" INT_S=");
  d30v_print_register (INT_S_REGNUM, 1);

  printf_filtered (" INT_M=");
  d30v_print_register (INT_M_REGNUM, 1);
  printf_filtered ("\n");

  d30v_print_flags ();
  for (regnum = 0; regnum <= 63;)
    {
      int i;

      printf_filtered ("R%d-R%d ", regnum, regnum + 7);
      if (regnum < 10)
	printf_filtered (" ");
      if (regnum + 7 < 10)
	printf_filtered (" ");

      for (i = 0; i < 8; i++)
	{
	  printf_filtered (" ");
	  d30v_print_register (regnum++, 1);
	}

      printf_filtered ("\n");
    }

  printf_filtered ("A0-A1    ");

  d30v_print_register (A0_REGNUM, 1);
  printf_filtered ("    ");
  d30v_print_register (A1_REGNUM, 1);
  printf_filtered ("\n");
}

CORE_ADDR
d30v_fix_call_dummy (char *dummyname, CORE_ADDR start_sp, CORE_ADDR fun,
		     int nargs, struct value **args,
		     struct type *type, int gcc_p)
{
  int regnum;
  CORE_ADDR sp;
  char buffer[MAX_REGISTER_RAW_SIZE];
  struct frame_info *frame = get_current_frame ();
  frame->dummy = start_sp;
  /*start_sp |= DMEM_START; */

  sp = start_sp;
  for (regnum = 0; regnum < NUM_REGS; regnum++)
    {
      sp -= REGISTER_RAW_SIZE (regnum);
      store_address (buffer, REGISTER_RAW_SIZE (regnum), read_register (regnum));
      write_memory (sp, buffer, REGISTER_RAW_SIZE (regnum));
    }
  write_register (SP_REGNUM, (LONGEST) sp);
  /* now we need to load LR with the return address */
  write_register (LR_REGNUM, (LONGEST) d30v_call_dummy_address ());
  return sp;
}

static void
d30v_pop_dummy_frame (struct frame_info *fi)
{
  CORE_ADDR sp = fi->dummy;
  int regnum;

  for (regnum = 0; regnum < NUM_REGS; regnum++)
    {
      sp -= REGISTER_RAW_SIZE (regnum);
      write_register (regnum, read_memory_unsigned_integer (sp, REGISTER_RAW_SIZE (regnum)));
    }
  flush_cached_frames ();	/* needed? */
}


CORE_ADDR
d30v_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		     int struct_return, CORE_ADDR struct_addr)
{
  int i, len, index = 0, regnum = 2;
  char buffer[4], *contents;
  LONGEST val;
  CORE_ADDR ptrs[10];

#if 0
  /* Pass 1. Put all large args on stack */
  for (i = 0; i < nargs; i++)
    {
      struct value *arg = args[i];
      struct type *arg_type = check_typedef (VALUE_TYPE (arg));
      len = TYPE_LENGTH (arg_type);
      contents = VALUE_CONTENTS (arg);
      val = extract_signed_integer (contents, len);
      if (len > 4)
	{
	  /* put on stack and pass pointers */
	  sp -= len;
	  write_memory (sp, contents, len);
	  ptrs[index++] = sp;
	}
    }
#endif
  index = 0;

  for (i = 0; i < nargs; i++)
    {
      struct value *arg = args[i];
      struct type *arg_type = check_typedef (VALUE_TYPE (arg));
      len = TYPE_LENGTH (arg_type);
      contents = VALUE_CONTENTS (arg);
      if (len > 4)
	{
	  /* we need multiple registers */
	  int ndx;

	  for (ndx = 0; len > 0; ndx += 8, len -= 8)
	    {
	      if (regnum & 1)
		regnum++;	/* all args > 4 bytes start in even register */

	      if (regnum < 18)
		{
		  val = extract_signed_integer (&contents[ndx], 4);
		  write_register (regnum++, val);

		  if (len >= 8)
		    val = extract_signed_integer (&contents[ndx + 4], 4);
		  else
		    val = extract_signed_integer (&contents[ndx + 4], len - 4);
		  write_register (regnum++, val);
		}
	      else
		{
		  /* no more registers available.  put it on the stack */

		  /* all args > 4 bytes are padded to a multiple of 8 bytes
		     and start on an 8 byte boundary */
		  if (sp & 7)
		    sp -= (sp & 7);	/* align it */

		  sp -= ((len + 7) & ~7);	/* allocate space */
		  write_memory (sp, &contents[ndx], len);
		  break;
		}
	    }
	}
      else
	{
	  if (regnum < 18)
	    {
	      val = extract_signed_integer (contents, len);
	      write_register (regnum++, val);
	    }
	  else
	    {
	      /* all args are padded to a multiple of 4 bytes (at least) */
	      sp -= ((len + 3) & ~3);
	      write_memory (sp, contents, len);
	    }
	}
    }
  if (sp & 7)
    /* stack pointer is not on an 8 byte boundary -- align it */
    sp -= (sp & 7);
  return sp;
}


/* pick an out-of-the-way place to set the return value */
/* for an inferior function call.  The link register is set to this  */
/* value and a momentary breakpoint is set there.  When the breakpoint */
/* is hit, the dummy frame is popped and the previous environment is */
/* restored. */

CORE_ADDR
d30v_call_dummy_address (void)
{
  CORE_ADDR entry;
  struct minimal_symbol *sym;

  entry = entry_point_address ();

  if (entry != 0)
    return entry;

  sym = lookup_minimal_symbol ("_start", NULL, symfile_objfile);

  if (!sym || MSYMBOL_TYPE (sym) != mst_text)
    return 0;
  else
    return SYMBOL_VALUE_ADDRESS (sym);
}

/* Given a return value in `regbuf' with a type `valtype', 
   extract and copy its value into `valbuf'.  */

void
d30v_extract_return_value (struct type *valtype, char regbuf[REGISTER_BYTES],
			   char *valbuf)
{
  memcpy (valbuf, regbuf + REGISTER_BYTE (2), TYPE_LENGTH (valtype));
}

/* The following code implements access to, and display of, the D30V's
   instruction trace buffer.  The buffer consists of 64K or more
   4-byte words of data, of which each words includes an 8-bit count,
   an 8-bit segment number, and a 16-bit instruction address.

   In theory, the trace buffer is continuously capturing instruction
   data that the CPU presents on its "debug bus", but in practice, the
   ROMified GDB stub only enables tracing when it continues or steps
   the program, and stops tracing when the program stops; so it
   actually works for GDB to read the buffer counter out of memory and
   then read each trace word.  The counter records where the tracing
   stops, but there is no record of where it started, so we remember
   the PC when we resumed and then search backwards in the trace
   buffer for a word that includes that address.  This is not perfect,
   because you will miss trace data if the resumption PC is the target
   of a branch.  (The value of the buffer counter is semi-random, any
   trace data from a previous program stop is gone.)  */

/* The address of the last word recorded in the trace buffer.  */

#define DBBC_ADDR (0xd80000)

/* The base of the trace buffer, at least for the "Board_0".  */

#define TRACE_BUFFER_BASE (0xf40000)

static void trace_command (char *, int);

static void untrace_command (char *, int);

static void trace_info (char *, int);

static void tdisassemble_command (char *, int);

static void display_trace (int, int);

/* True when instruction traces are being collected.  */

static int tracing;

/* Remembered PC.  */

static CORE_ADDR last_pc;

/* True when trace output should be displayed whenever program stops.  */

static int trace_display;

/* True when trace listing should include source lines.  */

static int default_trace_show_source = 1;

struct trace_buffer
  {
    int size;
    short *counts;
    CORE_ADDR *addrs;
  }
trace_data;

static void
trace_command (char *args, int from_tty)
{
  /* Clear the host-side trace buffer, allocating space if needed.  */
  trace_data.size = 0;
  if (trace_data.counts == NULL)
    trace_data.counts = (short *) xmalloc (65536 * sizeof (short));
  if (trace_data.addrs == NULL)
    trace_data.addrs = (CORE_ADDR *) xmalloc (65536 * sizeof (CORE_ADDR));

  tracing = 1;

  printf_filtered ("Tracing is now on.\n");
}

static void
untrace_command (char *args, int from_tty)
{
  tracing = 0;

  printf_filtered ("Tracing is now off.\n");
}

static void
trace_info (char *args, int from_tty)
{
  int i;

  if (trace_data.size)
    {
      printf_filtered ("%d entries in trace buffer:\n", trace_data.size);

      for (i = 0; i < trace_data.size; ++i)
	{
	  printf_filtered ("%d: %d instruction%s at 0x%s\n",
			   i, trace_data.counts[i],
			   (trace_data.counts[i] == 1 ? "" : "s"),
			   paddr_nz (trace_data.addrs[i]));
	}
    }
  else
    printf_filtered ("No entries in trace buffer.\n");

  printf_filtered ("Tracing is currently %s.\n", (tracing ? "on" : "off"));
}

/* Print the instruction at address MEMADDR in debugged memory,
   on STREAM.  Returns length of the instruction, in bytes.  */

static int
print_insn (CORE_ADDR memaddr, struct ui_file *stream)
{
  /* If there's no disassembler, something is very wrong.  */
  if (tm_print_insn == NULL)
    internal_error (__FILE__, __LINE__,
		    "print_insn: no disassembler");

  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    tm_print_insn_info.endian = BFD_ENDIAN_BIG;
  else
    tm_print_insn_info.endian = BFD_ENDIAN_LITTLE;
  return TARGET_PRINT_INSN (memaddr, &tm_print_insn_info);
}

void
d30v_eva_prepare_to_trace (void)
{
  if (!tracing)
    return;

  last_pc = read_register (PC_REGNUM);
}

/* Collect trace data from the target board and format it into a form
   more useful for display.  */

void
d30v_eva_get_trace_data (void)
{
  int count, i, j, oldsize;
  int trace_addr, trace_seg, trace_cnt, next_cnt;
  unsigned int last_trace, trace_word, next_word;
  unsigned int *tmpspace;

  if (!tracing)
    return;

  tmpspace = xmalloc (65536 * sizeof (unsigned int));

  last_trace = read_memory_unsigned_integer (DBBC_ADDR, 2) << 2;

  /* Collect buffer contents from the target, stopping when we reach
     the word recorded when execution resumed.  */

  count = 0;
  while (last_trace > 0)
    {
      QUIT;
      trace_word =
	read_memory_unsigned_integer (TRACE_BUFFER_BASE + last_trace, 4);
      trace_addr = trace_word & 0xffff;
      last_trace -= 4;
      /* Ignore an apparently nonsensical entry.  */
      if (trace_addr == 0xffd5)
	continue;
      tmpspace[count++] = trace_word;
      if (trace_addr == last_pc)
	break;
      if (count > 65535)
	break;
    }

  /* Move the data to the host-side trace buffer, adjusting counts to
     include the last instruction executed and transforming the address
     into something that GDB likes.  */

  for (i = 0; i < count; ++i)
    {
      trace_word = tmpspace[i];
      next_word = ((i == 0) ? 0 : tmpspace[i - 1]);
      trace_addr = trace_word & 0xffff;
      next_cnt = (next_word >> 24) & 0xff;
      j = trace_data.size + count - i - 1;
      trace_data.addrs[j] = (trace_addr << 2) + 0x1000000;
      trace_data.counts[j] = next_cnt + 1;
    }

  oldsize = trace_data.size;
  trace_data.size += count;

  xfree (tmpspace);

  if (trace_display)
    display_trace (oldsize, trace_data.size);
}

static void
tdisassemble_command (char *arg, int from_tty)
{
  int i, count;
  CORE_ADDR low, high;
  char *space_index;

  if (!arg)
    {
      low = 0;
      high = trace_data.size;
    }
  else if (!(space_index = (char *) strchr (arg, ' ')))
    {
      low = parse_and_eval_address (arg);
      high = low + 5;
    }
  else
    {
      /* Two arguments.  */
      *space_index = '\0';
      low = parse_and_eval_address (arg);
      high = parse_and_eval_address (space_index + 1);
      if (high < low)
	high = low;
    }

  printf_filtered ("Dump of trace from %s to %s:\n",
		   paddr_u (low),
		   paddr_u (high));

  display_trace (low, high);

  printf_filtered ("End of trace dump.\n");
  gdb_flush (gdb_stdout);
}

static void
display_trace (int low, int high)
{
  int i, count, trace_show_source, first, suppress;
  CORE_ADDR next_address;

  trace_show_source = default_trace_show_source;
  if (!have_full_symbols () && !have_partial_symbols ())
    {
      trace_show_source = 0;
      printf_filtered ("No symbol table is loaded.  Use the \"file\" command.\n");
      printf_filtered ("Trace will not display any source.\n");
    }

  first = 1;
  suppress = 0;
  for (i = low; i < high; ++i)
    {
      next_address = trace_data.addrs[i];
      count = trace_data.counts[i];
      while (count-- > 0)
	{
	  QUIT;
	  if (trace_show_source)
	    {
	      struct symtab_and_line sal, sal_prev;

	      sal_prev = find_pc_line (next_address - 4, 0);
	      sal = find_pc_line (next_address, 0);

	      if (sal.symtab)
		{
		  if (first || sal.line != sal_prev.line)
		    print_source_lines (sal.symtab, sal.line, sal.line + 1, 0);
		  suppress = 0;
		}
	      else
		{
		  if (!suppress)
		    /* FIXME-32x64--assumes sal.pc fits in long.  */
		    printf_filtered ("No source file for address %s.\n",
				 local_hex_string ((unsigned long) sal.pc));
		  suppress = 1;
		}
	    }
	  first = 0;
	  print_address (next_address, gdb_stdout);
	  printf_filtered (":");
	  printf_filtered ("\t");
	  wrap_here ("    ");
	  next_address = next_address + print_insn (next_address, gdb_stdout);
	  printf_filtered ("\n");
	  gdb_flush (gdb_stdout);
	}
    }
}

extern void (*target_resume_hook) (void);
extern void (*target_wait_loop_hook) (void);

void
_initialize_d30v_tdep (void)
{
  tm_print_insn = print_insn_d30v;

  target_resume_hook = d30v_eva_prepare_to_trace;
  target_wait_loop_hook = d30v_eva_get_trace_data;

  add_info ("flags", print_flags_command, "Print d30v flags.");

  add_com ("trace", class_support, trace_command,
	   "Enable tracing of instruction execution.");

  add_com ("untrace", class_support, untrace_command,
	   "Disable tracing of instruction execution.");

  add_com ("tdisassemble", class_vars, tdisassemble_command,
	   "Disassemble the trace buffer.\n\
Two optional arguments specify a range of trace buffer entries\n\
as reported by info trace (NOT addresses!).");

  add_info ("trace", trace_info,
	    "Display info about the trace data buffer.");

  add_show_from_set (add_set_cmd ("tracedisplay", no_class,
				  var_integer, (char *) &trace_display,
			     "Set automatic display of trace.\n", &setlist),
		     &showlist);
  add_show_from_set (add_set_cmd ("tracesource", no_class,
			   var_integer, (char *) &default_trace_show_source,
		      "Set display of source code with trace.\n", &setlist),
		     &showlist);

}
@


1.13.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1 1365
a1365 1365
/* OBSOLETE /* Target-dependent code for Mitsubishi D30V, for GDB. */
/* OBSOLETE  */
/* OBSOLETE    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software */
/* OBSOLETE    Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE /*  Contributed by Martin Hunt, hunt@@cygnus.com */ */
/* OBSOLETE  */
/* OBSOLETE #include "defs.h" */
/* OBSOLETE #include "frame.h" */
/* OBSOLETE #include "obstack.h" */
/* OBSOLETE #include "symtab.h" */
/* OBSOLETE #include "gdbtypes.h" */
/* OBSOLETE #include "gdbcmd.h" */
/* OBSOLETE #include "gdbcore.h" */
/* OBSOLETE #include "gdb_string.h" */
/* OBSOLETE #include "value.h" */
/* OBSOLETE #include "inferior.h" */
/* OBSOLETE #include "dis-asm.h" */
/* OBSOLETE #include "symfile.h" */
/* OBSOLETE #include "objfiles.h" */
/* OBSOLETE #include "regcache.h" */
/* OBSOLETE  */
/* OBSOLETE #include "language.h" /* For local_hex_string() */ */
/* OBSOLETE  */
/* OBSOLETE void d30v_frame_find_saved_regs (struct frame_info *fi, */
/* OBSOLETE 				 struct frame_saved_regs *fsr); */
/* OBSOLETE void d30v_frame_find_saved_regs_offsets (struct frame_info *fi, */
/* OBSOLETE 					 struct frame_saved_regs *fsr); */
/* OBSOLETE static void d30v_pop_dummy_frame (struct frame_info *fi); */
/* OBSOLETE static void d30v_print_flags (void); */
/* OBSOLETE static void print_flags_command (char *, int); */
/* OBSOLETE  */
/* OBSOLETE /* the following defines assume: */
/* OBSOLETE    fp is r61, lr is r62, sp is r63, and ?? is r22 */
/* OBSOLETE    if that changes, they will need to be updated */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_MASK_ALL_BUT_RA	0x0ffc0fff	/* throw away Ra, keep the rest */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_STW_SPM		0x054c0fc0	/* stw Ra, @@(sp-) */ */
/* OBSOLETE #define OP_STW_SP_R0		0x05400fc0	/* stw Ra, @@(sp,r0) */ */
/* OBSOLETE #define OP_STW_SP_IMM0		0x05480fc0	/* st Ra, @@(sp, 0x0) */ */
/* OBSOLETE #define OP_STW_R22P_R0		0x05440580	/* stw Ra, @@(r22+,r0) */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_ST2W_SPM		0x056c0fc0	/* st2w Ra, @@(sp-) */ */
/* OBSOLETE #define OP_ST2W_SP_R0		0x05600fc0	/* st2w Ra, @@(sp, r0) */ */
/* OBSOLETE #define OP_ST2W_SP_IMM0		0x05680fc0	/* st2w Ra, @@(sp, 0x0) */ */
/* OBSOLETE #define OP_ST2W_R22P_R0		0x05640580	/* st2w Ra, @@(r22+, r0) */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_MASK_OPCODE		0x0ffc0000	/* just the opcode, ign operands */ */
/* OBSOLETE #define OP_NOP			0x00f00000	/* nop */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_MASK_ALL_BUT_IMM	0x0fffffc0	/* throw away imm, keep the rest */ */
/* OBSOLETE #define OP_SUB_SP_IMM		0x082bffc0	/* sub sp,sp,imm */ */
/* OBSOLETE #define OP_ADD_SP_IMM		0x080bffc0	/* add sp,sp,imm */ */
/* OBSOLETE #define OP_ADD_R22_SP_IMM	0x08096fc0	/* add r22,sp,imm */ */
/* OBSOLETE #define OP_STW_FP_SP_IMM	0x054bdfc0	/* stw fp,@@(sp,imm) */ */
/* OBSOLETE #define OP_OR_SP_R0_IMM		0x03abf000	/* or sp,r0,imm */ */
/* OBSOLETE  */
/* OBSOLETE /* no mask */ */
/* OBSOLETE #define OP_OR_FP_R0_SP		0x03a3d03f	/* or fp,r0,sp */ */
/* OBSOLETE #define OP_OR_FP_SP_R0		0x03a3dfc0	/* or fp,sp,r0 */ */
/* OBSOLETE #define OP_OR_FP_IMM0_SP	0x03abd03f	/* or fp,0x0,sp */ */
/* OBSOLETE #define OP_STW_FP_R22P_R0	0x0547d580	/* stw fp,@@(r22+,r0) */ */
/* OBSOLETE #define OP_STW_LR_R22P_R0	0x0547e580	/* stw lr,@@(r22+,r0) */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_MASK_OP_AND_RB	0x0ff80fc0	/* keep op and rb,throw away rest */ */
/* OBSOLETE #define OP_STW_SP_IMM		0x05480fc0	/* stw Ra,@@(sp,imm) */ */
/* OBSOLETE #define OP_ST2W_SP_IMM		0x05680fc0	/* st2w Ra,@@(sp,imm) */ */
/* OBSOLETE #define OP_STW_FP_IMM		0x05480f40	/* stw Ra,@@(fp,imm) */ */
/* OBSOLETE #define OP_STW_FP_R0		0x05400f40	/* stw Ra,@@(fp,r0) */ */
/* OBSOLETE  */
/* OBSOLETE #define OP_MASK_FM_BIT		0x80000000 */
/* OBSOLETE #define OP_MASK_CC_BITS		0x70000000 */
/* OBSOLETE #define OP_MASK_SUB_INST	0x0fffffff */
/* OBSOLETE  */
/* OBSOLETE #define EXTRACT_RA(op)		(((op) >> 12) & 0x3f) */
/* OBSOLETE #define EXTRACT_RB(op)		(((op) >> 6) & 0x3f) */
/* OBSOLETE #define EXTRACT_RC(op)		(((op) & 0x3f) */
/* OBSOLETE #define EXTRACT_UIMM6(op)	((op) & 0x3f) */
/* OBSOLETE #define EXTRACT_IMM6(op)	((((int)EXTRACT_UIMM6(op)) << 26) >> 26) */
/* OBSOLETE #define EXTRACT_IMM26(op)	((((op)&0x0ff00000) >> 2) | ((op)&0x0003ffff)) */
/* OBSOLETE #define EXTRACT_IMM32(opl, opr)	((EXTRACT_UIMM6(opl) << 26)|EXTRACT_IMM26(opr)) */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE d30v_frame_chain_valid (CORE_ADDR chain, struct frame_info *fi) */
/* OBSOLETE { */
/* OBSOLETE #if 0 */
/* OBSOLETE   return ((chain) != 0 && (fi) != 0 && (fi)->return_pc != 0); */
/* OBSOLETE #else */
/* OBSOLETE   return ((chain) != 0 && (fi) != 0 && (fi)->frame <= chain); */
/* OBSOLETE #endif */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Discard from the stack the innermost frame, restoring all saved */
/* OBSOLETE    registers.  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_pop_frame (void) */
/* OBSOLETE { */
/* OBSOLETE   struct frame_info *frame = get_current_frame (); */
/* OBSOLETE   CORE_ADDR fp; */
/* OBSOLETE   int regnum; */
/* OBSOLETE   struct frame_saved_regs fsr; */
/* OBSOLETE   char raw_buffer[8]; */
/* OBSOLETE  */
/* OBSOLETE   fp = FRAME_FP (frame); */
/* OBSOLETE   if (frame->dummy) */
/* OBSOLETE     { */
/* OBSOLETE       d30v_pop_dummy_frame (frame); */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* fill out fsr with the address of where each */ */
/* OBSOLETE   /* register was stored in the frame */ */
/* OBSOLETE   get_frame_saved_regs (frame, &fsr); */
/* OBSOLETE  */
/* OBSOLETE   /* now update the current registers with the old values */ */
/* OBSOLETE   for (regnum = A0_REGNUM; regnum < A0_REGNUM + 2; regnum++) */
/* OBSOLETE     { */
/* OBSOLETE       if (fsr.regs[regnum]) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  read_memory (fsr.regs[regnum], raw_buffer, 8); */
/* OBSOLETE 	  write_register_bytes (REGISTER_BYTE (regnum), raw_buffer, 8); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   for (regnum = 0; regnum < SP_REGNUM; regnum++) */
/* OBSOLETE     { */
/* OBSOLETE       if (fsr.regs[regnum]) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  write_register (regnum, read_memory_unsigned_integer (fsr.regs[regnum], 4)); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   if (fsr.regs[PSW_REGNUM]) */
/* OBSOLETE     { */
/* OBSOLETE       write_register (PSW_REGNUM, read_memory_unsigned_integer (fsr.regs[PSW_REGNUM], 4)); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   write_register (PC_REGNUM, read_register (LR_REGNUM)); */
/* OBSOLETE   write_register (SP_REGNUM, fp + frame->size); */
/* OBSOLETE   target_store_registers (-1); */
/* OBSOLETE   flush_cached_frames (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE check_prologue (unsigned long op) */
/* OBSOLETE { */
/* OBSOLETE   /* add sp,sp,imm -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_ADD_SP_IMM) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* add r22,sp,imm -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_ADD_R22_SP_IMM) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* or  fp,r0,sp -- observed */ */
/* OBSOLETE   if (op == OP_OR_FP_R0_SP) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* nop */ */
/* OBSOLETE   if ((op & OP_MASK_OPCODE) == OP_NOP) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw  Ra,@@(sp,r0) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SP_R0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw  Ra,@@(sp,0x0) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SP_IMM0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* st2w  Ra,@@(sp,r0) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_R0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* st2w  Ra,@@(sp,0x0) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_IMM0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw fp, @@(r22+,r0) -- observed */ */
/* OBSOLETE   if (op == OP_STW_FP_R22P_R0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw r62, @@(r22+,r0) -- observed */ */
/* OBSOLETE   if (op == OP_STW_LR_R22P_R0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw Ra, @@(fp,r0) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_FP_R0) */
/* OBSOLETE     return 1;			/* first arg */ */
/* OBSOLETE  */
/* OBSOLETE   /* stw Ra, @@(fp,imm) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_OP_AND_RB) == OP_STW_FP_IMM) */
/* OBSOLETE     return 1;			/* second and subsequent args */ */
/* OBSOLETE  */
/* OBSOLETE   /* stw fp,@@(sp,imm) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_STW_FP_SP_IMM) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* st2w Ra,@@(r22+,r0) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_R22P_R0) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw  Ra, @@(sp-) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SPM) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* st2w  Ra, @@(sp-) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SPM) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* sub.?  sp,sp,imm */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_SUB_SP_IMM) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   return 0; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE d30v_skip_prologue (CORE_ADDR pc) */
/* OBSOLETE { */
/* OBSOLETE   unsigned long op[2]; */
/* OBSOLETE   unsigned long opl, opr;	/* left / right sub operations */ */
/* OBSOLETE   unsigned long fm0, fm1;	/* left / right mode bits */ */
/* OBSOLETE   unsigned long cc0, cc1; */
/* OBSOLETE   unsigned long op1, op2; */
/* OBSOLETE   CORE_ADDR func_addr, func_end; */
/* OBSOLETE   struct symtab_and_line sal; */
/* OBSOLETE  */
/* OBSOLETE   /* If we have line debugging information, then the end of the */ */
/* OBSOLETE   /* prologue should the first assembly instruction of  the first source line */ */
/* OBSOLETE   if (find_pc_partial_function (pc, NULL, &func_addr, &func_end)) */
/* OBSOLETE     { */
/* OBSOLETE       sal = find_pc_line (func_addr, 0); */
/* OBSOLETE       if (sal.end && sal.end < func_end) */
/* OBSOLETE 	return sal.end; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (target_read_memory (pc, (char *) &op[0], 8)) */
/* OBSOLETE     return pc;			/* Can't access it -- assume no prologue. */ */
/* OBSOLETE  */
/* OBSOLETE   while (1) */
/* OBSOLETE     { */
/* OBSOLETE       opl = (unsigned long) read_memory_integer (pc, 4); */
/* OBSOLETE       opr = (unsigned long) read_memory_integer (pc + 4, 4); */
/* OBSOLETE  */
/* OBSOLETE       fm0 = (opl & OP_MASK_FM_BIT); */
/* OBSOLETE       fm1 = (opr & OP_MASK_FM_BIT); */
/* OBSOLETE  */
/* OBSOLETE       cc0 = (opl & OP_MASK_CC_BITS); */
/* OBSOLETE       cc1 = (opr & OP_MASK_CC_BITS); */
/* OBSOLETE  */
/* OBSOLETE       opl = (opl & OP_MASK_SUB_INST); */
/* OBSOLETE       opr = (opr & OP_MASK_SUB_INST); */
/* OBSOLETE  */
/* OBSOLETE       if (fm0 && fm1) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* long instruction (opl contains the opcode) */ */
/* OBSOLETE 	  if (((opl & OP_MASK_ALL_BUT_IMM) != OP_ADD_SP_IMM) &&		/* add sp,sp,imm */ */
/* OBSOLETE 	      ((opl & OP_MASK_ALL_BUT_IMM) != OP_ADD_R22_SP_IMM) &&	/* add r22,sp,imm */ */
/* OBSOLETE 	      ((opl & OP_MASK_OP_AND_RB) != OP_STW_SP_IMM) &&	/* stw Ra, @@(sp,imm) */ */
/* OBSOLETE 	      ((opl & OP_MASK_OP_AND_RB) != OP_ST2W_SP_IMM))	/* st2w Ra, @@(sp,imm) */ */
/* OBSOLETE 	    break; */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* short instructions */ */
/* OBSOLETE 	  if (fm0 && !fm1) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      op1 = opr; */
/* OBSOLETE 	      op2 = opl; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    { */
/* OBSOLETE 	      op1 = opl; */
/* OBSOLETE 	      op2 = opr; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  if (check_prologue (op1)) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      if (!check_prologue (op2)) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  /* if the previous opcode was really part of the prologue */ */
/* OBSOLETE 		  /* and not just a NOP, then we want to break after both instructions */ */
/* OBSOLETE 		  if ((op1 & OP_MASK_OPCODE) != OP_NOP) */
/* OBSOLETE 		    pc += 8; */
/* OBSOLETE 		  break; */
/* OBSOLETE 		} */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    break; */
/* OBSOLETE 	} */
/* OBSOLETE       pc += 8; */
/* OBSOLETE     } */
/* OBSOLETE   return pc; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static int end_of_stack; */
/* OBSOLETE  */
/* OBSOLETE /* Given a GDB frame, determine the address of the calling function's frame. */
/* OBSOLETE    This will be used to create a new GDB frame struct, and then */
/* OBSOLETE    INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame. */
/* OBSOLETE  */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE d30v_frame_chain (struct frame_info *frame) */
/* OBSOLETE { */
/* OBSOLETE   struct frame_saved_regs fsr; */
/* OBSOLETE  */
/* OBSOLETE   d30v_frame_find_saved_regs (frame, &fsr); */
/* OBSOLETE  */
/* OBSOLETE   if (end_of_stack) */
/* OBSOLETE     return (CORE_ADDR) 0; */
/* OBSOLETE  */
/* OBSOLETE   if (frame->return_pc == IMEM_START) */
/* OBSOLETE     return (CORE_ADDR) 0; */
/* OBSOLETE  */
/* OBSOLETE   if (!fsr.regs[FP_REGNUM]) */
/* OBSOLETE     { */
/* OBSOLETE       if (!fsr.regs[SP_REGNUM] || fsr.regs[SP_REGNUM] == STACK_START) */
/* OBSOLETE 	return (CORE_ADDR) 0; */
/* OBSOLETE  */
/* OBSOLETE       return fsr.regs[SP_REGNUM]; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (!read_memory_unsigned_integer (fsr.regs[FP_REGNUM], 4)) */
/* OBSOLETE     return (CORE_ADDR) 0; */
/* OBSOLETE  */
/* OBSOLETE   return read_memory_unsigned_integer (fsr.regs[FP_REGNUM], 4); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static int next_addr, uses_frame; */
/* OBSOLETE static int frame_size; */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE prologue_find_regs (unsigned long op, struct frame_saved_regs *fsr, */
/* OBSOLETE 		    CORE_ADDR addr) */
/* OBSOLETE { */
/* OBSOLETE   int n; */
/* OBSOLETE   int offset; */
/* OBSOLETE  */
/* OBSOLETE   /* add sp,sp,imm -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_ADD_SP_IMM) */
/* OBSOLETE     { */
/* OBSOLETE       offset = EXTRACT_IMM6 (op); */
/* OBSOLETE       /*next_addr += offset; */ */
/* OBSOLETE       frame_size += -offset; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* add r22,sp,imm -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_ADD_R22_SP_IMM) */
/* OBSOLETE     { */
/* OBSOLETE       offset = EXTRACT_IMM6 (op); */
/* OBSOLETE       next_addr = (offset - frame_size); */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* stw Ra, @@(fp, offset) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_OP_AND_RB) == OP_STW_FP_IMM) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       offset = EXTRACT_IMM6 (op); */
/* OBSOLETE       fsr->regs[n] = (offset - frame_size); */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* stw Ra, @@(fp, r0) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_FP_R0) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = (-frame_size); */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* or  fp,0,sp -- observed */ */
/* OBSOLETE   if ((op == OP_OR_FP_R0_SP) || */
/* OBSOLETE       (op == OP_OR_FP_SP_R0) || */
/* OBSOLETE       (op == OP_OR_FP_IMM0_SP)) */
/* OBSOLETE     { */
/* OBSOLETE       uses_frame = 1; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* nop */ */
/* OBSOLETE   if ((op & OP_MASK_OPCODE) == OP_NOP) */
/* OBSOLETE     return 1; */
/* OBSOLETE  */
/* OBSOLETE   /* stw Ra,@@(r22+,r0) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_R22P_R0) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = next_addr; */
/* OBSOLETE       next_addr += 4; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE #if 0				/* subsumed in pattern above */ */
/* OBSOLETE   /* stw fp,@@(r22+,r0) -- observed */ */
/* OBSOLETE   if (op == OP_STW_FP_R22P_R0) */
/* OBSOLETE     { */
/* OBSOLETE       fsr->regs[FP_REGNUM] = next_addr;		/* XXX */ */
/* OBSOLETE       next_addr += 4; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* stw r62,@@(r22+,r0) -- observed */ */
/* OBSOLETE   if (op == OP_STW_LR_R22P_R0) */
/* OBSOLETE     { */
/* OBSOLETE       fsr->regs[LR_REGNUM] = next_addr; */
/* OBSOLETE       next_addr += 4; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE #endif */
/* OBSOLETE   /* st2w Ra,@@(r22+,r0) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_R22P_R0) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = next_addr; */
/* OBSOLETE       fsr->regs[n + 1] = next_addr + 4; */
/* OBSOLETE       next_addr += 8; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* stw  rn, @@(sp-) */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SPM) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = next_addr; */
/* OBSOLETE       next_addr -= 4; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* st2w  Ra, @@(sp-) */ */
/* OBSOLETE   else if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SPM) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = next_addr; */
/* OBSOLETE       fsr->regs[n + 1] = next_addr + 4; */
/* OBSOLETE       next_addr -= 8; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* sub  sp,sp,imm */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_SUB_SP_IMM) */
/* OBSOLETE     { */
/* OBSOLETE       offset = EXTRACT_IMM6 (op); */
/* OBSOLETE       frame_size += -offset; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* st  rn, @@(sp,0) -- observed */ */
/* OBSOLETE   if (((op & OP_MASK_ALL_BUT_RA) == OP_STW_SP_R0) || */
/* OBSOLETE       ((op & OP_MASK_ALL_BUT_RA) == OP_STW_SP_IMM0)) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = (-frame_size); */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* st2w  rn, @@(sp,0) */ */
/* OBSOLETE   if (((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_R0) || */
/* OBSOLETE       ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_IMM0)) */
/* OBSOLETE     { */
/* OBSOLETE       n = EXTRACT_RA (op); */
/* OBSOLETE       fsr->regs[n] = (-frame_size); */
/* OBSOLETE       fsr->regs[n + 1] = (-frame_size) + 4; */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* stw fp,@@(sp,imm) -- observed */ */
/* OBSOLETE   if ((op & OP_MASK_ALL_BUT_IMM) == OP_STW_FP_SP_IMM) */
/* OBSOLETE     { */
/* OBSOLETE       offset = EXTRACT_IMM6 (op); */
/* OBSOLETE       fsr->regs[FP_REGNUM] = (offset - frame_size); */
/* OBSOLETE       return 1; */
/* OBSOLETE     } */
/* OBSOLETE   return 0; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Put here the code to store, into a struct frame_saved_regs, the */
/* OBSOLETE    addresses of the saved registers of frame described by FRAME_INFO. */
/* OBSOLETE    This includes special registers such as pc and fp saved in special */
/* OBSOLETE    ways in the stack frame.  sp is even more special: the address we */
/* OBSOLETE    return for it IS the sp for the next frame. */ */
/* OBSOLETE void */
/* OBSOLETE d30v_frame_find_saved_regs (struct frame_info *fi, struct frame_saved_regs *fsr) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR fp, pc; */
/* OBSOLETE   unsigned long opl, opr; */
/* OBSOLETE   unsigned long op1, op2; */
/* OBSOLETE   unsigned long fm0, fm1; */
/* OBSOLETE   int i; */
/* OBSOLETE  */
/* OBSOLETE   fp = fi->frame; */
/* OBSOLETE   memset (fsr, 0, sizeof (*fsr)); */
/* OBSOLETE   next_addr = 0; */
/* OBSOLETE   frame_size = 0; */
/* OBSOLETE   end_of_stack = 0; */
/* OBSOLETE  */
/* OBSOLETE   uses_frame = 0; */
/* OBSOLETE  */
/* OBSOLETE   d30v_frame_find_saved_regs_offsets (fi, fsr); */
/* OBSOLETE  */
/* OBSOLETE   fi->size = frame_size; */
/* OBSOLETE  */
/* OBSOLETE   if (!fp) */
/* OBSOLETE     fp = read_register (SP_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   for (i = 0; i < NUM_REGS - 1; i++) */
/* OBSOLETE     if (fsr->regs[i]) */
/* OBSOLETE       { */
/* OBSOLETE 	fsr->regs[i] = fsr->regs[i] + fp + frame_size; */
/* OBSOLETE       } */
/* OBSOLETE  */
/* OBSOLETE   if (fsr->regs[LR_REGNUM]) */
/* OBSOLETE     fi->return_pc = read_memory_unsigned_integer (fsr->regs[LR_REGNUM], 4); */
/* OBSOLETE   else */
/* OBSOLETE     fi->return_pc = read_register (LR_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   /* the SP is not normally (ever?) saved, but check anyway */ */
/* OBSOLETE   if (!fsr->regs[SP_REGNUM]) */
/* OBSOLETE     { */
/* OBSOLETE       /* if the FP was saved, that means the current FP is valid, */ */
/* OBSOLETE       /* otherwise, it isn't being used, so we use the SP instead */ */
/* OBSOLETE       if (uses_frame) */
/* OBSOLETE 	fsr->regs[SP_REGNUM] = read_register (FP_REGNUM) + fi->size; */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  fsr->regs[SP_REGNUM] = fp + fi->size; */
/* OBSOLETE 	  fi->frameless = 1; */
/* OBSOLETE 	  fsr->regs[FP_REGNUM] = 0; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_frame_find_saved_regs_offsets (struct frame_info *fi, */
/* OBSOLETE 				    struct frame_saved_regs *fsr) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR fp, pc; */
/* OBSOLETE   unsigned long opl, opr; */
/* OBSOLETE   unsigned long op1, op2; */
/* OBSOLETE   unsigned long fm0, fm1; */
/* OBSOLETE   int i; */
/* OBSOLETE  */
/* OBSOLETE   fp = fi->frame; */
/* OBSOLETE   memset (fsr, 0, sizeof (*fsr)); */
/* OBSOLETE   next_addr = 0; */
/* OBSOLETE   frame_size = 0; */
/* OBSOLETE   end_of_stack = 0; */
/* OBSOLETE  */
/* OBSOLETE   pc = get_pc_function_start (fi->pc); */
/* OBSOLETE  */
/* OBSOLETE   uses_frame = 0; */
/* OBSOLETE   while (pc < fi->pc) */
/* OBSOLETE     { */
/* OBSOLETE       opl = (unsigned long) read_memory_integer (pc, 4); */
/* OBSOLETE       opr = (unsigned long) read_memory_integer (pc + 4, 4); */
/* OBSOLETE  */
/* OBSOLETE       fm0 = (opl & OP_MASK_FM_BIT); */
/* OBSOLETE       fm1 = (opr & OP_MASK_FM_BIT); */
/* OBSOLETE  */
/* OBSOLETE       opl = (opl & OP_MASK_SUB_INST); */
/* OBSOLETE       opr = (opr & OP_MASK_SUB_INST); */
/* OBSOLETE  */
/* OBSOLETE       if (fm0 && fm1) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* long instruction */ */
/* OBSOLETE 	  if ((opl & OP_MASK_ALL_BUT_IMM) == OP_ADD_SP_IMM) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* add sp,sp,n */ */
/* OBSOLETE 	      long offset = EXTRACT_IMM32 (opl, opr); */
/* OBSOLETE 	      frame_size += -offset; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else if ((opl & OP_MASK_ALL_BUT_IMM) == OP_ADD_R22_SP_IMM) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* add r22,sp,offset */ */
/* OBSOLETE 	      long offset = EXTRACT_IMM32 (opl, opr); */
/* OBSOLETE 	      next_addr = (offset - frame_size); */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else if ((opl & OP_MASK_OP_AND_RB) == OP_STW_SP_IMM) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* st Ra, @@(sp,imm) */ */
/* OBSOLETE 	      long offset = EXTRACT_IMM32 (opl, opr); */
/* OBSOLETE 	      short n = EXTRACT_RA (opl); */
/* OBSOLETE 	      fsr->regs[n] = (offset - frame_size); */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else if ((opl & OP_MASK_OP_AND_RB) == OP_ST2W_SP_IMM) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* st2w Ra, @@(sp,offset) */ */
/* OBSOLETE 	      long offset = EXTRACT_IMM32 (opl, opr); */
/* OBSOLETE 	      short n = EXTRACT_RA (opl); */
/* OBSOLETE 	      fsr->regs[n] = (offset - frame_size); */
/* OBSOLETE 	      fsr->regs[n + 1] = (offset - frame_size) + 4; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else if ((opl & OP_MASK_ALL_BUT_IMM) == OP_OR_SP_R0_IMM) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      end_of_stack = 1; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    break; */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* short instructions */ */
/* OBSOLETE 	  if (fm0 && !fm1) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      op2 = opl; */
/* OBSOLETE 	      op1 = opr; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    { */
/* OBSOLETE 	      op1 = opl; */
/* OBSOLETE 	      op2 = opr; */
/* OBSOLETE 	    } */
/* OBSOLETE 	  if (!prologue_find_regs (op1, fsr, pc) || !prologue_find_regs (op2, fsr, pc)) */
/* OBSOLETE 	    break; */
/* OBSOLETE 	} */
/* OBSOLETE       pc += 8; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE #if 0 */
/* OBSOLETE   fi->size = frame_size; */
/* OBSOLETE  */
/* OBSOLETE   if (!fp) */
/* OBSOLETE     fp = read_register (SP_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   for (i = 0; i < NUM_REGS - 1; i++) */
/* OBSOLETE     if (fsr->regs[i]) */
/* OBSOLETE       { */
/* OBSOLETE 	fsr->regs[i] = fsr->regs[i] + fp + frame_size; */
/* OBSOLETE       } */
/* OBSOLETE  */
/* OBSOLETE   if (fsr->regs[LR_REGNUM]) */
/* OBSOLETE     fi->return_pc = read_memory_unsigned_integer (fsr->regs[LR_REGNUM], 4); */
/* OBSOLETE   else */
/* OBSOLETE     fi->return_pc = read_register (LR_REGNUM); */
/* OBSOLETE  */
/* OBSOLETE   /* the SP is not normally (ever?) saved, but check anyway */ */
/* OBSOLETE   if (!fsr->regs[SP_REGNUM]) */
/* OBSOLETE     { */
/* OBSOLETE       /* if the FP was saved, that means the current FP is valid, */ */
/* OBSOLETE       /* otherwise, it isn't being used, so we use the SP instead */ */
/* OBSOLETE       if (uses_frame) */
/* OBSOLETE 	fsr->regs[SP_REGNUM] = read_register (FP_REGNUM) + fi->size; */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  fsr->regs[SP_REGNUM] = fp + fi->size; */
/* OBSOLETE 	  fi->frameless = 1; */
/* OBSOLETE 	  fsr->regs[FP_REGNUM] = 0; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE #endif */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_init_extra_frame_info (int fromleaf, struct frame_info *fi) */
/* OBSOLETE { */
/* OBSOLETE   struct frame_saved_regs dummy; */
/* OBSOLETE  */
/* OBSOLETE   if (fi->next && (fi->pc == 0)) */
/* OBSOLETE     fi->pc = fi->next->return_pc; */
/* OBSOLETE  */
/* OBSOLETE   d30v_frame_find_saved_regs_offsets (fi, &dummy); */
/* OBSOLETE  */
/* OBSOLETE   if (uses_frame == 0) */
/* OBSOLETE     fi->frameless = 1; */
/* OBSOLETE   else */
/* OBSOLETE     fi->frameless = 0; */
/* OBSOLETE  */
/* OBSOLETE   if ((fi->next == 0) && (uses_frame == 0)) */
/* OBSOLETE     /* innermost frame and it's "frameless", */
/* OBSOLETE        so the fi->frame field is wrong, fix it! */ */
/* OBSOLETE     fi->frame = read_sp (); */
/* OBSOLETE  */
/* OBSOLETE   if (dummy.regs[LR_REGNUM]) */
/* OBSOLETE     { */
/* OBSOLETE       /* it was saved, grab it! */ */
/* OBSOLETE       dummy.regs[LR_REGNUM] += (fi->frame + frame_size); */
/* OBSOLETE       fi->return_pc = read_memory_unsigned_integer (dummy.regs[LR_REGNUM], 4); */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     fi->return_pc = read_register (LR_REGNUM); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_init_frame_pc (int fromleaf, struct frame_info *prev) */
/* OBSOLETE { */
/* OBSOLETE   /* default value, put here so we can breakpoint on it and */
/* OBSOLETE      see if the default value is really the right thing to use */ */
/* OBSOLETE   prev->pc = (fromleaf ? SAVED_PC_AFTER_CALL (prev->next) : \ */
/* OBSOLETE 	      prev->next ? FRAME_SAVED_PC (prev->next) : read_pc ()); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void d30v_print_register (int regnum, int tabular); */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE d30v_print_register (int regnum, int tabular) */
/* OBSOLETE { */
/* OBSOLETE   if (regnum < A0_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       if (tabular) */
/* OBSOLETE 	printf_filtered ("%08lx", (long) read_register (regnum)); */
/* OBSOLETE       else */
/* OBSOLETE 	printf_filtered ("0x%lx	%ld", */
/* OBSOLETE 			 (long) read_register (regnum), */
/* OBSOLETE 			 (long) read_register (regnum)); */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       char regbuf[MAX_REGISTER_RAW_SIZE]; */
/* OBSOLETE  */
/* OBSOLETE       frame_register_read (selected_frame, regnum, regbuf); */
/* OBSOLETE  */
/* OBSOLETE       val_print (REGISTER_VIRTUAL_TYPE (regnum), regbuf, 0, 0, */
/* OBSOLETE 		 gdb_stdout, 'x', 1, 0, Val_pretty_default); */
/* OBSOLETE  */
/* OBSOLETE       if (!tabular) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  printf_filtered ("	"); */
/* OBSOLETE 	  val_print (REGISTER_VIRTUAL_TYPE (regnum), regbuf, 0, 0, */
/* OBSOLETE 		     gdb_stdout, 'd', 1, 0, Val_pretty_default); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE d30v_print_flags (void) */
/* OBSOLETE { */
/* OBSOLETE   long psw = read_register (PSW_REGNUM); */
/* OBSOLETE   printf_filtered ("flags #1"); */
/* OBSOLETE   printf_filtered ("   (sm) %d", (psw & PSW_SM) != 0); */
/* OBSOLETE   printf_filtered ("   (ea) %d", (psw & PSW_EA) != 0); */
/* OBSOLETE   printf_filtered ("   (db) %d", (psw & PSW_DB) != 0); */
/* OBSOLETE   printf_filtered ("   (ds) %d", (psw & PSW_DS) != 0); */
/* OBSOLETE   printf_filtered ("   (ie) %d", (psw & PSW_IE) != 0); */
/* OBSOLETE   printf_filtered ("   (rp) %d", (psw & PSW_RP) != 0); */
/* OBSOLETE   printf_filtered ("   (md) %d\n", (psw & PSW_MD) != 0); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("flags #2"); */
/* OBSOLETE   printf_filtered ("   (f0) %d", (psw & PSW_F0) != 0); */
/* OBSOLETE   printf_filtered ("   (f1) %d", (psw & PSW_F1) != 0); */
/* OBSOLETE   printf_filtered ("   (f2) %d", (psw & PSW_F2) != 0); */
/* OBSOLETE   printf_filtered ("   (f3) %d", (psw & PSW_F3) != 0); */
/* OBSOLETE   printf_filtered ("    (s) %d", (psw & PSW_S) != 0); */
/* OBSOLETE   printf_filtered ("    (v) %d", (psw & PSW_V) != 0); */
/* OBSOLETE   printf_filtered ("   (va) %d", (psw & PSW_VA) != 0); */
/* OBSOLETE   printf_filtered ("    (c) %d\n", (psw & PSW_C) != 0); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE print_flags_command (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   d30v_print_flags (); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_do_registers_info (int regnum, int fpregs) */
/* OBSOLETE { */
/* OBSOLETE   long long num1, num2; */
/* OBSOLETE   long psw; */
/* OBSOLETE  */
/* OBSOLETE   if (regnum != -1) */
/* OBSOLETE     { */
/* OBSOLETE       if (REGISTER_NAME (0) == NULL || REGISTER_NAME (0)[0] == '\000') */
/* OBSOLETE 	return; */
/* OBSOLETE  */
/* OBSOLETE       printf_filtered ("%s ", REGISTER_NAME (regnum)); */
/* OBSOLETE       d30v_print_register (regnum, 0); */
/* OBSOLETE  */
/* OBSOLETE       printf_filtered ("\n"); */
/* OBSOLETE       return; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Have to print all the registers.  Format them nicely.  */ */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("PC="); */
/* OBSOLETE   print_address (read_pc (), gdb_stdout); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" PSW="); */
/* OBSOLETE   d30v_print_register (PSW_REGNUM, 1); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" BPC="); */
/* OBSOLETE   print_address (read_register (BPC_REGNUM), gdb_stdout); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" BPSW="); */
/* OBSOLETE   d30v_print_register (BPSW_REGNUM, 1); */
/* OBSOLETE   printf_filtered ("\n"); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("DPC="); */
/* OBSOLETE   print_address (read_register (DPC_REGNUM), gdb_stdout); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" DPSW="); */
/* OBSOLETE   d30v_print_register (DPSW_REGNUM, 1); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" IBA="); */
/* OBSOLETE   print_address (read_register (IBA_REGNUM), gdb_stdout); */
/* OBSOLETE   printf_filtered ("\n"); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("RPT_C="); */
/* OBSOLETE   d30v_print_register (RPT_C_REGNUM, 1); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" RPT_S="); */
/* OBSOLETE   print_address (read_register (RPT_S_REGNUM), gdb_stdout); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" RPT_E="); */
/* OBSOLETE   print_address (read_register (RPT_E_REGNUM), gdb_stdout); */
/* OBSOLETE   printf_filtered ("\n"); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("MOD_S="); */
/* OBSOLETE   print_address (read_register (MOD_S_REGNUM), gdb_stdout); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" MOD_E="); */
/* OBSOLETE   print_address (read_register (MOD_E_REGNUM), gdb_stdout); */
/* OBSOLETE   printf_filtered ("\n"); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("EIT_VB="); */
/* OBSOLETE   print_address (read_register (EIT_VB_REGNUM), gdb_stdout); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" INT_S="); */
/* OBSOLETE   d30v_print_register (INT_S_REGNUM, 1); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered (" INT_M="); */
/* OBSOLETE   d30v_print_register (INT_M_REGNUM, 1); */
/* OBSOLETE   printf_filtered ("\n"); */
/* OBSOLETE  */
/* OBSOLETE   d30v_print_flags (); */
/* OBSOLETE   for (regnum = 0; regnum <= 63;) */
/* OBSOLETE     { */
/* OBSOLETE       int i; */
/* OBSOLETE  */
/* OBSOLETE       printf_filtered ("R%d-R%d ", regnum, regnum + 7); */
/* OBSOLETE       if (regnum < 10) */
/* OBSOLETE 	printf_filtered (" "); */
/* OBSOLETE       if (regnum + 7 < 10) */
/* OBSOLETE 	printf_filtered (" "); */
/* OBSOLETE  */
/* OBSOLETE       for (i = 0; i < 8; i++) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  printf_filtered (" "); */
/* OBSOLETE 	  d30v_print_register (regnum++, 1); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       printf_filtered ("\n"); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("A0-A1    "); */
/* OBSOLETE  */
/* OBSOLETE   d30v_print_register (A0_REGNUM, 1); */
/* OBSOLETE   printf_filtered ("    "); */
/* OBSOLETE   d30v_print_register (A1_REGNUM, 1); */
/* OBSOLETE   printf_filtered ("\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE d30v_fix_call_dummy (char *dummyname, CORE_ADDR start_sp, CORE_ADDR fun, */
/* OBSOLETE 		     int nargs, struct value **args, */
/* OBSOLETE 		     struct type *type, int gcc_p) */
/* OBSOLETE { */
/* OBSOLETE   int regnum; */
/* OBSOLETE   CORE_ADDR sp; */
/* OBSOLETE   char buffer[MAX_REGISTER_RAW_SIZE]; */
/* OBSOLETE   struct frame_info *frame = get_current_frame (); */
/* OBSOLETE   frame->dummy = start_sp; */
/* OBSOLETE   /*start_sp |= DMEM_START; */ */
/* OBSOLETE  */
/* OBSOLETE   sp = start_sp; */
/* OBSOLETE   for (regnum = 0; regnum < NUM_REGS; regnum++) */
/* OBSOLETE     { */
/* OBSOLETE       sp -= REGISTER_RAW_SIZE (regnum); */
/* OBSOLETE       store_address (buffer, REGISTER_RAW_SIZE (regnum), read_register (regnum)); */
/* OBSOLETE       write_memory (sp, buffer, REGISTER_RAW_SIZE (regnum)); */
/* OBSOLETE     } */
/* OBSOLETE   write_register (SP_REGNUM, (LONGEST) sp); */
/* OBSOLETE   /* now we need to load LR with the return address */ */
/* OBSOLETE   write_register (LR_REGNUM, (LONGEST) d30v_call_dummy_address ()); */
/* OBSOLETE   return sp; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE d30v_pop_dummy_frame (struct frame_info *fi) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR sp = fi->dummy; */
/* OBSOLETE   int regnum; */
/* OBSOLETE  */
/* OBSOLETE   for (regnum = 0; regnum < NUM_REGS; regnum++) */
/* OBSOLETE     { */
/* OBSOLETE       sp -= REGISTER_RAW_SIZE (regnum); */
/* OBSOLETE       write_register (regnum, read_memory_unsigned_integer (sp, REGISTER_RAW_SIZE (regnum))); */
/* OBSOLETE     } */
/* OBSOLETE   flush_cached_frames ();	/* needed? */ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE d30v_push_arguments (int nargs, struct value **args, CORE_ADDR sp, */
/* OBSOLETE 		     int struct_return, CORE_ADDR struct_addr) */
/* OBSOLETE { */
/* OBSOLETE   int i, len, index = 0, regnum = 2; */
/* OBSOLETE   char buffer[4], *contents; */
/* OBSOLETE   LONGEST val; */
/* OBSOLETE   CORE_ADDR ptrs[10]; */
/* OBSOLETE  */
/* OBSOLETE #if 0 */
/* OBSOLETE   /* Pass 1. Put all large args on stack */ */
/* OBSOLETE   for (i = 0; i < nargs; i++) */
/* OBSOLETE     { */
/* OBSOLETE       struct value *arg = args[i]; */
/* OBSOLETE       struct type *arg_type = check_typedef (VALUE_TYPE (arg)); */
/* OBSOLETE       len = TYPE_LENGTH (arg_type); */
/* OBSOLETE       contents = VALUE_CONTENTS (arg); */
/* OBSOLETE       val = extract_signed_integer (contents, len); */
/* OBSOLETE       if (len > 4) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* put on stack and pass pointers */ */
/* OBSOLETE 	  sp -= len; */
/* OBSOLETE 	  write_memory (sp, contents, len); */
/* OBSOLETE 	  ptrs[index++] = sp; */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE #endif */
/* OBSOLETE   index = 0; */
/* OBSOLETE  */
/* OBSOLETE   for (i = 0; i < nargs; i++) */
/* OBSOLETE     { */
/* OBSOLETE       struct value *arg = args[i]; */
/* OBSOLETE       struct type *arg_type = check_typedef (VALUE_TYPE (arg)); */
/* OBSOLETE       len = TYPE_LENGTH (arg_type); */
/* OBSOLETE       contents = VALUE_CONTENTS (arg); */
/* OBSOLETE       if (len > 4) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  /* we need multiple registers */ */
/* OBSOLETE 	  int ndx; */
/* OBSOLETE  */
/* OBSOLETE 	  for (ndx = 0; len > 0; ndx += 8, len -= 8) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      if (regnum & 1) */
/* OBSOLETE 		regnum++;	/* all args > 4 bytes start in even register */ */
/* OBSOLETE  */
/* OBSOLETE 	      if (regnum < 18) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  val = extract_signed_integer (&contents[ndx], 4); */
/* OBSOLETE 		  write_register (regnum++, val); */
/* OBSOLETE  */
/* OBSOLETE 		  if (len >= 8) */
/* OBSOLETE 		    val = extract_signed_integer (&contents[ndx + 4], 4); */
/* OBSOLETE 		  else */
/* OBSOLETE 		    val = extract_signed_integer (&contents[ndx + 4], len - 4); */
/* OBSOLETE 		  write_register (regnum++, val); */
/* OBSOLETE 		} */
/* OBSOLETE 	      else */
/* OBSOLETE 		{ */
/* OBSOLETE 		  /* no more registers available.  put it on the stack */ */
/* OBSOLETE  */
/* OBSOLETE 		  /* all args > 4 bytes are padded to a multiple of 8 bytes */
/* OBSOLETE 		     and start on an 8 byte boundary */ */
/* OBSOLETE 		  if (sp & 7) */
/* OBSOLETE 		    sp -= (sp & 7);	/* align it */ */
/* OBSOLETE  */
/* OBSOLETE 		  sp -= ((len + 7) & ~7);	/* allocate space */ */
/* OBSOLETE 		  write_memory (sp, &contents[ndx], len); */
/* OBSOLETE 		  break; */
/* OBSOLETE 		} */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (regnum < 18) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      val = extract_signed_integer (contents, len); */
/* OBSOLETE 	      write_register (regnum++, val); */
/* OBSOLETE 	    } */
/* OBSOLETE 	  else */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* all args are padded to a multiple of 4 bytes (at least) */ */
/* OBSOLETE 	      sp -= ((len + 3) & ~3); */
/* OBSOLETE 	      write_memory (sp, contents, len); */
/* OBSOLETE 	    } */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   if (sp & 7) */
/* OBSOLETE     /* stack pointer is not on an 8 byte boundary -- align it */ */
/* OBSOLETE     sp -= (sp & 7); */
/* OBSOLETE   return sp; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* pick an out-of-the-way place to set the return value */ */
/* OBSOLETE /* for an inferior function call.  The link register is set to this  */ */
/* OBSOLETE /* value and a momentary breakpoint is set there.  When the breakpoint */ */
/* OBSOLETE /* is hit, the dummy frame is popped and the previous environment is */ */
/* OBSOLETE /* restored. */ */
/* OBSOLETE  */
/* OBSOLETE CORE_ADDR */
/* OBSOLETE d30v_call_dummy_address (void) */
/* OBSOLETE { */
/* OBSOLETE   CORE_ADDR entry; */
/* OBSOLETE   struct minimal_symbol *sym; */
/* OBSOLETE  */
/* OBSOLETE   entry = entry_point_address (); */
/* OBSOLETE  */
/* OBSOLETE   if (entry != 0) */
/* OBSOLETE     return entry; */
/* OBSOLETE  */
/* OBSOLETE   sym = lookup_minimal_symbol ("_start", NULL, symfile_objfile); */
/* OBSOLETE  */
/* OBSOLETE   if (!sym || MSYMBOL_TYPE (sym) != mst_text) */
/* OBSOLETE     return 0; */
/* OBSOLETE   else */
/* OBSOLETE     return SYMBOL_VALUE_ADDRESS (sym); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Given a return value in `regbuf' with a type `valtype',  */
/* OBSOLETE    extract and copy its value into `valbuf'.  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_extract_return_value (struct type *valtype, char regbuf[REGISTER_BYTES], */
/* OBSOLETE 			   char *valbuf) */
/* OBSOLETE { */
/* OBSOLETE   memcpy (valbuf, regbuf + REGISTER_BYTE (2), TYPE_LENGTH (valtype)); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* The following code implements access to, and display of, the D30V's */
/* OBSOLETE    instruction trace buffer.  The buffer consists of 64K or more */
/* OBSOLETE    4-byte words of data, of which each words includes an 8-bit count, */
/* OBSOLETE    an 8-bit segment number, and a 16-bit instruction address. */
/* OBSOLETE  */
/* OBSOLETE    In theory, the trace buffer is continuously capturing instruction */
/* OBSOLETE    data that the CPU presents on its "debug bus", but in practice, the */
/* OBSOLETE    ROMified GDB stub only enables tracing when it continues or steps */
/* OBSOLETE    the program, and stops tracing when the program stops; so it */
/* OBSOLETE    actually works for GDB to read the buffer counter out of memory and */
/* OBSOLETE    then read each trace word.  The counter records where the tracing */
/* OBSOLETE    stops, but there is no record of where it started, so we remember */
/* OBSOLETE    the PC when we resumed and then search backwards in the trace */
/* OBSOLETE    buffer for a word that includes that address.  This is not perfect, */
/* OBSOLETE    because you will miss trace data if the resumption PC is the target */
/* OBSOLETE    of a branch.  (The value of the buffer counter is semi-random, any */
/* OBSOLETE    trace data from a previous program stop is gone.)  */ */
/* OBSOLETE  */
/* OBSOLETE /* The address of the last word recorded in the trace buffer.  */ */
/* OBSOLETE  */
/* OBSOLETE #define DBBC_ADDR (0xd80000) */
/* OBSOLETE  */
/* OBSOLETE /* The base of the trace buffer, at least for the "Board_0".  */ */
/* OBSOLETE  */
/* OBSOLETE #define TRACE_BUFFER_BASE (0xf40000) */
/* OBSOLETE  */
/* OBSOLETE static void trace_command (char *, int); */
/* OBSOLETE  */
/* OBSOLETE static void untrace_command (char *, int); */
/* OBSOLETE  */
/* OBSOLETE static void trace_info (char *, int); */
/* OBSOLETE  */
/* OBSOLETE static void tdisassemble_command (char *, int); */
/* OBSOLETE  */
/* OBSOLETE static void display_trace (int, int); */
/* OBSOLETE  */
/* OBSOLETE /* True when instruction traces are being collected.  */ */
/* OBSOLETE  */
/* OBSOLETE static int tracing; */
/* OBSOLETE  */
/* OBSOLETE /* Remembered PC.  */ */
/* OBSOLETE  */
/* OBSOLETE static CORE_ADDR last_pc; */
/* OBSOLETE  */
/* OBSOLETE /* True when trace output should be displayed whenever program stops.  */ */
/* OBSOLETE  */
/* OBSOLETE static int trace_display; */
/* OBSOLETE  */
/* OBSOLETE /* True when trace listing should include source lines.  */ */
/* OBSOLETE  */
/* OBSOLETE static int default_trace_show_source = 1; */
/* OBSOLETE  */
/* OBSOLETE struct trace_buffer */
/* OBSOLETE   { */
/* OBSOLETE     int size; */
/* OBSOLETE     short *counts; */
/* OBSOLETE     CORE_ADDR *addrs; */
/* OBSOLETE   } */
/* OBSOLETE trace_data; */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE trace_command (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   /* Clear the host-side trace buffer, allocating space if needed.  */ */
/* OBSOLETE   trace_data.size = 0; */
/* OBSOLETE   if (trace_data.counts == NULL) */
/* OBSOLETE     trace_data.counts = (short *) xmalloc (65536 * sizeof (short)); */
/* OBSOLETE   if (trace_data.addrs == NULL) */
/* OBSOLETE     trace_data.addrs = (CORE_ADDR *) xmalloc (65536 * sizeof (CORE_ADDR)); */
/* OBSOLETE  */
/* OBSOLETE   tracing = 1; */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("Tracing is now on.\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE untrace_command (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   tracing = 0; */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("Tracing is now off.\n"); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE trace_info (char *args, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   int i; */
/* OBSOLETE  */
/* OBSOLETE   if (trace_data.size) */
/* OBSOLETE     { */
/* OBSOLETE       printf_filtered ("%d entries in trace buffer:\n", trace_data.size); */
/* OBSOLETE  */
/* OBSOLETE       for (i = 0; i < trace_data.size; ++i) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  printf_filtered ("%d: %d instruction%s at 0x%s\n", */
/* OBSOLETE 			   i, trace_data.counts[i], */
/* OBSOLETE 			   (trace_data.counts[i] == 1 ? "" : "s"), */
/* OBSOLETE 			   paddr_nz (trace_data.addrs[i])); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     printf_filtered ("No entries in trace buffer.\n"); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("Tracing is currently %s.\n", (tracing ? "on" : "off")); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Print the instruction at address MEMADDR in debugged memory, */
/* OBSOLETE    on STREAM.  Returns length of the instruction, in bytes.  */ */
/* OBSOLETE  */
/* OBSOLETE static int */
/* OBSOLETE print_insn (CORE_ADDR memaddr, struct ui_file *stream) */
/* OBSOLETE { */
/* OBSOLETE   /* If there's no disassembler, something is very wrong.  */ */
/* OBSOLETE   if (tm_print_insn == NULL) */
/* OBSOLETE     internal_error (__FILE__, __LINE__, */
/* OBSOLETE 		    "print_insn: no disassembler"); */
/* OBSOLETE  */
/* OBSOLETE   if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG) */
/* OBSOLETE     tm_print_insn_info.endian = BFD_ENDIAN_BIG; */
/* OBSOLETE   else */
/* OBSOLETE     tm_print_insn_info.endian = BFD_ENDIAN_LITTLE; */
/* OBSOLETE   return TARGET_PRINT_INSN (memaddr, &tm_print_insn_info); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_eva_prepare_to_trace (void) */
/* OBSOLETE { */
/* OBSOLETE   if (!tracing) */
/* OBSOLETE     return; */
/* OBSOLETE  */
/* OBSOLETE   last_pc = read_register (PC_REGNUM); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Collect trace data from the target board and format it into a form */
/* OBSOLETE    more useful for display.  */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_eva_get_trace_data (void) */
/* OBSOLETE { */
/* OBSOLETE   int count, i, j, oldsize; */
/* OBSOLETE   int trace_addr, trace_seg, trace_cnt, next_cnt; */
/* OBSOLETE   unsigned int last_trace, trace_word, next_word; */
/* OBSOLETE   unsigned int *tmpspace; */
/* OBSOLETE  */
/* OBSOLETE   if (!tracing) */
/* OBSOLETE     return; */
/* OBSOLETE  */
/* OBSOLETE   tmpspace = xmalloc (65536 * sizeof (unsigned int)); */
/* OBSOLETE  */
/* OBSOLETE   last_trace = read_memory_unsigned_integer (DBBC_ADDR, 2) << 2; */
/* OBSOLETE  */
/* OBSOLETE   /* Collect buffer contents from the target, stopping when we reach */
/* OBSOLETE      the word recorded when execution resumed.  */ */
/* OBSOLETE  */
/* OBSOLETE   count = 0; */
/* OBSOLETE   while (last_trace > 0) */
/* OBSOLETE     { */
/* OBSOLETE       QUIT; */
/* OBSOLETE       trace_word = */
/* OBSOLETE 	read_memory_unsigned_integer (TRACE_BUFFER_BASE + last_trace, 4); */
/* OBSOLETE       trace_addr = trace_word & 0xffff; */
/* OBSOLETE       last_trace -= 4; */
/* OBSOLETE       /* Ignore an apparently nonsensical entry.  */ */
/* OBSOLETE       if (trace_addr == 0xffd5) */
/* OBSOLETE 	continue; */
/* OBSOLETE       tmpspace[count++] = trace_word; */
/* OBSOLETE       if (trace_addr == last_pc) */
/* OBSOLETE 	break; */
/* OBSOLETE       if (count > 65535) */
/* OBSOLETE 	break; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* Move the data to the host-side trace buffer, adjusting counts to */
/* OBSOLETE      include the last instruction executed and transforming the address */
/* OBSOLETE      into something that GDB likes.  */ */
/* OBSOLETE  */
/* OBSOLETE   for (i = 0; i < count; ++i) */
/* OBSOLETE     { */
/* OBSOLETE       trace_word = tmpspace[i]; */
/* OBSOLETE       next_word = ((i == 0) ? 0 : tmpspace[i - 1]); */
/* OBSOLETE       trace_addr = trace_word & 0xffff; */
/* OBSOLETE       next_cnt = (next_word >> 24) & 0xff; */
/* OBSOLETE       j = trace_data.size + count - i - 1; */
/* OBSOLETE       trace_data.addrs[j] = (trace_addr << 2) + 0x1000000; */
/* OBSOLETE       trace_data.counts[j] = next_cnt + 1; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   oldsize = trace_data.size; */
/* OBSOLETE   trace_data.size += count; */
/* OBSOLETE  */
/* OBSOLETE   xfree (tmpspace); */
/* OBSOLETE  */
/* OBSOLETE   if (trace_display) */
/* OBSOLETE     display_trace (oldsize, trace_data.size); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE tdisassemble_command (char *arg, int from_tty) */
/* OBSOLETE { */
/* OBSOLETE   int i, count; */
/* OBSOLETE   CORE_ADDR low, high; */
/* OBSOLETE   char *space_index; */
/* OBSOLETE  */
/* OBSOLETE   if (!arg) */
/* OBSOLETE     { */
/* OBSOLETE       low = 0; */
/* OBSOLETE       high = trace_data.size; */
/* OBSOLETE     } */
/* OBSOLETE   else if (!(space_index = (char *) strchr (arg, ' '))) */
/* OBSOLETE     { */
/* OBSOLETE       low = parse_and_eval_address (arg); */
/* OBSOLETE       high = low + 5; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     { */
/* OBSOLETE       /* Two arguments.  */ */
/* OBSOLETE       *space_index = '\0'; */
/* OBSOLETE       low = parse_and_eval_address (arg); */
/* OBSOLETE       high = parse_and_eval_address (space_index + 1); */
/* OBSOLETE       if (high < low) */
/* OBSOLETE 	high = low; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("Dump of trace from %s to %s:\n", */
/* OBSOLETE 		   paddr_u (low), */
/* OBSOLETE 		   paddr_u (high)); */
/* OBSOLETE  */
/* OBSOLETE   display_trace (low, high); */
/* OBSOLETE  */
/* OBSOLETE   printf_filtered ("End of trace dump.\n"); */
/* OBSOLETE   gdb_flush (gdb_stdout); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE display_trace (int low, int high) */
/* OBSOLETE { */
/* OBSOLETE   int i, count, trace_show_source, first, suppress; */
/* OBSOLETE   CORE_ADDR next_address; */
/* OBSOLETE  */
/* OBSOLETE   trace_show_source = default_trace_show_source; */
/* OBSOLETE   if (!have_full_symbols () && !have_partial_symbols ()) */
/* OBSOLETE     { */
/* OBSOLETE       trace_show_source = 0; */
/* OBSOLETE       printf_filtered ("No symbol table is loaded.  Use the \"file\" command.\n"); */
/* OBSOLETE       printf_filtered ("Trace will not display any source.\n"); */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   first = 1; */
/* OBSOLETE   suppress = 0; */
/* OBSOLETE   for (i = low; i < high; ++i) */
/* OBSOLETE     { */
/* OBSOLETE       next_address = trace_data.addrs[i]; */
/* OBSOLETE       count = trace_data.counts[i]; */
/* OBSOLETE       while (count-- > 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  QUIT; */
/* OBSOLETE 	  if (trace_show_source) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      struct symtab_and_line sal, sal_prev; */
/* OBSOLETE  */
/* OBSOLETE 	      sal_prev = find_pc_line (next_address - 4, 0); */
/* OBSOLETE 	      sal = find_pc_line (next_address, 0); */
/* OBSOLETE  */
/* OBSOLETE 	      if (sal.symtab) */
/* OBSOLETE 		{ */
/* OBSOLETE 		  if (first || sal.line != sal_prev.line) */
/* OBSOLETE 		    print_source_lines (sal.symtab, sal.line, sal.line + 1, 0); */
/* OBSOLETE 		  suppress = 0; */
/* OBSOLETE 		} */
/* OBSOLETE 	      else */
/* OBSOLETE 		{ */
/* OBSOLETE 		  if (!suppress) */
/* OBSOLETE 		    /* FIXME-32x64--assumes sal.pc fits in long.  */ */
/* OBSOLETE 		    printf_filtered ("No source file for address %s.\n", */
/* OBSOLETE 				 local_hex_string ((unsigned long) sal.pc)); */
/* OBSOLETE 		  suppress = 1; */
/* OBSOLETE 		} */
/* OBSOLETE 	    } */
/* OBSOLETE 	  first = 0; */
/* OBSOLETE 	  print_address (next_address, gdb_stdout); */
/* OBSOLETE 	  printf_filtered (":"); */
/* OBSOLETE 	  printf_filtered ("\t"); */
/* OBSOLETE 	  wrap_here ("    "); */
/* OBSOLETE 	  next_address = next_address + print_insn (next_address, gdb_stdout); */
/* OBSOLETE 	  printf_filtered ("\n"); */
/* OBSOLETE 	  gdb_flush (gdb_stdout); */
/* OBSOLETE 	} */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE extern void (*target_resume_hook) (void); */
/* OBSOLETE extern void (*target_wait_loop_hook) (void); */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE _initialize_d30v_tdep (void) */
/* OBSOLETE { */
/* OBSOLETE   tm_print_insn = print_insn_d30v; */
/* OBSOLETE  */
/* OBSOLETE   target_resume_hook = d30v_eva_prepare_to_trace; */
/* OBSOLETE   target_wait_loop_hook = d30v_eva_get_trace_data; */
/* OBSOLETE  */
/* OBSOLETE   add_info ("flags", print_flags_command, "Print d30v flags."); */
/* OBSOLETE  */
/* OBSOLETE   add_com ("trace", class_support, trace_command, */
/* OBSOLETE 	   "Enable tracing of instruction execution."); */
/* OBSOLETE  */
/* OBSOLETE   add_com ("untrace", class_support, untrace_command, */
/* OBSOLETE 	   "Disable tracing of instruction execution."); */
/* OBSOLETE  */
/* OBSOLETE   add_com ("tdisassemble", class_vars, tdisassemble_command, */
/* OBSOLETE 	   "Disassemble the trace buffer.\n\ */
/* OBSOLETE Two optional arguments specify a range of trace buffer entries\n\ */
/* OBSOLETE as reported by info trace (NOT addresses!)."); */
/* OBSOLETE  */
/* OBSOLETE   add_info ("trace", trace_info, */
/* OBSOLETE 	    "Display info about the trace data buffer."); */
/* OBSOLETE  */
/* OBSOLETE   add_show_from_set (add_set_cmd ("tracedisplay", no_class, */
/* OBSOLETE 				  var_integer, (char *) &trace_display, */
/* OBSOLETE 			     "Set automatic display of trace.\n", &setlist), */
/* OBSOLETE 		     &showlist); */
/* OBSOLETE   add_show_from_set (add_set_cmd ("tracesource", no_class, */
/* OBSOLETE 			   var_integer, (char *) &default_trace_show_source, */
/* OBSOLETE 		      "Set display of source code with trace.\n", &setlist), */
/* OBSOLETE 		     &showlist); */
/* OBSOLETE  */
/* OBSOLETE } */
@


1.12
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d2 3
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d729 1
a729 1
      read_relative_register_raw_bytes (regnum, regbuf);
@


1.11
log
@2001-09-05  Elena Zannoni  <ezannoni@@redhat.com>

        * gdbarch.sh: Move include of dis-asm.h so it is generated earlier
        in gdbarch.h.
        (TARGET_PRINT_INSN): Multiarch.
        * gdbarch.h: Regenerate.
        * gdbarch.c: Regenerate.

        * arch-utils.c (legacy_print_insn): New function.
        * arch-utils.h (legacy_print_insn): Export.

        * cris-tdep.c (cris_delayed_get_disassembler): Use
        TARGET_PRINT_INSN, instead of tm_print_insn.
        * d10v-tdep.c (print_insn): Ditto.
        * d30v-tdep.c (print_insn): Ditto.
        * m32r-tdep.c (dump_insn): Ditto.
        * v850-tdep.c (v850_scan_prologue): Ditto.
        * mcore-tdep.c (mcore_dump_insn): Ditto.
        * sh-tdep.c (sh_gdbarch_init): Set print_insn gdbarch field.
@
text
@d1155 1
a1155 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
@


1.10
log
@s/value_ptr/struct value */
@
text
@d1159 1
a1159 1
  return (*tm_print_insn) (memaddr, &tm_print_insn_info);
@


1.9
log
@Update/correct copyright notices.
@
text
@d872 2
a873 1
		     int nargs, value_ptr *args, struct type *type, int gcc_p)
d911 1
a911 1
d30v_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
d923 1
a923 1
      value_ptr arg = args[i];
d941 1
a941 1
      value_ptr arg = args[i];
@


1.8
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 2000, 2001 Free Software Foundation, Inc.
@


1.7
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d36 1
@


1.6
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 2000 Free Software Foundation, Inc.
d1149 2
a1150 1
    internal_error ("print_insn: no disassembler");
@


1.5
log
@Protoization.
@
text
@d1224 1
a1224 1
  free (tmpspace);
@


1.4
log
@Protoization.
@
text
@d100 1
a100 3
d30v_frame_chain_valid (chain, fi)
     CORE_ADDR chain;
     struct frame_info *fi;	/* not used here */
d1029 2
a1030 4
d30v_extract_return_value (valtype, regbuf, valbuf)
     struct type *valtype;
     char regbuf[REGISTER_BYTES];
     char *valbuf;
@


1.3
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d115 1
a115 1
d30v_pop_frame ()
d162 1
a162 2
check_prologue (op)
     unsigned long op;
d236 1
a236 2
d30v_skip_prologue (pc)
     CORE_ADDR pc;
d321 1
a321 2
d30v_frame_chain (frame)
     struct frame_info *frame;
d351 2
a352 4
prologue_find_regs (op, fsr, addr)
     unsigned long op;
     struct frame_saved_regs *fsr;
     CORE_ADDR addr;
d501 1
a501 3
d30v_frame_find_saved_regs (fi, fsr)
     struct frame_info *fi;
     struct frame_saved_regs *fsr;
d552 2
a553 3
d30v_frame_find_saved_regs_offsets (fi, fsr)
     struct frame_info *fi;
     struct frame_saved_regs *fsr;
d672 1
a672 3
d30v_init_extra_frame_info (fromleaf, fi)
     int fromleaf;
     struct frame_info *fi;
d702 1
a702 3
d30v_init_frame_pc (fromleaf, prev)
     int fromleaf;
     struct frame_info *prev;
d713 1
a713 3
d30v_print_register (regnum, tabular)
     int regnum;
     int tabular;
d743 1
a743 1
d30v_print_flags ()
d767 1
a767 3
print_flags_command (args, from_tty)
     char *args;
     int from_tty;
d773 1
a773 3
d30v_do_registers_info (regnum, fpregs)
     int regnum;
     int fpregs;
d871 2
a872 8
d30v_fix_call_dummy (dummyname, start_sp, fun, nargs, args, type, gcc_p)
     char *dummyname;
     CORE_ADDR start_sp;
     CORE_ADDR fun;
     int nargs;
     value_ptr *args;
     struct type *type;
     int gcc_p;
d895 1
a895 2
d30v_pop_dummy_frame (fi)
     struct frame_info *fi;
d910 2
a911 6
d30v_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     int struct_return;
     CORE_ADDR struct_addr;
d1009 1
a1009 1
d30v_call_dummy_address ()
d1100 1
a1100 3
trace_command (args, from_tty)
     char *args;
     int from_tty;
d1115 1
a1115 3
untrace_command (args, from_tty)
     char *args;
     int from_tty;
d1123 1
a1123 3
trace_info (args, from_tty)
     char *args;
     int from_tty;
d1149 1
a1149 3
print_insn (memaddr, stream)
     CORE_ADDR memaddr;
     struct ui_file *stream;
d1163 1
a1163 1
d30v_eva_prepare_to_trace ()
d1175 1
a1175 1
d30v_eva_get_trace_data ()
d1235 1
a1235 3
tdisassemble_command (arg, from_tty)
     char *arg;
     int from_tty;
d1272 1
a1272 2
display_trace (low, high)
     int low, high;
d1332 1
a1332 1
_initialize_d30v_tdep ()
@


1.2
log
@PARAMS removal.
@
text
@d1368 2
a1369 2
extern void (*target_resume_hook) PARAMS ((void));
extern void (*target_wait_loop_hook) PARAMS ((void));
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997 Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d33 1
a33 1
#include "dis-asm.h"  
d37 9
a45 7
void d30v_frame_find_saved_regs PARAMS ((struct frame_info *fi,
					 struct frame_saved_regs *fsr));
void d30v_frame_find_saved_regs_offsets PARAMS ((struct frame_info *fi,
						 struct frame_saved_regs *fsr));
static void d30v_pop_dummy_frame PARAMS ((struct frame_info *fi));
static void d30v_print_flags PARAMS ((void));
static void print_flags_command PARAMS ((char *, int));
d51 1
a51 1
#define OP_MASK_ALL_BUT_RA	0x0ffc0fff /* throw away Ra, keep the rest */
d53 19
a71 19
#define OP_STW_SPM		0x054c0fc0 /* stw Ra, @@(sp-) */
#define OP_STW_SP_R0		0x05400fc0 /* stw Ra, @@(sp,r0) */
#define OP_STW_SP_IMM0		0x05480fc0 /* st Ra, @@(sp, 0x0) */
#define OP_STW_R22P_R0		0x05440580 /* stw Ra, @@(r22+,r0) */

#define OP_ST2W_SPM		0x056c0fc0 /* st2w Ra, @@(sp-) */
#define OP_ST2W_SP_R0		0x05600fc0 /* st2w Ra, @@(sp, r0) */
#define OP_ST2W_SP_IMM0		0x05680fc0 /* st2w Ra, @@(sp, 0x0) */
#define OP_ST2W_R22P_R0		0x05640580 /* st2w Ra, @@(r22+, r0) */

#define OP_MASK_OPCODE		0x0ffc0000 /* just the opcode, ign operands */
#define OP_NOP			0x00f00000 /* nop */

#define OP_MASK_ALL_BUT_IMM	0x0fffffc0 /* throw away imm, keep the rest */
#define OP_SUB_SP_IMM		0x082bffc0 /* sub sp,sp,imm */
#define OP_ADD_SP_IMM		0x080bffc0 /* add sp,sp,imm */
#define OP_ADD_R22_SP_IMM	0x08096fc0 /* add r22,sp,imm */
#define OP_STW_FP_SP_IMM	0x054bdfc0 /* stw fp,@@(sp,imm) */
#define OP_OR_SP_R0_IMM		0x03abf000 /* or sp,r0,imm */
d74 11
a84 11
#define OP_OR_FP_R0_SP		0x03a3d03f /* or fp,r0,sp */
#define OP_OR_FP_SP_R0		0x03a3dfc0 /* or fp,sp,r0 */
#define OP_OR_FP_IMM0_SP	0x03abd03f /* or fp,0x0,sp */
#define OP_STW_FP_R22P_R0	0x0547d580 /* stw fp,@@(r22+,r0) */
#define OP_STW_LR_R22P_R0	0x0547e580 /* stw lr,@@(r22+,r0) */

#define OP_MASK_OP_AND_RB	0x0ff80fc0 /* keep op and rb,throw away rest */
#define OP_STW_SP_IMM		0x05480fc0 /* stw Ra,@@(sp,imm) */
#define OP_ST2W_SP_IMM		0x05680fc0 /* st2w Ra,@@(sp,imm) */
#define OP_STW_FP_IMM		0x05480f40 /* stw Ra,@@(fp,imm) */
#define OP_STW_FP_R0		0x05400f40 /* stw Ra,@@(fp,r0) */
d102 1
a102 1
     struct frame_info *fi;      /* not used here */
d126 1
a126 1
      d30v_pop_dummy_frame(frame);
d133 1
a133 1
  
d135 1
a135 1
  for (regnum = A0_REGNUM; regnum < A0_REGNUM+2 ; regnum++)
d155 1
a155 1
  write_register (PC_REGNUM, read_register(LR_REGNUM));
d161 1
a161 1
static int 
d190 2
a191 2
 if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_R0)
   return 1;
d194 22
a215 2
 if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_IMM0)
   return 1;
d217 3
a219 23
 /* stw fp, @@(r22+,r0) -- observed */
 if (op == OP_STW_FP_R22P_R0)
   return 1;

 /* stw r62, @@(r22+,r0) -- observed */
 if (op == OP_STW_LR_R22P_R0)
   return 1;

 /* stw Ra, @@(fp,r0) -- observed */
 if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_FP_R0)
   return 1;			/* first arg */

 /* stw Ra, @@(fp,imm) -- observed */
 if ((op & OP_MASK_OP_AND_RB) == OP_STW_FP_IMM)
   return 1;			/* second and subsequent args */

 /* stw fp,@@(sp,imm) -- observed */
 if ((op & OP_MASK_ALL_BUT_IMM) == OP_STW_FP_SP_IMM)
   return 1;

 /* st2w Ra,@@(r22+,r0) */
 if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_R22P_R0)
   return 1;
d253 1
a253 1
      if ( sal.end && sal.end < func_end)
d256 2
a257 2
  
  if (target_read_memory (pc, (char *)&op[0], 8))
d262 2
a263 2
      opl = (unsigned long)read_memory_integer (pc, 4);
      opr = (unsigned long)read_memory_integer (pc+4, 4);
d277 4
a280 4
	  if (((opl & OP_MASK_ALL_BUT_IMM) != OP_ADD_SP_IMM) && /* add sp,sp,imm */
	      ((opl & OP_MASK_ALL_BUT_IMM) != OP_ADD_R22_SP_IMM) && /* add r22,sp,imm */
	      ((opl & OP_MASK_OP_AND_RB) != OP_STW_SP_IMM) && /* stw Ra, @@(sp,imm) */
	      ((opl & OP_MASK_OP_AND_RB) != OP_ST2W_SP_IMM)) /* st2w Ra, @@(sp,imm) */
d290 2
a291 2
	    } 
	  else 
d296 1
a296 1
	  if (check_prologue(op1))
d298 1
a298 1
	      if (!check_prologue(op2))
d320 1
a320 1
*/
d331 1
a331 1
    return (CORE_ADDR)0;
d334 1
a334 1
    return (CORE_ADDR)0;
d339 2
a340 2
	return (CORE_ADDR)0;
      
d344 2
a345 2
  if (!read_memory_unsigned_integer(fsr.regs[FP_REGNUM],4))
    return (CORE_ADDR)0;
d347 2
a348 2
  return read_memory_unsigned_integer(fsr.regs[FP_REGNUM],4);
}  
d353 1
a353 1
static int 
d365 2
a366 2
      offset = EXTRACT_IMM6(op);
      /*next_addr += offset;*/
d374 1
a374 1
      offset = EXTRACT_IMM6(op);
d382 2
a383 2
      n = EXTRACT_RA(op);
      offset = EXTRACT_IMM6(op);
d391 2
a392 2
      n = EXTRACT_RA(op);
      fsr->regs[n] = (- frame_size);
d412 1
a412 1
      n = EXTRACT_RA(op);
d421 1
a421 1
      fsr->regs[FP_REGNUM] = next_addr;	/* XXX */
d437 1
a437 1
      n = EXTRACT_RA(op);
d439 1
a439 1
      fsr->regs[n+1] = next_addr + 4;
d447 1
a447 1
      n = EXTRACT_RA(op);
d456 1
a456 1
      n = EXTRACT_RA(op);
d458 1
a458 1
      fsr->regs[n+1] = next_addr+4;
d466 1
a466 1
      offset = EXTRACT_IMM6(op);
d475 2
a476 2
      n = EXTRACT_RA(op);
      fsr->regs[n] = (- frame_size);
d484 3
a486 3
      n = EXTRACT_RA(op);
      fsr->regs[n] = (- frame_size);
      fsr->regs[n+1] = (- frame_size) + 4;
d493 1
a493 1
      offset = EXTRACT_IMM6(op);
d525 1
a525 1
  
d529 1
a529 1
    fp = read_register(SP_REGNUM);
d531 1
a531 1
  for (i=0; i<NUM_REGS-1; i++)
d538 1
a538 1
    fi->return_pc = read_memory_unsigned_integer(fsr->regs[LR_REGNUM],4);
d540 2
a541 2
    fi->return_pc = read_register(LR_REGNUM);
  
d548 1
a548 1
	fsr->regs[SP_REGNUM] = read_register(FP_REGNUM) + fi->size;
d580 2
a581 2
      opl = (unsigned long)read_memory_integer (pc, 4);
      opr = (unsigned long)read_memory_integer (pc+4, 4);
d595 1
a595 1
	      long offset = EXTRACT_IMM32(opl, opr);
d601 1
a601 1
	      long offset = EXTRACT_IMM32(opl,opr);
d607 2
a608 2
	      long offset = EXTRACT_IMM32(opl, opr);
	      short n = EXTRACT_RA(opl);
d614 2
a615 2
	      long offset = EXTRACT_IMM32(opl, opr);
	      short n = EXTRACT_RA(opl);
d617 1
a617 1
	      fsr->regs[n+1] = (offset - frame_size) + 4;
d633 2
a634 2
	    } 
	  else 
d639 1
a639 1
	  if (!prologue_find_regs(op1,fsr,pc) || !prologue_find_regs(op2,fsr,pc))
d644 1
a644 1
  
d649 1
a649 1
    fp = read_register(SP_REGNUM);
d651 1
a651 1
  for (i=0; i<NUM_REGS-1; i++)
d658 1
a658 1
    fi->return_pc = read_memory_unsigned_integer(fsr->regs[LR_REGNUM],4);
d660 2
a661 2
    fi->return_pc = read_register(LR_REGNUM);
  
d668 1
a668 1
	fsr->regs[SP_REGNUM] = read_register(FP_REGNUM) + fi->size;
d687 1
a687 1
    fi->pc = fi->next->return_pc; 
d705 1
a705 1
      fi->return_pc = read_memory_unsigned_integer(dummy.regs[LR_REGNUM],4);
d708 1
a708 1
    fi->return_pc = read_register(LR_REGNUM);
d722 1
a722 1
static void d30v_print_register PARAMS ((int regnum, int tabular));
d732 1
a732 1
	printf_filtered ("%08x", read_register (regnum));
d734 3
a736 2
	printf_filtered ("0x%x	%d", read_register (regnum),
			 read_register (regnum));
d751 1
a751 1
		 gdb_stdout, 'd', 1, 0, Val_pretty_default);
d903 1
a903 1
  /*start_sp |= DMEM_START;*/
d908 3
a910 3
      sp -= REGISTER_RAW_SIZE(regnum);
      store_address (buffer, REGISTER_RAW_SIZE(regnum), read_register(regnum));
      write_memory (sp, buffer, REGISTER_RAW_SIZE(regnum));
d912 1
a912 1
  write_register (SP_REGNUM, (LONGEST)sp);
d914 1
a914 1
  write_register (LR_REGNUM, (LONGEST)d30v_call_dummy_address());  
d927 2
a928 2
      sp -= REGISTER_RAW_SIZE(regnum);
      write_register(regnum, read_memory_unsigned_integer (sp, REGISTER_RAW_SIZE(regnum)));
d930 1
a930 1
  flush_cached_frames (); /* needed? */
d942 1
a942 1
  int i, len, index=0, regnum=2;
d954 1
a954 1
      contents = VALUE_CONTENTS(arg);
d972 1
a972 1
      contents = VALUE_CONTENTS(arg);
d989 1
a989 1
		    val = extract_signed_integer (&contents[ndx+4], 4);
d991 1
a991 1
		    val = extract_signed_integer (&contents[ndx+4], len-4);
d999 1
a999 1
		   and start on an 8 byte boundary */
d1001 1
a1001 1
		    sp -= (sp & 7); /* align it */
d1003 1
a1003 1
		  sp -= ((len + 7) & ~7); /* allocate space */
d1011 1
a1011 1
	  if (regnum < 18 )
d1094 1
a1094 1
static void trace_command PARAMS ((char *, int));
d1096 1
a1096 1
static void untrace_command PARAMS ((char *, int));
d1098 1
a1098 1
static void trace_info PARAMS ((char *, int));
d1100 1
a1100 1
static void tdisassemble_command PARAMS ((char *, int));
d1102 1
a1102 1
static void display_trace PARAMS ((int, int));
d1120 7
a1126 5
struct trace_buffer {
  int size;
  short *counts;
  CORE_ADDR *addrs;
} trace_data;
d1136 1
a1136 1
    trace_data.counts = (short *) xmalloc (65536 * sizeof(short));
d1138 1
a1138 1
    trace_data.addrs = (CORE_ADDR *) xmalloc (65536 * sizeof(CORE_ADDR));
d1168 1
a1168 1
	  printf_filtered ("%d: %d instruction%s at 0x%x\n",
d1171 1
a1171 1
			   trace_data.addrs[i]);
d1186 1
a1186 1
     GDB_FILE *stream;
d1190 1
a1190 1
    abort ();
d1222 1
a1222 1
  tmpspace = xmalloc (65536 * sizeof(unsigned int));
d1300 3
a1302 1
  printf_filtered ("Dump of trace from %d to %d:\n", low, high);
d1318 1
a1318 1
  if (!have_full_symbols () && !have_partial_symbols())
d1330 1
a1330 1
      count = trace_data.counts[i]; 
d1352 1
a1352 1
				     local_hex_string((unsigned long) sal.pc));
d1385 1
a1385 1
 	   "Disable tracing of instruction execution.");
d1396 2
a1397 2
				  var_integer, (char *)&trace_display,
				  "Set automatic display of trace.\n", &setlist),
d1400 2
a1401 2
				  var_integer, (char *)&default_trace_show_source,
				  "Set display of source code with trace.\n", &setlist),
d1404 1
a1404 1
} 
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d32 1
a32 1
#include "dis-asm.h"
d36 5
a40 5
void d30v_frame_find_saved_regs PARAMS ((struct frame_info * fi,
					 struct frame_saved_regs * fsr));
void d30v_frame_find_saved_regs_offsets PARAMS ((struct frame_info * fi,
					    struct frame_saved_regs * fsr));
static void d30v_pop_dummy_frame PARAMS ((struct frame_info * fi));
d48 1
a48 1
#define OP_MASK_ALL_BUT_RA	0x0ffc0fff	/* throw away Ra, keep the rest */
d50 19
a68 19
#define OP_STW_SPM		0x054c0fc0	/* stw Ra, @@(sp-) */
#define OP_STW_SP_R0		0x05400fc0	/* stw Ra, @@(sp,r0) */
#define OP_STW_SP_IMM0		0x05480fc0	/* st Ra, @@(sp, 0x0) */
#define OP_STW_R22P_R0		0x05440580	/* stw Ra, @@(r22+,r0) */

#define OP_ST2W_SPM		0x056c0fc0	/* st2w Ra, @@(sp-) */
#define OP_ST2W_SP_R0		0x05600fc0	/* st2w Ra, @@(sp, r0) */
#define OP_ST2W_SP_IMM0		0x05680fc0	/* st2w Ra, @@(sp, 0x0) */
#define OP_ST2W_R22P_R0		0x05640580	/* st2w Ra, @@(r22+, r0) */

#define OP_MASK_OPCODE		0x0ffc0000	/* just the opcode, ign operands */
#define OP_NOP			0x00f00000	/* nop */

#define OP_MASK_ALL_BUT_IMM	0x0fffffc0	/* throw away imm, keep the rest */
#define OP_SUB_SP_IMM		0x082bffc0	/* sub sp,sp,imm */
#define OP_ADD_SP_IMM		0x080bffc0	/* add sp,sp,imm */
#define OP_ADD_R22_SP_IMM	0x08096fc0	/* add r22,sp,imm */
#define OP_STW_FP_SP_IMM	0x054bdfc0	/* stw fp,@@(sp,imm) */
#define OP_OR_SP_R0_IMM		0x03abf000	/* or sp,r0,imm */
d71 11
a81 11
#define OP_OR_FP_R0_SP		0x03a3d03f	/* or fp,r0,sp */
#define OP_OR_FP_SP_R0		0x03a3dfc0	/* or fp,sp,r0 */
#define OP_OR_FP_IMM0_SP	0x03abd03f	/* or fp,0x0,sp */
#define OP_STW_FP_R22P_R0	0x0547d580	/* stw fp,@@(r22+,r0) */
#define OP_STW_LR_R22P_R0	0x0547e580	/* stw lr,@@(r22+,r0) */

#define OP_MASK_OP_AND_RB	0x0ff80fc0	/* keep op and rb,throw away rest */
#define OP_STW_SP_IMM		0x05480fc0	/* stw Ra,@@(sp,imm) */
#define OP_ST2W_SP_IMM		0x05680fc0	/* st2w Ra,@@(sp,imm) */
#define OP_STW_FP_IMM		0x05480f40	/* stw Ra,@@(fp,imm) */
#define OP_STW_FP_R0		0x05400f40	/* stw Ra,@@(fp,r0) */
d99 1
a99 1
     struct frame_info *fi;	/* not used here */
d123 1
a123 1
      d30v_pop_dummy_frame (frame);
d130 1
a130 1

d132 1
a132 1
  for (regnum = A0_REGNUM; regnum < A0_REGNUM + 2; regnum++)
d152 1
a152 1
  write_register (PC_REGNUM, read_register (LR_REGNUM));
d158 1
a158 1
static int
d187 2
a188 2
  if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_R0)
    return 1;
d191 2
a192 2
  if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_SP_IMM0)
    return 1;
d194 23
a216 23
  /* stw fp, @@(r22+,r0) -- observed */
  if (op == OP_STW_FP_R22P_R0)
    return 1;

  /* stw r62, @@(r22+,r0) -- observed */
  if (op == OP_STW_LR_R22P_R0)
    return 1;

  /* stw Ra, @@(fp,r0) -- observed */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_STW_FP_R0)
    return 1;			/* first arg */

  /* stw Ra, @@(fp,imm) -- observed */
  if ((op & OP_MASK_OP_AND_RB) == OP_STW_FP_IMM)
    return 1;			/* second and subsequent args */

  /* stw fp,@@(sp,imm) -- observed */
  if ((op & OP_MASK_ALL_BUT_IMM) == OP_STW_FP_SP_IMM)
    return 1;

  /* st2w Ra,@@(r22+,r0) */
  if ((op & OP_MASK_ALL_BUT_RA) == OP_ST2W_R22P_R0)
    return 1;
d250 1
a250 1
      if (sal.end && sal.end < func_end)
d253 2
a254 2

  if (target_read_memory (pc, (char *) &op[0], 8))
d259 2
a260 2
      opl = (unsigned long) read_memory_integer (pc, 4);
      opr = (unsigned long) read_memory_integer (pc + 4, 4);
d274 4
a277 4
	  if (((opl & OP_MASK_ALL_BUT_IMM) != OP_ADD_SP_IMM) &&		/* add sp,sp,imm */
	      ((opl & OP_MASK_ALL_BUT_IMM) != OP_ADD_R22_SP_IMM) &&	/* add r22,sp,imm */
	      ((opl & OP_MASK_OP_AND_RB) != OP_STW_SP_IMM) &&	/* stw Ra, @@(sp,imm) */
	      ((opl & OP_MASK_OP_AND_RB) != OP_ST2W_SP_IMM))	/* st2w Ra, @@(sp,imm) */
d287 2
a288 2
	    }
	  else
d293 1
a293 1
	  if (check_prologue (op1))
d295 1
a295 1
	      if (!check_prologue (op2))
d317 1
a317 1
 */
d328 1
a328 1
    return (CORE_ADDR) 0;
d331 1
a331 1
    return (CORE_ADDR) 0;
d336 2
a337 2
	return (CORE_ADDR) 0;

d341 2
a342 2
  if (!read_memory_unsigned_integer (fsr.regs[FP_REGNUM], 4))
    return (CORE_ADDR) 0;
d344 2
a345 2
  return read_memory_unsigned_integer (fsr.regs[FP_REGNUM], 4);
}
d350 1
a350 1
static int
d362 2
a363 2
      offset = EXTRACT_IMM6 (op);
      /*next_addr += offset; */
d371 1
a371 1
      offset = EXTRACT_IMM6 (op);
d379 2
a380 2
      n = EXTRACT_RA (op);
      offset = EXTRACT_IMM6 (op);
d388 2
a389 2
      n = EXTRACT_RA (op);
      fsr->regs[n] = (-frame_size);
d409 1
a409 1
      n = EXTRACT_RA (op);
d418 1
a418 1
      fsr->regs[FP_REGNUM] = next_addr;		/* XXX */
d434 1
a434 1
      n = EXTRACT_RA (op);
d436 1
a436 1
      fsr->regs[n + 1] = next_addr + 4;
d444 1
a444 1
      n = EXTRACT_RA (op);
d453 1
a453 1
      n = EXTRACT_RA (op);
d455 1
a455 1
      fsr->regs[n + 1] = next_addr + 4;
d463 1
a463 1
      offset = EXTRACT_IMM6 (op);
d472 2
a473 2
      n = EXTRACT_RA (op);
      fsr->regs[n] = (-frame_size);
d481 3
a483 3
      n = EXTRACT_RA (op);
      fsr->regs[n] = (-frame_size);
      fsr->regs[n + 1] = (-frame_size) + 4;
d490 1
a490 1
      offset = EXTRACT_IMM6 (op);
d522 1
a522 1

d526 1
a526 1
    fp = read_register (SP_REGNUM);
d528 1
a528 1
  for (i = 0; i < NUM_REGS - 1; i++)
d535 1
a535 1
    fi->return_pc = read_memory_unsigned_integer (fsr->regs[LR_REGNUM], 4);
d537 2
a538 2
    fi->return_pc = read_register (LR_REGNUM);

d545 1
a545 1
	fsr->regs[SP_REGNUM] = read_register (FP_REGNUM) + fi->size;
d577 2
a578 2
      opl = (unsigned long) read_memory_integer (pc, 4);
      opr = (unsigned long) read_memory_integer (pc + 4, 4);
d592 1
a592 1
	      long offset = EXTRACT_IMM32 (opl, opr);
d598 1
a598 1
	      long offset = EXTRACT_IMM32 (opl, opr);
d604 2
a605 2
	      long offset = EXTRACT_IMM32 (opl, opr);
	      short n = EXTRACT_RA (opl);
d611 2
a612 2
	      long offset = EXTRACT_IMM32 (opl, opr);
	      short n = EXTRACT_RA (opl);
d614 1
a614 1
	      fsr->regs[n + 1] = (offset - frame_size) + 4;
d630 2
a631 2
	    }
	  else
d636 1
a636 1
	  if (!prologue_find_regs (op1, fsr, pc) || !prologue_find_regs (op2, fsr, pc))
d641 1
a641 1

d646 1
a646 1
    fp = read_register (SP_REGNUM);
d648 1
a648 1
  for (i = 0; i < NUM_REGS - 1; i++)
d655 1
a655 1
    fi->return_pc = read_memory_unsigned_integer (fsr->regs[LR_REGNUM], 4);
d657 2
a658 2
    fi->return_pc = read_register (LR_REGNUM);

d665 1
a665 1
	fsr->regs[SP_REGNUM] = read_register (FP_REGNUM) + fi->size;
d684 1
a684 1
    fi->pc = fi->next->return_pc;
d702 1
a702 1
      fi->return_pc = read_memory_unsigned_integer (dummy.regs[LR_REGNUM], 4);
d705 1
a705 1
    fi->return_pc = read_register (LR_REGNUM);
d747 1
a747 1
		     gdb_stdout, 'd', 1, 0, Val_pretty_default);
d899 1
a899 1
  /*start_sp |= DMEM_START; */
d904 3
a906 3
      sp -= REGISTER_RAW_SIZE (regnum);
      store_address (buffer, REGISTER_RAW_SIZE (regnum), read_register (regnum));
      write_memory (sp, buffer, REGISTER_RAW_SIZE (regnum));
d908 1
a908 1
  write_register (SP_REGNUM, (LONGEST) sp);
d910 1
a910 1
  write_register (LR_REGNUM, (LONGEST) d30v_call_dummy_address ());
d923 2
a924 2
      sp -= REGISTER_RAW_SIZE (regnum);
      write_register (regnum, read_memory_unsigned_integer (sp, REGISTER_RAW_SIZE (regnum)));
d926 1
a926 1
  flush_cached_frames ();	/* needed? */
d938 1
a938 1
  int i, len, index = 0, regnum = 2;
d950 1
a950 1
      contents = VALUE_CONTENTS (arg);
d968 1
a968 1
      contents = VALUE_CONTENTS (arg);
d985 1
a985 1
		    val = extract_signed_integer (&contents[ndx + 4], 4);
d987 1
a987 1
		    val = extract_signed_integer (&contents[ndx + 4], len - 4);
d995 1
a995 1
		     and start on an 8 byte boundary */
d997 1
a997 1
		    sp -= (sp & 7);	/* align it */
d999 1
a999 1
		  sp -= ((len + 7) & ~7);	/* allocate space */
d1007 1
a1007 1
	  if (regnum < 18)
d1116 5
a1120 7
struct trace_buffer
  {
    int size;
    short *counts;
    CORE_ADDR *addrs;
  }
trace_data;
d1130 1
a1130 1
    trace_data.counts = (short *) xmalloc (65536 * sizeof (short));
d1132 1
a1132 1
    trace_data.addrs = (CORE_ADDR *) xmalloc (65536 * sizeof (CORE_ADDR));
d1216 1
a1216 1
  tmpspace = xmalloc (65536 * sizeof (unsigned int));
d1310 1
a1310 1
  if (!have_full_symbols () && !have_partial_symbols ())
d1322 1
a1322 1
      count = trace_data.counts[i];
d1344 1
a1344 1
				 local_hex_string ((unsigned long) sal.pc));
d1377 1
a1377 1
	   "Disable tracing of instruction execution.");
d1388 2
a1389 2
				  var_integer, (char *) &trace_display,
			     "Set automatic display of trace.\n", &setlist),
d1392 2
a1393 2
			   var_integer, (char *) &default_trace_show_source,
		      "Set display of source code with trace.\n", &setlist),
d1396 1
a1396 1
}
@


1.1.1.3
log
@import gdb-1999-09-08 snapshot
@
text
@a36 2
#include "language.h" /* For local_hex_string() */

d730 1
a730 1
	printf_filtered ("%08lx", (long) read_register (regnum));
d732 2
a733 3
	printf_filtered ("0x%lx	%ld",
			 (long) read_register (regnum),
			 (long) read_register (regnum));
d1165 1
a1165 1
	  printf_filtered ("%d: %d instruction%s at 0x%s\n",
d1168 1
a1168 1
			   paddr_nz (trace_data.addrs[i]));
d1297 1
a1297 3
  printf_filtered ("Dump of trace from %s to %s:\n",
		   paddr_u (low),
		   paddr_u (high));
@


1.1.1.4
log
@import gdb-1999-11-08 snapshot
@
text
@d1190 1
a1190 1
    internal_error ("print_insn: no disassembler");
@


1.1.1.5
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 2000 Free Software Foundation, Inc.
d1186 1
a1186 1
     struct ui_file *stream;
@


