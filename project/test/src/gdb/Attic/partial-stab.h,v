head	1.15;
access;
symbols
	gdb_5_1_1-2002-01-24-release:1.11.4.2
	gdb_5_1_0_1-2002-01-03-release:1.11.4.2
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11.4.2
	gdb_5_1_0_1-2002-01-03-branch:1.11.4.2.0.2
	gdb_5_1-2001-11-21-release:1.11.4.2
	gdb_s390-2001-09-26-branch:1.11.4.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.11.4.1
	gdb_5_1-2001-07-29-branch:1.11.0.4
	gdb_5_1-2001-07-29-branchpoint:1.11
	dberlin-typesystem-branch:1.11.0.2
	dberlin-typesystem-branchpoint:1.11
	gdb-post-ptid_t-2001-05-03:1.7
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.5
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.6
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.6
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.15
date	2001.11.08.04.58.40;	author ezannoni;	state dead;
branches;
next	1.14;

1.14
date	2001.10.24.17.10.18;	author jimb;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.06.20.50.48;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.15.05.02.28;	author hjl;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.01.21.17.50;	author jimb;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.06.01.20.37.11;	author jimb;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.31.03.41.31;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.31.02.58.57;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.06.08.21.11;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.19.20.15.42;	author ezannoni;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.11.01.47.47;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.10.18.26.56;	author ezannoni;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.04.16.52.33;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.28.17.44.53;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.06.14.18.07.54;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.08.40;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.09.21.33.44;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.09.08.23.59.24;	author shebs;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.22.03.24.51;	author jsm;	state Exp;
branches;
next	;

1.11.4.1
date	2001.08.16.22.25.20;	author drow;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2001.10.15.20.38.14;	author kevinb;	state Exp;
branches;
next	;


desc
@@


1.15
log
@2001-10-30  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (set_namestring): New function, replacing the
 	SET_NAMESTRING macro.
 	(SET_NAMESTRING, CUR_SYMBOL_TYPE, CUR_SYMBOL_VALUE,
 	CUR_SYMBOL_STRX, DBXREAD_ONLY, START_PSYMTAB, END_PSYMTAB): Delete
 	definitions.
 	(read_dbx_symtab): Don't include partial-stab.h any more. Don't
 	reuse code in partial-stab.h, include the code directly, instead.

         * Makefile.in (dbxread.o): Remove dependency on partial-stab.h.
 	(HFILES_NO_SRCDIR): Remove partial-stab.h.

 	* partial-stab.h: Remove file.
@
text
@/* Shared code to pre-read a stab (dbx-style), when building a psymtab.
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* The following need to be defined:
   SET_NAMESTRING() --Set namestring to name of symbol.
   CUR_SYMBOL_TYPE --Type code of current symbol.
   CUR_SYMBOL_VALUE --Value field of current symbol.  May be adjusted here.
   namestring - variable pointing to the name of the stab.
   pst - the partial symbol table being built.

   psymtab_include_list, includes_used, includes_allocated - list of include
   file names (N_SOL) seen so far.
   dependency_list, dependencies_used, dependencies_allocated - list of
   N_EXCL stabs seen so far.

   END_PSYMTAB -- end a partial symbol table.
   START_PSYMTAB -- start a partial symbol table.
 */

/* End of macro definitions, now let's handle them symbols!  */

switch (CUR_SYMBOL_TYPE)
  {
    static struct complaint function_outside_compilation_unit = {
      "function `%s' appears to be defined outside of all compilation units", 0, 0
    };
    char *p;
    /*
     * Standard, external, non-debugger, symbols
     */

  case N_TEXT | N_EXT:
  case N_NBTEXT | N_EXT:
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
    goto record_it;

  case N_DATA | N_EXT:
  case N_NBDATA | N_EXT:
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
    goto record_it;

  case N_BSS:
  case N_BSS | N_EXT:
  case N_NBBSS | N_EXT:
  case N_SETV | N_EXT:		/* FIXME, is this in BSS? */
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS (objfile));
    goto record_it;

  case N_ABS | N_EXT:
  record_it:
#ifdef DBXREAD_ONLY
    SET_NAMESTRING ();

  bss_ext_symbol:
    record_minimal_symbol (namestring, CUR_SYMBOL_VALUE,
			   CUR_SYMBOL_TYPE, objfile);	/* Always */
#endif /* DBXREAD_ONLY */
    continue;

    /* Standard, local, non-debugger, symbols */

  case N_NBTEXT:

    /* We need to be able to deal with both N_FN or N_TEXT,
       because we have no way of knowing whether the sys-supplied ld
       or GNU ld was used to make the executable.  Sequents throw
       in another wrinkle -- they renumbered N_FN.  */

  case N_FN:
  case N_FN_SEQ:
  case N_TEXT:
#ifdef DBXREAD_ONLY
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
    SET_NAMESTRING ();
    if ((namestring[0] == '-' && namestring[1] == 'l')
	|| (namestring[(nsl = strlen (namestring)) - 1] == 'o'
	    && namestring[nsl - 2] == '.'))
      {
	if (objfile->ei.entry_point < CUR_SYMBOL_VALUE &&
	    objfile->ei.entry_point >= last_o_file_start)
	  {
	    objfile->ei.entry_file_lowpc = last_o_file_start;
	    objfile->ei.entry_file_highpc = CUR_SYMBOL_VALUE;
	  }
	if (past_first_source_file && pst
	/* The gould NP1 uses low values for .o and -l symbols
	   which are not the address.  */
	    && CUR_SYMBOL_VALUE >= TEXTLOW (pst))
	  {
	    END_PSYMTAB (pst, psymtab_include_list, includes_used,
			 symnum * symbol_size,
			 CUR_SYMBOL_VALUE > TEXTHIGH (pst)
			 ? CUR_SYMBOL_VALUE : TEXTHIGH (pst),
		       dependency_list, dependencies_used, textlow_not_set);
	    pst = (struct partial_symtab *) 0;
	    includes_used = 0;
	    dependencies_used = 0;
	  }
	else
	  past_first_source_file = 1;
	last_o_file_start = CUR_SYMBOL_VALUE;
      }
    else
      goto record_it;
#endif /* DBXREAD_ONLY */
    continue;

  case N_DATA:
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
    goto record_it;

  case N_UNDF | N_EXT:
#ifdef DBXREAD_ONLY
    if (CUR_SYMBOL_VALUE != 0)
      {
	/* This is a "Fortran COMMON" symbol.  See if the target
	   environment knows where it has been relocated to.  */

	CORE_ADDR reladdr;

	SET_NAMESTRING ();
	if (target_lookup_symbol (namestring, &reladdr))
	  {
	    continue;		/* Error in lookup; ignore symbol for now.  */
	  }
	CUR_SYMBOL_TYPE ^= (N_BSS ^ N_UNDF);	/* Define it as a bss-symbol */
	CUR_SYMBOL_VALUE = reladdr;
	goto bss_ext_symbol;
      }
#endif /* DBXREAD_ONLY */
    continue;			/* Just undefined, not COMMON */

  case N_UNDF:
#ifdef DBXREAD_ONLY
    if (processing_acc_compilation && CUR_SYMBOL_STRX == 1)
      {
	/* Deal with relative offsets in the string table
	   used in ELF+STAB under Solaris.  If we want to use the
	   n_strx field, which contains the name of the file,
	   we must adjust file_string_table_offset *before* calling
	   SET_NAMESTRING().  */
	past_first_source_file = 1;
	file_string_table_offset = next_file_string_table_offset;
	next_file_string_table_offset =
	  file_string_table_offset + CUR_SYMBOL_VALUE;
	if (next_file_string_table_offset < file_string_table_offset)
	  error ("string table offset backs up at %d", symnum);
	/* FIXME -- replace error() with complaint.  */
	continue;
      }
#endif /* DBXREAD_ONLY */
    continue;

    /* Lots of symbol types we can just ignore.  */

  case N_ABS:
  case N_NBDATA:
  case N_NBBSS:
    continue;

    /* Keep going . . . */

    /*
     * Special symbol types for GNU
     */
  case N_INDR:
  case N_INDR | N_EXT:
  case N_SETA:
  case N_SETA | N_EXT:
  case N_SETT:
  case N_SETT | N_EXT:
  case N_SETD:
  case N_SETD | N_EXT:
  case N_SETB:
  case N_SETB | N_EXT:
  case N_SETV:
    continue;

    /*
     * Debugger symbols
     */

  case N_SO:
    {
      CORE_ADDR valu;
      static int prev_so_symnum = -10;
      static int first_so_symnum;
      char *p;
      int prev_textlow_not_set;

      valu = CUR_SYMBOL_VALUE + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

      prev_textlow_not_set = textlow_not_set;

#ifdef SOFUN_ADDRESS_MAYBE_MISSING
      /* A zero value is probably an indication for the SunPRO 3.0
         compiler. end_psymtab explicitly tests for zero, so
         don't relocate it.  */

      if (CUR_SYMBOL_VALUE == 0)
	{
	  textlow_not_set = 1;
	  valu = 0;
	}
      else
	textlow_not_set = 0;
#else
      textlow_not_set = 0;
#endif
      past_first_source_file = 1;

      if (prev_so_symnum != symnum - 1)
	{			/* Here if prev stab wasn't N_SO */
	  first_so_symnum = symnum;

	  if (pst)
	    {
	      END_PSYMTAB (pst, psymtab_include_list, includes_used,
			   symnum * symbol_size,
			   valu > TEXTHIGH (pst) ? valu : TEXTHIGH (pst),
			   dependency_list, dependencies_used,
			   prev_textlow_not_set);
	      pst = (struct partial_symtab *) 0;
	      includes_used = 0;
	      dependencies_used = 0;
	    }
	}

      prev_so_symnum = symnum;

      /* End the current partial symtab and start a new one */

      SET_NAMESTRING ();

      /* Null name means end of .o file.  Don't start a new one. */
      if (*namestring == '\000')
	continue;

      /* Some compilers (including gcc) emit a pair of initial N_SOs.
         The first one is a directory name; the second the file name.
         If pst exists, is empty, and has a filename ending in '/',
         we assume the previous N_SO was a directory name. */

      p = strrchr (namestring, '/');
      if (p && *(p + 1) == '\000')
	continue;		/* Simply ignore directory name SOs */

      /* Some other compilers (C++ ones in particular) emit useless
         SOs for non-existant .c files.  We ignore all subsequent SOs that
         immediately follow the first.  */

      if (!pst)
	pst = START_PSYMTAB (objfile,
			     namestring, valu,
			     first_so_symnum * symbol_size,
			     objfile->global_psymbols.next,
			     objfile->static_psymbols.next);
      continue;
    }

  case N_BINCL:
    {
#ifdef DBXREAD_ONLY
      enum language tmp_language;
      /* Add this bincl to the bincl_list for future EXCLs.  No
         need to save the string; it'll be around until
         read_dbx_symtab function returns */

      SET_NAMESTRING ();

      tmp_language = deduce_language_from_filename (namestring);

      /* Only change the psymtab's language if we've learned
         something useful (eg. tmp_language is not language_unknown).
         In addition, to match what start_subfile does, never change
         from C++ to C.  */
      if (tmp_language != language_unknown
	  && (tmp_language != language_c
	      || psymtab_language != language_cplus))
	psymtab_language = tmp_language;

      if (pst == NULL)
	{
	  /* FIXME: we should not get here without a PST to work on.
	     Attempt to recover.  */
	  complain (&unclaimed_bincl_complaint, namestring, symnum);
	  continue;
	}
      add_bincl_to_list (pst, namestring, CUR_SYMBOL_VALUE);

      /* Mark down an include file in the current psymtab */

      goto record_include_file;

#else /* DBXREAD_ONLY */
      continue;
#endif
    }

  case N_SOL:
    {
      enum language tmp_language;
      /* Mark down an include file in the current psymtab */

      SET_NAMESTRING ();

      tmp_language = deduce_language_from_filename (namestring);

      /* Only change the psymtab's language if we've learned
         something useful (eg. tmp_language is not language_unknown).
         In addition, to match what start_subfile does, never change
         from C++ to C.  */
      if (tmp_language != language_unknown
	  && (tmp_language != language_c
	      || psymtab_language != language_cplus))
	psymtab_language = tmp_language;

      /* In C++, one may expect the same filename to come round many
         times, when code is coming alternately from the main file
         and from inline functions in other files. So I check to see
         if this is a file we've seen before -- either the main
         source file, or a previously included file.

         This seems to be a lot of time to be spending on N_SOL, but
         things like "break c-exp.y:435" need to work (I
         suppose the psymtab_include_list could be hashed or put
         in a binary tree, if profiling shows this is a major hog).  */
      if (pst && STREQ (namestring, pst->filename))
	continue;
      {
	register int i;
	for (i = 0; i < includes_used; i++)
	  if (STREQ (namestring, psymtab_include_list[i]))
	    {
	      i = -1;
	      break;
	    }
	if (i == -1)
	  continue;
      }

#ifdef DBXREAD_ONLY
    record_include_file:
#endif

      psymtab_include_list[includes_used++] = namestring;
      if (includes_used >= includes_allocated)
	{
	  char **orig = psymtab_include_list;

	  psymtab_include_list = (char **)
	    alloca ((includes_allocated *= 2) *
		    sizeof (char *));
	  memcpy ((PTR) psymtab_include_list, (PTR) orig,
		  includes_used * sizeof (char *));
	}
      continue;
    }
  case N_LSYM:			/* Typedef or automatic variable. */
  case N_STSYM:		/* Data seg var -- static  */
  case N_LCSYM:		/* BSS      "  */
  case N_ROSYM:		/* Read-only data seg var -- static.  */
  case N_NBSTS:		/* Gould nobase.  */
  case N_NBLCS:		/* symbols.  */
  case N_FUN:
  case N_GSYM:			/* Global (extern) variable; can be
				   data or bss (sigh FIXME).  */

    /* Following may probably be ignored; I'll leave them here
       for now (until I do Pascal and Modula 2 extensions).  */

  case N_PC:			/* I may or may not need this; I
				   suspect not.  */
  case N_M2C:			/* I suspect that I can ignore this here. */
  case N_SCOPE:		/* Same.   */

    SET_NAMESTRING ();

#ifdef DBXREAD_ONLY
    /* See if this is an end of function stab.  */
    if (pst && CUR_SYMBOL_TYPE == N_FUN && *namestring == '\000')
      {
	CORE_ADDR valu;

	/* It's value is the size (in bytes) of the function for
	   function relative stabs, or the address of the function's
	   end for old style stabs.  */
	valu = CUR_SYMBOL_VALUE + last_function_start;
	if (TEXTHIGH (pst) == 0 || valu > TEXTHIGH (pst))
	  TEXTHIGH (pst) = valu;
	break;
      }
#endif

    p = (char *) strchr (namestring, ':');
    if (!p)
      continue;			/* Not a debugging symbol.   */



    /* Main processing section for debugging symbols which
       the initial read through the symbol tables needs to worry
       about.  If we reach this point, the symbol which we are
       considering is definitely one we are interested in.
       p must also contain the (valid) index into the namestring
       which indicates the debugging type symbol.  */

    switch (p[1])
      {
      case 'S':
	CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
#ifdef STATIC_TRANSFORM_NAME
	namestring = STATIC_TRANSFORM_NAME (namestring);
#endif
	add_psymbol_to_list (namestring, p - namestring,
			     VAR_NAMESPACE, LOC_STATIC,
			     &objfile->static_psymbols,
			     0, CUR_SYMBOL_VALUE,
			     psymtab_language, objfile);
	continue;
      case 'G':
	CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
	/* The addresses in these entries are reported to be
	   wrong.  See the code that reads 'G's for symtabs. */
	add_psymbol_to_list (namestring, p - namestring,
			     VAR_NAMESPACE, LOC_STATIC,
			     &objfile->global_psymbols,
			     0, CUR_SYMBOL_VALUE,
			     psymtab_language, objfile);
	continue;

      case 'T':
	/* When a 'T' entry is defining an anonymous enum, it
	   may have a name which is the empty string, or a
	   single space.  Since they're not really defining a
	   symbol, those shouldn't go in the partial symbol
	   table.  We do pick up the elements of such enums at
	   'check_enum:', below.  */
	if (p >= namestring + 2
	    || (p == namestring + 1
		&& namestring[0] != ' '))
	  {
	    add_psymbol_to_list (namestring, p - namestring,
				 STRUCT_NAMESPACE, LOC_TYPEDEF,
				 &objfile->static_psymbols,
				 CUR_SYMBOL_VALUE, 0,
				 psymtab_language, objfile);
	    if (p[2] == 't')
	      {
		/* Also a typedef with the same name.  */
		add_psymbol_to_list (namestring, p - namestring,
				     VAR_NAMESPACE, LOC_TYPEDEF,
				     &objfile->static_psymbols,
				     CUR_SYMBOL_VALUE, 0,
				     psymtab_language, objfile);
		p += 1;
	      }
	    /* The semantics of C++ state that "struct foo { ... }"
	       also defines a typedef for "foo".  Unfortuantely, cfront
	       never makes the typedef when translating from C++ to C.
	       We make the typedef here so that "ptype foo" works as
	       expected for cfront translated code.  */
	    else if (psymtab_language == language_cplus)
	      {
		/* Also a typedef with the same name.  */
		add_psymbol_to_list (namestring, p - namestring,
				     VAR_NAMESPACE, LOC_TYPEDEF,
				     &objfile->static_psymbols,
				     CUR_SYMBOL_VALUE, 0,
				     psymtab_language, objfile);
	      }
	  }
	goto check_enum;
      case 't':
	if (p != namestring)	/* a name is there, not just :T... */
	  {
	    add_psymbol_to_list (namestring, p - namestring,
				 VAR_NAMESPACE, LOC_TYPEDEF,
				 &objfile->static_psymbols,
				 CUR_SYMBOL_VALUE, 0,
				 psymtab_language, objfile);
	  }
      check_enum:
	/* If this is an enumerated type, we need to
	   add all the enum constants to the partial symbol
	   table.  This does not cover enums without names, e.g.
	   "enum {a, b} c;" in C, but fortunately those are
	   rare.  There is no way for GDB to find those from the
	   enum type without spending too much time on it.  Thus
	   to solve this problem, the compiler needs to put out the
	   enum in a nameless type.  GCC2 does this.  */

	/* We are looking for something of the form
	   <name> ":" ("t" | "T") [<number> "="] "e"
	   {<constant> ":" <value> ","} ";".  */

	/* Skip over the colon and the 't' or 'T'.  */
	p += 2;
	/* This type may be given a number.  Also, numbers can come
	   in pairs like (0,26).  Skip over it.  */
	while ((*p >= '0' && *p <= '9')
	       || *p == '(' || *p == ',' || *p == ')'
	       || *p == '=')
	  p++;

	if (*p++ == 'e')
	  {
	    /* The aix4 compiler emits extra crud before the members.  */
	    if (*p == '-')
	      {
		/* Skip over the type (?).  */
		while (*p != ':')
		  p++;

		/* Skip over the colon.  */
		p++;
	      }

	    /* We have found an enumerated type.  */
	    /* According to comments in read_enum_type
	       a comma could end it instead of a semicolon.
	       I don't know where that happens.
	       Accept either.  */
	    while (*p && *p != ';' && *p != ',')
	      {
		char *q;

		/* Check for and handle cretinous dbx symbol name
		   continuation!  */
		if (*p == '\\' || (*p == '?' && p[1] == '\0'))
		  p = next_symbol_text (objfile);

		/* Point to the character after the name
		   of the enum constant.  */
		for (q = p; *q && *q != ':'; q++)
		  ;
		/* Note that the value doesn't matter for
		   enum constants in psymtabs, just in symtabs.  */
		add_psymbol_to_list (p, q - p,
				     VAR_NAMESPACE, LOC_CONST,
				     &objfile->static_psymbols, 0,
				     0, psymtab_language, objfile);
		/* Point past the name.  */
		p = q;
		/* Skip over the value.  */
		while (*p && *p != ',')
		  p++;
		/* Advance past the comma.  */
		if (*p)
		  p++;
	      }
	  }
	continue;
      case 'c':
	/* Constant, e.g. from "const" in Pascal.  */
	add_psymbol_to_list (namestring, p - namestring,
			     VAR_NAMESPACE, LOC_CONST,
			     &objfile->static_psymbols, CUR_SYMBOL_VALUE,
			     0, psymtab_language, objfile);
	continue;

      case 'f':
        if (! pst)
          {
            int name_len = p - namestring;
            char *name = xmalloc (name_len + 1);
            memcpy (name, namestring, name_len);
            name[name_len] = '\0';
            complain (&function_outside_compilation_unit, name);
            xfree (name);
          }
	CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
#ifdef DBXREAD_ONLY
	/* Kludges for ELF/STABS with Sun ACC */
	last_function_name = namestring;
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
	/* Do not fix textlow==0 for .o or NLM files, as 0 is a legit
	   value for the bottom of the text seg in those cases. */
	if (CUR_SYMBOL_VALUE == ANOFFSET (objfile->section_offsets, 
	                                  SECT_OFF_TEXT (objfile)))
	  {
	    CORE_ADDR minsym_valu = 
	      find_stab_function_addr (namestring, pst->filename, objfile);
	    /* find_stab_function_addr will return 0 if the minimal
	       symbol wasn't found.  (Unfortunately, this might also
	       be a valid address.)  Anyway, if it *does* return 0,
	       it is likely that the value was set correctly to begin
	       with... */
	    if (minsym_valu != 0)
	      CUR_SYMBOL_VALUE = minsym_valu;
	  }
	if (pst && textlow_not_set)
	  {
	    TEXTLOW (pst) = CUR_SYMBOL_VALUE;
	    textlow_not_set = 0;
	  }
#endif
	/* End kludge.  */

	/* Keep track of the start of the last function so we
	   can handle end of function symbols.  */
	last_function_start = CUR_SYMBOL_VALUE;

	/* In reordered executables this function may lie outside
	   the bounds created by N_SO symbols.  If that's the case
	   use the address of this function as the low bound for
	   the partial symbol table.  */
	if (pst
            && (textlow_not_set
                || (CUR_SYMBOL_VALUE < TEXTLOW (pst)
                    && (CUR_SYMBOL_VALUE
                        != ANOFFSET (objfile->section_offsets,
                                     SECT_OFF_TEXT (objfile))))))
	  {
	    TEXTLOW (pst) = CUR_SYMBOL_VALUE;
	    textlow_not_set = 0;
	  }
#endif /* DBXREAD_ONLY */
	add_psymbol_to_list (namestring, p - namestring,
			     VAR_NAMESPACE, LOC_BLOCK,
			     &objfile->static_psymbols,
			     0, CUR_SYMBOL_VALUE,
			     psymtab_language, objfile);
	continue;

	/* Global functions were ignored here, but now they
	   are put into the global psymtab like one would expect.
	   They're also in the minimal symbol table.  */
      case 'F':
        if (! pst)
          {
            int name_len = p - namestring;
            char *name = xmalloc (name_len + 1);
            memcpy (name, namestring, name_len);
            name[name_len] = '\0';
            complain (&function_outside_compilation_unit, name);
            xfree (name);
          }
	CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
#ifdef DBXREAD_ONLY
	/* Kludges for ELF/STABS with Sun ACC */
	last_function_name = namestring;
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
	/* Do not fix textlow==0 for .o or NLM files, as 0 is a legit
	   value for the bottom of the text seg in those cases. */
	if (CUR_SYMBOL_VALUE == ANOFFSET (objfile->section_offsets, 
	                                  SECT_OFF_TEXT (objfile)))
	  {
	    CORE_ADDR minsym_valu = 
	      find_stab_function_addr (namestring, pst->filename, objfile);
	    /* find_stab_function_addr will return 0 if the minimal
	       symbol wasn't found.  (Unfortunately, this might also
	       be a valid address.)  Anyway, if it *does* return 0,
	       it is likely that the value was set correctly to begin
	       with... */
	    if (minsym_valu != 0)
	      CUR_SYMBOL_VALUE = minsym_valu;
	  }
	if (pst && textlow_not_set)
	  {
	    TEXTLOW (pst) = CUR_SYMBOL_VALUE;
	    textlow_not_set = 0;
	  }
#endif
	/* End kludge.  */

	/* Keep track of the start of the last function so we
	   can handle end of function symbols.  */
	last_function_start = CUR_SYMBOL_VALUE;

	/* In reordered executables this function may lie outside
	   the bounds created by N_SO symbols.  If that's the case
	   use the address of this function as the low bound for
	   the partial symbol table.  */
	if (pst
            && (textlow_not_set
                || (CUR_SYMBOL_VALUE < TEXTLOW (pst)
                    && (CUR_SYMBOL_VALUE
                        != ANOFFSET (objfile->section_offsets,
                                     SECT_OFF_TEXT (objfile))))))
	  {
	    TEXTLOW (pst) = CUR_SYMBOL_VALUE;
	    textlow_not_set = 0;
	  }
#endif /* DBXREAD_ONLY */
	add_psymbol_to_list (namestring, p - namestring,
			     VAR_NAMESPACE, LOC_BLOCK,
			     &objfile->global_psymbols,
			     0, CUR_SYMBOL_VALUE,
			     psymtab_language, objfile);
	continue;

	/* Two things show up here (hopefully); static symbols of
	   local scope (static used inside braces) or extensions
	   of structure symbols.  We can ignore both.  */
      case 'V':
      case '(':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
      case '#':		/* for symbol identification (used in live ranges) */
	/* added to support cfront stabs strings */
      case 'Z':		/* for definition continuations */
      case 'P':		/* for prototypes */
	continue;

      case ':':
	/* It is a C++ nested symbol.  We don't need to record it
	   (I don't think); if we try to look up foo::bar::baz,
	   then symbols for the symtab containing foo should get
	   read in, I think.  */
	/* Someone says sun cc puts out symbols like
	   /foo/baz/maclib::/usr/local/bin/maclib,
	   which would get here with a symbol type of ':'.  */
	continue;

      default:
	/* Unexpected symbol descriptor.  The second and subsequent stabs
	   of a continued stab can show up here.  The question is
	   whether they ever can mimic a normal stab--it would be
	   nice if not, since we certainly don't want to spend the
	   time searching to the end of every string looking for
	   a backslash.  */

	complain (&unknown_symchar_complaint, p[1]);

	/* Ignore it; perhaps it is an extension that we don't
	   know about.  */
	continue;
      }

  case N_EXCL:
#ifdef DBXREAD_ONLY

    SET_NAMESTRING ();

    /* Find the corresponding bincl and mark that psymtab on the
       psymtab dependency list */
    {
      struct partial_symtab *needed_pst =
      find_corresponding_bincl_psymtab (namestring, CUR_SYMBOL_VALUE);

      /* If this include file was defined earlier in this file,
         leave it alone.  */
      if (needed_pst == pst)
	continue;

      if (needed_pst)
	{
	  int i;
	  int found = 0;

	  for (i = 0; i < dependencies_used; i++)
	    if (dependency_list[i] == needed_pst)
	      {
		found = 1;
		break;
	      }

	  /* If it's already in the list, skip the rest.  */
	  if (found)
	    continue;

	  dependency_list[dependencies_used++] = needed_pst;
	  if (dependencies_used >= dependencies_allocated)
	    {
	      struct partial_symtab **orig = dependency_list;
	      dependency_list =
		(struct partial_symtab **)
		alloca ((dependencies_allocated *= 2)
			* sizeof (struct partial_symtab *));
	      memcpy ((PTR) dependency_list, (PTR) orig,
		      (dependencies_used
		       * sizeof (struct partial_symtab *)));
#ifdef DEBUG_INFO
	      fprintf_unfiltered (gdb_stderr, "Had to reallocate dependency list.\n");
	      fprintf_unfiltered (gdb_stderr, "New dependencies allocated: %d\n",
				  dependencies_allocated);
#endif
	    }
	}
    }
#endif /* DBXREAD_ONLY */
    continue;

  case N_ENDM:
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
    /* Solaris 2 end of module, finish current partial symbol table.
       END_PSYMTAB will set TEXTHIGH (pst) to the proper value, which
       is necessary if a module compiled without debugging info
       follows this module.  */
    if (pst)
      {
	END_PSYMTAB (pst, psymtab_include_list, includes_used,
		     symnum * symbol_size,
		     (CORE_ADDR) 0,
		     dependency_list, dependencies_used, textlow_not_set);
	pst = (struct partial_symtab *) 0;
	includes_used = 0;
	dependencies_used = 0;
      }
#endif
    continue;

  case N_RBRAC:
#ifdef HANDLE_RBRAC
    HANDLE_RBRAC (CUR_SYMBOL_VALUE);
    continue;
#endif
  case N_EINCL:
  case N_DSLINE:
  case N_BSLINE:
  case N_SSYM:			/* Claim: Structure or union element.
				   Hopefully, I can ignore this.  */
  case N_ENTRY:		/* Alternate entry point; can ignore. */
  case N_MAIN:			/* Can definitely ignore this.   */
  case N_CATCH:		/* These are GNU C++ extensions */
  case N_EHDECL:		/* that can safely be ignored here. */
  case N_LENG:
  case N_BCOMM:
  case N_ECOMM:
  case N_ECOML:
  case N_FNAME:
  case N_SLINE:
  case N_RSYM:
  case N_PSYM:
  case N_LBRAC:
  case N_NSYMS:		/* Ultrix 4.0: symbol count */
  case N_DEFD:			/* GNU Modula-2 */
  case N_ALIAS:		/* SunPro F77: alias name, ignore for now.  */

  case N_OBJ:			/* useless types from Solaris */
  case N_OPT:
    /* These symbols aren't interesting; don't worry about them */

    continue;

  default:
    /* If we haven't found it yet, ignore it.  It's probably some
       new type we don't know about yet.  */
    complain (&unknown_symtype_complaint,
	      local_hex_string (CUR_SYMBOL_TYPE));
    continue;
  }
@


1.14
log
@Isolate STABS readers' use of the `textlow' and `texthigh' fields
of `struct partial_symtab' to only a few locations.  This change
is not supposed to affect the way the values are computed, only
where they live.

* dbxread.c (struct symloc): Add `textlow' and `texthigh' fields
to the reader-specific structure.
* mdebugread.c (struct symloc): Same.
* dbxread.c (TEXTLOW, TEXTHIGH): New accessor macros.
* mdebugread.c (TEXTLOW, TEXTHIGH): Same.
* dbxread.c (dbx_symfile_read): After we've built all our partial
symbol tables, set each partial symtab's `textlow' and `texthigh'
fields from our reader-specific structure.
* mdebugread.c (mdebug_build_psymtabs): Same.
* dbxread.c (start_psymtab): Initialize the reader-specific
structure's `textlow' and `texthigh' from the new psymtab's.
* mdebugread.c (parse_partial_symbols, new_psymtab): Same.
* dbxread.c (read_dbx_symtab, end_psymtab, read_ofile_symtab): Use
the reader-specific `textlow' and `texthigh', not the generic
psymtab fields.
* mdebugread.c (parse_lines, parse_partial_symbols,
psymtab_to_symtab_1): Same.
* partial-stab.h: Same.
@
text
@@


1.13
log
@Don't use error result from find_stab_function_addr().
@
text
@d107 1
a107 1
	    && CUR_SYMBOL_VALUE >= pst->textlow)
d111 2
a112 2
			 CUR_SYMBOL_VALUE > pst->texthigh
			 ? CUR_SYMBOL_VALUE : pst->texthigh,
d239 1
a239 1
			   valu > pst->texthigh ? valu : pst->texthigh,
d408 2
a409 2
	if (pst->texthigh == 0 || valu > pst->texthigh)
	  pst->texthigh = valu;
d613 1
a613 1
	    pst->textlow = CUR_SYMBOL_VALUE;
d629 1
a629 1
                || (CUR_SYMBOL_VALUE < pst->textlow
d634 1
a634 1
	    pst->textlow = CUR_SYMBOL_VALUE;
d680 1
a680 1
	    pst->textlow = CUR_SYMBOL_VALUE;
d696 1
a696 1
                || (CUR_SYMBOL_VALUE < pst->textlow
d701 1
a701 1
	    pst->textlow = CUR_SYMBOL_VALUE;
d816 1
a816 1
       END_PSYMTAB will set pst->texthigh to the proper value, which
@


1.12
log
@2001-08-14  Daniel Jacobowitz  <drow@@mvista.com>
	    H.J. Lu  (hjl@@gnu.org)

	* partial-stab.h: valu should be a CORE_ADDR.

2001-08-14  H.J. Lu  (hjl@@gnu.org)

	* dbxread.c (SWAP_SYMBOL): Removed.
	(INTERNALIZE_SYMBOL): Check sign extended vma.
@
text
@d598 13
d613 1
a613 2
	    pst->textlow =
	      find_stab_function_addr (namestring, pst->filename, objfile);
d667 11
a677 2
	  CUR_SYMBOL_VALUE = 
	    find_stab_function_addr (namestring, pst->filename, objfile);
@


1.11
log
@* partial-stab.h (case N_FUN: case 'f':, case N_FUN: case 'F':)
Fix memory leak.
@
text
@d204 1
a204 1
      unsigned long valu;
d402 1
a402 1
	unsigned long valu;
@


1.11.4.1
log
@2001-08-10  Daniel Jacobowitz  <drow@@mvista.com>
            H.J. Lu  (hjl@@gnu.org)

        * partial-stab.h: valu should be a CORE_ADDR.

2001-08-08  H.J. Lu  (hjl@@gnu.org)

        * dbxread.c (SWAP_SYMBOL): Removed.
        (INTERNALIZE_SYMBOL): Check sign extended vma.
@
text
@d204 1
a204 1
      CORE_ADDR valu;
d402 1
a402 1
	CORE_ADDR valu;
@


1.11.4.2
log
@	* dbxread.c (process_one_symbol): Don't use error result from
	find_stab_function_addr().
	* partial-stab.h (case 'F'): Likewise.

	* partial-stab.h (case 'f'): Make SOFUN_ADDRESS_MAYBE_MISSING
	code match that used for case 'F'.  This fixes the divergence
	that was introduced by my 1999-09-14 changes to partial-stab.h.
@
text
@d598 1
a598 2
	if (CUR_SYMBOL_VALUE == ANOFFSET (objfile->section_offsets, 
	                                  SECT_OFF_TEXT (objfile)))
d600 1
a600 1
	    CORE_ADDR minsym_valu = 
a601 11
	    /* find_stab_function_addr will return 0 if the minimal
	       symbol wasn't found.  (Unfortunately, this might also
	       be a valid address.)  Anyway, if it *does* return 0,
	       it is likely that the value was set correctly to begin
	       with... */
	    if (minsym_valu != 0)
	      CUR_SYMBOL_VALUE = minsym_valu;
	  }
	if (pst && textlow_not_set)
	  {
	    pst->textlow = CUR_SYMBOL_VALUE;
d655 2
a656 11
	  {
	    CORE_ADDR minsym_valu = 
	      find_stab_function_addr (namestring, pst->filename, objfile);
	    /* find_stab_function_addr will return 0 if the minimal
	       symbol wasn't found.  (Unfortunately, this might also
	       be a valid address.)  Anyway, if it *does* return 0,
	       it is likely that the value was set correctly to begin
	       with... */
	    if (minsym_valu != 0)
	      CUR_SYMBOL_VALUE = minsym_valu;
	  }
@


1.10
log
@* partial-stab.h: New complaint: function_outside_compilation_unit.
(case N_FUN: case 'f':, case N_FUN: case 'F':): If pst is zero,
complain, and don't try to set pst's start address.
@
text
@d589 1
d644 1
@


1.9
log
@* partial-stab.h: Revert previous patch.
@
text
@d43 3
d582 8
d614 6
a619 4
	if (textlow_not_set
	    || (pst && CUR_SYMBOL_VALUE < pst->textlow
		&& CUR_SYMBOL_VALUE
		!= ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile))))
d636 8
d671 6
a676 4
	if (textlow_not_set
	    || (pst && CUR_SYMBOL_VALUE < pst->textlow
		&& CUR_SYMBOL_VALUE
		!= ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile))))
@


1.8
log
@* partial-stab.h: Consistently guard against pst being NULL.
@
text
@d603 4
a606 5
	if (pst
	    && (textlow_not_set
		|| (pst && CUR_SYMBOL_VALUE < pst->textlow
		  && CUR_SYMBOL_VALUE
		  != ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile)))))
@


1.7
log
@Update/correct copyright notices.
@
text
@d603 5
a607 4
	if (textlow_not_set
	    || (pst && CUR_SYMBOL_VALUE < pst->textlow
		&& CUR_SYMBOL_VALUE
		!= ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile))))
@


1.6
log
@2001-02-19  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	From: innadadadavida@@yahoo.com:
	* partial-stab.h (switch): Check that pst is not null
 	before dereferencing it.
@
text
@d2 2
a3 1
   Copyright 1986, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 1998
@


1.5
log
@Eliminate redundant pst test.
@
text
@d603 1
a603 1
	    || (CUR_SYMBOL_VALUE < pst->textlow
@


1.4
log
@2000-08-10  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	From Greg McGary <greg@@mcgary.org>:
	* partial-stab.h: Don't crash if pst is null.
@
text
@d404 1
a404 1
	if (pst && pst->texthigh == 0 || valu > pst->texthigh)
@


1.3
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d404 1
a404 1
	if (pst->texthigh == 0 || valu > pst->texthigh)
d650 1
a650 1
	    || (CUR_SYMBOL_VALUE < pst->textlow
@


1.2
log
@* partial-stab.h: Add one more check against corrupted or irregular stabs
entry.
@
text
@d49 1
a49 1
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d54 1
a54 1
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d61 1
a61 1
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS);
d88 1
a88 1
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d124 1
a124 1
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d206 1
a206 1
      valu = CUR_SYMBOL_VALUE + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d426 1
a426 1
	CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d437 1
a437 1
	CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d578 1
a578 1
	CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d605 1
a605 1
		!= ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT)))
d622 1
a622 1
	CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d630 1
a630 1
	                                  SECT_OFF_TEXT))
d652 1
a652 1
		!= ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT)))
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a26 1
   section_offsets - variable pointing to the section offsets.
d30 1
a30 1
     file names (N_SOL) seen so far.
d32 1
a32 1
     N_EXCL stabs seen so far.
d40 23
a62 23
      switch (CUR_SYMBOL_TYPE)
	{
	  char *p;
	  /*
	   * Standard, external, non-debugger, symbols
	   */

	case N_TEXT | N_EXT:
	case N_NBTEXT | N_EXT:
	  CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	  goto record_it;

	case N_DATA | N_EXT:
	case N_NBDATA | N_EXT:
	  CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_DATA);
	  goto record_it;

	case N_BSS:
	case N_BSS | N_EXT:
	case N_NBBSS | N_EXT:
        case N_SETV | N_EXT:		/* FIXME, is this in BSS? */
	  CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_BSS);
	  goto record_it;
d64 2
a65 2
	case N_ABS | N_EXT:
	record_it:
d67 1
a67 1
	  SET_NAMESTRING();
d69 3
a71 3
	bss_ext_symbol:
	  record_minimal_symbol (namestring, CUR_SYMBOL_VALUE,
				 CUR_SYMBOL_TYPE, objfile); /* Always */
d73 3
a75 1
	  continue;
d77 1
a77 1
	  /* Standard, local, non-debugger, symbols */
d79 4
a82 1
	case N_NBTEXT:
d84 3
a86 8
	  /* We need to be able to deal with both N_FN or N_TEXT,
	     because we have no way of knowing whether the sys-supplied ld
	     or GNU ld was used to make the executable.  Sequents throw
	     in another wrinkle -- they renumbered N_FN.  */

	case N_FN:
	case N_FN_SEQ:
	case N_TEXT:
d88 32
a119 32
	  CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	  SET_NAMESTRING();
	  if ((namestring[0] == '-' && namestring[1] == 'l')
	      || (namestring [(nsl = strlen (namestring)) - 1] == 'o'
		  && namestring [nsl - 2] == '.'))
	    {
	      if (objfile -> ei.entry_point <  CUR_SYMBOL_VALUE &&
		  objfile -> ei.entry_point >= last_o_file_start)
		{
		  objfile -> ei.entry_file_lowpc = last_o_file_start;
		  objfile -> ei.entry_file_highpc = CUR_SYMBOL_VALUE;
		}
	      if (past_first_source_file && pst
		  /* The gould NP1 uses low values for .o and -l symbols
		     which are not the address.  */
		  && CUR_SYMBOL_VALUE >= pst->textlow)
		{
		  END_PSYMTAB (pst, psymtab_include_list, includes_used,
			       symnum * symbol_size,
			       CUR_SYMBOL_VALUE > pst->texthigh
				 ? CUR_SYMBOL_VALUE : pst->texthigh, 
			       dependency_list, dependencies_used, textlow_not_set);
		  pst = (struct partial_symtab *) 0;
		  includes_used = 0;
		  dependencies_used = 0;
		}
	      else
		past_first_source_file = 1;
	      last_o_file_start = CUR_SYMBOL_VALUE;
	    }
	  else
	    goto record_it;
d121 1
a121 1
	  continue;
d123 3
a125 3
	case N_DATA:
	  CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_DATA);
	  goto record_it;
d127 1
a127 1
	case N_UNDF | N_EXT:
d129 11
a139 13
	  if (CUR_SYMBOL_VALUE != 0) {
	    /* This is a "Fortran COMMON" symbol.  See if the target
	       environment knows where it has been relocated to.  */

	    CORE_ADDR reladdr;

	    SET_NAMESTRING();
	    if (target_lookup_symbol (namestring, &reladdr)) {
	      continue;		/* Error in lookup; ignore symbol for now.  */
	    }
	    CUR_SYMBOL_TYPE ^= (N_BSS^N_UNDF);	/* Define it as a bss-symbol */
	    CUR_SYMBOL_VALUE = reladdr;
	    goto bss_ext_symbol;
d141 4
d146 1
a146 1
	  continue;	/* Just undefined, not COMMON */
d148 1
a148 1
	case N_UNDF:
d150 16
a165 15
	  if (processing_acc_compilation && CUR_SYMBOL_STRX == 1) {
	    /* Deal with relative offsets in the string table
	       used in ELF+STAB under Solaris.  If we want to use the
	       n_strx field, which contains the name of the file,
	       we must adjust file_string_table_offset *before* calling
	       SET_NAMESTRING().  */
	    past_first_source_file = 1;
	    file_string_table_offset = next_file_string_table_offset;
	    next_file_string_table_offset =
	      file_string_table_offset + CUR_SYMBOL_VALUE;
	    if (next_file_string_table_offset < file_string_table_offset)
	      error ("string table offset backs up at %d", symnum);
  /* FIXME -- replace error() with complaint.  */
	    continue;
	  }
d167 1
a167 1
	  continue;
d169 1
a169 1
	    /* Lots of symbol types we can just ignore.  */
d171 34
a204 4
	case N_ABS:
	case N_NBDATA:
	case N_NBBSS:
	  continue;
d206 1
a206 1
	  /* Keep going . . .*/
d208 1
a208 15
	  /*
	   * Special symbol types for GNU
	   */
	case N_INDR:
	case N_INDR | N_EXT:
	case N_SETA:
	case N_SETA | N_EXT:
	case N_SETT:
	case N_SETT | N_EXT:
	case N_SETD:
	case N_SETD | N_EXT:
	case N_SETB:
	case N_SETB | N_EXT:
	case N_SETV:
	  continue;
d210 4
a213 10
	  /*
	   * Debugger symbols
	   */

	case N_SO: {
	  unsigned long valu;
	  static int prev_so_symnum = -10;
	  static int first_so_symnum;
	  char *p;
	  int prev_textlow_not_set;
d215 11
a225 1
	  valu = CUR_SYMBOL_VALUE + ANOFFSET (section_offsets, SECT_OFF_TEXT);
d227 3
a229 1
	  prev_textlow_not_set = textlow_not_set;
d231 1
a231 6
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
	  /* A zero value is probably an indication for the SunPRO 3.0
	     compiler. end_psymtab explicitly tests for zero, so
	     don't relocate it.  */

	  if (CUR_SYMBOL_VALUE == 0)
d233 8
a240 2
	      textlow_not_set = 1;
	      valu = 0;
d242 1
a242 6
	  else
	    textlow_not_set = 0;
#else
	  textlow_not_set = 0;
#endif
	  past_first_source_file = 1;
d244 1
a244 16
	  if (prev_so_symnum != symnum - 1)
	    {			/* Here if prev stab wasn't N_SO */
	      first_so_symnum = symnum;

	      if (pst)
		{
		  END_PSYMTAB (pst, psymtab_include_list, includes_used,
			       symnum * symbol_size,
			       valu > pst->texthigh ? valu : pst->texthigh,
			       dependency_list, dependencies_used,
			       prev_textlow_not_set);
		  pst = (struct partial_symtab *) 0;
		  includes_used = 0;
		  dependencies_used = 0;
		}
	    }
d246 1
a246 1
	  prev_so_symnum = symnum;
d248 1
a248 1
	  /* End the current partial symtab and start a new one */
d250 25
a274 1
	  SET_NAMESTRING();
d276 20
a295 3
	  /* Null name means end of .o file.  Don't start a new one. */
	  if (*namestring == '\000')
	    continue;
d297 5
a301 19
	  /* Some compilers (including gcc) emit a pair of initial N_SOs.
	     The first one is a directory name; the second the file name.
	     If pst exists, is empty, and has a filename ending in '/',
	     we assume the previous N_SO was a directory name. */

	  p = strrchr (namestring, '/');
	  if (p && *(p+1) == '\000')
	    continue;		/* Simply ignore directory name SOs */

	  /* Some other compilers (C++ ones in particular) emit useless
	     SOs for non-existant .c files.  We ignore all subsequent SOs that
	     immediately follow the first.  */

	  if (!pst)
	    pst = START_PSYMTAB (objfile, section_offsets,
				 namestring, valu,
				 first_so_symnum * symbol_size,
				 objfile -> global_psymbols.next,
				 objfile -> static_psymbols.next);
d304 1
d306 1
a306 31
	case N_BINCL:
	  {
#ifdef DBXREAD_ONLY
	    enum language tmp_language;
	    /* Add this bincl to the bincl_list for future EXCLs.  No
	       need to save the string; it'll be around until
	       read_dbx_symtab function returns */

	    SET_NAMESTRING();

	    tmp_language = deduce_language_from_filename (namestring);

	    /* Only change the psymtab's language if we've learned
	       something useful (eg. tmp_language is not language_unknown).
	       In addition, to match what start_subfile does, never change
	       from C++ to C.  */
	    if (tmp_language != language_unknown
		&& (tmp_language != language_c
		    || psymtab_language != language_cplus))
	      psymtab_language = tmp_language;

	    if (pst == NULL)
	      {
		/* FIXME: we should not get here without a PST to work on.
		   Attempt to recover.  */
		complain (&unclaimed_bincl_complaint, namestring, symnum);
		continue;
	      }
	    add_bincl_to_list (pst, namestring, CUR_SYMBOL_VALUE);

	    /* Mark down an include file in the current psymtab */
d308 1
a308 1
	    goto record_include_file;
d311 1
a311 1
	    continue;
d313 1
a313 1
	  }
d315 34
a348 30
	case N_SOL:
	  {
	    enum language tmp_language;
	    /* Mark down an include file in the current psymtab */
	    
	    SET_NAMESTRING();
  
	    tmp_language = deduce_language_from_filename (namestring);
  
	    /* Only change the psymtab's language if we've learned
	       something useful (eg. tmp_language is not language_unknown).
	       In addition, to match what start_subfile does, never change
	       from C++ to C.  */
	    if (tmp_language != language_unknown
		&& (tmp_language != language_c
		    || psymtab_language != language_cplus))
	      psymtab_language = tmp_language;
	    
	    /* In C++, one may expect the same filename to come round many
	       times, when code is coming alternately from the main file
	       and from inline functions in other files. So I check to see
	       if this is a file we've seen before -- either the main
	       source file, or a previously included file.
	       
	       This seems to be a lot of time to be spending on N_SOL, but
	       things like "break c-exp.y:435" need to work (I
	       suppose the psymtab_include_list could be hashed or put
	       in a binary tree, if profiling shows this is a major hog).  */
	    if (pst && STREQ (namestring, pst->filename))
	      continue;
d350 2
a351 9
	      register int i;
	      for (i = 0; i < includes_used; i++)
		if (STREQ (namestring, psymtab_include_list[i]))
		  {
		    i = -1; 
		    break;
		  }
	      if (i == -1)
		continue;
d353 4
a356 1
	    
d358 1
a358 1
	  record_include_file:
d360 22
a381 22
	    
	    psymtab_include_list[includes_used++] = namestring;
	    if (includes_used >= includes_allocated)
	      {
		char **orig = psymtab_include_list;
		
		psymtab_include_list = (char **)
		  alloca ((includes_allocated *= 2) *
			  sizeof (char *));
		memcpy ((PTR)psymtab_include_list, (PTR)orig,
			includes_used * sizeof (char *));
	      }
	    continue;
	  }
	case N_LSYM:		/* Typedef or automatic variable. */
	case N_STSYM:		/* Data seg var -- static  */
	case N_LCSYM:		/* BSS      "  */
	case N_ROSYM:		/* Read-only data seg var -- static.  */
	case N_NBSTS:           /* Gould nobase.  */
	case N_NBLCS:           /* symbols.  */
	case N_FUN:
	case N_GSYM:		/* Global (extern) variable; can be
d384 2
a385 2
	/* Following may probably be ignored; I'll leave them here
	   for now (until I do Pascal and Modula 2 extensions).  */
d387 1
a387 1
	case N_PC:		/* I may or may not need this; I
d389 2
a390 2
	case N_M2C:		/* I suspect that I can ignore this here. */
	case N_SCOPE:		/* Same.   */
d392 1
a392 1
	  SET_NAMESTRING();
d395 18
a412 14
	  /* See if this is an end of function stab.  */
	  if (CUR_SYMBOL_TYPE == N_FUN && *namestring == '\000')
	    {
	      unsigned long valu;

	      /* It's value is the size (in bytes) of the function for
		 function relative stabs, or the address of the function's
		 end for old style stabs.  */
	      valu = CUR_SYMBOL_VALUE + last_function_start;
	      if (pst->texthigh == 0 || valu > pst->texthigh)
		pst->texthigh = valu;
	      break;
	     }
#endif
a413 3
	  p = (char *) strchr (namestring, ':');
	  if (!p)
	    continue;		/* Not a debugging symbol.   */
d416 104
d521 8
a528 6
	  /* Main processing section for debugging symbols which
	     the initial read through the symbol tables needs to worry
	     about.  If we reach this point, the symbol which we are
	     considering is definitely one we are interested in.
	     p must also contain the (valid) index into the namestring
	     which indicates the debugging type symbol.  */
d530 1
a530 88
	  switch (p[1])
	    {
	    case 'S':
	      CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_DATA);
#ifdef STATIC_TRANSFORM_NAME
	      namestring = STATIC_TRANSFORM_NAME (namestring);
#endif
	      add_psymbol_to_list (namestring, p - namestring,
				   VAR_NAMESPACE, LOC_STATIC,
				   &objfile->static_psymbols,
				   0, CUR_SYMBOL_VALUE,
				   psymtab_language, objfile);
	      continue;
	    case 'G':
	      CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_DATA);
	      /* The addresses in these entries are reported to be
		 wrong.  See the code that reads 'G's for symtabs. */
	      add_psymbol_to_list (namestring, p - namestring,
				   VAR_NAMESPACE, LOC_STATIC,
				   &objfile->global_psymbols,
				   0, CUR_SYMBOL_VALUE,
				   psymtab_language, objfile);
	      continue;

	    case 'T':
	      if (p != namestring)	/* a name is there, not just :T... */
		{
		  add_psymbol_to_list (namestring, p - namestring,
				       STRUCT_NAMESPACE, LOC_TYPEDEF,
				       &objfile->static_psymbols,
				       CUR_SYMBOL_VALUE, 0,
				       psymtab_language, objfile);
		  if (p[2] == 't')
		    {
		      /* Also a typedef with the same name.  */
		      add_psymbol_to_list (namestring, p - namestring,
					   VAR_NAMESPACE, LOC_TYPEDEF,
					   &objfile->static_psymbols,
					   CUR_SYMBOL_VALUE, 0,
					   psymtab_language, objfile);
		      p += 1;
		    }
		  /* The semantics of C++ state that "struct foo { ... }"
		     also defines a typedef for "foo".  Unfortuantely, cfront
		     never makes the typedef when translating from C++ to C.
		     We make the typedef here so that "ptype foo" works as
		     expected for cfront translated code.  */
		  else if (psymtab_language == language_cplus)
		   {
		      /* Also a typedef with the same name.  */
		      add_psymbol_to_list (namestring, p - namestring,
					   VAR_NAMESPACE, LOC_TYPEDEF,
					   &objfile->static_psymbols,
					   CUR_SYMBOL_VALUE, 0,
					   psymtab_language, objfile);
		   }
		}
	      goto check_enum;
	    case 't':
	      if (p != namestring)	/* a name is there, not just :T... */
		{
		  add_psymbol_to_list (namestring, p - namestring,
				       VAR_NAMESPACE, LOC_TYPEDEF,
				       &objfile->static_psymbols,
				       CUR_SYMBOL_VALUE, 0,
				       psymtab_language, objfile);
		}
	    check_enum:
	      /* If this is an enumerated type, we need to
		 add all the enum constants to the partial symbol
		 table.  This does not cover enums without names, e.g.
		 "enum {a, b} c;" in C, but fortunately those are
		 rare.  There is no way for GDB to find those from the
		 enum type without spending too much time on it.  Thus
		 to solve this problem, the compiler needs to put out the
		 enum in a nameless type.  GCC2 does this.  */

	      /* We are looking for something of the form
		 <name> ":" ("t" | "T") [<number> "="] "e"
		 {<constant> ":" <value> ","} ";".  */

	      /* Skip over the colon and the 't' or 'T'.  */
	      p += 2;
	      /* This type may be given a number.  Also, numbers can come
		 in pairs like (0,26).  Skip over it.  */
	      while ((*p >= '0' && *p <= '9')
		     || *p == '(' || *p == ',' || *p == ')'
		     || *p == '=')
d532 10
d543 33
a575 55
	      if (*p++ == 'e')
		{
		  /* The aix4 compiler emits extra crud before the members.  */
		  if (*p == '-')
		    {
		      /* Skip over the type (?).  */
		      while (*p != ':')
			p++;

		      /* Skip over the colon.  */
		      p++;
		    }

		  /* We have found an enumerated type.  */
		  /* According to comments in read_enum_type
		     a comma could end it instead of a semicolon.
		     I don't know where that happens.
		     Accept either.  */
		  while (*p && *p != ';' && *p != ',')
		    {
		      char *q;

		      /* Check for and handle cretinous dbx symbol name
			 continuation!  */
		      if (*p == '\\' || (*p == '?' && p[1] == '\0'))
			p = next_symbol_text (objfile);

		      /* Point to the character after the name
			 of the enum constant.  */
		      for (q = p; *q && *q != ':'; q++)
			;
		      /* Note that the value doesn't matter for
			 enum constants in psymtabs, just in symtabs.  */
		      add_psymbol_to_list (p, q - p,
					   VAR_NAMESPACE, LOC_CONST,
					   &objfile->static_psymbols, 0,
					   0, psymtab_language, objfile);
		      /* Point past the name.  */
		      p = q;
		      /* Skip over the value.  */
		      while (*p && *p != ',')
			p++;
		      /* Advance past the comma.  */
		      if (*p)
			p++;
		    }
		}
	      continue;
	    case 'c':
	      /* Constant, e.g. from "const" in Pascal.  */
	      add_psymbol_to_list (namestring, p - namestring,
				   VAR_NAMESPACE, LOC_CONST,
				   &objfile->static_psymbols, CUR_SYMBOL_VALUE,
				   0, psymtab_language, objfile);
	      continue;
d577 2
a578 2
	    case 'f':
	      CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d580 2
a581 5
	      /* Keep track of the start of the last function so we
		 can handle end of function symbols.  */
	      last_function_start = CUR_SYMBOL_VALUE;
	      /* Kludges for ELF/STABS with Sun ACC */
	      last_function_name = namestring;
d583 8
a590 12
	      /* Do not fix textlow==0 for .o or NLM files, as 0 is a legit
		 value for the bottom of the text seg in those cases. */
	      if (pst && textlow_not_set)
		{
		  pst->textlow =
		    find_stab_function_addr (namestring, pst, objfile);
		  textlow_not_set = 0;
		}
#endif
#if 0
	      if (startup_file_end == 0)
		startup_file_end = CUR_SYMBOL_VALUE;
d592 1
a592 1
	      /* End kludge.  */
d594 16
a609 12
	      /* In reordered executables this function may lie outside
		 the bounds created by N_SO symbols.  If that's the case
		 use the address of this function as the low bound for
		 the partial symbol table.  */
	      if (textlow_not_set
		  || (CUR_SYMBOL_VALUE < pst->textlow
		      && CUR_SYMBOL_VALUE
			   != ANOFFSET (section_offsets, SECT_OFF_TEXT)))
		{
		  pst->textlow = CUR_SYMBOL_VALUE;
		  textlow_not_set = 0;
		}
d611 12
a622 12
	      add_psymbol_to_list (namestring, p - namestring,
				   VAR_NAMESPACE, LOC_BLOCK,
				   &objfile->static_psymbols,
				   0, CUR_SYMBOL_VALUE,
				   psymtab_language, objfile);
	      continue;

	      /* Global functions were ignored here, but now they
	         are put into the global psymtab like one would expect.
		 They're also in the minimal symbol table.  */
	    case 'F':
	      CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d624 2
a625 5
	      /* Keep track of the start of the last function so we
		 can handle end of function symbols.  */
	      last_function_start = CUR_SYMBOL_VALUE;
	      /* Kludges for ELF/STABS with Sun ACC */
	      last_function_name = namestring;
d627 11
a637 8
	      /* Do not fix textlow==0 for .o or NLM files, as 0 is a legit
		 value for the bottom of the text seg in those cases. */
	      if (pst && textlow_not_set)
		{
		  pst->textlow =
		    find_stab_function_addr (namestring, pst, objfile);
		  textlow_not_set = 0;
		}
d639 18
a656 17
#if 0
	      if (startup_file_end == 0)
		startup_file_end = CUR_SYMBOL_VALUE;
#endif
	      /* End kludge.  */
	      /* In reordered executables this function may lie outside
		 the bounds created by N_SO symbols.  If that's the case
		 use the address of this function as the low bound for
		 the partial symbol table.  */
	      if (textlow_not_set
		  || (CUR_SYMBOL_VALUE < pst->textlow
		      && CUR_SYMBOL_VALUE
			   != ANOFFSET (section_offsets, SECT_OFF_TEXT)))
		{
		  pst->textlow = CUR_SYMBOL_VALUE;
		  textlow_not_set = 0;
		}
d658 53
a710 53
	      add_psymbol_to_list (namestring, p - namestring,
				   VAR_NAMESPACE, LOC_BLOCK,
				   &objfile->global_psymbols,
				   0, CUR_SYMBOL_VALUE,
				   psymtab_language, objfile);
	      continue;

	      /* Two things show up here (hopefully); static symbols of
		 local scope (static used inside braces) or extensions
		 of structure symbols.  We can ignore both.  */
	    case 'V':
	    case '(':
	    case '0':
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
	    case '9':
	    case '-':
	    case '#':   /* for symbol identification (used in live ranges) */
	   /* added to support cfront stabs strings */
	    case 'Z':	/* for definition continuations */
	    case 'P':	/* for prototypes */
	      continue;

	    case ':':
	      /* It is a C++ nested symbol.  We don't need to record it
		 (I don't think); if we try to look up foo::bar::baz,
		 then symbols for the symtab containing foo should get
		 read in, I think.  */
	      /* Someone says sun cc puts out symbols like
		 /foo/baz/maclib::/usr/local/bin/maclib,
		 which would get here with a symbol type of ':'.  */
	      continue;

	    default:
	      /* Unexpected symbol descriptor.  The second and subsequent stabs
		 of a continued stab can show up here.  The question is
		 whether they ever can mimic a normal stab--it would be
		 nice if not, since we certainly don't want to spend the
		 time searching to the end of every string looking for
		 a backslash.  */

	      complain (&unknown_symchar_complaint, p[1]);

	      /* Ignore it; perhaps it is an extension that we don't
		 know about.  */
	      continue;
	    }
d712 1
a712 1
	case N_EXCL:
d715 1
a715 1
	  SET_NAMESTRING();
d717 10
a726 5
	  /* Find the corresponding bincl and mark that psymtab on the
	     psymtab dependency list */
	  {
	    struct partial_symtab *needed_pst =
	      find_corresponding_bincl_psymtab (namestring, CUR_SYMBOL_VALUE);
d728 4
a731 3
	    /* If this include file was defined earlier in this file,
	       leave it alone.  */
	    if (needed_pst == pst) continue;
d733 2
a734 1
	    if (needed_pst)
d736 7
a742 2
		int i;
		int found = 0;
d744 11
a754 21
		for (i = 0; i < dependencies_used; i++)
		  if (dependency_list[i] == needed_pst)
		    {
		      found = 1;
		      break;
		    }

		/* If it's already in the list, skip the rest.  */
		if (found) continue;

		dependency_list[dependencies_used++] = needed_pst;
		if (dependencies_used >= dependencies_allocated)
		  {
		    struct partial_symtab **orig = dependency_list;
		    dependency_list =
		      (struct partial_symtab **)
			alloca ((dependencies_allocated *= 2)
				* sizeof (struct partial_symtab *));
		    memcpy ((PTR)dependency_list, (PTR)orig,
			   (dependencies_used
			    * sizeof (struct partial_symtab *)));
d756 3
a758 3
		    fprintf_unfiltered (gdb_stderr, "Had to reallocate dependency list.\n");
		    fprintf_unfiltered (gdb_stderr, "New dependencies allocated: %d\n",
			     dependencies_allocated);
d760 3
a762 3
		  }
	      }
	  }
d764 1
a764 1
	  continue;
d766 1
a766 1
	case N_ENDM:
d768 14
a781 14
	  /* Solaris 2 end of module, finish current partial symbol table.
	     END_PSYMTAB will set pst->texthigh to the proper value, which
	     is necessary if a module compiled without debugging info
	     follows this module.  */
	  if (pst)
	    {
	      END_PSYMTAB (pst, psymtab_include_list, includes_used,
			   symnum * symbol_size,
			   (CORE_ADDR) 0,
			   dependency_list, dependencies_used, textlow_not_set);
	      pst = (struct partial_symtab *) 0;
	      includes_used = 0;
	      dependencies_used = 0;
	    }
d783 1
a783 1
	  continue;
d785 1
a785 1
	case N_RBRAC:
d787 2
a788 2
	  HANDLE_RBRAC(CUR_SYMBOL_VALUE);
	  continue;
d790 4
a793 4
	case N_EINCL:
	case N_DSLINE:
	case N_BSLINE:
	case N_SSYM:		/* Claim: Structure or union element.
d795 30
a824 30
	case N_ENTRY:		/* Alternate entry point; can ignore. */
	case N_MAIN:		/* Can definitely ignore this.   */
	case N_CATCH:		/* These are GNU C++ extensions */
	case N_EHDECL:		/* that can safely be ignored here. */
	case N_LENG:
	case N_BCOMM:
	case N_ECOMM:
	case N_ECOML:
	case N_FNAME:
	case N_SLINE:
	case N_RSYM:
	case N_PSYM:
	case N_LBRAC:
	case N_NSYMS:		/* Ultrix 4.0: symbol count */
	case N_DEFD:		/* GNU Modula-2 */
	case N_ALIAS:		/* SunPro F77: alias name, ignore for now.  */

	case N_OBJ:		/* useless types from Solaris */
	case N_OPT:
	  /* These symbols aren't interesting; don't worry about them */

	  continue;

	default:
	  /* If we haven't found it yet, ignore it.  It's probably some
	     new type we don't know about yet.  */
	  complain (&unknown_symtype_complaint,
		    local_hex_string (CUR_SYMBOL_TYPE));
	  continue;
	}
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-06-14 snapshot
@
text
@d444 1
a444 9
	      /* When a 'T' entry is defining an anonymous enum, it
		 may have a name which is the empty string, or a
		 single space.  Since they're not really defining a
		 symbol, those shouldn't go in the partial symbol
		 table.  We do pick up the elements of such enums at
		 'check_enum:', below.  */
	      if (p >= namestring + 2
		  || (p == namestring + 1
		      && namestring[0] != ' '))
d583 4
d629 4
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d30 1
a30 1
   file names (N_SOL) seen so far.
d32 1
a32 1
   N_EXCL stabs seen so far.
d40 23
a62 23
switch (CUR_SYMBOL_TYPE)
  {
    char *p;
    /*
     * Standard, external, non-debugger, symbols
     */

  case N_TEXT | N_EXT:
  case N_NBTEXT | N_EXT:
    CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_TEXT);
    goto record_it;

  case N_DATA | N_EXT:
  case N_NBDATA | N_EXT:
    CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_DATA);
    goto record_it;

  case N_BSS:
  case N_BSS | N_EXT:
  case N_NBBSS | N_EXT:
  case N_SETV | N_EXT:		/* FIXME, is this in BSS? */
    CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_BSS);
    goto record_it;
d64 2
a65 2
  case N_ABS | N_EXT:
  record_it:
d67 1
a67 1
    SET_NAMESTRING ();
d69 3
a71 3
  bss_ext_symbol:
    record_minimal_symbol (namestring, CUR_SYMBOL_VALUE,
			   CUR_SYMBOL_TYPE, objfile);	/* Always */
d73 1
a73 1
    continue;
d75 1
a75 1
    /* Standard, local, non-debugger, symbols */
d77 1
a77 1
  case N_NBTEXT:
d79 8
a86 8
    /* We need to be able to deal with both N_FN or N_TEXT,
       because we have no way of knowing whether the sys-supplied ld
       or GNU ld was used to make the executable.  Sequents throw
       in another wrinkle -- they renumbered N_FN.  */

  case N_FN:
  case N_FN_SEQ:
  case N_TEXT:
d88 32
a119 32
    CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_TEXT);
    SET_NAMESTRING ();
    if ((namestring[0] == '-' && namestring[1] == 'l')
	|| (namestring[(nsl = strlen (namestring)) - 1] == 'o'
	    && namestring[nsl - 2] == '.'))
      {
	if (objfile->ei.entry_point < CUR_SYMBOL_VALUE &&
	    objfile->ei.entry_point >= last_o_file_start)
	  {
	    objfile->ei.entry_file_lowpc = last_o_file_start;
	    objfile->ei.entry_file_highpc = CUR_SYMBOL_VALUE;
	  }
	if (past_first_source_file && pst
	/* The gould NP1 uses low values for .o and -l symbols
	   which are not the address.  */
	    && CUR_SYMBOL_VALUE >= pst->textlow)
	  {
	    END_PSYMTAB (pst, psymtab_include_list, includes_used,
			 symnum * symbol_size,
			 CUR_SYMBOL_VALUE > pst->texthigh
			 ? CUR_SYMBOL_VALUE : pst->texthigh,
		       dependency_list, dependencies_used, textlow_not_set);
	    pst = (struct partial_symtab *) 0;
	    includes_used = 0;
	    dependencies_used = 0;
	  }
	else
	  past_first_source_file = 1;
	last_o_file_start = CUR_SYMBOL_VALUE;
      }
    else
      goto record_it;
d121 1
a121 1
    continue;
d123 3
a125 3
  case N_DATA:
    CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_DATA);
    goto record_it;
d127 1
a127 1
  case N_UNDF | N_EXT:
d129 13
a141 11
    if (CUR_SYMBOL_VALUE != 0)
      {
	/* This is a "Fortran COMMON" symbol.  See if the target
	   environment knows where it has been relocated to.  */

	CORE_ADDR reladdr;

	SET_NAMESTRING ();
	if (target_lookup_symbol (namestring, &reladdr))
	  {
	    continue;		/* Error in lookup; ignore symbol for now.  */
a142 4
	CUR_SYMBOL_TYPE ^= (N_BSS ^ N_UNDF);	/* Define it as a bss-symbol */
	CUR_SYMBOL_VALUE = reladdr;
	goto bss_ext_symbol;
      }
d144 1
a144 1
    continue;			/* Just undefined, not COMMON */
d146 1
a146 1
  case N_UNDF:
d148 15
a162 16
    if (processing_acc_compilation && CUR_SYMBOL_STRX == 1)
      {
	/* Deal with relative offsets in the string table
	   used in ELF+STAB under Solaris.  If we want to use the
	   n_strx field, which contains the name of the file,
	   we must adjust file_string_table_offset *before* calling
	   SET_NAMESTRING().  */
	past_first_source_file = 1;
	file_string_table_offset = next_file_string_table_offset;
	next_file_string_table_offset =
	  file_string_table_offset + CUR_SYMBOL_VALUE;
	if (next_file_string_table_offset < file_string_table_offset)
	  error ("string table offset backs up at %d", symnum);
	/* FIXME -- replace error() with complaint.  */
	continue;
      }
d164 10
a173 1
    continue;
d175 15
a189 1
    /* Lots of symbol types we can just ignore.  */
d191 10
a200 34
  case N_ABS:
  case N_NBDATA:
  case N_NBBSS:
    continue;

    /* Keep going . . . */

    /*
     * Special symbol types for GNU
     */
  case N_INDR:
  case N_INDR | N_EXT:
  case N_SETA:
  case N_SETA | N_EXT:
  case N_SETT:
  case N_SETT | N_EXT:
  case N_SETD:
  case N_SETD | N_EXT:
  case N_SETB:
  case N_SETB | N_EXT:
  case N_SETV:
    continue;

    /*
     * Debugger symbols
     */

  case N_SO:
    {
      unsigned long valu;
      static int prev_so_symnum = -10;
      static int first_so_symnum;
      char *p;
      int prev_textlow_not_set;
d202 1
a202 1
      valu = CUR_SYMBOL_VALUE + ANOFFSET (section_offsets, SECT_OFF_TEXT);
d204 1
a204 1
      prev_textlow_not_set = textlow_not_set;
d207 3
a209 3
      /* A zero value is probably an indication for the SunPRO 3.0
         compiler. end_psymtab explicitly tests for zero, so
         don't relocate it.  */
d211 7
a217 7
      if (CUR_SYMBOL_VALUE == 0)
	{
	  textlow_not_set = 1;
	  valu = 0;
	}
      else
	textlow_not_set = 0;
d219 1
a219 1
      textlow_not_set = 0;
d221 1
a221 1
      past_first_source_file = 1;
d223 16
a238 3
      if (prev_so_symnum != symnum - 1)
	{			/* Here if prev stab wasn't N_SO */
	  first_so_symnum = symnum;
d240 1
a240 12
	  if (pst)
	    {
	      END_PSYMTAB (pst, psymtab_include_list, includes_used,
			   symnum * symbol_size,
			   valu > pst->texthigh ? valu : pst->texthigh,
			   dependency_list, dependencies_used,
			   prev_textlow_not_set);
	      pst = (struct partial_symtab *) 0;
	      includes_used = 0;
	      dependencies_used = 0;
	    }
	}
d242 1
a242 1
      prev_so_symnum = symnum;
d244 1
a244 1
      /* End the current partial symtab and start a new one */
d246 3
a248 1
      SET_NAMESTRING ();
d250 21
a270 25
      /* Null name means end of .o file.  Don't start a new one. */
      if (*namestring == '\000')
	continue;

      /* Some compilers (including gcc) emit a pair of initial N_SOs.
         The first one is a directory name; the second the file name.
         If pst exists, is empty, and has a filename ending in '/',
         we assume the previous N_SO was a directory name. */

      p = strrchr (namestring, '/');
      if (p && *(p + 1) == '\000')
	continue;		/* Simply ignore directory name SOs */

      /* Some other compilers (C++ ones in particular) emit useless
         SOs for non-existant .c files.  We ignore all subsequent SOs that
         immediately follow the first.  */

      if (!pst)
	pst = START_PSYMTAB (objfile, section_offsets,
			     namestring, valu,
			     first_so_symnum * symbol_size,
			     objfile->global_psymbols.next,
			     objfile->static_psymbols.next);
      continue;
    }
d272 2
a273 2
  case N_BINCL:
    {
d275 17
a291 17
      enum language tmp_language;
      /* Add this bincl to the bincl_list for future EXCLs.  No
         need to save the string; it'll be around until
         read_dbx_symtab function returns */

      SET_NAMESTRING ();

      tmp_language = deduce_language_from_filename (namestring);

      /* Only change the psymtab's language if we've learned
         something useful (eg. tmp_language is not language_unknown).
         In addition, to match what start_subfile does, never change
         from C++ to C.  */
      if (tmp_language != language_unknown
	  && (tmp_language != language_c
	      || psymtab_language != language_cplus))
	psymtab_language = tmp_language;
d293 8
a300 8
      if (pst == NULL)
	{
	  /* FIXME: we should not get here without a PST to work on.
	     Attempt to recover.  */
	  complain (&unclaimed_bincl_complaint, namestring, symnum);
	  continue;
	}
      add_bincl_to_list (pst, namestring, CUR_SYMBOL_VALUE);
d302 1
a302 1
      /* Mark down an include file in the current psymtab */
d304 1
a304 1
      goto record_include_file;
d307 1
a307 1
      continue;
d309 1
a309 1
    }
d311 30
a340 34
  case N_SOL:
    {
      enum language tmp_language;
      /* Mark down an include file in the current psymtab */

      SET_NAMESTRING ();

      tmp_language = deduce_language_from_filename (namestring);

      /* Only change the psymtab's language if we've learned
         something useful (eg. tmp_language is not language_unknown).
         In addition, to match what start_subfile does, never change
         from C++ to C.  */
      if (tmp_language != language_unknown
	  && (tmp_language != language_c
	      || psymtab_language != language_cplus))
	psymtab_language = tmp_language;

      /* In C++, one may expect the same filename to come round many
         times, when code is coming alternately from the main file
         and from inline functions in other files. So I check to see
         if this is a file we've seen before -- either the main
         source file, or a previously included file.

         This seems to be a lot of time to be spending on N_SOL, but
         things like "break c-exp.y:435" need to work (I
         suppose the psymtab_include_list could be hashed or put
         in a binary tree, if profiling shows this is a major hog).  */
      if (pst && STREQ (namestring, pst->filename))
	continue;
      {
	register int i;
	for (i = 0; i < includes_used; i++)
	  if (STREQ (namestring, psymtab_include_list[i]))
d342 9
a350 2
	      i = -1;
	      break;
d352 1
a352 4
	if (i == -1)
	  continue;
      }

d354 1
a354 1
    record_include_file:
d356 22
a377 22

      psymtab_include_list[includes_used++] = namestring;
      if (includes_used >= includes_allocated)
	{
	  char **orig = psymtab_include_list;

	  psymtab_include_list = (char **)
	    alloca ((includes_allocated *= 2) *
		    sizeof (char *));
	  memcpy ((PTR) psymtab_include_list, (PTR) orig,
		  includes_used * sizeof (char *));
	}
      continue;
    }
  case N_LSYM:			/* Typedef or automatic variable. */
  case N_STSYM:		/* Data seg var -- static  */
  case N_LCSYM:		/* BSS      "  */
  case N_ROSYM:		/* Read-only data seg var -- static.  */
  case N_NBSTS:		/* Gould nobase.  */
  case N_NBLCS:		/* symbols.  */
  case N_FUN:
  case N_GSYM:			/* Global (extern) variable; can be
d380 2
a381 2
    /* Following may probably be ignored; I'll leave them here
       for now (until I do Pascal and Modula 2 extensions).  */
d383 1
a383 1
  case N_PC:			/* I may or may not need this; I
d385 2
a386 2
  case N_M2C:			/* I suspect that I can ignore this here. */
  case N_SCOPE:		/* Same.   */
d388 1
a388 1
    SET_NAMESTRING ();
d391 13
a403 13
    /* See if this is an end of function stab.  */
    if (CUR_SYMBOL_TYPE == N_FUN && *namestring == '\000')
      {
	unsigned long valu;

	/* It's value is the size (in bytes) of the function for
	   function relative stabs, or the address of the function's
	   end for old style stabs.  */
	valu = CUR_SYMBOL_VALUE + last_function_start;
	if (pst->texthigh == 0 || valu > pst->texthigh)
	  pst->texthigh = valu;
	break;
      }
d406 4
a409 3
    p = (char *) strchr (namestring, ':');
    if (!p)
      continue;			/* Not a debugging symbol.   */
d412 6
d419 4
a422 11
    /* Main processing section for debugging symbols which
       the initial read through the symbol tables needs to worry
       about.  If we reach this point, the symbol which we are
       considering is definitely one we are interested in.
       p must also contain the (valid) index into the namestring
       which indicates the debugging type symbol.  */

    switch (p[1])
      {
      case 'S':
	CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_DATA);
d424 1
a424 1
	namestring = STATIC_TRANSFORM_NAME (namestring);
d426 89
a514 101
	add_psymbol_to_list (namestring, p - namestring,
			     VAR_NAMESPACE, LOC_STATIC,
			     &objfile->static_psymbols,
			     0, CUR_SYMBOL_VALUE,
			     psymtab_language, objfile);
	continue;
      case 'G':
	CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_DATA);
	/* The addresses in these entries are reported to be
	   wrong.  See the code that reads 'G's for symtabs. */
	add_psymbol_to_list (namestring, p - namestring,
			     VAR_NAMESPACE, LOC_STATIC,
			     &objfile->global_psymbols,
			     0, CUR_SYMBOL_VALUE,
			     psymtab_language, objfile);
	continue;

      case 'T':
	/* When a 'T' entry is defining an anonymous enum, it
	   may have a name which is the empty string, or a
	   single space.  Since they're not really defining a
	   symbol, those shouldn't go in the partial symbol
	   table.  We do pick up the elements of such enums at
	   'check_enum:', below.  */
	if (p >= namestring + 2
	    || (p == namestring + 1
		&& namestring[0] != ' '))
	  {
	    add_psymbol_to_list (namestring, p - namestring,
				 STRUCT_NAMESPACE, LOC_TYPEDEF,
				 &objfile->static_psymbols,
				 CUR_SYMBOL_VALUE, 0,
				 psymtab_language, objfile);
	    if (p[2] == 't')
	      {
		/* Also a typedef with the same name.  */
		add_psymbol_to_list (namestring, p - namestring,
				     VAR_NAMESPACE, LOC_TYPEDEF,
				     &objfile->static_psymbols,
				     CUR_SYMBOL_VALUE, 0,
				     psymtab_language, objfile);
		p += 1;
	      }
	    /* The semantics of C++ state that "struct foo { ... }"
	       also defines a typedef for "foo".  Unfortuantely, cfront
	       never makes the typedef when translating from C++ to C.
	       We make the typedef here so that "ptype foo" works as
	       expected for cfront translated code.  */
	    else if (psymtab_language == language_cplus)
	      {
		/* Also a typedef with the same name.  */
		add_psymbol_to_list (namestring, p - namestring,
				     VAR_NAMESPACE, LOC_TYPEDEF,
				     &objfile->static_psymbols,
				     CUR_SYMBOL_VALUE, 0,
				     psymtab_language, objfile);
	      }
	  }
	goto check_enum;
      case 't':
	if (p != namestring)	/* a name is there, not just :T... */
	  {
	    add_psymbol_to_list (namestring, p - namestring,
				 VAR_NAMESPACE, LOC_TYPEDEF,
				 &objfile->static_psymbols,
				 CUR_SYMBOL_VALUE, 0,
				 psymtab_language, objfile);
	  }
      check_enum:
	/* If this is an enumerated type, we need to
	   add all the enum constants to the partial symbol
	   table.  This does not cover enums without names, e.g.
	   "enum {a, b} c;" in C, but fortunately those are
	   rare.  There is no way for GDB to find those from the
	   enum type without spending too much time on it.  Thus
	   to solve this problem, the compiler needs to put out the
	   enum in a nameless type.  GCC2 does this.  */

	/* We are looking for something of the form
	   <name> ":" ("t" | "T") [<number> "="] "e"
	   {<constant> ":" <value> ","} ";".  */

	/* Skip over the colon and the 't' or 'T'.  */
	p += 2;
	/* This type may be given a number.  Also, numbers can come
	   in pairs like (0,26).  Skip over it.  */
	while ((*p >= '0' && *p <= '9')
	       || *p == '(' || *p == ',' || *p == ')'
	       || *p == '=')
	  p++;

	if (*p++ == 'e')
	  {
	    /* The aix4 compiler emits extra crud before the members.  */
	    if (*p == '-')
	      {
		/* Skip over the type (?).  */
		while (*p != ':')
		  p++;

		/* Skip over the colon.  */
a515 10
	      }

	    /* We have found an enumerated type.  */
	    /* According to comments in read_enum_type
	       a comma could end it instead of a semicolon.
	       I don't know where that happens.
	       Accept either.  */
	    while (*p && *p != ';' && *p != ',')
	      {
		char *q;
d517 55
a571 33
		/* Check for and handle cretinous dbx symbol name
		   continuation!  */
		if (*p == '\\' || (*p == '?' && p[1] == '\0'))
		  p = next_symbol_text (objfile);

		/* Point to the character after the name
		   of the enum constant.  */
		for (q = p; *q && *q != ':'; q++)
		  ;
		/* Note that the value doesn't matter for
		   enum constants in psymtabs, just in symtabs.  */
		add_psymbol_to_list (p, q - p,
				     VAR_NAMESPACE, LOC_CONST,
				     &objfile->static_psymbols, 0,
				     0, psymtab_language, objfile);
		/* Point past the name.  */
		p = q;
		/* Skip over the value.  */
		while (*p && *p != ',')
		  p++;
		/* Advance past the comma.  */
		if (*p)
		  p++;
	      }
	  }
	continue;
      case 'c':
	/* Constant, e.g. from "const" in Pascal.  */
	add_psymbol_to_list (namestring, p - namestring,
			     VAR_NAMESPACE, LOC_CONST,
			     &objfile->static_psymbols, CUR_SYMBOL_VALUE,
			     0, psymtab_language, objfile);
	continue;
d573 2
a574 2
      case 'f':
	CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d576 5
a580 5
	/* Keep track of the start of the last function so we
	   can handle end of function symbols.  */
	last_function_start = CUR_SYMBOL_VALUE;
	/* Kludges for ELF/STABS with Sun ACC */
	last_function_name = namestring;
d582 8
a589 8
	/* Do not fix textlow==0 for .o or NLM files, as 0 is a legit
	   value for the bottom of the text seg in those cases. */
	if (pst && textlow_not_set)
	  {
	    pst->textlow =
	      find_stab_function_addr (namestring, pst, objfile);
	    textlow_not_set = 0;
	  }
d591 1
a591 1
	/* End kludge.  */
d593 12
a604 12
	/* In reordered executables this function may lie outside
	   the bounds created by N_SO symbols.  If that's the case
	   use the address of this function as the low bound for
	   the partial symbol table.  */
	if (textlow_not_set
	    || (CUR_SYMBOL_VALUE < pst->textlow
		&& CUR_SYMBOL_VALUE
		!= ANOFFSET (section_offsets, SECT_OFF_TEXT)))
	  {
	    pst->textlow = CUR_SYMBOL_VALUE;
	    textlow_not_set = 0;
	  }
d606 12
a617 12
	add_psymbol_to_list (namestring, p - namestring,
			     VAR_NAMESPACE, LOC_BLOCK,
			     &objfile->static_psymbols,
			     0, CUR_SYMBOL_VALUE,
			     psymtab_language, objfile);
	continue;

	/* Global functions were ignored here, but now they
	   are put into the global psymtab like one would expect.
	   They're also in the minimal symbol table.  */
      case 'F':
	CUR_SYMBOL_VALUE += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d619 5
a623 5
	/* Keep track of the start of the last function so we
	   can handle end of function symbols.  */
	last_function_start = CUR_SYMBOL_VALUE;
	/* Kludges for ELF/STABS with Sun ACC */
	last_function_name = namestring;
d625 8
a632 8
	/* Do not fix textlow==0 for .o or NLM files, as 0 is a legit
	   value for the bottom of the text seg in those cases. */
	if (pst && textlow_not_set)
	  {
	    pst->textlow =
	      find_stab_function_addr (namestring, pst, objfile);
	    textlow_not_set = 0;
	  }
d634 13
a646 13
	/* End kludge.  */
	/* In reordered executables this function may lie outside
	   the bounds created by N_SO symbols.  If that's the case
	   use the address of this function as the low bound for
	   the partial symbol table.  */
	if (textlow_not_set
	    || (CUR_SYMBOL_VALUE < pst->textlow
		&& CUR_SYMBOL_VALUE
		!= ANOFFSET (section_offsets, SECT_OFF_TEXT)))
	  {
	    pst->textlow = CUR_SYMBOL_VALUE;
	    textlow_not_set = 0;
	  }
d648 53
a700 53
	add_psymbol_to_list (namestring, p - namestring,
			     VAR_NAMESPACE, LOC_BLOCK,
			     &objfile->global_psymbols,
			     0, CUR_SYMBOL_VALUE,
			     psymtab_language, objfile);
	continue;

	/* Two things show up here (hopefully); static symbols of
	   local scope (static used inside braces) or extensions
	   of structure symbols.  We can ignore both.  */
      case 'V':
      case '(':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
      case '#':		/* for symbol identification (used in live ranges) */
	/* added to support cfront stabs strings */
      case 'Z':		/* for definition continuations */
      case 'P':		/* for prototypes */
	continue;

      case ':':
	/* It is a C++ nested symbol.  We don't need to record it
	   (I don't think); if we try to look up foo::bar::baz,
	   then symbols for the symtab containing foo should get
	   read in, I think.  */
	/* Someone says sun cc puts out symbols like
	   /foo/baz/maclib::/usr/local/bin/maclib,
	   which would get here with a symbol type of ':'.  */
	continue;

      default:
	/* Unexpected symbol descriptor.  The second and subsequent stabs
	   of a continued stab can show up here.  The question is
	   whether they ever can mimic a normal stab--it would be
	   nice if not, since we certainly don't want to spend the
	   time searching to the end of every string looking for
	   a backslash.  */

	complain (&unknown_symchar_complaint, p[1]);

	/* Ignore it; perhaps it is an extension that we don't
	   know about.  */
	continue;
      }
d702 1
a702 1
  case N_EXCL:
d705 1
a705 1
    SET_NAMESTRING ();
d707 5
a711 10
    /* Find the corresponding bincl and mark that psymtab on the
       psymtab dependency list */
    {
      struct partial_symtab *needed_pst =
      find_corresponding_bincl_psymtab (namestring, CUR_SYMBOL_VALUE);

      /* If this include file was defined earlier in this file,
         leave it alone.  */
      if (needed_pst == pst)
	continue;
d713 3
a715 4
      if (needed_pst)
	{
	  int i;
	  int found = 0;
d717 1
a717 2
	  for (i = 0; i < dependencies_used; i++)
	    if (dependency_list[i] == needed_pst)
d719 2
a720 3
		found = 1;
		break;
	      }
d722 21
a742 15
	  /* If it's already in the list, skip the rest.  */
	  if (found)
	    continue;

	  dependency_list[dependencies_used++] = needed_pst;
	  if (dependencies_used >= dependencies_allocated)
	    {
	      struct partial_symtab **orig = dependency_list;
	      dependency_list =
		(struct partial_symtab **)
		alloca ((dependencies_allocated *= 2)
			* sizeof (struct partial_symtab *));
	      memcpy ((PTR) dependency_list, (PTR) orig,
		      (dependencies_used
		       * sizeof (struct partial_symtab *)));
d744 3
a746 3
	      fprintf_unfiltered (gdb_stderr, "Had to reallocate dependency list.\n");
	      fprintf_unfiltered (gdb_stderr, "New dependencies allocated: %d\n",
				  dependencies_allocated);
d748 3
a750 3
	    }
	}
    }
d752 1
a752 1
    continue;
d754 1
a754 1
  case N_ENDM:
d756 14
a769 14
    /* Solaris 2 end of module, finish current partial symbol table.
       END_PSYMTAB will set pst->texthigh to the proper value, which
       is necessary if a module compiled without debugging info
       follows this module.  */
    if (pst)
      {
	END_PSYMTAB (pst, psymtab_include_list, includes_used,
		     symnum * symbol_size,
		     (CORE_ADDR) 0,
		     dependency_list, dependencies_used, textlow_not_set);
	pst = (struct partial_symtab *) 0;
	includes_used = 0;
	dependencies_used = 0;
      }
d771 1
a771 1
    continue;
d773 1
a773 1
  case N_RBRAC:
d775 2
a776 2
    HANDLE_RBRAC (CUR_SYMBOL_VALUE);
    continue;
d778 4
a781 4
  case N_EINCL:
  case N_DSLINE:
  case N_BSLINE:
  case N_SSYM:			/* Claim: Structure or union element.
d783 30
a812 30
  case N_ENTRY:		/* Alternate entry point; can ignore. */
  case N_MAIN:			/* Can definitely ignore this.   */
  case N_CATCH:		/* These are GNU C++ extensions */
  case N_EHDECL:		/* that can safely be ignored here. */
  case N_LENG:
  case N_BCOMM:
  case N_ECOMM:
  case N_ECOML:
  case N_FNAME:
  case N_SLINE:
  case N_RSYM:
  case N_PSYM:
  case N_LBRAC:
  case N_NSYMS:		/* Ultrix 4.0: symbol count */
  case N_DEFD:			/* GNU Modula-2 */
  case N_ALIAS:		/* SunPro F77: alias name, ignore for now.  */

  case N_OBJ:			/* useless types from Solaris */
  case N_OPT:
    /* These symbols aren't interesting; don't worry about them */

    continue;

  default:
    /* If we haven't found it yet, ignore it.  It's probably some
       new type we don't know about yet.  */
    complain (&unknown_symtype_complaint,
	      local_hex_string (CUR_SYMBOL_TYPE));
    continue;
  }
@


1.1.1.4
log
@import gdb-1999-08-09 snapshot
@
text
@d50 1
a50 1
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d55 1
a55 1
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d62 1
a62 1
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS);
d89 1
a89 1
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d125 1
a125 1
    CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d207 1
a207 1
      valu = CUR_SYMBOL_VALUE + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d269 1
a269 1
	pst = START_PSYMTAB (objfile, objfile->section_offsets,
d427 1
a427 1
	CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d438 1
a438 1
	CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d579 1
a579 1
	CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d605 1
a605 1
		!= ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT)))
d622 1
a622 1
	CUR_SYMBOL_VALUE += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d647 1
a647 1
		!= ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT)))
@


1.1.1.5
log
@import gdb-1999-09-08 snapshot
@
text
@d27 1
d269 1
a269 1
	pst = START_PSYMTAB (objfile,
@


1.1.1.6
log
@import gdb-1999-09-21
@
text
@d580 3
d591 1
a591 1
	      find_stab_function_addr (namestring, pst->filename, objfile);
a596 4
	/* Keep track of the start of the last function so we
	   can handle end of function symbols.  */
	last_function_start = CUR_SYMBOL_VALUE;

d623 3
a630 4
	if (CUR_SYMBOL_VALUE == ANOFFSET (objfile->section_offsets, 
	                                  SECT_OFF_TEXT))
	  CUR_SYMBOL_VALUE = 
	    find_stab_function_addr (namestring, pst->filename, objfile);
d633 2
a634 1
	    pst->textlow = CUR_SYMBOL_VALUE;
a638 5

	/* Keep track of the start of the last function so we
	   can handle end of function symbols.  */
	last_function_start = CUR_SYMBOL_VALUE;

@


