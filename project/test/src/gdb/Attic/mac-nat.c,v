head	1.10;
access;
symbols
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.8
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.6
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.4
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.9.0.2
	dberlin-typesystem-branchpoint:1.9
	gdb-post-ptid_t-2001-05-03:1.9
	gdb-pre-ptid_t-2001-05-03:1.8
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.10
date	2002.01.05.05.54.29;	author cagney;	state dead;
branches;
next	1.9;

1.9
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.14.19.23.02;	author jtc;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.15.16.55.14;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.06.08.21.10;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.01.12.28;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.46;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.07.56;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.10.05.23.08.29;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove obsolete MacOS support.
@
text
@/* Target-vector operations for controlling Mac applications, for GDB.
   Copyright 1995, 1996, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
   Written by Stan Shebs.  Contributed by Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without eve nthe implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* Note that because all the available Mac compilers are ANSI or very
   close, and this is a native-only file, the code may be purely ANSI.  */

#include "defs.h"
#include "frame.h"		/* required by inferior.h */
#include "inferior.h"
#include "target.h"
#include "gdb_wait.h"
#include "gdbcore.h"
#include "command.h"
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include "buildsym.h"
#include "gdb_string.h"
#include "gdbthread.h"
#include "gdbcmd.h"
#include "regcache.h"

#include <Processes.h>

/* We call the functions "child_..." rather than "mac_..." so no one
   is tempted to try to link this with other native-only code.  */

/* Forward declaration */

extern struct target_ops child_ops;

static void child_stop (void);

static void
child_fetch_inferior_registers (int r)
{
  if (r < 0)
    {
      for (r = 0; r < NUM_REGS; r++)
	child_fetch_inferior_registers (r);
    }
  else
    {
      supply_register (r, 0);
    }
}

static void
child_store_inferior_registers (int r)
{
  if (r < 0)
    {
      for (r = 0; r < NUM_REGS; r++)
	child_store_inferior_registers (r);
    }
  else
    {
      read_register_gen (r, 0);
    }
}

static ptid_t
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
}

/* Attach to process PID, then initialize for debugging it.  */

static void
child_attach (char *args, int from_tty)
{
  ProcessSerialNumber psn;
  ProcessInfoRec inforec;
  Str31 name;
  FSSpecPtr fsspec;
  OSType code;
  int pid;
  char *exec_file;

  if (!args)
    error_no_arg ("process-id to attach");

  pid = atoi (args);

  psn.highLongOfPSN = 0;
  psn.lowLongOfPSN = pid;

  inforec.processInfoLength = sizeof (ProcessInfoRec);
  inforec.processName = name;
  inforec.processAppSpec = fsspec;

  if (GetProcessInformation (&psn, &inforec) == noErr)
    {
      if (from_tty)
	{
	  exec_file = (char *) get_exec_file (0);

	  if (exec_file)
	    printf_unfiltered ("Attaching to program `%s', %s\n", exec_file,
			       target_pid_to_str (pid_to_ptid (pid)));
	  else
	    printf_unfiltered ("Attaching to %s\n",
	                       target_pid_to_str (pid_to_ptid (pid)));

	  gdb_flush (gdb_stdout);
	}
      /* Do we need to do anything special? */
      attach_flag = 1;
      inferior_ptid = pid_to_ptid (pid);
      push_target (&child_ops);
    }
}

static void
child_detach (char *args, int from_tty)
{
  char *exec_file;

  if (from_tty)
    {
      exec_file = get_exec_file (0);
      if (exec_file == 0)
	exec_file = "";
      printf_unfiltered ("Detaching from program: %s %s\n", exec_file,
			 target_pid_to_str (inferior_ptid));
      gdb_flush (gdb_stdout);
    }
  inferior_ptid = null_ptid;
  unpush_target (&child_ops);
}

/* Print status information about what we're accessing.  */

static void
child_files_info (struct target_ops *ignore)
{
  printf_unfiltered ("\tUsing the running image of %s %s.\n",
      attach_flag ? "attached" : "child", target_pid_to_str (inferior_ptid));
}

/* ARGSUSED */
static void
child_open (char *arg, int from_tty)
{
  error ("Use the \"run\" command to start a Mac application.");
}

/* Start an inferior Mac program and sets inferior_ptid to its pid.
   EXEC_FILE is the file to run.
   ALLARGS is a string containing the arguments to the program.
   ENV is the environment vector to pass.  Errors reported with error().  */

static void
child_create_inferior (char *exec_file, char *allargs, char **env)
{
  LaunchParamBlockRec launchparms;
  FSSpec fsspec;
  OSErr launch_err;

  if (!exec_file)
    {
      error ("No executable specified, use `target exec'.\n");
    }

  launchparms.launchBlockID = extendedBlock;
  launchparms.launchEPBLength = extendedBlockLen;
  launchparms.launchFileFlags = 0;
  launchparms.launchControlFlags = launchContinue | launchNoFileFlags;
  fsspec.vRefNum = 0;
  fsspec.parID = 0;
  strcpy (fsspec.name + 1, exec_file);
  fsspec.name[0] = strlen (exec_file);
  launchparms.launchAppSpec = &fsspec;
  launchparms.launchAppParameters = nil;

  launch_err = LaunchApplication (&launchparms);

  if (launch_err == 999 /*memFullErr */ )
    {
      error ("Not enough memory to launch %s\n", exec_file);
    }
  else if (launch_err != noErr)
    {
      error ("Error launching %s, code %d\n", exec_file, launch_err);
    }

  inferior_ptid = pid_to_ptid (launchparms.launchProcessSN.lowLongOfPSN);
  /* FIXME be sure that high long of PSN is 0 */

  push_target (&child_ops);
  init_wait_for_inferior ();
  clear_proceed_status ();

/*  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);  */
}

static void
child_mourn_inferior (void)
{
  unpush_target (&child_ops);
  generic_mourn_inferior ();
}

static void
child_stop (void)
{
}

int
child_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		   struct mem_attrib *attrib,
		   struct target_ops *target)
{
  int i;

  for (i = 0; i < len; ++i)
    {
      if (write)
	{
	  ((char *) memaddr)[i] = myaddr[i];
	}
      else
	{
	  myaddr[i] = ((char *) memaddr)[i];
	}
    }
  return len;
}

void
child_kill_inferior (void)
{
}

void
child_resume (ptid_t ptid, int step, enum target_signal signal)
{
}

static void
child_prepare_to_store (void)
{
  /* Do nothing, since we can store individual regs */
}

static int
child_can_run (void)
{
  return 1;
}

static void
child_close (void)
{
}

static void
info_proc (char *args, int from_tty)
{
  ProcessSerialNumber psn;
  ProcessInfoRec inforec;
  Str31 name;
  FSSpecPtr fsspec;
  OSType code;

  /* Eventually use args, but not right now. */

  psn.highLongOfPSN = 0;
  psn.lowLongOfPSN = kNoProcess;

  inforec.processInfoLength = sizeof (ProcessInfoRec);
  inforec.processName = name;
  inforec.processAppSpec = fsspec;

  printf_filtered ("Process Name                     Sgnt Type    PSN   Loc Size FreeMem Time\n");

  while (GetNextProcess (&psn) == noErr)
    {
      if (GetProcessInformation (&psn, &inforec) == noErr)
	{
	  name[name[0] + 1] = '\0';
	  printf_filtered ("%-32.32s", name + 1);
	  code = inforec.processSignature;
	  printf_filtered (" %c%c%c%c",
			   (code >> 24) & 0xff,
			   (code >> 16) & 0xff,
			   (code >> 8) & 0xff,
			   (code >> 0) & 0xff);
	  code = inforec.processType;
	  printf_filtered (" %c%c%c%c",
			   (code >> 24) & 0xff,
			   (code >> 16) & 0xff,
			   (code >> 8) & 0xff,
			   (code >> 0) & 0xff);
	  if (psn.highLongOfPSN == 0)
	    printf_filtered (" %9d", psn.lowLongOfPSN);
	  else
	    printf_filtered (" %9d,%9d\n",
			     psn.highLongOfPSN, psn.lowLongOfPSN);
	  printf_filtered (" 0x%x", inforec.processLocation);
	  printf_filtered (" %9d", inforec.processSize);
	  printf_filtered (" %9d", inforec.processFreeMem);
	  printf_filtered (" %9d", inforec.processActiveTime);
	  printf_filtered ("\n");
	}
    }
}

struct target_ops child_ops;

static void
init_child_ops (void)
{
  child_ops.to_shortname = "mac";
  child_ops.to_longname = "MacOS application";
  child_ops.to_doc = "MacOS application (started by the \"run\" command).";
  child_ops.to_open = child_open;
  child_ops.to_close = child_close;
  child_ops.to_attach = child_attach;
  child_ops.to_post_attach = NULL;
  child_ops.to_require_attach = NULL;	/* to_require_attach */
  child_ops.to_detach = child_detach;
  child_ops.to_require_detach = NULL;	/* to_require_detach */
  child_ops.to_resume = child_resume;
  child_ops.to_wait = child_wait;
  child_ops.to_post_wait = NULL;	/* to_post_wait */
  child_ops.to_fetch_registers = child_fetch_inferior_registers;
  child_ops.to_store_registers = child_store_inferior_registers;
  child_ops.to_prepare_to_store = child_prepare_to_store;
  child_ops.to_xfer_memory = child_xfer_memory;
  child_ops.to_files_info = child_files_info;
  child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  child_ops.to_terminal_init = 0;
  child_ops.to_terminal_inferior = 0;
  child_ops.to_terminal_ours_for_output = 0;
  child_ops.to_terminal_ours = 0;
  child_ops.to_terminal_info = 0;
  child_ops.to_kill = child_kill_inferior;
  child_ops.to_load = 0;
  child_ops.to_lookup_symbol = 0;
  child_ops.to_create_inferior = child_create_inferior;
  child_ops.to_post_startup_inferior = NULL;	/* to_post_startup_inferior */
  child_ops.to_acknowledge_created_inferior = NULL;	/* to_acknowledge_created_inferior */
  child_ops.to_clone_and_follow_inferior = NULL;	/* to_clone_and_follow_inferior */
  child_ops.to_post_follow_inferior_by_clone = NULL;	/* to_post_follow_inferior_by_clone */
  child_ops.to_insert_fork_catchpoint = NULL;
  child_ops.to_remove_fork_catchpoint = NULL;
  child_ops.to_insert_vfork_catchpoint = NULL;
  child_ops.to_remove_vfork_catchpoint = NULL;
  child_ops.to_has_forked = NULL;	/* to_has_forked */
  child_ops.to_has_vforked = NULL;	/* to_has_vforked */
  child_ops.to_can_follow_vfork_prior_to_exec = NULL;
  child_ops.to_post_follow_vfork = NULL;	/* to_post_follow_vfork */
  child_ops.to_insert_exec_catchpoint = NULL;
  child_ops.to_remove_exec_catchpoint = NULL;
  child_ops.to_has_execd = NULL;
  child_ops.to_reported_exec_events_per_exec_call = NULL;
  child_ops.to_has_exited = NULL;
  child_ops.to_mourn_inferior = child_mourn_inferior;
  child_ops.to_can_run = child_can_run;
  child_ops.to_notice_signals = 0;
  child_ops.to_thread_alive = 0;
  child_ops.to_stop = child_stop;
  child_ops.to_pid_to_exec_file = NULL;		/* to_pid_to_exec_file */
  child_ops.to_stratum = process_stratum;
  child_ops.DONT_USE = 0;
  child_ops.to_has_all_memory = 1;
  child_ops.to_has_memory = 1;
  child_ops.to_has_stack = 1;
  child_ops.to_has_registers = 1;
  child_ops.to_has_execution = 1;
  child_ops.to_sections = 0;
  child_ops.to_sections_end = 0;
  child_ops.to_magic = OPS_MAGIC;
};

void
_initialize_mac_nat (void)
{
  init_child_ops ();

  add_info ("proc", info_proc,
	    "Show information about processes.");
}
@


1.9
log
@Phase 1 of the ptid_t changes.
@
text
@@


1.8
log
@* target.h (target_ops): Removed to_core_file_to_sym_file vector
function.
* corelow.c (core_ops): Updated for above change.
* gnu-nat.c (core_ops): Likewise.
* inftarg.c (child_ops): Likewise.
* monitor.c (monitor_ops): Likewise.
* ppc-bdm.c (bdm_ppc_ops): Likewise.
* remote-adapt.c (adapt_ops): Likewise.
* remote-bug.c (bug_ops): Likewise.
* remote-e7000.c (e7000_ops): Likewise.
* remote-eb.c (eb_ops): Likewise.
* remote-es.c (es1800_ops, es1800_child_ops): Likewise.
* remote-mm.c (mm_ops): Likewise.
* remote-nindy.c (nindy_ops): Likewise.
* remote-nrom.c (nrom_ops): Likewise.
* remote-os9k.c (rombug_ops): Likewise.
* remote-rdp.c (remote_rdp_ops): Likewise.
* remote-sim.c (gdbsim_ops): Likewise.
* remote-st.c (st2000_ops): Likewise.
* v850ice.c (v850ice_ops): Likewise.
* target.c (cleanup_target): Likewise
(update_current_target): Likewise.
(setup_target_debug): Likewise
(debug_to_core_file_to_sym_file): Removed.

* corefile.c (core_file_command) [HPUXHPPA]: Removed code that
sets symbol file from information obtained from the core file.
* corelow.c (core_file_to_sym_file): Removed.
@
text
@d81 2
a82 2
static int
child_wait (int pid, struct target_waitstatus *ourstatus)
d119 1
a119 1
			       target_pid_to_str (pid));
d121 2
a122 1
	    printf_unfiltered ("Attaching to %s\n", target_pid_to_str (pid));
d128 1
a128 1
      inferior_pid = pid;
d144 1
a144 1
			 target_pid_to_str (inferior_pid));
d147 1
a147 1
  inferior_pid = 0;
d157 1
a157 1
      attach_flag ? "attached" : "child", target_pid_to_str (inferior_pid));
d167 1
a167 1
/* Start an inferior Mac program and sets inferior_pid to its pid.
d206 1
a206 1
  inferior_pid = launchparms.launchProcessSN.lowLongOfPSN;
d255 1
a255 1
child_resume (int pid, int step, enum target_signal signal)
@


1.7
log
@Add ``attrib'' parameter to *xfer_memory() functions.
@
text
@a383 1
  child_ops.to_core_file_to_sym_file = NULL;
@


1.6
log
@Update/correct copyright notices.
@
text
@d228 3
a230 2
child_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
		   int write, struct target_ops *target)
@


1.5
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1995, 2001 Free Software Foundation, Inc.
@


1.4
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright (C) 1995 Free Software Foundation, Inc.
d39 1
@


1.3
log
@PARAMS removal.
@
text
@d87 1
a87 3
child_attach (args, from_tty)
     char *args;
     int from_tty;
d131 1
a131 3
child_detach (args, from_tty)
     char *args;
     int from_tty;
d151 1
a151 2
child_files_info (ignore)
     struct target_ops *ignore;
d159 1
a159 3
child_open (arg, from_tty)
     char *arg;
     int from_tty;
d170 1
a170 4
child_create_inferior (exec_file, allargs, env)
     char *exec_file;
     char *allargs;
     char **env;
d214 1
a214 1
child_mourn_inferior ()
d221 1
a221 1
child_stop ()
d256 1
a256 1
child_prepare_to_store ()
d262 1
a262 1
child_can_run ()
d268 1
a268 1
child_close ()
d273 1
a273 3
info_proc (args, from_tty)
     char *args;
     int from_tty;
d395 1
a395 1
_initialize_mac_nat ()
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d49 1
a49 1
static void child_stop PARAMS ((void));
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without eve nthe implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d29 1
a29 1
#include "wait.h"
d107 1
a107 1
  inforec.processInfoLength = sizeof(ProcessInfoRec);
d197 2
a198 2
  strcpy(fsspec.name + 1, exec_file);
  fsspec.name[0] = strlen(exec_file);
d204 1
a204 1
  if (launch_err == 999 /*memFullErr*/)
d220 1
a220 1
/*  proceed ((CORE_ADDR) - 1, TARGET_SIGNAL_0, 0);  */
d237 1
a237 1
		 int write, struct target_ops *target)
d298 1
a298 1
  inforec.processInfoLength = sizeof(ProcessInfoRec);
d314 2
a315 2
			   (code >>  8) & 0xff,
			   (code >>  0) & 0xff);
d320 2
a321 2
			   (code >>  8) & 0xff,
			   (code >>  0) & 0xff);
d336 1
a336 1
struct target_ops child_ops ;
d338 2
a339 2
static void 
init_child_ops(void)
d341 6
a346 6
  child_ops.to_shortname =   "mac";		
  child_ops.to_longname =   "MacOS application";
  child_ops.to_doc    =  "MacOS application (started by the \"run\" command).";
  child_ops.to_open   =  child_open; 
  child_ops.to_close  =  child_close;
  child_ops.to_attach =  child_attach;
d348 21
a368 21
  child_ops.to_require_attach = NULL;                         /* to_require_attach */  
  child_ops.to_detach =  child_detach;
  child_ops.to_require_detach = NULL;                         /* to_require_detach */
  child_ops.to_resume =  child_resume;
  child_ops.to_wait   =  child_wait;	
  child_ops.to_post_wait = NULL;                         /* to_post_wait */
  child_ops.to_fetch_registers  =   child_fetch_inferior_registers;
  child_ops.to_store_registers  =   child_store_inferior_registers;
  child_ops.to_prepare_to_store =   child_prepare_to_store;
  child_ops.to_xfer_memory =   child_xfer_memory;		
  child_ops.to_files_info  =   child_files_info;		
  child_ops.to_insert_breakpoint =   memory_insert_breakpoint;	
  child_ops.to_remove_breakpoint =   memory_remove_breakpoint;	
  child_ops.to_terminal_init  =   0;				
  child_ops.to_terminal_inferior =   0;				
  child_ops.to_terminal_ours_for_output =  0;
  child_ops.to_terminal_ours  =   0;			
  child_ops.to_terminal_info  =   0;			
  child_ops.to_kill  =   child_kill_inferior;	
  child_ops.to_load  =   0;	
  child_ops.to_lookup_symbol   = 0;			
d370 4
a373 4
  child_ops.to_post_startup_inferior = NULL;                         /* to_post_startup_inferior */
  child_ops.to_acknowledge_created_inferior = NULL;                         /* to_acknowledge_created_inferior */
  child_ops.to_clone_and_follow_inferior = NULL;                         /* to_clone_and_follow_inferior */
  child_ops.to_post_follow_inferior_by_clone = NULL;                         /* to_post_follow_inferior_by_clone */
d378 2
a379 2
  child_ops.to_has_forked = NULL;                         /* to_has_forked */
  child_ops.to_has_vforked = NULL;                         /* to_has_vforked */
d381 1
a381 1
  child_ops.to_post_follow_vfork = NULL;                         /* to_post_follow_vfork */
d387 6
a392 6
  child_ops.to_mourn_inferior  = child_mourn_inferior;		
  child_ops.to_can_run         = child_can_run;
  child_ops.to_notice_signals =  0;      
  child_ops.to_thread_alive  =   0;       
  child_ops.to_stop  =   child_stop;      
  child_ops.to_pid_to_exec_file =  NULL;                         /* to_pid_to_exec_file */
d394 10
a403 10
  child_ops.to_stratum =   process_stratum;
  child_ops.DONT_USE =   0; 
  child_ops.to_has_all_memory = 1; 
  child_ops.to_has_memory     = 1; 
  child_ops.to_has_stack      = 1; 
  child_ops.to_has_registers  = 1; 
  child_ops.to_has_execution  = 1; 
  child_ops.to_sections       = 0; 
  child_ops.to_sections_end   = 0; 
  child_ops.to_magic =   OPS_MAGIC;
d409 1
a409 1
  init_child_ops() ;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without eve nthe implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d106 1
a106 1
  inforec.processInfoLength = sizeof (ProcessInfoRec);
d196 2
a197 2
  strcpy (fsspec.name + 1, exec_file);
  fsspec.name[0] = strlen (exec_file);
d203 1
a203 1
  if (launch_err == 999 /*memFullErr */ )
d236 1
a236 1
		   int write, struct target_ops *target)
d297 1
a297 1
  inforec.processInfoLength = sizeof (ProcessInfoRec);
d313 2
a314 2
			   (code >> 8) & 0xff,
			   (code >> 0) & 0xff);
d319 2
a320 2
			   (code >> 8) & 0xff,
			   (code >> 0) & 0xff);
d335 1
a335 1
struct target_ops child_ops;
d337 2
a338 2
static void
init_child_ops (void)
d340 6
a345 6
  child_ops.to_shortname = "mac";
  child_ops.to_longname = "MacOS application";
  child_ops.to_doc = "MacOS application (started by the \"run\" command).";
  child_ops.to_open = child_open;
  child_ops.to_close = child_close;
  child_ops.to_attach = child_attach;
d347 21
a367 21
  child_ops.to_require_attach = NULL;	/* to_require_attach */
  child_ops.to_detach = child_detach;
  child_ops.to_require_detach = NULL;	/* to_require_detach */
  child_ops.to_resume = child_resume;
  child_ops.to_wait = child_wait;
  child_ops.to_post_wait = NULL;	/* to_post_wait */
  child_ops.to_fetch_registers = child_fetch_inferior_registers;
  child_ops.to_store_registers = child_store_inferior_registers;
  child_ops.to_prepare_to_store = child_prepare_to_store;
  child_ops.to_xfer_memory = child_xfer_memory;
  child_ops.to_files_info = child_files_info;
  child_ops.to_insert_breakpoint = memory_insert_breakpoint;
  child_ops.to_remove_breakpoint = memory_remove_breakpoint;
  child_ops.to_terminal_init = 0;
  child_ops.to_terminal_inferior = 0;
  child_ops.to_terminal_ours_for_output = 0;
  child_ops.to_terminal_ours = 0;
  child_ops.to_terminal_info = 0;
  child_ops.to_kill = child_kill_inferior;
  child_ops.to_load = 0;
  child_ops.to_lookup_symbol = 0;
d369 4
a372 4
  child_ops.to_post_startup_inferior = NULL;	/* to_post_startup_inferior */
  child_ops.to_acknowledge_created_inferior = NULL;	/* to_acknowledge_created_inferior */
  child_ops.to_clone_and_follow_inferior = NULL;	/* to_clone_and_follow_inferior */
  child_ops.to_post_follow_inferior_by_clone = NULL;	/* to_post_follow_inferior_by_clone */
d377 2
a378 2
  child_ops.to_has_forked = NULL;	/* to_has_forked */
  child_ops.to_has_vforked = NULL;	/* to_has_vforked */
d380 1
a380 1
  child_ops.to_post_follow_vfork = NULL;	/* to_post_follow_vfork */
d386 6
a391 6
  child_ops.to_mourn_inferior = child_mourn_inferior;
  child_ops.to_can_run = child_can_run;
  child_ops.to_notice_signals = 0;
  child_ops.to_thread_alive = 0;
  child_ops.to_stop = child_stop;
  child_ops.to_pid_to_exec_file = NULL;		/* to_pid_to_exec_file */
d393 10
a402 10
  child_ops.to_stratum = process_stratum;
  child_ops.DONT_USE = 0;
  child_ops.to_has_all_memory = 1;
  child_ops.to_has_memory = 1;
  child_ops.to_has_stack = 1;
  child_ops.to_has_registers = 1;
  child_ops.to_has_execution = 1;
  child_ops.to_sections = 0;
  child_ops.to_sections_end = 0;
  child_ops.to_magic = OPS_MAGIC;
d408 1
a408 1
  init_child_ops ();
@


1.1.1.3
log
@import gdb-1999-10-04 snapshot
@
text
@d220 1
a220 1
/*  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);  */
@


