head	1.6;
access;
symbols
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.8
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.6
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.4
	gdb_5_1-2001-07-29-branchpoint:1.5
	dberlin-typesystem-branch:1.5.0.2
	dberlin-typesystem-branchpoint:1.5
	gdb-post-ptid_t-2001-05-03:1.5
	gdb-pre-ptid_t-2001-05-03:1.5
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb-post-params-removal-2000-06-04:1.1.1.2
	gdb-pre-params-removal-2000-06-04:1.1.1.2
	gdb-post-params-removal-2000-05-28:1.1.1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2001.12.01.22.02.02;	author cagney;	state dead;
branches;
next	1.5;

1.5
date	2001.04.02.20.57.26;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.06.08.21.11;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.08.25;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Zap all but ns32k-netbsd NS32k targets and hosts.
@
text
@/* OBSOLETE /* Low level interface to ns532 running mach 3.0. */
/* OBSOLETE   Copyright 1992, 1993, 1998, 2000, 2001 Free Software Foundation, Inc. */
/* OBSOLETE */
/* OBSOLETE   This file is part of GDB. */
/* OBSOLETE */
/* OBSOLETE   This program is free software; you can redistribute it and/or modify */
/* OBSOLETE   it under the terms of the GNU General Public License as published by */
/* OBSOLETE   the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE   (at your option) any later version. */
/* OBSOLETE */
/* OBSOLETE   This program is distributed in the hope that it will be useful, */
/* OBSOLETE   but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE   GNU General Public License for more details. */
/* OBSOLETE */
/* OBSOLETE   You should have received a copy of the GNU General Public License */
/* OBSOLETE   along with this program; if not, write to the Free Software */
/* OBSOLETE   Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE   Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE */
/* OBSOLETE#include "defs.h" */
/* OBSOLETE#include "inferior.h" */
/* OBSOLETE#include "regcache.h" */
/* OBSOLETE */
/* OBSOLETE#include <stdio.h> */
/* OBSOLETE */
/* OBSOLETE#include <mach.h> */
/* OBSOLETE#include <mach/message.h> */
/* OBSOLETE#include <mach/exception.h> */
/* OBSOLETE#include <mach_error.h> */
/* OBSOLETE */
/* OBSOLETE#define private static */
/* OBSOLETE */
/* OBSOLETE */
/* OBSOLETE/* Find offsets to thread states at compile time. */
/* OBSOLETE * If your compiler does not grok this, calculate offsets */
/* OBSOLETE * offsets yourself and use them (or get a compatible compiler :-) */
/* OBSOLETE */ */
/* OBSOLETE */
/* OBSOLETE#define  REG_N_OFFSET(reg) (int)(&((struct ns532_combined_state *)0)->ts.reg) */
/* OBSOLETE#define  REG_F_OFFSET(reg) (int)(&((struct ns532_combined_state *)0)->fs.reg) */
/* OBSOLETE */
/* OBSOLETE/* at reg_offset[i] is the offset to the ns532_combined_state */
/* OBSOLETE * location where the gdb registers[i] is stored. */
/* OBSOLETE */ */
/* OBSOLETE */
/* OBSOLETEstatic int reg_offset[] = */
/* OBSOLETE{ */
/* OBSOLETE  REG_N_OFFSET (r0), REG_N_OFFSET (r1), REG_N_OFFSET (r2), REG_N_OFFSET (r3), */
/* OBSOLETE  REG_N_OFFSET (r4), REG_N_OFFSET (r5), REG_N_OFFSET (r6), REG_N_OFFSET (r7), */
/* OBSOLETE  REG_F_OFFSET (l0a), REG_F_OFFSET (l0b), REG_F_OFFSET (l2a), REG_F_OFFSET (l2b), */
/* OBSOLETE  REG_F_OFFSET (l4a), REG_F_OFFSET (l4b), REG_F_OFFSET (l6a), REG_F_OFFSET (l6b), */
/* OBSOLETEREG_N_OFFSET (sp), REG_N_OFFSET (fp), REG_N_OFFSET (pc), REG_N_OFFSET (psr), */
/* OBSOLETE  REG_F_OFFSET (fsr), */
/* OBSOLETE  REG_F_OFFSET (l0a), REG_F_OFFSET (l1a), REG_F_OFFSET (l2a), REG_F_OFFSET (l3a), */
/* OBSOLETE  REG_F_OFFSET (l4a), REG_F_OFFSET (l5a), REG_F_OFFSET (l6a), REG_F_OFFSET (l7a), */
/* OBSOLETE}; */
/* OBSOLETE */
/* OBSOLETE#define REG_ADDRESS(state,regnum) ((char *)(state)+reg_offset[regnum]) */
/* OBSOLETE */
/* OBSOLETE/* Fetch COUNT contiguous registers from thread STATE starting from REGNUM */
/* OBSOLETE * Caller knows that the regs handled in one transaction are of same size. */
/* OBSOLETE */ */
/* OBSOLETE#define FETCH_REGS(state, regnum, count) \ */
/* OBSOLETE  memcpy (&registers[REGISTER_BYTE (regnum)], \ */
/* OBSOLETE	  (char *)state+reg_offset[ regnum ], \ */
/* OBSOLETE	  count*REGISTER_SIZE) */
/* OBSOLETE */
/* OBSOLETE/* Store COUNT contiguous registers to thread STATE starting from REGNUM */ */
/* OBSOLETE#define STORE_REGS(state, regnum, count) \ */
/* OBSOLETE  memcpy ((char *)state+reg_offset[ regnum ], \ */
/* OBSOLETE	  &registers[REGISTER_BYTE (regnum)], \ */
/* OBSOLETE	  count*REGISTER_SIZE) */
/* OBSOLETE */
/* OBSOLETE/* */
/* OBSOLETE * Fetch inferiors registers for gdb. */
/* OBSOLETE * REGNO specifies which (as gdb views it) register, -1 for all. */
/* OBSOLETE */ */
/* OBSOLETE */
/* OBSOLETEvoid */
/* OBSOLETEfetch_inferior_registers (int regno) */
/* OBSOLETE{ */
/* OBSOLETE  kern_return_t ret; */
/* OBSOLETE  thread_state_data_t state; */
/* OBSOLETE  unsigned int stateCnt = NS532_COMBINED_STATE_COUNT; */
/* OBSOLETE  int index; */
/* OBSOLETE */
/* OBSOLETE  if (!MACH_PORT_VALID (current_thread)) */
/* OBSOLETE    error ("fetch inferior registers: Invalid thread"); */
/* OBSOLETE */
/* OBSOLETE  if (must_suspend_thread) */
/* OBSOLETE    setup_thread (current_thread, 1); */
/* OBSOLETE */
/* OBSOLETE  ret = thread_get_state (current_thread, */
/* OBSOLETE			  NS532_COMBINED_STATE, */
/* OBSOLETE			  state, */
/* OBSOLETE			  &stateCnt); */
/* OBSOLETE */
/* OBSOLETE  if (ret != KERN_SUCCESS) */
/* OBSOLETE    warning ("fetch_inferior_registers: %s ", */
/* OBSOLETE	     mach_error_string (ret)); */
/* OBSOLETE#if 0 */
/* OBSOLETE  /* It may be more effective to store validate all of them, */
/* OBSOLETE   * since we fetched them all anyway */
/* OBSOLETE   */ */
/* OBSOLETE  else if (regno != -1) */
/* OBSOLETE    supply_register (regno, (char *) state + reg_offset[regno]); */
/* OBSOLETE#endif */
/* OBSOLETE  else */
/* OBSOLETE    { */
/* OBSOLETE      for (index = 0; index < NUM_REGS; index++) */
/* OBSOLETE	supply_register (index, (char *) state + reg_offset[index]); */
/* OBSOLETE    } */
/* OBSOLETE */
/* OBSOLETE  if (must_suspend_thread) */
/* OBSOLETE    setup_thread (current_thread, 0); */
/* OBSOLETE} */
/* OBSOLETE */
/* OBSOLETE/* Store our register values back into the inferior. */
/* OBSOLETE * If REGNO is -1, do this for all registers. */
/* OBSOLETE * Otherwise, REGNO specifies which register */
/* OBSOLETE * */
/* OBSOLETE * On mach3 all registers are always saved in one call. */
/* OBSOLETE */ */
/* OBSOLETEvoid */
/* OBSOLETEstore_inferior_registers (int regno) */
/* OBSOLETE{ */
/* OBSOLETE  kern_return_t ret; */
/* OBSOLETE  thread_state_data_t state; */
/* OBSOLETE  unsigned int stateCnt = NS532_COMBINED_STATE_COUNT; */
/* OBSOLETE  register int index; */
/* OBSOLETE */
/* OBSOLETE  if (!MACH_PORT_VALID (current_thread)) */
/* OBSOLETE    error ("store inferior registers: Invalid thread"); */
/* OBSOLETE */
/* OBSOLETE  if (must_suspend_thread) */
/* OBSOLETE    setup_thread (current_thread, 1); */
/* OBSOLETE */
/* OBSOLETE  /* Fetch the state of the current thread */ */
/* OBSOLETE  ret = thread_get_state (current_thread, */
/* OBSOLETE			  NS532_COMBINED_STATE, */
/* OBSOLETE			  state, */
/* OBSOLETE			  &stateCnt); */
/* OBSOLETE */
/* OBSOLETE  if (ret != KERN_SUCCESS) */
/* OBSOLETE    { */
/* OBSOLETE      warning ("store_inferior_registers (get): %s", */
/* OBSOLETE	       mach_error_string (ret)); */
/* OBSOLETE      if (must_suspend_thread) */
/* OBSOLETE	setup_thread (current_thread, 0); */
/* OBSOLETE      return; */
/* OBSOLETE    } */
/* OBSOLETE */
/* OBSOLETE  /* move gdb's registers to thread's state */
/* OBSOLETE */
/* OBSOLETE   * Since we save all registers anyway, save the ones */
/* OBSOLETE   * that gdb thinks are valid (e.g. ignore the regno */
/* OBSOLETE   * parameter) */
/* OBSOLETE   */ */
/* OBSOLETE#if 0 */
/* OBSOLETE  if (regno != -1) */
/* OBSOLETE    STORE_REGS (state, regno, 1); */
/* OBSOLETE  else */
/* OBSOLETE#endif */
/* OBSOLETE    { */
/* OBSOLETE      for (index = 0; index < NUM_REGS; index++) */
/* OBSOLETE	STORE_REGS (state, index, 1); */
/* OBSOLETE    } */
/* OBSOLETE */
/* OBSOLETE  /* Write gdb's current view of register to the thread */
/* OBSOLETE   */ */
/* OBSOLETE  ret = thread_set_state (current_thread, */
/* OBSOLETE			  NS532_COMBINED_STATE, */
/* OBSOLETE			  state, */
/* OBSOLETE			  NS532_COMBINED_STATE_COUNT); */
/* OBSOLETE */
/* OBSOLETE  if (ret != KERN_SUCCESS) */
/* OBSOLETE    warning ("store_inferior_registers (set): %s", */
/* OBSOLETE	     mach_error_string (ret)); */
/* OBSOLETE */
/* OBSOLETE  if (must_suspend_thread) */
/* OBSOLETE    setup_thread (current_thread, 0); */
/* OBSOLETE} */
@


1.5
log
@Obsolete ns32k-*-mach3*, ns32k-umax-*, ns32k-utek-sysv* and
ns32k-utek-*.
@
text
@@


1.4
log
@Update/correct copyright notices.
@
text
@d1 183
a183 183
/* Low level interface to ns532 running mach 3.0.
   Copyright 1992, 1993, 1998, 2000, 2001 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include "regcache.h"

#include <stdio.h>

#include <mach.h>
#include <mach/message.h>
#include <mach/exception.h>
#include <mach_error.h>

#define private static


/* Find offsets to thread states at compile time.
 * If your compiler does not grok this, calculate offsets
 * offsets yourself and use them (or get a compatible compiler :-)
 */

#define  REG_N_OFFSET(reg) (int)(&((struct ns532_combined_state *)0)->ts.reg)
#define  REG_F_OFFSET(reg) (int)(&((struct ns532_combined_state *)0)->fs.reg)

/* at reg_offset[i] is the offset to the ns532_combined_state
 * location where the gdb registers[i] is stored.
 */

static int reg_offset[] =
{
  REG_N_OFFSET (r0), REG_N_OFFSET (r1), REG_N_OFFSET (r2), REG_N_OFFSET (r3),
  REG_N_OFFSET (r4), REG_N_OFFSET (r5), REG_N_OFFSET (r6), REG_N_OFFSET (r7),
  REG_F_OFFSET (l0a), REG_F_OFFSET (l0b), REG_F_OFFSET (l2a), REG_F_OFFSET (l2b),
  REG_F_OFFSET (l4a), REG_F_OFFSET (l4b), REG_F_OFFSET (l6a), REG_F_OFFSET (l6b),
REG_N_OFFSET (sp), REG_N_OFFSET (fp), REG_N_OFFSET (pc), REG_N_OFFSET (psr),
  REG_F_OFFSET (fsr),
  REG_F_OFFSET (l0a), REG_F_OFFSET (l1a), REG_F_OFFSET (l2a), REG_F_OFFSET (l3a),
  REG_F_OFFSET (l4a), REG_F_OFFSET (l5a), REG_F_OFFSET (l6a), REG_F_OFFSET (l7a),
};

#define REG_ADDRESS(state,regnum) ((char *)(state)+reg_offset[regnum])

/* Fetch COUNT contiguous registers from thread STATE starting from REGNUM
 * Caller knows that the regs handled in one transaction are of same size.
 */
#define FETCH_REGS(state, regnum, count) \
  memcpy (&registers[REGISTER_BYTE (regnum)], \
	  (char *)state+reg_offset[ regnum ], \
	  count*REGISTER_SIZE)

/* Store COUNT contiguous registers to thread STATE starting from REGNUM */
#define STORE_REGS(state, regnum, count) \
  memcpy ((char *)state+reg_offset[ regnum ], \
	  &registers[REGISTER_BYTE (regnum)], \
	  count*REGISTER_SIZE)

/*
 * Fetch inferiors registers for gdb.
 * REGNO specifies which (as gdb views it) register, -1 for all.
 */

void
fetch_inferior_registers (int regno)
{
  kern_return_t ret;
  thread_state_data_t state;
  unsigned int stateCnt = NS532_COMBINED_STATE_COUNT;
  int index;

  if (!MACH_PORT_VALID (current_thread))
    error ("fetch inferior registers: Invalid thread");

  if (must_suspend_thread)
    setup_thread (current_thread, 1);

  ret = thread_get_state (current_thread,
			  NS532_COMBINED_STATE,
			  state,
			  &stateCnt);

  if (ret != KERN_SUCCESS)
    warning ("fetch_inferior_registers: %s ",
	     mach_error_string (ret));
#if 0
  /* It may be more effective to store validate all of them,
   * since we fetched them all anyway
   */
  else if (regno != -1)
    supply_register (regno, (char *) state + reg_offset[regno]);
#endif
  else
    {
      for (index = 0; index < NUM_REGS; index++)
	supply_register (index, (char *) state + reg_offset[index]);
    }

  if (must_suspend_thread)
    setup_thread (current_thread, 0);
}

/* Store our register values back into the inferior.
 * If REGNO is -1, do this for all registers.
 * Otherwise, REGNO specifies which register
 *
 * On mach3 all registers are always saved in one call.
 */
void
store_inferior_registers (int regno)
{
  kern_return_t ret;
  thread_state_data_t state;
  unsigned int stateCnt = NS532_COMBINED_STATE_COUNT;
  register int index;

  if (!MACH_PORT_VALID (current_thread))
    error ("store inferior registers: Invalid thread");

  if (must_suspend_thread)
    setup_thread (current_thread, 1);

  /* Fetch the state of the current thread */
  ret = thread_get_state (current_thread,
			  NS532_COMBINED_STATE,
			  state,
			  &stateCnt);

  if (ret != KERN_SUCCESS)
    {
      warning ("store_inferior_registers (get): %s",
	       mach_error_string (ret));
      if (must_suspend_thread)
	setup_thread (current_thread, 0);
      return;
    }

  /* move gdb's registers to thread's state

   * Since we save all registers anyway, save the ones
   * that gdb thinks are valid (e.g. ignore the regno
   * parameter)
   */
#if 0
  if (regno != -1)
    STORE_REGS (state, regno, 1);
  else
#endif
    {
      for (index = 0; index < NUM_REGS; index++)
	STORE_REGS (state, index, 1);
    }

  /* Write gdb's current view of register to the thread
   */
  ret = thread_set_state (current_thread,
			  NS532_COMBINED_STATE,
			  state,
			  NS532_COMBINED_STATE_COUNT);

  if (ret != KERN_SUCCESS)
    warning ("store_inferior_registers (set): %s",
	     mach_error_string (ret));

  if (must_suspend_thread)
    setup_thread (current_thread, 0);
}
@


1.3
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 1
a2 1
   Copyright 1992, 2001 Free Software Foundation, Inc.
@


1.2
log
@Protoization.
@
text
@d2 1
a2 1
   Copyright (C) 1992 Free Software Foundation, Inc.
d23 1
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 1
a33 1

d46 1
a46 1
static int reg_offset[] = 
d48 8
a55 8
  REG_N_OFFSET(r0),  REG_N_OFFSET(r1), REG_N_OFFSET(r2), REG_N_OFFSET(r3),
  REG_N_OFFSET(r4),  REG_N_OFFSET(r5), REG_N_OFFSET(r6), REG_N_OFFSET(r7),
  REG_F_OFFSET(l0a), REG_F_OFFSET(l0b),REG_F_OFFSET(l2a),REG_F_OFFSET(l2b),
  REG_F_OFFSET(l4a), REG_F_OFFSET(l4b),REG_F_OFFSET(l6a),REG_F_OFFSET(l6b),
  REG_N_OFFSET(sp),  REG_N_OFFSET(fp), REG_N_OFFSET(pc), REG_N_OFFSET(psr),
  REG_F_OFFSET(fsr),
  REG_F_OFFSET(l0a), REG_F_OFFSET(l1a),REG_F_OFFSET(l2a),REG_F_OFFSET(l3a),
  REG_F_OFFSET(l4a), REG_F_OFFSET(l5a),REG_F_OFFSET(l6a),REG_F_OFFSET(l7a),
d80 1
a80 2
fetch_inferior_registers (regno)
     int regno;
d86 2
a87 2
  
  if (! MACH_PORT_VALID (current_thread))
d106 1
a106 1
    supply_register (regno, (char *)state+reg_offset[regno]);
d110 2
a111 2
      for (index = 0; index < NUM_REGS; index++) 
	supply_register (index, (char *)state+reg_offset[index]);
d125 1
a125 2
store_inferior_registers (regno)
     int regno;
d132 1
a132 1
  if (! MACH_PORT_VALID (current_thread))
d144 1
a144 1
   if (ret != KERN_SUCCESS) 
d154 1
a154 1
   *
d165 1
a165 1
      for (index = 0; index < NUM_REGS; index++) 
d168 1
a168 1
  
d175 1
a175 1
  
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d31 1
a32 1

d45 1
a45 1
static int reg_offset[] =
d47 8
a54 8
  REG_N_OFFSET (r0), REG_N_OFFSET (r1), REG_N_OFFSET (r2), REG_N_OFFSET (r3),
  REG_N_OFFSET (r4), REG_N_OFFSET (r5), REG_N_OFFSET (r6), REG_N_OFFSET (r7),
  REG_F_OFFSET (l0a), REG_F_OFFSET (l0b), REG_F_OFFSET (l2a), REG_F_OFFSET (l2b),
  REG_F_OFFSET (l4a), REG_F_OFFSET (l4b), REG_F_OFFSET (l6a), REG_F_OFFSET (l6b),
REG_N_OFFSET (sp), REG_N_OFFSET (fp), REG_N_OFFSET (pc), REG_N_OFFSET (psr),
  REG_F_OFFSET (fsr),
  REG_F_OFFSET (l0a), REG_F_OFFSET (l1a), REG_F_OFFSET (l2a), REG_F_OFFSET (l3a),
  REG_F_OFFSET (l4a), REG_F_OFFSET (l5a), REG_F_OFFSET (l6a), REG_F_OFFSET (l7a),
d86 2
a87 2

  if (!MACH_PORT_VALID (current_thread))
d106 1
a106 1
    supply_register (regno, (char *) state + reg_offset[regno]);
d110 2
a111 2
      for (index = 0; index < NUM_REGS; index++)
	supply_register (index, (char *) state + reg_offset[index]);
d133 1
a133 1
  if (!MACH_PORT_VALID (current_thread))
d145 1
a145 1
  if (ret != KERN_SUCCESS)
d155 1
a155 1

d166 1
a166 1
      for (index = 0; index < NUM_REGS; index++)
d169 1
a169 1

d176 1
a176 1

@

