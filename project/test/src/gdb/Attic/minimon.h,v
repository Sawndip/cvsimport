head	1.3;
access;
symbols
	jimb-gdb_6_2-e500-branch:1.2.0.84
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.80
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.78
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.76
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.74
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.72
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.70
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.68
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.66
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.64
	cagney_x86i386-20030821-branch:1.2.0.62
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.60
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.58
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.56
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.54
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.52
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.50
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.48
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.46
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.44
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.42
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.40
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.38
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.36
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.34
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.32
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030203-mergepoint:1.2
	interps-20030202-branch:1.2.0.30
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.28
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.26
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.24
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.22
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.20
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.18
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.16
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.14
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.2.0.12
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.10
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.8
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.6
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.4
	gdb_5_1-2001-07-29-branchpoint:1.2
	dberlin-typesystem-branch:1.2.0.2
	dberlin-typesystem-branchpoint:1.2
	gdb-post-ptid_t-2001-05-03:1.2
	gdb-pre-ptid_t-2001-05-03:1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb-post-protoization-2000-07-29:1.1.1.2
	gdb-pre-protoization-2000-07-29:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb-post-params-removal-2000-06-04:1.1.1.2
	gdb-pre-params-removal-2000-06-04:1.1.1.2
	gdb-post-params-removal-2000-05-28:1.1.1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2004.08.01.14.37.01;	author cagney;	state dead;
branches;
next	1.2;

1.2
date	2001.03.06.08.21.10;	author kevinb;	state Exp;
branches
	1.2.72.1;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.08.04;	author jsm;	state Exp;
branches;
next	;

1.2.72.1
date	2004.09.16.17.01.13;	author drow;	state dead;
branches;
next	;


desc
@@


1.3
log
@2004-08-01  Andrew Cagney  <cagney@@gnu.org>

	* config/ia64/tm-linux.h (IA64_GNULINUX_TARGET): Delete.
	* config/alpha/nm-osf2.h (PROCFS_SIGPEND_OFFSET): Delete.
	* config/nm-gnu.h (NO_CORE_OPS): Delete.
	* config/pa/nm-hppah.h (MAY_SWITCH_FROM_INFERIOR_PID): Delete.
	* config/i386/nm-i386v4.h (LOSING_POLL): Delete.
	* config/alpha/nm-osf2.h (LOSING_POLL): Delete.
	* config/tm-nto.h (RAW_SIGNAL_LO, RAW_SIGNAL_HI): Delete.
	* config/m68k/tm-vx68.h (VX_SIZE_FPREGS): Delete.
	* config/nm-linux.h (USE_THREAD_STEP_NEEDED): Delete.
	* config/pa/nm-hppah.h (USE_THREAD_STEP_NEEDED): Delete.
	* config/tm-nto.h (TARGET_SIGNAL_RAW_TABLE) Delete.
	(TARGET_SIGNAL_RAW_VALUES): Delete.
	* config/pa/nm-hppah.h (TARGET_RANGE_PROFITABLE_FOR_HW_WATCHPOINT):
	Delete.
	* config/frv/tm-frv.h (TARGET_HW_BREAK_LIMIT)
	(TARGET_HW_WATCH_LIMIT): Delete.
	* Makefile.in (minimon_h, HFILES_NO_SRCDIR): Remove minimon.h.
	* minimon.h: Delete file.
@
text
@/* Definitions and macros for support of AMD's remote debugger, MiniMON.
   Copyright 1990, 1991 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/*
 * Some basic types.  FIXME, this should be done by declaring bitfield
 * sizes in the structs.  We can't portably depend on a "long int" being
 * 32 bits, etc.
 */
typedef long int INT32;		/* 32 bit integer */
typedef unsigned long int UINT32;	/* 32 bit integer (unsigned) */
typedef unsigned long int ADDR32;	/* 32 bit address */
typedef unsigned long int INST32;	/* 32 bit instruction */
typedef long int BOOLEAN;	/* Boolean value (32 bit) */
typedef unsigned char BYTE;	/* byte (8 bit) */
typedef short int INT16;	/* 16 bit integer */
typedef unsigned short int UINT16;	/* 16 bit integer (unsigned) */

/****************************************************************************/
/************************* Message Information ******************************/
/****************************************************************************/

/*
 * Error codes 
 */

/* General errors */
#define EMUSAGE     1		/* Bad args / flags               */
#define EMFAIL      2		/* Unrecoverable error            */
#define EMBADADDR   3		/* Illegal address                */
#define EMBADREG    4		/* Illegal register               */
#define EMSYNTAX    5		/* Illegal command syntax         */
#define EMACCESS    6		/* Could not access memory        */
#define EMALLOC     7		/* Could not allocate memory      */
#define EMTARGET    8		/* Unknown target type            */
#define EMHINIT     9		/* Could not initialize host      */
#define EMCOMM     10		/* Could not open communication channel */

/* Message errors */
#define EMBADMSG   11		/* Unknown message type           */
#define EMMSG2BIG  12		/* Message to large for buffer    */
#define EMNOSEND   13		/* Could not send message         */
#define EMNORECV   14		/* Could not receive message      */

#define EMRESET    15		/* Could not RESET target         */
#define EMCONFIG   16		/* Could not get target CONFIG    */
#define EMSTATUS   17		/* Could not get target STATUS    */
#define EMREAD     18		/* Could not READ target memory   */
#define EMWRITE    19		/* Could not WRITE target memory  */
#define EMBKPTSET  20		/* Could not set breakpoint       */
#define EMBKPTRM   21		/* Could not remove breakpoint    */
#define EMBKPTSTAT 22		/* Could not get breakpoint status */
#define EMBKPTNONE 23		/* All breakpoints in use         */
#define EMBKPTUSED 24		/* Breakpoints already in use     */
#define EMCOPY     25		/* Could not COPY target memory   */
#define EMFILL     26		/* Could not FILL target memory   */
#define EMINIT     27		/* Could not initialize target memory */
#define EMGO       28		/* Could not start execution      */
#define EMSTEP     29		/* Could not single step          */
#define EMBREAK    30		/* Could not BREAK                */
#define EMHIF      31		/* Could not perform HIF service  */
#define EMCHANNEL0 32		/* Could not read CHANNEL0        */
#define EMCHANNEL1 33		/* Could not write CHANNEL1       */

/* COFF file loader errors */
#define EMOPEN     34		/* Could not open COFF file       */
#define EMHDR      35		/* Could not read COFF header     */
#define EMMAGIC    36		/* Bad magic number               */
#define EMAOUT     37		/* Could not read COFF a.out header */
#define EMSCNHDR   38		/* Could not read COFF section header */
#define EMSCN      39		/* Could not read COFF section    */
#define EMCLOSE    40		/* Could not close COFF file      */

/* Log file errors */
#define EMLOGOPEN  41		/* Could not open log file        */
#define EMLOGREAD  42		/* Could not read log file        */
#define EMLOGWRITE 43		/* Could not write to log file    */
#define EMLOGCLOSE 44		/* Could not close log file       */

/* Command file errors */
#define EMCMDOPEN  45		/* Could not open command file    */
#define EMCMDREAD  46		/* Could not read command file    */
#define EMCMDWRITE 47		/* Could not write to command file */
#define EMCMDCLOSE 48		/* Could not close comand file    */

#define EMTIMEOUT  49		/* Host timed out waiting for a message */
#define EMCOMMTYPE 50		/* A '-t' flag must be specified  */
#define EMCOMMERR  51		/* Communication error            */
#define EMBAUD     52		/* Invalid baud rate specified    */
/*
 * Memory Spaces
 */
#define LOCAL_REG    0		/* Local processor register     */
#define GLOBAL_REG   1		/* Global processor register    */
#define SPECIAL_REG  2		/* Special processor register   */
#define TLB_REG      3		/* Translation Lookaside Buffer */
#define COPROC_REG   4		/* Coprocessor register         */
#define I_MEM        5		/* Instruction Memory           */
#define D_MEM        6		/* Data Memory                  */
#define I_ROM        7		/* Instruction ROM              */
#define D_ROM        8		/* Data ROM                     */
#define I_O          9		/* Input/Output                 */
#define I_CACHE     10		/* Instruction Cache            */
#define D_CACHE     11		/* Data Cache                   */

/* To supress warnings for zero length array definitions */
#define DUMMY 1

/*
   ** Host to target definitions
 */

#define RESET          0
#define CONFIG_REQ     1
#define STATUS_REQ     2
#define READ_REQ       3
#define WRITE_REQ      4
#define BKPT_SET       5
#define BKPT_RM        6
#define BKPT_STAT      7
#define COPY           8
#define FILL           9
#define INIT          10
#define GO            11
#define STEP          12
#define BREAK         13

#define HIF_CALL_RTN  64
#define CHANNEL0      65
#define CHANNEL1_ACK  66


/*
   ** Target to host definitions
 */

#define RESET_ACK     32
#define CONFIG        33
#define STATUS        34
#define READ_ACK      35
#define WRITE_ACK     36
#define BKPT_SET_ACK  37
#define BKPT_RM_ACK   38
#define BKPT_STAT_ACK 39
#define COPY_ACK      40
#define FILL_ACK      41
#define INIT_ACK      42
#define HALT          43

#define ERROR         63

#define HIF_CALL      96
#define CHANNEL0_ACK  97
#define CHANNEL1      98


/* A "generic" message */
struct generic_msg_t
  {
    INT32 code;			/* generic */
    INT32 length;
    BYTE byte[DUMMY];
  };


/* A "generic" message (with an INT32 array) */
struct generic_int32_msg_t
  {
    INT32 code;			/* generic */
    INT32 length;
    INT32 int32[DUMMY];
  };


/*
   ** Host to target messages
 */

struct reset_msg_t
  {
    INT32 code;			/* 0 */
    INT32 length;
  };


struct config_req_msg_t
  {
    INT32 code;			/* 1 */
    INT32 length;
  };


struct status_req_msg_t
  {
    INT32 code;			/* 2 */
    INT32 length;
  };


struct read_req_msg_t
  {
    INT32 code;			/* 3 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 byte_count;
  };


struct write_req_msg_t
  {
    INT32 code;			/* 4 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 byte_count;
    BYTE data[DUMMY];
  };


struct write_r_msg_t
  {
    INT32 code;			/* 4 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 byte_count;
    INT32 data[DUMMY];
  };


struct bkpt_set_msg_t
  {
    INT32 code;			/* 5 */
    INT32 length;
    INT32 memory_space;
    ADDR32 bkpt_addr;
    INT32 pass_count;
    INT32 bkpt_type;
  };


struct bkpt_rm_msg_t
  {
    INT32 code;			/* 6 */
    INT32 length;
    INT32 memory_space;
    ADDR32 bkpt_addr;
  };


struct bkpt_stat_msg_t
  {
    INT32 code;			/* 7 */
    INT32 length;
    INT32 memory_space;
    ADDR32 bkpt_addr;
  };


struct copy_msg_t
  {
    INT32 code;			/* 8 */
    INT32 length;
    INT32 source_space;
    ADDR32 source_addr;
    INT32 dest_space;
    ADDR32 dest_addr;
    INT32 byte_count;
  };


struct fill_msg_t
  {
    INT32 code;			/* 9 */
    INT32 length;
    INT32 memory_space;
    ADDR32 start_addr;
    INT32 fill_count;
    INT32 byte_count;
    BYTE fill_data[DUMMY];
  };


struct init_msg_t
  {
    INT32 code;			/* 10 */
    INT32 length;
    ADDR32 text_start;
    ADDR32 text_end;
    ADDR32 data_start;
    ADDR32 data_end;
    ADDR32 entry_point;
    INT32 mem_stack_size;
    INT32 reg_stack_size;
    ADDR32 arg_start;
    INT32 os_control;
  };


struct go_msg_t
  {
    INT32 code;			/* 11 */
    INT32 length;
  };


struct step_msg_t
  {
    INT32 code;			/* 12 */
    INT32 length;
    INT32 count;
  };


struct break_msg_t
  {
    INT32 code;			/* 13 */
    INT32 length;
  };


struct hif_call_rtn_msg_t
  {
    INT32 code;			/* 64 */
    INT32 length;
    INT32 service_number;
    INT32 gr121;
    INT32 gr96;
    INT32 gr97;
  };


struct channel0_msg_t
  {
    INT32 code;			/* 65 */
    INT32 length;
    BYTE data;
  };


struct channel1_ack_msg_t
  {
    INT32 code;			/* 66 */
    INT32 length;
  };


/*
   ** Target to host messages
 */


struct reset_ack_msg_t
  {
    INT32 code;			/* 32 */
    INT32 length;
  };


struct config_msg_t
  {
    INT32 code;			/* 33 */
    INT32 length;
    INT32 processor_id;
    INT32 version;
    ADDR32 I_mem_start;
    INT32 I_mem_size;
    ADDR32 D_mem_start;
    INT32 D_mem_size;
    ADDR32 ROM_start;
    INT32 ROM_size;
    INT32 max_msg_size;
    INT32 max_bkpts;
    INT32 coprocessor;
    INT32 reserved;
  };


struct status_msg_t
  {
    INT32 code;			/* 34 */
    INT32 length;
    INT32 msgs_sent;
    INT32 msgs_received;
    INT32 errors;
    INT32 bkpts_hit;
    INT32 bkpts_free;
    INT32 traps;
    INT32 fills;
    INT32 spills;
    INT32 cycles;
    INT32 reserved;
  };


struct read_ack_msg_t
  {
    INT32 code;			/* 35 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 byte_count;
    BYTE data[DUMMY];
  };

struct read_r_ack_msg_t
  {
    INT32 code;			/* 35 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 byte_count;
    INT32 data[DUMMY];
  };


struct write_ack_msg_t
  {
    INT32 code;			/* 36 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 byte_count;
  };


struct bkpt_set_ack_msg_t
  {
    INT32 code;			/* 37 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 pass_count;
    INT32 bkpt_type;
  };


struct bkpt_rm_ack_msg_t
  {
    INT32 code;			/* 38 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
  };


struct bkpt_stat_ack_msg_t
  {
    INT32 code;			/* 39 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 pass_count;
    INT32 bkpt_type;
  };


struct copy_ack_msg_t
  {
    INT32 code;			/* 40 */
    INT32 length;
    INT32 source_space;
    ADDR32 source_addr;
    INT32 dest_space;
    ADDR32 dest_addr;
    INT32 byte_count;
  };


struct fill_ack_msg_t
  {
    INT32 code;			/* 41 */
    INT32 length;
    INT32 memory_space;
    ADDR32 start_addr;
    INT32 fill_count;
    INT32 byte_count;
  };


struct init_ack_msg_t
  {
    INT32 code;			/* 42 */
    INT32 length;
  };


struct halt_msg_t
  {
    INT32 code;			/* 43 */
    INT32 length;
    INT32 memory_space;
    ADDR32 pc0;
    ADDR32 pc1;
    INT32 trap_number;
  };


struct error_msg_t
  {
    INT32 code;			/* 63 */
    INT32 length;
    INT32 error_code;
    INT32 memory_space;
    ADDR32 address;
  };


struct hif_call_msg_t
  {
    INT32 code;			/* 96 */
    INT32 length;
    INT32 service_number;
    INT32 lr2;
    INT32 lr3;
    INT32 lr4;
  };


struct channel0_ack_msg_t
  {
    INT32 code;			/* 97 */
    INT32 length;
  };


struct channel1_msg_t
  {
    INT32 code;			/* 98 */
    INT32 length;
    BYTE data[DUMMY];
  };



/*
   ** Union all of the message types together
 */

union msg_t
  {
    struct generic_msg_t generic_msg;
    struct generic_int32_msg_t generic_int32_msg;

    struct reset_msg_t reset_msg;
    struct config_req_msg_t config_req_msg;
    struct status_req_msg_t status_req_msg;
    struct read_req_msg_t read_req_msg;
    struct write_req_msg_t write_req_msg;
    struct write_r_msg_t write_r_msg;
    struct bkpt_set_msg_t bkpt_set_msg;
    struct bkpt_rm_msg_t bkpt_rm_msg;
    struct bkpt_stat_msg_t bkpt_stat_msg;
    struct copy_msg_t copy_msg;
    struct fill_msg_t fill_msg;
    struct init_msg_t init_msg;
    struct go_msg_t go_msg;
    struct step_msg_t step_msg;
    struct break_msg_t break_msg;

    struct hif_call_rtn_msg_t hif_call_rtn_msg;
    struct channel0_msg_t channel0_msg;
    struct channel1_ack_msg_t channel1_ack_msg;

    struct reset_ack_msg_t reset_ack_msg;
    struct config_msg_t config_msg;
    struct status_msg_t status_msg;
    struct read_ack_msg_t read_ack_msg;
    struct read_r_ack_msg_t read_r_ack_msg;
    struct write_ack_msg_t write_ack_msg;
    struct bkpt_set_ack_msg_t bkpt_set_ack_msg;
    struct bkpt_rm_ack_msg_t bkpt_rm_ack_msg;
    struct bkpt_stat_ack_msg_t bkpt_stat_ack_msg;
    struct copy_ack_msg_t copy_ack_msg;
    struct fill_ack_msg_t fill_ack_msg;
    struct init_ack_msg_t init_ack_msg;
    struct halt_msg_t halt_msg;

    struct error_msg_t error_msg;

    struct hif_call_msg_t hif_call_msg;
    struct channel0_ack_msg_t channel0_ack_msg;
    struct channel1_msg_t channel1_msg;
  };
@


1.2
log
@Update/correct copyright notices.
@
text
@@


1.2.72.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990, 1991 Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d26 8
a33 8
typedef long int INT32;            /* 32 bit integer */
typedef unsigned long int UINT32;  /* 32 bit integer (unsigned) */
typedef unsigned long int ADDR32;  /* 32 bit address */
typedef unsigned long int INST32;  /* 32 bit instruction */
typedef long int BOOLEAN;          /* Boolean value (32 bit) */
typedef unsigned char BYTE;        /* byte (8 bit) */
typedef short int INT16;           /* 16 bit integer */
typedef unsigned short int UINT16; /* 16 bit integer (unsigned) */
d44 10
a53 10
#define EMUSAGE     1  /* Bad args / flags               */
#define EMFAIL      2  /* Unrecoverable error            */
#define EMBADADDR   3  /* Illegal address                */
#define EMBADREG    4  /* Illegal register               */
#define EMSYNTAX    5  /* Illegal command syntax         */
#define EMACCESS    6  /* Could not access memory        */
#define EMALLOC     7  /* Could not allocate memory      */
#define EMTARGET    8  /* Unknown target type            */
#define EMHINIT     9  /* Could not initialize host      */
#define EMCOMM     10  /* Could not open communication channel */
d56 24
a79 24
#define EMBADMSG   11  /* Unknown message type           */
#define EMMSG2BIG  12  /* Message to large for buffer    */
#define EMNOSEND   13  /* Could not send message         */
#define EMNORECV   14  /* Could not receive message      */

#define EMRESET    15  /* Could not RESET target         */
#define EMCONFIG   16  /* Could not get target CONFIG    */
#define EMSTATUS   17  /* Could not get target STATUS    */
#define EMREAD     18  /* Could not READ target memory   */
#define EMWRITE    19  /* Could not WRITE target memory  */
#define EMBKPTSET  20  /* Could not set breakpoint       */
#define EMBKPTRM   21  /* Could not remove breakpoint    */
#define EMBKPTSTAT 22  /* Could not get breakpoint status */
#define EMBKPTNONE 23  /* All breakpoints in use         */
#define EMBKPTUSED 24  /* Breakpoints already in use     */
#define EMCOPY     25  /* Could not COPY target memory   */
#define EMFILL     26  /* Could not FILL target memory   */
#define EMINIT     27  /* Could not initialize target memory */
#define EMGO       28  /* Could not start execution      */
#define EMSTEP     29  /* Could not single step          */
#define EMBREAK    30  /* Could not BREAK                */
#define EMHIF      31  /* Could not perform HIF service  */
#define EMCHANNEL0 32  /* Could not read CHANNEL0        */
#define EMCHANNEL1 33  /* Could not write CHANNEL1       */
d82 7
a88 7
#define EMOPEN     34  /* Could not open COFF file       */
#define EMHDR      35  /* Could not read COFF header     */
#define EMMAGIC    36  /* Bad magic number               */
#define EMAOUT     37  /* Could not read COFF a.out header */
#define EMSCNHDR   38  /* Could not read COFF section header */
#define EMSCN      39  /* Could not read COFF section    */
#define EMCLOSE    40  /* Could not close COFF file      */
d91 4
a94 4
#define EMLOGOPEN  41  /* Could not open log file        */
#define EMLOGREAD  42  /* Could not read log file        */
#define EMLOGWRITE 43  /* Could not write to log file    */
#define EMLOGCLOSE 44  /* Could not close log file       */
d97 9
a105 9
#define EMCMDOPEN  45  /* Could not open command file    */
#define EMCMDREAD  46  /* Could not read command file    */
#define EMCMDWRITE 47  /* Could not write to command file */
#define EMCMDCLOSE 48  /* Could not close comand file    */

#define EMTIMEOUT  49  /* Host timed out waiting for a message */
#define EMCOMMTYPE 50  /* A '-t' flag must be specified  */
#define EMCOMMERR  51  /* Communication error            */
#define EMBAUD     52  /* Invalid baud rate specified    */
d109 12
a120 12
#define LOCAL_REG    0  /* Local processor register     */
#define GLOBAL_REG   1  /* Global processor register    */
#define SPECIAL_REG  2  /* Special processor register   */
#define TLB_REG      3  /* Translation Lookaside Buffer */
#define COPROC_REG   4  /* Coprocessor register         */
#define I_MEM        5  /* Instruction Memory           */
#define D_MEM        6  /* Data Memory                  */
#define I_ROM        7  /* Instruction ROM              */
#define D_ROM        8  /* Data ROM                     */
#define I_O          9  /* Input/Output                 */
#define I_CACHE     10  /* Instruction Cache            */
#define D_CACHE     11  /* Data Cache                   */
d126 2
a127 2
** Host to target definitions
*/
d150 2
a151 2
** Target to host definitions
*/
d174 6
a179 5
struct generic_msg_t {
          INT32    code;  /* generic */
          INT32    length;
          BYTE     byte[DUMMY];
};
d183 6
a188 5
struct generic_int32_msg_t {
          INT32    code;  /* generic */
          INT32    length;
          INT32    int32[DUMMY];
};
d192 2
a193 2
** Host to target messages
*/
d195 168
a362 150
struct reset_msg_t {
          INT32    code;  /* 0 */
          INT32    length;
};


struct config_req_msg_t {
          INT32    code;  /* 1 */
          INT32    length;
};


struct status_req_msg_t {
          INT32    code;  /* 2 */
          INT32    length;
};


struct read_req_msg_t {
          INT32    code;  /* 3 */
          INT32    length;
          INT32    memory_space;
          ADDR32   address;
          INT32    byte_count;
};


struct write_req_msg_t {
          INT32    code;  /* 4 */
          INT32    length;
          INT32    memory_space;
          ADDR32   address;
          INT32    byte_count;
          BYTE     data[DUMMY];
};


struct write_r_msg_t {
          INT32    code;  /* 4 */
          INT32    length;
          INT32    memory_space;
          ADDR32   address;
          INT32    byte_count;
          INT32    data[DUMMY];
};


struct bkpt_set_msg_t {
          INT32    code;  /* 5 */
          INT32    length;
          INT32    memory_space;
          ADDR32   bkpt_addr;
          INT32    pass_count;
          INT32    bkpt_type;
};


struct bkpt_rm_msg_t {
          INT32    code;  /* 6 */
          INT32    length;
          INT32    memory_space;
          ADDR32   bkpt_addr;
};


struct bkpt_stat_msg_t {
          INT32    code;  /* 7 */
          INT32    length;
          INT32    memory_space;
          ADDR32   bkpt_addr;
};


struct copy_msg_t {
          INT32    code;  /* 8 */
          INT32    length;
          INT32    source_space;
          ADDR32   source_addr;
          INT32    dest_space;
          ADDR32   dest_addr;
          INT32    byte_count;
};


struct fill_msg_t {
          INT32    code;  /* 9 */
          INT32    length;
          INT32    memory_space;
          ADDR32   start_addr;
          INT32    fill_count;
          INT32    byte_count;
          BYTE     fill_data[DUMMY];
};


struct init_msg_t {
          INT32    code;  /* 10 */
          INT32    length;
          ADDR32   text_start;
          ADDR32   text_end;
          ADDR32   data_start;
          ADDR32   data_end;
          ADDR32   entry_point;
          INT32    mem_stack_size;
          INT32    reg_stack_size;
          ADDR32   arg_start;
          INT32    os_control;
};


struct go_msg_t {
          INT32    code;  /* 11 */
          INT32    length;
};


struct step_msg_t {
          INT32    code;  /* 12 */
          INT32    length;
          INT32    count;
};


struct break_msg_t {
          INT32    code;  /* 13 */
          INT32    length;
};


struct hif_call_rtn_msg_t {
          INT32    code;  /* 64 */
          INT32    length;
          INT32    service_number;
          INT32    gr121;
          INT32    gr96;
          INT32    gr97;
};


struct channel0_msg_t {
          INT32    code;  /* 65 */
          INT32    length;
          BYTE     data;
};


struct channel1_ack_msg_t {
          INT32    code;  /* 66 */
          INT32    length;
};
d366 2
a367 2
** Target to host messages
*/
d370 180
a549 163
struct reset_ack_msg_t {
          INT32    code;  /* 32 */
          INT32    length;
};


struct config_msg_t {
          INT32    code;  /* 33 */
          INT32    length;
          INT32    processor_id;
          INT32    version;
          ADDR32   I_mem_start;
          INT32    I_mem_size;
          ADDR32   D_mem_start;
          INT32    D_mem_size;
          ADDR32   ROM_start;
          INT32    ROM_size;
          INT32    max_msg_size;
          INT32    max_bkpts;
          INT32    coprocessor;
          INT32    reserved;
};


struct status_msg_t {
          INT32    code;  /* 34 */
          INT32    length;
          INT32    msgs_sent;
          INT32    msgs_received;
          INT32    errors;
          INT32    bkpts_hit;
          INT32    bkpts_free;
          INT32    traps;
          INT32    fills;
          INT32    spills;
          INT32    cycles;
          INT32    reserved;
};


struct read_ack_msg_t {
          INT32    code;  /* 35 */
          INT32    length;
          INT32    memory_space;
          ADDR32   address;
          INT32    byte_count;
          BYTE     data[DUMMY];
};

struct read_r_ack_msg_t {
          INT32    code;  /* 35 */
          INT32    length;
          INT32    memory_space;
          ADDR32   address;
          INT32    byte_count;
          INT32    data[DUMMY];
};


struct write_ack_msg_t {
          INT32    code;  /* 36 */
          INT32    length;
          INT32    memory_space;
          ADDR32   address;
          INT32    byte_count;
};


struct bkpt_set_ack_msg_t {
          INT32    code;  /* 37 */
          INT32    length;
          INT32    memory_space;
          ADDR32   address;
          INT32    pass_count;
          INT32    bkpt_type;
};


struct bkpt_rm_ack_msg_t {
          INT32    code;  /* 38 */
          INT32    length;
          INT32    memory_space;
          ADDR32   address;
};


struct bkpt_stat_ack_msg_t {
          INT32    code;  /* 39 */
          INT32    length; 
          INT32    memory_space;
          ADDR32   address;
          INT32    pass_count;
          INT32    bkpt_type;
};


struct copy_ack_msg_t {
          INT32    code;  /* 40 */
          INT32    length;
          INT32    source_space;
          ADDR32   source_addr;
          INT32    dest_space;
          ADDR32   dest_addr;
          INT32    byte_count;
};


struct fill_ack_msg_t {
          INT32    code;  /* 41 */
          INT32    length;
          INT32    memory_space;
          ADDR32   start_addr;
          INT32    fill_count;
          INT32    byte_count;
};


struct init_ack_msg_t {
          INT32    code;  /* 42 */
          INT32    length;
};


struct halt_msg_t {
          INT32    code;  /* 43 */
          INT32    length;
          INT32    memory_space;
          ADDR32   pc0;
          ADDR32   pc1;
          INT32    trap_number;
};


struct error_msg_t {
          INT32    code;  /* 63 */
          INT32    length;
          INT32    error_code;
          INT32    memory_space;
          ADDR32   address;
};


struct hif_call_msg_t {
          INT32    code;  /* 96 */
          INT32    length;
          INT32    service_number;
          INT32    lr2;
          INT32    lr3;
          INT32    lr4;
};


struct channel0_ack_msg_t {
          INT32    code;  /* 97 */
          INT32    length;
};


struct channel1_msg_t {
          INT32    code;  /* 98 */
          INT32    length;
          BYTE     data[DUMMY];
};
d554 2
a555 2
** Union all of the message types together
*/
d557 45
a601 44
union msg_t {
         struct generic_msg_t        generic_msg;
         struct generic_int32_msg_t  generic_int32_msg;

         struct reset_msg_t          reset_msg;
         struct config_req_msg_t     config_req_msg;
         struct status_req_msg_t     status_req_msg;
         struct read_req_msg_t       read_req_msg;
         struct write_req_msg_t      write_req_msg;
         struct write_r_msg_t        write_r_msg;
         struct bkpt_set_msg_t       bkpt_set_msg;
         struct bkpt_rm_msg_t        bkpt_rm_msg;
         struct bkpt_stat_msg_t      bkpt_stat_msg;
         struct copy_msg_t           copy_msg;
         struct fill_msg_t           fill_msg;
         struct init_msg_t           init_msg;
         struct go_msg_t             go_msg;
         struct step_msg_t           step_msg;
         struct break_msg_t          break_msg;

         struct hif_call_rtn_msg_t   hif_call_rtn_msg;
         struct channel0_msg_t       channel0_msg;
         struct channel1_ack_msg_t   channel1_ack_msg;

         struct reset_ack_msg_t      reset_ack_msg;
         struct config_msg_t         config_msg;
         struct status_msg_t         status_msg;
         struct read_ack_msg_t       read_ack_msg;
         struct read_r_ack_msg_t     read_r_ack_msg;
         struct write_ack_msg_t      write_ack_msg;
         struct bkpt_set_ack_msg_t   bkpt_set_ack_msg;
         struct bkpt_rm_ack_msg_t    bkpt_rm_ack_msg;
         struct bkpt_stat_ack_msg_t  bkpt_stat_ack_msg;
         struct copy_ack_msg_t       copy_ack_msg;
         struct fill_ack_msg_t       fill_ack_msg;
         struct init_ack_msg_t       init_ack_msg;
         struct halt_msg_t           halt_msg;

         struct error_msg_t          error_msg;

         struct hif_call_msg_t       hif_call_msg;
         struct channel0_ack_msg_t   channel0_ack_msg;
         struct channel1_msg_t       channel1_msg;
};
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d25 8
a32 8
typedef long int INT32;		/* 32 bit integer */
typedef unsigned long int UINT32;	/* 32 bit integer (unsigned) */
typedef unsigned long int ADDR32;	/* 32 bit address */
typedef unsigned long int INST32;	/* 32 bit instruction */
typedef long int BOOLEAN;	/* Boolean value (32 bit) */
typedef unsigned char BYTE;	/* byte (8 bit) */
typedef short int INT16;	/* 16 bit integer */
typedef unsigned short int UINT16;	/* 16 bit integer (unsigned) */
d43 10
a52 10
#define EMUSAGE     1		/* Bad args / flags               */
#define EMFAIL      2		/* Unrecoverable error            */
#define EMBADADDR   3		/* Illegal address                */
#define EMBADREG    4		/* Illegal register               */
#define EMSYNTAX    5		/* Illegal command syntax         */
#define EMACCESS    6		/* Could not access memory        */
#define EMALLOC     7		/* Could not allocate memory      */
#define EMTARGET    8		/* Unknown target type            */
#define EMHINIT     9		/* Could not initialize host      */
#define EMCOMM     10		/* Could not open communication channel */
d55 24
a78 24
#define EMBADMSG   11		/* Unknown message type           */
#define EMMSG2BIG  12		/* Message to large for buffer    */
#define EMNOSEND   13		/* Could not send message         */
#define EMNORECV   14		/* Could not receive message      */

#define EMRESET    15		/* Could not RESET target         */
#define EMCONFIG   16		/* Could not get target CONFIG    */
#define EMSTATUS   17		/* Could not get target STATUS    */
#define EMREAD     18		/* Could not READ target memory   */
#define EMWRITE    19		/* Could not WRITE target memory  */
#define EMBKPTSET  20		/* Could not set breakpoint       */
#define EMBKPTRM   21		/* Could not remove breakpoint    */
#define EMBKPTSTAT 22		/* Could not get breakpoint status */
#define EMBKPTNONE 23		/* All breakpoints in use         */
#define EMBKPTUSED 24		/* Breakpoints already in use     */
#define EMCOPY     25		/* Could not COPY target memory   */
#define EMFILL     26		/* Could not FILL target memory   */
#define EMINIT     27		/* Could not initialize target memory */
#define EMGO       28		/* Could not start execution      */
#define EMSTEP     29		/* Could not single step          */
#define EMBREAK    30		/* Could not BREAK                */
#define EMHIF      31		/* Could not perform HIF service  */
#define EMCHANNEL0 32		/* Could not read CHANNEL0        */
#define EMCHANNEL1 33		/* Could not write CHANNEL1       */
d81 7
a87 7
#define EMOPEN     34		/* Could not open COFF file       */
#define EMHDR      35		/* Could not read COFF header     */
#define EMMAGIC    36		/* Bad magic number               */
#define EMAOUT     37		/* Could not read COFF a.out header */
#define EMSCNHDR   38		/* Could not read COFF section header */
#define EMSCN      39		/* Could not read COFF section    */
#define EMCLOSE    40		/* Could not close COFF file      */
d90 4
a93 4
#define EMLOGOPEN  41		/* Could not open log file        */
#define EMLOGREAD  42		/* Could not read log file        */
#define EMLOGWRITE 43		/* Could not write to log file    */
#define EMLOGCLOSE 44		/* Could not close log file       */
d96 9
a104 9
#define EMCMDOPEN  45		/* Could not open command file    */
#define EMCMDREAD  46		/* Could not read command file    */
#define EMCMDWRITE 47		/* Could not write to command file */
#define EMCMDCLOSE 48		/* Could not close comand file    */

#define EMTIMEOUT  49		/* Host timed out waiting for a message */
#define EMCOMMTYPE 50		/* A '-t' flag must be specified  */
#define EMCOMMERR  51		/* Communication error            */
#define EMBAUD     52		/* Invalid baud rate specified    */
d108 12
a119 12
#define LOCAL_REG    0		/* Local processor register     */
#define GLOBAL_REG   1		/* Global processor register    */
#define SPECIAL_REG  2		/* Special processor register   */
#define TLB_REG      3		/* Translation Lookaside Buffer */
#define COPROC_REG   4		/* Coprocessor register         */
#define I_MEM        5		/* Instruction Memory           */
#define D_MEM        6		/* Data Memory                  */
#define I_ROM        7		/* Instruction ROM              */
#define D_ROM        8		/* Data ROM                     */
#define I_O          9		/* Input/Output                 */
#define I_CACHE     10		/* Instruction Cache            */
#define D_CACHE     11		/* Data Cache                   */
d125 2
a126 2
   ** Host to target definitions
 */
d149 2
a150 2
   ** Target to host definitions
 */
d173 5
a177 6
struct generic_msg_t
  {
    INT32 code;			/* generic */
    INT32 length;
    BYTE byte[DUMMY];
  };
d181 5
a185 6
struct generic_int32_msg_t
  {
    INT32 code;			/* generic */
    INT32 length;
    INT32 int32[DUMMY];
  };
d189 2
a190 2
   ** Host to target messages
 */
d192 150
a341 168
struct reset_msg_t
  {
    INT32 code;			/* 0 */
    INT32 length;
  };


struct config_req_msg_t
  {
    INT32 code;			/* 1 */
    INT32 length;
  };


struct status_req_msg_t
  {
    INT32 code;			/* 2 */
    INT32 length;
  };


struct read_req_msg_t
  {
    INT32 code;			/* 3 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 byte_count;
  };


struct write_req_msg_t
  {
    INT32 code;			/* 4 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 byte_count;
    BYTE data[DUMMY];
  };


struct write_r_msg_t
  {
    INT32 code;			/* 4 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 byte_count;
    INT32 data[DUMMY];
  };


struct bkpt_set_msg_t
  {
    INT32 code;			/* 5 */
    INT32 length;
    INT32 memory_space;
    ADDR32 bkpt_addr;
    INT32 pass_count;
    INT32 bkpt_type;
  };


struct bkpt_rm_msg_t
  {
    INT32 code;			/* 6 */
    INT32 length;
    INT32 memory_space;
    ADDR32 bkpt_addr;
  };


struct bkpt_stat_msg_t
  {
    INT32 code;			/* 7 */
    INT32 length;
    INT32 memory_space;
    ADDR32 bkpt_addr;
  };


struct copy_msg_t
  {
    INT32 code;			/* 8 */
    INT32 length;
    INT32 source_space;
    ADDR32 source_addr;
    INT32 dest_space;
    ADDR32 dest_addr;
    INT32 byte_count;
  };


struct fill_msg_t
  {
    INT32 code;			/* 9 */
    INT32 length;
    INT32 memory_space;
    ADDR32 start_addr;
    INT32 fill_count;
    INT32 byte_count;
    BYTE fill_data[DUMMY];
  };


struct init_msg_t
  {
    INT32 code;			/* 10 */
    INT32 length;
    ADDR32 text_start;
    ADDR32 text_end;
    ADDR32 data_start;
    ADDR32 data_end;
    ADDR32 entry_point;
    INT32 mem_stack_size;
    INT32 reg_stack_size;
    ADDR32 arg_start;
    INT32 os_control;
  };


struct go_msg_t
  {
    INT32 code;			/* 11 */
    INT32 length;
  };


struct step_msg_t
  {
    INT32 code;			/* 12 */
    INT32 length;
    INT32 count;
  };


struct break_msg_t
  {
    INT32 code;			/* 13 */
    INT32 length;
  };


struct hif_call_rtn_msg_t
  {
    INT32 code;			/* 64 */
    INT32 length;
    INT32 service_number;
    INT32 gr121;
    INT32 gr96;
    INT32 gr97;
  };


struct channel0_msg_t
  {
    INT32 code;			/* 65 */
    INT32 length;
    BYTE data;
  };


struct channel1_ack_msg_t
  {
    INT32 code;			/* 66 */
    INT32 length;
  };
d345 2
a346 2
   ** Target to host messages
 */
d349 163
a511 180
struct reset_ack_msg_t
  {
    INT32 code;			/* 32 */
    INT32 length;
  };


struct config_msg_t
  {
    INT32 code;			/* 33 */
    INT32 length;
    INT32 processor_id;
    INT32 version;
    ADDR32 I_mem_start;
    INT32 I_mem_size;
    ADDR32 D_mem_start;
    INT32 D_mem_size;
    ADDR32 ROM_start;
    INT32 ROM_size;
    INT32 max_msg_size;
    INT32 max_bkpts;
    INT32 coprocessor;
    INT32 reserved;
  };


struct status_msg_t
  {
    INT32 code;			/* 34 */
    INT32 length;
    INT32 msgs_sent;
    INT32 msgs_received;
    INT32 errors;
    INT32 bkpts_hit;
    INT32 bkpts_free;
    INT32 traps;
    INT32 fills;
    INT32 spills;
    INT32 cycles;
    INT32 reserved;
  };


struct read_ack_msg_t
  {
    INT32 code;			/* 35 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 byte_count;
    BYTE data[DUMMY];
  };

struct read_r_ack_msg_t
  {
    INT32 code;			/* 35 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 byte_count;
    INT32 data[DUMMY];
  };


struct write_ack_msg_t
  {
    INT32 code;			/* 36 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 byte_count;
  };


struct bkpt_set_ack_msg_t
  {
    INT32 code;			/* 37 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 pass_count;
    INT32 bkpt_type;
  };


struct bkpt_rm_ack_msg_t
  {
    INT32 code;			/* 38 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
  };


struct bkpt_stat_ack_msg_t
  {
    INT32 code;			/* 39 */
    INT32 length;
    INT32 memory_space;
    ADDR32 address;
    INT32 pass_count;
    INT32 bkpt_type;
  };


struct copy_ack_msg_t
  {
    INT32 code;			/* 40 */
    INT32 length;
    INT32 source_space;
    ADDR32 source_addr;
    INT32 dest_space;
    ADDR32 dest_addr;
    INT32 byte_count;
  };


struct fill_ack_msg_t
  {
    INT32 code;			/* 41 */
    INT32 length;
    INT32 memory_space;
    ADDR32 start_addr;
    INT32 fill_count;
    INT32 byte_count;
  };


struct init_ack_msg_t
  {
    INT32 code;			/* 42 */
    INT32 length;
  };


struct halt_msg_t
  {
    INT32 code;			/* 43 */
    INT32 length;
    INT32 memory_space;
    ADDR32 pc0;
    ADDR32 pc1;
    INT32 trap_number;
  };


struct error_msg_t
  {
    INT32 code;			/* 63 */
    INT32 length;
    INT32 error_code;
    INT32 memory_space;
    ADDR32 address;
  };


struct hif_call_msg_t
  {
    INT32 code;			/* 96 */
    INT32 length;
    INT32 service_number;
    INT32 lr2;
    INT32 lr3;
    INT32 lr4;
  };


struct channel0_ack_msg_t
  {
    INT32 code;			/* 97 */
    INT32 length;
  };


struct channel1_msg_t
  {
    INT32 code;			/* 98 */
    INT32 length;
    BYTE data[DUMMY];
  };
d516 2
a517 2
   ** Union all of the message types together
 */
d519 44
a562 45
union msg_t
  {
    struct generic_msg_t generic_msg;
    struct generic_int32_msg_t generic_int32_msg;

    struct reset_msg_t reset_msg;
    struct config_req_msg_t config_req_msg;
    struct status_req_msg_t status_req_msg;
    struct read_req_msg_t read_req_msg;
    struct write_req_msg_t write_req_msg;
    struct write_r_msg_t write_r_msg;
    struct bkpt_set_msg_t bkpt_set_msg;
    struct bkpt_rm_msg_t bkpt_rm_msg;
    struct bkpt_stat_msg_t bkpt_stat_msg;
    struct copy_msg_t copy_msg;
    struct fill_msg_t fill_msg;
    struct init_msg_t init_msg;
    struct go_msg_t go_msg;
    struct step_msg_t step_msg;
    struct break_msg_t break_msg;

    struct hif_call_rtn_msg_t hif_call_rtn_msg;
    struct channel0_msg_t channel0_msg;
    struct channel1_ack_msg_t channel1_ack_msg;

    struct reset_ack_msg_t reset_ack_msg;
    struct config_msg_t config_msg;
    struct status_msg_t status_msg;
    struct read_ack_msg_t read_ack_msg;
    struct read_r_ack_msg_t read_r_ack_msg;
    struct write_ack_msg_t write_ack_msg;
    struct bkpt_set_ack_msg_t bkpt_set_ack_msg;
    struct bkpt_rm_ack_msg_t bkpt_rm_ack_msg;
    struct bkpt_stat_ack_msg_t bkpt_stat_ack_msg;
    struct copy_ack_msg_t copy_ack_msg;
    struct fill_ack_msg_t fill_ack_msg;
    struct init_ack_msg_t init_ack_msg;
    struct halt_msg_t halt_msg;

    struct error_msg_t error_msg;

    struct hif_call_msg_t hif_call_msg;
    struct channel0_ack_msg_t channel0_ack_msg;
    struct channel1_msg_t channel1_msg;
  };
@

