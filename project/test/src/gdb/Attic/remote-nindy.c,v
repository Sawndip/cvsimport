head	1.21;
access;
symbols
	gdb_5_3-2002-12-12-release:1.20
	carlton_dictionary-20021115-merge:1.20
	kseitz_interps-20021105-merge:1.20
	kseitz_interps-20021103-merge:1.20
	drow-cplus-merge-20021020:1.20
	drow-cplus-merge-20021025:1.20
	carlton_dictionary-20021025-merge:1.20
	carlton_dictionary-20021011-merge:1.20
	drow-cplus-branch:1.20.0.10
	drow-cplus-branchpoint:1.20
	kseitz_interps-20020930-merge:1.20
	carlton_dictionary-20020927-merge:1.20
	carlton_dictionary-branch:1.20.0.8
	carlton_dictionary-20020920-branchpoint:1.20
	gdb_5_3-branch:1.20.0.6
	gdb_5_3-2002-09-04-branchpoint:1.20
	kseitz_interps-20020829-merge:1.20
	cagney_sysregs-20020825-branch:1.20.0.4
	cagney_sysregs-20020825-branchpoint:1.20
	readline_4_3-import-branch:1.20.0.2
	readline_4_3-import-branchpoint:1.20
	gdb_5_2_1-2002-07-23-release:1.19
	kseitz_interps-20020528-branch:1.19.0.8
	kseitz_interps-20020528-branchpoint:1.19
	cagney_regbuf-20020515-branch:1.19.0.6
	cagney_regbuf-20020515-branchpoint:1.19
	jimb-macro-020506-branch:1.19.0.4
	jimb-macro-020506-branchpoint:1.19
	gdb_5_2-2002-04-29-release:1.19
	gdb_5_2-branch:1.19.0.2
	gdb_5_2-2002-03-03-branchpoint:1.19
	gdb_5_1_1-2002-01-24-release:1.18
	gdb_5_1_0_1-2002-01-03-release:1.18
	cygnus_cvs_20020108_pre:1.18
	gdb_5_1_0_1-2002-01-03-branchpoint:1.18
	gdb_5_1_0_1-2002-01-03-branch:1.18.0.6
	gdb_5_1-2001-11-21-release:1.18
	gdb_s390-2001-09-26-branch:1.18.0.4
	gdb_s390-2001-09-26-branchpoint:1.18
	gdb_5_1-2001-07-29-branch:1.18.0.2
	gdb_5_1-2001-07-29-branchpoint:1.18
	dberlin-typesystem-branch:1.16.0.2
	dberlin-typesystem-branchpoint:1.16
	gdb-post-ptid_t-2001-05-03:1.16
	gdb-pre-ptid_t-2001-05-03:1.15
	insight-precleanup-2001-01-01:1.10
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.2
	insight-2000-02-04:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.21
date	2002.12.16.20.39.09;	author cagney;	state dead;
branches;
next	1.20;

1.20
date	2002.08.22.21.52.44;	author cagney;	state Exp;
branches
	1.20.8.1
	1.20.10.1;
next	1.19;

1.19
date	2002.01.19.03.32.38;	author cagney;	state Exp;
branches
	1.19.8.1;
next	1.18;

1.18
date	2001.07.15.20.34.13;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.11.17.52.32;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.14.19.23.02;	author jtc;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.06.08.21.12;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.02.19.14.33;	author jtc;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.23.22.48.55;	author jtc;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.15.01.01.49;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.03.22.00.56;	author jtc;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.10.05.17.25;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.18.22.52.23;	author jtc;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.10.18.54.27;	author jtc;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.19.18.59.07;	author jtc;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.47;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.09.09;	author jsm;	state Exp;
branches;
next	;

1.19.8.1
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	;

1.20.8.1
date	2002.12.23.19.38.39;	author carlton;	state dead;
branches;
next	;

1.20.10.1
date	2003.12.14.20.27.28;	author drow;	state dead;
branches;
next	;


desc
@@


1.21
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Memory-access and commands for remote NINDY process, for GDB.
// OBSOLETE 
// OBSOLETE    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
// OBSOLETE    2000, 2001, 2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    Contributed by Intel Corporation.  Modified from remote.c by Chris Benenati.
// OBSOLETE 
// OBSOLETE    GDB is distributed in the hope that it will be useful, but WITHOUT ANY
// OBSOLETE    WARRANTY.  No author or distributor accepts responsibility to anyone
// OBSOLETE    for the consequences of using it or for whether it serves any
// OBSOLETE    particular purpose or works at all, unless he says so in writing.
// OBSOLETE    Refer to the GDB General Public License for full details.
// OBSOLETE 
// OBSOLETE    Everyone is granted permission to copy, modify and redistribute GDB,
// OBSOLETE    but only under the conditions described in the GDB General Public
// OBSOLETE    License.  A copy of this license is supposed to have been given to you
// OBSOLETE    along with GDB so you can know your rights and responsibilities.  It
// OBSOLETE    should be in a file named COPYING.  Among other things, the copyright
// OBSOLETE    notice and this notice must be preserved on all copies.
// OBSOLETE 
// OBSOLETE    In other words, go ahead and share GDB, but don't try to stop
// OBSOLETE    anyone else from sharing it farther.  Help stamp out software hoarding!  */
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE    Except for the data cache routines, this file bears little resemblence
// OBSOLETE    to remote.c.  A new (although similar) protocol has been specified, and
// OBSOLETE    portions of the code are entirely dependent on having an i80960 with a
// OBSOLETE    NINDY ROM monitor at the other end of the line.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /*****************************************************************************
// OBSOLETE  *
// OBSOLETE  * REMOTE COMMUNICATION PROTOCOL BETWEEN GDB960 AND THE NINDY ROM MONITOR.
// OBSOLETE  *
// OBSOLETE  *
// OBSOLETE  * MODES OF OPERATION
// OBSOLETE  * ----- -- ---------
// OBSOLETE  *	
// OBSOLETE  * As far as NINDY is concerned, GDB is always in one of two modes: command
// OBSOLETE  * mode or passthrough mode.
// OBSOLETE  *
// OBSOLETE  * In command mode (the default) pre-defined packets containing requests
// OBSOLETE  * are sent by GDB to NINDY.  NINDY never talks except in reponse to a request.
// OBSOLETE  *
// OBSOLETE  * Once the the user program is started, GDB enters passthrough mode, to give
// OBSOLETE  * the user program access to the terminal.  GDB remains in this mode until
// OBSOLETE  * NINDY indicates that the program has stopped.
// OBSOLETE  *
// OBSOLETE  *
// OBSOLETE  * PASSTHROUGH MODE
// OBSOLETE  * ----------- ----
// OBSOLETE  *
// OBSOLETE  * GDB writes all input received from the keyboard directly to NINDY, and writes
// OBSOLETE  * all characters received from NINDY directly to the monitor.
// OBSOLETE  *
// OBSOLETE  * Keyboard input is neither buffered nor echoed to the monitor.
// OBSOLETE  *
// OBSOLETE  * GDB remains in passthrough mode until NINDY sends a single ^P character,
// OBSOLETE  * to indicate that the user process has stopped.
// OBSOLETE  *
// OBSOLETE  * Note:
// OBSOLETE  *	GDB assumes NINDY performs a 'flushreg' when the user program stops.
// OBSOLETE  *
// OBSOLETE  *
// OBSOLETE  * COMMAND MODE
// OBSOLETE  * ------- ----
// OBSOLETE  *
// OBSOLETE  * All info (except for message ack and nak) is transferred between gdb
// OBSOLETE  * and the remote processor in messages of the following format:
// OBSOLETE  *
// OBSOLETE  *		<info>#<checksum>
// OBSOLETE  *
// OBSOLETE  * where 
// OBSOLETE  *	#	is a literal character
// OBSOLETE  *
// OBSOLETE  *	<info>	ASCII information;  all numeric information is in the
// OBSOLETE  *		form of hex digits ('0'-'9' and lowercase 'a'-'f').
// OBSOLETE  *
// OBSOLETE  *	<checksum>
// OBSOLETE  *		is a pair of ASCII hex digits representing an 8-bit
// OBSOLETE  *		checksum formed by adding together each of the
// OBSOLETE  *		characters in <info>.
// OBSOLETE  *
// OBSOLETE  * The receiver of a message always sends a single character to the sender
// OBSOLETE  * to indicate that the checksum was good ('+') or bad ('-');  the sender
// OBSOLETE  * re-transmits the entire message over until a '+' is received.
// OBSOLETE  *
// OBSOLETE  * In response to a command NINDY always sends back either data or
// OBSOLETE  * a result code of the form "Xnn", where "nn" are hex digits and "X00"
// OBSOLETE  * means no errors.  (Exceptions: the "s" and "c" commands don't respond.)
// OBSOLETE  *
// OBSOLETE  * SEE THE HEADER OF THE FILE "gdb.c" IN THE NINDY MONITOR SOURCE CODE FOR A
// OBSOLETE  * FULL DESCRIPTION OF LEGAL COMMANDS.
// OBSOLETE  *
// OBSOLETE  * SEE THE FILE "stop.h" IN THE NINDY MONITOR SOURCE CODE FOR A LIST
// OBSOLETE  * OF STOP CODES.
// OBSOLETE  *
// OBSOLETE  ***************************************************************************/
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include <signal.h>
// OBSOLETE #include <sys/types.h>
// OBSOLETE #include <setjmp.h>
// OBSOLETE 
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "bfd.h"
// OBSOLETE #include "symfile.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "command.h"
// OBSOLETE #include "floatformat.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #include <sys/file.h>
// OBSOLETE #include <ctype.h>
// OBSOLETE #include "serial.h"
// OBSOLETE #include "nindy-share/env.h"
// OBSOLETE #include "nindy-share/stop.h"
// OBSOLETE #include "remote-utils.h"
// OBSOLETE 
// OBSOLETE extern int unlink ();
// OBSOLETE extern char *getenv ();
// OBSOLETE extern char *mktemp ();
// OBSOLETE 
// OBSOLETE extern void generic_mourn_inferior ();
// OBSOLETE 
// OBSOLETE extern struct target_ops nindy_ops;
// OBSOLETE extern FILE *instream;
// OBSOLETE 
// OBSOLETE extern char ninStopWhy ();
// OBSOLETE extern int ninMemGet ();
// OBSOLETE extern int ninMemPut ();
// OBSOLETE 
// OBSOLETE int nindy_initial_brk;		/* nonzero if want to send an initial BREAK to nindy */
// OBSOLETE int nindy_old_protocol;		/* nonzero if want to use old protocol */
// OBSOLETE char *nindy_ttyname;		/* name of tty to talk to nindy on, or null */
// OBSOLETE 
// OBSOLETE #define DLE	'\020'		/* Character NINDY sends to indicate user program has
// OBSOLETE 				   * halted.  */
// OBSOLETE #define TRUE	1
// OBSOLETE #define FALSE	0
// OBSOLETE 
// OBSOLETE /* From nindy-share/nindy.c.  */
// OBSOLETE extern struct serial *nindy_serial;
// OBSOLETE 
// OBSOLETE static int have_regs = 0;	/* 1 iff regs read since i960 last halted */
// OBSOLETE static int regs_changed = 0;	/* 1 iff regs were modified since last read */
// OBSOLETE 
// OBSOLETE extern char *exists ();
// OBSOLETE 
// OBSOLETE static void nindy_fetch_registers (int);
// OBSOLETE 
// OBSOLETE static void nindy_store_registers (int);
// OBSOLETE 
// OBSOLETE static char *savename;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_close (int quitting)
// OBSOLETE {
// OBSOLETE   if (nindy_serial != NULL)
// OBSOLETE     serial_close (nindy_serial);
// OBSOLETE   nindy_serial = NULL;
// OBSOLETE 
// OBSOLETE   if (savename)
// OBSOLETE     xfree (savename);
// OBSOLETE   savename = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Open a connection to a remote debugger.   
// OBSOLETE    FIXME, there should be "set" commands for the options that are
// OBSOLETE    now specified with gdb command-line options (old_protocol,
// OBSOLETE    and initial_brk).  */
// OBSOLETE void
// OBSOLETE nindy_open (char *name,		/* "/dev/ttyXX", "ttyXX", or "XX": tty to be opened */
// OBSOLETE 	    int from_tty)
// OBSOLETE {
// OBSOLETE   char baudrate[1024];
// OBSOLETE 
// OBSOLETE   if (!name)
// OBSOLETE     error_no_arg ("serial port device name");
// OBSOLETE 
// OBSOLETE   target_preopen (from_tty);
// OBSOLETE 
// OBSOLETE   nindy_close (0);
// OBSOLETE 
// OBSOLETE   have_regs = regs_changed = 0;
// OBSOLETE 
// OBSOLETE   /* Allow user to interrupt the following -- we could hang if there's
// OBSOLETE      no NINDY at the other end of the remote tty.  */
// OBSOLETE   immediate_quit++;
// OBSOLETE   /* If baud_rate is -1, then ninConnect will not recognize the baud rate
// OBSOLETE      and will deal with the situation in a (more or less) reasonable
// OBSOLETE      fashion.  */
// OBSOLETE   sprintf (baudrate, "%d", baud_rate);
// OBSOLETE   ninConnect (name, baudrate,
// OBSOLETE 	      nindy_initial_brk, !from_tty, nindy_old_protocol);
// OBSOLETE   immediate_quit--;
// OBSOLETE 
// OBSOLETE   if (nindy_serial == NULL)
// OBSOLETE     {
// OBSOLETE       perror_with_name (name);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   savename = savestring (name, strlen (name));
// OBSOLETE   push_target (&nindy_ops);
// OBSOLETE 
// OBSOLETE   target_fetch_registers (-1);
// OBSOLETE 
// OBSOLETE   init_thread_list ();
// OBSOLETE   init_wait_for_inferior ();
// OBSOLETE   clear_proceed_status ();
// OBSOLETE   normal_stop ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* User-initiated quit of nindy operations.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_detach (char *name, int from_tty)
// OBSOLETE {
// OBSOLETE   if (name)
// OBSOLETE     error ("Too many arguments");
// OBSOLETE   pop_target ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_files_info (void)
// OBSOLETE {
// OBSOLETE   /* FIXME: this lies about the baud rate if we autobauded.  */
// OBSOLETE   printf_unfiltered ("\tAttached to %s at %d bits per second%s%s.\n", savename,
// OBSOLETE 		     baud_rate,
// OBSOLETE 		     nindy_old_protocol ? " in old protocol" : "",
// OBSOLETE 		     nindy_initial_brk ? " with initial break" : "");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the number of characters in the buffer BUF before
// OBSOLETE    the first DLE character.  N is maximum number of characters to
// OBSOLETE    consider.  */
// OBSOLETE 
// OBSOLETE static
// OBSOLETE int
// OBSOLETE non_dle (char *buf, int n)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   for (i = 0; i < n; i++)
// OBSOLETE     {
// OBSOLETE       if (buf[i] == DLE)
// OBSOLETE 	{
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   return i;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Tell the remote machine to resume.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE nindy_resume (ptid_t ptid, int step, enum target_signal siggnal)
// OBSOLETE {
// OBSOLETE   if (siggnal != TARGET_SIGNAL_0 && siggnal != stop_signal)
// OBSOLETE     warning ("Can't send signals to remote NINDY targets.");
// OBSOLETE 
// OBSOLETE   if (regs_changed)
// OBSOLETE     {
// OBSOLETE       nindy_store_registers (-1);
// OBSOLETE       regs_changed = 0;
// OBSOLETE     }
// OBSOLETE   have_regs = 0;
// OBSOLETE   ninGo (step);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* FIXME, we can probably use the normal terminal_inferior stuff here.
// OBSOLETE    We have to do terminal_inferior and then set up the passthrough
// OBSOLETE    settings initially.  Thereafter, terminal_ours and terminal_inferior
// OBSOLETE    will automatically swap the settings around for us.  */
// OBSOLETE 
// OBSOLETE struct clean_up_tty_args
// OBSOLETE {
// OBSOLETE   serial_ttystate state;
// OBSOLETE   struct serial *serial;
// OBSOLETE };
// OBSOLETE static struct clean_up_tty_args tty_args;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE clean_up_tty (PTR ptrarg)
// OBSOLETE {
// OBSOLETE   struct clean_up_tty_args *args = (struct clean_up_tty_args *) ptrarg;
// OBSOLETE   serial_set_tty_state (args->serial, args->state);
// OBSOLETE   xfree (args->state);
// OBSOLETE   warning ("\n\nYou may need to reset the 80960 and/or reload your program.\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Recover from ^Z or ^C while remote process is running */
// OBSOLETE static void (*old_ctrlc) ();
// OBSOLETE #ifdef SIGTSTP
// OBSOLETE static void (*old_ctrlz) ();
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE clean_up_int (void)
// OBSOLETE {
// OBSOLETE   serial_set_tty_state (tty_args.serial, tty_args.state);
// OBSOLETE   xfree (tty_args.state);
// OBSOLETE 
// OBSOLETE   signal (SIGINT, old_ctrlc);
// OBSOLETE #ifdef SIGTSTP
// OBSOLETE   signal (SIGTSTP, old_ctrlz);
// OBSOLETE #endif
// OBSOLETE   error ("\n\nYou may need to reset the 80960 and/or reload your program.\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Wait until the remote machine stops. While waiting, operate in passthrough
// OBSOLETE  * mode; i.e., pass everything NINDY sends to gdb_stdout, and everything from
// OBSOLETE  * stdin to NINDY.
// OBSOLETE  *
// OBSOLETE  * Return to caller, storing status in 'status' just as `wait' would.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static ptid_t
// OBSOLETE nindy_wait (ptid_t ptid, struct target_waitstatus *status)
// OBSOLETE {
// OBSOLETE   fd_set fds;
// OBSOLETE   int c;
// OBSOLETE   char buf[2];
// OBSOLETE   int i, n;
// OBSOLETE   unsigned char stop_exit;
// OBSOLETE   unsigned char stop_code;
// OBSOLETE   struct cleanup *old_cleanups;
// OBSOLETE   long ip_value, fp_value, sp_value;	/* Reg values from stop */
// OBSOLETE 
// OBSOLETE   status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE   status->value.integer = 0;
// OBSOLETE 
// OBSOLETE   /* OPERATE IN PASSTHROUGH MODE UNTIL NINDY SENDS A DLE CHARACTER */
// OBSOLETE 
// OBSOLETE   /* Save current tty attributes, and restore them when done.  */
// OBSOLETE   tty_args.serial = serial_fdopen (0);
// OBSOLETE   tty_args.state = serial_get_tty_state (tty_args.serial);
// OBSOLETE   old_ctrlc = signal (SIGINT, clean_up_int);
// OBSOLETE #ifdef SIGTSTP
// OBSOLETE   old_ctrlz = signal (SIGTSTP, clean_up_int);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   old_cleanups = make_cleanup (clean_up_tty, &tty_args);
// OBSOLETE 
// OBSOLETE   /* Pass input from keyboard to NINDY as it arrives.  NINDY will interpret
// OBSOLETE      <CR> and perform echo.  */
// OBSOLETE   /* This used to set CBREAK and clear ECHO and CRMOD.  I hope this is close
// OBSOLETE      enough.  */
// OBSOLETE   serial_raw (tty_args.serial);
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       /* Input on remote */
// OBSOLETE       c = serial_readchar (nindy_serial, -1);
// OBSOLETE       if (c == SERIAL_ERROR)
// OBSOLETE 	{
// OBSOLETE 	  error ("Cannot read from serial line");
// OBSOLETE 	}
// OBSOLETE       else if (c == 0x1b)	/* ESC */
// OBSOLETE 	{
// OBSOLETE 	  c = serial_readchar (nindy_serial, -1);
// OBSOLETE 	  c &= ~0x40;
// OBSOLETE 	}
// OBSOLETE       else if (c != 0x10)	/* DLE */
// OBSOLETE 	/* Write out any characters preceding DLE */
// OBSOLETE 	{
// OBSOLETE 	  buf[0] = (char) c;
// OBSOLETE 	  write (1, buf, 1);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  stop_exit = ninStopWhy (&stop_code,
// OBSOLETE 				  &ip_value, &fp_value, &sp_value);
// OBSOLETE 	  if (!stop_exit && (stop_code == STOP_SRQ))
// OBSOLETE 	    {
// OBSOLETE 	      immediate_quit++;
// OBSOLETE 	      ninSrq ();
// OBSOLETE 	      immediate_quit--;
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      /* Get out of loop */
// OBSOLETE 	      supply_register (IP_REGNUM,
// OBSOLETE 			       (char *) &ip_value);
// OBSOLETE 	      supply_register (FP_REGNUM,
// OBSOLETE 			       (char *) &fp_value);
// OBSOLETE 	      supply_register (SP_REGNUM,
// OBSOLETE 			       (char *) &sp_value);
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   serial_set_tty_state (tty_args.serial, tty_args.state);
// OBSOLETE   xfree (tty_args.state);
// OBSOLETE   discard_cleanups (old_cleanups);
// OBSOLETE 
// OBSOLETE   if (stop_exit)
// OBSOLETE     {
// OBSOLETE       status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE       status->value.integer = stop_code;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* nindy has some special stop code need to be handled */
// OBSOLETE       if (stop_code == STOP_GDB_BPT)
// OBSOLETE 	stop_code = TRACE_STEP;
// OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE       status->value.sig = i960_fault_to_signal (stop_code);
// OBSOLETE     }
// OBSOLETE   return inferior_ptid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read the remote registers into the block REGS.  */
// OBSOLETE 
// OBSOLETE /* This is the block that ninRegsGet and ninRegsPut handles.  */
// OBSOLETE struct nindy_regs
// OBSOLETE {
// OBSOLETE   char local_regs[16 * 4];
// OBSOLETE   char global_regs[16 * 4];
// OBSOLETE   char pcw_acw[2 * 4];
// OBSOLETE   char ip[4];
// OBSOLETE   char tcw[4];
// OBSOLETE   char fp_as_double[4 * 8];
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_fetch_registers (int regno)
// OBSOLETE {
// OBSOLETE   struct nindy_regs nindy_regs;
// OBSOLETE   int regnum;
// OBSOLETE 
// OBSOLETE   immediate_quit++;
// OBSOLETE   ninRegsGet ((char *) &nindy_regs);
// OBSOLETE   immediate_quit--;
// OBSOLETE 
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (R0_REGNUM)], nindy_regs.local_regs, 16 * 4);
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (G0_REGNUM)], nindy_regs.global_regs, 16 * 4);
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (PCW_REGNUM)], nindy_regs.pcw_acw, 2 * 4);
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (IP_REGNUM)], nindy_regs.ip, 1 * 4);
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (TCW_REGNUM)], nindy_regs.tcw, 1 * 4);
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)], nindy_regs.fp_as_double, 4 * 8);
// OBSOLETE 
// OBSOLETE   registers_fetched ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_prepare_to_store (void)
// OBSOLETE {
// OBSOLETE   /* Fetch all regs if they aren't already here.  */
// OBSOLETE   read_register_bytes (0, NULL, REGISTER_BYTES);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_store_registers (int regno)
// OBSOLETE {
// OBSOLETE   struct nindy_regs nindy_regs;
// OBSOLETE   int regnum;
// OBSOLETE 
// OBSOLETE   memcpy (nindy_regs.local_regs, &registers[REGISTER_BYTE (R0_REGNUM)], 16 * 4);
// OBSOLETE   memcpy (nindy_regs.global_regs, &registers[REGISTER_BYTE (G0_REGNUM)], 16 * 4);
// OBSOLETE   memcpy (nindy_regs.pcw_acw, &registers[REGISTER_BYTE (PCW_REGNUM)], 2 * 4);
// OBSOLETE   memcpy (nindy_regs.ip, &registers[REGISTER_BYTE (IP_REGNUM)], 1 * 4);
// OBSOLETE   memcpy (nindy_regs.tcw, &registers[REGISTER_BYTE (TCW_REGNUM)], 1 * 4);
// OBSOLETE   memcpy (nindy_regs.fp_as_double, &registers[REGISTER_BYTE (FP0_REGNUM)], 8 * 4);
// OBSOLETE 
// OBSOLETE   immediate_quit++;
// OBSOLETE   ninRegsPut ((char *) &nindy_regs);
// OBSOLETE   immediate_quit--;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Copy LEN bytes to or from inferior's memory starting at MEMADDR
// OBSOLETE    to debugger memory starting at MYADDR.   Copy to inferior if
// OBSOLETE    SHOULD_WRITE is nonzero.  Returns the length copied.  TARGET is
// OBSOLETE    unused.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE nindy_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len,
// OBSOLETE 			    int should_write, struct mem_attrib *attrib,
// OBSOLETE 			    struct target_ops *target)
// OBSOLETE {
// OBSOLETE   int res;
// OBSOLETE 
// OBSOLETE   if (len <= 0)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   if (should_write)
// OBSOLETE     res = ninMemPut (memaddr, myaddr, len);
// OBSOLETE   else
// OBSOLETE     res = ninMemGet (memaddr, myaddr, len);
// OBSOLETE 
// OBSOLETE   return res;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_create_inferior (char *execfile, char *args, char **env)
// OBSOLETE {
// OBSOLETE   int entry_pt;
// OBSOLETE   int pid;
// OBSOLETE 
// OBSOLETE   if (args && *args)
// OBSOLETE     error ("Can't pass arguments to remote NINDY process");
// OBSOLETE 
// OBSOLETE   if (execfile == 0 || exec_bfd == 0)
// OBSOLETE     error ("No executable file specified");
// OBSOLETE 
// OBSOLETE   entry_pt = (int) bfd_get_start_address (exec_bfd);
// OBSOLETE 
// OBSOLETE   pid = 42;
// OBSOLETE 
// OBSOLETE   /* The "process" (board) is already stopped awaiting our commands, and
// OBSOLETE      the program is already downloaded.  We just set its PC and go.  */
// OBSOLETE 
// OBSOLETE   inferior_ptid = pid_to_ptid (pid);	/* Needed for wait_for_inferior below */
// OBSOLETE 
// OBSOLETE   clear_proceed_status ();
// OBSOLETE 
// OBSOLETE   /* Tell wait_for_inferior that we've started a new process.  */
// OBSOLETE   init_wait_for_inferior ();
// OBSOLETE 
// OBSOLETE   /* Set up the "saved terminal modes" of the inferior
// OBSOLETE      based on what modes we are starting it with.  */
// OBSOLETE   target_terminal_init ();
// OBSOLETE 
// OBSOLETE   /* Install inferior's terminal modes.  */
// OBSOLETE   target_terminal_inferior ();
// OBSOLETE 
// OBSOLETE   /* insert_step_breakpoint ();  FIXME, do we need this?  */
// OBSOLETE   /* Let 'er rip... */
// OBSOLETE   proceed ((CORE_ADDR) entry_pt, TARGET_SIGNAL_DEFAULT, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE reset_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   if (nindy_serial == NULL)
// OBSOLETE     {
// OBSOLETE       error ("No target system to reset -- use 'target nindy' command.");
// OBSOLETE     }
// OBSOLETE   if (query ("Really reset the target system?", 0, 0))
// OBSOLETE     {
// OBSOLETE       serial_send_break (nindy_serial);
// OBSOLETE       tty_flush (nindy_serial);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE nindy_kill (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   return;			/* Ignore attempts to kill target system */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Clean up when a program exits.
// OBSOLETE 
// OBSOLETE    The program actually lives on in the remote processor's RAM, and may be
// OBSOLETE    run again without a download.  Don't leave it full of breakpoint
// OBSOLETE    instructions.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE nindy_mourn_inferior (void)
// OBSOLETE {
// OBSOLETE   remove_breakpoints ();
// OBSOLETE   unpush_target (&nindy_ops);
// OBSOLETE   generic_mourn_inferior ();	/* Do all the proper things now */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Pass the args the way catch_errors wants them.  */
// OBSOLETE static int
// OBSOLETE nindy_open_stub (char *arg)
// OBSOLETE {
// OBSOLETE   nindy_open (arg, 1);
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_load (char *filename, int from_tty)
// OBSOLETE {
// OBSOLETE   asection *s;
// OBSOLETE   /* Can't do unix style forking on a VMS system, so we'll use bfd to do
// OBSOLETE      all the work for us
// OBSOLETE    */
// OBSOLETE 
// OBSOLETE   bfd *file = bfd_openr (filename, 0);
// OBSOLETE   if (!file)
// OBSOLETE     {
// OBSOLETE       perror_with_name (filename);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!bfd_check_format (file, bfd_object))
// OBSOLETE     {
// OBSOLETE       error ("can't prove it's an object file\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   for (s = file->sections; s; s = s->next)
// OBSOLETE     {
// OBSOLETE       if (s->flags & SEC_LOAD)
// OBSOLETE 	{
// OBSOLETE 	  char *buffer = xmalloc (s->_raw_size);
// OBSOLETE 	  bfd_get_section_contents (file, s, buffer, 0, s->_raw_size);
// OBSOLETE 	  printf ("Loading section %s, size %x vma %x\n",
// OBSOLETE 		  s->name,
// OBSOLETE 		  s->_raw_size,
// OBSOLETE 		  s->vma);
// OBSOLETE 	  ninMemPut (s->vma, buffer, s->_raw_size);
// OBSOLETE 	  xfree (buffer);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   bfd_close (file);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE load_stub (char *arg)
// OBSOLETE {
// OBSOLETE   target_load (arg, 1);
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* This routine is run as a hook, just before the main command loop is
// OBSOLETE    entered.  If gdb is configured for the i960, but has not had its
// OBSOLETE    nindy target specified yet, this will loop prompting the user to do so.
// OBSOLETE 
// OBSOLETE    Unlike the loop provided by Intel, we actually let the user get out
// OBSOLETE    of this with a RETURN.  This is useful when e.g. simply examining
// OBSOLETE    an i960 object file on the host system.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE nindy_before_main_loop (void)
// OBSOLETE {
// OBSOLETE   char ttyname[100];
// OBSOLETE   char *p, *p2;
// OBSOLETE 
// OBSOLETE   while (target_stack->target_ops != &nindy_ops)	/* What is this crap??? */
// OBSOLETE     {				/* remote tty not specified yet */
// OBSOLETE       if (instream == stdin)
// OBSOLETE 	{
// OBSOLETE 	  printf_unfiltered ("\nAttach /dev/ttyNN -- specify NN, or \"quit\" to quit:  ");
// OBSOLETE 	  gdb_flush (gdb_stdout);
// OBSOLETE 	}
// OBSOLETE       fgets (ttyname, sizeof (ttyname) - 1, stdin);
// OBSOLETE 
// OBSOLETE       /* Strip leading and trailing whitespace */
// OBSOLETE       for (p = ttyname; isspace (*p); p++)
// OBSOLETE 	{
// OBSOLETE 	  ;
// OBSOLETE 	}
// OBSOLETE       if (*p == '\0')
// OBSOLETE 	{
// OBSOLETE 	  return;		/* User just hit spaces or return, wants out */
// OBSOLETE 	}
// OBSOLETE       for (p2 = p; !isspace (*p2) && (*p2 != '\0'); p2++)
// OBSOLETE 	{
// OBSOLETE 	  ;
// OBSOLETE 	}
// OBSOLETE       *p2 = '\0';
// OBSOLETE       if (STREQ ("quit", p))
// OBSOLETE 	{
// OBSOLETE 	  exit (1);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (catch_errors (nindy_open_stub, p, "", RETURN_MASK_ALL))
// OBSOLETE 	{
// OBSOLETE 	  /* Now that we have a tty open for talking to the remote machine,
// OBSOLETE 	     download the executable file if one was specified.  */
// OBSOLETE 	  if (exec_bfd)
// OBSOLETE 	    {
// OBSOLETE 	      catch_errors (load_stub, bfd_get_filename (exec_bfd), "",
// OBSOLETE 			    RETURN_MASK_ALL);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Define the target subroutine names */
// OBSOLETE 
// OBSOLETE struct target_ops nindy_ops;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_nindy_ops (void)
// OBSOLETE {
// OBSOLETE   nindy_ops.to_shortname = "nindy";
// OBSOLETE   "Remote serial target in i960 NINDY-specific protocol",
// OBSOLETE     nindy_ops.to_longname = "Use a remote i960 system running NINDY connected by a serial line.\n\
// OBSOLETE Specify the name of the device the serial line is connected to.\n\
// OBSOLETE The speed (baud rate), whether to use the old NINDY protocol,\n\
// OBSOLETE and whether to send a break on startup, are controlled by options\n\
// OBSOLETE specified when you started GDB.";
// OBSOLETE   nindy_ops.to_doc = "";
// OBSOLETE   nindy_ops.to_open = nindy_open;
// OBSOLETE   nindy_ops.to_close = nindy_close;
// OBSOLETE   nindy_ops.to_attach = 0;
// OBSOLETE   nindy_ops.to_post_attach = NULL;
// OBSOLETE   nindy_ops.to_require_attach = NULL;
// OBSOLETE   nindy_ops.to_detach = nindy_detach;
// OBSOLETE   nindy_ops.to_require_detach = NULL;
// OBSOLETE   nindy_ops.to_resume = nindy_resume;
// OBSOLETE   nindy_ops.to_wait = nindy_wait;
// OBSOLETE   nindy_ops.to_post_wait = NULL;
// OBSOLETE   nindy_ops.to_fetch_registers = nindy_fetch_registers;
// OBSOLETE   nindy_ops.to_store_registers = nindy_store_registers;
// OBSOLETE   nindy_ops.to_prepare_to_store = nindy_prepare_to_store;
// OBSOLETE   nindy_ops.to_xfer_memory = nindy_xfer_inferior_memory;
// OBSOLETE   nindy_ops.to_files_info = nindy_files_info;
// OBSOLETE   nindy_ops.to_insert_breakpoint = memory_insert_breakpoint;
// OBSOLETE   nindy_ops.to_remove_breakpoint = memory_remove_breakpoint;
// OBSOLETE   nindy_ops.to_terminal_init = 0;
// OBSOLETE   nindy_ops.to_terminal_inferior = 0;
// OBSOLETE   nindy_ops.to_terminal_ours_for_output = 0;
// OBSOLETE   nindy_ops.to_terminal_ours = 0;
// OBSOLETE   nindy_ops.to_terminal_info = 0;	/* Terminal crud */
// OBSOLETE   nindy_ops.to_kill = nindy_kill;
// OBSOLETE   nindy_ops.to_load = nindy_load;
// OBSOLETE   nindy_ops.to_lookup_symbol = 0;	/* lookup_symbol */
// OBSOLETE   nindy_ops.to_create_inferior = nindy_create_inferior;
// OBSOLETE   nindy_ops.to_post_startup_inferior = NULL;
// OBSOLETE   nindy_ops.to_acknowledge_created_inferior = NULL;
// OBSOLETE   nindy_ops.to_clone_and_follow_inferior = NULL;
// OBSOLETE   nindy_ops.to_post_follow_inferior_by_clone = NULL;
// OBSOLETE   nindy_ops.to_insert_fork_catchpoint = NULL;
// OBSOLETE   nindy_ops.to_remove_fork_catchpoint = NULL;
// OBSOLETE   nindy_ops.to_insert_vfork_catchpoint = NULL;
// OBSOLETE   nindy_ops.to_remove_vfork_catchpoint = NULL;
// OBSOLETE   nindy_ops.to_has_forked = NULL;
// OBSOLETE   nindy_ops.to_has_vforked = NULL;
// OBSOLETE   nindy_ops.to_can_follow_vfork_prior_to_exec = NULL;
// OBSOLETE   nindy_ops.to_post_follow_vfork = NULL;
// OBSOLETE   nindy_ops.to_insert_exec_catchpoint = NULL;
// OBSOLETE   nindy_ops.to_remove_exec_catchpoint = NULL;
// OBSOLETE   nindy_ops.to_has_execd = NULL;
// OBSOLETE   nindy_ops.to_reported_exec_events_per_exec_call = NULL;
// OBSOLETE   nindy_ops.to_has_exited = NULL;
// OBSOLETE   nindy_ops.to_mourn_inferior = nindy_mourn_inferior;
// OBSOLETE   nindy_ops.to_can_run = 0;	/* can_run */
// OBSOLETE   nindy_ops.to_notice_signals = 0;	/* notice_signals */
// OBSOLETE   nindy_ops.to_thread_alive = 0;	/* to_thread_alive */
// OBSOLETE   nindy_ops.to_stop = 0;	/* to_stop */
// OBSOLETE   nindy_ops.to_pid_to_exec_file = NULL;
// OBSOLETE   nindy_ops.to_stratum = process_stratum;
// OBSOLETE   nindy_ops.DONT_USE = 0;	/* next */
// OBSOLETE   nindy_ops.to_has_all_memory = 1;
// OBSOLETE   nindy_ops.to_has_memory = 1;
// OBSOLETE   nindy_ops.to_has_stack = 1;
// OBSOLETE   nindy_ops.to_has_registers = 1;
// OBSOLETE   nindy_ops.to_has_execution = 1;	/* all mem, mem, stack, regs, exec */
// OBSOLETE   nindy_ops.to_sections = 0;
// OBSOLETE   nindy_ops.to_sections_end = 0;	/* Section pointers */
// OBSOLETE   nindy_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_nindy (void)
// OBSOLETE {
// OBSOLETE   init_nindy_ops ();
// OBSOLETE   add_target (&nindy_ops);
// OBSOLETE   add_com ("reset", class_obscure, reset_command,
// OBSOLETE 	   "Send a 'break' to the remote target system.\n\
// OBSOLETE Only useful if the target has been equipped with a circuit\n\
// OBSOLETE to perform a hard reset when a break is detected.");
// OBSOLETE }
@


1.20
log
@Obsolete i960.
@
text
@@


1.20.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.20.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.19
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d1 762
a762 762
/* Memory-access and commands for remote NINDY process, for GDB.

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
   2000, 2001, 2002 Free Software Foundation, Inc.

   Contributed by Intel Corporation.  Modified from remote.c by Chris Benenati.

   GDB is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY.  No author or distributor accepts responsibility to anyone
   for the consequences of using it or for whether it serves any
   particular purpose or works at all, unless he says so in writing.
   Refer to the GDB General Public License for full details.

   Everyone is granted permission to copy, modify and redistribute GDB,
   but only under the conditions described in the GDB General Public
   License.  A copy of this license is supposed to have been given to you
   along with GDB so you can know your rights and responsibilities.  It
   should be in a file named COPYING.  Among other things, the copyright
   notice and this notice must be preserved on all copies.

   In other words, go ahead and share GDB, but don't try to stop
   anyone else from sharing it farther.  Help stamp out software hoarding!  */

/*
   Except for the data cache routines, this file bears little resemblence
   to remote.c.  A new (although similar) protocol has been specified, and
   portions of the code are entirely dependent on having an i80960 with a
   NINDY ROM monitor at the other end of the line.
 */

/*****************************************************************************
 *
 * REMOTE COMMUNICATION PROTOCOL BETWEEN GDB960 AND THE NINDY ROM MONITOR.
 *
 *
 * MODES OF OPERATION
 * ----- -- ---------
 *	
 * As far as NINDY is concerned, GDB is always in one of two modes: command
 * mode or passthrough mode.
 *
 * In command mode (the default) pre-defined packets containing requests
 * are sent by GDB to NINDY.  NINDY never talks except in reponse to a request.
 *
 * Once the the user program is started, GDB enters passthrough mode, to give
 * the user program access to the terminal.  GDB remains in this mode until
 * NINDY indicates that the program has stopped.
 *
 *
 * PASSTHROUGH MODE
 * ----------- ----
 *
 * GDB writes all input received from the keyboard directly to NINDY, and writes
 * all characters received from NINDY directly to the monitor.
 *
 * Keyboard input is neither buffered nor echoed to the monitor.
 *
 * GDB remains in passthrough mode until NINDY sends a single ^P character,
 * to indicate that the user process has stopped.
 *
 * Note:
 *	GDB assumes NINDY performs a 'flushreg' when the user program stops.
 *
 *
 * COMMAND MODE
 * ------- ----
 *
 * All info (except for message ack and nak) is transferred between gdb
 * and the remote processor in messages of the following format:
 *
 *		<info>#<checksum>
 *
 * where 
 *	#	is a literal character
 *
 *	<info>	ASCII information;  all numeric information is in the
 *		form of hex digits ('0'-'9' and lowercase 'a'-'f').
 *
 *	<checksum>
 *		is a pair of ASCII hex digits representing an 8-bit
 *		checksum formed by adding together each of the
 *		characters in <info>.
 *
 * The receiver of a message always sends a single character to the sender
 * to indicate that the checksum was good ('+') or bad ('-');  the sender
 * re-transmits the entire message over until a '+' is received.
 *
 * In response to a command NINDY always sends back either data or
 * a result code of the form "Xnn", where "nn" are hex digits and "X00"
 * means no errors.  (Exceptions: the "s" and "c" commands don't respond.)
 *
 * SEE THE HEADER OF THE FILE "gdb.c" IN THE NINDY MONITOR SOURCE CODE FOR A
 * FULL DESCRIPTION OF LEGAL COMMANDS.
 *
 * SEE THE FILE "stop.h" IN THE NINDY MONITOR SOURCE CODE FOR A LIST
 * OF STOP CODES.
 *
 ***************************************************************************/

#include "defs.h"
#include <signal.h>
#include <sys/types.h>
#include <setjmp.h>

#include "frame.h"
#include "inferior.h"
#include "bfd.h"
#include "symfile.h"
#include "target.h"
#include "gdbcore.h"
#include "command.h"
#include "floatformat.h"
#include "regcache.h"

#include <sys/file.h>
#include <ctype.h>
#include "serial.h"
#include "nindy-share/env.h"
#include "nindy-share/stop.h"
#include "remote-utils.h"

extern int unlink ();
extern char *getenv ();
extern char *mktemp ();

extern void generic_mourn_inferior ();

extern struct target_ops nindy_ops;
extern FILE *instream;

extern char ninStopWhy ();
extern int ninMemGet ();
extern int ninMemPut ();

int nindy_initial_brk;		/* nonzero if want to send an initial BREAK to nindy */
int nindy_old_protocol;		/* nonzero if want to use old protocol */
char *nindy_ttyname;		/* name of tty to talk to nindy on, or null */

#define DLE	'\020'		/* Character NINDY sends to indicate user program has
				   * halted.  */
#define TRUE	1
#define FALSE	0

/* From nindy-share/nindy.c.  */
extern struct serial *nindy_serial;

static int have_regs = 0;	/* 1 iff regs read since i960 last halted */
static int regs_changed = 0;	/* 1 iff regs were modified since last read */

extern char *exists ();

static void nindy_fetch_registers (int);

static void nindy_store_registers (int);

static char *savename;

static void
nindy_close (int quitting)
{
  if (nindy_serial != NULL)
    serial_close (nindy_serial);
  nindy_serial = NULL;

  if (savename)
    xfree (savename);
  savename = 0;
}

/* Open a connection to a remote debugger.   
   FIXME, there should be "set" commands for the options that are
   now specified with gdb command-line options (old_protocol,
   and initial_brk).  */
void
nindy_open (char *name,		/* "/dev/ttyXX", "ttyXX", or "XX": tty to be opened */
	    int from_tty)
{
  char baudrate[1024];

  if (!name)
    error_no_arg ("serial port device name");

  target_preopen (from_tty);

  nindy_close (0);

  have_regs = regs_changed = 0;

  /* Allow user to interrupt the following -- we could hang if there's
     no NINDY at the other end of the remote tty.  */
  immediate_quit++;
  /* If baud_rate is -1, then ninConnect will not recognize the baud rate
     and will deal with the situation in a (more or less) reasonable
     fashion.  */
  sprintf (baudrate, "%d", baud_rate);
  ninConnect (name, baudrate,
	      nindy_initial_brk, !from_tty, nindy_old_protocol);
  immediate_quit--;

  if (nindy_serial == NULL)
    {
      perror_with_name (name);
    }

  savename = savestring (name, strlen (name));
  push_target (&nindy_ops);

  target_fetch_registers (-1);

  init_thread_list ();
  init_wait_for_inferior ();
  clear_proceed_status ();
  normal_stop ();
}

/* User-initiated quit of nindy operations.  */

static void
nindy_detach (char *name, int from_tty)
{
  if (name)
    error ("Too many arguments");
  pop_target ();
}

static void
nindy_files_info (void)
{
  /* FIXME: this lies about the baud rate if we autobauded.  */
  printf_unfiltered ("\tAttached to %s at %d bits per second%s%s.\n", savename,
		     baud_rate,
		     nindy_old_protocol ? " in old protocol" : "",
		     nindy_initial_brk ? " with initial break" : "");
}

/* Return the number of characters in the buffer BUF before
   the first DLE character.  N is maximum number of characters to
   consider.  */

static
int
non_dle (char *buf, int n)
{
  int i;

  for (i = 0; i < n; i++)
    {
      if (buf[i] == DLE)
	{
	  break;
	}
    }
  return i;
}

/* Tell the remote machine to resume.  */

void
nindy_resume (ptid_t ptid, int step, enum target_signal siggnal)
{
  if (siggnal != TARGET_SIGNAL_0 && siggnal != stop_signal)
    warning ("Can't send signals to remote NINDY targets.");

  if (regs_changed)
    {
      nindy_store_registers (-1);
      regs_changed = 0;
    }
  have_regs = 0;
  ninGo (step);
}

/* FIXME, we can probably use the normal terminal_inferior stuff here.
   We have to do terminal_inferior and then set up the passthrough
   settings initially.  Thereafter, terminal_ours and terminal_inferior
   will automatically swap the settings around for us.  */

struct clean_up_tty_args
{
  serial_ttystate state;
  struct serial *serial;
};
static struct clean_up_tty_args tty_args;

static void
clean_up_tty (PTR ptrarg)
{
  struct clean_up_tty_args *args = (struct clean_up_tty_args *) ptrarg;
  serial_set_tty_state (args->serial, args->state);
  xfree (args->state);
  warning ("\n\nYou may need to reset the 80960 and/or reload your program.\n");
}

/* Recover from ^Z or ^C while remote process is running */
static void (*old_ctrlc) ();
#ifdef SIGTSTP
static void (*old_ctrlz) ();
#endif

static void
clean_up_int (void)
{
  serial_set_tty_state (tty_args.serial, tty_args.state);
  xfree (tty_args.state);

  signal (SIGINT, old_ctrlc);
#ifdef SIGTSTP
  signal (SIGTSTP, old_ctrlz);
#endif
  error ("\n\nYou may need to reset the 80960 and/or reload your program.\n");
}

/* Wait until the remote machine stops. While waiting, operate in passthrough
 * mode; i.e., pass everything NINDY sends to gdb_stdout, and everything from
 * stdin to NINDY.
 *
 * Return to caller, storing status in 'status' just as `wait' would.
 */

static ptid_t
nindy_wait (ptid_t ptid, struct target_waitstatus *status)
{
  fd_set fds;
  int c;
  char buf[2];
  int i, n;
  unsigned char stop_exit;
  unsigned char stop_code;
  struct cleanup *old_cleanups;
  long ip_value, fp_value, sp_value;	/* Reg values from stop */

  status->kind = TARGET_WAITKIND_EXITED;
  status->value.integer = 0;

  /* OPERATE IN PASSTHROUGH MODE UNTIL NINDY SENDS A DLE CHARACTER */

  /* Save current tty attributes, and restore them when done.  */
  tty_args.serial = serial_fdopen (0);
  tty_args.state = serial_get_tty_state (tty_args.serial);
  old_ctrlc = signal (SIGINT, clean_up_int);
#ifdef SIGTSTP
  old_ctrlz = signal (SIGTSTP, clean_up_int);
#endif

  old_cleanups = make_cleanup (clean_up_tty, &tty_args);

  /* Pass input from keyboard to NINDY as it arrives.  NINDY will interpret
     <CR> and perform echo.  */
  /* This used to set CBREAK and clear ECHO and CRMOD.  I hope this is close
     enough.  */
  serial_raw (tty_args.serial);

  while (1)
    {
      /* Input on remote */
      c = serial_readchar (nindy_serial, -1);
      if (c == SERIAL_ERROR)
	{
	  error ("Cannot read from serial line");
	}
      else if (c == 0x1b)	/* ESC */
	{
	  c = serial_readchar (nindy_serial, -1);
	  c &= ~0x40;
	}
      else if (c != 0x10)	/* DLE */
	/* Write out any characters preceding DLE */
	{
	  buf[0] = (char) c;
	  write (1, buf, 1);
	}
      else
	{
	  stop_exit = ninStopWhy (&stop_code,
				  &ip_value, &fp_value, &sp_value);
	  if (!stop_exit && (stop_code == STOP_SRQ))
	    {
	      immediate_quit++;
	      ninSrq ();
	      immediate_quit--;
	    }
	  else
	    {
	      /* Get out of loop */
	      supply_register (IP_REGNUM,
			       (char *) &ip_value);
	      supply_register (FP_REGNUM,
			       (char *) &fp_value);
	      supply_register (SP_REGNUM,
			       (char *) &sp_value);
	      break;
	    }
	}
    }

  serial_set_tty_state (tty_args.serial, tty_args.state);
  xfree (tty_args.state);
  discard_cleanups (old_cleanups);

  if (stop_exit)
    {
      status->kind = TARGET_WAITKIND_EXITED;
      status->value.integer = stop_code;
    }
  else
    {
      /* nindy has some special stop code need to be handled */
      if (stop_code == STOP_GDB_BPT)
	stop_code = TRACE_STEP;
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = i960_fault_to_signal (stop_code);
    }
  return inferior_ptid;
}

/* Read the remote registers into the block REGS.  */

/* This is the block that ninRegsGet and ninRegsPut handles.  */
struct nindy_regs
{
  char local_regs[16 * 4];
  char global_regs[16 * 4];
  char pcw_acw[2 * 4];
  char ip[4];
  char tcw[4];
  char fp_as_double[4 * 8];
};

static void
nindy_fetch_registers (int regno)
{
  struct nindy_regs nindy_regs;
  int regnum;

  immediate_quit++;
  ninRegsGet ((char *) &nindy_regs);
  immediate_quit--;

  memcpy (&registers[REGISTER_BYTE (R0_REGNUM)], nindy_regs.local_regs, 16 * 4);
  memcpy (&registers[REGISTER_BYTE (G0_REGNUM)], nindy_regs.global_regs, 16 * 4);
  memcpy (&registers[REGISTER_BYTE (PCW_REGNUM)], nindy_regs.pcw_acw, 2 * 4);
  memcpy (&registers[REGISTER_BYTE (IP_REGNUM)], nindy_regs.ip, 1 * 4);
  memcpy (&registers[REGISTER_BYTE (TCW_REGNUM)], nindy_regs.tcw, 1 * 4);
  memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)], nindy_regs.fp_as_double, 4 * 8);

  registers_fetched ();
}

static void
nindy_prepare_to_store (void)
{
  /* Fetch all regs if they aren't already here.  */
  read_register_bytes (0, NULL, REGISTER_BYTES);
}

static void
nindy_store_registers (int regno)
{
  struct nindy_regs nindy_regs;
  int regnum;

  memcpy (nindy_regs.local_regs, &registers[REGISTER_BYTE (R0_REGNUM)], 16 * 4);
  memcpy (nindy_regs.global_regs, &registers[REGISTER_BYTE (G0_REGNUM)], 16 * 4);
  memcpy (nindy_regs.pcw_acw, &registers[REGISTER_BYTE (PCW_REGNUM)], 2 * 4);
  memcpy (nindy_regs.ip, &registers[REGISTER_BYTE (IP_REGNUM)], 1 * 4);
  memcpy (nindy_regs.tcw, &registers[REGISTER_BYTE (TCW_REGNUM)], 1 * 4);
  memcpy (nindy_regs.fp_as_double, &registers[REGISTER_BYTE (FP0_REGNUM)], 8 * 4);

  immediate_quit++;
  ninRegsPut ((char *) &nindy_regs);
  immediate_quit--;
}

/* Copy LEN bytes to or from inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR.   Copy to inferior if
   SHOULD_WRITE is nonzero.  Returns the length copied.  TARGET is
   unused.  */

int
nindy_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len,
			    int should_write, struct mem_attrib *attrib,
			    struct target_ops *target)
{
  int res;

  if (len <= 0)
    return 0;

  if (should_write)
    res = ninMemPut (memaddr, myaddr, len);
  else
    res = ninMemGet (memaddr, myaddr, len);

  return res;
}

static void
nindy_create_inferior (char *execfile, char *args, char **env)
{
  int entry_pt;
  int pid;

  if (args && *args)
    error ("Can't pass arguments to remote NINDY process");

  if (execfile == 0 || exec_bfd == 0)
    error ("No executable file specified");

  entry_pt = (int) bfd_get_start_address (exec_bfd);

  pid = 42;

  /* The "process" (board) is already stopped awaiting our commands, and
     the program is already downloaded.  We just set its PC and go.  */

  inferior_ptid = pid_to_ptid (pid);	/* Needed for wait_for_inferior below */

  clear_proceed_status ();

  /* Tell wait_for_inferior that we've started a new process.  */
  init_wait_for_inferior ();

  /* Set up the "saved terminal modes" of the inferior
     based on what modes we are starting it with.  */
  target_terminal_init ();

  /* Install inferior's terminal modes.  */
  target_terminal_inferior ();

  /* insert_step_breakpoint ();  FIXME, do we need this?  */
  /* Let 'er rip... */
  proceed ((CORE_ADDR) entry_pt, TARGET_SIGNAL_DEFAULT, 0);
}

static void
reset_command (char *args, int from_tty)
{
  if (nindy_serial == NULL)
    {
      error ("No target system to reset -- use 'target nindy' command.");
    }
  if (query ("Really reset the target system?", 0, 0))
    {
      serial_send_break (nindy_serial);
      tty_flush (nindy_serial);
    }
}

void
nindy_kill (char *args, int from_tty)
{
  return;			/* Ignore attempts to kill target system */
}

/* Clean up when a program exits.

   The program actually lives on in the remote processor's RAM, and may be
   run again without a download.  Don't leave it full of breakpoint
   instructions.  */

void
nindy_mourn_inferior (void)
{
  remove_breakpoints ();
  unpush_target (&nindy_ops);
  generic_mourn_inferior ();	/* Do all the proper things now */
}

/* Pass the args the way catch_errors wants them.  */
static int
nindy_open_stub (char *arg)
{
  nindy_open (arg, 1);
  return 1;
}

static void
nindy_load (char *filename, int from_tty)
{
  asection *s;
  /* Can't do unix style forking on a VMS system, so we'll use bfd to do
     all the work for us
   */

  bfd *file = bfd_openr (filename, 0);
  if (!file)
    {
      perror_with_name (filename);
      return;
    }

  if (!bfd_check_format (file, bfd_object))
    {
      error ("can't prove it's an object file\n");
      return;
    }

  for (s = file->sections; s; s = s->next)
    {
      if (s->flags & SEC_LOAD)
	{
	  char *buffer = xmalloc (s->_raw_size);
	  bfd_get_section_contents (file, s, buffer, 0, s->_raw_size);
	  printf ("Loading section %s, size %x vma %x\n",
		  s->name,
		  s->_raw_size,
		  s->vma);
	  ninMemPut (s->vma, buffer, s->_raw_size);
	  xfree (buffer);
	}
    }
  bfd_close (file);
}

static int
load_stub (char *arg)
{
  target_load (arg, 1);
  return 1;
}

/* This routine is run as a hook, just before the main command loop is
   entered.  If gdb is configured for the i960, but has not had its
   nindy target specified yet, this will loop prompting the user to do so.

   Unlike the loop provided by Intel, we actually let the user get out
   of this with a RETURN.  This is useful when e.g. simply examining
   an i960 object file on the host system.  */

void
nindy_before_main_loop (void)
{
  char ttyname[100];
  char *p, *p2;

  while (target_stack->target_ops != &nindy_ops)	/* What is this crap??? */
    {				/* remote tty not specified yet */
      if (instream == stdin)
	{
	  printf_unfiltered ("\nAttach /dev/ttyNN -- specify NN, or \"quit\" to quit:  ");
	  gdb_flush (gdb_stdout);
	}
      fgets (ttyname, sizeof (ttyname) - 1, stdin);

      /* Strip leading and trailing whitespace */
      for (p = ttyname; isspace (*p); p++)
	{
	  ;
	}
      if (*p == '\0')
	{
	  return;		/* User just hit spaces or return, wants out */
	}
      for (p2 = p; !isspace (*p2) && (*p2 != '\0'); p2++)
	{
	  ;
	}
      *p2 = '\0';
      if (STREQ ("quit", p))
	{
	  exit (1);
	}

      if (catch_errors (nindy_open_stub, p, "", RETURN_MASK_ALL))
	{
	  /* Now that we have a tty open for talking to the remote machine,
	     download the executable file if one was specified.  */
	  if (exec_bfd)
	    {
	      catch_errors (load_stub, bfd_get_filename (exec_bfd), "",
			    RETURN_MASK_ALL);
	    }
	}
    }
}

/* Define the target subroutine names */

struct target_ops nindy_ops;

static void
init_nindy_ops (void)
{
  nindy_ops.to_shortname = "nindy";
  "Remote serial target in i960 NINDY-specific protocol",
    nindy_ops.to_longname = "Use a remote i960 system running NINDY connected by a serial line.\n\
Specify the name of the device the serial line is connected to.\n\
The speed (baud rate), whether to use the old NINDY protocol,\n\
and whether to send a break on startup, are controlled by options\n\
specified when you started GDB.";
  nindy_ops.to_doc = "";
  nindy_ops.to_open = nindy_open;
  nindy_ops.to_close = nindy_close;
  nindy_ops.to_attach = 0;
  nindy_ops.to_post_attach = NULL;
  nindy_ops.to_require_attach = NULL;
  nindy_ops.to_detach = nindy_detach;
  nindy_ops.to_require_detach = NULL;
  nindy_ops.to_resume = nindy_resume;
  nindy_ops.to_wait = nindy_wait;
  nindy_ops.to_post_wait = NULL;
  nindy_ops.to_fetch_registers = nindy_fetch_registers;
  nindy_ops.to_store_registers = nindy_store_registers;
  nindy_ops.to_prepare_to_store = nindy_prepare_to_store;
  nindy_ops.to_xfer_memory = nindy_xfer_inferior_memory;
  nindy_ops.to_files_info = nindy_files_info;
  nindy_ops.to_insert_breakpoint = memory_insert_breakpoint;
  nindy_ops.to_remove_breakpoint = memory_remove_breakpoint;
  nindy_ops.to_terminal_init = 0;
  nindy_ops.to_terminal_inferior = 0;
  nindy_ops.to_terminal_ours_for_output = 0;
  nindy_ops.to_terminal_ours = 0;
  nindy_ops.to_terminal_info = 0;	/* Terminal crud */
  nindy_ops.to_kill = nindy_kill;
  nindy_ops.to_load = nindy_load;
  nindy_ops.to_lookup_symbol = 0;	/* lookup_symbol */
  nindy_ops.to_create_inferior = nindy_create_inferior;
  nindy_ops.to_post_startup_inferior = NULL;
  nindy_ops.to_acknowledge_created_inferior = NULL;
  nindy_ops.to_clone_and_follow_inferior = NULL;
  nindy_ops.to_post_follow_inferior_by_clone = NULL;
  nindy_ops.to_insert_fork_catchpoint = NULL;
  nindy_ops.to_remove_fork_catchpoint = NULL;
  nindy_ops.to_insert_vfork_catchpoint = NULL;
  nindy_ops.to_remove_vfork_catchpoint = NULL;
  nindy_ops.to_has_forked = NULL;
  nindy_ops.to_has_vforked = NULL;
  nindy_ops.to_can_follow_vfork_prior_to_exec = NULL;
  nindy_ops.to_post_follow_vfork = NULL;
  nindy_ops.to_insert_exec_catchpoint = NULL;
  nindy_ops.to_remove_exec_catchpoint = NULL;
  nindy_ops.to_has_execd = NULL;
  nindy_ops.to_reported_exec_events_per_exec_call = NULL;
  nindy_ops.to_has_exited = NULL;
  nindy_ops.to_mourn_inferior = nindy_mourn_inferior;
  nindy_ops.to_can_run = 0;	/* can_run */
  nindy_ops.to_notice_signals = 0;	/* notice_signals */
  nindy_ops.to_thread_alive = 0;	/* to_thread_alive */
  nindy_ops.to_stop = 0;	/* to_stop */
  nindy_ops.to_pid_to_exec_file = NULL;
  nindy_ops.to_stratum = process_stratum;
  nindy_ops.DONT_USE = 0;	/* next */
  nindy_ops.to_has_all_memory = 1;
  nindy_ops.to_has_memory = 1;
  nindy_ops.to_has_stack = 1;
  nindy_ops.to_has_registers = 1;
  nindy_ops.to_has_execution = 1;	/* all mem, mem, stack, regs, exec */
  nindy_ops.to_sections = 0;
  nindy_ops.to_sections_end = 0;	/* Section pointers */
  nindy_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
}

void
_initialize_nindy (void)
{
  init_nindy_ops ();
  add_target (&nindy_ops);
  add_com ("reset", class_obscure, reset_command,
	   "Send a 'break' to the remote target system.\n\
Only useful if the target has been equipped with a circuit\n\
to perform a hard reset when a break is detected.");
}
@


1.19.8.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1 762
a762 762
// OBSOLETE /* Memory-access and commands for remote NINDY process, for GDB.
// OBSOLETE 
// OBSOLETE    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
// OBSOLETE    2000, 2001, 2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    Contributed by Intel Corporation.  Modified from remote.c by Chris Benenati.
// OBSOLETE 
// OBSOLETE    GDB is distributed in the hope that it will be useful, but WITHOUT ANY
// OBSOLETE    WARRANTY.  No author or distributor accepts responsibility to anyone
// OBSOLETE    for the consequences of using it or for whether it serves any
// OBSOLETE    particular purpose or works at all, unless he says so in writing.
// OBSOLETE    Refer to the GDB General Public License for full details.
// OBSOLETE 
// OBSOLETE    Everyone is granted permission to copy, modify and redistribute GDB,
// OBSOLETE    but only under the conditions described in the GDB General Public
// OBSOLETE    License.  A copy of this license is supposed to have been given to you
// OBSOLETE    along with GDB so you can know your rights and responsibilities.  It
// OBSOLETE    should be in a file named COPYING.  Among other things, the copyright
// OBSOLETE    notice and this notice must be preserved on all copies.
// OBSOLETE 
// OBSOLETE    In other words, go ahead and share GDB, but don't try to stop
// OBSOLETE    anyone else from sharing it farther.  Help stamp out software hoarding!  */
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE    Except for the data cache routines, this file bears little resemblence
// OBSOLETE    to remote.c.  A new (although similar) protocol has been specified, and
// OBSOLETE    portions of the code are entirely dependent on having an i80960 with a
// OBSOLETE    NINDY ROM monitor at the other end of the line.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /*****************************************************************************
// OBSOLETE  *
// OBSOLETE  * REMOTE COMMUNICATION PROTOCOL BETWEEN GDB960 AND THE NINDY ROM MONITOR.
// OBSOLETE  *
// OBSOLETE  *
// OBSOLETE  * MODES OF OPERATION
// OBSOLETE  * ----- -- ---------
// OBSOLETE  *	
// OBSOLETE  * As far as NINDY is concerned, GDB is always in one of two modes: command
// OBSOLETE  * mode or passthrough mode.
// OBSOLETE  *
// OBSOLETE  * In command mode (the default) pre-defined packets containing requests
// OBSOLETE  * are sent by GDB to NINDY.  NINDY never talks except in reponse to a request.
// OBSOLETE  *
// OBSOLETE  * Once the the user program is started, GDB enters passthrough mode, to give
// OBSOLETE  * the user program access to the terminal.  GDB remains in this mode until
// OBSOLETE  * NINDY indicates that the program has stopped.
// OBSOLETE  *
// OBSOLETE  *
// OBSOLETE  * PASSTHROUGH MODE
// OBSOLETE  * ----------- ----
// OBSOLETE  *
// OBSOLETE  * GDB writes all input received from the keyboard directly to NINDY, and writes
// OBSOLETE  * all characters received from NINDY directly to the monitor.
// OBSOLETE  *
// OBSOLETE  * Keyboard input is neither buffered nor echoed to the monitor.
// OBSOLETE  *
// OBSOLETE  * GDB remains in passthrough mode until NINDY sends a single ^P character,
// OBSOLETE  * to indicate that the user process has stopped.
// OBSOLETE  *
// OBSOLETE  * Note:
// OBSOLETE  *	GDB assumes NINDY performs a 'flushreg' when the user program stops.
// OBSOLETE  *
// OBSOLETE  *
// OBSOLETE  * COMMAND MODE
// OBSOLETE  * ------- ----
// OBSOLETE  *
// OBSOLETE  * All info (except for message ack and nak) is transferred between gdb
// OBSOLETE  * and the remote processor in messages of the following format:
// OBSOLETE  *
// OBSOLETE  *		<info>#<checksum>
// OBSOLETE  *
// OBSOLETE  * where 
// OBSOLETE  *	#	is a literal character
// OBSOLETE  *
// OBSOLETE  *	<info>	ASCII information;  all numeric information is in the
// OBSOLETE  *		form of hex digits ('0'-'9' and lowercase 'a'-'f').
// OBSOLETE  *
// OBSOLETE  *	<checksum>
// OBSOLETE  *		is a pair of ASCII hex digits representing an 8-bit
// OBSOLETE  *		checksum formed by adding together each of the
// OBSOLETE  *		characters in <info>.
// OBSOLETE  *
// OBSOLETE  * The receiver of a message always sends a single character to the sender
// OBSOLETE  * to indicate that the checksum was good ('+') or bad ('-');  the sender
// OBSOLETE  * re-transmits the entire message over until a '+' is received.
// OBSOLETE  *
// OBSOLETE  * In response to a command NINDY always sends back either data or
// OBSOLETE  * a result code of the form "Xnn", where "nn" are hex digits and "X00"
// OBSOLETE  * means no errors.  (Exceptions: the "s" and "c" commands don't respond.)
// OBSOLETE  *
// OBSOLETE  * SEE THE HEADER OF THE FILE "gdb.c" IN THE NINDY MONITOR SOURCE CODE FOR A
// OBSOLETE  * FULL DESCRIPTION OF LEGAL COMMANDS.
// OBSOLETE  *
// OBSOLETE  * SEE THE FILE "stop.h" IN THE NINDY MONITOR SOURCE CODE FOR A LIST
// OBSOLETE  * OF STOP CODES.
// OBSOLETE  *
// OBSOLETE  ***************************************************************************/
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include <signal.h>
// OBSOLETE #include <sys/types.h>
// OBSOLETE #include <setjmp.h>
// OBSOLETE 
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "bfd.h"
// OBSOLETE #include "symfile.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "command.h"
// OBSOLETE #include "floatformat.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #include <sys/file.h>
// OBSOLETE #include <ctype.h>
// OBSOLETE #include "serial.h"
// OBSOLETE #include "nindy-share/env.h"
// OBSOLETE #include "nindy-share/stop.h"
// OBSOLETE #include "remote-utils.h"
// OBSOLETE 
// OBSOLETE extern int unlink ();
// OBSOLETE extern char *getenv ();
// OBSOLETE extern char *mktemp ();
// OBSOLETE 
// OBSOLETE extern void generic_mourn_inferior ();
// OBSOLETE 
// OBSOLETE extern struct target_ops nindy_ops;
// OBSOLETE extern FILE *instream;
// OBSOLETE 
// OBSOLETE extern char ninStopWhy ();
// OBSOLETE extern int ninMemGet ();
// OBSOLETE extern int ninMemPut ();
// OBSOLETE 
// OBSOLETE int nindy_initial_brk;		/* nonzero if want to send an initial BREAK to nindy */
// OBSOLETE int nindy_old_protocol;		/* nonzero if want to use old protocol */
// OBSOLETE char *nindy_ttyname;		/* name of tty to talk to nindy on, or null */
// OBSOLETE 
// OBSOLETE #define DLE	'\020'		/* Character NINDY sends to indicate user program has
// OBSOLETE 				   * halted.  */
// OBSOLETE #define TRUE	1
// OBSOLETE #define FALSE	0
// OBSOLETE 
// OBSOLETE /* From nindy-share/nindy.c.  */
// OBSOLETE extern struct serial *nindy_serial;
// OBSOLETE 
// OBSOLETE static int have_regs = 0;	/* 1 iff regs read since i960 last halted */
// OBSOLETE static int regs_changed = 0;	/* 1 iff regs were modified since last read */
// OBSOLETE 
// OBSOLETE extern char *exists ();
// OBSOLETE 
// OBSOLETE static void nindy_fetch_registers (int);
// OBSOLETE 
// OBSOLETE static void nindy_store_registers (int);
// OBSOLETE 
// OBSOLETE static char *savename;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_close (int quitting)
// OBSOLETE {
// OBSOLETE   if (nindy_serial != NULL)
// OBSOLETE     serial_close (nindy_serial);
// OBSOLETE   nindy_serial = NULL;
// OBSOLETE 
// OBSOLETE   if (savename)
// OBSOLETE     xfree (savename);
// OBSOLETE   savename = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Open a connection to a remote debugger.   
// OBSOLETE    FIXME, there should be "set" commands for the options that are
// OBSOLETE    now specified with gdb command-line options (old_protocol,
// OBSOLETE    and initial_brk).  */
// OBSOLETE void
// OBSOLETE nindy_open (char *name,		/* "/dev/ttyXX", "ttyXX", or "XX": tty to be opened */
// OBSOLETE 	    int from_tty)
// OBSOLETE {
// OBSOLETE   char baudrate[1024];
// OBSOLETE 
// OBSOLETE   if (!name)
// OBSOLETE     error_no_arg ("serial port device name");
// OBSOLETE 
// OBSOLETE   target_preopen (from_tty);
// OBSOLETE 
// OBSOLETE   nindy_close (0);
// OBSOLETE 
// OBSOLETE   have_regs = regs_changed = 0;
// OBSOLETE 
// OBSOLETE   /* Allow user to interrupt the following -- we could hang if there's
// OBSOLETE      no NINDY at the other end of the remote tty.  */
// OBSOLETE   immediate_quit++;
// OBSOLETE   /* If baud_rate is -1, then ninConnect will not recognize the baud rate
// OBSOLETE      and will deal with the situation in a (more or less) reasonable
// OBSOLETE      fashion.  */
// OBSOLETE   sprintf (baudrate, "%d", baud_rate);
// OBSOLETE   ninConnect (name, baudrate,
// OBSOLETE 	      nindy_initial_brk, !from_tty, nindy_old_protocol);
// OBSOLETE   immediate_quit--;
// OBSOLETE 
// OBSOLETE   if (nindy_serial == NULL)
// OBSOLETE     {
// OBSOLETE       perror_with_name (name);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   savename = savestring (name, strlen (name));
// OBSOLETE   push_target (&nindy_ops);
// OBSOLETE 
// OBSOLETE   target_fetch_registers (-1);
// OBSOLETE 
// OBSOLETE   init_thread_list ();
// OBSOLETE   init_wait_for_inferior ();
// OBSOLETE   clear_proceed_status ();
// OBSOLETE   normal_stop ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* User-initiated quit of nindy operations.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_detach (char *name, int from_tty)
// OBSOLETE {
// OBSOLETE   if (name)
// OBSOLETE     error ("Too many arguments");
// OBSOLETE   pop_target ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_files_info (void)
// OBSOLETE {
// OBSOLETE   /* FIXME: this lies about the baud rate if we autobauded.  */
// OBSOLETE   printf_unfiltered ("\tAttached to %s at %d bits per second%s%s.\n", savename,
// OBSOLETE 		     baud_rate,
// OBSOLETE 		     nindy_old_protocol ? " in old protocol" : "",
// OBSOLETE 		     nindy_initial_brk ? " with initial break" : "");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the number of characters in the buffer BUF before
// OBSOLETE    the first DLE character.  N is maximum number of characters to
// OBSOLETE    consider.  */
// OBSOLETE 
// OBSOLETE static
// OBSOLETE int
// OBSOLETE non_dle (char *buf, int n)
// OBSOLETE {
// OBSOLETE   int i;
// OBSOLETE 
// OBSOLETE   for (i = 0; i < n; i++)
// OBSOLETE     {
// OBSOLETE       if (buf[i] == DLE)
// OBSOLETE 	{
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   return i;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Tell the remote machine to resume.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE nindy_resume (ptid_t ptid, int step, enum target_signal siggnal)
// OBSOLETE {
// OBSOLETE   if (siggnal != TARGET_SIGNAL_0 && siggnal != stop_signal)
// OBSOLETE     warning ("Can't send signals to remote NINDY targets.");
// OBSOLETE 
// OBSOLETE   if (regs_changed)
// OBSOLETE     {
// OBSOLETE       nindy_store_registers (-1);
// OBSOLETE       regs_changed = 0;
// OBSOLETE     }
// OBSOLETE   have_regs = 0;
// OBSOLETE   ninGo (step);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* FIXME, we can probably use the normal terminal_inferior stuff here.
// OBSOLETE    We have to do terminal_inferior and then set up the passthrough
// OBSOLETE    settings initially.  Thereafter, terminal_ours and terminal_inferior
// OBSOLETE    will automatically swap the settings around for us.  */
// OBSOLETE 
// OBSOLETE struct clean_up_tty_args
// OBSOLETE {
// OBSOLETE   serial_ttystate state;
// OBSOLETE   struct serial *serial;
// OBSOLETE };
// OBSOLETE static struct clean_up_tty_args tty_args;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE clean_up_tty (PTR ptrarg)
// OBSOLETE {
// OBSOLETE   struct clean_up_tty_args *args = (struct clean_up_tty_args *) ptrarg;
// OBSOLETE   serial_set_tty_state (args->serial, args->state);
// OBSOLETE   xfree (args->state);
// OBSOLETE   warning ("\n\nYou may need to reset the 80960 and/or reload your program.\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Recover from ^Z or ^C while remote process is running */
// OBSOLETE static void (*old_ctrlc) ();
// OBSOLETE #ifdef SIGTSTP
// OBSOLETE static void (*old_ctrlz) ();
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE clean_up_int (void)
// OBSOLETE {
// OBSOLETE   serial_set_tty_state (tty_args.serial, tty_args.state);
// OBSOLETE   xfree (tty_args.state);
// OBSOLETE 
// OBSOLETE   signal (SIGINT, old_ctrlc);
// OBSOLETE #ifdef SIGTSTP
// OBSOLETE   signal (SIGTSTP, old_ctrlz);
// OBSOLETE #endif
// OBSOLETE   error ("\n\nYou may need to reset the 80960 and/or reload your program.\n");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Wait until the remote machine stops. While waiting, operate in passthrough
// OBSOLETE  * mode; i.e., pass everything NINDY sends to gdb_stdout, and everything from
// OBSOLETE  * stdin to NINDY.
// OBSOLETE  *
// OBSOLETE  * Return to caller, storing status in 'status' just as `wait' would.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static ptid_t
// OBSOLETE nindy_wait (ptid_t ptid, struct target_waitstatus *status)
// OBSOLETE {
// OBSOLETE   fd_set fds;
// OBSOLETE   int c;
// OBSOLETE   char buf[2];
// OBSOLETE   int i, n;
// OBSOLETE   unsigned char stop_exit;
// OBSOLETE   unsigned char stop_code;
// OBSOLETE   struct cleanup *old_cleanups;
// OBSOLETE   long ip_value, fp_value, sp_value;	/* Reg values from stop */
// OBSOLETE 
// OBSOLETE   status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE   status->value.integer = 0;
// OBSOLETE 
// OBSOLETE   /* OPERATE IN PASSTHROUGH MODE UNTIL NINDY SENDS A DLE CHARACTER */
// OBSOLETE 
// OBSOLETE   /* Save current tty attributes, and restore them when done.  */
// OBSOLETE   tty_args.serial = serial_fdopen (0);
// OBSOLETE   tty_args.state = serial_get_tty_state (tty_args.serial);
// OBSOLETE   old_ctrlc = signal (SIGINT, clean_up_int);
// OBSOLETE #ifdef SIGTSTP
// OBSOLETE   old_ctrlz = signal (SIGTSTP, clean_up_int);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   old_cleanups = make_cleanup (clean_up_tty, &tty_args);
// OBSOLETE 
// OBSOLETE   /* Pass input from keyboard to NINDY as it arrives.  NINDY will interpret
// OBSOLETE      <CR> and perform echo.  */
// OBSOLETE   /* This used to set CBREAK and clear ECHO and CRMOD.  I hope this is close
// OBSOLETE      enough.  */
// OBSOLETE   serial_raw (tty_args.serial);
// OBSOLETE 
// OBSOLETE   while (1)
// OBSOLETE     {
// OBSOLETE       /* Input on remote */
// OBSOLETE       c = serial_readchar (nindy_serial, -1);
// OBSOLETE       if (c == SERIAL_ERROR)
// OBSOLETE 	{
// OBSOLETE 	  error ("Cannot read from serial line");
// OBSOLETE 	}
// OBSOLETE       else if (c == 0x1b)	/* ESC */
// OBSOLETE 	{
// OBSOLETE 	  c = serial_readchar (nindy_serial, -1);
// OBSOLETE 	  c &= ~0x40;
// OBSOLETE 	}
// OBSOLETE       else if (c != 0x10)	/* DLE */
// OBSOLETE 	/* Write out any characters preceding DLE */
// OBSOLETE 	{
// OBSOLETE 	  buf[0] = (char) c;
// OBSOLETE 	  write (1, buf, 1);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  stop_exit = ninStopWhy (&stop_code,
// OBSOLETE 				  &ip_value, &fp_value, &sp_value);
// OBSOLETE 	  if (!stop_exit && (stop_code == STOP_SRQ))
// OBSOLETE 	    {
// OBSOLETE 	      immediate_quit++;
// OBSOLETE 	      ninSrq ();
// OBSOLETE 	      immediate_quit--;
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    {
// OBSOLETE 	      /* Get out of loop */
// OBSOLETE 	      supply_register (IP_REGNUM,
// OBSOLETE 			       (char *) &ip_value);
// OBSOLETE 	      supply_register (FP_REGNUM,
// OBSOLETE 			       (char *) &fp_value);
// OBSOLETE 	      supply_register (SP_REGNUM,
// OBSOLETE 			       (char *) &sp_value);
// OBSOLETE 	      break;
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   serial_set_tty_state (tty_args.serial, tty_args.state);
// OBSOLETE   xfree (tty_args.state);
// OBSOLETE   discard_cleanups (old_cleanups);
// OBSOLETE 
// OBSOLETE   if (stop_exit)
// OBSOLETE     {
// OBSOLETE       status->kind = TARGET_WAITKIND_EXITED;
// OBSOLETE       status->value.integer = stop_code;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* nindy has some special stop code need to be handled */
// OBSOLETE       if (stop_code == STOP_GDB_BPT)
// OBSOLETE 	stop_code = TRACE_STEP;
// OBSOLETE       status->kind = TARGET_WAITKIND_STOPPED;
// OBSOLETE       status->value.sig = i960_fault_to_signal (stop_code);
// OBSOLETE     }
// OBSOLETE   return inferior_ptid;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read the remote registers into the block REGS.  */
// OBSOLETE 
// OBSOLETE /* This is the block that ninRegsGet and ninRegsPut handles.  */
// OBSOLETE struct nindy_regs
// OBSOLETE {
// OBSOLETE   char local_regs[16 * 4];
// OBSOLETE   char global_regs[16 * 4];
// OBSOLETE   char pcw_acw[2 * 4];
// OBSOLETE   char ip[4];
// OBSOLETE   char tcw[4];
// OBSOLETE   char fp_as_double[4 * 8];
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_fetch_registers (int regno)
// OBSOLETE {
// OBSOLETE   struct nindy_regs nindy_regs;
// OBSOLETE   int regnum;
// OBSOLETE 
// OBSOLETE   immediate_quit++;
// OBSOLETE   ninRegsGet ((char *) &nindy_regs);
// OBSOLETE   immediate_quit--;
// OBSOLETE 
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (R0_REGNUM)], nindy_regs.local_regs, 16 * 4);
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (G0_REGNUM)], nindy_regs.global_regs, 16 * 4);
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (PCW_REGNUM)], nindy_regs.pcw_acw, 2 * 4);
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (IP_REGNUM)], nindy_regs.ip, 1 * 4);
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (TCW_REGNUM)], nindy_regs.tcw, 1 * 4);
// OBSOLETE   memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)], nindy_regs.fp_as_double, 4 * 8);
// OBSOLETE 
// OBSOLETE   registers_fetched ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_prepare_to_store (void)
// OBSOLETE {
// OBSOLETE   /* Fetch all regs if they aren't already here.  */
// OBSOLETE   read_register_bytes (0, NULL, REGISTER_BYTES);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_store_registers (int regno)
// OBSOLETE {
// OBSOLETE   struct nindy_regs nindy_regs;
// OBSOLETE   int regnum;
// OBSOLETE 
// OBSOLETE   memcpy (nindy_regs.local_regs, &registers[REGISTER_BYTE (R0_REGNUM)], 16 * 4);
// OBSOLETE   memcpy (nindy_regs.global_regs, &registers[REGISTER_BYTE (G0_REGNUM)], 16 * 4);
// OBSOLETE   memcpy (nindy_regs.pcw_acw, &registers[REGISTER_BYTE (PCW_REGNUM)], 2 * 4);
// OBSOLETE   memcpy (nindy_regs.ip, &registers[REGISTER_BYTE (IP_REGNUM)], 1 * 4);
// OBSOLETE   memcpy (nindy_regs.tcw, &registers[REGISTER_BYTE (TCW_REGNUM)], 1 * 4);
// OBSOLETE   memcpy (nindy_regs.fp_as_double, &registers[REGISTER_BYTE (FP0_REGNUM)], 8 * 4);
// OBSOLETE 
// OBSOLETE   immediate_quit++;
// OBSOLETE   ninRegsPut ((char *) &nindy_regs);
// OBSOLETE   immediate_quit--;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Copy LEN bytes to or from inferior's memory starting at MEMADDR
// OBSOLETE    to debugger memory starting at MYADDR.   Copy to inferior if
// OBSOLETE    SHOULD_WRITE is nonzero.  Returns the length copied.  TARGET is
// OBSOLETE    unused.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE nindy_xfer_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len,
// OBSOLETE 			    int should_write, struct mem_attrib *attrib,
// OBSOLETE 			    struct target_ops *target)
// OBSOLETE {
// OBSOLETE   int res;
// OBSOLETE 
// OBSOLETE   if (len <= 0)
// OBSOLETE     return 0;
// OBSOLETE 
// OBSOLETE   if (should_write)
// OBSOLETE     res = ninMemPut (memaddr, myaddr, len);
// OBSOLETE   else
// OBSOLETE     res = ninMemGet (memaddr, myaddr, len);
// OBSOLETE 
// OBSOLETE   return res;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_create_inferior (char *execfile, char *args, char **env)
// OBSOLETE {
// OBSOLETE   int entry_pt;
// OBSOLETE   int pid;
// OBSOLETE 
// OBSOLETE   if (args && *args)
// OBSOLETE     error ("Can't pass arguments to remote NINDY process");
// OBSOLETE 
// OBSOLETE   if (execfile == 0 || exec_bfd == 0)
// OBSOLETE     error ("No executable file specified");
// OBSOLETE 
// OBSOLETE   entry_pt = (int) bfd_get_start_address (exec_bfd);
// OBSOLETE 
// OBSOLETE   pid = 42;
// OBSOLETE 
// OBSOLETE   /* The "process" (board) is already stopped awaiting our commands, and
// OBSOLETE      the program is already downloaded.  We just set its PC and go.  */
// OBSOLETE 
// OBSOLETE   inferior_ptid = pid_to_ptid (pid);	/* Needed for wait_for_inferior below */
// OBSOLETE 
// OBSOLETE   clear_proceed_status ();
// OBSOLETE 
// OBSOLETE   /* Tell wait_for_inferior that we've started a new process.  */
// OBSOLETE   init_wait_for_inferior ();
// OBSOLETE 
// OBSOLETE   /* Set up the "saved terminal modes" of the inferior
// OBSOLETE      based on what modes we are starting it with.  */
// OBSOLETE   target_terminal_init ();
// OBSOLETE 
// OBSOLETE   /* Install inferior's terminal modes.  */
// OBSOLETE   target_terminal_inferior ();
// OBSOLETE 
// OBSOLETE   /* insert_step_breakpoint ();  FIXME, do we need this?  */
// OBSOLETE   /* Let 'er rip... */
// OBSOLETE   proceed ((CORE_ADDR) entry_pt, TARGET_SIGNAL_DEFAULT, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE reset_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   if (nindy_serial == NULL)
// OBSOLETE     {
// OBSOLETE       error ("No target system to reset -- use 'target nindy' command.");
// OBSOLETE     }
// OBSOLETE   if (query ("Really reset the target system?", 0, 0))
// OBSOLETE     {
// OBSOLETE       serial_send_break (nindy_serial);
// OBSOLETE       tty_flush (nindy_serial);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE nindy_kill (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   return;			/* Ignore attempts to kill target system */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Clean up when a program exits.
// OBSOLETE 
// OBSOLETE    The program actually lives on in the remote processor's RAM, and may be
// OBSOLETE    run again without a download.  Don't leave it full of breakpoint
// OBSOLETE    instructions.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE nindy_mourn_inferior (void)
// OBSOLETE {
// OBSOLETE   remove_breakpoints ();
// OBSOLETE   unpush_target (&nindy_ops);
// OBSOLETE   generic_mourn_inferior ();	/* Do all the proper things now */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Pass the args the way catch_errors wants them.  */
// OBSOLETE static int
// OBSOLETE nindy_open_stub (char *arg)
// OBSOLETE {
// OBSOLETE   nindy_open (arg, 1);
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE nindy_load (char *filename, int from_tty)
// OBSOLETE {
// OBSOLETE   asection *s;
// OBSOLETE   /* Can't do unix style forking on a VMS system, so we'll use bfd to do
// OBSOLETE      all the work for us
// OBSOLETE    */
// OBSOLETE 
// OBSOLETE   bfd *file = bfd_openr (filename, 0);
// OBSOLETE   if (!file)
// OBSOLETE     {
// OBSOLETE       perror_with_name (filename);
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (!bfd_check_format (file, bfd_object))
// OBSOLETE     {
// OBSOLETE       error ("can't prove it's an object file\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   for (s = file->sections; s; s = s->next)
// OBSOLETE     {
// OBSOLETE       if (s->flags & SEC_LOAD)
// OBSOLETE 	{
// OBSOLETE 	  char *buffer = xmalloc (s->_raw_size);
// OBSOLETE 	  bfd_get_section_contents (file, s, buffer, 0, s->_raw_size);
// OBSOLETE 	  printf ("Loading section %s, size %x vma %x\n",
// OBSOLETE 		  s->name,
// OBSOLETE 		  s->_raw_size,
// OBSOLETE 		  s->vma);
// OBSOLETE 	  ninMemPut (s->vma, buffer, s->_raw_size);
// OBSOLETE 	  xfree (buffer);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE   bfd_close (file);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE load_stub (char *arg)
// OBSOLETE {
// OBSOLETE   target_load (arg, 1);
// OBSOLETE   return 1;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* This routine is run as a hook, just before the main command loop is
// OBSOLETE    entered.  If gdb is configured for the i960, but has not had its
// OBSOLETE    nindy target specified yet, this will loop prompting the user to do so.
// OBSOLETE 
// OBSOLETE    Unlike the loop provided by Intel, we actually let the user get out
// OBSOLETE    of this with a RETURN.  This is useful when e.g. simply examining
// OBSOLETE    an i960 object file on the host system.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE nindy_before_main_loop (void)
// OBSOLETE {
// OBSOLETE   char ttyname[100];
// OBSOLETE   char *p, *p2;
// OBSOLETE 
// OBSOLETE   while (target_stack->target_ops != &nindy_ops)	/* What is this crap??? */
// OBSOLETE     {				/* remote tty not specified yet */
// OBSOLETE       if (instream == stdin)
// OBSOLETE 	{
// OBSOLETE 	  printf_unfiltered ("\nAttach /dev/ttyNN -- specify NN, or \"quit\" to quit:  ");
// OBSOLETE 	  gdb_flush (gdb_stdout);
// OBSOLETE 	}
// OBSOLETE       fgets (ttyname, sizeof (ttyname) - 1, stdin);
// OBSOLETE 
// OBSOLETE       /* Strip leading and trailing whitespace */
// OBSOLETE       for (p = ttyname; isspace (*p); p++)
// OBSOLETE 	{
// OBSOLETE 	  ;
// OBSOLETE 	}
// OBSOLETE       if (*p == '\0')
// OBSOLETE 	{
// OBSOLETE 	  return;		/* User just hit spaces or return, wants out */
// OBSOLETE 	}
// OBSOLETE       for (p2 = p; !isspace (*p2) && (*p2 != '\0'); p2++)
// OBSOLETE 	{
// OBSOLETE 	  ;
// OBSOLETE 	}
// OBSOLETE       *p2 = '\0';
// OBSOLETE       if (STREQ ("quit", p))
// OBSOLETE 	{
// OBSOLETE 	  exit (1);
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (catch_errors (nindy_open_stub, p, "", RETURN_MASK_ALL))
// OBSOLETE 	{
// OBSOLETE 	  /* Now that we have a tty open for talking to the remote machine,
// OBSOLETE 	     download the executable file if one was specified.  */
// OBSOLETE 	  if (exec_bfd)
// OBSOLETE 	    {
// OBSOLETE 	      catch_errors (load_stub, bfd_get_filename (exec_bfd), "",
// OBSOLETE 			    RETURN_MASK_ALL);
// OBSOLETE 	    }
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Define the target subroutine names */
// OBSOLETE 
// OBSOLETE struct target_ops nindy_ops;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_nindy_ops (void)
// OBSOLETE {
// OBSOLETE   nindy_ops.to_shortname = "nindy";
// OBSOLETE   "Remote serial target in i960 NINDY-specific protocol",
// OBSOLETE     nindy_ops.to_longname = "Use a remote i960 system running NINDY connected by a serial line.\n\
// OBSOLETE Specify the name of the device the serial line is connected to.\n\
// OBSOLETE The speed (baud rate), whether to use the old NINDY protocol,\n\
// OBSOLETE and whether to send a break on startup, are controlled by options\n\
// OBSOLETE specified when you started GDB.";
// OBSOLETE   nindy_ops.to_doc = "";
// OBSOLETE   nindy_ops.to_open = nindy_open;
// OBSOLETE   nindy_ops.to_close = nindy_close;
// OBSOLETE   nindy_ops.to_attach = 0;
// OBSOLETE   nindy_ops.to_post_attach = NULL;
// OBSOLETE   nindy_ops.to_require_attach = NULL;
// OBSOLETE   nindy_ops.to_detach = nindy_detach;
// OBSOLETE   nindy_ops.to_require_detach = NULL;
// OBSOLETE   nindy_ops.to_resume = nindy_resume;
// OBSOLETE   nindy_ops.to_wait = nindy_wait;
// OBSOLETE   nindy_ops.to_post_wait = NULL;
// OBSOLETE   nindy_ops.to_fetch_registers = nindy_fetch_registers;
// OBSOLETE   nindy_ops.to_store_registers = nindy_store_registers;
// OBSOLETE   nindy_ops.to_prepare_to_store = nindy_prepare_to_store;
// OBSOLETE   nindy_ops.to_xfer_memory = nindy_xfer_inferior_memory;
// OBSOLETE   nindy_ops.to_files_info = nindy_files_info;
// OBSOLETE   nindy_ops.to_insert_breakpoint = memory_insert_breakpoint;
// OBSOLETE   nindy_ops.to_remove_breakpoint = memory_remove_breakpoint;
// OBSOLETE   nindy_ops.to_terminal_init = 0;
// OBSOLETE   nindy_ops.to_terminal_inferior = 0;
// OBSOLETE   nindy_ops.to_terminal_ours_for_output = 0;
// OBSOLETE   nindy_ops.to_terminal_ours = 0;
// OBSOLETE   nindy_ops.to_terminal_info = 0;	/* Terminal crud */
// OBSOLETE   nindy_ops.to_kill = nindy_kill;
// OBSOLETE   nindy_ops.to_load = nindy_load;
// OBSOLETE   nindy_ops.to_lookup_symbol = 0;	/* lookup_symbol */
// OBSOLETE   nindy_ops.to_create_inferior = nindy_create_inferior;
// OBSOLETE   nindy_ops.to_post_startup_inferior = NULL;
// OBSOLETE   nindy_ops.to_acknowledge_created_inferior = NULL;
// OBSOLETE   nindy_ops.to_clone_and_follow_inferior = NULL;
// OBSOLETE   nindy_ops.to_post_follow_inferior_by_clone = NULL;
// OBSOLETE   nindy_ops.to_insert_fork_catchpoint = NULL;
// OBSOLETE   nindy_ops.to_remove_fork_catchpoint = NULL;
// OBSOLETE   nindy_ops.to_insert_vfork_catchpoint = NULL;
// OBSOLETE   nindy_ops.to_remove_vfork_catchpoint = NULL;
// OBSOLETE   nindy_ops.to_has_forked = NULL;
// OBSOLETE   nindy_ops.to_has_vforked = NULL;
// OBSOLETE   nindy_ops.to_can_follow_vfork_prior_to_exec = NULL;
// OBSOLETE   nindy_ops.to_post_follow_vfork = NULL;
// OBSOLETE   nindy_ops.to_insert_exec_catchpoint = NULL;
// OBSOLETE   nindy_ops.to_remove_exec_catchpoint = NULL;
// OBSOLETE   nindy_ops.to_has_execd = NULL;
// OBSOLETE   nindy_ops.to_reported_exec_events_per_exec_call = NULL;
// OBSOLETE   nindy_ops.to_has_exited = NULL;
// OBSOLETE   nindy_ops.to_mourn_inferior = nindy_mourn_inferior;
// OBSOLETE   nindy_ops.to_can_run = 0;	/* can_run */
// OBSOLETE   nindy_ops.to_notice_signals = 0;	/* notice_signals */
// OBSOLETE   nindy_ops.to_thread_alive = 0;	/* to_thread_alive */
// OBSOLETE   nindy_ops.to_stop = 0;	/* to_stop */
// OBSOLETE   nindy_ops.to_pid_to_exec_file = NULL;
// OBSOLETE   nindy_ops.to_stratum = process_stratum;
// OBSOLETE   nindy_ops.DONT_USE = 0;	/* next */
// OBSOLETE   nindy_ops.to_has_all_memory = 1;
// OBSOLETE   nindy_ops.to_has_memory = 1;
// OBSOLETE   nindy_ops.to_has_stack = 1;
// OBSOLETE   nindy_ops.to_has_registers = 1;
// OBSOLETE   nindy_ops.to_has_execution = 1;	/* all mem, mem, stack, regs, exec */
// OBSOLETE   nindy_ops.to_sections = 0;
// OBSOLETE   nindy_ops.to_sections_end = 0;	/* Section pointers */
// OBSOLETE   nindy_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_nindy (void)
// OBSOLETE {
// OBSOLETE   init_nindy_ops ();
// OBSOLETE   add_target (&nindy_ops);
// OBSOLETE   add_com ("reset", class_obscure, reset_command,
// OBSOLETE 	   "Send a 'break' to the remote target system.\n\
// OBSOLETE Only useful if the target has been equipped with a circuit\n\
// OBSOLETE to perform a hard reset when a break is detected.");
// OBSOLETE }
@


1.18
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d2 4
a5 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001 Free Software Foundation, Inc.
d22 1
a22 2
   anyone else from sharing it farther.  Help stamp out software hoarding!
 */
d481 2
a482 3
			    int should_write, 
			    struct mem_attrib *attrib ATTRIBUTE_UNUSED,
			    struct target_ops *target ATTRIBUTE_UNUSED)
@


1.17
log
@s/typedef serial_t/struct serial */
@
text
@d161 1
a161 1
    SERIAL_CLOSE (nindy_serial);
d288 1
a288 1
  SERIAL_SET_TTY_STATE (args->serial, args->state);
d302 1
a302 1
  SERIAL_SET_TTY_STATE (tty_args.serial, tty_args.state);
d337 2
a338 2
  tty_args.serial = SERIAL_FDOPEN (0);
  tty_args.state = SERIAL_GET_TTY_STATE (tty_args.serial);
d350 1
a350 1
  SERIAL_RAW (tty_args.serial);
d355 1
a355 1
      c = SERIAL_READCHAR (nindy_serial, -1);
d362 1
a362 1
	  c = SERIAL_READCHAR (nindy_serial, -1);
d395 1
a395 1
  SERIAL_SET_TTY_STATE (tty_args.serial, tty_args.state);
d544 1
a544 1
      SERIAL_SEND_BREAK (nindy_serial);
@


1.16
log
@Phase 1 of the ptid_t changes.
@
text
@d144 1
a144 1
extern serial_t nindy_serial;
d280 1
a280 1
  serial_t serial;
@


1.15
log
@* target.h (target_ops): Removed to_core_file_to_sym_file vector
function.
* corelow.c (core_ops): Updated for above change.
* gnu-nat.c (core_ops): Likewise.
* inftarg.c (child_ops): Likewise.
* monitor.c (monitor_ops): Likewise.
* ppc-bdm.c (bdm_ppc_ops): Likewise.
* remote-adapt.c (adapt_ops): Likewise.
* remote-bug.c (bug_ops): Likewise.
* remote-e7000.c (e7000_ops): Likewise.
* remote-eb.c (eb_ops): Likewise.
* remote-es.c (es1800_ops, es1800_child_ops): Likewise.
* remote-mm.c (mm_ops): Likewise.
* remote-nindy.c (nindy_ops): Likewise.
* remote-nrom.c (nrom_ops): Likewise.
* remote-os9k.c (rombug_ops): Likewise.
* remote-rdp.c (remote_rdp_ops): Likewise.
* remote-sim.c (gdbsim_ops): Likewise.
* remote-st.c (st2000_ops): Likewise.
* v850ice.c (v850ice_ops): Likewise.
* target.c (cleanup_target): Likewise
(update_current_target): Likewise.
(setup_target_debug): Likewise
(debug_to_core_file_to_sym_file): Removed.

* corefile.c (core_file_command) [HPUXHPPA]: Removed code that
sets symbol file from information obtained from the core file.
* corelow.c (core_file_to_sym_file): Removed.
@
text
@d258 1
a258 1
nindy_resume (int pid, int step, enum target_signal siggnal)
d319 2
a320 2
static int
nindy_wait (int pid, struct target_waitstatus *status)
d412 1
a412 1
  return inferior_pid;
d516 1
a516 1
  inferior_pid = pid;		/* Needed for wait_for_inferior below */
@


1.14
log
@Update/correct copyright notices.
@
text
@a740 1
  nindy_ops.to_core_file_to_sym_file = NULL;
@


1.13
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 2001 Free Software Foundation, Inc.
@


1.12
log
@* monitor.c (#include "gdb_wait.h"): Removed.
* ocd.c: Likewise.
* ppc-bdm.c: Likewise.
* remote-adapt.c: Likewise.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-eb.c: Likewise.
* remote-es.c: Likewise.
* remote-mips.c: Likewise.
* remote-mm.c: Likewise.
* remote-nindy.c: Likewise.
* remote-os9k.c: Likewise.
* remote-rdi.c: Likewise.
* remote-rdp.c: Likewise.
* remote-sds.c: Likewise.
* remote-sim.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
* remote.c: Likewise.
* ser-pipe.c: Likewise.
* ser-unix.c: Likewise.
* Makefile.in: Updated dependencies.
-------------------------------------------------------------------
@
text
@d111 1
@


1.11
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@a111 1
#include "gdb_wait.h"
@


1.10
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
d479 3
a481 1
			    int should_write, struct target_ops *target)
@


1.9
log
@* TODO: Note abstraction layer violation where "ocd reset" command
must invalidate the dcache, and how this might be fixed.

* monitor.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(monitor_open): Removed code that created local dcache.
(flush_monitor_dcache): Removed (unused function).
(monitor_resume): Removed call to dcache_invd().
(monitor_load): Likewise.
(monitor_xfer_memory): Changed to call monitor_write_memory(),
monitor_write_memory_block(), and monitor_read_memory() instead
of dcache_xfer_memory().
* monitor.h (flush_monitor_dcache): Removed (unused function).
* ocd.c (#include "dcache.h"): Removed.
(ocd_dcache): Removed.
(ocd_open): Removed code that created local dcache.
(ocd_resume): Removed call to dcache_invd().
(ocd_xfer_memory): Changed to call ocd_write_bytes() and
ocd_read_bytes() instead of dcache_xfer_memory().
(bdm_reset_command): Invalidate target dcache.
* remote-bug.c (bug_load): Remove call to dcache_invd().
(bug_resume): Likewise.
(bug_settings): Remove dcache, readfunc, and writefunc fields
from initializer.
(bug_xfer_memory): Changed to call bug_read_memory() and
bug_write_memory() instead of dcache_xfer_memory().
* remote-nindy.c (#include "dcache.h"): Removed.
(nindy_dcache): Removed.
(nindy_open): Removed code that created local dcache.
(nindy_resume): Removed call to dcache_invd().
(nindy_load): Likewise.
(nindy_xfer_inferior_memory): Changed to call ninMemPut() and
ninMemGet() instead of dcache_xfer_memory().
* remote-sds.c (#include "dcache.h"): Removed.
(sds_dcache): Removed.
(sds_open): Removed code that created local dcache.
(sds_resume): Removed call to dcache_invd().
(sds_xfer_memory): Changed to call sds_write_bytes() and
sds_read_bytes() instead of dcache_xfer_memory().
* remote-utils.c (gr_open): Removed code that created local dcache.
* remote-utils.h (#include "dcache.h"): Removed.
(struct gr_settings): Removed dcache, readfunc, and writefunc fields.
(gr_get_dcache, gr_set_dcache): Removed macro definitions.
* remote.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(remote_open_1): Removed code that created local dcache.
(remote_async_open_1): Likewise.
(remote_resume): Removed call to dcache_invd().
(remote_async_resume): Likewise.
(remote_xfer_memory): Changed to call remote_write_bytes() and
remote_read_bytes() instead of dcache_xfer_memory().
* wince.c (#include "dcache.h"): Removed.
(remote_dcache): Removed.
(child_create_inferior): Removed code that created local dcache.
(child_xfer_memory): Changed to call remote_write_bytes() and
remote_read_bytes() instead of dcache_xfer_memory().
(child_resume): Removed call to dcache_invd().

* target.c (target_dcache): Added.
(target_load): Invalidate target_dcache.
(do_xfer_memory): New function.
(target_xfer_memory): Reimplement in terms of dcache_xfer_memory().
(target_xfer_memory_partial): Likewise.
(initialize_targets): Create target_dcache.
* target.h (#include "dcache.h"): Added.
(target_open): Invalidate target_dcache.
(target_resume): Likewise.
(do_xfer_memory): New declaration.

* dcache.c (dcache_init): Removed reading and writing arguments.
(dcache_struct): Removed read_memory and write_memory fields.
(dcache_write_line): Call do_xfer_memory.
(dcache_read_line): Likewise.
(dcache_xfer_memory): Likewise.
(dcache_invalidate): Renamed from dcache_invd.
(dcache_init): Updated.
(dcache_xfer_memory): Updated.
* dcache.h (memxferfunc): Removed definition.
@
text
@d164 1
a164 1
    free (savename);
d288 1
a288 1
  free (args->state);
d302 1
a302 1
  free (tty_args.state);
d395 1
a395 1
  free (tty_args.state);
d606 1
a606 1
	  free (buffer);
@


1.8
log
@Protoization.
@
text
@a117 2

#include "dcache.h"
a119 2
static DCACHE *nindy_dcache;

a186 5
  if (!nindy_dcache)
    nindy_dcache = dcache_init (ninMemGet, ninMemPut);
  else
    dcache_invd (nindy_dcache);

a261 1
  dcache_invd (nindy_dcache);
d481 2
d485 7
a491 2
  return dcache_xfer_memory (nindy_dcache, memaddr, myaddr, 
			     len, should_write);
a609 2

  dcache_invd(nindy_dcache);
@


1.7
log
@* MAINTAINERS: Add myself as dcache.c maintainer.

* remote-nindy.c (nindy_load): Invalidate dcache.

* dcache.c (dcache_invd): Renamed from dcache_flush.  The term
flush with respect to caches usually implies that data will be
written to memory.
(dcache_init, dcache_xfer_memory): Updated.
* monitor.c (flush_monitor_dcache, monitor_resume, monitor_load):
Updated.
* ocd.c (ocd_open, ocd_resume, bdm_reset_command): Updated.
* remote-bug.c (bug_load, bug_resume): Updated.
* remote-nindy.c (nindy_open, nindy_resume): Updated.
* remote-sds.c (sds_open, sds_resume): Updated.
* remote-utils.c (gr_open): Updated.
* remote.c (remote_open_1, remote_resume, remote_async_resume,
remote_cisco_open): Updated.
* wince.c (child_create_inferior, child_resume): Updated.

* monitor.c (monitor_open): Free dcache before creating a new one.
* dcache.c (dcache_free): New function.
* dcache.h (dcache_free): New prototype.
-------------------------------------------------------------------
@
text
@d243 3
a245 2
/* Return the number of characters in the buffer before
   the first DLE character.  */
d249 1
a249 3
non_dle (buf, n)
     char *buf;			/* Character buffer; NOT '\0'-terminated */
     int n;			/* Number of characters in buffer */
d484 2
a485 1
   SHOULD_WRITE is nonzero.  Returns the length copied. */
d488 2
a489 6
nindy_xfer_inferior_memory (memaddr, myaddr, len, should_write, target)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int should_write;
     struct target_ops *target;	/* ignored */
@


1.6
log
@* monitor.c (monitor_open): If a dcache has already been created,
invalidate it rather than creating another.
* ocd.c (ocd_open): Likewise.
* remote-nindy.c (nindy_open): Likewise.
* remote-sds.c (sds_open): Likewise.
* remote-utils.c (gr_open): Likewise.
* remote.c (remote_open_1, remote_cisco_open): Likewise.

* dcache.c (dcache_alloc): Changed to take address of line as an
argument, and to invalidate cache line before returning.
(dcache_peek_byte): Updated.
(dcache_poke_byte): Updated.
-------------------------------------------------------------------
@
text
@d194 1
a194 1
    dcache_flush (nindy_dcache);
d272 1
a272 1
  dcache_flush (nindy_dcache);
d617 2
@


1.5
log
@Protoization.
@
text
@d190 5
a194 1
  nindy_dcache = dcache_init (ninMemGet, ninMemPut);
@


1.4
log
@* remote-nindy.c (nindy_fetch_word, nindy_store_word): Removed
(nindy_xfer_inferior_memory): Use dcache_xfer_memory() instead of
breaking transfer into chunks and using nindy_fetch_word() and
nindy_store_word().

* remote-bug.c (bug_xfer_memory): Use dcache_xfer_memory() instead
of breaking transfer into chunks and using gr_fetch_word() and
gr_store_word().

* remote.c (remote_fetch_word, remote_store_word): Removed.

* remote-utils.h (gr_fetch_word, gr_store_word): Removed.
* remote-utils.c (gr_fetch_word, gr_store_word): Removed.

* dcache.h (dcache_fetch, dcache_poke, dcache_poke_block): Removed.
* dcache.c (dcache_fetch, dcache_poke): Removed.
@
text
@d161 1
a161 2
nindy_close (quitting)
     int quitting;
d177 2
a178 3
nindy_open (name, from_tty)
     char *name;		/* "/dev/ttyXX", "ttyXX", or "XX": tty to be opened */
     int from_tty;
d222 1
a222 3
nindy_detach (name, from_tty)
     char *name;
     int from_tty;
d230 1
a230 1
nindy_files_info ()
d263 1
a263 3
nindy_resume (pid, step, siggnal)
     int pid, step;
     enum target_signal siggnal;
d291 1
a291 2
clean_up_tty (ptrarg)
     PTR ptrarg;
d306 1
a306 1
clean_up_int ()
d326 1
a326 3
nindy_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d435 1
a435 2
nindy_fetch_registers (regno)
     int regno;
d455 1
a455 1
nindy_prepare_to_store ()
d462 1
a462 2
nindy_store_registers (regno)
     int regno;
d498 1
a498 4
nindy_create_inferior (execfile, args, env)
     char *execfile;
     char *args;
     char **env;
d536 1
a536 3
reset_command (args, from_tty)
     char *args;
     int from_tty;
d550 1
a550 3
nindy_kill (args, from_tty)
     char *args;
     int from_tty;
d562 1
a562 1
nindy_mourn_inferior ()
d571 1
a571 2
nindy_open_stub (arg)
     char *arg;
d578 1
a578 3
nindy_load (filename, from_tty)
     char *filename;
     int from_tty;
d616 1
a616 2
load_stub (arg)
     char *arg;
d631 1
a631 1
nindy_before_main_loop ()
d755 1
a755 1
_initialize_nindy ()
@


1.3
log
@PARAMS removal.
@
text
@a489 21
/* Read a word from remote address ADDR and return it.
 * This goes through the data cache.
 */
int
nindy_fetch_word (addr)
     CORE_ADDR addr;
{
  return dcache_fetch (nindy_dcache, addr);
}

/* Write a word WORD into remote address ADDR.
   This goes through the data cache.  */

void
nindy_store_word (addr, word)
     CORE_ADDR addr;
     int word;
{
  dcache_poke (nindy_dcache, addr, word);
}

d492 1
a492 5
   WRITE is nonzero.  Returns the length copied.

   This is stolen almost directly from infptrace.c's child_xfer_memory,
   which also deals with a word-oriented memory interface.  Sometime,
   FIXME, rewrite this to not use the word-oriented routines.  */
d502 4
a505 55
  register int i;
  /* Round starting address down to longword boundary.  */
  register CORE_ADDR addr = memaddr & -sizeof (int);
  /* Round ending address up; get number of longwords that makes.  */
  register int count
  = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
  /* Allocate buffer of that many longwords.  */
  register int *buffer = (int *) alloca (count * sizeof (int));

  if (should_write)
    {
      /* Fill start and end extra bytes of buffer with existing memory data.  */

      if (addr != memaddr || len < (int) sizeof (int))
	{
	  /* Need part of initial word -- fetch it.  */
	  buffer[0] = nindy_fetch_word (addr);
	}

      if (count > 1)		/* FIXME, avoid if even boundary */
	{
	  buffer[count - 1]
	    = nindy_fetch_word (addr + (count - 1) * sizeof (int));
	}

      /* Copy data to be written over corresponding part of buffer */

      memcpy ((char *) buffer + (memaddr & (sizeof (int) - 1)), myaddr, len);

      /* Write the entire buffer.  */

      for (i = 0; i < count; i++, addr += sizeof (int))
	{
	  errno = 0;
	  nindy_store_word (addr, buffer[i]);
	  if (errno)
	    return 0;
	}
    }
  else
    {
      /* Read all the longwords */
      for (i = 0; i < count; i++, addr += sizeof (int))
	{
	  errno = 0;
	  buffer[i] = nindy_fetch_word (addr);
	  if (errno)
	    return 0;
	  QUIT;
	}

      /* Copy appropriate bytes out of the buffer.  */
      memcpy (myaddr, (char *) buffer + (memaddr & (sizeof (int) - 1)), len);
    }
  return len;
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d154 1
a154 2
static void
nindy_fetch_registers PARAMS ((int));
d156 1
a156 2
static void
nindy_store_registers PARAMS ((int));
@


1.1
log
@Initial revision
@
text
@d5 16
a20 16
GDB is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY.  No author or distributor accepts responsibility to anyone
for the consequences of using it or for whether it serves any
particular purpose or works at all, unless he says so in writing.
Refer to the GDB General Public License for full details.

Everyone is granted permission to copy, modify and redistribute GDB,
but only under the conditions described in the GDB General Public
License.  A copy of this license is supposed to have been given to you
along with GDB so you can know your rights and responsibilities.  It
should be in a file named COPYING.  Among other things, the copyright
notice and this notice must be preserved on all copies.

In other words, go ahead and share GDB, but don't try to stop
anyone else from sharing it farther.  Help stamp out software hoarding!
*/
d23 5
a27 5
Except for the data cache routines, this file bears little resemblence
to remote.c.  A new (although similar) protocol has been specified, and
portions of the code are entirely dependent on having an i80960 with a
NINDY ROM monitor at the other end of the line.
*/
d112 1
a112 1
#include "wait.h"
d124 3
a126 3
extern int unlink();
extern char *getenv();
extern char *mktemp();
d137 3
a139 3
int nindy_initial_brk;	/* nonzero if want to send an initial BREAK to nindy */
int nindy_old_protocol;	/* nonzero if want to use old protocol */
char *nindy_ttyname;	/* name of tty to talk to nindy on, or null */
d141 2
a142 2
#define DLE	'\020'	/* Character NINDY sends to indicate user program has
			 * halted.  */
d152 1
a152 1
extern char *exists();
d181 2
a182 2
    char *name;		/* "/dev/ttyXX", "ttyXX", or "XX": tty to be opened */
    int from_tty;
d194 1
a194 1
  nindy_dcache = dcache_init(ninMemGet, ninMemPut);
d202 3
a204 3
  sprintf(baudrate, "%d", baud_rate);
  ninConnect(name, baudrate,
	     nindy_initial_brk, !from_tty, nindy_old_protocol);
d215 1
a215 1
  target_fetch_registers(-1);
d239 4
a242 4
  printf_unfiltered("\tAttached to %s at %d bits per second%s%s.\n", savename,
	 baud_rate,
	 nindy_old_protocol? " in old protocol": "",
         nindy_initial_brk? " with initial break": "");
d250 3
a252 3
non_dle( buf, n )
    char *buf;		/* Character buffer; NOT '\0'-terminated */
    int n;		/* Number of characters in buffer */
d256 6
a261 3
  for ( i = 0; i < n; i++ ){
    if ( buf[i] == DLE ){
      break;
a262 1
  }
d276 2
a277 2
  dcache_flush(nindy_dcache);
  if ( regs_changed )
d283 1
a283 1
  ninGo( step );
d291 2
a292 1
struct clean_up_tty_args {
d296 1
a296 1
static  struct clean_up_tty_args tty_args;
d309 1
a309 1
static void (*old_ctrlc)();  
d311 1
a311 1
static void (*old_ctrlz)();
d315 1
a315 1
clean_up_int()
d320 1
a320 1
  signal(SIGINT, old_ctrlc);
d322 1
a322 1
  signal(SIGTSTP, old_ctrlz);
d324 1
a324 1
  error("\n\nYou may need to reset the 80960 and/or reload your program.\n");
d335 3
a337 3
nindy_wait( pid, status )
    int pid;
    struct target_waitstatus *status;
d356 1
a356 1
  old_ctrlc = signal( SIGINT, clean_up_int );
d358 1
a358 1
  old_ctrlz = signal( SIGTSTP, clean_up_int );
d377 1
a377 1
      else if (c == 0x1b) /* ESC */
d381 2
a382 2
	} 
      else if (c != 0x10) /* DLE */
d385 1
a385 1
	  buf[0] = (char)c;
d390 2
a391 2
	  stop_exit = ninStopWhy(&stop_code,
				 &ip_value, &fp_value, &sp_value);
d395 1
a395 1
	      ninSrq();
d401 6
a406 6
	      supply_register (IP_REGNUM, 
			       (char *)&ip_value);
	      supply_register (FP_REGNUM, 
			       (char *)&fp_value);
	      supply_register (SP_REGNUM, 
			       (char *)&sp_value);
d435 8
a442 7
struct nindy_regs {
  char	local_regs[16 * 4];
  char	global_regs[16 * 4];
  char	pcw_acw[2 * 4];
  char	ip[4];
  char	tcw[4];
  char	fp_as_double[4 * 8];
d446 1
a446 1
nindy_fetch_registers(regno)
d453 1
a453 1
  ninRegsGet( (char *) &nindy_regs );
d456 5
a460 5
  memcpy (&registers[REGISTER_BYTE (R0_REGNUM)], nindy_regs.local_regs, 16*4);
  memcpy (&registers[REGISTER_BYTE (G0_REGNUM)], nindy_regs.global_regs, 16*4);
  memcpy (&registers[REGISTER_BYTE (PCW_REGNUM)], nindy_regs.pcw_acw, 2*4);
  memcpy (&registers[REGISTER_BYTE (IP_REGNUM)], nindy_regs.ip, 1*4);
  memcpy (&registers[REGISTER_BYTE (TCW_REGNUM)], nindy_regs.tcw, 1*4);
d467 1
a467 1
nindy_prepare_to_store()
d474 1
a474 1
nindy_store_registers(regno)
d480 6
a485 6
  memcpy (nindy_regs.local_regs, &registers[REGISTER_BYTE (R0_REGNUM)], 16*4);
  memcpy (nindy_regs.global_regs, &registers[REGISTER_BYTE (G0_REGNUM)], 16*4);
  memcpy (nindy_regs.pcw_acw, &registers[REGISTER_BYTE (PCW_REGNUM)], 2*4);
  memcpy (nindy_regs.ip, &registers[REGISTER_BYTE (IP_REGNUM)], 1*4);
  memcpy (nindy_regs.tcw, &registers[REGISTER_BYTE (TCW_REGNUM)], 1*4);
  memcpy (nindy_regs.fp_as_double, &registers[REGISTER_BYTE (FP0_REGNUM)], 8*4);
d488 1
a488 1
  ninRegsPut( (char *) &nindy_regs );
d499 1
a499 1
	return dcache_fetch (nindy_dcache, addr);
d510 1
a510 1
	dcache_poke (nindy_dcache, addr, word);
d522 1
a522 1
nindy_xfer_inferior_memory(memaddr, myaddr, len, should_write, target)
d527 1
a527 1
     struct target_ops *target;			/* ignored */
d531 1
a531 1
  register CORE_ADDR addr = memaddr & - sizeof (int);
d534 1
a534 1
    = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
d542 5
a546 4
      if (addr != memaddr || len < (int)sizeof (int)) {
	/* Need part of initial word -- fetch it.  */
        buffer[0] = nindy_fetch_word (addr);
      }
d624 1
a624 1
  proceed ((CORE_ADDR)entry_pt, TARGET_SIGNAL_DEFAULT, 0);
d628 1
a628 1
reset_command(args, from_tty)
d634 1
a634 1
      error( "No target system to reset -- use 'target nindy' command.");
d636 1
a636 1
  if ( query("Really reset the target system?",0,0) )
d648 1
a648 1
  return;		/* Ignore attempts to kill target system */
d675 3
a677 3
nindy_load( filename, from_tty )
    char *filename;
    int from_tty;
d682 1
a682 1
     */
d684 1
a684 1
  bfd *file = bfd_openr(filename,0);
d686 24
a709 23
  {
    perror_with_name(filename);
    return;
  }

  if (!bfd_check_format(file, bfd_object))
  {
    error("can't prove it's an object file\n");
    return;
  }
 
  for ( s = file->sections; s; s=s->next)
  {
    if (s->flags & SEC_LOAD)
    {
      char *buffer = xmalloc(s->_raw_size);
      bfd_get_section_contents(file, s, buffer, 0, s->_raw_size);
      printf("Loading section %s, size %x vma %x\n",
             s->name,
             s->_raw_size,
             s->vma);
      ninMemPut(s->vma, buffer, s->_raw_size);
      free(buffer);
d711 1
a711 2
  }
  bfd_close(file);
d736 1
a736 1
  while (target_stack->target_ops != &nindy_ops) /* What is this crap??? */
d738 37
a774 32
	if ( instream == stdin ){
		printf_unfiltered("\nAttach /dev/ttyNN -- specify NN, or \"quit\" to quit:  ");
		gdb_flush( gdb_stdout );
	}
	fgets( ttyname, sizeof(ttyname)-1, stdin );

	/* Strip leading and trailing whitespace */
	for ( p = ttyname; isspace(*p); p++ ){
		;
	}
	if ( *p == '\0' ){
		return;		/* User just hit spaces or return, wants out */
	}
	for ( p2= p; !isspace(*p2) && (*p2 != '\0'); p2++ ){
		;
	}
	*p2= '\0';
	if ( STREQ("quit",p) ){
		exit(1);
	}

	if (catch_errors (nindy_open_stub, p, "", RETURN_MASK_ALL))
	  {
	    /* Now that we have a tty open for talking to the remote machine,
	       download the executable file if one was specified.  */
	    if (exec_bfd)
	      {
		catch_errors (load_stub, bfd_get_filename (exec_bfd), "",
			      RETURN_MASK_ALL);
	      }
	  }
      }
d779 1
a779 1
struct target_ops nindy_ops ;
d781 2
a782 2
static void 
init_nindy_ops(void)
d784 3
a786 2
  nindy_ops.to_shortname =   "nindy"; "Remote serial target in i960 NINDY-specific protocol",
					nindy_ops.to_longname =   "Use a remote i960 system running NINDY connected by a serial line.\n\
d790 5
a794 5
specified when you started GDB." ;
  nindy_ops.to_doc =   "";
  nindy_ops.to_open =   nindy_open;
  nindy_ops.to_close =   nindy_close;
  nindy_ops.to_attach =   0;
d797 1
a797 1
  nindy_ops.to_detach =   nindy_detach;
d799 2
a800 2
  nindy_ops.to_resume =   nindy_resume;
  nindy_ops.to_wait  =   nindy_wait;
d802 16
a817 16
  nindy_ops.to_fetch_registers  =   nindy_fetch_registers;
  nindy_ops.to_store_registers  =   nindy_store_registers;
  nindy_ops.to_prepare_to_store =   nindy_prepare_to_store;
  nindy_ops.to_xfer_memory  =   nindy_xfer_inferior_memory;
  nindy_ops.to_files_info  =   nindy_files_info;
  nindy_ops.to_insert_breakpoint =   memory_insert_breakpoint;
  nindy_ops.to_remove_breakpoint =   memory_remove_breakpoint;
  nindy_ops.to_terminal_init  =   0;
  nindy_ops.to_terminal_inferior =   0;
  nindy_ops.to_terminal_ours_for_output =   0;
  nindy_ops.to_terminal_ours  =   0;
  nindy_ops.to_terminal_info  =   0;	/* Terminal crud */
  nindy_ops.to_kill  =   nindy_kill;
  nindy_ops.to_load  =   nindy_load;
  nindy_ops.to_lookup_symbol =   0; /* lookup_symbol */
  nindy_ops.to_create_inferior =   nindy_create_inferior;
d835 5
a839 5
  nindy_ops.to_mourn_inferior =   nindy_mourn_inferior;
  nindy_ops.to_can_run  =   0;		/* can_run */
  nindy_ops.to_notice_signals =   0; /* notice_signals */
  nindy_ops.to_thread_alive  =   0;			/* to_thread_alive */
  nindy_ops.to_stop  =   0;			/* to_stop */
d842 10
a851 10
  nindy_ops.to_stratum =   process_stratum;
  nindy_ops.DONT_USE =   0; /* next */
  nindy_ops.to_has_all_memory =   1;
  nindy_ops.to_has_memory =   1;
  nindy_ops.to_has_stack =   1;
  nindy_ops.to_has_registers =   1;
  nindy_ops.to_has_execution =   1;	/* all mem, mem, stack, regs, exec */
  nindy_ops.to_sections =   0;
  nindy_ops.to_sections_end =   0;			/* Section pointers */
  nindy_ops.to_magic =   OPS_MAGIC;		/* Always the last thing */
d857 1
a857 1
  init_nindy_ops() ;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d5 16
a20 16
   GDB is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY.  No author or distributor accepts responsibility to anyone
   for the consequences of using it or for whether it serves any
   particular purpose or works at all, unless he says so in writing.
   Refer to the GDB General Public License for full details.

   Everyone is granted permission to copy, modify and redistribute GDB,
   but only under the conditions described in the GDB General Public
   License.  A copy of this license is supposed to have been given to you
   along with GDB so you can know your rights and responsibilities.  It
   should be in a file named COPYING.  Among other things, the copyright
   notice and this notice must be preserved on all copies.

   In other words, go ahead and share GDB, but don't try to stop
   anyone else from sharing it farther.  Help stamp out software hoarding!
 */
d23 5
a27 5
   Except for the data cache routines, this file bears little resemblence
   to remote.c.  A new (although similar) protocol has been specified, and
   portions of the code are entirely dependent on having an i80960 with a
   NINDY ROM monitor at the other end of the line.
 */
d124 3
a126 3
extern int unlink ();
extern char *getenv ();
extern char *mktemp ();
d137 3
a139 3
int nindy_initial_brk;		/* nonzero if want to send an initial BREAK to nindy */
int nindy_old_protocol;		/* nonzero if want to use old protocol */
char *nindy_ttyname;		/* name of tty to talk to nindy on, or null */
d141 2
a142 2
#define DLE	'\020'		/* Character NINDY sends to indicate user program has
				   * halted.  */
d152 1
a152 1
extern char *exists ();
d181 2
a182 2
     char *name;		/* "/dev/ttyXX", "ttyXX", or "XX": tty to be opened */
     int from_tty;
d194 1
a194 1
  nindy_dcache = dcache_init (ninMemGet, ninMemPut);
d202 3
a204 3
  sprintf (baudrate, "%d", baud_rate);
  ninConnect (name, baudrate,
	      nindy_initial_brk, !from_tty, nindy_old_protocol);
d215 1
a215 1
  target_fetch_registers (-1);
d239 4
a242 4
  printf_unfiltered ("\tAttached to %s at %d bits per second%s%s.\n", savename,
		     baud_rate,
		     nindy_old_protocol ? " in old protocol" : "",
		     nindy_initial_brk ? " with initial break" : "");
d250 3
a252 3
non_dle (buf, n)
     char *buf;			/* Character buffer; NOT '\0'-terminated */
     int n;			/* Number of characters in buffer */
d256 3
a258 6
  for (i = 0; i < n; i++)
    {
      if (buf[i] == DLE)
	{
	  break;
	}
d260 1
d274 2
a275 2
  dcache_flush (nindy_dcache);
  if (regs_changed)
d281 1
a281 1
  ninGo (step);
d289 1
a289 2
struct clean_up_tty_args
{
d293 1
a293 1
static struct clean_up_tty_args tty_args;
d306 1
a306 1
static void (*old_ctrlc) ();
d308 1
a308 1
static void (*old_ctrlz) ();
d312 1
a312 1
clean_up_int ()
d317 1
a317 1
  signal (SIGINT, old_ctrlc);
d319 1
a319 1
  signal (SIGTSTP, old_ctrlz);
d321 1
a321 1
  error ("\n\nYou may need to reset the 80960 and/or reload your program.\n");
d332 3
a334 3
nindy_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d353 1
a353 1
  old_ctrlc = signal (SIGINT, clean_up_int);
d355 1
a355 1
  old_ctrlz = signal (SIGTSTP, clean_up_int);
d374 1
a374 1
      else if (c == 0x1b)	/* ESC */
d378 2
a379 2
	}
      else if (c != 0x10)	/* DLE */
d382 1
a382 1
	  buf[0] = (char) c;
d387 2
a388 2
	  stop_exit = ninStopWhy (&stop_code,
				  &ip_value, &fp_value, &sp_value);
d392 1
a392 1
	      ninSrq ();
d398 6
a403 6
	      supply_register (IP_REGNUM,
			       (char *) &ip_value);
	      supply_register (FP_REGNUM,
			       (char *) &fp_value);
	      supply_register (SP_REGNUM,
			       (char *) &sp_value);
d432 7
a438 8
struct nindy_regs
{
  char local_regs[16 * 4];
  char global_regs[16 * 4];
  char pcw_acw[2 * 4];
  char ip[4];
  char tcw[4];
  char fp_as_double[4 * 8];
d442 1
a442 1
nindy_fetch_registers (regno)
d449 1
a449 1
  ninRegsGet ((char *) &nindy_regs);
d452 5
a456 5
  memcpy (&registers[REGISTER_BYTE (R0_REGNUM)], nindy_regs.local_regs, 16 * 4);
  memcpy (&registers[REGISTER_BYTE (G0_REGNUM)], nindy_regs.global_regs, 16 * 4);
  memcpy (&registers[REGISTER_BYTE (PCW_REGNUM)], nindy_regs.pcw_acw, 2 * 4);
  memcpy (&registers[REGISTER_BYTE (IP_REGNUM)], nindy_regs.ip, 1 * 4);
  memcpy (&registers[REGISTER_BYTE (TCW_REGNUM)], nindy_regs.tcw, 1 * 4);
d463 1
a463 1
nindy_prepare_to_store ()
d470 1
a470 1
nindy_store_registers (regno)
d476 6
a481 6
  memcpy (nindy_regs.local_regs, &registers[REGISTER_BYTE (R0_REGNUM)], 16 * 4);
  memcpy (nindy_regs.global_regs, &registers[REGISTER_BYTE (G0_REGNUM)], 16 * 4);
  memcpy (nindy_regs.pcw_acw, &registers[REGISTER_BYTE (PCW_REGNUM)], 2 * 4);
  memcpy (nindy_regs.ip, &registers[REGISTER_BYTE (IP_REGNUM)], 1 * 4);
  memcpy (nindy_regs.tcw, &registers[REGISTER_BYTE (TCW_REGNUM)], 1 * 4);
  memcpy (nindy_regs.fp_as_double, &registers[REGISTER_BYTE (FP0_REGNUM)], 8 * 4);
d484 1
a484 1
  ninRegsPut ((char *) &nindy_regs);
d495 1
a495 1
  return dcache_fetch (nindy_dcache, addr);
d506 1
a506 1
  dcache_poke (nindy_dcache, addr, word);
d518 1
a518 1
nindy_xfer_inferior_memory (memaddr, myaddr, len, should_write, target)
d523 1
a523 1
     struct target_ops *target;	/* ignored */
d527 1
a527 1
  register CORE_ADDR addr = memaddr & -sizeof (int);
d530 1
a530 1
  = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
d538 4
a541 5
      if (addr != memaddr || len < (int) sizeof (int))
	{
	  /* Need part of initial word -- fetch it.  */
	  buffer[0] = nindy_fetch_word (addr);
	}
d619 1
a619 1
  proceed ((CORE_ADDR) entry_pt, TARGET_SIGNAL_DEFAULT, 0);
d623 1
a623 1
reset_command (args, from_tty)
d629 1
a629 1
      error ("No target system to reset -- use 'target nindy' command.");
d631 1
a631 1
  if (query ("Really reset the target system?", 0, 0))
d643 1
a643 1
  return;			/* Ignore attempts to kill target system */
d670 3
a672 3
nindy_load (filename, from_tty)
     char *filename;
     int from_tty;
d677 1
a677 1
   */
d679 1
a679 1
  bfd *file = bfd_openr (filename, 0);
d681 23
a703 24
    {
      perror_with_name (filename);
      return;
    }

  if (!bfd_check_format (file, bfd_object))
    {
      error ("can't prove it's an object file\n");
      return;
    }

  for (s = file->sections; s; s = s->next)
    {
      if (s->flags & SEC_LOAD)
	{
	  char *buffer = xmalloc (s->_raw_size);
	  bfd_get_section_contents (file, s, buffer, 0, s->_raw_size);
	  printf ("Loading section %s, size %x vma %x\n",
		  s->name,
		  s->_raw_size,
		  s->vma);
	  ninMemPut (s->vma, buffer, s->_raw_size);
	  free (buffer);
	}
d705 2
a706 1
  bfd_close (file);
d731 1
a731 1
  while (target_stack->target_ops != &nindy_ops)	/* What is this crap??? */
d733 32
a764 37
      if (instream == stdin)
	{
	  printf_unfiltered ("\nAttach /dev/ttyNN -- specify NN, or \"quit\" to quit:  ");
	  gdb_flush (gdb_stdout);
	}
      fgets (ttyname, sizeof (ttyname) - 1, stdin);

      /* Strip leading and trailing whitespace */
      for (p = ttyname; isspace (*p); p++)
	{
	  ;
	}
      if (*p == '\0')
	{
	  return;		/* User just hit spaces or return, wants out */
	}
      for (p2 = p; !isspace (*p2) && (*p2 != '\0'); p2++)
	{
	  ;
	}
      *p2 = '\0';
      if (STREQ ("quit", p))
	{
	  exit (1);
	}

      if (catch_errors (nindy_open_stub, p, "", RETURN_MASK_ALL))
	{
	  /* Now that we have a tty open for talking to the remote machine,
	     download the executable file if one was specified.  */
	  if (exec_bfd)
	    {
	      catch_errors (load_stub, bfd_get_filename (exec_bfd), "",
			    RETURN_MASK_ALL);
	    }
	}
    }
d769 1
a769 1
struct target_ops nindy_ops;
d771 2
a772 2
static void
init_nindy_ops (void)
d774 2
a775 3
  nindy_ops.to_shortname = "nindy";
  "Remote serial target in i960 NINDY-specific protocol",
    nindy_ops.to_longname = "Use a remote i960 system running NINDY connected by a serial line.\n\
d779 5
a783 5
specified when you started GDB.";
  nindy_ops.to_doc = "";
  nindy_ops.to_open = nindy_open;
  nindy_ops.to_close = nindy_close;
  nindy_ops.to_attach = 0;
d786 1
a786 1
  nindy_ops.to_detach = nindy_detach;
d788 2
a789 2
  nindy_ops.to_resume = nindy_resume;
  nindy_ops.to_wait = nindy_wait;
d791 16
a806 16
  nindy_ops.to_fetch_registers = nindy_fetch_registers;
  nindy_ops.to_store_registers = nindy_store_registers;
  nindy_ops.to_prepare_to_store = nindy_prepare_to_store;
  nindy_ops.to_xfer_memory = nindy_xfer_inferior_memory;
  nindy_ops.to_files_info = nindy_files_info;
  nindy_ops.to_insert_breakpoint = memory_insert_breakpoint;
  nindy_ops.to_remove_breakpoint = memory_remove_breakpoint;
  nindy_ops.to_terminal_init = 0;
  nindy_ops.to_terminal_inferior = 0;
  nindy_ops.to_terminal_ours_for_output = 0;
  nindy_ops.to_terminal_ours = 0;
  nindy_ops.to_terminal_info = 0;	/* Terminal crud */
  nindy_ops.to_kill = nindy_kill;
  nindy_ops.to_load = nindy_load;
  nindy_ops.to_lookup_symbol = 0;	/* lookup_symbol */
  nindy_ops.to_create_inferior = nindy_create_inferior;
d824 5
a828 5
  nindy_ops.to_mourn_inferior = nindy_mourn_inferior;
  nindy_ops.to_can_run = 0;	/* can_run */
  nindy_ops.to_notice_signals = 0;	/* notice_signals */
  nindy_ops.to_thread_alive = 0;	/* to_thread_alive */
  nindy_ops.to_stop = 0;	/* to_stop */
d831 10
a840 10
  nindy_ops.to_stratum = process_stratum;
  nindy_ops.DONT_USE = 0;	/* next */
  nindy_ops.to_has_all_memory = 1;
  nindy_ops.to_has_memory = 1;
  nindy_ops.to_has_stack = 1;
  nindy_ops.to_has_registers = 1;
  nindy_ops.to_has_execution = 1;	/* all mem, mem, stack, regs, exec */
  nindy_ops.to_sections = 0;
  nindy_ops.to_sections_end = 0;	/* Section pointers */
  nindy_ops.to_magic = OPS_MAGIC;	/* Always the last thing */
d846 1
a846 1
  init_nindy_ops ();
@

