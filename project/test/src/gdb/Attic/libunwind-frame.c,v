head	1.38;
access;
symbols
	gdb_7_4_1-2012-04-26-release:1.32.2.1
	gdb_7_4-2012-01-24-release:1.32.2.1
	gdb_7_4-branch:1.32.0.2
	gdb_7_4-2011-12-13-branchpoint:1.32
	gdb_7_3_1-2011-09-04-release:1.31.2.1
	gdb_7_3-2011-07-26-release:1.31.2.1
	gdb_7_3-branch:1.31.0.2
	gdb_7_3-2011-04-01-branchpoint:1.31
	gdb_7_2-2010-09-02-release:1.27
	gdb_7_2-branch:1.27.0.2
	gdb_7_2-2010-07-07-branchpoint:1.27
	gdb_7_1-2010-03-18-release:1.25
	gdb_7_1-branch:1.25.0.2
	gdb_7_1-2010-02-18-branchpoint:1.25
	gdb_7_0_1-2009-12-22-release:1.24
	gdb_7_0-2009-10-06-release:1.24
	gdb_7_0-branch:1.24.0.2
	gdb_7_0-2009-09-16-branchpoint:1.24
	arc-sim-20090309:1.20
	msnyder-checkpoint-072509-branch:1.23.0.2
	msnyder-checkpoint-072509-branchpoint:1.23
	arc-insight_6_8-branch:1.20.0.6
	arc-insight_6_8-branchpoint:1.20
	insight_6_8-branch:1.20.0.4
	insight_6_8-branchpoint:1.20
	reverse-20081226-branch:1.22.0.10
	reverse-20081226-branchpoint:1.22
	multiprocess-20081120-branch:1.22.0.8
	multiprocess-20081120-branchpoint:1.22
	reverse-20080930-branch:1.22.0.6
	reverse-20080930-branchpoint:1.22
	reverse-20080717-branch:1.22.0.4
	reverse-20080717-branchpoint:1.22
	msnyder-reverse-20080609-branch:1.22.0.2
	msnyder-reverse-20080609-branchpoint:1.22
	drow-reverse-20070409-branch:1.11.0.2
	drow-reverse-20070409-branchpoint:1.11
	gdb_6_8-2008-03-27-release:1.20
	gdb_6_8-branch:1.20.0.2
	gdb_6_8-2008-02-26-branchpoint:1.20
	gdb_6_7_1-2007-10-29-release:1.18
	gdb_6_7-2007-10-10-release:1.18
	gdb_6_7-branch:1.18.0.2
	gdb_6_7-2007-09-07-branchpoint:1.18
	insight_6_6-20070208-release:1.9
	gdb_6_6-2006-12-18-release:1.9
	gdb_6_6-branch:1.9.0.12
	gdb_6_6-2006-11-15-branchpoint:1.9
	insight_6_5-20061003-release:1.9
	gdb-csl-symbian-6_4_50_20060226-12:1.8
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.9
	gdb-csl-symbian-6_4_50_20060226-11:1.8
	gdb-csl-sourcerygxx-4_1-17:1.8
	gdb-csl-20060226-branch-local-2:1.8
	gdb-csl-sourcerygxx-4_1-14:1.8
	gdb-csl-sourcerygxx-4_1-13:1.8
	gdb-csl-sourcerygxx-4_1-12:1.8
	gdb-csl-sourcerygxx-3_4_4-21:1.8
	gdb_6_5-20060621-release:1.9
	gdb-csl-sourcerygxx-4_1-9:1.8
	gdb-csl-sourcerygxx-4_1-8:1.8
	gdb-csl-sourcerygxx-4_1-7:1.8
	gdb-csl-arm-2006q1-6:1.8
	gdb-csl-sourcerygxx-4_1-6:1.8
	gdb-csl-symbian-6_4_50_20060226-10:1.8
	gdb-csl-symbian-6_4_50_20060226-9:1.8
	gdb-csl-symbian-6_4_50_20060226-8:1.8
	gdb-csl-coldfire-4_1-11:1.8
	gdb-csl-sourcerygxx-3_4_4-19:1.8
	gdb-csl-coldfire-4_1-10:1.8
	gdb_6_5-branch:1.9.0.10
	gdb_6_5-2006-05-14-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-5:1.8
	nickrob-async-20060513-branch:1.9.0.8
	nickrob-async-20060513-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-4:1.8
	msnyder-reverse-20060502-branch:1.9.0.6
	msnyder-reverse-20060502-branchpoint:1.9
	gdb-csl-morpho-4_1-4:1.8
	gdb-csl-sourcerygxx-3_4_4-17:1.8
	readline_5_1-import-branch:1.9.0.4
	readline_5_1-import-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.8
	gdb-csl-symbian-20060226-branch:1.8.0.6
	gdb-csl-symbian-20060226-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.8
	msnyder-reverse-20060331-branch:1.9.0.2
	msnyder-reverse-20060331-branchpoint:1.9
	gdb-csl-available-20060303-branch:1.8.0.4
	gdb-csl-available-20060303-branchpoint:1.8
	gdb-csl-20060226-branch:1.8.0.2
	gdb-csl-20060226-branchpoint:1.8
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.8
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.4
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.2
	gdb-csl-arm-20051020-branchpoint:1.7
	msnyder-tracepoint-checkpoint-branch:1.6.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.6
	gdb-csl-arm-20050325-2005-q1a:1.6
	csl-arm-20050325-branch:1.6.0.2
	csl-arm-20050325-branchpoint:1.6
	gdb-post-i18n-errorwarning-20050211:1.6
	gdb-pre-i18n-errorwarning-20050211:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.2
	gdb_6_3-20041019-branchpoint:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.4.0.6
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.2
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.2.0.14
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.12
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.10
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.8
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.6
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-branch:1.2.0.4
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-branch:1.2.0.2
	drow-cplus-merge-20031214:1.2;
locks; strict;
comment	@ * @;


1.38
date	2012.03.08.19.08.11;	author jkratoch;	state dead;
branches;
next	1.37;

1.37
date	2012.03.05.17.11.48;	author jkratoch;	state Exp;
branches;
next	1.36;

1.36
date	2012.03.04.19.22.47;	author jkratoch;	state Exp;
branches;
next	1.35;

1.35
date	2012.02.21.19.39.32;	author palves;	state Exp;
branches;
next	1.34;

1.34
date	2012.02.01.16.20.51;	author gingold;	state Exp;
branches;
next	1.33;

1.33
date	2012.01.04.08.17.05;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.08.16.16.41;	author sje;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2011.01.13.16.23.22;	author brobecke;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2011.01.13.16.23.11;	author brobecke;	state Exp;
branches;
next	1.29;

1.29
date	2011.01.05.22.22.49;	author msnyder;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.01.15.33.09;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.02.21.22.30;	author tromey;	state Exp;
branches;
next	1.26;

1.26
date	2010.05.14.23.41.04;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.01.07.31.36;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.13.16.28.28;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.06.18.37.46;	author brobecke;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.30.21.16.45;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.01.22.53.11;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.30.22.00.29;	author uweigand;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.23.18.08.35;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.12.15.21.27;	author schwab;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.06.19.35.02;	author schwab;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.31.20.57.41;	author uweigand;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.12.00.07.45;	author uweigand;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.11.16.09.57;	author jkratoch;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.08.15.28.17;	author schwab;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.7;

1.7
date	2005.06.08.21.54.23;	author jjohnstn;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.11.04.05.56;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.05.20.37.56;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.14.15.18.06;	author schwab;	state Exp;
branches;
next	1.3;

1.3
date	2004.03.15.20.38.08;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.13.03.51.56;	author kevinb;	state Exp;
branches
	1.2.2.1
	1.2.4.1
	1.2.10.1
	1.2.14.1;
next	1.1;

1.1
date	2003.11.14.21.17.51;	author jjohnstn;	state Exp;
branches;
next	;

1.2.2.1
date	2003.12.14.20.27.20;	author drow;	state Exp;
branches;
next	;

1.2.4.1
date	2003.12.16.00.00.40;	author carlton;	state Exp;
branches;
next	;

1.2.10.1
date	2004.03.27.17.37.50;	author drow;	state Exp;
branches;
next	1.2.10.2;

1.2.10.2
date	2004.09.16.17.01.10;	author drow;	state Exp;
branches;
next	;

1.2.14.1
date	2004.03.21.23.57.34;	author cagney;	state Exp;
branches;
next	;

1.31.2.1
date	2011.04.08.16.26.35;	author sje;	state Exp;
branches;
next	;

1.32.2.1
date	2012.01.06.04.43.19;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.38
log
@gdb/
	* libunwind-frame.c: Rename to ...
	* ia64-libunwind-tdep.c: ... here.
	* libunwind-frame.h: Rename to ...
	* ia64-libunwind-tdep.h: ... here.
	* Makefile.in (HFILES_NO_SRCDIR): Rename libunwind-frame.h to
	ia64-libunwind-tdep.h.
	(ALLDEPFILES): Rename libunwind-frame.c to ia64-libunwind-tdep.c.
	* README (--with-libunwind): Rename to ...
	(--with-libunwind-ia64): ... here, note it is ia64 specific now.
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac: New option --with-libunwind-ia64, make the
	AS_HELP_STRING ia64 specific.  Deprecate option --with-libunwind.
	Remove AC_DEFINE for HAVE_LIBUNWIND.
	* ia64-libunwind-tdep.c: Make the file top comment ia64 specific.
	Rename libunwind-frame.h #include to ia64-libunwind-tdep.h.
	Rename libunwind-frame in the general comment.
	* ia64-libunwind-tdep.h: Make the file top comment ia64 specific.
	Rename symbol LIBUNWIND_FRAME_H to IA64_TDEP_LIBUNWIND_FRAME_H.
	Move forward declarations inside #ifndef.  Rename libunwind-frame in
	the general comment.
	* ia64-tdep.c: Rename libunwind-frame.h #include to
	ia64-libunwind-tdep.h.
	(ia64_gdb2uw_regnum, ia64_uw2gdb_regnum, ia64_is_fpreg)
	(ia64_libunwind_descr): Rename libunwind-frame to
	ia64-libunwind-tdep in these function comments.
	* ia64-tdep.h: Rename libunwind-frame.h #include to
	ia64-libunwind-tdep.h.
	* ia64-vms-tdep.c (ia64_vms_libunwind_descr): Rename libunwind-frame to
	ia64-libunwind-tdep in that data comment.
@
text
@/* Frame unwinder for frames using the libunwind library.

   Copyright (C) 2003-2004, 2006-2012 Free Software Foundation, Inc.

   Written by Jeff Johnston, contributed by Red Hat Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"

#include "inferior.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "gdbcore.h"
#include "gdbtypes.h"
#include "symtab.h"
#include "objfiles.h"
#include "regcache.h"

#include <dlfcn.h>

#include "gdb_assert.h"
#include "gdb_string.h"

#include "libunwind-frame.h"

#include "complaints.h"

/* IA-64 is the only target that currently uses libunwind-frame.  Note
   how UNW_TARGET, UNW_OBJ, etc. are compile time constants below.
   Those come from libunwind's headers, and are target dependent.
   Also, some of libunwind's typedefs are target dependent, as e.g.,
   unw_word_t.  If some other target wants to use this, we will need
   to do some abstracting in order to make it possible to select which
   libunwind we're talking to at runtime (and have one per arch).  */

/* The following two macros are normally defined in <endian.h>.
   But systems such as ia64-hpux do not provide such header, so
   we just define them here if not already defined.  */
#ifndef __LITTLE_ENDIAN
#define __LITTLE_ENDIAN 1234
#endif
#ifndef __BIG_ENDIAN
#define __BIG_ENDIAN    4321
#endif

static int libunwind_initialized;
static struct gdbarch_data *libunwind_descr_handle;

/* Required function pointers from libunwind.  */
static int (*unw_get_reg_p) (unw_cursor_t *, unw_regnum_t, unw_word_t *);
static int (*unw_get_fpreg_p) (unw_cursor_t *, unw_regnum_t, unw_fpreg_t *);
static int (*unw_get_saveloc_p) (unw_cursor_t *, unw_regnum_t,
				 unw_save_loc_t *);
static int (*unw_is_signal_frame_p) (unw_cursor_t *);
static int (*unw_step_p) (unw_cursor_t *);
static int (*unw_init_remote_p) (unw_cursor_t *, unw_addr_space_t, void *);
static unw_addr_space_t (*unw_create_addr_space_p) (unw_accessors_t *, int);
static void (*unw_destroy_addr_space_p) (unw_addr_space_t);
static int (*unw_search_unwind_table_p) (unw_addr_space_t, unw_word_t,
					 unw_dyn_info_t *,
					 unw_proc_info_t *, int, void *);
static unw_word_t (*unw_find_dyn_list_p) (unw_addr_space_t, unw_dyn_info_t *,
					  void *);


struct libunwind_frame_cache
{
  CORE_ADDR base;
  CORE_ADDR func_addr;
  unw_cursor_t cursor;
  unw_addr_space_t as;
};

/* We need to qualify the function names with a platform-specific prefix
   to match the names used by the libunwind library.  The UNW_OBJ macro is
   provided by the libunwind.h header file.  */
#define STRINGIFY2(name)	#name
#define STRINGIFY(name)		STRINGIFY2(name)

#ifndef LIBUNWIND_SO
/* Use the stable ABI major version number.  `libunwind-ia64.so' is a link time
   only library, not a runtime one.  */
#define LIBUNWIND_SO "libunwind-" STRINGIFY(UNW_TARGET) ".so.8"

/* Provide also compatibility with older .so.  The two APIs are compatible, .8
   is only extended a bit, GDB does not use the extended API at all.  */
#define LIBUNWIND_SO_7 "libunwind-" STRINGIFY(UNW_TARGET) ".so.7"
#endif

static char *get_reg_name = STRINGIFY(UNW_OBJ(get_reg));
static char *get_fpreg_name = STRINGIFY(UNW_OBJ(get_fpreg));
static char *get_saveloc_name = STRINGIFY(UNW_OBJ(get_save_loc));
static char *is_signal_frame_name = STRINGIFY(UNW_OBJ(is_signal_frame));
static char *step_name = STRINGIFY(UNW_OBJ(step));
static char *init_remote_name = STRINGIFY(UNW_OBJ(init_remote));
static char *create_addr_space_name = STRINGIFY(UNW_OBJ(create_addr_space));
static char *destroy_addr_space_name = STRINGIFY(UNW_OBJ(destroy_addr_space));
static char *search_unwind_table_name
  = STRINGIFY(UNW_OBJ(search_unwind_table));
static char *find_dyn_list_name = STRINGIFY(UNW_OBJ(find_dyn_list));

static struct libunwind_descr *
libunwind_descr (struct gdbarch *gdbarch)
{
  return gdbarch_data (gdbarch, libunwind_descr_handle);
}

static void *
libunwind_descr_init (struct gdbarch *gdbarch)
{
  struct libunwind_descr *descr
    = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct libunwind_descr);

  return descr;
}

void
libunwind_frame_set_descr (struct gdbarch *gdbarch,
			   struct libunwind_descr *descr)
{
  struct libunwind_descr *arch_descr;

  gdb_assert (gdbarch != NULL);

  arch_descr = gdbarch_data (gdbarch, libunwind_descr_handle);

  if (arch_descr == NULL)
    {
      /* First time here.  Must initialize data area.  */
      arch_descr = libunwind_descr_init (gdbarch);
      deprecated_set_gdbarch_data (gdbarch,
				   libunwind_descr_handle, arch_descr);
    }

  /* Copy new descriptor info into arch descriptor.  */
  arch_descr->gdb2uw = descr->gdb2uw;
  arch_descr->uw2gdb = descr->uw2gdb;
  arch_descr->is_fpreg = descr->is_fpreg;
  arch_descr->accessors = descr->accessors;
  arch_descr->special_accessors = descr->special_accessors;
}

static struct libunwind_frame_cache *
libunwind_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  unw_accessors_t *acc;
  unw_addr_space_t as;
  unw_word_t fp;
  unw_regnum_t uw_sp_regnum;
  struct libunwind_frame_cache *cache;
  struct libunwind_descr *descr;
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  int i, ret;

  if (*this_cache)
    return *this_cache;

  /* Allocate a new cache.  */
  cache = FRAME_OBSTACK_ZALLOC (struct libunwind_frame_cache);

  cache->func_addr = get_frame_func (this_frame);
  if (cache->func_addr == 0)
    /* This can happen when the frame corresponds to a function for which
       there is no debugging information nor any entry in the symbol table.
       This is probably a static function for which an entry in the symbol
       table was not created when the objfile got linked (observed in
       libpthread.so on ia64-hpux).

       The best we can do, in that case, is use the frame PC as the function
       address.  We don't need to give up since we still have the unwind
       record to help us perform the unwinding.  There is also another
       compelling to continue, because abandonning now means stopping
       the backtrace, which can never be helpful for the user.  */
    cache->func_addr = get_frame_pc (this_frame);

  /* Get a libunwind cursor to the previous frame.
  
     We do this by initializing a cursor.  Libunwind treats a new cursor
     as the top of stack and will get the current register set via the
     libunwind register accessor.  Now, we provide the platform-specific
     accessors and we set up the register accessor to use the frame
     register unwinding interfaces so that we properly get the registers
     for the current frame rather than the top.  We then use the unw_step
     function to move the libunwind cursor back one frame.  We can later
     use this cursor to find previous registers via the unw_get_reg
     interface which will invoke libunwind's special logic.  */
  descr = libunwind_descr (gdbarch);
  acc = descr->accessors;
  as =  unw_create_addr_space_p (acc,
				 gdbarch_byte_order (gdbarch)
				 == BFD_ENDIAN_BIG
				 ? __BIG_ENDIAN
				 : __LITTLE_ENDIAN);

  unw_init_remote_p (&cache->cursor, as, this_frame);
  if (unw_step_p (&cache->cursor) < 0)
    {
      unw_destroy_addr_space_p (as);
      return NULL;
    }

  /* To get base address, get sp from previous frame.  */
  uw_sp_regnum = descr->gdb2uw (gdbarch_sp_regnum (gdbarch));
  ret = unw_get_reg_p (&cache->cursor, uw_sp_regnum, &fp);
  if (ret < 0)
    {
      unw_destroy_addr_space_p (as);
      error (_("Can't get libunwind sp register."));
    }

  cache->base = (CORE_ADDR)fp;
  cache->as = as;

  *this_cache = cache;
  return cache;
}

void
libunwind_frame_dealloc_cache (struct frame_info *self, void *this_cache)
{
  struct libunwind_frame_cache *cache = this_cache;

  if (cache->as)
    unw_destroy_addr_space_p (cache->as);
}

unw_word_t
libunwind_find_dyn_list (unw_addr_space_t as, unw_dyn_info_t *di, void *arg)
{
  return unw_find_dyn_list_p (as, di, arg);
}

/* Verify if there is sufficient libunwind information for the frame to use
   libunwind frame unwinding.  */
int
libunwind_frame_sniffer (const struct frame_unwind *self,
                         struct frame_info *this_frame, void **this_cache)
{
  unw_cursor_t cursor;
  unw_accessors_t *acc;
  unw_addr_space_t as;
  struct libunwind_descr *descr;
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  int i, ret;

  /* To test for libunwind unwind support, initialize a cursor to
     the current frame and try to back up.  We use this same method
     when setting up the frame cache (see libunwind_frame_cache()).
     If libunwind returns success for this operation, it means that
     it has found sufficient libunwind unwinding information to do so.  */

  descr = libunwind_descr (gdbarch);
  acc = descr->accessors;
  as =  unw_create_addr_space_p (acc,
				 gdbarch_byte_order (gdbarch)
				 == BFD_ENDIAN_BIG
				 ? __BIG_ENDIAN
				 : __LITTLE_ENDIAN);

  ret = unw_init_remote_p (&cursor, as, this_frame);

  if (ret < 0)
    {
      unw_destroy_addr_space_p (as);
      return 0;
    }

 
  /* Check to see if we have libunwind info by checking if we are in a 
     signal frame.  If it doesn't return an error, we have libunwind info
     and can use libunwind.  */
  ret = unw_is_signal_frame_p (&cursor);
  unw_destroy_addr_space_p (as);

  if (ret < 0)
    return 0;

  return 1;
}

void
libunwind_frame_this_id (struct frame_info *this_frame, void **this_cache,
		         struct frame_id *this_id)
{
  struct libunwind_frame_cache *cache =
    libunwind_frame_cache (this_frame, this_cache);

  if (cache != NULL)
    (*this_id) = frame_id_build (cache->base, cache->func_addr);
}

struct value *
libunwind_frame_prev_register (struct frame_info *this_frame,
                               void **this_cache, int regnum)
{
  struct libunwind_frame_cache *cache =
    libunwind_frame_cache (this_frame, this_cache);
  struct gdbarch *gdbarch = get_frame_arch (this_frame);

  void *ptr;
  unw_cursor_t *c;
  unw_save_loc_t sl;
  int i, ret;
  unw_word_t intval;
  unw_fpreg_t fpval;
  unw_regnum_t uw_regnum;
  struct libunwind_descr *descr;
  struct value *val = NULL;

  if (cache == NULL)
    return frame_unwind_got_constant (this_frame, regnum, 0);
  
  /* Convert from gdb register number to libunwind register number.  */
  descr = libunwind_descr (get_frame_arch (this_frame));
  uw_regnum = descr->gdb2uw (regnum);

  gdb_assert (regnum >= 0);

  if (!target_has_registers)
    error (_("No registers."));

  if (uw_regnum < 0)
    return frame_unwind_got_constant (this_frame, regnum, 0);

  if (unw_get_saveloc_p (&cache->cursor, uw_regnum, &sl) < 0)
    return frame_unwind_got_constant (this_frame, regnum, 0);

  switch (sl.type)
    {
    case UNW_SLT_MEMORY:
      val = frame_unwind_got_memory (this_frame, regnum, sl.u.addr);
      break;

    case UNW_SLT_REG:
      val = frame_unwind_got_register (this_frame, regnum,
                                       descr->uw2gdb (sl.u.regnum));
      break;
    case UNW_SLT_NONE:
      {
        /* The register is not stored at a specific memory address nor
           inside another register.  So use libunwind to fetch the register
           value for us, and create a constant value with the result.  */
        if (descr->is_fpreg (uw_regnum))
          {
            ret = unw_get_fpreg_p (&cache->cursor, uw_regnum, &fpval);
            if (ret < 0)
              return frame_unwind_got_constant (this_frame, regnum, 0);
            val = frame_unwind_got_bytes (this_frame, regnum,
                                          (gdb_byte *) &fpval);
          }
        else
          {
            ret = unw_get_reg_p (&cache->cursor, uw_regnum, &intval);
            if (ret < 0)
              return frame_unwind_got_constant (this_frame, regnum, 0);
            val = frame_unwind_got_constant (this_frame, regnum, intval);
          }
        break;
      }
    }

  return val;
} 

/* The following is a glue routine to call the libunwind unwind table
   search function to get unwind information for a specified ip address.  */ 
int
libunwind_search_unwind_table (void *as, long ip, void *di,
			       void *pi, int need_unwind_info, void *args)
{
  return unw_search_unwind_table_p (*(unw_addr_space_t *)as, (unw_word_t )ip, 
				    di, pi, need_unwind_info, args);
}

/* Verify if we are in a sigtramp frame and we can use libunwind to unwind.  */
int
libunwind_sigtramp_frame_sniffer (const struct frame_unwind *self,
                                  struct frame_info *this_frame,
                                  void **this_cache)
{
  unw_cursor_t cursor;
  unw_accessors_t *acc;
  unw_addr_space_t as;
  struct libunwind_descr *descr;
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  int i, ret;

  /* To test for libunwind unwind support, initialize a cursor to the
     current frame and try to back up.  We use this same method when
     setting up the frame cache (see libunwind_frame_cache()).  If
     libunwind returns success for this operation, it means that it
     has found sufficient libunwind unwinding information to do
     so.  */

  descr = libunwind_descr (gdbarch);
  acc = descr->accessors;
  as =  unw_create_addr_space_p (acc,
				 gdbarch_byte_order (gdbarch)
				 == BFD_ENDIAN_BIG
				 ? __BIG_ENDIAN
				 : __LITTLE_ENDIAN);

  ret = unw_init_remote_p (&cursor, as, this_frame);

  if (ret < 0)
    {
      unw_destroy_addr_space_p (as);
      return 0;
    }

  /* Check to see if we are in a signal frame.  */
  ret = unw_is_signal_frame_p (&cursor);
  unw_destroy_addr_space_p (as);
  if (ret > 0)
    return 1;

  return 0;
}

/* The following routine is for accessing special registers of the top frame.
   A special set of accessors must be given that work without frame info.
   This is used by ia64 to access the rse registers r32-r127.  While they
   are usually located at BOF, this is not always true and only the libunwind
   info can decipher where they actually are.  */
int
libunwind_get_reg_special (struct gdbarch *gdbarch, struct regcache *regcache,
			   int regnum, void *buf)
{
  unw_cursor_t cursor;
  unw_accessors_t *acc;
  unw_addr_space_t as;
  struct libunwind_descr *descr;
  int ret;
  unw_regnum_t uw_regnum;
  unw_word_t intval;
  unw_fpreg_t fpval;
  void *ptr;


  descr = libunwind_descr (gdbarch);
  acc = descr->special_accessors;
  as =  unw_create_addr_space_p (acc,
				 gdbarch_byte_order (gdbarch)
				 == BFD_ENDIAN_BIG
				 ? __BIG_ENDIAN
				 : __LITTLE_ENDIAN);

  ret = unw_init_remote_p (&cursor, as, regcache);
  if (ret < 0)
    {
      unw_destroy_addr_space_p (as);
      return -1;
    }

  uw_regnum = descr->gdb2uw (regnum);

  if (descr->is_fpreg (uw_regnum))
    {
      ret = unw_get_fpreg_p (&cursor, uw_regnum, &fpval);
      ptr = &fpval;
    }
  else
    {
      ret = unw_get_reg_p (&cursor, uw_regnum, &intval);
      ptr = &intval;
    }

  unw_destroy_addr_space_p (as);

  if (ret < 0)
    return -1;

  if (buf)
    memcpy (buf, ptr, register_size (gdbarch, regnum));

  return 0;
}
  
static int
libunwind_load (void)
{
  void *handle;
  char *so_error = NULL;

  handle = dlopen (LIBUNWIND_SO, RTLD_NOW);
  if (handle == NULL)
    {
      so_error = xstrdup (dlerror ());
#ifdef LIBUNWIND_SO_7
      handle = dlopen (LIBUNWIND_SO_7, RTLD_NOW);
#endif /* LIBUNWIND_SO_7 */
    }
  if (handle == NULL)
    {
      fprintf_unfiltered (gdb_stderr, _("[GDB failed to load %s: %s]\n"),
			  LIBUNWIND_SO, so_error);
#ifdef LIBUNWIND_SO_7
      fprintf_unfiltered (gdb_stderr, _("[GDB failed to load %s: %s]\n"),
			  LIBUNWIND_SO_7, dlerror ());
#endif /* LIBUNWIND_SO_7 */
    }
  xfree (so_error);
  if (handle == NULL)
    return 0;

  /* Initialize pointers to the dynamic library functions we will use.  */

  unw_get_reg_p = dlsym (handle, get_reg_name);
  if (unw_get_reg_p == NULL)
    return 0;

  unw_get_fpreg_p = dlsym (handle, get_fpreg_name);
  if (unw_get_fpreg_p == NULL)
    return 0;

  unw_get_saveloc_p = dlsym (handle, get_saveloc_name);
  if (unw_get_saveloc_p == NULL)
    return 0;

  unw_is_signal_frame_p = dlsym (handle, is_signal_frame_name);
  if (unw_is_signal_frame_p == NULL)
    return 0;

  unw_step_p = dlsym (handle, step_name);
  if (unw_step_p == NULL)
    return 0;

  unw_init_remote_p = dlsym (handle, init_remote_name);
  if (unw_init_remote_p == NULL)
    return 0;

  unw_create_addr_space_p = dlsym (handle, create_addr_space_name);
  if (unw_create_addr_space_p == NULL)
    return 0;

  unw_destroy_addr_space_p = dlsym (handle, destroy_addr_space_name);
  if (unw_destroy_addr_space_p == NULL)
    return 0;

  unw_search_unwind_table_p = dlsym (handle, search_unwind_table_name);
  if (unw_search_unwind_table_p == NULL)
    return 0;

  unw_find_dyn_list_p = dlsym (handle, find_dyn_list_name);
  if (unw_find_dyn_list_p == NULL)
    return 0;
   
  return 1;
}

int
libunwind_is_initialized (void)
{
  return libunwind_initialized;
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_libunwind_frame (void);

void
_initialize_libunwind_frame (void)
{
  libunwind_descr_handle
    = gdbarch_data_register_post_init (libunwind_descr_init);

  libunwind_initialized = libunwind_load ();
}
@


1.37
log
@gdb/
	* libunwind-frame.c (LIBUNWIND_SO): Change .7 to .8.
	[!LIBUNWIND_SO] (LIBUNWIND_SO_7): New #define.
	(libunwind_load): New variable so_error, use it for dlerror.  Try to
	load also LIBUNWIND_SO_7.
@
text
@@


1.36
log
@gdb/
	Removed unused code.
	* libunwind-frame.c (libunwind_frame_unwind)
	(libunwind_frame_base_address): Remove.
	* libunwind-frame.h (libunwind_frame_base_address): Remove declaration.
@
text
@d98 5
a102 1
#define LIBUNWIND_SO "libunwind-" STRINGIFY(UNW_TARGET) ".so.7"
d498 1
d503 7
d511 5
a515 2
                          LIBUNWIND_SO, dlerror ());
      return 0;
d517 3
@


1.35
log
@2012-02-21  Tristan Gingold  <gingold@@adacore.com>
	    Pedro Alves  <palves@@redhat.com>

	* ia64-tdep.c: Do not include libunwind-ia64.h.
	* libunwind-frame.h: Remove #ifdef HAVE_LIBUNWIND_H guard.
	Include libunwind-ia64.h instead of libunwind.h.
	* configure.ac (--with-libunwind, $enable_libunwind): Don't check
	for libunwind.h existence.
	* configure, config.in: Regenerate.
@
text
@a243 11
static const struct frame_unwind libunwind_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  libunwind_frame_this_id,
  libunwind_frame_prev_register,
  NULL,
  libunwind_frame_sniffer,
  libunwind_frame_dealloc_cache,
};

a375 11
CORE_ADDR
libunwind_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct libunwind_frame_cache *cache =
    libunwind_frame_cache (this_frame, this_cache);

  if (cache == NULL)
    return (CORE_ADDR)NULL;
  return cache->base;
}

@


1.34
log
@2012-02-01  Tristan Gingold  <gingold@@adacore.com>

	* libunwind-frame.c (libunwind_load): Display message if dlopen
	failed.
@
text
@d43 8
@


1.33
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d511 5
a515 1
    return 0;
@


1.32
log
@2011-04-08  Steve Ellcey  <sje@@cup.hp.com>

	* Add default_frame_unwind_stop_reason value to libunwind_frame_unwind
	initalization.
@
text
@d3 1
a3 2
   Copyright (C) 2003, 2004, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.32.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2003-2004, 2006-2012 Free Software Foundation, Inc.
@


1.31
log
@[libunwind-frame] handle functions with no minimal symbol/debug info.

This is something that I am seeing on ia64-hpux while trying to
backtrace from a thread that's doing a wait:

    (gdb) task 2
    [Switching to task 2]
    0x9fffffffef52f590 in __ksleep () from /[...]/libc.so.1
    (gdb) bt
    #0  0x9fffffffef52f590 in __ksleep () from /[...]/libc.so.1
    #1  0x9fffffffef73c870 in __sleep_1x1 () from /[...]/libpthread.so.1
    #2  0x9fffffffef738fe0 in __mxn_sleep () from /[...]/libpthread.so.1
    #3  0x9fffffffef675e90 in ?? () from /[...]/libpthread.so.1

The backtrace is incomplete and stops at frame #3, but there are in fact
a few more frames.

The reason why we stopped the backtrace is related to the fact that
we were not able to determine the start address of the function
corresponding to the frame PC.  This is visible at the user level
thanks to the "??" that GDB displayed for frame 3.

We have the following code in libunwind-frame.c:libunwind_frame_cache
which explicitly returns a NULL cache when we couldn't determine the
frame's function address, immediately triggering an end-of-stack
frame_id, thus terminating the backtrace:

   /* We can assume we are unwinding a normal frame.  Even if this is
      for a signal trampoline, ia64 signal "trampolines" use a normal
      subroutine call to start the signal handler.  */
   cache->func_addr = get_frame_func (this_frame);
   if (cache->func_addr == 0
       && get_next_frame (this_frame)
       && get_frame_type (get_next_frame (this_frame)) == NORMAL_FRAME)
     return NULL;

As explained in the comment, I think we can still go on, and use
the unwind record to do the debugging.  This change imlements this
change, and allows us to get the full backtrace.

gdb/ChangeLog:

        * libunwind-frame.c (libunwind_frame_cache): Do not return NULL
        if we could not determine the frame's function address.  Instead,
        use the frame's PC, and then continue.
@
text
@d240 1
@


1.31.2.1
log
@2011-04-08  Steve Ellcey  <sje@@cup.hp.com>

	* Add default_frame_unwind_stop_reason value to libunwind_frame_unwind
	initalization.
@
text
@a239 1
  default_frame_unwind_stop_reason,
@


1.30
log
@Make sure __LITTLE_ENDIAN/__BIG_ENDIAN are defined in libunwind-frame.c

These macros do not seem to exist on ia64-hpux.

gdb/ChangeLog:

        * libunwind-frame.c (__LITTLE_ENDIAN, __BIG_ENDIAN): Define if
        not already defined.
@
text
@a164 3
  /* We can assume we are unwinding a normal frame.  Even if this is
     for a signal trampoline, ia64 signal "trampolines" use a normal
     subroutine call to start the signal handler.  */
d166 13
a178 4
  if (cache->func_addr == 0
      && get_next_frame (this_frame)
      && get_frame_type (get_next_frame (this_frame)) == NORMAL_FRAME)
    return NULL;
@


1.29
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d44 10
@


1.28
log
@run copyright.sh for 2011.
@
text
@d50 2
a51 1
static int (*unw_get_saveloc_p) (unw_cursor_t *, unw_regnum_t, unw_save_loc_t *);
d57 2
a58 1
static int (*unw_search_unwind_table_p) (unw_addr_space_t, unw_word_t, unw_dyn_info_t *,
d92 2
a93 1
static char *search_unwind_table_name = STRINGIFY(UNW_OBJ(search_unwind_table));
d105 2
a106 2
  struct libunwind_descr *descr = GDBARCH_OBSTACK_ZALLOC (gdbarch,
							  struct libunwind_descr);
d112 2
a113 1
libunwind_frame_set_descr (struct gdbarch *gdbarch, struct libunwind_descr *descr)
d125 2
a126 1
      deprecated_set_gdbarch_data (gdbarch, libunwind_descr_handle, arch_descr);
d554 2
a555 1
  libunwind_descr_handle = gdbarch_data_register_post_init (libunwind_descr_init);
@


1.27
log
@	PR exp/11780:
	* libunwind-frame.c (libunwind_frame_prev_register): Don't set
	value as optimized-out.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2006, 2007, 2008, 2009, 2010
@


1.26
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* jv-lang.c: White space.
	* jv-typeprint.c: White space.
	* jv-valprint.c: White space.
	* language.c: White space.
	* libunwind-frame.c: White space.
	* linespec.c: White space.
	* linux-nat.c: White space.
	* linux-record.c: White space.
	* linux-thread-db.c: White space.
@
text
@a350 1
        set_value_optimized_out (val, 1);
@


1.25
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d104 1
d205 1
@


1.24
log
@        gdb/
        * frame.c (get_frame_id): Default to outer_frame_id if the this_id
        method does not supply an ID.  Assert that the result is not
        null_frame_id.
        (outer_frame_id): New.
        (frame_id_p): Accept outer_frame_id.
        (frame_id_eq): Allow outer_frame_id to be equal to itself.
        (frame_find_by_id): Revert previous local workarounds.
        (get_prev_frame_1): Adjust end-of-stack check to test outer_frame_id.
        * frame.h (null_frame_id, frame_id_p): Update comments.
        (outer_frame_id): Declare.
        * infrun.c (handle_inferior_event): Do not treat all steps from the
        outermost frame as subroutine calls.

        * libunwind-frame.c (libunwind_frame_this_id): Do not clear THIS_ID.
        * hppa-tdep.c (hppa_stub_frame_this_id): Likewise.
        * ia64-tdep.c (ia64_frame_this_id): Likewise.
        (ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id):
        Use outer_frame_id instead of null_frame_id.
        * amd64obsd-tdep.c (amd64obsd_trapframe_cache): Use outer_frame_id.
        * i386obsd-tdep.c (i386obsd_trapframe_cache): Likewise.
        * inline-frame.c (inline_frame_this_id): Refuse outer_frame_id.
        * thread.c (restore_selected_frame): Update comment and remove
        frame_id_p check.

        gdb/doc/
        * gdbint.texinfo (Unwinding the Frame ID): Reference outer_frame_id.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2006, 2007, 2008, 2009
@


1.23
log
@        Updated copyright notices for most files.
@
text
@a280 2
  else
    (*this_id) = null_frame_id;
@


1.22
log
@        * frame-unwind.c (frame_unwind_got_bytes): New function.
        * frame-unwind.h (frame_unwind_got_bytes): Add declaration.
        * libunwind-frame.h, libunwind-frame.c, ia64-tdep.c: Update
        for unwinder changes.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2004, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.21
log
@	Convert frame unwinders to use the current frame and
	"struct value".

	* frame.c (frame_debug): Make global.
	(get_frame_id): Pass this frame to unwinder routines.
	(frame_pc_unwind): Remove unused unwind->prev_pc support.
	(do_frame_register_read): Do not discard the return value of
	frame_register_read.
	(frame_register_unwind): Remove debug messages.  Use
	frame_unwind_register_value.
	(frame_unwind_register_value, get_frame_register_value): New
	functions.
	(create_new_frame, get_frame_base_address, get_frame_locals_address)
	(get_frame_args_address, get_frame_type): Pass this frame to
	unwinder routines.
	(frame_cleanup_after_sniffer, frame_prepare_for_sniffer): New
	functions.
	* frame.h: Update comments.
	(frame_debug, frame_unwind_register_value, get_frame_register_value)
	(frame_prepare_for_sniffer): Declare.
	* frame-unwind.h: Update comments and parameter names.
	(default_frame_sniffer): Declare.
	(frame_prev_register_ftype): Return a struct value *.
	(struct frame_unwind): Remove prev_pc member.
	(frame_unwind_sniffer_ftype, frame_unwind_append_sniffer): Delete.
	(frame_unwind_append_unwinder, frame_unwind_got_optimized)
	(frame_unwind_got_register, frame_unwind_got_memory)
	(frame_unwind_got_constant, frame_unwind_got_address): Declare.
	* frame-base.h: Update comments and parameter names.
	* valops.c (value_fetch_lazy): Use get_frame_register_value.  Iterate
	if necessary.  Add debugging output.
	* sentinel-frame.c (sentinel_frame_prev_register)
	(sentinel_frame_this_id): Update for new signature.
	(sentinel_frame_prev_pc): Delete.
	(sentinel_frame_unwinder): Remove prev_pc.
	* ia64-tdep.c (ia64_libunwind_frame_unwind): Do not initialize
	prev_pc.
	* libunwind-frame.c (libunwind_frame_unwind): Likewise.
	* frame-unwind.c (struct frame_unwind_table_entry): Remove sniffer.
	(frame_unwind_append_sniffer): Delete.
	(frame_unwind_append_unwinder): New function.
	(frame_unwind_find_by_frame): Take this frame.  Only use sniffers
	from unwinders.  Use frame_prepare_for_sniffer.
	(default_frame_sniffer, frame_unwind_got_optimized)
	(frame_unwind_got_register, frame_unwind_got_memory)
	(frame_unwind_got_constant, frame_unwind_got_address): New functions.
	* dummy-frame.c (dummy_frame_sniffer): Use gdbarch_dummy_id.
	(dummy_frame_prev_register, dummy_frame_this_id): Update for new
	signature.
	* gdbarch.sh: Replace unwind_dummy_id with dummy_id.
	* gdbarch.c, gdbarch.c: Regenerated.
	* frame-base.c (default_frame_base_address)
	(default_frame_locals_address, default_frame_args_address): Update
	for new signature.
	(frame_base_find_by_frame): Pass this frame to unwinder routines.
	* infcall.c (call_function_by_hand): Update comments.
	* Makefile.in (frame-unwind.o): Update dependencies.

	* gdbint.texinfo (Stack Frames): New chapter.
	(Algorithms): Move Frames text to the new chapter.
	(Target Conditionals): Delete SAVE_DUMMY_FRAME_TOS.  Document
	gdbarch_dummy_id instead of gdbarch_unwind_dummy_id.
@
text
@d69 3
a71 3
/* We need to qualify the function names with a platform-specific prefix to match 
   the names used by the libunwind library.  The UNW_OBJ macro is provided by the
   libunwind.h header file.  */
d131 1
a131 1
libunwind_frame_cache (struct frame_info *next_frame, void **this_cache)
d139 1
a139 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d151 1
a151 1
  cache->func_addr = frame_func_unwind (next_frame, NORMAL_FRAME);
d153 2
a154 2
      && frame_relative_level (next_frame) > 0
      && get_frame_type (next_frame) != SIGTRAMP_FRAME)
d157 11
a167 8
  /* Get a libunwind cursor to the previous frame.  We do this by initializing
     a cursor.  Libunwind treats a new cursor as the top of stack and will get
     the current register set via the libunwind register accessor.  Now, we
     provide the platform-specific accessors and we set up the register accessor to use
     the frame register unwinding interfaces so that we properly get the registers for
     the current frame rather than the top.  We then use the  unw_step function to 
     move the libunwind cursor back one frame.  We can later use this cursor to find previous 
     registers via the unw_get_reg interface which will invoke libunwind's special logic.  */
d176 1
a176 1
  unw_init_remote_p (&cache->cursor, as, next_frame);
d219 2
a220 2
  NULL,
  libunwind_frame_dealloc_cache
d225 3
a227 2
const struct frame_unwind *
libunwind_frame_sniffer (struct frame_info *next_frame)
d233 1
a233 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d236 5
a240 4
  /* To test for libunwind unwind support, initialize a cursor to the current frame and try to back
     up.  We use this same method when setting up the frame cache (see libunwind_frame_cache()).
     If libunwind returns success for this operation, it means that it has found sufficient
     libunwind unwinding information to do so.  */
d250 1
a250 1
  ret = unw_init_remote_p (&cursor, as, next_frame);
d255 1
a255 1
      return NULL;
d266 1
a266 1
    return NULL;
d268 1
a268 1
  return &libunwind_frame_unwind;
d272 2
a273 2
libunwind_frame_this_id (struct frame_info *next_frame, void **this_cache,
		      struct frame_id *this_id)
d276 1
a276 1
    libunwind_frame_cache (next_frame, this_cache);
d284 3
a286 5
void
libunwind_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			       int regnum, int *optimizedp,
			       enum lval_type *lvalp, CORE_ADDR *addrp,
			       int *realnump, gdb_byte *valuep)
d289 2
a290 2
    libunwind_frame_cache (next_frame, this_cache);
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d300 1
d303 1
a303 1
    return;
d306 1
a306 1
  descr = libunwind_descr (get_frame_arch (next_frame));
a313 8
  *optimizedp = 0;
  *addrp = 0;
  *lvalp = not_lval;
  *realnump = -1;

  if (valuep)
    memset (valuep, 0, register_size (gdbarch, regnum));

d315 1
a315 21
    return;

  /* To get the previous register, we use the libunwind register APIs with
     the cursor we have already pushed back to the previous frame.  */

  if (descr->is_fpreg (uw_regnum))
    {
      ret = unw_get_fpreg_p (&cache->cursor, uw_regnum, &fpval);
      ptr = &fpval;
    }
  else
    {
      ret = unw_get_reg_p (&cache->cursor, uw_regnum, &intval);
      ptr = &intval;
    }

  if (ret < 0)
    return;

  if (valuep)
    memcpy (valuep, ptr, register_size (gdbarch, regnum));
d318 1
a318 1
    return;
a321 4
    case UNW_SLT_NONE:
      *optimizedp = 1;
      break;

d323 1
a323 2
      *lvalp = lval_memory;
      *addrp = sl.u.addr;
d327 2
a328 2
      *lvalp = lval_register;
      *realnump = regnum;
d330 23
d354 2
d359 1
a359 1
libunwind_frame_base_address (struct frame_info *next_frame, void **this_cache)
d362 1
a362 1
    libunwind_frame_cache (next_frame, this_cache);
d380 4
a383 2
const struct frame_unwind *
libunwind_sigtramp_frame_sniffer (struct frame_info *next_frame)
d389 1
a389 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d407 1
a407 1
  ret = unw_init_remote_p (&cursor, as, next_frame);
d412 1
a412 1
      return NULL;
d419 1
a419 1
    return &libunwind_frame_unwind;
d421 1
a421 1
  return NULL;
@


1.20
log
@	Updated copyright notices for most files.
@
text
@a216 1
  NULL,
@


1.19
log
@2007-10-30  Markus Deuling  <deuling@@de.ibm.com>

	* libunwind-frame.c (libunwind_frame_sniffer)
	libunwind_frame_prev_register, libunwind_sigtramp_frame_sniffer)
	(libunwind_frame_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(libunwind_get_reg_special): Replace current_gdbarch by gdbarch.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2006, 2007 Free Software Foundation, Inc.
@


1.18
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d139 1
d165 1
a165 1
  descr = libunwind_descr (get_frame_arch (next_frame));
d168 1
a168 1
				 gdbarch_byte_order (current_gdbarch)
d181 1
a181 1
  uw_sp_regnum = descr->gdb2uw (gdbarch_sp_regnum (current_gdbarch));
d230 1
d238 1
a238 1
  descr = libunwind_descr (get_frame_arch (next_frame));
d241 1
a241 1
				 gdbarch_byte_order (current_gdbarch)
d288 1
d317 1
a317 1
    memset (valuep, 0, register_size (current_gdbarch, regnum));
d340 1
a340 1
    memcpy (valuep, ptr, register_size (current_gdbarch, regnum));
d392 1
d402 1
a402 1
  descr = libunwind_descr (get_frame_arch (next_frame));
d405 1
a405 1
				 gdbarch_byte_order (current_gdbarch)
d450 1
a450 1
				 gdbarch_byte_order (current_gdbarch)
d481 1
a481 1
    memcpy (buf, ptr, register_size (current_gdbarch, regnum));
@


1.17
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.16
log
@	* frame-unwind.h (frame_dealloc_cache_ftype): Define.
	(struct frame_unwind): Add dealloc_cache.
	* frame.c (reinit_frame_cache): Call dealloc_cache on all caches.

	* libunwind-frame.h (libunwind_frame_dealloc_cache): Declare.
	* libunwind-frame.c (libunwind_frame_dealloc_cache): Define.
	(libunwind_frame_unwind): Set dealloc_cache.
	* ia64-tdep.c (ia64_libunwind_frame_unwind): Set dealloc_cache.
@
text
@d182 1
a182 1
  uw_sp_regnum = descr->gdb2uw (SP_REGNUM);
@


1.15
log
@	* libunwind-frame.c (unw_destroy_addr_space_p): Define.
	(destroy_addr_space_name): Define.
	(libunwind_load): Get address of destroy_addr_space function.
	(libunwind_frame_cache): Destroy unw_addr_space_t object before
	returning unsuccessfully.
	(libunwind_frame_sniffer): Destroy unw_addr_space_t object before
	returning.
	(libunwind_sigtramp_frame_sniffer): Likewise.
	(libunwind_get_reg_special): Likewise.
@
text
@d68 1
d191 1
d197 8
d215 5
a219 1
  libunwind_frame_prev_register
@


1.14
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c (XTENSA_IS_ENTRY, extract_call_winsize)
	(xtensa_register_write_masked, xtensa_register_read_masked)
	(xtensa_extract_return_value, xtensa_store_return_value
	(xtensa_push_dummy_call, xtensa_breakpoint_from_pc): Replace
	TARGET_BYTE_ORDER by gdbarch_byte_order.
	* sh-tdep.c (sh_breakpoint_from_pc, gdb_print_insn_sh)
	(sh_justify_value_in_reg, sh_next_flt_argreg, sh_push_dummy_call_fpu)
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_breakpoint_from_pc, gdb_print_insn_sh64)
	(sh64_push_dummy_call, sh64_extract_return_value)
	(sh64_store_return_value, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_pseudo_register_read)
	(sh64_pseudo_register_write, sh64_do_fp_register)
	(sh64_frame_prev_register): Likewise.
	* score-tdep.c (score_print_insn, score_breakpoint_from_pc)
	(score_return_value, score_push_dummy_call, score_fetch_inst): Likewise.
	* rs6000-tdep.c (rs6000_breakpoint_from_pc, rs6000_push_dummy_call)
	(e500_move_ev_register,gdb_print_insn_powerpc): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* ppc-linux-nat.c (store_register): Likewise.
	* nto-tdep.c (nto_find_and_open_solib)
	(nto_init_solib_absolute_prefix): Likewise.
	* mips-tdep.c (mips_pseudo_register_read, mips_pseudo_register_write)
	(mips_convert_register_p, mips_eabi_push_dummy_call)
	(mips_n32n64_push_dummy_call, mips_n32n64_return_value)
	(mips_o32_push_dummy_call, mips_o32_return_value)
	(mips_o64_push_dummy_call, mips_o64_return_value, mips_o64_return_value)
	(mips_read_fp_register_single, mips_read_fp_register_double)
	(mips_print_register, print_gp_register_row, gdb_print_insn_mips)
	(mips_breakpoint_from_pc): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Likewise.
	* mips-linux-tdep.c (mips64_supply_fpregset, mips64_fill_fpregset)
	(mips_linux_o32_sigframe_init): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint, m32r_breakpoint_from_pc): Likewise.
	* libunwind-frame.c (libunwind_frame_cache, libunwind_frame_sniffer)
	(libunwind_sigtramp_frame_sniffer, libunwind_get_reg_special): Likewise.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* arm-tdep.c (convert_from_extended, convert_to_extended)
	(gdb_print_insn_arm): Likewise.
@
text
@d56 1
d89 1
d175 4
a178 1
    return NULL;
d184 4
a187 1
    error (_("Can't get libunwind sp register."));
d235 4
a238 1
    return NULL;
d245 1
d397 4
a400 1
    return NULL;
d404 1
d441 4
a444 1
    return -1;
d459 2
d509 4
@


1.13
log
@	* libunwind-frame.h (struct regcache): Add forward declaration.
	(libunwind_get_reg_special): Add REGCACHE argument.
	* libunwind-frame.c (libunwind_get_reg_special): Add REGCACHE
	argument.  Pass it to unw_init_remote_p.

	* ia64-tdep.c (ia64_pseudo_register_read): Pass regcache to
	libunwind_get_reg_special.
	(ia64_access_reg): Remove "write" case.
	(ia64_access_fpreg): Likewise.  Read from next_frame passed
	as callback argument instead of from current_regcache.
	(ia64_access_rse_reg): Remove "write" case.  Read from regcache
	passed as callback argument instead of from current_regcache.
	(ia64_access_rse_fpreg): New function.
	(ia64_unw_rse_acce): Use it instead of ia64_access_fpreg.
@
text
@d166 2
a167 1
				 TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
d219 2
a220 1
				 TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
d377 2
a378 1
				 TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
d418 2
a419 1
				 TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
@


1.12
log
@* libunwind-frame.c (LIBUNWIND_SO): Use major version number for `.so'.
@
text
@d398 2
a399 1
libunwind_get_reg_special (struct gdbarch *gdbarch, int regnum, void *buf)
d419 1
a419 1
  ret = unw_init_remote_p (&cursor, as, NULL);
@


1.11
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d76 3
a78 1
#define LIBUNWIND_SO "libunwind-" STRINGIFY(UNW_TARGET) ".so"
@


1.10
log
@Copyright updates for 2007.
@
text
@d144 4
a147 1
  cache->func_addr = frame_func_unwind (next_frame);
@


1.9
log
@	* ia64-tdep.c (ia64_libunwind_frame_this_id): Adapt uses of
	libunwind_frame_prev_register to use a gdb_byte buffer and
	extract_unsigned_integer.
	(ia64_libunwind_sigtramp_frame_prev_register): Likewise.

	* libunwind-frame.c (libunwind_frame_prev_register): Change type
	of last argument to `gdb_byte *'
	* libunwind-frame.h: Adjust declaration.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2006 Free Software Foundation, Inc.
@


1.8
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
d251 1
a251 1
			       int *realnump, void *valuep)
@


1.7
log
@
2005-06-08  Jeff Johnston  <jjohnstn@@redhat.com>
            David Mosberger <davidm@@hpl.hp.com>

        * ia64-tdep.c (KERNEL_START): New macro.
        (ia64_pseudo_register_read): Fix code to use libunwind to properly
        get the rse registers.
        (ia64_frame_this_id): Mark outermost frame with null frame id.
        (ia64_sigtramp_frame_prev_register): Fix up debug output.
        (ia64_access_rse_reg): New accessor function.
        (ia64_access_mem): Add special logic for accessing the
        kernel's unwind table.
        (getunwind_table): Fix for corefiles.
        (get_kernel_table): Fix to handle vDSO.
        (ia64_libunwind_frame_this_id): Check for null frame id and
        don't unwind past pc value of 0.  Fix debugging output.
        (ia64_libunwind_sigtramp_frame_this_id): New function.
        (ia64_libunwind_sigtramp_frame_prev_register): Ditto.
        (ia64_libunwind_sigtramp_frame_sniffer): Ditto.
        (ia64_libunwind_sigtramp_frame_unwind): New unwinder.
        (ia64_unw_rse_accessors): New libunwind accessors.
        (ia64_libunwind_descr): Add ia64_unw_rse_accessors.
        (ia64_gdbarch_init)[HAVE_LIBUNWIND_IA64_H]: Use
        ia64_libunwind_sigtramp_frame_sniffer instead of
        ia64_sigtramp_frame_sniffer.
        * libunwind-frame.c (libunwind_frame_set_descr): Add
        special register accessors.
        (libunwind_frame_cache): Add special logic to check for
        0 pc value.  Check for a signal trampoline frame.
        (libunwind_frame_this_id): Check if libunwind_frame_cache
        returns NULL.
        (libunwind_frame_prev_register): Check for NULL cache.
        (libunwind_frame_base_address): Ditto.
        (libunwind_sigtramp_frame_sniffer): New function.
        (libunwind_get_reg_special): Ditto.
        (libunwind_load): Add unw_is_signal_frame support.
        * libunwind-frame.h (struct libunwind_descr): Add special_accessors
        field.
        (libunwind_sigtramp_frame_sniffer): New prototype.
        (libunwind_get_reg_special): Ditto.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.6
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d52 1
d82 1
d124 1
d145 4
d166 2
a167 1
  unw_step_p (&cache->cursor);
d219 8
a226 2
  if (ret >= 0)
    ret = unw_step_p (&cursor);
d241 4
a244 1
  (*this_id) = frame_id_build (cache->base, cache->func_addr);
d265 3
d335 2
d350 89
d462 4
@


1.5
log
@
2004-08-05  Jeff Johnston  <jjohnstn@@redhat.com>

        * libunwind-frame.c (LIBUNWIND_SO): Change to be of form:
        libunwind-xxxx.so" where xxxx is UNW_TARGET.
@
text
@d165 1
a165 1
    error ("Can't get libunwind sp register.");
d255 1
a255 1
    error ("No registers.");
@


1.4
log
@	* ia64-tdep.c (ia64_libunwind_frame_prev_register): Handle null
	value buffer.
	* libunwind-frame.c (libunwind_frame_prev_register): Likewise.
@
text
@a47 4
#ifndef LIBUNWIND_SO
#define LIBUNWIND_SO "libunwind.so"
#endif

d74 4
@


1.3
log
@2004-03-15  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_data_pre_init_fytpe)
	(gdbarch_data_register_pre_init, gdbarch_data_post_init_fytpe)
	(gdbarch_data_register_post_init): Replace gdbarch_data_init_ftype
	and register_gdbarch_data.
	(deprecated_set_gdbarch_data): Rename set_gdbarch_data.
	(struct gdbarch_data): Replace "init" by "pre_init" and
	"post_init".
	* gdbarch.h, gdbarch.c: Re-generate.
	* dwarf2-frame.c (dwarf2_frame_init): Replace "gdbarch" paramter
	with"obstack", use OBSTACK_ZALLOC.
	(dwarf2_frame_ops): Delete.
	(dwarf2_frame_set_init_reg): Use gdbarch_data.
	(dwarf2_frame_init_reg): Use gdbarch_data.
	(_initialize_dwarf2_frame): Use gdbarch_data_register_pre_init.
	* solib-svr4.c (set_solib_svr4_fetch_link_map_offsets)
	(_initialize_svr4_solib): Update.
	* user-regs.c (_initialize_user_regs): Update.
	* reggroups.c (_initialize_reggroup): Update.
	* regcache.c (_initialize_regcache): Update.
	* mips-linux-tdep.c (_initialize_mips_linux_tdep): Update.
	* libunwind-frame.c (_initialize_libunwind_frame): Update.
	* gnu-v3-abi.c (init_gnuv3_ops): Update.
	* frame-unwind.c (_initialize_frame_unwind): Update.
	* frame-base.c (_initialize_frame_base): Update.
	* user-regs.c (user_reg_add): Update.
	* reggroups.c (reggroup_add): Update.
	* mips-linux-tdep.c (set_mips_linux_register_addr): Update.
	* libunwind-frame.c (libunwind_frame_set_descr): Update.
	* frame-unwind.c (frame_unwind_append_sniffer): Update.
	* frame-base.c (frame_base_table): Update.
	* remote.c (_initialize_remote): Update.
	* gdb_obstack.h (OBSTACK_ZALLOC, OBSTACK_CALLOC): Define.
@
text
@d3 1
a3 1
   Copyright 2003 Free Software Foundation, Inc.
d262 2
a263 1
  memset (valuep, 0, register_size (current_gdbarch, regnum));
d285 2
a286 1
  memcpy (valuep, ptr, register_size (current_gdbarch, regnum));
@


1.2
log
@	From David Mosberger  <davidm@@hpl.hp.com>:
	* libunwind-frame.c (unw_find_dyn_list_p): Replace most arguments
	with a single unw_dyn_info_t pointer.
	(libunwind_find_dyn_list): Likewise.
	* libunwind-frame.h: Likewise.
	* ia64-tdep.c (ia64_find_unwind_table): Switch to using
	UNW_INFO_FORMAT_REMOTE_TABLE so we can avoid having to read in the
	entire unwind-table at once.  Support for this table format has
	been added to libunwind v0.95.
	(ia64_find_proc_info_x): Adjust for remote-unwind-table changes.
	(ia64_get_dyn_info_list): Adjust for interface change for
	libunwind_find_dyn_list().
@
text
@d114 1
a114 1
      set_gdbarch_data (gdbarch, libunwind_descr_handle, arch_descr);
d384 1
a384 1
  libunwind_descr_handle = register_gdbarch_data (libunwind_descr_init);
@


1.2.10.1
log
@Merge mainline to intercu branch.
@
text
@d114 1
a114 1
      deprecated_set_gdbarch_data (gdbarch, libunwind_descr_handle, arch_descr);
d384 1
a384 1
  libunwind_descr_handle = gdbarch_data_register_post_init (libunwind_descr_init);
@


1.2.10.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d48 4
a77 4
#ifndef LIBUNWIND_SO
#define LIBUNWIND_SO "libunwind-" STRINGIFY(UNW_TARGET) ".so"
#endif

d262 1
a262 2
  if (valuep)
    memset (valuep, 0, register_size (current_gdbarch, regnum));
d284 1
a284 2
  if (valuep)
    memcpy (valuep, ptr, register_size (current_gdbarch, regnum));
@


1.2.14.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d114 1
a114 1
      deprecated_set_gdbarch_data (gdbarch, libunwind_descr_handle, arch_descr);
d384 1
a384 1
  libunwind_descr_handle = gdbarch_data_register_post_init (libunwind_descr_init);
@


1.2.4.1
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@@


1.2.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.1
log
@
2003-11-14  Jeff Johnston  <jjohnstn@@redhat.com>

        * libunwind-frame.c: New file.
        * libunwind-frame.h: New file.
        * acconfig.h (HAVE_LIBUNWIND): #undef reference added.
        * configure.in: Add --with-libunwind option support.  Define
        HAVE_LIBUNWIND if libunwind support selected / defaulted.
        Also check for libunwind.h and libunwind-ia64.h headers.
        * configure: Regenerated.
        * Makefile.in: Add support for libunwind-frame.o.
        * config.in: Regenerated.
@
text
@d61 2
a62 2
static unw_word_t (*unw_find_dyn_list_p) (unw_addr_space_t, void *, size_t,
					  unw_word_t, unw_word_t, void *);
d173 2
a174 3
unw_word_t 
libunwind_find_dyn_list (unw_addr_space_t as, void *table, size_t table_size,
			 unw_word_t segbase, unw_word_t gp, void *arg)
d176 1
a176 1
  return unw_find_dyn_list_p (as, table, table_size, segbase, gp, arg);
@

