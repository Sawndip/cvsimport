head	1.58;
access;
symbols
	drow_intercu-merge-20040921:1.57
	drow_intercu-merge-20040915:1.57
	jimb-gdb_6_2-e500-branch:1.55.0.6
	jimb-gdb_6_2-e500-branchpoint:1.55
	gdb_6_2-20040730-release:1.55
	gdb_6_2-branch:1.55.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.55
	gdb_6_1_1-20040616-release:1.52
	gdb_6_1-2004-04-05-release:1.52
	drow_intercu-merge-20040402:1.54
	drow_intercu-merge-20040327:1.53
	ezannoni_pie-20040323-branch:1.53.0.2
	ezannoni_pie-20040323-branchpoint:1.53
	cagney_tramp-20040321-mergepoint:1.52
	cagney_tramp-20040309-branch:1.52.0.10
	cagney_tramp-20040309-branchpoint:1.52
	gdb_6_1-branch:1.52.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.52
	drow_intercu-20040221-branch:1.52.0.6
	drow_intercu-20040221-branchpoint:1.52
	cagney_bfdfile-20040213-branch:1.52.0.4
	cagney_bfdfile-20040213-branchpoint:1.52
	drow-cplus-merge-20040208:1.52
	carlton_dictionary-20040126-merge:1.52
	cagney_bigcore-20040122-branch:1.52.0.2
	cagney_bigcore-20040122-branchpoint:1.52
	drow-cplus-merge-20040113:1.52
	drow-cplus-merge-20031224:1.52
	drow-cplus-merge-20031220:1.52
	carlton_dictionary-20031215-merge:1.52
	drow-cplus-merge-20031214:1.52
	carlton-dictionary-20031111-merge:1.52
	gdb_6_0-2003-10-04-release:1.47.2.2
	kettenis_sparc-20030918-branch:1.51.0.4
	kettenis_sparc-20030918-branchpoint:1.51
	carlton_dictionary-20030917-merge:1.51
	ezannoni_pie-20030916-branchpoint:1.51
	ezannoni_pie-20030916-branch:1.51.0.2
	cagney_x86i386-20030821-branch:1.49.0.2
	cagney_x86i386-20030821-branchpoint:1.49
	carlton_dictionary-20030805-merge:1.47
	carlton_dictionary-20030627-merge:1.47
	gdb_6_0-branch:1.47.0.2
	gdb_6_0-2003-06-23-branchpoint:1.47
	jimb-ppc64-linux-20030613-branch:1.44.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.44
	cagney_convert-20030606-branch:1.44.0.2
	cagney_convert-20030606-branchpoint:1.44
	cagney_writestrings-20030508-branch:1.43.0.14
	cagney_writestrings-20030508-branchpoint:1.43
	jimb-ppc64-linux-20030528-branch:1.43.0.12
	jimb-ppc64-linux-20030528-branchpoint:1.43
	carlton_dictionary-20030523-merge:1.43
	cagney_fileio-20030521-branch:1.43.0.10
	cagney_fileio-20030521-branchpoint:1.43
	kettenis_i386newframe-20030517-mergepoint:1.43
	jimb-ppc64-linux-20030509-branch:1.43.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.43
	kettenis_i386newframe-20030504-mergepoint:1.43
	carlton_dictionary-20030430-merge:1.43
	kettenis_i386newframe-20030419-branch:1.43.0.6
	kettenis_i386newframe-20030419-branchpoint:1.43
	carlton_dictionary-20030416-merge:1.43
	cagney_frameaddr-20030409-mergepoint:1.43
	kettenis_i386newframe-20030406-branch:1.43.0.4
	kettenis_i386newframe-20030406-branchpoint:1.43
	cagney_frameaddr-20030403-branchpoint:1.43
	cagney_frameaddr-20030403-branch:1.43.0.2
	cagney_framebase-20030330-mergepoint:1.43
	cagney_framebase-20030326-branch:1.42.0.12
	cagney_framebase-20030326-branchpoint:1.42
	cagney_lazyid-20030317-branch:1.42.0.10
	cagney_lazyid-20030317-branchpoint:1.42
	kettenis-i386newframe-20030316-mergepoint:1.42
	offbyone-20030313-branch:1.42.0.8
	offbyone-20030313-branchpoint:1.42
	kettenis-i386newframe-20030308-branch:1.42.0.6
	kettenis-i386newframe-20030308-branchpoint:1.42
	carlton_dictionary-20030305-merge:1.42
	cagney_offbyone-20030303-branch:1.42.0.4
	cagney_offbyone-20030303-branchpoint:1.42
	carlton_dictionary-20030207-merge:1.42
	interps-20030203-mergepoint:1.42
	interps-20030202-branch:1.42.0.2
	interps-20030202-branchpoint:1.42
	cagney-unwind-20030108-branch:1.41.0.2
	cagney-unwind-20030108-branchpoint:1.41
	carlton_dictionary-20021223-merge:1.39
	gdb_5_3-2002-12-12-release:1.35.2.2
	carlton_dictionary-20021115-merge:1.36
	kseitz_interps-20021105-merge:1.36
	kseitz_interps-20021103-merge:1.36
	drow-cplus-merge-20021020:1.35
	drow-cplus-merge-20021025:1.35
	carlton_dictionary-20021025-merge:1.35
	carlton_dictionary-20021011-merge:1.35
	drow-cplus-branch:1.35.0.6
	drow-cplus-branchpoint:1.35
	kseitz_interps-20020930-merge:1.35
	carlton_dictionary-20020927-merge:1.35
	carlton_dictionary-branch:1.35.0.4
	carlton_dictionary-20020920-branchpoint:1.35
	gdb_5_3-branch:1.35.0.2
	gdb_5_3-2002-09-04-branchpoint:1.35
	kseitz_interps-20020829-merge:1.35
	cagney_sysregs-20020825-branch:1.34.0.10
	cagney_sysregs-20020825-branchpoint:1.34
	readline_4_3-import-branch:1.34.0.8
	readline_4_3-import-branchpoint:1.34
	gdb_5_2_1-2002-07-23-release:1.32
	kseitz_interps-20020528-branch:1.34.0.6
	kseitz_interps-20020528-branchpoint:1.34
	cagney_regbuf-20020515-branch:1.34.0.4
	cagney_regbuf-20020515-branchpoint:1.34
	jimb-macro-020506-branch:1.34.0.2
	jimb-macro-020506-branchpoint:1.34
	gdb_5_2-2002-04-29-release:1.32
	gdb_5_2-branch:1.32.0.2
	gdb_5_2-2002-03-03-branchpoint:1.32
	gdb_5_1_1-2002-01-24-release:1.29
	gdb_5_1_0_1-2002-01-03-release:1.29
	cygnus_cvs_20020108_pre:1.31
	gdb_5_1_0_1-2002-01-03-branchpoint:1.29
	gdb_5_1_0_1-2002-01-03-branch:1.29.0.6
	gdb_5_1-2001-11-21-release:1.29
	gdb_s390-2001-09-26-branch:1.29.0.4
	gdb_s390-2001-09-26-branchpoint:1.29
	gdb_5_1-2001-07-29-branch:1.29.0.2
	gdb_5_1-2001-07-29-branchpoint:1.29
	dberlin-typesystem-branch:1.24.0.2
	dberlin-typesystem-branchpoint:1.24
	gdb-post-ptid_t-2001-05-03:1.14
	gdb-pre-ptid_t-2001-05-03:1.13
	insight-precleanup-2001-01-01:1.4;
locks; strict;
comment	@ * @;


1.58
date	2004.09.27.19.55.17;	author cagney;	state dead;
branches;
next	1.57;

1.57
date	2004.08.06.13.42.05;	author uweigand;	state Exp;
branches;
next	1.56;

1.56
date	2004.07.26.14.53.02;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2004.05.25.14.58.28;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.29.18.07.14;	author drow;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.22.20.18.33;	author drow;	state Exp;
branches;
next	1.52;

1.52
date	2003.10.08.20.05.56;	author jjohnstn;	state Exp;
branches
	1.52.6.1;
next	1.51;

1.51
date	2003.09.07.18.49.44;	author drow;	state Exp;
branches
	1.51.4.1;
next	1.50;

1.50
date	2003.08.28.14.20.03;	author drow;	state Exp;
branches;
next	1.49;

1.49
date	2003.08.17.18.52.59;	author drow;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.17.18.22.25;	author drow;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.19.22.52.03;	author msnyder;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2003.06.19.15.04.58;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.18.23.33.30;	author drow;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.04.20.51.28;	author jjohnstn;	state Exp;
branches;
next	1.43;

1.43
date	2003.03.28.21.42.41;	author jjohnstn;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.13.21.47.35;	author drow;	state Exp;
branches
	1.42.12.1;
next	1.41;

1.41
date	2003.01.09.19.14.46;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.06.23.12.29;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2002.12.09.18.41.42;	author kevinb;	state Exp;
branches;
next	1.38;

1.38
date	2002.12.04.03.20.29;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.26.01.23.46;	author drow;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.31.21.00.08;	author drow;	state Exp;
branches;
next	1.35;

1.35
date	2002.08.27.22.37.06;	author tromey;	state Exp;
branches
	1.35.2.1
	1.35.4.1
	1.35.6.1;
next	1.34;

1.34
date	2002.03.31.15.10.38;	author kettenis;	state Exp;
branches
	1.34.6.1;
next	1.33;

1.33
date	2002.03.27.21.35.35;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.24.21.53.02;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.21.21.56.47;	author kevinb;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.14.11.30.37;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.13.12.49.31;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.12.19.37.36;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.07.10.58.37;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.06.22.31.47;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.06.19.06.24;	author msnyder;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.07.19.31.10;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.06.16.31.32;	author jlarmour;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.30.22.58.37;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.30.18.15.45;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.15.00.13.47;	author kevinb;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.15.00.03.36;	author kevinb;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.10.01.34.17;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.10.01.07.39;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.06.22.22.03;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.06.17.00.44;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.01.20.39.51;	author msnyder;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.30.20.25.07;	author msnyder;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.30.18.21.17;	author msnyder;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.26.23.14.20;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.26.22.35.08;	author msnyder;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.06.17.53.39;	author dsmith;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.30.19.45.19;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.24.00.26.46;	author jtc;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.18.13.09.12;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.09.07.54.20;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.03.18.41.28;	author kettenis;	state Exp;
branches;
next	;

1.34.6.1
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	1.34.6.2;

1.34.6.2
date	2002.11.04.00.17.32;	author ezannoni;	state Exp;
branches;
next	;

1.35.2.1
date	2002.11.26.01.32.21;	author drow;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2002.12.03.22.35.48;	author cagney;	state Exp;
branches;
next	;

1.35.4.1
date	2002.11.15.19.18.49;	author carlton;	state Exp;
branches;
next	1.35.4.2;

1.35.4.2
date	2002.12.23.19.38.32;	author carlton;	state Exp;
branches;
next	1.35.4.3;

1.35.4.3
date	2003.02.07.19.17.50;	author carlton;	state Exp;
branches;
next	1.35.4.4;

1.35.4.4
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.35.4.5;

1.35.4.5
date	2003.06.27.21.50.05;	author carlton;	state Exp;
branches;
next	1.35.4.6;

1.35.4.6
date	2003.09.17.21.28.23;	author carlton;	state Exp;
branches;
next	1.35.4.7;

1.35.4.7
date	2003.11.11.23.50.48;	author carlton;	state Exp;
branches;
next	;

1.35.6.1
date	2003.12.14.20.27.20;	author drow;	state Exp;
branches;
next	;

1.42.12.1
date	2003.03.30.16.35.21;	author cagney;	state Exp;
branches;
next	;

1.47.2.1
date	2003.08.17.18.22.33;	author drow;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2003.08.17.18.53.12;	author drow;	state Exp;
branches;
next	;

1.51.4.1
date	2003.11.02.20.35.33;	author kettenis;	state Exp;
branches;
next	;

1.52.6.1
date	2004.03.27.17.37.50;	author drow;	state Exp;
branches;
next	1.52.6.2;

1.52.6.2
date	2004.04.02.16.47.47;	author drow;	state Exp;
branches;
next	1.52.6.3;

1.52.6.3
date	2004.09.16.17.01.10;	author drow;	state Exp;
branches;
next	;


desc
@@


1.58
log
@2004-09-16  Andrew Cagney  <cagney@@gnu.org>

	* lin-lwp.c: Delete file.
	* linux-nat.c: Include "gdb_assert.h", "gdb_string.h", <unistd.h>,
	<sys/syscall.h>, "gdbthread.h", "gdbcmd.h", "regcache.h".
	(status_to_str, init_lwp_list, add_lwp, delete_lwp)
	(find_lwp_pid, iterate_over_lwps, lin_lwp_attach_lwp)
	(linux_nat_attach, detach_callback, linux_nat_detach)
	(resume_callback, resume_clear_callback, linux_nat_resume)
	(kill_lwp, linux_nat_handle_extended, wait_lwp, stop_callback)
	(stop_wait_callback, linux_nat_has_pending, flush_callback)
	(status_callback, running_callback, count_events_callback)
	(select_singlestep_lwp_callback, select_event_lwp_callback)
	(cancel_breakpoints_callback, select_event_lwp, resumed_callback)
	(child_wait, stop_and_resume_callback, linux_nat_wait)
	(kill_callback, kill_wait_callback, linux_nat_kill)
	(linux_nat_create_inferior, linux_nat_mourn_inferior)
	(linux_nat_xfer_memory, linux_nat_thread_alive)
	(linux_nat_pid_to_str, init_linux_nat_ops, sigchld_handler)
	(_initialize_linux_nat): New functions.
	* Makefile.in: Update all dependencies.
	* config/sparc/linux64.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/sparc/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/s390/s390.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/powerpc/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/pa/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/mips/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/m68k/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/ia64/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/i386/linux64.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/i386/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/arm/linux.mh (NATDEPFILES): Remove lin-lwp.o.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Remove lin-lwp.o.
@
text
@/* Multi-threaded debugging support for GNU/Linux (LWP layer).
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"

#include "gdb_assert.h"
#include "gdb_string.h"
#include <errno.h>
#include <signal.h>
#ifdef HAVE_TKILL_SYSCALL
#include <unistd.h>
#include <sys/syscall.h>
#endif
#include <sys/ptrace.h>
#include "gdb_wait.h"

#include "gdbthread.h"
#include "inferior.h"
#include "target.h"
#include "regcache.h"
#include "gdbcmd.h"

static int debug_lin_lwp;
extern char *strsignal (int sig);

#include "linux-nat.h"

/* On GNU/Linux there are no real LWP's.  The closest thing to LWP's
   are processes sharing the same VM space.  A multi-threaded process
   is basically a group of such processes.  However, such a grouping
   is almost entirely a user-space issue; the kernel doesn't enforce
   such a grouping at all (this might change in the future).  In
   general, we'll rely on the threads library (i.e. the GNU/Linux
   Threads library) to provide such a grouping.

   It is perfectly well possible to write a multi-threaded application
   without the assistance of a threads library, by using the clone
   system call directly.  This module should be able to give some
   rudimentary support for debugging such applications if developers
   specify the CLONE_PTRACE flag in the clone system call, and are
   using the Linux kernel 2.4 or above.

   Note that there are some peculiarities in GNU/Linux that affect
   this code:

   - In general one should specify the __WCLONE flag to waitpid in
     order to make it report events for any of the cloned processes
     (and leave it out for the initial process).  However, if a cloned
     process has exited the exit status is only reported if the
     __WCLONE flag is absent.  Linux kernel 2.4 has a __WALL flag, but
     we cannot use it since GDB must work on older systems too.

   - When a traced, cloned process exits and is waited for by the
     debugger, the kernel reassigns it to the original parent and
     keeps it around as a "zombie".  Somehow, the GNU/Linux Threads
     library doesn't notice this, which leads to the "zombie problem":
     When debugged a multi-threaded process that spawns a lot of
     threads will run out of processes, even if the threads exit,
     because the "zombies" stay around.  */

/* List of known LWPs.  */
static struct lwp_info *lwp_list;

/* Number of LWPs in the list.  */
static int num_lwps;

/* Non-zero if we're running in "threaded" mode.  */
static int threaded;


#define GET_LWP(ptid)		ptid_get_lwp (ptid)
#define GET_PID(ptid)		ptid_get_pid (ptid)
#define is_lwp(ptid)		(GET_LWP (ptid) != 0)
#define BUILD_LWP(lwp, pid)	ptid_build (pid, lwp, 0)

/* If the last reported event was a SIGTRAP, this variable is set to
   the process id of the LWP/thread that got it.  */
ptid_t trap_ptid;


/* This module's target-specific operations.  */
static struct target_ops lin_lwp_ops;

/* The standard child operations.  */
extern struct target_ops child_ops;

/* Since we cannot wait (in lin_lwp_wait) for the initial process and
   any cloned processes with a single call to waitpid, we have to use
   the WNOHANG flag and call waitpid in a loop.  To optimize
   things a bit we use `sigsuspend' to wake us up when a process has
   something to report (it will send us a SIGCHLD if it has).  To make
   this work we have to juggle with the signal mask.  We save the
   original signal mask such that we can restore it before creating a
   new process in order to avoid blocking certain signals in the
   inferior.  We then block SIGCHLD during the waitpid/sigsuspend
   loop.  */

/* Original signal mask.  */
static sigset_t normal_mask;

/* Signal mask for use with sigsuspend in lin_lwp_wait, initialized in
   _initialize_lin_lwp.  */
static sigset_t suspend_mask;

/* Signals to block to make that sigsuspend work.  */
static sigset_t blocked_mask;


/* Prototypes for local functions.  */
static int stop_wait_callback (struct lwp_info *lp, void *data);
static int lin_lwp_thread_alive (ptid_t ptid);

/* Convert wait status STATUS to a string.  Used for printing debug
   messages only.  */

static char *
status_to_str (int status)
{
  static char buf[64];

  if (WIFSTOPPED (status))
    snprintf (buf, sizeof (buf), "%s (stopped)",
	      strsignal (WSTOPSIG (status)));
  else if (WIFSIGNALED (status))
    snprintf (buf, sizeof (buf), "%s (terminated)",
	      strsignal (WSTOPSIG (status)));
  else
    snprintf (buf, sizeof (buf), "%d (exited)", WEXITSTATUS (status));

  return buf;
}

/* Initialize the list of LWPs.  Note that this module, contrary to
   what GDB's generic threads layer does for its thread list,
   re-initializes the LWP lists whenever we mourn or detach (which
   doesn't involve mourning) the inferior.  */

static void
init_lwp_list (void)
{
  struct lwp_info *lp, *lpnext;

  for (lp = lwp_list; lp; lp = lpnext)
    {
      lpnext = lp->next;
      xfree (lp);
    }

  lwp_list = NULL;
  num_lwps = 0;
  threaded = 0;
}

/* Add the LWP specified by PID to the list.  If this causes the
   number of LWPs to become larger than one, go into "threaded" mode.
   Return a pointer to the structure describing the new LWP.  */

static struct lwp_info *
add_lwp (ptid_t ptid)
{
  struct lwp_info *lp;

  gdb_assert (is_lwp (ptid));

  lp = (struct lwp_info *) xmalloc (sizeof (struct lwp_info));

  memset (lp, 0, sizeof (struct lwp_info));

  lp->waitstatus.kind = TARGET_WAITKIND_IGNORE;

  lp->ptid = ptid;

  lp->next = lwp_list;
  lwp_list = lp;
  if (++num_lwps > 1)
    threaded = 1;

  return lp;
}

/* Remove the LWP specified by PID from the list.  */

static void
delete_lwp (ptid_t ptid)
{
  struct lwp_info *lp, *lpprev;

  lpprev = NULL;

  for (lp = lwp_list; lp; lpprev = lp, lp = lp->next)
    if (ptid_equal (lp->ptid, ptid))
      break;

  if (!lp)
    return;

  /* We don't go back to "non-threaded" mode if the number of threads
     becomes less than two.  */
  num_lwps--;

  if (lpprev)
    lpprev->next = lp->next;
  else
    lwp_list = lp->next;

  xfree (lp);
}

/* Return a pointer to the structure describing the LWP corresponding
   to PID.  If no corresponding LWP could be found, return NULL.  */

static struct lwp_info *
find_lwp_pid (ptid_t ptid)
{
  struct lwp_info *lp;
  int lwp;

  if (is_lwp (ptid))
    lwp = GET_LWP (ptid);
  else
    lwp = GET_PID (ptid);

  for (lp = lwp_list; lp; lp = lp->next)
    if (lwp == GET_LWP (lp->ptid))
      return lp;

  return NULL;
}

/* Call CALLBACK with its second argument set to DATA for every LWP in
   the list.  If CALLBACK returns 1 for a particular LWP, return a
   pointer to the structure describing that LWP immediately.
   Otherwise return NULL.  */

struct lwp_info *
iterate_over_lwps (int (*callback) (struct lwp_info *, void *), void *data)
{
  struct lwp_info *lp, *lpnext;

  for (lp = lwp_list; lp; lp = lpnext)
    {
      lpnext = lp->next;
      if ((*callback) (lp, data))
	return lp;
    }

  return NULL;
}


#if 0
static void
lin_lwp_open (char *args, int from_tty)
{
  push_target (&lin_lwp_ops);
}
#endif

/* Attach to the LWP specified by PID.  If VERBOSE is non-zero, print
   a message telling the user that a new LWP has been added to the
   process.  */

void
lin_lwp_attach_lwp (ptid_t ptid, int verbose)
{
  struct lwp_info *lp, *found_lp;

  gdb_assert (is_lwp (ptid));

  /* Make sure SIGCHLD is blocked.  We don't want SIGCHLD events
     to interrupt either the ptrace() or waitpid() calls below.  */
  if (!sigismember (&blocked_mask, SIGCHLD))
    {
      sigaddset (&blocked_mask, SIGCHLD);
      sigprocmask (SIG_BLOCK, &blocked_mask, NULL);
    }

  if (verbose)
    printf_filtered ("[New %s]\n", target_pid_to_str (ptid));

  found_lp = lp = find_lwp_pid (ptid);
  if (lp == NULL)
    lp = add_lwp (ptid);

  /* We assume that we're already attached to any LWP that has an id
     equal to the overall process id, and to any LWP that is already
     in our list of LWPs.  If we're not seeing exit events from threads
     and we've had PID wraparound since we last tried to stop all threads,
     this assumption might be wrong; fortunately, this is very unlikely
     to happen.  */
  if (GET_LWP (ptid) != GET_PID (ptid) && found_lp == NULL)
    {
      pid_t pid;
      int status;

      if (ptrace (PTRACE_ATTACH, GET_LWP (ptid), 0, 0) < 0)
	error ("Can't attach %s: %s", target_pid_to_str (ptid),
	       safe_strerror (errno));

      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "LLAL: PTRACE_ATTACH %s, 0, 0 (OK)\n",
			    target_pid_to_str (ptid));

      pid = waitpid (GET_LWP (ptid), &status, 0);
      if (pid == -1 && errno == ECHILD)
	{
	  /* Try again with __WCLONE to check cloned processes.  */
	  pid = waitpid (GET_LWP (ptid), &status, __WCLONE);
	  lp->cloned = 1;
	}

      gdb_assert (pid == GET_LWP (ptid)
		  && WIFSTOPPED (status) && WSTOPSIG (status));

      child_post_attach (pid);

      lp->stopped = 1;

      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "LLAL: waitpid %s received %s\n",
			      target_pid_to_str (ptid),
			      status_to_str (status));
	}
    }
  else
    {
      /* We assume that the LWP representing the original process
         is already stopped.  Mark it as stopped in the data structure
         that the lin-lwp layer uses to keep track of threads.  Note
         that this won't have already been done since the main thread
         will have, we assume, been stopped by an attach from a
         different layer.  */
      lp->stopped = 1;
    }
}

static void
lin_lwp_attach (char *args, int from_tty)
{
  struct lwp_info *lp;
  pid_t pid;
  int status;

  /* FIXME: We should probably accept a list of process id's, and
     attach all of them.  */
  child_ops.to_attach (args, from_tty);

  /* Add the initial process as the first LWP to the list.  */
  lp = add_lwp (BUILD_LWP (GET_PID (inferior_ptid), GET_PID (inferior_ptid)));

  /* Make sure the initial process is stopped.  The user-level threads
     layer might want to poke around in the inferior, and that won't
     work if things haven't stabilized yet.  */
  pid = waitpid (GET_PID (inferior_ptid), &status, 0);
  if (pid == -1 && errno == ECHILD)
    {
      warning ("%s is a cloned process", target_pid_to_str (inferior_ptid));

      /* Try again with __WCLONE to check cloned processes.  */
      pid = waitpid (GET_PID (inferior_ptid), &status, __WCLONE);
      lp->cloned = 1;
    }

  gdb_assert (pid == GET_PID (inferior_ptid)
	      && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP);

  lp->stopped = 1;

  /* Fake the SIGSTOP that core GDB expects.  */
  lp->status = W_STOPCODE (SIGSTOP);
  lp->resumed = 1;
  if (debug_lin_lwp)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "LLA: waitpid %ld, faking SIGSTOP\n", (long) pid);
    }
}

static int
detach_callback (struct lwp_info *lp, void *data)
{
  gdb_assert (lp->status == 0 || WIFSTOPPED (lp->status));

  if (debug_lin_lwp && lp->status)
    fprintf_unfiltered (gdb_stdlog, "DC:  Pending %s for %s on detach.\n",
			strsignal (WSTOPSIG (lp->status)),
			target_pid_to_str (lp->ptid));

  while (lp->signalled && lp->stopped)
    {
      errno = 0;
      if (ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0,
		  WSTOPSIG (lp->status)) < 0)
	error ("Can't continue %s: %s", target_pid_to_str (lp->ptid),
	       safe_strerror (errno));

      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "DC:  PTRACE_CONTINUE (%s, 0, %s) (OK)\n",
			    target_pid_to_str (lp->ptid),
			    status_to_str (lp->status));

      lp->stopped = 0;
      lp->signalled = 0;
      lp->status = 0;
      /* FIXME drow/2003-08-26: There was a call to stop_wait_callback
	 here.  But since lp->signalled was cleared above,
	 stop_wait_callback didn't do anything; the process was left
	 running.  Shouldn't we be waiting for it to stop?
	 I've removed the call, since stop_wait_callback now does do
	 something when called with lp->signalled == 0.  */

      gdb_assert (lp->status == 0 || WIFSTOPPED (lp->status));
    }

  /* We don't actually detach from the LWP that has an id equal to the
     overall process id just yet.  */
  if (GET_LWP (lp->ptid) != GET_PID (lp->ptid))
    {
      errno = 0;
      if (ptrace (PTRACE_DETACH, GET_LWP (lp->ptid), 0,
		  WSTOPSIG (lp->status)) < 0)
	error ("Can't detach %s: %s", target_pid_to_str (lp->ptid),
	       safe_strerror (errno));

      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "PTRACE_DETACH (%s, %s, 0) (OK)\n",
			    target_pid_to_str (lp->ptid),
			    strsignal (WSTOPSIG (lp->status)));

      delete_lwp (lp->ptid);
    }

  return 0;
}

static void
lin_lwp_detach (char *args, int from_tty)
{
  iterate_over_lwps (detach_callback, NULL);

  /* Only the initial process should be left right now.  */
  gdb_assert (num_lwps == 1);

  trap_ptid = null_ptid;

  /* Destroy LWP info; it's no longer valid.  */
  init_lwp_list ();

  /* Restore the original signal mask.  */
  sigprocmask (SIG_SETMASK, &normal_mask, NULL);
  sigemptyset (&blocked_mask);

  inferior_ptid = pid_to_ptid (GET_PID (inferior_ptid));
  child_ops.to_detach (args, from_tty);
}


/* Resume LP.  */

static int
resume_callback (struct lwp_info *lp, void *data)
{
  if (lp->stopped && lp->status == 0)
    {
      struct thread_info *tp;

      child_resume (pid_to_ptid (GET_LWP (lp->ptid)), 0, TARGET_SIGNAL_0);
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "RC:  PTRACE_CONT %s, 0, 0 (resume sibling)\n",
			    target_pid_to_str (lp->ptid));
      lp->stopped = 0;
      lp->step = 0;
    }

  return 0;
}

static int
resume_clear_callback (struct lwp_info *lp, void *data)
{
  lp->resumed = 0;
  return 0;
}

static int
resume_set_callback (struct lwp_info *lp, void *data)
{
  lp->resumed = 1;
  return 0;
}

static void
lin_lwp_resume (ptid_t ptid, int step, enum target_signal signo)
{
  struct lwp_info *lp;
  int resume_all;

  /* A specific PTID means `step only this process id'.  */
  resume_all = (PIDGET (ptid) == -1);

  if (resume_all)
    iterate_over_lwps (resume_set_callback, NULL);
  else
    iterate_over_lwps (resume_clear_callback, NULL);

  /* If PID is -1, it's the current inferior that should be
     handled specially.  */
  if (PIDGET (ptid) == -1)
    ptid = inferior_ptid;

  lp = find_lwp_pid (ptid);
  if (lp)
    {
      ptid = pid_to_ptid (GET_LWP (lp->ptid));

      /* Remember if we're stepping.  */
      lp->step = step;

      /* Mark this LWP as resumed.  */
      lp->resumed = 1;

      /* If we have a pending wait status for this thread, there is no
         point in resuming the process.  */
      if (lp->status)
	{
	  /* FIXME: What should we do if we are supposed to continue
	     this thread with a signal?  */
	  gdb_assert (signo == TARGET_SIGNAL_0);
	  return;
	}

      /* Mark LWP as not stopped to prevent it from being continued by
         resume_callback.  */
      lp->stopped = 0;
    }

  if (resume_all)
    iterate_over_lwps (resume_callback, NULL);

  child_resume (ptid, step, signo);
  if (debug_lin_lwp)
    fprintf_unfiltered (gdb_stdlog,
			"LLR: %s %s, %s (resume event thread)\n",
			step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
			target_pid_to_str (ptid),
			signo ? strsignal (signo) : "0");
}


/* Issue kill to specified lwp.  */

static int tkill_failed;

static int
kill_lwp (int lwpid, int signo)
{
  errno = 0;

/* Use tkill, if possible, in case we are using nptl threads.  If tkill
   fails, then we are not using nptl threads and we should be using kill.  */

#ifdef HAVE_TKILL_SYSCALL
  if (!tkill_failed)
    {
      int ret = syscall (__NR_tkill, lwpid, signo);
      if (errno != ENOSYS)
	return ret;
      errno = 0;
      tkill_failed = 1;
    }
#endif

  return kill (lwpid, signo);
}

/* Handle a GNU/Linux extended wait response.  Most of the work we
   just pass off to linux_handle_extended_wait, but if it reports a
   clone event we need to add the new LWP to our list (and not report
   the trap to higher layers).  This function returns non-zero if
   the event should be ignored and we should wait again.  */

static int
lin_lwp_handle_extended (struct lwp_info *lp, int status)
{
  linux_handle_extended_wait (GET_LWP (lp->ptid), status,
			      &lp->waitstatus);

  /* TARGET_WAITKIND_SPURIOUS is used to indicate clone events.  */
  if (lp->waitstatus.kind == TARGET_WAITKIND_SPURIOUS)
    {
      struct lwp_info *new_lp;
      new_lp = add_lwp (BUILD_LWP (lp->waitstatus.value.related_pid,
				   GET_PID (inferior_ptid)));
      new_lp->cloned = 1;
      new_lp->stopped = 1;

      lp->waitstatus.kind = TARGET_WAITKIND_IGNORE;

      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "LLHE: Got clone event from LWP %ld, resuming\n",
			    GET_LWP (lp->ptid));
      ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);

      return 1;
    }

  return 0;
}

/* Wait for LP to stop.  Returns the wait status, or 0 if the LWP has
   exited.  */

static int
wait_lwp (struct lwp_info *lp)
{
  pid_t pid;
  int status;
  int thread_dead = 0;

  gdb_assert (!lp->stopped);
  gdb_assert (lp->status == 0);

  pid = waitpid (GET_LWP (lp->ptid), &status, 0);
  if (pid == -1 && errno == ECHILD)
    {
      pid = waitpid (GET_LWP (lp->ptid), &status, __WCLONE);
      if (pid == -1 && errno == ECHILD)
	{
	  /* The thread has previously exited.  We need to delete it
	     now because, for some vendor 2.4 kernels with NPTL
	     support backported, there won't be an exit event unless
	     it is the main thread.  2.6 kernels will report an exit
	     event for each thread that exits, as expected.  */
	  thread_dead = 1;
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog, "WL: %s vanished.\n",
				target_pid_to_str (lp->ptid));
	}
    }

  if (!thread_dead)
    {
      gdb_assert (pid == GET_LWP (lp->ptid));

      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "WL: waitpid %s received %s\n",
			      target_pid_to_str (lp->ptid),
			      status_to_str (status));
	}
    }

  /* Check if the thread has exited.  */
  if (WIFEXITED (status) || WIFSIGNALED (status))
    {
      thread_dead = 1;
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog, "WL: %s exited.\n",
			    target_pid_to_str (lp->ptid));
    }

  if (thread_dead)
    {
      if (in_thread_list (lp->ptid))
	{
	  /* Core GDB cannot deal with us deleting the current thread.  */
	  if (!ptid_equal (lp->ptid, inferior_ptid))
	    delete_thread (lp->ptid);
	  printf_unfiltered ("[%s exited]\n",
			     target_pid_to_str (lp->ptid));
	}

      delete_lwp (lp->ptid);
      return 0;
    }

  gdb_assert (WIFSTOPPED (status));

  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
    {
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "WL: Handling extended status 0x%06x\n",
			    status);
      if (lin_lwp_handle_extended (lp, status))
	return wait_lwp (lp);
    }

  return status;
}

/* Send a SIGSTOP to LP.  */

static int
stop_callback (struct lwp_info *lp, void *data)
{
  if (!lp->stopped && !lp->signalled)
    {
      int ret;

      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "SC:  kill %s **<SIGSTOP>**\n",
			      target_pid_to_str (lp->ptid));
	}
      errno = 0;
      ret = kill_lwp (GET_LWP (lp->ptid), SIGSTOP);
      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "SC:  lwp kill %d %s\n",
			      ret,
			      errno ? safe_strerror (errno) : "ERRNO-OK");
	}

      lp->signalled = 1;
      gdb_assert (lp->status == 0);
    }

  return 0;
}

/* Wait until LP is stopped.  If DATA is non-null it is interpreted as
   a pointer to a set of signals to be flushed immediately.  */

static int
stop_wait_callback (struct lwp_info *lp, void *data)
{
  sigset_t *flush_mask = data;

  if (!lp->stopped)
    {
      int status;

      status = wait_lwp (lp);
      if (status == 0)
	return 0;

      /* Ignore any signals in FLUSH_MASK.  */
      if (flush_mask && sigismember (flush_mask, WSTOPSIG (status)))
	{
	  if (!lp->signalled)
	    {
	      lp->stopped = 1;
	      return 0;
	    }

	  errno = 0;
	  ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog,
				"PTRACE_CONT %s, 0, 0 (%s)\n",
				target_pid_to_str (lp->ptid),
				errno ? safe_strerror (errno) : "OK");

	  return stop_wait_callback (lp, flush_mask);
	}

      if (WSTOPSIG (status) != SIGSTOP)
	{
	  if (WSTOPSIG (status) == SIGTRAP)
	    {
	      /* If a LWP other than the LWP that we're reporting an
	         event for has hit a GDB breakpoint (as opposed to
	         some random trap signal), then just arrange for it to
	         hit it again later.  We don't keep the SIGTRAP status
	         and don't forward the SIGTRAP signal to the LWP.  We
	         will handle the current event, eventually we will
	         resume all LWPs, and this one will get its breakpoint
	         trap again.

	         If we do not do this, then we run the risk that the
	         user will delete or disable the breakpoint, but the
	         thread will have already tripped on it.  */

	      /* Now resume this LWP and get the SIGSTOP event. */
	      errno = 0;
	      ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
	      if (debug_lin_lwp)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "PTRACE_CONT %s, 0, 0 (%s)\n",
				      target_pid_to_str (lp->ptid),
				      errno ? safe_strerror (errno) : "OK");

		  fprintf_unfiltered (gdb_stdlog,
				      "SWC: Candidate SIGTRAP event in %s\n",
				      target_pid_to_str (lp->ptid));
		}
	      /* Hold the SIGTRAP for handling by lin_lwp_wait. */
	      stop_wait_callback (lp, data);
	      /* If there's another event, throw it back into the queue. */
	      if (lp->status)
		{
		  if (debug_lin_lwp)
		    {
		      fprintf_unfiltered (gdb_stdlog,
					  "SWC: kill %s, %s\n",
					  target_pid_to_str (lp->ptid),
					  status_to_str ((int) status));
		    }
		  kill_lwp (GET_LWP (lp->ptid), WSTOPSIG (lp->status));
		}
	      /* Save the sigtrap event. */
	      lp->status = status;
	      return 0;
	    }
	  else
	    {
	      /* The thread was stopped with a signal other than
	         SIGSTOP, and didn't accidentally trip a breakpoint. */

	      if (debug_lin_lwp)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "SWC: Pending event %s in %s\n",
				      status_to_str ((int) status),
				      target_pid_to_str (lp->ptid));
		}
	      /* Now resume this LWP and get the SIGSTOP event. */
	      errno = 0;
	      ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "SWC: PTRACE_CONT %s, 0, 0 (%s)\n",
				    target_pid_to_str (lp->ptid),
				    errno ? safe_strerror (errno) : "OK");

	      /* Hold this event/waitstatus while we check to see if
	         there are any more (we still want to get that SIGSTOP). */
	      stop_wait_callback (lp, data);
	      /* If the lp->status field is still empty, use it to hold
	         this event.  If not, then this event must be returned
	         to the event queue of the LWP.  */
	      if (lp->status == 0)
		lp->status = status;
	      else
		{
		  if (debug_lin_lwp)
		    {
		      fprintf_unfiltered (gdb_stdlog,
					  "SWC: kill %s, %s\n",
					  target_pid_to_str (lp->ptid),
					  status_to_str ((int) status));
		    }
		  kill_lwp (GET_LWP (lp->ptid), WSTOPSIG (status));
		}
	      return 0;
	    }
	}
      else
	{
	  /* We caught the SIGSTOP that we intended to catch, so
	     there's no SIGSTOP pending.  */
	  lp->stopped = 1;
	  lp->signalled = 0;
	}
    }

  return 0;
}

/* Check whether PID has any pending signals in FLUSH_MASK.  If so set
   the appropriate bits in PENDING, and return 1 - otherwise return 0.  */

static int
lin_lwp_has_pending (int pid, sigset_t *pending, sigset_t *flush_mask)
{
  sigset_t blocked, ignored;
  int i;

  linux_proc_pending_signals (pid, pending, &blocked, &ignored);

  if (!flush_mask)
    return 0;

  for (i = 1; i < NSIG; i++)
    if (sigismember (pending, i))
      if (!sigismember (flush_mask, i)
	  || sigismember (&blocked, i)
	  || sigismember (&ignored, i))
	sigdelset (pending, i);

  if (sigisemptyset (pending))
    return 0;

  return 1;
}

/* DATA is interpreted as a mask of signals to flush.  If LP has
   signals pending, and they are all in the flush mask, then arrange
   to flush them.  LP should be stopped, as should all other threads
   it might share a signal queue with.  */

static int
flush_callback (struct lwp_info *lp, void *data)
{
  sigset_t *flush_mask = data;
  sigset_t pending, intersection, blocked, ignored;
  int pid, status;

  /* Normally, when an LWP exits, it is removed from the LWP list.  The
     last LWP isn't removed till later, however.  So if there is only
     one LWP on the list, make sure it's alive.  */
  if (lwp_list == lp && lp->next == NULL)
    if (!lin_lwp_thread_alive (lp->ptid))
      return 0;

  /* Just because the LWP is stopped doesn't mean that new signals
     can't arrive from outside, so this function must be careful of
     race conditions.  However, because all threads are stopped, we
     can assume that the pending mask will not shrink unless we resume
     the LWP, and that it will then get another signal.  We can't
     control which one, however.  */

  if (lp->status)
    {
      if (debug_lin_lwp)
	printf_unfiltered ("FC: LP has pending status %06x\n", lp->status);
      if (WIFSTOPPED (lp->status) && sigismember (flush_mask, WSTOPSIG (lp->status)))
	lp->status = 0;
    }

  while (lin_lwp_has_pending (GET_LWP (lp->ptid), &pending, flush_mask))
    {
      int ret;
      
      errno = 0;
      ret = ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stderr,
			    "FC: Sent PTRACE_CONT, ret %d %d\n", ret, errno);

      lp->stopped = 0;
      stop_wait_callback (lp, flush_mask);
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stderr,
			    "FC: Wait finished; saved status is %d\n",
			    lp->status);
    }

  return 0;
}

/* Return non-zero if LP has a wait status pending.  */

static int
status_callback (struct lwp_info *lp, void *data)
{
  /* Only report a pending wait status if we pretend that this has
     indeed been resumed.  */
  return (lp->status != 0 && lp->resumed);
}

/* Return non-zero if LP isn't stopped.  */

static int
running_callback (struct lwp_info *lp, void *data)
{
  return (lp->stopped == 0 || (lp->status != 0 && lp->resumed));
}

/* Count the LWP's that have had events.  */

static int
count_events_callback (struct lwp_info *lp, void *data)
{
  int *count = data;

  gdb_assert (count != NULL);

  /* Count only LWPs that have a SIGTRAP event pending.  */
  if (lp->status != 0
      && WIFSTOPPED (lp->status) && WSTOPSIG (lp->status) == SIGTRAP)
    (*count)++;

  return 0;
}

/* Select the LWP (if any) that is currently being single-stepped.  */

static int
select_singlestep_lwp_callback (struct lwp_info *lp, void *data)
{
  if (lp->step && lp->status != 0)
    return 1;
  else
    return 0;
}

/* Select the Nth LWP that has had a SIGTRAP event.  */

static int
select_event_lwp_callback (struct lwp_info *lp, void *data)
{
  int *selector = data;

  gdb_assert (selector != NULL);

  /* Select only LWPs that have a SIGTRAP event pending. */
  if (lp->status != 0
      && WIFSTOPPED (lp->status) && WSTOPSIG (lp->status) == SIGTRAP)
    if ((*selector)-- == 0)
      return 1;

  return 0;
}

static int
cancel_breakpoints_callback (struct lwp_info *lp, void *data)
{
  struct lwp_info *event_lp = data;

  /* Leave the LWP that has been elected to receive a SIGTRAP alone.  */
  if (lp == event_lp)
    return 0;

  /* If a LWP other than the LWP that we're reporting an event for has
     hit a GDB breakpoint (as opposed to some random trap signal),
     then just arrange for it to hit it again later.  We don't keep
     the SIGTRAP status and don't forward the SIGTRAP signal to the
     LWP.  We will handle the current event, eventually we will resume
     all LWPs, and this one will get its breakpoint trap again.

     If we do not do this, then we run the risk that the user will
     delete or disable the breakpoint, but the LWP will have already
     tripped on it.  */

  if (lp->status != 0
      && WIFSTOPPED (lp->status) && WSTOPSIG (lp->status) == SIGTRAP
      && breakpoint_inserted_here_p (read_pc_pid (lp->ptid) -
				     DECR_PC_AFTER_BREAK))
    {
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "CBC: Push back breakpoint for %s\n",
			    target_pid_to_str (lp->ptid));

      /* Back up the PC if necessary.  */
      if (DECR_PC_AFTER_BREAK)
	write_pc_pid (read_pc_pid (lp->ptid) - DECR_PC_AFTER_BREAK, lp->ptid);

      /* Throw away the SIGTRAP.  */
      lp->status = 0;
    }

  return 0;
}

/* Select one LWP out of those that have events pending.  */

static void
select_event_lwp (struct lwp_info **orig_lp, int *status)
{
  int num_events = 0;
  int random_selector;
  struct lwp_info *event_lp;

  /* Record the wait status for the origional LWP.  */
  (*orig_lp)->status = *status;

  /* Give preference to any LWP that is being single-stepped.  */
  event_lp = iterate_over_lwps (select_singlestep_lwp_callback, NULL);
  if (event_lp != NULL)
    {
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "SEL: Select single-step %s\n",
			    target_pid_to_str (event_lp->ptid));
    }
  else
    {
      /* No single-stepping LWP.  Select one at random, out of those
         which have had SIGTRAP events.  */

      /* First see how many SIGTRAP events we have.  */
      iterate_over_lwps (count_events_callback, &num_events);

      /* Now randomly pick a LWP out of those that have had a SIGTRAP.  */
      random_selector = (int)
	((num_events * (double) rand ()) / (RAND_MAX + 1.0));

      if (debug_lin_lwp && num_events > 1)
	fprintf_unfiltered (gdb_stdlog,
			    "SEL: Found %d SIGTRAP events, selecting #%d\n",
			    num_events, random_selector);

      event_lp = iterate_over_lwps (select_event_lwp_callback,
				    &random_selector);
    }

  if (event_lp != NULL)
    {
      /* Switch the event LWP.  */
      *orig_lp = event_lp;
      *status = event_lp->status;
    }

  /* Flush the wait status for the event LWP.  */
  (*orig_lp)->status = 0;
}

/* Return non-zero if LP has been resumed.  */

static int
resumed_callback (struct lwp_info *lp, void *data)
{
  return lp->resumed;
}

#ifdef CHILD_WAIT

/* We need to override child_wait to support attaching to cloned
   processes, since a normal wait (as done by the default version)
   ignores those processes.  */

/* Wait for child PTID to do something.  Return id of the child,
   minus_one_ptid in case of error; store status into *OURSTATUS.  */

ptid_t
child_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  int save_errno;
  int status;
  pid_t pid;

  ourstatus->kind = TARGET_WAITKIND_IGNORE;

  do
    {
      set_sigint_trap ();	/* Causes SIGINT to be passed on to the
				   attached process.  */
      set_sigio_trap ();

      pid = waitpid (GET_PID (ptid), &status, 0);
      if (pid == -1 && errno == ECHILD)
	/* Try again with __WCLONE to check cloned processes.  */
	pid = waitpid (GET_PID (ptid), &status, __WCLONE);

      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "CW:  waitpid %ld received %s\n",
			      (long) pid, status_to_str (status));
	}

      save_errno = errno;

      /* Make sure we don't report an event for the exit of the
         original program, if we've detached from it.  */
      if (pid != -1 && !WIFSTOPPED (status) && pid != GET_PID (inferior_ptid))
	{
	  pid = -1;
	  save_errno = EINTR;
	}

      /* Check for stop events reported by a process we didn't already
	 know about - in this case, anything other than inferior_ptid.

	 If we're expecting to receive stopped processes after fork,
	 vfork, and clone events, then we'll just add the new one to
	 our list and go back to waiting for the event to be reported
	 - the stopped process might be returned from waitpid before
	 or after the event is.  If we want to handle debugging of
	 CLONE_PTRACE processes we need to do more here, i.e. switch
	 to multi-threaded mode.  */
      if (pid != -1 && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP
	  && pid != GET_PID (inferior_ptid))
	{
	  linux_record_stopped_pid (pid);
	  pid = -1;
	  save_errno = EINTR;
	}

      /* Handle GNU/Linux's extended waitstatus for trace events.  */
      if (pid != -1 && WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP
	  && status >> 16 != 0)
	{
	  linux_handle_extended_wait (pid, status, ourstatus);

	  /* If we see a clone event, detach the child, and don't
	     report the event.  It would be nice to offer some way to
	     switch into a non-thread-db based threaded mode at this
	     point.  */
	  if (ourstatus->kind == TARGET_WAITKIND_SPURIOUS)
	    {
	      ptrace (PTRACE_DETACH, ourstatus->value.related_pid, 0, 0);
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
	      ptrace (PTRACE_CONT, pid, 0, 0);
	      pid = -1;
	      save_errno = EINTR;
	    }
	}

      clear_sigio_trap ();
      clear_sigint_trap ();
    }
  while (pid == -1 && save_errno == EINTR);

  if (pid == -1)
    {
      warning ("Child process unexpectedly missing: %s",
	       safe_strerror (errno));

      /* Claim it exited with unknown signal.  */
      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
      ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
      return minus_one_ptid;
    }

  if (ourstatus->kind == TARGET_WAITKIND_IGNORE)
    store_waitstatus (ourstatus, status);

  return pid_to_ptid (pid);
}

#endif

/* Stop an active thread, verify it still exists, then resume it.  */

static int
stop_and_resume_callback (struct lwp_info *lp, void *data)
{
  struct lwp_info *ptr;

  if (!lp->stopped && !lp->signalled)
    {
      stop_callback (lp, NULL);
      stop_wait_callback (lp, NULL);
      /* Resume if the lwp still exists.  */
      for (ptr = lwp_list; ptr; ptr = ptr->next)
	if (lp == ptr)
	  {
	    resume_callback (lp, NULL);
	    resume_set_callback (lp, NULL);
	  }
    }
  return 0;
}

static ptid_t
lin_lwp_wait (ptid_t ptid, struct target_waitstatus *ourstatus)
{
  struct lwp_info *lp = NULL;
  int options = 0;
  int status = 0;
  pid_t pid = PIDGET (ptid);
  sigset_t flush_mask;

  sigemptyset (&flush_mask);

  /* Make sure SIGCHLD is blocked.  */
  if (!sigismember (&blocked_mask, SIGCHLD))
    {
      sigaddset (&blocked_mask, SIGCHLD);
      sigprocmask (SIG_BLOCK, &blocked_mask, NULL);
    }

retry:

  /* Make sure there is at least one LWP that has been resumed, at
     least if there are any LWPs at all.  */
  gdb_assert (num_lwps == 0 || iterate_over_lwps (resumed_callback, NULL));

  /* First check if there is a LWP with a wait status pending.  */
  if (pid == -1)
    {
      /* Any LWP that's been resumed will do.  */
      lp = iterate_over_lwps (status_callback, NULL);
      if (lp)
	{
	  status = lp->status;
	  lp->status = 0;

	  if (debug_lin_lwp && status)
	    fprintf_unfiltered (gdb_stdlog,
				"LLW: Using pending wait status %s for %s.\n",
				status_to_str (status),
				target_pid_to_str (lp->ptid));
	}

      /* But if we don't fine one, we'll have to wait, and check both
         cloned and uncloned processes.  We start with the cloned
         processes.  */
      options = __WCLONE | WNOHANG;
    }
  else if (is_lwp (ptid))
    {
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: Waiting for specific LWP %s.\n",
			    target_pid_to_str (ptid));

      /* We have a specific LWP to check.  */
      lp = find_lwp_pid (ptid);
      gdb_assert (lp);
      status = lp->status;
      lp->status = 0;

      if (debug_lin_lwp && status)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: Using pending wait status %s for %s.\n",
			    status_to_str (status),
			    target_pid_to_str (lp->ptid));

      /* If we have to wait, take into account whether PID is a cloned
         process or not.  And we have to convert it to something that
         the layer beneath us can understand.  */
      options = lp->cloned ? __WCLONE : 0;
      pid = GET_LWP (ptid);
    }

  if (status && lp->signalled)
    {
      /* A pending SIGSTOP may interfere with the normal stream of
         events.  In a typical case where interference is a problem,
         we have a SIGSTOP signal pending for LWP A while
         single-stepping it, encounter an event in LWP B, and take the
         pending SIGSTOP while trying to stop LWP A.  After processing
         the event in LWP B, LWP A is continued, and we'll never see
         the SIGTRAP associated with the last time we were
         single-stepping LWP A.  */

      /* Resume the thread.  It should halt immediately returning the
         pending SIGSTOP.  */
      registers_changed ();
      child_resume (pid_to_ptid (GET_LWP (lp->ptid)), lp->step,
		    TARGET_SIGNAL_0);
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: %s %s, 0, 0 (expect SIGSTOP)\n",
			    lp->step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
			    target_pid_to_str (lp->ptid));
      lp->stopped = 0;
      gdb_assert (lp->resumed);

      /* This should catch the pending SIGSTOP.  */
      stop_wait_callback (lp, NULL);
    }

  set_sigint_trap ();		/* Causes SIGINT to be passed on to the
				   attached process. */
  set_sigio_trap ();

  while (status == 0)
    {
      pid_t lwpid;

      lwpid = waitpid (pid, &status, options);
      if (lwpid > 0)
	{
	  gdb_assert (pid == -1 || lwpid == pid);

	  if (debug_lin_lwp)
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  "LLW: waitpid %ld received %s\n",
				  (long) lwpid, status_to_str (status));
	    }

	  lp = find_lwp_pid (pid_to_ptid (lwpid));

	  /* Check for stop events reported by a process we didn't
	     already know about - anything not already in our LWP
	     list.

	     If we're expecting to receive stopped processes after
	     fork, vfork, and clone events, then we'll just add the
	     new one to our list and go back to waiting for the event
	     to be reported - the stopped process might be returned
	     from waitpid before or after the event is.  */
	  if (WIFSTOPPED (status) && !lp)
	    {
	      linux_record_stopped_pid (lwpid);
	      status = 0;
	      continue;
	    }

	  /* Make sure we don't report an event for the exit of an LWP not in
	     our list, i.e.  not part of the current process.  This can happen
	     if we detach from a program we original forked and then it
	     exits.  */
	  if (!WIFSTOPPED (status) && !lp)
	    {
	      status = 0;
	      continue;
	    }

	  /* NOTE drow/2003-06-17: This code seems to be meant for debugging
	     CLONE_PTRACE processes which do not use the thread library -
	     otherwise we wouldn't find the new LWP this way.  That doesn't
	     currently work, and the following code is currently unreachable
	     due to the two blocks above.  If it's fixed some day, this code
	     should be broken out into a function so that we can also pick up
	     LWPs from the new interface.  */
	  if (!lp)
	    {
	      lp = add_lwp (BUILD_LWP (lwpid, GET_PID (inferior_ptid)));
	      if (options & __WCLONE)
		lp->cloned = 1;

	      if (threaded)
		{
		  gdb_assert (WIFSTOPPED (status)
			      && WSTOPSIG (status) == SIGSTOP);
		  lp->signalled = 1;

		  if (!in_thread_list (inferior_ptid))
		    {
		      inferior_ptid = BUILD_LWP (GET_PID (inferior_ptid),
						 GET_PID (inferior_ptid));
		      add_thread (inferior_ptid);
		    }

		  add_thread (lp->ptid);
		  printf_unfiltered ("[New %s]\n",
				     target_pid_to_str (lp->ptid));
		}
	    }

	  /* Handle GNU/Linux's extended waitstatus for trace events.  */
	  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
	    {
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: Handling extended status 0x%06x\n",
				    status);
	      if (lin_lwp_handle_extended (lp, status))
		{
		  status = 0;
		  continue;
		}
	    }

	  /* Check if the thread has exited.  */
	  if ((WIFEXITED (status) || WIFSIGNALED (status)) && num_lwps > 1)
	    {
	      if (in_thread_list (lp->ptid))
		{
		  /* Core GDB cannot deal with us deleting the current
		     thread.  */
		  if (!ptid_equal (lp->ptid, inferior_ptid))
		    delete_thread (lp->ptid);
		  printf_unfiltered ("[%s exited]\n",
				     target_pid_to_str (lp->ptid));
		}

	      /* If this is the main thread, we must stop all threads and
	         verify if they are still alive.  This is because in the nptl
	         thread model, there is no signal issued for exiting LWPs
	         other than the main thread.  We only get the main thread
	         exit signal once all child threads have already exited.
	         If we stop all the threads and use the stop_wait_callback
	         to check if they have exited we can determine whether this
	         signal should be ignored or whether it means the end of the
	         debugged application, regardless of which threading model
	         is being used.  */
	      if (GET_PID (lp->ptid) == GET_LWP (lp->ptid))
		{
		  lp->stopped = 1;
		  iterate_over_lwps (stop_and_resume_callback, NULL);
		}

	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s exited.\n",
				    target_pid_to_str (lp->ptid));

	      delete_lwp (lp->ptid);

	      /* If there is at least one more LWP, then the exit signal
	         was not the end of the debugged application and should be
	         ignored.  */
	      if (num_lwps > 0)
		{
		  /* Make sure there is at least one thread running.  */
		  gdb_assert (iterate_over_lwps (running_callback, NULL));

		  /* Discard the event.  */
		  status = 0;
		  continue;
		}
	    }

	  /* Check if the current LWP has previously exited.  In the nptl
	     thread model, LWPs other than the main thread do not issue
	     signals when they exit so we must check whenever the thread
	     has stopped.  A similar check is made in stop_wait_callback().  */
	  if (num_lwps > 1 && !lin_lwp_thread_alive (lp->ptid))
	    {
	      if (in_thread_list (lp->ptid))
		{
		  /* Core GDB cannot deal with us deleting the current
		     thread.  */
		  if (!ptid_equal (lp->ptid, inferior_ptid))
		    delete_thread (lp->ptid);
		  printf_unfiltered ("[%s exited]\n",
				     target_pid_to_str (lp->ptid));
		}
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s exited.\n",
				    target_pid_to_str (lp->ptid));

	      delete_lwp (lp->ptid);

	      /* Make sure there is at least one thread running.  */
	      gdb_assert (iterate_over_lwps (running_callback, NULL));

	      /* Discard the event.  */
	      status = 0;
	      continue;
	    }

	  /* Make sure we don't report a SIGSTOP that we sent
	     ourselves in an attempt to stop an LWP.  */
	  if (lp->signalled
	      && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP)
	    {
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: Delayed SIGSTOP caught for %s.\n",
				    target_pid_to_str (lp->ptid));

	      /* This is a delayed SIGSTOP.  */
	      lp->signalled = 0;

	      registers_changed ();
	      child_resume (pid_to_ptid (GET_LWP (lp->ptid)), lp->step,
			    TARGET_SIGNAL_0);
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s %s, 0, 0 (discard SIGSTOP)\n",
				    lp->step ?
				    "PTRACE_SINGLESTEP" : "PTRACE_CONT",
				    target_pid_to_str (lp->ptid));

	      lp->stopped = 0;
	      gdb_assert (lp->resumed);

	      /* Discard the event.  */
	      status = 0;
	      continue;
	    }

	  break;
	}

      if (pid == -1)
	{
	  /* Alternate between checking cloned and uncloned processes.  */
	  options ^= __WCLONE;

	  /* And suspend every time we have checked both.  */
	  if (options & __WCLONE)
	    sigsuspend (&suspend_mask);
	}

      /* We shouldn't end up here unless we want to try again.  */
      gdb_assert (status == 0);
    }

  clear_sigio_trap ();
  clear_sigint_trap ();

  gdb_assert (lp);

  /* Don't report signals that GDB isn't interested in, such as
     signals that are neither printed nor stopped upon.  Stopping all
     threads can be a bit time-consuming so if we want decent
     performance with heavily multi-threaded programs, especially when
     they're using a high frequency timer, we'd better avoid it if we
     can.  */

  if (WIFSTOPPED (status))
    {
      int signo = target_signal_from_host (WSTOPSIG (status));

      if (signal_stop_state (signo) == 0
	  && signal_print_state (signo) == 0
	  && signal_pass_state (signo) == 1)
	{
	  /* FIMXE: kettenis/2001-06-06: Should we resume all threads
	     here?  It is not clear we should.  GDB may not expect
	     other threads to run.  On the other hand, not resuming
	     newly attached threads may cause an unwanted delay in
	     getting them running.  */
	  registers_changed ();
	  child_resume (pid_to_ptid (GET_LWP (lp->ptid)), lp->step, signo);
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog,
				"LLW: %s %s, %s (preempt 'handle')\n",
				lp->step ?
				"PTRACE_SINGLESTEP" : "PTRACE_CONT",
				target_pid_to_str (lp->ptid),
				signo ? strsignal (signo) : "0");
	  lp->stopped = 0;
	  status = 0;
	  goto retry;
	}

      if (signo == TARGET_SIGNAL_INT && signal_pass_state (signo) == 0)
	{
	  /* If ^C/BREAK is typed at the tty/console, SIGINT gets
	     forwarded to the entire process group, that is, all LWP's
	     will receive it.  Since we only want to report it once,
	     we try to flush it from all LWPs except this one.  */
	  sigaddset (&flush_mask, SIGINT);
	}
    }

  /* This LWP is stopped now.  */
  lp->stopped = 1;

  if (debug_lin_lwp)
    fprintf_unfiltered (gdb_stdlog, "LLW: Candidate event %s in %s.\n",
			status_to_str (status), target_pid_to_str (lp->ptid));

  /* Now stop all other LWP's ...  */
  iterate_over_lwps (stop_callback, NULL);

  /* ... and wait until all of them have reported back that they're no
     longer running.  */
  iterate_over_lwps (stop_wait_callback, &flush_mask);
  iterate_over_lwps (flush_callback, &flush_mask);

  /* If we're not waiting for a specific LWP, choose an event LWP from
     among those that have had events.  Giving equal priority to all
     LWPs that have had events helps prevent starvation.  */
  if (pid == -1)
    select_event_lwp (&lp, &status);

  /* Now that we've selected our final event LWP, cancel any
     breakpoints in other LWPs that have hit a GDB breakpoint.  See
     the comment in cancel_breakpoints_callback to find out why.  */
  iterate_over_lwps (cancel_breakpoints_callback, lp);

  /* If we're not running in "threaded" mode, we'll report the bare
     process id.  */

  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP)
    {
      trap_ptid = (threaded ? lp->ptid : pid_to_ptid (GET_LWP (lp->ptid)));
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: trap_ptid is %s.\n",
			    target_pid_to_str (trap_ptid));
    }
  else
    trap_ptid = null_ptid;

  if (lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)
    {
      *ourstatus = lp->waitstatus;
      lp->waitstatus.kind = TARGET_WAITKIND_IGNORE;
    }
  else
    store_waitstatus (ourstatus, status);

  return (threaded ? lp->ptid : pid_to_ptid (GET_LWP (lp->ptid)));
}

static int
kill_callback (struct lwp_info *lp, void *data)
{
  errno = 0;
  ptrace (PTRACE_KILL, GET_LWP (lp->ptid), 0, 0);
  if (debug_lin_lwp)
    fprintf_unfiltered (gdb_stdlog,
			"KC:  PTRACE_KILL %s, 0, 0 (%s)\n",
			target_pid_to_str (lp->ptid),
			errno ? safe_strerror (errno) : "OK");

  return 0;
}

static int
kill_wait_callback (struct lwp_info *lp, void *data)
{
  pid_t pid;

  /* We must make sure that there are no pending events (delayed
     SIGSTOPs, pending SIGTRAPs, etc.) to make sure the current
     program doesn't interfere with any following debugging session.  */

  /* For cloned processes we must check both with __WCLONE and
     without, since the exit status of a cloned process isn't reported
     with __WCLONE.  */
  if (lp->cloned)
    {
      do
	{
	  pid = waitpid (GET_LWP (lp->ptid), NULL, __WCLONE);
	  if (pid != (pid_t) -1 && debug_lin_lwp)
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  "KWC: wait %s received unknown.\n",
				  target_pid_to_str (lp->ptid));
	    }
	}
      while (pid == GET_LWP (lp->ptid));

      gdb_assert (pid == -1 && errno == ECHILD);
    }

  do
    {
      pid = waitpid (GET_LWP (lp->ptid), NULL, 0);
      if (pid != (pid_t) -1 && debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "KWC: wait %s received unk.\n",
			      target_pid_to_str (lp->ptid));
	}
    }
  while (pid == GET_LWP (lp->ptid));

  gdb_assert (pid == -1 && errno == ECHILD);
  return 0;
}

static void
lin_lwp_kill (void)
{
  /* Kill all LWP's ...  */
  iterate_over_lwps (kill_callback, NULL);

  /* ... and wait until we've flushed all events.  */
  iterate_over_lwps (kill_wait_callback, NULL);

  target_mourn_inferior ();
}

static void
lin_lwp_create_inferior (char *exec_file, char *allargs, char **env,
			 int from_tty)
{
  child_ops.to_create_inferior (exec_file, allargs, env, from_tty);
}

static void
lin_lwp_mourn_inferior (void)
{
  trap_ptid = null_ptid;

  /* Destroy LWP info; it's no longer valid.  */
  init_lwp_list ();

  /* Restore the original signal mask.  */
  sigprocmask (SIG_SETMASK, &normal_mask, NULL);
  sigemptyset (&blocked_mask);

  child_ops.to_mourn_inferior ();
}

static int
lin_lwp_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		     struct mem_attrib *attrib, struct target_ops *target)
{
  struct cleanup *old_chain = save_inferior_ptid ();
  int xfer;

  if (is_lwp (inferior_ptid))
    inferior_ptid = pid_to_ptid (GET_LWP (inferior_ptid));

  xfer = linux_proc_xfer_memory (memaddr, myaddr, len, write, attrib, target);
  if (xfer == 0)
    xfer = child_xfer_memory (memaddr, myaddr, len, write, attrib, target);

  do_cleanups (old_chain);
  return xfer;
}

static int
lin_lwp_thread_alive (ptid_t ptid)
{
  gdb_assert (is_lwp (ptid));

  errno = 0;
  ptrace (PTRACE_PEEKUSER, GET_LWP (ptid), 0, 0);
  if (debug_lin_lwp)
    fprintf_unfiltered (gdb_stdlog,
			"LLTA: PTRACE_PEEKUSER %s, 0, 0 (%s)\n",
			target_pid_to_str (ptid),
			errno ? safe_strerror (errno) : "OK");
  if (errno)
    return 0;

  return 1;
}

static char *
lin_lwp_pid_to_str (ptid_t ptid)
{
  static char buf[64];

  if (is_lwp (ptid))
    {
      snprintf (buf, sizeof (buf), "LWP %ld", GET_LWP (ptid));
      return buf;
    }

  return normal_pid_to_str (ptid);
}

static void
init_lin_lwp_ops (void)
{
#if 0
  lin_lwp_ops.to_open = lin_lwp_open;
#endif
  lin_lwp_ops.to_shortname = "lwp-layer";
  lin_lwp_ops.to_longname = "lwp-layer";
  lin_lwp_ops.to_doc = "Low level threads support (LWP layer)";
  lin_lwp_ops.to_attach = lin_lwp_attach;
  lin_lwp_ops.to_detach = lin_lwp_detach;
  lin_lwp_ops.to_resume = lin_lwp_resume;
  lin_lwp_ops.to_wait = lin_lwp_wait;
  /* fetch_inferior_registers and store_inferior_registers will
     honor the LWP id, so we can use them directly.  */
  lin_lwp_ops.to_fetch_registers = fetch_inferior_registers;
  lin_lwp_ops.to_store_registers = store_inferior_registers;
  lin_lwp_ops.to_xfer_memory = lin_lwp_xfer_memory;
  lin_lwp_ops.to_kill = lin_lwp_kill;
  lin_lwp_ops.to_create_inferior = lin_lwp_create_inferior;
  lin_lwp_ops.to_mourn_inferior = lin_lwp_mourn_inferior;
  lin_lwp_ops.to_thread_alive = lin_lwp_thread_alive;
  lin_lwp_ops.to_pid_to_str = lin_lwp_pid_to_str;
  lin_lwp_ops.to_post_startup_inferior = child_post_startup_inferior;
  lin_lwp_ops.to_post_attach = child_post_attach;
  lin_lwp_ops.to_insert_fork_catchpoint = child_insert_fork_catchpoint;
  lin_lwp_ops.to_insert_vfork_catchpoint = child_insert_vfork_catchpoint;
  lin_lwp_ops.to_insert_exec_catchpoint = child_insert_exec_catchpoint;

  lin_lwp_ops.to_stratum = thread_stratum;
  lin_lwp_ops.to_has_thread_control = tc_schedlock;
  lin_lwp_ops.to_magic = OPS_MAGIC;
}

static void
sigchld_handler (int signo)
{
  /* Do nothing.  The only reason for this handler is that it allows
     us to use sigsuspend in lin_lwp_wait above to wait for the
     arrival of a SIGCHLD.  */
}

void
_initialize_lin_lwp (void)
{
  struct sigaction action;

  extern void thread_db_init (struct target_ops *);

  init_lin_lwp_ops ();
  add_target (&lin_lwp_ops);
  thread_db_init (&lin_lwp_ops);

  /* Save the original signal mask.  */
  sigprocmask (SIG_SETMASK, NULL, &normal_mask);

  action.sa_handler = sigchld_handler;
  sigemptyset (&action.sa_mask);
  action.sa_flags = 0;
  sigaction (SIGCHLD, &action, NULL);

  /* Make sure we don't block SIGCHLD during a sigsuspend.  */
  sigprocmask (SIG_SETMASK, NULL, &suspend_mask);
  sigdelset (&suspend_mask, SIGCHLD);

  sigemptyset (&blocked_mask);

  deprecated_add_show_from_set
    (add_set_cmd ("lin-lwp", no_class, var_zinteger,
		  (char *) &debug_lin_lwp,
		  "Set debugging of GNU/Linux lwp module.\n\
Enables printf debugging output.\n", &setdebuglist), &showdebuglist);
}


/* FIXME: kettenis/2000-08-26: The stuff on this page is specific to
   the GNU/Linux Threads library and therefore doesn't really belong
   here.  */

/* Read variable NAME in the target and return its value if found.
   Otherwise return zero.  It is assumed that the type of the variable
   is `int'.  */

static int
get_signo (const char *name)
{
  struct minimal_symbol *ms;
  int signo;

  ms = lookup_minimal_symbol (name, NULL, NULL);
  if (ms == NULL)
    return 0;

  if (target_read_memory (SYMBOL_VALUE_ADDRESS (ms), (char *) &signo,
			  sizeof (signo)) != 0)
    return 0;

  return signo;
}

/* Return the set of signals used by the threads library in *SET.  */

void
lin_thread_get_thread_signals (sigset_t *set)
{
  struct sigaction action;
  int restart, cancel;

  sigemptyset (set);

  restart = get_signo ("__pthread_sig_restart");
  if (restart == 0)
    return;

  cancel = get_signo ("__pthread_sig_cancel");
  if (cancel == 0)
    return;

  sigaddset (set, restart);
  sigaddset (set, cancel);

  /* The GNU/Linux Threads library makes terminating threads send a
     special "cancel" signal instead of SIGCHLD.  Make sure we catch
     those (to prevent them from terminating GDB itself, which is
     likely to be their default action) and treat them the same way as
     SIGCHLD.  */

  action.sa_handler = sigchld_handler;
  sigemptyset (&action.sa_mask);
  action.sa_flags = 0;
  sigaction (cancel, &action, NULL);

  /* We block the "cancel" signal throughout this code ...  */
  sigaddset (&blocked_mask, cancel);
  sigprocmask (SIG_BLOCK, &blocked_mask, NULL);

  /* ... except during a sigsuspend.  */
  sigdelset (&suspend_mask, cancel);
}
@


1.57
log
@	* lin-lwp.c (child_wait): Continue inferior after processing
	PTRACE_EVENT_CLONE event.
@
text
@@


1.56
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d1216 1
@


1.55
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@d1899 4
a1902 3
  add_show_from_set (add_set_cmd ("lin-lwp", no_class, var_zinteger,
				  (char *) &debug_lin_lwp,
				  "Set debugging of GNU/Linux lwp module.\n\
@


1.54
log
@	* Makefile.in (linux_nat_h): Update dependencies.
	* configure.in: Check for <gnu/libc-version.h>.
	* configure: Regenerate.
	* config.in: Regenerate.
	* linux-nat.h: Include "target.h".  Add waitstatus field to
	struct lwp_info.
	* lin-lwp.c (add_lwp): Initialize waitstatus.kind.
	(lin_lwp_attach_lwp): Don't attach to LWPs we have already attached
	to.
	(lin_lwp_handle_extended): New function.  Handle clone events.
	(wait_lwp): Use lin_lwp_handle_extended.  Update comment about
	thread exit events.
	(child_wait): Handle clone events.
	(lin_lwp_wait: Use lin_lwp_handle_extended and handle clone events.
	* linux-nat.c (linux_enable_event_reporting): Turn on
	PTRACE_O_TRACECLONE.
	(linux_handle_extended_wait): Handle clone events.
	* thread-db.c: Include <gnu/libc-version.h>.
	(struct private_thread_info): Add dying flag.
	(enable_thread_event_reporting): Enable TD_DEATH for glibc 2.2 and
	higher.
	(attach_thread): Update comments.  Handle dying threads.
	(detach_thread): Set the dying flag.
	(check_event): Always call attach_thread.
@
text
@d1761 2
a1762 1
lin_lwp_create_inferior (char *exec_file, char *allargs, char **env)
d1764 1
a1764 1
  child_ops.to_create_inferior (exec_file, allargs, env);
@


1.53
log
@	* lin-lwp.c (lin_lwp_wait): Pass the LWP ID to
	linux_handle_extended_wait.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d186 2
d283 1
a283 1
  struct lwp_info *lp;
d298 1
a298 1
  lp = find_lwp_pid (ptid);
d302 7
a308 3
  /* We assume that we're already attached to any LWP that has an
     id equal to the overall process id.  */
  if (GET_LWP (ptid) != GET_PID (ptid))
d599 35
d653 5
a657 3
	  /* The thread has previously exited.  We need to delete it now
	     because in the case of NPTL threads, there won't be an
	     exit event unless it is the main thread.  */
d704 11
d1154 2
d1202 19
d1237 2
a1238 3
  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
    return linux_handle_extended_wait (pid, status, ourstatus);
a1239 1
  store_waitstatus (ourstatus, status);
d1447 14
d1678 1
a1678 2
  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
d1680 2
a1681 2
      linux_handle_extended_wait (GET_LWP (lp->ptid), status, ourstatus);
      return trap_ptid;
d1683 2
a1685 1
  store_waitstatus (ourstatus, status);
@


1.52
log
@
2003-10-08  Jeff Johnston  <jjohnstn@@redhat.com>

        * lin-lwp.c (stop_and_resume_callback): Set the resumed flag
        for any lwp we resume.
        (running_callback): Add lwps that have pending status events
        against them to be considered running.
@
text
@d1594 1
a1594 2
      linux_handle_extended_wait (ptid_get_pid (trap_ptid),
				  status, ourstatus);
@


1.52.6.1
log
@Merge mainline to intercu branch.
@
text
@d1594 2
a1595 1
      linux_handle_extended_wait (GET_LWP (lp->ptid), status, ourstatus);
@


1.52.6.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a185 2
  lp->waitstatus.kind = TARGET_WAITKIND_IGNORE;

d281 1
a281 1
  struct lwp_info *lp, *found_lp;
d296 1
a296 1
  found_lp = lp = find_lwp_pid (ptid);
d300 3
a302 7
  /* We assume that we're already attached to any LWP that has an id
     equal to the overall process id, and to any LWP that is already
     in our list of LWPs.  If we're not seeing exit events from threads
     and we've had PID wraparound since we last tried to stop all threads,
     this assumption might be wrong; fortunately, this is very unlikely
     to happen.  */
  if (GET_LWP (ptid) != GET_PID (ptid) && found_lp == NULL)
a592 35
/* Handle a GNU/Linux extended wait response.  Most of the work we
   just pass off to linux_handle_extended_wait, but if it reports a
   clone event we need to add the new LWP to our list (and not report
   the trap to higher layers).  This function returns non-zero if
   the event should be ignored and we should wait again.  */

static int
lin_lwp_handle_extended (struct lwp_info *lp, int status)
{
  linux_handle_extended_wait (GET_LWP (lp->ptid), status,
			      &lp->waitstatus);

  /* TARGET_WAITKIND_SPURIOUS is used to indicate clone events.  */
  if (lp->waitstatus.kind == TARGET_WAITKIND_SPURIOUS)
    {
      struct lwp_info *new_lp;
      new_lp = add_lwp (BUILD_LWP (lp->waitstatus.value.related_pid,
				   GET_PID (inferior_ptid)));
      new_lp->cloned = 1;
      new_lp->stopped = 1;

      lp->waitstatus.kind = TARGET_WAITKIND_IGNORE;

      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "LLHE: Got clone event from LWP %ld, resuming\n",
			    GET_LWP (lp->ptid));
      ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);

      return 1;
    }

  return 0;
}

d612 3
a614 5
	  /* The thread has previously exited.  We need to delete it
	     now because, for some vendor 2.4 kernels with NPTL
	     support backported, there won't be an exit event unless
	     it is the main thread.  2.6 kernels will report an exit
	     event for each thread that exits, as expected.  */
a660 11
  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
    {
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "WL: Handling extended status 0x%06x\n",
			    status);
      if (lin_lwp_handle_extended (lp, status))
	return wait_lwp (lp);
    }

a1099 2
  ourstatus->kind = TARGET_WAITKIND_IGNORE;

a1145 19
      /* Handle GNU/Linux's extended waitstatus for trace events.  */
      if (pid != -1 && WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP
	  && status >> 16 != 0)
	{
	  linux_handle_extended_wait (pid, status, ourstatus);

	  /* If we see a clone event, detach the child, and don't
	     report the event.  It would be nice to offer some way to
	     switch into a non-thread-db based threaded mode at this
	     point.  */
	  if (ourstatus->kind == TARGET_WAITKIND_SPURIOUS)
	    {
	      ptrace (PTRACE_DETACH, ourstatus->value.related_pid, 0, 0);
	      ourstatus->kind = TARGET_WAITKIND_IGNORE;
	      pid = -1;
	      save_errno = EINTR;
	    }
	}

d1162 3
a1164 2
  if (ourstatus->kind == TARGET_WAITKIND_IGNORE)
    store_waitstatus (ourstatus, status);
d1166 1
a1373 14
	  /* Handle GNU/Linux's extended waitstatus for trace events.  */
	  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
	    {
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: Handling extended status 0x%06x\n",
				    status);
	      if (lin_lwp_handle_extended (lp, status))
		{
		  status = 0;
		  continue;
		}
	    }

d1591 2
a1592 1
  if (lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)
d1594 2
a1595 2
      *ourstatus = lp->waitstatus;
      lp->waitstatus.kind = TARGET_WAITKIND_IGNORE;
a1596 2
  else
    store_waitstatus (ourstatus, status);
d1598 1
@


1.52.6.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a1215 1
	      ptrace (PTRACE_CONT, pid, 0, 0);
d1761 1
a1761 2
lin_lwp_create_inferior (char *exec_file, char *allargs, char **env,
			 int from_tty)
d1763 1
a1763 1
  child_ops.to_create_inferior (exec_file, allargs, env, from_tty);
d1898 3
a1900 4
  deprecated_add_show_from_set
    (add_set_cmd ("lin-lwp", no_class, var_zinteger,
		  (char *) &debug_lin_lwp,
		  "Set debugging of GNU/Linux lwp module.\n\
@


1.51
log
@	* lin-lwp.c (detach_callback): Don't call stop_wait_callback.
	(stop_wait_callback): Handle !lp->signalled also.
	(lin_lwp_has_pending, flush_callback): New functions.
	(lin_lwp_wait): Call flush_callback.
	* linux-proc.c (linux_proc_add_line_to_sigset): New function.
	(linux_proc_pending_signals): New function.
	* linux-nat.h (linux_proc_pending_signals): Add prototype.
@
text
@d933 1
a933 1
  return (lp->stopped == 0);
d1186 4
a1189 1
	  resume_callback (lp, NULL);
@


1.51.4.1
log
@* lin-lwp.c (lin_lwp_thread_alive): Use PTRACE_PEEKDATA instead of
PTRACE_PEEKUSER.  Return zero if the call failed with ESRCH.
@
text
@d1716 1
a1716 1
  ptrace (PTRACE_PEEKDATA, GET_LWP (ptid), 0, 0);
d1719 1
a1719 1
			"LLTA: PTRACE_PEEKDATA %s, 0, 0 (%s)\n",
d1722 1
a1722 1
  if (errno == ESRCH)
@


1.50
log
@	* lin-lwp.c (wait_lwp): New function, copied from
	stop_wait_callback.  Clean up.
	(stop_wait_callback): Use wait_lwp.
@
text
@d420 6
a425 1
      stop_wait_callback (lp, NULL);
d704 1
a704 1
  if (!lp->stopped && lp->signalled)
d715 6
d836 82
d1561 1
@


1.49
log
@	* lin-lwp.c (child_wait): Call linux_record_stopped_pid.
@
text
@d588 71
a700 1
      pid_t pid;
d703 3
a705 77
      gdb_assert (lp->status == 0);

      pid = waitpid (GET_LWP (lp->ptid), &status, 0);
      if (pid == -1 && errno == ECHILD)
	{
	  pid = waitpid (GET_LWP (lp->ptid), &status, __WCLONE);
	  if (pid == -1 && errno == ECHILD)
	    {
	      /* The thread has previously exited.  We need to delete it now
	         because in the case of nptl threads, there won't be an
	         exit event unless it is the main thread.  */
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "SWC: %s exited.\n",
				    target_pid_to_str (lp->ptid));
	      delete_lwp (lp->ptid);
	      return 0;
	    }
	}

      gdb_assert (pid == GET_LWP (lp->ptid));

      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "SWC: waitpid %s received %s\n",
			      target_pid_to_str (lp->ptid),
			      status_to_str (status));
	}

      /* Check if the thread has exited.  */
      if (WIFEXITED (status) || WIFSIGNALED (status))
	{
	  gdb_assert (num_lwps > 1);

	  if (in_thread_list (lp->ptid))
	    {
	      /* Core GDB cannot deal with us deleting the current
	         thread.  */
	      if (!ptid_equal (lp->ptid, inferior_ptid))
		delete_thread (lp->ptid);
	      printf_unfiltered ("[%s exited]\n",
				 target_pid_to_str (lp->ptid));
	    }
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog,
				"SWC: %s exited.\n",
				target_pid_to_str (lp->ptid));

	  delete_lwp (lp->ptid);
	  return 0;
	}

      /* Check if the current LWP has previously exited.  For nptl threads,
         there is no exit signal issued for LWPs that are not the
         main thread so we should check whenever the thread is stopped.  */
      if (!lin_lwp_thread_alive (lp->ptid))
	{
	  if (in_thread_list (lp->ptid))
	    {
	      /* Core GDB cannot deal with us deleting the current
	         thread.  */
	      if (!ptid_equal (lp->ptid, inferior_ptid))
		delete_thread (lp->ptid);
	      printf_unfiltered ("[%s exited]\n",
				 target_pid_to_str (lp->ptid));
	    }
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog,
				"SWC: %s already exited.\n",
				target_pid_to_str (lp->ptid));

	  delete_lwp (lp->ptid);
	  return 0;
	}

      gdb_assert (WIFSTOPPED (status));
@


1.48
log
@	* Makefile.in (i386-linux-nat.o): Update dependencies.
	* config/i386/nm-linux.h (LINUX_CHILD_POST_STARTUP_INFERIOR): Define.
	* config/nm-linux.h (CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH)
	(CHILD_FOLLOW_FORK, KILL_INFERIOR): Define.
	* i386-linux-nat.c: Include "linux-nat.h".
	(child_post_startup_inferior): New function.
	* i386-nat.c (child_post_startup_inferior): Wrap in #ifdef.
	* infptrace.c (kill_inferior): Wrap in #ifdef.
	* lin-lwp.c (lin_lwp_attach_lwp): Call child_post_attach after
	attaching to each LWP.
	(child_wait, lin_lwp_wait): Call linux_handle_extended_wait.
	(init_lin_lwp_ops): Fill in some more operations.
	* linux-nat.h (linux_enable_event_reporting)
	(linux_handle_extended_wait, linux_child_post_startup_inferior): New
	prototypes.
	* linux-nat.c (linux_enable_event_reporting): New function.
	(child_post_attach, linux_child_post_startup_inferior)
	(child_post_startup_inferior, child_follow_fork)
	(linux_handle_extended_wait, kill_inferior): New functions.
@
text
@d1052 1
@


1.47
log
@2003-06-19  Michael Snyder  <msnyder@@redhat.com>

	* linux-nat.h: New file.
	* linux-nat.c: Include linux-nat.h.
	* lin-lwp.c: Include linux-nat.h.
	Move struct lwp_info def to linux-nat.h.
	* linux-proc.c: Include linux-nat.h.
	(linux_make_note_section): Iterate over lwps instead of threads.
	(linux_do_thread_registers): Use lwp instead of merged pid.
	* config/nm-linux.h: Move miscelaneous def'ns to linux-nat.h.
	* Makefile.in (lin-lwp.o, linux-proc.o, linux-nat.o):
	Add dependency on linux_nat_h.
@
text
@d327 2
d1072 4
d1497 8
d1674 6
@


1.47.2.1
log
@	* Makefile.in (i386-linux-nat.o): Update dependencies.
	* config/i386/nm-linux.h (LINUX_CHILD_POST_STARTUP_INFERIOR): Define.
	* config/nm-linux.h (CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH)
	(CHILD_FOLLOW_FORK, KILL_INFERIOR): Define.
	* i386-linux-nat.c: Include "linux-nat.h".
	(child_post_startup_inferior): New function.
	* i386-nat.c (child_post_startup_inferior): Wrap in #ifdef.
	* infptrace.c (kill_inferior): Wrap in #ifdef.
	* lin-lwp.c (lin_lwp_attach_lwp): Call child_post_attach after
	attaching to each LWP.
	(child_wait, lin_lwp_wait): Call linux_handle_extended_wait.
	(init_lin_lwp_ops): Fill in some more operations.
	* linux-nat.h (linux_enable_event_reporting)
	(linux_handle_extended_wait, linux_child_post_startup_inferior): New
	prototypes.
	* linux-nat.c (linux_enable_event_reporting): New function.
	(child_post_attach, linux_child_post_startup_inferior)
	(child_post_startup_inferior, child_follow_fork)
	(linux_handle_extended_wait, kill_inferior): New functions.
@
text
@a326 2
      child_post_attach (pid);

a1069 4
  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
    return linux_handle_extended_wait (pid, status, ourstatus);

a1490 8
  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
    {
      linux_handle_extended_wait (ptid_get_pid (trap_ptid),
				  status, ourstatus);
      return trap_ptid;
    }

a1659 6
  lin_lwp_ops.to_post_startup_inferior = child_post_startup_inferior;
  lin_lwp_ops.to_post_attach = child_post_attach;
  lin_lwp_ops.to_insert_fork_catchpoint = child_insert_fork_catchpoint;
  lin_lwp_ops.to_insert_vfork_catchpoint = child_insert_vfork_catchpoint;
  lin_lwp_ops.to_insert_exec_catchpoint = child_insert_exec_catchpoint;

@


1.47.2.2
log
@	* lin-lwp.c (child_wait): Call linux_record_stopped_pid.
@
text
@a1051 1
	  linux_record_stopped_pid (pid);
@


1.46
log
@	* arch-utils.c (default_prepare_to_proceed): Remove.
	(generic_prepare_to_proceed): Remove.
	* arch-utils.h (default_prepare_to_proceed): Remove prototype.
	(generic_prepare_to_proceed): Remove prototype.
	* gdbarch.sh (PREPARE_TO_PROCEED): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-tdep.c (hppa_prepare_to_proceed): Remove dangling prototype.
	* hppah-nat.c (hppa_switched_threads): Remove.
	* infrun.c (prepare_to_proceed): New static function, copied from
	generic_prepare_to_proceed.  Remove select_it argument.
	(proceed): Call prepare_to_proceed.
	* infttrace.c (old_gdb_pid, reported_pid, reported_bpt): Remove
	variables.
	(ptrace_wait): Don't set the removed variables.
	(hppa_switched_threads): Remove.
	* lin-lwp.c (lin_lwp_prepare_to_proceed): Remove.
	* config/nm-linux.h (PREPARE_TO_PROCEED): Don't define.
	(lin_lwp_prepare_to_proceed): Remove prototype.
	* config/i386/nm-x86-64linux.h (PREPARE_TO_PROCEED): Don't undefine.
	* config/pa/nm-hppah.h (PREPARE_TO_PROCEED): Don't define.
@
text
@d43 2
a76 37

/* Structure describing a LWP.  */
struct lwp_info
{
  /* The process id of the LWP.  This is a combination of the LWP id
     and overall process id.  */
  ptid_t ptid;

  /* Non-zero if this LWP is cloned.  In this context "cloned" means
     that the LWP is reporting to its parent using a signal other than
     SIGCHLD.  */
  int cloned;

  /* Non-zero if we sent this LWP a SIGSTOP (but the LWP didn't report
     it back yet).  */
  int signalled;

  /* Non-zero if this LWP is stopped.  */
  int stopped;

  /* Non-zero if this LWP will be/has been resumed.  Note that an LWP
     can be marked both as stopped and resumed at the same time.  This
     happens if we try to resume an LWP that has a wait status
     pending.  We shouldn't let the LWP run until that wait status has
     been processed, but we should not report that wait status if GDB
     didn't try to let the LWP run.  */
  int resumed;

  /* If non-zero, a pending wait status.  */
  int status;

  /* Non-zero if we were stepping this LWP.  */
  int step;

  /* Next LWP in list.  */
  struct lwp_info *next;
};
@


1.45
log
@	* config/nm-linux.h (linux_record_stopped_pid): New prototype.
	* lin-lwp.c (child_wait): Call linux_record_stopped_pid.
	(lin_lwp_wait): Likewise.  Update comments.
	* linux-nat.c (struct simple_pid_list, add_to_pid_list)
	(pull_pid_from_list, linux_record_stopped_pid): New.
@
text
@a300 40
/* Implementation of the PREPARE_TO_PROCEED hook for the GNU/Linux LWP
   layer.

   Note that this implementation is potentially redundant now that
   default_prepare_to_proceed() has been added.

   FIXME This may not support switching threads after Ctrl-C
   correctly. The default implementation does support this. */

int
lin_lwp_prepare_to_proceed (void)
{
  if (!ptid_equal (trap_ptid, null_ptid)
      && !ptid_equal (inferior_ptid, trap_ptid))
    {
      /* Switched over from TRAP_PID.  */
      CORE_ADDR stop_pc = read_pc ();
      CORE_ADDR trap_pc;

      /* Avoid switching where it wouldn't do any good, i.e. if both
         threads are at the same breakpoint.  */
      trap_pc = read_pc_pid (trap_ptid);
      if (trap_pc != stop_pc && breakpoint_here_p (trap_pc))
	{
	  /* User hasn't deleted the breakpoint.  Return non-zero, and
	     switch back to TRAP_PID.  */
	  inferior_ptid = trap_ptid;

	  /* FIXME: Is this stuff really necessary?  */
	  flush_cached_frames ();
	  registers_changed ();

	  return 1;
	}
    }

  return 0;
}


@


1.44
log
@
2003-06-04  Jeff Johnston  <jjohnstn@@redhat.com>

        * acconfig.h: Add HAVE_TKILL_SYSCALL definition check.
        * config.in: Regenerated.
        * configure.in: Add test for syscall function and check for
        __NR_tkill macro in <syscall.h> to set HAVE_TKILL_SYSCALL.
        * configure: Regenerated.
        * lin-lwp.c [HAVE_TKILL_SYSCALL]: Include <unistd.h> and
        <sys/syscall.h>.
        (kill_lwp): New function that uses tkill syscall or
        uses kill, depending on whether threading model is nptl or not.
        All callers of kill() changed to use kill_lwp().
        (lin_lwp_wait): Make special check when WIFEXITED occurs to
        see if all threads have already exited in the nptl model.
        (stop_and_resume_callback): New callback function used by the
        lin_lwp_wait thread exit handling code.
        (stop_wait_callback): Check for threads already having exited and
        delete such threads fromt the lwp list when discovered.
        (stop_callback): Don't assert retcode of kill call.

        Roland McGrath  <roland@@redhat.com>
        * i386-linux-nat.c (ps_get_thread_area): New function needed by
        nptl libthread_db.
@
text
@d1112 17
d1292 16
d1318 7
@


1.43
log
@
2003-03-28  Jeff Johnston  <jjohnstn@@redhat.com>

        * thread.c: Reindented.
        * lin-lwp.c: Ditto.
        * linux-proc.c: Ditto.
@
text
@d27 4
d163 1
d635 26
d676 9
a684 2
      ret = kill (GET_LWP (lp->ptid), SIGSTOP);
      gdb_assert (ret == 0);
d708 1
a708 1
      pid = waitpid (GET_LWP (lp->ptid), &status, lp->cloned ? __WCLONE : 0);
d710 15
a724 3
	/* OK, the proccess has disappeared.  We'll catch the actual
	   exit event in lin_lwp_wait.  */
	return 0;
d736 1
d751 25
a775 1
	    fprintf_unfiltered (gdb_stdlog, "SWC: %s exited.\n",
d834 8
a841 1
		  kill (GET_LWP (lp->ptid), WSTOPSIG (lp->status));
d885 1
a885 1
		  kill (GET_LWP (lp->ptid), WSTOPSIG (status));
d1134 19
d1310 1
a1310 3
	  /* Make sure we don't report a TARGET_WAITKIND_EXITED or
	     TARGET_WAITKIND_SIGNALLED event if there are still LWP's
	     left in the process.  */
d1312 53
@


1.42
log
@	* lin-lwp.c (struct private_thread_info, find_lwp_callback): Remove.
	(resume_callback): Remove dead code.
@
text
@d175 1
a175 2
    snprintf (buf, sizeof (buf), "%d (exited)",
	      WEXITSTATUS (status));
d308 2
a309 2
  if (! ptid_equal (trap_ptid, null_ptid)
      && ! ptid_equal (inferior_ptid, trap_ptid))
d321 1
a321 1
             switch back to TRAP_PID.  */
d357 1
a357 1
  if (! sigismember (&blocked_mask, SIGCHLD))
d382 2
a383 2
	fprintf_unfiltered (gdb_stdlog, 
			    "LLAL: PTRACE_ATTACH %s, 0, 0 (OK)\n", 
d403 1
a403 1
			      target_pid_to_str (ptid), 
d410 5
a414 5
	 is already stopped.  Mark it as stopped in the data structure
	 that the lin-lwp layer uses to keep track of threads.  Note
	 that this won't have already been done since the main thread
	 will have, we assume, been stopped by an attach from a
	 different layer.  */
d457 1
a457 2
			  "LLA: waitpid %ld, faking SIGSTOP\n", 
			  (long) pid);
d468 1
a468 1
			strsignal (WSTOPSIG (lp->status)), 
d480 1
a480 1
	fprintf_unfiltered (gdb_stdlog, 
d483 1
a483 1
			    status_to_str (lp->status)); 
d506 1
a506 1
			    target_pid_to_str (lp->ptid), 
d548 1
a548 1
	fprintf_unfiltered (gdb_stdlog, 
d607 1
a607 1
             this thread with a signal?  */
d613 1
a613 1
	 resume_callback.  */
d635 1
a635 1
  if (! lp->stopped && ! lp->signalled)
d663 1
a663 1
  if (! lp->stopped && lp->signalled)
d682 1
a682 1
			      target_pid_to_str (lp->ptid), 
d693 1
a693 1
		 thread.  */
d700 1
a700 1
	    fprintf_unfiltered (gdb_stdlog, "SWC: %s exited.\n", 
d728 11
a738 11
                 event for has hit a GDB breakpoint (as opposed to
                 some random trap signal), then just arrange for it to
                 hit it again later.  We don't keep the SIGTRAP status
                 and don't forward the SIGTRAP signal to the LWP.  We
                 will handle the current event, eventually we will
                 resume all LWPs, and this one will get its breakpoint
                 trap again.

		 If we do not do this, then we run the risk that the
		 user will delete or disable the breakpoint, but the
		 thread will have already tripped on it.  */
d745 1
a745 1
		  fprintf_unfiltered (gdb_stdlog, 
d750 1
a750 1
		  fprintf_unfiltered (gdb_stdlog, 
d768 1
a768 1
		 SIGSTOP, and didn't accidentally trip a breakpoint. */
d772 1
a772 1
		  fprintf_unfiltered (gdb_stdlog, 
d774 1
a774 1
				      status_to_str ((int) status), 
d781 1
a781 1
		fprintf_unfiltered (gdb_stdlog, 
d787 1
a787 1
		 there are any more (we still want to get that SIGSTOP). */
d790 2
a791 2
		 this event.  If not, then this event must be returned
		 to the event queue of the LWP.  */
d798 1
a798 1
		      fprintf_unfiltered (gdb_stdlog, 
d800 1
a800 1
					  target_pid_to_str (lp->ptid), 
d811 1
a811 1
             there's no SIGSTOP pending.  */
d905 2
a906 2
      && WIFSTOPPED (lp->status) &&  WSTOPSIG (lp->status) == SIGTRAP
      && breakpoint_inserted_here_p (read_pc_pid (lp->ptid) - 
d949 1
a949 1
	 which have had SIGTRAP events.  */
d959 2
a960 2
	fprintf_unfiltered (gdb_stdlog, 
			    "SEL: Found %d SIGTRAP events, selecting #%d\n", 
d971 1
a971 1
      *status  = event_lp->status;
d1015 1
a1015 1
	  fprintf_unfiltered (gdb_stdlog, 
d1017 1
a1017 2
			      (long) pid, 
			      status_to_str (status));
d1023 2
a1024 2
	 original program, if we've detached from it.  */
      if (pid != -1 && ! WIFSTOPPED (status) && pid != GET_PID (inferior_ptid))
d1037 1
a1037 1
      warning ("Child process unexpectedly missing: %s", 
d1064 1
a1064 1
  if (! sigismember (&blocked_mask, SIGCHLD))
d1070 1
a1070 1
 retry:
d1089 1
a1089 1
				status_to_str (status), 
d1101 1
a1101 1
	fprintf_unfiltered (gdb_stdlog, 
d1114 1
a1114 1
			    status_to_str (status), 
d1127 7
a1133 7
	 events.  In a typical case where interference is a problem,
	 we have a SIGSTOP signal pending for LWP A while
	 single-stepping it, encounter an event in LWP B, and take the
	 pending SIGSTOP while trying to stop LWP A.  After processing
	 the event in LWP B, LWP A is continued, and we'll never see
	 the SIGTRAP associated with the last time we were
	 single-stepping LWP A.  */
d1136 1
a1136 1
	 pending SIGSTOP.  */
d1139 1
a1139 1
                    TARGET_SIGNAL_0);
d1152 2
a1153 2
  set_sigint_trap ();	/* Causes SIGINT to be passed on to the
			   attached process. */
d1169 1
a1169 2
				  (long) lwpid, 
				  status_to_str (status));
d1178 1
a1178 1
	  if (! WIFSTOPPED (status) && ! lp)
d1184 1
a1184 1
	  if (! lp)
d1196 1
a1196 1
		  if (! in_thread_list (inferior_ptid))
d1199 1
a1199 1
		                                 GET_PID (inferior_ptid));
d1210 2
a1211 2
             TARGET_WAITKIND_SIGNALLED event if there are still LWP's
             left in the process.  */
d1217 2
a1218 2
                     thread.  */
		  if (! ptid_equal (lp->ptid, inferior_ptid))
d1224 2
a1225 2
		fprintf_unfiltered (gdb_stdlog, 
				    "LLW: %s exited.\n", 
d1239 1
a1239 1
             ourselves in an attempt to stop an LWP.  */
d1241 1
a1241 2
              && WIFSTOPPED (status)
	      && WSTOPSIG (status) == SIGSTOP)
d1244 1
a1244 1
		fprintf_unfiltered (gdb_stdlog, 
d1253 1
a1253 1
	                    TARGET_SIGNAL_0);
d1257 1
a1257 1
				    lp->step ? 
d1307 4
a1310 4
             here?  It is not clear we should.  GDB may not expect
             other threads to run.  On the other hand, not resuming
             newly attached threads may cause an unwanted delay in
             getting them running.  */
d1316 2
a1317 1
				lp->step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
d1325 1
a1325 2
      if (signo == TARGET_SIGNAL_INT
	  && signal_pass_state (signo) == 0)
d1328 3
a1330 3
             forwarded to the entire process group, that is, all LWP's
             will receive it.  Since we only want to report it once,
             we try to flush it from all LWPs except this one.  */
d1340 1
a1340 2
			status_to_str (status), 
			target_pid_to_str (lp->ptid));
d1367 1
a1367 1
	fprintf_unfiltered (gdb_stdlog, 
d1384 1
a1384 1
    fprintf_unfiltered (gdb_stdlog, 
d1427 1
a1427 1
			      "KWC: wait %s received unk.\n", 
d1455 1
a1455 1
static void  
d1472 1
a1472 2
		     struct mem_attrib *attrib,
		     struct target_ops *target)
d1498 1
a1498 1
			target_pid_to_str (ptid), 
d1582 1
a1582 1
				  (char *) &debug_lin_lwp, 
d1584 1
a1584 3
Enables printf debugging output.\n",
				      &setdebuglist),
		     &showdebuglist);
@


1.42.12.1
log
@Merge with mainline.
@
text
@d175 2
a176 1
    snprintf (buf, sizeof (buf), "%d (exited)", WEXITSTATUS (status));
d309 2
a310 2
  if (!ptid_equal (trap_ptid, null_ptid)
      && !ptid_equal (inferior_ptid, trap_ptid))
d322 1
a322 1
	     switch back to TRAP_PID.  */
d358 1
a358 1
  if (!sigismember (&blocked_mask, SIGCHLD))
d383 2
a384 2
	fprintf_unfiltered (gdb_stdlog,
			    "LLAL: PTRACE_ATTACH %s, 0, 0 (OK)\n",
d404 1
a404 1
			      target_pid_to_str (ptid),
d411 5
a415 5
         is already stopped.  Mark it as stopped in the data structure
         that the lin-lwp layer uses to keep track of threads.  Note
         that this won't have already been done since the main thread
         will have, we assume, been stopped by an attach from a
         different layer.  */
d458 2
a459 1
			  "LLA: waitpid %ld, faking SIGSTOP\n", (long) pid);
d470 1
a470 1
			strsignal (WSTOPSIG (lp->status)),
d482 1
a482 1
	fprintf_unfiltered (gdb_stdlog,
d485 1
a485 1
			    status_to_str (lp->status));
d508 1
a508 1
			    target_pid_to_str (lp->ptid),
d550 1
a550 1
	fprintf_unfiltered (gdb_stdlog,
d609 1
a609 1
	     this thread with a signal?  */
d615 1
a615 1
         resume_callback.  */
d637 1
a637 1
  if (!lp->stopped && !lp->signalled)
d665 1
a665 1
  if (!lp->stopped && lp->signalled)
d684 1
a684 1
			      target_pid_to_str (lp->ptid),
d695 1
a695 1
	         thread.  */
d702 1
a702 1
	    fprintf_unfiltered (gdb_stdlog, "SWC: %s exited.\n",
d730 11
a740 11
	         event for has hit a GDB breakpoint (as opposed to
	         some random trap signal), then just arrange for it to
	         hit it again later.  We don't keep the SIGTRAP status
	         and don't forward the SIGTRAP signal to the LWP.  We
	         will handle the current event, eventually we will
	         resume all LWPs, and this one will get its breakpoint
	         trap again.

	         If we do not do this, then we run the risk that the
	         user will delete or disable the breakpoint, but the
	         thread will have already tripped on it.  */
d747 1
a747 1
		  fprintf_unfiltered (gdb_stdlog,
d752 1
a752 1
		  fprintf_unfiltered (gdb_stdlog,
d770 1
a770 1
	         SIGSTOP, and didn't accidentally trip a breakpoint. */
d774 1
a774 1
		  fprintf_unfiltered (gdb_stdlog,
d776 1
a776 1
				      status_to_str ((int) status),
d783 1
a783 1
		fprintf_unfiltered (gdb_stdlog,
d789 1
a789 1
	         there are any more (we still want to get that SIGSTOP). */
d792 2
a793 2
	         this event.  If not, then this event must be returned
	         to the event queue of the LWP.  */
d800 1
a800 1
		      fprintf_unfiltered (gdb_stdlog,
d802 1
a802 1
					  target_pid_to_str (lp->ptid),
d813 1
a813 1
	     there's no SIGSTOP pending.  */
d907 2
a908 2
      && WIFSTOPPED (lp->status) && WSTOPSIG (lp->status) == SIGTRAP
      && breakpoint_inserted_here_p (read_pc_pid (lp->ptid) -
d951 1
a951 1
         which have had SIGTRAP events.  */
d961 2
a962 2
	fprintf_unfiltered (gdb_stdlog,
			    "SEL: Found %d SIGTRAP events, selecting #%d\n",
d973 1
a973 1
      *status = event_lp->status;
d1017 1
a1017 1
	  fprintf_unfiltered (gdb_stdlog,
d1019 2
a1020 1
			      (long) pid, status_to_str (status));
d1026 2
a1027 2
         original program, if we've detached from it.  */
      if (pid != -1 && !WIFSTOPPED (status) && pid != GET_PID (inferior_ptid))
d1040 1
a1040 1
      warning ("Child process unexpectedly missing: %s",
d1067 1
a1067 1
  if (!sigismember (&blocked_mask, SIGCHLD))
d1073 1
a1073 1
retry:
d1092 1
a1092 1
				status_to_str (status),
d1104 1
a1104 1
	fprintf_unfiltered (gdb_stdlog,
d1117 1
a1117 1
			    status_to_str (status),
d1130 7
a1136 7
         events.  In a typical case where interference is a problem,
         we have a SIGSTOP signal pending for LWP A while
         single-stepping it, encounter an event in LWP B, and take the
         pending SIGSTOP while trying to stop LWP A.  After processing
         the event in LWP B, LWP A is continued, and we'll never see
         the SIGTRAP associated with the last time we were
         single-stepping LWP A.  */
d1139 1
a1139 1
         pending SIGSTOP.  */
d1142 1
a1142 1
		    TARGET_SIGNAL_0);
d1155 2
a1156 2
  set_sigint_trap ();		/* Causes SIGINT to be passed on to the
				   attached process. */
d1172 2
a1173 1
				  (long) lwpid, status_to_str (status));
d1182 1
a1182 1
	  if (!WIFSTOPPED (status) && !lp)
d1188 1
a1188 1
	  if (!lp)
d1200 1
a1200 1
		  if (!in_thread_list (inferior_ptid))
d1203 1
a1203 1
						 GET_PID (inferior_ptid));
d1214 2
a1215 2
	     TARGET_WAITKIND_SIGNALLED event if there are still LWP's
	     left in the process.  */
d1221 2
a1222 2
		     thread.  */
		  if (!ptid_equal (lp->ptid, inferior_ptid))
d1228 2
a1229 2
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s exited.\n",
d1243 1
a1243 1
	     ourselves in an attempt to stop an LWP.  */
d1245 2
a1246 1
	      && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP)
d1249 1
a1249 1
		fprintf_unfiltered (gdb_stdlog,
d1258 1
a1258 1
			    TARGET_SIGNAL_0);
d1262 1
a1262 1
				    lp->step ?
d1312 4
a1315 4
	     here?  It is not clear we should.  GDB may not expect
	     other threads to run.  On the other hand, not resuming
	     newly attached threads may cause an unwanted delay in
	     getting them running.  */
d1321 1
a1321 2
				lp->step ?
				"PTRACE_SINGLESTEP" : "PTRACE_CONT",
d1329 2
a1330 1
      if (signo == TARGET_SIGNAL_INT && signal_pass_state (signo) == 0)
d1333 3
a1335 3
	     forwarded to the entire process group, that is, all LWP's
	     will receive it.  Since we only want to report it once,
	     we try to flush it from all LWPs except this one.  */
d1345 2
a1346 1
			status_to_str (status), target_pid_to_str (lp->ptid));
d1373 1
a1373 1
	fprintf_unfiltered (gdb_stdlog,
d1390 1
a1390 1
    fprintf_unfiltered (gdb_stdlog,
d1433 1
a1433 1
			      "KWC: wait %s received unk.\n",
d1461 1
a1461 1
static void
d1478 2
a1479 1
		     struct mem_attrib *attrib, struct target_ops *target)
d1505 1
a1505 1
			target_pid_to_str (ptid),
d1589 1
a1589 1
				  (char *) &debug_lin_lwp,
d1591 3
a1593 1
Enables printf debugging output.\n", &setdebuglist), &showdebuglist);
@


1.41
log
@	* lin-lwp.c (child_wait): Ignore exit statuses for processes other
	than inferior_ptid.
	(lin_lwp_wait): Ignore exit statuses for unknown LWPs.
@
text
@a538 19
struct private_thread_info
{
  int lwpid;
};

/* Return non-zero if TP corresponds to the LWP specified by DATA
   (which is assumed to be a pointer to a `struct lwp_info'.  */

static int
find_lwp_callback (struct thread_info *tp, void *data)
{
  struct lwp_info *lp = data;

  if (tp->private->lwpid == GET_LWP (lp->ptid))
    return 1;

  return 0;
}

a546 21

#if 0
      /* FIXME: kettenis/2000-08-26: This should really be handled
         properly by core GDB.  */

      tp = find_thread_pid (lp->ptid);
      if (tp == NULL)
	tp = iterate_over_threads (find_lwp_callback, lp);
      gdb_assert (tp);

      /* If we were previously stepping the thread, and now continue
         the thread we must invalidate the stepping range.  However,
         if there is a step_resume breakpoint for this thread, we must
         preserve the stepping range to make it possible to continue
         stepping once we hit it.  */
      if (tp->step_range_end && tp->step_resume_breakpoint == NULL)
	{
	  gdb_assert (lp->step);
	  tp->step_range_start = tp->step_range_end = 0;
	}
#endif
@


1.40
log
@
chael Snyder  <msnyder@@redhat.com>

	* lin-lwp.c: Added or elaborated on "debug lin-lwp" info.
qCVS: Committing in .
@
text
@d2 1
a2 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d1065 8
d1217 11
@


1.39
log
@	* lin-lwp.c (strsignal): Make extern declaration match that of glibc.
@
text
@d382 5
d399 8
d455 6
d469 3
a471 2
    fprintf_unfiltered (gdb_stdlog, "Pending %s for LWP %ld on detach.\n",
			strsignal (WSTOPSIG (lp->status)), GET_LWP (lp->ptid));
d475 1
d481 6
d499 1
d505 6
d589 4
d663 6
d681 6
d720 8
d742 2
a743 2
	    fprintf_unfiltered (gdb_stdlog, 
				"%s exited.\n", target_pid_to_str (lp->ptid));
d754 1
d756 6
d783 1
d787 8
a794 3
		  fprintf_unfiltered (gdb_stderr, 
				      "SWC: Candidate SIGTRAP event in %ld\n",
				      GET_LWP (lp->ptid));
d800 3
a802 1
		kill (GET_LWP (lp->ptid), WSTOPSIG (lp->status));
d814 4
a817 3
		  fprintf_unfiltered (gdb_stderr, 
				      "SWC: Pending event %d in %ld\n",
				      WSTOPSIG (status), GET_LWP (lp->ptid));
d820 1
d822 5
d837 10
a846 1
		kill (GET_LWP (lp->ptid), WSTOPSIG (status));
d953 2
a954 2
			    "Push back breakpoint for LWP %ld\n",
			    GET_LWP (lp->ptid));
d985 2
a986 2
			    "Select single-step LWP %ld\n",
			    GET_LWP (event_lp->ptid));
d1002 1
a1002 1
			    "Found %d SIGTRAP events, selecting #%d\n", 
d1054 9
d1072 2
a1073 1
      warning ("Child process unexpectedly missing: %s", safe_strerror (errno));
d1123 3
a1125 2
				"Using pending wait status %s for LWP %ld.\n",
				status_to_str (status), GET_LWP (lp->ptid));
d1137 2
a1138 2
			    "Waiting for specific LWP %ld.\n",
			    GET_LWP (ptid));
d1148 3
a1150 2
			    "Using pending wait status %s for LWP %ld.\n",
			    status_to_str (status), GET_LWP (lp->ptid));
d1172 1
d1175 5
d1200 8
d1250 1
a1250 1
				    "%s exited.\n", 
d1265 2
a1266 1
	  if (lp->signalled && WIFSTOPPED (status)
d1271 1
a1271 1
				    "Delayed SIGSTOP caught for %s.\n",
d1277 1
d1280 7
d1337 1
d1339 6
d1365 3
a1367 2
    fprintf_unfiltered (gdb_stdlog, "Candidate event %s in LWP %ld.\n",
			status_to_str (status), GET_LWP (lp->ptid));
d1395 2
a1396 2
			    "LLW: trap_ptid is %ld\n",
			    GET_LWP (trap_ptid));
d1408 1
d1410 6
d1436 6
d1451 6
d1523 5
@


1.38
log
@2002-12-03  Andrew Cagney  <ac131313@@redhat.com>

	* sparc-nat.c (fetch_inferior_registers)
	(store_inferior_registers): Add comment on problem of LWP vs
	threads.

	From 2002-11-21 Daniel Jacobowitz <drow@@mvista.com>
	* lin-lwp.c (lin_lwp_fetch_registers): Remove.
	(lin_lwp_store_registers): Remove.
	(init_lin_lwp_ops): Use fetch_inferior_registers
	and store_inferior_registers directly.
	* sparc-nat.c (fetch_inferior_registers): Honor LWP ID.
	(store_inferior_registers): Likewise.
	Fix PR gdb/725.
@
text
@d37 1
a37 1
extern const char *strsignal (int sig);
@


1.37
log
@	* acconfig.h (HAVE_PREAD64): Add.
	* configure.in: Check for pread64.
	* config.in: Regenerated.
	* configure: Regenerated.
	* lin-lwp.c (lin_lwp_xfer_memory): Call linux_proc_xfer_memory.
	* linux-proc.c (linux_proc_xfer_memory): New function.
	* config/nm-linux.h (linux_proc_xfer_memory): Add prototype.
@
text
@a1345 26
static void
lin_lwp_fetch_registers (int regno)
{
  struct cleanup *old_chain = save_inferior_ptid ();

  if (is_lwp (inferior_ptid))
    inferior_ptid = pid_to_ptid (GET_LWP (inferior_ptid));

  fetch_inferior_registers (regno);

  do_cleanups (old_chain);
}

static void
lin_lwp_store_registers (int regno)
{
  struct cleanup *old_chain = save_inferior_ptid ();

  if (is_lwp (inferior_ptid))
    inferior_ptid = pid_to_ptid (GET_LWP (inferior_ptid));

  store_inferior_registers (regno);

  do_cleanups (old_chain);
}

d1405 4
a1408 2
  lin_lwp_ops.to_fetch_registers = lin_lwp_fetch_registers;
  lin_lwp_ops.to_store_registers = lin_lwp_store_registers;
@


1.36
log
@	* lin-lwp.c (lin_lwp_resume): Remove resume_all test for !step.
@
text
@d1383 3
a1385 1
  xfer = child_xfer_memory (memaddr, myaddr, len, write, attrib, target);
@


1.35
log
@	* Makefile.in (osabi.o, i387-tdep.o, i386-linux-nat.o, lin-lwp.o,
	ax-gdb.o, signals.o, jv-valprint.o, c-valprint.o, cp-abi.o):
	Update dependencies.
	* i387-tdep.c: Include gdb_string.h.
	* osabi.c: Likewise.
	* i386-linux-nat.c: Likewise.
	* lin-lwp.c: Likewise.
	* ax-gdb.c: Likewise.
	* signals/signals.c: Likewise.
	* jv-valprint.c: Likewise.
	* p-lang.c: Likewise.
	* c-valprint.c: Likewise.
	* cp-abi.c: Likewise.
@
text
@d582 2
a583 5
  /* Apparently the interpretation of PID is dependent on STEP: If
     STEP is non-zero, a specific PID means `step only this process
     id'.  But if STEP is zero, then PID means `continue *all*
     processes, but give the signal only to this one'.  */
  resume_all = (PIDGET (ptid) == -1) || !step;
@


1.35.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a26 4
#ifdef HAVE_TKILL_SYSCALL
#include <unistd.h>
#include <sys/syscall.h>
#endif
d37 1
a37 3
extern char *strsignal (int sig);

#include "linux-nat.h"
d72 37
a158 1
static int lin_lwp_thread_alive (ptid_t ptid);
d175 2
a176 1
    snprintf (buf, sizeof (buf), "%d (exited)", WEXITSTATUS (status));
d297 40
d358 1
a358 1
  if (!sigismember (&blocked_mask, SIGCHLD))
a381 5
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "LLAL: PTRACE_ATTACH %s, 0, 0 (OK)\n",
			    target_pid_to_str (ptid));

a392 2
      child_post_attach (pid);

a393 8

      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "LLAL: waitpid %s received %s\n",
			      target_pid_to_str (ptid),
			      status_to_str (status));
	}
d398 5
a402 5
         is already stopped.  Mark it as stopped in the data structure
         that the lin-lwp layer uses to keep track of threads.  Note
         that this won't have already been done since the main thread
         will have, we assume, been stopped by an attach from a
         different layer.  */
a441 5
  if (debug_lin_lwp)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "LLA: waitpid %ld, faking SIGSTOP\n", (long) pid);
    }
d450 2
a451 3
    fprintf_unfiltered (gdb_stdlog, "DC:  Pending %s for %s on detach.\n",
			strsignal (WSTOPSIG (lp->status)),
			target_pid_to_str (lp->ptid));
a454 1
      errno = 0;
a459 6
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "DC:  PTRACE_CONTINUE (%s, 0, %s) (OK)\n",
			    target_pid_to_str (lp->ptid),
			    status_to_str (lp->status));

d463 1
a463 6
      /* FIXME drow/2003-08-26: There was a call to stop_wait_callback
	 here.  But since lp->signalled was cleared above,
	 stop_wait_callback didn't do anything; the process was left
	 running.  Shouldn't we be waiting for it to stop?
	 I've removed the call, since stop_wait_callback now does do
	 something when called with lp->signalled == 0.  */
a471 1
      errno = 0;
a476 6
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "PTRACE_DETACH (%s, %s, 0) (OK)\n",
			    target_pid_to_str (lp->ptid),
			    strsignal (WSTOPSIG (lp->status)));

d505 19
d533 21
a554 4
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "RC:  PTRACE_CONT %s, 0, 0 (resume sibling)\n",
			    target_pid_to_str (lp->ptid));
d582 5
a586 2
  /* A specific PTID means `step only this process id'.  */
  resume_all = (PIDGET (ptid) == -1);
d614 1
a614 1
	     this thread with a signal?  */
d620 1
a620 1
         resume_callback.  */
a627 6
  if (debug_lin_lwp)
    fprintf_unfiltered (gdb_stdlog,
			"LLR: %s %s, %s (resume event thread)\n",
			step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
			target_pid_to_str (ptid),
			signo ? strsignal (signo) : "0");
a630 97
/* Issue kill to specified lwp.  */

static int tkill_failed;

static int
kill_lwp (int lwpid, int signo)
{
  errno = 0;

/* Use tkill, if possible, in case we are using nptl threads.  If tkill
   fails, then we are not using nptl threads and we should be using kill.  */

#ifdef HAVE_TKILL_SYSCALL
  if (!tkill_failed)
    {
      int ret = syscall (__NR_tkill, lwpid, signo);
      if (errno != ENOSYS)
	return ret;
      errno = 0;
      tkill_failed = 1;
    }
#endif

  return kill (lwpid, signo);
}

/* Wait for LP to stop.  Returns the wait status, or 0 if the LWP has
   exited.  */

static int
wait_lwp (struct lwp_info *lp)
{
  pid_t pid;
  int status;
  int thread_dead = 0;

  gdb_assert (!lp->stopped);
  gdb_assert (lp->status == 0);

  pid = waitpid (GET_LWP (lp->ptid), &status, 0);
  if (pid == -1 && errno == ECHILD)
    {
      pid = waitpid (GET_LWP (lp->ptid), &status, __WCLONE);
      if (pid == -1 && errno == ECHILD)
	{
	  /* The thread has previously exited.  We need to delete it now
	     because in the case of NPTL threads, there won't be an
	     exit event unless it is the main thread.  */
	  thread_dead = 1;
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog, "WL: %s vanished.\n",
				target_pid_to_str (lp->ptid));
	}
    }

  if (!thread_dead)
    {
      gdb_assert (pid == GET_LWP (lp->ptid));

      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "WL: waitpid %s received %s\n",
			      target_pid_to_str (lp->ptid),
			      status_to_str (status));
	}
    }

  /* Check if the thread has exited.  */
  if (WIFEXITED (status) || WIFSIGNALED (status))
    {
      thread_dead = 1;
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog, "WL: %s exited.\n",
			    target_pid_to_str (lp->ptid));
    }

  if (thread_dead)
    {
      if (in_thread_list (lp->ptid))
	{
	  /* Core GDB cannot deal with us deleting the current thread.  */
	  if (!ptid_equal (lp->ptid, inferior_ptid))
	    delete_thread (lp->ptid);
	  printf_unfiltered ("[%s exited]\n",
			     target_pid_to_str (lp->ptid));
	}

      delete_lwp (lp->ptid);
      return 0;
    }

  gdb_assert (WIFSTOPPED (status));

  return status;
}

d636 1
a636 1
  if (!lp->stopped && !lp->signalled)
d640 2
a641 15
      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "SC:  kill %s **<SIGSTOP>**\n",
			      target_pid_to_str (lp->ptid));
	}
      errno = 0;
      ret = kill_lwp (GET_LWP (lp->ptid), SIGSTOP);
      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "SC:  lwp kill %d %s\n",
			      ret,
			      errno ? safe_strerror (errno) : "ERRNO-OK");
	}
d658 1
a658 1
  if (!lp->stopped)
d660 1
d663 6
a668 2
      status = wait_lwp (lp);
      if (status == 0)
d671 3
a673 2
      /* Ignore any signals in FLUSH_MASK.  */
      if (flush_mask && sigismember (flush_mask, WSTOPSIG (status)))
d675 3
a677 1
	  if (!lp->signalled)
d679 6
a684 2
	      lp->stopped = 1;
	      return 0;
d686 7
d694 5
a698 1
	  errno = 0;
a699 6
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog,
				"PTRACE_CONT %s, 0, 0 (%s)\n",
				target_pid_to_str (lp->ptid),
				errno ? safe_strerror (errno) : "OK");

d708 11
a718 11
	         event for has hit a GDB breakpoint (as opposed to
	         some random trap signal), then just arrange for it to
	         hit it again later.  We don't keep the SIGTRAP status
	         and don't forward the SIGTRAP signal to the LWP.  We
	         will handle the current event, eventually we will
	         resume all LWPs, and this one will get its breakpoint
	         trap again.

	         If we do not do this, then we run the risk that the
	         user will delete or disable the breakpoint, but the
	         thread will have already tripped on it.  */
a720 1
	      errno = 0;
d724 3
a726 8
		  fprintf_unfiltered (gdb_stdlog,
				      "PTRACE_CONT %s, 0, 0 (%s)\n",
				      target_pid_to_str (lp->ptid),
				      errno ? safe_strerror (errno) : "OK");

		  fprintf_unfiltered (gdb_stdlog,
				      "SWC: Candidate SIGTRAP event in %s\n",
				      target_pid_to_str (lp->ptid));
d732 1
a732 10
		{
		  if (debug_lin_lwp)
		    {
		      fprintf_unfiltered (gdb_stdlog,
					  "SWC: kill %s, %s\n",
					  target_pid_to_str (lp->ptid),
					  status_to_str ((int) status));
		    }
		  kill_lwp (GET_LWP (lp->ptid), WSTOPSIG (lp->status));
		}
d740 1
a740 1
	         SIGSTOP, and didn't accidentally trip a breakpoint. */
d744 3
a746 4
		  fprintf_unfiltered (gdb_stdlog,
				      "SWC: Pending event %s in %s\n",
				      status_to_str ((int) status),
				      target_pid_to_str (lp->ptid));
a748 1
	      errno = 0;
a749 5
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "SWC: PTRACE_CONT %s, 0, 0 (%s)\n",
				    target_pid_to_str (lp->ptid),
				    errno ? safe_strerror (errno) : "OK");
d752 1
a752 1
	         there are any more (we still want to get that SIGSTOP). */
d755 2
a756 2
	         this event.  If not, then this event must be returned
	         to the event queue of the LWP.  */
d760 1
a760 10
		{
		  if (debug_lin_lwp)
		    {
		      fprintf_unfiltered (gdb_stdlog,
					  "SWC: kill %s, %s\n",
					  target_pid_to_str (lp->ptid),
					  status_to_str ((int) status));
		    }
		  kill_lwp (GET_LWP (lp->ptid), WSTOPSIG (status));
		}
d767 1
a767 1
	     there's no SIGSTOP pending.  */
a775 82
/* Check whether PID has any pending signals in FLUSH_MASK.  If so set
   the appropriate bits in PENDING, and return 1 - otherwise return 0.  */

static int
lin_lwp_has_pending (int pid, sigset_t *pending, sigset_t *flush_mask)
{
  sigset_t blocked, ignored;
  int i;

  linux_proc_pending_signals (pid, pending, &blocked, &ignored);

  if (!flush_mask)
    return 0;

  for (i = 1; i < NSIG; i++)
    if (sigismember (pending, i))
      if (!sigismember (flush_mask, i)
	  || sigismember (&blocked, i)
	  || sigismember (&ignored, i))
	sigdelset (pending, i);

  if (sigisemptyset (pending))
    return 0;

  return 1;
}

/* DATA is interpreted as a mask of signals to flush.  If LP has
   signals pending, and they are all in the flush mask, then arrange
   to flush them.  LP should be stopped, as should all other threads
   it might share a signal queue with.  */

static int
flush_callback (struct lwp_info *lp, void *data)
{
  sigset_t *flush_mask = data;
  sigset_t pending, intersection, blocked, ignored;
  int pid, status;

  /* Normally, when an LWP exits, it is removed from the LWP list.  The
     last LWP isn't removed till later, however.  So if there is only
     one LWP on the list, make sure it's alive.  */
  if (lwp_list == lp && lp->next == NULL)
    if (!lin_lwp_thread_alive (lp->ptid))
      return 0;

  /* Just because the LWP is stopped doesn't mean that new signals
     can't arrive from outside, so this function must be careful of
     race conditions.  However, because all threads are stopped, we
     can assume that the pending mask will not shrink unless we resume
     the LWP, and that it will then get another signal.  We can't
     control which one, however.  */

  if (lp->status)
    {
      if (debug_lin_lwp)
	printf_unfiltered ("FC: LP has pending status %06x\n", lp->status);
      if (WIFSTOPPED (lp->status) && sigismember (flush_mask, WSTOPSIG (lp->status)))
	lp->status = 0;
    }

  while (lin_lwp_has_pending (GET_LWP (lp->ptid), &pending, flush_mask))
    {
      int ret;
      
      errno = 0;
      ret = ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stderr,
			    "FC: Sent PTRACE_CONT, ret %d %d\n", ret, errno);

      lp->stopped = 0;
      stop_wait_callback (lp, flush_mask);
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stderr,
			    "FC: Wait finished; saved status is %d\n",
			    lp->status);
    }

  return 0;
}

d791 1
a791 1
  return (lp->stopped == 0 || (lp->status != 0 && lp->resumed));
d861 2
a862 2
      && WIFSTOPPED (lp->status) && WSTOPSIG (lp->status) == SIGTRAP
      && breakpoint_inserted_here_p (read_pc_pid (lp->ptid) -
d867 2
a868 2
			    "CBC: Push back breakpoint for %s\n",
			    target_pid_to_str (lp->ptid));
d899 2
a900 2
			    "SEL: Select single-step %s\n",
			    target_pid_to_str (event_lp->ptid));
d905 1
a905 1
         which have had SIGTRAP events.  */
d915 2
a916 2
	fprintf_unfiltered (gdb_stdlog,
			    "SEL: Found %d SIGTRAP events, selecting #%d\n",
d927 1
a927 1
      *status = event_lp->status;
a967 8

      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "CW:  waitpid %ld received %s\n",
			      (long) pid, status_to_str (status));
	}

a969 26
      /* Make sure we don't report an event for the exit of the
         original program, if we've detached from it.  */
      if (pid != -1 && !WIFSTOPPED (status) && pid != GET_PID (inferior_ptid))
	{
	  pid = -1;
	  save_errno = EINTR;
	}

      /* Check for stop events reported by a process we didn't already
	 know about - in this case, anything other than inferior_ptid.

	 If we're expecting to receive stopped processes after fork,
	 vfork, and clone events, then we'll just add the new one to
	 our list and go back to waiting for the event to be reported
	 - the stopped process might be returned from waitpid before
	 or after the event is.  If we want to handle debugging of
	 CLONE_PTRACE processes we need to do more here, i.e. switch
	 to multi-threaded mode.  */
      if (pid != -1 && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP
	  && pid != GET_PID (inferior_ptid))
	{
	  linux_record_stopped_pid (pid);
	  pid = -1;
	  save_errno = EINTR;
	}

d977 1
a977 2
      warning ("Child process unexpectedly missing: %s",
	       safe_strerror (errno));
a984 4
  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
    return linux_handle_extended_wait (pid, status, ourstatus);

a990 22
/* Stop an active thread, verify it still exists, then resume it.  */

static int
stop_and_resume_callback (struct lwp_info *lp, void *data)
{
  struct lwp_info *ptr;

  if (!lp->stopped && !lp->signalled)
    {
      stop_callback (lp, NULL);
      stop_wait_callback (lp, NULL);
      /* Resume if the lwp still exists.  */
      for (ptr = lwp_list; ptr; ptr = ptr->next)
	if (lp == ptr)
	  {
	    resume_callback (lp, NULL);
	    resume_set_callback (lp, NULL);
	  }
    }
  return 0;
}

d1003 1
a1003 1
  if (!sigismember (&blocked_mask, SIGCHLD))
d1009 1
a1009 1
retry:
d1027 2
a1028 3
				"LLW: Using pending wait status %s for %s.\n",
				status_to_str (status),
				target_pid_to_str (lp->ptid));
d1039 3
a1041 3
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: Waiting for specific LWP %s.\n",
			    target_pid_to_str (ptid));
d1051 2
a1052 3
			    "LLW: Using pending wait status %s for %s.\n",
			    status_to_str (status),
			    target_pid_to_str (lp->ptid));
d1064 7
a1070 7
         events.  In a typical case where interference is a problem,
         we have a SIGSTOP signal pending for LWP A while
         single-stepping it, encounter an event in LWP B, and take the
         pending SIGSTOP while trying to stop LWP A.  After processing
         the event in LWP B, LWP A is continued, and we'll never see
         the SIGTRAP associated with the last time we were
         single-stepping LWP A.  */
d1073 1
a1073 2
         pending SIGSTOP.  */
      registers_changed ();
d1075 1
a1075 6
		    TARGET_SIGNAL_0);
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: %s %s, 0, 0 (expect SIGSTOP)\n",
			    lp->step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
			    target_pid_to_str (lp->ptid));
d1083 2
a1084 2
  set_sigint_trap ();		/* Causes SIGINT to be passed on to the
				   attached process. */
a1095 7
	  if (debug_lin_lwp)
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  "LLW: waitpid %ld received %s\n",
				  (long) lwpid, status_to_str (status));
	    }

d1097 1
a1097 35

	  /* Check for stop events reported by a process we didn't
	     already know about - anything not already in our LWP
	     list.

	     If we're expecting to receive stopped processes after
	     fork, vfork, and clone events, then we'll just add the
	     new one to our list and go back to waiting for the event
	     to be reported - the stopped process might be returned
	     from waitpid before or after the event is.  */
	  if (WIFSTOPPED (status) && !lp)
	    {
	      linux_record_stopped_pid (lwpid);
	      status = 0;
	      continue;
	    }

	  /* Make sure we don't report an event for the exit of an LWP not in
	     our list, i.e.  not part of the current process.  This can happen
	     if we detach from a program we original forked and then it
	     exits.  */
	  if (!WIFSTOPPED (status) && !lp)
	    {
	      status = 0;
	      continue;
	    }

	  /* NOTE drow/2003-06-17: This code seems to be meant for debugging
	     CLONE_PTRACE processes which do not use the thread library -
	     otherwise we wouldn't find the new LWP this way.  That doesn't
	     currently work, and the following code is currently unreachable
	     due to the two blocks above.  If it's fixed some day, this code
	     should be broken out into a function so that we can also pick up
	     LWPs from the new interface.  */
	  if (!lp)
d1109 1
a1109 1
		  if (!in_thread_list (inferior_ptid))
d1112 1
a1112 1
						 GET_PID (inferior_ptid));
d1122 3
a1124 1
	  /* Check if the thread has exited.  */
d1130 2
a1131 55
		     thread.  */
		  if (!ptid_equal (lp->ptid, inferior_ptid))
		    delete_thread (lp->ptid);
		  printf_unfiltered ("[%s exited]\n",
				     target_pid_to_str (lp->ptid));
		}

	      /* If this is the main thread, we must stop all threads and
	         verify if they are still alive.  This is because in the nptl
	         thread model, there is no signal issued for exiting LWPs
	         other than the main thread.  We only get the main thread
	         exit signal once all child threads have already exited.
	         If we stop all the threads and use the stop_wait_callback
	         to check if they have exited we can determine whether this
	         signal should be ignored or whether it means the end of the
	         debugged application, regardless of which threading model
	         is being used.  */
	      if (GET_PID (lp->ptid) == GET_LWP (lp->ptid))
		{
		  lp->stopped = 1;
		  iterate_over_lwps (stop_and_resume_callback, NULL);
		}

	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s exited.\n",
				    target_pid_to_str (lp->ptid));

	      delete_lwp (lp->ptid);

	      /* If there is at least one more LWP, then the exit signal
	         was not the end of the debugged application and should be
	         ignored.  */
	      if (num_lwps > 0)
		{
		  /* Make sure there is at least one thread running.  */
		  gdb_assert (iterate_over_lwps (running_callback, NULL));

		  /* Discard the event.  */
		  status = 0;
		  continue;
		}
	    }

	  /* Check if the current LWP has previously exited.  In the nptl
	     thread model, LWPs other than the main thread do not issue
	     signals when they exit so we must check whenever the thread
	     has stopped.  A similar check is made in stop_wait_callback().  */
	  if (num_lwps > 1 && !lin_lwp_thread_alive (lp->ptid))
	    {
	      if (in_thread_list (lp->ptid))
		{
		  /* Core GDB cannot deal with us deleting the current
		     thread.  */
		  if (!ptid_equal (lp->ptid, inferior_ptid))
d1137 2
a1138 2
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s exited.\n",
d1152 3
a1154 3
	     ourselves in an attempt to stop an LWP.  */
	  if (lp->signalled
	      && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP)
d1157 2
a1158 2
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: Delayed SIGSTOP caught for %s.\n",
a1163 1
	      registers_changed ();
d1165 1
a1165 8
			    TARGET_SIGNAL_0);
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s %s, 0, 0 (discard SIGSTOP)\n",
				    lp->step ?
				    "PTRACE_SINGLESTEP" : "PTRACE_CONT",
				    target_pid_to_str (lp->ptid));

d1212 4
a1215 5
	     here?  It is not clear we should.  GDB may not expect
	     other threads to run.  On the other hand, not resuming
	     newly attached threads may cause an unwanted delay in
	     getting them running.  */
	  registers_changed ();
a1216 7
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog,
				"LLW: %s %s, %s (preempt 'handle')\n",
				lp->step ?
				"PTRACE_SINGLESTEP" : "PTRACE_CONT",
				target_pid_to_str (lp->ptid),
				signo ? strsignal (signo) : "0");
d1222 2
a1223 1
      if (signo == TARGET_SIGNAL_INT && signal_pass_state (signo) == 0)
d1226 3
a1228 3
	     forwarded to the entire process group, that is, all LWP's
	     will receive it.  Since we only want to report it once,
	     we try to flush it from all LWPs except this one.  */
d1237 2
a1238 2
    fprintf_unfiltered (gdb_stdlog, "LLW: Candidate event %s in %s.\n",
			status_to_str (status), target_pid_to_str (lp->ptid));
a1245 1
  iterate_over_lwps (flush_callback, &flush_mask);
d1265 3
a1267 3
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: trap_ptid is %s.\n",
			    target_pid_to_str (trap_ptid));
a1271 8
  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
    {
      linux_handle_extended_wait (ptid_get_pid (trap_ptid),
				  status, ourstatus);
      return trap_ptid;
    }

a1278 1
  errno = 0;
a1279 6
  if (debug_lin_lwp)
    fprintf_unfiltered (gdb_stdlog,
			"KC:  PTRACE_KILL %s, 0, 0 (%s)\n",
			target_pid_to_str (lp->ptid),
			errno ? safe_strerror (errno) : "OK");

a1299 6
	  if (pid != (pid_t) -1 && debug_lin_lwp)
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  "KWC: wait %s received unknown.\n",
				  target_pid_to_str (lp->ptid));
	    }
a1308 6
      if (pid != (pid_t) -1 && debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "KWC: wait %s received unk.\n",
			      target_pid_to_str (lp->ptid));
	}
d1334 1
a1334 1
static void
d1349 26
d1377 2
a1378 1
		     struct mem_attrib *attrib, struct target_ops *target)
d1386 1
a1386 3
  xfer = linux_proc_xfer_memory (memaddr, myaddr, len, write, attrib, target);
  if (xfer == 0)
    xfer = child_xfer_memory (memaddr, myaddr, len, write, attrib, target);
a1398 5
  if (debug_lin_lwp)
    fprintf_unfiltered (gdb_stdlog,
			"LLTA: PTRACE_PEEKUSER %s, 0, 0 (%s)\n",
			target_pid_to_str (ptid),
			errno ? safe_strerror (errno) : "OK");
d1432 2
a1433 4
  /* fetch_inferior_registers and store_inferior_registers will
     honor the LWP id, so we can use them directly.  */
  lin_lwp_ops.to_fetch_registers = fetch_inferior_registers;
  lin_lwp_ops.to_store_registers = store_inferior_registers;
a1439 6
  lin_lwp_ops.to_post_startup_inferior = child_post_startup_inferior;
  lin_lwp_ops.to_post_attach = child_post_attach;
  lin_lwp_ops.to_insert_fork_catchpoint = child_insert_fork_catchpoint;
  lin_lwp_ops.to_insert_vfork_catchpoint = child_insert_vfork_catchpoint;
  lin_lwp_ops.to_insert_exec_catchpoint = child_insert_exec_catchpoint;

d1479 1
a1479 1
				  (char *) &debug_lin_lwp,
d1481 3
a1483 1
Enables printf debugging output.\n", &setdebuglist), &showdebuglist);
@


1.35.2.1
log
@	* acconfig.h (HAVE_PREAD64): Add.
	* configure.in: Check for pread64.
	* config.in: Regenerated.
	* configure: Regenerated.
	* lin-lwp.c (lin_lwp_xfer_memory): Call linux_proc_xfer_memory.
	* linux-proc.c (linux_proc_xfer_memory): New function.
	* config/nm-linux.h (linux_proc_xfer_memory): Add prototype.
@
text
@d1386 1
a1386 3
  xfer = linux_proc_xfer_memory (memaddr, myaddr, len, write, attrib, target);
  if (xfer == 0)
    xfer = child_xfer_memory (memaddr, myaddr, len, write, attrib, target);
@


1.35.2.2
log
@2002-12-03  Andrew Cagney  <ac131313@@redhat.com>

	* sparc-nat.c (fetch_inferior_registers)
	(store_inferior_registers): Add comment on problem of LWP vs
	threads.

	From 2002-11-21 Daniel Jacobowitz <drow@@mvista.com>
	* lin-lwp.c (lin_lwp_fetch_registers): Remove.
	(lin_lwp_store_registers): Remove.
	(init_lin_lwp_ops): Use fetch_inferior_registers
	and store_inferior_registers directly.
	* sparc-nat.c (fetch_inferior_registers): Honor LWP ID.
	(store_inferior_registers): Likewise.
	Fix PR gdb/725.
@
text
@d1349 26
d1434 2
a1435 4
  /* fetch_inferior_registers and store_inferior_registers will
     honor the LWP id, so we can use them directly.  */
  lin_lwp_ops.to_fetch_registers = fetch_inferior_registers;
  lin_lwp_ops.to_store_registers = store_inferior_registers;
@


1.35.4.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d582 5
a586 2
  /* A specific PTID means `step only this process id'.  */
  resume_all = (PIDGET (ptid) == -1);
@


1.35.4.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d37 1
a37 1
extern char *strsignal (int sig);
d1346 26
d1383 1
a1383 3
  xfer = linux_proc_xfer_memory (memaddr, myaddr, len, write, attrib, target);
  if (xfer == 0)
    xfer = child_xfer_memory (memaddr, myaddr, len, write, attrib, target);
d1429 2
a1430 4
  /* fetch_inferior_registers and store_inferior_registers will
     honor the LWP id, so we can use them directly.  */
  lin_lwp_ops.to_fetch_registers = fetch_inferior_registers;
  lin_lwp_ops.to_store_registers = store_inferior_registers;
@


1.35.4.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a381 5
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog, 
			    "LLAL: PTRACE_ATTACH %s, 0, 0 (OK)\n", 
			    target_pid_to_str (ptid));

a393 8

      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "LLAL: waitpid %s received %s\n",
			      target_pid_to_str (ptid), 
			      status_to_str (status));
	}
a441 6
  if (debug_lin_lwp)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "LLA: waitpid %ld, faking SIGSTOP\n", 
			  (long) pid);
    }
d450 2
a451 3
    fprintf_unfiltered (gdb_stdlog, "DC:  Pending %s for %s on detach.\n",
			strsignal (WSTOPSIG (lp->status)), 
			target_pid_to_str (lp->ptid));
a454 1
      errno = 0;
a459 6
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog, 
			    "DC:  PTRACE_CONTINUE (%s, 0, %s) (OK)\n",
			    target_pid_to_str (lp->ptid),
			    status_to_str (lp->status)); 

a471 1
      errno = 0;
a476 6
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "PTRACE_DETACH (%s, %s, 0) (OK)\n",
			    target_pid_to_str (lp->ptid), 
			    strsignal (WSTOPSIG (lp->status)));

d505 19
d533 21
a554 4
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog, 
			    "RC:  PTRACE_CONT %s, 0, 0 (resume sibling)\n",
			    target_pid_to_str (lp->ptid));
a624 6
  if (debug_lin_lwp)
    fprintf_unfiltered (gdb_stdlog,
			"LLR: %s %s, %s (resume event thread)\n",
			step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
			target_pid_to_str (ptid),
			signo ? strsignal (signo) : "0");
a636 6
      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "SC:  kill %s **<SIGSTOP>**\n",
			      target_pid_to_str (lp->ptid));
	}
a669 8
      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "SWC: waitpid %s received %s\n",
			      target_pid_to_str (lp->ptid), 
			      status_to_str (status));
	}

d684 2
a685 2
	    fprintf_unfiltered (gdb_stdlog, "SWC: %s exited.\n", 
				target_pid_to_str (lp->ptid));
a695 1
	  errno = 0;
a696 6
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog,
				"PTRACE_CONT %s, 0, 0 (%s)\n",
				target_pid_to_str (lp->ptid),
				errno ? safe_strerror (errno) : "OK");

a717 1
	      errno = 0;
d721 3
a723 8
		  fprintf_unfiltered (gdb_stdlog, 
				      "PTRACE_CONT %s, 0, 0 (%s)\n",
				      target_pid_to_str (lp->ptid),
				      errno ? safe_strerror (errno) : "OK");

		  fprintf_unfiltered (gdb_stdlog, 
				      "SWC: Candidate SIGTRAP event in %s\n",
				      target_pid_to_str (lp->ptid));
d729 1
a729 3
		{
		  kill (GET_LWP (lp->ptid), WSTOPSIG (lp->status));
		}
d741 3
a743 4
		  fprintf_unfiltered (gdb_stdlog, 
				      "SWC: Pending event %s in %s\n",
				      status_to_str ((int) status), 
				      target_pid_to_str (lp->ptid));
a745 1
	      errno = 0;
a746 5
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog, 
				    "SWC: PTRACE_CONT %s, 0, 0 (%s)\n",
				    target_pid_to_str (lp->ptid),
				    errno ? safe_strerror (errno) : "OK");
d757 1
a757 10
		{
		  if (debug_lin_lwp)
		    {
		      fprintf_unfiltered (gdb_stdlog, 
					  "SWC: kill %s, %s\n",
					  target_pid_to_str (lp->ptid), 
					  status_to_str ((int) status));
		    }
		  kill (GET_LWP (lp->ptid), WSTOPSIG (status));
		}
d864 2
a865 2
			    "CBC: Push back breakpoint for %s\n",
			    target_pid_to_str (lp->ptid));
d896 2
a897 2
			    "SEL: Select single-step %s\n",
			    target_pid_to_str (event_lp->ptid));
d913 1
a913 1
			    "SEL: Found %d SIGTRAP events, selecting #%d\n", 
a964 9

      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog, 
			      "CW:  waitpid %ld received %s\n",
			      (long) pid, 
			      status_to_str (status));
	}

a966 8
      /* Make sure we don't report an event for the exit of the
	 original program, if we've detached from it.  */
      if (pid != -1 && ! WIFSTOPPED (status) && pid != GET_PID (inferior_ptid))
	{
	  pid = -1;
	  save_errno = EINTR;
	}

d974 1
a974 2
      warning ("Child process unexpectedly missing: %s", 
	       safe_strerror (errno));
d1024 2
a1025 3
				"LLW: Using pending wait status %s for %s.\n",
				status_to_str (status), 
				target_pid_to_str (lp->ptid));
d1037 2
a1038 2
			    "LLW: Waiting for specific LWP %s.\n",
			    target_pid_to_str (ptid));
d1048 2
a1049 3
			    "LLW: Using pending wait status %s for %s.\n",
			    status_to_str (status), 
			    target_pid_to_str (lp->ptid));
a1070 1
      registers_changed ();
a1072 5
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog,
			    "LLW: %s %s, 0, 0 (expect SIGSTOP)\n",
			    lp->step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
			    target_pid_to_str (lp->ptid));
a1092 8
	  if (debug_lin_lwp)
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  "LLW: waitpid %ld received %s\n",
				  (long) lwpid, 
				  status_to_str (status));
	    }

a1093 11

	  /* Make sure we don't report an event for the exit of an LWP not in
	     our list, i.e.  not part of the current process.  This can happen
	     if we detach from a program we original forked and then it
	     exits.  */
	  if (! WIFSTOPPED (status) && ! lp)
	    {
	      status = 0;
	      continue;
	    }

d1135 1
a1135 1
				    "LLW: %s exited.\n", 
d1150 1
a1150 2
	  if (lp->signalled
              && WIFSTOPPED (status)
d1155 1
a1155 1
				    "LLW: Delayed SIGSTOP caught for %s.\n",
a1160 1
	      registers_changed ();
a1162 7
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s %s, 0, 0 (discard SIGSTOP)\n",
				    lp->step ? 
				    "PTRACE_SINGLESTEP" : "PTRACE_CONT",
				    target_pid_to_str (lp->ptid));

a1212 1
	  registers_changed ();
a1213 6
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog,
				"LLW: %s %s, %s (preempt 'handle')\n",
				lp->step ? "PTRACE_SINGLESTEP" : "PTRACE_CONT",
				target_pid_to_str (lp->ptid),
				signo ? strsignal (signo) : "0");
d1234 2
a1235 3
    fprintf_unfiltered (gdb_stdlog, "LLW: Candidate event %s in %s.\n",
			status_to_str (status), 
			target_pid_to_str (lp->ptid));
d1263 2
a1264 2
			    "LLW: trap_ptid is %s.\n",
			    target_pid_to_str (trap_ptid));
a1275 1
  errno = 0;
a1276 6
  if (debug_lin_lwp)
    fprintf_unfiltered (gdb_stdlog, 
			"KC:  PTRACE_KILL %s, 0, 0 (%s)\n",
			target_pid_to_str (lp->ptid),
			errno ? safe_strerror (errno) : "OK");

a1296 6
	  if (pid != (pid_t) -1 && debug_lin_lwp)
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  "KWC: wait %s received unknown.\n",
				  target_pid_to_str (lp->ptid));
	    }
a1305 6
      if (pid != (pid_t) -1 && debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "KWC: wait %s received unk.\n", 
			      target_pid_to_str (lp->ptid));
	}
a1371 5
  if (debug_lin_lwp)
    fprintf_unfiltered (gdb_stdlog,
			"LLTA: PTRACE_PEEKUSER %s, 0, 0 (%s)\n",
			target_pid_to_str (ptid), 
			errno ? safe_strerror (errno) : "OK");
@


1.35.4.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d175 2
a176 1
    snprintf (buf, sizeof (buf), "%d (exited)", WEXITSTATUS (status));
d309 2
a310 2
  if (!ptid_equal (trap_ptid, null_ptid)
      && !ptid_equal (inferior_ptid, trap_ptid))
d322 1
a322 1
	     switch back to TRAP_PID.  */
d358 1
a358 1
  if (!sigismember (&blocked_mask, SIGCHLD))
d383 2
a384 2
	fprintf_unfiltered (gdb_stdlog,
			    "LLAL: PTRACE_ATTACH %s, 0, 0 (OK)\n",
d404 1
a404 1
			      target_pid_to_str (ptid),
d411 5
a415 5
         is already stopped.  Mark it as stopped in the data structure
         that the lin-lwp layer uses to keep track of threads.  Note
         that this won't have already been done since the main thread
         will have, we assume, been stopped by an attach from a
         different layer.  */
d458 2
a459 1
			  "LLA: waitpid %ld, faking SIGSTOP\n", (long) pid);
d470 1
a470 1
			strsignal (WSTOPSIG (lp->status)),
d482 1
a482 1
	fprintf_unfiltered (gdb_stdlog,
d485 1
a485 1
			    status_to_str (lp->status));
d508 1
a508 1
			    target_pid_to_str (lp->ptid),
d550 1
a550 1
	fprintf_unfiltered (gdb_stdlog,
d609 1
a609 1
	     this thread with a signal?  */
d615 1
a615 1
         resume_callback.  */
d637 1
a637 1
  if (!lp->stopped && !lp->signalled)
d665 1
a665 1
  if (!lp->stopped && lp->signalled)
d684 1
a684 1
			      target_pid_to_str (lp->ptid),
d695 1
a695 1
	         thread.  */
d702 1
a702 1
	    fprintf_unfiltered (gdb_stdlog, "SWC: %s exited.\n",
d730 11
a740 11
	         event for has hit a GDB breakpoint (as opposed to
	         some random trap signal), then just arrange for it to
	         hit it again later.  We don't keep the SIGTRAP status
	         and don't forward the SIGTRAP signal to the LWP.  We
	         will handle the current event, eventually we will
	         resume all LWPs, and this one will get its breakpoint
	         trap again.

	         If we do not do this, then we run the risk that the
	         user will delete or disable the breakpoint, but the
	         thread will have already tripped on it.  */
d747 1
a747 1
		  fprintf_unfiltered (gdb_stdlog,
d752 1
a752 1
		  fprintf_unfiltered (gdb_stdlog,
d770 1
a770 1
	         SIGSTOP, and didn't accidentally trip a breakpoint. */
d774 1
a774 1
		  fprintf_unfiltered (gdb_stdlog,
d776 1
a776 1
				      status_to_str ((int) status),
d783 1
a783 1
		fprintf_unfiltered (gdb_stdlog,
d789 1
a789 1
	         there are any more (we still want to get that SIGSTOP). */
d792 2
a793 2
	         this event.  If not, then this event must be returned
	         to the event queue of the LWP.  */
d800 1
a800 1
		      fprintf_unfiltered (gdb_stdlog,
d802 1
a802 1
					  target_pid_to_str (lp->ptid),
d813 1
a813 1
	     there's no SIGSTOP pending.  */
d907 2
a908 2
      && WIFSTOPPED (lp->status) && WSTOPSIG (lp->status) == SIGTRAP
      && breakpoint_inserted_here_p (read_pc_pid (lp->ptid) -
d951 1
a951 1
         which have had SIGTRAP events.  */
d961 2
a962 2
	fprintf_unfiltered (gdb_stdlog,
			    "SEL: Found %d SIGTRAP events, selecting #%d\n",
d973 1
a973 1
      *status = event_lp->status;
d1017 1
a1017 1
	  fprintf_unfiltered (gdb_stdlog,
d1019 2
a1020 1
			      (long) pid, status_to_str (status));
d1026 2
a1027 2
         original program, if we've detached from it.  */
      if (pid != -1 && !WIFSTOPPED (status) && pid != GET_PID (inferior_ptid))
d1040 1
a1040 1
      warning ("Child process unexpectedly missing: %s",
d1067 1
a1067 1
  if (!sigismember (&blocked_mask, SIGCHLD))
d1073 1
a1073 1
retry:
d1092 1
a1092 1
				status_to_str (status),
d1104 1
a1104 1
	fprintf_unfiltered (gdb_stdlog,
d1117 1
a1117 1
			    status_to_str (status),
d1130 7
a1136 7
         events.  In a typical case where interference is a problem,
         we have a SIGSTOP signal pending for LWP A while
         single-stepping it, encounter an event in LWP B, and take the
         pending SIGSTOP while trying to stop LWP A.  After processing
         the event in LWP B, LWP A is continued, and we'll never see
         the SIGTRAP associated with the last time we were
         single-stepping LWP A.  */
d1139 1
a1139 1
         pending SIGSTOP.  */
d1142 1
a1142 1
		    TARGET_SIGNAL_0);
d1155 2
a1156 2
  set_sigint_trap ();		/* Causes SIGINT to be passed on to the
				   attached process. */
d1172 2
a1173 1
				  (long) lwpid, status_to_str (status));
d1182 1
a1182 1
	  if (!WIFSTOPPED (status) && !lp)
d1188 1
a1188 1
	  if (!lp)
d1200 1
a1200 1
		  if (!in_thread_list (inferior_ptid))
d1203 1
a1203 1
						 GET_PID (inferior_ptid));
d1214 2
a1215 2
	     TARGET_WAITKIND_SIGNALLED event if there are still LWP's
	     left in the process.  */
d1221 2
a1222 2
		     thread.  */
		  if (!ptid_equal (lp->ptid, inferior_ptid))
d1228 2
a1229 2
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s exited.\n",
d1243 1
a1243 1
	     ourselves in an attempt to stop an LWP.  */
d1245 2
a1246 1
	      && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP)
d1249 1
a1249 1
		fprintf_unfiltered (gdb_stdlog,
d1258 1
a1258 1
			    TARGET_SIGNAL_0);
d1262 1
a1262 1
				    lp->step ?
d1312 4
a1315 4
	     here?  It is not clear we should.  GDB may not expect
	     other threads to run.  On the other hand, not resuming
	     newly attached threads may cause an unwanted delay in
	     getting them running.  */
d1321 1
a1321 2
				lp->step ?
				"PTRACE_SINGLESTEP" : "PTRACE_CONT",
d1329 2
a1330 1
      if (signo == TARGET_SIGNAL_INT && signal_pass_state (signo) == 0)
d1333 3
a1335 3
	     forwarded to the entire process group, that is, all LWP's
	     will receive it.  Since we only want to report it once,
	     we try to flush it from all LWPs except this one.  */
d1345 2
a1346 1
			status_to_str (status), target_pid_to_str (lp->ptid));
d1373 1
a1373 1
	fprintf_unfiltered (gdb_stdlog,
d1390 1
a1390 1
    fprintf_unfiltered (gdb_stdlog,
d1433 1
a1433 1
			      "KWC: wait %s received unk.\n",
d1461 1
a1461 1
static void
d1478 2
a1479 1
		     struct mem_attrib *attrib, struct target_ops *target)
d1505 1
a1505 1
			target_pid_to_str (ptid),
d1589 1
a1589 1
				  (char *) &debug_lin_lwp,
d1591 3
a1593 1
Enables printf debugging output.\n", &setdebuglist), &showdebuglist);
@


1.35.4.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a26 4
#ifdef HAVE_TKILL_SYSCALL
#include <unistd.h>
#include <sys/syscall.h>
#endif
a38 2
#include "linux-nat.h"

d72 37
a158 1
static int lin_lwp_thread_alive (ptid_t ptid);
d296 40
a629 26
/* Issue kill to specified lwp.  */

static int tkill_failed;

static int
kill_lwp (int lwpid, int signo)
{
  errno = 0;

/* Use tkill, if possible, in case we are using nptl threads.  If tkill
   fails, then we are not using nptl threads and we should be using kill.  */

#ifdef HAVE_TKILL_SYSCALL
  if (!tkill_failed)
    {
      int ret = syscall (__NR_tkill, lwpid, signo);
      if (errno != ENOSYS)
	return ret;
      errno = 0;
      tkill_failed = 1;
    }
#endif

  return kill (lwpid, signo);
}

d645 2
a646 9
      errno = 0;
      ret = kill_lwp (GET_LWP (lp->ptid), SIGSTOP);
      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "SC:  lwp kill %d %s\n",
			      ret,
			      errno ? safe_strerror (errno) : "ERRNO-OK");
	}
d670 1
a670 1
      pid = waitpid (GET_LWP (lp->ptid), &status, 0);
d672 3
a674 15
	{
	  pid = waitpid (GET_LWP (lp->ptid), &status, __WCLONE);
	  if (pid == -1 && errno == ECHILD)
	    {
	      /* The thread has previously exited.  We need to delete it now
	         because in the case of nptl threads, there won't be an
	         exit event unless it is the main thread.  */
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "SWC: %s exited.\n",
				    target_pid_to_str (lp->ptid));
	      delete_lwp (lp->ptid);
	      return 0;
	    }
	}
a685 1
      /* Check if the thread has exited.  */
d700 1
a700 25
	    fprintf_unfiltered (gdb_stdlog,
				"SWC: %s exited.\n",
				target_pid_to_str (lp->ptid));

	  delete_lwp (lp->ptid);
	  return 0;
	}

      /* Check if the current LWP has previously exited.  For nptl threads,
         there is no exit signal issued for LWPs that are not the
         main thread so we should check whenever the thread is stopped.  */
      if (!lin_lwp_thread_alive (lp->ptid))
	{
	  if (in_thread_list (lp->ptid))
	    {
	      /* Core GDB cannot deal with us deleting the current
	         thread.  */
	      if (!ptid_equal (lp->ptid, inferior_ptid))
		delete_thread (lp->ptid);
	      printf_unfiltered ("[%s exited]\n",
				 target_pid_to_str (lp->ptid));
	    }
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog,
				"SWC: %s already exited.\n",
d759 1
a759 8
		  if (debug_lin_lwp)
		    {
		      fprintf_unfiltered (gdb_stdlog,
					  "SWC: kill %s, %s\n",
					  target_pid_to_str (lp->ptid),
					  status_to_str ((int) status));
		    }
		  kill_lwp (GET_LWP (lp->ptid), WSTOPSIG (lp->status));
d803 1
a803 1
		  kill_lwp (GET_LWP (lp->ptid), WSTOPSIG (status));
a1029 17
      /* Check for stop events reported by a process we didn't already
	 know about - in this case, anything other than inferior_ptid.

	 If we're expecting to receive stopped processes after fork,
	 vfork, and clone events, then we'll just add the new one to
	 our list and go back to waiting for the event to be reported
	 - the stopped process might be returned from waitpid before
	 or after the event is.  If we want to handle debugging of
	 CLONE_PTRACE processes we need to do more here, i.e. switch
	 to multi-threaded mode.  */
      if (pid != -1 && WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP
	  && pid != GET_PID (inferior_ptid))
	{
	  pid = -1;
	  save_errno = EINTR;
	}

a1051 19
/* Stop an active thread, verify it still exists, then resume it.  */

static int
stop_and_resume_callback (struct lwp_info *lp, void *data)
{
  struct lwp_info *ptr;

  if (!lp->stopped && !lp->signalled)
    {
      stop_callback (lp, NULL);
      stop_wait_callback (lp, NULL);
      /* Resume if the lwp still exists.  */
      for (ptr = lwp_list; ptr; ptr = ptr->next)
	if (lp == ptr)
	  resume_callback (lp, NULL);
    }
  return 0;
}

a1173 16
	  /* Check for stop events reported by a process we didn't
	     already know about - anything not already in our LWP
	     list.

	     If we're expecting to receive stopped processes after
	     fork, vfork, and clone events, then we'll just add the
	     new one to our list and go back to waiting for the event
	     to be reported - the stopped process might be returned
	     from waitpid before or after the event is.  */
	  if (WIFSTOPPED (status) && !lp)
	    {
	      linux_record_stopped_pid (lwpid);
	      status = 0;
	      continue;
	    }

a1183 7
	  /* NOTE drow/2003-06-17: This code seems to be meant for debugging
	     CLONE_PTRACE processes which do not use the thread library -
	     otherwise we wouldn't find the new LWP this way.  That doesn't
	     currently work, and the following code is currently unreachable
	     due to the two blocks above.  If it's fixed some day, this code
	     should be broken out into a function so that we can also pick up
	     LWPs from the new interface.  */
d1209 3
a1211 1
	  /* Check if the thread has exited.  */
a1212 53
	    {
	      if (in_thread_list (lp->ptid))
		{
		  /* Core GDB cannot deal with us deleting the current
		     thread.  */
		  if (!ptid_equal (lp->ptid, inferior_ptid))
		    delete_thread (lp->ptid);
		  printf_unfiltered ("[%s exited]\n",
				     target_pid_to_str (lp->ptid));
		}

	      /* If this is the main thread, we must stop all threads and
	         verify if they are still alive.  This is because in the nptl
	         thread model, there is no signal issued for exiting LWPs
	         other than the main thread.  We only get the main thread
	         exit signal once all child threads have already exited.
	         If we stop all the threads and use the stop_wait_callback
	         to check if they have exited we can determine whether this
	         signal should be ignored or whether it means the end of the
	         debugged application, regardless of which threading model
	         is being used.  */
	      if (GET_PID (lp->ptid) == GET_LWP (lp->ptid))
		{
		  lp->stopped = 1;
		  iterate_over_lwps (stop_and_resume_callback, NULL);
		}

	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "LLW: %s exited.\n",
				    target_pid_to_str (lp->ptid));

	      delete_lwp (lp->ptid);

	      /* If there is at least one more LWP, then the exit signal
	         was not the end of the debugged application and should be
	         ignored.  */
	      if (num_lwps > 0)
		{
		  /* Make sure there is at least one thread running.  */
		  gdb_assert (iterate_over_lwps (running_callback, NULL));

		  /* Discard the event.  */
		  status = 0;
		  continue;
		}
	    }

	  /* Check if the current LWP has previously exited.  In the nptl
	     thread model, LWPs other than the main thread do not issue
	     signals when they exit so we must check whenever the thread
	     has stopped.  A similar check is made in stop_wait_callback().  */
	  if (num_lwps > 1 && !lin_lwp_thread_alive (lp->ptid))
@


1.35.4.6
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a326 2
      child_post_attach (pid);

d418 1
a418 6
      /* FIXME drow/2003-08-26: There was a call to stop_wait_callback
	 here.  But since lp->signalled was cleared above,
	 stop_wait_callback didn't do anything; the process was left
	 running.  Shouldn't we be waiting for it to stop?
	 I've removed the call, since stop_wait_callback now does do
	 something when called with lp->signalled == 0.  */
a585 71
/* Wait for LP to stop.  Returns the wait status, or 0 if the LWP has
   exited.  */

static int
wait_lwp (struct lwp_info *lp)
{
  pid_t pid;
  int status;
  int thread_dead = 0;

  gdb_assert (!lp->stopped);
  gdb_assert (lp->status == 0);

  pid = waitpid (GET_LWP (lp->ptid), &status, 0);
  if (pid == -1 && errno == ECHILD)
    {
      pid = waitpid (GET_LWP (lp->ptid), &status, __WCLONE);
      if (pid == -1 && errno == ECHILD)
	{
	  /* The thread has previously exited.  We need to delete it now
	     because in the case of NPTL threads, there won't be an
	     exit event unless it is the main thread.  */
	  thread_dead = 1;
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog, "WL: %s vanished.\n",
				target_pid_to_str (lp->ptid));
	}
    }

  if (!thread_dead)
    {
      gdb_assert (pid == GET_LWP (lp->ptid));

      if (debug_lin_lwp)
	{
	  fprintf_unfiltered (gdb_stdlog,
			      "WL: waitpid %s received %s\n",
			      target_pid_to_str (lp->ptid),
			      status_to_str (status));
	}
    }

  /* Check if the thread has exited.  */
  if (WIFEXITED (status) || WIFSIGNALED (status))
    {
      thread_dead = 1;
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stdlog, "WL: %s exited.\n",
			    target_pid_to_str (lp->ptid));
    }

  if (thread_dead)
    {
      if (in_thread_list (lp->ptid))
	{
	  /* Core GDB cannot deal with us deleting the current thread.  */
	  if (!ptid_equal (lp->ptid, inferior_ptid))
	    delete_thread (lp->ptid);
	  printf_unfiltered ("[%s exited]\n",
			     target_pid_to_str (lp->ptid));
	}

      delete_lwp (lp->ptid);
      return 0;
    }

  gdb_assert (WIFSTOPPED (status));

  return status;
}

d626 1
a626 1
  if (!lp->stopped)
d628 1
d631 1
a631 3
      status = wait_lwp (lp);
      if (status == 0)
	return 0;
d633 2
a634 2
      /* Ignore any signals in FLUSH_MASK.  */
      if (flush_mask && sigismember (flush_mask, WSTOPSIG (status)))
d636 2
a637 1
	  if (!lp->signalled)
d639 8
a646 1
	      lp->stopped = 1;
d649 3
d653 59
a826 82
/* Check whether PID has any pending signals in FLUSH_MASK.  If so set
   the appropriate bits in PENDING, and return 1 - otherwise return 0.  */

static int
lin_lwp_has_pending (int pid, sigset_t *pending, sigset_t *flush_mask)
{
  sigset_t blocked, ignored;
  int i;

  linux_proc_pending_signals (pid, pending, &blocked, &ignored);

  if (!flush_mask)
    return 0;

  for (i = 1; i < NSIG; i++)
    if (sigismember (pending, i))
      if (!sigismember (flush_mask, i)
	  || sigismember (&blocked, i)
	  || sigismember (&ignored, i))
	sigdelset (pending, i);

  if (sigisemptyset (pending))
    return 0;

  return 1;
}

/* DATA is interpreted as a mask of signals to flush.  If LP has
   signals pending, and they are all in the flush mask, then arrange
   to flush them.  LP should be stopped, as should all other threads
   it might share a signal queue with.  */

static int
flush_callback (struct lwp_info *lp, void *data)
{
  sigset_t *flush_mask = data;
  sigset_t pending, intersection, blocked, ignored;
  int pid, status;

  /* Normally, when an LWP exits, it is removed from the LWP list.  The
     last LWP isn't removed till later, however.  So if there is only
     one LWP on the list, make sure it's alive.  */
  if (lwp_list == lp && lp->next == NULL)
    if (!lin_lwp_thread_alive (lp->ptid))
      return 0;

  /* Just because the LWP is stopped doesn't mean that new signals
     can't arrive from outside, so this function must be careful of
     race conditions.  However, because all threads are stopped, we
     can assume that the pending mask will not shrink unless we resume
     the LWP, and that it will then get another signal.  We can't
     control which one, however.  */

  if (lp->status)
    {
      if (debug_lin_lwp)
	printf_unfiltered ("FC: LP has pending status %06x\n", lp->status);
      if (WIFSTOPPED (lp->status) && sigismember (flush_mask, WSTOPSIG (lp->status)))
	lp->status = 0;
    }

  while (lin_lwp_has_pending (GET_LWP (lp->ptid), &pending, flush_mask))
    {
      int ret;
      
      errno = 0;
      ret = ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stderr,
			    "FC: Sent PTRACE_CONT, ret %d %d\n", ret, errno);

      lp->stopped = 0;
      stop_wait_callback (lp, flush_mask);
      if (debug_lin_lwp)
	fprintf_unfiltered (gdb_stderr,
			    "FC: Wait finished; saved status is %d\n",
			    lp->status);
    }

  return 0;
}

a1049 1
	  linux_record_stopped_pid (pid);
a1069 4
  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
    return linux_handle_extended_wait (pid, status, ourstatus);

a1464 1
  iterate_over_lwps (flush_callback, &flush_mask);
a1490 8
  /* Handle GNU/Linux's extended waitstatus for trace events.  */
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
    {
      linux_handle_extended_wait (ptid_get_pid (trap_ptid),
				  status, ourstatus);
      return trap_ptid;
    }

a1659 6
  lin_lwp_ops.to_post_startup_inferior = child_post_startup_inferior;
  lin_lwp_ops.to_post_attach = child_post_attach;
  lin_lwp_ops.to_insert_fork_catchpoint = child_insert_fork_catchpoint;
  lin_lwp_ops.to_insert_vfork_catchpoint = child_insert_vfork_catchpoint;
  lin_lwp_ops.to_insert_exec_catchpoint = child_insert_exec_catchpoint;

@


1.35.4.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d933 1
a933 1
  return (lp->stopped == 0 || (lp->status != 0 && lp->resumed));
d1186 1
a1186 4
	  {
	    resume_callback (lp, NULL);
	    resume_set_callback (lp, NULL);
	  }
@


1.34
log
@* lin-lwp.c (child_wait): Check SAVE_ERRNO instead of ERRNO in
while statement.
@
text
@d24 1
@


1.34.6.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a23 1
#include "gdb_string.h"
@


1.34.6.2
log
@merge from mainline
@
text
@d582 5
a586 2
  /* A specific PTID means `step only this process id'.  */
  resume_all = (PIDGET (ptid) == -1);
@


1.33
log
@s/strerror/safe_strerror/
@
text
@d972 1
a972 1
  while (pid == -1 && errno == EINTR);
@


1.32
log
@* lin-lwp.c, thread-db.c, defs.h, cris-tdep.c: Replace ``Linux''
with either ``GNU/Linux'' or ``Linux kernel''.
Fix PR gdb/378.
@
text
@d379 1
a379 1
	       strerror (errno));
d457 1
a457 1
	       strerror (errno));
d474 1
a474 1
	       strerror (errno));
d976 1
a976 1
      warning ("Child process unexpectedly missing: %s", strerror (errno));
@


1.31
log
@Fix two ``attach'' related bugs involving threads.
@
text
@d1 1
a1 1
/* Multi-threaded debugging support for Linux (LWP layer).
d38 7
a44 7
/* On Linux there are no real LWP's.  The closest thing to LWP's are
   processes sharing the same VM space.  A multi-threaded process is
   basically a group of such processes.  However, such a grouping is
   almost entirely a user-space issue; the kernel doesn't enforce such
   a grouping at all (this might change in the future).  In general,
   we'll rely on the threads library (i.e. the LinuxThreads library)
   to provide such a grouping.
d51 1
a51 1
   using Linux 2.4 or above.
d53 2
a54 2
   Note that there are some peculiarities in Linux that affect this
   code:
d60 2
a61 2
     __WCLONE flag is absent.  Linux 2.4 has a __WALL flag, but we
     cannot use it since GDB must work on older systems too.
d65 5
a69 5
     keeps it around as a "zombie".  Somehow, the LinuxThreads library
     doesn't notice this, which leads to the "zombie problem": When
     debugged a multi-threaded process that spawns a lot of threads
     will run out of processes, even if the threads exit, because the
     "zombies" stay around.  */
d296 1
a296 1
/* Implementation of the PREPARE_TO_PROCEED hook for the Linux LWP
d1479 1
a1479 1
				  "Set debugging of linux lwp module.\n\
d1487 2
a1488 1
   the LinuxThreads library and therefore doesn't really belong here.  */
d1532 5
a1536 4
  /* The LinuxThreads library makes terminating threads send a special
     "cancel" signal instead of SIGCHLD.  Make sure we catch those (to
     prevent them from terminating GDB itself, which is likely to be
     their default action) and treat them the same way as SIGCHLD.  */
@


1.30
log
@Fix attaching to cloned processes.  This fixes PR gdb/61.
* lin-lwp.c (struct lwp_info): Add new member `cloned'.
(is_cloned) Removed.
(lin_lwp_attach_lwp): Don't call stop_wait_callback.  Instead call
waitpid explicitly.  Mark the LWP as cloned if waitpid fails and
retry with __WCLONE flag.
(lin_lwp_attach): Likewise.  Warn if attaching to a cloned process.
(detach_callback): Replace use of is_cloned with explicit check on
LWP id and process id.
(stop_wait_callback): Replace use of is_cloned with check if LWP
is marked as cloned.
[CHILD_WAIT] (child_wait): New function.
(lin_lwp_wait): Replace use of is_cloned with check if LWP is
marked as cloned.  Mark newly detected LWPs as cloned if detected
by waitpid with __WCLONE flag.
(kill_wait_callback): Replace use of is_cloned with check if LWP
is marked as cloned.
* config/i386/nm-linux.h (struct target_waitstatus): Add forward
declaration.
(child_wait): Add prototype.
(CHILD_WAIT): Define.
@
text
@d355 8
d392 10
@


1.29
log
@* lin-lwp.c (lin_lwp_wait): Avoid check for resumed LWPs if there
are no registered LWPs yet.
@
text
@d78 5
a122 2
#define is_cloned(pid)	(GET_LWP (pid) != GET_PID (pid))

a357 4
  /* We assume that we're already tracing the initial process.  */
  if (is_cloned (ptid) && ptrace (PTRACE_ATTACH, GET_LWP (ptid), 0, 0) < 0)
    error ("Can't attach %s: %s", target_pid_to_str (ptid), strerror (errno));

d362 3
a364 1
  if (is_cloned (ptid))
d366 19
a384 2
      lp->signalled = 1;
      stop_wait_callback (lp, NULL);
d392 2
d400 1
a400 1
  lp = add_lwp (BUILD_LWP (PIDGET (inferior_ptid), PIDGET (inferior_ptid)));
d405 14
a418 3
  lp->signalled = 1;
  stop_wait_callback (lp, NULL);
  gdb_assert (lp->status == 0);
d449 3
a451 1
  if (is_cloned (lp->ptid))
d469 1
a469 1
  /* Only the initial (uncloned) process should be left right now.  */
d646 1
a646 2
      pid = waitpid (GET_LWP (lp->ptid), &status,
		     is_cloned (lp->ptid) ? __WCLONE : 0);
d923 49
d1038 1
a1038 1
      options = is_cloned (lp->ptid) ? __WCLONE : 0;
d1081 3
d1276 1
a1276 1
  if (is_cloned (lp->ptid))
@


1.28
log
@* lin-lwp.c (stop_wait_callback): Add support for flushing
signals.  Use that in favour of the old code to get rid of
superfluous SIGINTs.
(lin_lwp_wait): Use the new support in stop_wait_callback to
flush all but one SIGINT.
@
text
@d911 3
a913 2
  /* Make sure there is at least one thread that has been resumed.  */
  gdb_assert (iterate_over_lwps (resumed_callback, NULL));
@


1.27
log
@* lin-lwp.c (status_to_str): New function.
(lin_lwp_wait): Use it to print debug messages where appropriate.
@
text
@d598 2
a599 1
/* Wait until LP is stopped.  */
d604 2
d645 7
a685 12
	  else if (WSTOPSIG (status) == SIGINT &&
		   signal_pass_state (SIGINT) == 0)
	    {
	      /* Since SIGINT gets forwarded to the entire process group
		 (in the case where ^C/BREAK is typed at the tty/console),
		 just ignore all SIGINT events from all lwp's except for
		 the one that was caught by lin_lwp_wait.  */

	      /* Now resume this LWP and get the SIGSTOP event. */
	      ptrace (PTRACE_CONT, GET_LWP (lp->ptid), 0, 0);
	      return stop_wait_callback (lp, data);
	    }
d898 3
d1117 10
d1141 1
a1141 1
  iterate_over_lwps (stop_wait_callback, NULL);
@


1.26
log
@* lin-lwp.c (count_events_callback): Fix formatting.  Turn check
commented with "paranoia" into gdb_assert.
(select_event_lwp_callback): Likewise.
(cancel_breakpoints_callback): Bail out early if LP is the event
LWP.  Add comment about backup up breakpoints.  Fix formatting and
debug message.
(select_event_lwp): Make solely repsonsible for switching event
LWP.  Fix formatting and remove bogus "ERROR" debug message.
Don't backup breakpoints from here.
(lin_lwp_wait): Don't touch LP->status, let select_event_lwp
handle that.  Only call select_event_lwp if we're not waiting for
a specific LWP, i.e. when PID == -1.  Backup breakpoints from here.
@
text
@d156 2
d159 18
d924 3
a926 5
	    fprintf_unfiltered (gdb_stdlog, 
				"Using pending wait status %d for LWP %ld.\n",
				WIFSTOPPED (status) ? WSTOPSIG (status) : 
				WIFSIGNALED (status) ? WTERMSIG (status) :
				WEXITSTATUS (status), GET_LWP (lp->ptid));
d948 3
a950 5
	fprintf_unfiltered (gdb_stdlog, 
			    "Using pending wait status %d for LWP %ld.\n",
			    WIFSTOPPED (status) ? WSTOPSIG (status) : 
			    WIFSIGNALED (status) ? WTERMSIG (status) :
			    WEXITSTATUS (status), GET_LWP (lp->ptid));
d1122 2
a1123 3
    fprintf_unfiltered (gdb_stdlog, 
			"LLW: Candidate event %d in %ld\n",
			WSTOPSIG (status), GET_LWP (lp->ptid));
@


1.25
log
@2001-06-12  Michael Snyder  <msnyder@@redhat.com>

	* lin-lwp.c: Prevent thread starvation by using a monte carlo
	method to choose which of several event threads to handle next.

	(stop_wait_callback): Defer pushback of breakpoint events until
	later; add SIGTRAP events to the queue of unhandled events.
	Keep calling waitpid until SIGSTOP retrieved.  If more than one
	non-SIGSTOP event is retrieved, push them back onto the process
	queue using kill.
	(count_events_callback, select_singlestep_lwp_callback,
	select_event_lwp_callback, cancel_breakpoints_callback,
	select_event_lwp): New functions.  Implement monte carlo method
	for selecting which of several SIGTRAP threads to handle next.
	Push back the breakpoint event for all threads other than the
	selected one.
	(lin_lwp_wait): Call select_event_lwp to decide which of several
	sigtrapped lwps to handle next.
	(resume_callback): Disable code that attempts to handle
	step_resume breakpoints.  Let core gdb handle this.
@
text
@d725 1
a725 1
/* Count the LWP's that have had events. */
d732 5
a736 5
  /* Count only threads that have a SIGTRAP pending. */
  if (lp->status != 0 &&
      WIFSTOPPED (lp->status) && 
      WSTOPSIG (lp->status) == SIGTRAP &&
      count != NULL)	/* paranoia */
d742 1
a742 1
/* Select the LWP (if any) that is currently being single-stepped. */
d753 1
a753 1
/* Select the Nth LWP that has had a SIGTRAP event. */
d760 5
a764 5
  /* Select only threads that have a SIGTRAP event pending. */
  if (lp->status != 0 &&
      WIFSTOPPED (lp->status) &&
      WSTOPSIG (lp->status) == SIGTRAP &&
      selector != NULL)	/* paranoia */
d776 19
a794 6
  if (lp != event_lp &&
      lp->status != 0 &&
      WIFSTOPPED (lp->status) &&
      WSTOPSIG (lp->status) == SIGTRAP &&
      breakpoint_inserted_here_p (read_pc_pid (lp->ptid) - 
				  DECR_PC_AFTER_BREAK))
d797 5
a801 7
	{
	  fprintf_unfiltered (gdb_stdlog, 
			      "Push back BP for %ld\n",
			      GET_LWP (lp->ptid));
	}
      /* For each lp except the event lp, if there was a trap,
	 set the PC to before the trap. */
d803 3
a805 4
	{
	  write_pc_pid (read_pc_pid (lp->ptid) - DECR_PC_AFTER_BREAK, 
			lp->ptid);
	}
d808 1
d812 1
a812 1
/* Select one LWP out of those that have events to be the event thread. */
d821 4
a824 1
  /* Give preference to any LWP that is being single-stepped. */
d829 2
a830 2
	fprintf_unfiltered (gdb_stdlog, 
			    "Select singlestep lwp %ld\n", 
d836 1
a836 1
	 which have had SIGTRAP events. */
d838 2
a839 2
      /* First see how many SIGTRAP events we have. */
      iterate_over_lwps (count_events_callback, (void *) &num_events);
d841 2
a842 2
      /* OK, now randomly pick the Nth LWP of those that have had SIGTRAP. */
      random_selector = (int) 
d845 4
a848 11
      if (debug_lin_lwp)
	{
	  if (num_events > 1)
	    fprintf_unfiltered (gdb_stdlog, 
				"Found %d SIGTRAP events, selecting #%d\n", 
				num_events, random_selector);
	  else if (num_events <= 0)
	    fprintf_unfiltered (gdb_stdlog, 
				"ERROR select_event_lwp %d events!\n", 
				num_events);
	}
d850 2
a851 2
      event_lp =  iterate_over_lwps (select_event_lwp_callback, 
				     (void *) &random_selector);
d856 1
a856 5
      /* "event_lp" is now the selected event thread.
	 If any other threads have had SIGTRAP events, these events
	 must now be cancelled, so that the respective thread will
	 trip the breakpoint again once it is resumed.  */
      iterate_over_lwps (cancel_breakpoints_callback, (void *) event_lp);
a858 1
      event_lp->status = 0;
d860 3
a1104 6
  if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP)
    {
      /* Save SIGTRAP event for select_event_lwp. */
      lp->status = status;
    }

d1117 5
a1121 3
  /* MVS Now choose an event thread from among those that
     have had events.  Giving equal priority to all threads
     that have had events helps prevent starvation. */
d1123 4
a1126 1
  select_event_lwp (&lp, &status);
@


1.24
log
@* lin-lwp.c (struct lwp_info): Add member `resumed'.
(iterate_over_lwps): Make sure we can handle CALLBACK deleting the
LWP it's called for.
(lin_lwp_attach): Mark LWP as resumed to make sure the fake
SIGSTOP is reported.
(resume_clear_callback): New function.
(resume_set_callback): New function.
(lin_lwp_resume): Mark all LWP's that we're going to resume as
resumed, and unmark all others.
(status_callback): Only report a pending wait status if we pretend
that LP has been resumed.
(resumed_callback): New function.
(lin_lwp_wait): Add assertions to check that LWP's are properly
marked as resumed.  Partially revert 2001-05-25 patch by Michael
Snyder: do not resume all threads.  Add comment explaining the
problems associated with this bit of code.
@
text
@d461 1
a461 1
#if 1
a587 1
    get_another_event:
a620 1
      lp->stopped = 1;
d624 1
a624 3
	  if (WSTOPSIG (status) == SIGTRAP
	      && breakpoint_inserted_here_p (read_pc_pid (pid_to_ptid (pid))
					     - DECR_PC_AFTER_BREAK))
a638 12
	      if (debug_lin_lwp)
		fprintf_unfiltered (gdb_stdlog,
				    "Tripped breakpoint at %lx in LWP %d"
				    " while waiting for SIGSTOP.\n",
				    (long) read_pc_pid (lp->ptid), pid);

	      /* Set the PC to before the trap.  */
	      if (DECR_PC_AFTER_BREAK)
		write_pc_pid (read_pc_pid (pid_to_ptid (pid)) 
		                - DECR_PC_AFTER_BREAK,
			      pid_to_ptid (pid));

d641 14
a654 1
	      goto get_another_event;
d664 1
a664 1
	      /* Now resume this LWP and get the SIGSTP event. */
d666 1
a666 1
	      goto get_another_event;
d670 3
d674 7
a680 3
		fprintf_unfiltered (gdb_stdlog, 
				    "Received %s in LWP %d while waiting for SIGSTOP.\n",
				    strsignal (WSTOPSIG (status)), pid);
d682 11
a692 4
	      /* The thread was stopped with a signal other than
		 SIGSTOP, and didn't accidentally trip a breakpoint.
		 Record the wait status.  */
	      lp->status = status;
d699 1
d725 135
d891 1
a891 1
      /* Any LWP will do.  */
a894 5
	  if (debug_lin_lwp)
	    fprintf_unfiltered (gdb_stdlog, 
				"Using pending wait status for LWP %ld.\n",
				GET_LWP (lp->ptid));

d897 7
d924 6
a929 5
      if (debug_lin_lwp)
	if (status)
	  fprintf_unfiltered (gdb_stdlog, 
			      "Using pending wait status for LWP %ld.\n",
			      GET_LWP (lp->ptid));
d1100 11
d1118 6
d1128 7
a1134 1
    trap_ptid = (threaded ? lp->ptid : pid_to_ptid (GET_LWP (lp->ptid)));
@


1.23
log
@
* arch-utils.c (generic_prepare_to_proceed): Allow for having
stopped due to a Ctrl-C as well as breakpoints.

* hppa-tdep.c (hppa_prepare_to_proceed): Add FIXME as this may not
support thread switches after Ctrl-C.
* lin-lwp.c (lin_lwp_prepare_to_proceed): Ditto.
* linux-thread.c (linuxthreads_prepare_to_proceed): Ditto.
* m3-nat.c (mach3_prepare_to_proceed): Ditto.
@
text
@d85 8
d260 1
a260 1
  struct lwp_info *lp;
d262 6
a267 3
  for (lp = lwp_list; lp; lp = lp->next)
    if ((*callback) (lp, data))
      return lp;
d371 1
d490 14
d516 5
d534 3
d700 3
a702 1
  return (lp->status != 0);
d713 8
d738 3
d804 1
d891 1
d935 6
a940 2
	  /* First mark this LWP as "not stopped", so that
	     resume_callback will not resume it. */
a941 5
	  /* Resume all threads except this one
	     (mainly to get the newly attached ones). */
	  iterate_over_lwps (resume_callback, NULL);
	  /* Now resume this thread, forwarding the signal to it. */
	  child_resume (pid_to_ptid (GET_LWP (lp->ptid)), lp->step, signo);
@


1.22
log
@2001-05-25  Michael Snyder  <msnyder@@redhat.com>

	* lin-lwp.c (lin_lwp_attach_lwp): Call stop_wait_callback,
	to consume the SIGSTOP generated by PTRACE_ATTACH.
	(stop_wait_callback): If a SIGTRAP or a SIGINT event is consumed,
	try again to get the SIGSTOP event.
	(lin_lwp_wait): Resume all threads when ignoring a signal.
	This will insure that newly attached threads get resumed.
@
text
@d266 4
a269 1
   default_prepare_to_proceed() has been added.  */
@


1.21
log
@2001-05-25  Michael Snyder  <msnyder@@redhat.com>

	* lin-lwp.c (stop_wait_callback): Discard redundant SIGINT events.
@
text
@d330 4
a333 1
    lp->signalled = 1;
d376 1
d488 1
a488 1
     handled special.  */
d551 1
d617 4
d629 4
a632 1
	      ;  /* Don't save.  Signal will disappear into oblivion. */
d883 7
a890 1
	  lp->stopped = 0;
@


1.20
log
@Fix warnings resulting from fact that GET_LWP() now returns a long rather
than an int.
@
text
@d613 9
d630 1
a630 1
		 SIGSTOP, and didn't accidentiliy trip a breakpoint.
@


1.19
log
@Redefine ptid_t to be a struct rather than an int.
@
text
@d362 1
a362 1
    fprintf_unfiltered (gdb_stdlog, "Pending %s for LWP %d on detach.\n",
d679 1
a679 1
				"Using pending wait status for LWP %d.\n",
d695 1
a695 1
			    "Waiting for specific LWP %d.\n",
d707 1
a707 1
			      "Using pending wait status for LWP %d.\n",
d1027 1
a1027 1
      snprintf (buf, sizeof (buf), "LWP %d", GET_LWP (ptid));
@


1.18
log
@Revert a couple of small changes that inadvertently came in via the
2001-05-03 patch.
@
text
@d105 4
a108 12
#ifndef TIDGET
#define TIDGET(PID)		(((PID) & 0x7fffffff) >> 16)
#define PIDGET0(PID)		(((PID) & 0xffff))
#define PIDGET(PID)		((PIDGET0 (PID) == 0xffff) ? -1 : PIDGET0 (PID))
#define MERGEPID(PID, TID)	(((PID) & 0xffff) | ((TID) << 16))
#endif

#define THREAD_FLAG		0x80000000
#define is_lwp(pid)		(((pid) & THREAD_FLAG) == 0 && TIDGET (pid))
#define GET_LWP(pid)		TIDGET (pid)
#define GET_PID(pid)		PIDGET (pid)
#define BUILD_LWP(tid, pid)	MERGEPID (pid, tid)
@


1.17
log
@Minor ptid_t changes for the upcoming phase 3 ptid patch.
@
text
@d688 1
a688 1
				(int) GET_LWP (lp->ptid));
d1035 1
a1035 1
      snprintf (buf, sizeof (buf), "LWP %ld", GET_LWP (ptid));
@


1.16
log
@Consolidate save_inferior_ptid/restore_inferior_ptid implementation to
one source file.
@
text
@d351 1
a351 1
  lp = add_lwp (BUILD_LWP (inferior_ptid, inferior_ptid));
d417 1
a417 1
  inferior_ptid = GET_PID (inferior_ptid);
@


1.15
log
@Implement attach/detach for multi-threaded programs on Linux.
* thread-db.c (keep_thread_db): Adjust comment.
(deactivate_target): Removed.
(thread_db_new_objfile): Don't call deactivate_target.  Implement
guts of deactivate_target inline instead.
(attach_thread): Call ATTACH_LWP unconditionally if defined.
(thread_db_attach): New function.
(thread_db_detach): Don't call deactivate_target.  Do necessary
cleanup inline instead.  Set inferior_ptid to LWP corresponding to
the current user-level thread.
(thread_db_kill): Set inferior_ptid to LWP corresponding to the
current user-level thread.
(thread_db_create_inferior): Deactivate target vector if
KEEP_THREAD_DB is zero.
(thread_db_mourn_inferior): Don't call deactivate_target.  Do
necessary cleanup inline instead.
(init_thread_db_ops): Initialize to_attach field to
thread_db_attach.
* lin-lwp.c (lin_lwp_mourn_inferior): Remove prototype.
(stop_wait_callback): Add prototype.
(init_lwp_list): Add comment about when to re-initialize the LWP
list.
(lin_lwp_attach_lwp): Only call ptrace for cloned processes.
Avoid adding publicates to the LWP list.  Only mark an LWP as
signalled if it doesn't correspond to a cloned process.
(lin_lwp_attach): Add initial process to the LWP list.  Make sure
it's stopped and fake a SIGSTOP.
(detach_callback): New function.
(lin_lwp_detach): Implement.
(lin_lwp_create_inferior): Don't re-initialize LWP list here.
Call child_ops.to_create_inferior directly instead of via
target_beneath local.
(lin_lwp_mourn_inferior): Call child_ops.to_mourn_inferior
directly instead of via target_beneath local.
@
text
@a269 21
/* Helper functions.  */

static void
restore_inferior_ptid (void *arg)
{
  ptid_t *saved_ptid_ptr = arg;
  inferior_ptid = *saved_ptid_ptr;
  xfree (arg);
}

static struct cleanup *
save_inferior_ptid (void)
{
  ptid_t *saved_ptid_ptr;

  saved_ptid_ptr = xmalloc (sizeof (ptid_t));
  *saved_ptid_ptr = inferior_ptid;
  return make_cleanup (restore_inferior_ptid, saved_ptid_ptr);
}


d704 1
a704 1
			    (int) GET_LWP (ptid));
@


1.14
log
@Phase 1 of the ptid_t changes.
@
text
@d154 1
a154 1
static void lin_lwp_mourn_inferior (void);
d157 4
a160 1
/* Initialize the list of LWPs.  */
d350 2
a351 1
  if (ptrace (PTRACE_ATTACH, GET_LWP (ptid), 0, 0) < 0)
d354 6
a359 2
  lp = add_lwp (ptid);
  lp->signalled = 1;
d365 2
d369 50
a418 1
  error("Not implemented yet");
d424 16
a439 2
  /* FIXME: Provide implementation when we implement lin_lwp_attach.  */
  error ("Not implemented yet");
d975 1
a975 10
  struct target_ops *target_beneath;

  init_lwp_list ();

#if 0
  target_beneath = find_target_beneath (&lin_lwp_ops);
#else
  target_beneath = &child_ops;
#endif
  target_beneath->to_create_inferior (exec_file, allargs, env);
d981 1
a981 1
  struct target_ops *target_beneath;
d983 1
a985 2
  trap_ptid = null_ptid;

d990 1
a990 6
#if 0
  target_beneath = find_target_beneath (&lin_lwp_ops);
#else
  target_beneath = &child_ops;
#endif
  target_beneath->to_mourn_inferior ();
@


1.13
log
@2001-05-01  Michael Snyder  <msnyder@@redhat.com>

	* lin-lwp.c: Change printf to fprintf_unfiltered.
@
text
@d76 1
a76 1
  int pid;
d107 2
a108 1
#define PIDGET(PID)		(((PID) & 0xffff))
d122 1
a122 1
int trap_pid;
d180 1
a180 1
add_lwp (int pid)
d184 1
a184 1
  gdb_assert (is_lwp (pid));
d190 1
a190 1
  lp->pid = pid;
d203 1
a203 1
delete_lwp (int pid)
d210 1
a210 1
    if (lp->pid == pid)
d232 1
a232 1
find_lwp_pid (int pid)
d235 1
d237 4
a240 2
  if (is_lwp (pid))
    pid = GET_LWP (pid);
d243 1
a243 1
    if (pid == GET_LWP (lp->pid))
d270 1
a270 1
restore_inferior_pid (void *arg)
d272 2
a273 2
  int *saved_pid_ptr = arg;
  inferior_pid = *saved_pid_ptr;
d278 1
a278 1
save_inferior_pid (void)
d280 1
a280 1
  int *saved_pid_ptr;
d282 3
a284 3
  saved_pid_ptr = xmalloc (sizeof (int));
  *saved_pid_ptr = inferior_pid;
  return make_cleanup (restore_inferior_pid, saved_pid_ptr);
d297 2
a298 1
  if (trap_pid && inferior_pid != trap_pid)
d306 1
a306 1
      trap_pc = read_pc_pid (trap_pid);
d311 1
a311 1
	  inferior_pid = trap_pid;
d338 1
a338 1
lin_lwp_attach_lwp (int pid, int verbose)
d342 1
a342 1
  gdb_assert (is_lwp (pid));
d345 1
a345 1
    printf_filtered ("[New %s]\n", target_pid_to_str (pid));
d347 2
a348 2
  if (ptrace (PTRACE_ATTACH, GET_LWP (pid), 0, 0) < 0)
    error ("Can't attach %s: %s", target_pid_to_str (pid), strerror (errno));
d350 1
a350 1
  lp = add_lwp (pid);
d383 1
a383 1
  if (tp->private->lwpid == GET_LWP (lp->pid))
d402 1
a402 1
      tp = find_thread_pid (lp->pid);
d419 1
a419 1
      child_resume (GET_LWP (lp->pid), 0, TARGET_SIGNAL_0);
d428 1
a428 1
lin_lwp_resume (int pid, int step, enum target_signal signo)
d437 1
a437 1
  resume_all = (pid == -1) || !step;
d441 2
a442 2
  if (pid == -1)
    pid = inferior_pid;
d444 1
a444 1
  lp = find_lwp_pid (pid);
d447 1
a447 1
      pid = GET_LWP (lp->pid);
d470 1
a470 1
  child_resume (pid, step, signo);
d483 1
a483 1
      ret = kill (GET_LWP (lp->pid), SIGSTOP);
d505 2
a506 2
      pid = waitpid (GET_LWP (lp->pid), &status,
		     is_cloned (lp->pid) ? __WCLONE : 0);
d512 1
a512 1
      gdb_assert (pid == GET_LWP (lp->pid));
d518 1
a518 1
	  if (in_thread_list (lp->pid))
d522 2
a523 2
	      if (lp->pid != inferior_pid)
		delete_thread (lp->pid);
d525 1
a525 1
				 target_pid_to_str (lp->pid));
d529 1
a529 1
				"%s exited.\n", target_pid_to_str (lp->pid));
d531 1
a531 1
	  delete_lwp (lp->pid);
d541 1
a541 1
	      && breakpoint_inserted_here_p (read_pc_pid (pid)
d561 1
a561 1
				    (long) read_pc_pid (lp->pid), pid);
d565 3
a567 1
		write_pc_pid (read_pc_pid (pid) - DECR_PC_AFTER_BREAK, pid);
d609 2
a610 2
static int
lin_lwp_wait (int pid, struct target_waitstatus *ourstatus)
d615 1
d636 1
a636 1
				GET_LWP (lp->pid));
d647 1
a647 1
  else if (is_lwp (pid))
d651 2
a652 1
			    "Waiting for specific LWP %d.\n", GET_LWP (pid));
d655 1
a655 1
      lp = find_lwp_pid (GET_LWP (pid));
d664 1
a664 1
			      GET_LWP (lp->pid));
d669 2
a670 2
      options = is_cloned (lp->pid) ? __WCLONE : 0;
      pid = GET_LWP (pid);
d686 2
a687 1
      child_resume (GET_LWP (lp->pid), lp->step, TARGET_SIGNAL_0);
d707 1
a707 1
	  lp = find_lwp_pid (lwpid);
d710 1
a710 1
	      lp = add_lwp (BUILD_LWP (lwpid, inferior_pid));
d717 1
a717 1
		  if (! in_thread_list (inferior_pid))
d719 3
a721 2
		      inferior_pid = BUILD_LWP (inferior_pid, inferior_pid);
		      add_thread (inferior_pid);
d724 1
a724 1
		  add_thread (lp->pid);
d726 1
a726 1
				     target_pid_to_str (lp->pid));
d735 1
a735 1
	      if (in_thread_list (lp->pid))
d739 2
a740 2
		  if (lp->pid != inferior_pid)
		    delete_thread (lp->pid);
d742 1
a742 1
				     target_pid_to_str (lp->pid));
d747 1
a747 1
				    target_pid_to_str (lp->pid));
d749 1
a749 1
	      delete_lwp (lp->pid);
d767 1
a767 1
				    target_pid_to_str (lp->pid));
d772 2
a773 1
	      child_resume (GET_LWP (lp->pid), lp->step, TARGET_SIGNAL_0);
d818 1
a818 1
	  child_resume (GET_LWP (lp->pid), lp->step, signo);
d839 1
a839 1
    trap_pid = (threaded ? lp->pid : GET_LWP (lp->pid));
d841 1
a841 1
    trap_pid = 0;
d844 1
a844 1
  return (threaded ? lp->pid : GET_LWP (lp->pid));
d850 1
a850 1
  ptrace (PTRACE_KILL, GET_LWP (lp->pid), 0, 0);
d866 1
a866 1
  if (is_cloned (lp->pid))
d870 1
a870 1
	  pid = waitpid (GET_LWP (lp->pid), NULL, __WCLONE);
d872 1
a872 1
      while (pid == GET_LWP (lp->pid));
d879 1
a879 1
      pid = waitpid (GET_LWP (lp->pid), NULL, 0);
d881 1
a881 1
  while (pid == GET_LWP (lp->pid));
d921 1
a921 1
  trap_pid = 0;
d938 1
a938 1
  struct cleanup *old_chain = save_inferior_pid ();
d940 2
a941 2
  if (is_lwp (inferior_pid))
    inferior_pid = GET_LWP (inferior_pid);
d951 1
a951 1
  struct cleanup *old_chain = save_inferior_pid ();
d953 2
a954 2
  if (is_lwp (inferior_pid))
    inferior_pid = GET_LWP (inferior_pid);
d966 1
a966 1
  struct cleanup *old_chain = save_inferior_pid ();
d969 2
a970 2
  if (is_lwp (inferior_pid))
    inferior_pid = GET_LWP (inferior_pid);
d979 1
a979 1
lin_lwp_thread_alive (int pid)
d981 1
a981 1
  gdb_assert (is_lwp (pid));
d984 1
a984 1
  ptrace (PTRACE_PEEKUSER, GET_LWP (pid), 0, 0);
d992 1
a992 1
lin_lwp_pid_to_str (int pid)
d996 1
a996 1
  if (is_lwp (pid))
d998 1
a998 1
      snprintf (buf, sizeof (buf), "LWP %d", GET_LWP (pid));
d1002 1
a1002 1
  return normal_pid_to_str (pid);
@


1.12
log
@2001-04-30  Michael Snyder  <msnyder@@redhat.com>

	* thread-db.c: Revert 2001-04-26 change for debugging output.
	* lin-lwp.c: Ditto.
	* lin-lwp.c: Add set/show debug lin-lwp command.  Use this
	command to turn extra debugging output on / off.
@
text
@d523 2
a524 1
	    printf ("%s exited.\n", target_pid_to_str (lp->pid));
d553 4
a556 3
		printf ("Tripped breakpoint at %lx in LWP %d"
			" while waiting for SIGSTOP.\n",
			(long) read_pc_pid (lp->pid), pid);
d565 3
a567 2
		printf ("Received %s in LWP %d while waiting for SIGSTOP.\n",
			strsignal (WSTOPSIG (status)), pid);
d626 3
a628 2
	    printf ("Using pending wait status for LWP %d.\n",
		    GET_LWP (lp->pid));
d642 2
a643 1
	printf ("Waiting for specific LWP %d.\n", GET_LWP (pid));
d653 3
a655 2
	  printf ("Using pending wait status for LWP %d.\n",
		  GET_LWP (lp->pid));
d734 3
a736 1
		printf ("%s exited.\n", target_pid_to_str (lp->pid));
d754 3
a756 2
		printf ("Delayed SIGSTOP caught for %s.\n",
			target_pid_to_str (lp->pid));
@


1.11
log
@2001-04-30  Michael Snyder  <msnyder@@redhat.com>

	* thread-db.c: Revert 2001-04-26 change for debugging output.
	* lin-lwp.c:   Ditto.
@
text
@d33 1
d35 1
a35 3
#define DEBUG 1

#if DEBUG
a36 1
#endif
d522 3
a524 3
#if DEBUG
	  printf ("%s exited.\n", target_pid_to_str (lp->pid));
#endif
d550 6
a555 5
#if DEBUG
	      printf ("Tripped breakpoint at %lx in LWP %d"
		      " while waiting for SIGSTOP.\n",
		      (long) read_pc_pid (lp->pid), pid);
#endif
d562 4
a565 4
#if DEBUG
	      printf ("Received %s in LWP %d while waiting for SIGSTOP.\n",
		      strsignal (WSTOPSIG (status)), pid);
#endif
d622 4
a625 4
#if DEBUG
	  printf ("Using pending wait status for LWP %d.\n",
		  GET_LWP (lp->pid));
#endif
d637 3
a639 3
#if DEBUG
      printf ("Waiting for specific LWP %d.\n", GET_LWP (pid));
#endif
d645 3
a647 2
#if DEBUG
      if (status)
a649 1
#endif
d727 3
a729 3
#if DEBUG
	      printf ("%s exited.\n", target_pid_to_str (lp->pid));
#endif
d745 4
a748 4
#if DEBUG
	      printf ("Delayed SIGSTOP caught for %s.\n",
		      target_pid_to_str (lp->pid));
#endif
d1042 7
@


1.10
log
@2001-04-26  Michael Snyder  <msnyder@@redhat.com>

	* thread-db.c (_initialize_thread_db): Add set/show command
	"debug-linux-threads" for debugging output.
	* lin-lwp.c (various): Use global "debug_linux_threads to
	turn on extra debugging output.
@
text
@d34 3
a36 1
extern int debug_linux_threads;
d38 1
d524 3
a526 3
	  if (debug_linux_threads)
	    printf ("%s exited.\n", target_pid_to_str (lp->pid));

d552 5
a556 6

	      if (debug_linux_threads)
		printf ("Tripped breakpoint at %lx in LWP %d"
			" while waiting for SIGSTOP.\n",
			(long) read_pc_pid (lp->pid), pid);

d563 4
a566 3
	      if (debug_linux_threads)
		printf ("Received %s in LWP %d while waiting for SIGSTOP.\n",
			strsignal (WSTOPSIG (status)), pid);
d623 4
a626 3
	  if (debug_linux_threads)
	    printf ("Using pending wait status for LWP %d.\n",
		    GET_LWP (lp->pid));
d638 3
a640 3
      if (debug_linux_threads)
	printf ("Waiting for specific LWP %d.\n", GET_LWP (pid));

d646 2
a647 2
      if (debug_linux_threads)
	if (status)
d650 1
d728 3
a730 3
	      if (debug_linux_threads)
		printf ("%s exited.\n", target_pid_to_str (lp->pid));

d746 4
a749 4
	      if (debug_linux_threads)
		printf ("Delayed SIGSTOP caught for %s.\n",
			target_pid_to_str (lp->pid));

@


1.9
log
@2001-04-26  Michael Snyder  <msnyder@@redhat.com>

	* lin-lwp.c: Minor cleanups in comments.
@
text
@d34 1
a34 3
#define DEBUG 1

#if DEBUG
a35 1
#endif
d521 3
a523 3
#if DEBUG
	  printf ("%s exited.\n", target_pid_to_str (lp->pid));
#endif
d549 6
a554 5
#if DEBUG
	      printf ("Tripped breakpoint at %lx in LWP %d"
		      " while waiting for SIGSTOP.\n",
		      (long) read_pc_pid (lp->pid), pid);
#endif
d561 3
a563 4
#if DEBUG
	      printf ("Received %s in LWP %d while waiting for SIGSTOP.\n",
		      strsignal (WSTOPSIG (status)), pid);
#endif
d620 3
a622 4
#if DEBUG
	  printf ("Using pending wait status for LWP %d.\n",
		  GET_LWP (lp->pid));
#endif
d634 3
a636 3
#if DEBUG
      printf ("Waiting for specific LWP %d.\n", GET_LWP (pid));
#endif
d642 2
a643 2
#if DEBUG
      if (status)
a645 1
#endif
d723 3
a725 3
#if DEBUG
	      printf ("%s exited.\n", target_pid_to_str (lp->pid));
#endif
d741 4
a744 4
#if DEBUG
	      printf ("Delayed SIGSTOP caught for %s.\n",
		      target_pid_to_str (lp->pid));
#endif
@


1.8
log
@2001-04-06  David Smith  <dsmith@@redhat.com>

	* arch-utils.c (default_prepare_to_proceed)
	(generic_prepare_to_proceed): Added new functions.
	* arch-utils.h: New function declarations for
	default_prepare_to_proceed() and generic_prepare_to_proceed().
	* gdbarch.sh: Added PREPARE_TO_PROCEED.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* inferior.h: Added get_last_target_status() declaration.
	* infrun.c (get_last_target_status): Added new function.
	(handle_inferior_event): Saves last pid and waitstatus, which will
	get returned by get_last_target_status().

	* hppa-tdep.c (prepare_to_proceed):  Added comment stating that
	prepare_to_proceed() is potentially redundant since
	default_prepare_to_proceed() has been added.
	* linux-thread.c (prepare_to_proceed): Ditto.
	* lin-lwp.c (prepare_to_proceed): Ditto.
	* m3-nat.c (prepare_to_proceed): Ditto.
@
text
@d66 1
a66 1
     debugger, the kernel reassigns it to the origional parent and
d134 1
a134 1
   use the WNOHANG flag and call waitpid in a loop.  To optimize
d138 1
a138 1
   origional signal mask such that we can restore it before creating a
d143 1
a143 1
/* Origional signal mask.  */
d903 1
a903 1
  /* Restore the origional signal mask.  */
d1030 1
a1030 1
  /* Save the origional signal mask.  */
@


1.7
log
@* lin-lwp.c (lin_lwp_resume): Don't mark LWP as not stopped until
we're absolutely sure we're going to resume it.
@
text
@d286 5
a290 1
/* Implementation of the PREPARE_TO_PROCEED hook for the Linux LWP layer.  */
@


1.6
log
@Create new file regcache.h.  Update all uses.
@
text
@a441 4
      /* Mark LWP as not stopped to prevent it from being continued by
	 resume_callback.  */
      lp->stopped = 0;

d454 4
@


1.5
log
@* lin-lwp.c (lin_lwp_xfer_memory): Add attrib argument.
* thread-db.c (thread_db_xfer_memory): Likewise.
@
text
@d2 1
a2 1
   Copyright 2000 Free Software Foundation, Inc.
d32 1
@


1.4
log
@Replace free() with xfree().
@
text
@d938 1
d947 1
a947 1
  xfer = child_xfer_memory (memaddr, myaddr, len, write, target);
@


1.3
log
@* lin-lwp.c (stop_wait_callback): Remove bogus assertions in the
code that deals with exiting/signalled threads.  Replace with
code similar to what's done in lin_lwp_wait.
@
text
@d167 1
a167 1
      free (lp);
d225 1
a225 1
  free (lp);
d271 1
a271 1
  free (arg);
@


1.2
log
@* lin-lwp.c (normal_mask, blocked_mask): New variables.
(lin_lwp_wait): Block SIGCHLD here if it isn't already blocked.
(lin_lwp_mourn_inferior): Restore the origional signal mask, and
reset the mask of blocked signals.
(_initialize_lin_lwp): Don't block SIGCHLD here, but do initialize
suspend_mask and blocked_mask.  This makes us pass
gdb.base/sigall.exp for Linux/x86 now.
(lin_thread_get_thread_signals): Treat the LinuxThreads "cancel"
signal similarly to SIGCHLD in the generic code.  Avoids GDB being
terminated by a Real-time signal.
@
text
@a508 7
	  gdb_assert (! is_cloned (lp->pid));

	  gdb_assert (in_thread_list (lp->pid));
	  if (lp->pid != inferior_pid)
	    delete_thread (lp->pid);
	  printf_unfiltered ("[%s exited]\n",
			     target_pid_to_str (lp->pid));
d510 12
d716 1
a716 1
		  /* Core GDB cannot deal with us deeting the current
@


1.1
log
@* config/i386/nm-linux.h (PREPARE_TO_PROCEED, ATTCH_LWP,
GET_THREAD_SIGNALS): New defines.
* config/i386/linux.mh (NATDEPFILES): Remove lin-thread.o and
linux-threads.o.  Add proc-service.o, thread-db.o and lin-lwp.o.
* proc-service.c: New file.
* thread-db.c: New file.
* lin-lwp.c: New file.
@
text
@d58 5
a62 3
     order to make it report events for any of the cloned processes.
     However, if a cloned process has exited the exit status is only
     reported if the __WCLONE flag is absent.
d131 14
d148 3
d501 1
a501 1
           exit event in lin_lwp_wait.  */
d597 7
d688 2
a689 1
		  gdb_assert (WIFSTOPPED (status) && WSTOPSIG (status) == SIGSTOP);
d893 4
a1011 1
  sigset_t mask;
d1019 3
d1027 3
a1029 4
  /* We block SIGCHLD throughout this code ...  */
  sigemptyset (&mask);
  sigaddset (&mask, SIGCHLD);
  sigprocmask (SIG_BLOCK, &mask, &suspend_mask);
d1031 1
a1031 2
  /* ... except during a sigsuspend.  */
  sigdelset (&suspend_mask, SIGCHLD);
d1064 2
a1065 2
  int restart;
  int cancel;
d1079 17
@

