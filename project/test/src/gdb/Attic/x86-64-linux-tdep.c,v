head	1.28;
access;
symbols
	drow_intercu-20040221-branch:1.25.0.6
	drow_intercu-20040221-branchpoint:1.25
	cagney_bfdfile-20040213-branch:1.25.0.4
	cagney_bfdfile-20040213-branchpoint:1.25
	drow-cplus-merge-20040208:1.25
	carlton_dictionary-20040126-merge:1.25
	cagney_bigcore-20040122-branch:1.25.0.2
	cagney_bigcore-20040122-branchpoint:1.25
	drow-cplus-merge-20040113:1.25
	drow-cplus-merge-20031224:1.24
	drow-cplus-merge-20031220:1.24
	carlton_dictionary-20031215-merge:1.24
	drow-cplus-merge-20031214:1.24
	carlton-dictionary-20031111-merge:1.24
	gdb_6_0-2003-10-04-release:1.19.6.1
	kettenis_sparc-20030918-branch:1.22.0.4
	kettenis_sparc-20030918-branchpoint:1.22
	carlton_dictionary-20030917-merge:1.22
	ezannoni_pie-20030916-branchpoint:1.22
	ezannoni_pie-20030916-branch:1.22.0.2
	cagney_x86i386-20030821-branch:1.20.0.2
	cagney_x86i386-20030821-branchpoint:1.20
	carlton_dictionary-20030805-merge:1.20
	carlton_dictionary-20030627-merge:1.19
	gdb_6_0-branch:1.19.0.6
	gdb_6_0-2003-06-23-branchpoint:1.19
	jimb-ppc64-linux-20030613-branch:1.19.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.19
	cagney_convert-20030606-branch:1.19.0.2
	cagney_convert-20030606-branchpoint:1.19
	cagney_writestrings-20030508-branch:1.17.0.26
	cagney_writestrings-20030508-branchpoint:1.17
	jimb-ppc64-linux-20030528-branch:1.17.0.24
	jimb-ppc64-linux-20030528-branchpoint:1.17
	carlton_dictionary-20030523-merge:1.17
	cagney_fileio-20030521-branch:1.17.0.22
	cagney_fileio-20030521-branchpoint:1.17
	kettenis_i386newframe-20030517-mergepoint:1.17
	jimb-ppc64-linux-20030509-branch:1.17.0.20
	jimb-ppc64-linux-20030509-branchpoint:1.17
	kettenis_i386newframe-20030504-mergepoint:1.17
	carlton_dictionary-20030430-merge:1.17
	kettenis_i386newframe-20030419-branch:1.17.0.18
	kettenis_i386newframe-20030419-branchpoint:1.17
	carlton_dictionary-20030416-merge:1.17
	cagney_frameaddr-20030409-mergepoint:1.17
	kettenis_i386newframe-20030406-branch:1.17.0.16
	kettenis_i386newframe-20030406-branchpoint:1.17
	cagney_frameaddr-20030403-branchpoint:1.17
	cagney_frameaddr-20030403-branch:1.17.0.14
	cagney_framebase-20030330-mergepoint:1.17
	cagney_framebase-20030326-branch:1.17.0.12
	cagney_framebase-20030326-branchpoint:1.17
	cagney_lazyid-20030317-branch:1.17.0.10
	cagney_lazyid-20030317-branchpoint:1.17
	kettenis-i386newframe-20030316-mergepoint:1.17
	offbyone-20030313-branch:1.17.0.8
	offbyone-20030313-branchpoint:1.17
	kettenis-i386newframe-20030308-branch:1.17.0.6
	kettenis-i386newframe-20030308-branchpoint:1.17
	carlton_dictionary-20030305-merge:1.17
	cagney_offbyone-20030303-branch:1.17.0.4
	cagney_offbyone-20030303-branchpoint:1.17
	carlton_dictionary-20030207-merge:1.17
	interps-20030203-mergepoint:1.17
	interps-20030202-branch:1.17.0.2
	interps-20030202-branchpoint:1.17
	cagney-unwind-20030108-branch:1.16.0.2
	cagney-unwind-20030108-branchpoint:1.16
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.7
	carlton_dictionary-20021025-merge:1.7
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.6
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.4
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.2
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.12
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.10
	readline_4_3-import-branchpoint:1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.8
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.6
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.4
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.2
	gdb_5_2-2002-03-03-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.3;
locks; strict;
comment	@ * @;


1.28
date	2004.02.25.20.45.30;	author kettenis;	state dead;
branches;
next	1.27;

1.27
date	2004.02.23.21.37.52;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.22.20.29.48;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.10.12.52.41;	author kettenis;	state Exp;
branches
	1.25.6.1;
next	1.24;

1.24
date	2003.10.31.22.26.29;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.28.13.35.44;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.29.15.31.10;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.23.13.58.18;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.15.11.33.59;	author mludvig;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2003.05.31.16.11.47;	author kettenis;	state Exp;
branches
	1.19.6.1;
next	1.18;

1.18
date	2003.05.31.08.15.38;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches
	1.17.18.1;
next	1.16;

1.16
date	2003.01.09.18.30.32;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.08.15.56.38;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.08.01.53.37;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.06.20.45.30;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.02.22.20.46;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.21.21.09.58;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.09.02.04.16;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.18.22.19.31;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2002.10.26.17.04.37;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.24.01.37.40;	author mludvig;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.24.01.27.43;	author mludvig;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.03.13.06.33;	author mludvig;	state Exp;
branches
	1.5.4.1
	1.5.6.1;
next	1.4;

1.4
date	2002.02.24.22.14.33;	author cagney;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	2001.09.25.10.37.17;	author smid;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.21.22.57.29;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.21.12.19.15;	author smid;	state Exp;
branches;
next	;

1.4.8.1
date	2002.10.01.00.46.15;	author kseitz;	state Exp;
branches;
next	1.4.8.2;

1.4.8.2
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.5.4.1
date	2002.10.25.23.49.55;	author carlton;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2002.11.15.19.19.01;	author carlton;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.12.23.19.38.50;	author carlton;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.02.07.19.17.54;	author carlton;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.06.27.21.50.13;	author carlton;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2003.08.05.17.13.16;	author carlton;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2003.09.17.21.28.36;	author carlton;	state Exp;
branches;
next	1.5.4.8;

1.5.4.8
date	2003.11.11.23.50.59;	author carlton;	state Exp;
branches;
next	1.5.4.9;

1.5.4.9
date	2004.01.26.19.11.35;	author carlton;	state Exp;
branches;
next	;

1.5.6.1
date	2002.10.26.17.12.10;	author drow;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2003.12.14.20.27.34;	author drow;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2004.01.13.16.12.03;	author drow;	state Exp;
branches;
next	;

1.17.18.1
date	2003.05.17.15.09.15;	author kettenis;	state Exp;
branches;
next	1.17.18.2;

1.17.18.2
date	2003.05.28.20.52.03;	author kettenis;	state Exp;
branches;
next	;

1.19.6.1
date	2003.07.15.11.30.58;	author mludvig;	state Exp;
branches;
next	;

1.20.2.1
date	2003.08.21.20.37.30;	author cagney;	state Exp;
branches;
next	;

1.25.6.1
date	2004.03.27.17.37.55;	author drow;	state dead;
branches;
next	;


desc
@@


1.28
log
@* amd64-tdep.h: Renamed from x86-64-tdep.h.
* amd64-tdep.c: Renamed from x86-64-tdep.c.  Include
"amd64-tdep.h" instead of "x86-64-tdep.h".
* amd64-nat.c: Include "amd64-tdep.h" instead of "x86-64-tdep.h".
* amd64-linux-tdep.h: Renamed from x86-64-linux.h.
* amd64-linux-tdep.c: Renamed from x86-64-linux-tdep.c.  Include
"amd64-tdep.h" and "amd64-linux-tdep.h" instead of "x86-64-tdep.h"
and "x86-64-tdep.c".
* amd64-linux-nat.c: Renamed from x86-64-linux-nat.c.  Include
"amd64-tdep.h" and "amd64-linux-tdep.h" instead of "x86-64-tdep.h"
and "x86-64-tdep.c".
* amd64bsd-nat.c: Update copyright year.
Include "amd64-tdep.h" instead of "x86-64-tdep.h".
* amd64fbsd-tdep.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64fbsd-nat.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64nbsd-tdep.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64nbsd-nat.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64obsd-tdep.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64obsd-nat.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* configure.host: (x86_64-*-linux*): Set gdb_target to linux64.
* configure.tgt (x86_64-*-linux*): Set gdb_target to linux64.
* Makefile.in (amd64_linux_tdep_h): Renamed from
x86_64_linux_tdep_h.
(amd64_tdep_h): Renamed from x86_64_tdep_h.
(amd64bsd-nat.o, amd64fbsd-nat.o, amd64fbsd-tdep.o, amd64-nat.o)
(amd64nbsd-nat.o, amd64nbsd-tdep.o, amd64obsd-nat.o)
(amd64obsd-tdep.o): Update dependencies.
(amd64-tdep.o, amd64-linux-nat.o, amd64-linux-tdep.o): New
dependencies.
(x86-64-linux-nat.o, x86-64-linux-tdep.o, x86-64-tdep.o): Remove
dependencies.
(ALLDEPFILES): Add amd64-tdep.c, amd64obsd-nat.c, amd64obsd-nat.c,
amd64-linux-nat.c amd64-linux-tdep.c.
* config/i386/tm-linux64.h: Renamed from tm-x86-64linux.h
* config/i386/nm-linux64.h: Renamed from nm-x86-64linux.h.
* config/i386/linux64.mt: Renamed from x86-64linux.mt.
(TDEPFILES): Replace x86-64-tdep.o and x86-64-linux-tdep.o with
amd64-tdep.o and amd64-linux-tdep.o.
(TM_FILE): Set to tm-linux64.h.
* config/i386/linux64.mh: Renamed from x86-64linux.mh.
(NAT_FILE): Set to nm-linux64.h.
(NATDEPFILES): Replace x86-64-linux-nat.o with amd64-linux-nat.o.
* config/i386/fbsd64.mt (TDEPFILES): Replace x86-64-tdep.o with
amd64-tdep.o.
* config/i386/nbsd64.mt (TDEPFILES): Replace x86-64-tdep.o with
amd64-tdep.o.
* config/i386/obsd64.mt (TDEPFILES): Replace x86-64-tdep.o with
amd64-tdep.o.
@
text
@/* Target-dependent code for GNU/Linux x86-64.

   Copyright 2001, 2003, 2004 Free Software Foundation, Inc.
   Contributed by Jiri Smid, SuSE Labs.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include "gdbcore.h"
#include "regcache.h"
#include "osabi.h"

#include "gdb_string.h"

#include "x86-64-tdep.h"
#include "x86-64-linux-tdep.h"

/* Register indexes to 'struct user' come from <sys/reg.h>.  */

#define USER_R15    0
#define USER_R14    1
#define USER_R13    2
#define USER_R12    3
#define USER_RBP    4
#define USER_RBX    5
#define USER_R11    6
#define USER_R10    7
#define USER_R9     8
#define USER_R8     9
#define USER_RAX    10
#define USER_RCX    11
#define USER_RDX    12
#define USER_RSI    13
#define USER_RDI    14
#define USER_RIP    16
#define USER_CS     17
#define USER_EFLAGS 18
#define USER_RSP    19
#define USER_SS     20
#define USER_DS     23
#define USER_ES     24
#define USER_FS     25
#define USER_GS     26

/* Mapping between the general-purpose registers in `struct user'
   format and GDB's register array layout.  */

static int user_to_gdb_regmap[] =
{
  USER_RAX, USER_RBX, USER_RCX, USER_RDX,
  USER_RSI, USER_RDI, USER_RBP, USER_RSP,
  USER_R8, USER_R9, USER_R10, USER_R11,
  USER_R12, USER_R13, USER_R14, USER_R15,
  USER_RIP, USER_EFLAGS,
  USER_CS, USER_SS,
  USER_DS, USER_ES, USER_FS, USER_GS
};

/* Fill GDB's register array with the general-purpose register values
   in *GREGSETP.  */

void
amd64_linux_supply_gregset (char *regp)
{
  int i;

  for (i = 0; i < AMD64_NUM_GREGS; i++)
    supply_register (i, regp + (user_to_gdb_regmap[i] * 8));
}

/* Fill register REGNO (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */

void
amd64_linux_fill_gregset (char *regp, int regno)
{
  int i;

  for (i = 0; i < AMD64_NUM_GREGS; i++)
    if (regno == -1 || regno == i)
      regcache_collect (i, regp + (user_to_gdb_regmap[i] * 8));
}

/* The register sets used in GNU/Linux ELF core-dumps are identical to
   the register sets used by `ptrace'.  The corresponding types are
   `elf_gregset_t' for the general-purpose registers (with
   `elf_greg_t' the type of a single GP register) and `elf_fpregset_t'
   for the floating-point registers.  */

static void
fetch_core_registers (char *core_reg_sect, unsigned core_reg_size,
			 int which, CORE_ADDR ignore)
{
  switch (which)
    {
    case 0:  /* Integer registers.  */
      if (core_reg_size != 216)
	warning ("Wrong size register set in core file.");
      else
	amd64_linux_supply_gregset (core_reg_sect);
      break;

    case 2:  /* Floating point registers.  */
    case 3:  /* "Extended" floating point registers.  This is gdb-speak
		for SSE/SSE2. */
      if (core_reg_size != 512)
	warning ("Wrong size XMM register set in core file.");
      else
	amd64_supply_fxsave (current_regcache, -1, core_reg_sect);
      break;

    default:
      /* Don't know what kind of register request this is; just ignore it.  */
      break;
    }
}

static struct core_fns amd64_core_fns = 
{
  bfd_target_elf_flavour,		/* core_flavour */
  default_check_format,			/* check_format */
  default_core_sniffer,			/* core_sniffer */
  fetch_core_registers,			/* core_read_registers */
  NULL					/* next */
};

#define LINUX_SIGTRAMP_INSN0	0x48	/* mov $NNNNNNNN, %rax */
#define LINUX_SIGTRAMP_OFFSET0	0
#define LINUX_SIGTRAMP_INSN1	0x0f	/* syscall */
#define LINUX_SIGTRAMP_OFFSET1	7

static const unsigned char linux_sigtramp_code[] =
{
  /* mov $__NR_rt_sigreturn, %rax */
  LINUX_SIGTRAMP_INSN0, 0xc7, 0xc0, 0x0f, 0x00, 0x00, 0x00,
  /* syscall */
  LINUX_SIGTRAMP_INSN1, 0x05
};

#define LINUX_SIGTRAMP_LEN (sizeof linux_sigtramp_code)

/* If PC is in a sigtramp routine, return the address of the start of
   the routine.  Otherwise, return 0.  */

static CORE_ADDR
amd64_linux_sigtramp_start (CORE_ADDR pc)
{
  unsigned char buf[LINUX_SIGTRAMP_LEN];

  /* We only recognize a signal trampoline if PC is at the start of
     one of the two instructions.  We optimize for finding the PC at
     the start, as will be the case when the trampoline is not the
     first frame on the stack.  We assume that in the case where the
     PC is not at the start of the instruction sequence, there will be
     a few trailing readable bytes on the stack.  */

  if (read_memory_nobpt (pc, (char *) buf, LINUX_SIGTRAMP_LEN) != 0)
    return 0;

  if (buf[0] != LINUX_SIGTRAMP_INSN0)
    {
      if (buf[0] != LINUX_SIGTRAMP_INSN1)
	return 0;

      pc -= LINUX_SIGTRAMP_OFFSET1;

      if (read_memory_nobpt (pc, (char *) buf, LINUX_SIGTRAMP_LEN) != 0)
	return 0;
    }

  if (memcmp (buf, linux_sigtramp_code, LINUX_SIGTRAMP_LEN) != 0)
    return 0;

  return pc;
}

/* Return whether PC is in a GNU/Linux sigtramp routine.  */

static int
amd64_linux_pc_in_sigtramp (CORE_ADDR pc, char *name)
{
  /* If we have NAME, we can optimize the search.  The trampoline is
     named __restore_rt.  However, it isn't dynamically exported from
     the shared C library, so the trampoline may appear to be part of
     the preceding function.  This should always be sigaction,
     __sigaction, or __libc_sigaction (all aliases to the same
     function).  */
  if (name == NULL || strstr (name, "sigaction") != NULL)
    return (amd64_linux_sigtramp_start (pc) != 0);

  return (strcmp ("__restore_rt", name) == 0);
}

/* Offset to struct sigcontext in ucontext, from <asm/ucontext.h>.  */
#define AMD64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET 40

/* Assuming NEXT_FRAME is a frame following a GNU/Linux sigtramp
   routine, return the address of the associated sigcontext structure.  */

static CORE_ADDR
amd64_linux_sigcontext_addr (struct frame_info *next_frame)
{
  CORE_ADDR sp;
  char buf[8];

  frame_unwind_register (next_frame, SP_REGNUM, buf);
  sp = extract_unsigned_integer (buf, 8);

  /* The sigcontext structure is part of the user context.  A pointer
     to the user context is passed as the third argument to the signal
     handler, i.e. in %rdx.  Unfortunately %rdx isn't preserved across
     function calls so we can't use it.  Fortunately the user context
     is part of the signal frame and the unwound %rsp directly points
     at it.  */
  return sp + AMD64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
}


/* From <asm/sigcontext.h>.  */
static int amd64_linux_sc_reg_offset[] =
{
  13 * 8,			/* %rax */
  11 * 8,			/* %rbx */
  14 * 8,			/* %rcx */
  12 * 8,			/* %rdx */
  9 * 8,			/* %rsi */
  8 * 8,			/* %rdi */
  10 * 8,			/* %rbp */
  15 * 8,			/* %rsp */
  0 * 8,			/* %r8 */
  1 * 8,			/* %r9 */
  2 * 8,			/* %r10 */
  3 * 8,			/* %r11 */
  4 * 8,			/* %r12 */
  5 * 8,			/* %r13 */
  6 * 8,			/* %r14 */
  7 * 8,			/* %r15 */
  16 * 8,			/* %rip */
  17 * 8,			/* %eflags */

  /* FIXME: kettenis/2002030531: The registers %cs, %fs and %gs are
     available in `struct sigcontext'.  However, they only occupy two
     bytes instead of four, which makes using them here rather
     difficult.  Leave them out for now.  */
  -1,				/* %cs */
  -1,				/* %ss */
  -1,				/* %ds */
  -1,				/* %es */
  -1,				/* %fs */
  -1				/* %gs */
};

static void
amd64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  amd64_init_abi (info, gdbarch);

  set_gdbarch_pc_in_sigtramp (gdbarch, amd64_linux_pc_in_sigtramp);

  tdep->sigcontext_addr = amd64_linux_sigcontext_addr;
  tdep->sc_reg_offset = amd64_linux_sc_reg_offset;
  tdep->sc_num_regs = ARRAY_SIZE (amd64_linux_sc_reg_offset);
}


/* Provide a prototype to silence -Wmissing-prototypes.  */
extern void _initialize_amd64_linux_tdep (void);

void
_initialize_amd64_linux_tdep (void)
{
  add_core_fns (&amd64_core_fns);

  gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64,
			  GDB_OSABI_LINUX, amd64_linux_init_abi);
}
@


1.27
log
@* x86-64-tdep.h: Tewak comment.
(enum amd64_regnum): New.
(X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, X86_64_RDI_REGNUM)
(X86_64_RBP_REGNUM, X86_64_RSP_REGNUM, X86_64_RIP_REGNUM)
(X86_64_EFLAGS_REGNUM, X86_64_ST0_REGNUM, X86_64_XMM0_REGNUM)
(X86_64_XMM1_REGNUM): Removed.
(AMD64_NUM_GREGS): Renamed from X86_64_NUM_GREGS.
(amd64_init_abi, amd64_supply_fxsave, amd64_fill_fxsave): Adjust
prototypes for renamed functions.
* x86-64-tdep.c: Fix typo.
(amd64_dwarf_regmap): Use constants from `enum amd64_regnum' for
register numbers.
(amd64_return_value, amd64_push_arguments, amd64_push_dummy_call):
Use constants from `enum amd64_regnum' for register numbers.
(AMD64_NUM_SAVED_REGS): Adjust for renamed macros.
(amd64_analyze_prologue, amd64_frame_cache,
amd64_sigtramp_frame_cache): Use constants from `enum
amd64_regnum' for register numbers.
(amd64_supply_fpregset): Adjust for renamed functions.
(amd64_init_abi): Rename from x86_64_init_abi.  Use constants from
`enum amd64_regnum' for register numbers.
(I387_ST0_REGNUM): Use constant from `enum amd64_regnum'.
(amd64_supply_fxsave): Rename from x86_64_supply_fxsave.
(amd64_fill_fxsave): Rename fro x86_64_fill_fxsave.
* x86-64-linux-tdep.c (amd64_linux_supply_gregset)
(amd64_linux_fill_gregset): Adjust for renamed macros.
(fetch_core_registers): Adjust for renamed functions.
(amd64_linux_init_abi): Adjust for renamed functions.
* x86-64-linux-nat.c (supply_gregset, fill_gregset): Adjust for
renamed functions.
* amd64-nat.c: Adjust for renamed macros.
* amd64bsd-nat.c (fetch_inferior_registers)
(store_inferior_registers): Use constants from `enum amd64_regnum'
for register numbers.  Adjust for renamed variables.
* amd64fbsd-nat.c (supply_gregset, fill_gregset): Adjust for
renamed variables.
(_initialize_amd64fbsd_nat): Use constants from `enum
amd64_regnum' for register numbers.
* amd64fbsd-tdep.c (amd64fbsd_sigcontext_addr): Use constants from
`enum amd64_regnum' for register numbers.
(amd64fbsd_init_abi): Adjust for renamed functions.
* amd64nbsd-tdep.c (amd64nbsd_sigcontext_addr): Use constants from
`enum amd64_regnum' for register numbers.
(amd64nbsd_init_abi): Adjust for renamed functions.
(_initialize_amd64nbsd_ndep): Adjust for renamed macros.
* amd64obsd-tdep.c (amd64obsd_sigcontext_addr): Use constants from
`enum amd64_regnum' for register numbers.
(amd64obsd_init_abi): Adjust for renamed functions.
(_initialize_amd64obsd_ndep): Adjust for renamed macros.
@
text
@@


1.26
log
@* x86-64-linux-tdep.c: Tweak comment.
(amd64_linux_supply_gregset): Renamed from
x86_64_linux_supply_gresget.
(amd64_linux_fill_gregset): Renamed from
x86_64_linux_fill_gregset.
(fetch_core_registers): Adjust for renamed functions.
(amd64_core_fns): Renamed from x86_64_core_fns.
(amd64_linux_sigtramp_start): Renamed from
x86_64_linux_sigtramp_start.
(amd64_linux_pc_in_sigtramp): Renamed from
x86_64_linux_pc_in_sigtramp.  Adjust for renamed functions.
(AMD64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET): Renamed from
X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET.
(amd64_linux_sigcontext_addr): Renamed from
x86_64_linux_sigcontext_addr.
(amd64_linux_sc_reg_offset): Renamed from
x86_64_linux_sc_reg_offset.
(amd64_linux_init_abi): Renamed from x86_64_linux_init_abi.
Adjust for renamed functions and variables.
(_initialize_amd64_linux_tdep): Renamed from
_initialize_x86_64_linux_tdep.  Adjust for renamed functions and
variables.
* x86-64-linux-tdep.h: Update copyright year.  Tweak comment.
Adjust for renamed functions.
@
text
@d83 1
a83 1
  for (i = 0; i < X86_64_NUM_GREGS; i++)
d96 1
a96 1
  for (i = 0; i < X86_64_NUM_GREGS; i++)
d126 1
a126 1
	x86_64_supply_fxsave (current_regcache, -1, core_reg_sect);
d274 1
a274 1
  x86_64_init_abi (info, gdbarch);
@


1.25
log
@* x86-64-tdep.c (amd64_register_info): Add %cs and %ss.  Adjust
register numbers in comments.
* x86-64-tdep.h: Update copyright year.
(X86_64_ST0_REGNUM, X86_64_XMM0_REGNUM, X86_64_XMM1_REGNUM):
Adjust for addition of %cs and %ss.
* amd64fbsd-nat.c: Update copyright year.
(reg_offset): Add register offsets for %cs and %ss.
* amd64fbsd-tdep.c: Update copyright year.
(amd64fbsd_r_reg_offset): Add register offsets for %cs and %ss.
(amd64fbsd_sc_reg_offset): Likewise.
* x86-64-linux-nat.c: Update copyright year.
(x86_64_linux_gregset64_reg_offset): Add register offsets for %cs
and %ss.
* amd64nbsd-nat.c: Update copyright year.
(amd64nbsd32_r_reg_offset): Add register offsets for %cs and %ss.
* amd64nbsd-tdep.c: Update copyright year.
(amd64nbsd_r_reg_offset): Add register offsets for %cs and %ss.
* x86-64-linux-tdep.c: Update copyright year.
(user_to_gdb_regmap): Add mapping for %cs and %ss.
(x86_64_linux_sc_reg_offset): Adjust for addition of %cs and %ss.
* regformats/reg-x86-64.dat: Add %cs and %ss.
@
text
@d1 1
a1 1
/* Target-dependent code for GNU/Linux running on x86-64, for GDB.
d79 1
a79 1
x86_64_linux_supply_gregset (char *regp)
d92 1
a92 1
x86_64_linux_fill_gregset (char *regp, int regno)
d117 1
a117 1
	x86_64_linux_supply_gregset (core_reg_sect);
d135 1
a135 1
static struct core_fns x86_64_core_fns = 
d163 1
a163 1
x86_64_linux_sigtramp_start (CORE_ADDR pc)
d197 1
a197 1
x86_64_linux_pc_in_sigtramp (CORE_ADDR pc, char *name)
d206 1
a206 1
    return (x86_64_linux_sigtramp_start (pc) != 0);
d212 1
a212 1
#define X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET 40
d218 1
a218 1
x86_64_linux_sigcontext_addr (struct frame_info *next_frame)
d232 1
a232 1
  return sp + X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
d237 1
a237 1
static int x86_64_linux_sc_reg_offset[] =
d271 1
a271 1
x86_64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d276 1
a276 1
  set_gdbarch_pc_in_sigtramp (gdbarch, x86_64_linux_pc_in_sigtramp);
d278 3
a280 3
  tdep->sigcontext_addr = x86_64_linux_sigcontext_addr;
  tdep->sc_reg_offset = x86_64_linux_sc_reg_offset;
  tdep->sc_num_regs = ARRAY_SIZE (x86_64_linux_sc_reg_offset);
d285 1
a285 1
extern void _initialize_x86_64_linux_tdep (void);
d288 1
a288 1
_initialize_x86_64_linux_tdep (void)
d290 1
a290 1
  add_core_fns (&x86_64_core_fns);
d292 2
a293 2
  gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64, GDB_OSABI_LINUX,
			  x86_64_linux_init_abi);
@


1.25.6.1
log
@Merge mainline to intercu branch.
@
text
@@


1.24
log
@* x86-64-linux-tdep.c (x86_64_linux_sc_reg_offset): Don't
explicitly specify size of array.
(x86_64_linux_init_abi): Use ARRAY_SIZE to initialize
TDEP->sc_num_regs.
@
text
@d3 1
a3 2
   Copyright 2001, 2003 Free Software Foundation, Inc.

d71 1
a256 2
  -1,				/* %ds */
  -1,				/* %es */
d258 1
a258 1
  /* FIXME: kettenis/2002030531: The registers %fs and %gs are
d262 4
@


1.23
log
@* i387-tdep.c (i387_supply_fsave, i387_supply_fxsave): Add
regcache argument and reverse the order of the other two
arguments.  Remove local regcache variable.  Determine
architecture from REGCACHE.  Update comments.
* x86-64-tdep.c (x86_64_supply_fxsave): Add regcache argument and
reverse the order of the other two arguments.  Remove local
regcache variable.  Determine architecture from REGCACHE.  Update
comments.
* i387-tdep.h (i387_supply_fsave, i387_supply_fxsave): Adjust
prototypes.  Update comments.
* x86-64-tdep.c (x86_64_supply_fxsave): Adjust prototype.  Adjust
comment.
* amd64fbsd-nat.c (supply_fpregset, fetch_inferior_registers):
Update.
* go32-nat.c (fetch_register, go32_fetch_registers): Update.
* i386-interix-nat.c (supply_fpregset): Update.
* i386-linux-nat.c (supply_fpregset, supply_fpxregset): Update.
* i386-nto-tdep.c (i386nto_supply_fpregset): Update.
* i386gnu-nat.c (fetch_fpregs, supply_fpregset): Update.
* i386bsd-nat.c (supply_fpregset, fetch_inferior_registers): Update.
* i386nbsd-tdep.c (fetch_core_registers, fetch_elfcore_registers):
Update.
* i386obsd-tdep.c (fetch_core_registers): Update.
* i386v4-nat.c (supply_fpregset): Update.
* x86-64-linux-nat.c (supply_fpregset): Update.
* x86-64-linux-tdep.c (fetch_core_registers): Update.
@
text
@d237 1
a237 1
static int x86_64_linux_sc_reg_offset[X86_64_NUM_GREGS] =
d278 1
a278 1
  tdep->sc_num_regs = X86_64_NUM_GREGS;
@


1.22
log
@* x86-64-linux-tdep.c (user_to_gdb_regmap): Remove USER_CS and
USER_DS.  We haven't given them a register number yet.
@
text
@d126 1
a126 1
	x86_64_supply_fxsave (core_reg_sect, -1);
@


1.21
log
@* x86-64-tdep.c (x86_64_supply_fxsave): Add `regnum' argument.
Update comments.
* x86-64-tdep.h (x86_64_supply_fxsave): Adjust prototype.  Update
comments.
* x86-64-linux-tdep.c (fetch_core_registers): Adjust call to
x86_64_supply_fxsave.
* x86-64-linux-nat.c (supply_fpregset): Adjust call to
x86_64_supply_fxsave.
* amd64fbsd-nat.c (supply_fpregset): Adjust call to
x86_64_supply_fxsave.
@
text
@d71 1
a71 1
  USER_RIP, USER_EFLAGS, USER_CS, USER_SS,
@


1.20
log
@2003-07-15  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-linux-nat.c (regmap): Removed.
	(supply_gregset, fill_gregset): Call
	x86_64_linux_(fill,supply)_gregset functions.
	* x86-64-linux-tdep.c (USER_*): New defines.
	(user_to_gdb_regmap, x86_64_core_fns): New structure.
	(x86_64_linux_supply_gregset, x86_64_linux_fill_gregset):
	New functions.
	(fetch_core_registers): Ditto.
	(_initialize_x86_64_linux_tdep): Call add_core_fns().
	* x86-64-linux-tdep.h: New file.
	* config/i386/x86-64linux.mh (NATDEPFILES): Remove corelow.o
	and core-regset.o.
	* config/i386/x86-64linux.mt (TDEPFILES): Add corelow.o.
@
text
@d126 1
a126 1
	x86_64_supply_fxsave (core_reg_sect);
@


1.20.2.1
log
@2003-08-21  Andrew Cagney  <cagney@@redhat.com>

	* x86-64-tdep.h (enum x86_64_regnums): Replace #define of
	X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, X86_64_RDI_REGNUM,
	X86_64_RBP_REGNUM, X86_64_RSP_REGNUM, X86_64_RIP_REGNUM,
	X86_64_EFLAGS_REGNUM, X86_64_ST0_REGNUM, X86_64_XMM0_REGNUM,
	X86_64_XMM1_REGNUM.
	* x86-64-linux-tdep.h (x86_64_linux_greg_offset): Declare.
	(x86_64_linux_supply_gregset): Add "sizeof_gregs" param.
	(x86_64_linux_fill_gregset): Add "sizeof_gregs" param.
	* x86-64-linux-tdep.c: Include "gdb_assert.h" and
	"i386-linux-tdep.h".
	(enum user_regs): Replace user reg #defines, add USER_ORIG_RAX,
	USER_FS_BASE and USER_GS_BASE.
	(struct regnum_map, struct regnum_to_user): Define.
	(x86_64_linux_greg_offset): New function.
	(user_to_gdb_regmap): Delete.
	(x86_64_linux_supply_gregset, x86_64_linux_fill_gregset): Use
	x86_64_linux_greg_offset.
	(x86_64_core_sniffer): New function
	(x86_64_core_fns): Set the sniffer to x86_64_core_sniffer.
	(fetch_core_registers): Pass "core_reg_size" to the supply
	functions.
	* x86-64-linux-nat.c (GETREGS_SUPPLIES): Delete macro.
	(fetch_inferior_registers): Use x86_64_linux_greg_offset.
	(store_inferior_registers): Ditto.
	* Makefile.in (x86-64-linux-tdep.o): Update dependencies.
@
text
@a30 1
#include "gdb_assert.h"
a33 1
#include "i386-linux-tdep.h"	/* For I386_LINUX_ORIG_EAX_REGNUM.  */
d37 36
a72 45
enum user_regs
{
  USER_R15,
  USER_R14,
  USER_R13,
  USER_R12,
  USER_RBP,
  USER_RBX,
  USER_R11,
  USER_R10,
  USER_R9,
  USER_R8,
  USER_RAX,
  USER_RCX,
  USER_RDX,
  USER_RSI,
  USER_RDI,
  USER_ORIG_RAX,
  USER_RIP,
  USER_CS,
  USER_EFLAGS,
  USER_RSP,
  USER_SS,
  USER_FS_BASE,
  USER_GS_BASE,
  USER_DS,
  USER_ES,
  USER_FS,
  USER_GS,
  USER_MAX
};

/* Map from GDB's i386/x86-64 REGNUM indexed general-purpose registers
   to a `struct user' array of registers..  */

struct regnum_map
{
  int regnum;
  int user;
};

struct regnum_to_user
{
  long nr;
  const struct regnum_map *map;
a74 112
long
x86_64_linux_greg_offset (int regnum)
{
  const static struct regnum_map i386_regnum_map[] =
  {
    { I386_EAX_REGNUM, USER_RAX },
    { I386_ECX_REGNUM, USER_RCX },
    { I386_EDX_REGNUM, USER_RDX },
    { I386_EBX_REGNUM, USER_RBX },
    { I386_ESP_REGNUM, USER_RSP },
    { I386_EBP_REGNUM, USER_RBP },
    { I386_ESI_REGNUM, USER_RSI },
    { I386_EDI_REGNUM, USER_RDI },
    { I386_EIP_REGNUM, USER_RIP },
    { I386_EFLAGS_REGNUM, USER_EFLAGS },
    { I386_CS_REGNUM, USER_CS },
    { I386_SS_REGNUM, USER_SS },
    { I386_DS_REGNUM, USER_DS },
    { I386_ES_REGNUM, USER_ES },
    { I386_FS_REGNUM, USER_FS },
    { I386_GS_REGNUM, USER_GS },
    { I386_ST0_REGNUM, -1 },
    { I386_ST1_REGNUM, -1 },
    { I386_ST2_REGNUM, -1 },
    { I386_ST3_REGNUM, -1 },
    { I386_ST4_REGNUM, -1 },
    { I386_ST5_REGNUM, -1 },
    { I386_ST6_REGNUM, -1 },
    { I386_ST7_REGNUM, -1 },
    { I386_FCTRL_REGNUM, -1 },
    { I386_FSTAT_REGNUM, -1 },
    { I386_FTAG_REGNUM, -1 },
    { I386_FISEG_REGNUM, -1 },
    { I386_FIOFF_REGNUM, -1 },
    { I386_FOSEG_REGNUM, -1 },
    { I386_FOOFF_REGNUM, -1 },
    { I386_FOP_REGNUM, -1 },
    { I386_XMM0_REGNUM, -1 },
    { I386_XMM1_REGNUM, -1 },
    { I386_XMM2_REGNUM, -1 },
    { I386_XMM3_REGNUM, -1 },
    { I386_XMM4_REGNUM, -1 },
    { I386_XMM5_REGNUM, -1 },
    { I386_XMM6_REGNUM, -1 },
    { I386_XMM7_REGNUM, -1 },
    { I386_MXCSR_REGNUM, -1 },
    { I386_LINUX_ORIG_EAX_REGNUM, USER_ORIG_RAX },
  };
  const static struct regnum_to_user i386_regnum_to_user =
  {
    ARRAY_SIZE (i386_regnum_map), i386_regnum_map
  };
  const static struct regnum_map x86_64_regnum_map[] =
  {
    { X86_64_RAX_REGNUM, USER_RAX },
    { X86_64_RBX_REGNUM, USER_RBX },
    { X86_64_RCX_REGNUM, USER_RCX },
    { X86_64_RDX_REGNUM, USER_RDX },
    { X86_64_RSI_REGNUM, USER_RSI },
    { X86_64_RDI_REGNUM, USER_RDI },
    { X86_64_RBP_REGNUM, USER_RBP },
    { X86_64_RSP_REGNUM, USER_RSP },
    { X86_64_R8_REGNUM, USER_R8 },
    { X86_64_R9_REGNUM, USER_R9 },
    { X86_64_R10_REGNUM, USER_R10 },
    { X86_64_R11_REGNUM, USER_R11 },
    { X86_64_R12_REGNUM, USER_R12 },
    { X86_64_R13_REGNUM, USER_R13 },
    { X86_64_R14_REGNUM, USER_R14 },
    { X86_64_R15_REGNUM, USER_R15 },
    { X86_64_RIP_REGNUM, USER_RIP },
    { X86_64_EFLAGS_REGNUM, USER_EFLAGS },
    /* { X86_64_CS_REGNUM, USER_CS }, */
    /* { X86_64_SS_REGNUM, USER_SS }, */
    { X86_64_DS_REGNUM, USER_DS },
    { X86_64_ES_REGNUM, USER_ES },
    { X86_64_FS_REGNUM, USER_FS },
    { X86_64_GS_REGNUM, USER_GS },
  };
  const static struct regnum_to_user x86_64_regnum_to_user =
  {
    ARRAY_SIZE (x86_64_regnum_map), x86_64_regnum_map
  };
  const struct regnum_to_user *regnum_to_user;

  gdb_assert (TARGET_ARCHITECTURE->arch == bfd_arch_i386);
  switch (TARGET_ARCHITECTURE->mach)
    {
    case bfd_mach_i386_i386:
    case bfd_mach_i386_i386_intel_syntax:
      regnum_to_user = &i386_regnum_to_user;
      break;
    case bfd_mach_x86_64:
    case bfd_mach_x86_64_intel_syntax:
      regnum_to_user = &x86_64_regnum_to_user;
      break;
    case bfd_mach_i386_i8086:
      /* Better suggestion?  */
      return -1;
    default:
      internal_error (__FILE__, __LINE__, "bad_switch");
    }
  if (regnum < 0)
    return USER_MAX * 8;
  if (regnum >= regnum_to_user->nr)
    return -1;
  gdb_assert (regnum_to_user->map[regnum].regnum == regnum);
  if (regnum_to_user->map[regnum].user < 0)
    return -1;
  return regnum_to_user->map[regnum].user * 8;
}

a81 2
  char buf[MAX_REGISTER_SIZE];
  int bad = 0;
d83 2
a84 6
  for (i = 0; i < NUM_REGS; i++)
    {
      long offset = x86_64_linux_greg_offset (i);
      if (offset >= 0)
	supply_register (i, regp + offset);
    }
d96 1
a96 1
  for (i = 0; i < NUM_REGS; i++)
d98 1
a98 12
      {
	long offset = x86_64_linux_greg_offset (i);
	if (offset >= 0)
	  {
	    char buf[MAX_REGISTER_SIZE];
	    memset (buf, 0, sizeof buf);
	    /* Assume little endian - LHS of buffer is the correct
               place to put the collected bytes.  */
	    regcache_collect (i, buf);
	    memcpy (regp + offset, buf, 8);
	  }
    }
d114 1
a114 1
      if (x86_64_linux_greg_offset (-1) > core_reg_size)
a134 12
static int
x86_64_core_sniffer (struct core_fns *our_fns, bfd *abfd)
{
  int result;

  result = ((bfd_get_flavour (abfd) == our_fns -> core_flavour)
	    && bfd_get_arch (abfd) == bfd_arch_i386
	    && (bfd_get_mach (abfd) == bfd_mach_x86_64
		|| bfd_get_mach (abfd) == bfd_mach_x86_64_intel_syntax));
  return (result);
}

d139 1
a139 1
  x86_64_core_sniffer,			/* core_sniffer */
@


1.19
log
@* x86-64-tdep.c (X86_64_NUM_SAVED_REGS): Set to X86_64_NUM_GREGS.
(x86_64_sigtramp_frame_cache): Use `sc_reg_offset' to find saved
registers.

* x86-64-linux-tdep.c (x86_64_linux_sc_reg_offset): New variable.
(x86_64_linux_init_abi): Initialize TDEP->sc_reg_offset and
TDEP->sc_num_regs instead of TDEP->sc_pc_offset and
TDEP->sc_sp_offset.
@
text
@d33 110
d288 2
@


1.19.6.1
log
@2003-07-15  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-linux-nat.c (regmap): Removed.
	(supply_gregset, fill_gregset): Call
	x86_64_linux_(fill,supply)_gregset functions.
	* x86-64-linux-tdep.c (USER_*): New defines.
	(user_to_gdb_regmap, x86_64_core_fns): New structure.
	(x86_64_linux_supply_gregset, x86_64_linux_fill_gregset):
	New functions.
	(fetch_core_registers): Ditto.
	(_initialize_x86_64_linux_tdep): Call add_core_fns().
	* x86-64-linux-tdep.h: New file.
	* config/i386/x86-64linux.mh (NATDEPFILES): Remove corelow.o
	and core-regset.o.
	* config/i386/x86-64linux.mt (TDEPFILES): Add corelow.o.
@
text
@a32 110
#include "x86-64-linux-tdep.h"

/* Register indexes to 'struct user' come from <sys/reg.h>.  */

#define USER_R15    0
#define USER_R14    1
#define USER_R13    2
#define USER_R12    3
#define USER_RBP    4
#define USER_RBX    5
#define USER_R11    6
#define USER_R10    7
#define USER_R9     8
#define USER_R8     9
#define USER_RAX    10
#define USER_RCX    11
#define USER_RDX    12
#define USER_RSI    13
#define USER_RDI    14
#define USER_RIP    16
#define USER_CS     17
#define USER_EFLAGS 18
#define USER_RSP    19
#define USER_SS     20
#define USER_DS     23
#define USER_ES     24
#define USER_FS     25
#define USER_GS     26

/* Mapping between the general-purpose registers in `struct user'
   format and GDB's register array layout.  */

static int user_to_gdb_regmap[] =
{
  USER_RAX, USER_RBX, USER_RCX, USER_RDX,
  USER_RSI, USER_RDI, USER_RBP, USER_RSP,
  USER_R8, USER_R9, USER_R10, USER_R11,
  USER_R12, USER_R13, USER_R14, USER_R15,
  USER_RIP, USER_EFLAGS, USER_CS, USER_SS,
  USER_DS, USER_ES, USER_FS, USER_GS
};

/* Fill GDB's register array with the general-purpose register values
   in *GREGSETP.  */

void
x86_64_linux_supply_gregset (char *regp)
{
  int i;

  for (i = 0; i < X86_64_NUM_GREGS; i++)
    supply_register (i, regp + (user_to_gdb_regmap[i] * 8));
}

/* Fill register REGNO (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */

void
x86_64_linux_fill_gregset (char *regp, int regno)
{
  int i;

  for (i = 0; i < X86_64_NUM_GREGS; i++)
    if (regno == -1 || regno == i)
      regcache_collect (i, regp + (user_to_gdb_regmap[i] * 8));
}

/* The register sets used in GNU/Linux ELF core-dumps are identical to
   the register sets used by `ptrace'.  The corresponding types are
   `elf_gregset_t' for the general-purpose registers (with
   `elf_greg_t' the type of a single GP register) and `elf_fpregset_t'
   for the floating-point registers.  */

static void
fetch_core_registers (char *core_reg_sect, unsigned core_reg_size,
			 int which, CORE_ADDR ignore)
{
  switch (which)
    {
    case 0:  /* Integer registers.  */
      if (core_reg_size != 216)
	warning ("Wrong size register set in core file.");
      else
	x86_64_linux_supply_gregset (core_reg_sect);
      break;

    case 2:  /* Floating point registers.  */
    case 3:  /* "Extended" floating point registers.  This is gdb-speak
		for SSE/SSE2. */
      if (core_reg_size != 512)
	warning ("Wrong size XMM register set in core file.");
      else
	x86_64_supply_fxsave (core_reg_sect);
      break;

    default:
      /* Don't know what kind of register request this is; just ignore it.  */
      break;
    }
}

static struct core_fns x86_64_core_fns = 
{
  bfd_target_elf_flavour,		/* core_flavour */
  default_check_format,			/* check_format */
  default_core_sniffer,			/* core_sniffer */
  fetch_core_registers,			/* core_read_registers */
  NULL					/* next */
};
a177 2
  add_core_fns (&x86_64_core_fns);

@


1.18
log
@* x86-64-tdep.h (x86_64_num_regs, x86_64_num_gregs): Remove
variable declarations.
(x86_64_register_number, x86_64_register_name): Remove prototypes.
(x86_64_linux_frame_saved_pc, x86_64_linux+saved_pc_after_call,
x86_64_linux_in_sigtramp, x86_64_linux_frame_chain,
x86_64_init_frame_pc, x86_64_init_frame_pc,
x86_64_function_has_prologue): Remove prototypes.
(X86_64_NUM_GREGS): New define.
(x86_64_supply_fxsave, x86_64_fill_fxsave): New prototypes.
* x86-64-tdep.c: Don't include "dwarf2cfi.h".  Include
"dummy_frame.h", "frame.h", "frame-base.h", "frame-unwind.h".
(RAX_REGNUM, RDX_REGNUM, RDI_REGNUM, EFLAGS_REGNUM, ST0_REGNUM,
XMM1_REGNUM): Remove defines.
(X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, X86_64_RDI_REGNUM,
X86_64_RBP_REGNUM, X86_64_RSP_REGNUM, X86_64_RIP_REGNUM,
X86_64_EFLAGS_REGNUM, X86_64_ST0_REGNUM, X86_64_XMM0_REGNUM,
X86_64_XMM1_REGNUM): New defines.
(struct x86_64_register_info): Renamed from `struct
register_info'.  Remove `size' member.
(x86_64_register_info_table): Remove variable.
(x86_64_register_info): New variable.
(X86_64_NUM_REGS): New define.
(X86_64_NUM_GREGS): Remove define.
(x86_64_num_regs, x86_64_num_gregs): Remove variables.
(x86_64_dwarf2gdb_regno_map, x86_64_dwarf2gdb_regno_map_length):
Remove variables.
(x86_54_dwarf2_reg_to_regnum): Remove function.
(x86_64_dwarf_regmap, x86_64_dwarf_regmap_len): New variables.
(x86_64_dwarf_reg_to_regnum): New function.
(x86_64_register_name): Rewrite.
(x86_64_register_raw_size): Remove function.
(x86_64_register_byte_table): Remove variable.
(x86_64_register_byte): Remove function.
(x86_64_register_virtual_type): Remove function.
(x86_64_register_type): New function.
(x86_64_register_convertible, x86_64_register_convert_to_virtual,
x86_64_register_convert_to_raw): Remove functions.
(x86_64_push_return_address, x86_64_pop_frame): Remove functon.
(x86_64_use_struct_convention): Make static.  Adjust for renamed
defines.
(x86_64_frame_init_saved_regs): Remove function.
(x86_64_push_arguments): Make static.  Change to accept a regcache
as argument.
(x86_64_store_return_value, x86_64_extract_return_value): Make
static.  Rewrite based on i386 counterparts.
(x86_64_push_dummy_call): New function.
(X86_64_NUM_SAVED_REGS): New define.
(x86_64_register_number): Remove function.
(x86_64_store_struct_return): Remove function.
(x86_64_frameless_function_invocation,
x86_64_function_has_prologue): Remove functions.
(PROLOG_BUFSIZE): Remove define.
(struct x86_64_frame_cache): New structure.
(x86_64_alloc_frame_cache, x86_64_analyze_prologue,
x86_64_frame_cache, x86_64_frame_this_id,
x86_64_frame_prev_register, x86_64_frame_p,
x86_64_sigtramp_frame_cache, x86_64_sigtramp_frame_this_id,
x86_64_sigtramp_frame_prev_register, x86_sigtramp_frame_p): New
functions.
(x86_64_frame_unwind, x86_64_sigtramp_frame_unwind): New
variables.
(x86_64_skip_prologue): Rewrite in terms of
x86_64_analyze_prologue.
(x86_64_frame_base_address): New function.
(x86_64_frame_base): New variable.
(x86_64_save_dummy_frame_tos, x86_64_unwind_dummy_id): Rewrite.
(x86_64_init_abi): Set register_type and push_dummy_call.  Don't
set deprecated_fp_regnum, deprecated_register_size,
deprecated_register_bytes, register_raw_size, register_byte,
register_virtual_type, register_convertiable,
register_convert_to_virtual, convert_to_raw,
deprecated_get_saved_register, deprecated_target_read_fp,
deprecated_push_arguments, deprecated_push_return_address,
deprecated_pop_frame, deprecated_store_struct_return,
deprecated_frame_init_saved_regs, deprecated_frame_chain,
frameless_function_invocation, deprecated_frame_saved_pc,
deprecated_saved_pc_after_call, frame_num_args, pc_in_sigtramp,
dwarf2_build_frame_info, deprecated_init_extra_frame_info,
deprecated_init_frame_pc and virtual_frame_pointer.  Call
frame_unwind_append_predicate to register x86_64_sigtramp_frame_p
and x86_64_frame_p.  Call frame_base_set_default to register
x86_64_frame_base.
(I387_FISEG_REGNUM, I387_FOSEG_REGNUM): New defines.
(x86_64_supply_fxsave, x86_64_fill_fxsave): New functions.
(_initialize_x86_64_tdep): Remove function.
* x86-64-linux-tdep.c: Don't include "dwarf2cfi.h".
(LINUX_SIGINFO_SIZE, LINUX_UCONTEXT_SIGCONTEXT_OFFSET,
LINUX_SIGCONTEXT_PC_OFFSET, LINUX_SIGCONTEXT_FP_OFFSET): Don't
define.
(X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET): Define.
(x86_64_linux_sigcontext_addr): Rewrite.
(x86_64_linux_sigtramp_saved_pc, x86_64_linux_saved_pc_after_call,
x86_64_linux_frame_saved_pc): Remove functions.
(x86_64_linux_pc_in_sigtramp): Renamed from
x86_64_linux_in_sigtramp.  Try harder to recognize a signal
trampoline.
(x86_64_linux_frame_chain, x86_64_init_frame_pc):
Remove_functions.
(x86_64_linux_init_abi): Set pc_in_sigtramp.  Initialize
TDEP->sigcontext_addr, TDEP->sc_pc_offset and TDEP->sc_sp_offset.
* x86-64-linux-nat.c: Sync with i386-linux-tdep.c.
(x86_64_regmap): Rename to regmap.
(GETREGS_SUPPLIES): Use X86_64_NUM_GREGS instead of
x86_64_num_gregs.
(supply_gregset, fill_gregset): Likewise.  Use regmap instead of
x86_64_regmap.
(x86_64_fxsave_offset): Remove function.
(supply_fpregset): Simply call x86_64_supply_fxsave.
(fill_fpregset): Simply call x86_64_fill_fxsave.
(fetch_inferior_registers, store_inferior_registers): Avoid
asignment in if-statement.
(LINUX_SYSCALL_LEN, LINUX_SYSCALL_REGNUM, SYS_Sigreturn,
SYS_rt_sigreturn, LINUX_SIGCONTEXT_EFLAGS_OFFSET,
LINUX_UCONTEXT_SIGCONTEXT_OFFSET): Remove defines.
(fetch_core_registers): Remove function.
(linux_elf_core_fns): Remove.
(offsetoff): Don't define.
(_initialize_x86_64_linux_nat, kernel_u_size): Remove functions.
* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
* config/i386/x86-64linux.mh (NATDEPFILES): Remove core-aout.o,
add core-regset.o.
* config/i386/nm-x86-64linux.h: Use NM_X86_64_LINUX_H for
protection against multiple includes instead of NM_X86_64_h.  Add
various comments.  Include "config/nm-linux.h".  Don't include
<signal.h>.
(REGISTER_U_ADDR, KERNEL_U_SIZE, U_REGS_OFFSET, KERN_U_ADDR,
GET_THREAD_SIGNALS): Remove defines.
(x86_64_register_u_addr, kernel_u_size,
lin_thread_get_thread_signals): Remove prototypes.
(PTRACE_ARG3_TYPE, PTRACE_XFER_TYPE): Define to `long'.
[HAVE_LINK_H]: Don't include "solib.h".
[HAVE_LINK_H] (SVR4_SHARED_LIBS): Remove define.
* config/i386/tm-x86-64linux.h: Fix comments.
* Makefile.in (x86-64-linux-nat.o, x86_64-linux-tdep.o,
x86-64-tdep.o): Update dependencies.
@
text
@d126 32
d167 2
a168 2
  tdep->sc_pc_offset = 16 * 8;	/* From <asm/sigcontext.h>.  */
  tdep->sc_sp_offset = 15 * 8;
@


1.17
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d27 3
d31 1
a31 1
#include "regcache.h"
a32 2
#include "dwarf2cfi.h"
#include "osabi.h"
d34 4
a37 4
#define LINUX_SIGTRAMP_INSN0 (0x48)	/* mov $NNNNNNNN,%rax */
#define LINUX_SIGTRAMP_OFFSET0 (0)
#define LINUX_SIGTRAMP_INSN1 (0x0f)	/* syscall */
#define LINUX_SIGTRAMP_OFFSET1 (7)
d39 3
a41 2
static const unsigned char linux_sigtramp_code[] = {
  /*  mov $__NR_rt_sigreturn,%rax */
d56 8
d84 1
a84 1
#define LINUX_SIGINFO_SIZE 0
d86 2
a87 11
/* Offset to struct sigcontext in ucontext, from <asm/ucontext.h>.  */
#define LINUX_UCONTEXT_SIGCONTEXT_OFFSET 40

/* Offset to saved PC in sigcontext, from <asm/sigcontext.h>.  */
#define LINUX_SIGCONTEXT_PC_OFFSET 128
#define LINUX_SIGCONTEXT_FP_OFFSET 120

/* Assuming FRAME is for a GNU/Linux sigtramp routine, return the
   address of the associated sigcontext structure.  */
static CORE_ADDR
x86_64_linux_sigcontext_addr (struct frame_info *frame)
d89 8
a96 2
  CORE_ADDR pc;
  ULONGEST rsp;
d98 2
a99 9
  pc = x86_64_linux_sigtramp_start (get_frame_pc (frame));
  if (pc)
    {
      if (get_next_frame (frame))
	/* If this isn't the top frame, the next frame must be for the
	   signal handler itself.  The sigcontext structure is part of
	   the user context. */
	return get_frame_base (get_next_frame (frame)) + LINUX_SIGINFO_SIZE +
	  LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
d101 2
d104 2
a105 12
      /* This is the top frame. */
      rsp = read_register (SP_REGNUM);
      return rsp + LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;

    }

  error ("Couldn't recognize signal trampoline.");
  return 0;
}

/* Assuming FRAME is for a GNU/Linux sigtramp routine, return the
   saved program counter.  */
d108 1
a108 1
x86_64_linux_sigtramp_saved_pc (struct frame_info *frame)
d110 2
a111 5
  CORE_ADDR addr;

  addr = x86_64_linux_sigcontext_addr (frame);
  return read_memory_integer (addr + LINUX_SIGCONTEXT_PC_OFFSET, 8);
}
d113 2
a114 1
/* Immediately after a function call, return the saved pc.  */
d116 7
a122 67
CORE_ADDR
x86_64_linux_saved_pc_after_call (struct frame_info *frame)
{
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
    return x86_64_linux_sigtramp_saved_pc (frame);

  return read_memory_integer (read_register (SP_REGNUM), 8);
}

/* Saved Pc.  Get it from sigcontext if within sigtramp.  */
CORE_ADDR
x86_64_linux_frame_saved_pc (struct frame_info *frame)
{
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
    return x86_64_linux_sigtramp_saved_pc (frame);
  return cfi_get_ra (frame);
}

/* Return whether PC is in a GNU/Linux sigtramp routine.  */

int
x86_64_linux_in_sigtramp (CORE_ADDR pc, char *name)
{
  if (name)
    return strcmp ("__restore_rt", name) == 0;

  return (x86_64_linux_sigtramp_start (pc) != 0);
}

CORE_ADDR
x86_64_linux_frame_chain (struct frame_info *fi)
{
  ULONGEST addr;
  CORE_ADDR fp, pc;

  if (!(get_frame_type (fi) == SIGTRAMP_FRAME))
    {
      fp = cfi_frame_chain (fi);
      if (fp)
	return fp;
      else
	addr = get_frame_base (fi);
    }
  else
    addr = get_frame_base (get_next_frame (fi));

  addr += LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;

  fp = read_memory_integer (addr + LINUX_SIGCONTEXT_FP_OFFSET, 8) + 8;

  return fp;
}

CORE_ADDR
x86_64_init_frame_pc (int fromleaf, struct frame_info *fi)
{
  CORE_ADDR addr;

  if (get_next_frame (fi)
      && (get_frame_type (get_next_frame (fi)) == SIGTRAMP_FRAME))
    {
      addr = get_frame_base (get_next_frame (get_next_frame (fi)))
	+ LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
      return read_memory_integer (addr + LINUX_SIGCONTEXT_PC_OFFSET, 8);
    }
  else
    return cfi_init_frame_pc (fromleaf, fi);
d129 1
d131 6
d138 1
@


1.17.18.1
log
@Revise the x86_64 (sub)taget.
* x86-64-tdep.c, x86-64-linux-tdep.c, x86-64-linux-nat.c,
config/i386/tm-x86-64linux.h, config/i386/nm-x86-64linux.h,
config/i386/x86-64-linux.mt, config/i386/x86-64linux.mh: Extensive
changes.
@
text
@d27 1
d29 2
d33 4
a36 1
#include "gdb_string.h"
d38 2
a39 10
#include "x86-64-tdep.h"

#define LINUX_SIGTRAMP_INSN0	0x48	/* mov $NNNNNNNN, %rax */
#define LINUX_SIGTRAMP_OFFSET0	0
#define LINUX_SIGTRAMP_INSN1	0x0f	/* syscall */
#define LINUX_SIGTRAMP_OFFSET1	7

static const unsigned char linux_sigtramp_code[] =
{
  /* mov $__NR_rt_sigreturn, %rax */
a53 8

  /* We only recognize a signal trampoline if PC is at the start of
     one of the two instructions.  We optimize for finding the PC at
     the start, as will be the case when the trampoline is not the
     first frame on the stack.  We assume that in the case where the
     PC is not at the start of the instruction sequence, there will be
     a few trailing readable bytes on the stack.  */

d74 70
d146 2
a147 2
static int
x86_64_linux_pc_in_sigtramp (CORE_ADDR pc, char *name)
d149 2
a150 8
  /* If we have NAME, we can optimize the search.  The trampoline is
     named __restore_rt.  However, it isn't dynamically exported from
     the shared C library, so the trampoline may appear to be part of
     the preceding function.  This should always be sigaction,
     __sigaction, or __libc_sigaction (all aliases to the same
     function).  */
  if (name == NULL || strstr (name, "sigaction") != NULL)
    return (x86_64_linux_sigtramp_start (pc) != 0);
d152 1
a152 1
  return (strcmp ("__restore_rt", name) == 0);
d155 20
a174 2
/* Offset to struct sigcontext in ucontext, from <asm/ucontext.h>.  */
#define X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET 40
d176 2
a177 2
/* Assuming NEXT_FRAME is a frame following a GNU/Linux sigtramp
   routine, return the address of the associated sigcontext structure.  */
d179 2
a180 2
static CORE_ADDR
x86_64_linux_sigcontext_addr (struct frame_info *next_frame)
d182 1
a182 2
  CORE_ADDR sp, ucontext_addr;
  char buf[8];
d184 9
a192 9
  frame_unwind_register (next_frame, SP_REGNUM, buf);
  sp = extract_unsigned_integer (buf, 8);

  /* The sigcontext structure is part of the user context.  A pointer
     to the user context is passed as the third argument to the signal
     handler.  */
  read_memory (sp + 16, buf, 8);
  ucontext_addr = extract_unsigned_integer (buf, 8);
  return ucontext_addr + X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
a198 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
a199 6

  set_gdbarch_pc_in_sigtramp (gdbarch, x86_64_linux_pc_in_sigtramp);

  tdep->sigcontext_addr = x86_64_linux_sigcontext_addr;
  tdep->sc_pc_offset = 16 * 8;	/* From <asm/sigcontext.h>.  */
  tdep->sc_sp_offset = 15 * 8;
a200 1

@


1.17.18.2
log
@* x86-64-linux-tdep.c (x86_64_linux_sigcontext_addr): Fix.
@
text
@d110 1
a110 1
  CORE_ADDR sp;
d118 4
a121 5
     handler, i.e. in %rdx.  Unfortunately %rdx isn't preserved across
     function calls so we can't use it.  Fortunately the user context
     is part of the signal frame and the unwound %rsp directly points
     at it.  */
  return sp + X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
@


1.16
log
@2003-01-09  Andrew Cagney  <ac131313@@redhat.com>

	* somsolib.h: Fix function indentation.
	* disasm.c, buildsym.c, buildsym.h: Eliminate PTR.
	* gnu-v2-abi.c, f-typeprint.c, x86-64-linux-tdep.c: Eliminate STREQ.
	* demangle.c, ax-gdb.c, c-valprint.c: Eliminate STREQ.
	* alpha-osf1-tdep.c, corefile.c: Eliminate STREQ.
	* somsolib.c, inftarg.c: Remove assignment in if conditional.
@
text
@d3 1
a3 1
   Copyright 2001 Free Software Foundation, Inc.
@


1.15
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_next_frame.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10200-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, sparc-tdep.c: Ditto.
	* v850-tdep.c, vax-tdep.c, x86-64-linux-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
@
text
@d150 1
a150 1
    return STREQ ("__restore_rt", name);
@


1.14
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_base.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* mn10300-tdep.c, ns32k-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c: Ditto.
	* x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* config/h8500/tm-h8500.h, config/mn10200/tm-mn10200.h: Ditto.
	* config/sparc/tm-sparc.h: Ditto.
@
text
@d94 1
a94 1
      if (frame->next)
d98 1
a98 1
	return get_frame_base (frame->next) + LINUX_SIGINFO_SIZE +
d170 1
a170 1
    addr = get_frame_base (fi->next);
d184 2
a185 1
  if (get_next_frame (fi) && (get_frame_type (fi->next) == SIGTRAMP_FRAME))
@


1.13
log
@2003-01-06  Andrew Cagney  <cagney@@redhat.com>

	* x86-64-linux-tdep.c: Include "osabi.h".
	* Makefile.in (x86-64-linux-tdep.o): Update dependencies.
@
text
@d98 1
a98 1
	return frame->next->frame + LINUX_SIGINFO_SIZE +
d167 1
a167 1
	addr = fi->frame;
d170 1
a170 1
    addr = fi->next->frame;
@


1.12
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d31 1
@


1.11
log
@* x86-64-tdep.h (x86_64_init_abi): New prototype.
* x86-64-tdep.c (i386_fp_regnum_p): Remove function.
(x86_64_init_abi): Make non-static.  Set number of pseudo
registers to 0.
(x86_64_gdbarch_init): Remove function.
(_initialize_x86_64_tdep): Renove register_gdbarch_init call.
Remove code dealing with dissambly.
* x86-64-linux-tdep.c (x86_64_linux_init_abi): New function.
(_initialize_x86_64_linux_tdep): New function.
* config/i386/x86-64linux.mt (TDEPFILES): Add i386-tdep.o and
i386-tdep.o.
@
text
@d90 1
a90 1
  pc = x86_64_linux_sigtramp_start (frame->pc);
@


1.10
log
@2002-12-08  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (INIT_FRAME_PC_FIRST, INIT_FRAME_PC_DEFAULT): Convert
	to pure functions.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Explictly assign prev's pc with value
	returned by INIT_FRAME_PC_FIRST and INIT_EXTRA_FRAME_INFO.

	* arch-utils.h (init_frame_pc_default, init_frame_pc_noop): Change
	declaration to a function returning a CORE_ADDR.
	* x86-64-tdep.h (x86_64_init_frame_pc): Ditto.
	* arch-utils.c (init_frame_pc_noop): Return the PC value.
	(init_frame_pc_default): Ditto.
	* x86-64-linux-tdep.c (x86_64_init_frame_pc): Ditto.
	* s390-tdep.c (s390_init_frame_pc_first): Ditto.
	* mips-tdep.c (mips_init_frame_pc_first): Ditto.
	* dwarf2cfi.h (cfi_init_frame_pc): Ditto.
	* dwarf2cfi.c (cfi_init_frame_pc): Ditto.
	* alpha-tdep.c (alpha_init_frame_pc_first): Ditto.

	* i386-interix-tdep.c (i386_interix_init_abi): Set init_frame_pc
	to init_frame_pc_noop.
	(i386_interix_init_frame_pc): Delete function.
	* z8k-tdep.c (init_frame_pc): Delete function.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC): Define as init_frame_pc_noop.
	(INIT_FRAME_PC_FIRST): Ditto.
	* config/mn10200/tm-mn10200.h (INIT_FRAME_PC): Ditto.
	(INIT_FRAME_PC_FIRST): Ditto.
	* config/sparc/tm-sparc.h (INIT_FRAME_PC): Ditto.
	* config/rs6000/tm-rs6000.h (INIT_FRAME_PC): Redefine as
	init_frame_pc_noop.
	(INIT_FRAME_PC_FIRST): Convert to an expression.
	* config/sparc/tm-sparc.h (INIT_FRAME_PC_FIRST): Ditto.
@
text
@d192 17
@


1.9
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@d178 1
a178 1
void
d183 1
a183 1
  if (fi->next && (get_frame_type (fi->next) == SIGTRAMP_FRAME))
d185 1
a185 1
      addr = fi->next->next->frame
d187 1
a187 1
      fi->pc = read_memory_integer (addr + LINUX_SIGCONTEXT_PC_OFFSET, 8);
d190 1
a190 1
    cfi_init_frame_pc (fromleaf, fi);
@


1.8
log
@* x86-64-tdep.c (x86_64_init_abi): Set init_extra_frame_info to
cfi_init_extra_frame_info.
* x86-64-tdep.h (x86_64_init_extra_frame_info): Remove prototype.
* x86-64-linux-tdep.c (x86_64_init_extra_frame_info): Remove function.
@
text
@d128 1
a128 1
  if (frame->signal_handler_caller)
d138 1
a138 1
  if (frame->signal_handler_caller)
d160 1
a160 1
  if (!fi->signal_handler_caller)
d183 1
a183 1
  if (fi->next && fi->next->signal_handler_caller)
@


1.7
log
@Reindented.
@
text
@a191 6

void
x86_64_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  cfi_init_extra_frame_info (fromleaf, fi);
}
@


1.6
log
@2002-10-24  Michal Ludvig  <mludvig@@suse.cz>

	* dwarf2cfi.c (struct context)
	(struct context_reg): Moved to dwarf2cfi.h
	(context_alloc, frame_state_alloc, context_cpy):
	Made extern instead of static, removed prototypes.
	* dwarf2cfi.h (struct context)
	(struct context_reg): New, moved from dwarf2cfi.c
	(context_alloc, frame_state_alloc, context_cpy):
	New prototypes.
	* x86-64-linux-tdep.c (x86_64_linux_sigtramp_saved_pc):
	Changed from static to extern.
	(LINUX_SIGINFO_SIZE, LINUX_SIGCONTEXT_PC_OFFSET)
	(LINUX_SIGCONTEXT_FP_OFFSET)
	(LINUX_UCONTEXT_SIGCONTEXT_OFFSET): Adjusted.
	(x86_64_linux_in_sigtramp, x86_64_linux_frame_chain)
	(x86_64_init_frame_pc, x86_64_init_extra_frame_info): New.
	* x86-64-tdep.c (x86_64_gdbarch_init): Several
	set_gdbarch_*() calls now use x86-64 specific functions
	instead of DWARF2 CFI ones.
	* x86-64-tdep.h (x86_64_linux_in_sigtramp)
	(x86_64_linux_frame_chain, x86_64_init_frame_pc)
	(x86_64_init_extra_frame_info): New prototypes.
@
text
@d38 1
a38 1
  /*  mov $__NR_rt_sigreturn,%rax */	
d103 1
a103 2
      return rsp + LINUX_SIGINFO_SIZE +
	LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
d150 1
a150 1
  
d157 7
a163 18
	ULONGEST addr;
	CORE_ADDR fp, pc;
	
	if (! fi->signal_handler_caller)
	{
		fp = cfi_frame_chain (fi);
		if(fp)
			return fp;
		else
			addr = fi->frame;
	}
	else
		addr = fi->next->frame;

	addr += LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
	
	fp = read_memory_integer (addr + LINUX_SIGCONTEXT_FP_OFFSET, 8)+8;
	
d165 11
d181 1
a181 1
	CORE_ADDR addr;
d183 8
a190 10
	if(fi->next && fi->next->signal_handler_caller)
	{
		addr = fi->next->next->frame 
			+ LINUX_SIGINFO_SIZE 
			+ LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
		fi->pc = read_memory_integer (addr 
				+ LINUX_SIGCONTEXT_PC_OFFSET, 8);
	}
	else
		cfi_init_frame_pc (fromleaf, fi);
d196 1
a196 1
	cfi_init_extra_frame_info (fromleaf, fi);
@


1.5
log
@2002-09-03  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-linux-tdep.c: Include gdb_string.h
	* x86-64-linux-nat.c: Ditto.
@
text
@d38 4
a41 2
  LINUX_SIGTRAMP_INSN0, 0xc7, 0xc0, 0x89, 0x00, 0x00, 0x00,	/*  mov $0x89,%rax */
  LINUX_SIGTRAMP_INSN1, 0x05	/* syscall */
d73 1
a73 1
#define LINUX_SIGINFO_SIZE 128
d76 5
a80 1
#define LINUX_UCONTEXT_SIGCONTEXT_OFFSET (36)
d84 1
a84 1
CORE_ADDR
d88 1
d102 2
a103 1
      return read_register (SP_REGNUM) + LINUX_SIGINFO_SIZE +
a111 3
/* Offset to saved PC in sigcontext, from <asm/sigcontext.h>.  */
#define LINUX_SIGCONTEXT_PC_OFFSET (136)

d115 1
a115 1
CORE_ADDR
d142 58
@


1.5.6.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d38 2
a39 4
  /*  mov $__NR_rt_sigreturn,%rax */
  LINUX_SIGTRAMP_INSN0, 0xc7, 0xc0, 0x0f, 0x00, 0x00, 0x00,
  /* syscall */
  LINUX_SIGTRAMP_INSN1, 0x05
d71 1
a71 1
#define LINUX_SIGINFO_SIZE 0
d74 1
a74 5
#define LINUX_UCONTEXT_SIGCONTEXT_OFFSET 40

/* Offset to saved PC in sigcontext, from <asm/sigcontext.h>.  */
#define LINUX_SIGCONTEXT_PC_OFFSET 128
#define LINUX_SIGCONTEXT_FP_OFFSET 120
d78 1
a78 1
static CORE_ADDR
a81 1
  ULONGEST rsp;
d95 2
a96 2
      rsp = read_register (SP_REGNUM);
      return rsp + LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
d104 3
d110 1
a110 1
static CORE_ADDR
a136 56
}

/* Return whether PC is in a GNU/Linux sigtramp routine.  */

int
x86_64_linux_in_sigtramp (CORE_ADDR pc, char *name)
{
  if (name)
    return STREQ ("__restore_rt", name);

  return (x86_64_linux_sigtramp_start (pc) != 0);
}

CORE_ADDR
x86_64_linux_frame_chain (struct frame_info *fi)
{
  ULONGEST addr;
  CORE_ADDR fp, pc;

  if (!fi->signal_handler_caller)
    {
      fp = cfi_frame_chain (fi);
      if (fp)
	return fp;
      else
	addr = fi->frame;
    }
  else
    addr = fi->next->frame;

  addr += LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;

  fp = read_memory_integer (addr + LINUX_SIGCONTEXT_FP_OFFSET, 8) + 8;

  return fp;
}

void
x86_64_init_frame_pc (int fromleaf, struct frame_info *fi)
{
  CORE_ADDR addr;

  if (fi->next && fi->next->signal_handler_caller)
    {
      addr = fi->next->next->frame
	+ LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
      fi->pc = read_memory_integer (addr + LINUX_SIGCONTEXT_PC_OFFSET, 8);
    }
  else
    cfi_init_frame_pc (fromleaf, fi);
}

void
x86_64_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  cfi_init_extra_frame_info (fromleaf, fi);
@


1.5.6.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 2001, 2003 Free Software Foundation, Inc.
d27 1
a28 4
#include "osabi.h"

#include "gdb_string.h"

d30 1
a30 41
#include "x86-64-linux-tdep.h"

/* Register indexes to 'struct user' come from <sys/reg.h>.  */

#define USER_R15    0
#define USER_R14    1
#define USER_R13    2
#define USER_R12    3
#define USER_RBP    4
#define USER_RBX    5
#define USER_R11    6
#define USER_R10    7
#define USER_R9     8
#define USER_R8     9
#define USER_RAX    10
#define USER_RCX    11
#define USER_RDX    12
#define USER_RSI    13
#define USER_RDI    14
#define USER_RIP    16
#define USER_CS     17
#define USER_EFLAGS 18
#define USER_RSP    19
#define USER_SS     20
#define USER_DS     23
#define USER_ES     24
#define USER_FS     25
#define USER_GS     26

/* Mapping between the general-purpose registers in `struct user'
   format and GDB's register array layout.  */

static int user_to_gdb_regmap[] =
{
  USER_RAX, USER_RBX, USER_RCX, USER_RDX,
  USER_RSI, USER_RDI, USER_RBP, USER_RSP,
  USER_R8, USER_R9, USER_R10, USER_R11,
  USER_R12, USER_R13, USER_R14, USER_R15,
  USER_RIP, USER_EFLAGS,
  USER_DS, USER_ES, USER_FS, USER_GS
};
d32 4
a35 20
/* Fill GDB's register array with the general-purpose register values
   in *GREGSETP.  */

void
x86_64_linux_supply_gregset (char *regp)
{
  int i;

  for (i = 0; i < X86_64_NUM_GREGS; i++)
    supply_register (i, regp + (user_to_gdb_regmap[i] * 8));
}

/* Fill register REGNO (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */

void
x86_64_linux_fill_gregset (char *regp, int regno)
{
  int i;
d37 2
a38 56
  for (i = 0; i < X86_64_NUM_GREGS; i++)
    if (regno == -1 || regno == i)
      regcache_collect (i, regp + (user_to_gdb_regmap[i] * 8));
}

/* The register sets used in GNU/Linux ELF core-dumps are identical to
   the register sets used by `ptrace'.  The corresponding types are
   `elf_gregset_t' for the general-purpose registers (with
   `elf_greg_t' the type of a single GP register) and `elf_fpregset_t'
   for the floating-point registers.  */

static void
fetch_core_registers (char *core_reg_sect, unsigned core_reg_size,
			 int which, CORE_ADDR ignore)
{
  switch (which)
    {
    case 0:  /* Integer registers.  */
      if (core_reg_size != 216)
	warning ("Wrong size register set in core file.");
      else
	x86_64_linux_supply_gregset (core_reg_sect);
      break;

    case 2:  /* Floating point registers.  */
    case 3:  /* "Extended" floating point registers.  This is gdb-speak
		for SSE/SSE2. */
      if (core_reg_size != 512)
	warning ("Wrong size XMM register set in core file.");
      else
	x86_64_supply_fxsave (current_regcache, -1, core_reg_sect);
      break;

    default:
      /* Don't know what kind of register request this is; just ignore it.  */
      break;
    }
}

static struct core_fns x86_64_core_fns = 
{
  bfd_target_elf_flavour,		/* core_flavour */
  default_check_format,			/* check_format */
  default_core_sniffer,			/* core_sniffer */
  fetch_core_registers,			/* core_read_registers */
  NULL					/* next */
};

#define LINUX_SIGTRAMP_INSN0	0x48	/* mov $NNNNNNNN, %rax */
#define LINUX_SIGTRAMP_OFFSET0	0
#define LINUX_SIGTRAMP_INSN1	0x0f	/* syscall */
#define LINUX_SIGTRAMP_OFFSET1	7

static const unsigned char linux_sigtramp_code[] =
{
  /* mov $__NR_rt_sigreturn, %rax */
a52 8

  /* We only recognize a signal trampoline if PC is at the start of
     one of the two instructions.  We optimize for finding the PC at
     the start, as will be the case when the trampoline is not the
     first frame on the stack.  We assume that in the case where the
     PC is not at the start of the instruction sequence, there will be
     a few trailing readable bytes on the stack.  */

d73 8
a80 1
/* Return whether PC is in a GNU/Linux sigtramp routine.  */
d82 4
a85 2
static int
x86_64_linux_pc_in_sigtramp (CORE_ADDR pc, char *name)
d87 2
a88 8
  /* If we have NAME, we can optimize the search.  The trampoline is
     named __restore_rt.  However, it isn't dynamically exported from
     the shared C library, so the trampoline may appear to be part of
     the preceding function.  This should always be sigaction,
     __sigaction, or __libc_sigaction (all aliases to the same
     function).  */
  if (name == NULL || strstr (name, "sigaction") != NULL)
    return (x86_64_linux_sigtramp_start (pc) != 0);
d90 19
a108 1
  return (strcmp ("__restore_rt", name) == 0);
d111 2
a112 5
/* Offset to struct sigcontext in ucontext, from <asm/ucontext.h>.  */
#define X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET 40

/* Assuming NEXT_FRAME is a frame following a GNU/Linux sigtramp
   routine, return the address of the associated sigcontext structure.  */
d115 1
a115 1
x86_64_linux_sigcontext_addr (struct frame_info *next_frame)
d117 5
a121 2
  CORE_ADDR sp;
  char buf[8];
d123 1
a123 2
  frame_unwind_register (next_frame, SP_REGNUM, buf);
  sp = extract_unsigned_integer (buf, 8);
d125 7
a131 7
  /* The sigcontext structure is part of the user context.  A pointer
     to the user context is passed as the third argument to the signal
     handler, i.e. in %rdx.  Unfortunately %rdx isn't preserved across
     function calls so we can't use it.  Fortunately the user context
     is part of the signal frame and the unwound %rsp directly points
     at it.  */
  return sp + X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
a132 1

d134 3
a136 2
/* From <asm/sigcontext.h>.  */
static int x86_64_linux_sc_reg_offset[] =
d138 15
a152 28
  13 * 8,			/* %rax */
  11 * 8,			/* %rbx */
  14 * 8,			/* %rcx */
  12 * 8,			/* %rdx */
  9 * 8,			/* %rsi */
  8 * 8,			/* %rdi */
  10 * 8,			/* %rbp */
  15 * 8,			/* %rsp */
  0 * 8,			/* %r8 */
  1 * 8,			/* %r9 */
  2 * 8,			/* %r10 */
  3 * 8,			/* %r11 */
  4 * 8,			/* %r12 */
  5 * 8,			/* %r13 */
  6 * 8,			/* %r14 */
  7 * 8,			/* %r15 */
  16 * 8,			/* %rip */
  17 * 8,			/* %eflags */
  -1,				/* %ds */
  -1,				/* %es */

  /* FIXME: kettenis/2002030531: The registers %fs and %gs are
     available in `struct sigcontext'.  However, they only occupy two
     bytes instead of four, which makes using them here rather
     difficult.  Leave them out for now.  */
  -1,				/* %fs */
  -1				/* %gs */
};
d154 2
a155 2
static void
x86_64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
d157 15
a171 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  x86_64_init_abi (info, gdbarch);
d173 1
a173 1
  set_gdbarch_pc_in_sigtramp (gdbarch, x86_64_linux_pc_in_sigtramp);
d175 1
a175 3
  tdep->sigcontext_addr = x86_64_linux_sigcontext_addr;
  tdep->sc_reg_offset = x86_64_linux_sc_reg_offset;
  tdep->sc_num_regs = ARRAY_SIZE (x86_64_linux_sc_reg_offset);
a176 1

d178 14
a191 2
/* Provide a prototype to silence -Wmissing-prototypes.  */
extern void _initialize_x86_64_linux_tdep (void);
d194 1
a194 1
_initialize_x86_64_linux_tdep (void)
d196 1
a196 4
  add_core_fns (&x86_64_core_fns);

  gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64, GDB_OSABI_LINUX,
			  x86_64_linux_init_abi);
@


1.5.6.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d3 2
a4 1
   Copyright 2001, 2003, 2004 Free Software Foundation, Inc.
a71 1
  USER_CS, USER_SS,
d257 2
d260 1
a260 1
  /* FIXME: kettenis/2002030531: The registers %cs, %fs and %gs are
a263 4
  -1,				/* %cs */
  -1,				/* %ss */
  -1,				/* %ds */
  -1,				/* %es */
@


1.5.4.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d38 2
a39 4
  /*  mov $__NR_rt_sigreturn,%rax */
  LINUX_SIGTRAMP_INSN0, 0xc7, 0xc0, 0x0f, 0x00, 0x00, 0x00,
  /* syscall */
  LINUX_SIGTRAMP_INSN1, 0x05
d71 1
a71 1
#define LINUX_SIGINFO_SIZE 0
d74 1
a74 5
#define LINUX_UCONTEXT_SIGCONTEXT_OFFSET 40

/* Offset to saved PC in sigcontext, from <asm/sigcontext.h>.  */
#define LINUX_SIGCONTEXT_PC_OFFSET 128
#define LINUX_SIGCONTEXT_FP_OFFSET 120
d78 1
a78 1
static CORE_ADDR
a81 1
  ULONGEST rsp;
d95 2
a96 2
      rsp = read_register (SP_REGNUM);
      return rsp + LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
d104 3
d110 1
a110 1
static CORE_ADDR
a136 56
}

/* Return whether PC is in a GNU/Linux sigtramp routine.  */

int
x86_64_linux_in_sigtramp (CORE_ADDR pc, char *name)
{
  if (name)
    return STREQ ("__restore_rt", name);

  return (x86_64_linux_sigtramp_start (pc) != 0);
}

CORE_ADDR
x86_64_linux_frame_chain (struct frame_info *fi)
{
  ULONGEST addr;
  CORE_ADDR fp, pc;

  if (!fi->signal_handler_caller)
    {
      fp = cfi_frame_chain (fi);
      if (fp)
	return fp;
      else
	addr = fi->frame;
    }
  else
    addr = fi->next->frame;

  addr += LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;

  fp = read_memory_integer (addr + LINUX_SIGCONTEXT_FP_OFFSET, 8) + 8;

  return fp;
}

void
x86_64_init_frame_pc (int fromleaf, struct frame_info *fi)
{
  CORE_ADDR addr;

  if (fi->next && fi->next->signal_handler_caller)
    {
      addr = fi->next->next->frame
	+ LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
      fi->pc = read_memory_integer (addr + LINUX_SIGCONTEXT_PC_OFFSET, 8);
    }
  else
    cfi_init_frame_pc (fromleaf, fi);
}

void
x86_64_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  cfi_init_extra_frame_info (fromleaf, fi);
@


1.5.4.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d192 6
@


1.5.4.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d128 1
a128 1
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
d138 1
a138 1
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
d160 1
a160 1
  if (!(get_frame_type (fi) == SIGTRAMP_FRAME))
d178 1
a178 1
CORE_ADDR
d183 1
a183 1
  if (get_next_frame (fi) && (get_frame_type (fi->next) == SIGTRAMP_FRAME))
d185 1
a185 1
      addr = get_frame_base (get_next_frame (get_next_frame (fi)))
d187 1
a187 1
      return read_memory_integer (addr + LINUX_SIGCONTEXT_PC_OFFSET, 8);
d190 1
a190 18
    return cfi_init_frame_pc (fromleaf, fi);
}


static void
x86_64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  x86_64_init_abi (info, gdbarch);
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern void _initialize_x86_64_linux_tdep (void);

void
_initialize_x86_64_linux_tdep (void)
{
  gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64, GDB_OSABI_LINUX,
			  x86_64_linux_init_abi);
@


1.5.4.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   Copyright 2001, 2003 Free Software Foundation, Inc.
a30 1
#include "osabi.h"
d90 1
a90 1
  pc = x86_64_linux_sigtramp_start (get_frame_pc (frame));
d93 1
a93 1
      if (get_next_frame (frame))
d97 1
a97 1
	return get_frame_base (get_next_frame (frame)) + LINUX_SIGINFO_SIZE +
d149 1
a149 1
    return strcmp ("__restore_rt", name) == 0;
d166 1
a166 1
	addr = get_frame_base (fi);
d169 1
a169 1
    addr = get_frame_base (get_next_frame (fi));
d183 1
a183 2
  if (get_next_frame (fi)
      && (get_frame_type (get_next_frame (fi)) == SIGTRAMP_FRAME))
@


1.5.4.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d27 1
d29 2
d33 4
a36 1
#include "gdb_string.h"
d38 2
a39 10
#include "x86-64-tdep.h"

#define LINUX_SIGTRAMP_INSN0	0x48	/* mov $NNNNNNNN, %rax */
#define LINUX_SIGTRAMP_OFFSET0	0
#define LINUX_SIGTRAMP_INSN1	0x0f	/* syscall */
#define LINUX_SIGTRAMP_OFFSET1	7

static const unsigned char linux_sigtramp_code[] =
{
  /* mov $__NR_rt_sigreturn, %rax */
a53 8

  /* We only recognize a signal trampoline if PC is at the start of
     one of the two instructions.  We optimize for finding the PC at
     the start, as will be the case when the trampoline is not the
     first frame on the stack.  We assume that in the case where the
     PC is not at the start of the instruction sequence, there will be
     a few trailing readable bytes on the stack.  */

d74 70
d146 2
a147 2
static int
x86_64_linux_pc_in_sigtramp (CORE_ADDR pc, char *name)
d149 2
a150 8
  /* If we have NAME, we can optimize the search.  The trampoline is
     named __restore_rt.  However, it isn't dynamically exported from
     the shared C library, so the trampoline may appear to be part of
     the preceding function.  This should always be sigaction,
     __sigaction, or __libc_sigaction (all aliases to the same
     function).  */
  if (name == NULL || strstr (name, "sigaction") != NULL)
    return (x86_64_linux_sigtramp_start (pc) != 0);
d152 1
a152 1
  return (strcmp ("__restore_rt", name) == 0);
d155 5
a159 2
/* Offset to struct sigcontext in ucontext, from <asm/ucontext.h>.  */
#define X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET 40
d161 10
a170 2
/* Assuming NEXT_FRAME is a frame following a GNU/Linux sigtramp
   routine, return the address of the associated sigcontext structure.  */
d172 1
a172 5
static CORE_ADDR
x86_64_linux_sigcontext_addr (struct frame_info *next_frame)
{
  CORE_ADDR sp;
  char buf[8];
d174 1
a174 2
  frame_unwind_register (next_frame, SP_REGNUM, buf);
  sp = extract_unsigned_integer (buf, 8);
d176 1
a176 7
  /* The sigcontext structure is part of the user context.  A pointer
     to the user context is passed as the third argument to the signal
     handler, i.e. in %rdx.  Unfortunately %rdx isn't preserved across
     function calls so we can't use it.  Fortunately the user context
     is part of the signal frame and the unwound %rsp directly points
     at it.  */
  return sp + X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
a177 1

d179 2
a180 2
/* From <asm/sigcontext.h>.  */
static int x86_64_linux_sc_reg_offset[X86_64_NUM_GREGS] =
d182 13
a194 28
  13 * 8,			/* %rax */
  11 * 8,			/* %rbx */
  14 * 8,			/* %rcx */
  12 * 8,			/* %rdx */
  9 * 8,			/* %rsi */
  8 * 8,			/* %rdi */
  10 * 8,			/* %rbp */
  15 * 8,			/* %rsp */
  0 * 8,			/* %r8 */
  1 * 8,			/* %r9 */
  2 * 8,			/* %r10 */
  3 * 8,			/* %r11 */
  4 * 8,			/* %r12 */
  5 * 8,			/* %r13 */
  6 * 8,			/* %r14 */
  7 * 8,			/* %r15 */
  16 * 8,			/* %rip */
  17 * 8,			/* %eflags */
  -1,				/* %ds */
  -1,				/* %es */

  /* FIXME: kettenis/2002030531: The registers %fs and %gs are
     available in `struct sigcontext'.  However, they only occupy two
     bytes instead of four, which makes using them here rather
     difficult.  Leave them out for now.  */
  -1,				/* %fs */
  -1				/* %gs */
};
a198 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
a199 6

  set_gdbarch_pc_in_sigtramp (gdbarch, x86_64_linux_pc_in_sigtramp);

  tdep->sigcontext_addr = x86_64_linux_sigcontext_addr;
  tdep->sc_reg_offset = x86_64_linux_sc_reg_offset;
  tdep->sc_num_regs = X86_64_NUM_GREGS;
a200 1

@


1.5.4.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a32 110
#include "x86-64-linux-tdep.h"

/* Register indexes to 'struct user' come from <sys/reg.h>.  */

#define USER_R15    0
#define USER_R14    1
#define USER_R13    2
#define USER_R12    3
#define USER_RBP    4
#define USER_RBX    5
#define USER_R11    6
#define USER_R10    7
#define USER_R9     8
#define USER_R8     9
#define USER_RAX    10
#define USER_RCX    11
#define USER_RDX    12
#define USER_RSI    13
#define USER_RDI    14
#define USER_RIP    16
#define USER_CS     17
#define USER_EFLAGS 18
#define USER_RSP    19
#define USER_SS     20
#define USER_DS     23
#define USER_ES     24
#define USER_FS     25
#define USER_GS     26

/* Mapping between the general-purpose registers in `struct user'
   format and GDB's register array layout.  */

static int user_to_gdb_regmap[] =
{
  USER_RAX, USER_RBX, USER_RCX, USER_RDX,
  USER_RSI, USER_RDI, USER_RBP, USER_RSP,
  USER_R8, USER_R9, USER_R10, USER_R11,
  USER_R12, USER_R13, USER_R14, USER_R15,
  USER_RIP, USER_EFLAGS, USER_CS, USER_SS,
  USER_DS, USER_ES, USER_FS, USER_GS
};

/* Fill GDB's register array with the general-purpose register values
   in *GREGSETP.  */

void
x86_64_linux_supply_gregset (char *regp)
{
  int i;

  for (i = 0; i < X86_64_NUM_GREGS; i++)
    supply_register (i, regp + (user_to_gdb_regmap[i] * 8));
}

/* Fill register REGNO (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */

void
x86_64_linux_fill_gregset (char *regp, int regno)
{
  int i;

  for (i = 0; i < X86_64_NUM_GREGS; i++)
    if (regno == -1 || regno == i)
      regcache_collect (i, regp + (user_to_gdb_regmap[i] * 8));
}

/* The register sets used in GNU/Linux ELF core-dumps are identical to
   the register sets used by `ptrace'.  The corresponding types are
   `elf_gregset_t' for the general-purpose registers (with
   `elf_greg_t' the type of a single GP register) and `elf_fpregset_t'
   for the floating-point registers.  */

static void
fetch_core_registers (char *core_reg_sect, unsigned core_reg_size,
			 int which, CORE_ADDR ignore)
{
  switch (which)
    {
    case 0:  /* Integer registers.  */
      if (core_reg_size != 216)
	warning ("Wrong size register set in core file.");
      else
	x86_64_linux_supply_gregset (core_reg_sect);
      break;

    case 2:  /* Floating point registers.  */
    case 3:  /* "Extended" floating point registers.  This is gdb-speak
		for SSE/SSE2. */
      if (core_reg_size != 512)
	warning ("Wrong size XMM register set in core file.");
      else
	x86_64_supply_fxsave (core_reg_sect);
      break;

    default:
      /* Don't know what kind of register request this is; just ignore it.  */
      break;
    }
}

static struct core_fns x86_64_core_fns = 
{
  bfd_target_elf_flavour,		/* core_flavour */
  default_check_format,			/* check_format */
  default_core_sniffer,			/* core_sniffer */
  fetch_core_registers,			/* core_read_registers */
  NULL					/* next */
};
a177 2
  add_core_fns (&x86_64_core_fns);

@


1.5.4.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d71 1
a71 1
  USER_RIP, USER_EFLAGS,
d126 1
a126 1
	x86_64_supply_fxsave (core_reg_sect, -1);
@


1.5.4.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d126 1
a126 1
	x86_64_supply_fxsave (current_regcache, -1, core_reg_sect);
d237 1
a237 1
static int x86_64_linux_sc_reg_offset[] =
d278 1
a278 1
  tdep->sc_num_regs = ARRAY_SIZE (x86_64_linux_sc_reg_offset);
@


1.5.4.9
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d3 2
a4 1
   Copyright 2001, 2003, 2004 Free Software Foundation, Inc.
a71 1
  USER_CS, USER_SS,
d257 2
d260 1
a260 1
  /* FIXME: kettenis/2002030531: The registers %cs, %fs and %gs are
a263 4
  -1,				/* %cs */
  -1,				/* %ss */
  -1,				/* %ds */
  -1,				/* %es */
@


1.4
log
@s/Linux/.../
Fix PR gdb/378.
@
text
@d27 1
@


1.4.8.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a26 1
#include "gdb_string.h"
@


1.4.8.2
log
@merge from mainline
@
text
@d38 2
a39 4
  /*  mov $__NR_rt_sigreturn,%rax */
  LINUX_SIGTRAMP_INSN0, 0xc7, 0xc0, 0x0f, 0x00, 0x00, 0x00,
  /* syscall */
  LINUX_SIGTRAMP_INSN1, 0x05
d71 1
a71 1
#define LINUX_SIGINFO_SIZE 0
d74 1
a74 5
#define LINUX_UCONTEXT_SIGCONTEXT_OFFSET 40

/* Offset to saved PC in sigcontext, from <asm/sigcontext.h>.  */
#define LINUX_SIGCONTEXT_PC_OFFSET 128
#define LINUX_SIGCONTEXT_FP_OFFSET 120
d78 1
a78 1
static CORE_ADDR
a81 1
  ULONGEST rsp;
d95 2
a96 2
      rsp = read_register (SP_REGNUM);
      return rsp + LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
d104 3
d110 1
a110 1
static CORE_ADDR
a136 50
}

/* Return whether PC is in a GNU/Linux sigtramp routine.  */

int
x86_64_linux_in_sigtramp (CORE_ADDR pc, char *name)
{
  if (name)
    return STREQ ("__restore_rt", name);

  return (x86_64_linux_sigtramp_start (pc) != 0);
}

CORE_ADDR
x86_64_linux_frame_chain (struct frame_info *fi)
{
  ULONGEST addr;
  CORE_ADDR fp, pc;

  if (!fi->signal_handler_caller)
    {
      fp = cfi_frame_chain (fi);
      if (fp)
	return fp;
      else
	addr = fi->frame;
    }
  else
    addr = fi->next->frame;

  addr += LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;

  fp = read_memory_integer (addr + LINUX_SIGCONTEXT_FP_OFFSET, 8) + 8;

  return fp;
}

void
x86_64_init_frame_pc (int fromleaf, struct frame_info *fi)
{
  CORE_ADDR addr;

  if (fi->next && fi->next->signal_handler_caller)
    {
      addr = fi->next->next->frame
	+ LINUX_SIGINFO_SIZE + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
      fi->pc = read_memory_integer (addr + LINUX_SIGCONTEXT_PC_OFFSET, 8);
    }
  else
    cfi_init_frame_pc (fromleaf, fi);
@


1.3
log
@* x86-64-linux-tdep.c (LINUX_SIGINFO_SIZE): Add.
(x86_64_linux_sigcontext_addr): Replace `sizeof (struct siginfo)'
by LINUX_SIGINFO_SIZE.
@
text
@d1 4
a4 3
/* Target-dependent code for Linux running on x86-64, for GDB.
   Copyright 2001
   Free Software Foundation, Inc.
d75 2
a76 2
/* Assuming FRAME is for a Linux sigtramp routine, return the address
   of the associated sigcontext structure.  */
d106 2
a107 2
/* Assuming FRAME is for a Linux sigtramp routine, return the saved
   program counter.  */
@


1.2
log
@* x86-64-linux-tdep.c (STRUCT_OFFSET): Removed.
@
text
@d69 2
d88 1
a88 1
	return frame->next->frame + sizeof (struct siginfo) +
d93 1
a93 1
      return read_register (SP_REGNUM) + sizeof (struct siginfo) +
@


1.1
log
@* config/i386/x86-64linux.mh: New file.
* config/i386/x86-64linux.mt: New file.
* config/i386/nm-x86_64.h: New file.
* x86-64-linux-tdep.c: New file.
* x86-64-linux-nat.c: New file.
* x86-64-tdep.c: New file.
* x86-64-tdep.h: New file.
* config/djgpp/fnchange.lst: Add entries for x86_64-linux-tdep.c
and x86_64-linux-nat.c
* Makefile.in: Add x86_64-linux-tdep.o, x86_64-tdep.o,
x86_64-linux-tdep.o, x86_64-nat.o, update dependencies.
@
text
@a29 3
#define STRUCT_OFFSET(struct_type, member)    \
    ((long) ((char*) &((struct_type*) 0)->member))

@

