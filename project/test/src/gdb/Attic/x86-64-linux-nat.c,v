head	1.35;
access;
symbols
	drow_intercu-20040221-branch:1.31.0.6
	drow_intercu-20040221-branchpoint:1.31
	cagney_bfdfile-20040213-branch:1.31.0.4
	cagney_bfdfile-20040213-branchpoint:1.31
	drow-cplus-merge-20040208:1.31
	carlton_dictionary-20040126-merge:1.31
	cagney_bigcore-20040122-branch:1.31.0.2
	cagney_bigcore-20040122-branchpoint:1.31
	drow-cplus-merge-20040113:1.31
	drow-cplus-merge-20031224:1.30
	drow-cplus-merge-20031220:1.30
	carlton_dictionary-20031215-merge:1.30
	drow-cplus-merge-20031214:1.30
	carlton-dictionary-20031111-merge:1.30
	gdb_6_0-2003-10-04-release:1.23.6.3
	kettenis_sparc-20030918-branch:1.29.0.4
	kettenis_sparc-20030918-branchpoint:1.29
	carlton_dictionary-20030917-merge:1.29
	ezannoni_pie-20030916-branchpoint:1.29
	ezannoni_pie-20030916-branch:1.29.0.2
	cagney_x86i386-20030821-branch:1.26.0.2
	cagney_x86i386-20030821-branchpoint:1.26
	carlton_dictionary-20030805-merge:1.25
	carlton_dictionary-20030627-merge:1.23
	gdb_6_0-branch:1.23.0.6
	gdb_6_0-2003-06-23-branchpoint:1.23
	jimb-ppc64-linux-20030613-branch:1.23.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.23
	cagney_convert-20030606-branch:1.23.0.2
	cagney_convert-20030606-branchpoint:1.23
	cagney_writestrings-20030508-branch:1.21.0.24
	cagney_writestrings-20030508-branchpoint:1.21
	jimb-ppc64-linux-20030528-branch:1.21.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.21
	carlton_dictionary-20030523-merge:1.21
	cagney_fileio-20030521-branch:1.21.0.20
	cagney_fileio-20030521-branchpoint:1.21
	kettenis_i386newframe-20030517-mergepoint:1.21
	jimb-ppc64-linux-20030509-branch:1.21.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.21
	kettenis_i386newframe-20030504-mergepoint:1.21
	carlton_dictionary-20030430-merge:1.21
	kettenis_i386newframe-20030419-branch:1.21.0.16
	kettenis_i386newframe-20030419-branchpoint:1.21
	carlton_dictionary-20030416-merge:1.21
	cagney_frameaddr-20030409-mergepoint:1.21
	kettenis_i386newframe-20030406-branch:1.21.0.14
	kettenis_i386newframe-20030406-branchpoint:1.21
	cagney_frameaddr-20030403-branchpoint:1.21
	cagney_frameaddr-20030403-branch:1.21.0.12
	cagney_framebase-20030330-mergepoint:1.21
	cagney_framebase-20030326-branch:1.21.0.10
	cagney_framebase-20030326-branchpoint:1.21
	cagney_lazyid-20030317-branch:1.21.0.8
	cagney_lazyid-20030317-branchpoint:1.21
	kettenis-i386newframe-20030316-mergepoint:1.21
	offbyone-20030313-branch:1.21.0.6
	offbyone-20030313-branchpoint:1.21
	kettenis-i386newframe-20030308-branch:1.21.0.4
	kettenis-i386newframe-20030308-branchpoint:1.21
	carlton_dictionary-20030305-merge:1.21
	cagney_offbyone-20030303-branch:1.21.0.2
	cagney_offbyone-20030303-branchpoint:1.21
	carlton_dictionary-20030207-merge:1.20
	interps-20030203-mergepoint:1.20
	interps-20030202-branch:1.20.0.2
	interps-20030202-branchpoint:1.20
	cagney-unwind-20030108-branch:1.19.0.2
	cagney-unwind-20030108-branchpoint:1.19
	carlton_dictionary-20021223-merge:1.18
	gdb_5_3-2002-12-12-release:1.15.2.1
	carlton_dictionary-20021115-merge:1.17
	kseitz_interps-20021105-merge:1.17
	kseitz_interps-20021103-merge:1.17
	drow-cplus-merge-20021020:1.16
	drow-cplus-merge-20021025:1.16
	carlton_dictionary-20021025-merge:1.16
	carlton_dictionary-20021011-merge:1.16
	drow-cplus-branch:1.16.0.4
	drow-cplus-branchpoint:1.16
	kseitz_interps-20020930-merge:1.16
	carlton_dictionary-20020927-merge:1.16
	carlton_dictionary-branch:1.16.0.2
	carlton_dictionary-20020920-branchpoint:1.16
	gdb_5_3-branch:1.15.0.2
	gdb_5_3-2002-09-04-branchpoint:1.15
	kseitz_interps-20020829-merge:1.14
	cagney_sysregs-20020825-branch:1.14.0.4
	cagney_sysregs-20020825-branchpoint:1.14
	readline_4_3-import-branch:1.14.0.2
	readline_4_3-import-branchpoint:1.14
	gdb_5_2_1-2002-07-23-release:1.5.2.4
	kseitz_interps-20020528-branch:1.12.0.4
	kseitz_interps-20020528-branchpoint:1.12
	cagney_regbuf-20020515-branch:1.12.0.2
	cagney_regbuf-20020515-branchpoint:1.12
	jimb-macro-020506-branch:1.10.0.2
	jimb-macro-020506-branchpoint:1.10
	gdb_5_2-2002-04-29-release:1.5.2.3
	gdb_5_2-branch:1.5.0.2
	gdb_5_2-2002-03-03-branchpoint:1.5
	cygnus_cvs_20020108_pre:1.1;
locks; strict;
comment	@ * @;


1.35
date	2004.02.25.20.45.30;	author kettenis;	state dead;
branches;
next	1.34;

1.34
date	2004.02.23.21.37.52;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.22.20.19.40;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.21.23.45.36;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.10.12.52.41;	author kettenis;	state Exp;
branches
	1.31.6.1;
next	1.30;

1.30
date	2003.09.28.13.35.44;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.31.15.18.58;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.29.16.28.38;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2003.08.23.13.58.18;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.18.13.42.13;	author mludvig;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2003.07.17.12.49.52;	author ezannoni;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.15.11.33.59;	author mludvig;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.31.18.00.04;	author aj;	state Exp;
branches
	1.23.6.1;
next	1.22;

1.22
date	2003.05.31.08.15.38;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.11.23.09.59;	author mludvig;	state Exp;
branches
	1.21.16.1;
next	1.20;

1.20
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.06.14.47.37;	author mludvig;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.16.00.53.23;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.18.11.24.02;	author mludvig;	state Exp;
branches
	1.16.2.1
	1.16.4.1;
next	1.15;

1.15
date	2002.09.03.13.06.32;	author mludvig;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.06.20.13.08.11;	author mludvig;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.07.16.11.09;	author mludvig;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.11.17.22.26;	author thorpej;	state Exp;
branches
	1.12.2.1
	1.12.4.1;
next	1.11;

1.11
date	2002.05.07.11.22.54;	author mludvig;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.29.18.27.31;	author mludvig;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.10.12.12.33;	author mludvig;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.04.13.18.59;	author mludvig;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.27.10.21.26;	author mludvig;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.10.18.16.26;	author mludvig;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.24.22.14.33;	author cagney;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.01.20.09.29.41;	author aj;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.19.03.32.43;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.08.00.59.31;	author msnyder;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.21.12.19.15;	author smid;	state Exp;
branches;
next	;

1.5.2.1
date	2002.03.27.17.19.37;	author mludvig;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.04.04.14.21.35;	author mludvig;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.04.10.12.53.44;	author mludvig;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2002.07.03.06.00.26;	author mludvig;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.15.16.42.55;	author cagney;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.06.21.16.46.53;	author cagney;	state Exp;
branches;
next	;

1.12.4.1
date	2002.06.20.01.33.21;	author kseitz;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.07.22.21.47.04;	author kseitz;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2002.10.01.00.46.15;	author kseitz;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.15.2.1
date	2002.09.18.11.24.40;	author mludvig;	state Exp;
branches;
next	;

1.16.2.1
date	2002.11.15.19.19.01;	author carlton;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.12.23.19.38.50;	author carlton;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2003.02.07.19.17.54;	author carlton;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2003.03.06.00.56.33;	author carlton;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2003.06.27.21.50.13;	author carlton;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2003.08.05.17.13.16;	author carlton;	state Exp;
branches;
next	1.16.2.7;

1.16.2.7
date	2003.09.17.21.28.36;	author carlton;	state Exp;
branches;
next	1.16.2.8;

1.16.2.8
date	2003.11.11.23.50.59;	author carlton;	state Exp;
branches;
next	1.16.2.9;

1.16.2.9
date	2004.01.26.19.11.35;	author carlton;	state Exp;
branches;
next	;

1.16.4.1
date	2003.12.14.20.27.34;	author drow;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2004.01.13.16.12.03;	author drow;	state Exp;
branches;
next	;

1.21.16.1
date	2003.05.17.15.09.15;	author kettenis;	state Exp;
branches;
next	1.21.16.2;

1.21.16.2
date	2003.05.29.07.39.11;	author mludvig;	state Exp;
branches;
next	;

1.23.6.1
date	2003.07.15.11.30.58;	author mludvig;	state Exp;
branches;
next	1.23.6.2;

1.23.6.2
date	2003.07.17.12.51.55;	author ezannoni;	state Exp;
branches;
next	1.23.6.3;

1.23.6.3
date	2003.08.18.13.33.18;	author mludvig;	state Exp;
branches;
next	;

1.26.2.1
date	2003.08.21.20.37.30;	author cagney;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2003.08.26.16.07.22;	author cagney;	state Exp;
branches;
next	;

1.31.6.1
date	2004.03.27.17.37.55;	author drow;	state dead;
branches;
next	;


desc
@@


1.35
log
@* amd64-tdep.h: Renamed from x86-64-tdep.h.
* amd64-tdep.c: Renamed from x86-64-tdep.c.  Include
"amd64-tdep.h" instead of "x86-64-tdep.h".
* amd64-nat.c: Include "amd64-tdep.h" instead of "x86-64-tdep.h".
* amd64-linux-tdep.h: Renamed from x86-64-linux.h.
* amd64-linux-tdep.c: Renamed from x86-64-linux-tdep.c.  Include
"amd64-tdep.h" and "amd64-linux-tdep.h" instead of "x86-64-tdep.h"
and "x86-64-tdep.c".
* amd64-linux-nat.c: Renamed from x86-64-linux-nat.c.  Include
"amd64-tdep.h" and "amd64-linux-tdep.h" instead of "x86-64-tdep.h"
and "x86-64-tdep.c".
* amd64bsd-nat.c: Update copyright year.
Include "amd64-tdep.h" instead of "x86-64-tdep.h".
* amd64fbsd-tdep.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64fbsd-nat.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64nbsd-tdep.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64nbsd-nat.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64obsd-tdep.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* amd64obsd-nat.c: Include "amd64-tdep.h" instead of
"x86-64-tdep.h".
* configure.host: (x86_64-*-linux*): Set gdb_target to linux64.
* configure.tgt (x86_64-*-linux*): Set gdb_target to linux64.
* Makefile.in (amd64_linux_tdep_h): Renamed from
x86_64_linux_tdep_h.
(amd64_tdep_h): Renamed from x86_64_tdep_h.
(amd64bsd-nat.o, amd64fbsd-nat.o, amd64fbsd-tdep.o, amd64-nat.o)
(amd64nbsd-nat.o, amd64nbsd-tdep.o, amd64obsd-nat.o)
(amd64obsd-tdep.o): Update dependencies.
(amd64-tdep.o, amd64-linux-nat.o, amd64-linux-tdep.o): New
dependencies.
(x86-64-linux-nat.o, x86-64-linux-tdep.o, x86-64-tdep.o): Remove
dependencies.
(ALLDEPFILES): Add amd64-tdep.c, amd64obsd-nat.c, amd64obsd-nat.c,
amd64-linux-nat.c amd64-linux-tdep.c.
* config/i386/tm-linux64.h: Renamed from tm-x86-64linux.h
* config/i386/nm-linux64.h: Renamed from nm-x86-64linux.h.
* config/i386/linux64.mt: Renamed from x86-64linux.mt.
(TDEPFILES): Replace x86-64-tdep.o and x86-64-linux-tdep.o with
amd64-tdep.o and amd64-linux-tdep.o.
(TM_FILE): Set to tm-linux64.h.
* config/i386/linux64.mh: Renamed from x86-64linux.mh.
(NAT_FILE): Set to nm-linux64.h.
(NATDEPFILES): Replace x86-64-linux-nat.o with amd64-linux-nat.o.
* config/i386/fbsd64.mt (TDEPFILES): Replace x86-64-tdep.o with
amd64-tdep.o.
* config/i386/nbsd64.mt (TDEPFILES): Replace x86-64-tdep.o with
amd64-tdep.o.
* config/i386/obsd64.mt (TDEPFILES): Replace x86-64-tdep.o with
amd64-tdep.o.
@
text
@/* Native-dependent code for GNU/Linux x86-64.

   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
   Contributed by Jiri Smid, SuSE Labs.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "inferior.h"
#include "gdbcore.h"
#include "regcache.h"
#include "linux-nat.h"

#include "gdb_assert.h"
#include "gdb_string.h"
#include <sys/ptrace.h>
#include <sys/debugreg.h>
#include <sys/syscall.h>
#include <sys/procfs.h>
#include <asm/prctl.h>
/* FIXME ezannoni-2003-07-09: we need <sys/reg.h> to be included after
   <asm/ptrace.h> because the latter redefines FS and GS for no apparent
   reason, and those definitions don't match the ones that libpthread_db
   uses, which come from <sys/reg.h>.  */
/* ezannoni-2003-07-09: I think this is fixed. The extraneous defs have
   been removed from ptrace.h in the kernel.  However, better safe than
   sorry.  */
#include <asm/ptrace.h>
#include <sys/reg.h>
#include "gdb_proc_service.h"

/* Prototypes for supply_gregset etc.  */
#include "gregset.h"

#include "x86-64-tdep.h"
#include "x86-64-linux-tdep.h"
#include "i386-linux-tdep.h"
#include "amd64-nat.h"

/* Mapping between the general-purpose registers in GNU/Linux x86-64
   `struct user' format and GDB's register cache layout.  */

static int amd64_linux_gregset64_reg_offset[] =
{
  RAX * 8, RBX * 8,		/* %rax, %rbx */
  RCX * 8, RDX * 8,		/* %rcx, %rdx */
  RSI * 8, RDI * 8,		/* %rsi, %rdi */
  RBP * 8, RSP * 8,		/* %rbp, %rsp */
  R8 * 8, R9 * 8,		/* %r8 ... */
  R10 * 8, R11 * 8,
  R12 * 8, R13 * 8,
  R14 * 8, R15 * 8,		/* ... %r15 */
  RIP * 8, EFLAGS * 8,		/* %rip, %eflags */
  CS * 8, SS * 8,		/* %cs, %ss */
  DS * 8, ES * 8,		/* %ds, %es */
  FS * 8, GS * 8		/* %fs, %gs */
};


/* Mapping between the general-purpose registers in GNU/Linux x86-64
   `struct user' format and GDB's register cache layout for GNU/Linux
   i386.

   Note that most GNU/Linux x86-64 registers are 64-bit, while the
   GNU/Linux i386 registers are all 32-bit, but since we're
   little-endian we get away with that.  */

/* From <sys/reg.h> on GNU/Linux i386.  */
static int amd64_linux_gregset32_reg_offset[] =
{
  RAX * 8, RCX * 8,		/* %eax, %ecx */
  RDX * 8, RBX * 8,		/* %edx, %ebx */
  RSP * 8, RBP * 8,		/* %esp, %ebp */
  RSI * 8, RDI * 8,		/* %esi, %edi */
  RIP * 8, EFLAGS * 8,		/* %eip, %eflags */
  CS * 8, SS * 8,		/* %cs, %ss */
  DS * 8, ES * 8,		/* %ds, %es */
  FS * 8, GS * 8,		/* %fs, %gs */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1,
  ORIG_RAX * 8			/* "orig_eax" */
};

/* Which ptrace request retrieves which registers?
   These apply to the corresponding SET requests as well.  */

#define GETFPREGS_SUPPLIES(regno) \
  (FP0_REGNUM <= (regno) && (regno) <= MXCSR_REGNUM)


/* Transfering the general-purpose registers between GDB, inferiors
   and core files.  */

/* Fill GDB's register cache with the general-purpose register values
   in *GREGSETP.  */

void
supply_gregset (elf_gregset_t *gregsetp)
{
  amd64_supply_native_gregset (current_regcache, gregsetp, -1);
}

/* Fill register REGNUM (if it is a general-purpose register) in
   *GREGSETP with the value in GDB's register cache.  If REGNUM is -1,
   do this for all registers.  */

void
fill_gregset (elf_gregset_t *gregsetp, int regnum)
{
  amd64_collect_native_gregset (current_regcache, gregsetp, regnum);
}

/* Fetch all general-purpose registers from process/thread TID and
   store their values in GDB's register cache.  */

static void
fetch_regs (int tid)
{
  elf_gregset_t regs;

  if (ptrace (PTRACE_GETREGS, tid, 0, (long) &regs) < 0)
    perror_with_name ("Couldn't get registers");

  supply_gregset (&regs);
}

/* Store all valid general-purpose registers in GDB's register cache
   into the process/thread specified by TID.  */

static void
store_regs (int tid, int regnum)
{
  elf_gregset_t regs;

  if (ptrace (PTRACE_GETREGS, tid, 0, (long) &regs) < 0)
    perror_with_name ("Couldn't get registers");

  fill_gregset (&regs, regnum);

  if (ptrace (PTRACE_SETREGS, tid, 0, (long) &regs) < 0)
    perror_with_name ("Couldn't write registers");
}


/* Transfering floating-point registers between GDB, inferiors and cores.  */

/* Fill GDB's register cache with the floating-point and SSE register
   values in *FPREGSETP.  */

void
supply_fpregset (elf_fpregset_t *fpregsetp)
{
  amd64_supply_fxsave (current_regcache, -1, fpregsetp);
}

/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FPREGSETP with the value in GDB's register cache.  If REGNUM is
   -1, do this for all registers.  */

void
fill_fpregset (elf_fpregset_t *fpregsetp, int regnum)
{
  amd64_fill_fxsave ((char *) fpregsetp, regnum);
}

/* Fetch all floating-point registers from process/thread TID and store
   thier values in GDB's register cache.  */

static void
fetch_fpregs (int tid)
{
  elf_fpregset_t fpregs;

  if (ptrace (PTRACE_GETFPREGS, tid, 0, (long) &fpregs) < 0)
    perror_with_name ("Couldn't get floating point status");

  supply_fpregset (&fpregs);
}

/* Store all valid floating-point registers in GDB's register cache
   into the process/thread specified by TID.  */

static void
store_fpregs (int tid, int regnum)
{
  elf_fpregset_t fpregs;

  if (ptrace (PTRACE_GETFPREGS, tid, 0, (long) &fpregs) < 0)
    perror_with_name ("Couldn't get floating point status");

  fill_fpregset (&fpregs, regnum);

  if (ptrace (PTRACE_SETFPREGS, tid, 0, (long) &fpregs) < 0)
    perror_with_name ("Couldn't write floating point status");
}


/* Transferring arbitrary registers between GDB and inferior.  */

/* Fetch register REGNUM from the child process.  If REGNUM is -1, do
   this for all registers (including the floating point and SSE
   registers).  */

void
fetch_inferior_registers (int regnum)
{
  int tid;

  /* GNU/Linux LWP ID's are process ID's.  */
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */

  if (regnum == -1 || amd64_native_gregset_supplies_p (regnum))
    {
      fetch_regs (tid);
      if (regnum != -1)
	return;
    }

  if (regnum == -1 || GETFPREGS_SUPPLIES (regnum))
    {
      fetch_fpregs (tid);
      return;
    }

  internal_error (__FILE__, __LINE__,
		  "Got request for bad register number %d.", regnum);
}

/* Store register REGNUM back into the child process.  If REGNUM is
   -1, do this for all registers (including the floating-point and SSE
   registers).  */

void
store_inferior_registers (int regnum)
{
  int tid;

  /* GNU/Linux LWP ID's are process ID's.  */
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */

  if (regnum == -1 || amd64_native_gregset_supplies_p (regnum))
    {
      store_regs (tid, regnum);
      if (regnum != -1)
	return;
    }

  if (regnum == -1 || GETFPREGS_SUPPLIES (regnum))
    {
      store_fpregs (tid, regnum);
      return;
    }

  internal_error (__FILE__, __LINE__,
		  "Got request to store bad register number %d.", regnum);
}


static unsigned long
amd64_linux_dr_get (int regnum)
{
  int tid;
  unsigned long value;

  /* FIXME: kettenis/2001-01-29: It's not clear what we should do with
     multi-threaded processes here.  For now, pretend there is just
     one thread.  */
  tid = PIDGET (inferior_ptid);

  /* FIXME: kettenis/2001-03-27: Calling perror_with_name if the
     ptrace call fails breaks debugging remote targets.  The correct
     way to fix this is to add the hardware breakpoint and watchpoint
     stuff to the target vectore.  For now, just return zero if the
     ptrace call fails.  */
  errno = 0;
  value = ptrace (PT_READ_U, tid,
		  offsetof (struct user, u_debugreg[regnum]), 0);
  if (errno != 0)
#if 0
    perror_with_name ("Couldn't read debug register");
#else
    return 0;
#endif

  return value;
}

static void
amd64_linux_dr_set (int regnum, unsigned long value)
{
  int tid;

  /* FIXME: kettenis/2001-01-29: It's not clear what we should do with
     multi-threaded processes here.  For now, pretend there is just
     one thread.  */
  tid = PIDGET (inferior_ptid);

  errno = 0;
  ptrace (PT_WRITE_U, tid, offsetof (struct user, u_debugreg[regnum]), value);
  if (errno != 0)
    perror_with_name ("Couldn't write debug register");
}

void
amd64_linux_dr_set_control (unsigned long control)
{
  amd64_linux_dr_set (DR_CONTROL, control);
}

void
amd64_linux_dr_set_addr (int regnum, CORE_ADDR addr)
{
  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);

  amd64_linux_dr_set (DR_FIRSTADDR + regnum, addr);
}

void
amd64_linux_dr_reset_addr (int regnum)
{
  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);

  amd64_linux_dr_set (DR_FIRSTADDR + regnum, 0L);
}

unsigned long
amd64_linux_dr_get_status (void)
{
  return amd64_linux_dr_get (DR_STATUS);
}


ps_err_e
ps_get_thread_area (const struct ps_prochandle *ph,
                    lwpid_t lwpid, int idx, void **base)
{
/* This definition comes from prctl.h, but some kernels may not have it.  */
#ifndef PTRACE_ARCH_PRCTL
#define PTRACE_ARCH_PRCTL      30
#endif

  /* FIXME: ezannoni-2003-07-09 see comment above about include file order.
     We could be getting bogus values for these two.  */
  gdb_assert (FS < ELF_NGREG);
  gdb_assert (GS < ELF_NGREG);
  switch (idx)
    {
    case FS:
      if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_FS) == 0)
	return PS_OK;
      break;
    case GS:
      if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_GS) == 0)
	return PS_OK;
      break;
    default:                   /* Should not happen.  */
      return PS_BADADDR;
    }
  return PS_ERR;               /* ptrace failed.  */
}


void
child_post_startup_inferior (ptid_t ptid)
{
  i386_cleanup_dregs ();
  linux_child_post_startup_inferior (ptid);
}


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_amd64_linux_nat (void);

void
_initialize_amd64_linux_nat (void)
{
  amd64_native_gregset32_reg_offset = amd64_linux_gregset32_reg_offset;
  amd64_native_gregset32_num_regs = I386_LINUX_NUM_REGS;
  amd64_native_gregset64_reg_offset = amd64_linux_gregset64_reg_offset;

  gdb_assert (ARRAY_SIZE (amd64_linux_gregset32_reg_offset)
	      == amd64_native_gregset32_num_regs);
  gdb_assert (ARRAY_SIZE (amd64_linux_gregset64_reg_offset)
	      == amd64_native_gregset64_num_regs);
}
@


1.34
log
@* x86-64-tdep.h: Tewak comment.
(enum amd64_regnum): New.
(X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, X86_64_RDI_REGNUM)
(X86_64_RBP_REGNUM, X86_64_RSP_REGNUM, X86_64_RIP_REGNUM)
(X86_64_EFLAGS_REGNUM, X86_64_ST0_REGNUM, X86_64_XMM0_REGNUM)
(X86_64_XMM1_REGNUM): Removed.
(AMD64_NUM_GREGS): Renamed from X86_64_NUM_GREGS.
(amd64_init_abi, amd64_supply_fxsave, amd64_fill_fxsave): Adjust
prototypes for renamed functions.
* x86-64-tdep.c: Fix typo.
(amd64_dwarf_regmap): Use constants from `enum amd64_regnum' for
register numbers.
(amd64_return_value, amd64_push_arguments, amd64_push_dummy_call):
Use constants from `enum amd64_regnum' for register numbers.
(AMD64_NUM_SAVED_REGS): Adjust for renamed macros.
(amd64_analyze_prologue, amd64_frame_cache,
amd64_sigtramp_frame_cache): Use constants from `enum
amd64_regnum' for register numbers.
(amd64_supply_fpregset): Adjust for renamed functions.
(amd64_init_abi): Rename from x86_64_init_abi.  Use constants from
`enum amd64_regnum' for register numbers.
(I387_ST0_REGNUM): Use constant from `enum amd64_regnum'.
(amd64_supply_fxsave): Rename from x86_64_supply_fxsave.
(amd64_fill_fxsave): Rename fro x86_64_fill_fxsave.
* x86-64-linux-tdep.c (amd64_linux_supply_gregset)
(amd64_linux_fill_gregset): Adjust for renamed macros.
(fetch_core_registers): Adjust for renamed functions.
(amd64_linux_init_abi): Adjust for renamed functions.
* x86-64-linux-nat.c (supply_gregset, fill_gregset): Adjust for
renamed functions.
* amd64-nat.c: Adjust for renamed macros.
* amd64bsd-nat.c (fetch_inferior_registers)
(store_inferior_registers): Use constants from `enum amd64_regnum'
for register numbers.  Adjust for renamed variables.
* amd64fbsd-nat.c (supply_gregset, fill_gregset): Adjust for
renamed variables.
(_initialize_amd64fbsd_nat): Use constants from `enum
amd64_regnum' for register numbers.
* amd64fbsd-tdep.c (amd64fbsd_sigcontext_addr): Use constants from
`enum amd64_regnum' for register numbers.
(amd64fbsd_init_abi): Adjust for renamed functions.
* amd64nbsd-tdep.c (amd64nbsd_sigcontext_addr): Use constants from
`enum amd64_regnum' for register numbers.
(amd64nbsd_init_abi): Adjust for renamed functions.
(_initialize_amd64nbsd_ndep): Adjust for renamed macros.
* amd64obsd-tdep.c (amd64obsd_sigcontext_addr): Use constants from
`enum amd64_regnum' for register numbers.
(amd64obsd_init_abi): Adjust for renamed functions.
(_initialize_amd64obsd_ndep): Adjust for renamed macros.
@
text
@@


1.33
log
@* x86-64-linux-nat.c (amd64_linux_gregset64_reg_offset): Rename
from x86_64_linux_gregset64_reg_offset.
(amd64_linux_gregset32_reg_offset): Rename from
x86_64_linux_gregset64_reg_offset.
(amd64_linux_dr_get): Renamed from x86_64_linux_dr_get.
(amd64_linux_dr_set): Renamed from x86_64_linux_dr_set.
(amd64_linux_dr_set_control): Renamed from
x86_64_linux_dr_set_control.  Adjust for renamed functions.
(amd64_linux_dr_set_addr): Renamed from x86_64_linux_dr_set_addr.
Adjust for renamed functions.
(amd64_linux_dr_reset_addr): Renamed from
x86_64_linux_dr_reset_addr. Adjust for renamed functions.
(amd64_linux_dr_get_status): Renamed from
x86_64_linux_dr_get_status.  Adjust for renamed functions.
(_initialize_amd64_linux_nat): Renamed from
_initialize_x86_64_linux_nat.  Adjust for renamed variables and
functions.
* config/i386/nm-x86-64linux.h: Update copyright year.
Adjust for renamed functions.
@
text
@d169 1
a169 1
  x86_64_supply_fxsave (current_regcache, -1, fpregsetp);
d179 1
a179 1
  x86_64_fill_fxsave ((char *) fpregsetp, regnum);
@


1.32
log
@* x86-64-linux-nat.c (x86_64_linux_gregset32_reg_offset): Use
symbolic constants from <sys/reg.h> instead of hard-coded numbers.
@
text
@d58 1
a58 1
static int x86_64_linux_gregset64_reg_offset[] =
d84 1
a84 1
static int x86_64_linux_gregset32_reg_offset[] =
d280 1
a280 1
x86_64_linux_dr_get (int regnum)
d309 1
a309 1
x86_64_linux_dr_set (int regnum, unsigned long value)
d325 1
a325 1
x86_64_linux_dr_set_control (unsigned long control)
d327 1
a327 1
  x86_64_linux_dr_set (DR_CONTROL, control);
d331 1
a331 1
x86_64_linux_dr_set_addr (int regnum, CORE_ADDR addr)
d335 1
a335 1
  x86_64_linux_dr_set (DR_FIRSTADDR + regnum, addr);
d339 1
a339 1
x86_64_linux_dr_reset_addr (int regnum)
d343 1
a343 1
  x86_64_linux_dr_set (DR_FIRSTADDR + regnum, 0L);
d347 1
a347 1
x86_64_linux_dr_get_status (void)
d349 1
a349 1
  return x86_64_linux_dr_get (DR_STATUS);
d392 1
a392 1
void _initialize_x86_64_linux_nat (void);
d395 1
a395 1
_initialize_x86_64_linux_nat (void)
d397 1
a397 1
  amd64_native_gregset32_reg_offset = x86_64_linux_gregset32_reg_offset;
d399 1
a399 1
  amd64_native_gregset64_reg_offset = x86_64_linux_gregset64_reg_offset;
d401 1
a401 1
  gdb_assert (ARRAY_SIZE (x86_64_linux_gregset32_reg_offset)
d403 1
a403 1
  gdb_assert (ARRAY_SIZE (x86_64_linux_gregset64_reg_offset)
@


1.31
log
@* x86-64-tdep.c (amd64_register_info): Add %cs and %ss.  Adjust
register numbers in comments.
* x86-64-tdep.h: Update copyright year.
(X86_64_ST0_REGNUM, X86_64_XMM0_REGNUM, X86_64_XMM1_REGNUM):
Adjust for addition of %cs and %ss.
* amd64fbsd-nat.c: Update copyright year.
(reg_offset): Add register offsets for %cs and %ss.
* amd64fbsd-tdep.c: Update copyright year.
(amd64fbsd_r_reg_offset): Add register offsets for %cs and %ss.
(amd64fbsd_sc_reg_offset): Likewise.
* x86-64-linux-nat.c: Update copyright year.
(x86_64_linux_gregset64_reg_offset): Add register offsets for %cs
and %ss.
* amd64nbsd-nat.c: Update copyright year.
(amd64nbsd32_r_reg_offset): Add register offsets for %cs and %ss.
* amd64nbsd-tdep.c: Update copyright year.
(amd64nbsd_r_reg_offset): Add register offsets for %cs and %ss.
* x86-64-linux-tdep.c: Update copyright year.
(user_to_gdb_regmap): Add mapping for %cs and %ss.
(x86_64_linux_sc_reg_offset): Adjust for addition of %cs and %ss.
* regformats/reg-x86-64.dat: Add %cs and %ss.
@
text
@d86 8
a93 8
  10 * 8, 11 * 8,		/* %eax, %ecx */
  12 * 8, 13 * 8,		/* %edx, %ebx */
  19 * 8, 4 * 8,		/* %esp, %ebp */
  13 * 8, 14 * 8,		/* %esi, %edi */
  16 * 8, 18 * 8,		/* %eip, %eflags */
  17 * 8, 20 * 8,		/* %cs, %ss */
  23 * 8, 24 * 8,		/* %ds, %es */
  25 * 4, 26 * 4,		/* %fs, %gs */
d97 1
a97 1
  15 * 8			/* "orig_eax" */
@


1.31.6.1
log
@Merge mainline to intercu branch.
@
text
@@


1.30
log
@* i387-tdep.c (i387_supply_fsave, i387_supply_fxsave): Add
regcache argument and reverse the order of the other two
arguments.  Remove local regcache variable.  Determine
architecture from REGCACHE.  Update comments.
* x86-64-tdep.c (x86_64_supply_fxsave): Add regcache argument and
reverse the order of the other two arguments.  Remove local
regcache variable.  Determine architecture from REGCACHE.  Update
comments.
* i387-tdep.h (i387_supply_fsave, i387_supply_fxsave): Adjust
prototypes.  Update comments.
* x86-64-tdep.c (x86_64_supply_fxsave): Adjust prototype.  Adjust
comment.
* amd64fbsd-nat.c (supply_fpregset, fetch_inferior_registers):
Update.
* go32-nat.c (fetch_register, go32_fetch_registers): Update.
* i386-interix-nat.c (supply_fpregset): Update.
* i386-linux-nat.c (supply_fpregset, supply_fpxregset): Update.
* i386-nto-tdep.c (i386nto_supply_fpregset): Update.
* i386gnu-nat.c (fetch_fpregs, supply_fpregset): Update.
* i386bsd-nat.c (supply_fpregset, fetch_inferior_registers): Update.
* i386nbsd-tdep.c (fetch_core_registers, fetch_elfcore_registers):
Update.
* i386obsd-tdep.c (fetch_core_registers): Update.
* i386v4-nat.c (supply_fpregset): Update.
* x86-64-linux-nat.c (supply_fpregset): Update.
* x86-64-linux-tdep.c (fetch_core_registers): Update.
@
text
@d3 1
a3 2
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.

d69 1
@


1.29
log
@* i386-linux-nat.c (ps_get_thread_area): Don't define as extern.
Only define PTRACE_GET_THREAD_AREA is not already defined.
Various style fixes in code and comments and some additional
spelling fixes in comments.  Move after functions dealing with
debug registers.
* x86-64-linux-nat.c (ps_get_thread_area): Don't define as extern.
Fix coding-style.
@
text
@d169 1
a169 1
  x86_64_supply_fxsave ((const char *) fpregsetp, -1);
@


1.28
log
@* i386-linux-tdep.h (I386_LINUX_NUM_REGS): New define.
* x86-64-linux-nat.c: Include "i386-linux-tdep.h" and "amd64.h".
Change "register array" to "register cache" in comments.
(x86_64_linux_gregset64_reg_offset): New variable.
(GETREGS_SUPPLIES): Remove macro.
(supply_gregset): Call amd64_supply_native_gregset instead of
x86_64_linux_supply_gregset.
(fill_gregset): Rename `regno' to `regnum'.  Call
amd64_collect_native_gregset instead of x86_64_linux_fill_gregset.
(store_regs): Rename `regno' to `regnum'.
(store_fpregs): Rename `regno' to `regnum'.
(fetch_inferior_registers): Rename `regno' to `regnum'.  Use
amd64_native_gregset_supplies_p instead of GREGSET_SUPPLIES.
Reorganize function a bit.
(store_inferior_registers): Rename `regno' to `regnum'.  Use
amd64_native_gregset_supplies_p instead of GREGSET_SUPPLIES.
Reorganize function a bit.
(_initialize_x86_64_linux_nat): New function.
* config/i386/x86-64linux.mh.
@
text
@d351 1
d353 1
a353 1
extern ps_err_e
a356 1

d370 1
a370 1
       return PS_OK;
d374 1
a374 1
       return PS_OK;
d381 1
@


1.27
log
@* x86-64-tdep.c (x86_64_supply_fxsave): Add `regnum' argument.
Update comments.
* x86-64-tdep.h (x86_64_supply_fxsave): Adjust prototype.  Update
comments.
* x86-64-linux-tdep.c (fetch_core_registers): Adjust call to
x86_64_supply_fxsave.
* x86-64-linux-nat.c (supply_fpregset): Adjust call to
x86_64_supply_fxsave.
* amd64fbsd-nat.c (supply_fpregset): Adjust call to
x86_64_supply_fxsave.
@
text
@d53 46
a102 3
#define GETREGS_SUPPLIES(regno) \
  (0 <= (regno) && (regno) < X86_64_NUM_GREGS)

d110 1
a110 1
/* Fill GDB's register array with the general-purpose register values
d116 1
a116 1
  x86_64_linux_supply_gregset ((char *) gregsetp);
d119 2
a120 2
/* Fill register REGNO (if it is a general-purpose register) in
   *GREGSETPS with the value in GDB's register array.  If REGNO is -1,
d124 1
a124 1
fill_gregset (elf_gregset_t *gregsetp, int regno)
d126 1
a126 1
  x86_64_linux_fill_gregset ((char *) gregsetp, regno);
d130 1
a130 1
   store their values in GDB's register array.  */
d143 1
a143 1
/* Store all valid general-purpose registers in GDB's register array
d147 1
a147 1
store_regs (int tid, int regno)
d154 1
a154 1
  fill_gregset (&regs, regno);
d163 1
a163 1
/* Fill GDB's register array with the floating-point and SSE register
d173 1
a173 1
   *FPREGSETP with the value in GDB's register array.  If REGNUM is
d183 1
a183 1
   thier values in GDB's register array.  */
d196 1
a196 1
/* Store all valid floating-point registers in GDB's register array
d200 1
a200 1
store_fpregs (int tid, int regno)
d207 1
a207 1
  fill_fpregset (&fpregs, regno);
d216 1
a216 1
/* Fetch register REGNO from the child process.  If REGNO is -1, do
d221 1
a221 1
fetch_inferior_registers (int regno)
d230 1
a230 8
  if (regno == -1)
    {
      fetch_regs (tid);
      fetch_fpregs (tid);
      return;
    }

  if (GETREGS_SUPPLIES (regno))
d233 2
a234 1
      return;
d237 1
a237 1
  if (GETFPREGS_SUPPLIES (regno))
d244 1
a244 1
		  "Got request for bad register number %d.", regno);
d247 2
a248 2
/* Store register REGNO back into the child process.  If REGNO is -1,
   do this for all registers (including the floating-point and SSE
d252 1
a252 1
store_inferior_registers (int regno)
d261 1
a261 8
  if (regno == -1)
    {
      store_regs (tid, regno);
      store_fpregs (tid, regno);
      return;
    }

  if (GETREGS_SUPPLIES (regno))
d263 3
a265 2
      store_regs (tid, regno);
      return;
d268 1
a268 1
  if (GETFPREGS_SUPPLIES (regno))
d270 1
a270 1
      store_fpregs (tid, regno);
d275 1
a275 1
		  "Got request to store bad register number %d.", regno);
d387 17
@


1.26
log
@2003-08-18  Michal Ludvig  <mludvig@@suse.cz>

	* config/i386/nm-x86-64linux.h (LINUX_CHILD_POST_STARTUP_INFERIOR):
	Define.
	* i386-linux-nat.c: Include "linux-nat.h".
	(child_post_startup_inferior): New function.
@
text
@d126 1
a126 1
  x86_64_supply_fxsave ((char *) fpregsetp);
@


1.26.2.1
log
@2003-08-21  Andrew Cagney  <cagney@@redhat.com>

	* x86-64-tdep.h (enum x86_64_regnums): Replace #define of
	X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, X86_64_RDI_REGNUM,
	X86_64_RBP_REGNUM, X86_64_RSP_REGNUM, X86_64_RIP_REGNUM,
	X86_64_EFLAGS_REGNUM, X86_64_ST0_REGNUM, X86_64_XMM0_REGNUM,
	X86_64_XMM1_REGNUM.
	* x86-64-linux-tdep.h (x86_64_linux_greg_offset): Declare.
	(x86_64_linux_supply_gregset): Add "sizeof_gregs" param.
	(x86_64_linux_fill_gregset): Add "sizeof_gregs" param.
	* x86-64-linux-tdep.c: Include "gdb_assert.h" and
	"i386-linux-tdep.h".
	(enum user_regs): Replace user reg #defines, add USER_ORIG_RAX,
	USER_FS_BASE and USER_GS_BASE.
	(struct regnum_map, struct regnum_to_user): Define.
	(x86_64_linux_greg_offset): New function.
	(user_to_gdb_regmap): Delete.
	(x86_64_linux_supply_gregset, x86_64_linux_fill_gregset): Use
	x86_64_linux_greg_offset.
	(x86_64_core_sniffer): New function
	(x86_64_core_fns): Set the sniffer to x86_64_core_sniffer.
	(fetch_core_registers): Pass "core_reg_size" to the supply
	functions.
	* x86-64-linux-nat.c (GETREGS_SUPPLIES): Delete macro.
	(fetch_inferior_registers): Use x86_64_linux_greg_offset.
	(store_inferior_registers): Ditto.
	* Makefile.in (x86-64-linux-tdep.o): Update dependencies.
@
text
@d57 3
d62 1
d194 1
a194 1
  if (x86_64_linux_greg_offset (regno) >= 0)
d231 1
a231 1
  if (x86_64_linux_greg_offset (regno) >= 0)
@


1.26.2.2
log
@2003-08-21  Andrew Cagney  <cagney@@redhat.com>

	* x86-64-linux-nat.c (ps_get_thread_area): When architecture is
	i386 use PTRACE_GET_THREAD_AREA.  Suggested by Roland McGrath.
@
text
@a316 3
/* This function is called by libthread_db as part of its handling of
   a request for a thread's local storage address.  */

d322 1
a322 32
  switch (TARGET_ARCHITECTURE->mach)
    {
    case bfd_mach_i386_i386:
    case bfd_mach_i386_i386_intel_syntax:
      {
	/* The full structure is found in <asm-i386/ldt.h>.  The
	   second integer is the LDT's base_address and that is used
	   to locate the thread's local storage.  See i386-linux-nat.c
	   more info.  */
	unsigned int desc[4];

	/* This code assumes that "int" is 32 bits and that
           GET_THREAD_AREA returns no more than 4 int values.  */
	gdb_assert (sizeof (int) == 4);	
#ifndef PTRACE_GET_THREAD_AREA
#define PTRACE_GET_THREAD_AREA 25
#endif
	if  (ptrace (PTRACE_GET_THREAD_AREA, 
		     lwpid, (void *) (long) idx, (unsigned long) &desc) < 0)
	  return PS_ERR;
      
	/* Extend the value to 64 bits.  Here it's assumed that a
           "long" and a "void *" are the same.  */
	(*base) = (void *) (long) desc[1];
	return PS_OK;
      }

    case bfd_mach_x86_64:
    case bfd_mach_x86_64_intel_syntax:

      /* This definition comes from prctl.h, but some kernels may not
         have it.  */
d327 16
a342 23
      /* FIXME: ezannoni-2003-07-09 see comment above about include
	 file order.  We could be getting bogus values for these two.  */
      gdb_assert (FS < ELF_NGREG);
      gdb_assert (GS < ELF_NGREG);
      switch (idx)
	{
	case FS:
	  if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_FS) == 0)
	    return PS_OK;
	  break;
	case GS:
	  if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_GS) == 0)
	    return PS_OK;
	  break;
	default:                   /* Should not happen.  */
	  return PS_BADADDR;
	}
      return PS_ERR;               /* ptrace failed.  */
      
    case bfd_mach_i386_i8086:
      internal_error (__FILE__, __LINE__, "bad i8086 machine");
    default:
      internal_error (__FILE__, __LINE__, "bad_switch");
d344 1
@


1.25
log
@2003-07-17  Elena Zannoni  <ezannoni@@redhat.com>

	* Makefile.in (x86-64-linux-nat.o): Update dependencies.
	* x86-64-linux-nat.c (ps_get_thread_area): New function.  Add
	include of asm/prctl.h, asm/ptrace.h, and gdb_proc_service.h.
@
text
@d28 1
d351 6
@


1.24
log
@2003-07-15  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-linux-nat.c (regmap): Removed.
	(supply_gregset, fill_gregset): Call
	x86_64_linux_(fill,supply)_gregset functions.
	* x86-64-linux-tdep.c (USER_*): New defines.
	(user_to_gdb_regmap, x86_64_core_fns): New structure.
	(x86_64_linux_supply_gregset, x86_64_linux_fill_gregset):
	New functions.
	(fetch_core_registers): Ditto.
	(_initialize_x86_64_linux_tdep): Call add_core_fns().
	* x86-64-linux-tdep.h: New file.
	* config/i386/x86-64linux.mh (NATDEPFILES): Remove corelow.o
	and core-regset.o.
	* config/i386/x86-64linux.mt (TDEPFILES): Add corelow.o.
@
text
@d35 9
d45 1
d319 31
@


1.23
log
@	* x86-64-linux-nat.c: Fix comment.
@
text
@d41 1
a41 18

/* The register sets used in GNU/Linux ELF core-dumps are identical to
   the register sets used by `ptrace'.  The corresponding types are
   `elf_gregset_t' for the general-purpose registers (with
   `elf_greg_t' the type of a single GP register) and `elf_fpregset_t'
   for the floating-point registers.  */

/* Mapping between the general-purpose registers in `struct user'
   format and GDB's register array layout.  */
static int regmap[] =
{
  RAX, RBX, RCX, RDX,
  RSI, RDI, RBP, RSP,
  R8, R9, R10, R11,
  R12, R13, R14, R15,
  RIP, EFLAGS, CS, SS, 
  DS, ES, FS, GS
};
d62 1
a62 5
  elf_greg_t *regp = (elf_greg_t *) gregsetp;
  int i;

  for (i = 0; i < X86_64_NUM_GREGS; i++)
    supply_register (i, regp + regmap[i]);
d72 1
a72 6
  elf_greg_t *regp = (elf_greg_t *) gregsetp;
  int i;

  for (i = 0; i < X86_64_NUM_GREGS; i++)
    if (regno == -1 || regno == i)
      regcache_collect (i, regp + regmap[i]);
@


1.23.6.1
log
@2003-07-15  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-linux-nat.c (regmap): Removed.
	(supply_gregset, fill_gregset): Call
	x86_64_linux_(fill,supply)_gregset functions.
	* x86-64-linux-tdep.c (USER_*): New defines.
	(user_to_gdb_regmap, x86_64_core_fns): New structure.
	(x86_64_linux_supply_gregset, x86_64_linux_fill_gregset):
	New functions.
	(fetch_core_registers): Ditto.
	(_initialize_x86_64_linux_tdep): Call add_core_fns().
	* x86-64-linux-tdep.h: New file.
	* config/i386/x86-64linux.mh (NATDEPFILES): Remove corelow.o
	and core-regset.o.
	* config/i386/x86-64linux.mt (TDEPFILES): Add corelow.o.
@
text
@d41 18
a58 1
#include "x86-64-linux-tdep.h"
d79 5
a83 1
  x86_64_linux_supply_gregset ((char *) gregsetp);
d93 6
a98 1
  x86_64_linux_fill_gregset ((char *) gregsetp, regno);
@


1.23.6.2
log
@2003-07-17  Elena Zannoni  <ezannoni@@redhat.com>

	* Makefile.in (x86-64-linux-nat.o): Update dependencies.
	* x86-64-linux-nat.c (ps_get_thread_area): New function.  Add
	include of asm/prctl.h, asm/ptrace.h, and gdb_proc_service.h.
@
text
@a34 9
#include <asm/prctl.h>
/* FIXME ezannoni-2003-07-09: we need <sys/reg.h> to be included after
   <asm/ptrace.h> because the latter redefines FS and GS for no apparent
   reason, and those definitions don't match the ones that libpthread_db
   uses, which come from <sys/reg.h>.  */
/* ezannoni-2003-07-09: I think this is fixed. The extraneous defs have
   been removed from ptrace.h in the kernel.  However, better safe than
   sorry.  */
#include <asm/ptrace.h>
a35 1
#include "gdb_proc_service.h"
a308 31

extern ps_err_e
ps_get_thread_area (const struct ps_prochandle *ph,
                    lwpid_t lwpid, int idx, void **base)
{

/* This definition comes from prctl.h, but some kernels may not have it.  */
#ifndef PTRACE_ARCH_PRCTL
#define PTRACE_ARCH_PRCTL      30
#endif

  /* FIXME: ezannoni-2003-07-09 see comment above about include file order.
     We could be getting bogus values for these two.  */
  gdb_assert (FS < ELF_NGREG);
  gdb_assert (GS < ELF_NGREG);
  switch (idx)
    {
    case FS:
      if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_FS) == 0)
       return PS_OK;
      break;
    case GS:
      if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_GS) == 0)
       return PS_OK;
      break;
    default:                   /* Should not happen.  */
      return PS_BADADDR;
    }
  return PS_ERR;               /* ptrace failed.  */
}

@


1.23.6.3
log
@2003-08-18  Michal Ludvig  <mludvig@@suse.cz>

	* config/i386/nm-x86-64linux.h (LINUX_CHILD_POST_STARTUP_INFERIOR):
	Define.
	* i386-linux-nat.c: Include "linux-nat.h".
	(child_post_startup_inferior): New function.
@
text
@a27 1
#include "linux-nat.h"
a349 6
void
child_post_startup_inferior (ptid_t ptid)
{
  i386_cleanup_dregs ();
  linux_child_post_startup_inferior (ptid);
}
@


1.22
log
@* x86-64-tdep.h (x86_64_num_regs, x86_64_num_gregs): Remove
variable declarations.
(x86_64_register_number, x86_64_register_name): Remove prototypes.
(x86_64_linux_frame_saved_pc, x86_64_linux+saved_pc_after_call,
x86_64_linux_in_sigtramp, x86_64_linux_frame_chain,
x86_64_init_frame_pc, x86_64_init_frame_pc,
x86_64_function_has_prologue): Remove prototypes.
(X86_64_NUM_GREGS): New define.
(x86_64_supply_fxsave, x86_64_fill_fxsave): New prototypes.
* x86-64-tdep.c: Don't include "dwarf2cfi.h".  Include
"dummy_frame.h", "frame.h", "frame-base.h", "frame-unwind.h".
(RAX_REGNUM, RDX_REGNUM, RDI_REGNUM, EFLAGS_REGNUM, ST0_REGNUM,
XMM1_REGNUM): Remove defines.
(X86_64_RAX_REGNUM, X86_64_RDX_REGNUM, X86_64_RDI_REGNUM,
X86_64_RBP_REGNUM, X86_64_RSP_REGNUM, X86_64_RIP_REGNUM,
X86_64_EFLAGS_REGNUM, X86_64_ST0_REGNUM, X86_64_XMM0_REGNUM,
X86_64_XMM1_REGNUM): New defines.
(struct x86_64_register_info): Renamed from `struct
register_info'.  Remove `size' member.
(x86_64_register_info_table): Remove variable.
(x86_64_register_info): New variable.
(X86_64_NUM_REGS): New define.
(X86_64_NUM_GREGS): Remove define.
(x86_64_num_regs, x86_64_num_gregs): Remove variables.
(x86_64_dwarf2gdb_regno_map, x86_64_dwarf2gdb_regno_map_length):
Remove variables.
(x86_54_dwarf2_reg_to_regnum): Remove function.
(x86_64_dwarf_regmap, x86_64_dwarf_regmap_len): New variables.
(x86_64_dwarf_reg_to_regnum): New function.
(x86_64_register_name): Rewrite.
(x86_64_register_raw_size): Remove function.
(x86_64_register_byte_table): Remove variable.
(x86_64_register_byte): Remove function.
(x86_64_register_virtual_type): Remove function.
(x86_64_register_type): New function.
(x86_64_register_convertible, x86_64_register_convert_to_virtual,
x86_64_register_convert_to_raw): Remove functions.
(x86_64_push_return_address, x86_64_pop_frame): Remove functon.
(x86_64_use_struct_convention): Make static.  Adjust for renamed
defines.
(x86_64_frame_init_saved_regs): Remove function.
(x86_64_push_arguments): Make static.  Change to accept a regcache
as argument.
(x86_64_store_return_value, x86_64_extract_return_value): Make
static.  Rewrite based on i386 counterparts.
(x86_64_push_dummy_call): New function.
(X86_64_NUM_SAVED_REGS): New define.
(x86_64_register_number): Remove function.
(x86_64_store_struct_return): Remove function.
(x86_64_frameless_function_invocation,
x86_64_function_has_prologue): Remove functions.
(PROLOG_BUFSIZE): Remove define.
(struct x86_64_frame_cache): New structure.
(x86_64_alloc_frame_cache, x86_64_analyze_prologue,
x86_64_frame_cache, x86_64_frame_this_id,
x86_64_frame_prev_register, x86_64_frame_p,
x86_64_sigtramp_frame_cache, x86_64_sigtramp_frame_this_id,
x86_64_sigtramp_frame_prev_register, x86_sigtramp_frame_p): New
functions.
(x86_64_frame_unwind, x86_64_sigtramp_frame_unwind): New
variables.
(x86_64_skip_prologue): Rewrite in terms of
x86_64_analyze_prologue.
(x86_64_frame_base_address): New function.
(x86_64_frame_base): New variable.
(x86_64_save_dummy_frame_tos, x86_64_unwind_dummy_id): Rewrite.
(x86_64_init_abi): Set register_type and push_dummy_call.  Don't
set deprecated_fp_regnum, deprecated_register_size,
deprecated_register_bytes, register_raw_size, register_byte,
register_virtual_type, register_convertiable,
register_convert_to_virtual, convert_to_raw,
deprecated_get_saved_register, deprecated_target_read_fp,
deprecated_push_arguments, deprecated_push_return_address,
deprecated_pop_frame, deprecated_store_struct_return,
deprecated_frame_init_saved_regs, deprecated_frame_chain,
frameless_function_invocation, deprecated_frame_saved_pc,
deprecated_saved_pc_after_call, frame_num_args, pc_in_sigtramp,
dwarf2_build_frame_info, deprecated_init_extra_frame_info,
deprecated_init_frame_pc and virtual_frame_pointer.  Call
frame_unwind_append_predicate to register x86_64_sigtramp_frame_p
and x86_64_frame_p.  Call frame_base_set_default to register
x86_64_frame_base.
(I387_FISEG_REGNUM, I387_FOSEG_REGNUM): New defines.
(x86_64_supply_fxsave, x86_64_fill_fxsave): New functions.
(_initialize_x86_64_tdep): Remove function.
* x86-64-linux-tdep.c: Don't include "dwarf2cfi.h".
(LINUX_SIGINFO_SIZE, LINUX_UCONTEXT_SIGCONTEXT_OFFSET,
LINUX_SIGCONTEXT_PC_OFFSET, LINUX_SIGCONTEXT_FP_OFFSET): Don't
define.
(X86_64_LINUX_UCONTEXT_SIGCONTEXT_OFFSET): Define.
(x86_64_linux_sigcontext_addr): Rewrite.
(x86_64_linux_sigtramp_saved_pc, x86_64_linux_saved_pc_after_call,
x86_64_linux_frame_saved_pc): Remove functions.
(x86_64_linux_pc_in_sigtramp): Renamed from
x86_64_linux_in_sigtramp.  Try harder to recognize a signal
trampoline.
(x86_64_linux_frame_chain, x86_64_init_frame_pc):
Remove_functions.
(x86_64_linux_init_abi): Set pc_in_sigtramp.  Initialize
TDEP->sigcontext_addr, TDEP->sc_pc_offset and TDEP->sc_sp_offset.
* x86-64-linux-nat.c: Sync with i386-linux-tdep.c.
(x86_64_regmap): Rename to regmap.
(GETREGS_SUPPLIES): Use X86_64_NUM_GREGS instead of
x86_64_num_gregs.
(supply_gregset, fill_gregset): Likewise.  Use regmap instead of
x86_64_regmap.
(x86_64_fxsave_offset): Remove function.
(supply_fpregset): Simply call x86_64_supply_fxsave.
(fill_fpregset): Simply call x86_64_fill_fxsave.
(fetch_inferior_registers, store_inferior_registers): Avoid
asignment in if-statement.
(LINUX_SYSCALL_LEN, LINUX_SYSCALL_REGNUM, SYS_Sigreturn,
SYS_rt_sigreturn, LINUX_SIGCONTEXT_EFLAGS_OFFSET,
LINUX_UCONTEXT_SIGCONTEXT_OFFSET): Remove defines.
(fetch_core_registers): Remove function.
(linux_elf_core_fns): Remove.
(offsetoff): Don't define.
(_initialize_x86_64_linux_nat, kernel_u_size): Remove functions.
* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
* config/i386/x86-64linux.mh (NATDEPFILES): Remove core-aout.o,
add core-regset.o.
* config/i386/nm-x86-64linux.h: Use NM_X86_64_LINUX_H for
protection against multiple includes instead of NM_X86_64_h.  Add
various comments.  Include "config/nm-linux.h".  Don't include
<signal.h>.
(REGISTER_U_ADDR, KERNEL_U_SIZE, U_REGS_OFFSET, KERN_U_ADDR,
GET_THREAD_SIGNALS): Remove defines.
(x86_64_register_u_addr, kernel_u_size,
lin_thread_get_thread_signals): Remove prototypes.
(PTRACE_ARG3_TYPE, PTRACE_XFER_TYPE): Define to `long'.
[HAVE_LINK_H]: Don't include "solib.h".
[HAVE_LINK_H] (SVR4_SHARED_LIBS): Remove define.
* config/i386/tm-x86-64linux.h: Fix comments.
* Makefile.in (x86-64-linux-nat.o, x86_64-linux-tdep.o,
x86-64-tdep.o): Update dependencies.
@
text
@d46 1
a46 1
   for the floating-point registers.
@


1.21
log
@2003-02-12  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_extract_return_value)
	(x86_64_store_return_value): Use regcache instead of regbuf.
	(x86_64_gdbarch_init): Change related set_gdbarch_* functions.
	* x86-64-linux-nat.c (fill_gregset): Use regcache.
@
text
@d28 1
a30 2
#include "x86-64-tdep.h"

d37 11
d50 2
a51 2

static int x86_64_regmap[] = {
d60 2
a61 10
static unsigned long
x86_64_linux_dr_get (int regnum)
{
  int tid;
  unsigned long value;

  /* FIXME: kettenis/2001-01-29: It's not clear what we should do with
     multi-threaded processes here.  For now, pretend there is just
     one thread.  */
  tid = PIDGET (inferior_ptid);
d63 2
a64 22
  /* FIXME: kettenis/2001-03-27: Calling perror_with_name if the
     ptrace call fails breaks debugging remote targets.  The correct
     way to fix this is to add the hardware breakpoint and watchpoint
     stuff to the target vectore.  For now, just return zero if the
     ptrace call fails.  */
  errno = 0;
  value = ptrace (PT_READ_U, tid,
		  offsetof (struct user, u_debugreg[regnum]), 0);
  if (errno != 0)
#if 0
    perror_with_name ("Couldn't read debug register");
#else
    return 0;
#endif

  return value;
}

static void
x86_64_linux_dr_set (int regnum, unsigned long value)
{
  int tid;
a65 45
  /* FIXME: kettenis/2001-01-29: It's not clear what we should do with
     multi-threaded processes here.  For now, pretend there is just
     one thread.  */
  tid = PIDGET (inferior_ptid);

  errno = 0;
  ptrace (PT_WRITE_U, tid, offsetof (struct user, u_debugreg[regnum]), value);
  if (errno != 0)
    perror_with_name ("Couldn't write debug register");
}

void
x86_64_linux_dr_set_control (unsigned long control)
{
  x86_64_linux_dr_set (DR_CONTROL, control);
}

void
x86_64_linux_dr_set_addr (int regnum, CORE_ADDR addr)
{
  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);

  x86_64_linux_dr_set (DR_FIRSTADDR + regnum, addr);
}

void
x86_64_linux_dr_reset_addr (int regnum)
{
  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);

  x86_64_linux_dr_set (DR_FIRSTADDR + regnum, 0L);
}

unsigned long
x86_64_linux_dr_get_status (void)
{
  return x86_64_linux_dr_get (DR_STATUS);
}


/* The register sets used in GNU/Linux ELF core-dumps are identical to
   the register sets used by `ptrace'.  */

#define GETREGS_SUPPLIES(regno) \
  (0 <= (regno) && (regno) < x86_64_num_gregs)
d77 1
a77 1
supply_gregset (elf_gregset_t * gregsetp)
d82 2
a83 2
  for (i = 0; i < x86_64_num_gregs; i++)
    supply_register (i, (char *) (regp + x86_64_regmap[i]));
d91 1
a91 1
fill_gregset (elf_gregset_t * gregsetp, int regno)
d96 3
a98 3
  for (i = 0; i < x86_64_num_gregs; i++)
    if ((regno == -1 || regno == i))
      regcache_collect (i, (char *) (regp + x86_64_regmap[i]));
a134 28
static void *
x86_64_fxsave_offset (elf_fpregset_t * fxsave, int regnum)
{
  const char *reg_name;
  int reg_index;

  gdb_assert (x86_64_num_gregs - 1 < regnum && regnum < x86_64_num_regs);

  reg_name = x86_64_register_name (regnum);

  if (reg_name[0] == 's' && reg_name[1] == 't')
    {
      reg_index = reg_name[2] - '0';
      return &fxsave->st_space[reg_index * 2];
    }

  if (reg_name[0] == 'x' && reg_name[1] == 'm' && reg_name[2] == 'm')
    {
      reg_index = reg_name[3] - '0';
      return &fxsave->xmm_space[reg_index * 4];
    }

  if (strcmp (reg_name, "mxcsr") == 0)
    return &fxsave->mxcsr;

  return NULL;
}

d136 1
a136 2
   values in *FXSAVE.  This function masks off any of the reserved
   bits in *FXSAVE.  */
d139 1
a139 1
supply_fpregset (elf_fpregset_t * fxsave)
d141 1
a141 9
  int i, reg_st0, reg_mxcsr;

  reg_st0 = x86_64_register_number ("st0");
  reg_mxcsr = x86_64_register_number ("mxcsr");

  gdb_assert (reg_st0 > 0 && reg_mxcsr > reg_st0);

  for (i = reg_st0; i <= reg_mxcsr; i++)
    supply_register (i, x86_64_fxsave_offset (fxsave, i));
d145 2
a146 3
   *FXSAVE with the value in GDB's register array.  If REGNUM is -1, do
   this for all registers.  This function doesn't touch any of the
   reserved bits in *FXSAVE.  */
d149 1
a149 1
fill_fpregset (elf_fpregset_t * fxsave, int regnum)
d151 1
a151 13
  int i, last_regnum = MXCSR_REGNUM;
  void *ptr;

  if (gdbarch_tdep (current_gdbarch)->num_xmm_regs == 0)
    last_regnum = FOP_REGNUM;

  for (i = FP0_REGNUM; i <= last_regnum; i++)
    if (regnum == -1 || regnum == i)
      {
	ptr = x86_64_fxsave_offset (fxsave, i);
	if (ptr)
	  regcache_collect (i, ptr);
      }
d198 3
a200 2
  if ((tid = TIDGET (inferior_ptid)) == 0)
    tid = PIDGET (inferior_ptid);	/* Not a threaded program.  */
d226 1
a226 1
   do this for all registers (including the floating point and SSE
d228 1
d235 3
a237 2
  if ((tid = TIDGET (inferior_ptid)) == 0)
    tid = PIDGET (inferior_ptid);	/* Not a threaded program.  */
d263 5
a267 1
static const unsigned char linux_syscall[] = { 0x0f, 0x05 };
d269 4
a272 1
#define LINUX_SYSCALL_LEN (sizeof linux_syscall)
d274 14
a287 2
/* The system call number is stored in the %rax register.  */
#define LINUX_SYSCALL_REGNUM 0	/* %rax */
d289 2
a290 2
/* We are specifically interested in the sigreturn and rt_sigreturn
   system calls.  */
d292 4
a295 6
#ifndef SYS_sigreturn
#define SYS_sigreturn		__NR_sigreturn
#endif
#ifndef SYS_rt_sigreturn
#define SYS_rt_sigreturn	__NR_rt_sigreturn
#endif
d297 4
a300 15
/* Offset to saved processor flags, from <asm/sigcontext.h>.  */
#define LINUX_SIGCONTEXT_EFLAGS_OFFSET (152)
/* Offset to saved processor registers from <asm/ucontext.h> */
#define LINUX_UCONTEXT_SIGCONTEXT_OFFSET (36)

/* Interpreting register set info found in core files.  */
/* Provide registers to GDB from a core file.

   CORE_REG_SECT points to an array of bytes, which are the contents
   of a `note' from a core file which BFD thinks might contain
   register contents.  CORE_REG_SIZE is its size.

   WHICH says which register set corelow suspects this is:
     0 --- the general-purpose register set, in elf_gregset_t format
     2 --- the floating-point register set, in elf_fpregset_t format
d302 5
a306 1
   REG_ADDR isn't used on GNU/Linux.  */
d308 2
a309 3
static void
fetch_core_registers (char *core_reg_sect, unsigned core_reg_size,
		      int which, CORE_ADDR reg_addr)
d311 1
a311 30
  elf_gregset_t gregset;
  elf_fpregset_t fpregset;
  switch (which)
    {
    case 0:
      if (core_reg_size != sizeof (gregset))
	warning ("Wrong size gregset in core file.");
      else
	{
	  memcpy (&gregset, core_reg_sect, sizeof (gregset));
	  supply_gregset (&gregset);
	}
      break;

    case 2:
      if (core_reg_size != sizeof (fpregset))
	warning ("Wrong size fpregset in core file.");
      else
	{
	  memcpy (&fpregset, core_reg_sect, sizeof (fpregset));
	  supply_fpregset (&fpregset);
	}
      break;

    default:
      /* We've covered all the kinds of registers we know about here,
         so this must be something we wouldn't know what to do with
         anyway.  Just ignore it.  */
      break;
    }
d314 4
a317 1
/* Register that we are able to handle GNU/Linux ELF core file formats.  */
d319 1
a319 34
static struct core_fns linux_elf_core_fns = {
  bfd_target_elf_flavour,	/* core_flavour */
  default_check_format,		/* check_format */
  default_core_sniffer,		/* core_sniffer */
  fetch_core_registers,		/* core_read_registers */
  NULL				/* next */
};


#if !defined (offsetof)
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif

/* Return the address of register REGNUM.  BLOCKEND is the value of
   u.u_ar0, which should point to the registers.  */
CORE_ADDR
x86_64_register_u_addr (CORE_ADDR blockend, int regnum)
{
  struct user u;
  CORE_ADDR fpstate;
  CORE_ADDR ubase;
  ubase = blockend;
  if (IS_FP_REGNUM (regnum))
    {
      fpstate = ubase + ((char *) &u.i387.st_space - (char *) &u);
      return (fpstate + 16 * (regnum - FP0_REGNUM));
    }
  else if (IS_SSE_REGNUM (regnum))
    {
      fpstate = ubase + ((char *) &u.i387.xmm_space - (char *) &u);
      return (fpstate + 16 * (regnum - XMM0_REGNUM));
    }
  else
    return (ubase + 8 * x86_64_regmap[regnum]);
d323 1
a323 1
_initialize_x86_64_linux_nat (void)
d325 3
a327 1
  add_core_fns (&linux_elf_core_fns);
d330 2
a331 2
int
kernel_u_size (void)
d333 1
a333 1
  return (sizeof (struct user));
@


1.21.16.1
log
@Revise the x86_64 (sub)taget.
* x86-64-tdep.c, x86-64-linux-tdep.c, x86-64-linux-nat.c,
config/i386/tm-x86-64linux.h, config/i386/nm-x86-64linux.h,
config/i386/x86-64-linux.mt, config/i386/x86-64linux.mh: Extensive
changes.
@
text
@a27 1

d30 2
a37 11
/* Prototypes for supply_gregset etc.  */
#include "gregset.h"

#include "x86-64-tdep.h"

/* The register sets used in GNU/Linux ELF core-dumps are identical to
   the register sets used by `ptrace'.  The corresponding types are
   `elf_gregset_t' for the general-purpose registers (with
   `elf_greg_t' the type of a single GP register) and `elf_fpregset_t'
   for the floating-point registers.

d40 2
a41 2
static int regmap[] =
{
d50 76
a125 2
/* Which ptrace request retrieves which registers?
   These apply to the corresponding SET requests as well.  */
d128 1
a128 2
  (0 <= (regno) && (regno) < X86_64_NUM_GREGS)

d140 1
a140 1
supply_gregset (elf_gregset_t *gregsetp)
d145 2
a146 2
  for (i = 0; i < X86_64_NUM_GREGS; i++)
    supply_register (i, regp + regmap[i]);
d154 1
a154 1
fill_gregset (elf_gregset_t *gregsetp, int regno)
d159 3
a161 3
  for (i = 0; i < X86_64_NUM_GREGS; i++)
    if (regno == -1 || regno == i)
      regcache_collect (i, regp + regmap[i]);
d198 28
d227 2
a228 1
   values in *FPREGSETP.  */
d231 1
a231 1
supply_fpregset (elf_fpregset_t *fpregsetp)
d233 9
a241 1
  x86_64_supply_fxsave ((char *) fpregsetp);
d245 3
a247 2
   *FPREGSETP with the value in GDB's register array.  If REGNUM is
   -1, do this for all registers.  */
d250 1
a250 1
fill_fpregset (elf_fpregset_t *fpregsetp, int regnum)
d252 13
a264 1
  x86_64_fill_fxsave ((char *) fpregsetp, regnum);
d311 2
a312 3
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d338 1
a338 1
   do this for all registers (including the floating-point and SSE
a339 1

d346 2
a347 3
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d373 6
a378 5
static unsigned long
x86_64_linux_dr_get (int regnum)
{
  int tid;
  unsigned long value;
d380 2
a381 4
  /* FIXME: kettenis/2001-01-29: It's not clear what we should do with
     multi-threaded processes here.  For now, pretend there is just
     one thread.  */
  tid = PIDGET (inferior_ptid);
d383 5
a387 13
  /* FIXME: kettenis/2001-03-27: Calling perror_with_name if the
     ptrace call fails breaks debugging remote targets.  The correct
     way to fix this is to add the hardware breakpoint and watchpoint
     stuff to the target vectore.  For now, just return zero if the
     ptrace call fails.  */
  errno = 0;
  value = ptrace (PT_READ_U, tid,
		  offsetof (struct user, u_debugreg[regnum]), 0);
  if (errno != 0)
#if 0
    perror_with_name ("Couldn't read debug register");
#else
    return 0;
d390 17
a406 2
  return value;
}
d409 2
a410 1
x86_64_linux_dr_set (int regnum, unsigned long value)
d412 31
a442 1
  int tid;
d444 1
a444 4
  /* FIXME: kettenis/2001-01-29: It's not clear what we should do with
     multi-threaded processes here.  For now, pretend there is just
     one thread.  */
  tid = PIDGET (inferior_ptid);
d446 8
a453 5
  errno = 0;
  ptrace (PT_WRITE_U, tid, offsetof (struct user, u_debugreg[regnum]), value);
  if (errno != 0)
    perror_with_name ("Couldn't write debug register");
}
d455 3
a457 5
void
x86_64_linux_dr_set_control (unsigned long control)
{
  x86_64_linux_dr_set (DR_CONTROL, control);
}
d459 21
a479 6
void
x86_64_linux_dr_set_addr (int regnum, CORE_ADDR addr)
{
  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);

  x86_64_linux_dr_set (DR_FIRSTADDR + regnum, addr);
d483 1
a483 1
x86_64_linux_dr_reset_addr (int regnum)
d485 1
a485 3
  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);

  x86_64_linux_dr_set (DR_FIRSTADDR + regnum, 0L);
d488 2
a489 2
unsigned long
x86_64_linux_dr_get_status (void)
d491 1
a491 1
  return x86_64_linux_dr_get (DR_STATUS);
@


1.21.16.2
log
@2003-05-29  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-linux-nat.c: Fix nested comments.
@
text
@d46 1
a46 1
   for the floating-point registers.  */
@


1.20
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d161 1
a161 1
      deprecated_read_register_gen (i, (char *) (regp + x86_64_regmap[i]));
@


1.19
log
@2003-01-06  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-linux-nat.c (i386_sse_regnum_p): Deleted. Not needed anymore
	since it is in i386-tdep.c.
@
text
@d3 1
a3 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
@


1.18
log
@2002-11-15  Andrew Cagney  <cagney@@redhat.com>

	* x86-64-linux-nat.c (i386_sse_regnum_p): New function.  Copy from
	i386-tdep.c.
@
text
@a458 11
/* SSE register?  */
/* FIXME: cagney/2002-11-15: Once the i386 and x86-64 are integrated,
   this will go.  */

int
i386_sse_regnum_p (int regnum)
{
  return (regnum < NUM_REGS
	  && (XMM0_REGNUM <= (regnum) && (regnum) < MXCSR_REGNUM));
}

@


1.17
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d459 11
@


1.16
log
@2002-09-18  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-linux-nat.c (x86_64_regmap): Added CS and SS
	registers.
@
text
@d161 1
a161 1
      read_register_gen (i, (char *) (regp + x86_64_regmap[i]));
@


1.16.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
a27 2
#include "linux-nat.h"

d30 2
a35 9
#include <asm/prctl.h>
/* FIXME ezannoni-2003-07-09: we need <sys/reg.h> to be included after
   <asm/ptrace.h> because the latter redefines FS and GS for no apparent
   reason, and those definitions don't match the ones that libpthread_db
   uses, which come from <sys/reg.h>.  */
/* ezannoni-2003-07-09: I think this is fixed. The extraneous defs have
   been removed from ptrace.h in the kernel.  However, better safe than
   sorry.  */
#include <asm/ptrace.h>
a36 1
#include "gdb_proc_service.h"
d38 2
a39 2
/* Prototypes for supply_gregset etc.  */
#include "gregset.h"
d41 7
a47 21
#include "x86-64-tdep.h"
#include "x86-64-linux-tdep.h"
#include "i386-linux-tdep.h"
#include "amd64-nat.h"

/* Mapping between the general-purpose registers in GNU/Linux x86-64
   `struct user' format and GDB's register cache layout.  */

static int x86_64_linux_gregset64_reg_offset[] =
{
  RAX * 8, RBX * 8,		/* %rax, %rbx */
  RCX * 8, RDX * 8,		/* %rcx, %rdx */
  RSI * 8, RDI * 8,		/* %rsi, %rdi */
  RBP * 8, RSP * 8,		/* %rbp, %rsp */
  R8 * 8, R9 * 8,		/* %r8 ... */
  R10 * 8, R11 * 8,
  R12 * 8, R13 * 8,
  R14 * 8, R15 * 8,		/* ... %r15 */
  RIP * 8, EFLAGS * 8,		/* %rip, %eflags */
  DS * 8, ES * 8,		/* %ds, %es */
  FS * 8, GS * 8		/* %fs, %gs */
d49 73
d124 2
a125 27
/* Mapping between the general-purpose registers in GNU/Linux x86-64
   `struct user' format and GDB's register cache layout for GNU/Linux
   i386.

   Note that most GNU/Linux x86-64 registers are 64-bit, while the
   GNU/Linux i386 registers are all 32-bit, but since we're
   little-endian we get away with that.  */

/* From <sys/reg.h> on GNU/Linux i386.  */
static int x86_64_linux_gregset32_reg_offset[] =
{
  10 * 8, 11 * 8,		/* %eax, %ecx */
  12 * 8, 13 * 8,		/* %edx, %ebx */
  19 * 8, 4 * 8,		/* %esp, %ebp */
  13 * 8, 14 * 8,		/* %esi, %edi */
  16 * 8, 18 * 8,		/* %eip, %eflags */
  17 * 8, 20 * 8,		/* %cs, %ss */
  23 * 8, 24 * 8,		/* %ds, %es */
  25 * 4, 26 * 4,		/* %fs, %gs */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1,
  15 * 8			/* "orig_eax" */
};

/* Which ptrace request retrieves which registers?
   These apply to the corresponding SET requests as well.  */
d127 2
d136 1
a136 1
/* Fill GDB's register cache with the general-purpose register values
d140 1
a140 1
supply_gregset (elf_gregset_t *gregsetp)
d142 5
a146 1
  amd64_supply_native_gregset (current_regcache, gregsetp, -1);
d149 2
a150 2
/* Fill register REGNUM (if it is a general-purpose register) in
   *GREGSETP with the value in GDB's register cache.  If REGNUM is -1,
d154 1
a154 1
fill_gregset (elf_gregset_t *gregsetp, int regnum)
d156 6
a161 1
  amd64_collect_native_gregset (current_regcache, gregsetp, regnum);
d165 1
a165 1
   store their values in GDB's register cache.  */
d178 1
a178 1
/* Store all valid general-purpose registers in GDB's register cache
d182 1
a182 1
store_regs (int tid, int regnum)
d189 1
a189 1
  fill_gregset (&regs, regnum);
d198 31
a228 2
/* Fill GDB's register cache with the floating-point and SSE register
   values in *FPREGSETP.  */
d231 1
a231 1
supply_fpregset (elf_fpregset_t *fpregsetp)
d233 9
a241 1
  x86_64_supply_fxsave (current_regcache, -1, fpregsetp);
d245 20
a264 7
   *FPREGSETP with the value in GDB's register cache.  If REGNUM is
   -1, do this for all registers.  */

void
fill_fpregset (elf_fpregset_t *fpregsetp, int regnum)
{
  x86_64_fill_fxsave ((char *) fpregsetp, regnum);
d268 1
a268 1
   thier values in GDB's register cache.  */
d281 1
a281 1
/* Store all valid floating-point registers in GDB's register cache
d285 1
a285 1
store_fpregs (int tid, int regnum)
d292 1
a292 1
  fill_fpregset (&fpregs, regnum);
d301 1
a301 1
/* Fetch register REGNUM from the child process.  If REGNUM is -1, do
d306 1
a306 1
fetch_inferior_registers (int regnum)
d311 9
a319 3
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d321 1
a321 1
  if (regnum == -1 || amd64_native_gregset_supplies_p (regnum))
d324 1
a324 2
      if (regnum != -1)
	return;
d327 1
a327 1
  if (regnum == -1 || GETFPREGS_SUPPLIES (regnum))
d334 1
a334 1
		  "Got request for bad register number %d.", regnum);
d337 2
a338 2
/* Store register REGNUM back into the child process.  If REGNUM is
   -1, do this for all registers (including the floating-point and SSE
a339 1

d341 1
a341 1
store_inferior_registers (int regnum)
d346 2
a347 3
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d349 1
a349 1
  if (regnum == -1 || amd64_native_gregset_supplies_p (regnum))
d351 9
a359 3
      store_regs (tid, regnum);
      if (regnum != -1)
	return;
d362 1
a362 1
  if (regnum == -1 || GETFPREGS_SUPPLIES (regnum))
d364 1
a364 1
      store_fpregs (tid, regnum);
d369 1
a369 1
		  "Got request to store bad register number %d.", regnum);
d373 1
a373 5
static unsigned long
x86_64_linux_dr_get (int regnum)
{
  int tid;
  unsigned long value;
d375 1
a375 4
  /* FIXME: kettenis/2001-01-29: It's not clear what we should do with
     multi-threaded processes here.  For now, pretend there is just
     one thread.  */
  tid = PIDGET (inferior_ptid);
d377 2
a378 14
  /* FIXME: kettenis/2001-03-27: Calling perror_with_name if the
     ptrace call fails breaks debugging remote targets.  The correct
     way to fix this is to add the hardware breakpoint and watchpoint
     stuff to the target vectore.  For now, just return zero if the
     ptrace call fails.  */
  errno = 0;
  value = ptrace (PT_READ_U, tid,
		  offsetof (struct user, u_debugreg[regnum]), 0);
  if (errno != 0)
#if 0
    perror_with_name ("Couldn't read debug register");
#else
    return 0;
#endif
d380 2
a381 2
  return value;
}
d383 6
a388 4
static void
x86_64_linux_dr_set (int regnum, unsigned long value)
{
  int tid;
d390 15
a404 4
  /* FIXME: kettenis/2001-01-29: It's not clear what we should do with
     multi-threaded processes here.  For now, pretend there is just
     one thread.  */
  tid = PIDGET (inferior_ptid);
d406 1
a406 5
  errno = 0;
  ptrace (PT_WRITE_U, tid, offsetof (struct user, u_debugreg[regnum]), value);
  if (errno != 0)
    perror_with_name ("Couldn't write debug register");
}
d408 3
a410 2
void
x86_64_linux_dr_set_control (unsigned long control)
d412 13
a424 2
  x86_64_linux_dr_set (DR_CONTROL, control);
}
d426 9
a434 4
void
x86_64_linux_dr_set_addr (int regnum, CORE_ADDR addr)
{
  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);
d436 6
a441 1
  x86_64_linux_dr_set (DR_FIRSTADDR + regnum, addr);
d444 1
a444 4
void
x86_64_linux_dr_reset_addr (int regnum)
{
  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);
d446 7
a452 8
  x86_64_linux_dr_set (DR_FIRSTADDR + regnum, 0L);
}

unsigned long
x86_64_linux_dr_get_status (void)
{
  return x86_64_linux_dr_get (DR_STATUS);
}
d455 2
a456 7
ps_err_e
ps_get_thread_area (const struct ps_prochandle *ph,
                    lwpid_t lwpid, int idx, void **base)
{
/* This definition comes from prctl.h, but some kernels may not have it.  */
#ifndef PTRACE_ARCH_PRCTL
#define PTRACE_ARCH_PRCTL      30
d459 18
a476 16
  /* FIXME: ezannoni-2003-07-09 see comment above about include file order.
     We could be getting bogus values for these two.  */
  gdb_assert (FS < ELF_NGREG);
  gdb_assert (GS < ELF_NGREG);
  switch (idx)
    {
    case FS:
      if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_FS) == 0)
	return PS_OK;
      break;
    case GS:
      if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_GS) == 0)
	return PS_OK;
      break;
    default:                   /* Should not happen.  */
      return PS_BADADDR;
d478 2
a479 1
  return PS_ERR;               /* ptrace failed.  */
a480 1

d483 1
a483 1
child_post_startup_inferior (ptid_t ptid)
d485 1
a485 2
  i386_cleanup_dregs ();
  linux_child_post_startup_inferior (ptid);
a486 1

d488 2
a489 5
/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_x86_64_linux_nat (void);

void
_initialize_x86_64_linux_nat (void)
d491 1
a491 8
  amd64_native_gregset32_reg_offset = x86_64_linux_gregset32_reg_offset;
  amd64_native_gregset32_num_regs = I386_LINUX_NUM_REGS;
  amd64_native_gregset64_reg_offset = x86_64_linux_gregset64_reg_offset;

  gdb_assert (ARRAY_SIZE (x86_64_linux_gregset32_reg_offset)
	      == amd64_native_gregset32_num_regs);
  gdb_assert (ARRAY_SIZE (x86_64_linux_gregset64_reg_offset)
	      == amd64_native_gregset64_num_regs);
@


1.16.4.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d3 2
a4 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a69 1
  CS * 8, SS * 8,		/* %cs, %ss */
@


1.16.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d161 1
a161 1
      deprecated_read_register_gen (i, (char *) (regp + x86_64_regmap[i]));
@


1.16.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a458 11
/* SSE register?  */
/* FIXME: cagney/2002-11-15: Once the i386 and x86-64 are integrated,
   this will go.  */

int
i386_sse_regnum_p (int regnum)
{
  return (regnum < NUM_REGS
	  && (XMM0_REGNUM <= (regnum) && (regnum) < MXCSR_REGNUM));
}

@


1.16.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d458 11
@


1.16.2.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d161 1
a161 1
      regcache_collect (i, (char *) (regp + x86_64_regmap[i]));
@


1.16.2.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a27 1

d30 2
a37 11
/* Prototypes for supply_gregset etc.  */
#include "gregset.h"

#include "x86-64-tdep.h"

/* The register sets used in GNU/Linux ELF core-dumps are identical to
   the register sets used by `ptrace'.  The corresponding types are
   `elf_gregset_t' for the general-purpose registers (with
   `elf_greg_t' the type of a single GP register) and `elf_fpregset_t'
   for the floating-point registers.  */

d40 2
a41 2
static int regmap[] =
{
d50 76
a125 2
/* Which ptrace request retrieves which registers?
   These apply to the corresponding SET requests as well.  */
d128 1
a128 2
  (0 <= (regno) && (regno) < X86_64_NUM_GREGS)

d140 1
a140 1
supply_gregset (elf_gregset_t *gregsetp)
d145 2
a146 2
  for (i = 0; i < X86_64_NUM_GREGS; i++)
    supply_register (i, regp + regmap[i]);
d154 1
a154 1
fill_gregset (elf_gregset_t *gregsetp, int regno)
d159 3
a161 3
  for (i = 0; i < X86_64_NUM_GREGS; i++)
    if (regno == -1 || regno == i)
      regcache_collect (i, regp + regmap[i]);
d198 28
d227 2
a228 1
   values in *FPREGSETP.  */
d231 1
a231 1
supply_fpregset (elf_fpregset_t *fpregsetp)
d233 9
a241 1
  x86_64_supply_fxsave ((char *) fpregsetp);
d245 3
a247 2
   *FPREGSETP with the value in GDB's register array.  If REGNUM is
   -1, do this for all registers.  */
d250 1
a250 1
fill_fpregset (elf_fpregset_t *fpregsetp, int regnum)
d252 13
a264 1
  x86_64_fill_fxsave ((char *) fpregsetp, regnum);
d311 2
a312 3
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d338 1
a338 1
   do this for all registers (including the floating-point and SSE
a339 1

d346 2
a347 3
  tid = TIDGET (inferior_ptid);
  if (tid == 0)
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d373 6
a378 5
static unsigned long
x86_64_linux_dr_get (int regnum)
{
  int tid;
  unsigned long value;
d380 2
a381 4
  /* FIXME: kettenis/2001-01-29: It's not clear what we should do with
     multi-threaded processes here.  For now, pretend there is just
     one thread.  */
  tid = PIDGET (inferior_ptid);
d383 5
a387 13
  /* FIXME: kettenis/2001-03-27: Calling perror_with_name if the
     ptrace call fails breaks debugging remote targets.  The correct
     way to fix this is to add the hardware breakpoint and watchpoint
     stuff to the target vectore.  For now, just return zero if the
     ptrace call fails.  */
  errno = 0;
  value = ptrace (PT_READ_U, tid,
		  offsetof (struct user, u_debugreg[regnum]), 0);
  if (errno != 0)
#if 0
    perror_with_name ("Couldn't read debug register");
#else
    return 0;
d390 17
a406 2
  return value;
}
d409 2
a410 1
x86_64_linux_dr_set (int regnum, unsigned long value)
d412 31
a442 1
  int tid;
d444 1
a444 4
  /* FIXME: kettenis/2001-01-29: It's not clear what we should do with
     multi-threaded processes here.  For now, pretend there is just
     one thread.  */
  tid = PIDGET (inferior_ptid);
d446 8
a453 5
  errno = 0;
  ptrace (PT_WRITE_U, tid, offsetof (struct user, u_debugreg[regnum]), value);
  if (errno != 0)
    perror_with_name ("Couldn't write debug register");
}
d455 3
a457 5
void
x86_64_linux_dr_set_control (unsigned long control)
{
  x86_64_linux_dr_set (DR_CONTROL, control);
}
d459 21
a479 6
void
x86_64_linux_dr_set_addr (int regnum, CORE_ADDR addr)
{
  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);

  x86_64_linux_dr_set (DR_FIRSTADDR + regnum, addr);
d483 1
a483 1
x86_64_linux_dr_reset_addr (int regnum)
d485 1
a485 3
  gdb_assert (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR);

  x86_64_linux_dr_set (DR_FIRSTADDR + regnum, 0L);
d488 2
a489 2
unsigned long
x86_64_linux_dr_get_status (void)
d491 1
a491 1
  return x86_64_linux_dr_get (DR_STATUS);
@


1.16.2.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a34 9
#include <asm/prctl.h>
/* FIXME ezannoni-2003-07-09: we need <sys/reg.h> to be included after
   <asm/ptrace.h> because the latter redefines FS and GS for no apparent
   reason, and those definitions don't match the ones that libpthread_db
   uses, which come from <sys/reg.h>.  */
/* ezannoni-2003-07-09: I think this is fixed. The extraneous defs have
   been removed from ptrace.h in the kernel.  However, better safe than
   sorry.  */
#include <asm/ptrace.h>
a35 1
#include "gdb_proc_service.h"
d41 18
a58 1
#include "x86-64-linux-tdep.h"
d79 5
a83 1
  x86_64_linux_supply_gregset ((char *) gregsetp);
d93 6
a98 1
  x86_64_linux_fill_gregset ((char *) gregsetp, regno);
a334 31

extern ps_err_e
ps_get_thread_area (const struct ps_prochandle *ph,
                    lwpid_t lwpid, int idx, void **base)
{

/* This definition comes from prctl.h, but some kernels may not have it.  */
#ifndef PTRACE_ARCH_PRCTL
#define PTRACE_ARCH_PRCTL      30
#endif

  /* FIXME: ezannoni-2003-07-09 see comment above about include file order.
     We could be getting bogus values for these two.  */
  gdb_assert (FS < ELF_NGREG);
  gdb_assert (GS < ELF_NGREG);
  switch (idx)
    {
    case FS:
      if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_FS) == 0)
       return PS_OK;
      break;
    case GS:
      if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_GS) == 0)
       return PS_OK;
      break;
    default:                   /* Should not happen.  */
      return PS_BADADDR;
    }
  return PS_ERR;               /* ptrace failed.  */
}

@


1.16.2.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a27 1
#include "linux-nat.h"
a51 46
#include "i386-linux-tdep.h"
#include "amd64-nat.h"

/* Mapping between the general-purpose registers in GNU/Linux x86-64
   `struct user' format and GDB's register cache layout.  */

static int x86_64_linux_gregset64_reg_offset[] =
{
  RAX * 8, RBX * 8,		/* %rax, %rbx */
  RCX * 8, RDX * 8,		/* %rcx, %rdx */
  RSI * 8, RDI * 8,		/* %rsi, %rdi */
  RBP * 8, RSP * 8,		/* %rbp, %rsp */
  R8 * 8, R9 * 8,		/* %r8 ... */
  R10 * 8, R11 * 8,
  R12 * 8, R13 * 8,
  R14 * 8, R15 * 8,		/* ... %r15 */
  RIP * 8, EFLAGS * 8,		/* %rip, %eflags */
  DS * 8, ES * 8,		/* %ds, %es */
  FS * 8, GS * 8		/* %fs, %gs */
};


/* Mapping between the general-purpose registers in GNU/Linux x86-64
   `struct user' format and GDB's register cache layout for GNU/Linux
   i386.

   Note that most GNU/Linux x86-64 registers are 64-bit, while the
   GNU/Linux i386 registers are all 32-bit, but since we're
   little-endian we get away with that.  */

/* From <sys/reg.h> on GNU/Linux i386.  */
static int x86_64_linux_gregset32_reg_offset[] =
{
  10 * 8, 11 * 8,		/* %eax, %ecx */
  12 * 8, 13 * 8,		/* %edx, %ebx */
  19 * 8, 4 * 8,		/* %esp, %ebp */
  13 * 8, 14 * 8,		/* %esi, %edi */
  16 * 8, 18 * 8,		/* %eip, %eflags */
  17 * 8, 20 * 8,		/* %cs, %ss */
  23 * 8, 24 * 8,		/* %ds, %es */
  25 * 4, 26 * 4,		/* %fs, %gs */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1,
  15 * 8			/* "orig_eax" */
};
d56 3
d66 1
a66 1
/* Fill GDB's register cache with the general-purpose register values
d72 1
a72 1
  amd64_supply_native_gregset (current_regcache, gregsetp, -1);
d75 2
a76 2
/* Fill register REGNUM (if it is a general-purpose register) in
   *GREGSETP with the value in GDB's register cache.  If REGNUM is -1,
d80 1
a80 1
fill_gregset (elf_gregset_t *gregsetp, int regnum)
d82 1
a82 1
  amd64_collect_native_gregset (current_regcache, gregsetp, regnum);
d86 1
a86 1
   store their values in GDB's register cache.  */
d99 1
a99 1
/* Store all valid general-purpose registers in GDB's register cache
d103 1
a103 1
store_regs (int tid, int regnum)
d110 1
a110 1
  fill_gregset (&regs, regnum);
d119 1
a119 1
/* Fill GDB's register cache with the floating-point and SSE register
d125 1
a125 1
  x86_64_supply_fxsave ((const char *) fpregsetp, -1);
d129 1
a129 1
   *FPREGSETP with the value in GDB's register cache.  If REGNUM is
d139 1
a139 1
   thier values in GDB's register cache.  */
d152 1
a152 1
/* Store all valid floating-point registers in GDB's register cache
d156 1
a156 1
store_fpregs (int tid, int regnum)
d163 1
a163 1
  fill_fpregset (&fpregs, regnum);
d172 1
a172 1
/* Fetch register REGNUM from the child process.  If REGNUM is -1, do
d177 1
a177 1
fetch_inferior_registers (int regnum)
d186 1
a186 1
  if (regnum == -1 || amd64_native_gregset_supplies_p (regnum))
d189 2
a190 2
      if (regnum != -1)
	return;
d193 7
a199 1
  if (regnum == -1 || GETFPREGS_SUPPLIES (regnum))
d206 1
a206 1
		  "Got request for bad register number %d.", regnum);
d209 2
a210 2
/* Store register REGNUM back into the child process.  If REGNUM is
   -1, do this for all registers (including the floating-point and SSE
d214 1
a214 1
store_inferior_registers (int regnum)
d223 8
a230 1
  if (regnum == -1 || amd64_native_gregset_supplies_p (regnum))
d232 2
a233 3
      store_regs (tid, regnum);
      if (regnum != -1)
	return;
d236 1
a236 1
  if (regnum == -1 || GETFPREGS_SUPPLIES (regnum))
d238 1
a238 1
      store_fpregs (tid, regnum);
d243 1
a243 1
		  "Got request to store bad register number %d.", regnum);
a318 1

d320 1
a320 1
ps_err_e
d324 1
d338 1
a338 1
	return PS_OK;
d342 1
a342 1
	return PS_OK;
a348 1

a349 23
void
child_post_startup_inferior (ptid_t ptid)
{
  i386_cleanup_dregs ();
  linux_child_post_startup_inferior (ptid);
}


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_x86_64_linux_nat (void);

void
_initialize_x86_64_linux_nat (void)
{
  amd64_native_gregset32_reg_offset = x86_64_linux_gregset32_reg_offset;
  amd64_native_gregset32_num_regs = I386_LINUX_NUM_REGS;
  amd64_native_gregset64_reg_offset = x86_64_linux_gregset64_reg_offset;

  gdb_assert (ARRAY_SIZE (x86_64_linux_gregset32_reg_offset)
	      == amd64_native_gregset32_num_regs);
  gdb_assert (ARRAY_SIZE (x86_64_linux_gregset64_reg_offset)
	      == amd64_native_gregset64_num_regs);
}
@


1.16.2.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d169 1
a169 1
  x86_64_supply_fxsave (current_regcache, -1, fpregsetp);
@


1.16.2.9
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d3 2
a4 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a69 1
  CS * 8, SS * 8,		/* %cs, %ss */
@


1.15
log
@2002-09-03  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-linux-tdep.c: Include gdb_string.h
	* x86-64-linux-nat.c: Ditto.
@
text
@d46 1
a46 1
  RIP, EFLAGS,
@


1.15.2.1
log
@2002-09-18  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-linux-nat.c (x86_64_regmap): Added CS and SS
	registers.
@
text
@d46 1
a46 1
  RIP, EFLAGS, CS, SS, 
@


1.14
log
@2002-06-20  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-tdep.c (x86_64_register_nr2name): Rename to
	x86_64_register_name. Return type changed to 'const char *'.
	(x86_64_register_name2nr): Rename to x86_64_register_number.
	(x86_64_gdbarch_init): Update to reflect the change.
	* x86-64-tdep.h: Ditto.
	* x86-64-linux-nat.c (x86_64_fxsave_offset)
	(supply_fpregset): Ditto.
@
text
@d29 1
@


1.13
log
@2002-06-07  Michal Ludvig  <mludvig@@suse.cz>

	* x86-64-linux-nat.c (x86_64_fxsave_offset): New.
	(supply_fpregset, fill_fpregset): Don't call i387_*_fxsave,
	better do the things actually here.
	* x86-64-tdep.c (x86_64_register_name2nr): New.
	(x86_64_register_name): Renamed to x86_64_register_nr2name.
	(x86_64_gdbarch_init): Respect the above change.
	* x86-64-tdep.h (x86_64_register_name2nr)
	(x86_64_register_nr2name): Add prototypes.
	* config/i386/x86-64linux.mt (TDEPFILES): Remove i387-tdep.o.
@
text
@d200 1
a200 1
  char *reg_name;
d205 1
a205 1
  reg_name = x86_64_register_nr2name (regnum);
d234 2
a235 2
  reg_st0 = x86_64_register_name2nr ("st0");
  reg_mxcsr = x86_64_register_name2nr ("mxcsr");
@


1.12
log
@* Makefile.in (ALLDEPFILES): Remove i387-nat.c.
(i387-nat.o): Delete dependency list.
(go32-nat.o): Change i387-nat.h to i387-tdep.h.
(x86-64-linux-nat.o): Likewise.
* i387-nat.c: Delete file, moving contents to...
* i387-tdep.c: ...here.
* i387-nat.h: Rename...
* i387-tdep.h: ...to this.
* go32-nat.c: Include i387-tdep.h instead of i387-nat.h.
* i386-linux-nat.c: Likewise.
* i386bsd-nat.c: Likewise.
* i386gnu-nat.c: Likewise.
* i386nbsd-nat.c: Likewise.
* i386v4-nat.c: Likewise.
* x86-64-linux-nat.c: Likewise.
* config/i386/fbsd.mh (NATDEPFILES): Remove i387-nat.o.
* config/i386/go32.mh (NATDEPFILES): Likewise.
* config/i386/i386gnu.mh (NATDEPFILES): Likewise.
* config/i386/i386sol2.mh (NATDEPFILES): Likewise.
* config/i386/i386v42mp.mh (NATDEPFILES): Likewise.
* config/i386/linux.mh (NATDEPFILES): Likewise.
* config/i386/nbsd.mh (NATDEPFILES): Likewise.
* config/i386/nbsdelf.mh (NATDEPFILES): Likewise.
* config/i386/obsd.mh (NATDEPFILES): Likewise.
* config/i386/x86-64linux.mh (NATDEPFILES): Likewise.
@
text
@a27 1
#include "i387-tdep.h"
d197 31
a227 2
/* Fill GDB's register array with the floating-point register values in
   *FPREGSETP.  */
d230 1
a230 1
supply_fpregset (elf_fpregset_t * fpregsetp)
d232 9
a240 1
  i387_supply_fxsave ((char *) fpregsetp);
d243 4
a246 3
/* Fill register REGNO (if it is a floating-point register) in
   *FPREGSETP with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */
d249 1
a249 1
fill_fpregset (elf_fpregset_t * fpregsetp, int regno)
d251 13
a263 1
  i387_fill_fxsave ((char *) fpregsetp, regno);
@


1.12.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d28 1
d198 2
a199 31
static void *
x86_64_fxsave_offset (elf_fpregset_t * fxsave, int regnum)
{
  char *reg_name;
  int reg_index;

  gdb_assert (x86_64_num_gregs - 1 < regnum && regnum < x86_64_num_regs);

  reg_name = x86_64_register_nr2name (regnum);

  if (reg_name[0] == 's' && reg_name[1] == 't')
    {
      reg_index = reg_name[2] - '0';
      return &fxsave->st_space[reg_index * 2];
    }

  if (reg_name[0] == 'x' && reg_name[1] == 'm' && reg_name[2] == 'm')
    {
      reg_index = reg_name[3] - '0';
      return &fxsave->xmm_space[reg_index * 4];
    }

  if (strcmp (reg_name, "mxcsr") == 0)
    return &fxsave->mxcsr;

  return NULL;
}

/* Fill GDB's register array with the floating-point and SSE register
   values in *FXSAVE.  This function masks off any of the reserved
   bits in *FXSAVE.  */
d202 1
a202 1
supply_fpregset (elf_fpregset_t * fxsave)
d204 1
a204 9
  int i, reg_st0, reg_mxcsr;

  reg_st0 = x86_64_register_name2nr ("st0");
  reg_mxcsr = x86_64_register_name2nr ("mxcsr");

  gdb_assert (reg_st0 > 0 && reg_mxcsr > reg_st0);

  for (i = reg_st0; i <= reg_mxcsr; i++)
    supply_register (i, x86_64_fxsave_offset (fxsave, i));
d207 3
a209 4
/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FXSAVE with the value in GDB's register array.  If REGNUM is -1, do
   this for all registers.  This function doesn't touch any of the
   reserved bits in *FXSAVE.  */
d212 1
a212 1
fill_fpregset (elf_fpregset_t * fxsave, int regnum)
d214 1
a214 13
  int i, last_regnum = MXCSR_REGNUM;
  void *ptr;

  if (gdbarch_tdep (current_gdbarch)->num_xmm_regs == 0)
    last_regnum = FOP_REGNUM;

  for (i = FP0_REGNUM; i <= last_regnum; i++)
    if (regnum == -1 || regnum == i)
      {
	ptr = x86_64_fxsave_offset (fxsave, i);
	if (ptr)
	  regcache_collect (i, ptr);
      }
@


1.12.4.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d200 1
a200 1
  const char *reg_name;
d205 1
a205 1
  reg_name = x86_64_register_name (regnum);
d234 2
a235 2
  reg_st0 = x86_64_register_number ("st0");
  reg_mxcsr = x86_64_register_number ("mxcsr");
@


1.12.4.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a28 1
#include "gdb_string.h"
d45 1
a45 1
  RIP, EFLAGS, CS, SS, 
@


1.12.4.4
log
@merge from mainline
@
text
@d161 1
a161 1
      deprecated_read_register_gen (i, (char *) (regp + x86_64_regmap[i]));
@


1.12.2.1
log
@merge from trunk
@
text
@d28 1
d198 2
a199 31
static void *
x86_64_fxsave_offset (elf_fpregset_t * fxsave, int regnum)
{
  char *reg_name;
  int reg_index;

  gdb_assert (x86_64_num_gregs - 1 < regnum && regnum < x86_64_num_regs);

  reg_name = x86_64_register_nr2name (regnum);

  if (reg_name[0] == 's' && reg_name[1] == 't')
    {
      reg_index = reg_name[2] - '0';
      return &fxsave->st_space[reg_index * 2];
    }

  if (reg_name[0] == 'x' && reg_name[1] == 'm' && reg_name[2] == 'm')
    {
      reg_index = reg_name[3] - '0';
      return &fxsave->xmm_space[reg_index * 4];
    }

  if (strcmp (reg_name, "mxcsr") == 0)
    return &fxsave->mxcsr;

  return NULL;
}

/* Fill GDB's register array with the floating-point and SSE register
   values in *FXSAVE.  This function masks off any of the reserved
   bits in *FXSAVE.  */
d202 1
a202 1
supply_fpregset (elf_fpregset_t * fxsave)
d204 1
a204 9
  int i, reg_st0, reg_mxcsr;

  reg_st0 = x86_64_register_name2nr ("st0");
  reg_mxcsr = x86_64_register_name2nr ("mxcsr");

  gdb_assert (reg_st0 > 0 && reg_mxcsr > reg_st0);

  for (i = reg_st0; i <= reg_mxcsr; i++)
    supply_register (i, x86_64_fxsave_offset (fxsave, i));
d207 3
a209 4
/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FXSAVE with the value in GDB's register array.  If REGNUM is -1, do
   this for all registers.  This function doesn't touch any of the
   reserved bits in *FXSAVE.  */
d212 1
a212 1
fill_fpregset (elf_fpregset_t * fxsave, int regnum)
d214 1
a214 13
  int i, last_regnum = MXCSR_REGNUM;
  void *ptr;

  if (gdbarch_tdep (current_gdbarch)->num_xmm_regs == 0)
    last_regnum = FOP_REGNUM;

  for (i = FP0_REGNUM; i <= last_regnum; i++)
    if (regnum == -1 || regnum == i)
      {
	ptr = x86_64_fxsave_offset (fxsave, i);
	if (ptr)
	  regcache_collect (i, ptr);
      }
@


1.12.2.2
log
@More merging.
@
text
@d200 1
a200 1
  const char *reg_name;
d205 1
a205 1
  reg_name = x86_64_register_name (regnum);
d234 2
a235 2
  reg_st0 = x86_64_register_number ("st0");
  reg_mxcsr = x86_64_register_number ("mxcsr");
@


1.11
log
@2002-05-07  Michal Ludvig  <mludvig@@suse.cz>
	* dwarf2cfi.c: Code cleanup, removed unused variables,
	added default labels to switch {} statements.
	* x86-64-tdep.c: Ditto.
	* x86-64-linux-nat.c: Ditto.
@
text
@d28 1
a28 1
#include "i387-nat.h"
@


1.10
log
@2002-04-29  Michal Ludvig  <mludvig@@suse.cz>
	* x86-64-linux-nat.c (fill_gregset): Explicit cast to avoid warning.
	* x86-64-tdep.c (i386_gdbarch_init): Ditto.
	(x86_64_register_info_table): Added comments with register numbers.
@
text
@a408 6
/* Record the value of the debug control register.  */
static long debug_control_mirror;

/* Record which address associates with which register.  */
static CORE_ADDR address_lookup[DR_LASTADDR - DR_FIRSTADDR + 1];

@


1.9
log
@	* x86-64-linux-nat.c (child_resume, child_xfer_memory): Delete.
	(PTRACE_XFER_TYPE): Moved to config/i386/nm-x86-64.h.
	(kernel_u_size): Added.
	* config/i386/nm-x86-64.h (CHILD_XFER_MEMORY, CHILD_RESUME): Delete.
	(PTRACE_XFER_TYPE): Moved here from config/i386/nm-x86-64.h.
@
text
@d161 1
a161 1
      read_register_gen (i, regp + x86_64_regmap[i]);
a448 1
  
@


1.8
log
@* x86-64-linux-nat.c (child_xfer_memory): x86-64 ptrace() ABI change sync
@
text
@a130 2

#define PTRACE_XFER_TYPE unsigned long
a344 156
/* Resume execution of the inferior process.
   If STEP is nonzero, single-step it.
   If SIGNAL is nonzero, give it that signal.  */

void
child_resume (ptid_t ptid, int step, enum target_signal signal)
{
  int pid = PIDGET (ptid);
  int request = PTRACE_CONT;

  if (pid == -1)
    /* Resume all threads.  */
    /* I think this only gets used in the non-threaded case, where "resume
       all threads" and "resume inferior_ptid" are the same.  */
    pid = PIDGET (inferior_ptid);

  if (step)
    {
      CORE_ADDR pc = read_pc_pid (pid_to_ptid (pid));
      unsigned char buf[LINUX_SYSCALL_LEN];

      request = PTRACE_SINGLESTEP;

      /* Returning from a signal trampoline is done by calling a
         special system call (sigreturn or rt_sigreturn, see
         i386-linux-tdep.c for more information).  This system call
         restores the registers that were saved when the signal was
         raised, including %eflags.  That means that single-stepping
         won't work.  Instead, we'll have to modify the signal context
         that's about to be restored, and set the trace flag there.  */

      /* First check if PC is at a system call.  */
      if (read_memory_nobpt (pc, (char *) buf, LINUX_SYSCALL_LEN) == 0
	  && memcmp (buf, linux_syscall, LINUX_SYSCALL_LEN) == 0)
	{
	  int syscall =
	    read_register_pid (LINUX_SYSCALL_REGNUM, pid_to_ptid (pid));

	  /* Then check the system call number.  */
	  if (syscall == SYS_rt_sigreturn)
	    {
	      CORE_ADDR sp = read_register (SP_REGNUM);
	      CORE_ADDR addr = sp;
	      unsigned long int eflags;

	      addr +=
		sizeof (struct siginfo) + LINUX_UCONTEXT_SIGCONTEXT_OFFSET;

	      /* Set the trace flag in the context that's about to be
	         restored.  */
	      addr += LINUX_SIGCONTEXT_EFLAGS_OFFSET;
	      read_memory (addr, (char *) &eflags, 8);
	      eflags |= 0x0100;
	      write_memory (addr, (char *) &eflags, 8);
	    }
	}
    }

  if (ptrace (request, pid, 0, target_signal_to_host (signal)) == -1)
    perror_with_name ("ptrace");
}


/* Copy LEN bytes to or from inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR.   Copy to inferior if
   WRITE is nonzero.  TARGET is ignored.

   Returns the length copied, which is either the LEN argument or zero.
   This xfer function does not do partial moves, since child_ops
   doesn't allow memory operations to cross below us in the target stack
   anyway.  */

int
child_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		   struct mem_attrib *attrib, struct target_ops *target)
{
  register int i;
  /* Round starting address down to longword boundary.  */
  register CORE_ADDR addr = memaddr & -sizeof (PTRACE_XFER_TYPE);
  /* Round ending address up; get number of longwords that makes.  */
  register int count
    = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
    / sizeof (PTRACE_XFER_TYPE);
  /* Allocate buffer of that many longwords.  */
  /* FIXME (alloca): This code, cloned from infptrace.c, is unsafe
     because it uses alloca to allocate a buffer of arbitrary size.
     For very large xfers, this could crash GDB's stack.  */
  register PTRACE_XFER_TYPE *buffer
    = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));

  if (write)
    {
      /* Fill start and end extra bytes of buffer with existing memory data.  */
      if (addr != memaddr || len < (int) sizeof (PTRACE_XFER_TYPE))
	{
	  /* Need part of initial word -- fetch it.  */
	  buffer[0] = ptrace (PT_READ_I, PIDGET (inferior_ptid),
			      (PTRACE_ARG3_TYPE) addr, 0);
	}

      if (count > 1)		/* FIXME, avoid if even boundary */
	{
	  buffer[count - 1] = ptrace (PT_READ_I, PIDGET (inferior_ptid),
				      ((PTRACE_ARG3_TYPE)
				       (addr +
					(count -
					 1) * sizeof (PTRACE_XFER_TYPE))), 0);
	}

      /* Copy data to be written over corresponding part of buffer */

      memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
	      myaddr, len);

      /* Write the entire buffer.  */

      for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
	{
	  errno = 0;
	  ptrace (PT_WRITE_D, PIDGET (inferior_ptid),
		  (PTRACE_ARG3_TYPE) addr, buffer[i]);
	  if (errno)
	    {
	      /* Using the appropriate one (I or D) is necessary for
	         Gould NP1, at least.  */
	      errno = 0;
	      ptrace (PT_WRITE_I, PIDGET (inferior_ptid),
		      (PTRACE_ARG3_TYPE) addr, buffer[i]);
	    }
	  if (errno)
	    return 0;
	}
#ifdef CLEAR_INSN_CACHE
      CLEAR_INSN_CACHE ();
#endif
    }
  else
    {
      /* Read all the longwords */
      for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
	{
	  errno = 0;
	  buffer[i] = ptrace (PT_READ_I, PIDGET (inferior_ptid),
			      (PTRACE_ARG3_TYPE) addr, 0);
	  if (errno)
	    return 0;
	}

      /* Copy appropriate bytes out of the buffer.  */
      memcpy (myaddr,
	      (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
	      len);
    }
  return len;
}

a345 1

d443 7
@


1.7
log
@	* x86-64-tdep.h (X86_64_NUM_REGS, X86_64_NUM_GREGS): Delete #defines.
	(x86_64_num_regs, x86_64_num_gregs): Added extern variables.
	* x86-64-linux-nat.c (x86_64_regmap): Swapped RBX <> RDX, added DS, ES, FS, GS.
	(x86_64_linux_dr_get_status, supply_gregset),
	(fill_gregset): Changed X86_64_NUM_GREGS to x86_64_num_gregs.
	* x86-64-tdep.c (x86_64_register_raw_size_table): Delete.
	(x86_64_register_info_table): Add.
	(X86_64_NUM_REGS, X86_64_NUM_GREGS): Add.
	(x86_64_register_raw_size, x86_64_register_virtual_type),
	(x86_64_register_name, _initialize_x86_64_tdep): Changed to reflect new
	general x86_64_register_info_table.
	(i386_gdbarch_init): gdbarch_register_bytes is now set
	dynamicaly during initialization.
	* regformats/reg-x86-64.dat: Synced with changes to registers above.
	* gdbserver/linux-x86-64-low.c: Ditto.
@
text
@d46 1
a46 1
  RIP, EFLAGS, 
d90 1
a90 2
  ptrace (PT_WRITE_U, tid,
	  offsetof (struct user, u_debugreg[regnum]), value);
d175 1
a175 1
      perror_with_name ("Couldn't get registers");
d443 2
a444 2
	  ptrace (PT_READ_I, PIDGET (inferior_ptid),
		  (PTRACE_ARG3_TYPE) addr, buffer);
d449 5
a453 4
	  ptrace (PT_READ_I, PIDGET (inferior_ptid),
		  ((PTRACE_ARG3_TYPE)
		   (addr + (count - 1) * sizeof (PTRACE_XFER_TYPE))),
		  buffer + count - 1);
d489 2
a490 2
	  ptrace (PT_READ_I, PIDGET (inferior_ptid),
		  (PTRACE_ARG3_TYPE) addr, buffer + i);
d583 1
a583 1
  if (IS_FP_REGNUM(regnum))
d588 1
a588 1
  else if (IS_SSE_REGNUM(regnum))
@


1.6
log
@        * x86-64-tdep.h (sys/reg.h, x86_64_regmap): Moved to x86-64-linux-nat.c
        * x86-64-linux-nat.c (sys/reg.h, x86_64_regmap): Moved here
        from x86-64-tdep.h
@
text
@d42 1
a42 1
  RAX, RDX, RCX, RBX,
d46 2
a47 1
  RIP, EFLAGS
d129 1
a129 1
  (0 <= (regno) && (regno) <= 17)
d148 1
a148 1
  for (i = 0; i < X86_64_NUM_GREGS; i++)
d162 1
a162 1
  for (i = 0; i < X86_64_NUM_GREGS; i++)
@


1.5
log
@s/Linux/.../
Fix PR gdb/378.
@
text
@d36 12
@


1.5.2.1
log
@	* x86-64-tdep.c (x86_64_skip_prologue): Rewritten from scratch.
	* x86-64-tdep.h (X86_64_NUM_REGS, X86_64_NUM_GREGS): Delete #defines.
	(x86_64_num_regs, x86_64_num_gregs): Added extern variables.
	* x86-64-linux-nat.c (x86_64_regmap): Swapped RBX <> RDX, added DS, ES, FS, GS.
	(x86_64_linux_dr_get_status, supply_gregset),
	(fill_gregset): Changed X86_64_NUM_GREGS to x86_64_num_gregs.
	* x86-64-tdep.c (x86_64_register_raw_size_table): Delete.
	(x86_64_register_info_table): Add.
	(X86_64_NUM_REGS, X86_64_NUM_GREGS): Add.
	(x86_64_register_raw_size, x86_64_register_virtual_type),
	(x86_64_register_name, _initialize_x86_64_tdep): Changed to reflect new
	general x86_64_register_info_table.
	(i386_gdbarch_init): gdbarch_register_bytes is now set
	dynamicaly during initialization.
	* regformats/reg-x86-64.dat: Synced with changes to registers above.
	* gdbserver/linux-x86-64-low.c: Ditto.
@
text
@a35 13
#include <sys/reg.h>

/* Mapping between the general-purpose registers in `struct user'
   format and GDB's register array layout.  */

static int x86_64_regmap[] = {
  RAX, RBX, RCX, RDX,
  RSI, RDI, RBP, RSP,
  R8, R9, R10, R11,
  R12, R13, R14, R15,
  RIP, EFLAGS, 
  DS, ES, FS, GS
};
d116 1
a116 1
  (0 <= (regno) && (regno) < x86_64_num_gregs)
d135 1
a135 1
  for (i = 0; i < x86_64_num_gregs; i++)
d149 1
a149 1
  for (i = 0; i < x86_64_num_gregs; i++)
@


1.5.2.2
log
@* x86-64-linux-nat.c (child_xfer_memory): x86-64 ptrace() ABI change sync with glibc.
@
text
@d46 1
a46 1
  RIP, EFLAGS,
d90 2
a91 1
  ptrace (PT_WRITE_U, tid, offsetof (struct user, u_debugreg[regnum]), value);
d176 1
a176 1
    perror_with_name ("Couldn't get registers");
d444 2
a445 2
	  buffer[0] = ptrace (PT_READ_I, PIDGET (inferior_ptid),
			      (PTRACE_ARG3_TYPE) addr, 0);
d450 4
a453 5
	  buffer[count - 1] = ptrace (PT_READ_I, PIDGET (inferior_ptid),
				      ((PTRACE_ARG3_TYPE)
				       (addr +
					(count -
					 1) * sizeof (PTRACE_XFER_TYPE))), 0);
d489 2
a490 2
	  buffer[i] = ptrace (PT_READ_I, PIDGET (inferior_ptid),
			      (PTRACE_ARG3_TYPE) addr, 0);
d583 1
a583 1
  if (IS_FP_REGNUM (regnum))
d588 1
a588 1
  else if (IS_SSE_REGNUM (regnum))
@


1.5.2.3
log
@	* x86-64-linux-nat.c (child_resume, child_xfer_memory): Delete.
	(PTRACE_XFER_TYPE): Moved to config/i386/nm-x86-64.h.
	(kernel_u_size): Added.
	* config/i386/nm-x86-64.h (CHILD_XFER_MEMORY, CHILD_RESUME): Delete.
	(PTRACE_XFER_TYPE): Moved here from config/i386/nm-x86-64.h.
@
text
@d131 2
d347 156
d504 1
a601 7

int
kernel_u_size (void)
{
  return (sizeof (struct user));
}
  
@


1.5.2.4
log
@Merge with mainline.
@
text
@d28 1
d161 1
a161 1
      read_register_gen (i, (char *) (regp + x86_64_regmap[i]));
d198 2
a199 31
static void *
x86_64_fxsave_offset (elf_fpregset_t * fxsave, int regnum)
{
  const char *reg_name;
  int reg_index;

  gdb_assert (x86_64_num_gregs - 1 < regnum && regnum < x86_64_num_regs);

  reg_name = x86_64_register_name (regnum);

  if (reg_name[0] == 's' && reg_name[1] == 't')
    {
      reg_index = reg_name[2] - '0';
      return &fxsave->st_space[reg_index * 2];
    }

  if (reg_name[0] == 'x' && reg_name[1] == 'm' && reg_name[2] == 'm')
    {
      reg_index = reg_name[3] - '0';
      return &fxsave->xmm_space[reg_index * 4];
    }

  if (strcmp (reg_name, "mxcsr") == 0)
    return &fxsave->mxcsr;

  return NULL;
}

/* Fill GDB's register array with the floating-point and SSE register
   values in *FXSAVE.  This function masks off any of the reserved
   bits in *FXSAVE.  */
d202 1
a202 1
supply_fpregset (elf_fpregset_t * fxsave)
d204 1
a204 9
  int i, reg_st0, reg_mxcsr;

  reg_st0 = x86_64_register_number ("st0");
  reg_mxcsr = x86_64_register_number ("mxcsr");

  gdb_assert (reg_st0 > 0 && reg_mxcsr > reg_st0);

  for (i = reg_st0; i <= reg_mxcsr; i++)
    supply_register (i, x86_64_fxsave_offset (fxsave, i));
d207 3
a209 4
/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FXSAVE with the value in GDB's register array.  If REGNUM is -1, do
   this for all registers.  This function doesn't touch any of the
   reserved bits in *FXSAVE.  */
d212 1
a212 1
fill_fpregset (elf_fpregset_t * fxsave, int regnum)
d214 1
a214 13
  int i, last_regnum = MXCSR_REGNUM;
  void *ptr;

  if (gdbarch_tdep (current_gdbarch)->num_xmm_regs == 0)
    last_regnum = FOP_REGNUM;

  for (i = FP0_REGNUM; i <= last_regnum; i++)
    if (regnum == -1 || regnum == i)
      {
	ptr = x86_64_fxsave_offset (fxsave, i);
	if (ptr)
	  regcache_collect (i, ptr);
      }
d409 6
d449 1
@


1.4
log
@2002-01-20  Jiri Smid  <smid@@suse.cz>

	* config/i386/x86-64linux.mh (NATDEPFILES): x86-64-nat.o removed.
	* x86-64-linux-nat.c (x86_64_register_u_addr): New function.
	* config/i386/nm-x86-64.h (ATTACH_LWP): Removed.
	* Makefile.in (x86-64-tdep.o, x86-64-linux-tdep.o,
	x86-64-linux-nat.o): Fix dependencies.
@
text
@d1 1
a1 1
/* Native-dependent code for Linux/x86-64.
d112 2
a113 2
/* The register sets used in Linux ELF core-dumps are identical to the
   register sets used by `ptrace'.  */
d250 1
a250 1
  /* Linux LWP ID's are process ID's.  */
d285 1
a285 1
  /* Linux LWP ID's are process ID's.  */
d502 1
a502 1
   REG_ADDR isn't used on Linux.  */
d540 1
a540 1
/* Register that we are able to handle Linux ELF core file formats.  */
@


1.3
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d561 23
@


1.2
log
@2002-01-07  Michael Snyder  <msnyder@@redhat.com>

	* infptrace.c (GDB_MAX_ALLOCA): New define.
	(child_xfer_memory): Use xmalloc/xfree instead of alloca if the
	size of the buffer exceeds GDB_MAX_ALLOCA (default 1 megabyte,
	can be overridden with whatever value is appropriate to the host).
	* infttrace.c (child_xfer_memory): Add FIXME warning about use of
	alloca to allocate potentially large buffer.
	* rs6000-nat.c (child_xfer_memory): Ditto.
	* symm-nat.c (child_xfer_memory): Ditto.
	* x86-64-linux-nat.c (child_xfer_memory): Ditto.
@
text
@d2 3
a4 2
   Copyright 2001
   Free Software Foundation, Inc.
d409 1
a409 2
		   struct mem_attrib *attrib ATTRIBUTE_UNUSED,
		   struct target_ops *target)
@


1.1
log
@* config/i386/x86-64linux.mh: New file.
* config/i386/x86-64linux.mt: New file.
* config/i386/nm-x86_64.h: New file.
* x86-64-linux-tdep.c: New file.
* x86-64-linux-nat.c: New file.
* x86-64-tdep.c: New file.
* x86-64-tdep.h: New file.
* config/djgpp/fnchange.lst: Add entries for x86_64-linux-tdep.c
and x86_64-linux-nat.c
* Makefile.in: Add x86_64-linux-tdep.o, x86_64-tdep.o,
x86_64-linux-tdep.o, x86_64-nat.o, update dependencies.
@
text
@d150 1
a150 2
      *(regp + x86_64_regmap[i]) =
	*(elf_greg_t *) & registers[REGISTER_BYTE (i)];
d419 3
@

